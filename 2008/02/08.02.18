00:00:31 <glguy> ?seen dons
00:00:32 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 20m 55s ago.
00:10:01 <OceanSpray> Silence.
00:11:18 <BMeph> Yep - it's good for sleeping. So, good night. ;)
00:12:48 <dons> glguy: yo
00:21:31 <sjw> ?hoogle (m a, m b) -> m (a, b)
00:21:31 <lambdabot> Prelude.fst :: (a, b) -> a
00:21:31 <lambdabot> Prelude.snd :: (a, b) -> b
00:21:31 <lambdabot> Data.Tuple.fst :: (a, b) -> a
00:21:49 <sjw> ?hoogle Monad m => (m a, m b) -> m (a, b)
00:21:49 <lambdabot> Prelude.fst :: (a, b) -> a
00:21:49 <lambdabot> Prelude.snd :: (a, b) -> b
00:21:49 <lambdabot> Data.Tuple.fst :: (a, b) -> a
00:22:03 <sjw> well that doesn't help
00:22:49 <Cale> :t liftM2 (,)
00:22:50 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
00:22:59 <Cale> :t uncurry (liftM2 (,))
00:22:59 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
00:23:21 <Cale> sjw: ^^
00:23:33 <sjw> yeah, I wondered if there was an existing function
00:23:51 <sjw> :t uncurry . liftM2 (,)
00:23:51 <lambdabot> forall b a1 a2. (b -> a1) -> (b -> a2, b) -> (a1, a2)
00:24:09 <sjw> not quite
00:24:19 <Cale> :t uncurry $ liftM2 (,)
00:24:19 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
00:33:36 <ac> @seen jedbrown
00:33:37 <lambdabot> jedbrown is in #haskell. I last heard jedbrown speak 10h 35m 16s ago.
00:33:59 <jedbrown> ac: Hey
00:34:52 <ac> does it bug anybody that "elems array" orders elements in a multidimensional array opposite to how C does?
00:35:30 <ac> and that indexes for Array.Storeable are also reversed, so if you pass an image to a C program, it will be rotated 90 degrees :-P
00:36:10 <ac> jedbrown: do you have a "CArray -> ByteString" function?
00:36:56 <ac> jedbrown: oo, you have reshape. How handy
00:37:44 <jedbrown> ac: I don't.  A CArray -> StorableVector is probably more handy.  What do you mean about ordering.  It looks like row-major (i.e. C-style) ordering to me.
00:39:20 <ac> really? I thought "array ! (10, 0)" on a 10xN array would index the 100th element, where in C, "array[10][0]" would index the 10th.
00:39:42 <jedbrown> You can make a CArray from ByteString using unsafeForeignPtrToCArray.
00:39:58 <ac> jedbrown: that sounds scary. It also wouldn't work for lazy ByteStrings
00:40:41 <jedbrown> ac: (and castPtr).  I can wrap that up nicely, but then CArray depends on bytestring for just that feature.  However, bytestring is ubiquitous.
00:41:03 <jedbrown> ac: You have the C ordering wrong.  Fortran is like that.
00:41:25 <ac> figures. It's been a while since I've coded C. Huh. Why is my image rotated 90 degrees? :-P
00:41:51 <jedbrown> Also, array[10,0] would be out of bounds!  array[9][N-1] would be the last element ;)
00:42:17 <ac> damn off by one errors
00:43:43 <boegel> @seen shapr
00:43:43 <lambdabot> shapr is in #scannedinavian, #haskell-blah and #haskell. I last heard shapr speak 13h 45m 40s ago.
00:45:34 <jedbrown> ac: If you would like safe and unsafe Array -> ByteString and ByteString -> Array functions, I'd be happy to add them.  CArray is just a block of memory (like ByteString) so it would be easy.
00:47:09 <jedbrown> ac: Heh, since ByteString is immutable, they can be O(1) and safe.  But maybe it would be better to just make them instances of Binary.
00:49:37 <jedbrown> ac: They can have O(1) encode and decode.  Is that all you want?
00:59:33 <ac> jedbrown: yeah actually
01:00:11 <jedbrown> ac: I'll let you know when it's added.
01:00:16 <ac> awesome
01:06:13 <encryptio> @pl \x -> a x * b x
01:06:14 <lambdabot> liftM2 (*) a b
01:08:59 <encryptio> :t liftM2
01:09:01 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
01:17:04 <jfredett> holy crap, my algorithm with lists = 2 hours, my algorithm with sets. 6 minutes.
01:17:13 <jfredett> and thats the unoptimized version.
01:17:44 <kfish> jfredett, any idea why?
01:17:50 <wli> jfredett: What algorithm?
01:18:16 <jfredett> wli: it's a algorithm for solving project euler problem 31
01:19:02 <wli> jfredett: URL to problem?
01:19:07 <jfredett> it's basically optimized brute force
01:19:12 <jfredett> wli, hang on
01:19:32 <kfish> with backtracking?
01:19:33 <jfredett> kfish: because set operations are much faster than list ones, I guess
01:19:42 <jfredett> kfish: no, no backtracking
01:20:02 <jfredett> it's linear now the original algorithm was O(n^2)
01:20:08 <kfish> jfredett, hmm, i'm thinking more about laziness, but perhaps it depends on what operations you're doing :-)
01:20:27 <jfredett> http://projecteuler.net/index.php?section=problems&id=31
01:20:28 <lambdabot> Title: Problem 31 - Project Euler
01:20:33 <jfredett> I hope that doesn't log me in
01:20:34 <jfredett> :/
01:20:43 <dmwit> jfredett: You can do much better than six minutes, and without Sets.
01:20:51 <jfredett> dmwit: i know
01:21:00 <jfredett> i wanted to mess around with an idea i had
01:21:06 <jfredett> i've solve most of these before
01:21:12 <dmwit> My solution takes .00096s... =P
01:21:26 <jfredett> dmwit: my original solution is about the same
01:21:42 <jfredett> but i thought this was a pretty neat way to solve problems
01:21:45 <wli> Hmm. I've not seriously thought about this one.
01:21:47 <dmwit> ok
01:21:59 <jfredett> i borrowed some ideas from genetic algorithms
01:22:12 <jfredett> i just don't treat the problem very genetically
01:23:07 <jfredett> kindof like taboo search meets genetic algorithm meet simulated annealing meet more buzzwords.
01:33:37 <wolfgangbeck> is it a known bug of ghc 6.6.1 that fdRead blocks all threads?
01:34:13 <quicksilver> did you compile with -threaded?
01:34:25 <quicksilver> and run with RTS -N2 ?
01:34:38 <quicksilver> if not, it's a feature :P
01:34:42 <wolfgangbeck> didn't know that I have to, I'll try it, thx
01:35:33 <quicksilver> without that, it's not really using threads
01:35:43 <quicksilver> if it's not really using threads then yes, a blocking call will block all threads
01:35:48 <quicksilver> why use fdRead at all, btw?
01:36:13 <wolfgangbeck> I've written a c wrapper for inotify
01:37:03 <wolfgangbeck> every read returns a c struct for inotiy info, hGetContents fails with 'file is a directory' (which it is not)
01:37:20 <wolfgangbeck> fdRead works, but blocks everything
01:37:41 <quicksilver> you certainly wouldn't want hGetContents
01:37:46 <wolfgangbeck> but -threaded seems to help!
01:37:50 <quicksilver> although I can't explain that error :)
01:40:18 <wolfgangbeck> yes, -threaded did the trick. that's what i call quick user support :-)
01:52:36 <zerny> Is there any current work on ghc for the cell broadband engine?
01:56:21 <zerny> Or is there a good/better place to ask this question?
01:57:02 <jeffz> zerny: I'd take a look at the ghc section of the haskell website http://haskell.org/ghc - I guess you could ask in #ghc or ask on the mailing list
01:57:20 <jeffz> http://news.gmane.org/gmane.comp.lang.haskell.glasgow.user
01:57:20 <lambdabot> Title: Gmane Loom
01:57:51 <jeffz> there should be information on porting on the website
01:58:08 <zerny> jeffz: thanks, will try. There does not seem to be anything related on the list currently.
01:58:17 <zerny> great
02:00:48 <ac> jedbrown: do you have API documentation anywhere, or should I be looking at the source?
02:01:16 <jedbrown> ac: haddock docs should be okay
02:01:29 <ac> how do I generate them, or where's a link?
02:01:45 <jedbrown> ac: runhaskell Setup.lhs haddock (then install)
02:02:13 <jedbrown> ac: It turns out that a Binary instance is not really a good idea.  It's really unsafe since we have to use castPtr.
02:02:33 <ac> think I need to update my haddock
02:02:35 <jedbrown> ac: So instead I just wrote the unsafe instances to/from ByteString.
02:02:54 <wli> My first crack at that Project Euler problem seems to take 17 seconds.
02:03:07 <ac> huh. What's unsafe about it?
02:03:29 <wli> jfredett's problem.
02:03:36 <jedbrown> ac: castPtr is platform dependent.
02:04:09 <wli> I'm not entirely sure what dmwit's did that made it so fast. My wild guess is counting some other way.
02:04:16 <jfredett> what about my problem?
02:04:25 <jedbrown> ac: It's actually the reason why there are not Binary instances for floating point.
02:04:27 <jfredett> wli, there exists a counting argument
02:04:41 <jfredett> i dont want to give either method away
02:04:45 <jfredett> mine or the fast one
02:04:46 <wli> I've produced someting that goes about enumerating the combinations of coins.
02:04:55 <jfredett> (i got it down to 5 minutes)
02:04:56 <jfredett> :)
02:05:03 <wli> I've produced something that goes about enumerating the combinations of coins, rather.
02:05:55 <ac> jedbrown: hm. Maybe it doesn't make sense to use a CArray as input for writing, just as output from reading
02:06:37 <dmwit> wli: Try adding memoization with an array, that really drops the time a lot.
02:06:45 <wli> I suspect there might be a way to do it without explicitly enumerating the combinations of coins or some such.
02:06:57 <dmwit> wli: Yes, and don't bother enumerating them all.
02:07:32 <jedbrown> ac: Either way, you'll be doing a castPtr.  But what type are you using.  If it is CArray i Word8 for instance, then everything is actually safe.
02:07:54 <romeo1> can you feel it when someone smile and take breath in and out and not smile or different facial muscle?
02:08:28 <ac> jedbrown: Word8 or Word16 I suppose for the CArray interface. Do you think it's reasonable for an image library to also provide a diff array of doubles interface?
02:09:05 <ac> so everybody, what would you want in an image (loading and saving) library? What sort of data structure would you want it to provide?
02:09:14 <ac> What sort of data structure should it accept?
02:10:19 <tobyh> For the raster data?
02:10:25 <ac> yeah
02:10:29 <wli> dmwit: It already runs within the time limits when explicitly enumerating them. I've not come up with an algorithm to do it without enumerating them.
02:10:37 <ac> What to use for all the meta data is more or less obvious
02:11:22 <tobyh> Maybe a list of RGB(A) tuples..?
02:11:54 <tobyh> Tuples of doubles.
02:12:25 <ac> tobyh: currently I more or less support an array of 3/4 tuples of Doubles or a list of Word16s
02:12:42 <ac> but not a list of tuples of Doubles
02:13:04 <tobyh> I wouldn't always want to use an array, but they're easily interchangable at the last minute.
02:13:09 <jeffz> is romeo1 some sort of bot?
02:13:14 <ac> tobyh: thing is, doing image processing on lists is rather inefficient
02:14:06 <jedbrown> ac: For Word16 there is still an endianness issue which makes the binary instance slower.  We can have an instance (Ix i, IArray CArray e, Binary e) => Binary (CArray i e).  That would be sufficient for you and probably generally useful.
02:14:12 <tobyh> ac: Yeah, but it's simple.  If I have some crazy data structure I'm using for intermediate representation then I'll always be able to render down to a list for the loading and saving.
02:14:32 <vincenz> jeffz: what makes you say that
02:14:33 <romeo1> adsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffff
02:14:37 <romeo1> adsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffff
02:14:41 --- mode: ChanServ set +o vincenz
02:14:43 <romeo1> adsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffffadsffffffffffffffff
02:14:45 --- kick: romeo1 was kicked by vincenz (vincenz)
02:14:48 <tobyh> ac: Which you probably won't do that often.
02:14:50 <psykon> ?
02:15:05 <ac> tobyh: that's reasonable
02:15:22 <ac> I guess I'm not writing an image _processing_ library in any way
02:15:37 <jeffz> vincenz: he's been saying random stuff on-and-off if you scrollback far enough you can see a pattern emerging.
02:15:41 <tobyh> That's my thinking.
02:15:48 <vincenz> jeffz: oh
02:15:50 <tobyh> If you're doing processing then it's a little different.
02:15:57 <ac> though I think it would be convenient if it did alpha blending automatically if you asked for an RGB image from a file that contained an RGBA image and a background color
02:16:03 <jeffz> vincenz: but I guess his flood just then was reason enough to get rid of him :)
02:16:20 <vincenz> jeffz: reasonaby good reason :)
02:16:26 <tobyh> ac: HSV might be useful too.
02:16:33 <ac> tobyh: what's HSV?
02:16:33 --- mode: vincenz set -o vininim_
02:16:35 --- mode: vincenz set -o vincenz
02:16:38 <vincenz> vininim_: curse you!
02:16:50 <Japsu> baah
02:16:59 <Japsu> where do all these trolls etc come from
02:17:03 <tobyh> ac: Hue / Saturation / Value instead of Red / Green / Blue.
02:17:13 <ac> tobyh: oh crazy. How do you do that? ;)
02:17:13 <tobyh> ac: Look it up on wikipedia.
02:17:19 <jeffz> Japsu: they say it's something to do with the popularity of haskell
02:17:30 <Japsu> jeffz: it's not just #haskell
02:17:34 <ac> Haskell popular? Phsaw. I'm going to have to go learn a different language now
02:17:37 <vincenz> Now I will spam and give this link: http://www.youtube.com/watch?v=2fZHou18Cdk
02:17:38 <lambdabot> Title: YouTube - Yes We Can Obama Song by will.i.am
02:17:45 <tobyh> ac: There's a paper I read somewhere that extols the virtues of HSV...
02:17:45 --- mode: ChanServ set +o vincenz
02:17:47 --- kick: vincenz was kicked by vincenz (vincenz)
02:18:01 <Japsu> I've seen a massive increase in the amount of such activity lately, not just here at #haskell but on other Freenode channels, too
02:18:07 <olsner> wow, you can kick yourself?
02:18:11 <Japsu> olsner: of course :P
02:18:16 <Japsu> that obama song's pretty cool
02:18:36 <jeffz> Japsu: it so happens that paul graham's latest essay is on trolls
02:18:40 <Japsu> wish they had similar campaign advertising here in Finland. our presidential elections are very dull compared to that
02:18:52 <vincenz> Japsu: we don't evne have a government yet ..
02:19:03 <Japsu> vincenz: which country is that?
02:19:08 <vincenz> Belgium
02:19:14 <Japsu> :o
02:19:54 <ac> tobyh: huh. maybe I'll add HSV transformation later. I haven't even finished with the PNG spec. Actually I don't really intend to implement ICCC color profiles... that spec looks huge
02:20:56 <tobyh> ac: What's the grand plan?  To support a bunch of different file types?
02:21:10 <olsner> graham's "arc is underwhelming because I'm so full of awesome you don't even notice how awesome I am" was an interesting read too :P
02:21:37 <ac> tobyh: nope, just PNG
02:21:58 <ac> tobyh: the grand plan is to get a very reasonable PNG library that's very easy and natural to use in Haskell
02:22:04 <wli> It runs in 0.63s in ghci with a dumb speedup.
02:22:20 <tobyh> Cool.
02:22:44 <vincenz> Japsu: elections in june 2007, still no government
02:23:08 <Japsu> vincenz: they just can't get a consensus?
02:23:14 <vincenz> yeah
02:23:19 <vincenz> and now, they were getting a temporary fix
02:23:24 <vincenz> and the prime minister got sick
02:24:36 <wy> I found that as if context free grammars are actually recursive types
02:24:47 <wy> Is it true?
02:25:12 <olsner> the AST is the data type you get from translating the CFG directly into data definitions
02:25:36 <olsner> or, you get *an* AST.. obviously there are tons of ways to build an AST
02:26:30 <vincenz> That song is really good
02:26:44 <ac> tobyh: and to give good support for features that are not necessarily in other formats, like background color, UTF-8 meta data, and good compression
02:26:45 <vincenz> But even aside from that song, the speech was very good, as was the talk @ google
02:26:50 * vincenz would vote for him if he lived in the us
02:27:03 <ac> tobyh: and most importantly, a non-file based API
02:27:04 <wy> olsner: It's very interest to see that
02:27:18 <tobyh> ac: Does PNG support compression other than zlib?
02:27:24 <ac> tobyh: nope
02:27:37 <ac> tobyh: well, there are a few filters defined in the spec to help out zlib
02:28:03 <tobyh> ac: I see.  zlib is very general purpose, they could do a better lossless codec.
02:28:13 <ac> tobyh: yeah I think so too
02:28:48 <wy> So if a construct is recognized by a grammar, is that the same thing that the it's successfully typed?
02:30:13 <letrec> Hi! I've got this code dut = [1..100] >>= (\x-> [1..100] >>= (\y -> filt (x y) >>= (\_ -> return (x,y)))) where filt ... I've been told there is backtracking here. Is it because of laziness?
02:30:33 <wli> 0.63s in ghci, 0.1s compiled with ghc.
02:30:57 <ac> So what I've already done is create an Encode16 class, and an instance for 3 and 4 tuple Doubles, and Word8s. You feed it an image as a "Encode16 a => Int -> Int -> [a]" or "Encode16 p, Ix i, IArray a => a i p"
02:31:32 <tobyh> :letrec Damn, what does that look like in 'do' notation?
02:31:38 <olsner> hmm, I think you may be overusing the analogy there... expressions on type constructors are always parenthesised unambiguously - the task of parsing consists of extracting that piece of structure from a sequence of tokens
02:32:23 <ac> but how should I present an image that's read?
02:33:11 <tobyh> You'd want to keep it orthogonal wouldn't you?
02:33:30 <ac> tobyh: orthogonal?
02:33:44 <tobyh> Symmetric...
02:34:07 <ac> tobyh: ok, I guess I would make a Decode16 type class
02:34:51 <ac> and I have readImage overloaded to provide the same types, but with Decode16 instead of Encode16
02:35:33 <tobyh> Or a Pixel class..?  With both de- and encode?  I dunno... off the top of my head...
02:35:55 <ac> perhaps
02:36:03 <olsner> IMO a haskell imaging library should keep the pixel data as densely packed as possible - some bytestring analogy (whatever the underlying array was called)
02:36:45 <tobyh> That would make it harder to manipulate I reckon.
02:37:04 <tobyh> Perhaps.  It depends.
02:37:11 <letrec> tobyh: You don't like >>= :) Anyway, it can be written: dut = x<-[1..100] y<-[1..100] filt x y return (x,y) where filt is a function returning [] or [()] to do filtering.
02:37:23 <letrec> (I forgot the do)
02:39:11 <wy> olsner: If there is analogy, I'd better exploit it. Which one is more general?
02:39:49 <xpika> does anyone know a lambda calculus evaluator written in haskell?
02:40:29 <wli> xpika: There are tons of them.
02:40:45 <vincenz> it's not really that complicated ;)
02:40:49 <wli> xpika: They're repeatedly used as examples all over the place.
02:40:51 <tobyh> And they're a blast to write.
02:40:58 <vincenz> tobyh: especially typechecking :)
02:41:05 <tobyh> :)
02:41:47 <tobyh> I plan one day to write a type inference engine and a garbage collector.  Never gotten around to it over the years...
02:41:48 <ibid> does a modern ghc detect blackholes, and if so, does anybody have a simple example that triggers it?
02:41:54 * ibid cannot construct one
02:41:55 <wli> The ATiTaPL chapter on module systems didn't enlighten me.
02:42:17 <vincenz> ibid: easy
02:42:23 <vincenz> > let x = x + 1
02:42:23 <lambdabot>  Parse error at end of input
02:42:23 <ibid> vincenz: ...?
02:42:25 <vincenz> > let x = x + 1 in x
02:42:26 <lambdabot>  Exception: <<loop>>
02:42:30 <ibid> vincenz: try it in ghc
02:42:42 <ibid> vincenz: it just hangs here
02:42:45 <vincenz> hmm
02:42:50 <ibid> vincenz: that was the second example i tried :)
02:42:54 <olsner> wy: I think it's just that the correspondence is that superficial... BNF and data types are both just sums and products (sum = alternatives, like data A = B | C, and products = pairs/tuples, like data A = B C D)
02:43:18 <vincenz> > let x = case x of True -> False | False -> True in x
02:43:18 <lambdabot>  Parse error at "|" (column 33)
02:43:28 <vincenz> > let x = case x of {True -> False | False -> True }in x
02:43:28 <lambdabot>  Parse error at "|" (column 34)
02:43:32 <vincenz> > let x = case x of {True -> False; False -> True }in x
02:43:33 <lambdabot>  Exception: <<loop>>
02:43:41 <ToRA> ibid: it hangs, but you'll notice it swallows no memory or cpu
02:43:51 <vincenz> hangs too
02:43:53 <wli> ibid: I'm not sure black holes are an issue outside of conservative collection.
02:44:00 <ibid> ToRA: who cares?
02:44:03 <ToRA> ibid: you wouldn't want it to throw an exception as that isn't really correct behaviour...
02:44:05 <vincenz> so lambdabot is smarter than ghci?
02:44:10 <ibid> wli: ghc used to handle blackholes
02:44:11 <olsner> wy: there's bound to be a number of other formalisms that end up being just sums and products... and then you can suddenly transform any BNF grammar into that other thing... but that doesn't necessarily mean that there's meaning to be extracted from the analogy
02:44:18 <ibid> ToRA: ghci used to do that
02:44:19 <vincenz> ToRA: yes it is, they're both bottom
02:44:33 <ToRA> vincenz, but i can catch exceptions...
02:44:37 <ibid> but it seems i lied to my students, not having tested it recently
02:44:43 <wy> olsner: I just think there might be
02:44:46 <vincenz> how come lambdabot can do it?
02:44:57 <ibid> vincenz: does it have its own interpreter?
02:44:58 <olsner> vincenz: isn't that fix not?
02:45:00 <ivanm> magic!
02:45:26 <vincenz> ibid: dunno
02:45:31 * vincenz bets there is no lambdabot
02:45:35 <vincenz> it's a feed into dons' brain
02:46:02 <ibid> vincenz: or perhaps ghc handles blackholes by waiting on a false condition? :)
02:46:16 <tobyh> :)
02:46:39 <wli> Maybe I'm thinking a black hole is something else.
02:47:35 <wli> I thought it was something that wasn't a pointer, but looked like one, and so fooled a conservative collector into refusing to collect otherwise freeable garbage.
02:47:45 <ibid> wli: different blackhole
02:47:55 <wy> olsner: It at least makes me write grammars with as confident as I define data types ;)
02:48:06 <vincenz> black holes can be found in bottoms
02:48:09 <ibid> wli: this one's used by lazy evaluation to mark the place where the result will be
02:48:10 <wli> ibid: What are the ones you're on about?
02:48:33 <wli> Okay.
02:48:53 <vincenz> wli: when you force athunk
02:48:57 <ibid> wli: basically, when evaluating let x = ... in x, you let x be a blackhole, evaluate the ... expression to WHNF and then replace the blackhole by the WHNF result
02:49:01 <vincenz> wli: it stores a BLACK value in that place
02:49:12 <vincenz> so that when the thunk requires it's own value, it blackholes
02:49:53 <jrx> @pl \x -> foldr1 (++) (map snd x)
02:49:54 <lambdabot> foldr1 (++) . map snd
02:51:17 <wy> olsner: there is really a difference... thanks
02:56:14 <ibid> vincenz: might have something to do with concurrency, actually. simpler just to put any thread that accesses a black hole into the black hole's waiting list than to special case the evaluating thread
02:57:17 <tibbe> @seen dons
02:57:17 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 2h 44m 29s ago.
03:05:36 <ac> does anybody know of image processing algorithms?
03:07:14 <quicksilver> yes.
03:07:27 <quicksilver> darken: multiply all components by n, n < 1
03:09:20 <vincenz> blur: multiply by [0,1,0;2,4,2;0,1,0]
03:10:51 <jrx> @pl \x y -> (fst x, (snd x) ++ (snd y))
03:10:51 <lambdabot> ap ((.) . (,) . fst) ((. snd) . (++) . snd)
03:11:39 <jrx> \x  -> markField b x ml
03:12:01 <jrx> @pl \x  -> markField b x ml
03:12:01 <lambdabot> flip (markField b) ml
03:29:06 <malcolmw> anyone up for answering a Gtk2hs question?
03:29:29 <daf> malcolmw: we can try
03:29:47 <malcolmw> When you create a comboBox widget, and fill it with strings to be selected, how do you read which one the user chose?
03:29:52 <xpika> malcolmw: what seems to be the problem.
03:30:16 <malcolmw> there doesn't seem to be a 'comboBoxGetValue' function to throw into a callback
03:31:04 <malcolmw> maybe there is a more generic method, higher up the widget hierarchy, but I can't find it
03:31:11 <daf> malcolmw: it has an "activte" property
03:31:24 <daf> "active"
03:31:57 <malcolmw> ah, comboBoxGetActive.  Thanks
03:32:00 <xpika> malcolmw: there is also an 'onChanged' callback
03:32:31 <xpika> @hpaste it
03:32:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:32:33 <daf> malcolmw: you might find DevHelp useful
03:33:08 <daf> hmm, somebody should import the gtk2hs documentation into DevHelp
03:33:28 <resiak> someone should write a haddock index -> .devhelp file converter
03:33:42 <xpika> daf: what is devhelp?
03:33:44 <resiak> i nominate â€¦ you.
03:34:02 <daf> xpika: documentation browser
03:34:26 <xpika> is there a haddock to devhelp converter?
03:35:00 <daf> oh, looks like haddock does have support
03:35:02 <daf> -m
03:35:38 <daf> "Produce extra contents and index files for given HTML Help system. Currently supported Help systems are Microsoft HTML Help 1.3 and 2.0 and GNOME DevHelp."
03:35:38 <quicksilver> (In HTML mode only) Produce extra contents and index files for given HTML Help system. Currently supported Help systems are Microsoft HTML Help 1.3 and 2.0 and GNOME DevHelp.
03:35:42 <quicksilver> heh
03:35:42 <quicksilver> ;)
03:35:49 <quicksilver> looks like it yes
03:35:53 <resiak> So I guess nag the debian packagers to pass -m to haddock
03:35:57 <daf> resiak: aye
03:36:04 <daf> well, perhaps it's upstreamable
03:36:06 <resiak> argh, i appear to have broken haddock
03:37:02 <resiak> or at least, the library index is empty.  hrm.
03:52:05 <daniel_larsson> k
03:52:10 <daniel_larsson> oops...
03:55:00 <tibbe> what's the right data type to use if I want a simple 256 byte array, no boxing or anything?
03:55:08 <tibbe> (going to use it for a byte hashtable)
03:56:47 <quicksilver> UArray Word8 probably
03:56:56 <mauke> IOUArray Word8?
03:56:58 <tibbe> alright
03:57:09 <tibbe> there are too many array types xD
03:57:11 <mauke> bytestring? Ptr Word8?
03:58:00 <tibbe> I could use bytestring
03:58:34 <tibbe> is there a really efficient way of creating a BS of size 256 initialized to all 0oes?
04:01:19 <tobyh> 256 isn't much--what's wrong with pack?
04:02:26 <kosmikus> has anybody ever managed to compile lambdabot on Windows?
04:02:29 <kosmikus> dons: ^^ ?
04:03:15 <tibbe> tobyh: depends how many times you do it I guess
04:03:40 <tobyh> tibbe: do it once then re-use it. ;)
04:04:00 <tibbe> :p
04:04:24 <jedbrown> tibbe: I would think mallocByteString and memset (Data.ByteString.Internal)
04:04:43 <tibbe> jedbrown: alright, let me read through those docs
04:05:23 <jedbrown> tibbe: But ByteStrings are immutable...
04:06:02 <tobyh> A ByteString probably isn't the best data structure for a hash table.
04:06:33 <tobyh> An array is simpler and more efficient for a small one like that.
04:06:50 <tobyh> Unless you only have 2k of RAM.
04:07:16 <Stinger_> for those of you using haskell-mode, ever had the problem where it complains ignore-errors is void?
04:07:36 <solrize_> @pl filter p1 (filter p2 x)
04:07:37 <lambdabot> filter p1 (filter p2 x)
04:07:46 <solrize_> bah :)
04:08:23 <solrize_> @pl filter (\a->p1 a && p2 a)
04:08:24 <lambdabot> filter (liftM2 (&&) p1 p2)
04:08:28 <solrize_> aha
04:08:56 <solrize_> but what monad has (&&) been lifted to???
04:09:01 <ToRA> ->
04:09:56 <solrize_> thanks i'll have to think about that
04:10:32 <dancor> does parsec have a primitive to accept any token
04:10:50 <mauke> wasn't there something like anyChar?
04:10:52 <tobyh> For Char parsers?
04:10:57 <dancor> general
04:11:05 <tobyh> Hrmm, dunno.
04:11:22 <ToRA> anyChar exists
04:11:32 <tobyh> The source to Parsec is actually pretty small and neat.  Could look there.
04:11:33 <solrize_> @pl filter (\a->p1 a && p2 a && p3 a)
04:11:34 <lambdabot> filter (liftM2 (&&) p1 (liftM2 (&&) p2 p3))
04:13:19 <Cin> has anyone seen a cool "suggest-as-you-type" kind of drop down menu that can appear when writing haskell code in an editor?
04:13:25 <ToRA> :type (liftM3 (((&&) .) . (&&))
04:13:30 <ToRA> @type (liftM3 (((&&) .) . (&&))
04:13:30 <lambdabot> parse error (possibly incorrect indentation)
04:13:43 <ToRA> @type (liftM3 (((&&) .) . (&&)))
04:13:44 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool -> m Bool
04:15:08 <ToRA> @type \a -> and . map ($a)
04:15:09 <lambdabot> forall a. a -> [a -> Bool] -> Bool
04:15:37 <ToRA> @pl \a -> and . map ($a)
04:15:37 <lambdabot> all . flip id
04:32:46 <Cin> hrm. the vty package's "configure" script doesn't ask for bytestring, but when i do `build', it says it needs it. no issue, i'm installing ByteString now. but isn't that incorrect behaviour?
04:33:43 <Cin> hrm, maybe not. disregard that
04:34:44 <ac> specifically I'm wondering how to smear or distort an image smoothly
04:36:18 <Cin> Graphics/Vty/Types.hs:9:17:
04:36:18 <Cin>     Could not find module `Data.ByteString':
04:36:18 <Cin>       it is a member of package bytestring-0.9.0.4, which is hidden
04:36:34 <Cin> what does this mean? i don't really know what it's talking about. i've just installed the bytestring package :\
04:37:22 <u_quark> after building lambdabot when trying to eval a simple haskell expr like `> "lala"` i get Failed to load interface for `Data.Number.Symbolic': Use -v to see a list of the files searched for.
04:37:29 <Zao> Cin: The .cabal file is probably missing the package name.
04:37:48 <Zao> I had massive pains when trying to build Vty recently.
04:37:58 <Cin> zao: yeah, i'm trying to build Yi
04:38:04 <jedbrown> Cin: It means that the cabal file thinks that bytestring is still in base.  Add `bytestring' to the build-depends line of the .cabal file.
04:38:15 <Cin> jedbrown: okay
04:38:20 <Zao> I threw away Yi after I managed to build it. I found the vi-emulation quite inferior to the real deal.
04:38:30 <doserj> u_quark: it is in http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers-2007.9.25
04:38:32 <lambdabot> http://tinyurl.com/2pmthz
04:38:46 * dancor is highly confused why Parsec.satifsy e.g. is Char-specific
04:39:20 <ac> Zao: emulation of what?
04:39:31 <ac> Zao: (emacs or vim)
04:39:55 <ac> oh nm, you said "vi-emulation" which I read "yi-emulation"
04:40:11 <fl4ppie> Can someone explain why concatenation doesn't work in this line? "putStrLn "Sum: " ++ (show total)"
04:40:33 <dancor> fl4ppie: putStrLn ("a" ++ (show b))
04:40:34 <ac> > "Sum: " ++ (show 1)
04:40:36 <lambdabot>  "Sum: 1"
04:40:39 <Cin> jedbrown: that got it to work. i also had to add the 'containers' package to build-depends, too
04:40:44 <fl4ppie> dancor: thx
04:40:46 <dancor> fl4ppie: putStrLn ("a" ++ show b)  actually
04:41:02 <fl4ppie> yeah I understand *doh*
04:41:06 <dancor> precedence is weird in haskell
04:41:12 <mauke> s/weird/simple/
04:41:19 <ac> fl4ppie: you can also say: putStrLn $ "Sum: " ++ (show 1)
04:41:32 <ac> fl4ppie: (if you don't like parenthesis
04:41:33 <ac> )
04:41:39 <fl4ppie> ac: What does the $ do?
04:41:43 <mauke> ac: putStrLn $ "Sum: " ++ show 1
04:41:43 <ac> fl4ppie: it's the same as " "
04:41:48 <dancor> fl4ppie: weird precedencery
04:41:49 <mauke> @src ($)
04:41:50 <lambdabot> f $ x = f x
04:41:54 <mauke> it's just an operator
04:42:08 <ac> fl4ppie: in ghci, type ":info ($)"
04:42:22 <fl4ppie> ok, thx for the quick help :)
04:42:42 <mauke> printf "Sum: %d\n" total
04:43:01 <ac> fl4ppie: "$" is used a _lot_
04:43:03 <quicksilver> a $ b is (a) (b)
04:43:11 <quicksilver> where a and b are normally longer than one letter
04:48:51 <vincenz> @yarr
04:48:51 <lambdabot> I'll keel haul ya fer that!
04:48:57 <vincenz> @avast!
04:48:58 <lambdabot> Unknown command, try @list
04:52:18 <wolfgangbeck> this morning, I had a problem with fdRead blocking threads
04:52:35 <wolfgangbeck> +RTS  -N2 helped somewhat, but wasn't the solution
04:53:10 <wolfgangbeck> after inserting a threadWaitRead before fdRead, everything worked as expected
04:54:18 <wolfgangbeck> maybe this should be mentioned somewhere in the System.Posix.IO docs, as most functions here should have the same problem
04:56:21 <slava> is there a data structure which is like a priority queue but with O(log n) deletion?
04:56:33 <mauke> Data.Map
04:56:37 <slava> this is a general algorithms question, not haskell-specific
04:56:40 <DRMacIver> Sigh. I just know that post is going to be used to start a language war. :)
04:56:41 <slava> Data.Map implements this?
04:56:52 <mauke> what do you mean by "like a priority queue"?
04:56:52 <slava> its some kind of tree?
04:57:00 <slava> mauke: O(log n) removal if minimal element
04:57:04 <slava> O(log n) insertion
04:57:24 <mauke> any good balanced tree should do that
04:57:26 <slava> but i also want to be able to delete an arbitrary eleemnt
04:57:28 <slava> ok
04:57:30 <DRMacIver> Isn't that more like Data.Set (which I believe is a balanced binary tree) than Data.Map?
04:58:00 <quicksilver> Data.Set and Data.Map are the same structure
04:58:04 <Cin> hurrah. yi built
04:58:20 <quicksilver> the Map is a set of pairs with a custom equality predicate, essentially.
04:58:30 <DRMacIver> Yes, but the interface is different.
04:58:35 <dcoutts> wolfgangbeck: you're quite right, the Posix api is the low level one that just makes blocking system calls, it gets wrapped with the haskell concurrency stuff to give the high level portable api that works with haskell threads. You can email the libraries list to suggest some better docs. Even better, send a patch.
04:59:04 <quicksilver> slava: I would think any tree-like priority queue implentation should have O(log n) deletion.
04:59:19 <slava> so what does a heap offer over an avl tree?
04:59:26 <quicksilver> almost nothing
04:59:28 <slava> i've always implemented priority queues as heaps
04:59:29 <dcoutts> O(n) construction
04:59:32 <quicksilver> compactness in memory
04:59:34 <slava> O(1) peeking too
04:59:37 <slava> quicksilver: ah
04:59:49 <slava> those are probably the two main advantages
04:59:52 <quicksilver> you can get O(1) peeking with a tree
04:59:58 <quicksilver> if you put the minimal element at the top
05:00:04 <dcoutts> a heap is less ordered than a sorted binary tree
05:00:09 <dcoutts> so it's cheaper to build
05:00:13 <slava> quicksilver: but then its no longer a binary search tree
05:00:24 <quicksilver> who said search tree?
05:00:26 <quicksilver> not me, that's for sure.
05:00:43 <dcoutts> a search tree is O(n log n) to build O(n) to take apart, a heap is the reverse of that
05:01:20 <quicksilver> the main difference between a heap-like tree and a true heap is compactness
05:01:27 <mauke> slava: O(1) insert, O(1) peekMin, O(1) merge
05:01:31 <quicksilver> but a heap-like tree can do certain operations faster
05:01:41 <quicksilver> since it doesn't need to copy
05:01:59 <quicksilver> an a heap-like tree might exhibit better sharing
05:02:07 <quicksilver> which might matter for some uses
05:02:28 <slava> basically i have a large number of timers which need to wake up in order, but cancelling a timer needs to be fast
05:03:20 <pejo> slava, do you need to remove it from the structure immediately, or can you do that at deletion?
05:03:34 <mauke> you could just keep a queue of "deleted" timers and ignore them when they come up
05:03:41 <pejo> slava, err, deletion = when you take out the next event.
05:03:52 <slava> yes, but then if timers are added and deleted rapidly (which can happen here) the heap fills up with useless entries
05:04:07 <slava> this is for i/o timeouts -- if a timeout is set on a socket, then it adds the socket to the timeout queue, when data comes in its removed
05:04:15 <slava> so you can see in the normal course of operation, you have a lot of cancelled timers
05:04:24 <DRMacIver> Is this for the file system monitoring stuff you've been working on?
05:04:25 <slava> maybe my whole approach is wrong here
05:04:29 <slava> DRMacIver: no, just timeouts for sockets
05:04:32 <DRMacIver> ok
05:06:47 <slava> so i guess the consensus is to use a balanced binary tree here?
05:08:00 <Taejo> what is an appropriate place for a library on Hidden Markov Models? Data.HMM?
05:08:12 <Saul_> Does anyone know how to make a console application with haskell?
05:08:47 <Taejo> Saul_: what do you mean?
05:08:55 <Saul_> I don't mean command line applications but a full screen one like vim or other text editors
05:09:03 <Taejo> oic
05:09:15 <pejo> slava, do you have any indications that this currently is a performance bottleneck?
05:09:21 <Cin> a curses or similar
05:09:25 <Taejo> Saul_: maybe curses
05:10:05 <DRMacIver> There don't actually seem to be any curses bindings in hackage. Weird.
05:10:49 <qwr> DRMacIver: yi used some library
05:10:50 <Saul_> Ok I'll try that
05:10:54 <Saul_> thanks
05:11:07 <u_quark> doserj: i got worse :( ... /tmp/Mkiwl29108.o: unknown symbol `__stginit_numberszm2007zi9zi25_DataziNumberziSymbolic_' user error (resolvedObjs failed.)
05:11:15 <vininim_> I wake up with this channel number pink. Let me guess, someone miss auto-tabed vincenz ?
05:11:17 <Cin> the nmp3 package is a curses program.. so i wonder what that uses
05:11:35 <DRMacIver> qwr: I assume one exists somewhere. There's at least one ncurses application there. I'm just surprised it's not on hackage
05:11:47 <DRMacIver> Cin: Might use curses directly via the FFI.
05:12:01 <Cin> http://code.haskell.org/~dons/code/hmp3/Curses.hsc
05:12:18 <DRMacIver> Ah
05:12:37 <quicksilver> there is vty
05:13:03 <daf> vininim_: /lastlog vininim?
05:13:42 <Cin> does vty work on windows?
05:13:53 <Taejo> I'm implementing a number representation that uses (sign, logarithm), for fast and accurate multiplication of very small numbers; is there a way to add such numbers without exponentiating and then taking the log?
05:14:13 <qwr> hmm, vty is what yi uses...
05:14:19 <Saul_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/terminfo Might this be used instead of curses?
05:14:20 <lambdabot> http://tinyurl.com/2mf695
05:15:36 <Taejo> Saul_: terminfo is lower level than curses; I haven't used the haskell bindings, tho
05:15:46 <quicksilver> Taejo: you mean, is there a clever way to calculate log( exp(x) + exp(y) )
05:15:59 <quicksilver> Taejo: ?
05:15:59 <Saul_> I can't seem to find curses anywhere though
05:16:00 <Taejo> quicksilver: exactly
05:16:17 <quicksilver> Taejo: no, there is no generic simplification for log ( a + b )
05:16:38 <quicksilver> nor is there one for e(a) + e(b)
05:17:03 <DRMacIver> Although you can reduce the number of exponentiations by writing it as x + log(1 + exp(y - x)), which might be useful.
05:17:17 <Taejo> Saul_: what capabilities do you need? terminfo has funcs to move the cursor up and down; curses has full-blown text-based window management
05:17:24 <quicksilver> you might find a clever approximation by expanding a suitable power series etc
05:17:45 <Taejo> quicksilver: that sounds too much like hard work
05:18:02 <Taejo> DRMacIver: that might be useful
05:18:02 <quicksilver> ;)
05:18:51 <Cin> heh.. C-x f ~/.yi/YiConfig .. loading /home/chris/Haskell/Yi/yi/~/.yi/YiConfig.hs  WHAT
05:19:24 <Saul_> Taejo: I have an assignment to implement a roguelike game
05:24:31 <Taejo> Saul_: well, rogue uses curses, AFAIR
05:24:50 <Taejo> terminfo might be a little more work, but it shouldn't be a problem
05:32:38 <dancor> @pl f >>= \x -> g
05:32:38 <lambdabot> f >> g
05:32:50 <dancor> @pl f >>= \x -> g x
05:32:50 <lambdabot> g =<< f
05:33:54 <dancor> @pl do{y1<-f1;y2<-f2;return(f1++f2)}
05:33:54 <lambdabot> (line 1, column 3):
05:33:54 <lambdabot> unexpected "{"
05:33:54 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
05:34:15 <EvilTerran> pl doesn't do do{}
05:34:28 <EvilTerran> @undo do y1<-f1;y2<-f2;return(f1++f2)
05:34:29 <lambdabot> f1 >>= \ y1 -> f2 >>= \ y2 -> return (f1 ++ f2)
05:34:37 <EvilTerran> @. pl undo do y1<-f1;y2<-f2;return(f1++f2)
05:34:37 <lambdabot> f1 >> (f2 >> return (f1 ++ f2))
05:34:37 <dancor> hah ok
05:34:58 <EvilTerran> @. pl undo do y1<-f1;y2<-f2;return(y1++y2) -- but i think you wanted this
05:34:58 <lambdabot> (`fmap` f2) . (++) =<< f1
05:35:01 <quicksilver> it's also liftM2 (++) f1 f2
05:35:15 <dancor> cool
05:35:59 <EvilTerran> @. pl undo \f1 f2 -> do y1<-f1;y2<-f2;return(y1++y2) -- or this
05:35:59 <lambdabot> liftM2 (++)
05:36:43 <EvilTerran>  @pl works better when it knows what's a parameter and what isn't
05:37:05 <EvilTerran> 'cos then it knows which points need removed
05:39:57 <regularfry> 'Ning all...  I can't seem to build cabal-install at the moment, can anyone help?  I've probably just done something thick...
05:40:31 <regularfry> I get "Setup.lhs: At least the following dependencies are missing:
05:40:32 <regularfry>     Cabal >=1.3.3, network -any, zlib >=0.3, HTTP >=3000.0&&<3001.1
05:40:32 <regularfry> "
05:40:48 <regularfry> I know Cabal 1.3.3 is installed, so that's obviously wrong...
05:42:33 <dancor> regularfry: does ghc-pkg agree
05:43:02 <regularfry> No.
05:43:15 <dancor> then you may have to reinstall cabal 1.3.3?
05:43:16 <regularfry> I installed GHC to $HOME
05:43:36 <regularfry> Let me have a look around, I thought I'd just done that.
05:44:37 <regularfry> Oh, I see.  I'm just confused.  I had ~/lib/Cabal-1.3.3 from a previous install.  I also have ~/lib/ghc-6.8.2/Cabal-1.2.3.0
05:44:42 <regularfry> Never mind...
05:48:05 <u_quark> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
05:48:05 <lambdabot>  fd:19: hClose: resource vanished (Broken pipe)
05:48:18 <u_quark> @bf
05:48:18 <lambdabot> Done.
05:48:22 <u_quark> lol
05:48:28 <u_quark> @bf +
05:48:29 <lambdabot>  fd:19: hClose: resource vanished (Broken pipe)
05:49:29 <u_quark> @seen dons
05:49:29 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 5h 36m 42s ago.
05:49:37 <dcoutts> regularfry: try --user
05:50:44 <dcoutts> regularfry: by default "runghc Setup configure" uses only --global, we changed the default to --user for the 'cabal' command line prog.
05:50:54 <regularfry> dcoutts:  It seemed to work without that.  At least, it's stopped complaining about Cabal.  Now I just need to go and get network, zlib and HTTP...
05:51:20 <dcoutts> regularfry: with --global it only looks at packages in the global package db, with --user it looks at both
05:51:36 <regularfry> dcoutts: Ah, I see.  I was about to ask what the difference was :-)
05:52:15 <regularfry> dcoutts: is the global package database location specified by the ghc install?
05:52:18 <dcoutts> regularfry: once you get cabal-install built you won't have to worry about that any more since it uses --user by default
05:52:39 <dcoutts> regularfry: use ghc-pkg list, it shows the package db files it's using
05:53:10 <regularfry> dcoutts: yup, found that :-)  I configured ghc with --prefix=$HOME as well, I don't know if that's relevant.
05:53:34 <dcoutts> regularfry: doesn't matter, it just means your global one is not very global :-)
05:53:49 <regularfry> :-)
05:56:43 <regularfry> Oh, *now* I get it.  The global db is in --prefix=foo, the user db is in ~/.ghc.  </newbie>
05:57:16 <dcoutts> regularfry: right.
05:57:23 <Cin> oh yay. i got Yi to say "Wrote file /home/chris/test.hs" when i C-x s. it's so ace how easily i can hack on this editor
05:59:12 <regularfry> Bah.  Trying to build network:
05:59:19 <regularfry> Building network-2.1.0.0...
05:59:19 <regularfry> [2 of 4] Compiling Network.Socket   ( dist/build/Network/Socket.hs, dist/build/Network/Socket.o )
05:59:19 <regularfry> Network/Socket.hsc:2072:9: Not in scope: `openFd'
06:02:52 <EvilTerran> @hoogle openFd
06:02:52 <lambdabot> No matches found
06:02:54 <EvilTerran> @hoogle openFD
06:02:54 <lambdabot> No matches found
06:03:07 <dcoutts> regularfry: using ghc-6.6 or 6.8?
06:03:26 <regularfry> 6.8.2 stable, freshly downloaded this morning.
06:03:59 <LoganCapaldo> doesn't network come in the box?
06:04:19 <dcoutts> it's in the extra-libs collection, but that is version 2.1.0.0 so it should work
06:04:20 <regularfry> If it does, cabal-install's Setup.hs doesn't know about it.
06:04:32 <dcoutts> regularfry: ghc-pkg list network
06:04:53 <regularfry> $ ghc-pkg list network
06:04:53 <regularfry> /home/alex/lib/ghc-6.8.2/package.conf:
06:04:56 <regularfry> Nada.
06:05:10 <dcoutts> regularfry: you built it from source I guess using the minimal tarball
06:05:13 <bringert> hah, I got an e-mail from Igloo, and Gmail seves me an ad for "Igloo seal oil - superior omega-3"
06:05:20 <regularfry> I overlaid the extralibs...
06:05:50 <dcoutts> regularfry: that's odd since network is in the extralibs
06:06:22 <dcoutts> regularfry: and 2.1.0.0 is the version that works with ghc-6.8, are you sure there's not something weird going on like you're still picking up an old ghc-6.6 from the global path
06:06:33 <dcoutts> regularfry: try ghc --version and ghc-pkg --version
06:06:44 <regularfry> $ ghc --version
06:06:44 <regularfry> The Glorious Glasgow Haskell Compilation System, version 6.8.2
06:06:54 <regularfry> $ ghc-pkg --version
06:06:54 <regularfry> GHC package manager version 6.8.2
06:07:27 <dcoutts> regularfry: and when you build network using cabal, try with -v and check that it is also picking up ghc-6.8.2
06:08:01 <regularfry> Ok, just a sec
06:10:45 <regularfry> Well, I blew away the network-2.1.0.0/ dir and rebuilt; it worked that time.  Oddness.
06:12:23 <trez> 1
06:15:42 <hakerx> http://wow-dev.zapto.org/
06:15:43 <lambdabot> Title: === WOW Dev ===
06:17:51 <LoganCapaldo> i need me some bayesian spam filtering for irc
06:20:55 <quicksilver> freenode needs to auto K-line people who post only URLs and/or post URLs to multiple chans etc
06:21:47 <therp> quicksilver: ack. and that shouldn't be that hard to detect
06:22:40 <ohub> quicksilver; which is then easy to defeat by saying something clever first and then posting the url?
06:22:54 <LoganCapaldo> well helpfully the clever thing is entertaining
06:23:00 <quicksilver> I predict most of these people aren't that smart
06:23:05 <LoganCapaldo> s/help/hope/
06:23:16 <quicksilver> if they are I can generalise the heuristic ;)
06:23:35 <therp> probably a channel join limit is sufficient -- token bucket with initial=20, refillrate=2/h while this can be extended by answering captchas
06:23:39 <LoganCapaldo> I don't think the idea is to get them all, just to get enough of them so that the work > reward
06:24:03 <EvilTerran> the site seems to've gone down since he posted that link, anyway
06:24:21 <EvilTerran> apparently abuse@zapto.org work FAST :)
06:24:25 <LoganCapaldo> it musta gotten #haskell 'd ;)
06:25:00 <regularfry> @dcoutts: Thanks for the help, all seems to be working now :)
06:25:01 <lambdabot> Unknown command, try @list
06:25:02 <therp> ah that reminds me of the idea of countering spam by automatically retrieving URLs, practically ddosing the site
06:25:14 <EvilTerran> hehe
06:25:18 <dcoutts> regularfry: great, got cabal-install working then?
06:25:46 <therp> lambdabot apparently does that :)
06:25:57 <EvilTerran> therp, and i guess you could legitimately say your spamfilter was scanning the content of contained links to better judge if an email was spam
06:26:01 <regularfry> dcoutts: Seems to be :-)  I think the problem was just a load of junk from previous install attempts cluttering up the source dirs.
06:26:09 <EvilTerran> although it'd cause trouble with activation links in emails and things
06:26:11 <dcoutts> regularfry: ok
06:26:21 <quicksilver> therp: unfortunately that makes malevolant link posting for ddos purpose more attractive :)
06:26:31 <EvilTerran> you'd have to respect robots.txt, and hope it's used correctly
06:26:51 <EvilTerran> (altho activation links are the Wrong Thing anyway; only POST should have side-effects, etc)
06:27:00 <EvilTerran> (well, GET shouldn't)
06:27:11 <darrint> I'm often finding myself writing lines like do { ... somevar <- f ; use somevar ... } Is there a function which will allow me to eliminate somevar there?
06:27:27 <dcoutts> darrint: >>=
06:27:28 <LoganCapaldo> f >>= use
06:27:35 <quicksilver> darrint: depends on context, really
06:27:47 <darrint> Can I use >>= right in the do?
06:27:53 <quicksilver> yes
06:27:55 <therp> evilterran: I don't think that I would run in any legal trouble for accessing urls that are mailed to me, even this is done automatically with my authorizations.. however yes, activations urls are a problem I guess, but usually you have to two-step activation, one accessing the url, then clicking on a button or something
06:28:04 <darrint> ok. thanks.
06:28:11 <EvilTerran> mmhmm
06:28:16 <quicksilver> <$> and <*> are also useful
06:28:18 <dcoutts> darrint: or =<< which sometimes looks nicer, or fmap or <*>
06:28:24 <quicksilver> as is liftM2
06:28:37 <EvilTerran> legally it wouldn't be a problem, but people might get antsy if your spam filter explicitly tries to DDoS spammers.
06:28:48 <dcoutts> darrint: eg: lines <$> readFile f
06:28:50 <darrint> Looks like some quality time with hoogle for me. Thanks.
06:29:06 <EvilTerran> and you might as well feed the text of the page into your spam filter, if you're downloading it anyway
06:29:49 <therp> quicksilver: well, there can't be only a good sides of the claim "No, I'm not responsible of someone posts URLs to my http://get-your-dick-enlargement-today.com in spam mails", even when there is an obvious connection that can't be proven.
06:29:50 <lambdabot> Title: Com.org - Only the best links ...
06:30:01 <therp> thanks you lambdabot
06:30:11 <therp> -s
06:33:48 <u_quark> anyone any ideas why i am getting /tmp/MMohI30415.o: unknown symbol `__stginit_numberszm2007zi9zi25_DataziNumberziSymbolic_' when evaluating haskell exprs in my compiled lambdabot ?
06:35:33 <pjd_> darrint: for that example specifically, you should be able to say f =<< somevar
06:35:41 <pjd_> err
06:35:48 <pjd_> use =<< f, even
06:36:32 * pjd_ is slow today
06:37:03 <u_quark> and what is fptools ?
06:41:35 <dancor> why does this say "Pattern match(es) are overlapped":  f x y = do { t <- getChar; case t of x -> ..; y -> .. }
06:41:54 <dancor> does a case in a do some how not have access to func args?
06:41:55 <vincenz> dancor: x is not a pattern
06:42:02 <vincenz> erm it is
06:42:04 <vincenz> but not in the way you intend
06:42:07 <vincenz> x is just "anything"
06:42:09 <vincenz> and that gets put in x
06:42:09 <LoganCapaldo> it's shadowing the x
06:42:14 <vincenz> it's not the same x as the one passed into f
06:42:21 <vincenz> like LoganCapaldo says, it shadows the original x
06:42:21 <EvilTerran> dancor, you can't use an existing variable in a pattern, it gets bound afresh
06:42:24 <malcolmw> u_quark: you need a -package numbers flag to the compiler
06:43:06 <EvilTerran> > let x = error "x error"; y = error "y error" in case 12 of x -> x; y -> y
06:43:09 <lambdabot>      Warning: Pattern match(es) are overlapped
06:43:09 <lambdabot>              In a case alterna...
06:43:15 <Cin> @hoogle [a] -> Bool
06:43:16 <lambdabot> Prelude.null :: [a] -> Bool
06:43:16 <lambdabot> Data.List.null :: [a] -> Bool
06:43:16 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
06:43:17 <EvilTerran> > let x = error "x error"; y = error "y error" in case 12 of x -> x
06:43:18 <lambdabot>  12
06:43:40 <LoganCapaldo> dancor you probably want something like f x y = do { t <- getChar ; g t } where g c | c == x = ... ; g c | c == y = ...
06:43:43 <Cin> there no function to test if a list contains only one item?
06:43:54 <EvilTerran> ah, we've had this one before
06:44:21 <dancor> Cin: null . drop 1 ?
06:44:22 <EvilTerran> (&&) <$> not.null <*> null.tail
06:44:28 <LoganCapaldo> case list of [x] -> True ; _ -> False ?
06:44:34 <dancor> oh wait that doesn't work
06:44:55 <EvilTerran> @check liftM2 (==) (liftM2 (&&) (not.null) (null.tail)) ((==1).length)
06:44:56 <lambdabot>  Add a type signature
06:45:01 <EvilTerran> @check liftM2 (==) (liftM2 (&&) (not.null) (null.tail)) ((==1).length) :: [Int] -> Bool
06:45:02 <lambdabot>  OK, passed 500 tests.
06:45:10 <EvilTerran> @scheck liftM2 (==) (liftM2 (&&) (not.null) (null.tail)) ((==1).length) :: [Int] -> Bool
06:45:11 <lambdabot>   Completed 25059 test(s) without failure.
06:45:32 <Cin> so the answer is "no" :P
06:45:38 <EvilTerran> if you prefer, uncurry (&&) . (not.null &&& null.tail)
06:45:52 <EvilTerran> not in the standard library, no
06:46:54 * dancor is surprised that case patterns and func patterns are different like that
06:47:06 <EvilTerran> or even (not.null <$| (&&) |*> null.tail), with the appropriate infix-expressions operators
06:47:12 <EvilTerran> dancor, they aren't
06:47:18 <LoganCapaldo> dancor: hmm, how are they different?
06:48:04 <dancor> oh they aren't different, just putting either in a do loses scoping?
06:48:13 <LoganCapaldo> um no
06:48:50 <EvilTerran> under ALL CIRCUMSTANCES, using a variable name in a pattern makes a new, local binding of that variable to whatever it matches
06:49:34 <EvilTerran> if you want to see if a value matches the value of a variable, you have to use ==
06:50:18 <LoganCapaldo> or effectively write == with nested cases
06:50:38 <EvilTerran> ew
06:50:59 <LoganCapaldo> that's not a good idea btw
06:51:02 <LoganCapaldo> ;)
06:51:41 <EvilTerran> cross-product FTL
06:52:06 <dancor> writing out these == is hideous
06:52:13 * dancor modifies ghc
06:52:18 <LoganCapaldo> err
06:52:23 <LoganCapaldo> deriving Eq ?
06:55:01 <quicksilver> dancor: there is probably a better way to do what you are doing, why not explain the problem a bit more?
06:55:11 <quicksilver> I quite often use assoc-lists as dispatch tables
06:55:19 <hpaste>  dancor pasted "are these f t | t == things the best way" at http://hpaste.org/5729
06:58:13 <quicksilver> for such a simple case I might even use if-then
06:58:22 <quicksilver> although I normally prefer guards to ids
06:58:23 <quicksilver> ifs
06:59:32 <hpaste>  why need a func annotated "are these f t | t == things the best way" with "vincenz" at http://hpaste.org/5729#a1
07:01:18 <hpaste>  EvilTerran annotated "are these f t | t == things the best way" with "(no title)" at http://hpaste.org/5729#a2
07:01:20 <hpaste>  quicksilver annotated "are these f t | t == things the best way" with "use case?" at http://hpaste.org/5729#a3
07:02:02 <vincenz> quicksilver: you just took my code :)
07:02:30 <quicksilver> well I don't repeat the _ each line
07:02:31 <malcolmw> in Gtk2hs, how do I dynamically change the widget layout in a container, based on an action on some widget (e.g. after clicking a button)?  using the callback 'onClicked', I can attempt to alter the contents of the container widget, but it doesn't actually show up in the display.
07:02:58 <hpaste>  vincenz annotated "are these f t | t == things the best way" with "just case ()" at http://hpaste.org/5729#a4
07:03:00 <vincenz> quicksilver: ooh
07:03:02 <vincenz> :P
07:03:13 <dcoutts> malcolmw: you can add/remove widgets from a container, remember that newly created widgets start off hidden.
07:03:33 <malcolmw> dcoutts: I used widgetShow, but still they were not visible
07:03:52 <quicksilver> I like to case t since logically that's what I'm doing...
07:03:52 <dcoutts> malcolmw: widgetShow on the new widget, not just the container?
07:03:58 <vincenz> erm
07:04:03 <malcolmw> dcoutts: ah, yes only on the container
07:04:16 <malcolmw> dcoutts: I imagined that the showing propagated inside
07:04:19 <dcoutts> malcolmw: widgetShowAll does it recursively
07:04:28 <malcolmw> dcoutts: Great, will try that
07:04:31 <quicksilver> dancor: I would also write the otherwise case as (t:) <$> balanceEnd l r, probably
07:04:47 <doserj> quicksilver: but "case t of t" is a bit misleading...
07:05:14 <quicksilver> it's either misleading or it's documenting intention :P
07:05:16 <vincenz> doserj: cheeck my version
07:05:18 <quicksilver> depending how you look at it
07:05:22 <vincenz> comes after
07:06:24 <u_quark> malcolmw: didn't work... the same prob
07:06:34 <hpaste>  vincenz annotated "are these f t | t == things the best way" with "cleaning up further" at http://hpaste.org/5729#a5
07:06:47 <doserj> vincenz: I'm not sure if I prefer case () of (), though. Anyways, "case | ..." should be made sugar for sth. like this
07:06:55 <vincenz> doserj: yah
07:07:07 <malcolmw> dcoutts: it works.  also, any tips on how to specify the size of a container?  widgetSetSizeRequest doesn't seem to do it (on its own)
07:07:29 <vincenz> quicksilver: I like this even more ;)
07:07:49 <hpaste>  vincenz annotated "are these f t | t == things the best way" with "GOLF: removing extra do" at http://hpaste.org/5729#a6
07:08:08 <quicksilver> hmm yes
07:08:11 <quicksilver> that is nice
07:08:16 <quicksilver> although I despise 'where'
07:08:27 <dcoutts> malcolmw: generally one wants to try and avoid specifying too many fixed sizes, containers are usually sized by the size of their contents
07:08:48 <vincenz> @hoogle liftM2
07:08:48 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:08:59 <dancor> @type <$>
07:09:01 <lambdabot> parse error on input `<$>'
07:09:02 <malcolmw> dcoutts: I need to leave space in an area of the screen, where widgets are going to appear later
07:09:11 <quicksilver> @type (<$>)
07:09:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:09:42 <hpaste>  vincenz annotated "are these f t | t == things the best way" with "same sort of code.." at http://hpaste.org/5729#a7
07:09:44 <dcoutts> malcolmw: every area of a window is covered by some widget, so if you want a place holder it is probably easiest to put something in explicitly.
07:10:19 <malcolmw> dcoutts: hmm, ok.  are there any blank widgets?
07:10:28 <dcoutts> malcolmw: and replacing widgets causes general re-negotiation of sizes
07:10:42 <quicksilver> vincenz: yeah, I don't like that at all. I'd rather use <++> where (<++>) = liftM2 (++)
07:10:49 <dcoutts> malcolmw: a blank label is pretty blank
07:10:59 <malcolmw> dcoutts: :-)
07:11:00 <dcoutts> malcolmw: what is the area going to be replaced with?
07:11:08 <malcolmw> dcoutts: widgets
07:11:19 <hpaste>  vincenz annotated "are these f t | t == things the best way" with "refactoring out" at http://hpaste.org/5729#a8
07:11:23 <dcoutts> malcolmw: it may make sense to use an empty container with a minimum size.
07:11:24 <vincenz> quicksilver: check
07:11:45 <dcoutts> malcolmw: this kind of sizing thing is much much easier to do interactively in glade.
07:11:52 <malcolmw> dcoutts: the particular use-case is that I have a vbox of hboxes down the LHS, and I want each hbox to be for fixed height
07:12:25 <hpaste>  vincenz annotated "are these f t | t == things the best way" with "woo" at http://hpaste.org/5729#a9
07:12:31 <vincenz> quicksilver: even better
07:12:47 <hpaste>  vincenz annotated "are these f t | t == things the best way" with "removed typo (" at http://hpaste.org/5729#a10
07:12:58 <malcolmw> dcoutts: most of the column will be blank, and you can add an hbox interactively, but I want each hbox to be roughly the same size.
07:13:14 <vincenz> quicksilver: ya like?
07:13:29 <quicksilver> I think it's very cute
07:13:34 <dcoutts> malcolmw: so when you add more boxes than the requested size the window will just grow
07:13:36 <quicksilver> I wouldn't personally have bothered to abstract p
07:13:37 <vincenz> quicksilver: I like the symmetric of the 'o'
07:13:40 <quicksilver> but it's cute :)
07:13:44 <vincenz> s/o/p
07:13:57 <doserj> vincenz: what about a <:>?
07:13:57 <malcolmw> dcoutts: that was the rough idea, yes.
07:14:02 <vincenz> doserj: t's _++
07:14:10 <vincenz> oh!
07:14:25 <vincenz> doserj: won't work
07:14:30 <vincenz> first value is not monadic
07:14:37 <vincenz> doserj: so the analogy doens't hold
07:14:43 <vincenz> it''d have to be :> but that's a tycon
07:15:09 <dcoutts> malcolmw: so my main suggestion is to use glade (even it's just for experimentation and you don't use it in your code) and to read the gtk tutorial on box packing
07:15:37 <vincenz> dancor: how's the last version for ya?
07:15:49 <malcolmw> dcoutts: I couldn't install glade on my machine with fink - more than 100 dependencies, and the deps did not build cleanly
07:16:23 <malcolmw> dcoutts: but thx for the suggestion.  Glade looks nice
07:16:26 <dcoutts> malcolmw: wow, perhaps you can get it without the gnome/dev-help deps
07:16:59 <dcoutts> malcolmw: itself it doesn't use any gnome stuff, but it as an optional dep on devhelp which is a gnome help viewer
07:17:29 <hpaste>  jedbrown annotated "are these f t | t == things the best way" with "more golf" at http://hpaste.org/5729#a11
07:17:40 <vincenz> jedbrown: eww
07:17:50 <malcolmw> dcoutts: maybe another day.  Got a deadline to beat.
07:19:06 <jedbrown> vincenz: It removes all the == but is way too heavy here since there are only two choices plus default.
07:19:31 <dcoutts> malcolmw: this may be helpful: http://developer.gnome.org/doc/GGAD/sec-containers.html#SEC-SIZENEGOTIATION
07:19:31 <lambdabot> Title: Containers And Widget Layout, http://tinyurl.com/25onfm
07:20:42 <vincenz> @src otherwise
07:20:42 <lambdabot> otherwise = True
07:20:59 <quicksilver> jedbrown: that list-of-pairs approach was sorta what I was thinking of when dancor first asked
07:21:14 <quicksilver> jedbrown: I often write code like that (but not for little tiny two-case examples like this)
07:21:22 <dcoutts> malcolmw: so widgetSetDefaultSize might be what you want.
07:21:44 <jedbrown> quicksilver: Yeah, it scales nicely and you can make it a Map/Hash/Array if it needs to be really fast.
07:22:45 <vincenz> jedbrown: I don't think it'd be faster..
07:22:48 <vincenz> jedbrown: if anything, slower
07:23:00 <malcolmw> dcoutts: I can find windowSetDefaultSize, but not widgetSet...
07:23:01 <vincenz> jedbrown: you're doing a single dispatch (since l and r comes as input parameters to the function)
07:23:10 <vincenz> jedbrown: so it'd cost more to build the structure and then do a lookup
07:24:11 <dcoutts> malcolmw: oh, yes, right, that's only for top level windows
07:24:14 <jedbrown> vincenz: For the 2-choice case, you're right, but if there were a lot of choices (like a hardware emulator) then the Array lookup wins.
07:24:30 <vincenz> jedbrown: only if you could reuse the choicec table accross chocies
07:24:40 <vincenz> jedbrown: notice here the choicce-table is built up inside the clal and used once
07:24:45 <vincenz> jedbrown: 2 choices or r100 choices
07:24:56 <jedbrown> vincenz: Yes.  It's a different problem.
07:24:57 * vincenz rents a new typist
07:25:07 <dcoutts> malcolmw: so what widget were you using widgetSetSizeRequest on, and what did it do that you did not expect?
07:25:38 <jedbrown> @seen Igloo
07:25:39 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 3h 49m 18s ago.
07:25:54 <slihn> first time in irc, can someone tell me whether ~> is the arr constructor?
07:26:20 * earthy doesn't understand the question
07:26:32 <malcolmw> dcoutts: it was an HBox, I asked for size (-1) 20, i.e. height of 20, don't care about width, and got just an even division of the screen space, about 200 pixels
07:26:54 <earthy> @hoogle ~>
07:26:55 <lambdabot> No matches found
07:27:26 <dcoutts> malcolmw: so they were given more than they asked for, that is always allowed
07:27:40 <malcolmw> dcoutts: ah.  OK
07:27:42 <dcoutts> malcolmw: you can change what widgets do with the extra space they have been given
07:27:54 <dcoutts> malcolmw: that's what the packing parameter does
07:28:00 <malcolmw> dcoutts: with the packing info, I suppose
07:28:42 <dcoutts> malcolmw: you probably want to tell the vbox you're packing the hboxes into to not expand vertically
07:28:59 <malcolmw> dcoutts: makes sense
07:29:25 <dcoutts> malcolmw: this is where glade is really handy, for tweaking these parameters and interactively resizing and seeing if it does what you want. Doing it in code after that is easy. Doing is straight off is really hard.
07:30:17 <dcoutts> malcolmw: it's like trying to write nice resizable html without the use of a browser to check your results :-)
07:31:00 <malcolmw> dcoutts: the edit-compile-run cycle is much the same, only a little bit slower
07:31:52 <dcoutts> malcolmw: right, it's the slowness that's the problem the other has a cycle of however long it takes to move the mouse halfway across the screen.
07:32:15 <malcolmw> dcoutts: ghc is pretty fast these days ... :-)
07:32:24 <dcoutts> heh heh
07:37:34 <byorgey> hi slihn, where did you see ~> ?
07:37:49 <byorgey> I've seen it used for arrows before, but I don't think it's in the standard libraries or anything
07:38:04 <byorgey> slihn: and welcome to #haskell =)
07:38:18 <slihn> http://hackage.haskell.org/packages/archive/TypeCompose/0.3/doc/html/Control-Compose.html biFlip
07:38:20 <lambdabot> http://tinyurl.com/3cpnbh
07:39:40 <byorgey> slihn: oh, I see. it is just being used as a name for one of the type parameters.
07:40:19 <byorgey> for example, newtype Flip (~>) b a  means Flip takes three type parameters, called (~>), b, and a respectively
07:40:46 <byorgey> but since it uses operator syntax, it can be written infix which can make certain things nicer to read
07:40:53 <slihn> this is new to me.
07:41:47 <slihn> can you provide an example of Flip?
07:42:08 <slihn> or how to use biFlip
07:43:34 <quicksilver> like the built-in type (->)
07:43:40 <quicksilver> this is an infix constructor
07:43:56 <quicksilver> (but here, ~> is a variable, not a fixed type constructor)
07:44:18 <slihn> ~> a variable of what?
07:45:16 <byorgey> a type variable.
07:45:30 <byorgey> here, it represents a type constructor with kind * -> * -> *.
07:45:45 <byorgey> for example, (->) .
07:45:55 <byorgey> which is the function type constructor.
07:46:13 <jedbrown> @seen ac
07:46:13 <lambdabot> ac is in #haskell. I last heard ac speak 3h 3m 19s ago.
07:47:15 <Stinger_> hmm I'm trying to learn HXT, is there a function to generate a DOM tree from a string?
07:48:14 <slihn> oh, so ~> has to do with the abstract type extension and it holds a type, instead of a function.
07:49:02 <jedbrown> @tell ac carray-0.1.2 is in Hackage now.  It adds an instance of Binary and unsafe O(1) from/to ByteString.  They are unsafe because they are not platform independent.
07:49:03 <lambdabot> Consider it noted.
07:55:12 <quicksilver> jedbrown: sounds like we're overloading unsafe a bit :)
07:55:42 <jedbrown> quicksilver: Oh?-
07:57:20 <slihn> let me guess Flip (~>) b a is really no differerent from Flip c b a. And a ~> b can just be a `c` b. Am I right?
07:57:26 <twanvl> unsafe usually means 'can crash the program' or 'will break referential transaprency'
07:58:51 <jedbrown> twanvl: If I turn an array into a bytestring on my machine and you turn the same array into a bytestring on your machine, it should be the same.
07:59:49 <twanvl> the name "CArray" already suggests it is not portable
07:59:54 <jedbrown> twanvl: But in this case, it's not unless endian-ness and such agree.
08:00:29 <jedbrown> twanvl: Since when is C is not portable?
08:01:30 <quicksilver> slihn: yes
08:01:41 <quicksilver> slihn: except `c` syntax isn't permitted for type variables
08:01:47 <twanvl> data written for/by C is not portable
08:02:00 <quicksilver> slihn: but what you say is basically correct
08:03:32 <Cin> i'm trying to write an ido-mode for yi, except i think i might need to change some of yi's innards to have the "update-possibilities-as-you-go" behaviour. is this awesome (y/n)?
08:05:13 <slihn> quicksilver: thanks. that really helps...
08:05:19 <jedbrown> twanvl: It depends on how the library does the writing.  In this case, CArray is just like any other array type except that it is nicely suited for external libraries.  This part is quite portable.
08:06:28 <twanvl> but the data representation of these libraries is not; if they use normal c data types, the representation is depends on the endianness
08:07:44 <jedbrown> twanvl: Yes, but so does the Haskell type.  The fact that we don't normally see the binary representation of the Haskell type doesn't make it more portable.  An external library can process an array just as well as a Haskell lib.
08:08:45 <jedbrown> twanvl: It can be pure and portable.  But if you actually look at the binary rep (by writing it to a file or making a ByteString from it) then you may get different results.  Hence unsafe.
08:10:06 <shapr> Good morning #haskell!
08:10:14 <shapr> What's goin on?
08:10:29 <Cin> we're all hacking Yi
08:10:31 <kpreid> arguing about what "unsafe" means
08:10:32 <Cin> :P
08:10:38 <twanvl> jedbrown: I wouldn't call that unsafe, it is perfectly safe in almost all cases. Perhaps you could call it toByteStringNative or toByteStringHost
08:11:00 <shapr> Cin: Oh cool!
08:15:24 <jedbrown> twanvl: That would work as well.  The documentation explains what is unsafe, and I think that most users will use binary encode/decode which are platform independent.
08:17:05 <jedbrown> I don't think it's often useful (in Haskell) to cast a block of memory to/from Word8.
08:17:29 <conal> slihn: just read the logs.  i think you got it.
08:19:44 <ehird`> completely crazy idea -
08:19:48 <ehird`> a haskell IRCd. :-P
08:20:19 <smtms> I thought about it a few hours ago
08:20:27 <quicksilver> jedbrown: mostly just when interfacing with external libraries which require specfic memory layouts, I guess
08:20:41 <quicksilver> jedbrown: (and trying to avoid excessive copying)
08:20:50 <smtms> the fastest ircd's are single-threaded C apps
08:21:19 <quicksilver> haskell would be a pretty good language for writing an ircd in
08:21:20 <Cin> @hoogle act
08:21:21 <lambdabot> Distribution.Simple.Setup.Action :: data Action
08:21:21 <lambdabot> Prelude.subtract :: Num a => a -> a -> a
08:21:21 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
08:21:34 <smtms> I think going from single-threaded to any form of multi-threaded will involve performance degradation
08:21:39 <quicksilver> I bet you could write a pretty reliable one in many fewer lines than the C one.
08:21:51 <quicksilver> simple haskell threads are single-threaded :P
08:21:52 <jedbrown> quicksilver: That is the whole point of CArray!
08:21:58 <Cin> mine was about 600 lines, i guess
08:22:04 <quicksilver> jedbrown: yes, I know.
08:22:45 <Cin> http://monkeyboy.td.org.uit.no/~cin/code/hircd/doc/
08:25:02 <czakey> Cin: is it working?
08:25:02 <jedbrown> quicksilver: My motivation for calling the to/from ByteString instances unsafe is that bytestrings *are* viewed as platform independent.  I don't think it's common to need the bytestring interface to a block of memory.  The to/from StorableVector functions (not written since storable-vector is not on hackage) would certainly be safe.
08:25:31 <quicksilver> jedbrown: yes, I agree with that reasoning
08:26:02 <jedbrown> quicksilver: Cool, I'll leave the API as is then.
08:26:11 <Cin> czakey: well it does very basic channels. i rewrote it to use a state monad but lost the darcs repo. heh
08:26:15 <LoganCapaldo> Cin: OOC why is ClientID = CInt and not = Int ?
08:26:46 <Cin> logan: i get the id from the socket number. nice way to have a unique id generated for me
08:26:46 <czakey> ok
08:27:11 <LoganCapaldo> CIn ah ok
08:27:27 <quicksilver> socket number?
08:27:30 <quicksilver> == port number?
08:27:37 <LoganCapaldo> the fd I assume
08:27:40 <Cin> quicksilver: the fd
08:27:45 <quicksilver> ah hmm
08:27:54 <quicksilver> fine as long as you don't mind it being reused :)
08:27:57 <Cin> logan: i didn't realise at the time i could just use an infinite list like a stack of IDs, but there you go
08:28:03 <ehird`> IMO re: ircd in haskell,
08:28:07 <ehird`> it should stay single-threaded
08:28:16 <ehird`> you can do async stuff in haskell, iirc
08:28:27 <quicksilver> ehird`: as I said, simple haskell threading *is* single-threaded.
08:28:29 <ehird`> however, the fastest ircd will probably be crazily hand-optimized erlang ;)
08:28:33 <Cin> pretty sure Network.Socket does select()
08:28:37 <ehird`> quicksilver: threads are a pretty bad abstraction imo
08:28:49 <quicksilver> threads are an excellent abstraction for blocking IO.
08:28:59 <ehird`> async io is better.
08:29:16 <quicksilver> threads are an excellent abstraction for hiding the details of async io
08:29:21 <ehird`> also, a Haskell program dealing with IRC is not a Haskell program dealing with IRC unless it has 1. a monad called IRC 2. a type for every irc command
08:29:23 <ehird`> and that's final
08:29:43 <quicksilver> doing async io by hand involves remembering a bunch of state for each waiting fd
08:29:51 <quicksilver> that's exactly what threads do automatically
08:29:54 <Cin> actually mind did have that before i lost the repo. i'm not really interested in it right now so i won't be updating it
08:29:55 <quicksilver> with less pain :)
08:30:40 <Cin> quicksilver: indeed, it's nice to just forkIO to, say, send a long /WHO or /LIST. you don't have to buffer it like you would in an async model
08:31:08 <quicksilver> right.
08:31:17 <quicksilver> you don't have to explicitly buffer it.
08:31:25 <quicksilver> cos it happens automatically behind the scenes.
08:31:44 <quicksilver> threads may be a bad abstraction for some tasks but for multi-FD io, they're just about perfect.
08:36:05 <ehird`> hmm... what IRC rfc is the most widely-used these days?
08:55:07 <dancor> Either String a   isn't a monad like  Maybe a  ?
08:55:09 <tonfa> how do you get the best optimizations with ghc ?
08:55:20 <mauke> tonfa: -O2
08:55:20 <Cale> dancor: it is
08:55:29 <Cale> dancor: the instance is in Control.Monad.Error
08:55:42 <Cale> dancor: It's just:
08:55:48 <Cale> instance Monad (Either e) where
08:55:57 <Cale>   return = Right
08:56:05 <Cale>   Left e >>= f = Left e
08:56:10 <Cale>   Right x >>= f = f x
08:56:12 <ehird`> the either monad is basically designed for 'maybe'-esque uses..
08:56:28 <vincenz> fail s = Left . read $ s
08:56:36 <Cale> Of course the instance in Control.Monad.Error is screwy.
08:57:04 <dancor> oh i think i need instance Control.Monad.Error Psec.ParseError
08:57:05 <Cale> vincenz: that's novel, require a Read instance :)
08:57:07 <vincenz> Cale: I Wonder why 'fail' is string based
08:57:15 <tonfa> I have the impression that even for simple code like this http://hpaste.org/5730 ghc -O2 uses the stack
08:57:27 <Cale> vincenz: because it was never intended for human consumption anyway
08:57:33 <vincenz> Cale: use 'Show a"
08:57:50 <tonfa> (I admit the asm generated isn't very readable so I'm not 100% sure)
08:58:04 <Cale> vincenz: It's supposed to be just used by the do-notation, and that only needs string error reporting.
08:58:11 <quicksilver> > let f x = if x < 1000000000 then f $ x+42 else x in f 0
08:58:13 <vincenz> : tfail
08:58:15 <vincenz> :t fail
08:58:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
08:58:16 <lambdabot>  1000000008
08:58:28 <vincenz> Cale: bh
08:58:28 <quicksilver> tonfa: since that works, I'm guessing it doesn't :P
08:58:30 <vincenz> Cale: bah
08:58:39 <Cale> People abuse fail all the time, and it bothers me a lot :)
08:58:55 <Cale> We really need to get it removed from the Monad class entirely.
08:59:05 <vincenz> Join the AFA, anonymous fail abusers, and get rid of your failure-abuse today!
08:59:55 <matthew-_> @pl \(x,y) -> (y,x)
08:59:55 <lambdabot> uncurry (flip (,))
09:01:40 <tonfa> quicksilver: it still runs in 54s whereas the equivalent ocaml code runs in 2.5s (C code with a recursive function runs in 1.3s)
09:01:48 <shachaf> matthew-_: (snd &&& fst), maybe.
09:01:56 <tonfa> i think it uses the stack instead of register or something
09:01:59 <shachaf> matthew-_: It's probably nicer to define it yourself somewhere.
09:02:10 <ehird`> uncurry (,)
09:02:12 <ehird`> that's amusing
09:02:15 <ehird`> @pl uncurry (,)
09:02:16 <lambdabot> id
09:02:21 <ehird`> @pl curry (,)
09:02:22 <lambdabot> curry (,)
09:02:44 <vincenz> ehird`: you can't curry that, it's already curried
09:02:48 <hpaste>  (anonymous) annotated "simple example" with "(no title)" at http://hpaste.org/5730#a1
09:02:48 <ehird`> vincenz: i know
09:02:49 <vincenz> that doesn't even type
09:02:49 <ehird`> :P
09:02:52 <vincenz> :t curry (,)
09:02:53 <lambdabot> forall a b b1. a -> b -> b1 -> ((a, b), b1)
09:02:58 <vincenz> oh
09:03:00 <vincenz> ew
09:03:03 <ehird`> haha
09:03:05 <ehird`> that is brilliant
09:03:10 <shachaf> @ty uncurry . flip . curry $ id
09:03:10 <lambdabot> forall a b. (b, a) -> (a, b)
09:03:17 <ehird`> it's like consing of tuples.
09:03:22 <ehird`> > (curry (,)) 1 2 3
09:03:24 <lambdabot>  ((1,2),3)
09:03:32 <ehird`> > (curry$curry (,)) 1 2 3 4
09:03:33 <lambdabot>  (((1,2),3),4)
09:03:36 <ehird`> haha
09:03:37 <ehird`> that's great
09:03:43 <vincenz> :t curry $ curry (,) -- more curry!
09:03:43 <lambdabot> forall a b b1 b2. a -> b -> b1 -> b2 -> (((a, b), b1), b2)
09:03:47 <ehird`> > (flip$curry (,)) 1 2 3
09:03:48 <lambdabot>  ((2,1),3)
09:03:50 <quicksilver> tonfa: eh? 54s?
09:03:51 <ehird`> oh
09:03:57 <ehird`> > (curry$flip (,)) 1 2 3
09:03:58 <lambdabot>  (3,(1,2))
09:04:01 <ehird`> hmm
09:04:02 <quicksilver> tonfa: did you see how fast lambdabot ran it?
09:04:06 <vincenz> :t curry $ curry $ curry $ curry $ curry (,) -- more curry!
09:04:07 <lambdabot> forall a b b1 b2 b3 b4 b5. a -> b -> b1 -> b2 -> b3 -> b4 -> b5 -> ((((((a, b), b1), b2), b3), b4), b5)
09:04:07 <ehird`> getting a lisp-style cons might be difficult
09:04:08 <ehird`> :)
09:04:09 <quicksilver> > let f x = if x < 1000000000 then f $ x+42 else x in f 0
09:04:10 <lambdabot>  1000000008
09:04:23 <vincenz> ehird`: there you have it, eat enough curry, and you'll end up a lisp
09:04:23 <quicksilver> tonfa: way under 54s. Are you sure you're not doing something wrong?
09:04:33 <ehird`> first one who gets "f 1 2 3" -> (1,(2,3)) or (1,(2,(3,()))) using that general style wins something :P
09:04:54 <hpaste>  tonfa annotated "simple example" with "ocaml and C code" at http://hpaste.org/5730#a2
09:05:10 <tonfa> quicksilver: with +1 instead of +42
09:05:12 <DukeDave> Hey gang, has anyone played with Haskell and Thrift yet?
09:05:17 <vincenz> :t curry $ flip (,)
09:05:18 <lambdabot> forall a b a1. a -> b -> a1 -> (a1, (a, b))
09:05:19 <quicksilver> > let f x = if x < 1000000000 then f $ x+1 else x in f 0
09:05:20 <tonfa> I added the 42 to find it in the asm
09:05:25 <lambdabot> Terminated
09:05:25 <Qerub> "Monad m => ... x ... -> m x" <- What is this construction called? Implicit monad-something? :)
09:05:29 <quicksilver> tonfa: ah.
09:05:30 <DukeDave> I'm looking for some example code
09:05:39 <quicksilver> tonfa: well if it was using the stack it would overflow.
09:05:41 <shachaf> Qerub: Which construction?
09:05:43 <ehird`> Qerub: "Where m is a monad, x -> m x"
09:05:47 <quicksilver> tonfa: being slow is not evidence of using the stack :)
09:06:01 <ehird`> :t flip $ curry $ flip (,)
09:06:03 <lambdabot> forall a b a1. b -> a -> a1 -> (a1, (a, b))
09:06:14 <ehird`> hmz
09:06:23 <ehird`> @djinn a -> b -> c -> (a,(b,c))
09:06:24 <lambdabot> f a b c = (a, (b, c))
09:06:32 <ehird`> thanks lambdabot. you're real helpful
09:06:39 <ehird`> @pl \a b c -> (a, (b, c))
09:06:40 <lambdabot> (. (,)) . (.) . (,)
09:06:43 <ehird`> hahaha, wow
09:06:49 <ehird`> @unpl (. (,)) . (.) . (,)
09:06:50 <lambdabot> (\ g m d -> ((,)) g (((,)) m d))
09:07:06 <tonfa> quicksilver: for simple example like that, where it does tail-recursion, there should be something wrong
09:08:12 <quicksilver> tonfa: sure. But that 'something wrong' is not stack usage.
09:08:14 <tonfa> quicksilver: maybe it's using the stack instead of the registers for some variables
09:08:55 <quicksilver> tonfa: yeah, ghc isn't very good at using registers.
09:09:04 <quicksilver> tonfa: which version of ghc are you using?
09:09:24 <tonfa> the one in ubuntu 7.10
09:09:26 <tonfa> let me check
09:09:27 <quicksilver> tonfa: doh
09:09:30 <quicksilver> tonfa: the problem isn't that :P
09:09:34 <quicksilver> tonfa: it's that you're using Integer.
09:09:43 <tonfa> 6.6.1
09:09:46 <quicksilver> use Int and the time drops from 22s to 2.7s on this machine.
09:09:52 <tonfa> oh ok
09:10:40 <ehird`> hmm
09:10:42 <ehird`> that cons is really hard
09:10:43 <ehird`> :-P
09:12:15 <shachaf> tonfa: The OCaml and Haskell are about the same speed for me, by the way.
09:12:20 <shachaf> tonfa: (As @pasted.)
09:12:30 <quicksilver> shachaf: even without an 'Int' annotation?
09:13:02 <shachaf> quicksilver: Yes.
09:13:13 <quicksilver> shachaf: that's very odd. Try it with an Int annotation?
09:13:21 <shachaf> Oh, I might not be compiling the OCaml correctly.
09:13:29 <shachaf> tonfa: How are you compiling it?
09:13:46 <tonfa> shachaf: $ ghc -O2 -S a.hs / ocamlopt a.ml
09:13:53 <tonfa> (remove the -S)
09:14:22 <quicksilver> tonfa: ghc 6.8.2 has a better native code gen it might do slightly better, btw.
09:14:30 <quicksilver> tonfa: but 2.7s is not too shabby.
09:14:33 <shachaf> Oh, I was using ocamlc.
09:14:35 <shachaf> Sorry. :-)
09:14:37 <tonfa> yeah it's ok
09:14:39 <shachaf> It's indeed much faster now.
09:14:52 <tonfa> quicksilver: can you paste the code with the type annotation ?
09:14:57 <shachaf> Does ocaml use Ints by default?
09:15:08 <tonfa> it takes 7.8s for me
09:15:13 <quicksilver> tonfa: (1000000000::Int)
09:15:14 <tonfa> shachaf: yes
09:15:17 <quicksilver> is the way I did it
09:15:17 <tonfa> quicksilver: ok
09:15:23 <quicksilver> there are a number of other ways which would work
09:15:32 <quicksilver> like let f::Int->Int;f x = ....
09:16:05 <tonfa> that's what I tried
09:16:09 <hpaste>  (anonymous) annotated "simple example" with "(no title)" at http://hpaste.org/5730#a3
09:16:16 <tonfa> it isn't 2s for me, it's 7s
09:16:29 <tonfa> maybe I'll try with a more recent ghc
09:16:30 <quicksilver> decent speedup on the 54s you had before :)
09:16:34 <tonfa> right
09:16:49 <quicksilver> but it doesn't surprise me too much; as I say ghc is pretty bad at using registers
09:17:12 <tonfa> that's bad, register allocation is cool :)
09:17:21 * tonfa does a phd thesis about register allocation :)
09:18:44 <esap> a good compiler would compile the example as "main = print (1000000000 :: Int)"
09:18:50 <tonfa> and with some inlining and induction variable detection it could probably detect the value statically
09:18:59 <tonfa> gcc does that if you use a loop
09:19:04 <tonfa> esap: yes
09:19:20 <quicksilver> that's a pretty stupid optimisation though
09:19:26 <quicksilver> it's cute, sure
09:19:30 <tonfa> that's an uncommon case
09:19:36 <quicksilver> but it doesn't do anything of interest in interesting programs
09:19:42 <darrint> Is there a way to take a reference to a function with an incomplete pattern match and convert invoking it to a Maybe?
09:19:49 <tonfa> but induction variable detection is good anyway
09:19:59 <tonfa> that's just a special case
09:20:20 <quicksilver> tonfa: the new ghc has a pretty nice register allocator
09:20:24 <quicksilver> tonfa: in theory, at least.
09:20:36 <quicksilver> tonfa: in practice, it doesn't do all that well for a couple of silly reasons.
09:20:37 <desegnis> darrint: Only by capturing the error as an exception, I think, so you'd be stuck to the IO monad
09:20:45 <quicksilver> darrint: basically, no.
09:20:57 <vininim> What is ghc's internal represantation?
09:21:00 <darrint> rats. Because I need to handle this in an stm transactions.
09:21:01 <quicksilver> darrint: don't write functions with incomplete pattern matches.
09:21:07 <quicksilver> vininim: magic dust
09:21:14 <tonfa> quicksilver: is there some documentation about it ?
09:21:19 <tonfa> or just the source ?
09:21:28 <darrint> cast almost does what I want.
09:21:32 <quicksilver> tonfa: there was an interesting mailing list post about it. or sequence of posts.
09:21:50 <tonfa> I'll try to find it, then
09:22:04 <quicksilver> darrint: incomplete pattern matches are bugs. they should never occur in "working operation"
09:22:17 <quicksilver> darrint: either change the offending function or reimplement it.
09:23:13 <quicksilver> tonfa: http://www.mail-archive.com/haskell-cafe@haskell.org/msg34906.html
09:23:14 <lambdabot> Title: [Haskell-cafe] Re: #haskell works, http://tinyurl.com/2fo2hv
09:23:19 <quicksilver> tonfa: was one such email. I think there was another.
09:24:44 <ehird`> what is the hpaste type sig?
09:25:30 <desegnis> @type fmap
09:25:30 <tonfa> quicksilver: cool, thanks
09:25:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:26:05 <ehird`> aha :)
09:26:15 <ehird`> @djinn forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:26:16 <lambdabot> Cannot parse command
09:26:25 <ehird`> @djinn (Functor f) => (a -> b) -> f a -> f b
09:26:32 <darrint> quicksilver: The what I really need is a more compact notation for \x -> case x of { Happy id -> Just id ; x -> Nothing }
09:26:37 <shachaf> ehird`: I don't think the function you asked for is possible.
09:26:44 <ehird`> Probably not.
09:26:48 <ehird`> @src fmap
09:26:49 <lambdabot> Source not found. There are some things that I just don't know.
09:27:04 <shachaf> ehird`: (I mean, the one that makes tuples.)
09:27:20 <Lord_Illidan> hi guys
09:27:32 <ehird`> shachaf: Oh.
09:27:39 <ehird`> Well, it is, just not in the style I said.
09:27:40 <ehird`> Probably.
09:27:41 <ehird`> :-)
09:27:46 <ehird`> Case in point:
09:27:47 <Lord_Illidan> Is there a way in haskell to do something for n times? As if in a for loop?
09:27:51 <ehird`> @type \a b c -> (a,(b,c))
09:27:52 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> (t, (t1, t2))
09:27:55 <ehird`> @pl \a b c -> (a,(b,c))
09:27:56 <shachaf> ehird`: It's in a type class, so it's different for each type.
09:27:56 <lambdabot> (. (,)) . (.) . (,)
09:28:03 <shachaf> @ty mapM_
09:28:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:28:05 <ehird`> @unpl (. (,)) . (.) . (,)
09:28:06 <lambdabot> (\ g m d -> ((,)) g (((,)) m d))
09:28:14 <Syzygy-> Lord_Illidan: Several ways.
09:28:16 <shachaf> ehird`: No, I mean for n arguments.
09:28:23 <ehird`> shachaf: I didn't say N arguments.
09:28:33 <shachaf> Lord_Illidan: You'll need to be more specific, probably.
09:28:38 <Lord_Illidan> Sure
09:28:40 <Syzygy-> ?type for
09:28:42 <lambdabot> Not in scope: `for'
09:28:58 <Lord_Illidan> I have a 4 square checked shape
09:29:00 <shachaf> <ehird`> first one who gets "f 1 2 3" -> (1,(2,3)) or (1,(2,(3,()))) using that general style wins something :P
09:29:11 <shachaf> Oh, by "general style" you mean @pl-ed.
09:29:13 <ehird`> Yes. N=3.
09:29:14 <ehird`> And no.
09:29:16 <ehird`> I don't.
09:29:26 <ehird`> <ehird`> > (curry$flip (,)) 1 2 3
09:29:30 <ehird`> I meant curry-flip-etc stuff
09:29:34 <shachaf> ehird`: You mean with curry/uncurry/flip.
09:29:34 <ehird`>  > (curry$flip (,)) 1 2 3
09:29:38 <shachaf> ehird`: OK, fine.
09:29:44 <ehird`> shachaf: Well, not STRICTLY ... but that general idea.
09:29:45 <ehird`> > (curry$flip (,)) 1 2 3
09:29:49 <Syzygy-> Lord_Illidan: What exactly do you mean by "do something n times"? First off, will you be doing this with a pure function, or with something monadic?
09:29:51 <ehird`> hmm
09:29:54 <ehird`> lambdabot can has dead?
09:29:57 <Syzygy-> If it's monadic, then there is the forM function.
09:29:58 <lambdabot>  (3,(1,2))
09:30:06 <shachaf> @version
09:30:06 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
09:30:06 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:30:18 <desegnis> Lord_Illidan, or even replicateM
09:30:38 <Lord_Illidan> as in, one white square,one black square on one line, and below them one black square and white square.. Like the rows a8,b8,a7,b7 on this chess board : http://www.chesscentral.com/chess_rule/pix/chess_board_blank.gif
09:30:54 <Lord_Illidan> From that shape, I have to make an entire chessboard.. Any ideas on how to do  it?
09:30:56 <shachaf> Lord_Illidan: What is the type of what you'll be returning at the end?
09:31:03 <Syzygy-> If you really want f(f(f(f(...(f(x))))))...))) for some clever f, then iterate might help you get it out.
09:31:27 <vincenz> > iterate f x :: Expr
09:31:27 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
09:31:30 <Lord_Illidan> If it was a java app, I would do it with iteration
09:31:38 <vincenz> > drop 100 $ iterate f x :: Expr
09:31:38 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
09:31:45 <Syzygy-> > iterate f x :: [Expr]
09:31:46 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
09:31:50 <vincenz> > drop 100 $ iterate f x :: [Expr]
09:31:51 <lambdabot>  [f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
09:31:57 <Syzygy-> > drop 100 $ head $ iterate f x :: Expr
09:31:58 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
09:32:02 <vincenz> Syzygy-: haha
09:32:08 <desegnis> Lord_Illidan, no way to give a useful response if we don't know your data type
09:32:10 <Syzygy-> Pbt.
09:32:14 <Syzygy-> > drop 100 $ head $ iterate f x :: [Expr]
09:32:14 <vincenz> > head $ drop 100 $ iterate f x :: Expr
09:32:15 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
09:32:15 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
09:32:17 <shachaf> > runWriter $ replicateM_ 5 (do { tell "A " })
09:32:18 <lambdabot>  ((),"A A A A A ")
09:32:20 <vincenz> Syzygy-: nice one..
09:32:24 <Lord_Illidan> err, it's Picture
09:32:24 <vincenz> Syzygy-: dropping post head?
09:32:34 <Syzygy-> vincenz: Huh?
09:32:40 <vincenz> drop first, then head..
09:32:42 <Syzygy-> Ooooooh.
09:32:43 <Syzygy-> Hrm.
09:32:49 <gnuvince> I'm in chapter 8 of Graham Hutton's book.  He defines return and (>>=).  When I load my code, there is an ambiguity between those I wrote and those in GHC.Base.  Is it possible to hide the definitions of those in GHC.Base in my module?  I tried import GHC.Base hiding (return, (>>=)), but that didn't work.
09:33:01 <shachaf> gnuvince: See the book's website.
09:33:29 <shachaf> gnuvince: Otherwise, you'll probably want to use instance Monad MyType where (>>=) = ...; return = ...
09:33:36 <Lord_Illidan> desegnis, It's basically an exercise from a book..I have this type Picture, and I have to construct a chess board
09:33:50 <shachaf> gnuvince: (Or use -fno-implicit-prelude, if you really want to define them yourself.)
09:33:59 <Lord_Illidan> Now, in the book, iteration/recursion hasn't even been defined yet, but I think that's the way to do it
09:34:10 <shachaf> Lord_Illidan: What is Picture?
09:34:12 <desegnis> Lord_Illidan, you can imagine that knowing that the type is called Picture doesn't tell me anything?
09:34:15 <shachaf> Lord_Illidan: Which book is this?
09:34:49 <Lord_Illidan> The book is : The Craft of Functional Programming
09:35:33 <araujo> hello
09:35:51 <Lord_Illidan> desegnis, I know..well, I'm going to post the code of the module the book is using on pastebin, so you can see it
09:36:26 <desegnis> (Personally I don't like assignments where you construct some structure just for the sake of that structure. You don't learn problem-solving this way... but anyhow)
09:36:51 <Lord_Illidan> desegnis, http://pastebin.com/d6f290903
09:37:03 <desegnis> Lord_Illidan, we prefer hpaste here due to Haskell syntax highlighting - d'oh, too late :)
09:37:24 <Lord_Illidan> pastebin.com does Haskell syntax highlighting, too
09:37:58 <hpaste>  Jean Azzopardi pasted "Pictures" at http://hpaste.org/5731
09:37:59 <shachaf> gnuvince: http://www.cs.nott.ac.uk/~gmh/book.html should have working code.
09:38:00 <lambdabot> Title: Programming in Haskell
09:38:13 <Lord_Illidan> but, dw : http://hpaste.org/5731
09:38:30 <Lord_Illidan> heh, nice bot :D
09:38:45 <shachaf> gnuvince: (However, I think part of the point is for you to understand the code on paper.)
09:40:01 <desegnis> Lord_Illidan, here's an idea for you:
09:40:05 <desegnis> > take 8 (cycle ".#")
09:40:07 <lambdabot>  ".#.#.#.#"
09:40:28 <Syzygy-> > take 8 . drop 1 . cycle $ ".#"
09:40:29 <lambdabot>  "#.#.#.#."
09:43:40 <Stinger_> @src runX
09:43:40 <lambdabot> Source not found. I am sorry.
09:43:42 <Lord_Illidan> hmm, fun one
09:44:01 <thotypous> hi :)
09:44:12 <Lord_Illidan> does it try to make a list of size n full of the elements defined?
09:44:27 <Lord_Illidan> or do I have it wrong?
09:44:37 <shachaf> Stinger_: If this is xmonad, it's defined in Core.hs.
09:44:41 <dons> ?yow
09:44:41 <lambdabot> In Newark the laundromats are open 24 hours a day!
09:44:45 <dons> ?users
09:44:45 <lambdabot> Maximum users seen in #haskell: 463, currently: 449 (97.0%), active: 19 (4.2%)
09:44:57 <thotypous> I'm learning Haskell by using the wikibook, and I solved exercise 4 at http://en.wikibooks.org/wiki/Haskell/More_about_lists, but it looks weird: http://paste.lisp.org/display/56085 .. can anybody help me have a better idea? :)
09:44:58 <shachaf> Stinger_: (Since X is an xmonad type, there's no reason for \bot to know about it.)
09:45:18 <Stinger_> well no it was HXT, and its runs arrows aparently
09:45:22 <dons> thotypous: yeah, let's have a look.
09:45:27 <thotypous> thanks :)
09:46:14 <Stinger_> it runs*
09:46:20 <u_quark> when evaluating haskell code in lambdabot i get a /tmp/MWzJYG4258.o: unknown symbol `__stginit_numberszm2007zi9zi25_DataziNumberziSymbolic_' - y is that ?
09:47:21 <shachaf> @src scanl
09:47:21 <lambdabot> scanl f q ls = q : case ls of
09:47:21 <lambdabot>     []   -> []
09:47:21 <lambdabot>     x:xs -> scanl f (f q x) xs
09:47:45 <shachaf> u_quark: Which code?
09:47:59 <u_quark> > 1 --for example
09:47:59 <lambdabot>  1
09:48:03 <thotypous> @src scan
09:48:04 <lambdabot> Source not found. Wrong!  You cheating scum!
09:48:04 <dons> tail (scanl (+) 0 [1..10])
09:48:22 <thotypous> @src take
09:48:22 <lambdabot> take n _      | n <= 0 =  []
09:48:22 <lambdabot> take _ []              =  []
09:48:22 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
09:48:26 <thotypous> great bot :)
09:48:29 <shachaf> u_quark: Oh, in your own lambdabot.
09:48:36 <u_quark> yes :)
09:48:59 <ddarius> When we have hackage/hoogle/lambdabot integration maybe lambdabot will know all.
09:49:00 <hpaste>  dons pasted "scanl" at http://hpaste.org/5732
09:49:04 <dons> thotypous: http://hpaste.org/5732
09:49:53 <thotypous> dons, hmmm thanks, it's a lot better with those where :) good idea :D
09:50:00 <shachaf> thotypous: However, scanl's definition looks pretty similar to yours.
09:50:16 <shachaf> thotypous: (Though it's more general.)
09:50:36 <thotypous> yes :)
09:51:26 <u_quark> do i need any object code C libs for Data.Number.Symbolic ?
09:54:45 <pitecus> Is it possible to import a module which defined some instances and override them, or avoid importing them somehow?
09:54:58 <quicksilver> no
09:55:13 <quicksilver> instances are global, in the sense that there can only be one anywhere in the entire world
09:55:18 <quicksilver> ;P
09:55:41 <quicksilver> but seriously, local instances break stuff. The global instance assumption runs pretty deep.
09:55:47 <quicksilver> Which is admittedly a shame.
09:55:51 <shachaf> quicksilver: What do they break?
09:56:17 <quicksilver> shachaf: imagine that two modules, a very long way apart, have access to different (Ord) instances for a type
09:56:35 <quicksilver> shachaf: such as by an import scheme like pitecus describes.
09:57:02 <quicksilver> shachaf: now suppose that by some complex communication path, a Data.Map from one module can reach the other...
09:57:05 <quicksilver> BOOM!
09:57:10 <quicksilver> That was the sound of the universe imploding.
09:57:23 <pitecus> so i need to wrap stuff in a newtype?
09:57:44 <quicksilver> yup
09:58:22 <shachaf> quicksilver: Hmm... People have not come up with a way to make that work? :-(
09:58:42 <quicksilver> shachaf: I think they probably have, but there is no obviously 'nice' solution.
09:58:59 <shachaf> quicksilver: Yes, I mean "work nicely". :-)
09:59:10 <quicksilver> I think classes are somewhat overused and people should use nice higher order features like functions and so on instead
09:59:15 <quicksilver> a lot of the time
09:59:25 <quicksilver> and save classes for things like 'Num' and 'Eq' and 'Monad'
10:00:03 * shachaf has sometimes though classes are underused, in various places.
10:00:14 * BMeph wants a Vector Field class
10:01:34 <desegnis> Lord_Illidan, look at the definitions or documentation of the functions involved to understand what's going on
10:02:00 <tonfa> is there an easy way to compile a .s generated by ghc -S into an exe ?
10:03:18 <shepheb> if I specify -threaded or -N2 in the source file, and specify differently with the command line to ghc and the RTS, which wins?
10:03:18 <K0MPR3SS0R> hello
10:04:02 <quicksilver> shachaf: what do you mean by 'specify -N2 in the source file' ?
10:04:11 <quicksilver> shepheb: what do you mean by 'specify -N2 in the source file' ?
10:04:14 <quicksilver> shachaf: sorry :P
10:04:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5733
10:04:46 <K0MPR3SS0R> hello
10:04:52 <wli> BMeph: I want a module and ring class.
10:05:01 <quicksilver> who pasted that?
10:05:05 <K0MPR3SS0R> me
10:05:11 <K0MPR3SS0R> i need help with this assignment
10:05:24 <BMeph> wli: <shrugs> I want it all. ;)
10:05:25 <K0MPR3SS0R> i need to be able to read a list of characters into a binary tree
10:05:26 <shachaf> K0MPR3SS0R: Think about what "data Tree a = ..." means.
10:05:34 <quicksilver> kolmodin: you can't use "Tree" as a type
10:05:38 <quicksilver> kolmodin: argh, sorry
10:05:43 <quicksilver> K0MPR3SS0R: you can't use "Tree" as a type
10:05:46 <quicksilver> bad tab completion day!
10:05:51 <quicksilver> K0MPR3SS0R: cos it has a parameter
10:06:02 <quicksilver> e.g. "Tree Integer" is a type, and so is "Tree String"
10:06:14 <quicksilver> (I can see other problems in that source file too but it's a start)
10:06:20 <K0MPR3SS0R> im confused I thought I was creating a tree accepting parameter a
10:06:27 <shepheb> quicksilver: can't one specify such things in a > {-# LANGUAGE -threaded #-} < or such?
10:06:29 <K0MPR3SS0R> whatever a type is
10:06:43 <quicksilver> shepheb: not RTS options, no
10:06:48 <shachaf> K0MPR3SS0R: Yes, but a specific Tree is for a *specific* a.
10:06:54 <quicksilver> shepheb: RTS options are not compile-time options, they are run-time options.
10:06:58 <shachaf> K0MPR3SS0R: Just like you have [Char].
10:07:13 <K0MPR3SS0R> so should I put Tree Char
10:07:14 <shepheb> quicksilver: okay, I guess I would have to create a wrapper script then. just a hypothetical, thanks.
10:07:20 <quicksilver> shepheb: there is a way to specify RTS defaults at compile-time, which involves a seaprate C file.
10:07:33 <quicksilver> in that case, the compiled in default is just a default.
10:07:39 <quicksilver> command-line overrides.
10:08:00 <quicksilver> "-threaded" choooses an RTS. That's a link-time decision (not even a compile time one) and once made, it's irrevocable.
10:08:34 <shachaf> K0MPR3SS0R: You could, if you want a Tree of Chars. :-)
10:08:52 <hpaste>  tonfa annotated "simple example" with "ghc as fast as ocamlopt ?" at http://hpaste.org/5730#a4
10:09:03 <shepheb> quicksilver: okay, that makes things clearer, thanks.
10:09:04 <quicksilver> K0MPR3SS0R: your next problem is that you declare 'ins' as taking one parameter but then define it as taking two.
10:09:10 <tonfa> quicksilver: ghc could easily be as fast as ocamlopt :)
10:09:24 <K0MPR3SS0R> yes I just need to store a string into a binary tree, im doing this by using a list of chars to represent the word for example [a, l, p, h, a]
10:09:27 <K0MPR3SS0R> would be one word
10:09:35 <shachaf> K0MPR3SS0R: Note, however, that you aren't doing anything Char-specific in your functions.
10:09:38 <K0MPR3SS0R> and I need to read each character and put it into the binary tree
10:09:53 <K0MPR3SS0R> what would be the best way to read that word in then?
10:10:14 <vincenz> > 9*1024*1024*1024*1024/200/1000/1000
10:10:18 <lambdabot>  49478.02324992
10:10:23 <quicksilver> K0MPR3SS0R: you're doing that bit fine.
10:10:26 <shepheb> is there a feature request for a module option to ghci? something akin to perl -MSome::Module -e 'some one-liner'.
10:10:32 <quicksilver> K0MPR3SS0R: (reading in the list of chars by 'pattern matching')
10:10:49 <quicksilver> K0MPR3SS0R: however you have given 'ins' the wrong type.
10:10:51 <K0MPR3SS0R> i cant use pattern matching for this assignment
10:11:15 <K0MPR3SS0R> cannot use any predefined haskell functions or anything
10:11:26 <quicksilver> of course you can use pattern matching
10:11:28 <allbery_b> shepheb: not usually needed, ghci implicitly imports modules if you use fully qualified names
10:11:29 <quicksilver> you are using it!
10:11:30 <shachaf> K0MPR3SS0R: You already are using pattern-matching.
10:11:38 <quicksilver> build1 (x:xs) = ins x (build1 xs)
10:11:44 <quicksilver> ^^^^^^^^ that's pattern matching
10:11:45 <K0MPR3SS0R> uhmm
10:11:47 <K0MPR3SS0R> lol
10:12:07 <quicksilver> you can't write much using trees or lists  in haskell without a bit of pattern matching :)
10:12:09 <K0MPR3SS0R> i thought it was soemthing else
10:12:11 <shepheb> allbery_b: fair enough. thanks.
10:12:30 <quicksilver> shepheb: there is a way and I don't remember it. There have been some blog posts about it.
10:12:40 <quicksilver> shepheb: about using haskell for commandline hacks.
10:12:49 <Saizan> K0MPR3SS0R: in haskell what is usually called pattern matching has nothing to do with regexes
10:12:53 * shachaf wishes ghci could import qualified/hiding.
10:13:09 <K0MPR3SS0R> our teacher said : digits st = [ch | ch <- st, isDigit ch] would be pattern matching
10:13:13 <K0MPR3SS0R> with a pipe simble
10:13:22 <quicksilver> that's list comprehension
10:13:28 <K0MPR3SS0R> ohhh thats right
10:13:38 <K0MPR3SS0R> thanks lol, list comprehension is what were not allowed to use!
10:13:44 <quicksilver> although list comprehensions can use pattern matching that one doesn't (well, only trivially)
10:13:47 <quicksilver> :)
10:13:59 <dcoutts> K0MPR3SS0R: the 'ch' in the "ch <- st" is a pattern, however it is a trivial pattern that always matches.
10:14:07 <K0MPR3SS0R> ok so now you said that my ins in my code is of the wrong type?
10:14:14 <allbery_b> <evil> so write it in the list monad instead </evil>
10:14:23 <quicksilver> yes, you define and use 'ins' to take two parameters
10:14:26 <shachaf> K0MPR3SS0R: Think about what it's supposed to do.
10:14:30 <quicksilver> but you give it the type "Char -> Tree"
10:14:36 <quicksilver> which only takes one parameter
10:14:38 <shachaf> K0MPR3SS0R: What arguments does it get, and what does it return?
10:14:43 <quicksilver> even when we fix the broken part
10:14:54 <K0MPR3SS0R> im giving it a character and I want to insert it into a particular tree, 2 arguments. whats wreong with that?
10:15:20 <shachaf> K0MPR3SS0R: What are the arguments to the function?
10:16:15 <kpreid> quicksilver: (re can't do much without patterns) oh yeah? data Tree a = Tree { leaf :: Bool, x :: a, l :: Tree a, r :: Tree a }; flat t | leaf t = x t; | otherwise = flat (l t) `mplus` flat (r t) -- if you don't want even any variable patterns, just @pl it
10:16:18 <kpreid> mkLeaf x = Tree True x undefined undefined
10:16:19 <K0MPR3SS0R> oh okay, so it will read one character from that character array, and with an existing tree called x = it will traverse it and insert that character in the right place
10:18:19 <shachaf> K0MPR3SS0R: That's not an array, it's a list.
10:18:54 <shachaf> K0MPR3SS0R: And in Haskell, functions don't modify their arguments, they return new values (as your implementation seems to be trying to do).
10:19:39 <Le-Chuck_ITA> Hi all! Do we have a category theory channel?
10:20:08 <shachaf> Le-Chuck_ITA: Perhaps #math?
10:20:22 <dons> oh here.
10:20:27 <ddarius> shachaf: Not really, but the question is off-topic here and more on-topic there.
10:20:27 <Le-Chuck_ITA> not sure I went there once and they didn't look like :)
10:22:01 <dons> Igloo: so are we doing the untabify pass, as an emergent behaviour? :)
10:23:56 <Igloo> dons: Heh, I was only untabifying because I wanted to fix warnings, and it's easier if you untabify first
10:24:16 <dons> yeah.
10:24:25 <dons> when i open up a file to check something, the first thing i do is untabify
10:24:38 <dons> so i figured i may as well commit those, rather than polluting the tree
10:24:45 <vincenz> :%s/^t/  /g
10:24:48 <Igloo> Yeah
10:24:55 <vincenz> :set fileformat=unix
10:24:58 <vincenz> :wq
10:24:59 <Igloo> vincenz: :retab is more correct
10:25:07 * Le-Chuck_ITA apt-get installs xmonad
10:25:08 <dons> yeah. that's what I use
10:25:13 <dons> Le-Chuck_ITA: cool!
10:25:15 <vincenz> Igloo: never heard of that one
10:25:17 <dons> xmonad 0.6 from debian?
10:25:18 <Igloo> Along with :%s/  *$//
10:25:23 <Le-Chuck_ITA> no 0.4 from hardy :)
10:25:29 <gnuvince> dons: do you not blog anymore?
10:25:32 <K0MPR3SS0R> man im confused i dont understand how to fix this anymore
10:25:35 <K0MPR3SS0R> its very simple I know
10:25:46 <K0MPR3SS0R> but I dont get what data type is wrong or what to do
10:25:49 <shachaf> Le-Chuck_ITA: You should probably not use 0.4.
10:25:50 <dons> gnuvince: i'm between blogs
10:25:55 <shachaf> Le-Chuck_ITA: 0.5/0.6 is much nicer. :-)
10:26:03 <dons> gnuvince: since moving countries. i've a new site, which i may get set up soon
10:26:03 <Le-Chuck_ITA> we should get a sync with debian
10:26:07 <dcoutts> dons: what's the cheap and easy way to untabify?
10:26:15 <dons> Le-Chuck_ITA: hmm. 0.6 is much better
10:26:16 <dcoutts> dons: I want to do it to cabal too
10:26:22 <Igloo> dcoutts: :retab in vim
10:26:24 <dons> dcoutts: :retab in vim ..
10:26:28 <dcoutts> ta :-)
10:26:30 <Igloo> dcoutts: (:set ts=8 first, if appropriate)
10:26:44 <ddarius> Maybe some day I will upgrade from 0.3
10:26:52 <dons> ddarius: wow
10:27:04 <maskeye> is there an easy way to fix Cabal if i installed `process` package before `filepath` and it got broken?
10:27:05 <dons> hehe, Igloo is #1 on http://www.ohloh.net/ :)
10:27:06 <lambdabot> Title: Ohloh, the open source network
10:27:25 <Le-Chuck_ITA> is there xmonad in .deb format?
10:27:31 <Le-Chuck_ITA> maybe  in debian's archive
10:27:35 <dons> Le-Chuck_ITA: yeah. in debian
10:27:39 <Igloo> dons: Yeah, for getting my second kudos, as far as I can tell  :-)
10:27:41 <gnuvince> dons: OK. Plus I guess Real World Haskell is keeping you busy
10:27:42 <bd_> Le-Chuck_ITA: it's in debian testing
10:27:45 <dcoutts> maskeye: what's the problem exactly?
10:27:47 <u_quark> @wikipedia lambda
10:27:47 <lambdabot> No Result Found.
10:27:49 <gnuvince> (gives us more chapters!)
10:27:53 <dons> gnuvince: that's chewing up a lot of time, yep.
10:28:01 <dons> http://packages.debian.org/sid/xmonad
10:28:03 <lambdabot> Title: Debian -- Details of package xmonad in sid
10:28:13 <dons> we're having a mini hackathon in portland today. btw. web framework hacking
10:28:21 <dons> 4 guys, 4 laptops
10:28:24 <dcoutts> dons: do you know if ohloh is going to get darcs support, it's silly us having to proxy everything via git.
10:28:31 <maskeye> http://hpaste.org/5734
10:28:36 <dons> dcoutts: i'm not sure.
10:28:49 <maskeye> i get that trying to build
10:28:54 <dons> Igloo: the ghc->git pass is up to 1997 now
10:28:57 <dons> man ruby is slow.
10:29:01 <maskeye> s/build/configure
10:29:02 <oal> anybody doing parallel haskells here?
10:29:03 <Igloo> Heh
10:29:05 <ddarius> "4 guys, 4 laptops. WHO WILL WIN?"
10:29:05 <Le-Chuck_ITA> dons ok clicked on that and installed it :) so easy these days
10:29:17 <dons> oal: yeah. a few here.
10:29:22 <Igloo> dons: Has that been running for 2 days?
10:29:25 <ddarius> dons: Prod some newbie in implementing a ruby compiler
10:29:29 <dons> Igloo: yep.
10:29:49 * dons tried to get SamB to translate the code to haskell, just for the speed boost
10:29:50 <u_quark> @wikipedia some_random_text_here
10:29:51 <lambdabot> No Result Found.
10:29:52 <dcoutts> maskeye: so it looks like your process package is borked, you'll need to rebuild it and perhaps other packages that depend on it.
10:29:54 <Igloo> Hmm, that really is slow, compared to past conversions, I think
10:30:06 <dons> its some kind of naive import system
10:30:16 <Igloo> You could probably write ohloh darcs support in that time, if it was open  :-)
10:30:20 <oal> dons, oh. Ok. Is there a parMap out there, which has the same signature as "normal" map?
10:30:20 <Le-Chuck_ITA> aaargh! This smonad thingy is also using my compiz effects
10:30:24 <dons> dcoutts: it worked on cabal, but failed on c2hs and gtk2hs
10:30:27 <oal> Or is it too much to ask?
10:30:32 <dons> oal: yes, parMap
10:30:33 <dcoutts> dons: ah I see
10:30:37 <dcoutts> Igloo: it is open I thought
10:30:38 <dons> in Control.Parallel.Strategies
10:30:40 <shachaf> Le-Chuck_ITA: You can't run compiz and xmonad together, if that's what you mean.
10:30:45 <maskeye> thanks dcoutts.
10:30:47 <shachaf> Le-Chuck_ITA: (There's a #xmonad, by the way.)
10:30:49 <Le-Chuck_ITA> it seems to be doing that right now
10:30:56 <Igloo> dcoutts: I thought only the line counting was
10:31:03 <dcoutts> Igloo: http://www.ohloh.net/pages/101
10:31:04 <lambdabot> Title: Ohloh Goes Open Source
10:31:07 <Le-Chuck_ITA> shachaf: ok thanks
10:31:09 <dons> yeah, they use git internally, and convert all things to git
10:31:11 <oal> dons, meh. parMap I have here wants some Strategies
10:31:15 <dons> so it would be a darcs2git internally anyway
10:31:22 <dons> oal: give it rnf as a strategy
10:31:27 <Igloo> Ah, I see
10:31:34 <dcoutts> Igloo: right looks like line counting only so far, but presumably they'd be happy to accept scm support too
10:31:45 <oal> dons, oh, ok. Thank you, I'll give it a try
10:32:00 <Igloo> dcoutts: Hard to write scm support without knowing what you have to interface with, though  :-)
10:32:22 <dcoutts> Igloo: sure, but it looks like they'll get there going by the press release
10:32:34 <waern> speaking of mini hackathons - me, nominolo and kolmodin had one a couple of weeks ago as well :)
10:32:42 <dons> it might be interesting to use their statiistcs api for hackage
10:32:43 <dcoutts> waern: what did you hack on?
10:32:51 <dons> you can export and query their database
10:32:57 <dcoutts> dons: right, or just sloccount, or something based on the ghc api
10:33:11 <waern> dcoutts: we looked at yi and the incremental parser there, and on conal's reactive stuff... we didn't get that far with anything though
10:33:11 <shachaf> dons: Since you posted the information about the new Seattle FP group -- do you know any contact details for Greg Meredith?
10:33:25 <dons> shachaf: only that he runs on biotech company (?)
10:33:26 <shachaf> dons: Apparently he hasn't reponded to emails.
10:33:37 <dcoutts> dons: I think there is a huge scope for code analysis/metrics based on cabal/hackage/ghc-api
10:33:49 <shachaf> dons: The people in SeaFunc are saying that it's a bit silly to have two groups in the same area. :-)
10:34:03 <dons> dcoutts: yep
10:34:19 <shapr> Doesn't SeaFunc have Brandon J Van Every?
10:34:27 <shachaf> shapr: Yes.
10:34:40 <shachaf> shapr: (Or at least the mailing list does, I haven't been to a meeting. :-) )
10:34:42 <shapr> In that case, it might make sense to have two groups in the same area.
10:34:59 <shachaf> shapr: Why?
10:35:03 <dons> waern: cool
10:36:01 <dcoutts> waern: what is yi's incremental parser? it's an attempt at an incremental Haskell parser?
10:36:45 <dons> dcoutts: at least the version i worked on used ghc's lexer, incrementally
10:36:56 <waern> dcoutts: well, it's just an attempt at a parser library at the moment I think, but the goal is to parse a (simple subset of) Haskell
10:37:06 <dcoutts> waern: interesting
10:37:22 <dcoutts> dons: yeah, I remember the incremental lexer, that's a good deal simpler
10:37:46 <waern> hey, that lexer, if I understand things correctly, isn't GHC's lexer
10:38:00 <dcoutts> it's a derivative as I recall
10:38:00 <dons> oh interesting. it used to be.
10:38:06 <waern> it's an extremely simplified version of it
10:38:40 <waern> atleast if you're talking about that alex file that is used by visual haskell and hIDE as well
10:38:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5735
10:38:47 <dcoutts> waern: because it was only needed for highlighting, so you didn't need so much detail?
10:38:52 <K0MPR3SS0R> alright
10:39:11 <K0MPR3SS0R> can someone help me with that  http://hpaste.org/5735
10:39:25 <ehird`> Tree Char?!
10:39:28 <ehird`> What does that mean?
10:39:30 <waern> dcoutts: sure
10:39:34 <K0MPR3SS0R> I tried to do some changes to see if it would work. but keep some error
10:39:36 <ehird`> ITYM:
10:39:41 <ehird`> data Tree a = Nil | Node a (Tree a) (Tree a)
10:39:41 <K0MPR3SS0R> uhmm A tree that will accept characters?
10:39:50 <ehird`> K0MPR3SS0R: so why do you need to say "Tree Char"
10:39:52 <ehird`> why not just Tree?
10:40:03 <dcoutts> ehird`: you're comfortable with the idea of [Char] right?
10:40:09 <K0MPR3SS0R> I dunno I thought thats how it was supposed to be
10:40:16 <ehird`> dcoutts: Uhm, yes?
10:40:21 <ehird`> I know.
10:40:23 <dcoutts> ehird`: that list is a 'generic' type that can accept different types of content
10:40:23 <ehird`> But look at his code.
10:40:28 <ehird`> "data Tree Char = ..."
10:40:47 <dcoutts> ehird`: well that concept extends to other user-defined types, like Tree
10:40:54 <ehird`> dcoutts: look at his code
10:40:55 <ehird`> it is not:
10:40:58 <ehird`> "data Tree a = ..."
10:41:03 <K0MPR3SS0R> so is it alright to use a non generic data type?
10:41:04 <ehird`> it's "data Tree Char = .... stuff with Char ..."
10:41:13 <ehird`> which makes no sense at all, of course
10:41:19 <dcoutts> ehird`: oh right yes, that's a mistake
10:41:29 <K0MPR3SS0R> i dont understand...
10:41:31 <dcoutts> ehird`: sorry, I misunderstood :-)
10:41:38 <ehird`> K0MPR3SS0R: OK, let me try and explain
10:41:46 <ehird`> You have:
10:41:46 <ehird`> data Tree Char = Nil | Node Char (Tree Char) (Tree Char)
10:41:50 <ehird`> Tell me why this won't work:
10:41:53 <ehird`> data Tree = Nil | Node Char (Tree Char) (Tree Char)
10:41:58 <ehird`> err
10:42:02 <ehird`> data Tree = Nil | Node Char Tree Tree
10:42:25 <K0MPR3SS0R> uhmm...
10:42:32 <K0MPR3SS0R> so this is the right way to do it?
10:43:03 <K0MPR3SS0R> so why is general example like : data Tree a = Nil | Node a (Tree a) (Tree a)
10:43:11 <K0MPR3SS0R> I thought a was generic data type
10:43:27 <qwr> kosmikus: it is. the upper/lowercase start matters
10:43:27 <K0MPR3SS0R> and I wanted Char data type, so I replaced a with Char... that was my reasoning
10:43:28 <monochrom> Char is not a type variable.  In "data Tree = ..." or "data Tree more_stuff_here = ...", you are supposed to use type variables, or nothing.
10:43:53 <qwr> s/kosmikus/K0MPR3SS0R /
10:43:54 <monochrom> You are the author of Tree. You make it generic or not generic.
10:44:13 <K0MPR3SS0R> ok
10:44:27 <K0MPR3SS0R> so now would it be better in my aplication to leave it generic  or not?
10:45:10 <monochrom> That is a question you will have to learn to answer in your next 20 years of programming career.
10:45:24 <K0MPR3SS0R> heh
10:45:35 <K0MPR3SS0R> i dont plan on being a programmer
10:45:55 <K0MPR3SS0R> it frustrates me too much, and now that I have to learn functional programming with haskell, it makes me want to pull all my hair out
10:46:45 <monochrom> Usually you can bet safely on the general side.
10:47:02 <K0MPR3SS0R> uhmmk
10:47:04 <dons> it can be a joyous, creative, absorbing activity though, K0MPR3SS0R :)
10:47:05 <qwr> K0MPR3SS0R: usually i would use generic types. but concrete type may possibly make it more optimisable for compiler (i don't know ghc internals well enough) and you get easier to understand type errors.
10:47:15 <dons> particularly if the language gets out of the way
10:47:15 <ehird`> K0MPR3SS0R: OK, you replace 'Tree a' with 'Tree CHar' when you USE it
10:47:18 <dons> and you can just code
10:47:27 <ehird`> Otherwise, you don't need to say 'Tree Char', if you can only accept Chars.
10:47:34 <K0MPR3SS0R> oh also, my variable t = [a, l, p, h, a] do I put each letter in "a" or single quote 'a'
10:47:44 <ehird`> K0MPR3SS0R: "abc" works. 'abc' doesn't.
10:47:47 <ehird`> you can figure it out from that ;)
10:48:24 <shachaf> Or look at the type in ghci.
10:48:29 <shachaf> @ty 'a'
10:48:29 <lambdabot> Char
10:48:30 <shachaf> @ty "a"
10:48:30 <lambdabot> [Char]
10:48:46 <K0MPR3SS0R> yes I know with strings its ""
10:48:51 <K0MPR3SS0R> alright ill just use ""
10:48:59 <ehird`> ..
10:49:00 <ehird`> Wrong answer.
10:49:06 <K0MPR3SS0R> lol
10:49:16 <ehird`> Do you just want the computer to work everything out for you when you give it arbitary stuff without thinking?
10:49:38 <monochrom> Yes!
10:49:39 <K0MPR3SS0R> well, these are just different syntax im not used to
10:49:48 <K0MPR3SS0R> normally for single characters I use single quote
10:50:07 <K0MPR3SS0R> and strings double quote, but how am I supposed to know all of the syntax in haskell...
10:50:16 <K0MPR3SS0R> I try something, it doesnt work, so I try the other one
10:50:16 <zarvok> KOMPRESSOR: yes, in haskell you can use that same syntax
10:50:21 <K0MPR3SS0R> ok
10:50:24 <qwr> K0MPR3SS0R: t = "alpha" is same as t = [ 'a', 'l', 'p', 'h', 'a' ]
10:50:26 <K0MPR3SS0R> thnx
10:50:42 <zarvok> the only difference is that strings happen to be implemented as lists of characters.
10:50:49 <Japsu> t = 'a':'l':'p':'h':'a':[]
10:50:52 <Japsu> ;)
10:51:15 <monochrom> IRC is collaborative computing.
10:51:15 <K0MPR3SS0R> so in terms of practicality youre telling me that I should use string instead?
10:51:34 <shachaf> @@ ((@pl (\a b c d e -> [a,b,c,d,e]))) 'a' 'l' 'p' 'h' 'a'
10:51:34 <lambdabot>  ((. ((. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:))) . (.) . (.) . (.) . (:)) 'a' 'l' 'p' 'h' 'a'
10:51:36 <K0MPR3SS0R> I was using char for simplicity, so that I wouldnt have trouble parsing through a string to chose every character
10:51:37 <Japsu> monochrom: have you run into Internet Relay Programming? ;)
10:52:03 <gnuvince> K0MPR3SS0R: String is just an alias for [Char], a list of characters.  The difference between "hello" and ['h','e','l','l','o'] is the ease of typing
10:52:17 <K0MPR3SS0R> ahh I see
10:52:25 <K0MPR3SS0R> alright ill make the necessary changes
10:52:29 <shachaf> K0MPR3SS0R: More general types can actually make your function simpler, not more complicated.
10:52:32 <Japsu> http://www.esolangs.org/wiki/IRP ^^
10:52:33 <lambdabot> Title: IRP - Esolang
10:52:33 <sioraiocht> also,  ['h','e','l','l','o'] looks ridiculous
10:52:47 <lament> > ['h', 'e', 'l', 'l', 'o']
10:52:49 <lambdabot>  "hello"
10:52:59 <Japsu> > 'a':'l':'p':'h':'a':[]
10:53:00 <lambdabot>  "alpha"
10:53:31 <K0MPR3SS0R> but now when I pass my string to my function, it will know to start reading each individual character?
10:53:39 <sioraiocht> > "your" ++ "mom"
10:53:41 <lambdabot>  "yourmom"
10:54:27 <shachaf> > concat ["h", ['e','l'],"lo"]
10:54:27 <lambdabot>  "hello"
10:54:32 <K0MPR3SS0R> perfect, it works!
10:54:38 <K0MPR3SS0R> thanks guys
10:54:43 <monochrom> Why are people obsessed with your mom?
10:54:51 <K0MPR3SS0R> now I have to figure out the rest of this crappy assignment
10:55:10 <sioraiocht> monochrom: I dunno, she's not that exciting
10:55:48 <sioraiocht> <~~~~~~~~~ has a de facto maturity of about 12
10:56:03 <lament> i have a maturity of "your mom"
10:56:14 <sioraiocht> she's not very mature
10:56:16 <sioraiocht> so you're missing out
10:57:43 <sioraiocht> lolcode is amazing
10:57:55 <kolmodin> ?tell waern http://picasaweb.google.com/kolmodin/Minihackathon
10:57:55 <lambdabot> Consider it noted.
10:58:19 <lament> sioraiocht: i suggest you have a look at the esolang wiki, it has a few hundred languages more interesting than lolcode.
10:59:28 <sioraiocht> yeah like NULL
10:59:48 <shachaf> monochrom: Were you the one who was going to write a Haskell Gobby-ish editor?
10:59:48 * sioraiocht wrote a null interpreter in haskell
10:59:49 <dcoutts> sioraiocht: kolmodin and I were thinking of writing the operational semantics of lolcode
10:59:58 <sioraiocht> dcoutts: yes!
11:00:01 <monochrom> No, I don't want to write an editor.
11:00:02 <byte-> hello
11:00:53 <qwr>  
11:00:53 <shachaf> monochrom: But the other parts of it?
11:01:05 * shachaf must be thinking of someone else.
11:02:05 <shachaf> monochrom: Oh, this was byorgey, sorry.
11:02:20 * vincenz cocughs
11:02:32 <byte-> mmm... cocughs
11:02:39 <byte-> those go well with hot cocoa
11:02:47 <byorgey> shachaf: yes, that was me.  vincenz is coughing because he actually thought of the idea first. =)
11:03:16 <shachaf> Sorry, vincenz.
11:03:20 <vincenz> no worries :)
11:03:33 <vincenz> well byorgey it wasn't me alone
11:03:36 <vincenz> it was in collab with ivant
11:03:41 <vincenz> @ hac
11:03:45 <byorgey> oh, right
11:04:24 <shapr> hi byte-, are you learning Haskell?
11:04:24 <vincenz> kind of was "let's improve yi... what do to... I know, gobby sucks @ undo, let's do that"
11:04:30 <shapr> yay Yi!
11:04:49 <byte-> shapr, I already know a decent amount about it
11:04:50 <byorgey> shachaf: note that I probably will not actually end up writing a gobby-ish editor, but I've been thinking about the theory behind such a thing.
11:04:55 <byte-> so not really "learning"
11:05:04 <byorgey> shachaf: I've got a few more blog posts on the subject in the works.
11:05:07 <byte-> I'm writing an interpreter in it for my pet language
11:05:11 <shachaf> byorgey: Well, that's the more interesting part. :-)
11:05:20 <byorgey> shachaf: indeed! =)
11:05:31 <byte-> shapr, why do you ask?
11:05:41 <faxathisia> byte-: what is your language/
11:05:53 <byte-> vaporware, at the moment
11:05:57 <shapr> byte-: Just curious, I like to talk to new people on #haskell
11:05:58 <shachaf> "byte-code"?
11:06:07 <byte-> shapr, oh :)
11:06:11 <shachaf> shapr: byte-'s been here before.
11:06:15 <byte-> shachaf, lol, no
11:06:21 <shapr> shachaf: Yeah, but I haven't spoken to byte- before!
11:06:27 <byte-> the name will either be M, or Mu
11:06:33 <u_quark> @unlambda 1
11:06:33 <lambdabot>  fd:20: hClose: resource vanished (Broken pipe)
11:06:37 <shapr> Life is so busy lately, I don't have much time for #haskell
11:06:38 <byte-> the latter has the possibility for a nice pun in the solgan
11:06:39 <byte-> slogan
11:06:46 <byte-> "reducing errors since ...!"
11:07:19 <byte-> although the former allows for the expansion "Macro programming language"
11:07:54 <byte-> but I've said too much.
11:07:58 <byte-> ;)
11:15:14 <roconnor> @seen dons
11:15:15 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 27m 57s ago.
11:16:07 <dons> roconnor: ?
11:16:09 <shapr> @seen my socks
11:16:09 <lambdabot> I haven't seen my.
11:16:38 <dons> yo shapr! wazzup?
11:16:59 <shapr> y0 y0 dons!
11:17:09 <shapr> I'm just hackin on C#
11:17:37 <shapr> Oh hey, I met the inventor of netcat, inventor of crm114, a former symbolics employee, and a bunch of other geeks of that style and flavor on Saturday.
11:17:57 <shapr> How's the land of Ports treating you?
11:18:29 * monochrom <3 netcat
11:18:48 <u_quark> dons: any ideas why i get this error in lambdabot: /tmp/MVbMJf4860.o: unknown symbol `__stginit_numberszm2007zi9zi25_DataziNumb...
11:19:23 <dagit|lispy> u_quark, try a make clean?
11:19:36 <roconnor> @seen wouter
11:19:37 <lambdabot> I haven't seen wouter.
11:19:39 <dons> u_quark: hmm.
11:19:41 <dagit|lispy> u_quark, also, I believe Cale is the new maintainer
11:19:58 <glguy> orly?
11:20:16 <dagit|lispy> glguy, yes, I thought that's what dons said.
11:20:29 <dons> glguy: see you in 40 mins?
11:20:35 <u_quark> dagit|lispy: i have tried that...
11:20:37 <sieni> glguy: that's a city in france
11:20:44 <glguy> dons: ya
11:21:01 <dagit|lispy> u_quark, hmm
11:21:01 <glguy> sieni: France?
11:21:03 <dons> glguy: what to do about power?
11:21:30 <glguy> I'm bringing two batteries and hoping that something works out
11:21:36 <hpaste>  Big_Red pasted "iterative checker" at http://hpaste.org/5736
11:21:42 <glguy> (I could bring a power strip)
11:21:48 <Big_Red> can anyone take a look at that and tell me where i'm going wrong
11:21:51 <sieni> glguy: the country to the north of spain
11:21:54 <Big_Red> other than my obvious type problem
11:22:08 <glguy> sieni: Oh, the UK?
11:22:13 <sieni> glguy: http://en.wikipedia.org/wiki/Orly
11:22:14 <lambdabot> Title: Orly - Wikipedia, the free encyclopedia
11:23:22 <dons> glguy: a spare power strip might be a good idea.
11:23:25 <dons> we'll see what space we have.
11:23:56 <glguy> Sam knows I'm leaving, is being very clingy
11:24:18 <Big_Red> any ideas anyone?
11:24:24 <byte-> bah
11:24:30 <byte-> why does vim keep opening my files in RO mode...
11:24:43 <glguy> it is passing judgement on you
11:24:43 <faxathisia> t_unit :: STerm
11:24:44 <faxathisia> Big_Red: Well I don't understand it
11:24:52 <faxathisia> Big_Red: What are your types, and what should it do?
11:24:55 <smtms> byte-, because you don't have permission to modify them
11:25:08 <byte-> smtms, sure I do.
11:25:14 <byte-> smtms, doing a :w! works perfectly fine.
11:25:23 <byte-> it's just annoying to have to do that when I open them up :(
11:25:29 <Zao> byte-: You can write to readonly files you own.
11:25:31 <byte-> *first open them up
11:25:47 <Zao> Make sure you have u+w rights.
11:25:55 <Baughn> @hoogle bracket
11:25:56 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:25:56 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
11:25:56 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:26:06 <byte-> Zao, permissions are fine.
11:26:08 <byte-> I just checked.
11:26:13 <Zao> Got a silly vimrc?
11:26:16 <Big_Red> fax: its supposed to take a noughts and crosses board (list of lists) and then permute it a few times down a tree and finally map win to each board
11:26:24 <byte-> Zao, checked that before the permissions :/
11:26:32 <Zao> ACLs? Pie?
11:26:39 <byte-> no
11:26:41 <Big_Red> fax: so if test is a board
11:26:43 <byte-> also...mmm, pie
11:26:56 <Big_Red> fax: map (map win . permute) (permute test) gives me 2 permutations
11:27:09 <glguy> dons: the place on glisan, right?
11:27:11 <Big_Red> fax: map (map (map win. permute) . permute) (permute test) gives me 3
11:27:14 <faxathisia> Big_Red: why permute it?
11:27:21 <Big_Red> trying to create an ai tree
11:27:40 <Big_Red> first step - the ability to create a list of outcomes as deep as i want
11:27:49 <byte-> oh wait
11:27:54 <byte-> I think I figured it out
11:28:01 <byte-> I'm guessing gview opens files in read-only mode?
11:28:10 <faxathisia> Big_Red: Ss how you get a tree of solutions
11:28:11 <byte-> yeah, it does
11:28:12 <glguy> view is vim + readonly
11:28:14 * jaredj fruitcake
11:28:15 <byte-> lol
11:28:18 <faxathisia> Big_Red: So you get a tree of solutions?
11:29:26 * shachaf wants a vim-pager program, if there isn't one already.
11:29:34 <shachaf> Something like less, that can be piped into.
11:29:42 <byte-> emacs?
11:29:46 <Big_Red> fax: well if there's a board with 7 spaces filled in it produces the 2 different places you could go
11:30:08 <faxathisia> Big_Red: But do you get a tree of those answers?
11:30:43 <faxathisia> (as nested lists)
11:31:16 <shapr> shachaf: You can pipe into and out of buffers with emacs
11:31:23 <Big_Red> fax: this isn't a proper tree yet, but each different permutation on the original board gives a board in its own list, each permutation on THOSE boards puts the board in their specific list
11:31:29 <Big_Red> it works if i type it out verbatim
11:31:33 <faxathisia> right
11:31:39 <Big_Red> fax: but not if i try to use this check function
11:31:40 <faxathisia> Big_Red: I think the difficulty is the representation of the tree is the same as the board?
11:31:57 <faxathisia> Big_Red: Like you can't traverse the tree to apply win on each borad
11:32:01 <jaredj> you can :r !command from vim
11:32:14 <shachaf> shapr: You can say something like "cmd | emacs -..."?
11:32:18 <Big_Red> fax: the theory works... its just i can't seem to work out how to do it in a nice recursive manner..
11:32:55 <jaredj> oodilolly, you can cmd | vim -
11:33:06 <allbery_b> shachaf: no
11:33:11 <faxathisia> Big_Red: Yeah, I think I see why
11:33:25 <jaredj> unfortunately i 've never figured out a way to xargs vim properly
11:33:25 <faxathisia> Big_Red: If you have deeply nested lists.. you don't know where to map
11:33:27 <shachaf> jaredj: Wow, you can do that.
11:33:31 <shachaf> jaredj: Thanks! :-)
11:33:32 <shapr> shachaf: Not quite like that, but with eshell you can mix shell commands, shell pipes, inline elisp, and you can put buffers wherever you want in the pipeline.
11:33:32 <Big_Red> fax: they type would grow with each iteration...
11:33:43 <jaredj> np
11:33:47 <faxathisia> Big_Red: but if you have a tree structure it would be simple
11:33:57 <faxathisia> Big_Red: Or you could flatten it?
11:34:03 <Big_Red> fax: but no matter how i look at it, it should work...
11:34:19 <Big_Red> fax: as i said if i type it out it works
11:34:19 <jaredj> "for easier recycling, flatten your trees"
11:34:39 <Big_Red> fax: i do map (map (map (map win . permute). permute) . permute) (permute test) and it prints out a happy answer
11:37:02 <Big_Red> fax: soooo other than completely restructuring is there a way to get a function to represent this statement?
11:39:00 <BMeph> @seen an_honest_politician
11:39:00 <lambdabot> I haven't seen an_honest_politician.
11:39:14 * BMeph sadly aggrees
11:39:43 <byte-> @seen byte-
11:39:43 <lambdabot> You are in #haskell. I last heard you speak just now.
11:39:46 <byte-> hehe
11:39:51 <byte-> touche
11:40:22 <Big_Red> fax: nudge
11:43:21 <faxathisia> Big_Red: You could try to output a tree structure, like  Tree Board  where data Tree a = Leaf a | Branch (Tree a) (Tree a)
11:43:21 <Big_Red> sad :(
11:43:33 <Big_Red> mm
11:43:54 <Big_Red> so in this case i agree i'll probably just restructure
11:44:04 <Big_Red> but does anyone know why it wasn't actually working
11:44:17 <Big_Red> i thought polymorphism would stop it having infinite type...
11:46:08 <Baughn> The type isn't infinite, just recursive
11:47:10 <shapr> Hacking C# makes me appreciate Haskell even more.
11:47:11 <cjb> huh.  I shiwed up at work and no-one's here.  D'oh.
11:47:20 <shapr> cjb: It's president's day!
11:47:21 <cjb> s/shiwed/showed/
11:47:24 <cjb> well I know
11:47:27 <shapr> cjb: It's okay, you can come visit me at work.
11:47:31 * shapr grins
11:47:33 <ddarius> shapr: Start writing some Java and you'll appreciate C# even more.
11:47:34 <cjb> but I thought it was one of those half-assed holidays that no-one cares about
11:47:49 <shapr> ddarius: Yes, definitely.
11:47:53 <Big_Red> baughn: thats what i thought - but it still doesn't run :(
11:48:02 <shapr> cjb: I dunno, half my office is taking a holiday, but I had stuff I needed to do.
11:48:39 <Baughn> Big_Red: I didn't catch the original question, but if you just want to map over a nested structure, how about instancing Functor and using fmap?
11:48:55 <byorgey> cjb: no one cares about the holiday itself, but people care very much about getting a day off of work =)
11:49:02 * byorgey has work today though
11:49:06 <cjb> ah :)
11:49:20 <gwern> today's a holiday?
11:49:28 <cjb> in the US, yeah, federal holiday.
11:49:41 <gwern> oh. that explains some things
11:49:44 * ddarius isn't at work.
11:50:01 <byorgey> gwern: it's "President's Day", which celebrates... George Washington's birthday, maybe?  I actually have no idea.
11:50:05 <ddarius> Unfortunately, it also means I can't pick up a package from the post office until tomorrow.
11:50:06 <vincenz> gwern: ever got into contact with nmd?
11:50:08 <vincenz> ndm even
11:50:14 <gwern> actually, I did see one interesting thing on reddit - one person claimed to have a dynamically linked GHC on ubnutu
11:50:20 <shapr> I saw a commercial that referenced George Washington, so maybe?
11:50:21 <gwern> I thought GHC didn't do dynamic linking?
11:50:32 * Big_Red looks up fmap
11:50:33 <gwern> vincenz: over what?
11:50:34 <Baughn> gwern: It does, but iirc the interface is still in flux
11:50:58 <vincenz> gwern: your uploading packages to hackage
11:51:29 <gwern> vincenz: why would I have? Mitchell handles his tagsoup package himself just fine afaik
11:51:34 <ddarius> I think it has since combined several such birthdays
11:51:43 <gwern> and hoogle isn't a concern of mine just yet
11:51:49 <vincenz> gwern: alright
11:52:31 <Big_Red> baughn: i think the answer to that is cause i don't quite understand fmap yet...
11:52:47 <gwern> (hm. hoogle isn't on hackage yet? add that to the list)
11:52:49 <vincenz> gwern: I think he was concerned with you uploading so many packages
11:52:55 <Big_Red> hmm
11:52:55 <byte-> wow, fmap is one typo away from being rather...embarrassing
11:53:17 <gwern> 'fap'? short for function application of course...
11:53:37 <byte-> teehee
11:53:43 <Baughn> @hoogle fap
11:53:44 <lambdabot> No matches found
11:53:46 <Big_Red> i decided to fap throughout the entire program?
11:53:49 * Baughn shrugs
11:53:55 <gwern> Big_Red: pointlessly of course
11:54:23 <gwern> because not long afterwards you feel the same
11:54:41 <Big_Red> so in summation to solve my problem i should either fmap or tree or both but don't know exactly why its not working...
12:04:36 <MyCatVerbs> @pl \l -> lookup (map foo l)
12:04:36 <lambdabot> lookup . map foo
12:11:48 <LordMetroid> Have I missheard or do the Haskell developers introducing automatic parallelizing
12:11:59 <cjb> you misheard
12:12:10 <LordMetroid> I se...
12:12:22 <roconnor> possibly they misspoke
12:12:28 <cjb> automatic parallelization isn't what you want, because the cost of sparking a new thread is higher than the cost of many computations
12:12:37 <vininim> fvsq of automatic
12:12:43 <cjb> and we can't know ahead of time what the cost of the computation will be, without doing something like profiling a previous run.
12:12:47 <vininim> *fvsa
12:12:52 <cjb> fvsa?
12:13:49 <vininim> for very small quantities of automatic =P (fsvo overloaded)
12:14:02 <cjb> ah :)
12:15:42 <ddarius> It's trivially easy to automatically parallelize Haskell code, but it isn't that useful.
12:16:15 <Beelsebob> well, it is usefull... *if* you have as many CPUs as applications in your program's execution
12:16:31 <cjb> Beelsebob: not true.
12:16:50 <Beelsebob> well, certainly an upper bound
12:16:56 <cjb> sparking a thread onto a different CPU is *often* slower than performing the work on the main CPU without a thread.
12:17:05 <cjb> see dons' blog post on parallel fib.
12:17:24 <Beelsebob> okay, yes, sorry, *if* you have as many CPUs as applications, and a 0 cost of moving an application to another CPU
12:18:09 <ddarius> The name of the parallization game is granularity.
12:18:21 <shapr> Right, exactly.
12:18:24 <monochrom> My friend evaluated the naive "fork them all" method in his MSc thesis. He found that in practice there is too much data dependency, if you fork them all it is slower.
12:19:17 <shapr> dons had a post some months ago where he profiled to find the best granularity... was it a parallel sudoku solver?
12:19:18 <cjb> monochrom: dons did the same.  http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/29#smoking-4core
12:19:19 <esap> Just have a large-enough task per thread.
12:19:20 <lambdabot> Title: Haskell hacking
12:19:26 <cjb> shapr: it was fib
12:19:43 <esap> and watch for amount of communication between threads
12:19:47 <shapr> cjb: Ah, cool
12:19:48 <cjb> not sure he actually profiled, just picked a threshold for small fib(n) to avoid sparking on.
12:20:08 <shapr> Ah
12:20:21 <shapr> Profiling would be the nice solution though.
12:20:25 <cjb> yes
12:20:39 <cjb> there's a decent MSR paper on this
12:20:55 <cjb> they modified GHC to monitor how long-lived each thunk in a program is
12:21:03 * gwern goes to darcs.org. 'Best links: Free Anal' o.0
12:21:08 <shapr> Got a reference/title/author for that?
12:21:11 <gwern> darcs.org must not be the right link...
12:21:19 <cjb> "Feedback Directed Implicit Parallelism", IIRC
12:21:22 <cjb> from ICFP '07
12:21:26 <byorgey> gwern: darcs.net.  I've done that before too.
12:21:30 <cjb> they didn't publish their GHC modifications :(
12:21:46 <shapr> suck
12:21:49 <shapr> Why not?
12:22:01 <cjb> because they work for Microsoft, and are losers
12:22:05 <shapr> Heh
12:22:08 <Heffalump> email and ask for them..
12:22:11 <cjb> which is to say, I don't know why not :)
12:22:34 <cjb> yeah, I meant to do that.  I should e-mail before whining.
12:22:38 <shapr> Tim Harris was part of the STM for GHC effort, and Satnam Singh has done open source releases in the past, so I'm surprised they didn't release them.
12:23:07 <Heffalump> my guess would be that like with most research experiments, the modifications are ugly hacks that would be hard for anyone else to use without a lot of effort
12:23:31 <cjb> *nod*
12:23:55 <olsner> also, MS is evil and might not have let them... esp. not if it is patentable :P
12:24:21 <cjb> MSR isn't that evil.
12:24:34 <matthew-_> depends on your perspective
12:24:36 <Heffalump> I think getting patents is basically up to individuals.
12:24:37 <shapr> Yeah, MSR pays for GHC.
12:24:43 <shapr> I like that.
12:24:46 <Heffalump> They get extra brownie points for getting them, but they don't have to
12:25:00 <gwern> if only we could get MSR to also pay for JHC. that'd be nice
12:25:02 <cjb> where "brownie points" == $5000 or so.
12:25:04 <radix> hmm, nobody mentioned the DPH stuff?
12:25:29 <Heffalump> cjb: not just that, good for the career too
12:25:40 <shapr> radix: DPH already handles granularity on its own.
12:26:00 <shapr> dons post and the Harris/Singh paper talk about doing your own granularity.
12:26:14 <cjb> or even inferring the granularity for you.
12:26:18 <shapr> At least, that's why I didn't say anything about nested data parallelism.
12:26:37 <radix> sorry, I wasn't mentioning it specifically in response to dons' reference, but rather the general question about automatical parallelism
12:26:44 <radix> ("automatical"? whoah.)
12:27:23 <radix> by... LordMetroid.
12:27:23 <cjb> the big prize in terms of the MSR paper is being able to make code run faster on multi-core without programmers doing much.
12:27:27 <radix> maybe LordMetroid had heard about DPH.
12:27:35 <Heffalump> cjb: apart from a training run :-(
12:27:51 <cjb> yeah
12:28:02 <matthew-_> the main issue I have with MS funding academic stuff is their banning of the use of GPL and similarly viral "copyleft" licenses.
12:28:07 <cjb> has anyone considered a GHC runtime, if that even makes sense?
12:28:14 <shapr> cjb: But that's always the big prize, yeah? Multicore won't be worthwhile until C compilers take legacy code and run it on 64 cores with a worthwhile speedup.
12:28:22 <Heffalump> cjb: in what sense?
12:28:23 <cjb> I was thinking something that is able to look at the lifetime of thread sparks on the fly
12:28:27 <radix> matthew-_: well, hey, if that means they use MIT or BSD instead, I ain't complaining
12:28:45 <Heffalump> shapr: people might rework their code
12:28:48 <matthew-_> radix: BSD 3-clause is specifically held up as an acceptable license.
12:28:48 <Feuerbach> does lambdabot take @src from standard library? definitions of functions like map don't seem to be tail recursive
12:28:52 <Feuerbach> @src map
12:28:53 <lambdabot> map _ []     = []
12:28:53 <lambdabot> map f (x:xs) = f x : map f xs
12:28:58 <Heffalump> cjb: well, that's what their modifications did. They were just very slow at doing so.
12:29:08 <LordMetroid> radix: "by..."?
12:29:21 <radix> LordMetroid: It was a continuation of a previous statement.
12:29:23 <Heffalump> Feuerbach: tail recursion generally isn't what you want for things that produce data like that
12:29:29 <radix> LordMetroid: You may be interested in Data Parallel Haskell.
12:29:36 <Heffalump> but that's not the internal definition GHC uses
12:29:42 <cjb> Heffalump: right, but their modification relied on you later running the same binary with the same semantics for thunk creation
12:29:51 <Le-Chuck_ITA> what is the history behind the two haskell bindings of libfuse? And is one of them maintained and up-to-date?
12:30:00 <cjb> it would be nice if their inferences could be moved into runtime instead of previous-compile-time
12:30:05 <shapr> Feuerbach: I don't remember, grab the source and look?
12:30:07 <shapr> @version
12:30:08 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
12:30:08 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:30:24 <Heffalump> cjb: nice, but the impression I got was that it was unlikely given the cost
12:30:25 <shapr> radix: Hey, are you going to be at the dinner tomorrow evening?
12:30:26 <radix> LordMetroid: It's still pretty thoroughly in development, as far as I'm aware
12:30:28 <cjb> I'm not asserting this is possible, just wondering if people have tried this sort of JIT in Haskell before
12:30:35 <radix> shapr: I donno, where is it?
12:30:42 <shapr> radix: I donno, ask glyph?
12:30:53 <Heffalump> perhaps if you could do something like quickly deciding not to instrument most thunks, you might get somewhere
12:31:03 <bos> what's a reasonable word to describe the opposite of an applicative coding style?
12:31:12 <cjb> Haskell's such a great language for automatic parallelism, it'd be a huge shame not to manage to fulfil the promise of implicit parallelism if we think we can :)
12:31:18 <esap> bos: depends on your definition of opposite :-)
12:31:33 <byorgey> bos: coapplicative? inapplicative? =)
12:31:34 <radix> cjb: +1
12:31:44 <bos> esap: well, think of "do" notation as the opposite that i have in mind
12:32:05 <byorgey> bos: extractative?
12:32:18 <esap> bos: how about procedural?
12:32:26 <Heffalump> bos: pointwise?
12:32:30 <Saizan> imperative?
12:32:32 <radix> imperative? or procedural...
12:32:37 <bos> i think "procedural" captures it fairly well.
12:32:52 <Heffalump> cjb: yeah. Though I found the results of that paper rather dispiriting, really.
12:33:04 <cjb> Heffalump: yes, agreed.
12:33:47 <shapr> I haven't read that paper yet... Any encouraging papers in that space?
12:33:55 <cjb> when your theoretical "this is how fast we could possibly go" results aren't that promising, it doesn't make you hopeful about the practical ones.
12:34:11 <shapr> cjb: Still beats OCaml
12:34:37 <Heffalump> well, how fast you can go with their strategy
12:34:44 <cjb> right.
12:34:46 <Heffalump> hopefully there's a better one out there
12:35:19 <bos> nobody should be shocked that if you don't plan for parallel evaluation, you get crappy parallelism.
12:35:56 <bos> in this day and age, that's like being disappointed that apples fall from trees.
12:35:57 <Heffalump> I find it disappointing, given that by accepting purity you've already gone some way towards planning for it.
12:36:08 <esap> Hmm.. is it possible to write type-level queues with GADTs or some other extension?
12:36:12 <shapr> Anyone in Boston want to have geeky programming dinner tomorrow night with me and some other programmers?
12:36:21 <shapr> esap: oooh, that would be cute!
12:36:35 <esap> shapr: well I've been trying to think how, but haven't found any way...
12:36:44 <Heffalump> esap: what operations would you want?
12:37:12 <Heffalump> representing stuff at the type level isn't that hard, IME, it's writing programs that use them that's tricky
12:37:12 <fiilicdae> nats xs = map reverse (inits xs) >>= zip xs in nats [0..2]
12:37:14 <esap> Heffalump: well I know you can write queues using *two* stacks + a reverse operation on one of the stacks.
12:37:31 <esap> Heffalump: Well I can write stacks already.
12:37:34 <fiilicdae> hmm
12:37:34 <Heffalump> a stack is basically easy, reverse probably isn't :-)
12:37:41 <ddarius> Hey esap btw  Haven't seen you in a while.
12:37:41 <esap> But the reverse operation is hard
12:37:47 <fiilicdae> why does it give me: parse error on input `in' ?
12:37:52 <fiilicdae> anyone can help?
12:37:53 <fiilicdae> :)
12:38:01 <dons> dcoutts: around?
12:38:03 <esap> ddarius: I've been bound in RL :-(
12:38:08 <byorgey> fiilicdae: you need a 'let'.
12:38:33 <fiilicdae> byorgey:  before map?
12:38:35 <byorgey> fiilicdae: 'in' always has to be paired with a 'let'.  so you could say 'let nats xs = ... in nats [0..2]'.
12:38:42 <fiilicdae> oh no
12:38:42 <Heffalump> are you actually proposing to use type functions a la GHC 6.10?
12:38:46 <fiilicdae> it's in file
12:38:56 <ddarius> esap: That's a bit kinky and perhaps too much information, but a good excuse.
12:38:56 <fiilicdae> and Data.List is imported already
12:39:06 <Saizan> esap: oleg has written it iirc
12:39:13 <byorgey> fiilicdae: what are you trying to do?
12:39:31 <fiilicdae> byorgey: oh - always u said ^^"
12:39:42 <fiilicdae> byorgey: some sort of list ;)
12:40:35 <byorgey> fiilicdae: you probably want to separate it.
12:40:46 <byorgey> nats xs = map .... zip xs  -- defines a function 'nats'
12:40:59 <byorgey> myList = nats [0..2]  -- creates a particular list using the nats function
12:41:26 <fiilicdae> byorgey: my prof told me to declare such nats func ;)
12:42:05 <ddarius> :t zip ?xs
12:42:07 <lambdabot> forall a b. (?xs::[a]) => [b] -> [(a, b)]
12:42:21 <byorgey> fiilicdae: ok, then forget what I said about 'let'.  You just want to have the 'nats' definition by itself like a showed above, and use it somewhere separate.
12:42:34 <byorgey> ...like *I showed above...
12:42:43 <byorgey> does that help?
12:42:56 <fiilicdae> byorgey: not exactly...
12:43:03 <fiilicdae> byorgey: it's a difficult topic
12:43:11 <esap> Here's an implementation of a type-level Stack: http://www.kotiposti.net/epulkkin/PolyStack.txt
12:43:17 <fiilicdae> byorgey: he want's me to declare smth like nats but not exactly like it
12:43:45 <fiilicdae> byorgey: func needs to produce infinite list of pairs - reverse permutaion of them
12:43:53 <Heffalump> anyone know what happened to the i386-linux GHC 6.9 snapshots? The last one is nearly two months old.
12:44:34 <esap> But whatever I do, I can't seem to get reverse on the stack done.
12:44:42 <Heffalump> esap: can you explain the intuition behind the type PolyStack?
12:44:48 <byorgey> fiilicdae: can you paste what you have so far on hpaste.org?
12:45:32 <fiilicdae> byorgey: this code is all I got ^^" excluding import Data.List ;)
12:45:33 <esap> Heffalump: The idea is that I encode the types of the elements of the stack in the type 'f a', where 'f' represents the "current" element and 'a' represents the rest of the stack.
12:45:51 <Heffalump> why not just make a type level list?
12:46:24 <faxathisia> two lists back to back can't be used like a queue though
12:46:55 <Heffalump> faxathisia: they can if you have a reverse operation
12:47:06 <esap> Heffalump: Well you could do that, but I think my approach is simpler and more general
12:47:27 <Heffalump> it doesn't really seem simpler to me, though it may well be more general.
12:47:27 <esap> Heffalump: You can also do things like PolyStack (Either Int a)
12:47:31 <faxathisia> if you had reverse, I guess you'd just use a single list
12:47:45 <Heffalump> faxathisia: well, not if you want amortised constant time performance
12:48:04 <Heffalump> though whether anyone would care about performance in a type-level program, I don't know :-)
12:48:10 <esap> Heffalump: And this approach allows you to represent the empty queue with the simple  "PFrame id".
12:48:29 <faxathisia> ok I don't know how it would be done
12:48:30 <Heffalump> esap: oh, so they're cons lists?
12:48:42 <Heffalump> that makes more sense
12:48:47 <MyCatVerbs> @pl \m s -> lookup (map foo l) m
12:48:48 <lambdabot> const . lookup (map foo l)
12:48:55 <esap> Heffalump: I mean empty stack, of course.
12:49:08 <MyCatVerbs> @pl \m s -> lookup (map foo s) m
12:49:09 <lambdabot> flip (lookup . map foo)
12:51:06 <esap> Heffalump: Well basically yes, type level cons list, with possibility to use types other than the two usually used for cons lists
12:51:38 <esap> Heffalump: But I don't see any way of extending this to queues...
12:52:33 <esap> maybe I'
12:52:38 <esap> maybe I'm asking too much...
12:54:48 <esap> I've been thinking of using the Adjunction for the reverse, but couldn't find any way of making it work...
12:58:44 <cjb> something else interesting from that parallelism paper, by the way:  a side-effect of their method was to determine the hot sites for long-lived thunk allocation in the Haskell source
12:59:23 <cjb> so it should be possible to come up with a tool that tells you where you might benefit from adding `par`.
13:00:28 <sioraiocht> cjb: isn't that just liveness analysis?
13:00:46 <faxathisia> http://www.cs.ru.nl/barendregt60/essays/hartel_vree/src/pr1_naive_11.hs http://www.cs.ru.nl/barendregt60/essays/hartel_vree/src/pr1_15.plg
13:00:48 <lambdabot> http://tinyurl.com/24rbzt
13:00:54 <faxathisia> interesting comparison
13:01:41 <Daxter> hi there, does anyone know how i chat with the lambdabot i was given a command /query lambdabot but it doesn't respond
13:01:54 <cjb> sioraiocht: Good point.  I don't think it is.. there are functions that you spend a time in that do not benefit for parallelism.
13:02:31 <cjb> they're specifically finding sites that spawn multiple long-lived thunks with no data dependency, not just sites you spend a lot of CPU time in
13:02:33 <shapr> Daxter: Maybe you're not identified to Nickserv?
13:02:38 <cjb> (I think.)
13:02:52 <sioraiocht> cjb: interesting.  I'm still sceptical, though, heh
13:03:15 <ddarius> faxathisia: It's actually rather easy to write a library that would let you "translate" the Prolog directly.
13:03:38 <Daxter> ah thank you :)
13:16:45 * ddarius considers starting a programming project.
13:16:58 <matthew-_> ddarius: I suggest you reconsider
13:17:02 <cjb> whoa, are you sure?  that sounds kinda scary.
13:17:07 * stepcut considers finishing a programming project.
13:17:20 * gwern installs a programming project
13:17:28 * esap deploys the project.
13:17:36 * matthew-_ starts on a rewrite
13:17:49 * gwern posts a blog article criticizing said rewrite
13:17:57 * rey_ reports a bug
13:18:15 * cjb votes that said project moves from darcs to git immediately, and changes license to GPLv3.
13:18:22 * matthew-_ concurs
13:18:28 * cjb forks.
13:18:29 * olsner closes rey_'s bug WONTFIX and points to the manual that doesn't exist
13:18:40 <faxathisia> certainly started something..
13:18:55 * matthew-_ has loud flamefest with cjb over fork
13:19:05 * cjb takes his toys and goes home.
13:19:17 * matthew-_ throws his pram out of the window
13:19:17 * olsner suggests a rewrite in C++ and cc:s torvalds
13:19:19 * gwern sends patches adding -Wall cleanliness and cabal support, and removes the old makefile stuff
13:19:36 * oerjan points out that the fork license is incompatible with the old one
13:19:49 <cjb> oerjan: stop confusing us with facts
13:19:53 * vincenz invents a new license
13:19:55 * matthew-_ points out a number of features of haskell that -Wall makes plainly annoying
13:20:33 <ddarius> "RTFM" "There is no manual" "WTFM"
13:20:42 <cjb> ddarius: so anyway, what's this project?  :)
13:21:40 <matthew-_> and does it include real lambdas in the type system?
13:21:48 <ddarius> A remake of a project I did many years ago using C++.
13:22:32 <olsner> we seem to have decided on some of this project's future history, but it still lacks a version number scheme based on a mathematical constant
13:22:46 <matthew-_> or a name. We should argue for a long time about the name
13:22:49 <gwern> make it approach i
13:22:53 <oerjan> olsner: chaitin's omega!
13:23:04 <ddarius> I don't have a name for this project or it's earlier incarnation.
13:23:05 <gwern> that way, you fuck up each and every tool which parses versions
13:23:28 <matthew-_> ddarius: then it's doomed to failure ;)
13:23:40 <olsner> "computing the version number of this release is left as an exercise to the reader"
13:23:52 <gwern> matthew-_: not realy. chaitin's omega is partially computable, remember
13:24:00 <byorgey> ddarius: WTFM? Is that a monadic version of WTF?
13:24:33 <sieni> wolrld transformation format monad
13:24:37 <sieni> -l
13:24:38 <smtms> Write TFM
13:24:42 <gwern> mapM WTFM_ haskellcriticisms
13:24:50 <sioraiocht> lol
13:25:43 <oerjan> is Write TFM a reduced version of State TFM?
13:25:45 <Cin> anyone wrote some kind of stateful web page with a haskell cgi?
13:26:10 <matthew-_> Cin: yes
13:26:22 <gwern> ?faq
13:26:23 <lambdabot> The answer is: Yes! Haskell can do that.
13:27:17 <dons> Cin: sure. hpaste?
13:27:50 <gwern> @hoogle hSelect
13:27:51 <lambdabot> No matches found
13:27:51 <Cin> well, that's happs, isn't it. i meant just with the cgi
13:27:56 <gwern> @hoogle select
13:27:56 <lambdabot> No matches found
13:28:16 <Lemmih> Cin: Sure.
13:28:23 <gwern> @hoogle Select
13:28:24 <lambdabot> No matches found
13:29:10 * gwern ponders 'import Select (hSelect)'
13:29:27 <matthew-_> Cin: yep. Though by stateful, I take it you mean some sort of workflow / session state?
13:29:33 <ddarius> @hackage
13:29:33 <lambdabot> http://hackage.haskell.org
13:30:16 <gwern> (somewhere in posix, probably)
13:31:51 <olsner> ddarius: so, what is this old C++ project you're going to rewrite (in haskell?)?
13:33:34 <Cin> sorry, i just started a skype call
13:34:35 <Cin> matthew-_: indeed, i mean a session state
13:36:47 <ddarius> olsner: Turn waveform data into MIDI.  My first attempt was straight Fourier analysis.  Since then I considered wavelet analysis, but now I suspect Bayesian parameter estimation may be the way to go.
13:36:57 <Cin> matthew-_: have you done something like that before?
13:36:59 <olsner> ah, cool project
13:37:14 <wy> oerjan: T -> lambda, T -> A b, T -> B a, A -> T a | A T, B -> T b | B T
13:37:32 <Cin> matthew-_: i've managed to get haskell cgi with lighttpd+fastcgi working before quite easily
13:38:20 <Cin> matthew-_: i tried to get happs working recently but i couldn't even get the dependencies working, heh
13:38:31 <shapr> heh
13:40:23 * ddarius installs a Fortran compiler...
13:41:41 <oerjan> wy: not unambiguous
13:42:12 <oerjan> A -> A T -> T a T
13:42:41 <ehird`> type Foo = [Foo]
13:42:43 <wy> oerjan: uhh...
13:42:56 <matthew-_> Cin: sorry, was coding. Or at least thinking.
13:43:08 <oerjan> which means anything of form T a b a T is ambiguous
13:43:13 <Cin> matthew-_: hehe, coding is a large part of thinking :]]
13:43:20 <matthew-_> Cin: all of the stuff I've done is either stateless or the state is entirely managed by javascript
13:43:23 <Cin> matthew-_: er, i mean..
13:43:29 <Cin> matthew-_: ah, okay
13:43:38 <wy> oerjan: change A -> a T
13:43:41 <matthew-_> but as others have said, doing stuff with cookies isn't difficult
13:43:59 <matthew-_> probably your greatest pain will be the db layer
13:44:05 <Cin> yeah
13:44:13 <Cin> if there's an sqlite library i wouldn't mind that at all
13:44:15 * Cin checks
13:44:24 <ctkrohn> yeah there is a sqlite haskell library in hdbc I think
13:44:34 <wy> oerjan: A -> a T | A T
13:44:41 <Cin> several, it seems
13:44:44 <Cin> which is nice
13:44:49 <jeffz> Cin: this is what I had to do last time I tried HAppS http://jottit.com/39hm4/ - it's probably change since then though
13:44:50 <lambdabot> Title: Home
13:44:51 <ctkrohn> I remember playing with it a couple weeks ago, seemed straightforward enough...
13:45:51 <matthew-_> yeah, it depends what level you want to work on. I really like the haskelldb stuff, but it's not the most active stuff
13:46:04 <matthew-_> I just detest putting raw sql strings in all over the place
13:46:09 <ctkrohn> haskelldb is the one with the combinator library, right?
13:46:15 <matthew-_> yeah. it's lovely.
13:46:29 <matthew-_> though a little inflexible in places
13:46:43 <ctkrohn> agreed... would be nice to have a combinator library for queries, that also returned the appropriate record type for the table
13:46:54 <Cin> jeffz: well, i'll give a try again
13:46:54 <ctkrohn> could be an interesting project, actually...
13:47:13 <ehird`> ctkrohn: you mean like..
13:47:25 <Cin> jeffz: what do you think of happs?
13:47:27 <ehird`> (selectFrom table ...) -> MyRecordType?
13:47:35 <ehird`> uh, where table = Table MyRecordType
13:47:36 <ehird`> I guess
13:47:41 <ehird`> and some kind of conversion class
13:47:45 <ctkrohn> yeah essentially, although it would probably have to return Maybe MyRecordType
13:47:49 <matthew-_> ctkrohn: that's what haskelldb does
13:47:54 <jeffz> Cin: confusing, I don't know enough Haskell to use it, though I didn't make an attempt at understanding how, I've stuck with Network.CGI since
13:47:54 <matthew-_> iirc
13:48:05 <ctkrohn> oh, ok, nice... I haven't looked at haskelldb very closely to be honest
13:48:07 <jeffz> Cin: I might look at it again when they make a stable release.
13:48:22 <matthew-_> there's a preprocessor that builds loads of data types from inspecting your db
13:48:28 <ehird`> mathrick: lame
13:48:31 <matthew-_> I think they're all records
13:48:50 <matthew-_> well, yeah, it should be TH really I guess
13:49:02 <ehird`> class DBRecord a b where colsToRecord :: a -> b
13:49:06 <ehird`> i wish that could be made better...
13:49:07 <matthew-_> otoh, there's little point as you can always screw the db independantly
13:49:14 <ehird`> we want a fully polymorphic array for it, really
13:49:16 <dejones> is '...' part of Haskell's syntax?
13:49:18 <sioraiocht> what's that small one liner prime number sieve?
13:49:26 <cjb> dejones: ".." is
13:49:26 <sioraiocht> that everyone here seems to rattle off every now and then?
13:49:27 <ehird`> otherwise, you have to do crazy preprocessing
13:49:29 <ehird`> dejones: no.
13:49:30 <ctkrohn> matthew-_: interesting, I'll have to check it out
13:49:36 <dejones> cjb: what is '..' then?
13:49:37 <ehird`> it means 'fill me in', or in the case of the prelude, 'this is primitive'
13:49:42 <ehird`> dejones: [1..2]
13:49:44 <matthew-_> ehird`: oh well that's easy enough to do. Just nested tuples is what it boils down to
13:49:44 <ehird`> = [1,2]
13:49:46 <cjb> sorry
13:49:46 <faxathisia> > nubBy(((>1).).gcd)[2..]
13:49:50 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:49:51 <Cin> jeffz: indeed... i have some little web site idea i want to implement. i could cook it up in php really easily, i just hate coding in php. using haskell just like php or asp or whatever is attractive to me. just to whip up scripts, so to speak...
13:49:51 <sioraiocht> cheers
13:49:55 <cjb> > take 10 [1..]
13:49:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
13:49:56 <ehird`> matthew-_: true, but you get what i'm saying
13:50:06 <dejones> cjb, ehird`: thanks
13:50:14 <ehird`> q: can you make Net.CGI use fastcgi?
13:50:18 <matthew-_> ehird`: yeah - that Haskell's record system sucks?
13:50:31 <dejones> what is "(.)" in Haskell?  :)
13:50:34 <ctkrohn> Cin: interesting, I've been thinking about the same thing... I have to make a simple db-driven app for work, not sure whether I want to play with haskell and take a long time and have fun, or use python and get it done quick and not learn anything
13:50:35 <ehird`> matthew-_: Well, yes. :-) But also that a class like that would allow for preprocessor-less database typing stuff.
13:50:39 <ehird`> dejones: uh
13:50:46 <ehird`> can't you learn haskell someplace other than #haskell
13:50:47 <ddarius> @src (.)
13:50:47 <lambdabot> (.) f g x = f (g x)
13:50:56 <Cin> ctkrohn: i know exactly what you mean
13:50:59 <ehird`> f . g == \x -> f $ g x
13:51:01 <jeffz> Cin: I understand the temptation, I used php at my last job, though I don't want to use Haskell like php.
13:51:04 <oerjan> T -> A b, T -> B a, A -> a T | A t, B -> T b | B T
13:51:08 <oerjan> ?
13:51:15 <dejones> 'Of course filter composition, like (.) becomes one of the most frequently used combinators. there are more complex filters for traversal of a whole tree and selection or transformation of several nodes.'
13:51:21 <dejones> that is the context.
13:51:28 <oerjan> wy: T -> A b, T -> B a, A -> a T | A t, B -> T b | B T ?
13:51:38 <dejones> ehird`: I'm just confused by the description here.
13:51:44 <dejones> It is using syntax I don't understand.
13:51:51 <Lord_Illidan> Hi all
13:51:51 <dejones> I thought it would be simple...
13:51:53 <ehird`> dejones: (x) is the non-infix version of x
13:51:57 <ehird`> (+) a b == a + b
13:52:04 <ehird`> (.) a b == a . b
13:52:09 <ehird`> dejones: And where are you learning from?
13:52:09 <dejones> ehird`: thank you.  :)
13:52:12 <ehird`> Sounds like gentle introduction.
13:52:14 <wy> oerjan: T -> A b, T-> B a, T->lambda, A-> a T | A T, B -> b T | B T
13:52:18 <matthew-_> ehird`: oh sure, but in this case, the preprocessor isn't the wrong thing to do as unless you can prevent the user from messing with the db, no static guarantees you can make are actually worth anything
13:52:20 <Cin> ehird`: http://darcs.haskell.org/fastcgi/
13:52:21 <ehird`> If so, I don't think you should be reading it, considering the questions..
13:52:22 <lambdabot> Title: Index of /fastcgi
13:52:24 <hpaste>  Lord Illidan pasted "Circle Area" at http://hpaste.org/5737
13:52:24 <ehird`> Try YAHT.
13:52:25 <Cin> ehird`: hmm
13:52:34 <ehird`> Cin: is that an identical itnerface to network.cgi?
13:52:39 <ehird`> i guess not
13:52:39 <wy> oerjan: I just switched side of a,b and T in A-> , B->
13:52:44 <Cin> ehird`: i'm investigating
13:52:46 <ehird`> what I really want is a tower like this:
13:52:48 <Lord_Illidan> can somone take a look at this code : http://hpaste.org/5737 ?
13:52:58 <wy> oerjan: so the unbalanced part always at front
13:52:59 <dejones> ehird`: I'm reading "A gentle introduction to the Haskell XML Toolbox" at the moment.  But, I am reading Haskell School of Expression to learn Haskell.
13:53:06 <Cin> ehird`: This library lets you write FastCGI programs. This package reuses the cgi package API, making it very easy to port CGI programs to FastCGI.
13:53:10 <kmcallister> Lord_Illidan, what about it
13:53:13 <Cin> ehird`: sounds good..
13:53:13 <Lord_Illidan> I'm having problems with inputting a number and converting it into an int
13:53:19 <ehird`> Network.CGI/That fastcgi thing <== WebCore (pretends to be FastCGI, basically, but plugs into any of those) <== Webmonad (the big 'un)
13:53:29 <ehird`> WebCore would have a simple, usable interface, though
13:53:32 <mauke> Lord_Illidan: show (circleArea radius)
13:53:32 <ehird`> so 'core' isn't the right name
13:53:35 <dejones> ehird`: Haskell School of Expression seems to require me to do many examples to learn syntax though.  Maybe you can recommend a different book?
13:53:36 <kmcallister> getRadius should have type IO Int
13:53:41 <Lord_Illidan> Hugs gives me this error : ERROR "circleArea.hs":12 - Type error in explicitly typed binding
13:53:41 <ehird`> dejones: YAHT.
13:53:41 <Lord_Illidan> *** Term           : getRadius
13:53:41 <Lord_Illidan> *** Type           : IO Int
13:53:41 <Lord_Illidan> *** Does not match : Int
13:53:41 <kmcallister> since it's a do block that does IO
13:53:48 <ehird`> @yaht
13:53:48 <lambdabot> Maybe you meant: fact part yarr
13:53:49 <wy> oerjan: I hope there is a nice tool to verify this
13:53:49 <ehird`> @what yaht
13:53:50 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
13:53:54 <mauke> Lord_Illidan: circleArea :: Double -> Double
13:53:54 <kmcallister> also why are you returning getRadius?
13:53:59 <ehird`> e.g. you could use WebCore to write a simple script like you would do in PHP
13:54:01 <dejones> ehird`: thank you (again :)
13:54:01 <mauke> Lord_Illidan: getRadius :: IO Double
13:54:05 <ehird`> and WebMonad for big things, like a wiki app or something
13:54:10 <wy> oerjan: will parser generators do?
13:54:35 <kmcallister> i think you want to return number
13:55:15 <kmcallister> "show circleArea radius" is "(show circleArea) radius", you probably want "show (circleArea radius)" which can also be written "show $ circleArea radius"
13:55:39 <Lord_Illidan> whoa, whoa
13:56:18 <Lord_Illidan> regarding getRadius :: IO Double
13:56:18 <wy> oerjan: seems to still be ambiguous
13:56:21 <bos> i get the impression that newish programmers find `ap` tricky.  does this seem correct?
13:56:29 <ehird`> @src ap
13:56:30 <lambdabot> ap = liftM2 id
13:56:34 <ehird`> i can't even remembe rwhat ap does
13:56:35 <ehird`> :-|
13:56:45 <ddarius> It does what it says it does.
13:56:53 <ehird`> well, that's unhelpful
13:56:53 <ddarius> Also, ap = liftM2 ($) might be clearer.
13:56:58 <ehird`> @unpl liftM2 id
13:56:59 <Lord_Illidan> It still doesn't work for me
13:56:59 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:57:00 <ehird`> @unpl liftM2 ($)
13:57:00 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:57:01 <matthew-_> I think @pl means I don't bother remembering a lot of stuff
13:57:11 <kmcallister> Lord_Illidan, what error do you get now?
13:57:19 <matthew-_> I just write it long hand and feed it into @pl and then go "oh yeah, that makes sense"
13:57:22 <ehird`> @do (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:57:23 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a)) not available
13:57:25 <ehird`> matthew-_: ditto
13:57:28 <hpaste>  Lord Illidan annotated "Circle Area" with "Circle Area" at http://hpaste.org/5737#a1
13:57:28 <matthew-_> or not, in some cases
13:57:29 <ehird`> @do \ d e -> d >>= \ b -> e >>= \ a -> return (b a)
13:57:29 <lambdabot> \ d e -> d >>= \ b -> e >>= \ a -> return (b a) not available
13:57:33 <ehird`> @do d >>= \ b -> e >>= \ a -> return (b a)
13:57:34 <lambdabot> d >>= \ b -> e >>= \ a -> return (b a) not available
13:57:37 <ehird`> wtf
13:57:38 <ehird`> @help do
13:57:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:57:41 <ddarius> redo
13:57:41 <Lord_Illidan> i updated it
13:57:43 <ehird`> oh
13:57:44 <ehird`> @redo (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
13:57:45 <lambdabot> (\ d e -> do { b <- d; a <- e; return (b a)})
13:57:48 <mauke> Lord_Illidan: show (circleArea radius)
13:57:49 <kmcallister> Lord_Illidan, you "return getRadius" when i think you want "return number"
13:57:55 <kmcallister> and that
13:57:57 <ehird`> ap d e = do { b <- d; a <- e; return (b a) }
13:58:10 <ehird`> ap d e = do { a <- d; b <- e; return (a b) }
13:58:12 <Lord_Illidan> kmcallister, omg
13:58:22 <Lord_Illidan> kmcallister, Ok that was a bad mistake, thanks
13:58:26 <ehird`> ap a b = do { c <- a; d <- b; return (c d) }
13:58:29 <kmcallister> no prob
13:58:31 <Lord_Illidan> but what does show do? /me starts hitting the books
13:58:36 <kmcallister> :t show
13:58:37 <lambdabot> forall a. (Show a) => a -> String
13:58:38 <ehird`> @type ap
13:58:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:58:44 <ehird`> well, the type is inscrutable
13:58:45 <kmcallister> Lord_Illidan, it turns any "showable value" into a string
13:58:49 <ehird`> but here's my english language 'ap':
13:59:17 <ddarius> ehird`: Is the type of ($) inscrutable?
13:59:39 <ehird`> "Take a function (a -> b), wrapped inside an IO action, and perform that action to get the function. Then, take an IO-wrapped `a`, perform the action in it, and apply the function to the value."
13:59:43 <ehird`> badly worded
13:59:44 <ehird`> but hey
13:59:47 <ehird`> @type ($)
13:59:48 <lambdabot> forall a b. (a -> b) -> a -> b
13:59:50 <ehird`> ddarius: No.
14:00:01 <ehird`> Just the * -> * stuff :-P
14:00:03 <faxathisia> What is the meaning of inscrutable?
14:00:04 <kmcallister> :t fmap
14:00:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:00:10 <Lord_Illidan> ah thanks
14:00:10 <ddarius> ehird`: Ignore that.
14:00:18 <ddarius> ehird`: That's a GHC extension.
14:00:26 <Lord_Illidan> My bad..I'm terrible at doing debugging, thanks!
14:00:30 <ehird`> Yes. But I still don't understand it.
14:00:30 <ehird`> :-)
14:00:51 <ehird`> http://cryp.to/formdata/ <-- ? i've never heard of this
14:00:52 <lambdabot> Title: FormData: A Network.CGI replacement
14:00:57 <mauke> ehird`: it's just trying to be kind
14:01:20 <BMeph> I'd say "monad" instead of "IO," but that sounds reasonable.
14:01:22 <kmcallister> :t (>>= fmap)
14:01:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (f a -> a -> b) -> f a -> f b
14:01:41 <faxathisia> :t (fmap.fmap)
14:01:42 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:01:47 <oerjan> wy: i recall seeing some tool to check ambiguity linked from wikipedia
14:01:51 <ehird`> BMeph: Errr ups
14:01:52 <ehird`> Yeah.
14:02:14 <ddarius> ap takes a computation that returns a function and computation that returns a value, executes each, and returns the result.
14:02:16 <oerjan> wy: http://www.brics.dk/grammar/
14:02:18 <lambdabot> Title: dk.brics.grammar
14:02:21 <byorgey> faxathisia: 'inscrutable' means something like 'impossible to understand due to obfuscation'
14:02:23 <ehird`> "Take a function (a -> b) in the monad m, and extract its value. Then take a value of type 'a' in the monad m, extract its value, and apply the function to the value."
14:02:24 <kmcallister> :t \m x -> do { f <- m; fmap f x}
14:02:25 <lambdabot> forall (t :: * -> *) a t1. (Monad t, Functor t) => t (a -> t1) -> t a -> t t1
14:02:32 <BMeph> > ap [(*2),(+3),(2^)] [5,4,3]
14:02:33 <lambdabot>  [10,8,6,8,7,6,32,16,8]
14:02:52 <faxathisia> oh ok, thanks
14:02:52 <kmcallister> > let ap m x = do { f <- m; fmap f x} in ap [(*2),(+3),(2^)] [5,4,3]
14:02:53 <lambdabot>  [10,8,6,8,7,6,32,16,8]
14:03:10 <ehird`> question about Network.FastCGI --
14:03:14 <ehird`> does it take advantage of FastCGI's features?
14:03:26 <ehird`> or does it still 'pretend' to be in a cgi model (which really makes it just a backwards compatibility layer)
14:03:53 <ehird`> and, is there a module like Network.(Fast)CGI but that plugs into something 'arbitary'?
14:03:54 <BMeph> kmcallister: :)
14:04:24 <ehird`> > ap [(*2),(+3),(2^)] [5,4,3] :: Expr
14:04:25 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
14:04:29 <ehird`> > ap [(*2),(+3),(2^)] [5,4,3] :: [Expr]
14:04:30 <lambdabot>  [5 * 2,4 * 2,3 * 2,5 + 3,4 + 3,3 + 3,2 * 2 * (2 * 2) * 2,2 * 2 * (2 * 2),2 *...
14:04:42 <ehird`> > sum (ap [(*2),(+3),(2^)] [5,4,3]) :: Expr
14:04:44 <lambdabot>  0 + 5 * 2 + 4 * 2 + 3 * 2 + (5 + 3) + (4 + 3) + (3 + 3) + 2 * 2 * (2 * 2) * ...
14:04:48 <ehird`> > sum (ap [(*2),(+3),(2^)] [5,4,3])
14:04:49 <lambdabot>  101
14:05:00 <BMeph> ehird': "Then, after applying the function, put the result into the same type of monad that the function and value were."
14:05:07 <ehird`> BMeph: Oh, yes.
14:05:14 <hpaste>  Lord Illidan annotated "Circle Area" with "Circle Area" at http://hpaste.org/5737#a2
14:05:20 <BMeph> :)
14:05:24 <ehird`> > let one = 2 - one in one
14:05:26 <lambdabot>  Exception: <<loop>>
14:05:27 <ehird`> > let one = 2 - one in one :: Expr
14:05:29 <lambdabot>  2 - (2 - (2 - (2 - (2 - (2 - (2 - (2 - (2 - (2 - (2 - (2 - (2 - (2 - (2 - (2...
14:05:32 <Lord_Illidan> Ok, this is my new code..it works, any comments? http://hpaste.org/5737#a2
14:05:54 <Lord_Illidan> thanks all of you, btw...you're making my foray into Haskell that much more bearable!
14:06:28 <ricky_clarkson> Is there such thing as a topology of types?
14:06:35 <ehird`> > let zero = 0; one = 1; two = 2; three = 3; four = 4; (plus) = (+); (times) = (*); (minus) = (-) in one minus (two plus three)
14:06:36 <lambdabot>        add an instance declaration for (Num ((a1 -> a1 -> a1) -> t -> t1))
14:06:36 <lambdabot>   ...
14:06:40 <ehird`> awwwwwwwww.
14:06:47 <BMeph> Lord_Illidan: Oh, just you wait - in a couple of weeks we'll get you writing a Lua interpreter. ;)
14:06:51 <ehird`> anyway, is there such a Network.GenericCGI?
14:06:55 <bd_> ehird`: `minus` and `plus`
14:06:59 <ricky_clarkson> @src Maybe
14:07:00 <lambdabot> data Maybe a = Nothing | Just a
14:07:02 <ehird`> bd_: That doesn't rea
14:07:03 <Lord_Illidan> BMeph, heh!
14:07:05 <ehird`> d as well. :P
14:07:15 <ricky_clarkson> data Perhaps a = Naww | Yep a
14:07:16 <bd_> ehird`: if you want it to read well you'll need to use typeclass hackery :)
14:07:22 <ehird`> :-(
14:07:28 <bd_> ehird`: or swap one/minus and two/plus
14:07:31 <ddarius> BMeph: That would be a pretty simple and fun exercise.
14:07:34 <ricky_clarkson> Perhaps can be said to be equivalent to Maybe.. is there a technical way of deciding on that?
14:07:45 <ehird`> eh, asking again -- anyone heard of/used http://cryp.to/formdata/ ?
14:07:46 <lambdabot> Title: FormData: A Network.CGI replacement
14:07:48 <Lord_Illidan> What's maybe?
14:07:49 <ctkrohn> ehird`: I thought they were the same, except for fastcgi you call runFastCGI and for plain cgi you use runCGI?
14:07:56 <ehird`> ricky_clarkson: halting problem, i think.
14:08:01 <wy> oerjan: That's a good tool. Thanks!
14:08:03 <ehird`> ctkrohn: ?
14:08:08 <ehird`> i didn't mention FastCGI.
14:08:11 <ricky_clarkson> ehird`: I don't mean an automated way.
14:08:15 <ctkrohn> ehird`: nm then, when you said
14:08:18 <ctkrohn> er
14:08:30 <ctkrohn> when you said "generic cgi" I thought you want something to abstract over fastcgi and network.cgi
14:08:40 <BMeph> ddarius: It sounds almost as fun as the FALSE interpreter I keep threatening to write. ;)
14:08:50 <DRMacIver> Hm. Silly question: Any simple libraries I could include to get a fair list shuffling function? (I can just define a simple one, but it would be nice to get a good implementation if there's one available)
14:08:59 <ehird`> ctkrohn: no
14:09:12 <ehird`> ctkrohn: i mean something that has a class for 'servable' or something
14:09:23 <ehird`> and it's just like network.cgi, except it defers the real meaty actual-serving stuff to an instanc eof that
14:09:24 <kmcallister> Lord_Illidan, lambdabot will give you the type of maybe:
14:09:25 <kmcallister> :t maybe
14:09:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:09:34 <ehird`> like, one for MyHaskellWebserver, one for FastCGI, etc
14:09:38 <kmcallister> @src maybe
14:09:38 <lambdabot> maybe n _ Nothing  = n
14:09:38 <lambdabot> maybe _ f (Just x) = f x
14:09:48 <Lord_Illidan> kmcallister, that doesn't mean I understood it :S
14:09:51 <byorgey>  > let zero = 0; one = 1; two = 2; three = 3; four = 4; plus = (+); times = (*); minus = (-) in one `minus` (two `plus` three)  -- ehird`
14:10:05 <ehird`> byorgey: didn't you read? `minus` doesn't read as wlel. that's why. :P
14:10:10 <kmcallister> Lord_Illidan, think of the first argument as a default and the second argument as an accessor function
14:10:23 <kmcallister> if the third arg is Nothing, the default is returned
14:10:31 <kmcallister> if it's Just x, the accessor is applied to x and that's returned
14:10:33 <byorgey> ehird`: that's why what?
14:10:44 <DRMacIver> (Oh well, I'll just steal Oleg's :) )
14:10:44 <kmcallister> Lord_Illidan, out of curiosity, why did you write main using (>>) and (>>=) rather than the do notation?
14:10:46 <ehird`> byorgey: :P
14:11:04 <Lord_Illidan> kmcallister, because I am 1337 :D
14:11:13 <kmcallister> haha, fair enough
14:11:25 <byorgey> ehird`: oh, sorry.  I thought you meant "`minus` also doesn't read", i.e. "doesn't parse".
14:11:27 <Lord_Illidan> kmcallister, no real reason, just because I wanted to test how they work
14:11:27 <BMeph> DRMacIver: Yeah, I'd say so - although someone was mentioning an easier one yesterday.
14:11:35 <kmcallister> yeah, it's good to understand the translation
14:11:44 <Lord_Illidan> the do is just syntatic sugar anyway
14:11:58 <kmcallister> yeah
14:12:02 <byorgey> writing main using (>>) and (>>=) is an excellent idea.
14:12:14 <kmcallister> byorgey, for didactic purposes or in general?
14:12:20 <byorgey> IMO do notation should not be used until you can translate to >> and >>= instantly in your head.
14:12:24 <byorgey> for didactic purposes.
14:12:26 <Lord_Illidan> Also, I learned something out of it, that >>= returns the output of the previous function..
14:12:30 <DRMacIver> BMeph: I don't really need it to be simpler to be honest. I just plan to stick it into its own module and forget about the implementation. :)
14:12:36 <fnord`> is there a good way to walk nested lists? That is if I have lists acting as a a tree and I want to map over the leaves
14:12:43 <Lord_Illidan> >>= sry, uses the output of the previous function
14:12:48 <faxathisia> fnord`: No not really
14:12:56 <cjb> byorgey: alternatively, >>= shouldn't be used until you can translate to it *from* do notation :)
14:13:10 <BMeph> DRMacIver: Okay, but I just scanned hpaste - it was blargeyfarg. Check out http://hpaste.org/5725 if you're curious.
14:13:15 <bos> fnord`: you can't even really use lists as a tree.
14:13:17 <kmcallister> Lord_Illidan, technically the thing to the left of >>= isn't a function, it's a monadic action (which could of course be the result of applying a function)
14:13:27 <fnord`> cool, just thought I'd ask in case someone knew something I didn't :p
14:13:35 <byorgey> cjb: well, my experience was that I found do-notation terribly confusing, until I found out about >> and >>= and studied their types, and then it all made sense suddenly.
14:13:39 <ddarius> fnord`: If you use nested lists you could only have "trees" of a specific depth.
14:13:40 <Lord_Illidan> kmcallister, ah
14:13:48 <byorgey> but the initial frustration with do-notation was... well, frustrating. =)
14:13:59 <ehird`> question: why does the Text.XHtml generated output suck?
14:14:03 <ehird`> <h1\n     >
14:14:07 <ehird`> is just stupid html style
14:14:15 <Lord_Illidan> I recall reading a pdf by the developer of UT, regarding Haskell
14:14:19 <bd_> ehird`: because whitespace is meaningful in HTML
14:14:26 <ehird`> Lord_Illidan: yes
14:14:28 <fnord`> ddarius: that's what I've got, it's not really a tree as such, although in this case it's acting like one
14:14:29 <ehird`> bd_: yes.
14:14:29 <DRMacIver> BMeph: Thanks
14:14:34 <ehird`> so handle it sanely.
14:14:35 <bd_> ehird`: if it did <h1>\n(other stuff), that would insert a whitespace you didn't ask for
14:14:39 <ehird`> so... do:
14:14:39 <ddarius> :t map . map . map
14:14:40 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
14:14:41 <ehird`> <h1>(other stuff)
14:14:51 <Lord_Illidan> Basically, it's the best thing since sliced bread :D
14:14:52 <bd_> ehird`: that's complex and special-casey :)
14:14:52 <BMeph> DRMacIver: No problem. Nice blog post, BTW. :)
14:14:53 <vincenz> :t map map
14:14:53 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
14:15:02 <kmcallister> Lord_Illidan, sure is :)
14:15:02 <ehird`> bd_: and less hideously ugly
14:15:13 <vincenz> :t map map [map]
14:15:14 <lambdabot> forall a b. [[a -> b] -> [[a] -> [b]]]
14:15:16 <bd_> ehird`: and you expect to be editing automatically generated HTML often?
14:15:17 <Lord_Illidan> However, the syntax is scary, at least for a n00b like me
14:15:28 <ehird`> Lord_Illidan: the syntax is nice and clean.
14:15:29 <bd_> ehird`: anyway, it can't know when the whitespace matters, so you'd end up with everything all on one line otherwise
14:15:32 <vincenz> :t map map [map] [map map]
14:15:32 <DRMacIver> BMeph: Thanks. :) I'm pleasantly surprised at how much it hasn't turned into Haskell bashing.
14:15:32 <lambdabot>     Couldn't match expected type `[[a -> b] -> [[a] -> [b]]] -> t'
14:15:32 <lambdabot>            against inferred type `[[a1 -> b1] -> [[a1] -> [b1]]]'
14:15:33 <ehird`> bd_: No -- but looking at it, yes :P
14:15:36 <vincenz> :t map map [map] [map]
14:15:37 <kmcallister> Lord_Illidan, i'm not sure i'd agree, one of the first things that impressed me about haskell was its clean syntax
14:15:37 <lambdabot>     Couldn't match expected type `[(a -> b) -> [a] -> [b]] -> t'
14:15:37 <lambdabot>            against inferred type `[[a1 -> b1] -> [[a1] -> [b1]]]'
14:15:39 <ehird`> > map map
14:15:40 <lambdabot>  Add a type signature
14:15:40 <DRMacIver> People actually seem to be obeying the rules
14:15:45 <vincenz> :t map map [map] [[map map]]
14:15:46 <lambdabot>     Couldn't match expected type `[[[a -> b] -> [[a] -> [b]]]] -> t'
14:15:46 <lambdabot>            against inferred type `[[a1 -> b1] -> [[a1] -> [b1]]]'
14:15:50 <kmcallister> certainly it bucks convention in a number of ways, if you're coming from C-like languages
14:15:51 <ehird`> > map map [id] [map id]
14:15:52 <lambdabot>  Couldn't match expected type `[[a] -> [a]] -> t'
14:15:56 <ehird`> hm
14:16:03 <hpaste>  mmorrow annotated "simple example" with "beat everyone with harpy" at http://hpaste.org/5730#a5
14:16:03 <ehird`> :t map map
14:16:03 <Lord_Illidan> kmcallister, I am.. well, I'm used to Java
14:16:04 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
14:16:13 <ehird`> :t map id
14:16:14 <lambdabot> forall a. [a] -> [a]
14:16:16 <Lord_Illidan> I've done some C++, some c#, and pascal, and java
14:16:22 <ehird`> > map map [id] [map id]
14:16:23 <lambdabot>  Couldn't match expected type `[[a] -> [a]] -> t'
14:16:23 <faxathisia> :t map . map
14:16:23 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
14:16:26 <faxathisia> :t map . map . map
14:16:27 <Lord_Illidan> Also, scraped the floor with prolgo
14:16:27 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
14:16:29 <dolio> @arr
14:16:30 <ehird`> ok, why doesn't that map map example work
14:16:30 <lambdabot> Swab the deck!
14:16:35 <faxathisia> :t map . (map . map)
14:16:36 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
14:16:38 <BMeph> DRMacIver: Hm, I'll check out the comments, probably bring up stuff about Lua.
14:16:43 <faxathisia> :t (map . map) . map
14:16:44 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
14:16:45 <ehird`> > (map . map) reverse ["abc","def"]
14:16:46 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
14:16:48 <resiak> :t map (map map)
14:16:48 <lambdabot> forall a b. [[a -> b]] -> [[[a] -> [b]]]
14:16:52 <vincenz> faxathisia: . is associative
14:16:54 <ehird`> > (map . map) (map reverse) ["abc","def"]
14:16:55 <lambdabot>  Couldn't match expected type `[[a]]' against inferred type `Char'
14:16:55 <faxathisia> yes
14:17:12 <ehird`> question about ghc
14:17:21 <ehird`> why can't i compile a program using e.g. Network.CGI?
14:17:24 <ehird`> the linker craps out on their symbols
14:17:28 <DRMacIver> BMeph: Comments about Lua would definitely be appreciated. :)
14:17:33 <ehird`> ah
14:17:35 <ehird`> just need --make
14:17:40 <byorgey> > map map [id] $ [map id]
14:17:41 <lambdabot>  Couldn't match expected type `a -> b'
14:17:54 <BMeph> Hmm, a Harpy LLVM module...would be almost self-referential, wouldn't it? ;)
14:18:11 <ehird`> BMeph: We need a Haskell compiler that uses Harpy.
14:18:13 <ehird`> That would be awesome.
14:18:23 <ehird`> I assume everyone agrees.
14:18:41 <hpaste>  mmorrow annotated "simple example" with "small correction" at http://hpaste.org/5730#a6
14:18:59 <Lord_Illidan> @type read
14:18:59 <lambdabot> forall a. (Read a) => String -> a
14:19:13 <BMeph> Make one - call it EHCo ;)
14:20:16 <Lord_Illidan> Is there a way to type-cast in haskell as it is done in java?
14:20:25 <vincenz> Lord_Illidan: no
14:20:25 <ehird`> Lord_Illidan: No -- that is unsafe.
14:20:31 <kmcallister> :t cast
14:20:32 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
14:20:32 <ehird`> (nobody mention you-know-what-ending-with-a-#)
14:20:35 <vincenz> Lord_Illidan: since haskell does not generally have subtypign
14:20:41 <ehird`> kmcallister: You shouldn't have said that.
14:20:46 <kmcallister> ehird`, probably so :)
14:20:48 <mauke> ehird`: oh, there's unsafeCoerce without #
14:20:49 <Lord_Illidan> ic
14:20:51 <faxathisia> I don't think cast is anything like javas cast..
14:20:51 --- mode: ChanServ set +o vincenz
14:20:53 <kmcallister> Lord_Illidan, there are ways, but they're advanced
14:20:53 <ehird`> mauke: oh jeez..
14:20:53 * vincenz kicks kmcallister 
14:20:55 <Big_Red> hmm, my program keeps saying "Program error: pattern match failure: head []"
14:20:56 --- mode: vincenz set -o vincenz
14:20:56 <faxathisia> Is it?
14:20:57 <kmcallister> generally the Wrong Way to do anything simple
14:21:07 <Lord_Illidan> kmcallister, lol..ok
14:21:14 <ehird`> Oh, nobody show him the coerce definition using unsafePerformIO
14:21:15 <ehird`> Please.
14:21:18 <hpaste>  mmorrow annotated "simple example" with "better fix" at http://hpaste.org/5730#a7
14:21:28 <ehird`> Random note: I just realised that haskell should be REALLY nice to write 'quick scripts' oddly enough
14:21:31 <ehird`> even things like quick cgis
14:21:32 <Lord_Illidan> I'd just like to put the conversion from getLine to a double in the main
14:21:35 <cjb> Big_Red: head errors when run on an empty list
14:21:40 <vincenz> unsafeLaunchJava
14:21:40 <cjb> Big_Red: perhaps that's it?
14:21:44 <Cin> <_<
14:21:52 <kmcallister> Lord_Illidan, there are specific numeric conversions
14:21:54 <vincenz> ehird`: using unsafePerformIO?
14:21:54 <kmcallister> :t fromIntegral
14:21:55 <lambdabot> forall a b. (Num b, Integral a) => a -> b
14:21:56 <mauke> Lord_Illidan: you need Â«readÂ» for that
14:21:57 <faxathisia> ehird`: This coerce e = unsafePerformIO $ do writeIORef globalRef e ; readIORef globalRef -- or a diffurent one?
14:21:58 <kmcallister> :t fromFloating
14:21:59 <lambdabot> Not in scope: `fromFloating'
14:21:59 <Big_Red> cjb: thanks - i'll poke it with a pointy stick and see what it says
14:22:02 <vincenz> Lord_Illidan: use 'r'ead'
14:22:03 <kmcallister> err
14:22:04 <vincenz> Lord_Illidan: 'read''
14:22:09 <mauke> Lord_Illidan: oh, from Int to Double?
14:22:13 <vincenz> > read "1.0" :: Double
14:22:14 <mauke> fromIntegral, yes
14:22:17 <Lord_Illidan> Yes, I am using read
14:22:21 <hpaste>  (anonymous) annotated "simple example" with "(no title)" at http://hpaste.org/5730#a8
14:22:24 <lambdabot>  1.0
14:22:29 <kmcallister> > (fromIntegral (3 :: Int)) :: Double
14:22:30 <lambdabot>  3.0
14:22:32 <ehird`> faxathisia: Aieeeeeeeeee.
14:22:34 <vincenz> Lord_Illidan: do you have an example piece of code?
14:22:38 <ehird`> And actually this is the one I use:
14:22:44 <Lord_Illidan> this is a different context, though
14:22:44 <Lord_Illidan> main = 	putStrLn "Enter an Integer : " >> hFlush stdout >> read getLine >>= (\number -> putStrLn $ "Double = " ++show (dbl number)++ " Quad = " ++show(quad number))
14:22:53 <faxathisia> you -use-..?
14:23:03 <ehird`> coerce x = let ref = unsafePerformIO (newIORef undefined) in unsafePerformIO (writeIORef ref x; readIORef ref)
14:23:06 <ehird`> faxathisia: Well, not usel
14:23:10 <ehird`> But the definition I have, in Evil.hs
14:23:20 <vincenz> ehird .. evil ... so close
14:23:34 <ehird`> vincenz: You can't implement eval with it.
14:23:36 <ehird`> I don't think.
14:23:51 * roconnor ponders making monad classes for various asspects of IO.
14:23:51 <vincenz> who ws talking about eval?
14:24:01 <kmcallister> roconnor, that's a good idea
14:24:12 <xpika> hi haskellers.
14:24:18 <roconnor> kmcallister: it's such a good idea, I fear others are working on it. :)
14:24:25 <kmcallister> putStrLn :: (MonadIO m) => String -> m ()
14:24:34 <kmcallister> this would make working with monad transformers much nicer, among other benefits
14:24:44 <roconnor> kmcallister: right, execpet that would be MonadStdIO
14:24:46 <kmcallister> i don't know exactly how fine-grained to make it
14:24:55 <kmcallister> :t forkIO
14:24:56 <lambdabot> Not in scope: `forkIO'
14:25:04 <roconnor> kmcallister: network, stdIO, ...
14:25:07 <hpaste>  (anonymous) annotated "simple example" with "(no title)" at http://hpaste.org/5730#a9
14:25:09 <roconnor> kmcallister: maybe we should make a list
14:25:17 <resiak> i swear unsafeCoerce# is defined somewhere
14:25:20 <ehird`> "runhaskell: PATH: getEnv: does not exist (no environment variable)"
14:25:23 <kmcallister> roconnor, is this idea already on the haskell' trac?
14:25:27 <ehird`> what do i need to do to runhaskell cgi programs?
14:25:35 <roconnor> kmcallister: dividing along standard security barriers seems like a good start
14:25:37 <vincenz> what's the status of haskell'
14:25:42 <xpika> check out my haskell implemenatation of the integer square root on the codecodex wiki
14:25:44 <xpika> http://www.codecodex.com/wiki/index.php?title=Calculate_an_integer_square_root#Haskell
14:25:45 <lambdabot> Title: Calculate an integer square root - Find and Write Source Code at CodeCodex, http://tinyurl.com/y9zk4g
14:25:46 <roconnor> kmcallister: I have no idea.
14:26:24 <ehird`> Regarding IO, I still want IOT. :-D
14:26:29 <ehird`> TwoDucks implementation, here I come!
14:26:37 <kmcallister> TwoDucks?
14:26:56 <ehird`> kmcallister: esolangs.org/wiki/TwoDucks
14:27:07 <vincenz> ehird`: quack
14:27:20 <ehird`> the most amazing time-travelling language ever
14:27:25 <gwern> you have two ducks. You realize you don't like ducks, sell them to a collector, and go buy two cows
14:27:27 <mauke> is that related to "pair o' ducks"?
14:27:35 <monochrom> hahaha
14:27:42 <roconnor> xpika: that doesn't look very good to me.
14:28:33 * gwern doesn't understand why gravity is incomputable instead of intractable: http://esolangs.org/wiki/Gravity
14:28:34 <lambdabot> Title: Gravity - Esolang
14:28:37 <roconnor> ehird`: StateMonadT RealWorld
14:29:09 <ehird`> roconnor: That's too internal. We need abstractions! ;)
14:29:29 <ehird`> type TwoDucks = IOT Cont     -- obviously
14:29:35 <xpika> roconnor: what's wrong?
14:29:36 <roconnor> ehird`: newtype IOT = StateMonadT RealWorld
14:30:02 <ehird`> Bah.
14:30:04 <roconnor> xpika: the recursive call is only 1 less than the input number.
14:30:42 <gwern> @hoogle sleep
14:30:54 <lambdabot> No matches found
14:31:07 <mauke> @hoogle delay
14:31:08 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
14:31:08 <lambdabot> GHC.Conc.registerDelay :: Int -> IO (TVar Bool)
14:31:08 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
14:31:10 <ehird`> roconnor: don't you mean "type"?
14:31:27 <roconnor> ehird`: er no, but I forget the constructor name
14:31:33 <roconnor> ehird`: and paramters
14:31:59 <roconnor> ehird`: newtype IOT a = unsafeRunIO (StateMonadT RealWorld a)
14:32:11 <roconnor> @src IO
14:32:12 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
14:32:26 <ehird`> unsafeRunIO ain't a valid constructor name
14:32:27 <roconnor> ehird`: newtype IOT a = IOT (StateMonadT RealWorld a)
14:32:36 <dejones> @src even
14:32:37 <lambdabot> even n = n `rem` 2 == 0
14:32:48 <ehird`> No such thing as StateMonadT, roconnor. :)
14:33:03 <amb_> hi
14:33:17 <Lord_Illidan> and, another stupid question. What's the difference between = and <-?
14:33:35 <ehird`> anyone know re: runhaskell?
14:33:37 <roconnor> ehird`: newtype IOT a = IOT (StateT RealWorld IO a)
14:33:43 <roconnor> ehird`: I'm getting closer
14:33:44 <ehird`> Lord_Illidan: this:
14:33:48 <ehird`> do a <- b; c
14:33:50 <ehird`> ======>
14:33:54 <mauke> <- has the "type" (Monad m) => m a -> a
14:33:55 <ehird`> b >>= (\a -> c)
14:33:55 <mauke> i.e. it lets you extract values from monadic actions
14:34:04 <ehird`> but = is just a toplevel definition
14:34:16 * ehird` fears that Lord_Illidan will misunderstand monads for time to come...
14:34:21 <ehird`> those 3 seconds after they ask about something are vital
14:34:22 <jeffz> Cin: mind if I pm you?
14:34:26 <ehird`> I think i messed 'em up.
14:34:34 * Lord_Illidan believes that ehird's fears are entirely justified
14:34:46 <meren> :)
14:34:51 <ehird`> oh dear :)
14:34:54 <ehird`> Lord_Illidan: Ignore what I said, then
14:35:02 <mauke> eh, it's simple once you learn about >>= and forget do notation
14:35:10 <Lord_Illidan> damn my incompetent book
14:35:19 <dejones> lol
14:35:19 <hpaste>  mmorrow annotated "simple example" with "fixed" at http://hpaste.org/5730#a10
14:35:25 <roconnor> mauke: you write strange code :)
14:35:38 <Lord_Illidan> The Craft of Functional Programming...totally ignores I/O until the 12th or so chapter
14:35:43 * dejones damns his incompetent self  ;)
14:35:46 <dejones> hehe
14:35:58 <Saizan> Lord_Illidan: you don't need IO!
14:35:59 <psykon> Lord_Illidan: I/O isn't functional :)
14:36:01 <mauke> oh, I use do notation but I view it as a very thin layer over >>=
14:36:10 <Lord_Illidan> Saizan, what??
14:36:11 <ehird`> hmmm
14:36:13 <ehird`> what is Network.NewCGI?
14:36:13 <dejones> Lord_Illidan: YAHT seems to remedy that issue.
14:36:22 <ehird`> Lord_Illidan: Here's how to do IO to start with:
14:36:25 <ehird`> main = interact func
14:36:26 <Lord_Illidan> Sure, if I use Hugs, I don't need to fuss about IO so much
14:36:27 <psykon> Gentle Introduction is nice
14:36:28 <ehird`> where func :: String -> String
14:36:35 <Lord_Illidan> But I like using ghc
14:36:37 <Saizan> Lord_Illidan: i mean, you can explore and learn about haskell without needing IO
14:36:44 <ehird`> You get the whole input as a string and give it the output.
14:36:46 <ehird`> But it's lazy
14:36:48 <ehird`> So it works nicely.
14:36:51 <ehird`> Lord_Illidan: ghci
14:36:53 <ehird`> it's like hugs, but uses ghc.
14:37:03 <ehird`> anyway -- anyone know what Network.NewCGI is?
14:37:11 <mauke> Lord_Illidan: if you understand data structures, you can understand IO :-)
14:37:17 <Lord_Illidan> Unfortunately, our lecturer believes we can learn all about haskell in a week :(
14:37:30 <ehird`> Lord_Illidan: your lecturer does not know haskell
14:37:31 <ehird`> :)
14:37:48 <faxathisia> Lord_Illidan: Yes you can
14:37:51 <dmwit> Lord_Illidan: Eh, give it a week.  Maybe you'll agree... heh
14:38:09 <roconnor> gwern: I question whether gravity is uncomputable.
14:38:24 <meren> learning haskell theoretically is not a big deal. it becomes a big deal when you start practicing.
14:38:38 <dmwit> roconnor: It doesn't have a closed-form solution for more than three bodies.
14:38:48 <dmwit> roconnor: I don't think that means "uncomputable" at all.
14:38:55 <roconnor> dmwit: who cares about closed form solutions.
14:39:06 <dmwit> roconnor: ...people who like fast calculations?
14:39:07 <psykon> meren: the main problem with learning haskell is side-effects
14:39:10 <gwern> roconnor: I think gravity might require real computations
14:39:23 <psykon> or I/O, whatever you want to call it
14:39:25 <roconnor> gwern: they start with points on an interger lattice
14:39:27 <kmcallister> Lord_Illidan, personally i recommend learning "pure" haskell, then monads in general (using a nice monad like Maybe), and only then IO
14:39:33 <roconnor> gwern: and I assume the masses are rational
14:39:35 <gwern> not discrete; which I guess would put it into the uncomputable?
14:39:57 <roconnor> gwern: that is a pretty nice initial condition.
14:40:05 <kmcallister> at Caltech the haskell course doesn't touch IO until the 4th of 5 labs
14:40:09 <dejones> ehird`: thank you for the link to YAHT.  Very helpful.  :)
14:40:17 <gwern> or maybe it's the 'countably infinite' part that does it
14:40:19 <roconnor> gwern: but I suppose checking for a collision may be undecidable.
14:40:24 <dejones> kmcallister: what do they cover before then...?
14:40:28 <ehird`> dejones: np :)
14:40:28 <Lord_Illidan> For instance..what about this:
14:40:38 <Lord_Illidan> getInt :: IO Integer
14:40:47 <Lord_Illidan> getInt = read getLine
14:40:54 <Lord_Illidan> why shouldn't that code work?
14:41:05 <smtms> cd
14:41:06 <mauke> Lord_Illidan: the types don't fit
14:41:11 <roconnor> gwern: but it isn't obviously undecidable.
14:41:15 <kmcallister> dejones, the labs list "datatypes, functions, pattern-matching, lists, recursion, higher-order functions, algebraic data types, type classes"
14:41:15 <gwern> 'Particles should be visualised as occupying a plane in three-dimensional space, as gravity follows an inverse-square law. ' <-- plane, not grid. so maybe the points' positions can be reals?
14:41:15 <esap> Uuh, I wrote a type-level queue, and GHC can *infer* type for it, but cannot *typecheck* the code...
14:41:16 <ehird`> anyway -- anyone know about Network.newCGI?
14:41:19 <mauke> Lord_Illidan: getLine :: IO String, but read :: String -> whatever
14:41:20 <hpaste>  mmorrow annotated "simple example" with "without comments" at http://hpaste.org/5730#a11
14:41:22 <ehird`> Lord_Illidan: Because:
14:41:25 <mauke> IO String /= String
14:41:25 <ehird`> getLine returns (IO String)
14:41:28 <ehird`> read takes a String
14:41:30 <kmcallister> (it's a 3 unit course where a normal course is 9, and a term is only 10 weeks)
14:41:30 <ehird`> You need to do this:
14:41:32 <Lord_Illidan> ah..
14:41:34 <ehird`> getInt = getLine >>= read
14:41:38 <ehird`> well, no
14:41:43 <ehird`> getInt = getLine >>= (\x -> return (read x))
14:41:45 <kmcallister> (so it's a pretty reasonable pace imho)
14:41:49 <Lord_Illidan> so that' s why we were using monads, then
14:41:50 <ehird`> >>= takes an IO thing on its left
14:41:50 <mauke> Lord_Illidan: could you read http://mauke.ath.cx/stuff/haskell/how-to-io.html and tell me what you think about it?
14:41:51 <gwern> ' This equation is ill-defined if two particles occupy the same location, so the collision rules define what happens at that time. Note that the general question of whether there is ever a collision is non-computable, leading to the power of the Gravity language. '
14:41:53 <dejones> kmcallister: Ahh, I see.  Interesting overall.
14:41:54 <lambdabot> Title: Haskell: How To IO
14:41:54 <ehird`> and a function on its right
14:42:01 <ehird`> and it gets the non-IO value
14:42:04 <ehird`> but must return an IO value
14:42:09 <ehird`> 'return' takes a value and makes it an IO value
14:42:15 <Lord_Illidan> mauke, sure
14:42:23 <ehird`> Lord_Illidan: with me?
14:42:33 <roconnor> gwern: ``Note that the general question of whether there is ever a collision is non-computable
14:42:40 <Lord_Illidan> ehird`, yes, thanks
14:42:49 <roconnor> gwern: that is true; however the particals are not in general position.
14:42:50 <dejones> Lord_Illidan: http://haskell.org/haskellwiki/Introduction_to_IO by Cale.  I thought it was helpful.
14:43:08 <dejones> But, may not be specific enough for you.
14:43:28 <meren> mauke: first impression: the mouse-over code show/hide thing is really smart and helpful..
14:43:52 <Lord_Illidan> I'm reading them, many thanks for the links
14:43:54 <dmwit> There's also http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html and http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html which are two nicely complementary approaches to explaining monads.
14:43:55 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
14:44:12 <gwern> is there anything obviously wrong with 'foreign import unsafe tzset âˆ· IO ()'?
14:44:14 <lament> You could have inverted monads
14:44:28 <ehird`> what was that one
14:44:31 <ehird`> that constructs monads
14:44:35 <ehird`> using dependencies on vvalues
14:44:38 <ehird`> explicitly?
14:44:41 <ehird`> that one helped me
14:44:42 <ehird`> it was on the wiki
14:44:56 <Lord_Illidan> I dunno why but I've taken to Haskell in a way I never took to Prolog
14:45:11 <ehird`> Prolog isn't nearly as fun or useful for practical things
14:45:13 <ehird`> :P
14:45:23 <ehird`> guess ishould ask the q again:
14:45:26 <ehird`> does anyone know what network.newcgi is?
14:45:49 <dejones> ehird`: no clue about newcgi, sorry
14:45:57 <dejones> at least you got a response now.  :)
14:46:52 <Saizan> ehird`: you might have more luck on -cafe
14:46:57 <Lord_Illidan> mauke, puts [c]      = putChar c puts (c : cs) = putChar c >> puts cs
14:47:10 <Lord_Illidan> does that go into array notation in Haskell?
14:47:22 <kmcallister> Lord_Illidan, those are lists
14:47:24 <mauke> there is no array notation
14:47:24 <kmcallister> not arrays
14:47:30 <Lord_Illidan> sry, my bad
14:47:43 <kmcallister> mauke, there are array operators though, (!) and (//)
14:47:55 <dmwit> Also, it dies on (puts "")... you have a bad implementation. =P
14:48:03 <Lord_Illidan> so what does puts(c:cs) do?
14:48:05 <mauke> dmwit: sorry, we haven't learned about return yet :-)
14:48:05 <Lemmih> ehird`: Network.NewCGI is Network.CGI is newer versions of GHC.
14:48:15 <Lord_Illidan> my guess it is iterating over the list, or recursing over it
14:48:18 <dmwit> mauke: oh, heh
14:48:18 <Lemmih> *in newer ...
14:48:26 <mauke> Lord_Illidan: this tutorial assumes you already know about data structures, lists, etc
14:48:28 <kmcallister> Lord_Illidan, (c:cs) there is a pattern, which matches any list of at least 1 element
14:48:34 <kmcallister> binding the name c to the first element, and cs to the rest of the list
14:48:36 <Lord_Illidan> mauke, Bad assumption :S
14:48:48 <kmcallister> so yes, it's recursing over the list
14:48:56 <mauke> yeah, you're supposed to play with them before trying IO
14:49:04 <kmcallister> and yeah, a better base case would be puts [] = return ()
14:49:13 <mauke> basically, data List a = Nil | Cons a (List a)
14:49:33 <mauke> except it's data [] a = [] | (:) a ([] a)
14:49:39 <gwern> @hoogle tzset
14:49:39 <lambdabot> No matches found
14:49:43 <gwern> @hoogle tz
14:49:43 <lambdabot> System.Time.ctTZ :: CalendarTime -> Int
14:49:43 <lambdabot> Control.Applicative.getZipList :: ZipList a -> [a]
14:49:43 <lambdabot> System.Time.ctTZName :: CalendarTime -> String
14:49:43 <Lord_Illidan> mauke, sure, I'm going to go into them now
14:49:48 <mauke> which is invalid syntax because it's hardwired into the language
14:50:14 <kmcallister> :t (:)
14:50:29 <lambdabot> thread killed
14:50:31 <kmcallister> uh
14:50:35 <dmwit> :t (:)
14:50:36 <lambdabot> forall a. a -> [a] -> [a]
14:50:40 <ehird`> mauke: it's data [a] actually
14:50:45 <dmwit> It needed a practice run. =)
14:50:46 <DRMacIver> Hm. Does transpose work correctly on infinite lists?
14:50:47 <mauke> if you look at the type of (:), you see that it takes an element and a list, and returns another list
14:50:49 <mauke> ehird`: same thing
14:50:49 <mrd> that thread spun off the reel entirely
14:50:52 <dmwit> ehird`: [] a is also correct.
14:50:59 <dmwit> :k []
14:51:00 <lambdabot> * -> *
14:51:05 <dmwit> :k [] a
14:51:06 <lambdabot> Not in scope: type variable `a'
14:51:09 <dmwit> ah well
14:51:14 <kmcallister> :k forall a. [] a
14:51:15 <lambdabot> *
14:51:16 <dmwit> > "hi" :: [] Char
14:51:17 <ehird`> well
14:51:17 <lambdabot>  "hi"
14:51:19 <ehird`> the prelude definition
14:51:20 <ehird`> is [a]
14:51:25 <dons> > take 10 (transpose [1..])
14:51:25 <lambdabot>   add an instance declaration for (Num [a])
14:51:25 <lambdabot>     In the expression: 1
14:51:31 <dons> :t transpose
14:51:32 <lambdabot> forall a. [[a]] -> [[a]]
14:51:42 <DRMacIver> Apparently so. Yay.
14:51:42 <dons> > take 10 (transpose [[1..],[1..]])
14:51:44 <lambdabot>  [[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10]]
14:51:47 <dons> huh
14:51:49 <ehird`> (it's like theologicians debating: first one to back evidence up with prelude quote wins)
14:52:01 <DRMacIver> dons: Is that surprising?
14:52:09 <Lord_Illidan> Thanks guys, I'm turning in for tonight!
14:52:20 <dons> DRMacIver: not really I suppose :)
14:52:22 <lament> ehird`: :D
14:52:29 <Lord_Illidan> You've been a great help these past few days..
14:52:37 <mauke> ehird`: that's like arguing over whether (!!) is defined using prefix or infix notation
14:52:37 <mrd> @src tranpose
14:52:38 <lambdabot> Source not found. Wrong!  You cheating scum!
14:52:39 <mrd> @src transpose
14:52:40 <lambdabot> transpose []             = []
14:52:40 <lambdabot> transpose ([]   : xss)   = transpose xss
14:52:40 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
14:52:49 <mrd> gaah, i wrote that function a few times.
14:52:58 <cjb> hm, transpose is what I thought zip was.
14:53:00 <mauke> Â«xs !! n = ...Â» vs Â«(!!) xs n = ...Â»
14:53:06 <ehird`> mauke: do not question to Prelude, for it was written by Them, and They are not to be Questioned.
14:53:06 <mrd> for matrix-multiply =)
14:53:15 <ehird`> *the
14:53:34 <mrd> calling it a "Prelude" makes me think of music
14:53:52 <ddarius> > zip xs ys = map (
14:53:52 <lambdabot> Unbalanced parentheses
14:53:56 <dmwit> ehird`: Nonsense.  Even They admit to a few mistakes, and are planning a Haskell' as payment.
14:54:19 <dolio> Yeah, there are widely acknowledged problems with the prelude.
14:54:24 <gwern> haskell' seems to have a reputation as being bogged down
14:54:29 <ddarius> > let zip xs ys = map (\[x,y] -> (x,y)) $ transpose [xs,ys] in zip [1..] [1..10]
14:54:30 <lambdabot>   Non-exhaustive patterns in lambda
14:54:37 <ehird`> dmwit: No; these are not Mistakes, They foresaw the future, and decided that we cannot understand the True Nature yet, so They wisely withheld it from us, until the Second Coming.
14:54:48 <dmwit> Haskell' has a reputation of taking a long time to appear. =P
14:54:51 <ehird`> dolio: HERETIC! You shall be burned at the stake, tomorrow.
14:55:02 <dmwit> Luckily, we have -fglasgow-exts to tide us over until it does. =P
14:55:04 <olsner> mrd: it's the little piece of music ghc plays to itself before taking in the full beauty of the provided source code ;-)
14:55:14 <ehird`> -FGLASGOW-EXTS IS AN AFFRONT AGAINST THEM!!!!
14:55:17 <ehird`> REPENT!
14:55:35 <gwern> @hoogle toCalendarTime
14:55:35 <lambdabot> System.Time.toCalendarTime :: ClockTime -> IO CalendarTime
14:55:45 <roconnor> anyone have an example of using HTTP post?
14:55:59 <ehird`> is there an IOHCC?
14:56:13 <mauke> @go iohcc
14:56:14 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation/IOHCC_2004
14:56:14 <lambdabot> Title: Obfuscation/IOHCC 2004 - HaskellWiki
14:56:15 <lament> ehird`: have a look at any haskell source code.
14:56:23 * monochrom <3 dolio. Please don't burn him!
14:56:33 <gwern> @hoogle Posix
14:56:33 <lambdabot> System.FilePath.Posix :: module
14:56:33 <lambdabot> Data.Time.Clock.POSIX :: module
14:56:33 <lambdabot> Data.Time.Clock.POSIX.posixDayLength :: NominalDiffTime
14:56:53 <olsner> I guess someone built @pl some time after 2004, thus deprecating iohcc :P
14:56:58 <ehird`> lament: Pretty code; your point?
14:57:11 <ehird`> @src flipM_
14:57:12 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:57:13 <ehird`> @src flipM
14:57:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:57:16 <ehird`> aeurgh
14:57:18 <ehird`> what was it called again
14:57:24 <ehird`> @src mapM
14:57:25 <lambdabot> mapM f as = sequence (map f as)
14:57:25 <ehird`> @src mapM_
14:57:26 <lambdabot> mapM_ f as = sequence_ (map f as)
14:57:31 <ehird`> hmm
14:57:33 <ehird`> @src foldM
14:57:33 <dmwit> ?src forM
14:57:33 <lambdabot> forM = flip mapM
14:57:33 <lambdabot> foldM _ a []     = return a
14:57:33 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:57:39 <ehird`> @src fol
14:57:40 <lambdabot> Source not found. I am sorry.
14:57:40 <ehird`> err
14:57:41 <ehird`> @pl foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:57:42 <lambdabot> foldM = fix (flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . liftM2 flip ((flip . (((.) . (>>=)) .)) .) . (flip .))
14:57:44 <mrd> @let matmult a b = map (\ r -> map (\ c -> sum (zipWith (*) r c)) (transpose b)) a
14:57:45 <lambdabot> Defined.
14:57:45 <ehird`> there we go
14:57:59 <mrd> > matmult [[1,0],[0,1]] [[1,2],[3,4]]
14:58:01 <lambdabot>  [[1,2],[3,4]]
14:58:34 <blakkino> darcs give me a "Skipping depended-upon patch:" when doing an unroll.. any idea?
14:58:46 <blakkino> i'm afraid of losing my data..
14:58:47 <blakkino> :|
14:59:00 <mrd> > matmult [[1,0],[0,1]] [[1],[2]]
14:59:01 <lambdabot>  [[1],[2]]
14:59:13 <dmwit> blakkino: The friendly people in #darcs may know more.
14:59:30 <mrd> > matmult [[cos pi,sin pi],[-cos pi,sin pi]] [[1],[0]]
14:59:31 <lambdabot>  [[-1.0],[1.0]]
14:59:32 <blakkino> dmwit, yes sorry
14:59:36 <blakkino> the problem is i'm desperate :)
14:59:45 <dolio> > matmult [[1,0,0],[0,1,0][0,0,1]] [2,5]
14:59:45 <lambdabot>  Couldn't match expected type `t1 -> [t]'
14:59:58 <dolio> > matmult [[1,0,0],[0,1,0][0,0,1]] [[2],[5]]
14:59:59 <lambdabot>  Couldn't match expected type `t1 -> [t]'
15:00:04 <mrd> missing a ,
15:00:16 <dolio> > matmult [[1,0,0],[0,1,0],[0,0,1]] [[2],[5]]
15:00:16 <mrd> hmm, i think i screwed up the rotation formula
15:00:17 <lambdabot>  [[2],[5],[0]]
15:00:18 <dolio> Of course.
15:00:43 <dmwit> mrd: cos, sin, -sin, cos
15:00:49 <mrd> > matmult [[cos pi,sin pi],[-sin pi,cos pi]] [[1],[0]]
15:00:50 <lambdabot>  [[-1.0],[-1.2246063538223773e-16]]
15:00:52 <mrd> yea i just realized it heh
15:01:03 <mrd> yay fp
15:01:37 <dmwit> ?let rotate angle = matmult [[cos angle, sin angle], [-sin angle, cos angle]]
15:01:37 <lambdabot> Defined.
15:01:48 <dmwit> > rotate (pi/2) [[1], [0]]
15:01:50 <lambdabot> Terminated
15:01:54 <dmwit> orly?
15:01:54 <dmwit> > rotate (pi/2) [[1], [0]]
15:01:55 <lambdabot> Terminated
15:02:07 <mrd> :t L.rotate
15:02:08 <lambdabot> Couldn't find qualified module.
15:02:12 <mrd> :t rotate
15:02:12 <lambdabot> forall a. (Bits a) => a -> Int -> a
15:02:17 <dmwit> oy
15:02:22 <roconnor> Hmm, there ought to ge a Network.HTTP.Post
15:02:47 <dmwit> ?let rotate = Data.Bits.rotate
15:02:47 <lambdabot> <local>:2:0:     Equations for `L.rotate' have different numbers of arguments...
15:03:31 <mrd> ?pl \ a b -> map (\ r -> map (\ c -> sum (zipWith (*) r c)) (transpose b)) a
15:03:32 <lambdabot> flip (map . flip (map . (sum .) . zipWith (*)) . transpose)
15:06:41 <oerjan> dmwit: that Terminated happens to be lambdabot's usual message whenever a @let definition conflicts with a builtin ont
15:06:54 <oerjan> *one
15:07:04 <dmwit> bummer
15:07:36 <oerjan> @undef
15:07:36 <lambdabot> Undefined.
15:07:45 <oerjan> > [(),rotate]
15:07:46 <lambdabot>  Couldn't match expected type `()'
15:07:54 <oerjan> > [rotate,()]
15:07:55 <lambdabot>  Couldn't match expected type `a -> Int -> a'
15:08:25 <dmwit> > rotate
15:08:25 <lambdabot>  Add a type signature
15:08:35 <oerjan> dmwit: a -> Int -> a
15:08:42 <dmwit> I'm just playing.
15:08:43 <oerjan> (by that [rotate,()] trick
15:08:46 <dmwit> > rotate :: ()
15:08:47 <lambdabot>  Couldn't match expected type `()'
15:08:51 <ddarius> With Data.Binary rewriting my little midiscript->midi program should be easy.
15:08:55 <dmwit> > () `asTypeOf` rotate
15:08:56 <lambdabot>  Couldn't match expected type `()'
15:09:05 <dmwit> > rotate `asTypeOf` ()
15:09:06 <lambdabot>  Couldn't match expected type `a -> Int -> a'
15:10:08 <jrx> @pl \b p -> show $ getField b p
15:10:08 <lambdabot> (show .) . getField
15:10:15 * roconnor wonders what urlEncode does
15:10:25 <roconnor> @src urlEncode
15:10:26 <lambdabot> Source not found. There are some things that I just don't know.
15:10:30 <mauke> I bet it urlencodes things
15:10:34 <roconnor> @src Network.HTTP.urlEncode
15:10:34 <lambdabot> Source not found. You untyped fool!
15:10:37 <jrx> @pl \b p -> if p `elem` path then "o" else show $ getField b p
15:10:37 <lambdabot> ap (flip if' "o" . (`elem` path)) . (show .) . getField
15:10:51 <roconnor> well, I'll just call it and hope for the best
15:11:00 <oerjan> roconnor: i don't think @src ever takes a module qualifier
15:11:09 <Cin> @hoogle urlEncode
15:11:10 <mauke> urlEncode = concatMap (\c -> if good c then [c] else escape c)?
15:11:11 <lambdabot> No matches found
15:11:17 <dmwit> jrx: if' doesn't actually exist, but it's easy to write, and often useful.
15:11:27 <roconnor> oh wait urlEncodeVars may be exactly what I want
15:11:29 <mauke> where escape c = printf "%%%02X" (ord c)
15:13:17 <jrx> dmwit: like: if' :: Bool -> a -> a -> a
15:13:27 <jrx> if' True a b = a
15:13:32 <jrx> if' False a b = b
15:13:33 <jrx> ?
15:13:35 <dmwit> jrx: Exactly.
15:13:45 <mauke> if' a b c = if a then b else c
15:13:48 <dmwit> jrx: Or even, "if' p x y = if p then x else y".
15:14:00 <roconnor> urlEncodeVars doesn't seem to convert spaces to +
15:14:07 <mauke> if' a b c | a = b | otherwise = c
15:14:17 <faxathisia> if a then b else c = if' a b c
15:14:18 <oerjan> @pl \b p -> bool "o" (show $ getField b p) $ p `elem` path
15:14:19 <lambdabot> (`ap` (`elem` path)) . ((bool "o" . show) .) . getField
15:14:35 <dmwit> :t bool
15:14:36 <lambdabot> Not in scope: `bool'
15:14:37 <mauke> @. unpl pl  \b p -> bool "o" (show $ getField b p) $ p `elem` path
15:14:37 <lambdabot> (\ f -> (\ o -> bool "o" (show (getField f o))) >>= \ q -> (\ a -> elem a path) >>= \ p -> return (q p))
15:14:51 <oerjan> bool is a similar non-existent one that has the Bool last
15:14:52 <dmwit> bool is the catamorphism on Bool?
15:15:02 <oerjan> right
15:15:15 <oerjan> it's sometimes more useful than if'
15:15:55 <oerjan> both should be added to Data.Bool, i assume
15:16:32 <mrd> shouldn't it be Data.Boole?
15:17:02 <mauke> data Boole = False | True | FileNotFound deriving (Enum)
15:17:14 <Botje> giggle :)
15:17:51 <oerjan> Bool is the data type name
15:18:02 <esap> dequeue :: forall u w q t v y a z. (S.Reversable (S.PolyStack t) (S.PolyStack u), S.Reversable (S.PolyStack v) (S.PolyStack w), S.ReverseStack' (S.PolyStack u) (S.PolyStack w) (S.PolyStack q),S.Reversable (S.PolyStack q) (S.PolyStack (y, z))) =>PolyQueue t v -> (y, PolyQueue (S.PolyStack a -> a) z)
15:18:13 <mauke> AIIRRR
15:18:17 <esap> That's a type-level queue dequeue :-)
15:18:18 <dmwit> hahah
15:18:28 <mrd> the name is Boole.  George Boole.
15:18:36 <mrd> catchy
15:18:39 <mauke> Georg Bool
15:18:45 <mauke> .oO( German? )
15:18:51 <mrd> British guy
15:19:12 <oerjan> mrd: if you say so, Boolegeorgeboole
15:20:36 <dmwit> "It would be nice if generic monadic code could automagically be specialised to the identity monad in a way that didn't uglify pure code using it."
15:20:44 <dmwit> That is an interesting idea... I like it!
15:20:45 <esap> http://www.kotiposti.net/epulkkin/PolyQueue.txt and http://www.kotiposti.net/epulkkin/PolyStack.txt
15:21:14 <mauke> dmwit: it's called "imperative code"
15:21:44 <dmwit> Eh, I think he means code which uses only the Monad interface, and nothing more specific.
15:21:46 <esap> can't remove comments from dequeue type :-(
15:21:59 <dmwit> mauke: So that we wouldn't both map and mapM, for example.
15:22:08 <ddarius> dmwit: It's what we'd have if we could make something like type Id a = a an instance of Monad.
15:22:20 <dmwit> Exactly.
15:22:22 <mrd> if we named "Bool" after Boole, then shouldn't types denoting predicate logic statements be named "Frege" or perhaps "Freg"
15:25:29 <oerjan> @users
15:25:30 <lambdabot> Maximum users seen in #haskell: 465, currently: 451 (97.0%), active: 24 (5.3%)
15:26:03 <ehird`> http://www.haskell.org/haskellwiki/Type_SK <-- doesn't this mean you can do Real Bad Things with types?
15:26:04 <lambdabot> Title: Type SK - HaskellWiki
15:26:13 <ehird`> also
15:26:26 <ehird`> newtype Perhaps a b = Perhaps a b
15:26:31 <ehird`> and all operations on a 'perhaps' generate a new perhaps :-P
15:26:35 <ehird`> like:
15:26:37 <mrd> undecidable-instances allows that, ehird`
15:26:43 <ehird`> if <perhaps> then a else b
15:26:51 <ehird`> -> if <perhaps> = Perhaps True True
15:26:52 <ehird`> then a
15:26:57 <ehird`> Perhaps False False -> b
15:27:11 <ehird`> otherwise -- Perhaps a b
15:27:17 <ehird`> let's you write an Omega-Scheme interpreter...
15:27:28 <ehird`> H = const const (Perhaps True False)
15:29:23 * oerjan envisions an old lady trying out Omega-Scheme.  Perhaps she'll terminate.
15:29:26 <ehird`> Anyone know what I have to do with runhaskell to get CGI to work?
15:29:47 <ehird`> runhaskell: PATH: getEnv: does not exist (no environment variable)
15:29:49 <ehird`> is the error i get
15:29:51 <ehird`> using lighttpd
15:29:57 <ehird`> and a trivial 'hello world' cgi
15:30:21 <dmwit> PATH=$PATH runhaskell ...
15:30:26 <dmwit> or
15:30:32 <dmwit> export PATH; runhaskell ...
15:30:58 <ehird`> dmwit: ehm, lighttpd is running it.
15:31:00 <dmwit> (Can you run the program outside of lighttpd, incidentally?)
15:31:03 <ehird`> yes
15:31:04 <ehird`> yes i can
15:31:18 <ehird`> so lighttpd very intelligently restricts PATH
15:31:20 <ehird`> which makes sense.
15:31:24 <ehird`> why is haskell trying to use it in this case.
15:31:40 <dmwit> Where is getEnv being called?
15:31:41 <jeffz> what makes you want to use runhaskell? avoiding manually recompiling it?
15:32:06 <dmwit> Oh, probably runhaskell needs $PATH to discover runghc.
15:32:26 <dmwit> ehird`: What if you go straight to runghc instead of runhaskell?
15:33:16 <dmwit> Same problem, probably.
15:33:16 <ehird`> dmwit: I don't know. I'll try it.
15:33:19 <Cin> ahhh
15:33:25 <ehird`> jeffz: just for trivial cgis
15:33:43 <ehird`> for Real Stuff i'll use fastcgi
15:33:45 <dmwit> ehird`: Use something like PATH=/usr/bin runhaskell..., you need to have ghc in your path for it to work.
15:33:47 <Cin> i had this getenv error. trying to remember how i solved it
15:34:37 <Cin> oh. i just didnt use runhaskell. heh. compiled it to a program and ran the program >_>
15:34:40 <dmwit> (Or make lighthttpd put it in your path for you, I'm sure there's a way to configure it.)
15:35:10 <ehird`> lighttpd, not lighthttpd, dmwit ;)
15:35:24 <dmwit> whatever =P
15:35:59 <ehird`> same with runghc, dmwit
15:36:04 <ehird`> ok then
15:36:06 <ehird`> i'll add  the path
15:36:11 <dmwit> ehird`: Yeah, runghc needs ghc, too.
15:36:13 <ehird`> aha
15:36:15 <ehird`> [-f GHC-PATH | --
15:36:21 <ehird`> cgi.assign = ( ".hs" => "/usr/local/bin/runghc -f /usr/local/bin" )
15:36:30 <ehird`> well, not i get a 500
15:36:37 <dmwit> sweet =)
15:36:41 <ehird`> 2008-02-18 23:36:29: (mod_cgi.c.734) stat for cgi-handler /usr/local/bin/runghc -f /usr/local/bin failed: No such file or directory
15:36:49 <ehird`> great, it doesn't allow shellisms
15:36:58 <ehird`> i refuse to create a wrapper!
15:37:00 <ehird`> must..figure..out
15:37:29 * dmwit . o O ( Use the compiler, Luke... )
15:38:15 <ehird`> why?
15:38:18 <ehird`> that's like writing a cgi in C.
15:40:11 <lament> exactly. Why write cgi in C when there's brainfuck?
15:40:32 <ehird`> lament: you know what i'm saying
15:40:33 <ehird`> :)
15:41:07 <dmwit> I don't.  But then, I don't know what fastcgi is, either, so ignore me.
15:41:09 <ehird`> hm
15:41:23 <ehird`> does runghc actually call ghc
15:41:27 <ehird`> or is it faster, and uses ghci
15:42:09 <dmwit> It uses ghc.
15:42:17 <bd_> aren't they the same? :)
15:42:18 <dmwit> You can verify by moving ghc to ghc.bak. ;-)
15:42:44 <stepcut> is there a predefined function, f = const True ?
15:42:51 <dmwit> no
15:42:52 <lament> > f
15:42:55 <lambdabot>  Add a type signature
15:43:03 <dmwit> > f :: Expr
15:43:05 <lambdabot>  f
15:43:08 <ddarius> lament is foiled
15:43:15 <bd_> Expr?
15:43:20 <dmwit> > f x :: Expr
15:43:20 <lambdabot>  f x
15:43:26 <lament> > f :: (a -> Bool)
15:43:27 <lambdabot>        add (Show a) to the context of
15:43:27 <lambdabot>         the polymorphic type `forall a....
15:43:29 <dmwit> > map f [1..] :: [Expr]
15:43:30 <lambdabot>  [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10,f 11,f 12,f 13,f 14,f 15,f 16,f 17...
15:43:40 <ehird`> > const True :: Exp
15:43:40 <lambdabot>   Not in scope: type constructor or class `Exp'
15:43:41 <ehird`> > const True :: Expr
15:43:42 <lambdabot>  Couldn't match expected type `Expr'
15:43:44 <ehird`> eh
15:43:46 <ehird`> expr is ints only
15:43:47 <int-e> @type x
15:43:48 <lambdabot> Not in scope: `x'
15:43:56 <oerjan> @where Expr
15:43:56 <lambdabot> I know nothing about expr.
15:43:57 <dmwit> bd_: Have a look at twanvl's blog to see what it's all about; it's pretty neat!
15:44:04 <int-e> how does that work?
15:44:05 * stepcut adds a tracs proposal for, constTrue = const True 
15:44:08 <ddarius> @where simple.reflection
15:44:08 <lambdabot> I know nothing about simple.reflection.
15:44:19 <oerjan> @where simple-reflection
15:44:19 <lambdabot> I know nothing about simple-reflection.
15:44:22 <dmwit> int-e: A nice instance for Num and a few others.
15:44:24 <ddarius> stepcut: To save a space?
15:44:27 <oerjan> huh?
15:44:33 <dmwit> http://twan.home.fmf.nl/blog/
15:44:33 <stepcut> ddarius: exactly! ;)
15:44:34 <lambdabot> Title: 21 thoughts
15:44:41 <lament> @where puppies
15:44:41 <lambdabot> I know nothing about puppies.
15:44:55 <ehird`> whoa, runhaskell is slow
15:44:56 <ehird`> :-D
15:44:59 <ehird`> my cgis are molasses-style
15:45:07 <oerjan> did the @where get lost or is it just impossible to remember the keyword correctly?
15:45:09 <ehird`> ooh
15:45:13 <ehird`> i could make runcgi cache a compiled
15:45:21 <dmwit> ehird`: It has to compile it each time...
15:45:21 <int-e> > x :: Expr
15:45:22 <lambdabot>  x
15:45:47 <dmwit> ?where expr
15:45:48 <lambdabot> I know nothing about expr.
15:45:53 <dmwit> ?where+ expr http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
15:45:53 <lambdabot> I will never forget.
15:46:05 <ddarius> oerjan: Probably the former and maybe the latter as well.
15:46:52 <dmwit> > gcd 1 2 :: Expr
15:46:53 <lambdabot>  abs 1 `rem` abs 2
15:47:07 <int-e> dmwit: hmm. ok, so @type x  was the right idea.
15:47:28 <int-e> > x == x
15:47:29 <lambdabot>  True
15:47:31 <wy> oerjan: I began to think if there can be a possible unambiguous grammar
15:47:31 <lambdabot> wy: You have 1 new message. '/msg lambdabot @messages' to read it.
15:47:51 <dolio> > x < y
15:47:51 <lambdabot>  True
15:48:13 <dmwit> wy: Still on strings with equal numbers of 'a's and 'b's?
15:48:15 <int-e> > 2*x == x*2
15:48:16 <lambdabot>  False
15:48:22 <wy> dmwit: yes...
15:48:26 <oerjan> wy: i have a solution.
15:48:35 <oerjan> or so i think anyway...
15:48:37 <wy> oerjan: Don't tell me :)
15:48:46 <ehird`> Hmmm.
15:48:51 <wy> oerjan: have checked that with the program?
15:48:57 <oerjan> wy: hm no
15:49:06 <int-e> > 2*4 + x == 4*2 + x
15:49:06 <ehird`> can I tell ghc to dump .hi,.o in a special directory?
15:49:07 <lambdabot>  False
15:49:08 <ehird`> .compiled/ or something
15:49:39 <dolio> > 2*4 + x < 4*2 + x
15:49:40 <lambdabot>  True
15:50:12 <dmwit> ehird`: Well... "cd .compiled && ghc ../Main.hs" works for very simple programs. =P
15:50:19 <ehird`> Good point :P
15:50:25 <dmwit> ehird`: (There's also a real way to do it, I think.)
15:50:40 <wy> oerjan: have you used some other way to think? I had been trying to express the tail substring that has equal number of a's and b's, but any rightmost substring of that substring can't be balanced
15:51:49 <dmwit> ehird`: Try man ghc, vgrep for "Redirecting output".
15:51:54 <oerjan> wy: i have split the substring according to where a-b reaches various values
15:51:55 <dejones> with ghc, how can I get Char.isUpper in scope?  I tried "import Prelude as P" then "P.Char.isUpper c" ...
15:51:58 <roconnor> Is there a nicer way to say listToMaybe $ catMaybes $ map process (lines x)
15:52:08 <dmwit> dejones: import Data.Char
15:52:36 <dmwit> roconnor: msum
15:52:40 <oerjan> oh and it is not based on tails.  that tends to only give you regular languages.
15:52:54 <roconnor> @type msum
15:52:54 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
15:53:19 <dmwit> roconnor: For Maybe, msum = listToMaybe . catMaybes
15:53:23 <wy> oerjan: But I can't find a way to count
15:53:32 <ehird`> dmwit: Also, no it doesn't... because it still dumps .hi in the parent dir
15:53:39 <wy> oerjan: How many values do you have?
15:53:40 <ehird`> and hello.o
15:53:48 <dmwit> ehird`: Try -odir.
15:53:53 <roconnor> dmwit: I figured there was something
15:53:57 <dejones> dmwit: thank you, I didn't realize the link to isUpper takes me to the Data.Char module from the Char module...
15:54:04 <ehird`> dmwit: What if I want to name the output file too?
15:54:12 <oerjan> wy: values?
15:54:16 <dmwit> dejones: Char is the non-hierarchical name; "import Char" would also work.
15:54:18 <wy> oerjan: Is it of the form S -> a S b T ?
15:54:28 <dmwit> ehird`: Read the man page. ;-)
15:54:31 <dejones> dmwit: thanks
15:54:34 <wy> oerjan: you mentioned  "to where a-b reaches various values"
15:54:41 <oerjan> also my solution can be thought of in terms of that paired a b popping with a pushdown automaton i mentioned
15:54:46 <dmwit> ehird`: -odir and -o are different.
15:54:52 <ehird`> aha
15:54:53 <ehird`> :)
15:55:10 <oerjan> wy: actually the top is S = (A | B) *  (* for repetitions)
15:55:14 <wy> oerjan: My first solution today is based on your idea, but that gave me an ambiguous one
15:55:53 <TomMD> Anyone willing to partake in an imformal poll?  How many people in here are a) paid to work with Haskell b) looking to be paid to work with Haskell c) hobbiest Haskeller.  I've always wondered how the demographics looked in here.
15:55:57 <wy> oerjan: So that's S -> A S | B S | lambda
15:56:03 <oerjan> yeah
15:56:08 <dmwit> oerjan: Can you turn any NPDA into an unambiguous grammar?
15:56:11 <oerjan> *epsilon ;)
15:56:11 <wy> oerjan: let me try
15:56:19 <ehird`> dmwit: SAtil doesn't work
15:56:23 <oerjan> dmwit: no.
15:56:36 <ehird`> aha
15:56:37 <ehird`> -ohi
15:56:45 <ehird`> oh
15:56:45 <ehird`> hm
15:56:47 <dmwit> oerjan: err... I meant PDA, N not required, sorry
15:56:49 <oerjan> any CFG can be turned into an NPDA and there are languages intrinsically ambiguous
15:56:54 * kmcallister is (c), (b), has been (a) in the past and would love to do it again :)
15:57:07 <jeffz> TomMD: c and hopefully a.
15:57:09 <oerjan> dmwit: DPDA's are LR(1) equivalent
15:57:21 <wy> oerjan: What's NPDA?
15:57:32 <oerjan> wy: non-deterministic pushdown automaton
15:57:35 <wy> oerjan: got it
15:57:53 <dmwit> oerjan: Okay, so if I have a DPDA, I should consider this problem solved, up to the transformation? =)
15:58:34 <wy> oerjan: It really takes a lot of practice to be able to convert those ideas back and forth
15:59:03 <jrx> is there any function in prelude, that removes double elements in lists?
15:59:07 <dmwit> nub
15:59:17 <kmcallister> in Data.List
15:59:29 <wy> oerjan: How can you make sure it has equal number of a's and b's?
15:59:37 <dmwit> Or map head . group . sort if it is a *really* big list, and you have Ord.
15:59:45 <cjb> I wonder if there could be a version of Hoogle that tells you what function you want given data from before and after the function
16:00:11 <oerjan> TomMD: (c)
16:00:18 <cjb> it would have to run every type-appropriate function it knew about on the data, of course
16:00:20 <jrx> no, it's rather small list, and I have only Eq
16:00:23 <dmwit> ?. hoogle type \[1, 2, 2, 3] -> [1, 2, 3]
16:00:31 <lambdabot> Did you mean: forall t t1. (Num t1, Num t) => [t] -> [T1]
16:00:31 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
16:00:31 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
16:00:35 <roconnor> ConnError ought to be an instance of Error.
16:00:43 <roconnor> I wonder if there is a reason it isn't?
16:00:56 <cjb> dmwit: ok, so it's got the type inference part
16:01:01 <dmwit> Oh, hoogle doesn't know about forall, does it?  Oh well.
16:01:07 <cjb> dmwit: but that's not looking at the transformation itself
16:01:15 <dmwit> cjb: No, that was GHC doing the type inference. ;-)
16:01:21 <cjb> ooh :)
16:01:29 <TomMD> I guess it being 4pm on the USA west coast, all the people who would answer (a) on that poll are working ;-).
16:01:53 <oerjan> dmwit: yeah although the conversion is somewhat complicated
16:02:01 <oerjan> (i believe)
16:02:37 * Cin now has even more motivation to write a simple poll making cgi script
16:02:49 <oerjan> wy: note that that top split of S into A and B's is at exactly those points where a-b = 0
16:03:17 <dmwit> ?help poll
16:03:17 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
16:03:40 <dmwit> Cin now has less motivation to write a simple poll making cgi script
16:04:33 <TomMD> ?poll-show
16:04:33 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
16:04:41 <wy> oerjan: There could be many such places
16:04:46 <jeffz> ?poll-dance
16:04:46 <lambdabot> Unknown command, try @list
16:05:09 <TomMD> jeffz: You weren't in the @vixen window...
16:05:24 <jeffz> heh
16:06:18 <ehird`> Hmm/.
16:06:21 <ehird`> Writing this script is hard. :-P
16:06:28 <u_quark> @check map
16:06:38 <lambdabot>   add an instance declaration for (Testable [b])     In the expression: let b...
16:06:55 <jrx> @pl (\x -> (getField b x) /= Occupied)
16:06:56 <lambdabot> (Occupied /=) . getField b
16:07:01 <ehird`> It acts as a cgi, and compiles a haskell program with --make if it needs to be recompiled. All the output files are dumped into .compiled/, and .compiled/<out-binary> is run.
16:07:06 <ehird`> If it doesn't need to be compiled, it just runs the binary.
16:07:19 <ehird`> And if a compiler errors happens, it dumps a 500 text/plain with the ghc output.
16:07:28 <ehird`> So, just like a regular cgi, except faster when not modified.
16:07:30 <ehird`> But it just won't work.
16:07:32 <thotypous> hey, has anybody already tried to upgrade NetBSD pkgsrc's ghc to 6.8.x series? :D
16:10:39 <matthew-_> um, could someone please implement closed type classes tonight please?
16:12:55 <wy> oerjan: Can you tell me your solution. I can verify it with the brics program
16:16:41 <Cin> ehird`: can i has ur script?
16:16:49 <ehird`> Cin: it doesn't actually work
16:17:10 <Cin> ehird`: does lighttpd execute scripts (i thought it might only run binaries>_>)
16:17:26 <Valodim> what scripts?
16:17:26 * Cin tests
16:17:28 <ehird`> Cin: yes
16:17:29 <ehird`> it does
16:17:32 <dmwit> Scripts *are* binaries.
16:17:45 <Cin> well, elf, whatever
16:17:48 <Cin> ehird`: hpaste?
16:17:56 <Valodim> binaries whose behavior is defined in the interpreted files, that is
16:18:09 <ehird`> Cin: bit late. i deleted it
16:18:15 <ehird`> i'm just going to compile&use fastcgi
16:18:37 <dmwit> wy: Try something like this: (S -> aAA | bB | ""), (A -> aAA | bS), (B -> bBB | aS).
16:18:39 <ehird`> though it is a bit ugly compiling each time
16:18:39 <ehird`> :(
16:18:46 <ehird`> we need something like:
16:19:18 <dmwit> wy: err... (S -> aA | bB | ""), of course, the first one shouldn't have two A's.
16:19:26 <ehird`> ghc-cache --dir=/var/www/haskell/.cache foo.hs
16:19:36 <ehird`> which will look for 'foo' (or whatever) in that directory, and run it if foo.hs is up-to-date with it
16:19:43 <ehird`> and it puts all its junk in that cache dir
16:19:53 <ehird`> so, basically, ghc-cache would be runhaskell but it caches compiles
16:19:55 <wy> dmwit: thanks. I'll try it
16:19:59 <ehird`> that would be perfect
16:20:10 <Cin> doesn't ghc do something like that anyway?
16:20:12 <Cin> ie if you do ghc --make <foo.hs>, if it's already built it does nothing..
16:20:44 <ehird`> Cin: but ghc-cache runs it too,
16:20:49 <ehird`> and ghc spews into the current dir
16:20:54 <ehird`> well
16:20:54 <ehird`> no
16:20:58 <ehird`> it spews into the dir of the file
16:21:02 <wy> dmwit: uhh.. "the grammar might be ambiguous, but I'm not sure..."
16:21:09 <ehird`> and if you move the files, it doesn't recognize them so it recompiles each time
16:21:16 <dmwit> wy: Yeah, ambiguity is undecidable. =)
16:21:46 <ehird`> if anyone figures out how to implement 'ghc-cache', btw, please inform me
16:21:49 <ehird`> i can't get it to work
16:21:56 <dmwit> wy: Anyway, it's LR(1), which is nice.
16:22:18 <wy> dmwit: If it's ambiguous, the must it not be LR(1)?
16:22:22 <ehird`> oh yeah, and it *musn't* ever touch the dir of the source file
16:22:26 <ehird`> because -- no permissions
16:22:42 <dmwit> wy: I don't know.
16:22:52 <dmwit> wy: I'm trying to prove unambiguity right now.
16:23:03 <wy> dmwit: I haven't learned grammars more than LR(k)
16:23:51 <wy> dmwit: What does prove mean, if ambiguity is undecidable
16:24:21 <dmwit> wy: Undecidable means there's no algorithm in general that is guaranteed to halt.
16:24:35 <dmwit> wy: It does not mean there are *no instances* which can be decided.
16:24:56 <dmwit> wy: (Hence, your program can decide the ambiguity of some restricted subset of grammars.)
16:25:02 <wy> dmwit: So we need to guess?
16:25:14 <dmwit> wy: No, we just might never finish the proof. =)
16:25:34 <wy> dmwit: but we might finish
16:25:49 <dmwit> Right, you can never tell.
16:26:18 <conal> @seen svrog
16:26:18 <lambdabot> I haven't seen svrog.
16:26:27 <dmwit> Okay, I think the grammar I gave is ambiguous. =/
16:26:35 <oerjan> dmwit: i don't think yours works
16:26:49 <oerjan> basically there is more than one way to split a string into AA
16:26:55 <dmwit> right
16:27:00 <dmwit> That's exactly the problem.
16:27:20 <oerjan> because (AS)A and A(SA) can be the same
16:27:34 <oerjan> wy: ok here is my solution if you want it:
16:27:40 <EvilTerran> what're we trying to express?
16:28:10 <oerjan> S = (A | B)*, A = a A* b, B = b B* a
16:28:20 <dmwit> EvilTerran: The language over {'a', 'b'} with equal numbers of each character.
16:28:25 <wy> oerjan: Thanks
16:28:28 <EvilTerran> hm
16:29:15 <dmwit> oerjan: I don't think that works either... does it?
16:29:17 <oerjan> wy: an important fact is that _inside_ an A or B, a-b never reaches 0
16:29:34 <dmwit> oh
16:29:38 * dmwit looks again
16:29:38 <EvilTerran> i think it does
16:29:42 <oerjan> in A it is always positive, in B it is always negative
16:29:57 <ehird`> foo = "" | A "foo" B
16:29:58 <ehird`> err
16:30:04 <ehird`> foo = "" | "A" foo "B"
16:30:16 <ehird`> i think i win
16:30:17 <EvilTerran> at each step there's exactly one possible production, AFAICT
16:30:32 <wy> oerjan: good idea. A are ab, aabb, aaabbb, ... ?
16:30:34 <EvilTerran> ehird`, "BA"
16:30:36 <dmwit> ehird`: "BA"
16:30:45 <EvilTerran> @quote fugue
16:30:45 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
16:30:52 <EvilTerran> huh
16:30:59 <oerjan> wy: not just that. also aabaabbb, say
16:31:09 <dmwit> Needs a more frequent auto-?flush.
16:31:16 <ehird`> dmwit: uhm..
16:31:23 <ehird`> well, ok
16:31:25 <ehird`> i'm used to this problem
16:31:27 <ehird`> which is more common
16:31:35 <ehird`> the a^nb^n problem
16:31:45 <dmwit> right
16:31:51 <oerjan> (* for 0 or more repetitions of the previous token, like in regexes)
16:31:52 <EvilTerran> it's only more common 'cos it's easier :P
16:32:07 <wy> oerjan: how can A generate that?
16:32:28 <EvilTerran> oerjan's thinking of S rather than A, i think
16:32:33 <EvilTerran> no, wait
16:32:43 <EvilTerran> wy, A = a A ->*-< b
16:32:51 <EvilTerran> er, well, mangled that. but you get the idea
16:33:13 <wy> EvilTerran: I don't understand the notation
16:33:22 <dmwit> A -> aAAb -> aabAb -> aabaAbb -> aabaabbb
16:33:25 <EvilTerran> there's a * after the A in the production for A
16:34:01 <wy> got it
16:34:18 <ehird`> ok, ghc question... again...
16:34:20 <oerjan> wy: you can factor it out of course: A* = epsilon | A A*
16:34:27 <ehird`> the .hi and .o (etc.) files generated by ghc
16:34:38 <ehird`> how can I -- within the ghc incantation, and when using --make -- redirect these somewhere else?
16:34:51 <ehird`> and, how can I then when compiling, tell ghc where they are, so that it can use them for recompilation checking?
16:35:17 <dmwit> Use cabal. ;-)
16:35:28 <dmwit> (I kid, I kid.)
16:35:35 <ehird`> dmwit: When compiling cgis. :-P
16:36:51 <dcoutts_> ehird`: there are flags to do that, see the ghc manual, or run cabal build -v and look at the flags cabal uses
16:36:55 <EvilTerran> @where flags
16:36:57 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
16:37:03 <ehird`> dcoutts_: trying to read the manual
16:37:07 <ehird`> can't find anything working with --make
16:37:08 <wy> oerjan: So it's like A : "a" U "b", U : A | epsilon
16:37:11 <EvilTerran> oh, wow. i wasn't really expecting that to be there.
16:37:28 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#options-output
16:37:29 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
16:37:30 <TSC> ehird`: -odir and -hidir don't do the right thing?
16:37:33 <dmwit> oerjan: How do you make (A | B)* unambiguously?
16:37:33 <dcoutts_> ehird`: it's the same with or without --make, cabal uses --make
16:37:38 <ddarius> "lambdabot: Expect The Unexpected"
16:37:46 <ehird`> TSC: -hidir can only be used with --make. Suprise!
16:37:57 <EvilTerran> hehe, there's a flag called "ohi"
16:38:15 <oerjan> dmwit: because of what i said, a-b count never reaches 0 inside A or B so that top split is the only one possible
16:38:19 <ehird`> --ohi --ifixeduram
16:38:22 <EvilTerran> "ohi i redirected ur interfaces
16:38:44 <dmwit> oerjan: You misunderstand.  Let A -> a, B -> b.  How do you make S -> (A | B) * unambiguously?
16:38:48 <oerjan> wy: U = A U | epsilon
16:39:11 <EvilTerran> dmwit, S -> a S | b S | ()
16:39:24 <oerjan> what EvilTerran said
16:39:32 <EvilTerran> S -> (a | b) S | () also works
16:39:49 <dmwit> Wait, why was I thinking that was wrong?
16:39:56 <dmwit> I need to start writing things down
16:39:57 <ehird`> TSC: aha... it works...
16:39:59 <ehird`> TSC: BUT
16:40:03 <ehird`> I get Main.hi and Main.o
16:40:07 <ehird`> which will conflict with any other programs
16:40:11 <TSC> Yeah, that happened to me too
16:40:24 <dmwit> ehird`: Different directory for each program?
16:41:00 <TSC> Yeah, you'll end up with home-brew cabal
16:41:01 <dmwit> ehird`: Or, you could use the busybox approach.
16:41:03 <ehird`> dmwit: I guess so
16:41:27 <jeffz> ehird`: you should figure out how to make ccache work for ghc ;)
16:41:41 <dmwit> ehird`: http://haskell.org/haskellwiki/Simple_Unix_tools
16:42:00 <EvilTerran> ehird`, always give your files module names matching their filename?
16:42:02 <dmwit> ehird`: Read the intro, you could probably use that to make up for having only one Main.*.
16:42:11 <ehird`> EvilTerran: that will so work with cgis.
16:42:24 <dmwit> EvilTerran: With --make, you need a module Main, don't you?
16:42:44 <EvilTerran> eh. i guess you'd have to do something clever with -main-is
16:42:58 <dmwit> Oh yes, there's that, too.
16:43:16 <lament> how come simple unix tools doesn't have yes
16:43:42 <dmwit> interact . const . unlines . repeat $ "yes"
16:44:05 <dmwit> It has rpt.
16:44:38 <ehird`> wowzers, ghc's compile-checking takes about .2s in itself
16:44:41 <ehird`> that's some overheat
16:44:43 <ehird`> *overhead
16:44:58 <ehird`> yes = cycle "yes\n"
16:44:58 <ehird`> :)
16:45:18 <dmwit> nice
16:45:39 <dmwit> const (cycle "yes\n"), though, to fit in with the framework.
16:45:58 <Cin> hrm. i wrote a cache checker with md5sum instead
16:46:25 <Cin> ghc takes like 0.1 seconds minimum to just open. md5sum takes like 0.003
16:46:52 <dcoutts_> Cin: that's mostly down to parsing the package.conf file, ghc --version is much quicker
16:47:30 <oerjan> forever $ putStrLn "yes"
16:48:02 <byte-> greetings
16:48:16 <dmwit> Hiya!
16:49:08 <ehird`> Cin: you wanted that script?
16:49:18 <hpaste>  ehird pasted "runcgi" at http://hpaste.org/5739
16:49:24 <ehird`> the current problem is:
16:49:32 <ehird`> sometimes the output file just Isn't There
16:49:34 <ehird`> and only when run as a cgi
16:50:00 <EvilTerran> server may be killing the process for running for too long
16:50:11 <ehird`> EvilTerran: no.
16:50:13 <EvilTerran> if it's in a subfolder, something may not like it not existing
16:50:16 <ehird`> it takes about 1 second
16:50:18 <ehird`> and
16:50:23 <EvilTerran> check ur logs ;)
16:50:24 <ehird`> "sudo -u www-data ./runcgi hello.hs"
16:50:24 <ehird`> works
16:50:32 <ehird`> and the logs just have the '.../hello does not exist'
16:50:40 <EvilTerran> meh
16:50:56 <Cin> ouch, one second
16:51:00 <wy> oerjan: Is Nerode a big name in automata theory?
16:51:14 <matthew-_> you know how the old hackers of yore used to hack out to heavy rock music, eg the apple ][ developers, well who else here uses such tricks?
16:51:40 * ddarius is playing guitar right now.
16:51:46 <dmwit> I hack out to very mellow music.
16:51:49 * EvilTerran is currently listening to http://neurobeat.net
16:51:50 <lambdabot> Title: Neurobeat Radio
16:51:51 <ddarius> And I've written a lot of code to Bad Religion.
16:51:54 <oerjan> wy: never heard the name afair
16:52:03 <byte-> matthew-_, I'm listening to somafm right now.
16:52:12 <ehird`> i am listening to nothing
16:52:15 <ehird`> it distracts me.
16:52:17 <ehird`> when coding
16:52:28 <byte-> I'd think IRC would distract you more than music...
16:52:30 <EvilTerran> previously known as Feindsender, and before that Meltingclose
16:52:31 <dmwit> I listen to /dev/hdc sometimes. =)
16:52:42 <matthew-_> right, so it seems slightly bizarre that we all need something to "distract" us
16:52:47 <EvilTerran> i get distracted by the occasional sounds
16:52:51 <wagle_home> myhill-nerode theorem?
16:53:02 <thoughtpolice> music: cat /dev/urandom > /dev/audio
16:53:06 <byte-> mostly I listen to music
16:53:08 <EvilTerran> but persistent music blocks 'em out and helps me focus
16:53:13 <matthew-_> esp considering that at least in my case, 90% of coding in haskell is actually thinking
16:53:15 <wy> oerjan: I'm wondering if those automata are the basic stuff, or they are only some sort of "compiled" code that's hard to understand
16:53:16 <jeffz> http://www.n-heptane.com/loops/lofi-toy-piano-beat.mp3 - this is only 30 seconds, but I loop it endlessly
16:53:21 <thoughtpolice> otherwise I listen to like, dragonforce or something.
16:53:25 <byte-> because it drones out any noise from the environment
16:53:31 <stepcut> jeffz: awesome!
16:53:36 <matthew-_> thoughtpolice: lol, I've got dragonforce on at the moment
16:53:37 <byte-> at least music is pleasant to listen to, and regular
16:53:44 <byte-> rather than noisy and random
16:53:48 <jeffz> stepcut: I found it after whoising you ;) 57 seconds actually, heh.
16:53:48 <thoughtpolice> matthew-_: right on.
16:53:55 <ddarius> I code fine with or without music.
16:53:56 <matthew-_> thoughtpolice: it's crap. ;)
16:54:00 <thoughtpolice> :(
16:54:10 <jeffz> stepcut: those loops seem pretty cool, I was thinking about using them in a game
16:54:10 <stepcut> jeffz: maybe we should finish it :)
16:54:18 <ehird`> Cin: any ideas?
16:54:24 <stepcut> jeffz: that would be cool -- we can make plenty more
16:54:39 <matthew-_> so in general if I was listening to music for pleasure, I'd listen to classical music. But I find that actually requires thought and I can't background it. Whereas mindless pop music seems to work pretty well for coding
16:54:40 <Cin> ehird`: i'm experimenting with md5sum >_>
16:54:57 <ehird`> Cin: ahhh wait
16:55:01 <ehird`> does lighttpd run cgis as nobody
16:55:08 <Cin> i don't know
16:55:13 * EvilTerran listened to a live feed of Erik Satie - Vexations for a while a couple of months ago
16:55:18 <thoughtpolice> matthew-_: my playlists in general are probably pretty tabu though. this one has everything from pink floyd and mudvayne to dragonforce to random video game themes.
16:55:21 <EvilTerran> a friend of mine was taking part in a live performance
16:55:32 <gwern> I listen to Bing Crosby. hours and hours of it
16:55:44 <Cin> ehird`: mine has server.username            = "www-data"
16:55:54 <ehird`> that's server
16:55:55 <ehird`> not cgi
16:56:08 <matthew-_> I go through phases of music. For about 5 years I listened to a lot of ben folds. Since then the most recent phase has been Muse, which I do really think is good.
16:56:18 <wy> I went to an undergrad aplied logic class here, and the professor taught a "compiled" version of walking the syntax tree of proposition logic. Color the node red, then move down, set the flag to up, ...
16:56:55 <dmwit> I guess I still don't understand why all this is necessary.
16:57:13 <dmwit> What's wrong with compiling when you change the source?
16:57:37 <dmwit> i.e. changing the source is presumably manual, why can't installing the new binary also be manual?
16:58:04 <wy> the binary is too hard to understand
16:58:58 <ehird`> dmwit: because the source is in the cgi dir
16:59:00 <wy> I think obviously someone wrote a recursive version first, then unwrapped it into those code with GOTOs, then wrote a book like that
16:59:05 <ehird`> and i can just edit it and get it recompiled
16:59:20 <EvilTerran> this is lazy compilation :D
16:59:25 <ehird`> EvilTerran: true
16:59:39 <jeffz> maybe your editor should recompile it for you instead of the webserver
16:59:40 <wy> then everyone learned from that book... and don't know the source code
16:59:46 <dmwit> :xmap :w<CR> :w<CR>:make<CR>
16:59:53 <dmwit> jeffz: exactly
17:00:12 <EvilTerran> gotta be a way of doing it that works for :wa and whatnot too
17:01:00 <oerjan> wy: that coloring reminded me of a garbage collection algorithm
17:01:01 <wy> Very much like Asimov's Foundation uh?
17:01:03 <dmwit> EvilTerran: With my tex.vim, I find that ":nmap <local> <F3> :w<CR>\ll" is sufficiently general.
17:01:30 <wy> oerjan: ;)
17:01:35 * EvilTerran uses ZZ, too
17:02:02 <wy> btw: Is Haskell doing static analysis for garbage collection?
17:02:03 <dmwit> EvilTerran: i.e. rather than remapping the write commands, make a new command that both writes and compiles.
17:02:22 <EvilTerran> hm
17:02:38 <oerjan> wy: i don't think ghc as any region inference or such
17:02:40 <wy> dmwit: How can you guys bare with Vim when you appreciate a language like Haskell?
17:02:42 <oerjan> *has
17:03:04 <oerjan> i am not sure about other compilers
17:03:09 <dmwit> wy: You obviously don't know much about Vim. =)
17:03:19 <shachaf> wy: There are no working enough Haskell editors.
17:03:36 <shachaf> wy: How can you bear with anything else?
17:03:41 <wy> dmwit: I know something actually
17:04:00 <EvilTerran> vim is very much of the same mindset as perl
17:04:10 <EvilTerran> i'm still a perler, so vim works for me
17:04:13 <wy> EvilTerran: you got it
17:04:14 <gwern> wy: because they await silent yi's empire
17:04:17 <ddarius> Haskell is actually a rather minimalistic language from certain perspectives.
17:04:31 <dmwit> wy: In particular, I don't "bear with" Vim... I mold it to my will. =)
17:04:36 <jeffz> does anyone use ed to edit Haskell?  that's minimalistic.
17:04:45 <idnar> how about ex
17:04:45 <ddarius> gwern: yi was doing okay back when it was being developed by a vim user, now we have an emacs user at the helm...
17:04:50 <EvilTerran> gwern, that sounds like something HP Lovecraft would write O.o
17:04:50 <ehird`> ed is actually pretty easy to use..
17:04:56 <wy> dmwit: I don't like its language much
17:04:58 <ehird`> well, easier for C
17:04:59 <jeffz> there's an idea... implement ed in Haskell
17:05:01 * EvilTerran uses edlin :P
17:05:01 <ehird`> since you can jump braces
17:05:09 <gwern> EvilTerran: I was trying to parodize the crying of lot 49, but it didn't come out well
17:05:11 <dmwit> wy: You don't like Python?
17:05:11 <ehird`> jeffz: golf.shinh.org has an edlin challenge
17:05:14 <ehird`> there are haskell entries i think
17:05:20 <thoughtpolice> what about e3? :)
17:05:24 <shachaf> wy: What alternatives do you suggest?
17:05:26 <thoughtpolice> http://en.wikipedia.org/wiki/E3_(text_editor)
17:05:34 <ehird`> but, yeah -- i've used ed before, for editing
17:05:36 <ehird`> it's not that hard
17:05:36 <wy> dmwit: uhh... I guess Vim changed its scripting language these days
17:05:38 <ehird`> quite pleasant actually
17:05:42 <ehird`> wy: it has a python interface
17:05:44 <ehird`> ruby and perl too
17:05:51 <dmwit> wy: Like I said... you obviously don't know much about Vim. =)
17:06:02 <ehird`> anyway...
17:06:07 <ehird`> sam makes ed even nicer
17:06:17 <ehird`> it's ed, but with a gui (multiple windows, you can look at the file below, etc)
17:06:34 <wy> dmwit: It's just that my  knowledge of it stayed from 5 years ago
17:06:35 <ehird`> ken thompson's favourite editor, iirc, is sam.
17:06:36 <shachaf> > forever (getLine >> putStrLn "?")
17:06:39 <lambdabot>  <IO ()>
17:06:40 <ehird`> though he may have moved on to acme..
17:06:49 <ehird`> shachaf: pwned by lambdabot
17:06:58 <dmwit> :t forever
17:06:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
17:07:00 <ehird`> > getLine >> putStrLn "?"
17:07:02 <lambdabot>  <IO ()>
17:07:03 <ehird`> hm
17:07:04 <dmwit> Bah, they castrated it.
17:07:05 <shachaf> ehird`: That's what I was hoping to get.
17:07:05 <ehird`> sneaky
17:07:15 <dmwit> forever :: (Monad m) => m a -> m b
17:07:19 <ddarius> dmwit: I believe they uncastrated it.
17:07:45 <dmwit> :t fix (>>)
17:07:46 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m b)
17:07:46 <lambdabot>     Probable cause: `>>' is applied to too few arguments
17:07:46 <lambdabot>     In the first argument of `fix', namely `(>>)'
17:07:47 <ehird`> forever :: (Monad m) => m a => m Unicorn
17:07:50 <ehird`> Unicorn is the unreachable type
17:07:54 <ehird`> 'data Unicorn'
17:07:56 <ddarius> :t fix . (>>)
17:07:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:07:59 <ehird`> and:
17:08:11 <EvilTerran> instance Pink Unicorn; instance Invisible Unicorn
17:08:12 <ehird`> desperatelyTryToGetAUnicornAtNoAvail :: a -> Unicorn
17:08:22 <ehird`> EvilTerran: my inspiration, yes
17:08:24 <ehird`> however
17:08:25 <EvilTerran> :t fix.(>>)
17:08:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
17:08:29 <EvilTerran> :t fix.(>>=)
17:08:30 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
17:08:30 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
17:08:30 <lambdabot>     In the second argument of `(.)', namely `(>>=)'
17:08:33 <ehird`> some people (mostly young) have thwarted this
17:08:36 <ehird`> with this evil trick:
17:08:37 <gwern> at no avail? interesting. I thought it was 'to no avail'
17:08:40 <dmwit> :t fix (>>=)
17:08:40 <EvilTerran> :t fix.(>=>)
17:08:41 <lambdabot>     Occurs check: cannot construct the infinite type:
17:08:41 <lambdabot>       m = (->) (a -> m b)
17:08:41 <lambdabot>     Probable cause: `>>=' is applied to too few arguments
17:08:41 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
17:08:45 <ehird`> let unicorn = desperatelyTryToGetAUnicornAtNoAvail unicorn in unicorn
17:08:51 <wy> Let me try to find out... Is theory of computing the thing I want to know first, compared with more lambda calculus?
17:09:01 <ehird`> > (fix.(>>))
17:09:03 <lambdabot>  Add a type signature
17:09:09 <TomMD> @users
17:09:09 <ehird`> > (fix.(>>)) (putStrLn "hi")
17:09:09 <lambdabot> Maximum users seen in #haskell: 465, currently: 423 (91.0%), active: 29 (6.9%)
17:09:10 <lambdabot>  Add a type signature
17:09:11 <wagle_home> forever :: (Monad m) => m a -> _|_
17:09:18 <ehird`> wagle_home: how rude
17:09:27 <ehird`> anyway, Unicorn = _|_
17:09:28 <wagle_home> eh?
17:09:28 <dmwit> wagle_home: Bah, _|_ is a value, not a type.
17:09:35 <ac> heh. forgetting to convert a greyscale image to an RGB gives you three smaller copies of the image with strange color artifacts
17:09:35 <lambdabot> ac: You have 1 new message. '/msg lambdabot @messages' to read it.
17:09:40 <ehird`> _|_ is the one value of type Unicorn
17:09:45 <ehird`> and it is unreachable, unless by that trick
17:09:51 <ehird`> however, haskell's typesystem requires you to put it in the monad
17:09:52 <ehird`> so:
17:09:59 <ehird`> forever :: (Monad m) => m a -> m Unicorn
17:10:08 <ehird`> (Replacing 'Unicorn' with 'Void' may be preferable. :-P)
17:10:16 <EvilTerran> Bottom would work too
17:10:25 <idnar> heh
17:10:27 <wagle_home> ok: forever :: (Monad m) => m a -> Unicorn
17:10:33 <ehird`> Hm
17:10:38 <ehird`> Does Network.SCGI use the CGI interface
17:10:40 <ehird`> wagle_home: Impossible.
17:10:47 <ehird`> Like I said, that's badly typed.
17:10:47 <EvilTerran> wagle_home, it has to return a monadic value for the actions to run
17:10:54 <ehird`> because of what EvilTerran said.
17:10:59 <ehird`> otherwise, it's just a constant function.
17:11:02 <wagle_home> doesnt return a value
17:11:15 <ehird`> @djinn (Monad m) => m a -> b
17:11:24 * ehird` kicks lambdabot 
17:11:31 <EvilTerran> wagle_home, so? you can still run actions in it
17:11:34 <shachaf> ehird`: What answer did you expect?
17:11:41 <ehird`> shachaf: Not silence.
17:11:42 <gwern> blargh! i give up on hsclock. 2001 called, it wanted its GTK-using programs back
17:11:43 <EvilTerran> ?type sequence_.repeat
17:11:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
17:11:47 <EvilTerran> ?type sequence.repeat
17:11:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
17:12:04 <ddarius> @djinn a -> b
17:12:04 <lambdabot> -- f cannot be realized.
17:12:10 <ddarius> @djinn [a] -> [b]
17:12:10 <lambdabot> -- f cannot be realized.
17:12:13 <ddarius> @djinn [a] -> [a]
17:12:13 <lambdabot> f a = a
17:12:19 <EvilTerran> neither of those return, but it still runs the actions
17:12:31 <shachaf> @djinn a -> [a]
17:12:31 <lambdabot> -- f cannot be realized.
17:12:37 <EvilTerran> they're both bottom, but they're busy bottoms
17:12:41 <shachaf> It just sees [a] as another type?
17:12:47 <EvilTerran> shachaf, djinn doesn't do recursive types
17:12:59 <wagle_home> > forever (1:)
17:12:59 <ehird`> (Monad m) => m a -> Void
17:13:01 <shachaf> EvilTerran: [] wouldn't be useful in @djinn anyway.
17:13:02 <lambdabot>  <[Integer] -> ()>
17:13:02 <ehird`> @djinn (Monad m) => m a -> Void
17:13:04 <ehird`> @djinn (Monad m) => m a -> Void
17:13:12 <EvilTerran> or typeclasses
17:13:13 <shachaf> EvilTerran: But I'm surprised it's accepted at all.
17:13:22 <dmwit> > forever (return 1)
17:13:22 <lambdabot>   add an instance declaration for (Show (m ()))
17:13:23 <ehird`> Djinn has Void...
17:13:28 <ehird`> @djinn m a -> Void
17:13:28 <lambdabot> -- f cannot be realized.
17:13:29 <EvilTerran> shachaf, meh. blame Language.Haskell
17:13:29 <shachaf> @djinn Maybe a -> Void
17:13:30 <lambdabot> -- f cannot be realized.
17:13:30 <dmwit> > forever (return 1) :: [Int]
17:13:31 <ehird`> @djinn a -> Void
17:13:34 <ehird`> Eh. Well, whatever.
17:13:37 <lambdabot> -- f cannot be realized.
17:13:38 <wagle_home> EvilTerran, hmm
17:13:40 <ehird`> The idea is that you need 'm Void' to get forever to work
17:13:44 <lambdabot>  Couldn't match expected type `Int' against inferred type `()'
17:13:46 <EvilTerran> ehird`, Void is the un-realisable type
17:13:51 <ehird`> EvilTerran: Yes.
17:13:54 <dmwit> > forever (return 1) :: [()]
17:13:56 <lambdabot>  Exception: stack overflow
17:13:58 <ehird`> Which is why:
17:14:04 <ehird`> forever :: (Monad m) => m a -> m Void
17:14:07 <ehird`> is the most logical type
17:14:12 <wy> oerjan: Can you have two different splits for aabaabbaaabbbb ?
17:14:16 <EvilTerran> it's False in the constructive logic it uses through curry-howard
17:14:17 <ehird`> 'forever' returning is logically impossible.
17:14:25 <ddarius> type Void = forall a. a
17:14:31 <EvilTerran> forever :: (Monad m) => m a -> m (forall a. a)
17:14:31 <ehird`> But, since we have monadic actions, we have to `not-return' a monadic action.
17:14:33 <ddarius> That is the type people are suggesting.
17:14:35 <ehird`> so: 'm Void'
17:14:36 <shachaf> ehird`: "forall a. a" also can't be realized.
17:14:42 <ehird`> shachaf: 'data Void'
17:14:44 <wagle_home> EvilTerran, i like that
17:14:44 <EvilTerran> would be better
17:15:02 <shachaf> What's the difference in this case, though?
17:15:02 <EvilTerran> as an infinite computation can return *any* value, rather than *no* value
17:15:08 <oerjan> wy: a(ab)(aabb)(aaabbb)b should be the only possible
17:15:09 <wagle_home> thought it still implies a value
17:15:15 <wagle_home> though
17:15:24 <EvilTerran> owing to a lack of unique fixed point
17:16:13 <wy> oerjan: good. and A* is right recursive?
17:16:17 <dmwit> > do { a <- forever m; print a }
17:16:18 <lambdabot>  Couldn't match expected type `t a' against inferred type `Expr'
17:16:25 <wagle_home> ok: forever :: (Monad m) => m a -> fix m
17:16:33 <dmwit> wagle_home: ...no
17:16:39 <wagle_home> awww
17:16:42 <oerjan> wy: right, left, take your pick
17:16:44 <idnar> haha
17:17:24 <wy> oerjan: got it. but are sure this will generate all possible strings as the original ambiguous version?
17:17:59 <dolio> > do { foo <- forever (Left "bar") ; return foo }
17:18:00 <lambdabot>  Left "bar"
17:18:10 <oerjan> wy: i believe so
17:18:29 <wagle_home> > forever (1:)
17:18:30 <lambdabot>  <[Integer] -> ()>
17:19:27 <wagle_home> > do { x <- forever [1] ; return x }
17:19:28 <lambdabot>  Exception: stack overflow
17:19:40 <dmwit> > do { foo <- forever (Left "bar"); return (foo + 32) } -- indeed
17:19:40 <lambdabot>   add an instance declaration for (Num ())
17:20:00 <dmwit> That's why it should be :: m a -> m b...
17:20:05 <wagle_home> @src forever
17:20:05 <lambdabot> Source not found. :(
17:20:12 <wy> oerjan: Let me try to interprete the idea... so is A the substring that has equal number of a's and b's and can't be splited?
17:20:21 <ehird`> anyway
17:20:22 <oerjan> yes
17:20:30 <oerjan> (and starting with an a)
17:20:32 <ehird`> the problem i have with recompiling manually
17:20:34 <ehird`> is that with fcgi
17:20:38 <dmwit> > let forever = fix . (>>) in do { foo <- forever (Left "bar"); return (foo + 32) }
17:20:38 <ehird`> this means to change one thing in my app:
17:20:43 <lambdabot>  Left "bar"
17:20:44 <ehird`> - do the ghc incantation
17:20:49 <ehird`> - put binary in place
17:20:49 <wy> oerjan: What made you think of that?
17:20:52 <ehird`> - reload lighttpd config
17:20:56 <ehird`> which is a drag for every single change
17:21:45 <oerjan> wy: i sort of thought of a graph of a-b varying over time
17:22:04 <oerjan> and then splitting that graph on horizontal lines
17:22:10 <wagle_home> > forever (1:) [2..10]
17:22:16 <lambdabot> Terminated
17:22:19 <ehird`> so what should i do?
17:22:35 <dmwit> ehird`: What you need is for your program to accept a signal that causes it to fork off the new version and die.
17:22:38 <wy> oerjan: ah... that's brilliant
17:22:53 <dmwit> s/fork off.*/exec the new version./
17:23:03 <byte-> :t forever
17:23:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
17:23:12 <dmwit> ehird`: That would at least save you from having to restart lighttpd.
17:23:18 <ehird`> dmwit: won't work; lighttpd manages fcgi processes itself
17:23:21 <byte-> :t forever (1:)
17:23:21 <lambdabot> forall t. (Num t) => [t] -> ()
17:23:23 <BMeph> dmwit: Naugh, itsounds better as "fork off and die". ;)
17:23:32 <dmwit> ehird`: exec replaces a process in-place.
17:23:34 <ehird`> http://saxophone.jpberlin.de/MonadTransformer?source=http%3A%2F%2Fwww%2Ehaskell%2Eorg%2Fhaskellwiki%2FMonad <-- this is brilliant
17:23:37 <lambdabot> http://tinyurl.com/2sozd6
17:23:50 <dmwit> BMeph: ;-)
17:23:50 <ehird`> dmwit: yes, but i don't know what lighttpd does with procs - i think it kills and starts them depending on the moon cycle
17:24:08 <oerjan> :)
17:24:13 <gwern> is Hat still a living project? the last date listed is '     Version 2.05 released 22nd Oct 2006.'
17:24:15 <dmwit> ehird`: Ah, yeah, you would also need a way to send that signal to all the running processes.
17:24:33 <ehird`> dmwit: :-|
17:24:44 <ehird`> Basically, I should make using Haskell for web development as painful as C or similar.
17:24:47 <ehird`> That sounds fun.
17:25:03 <dmwit> ehird`: Right, I changed my mind, don't do that. =P
17:25:06 <wagle_home> @index warm, fuzzy thing
17:25:06 <lambdabot> bzzt
17:25:29 <ehird`> 'Commutative warm, fuzzy things are warm, fuzzy things for which the order of actions makes no difference (they commute), that is when following code:'
17:25:39 <ehird`> 'Warm, fuzzy things are known for being deeply confusing to lots of people, so there are plenty of tutorials specifically related to warm, fuzzy things. Each takes a different approach to Warm, fuzzy things, and hopefully everyone will find something useful.'
17:26:09 <ehird`> 'If you are tired of warm, fuzzy things, you can easily get rid of them.'
17:26:18 <dmwit> ?go there's a monster in my haskell
17:26:19 <lambdabot> No Result Found.
17:26:40 <Cale> Hmm, I wonder if there should be a language primitive for preventing sharing.
17:26:52 <dmwit> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
17:26:53 <lambdabot> Title: [Haskell-cafe] there's a monster in my Haskell!, http://tinyurl.com/y49m75
17:27:00 <ehird`> dmwit: So, what do you suggest?
17:27:22 <dmwit> ehird`: You're looking at the wrong guy, I know next to nothing about CGI.
17:27:57 <ehird`> dmwit: Meh.
17:27:58 <ehird`> :)
17:27:58 <gwern> dmwit: brilliant
17:28:14 <ehird`> OK, who has developed web stuff with Haskell and found a way to eliminate the awful compilation&reloading step?
17:28:28 <wagle_home> > slay $ putStrLn "a"
17:28:29 * Zao eyes his "make blag rss" step.
17:28:30 <lambdabot>   Not in scope: `slay'
17:28:55 <gwern> ''The divine among monsters is the mysterious and awesome IO.  Its powers are vast, perhaps limitless, and beginners are taught that it cannot be slain.  Like poisoned candy and release dates, this is of course a myth. The pure of spirit may, after meditation at the altar of referential transparency, cast the spell' unsafePerformIO <-- brilliant
17:29:03 <jeffz> ehird`: I've only done two cgi programs, but I don't compile to test, I test functions in ghci and compile once, strip, upx and upload.
17:29:10 <dmwit> "When you say it correctly, the terminal may become slightly moist."
17:29:47 <wagle_home> > unsafeSlay $ putStrLn "a"
17:29:47 <ehird`> jeffz: Well, that's hardly helpful for a web app.
17:29:47 <lambdabot>   Not in scope: `unsafeSlay'
17:29:56 <jeffz> ehird`: is it? why do you think so?
17:30:10 <ehird`> jeffz: I don't like looking at raw html output and manually calling request handlers
17:30:19 <dolio> "runCC (do q <- reset (\p -> forever' (shift p (\_ -> return (5 :: Int)))) ; return (q + 1))" ==> 6
17:30:39 <jeffz> ehird`: I see, my two web applications don't really output any html.
17:30:47 <ehird`> gwern: I described unsafePerformIO to ais523 -- he'd asked about it when i'd mentioned it, and I told him:
17:30:52 <ehird`> "unsafePerformIO :: IO a -> a"
17:31:00 <ehird`> and that pretty much ended that train of conversation
17:31:00 <jeffz> ehird`: I keep the html in the .html file.
17:31:48 <Cale> ehird`: What was ais523's question?
17:31:54 <gwern> ehird`: smart fellow
17:32:06 <Cale> Oh, just what that did? :)
17:32:28 <ehird`> Cale: I think I'd said something in response to that if the titanic was written in haskell, it wouldn't have even compiled -- something like 'they used unsafePerformIO'
17:32:36 <Cale> heh
17:32:40 <ehird`> and he said 'unsafePerformIO?'
17:33:27 <dmwit> http://www.willamette.edu/~fruehr/logos/PNGs/RealHackers.png
17:35:07 <ehird`> i think
17:35:28 <ehird`> unsafePerformIO e = coerce (e :: IO a) :: a
17:35:31 <ehird`> *should* work
17:35:37 * matthew-_ writes a function "damnitTryToDoSomething"
17:35:51 <ddarius> ehird`: No.
17:36:23 <EvilTerran> ehird`, most definitely not
17:36:26 <ehird`> oh
17:36:27 <ehird`> of course not
17:37:06 <wagle_home> :t coerce
17:37:07 <lambdabot> Not in scope: `coerce'
17:37:16 <oerjan> @hoogle coerce
17:37:23 <lambdabot> Unsafe.Coerce :: module
17:37:23 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
17:37:28 <ehird`> unsafeCoerce, bah.
17:37:30 <ehird`> I use my own!
17:37:42 <matthew-_> Corun: why are you up? you should be in bed. Students need their sleep....
17:37:56 <ac> PNM formats are awesome
17:38:04 <wagle_home> coerceNothingToSeeHereMoveAlong
17:38:16 <ehird`> coerceOhMyGodIAmSoSorry
17:38:25 <idnar> unsafeSplitAtom
17:38:26 <dmwit> unsafePerformRitual
17:38:29 <byte-> matthew-_, who's "Corun"?
17:38:29 <idnar> unsafeSplitAtom# !
17:38:39 <matthew-_> byte-: first year student at IC
17:38:39 <dmwit> ?localtime Corun
17:38:40 <lambdabot> Local time for Corun is Tue Feb 19 01:38:38
17:38:42 <oerjan> unsafeSummonCthulhu
17:38:49 <dmwit> Why, that's not late for a student at all!
17:38:56 <matthew-_> ;)
17:39:06 <mauke> call/cthulhu
17:39:09 <byte-> matthew-_, I don't see him in this channel?
17:39:13 <matthew-_> maybe he is actually passed out at the kb though
17:39:13 <ehird`> hey, that's the time here!
17:39:14 <ehird`>  :P
17:39:19 <ehird`> Corun: byte-
17:39:19 <gwern> mauke: c-c-cthulhu!
17:39:21 <dmwit> byte-: Look again. =)
17:39:25 <matthew-_> byte-: he just joined
17:39:27 <gwern> @hoogle trace
17:39:27 <lambdabot> Debug.Trace.trace :: String -> a -> a
17:39:27 <lambdabot> Debug.Trace :: module
17:39:27 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
17:39:29 <matthew-_> ehird`: here too!
17:39:30 <byte-> oh
17:39:30 <Corun> Oh, er
17:39:31 <Corun> Um
17:39:36 <ehird`> trace is awesome
17:39:37 <EvilTerran> ?localtime
17:39:38 <lambdabot> Local time for EvilTerran is Tue Feb 19 01:39:25
17:39:38 <byte-> I was just looking at the lhs of chat
17:39:39 <Corun> Students don't need sleep
17:39:40 <Corun> It's true.
17:39:41 <byte-> nevermind
17:39:43 <EvilTerran> yeah, me too
17:39:45 * matthew-_ looks to see what Corun has tomorrow morning
17:39:53 <EvilTerran> sleep is what sundays are for :)
17:39:57 <Corun> It's the lecture after "The Stack"
17:40:21 <EvilTerran> (spot the Thank You For Smoking reference)
17:40:25 <matthew-_> ahh, you have nothing to 11.
17:40:39 <matthew-_> unless you what to go and see the ex-leader of the tory party...
17:40:49 <ehird`> coerce :: a -> b
17:40:49 <ehird`> coerce e = let ref = unsafePerformIO $ newIORef undefined
17:40:49 <ehird`>            in unsafePerformIO $ do writeIORef ref e
17:40:49 <ehird`>                                    readIORef ref
17:40:52 <ehird`> ehm
17:40:54 <ehird`> longer than i thought
17:40:57 <ehird`> but yes.
17:41:09 <Corun> And the notes for the lecture at 11 are "The ADT BinaryTree"
17:41:21 <Corun> Woopety doo.
17:41:37 <ddarius> Abstract data type or algebraic data type?
17:41:42 <matthew-_> ok, well if you're not going then you can read up on B-Trees, B*-Trees, finger trees, red-black trees and other interesting things
17:42:20 <Corun> Abstract, dd. Also, I probably will go
17:42:28 <Corun> But, I don't need to be particularly awake, ya know :-)
17:42:40 <mauke> s k e w   b i n o m i a l   t r e e s
17:42:50 <ddarius> "A binary tree is a ..." "Zzzzzzzzzz"
17:43:03 <matthew-_> Corun: yeah, I know the feeling. There are normally one or two courses each year where you need to be awake
17:43:05 <BMeph> call/cCc - call with current Cthulhu continuations? ;p
17:43:09 <ehird`> *Main> unsafeSomething (putStrLn "hi")    ==> ()
17:43:14 <matthew-_> by the 4th year, being awake is definately recommended
17:43:16 <Corun> Watching TV and eating turkish delight just seems way more awesome than sleeping right now ^_^
17:43:17 <ehird`> *Main> unsafeSomething (getLine)    ==> ""
17:43:25 <ehird`> which is: unsafeSomething e = coerce e :: a
17:43:28 <ehird`> so it doesn't do unsafe io
17:43:36 <ehird`> but it does give you some kind of mocking facility for IO
17:43:37 <ehird`> :P
17:43:37 <gwern> I can never hear of turkish delight without worrying about the White Witch
17:44:07 * matthew-_ only has 7 (undefined :: Foobar) so far in this project...
17:44:13 <gwern> true story: the only time in my life I saw Turkish Delight was when I was in London in harrod's; I wanted to buy some very badly, but as luck had it, I had just lost my wallet >.<
17:44:27 <ddarius> This is the first time I've heard "Turkish Delight" used outside of the Chronicles of Narnia.
17:44:41 <gwern> matthew-_: the module of a thousand functions begins with a single character!
17:45:06 <byte-> gwern, don't worry, you didn't miss out on anything special.
17:45:13 <ddarius> The module of a thousand functions needs to be refactored.
17:45:27 <byte-> Turkish Delight isn't nearly as good as its name implies.
17:45:30 <idnar> arabian modules?
17:45:40 <gwern> 1001 arabian libraries
17:45:44 <Corun> Turkish Delight is frickin' awesome
17:45:53 <gwern> Corun: YOU'RE NOT HELPING
17:45:56 <idnar> I'm not a fan of Turkish Delight
17:46:02 <matthew-_> Corun: nah, it's not
17:46:03 <Corun> Possibly even more so because this particular batch came from THE WHITE WITCH! HAHAHA!
17:46:06 <byte-> meh, I dunno
17:46:13 <byte-> all I'm basing this off of is the one time I had it
17:46:16 <byte-> in 6th grade
17:46:20 <Cin> om nom nom
17:46:22 <matthew-_> this module is quite large now. And is in need of refactoring
17:46:23 <byte-> I think one of my classmate's moms made it or something
17:46:30 <matthew-_> however, there's a paper deadline approaching...
17:46:37 <byte-> so it probably wasn't of the highest quality
17:47:12 <ehird`> hm
17:47:14 <ehird`> with my coerce:
17:47:15 <ehird`> unsafeSomething :: IO a -> a
17:47:15 <ehird`> unsafeSomething e = coerce e :: a
17:47:21 <ehird`> if you get an IORef, with unsafeSomething
17:47:24 <ehird`> then try and read it
17:47:27 <matthew-_> remind me, what happens when the victim eats the turkish delight in the lion, witch and the wardrobe?
17:47:27 <ehird`> it explodes
17:47:39 <gwern> matthew-_: can't stop eating, too delicious iirc
17:47:43 <ddarius> unsafeCoercing tends to do that
17:47:48 <ehird`> matthew-_: some kind of christian metaphor, probably.
17:47:57 <ddarius> matthew-_: Nothing.
17:48:01 <Corun> Nothing. The child is edmund.
17:48:08 <Corun> Main characters can't have bad things happen.
17:48:09 <ehird`> ddarius: yes.. but amusing, because in "IO a" you can get a valid a with unsafeSomething
17:48:09 <byte-> isn't he the chubby one?
17:48:13 <ehird`> for IO String, you get ""
17:48:14 <ehird`> for IO (), you get ()
17:48:18 <wagle_home> now we know what the thin mint was made of?
17:48:20 <ehird`> for IORefs, you get... a corrupted ioref
17:48:21 <Cin> the witch temps him with them, and he gets really fat and has a heart attack. she planned it all along
17:48:56 <matthew-_> Cin: it was a very early attempt to prevent the rising obesity epidemic
17:49:13 <matthew-_> Jamie Oliver is a reincarnation of C S Lewis!
17:49:21 <Cin> matthew-_: indeed. of course, a foolish one. nobody can stop the delight of the turkish
17:49:55 <matthew-_> Cambodian Cocain may be preferable to Turkish Delight...
17:49:57 <lament> Corun: what about the girl who got denied heaven?
17:50:05 <gwern> susan?
17:50:06 <Corun> I don't remember
17:50:20 <matthew-_> hmm. My supervisor's called Susan.
17:50:24 <lament> Corun: i mean, she's a main character
17:50:39 <gwern> yeah, but she prefers boys to Aslan
17:50:45 <gwern> so obviously she must go to hell
17:50:52 <Corun> Yay Aslan.
17:50:58 <Cin> haha? denied in heaven? "hey, god, can i have a turkish delight?" "DENIED." "aw.."
17:51:52 <matthew-_> ENOTURKISHDELIGHT
17:52:16 <Cin> Susan: "But my girlfriend's in there!" Aslan: "Hey, a lot of people's girlfriends are in there."
17:52:45 <gwern> Cin: you should go read Neil Gaiman's short story, 'The Problem of Susan'
17:52:53 <gwern> freaky ending. I'm sure I don't understand it
17:53:21 <byte-> what's the syntax for @ patterns in haskell, again?
17:53:31 <kmcallister> v@p
17:53:36 <byte-> x@(Just _)
17:53:37 <ddarius> a@(Just x)
17:53:38 <byte-> ?
17:53:40 <byte-> ok, thanks
17:53:40 <kmcallister> v is a var, p is a pattern
17:53:47 <byte-> I've got OCaml on the brain, for some reason
17:53:55 <Cin> gwern: i may just do that
17:53:57 <byte-> I used Some/None in my code earlier and didn't even realize it
17:54:00 <byte-> until I compiled :/
17:54:02 <ddarius> byte-: You should get that looked at.
17:54:06 <kmcallister> has anyone written a Haskell -> OCaml syntax converter yet?
17:54:11 <byte-> Damn you, F#!
17:54:22 <ddarius> kmcallister: Why in God's name would anyone do that?!
17:54:23 <Corun> Well, bye.
17:54:25 <kmcallister> it could probably be done with some unholy mixture of Template Haskell and Camlp4 :D
17:54:35 <gwern> Cin: incidentally, it's a bit nsfw
17:54:36 <kmcallister> ddarius, because Haskell has nicer syntax, but for various other reasons one may want to use OCaml
17:54:49 <ddarius> kmcallister: So what you mean is a Haskellish frontend for O'Caml.
17:54:55 <kmcallister> yeah
17:55:04 <Cin> gwern: sounds... interesting...
17:55:20 <ddarius> kmcallister: It should be readily doable with camlp4
17:55:21 * gwern grins, and imagines Cin's reaction to the ending
17:55:24 <kmcallister> you would have to extend / modify the haskell syntax a bit, but not too much
17:55:29 <kmcallister> hmm, maybe i should learn camlp4 then :)
17:56:45 <byte-> sweet
17:57:07 <byte-> my 20 lines of code finally compile
17:57:19 <TomMD> @karma Haskell
17:57:19 <lambdabot> Haskell has a karma of 23
17:57:27 <byte-> I think maybe I should stop coding
17:57:29 <byte-> my brain feels like mush
17:57:40 <gwern> Cin: https://webfiles.berkeley.edu/xythoswfs/webui/SrAndrea/narnia?action=frameset&subaction=print&uniq=gljjav is a workable link, although kind of awkward
17:57:41 <lambdabot> http://tinyurl.com/ered6
17:58:40 <Cin> gwern: awesome
17:59:37 <foxyom> when running "make install" of the linux binary package it fails when trying to install OpenAL with: "installPackage: error reading dist/setup-config; run "setup configure" command?"
17:59:55 <Vladimir123> Does Haskell optimize tail recursion?
18:00:17 <ehird`> Vladimir123: No, that's why all Haskell programs using the Prelude functions run out of stack very quickly.
18:00:19 <ehird`> (Yes.)
18:00:51 <Vladimir123> ?
18:01:39 <gwern> Vladimir123: laziness interacts with tail recursion in counterintuitive ways
18:01:43 <hpaste>  foxyom pasted "GHC 6.8.2 linux install failure" at http://hpaste.org/5740
18:03:04 <byte-> hehe
18:03:07 <byte-> I feel so naughty
18:03:19 <wy> oerjan: still not very clear why you use A -> a A* b... it's self recursive
18:03:32 <byte-> I'm going to call my language's identify function with itself.
18:07:54 <ehird`> byte-: what does the function do?
18:07:55 <monochrom> @type id id
18:07:58 <lambdabot> forall a. a -> a
18:08:06 <monochrom> > id id 'T'
18:08:10 <lambdabot>  'T'
18:08:27 <ehird`> identify
18:08:29 <ehird`> not identity
18:08:34 <byte-> oops
18:08:36 <monochrom> oops
18:08:37 <byte-> I meant identity
18:08:39 <ehird`> oh
18:08:40 <monochrom> haha
18:08:44 <ehird`> byte-: so that's just (a -> a)
18:08:46 <byte-> don't know how that f snuck in there
18:08:47 <ehird`> why is that naughty
18:09:03 <byte-> must...hold...back...your mama joke
18:09:13 <ehird`> heh
18:09:17 <byte-> I don't konw
18:09:23 <byte-> damn you, fickle fingers!
18:09:29 <byte-> I just find it amusing.
18:10:21 <ehird`> I want an IdentityT monad.
18:10:22 <ehird`> :D
18:10:23 <oerjan> wy: each nested level of A's corresponds to a-b increasing by 1
18:10:53 <wagle_home> > identify 'T'
18:10:54 <lambdabot>  Couldn't match expected type `Char -> t'
18:10:57 <ddarius> type Identity = IdentityT Identity
18:11:31 <oerjan> the A* is because a-b might reach 1 several times before coming back to 0
18:11:46 <wy> oerjan: such as ab, aabb, aaabbb?
18:11:57 <roconnor> @type bracket
18:11:57 <ehird`> @type identify
18:11:58 <lambdabot> Not in scope: `bracket'
18:11:59 <lambdabot> Not in scope: `identify'
18:12:02 <ehird`> ddarius: Yes, exaxctly.
18:12:03 <byte-> ok, well I'm done for the night.
18:12:08 <ehird`> I want my IdentityT!
18:12:10 <roconnor> @type Control.Exception.bracket
18:12:11 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
18:12:12 <ehird`> > identify
18:12:13 <lambdabot>   Not in scope: `identify'
18:12:17 <ehird`> o.O
18:12:23 <wagle_home> > identify 'T'
18:12:24 <lambdabot>  "don't know yet, try again"
18:12:27 <chessguy> @bot
18:12:27 <byte-> you're not going to let that down, are you?
18:12:27 <lambdabot> :)
18:12:27 <ehird`> wtf??
18:12:30 <ehird`> @identify T
18:12:31 <lambdabot> Unknown command, try @list
18:12:36 <ehird`> what the hell is 'identify'
18:12:36 <oerjan> 0 a 1 (a 2 (a 3 b) 2 b) 1 b 0
18:12:47 <byte-> anyway, see you all later.
18:12:48 * wagle_home cackles
18:13:25 <wy> oerjan: It's still twisting my brain
18:14:22 <roconnor> @docs Control.Exception.bracket
18:14:23 <lambdabot> Control.Exception.bracket not available
18:14:25 <wy> oerjan: Can I use this? U -> a U b | () , A -> a U* b ?
18:14:28 <ehird`> > let identify_ d x = (x `elem` d, identify_ (x:d)); identify = identify_ [] in identify 1 2 3
18:14:29 <lambdabot>      Occurs check: cannot construct the infinite type:
18:14:29 <lambdabot>       t = (Bool, a -> ...
18:14:33 <ehird`> > let identify_ d x = (x `elem` d, identify_ (x:d)); identify = identify_ [] in 1
18:14:34 <lambdabot>      Occurs check: cannot construct the infinite type:
18:14:34 <lambdabot>       t = (Bool, a -> ...
18:14:36 <ehird`> hm
18:14:37 <ehird`> that's a shame
18:14:40 <ehird`> why can't i do that
18:14:40 <ehird`> :(
18:15:19 <oerjan> wy: when a-b > 0, if the next character is an a, start an A.  if it is b, end the current one.
18:16:08 <wagle_home> > let identify_ d x = (x `elem` d, Just $ identify_ (x:d)); identify = identify_ [] in 1
18:16:09 <lambdabot>      Occurs check: cannot construct the infinite type:
18:16:09 <lambdabot>       t = (Bool, Maybe...
18:16:37 <ehird`> > let identify_ = fix (\f d x -> (x `elem` d, f (x:d))) in 0
18:16:50 <oerjan> for a-b < 0 do the opposite with B.  for a-b == 0, start an A or B as appropriate.
18:16:53 * ehird` kicks lambdabot 
18:16:53 <lambdabot>      Occurs check: cannot construct the infinite type:
18:16:53 <lambdabot>       t = (Bool, a -> ...
18:16:57 <ehird`> hahah
18:17:15 <wy> oerjan: Are you generating strings with a in the front and b at end, and ab, aabb, aaabbb, ... those in the middle?
18:17:17 <wagle_home> i'm fuzzy on the mechanics, but using a newtype can get you out of the infinite type thing
18:17:22 <ehird`> > let identify_ = fix (\f d x -> (x `elem` d, uncurry ($) (f,(x:d)))) in 0
18:17:23 <lambdabot>      Occurs check: cannot construct the infinite type:
18:17:23 <lambdabot>       t = (Bool, a -> ...
18:17:26 <ehird`> wagle_home: yes
18:17:32 <matthew-_> ehird`: I've spent entire weeks kicking ghc about that one...
18:17:39 <ehird`> > let identify_ = fix (\f d x -> (x `elem` d,f,(x:d))) in 0
18:17:40 <lambdabot>      Occurs check: cannot construct the infinite type:
18:17:40 <lambdabot>       t = (Bool, [a] -...
18:17:58 <ehird`> > let identify_ d x = (x `elem` d,identify_,x:d) in 0
18:17:59 <lambdabot>      Occurs check: cannot construct the infinite type:
18:17:59 <lambdabot>       t = (Bool, [a] -...
18:18:01 <ehird`> wtf
18:18:05 <ehird`> > let identify_ d x = (x `elem` d,Just identify_,x:d) in 0
18:18:06 <lambdabot>      Occurs check: cannot construct the infinite type:
18:18:06 <lambdabot>       t = (Bool, Maybe...
18:18:12 <ehird`> > let identify_ d x = (x `elem` d,[identify_],x:d) in 0
18:18:13 <lambdabot>      Occurs check: cannot construct the infinite type:
18:18:13 <lambdabot>       t = (Bool, [[a] ...
18:18:36 <ehird`> > let identify_ :: [a] -> a -> (Bool,b,[a]); identify_ d x = (x `elem` d,[identify_],x:d) in 0
18:18:37 <lambdabot>   [identify_]
18:18:37 <lambdabot>     In the expression: (x `elem` d, [identify_], x : d)
18:18:37 <lambdabot>     In ...
18:18:44 <ehird`> > let identify_ :: [a] -> a -> (Bool,b,[a]); identify_ d x = (x `elem` d,identify_,x:d) in 0
18:18:45 <lambdabot>   identify_
18:18:45 <lambdabot>     In the expression: (x `elem` d, identify_, x : d)
18:18:45 <lambdabot>     In the ...
18:18:47 <wagle_home> > let identify_ d x = (x `elem` d, identify_ (x:d) x); identify = identify_ [] in 1
18:18:47 <lambdabot>      Occurs check: cannot construct the infinite type: t = (Bool, t)
18:18:47 <lambdabot>       Ex...
18:19:09 <wagle_home> > let identify_ d x = (x `elem` d, Just $ identify_ (x:d) x); identify = identify_ [] in 1
18:19:09 <lambdabot>      Occurs check: cannot construct the infinite type:
18:19:09 <lambdabot>       a = (Bool, Maybe...
18:19:14 <thotypous> haskell is the worlds faster language :D  http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all&xfullcpu=5&xmem=0&xloc=5&binarytrees=5&chameneosredux=1&fannkuch=1&fasta=1&knucleotide=1&mandelbrot=1&meteor=0&nbody=1&nsieve=1&nsievebits=1&partialsums=1&pidigits=1&recursive=1&regexdna=1&revcomp=1&spectralnorm=1&hello=5&sumcol=5&threadring=2&calc=Calculate
18:19:15 <lambdabot> Title: Create your own Ranking | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/2ro77o
18:19:17 <oerjan> wy: U -> a U b | () won't work.  it doesn't take account of the fact that a-b can go up and down several times within an A
18:19:25 <ehird`> thotypous: if you weight it to hell
18:19:43 <thotypous> I've adjusted the weights so haskell got the faster haha :D
18:20:13 <ehird`> type Identifier a = [a] -> a -> (Bool,Identifier a)
18:20:18 <ehird`> identify_ :: Identifier a
18:20:21 <oerjan> that's the whole point of using * at _every_ level
18:20:24 <ddarius> Exercise to the Reader:  Adjust the weights so ruby comes out the fastest.
18:20:24 <wy> oerjan: U generates those ab, aabb, aaabbb, .... And if I wrap them in any order in a...b, there will be always more a's than b's
18:20:27 <ehird`> identify_ d x = (x `elem` d,identify_ (x:d))
18:20:35 <ehird`> identify = identify_ []
18:20:37 <ehird`> :D
18:20:43 <ehird`> If only recursion was allowed in type synonyms..
18:20:43 <thotypous> ddarius, it should be very difficult :P
18:20:48 <ehird`> Even the Y combinator would type!
18:20:55 <oerjan> wy: you don't get everything that way
18:20:58 <ehird`> of course, there should be a way to do that anonymously, so that the type can be reported properly.
18:20:59 <wy> oerjan: maybe they are equivalent?
18:20:59 <ddarius> thotypous: I'm wondering if it is even possible.
18:21:10 <wy> oerjan: or I missed something
18:21:20 <ehird`> identify_ :: let Identifier a = [a] -> a -> (Bool,Identifier a) in Identifier a
18:21:32 <ehird`> all in favour of the above syntax being a good type for `identify_ d x = (x `elem` d,identify_ (x:d))`, say 'yay'
18:22:06 <wy> oerjan: Can you have aabaababbb?
18:22:15 <ehird`> or .. offer constructive comments
18:22:22 <oerjan> wy: a(a(ab)(a(ab)b)(a(a(ab)b)(ab)b)b)(ab)b -- perfectly legal
18:22:37 <ehird`> :(
18:23:19 <wy> oerjan: got it. yours is more
18:23:29 <ehird`> http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=cal&id=0 <-- uh, haskell influence anyone?
18:23:31 <lambdabot> Title: binary-trees CAL program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer La ..., http://tinyurl.com/2nl8u7
18:23:39 <ehird`> even has $
18:23:41 <ehird`> and `seq`
18:23:47 <ehird`> and the type sigs
18:23:58 <ehird`> and show
18:23:59 <ehird`> and ++
18:24:11 <gwern> oh wow, CAL is still alive?
18:24:21 <ehird`> ?
18:24:48 <gwern> CAL was this quixotic attempt to hybridize haskell and java, iirc
18:24:53 <ehird`> crazy
18:25:48 <wy> oerjan: yes. I've checked that.
18:26:48 <wy> oerjan: Is this the same as balanced parentheses?
18:27:34 <wagle_home> cute!
18:28:01 <oerjan> wy: ah yes, that's true
18:28:35 <BMeph> CAL seems to take the worst aspects of Haskell and Java and develop them to the fullest. :|
18:28:53 <roconnor> @pl (\sid -> runReaderT cmd (nm,sid))
18:28:53 <lambdabot> runReaderT cmd . (,) nm
18:29:31 <BMeph> ehird': isn't identify_ (x:d) f type a -> (Bool,Identifier a), vice just Identifier a?
18:30:10 <BMeph> ehird': (file that under constructive comment, I guess. ;)
18:30:12 <ehird`> BMeph: well, yes
18:30:14 <ehird`> ok then:
18:30:40 <BMeph> s/ f/ of/
18:30:41 <ehird`> identify_ :: a = [b] -> b -> (Bool,a)
18:30:58 <wy> oerjan: so it can be rewritten as A -> a A b A | ()
18:31:09 <ehird`> Y :: (a = a -> a) -> a
18:31:11 <ehird`> er, i think...
18:31:19 <ehird`> when allowing recursive = synonyms, what IS y's type?
18:33:15 <ehird`> =/
18:33:56 <oerjan> wy: no (), that messes up the top
18:34:01 <hpaste>  gwern pasted "hard overlapping instances error" at http://hpaste.org/5741
18:34:34 <gwern> so I tested commenting out either of the two; compilation faisl with no instances either wya; I added in OverlappingInstances and the two other Instances flags, that didn't help either
18:34:41 <gwern> any ideas?
18:35:09 <oerjan> wy: ah, unless you modify to S -> a A b S | b B a S | ()
18:35:42 <wy> oerjan: Isn't that our original grammar?
18:35:55 <oerjan> hm perhaps
18:36:40 <wy> oerjan: may be equivalent
18:36:49 <oerjan> wy: then A corresponds to what i called A*
18:37:52 <oerjan> so it is pretty clearly the same
18:39:20 <wy> oerjan: so A is the matched parentheses...
18:39:38 <oerjan> and B is matching with a and b switched
18:39:53 <wy> oerjan: but is A splittable?
18:41:05 <wy> oerjan: A can derive aabbab
18:41:06 <oerjan> wy: AA subset A, but you cannot derive A -> AA
18:41:18 <oerjan> so there is no ambiguity
18:42:03 <wy> oerjan: nice... really twisted today
18:44:31 <hpaste>  mmorrow pasted "lambda compiler with harpy (from tutorial 2)" at http://hpaste.org/5742
18:45:12 <gwern> looks cut off
18:45:27 <gwern> freevariables really the last function?
18:46:15 <adu> whats the difference betwee Monoid and MonadPlus?
18:46:35 <wagle_home> @index Monoid
18:46:35 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
18:46:46 <wagle_home> @src Monoid
18:46:46 <lambdabot> class Monoid a where
18:46:46 <lambdabot>     mempty  :: a
18:46:46 <lambdabot>     mappend :: a -> a -> a
18:46:46 <lambdabot>     mconcat :: [a] -> a
18:47:20 <adu> @src MonadPlus
18:47:21 <lambdabot> Source not found. My mind is going. I can feel it.
18:47:30 <dolio> MonadPlus m implies that forall a. Monoid (m a)
18:47:33 <hpaste>  Paczesiowa pasted "typeclass for tuples" at http://hpaste.org/5743
18:47:38 <paczesiowa> was this thing for tuples ever considered to be added to haskell''s (we need to figure out priority of 's clitic and prime symbol) prelude?
18:48:10 <adu> thing for tuples?
18:48:42 <adu> dolio: ok
18:48:43 <wagle_home> @index MonadPlus
18:48:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:49:09 <wagle_home> @src Control.Monad.MonadPlus
18:49:09 <lambdabot> Source not found. You speak an infinite deal of nothing
18:49:39 <dolio> adu: Of course, that's not enforced anywhere or anything.
18:49:49 <oerjan> > (Just "hah" `mappend` Nothing, Just "hah" `mplus` Nothing)
18:50:04 <lambdabot>  thread killed
18:50:07 <adu> woah! that is brilliant!
18:50:23 <oerjan> > (Just "hah" `mappend` Nothing, Just "hah" `mplus` Nothing)
18:50:24 <lambdabot>  (Just "hah",Just "hah")
18:50:29 <hpaste>  mmorrow annotated "lambda compiler with harpy (from tutorial 2)" with "didn't succeed in pasting the whole thing" at http://hpaste.org/5742#a1
18:50:30 <oerjan> hm something wrong
18:50:34 * adu votes for Data.Tuples
18:50:45 <oerjan> > (Just "hah" `mappend` Just "not", Just "hah" `mplus` Just "not")
18:50:46 <lambdabot>  (Just "hahnot",Just "hah")
18:50:58 <wagle_home> > (Just "hah" `mappend` Nothing, Just "hah" `mplus` Nothing)
18:50:58 <lambdabot>  (Just "hah",Just "hah")
18:51:42 <wagle_home> oh..  nm..  thought you put in different things
18:51:49 <hpaste>  mmorrow annotated "lambda compiler with harpy (from tutorial 2)" with "oh, it wasn't me...the rest" at http://hpaste.org/5742#a2
18:51:55 <dolio> adu: Oh, I suppose that's another issue. Sometimes the Monoid instance doesn't match the MonadPlus instance.
18:52:17 <dolio> Since there is possibly more than one monoid you could define.
18:52:40 <dolio> The Monoid corresponding to the MonadPlus for Maybe is First, I think.
18:53:30 <adu> dolio: which do you think is more fundamental?
18:53:43 <adu> Monoid?
18:54:10 <dolio> Depends what you're doing.
18:54:25 <dolio> MonadPlus is useful if you're looking at Maybe as a computation with failure.
18:54:45 <adu> hmm ok
18:55:00 <dolio> That Monoid instance just lifts Monoids into Maybe.
18:55:23 <dolio> Just a `mappend` Just b = Just (a `mappend` b)
18:55:35 <adu> ok
18:55:44 <dolio> Just a `mappend` Nothing = Just (a `mappend` mempty) ...
18:55:45 <dolio> Etc.
18:56:00 <mrd> woo hoo, someone benefited from HXT/Practical
18:56:21 <dolio> Of course, there are monoids that aren't monads.
18:57:11 <dolio> If you're working with monads, you probably want MonadPlus. If you're thinking in terms of monoids you probably want Monoid.
18:57:12 <adu> cool
18:59:52 <dolio> > 5 `mappend` 4
18:59:53 <lambdabot>  Add a type signature
18:59:58 <dolio> > 5 `mappend` 4 :: Int
18:59:59 <lambdabot>   add an instance declaration for (Monoid Int)
18:59:59 <lambdabot>     In the expression: 5 `mapp...
19:01:19 <matthew-_> a super class constraint adds a constraint to all instances right? It doesn't allow the derivation of instances from a given super class instance
19:01:24 <dolio> > getProduct $ Product 5 `mappend` Product 4
19:01:24 <lambdabot>  20
19:04:34 <dolio> @check \ms -> getFirst (mconcat (map First ms)) == msum (ms :: [Maybe Int])
19:04:36 <lambdabot>  OK, passed 500 tests.
19:05:14 <roconnor> @type args
19:05:15 <lambdabot> Not in scope: `args'
19:05:22 <roconnor> @hoogle args
19:05:23 <lambdabot> Distribution.Simple.Args :: type Args
19:05:23 <lambdabot> Data.Typeable.typeRepArgs :: TypeRep -> [TypeRep]
19:05:23 <lambdabot> GHC.Environment.getFullArgs :: IO [String]
19:05:36 <roconnor> @hoogle arg
19:05:37 <lambdabot> Distribution.Simple.Args :: type Args
19:05:37 <lambdabot> System.Console.GetOpt.ArgOrder :: data ArgOrder a
19:05:37 <lambdabot> System.Console.GetOpt.ArgDescr :: data ArgDescr a
19:05:38 <oerjan> @hoogle getArgs
19:05:38 <lambdabot> System.Environment.getArgs :: IO [String]
19:05:45 <EvilTerran> matthew-_, if you put it on the class decleration, yes
19:06:00 <EvilTerran> if you put it on the instance decleration, that gives instances from the superclass instances
19:07:13 <EvilTerran> class Num a => Integral a -- every integral type is numeric
19:07:50 <EvilTerran> instance Monad m => Functor (WrappedMonad m) -- every WrappedMonad m, where m is a Monad, is a Functor
19:08:07 <roconnor> how would I get input from standard in without echoing the characters (for passwords?)
19:08:20 <EvilTerran> by not using standard in
19:08:24 <cjb> roconnor: you might use ncurses.
19:08:26 <mrd> ffi to getpass()? (a horribly insecure function)
19:08:33 <mrd> or to PAM
19:08:34 <EvilTerran> you have to use terminal-manipulation functions for that
19:08:49 <EvilTerran> as stdin is nowt but a buffered stream
19:09:37 <cjb> roconnor: this is why there are very few unix apps that have you type in a password, rather than put it in a file somewhere :)
19:09:43 <roconnor> EvilTerran: right, I guess this is outside the scope of stdin
19:10:02 <EvilTerran> indeed
19:10:08 <roconnor> cjb: we all love putting passwords in files
19:10:18 <roconnor> cjb: maybe I can call some kde program.
19:10:37 <ddarius> nought
19:14:10 <jeffz> roconnor: if you install the glibc info page there is a C example for a getpass replacement as getpass is obsolete
19:14:47 <jeffz> roconnor: apt-get install glibc-doc on debian systems, info libc
19:15:38 <roconnor> kdialog --password foo seems to do what I want
19:15:59 * jeffz shrugs
19:17:21 <allbery_b> kcheckpass, but a binding to PAM would be nice
19:17:53 * allbery_b notes his connection to this remote session is acting up
19:19:49 <jeffz> what does pam have to do with turning off echoing?  maybe hSetEcho would be good in System.IO
19:20:19 <mrd> PAM reads the password for you and does the authentication
19:20:21 <roconnor> allbery_b: I don't need the system password
19:20:30 <roconnor> I need a password for a website.
19:20:39 <roconnor> although i suppose PAM might do that sort of thing.
19:20:45 <mrd> hmm, probably not
19:20:52 <jeffz> mrd, no one asked about passwords
19:21:00 <mrd> PAM doesn't give the password to the app
19:21:03 <dagit|lispy> do they have a secure PAM?
19:21:08 <roconnor> anyhow, isn't there an easy way to run a process and get it's stdout?
19:21:13 <mrd> jeffz: erm? huh?
19:21:27 <mrd> 22:08 < roconnor> how would I get input from standard in without echoing the characters (for passwords?)
19:21:30 <yondalf> roconnor: in c we would use popen, maybe there's a haskell equivalent
19:21:35 <yondalf> @hoogle popen
19:21:36 <lambdabot> No matches found
19:21:53 <jeffz> mrd, oh, I missed the last bit then, sorry
19:22:08 <sclv> so I know HSQL isn't altogether right now, but in general, are there any reasons that ppl find it preferable to HDBC? Last I looked they seemed fairly similar. Is there any reason to keep both going?
19:22:29 <roconnor> oh runInteractiveCommand
19:22:31 <dons> your could also try takusen now
19:22:33 <roconnor> that seems good
19:22:33 <dons> its on hackage.
19:22:57 <dons> i'd love a combined db, fastcgi, html templating framework, to roll really quick webapps
19:23:03 <dons> without the overhead of happs . hmm
19:23:24 <cjb> is hmm a framework on top of happs?
19:23:30 <cjb> or have I just been reading too much Haskell code today?
19:23:37 <dons> hmm?
19:23:43 <dons> hehe
19:23:47 <cjb> :)
19:24:01 <dons> hmm eh? haskell magic modules?
19:24:29 <allbery_b> actually kcheckpass does the wrong part, you pipe a password to it and it PAMs it
19:25:40 <monochrom> "hmpf" may be the next cool name. :)
19:25:41 <hpaste>  jeffz pasted "how to turn on/off echo" at http://hpaste.org/5744
19:26:16 <sclv> dons: that's my secret project!
19:26:32 <sclv> I got the controller engine pretty much working yesterday.
19:26:54 <bparkis> map and reduce are really special cases of matrix multiplication with a customized scalar + and *
19:26:56 <bparkis> http://www.bparkis.com/node/8
19:26:57 <lambdabot> Title: Matrices and map/reduce | www.bparkis.com
19:27:35 <wagle_home> jeffz, eeek!  what language is that in?!?
19:27:53 <jeffz> wagle_home: C, ffi was mentioned - that's the starting point.
19:28:03 <wagle_home> j/k
19:28:11 <sclv> Maybe I could build on takusen. That's built on HDBC anyway though.. so my question still stands about what HSQL is useful for...
19:28:27 <sclv> is it lower level, etc.?
19:28:34 <dons> sclv: takusen doesn't need hdbc, afaik...
19:28:47 <dons> i uploaded it to hackage today. it just runs on top of say, sqlite
19:28:48 <roconnor> readPassword str = do
19:28:48 <roconnor>   (_,output,_,ph) <- runInteractiveCommand cmd
19:28:48 <roconnor>   ExitSuccess <- waitForProcess ph
19:28:48 <roconnor>   hGetContents output
19:28:48 <roconnor>  where
19:28:49 <roconnor>   cmd = "kdialog --password "++(show str)
19:28:58 <dons> ExitSuccess <- waitForProcess  eh?
19:29:03 <dagit|lispy> sclv, isn't HSQL the one that allows lazy fetching of query results?
19:29:26 <sclv> dons.. you're right, just checked.
19:29:41 <monochrom> "You are expected to succeed." :)
19:29:58 <mrd> bparkis: aye, and matrix multiplication is embarrassingly parallel =)
19:30:03 <roconnor> dons: what do you think?
19:30:34 <stepcut> dons: I thought the point of happs was to have a db, "fast cgi", and html templating framework to roll really quick webapps without the overhead of apache, cgi, and a SQL server ;)
19:31:10 <dons> stepcut: yeah, but happs got out of control big.
19:31:23 <dons> but apache and (fast)cgi are ubiquitous anyway
19:31:33 <stepcut> hehe
19:31:53 <dons> so if we just concentrate on the url scheme for arguments (like GetOpt) and dispatch to chunks of pure haskell with nice db integration, haskell ftw!
19:32:00 <mrd> bparkis: in general, scanning, with some monoid, can be done in O(log n) depth
19:32:03 <dons> i'd love to toss little code into standalone webapps
19:32:16 <dons> we're getting there.
19:32:36 <dagit|lispy> just use arc ;)
19:32:57 <ddarius> bparkis: You probably want to look at APL/J/K.
19:33:06 <sclv> cabal install takusen just failed. :-(. I think I need cpphs.
19:33:15 <dons> sclv: nope. it shouldn't. how did it fail?
19:33:21 <dons> it requires cabal 1.2.3
19:33:22 <dagit|lispy> dons, but don't you want some of the nice features of things like flapjax?  With the closures and continuations under the hood?
19:33:37 <sclv> OdbcFunctions.hsc:17:0:  error: parse error before ')' token
19:33:38 <sclv> OdbcFunctions.hsc: In function 'main':
19:33:38 <sclv> OdbcFunctions.hsc:834:0:  error: parse error before ';' token
19:33:40 <sclv> etc.
19:33:41 <dons> dagit|lispy: sure. nice things are nice. but we're still at "let's just get something" stage
19:33:47 <dons> sclv: oh, its trying to use that backend.
19:33:53 <dons> sclv: i just build it for sqlite
19:34:26 <bparkis> ddarius: I have checked it out but not done much with it, but does it allow matrices with elements that are functions, and custom matrix multiplication?
19:34:47 <bparkis> or rather "Allow" isn't the word I'm looking for... does it _facilitate_ them?
19:35:57 <ddarius> bparkis: I haven't done much with any of them either, but I seriously doubt they don't have ideas analagous to yours well worked out.
19:35:58 <dons> timely, http://reddit.com/info/69738/comments/ "More web programming in Haskell: Service APIs for the Web [programming] (mult.ifario.us)"
19:36:08 <ddarius> I should actually look at J though.
19:36:38 <dons> it'd be fun to have an ffi binding to J
19:36:44 <dons> or a little EDSL, actually
19:36:48 <ddarius> dons: why... ?
19:37:01 <dons> fun/
19:37:34 <dons> who wouldn't love (($:@(<#[) , (=#[) , $:@(>#[)) ({~ ?@#)) ^: (1<#) ?
19:37:47 <dons> looks like pointfree, symvar only haskell :)
19:37:57 <gwern> interesting. hmp3 seems to generate incomplete sdist tarballs
19:38:00 * gwern fixes
19:38:03 <dolio> dagit|lispy: Does flapjax use continuations? I thought it was just functional reactive programming (only not, because FRP is a bad word :)).
19:39:20 <redleafgr> why is it a bad word?
19:39:47 <dolio> Well, when it was originally presented, the pitch was for ordinary human beings.
19:40:13 <dolio> So the presenter made a big shtick about this not being functional programming, and therefore not scary.
19:40:19 <redleafgr> hahaha
19:41:07 <sclv> hmm.. so how do I get takusen to build with only sqllite?
19:41:44 <dons> sclv: it has a scary crazy Setup.hs
19:41:49 <sclv> ah. super weird. it works fine from source, just not from cabal install...
19:42:13 <dons> yep
19:42:17 <sclv> the cabal file has the build type wrongly set to simple.
19:42:26 <dons> i think it tries to resolve the odbc dep, since it can see it on hackage
19:42:32 <dons> sclv: oh true.
19:42:40 <sclv> that's probably the issue.
19:43:49 <roconnor> I couldn't bring myself to code my password into my program.
19:44:07 <gwern> dons: I've sent you two patches that make hmp3 work for me and hackage, since the current one fails to cabal-install with errors about no binary instances
19:44:47 <dons> ok. that's curious
19:45:15 <dons> those patches don't seem related to the binary instances though?
19:45:26 <gwern> no, just for hackage and the sdist tarball issues
19:45:48 <dons> so likely it depends on a newer version of binary, perhaps
19:48:08 <bparkis> though I haven't seen any apl code with matrices whose elements are functions
19:48:18 <dons> gwern: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmp3-1.5.1
19:48:19 <lambdabot> http://tinyurl.com/2w9prs
19:48:54 <dons> build-type fails though
19:49:05 <dons> ah, needs configure pregenerated.
19:50:31 <gwern> so that's what the deprecated messages are about? 'warning: #warning config.h is deprecated; please use ghcconfig.h instead
19:50:41 <dons> yeah
19:51:34 <gwern> alright. other than that, cabal install seems to work (modulo the bytestring problem I keep running into, but I just have to edit the cabal file to specify bytestring == 0.9.0.1)
19:52:48 <dons> that's because you've got a bungled system, wrt. bytestring versions, i guess
19:53:19 <gwern> yeah, but I know that - it's not hmp3's fault
19:54:02 <ddarius> :t (>=>)
19:54:10 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:54:29 <ddarius> :t (<=<)
19:54:30 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
19:55:52 <ddarius> bparkis: I believe if you work with functions of the form a -> [b] (i.e arrows of the Kleisli category of []) you can get a ring with (*) = (<=<) and f+g = \x -> f x ++ g x.  You can then talk about modules.
19:59:03 <ddarius> Well not quite as (+) is not commutative.
20:01:15 <u_quark> @check  (Show a3, Show a2, Show a1, Show a) => a -> a1 -> a2 -> a3 -> [Char]
20:01:16 <lambdabot>  Parse error at "=>" (column 37)
20:05:15 <bparkis> though the way I'm conceiving it you can multiply two matrices without their values being the same type, i.e. multiply a matrix of functions by a matrix of integers
20:10:40 --- mode: irc.freenode.net set +o ChanServ
20:10:52 <dmwit> Bye bye, niven!
20:10:53 <u_quark> ic...
20:10:53 <u_quark> :S
20:10:54 <elaforge> is there a good introduction to rank-n out there?
20:10:54 <elaforge> I have
20:10:54 <elaforge> f :: (forall a. a->b) -> (b, b)
20:10:54 <elaforge> f g = (g 1, g 'a')
20:10:54 <elaforge> but I can't pass it 'id'
20:10:56 <JohnMeacham> hello
20:10:56 <dmwit> elaforge: "id" doesn't match that type signature.
20:11:04 <dmwit> elaforge: Maybe you want (const 10) or something like that?
20:11:23 <elaforge> but id is a->a, it should be passed polymorphically, right?
20:11:35 <dmwit> elaforge: You need to end with a tuple of two things with the same type...
20:11:37 <elaforge> I was just guessing with the forall a. a->b stuff though
20:12:06 <elaforge> oh, so in a->b it's the *same* b
20:12:19 <dmwit> elaforge: "forall a. a -> b" means the function you pass in has to be able to give a 'b' value for *any* input at all of any type.
20:12:37 <dmwit> elaforge: Well, at least in the tuple (b, b) it's the same b. =)
20:12:54 <wagle_home> > let id' x = x ; f g = (g 1, g 'a') in f id'
20:12:54 <dmwit> elaforge: (And yes, without a "forall b." clause, it's the same b inside there, too.)
20:13:09 <lambdabot>  thread killed
20:13:11 <dmwit> wagle_home: The rub is in the type signature.
20:13:21 <wagle_home> > let id' x = x ; f g = (g 1, g 'a') in f id'
20:13:21 <lambdabot>   add an instance declaration for (Num Char)
20:13:31 <elaforge> but forall a b. a->b has a different problem
20:13:42 <dmwit> elaforge: It sure does!
20:13:55 <elaforge> I think the real problem is that I don't fully understand the foralls
20:14:52 <dmwit> I don't know of any real introductions to this, sorry.
20:15:08 <dmwit> (I only know what I know through osmosis, really.)
20:15:30 <dmwit> Well, maybe diffusion.  Unless we have instance Water Knowledge. =)
20:15:36 <elaforge> so my impression from the ghc docs is that it lets you pass a polymorphic function
20:16:43 <dmwit> elaforge: What is it you are trying to do?
20:16:57 <dmwit> ("Understand rank-n types" is a perfectly acceptable answer... =)
20:16:58 <u_quark> dmwit: ghc infers  the right type forall a. (Show a) => a -> String but seas it's illegal  `Illegal polymorphic or qualified type: forall a. ...`
20:17:21 <u_quark> says*
20:17:55 <elaforge> at the high level, hand back a function that takes actions, runs them in another thread, and returns the results, like (IO a -> IO b)
20:18:14 <elaforge> but I want that function to remain polymorphic, and not settle on a particular a and b
20:18:21 <mrd> elaforge: the first thing to understand is that an "unbound" type-variable is captured by a forall which is inserted at the beginning by GHC
20:18:32 <elaforge> right, I've read that
20:18:33 <dmwit> u_quark: Works here, do you have -fglasgow-exts on?
20:19:05 <elaforge> it's only rank >1 if you stick it in parens not at the leftmost position
20:19:13 <mrd> elaforge: the second important rule of thumb is that: forall a. a -> forall b. b can be transformed into forall a b. a -> b; but that is not the case for forall a. (forall b. b) -> a
20:19:31 <mrd> ok i think you got that
20:20:07 <u_quark> dmwit: nop... do i need something like -XRankNTypes ?
20:20:11 <elaforge> so the first says "polymorphic function from something to something else" and the second is, umm...
20:20:26 <dmwit> u_quark: Yes, you need some flag.  (I'm not sure which one.)
20:20:36 <u_quark> ok...
20:20:50 <elaforge> my ghc suggests -XTypeOperators
20:21:06 <roconnor> is there an existing function for "either (fail . show) return"
20:21:14 <dmwit> u_quark: Sorry, but I'm on ghc 6.6, which has a different flag set.
20:21:30 <dmwit> :t left
20:21:32 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
20:21:47 <dmwit> :t left (fail . show)
20:21:48 <lambdabot> forall (m :: * -> *) a a1 d. (Show a1, Monad m) => Either a1 d -> Either (m a) d
20:21:53 <elaforge> mrd, so what do those two examples mean actually?
20:21:55 <dmwit> Not really, huh?
20:22:40 <roconnor> @type either (fail . show) return
20:22:41 <lambdabot> forall (m :: * -> *) a a1. (Show a1, Monad m) => Either a1 a -> m a
20:22:56 <mrd> elaforge: another important intuition to have is that you don't know anything about "just" a type-variable besides what comes before the ->
20:23:04 <u_quark> seams to work ... tnx dmwit
20:23:19 <mrd> elaforge: so you can immediately know that there is only one "thing" of type forall a. a
20:23:57 <mrd> elaforge: care to guess?
20:24:28 <roconnor> @seen bjorn
20:24:29 <lambdabot> I haven't seen bjorn.
20:25:12 <Mr_Awesome> bjorn? who's bjorn?
20:25:17 <sclv> :t fmap (listToMaybe . catMaybes) <$> (fmap sequence <$> sequence <$> sequence xs) p
20:25:18 <lambdabot> Not in scope: `xs'
20:25:18 <lambdabot> Not in scope: `p'
20:25:25 <sclv> :t \xs p -> fmap (listToMaybe . catMaybes) <$> (fmap sequence <$> sequence <$> sequence xs) p
20:25:27 <lambdabot> forall a (m :: * -> *) (m1 :: * -> *) t. (Functor ((->) t), Monad ((->) t), Monad m1, Functor m1, Monad m, Functor m) => [t -> m1 (m (Maybe a))] -> t -> m1 (m (Maybe a))
20:25:33 <sclv> How do I write this without being ugly?
20:25:36 <roconnor> Bjorn Bringert
20:25:46 <Mr_Awesome> sclv: get a makeover?
20:25:47 <sclv> I suspect that it's deeparrow or nothing...
20:25:48 <ddarius> @seen bringert
20:25:48 <lambdabot> I saw bringert leaving #ghc and #haskell 6h 7m 5s ago, and .
20:26:06 <dmwit> sclv: Well, to start with, listToMaybe . catMaybes = msum.
20:26:25 <sclv> :t \xs p -> fmap msum <$> (fmap sequence <$> sequence <$> sequence xs) p
20:26:26 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) (m2 :: * -> *) t. (Functor ((->) t), Monad ((->) t), Monad m2, Functor m2, Monad m1, Functor m1, MonadPlus m) => [t -> m2 (m1 (m a))] -> t -> m2 (m1 (m a))
20:26:34 <oerjan> @check \l -> listToMaybe (catMaybes l) == msum l
20:26:36 <lambdabot>  Add a type signature
20:26:37 <sclv> ok that's a help.
20:26:48 <oerjan> @check \l -> listToMaybe (catMaybes l) == msum (l::[Maybe Int])
20:26:50 <lambdabot>  OK, passed 500 tests.
20:26:57 <oerjan> sclv: ^^
20:27:00 <dons> oerjan++
20:27:12 <dons> rewrite rules in your head, man!
20:27:16 <roconnor> @tell bringert why isn't ConnError an instance of Error?
20:27:16 <lambdabot> Consider it noted.
20:27:25 <sclv> seriously. excellent catch.
20:27:25 <oerjan> oh you already found that
20:27:28 <dmwit> :t ($)
20:27:28 <lambdabot> forall a b. (a -> b) -> a -> b
20:27:32 <dmwit> :t (<$>)
20:27:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:27:37 <roconnor> @src Error
20:27:38 <lambdabot> class Error a where
20:27:38 <lambdabot>     noMsg  :: a
20:27:38 <lambdabot>     strMsg :: String -> a
20:27:58 <sclv> I'm just doing a whole bunch of sequences fmapped into more sequences though and its getting confusing...
20:28:03 <sclv> not sure how to avoid it however.
20:28:05 <elaforge> mrd, um, bottom?
20:28:16 <dmwit> sclv: You've got some deeply nested monads/functors there... have you considered using a monad transformer stack?
20:28:27 <sclv> they're all reader. :-)
20:28:30 <ddarius> sclv: Use newtypes.
20:28:43 <mrd> elaforge: good =)
20:28:58 <ddarius> bottom is always a safe answer
20:29:09 <mrd> not in a strongly normalizing language!
20:29:11 <elaforge> mrd, that would mean that "forall a. (forall b. b) -> a" can only be satisfied by const?
20:29:19 <mrd> elaforge: pretty much
20:29:19 <ddarius> Which Haskell is not.
20:29:23 <elaforge> since it takes bottom to anything
20:29:34 <mrd> a lazy const
20:29:36 <dmwit> elaforge: That's why I suggested (const 10), incidentally.
20:29:59 <ddarius> const, seq, or bottom
20:30:00 <elaforge> whereas forall a b. a -> b is satisfied by any function whatsoever
20:30:17 <sclv> hmmm... looks like monoids to the rescue again!
20:30:28 <mrd> no
20:30:31 <ddarius> elaforge: There are only two "functions" of that type.
20:30:40 <sclv> wrap the functions in a First, and use mconcat and I should be golden!
20:30:50 <elaforge> ddarius, is id one?
20:30:54 <ddarius> No
20:31:03 <dmwit> ?djinn a -> b
20:31:05 <lambdabot> -- f cannot be realized.
20:31:13 <elaforge> oh right, b has to be *any* type
20:31:15 <ddarius> Think about what that type says.  Even if you just "read" it aloud.
20:31:21 <elaforge> so that's just like a->b which is a cast
20:31:22 <dmwit> elaforge: exactly
20:31:40 <mrd> indeed, no restrictions.  which in a strange twist, limits the possible implementations of that type.
20:32:11 <elaforge> I seem to recall the state thread paper had a motivation and examples for rank2
20:32:16 <elaforge> but I didn't fully understand it
20:32:27 <ddarius> :t runST
20:32:30 <lambdabot> Not in scope: `runST'
20:32:49 <elaforge> is there anything out there with simple examples and uses for them?
20:33:00 <mrd> existential types
20:33:35 <mrd> they are representable with a rank2 type: forall a. (forall b. b -> a) -> a -- er did I screw that up?
20:33:41 <elaforge> really I just want to see if I can type my program, but understanding rank-n better would be a nice side-effect
20:33:48 <ddarius> mrd: That's right.
20:34:15 <ddarius> mrd: Just remember: (forall a. F a) -> B  ~> exists a. F a -> B
20:34:21 <mrd> yea
20:35:10 <bparkis> fast matrix multiplication depends on special properties of + and *, though, so you wouldn't get a performance benefit with a "general" multiplication unless your functions could be verified to have the same properties
20:35:29 <mrd> bparkis: associativity and having identity
20:35:30 <ddarius> bparkis: Hence me aiming for module theory and rings.
20:36:09 <elaforge> ddarius, wouldn't "length" have that type?  since it takes [a] -> Int
20:36:15 <ddarius> (Well, not so much for performance, but to better relate to well-explored fields.)
20:36:59 <mrd> elaforge: no, length :: [a] -> Int
20:37:08 <mrd> length /:: a -> b
20:38:00 <mrd> remember, in "forall a b. a -> b", you don't know anything about a or b
20:38:08 <ddarius> elaforge: Have what type?
20:38:20 <elaforge> well yeah, but if "(forall a. F a) -> B" is a polymorphic function that takes an F of some type to a specific type B, isn't that satisfied by [] a -> Int?
20:38:34 <elaforge> I'm trying to figure out what functions would have that type
20:38:42 <mrd> forall a. ([a] -> Int)
20:39:01 <mrd> note the parens
20:39:10 <elaforge> right, that's what :t length would tell me
20:39:41 <mrd> remember my point #2: you can't lift an inner forall that appears as antecedent to ->
20:40:05 <elaforge> ok.. then who does have that type?
20:40:56 <ddarius> If you had a function  f :: forall a b. (a -> b) -> Int, it would have to accept length as well, but length doesn't provide a value of type forall a b. a -> b
20:40:57 <mrd> a type like "(forall a. F a) -> B" for some F and B?  with the existential type extension you can create such things
20:42:05 <mrd> usually used for some kind of modularity
20:42:19 <mrd> if you read TAPL you'll find existential types presented as the basis of module systems
20:42:41 <elaforge> ha, so I finally got something that worked:
20:42:41 <elaforge> f :: (forall a. [a] -> Int) -> (Int, Int)
20:42:41 <elaforge> f g = (g [1], g ['a'])
20:42:49 <elaforge> I can pass length, and it remains polymorphic
20:42:52 <thoughtp1lice> i remember having issues with existentials in this manner; if you treat them wrong, you will get a very unhappy error from ghc saying something like 'type is less polymorphic than expected'
20:43:07 <elaforge> thoughtp1lice, yeah I've been seeing a lot of those lately
20:43:41 <elaforge> interestingly, I have to put (forall a. [a]->Int), forall a. a->Int doesn't typecheck
20:43:48 <thoughtp1lice> it's not really a hard error, it just took a little thought to get around. i almost resorted to something like oleg hackery but it turned out to be unnecessary.
20:43:50 <mrd> it might make a bit more sense if you understand that type-inference is inserting "type-lambdas" and "type-applications" where appropriate
20:43:57 <elaforge> well, doesn't let length in
20:44:02 <mrd> a "type-lambda" is a term which has polymorphic type "forall..."
20:44:31 <dmwit> > let a + b c = sum [a, b, c] in 3 + 4 $ 5
20:44:31 <elaforge> thoughtp1lice, I don't actualy understand what it means
20:44:31 <lambdabot>  Parse error in pattern at "in" (column 29)
20:44:53 <elaforge> that you passed a non-polymorphic function to something expecting a polymorphic one?
20:45:39 <thoughtp1lice> elaforge: it means basically what it says. you are basically treating something of that polymorphic type as if it has a more 'concrete' type, but the purpose of something like rankN and whatnot is that you can pass polymorphic functions to other functions, hence, they need to stay polymorphic.
20:46:21 <elaforge> so by e.g. applying it to concrete arguments you are requiring a specific type of it?
20:46:22 <thoughtp1lice> if you treat them in a manner that gives them a 'concrete' type, you'll get an error because, well, the purpose of the forall and quantification is to *show* they're polymorphic; you don't know anything about them.
20:47:00 <ddarius> thoughtp1lice: There are levels of polymorphism without actually hitting concrete types.
20:47:52 <thoughtp1lice> ddarius: and that's about as far as my knowledge on the subject goes (i need to finish tapl.)
20:48:23 <bparkis> can matrices of dimension more than 2 be multiplied in any standard way?
20:48:32 <elaforge> so back to my broken attempt:
20:48:33 <elaforge> f2 :: (forall a. a->b) -> (b, b)
20:48:33 <elaforge> f2 g = (g 1, g 'a')
20:48:36 <elaforge> gives that error
20:48:37 <ddarius> bparkis: Those would be tensors.
20:48:38 <mrd> reading up about the polymorphic lambda calculus will really help.  it's extraordinarily simple, especially since there's no pesky type inference, and it will make you think about when you introduce type abstraction.
20:48:45 <elaforge> err, supplying 'id' gives the error, I mean
20:49:04 <thoughtp1lice> in my case the error cropped up because I was using existentials to hide data constructors in a list, and when I enumerated the list I hit a few of those errors, so really all i'm just going off experience.
20:49:17 <loupgaroublond> bos, ping
20:49:19 <ddarius> Indeed.  It all comes down to scoping.
20:49:19 <elaforge> mrd, this smells like a rabbit hole, but got any recommendations on what to read?
20:49:28 <bparkis> ok
20:49:31 <mrd> TAPL
20:49:39 <thoughtp1lice> elaforge: TAPL is a great read on the general subject of types.
20:49:43 <dmwit> Any nice way to print numbers as "32,000" rather than "32000"?
20:50:01 <mrd> I can't think of any online things offhand, though I'm sure they exist.
20:50:18 <thoughtp1lice> it's a pretty approachable book, I would recommend you don't read too much into it the first time over though.
20:50:22 <elaforge> oh, big book.  will a non CS non mathematician understand this?
20:50:28 <loupgaroublond> does Distribution.PackageDescription.withLib ignore libraries in packages that have both executable and library sections, such as xmonad?
20:50:36 <mrd> yes it's pretty accessible
20:50:39 <thoughtp1lice> elaforge: i'm not even out of high school and I've gotten a lot out of it. i'm not a math wizard, either.
20:50:55 <mrd> we used it in undergrad, though admittedly, my prof was Pierce's advisor
20:50:56 <ddarius> elaforge: Why would the book being big make it less understandable?
20:51:04 <elaforge> thoughtp1lice, ok cool
20:51:08 <mrd> you can skip around a lot
20:51:20 <mrd> especially when he gets all Java-ey and dOOP-ey
20:51:39 <elaforge> ddarius, I didn't mean the "big" to be related to the "hard" part, just that this wasn't some 20-page paper
20:52:08 <ddarius> elaforge: That's how I took what you said.
20:52:36 <thoughtp1lice> i would say I learned more out of say, the first 8 chapters than most other CS books I've read.
20:52:48 <elaforge> ddarius, sorry my mistake
20:53:24 <elaforge> ok, thanks for the recommendation, I'll order this one
20:53:29 <ddarius> thoughtp1lice: You need to read better CS books.
20:53:29 * cjb just started reading it, and wouldn't call it approachable.  :)
20:53:37 <thoughtp1lice> elaforge: the only thing I've had a tough time with is some of the proofs he brings up but if you invest a little time into them and have a sketchpad or something open to work with them on a small scale, you should do pretty well.
20:53:53 <cjb> but maybe I'm, like, really dumb.
20:54:17 <thoughtp1lice> ddarius: granted my scope on that matter is pretty limited. recommendations?
20:55:23 <cjb> it would be nice if we had some sort of collaborative CS book review/rating site.
20:55:36 <ddarius> Some of the standard "good" CS books would be: SICP, CTM, CSP, the Dragon book (or the Tiger book nowadays).
20:55:41 <cjb> whereby nice I mean that if someone else did it, I'd probably think it was sort of cool.
20:56:03 <jeffz> ddarius: which one is the Tiger book?
20:56:17 <Mr_Awesome> yay SICP! :)
20:56:27 <thoughtp1lice> SICP is on a checklist. i'm not familiar with CTM or CSP?
20:56:29 <elaforge> sicp I've read, but it doesn't really say a lot about types, naturally :)
20:56:35 <loupgaroublond> bos, unping, i'm going to sleep
20:56:50 <ddarius> Modern Compiler Implementation in (ML/Java/C?)
20:56:50 <ddarius> Is it C?  I forget what the other one is.
20:56:55 <dmwit> > printf "%d" 3
20:56:58 <lambdabot>  Add a type signature
20:57:16 <ddarius> @google "Concepts, Techniques and Models of Computer Programs"
20:57:17 <lambdabot> http://www.turnofthecrank.com/2006/12/01/the-5-books-that-every-programmer-should-read/
20:57:17 <lambdabot> Title: Shane Sherman » Blog Archive » The 5 Books that Every Programmer Should Read
20:57:27 <dagit|lispy> why is the dragon book so highly recommended? I had that one and found it obtuse.
20:57:30 <yondalf> > printf "%d" 3 :: String
20:57:33 <lambdabot>  "3"
20:57:45 <elaforge> Concepts, Techniques, and Models of Computer Programming, a computer programming textbook <- this?
20:57:48 <ddarius> @google "Communicating Sequential Processes"
20:57:49 <lambdabot> http://www.usingcsp.com/
20:57:49 <lambdabot> Title: Communicating Sequential Processes (CSP), by C. A. R. Hoare (Electronic Version)
20:58:06 <dmwit> > let formatNumber :: Integer -> String; formatNumber = dropWhile (=='0') . concat . intersperse "," . map (printf "%03d") . reverse . map (`mod` 1000) . takeWhile (>0) . iterate . (`div` 1000) in formatNumber 4000000
20:58:10 <lambdabot>  Couldn't match expected type `a -> a'
20:58:14 <bos> loupgaroublond: just missed you
20:58:27 <dobblego> that looks like 5 books you should throw in the rubbish bin
20:58:32 <thoughtp1lice> ddarius: thanks. :) i'll be sure to read when I have time.
20:58:38 <dmwit> (Works here, but is way ugly.)
20:59:30 <dagit|lispy> dobblego, design patterns and pragmatic programer are both good books on that list.  I can't speak for the other 3.
20:59:44 <dobblego> dagit|lispy, design patterns is good toilet paper
20:59:50 <dobblego> the pages are thin
21:00:07 <dagit|lispy> my copy has thick pages.  Maybe we read different books.
21:00:09 <mrd> the dragon book is awful
21:00:23 <mrd> hmm, soft thick toilet paper
21:00:39 <stepcut> ?pl \f x -> fmap ((,) x) (f x)
21:00:39 <elaforge> I think I'm noticing a problem that a list of community recommended CS books would have
21:00:39 <lambdabot> liftM2 fmap (,)
21:00:48 * mrd chuckles
21:00:54 <dagit|lispy> I told a professor of mine that the dragon book was bad and I prefer "Modern Compiler Design" and they scoff at me.
21:01:32 <mrd> they are ancient people and the dragon book is ancient too
21:01:33 <blargeyfarg> the dragon book is theory heavy... makes sense
21:01:44 <mrd> it's mostly parsing
21:01:50 <stepcut> ?pl \f a -> sequenceA (fmap (\x -> fmap ((,) x) (f x)) a)
21:01:50 <lambdabot> (sequenceA .) . fmap . liftM2 fmap (,)
21:01:50 <mrd> parsing is so... 1950s
21:02:00 <dagit|lispy> yeah, there isn't enough code analysis in that book
21:02:01 <thoughtp1lice> mrd: angry much?
21:02:16 <mrd> thoughtp1lice: no?
21:02:29 <thoughtp1lice> mrd: that's just the tone i picked up.
21:02:40 <mrd> I wasn't aware you could hear tones on IRC
21:02:42 <dagit|lispy> at least Modern Compiler Design tells you how to write a Haskell compiler.
21:02:55 <mrd> we used Appel in our course, which was ok
21:03:15 <mrd> thoughtp1lice: but I think I am tone-deaf, if that makes any sense
21:03:38 <ddarius> Joe Armstrong's thesis is probably a decent addition as well as Guy Steele's.
21:03:42 <thoughtp1lice> mrd: fair enough.
21:03:53 <elaforge> so... before I get all involved in reading about type theory in general... can anyone who already understands it let me know if what I'm attempting is even possible?
21:03:57 <mrd> I bought myself a copy of ACD&I
21:04:44 <wli> dagit|lispy: I remember a very brief discussion of laziness in Appel's MCD.
21:04:46 <thoughtp1lice> elaforge: what're you attempting, and why wouldn't it be possible?
21:05:04 <elaforge> namely, a function that takes IO a, and drops (a, MVar b) on a channel, for another thread to execute, and then returns IO b
21:05:16 <ddarius> Reading about type theory is a good thing regardless.
21:05:22 <wli> dagit|lispy: Far too vague to help compile Haskell.
21:05:43 <mrd> elaforge: what's b?
21:05:57 <elaforge> whatever the IO operation returns
21:06:06 <elaforge> so for (putStr "hi") it will be ()
21:06:07 <mrd> isn't that a?
21:06:20 <elaforge> oh wait, yeah right
21:06:45 <elaforge> no wait, I was right
21:06:57 <mrd> wli: he does discuss, at least, implementation techniques for proper lexical scoping.  unless my memory has really failed.  that's more than most books.
21:07:04 <elaforge> e.g. 'execute_somewhere_else $ putStr "hi"'
21:07:27 <elaforge> execute takes IO () -> IO ()
21:07:56 <elaforge> or 'line <- execute $ getLine', now it takes IO () -> IO String
21:08:16 <mrd> :t getLine
21:08:19 <lambdabot> IO String
21:08:24 <wagle_home> i saw that there was a new edition of the dragon book out..  was shrink wrapped, so i didnt look inside
21:08:27 <mrd> execute :: IO a -> IO a
21:08:41 <dagit|lispy> wli: I found the chapter on desugaring to be quite helpful, but I admit, I didn't check further to see if they talk about doing DM type inference
21:08:44 <elaforge> oh yeah, you're right
21:08:57 <mrd> :t forkIO
21:08:58 <lambdabot> Not in scope: `forkIO'
21:09:00 <elaforge> that's actually what I'm using :/
21:09:11 <mrd> forkIO :: IO () -> IO ThreadID, I think
21:09:45 <elaforge> the problem is that as soon as I use it for e.g. execute $ putStr "hi", 'a' becomes () and I can't follow with execute $ getLine
21:10:47 <mrd> sure you can
21:10:51 <dmwit> > 2^(length "UUUUUULLULULLLULL")
21:10:54 <lambdabot>  131072
21:11:41 <elaforge> but this function is using channels, so it's bound with 'execute <- initialize'
21:12:09 <elaforge> where 'initialize' does a forkOS and sets up a channel to it
21:12:14 <oerjan> > let b 'U' = 1; b 'L' = 0 in readInt 2 (const True) b "UUUUUULLULULLLULL"
21:12:16 <lambdabot>  [(129348,"")]
21:12:25 <mrd> initialize :: IO (IO a -> IO a) ?
21:12:30 <elaforge> yeah
21:12:34 <wy> Has anyone compared speed of generated code from scheme compilers and Haskell compilers?
21:12:59 <oerjan> @where shootout
21:13:00 <lambdabot> http://shootout.alioth.debian.org/
21:13:04 <oerjan> wy: ^^
21:13:37 <elaforge> since this would amount to having a heterogeneous channel, I'm thinking it may never work
21:13:49 <mrd> ok, so you want IO (forall a. IO a -> IO a)
21:13:55 <elaforge> yeah, I tried that, here's the error
21:14:02 <mrd> yea I don't think that'd work
21:14:14 <dagit|lispy> haskell is predicative, right? so that won't work in place of a monotype :(
21:14:30 <mrd> it doesn't have to be predicative
21:14:45 <wy> oerjan: there is no Stalin or Chez
21:14:56 <dons> wy, only the shootout. dynamic type checks cost a little, over static type erasure?
21:14:59 <mrd> wy: wouldn't SML be a better comparison anyhow?
21:15:09 <elaforge>     Couldn't match expected type `forall a. IO a -> IO a'
21:15:09 <elaforge>            against inferred type `m a -> m a'
21:15:09 <elaforge>       Expected type: IO (forall a1. IO a1 -> IO a1)
21:15:09 <elaforge>       Inferred type: IO (m a -> m a)
21:15:16 <wagle_home> good thing they didnt use a real scheme compiler like chez scheme
21:15:34 <wy> wagle_home: why?
21:15:48 <dmwit> Does foldl' have to calculate its entire list before it starts calculating?  I guess it does, huh... =/
21:16:00 <dagit|lispy> elaforge, may I see more of your code?
21:16:07 <wagle_home> wy: it would have provided some serious competition
21:16:16 <dons> how do you know, wagle_home ?
21:16:16 <oerjan> dmwit: not before it starts calculating, but before it produces any result
21:16:26 <mrd> elaforge: i might try writing a datatype with existential type, I suppose
21:16:28 <dmwit> oerjan: Okay, yes.
21:16:47 <wy> wagle_home: Do you mean Chez is fast?
21:16:49 <dmwit> oerjan: Er, wait, that doesn't answer my question.
21:16:55 <wagle_home> yes, it is fast
21:17:02 <elaforge> dagit|lispy, sure... I have a toy example that has one error, and then the real code that oddly gets another error
21:17:07 <mrd> ?paste
21:17:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:17:11 <wy> wagle_home: I don't know anybody who has a complete Chez compiler. It's commercial
21:17:16 <dmwit> oerjan: Let me rephrase: foldl' is hell on the garbage-collector, huh?
21:17:18 <dmwit> =P
21:17:31 <dagit|lispy> wagle_home, well, I can assure you SBCL is very fast, and last time I looked at the shootout, GHC was faster.
21:17:41 <dons> dmwit: no?
21:17:51 <hpaste>  blargeyfarg pasted "possible executeSomewhereElse implementation" at http://hpaste.org/5745
21:17:54 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5746
21:17:55 <dmwit> no?
21:18:03 <oerjan> dmwit: foldl' is a "good consumer", the list may be optimized away
21:18:06 <elaforge> that was me, posting the short example
21:18:18 <dmwit> hmmm... something else must be going on, then.
21:18:22 <elaforge> I guess I don't know how to log in
21:18:33 <dons> oerjan: thought it won't fuse.
21:18:38 <wagle_home> yeah..  i went through several scheme implemetations before i finally used petite chez scheme and it was the only one that worked
21:18:40 <dons> (under build/foldr)
21:18:46 <hpaste>  stepcut pasted "is there a better way to write mapTA?" at http://hpaste.org/5747
21:18:52 <dmwit> elaforge: You don't log in, just stick your name in the dialog box at the bottom.  (In the future.)
21:18:53 <radetsky> I'm having some module issues I could use some help diagnosing
21:18:54 <wagle_home> i just have confidence in kent
21:18:57 <oerjan> dons: it isn't?
21:19:02 <elaforge> dmwit, ok thanks, will do
21:19:08 <dons> oerjan: foldl' won't fuse, nor any left fold.
21:19:19 <radetsky> I have module M which contains "data Option = X | Y | Z"
21:19:21 <dons> that's one of the main things stream fusion addresses
21:19:35 <dmwit> It's okay, I think I can massage this into a right-fold.
21:19:47 <radetsky> in another module, I do "Import M (Option)" and use Y
21:19:57 <dmwit> Oh, wait, that's not really better for really long lists where we need every element.
21:19:58 <dmwit> hmm
21:20:01 <oerjan> dons: sheesh
21:20:10 <elaforge> in the real code, I get
21:20:10 <elaforge>     Inferred type is less polymorphic than expected
21:20:11 <radetsky> but I still get a "not in scope: data constructor Y" error
21:20:12 <elaforge>       Quantified type variable `a' is mentioned in the environment:
21:20:12 <elaforge>         act_chan :: STM.TChan (IO a, MVar.MVar a)
21:20:12 <elaforge>           (bound at Interface/Ui.hs:19:4)
21:20:15 <oerjan> ic
21:20:28 <radetsky> amidoinitrite?
21:20:31 <elaforge> I'm guessing this is the chan refusing to be polymorphic?
21:20:41 <dmwit> radetsky: import M (Option(..)) -- ?
21:20:53 <dagit|lispy> elaforge, that error message is really confusing :(
21:21:09 <radetsky> dmwit: literally that, or "import M (Option(Y))"?
21:21:21 <wy> Clean seems to be quite fast
21:21:28 <dmwit> radetsky: (Y) to import the Y constructor, or (..) to import all constructors.
21:21:34 <elaforge> dagit|lispy, so is my guess right, or are you confused too?
21:21:39 <radetsky> awesome, thanks
21:22:07 <dagit|lispy> elaforge, remove the $ on this line: tf = return $ (\op -> op >> op)
21:22:09 <wy> wagle_home: Kent is a distinguished engineer :)
21:22:19 <dagit|lispy> elaforge, ($) could be causing suprious type check errors
21:22:24 <dagit|lispy> and it's not needed
21:22:50 <elaforge> dagit|lispy, oh right, left over from previous code.  unfortunately it's the same errror
21:22:51 <dmwit> :t join (>>)
21:22:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
21:23:16 <mrd> it's $
21:23:22 <mrd> yea, can't use that with rank-2 types
21:23:59 <radetsky> by the way, as a style issue, do folks think it's a good idea to import only exactly what's used from a module, rather than everything?
21:24:09 <elaforge> radetsky, I like import qualified
21:24:19 <wagle_home> wy, haha.. where does it say that?
21:24:34 <wy> wagle_home: ACM
21:24:37 <dagit|lispy> elaforge, I think this line is erroneous: tf (print "hi" >> return "hi")
21:24:41 <dmwit> radetsky: I think it's fine to import everything until you run into ambiguity problems.
21:24:50 <dagit|lispy> elaforge, tf is a value not a function
21:24:52 <radetsky> elaforge: I mean if you write a module M with a bunch of functions, but only use foo, should you do "import M (foo)" or "import M"
21:24:53 <radetsky> ?
21:24:58 <mrd> dagit|lispy: yea that's a typo
21:25:05 <wy> wagle_home: I'm quite sure they have been using partial evaluation for a long time
21:25:17 <elaforge> dagit|lispy, *sigh* you're right, dumb typo
21:25:23 <mrd> elaforge: avoid using ($) when dealing with rank-2 types
21:25:25 <elaforge> thanks, now it works :)
21:25:31 <radetsky> My thinking was that restricting your imports to only what's actually used has the side effect of documenting where everything comes from
21:25:35 <dagit|lispy> elaforge, taht example works now?
21:25:42 <elaforge> dagit|lispy, indeed it does
21:25:46 <dagit|lispy> elaforge, cool!
21:25:57 <elaforge> mrd, because ($), being rank-1, "collapses" the polymorphic functions?
21:25:57 <dagit|lispy> elaforge, now back to the real example?
21:25:59 <radetsky> if I look at a source file, I'm not thinking "what is all this shit?" but "okay, this is here, that's there..."
21:26:07 <mrd> elaforge: no..
21:26:10 <radetsky> so I know where to look to figure out what everything's doing
21:26:11 <oerjan> stepcut: maybe traverse fits better than sequenceA?
21:26:14 <wagle_home> wy, oh cool
21:26:20 <oerjan> :t Data.Traversable.sequenceA
21:26:21 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Traversable.Traversable t) => t (f a) -> f (t a)
21:26:24 <mrd> :t ($)
21:26:25 <lambdabot> forall a b. (a -> b) -> a -> b
21:26:27 <oerjan> :t Data.Traversable.traverse
21:26:27 <dmwit> Wow, this problem is *really* cool!
21:26:28 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
21:26:35 <elaforge> dagit|lispy, yeah, so what it does is create a TChan and pass the IO action along it
21:26:42 <dmwit> http://fudge.fit.edu/Problems/View.aspx?id=76 # recommended
21:26:43 <lambdabot> Title: Fudge - Problem Statement
21:26:48 <radetsky> is this the sort of thing I should  be tracing with some sort of tool or documentation system, rather than putting it in the code?
21:26:50 <elaforge> I'll try making a toy example of tha
21:26:52 <adu> what was the project called that was a port of House to L4?
21:26:52 <mrd> elaforge: the problem is esoteric and has to do with GHC type internals
21:26:55 <dagit|lispy> elaforge, there is a paper written recently by some GHC devs that will help you understand why ($) doesn't work there.
21:27:12 <dagit|lispy> ?where spj
21:27:13 <lambdabot> I know nothing about spj.
21:27:17 <ddarius> mrd: It's just lack of impredacitivity.
21:27:22 <radetsky> (also, I'd assume it'd make compilation more efficient)
21:27:25 <mrd> elaforge: one of the simons actually got it to work with a hack, but it was decided to back that out sinceit was so ugly
21:27:28 <wy> wagle_home: I'm curious who is using Chez, and also languages like Miranda
21:27:36 * mrd can't remember the details
21:27:36 <radetsky> opinions?
21:27:53 <elaforge> mrd, huh... interesting.  what's the paper called?
21:28:07 <mrd> about impredicative instantiation?
21:28:10 <stepcut> oerjan: I give that a shot
21:28:23 <stepcut> s/I/I'll/
21:28:31 <elaforge> radetsky, using qualified names also does that, though with more typing
21:28:35 <ddarius> s/impredacitivity/impredicativity
21:28:36 <oerjan> stepcut: in fact traverse f = sequenceA . fmap f
21:29:10 <stepcut> oerjan: heh.
21:29:19 <mrd> http://research.microsoft.com/~simonpj/papers/higher-rank/
21:29:20 <lambdabot> Title: Simon Peyton Jones: papers
21:29:26 <mrd> is one
21:29:28 <dagit|lispy> thanks, mrd beat me to it
21:29:34 <dagit|lispy> that's the one I was going to recommend you read elaforge
21:29:35 <oerjan> @pl mapTA f a = traverse (\x -> fmap ((,) x) (f x)) a
21:29:35 <lambdabot> mapTA = traverse . liftM2 fmap (,)
21:29:40 <stepcut> oerjan: I think it's time for me to learn these new fangled modules
21:29:43 <oerjan> stepcut: yay :)
21:29:46 <dagit|lispy> I'm reading it now and it explains a lot just in the first 10 pages
21:30:02 <elaforge> ok, it's on the top of the stack
21:30:11 <elaforge> reading the paper, I mean
21:30:12 <wagle_home> wy, i dont have the proprietary compiler, though..  hm..  i have access to it (I'm from indiana)..  i used miranda once, long ago
21:30:22 <oerjan> :t traverse . liftM2 fmap (,)
21:30:23 <lambdabot> Not in scope: `traverse'
21:30:33 <dagit|lispy> elaforge, okay, then back to your toy example of what you really want to do
21:30:33 <oerjan> :t Data.Traversable.traverse . liftM2 fmap (,)
21:30:35 <lambdabot> forall (t :: * -> *) a (f :: * -> *) a1. (Applicative f, Data.Traversable.Traversable t) => (a1 -> f a) -> t a1 -> f (t (a1, a))
21:31:03 <wy> wagle_home: oh, you are from Indiana
21:31:10 <wy> wagle_home: I'm applying there
21:31:45 <wagle_home> good place
21:32:04 <wy> wagle_home: Did you get your PhD there?
21:32:24 <radetsky> elaforge: even if I do "import qualified ModuleWithLongName as M", I don't have to do M.foo
21:32:29 <radetsky> do I?
21:32:36 <wy> wagle_home: found your page :)
21:32:42 <mrd> radetsky: qualified requires the M.
21:32:45 <hpaste>  oerjan annotated "is there a better way to write mapTA?" with "simplified" at http://hpaste.org/5747#a1
21:32:46 <elaforge> radetsky, yeah you do
21:32:54 <wagle_home> MS.. havent applied to a phd program yet..  oh that old thing..  eww
21:33:19 <elaforge> radetsky, but it means that if I see "M.foo" in your code I can hit * on M to see where 'foo' comes from
21:34:04 <Cha1> wy, wagle: I went to Indiana...
21:34:08 <wy> wagle_home: Your page is interesting. How can a short MS program have so much content?
21:34:14 <Cha1> Math, though, no CS
21:34:28 <wy> Cha1: How do you like it?
21:34:44 <radetsky> elaforge: in what editor?
21:34:49 <Cha1> I was pretty happy, but I ended up doing much more applied stuff than I studied
21:34:50 <wagle_home> i had sortof a super masters
21:35:08 <wagle_home> "graduate student emeritus"  8)
21:35:23 <elaforge> radetsky, vim, that just searches for the next M, which will eventually be 'import ... as M' :)
21:35:32 <wy> Cha1: Do you mean you learned quite theoretical things there?
21:35:40 <wagle_home> (had a fling at switching to biology)
21:35:57 <Cha1> Yeah, I started in algebraic topology
21:36:01 <ddarius> wagle_home: Why didn't you?
21:36:12 <Cha1> category theory has helped with haskell, at least ;)
21:36:36 <mrd> radetsky: previous M
21:36:39 <mrd> er
21:36:41 <mrd> no that's #
21:36:45 <dmwit> ?pl \x -> digits !! x !! x
21:36:45 <lambdabot> (!!) =<< (digits !!)
21:36:46 * mrd always mixes that up
21:36:52 <radetsky> Cha1: does it really?
21:36:57 <wy> Cha1: topology is big
21:37:00 <wagle_home> ddarius, needed a solid foundation in molecular, which was about 3 years of one course at a time..  thought that was too long..  in hindsight, it wasnt
21:37:05 <radetsky> I have this pet hypothesis that it doesn't actually matter
21:37:22 <radetsky> except in the way that, say, knowing latin will make learning law easier
21:37:28 <mrd> my fingers know, my mind is lost
21:37:39 <Cha1> Well, having seen it helps, I think. Monads were still new to me - I hadn't made it that far in category theory
21:37:44 <wy> wagle_home: Do they have a program that has one course at a time?
21:38:11 <ddarius> radetsky: Knowing category theory may help, but it isn't necessary.
21:38:17 <radetsky> My guess is that even if you had, it wouldn't have made a difference
21:38:19 <Cha1> I agree, ddarius
21:38:25 <wy> Cha1: Did you take any course from Prof. Hofstadter?
21:38:31 <Cha1> No, just math
21:38:35 <wagle_home> they dont support getting second undergraduate degrees in biology..  but they wouldnt stop me from taking the courses anyway
21:38:48 <hpaste>  elaforge pasted "send actions to another thread" at http://hpaste.org/5748
21:38:55 <elaforge> dagit|lispy, ok, there we go
21:38:58 <radetsky> because you would have been familiar with, say, the monad laws, but using them to express stateful computations probably wouldn't have been covered in a math class
21:38:59 <Cha1> closest I got to CS was logic and set theory
21:39:22 <wy> wagle_home: What kind of biology course did you take?
21:39:28 <Cha1> Yeah, one of those things I wish I'd done. I was in too big a hurry
21:39:28 <elaforge> if I add:
21:39:32 <ddarius> Cha1: CS is applied logic
21:39:33 <elaforge> initialize :: IO (forall a. IO a -> IO a)
21:39:35 <elaforge> then I get the error
21:39:54 <wagle_home> wy, genetics, evolution, ecology, neural science
21:40:17 <radetsky> ddarius: I think that's kind of a stretch
21:40:24 <wy> wagle_home: Interesting. how do you like the classes?
21:40:48 <ddarius> radetsky: Look up the Curry Howard correspondence.
21:41:16 <dmwit> ?pl \bases -> zipWith f bases . inMixedBases bases
21:41:16 <lambdabot> ap ((.) . zipWith f) inMixedBases
21:41:19 <radetsky> ddarius: I am familiar with it
21:41:31 <dmwit> :t liftM2 (.) (zipWith f) (inMixedBases)
21:41:33 <lambdabot> Not in scope: `f'
21:41:33 <lambdabot> Not in scope: `inMixedBases'
21:41:34 <elaforge> dagit|lispy, so on one hand I don't expect to be able to create a polymorphic chan, but on the other hand, the receiver doesn't need to know the type of 'a', it just has to return it
21:41:39 <wagle_home> wy, liked them a lot..
21:41:44 <wy> ddarius: I guess there is something more than logic
21:41:58 <wagle_home> oh yeah, and developemental
21:42:04 <dagit|lispy> elaforge, hmm
21:42:06 <elaforge> so it seems like there should be some way to do this
21:42:14 <wy> wagle_home: What does developmental mean?
21:42:20 <dagit|lispy> Yeah, probably need a type
21:42:30 <elaforge> I thought of Data.Dynamic
21:42:38 <dagit|lispy> data Sealed = Seal (forall a. a)
21:42:44 <wagle_home> how organisms develop from conception to adult
21:43:03 <dagit|lispy> or sorry
21:43:11 <elaforge> and then the receiver can unpack it, run it, and pass the result back in another Seal?
21:43:18 <dagit|lispy> Yeah
21:43:22 <dagit|lispy> I think that's how it works
21:43:28 <elaforge> lemme try
21:43:50 <wy> wagle_home: Do you think we are all programmed by some superior being?
21:44:09 <dagit|lispy> elaforge, the hard part is is that, once it's Sealed, you can't know the type anymore
21:44:22 <elaforge> yeah, so I don't know how >>= will like that
21:44:23 <dagit|lispy> elaforge, so if you do something that depends on the type, you're SOL
21:45:24 <wagle_home> wy, no, but i had a biology postdoc (out of the blue) get pissed at me for supposedly thinking genetic codes were just programs (i guess because I was in CS)
21:45:46 <dagit|lispy> elaforge, I know you can get the type back with unsafeCoerce#, but that requires you to do the proof that the type is correct.  so you lose the type safety that you normally have for free.
21:46:19 <wy> wagle_home: hmm did he think genetic code is just like xml ;)
21:46:38 <elaforge> so I'm getting "Inferred type is less polymorphic than expected", but I'm not sure I'm doing this right
21:47:08 <dagit|lispy> elaforge, please annotate your paste with your new code, there is an "annotate" link
21:47:10 <hpaste>  blargeyfarg pasted "polymorphic executeSomewhereElse" at http://hpaste.org/5749
21:47:27 <wagle_home> dunno..  he stomped in, had his say, and stomped off, with a virtual "dont talk to me" sign written on his back
21:47:30 <blargeyfarg> it doesn't use STM, but extends my previous example to be polymorphic
21:47:58 <blargeyfarg> at least as an example. it resorts to a new type
21:47:58 <elaforge> blargeyfarg my use of STM there was gratuitous anyway, checking out your example...
21:48:11 <wy> wagle_home: haha. I guess I would like Indiana
21:48:45 <dmwit> ?index unfoldr
21:48:46 <lambdabot> Data.List
21:49:17 <oerjan> elaforge: it seems like you are bordering on static typing of client/server protocols...
21:49:20 <dagit|lispy> elaforge, I don't see anything wrong with blargeyfarg's version
21:49:53 <wagle_home> wy, i was the first cs student to hang around those parts..  i broke the ice though, i think, and there's much more interaction between the depts
21:49:55 <dagit|lispy> elaforge, Adding the Show type class constraint on 'a' is a really good idea.  You can add oters.
21:50:16 <elaforge> dagit|lispy, yeah it just ran, now I have to pick it apart to see why :)
21:50:30 <wy> wagle_home: Do you found the classes sort of teaching you fishing?
21:50:30 <elaforge> oerjan, sorta, in a simple kind of way
21:51:21 <elaforge> dagit|lispy, that would just make sure I can print out my actions, right?
21:51:31 <dagit|lispy> elaforge, yeah
21:51:53 <oerjan> elaforge: you cannot do that with a channel of fixed type, i think.  you need to pass back and forth channels (or MVars) whose types represent the current state of protocol.
21:52:06 <wagle_home> wy, what do you mean?
21:52:19 <dagit|lispy> elaforge, and you could make a type class Foo, that has all of the features you want to support defined or as constraints and then make T require that Foo.
21:52:37 <wy> wagle_home: Have you heard of the adage that "giving one fish is not as good as teaching one fishing"?
21:52:55 <wagle_home> sure
21:53:07 <elaforge> dagit|lispy, actually I eventually want to serialize the actions, and then I can write them to disk for a combination undo-queue and log-structured save file
21:53:16 <wy> wagle_home: so have you learned fishing there?
21:53:23 <oerjan> @where oleg
21:53:23 <lambdabot> http://okmij.org/ftp/
21:53:30 <wagle_home> is cs or in bio?
21:53:34 <dagit|lispy> Give a man a fire and you warm him for one day; set a man on fire and you keep him warm for the rest of his life.
21:53:39 <wagle_home> in cs or in bio?
21:53:41 <wy> oerjan: I'm curious what is oleg's job
21:53:51 <wy> wagle_home: both
21:54:15 <wy> I feel as if he is some sort of free soul
21:54:17 <dagit|lispy> (I prefer that adage ^^)
21:54:56 <dagit|lispy> elaforge, well you could certainly make a type class that has those two features and then make the types you want to pass around instances.  That sounds quite reasonable.
21:55:23 <wagle_home> cs, yes; bio, sorta (needed more)
21:55:29 <oerjan> hm nothing obvious show up, maybe Oleg wasn't the one...
21:55:48 <dagit|lispy> oerjan,what did you want?
21:55:57 <dagit|lispy> oerjan, you aren't suggesting HList are you?
21:56:07 <wy> dagit|lispy: lol :)
21:56:25 <oerjan> dagit|lispy: Oleg has done many things
21:56:38 <wy> wagle_home: gosh... I should have been there two years ago...
21:56:42 <dagit|lispy> oerjan, right, and he's clever!
21:56:57 <oerjan> dagit|lispy: i was thinking of static typing of client/server protocols
21:56:58 <wagle_home> wy, what would you be studying?
21:57:05 <oerjan> like elaforge seems to need
21:57:19 <ddarius> @google "session types"
21:57:20 <lambdabot> http://www.oracle.com/technology/products/ias/toplink/doc/1013/main/_html/sesun001.htm
21:57:20 <lambdabot> Title: Session Types
21:57:21 <wy> wagle_home: I got a fellowship at that time on cognitive science
21:57:33 <oerjan> ddarius: ah that rings a bell
21:57:53 <elaforge> I think my needs are simpler, since the "server" just passes the result of the action back with no interpretation
21:58:00 <wy> wagle_home: but I chose Cornell... sigh
21:58:20 <oerjan> ddarius: except surely that's not the link
21:58:29 <elaforge> it's actually just to get around the single threaded caller that some guis require
21:58:31 <wagle_home> wy, and they are giving you fish?
21:58:50 <wy> wagle_home: They pour fish on me
21:59:35 <wagle_home> memorization?
21:59:59 <elaforge> blargeyfarg, so the reason your example works is that you only do "print" on the results and you've made 'a' into Show?
22:00:04 <wy> wagle_home: I have the impression as if scheme is quite ingrained in Indiana's course. Is this true?
22:00:20 <dagit|lispy> elaforge, yeah that's part of the magic
22:00:24 <elaforge> blargeyfarg, so if I wanted to print (result+1) for the first result, I'd be out of luck?
22:00:28 <blargeyfarg> correct.  i've only guaranteed that the class is showable.  nothing else
22:00:38 <wy> wagle_home: lot much ideas from classes, but have to deal with much harder homework, day and night...
22:00:38 <oerjan> http://www.informatik.uni-freiburg.de/~neubauer/papers/padl04.pdf is relevant
22:00:47 <blargeyfarg> one could be more or less general
22:00:50 <dagit|lispy> elaforge, then you'd make it (Show a, Num a) =>
22:00:53 <elaforge> blargeyfarg, hrm, I guess I could put all my actions into a giant UI typeclass...
22:00:58 <dmwit> Is intercalate in Data.List for GHC 6.8?
22:01:01 <mrd> give a man a fire and you warm him for one day; point a man to oleg's web site, and he will create fire for himself -- in the type system
22:01:18 <oerjan> but maybe too heavy
22:01:19 <elaforge> mrd, I think his brain will catch on fire and he'll die
22:01:35 <dagit|lispy> ?remember mrd give a man a fire and you warm him for one day; point a man to oleg's web site, and he will create fire for himself -- in the type system
22:01:36 <lambdabot> It is forever etched in my memory.
22:02:14 <wagle_home> wy, yeah, but don't let the haskell people fool you, the scheme you learn is more interesting that they know... (though i think haskell's type system is pretty darned cool)..  but i dunno..  havent been there for ten years
22:02:44 <elaforge> blargeyfarg, so there's no way to do this without a typeclass explicitly specifying the operations?
22:02:54 <wagle_home> wy, fellowship under who?
22:03:03 <dagit|lispy> elaforge, there is, one other way I know of
22:03:08 <dagit|lispy> elaforge, but it's not type safe
22:03:09 <kbateman> @pl \op (x,y) -> op x y
22:03:10 <lambdabot> (`ap` snd) . (. fst)
22:03:22 <elaforge> dagit|lispy, ah the unsafeCoerce it back?
22:03:31 <dagit|lispy> elaforge, yeah
22:03:34 <blargeyfarg> the most general class of types has no operations available, since you don't have any information to go on
22:03:39 <blargeyfarg> so yeah
22:04:03 <wy> wagle_home: I didn't mean that scheme is not good. On the contrary, I mean a cs department with scheme as the main language for many courses. That says something better about that department than those with Java ;)
22:04:17 <dagit|lispy> elaforge, when you read that paper mrd found for you on higher ranks, more of this will make sense.
22:04:19 <BMeph> mrd: "Give a man a match, and he''l be warm for a day. Set a man on fire, and he'll be warm for the rest of his life." ;)
22:04:35 <wy> wagle_home: under Prof. Hofstadter
22:04:36 <elaforge> ok, well I'll look at that, and unsafeCoerce, and some locking to let me call from multiple threads, and see which is most palatable
22:04:43 <elaforge> dagit|lispy, will do, thanks for the help!
22:04:50 <wagle_home> oh man..  why didnt you go?
22:04:59 <dagit|lispy> elaforge, good luck and you're welcome
22:05:05 <scottutd> can someone help me with what must be an elementary question?
22:05:07 <elaforge> blargeyfarg, much thanks also
22:05:24 <blargeyfarg> glad i could help.  best of luck
22:05:34 <dagit|lispy> scottutd, it's better to just ask, than ask if you can ask :)
22:05:37 <wagle_home> oh yeah, cornell
22:05:39 <dagit|lispy> scottutd, so what is the problem?
22:05:45 <gio123> hi all
22:06:16 <dmwit> Hmm, I can only seem to pass 22 of the test cases, despite the problem being very simple.
22:06:19 <dmwit> gio123: Hiya!
22:06:28 <scottutd> ok... say i have 4 types of things, which all have the same properties, but should be identified differently... ie. I want to take advantage of tagging, but use the same underlying representation
22:06:44 <gio123> in general if i have condition if X/=Y/=epsilon then a else b. if I take X and Y is epslilon what it output? if I take X and Y are both d then what?
22:06:53 <scottutd> so say data Innards = { a : int, b:  int->int } or something
22:06:55 <wy> wagle_home: I didn't know much about both of them, so...
22:07:09 <elaforge> scottutd, oh I just did something like this, using newtype + extended deriving
22:07:14 <gio123> in general if i have condition if X/=Y/=epsilon then a else b. if I take X and Y is epslilon what it output? if I take X and Y are both d then what?
22:07:27 <scottutd> I could do that by defining another type: data Stuff = Type1 Innards | Type2 Innards, etc
22:07:46 <wy> wagle_home: also about the rankings... now I understand what does the rankings mean...
22:07:52 * ddarius learned something new just now.
22:07:54 <scottutd> but then I have to construct using Type1 Innards <args>, where I'd much rather just use Type1 <args>
22:08:12 <dmwit> gio123: That condition won't be well typed unless epsilon :: Bool.
22:08:19 <scottutd> It'd be nice if the Type1... were subtypes too
22:08:20 <scottutd> any ideas?
22:08:24 <bobwhoops> Hi all, I'm trying to something like filter (0 < fst) [(1,2),...], but that doesn't work. Is there a way to do this without a lambda function?
22:08:39 <dagit|lispy> scottutd, sounds like you can use a type class for part of it
22:08:41 <dmwit> bobwhoops: filter ((0<) . fst)
22:08:43 <wy> wagle_home: and there were people tell me about how hard it was to find a job after graduation from Indiana, tornados, etc etc...
22:08:53 <bobwhoops> dmwit: aha, thank you
22:09:01 <dobblego> @pl \x -> 0 < fst -- bobwhoops
22:09:02 <lambdabot> const (0 < fst)
22:09:10 <wy> wagle_home: now I know the truth
22:09:13 <dmwit> ?pl \x -> 0 < fst x
22:09:13 <dobblego> @pl \x -> 0 < fst x -- bobwhoops
22:09:13 <lambdabot> (0 <) . fst
22:09:14 <lambdabot> (0 <) . fst
22:09:22 <scottutd> wy: what is the truth about what rankings mean?
22:09:26 <dagit|lispy> scottutd, are you familiar with type classes?
22:09:50 <wy> scottutd: They don't mean anything
22:10:06 <scottutd> dagit|lispy: no, could you elaborate (I had gotten up to speed on Haskell, but I left for a while)
22:10:31 <wy> scottutd: only that I feel higher ranked departments are doing things which can attract more money
22:10:35 <scottutd> wy: good to know... though I'd always heard the meaning came when you were trying for postdoc/position
22:10:37 <dagit|lispy> scottutd, are you familiar with interfaces in java?
22:10:48 <dmwit> > True /= True /= True
22:10:57 <lambdabot>      precedence parsing error
22:10:57 <lambdabot>         cannot mix `(/=)' [infix 4] and `(/=)' ...
22:11:00 <gio123> dmwit: actualy it is not haskel related question, so i am writing algorithm and whnt the case algorithm has to output let say b if both inputs is deference to epsilon
22:11:17 <wy> scottutd: And higher ranked departments also care about their students less I guess
22:11:35 <scottutd> dagit|lispy: Yes. And I think I know what you're talking about in Haskell, but I don't remember about the syntax... it involves => right?
22:11:45 <wy> scottutd: and they like advertisement better
22:12:05 <dagit|lispy> scottutd, yeah, like class MyFourProperties where ...
22:12:15 <dagit|lispy> scottutd, yeah, like class MyFourProperties a where ...
22:12:36 <scottutd> wy: I'm down here at University of Texas at Dallas... apparently we're working on being the MIT of the southwest, or something like that
22:12:37 <gio123> alg(X,Y,Z)---> b if X=/epsolon and Y/=epsilon
22:12:39 <dagit|lispy> then you do, instance MyFourPorperties Type1 where ...
22:12:52 <dons> welcome, scottutd
22:13:14 <dagit|lispy> scottutd, then you can define functions like, useProperty1 :: MyFourProperties a => a -> Int
22:13:15 <gio123> dons: hi
22:13:31 <dmwit> gio123: (&&) and (/=) do what you would expect.
22:13:31 <scottutd> dagit|lispy: Ah, you've got my memory jogged and my mind on track now, I think I can look up the rest. Thank you very much.
22:13:43 <radetsky> scottutd: I think Rice beat you to it
22:13:45 <dagit|lispy> scottutd, you're welcome :)
22:13:52 <elaforge> scottutd, if your Innards all have the same implementation and you just want type tagging, you could maybe put the ops in a typeclass, and then do 'newtype Type1 Innards deriving (InnardsClass)
22:14:23 <gio123> dmwit: isted of writing X/=lambda and Y/=lambda can u write more coherant form?
22:14:35 <wy> scottutd: MIT seems to have been going down in such areas like programming languages
22:14:46 <scottutd> elaforge: Is there a good tutorial or doc segment on newtype and type classes and related?
22:14:47 <dagit|lispy> scottutd, but, this won't totally solve your problem because type classes are like java's interfaces.  You can't put any data into a type class, only functions
22:15:08 <gio123> X/=lambda and Y/=lambda <==> X/=Y/=lambda ?
22:15:15 * dolio fails to figure out Agda's indexed monads.
22:15:17 <scottutd> dagit|lispy: I can always abstract that away with () -> type functions though right?
22:15:29 <dmwit> gio123: no
22:15:37 <dmwit> gio123: Well... yes.
22:15:50 <scottutd> wy: Doing my master's now trying to get into language-based security, so theres a pretty small field of places doing the research
22:16:00 <dmwit> gio123: liftM2 (&&) (x/=) (y/=) epsilon
22:16:08 <dagit|lispy> scottutd, basically yeah.  You could have getA :: MyFourProperties a => a -> A
22:16:10 <dmwit> gio123: But for readability, that is not recommended. =)
22:16:19 <gio123> which one?
22:16:21 <elaforge> scottutd, hrm, any introduction to haskell thing should introduce data, newtype, and type
22:16:30 <dejones> scottutd: at which university are you?
22:16:41 <scottutd> dejones: University of Texas at Dallas
22:16:58 <wy> scottutd: How do you compare Dallas and Austin?
22:17:00 <dejones> scottutd: cool.  I was just curious.  :)
22:17:02 <dagit|lispy> ah, hence the nick I guess :)
22:17:09 <scottutd> indeed
22:17:15 <elaforge> scottutd, but the deriving thing is a newish ghc extension, so you can find that described in the ghc doc
22:17:28 <dejones> scottutd: I'm learning Haskell right now too, and I found this tutorial very helpful, YAHT: http://en.wikibooks.org/wiki/Haskell/YAHT/
22:17:29 <lambdabot> Title: Haskell/YAHT/ - Wikibooks, collection of open-content textbooks
22:17:39 <dmwit> > (length "x /= epsilon && y /= epsilon", length "liftM2 (&&) (x/=) (y/=) epsilon")
22:17:41 <lambdabot>  (28,31)
22:17:45 <elaforge> it just automates all the unwrapping and wrapping you'd do for the new type
22:17:55 <dmwit> gio123: The more readable one is also shorter. =)
22:17:56 <dejones> scottutd: this link is better: http://en.wikibooks.org/wiki/Haskell/YAHT
22:17:57 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
22:18:09 <dejones> it seems to matter with the trailing /
22:18:10 <dejones> heh
22:18:24 <scottutd> wy: Very different sorts of schools. I don't know too much about their (UT Austin's) grad programs, other than that they are highly ranked. Though I have a friend from there in Theory of Computation who said Automata Theory at UT is crosslisted from the Linguistics department.
22:18:54 <dejones> scottutd: wasn't Dijkstra at UT Austin too?  hehe.
22:19:02 <dejones> I wish I could have worked under Dijkstra....
22:19:03 <dejones> :(
22:19:12 <dejones> One of my profs did; I'm so jealous.
22:19:20 <radetsky> dejones: READ EWD
22:19:28 <dagit|lispy> When I toured the UTD campus I felt like it was very applied stuff.  So what you say about the "theory" course could be very true.
22:19:38 <dejones> radetsky: huh?
22:19:56 <radetsky> dejones: n/m, bad joke
22:19:56 <wy> Dijkstra seems to have introduced many wrong ideas to computer science ;)
22:20:12 <dejones> radetsky: lol, inform me on the joke?  heh
22:20:14 <dejones> wy: such as?
22:20:27 <dagit|lispy> dijkstra wanted CS to be more about astronomy and less about telescopes
22:20:28 <scottutd> dagit|lispy: No, that was the theory course at UT Austin. Though UTD is very much a software engineering school. I've floundered a bit trying to get into Theoretical stuff, hence working on a Masters to get a jump at a PhD elsewhere
22:20:33 <wy> dejones: considered-harmful articles ;)
22:20:45 <radetsky> wy: he was right on that one
22:20:49 <dejones> wy: how was he wrong?
22:20:58 <dejones> gotos are harmful! hehe
22:21:06 <jeffz> gotos aren't harmful, too many gotos are harmful.
22:21:06 <ddarius> wy: He didn't choose the title.
22:21:10 <scottutd> dejones: Goto's aren't that bad if they're not into a different scope
22:21:31 <elaforge> then you just call them continuations and say it's a feature?
22:21:36 <wy> And I still don't like semaphores
22:21:41 <siti> they make c cleaner, e.g. using them for clean up functions
22:21:42 <radetsky> you have to keep in mind what dijkstra was referring to
22:21:51 <scottutd> wy: got a better answer on the semaphores? :P
22:21:58 <radetsky> he didn't mean "don't use the goto statement" exactly
22:22:06 <dagit|lispy> scottutd, STM?
22:22:13 <dejones> scottutd: In some cases gotos are okay, but overall I think you can accomplish the same goals without them and have much better to read/understand code.
22:22:20 <radetsky> afaik he was referring to the practice of organizing programs with unconditional gotos
22:22:28 <scottutd> dagit|lispy: good call.
22:22:39 <wy> scottutd: No. but I see it as a temporary solution to several trivial problems, but then advertised as something general
22:23:04 <bobwhoops> another question: is there a function in the prelude which takes two arguments and puts them in a tuple?
22:23:04 <radetsky> rather than in functions or other control stuctures
22:23:07 <dejones> radetsky: I believe he was overall saying that gotos ruin the logical flow of your code, in that, you can't read the code and know what path it will follow in execution because of the gotos.
22:23:14 <dagit|lispy> bobwhoops, (,)
22:23:14 <dejones> which leads to bugs...
22:23:25 <dagit|lispy> :t (,)
22:23:26 <scottutd> Concurrency is certainly in need of better primitives, thats for sure.
22:23:28 <lambdabot> forall a b. a -> b -> (a, b)
22:23:37 <radetsky> dejones: right, but that isn't about gotos specifically
22:23:39 <dagit|lispy> ?src zip
22:23:40 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
22:23:40 <lambdabot> zip _      _      = []
22:23:51 <dagit|lispy> oh, zip is not how I expected
22:23:51 <bobwhoops> dagit|lispy: heh, I should have guessed that. thanks
22:23:53 <radetsky> a function call is basically a goto
22:23:55 <dagit|lispy> I thought, zip = zipWith (,)
22:23:55 <dejones> radetsky: true, but gotos are a great example of the problem!  :)
22:24:14 <wy> dejones: I'm joking
22:24:22 <dejones> :P
22:25:16 <radetsky> the point is that you can write code that doesn't have the problems dijkstra referred to with goto statements, but they enable you to write really horrible code very easily
22:25:16 <dagit|lispy> Didn't Baukus give a talk comparing anonymous functions to goto?
22:25:33 <dejones> radetsky: definitely.  :)
22:25:55 <dejones> where's Cale at?  It is almost 2am, isn't he normally here now?  heh
22:26:26 <scottutd> dagit|lispy: Where did you end up?
22:26:29 <dolio> Cale's schedule is irregular.
22:26:30 <dagit|lispy> Probably off doing some Oleg-ean exercises..
22:26:55 <dagit|lispy> scottutd, I went to a state school in my backyard, oregon state un.
22:27:03 <radetsky> dejones: by the way, the joke was a reference to "READ SICP"
22:27:30 <radetsky> Dijkstra's manuscripts were referred to as EWDs
22:27:32 <radetsky> etc...
22:28:06 <dagit|lispy> actually, I almost didn't go to college.  Boy, that would have been tremendously stupid.  But, it was certainly the kind of stupid mistake I made more frequently back then.
22:29:12 <dejones> radetsky: my prof is referred to in one of the EWD manuscripts, heh
22:29:37 <dejones> but, yah, the EWDs are interesting to read.
22:29:38 * dolio was trying to figure out smooth sort a few days ago.
22:29:40 <dolio> I failed.
22:29:51 <radetsky> dejones: as in "For example, my graduate student did X. This is fucking stupid. Don't do it."?
22:30:12 <dejones> dolio: maybe someone should write a haskell program to log Cale's activity and see if we can predict his availability  ;)  lol
22:30:21 <dolio> Heh.
22:31:00 <dejones> radetsky: haha, surprisingly not... actually he said something that Dijkstra didn't know, and that suprised Dijkstra, so in EWD's style, he went and learned it and wrote down his insights.
22:31:10 <wy> dagit|lispy: oregon state is very good
22:32:08 <radetsky> dejones: well, you said "Dijkstra" so I figured it involved calling *somebody* a fucking moron
22:32:21 <dejones> http://www.cs.utexas.edu/~EWD/ewd10xx/EWD1088.PDF --- here is the EWD, it's titled "A theorem communicated by Ken Calvert"
22:32:25 <dejones> radetsky: lol
22:32:25 <davidL> wy: good for functional programming?
22:32:31 <dejones> radetsky: I guess luckily my prof is smart?  ;) haha
22:32:47 <wy> davidL: It seems to be quite good
22:33:00 <wy> davidL: That's just my impression
22:33:09 <dejones> wy: why is oregon state good?
22:33:26 <dejones> you're saying for functional programming research?
22:33:28 <davidL> wy: I will have to look into that, there seems to be a lot going on in that area in terms of FP
22:33:31 <wy> dejones: because I found recently many good people graduated there
22:33:38 <dmwit> To golf: interact$show.length.filter(`elem`"13579")
22:33:43 <dagit|lispy> Prof. Erwig is good in languages
22:33:43 <radetsky> does anyone know how to make emacs stop treating esc as meta?
22:33:54 <adu> every time I see 'graduate' my name is highlighted ... :(
22:34:10 <siti> heh
22:34:11 <dagit|lispy> several of the grads from his group have gone on to work at MS and MSR
22:34:17 <siti> get a better client :p
22:34:20 <dagit|lispy> several of them are on the C# team as I understand it
22:34:39 <siti> that explains why C# sucks ;)
22:34:46 <radetsky> yeah, it's all about Db
22:34:51 <dagit|lispy> yeah, but C# 3.0 is way more FP
22:35:17 <radetsky> actually, Db would be a great name for a similar language
22:35:19 <dagit|lispy> actually C# is pretty good for what it is and the audience it targets
22:35:20 <siti> it's becoming another c++, e.g. mixing OO & procedural, OO & functional
22:35:33 <scottutd> i keep wishing F# was Haskell# :/
22:36:08 <dagit|lispy> scottutd, if that's a research area that interests you, making GHC efficently target CLR is a worthwhile research project
22:36:39 <siti> a few people have done that already
22:36:43 <siti> and it's a silly thing to do IMO
22:36:47 <radetsky> nobody will fix my editor for me?
22:36:54 <scottutd> dagit|lispy: that would mean touching GHC's innards with a ten-foot pole. j/k
22:36:57 <radetsky> waaaaahhhh!!!
22:37:11 <scottutd> siti: really, do you have a clicky? and why is it silly?
22:37:16 <dagit|lispy> siti, have they? where?
22:37:26 <siti> a guy at the uni I went to done it
22:37:31 <siti> I have not read his report/thesis
22:37:32 <dagit|lispy> last I read by SPJ it was a tricky problem full of hurdles
22:37:36 <siti> I don't think it's online
22:37:37 <radetsky> scottutd: It's easy for spj, because all he has to do is take his pants off
22:37:46 <scottutd> lol
22:38:02 <siti> it's silly because the CLR is not made for functional programming languages
22:38:07 <scottutd> siti: PhD student?
22:38:26 <scottutd> siti: they've hacked OCaml onto it
22:38:27 <siti> it's made for stupid imperative OO languages ;)
22:38:34 <siti> masters or honours project
22:38:49 <scottutd> siti: that's one heck of an honours project
22:38:49 <siti> what's the big benefit of using the CLR
22:39:17 <dagit|lispy> because then Haskell could be a .NET language.
22:39:22 <siti> it's like compiling c to javascript... it's just stupid
22:39:25 <dagit|lispy> take advantage of all those libraries, etc
22:39:35 <radetsky> dagit|lispy: ok, but what's the upside?
22:39:36 <siti> I would prefer native libraries rather than crappy ports
22:39:39 <wy> dagit|lispy: Which paper?
22:39:56 <dagit|lispy> use Haskell interchangably with C# and VB.NET in desktop applications.  Ya know, standard development for many small companies.
22:40:07 <scottutd> siti: Some of the language-based security work at my school is on working with .Net bytecode (for securing arbitrary programs). This is nicer to do in a functional language. I like Haskell better than OCaml, but my only option is F#.
22:40:07 <siti> java is more standard
22:40:24 <dagit|lispy> wy: I think it was in an email he sent some where.  I don't know how to find it other than googling.
22:40:57 <scottutd> siti: I also wish I had some functional languages targetting Java Bytecode
22:40:59 <siti> I am confused why you need .net bytecode security. I would have thought making the language have a nice typing system would do wonders for security
22:41:11 <ac> Cin: you disappeared your Scheme interpreter before I DLed the code
22:41:15 <radetsky> scottutd: like, say, Haskell?
22:41:15 <dagit|lispy> siti: and I'm not sure if you've noticed, but x86 is for imperative programs too.
22:41:46 <radetsky> or does haskell not actually compile to java bytecode?
22:41:50 <scottutd> siti: You can do arbitrary security policies by inlining reference monitors, that are more powerful than the limited typesystem of the original language
22:41:53 <radetsky> I was pretty sure it could be run from JVM
22:42:03 <siti> when you are compiling to java/.net bytecode you lose context which damages the result
22:42:14 <ac> Cin: something wrong with it?
22:42:45 <siti> scottutd: it sounds rather hard to maintain
22:42:55 <scottutd> siti: The advantage of being in .Net is that I can edit the bytecode with existing .Net Bytecode libraries written in .Net
22:42:57 <radetsky> oh, wait: http://www.cse.unsw.edu.au/~pls/thesis-topics/ghcjava.html
22:42:58 <lambdabot> Title: Thesis Topic : Compiling Haskell to Java
22:44:10 <scottutd> siti: http://www.utdallas.edu/~hamlen/thesis.pdf
22:44:39 <wy> radetsky: dons did that?
22:45:14 <radetsky> I don't think so
22:45:29 <siti> dons is not crazy as far as I know ;)
22:45:34 <radetsky> actually, it looks like unsw is just trying to pawn it off on somebody
22:45:41 <radetsky> it's not actually someone's project
22:45:45 <dons> heh
22:45:53 <jones-> Morning.
22:46:08 <dons> its an undergrad thesis topic, for those interesting in purusing compilation to jit machines (continuing my undergrad thesis)
22:46:10 <radetsky> dons: I gather you went to unsw. Does that sound like them?
22:46:24 <jones-> I was googling for a tutorial on how to write haskell bindings for a C library, but couldn't find much. Can anyone point me to some good sources?
22:46:42 <siti> jones-: one technique is using examples of hackage
22:46:46 <siti> there's some really simple bindings
22:46:50 <dons> jones-: probably the best bet is to look at a library. mersenne-random is a nice example, imo (on hackage.haskell.org)
22:47:22 <dons> radetsky: does what sound like them?
22:47:24 <wy> radetsky: I found don's BS thesis there :)
22:47:33 <jones-> siti, dons: thanks a lot. By the way, the C library I'd like to bind, makes heavy use of aynchronous callbacks. Do you think this could be a major problem?
22:47:46 <dons> hmm. gtk2hs does that, iirc.
22:47:52 <dons> its certainly possible.
22:48:06 <siti> it's bad if the main loop stays inside c code though
22:48:07 <radetsky> trying to pawn the compiling-haskell-to-java project off on some poor unfortunate soul because nobody wants to do it
22:48:10 <jones-> Ok, great, thanks. I'll have a look at the library you mentioned, for starters.
22:48:27 <dons> radetsky: not really. its just a topic, for someone to pick up if they're interested
22:48:31 <siti> I think you just have to use the safe annotation or something like that.  Then c can call your code...
22:48:33 <dons> there's a million other topics
22:48:48 <dagit|lispy> and it's not a bad topic.
22:49:02 <radetsky> by the way, I thought I'd ask again. Does anyone know how to make emacs stop interpreting ESC as Meta?
22:49:03 <dagit|lispy> There are quite pragmatic reasons to want things like that.
22:49:23 <dagit|lispy> radetsky, better to ask in #emacs i'd say :)
22:49:39 <radetsky> dagit|lispy: I'd have thought so too, but they weren't very helpful last time
22:49:53 <dagit|lispy> radetsky, it is possible, and I think I tried it once, but I don't recall how.
22:50:05 <jones-> dons: just one more qu estion: this thing that I'd like to write in haskell, will probably use a lot of networking. It's a server that listens for clients to connect, and then a lot of communication happens with these clients. Would you recommend against haskell for this kind of project, because I'll end up using an imperative paradigm most of the time anyway?
22:50:19 <glguy> ESC-x and Alt+x being the same thing is part of being a terminal, iirc
22:50:23 <glguy> not emacs specific
22:50:41 <dons> jones-: for network stuff? go for it. you get to use haskell threads for the app, which should be nice and zippy
22:50:52 <jones-> dons: aight, thanks!
22:50:59 <dons> there's lots of choices for network stuff now (get familiar with hackage.haskell.org)
22:51:22 <jones-> Ok.
22:51:57 <radetsky> jones-: why use an imperative paradigm?
22:52:41 <jones-> radetsky: because of all the networking communication that requires a precise order of execution
22:53:04 <jones-> radetsky: (just guessing here, I've only beein going thru several haskell tutorials, I'm really just starting)
22:53:31 <dons> sequencing is fine :)
22:53:41 <dons> it would be hard to program some things without it.
22:54:15 <dmwit> > (+) `on` read "3" "4"
22:54:18 <lambdabot>   Not in scope: `on'
22:54:35 <dmwit> ?let on (*) f x y = f x * f y
22:54:44 <lambdabot> Defined.
22:54:46 <dmwit> > (+) `on` read "3" "4"
22:54:47 <lambdabot>        add an instance declaration for (Read ([Char] -> t -> t1))
22:55:15 <dmwit> oh
22:55:24 <dmwit> > on (+) read "3" "4"
22:55:26 <lambdabot>  7
22:55:27 <dagit|lispy> > (+) `on` read $ "3" "4"
22:55:28 <lambdabot>  Couldn't match expected type `t -> String'
22:55:38 <dmwit> > (+) `on` read $ "3" $ "4"
22:55:39 <lambdabot>  Couldn't match expected type `a -> b'
22:55:52 <dagit|lispy> :t (+) `on` read
22:55:53 <lambdabot> Not in scope: `on'
22:56:14 <ac> how do I enable ! notation on arguments?
22:56:32 <LoganCapaldo> -XBangPatterns IIRC
22:56:36 <ac> ah cool
22:56:42 <radetsky> sequencing isn't the same thing as imperative style
22:56:49 <LoganCapaldo> don't quote me on that one ;)
22:56:54 <ac> LoganCapaldo: it worked
22:57:13 <LoganCapaldo> oh good :)
22:57:14 <ac> looks like it doesn't work for lambda arguments
23:00:00 <ac> wow, adding a couple bangs improved things more than a factor of 4
23:00:19 <ac> laziness can kill :-P
23:08:48 <BMeph> ac: No, it's just that laziness leads to lazy GC, too. ;)
23:09:36 <scottutd> how can I paste a code block into irc? do I need to insert \n's and type it on one line?
23:09:50 <dmwit> In general, you don't paste code blocks into irc.
23:09:53 <dmwit> ?hpaste
23:09:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:09:58 <dmwit> Use that instead.
23:10:17 <scottutd> so paste it there and then link it here?
23:10:28 <dmwit> scottutd: It will automatically announce your paste here.
23:10:55 <hpaste>  scottutd pasted "Type Class test problem" at http://hpaste.org/5750
23:11:18 <dmwit> test :: a -> Int
23:11:20 <scottutd> why does that try and infer Num int and  not compile
23:11:21 <scottutd> ?
23:11:25 <dmwit> (capital i)
23:11:30 <scottutd> ....
23:11:35 <scottutd> its been a while. :P
23:11:44 <dmwit> =)
23:12:02 <scottutd> ah. Much better.
23:13:10 <wagle_home> yeah, you mispelled "b" as "int"..  8) 8) 8)
23:19:04 <dmwit> :src minimum
23:19:09 <dmwit> ?src minimum
23:19:09 <lambdabot> minimum [] = undefined
23:19:10 <lambdabot> minimum xs = foldl1 min xs
23:22:35 <wy> I found an interesting quote: The life of a programming language expert in a world that does not know what one is and does not understand what one does...
23:29:50 <dmwit> So a while ago I decided to start ordering my imports lexically.
23:29:55 <dmwit> It has worked out wonderfully!
23:30:15 <dmwit> It almost always coincides very closely with a logical order for the imports.
23:31:05 <jones-> dons: cool, I'm binding stuff, over here! Thanks again1 :)
23:32:48 <radetsky> wy: sucks?
23:33:47 <OceanSpray> radetsky: blows
23:35:09 <wagle_home> works really well when you name the imports:  00_moduleB, 01_moduleA, ....
23:35:15 <scottutd> which of the records proposals is actually implemented in the standard? is there a section in the prelude (lots of dumb questions from me tonight...)
23:35:54 <BMeph> See y'all in six...
23:36:53 <radetsky> OceanSpray: I guess it's all a matter of perspective
23:37:57 <wy> radetsky: Do you mean the quote or the world?
23:38:20 <wagle_home> sounds like gravity, and whether gravitons exist or not
23:38:20 <scottutd> records? anyone?
23:41:13 <dmwit> scottutd: None of the proposals are implemented, I think.
23:41:25 <dmwit> Just the one in the Report.
23:41:34 <radetsky> wy: n/m
23:42:22 <dmwit> data F = F { recordName :: recordType, ... } | G { recordName2 :: recordType2, ... } | ...
23:42:41 <dmwit> Then, if foo :: f, recordName foo :: recordType.
23:43:02 <wy> I'm wondering what is the relation between lambda calculus and turing machines
23:43:29 <wy> I mean their intended use, not the equivalence
23:43:45 <radetsky> wy: something vs. nothing
23:43:59 <scottutd> so field access is not foo.recordName as in the SPJ paper :P thats good to know
23:44:12 <wy> radetsky: Do you mean lambda calculus is something?
23:44:31 <radetsky> wy: that its intended usage is something
23:45:08 <scottutd> Turing Machines are useful for proving things about computability/a definition for what an algorithm is? Lambda calculus is a mathematical formalization of a way of computing?
23:45:16 <wy> I'm just wondering why all books on theory of computation is about turing machines
23:46:13 <wy> scottutd: So actually the thing intended for real use is lambda calculus?
23:46:13 <scottutd> I believe its because Theory of Comp. is based on the Church/Turing Thesis that the abstract notion of an algorithm is equivalent to "things you can do with a TM"
23:46:17 <radetsky> wy: computability theorists don't have to deliver results
23:46:25 <radetsky> programmers do
23:46:56 <hpaste>  (anonymous) annotated "Type Class test problem" with "(no title)" at http://hpaste.org/5750#a1
23:47:03 <wy> I just guess if turing machines are just a convenient way to analysis what lambda calculus does
23:47:11 <dolio> Turing Machines are much closer to all the other automata you learn about in those courses. Perhaps that has something to do with it.
23:47:23 <scottutd> It would be harder (I believe) to do proofs via reduction, etc, if you had to define it on algorithms described in lambda calculus, it would be pretty nasty
23:47:39 <scottutd> Take Theory of Computation and find out! Its fun!
23:48:12 <wy> I'll read by myself. I don't like to be poured again
23:48:31 <wy> What about Sipser's book?
23:48:35 <radetsky> compare the two
23:48:41 <radetsky> turing machines are like asm from hell
23:48:49 <radetsky> lambda calculus is like functional programming
23:48:56 <radetsky> which would you rather use?
23:49:13 <scottutd> Sipser's is the one I am using atm, but his treatment can be less rigorous at times then the other guy (whose name slips my mind)
23:49:35 <dolio> finite automata ==add a stack==> pushdown automata ==swap stack for an infinite tape==> Turing machines.
23:49:52 <wy> scottutd: What does rigorous mean? with lots of proofs?
23:50:04 <scottutd> ok, radetsky, prove the halting problem using lambda calculus :P
23:50:20 <scottutd> wy: A decent number of proofs with quite a bit of hand-waving
23:50:34 <radetsky> scottutd: Chaitin already did it
23:50:55 <scottutd> radetsky: how's it look? (goes to google)
23:51:06 <wy> I'd like a book with ideas, and not only theorems and proofs
23:51:22 <scottutd> wy: well, they've all got the ideas.
23:51:29 <wy> dolio: That's what I found out recently
23:52:08 <wy> scottutd: But the difference is how the ideas are represented. It's better for me if I get to know how the ideas are dicovered
23:52:11 <dolio> There should be something in there for context sensitive languages, too, I guess, but my course skipped those, and I never bothered to go read up on them. :)
23:52:20 <radetsky> The one area where I used to think turing machines had an advantage was in universal induction, where it's easy to think of the universal induction machine as averaging a bunch of tapes to produce a prediction
23:52:47 <radetsky> but I just picked up a paper (I haven't read it yet) which claims to be able to cast that problem sensibly in lambda calculus
23:53:30 <wy> I found lambda calculus a more fundamental thing. I don't know if this is true
23:53:51 <radetsky> who cares if it's more fundamental or not? It's more *good*
23:54:27 <scottutd> I would agree that lambda calc. is more fundamental in a mathematical sense, but TMs come closer to our intuitive sense of what an "algorithm" is
23:54:29 <wy> radetsky: But after knowing it's good, people will want to know why it is good
23:54:59 <radetsky> math doesn't have a bottom
23:55:26 <scottutd> Think about the hurdles we go through to describe sequential algorithms or algorithms with side effects in lambda calc (not that its that difficult)
23:55:28 <radetsky> wy: and they won't find the answer in foundations
23:55:48 <scottutd> But its pretty easy to go the other way and define an imperative (TM) algorithm for evaluating lambda calculus
23:56:16 <wagle_home> lattice theory is math, it has a bottom
23:56:22 <wy> scottutd: yes. so TM is an analysis tool
23:56:52 <scottutd> wy: A TM is a mathematical formalism to capture the intuitive concept of an "
23:56:55 <wy> wagle_home: Have you taken course from Dan Friedman?
23:57:00 <scottutd> algorithm", so that we can reason about algorithms.
23:57:11 <wagle_home> wy yeah
23:57:53 <wy> scottutd: mostly about efficiency
23:58:15 <scottutd> wy: Mostly about computability, with a more recent concentration on efficiency
23:58:57 <radetsky> scottutd: I disagree. I think a TM is a mathematical formalism related to a mechanical process, but an algorithm isn't necessarily a mechanical process
23:59:00 <scottutd> wy: all the NP-completeness stuff borrows notation etc from work on computability in general and the arithmetic hierarchy that was done much earlier in the century
23:59:25 <radetsky> it can just as easily be thought of as a collection of rules to be applied under certain circumstances
23:59:49 <scottutd> radetsky: which are applied in a mechanical process... so algorithms of that sort are a subset
