00:27:42 <robreim> g'day. I'm trying to write source with Japanese characters again. Will the source file need to be in UTF-8 or is some more suitable charset possible?
00:28:09 <oerjan> i believe ghc supports UTF-8 only
00:28:28 <sjanssen> right
00:28:44 <sjanssen> robreim: you can use iconv as a pre-processor, though
00:28:53 <sjanssen> @google iconv ghc preprocessor
00:28:55 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html
00:28:55 <lambdabot> Title: 5.10. Options related to a particular phase
00:29:10 <robreim> sjanssen, thanks. I've looked into that a bit, but I still need some way of getting Japanese strings into my source code.
00:30:03 <sjanssen> robreim: why won't UTF-8 work?
00:30:44 <robreim> I suspect because the Japanese charset is too large to fit in UTF-8 with English chars included. Anyway, emacs whines when I try to save my file.
00:30:59 <robreim> (I know almost nothing about unicode I should mention)
00:31:29 <oerjan> UTF-8 as room for everything
00:31:33 <oerjan> *has
00:31:53 <sjanssen> > fromEnum (maxBound :: Char)
00:31:55 <lambdabot>  1114111
00:32:08 <sjanssen> robreim: lots of room :)
00:33:44 <robreim> Huh. Well, excuse my i18n ignorance. I need to do more reading. I thought utf-8 was only 8 bits and hence 256 chars.
00:34:03 <robreim> Ok, this may just be an emacs issue. I'll try upgrading.
00:34:19 <oerjan> it is variable-bits, that's how it can be short for English text
00:35:13 <oerjan> (just 8 bits for English)
00:35:52 <robreim> I see. Thanks.
01:06:29 <bloup> is there a simple way to pretty print data; replace "deriving Show" by something else?
01:07:40 <dolio> @hoogle pretty
01:07:42 <lambdabot> No matches found
01:08:28 <dolio> Text.PrettyPrint
01:11:25 <bloup> can you help me with the syntax. instead of "... deriving Show" what would I write?
01:11:49 <oerjan> i doubt it's _that_ simple
01:11:59 <bloup> so there is no generic way?
01:12:42 <oerjan> oh there probably is something with generics programming
01:13:24 <robreim> So source code containing unicode chars greater than 8 bits - I understand ghc truncates them somehow? What do they become (for the purposes of iconv conversion)
01:14:55 <oerjan> no that's not it
01:15:40 <oerjan> you have to distinguish between what ghc does on compilation, and what haskell I/O from ghc does by default in programs
01:16:09 <oerjan> on compilation, it reads UTF-8 and i doubt it truncates anything
01:17:54 <oerjan> but haskell I/O in programs is not properly Unicode - it reads ISO-8859-1 (= one 8-bit byte into a Char just with toEnum) and truncates on output
01:18:54 <oerjan> so source code should not be truncated in any way
01:18:59 <robreim> I see. So conversion to a bytestring would work around it?
01:19:41 <robreim> (Sorry, I wasn't clear when I said truncate - I meant truncate on output but your explanation helps a lot with my poor understanding, thanks)
01:19:54 <desegnis> On that matter, how are those new bytestring literals handled by ghc? Will they contain exactly the same byte sequence as given in the source file? (That's what one would hope)
01:20:14 <oerjan> there are unicode conversion libraries on hackage
01:20:58 <robreim> So what I'm a bit confused about is how utilities such as iconv work around this problem. How come it doesn't still get truncated when outputting after iconv conversion?
01:21:01 <oerjan> desegnis: don't know, interesting question
01:21:15 <desegnis> oerjan, ok
01:22:05 <oerjan> robreim: i think the suggestion was to use iconv to convert your source code to UTF-8 encoding (which is just one of several full Unicode encodings)
01:22:49 <robreim> Oh ok. I thought it was related to this idea: http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
01:22:50 <lambdabot> Title: blog.kfish.org: Survey: Haskell Unicode support
01:23:01 <desegnis> robreim: The thing is, values of type Char describe characters by their unicode code point (that is, directly, without an encoding). So whenever you input or output [Char]s, you have to convert them to an appropriate encoding (which is likely to be utf-8)
01:24:59 <robreim> Ok. So, for the purposes of say Codec.Text.IConv, what would be the input encoding for converting to utf-8 for output?
01:25:31 <robreim> (I've tried "unicode" but that hasn't worked)
01:26:31 <desegnis> that's because unicode isn't an encoding
01:27:31 <robreim> iconv --list | grep UNICODE gives me unicode as a valid encoding
01:27:57 <robreim> But anyway, what should I be using do you think?
01:28:07 <oerjan> hm that library seems to be for turning bytestrings with one encoding into bytestrings with another
01:28:25 <oerjan> that won't help if you have Strings
01:28:28 <robreim> oerjan, yeah, I think you're right.
01:28:56 <robreim> Ok. So if I have unicode strings in my source, how can I print those strings in unicode?
01:29:05 <desegnis> robreim: not sure about the meaning of UNICODE in iconv
01:29:26 <desegnis> robreim: I guess you'd want to print them in utf-8
01:29:34 <desegnis> you could use utf8-string on hackage
01:29:42 <robreim> Ok, I'll look at that. Thanks.
01:30:54 <desegnis> or alternatively, there is the encoding library
01:31:26 <desegnis> Look what suits you better
01:37:03 <robreim> utf8-string works! Thanks desegnis and oerjan
02:08:07 <desegnis> to answer my own question: no, overloaded string literals are achieved via conversion from [Char]
02:17:28 <kaol> @where CPS
02:17:28 <lambdabot> I know nothing about cps.
02:56:17 <paolino> :t unfoldr
02:56:19 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:59:40 <kaol> @go eta reduction
02:59:41 <lambdabot> http://www.lambda-bound.com/book/lambdacalc/node21.html
02:59:41 <lambdabot> Title: Eta Reduction
02:59:55 <dolio> @type \p f -> unfoldr $ (>>) <$> guard . p <*> return . f
02:59:56 <lambdabot> forall a a1. (a1 -> Bool) -> (a1 -> (a, a1)) -> a1 -> [a]
03:00:45 <kaol> could someone give me an example of eta reduction?
03:01:11 <dolio> \x -> f x ==> f?
03:01:38 <kaol> that's what it is? so simple.
03:01:45 <dolio> Yep.
03:01:52 <kaol> nice
03:02:48 <dolio> I guess technically it's '\x -> M x ==> M' for some expression M that doesn't contain x as a free variable.
03:03:22 <dolio> So '\x -> g y x ==> g y' is okay, but '\x -> g x x ==> g x' isn't.
03:07:34 <dolio> @pl \x -> g x x
03:07:35 <lambdabot> join g
03:16:16 <njbartlett> matthew-_: Ping
03:16:23 <njbartlett> matthew_-: Ping
03:18:06 <kaol> @src join
03:18:06 <lambdabot> join x =  x >>= id
03:20:10 <kaol> > join (+) 1
03:20:12 <lambdabot>  2
03:20:24 * kaol blinks
03:20:59 <dolio> @src (->) (>>=)
03:21:00 <lambdabot> f >>= k = \ r -> k (f r) r
03:21:01 <kaol> that (->) instance of monad is bizarre
03:26:17 <hpaste>  nayru pasted "(no title)" at http://hpaste.org/5409
03:27:09 <nayru> anyone know why retFst doesn't work? i am trying to run an example from a book
03:27:35 <dolio> retFst "abc" is a function.
03:27:56 <dolio> GHCi tries to display it, but it can't display functions.
03:29:42 <nayru> dolio: ah. i can call it with (retFst 1) "abc"
03:31:25 <dolio> Yeah, you need to supply it with enough parameters so you just have the resulting list.
03:31:34 <dolio> Or make functions showable, I suppose.
03:31:37 <nayru> okay. thanks
03:31:50 <dolio> > (+)
03:31:50 <lambdabot>  <Integer -> Integer -> Integer>
03:34:24 <luqui> :t on
03:34:25 <lambdabot> Not in scope: `on'
03:34:38 <luqui> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
03:34:38 <lambdabot> f a b c _ = a (b c) (b c)
03:35:30 <wagle_> : On
03:35:39 <wagle_> :t On
03:35:39 <lambdabot> Not in scope: data constructor `On'
03:36:06 <luqui> makes me think of the ordinal numbers
03:36:22 <wagle_> surreal
03:36:31 <luqui> oh was that it?
04:09:30 <sizur> @users
04:09:30 <lambdabot> Maximum users seen in #haskell: 465, currently: 406 (87.3%), active: 5 (1.2%)
04:10:57 <sizur> @hoogle Int -> Char
04:10:57 <lambdabot> Data.Char.intToDigit :: Int -> Char
04:10:58 <lambdabot> Data.Char.chr :: Int -> Char
04:10:58 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
04:21:45 <sizur> which is the command for integer sequences?
04:22:21 <luqui> sizur, what do you mean?
04:22:51 <sizur> a lambdabot command to search for integer sequence based on a few initial ones
04:22:56 <luqui> oh lambdabot's?
04:23:00 <ari> @help oeis
04:23:00 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
04:23:01 <luqui> here's a guess:
04:23:09 <luqui> that's what I was going to guess :-)
04:23:13 <sizur> ari, thanks
04:23:31 <sizur> @oeis 9 20 18 19
04:23:33 <lambdabot> Sequence not found. Wrong!  You cheating scum!
04:24:05 <luqui> oeis seems to be down
04:24:08 <sizur> @oeis 1 12 10 11
04:24:13 <lambdabot> Sequence not found. Listen, broccoli brains, I don't have time to listen to t...
04:24:29 <luqui> "Bad Gateway" it says...
04:24:36 <sizur> yeah, on every page
04:24:58 <ari> @oeis 1 2 3 4
04:25:13 <lambdabot> Plugin `oeis' failed with: thread killed
04:25:22 <ari> :(
04:34:35 <sizur> > unfoldr (\(a,b)->Just(a,(b,a+b))) (1,1)
04:34:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:35:57 <sizur> > let f=unfoldr(\(a,b)->Just(a,(b,a+b)))(1,1) in f!!21/f!!20
04:35:58 <lambdabot>  1.618033985017358
04:36:10 <sizur> > let f=unfoldr(\(a,b)->Just(a,(b,a+b)))(2000,1) in f!!21/f!!20
04:36:11 <lambdabot>  1.6180339631952863
04:36:54 <sizur> > let f=unfoldr(\(a,b)->Just(a,(b,a+b)))(2000,(-2000)) in f!!21/f!!20
04:36:55 <lambdabot>  1.618034055727554
04:37:55 <sizur> > let f=unfoldr(\(a,b)->Just(a,(b,a+b)))(1,1) in f!!201/f!!200
04:37:56 <lambdabot>  1.6180339887498947
04:40:08 <sizur> > let phi=1.618033988 in let fib = (**) phi in map fib [0..]
04:40:11 <lambdabot>  [1.0,1.618033988,2.6180339863231845,4.23606797161004,6.854101953543264,11.09...
04:40:25 <sizur> > let phi=1.618033988 in let fib = (**) phi in map (floor.fib) [0..]
04:40:25 <lambdabot>  [1,1,2,4,6,11,17,29,46,76,122,199,321,521,842,1364,2206,3571,5777,9349,15126...
04:44:53 <sizur> > let phi=1.618033988 in map ((**)phi) [0..]
04:44:56 <lambdabot>  [1.0,1.618033988,2.6180339863231845,4.23606797161004,6.854101953543264,11.09...
04:45:10 <sizur> > let phi=1.618033988 in map (floor.(**)phi) [0..]
04:45:10 <lambdabot>  [1,1,2,4,6,11,17,29,46,76,122,199,321,521,842,1364,2206,3571,5777,9349,15126...
04:45:52 <sizur> > let phi=(1.618033988::Double) in map (floor.(**)phi) [0..]
04:45:53 <lambdabot>  [1,1,2,4,6,11,17,29,46,76,122,199,321,521,842,1364,2206,3571,5777,9349,15126...
04:46:03 <lightstep> i think you need to round
04:46:13 <sizur> wont help, the error is too large
04:46:15 <lightstep> and maybe divide by (sqrt 5)
04:48:05 <lightstep> > let phi=(1 + sqrt 5) / 2; fib = round . (/ (sqrt 5)) . (phi **) in map fib [0..]
04:48:06 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:48:21 <sizur> lightstep, not bad
04:48:39 <lightstep> > let phi=(1 + sqrt 5) / 2; fib = floor . (/ (sqrt 5)) . (phi **) in map fib [0..]
04:48:40 <lambdabot>  [0,0,1,1,3,4,8,12,21,33,55,88,144,232,377,609,987,1596,2584,4180,6765,10945,...
04:49:00 <lightstep> there's probably some (-1)**n in the formula
04:52:38 <int-e> > let phi=(1 + sqrt 5) / 2 in [(phi^n - (-phi)^^(-n)) / sqrt 5 | n <- [0..]]
04:52:38 <lambdabot>  [0.0,1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,54.99999999999999,89.0,143.99999...
05:11:07 <roconnor> > exp pi - pi
05:11:07 <lambdabot>  19.999099979189474
05:11:53 <phlpp> > exp (sqrt 2) - (sqrt 2)
05:11:54 <lambdabot>  2.6990368164098326
05:12:09 <roconnor> http://www.xkcd.com/217/
05:12:09 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
05:13:56 <fourbissime> hi there. I'm trying to create my first monadic bit of code. here we go : http://hpaste.org/5410 - I don't understand why the type inference doesn't agree with this declaration. Is my definition too broad ? do I need multi-parametric classes here ?
05:14:38 <fourbissime> the second "narrow" declaration works.
05:17:44 * qwr stares at that error... what's a _rigid_ type variable?
05:17:46 <fourbissime> (sorry I messed up with a part of my code - correcting it)
05:18:14 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5410#a1
05:18:41 <fourbissime> my declaration was rule :: (Monad m) => a -> b -> m b of course
05:18:54 <roconnor> fourbissime: acroding to your delcaration rule must be polymorphic in b.
05:19:05 * resiak wonders why all the Haskellers have left/are leaving linspire
05:19:06 <roconnor> fourbissime: but in your instance it only works when b = Int.
05:19:32 <fourbissime> roconnor: oh I see what you mean.
05:20:25 <roconnor> fourbissime: you could make b a parameter of Rule as well if you enable multi-parameter type classes, but you should read a bit about multi-parameter type classes if you are going to go down that road.
05:21:11 <roconnor> fourbissime: and if you are making your first monadic code, I'd suggest staying away from MPTCs until you get the hang of Haskell 98 first.
05:21:18 <luqui> and more to the point, take a hammer and bang it on your head until you stop thinking in subtyping OO :-)
05:21:26 <olsner> fourbissime: also, since you're using Just, this would only work for m = Maybe
05:21:31 <luqui> (the hole in mine is quite deep)
05:21:37 <fourbissime> yes.
05:22:12 <roconnor> olsner: ah good point, Fortunately we could replace Just with return and Nothing with fail "errmsg"
05:22:33 <olsner> yeah
05:22:38 <fourbissime> actually this bit of code is a simplification of my actual code.
05:23:06 <matthew-_> @seen njbartlett
05:23:06 <lambdabot> njbartlett is in #scala, #perl6 and #haskell. I last heard njbartlett speak 2h 6m 43s ago.
05:23:16 <matthew-_> @seen Heffalump
05:23:16 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 1h 33m 27s ago.
05:23:48 <fourbissime> I'm writing a software that basically takes a complicated data type and pass it through tons of transformation functions that may return an invalid output. Here I used the Maybe monad but I'm using an Error monad in my actual code.
05:23:58 <matthew-_> The latest London Haskell User Group presentation featuring Heffalump talking about darcs is now available from: http://www.wellquite.org/non-blog/videos/hug_darcs_gadts.flv
05:24:16 <fourbissime> What I wrote here is a try at describing what my software is doing the most generic way possible
05:25:05 <roconnor> fourbissime: you should use return and fail.
05:25:08 <fourbissime> so the datatype (b) could be anything and the monad (m) used to handle invalid transformations could be anything too.
05:25:29 <roconnor> @type return
05:25:30 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:25:33 <roconnor> @type fail
05:25:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
05:25:48 <fourbissime> oh, good.
05:25:51 <fourbissime> I'll do that
05:26:08 <roconnor> you can replace Just/Right with return
05:26:18 <roconnor> and Nothing, Left with fail
05:26:26 <roconnor> @src Monad Maybe
05:26:27 <lambdabot> Source not found. Do you think like you type?
05:26:32 <roconnor> @src Maybe Monad
05:26:33 <lambdabot> Source not found. My pet ferret can type better than you!
05:26:42 <roconnor> I can never figure out src.
05:27:06 <roconnor> and lambdabot just pisses me off when I try.
05:27:17 <doserj> @src Maybe fail
05:27:17 <lambdabot> fail _      = Nothing
05:27:21 <doserj> @src Maybe return
05:27:21 <lambdabot> return              = Just
05:27:25 <jyp> yeah, lambdabot's become so obnoxious.
05:27:34 <matthew-_> it's a hard life
05:27:39 <fourbissime> well, thanks for your help guys. I'm going to dig a bit into all this.
05:27:52 <roconnor> fourbissime: anytime
05:29:05 <Heffalump> matthew-_: ?
05:29:20 <matthew-_> Heffalump: The latest London Haskell User Group presentation featuring Heffalump talking about darcs is now available from: http://www.wellquite.org/non-blog/videos/hug_darcs_gadts.flv
05:29:22 <Heffalump> oh, right.
05:29:43 <Heffalump> what can I use to play that?
05:29:46 <matthew-_> neil will, I'm sure, add a posting to londonhug.net
05:29:49 <matthew-_> mplayer
05:29:54 <Heffalump> windows :-)
05:30:05 <matthew-_> flash then
05:30:11 <matthew-_> just stick it in a web browser
05:30:17 <matthew-_> flv is flash video
05:30:18 <Heffalump> I did, it didn't like it.
05:30:24 <Heffalump> oh well, I'll investigate. Thanks for posting it!
05:30:37 <matthew-_> oh, bizarre. Might have to wait for Neil to make it pretty or something then. Dunno.
05:31:00 <matthew-_> np. I agreed to host all the videos some time ago - it's not like I get close to my bandwidth limit!
05:31:43 <roconnor> @type readMVar
05:31:44 <lambdabot> Not in scope: `readMVar'
05:32:00 <matthew-_> readMVar :: Mvar a -> IO a
05:32:03 * Heffalump looks at the source of how the last one went on the blog
05:32:05 <matthew-_> (from memory)
05:32:11 <roconnor> vlc works for me!
05:32:37 <visof> @src words
05:32:37 <lambdabot> words s = case dropWhile isSpace s of
05:32:38 <lambdabot>     "" -> []
05:32:38 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
05:32:55 <roconnor> Heffalump: I can play the video in vlc.
05:33:06 <Heffalump> ah, I see. It needs to be embedded on a page appropriate, or as roconnor says, played with vlc.
05:34:02 <matthew-_> I'd be quite happy to see .avi or .xvid but the embedding in a webpage is quite convenient. And I guess these days people are used to it with youtube and stuff
05:34:34 * matthew-_ watches bandwidth sustain > 10Mbps...
05:35:42 <Heffalump> matthew-_: :-)
05:36:10 <Heffalump> how much bandwidth does one person viewing it take up?
05:37:24 <matthew-_> well, it's over 100Mb
05:37:35 <matthew-_> and lasts an amount of time
05:37:35 <Heffalump> MB?
05:37:40 <matthew-_> yes, sorry
05:38:01 <matthew-_> -rw-r--r-- 1 matthew matthew 134249237 2008-02-02 13:20 hug_darcs_gadts.flv
05:38:02 <Heffalump> ok, but players will cache it so it's hard to figure out what the actual download rates will be
05:38:49 <olsner> "Hug darcs GADT:s"?
05:39:48 <Heffalump> absolutely, they'll work much better if you make them feel loved
05:39:53 <roconnor> @seen conal
05:39:53 <lambdabot> I saw conal leaving #haskell, #oasis and #ghc 5h 35m 58s ago, and .
05:40:04 <matthew-_> Heffalump: did the talk go well? I'm really sorry I couldn't be there but I just can't make wednesdays in general
05:40:23 <Heffalump> I think so, a lot of people expressed surprise that they'd understood it :-)
05:41:55 <olsner> Heffalump: yeah, gotta love the types!
05:42:32 <roconnor> is readMVar a blocking command?
05:43:30 <Saizan> roconnor: yes
05:43:47 * Heffalump counts his Ums
05:43:49 <roconnor> ooooh
05:44:06 <Saizan> roconnor: but it doesn't empty the MVar like takeMVar, for non-blocking you need tryTakeMVar
05:44:42 <roconnor> Saizan: I'm reading http://conal.net/blog/posts/future-values-via-multi-threading/
05:44:42 <lambdabot> Title: Conal Elliott » Blog Archive » Future values via multi-threading
05:44:59 <roconnor> I couldn't find the syncronization.
05:45:07 <roconnor> But I'm not familiar with MVars.
05:45:16 <Botje> HAHAHA
05:45:17 <Botje> success!
05:45:45 <Botje> I mailed a complaint to bux.to and they suspended the guy who spammed in here
05:47:24 <EvilTerran> win!
05:47:48 <Botje> very much so :)
05:47:59 <Botje> now to get lambdabot to report spams to abuse@ automatically
05:50:44 <matthew-_> I find the strangest thing, when listening to recordings of yourself is your voice. I really hate how I sound, and I don't know many people who don't hate how they sound when they hear themselves. it's odd.
05:51:42 <roconnor> @hoggle evaluate
05:51:43 <lambdabot> Control.Exception.evaluate :: a -> IO a
05:52:34 <sizur> matthew-_, it takes a simple getting used to. we're always thinking of ourselves as "this important sounding dude" ;)
05:52:52 <matthew-_> hmm
05:53:33 <matthew-_> when I heard me, I thought "I sound so poncy and snobbish" and my boss said "yeah, and I sound German!" (he actually is German)
05:54:53 <sizur> i hated to see myself in the video of my own wedding... i looked like i'm the king of this city
05:55:11 <matthew-_> yeah, but you see yourself in the mirror and stuff
05:55:21 <matthew-_> I find that less surprising than hearing myself
05:55:26 <sizur> i got used to my own voice when i was doing telemarketing
05:56:10 <roconnor> @src mfix IO
05:56:10 <lambdabot> Source not found. :(
05:56:15 <Heffalump> matthew-_: yeah, I agree
05:56:22 <roconnor> @src IO mfix
05:56:22 <lambdabot> mfix = fixIO
05:56:24 <sizur> in the mirror i look normal, because there is feedback, but in that video, i thought i looked normal when i did not :P
05:56:28 <roconnor> @src fixIO
05:56:29 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:56:33 <roconnor> :/
05:57:08 <matthew-_> roconnor: even when Î»b reports useful@src, it's not necessarily the src from ghc
05:57:21 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
05:57:21 <lambdabot> http://tinyurl.com/2wxtb3
05:57:57 <EvilTerran> ... hacky
06:00:53 <EvilTerran> is there a category-theoretic justification of MonadFix?
06:00:59 <roconnor> what is the semantics of unsafeInterleaveIO?
06:01:11 <roconnor> @type unsafeInterleaveIO
06:01:13 <lambdabot> Not in scope: `unsafeInterleaveIO'
06:01:13 <EvilTerran> "boom"
06:01:18 <roconnor> @hoogle unsafeInterleaveIO
06:01:18 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
06:01:44 <EvilTerran> it's much like return.unsafePerformIO, i think
06:02:11 <roconnor> ok
06:02:16 <resiak> do x <- unsafeInterleaveIO foo; ... something with x  doesn't actually run foo until you evaluate x
06:02:53 <lightstep> isn't that just return . unsafePerformIO ?
06:03:05 <EvilTerran> "unsafeInterleaveIO allows IO computation to be deferred lazily. When passed a value of type IO a, the IO will only be performed when the value of the a is demanded. This is used to implement lazy file reading, see hGetContents."
06:03:18 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#unsafeInterleaveIO - in reality, it's a bit fancier
06:03:18 <lambdabot> http://tinyurl.com/yuvzp2
06:04:14 <Saizan> ?src unsafeInterleaveIO
06:04:14 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
06:04:31 <roconnor> EvilTerran: you man hGetContents is built upon a proper function?
06:04:45 <EvilTerran> ?
06:05:30 <EvilTerran> i'd argue unsafeInterleaveIO isn't a "proper function" :P
06:06:32 <roconnor> yeah, but hGetContents has broken semantics
06:06:47 <roconnor> And it doesn't have some unsound- or unsafe- prefix.
06:06:51 <lightstep> that module's code doesn't make sense. IO can't really be implemented with state threading
06:07:12 <EvilTerran> why not?
06:07:15 <lightstep> it looks like some hack to make the ghc implementation work
06:07:30 <EvilTerran> the implementation of IO is, surprisingly, an implementation detail
06:07:33 <lightstep> i mean, there isn't any real world to pass around
06:07:36 <EvilTerran> ghc does it by state threading
06:07:39 <EvilTerran> ?src IO
06:07:39 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
06:07:44 <EvilTerran> there's your RealWorld :P
06:08:00 <lightstep> ?src RealWorld
06:08:00 <lambdabot> Source not found. :(
06:08:54 <matthew-_> it's an imaginary relay baton
06:09:33 <Saizan> ?src IO >>=
06:09:33 <lambdabot> Source not found. I am sorry.
06:09:40 <Saizan> ?src >>= IO
06:09:40 <lambdabot> Source not found. My pet ferret can type better than you!
06:09:47 <Saizan> it was there!
06:09:49 <roconnor> ?src IO (>>=)
06:09:49 <EvilTerran> you had it the right way round the first time
06:09:49 <lambdabot> m >>= k     = bindIO m k
06:09:56 <lightstep> it's in the beginning of the same page
06:10:08 <lightstep> the code is just liek for State, just with unboxing
06:10:32 <Saizan> ?src bindIO
06:10:32 <lambdabot> bindIO (IO m) k = IO ( \ s ->
06:10:32 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
06:10:37 <lightstep> so why does unsafeInterleaveIO produce lazy code and (>>=) not?
06:10:51 <Saizan> because of the let
06:11:12 <Heffalump> because unsafeInterleaveIO = return . unsafePerformIO
06:11:33 <Heffalump> it basically throws away the resulting RealWorld
06:11:41 <Heffalump> so it doesn't impose ordering constraints
06:12:09 <lightstep> oh, the imported implementations of IO primitives pretend to really use that argument?
06:12:16 <EvilTerran> Heffalump, we've had that bit of the conversation already; we're comparing the source of unsafeInterleaveIO and bindIO now :P
06:12:27 <Heffalump> ah, sorry
06:13:53 <lightstep> if you write "return x >>= f", isn't it equivalent to f $! x?
06:13:58 <lightstep> in IO
06:14:45 <int-e> lightstep: no, IO has no reason to force x. it's just  f x
06:14:57 <Saizan> lightstep: IO is strict in the effects
06:15:35 <roconnor> evaluate x >>= f is equivalent to f $! x
06:15:54 <EvilTerran> "evaluate"?
06:16:02 <roconnor> @hoogle evaluate
06:16:02 <lambdabot> Control.Exception.evaluate :: a -> IO a
06:16:27 <EvilTerran> evaluate x = x `seq` return x?
06:16:33 <EvilTerran> ?src evaluat
06:16:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:16:34 <EvilTerran> ?src evaluate
06:16:35 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
06:16:42 <EvilTerran> eh, pretty much
06:18:29 <Daniil0> http://world3.monstersgame.fr/?ac=vid&vid=108014140
06:19:12 <EvilTerran> Botje, fancy exercising your skills again? :P
06:21:21 <Botje> let's see if these people also respond to abuse@ >:)
06:21:36 * EvilTerran can't find a "report abuse" link on monstersgame.fr, but it says "3) Spamming or flooding public forums, bulletin boards or chats with Victim Links is forbidden and can lead to deletion of all game accounts involved." in their rules page
06:22:04 <litb> hello there
06:22:13 <litb> what is the difference between span and partition ?
06:22:30 <resiak> @src span
06:22:30 <lambdabot> Source not found. You type like i drive.
06:22:32 <litb> and if there is none, why the heck are there two functions for the same purpose?
06:22:34 * resiak growls at \b
06:22:37 <roconnor> @type span
06:22:38 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
06:22:49 <EvilTerran> span p xs = (takeWhile p xs, dropWhile p xs)
06:22:50 <Botje> litb: span only looks at the first elements that match
06:22:54 <Botje> partition takes htem all
06:23:00 <roconnor> > span (< 5) [4,5,6,5,4,5,6]
06:23:01 <EvilTerran> partition p xs = (filter p xs, filter (not.p) xs)
06:23:01 <lambdabot>  ([4],[5,6,5,4,5,6])
06:23:07 <roconnor> > parition (< 5) [4,5,6,5,4,5,6]
06:23:08 <lambdabot>   Not in scope: `parition'
06:23:12 <roconnor> > partition (< 5) [4,5,6,5,4,5,6]
06:23:13 <lambdabot>  ([4,4],[5,6,5,5,6])
06:23:29 <litb> ah i undestand
06:23:34 <Botje> hmm
06:23:45 <Botje> partition could be used to make the quicksort a bit nicer
06:23:46 <litb> kinda like span.nub
06:23:58 <EvilTerran> er, not really...
06:24:03 <Botje> litb: not really. more like filter.
06:24:20 <roconnor> @check (\p x -> let (l,r) = span p x in l++r == (x::[Int]))
06:24:21 <lambdabot>  OK, passed 500 tests.
06:24:28 <roconnor> @check (\p x -> let (l,r) = partition p x in l++r == (x::[Int]))
06:24:29 <lambdabot>  Falsifiable, after 2 tests: <Int -> Bool>, [4,3,1,4]
06:25:21 <litb> > let spaN f l = partition f (nub l)
06:25:21 <lambdabot>  Parse error at end of input
06:25:25 <litb> @let spaN f l = partition f (nub l)
06:25:28 <lambdabot> Defined.
06:25:50 <litb> > spaN (< 5) [4,5,6,5,4,5,6]
06:25:50 <lambdabot>  ([4],[5,6])
06:26:06 <litb> > span (< 5) [4,5,6,5,4,5,6]
06:26:06 <lambdabot>  ([4],[5,6,5,4,5,6])
06:26:09 <litb> hm
06:26:16 <litb> @undefine
06:26:17 <lambdabot> Undefined.
06:26:34 <Riastradh> Botje: quicksort list lt = qsort list [] where qsort [] tail = tail; qsort (x:xs) tail = let (left,right) = partition lt xs in qsort left (x : qsort right tail)
06:26:41 <litb> ah i understand it now
06:26:59 <EvilTerran> @check \p xs -> partition p xs == span p (sortBy (\x y -> p y `compare` p x) (xs :: [Int]))
06:27:03 <lambdabot>  OK, passed 500 tests.
06:27:07 <EvilTerran> :D
06:27:23 <litb> o.O
06:27:32 <litb> does it use random data?
06:27:37 <EvilTerran> yeah
06:27:42 <EvilTerran> dunno how it chooses po
06:27:43 <EvilTerran> er, p
06:27:57 <roconnor> It's not quicksort, it's tree sort damn it!
06:28:14 <roconnor> http://reddit.com/r/programming/info/656k9/comments/c02vo9d
06:28:33 <roconnor> http://reddit.com/r/programming/info/2h0j2/comments/c2h196
06:28:36 <litb> is it intentional that reddit sounds like "read it" ?
06:29:52 <litb> anyway, back learning for the examination
06:29:54 <benny> yes
06:30:04 <benny> "I read it on reddit."
06:30:52 <Riastradh> roconnor, so what would you call quick-sort, then?
06:31:12 <roconnor> Riastradh: http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
06:31:13 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2hq6cn
06:31:26 <roconnor> Riastradh: quicksort is quick because it is inplace
06:31:45 <roconnor> it is actually O(n^2) algorithm
06:32:01 <roconnor> if you are not doing it in-place, you might as well use merge sort.
06:32:56 <litb> on wikipedia i read that qsort in haskell is not inplace
06:33:04 <litb> how could it be in a pure functional language
06:33:21 <roconnor> litb: right, because what people here call quicksort isn't quicksort, but rather it is tree sort.
06:33:29 <EvilTerran> with references; one of those links explains
06:33:39 <litb> i see, i will hunt that treesort and see what that is
06:33:55 <roconnor> litb: you can implement quicksort in Haskell by using monads and arrays.
06:34:11 <litb> roconnor: ugg, i'm not into arrays yet
06:34:42 <litb> arrays are mutable?
06:34:49 <EvilTerran> not all of em
06:34:52 <EvilTerran> mutable arrays are :D
06:35:00 <litb> i'm upset. i thought haskell is non-mutable
06:35:12 <EvilTerran> ... what makes it an array is the O(1) indexing operation
06:35:17 <roconnor> litb: some things are mutable ``inside'' some monads.
06:35:23 * litb is disappointed, has to sip some coffee
06:35:39 <lightstep> ghc optimizes single-threaded arrays into mutable ones
06:35:51 <EvilTerran> haskell's still pure; the mutability is wrapped up safely in a monad
06:35:54 <litb> oh, i see. behind the scene
06:36:06 <litb> anyway, what i want to know is
06:36:10 <EvilTerran> the simplest example of mutable values would be IORefs
06:36:27 <litb> if something has side effect on >>= or is mutable on >>= , how is it still pure?
06:36:41 <litb> i mean, yeah it is hidden behind >>= , but it still causes side effects
06:36:47 <EvilTerran> because your code can't see the impurity
06:36:49 <litb> i don't really understand that
06:36:59 <lightstep> haskell is like a macro language
06:37:00 <roconnor> litb: >>= doesn't actually mutate
06:37:04 <EvilTerran> all the side-effects could be "pre-recorded", as it were
06:37:18 <roconnor> litb: it constructs a ``program'' that when executed by the run time system will mutate.
06:37:35 <litb> well, if i hide IO t in my function and return String the caller cannot see the immutability too, but it's still unpure
06:37:43 <lightstep> you have the basic IO actions, and haskell allows you to combine them purely into moer complicated ones. then, after that is done, the runtime system runs the one called "main"
06:37:51 <EvilTerran> litb, except not, because that IO will never happen
06:38:14 <EvilTerran> unless you're talking about unsafePerformIO, which is Not Really Haskell
06:38:32 <roconnor> litb: there are no functions that will allow you to construct a String from an IO t that uses t.
06:38:45 <roconnor> litb: you can only construct IO Strings.
06:38:51 <litb> i see
06:38:56 <litb> lets assume there was
06:39:02 <roconnor> an IO String isn't a string.
06:39:11 <EvilTerran> litb, but then we're not talking about haskell any more
06:39:12 <litb> then wouldn't that be the same as the "wrapped up safely in the monad" case?
06:39:20 <EvilTerran> this is the whole point of doing IO in a monad
06:39:20 <litb> i would say "wrapped up safely in my fooGetString"
06:40:05 <EvilTerran> but that's a function, and a monad's a type
06:40:38 <roconnor> if you can produce interesting strings from an IO t than by definition things aren't wrapped up safely.
06:40:57 <roconnor> safety comes from the fact that you cannot produce strings from IO t 's
06:41:04 <Vq^> litb: if fooGetString gives you a String from an unpure source, how can that be called safe?
06:41:18 <litb> Vq^: well i don't call it safe
06:41:27 <Botje> Riastradh: neat!
06:41:31 <EvilTerran> you said "wrapped up safely" :P
06:41:46 <litb> it was the fact that there are mutable arrays that work wrapped up into a monad.
06:41:54 <litb> i quoted it EvilTerran :p
06:42:13 <EvilTerran> litb,are you okay with reading/writing files via the IO monad?
06:42:18 <litb> is there a good paper explaining all this?
06:42:26 <EvilTerran> a file is an array of characters :D
06:42:47 <EvilTerran> @go tackling the awkward squad
06:42:48 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
06:42:48 <lambdabot> Title: Simon Peyton Jones: papers
06:42:49 <litb> EvilTerran: well, see. if i access a file. could we say that is a part of haskell that is impure?
06:43:14 <EvilTerran> your code itself is still pure; the side-effects are cunningly hidden from your code by the monad
06:43:20 <pejo> litb, "What is a purely functional language", http://www.cs.indiana.edu/hyplan/sabry/papers/purelyFunctional.ps
06:45:08 <Saizan> litb: values of type IO t are still pure, you can manipulate and pass them around in a referentially transparent way, it's only their execution, done by the runtime system, that's impure
06:45:09 <desegnis> litb, I'd put it this way: the side-effects are only in the run-time system / the program, while Haskell functions are always pure. (So I say the *functions* are pure and without side effects, while my code may of course describe side effects to perform!)
06:45:14 <hpaste>  khadrin pasted "Is there a library function that increments the ith entry in a list?" at http://hpaste.org/5411
06:45:54 <EvilTerran> > zipWith ($) (replicate 5 id ++ [(+1)] ++ repeat id) [0..]
06:45:56 <lambdabot>  [0,1,2,3,4,6,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
06:46:34 <Vq^> litb: the difference is that you only compose the impure actions instead of executing them
06:46:35 <litb> desegnis: ah, i understand
06:46:39 <desegnis> litb, or put yet another way: Haskell provides a functional *abstraction* of the real world (consisting of your screen, keyboard, ...)
06:46:43 <khadrin> EvilTerran: cool
06:47:42 <khadrin> that hurts my brain =)
06:47:51 <desegnis> actually I think, s/describe side effects to perform/describe effects to perform/
06:48:02 <EvilTerran> :)
06:48:38 <EvilTerran> resiak's version he annotated with is probably better, tho, as it's clearer
06:48:44 <idnar> well, there is the ST monad
06:49:52 <khadrin> looking at it
06:50:25 <hpaste>  Deewiant annotated "Is there a library function that increments the ith entry in a list?" with "something I wrote recently" at http://hpaste.org/5411#a2
06:50:28 <resiak> oh, and the type signature is wrong
06:50:43 <litb> > zipWith ($) (replicate 5 id ++ [(*2)] ++ repeat id) [0..]
06:50:43 <lambdabot>  [0,1,2,3,4,10,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
06:50:47 <litb> nice
06:50:55 <hpaste>  resiak annotated "Is there a library function that increments the ith entry in a list?" with "the index need not have the elements' type" at http://hpaste.org/5411#a3
06:51:36 <khadrin> right, doh
06:51:45 <khadrin> (x:xs) is very cool
06:52:46 <hpaste>  EvilTerran annotated "Is there a library function that increments the ith entry in a list?" with "how i'd do it really" at http://hpaste.org/5411#a4
06:53:51 <resiak> well, yes
06:54:03 <resiak> i was tidying, not reimplementing :-)
06:54:34 <litb> fascinating
06:54:36 <khadrin> why is EvilTerran's version better?
06:54:49 <litb> how do you guys always get the precedence of the operators right  ?
06:55:01 <EvilTerran> khadrin, i prefer to avoid explicit recursion if i can
06:55:07 <khadrin> hmm
06:55:08 <EvilTerran> litb, practise :P
06:55:19 <roconnor> litb: always use brackets :)
06:55:26 <litb> i see =)
06:55:29 <EvilTerran> most of 'em are pretty sensible, and if it's not immediately obvious, i use brackets
06:55:40 <litb> yeah, explicit recursion reminds me of for, while and friends
06:56:26 <EvilTerran> khadrin, in my version, a seasoned haskell programmer can grok the behaviour pretty quickly based on his knowledge of the behaviour of the prelude functions
06:56:51 <EvilTerran> khadrin, while, with the explicit recursion, he has to work a lot more of the behaviour out himself
06:57:16 <Deewiant> at least in this case I'd say they're both pretty obvious at a glance
06:57:21 <litb> yeah the splitAt version is immediately clear to me
06:57:47 <lightstep> i think there should be a prettier name for zipWith ($), or maybe for zipWith
06:58:08 <litb> maybe applyTo . it sounds nice
06:58:21 * desegnis always thought that zipWIth should be called zip, and zip should be called zip (,)
06:58:39 <khadrin> yea, learning the libraries is always a big step
06:58:41 <olsner> > let splitAt = liftM2 (&&&) take drop in splitAt 3 [0..7]
06:58:42 <lambdabot>  ([0,1,2],[3,4,5,6,7])
06:58:54 <Deewiant> my applyAt has the additional obfuscation of the Maybe stuff, too
06:59:08 <EvilTerran> also, mine has the advantage of awesome generality, too
06:59:14 <desegnis> s/thought/has thought/ -- stupid English grammar
06:59:28 <Deewiant> EvilTerran: ?
06:59:33 <EvilTerran> i believe it's quite common to say zipWith ($) = zapp
06:59:37 <litb> olsner: isn't that inefficient?
06:59:59 <EvilTerran> Deewiant, as compared to the original (incrAt n), mine does any (f `at` n)
07:00:19 <EvilTerran> yours is just as general, tho
07:00:21 <Deewiant> EvilTerran: ah, but so does mine. :-)
07:00:26 <roconnor> > ZipList [id, (+ 2) (* 2)] <*> ZipList [1..]
07:00:27 <lambdabot>   add an instance declaration for (Show (ZipList a))
07:00:45 <litb> only wild guessing
07:00:47 <roconnor> > getZipList (ZipList [id, (+ 2) (* 2)] <*> ZipList [1..])
07:00:47 <litb> since it first takes the first 3, but then drops the first 3 (and has to iterate to 4 again) . or is that transformed by the optimisator ?
07:00:47 <lambdabot>   add an instance declaration for (Num (a -> a))
07:00:47 <lambdabot>     In the expression: (+ 2)...
07:01:03 <roconnor> > getZipList (ZipList [id, (+ 2), (* 2)] <*> ZipList [1..])
07:01:04 <lambdabot>  [1,4,6]
07:01:16 <EvilTerran> litb, yes, that would be a little less efficient. only by a constant factor, tho :P
07:01:16 <roconnor> lightstep: there you go
07:01:37 <olsner> heh, at worst twice as slow, I'd think :P
07:01:46 <lightstep> is that Idiom? or Applicative?
07:01:50 <litb> EvilTerran: i just wanted to be sure i understand that function rite, actually. not moaning its performance :D
07:01:53 <lightstep> ?type (<*>)
07:01:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:02:38 <litb> but that take, drop makes a nice analogy to the result imho
07:02:58 <olsner> > splitAt 3 [0..7]
07:02:59 <lambdabot>  ([0,1,2],[3,4,5,6,7])
07:03:00 <EvilTerran> Idiom would be iI (ZipList [id, (+1), (*2)]) (ZipList [1..]) Ii, i think
07:03:48 <roconnor> > iI (ZipList [id, (+1), (*2)]) (ZipList [1..]) Ii
07:03:48 <lambdabot>   Not in scope: data constructor `Ii'
07:03:52 <roconnor> awww
07:04:06 <EvilTerran> idiom's not in the stdlib
07:04:18 <litb> > [(2*), (/2)] `ap` [1..]
07:04:19 <lambdabot>  [2.0,4.0,6.0,8.0,10.0,12.0,14.0,16.0,18.0,20.0,22.0,24.0,26.0,28.0,30.0,32.0...
07:04:28 <litb> oh, that was dumb actually :)
07:04:36 <litb> > [(2*), (/2)] `ap` [1..5]
07:04:36 <lambdabot>  [2.0,4.0,6.0,8.0,10.0,0.5,1.0,1.5,2.0,2.5]
07:04:41 <olsner> EvilTerran: what iI and Ii?
07:04:55 <lightstep> getZipList $ fmap ($) [(2*), (/2)] [5,6]
07:05:08 <lightstep> > getZipList $ fmap ($) (ZipList [(2*), (/2)]) (ZipList [5,6])
07:05:08 <lambdabot>  Couldn't match expected type `ZipList a'
07:05:33 <roconnor> > getZipList $ id ($) (ZipList [(2*), (/2)]) (ZipList [5,6])
07:05:34 <lambdabot>  Couldn't match expected type `ZipList (t -> t)'
07:05:47 <lightstep> ?type fmap
07:05:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:05:55 <roconnor> > getZipList $ fmap (ZipList [(2*), (/2)]) (ZipList [5,6])
07:05:56 <lambdabot>  Couldn't match expected type `a -> b'
07:06:14 <lightstep> <*> is more like liftM2
07:06:18 <roconnor> right
07:06:27 <lightstep> ?type liftM2
07:06:27 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:06:34 <roconnor> > getZipList $ liftM2 ($) (ZipList [(2*), (/2)]) (ZipList [5,6])
07:06:34 <lambdabot>   add an instance declaration for (Monad ZipList)
07:06:46 <lightstep> no, it's just Applicative, not Monad
07:06:48 <Saizan> liftA2
07:06:59 <roconnor> > getZipList $ (<*>) ($) (ZipList [(2*), (/2)]) (ZipList [5,6])
07:06:59 <lambdabot>  Couldn't match expected type `(a1 -> ZipList a) -> a1'
07:07:03 <roconnor> :P
07:07:09 <twanvl> > let (<%>) = zipWith ($) in [id, (+2), (*2)] <%> [1..]
07:07:10 <lambdabot>  [1,4,6]
07:07:15 <EvilTerran> olsner, deep magicks
07:07:19 <olsner> @ty (<*>)
07:07:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:07:28 <olsner> @ty (<$>)
07:07:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:07:28 <litb> > let appAt f n = [id, (f), id] `ap` [[1..(n-1)], [n], [(n+1)..]] in appAt (+1) 5
07:07:29 <lambdabot>   add an instance declaration for (Num [a])
07:08:24 <litb> oh
07:09:50 <olsner> aha, so (f <$> x) would be (a -> b -> c -> d) -> f a -> f (b -> c -> d), which you then `ap` or <*> for each extra argument until you end up with (f d)
07:09:58 <Deewiant> > let appAt f n = [id, (f), id] `ap` [[1..(n-1)], [n], [(n+1)..]] in appAt (++[1]) 5
07:09:59 <lambdabot>  [[1,2,3,4],[5],[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
07:10:12 <EvilTerran> indeed, i think
07:10:20 <EvilTerran> @let zapp = zipWith ($)
07:10:21 <lambdabot> Defined.
07:10:53 <EvilTerran> @undef - wait a minute
07:10:54 <lambdabot> Undefined.
07:11:01 <EvilTerran> @let infixl 4 `zapp`; zapp = zipWith ($)
07:11:02 <lambdabot> Defined.
07:11:20 <Deewiant> @pl zipWith ($)
07:11:20 <lambdabot> zipWith id
07:11:34 <olsner> eww, precedence on infix functions
07:11:36 <EvilTerran> > repeat (,,,) `zapp` [0..] `zapp` ['a'..] `zapp` [True,False,False,True]
07:11:37 <lambdabot>  Add a type signature
07:11:43 <litb> well my appAt doesn't make any sense :p
07:11:46 <EvilTerran> > repeat (,,) `zapp` [0..] `zapp` ['a'..] `zapp` [True,False,False,True] -- even
07:11:46 <lambdabot>  [(0,'a',True),(1,'b',False),(2,'c',False),(3,'d',True)]
07:12:02 <Japsu> :t (,,,)
07:12:02 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
07:12:06 <EvilTerran> ?type repeat (,,)
07:12:07 <lambdabot> forall a b c. [a -> b -> c -> (a, b, c)]
07:12:07 <Japsu> :t (,,,,)
07:12:08 <lambdabot> forall a b c d e. a -> b -> c -> d -> e -> (a, b, c, d, e)
07:12:11 <EvilTerran> ?type repeat (,,) `zapp` [0..]
07:12:12 <lambdabot> Not in scope: `zapp'
07:12:19 <EvilTerran> meh
07:13:25 <khadrin> is it typical in haskell to think of indexes starting at 0? i had 1 as the index of the first element
07:13:48 <Deewiant> > [1..] !! 0
07:13:49 <lambdabot>  1
07:13:51 <Deewiant> > [1..] !! 1
07:13:51 <roconnor> khadrin: it is typical in CS.
07:13:52 <lambdabot>  2
07:14:03 <resiak> echan.
07:14:04 <resiak> @let (â˜‡) = zapp
07:14:05 <lambdabot>  Illegal character ''\152''
07:14:07 <resiak> :(
07:14:23 <khadrin> fine by me i'm used to c style languages =)
07:14:57 <roconnor> CS = computer science.
07:15:14 <litb> NOT cyber sex :p
07:15:35 <litb> although i could consider haskell as such hehe
07:16:22 <Deewiant> can the function "length1 :: [a] -> Bool, length1 [_] = True, length1 _ = False" be defined pointfree?
07:16:38 <lightstep> ?src null
07:16:39 <lambdabot> null []     = True
07:16:39 <lambdabot> null (_:_)  = False
07:16:46 <dcoutts_> waern: any opinion on the haddock and .lhs code issue?
07:17:07 <Deewiant> length1 = null.tail almost works, but it dies on empty lists due to tail
07:17:10 <lightstep> ?pf \list -> case list of [_] -> True; _ -> False
07:17:10 <lambdabot> Maybe you meant: bf pl
07:17:15 <lightstep> ?pl \list -> case list of [_] -> True; _ -> False
07:17:15 <lambdabot> (line 1, column 23):
07:17:16 <lambdabot> unexpected "["
07:17:16 <lambdabot> expecting variable, "(", operator or end of input
07:17:38 <EvilTerran> liftA2 (&&) (not.null) (null.tail)
07:17:39 <lightstep> > ((== 1) . length) [5]
07:17:41 <lambdabot>  True
07:17:43 <litb> > (not.null) [1]
07:17:44 <lambdabot>  True
07:17:50 <litb> > (not.null) []
07:17:50 <lambdabot>  False
07:17:52 <Deewiant> without computing the length, of course. :-)
07:18:01 <Deewiant> > ((==1) . length) [1..]
07:18:02 <EvilTerran> lightstep, that won't work on infinite lists
07:18:06 <lambdabot> Terminated
07:18:10 <khadrin> (1::Int) / (2::Int)
07:18:19 <twanvl> data Nat = Z | S Nat ; instance Num Nat; length1 = (==(1::Nat)) . genericLength
07:18:23 <lightstep> > ((== 1) . length . take 2) [5]
07:18:24 <lambdabot>  True
07:18:30 <lightstep> > ((== 1) . length . take 2) [0..]
07:18:31 <lambdabot>  False
07:18:34 <Deewiant> @pl liftA2 (&&) (not.null) (null.tail)
07:18:34 <lambdabot> liftA2 (&&) (not . null) (null . tail)
07:18:46 <resiak> > take 2 []
07:18:46 <lambdabot>  []
07:18:51 <EvilTerran> Deewiant, \xs -> not (null xs) && null (tail xs)
07:18:54 <Deewiant> @src liftA2
07:18:54 <lambdabot> liftA2 f a b = f <$> a <*> b
07:18:55 <litb> > let a [_] = True; a _ = False in a []
07:18:55 <lambdabot>  False
07:19:06 <Deewiant> EvilTerran: aye, just wondering about liftA2
07:19:09 <litb> well, isn't it (not.null) ?
07:19:15 <EvilTerran> ah
07:19:25 <Deewiant> > let a [_] = True; a _ = False in a []
07:19:25 <EvilTerran> litb, no...
07:19:25 <lambdabot>  False
07:19:27 <Deewiant> > let a [_] = True; a _ = False in a [1]
07:19:28 <lambdabot>  True
07:19:29 <Deewiant> > let a [_] = True; a _ = False in a [1,2]
07:19:29 <lambdabot>  False
07:19:35 <EvilTerran> @src null
07:19:35 <lambdabot> null []     = True
07:19:35 <lambdabot> null (_:_)  = False
07:19:44 <waern> dcoutts_: no, I haven't followed it very closely
07:19:44 <lambdabot> waern: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:19:47 <EvilTerran> [_] is any length-one list
07:19:58 <shachaf> Deewiant: liftA2 f g h = \x -> g x `f` h x
07:20:03 <lightstep> is there "uncons"? like "maybe"?
07:20:07 <litb> EvilTerran: oh, i see
07:20:14 <dcoutts_> waern: I cc'ed the last email to you as it's the most relevant
07:20:19 <b_jonas> lightstep: yes, curry or uncurry (I forgot which)
07:20:25 <waern> dcoutts_: ok
07:20:27 <Deewiant> shachaf: I see that, thanks
07:20:38 <lightstep> b_jonas, that does tuples, i want lists
07:20:41 <EvilTerran> b_jonas, er, that's for pairs, not lists
07:20:41 <dcoutts_> waern: haddock-0.x doesn't like comments and code having different indentations, eg comments with no indent and code indented by one or two spaces
07:20:50 <b_jonas> oh sorry, yes, I'm stupid
07:20:53 <shachaf> lightstep: There's foldr.
07:20:56 <b_jonas> well, let's hoogle its type
07:20:58 <dcoutts_> waern: which is exactly what one ends up with if you unlit
07:21:00 <EvilTerran> there isn't such a thing for lists, tho
07:21:01 <shachaf> lightstep: There's maybe . listToMaybe. :-)
07:21:20 <LoganCapaldo> list (null (fiip const)) False
07:21:26 <LoganCapaldo> if there was a list
07:21:27 <waern> dcoutt_: aha
07:21:42 * LoganCapaldo wants a list
07:22:01 <waern> dcoutts_: I'm not sure what haddock 2.0 would say about that
07:22:03 <b_jonas> @hoogle [a] -> (b, a -> [a] -> b)
07:22:04 <lambdabot> No matches, try a more general search
07:22:10 <b_jonas> @hoogle [a] -> (a -> [a] -> b, b)
07:22:10 <lambdabot> No matches, try a more general search
07:22:23 <waern> dcoutts_: but I'm guessing it might actually work
07:22:33 <dcoutts_> waern: and we'd want to use our unlit for haddock-2.0 too I think since that'll allow haddock markup in .lhs files
07:23:03 <dcoutts_> waern: where as if haddock-2.0/ghc does the unlit then it discards comments
07:23:07 <sizur> dcoutts_, haddock2 doesnt do a literate preprocess?
07:23:23 <dcoutts_> sizur: it does, but it replaces comment lines with blank
07:23:32 <dcoutts_> sizur: that's what standard unlit does
07:23:43 <LoganCapaldo> > let list (x:xs) f d = f x xs ; list _ _ d = d in list [2] (null . (flip const)) False
07:23:43 <lambdabot>  Couldn't match expected type `[a]' against inferred type `a1 -> a1'
07:23:44 <dcoutts_> but some people want to use .lhs and use haddock markup
07:24:00 <waern> dcoutts_: hmm... are you talking about haddock commens that are not in a source code section?
07:24:00 <dcoutts_> which requires preserving comments in a form haddock will understand
07:24:01 <sizur> dcoutts_, i'd love that
07:24:08 <dcoutts_> waern: exactly
07:24:09 * LoganCapaldo goes back to getting coffee
07:24:18 <waern> dcoutts_: ok ok
07:24:29 <dcoutts_> waern: so you don't have to use: > -- this is a comment
07:24:35 <waern> right
07:24:46 <litb> > let lenth1 xs = length (do { [x] <- [xs]; return x }) == 1 in length [2]
07:24:46 <lambdabot>  1
07:24:48 <litb> :p
07:24:51 <sizur> hmm, how would you do it then?
07:24:59 <dcoutts_> this is a comment
07:25:01 <dcoutts_> > code
07:25:01 <lambdabot>   Not in scope: `code'
07:25:03 <litb> oh, hehe
07:25:07 <dcoutts_> though with a blank line
07:25:13 <sizur> but haddock is not literate
07:25:23 <dcoutts_> sizur: oh and you'd have to use | on that first line
07:25:24 <sizur> it's just api doc
07:25:29 <dcoutts_> | start of haddock comment
07:25:32 <dcoutts_> (blank line)
07:25:36 <dcoutts_> > some code
07:25:36 <lambdabot>   Not in scope: `code'
07:25:44 <shachaf> If you made an instance Num [()] you could use (==1) . genericLength. :-)
07:25:48 <litb> > let length1 xs = length (do { [x] <- [xs]; return x }) == 1 in (length1 [2], length1 [1, 2], length1 [])
07:25:48 <lambdabot>  (True,False,False)
07:25:52 <litb> yeah :)
07:26:13 <dcoutts_> sizur: the point is, Cabal's unlit converts that to -- | start of haddock comment
07:26:18 <sizur> so as it stands right now i can do \begin{code}\n -- | comment\n func = ...?
07:26:33 <dcoutts_> sizur: that's always worked, yes
07:26:39 <EvilTerran> shachaf, someone suggested using peano numbers a minute ago, yeah
07:26:45 <dcoutts_> sizur: putting comments inside the code sections
07:26:56 <dcoutts_> sizur: we want to put comments in the comment sections
07:27:03 <dcoutts_> and use haddock markup
07:27:06 <shachaf> EvilTerran: Oh, I must've missed that, sorry. :-)
07:27:13 <EvilTerran> :)
07:27:20 <sizur> dcoutts_, i actually see no reason putting haddock comments inside literate comments
07:27:37 <dcoutts_> waern: see takusen, it's a nice style
07:27:57 <dcoutts_> sizur: why not? because you see no reason to use literate comments at all?
07:28:07 <Deewiant> @pl length1 xs = length (xs >>= \x -> return x) == 1
07:28:07 <lambdabot> length1 = (1 ==) . length
07:28:33 <sizur> dcoutts_, hmm, i'm using literate comments to explain the code, and haddock as reference
07:28:37 <dcoutts_> sizur: it's pretty annoying if you use the bird track style of .lhs file
07:28:41 <nominolo_> @seen ekidd
07:28:41 <lambdabot> I haven't seen ekidd.
07:28:45 <dcoutts_> > -- having to use this style
07:28:45 <lambdabot>   parse error on input `}'
07:29:18 <EvilTerran> isn't it even "> -- |"?
07:29:38 <Deewiant> @type some
07:29:39 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
07:29:43 <dcoutts_> waern, sizur: see for example http://darcs.haskell.org/takusen/Database/InternalEnumerator.lhs
07:29:48 <EvilTerran> whoa, stream of punctuation - i'm getting perl flashbacks now :P
07:29:55 <sizur> well, actually i find no reason for ">" either, but it must be only me as ppl use it.
07:30:30 <dcoutts_> waern: and note that the '.' on blank lines is from an older unlit they were using, we do not require that.
07:30:40 <sizur> i like to have my haskell compiles as pdf :)
07:30:43 <sizur> compiled*
07:30:50 <RudolfRentier> hoi
07:32:05 <Deewiant> where's that 'some' function from, looks scary :-P
07:32:31 <RudolfRentier> in gtk2hs, what is the purpose of update functions for attributes? when are they actually called? (i thought when the widget is redrawn, but that didn't happen (?!))
07:32:38 <EvilTerran> Deewiant, Control.Applicative
07:33:20 <dcoutts_> RudolfRentier: oh, they're just a convenience for doing: do v <- get obj attr; set obj [ attr := f v ]
07:33:23 <Deewiant> Of course, where all scary-looking functions come from. :-)
07:33:44 <EvilTerran> you're forgetting Control.Arrow
07:33:45 <waern> dcoutts_: I just checked, haddock 2 has the same problem in this regard
07:33:50 <RudolfRentier> dcoutts_: oh :-( okay, nevermind then
07:33:58 <dcoutts_> RudolfRentier: instead you can do: set obj [ attr :~ f ]  (I think that's the right symbol)
07:34:44 <litb> hm, lambdabot doesn't pointfree a do {.. }
07:35:02 <EvilTerran> @help undo
07:35:02 <lambdabot> undo <expr>
07:35:03 <Deewiant> just turn it into >>s
07:35:03 <lambdabot> Translate do notation to Monad operators.
07:35:08 <Deewiant> oh, cool
07:35:12 <dcoutts_> waern: it's tricky since normally you'd expect the comments at the same indentation level as the code, but when unliting we don't get that since '>' gets replaced with ' ', and usually people use "> then the code" anyway, ie an extra space.
07:35:14 <waern> dcoutts_: they are layout-ed just like all other tokens by the ghc lexer
07:35:47 <dcoutts_> waern: and of course the indentation is different for \begin{code} vs bird track style!
07:35:50 <EvilTerran> @. pl undo \x -> do { y <- x; return (x,y) }
07:35:50 <lambdabot> ap (>>=) ((return .) . (,))
07:35:52 <waern> dcoutts_: yes, I see
07:36:16 <dcoutts_> waern: \being{code} usually uses no indentation and > uses 2 normally (though it can be just 1)
07:36:20 <Deewiant> @. pl undo \xs -> do { [x] <- [xs]; return x }
07:36:20 <lambdabot> (line 1, column 35):
07:36:20 <lambdabot> unexpected "{"
07:36:20 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
07:36:20 <b_jonas> "bird track" wow
07:36:31 <Deewiant> meh, can't handle case expressions either
07:36:33 <litb> ah i see
07:36:43 <waern> dcoutts_: so, this might be hacky, but couldn't we just look at the identation level of the code?
07:36:44 <brr> hello
07:36:48 <EvilTerran> b_jonas, after richard bird
07:36:59 <dcoutts_> b_jonas: that's their standard name, since they look like bird tracks and invented by professor Bird
07:37:07 <EvilTerran> Deewiant, how exactly would you pointsfree a case expression?
07:37:09 <litb> @undo do { [x] <- [xs]; return x }
07:37:10 <lambdabot> [xs] >>= \ a -> case a of { [x] -> return x; _ -> fail ""}
07:37:23 <waern> dcoutts_: making haddock accept mis-indented comments would mean lots of changes to the parser
07:37:28 <dcoutts_> EvilTerran: church encode the data :-)
07:37:34 <Botje> @src fail []
07:37:34 <lambdabot> Source not found. My mind is going. I can feel it.
07:37:39 <dcoutts_> waern: hmm, I can believe it
07:37:40 <EvilTerran> @src [] fail
07:37:40 <lambdabot> fail _      = []
07:37:43 <Botje> gah :)
07:37:46 <litb> > let length1 xs = length ([xs] >>= \ a -> case a of { [x] -> return x; _ -> fail ""}) == 1 in (length1 [2], length1 [1, 2], length1 [])
07:37:47 <lambdabot>  (True,False,False)
07:37:58 <dcoutts_> waern: could you write back and make that point
07:38:09 <Deewiant> @pl length1 xs = length (xs >>= \x -> return x) == 1
07:38:09 <lambdabot> length1 = (1 ==) . length
07:38:15 <EvilTerran>  @src is _always_ "@src <instance> <method>" for class methods
07:38:16 <waern> dcoutts_: since currently haddock declarations are separated with ";" just like any other declaration (that's not ideal design though)
07:38:27 <litb> @pl (\ xs -> length ([xs] >>= \ a -> case a of { [x] -> return x; _ -> fail ""}) == 1)
07:38:27 <lambdabot> (line 1, column 44):
07:38:27 <lambdabot> unexpected "{"
07:38:27 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or ")"
07:38:30 <litb> hm
07:38:40 <EvilTerran> Deewiant, er, (xs >>= \x -> return x) = id
07:38:51 <Deewiant> EvilTerran: I know, that's litb's definition :-P
07:38:54 <EvilTerran> by the monad laws
07:38:59 <litb> Deewiant: hm, no
07:39:20 <litb> Deewiant: i did pattern matching you not afais
07:39:22 <EvilTerran> litb, to quote myself a minute ago, "how exactly would you pointsfree a case expression?"
07:39:33 <dcoutts_> EvilTerran: like 'maybe' that gives you a case expression on Maybe right?
07:39:33 <litb> EvilTerran: oh sorry, i missed that
07:39:37 <litb> EvilTerran: i don't know :)
07:39:40 <EvilTerran> dcoutts_, I know, i know
07:39:44 <Deewiant> litb: yeah, essentially that's just a simplification of that which removes the useless pattern matching, or?
07:39:50 <litb> EvilTerran: i hoped lambdabot knows
07:39:56 <dcoutts_> that's because 'maybe' is like the church encoding of the Maybe data type
07:39:57 <EvilTerran> dcoutts_, but you'd need one for every data type, and you can't construct *that* pointsfree
07:40:08 <dcoutts_> EvilTerran: you can :-)
07:40:20 <EvilTerran> well, somewhere you've got to have points
07:40:26 <litb> Deewiant: i did patternmatching so that it fails if the list is >1 elements big, and calls fail that gives [] in the list monad, and the length of that is 0 then
07:40:41 <Deewiant> litb: O_o. :-P
07:40:42 <dcoutts_> EvilTerran: maybe is only written using case because it's working on a standard data type representation rather than a church encoding
07:40:51 <shachaf> litb: If you can do pattern-matching, you can just define the function as a case. :-)
07:41:00 <litb> Deewiant: just doing silly stuff i know o.O
07:41:04 <EvilTerran> dcoutts_, that's all well-and-good, but if you're working with standard data type representations already...
07:41:06 <dcoutts_> EvilTerran: ok, i'm not so sure about a point free, but certainly an applicative style
07:41:16 <Deewiant> litb: good point, didn't realize that [x] isn't always a match
07:41:17 <dcoutts_> EvilTerran: then yes, you have to use case sometimes
07:41:21 <litb> shachaf: i see
07:41:30 <litb> Deewiant: :)
07:41:42 <dcoutts_> or functions defined over patters, which is equivalent
07:41:49 <shachaf> @pl \x -> if null x then False else null (tail x)
07:41:49 <lambdabot> ap (flip if' False . null) (null . tail)
07:42:02 * shachaf still likes EvilTerran's definition.
07:42:02 <EvilTerran> dcoutts_, and that's what @pl is generally used for. the average punter doesn't use church encodings for much. :P
07:42:34 <EvilTerran> shachaf, er, what? \xs -> not (null xs) && null (tail xs) ?
07:42:52 <shachaf> EvilTerran: The @pl-ed one.
07:43:01 <EvilTerran> @pl \xs -> not (null xs) && null (tail xs)
07:43:01 <lambdabot> ap ((&&) . not . null) (null . tail)
07:43:02 <Deewiant> > map (\x -> if null x then False else null (tail x)) [[], [1], [1,2], [1..]]
07:43:03 <lambdabot>  [False,True,False,False]
07:43:06 <olsner> EvilTerran: isn't that (== 1) . length?
07:43:10 <shachaf> liftA2 (&&) (not.null) (null.tail)
07:43:18 <EvilTerran> olsner, well, yes, but it works for infinite lists too
07:43:25 <shachaf> olsner: For infinite lists, with regular numbers?
07:43:27 <Saizan> pl could just assume there's a method chuch that gives the chuch encoding :)
07:43:40 <olsner> shachaf: oh, didn't think of that
07:43:55 <dcoutts_> or use lazy natural numbers :-)
07:44:13 <shachaf> dcoutts_: Then it would be genericLength. :-)
07:44:14 <EvilTerran> ?pl \null -> liftA2 (&&) (not.null) (null.tail)
07:44:14 <lambdabot> ap (liftA2 (&&) . (not .)) (. tail)
07:44:15 <olsner> (matches [_])
07:44:22 <dcoutts_> shachaf: yes, true
07:44:35 <olsner> (in DWIM haskell, that is)
07:44:57 <litb> once getting haskell, it seems to be lot of fun playing around with it :)
07:44:59 <EvilTerran> ?type (liftA2.liftA2) (&&) (not.) (.tail) null
07:45:00 <lambdabot> forall a. [a] -> Bool
07:45:08 <EvilTerran> muhahaha
07:45:11 <Deewiant> O_o
07:45:30 <EvilTerran> ?unpl \null -> (liftA2.liftA2) (&&) (not.) (.tail) null
07:45:30 <lambdabot> \ null -> liftA2 (liftA2 (&&)) (\ a h -> not (a h)) (\ b k -> b (tail k)) null
07:45:37 <EvilTerran> hm. never mind.
07:45:51 <Deewiant> ((liftA2.liftA2) (&&) (not.) (.tail) null) [[], [1], [1,2], [1..]]
07:45:58 <shachaf> EvilTerran: Why \null?
07:45:58 <Deewiant> > map ((liftA2.liftA2) (&&) (not.) (.tail) null) [[], [1], [1,2], [1..]]
07:45:59 <lambdabot>  [False,True,False,False]
07:46:34 <shachaf> Because it's used twice? :-)
07:46:42 <brr> hate to interrupt this interesting discussion... but does anyone know how to use poke?
07:46:47 <EvilTerran> shachaf, er, momentary confusion, as it's necessary for pl if you want it to eliminate a term
07:46:56 <EvilTerran> brr, in what context?
07:47:08 <litb> @type poke
07:47:08 <lambdabot> Not in scope: `poke'
07:47:09 <brr> i wanna poke something thats mmapd
07:47:10 <LoganCapaldo> basiic?
07:47:19 <brr> ByteString
07:47:50 <shachaf> EvilTerran: Are you using liftA2.liftA2 because you had null twice?
07:48:00 <dcoutts_> brr: ByteStrings are immutable, not suitable if you want to modify a mmaped memory area
07:48:11 <EvilTerran> shachaf, yes, the second liftA2 was to eliminate the null
07:48:12 <olsner> LoganCapaldo: ah, the good old days, when dynamic languages included operations for mucking with random memory adresses
07:48:15 <shachaf> EvilTerran: (Now you have liftA2 twice... :-) )
07:48:21 <brr> what are my options to mmap if not bytestring?
07:48:34 <shachaf> EvilTerran: Why were you trying to eliminate it?
07:48:36 <EvilTerran> ?type join (.) (&&) (not.) (.tail) null
07:48:37 <lambdabot>     Couldn't match expected type `t -> t1 -> t2'
07:48:37 <lambdabot>            against inferred type `Bool'
07:48:37 <lambdabot>     Probable cause: `&&' is applied to too many arguments
07:48:41 <olsner> @pl \liftA2 -> (liftA2.liftA2) (&&) (not.) (.tail) null
07:48:41 <lambdabot> flip (flip (flip (flip (join (.)) (&&)) (not .)) (. tail)) null
07:48:47 <EvilTerran> ?type join (.) liftA2 (&&) (not.) (.tail) null
07:48:48 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
07:48:48 <lambdabot>     Probable cause: `liftA2' is applied to too many arguments
07:48:48 <lambdabot>     In the second argument of `join', namely `liftA2'
07:48:53 <dcoutts_> brr: perhaps you want to see an FFI tutorial which will cover the Storable class (which includes poke)
07:48:55 <EvilTerran> grah
07:48:56 <litb> olsner: oh you can pattern match on functions?
07:48:57 <shachaf> EvilTerran: I don't think that'd work.
07:48:59 <shachaf> @ty join (.)
07:49:00 <lambdabot> forall b. (b -> b) -> b -> b
07:49:05 <EvilTerran> shachaf, because obfuscation is amusing
07:49:15 <dcoutts_> brr: a Ptr or a ForeignPtr or a Storable array
07:49:33 <brr> thanks, dcoutts, i'll look into it.
07:49:34 <EvilTerran> yeah, the type system's not clever enough for that one :P
07:49:47 <olsner> litb: eh, no, that was just hypothetical syntax sugar ;-)
07:50:16 <EvilTerran> litb, "liftA2" is a name just like any other
07:50:17 <shachaf> EvilTerran: Is there no way of writing that nicely?
07:50:22 <EvilTerran> > let map = 1 in map
07:50:23 <lambdabot>  1
07:50:24 <shachaf> Perhaps with type classes?
07:50:28 <litb> anyway, i will no really going to learn for examination
07:50:31 <litb> EvilTerran: ah i understand
07:50:55 <EvilTerran> shachaf, what, (\x -> x.x) in a way that works for types other than a->a?
07:51:07 <shachaf> EvilTerran: Yes.
07:51:10 <olsner> litb: yeah, that was just a normal lambda creating a new binding for an old name... (my previous answer was for another interpretation of the question)
07:51:22 <EvilTerran> yes, you could do something with typeclasses, or with parameterised types
07:51:43 <EvilTerran> but it'd be restricted to only one typeclass in the first case, and result in newtype hell in the second
07:51:44 <shachaf> EvilTerran: Take a simpler example, like join (.) (:[]).
07:51:45 <olsner> (I was answering about (matches [_]), which is something that haskell does not have)
07:52:26 <shachaf> EvilTerran: :-(
07:53:33 <EvilTerran> shachaf, i've had discussions about similar things several times recently, actually
07:54:15 <EvilTerran> in previous cases it was that you can't have differently-typed x and y in "app2 f (x,y) = (f x, f y)" without rank-2 types
07:54:42 <EvilTerran> and, even with rank-2, either they have to be in the same typeclass, or you have to do some funk with parameterised types
07:54:54 <EvilTerran> (or you can't do anything with the values)
07:55:15 <EvilTerran> it's much the same problem, really
07:57:06 <litb> Deewiant: i like this better tho :) length1 xs = isJust (do { [_] <- return xs; return True })
07:57:18 <Deewiant> O_o
07:57:28 <EvilTerran> litb, but then you've got a pattern, and you might as well do normal pattern-matching...
07:57:54 <litb> oh rite. darn. but it's using teh monad as all cool kinds do today :p
07:58:21 <shachaf> litb: It's using *fail*.
07:58:39 <shachaf> litb: If it used mzero, somebody might forgive you.
07:59:34 <roconnor> http://math.andrej.com/wp-content/uploads/2008/02/Hydra/hydraApplet.html
07:59:36 <lambdabot> Title: The Hydra game, http://tinyurl.com/yt6rmm
08:01:31 <roconnor> I won!
08:01:42 <litb> i fail
08:04:03 <Deewiant> gets slow after 10000 heads :-P
08:04:52 <roconnor> keep hacking at it :P
08:05:08 <Deewiant> nah, grows a bit too fast if you let it go past 100 :-P
08:05:49 <olsner> @src otherwise
08:05:49 <lambdabot> otherwise = True
08:06:03 <roconnor> Deewiant: oh noes, 7951 heads
08:06:08 <Deewiant> heh
08:06:31 <EvilTerran> ... is there a strategy there?
08:06:34 <roconnor> I hope PA is consistent. *slice, slice*
08:06:50 <EvilTerran> it looks like it might be some representation of \calc or something
08:07:00 <roconnor> EvilTerran: if PA is consistent then any strategy works.
08:07:04 <EvilTerran> PA?
08:07:08 <roconnor> Peano Arithmetic.
08:07:14 <Deewiant> http://math.andrej.com/wp-content/uploads/2008/02/Hydra/README.txt
08:07:15 <lambdabot> http://tinyurl.com/yts8qf
08:07:22 <shachaf> roconnor: That Java applet just crashed X for me. :-(
08:07:29 <roconnor> if PA isn't  consistent, god help us all.
08:07:29 <litb> uh
08:07:40 <EvilTerran> i see
08:09:20 <roconnor> @bab nl en piment
08:09:21 <lambdabot>   piment
08:10:01 <Deewiant> @help bab
08:10:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:10:08 <Deewiant> erm
08:10:17 <litb> hm
08:10:22 <litb> @help bab nl
08:10:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:10:41 <roconnor> allspice
08:10:48 <olsner> @pl uncurry (flip (f . const))
08:10:48 <lambdabot> uncurry (flip (f . const))
08:10:49 <shachaf> @help babel
08:10:50 <lambdabot> babel <lang1> <lang2> <phrase>.
08:10:50 <Deewiant> my guess is it does translation based on a language code, as in bab[elfish]
08:10:50 <lambdabot> Translate a phrase in lang1 to lang2.
08:10:50 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
08:10:53 <olsner> @unpl uncurry (flip (f . const))
08:10:53 <lambdabot> uncurry (\ b c -> f (\ _ -> c) b)
08:11:02 <olsner> @pl uncurry (\ b c -> f (\ _ -> c) b)
08:11:02 <lambdabot> uncurry (flip (f . const))
08:11:10 <roconnor> unallspice
08:11:32 <olsner> spiceItUp
08:11:36 <Deewiant> @pl \f -> uncurry (flip (f . const))
08:11:36 <lambdabot> uncurry . flip . (. const)
08:11:46 <Deewiant> @unpl \f -> uncurry (flip (f . const))
08:11:46 <lambdabot> \ f -> uncurry (\ b c -> f (\ _ -> c) b)
08:12:13 <Deewiant> anybody managed to get \b e e t h o v e n from djinn yet?
08:13:11 <olsner> @quote djinn
08:13:11 <lambdabot> djinn says: does not do lists
08:13:13 <olsner> @quote djinn
08:13:13 <lambdabot> djinn says: does not do lists
08:13:26 <shachaf> Deewiant: \e e?
08:13:38 <shachaf> > \@ty e -> e
08:13:38 <lambdabot>  Parse error at "->" (column 8)
08:13:42 <shachaf> @ty e -> e
08:13:43 <lambdabot> <command line>:
08:13:43 <lambdabot>     Could not find module `L':
08:13:43 <lambdabot>       Use -v to see a list of the files searched for.
08:13:46 <shachaf> @ty \e -> e
08:13:46 <Deewiant> @ty \e e -> e
08:13:46 <lambdabot> forall t. t -> t
08:13:47 <lambdabot>     Conflicting definitions for `e'
08:13:47 <lambdabot>     In a lambda abstraction
08:13:49 <Deewiant> meh
08:13:58 <Deewiant> well, \m o z a r t then. :-P
08:15:20 <EvilTerran> i think it's going to need repeated use of the compose operator
08:15:23 <idnar> you'd need a lot of _
08:15:31 <EvilTerran> *badum-chh*
08:15:55 <idnar> er wait, no
08:16:06 <shachaf> Oops.
08:16:13 <idnar> EvilTerran: hahaha
08:16:16 <shachaf> Looks like @djinn doesn't use @more...
08:24:26 <litb> one question
08:24:42 <litb> can i somehow "link" into the do notation?
08:24:53 <olsner> link into?
08:25:02 <EvilTerran> litb, you can define your own monad, if that's what you mean
08:25:12 <litb> i mean in "do { e<- ... }" if i now give an argument to that, can i have the argument be placed into the ... ?
08:25:20 <litb> so that i could put the do into a (.) ?
08:25:33 <EvilTerran> ah... no, you have to use a \ or something
08:25:41 <olsner> you'd have to un-do the do-block or add a lambda around it
08:25:42 <EvilTerran> or explicit monad operators
08:25:55 <litb> alrite
08:26:27 <litb> would be nice if do had a form like "do (x) { e <- e; ... }"
08:27:14 <LoganCapaldo> @type do { e <- ?x ; return e }
08:27:14 <lambdabot> forall (t :: * -> *) t1. (?x::t t1, Monad t) => t t1
08:27:18 <EvilTerran> i did once suggest "do x -> { ... }", but people managed to convince me that "\x -> do { ... }" is perfectly adequate
08:27:25 <kosmikus> what's the problem with (\ x -> do { ... }) x
08:27:47 <olsner> now, if haskell had some extension for implicit lambda-ification of arbitrary expressions
08:27:56 <EvilTerran> olsner, ew
08:28:17 <EvilTerran> altho there is linear implicit parameters (like what LoganCapaldo just did)
08:28:17 <wli> kosmikus: Can I make a feature request?
08:28:29 <kosmikus> requests are always possible ;)
08:28:52 <litb> what is that what LoganCapaldo just did?
08:29:10 <EvilTerran> ?type ?x
08:29:11 <lambdabot> forall t. (?x::t) => t
08:29:14 <litb> the ?x looks strange to me
08:29:15 <desegnis> litb: Implicit parameters
08:29:19 <EvilTerran> ?type let ?x = 1 in ?x
08:29:20 <lambdabot> forall t. (Num t) => t
08:29:26 <desegnis> litb: One of those crazy extensions
08:29:28 <LoganCapaldo> > let z = ?x + 1 in let ?x = 4 in z
08:29:28 <lambdabot>  Parse error at "?x" (column 9)
08:29:33 <LoganCapaldo> mm
08:29:37 <EvilTerran> ?type let f = ?x + 1 in f
08:29:37 <lambdabot> forall a. (Num a, ?x::a) => a
08:29:38 <LoganCapaldo> I don't really know how to use 'e
08:29:42 <LoganCapaldo> *'em
08:29:44 <wli> kosmikus: Could I get an lhs2TeX option to omit the boilerplate at the beginning of the generated TeX file and maybe another to spit the boilerplate out in isolation? It'd make multi-module literate programs a lot easier.
08:29:49 <EvilTerran> ?type let f = ?x + 1 in let ?x = 2 in f
08:29:50 <lambdabot> forall a. (Num a, ?x::a) => a
08:30:07 <litb> > let x = ?y + 1 in x 2
08:30:08 <wli> kosmikus: (I think this is an easy request.)
08:30:08 <lambdabot>  Parse error at "?y" (column 9)
08:30:15 <litb> meh
08:30:26 <EvilTerran> litb, you bind a LIP with let
08:30:34 <kosmikus> wli: hmmm
08:30:44 <EvilTerran> litb, but regardless, > won't do it - haskell98 only
08:30:58 <litb> oh i see
08:31:13 <kosmikus> wli: I don't think it's that easy. Define "boilerplate". lhs2TeX doesn't know what is and what's not.
08:31:19 <LoganCapaldo> @type let z = ?x + 1 in let ?x = 3 in z
08:31:20 <lambdabot> forall a. (Num a, ?x::a) => a
08:31:29 <kosmikus> wli: also, what's the problem with multi-module programs?
08:32:36 <wli> kosmikus: It's the generated TeX, not the Haskell. There's a bunch of stuff that's always the same right at the beginning of the generated LaTeX file.
08:33:25 <kosmikus> wli: but that's not hardcoded. it's what you include with %include lhs2TeX.fmt or something alike.
08:33:54 <kosmikus> wli: but it shouldn't cause any problem for multi-module programs.
08:34:44 <wli> kosmikus: When I do \include{ModuleOne} \include{ModuleTwo} I get errors from redefinition/etc. of things in the boilerplate. My solution thus far is hand-editing. If omitting the %include directive will already do it I'm set.
08:35:46 <kosmikus> wli: what you describe should just work
08:36:49 <Japsu> @pl return . sum
08:36:49 <lambdabot> return . sum
08:37:16 <Japsu> @pl return . (>>= sum) -- liftM sum?
08:37:16 <lambdabot> return . (sum =<<)
08:37:30 <Japsu> :t liftM
08:37:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:37:58 <Japsu> @src replicateM
08:37:58 <lambdabot> replicateM n x = sequence (replicate n x)
08:38:01 <wli> I'll upgrade and try it again.
08:40:58 <kosmikus> wli: which version are you using?
08:41:48 <kosmikus> wli: basically, the first two questions in the FAQ at the end of the documentation are relevant; the answers are pretty short, but the way described there should work.
08:42:12 <wli> I think the last I tried was 1.12; I should've found it in the FAQ, sorry.
08:43:02 <kosmikus> wli: 1.12 should be ok. 1.13 mainly changes ghc and cabal compatibility
08:44:51 <mainland> Does 1.13 still have the --> lexing bug?
08:45:16 <EvilTerran> > lex "-->"
08:45:17 <lambdabot>  [("-->","")]
08:45:25 <EvilTerran> > lex "-- comment?"
08:45:25 <lambdabot>  [("--"," comment?")]
08:45:34 <EvilTerran> nvm
08:45:42 <litb> @hoogle replicateM
08:45:43 <lambdabot> Control.Monad.replicateM :: Monad m => Int -> m a -> m [a]
08:45:43 <lambdabot> Control.Monad.replicateM_ :: Monad m => Int -> m a -> m ()
08:45:50 <Japsu> @pl (fst >>> id) &&& (snd >>> map snd)
08:45:51 <lambdabot> fst >>> id &&& (snd >>> map snd)
08:46:27 <kosmikus> mainland: actually, I think I fixed something like that
08:46:36 <EvilTerran> @unpl (fst >>> id) &&& (snd >>> map snd)
08:46:36 <lambdabot> ((fst >>> \ a -> a) &&& (snd >>> (map snd)))
08:46:48 <Japsu> @index lex
08:46:49 <lambdabot> Text.Read, Prelude, Text.Read.Lex
08:47:15 <mainland> kosmikus: i'll check it out and send a patch if it's not fixed...been meaning to send the patch for a while now
08:47:20 <olsner> @pl \a b -> f a >> return b
08:47:20 <lambdabot> (. return) . (>>) . f
08:47:42 <litb> woo replicateM used with list monad is fun
08:47:54 <conal> :ty (fst >>> id) &&& (snd >>> map snd)
08:47:56 <Japsu> sounds inherently incomprehensible
08:47:59 <Japsu> +like
08:48:07 <conal> :ty second (map snd)
08:48:15 <Japsu> :t (fst >>> id) &&& (snd >>> map snd)
08:48:16 <conal> no lb?
08:48:16 <lambdabot> forall a a1 b. (a, [(a1, b)]) -> (a, [b])
08:48:18 <EvilTerran> i think you want :t or ?Type
08:48:21 <conal> oh.
08:48:36 <kosmikus> mainland: I think it's fixed.
08:48:39 <EvilTerran> (>>>) is a generalisation of flip (.), right?
08:48:50 <conal> :t second (map snd)
08:48:51 <lambdabot> forall a b d. (d, [(a, b)]) -> (d, [b])
08:48:57 <Japsu> I have ([(a,b)], [(a,b)]) but in the second list all a's are 1
08:49:09 <kosmikus> mainland: although, if I recall correctly, it still doesn't implement Haskell's lexing behaviour faithfully.
08:49:44 <Japsu> because it's the result of partition (fst >>> (>1))
08:49:53 <litb> i like to use replicateM 4 ['a' .. 'z'] to brute-force silly passwords
08:50:14 <conal> @seen roconnor
08:50:14 <lambdabot> roconnor is in #oasis and #haskell. I last heard roconnor speak 39m 4s ago.
08:51:17 <wli> replicateM looks handy.
08:51:35 <conal> can someone explain how 'evaluate a' differs semantically from 'a `seq` return a' ?
08:52:04 <litb> @src seq
08:52:04 <lambdabot> Source not found.
08:52:07 <olsner> @src evaluate
08:52:07 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
08:52:13 <litb> i fail
08:52:25 <EvilTerran> seq is magicks
08:52:28 <litb> i bet it's some strange whatnot instance
08:52:38 <sclv> seq is a primative
08:52:41 <oerjan> there's something on the doc page, i recall
08:53:17 <oerjan> @index evaluate
08:53:17 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
08:53:40 <litb> @index replicateM
08:53:41 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:53:44 <conal> doc: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Aevaluate
08:53:45 <lambdabot> http://tinyurl.com/yk8zqb
08:53:45 <litb> ah, handy
08:54:03 <conal> i guess the difference is that evaluate only forces in IO contexts, but not in general.
08:54:19 <oerjan> evaluate x `seq` y    ==>  y
08:54:27 <conal> yeah
08:54:36 <conal> doesn't force x then
08:55:22 <conal> so why would anyone use evaluate in that context?
08:55:25 <ddarius> conal: evaluate (return undefined) `seq` 1 = 1     (undefined `seq` return undefined) `seq` 1 = undefined
08:56:00 <litb> what does seq do anyway?
08:56:10 <conal> ddarius: yep.  but why use it?
08:56:37 <litb> it seems to be flip const
08:56:38 <conal> ddarius: i.e., by use evaluate on the rhs of seq?
08:56:51 <oerjan> litb: seq undefined x = undefined, seq _ x = x, essentially
08:56:52 <ddarius> conal: You want to catch an exception from pure code when an IO action is executed, not when it is evaluated.
08:57:01 <roconnor> conal: seq is evil because it destroys paramicity.
08:57:08 <roconnor> or something like that
08:57:21 <litb> ah i'm sorry. missed the definition above
08:57:36 <ddarius> @free seq
08:57:36 <lambdabot> g . seq x = seq (f x) . g
08:57:45 <conal> oh.... now i'm starting to get it
08:58:33 <wli> Parametricity?
08:58:35 <roconnor> see, that just isn't true :)
08:58:46 <litb> hm, is there some good paper/tut explaining how showsPrec works?
08:58:57 <litb> so far i only know that it has something todo with parens
08:59:21 <litb> anyway, going out for some time, write read you later
08:59:45 <litb> lolnice nick, what about flpi :)
09:00:35 <roconnor> conal: I was reading your blog post about Futures with Threads, but I don't get what your problem with simultaneouslyness is.
09:00:38 <oerjan> from the report: "The Int argument to showsPrec and readsPrec gives the operator precedence of the enclosing context (see Section 10.4)."
09:00:52 <conal> roconnor: thanks for the blog tip.  in case anyone else cares: http://conal.net/blog/posts/future-values-via-multi-threading/#comment-32
09:00:54 <lambdabot> http://tinyurl.com/2gt79c
09:00:58 <litb> oerjan: sounds confusing :)
09:01:02 <conal> roconnor: problem with simultaneouslyness?
09:01:17 <roconnor> ``This last piece of the implementation can fall short of the semantics. For a `mappend` b, we might get b instead of a even if theyâ€™re available simultaneously.
09:01:27 <conal> roconnor: why it matters which occurrence is chosen when they're simultaneous?
09:01:36 <conal> (s/occurrence/future)
09:01:44 <litb> i've seen it used by augustss for his symbolic lib
09:01:46 <roconnor> conal: There is no notion of simultaneous.
09:01:53 <roconnor> conal: Einstein showed that :)
09:02:10 <conal> roconnor: maybe you're thinking of distinct physical events
09:02:22 <LoganCapaldo> quick! what's the one way speed of light?
09:02:26 <roconnor> conal: IO includes physical events.
09:02:38 <roconnor> it has the RealWorld in it.
09:02:55 <litb> roconnor: u understand his theory ?
09:03:07 <oerjan> litb: see the fourth paragraph of http://haskell.org/onlinereport/derived.html#derived-text
09:03:08 <roconnor> litb: special relativity isn't hard.
09:03:12 <conal> roconnor: i'm confused.  where does IO enter the discussion?
09:03:25 <conal> roconnor: i.e., the discussion of futures
09:03:27 <litb> oerjan: i will, thanks.
09:03:27 <roconnor> data Future a = Future (IO a) | Never
09:03:36 <roconnor> right there
09:03:37 <conal> that's representation, not semantics
09:03:41 <ddarius> @go speed of light in millimeters per fortnight
09:03:41 <lambdabot> the speed of light = 3.62628957 x 10^17 millimeters per fortnight
09:03:58 <conal> the semantics is pure -- no IO
09:04:08 <olsner> @go speed of light in feet per nanosecond
09:04:08 <lambdabot> the speed of light = 0.983571056 feet per nanosecond
09:04:16 <roconnor> conal: are you saying you are only using IO to get multithreaded support?
09:04:51 <oerjan> ddarius: furlongs per fortnight, surely?
09:05:03 <roconnor> conal: but you give examples like ``how many tries it will take me to blow out all the candles on my next birthday cake''
09:05:05 <roconnor> that is IO.
09:05:32 <conal> roconnor: i could give you an example of two simultaneous futures.
09:06:00 <conal> 'foo' and '(*2) <$> foo'
09:06:03 <roconnor> conal: oh, two futures that are the same future
09:06:09 <roconnor> or derived from the same event.
09:06:15 <conal> exactly!
09:06:15 <roconnor> ... okay
09:06:25 <roconnor> yep, those are simultaneous.
09:06:27 <litb> ive a good lung
09:06:36 <conal> because futures are compositional
09:06:50 <roconnor> conal: I thought you were worried about independent simultaneous events.
09:07:00 <conal> i am
09:07:12 <conal> oh -- independent .  no i'm not
09:07:24 <roconnor> conal: okay, I'm with you now.
09:07:45 <proppy> anyone has manage to compile yi 0.3 (or darcs head) ?
09:07:47 <conal> roconnor: i'll edit the post to be clearer.  thanks.
09:07:57 <litb> augustss seems to have probs :)
09:07:58 <hpaste>  proppy pasted "yi build error" at http://hpaste.org/5412
09:07:59 <roconnor> and the worse worry is that delay (1 ns) x and x may return the later one as first.
09:08:21 <roconnor> even though they are dependent events where one occurs strictly later than the other.
09:08:26 <roconnor> right.
09:08:51 <conal> roconnor: the future monad describes those ones, i think.
09:09:22 <roconnor> okay, now I understand.
09:10:55 <mikmik> can someone tell me where cabal keeps the "registry" of installed modules? Once I remove one of the libs it keeps complaining "can't load .so...."
09:10:59 <conal> roconnor: you're not the first to assume i meant physically independent events.  maybe people are used to thinking of these things non-compositionally.  i don't know of compositional event system other than FRP.
09:14:12 <conal> does anyone know of a non-FP compositional approach to events?
09:15:08 <LoganCapaldo> i don't
09:15:28 <LoganCapaldo> i don't even know if i know what your question is
09:17:04 <Twey> Heh
09:20:21 <conal> LoganCapaldo: thx.  I mean a way of combining events into higher level events, rather than just staying at the lowest level of *physical* events.
09:21:04 <LoganCapaldo> I don't know of one, but it is something I've bene thinking about a lot lately (in the context of guis)
09:21:09 <LoganCapaldo> stupid day job ;)
09:21:12 <conal> the notion of event is very important in some kinds of programming, but there's generally no abstraction/composition tool.
09:21:20 <conal> LoganCapaldo: yes -- especially guis
09:21:28 <conal> events are central but not first class
09:21:35 <conal> which keeps programming low-level
09:21:45 <ddarius> In a message passing system, it would be trivial to do that.
09:22:10 <conal> ddarius: by massaging and filtering messages?
09:22:59 <conal> ddarius: in such a system, is there a first-class notion of events or messages or processors of such?
09:23:35 <ddarius> There can be.
09:24:13 <paolino> is there a wa to make this work ? readFile "name" >>= writeFile "name" . (++ " something")
09:24:15 <ddarius> Usually, you would have a process that sits between you and some source of events (messages) and sends new events (messages).
09:24:34 * oerjan wonders what happens in the event of defining a class of first-class events.  but don't mind him.
09:24:39 <qwr> paolino: use strict readFile
09:25:28 <paolino> qwr , is that a kind of annotation somewhere ?
09:25:54 <shapr> @seen radix
09:25:54 <lambdabot> radix is in #haskell. I last heard radix speak 18h 9m 5s ago.
09:25:55 <paolino> on the >>= ?
09:26:28 <qwr> paolino: Data.ByteString.Char8.readFile
09:27:14 * dcoutts_ creates paolino's Hedi project workspace...
09:28:08 <paolino> qwr, I'm not using bytestrings
09:28:39 <qwr> paolino: you can unpack them into usual [Char] strings as needed
09:29:27 <dcoutts_> paolino: so what is Hedi then? sounds intriguing
09:29:29 <pejo> ddarius, what is the purpose of the middle-man that sends new events?
09:29:32 <paolino> qwr, is it possible to write a strict readFile of my own ?
09:29:50 <qwr> paolino: certainly, why would you want to do that?
09:30:09 <ddarius> pejo: It's an adapter pattern essentially.  It's not crucial, it's just an example of how you could turn lower level events into higher level ones.
09:30:17 <paolino> because , I'm coding an editor
09:30:30 <oerjan> paolino: one advantage of going via ByteStrings is that the whole file will probably take less place in memory
09:30:49 <oerjan> well, if it is big enough
09:30:56 <paolino> dcoutts, just noticed after a little while that hedi /= hide :)
09:31:32 <oerjan> this should apply even if you unpack it lazily to a String, i assume?
09:31:38 <dcoutts_> strictReadFile f = readFile f >>= \content -> evaluate (length content) >> return content
09:31:41 <ddarius> pejo: E.g. lets say I'm getting position deltas from some mouse process and I'd rather have absolute positions.  I can easily make a process that will handle those details and let me write to the interface I prefer.
09:32:00 <dcoutts_> or just fmap unpack . Data.ByteString.Char8.readFile
09:33:15 <paolino> dcoutts_: so reading last character make it close?
09:33:25 <dcoutts_> paolino: yes
09:33:26 * qwr . o O ( and the last one is essentially what i suggested before :P )
09:33:38 <radix> shapr: good day
09:33:46 <dcoutts_> qwr: yes
09:34:04 <pejo> ddarius, ah, ok. And under ideal circumstances the compiler would remove the possible overhead created by it. Neat.
09:35:39 <radix> shapr: I am searching for glyph
09:35:43 <ddarius> Rob Pike's "A Concurrent Windowing System" is the perspective I'm coming from.
09:36:01 <dblazakis> anyone have a second to help with a question about generic programming/introspection with the GHC extensions?
09:36:21 <ddarius> s/Windowing/Window
09:36:34 <paolino> :t evaluate
09:36:35 <lambdabot> Not in scope: `evaluate'
09:36:49 <oerjan> :t Control.Exception.evaluate
09:36:50 <lambdabot> forall a. a -> IO a
09:37:36 <nominolo> dcoutts_: that's in order to avoid too many build error reports
09:37:44 <nominolo> (due to bug 220
09:38:25 <dcoutts_> nominolo: oh, sure I know. I'm not blaming yi. I'm indicating it's a serious problem that needs to be solved by cabal-install so that packages do not have to hard code things like that.
09:39:08 <conal> ddarius: yes.  that's the kind of functionality i'm talking about.
09:39:40 <conal> ddarius: that's the kind of thing the event algebra in Reactive does
09:39:58 <dcoutts_> nominolo: I'm not clear why the problem happens though, since the ghc package does not expose it's use of bytestring, so there can be no api problem
09:40:05 <dcoutts_> so I don't understand what goes wrong
09:40:32 <oerjan> dblazakis: just ask the question, that's the usual procedure here - no one can know if they know the answer before you ask it :)
09:40:38 <nominolo> dcoutts_: it's somewhere in the linker
09:40:59 <Saizan> maybe some optimization is fusing a pack . unpack?
09:41:00 <dcoutts_> nominolo: in ghci's linker? then it's probably a bug.
09:41:05 <oerjan> also, hpaste if there is code involved
09:41:07 <oerjan> !paste
09:41:07 <hpaste> Haskell paste bin: http://hpaste.org/
09:41:22 <nominolo> dcoutts_: no, i mean the error occurs as a link error
09:41:31 <dblazakis> oerjan: thanks, will do
09:42:29 <dcoutts_> nominolo: the native static linker? that's pretty odd. It's perfectly possible to link two versions of a package into a program since they prefix symbols with the version.
09:42:47 <dcoutts_> nominolo: is there a description of the error message anywhere I can see?
09:43:01 <dcoutts_> nominolo: or I'll wait and try it myself, just emerging all the packages now...
09:44:05 <radix> shapr: do you have preferences for where to eat?
09:44:08 <nominolo> dcoutts_: hm, it was somewhere on hpaste
09:44:13 * radix thinks shapr wandered off
09:44:25 <BMeph> pejo: Events are also used in many game scripting environments, to allow scripts to interact with the game, without messing up the users' experiences of the game "world".
09:45:37 <dblazakis> i have an ast i want to pretty print using SPJ's lib.  i wrote a bunch of functions and a type class to do it
09:46:07 <dblazakis> it works, but i wanted to convert it to use the "scrap your boilerplate" stuff
09:46:14 <khadrin> how do i round 16.2345 to 16.23 ?
09:47:21 <oerjan> khadrin: if it is only for showing, use printf
09:47:42 <oerjan> > printf "%.2f" 16.2345 :: String
09:47:43 <lambdabot>  "16.23"
09:47:56 <khadrin> hmm ok
09:48:04 <dblazakis> i want a function to pretty print by traversing the AST, using the name of the constructor and then calling the pretty print function on each arg to the constr, form a list and then apply a function to the name of the constr and the list of Docs
09:48:05 <khadrin> :t printf
09:48:05 <lambdabot> forall r. (PrintfType r) => String -> r
09:48:48 <paolino> dcoutts_: is there web service for the projects ?
09:49:30 <khadrin> is printf in a module?
09:49:37 <oerjan> Text.Printf
09:49:39 <dcoutts_> paolino: I'm not sure what you mean
09:49:49 <oerjan> @index printf
09:49:49 <lambdabot> Text.Printf
09:50:11 <paolino> I'd like to browse the docs directory of the darcs repository
09:50:25 <dcoutts_> paolino: code.haskell.org/projectname
09:50:32 <khadrin> cool thx..is there a way to do @index from ghci?
09:51:29 <dcoutts_> paolino: the code is all available publicly via http so that people can darcs get your project code
09:51:33 <EvilTerran> khadrin, :info
09:51:40 <oerjan> don't think so, unless you install ghc-on-acid (which i don't think is very up-to-date?)
09:51:48 <pejo> BMeph, did that answer have anything to do with first class events?
09:52:23 <khadrin> EvilTerran: :info only works for me if ive already done :m Text.Printf
09:52:38 <EvilTerran> i guess that's not so helpful
09:52:39 <oerjan> you can also use hoogle
09:52:44 <oerjan> @where hoogle
09:52:44 <lambdabot> http://haskell.org/hoogle
09:52:45 <Saizan> dblazakis: looked at gfoldl?
09:52:50 <paolino> dcoutts_:the repo is code.haskell.org:projectname ? for ssh access ?
09:52:52 <EvilTerran> you can use lambdabot via pm, or hoogle, or maybe ghci-on-acid
09:52:55 <EvilTerran> @where goa
09:52:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
09:54:17 <dblazakis> Saizan: yeah, i'll have to mess with it a bit. the type sig is hard to grok
09:54:37 <BMeph> pejo: From the point of view of the script writers, events are first-class. They have to be, since the script processor runs slower than the game engine does.
09:54:38 <khadrin> cool thanks for the tips
09:54:50 <BMeph> pejo: So, "yes". :)
09:54:52 <oerjan> @version
09:54:52 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
09:54:53 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:55:23 <paolino> dcoutts_ , I mean push method , I am confused now
09:55:36 <dblazakis> another question, can i define a different type class instance for a string
09:55:45 <dblazakis> vs a list
09:56:16 <dcoutts_> paolino: darcs pull http://code.haskell.org/Hedi/  darcs push paolino@code.haskell.org:/srv/code/Hedi/
09:56:16 <lambdabot> Title: Index of /Hedi
09:56:29 <Saizan> dblazakis: you need OverlappingInstances for that
09:56:45 <Twey> @pl (\x y -> x + read y)
09:56:45 <lambdabot> (. read) . (+)
09:57:10 <Twey> Ahh
09:57:17 <dcoutts_> paolino: http://community.haskell.org/admin/using_project.html
09:57:17 <lambdabot> Title: Using Your Project
09:57:18 * Twey finally gets that usage of .
09:57:34 <dblazakis> Saizan: what is that?
09:58:35 <Saizan> dblazakis: a ghc extension, that permits you to have both an instance for [a] and for [Char], choosing the most specific
09:58:48 <dblazakis> Saizan
09:58:59 <dblazakis> Saizan: oh, thanks! i'll have to check it out
09:59:13 <bos> @seen dons
09:59:13 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 12h 53m 50s ago.
09:59:43 * BMeph goes to get breakfast and a haircut (in that order)
10:02:55 * heatsink wants to find out more about how to do type inference and checking for type systems with predicates on multiple types (like MPTCs) and subtyping.
10:03:29 <heatsink> I've read through TAPL up to the chapter on type reconstruction, and through Xi's paper on DML I found a lot of work on dependent type systems... but I don't know where to start.
10:05:57 <heatsink> Is there a book or paper where I can get an overview of the area?
10:08:28 <paolino> dcoutts_ :am I in group Hedi_p and should darcs init that /srv/code/Hedi ?
10:09:04 <ddarius> paolino: Yes, or you can just darcs put there.
10:09:35 <pejo> heatsink, Pierce and Turner, "Local type Inference" might be a good starting point?
10:09:43 * paolino never darcs putted
10:10:04 <ddarius> It's just like a darcs push only it does a darcs init first.
10:10:14 <pejo> heatsink, not a book though, but a starting point.
10:10:27 <dcoutts_> paolino: yes
10:11:11 <Twey> @pl (\ f x = x * 2 + 3 )
10:11:11 <lambdabot> (line 1, column 8):
10:11:11 <lambdabot> unexpected "="
10:11:11 <lambdabot> expecting pattern or "->"
10:11:17 <Twey> Oops
10:11:20 <heatsink> pejo: Thanks, I found it.
10:11:21 <Twey> @pl (\ f x -> x * 2 + 3 )
10:11:21 <lambdabot> const ((3 +) . (2 *))
10:11:29 * Twey got it right!
10:11:33 * Twey feels happy.
10:12:50 <paolino> thanks dcoutts_ Hedi is there
10:18:45 <heatsink> Readable -- it uses the same syntax conventions as TAPL.
10:19:10 <Cin> go go power Twey :P
10:24:32 <EvilTerran> hm... would "data Trie a = Trie (Maybe a) (Data.Map a (Trie a))" be a reasonable representation of tries/prefix trees?
10:25:43 <EvilTerran> I'm just thinking that the "prefix tree" idea would generalise quite nicely to indexing by more complicated ADTs by re-organising an ADT value into a list by breadth-first traversal
10:26:40 <heatsink> EvilTerran: why not a instead of (Maybe a)?
10:26:44 * EvilTerran is trying to memoize a function on a complex ADT with infinite values :P
10:26:58 <EvilTerran> heatsink, because your trie may contain something at [1,2] but not at [1]
10:27:21 <EvilTerran> also because tries are allowed to contain no elements; Trie Nothing Map.empty
10:27:40 <heatsink> I see.
10:28:21 <EvilTerran> it occurs to me that you could create arbitrarily complicated empty tries with that representation, but defining a "canonical form" shouldn't be too hard...
10:29:36 <heatsink> That looks basically right, I'd pick on a few details.
10:30:29 <heatsink> You only need a boolean at the trie node because you can reconstruct the value based on the path from the root to the node.  Also, it might work better if a different constructor were used for empty tries.  It depends on what makes your code simpler though.
10:33:57 <Saizan> EvilTerran: have you read sigfpe's blog post on that?
10:35:18 <oerjan> possibly you would want data Trie a b = Trie (Maybe b) (Data.Map a (Trie a b)) ?
10:37:40 <olsner> heh, I think I've built one of those structures, but I called it a DFA, with every final/accepting state having (Just x) and other states having Nothing
10:37:50 <idnar> http://sigfpe.blogspot.com/2007/09/tries-and-their-derivatives_08.html
10:40:15 <glen_quagmire> would it be possible to write a haskell compiler in haskell?
10:41:07 <Saizan> olsner: did you wrote a NFA -> DFA converter for such structure?
10:41:12 <idnar> isn't ghc written in Haskell?
10:41:19 <pejo> glen_quagmire, see ghc, yhc, etc.
10:41:41 <olsner> Saizan: no, I think not
10:41:45 <glen_quagmire> oh i see
10:43:17 --- mode: ChanServ set +b *!n=palomer@*
10:43:48 <Saizan> olsner: and you "tied the knot" for states with a reentrant arc?
10:44:23 <olsner> nope, in this case I was lazy and just ignored it and let the generator recreate states
10:46:11 <sarehu> regarding the possibility of writing a haskell compiler in haskell...
10:46:13 <sarehu> ?faq
10:46:13 <lambdabot> The answer is: Yes! Haskell can do that.
10:46:19 <sarehu> sigh.
10:46:35 <olsner> haven't really figured out just how to actually tie the knot
10:47:41 <sarehu> "sigh" is in regard to my internet connection...
10:49:08 <olsner> lambdabot should have a plugin that responds to any "Can haskell X?" and "Can you do X in haskell?" questions in an text with "Yes, you can X in haskell" or "Yes, haskell can X"
10:52:42 <zkincaid> hey, does anyone know how to retrieve the output (to stdout) from a system command as a [Char]?
10:52:50 <litb> @users
10:52:51 <lambdabot> Maximum users seen in #haskell: 465, currently: 432 (92.9%), active: 13 (3.0%)
10:53:03 <litb> hm how should i get (. someFunction) ?
10:53:14 <zkincaid> I know I can execute commands with system, but it returns an ExitCode
10:53:15 <litb> i mean, i know what (f . u) means, but what if f is not given?
10:53:19 <litb> it confuses me
10:53:49 <slarba_> function composition is curried as all functions are
10:53:50 <kaol> @pl \f -> (f . u)
10:53:50 <lambdabot> (. u)
10:53:52 <olsner> @index runInteractiveCommand
10:53:52 <lambdabot> System.Process
10:53:55 <shachaf> zkincaid: Maybe runInteractiveProcess or some variation?
10:54:13 <zkincaid> shachaf: Thanks, I'll look it up
10:54:43 <litb> @pl \f u -> (f . u) u
10:54:43 <lambdabot> join . (.)
10:55:04 <kaol> > (. (*2)) (*3) 4
10:55:06 <lambdabot>  24
10:55:13 <litb> hmm
10:55:19 <nominolo> @seen conal
10:55:19 <lambdabot> conal is in #haskell, #oasis and #ghc. I last heard conal speak 1h 15m 39s ago.
10:55:28 <conal> nominolo: hi
10:55:42 <nominolo> i have a weird problem
10:55:45 <nominolo> !hpaste
10:55:55 <EvilTerran> ?paste
10:55:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:56:28 <litb> @pl \f x -> (f . u) x
10:56:28 <lambdabot> (. u)
10:56:35 <litb> ah i see
10:56:48 <hpaste>  nominolo pasted "reactive weirdness" at http://hpaste.org/5416
10:57:11 <nominolo> conal: i don't understand what's going on here
10:57:57 <conal> nominolo: looking ...
10:59:07 <conal> nominolo: you're using the event Applicative.
10:59:12 <conal> nominolo: do you know what it means?
10:59:20 <nominolo> no :)
10:59:21 <conal> nominolo: in t0'
10:59:46 <litb> what is ap again? <*> ?
10:59:53 <litb> oh no i guess <$>
10:59:53 <Deewiant> @src ap
10:59:53 <conal> litb: yes
10:59:54 <lambdabot> ap = liftM2 id
11:00:05 <conal> litb: ap = <*>
11:00:08 <litb> i see
11:00:16 <litb> <$> was fmap then
11:00:26 <litb> s/was/is/
11:00:50 <conal> nominolo: see http://haskell.org/haskellwiki/Reactive#Instances_for_Event .  Does that help?  If not, maybe I can write it more clearly.
11:03:20 <nominolo> conal: hm. so how do i get from Event Int and Event String to Event (Int, String) ?
11:03:32 <conal> nominolo: with what meaning?
11:03:49 <nominolo> just combining them.  so kind of "in parallel"
11:04:01 <litb> nominolo: sounds like join
11:04:16 <conal> nominolo: okay.  as in ZipList rather [] ?
11:04:17 <litb> i mean a join function for that could be sweet
11:04:21 <nominolo> litb: no that's exactly my problem
11:04:30 <nominolo> conal: the problem is, that it's the same event
11:04:32 <conal> litb: there is a join.  Event is a monad.
11:04:39 <nominolo> conal: yep
11:04:59 <conal> nominolo: a related event, anyway.  one that occurs simultaneously.
11:05:07 <nominolo> conal: so i have to use prep *** id ?
11:05:17 <cnwdup> Isn't there a ResizeRequest event in haskell's X11 modules? I can't find any. How can I get informed about my windows' size being changed?
11:05:31 <conal> nominolo: i think that'd do it.
11:05:41 <conal> nominolo: think about events as lists/streams
11:06:00 <conal> nominolo: the Applicative and Monad instances work list [].
11:06:01 <olsner> how do I upgrade stuff with cabal?
11:06:11 <bos> olsner: just install the new version
11:06:21 <bos> olsner: it will be picked up by default
11:06:25 <conal> nominolo: you could also use Reactive instead of Event.  There the Applicative and Monad instances work like ZipList, as you wanted.
11:06:32 <bos> olsner: but the old version will remain present for packages that need it
11:06:38 <olsner> cabal install says it's already installed, nothing to do
11:07:16 <bos> oh, cabal-install. can't help you there.
11:07:28 <int-e> cnwdup: ConfigureEvent, I believe
11:07:35 <cnwdup> int-e: Thanks.
11:07:38 <conal> nominolo: see stepper :: a -> Event a -> Reactive a
11:08:10 <Saizan> conal: why (1,"CB") is generated before (2,"B") if the first C depends on the 2?
11:08:14 <nominolo> :t (***)
11:08:16 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:08:23 <nominolo> :t (***) (->)
11:08:24 <lambdabot> parse error on input `->'
11:08:30 <nominolo> :t (***) (~>)
11:08:30 <lambdabot> Not in scope: `~>'
11:09:13 <nominolo> :t (&&&)
11:09:13 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:09:43 <conal> nominolo: oh yeah -- (&&&)
11:10:58 <nominolo> conal: still not quite there yet.  but i'll figure it out, thanks
11:11:01 <Saizan> that'd give (Event Int,Event [Char])
11:11:38 <conal> nominolo: you're going to fmap, right?
11:12:07 <conal> nominolo: oh, i see.  prep makes an event.  so, no, that won't quite work.
11:12:50 <olsner> > fromEnum (upperBound :: Char)
11:12:50 <lambdabot>   Not in scope: `upperBound'
11:12:51 <nominolo> so stepper just creates a time-varying value whose current value is the value of the last event?
11:13:01 <conal> nominolo: exactly
11:13:10 <olsner> @src Enum
11:13:10 <lambdabot> class  Enum a   where
11:13:10 <lambdabot>     succ                     :: a -> a
11:13:10 <lambdabot>     pred                     :: a -> a
11:13:10 <lambdabot>     toEnum                   :: Int -> a
11:13:10 <lambdabot>     fromEnum                 :: a -> Int
11:13:12 <lambdabot> [3 @more lines]
11:13:15 <olsner> @more
11:13:15 <lambdabot>     enumFrom                 :: a -> [a]
11:13:16 <conal> nominolo: and time-varying values combine in parallel
11:13:16 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
11:13:18 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
11:13:38 <olsner> > fromEnum (maxBound :: Char)
11:13:39 <lambdabot>  1114111
11:13:45 <conal> nominolo: i don't know how to give a parallel semantics to events, due to lack of initial value.
11:14:16 <soduko> > (concat $  map ( (++ " " ) . show) [ 1 ,2 ,3 ,4 ,0] ) ++ "\n"
11:14:17 <lambdabot>  "1 2 3 4 0 \n"
11:14:41 <dons> ?users
11:14:41 <lambdabot> Maximum users seen in #haskell: 465, currently: 436 (93.8%), active: 21 (4.8%)
11:14:43 <nominolo> conal:yes. it's just a missing docs issue ;)
11:14:43 <conal> liftA2 (,) [1,2] ["B","CB"]
11:14:52 <nominolo> conal: how do i print reactive values then?
11:14:56 <conal> > liftA2 (,) [1,2] ["B","CB"]
11:14:56 <lambdabot>  [(1,"B"),(1,"CB"),(2,"B"),(2,"CB")]
11:15:08 <conal> Saizan: does that answer your question?
11:15:10 <olsner> > unlines . (:[]) . unwords . map show $ ([1..4]++[0])
11:15:11 <lambdabot>  "1 2 3 4 0\n"
11:15:20 <Deewiant> hmm, lambdabot doesn't have intercalate?
11:15:37 <conal> nominolo: you could 'fmap show'
11:15:55 <conal> nominolo: or 'fmap print'
11:16:02 <olsner> > (((++" ").show) =<< [1,2,3,4,0]) ++ "\n"
11:16:03 <lambdabot>  "1 2 3 4 0 \n"
11:16:09 <Saizan> conal: then i wonder why there are more events for which the first value is 1 later :)
11:16:25 <conal> nominolo: forkR (print <$> r)
11:17:19 <soduko> ha the reverse bind one looks best
11:17:19 <conal> Saizan: good point.  i was hazarding a guess.  honestly, i get lost in the details.
11:17:35 <olsner> are we still talking about getting the first of several futures?
11:18:43 <conal> Saizan: the (1,"CB") and (2,"B") events semantically have the same associated times.  probably the funny ordering is due to the issue (bug) that roconnor was asking about earlier.
11:19:12 <conal> Saizan: in other words nondeterminism of ordering of simultaneous futures.  i have a simple deterministic semantics, but i don't know how to implement it.
11:19:33 <bos> @hoogle forever
11:19:33 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
11:19:44 <cnwdup> int-e: And how do I know which eventMask I have to additionionally select to receive this event?
11:20:08 <dons> bos, its m a -> m b now
11:20:31 <bos> dons: really?
11:20:39 <olsner> I'd wager that any attempt at deterministic semantics is impossible to implement... unless you're running under a deterministic, sequentializing scheduler
11:20:53 <dons> bos, yeah, m () was overly constrained.
11:21:00 <dons> so now 'fail' works to terminate the loop
11:21:10 <bos> ah, yes.
11:21:19 <olsner> @ty fail
11:21:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
11:21:34 <ddarius> > forever . fail
11:21:34 <lambdabot>   Not in scope: `forever'
11:22:01 <int-e> cnwdup: ConfigureNotify has the right type.
11:22:14 <nominolo> conal: ok, thanks.  that works
11:22:47 <conal> nominolo: paste?
11:22:59 <bos> dons: are my privmsgs getting through?
11:23:41 <Twey> @pl (\ x -> x mod 2 == 0)
11:23:41 <lambdabot> (0 ==) . flip ($ mod) 2
11:24:09 <Deewiant> Twey: x `mod` 2
11:24:34 <cnwdup> int-e: Ah, thanks. (: I'll read the xlib manual about that.
11:24:42 <Deewiant> @pl \x -> x `mod` 2 == 0
11:24:42 <lambdabot> (0 ==) . (`mod` 2)
11:26:59 <Twey> Hmm
11:27:05 <Twey> Deewiant: Oh, thanks
11:27:09 <nominolo> conal: well, kind of
11:27:11 <dons> bos, no?
11:27:12 <dons> hmm
11:27:15 <dons> ah!
11:27:17 <Twey> What's wrong with: factors n = filter (\x -> x mod n == 0) [1..n] ?
11:27:29 <Deewiant> again, `mod` instead of mod ;-)
11:27:32 <soduko> a bug in a list comprehension:  [ (x,y,z) | x<[1..n] , y <-[1..n] , k <- [1..] , ( k+j)<n]
11:27:42 <Twey> Deewiant: Oh, of course.  Heh
11:27:44 <soduko> a bug in a list comprehension:  [ (x,y,z) | x<-[1..n] , y <-[1..n] , k <- [1..] , ( k+j)<n]
11:27:48 <dons> bos, got that?
11:27:51 * Twey is too used to it being an operator.
11:28:01 <bos> yep
11:28:36 <hpaste>  nominolo annotated "reactive weirdness" with "Reactive noise" at http://hpaste.org/5416#a1
11:28:50 * conal looks at nominolo's paste
11:29:06 <soduko> @pl (\l-> (((++" ").show) =<< l ) ++ "\n")
11:29:09 <lambdabot> (++ "\n") . ((++ " ") . show =<<)
11:29:25 <dons> glguy: snow!
11:30:46 <conal> nominolo: sigh.  i misled you.  this is exactly the issue discussed in the comments at http://conal.net/blog/posts/blending-continuity-into-reactive-values .
11:30:47 <lambdabot> Title: Conal Elliott » Blog Archive » Blending continuity into reactive values, http://tinyurl.com/3dcxtz
11:31:30 <nominolo> conal: i think Hughes' arrows paper also deals with those issues
11:31:40 <nominolo> i think using some nub-combinator
11:32:00 <conal> nominolo: really?  if you find that bit, please let me know.
11:32:06 <Twey> @pl (\x -> [1..x])
11:32:06 <lambdabot> enumFromTo 1
11:32:47 <Deewiant> > let fac = product . enumFromTo 1 in fac 10
11:32:47 <lambdabot>  3628800
11:32:48 <conal> nominolo: i know how to fix it semantically: just take the last value at any given time.  and i know how to fix it in a GUI setting (done in phooey).  but now with the fmap print i recommended.
11:33:15 <nominolo> conal: yes, he used some delay semantics
11:34:39 <conal> nominolo: i guess i've not thought much about using Reactive with things like print that leave a visible trace of multiple simultaneous occurrences.
11:35:57 <conal> nominolo: my intention is more to replace IO than compose with it.
11:36:19 <pejo> conal, are you trying to get a deterministic semantics in a (conceptually?) concurrent setting?
11:36:25 <conal> nominolo: i mean IO in the semantics, not in the implementation.
11:36:35 <nominolo> conal: well, for performance reasons it might be nice to combine multiple events into one
11:36:55 <conal> pejo: yes, which i've done before in FRP, but with a very different implementation style.
11:37:02 <nominolo> conal: ie., like a GUI typically combines several refresh commands into one
11:37:19 <Twey> How does everyone read "foldl'"?  I automatically read that as "fold ell prime" but this page says the Haskell way is "fold ell tick"
11:37:35 <conal> nominolo: see the blog discussion on the topic.  i think laziness addresses efficiency without combining.
11:37:48 <Twey> (not that it's particularly important, just curious)
11:38:23 <Deewiant> I just read it the same as "foldl" most of the time :-P
11:38:23 <conal> nominolo: i exploit that GUI optimization in phooey.
11:38:32 <conal> nominolo: as discussed in the blog thread
11:38:36 <EvilTerran> i think "foldl" or "foldl prime"
11:38:47 <Deewiant> if I need to use "foldl" and "foldl'" in the same sentence, "foldl prime"
11:39:07 <olsner> Twey: I pronounce it silently as the abstract concept <strict>
11:39:16 <conal> pejo: but implementation-wise, you've put your finger on it.
11:40:38 <Twey> olsner: Heh :-P
11:43:01 <hpaste>  olsner pasted "Trie-similar DFA" at http://hpaste.org/5417
11:44:00 <pejo> conal, hm. Sounds interesting. Does "Functional Reactive Animation" describe what you did in FRP?
11:44:27 <tux_rocker> hmmm, my computer can't resolve hpaste.org
11:44:42 <conal> pejo: that and many of my follow-on papers
11:44:57 <psykon> darcs: : createDirectory: does not exist (No such file or directory)
11:45:08 <psykon> does anyone know what this might be?
11:45:55 <Deewiant> trying to create foo/bar while foo does not exist?
11:45:59 <Deewiant> (guessing)
11:46:43 <psykon> hmm
11:51:27 <hpaste>  khadrin pasted "why is it "ambiguous"?" at http://hpaste.org/5418
11:53:01 <olsner> @ty \a b -> ( (fromIntegral a) / (fromIntegral b) ) * 100
11:53:03 <lambdabot> forall a b a1. (Integral a, Integral a1, Fractional b) => a -> a1 -> b
11:53:14 <khadrin> or, What is Fractional and why does printf not like it?
11:54:14 <nelhage> @src Fractional
11:54:15 <lambdabot> class  (Num a) => Fractional a  where
11:54:15 <lambdabot>     (/)             :: a -> a -> a
11:54:15 <lambdabot>     recip           :: a -> a
11:54:15 <lambdabot>     fromRational    :: Rational -> a
11:54:30 <Deewiant> @src PrintfArg
11:54:30 <lambdabot> Source not found. Are you on drugs?
11:56:04 <khadrin> is it a "printf doesnt support it" or a "printf cant support it" issue?
11:56:54 <khadrin> @src Text.Printf.PrintfArg
11:56:54 <lambdabot> Source not found. Where did you learn to type?
11:57:16 <Botje> khadrin: yeah, it looks like there's on definition for PrintfArg
11:57:19 <EvilTerran> khadrin, the problem is it needs to know exactly what type "percent" is before it can pick an instance of PrintfArg
11:57:22 <Botje> *no
11:57:52 <olsner> more of an issue that (Fractional b, PrintfArg b) isn't enough to decide on the exact type of b and the instance of PrintfArg for it
11:58:01 <EvilTerran> without the type sig, it can only tell that it's a Fractional a => a
11:58:33 <khadrin> is Double a type of Fractional then?
11:58:38 <Deewiant> @instances Fractional
11:58:39 <lambdabot> Double, Float
11:58:43 <roconnor> conal: this simultaneous problem thing is tought.
11:58:51 <khadrin> i see
11:58:54 <soduko> map read ["2", "3"]  how do i specify the type constraint Int in this case?  im trying to convert cmd line args to unsigned ints
11:58:56 <roconnor> conal: you could have events A B.
11:59:11 <roconnor> conal: and thier joing A /\ B
11:59:19 <idnar> > map read ["2", "3"] :: [Int]
11:59:25 <lambdabot>  [2,3]
11:59:31 <roconnor> conal: then whether or not A and A /\ B is simultaneous depends on how fast B runs.
12:01:39 <soduko> idnar: thanls
12:01:40 <shachaf> > map (read :: String -> Int) ["2","3"]
12:01:41 <lambdabot>  [2,3]
12:01:41 <soduko> thanks
12:02:09 <ddarius> > (map :: (String -> Int) -> [String] -> [Int]) read ["2","3"]
12:02:09 <lambdabot>  [2,3]
12:03:22 <soduko> which version is the most idiomatic in haskell?  shachaf's looks most intuitive to me
12:03:28 <idnar> > (map :: (a -> Int) -> [a] -> [Int]) read ["2","3"]
12:03:28 <lambdabot>  [2,3]
12:03:48 <shachaf> soduko: Either, but probably the first one (idnar's).
12:03:59 <ddarius> soduko: Often you can avoid providing any type signature or you can put one elsewhere.
12:04:03 <shachaf> soduko: Since what you really care about is the final type.
12:04:12 <ddarius> Otherwise, idnar's is probably the most common.
12:04:15 <shachaf> soduko: Of course, what you'd always prefer to have it inferred. :-)
12:04:42 <EvilTerran> soduko, keep writing code, hopefully once a bit more surrounding stuff's in it'll be able to infer the type anyway
12:05:39 <soduko> can a case where the programmer has to disambiguate be avoided altogether?
12:05:49 <ddarius> soduko: Not in general.
12:05:55 <ddarius> > show . read
12:05:56 <lambdabot>  <[Char] -> [Char]>
12:06:02 <soduko> hmm. thanks
12:06:12 <ddarius> Stupid defaulting
12:06:52 <inimino> is there a variant of getLine that expects CRLF instead of just LF?
12:07:04 <bos> no
12:07:22 <bos> inimino: the runtime will convert CRLF to LF for you on windows
12:07:33 <inimino> ok, I'm trying to parse HTTP
12:08:03 <EvilTerran> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP-3001.0.4 ?
12:08:04 <lambdabot> http://tinyurl.com/282fmq
12:08:17 <inimino> I guess I will try just trimming the last character then
12:08:20 <EvilTerran> or maybe http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP-Simple
12:08:21 <lambdabot> http://tinyurl.com/26l2xc
12:08:38 <inimino> EvilTerran: I know there are packages for it, I'm just doing it as an exercise
12:08:44 <EvilTerran> k
12:08:55 <hpaste>  bos pasted "parsing HTTP" at http://hpaste.org/5419
12:09:03 <bos> inimino: see above
12:09:11 <inimino> ok
12:09:59 <bos> it's a very simple brain-dead parser, but enough to get a start.
12:10:42 <litb> hm is there a version of getLine returning the whole line including line ending?
12:10:45 <hpaste>  bos annotated "parsing HTTP" with "oops, missed a bit" at http://hpaste.org/5419#a1
12:10:54 <bos> litb: no
12:10:58 <litb> s/version/variant/
12:11:00 <litb> hmm
12:11:56 <awesame> hey, what do people use for editing haskell code in emacs?
12:12:02 <bos> haskell-mode
12:12:05 <awesame> haskell-mode seems to be bad at indentation
12:12:10 <litb> hm how can i read one character from stdin?
12:12:21 <bos> @hoogle hGetChar
12:12:21 <lambdabot> System.IO.hGetChar :: Handle -> IO Char
12:12:24 <litb> awesame: haskell-mode
12:12:31 <litb> awesame: it's awesome here
12:12:38 <desegnis> @type getChar
12:12:38 <lambdabot> IO Char
12:12:40 <bos> awesame: it's hard to indent haskell automatically
12:12:42 <litb> ah thanks
12:12:45 <awesame> or am I doing something wrong?  I'm constantly having to hit tab 3 or 4 times to get to the same level of indentation as the previous line
12:12:52 <litb> hGetChar is with buffering or ?
12:13:23 <litb> awesame: there are two indentation modes . one simple and one advanced
12:13:25 <bos> awesame: that's the way haskell-mode works.
12:13:26 <litb> maybe try the other one
12:13:31 <awesame> hm
12:13:34 <awesame> how do I switch?
12:13:40 <bos> litb: the buffering mode is on the handle, not on the function.
12:13:45 <litb> awesame: see haskell-mode.hs
12:13:45 <desegnis> @hoogle hSetBuffering
12:13:45 <lambdabot> System.IO.hSetBuffering :: Handle -> BufferMode -> IO ()
12:13:47 <litb> err
12:13:49 <litb> haskell-mode.el
12:13:50 <litb> o.O
12:14:03 <inimino> thanks bos, I was trying to do it with only Prelude stuff, but maybe I should try the Parsec stuff too...
12:14:08 <litb> what is the diff between hGetChar and getChar ?
12:14:19 <bos> inimino: it's much tidier with Parsec
12:14:22 <shachaf> litb: hGetChar gets a Handle.
12:14:26 <litb> ah, thanx
12:14:32 <awesame> litb: to be "awesame" is to have impressive rotational symmetry (imagine rotating the word 180 degrees about its center in the plane of your monitor)
12:14:55 <shachaf> litb: You can use hSetBuffering to set the buffering.
12:14:55 <awesame> thanks litb, I'll take a look
12:15:04 <litb> shachaf: thx you
12:15:32 <inimino> bos: I figured it would be
12:15:45 <litb> awesame: i do not understand your statement about awesomeness
12:15:52 <awesame> awesameness
12:16:05 <bos> litb: stand on your head and read his nick
12:16:09 <awesame> yeah that
12:16:13 <shachaf> awesame: You must use some weird font.
12:16:22 <awesame> courier, I think
12:16:27 <litb> oh
12:16:28 <litb> lol
12:17:00 <shachaf> awesame: And 'a'/'e' are really symmetrical?
12:17:04 <litb> i haven't known what word to rotate :)
12:17:29 <awesame> shachaf: sort of, if your 'a' has the curved top
12:18:01 <shachaf> awesame: Very "sort of". :-)
12:18:20 <awesame> shachaf: it's legible!
12:18:43 <litb> hm, having a question here. mybe this is silly now
12:18:59 <litb> i want to mix takeUntil (=='a') getChar
12:19:11 <awesame> so, symmetrical through whatever transform my brain applies to shapes to get letters
12:19:15 <litb> but getChar is IO Char not [Char]
12:19:19 <litb> how can i fix that?
12:22:16 <Gwern-away> wait 'til we release v18
12:22:21 <Gwern-away> (mischan)
12:22:29 <glguy> dons: No snow here :(
12:23:31 <awesame> hm, I want to know the answer to litb's question, too
12:23:48 <EvilTerran> i think you have to write that yourself
12:23:54 <EvilTerran> it's probably a foldl
12:24:21 <Gwern-away> maybe you've tried it, but why doesn't liftM work? ie liftM (takeUntil (== 'a')) $ getChar?
12:24:30 <conal> roconnor: (... then whether or not A and A /\ B is simultaneous depends on how fast B runs).  do you mean semantics or this implementation?
12:24:50 <EvilTerran> Gwern-away, because getChar only returns a single value?
12:24:55 <dons> glguy: well, its just stopped. but was falling very heavily.
12:24:59 <litb> ah thanxx awesame seems not too silly
12:25:10 <bos> dons: bit of a change from back home, eh?
12:25:16 <dons> just a bit :)
12:25:28 <Gwern-away> oh. hm. well, isn't there a while keyword somewhere?
12:25:39 <Saizan> no.
12:25:42 <dons> :t until
12:25:43 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
12:26:06 <dcoutts_> @seen bringert
12:26:06 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
12:26:26 <Gwern-away> ('until'? close enough)
12:26:47 <Saizan> until won't work with monads
12:26:49 <EvilTerran> i think we want "getCharWhile p = do c <- getChar; if p c then (c :) <$> getCharWhile p else return []"
12:26:50 <shachaf> getContents, maybe?
12:27:01 <EvilTerran> altho bearing in mind that reads one more character than it returns
12:27:10 <litb> something like replicateUntil
12:27:16 <shachaf> @ty unGetChar
12:27:16 <lambdabot> Not in scope: `unGetChar'
12:27:21 <EvilTerran> untilM would be useful, if it existed
12:27:43 <EvilTerran> i think
12:28:08 <EvilTerran> litb, awesame; are your problems such that you can't work with getContents instead?
12:28:26 <EvilTerran> (or readFile)
12:29:06 <EvilTerran> those functions may have broken semantics, but they're still quite handy
12:30:36 <dons> :t replicateM
12:30:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:31:18 <ddarius> @quote never.dies
12:31:18 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
12:31:18 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
12:31:42 <EvilTerran> dons, all well-and-good if you know how many characters you want ahead of time
12:31:49 <Twey> If I do: ((+) . read) "1" 2 -- how does Haskell know how many arguments to pass to each function?
12:32:18 <shachaf> Twey: "know"?
12:32:18 <ddarius> Twey: You've told it.
12:32:21 <Twey> Does it just keep applying it until the value returned doesn't take any arguments?
12:32:47 <ddarius> Twey: There's nothing to figure out.
12:32:48 <shachaf> Twey: ((+) . read) "1" 2 == ((+) (read "1")) 2 == ((+) 1) 2 == 3
12:32:51 <Twey> But that could be interpreted as (+) (read "1" 2)
12:32:58 <ddarius> Twey: No.
12:32:59 <shachaf> Twey: No.
12:33:03 <Twey> Why not?
12:33:08 <shachaf> @src (.)
12:33:08 <lambdabot> (.) f g x = f (g x)
12:33:12 <ddarius> Because that's not what (.) means.
12:33:15 <shachaf> Twey: (.) is for one argument only.
12:33:25 <Twey> Oh
12:33:36 <Twey> Is there a variant for multiple arguments?
12:33:43 <ddarius> :t (.) . (.)
12:33:44 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:33:51 <Twey> Oh, right
12:33:51 <shachaf> Twey: There's dot = (.) . (.).
12:33:59 <Twey> Mmkay, thanks
12:34:14 <ddarius> I would recommend just using a lambda in those cases.
12:34:18 * Twey nods.
12:34:36 <conal> ddarius: i'd recommend compositions of "result".  and throw in first & second as needed.
12:35:01 <ddarius> conal: Depends on the context.
12:35:06 <conal> or (fmap.fmap), etc.
12:35:42 <conal> perhaps infix notation interferes with compositionality here.
12:35:48 <litb> EvilTerran: i don't know that getContents
12:36:19 <conal> if we could compose inside infix operators, perhaps we'd see higher-level programming style.
12:36:39 <ddarius> conal: As in infix expressions?
12:36:44 <litb> however, why doesn't this work?
12:36:46 <litb> liftM ((/= 'a') . last) (sequence (repeat getChar))
12:37:17 <ddarius> litb: Because you are first reading an infinite number of keys from the keyboard.
12:37:21 <conal> ddarius: yeah.  i'm not at all sure it's a good idea.  i'm wondering how to resolve the tension i see between infix and compositionality.
12:37:36 <litb> i thought it would be lazy
12:38:30 <conal> for infix expressions, "a `op` b", op is always atomic.  but there's really a rich algebra one could use for op.
12:39:01 <conal> and that algebra is available only when we switch to prefix form.
12:39:20 <conal> such as (fmap.first.fmap) f x
12:39:22 <Saizan> are the strictness properties of IO described in the report?
12:39:31 <conal> instead of f `fmap.first.fmap` x
12:39:37 <EvilTerran> litb, repeat getChar is an infinite list, so sequence <that> likewise, so last (<all that>) is undefined
12:40:03 <EvilTerran> litb, getContents looks like it'd do what you want, tho
12:40:16 <EvilTerran> @. docs getContents
12:40:16 <lambdabot> Plugin `compose' failed with: Unknown command: "getContents"
12:40:17 <litb> i don't know that. maybe i should give it a try
12:40:19 <EvilTerran> @. docs index getContents
12:40:19 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:40:26 <EvilTerran> hm
12:40:30 <ddarius> Saizan: It's not a strictness issue per se.  But the "lazy" IO functions are explicitly described.
12:40:39 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3AgetContents
12:40:39 <lambdabot> http://tinyurl.com/ovjef
12:41:04 <EvilTerran> > chr 0x3A
12:41:05 <lambdabot>  ':'
12:41:07 <EvilTerran> ah.
12:42:14 <ddarius> conal: I'm sure you are aware of the various "infix expressions" hacks
12:42:18 <litb> wow nice
12:42:43 <EvilTerran> f <|fmap.first.fmap|> x
12:43:19 <conal> i'd forgotten.  i like the look of it.  what are the defs & fixities?
12:43:24 <ac> what's the short version of: (\x y -> foldr1 (>>) $ map x y) --?
12:43:51 <kpreid> ac: (\x -> sequence . map x)
12:43:51 <EvilTerran> infixl 1 <|, |>; (<|) = flip ($); (|>) = ($) -- this works
12:44:31 <conal> EvilTerran: thanks.  i'll try it out in my programming.  i have a lot of things like (fmap.fmap).
12:44:41 <EvilTerran> if you make 'em infixr and tweak the definitions a bit, you can make "right sections" work too
12:44:49 <EvilTerran> (with that version, only left sections work)
12:45:09 <conal> EvilTerran: btw, who came up with that nifty hack?
12:45:24 <EvilTerran> (as in, (f <|fmap.fmap) does what you expect, but (fmap.fmap|> x) doesn't)
12:45:38 <EvilTerran> er... me, as far as i know :)
12:45:44 <ddarius> conal: It was on the mailinglist many many years ago.
12:45:45 <conal> EvilTerran: thx for the warning
12:45:52 <ac> :t (\x -> sequence . map x)
12:45:54 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
12:45:54 <EvilTerran> but someone else almost certainly thought of it first
12:46:04 <EvilTerran> eg whoever ddarius just mentioned
12:46:07 <ac> :t (\x y -> foldr1 (>>) $ map x y)
12:46:07 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m a
12:46:47 <litb> hmm
12:46:58 <EvilTerran> last . sequence . map x?
12:47:08 <EvilTerran> seems ugly to use last, tho
12:47:14 <litb> now i have getContents. but i don't know how i can do it :)
12:47:36 <EvilTerran> litb, once you've done "s <- getContents", s is the entirity of standard input
12:47:41 <EvilTerran> but read lazily.
12:47:53 <litb> there doesn't seem to be an unfoldM
12:48:00 <EvilTerran> indeed not.
12:48:08 <litb> oh i see
12:48:36 <EvilTerran> if you're careful about how you poke about with the string, you can do interactivity fairly well
12:48:58 <EvilTerran> although if you want interativity, it'd probably be better to use the line-wise IO functions
12:49:13 <litb> darn
12:49:16 <EvilTerran> getContents is good for a program you want to use as part of a pipeline
12:49:20 <litb> do { s <- getContents; return (takeWhile (/= 'a') s); }
12:49:27 <litb> i do not know what is wrong with that
12:49:27 <EvilTerran> (altho, for a lot of those, interact is even better)
12:49:33 <litb> *** Exception: <stdin>: hGetContents: illegal operation (handle is closed)
12:49:47 <EvilTerran> litb, you can only getContents once
12:50:01 <EvilTerran> as it reads *everything* remaining in stdin
12:50:07 <EvilTerran> for the lifetime of the program
12:50:25 <litb> yeah but stdin is keyboard
12:50:49 <EvilTerran> so?
12:50:56 <litb> does it close the stdin then?
12:50:58 <litb> hm
12:51:17 <EvilTerran> no, it doesn't clone it, it "reserves" it
12:51:25 <EvilTerran> making it appear closed to the rest of your program
12:51:29 <litb> lets say one wants to read until one gets an 'a': int c; while((c = read()) != 'a') putc(c); how is that done?
12:51:40 <litb> i can only write such a thing one time in a haskell program?
12:51:45 <EvilTerran> no...
12:52:31 <EvilTerran> forget getContents for now, the semantics are complicated and/or broken
12:52:40 <EvilTerran> to translate your program directly into haskell:
12:52:44 <litb> alrite :)
12:52:53 <conal> litb: try a functional approach instead
12:53:09 <EvilTerran> loop = do c <- getChar; if c == a then return () else putChar c; loop
12:53:11 <litb> i try but i don't know how to with IO
12:53:46 <litb> ah i see
12:53:49 <Cin> twey: do you fancy collaborating on some mini project in haskell with Gobby?
12:53:51 <EvilTerran> er, else do putChar c; loop
12:54:02 <conal> litb: by "functional" i mean without IO except for a simple outer wrapper like 'interact'
12:54:11 <Twey> Cin: Gobby?  What's the project?
12:54:22 <shachaf> Cin: Has there been more activity on monad.printf.net?
12:54:30 <conal> litb: it takes some mental retooling.
12:54:36 <Cin> twey: i really want to see what collaboritive coding is like. a few people in here are willing but i'm not very good at haskell so it instantly goes over my head
12:54:49 <Cin> twey: gobby is a collaborative editor. the project could be anything
12:54:59 <Cin> shachaf: i don't think so
12:55:06 <shachaf> Cin: Just start something and people will join. :-)
12:55:09 <Twey> Cin: I'm not very good at Haskell either :-P
12:55:24 <Cin> twey: that would work nicely then ;)
12:56:11 <Cin> shachaf: well the arc implementation sounds pretty fun but i'm actually not sure how to do it. i could start on how i think it could be done but i sense that someone will come along and wipe it away declaring it ridiculous
12:56:18 <Cin> ah, bbl. dinner time
12:56:32 * Twey nods.
12:56:37 <Twey> Cin: I don't mind.
12:56:38 <LoganCapaldo> someone should do libobby bindingss for Yi
12:57:12 <conal> litb: in other words, unix/c-style stream programming (getChar/putChar/IO in haskell) is often used as an implementation of lazy streams.  we have much more elegant tools to use instead.
12:58:16 <shachaf> LoganCapaldo: Yes, someone should.
12:58:35 <shachaf> That would almost be a reason to switch from vim (assuming everything else was working :-) ).
12:58:39 <EvilTerran> thanks for volunteering, guys :P
12:58:50 <Twey> Cin: I'm not going anywhere near Arc, it's been declared to only support 7-bit ASCII :-\
12:58:54 <litb> if i wanted to return the list, is this correct?
12:58:56 <litb> let loop = do c <- getChar; if c == 'a' then return [c] else liftM (c:) loop; in loop
12:58:57 <shachaf> EvilTerran: Someone should integrate it with hpaste somehow.
12:59:07 <EvilTerran> that'd be cool
12:59:16 <EvilTerran> also hpaste + lambdabot integration would be awesome
12:59:52 <litb> conal: i see
12:59:54 <shachaf> lambdabot.codersbase.com is still down, right?
13:00:02 <shachaf> It worked at one point, anyway.
13:00:09 <EvilTerran> > HPaste.5414.0.romanize 12345
13:00:09 <lambdabot>   Not in scope: `romanize'
13:00:12 <LoganCapaldo> Does Yi have like an "everyhting is a buffer" model? Cause then you could probably have an obby -backed buffer pretty "easily"
13:00:22 <LoganCapaldo> \/me grabs yi source
13:00:26 <LoganCapaldo> ack
13:00:32 <LoganCapaldo> I escaped my emote
13:00:35 <shachaf> lispy: Is that yours?
13:00:35 <EvilTerran> syn
13:01:00 <litb> i hope Yi will support arbitratry things in buffers
13:01:03 <litb> like drawing into ot
13:01:06 <litb> s/ot/it
13:01:34 <litb> i could finally write a form designer for wx then for Yi buffers that automatically interprest the .xrc files (xml) and displays a preview
13:01:40 <EvilTerran> \o/ it'll be just like mathematica
13:01:54 <litb> i always wanted to do that for emacs, but i've only very little lisp expertise
13:02:35 <ac> litb: couldn't you say something like: do c <- getContents; return takeWhile (/='a') c; -- ?
13:02:54 <litb> ac: stdin is closed after that
13:03:24 <litb> after that, more calls to IO functions throw errors
13:03:37 <shachaf> litb: Do you need stdin more than once?
13:03:55 <ac> I think he's writing an interactive program that does something after you type 'a'
13:03:59 <ac> so yes
13:04:26 <Cin> wouldn't it be line buffered?
13:04:36 <conal> can't it be written with interact?
13:04:40 <EvilTerran> litb, try doing s <- getContents once at the start of your program, then using "break (=='a') s" to get the bit you want and the remaining part
13:04:43 <EvilTerran> ?hoogle break
13:04:43 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
13:04:43 <lambdabot> Data.List.break :: (a -> Bool) -> [a] -> ([a], [a])
13:04:43 <lambdabot> Data.ByteString.break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
13:05:14 <EvilTerran> > break (=='a') "qwertyuiopasdfghjkl"
13:05:15 <lambdabot>  ("qwertyuiop","asdfghjkl")
13:05:58 <ac> Cin: not necessarily... stty -icanon
13:06:24 <EvilTerran> litb, the way to use getContents is to only ever call it once, and then to treat the read-in String as if it were stdin
13:06:30 <conal> litb: building on EvilTerran's advice, collect up your results in a string, and do only a single (lazy) putStr.  Then replace the getContents and putStr with a call to interact.  and you'll have a functional program.
13:07:03 * EvilTerran notes that one could do conal's transformation backwards with WriterT String
13:07:33 <conal> EvilTerran: interesting.  please say more.
13:07:46 <Saizan> conal: that's particulary messy if you really want an interactive program
13:08:12 <conal> Saizan: because it amounts to the old stream-style functional I/O?
13:08:19 <njbartlett> Heffalump: http://www.londonhug.net/2008/02/02/video-darcs-and-gadts/
13:08:20 <lambdabot> Title: Î»ondon HUG » Blog Archive » Video: Darcs and GADTs
13:08:57 <Saizan> conal: yeah, you've to be caraful on the evaluation order of that list wrt the ouput one
13:09:00 <puika> http://lostworlds.lv/go.php?1139637493
13:09:17 <EvilTerran> conal, actually, i was thinking something like working in the (Writer String) monad, and then doing putStr.execWriter to print the value
13:09:20 <conal> Saizan: yep.  it all depends on how simple litb's app is.
13:09:21 <EvilTerran> as Writer itself is pure
13:09:34 <conal> Saizan: a FRP style would probably be much more modular.
13:09:39 <EvilTerran> it's kinda half-way between using putStr repeatedly and using interact
13:10:02 <Saizan> and for input?
13:10:13 <EvilTerran> getContents, i guess
13:10:26 <EvilTerran> or a Source monad or whatever it's called
13:10:33 <conal> EvilTerran: i see.  interesting.  a monadic style, but still keeping all of the (intractable) IO semantics on the outside.
13:10:45 <EvilTerran> conal, exactly! :)
13:11:09 <conal> EvilTerran: nice!  and you can still get functional composability by keeping the interact separate.
13:11:20 <Saizan> if your getChar is still monadic you're back to the problem of takeUntilM :)
13:11:29 <conal> EvilTerran: i.e., separable, so it can be stripped off before composition.
13:12:21 <EvilTerran> indeed; you could work entirely in Writer String, and only using interact or putStr at the very outside
13:12:35 <ac> Cin: actually, in ghci "stty -icanon" is already set of course for things like tab completion
13:12:50 <dons> http://reddit.com/r/programming/info/67gzp/comments/ good work njbartlett, Heffalump !
13:12:56 <dons> Darcs and Generalised Algebraic Data Types :: Video (londonhug.net)
13:13:08 * paolino chants his litany
13:13:20 <njbartlett> dons: Good work Heffalump, I just pointed a camera at him ;-)
13:13:23 <paolino> anyone knows how to program readline completion ?
13:13:23 <mightybyte> @hoogle serveAs
13:13:24 <lambdabot> No matches found
13:13:32 <conal> EvilTerran: and one step further.  don't literally apply the interact, but instead pair it up with the String->String function, so it can either be applied (landing in IO), or stripped off for composition.
13:13:44 <dons> paolino: there's a setHistory function
13:13:52 <dons> hmm, but not sure about completion
13:14:02 <paolino> addJistory
13:14:19 <EvilTerran> conal, i'm not sure how what you're suggesting differs
13:14:39 <paolino> I use it, but completion is another story
13:15:07 <conal> EvilTerran: type TV a = (View a, a), where View a could be a -> IO (), or a GUI counterpart, or ...
13:15:24 <EvilTerran> i see, yes
13:15:30 <Ben`> how can I write a function which takes an arbitrary number of arguments
13:15:38 * paolino begs functional interface to readline
13:15:41 <dons> give it a list, Ben` ?
13:15:43 <EvilTerran> Ben`, are they the same type? use a list
13:15:58 <Ben`> ok, thanks
13:16:14 <Ben`> yeah, they're the same type :)
13:16:28 <paolino> dons ghci uses completion in haskell code ?
13:16:37 <conal> EvilTerran: i guess what i'm getting at is this question: how do we use IO where we must, but keep it from interfering with powerful & simple compositionality.
13:16:48 <dons> paolino: yeah
13:16:52 <EvilTerran> mmhmm
13:17:09 <conal> EvilTerran: one way is to keep view & value combined but separable.
13:17:39 <paolino> dons , can you point me to that source ?
13:18:04 <ac> are you saying ghci does not use readline?
13:18:21 <paolino> me ?
13:18:53 <ac> paolino: is that what you were asking by "does ghci use completion in haskell code"?
13:19:17 <paolino> it does, it seems to me something has been built on the simple wrappers there
13:19:54 <paolino> sorry for my lexer
13:21:58 <paolino> also this call to system stty is said to be not portable in the readline wrappers
13:26:19 <radix> @seen shapr
13:26:19 <lambdabot> shapr is in #ghc, #haskell, #scannedinavian and #haskell-blah. I last heard shapr speak 4h 25s ago.
13:26:54 <brian`> @seen brian`
13:26:54 <lambdabot> You are in #haskell. I last heard you speak just now.
13:27:03 <EvilTerran> @seen lambdabot
13:27:04 <lambdabot> Yes, I'm here. I'm in #not-math, #haskell-blah, #oasis, #friendly-coders, #gentoo-uy, #curry, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #jtiger, #haskell-soc, #haskell-
13:27:04 <lambdabot> overflow, #scala, #haskell, #ghc and #darcs
13:27:27 <shachaf> @seen
13:27:58 <ac> @undo do putStrLn "foo"; do putStrLn "bar"
13:27:58 <lambdabot> putStrLn "foo" >> putStrLn "bar"
13:28:34 <tux_rocker> @seen chr1s
13:28:34 <lambdabot> chr1s is in #oasis and #haskell. I don't know when chr1s last spoke.
13:28:54 <EvilTerran> @@ @seen @quote
13:28:54 <lambdabot>  I haven't seen dcnstrct.
13:29:20 <tux_rocker> what does @@ do?
13:29:31 <dmwit> ?quote dcnstrct
13:29:31 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
13:29:35 <ac> tux_rocker: pipes @ commands together
13:29:38 * Cin chuckles
13:29:52 <EvilTerran> @@ @elite @yow
13:29:54 <lambdabot>  y0\/\/! i jU$t w3N7 Be10w ThE POv3r+y 1in3!
13:29:59 <dmwit> Damn, I was looking for that quote the other day and couldn't find it!
13:30:02 <olsner> @@ @elite @quote
13:30:02 <lambdabot>  #PerL $ayz: <+E(H> Wh0 nEEd5 saN3ne5z
13:30:14 <idnar> heh
13:30:21 <Gwern-away> :t (^)
13:30:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:30:28 <jethr0>  what's the current status of cabal-install?
13:30:47 <Gwern-away> jethr0: works pretyy well with 1.2.3  or whatever is stable right now
13:31:37 <jethr0> cool, thx
13:31:43 <EvilTerran> @@ @@ @read @run (++) <*> (": @"++) $ words "keal protontorpedo palomer girl19" !! (length (@show @quote) `mod` 4) -- a more sophisticated example
13:31:43 <lambdabot>  girl19: LOL
13:31:58 <Gwern-away> jethr0: although a lot of hackage packages are old enough that they don't work with 6.8.x, so you might find yourself manually downloading and editing tarballs...
13:32:18 * Gwern-away is working on that, though. one by one...
13:32:22 <dmwit> EvilTerran: ...
13:32:58 <dmwit> EvilTerran: Please tell me you had to debug that at least a little bit in a /msg.
13:33:01 <jethr0> Gwern-away: the cabal-install page says that the head-version also needs cabal-head-version. is there someplace to get the "stable version"?
13:33:39 <b_jonas> what's @read?
13:33:44 <Gwern-away> I think it just comes with cabal. I don't remember installing cbaal-install, but it's on my system anyway
13:33:51 <EvilTerran> dmwit, more like a lot
13:33:52 <jethr0> k
13:33:53 <EvilTerran> :)
13:34:00 <b_jonas> @run (++) <*> (": @"++) $ words "keal protontorpedo palomer girl19" !! (length (@show @quote) `mod` 4)
13:34:00 <lambdabot>  Parse error at "@show" (column 76)
13:34:23 <EvilTerran> @read "de-quotes\ta\nstring"
13:34:24 <lambdabot>  de-quotes	astring
13:34:27 <Gwern-away> I could be wrong of course :)
13:34:28 <b_jonas> @@ @run (++) <*> (": @"++) $ words "keal protontorpedo palomer girl19" !! (length (@show @quote) `mod` 4)
13:34:29 <lambdabot>  "palomer: @palomer"
13:34:40 <b_jonas> @@ @echo (++) <*> (": @"++) $ words "keal protontorpedo palomer girl19" !! (length (@show @quote) `mod` 4)
13:34:40 <lambdabot>  echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "b_jonas!n=b_jonas@dsl51B61977.pool.t-online.hu", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@@ @echo (++) <
13:34:40 <lambdabot> *> (\": @\"++) $ words \"keal protontorpedo palomer girl19\" !! (length (@show @quote) `mod` 4)"]} rest:"(++) <*> (\": @\"++) $ words \"keal protontorpedo palomer girl19\" !! (length \"largos says: [
13:34:40 <lambdabot> on programming languages] \\\"...and I'd rather not own as much rope as c/c++ gives you.\\\"\" `mod` 4)"
13:35:00 <EvilTerran> eek
13:35:36 <dmwit> So @@ works by sending pseudo-messages?
13:35:39 <dmwit> That's clever.
13:35:47 <Gwern-away> suppose I have the expression 'x^2', and ghc mentions it isn't happy about inferring the 2 being Integer; is there any case in which going x^(2::Int) gives different results than x^(2::Integer)?
13:35:54 <conal> apropos the discussion about functional vs imperative programming for text/console-style user interaction (interact vs getChar/putChar/loop ...), i'd like some help.  i'm looking for examples that are awkward to express functionally, so i can experiment with making them easier (and still functional).  examples, please.
13:35:59 <dmwit> I wonder if they show up in \bot's logs.
13:36:14 <dmwit> :t (^)
13:36:15 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:36:33 <newsham> I wrote some FFI code and I am seeing some weird behavior.  I have a callback to haskell code.  if my callback is "cbfunc = printf "foo"" it crashes.  if my callback function is "cbfunc = printf "foo" >> return ()"  it doesnt crash
13:36:34 <dmwit> Gwern-away: There shouldn't be.
13:36:44 <newsham> the function is of type IO ()
13:36:50 <Gwern-away> I say this because I want to think they are identical, since 2 is well within the range of Int, but I'm not sure...
13:37:04 <ac> EvilTerran: just what did that command do?
13:37:06 <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<yow> " ++ s ++ " <vixen> @vixen " ++ s
13:37:06 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
13:37:09 <jethr0> Gwern-away: this might be uniformative or just plain wrong. but from what i understand Integer is reprented transparently as machine int's for "small" values
13:37:11 <EvilTerran> hm.
13:37:12 <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<yow> " ++ s ++ " <vixen> @vixen " ++ s
13:37:12 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
13:37:16 <EvilTerran> grr
13:37:17 <jethr0> but that's not even an answer to your question ;)
13:37:34 <EvilTerran> ac, er, lots of complicated stuff
13:37:40 <olsner> @@ @@ @read @run (++) <*> (": @"++) $ words "keal protontorpedo palomer girl19" !! (length (@show @quote) `mod` 4)
13:37:41 <lambdabot>  girl19: nobody can catch me
13:37:52 <dmwit> ?source (^)
13:37:52 <lambdabot> (^) not available
13:37:54 <EvilTerran> @@ @@ @read @run let s = (@show @yow) in "<yow> " ++ s ++ " <vixen> @vixen " ++ s
13:37:55 <lambdabot>  <yow> Bo Derek ruined my life! <vixen> Guys who can speak latin really turn me on.
13:38:02 <dmwit> ?src (^)
13:38:02 <lambdabot> Source not found. My pet ferret can type better than you!
13:38:04 <EvilTerran> hehe
13:38:17 <dmwit> ?source Prelude
13:38:17 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
13:38:18 <Gwern-away> jethr0: mm. I'm not sure. if that were so, then switching sigs from Integer to Int should never make a difference for small runs, but I've seen performance improvements from doing so
13:38:36 <olsner> lambdabot should have some way of defining command aliases for that
13:39:11 <int-e> @src Int
13:39:11 <lambdabot> data Int = I# Int#
13:39:14 <int-e> @src Integer
13:39:14 <lambdabot> data Integer = S# Int#
13:39:14 <lambdabot>              | J# Int# ByteArray#
13:39:20 <jethr0> Gwern-away: yes, i guess some of the unboxing/bounds checking is having an effect on performance. but again, i don't really know the inner details of Integer
13:39:47 <dons> integer should have got a bit faster with the new pointer tagging stuff
13:40:02 <dmwit> Gwern-away: Take a look at the report-Prelude version of (^).
13:40:08 <int-e> Gwern-away, jethr0: the implementation uses an extra constructor for small integers that fit into a machine word, but it's still a two constructor type and thus more expensive than Int.
13:40:14 <dmwit> Gwern-away: According to the spec, those two things should be the same.
13:40:21 <chessguy> #math
13:40:23 <int-e> and yes, Integer won't be unboxed.
13:40:26 <dmwit> (Maybe not in speed, but in answer.)
13:40:35 <Gwern-away> dmwit: ok. nice to be right for once :)
13:40:35 <chessguy> oops
13:40:46 <jethr0> k, thx
13:41:31 <dmwit> Gwern-away: It ends up boiling down to (x*x) in both cases... so you might just want to write that. =P
13:41:54 <EvilTerran> ?type (^2)
13:41:57 <lambdabot> forall a. (Num a) => a -> a
13:42:00 <EvilTerran> ?type (^)
13:42:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:42:04 <EvilTerran> hmm
13:42:32 <dmwit> EvilTerran: It's repeated multiplication, with repeated squaring.
13:42:42 <EvilTerran> dmwit, i figured
13:42:45 <Gwern-away> dmwit: they're not all ^2 though, and the authors are better at math than I so perhaps there was a reason? dunno
13:43:40 <dmwit> Gwern-away: Ah, ok.  In any case, as long as the number is in the Int range (and (-)/quot mean the same thing for Int/Integer) you should be fine.
13:44:14 <dmwit> where "the number" means "the exponent"
13:44:15 <ac> ok, I'm proud of this code ;) ...
13:44:17 <hpaste>  ac pasted "serialize / deserialize background chunk in PNGs" at http://hpaste.org/5421
13:44:30 <ac> can I eliminate the three returns in my case?
13:44:41 <conal> Saizan: (conal: that's particulary messy if you really want an interactive program).  i'd appreciate an example of what you think would turn out messy.  then i can play with some approaches to making it pretty.
13:44:53 <dmwit> ac: return $ case ...
13:44:59 <ac> dmwit: that didn't type cehck
13:45:04 <dmwit> ac: Never mind, I'm an idiot.
13:45:14 <dmwit> ac: But, how about:
13:45:27 <heatsink> ac: 1 -> liftM BGIndex getWord8
13:45:32 <dmwit> ac: fmap BGIndex getWord8 -- etc
13:45:47 <ac> heatsink: nice
13:46:05 <Twey> @src (^)
13:46:05 <lambdabot> Source not found. It can only be attributed to human error.
13:46:07 <Twey> @src ^
13:46:07 <lambdabot> Source not found. I am sorry.
13:46:10 <dmwit> The last one doesn't get much better, though:
13:46:11 * Twey fails.
13:46:28 <Twey> x ^ y = foldr (*) 1 (take 3 (cycle [2])) -- nicer way to write it than this?
13:46:33 <dmwit> fmap (\[r, g, b] -> (r, g, b)) (replicateM 3 getWord16be)
13:46:36 <b_jonas> me tries to install ghc 6.8.2 now
13:46:39 <ac> heatsink: much prettier
13:46:57 <EvilTerran> ac, or even use <$> ...
13:47:03 <dmwit> Well... "-> BGRGB (r, g, b)", but you get the idea.
13:47:23 <int-e> Twey: take 3 (cycle [2]) = take 3 (repeat 2) = replicate 3 2
13:47:51 <ac> that's what's great about #haskell... I hpaste code that I already think is amazingly concise, and it gets even more concise
13:48:02 <heatsink> Twey: foldr (*) 1 = product
13:48:04 <EvilTerran> int-e, = [2,2,2]? :P
13:48:19 <int-e> EvilTerran: sure
13:48:29 <EvilTerran> altho i suspect he meant replicate y x
13:48:29 <dmwit> x ^ y = product (replicate y x)
13:48:34 <heatsink> ac: That gives me an idea for an algorithm for computing Kolmgorov complexity.
13:48:45 <EvilTerran> it's not the most efficient algo, mind
13:48:55 <dmwit> heatsink: ...magical?
13:49:10 <djfroofy> hello haskellers
13:49:19 <dmwit> Hiya, djfroofy!
13:49:20 <Twey> int-e, heatsink, dmwit: Ah -- thanks!
13:49:38 <ac> heatsink: are you joking?
13:49:45 <djfroofy> i'm revisiting haskell and was trying to understand making generics data types to support reflection
13:50:02 <heatsink> ac: yes.  This channel is pretty good at shrinking program size.
13:50:27 <Twey> Heheh
13:50:31 <paolino> @src unlines
13:50:32 <lambdabot> unlines = concatMap (++ "\n")
13:50:36 <dmwit> djfroofy: Like Data.Dynamic-ish?
13:50:38 <ac> heatsink: ah I see. The algorithm simply becomes a matter of encoding anything in to Haskell code
13:50:41 <djfroofy> so i'm a little lost on how to "add an instance declaration for (Data XX)"
13:50:46 <djfroofy> dmwit: i think so
13:50:49 <EvilTerran> djfroofy, "deriving Data"
13:50:54 <djfroofy> basically deriving Data, yes
13:51:00 <EvilTerran> no, that's what you write.
13:51:07 <Twey> Heh
13:51:29 <EvilTerran> you don't write Data instances manually; that's the point of Data.Generics
13:51:32 <dmwit> ac: Also, do you know of mapM?
13:51:53 <ac> dmwit: yeah, but where can I use it?
13:52:05 <djfroofy> EvilTerran: ?  Where can I read more about this?
13:52:17 <dmwit> put (BGRGB (r, g, b)) = mapM putWord16be [r, g, b] -- ?
13:52:26 <ac> I thought it would work to use it in place of "foldr1 (>>) ..." but I couldn't get the types to match up
13:52:34 <dmwit> :t mapM
13:52:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:52:39 <ac> dmwit: you see, my method for writing haskell is trial and error
13:53:04 <dmwit> Oh, you want mapM_.
13:53:08 <dmwit> :t mapM_
13:53:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:53:20 <EvilTerran> djfroofy, http://www.cs.vu.nl/boilerplate
13:53:22 <lambdabot> Title: Scrap your boilerplate ... in Haskell
13:54:02 <Saizan> conal: first example i could think of: f xs = "Insert a string:\n" ++ let s = takeWhile (/= '\n') xs in seq (length s) "Here is your string in uppercase:\n" ++ map toUpper s ++ "\n"
13:54:41 <djfroofy> EvilTerran: yeah, so I'm reading this already - though in their examples they do write their own data types ...
13:54:47 <dmwit> ac: (Does that work?)
13:54:50 <djfroofy> for example: http://www.cs.vu.nl/boilerplate/testsuite/paradise/CompanyDatatypes.hs
13:54:50 <lambdabot> http://tinyurl.com/3bod7h
13:54:55 <EvilTerran> djfroofy, the papers go into more detail, but basically the point of Data.Generics and its relatives is to save you the hassle of writing your own generic traversal code
13:55:07 <EvilTerran> yes, you write your own data types
13:55:22 <EvilTerran> "data Company  = C [Dept]               deriving (Eq, Show, Typeable, Data)" <- note "deriving ... Data"
13:55:26 <EvilTerran> that's what I was referring to
13:55:26 <RayNbow> holy crap... I was already wondering why my comp was running slow...
13:55:38 <djfroofy> So my question boils down to simply: "How do I make String derive generic"
13:55:39 <RayNbow> there's a ghc process eating up 490 MB
13:55:56 <Twey> RayNbow: Haha, what're you compiling?
13:56:03 <EvilTerran> djfroofy, isn't it already?
13:56:07 <ac> dmwit: yeah
13:56:10 <dmwit> djfroofy: You need GHC 6.8.
13:56:14 <ac> dmwit: I should have realized I needed mapM_
13:56:29 <djfroofy> dmwit: ah, i'm on 6.6
13:56:38 <conal> Saizan: that one would be a simple interact, wouldn't it?
13:56:40 <EvilTerran> ?instances-importing Data.Generics Data
13:56:41 <lambdabot> (), (a -> b), (a, b), (a, b, c), (a, b, c, d), Bool, Char, DataType, Double, Either a b, Float, IO a, Int, Integer, Maybe a, Ordering, ST s a, TyCon, TypeRep, [a]
13:56:53 <RayNbow> Twey: nothing
13:56:58 <hpaste>  ac annotated "serialize / deserialize background chunk in PNGs" with "now #haskell-ized" at http://hpaste.org/5421#a1
13:56:59 <RayNbow> I'm running two ghci instances
13:57:01 <EvilTerran> djfroofy, [a] is already an instance of Data, and String is a special case of [a]
13:57:04 <dmwit> djfroofy: In 6.8 you can derive instances of things separately from declaring them.
13:57:08 <Twey> RayNbow: Ah
13:57:17 <EvilTerran> dmwit, yes, but that's not necessary here, as it's already an instance
13:57:23 <conal> Saizan: oh -- silly me.  it's already functional.  you're saying it's awkward, right?
13:57:29 <dmwit> EvilTerran: Oh, even better!
13:57:40 <Saizan> conal: exactly
13:57:50 <conal> Saizan: thx.
13:58:18 <EvilTerran> djfroofy, you don't need to upgrade, dmwit was confused ;)
13:58:19 <int-e> ac: you should stick to either liftM or fmap :)
13:58:42 <RayNbow> Twey: it's probably because I reloaded certain files several times over the past few hours... maybe it was still pointing to a lot of garbage I created :p
13:58:43 <conal> Saizan: btw, why the seq?  does it correspond to something implicit in an imperative formulation?
13:59:25 <ac> int-e: isn't liftM a little more specific?
13:59:53 <Cin> :t (->)
13:59:54 <ac> liftM makes sense to me, not sure I quite understand fmap yet
13:59:54 <lambdabot> parse error on input `->'
13:59:57 <Twey> RayNbow: Ah, heh
13:59:59 <EvilTerran> ac, yes, but you've used both there
14:00:06 <Saizan> conal: with no seq "Here is your string in uppercase:" would be printed before the user inserted the string, also, each character would be immediatly repeated in uppercase
14:00:16 <int-e> ac: liftM works for Monads, fmap for Functor; monads should come with Functor instances that satisfy  fmap === liftM
14:00:21 <ac> EvilTerran: yeah, I just pasted in what dmwit suggested
14:00:44 <Saizan> conal: having to tweak this things with seq it's most of the weirdness
14:01:16 <hpaste>  EvilTerran annotated "serialize / deserialize background chunk in PNGs" with "or this..." at http://hpaste.org/5421#a2
14:01:23 <conal> Saizan: ah!!  tricky!  thanks again.  :)
14:01:23 <dmwit> ac: liftM and fmap are the same function, basically.  As one of my math professors used to say: "Nothing to understand here!"
14:01:41 <int-e> ac: anyway, the code you pasted uses both, and all I'm saying is that you should pick one and stick to it, to avoid confusion.
14:01:43 <conal> Saizan: exactly the kind of thing i'm looking for.
14:01:43 <Twey> What does liftM do?
14:01:45 * shachaf remembers reading about Lazy K having the same problem.
14:01:47 <EvilTerran> <$> is another name for fmap
14:01:48 <shachaf> @src liftM
14:01:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:01:59 <int-e> @src (<$>)
14:02:00 <lambdabot> f <$> a = fmap f a
14:02:08 <EvilTerran> ?type (<$>)
14:02:08 <ac> int-e: yeah, I changed fmap to liftM
14:02:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:02:11 <dmwit> Twey: It puts a pure function into a monad.
14:02:22 <djfroofy> EvilTerran: hrrmmm, well weird it's working now.  too bad reiser kniffed his wife and I can't trace back my steps over changes to the file to see what I did wrong.
14:02:23 <shachaf> dmwit: "puts"?
14:02:31 <Gwern-away> ' add_matrices a b = matrix_zipWith (+)' <-- huh. pointless but pointful?
14:02:33 <shachaf> (That would be return, probably.)
14:02:34 <EvilTerran> ...
14:02:38 <dmwit> shachaf: Yes, basically.
14:03:26 <djfroofy> EvilTerran: anyhow, I have to use "-fglasgow-exts" for generics?
14:03:27 <shachaf> dmwit: return :: (Monad m) => (a -> b) -> m (a -> b) -- I mean. :-)
14:03:50 <EvilTerran> djfroofy, -XGenerics is more specific
14:03:50 <dmwit> shachaf: Okay, yes, my English was a bit ambiguous.
14:04:11 <EvilTerran> djfroofy, or you can put the line {-# LANGUAGE Generics #-} in your source file
14:04:14 <dons> ?users
14:04:14 <lambdabot> Maximum users seen in #haskell: 465, currently: 440 (94.6%), active: 25 (5.7%)
14:04:18 <dmwit> Maybe saying, "liftM turns a pure function into a monadic function" would be closer.
14:04:34 <EvilTerran> s/turns/lifts/! :D
14:04:47 <dmwit> *nods*
14:05:05 <dmwit> dons: My client says only 435 users; you should check up on that!
14:05:18 <djfroofy> EvilTerran: thanks, but I still get the error "You need -fglasgow-exts ..."
14:05:35 <idnar> mine also says 435
14:05:36 <EvilTerran> djfroofy, does it say what for?
14:05:59 <djfroofy> Can't make a derived instance of `Typeable Foo' (You need -fglasgow-exts to derive an instance for this class)
14:06:15 <djfroofy> bollocks
14:06:15 <BMeph> dmwit, shachaf: Although, it's a good word to use for it, since an alternate definition for f<$>x is pure f<*>x ;)
14:06:31 <LoganCapaldo> "liftM lifts a function into a monadic function", I think the pure part is unecessary and wrong (liftM putStrLn for example, or liftM (+) when M is a pure monad)
14:06:35 <dons> yeah, the bot seems to have not seen some people leave
14:06:40 <EvilTerran> djfroofy, oh well, use -fglasgow-exts then
14:06:44 <shachaf> BMeph: Assuming instances for Applicative and Functor with the appropriate laws. :-)
14:06:52 <shachaf> @src liftA
14:06:53 <lambdabot> liftA f a = pure f <*> a
14:06:53 <EvilTerran> never mind -XGenerics or whatever. it might be a 6.8 thing.
14:07:03 <BMeph> dmwit: Your client is ignoring the five bots in the channel. :)
14:07:13 <EvilTerran> ...five?
14:07:24 <djfroofy> EvilTerran: I think it is ... the -XGenerics flag wasn't recognized
14:07:25 <LoganCapaldo> everyone;'s a bot
14:07:36 <EvilTerran> @vixen you're not a bot, are you?
14:07:36 <lambdabot> a bot? what is that?
14:07:42 <dmwit> No girls on internet... only bots.
14:07:45 * shachaf is a bot.
14:07:51 <BMeph> shachaf: Well, since Applicaative is short for "applicative functor"... ;)
14:07:52 <litb> isn't pure the Functors' "return" ?
14:08:01 <olsner> everyone is a bot until a turing test shows otherwise
14:08:02 <BMeph> litb: Yes, it is.
14:08:06 <dmwit> :t pure
14:08:06 <lambdabot>     Ambiguous occurrence `pure'
14:08:07 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
14:08:07 <lambdabot>                           or `pure', imported from Control.Arrow
14:08:07 <shachaf> litb: It's Applicative's return, anyway.
14:08:11 <EvilTerran> well, the Ap- yeah.
14:08:15 <shachaf> @ty Control.Applcative.pure
14:08:16 <lambdabot> Couldn't find qualified module.
14:08:17 * LoganCapaldo is sparticus bot
14:08:18 <litb> i thought Applicative is another thing than Functor
14:08:24 <shachaf> litb: It is.
14:08:26 * heatsink is a _|_
14:08:28 <shachaf> litb: Functor has no return.
14:08:30 <EvilTerran> every Applicative is a Functor
14:08:32 <shachaf> @src Functor
14:08:32 <lambdabot> class  Functor f  where
14:08:32 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:08:35 <dmwit> Functors might not have a return.
14:08:36 <EvilTerran> at least in theory
14:08:43 <litb> shachaf: you know what i mean mate :)
14:08:46 <dmwit> heatsink: aaaahahaha
14:08:53 <litb> well
14:09:01 <LoganCapaldo> hmm, what's a good example of a functor without a return?
14:09:02 <shachaf> litb: Functor only has fmap.
14:09:07 <litb> ah Functor only has fmap and Applicative has that stuff
14:09:13 <litb> i see
14:09:21 <EvilTerran> Applicative has "pure" and "<*>"
14:09:26 <EvilTerran> (pronounced "apply)
14:09:51 <litb> i see. and <$> is an alias for fmap i suppose
14:09:57 <EvilTerran> yeah.
14:10:06 <dmwit> ?remember heatsink <LoganCapaldo> everyone's a bot <heatsink> * heatsink is a _|_
14:10:06 <lambdabot> Done.
14:10:08 <shachaf> LoganCapaldo: Perhaps (a,)?
14:10:24 <EvilTerran> shachaf, isn't that Writer?
14:10:25 <shachaf> LoganCapaldo: (return for that is usually defined with mempty, though.)
14:10:42 <LoganCapaldo> shachaf: yeah that works
14:10:50 <shachaf> EvilTerran: Well, (Monoid a) => (a,) is, perhaps.
14:11:04 <dmwit> ziplists?
14:11:09 <EvilTerran> pure = repeat
14:11:15 <dmwit> Oh, no, ziplists are applicative.
14:11:18 <dmwit> yeah
14:11:40 <b_jonas> is (a,) even a valid slice notation for (,) a as a type?
14:11:54 <b_jonas> @kind (Int,)
14:11:54 <shachaf> b_jonas: It is in #haskell. :-)
14:11:54 <lambdabot> parse error on input `)'
14:11:56 <dmwit> EvilTerran: non-empty lists ;-)
14:11:56 <ddarius> No.
14:11:58 <EvilTerran> b_jonas, no
14:12:08 <dmwit> bah, no
14:12:14 <b_jonas> nor as an expression, right?
14:12:15 <LoganCapaldo> we all knew what he meant :)
14:12:18 <EvilTerran> newtype Pair a = Pair (a,a) would be a working example, tho, i guess
14:12:18 <b_jonas> @type (1,)
14:12:19 <lambdabot> parse error on input `)'
14:12:30 <b_jonas> ok, good
14:12:34 <b_jonas> @type (,)1
14:12:34 <lambdabot> forall t b. (Num t) => b -> (t, b)
14:12:37 <EvilTerran> altho pure = join (,) would work...
14:12:39 <b_jonas> @kind (,)Int
14:12:40 <lambdabot> * -> *
14:12:40 <shachaf> EvilTerran: return = join (,)?
14:12:45 <shachaf> EvilTerran: (Or would that not work?)
14:13:03 <dmwit> I bet any container you can come up with is also a Monad.
14:13:04 <EvilTerran> but could you define <*> as well?
14:13:08 <BMeph> Happiness is a warm _|_. Well, unless you're a mis-behaving child... ;)
14:13:14 <dmwit> We are going to have to become more clever.
14:13:22 <shachaf> EvilTerran: LoganCapaldo just asked for return.
14:13:27 <ddarius> dmwit: Set
14:13:27 <EvilTerran> hmm
14:13:41 <LoganCapaldo> you I was interested in things with fmap but w/o pure
14:13:50 <LoganCapaldo> <*> is just bonus points :)
14:13:56 <LoganCapaldo> s/you/yeah/
14:14:03 <LoganCapaldo> but feel free to go off on a tangent <g>
14:14:23 <b_jonas> if I build ghc 6.8.2 from source using an older ghc, can I parallel make it?
14:14:29 <dmwit> ddarius: Yeah, well, ok.  But that isn't a Functor, either.
14:14:56 <EvilTerran> what about (Array i)?
14:15:06 <Saizan> b_jonas: with make -j? yes
14:15:11 <newsham> how do I use ghci with an ffi module?
14:15:22 <BMeph> src ((,)a) return
14:15:24 <dmwit> EvilTerran: return just puts the element in each slot
14:15:27 <EvilTerran> you can't define pure, as you can't make an array without knowledge of what size it's meant to be
14:15:38 <b_jonas> Saizan: thanks
14:15:43 <Saizan> newsham: you've linker errors?
14:15:59 <dmwit> EvilTerran: What's fmap?
14:16:08 <BMeph> @src ((,)a) return
14:16:08 <lambdabot> Source not found. You speak an infinite deal of nothing
14:16:12 <Saizan> newsham: if so you need to pass the .o as a command line argument
14:16:22 <BMeph> @src (,) return
14:16:22 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:16:23 <newsham> what about libs?  -L... -l...  ?
14:16:26 <shachaf> BMeph: return x = (mempty,x)
14:16:52 <EvilTerran> ?type amap
14:16:52 <lambdabot> Not in scope: `amap'
14:17:07 <BMeph> shachaf: But that doesn't make sense w/o defining the MonadPlus - what's mempty? ;)
14:17:19 <Saizan> newsham: never tried :\
14:17:21 <idnar> :t mempty
14:17:21 <lambdabot> forall a. (Monoid a) => a
14:17:24 <shachaf> BMeph: That's from Monoid.
14:17:25 <b_jonas> it's not a monad, so no return
14:17:37 <dmwit> EvilTerran: I'm not convinced.  Wouldn't making a one-element array count as a return?
14:17:53 <shachaf> BMeph: And it's mempty :: a, not :: (a,b)
14:17:57 <EvilTerran> instance Ix i => Functor (Array i) where fmap f a = listArray (bounds a) . map f . elems $ a
14:18:08 <EvilTerran> dmwit, okay then. what index is this element at? :D
14:18:26 <soduko> what is a is a rigid type variable ?
14:18:49 <hpaste>  newsham pasted "ghci/ffi fail" at http://hpaste.org/5422
14:18:50 <shachaf> soduko: One that doesn't bend.
14:18:59 <Saizan> the only rule is that fmap f (return a) = return (f a)?
14:19:00 <LoganCapaldo> soduko: I'm still not sure. All I know is it means I screwed something up, and I don't understand the type system as well as I wish I did :)
14:19:26 <EvilTerran> dmwit, Ix doesn't provide a way to get an element of the type without already having one
14:19:26 <dmwit> EvilTerran: Oh, uh, ...
14:19:36 <b_jonas> newsham++ wow
14:19:48 <newsham> hmm.. I can just put the -I and -L flags in the OPTIONS_GHC, right?
14:19:51 <BMeph> soduko: A rigid type variable, is a variable, whose type has already been inferred to something.
14:19:52 <soduko> shachaf: :) what does that mean in a haskell program? i get a compiler error if i use a variable as a second parameter, but if i put a numeric constant it works
14:20:24 <shachaf> @paste, maybe?
14:20:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:20:26 <Saizan> soduko: it means that you can't unify it with another polymorphic one, maybe you've misplaced a type signature
14:20:42 <EvilTerran> dmwit, so there's you're functor-without-return. Array i. :)
14:20:58 <int-e> > id :: a -> b
14:20:59 <lambdabot>  1:0-11
14:20:59 <lambdabot>     In the expression: id
14:20:59 <lambdabot>     In the expression: id :: a -> b
14:20:59 <lambdabot>     In ...
14:21:05 <hpaste>  soduko pasted "rigid type error" at http://hpaste.org/5423
14:21:08 <dmwit> EvilTerran: Pretty good!
14:21:56 <EvilTerran> altho, in a way, i guess you could say that (a,) (as compared to, say, Monoid a => a) isn't, using the same trick
14:22:09 <EvilTerran> as you could put, say, an Enum constraint on the index type, and use that to get a value
14:22:34 <litb> ken_: :)
14:22:36 <LoganCapaldo> soduko: you forgot the Show constraint I think
14:22:38 <dmwit> soduko: The problem is that nv isn't guaranteed to be an Int.
14:22:39 <LoganCapaldo> in header
14:22:55 <soduko> but it complains about nc
14:22:58 <LoganCapaldo> Integral ness doesn't guarantee showyness
14:23:05 <EvilTerran> it doesn't?
14:23:08 <shachaf> @src Integral
14:23:08 <lambdabot> class  (Real a, Enum a) => Integral a  where
14:23:09 <lambdabot>     quot, rem, div, mod :: a -> a -> a
14:23:09 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
14:23:09 <lambdabot>     toInteger           :: a -> Integer
14:23:12 <LoganCapaldo> does it?
14:23:12 <shachaf> @src Real
14:23:12 <lambdabot> class  (Num a, Ord a) => Real a  where
14:23:13 <lambdabot>     toRational      ::  a -> Rational
14:23:15 <shachaf> @src Num
14:23:15 <lambdabot> class  (Eq a, Show a) => Num a  where
14:23:15 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:23:16 <lambdabot>     negate, abs, signum     :: a -> a
14:23:19 <lambdabot>     fromInteger             :: Integer -> a
14:23:21 <shachaf> It seems to.
14:23:26 <LoganCapaldo> i gues it does
14:23:27 <hpaste>  int-e annotated "rigid type error" with "possible fix - use genericLength" at http://hpaste.org/5423#a1
14:23:35 <shachaf> > show (1 :: Integral a => a)
14:23:36 <lambdabot>  "1"
14:23:40 <Saizan> siti: because nc :: Int, but you're using with something you've declared as Num n => n
14:23:45 <EvilTerran> much to many people's annoyance, it does
14:23:56 <LoganCapaldo> that's stupid
14:24:09 <ddarius> LoganCapaldo: Yep
14:24:31 <EvilTerran> i guess it's show.fromInteger.toInteger
14:24:34 <soduko> int-e: sorry but that didnt help. i had tried that before too
14:24:48 <int-e> soduko: anyway, the 'rigid' type variable is usually a type variable in a type signature. it's really a constant - as far as type checking is concerned - but a constant of unknown value! that's awkward, 'rigid variable' is a nicer term.
14:25:08 <int-e> soduko: I tried that, so it does help. note that I removed the :: Int of nc, too.
14:25:11 <soduko> even if i remove the :Int i get the error, thats why i tried putting it there. should i try ::Num ?
14:25:53 <dmwit> soduko: You need both changes; remove :: Int *and* use genericLength.
14:26:02 <soduko> int-e: sorry i forgot to change genricLength
14:26:18 <soduko> :t genericLength
14:26:18 <lambdabot> forall b i. (Num i) => [b] -> i
14:27:11 <LoganCapaldo> Hmm
14:27:29 <LoganCapaldo> I know f (x :: T) is a ghc extension (right?)
14:27:38 <EvilTerran> LoganCapaldo, in a pattern, yes
14:27:39 <int-e> LoganCapaldo: yes.
14:28:13 <LoganCapaldo> I wonder if this works
14:28:48 <soduko> int-e:  thanks, now on to the next problem.. getting a pretty output.
14:29:11 <LoganCapaldo> @type let ((plus (x :: Int) (y :: Int)) :: Int)= x + y in plus
14:29:12 <lambdabot> Parse error in pattern
14:29:30 <glen_quagmire> :t bot
14:29:31 <lambdabot> Not in scope: `bot'
14:29:47 <dmwit> :t let bot = bot in bot
14:29:48 <lambdabot> forall t. t
14:30:04 <dmwit> (That's the usual definition, if you're reading a paper.)
14:30:15 <glen_quagmire> oh bottom
14:30:23 <dmwit> yeah
14:30:38 <LoganCapaldo> :t let bot = error "more than meets the eye" in bot
14:30:39 <lambdabot> forall a. a
14:31:12 <dmwit> > let bot = bot in bot -- I <3 GHC
14:31:13 <lambdabot>  Exception: <<loop>>
14:31:14 <shachaf> > let _I_ = _I_ in _I_ -- <<loop>>
14:31:15 <lambdabot>  Exception: <<loop>>
14:31:24 <litb> hehe shachaf
14:31:27 <dmwit> Beatcha to it!
14:32:03 * BMeph pats his wife's (_|_)
14:32:25 <dmwit> > let bot = error "<<loop>>" in bot -- indistinguishable
14:32:25 <lambdabot>  Exception: <<loop>>
14:33:02 <LoganCapaldo> > fix (\a -> a) -- this is lambda bot
14:33:02 <lambdabot>  Exception: <<loop>>
14:33:07 <litb> > let hehe = error "No, sorry, this isn't one" in hehe
14:33:07 <lambdabot>  Exception: No, sorry, this isn't one
14:33:46 <shachaf> > fix (error "<<loop>>")
14:33:47 <lambdabot>  Exception: <<loop>>
14:34:04 <b_jonas> > undefined
14:34:05 <lambdabot>  Undefined
14:34:11 <idnar> this is lambdaaaaaaaaaaaaaaaaaboooooooooooooooot!
14:34:11 <LoganCapaldo> get it? I used a lambda to make bot. So it's lambda bot!
14:34:27 <dmwit> =)
14:34:29 <b_jonas> LoganCapaldo: make a lambdacats from that pun
14:34:53 <Saizan> i want one with "mutable arrays are mutable"
14:35:37 <litb> how can i get the ascii code of Char ?
14:35:44 <LoganCapaldo> > ord 'a'
14:35:45 <dmwit> ord
14:35:45 <lambdabot>  97
14:35:49 <litb> ah, thxx
14:35:49 <dmwit> It's in Data.Char.
14:35:50 <b_jonas> wtf
14:35:56 <b_jonas> I thought it was fromEnum
14:35:59 <LoganCapaldo> > fromEnum 'a'
14:35:59 <lambdabot>  97
14:36:05 <EvilTerran> ?src chr
14:36:05 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:36:09 <dmwit> Also acceptable. =)
14:36:11 <EvilTerran> ?src Char fromEnum
14:36:11 <lambdabot> Source not found. You untyped fool!
14:36:15 <EvilTerran> hmpf.
14:36:18 <dmwit> > toEnum 97 :: Char
14:36:19 <lambdabot>  'a'
14:36:25 <idnar> :t EvilTerran
14:36:26 <lambdabot> Not in scope: data constructor `EvilTerran'
14:36:27 <LoganCapaldo> > chr 97
14:36:27 <lambdabot>  'a'
14:36:45 <shachaf> > fix idnar
14:36:46 <lambdabot>  "EvilTerran"
14:36:51 <jethr0_> any ideas where i'd get a ghc6.8 under ubuntu gutsy gibbons? (unstable, debian repository, ...)
14:36:53 <litb> from back again?
14:36:54 <LoganCapaldo> wt
14:37:00 <LoganCapaldo> > idnar
14:37:00 <lambdabot>   Not in scope: `idnar'
14:37:15 <EvilTerran> hehe
14:37:16 <dmwit> He's to fast at ?undefine for you. =)
14:37:20 <litb> errm. i mean from the code to the char?
14:37:30 <dmwit> litb: chr
14:37:39 <LoganCapaldo> we did that tooo
14:37:44 <litb> ah, i think i should better use <TAB> more in ghci o.O
14:37:50 <dmwit> ord/chr and fromEnum/toEnum are basically inverses
14:37:52 <LoganCapaldo> > map (chr . ord) "wee"
14:37:53 <lambdabot>  "wee"
14:38:00 <b_jonas> @type (ord,chr)
14:38:00 <lambdabot> (Char -> Int, Int -> Char)
14:38:24 <idnar> @type ord . chr
14:38:25 <lambdabot> Int -> Int
14:38:28 <idnar> @type chr . ord
14:38:29 <lambdabot> Char -> Char
14:38:42 <b_jonas> jethr0_: try http://haskell.org/ghc/download.html
14:38:59 <EvilTerran> @check (==) <*> (ord.chr)
14:39:00 <lambdabot>   Not in scope: `<*>'
14:39:05 <EvilTerran> @check (==) `ap` (ord.chr)
14:39:06 <lambdabot>  Exception: Prelude.chr: bad argument
14:39:07 <jethr0_> b_jonas: i'm looking at it right now. but i had hoped for a binary package for ubuntu
14:39:20 <EvilTerran> @check (==) `ap` (chr.ord) -- (-.-)
14:39:21 <lambdabot>  OK, passed 500 tests.
14:39:51 <litb> > zipWith ($) [chr . (+1) . ord, chr . (+14) . ord, chr . (subtract 13) . ord] "cat"
14:39:52 <lambdabot>  "dog"
14:39:53 <b_jonas> jethr0_: http://haskell.org/ghc/distribution_packages.html
14:39:55 <litb> o.O
14:40:27 <jethr0_> yes, i've got ghc6.6 as an ubuntu package. but am looking for 6.8. i guess i'll look at the unstable branch then
14:41:35 <dmwit> > let homomorph f f' g = f' . g . f; onChar = homomorph ord chr in zipWith ($) [onChar (+1), onChar (+14), onChar (subtract 13)] "cat"
14:41:35 <lambdabot>  "dog"
14:41:44 <litb> let u x = chr . (+x) . ord in zipWith ($) [u 1, u 14, u (-13)] "cat"
14:41:52 <litb> at least better than before :)
14:42:08 <Cin> holy crap i understand this monadish type State st a = st -> (st, a)
14:42:11 <Cin> in YAHT
14:42:24 <LoganCapaldo> hooray
14:42:31 <dmwit> > let u x = chr . (+x) . ord in zipWith u [1, 14, -13] "cat"
14:42:32 <lambdabot>  "dog"
14:42:34 <Cin> man that took like half an hour of reasoning over the same page
14:42:35 <dolio> jethr0_: Yeah, there's no gutsy package. It doesn't take that long to build 6.8.x, depending on your computer, though.
14:43:03 <Saizan> the generic linux package works fine.
14:43:35 <LoganCapaldo> @type x (f, a) = f a
14:43:36 <lambdabot> parse error on input `='
14:43:49 <LoganCapaldo> @type \(f, a) -> f a
14:43:50 <lambdabot> forall t t1. (t -> t1, t) -> t1
14:43:56 <b_jonas> dolio: I'm building it right now, and it's not so fast
14:45:00 <dons> awesome, http://reddit.com/r/programming/info/67h79/comments/ Purely functional recursive types in Haskell and Python (sigfpe.blogspot.com)
14:45:10 <litb> @pl (\x y -> ord x - ord y)
14:45:10 <lambdabot> (. ord) . (-) . ord
14:45:23 <dolio> Takes a couple hours here, maybe.
14:46:28 <dolio> @type (-) `on` ord
14:46:29 <lambdabot> Not in scope: `on'
14:47:12 <dropdrive> Is there a way to spot (automatically) unnecessary parentheses?
14:47:47 <Twey> The parser would have to be function-aware.
14:47:58 <b_jonas> dropdrive: all or only some?
14:48:02 <litb> hm, composition reads (. (. (.))) ? or the other way around?
14:48:15 <b_jonas> litb: other I think
14:48:36 <b_jonas> @pf \x y -> f (g x y)
14:48:37 <lambdabot> Maybe you meant: bf pl
14:48:39 <b_jonas> @pl \x y -> f (g x y)
14:48:40 <lambdabot> (f .) . g
14:48:41 <dropdrive> b_jonas: well, all :)
14:48:49 <b_jonas> @pl \f g x y -> f (g x y)
14:48:49 <lambdabot> (.) . (.)
14:48:54 <b_jonas> hmm
14:48:55 <litb> (. ord) . (-) . ord
14:49:16 <litb> ah, now i see how that works
14:49:21 <litb> if i go from left to right
14:49:29 <b_jonas> dropdrive: because of the not really well defined haskell syntax, finding all unneccesary parenthesis would be quite difficult
14:49:57 <dropdrive> b_jonas: I mean, here's a way: take the source, randomly remove a pair of matching parens, recompile, if the result (bytecode?) is the same, then the parens are unnecessary.
14:50:27 <b_jonas> dropdrive: that could work, yes
14:50:34 <litb> it will get a Char. then it wants a function to feed the Int into. thet is the one that is retured by (-) . ord if i read it correctly
14:51:52 <dropdrive> b_jonas: The reason I ask is I'm just not really up to speed with levels of precedence and left/right associativity.  E.g. does this work?  (1+) `id` (+1) 1
14:52:14 <dropdrive> > (1+) `id` (+1) 1
14:52:15 <lambdabot>  3
14:53:04 <b_jonas> ah, make finished
14:53:10 <khadrin> @src Int
14:53:10 <lambdabot> data Int = I# Int#
14:53:15 <khadrin> what is I#?
14:53:21 <Twey> @pl (\x y z w -> (x (y z)) w)
14:53:22 <lambdabot> (.)
14:53:38 <litb> uh Int is a datatype?
14:53:42 <Twey> ...
14:53:50 <litb> yeah, what the heck is that I# good question :)
14:53:53 <Twey> Since when does (.) take four arguments?
14:54:02 <Twey> :t (.)
14:54:03 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:54:10 <Twey> :t (\x y z w -> (x (y z)) w)
14:54:11 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1) -> t -> t2 -> t3
14:54:29 <Twey> Looks pretty different to me.
14:54:33 <b_jonas> @src Double
14:54:33 <lambdabot> data Double = D# Double#
14:54:46 <khadrin> @src Integer
14:54:46 <lambdabot> data Integer = S# Int#
14:54:46 <lambdabot>              | J# Int# ByteArray#
14:55:05 <b_jonas> ah, so I# is just the name of the data constructor
14:55:43 <pejo> khadrin unboxed types. http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html
14:55:45 <lambdabot> Title: 8.2. Unboxed types and primitive operations, http://tinyurl.com/y59rbr
14:56:08 <resiak> @ty (.) :: (t1 -> t2 -> t3) -> (t -> t1) -> t -> t2 -> t3
14:56:09 <lambdabot> forall t1 t2 t3 t. (t1 -> t2 -> t3) -> (t -> t1) -> t -> t2 -> t3
14:56:59 <resiak> Twey: it's just instantiating the type variable "c" in the most general type to an arrow type
14:58:33 <khadrin> pejo: thanks!
15:00:03 <Cin> i think i may actually get monads
15:00:06 * Cin wipes tears from eyes
15:00:16 <Cin> it's.. beautiful  @_@
15:00:31 <jethr0> cin, there's always more ^_^
15:00:51 <b_jonas> I've got some of them when I understood these simple monad transfomers
15:00:59 * litb likes list monads
15:01:19 <Cin> YAHT's explanation of them is great
15:02:00 <litb> meh, maybe i'm teh loser now. but i don't liek Yaht :)
15:02:25 <khadrin> its not my favorite
15:02:48 <litb> well, i like it, but i don't like its monad chapter. there are much better out there imho
15:03:28 <litb> > filterM (const [True, False]) [1, 2, 3]
15:03:31 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
15:03:36 <khadrin> its good, just not my fave
15:03:49 <litb> i really enyou that function :)
15:04:30 <litb> muhaha did i say enyou? meh i mean enjoy. my english is really silly i know
15:04:43 <khadrin> how does Integer dffer from Int ?
15:05:01 <dmwit> > 2^50 :: Int
15:05:02 <lambdabot>  0
15:05:06 <dmwit> > 2^50 :: Integer
15:05:06 <lambdabot>  1125899906842624
15:05:18 <Cin> int doesn't support power?
15:05:27 <dmwit> No, Int is bounded.
15:05:41 <litb> > iterate (*1000) 1
15:05:41 <khadrin> cool
15:05:42 <lambdabot>  [1,1000,1000000,1000000000,1000000000000,1000000000000000,100000000000000000...
15:05:50 <dmwit> Int is a machine-Int, Integer is arbitrarily large.
15:05:55 <Cin> ohhh
15:05:57 <Cin> i see
15:06:03 <roconnor> > 2^30 :: Int
15:06:03 <lambdabot>  1073741824
15:06:12 <Cin> dmwit: is Int supposed to save space or speed or something?
15:06:15 <roconnor> > 2^31 :: Int
15:06:16 <lambdabot>  -2147483648
15:06:20 <dmwit> Cin: Yes to both.
15:06:21 <roconnor> > 2^32 :: Int
15:06:21 <cjb> Cin: it does save speed and space.
15:06:21 <lambdabot>  0
15:06:41 <Cin> fair enough
15:07:32 <khadrin> 2^32 - 1 :: Int
15:07:36 <dons> you can represent an Int with a raw machine word. while Integer needs a tag, and a bytearray..
15:07:38 <litb> > dropWhile (< (2^32-1)) $ iterate (+1) 1
15:07:40 <khadrin> > 2^32 - 1 :: Int
15:07:40 <lambdabot> Terminated
15:07:42 <lambdabot>  -1
15:08:01 <khadrin> > 2^31 :: Int
15:08:01 <lambdabot>  -2147483648
15:08:10 <resiak> so, tagging works by stealing the top bit of the word and saying "if 0, then the rest of the word is a 31-bit int; otherwise, it's a pointer", right?
15:08:11 <litb> > 2^21-1 :: Int
15:08:11 <lambdabot>  2097151
15:08:13 <litb> err
15:08:20 <litb> > 2^32-1 :: Int
15:08:21 <lambdabot>  -1
15:08:23 <litb> oh
15:08:28 <litb> ah someone else tried it
15:08:37 <resiak> so, ignorant question time: what if the top bit of the address that needs to be pointed to is not meant to be 1?  :-)
15:09:13 <jethr0> argh, cabal is killing me. i'm looking at pcre-light right now, but can't find where it tells cabal how to compile the .hsc file. and mine won't compile........
15:09:26 <litb> > fromIntegral(2^32-1) :: Int
15:09:26 <lambdabot>  -1
15:09:26 <pejo> resiak, hm? Addresses are usually aligned in multiples of some power of two, I would have expected to steal the low bits.
15:09:32 <litb> kay, i give up
15:09:45 <resiak> pejo: oh, sure, but surely the same problem applies?
15:09:49 <dmwit> ?pl \x xs f -> f x xs
15:09:49 <lambdabot> flip . flip id
15:10:30 <pejo> resiak, ignore my comment, you were discussing something totally different. (I need to start reading from the top of my screen, not bottom).
15:10:38 <pejo> Sorry.
15:10:43 <ddarius> resiak: Depending on which you want to make efficient, usually you use the low bits and if say low bit 1 == 1 means pointer, you have to mask it off before dereferencing.
15:10:58 <resiak> ddarius: sure, but then 0b11010000 can't be used as a pointer
15:11:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5424
15:11:37 <RayNbow> hmm, is there an easy way to change [(a,b)] into [(a, m b)]? I'm currently using map and a lambda function
15:11:54 <resiak> oh, but actually, pejo may have given the answer: you align everything to a multiple of 2, then use last_bit == 0 => pointer, and last bit == 1 => int
15:12:00 <ddarius> resiak: I'm assuming you have the low order bits first there?  Yes, if you use the low order bits, then you can only have pointers 2^m aligned (where m is the number of low order bits you used)
15:12:23 <resiak> and that's just accepted?
15:12:42 <cts> ?
15:13:45 <LoganCapaldo> @type map (second return)
15:13:45 <ddarius> resiak: Usually pointers should/need to be aligned for performance or architechtural reasons.
15:13:47 <lambdabot> forall b (m :: * -> *) d. (Monad m) => [(d, b)] -> [(d, m b)]
15:14:31 <ddarius> If you do need a pointer that can be at any alignment there's no trouble dealing with that using the type system or boxing.
15:15:34 <dmwit> resiak: Actually, I think pointer tagging uses the bottom two bits (pointers are 4-byte aligned).  The remaining bits are *always* a pointer.
15:15:50 <resiak> aha!
15:16:00 <kpreid> RayNbow: what LoganCapaldo said is an answer
15:16:01 <dmwit> resiak: But, the bottom four bits can encode the first three *constructors* of the type.
15:16:17 <LoganCapaldo> @type fmap (fmap return) :: Monad m => [(a, b)] -> [(a, m b)]
15:16:18 <lambdabot> forall a b (m :: * -> *). (Monad m) => [(a, b)] -> [(a, m b)]
15:16:18 <dmwit> resiak: This helps immensely with pattern-matching, which is common.
15:16:53 <ddarius> bottom two
15:17:02 <resiak> right, so if you have data Foo = A Bar | B Baz | C Bop, it's represented as a pointer to a (bar|baz|bop), and which one is indicated by the bottom two bits
15:17:12 <dmwit> Yes, sorry, the bottom two bits.
15:17:19 <litb> darn i forgot about second. some silly arrow stuff
15:17:24 <dmwit> resiak: yep!
15:17:28 <resiak> nifty
15:17:41 <dmwit> resiak: If there are only four constructors, you can represent all of them that way.
15:17:42 <resiak> that's quite a nice consequence of pointers being aligned
15:18:03 <dmwit> resiak: (Otherwise you have to use the fourth one to say "I don't know.")
15:18:46 <litb> > second (*2) (10, 5)
15:18:47 <lambdabot>  (10,10)
15:19:20 <pejo> dmwit, isn't the fourth one used for exactly that in ghc?
15:19:28 <shachaf> > (*2) <$> (10,5)
15:19:29 <lambdabot>  (10,10)
15:19:46 <dmwit> I recall reading article about this.  This kind of thing (abusing the bottom bits of pointers) has been done before.  Usually, it's used to give information about the *type* being pointed to.  But in Haskell, we *know* the type, so we can encode part of the value!
15:19:53 <dmwit> pejo: I'm sure it is!
15:20:18 <litb> @src (->) fmap
15:20:18 <lambdabot> fmap = (.)
15:21:11 <litb> shachaf: hm what Functor is that tuple from?
15:21:16 <dons> looks nice, http://reddit.com/r/programming/info/67h9y/comments/ (A syntax highlighting library for Haskell: generate highlighters from syntax definitions (article.gmane.org)
15:21:22 <dmwit> The (a,) Functor.
15:21:53 <litb> @src (,) fmap
15:21:53 <lambdabot> fmap f (x,y) = (x, f y)
15:21:58 <litb> ah nice
15:22:09 <conal> dons: neat.  thanks!  i like his pandoc.
15:22:18 <RayNbow> kpreid, LoganCapaldo, sorry for the late reply (I wasn't paying attention to the chat), but thx :)
15:22:55 <olsner> anyone else using Frisby? is there any (nice) way to get state into a frisby parser?
15:23:16 <RayNbow> ah, second is in the Arrow module
15:23:18 <Gwern-away> dons: I wish the highlighting was being done through alex, so it'd be easy to adapt into yi :(
15:23:21 <litb> nice it's for the kde kate?
15:23:35 <conal> what's Kate, btw?
15:23:59 <Saizan> kde's text editor
15:24:05 * RayNbow should add Arrows to the to-learn list
15:24:07 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5424#a1
15:24:30 <litb> RayNbow: yeah, arrow seem to be very useful imho
15:24:30 <shachaf> Yi still doesn't do its own highlighting?
15:24:56 <Saizan> it uses hscolour?
15:25:00 <Gwern-away> shachaf: no, it does, but it doesn't support very many languages
15:25:10 <shachaf> litb: Have you used any instance other than (->)? :-)
15:25:14 <conal> Saizan: oh.  the text editor defines a syntax meta-language?
15:25:16 <litb> well i will do one for c++ if i get time :)
15:25:19 <BMeph> RayNbow: Add this link to you "TODO" list, then - http://www.haskell.org/arrows/
15:25:19 <lambdabot> Title: Arrows: A General Interface to Computation
15:25:48 <RayNbow> BMeph: thx
15:25:55 <litb> shachaf: i used &&& sometimes (id&&&(*2))
15:26:05 <litb> shachaf: i'm not sure but is that (->) ?
15:26:31 <conal> on kate, yack -- xml!  is there also a human-friendly format for kate specs?
15:26:57 <RayNbow> btw, anyone else familiar with the phenonema that ToDo/Learn/Watch/Read/Etc lists tend to grow faster than they shrink? :p
15:27:13 <conal> RayNbow: you bet
15:27:16 <shachaf> RayNbow: Mine almost never shrink. :-(
15:27:18 <b_jonas> RayNbow: sure
15:27:36 <dmwit> I've pegged my CPU trying to find a solution to the 13-queens problem.
15:27:42 <litb> mh there are so many things i want to learn but i haven't the time to do so
15:28:19 <litb> dmwit: something from project-euler ?
15:28:36 <dmwit> litb: No, just for fun.  It's been several minutes now...
15:29:06 <litb> @src (->) &&&
15:29:06 <lambdabot> Source not found. You untyped fool!
15:29:20 <litb> @src (->) (&&&)
15:29:20 <lambdabot> Source not found. Maybe you made a typo?
15:29:22 <litb> hmm
15:29:35 <sjanssen>  @src is quite incomplete
15:30:20 <resiak> dmwit, ddarius, pejo: thanks for clearing that up.  i was thinking about it while walking home (as you do) and i was troubled!
15:30:24 <litb> oh it isn't defined in ->
15:30:47 <shachaf> @src (&&&)
15:30:47 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
15:32:07 <litb> i have still to see where i can make use of the other instances of it
15:32:25 <pejo> RayNbow, "Get Things Done" has a workaround for that. Create a "Some day/Maybe" list where you put things you don't immediately intend to start working on, and reserve your todo-list for 15-20 "short" tasks that carry you towards completion of your current projects.
15:34:31 <dmwit> litb: Do you even know of other instances of Arrow?
15:34:48 <ddarius> dmwit: Why would one care?
15:34:49 <b_jonas> @instances Arrow
15:34:51 <lambdabot> (->), Kleisli m
15:34:56 <b_jonas> see
15:35:02 <litb> dmwit: no =)
15:35:16 <dmwit> ddarius: Well, it's hard to see how to use other instances if you don't know of any other instances.
15:35:30 <ddarius> Ah, I missed that comment.
15:35:39 <litb> dmwit: there seem to be some bridge between Arrow and Monad. but i don't know how i should use it :)
15:35:39 <ddarius> Yeah, the only "standard" instances are "trivial" ones.
15:35:50 <ddarius> Kleisli is that bridge.
15:36:07 <ddarius> But there is little reason to use a Kleisli Arrow rather than using the monad directly.
15:36:13 <litb> well sounds strange but well, maybe it's something awesome too
15:36:28 <litb> i see
15:37:17 <ddarius> That said, Kleisli perfectly joins the intuition behind Freyd categories and monads (as applied to programming).
15:37:36 <litb> while i would maybe know when to make something a Monad, i certainly don't know when to make something an Arrow :)
15:38:50 <litb> i've bought the book of Richard Bird. maybe that has some insights
15:39:12 <ddarius> It should, but not about this.
15:39:25 <conal> litb: one reason to use an arrow instead of a monad is for static analysis/optimization.  you can't look inside of an a -> m b .
15:39:29 <litb> you know which book is good about such math stuff?
15:40:37 <jethr0> anyone proficient in cabal?
15:40:37 <conal> litb: arrows let you combine transformations with static info.  e.g., in parsing, the static info might be lookahead sets.  in guis, it might be the structure of the gui and even the particular widgets.
15:40:41 <litb> conal: a -> m b ?
15:41:04 <conal> litb: with monads, a lot of useful functionality has type a -> m b, where m is the monad.
15:41:14 <LoganCapaldo> isn't that ability also a downside?
15:41:24 <conal> litb: because it's a function, you can't learn anything about it independently of a particular argument.
15:42:46 <jethr0> anyone have experience with cabal?
15:42:56 <conal> LoganCapaldo: i dont' know.  do you have a downside in mind?
15:43:40 <LoganCapaldo> I was thinking it limits the operations you can do, but I guess it doesn't really
15:43:56 <ddarius> LoganCapaldo: Obviously it does.  That's why such things are Arrows but not Monads.
15:44:02 <LoganCapaldo> there will jut be things the static analysis doesn't know about
15:45:24 <nolrai> @hoggle [a -> a] -> a -> a
15:45:25 <lambdabot> No matches, try a more general search
15:45:33 <nolrai> @hoggle a -> [a -> a] -> a
15:45:34 <lambdabot> No matches, try a more general search
15:45:45 <conal> @ty map (flip ($))
15:45:46 <lambdabot> forall a b. [a] -> [(a -> b) -> b]
15:46:09 <conal> @ty flip (map ($))
15:46:09 <lambdabot>     Couldn't match expected type `b -> c'
15:46:09 <lambdabot>            against inferred type `[a -> b1]'
15:46:09 <lambdabot>     In the first argument of `flip', namely `(map ($))'
15:46:22 <conal> @ty flip (map (flip ($)))
15:46:23 <lambdabot>     Couldn't match expected type `b -> c'
15:46:23 <lambdabot>            against inferred type `[(a -> b1) -> b1]'
15:46:23 <lambdabot>     In the first argument of `flip', namely `(map (flip ($)))'
15:46:27 <conal> :p
15:46:40 <resiak> nolrai: head!
15:46:40 <dmwit> :t foldr1 ($)
15:46:41 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
15:46:41 <lambdabot>     Probable cause: `$' is applied to too many arguments
15:46:41 <lambdabot>     In the first argument of `foldr1', namely `($)'
15:47:15 <dmwit> resiak: ...you know what he wants to do. =P
15:47:21 <dmwit> :t foldr
15:47:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:47:30 <BMeph> @oeis
15:47:35 <dmwit> :t foldr1
15:47:36 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
15:47:39 <conal> @ty appEndo . foldr id . Endo
15:47:41 <nolrai> resiak: yeah but not quit what i whant :P :)
15:47:42 <lambdabot> Sequence not found. Maybe you made a typo?
15:47:43 <lambdabot>     Couldn't match expected type `Endo a'
15:47:43 <lambdabot>            against inferred type `[Endo a1 -> Endo a1] -> Endo a1'
15:47:43 <lambdabot>     In the second argument of `(.)', namely `(foldr id) . Endo'
15:47:46 <resiak> dmwit: yeah, i do :-)
15:48:09 <dmwit> :t foldr1 (.)
15:48:09 <lambdabot> forall b. [b -> b] -> b -> b
15:48:13 <conal> @ty appEndo . foldr id . map Endo
15:48:13 <lambdabot>     Couldn't match expected type `Endo a'
15:48:14 <lambdabot>            against inferred type `[[Endo a1] -> [Endo a1]] -> [Endo a1]'
15:48:14 <lambdabot>     In the second argument of `(.)', namely `(foldr id) . (map Endo)'
15:48:17 <dmwit> There we go!
15:48:18 <conal> sorry, guys
15:48:32 <nolrai> thanks!
15:48:32 <jethr0> caba-ha-ha-l
15:48:35 <conal> oh, that's much simpler.
15:48:48 <BMeph> @oeis 1,0,0,2
15:48:49 <lambdabot> Sequence not found. Just try something else.
15:48:51 <conal> oh -- i was going for concat
15:48:53 <resiak> :t foldr1 (.) id
15:48:54 <lambdabot>     Couldn't match expected type `[b -> b]'
15:48:54 <lambdabot>            against inferred type `a -> a'
15:48:54 <lambdabot>     In the second argument of `foldr1', namely `id'
15:49:00 <resiak> :t foldr (.) id
15:49:00 <lambdabot> forall a. [a -> a] -> a -> a
15:49:04 <resiak> totalness!
15:49:06 <BMeph> @help oeis
15:49:06 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
15:49:06 <jethr0> @oeis 0,1,0,1,0,1
15:49:06 <dmwit> jethr0: What's wrong?
15:49:07 <lambdabot> Sequence not found. Take a stress pill and think things over.
15:49:08 <conal> @ty concat
15:49:09 <lambdabot> forall a. [[a]] -> [a]
15:49:17 <conal> @ty mconcat
15:49:17 <jethr0> dmwit: i'm having trouble with cabal
15:49:17 <lambdabot> forall a. (Monoid a) => [a] -> a
15:49:24 <jethr0> it won't compile my hsc-file
15:49:35 <jethr0> and i don't know where to look this up
15:49:46 <resiak> > mconcat [(+2),(*3)] 1
15:49:47 <lambdabot>  Add a type signature
15:49:53 <resiak> > mconcat [(+2),(*3)] (1::Int)
15:49:54 <litb> :t mconcat
15:49:54 <lambdabot>   add an instance declaration for (Monoid Int)
15:49:54 <lambdabot>     In the expression: mconcat...
15:49:54 <lambdabot> forall a. (Monoid a) => [a] -> a
15:50:07 <dmwit> jethr0: Have a look at the X11 package's cabal file, I know it has some .hsc files.
15:50:14 <resiak> yarr
15:50:26 <jethr0> dmwit: so does pcre-light. but there's no mention anywhere of the hsc file
15:50:36 <resiak> there's no Monoid (a->a) instance, is there?
15:50:37 <litb> @src [] mconcat
15:50:37 <lambdabot> Source not found.
15:50:47 <dons> you don't need to list .hsc files specially. they're just exported modules as normal
15:50:48 <dmwit> ?instances Monoid
15:50:49 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
15:51:05 <litb> i wonder what mconcat does
15:51:06 <resiak> i stand corrected
15:51:10 <RayNbow> pejo: ah, but the todo lists I was talking about were not really project related :)
15:51:10 <BMeph> @oeis 1,1,1,1,1,1,1,1
15:51:16 <lambdabot> Sequence not found. It can only be attributed to human error.
15:51:23 <Saizan> ?src mconcat
15:51:24 <lambdabot> Source not found. Just try something else.
15:51:40 <BMeph> Yep, looks like OEIS itself is down. Pity.
15:51:43 <Saizan> mconcat xs = foldr mappend empty xs
15:51:46 <jethr0> dons, i have a file containing main and it imports "FreeImageBinding" which lies in "FreeImageBinding.hsc" and cabal says it can't find "FreeImageBinding.hs"
15:51:50 <conal> litb: generalized concat
15:51:54 <dmwit> Yay, solved 13-queens!
15:52:00 <conal> dmwit: !!
15:52:19 <Saizan> jethr0: have you listed FreeImageBinding as other-modules:
15:52:29 <Saizan> s/as/in/
15:52:30 <jethr0> ah, no
15:52:30 <litb> dmwit: huhu
15:52:53 <litb> > "hello " `mconcat` "guyz"
15:52:53 <lambdabot>  Couldn't match expected type `[Char] -> t'
15:52:57 <jethr0> but neither does pcre-light.
15:53:01 <litb> oh darn
15:53:02 <jethr0> Saizan: how would that look?
15:53:12 <litb> > "hello " `mappend` "guyz"
15:53:13 <lambdabot>  "hello guyz"
15:53:56 <Saizan> jethr0: maybe pcre-light has only exposed-modules? however just other-modules: FreeImageBinding
15:54:07 <jethr0> k, i'll try that
15:54:33 <jethr0> Saizan: YEAH, thank you so much
15:54:44 <RayNbow> damn, unbiased randomness is tricky... :)
15:54:51 <RayNbow> before you know it, you created something that's biased
16:00:16 <kaol> I seem to have promised to organise some sort of a local Haskell users group. Anyone done that sort of a thing before?
16:02:44 <mrd> buy a case of beer, send out an email
16:03:12 <LoganCapaldo> well given that haskell groups exist, and assuming that user groups don't just occur spontaneously (which I could be wrong about) I assume _someone_ has done that sort of thing before
16:03:38 <LoganCapaldo> mmm beer and email
16:03:46 <LoganCapaldo> good combo
16:03:47 <kaol> it started to sound more like a seminar. those don't mix well with alcohol.
16:04:05 <mrd> spontaneous HUGs, or SHUGs, are described in quantum functo-dynamics
16:04:30 <Saizan> well maybe the beer is for later?
16:04:43 <blbrown> I posted a thread on the mailing list about sqlite/db access. I just want to read/write a simple table.  Is hsql what I need.  Or haskelldb.  And does haskelldb depend on hsql
16:04:46 <LoganCapaldo> We need more seminar mixers
16:04:59 <kaol> Saizan: yeah, once everyone has found their own inner lambda
16:05:16 <LoganCapaldo> I want some throwing lambdas
16:05:40 <nolrai> are those like throwing stars?
16:05:56 <LoganCapaldo> i'd use them to launch a campaign of terror against the avatars of mutable state
16:05:56 <dmwit> Only if they're pointy.
16:06:01 <LoganCapaldo> precisely
16:06:32 <LoganCapaldo> It wouldn't work though
16:06:51 <LoganCapaldo> avatars of mutable state are already in a constant state of terror
16:06:55 <jethr0> throwing lambdas sound like fun
16:07:11 <jethr0> but as dmwit mentioned they have limited pointiness
16:07:22 <LoganCapaldo> hmm maybe they'd be more like boomerangs than starts
16:07:25 <blbrown> hmm, hdbc looks nice
16:07:26 <Saizan> blbrown: haskelldb is an higher-level interface based on relational algebra, it uses either HDBC or hsql as backends, but you can use those directly, and it might be simpler if you don't need anything fancy
16:07:26 <jethr0> alternatively they could just be razor sharp instead of pointy
16:07:35 <LoganCapaldo> *stars
16:07:55 <LoganCapaldo> throwing lambdas w/ continuations (they come back)
16:08:02 <jethr0> i once had a three pronged boomerage that looked pretty much like a lambda
16:08:05 <blbrown> Saizan, on haskell-cafe, hsql doesnt build with ghc6.8+.  But then again, I didnt try that hard
16:08:11 <jethr0> built it myself, not hard to do at all
16:08:46 <mrd> but functional throwing lambdas can't effect anything
16:09:03 <Saizan> blbrown: well that could just be a problem of updating the cabal file, do you still have the error?
16:09:08 <LoganCapaldo> they can effect things, they just can't affect things
16:09:19 <mrd> neither!
16:09:39 <LoganCapaldo> lambda should not cons it's result?
16:09:46 <LoganCapaldo> s/it's/its/
16:10:11 <nelhage> Nice. I'm watching a demo of a collaborative crossword solving tool written in Haskell.
16:10:25 <blbrown> Saizan, the build log is different, http://hackage.haskell.org/packages/archive/hsql/1.7/logs/failure/ghc-6.8  But I got a different error yesterday
16:10:26 <lambdabot> http://tinyurl.com/ytn5rm
16:11:06 <nelhage> It throws up an AJAX grid and lets you draw a crossword on it and then pushes your updates to other users in real time
16:11:38 <Cin> cool
16:11:42 <Cin> link?
16:11:46 <mrd> you mean a Javascript grid which sends updates using "AJAX"-style communication
16:11:50 <nelhage> They haven't released anything yet
16:11:53 <LoganCapaldo> It needs a Comet grid :p
16:12:00 <LoganCapaldo> AJAX is so 2007
16:12:02 <nelhage> mrd: Yes I do, but what I said was shorter and relatively unambigious.
16:12:08 <nelhage> I believe it is comet, actually.
16:12:17 <Saizan> blbrown: that error can be solved by adding old-time to build-depends
16:12:29 <abz> if Ajax is so 2007, when was Haskell, 98?
16:12:35 * LoganCapaldo is so glad he's not a web programmer any more
16:12:37 <mrd> Comet, it makes your mouth turn green
16:12:46 <LoganCapaldo> it smells like gasoline
16:12:58 <Cin> abz: well it's not like ajax was made in 07
16:12:58 <nelhage> It also can run searches against a dictionary in real time for you
16:13:07 <Saizan> abz: we're all using Haskell' from the future!
16:13:15 <conal> nelhage: neat.  url?
16:13:16 * mrd agrees with LoganCapaldo 
16:13:34 <nelhage> conal: They haven't put anything online yet :( I'll yell at them.
16:13:37 <abz> Saizan: true
16:13:45 <BMeph> +
16:13:45 <LoganCapaldo> apparently I can't change my nick to LoganCapaldo'
16:14:03 <LoganCapaldo> IRC needs to support a wider variety of novelty nicks
16:14:16 <conal> nelhage: please do.  sounds like something i'd like.  i've been wanting to do some web-based FRP.
16:14:44 <nelhage> I'd love to see a (library|framework) for comet/ajax FRP
16:14:58 <mrd> speaking of old-time, was there a way to convert seconds to NominalDiffTime? I couldn't find anything.
16:15:01 <conal> nelhage: cool :)
16:15:15 <Cin> LoganCapaldo: i could include support for that in my ircd :P (but some irc clients could probably just drop messages with invalid nicks) ;D
16:15:20 <ddarius> @google Flapjax
16:15:21 <lambdabot> http://www.flapjax-lang.org/
16:15:21 <lambdabot> Title: Flapjax
16:15:35 <LoganCapaldo> @index NominalDiffTime
16:15:35 <lambdabot> bzzt
16:15:46 <conal> nelhage: my new FRP stuff is data-driven, so something comet-ish could be very nice.  i hadn't thought of an application.  something collaborative/competitive sounds like a good fit.
16:15:49 <LoganCapaldo> bzzt at me one more time, I dare you.
16:15:49 <mrd> in ghc 6.8 there is, but not in older ghc afaict
16:15:52 <hpaste>  blbrown pasted "hsql" at http://hpaste.org/5425
16:16:19 <blbrown> Saizan: no dice, I think I am going to hdbc
16:17:01 <LoganCapaldo> missing -fglasgow-exts?
16:17:07 <Saizan> seems so
16:17:10 <LoganCapaldo> or the cabal file is missing it
16:17:43 <Saizan> probably in 6.6 some extension was enabling -fglasgow-exts so that forall skipped through
16:17:46 <Saizan> *slipped
16:18:01 <shachaf> @where LoganCapaldo
16:18:01 <lambdabot> bzzt
16:18:27 <LoganCapaldo> @where+ LoganCapaldo right here
16:18:27 <lambdabot> Nice!
16:18:41 <LoganCapaldo> @where LoganCapaldo
16:18:41 <lambdabot> right here
16:18:56 <dmwit> ?where+ LoganCapaldo right there
16:18:57 <lambdabot> Good to know.
16:18:58 <shachaf> @where LoganCapaldo
16:18:59 <lambdabot> right there
16:19:09 <shachaf> @where LoganCapaldo
16:19:09 <lambdabot> #ruby-lang
16:19:14 <shachaf> Traitor!
16:19:47 <LoganCapaldo> but to which side?
16:20:08 <shachaf> LoganCapaldo: The good side, of course.
16:20:22 <RayNbow> @pl \xs -> frequency (map (second return) xs)
16:20:22 <lambdabot> frequency . map (second return)
16:20:22 <wagle_> @where shachaf
16:20:23 <lambdabot> gone and lost forever
16:20:34 <shachaf> @where shachaf
16:21:11 <LoganCapaldo> @where+ shapr @get-shapr
16:21:11 <lambdabot> Done.
16:21:20 <LoganCapaldo> @where shapr
16:21:20 <lambdabot>  @get-shapr
16:21:30 <shachaf> @where+ shapr ?get-shapr
16:21:30 <lambdabot> I will remember.
16:21:37 <shachaf> @where shapr
16:21:37 <lambdabot> ?get-shapr
16:21:55 <LoganCapaldo> @@ @where shapr
16:21:56 <lambdabot>  ?get-shapr
16:23:27 <dmwit> ?were wolf
16:23:27 * lambdabot howls
16:23:39 <LoganCapaldo> ?were castle
16:23:40 <lambdabot> I know nothing about castle.
16:23:45 <litb> @src frequency
16:23:45 <lambdabot> Source not found. That's something I cannot allow to happen.
16:23:50 <mrd> ?were car
16:23:50 <lambdabot> I know nothing about car.
16:23:55 <dmwit> ?were shapr
16:23:56 <lambdabot> ?get-shapr
16:24:03 <LoganCapaldo> ?ware shapr
16:24:03 <lambdabot> Maybe you meant: arr more part where yarr
16:24:08 <LoganCapaldo> mm
16:24:50 <blbrown> Saizan, how do I add glasgow-exts to the cabal file
16:25:04 <dons> blbrown: its better to use specific extensions
16:25:15 <dons>     extensions:      CPP, ForeignFunctionInterface
16:25:17 <dons> for example
16:25:30 <dons>  or BangPatterns, PolymorphicComponents etc
16:25:33 <LoganCapaldo> dons: ok, then what's the one for forall a. ..?
16:25:42 <shachaf> Or to have {-# LANGUAGE ... #-} in the source files.
16:25:46 <dons> one of the quanitifcation-related flags
16:25:49 <Saizan> blbrown: use this cabal file: http://zzodici.yi.org/s/hsql.cabal
16:26:05 <blbrown> cool, gracias
16:26:08 <Saizan> LoganCapaldo: in this case it's Rank2Types
16:26:23 <LoganCapaldo> rank3types
16:26:26 <LoganCapaldo> are cooler
16:26:43 <dons> a great thing about H' was getting all the flags seperated out
16:26:54 <dons> so you have to conciously ask for the extension you want
16:27:05 * Saizan pwnz LoganCapaldo with RankNTypes 
16:27:21 <LoganCapaldo> rank1 is the lonliest type rank that you ever knew, 2 is just as bad 1 it's the lonliest type rank since the type rank 1
16:27:24 <Saizan> it's a bit a maintain hell
16:27:48 <shachaf> forall n. (Num n) => RankTypes n
16:28:13 <LoganCapaldo> 2 type ranks should be enough for anyone
16:28:24 <olsner> "should be enough for anyone"
16:29:06 <LoganCapaldo> do rank N types smell like N?
16:29:21 * LoganCapaldo is crazy
16:31:51 <jethr0> LoganCapaldo: is that like 640k of memory should be enough for anyone?
16:32:01 <LoganCapaldo> that was the joke, yes
16:35:22 <conal> cognominal: author typo on http://www.citeulike.org/user/cognominal/article/1758813
16:35:22 <lambdabot> Title: CiteULike: Arrows and computation
16:36:23 <conal> @tell cognominal author typo on http://www.citeulike.org/user/cognominal/article/1758813
16:36:23 <lambdabot> Consider it noted.
16:37:33 <dmwit> ?seen cognominal
16:37:33 <lambdabot> cognominal is in #perl6 and #haskell. I don't know when cognominal last spoke.
16:38:49 <litb> is it Richard Hughes that introduced Arrows?
16:39:01 <ddarius> John Hughes you mean
16:39:18 <LoganCapaldo> W need Bows,
16:39:28 <LoganCapaldo> to shoot our Arrows with
16:39:47 <LoganCapaldo> we can mount Lenses on them so we can hit a Banana at a thousand paces
16:39:52 <dmwit> What, bananas aren't enough for you?
16:40:03 <dmwit> Damn, your joke was better.
16:45:41 <olsner> rats, has anyone built a stateful packrat parser? is it even possible?
16:46:21 <LoganCapaldo> seems like state would hurt the memoization
16:46:44 <olsner> yeah, seems like it would
16:47:01 <olsner> perhaps I should've thought about that before starting hacking on frisby
16:47:03 <LoganCapaldo> I'd lean towards, not possible, or very  very very hard
16:47:22 <kpreid> you just have to make the memoization keyed by the state as well, no?
16:47:32 <LoganCapaldo> but I don't know nearly as much about parsers as I'd like to wish I did :)
16:47:32 <olsner> urgh
16:47:34 <hpaste>  gwern pasted "what license is this?" at http://hpaste.org/5426
16:47:43 <Gwern-away> I've been looking at HList
16:48:03 <Gwern-away> and I don't know what license that is. it's not BSD I don't think - that looks like an advertising clause
16:48:08 <kpreid> gwern: MIT X
16:48:21 <Gwern-away> hm. O
16:48:31 <Gwern-away> is there a cabal for that?
16:48:38 <Gwern-away> (license: field I mean)
16:48:47 <kpreid> it's a common license...
16:49:08 * kpreid uses it for everything
16:49:53 <Gwern-away> kpreid: maybe you do... I think this is the first time I've run across it
16:50:06 <olsner> hmm, how about, if you let the parser store and compose functions manipulating the state rather than threading the state itself
16:50:21 <LoganCapaldo> kpreid: I think it would be more complicated than that, esp. if teh state changes due to the input, ie, what if you end up "back tracking" multiple state changes back?
16:50:23 <kpreid> olsner: no good if you want to *read* the state
16:50:31 <Gwern-away> btw, does Hackage allow non-maintainer uploads?
16:50:35 <kpreid> during the parse, I mean
16:50:58 <kpreid> what you could do with that is equivelent to walking the parse tree afterward
16:51:24 <olsner> ah yes, no way for the parser to reach out of its monad and grab at the computation being done to the state value outside of it
16:52:44 <olsner> my first idea was to use the parser non-statefully and have everything return lists of [result or state-processing command]
16:52:59 <LoganCapaldo> heh
16:53:14 <LoganCapaldo> State + AST GADT
16:53:28 <LoganCapaldo> which you'd then run to get the real AST?
16:53:39 <olsner> yeah, like so
16:54:41 <olsner> which is really ugly compared to a normal stateful parser monad
16:54:44 <Trinithis> @src quickCheck
16:54:44 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
16:55:02 <Trinithis> @src Test.QuickCheck.quickCheck
16:55:03 <lambdabot> Source not found. stty: unknown mode: doofus
16:55:24 <LoganCapaldo> Couldn't yu just use a different sort of parser? (Parse or whatever)?
16:55:38 <LoganCapaldo> s/Parse/Parsec/
16:56:36 <olsner> but I already have that, now I want to try this cool newfangled PEG thingy ;-)
16:56:45 <dolio> Gwern-away: Last I checked MIT was "OtherLicense" in Cabal.
16:57:32 <olsner> of course, I should make a Parsec version as well and compare that (the version I have is done with PolyParse)
16:57:49 <LoganCapaldo> so do the PEG thingy w/o state <g>
16:58:20 <glen_quagmire> @hoogle IO String -> Int
16:58:21 <lambdabot> No matches, try a more general search
16:59:03 <dolio> @type read . unsafePerformIO
16:59:04 <kpreid> glen_quagmire: there are no nonsilly functions of that type
16:59:05 <lambdabot> Not in scope: `unsafePerformIO'
17:00:25 <dons> did anyone else notice that john macfarlane, haskell programmer of pandoc/markup fame, is an assoc. professor of philosophy?
17:00:46 <newsham> /tmp/ghc47407_0/ghc47407_0.s:36:0:  Error: unassigned file number 1
17:01:00 <glen_quagmire> a <- getLine;   how can I make a an Int ?
17:01:02 <dons> nice
17:01:11 <glen_quagmire> a <- read getLine
17:01:15 <kpreid> a <- liftM read getLine
17:01:16 <dons> main = do a <- readIO =<< getLine
17:01:28 <kpreid> @type readIO
17:01:28 <lambdabot> forall a. (Read a) => String -> IO a
17:01:33 <dons> ?src readIO
17:01:33 <kpreid> huh, okay.
17:01:33 <lambdabot> Source not found. Sorry.
17:01:37 <kpreid> that's better.
17:01:53 <dons> a <- read <$> getLine
17:03:21 <glen_quagmire> :i <$>
17:03:33 <glen_quagmire> :i (<$>)
17:03:33 <shachaf> glen_quagmire: lambdabot isn't ghci.
17:03:40 <newsham> hmm this wanst broken a few days ago.
17:03:50 <shachaf> glen_quagmire: It doesn't have :i (and it only fakes :t).
17:04:29 <Saizan> fakes?
17:04:42 <shachaf> Saizan: Well, it doesn't work in /msg.
17:04:56 <shachaf> Saizan: And it's separate from @run.
17:06:50 <dmwit> Everybody's next attempt is ?info, but:
17:07:09 <dmwit> ?info do { x <- getLine; return (read x) }
17:07:09 <lambdabot> getLine >>= \ x -> return (read x)
17:07:18 <glen_quagmire> how would I do {  int i; cin>>i; i++; cout<<i; }  in haskell do block?
17:07:36 <shachaf> glen_quagmire: Without initializing i?
17:07:39 <Saizan> in System F \pi is forall and \sigma is exists, right?
17:07:52 <dmwit> do { i <- readLine; print (i - 1) }
17:08:00 <newsham> i+1
17:08:02 <glen_quagmire> shachaf: i'm not sure. it seems in do block, a <- getLine; a <- getLine; is ok
17:08:13 <dmwit> err... s/- 1/+ 1/
17:08:19 <glen_quagmire> like, `a` is changed
17:08:23 <shachaf> Oops, sorry.
17:08:25 * shachaf misread.
17:08:43 <dmwit> :t readLine
17:08:44 <lambdabot> Not in scope: `readLine'
17:08:49 <shachaf> glen_quagmire: Does that read the string automatically?
17:08:55 <shachaf> @ty readLn
17:08:55 <lambdabot> forall a. (Read a) => IO a
17:09:05 <dmwit> Oh, there we go.
17:09:11 <Saizan> glen_quagmire: 'a' is not changed, rather the second 'a' shadows the first one
17:09:12 <dmwit> glen_quagmire: Did you see my response?
17:09:34 <glen_quagmire> dmwit: print (i + 1) ?
17:09:41 <dmwit> glen_quagmire: yes
17:09:51 <litb> it is not too hard:
17:09:54 <dmwit> glen_quagmire: Also, s/readLine/readLn/
17:09:56 <glen_quagmire> a <- getLine;  a <- (++ a) =<< getLine
17:10:16 <dolio> @type print . pred =<< readLn
17:10:16 <lambdabot> IO ()
17:10:24 <litb> do { i<-readLine; print (i+1) }
17:10:31 <litb> err readLn i think
17:10:31 <dmwit> glen_quagmire: type error
17:10:35 <dolio> @type print . succ =<< readLn
17:10:35 <lambdabot> IO ()
17:11:16 <dmwit> :t readLn >>= succ >>> print
17:11:17 <lambdabot>     precedence parsing error
17:11:17 <lambdabot>         cannot mix `(>>=)' [infixl 1] and `(>>>)' [infixr 1] in the same infix expression
17:11:32 <dmwit> :t readLn >>= (succ >>> print)
17:11:33 <lambdabot> IO ()
17:11:38 <dolio> Huh, that's a shame.
17:11:40 <litb> glen_quagmire: it automatically converts the string to a Num
17:11:43 <dmwit> yeah
17:12:08 <litb> >>> what is that?
17:12:29 <dmwit> In the (->) Arrow, (>>>) is flip (.)
17:12:30 <dolio> Arrow composition.
17:12:33 * litb thinks he read that in Arrow 
17:14:11 <glen_quagmire> ok. I want to do   a <- getLine;  a <- liftM (++ a) getLine
17:14:40 <litb> > ((*2) >>> (+3)) 10
17:14:40 <litb> hmm
17:14:40 <litb> it's stuck
17:14:41 <glen_quagmire> oh it does compile!
17:14:41 <lambdabot>  23
17:15:06 <dmwit> liftM2 (++) getLine getLine -- preferred
17:15:17 <dmwit> or:
17:15:30 <shachaf> @ty join (liftA2 (++)) getLine
17:15:31 <lambdabot> IO [Char]
17:15:32 <litb> uh, that took long
17:15:36 <dmwit> do { a <- getLine; b <- getLine; let c = a ++ b }
17:15:43 <litb> that arrow had a long way until it hit
17:16:12 <dmwit> shachaf: Yeah. =)
17:16:35 <dmwit> litb: It's probably just laggy a bit.
17:17:55 <litb> @src join
17:17:55 <lambdabot> join x =  x >>= id
17:18:19 <Saizan> glen_quagmire: are you aware that in haskell ++ is the list-append operator and not the increment operator like in C?
17:18:46 <shachaf> litb; join f x = f x x
17:18:53 <dmwit> I've just upgraded cabal.  Does this get me cabal-install for free?
17:18:56 <litb> damn that is clever
17:19:10 <litb> it will double the (++)
17:19:21 <dmwit> litb: No, it doubles the getLine.
17:19:29 <Saizan> dmwit: no, it's separate
17:19:49 <glen_quagmire> Saizan: yes. i was trying to do a = getline;  a += getline;
17:20:07 <newsham> hmm.. simply adding an item to "build-depends" in the cab file is making my ghc fail in the assembler.
17:20:07 <glen_quagmire> but as you said, that second a is shadowing. not the same a
17:20:13 <ogex> is there a function typed (Monad m) => m t1 -> m t2 -> m (t1, t2)
17:20:31 <dmwit> :t liftM2 (,)
17:20:32 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
17:21:05 <litb> (liftA2 (++)) >>= id  doesn't make sense to me :/
17:21:09 <shachaf> glen_quagmire: That's not very functional of you.
17:21:16 <ogex> dmwit, thanx a lot! overlooked that one
17:21:19 <shachaf> litb: Think of the types, in the (r ->) monad.
17:21:26 <litb> oh wait that is the -> monad yeah
17:21:56 <glen_quagmire> @index (->)
17:21:56 <lambdabot> bzzt
17:22:10 <litb> ok it f >>= x was \z -> x (f z) z i think
17:22:13 <dmwit> Control.Monad.Reader
17:22:38 <shachaf> litb: Think of the types, it's simpler.
17:22:49 <shachaf> @ty join
17:22:51 <litb> too bad i haven't done much with liftA yet. only liftM and ap here
17:22:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:22:52 <dmwit> litb: Good so far!
17:23:00 <litb> is liftA anything different?
17:23:03 <shachaf> join :: (r -> r -> a) -> r -> a
17:23:11 <shachaf> litb: It's more general, but it shoul dbehave the same way.
17:23:21 <dmwit> litb: liftA/liftM/fmap are pretty much the same, but with different contexts.
17:23:32 <LoganCapaldo> hehe
17:23:40 <LoganCapaldo> "different contexts"
17:23:49 <LoganCapaldo> it's true on multiple levels!
17:24:02 <dmwit> Isn't that what it's called? context?
17:24:08 <dmwit> Oh, no, constraint.
17:24:10 <dmwit> rats
17:24:32 <LoganCapaldo> oh
17:24:39 <LoganCapaldo> maybe it's not true on multiple levels :(
17:24:47 <dmwit> heh
17:24:55 <LoganCapaldo> (i thought they were contextes too)
17:25:38 <dmwit> Well, hell, if everybody thinks contexts is a good name, that's good enough for me! =D
17:26:27 <LoganCapaldo> dmwit + LoganCapaldo = everybody!
17:27:01 <shachaf> I like "constraint".
17:27:09 * shachaf is just a bot, though.
17:27:57 <LoganCapaldo> I actually do like constraint
17:28:03 <LoganCapaldo> but I like word play more
17:28:12 * BMeph gets out the handcuffs and beckons to shachaf: Look, constraints! ;)
17:28:26 <dmwit> kinky
17:28:28 <litb> ok, it will be "id (liftA (++) getLine) getLine"
17:28:34 <litb> hmm
17:29:20 <dmwit> right
17:29:27 <dmwit> Now apply id.
17:29:27 <litb> i see
17:29:33 <dmwit> =)
17:29:44 <dmwit> It's a roundabout derivation, but pretty clever, no?
17:29:49 <Twey> Um, why id?
17:29:50 <litb> sure
17:30:00 <litb> Twey: because it's x
17:30:08 <litb> it's what poor join does
17:30:08 <dmwit> Twey: This is carrying on from earlier.
17:30:26 <Twey> Hm, OK.
17:30:27 <dmwit> Twey: He's trying to understand how join f x = f x x.
17:30:34 <Twey> Ah
17:30:46 <litb> > join "hello " "test"
17:30:47 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
17:30:52 <litb> well, was worth a try :)
17:30:59 <dmwit> > join (++) "hello "
17:31:00 <lambdabot>  "hello hello "
17:31:09 <dmwit> Gotta have a function! =)
17:31:21 <litb> ah yes i remember
17:31:28 <dmwit> Well... a monad.
17:31:32 <shachaf> > join ["hello ", "hello "] -- Not always. :-)
17:31:33 <lambdabot>  "hello hello "
17:31:38 <dmwit> > join ["hello ", "hello"]
17:31:39 <lambdabot>  "hello hello"
17:31:50 <dmwit> I'm too slow today. =P
17:32:12 <Twey> > concat ["hello", " ", "hello"]
17:32:13 <lambdabot>  "hello hello"
17:32:23 <Twey> > join ["hello", " ", "hello"]
17:32:24 <lambdabot>  "hello hello"
17:32:28 * Twey is confused.
17:32:35 <Twey> :t join
17:32:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:32:39 <Twey> :t concat
17:32:40 <litb> well i see. it's [] a >>= id pretty clear that it just concats its elements
17:32:40 <lambdabot> forall a. [[a]] -> [a]
17:32:43 <Twey> Ah
17:33:07 <BMeph> You need a doubly-"applied" monad. A binary function/op for the function monad, a list of lists for the list monad, etc.
17:34:15 <dmwit> > join . return . print $ 3
17:34:20 <lambdabot>  <IO ()>
17:34:36 <dmwit> Of course, join . return isn't all that interesting.
17:35:02 <dmwit> But I was having a hard time coming up with a short, interesting example that would double up IO. =P
17:35:37 * Twey still doesn't quite understand monads.
17:35:40 <litb> =)
17:35:46 <conal> BMeph: btw, though monads don't generally compose, applicatives do.
17:35:59 <conal> @wiki TypeCompose
17:36:00 <lambdabot> http://www.haskell.org/haskellwiki/TypeCompose
17:36:27 <conal> or maybe those remarks are for litb.  i just retuned in.
17:37:39 <BMeph> conal: Yes, I realize that using the word "apply" implies things I don't mean about the monad, but it's what I meant linguistically. ;)
17:37:54 <litb> :)
17:38:07 <litb> germans have a hard time being in an english experts chan
17:38:31 <newsham> that must be why they make all that great angstful music
17:39:07 <BMeph> litb: Why so? Everyone knows that English is the bastard child of Saxony/Frisian German and Norman French. ;)
17:39:14 <MisterN> you mean the angst of the listener?
17:39:24 <litb> :)
17:39:40 <Twey> Heheh
17:39:59 <conal> BMeph: clear enough for me, though now i wonder if i misunderstood.
17:40:34 <litb> > join $ filterM (const [True, False]) [1, 2, 3]
17:40:34 <lambdabot>  [1,2,3,1,2,1,3,1,2,3,2,3]
17:40:41 <newsham> i'm not having a good ghc day
17:41:09 <BMeph> I still remember the ditty from my German teacher - "'Good butter and good cheese', is good English and good Fris." It's not spelled the same, but it makes sense to both when spoken. :)
17:41:23 <litb> is there a replace function for lists?
17:42:11 <conal> litb: there's map.  what type & semantics would you like?
17:42:36 <MisterN> BMeph: most germans are not frisians though.
17:43:29 <BMeph> MisterN: Heh-heh, I wonderwould most Frisians say they weren't Germans, though... ;)
17:43:35 <litb> oh rite, i almost forgot about map doing all this silly monad stuff
17:43:43 <BMeph> s/wonderwould/wonder would/
17:43:44 <ogex> Is there a shorthand for \x->[x] ?
17:43:49 <conal> return
17:43:54 <newsham> map doing all this silly monad stuff?
17:43:57 <conal> ogex: return
17:44:00 <dmwit> (:[])
17:44:03 <wagle_> :t []
17:44:03 <BMeph> conal: ROFL! :)
17:44:03 <lambdabot> forall a. [a]
17:44:03 <ogex> but return needs type signature
17:44:07 <litb> isn't [] short enough?
17:44:24 <wagle_> > [] 1
17:44:24 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
17:44:25 <newsham> ?keal+ oh rite, i almost forgot about map doing all this silly monad stuff
17:44:26 <lambdabot> last day i was in my lab i had a diagram which might have removed pi
17:44:28 <dmwit> litb: not a function
17:44:37 <BMeph> Long Live the Robot Monkey! :)
17:44:37 <litb> meh :/
17:44:46 <litb> > ([]) 1
17:44:46 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
17:44:51 <litb> too bad
17:44:57 <dmwit> newsham: Stick a "while" in between "map" and "doing" and it makes sense.
17:45:04 <litb> > (:[]) 1
17:45:04 <lambdabot>  [1]
17:45:06 <MisterN> BMeph: but seriously, while german and english are related, there are enough differences to make the subtle meanings of apply and compose somewhat hard to grasp
17:45:13 <wagle_> litb: yeah
17:45:24 <newsham> oh, EPARSE.  I get it.
17:45:25 <litb> oh darn overseen dmwit :/
17:45:42 <litb> :[] looks like a smily :)
17:45:43 <dmwit> newsham: Yeah, the bug is on your end. =P
17:45:57 <MisterN> cu
17:45:59 <litb> like "my mouth is big, put it into teh list"
17:46:09 <newsham> nah, there were multiple parse trees and I picked another equally likely one
17:46:57 <BMeph> MisterN: Depends on which forms of German (and English) you mean, as well. :)
17:47:26 <wagle_> @pl \x -> [x]
17:47:26 <lambdabot> return
17:47:51 <wagle_> @pl \x -> [x,x]
17:47:51 <lambdabot> ap (:) return
17:48:09 <litb> > (return 't') ++ "hello"
17:48:10 <lambdabot>  "thello"
17:48:32 <newsham> 't':"hello"
17:48:41 <wagle_> > return 't'
17:48:41 <lambdabot>   add an instance declaration for (Show (m Char))
17:49:32 <newsham> > return 't' :: [Char]
17:49:32 <lambdabot>  "t"
17:49:36 <BMeph> MisterN: Just curious, but which subtle meaning of compose were you thinking of?
17:50:13 <litb> aply and compose is no way sublte different imho
17:50:16 <litb> *apply
17:50:22 <wagle_> @meanings (.)
17:50:23 <lambdabot> Unknown command, try @list
17:50:28 <wagle_> aww
17:50:29 <conal> @tell nominolo to my surprise, my new toy arrow-based FRP library looks like it will have a synchronous Applicative instance (like Reactive and unlike Event).  blog post in progress.
17:50:30 <lambdabot> Consider it noted.
17:51:29 <litb> :t ap
17:51:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:53:43 <ogex> > liftM return [1..3]
17:53:43 <lambdabot>   add an instance declaration for (Show (m a1))
17:54:12 <ogex> > liftM (:[]) [1..3]
17:54:13 <lambdabot>  [[1],[2],[3]]
17:54:22 <newsham> > liftM return [1..3] :: [[Int]]
17:54:23 <lambdabot>  [[1],[2],[3]]
17:54:28 <newsham> > liftM return [1..3] :: Maybe [Int]
17:54:29 <lambdabot>  Couldn't match expected type `Maybe Int'
17:54:43 <newsham> > liftM return [1..3] :: [Maybe Int]
17:54:43 <lambdabot>  [Just 1,Just 2,Just 3]
17:55:42 <litb> hm one thing:
17:55:53 <litb> ap (:) , how is this going?
17:57:03 <litb> a = a, b = [a] -> [a] then it follows :t ap (:) = "m a -> m ([a] -> [a])"
17:57:40 <litb> but ghci tells me "(a -> [a]) -> a -> [a]"
17:57:49 <TomMD> > "hi" :: ByteString
17:57:49 <lambdabot>   Not in scope: type constructor or class `ByteString'
17:58:02 <litb> maybe it has something todo that it alreay figured out what type m is
17:58:15 <BMeph> @tell MisterN Just curious, but of which subtle meaning of compose were you thinking?
17:58:15 <lambdabot> Consider it noted.
17:59:34 <litb> @type ap (:)
17:59:35 <lambdabot> forall a. (a -> [a]) -> a -> [a]
17:59:45 <BMeph> ?type ap
17:59:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:59:59 <BMeph> ?type (:)
17:59:59 <lambdabot> forall a. a -> [a] -> [a]
18:02:53 <BMeph> litb: The important question here is: What is the monad? :)
18:03:20 <litb> hm. looks like a is (a -> [a])
18:03:28 <newsham> "I can name that monad in 2 lines"
18:03:39 <Botje> i'd bind that.
18:04:17 <litb> :t ap (:) return
18:04:17 <lambdabot> forall a. a -> [a]
18:04:35 <litb> looks like [] monad
18:05:15 <LoganCapaldo> I'd watch that game show
18:05:20 <LoganCapaldo> that would be sweet
18:09:46 <litb> ah i know it now. the monad is (->)e , with a=[a] b=[a] :)
18:10:11 <litb> and e being a :)
18:11:37 <idnar> :t ap
18:11:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:12:42 <idnar> @unpl ap (:)
18:12:42 <lambdabot> (\ e -> (:) >>= \ b -> e >>= \ a -> return (b a))
18:12:58 <idnar> bah
18:13:21 <litb> =) isn't quite that clear
18:14:47 <litb> having the liftM2 id is way easier to understand it then
18:17:37 <litb> @src (->) (>>=)
18:17:37 <lambdabot> f >>= k = \ r -> k (f r) r
18:19:15 <Gwern-away> hm. what's the convention for naming data structure modules? I'm working on HList and I'm wondering whether Datqa.HList.* is good
18:20:06 <Gwern-away> *Data
18:24:22 <litb> @src liftM2
18:24:22 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:24:36 <BMeph> Gwern-away: Well, it sounds more sensible than Data.Function does... ;p
18:25:28 <litb> @undo do { f<-(:); g<-(return); return (id f g); }
18:25:29 <lambdabot> (:) >>= \ f -> (return) >>= \ g -> return (id f g)
18:25:50 <Gwern-away> true
18:26:26 <litb> @unpl (:) >>= \ f -> (return) >>= \ g -> return (id f g)
18:26:26 <lambdabot> (((:)) >>= \ f -> return >>= \ g -> return (f g))
18:32:21 <dons> glguy: did you look at highlighting-kate ?
18:32:21 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:32:30 <dons> it looks like a pretty good extension of Hscolour to arbitrary languages
18:32:51 <dons> there's support for 20 or so html markup generators in this lib. very nice
18:36:22 <conal> dons: i wonder if it'd be a good basis for hyperlinking to haddock docs as well.  geshi does that, but it's in php and has just the prelude wired in.
18:38:06 <conal> of course there's the question of how to resolve the identifier to its package.  haddock certainly has that info.
18:42:43 * Saizan needs someone to check if he has finally grokked the Curry-Howard correspondence
18:46:17 <Saizan> FOPL ~ STLC, so forall x. P(x) -> P(x)  ~~ \x:P -> x ?
18:46:57 <monochrom> @seen Cale
18:46:57 <lambdabot> Cale is in #haskell, #haskell-overflow, #not-math, #oasis and #ghc. I last heard Cale speak 20h 53m 5s ago.
18:47:04 <Cale> hi
18:47:14 <LoganCapaldo> He lives
18:48:03 <monochrom> Cale: Thanks for bringing up math.reddit. I find that it is worthwhile and the only worthwhile branch of reddit. I am now now inclined to create a reddit account. :)
18:48:12 <Cale> :)
18:48:14 <ddarius> Saizan: No,
18:48:29 <ddarius> monochrom: How long will that last?
18:48:53 <monochrom> In the past few days it seems getting better, actually.
18:50:30 <monochrom> Two characteristics. 1. Almost no comments. (Remember: no comments is no trolls.)  2. High proportion of items interesting to me.
18:50:32 <Saizan> ddarius: so, what correponds to forall x. P(x) -> P(x), in the simply typed lambda calculus? i guess i'm puzzled on which are the predicates and which the terms
18:50:41 <Cale> Yeah, it started out kinda crappy, but there are some math people on there now. :)
18:50:51 <ddarius> Saizan: There is nothing that corresponds to that in the simply typed lambda calculus.
18:51:10 <ddarius> Saizan: The simply typed lambda calculus corresponds to intuitionistic propositional logic.
18:52:32 <Philippa> Saizan: in System F w/type constructors, you'd have the type forall x. P x -> P x. The Haskell equivalent being just P x -> P x
18:52:56 <Philippa> (but you can write the forall in GHC if you want)
18:53:13 <Saizan> so System F2 (or just F) is first order propositional logic?
18:54:10 <ddarius> Propositional logic means no predicates/quantifiers (usually)
18:54:21 <dons> boo. i want my math in my programming reddit :(
18:54:27 <Saizan> yes, i meant predicative now
18:54:37 <Philippa> http://en.wikipedia.org/wiki/System_F <- mentions the curry-howard correspondance
18:54:44 <monochrom> dons: Come join us mathematicians :)
18:54:55 <Saizan> Philippa: yeah, but it says second order
18:55:07 * monochrom passes around his math degree certificate
18:55:12 <LoganCapaldo> Hey you got math in my programming! You got programming in my math!
18:55:24 <Saizan> Philippa: so i got confused trying to see the quantification on predicates
18:55:57 <Saizan> can someone confirm that wikipedia is wrong there?:)
18:56:33 <LoganCapaldo> Some people have "stretch" programming langauges. math.reddit.com is my stretch website :p
18:56:46 <LoganCapaldo> (that and LtU)
18:58:26 <Saizan> i guess i could read girard's paper..
19:00:47 <ddarius> Saizan: The variables of the STLC correspond to (labels of) proofs in the intuitionistic propositional logic, not to propositional variables
19:04:19 <Saizan> ddarius: so propositional variables are the ones in its types? and which logic correponds to System F then?
19:07:01 <ddarius> Saizan: As the wikipedia entry says, it corresponds to second order logic.  -Type- variables do correspond to propositional variables.
19:09:57 <ddarius> Saizan: If you haven't, what you may want to look at is proof theory.
19:16:51 <Saizan> ddarius: i guess i need to learn more in that field :), here i confused myself thinking of predicative instead of propositional
19:23:10 <ddarius> @google Heyting Brouwer Kolmogorov interpretation
19:23:11 <lambdabot> http://en.wikipedia.org/wiki/BHK_interpretation
19:39:46 <hpaste>  (anonymous) annotated "hsql" with "(no title)" at http://hpaste.org/5425#a1
19:54:00 <Gyde> !targets
19:55:01 <jcreigh> Gyde: ?
19:55:44 <LoganCapaldo> he's trying to hax ze lambda bot
19:55:51 <LoganCapaldo> stop 'im
19:55:55 --- mode: ChanServ set +o allbery_b
19:57:41 <olsner_> how do you build an iterating lambdabot quine?
19:58:13 <dcoutts_> lambdabot doesn't respond to itself of course
19:58:35 <olsner_> hmm, so you really need two lambdabots to do it?
19:58:47 <LoganCapaldo> 2 lambdabots is  a bad combo
19:58:53 <LoganCapaldo> they go nuts
19:58:57 <dcoutts_> olsner: yep, which is why we don't let two bots into the channel :-)
20:00:23 <eugman> Quines and goedel's incompleteness theorem is interesting.
20:00:47 --- mode: allbery_b set -o allbery_b
20:00:58 <Gyde> hehe ...
20:01:00 <Gyde> ;)
20:01:08 <Gyde> sorry, wrong channel ;)
20:01:43 <olsner_> I remember reading some blog-like page about how to make quines and a proof for how any turing-complete language has quines
20:02:04 <LoganCapaldo> there's a proof of that?
20:02:07 <eugman> Actuallt if lambdabot responds to his own commands, it'd be an interesting challenge to give him a self replicating command.
20:02:08 <nelhage> Does new cabal not have the GHC-Options flag?
20:02:30 <EvilTerran> most \b commands' outputs have a space at the start
20:02:33 <dcoutts_> nelhage: it's never had a ghc-options flag, there's a field with that name of course
20:02:40 <olsner_> "him"? isn't it generally agreed that lambdabot's a "she"?
20:02:45 <nelhage> s/flag/field/ I guess I mean
20:02:45 <allbery_b> lb doesn't respond to her own commands but occasionally can be tricked into responding to another lb
20:02:47 <EvilTerran> @vixen asl?
20:02:47 <lambdabot> 19/f/California
20:03:21 <allbery_b> vixen output won't ever start with a commmand character, though
20:03:24 <nelhage> My cabal is claiming : Warning: Unknown fields: ghc-options (line 7)
20:03:38 <EvilTerran> see, in the IRC standards, ISTR it said bots're supposed to use NOTICE instead of PRIVMSG, and ignore NOTICEs
20:03:43 <dcoutts_> nelhage: then it's because you've put it in the wrong section
20:03:51 <EvilTerran> http://www.irchelp.org/irchelp/rfc/chapter4.html#c4_4_2
20:03:51 <lambdabot> Title: RFC 1459
20:03:56 <dcoutts_> nelhage: what is the full warning?
20:04:03 <glguy> EvilTerran: but I've not seen many bots that do that
20:04:05 <EvilTerran> "The NOTICE message is used similarly to PRIVMSG. The difference between NOTICE and PRIVMSG is that automatic replies must never be sent in response to a NOTICE message. This rule applies to servers too - they must not send any error reply back to the client on receipt of a notice. The object of this rule is to avoid loops between a client automatically sending something in response to something it received. This is typically used by automaton
20:04:05 <EvilTerran> s (clients with either an AI or other interactive program controlling their actions) which are always seen to be replying lest they end up in a loop with another automaton."
20:04:10 <allbery_b> nor have I
20:04:17 <allbery_b> a few, but it's rare
20:04:28 <nelhage> dcoutts_: http://paste.husk.org/10831
20:04:36 <EvilTerran> i think some chat clients do the Wrong Thing in response to NOTICEs, too
20:05:09 <dcoutts_> nelhage: right, like I said, it's in the wrong section. You've probably put it in the global section rather than the lib or exe section.
20:05:14 <EvilTerran> for instance, gaim used to pop up a dialog instead of putting it into the scrollback, IIRC
20:07:29 <olsner_> LoganCapaldo: this is the page: http://www.madore.org/~david/computers/quine.html
20:07:30 <lambdabot> Title: Quines (self-replicating programs)
20:07:48 <EvilTerran> main = putStr s >> print s where s = "main = putStr s >> print s where s = "
20:08:04 <kpreid> EvilTerran: I don't think the rfc says you *should* use NOTICE; just that it is available for that purpose
20:08:20 <EvilTerran> kpreid, well, it does kinda suggest it's a Good Idea
20:08:29 <kpreid> yeah.
20:08:35 <bos> @hoogle MonadIO
20:08:35 <lambdabot> Control.Monad.Trans.MonadIO :: class Monad m => MonadIO m
20:08:38 <eugman> So let me see if I get monads right. It's a way to wrap a value with additonal information and in a sense make each sequential function literally dependant on the output of the last.
20:08:51 <allbery_b> it can be
20:08:56 <olsner_> among other things, monads are that
20:08:59 <EvilTerran> the sequencing's the important bit
20:10:08 <eugman> I normally grasp abstract concepts quite well but I've ben self teaching and this seems like such a bizarre thing but it's making sense given the issue of referential transperancy
20:11:35 <nelhage> Is haskellnet abandoned? Or named something different?
20:11:50 <LoganCapaldo> eugman: I finally decided that a Monad is a type constructor which supports two functions with types :: a -> m a and :: m a -> (a -> m b) -> m b
20:11:55 <dons> much of it is getting merged into standalone libs, nelhage
20:12:05 <dons> e.g. network-bytestring, json libs, mime libs
20:12:12 <LoganCapaldo> everytime I tried to add more or less detail to that I'd get "caught" and being wrong
20:13:13 <Cale> LoganCapaldo: but it would be good to try to remember something about the laws too :)
20:13:27 <allbery_b> monads are from category theory --- a theory which tries to be as general as possible to describe as much as possible
20:13:28 <LoganCapaldo> Cale: them too :)
20:13:37 <allbery_b> which is more or less what they do in haskell as well :)
20:13:41 <nelhage> Can anyone speculate what's going wrong here: http://paste.husk.org/10832
20:13:47 <eugman> Abstract maths are quite a difficulty
20:13:49 <LoganCapaldo> but I don't worry about them much because I have yet to really create a monad
20:13:59 <Cale> eugman: Have you looked at either of my tutorials?
20:14:04 <Cale> (on monads)
20:14:19 <allbery_b> nelhage:  need -user
20:14:21 * EvilTerran really likes the >=> formulation of monad law #3
20:14:34 <nelhage> ah, thanks.
20:14:38 <allbery_b> otherwise it won't look in your private ghc package db
20:14:46 <eugman> Cale: I haven't been checking the authors of the tutorials I read
20:14:57 <Cale> eugman: Monads as Containers and Monads as Computations
20:15:16 <EvilTerran> and the first, i guess; return >=> f = f
20:15:25 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
20:15:26 <lambdabot> Title: Monads as computation - HaskellWiki
20:15:30 <Cale> http://www.haskell.org/haskellwiki/Monads_as_containers
20:15:31 <lambdabot> Title: Monads as containers - HaskellWiki
20:15:37 <EvilTerran> (the third: ">=> is associative" :D)
20:16:39 <eugman> Hmmm, I either need to figure out how to do copy paste using screen or just do a search on the wiki
20:16:41 <Cale> Monads as computation takes about as general an approach as you'll need in order to do functional programming. Monads as containers tries to form an analogy with containers (though it's not a perfect one, the expectation is that it'll be good enough to get you started if you're stuck)
20:16:45 <olsner_> EvilTerran: where's that formulation from?
20:16:48 <EvilTerran> ghci> :t (return >=>)
20:16:49 <EvilTerran> (return >=>) :: (Monad m) => (a -> m c) -> a -> m c
20:17:13 <EvilTerran> olsner_, well, it follows algebraically from the >>= versions and the definition of >=>
20:17:15 <LoganCapaldo> :t (>=>)
20:17:15 <lambdabot> Not in scope: `>=>'
20:17:17 <EvilTerran> and you can do the reverse, oto
20:17:26 <LoganCapaldo> o
20:17:30 <EvilTerran> *too
20:17:33 <LoganCapaldo> that was a copy and paste job
20:17:40 <Cale> Neither of them completely give the full category-theoretic sense of what a monad is, but that's unnecessary for programming :)
20:17:41 <EvilTerran> (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:17:58 <LoganCapaldo> ah, it's . (sort of)
20:18:14 <EvilTerran> (>=>) : (.) :: (>>=) : ($)
20:18:19 <Cale> It's the (.) in the Kleisli category, sort of.
20:18:21 <LoganCapaldo> .M if you will
20:18:29 <EvilTerran> hehe.
20:20:00 * Gwern-away announces on -cafe a hackage upload of HList. I wonder whether anyone still uses it?
20:20:06 <eugman> Cale:  found them. This is such an uncommon language.
20:20:32 <Cale> eugman: hehe
20:20:48 <Cale> eugman: If you just want to get started with IO, I have a simple intro to that.
20:20:54 <Gwern-away> 'haskell: an uncommon language for uncommon minds'
20:20:57 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
20:20:57 <lambdabot> Title: Introduction to IO - HaskellWiki
20:21:38 <Cale> eugman: If you read the start of Monads as Computation, it should give some idea of why we've chosen to use the monad abstraction to structure many libraries.
20:21:51 <dejones> Hello, any recommendations on mainland European (not United Kingdom) universities that do research with Haskell and/or Operating Systems kernels?  I'm trying to find a place to do my Doctorate studies... I'm currently a Master's student in Comp. Science.
20:22:14 <dejones> So far, I've only found ETH Zurich's NetOS group.
20:22:16 <Cale> eugman: (In fact, that's more the point of that tutorial than teaching anything in particular about how to use monads)
20:23:12 <dejones> Oh yah, and hopefully English-speaking graduate program. ;)
20:24:08 <shapr> yarr!
20:25:10 <dejones> shapr: matey!
20:25:16 <dejones> hehe
20:25:40 <shapr> Hiya dejones, how's Cincinatti?
20:25:55 <dejones> shapr: Not too bad.  Warmer today than lately.
20:26:40 <dejones> shapr: How are you?
20:26:56 <shapr> Doing well, I just played a ps2 game for six hours straight.
20:27:04 <dejones> lol
20:27:08 <dejones> What game?
20:27:15 <shapr> God of War 2
20:27:24 <dejones> Ahh, I have heard that is a great game.
20:27:36 <shapr> And of course, that brought up the topic of doing Functional Reactive Programming outside of Haskell...
20:27:54 <shapr> dejones: Have you tried FRP?
20:28:00 <dejones> shapr: Nope.
20:28:09 <shapr> Are you new to Haskell?
20:28:14 <dejones> shapr: Yes, I am.
20:28:21 <eugman> I'm still learning the basics of the language, but does anyone have suggestions for managing state for a text adventure?
20:28:42 <shapr> dejones: You'd fare well to check out Portland's Haskell OS group.
20:28:55 <shapr> Let's see.. Rebekah Leslie is working on a L4 kernel last I heard.
20:28:56 <luqui> eugman, StateT is pretty good
20:29:01 <dejones> shapr: Yah, I have found them... but I am wanting to go to Europe.  ;)
20:29:05 <shapr> And someone around there is still working on House, I think.
20:29:17 <Cale> eugman: I recommend starting out just forming a record type of the state you need to carry around, and passing it as a parameter to everything that needs it.
20:29:21 <shapr> Ah, I can understand. I did a seven year shift in Europe.
20:29:27 <Cale> You can worry about state monads later :)
20:29:36 <dejones> shapr: wow.  Where in Europe?
20:29:47 <luqui> ahh, right, monads, they're confusing for the first six months :-)
20:30:06 <shapr> dejones: I lived in Sweden and Finland. Speaking of which, have you considered Chalmers?
20:30:07 <Cale> But first you should understand how maintaining state using parameter passing works, and a lot of the time, it works well enough that you'll be fine with it :)
20:31:11 <dejones> shapr: I'm not familiar with Chalmers.
20:31:28 <blbrown> dcoutts, you there?/
20:31:49 <EvilTerran> blbrown, it's 4:30am in dcoutts' timezone
20:31:54 <dons> eugman: most interactive games run in a ReaderT or StateT (or combination of them)
20:32:00 <EvilTerran> (i know because I'm in the same timezone :P)
20:32:01 <blbrown> EvilTerran, weak...hehe
20:32:09 <EvilTerran> @seen dcoutts
20:32:09 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1d 11h 50m 24s ago.
20:32:14 <EvilTerran> @seen dcoutts_
20:32:14 <lambdabot> dcoutts_ is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts_ speak 5m 3s ago.
20:32:18 <shapr> dejones: http://www.cs.chalmers.se/~koen/phdad.html
20:32:18 <lambdabot> Title: PhD Positions in Functional Programming at Chalmers
20:32:21 <EvilTerran> actually, he seems to be here
20:32:35 <dejones> shapr: thank you.  :)
20:33:01 <eugman> dons: k, cool
20:34:35 <olsner_> hmm... 5.30 am... time to get some sleep before monday perhaps?
20:37:46 <eugman> Hmm is there a page specifically about the -> notation for describing functions? I can intuitively understand something simple a -> [a] but when there are multiple arrows I don't fully get it.
20:38:04 <EvilTerran> a -> b -> c = a -> (b -> c)
20:38:27 <EvilTerran> a function that seems to take two parameters really takes one parameter and returns a function that takes the other parameter
20:38:28 <nelhage> How do I get cabal to install something into my homedir? runghc Setup.lhs configure --user still wants to install into /usr/local
20:38:30 <EvilTerran> f x y = (f x) y
20:38:39 <eugman> So is there a heirarchy of implied parenthesis?
20:38:44 <dejones> shapr: is Rebekah Leslie in this channel sometimes?  or why did you recommend her?
20:38:48 <EvilTerran> "foo x y = ..." is like "foo x = f where f y = ..."
20:38:50 <Gwern-away> nelhage: I use 'runhaskell Setup configure --verbose=2 --user --prefix=$HOME/bin --datadir=$HOME/bin/share "$@"'
20:38:55 <EvilTerran> eugman, indeed, -> is right-associative
20:39:04 <dejones> shapr: or just that she is doing l4 microkernel with haskell research?
20:39:10 <eugman> EvilTerran: hmm, that helps a bit
20:39:13 <nelhage> What does cabal-install use? It'd be nice to have everything in the same place
20:39:15 <EvilTerran> and function application ("the ' ' operator") is left-associative
20:39:28 <Gwern-away> nelhage: someting in .cabal
20:39:45 <Gwern-away> nelhage: but it uses an odd structure. leave .cabal to cabal-install, imo. much safer
20:39:48 <EvilTerran> eugman, this also means that (\x -> \y -> ...) is the same as (\x y -> ...)
20:39:57 <EvilTerran> :)
20:41:02 <Eelis> eugman: read any of the gazillion currying tutorials out there
20:42:53 <dejones> shapr: did you leave?  ;)
20:43:41 <shapr> dejones: I've never seen her on the channel. I recommended her because you're interested in OS kernels and Haskell together.
20:43:56 <shapr> dejones: I'm here, but about to fall asleep.
20:44:11 <dejones> shapr: Thank you, she does seem quite appropriate to my interests.
20:45:10 <shapr> @users
20:45:10 <lambdabot> Maximum users seen in #haskell: 465, currently: 417 (89.7%), active: 17 (4.1%)
20:45:24 <shapr> Is 465 the current high water mark?
20:47:01 <Cin> yeah. maximum users ever
20:51:19 <gvdm> I wonder if it would help or hinder to construct some sort of abstract semantic representation of language to use as an intermediatory for translations...
20:52:07 <EvilTerran> like core for natural language?
20:52:22 <Trinithis> what is a .lhs file?
20:52:44 <EvilTerran> "literate haskell"
20:52:55 <Trinithis> is taht wherer comments are default?
20:52:59 <EvilTerran> yes
20:53:32 <dons> Trinithis: there's two styles of .lhs, 'Bird style', after Richard Bird, where code is introduced with >
20:53:40 <dons> this channel is a literate haskell program in that style
20:53:41 <dons> > 1+2
20:53:44 <lambdabot>  3
20:53:50 <dons> and there's a latex style, that is used in ghc and darcs.
20:54:00 <dons> where code is introduced with \begin{code}
20:54:06 <Trinithis> which version do most people prefere?
20:54:15 <dons> of the .lhs styles, Bird style is most common
20:54:52 <EvilTerran> latex style is, surprisingly, useful when you want your code to also be valid latex
20:54:56 <Trinithis> sry, i meant... lhs vs hs
20:55:03 <wagle_> \begin{code} 1+1 \end{code}
20:55:06 <EvilTerran> as i believe tex can be rigged to format the code nicely
20:55:08 <eugman> So what's the advantage of literate style besides lambdabot?
20:55:36 <EvilTerran> bird style's nice for discussing code in a plaintext context
20:55:36 <dons> it encourages more commenting/description, and perhaps more design.
20:55:37 <znutar> it makes the comments nicer to look at
20:55:55 <eugman> I was thinking it'd be cool if you could do  latex style and use haddock but it doesn't look like it
20:55:59 <wagle_> one source, produces typeset article, and runs as a program
20:56:06 <dons> literate programming has a long history in CS.
20:56:14 <dons> and Haskell supports it surprisingly well out of the box
20:56:19 <dons> http://en.wikipedia.org/wiki/Literate_programming
20:56:20 <lambdabot> Title: Literate programming - Wikipedia, the free encyclopedia
20:56:24 <sarehu> While we're on the topic of bird style, does anybody have a fix for Emacs' messed up auto-fill in haskell-mode in the literate comments?
20:56:31 <dons> it also makes sense for Haskell, where our code can be rather beautiful
20:56:36 <thetallguy> I've found recently that I would like more features in LHS
20:57:13 <thetallguy> Being able to redefine a function multiple times, for example, to show the history of development
20:57:14 <znutar> I want semantics for fonts
20:57:36 <thetallguy> znutar that would be nice, as well.   more typsetting is always good.
20:58:14 <Trinithis> do you guys personally like literate haskell? or do you code nonliterate
20:59:05 <znutar> No I mean like the font I use having meaning to the compiler
20:59:07 <EvilTerran> most of the time, i'm just fiddling, so i don't comment much, so LHS is just noise
20:59:10 <thetallguy> I like it, but I only use it for small things
20:59:22 <thetallguy> the emacs mode is kind of wonky
20:59:32 <thetallguy> I think if it were better, I would do more.
21:00:07 <dons> Trinithis: i only use it for publications
21:00:23 <dons> outside of my thesis, and papers, i use non-literate haskell exclusively
21:00:31 <Trinithis> dons: by that you mean code you release?
21:00:43 <thetallguy> inside of a dog, it's too dark to read.
21:01:22 <Gwern-away> on the internet, no one knows you're inside a dog
21:01:35 <thetallguy> I have noodled quite a bit about an even tighter integration of docs and code, but I keep reckoning it to be a big project.
21:03:33 <Trinithis> anyone know how to install lambdabot on a windows computer?
21:03:43 <shapr> Good question.
21:03:51 <LoganCapaldo> 1) install colinux
21:03:58 <Trinithis> i installed the bystestring and cabal
21:04:00 * LoganCapaldo ducks
21:04:19 <EvilTerran> thetallguy, funny, i just read http://www.lorebrandcomics.com/bestfriend.html
21:04:19 <lambdabot> Title: Lore Brand Comics: Best Friend
21:04:38 <Trinithis> what is colinux? a linux vm?
21:04:57 <thetallguy> EvilTerran: lol
21:05:13 <LoganCapaldo> it's linux as a windows process heh
21:05:17 <LoganCapaldo> so yeah a linux vm sort of
21:05:37 <LoganCapaldo> but theres no vm to speak of
21:07:08 * BMeph chickens
21:08:14 <Trinithis> ack! i got an error message saying that it would cause some system problems if i continued to install it
21:08:47 <Trinithis> err... it finished installing anyway.
21:09:00 <Trinithis> LoganCapaldo: it's done. what next?
21:09:08 <EvilTerran> Trinithis, enjoy your system problems :P
21:09:27 <LoganCapaldo> 2) start it up, install lambdabot ;)
21:09:39 <LoganCapaldo> I'm surprised you took me seriously, tbh
21:10:56 <Trinithis> t:D
21:11:02 <EvilTerran> nice hat
21:13:00 <Trinithis> got it at the zoo
21:16:50 <Trinithis> eh, can't get it to work. oh well, the irc one is good enough
21:20:04 <EvilTerran> it might be possible to extract the bits you want into a form that's compilable in windows
21:21:35 <blbrown> EvilTerran, is it 5am where you are at now
21:21:36 <Gwern-away> http://reddit.com/r/programming/info/63vgu/comments/c02r1bb <-- heh. Haskell Facts
21:21:39 <Trinithis> EvilTerran: I'll just wait until i get my own computer during the summer
21:21:43 <Gwern-away> 'Haskell doesn't unroll loops; loops roll over for Haskell'
21:21:52 <Trinithis> EvilTerran: im gonna install linux on that
21:22:22 <EvilTerran> blbrown, yes, it is. i went to bed at 10pm and randomly woke up around 3am feeling rested
21:22:25 <EvilTerran> Trinithis, ok
21:22:44 <wagle_> so haskell does all P problems in NP time?
21:23:21 <Gwern-away> hm. maybe 'Haskell can do NP problems in (amortized) P time'?
21:25:10 <dons> ?faq
21:25:10 <lambdabot> The answer is: Yes! Haskell can do that.
21:25:18 <dons> ?quote oleg
21:25:18 <lambdabot> emu says: olegarithmic
21:25:22 <dons> ?quote Oleg
21:25:23 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
21:25:40 <Gwern-away> did... did Oleg actually say that?
21:25:49 <EvilTerran> i think so, yes
21:25:52 <EvilTerran> ?where oleg
21:25:53 <lambdabot> http://okmij.org/ftp/
21:26:12 <dons> yeah. its from the type level decimals library
21:26:16 <Gwern-away> anyone else, I'd take that as a jape, but with Oleg, I'm never sure. he does so much
21:27:10 <EvilTerran> it'd be something under http://okmij.org/ftp/Haskell/types.html
21:27:10 <lambdabot> Title: Haskell Programming: Types
21:27:27 <Gwern-away> (and I understand so little. :( I'm still not sure what you'd use his HList stuff *for*, and I spent hours working through and messing with it)
21:31:53 <dolio> Gwern-away: Go read about polymorphic variants, and how great they are in OCaml.
21:32:11 <dolio> Then you can come back and realize that HList is an implementation of them as a library. :)
21:33:36 <dolio> Or, extensible records, too.
21:33:43 <dolio> They're related, I suppose.
21:36:14 <EvilTerran> one's products, the other coproducts - apart from that they're really quite similar
21:36:27 <dolio> Yeah.
21:36:43 <Gwern-away> got a link handy? all the google hits seem to be either dead, about variants in haskell, or biology-related
21:38:24 <EvilTerran> it's not a link as such, but TaPL describes them, i think
21:38:38 <EvilTerran> @where tapl
21:38:38 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
21:38:46 <soduko>   
21:38:48 <soduko> /home/neeraja/pax/lib/ghc-6.8.2/libHSrts.a(Main.o)(.text+0x7): In function `real_main':
21:38:49 <soduko> : undefined reference to `__stginit_ZCMain'
21:39:00 <soduko> and the file works when i load it in ghci
21:39:02 <dolio> @go extensible records scoped labels leijen
21:39:03 <lambdabot> http://research.microsoft.com/users/daan/pubs.html
21:39:03 <lambdabot> Title: Publications
21:39:08 <EvilTerran> it's a great book for learning about programming language theory, anyway
21:39:25 <Gwern-away> 60 DOLLARS?
21:39:34 <dolio> The paper there on extensible records mentions variants as well.
21:39:40 <hpaste>  soduko pasted "link error" at http://hpaste.org/5428
21:39:56 * Gwern-away thinks I won't be getting that any time soon. I already blew too much on Hudak's textbook and ET Jayne
21:39:56 <EvilTerran> meh. it's an academic book. those're always expensive.
21:40:03 <Gwern-away> 's _Probability Theory_
21:40:09 <EvilTerran> i've seen ones that cost a lot more than 60USD
21:40:33 <kmcallister> you can also find TaPL online for (illegal) free download, if you're okay with this sort of thing
21:40:40 <sclv> ok how do I take something from (a, IO b) to IO (a, b) ?
21:40:42 <dolio> Anyhow, I think that's a nice looking proposal, but I imagine HList can do most of it (although it's probably more ugly about it).
21:40:46 <kmcallister> i did this, after i lost my hardcopy
21:41:05 <EvilTerran> http://www.abebooks.com/servlet/SearchResults?an=pierce&tn=types+programming+languages
21:41:07 <lambdabot> Title: AbeBooks: Search Results - pierce and types programming languages, http://tinyurl.com/ynkomh
21:41:26 <soduko> did any one get a similar linker error on linux x86?
21:41:40 <sclv> I could have sworn there was some nifty trick to do it using the functor instance of (,) but I'm not so sure now.
21:41:53 <Gwern-away> heh. a lot of copies in India
21:41:57 <johnnowak> urgh. why did I pay the full price for tapl on amazing...
21:42:03 <EvilTerran> soduko, did you give ghc the --make flag?
21:42:09 <johnnowak> ... amazon. bloody freudian crap from me lately.
21:42:14 <soduko> nope just ghc genq.hs
21:42:20 <EvilTerran> try doing that
21:42:30 <kmcallister> :pl \(a, iob) -> iob >>= (\b -> return (a,b))
21:42:33 <kmcallister> @pl \(a, iob) -> iob >>= (\b -> return (a,b))
21:42:33 <lambdabot> uncurry (fmap . (,))
21:42:40 <kmcallister> :t uncurry (fmap . (,))
21:42:42 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
21:42:49 <soduko> EvilTerran: it workd. but why?
21:42:51 <kmcallister> :t (fmap . (,))
21:42:52 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
21:43:19 <EvilTerran> it tells ghc to do dependency analysis an' stuff
21:43:41 <dolio> @type sequenceA :: (Monoid a) => (a, IO b) -> IO (a, b)
21:43:41 <lambdabot> Not in scope: `sequenceA'
21:43:46 <EvilTerran> ?hoogle Data.Traversable.sequence
21:43:46 <lambdabot> No matches, try a more general search
21:43:51 <dolio> @type Data.Traversable.sequenceA :: (Monoid a) => (a, IO b) -> IO (a, b)
21:43:52 <lambdabot>     Could not deduce (Data.Traversable.Traversable ((,) a))
21:43:52 <lambdabot>       from the context (Monoid a)
21:43:52 <lambdabot>       arising from use of `Data.Traversable.sequenceA'
21:44:07 <EvilTerran> sequence :: (Monad m, Traversable t) => t (m a) -> m (t a)
21:44:10 <soduko> thanks
21:44:33 <wagle_> @type Data.Traversable.sequenceA
21:44:34 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
21:44:35 <EvilTerran> there's no instance Traversable ((,)a), tho, apparently
21:45:12 <EvilTerran> so uncurry(fmap.(,)) is probably your best bet
21:45:20 <sclv> gah. the hard way it is. :-(
21:45:31 <EvilTerran> the hard way would be defining that instance ;)
21:46:29 <EvilTerran> you'd need to make an instance of Foldable while you were at it
21:48:37 <dolio> Yeah, and send it to the libraries list, while you're at it. :)
21:48:55 <sclv> well, secondM = uncurry(fmap . (,)) . second it is
21:49:55 <EvilTerran> instance Foldable ((,) w) where foldMap f (w,x) = f x
21:49:56 <EvilTerran> instance Traversable ((,) w) where traverse f (w,x) = (,) w <$> f x
21:51:51 <nolrai> @kind ErrorT
21:51:52 <lambdabot> * -> (* -> *) -> * -> *
21:52:12 <EvilTerran> ErrorT error monad monadParam
21:52:34 <EvilTerran> @unmtl ErrorT e m a
21:52:35 <lambdabot> m (Either e a)
21:53:03 <nolrai> whats the diffrence between ErrorT e (StateT s) r and StateT s (ErrorT e) r, again?
21:53:28 <nelhage> @unmtl RWST r w s m a
21:53:28 <lambdabot> r -> s -> m (a, s, w)
21:53:34 <EvilTerran> @unmtl ErrorT e (State s) r a
21:53:34 <lambdabot> err: Unknown MTL(3)
21:53:43 <EvilTerran> @unmtl ErrorT e (State s) a
21:53:44 <lambdabot> s -> (Either e a, s)
21:53:53 <EvilTerran> @unmtl StateT s (Error e) a
21:53:53 <lambdabot> err: Unknown MTL(1)
21:53:59 <EvilTerran> @unmtl StateT s (Either e) a
21:53:59 <lambdabot> err: Unknown MTL(1)
21:54:02 <EvilTerran> grah
21:54:23 <nolrai> it doesnt know StateT?
21:54:29 <EvilTerran> nolrai, in one of them, throwing an error loses the current state; in the other, it preserves it
21:55:01 <EvilTerran> ErrorT e (State s) a preserves state, looking at the one working @unmtl output there ;)
21:55:31 <nolrai> thanks!
21:56:52 <nolrai> EvilTerran++
21:57:10 <EvilTerran> :)
21:57:23 <soduko> any yi users here?
21:57:32 <EvilTerran> same goes for ContT State vs StateT Cont, i thinlk
21:57:46 <ddarius> :t runContT
21:57:46 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
21:57:49 <ddarius> :t runStateT
21:57:49 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
21:59:46 <vincenz> Anyone familiar with virtual hosting solutions?
22:00:48 <sclv> a tiny bit.
22:01:20 <vincenz> sclv: suggestions?
22:04:20 <sclv> doing some stuff with savvis now. I guess they're ok. don't have much of a base to compare to. the boxes are probably overpowered for what we're doing and they're locked down insanely tight so that we have to wait forever to get every single port we need opened, but that might be issues on our side and with communications as much as with savvis themselves... I guess that sort of thing is nice for some circumstances anyway.
22:05:08 <sclv> oh wait, sorry. that's virtualization not vhosting.
22:05:19 * sclv is braindead today.
22:05:31 <vincenz> difference is?
22:06:43 <sclv> virtual hosting is the low-end solution. lots of websites from one server. virtualization is one server (or maybe many) with virtualized oses on top, one instance per app.
22:07:18 <vincenz> sclv: what do you call linode?
22:07:30 <vincenz> sclv: no I want virtual hosting in the  sense of root-access
22:07:38 <vincenz> sclv: I want my own (virtual) linux box
22:07:55 <sclv> right. that's virtualization then i guess.
22:08:55 <faxathisia> Hello
22:09:22 <faxathisia> Does anyone know of some interpreter in haskell (for any language) which has a debugger?
22:09:38 <vincenz> sclv: hmm
22:10:13 <ddarius> faxathisia: GHCi
22:11:21 <ddarius> Pugs may have a debugger; I don't know.
22:15:35 <sclv> vincenz: linode seems pretty reasonable if that's what you want. i only know the corporate stuff, not consumer-level solutions really...
22:16:08 <faxathisia> thanks, GhciMonad.hs looks good
22:16:16 <vincenz> sclv: how do you see if it's reasonable or not
22:16:18 <vincenz> sclv: what does one look at?
22:19:44 <sclv> just meant the price seemed reasonable. my experience with vmware and the like is that performance will probably sort of drag, an it will be fairly unbearable to use x at all. but at those prices, can't hurt to try it and see!
22:19:59 <vincenz> well prolly I'll get in with X
22:20:07 <vincenz> it's mostly to have a place online to experiment with websites
22:20:11 <vincenz> to maybe run irc
22:20:13 <vincenz> that kind of thing
22:21:44 <sclv> there's also, e.g. http://www.openhosting.com, but i'll be darned if i can tell you which is a better bet.
22:21:44 <lambdabot> Title: OpenHosting, Inc. - Linux Virtual Private Server Hosting
22:22:37 <nolrai> ?src Second
22:22:37 <lambdabot> Source not found.
22:22:43 <nolrai> ?src first
22:22:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:22:52 <vincenz> what is 'LAMP'
22:23:08 <sclv> norlai: go to the haskell ghc libraries and look up the source directly for things like that.
22:23:26 <sclv> LAMP = Linux Apache MySQL PHP. the default boring webapp stack.
22:23:28 <nolrai> @pl \g f (a, b) = (f a, b)
22:23:28 <lambdabot> (line 1, column 13):
22:23:28 <lambdabot> unexpected "="
22:23:28 <lambdabot> expecting pattern or "->"
22:23:33 <nolrai> @pl \ f (a, b) = (f a, b)
22:23:33 <lambdabot> (line 1, column 12):
22:23:33 <lambdabot> unexpected "="
22:23:33 <lambdabot> expecting pattern or "->"
22:23:39 <nolrai> @pl \ f (a, b) -> (f a, b)
22:23:39 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
22:23:51 <nolrai> @pl \ (a, b) f -> (f a, b)
22:23:51 <lambdabot> uncurry (flip . ((,) .) . flip id)
22:23:58 <sclv> second is defined in terms of other things, as i recall, but first is a class method of Arrow, by the way.
22:24:11 <nolrai> thanks!
22:24:51 <vincenz> sclv: thx for the help
22:25:01 <vincenz> sclv: linode seems to offer more bandwidth + diskspace
22:25:03 <vincenz> not sure about cpu usage
22:25:04 <sclv> :-)
22:25:27 <vincenz> is there cheaper than 20$/month or is that a normal price?
22:26:23 * vincenz had some other place before, 20$/year, with unlimited diskspace, but only ftp access, and it had really crappy latency
22:26:54 <sclv> 20$/mo is the same price, e.g., earthlink charge for a decend standard shared hosting package so... can't imagine i'll get better, especially since this is pretty new technology.
22:27:07 <vincenz> ok, thanks
22:29:46 <johnnowak> site5 is a not so awful host.
22:31:18 <blbrown> linode is cool and I think they are playing around with xen virtualization
22:31:42 <blbrown> yes, 20 is steep
22:32:05 <vincenz> http://www.gandi.net/hosting/
22:32:05 <lambdabot> Title: [Gandi] HÃ©bergement
22:32:07 <vincenz> what of this?
22:32:16 <johnnowak> gandi has awful support
22:33:13 <vincenz> johnnowak: oh
22:33:14 <vincenz> ?
22:33:19 <johnnowak> site5 is nice. support within a couple hours usually. cheap. shell access, compiler, no long-running process limits. decent uptime. etc.
22:33:21 <vincenz> let's move this to #oasis?
22:33:23 <vincenz> bit OT here
22:33:29 <johnnowak> errr. yes.
22:33:41 <blbrown> I like eapps for my more moderate stuff and linode when I need something without restrictions.
22:40:23 <nolrai> is there a zipWith for arrays?
22:41:27 <Cale> nolrai: No, but it could be written reasonably efficiently, at least if the bounds are the same.
22:41:55 <wagle_> @hoogle zipwith array
22:41:55 <lambdabot> Did you mean: Zipwith Array
22:41:55 <lambdabot> Prelude.undefined :: a
22:41:55 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
22:42:08 <wagle_> ?
22:42:50 <wagle_> google zipwith array haskell    got some results
22:44:56 <scook0> I've just uploaded http://code.haskell.org/bimap/ if anyone's interested
22:44:56 <lambdabot> Title: Index of /bimap
22:46:14 <nolrai> Cale: is "listArray (bounds a1) (zipWith f (elems a1) (elems a2))" reasonably efficient?
22:48:34 <nolrai> I'm guesing no.
22:53:29 <sclv> depends what you're doing with it? if you're doing lots of zipping and unzipping, you need to ask why you're using arrays to begin with...
22:59:39 <nolrai> sclv: thanks
23:01:57 <nolrai> :t replicate
23:02:04 <lambdabot> forall a. Int -> a -> [a]
23:02:55 <nolrai> :t zipWith
23:02:56 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
23:18:16 <Twey> @pl (\ x y -> compare y x )
23:18:17 <lambdabot> flip compare
23:18:40 <Twey> @pl (\ x y z -> compare z y x )
23:18:40 <lambdabot> flip (flip . flip compare)
23:23:36 <wagle_> :t flip
23:23:42 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:23:46 <wagle_> :t flip . flip
23:23:47 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
23:23:59 <wagle_> :t flip . flip . flip
23:24:00 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:24:35 <wagle_> :t flip flip
23:24:35 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
23:24:43 <wagle_> :t flip flip flip
23:24:44 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
23:24:57 <wagle_> :t flip flip flip flip
23:24:57 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
23:25:41 <wagle_> :t flip flip flip flip flip
23:25:42 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
23:25:50 <faxathisia> yes ?
23:26:16 <wagle_> :t flip flip flip flip flip flip
23:26:17 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
23:26:23 <sarehu> /msg lambdabot :t flip flip flip flip flip flip
23:26:24 <wagle_> neato
23:26:30 <faxathisia> Why is that neat?
23:26:39 <faxathisia> (:t in GHCI also works)
23:27:22 <sarehu> ?users
23:27:22 <lambdabot> Maximum users seen in #haskell: 465, currently: 407 (87.5%), active: 13 (3.2%)
23:27:26 <wagle_> closing your eyes also works
23:28:08 <faxathisia> wagle_, not sure what you mean by that, Why is the type of flip .. flip neat though?
23:28:30 <wagle_> flip5 is the same as flip6
23:29:23 <faxathisia> strange
23:29:32 <faxathisia> looks like, past flip flip, they are all the same
23:30:42 <wagle_> meant flip4 and flip5, where the naming made the equality of the types obvious
23:31:21 <faxathisia> yeah, it seems like flip3 = flip4 = flip5 = flip6 = ... though, Doesn't it?
23:31:37 <faxathisia> I don't really see dow that's possible
23:32:12 <faxathisia> oh, wait, I get it
23:38:27 <Twey> @pl (\y -> comparison y x == LT)
23:38:27 <lambdabot> (LT ==) . flip comparison x
23:38:37 * Twey frowns.
23:38:49 <Twey> Ah.
23:38:51 <dons> did a good job there
23:39:01 * Twey nods.
23:39:08 <Twey> lambdabot is still smarter than me :-(
23:39:25 <dons> it has a big handbook of tricks
23:39:27 <faxathisia> (== GT) . comparison x
23:39:30 <faxathisia> that works too?
23:39:45 <Twey> faxathisia: I think not
23:39:56 <Twey> Er
23:40:00 <Twey> Wait, yes, it does
23:40:00 <faxathisia> wait
23:40:04 <dons> is 'comparison' == compare?
23:40:06 <Twey> But it's semantically worse
23:40:13 <Twey> dons, eh, basically
23:40:21 <wagle_> @pl  (== GT) . comparison x
23:40:21 <lambdabot> (GT ==) . comparison x
23:40:35 <Twey> dons: I'm fiddling with quickSort v2 from http://en.wikibooks.org/wiki/Haskell/Higher-order_functions_and_Currying
23:40:36 <sarehu> comparison y x == LT   is in general not the same as  comparison x y == GT
23:40:37 <lambdabot> http://tinyurl.com/uuqak
23:40:38 <sjw> dons: hey
23:40:41 <faxathisia> @quickcheck (\ x -> (LT ==) . flip comparison x) === (\ x (== GT) . comparison x)
23:40:42 <lambdabot> Unknown command, try @list
23:40:49 <faxathisia> @check (\ x -> (LT ==) . flip comparison x) === (\ x -> (== GT) . comparison x)
23:40:49 <lambdabot>   Not in scope: `comparison'
23:40:52 <dons> ?check \x y -> let _=x::Int ((== GT) . compare x $ y) == ((LT ==) . flip comparison x $ y)
23:40:52 <lambdabot>  Parse error at "==" (column 24)
23:40:58 <dons> ?check \x y -> let _=x::Int in ((== GT) . compare x $ y) == ((LT ==) . flip comparison x $ y)
23:40:58 <lambdabot>   Not in scope: `comparison'
23:40:59 <Twey> I had ((== LT) . (`compare` x)) which is apparently horribly wrong
23:41:01 <dons> yo sjw
23:41:06 <sarehu> where 'comparison'.... is 'compare'
23:41:08 <dons> ?check \x y -> let _=x::Int in ((== GT) . compare x $ y) == ((LT ==) . flip compare x $ y)
23:41:09 <lambdabot>  OK, passed 500 tests.
23:41:14 <Twey> Yeah, just sub it out with compare
23:41:35 <sarehu> but that's with respect to cases like comparing NaNs.
23:41:49 * Twey nods.
23:42:48 <sarehu> ?check \x y -> let _=x::Double in ((== GT) . compare x $ y) == ((LT ==) . flip compare x $ y)
23:42:48 <lambdabot>  OK, passed 500 tests.
23:42:56 <sarehu> bah, no nans
23:42:57 <dons> heh
23:43:05 <dons> or bottoms
23:43:44 <scook0> ?check not . isNan :: Double -> Bool
23:43:44 <lambdabot>   Not in scope: `isNan'
23:43:49 <scook0> ?check not . isNaN :: Double -> Bool
23:43:50 <lambdabot>  OK, passed 500 tests.
23:44:30 <dons> ?check \n m y -> let x= n / m ::Double in ((== GT) . compare x $ y) == ((LT ==) . flip compare x $ y)
23:44:31 <lambdabot>  Falsifiable, after 1 tests: 0.0, 0.0, 0.0
23:45:00 <dons> ?check \n m y -> m /= 0 ==> let x= n / m ::Double in ((== GT) . compare x $ y) == ((LT ==) . flip compare x $ y)
23:45:01 <lambdabot>  OK, passed 500 tests.
23:45:05 <dons> NaNs :)
23:45:32 <wagle_> :t NaN
23:45:33 <lambdabot> Not in scope: data constructor `NaN'
23:45:36 <dons> > 1/1
23:45:37 <lambdabot>  1.0
23:45:38 <dons> > 1/0
23:45:39 <lambdabot>  Infinity
23:45:49 <wagle_> :t 0/0
23:45:50 <lambdabot> forall t. (Fractional t) => t
23:46:04 <scook0> > 0/0 :: Rational
23:46:04 <lambdabot>  Exception: Ratio.%: zero denominator
23:46:32 <sarehu> ?check (== 0) :: Double -> Bool
23:46:33 <lambdabot>  Falsifiable, after 1 tests: 0.3333333333333333
23:46:38 <sarehu> dumb
23:46:48 <sarehu> ?check (/= 0) :: Double -> Bool
23:46:49 <lambdabot>  Falsifiable, after 0 tests: 0.0
23:47:13 <sarehu> foiled again!
23:48:01 <kaol> ?check (< maxBound-1) :: Int -> Bool
23:48:01 <lambdabot>  OK, passed 500 tests.
23:48:22 <dons> ?check (< maxBound-1) :: Int8 -> Bool
23:48:22 <lambdabot>   add an instance declaration for (Arbitrary Int8)     In the expression:,   ...
23:48:27 <dons> ?check (< maxBound-1) :: Word8 -> Bool
23:48:27 <lambdabot>  Falsifiable, after 64 tests: 255
23:48:49 <dons> the arbitraries should be hooked up to mersenne-random, so we get good distributoin..
23:51:37 <Twey> @pl (\ v -> filter ((== v) . ((flip cmp) x)))
23:51:38 <lambdabot> filter . (. flip cmp x) . (==)
23:52:10 <sclv> if I keep getting "gcc: fork: Resource temporarily unavailable" in ghci after playing around with io a bit, is that because there's something i'm not closing properly, or is this a known issue... ?
23:53:03 <sclv> by io i should specify i mean System.Process.
23:53:58 <Twey> Hmm
23:54:10 <Twey> (. x y) === (x . y) ?
23:54:38 <sarehu> ((.) x y)
23:54:51 <sarehu> (. x y) == (\z -> z . x y)
23:54:53 <Twey> Same as (. x y) ?
23:54:59 <Twey> Ah
23:55:02 <sarehu> you know how (+ 3) makes a function that adds 3?
23:55:02 <Twey> Of course
23:55:04 <Twey> Thanks
23:55:04 <sarehu> it's the same syntax
23:55:09 <Twey> Yeah, it just hit me :-P
23:55:29 <wagle_> sclv, probably need to reap your child processes with something like a wait call
23:56:30 <wagle_> i've seen people here refer to functions named waitSomethingSomething
23:56:30 <sclv> I thought I was... I'm forcing a hGetContents on their err buffer, so they should be complete before the program can move on.
23:57:07 <sclv> right. I'm using waitForProcess elsewhere where I'm not waiting on a handle. not sure why that isn't enough...
23:57:27 <Twey> I love pointless style ^_^
23:57:39 <Twey> It just makes my head hurt in strange new ways
23:57:50 <wagle_> i've never gotten around to figuring out concurrent haskell, so i dont know much
23:58:40 <davidL`> sclv: what email do I send happs patches to?
23:59:15 <dons> wagle_: forkIO + MVars. that's it :)
23:59:45 <sclv> I'd imagine alexj -- his email should be listed in all the .cabal files as maintainer.
