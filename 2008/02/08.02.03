00:00:13 <wagle_> @hoogle forkIO
00:00:14 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
00:00:14 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
00:00:21 <davidL`> right, thanks
00:00:52 <wagle_> @hoogle MVars
00:00:53 <lambdabot> No matches found
00:00:57 <wagle_> 8(
00:01:02 <wagle_> 8-D
00:01:17 <wagle_> dons, thanks!
00:01:51 <dons> :t Control.Concurrent.newMVar
00:01:52 <lambdabot> forall a. a -> IO (GHC.IOBase.MVar a)
00:01:54 <dons> :t Control.Concurrent.takeMVar
00:01:55 <lambdabot> forall a. GHC.IOBase.MVar a -> IO a
00:01:57 <dons> :t Control.Concurrent.putMVar
00:01:58 <lambdabot> forall a. GHC.IOBase.MVar a -> a -> IO ()
00:09:48 <faxathisia> My compiler (or someelses code) doesn't work :(
00:10:54 <wagle_> the fix is obvious
00:11:39 <faxathisia> no to me..
00:11:50 <wagle_> nor to i
00:12:02 <wagle_> what does it complain about?
00:13:52 <Twey> Heh
00:14:04 <Twey> "It's obvious -- but maybe only if you're Dutch"
00:15:49 <sclv> gah this resource unavailable thing is really getting to me.
00:16:28 <wagle_> maybe you arent WAITing for your children after they have actually died
00:17:15 <wagle_> or waiting for the wrong one, and they are piling up waiting to be reaped
00:17:50 <Cin> twey: point-free for the win!
00:17:53 <sclv> if I'm getting contents on their buffer, that means they must be closed finished, right?
00:18:00 <sclv> s/closed//g;
00:18:03 <Twey> Cin: It's great :-D
00:18:55 <Twey> Also, I think I've been on this channel for at least a week now, making Haskell the language that's taken the longest to learn of all those I've tried
00:19:12 <Twey> And I still have a way to go :-D
00:19:16 <dons> Twey, what have you been trying to do with it?
00:19:23 <wagle_> sclv, dunno..  all i know is how processes in unix work (but not haskell)..  i can imagine you can get output from a process before its died though
00:19:31 <dons> i reckon we can bootstrap new hackers faster than a week
00:19:59 <sclv> testing with a compiled program now and seeing if its just a ghci issue. ghci messes with me on filedescriptors too.
00:20:09 <sclv> if I :r often enough, it uses them all up..
00:20:50 <Twey> dons: Haskell?  I'm just following through various tutorials and so for now... might do a quick IRC bot when I actually manage to work out how to apply monads to my code, it's something of a tradition :-P
00:21:40 <dons> yeah, might be a good idea to work on a concrete problem
00:21:44 <dons> while referring to tuts
00:21:56 <wagle_> my standard helloworld program is a scheme interpreter
00:22:02 <dons> you can chase tutes all day long, but not reach a point where you can put together real stuff
00:22:11 <dons> that seems surprisingly common, with "100 line burnout"
00:22:21 <dons> where people feel they don't know how to structure large haskell programs.
00:22:28 <Twey> Hmm
00:22:31 <Twey> You may have a point.
00:22:32 <dons> so, if you can get into writing real stuff sooner, the better
00:22:45 * Twey nods.
00:22:58 <dons> theory *and* practice :)
00:23:01 <Cin> twey: your irc bot can connect to my ircd :P
00:23:03 <Twey> I will get cracking on that IRC bot, then, when I wake up
00:23:18 <Twey> Cin: That sounds oddly sexual
00:23:18 * dons is impressed Twey can use irc while asleep
00:23:31 <Twey> dons: I've passed exams whilst asleep
00:23:36 <Cin> twey: that's the way i roll
00:23:40 <Twey> Heh
00:23:48 <Twey> Cin: No objections then :-P
00:23:57 <dons> i'd probably look at some scripts you have written in other languages, and redo them in the best haskell you can.
00:24:11 <dons> and seek advice about libs/ structures/ types to use
00:24:27 <Twey> Hmm
00:24:28 <dons> if you get past that, you're in a state where you can do real stuff in haskell that's useful to you
00:24:40 <Twey> Yes, I could do that
00:24:45 <wagle_> dons: doesnt that sorta lead you to write non-functional-like code?
00:24:53 <Twey> It's rather jumping in at the deep end though
00:25:03 <faxathisia> Twey, I found that works
00:25:03 <dons> wagle_: nope. FP shines through lots of tihngs
00:25:18 <dons> most perl scripts turn into StateT + Text.PrettyPrint + Parsec + Data.Map
00:25:26 <Twey> Well, either that or porting little utility scripts that aren't really worth the effort :-)
00:25:28 <dons> actually, not even StateT
00:25:54 <Cin> like spj says in his talk, a lot of the heavy processing of programs can be purely functional, only every so often involving IO
00:25:55 <dons> wagle_: its important to realise that "non functional" problems really aren't.
00:26:07 <dons> since if we think that way, we'll never use it for real stuff
00:26:34 <dons> the haskell way is to do a pure model ,wrapped in a monadic skin, for those very imperative programs. or for small stuff, IO , or an IO wrapper
00:26:57 <dons> but, its a general purpoose language, so no domain should be considered out of bounds
00:27:07 <Twey> Oh
00:27:18 <wagle_> having not yet read the two functional algorithms books, i still think of algorithms in imperative ways
00:27:27 <Twey> Before I go, out of curiosity: is there any way to interact with ActiveX in Haskell?
00:27:36 <dons> i don't think we have bindings to that
00:27:42 <dons> there's OpenGL bindings (that's related, isn't it?)
00:27:47 <Twey> I'm trying to convert someone who requires it
00:27:50 <Twey> dons, nah :-)
00:27:54 <dons> wagle_: yeah, maybe "purely functional data structures" ?
00:28:01 <dons> do the data structure, and the algorithms fall out
00:28:15 <Twey> ActiveX is... well, the way to do just about anything under Windows nowadays, I'm lead to believe
00:28:20 <dons> ah ok
00:28:26 <mrd> ActiveX is a Windows API for doing foolish Windows things
00:28:37 <dons> sounds fun :)
00:28:39 <Twey> Heh
00:28:45 <Twey> Right
00:28:47 <mrd> like desktop re-arranging and infecting oneself with virii
00:28:55 <Twey> Bed, then, in preparation of a project
00:28:56 <Twey> 'night!
00:29:00 <mrd> mostly the latter
00:29:03 <Cin> night
00:29:05 <dons> have well typed dreams, Twey
00:29:13 <Twey> Heheh, thanks
00:29:18 <wagle_> i'm still of the habit to be loath to copy things all over the place instead of rewriting an object in place
00:30:57 <wagle_> what i'd like is a series of algebraic transformations were I can convert algorithms from imperative form to purely functional form and back..  (i think thats not directly possible though)
00:32:23 <sarehu> it's possible...
00:32:26 <bd_> wagle_: It's called a universal turing machine :)
00:33:00 <bd_> or at least an emulator/language implementation
00:33:45 <sarehu> just keep a map with keys/values and a unique key-generator as a replacement for STRefs
00:33:52 <wagle_> okasaki seemed to claim that he had to rethink completely to get purely functional algorithms
00:34:55 <Cin> i just think in terms of substitutions rather than timeful statements
00:36:38 <wagle_> bd_, a naive fortran interpreter written in haskell won't necessarily preserve big-O
00:37:24 <bd_> it doesn't have to be a naive interpreter :)
00:39:47 <wagle_> rewrite memory in place seems to be a kind of cheat that only some haskell compilers/interpreters (that run the fortran interpreter) would support
00:40:53 <sarehu> haskell is impure anyway... it uses lazy evaluation
00:41:08 <sarehu> and memoizes!  gasp
00:41:17 <wagle_> i guess i am interested in rewrite in place, and supposedly these situations can be detected, but as far as i've been told, nothing tells you when the compiler decided it couldnt be done
00:41:48 <johnnowak> mm uniqueness types
00:43:06 <wagle_> yeah, but you get the same thing each time you run the computation whose value is to be memoized
00:44:58 <wagle_> johnnowak, will uniqueness types fail at compile time if the single-threaded store couldnt be proved?
00:45:39 <flux> how couldn't it be proved with uniqueness types?
00:45:42 <johnnowak> uniqueness types prove data is singularly referenced, so i can't imagine how it would fail.
00:45:48 <johnnowak> that's the entire point
00:46:09 <bd_> sarehu: lazy evaluation and memoization's an implementation detail, unless you use unsafe*
00:47:05 <johnnowak> of course if it's an implement detail, you can't depend on it
00:47:06 <wagle_> ok..  in previous discussions it seemed to not matter to the person talking to be whether or not it rewrote-in-place or copied..  (and that I was being impure for worrying about such things)
00:50:16 <Cale> sarehu: A lazy evaluation reduction step is a pure function on code graphs.
00:50:54 <flux> wagle_, well, in a functional program you can always copy, and if you only have one instance around, you can always mutate?
00:51:15 <flux> because nothing has a reference to the old version
00:51:40 <flux> mutating values with uniqueness typing is a mere optimization
00:51:47 <wagle_> i want to prove nothing has a reference
00:51:49 <flux> (a good one at that, I suppose)
00:52:06 <wagle_> O(n) ~> O(1)
00:52:34 <johnnowak> flux: it's not a mere optimization, it's one of the major motivations for having uniqueness types
00:53:06 <flux> johnnowak, sure, but it's not a fundamental requirement for uniqueness types to work.. say, you could write a prototype which indeed didn't mutate
00:53:27 <wagle_> tail call reduces unbounded stack space to constant space..
00:53:28 <johnnowak> yes that's true, but it would be rather silly to have them then.
00:53:38 <wagle_> is tail call just an optimization?
00:53:38 <flux> you could still have side effects
00:56:01 <hpaste>  (anonymous) annotated "why is it "ambiguous"?" with "(no title)" at http://hpaste.org/5418#a1
00:57:38 <wagle_> doesnt printf need dependent types to cast percent as a double?
00:58:03 <ac> fromIntegral could produce any fractional
00:58:27 <ac> I think that's why it's ambiguous
00:58:29 <sarehu> printf is basically crazy.  that's why.  in particular it only knows about the typeclass
00:58:30 <bparkis> is it possible to completely abstract out the notion of "sorting," so that you can, for instance, recognize that algorithms that sort lists or that sort some other sequence representation, functionally equivalent to lists, are doing the same thing?
00:58:39 <wagle_> hmm..  it could be ambiguous between float and double
00:59:09 <siti> when's type checked printf going to be in ...
00:59:31 <wagle_> i've skimmed articles that alleged to make printf functional, but i cant recreate that here
00:59:48 <swiert> Ralf Hinze has a functional pearl about printf in Haskel.
01:00:01 <wagle_> yeah..
01:00:11 <faxathisia> This is totally cool
01:00:19 <bparkis> i.e. is it possible to define a (noncomputable) function that maps algorithms to whether they perform "sorting" in some sense
01:00:19 <faxathisia> http://www.lri.fr/perso/~sozeau/repos/coq/misc/shiftreset/GenuineShiftReset.html
01:00:20 <lambdabot> Title: GenuineShiftReset, http://tinyurl.com/2ywh6h
01:00:28 <faxathisia> regarding printf
01:00:37 <flux> wagle_, tail calls are an optimization required for transforming the algorithm to actual hardware
01:00:53 <flux> wagle_, were you proving an algorithm for termination, would you take tail call optimization into account?
01:01:08 <wagle_> flux, no, return jumps work "just fine"
01:01:19 <swiert> Found it: http://www.informatik.uni-bonn.de/~ralf/publications/Format.ps.gz
01:01:23 <flux> wagle_, memoization is an optimization too, yet it can change the complexity of a function
01:01:31 <wagle_> fact 1000000000 without tail recursive crashes
01:01:50 <flux> wagle_, crashes even if you have a terabyte of memory?
01:01:53 <siti> increase the stack size ;)
01:02:25 <bparkis> let F be a function in question (that we are deciding if it is sorting in some sense or not), let A be its input, let B be its output
01:03:08 <wagle_> give me the biggest number you can think of..  i will beat you by adding one to it
01:03:10 <flux> wagle_, btw, regarding uniqueness types (which I only know a little about, so feel fee to correct), copying versus mutating is an implementation detail in the sense that it still guarantees that nothing has a reference to an expired element
01:03:52 <bparkis> say that F performs sorting "in some sense" if there exists a function g from A to the set of all lists of integers, and a function h from B to the set of all lists of integers, such that if F(A) = B then h(B) is the sorted version of g(A)
01:03:54 <oerjan> bparkis: my intuition is that a lot of things _could_ be interpreted as sorting if you were perverse enough, so it is hard to define the boundary
01:03:56 <ac> hm, if you declare an instance on a type alias (defined with "type Foo = ...") you need to explicitly declare the type as the alias for it to work
01:04:22 <bparkis> can you find anything wrong with that definition?
01:04:23 <johnnowak> it's not an implementation detail if the spec guarantees it
01:05:09 <sarehu> bparkis: use rationals instead of integers
01:05:22 <bparkis> rationals can be represented as integers
01:05:32 <sarehu> bparkis: actually, never mind
01:05:46 <flux> johnnowak, specification can't dictate implementation details?-)
01:06:01 <wagle_> copying is O(n),,  mutating is O(1)
01:06:03 <oerjan> bparkis: i think with that definition almost any F would be sorting
01:06:10 <johnnowak> flux: eh?
01:06:12 <sclv> hmm... solved the issues i think. unsafeInterleave + lazy evaluation + processes + buffers = massive confusing pain.
01:06:43 <sclv> I've sort of sprinkled evaluates and hFlush stdouts until somehow it works... bleh.
01:07:03 <bparkis> you're right oerjan, for instance of h(x) = g(x) = [1] for any x
01:07:23 <bparkis> so let's add the additional restriction that g and h must have infinite range
01:07:43 <sarehu> you could make any 1-1 function a sorting function still
01:08:02 <bparkis> how would you make the function f(x) = x a sorting function then?
01:09:06 <bparkis> well, I guess you could have h and g map any integer to the list containing that integer
01:09:07 <sarehu> h(x) = g(x) = [some_enumeration_of(x)]
01:09:37 <wagle_> if i can prove uniqueness, i want to actually use that info..  (psst..  what good does uniqueness do if not to facilitate the mutate-in-place optimization?)
01:10:28 <bparkis> so somehow I want to impose a restriction that h and g must do "interesting" sorting
01:10:40 <bd_> wagle_: you can implement IO without monads using uniqueness types
01:10:41 * wagle_ rereads
01:10:50 <bd_> by threading a unique 'world' type through all IO actions, for example
01:10:54 <sarehu> bparkis: what would count as 'interesting' sorting?
01:11:06 <wagle_> bd_, ah..  makes sense
01:11:10 <sarehu> would bubbling up values in a tree count as sorting?
01:11:21 <sclv> aand... no i haven't solved it.
01:11:37 <bparkis> ok let me change h and g... instead of mapping to arbitrary integer sequences, they must map to permutations of the integers 1...n for some n
01:11:38 <sclv> using System.Process seems to leave zombie sh instances around. anyone else run into this?
01:11:55 <bparkis> the n is not fixed
01:12:02 <wagle_> isnt the world type a sort of monad?
01:12:15 <sclv> i.e. the processes they were used to spawn are all terminated, but my ps gives me lots of little (sh) instances still.
01:12:27 <sclv> this is using runInteractiveCommand
01:12:36 <sarehu> bparkis:  i'd go this way:
01:12:53 <wagle_> sclv, ick
01:13:43 <sarehu> let g map from A onto sequences of rationals
01:13:45 <bparkis> let me sum up:  F :: A -> B performs sorting "in some sense" if there exist two functions g :: A -> C and h:: B -> C where C is the set of permutations of 1...n for some n, such that f(x) = y implies h(y) == sort(g(x))
01:13:54 <oerjan> wagle_: no.  it is like the state of a monad
01:14:00 <oerjan> @src IO
01:14:00 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
01:14:00 <sarehu> and stipulate that g is 1 to 1
01:14:23 <wagle_> whats the language that does uniqueness types again?
01:14:23 <sarehu> and do the same for h
01:14:31 <sarehu> I would expect a sorting algorithm to have type A -> A
01:14:42 <oerjan> wagle_: this is what ghc does under the hood.  however because of the uniqueness types, in Clean you can expose the RealWorld token publically
01:14:46 <sarehu> (at least say the range is a subset of the domain)
01:14:48 <bparkis> no I'm saying sorting "in some sense"
01:15:05 <bparkis> I will still consider it sorting if it takes lists and produces sorted arrays, for instance
01:15:07 <erg0t> hi :)
01:15:12 <wagle_> ah, it was clean i was trying to remember
01:15:42 <wagle_> oerjan, but you cant tell when ghc finds a uniqueness?
01:16:00 <bparkis> actually I see a further error in my definition now, because you could say f(x) = x does sorting when g(x) = 1...x = h(x)
01:16:19 <sarehu> you need to specify that g(x) is 1-1
01:16:21 <oerjan> wagle_: ghc forces uniqueness by not exposing anything but the monadic combinators for this state monad
01:16:27 <sarehu> and the same for h(x)
01:16:34 <bparkis> g(x) need not be 1-1
01:16:51 <oerjan> unsafePerformIO breaks this
01:16:54 <sarehu> it would be simpler if you specified g(x) is 1-1, and mapped onto sequences of rationals
01:17:04 <bparkis> F could sort, say, "either arrays or lists" and then an array would be mapped to the same thing that its corresponding list would be
01:17:12 <bparkis> I think rather that g(x) must be onto
01:17:31 <oerjan> as does unsafeInterleaveIO - the former creates a RealWorld token out of thin air, the latter duplicates one, i think
01:18:01 <bparkis> F :: A -> B performs sorting "in some sense" if there exist two functions g :: A -> C and h:: B -> C (where C is the set of permutations of 1...n for some n) such that f(x) = y implies h(y) == sort(g(x)), and g is onto
01:18:36 <sclv> heck with it. i'm turning in for the night and going straight to the System.Posix.Process API in the morning.
01:18:55 <sarehu> have h(y) = 1...n forall y
01:18:59 <sclv> oh, and then writing a little note to libraries...
01:19:22 <bparkis> yes sarehu that's true (where n = length(y)) but i don't need to say it, it's a theorem
01:19:47 <sarehu> no, i mean simply have h return 1...n for all elements of B
01:19:59 <sarehu> then anything is trivially satisfactory
01:20:05 <bparkis> n depends on the element of B
01:20:15 <sarehu> oh?
01:20:24 <sarehu> then have n = 1 for all elements of B
01:20:25 <bparkis> n is the length of the sequence
01:20:26 <sarehu> and A
01:20:32 <sarehu> or wait, onto
01:20:33 <wagle_> ... thanks all
01:20:35 <bparkis> and what would g be
01:21:07 <sarehu> the trouble is, you can still have h(y) == 1..length(y)
01:21:19 <bparkis> yes, h(y) is _always_ 1..length(y)
01:21:19 <sarehu> and then any operation on sequences that doesn't change the length becomes 'sorting'
01:21:36 <bparkis> well no
01:21:43 <bparkis> h(y) is always 1..length(y) for some definition of length
01:21:52 <sarehu> you can't allow that
01:21:56 <bparkis> I do allow it
01:21:57 <sarehu> then sorting by your definition is trivial
01:22:00 <bparkis> provide a counterexample
01:22:02 <bparkis> it's not trivial
01:22:05 <sarehu> yes it is
01:22:13 <sarehu> ok
01:22:15 <bparkis> a counterexample consists of a valid g, a valid h, and a "non-sorting" F
01:22:17 <sarehu> let's let f map lists to arrays
01:22:24 <bparkis> remember g must be onto
01:22:27 <sarehu> where f is the direct translation of a list into an array in the same order
01:22:37 <bparkis> and what is g
01:22:39 <sarehu> then have g map from a list to the corresponding permutation.
01:22:49 <sarehu> and have h map from the array to (1 .. length of the array)
01:24:04 <bparkis> hmm, I see your point
01:24:16 <bparkis> the problem is that h is doing the sorting
01:24:22 <bparkis> so h needs to be onto as well, as you said earlier
01:24:40 <bparkis> F :: A -> B performs sorting "in some sense" if there exist two functions g :: A -> C and h:: B -> C (where C is the set of permutations of 1...n for some n) such that f(x) = y implies h(y) == sort(g(x)), and g is onto and h is onto
01:25:05 <sarehu> have h :: B -> A be a one to one function from B onto A.  then g(h(f(x))) == sorted(g(x))
01:25:11 <paczesiowa> @src liftM2
01:25:11 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
01:25:20 <bparkis> no h can't be 1-1
01:25:25 <sarehu> from B -> A
01:25:30 <bparkis> it has to be onto but not necessarily 1-1
01:25:54 <sarehu> h :: B -> A
01:25:59 <bparkis> because what if F outputs a type D, where D is "either a list or an array"
01:26:21 <bparkis> then h would be D -> (permutations of 1..n for some n)
01:26:22 <sarehu> the inverse of a function is always 1-to-many
01:26:30 <sarehu> so let h pick one of the many
01:26:32 <bparkis> and it would have to map the array 1, 2, 3 to the same thing as the list 1, 2, 3
01:26:53 <bparkis> there's no need for h to be 1-1 but it does need to be onto
01:27:27 <sarehu> no, i changed the type of h
01:28:09 <sarehu> the trouble is that you need some kind of iso or  maybe homo-morphism between A and B
01:28:23 <bparkis> i don't think what you're saying makes sense
01:28:30 <sarehu> otherwise, you can just declare everything in B to be sorted
01:28:43 <bparkis> can you provide a counterexample for my amended definition?
01:28:56 <sarehu> the one where all you added was that h be onto?
01:28:59 <bparkis> yeah
01:29:57 <sarehu> let A be lists of integers, B be arrays of integers
01:30:26 <sarehu> let f(A) be the direct translation of (0:A) into an array
01:30:48 <sarehu> let h(x) be 1..(length x - 1) if the x begins with a 0
01:31:24 <sarehu> and let h(x) be x[1]..x[n] if x[0] is 1
01:31:30 <sarehu> or any non-zero value
01:32:15 <bparkis> and g(x)?
01:32:35 <sarehu> g(x) is the straight translation of a list into the corresponding permutatino
01:32:56 <sarehu> oh, h(x) translates the permutation of x[1]..x[n], not the actual values, of course
01:33:49 <sarehu> here's what I think about sorting
01:34:24 <sarehu> considering just the A->A case atm
01:34:40 <sarehu> if f is a sorting algorithm, f . f = f
01:35:13 <sarehu> ^ that's pretty much all I can say
01:35:39 <wagle_> how about unstable sorts?
01:35:42 <bparkis> id isn't a sorting algorithm
01:36:31 <sarehu> id is a sorting algorithm if A is the set of sorted lists
01:37:17 <znutar> id's a sorting algorithm where the sorting criteria always succeeds, no?
01:37:21 <bparkis> ok but that's too trivial, you wouldn't say it was really doing any sorting
01:37:33 <sarehu> right, just a projection, or canonicalization, or whatever
01:38:05 <oerjan> id itself is trivial, thus even if the sorting part is trivial, it can be all of it...
01:38:10 <sarehu> if you have some notion of length, maybe   length . f = length
01:38:41 <bparkis> that's too trivial, f should have to be somehow interpreted as sorting arbitrary "lists" for some representation of lists
01:38:57 <sarehu> sure
01:39:39 <sarehu> so I'd also add a 1-1 mapping from A into the set of finite sequences of rational numbers
01:39:46 <sarehu> call it g
01:40:00 <sarehu> and then g . f = sort . g
01:40:46 <bparkis> wait a minute I'm still thinking about your counterexample, maybe I'm slow but what do you do if a list in A has repeated elements
01:40:59 <bparkis> then h(x) would not be valid
01:41:07 <bparkis> actually that would be if a list in B has repeated elts
01:41:22 <ac> there isn't any way to turn an enum in to a string is there (for error messages, and whatnot)?
01:41:37 <bparkis> you would define it, probably, to be 1...n
01:41:40 <sarehu> ac: show
01:41:46 <bparkis> that is h(x) = 1...n in case x has repeated elements
01:41:47 <sarehu> > show True
01:41:47 <ac> oh :-P
01:41:48 <lambdabot>  "True"
01:41:50 <bparkis> and the same for g(x)
01:42:22 <sarehu> bparkis: good point... ok, have h(x) do the sorting then when x[0] = 0
01:42:22 <oerjan> ac: make it a Show instance as well
01:43:11 <bparkis> no I think the problem is deeper than that, you can't sort if there are repeated elements
01:43:37 <bparkis> since my set C only consists of permutations
01:43:41 <sarehu> [1,2,3,3] is not a sorted form of [3,2,1,3]?
01:43:43 <ac> oerjan: yeah it already is, I just forgot about show momentarily
01:43:45 <sarehu> oh, true
01:43:45 <Tac-Tics> Is it true, in Category Theory, that f . x = f . y => x = y?
01:43:58 <sarehu> bparkis: make it monotonic with jumps of 0 or 1
01:44:01 <bparkis> not by my definition since 1,2,3,3, is not a permutation
01:44:12 <sarehu> or wait, no
01:44:13 <vincenz> Tac-Tics: only if f is injective
01:44:15 <bparkis> permutations can only have one of each number
01:44:24 <sarehu> make it a multipermutation :P
01:44:28 <Tac-Tics> Bah, yeah....
01:44:38 <oerjan> Tac-Tics: such an f is called "monic"
01:44:45 <bparkis> is that a real word?
01:44:51 <sarehu> I don't think so
01:45:07 <wagle_> vincenz, how the heck do you remember which side is injective, and which is surjective?
01:45:09 <sarehu> call it an 'ordering'
01:45:17 <vincenz> wagle_: dunno?
01:45:22 <oerjan> (and x . f = y . f => x = y is called "epic")
01:45:25 <bparkis> ok how about instead of permutation i say "list of integers with a jump of no more than 1"
01:45:42 <bparkis> so like, 5 2 3 would have a jump of 2
01:45:44 <mgsloan> I'm trying to compile pcre-light, and getting stuff like:
01:45:52 <bparkis> also with smallest element 1
01:45:52 <vincenz> oerjan: epic for functions == surjective?
01:45:57 <mgsloan> Base.hsc:401: error: ‘PCRE_ANCHORED’ undeclared (first use in this function)
01:45:58 <Tac-Tics> I'm having an issue with this problem involving products, and after days of scratching my head, I've narrowed it down to me not knowing that <f . h, g . h> = <f, g> . h   ... which is nice and all, but I can't figure out the proof for that
01:45:58 <sarehu> bparkis: well g can map to big jumps, i was wrong
01:46:00 <ac> hum... how would I indent: if False == case blah of .... big case with many lines ... then ... ?
01:46:27 <sarehu> bparkis: how about, the n-ary cartesian product of {1,...,m}, m <= n
01:46:34 <mgsloan> the issue is probably that it can't find pcre.h..
01:46:44 <oerjan> vincenz: yep
01:46:44 <bparkis> F :: A -> B performs sorting "in some sense" if there exist two functions g :: A -> C and h:: B -> C (where C is the set of permutations of monotonic non-decreasing integer sequences beginning with 1) such that f(x) = y implies h(y) == sort(g(x)), and g is onto and h is onto
01:46:58 <Tac-Tics> So either projection functions are monic, or I'm back to square one
01:47:00 <sarehu> g doesn't need to map to C
01:47:12 <bparkis> er no wait
01:47:13 <sarehu> then g is already mapping to sorted sets the way you are going
01:47:49 <bparkis> if g only mapped to sorted sets, it couldn't be onto
01:48:20 <sarehu> let C be { {1,...,m}^n | m <= n, n \in N }
01:48:23 <sclv> aand.. posix solves it!
01:48:32 <sarehu> er, not quite -- ignore that
01:48:42 <sclv> runInteractiveProcess is borked anyway. it seems like a perl or php type concept.
01:49:13 <wagle_> sclv, gratz!
01:49:25 <sarehu> bparkis: but anyway you know what you mean.. but no matter what, you can have h do the sorting
01:50:12 <bparkis> however the way you set it up before, you had h do the sorting only because f wasn't onto
01:50:18 <ac> oh, I was missing an else
01:50:23 <bparkis> wait a second no that would always be the case
01:50:24 <oerjan> Tac-Tics: hm, i think they are epic actually... \(x,y) -> x is definitely not injective
01:51:18 <bparkis> what were you saying about h being B -> A
01:51:21 <oerjan> Tac-Tics: your equation should be right, maybe you can show that <f, g> . h fulfils the universal property for <f . h, g . h> ?
01:51:21 <Tac-Tics> bah
01:51:31 <bparkis> that sounds somewhat promising now
01:51:36 <sarehu> bparkis: I was really trying to avoid the problem of A->B altogether and force it to have A->A somewhere
01:51:42 <Cin> ooo darcs. video
01:51:44 * Cin downloads
01:51:47 <sarehu> here's an example of a sorting algorithm
01:51:53 <Tac-Tics> I haven't learned about universal properties
01:51:55 <sarehu> that maps continuous functions to continuous functions
01:52:26 <bparkis> sorting is ill defined in that case
01:52:35 <sarehu> continous, differentiable functinos
01:52:39 <bparkis> you can't sort a polynomial function
01:52:39 <oerjan> Tac-Tics: the thing is that <f, g> is the _only_ morphism such that p1 . <f, g> = f and p2 . <f, g> = g
01:52:49 <sarehu> on an interval [a,b]
01:53:00 <oerjan> (assuming i understand your notation right)
01:53:07 <bparkis> ok
01:53:22 <sarehu> let f(a) = the minimum, f(b) = the maximum
01:53:23 <Tac-Tics> oerjan: ah, I don't think I've considered <f, g>'s uniqueness
01:53:54 <bparkis> what are a and b
01:54:04 <sarehu> let me think about this
01:54:05 <bparkis> they can't be arguments to f if they are endpoints
01:54:08 <sarehu> arbitrary end points
01:54:14 <bparkis> because f takes functions
01:54:16 <sarehu> they are in the range [a,b]
01:54:32 <bparkis> f takes continuous differentiable functions, not points on the number line
01:54:44 <sarehu> er, i'm using f as in f = sort(some continuous function)
01:55:00 <sarehu> use s then... s = sort(some continuous function)
01:55:02 <bparkis> oh ok
01:56:15 <wagle_> isnt the answer the line segment from min(f) to max(f) on the domain of f?
01:56:49 <bparkis> you want to have f(x) = y iff the sum of all intervals where the input function g is greater than x, is y
01:57:11 <bparkis> er, you want to have f(x) = y+a iff the sum of all intervals where the input function g is greater than x, is y
01:57:20 <sarehu> let s'(x) = 1/|S| * sum over all x in S of { |s'(x)| }, where S = { x | s(x) = y } -- except if there was any flat line at y, in which case it takes on the length of the flat line
01:57:43 <sarehu> the first pair of braces is supposed to be parentheses
01:57:47 <sarehu> i was thinking in latex
01:58:28 <bparkis> what is s(x), the input function?
01:58:36 <sarehu> s(x) = the sorted version
01:58:40 <sarehu> a monotonic function
01:58:54 <bparkis> you said f was the sorted version since you said f(a) = minimum f(b) = maximum
01:58:56 <sarehu> er, sorry, s/s(x) = y/unsorted(x) = y/
01:59:05 <sarehu> then i said ok, let's use s as the sorted version
01:59:27 <bparkis> oh i see, skippe it
01:59:30 <wagle_> s(f) is a continuous function?
01:59:30 <bparkis> d
01:59:44 <sarehu> it's monotonically increasing and continuous
01:59:55 <sarehu> there might be some pathological cases where that doesn't work
02:00:28 <bparkis> and what is s'(x), the derivative of s, or the unsorted function?
02:00:34 <sarehu> the derivative of s
02:00:51 <bparkis> what is the sorted function?
02:00:53 <sarehu> er, sorry
02:00:54 <sarehu> that was dumb
02:00:56 <bparkis> i mean what is the unsorted function
02:00:57 <sarehu> let me rephrase
02:01:09 <sarehu> let u be a continuously differentiable function
02:01:34 <sarehu> then let s be a function where
02:02:44 <Tac-Tics> yeah, that did it. Uniqueness is pretty important, and I missed that point
02:02:55 <bparkis> well, if your point is that definitions like mine using permutations of the integers are insufficient for "sorts" of continuous functions, you're right
02:02:56 <oerjan> :)
02:03:06 <ac> so did anybody read the paper about Typed Scheme from LTU that introduced occurrence typing?
02:03:15 <bparkis> but let's see if we can get the discrete case before getting the continuous case
02:03:18 <sarehu> if s(x) = y, and if there are no intervals where u is constant and equal to y, then s'(x) = the average of the absolute slopes of u(x) where u(x) = y
02:03:35 <sarehu> and if there are intervals where u is constant and equal to y, s is flat for the length of those intervals
02:03:46 <bparkis> sarehu did you notice I said something about it
02:04:06 <sarehu> well, the set of continuous functions on [a,b] is countable
02:04:21 <bparkis> you want to have s(x) = y+a iff the sum of all intervals where the input function g is greater than x, is y
02:04:23 <sarehu> er, no
02:04:24 <sarehu> moron me
02:04:25 <sarehu> sorry
02:05:01 <wagle_> what function is sort (x^3+x^2)?
02:05:23 <bparkis> let's say on the interval 0, 1 to be simple wagle_
02:05:25 <sarehu> wagle_: over what interval is this defined?  I only want to worry about finite intervals for now
02:05:28 <sarehu> ok, [0,1]
02:05:40 <sarehu> that function is already sorted
02:05:52 <bparkis> yeah
02:05:53 <sarehu> since it's monotonically increasing on [0,1]
02:06:20 <wagle_> [-1,1] looks good
02:07:00 <bparkis> you want to have s(x) = y+a iff the sum of all intervals where the input function g is LESS than x, is y
02:07:18 <bparkis> [-1,1] is unduly complicated
02:07:43 <bparkis> let's sort (x^2 -x^3) on [0, 1]
02:07:50 <sarehu> wagle: we'd have s(-1)= 0, s(1)=1, s'(-1) = 1/2
02:08:25 <wagle_> really?  its practically the nicest non-monotonic differentiable continuous function you can have on [-1.1]?
02:08:48 <sarehu> besides 1-x^2
02:08:59 <bparkis> yeah it's just the -1 makes it hard
02:09:05 <bparkis> so i'm moving the left endpoint to 0 for simplicity
02:09:11 <sarehu> ok how about 1-x^2 on [-1,1]
02:09:15 <bparkis> (x^2-x^3) is not monotonic on [0, 1]
02:09:19 <sarehu> it starts off at (-1,0) with slop 1
02:09:22 <oerjan> don't make your functions unduly undulating, folks
02:09:40 <bparkis> i'm not going to mess around with left endpoints at -1
02:10:02 <wagle_> ok..  -x^3 + x^2 undulates one less time
02:10:21 <sarehu> it would be a parabola with vertex at (1,1)
02:10:30 <sarehu> 1-x^2's sort, that is
02:11:02 <sarehu> 1-((x-1)^2/2)
02:11:20 <ac> wasn't somebody in here saying earlier that there's a better way to construct arrays than building them from a list using array?
02:11:57 <bparkis> so (x^3 - x^2) has a peak at 2/3, and it goes to 0 at either endpoint
02:12:50 <bparkis> and we want to have f(x) = y iff g(x) > x over a distance of  y
02:13:01 <sarehu> so now just invert y=x^3-x^2 and you have a nice solveable differential equation :)
02:13:01 <bparkis> composed of the left half and the right half
02:13:44 <oerjan> ac: don't know, seems O(n) to me anyhow?  maybe listArray is more concise some times?
02:14:12 <ac> oerjan: yeah I typically use listArray. I think there's a way to do it in the same time that malloc would take
02:14:21 <ac> but I guess that would have an IO type, as the initial contents of the memory are not known
02:14:22 <bparkis> however I'd have to be able to invert the function x^2-x^3 piecewise
02:14:34 <sarehu> it's doable
02:14:43 <bparkis> is that invertible?
02:14:47 <sarehu> use the cubic formula
02:14:56 <bparkis> I don't know it
02:15:17 <sarehu> yeah, so you could look it up, find the two terms that lie on the interval...
02:15:47 <bparkis> yeah and sum the distance to the left of the left point, and to the right of the right point
02:15:49 <sarehu> then find the x values for the particular y value, average their derivatives
02:15:51 <bparkis> and plot that point
02:16:06 <bparkis> no not average derivatives
02:16:12 <sarehu> that's how the sort works
02:16:16 <bparkis> that's what you say
02:16:26 <sarehu> yep :P
02:16:27 <bparkis> i don't think that works
02:16:30 <sarehu> and I say i'm going to sleep
02:16:41 <bparkis> because how a sort works normally
02:17:03 <sarehu> my sort works the way a sort would work normally
02:17:20 <roconnor> oooh, what are we talking about?
02:17:24 * roconnor joins in
02:17:25 <sarehu> values 'linger' near a particular y value in an equal amount as they did in the original continuous function
02:17:46 <sarehu> and s(a) <= s(b) iff a <= b
02:18:14 <sarehu> which is the same for sorting functions on discrete, finite domains
02:18:15 <bparkis> you want to have s[x] = y iff the sum of all positions where the input function g is less than y, is x-1
02:18:22 <bparkis> that's for an array
02:18:46 <bparkis> so for a continuous function you want to have s(x) = y iff the sum of all interval lengths of intervals where the input function g is less than y, is x
02:19:04 <sarehu> our definitions are equivalent
02:19:55 <bparkis> ok i'm not going to try to prove you otherwise ;p
02:20:05 <wagle_> what is the inversion of x^3-x^2?
02:20:14 <sarehu> use the cubic formula for local inverses
02:20:53 <bparkis> which is fiendishly complicated
02:21:19 <bparkis> sarehu: did you sort your other function, the one that was quadratic
02:21:32 <bparkis> what was that
02:21:33 <sarehu> the 1-x^2 one?  yeah
02:21:41 <sarehu> 1-((x-1)^2/2)
02:21:50 <bparkis> over what interval
02:21:54 <sarehu> [-1,1]
02:22:00 <wagle_> @google "cubic formula" for "local inverses"
02:22:00 <lambdabot> No Result Found.
02:22:04 <bparkis> ok i'll try that
02:22:08 <wagle_> 8-p
02:22:47 <bparkis> wagle_ you would solve the equation x^2 - x^3 - y = 0 using the cubic formula
02:22:56 <sarehu> for that one you don't even need any math
02:22:56 <ac> who was working on bindings for the freeimage library?
02:23:18 <bparkis> wait sarehu if you aren't doing that using your method then it's no use
02:23:27 <sarehu> bparkis: what?
02:23:33 <sarehu> i did do it using my method
02:23:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5430
02:23:38 <bparkis> ok
02:23:41 <bparkis> i'll try it then using mine
02:23:58 <sarehu> it's just that you can take advantage of symmetry
02:24:52 <sarehu> for any function on [a,b] that's symmetric over (a+b)/2, your sort will just be [a,(a+b)/2] stretched horizontally to cover [a,b]
02:25:21 <sarehu> well I need to get some sleep
02:28:04 <bparkis> sarehu:
02:28:16 <bparkis> my method gets 1 - ((1 - x)^2/4)
02:28:36 <bparkis> a /4 instead of /2
02:28:53 <bparkis> oh wait that's not right either
02:30:14 <bparkis> missed the offset
02:31:46 <bparkis> 1 - x^2/4
02:32:23 <sarehu> that's not 0 when you plug in -1
02:32:33 <sarehu> and it's not 1 when you plug in 1
02:33:04 <bparkis> ohh i missed a 2
02:33:12 <bparkis> yeah what i said before was right
02:33:19 <bparkis> 1 - ((1 - x)^2/4)
02:33:35 <sarehu> yeah, that's right
02:33:38 <sarehu> my /2 was wrong
02:33:53 <bparkis> is it what your method gets?
02:34:56 <sarehu> I meant ((1-x)/2)^2
02:35:05 <sarehu> that does a horizontal scaling of 2
02:35:34 <bparkis> my method, you invert it and get x = +/- sqrt(1-y), then the total distance where the function is greater than y is 2 - 2 * sqrt(1-y), and set that equal to xnew + 1, and solve for xnew
02:35:44 <sarehu> of course I mean 1-((1-x)/2)^2
02:35:44 <bparkis> er, LESS than y
02:35:56 <bparkis> sarehu: but does your _method_ get you there?
02:36:27 <sarehu> my method is just taking the derivative of your method
02:36:29 <sarehu> and integrating
02:36:50 <Tac-Tics> and indeed, projection functions are pretty trivially epimorphic.... It's like math people have superpowers over the obscure but logical. Figuring out that problem took me about a week >__>
02:36:56 <bparkis> I just don't see how derivatives relate to this stuff
02:37:08 <bparkis> I mean you could sort a discontinuous function with my  method
02:37:36 <Tac-Tics> (but it would have been nice if they would have just used the word "epimorphism" in the definition of a product in the first place. Woulda saved me some time)
02:37:47 <sarehu> bparkis: let A(y) be the length of the intervals where u(x) < y
02:38:21 <wagle_> sort(x^3-x^2) =  1-((1-x)/2)^2  ?
02:38:40 <bparkis> no wagle sort(1-x^2) = 1-(1-x)^2/4
02:38:41 <sarehu> no wagle that's sort(1-x^2) = 1-((1-x)/2)^2
02:38:47 <bparkis> over [-1,1]
02:38:59 <sarehu> bparkis: what's A'(y)?
02:39:15 <Tac-Tics> The use of the word "injective functions" in the definition of a coproduct is a good tip... sigh, if I would have just read on, I would have probably figured that out quicker...
02:39:23 <sarehu> it's sum (1/u'(x)) over all x where u(x) = y
02:40:36 <bparkis> ok
02:40:52 <sarehu> and A^-1 is s
02:41:21 <bparkis>  that works
02:41:54 <wagle_> 1-x^2 isnt monotonic over [-1,1]
02:42:04 <wagle_> duh, nm
02:42:19 <bparkis> well, back to the original thing, let's relax it a bit and say f is A -> A
02:43:00 <wagle_> ok, i see now..  thanks
02:43:02 <bparkis> f :: A -> A performs sorting "in some sense" if there exist two functions g :: A -> C and h:: A -> C (where C is the set of permutations of monotonic non-decreasing integer sequences with jumps of no more than 1, beginning with 1) such that f(x) = y implies h(y) == sort(g(x)), and g is onto and h is onto
02:43:24 <sarehu> no
02:43:25 <bparkis> in fact, we don't want two functions in that case
02:43:29 <sarehu> g is mapping onto sorted sequences there
02:43:36 <sarehu> and yeah
02:43:52 <bparkis> F :: A -> B performs sorting "in some sense" if there exist a function g :: A -> C (where C is the set of permutations of monotonic non-decreasing integer sequences beginning with 1) such that f(x) = y implies h(y) == sort(g(x)), and g is onto
02:44:09 <bparkis> no g is mapping to PERMUTATIONS of sorted sequences
02:44:23 <sarehu>  you mean F :: A -> A
02:44:35 <sarehu> see, I would go with this
02:44:36 <bparkis> ah right, pasted from the wrong place
02:45:02 <bparkis> f :: A -> A performs sorting "in some sense" if there exist a functions g :: A -> C (where C is the set of permutations of monotonic non-decreasing integer sequences with jumps of no more than 1, beginning with 1) such that f(x) = y implies g(y) == sort(g(x)), and g is onto
02:46:01 <Tac-Tics> @pl \x -> (f x, g x)
02:46:01 <lambdabot> liftM2 (,) f g
02:46:04 <sarehu> f :: A -> A, g :: A -> C, where C is the set of finite sequences of rationals, and g is 1-1.  Then g . f = sort . g
02:46:24 <sarehu> and for extra strength, define a concat operation on A and the customary one on C.
02:47:18 <sarehu> then g (f (x ++ y)) = sort (g (x ++ y))
02:47:22 <sarehu> forget the customary one on C
02:47:33 <sarehu> er, don't
02:47:38 <bparkis> the 1-1 requirement is bad because you could have more than one representation of a given sequence
02:47:40 <sarehu> stipulate that g (x ++ y) = g x ++ g y
02:48:05 <sarehu> I don't think so
02:48:23 <sarehu> if you're worried about that, fix your equivalence definitino
02:48:28 <bparkis> what if f sorts the tails of lists of integers
02:48:37 <bparkis> ignoring the head
02:48:45 <bparkis> that's still sorting
02:49:10 <notpalomer> hello!
02:49:30 <notpalomer> I'd like to ask to get unbanned (and I also have a gtk2hs question)
02:49:38 <bparkis> but if your g is 1-1 then you couldn't map [1, 0, 2] to the same thing as [3, 0, 2] and you should
02:50:32 <notpalomer> I can't give any input to text entries which I place in popup windows, here's the testcase:
02:51:04 <hpaste>  notpalomer pasted "unable to input into my text entry" at http://hpaste.org/5431
02:51:16 <sarehu> i would not say that f is sorting in that case
02:51:59 <sarehu> you could go very far in that direction, getting all sorts of obcure things called sorting
02:52:21 <bparkis> well, I certainly would--what if A is a type of "integer lists or integer arrays"
02:52:31 <bparkis> then every sequence would have 2 identical representations
02:52:42 <bparkis> well, 2 different representations for the same sequence
02:52:49 <sarehu> if you ignore the concatenation part
02:52:51 <sarehu> my definition works fine
02:52:55 <sarehu> for both your cases
02:53:25 <bparkis> it would be natural to have g map the list 1, 2, 3 to the same thing it maps the array 1, 2, 3 to
02:53:30 <bparkis> but if g is 1-1 then you can't do that
02:53:32 <sarehu> no, don't
02:53:38 <bparkis> how would you do it
02:53:53 <bparkis> some kind of even/odd encoding?
02:54:32 <sarehu> take whatever mapping you _wolud_ have used, and factor the denominators, and replace all the primes with the second greater prime, and then add a 2 or 3 to indicate list vs array
02:56:17 <bparkis> however what if g maps the list 3, 1, 2 to the array 1, 2, 3
02:56:23 <bparkis> that's still sorting
02:57:05 <sarehu> ok
02:57:09 <sarehu> instead of what I said
02:57:35 <bparkis> er not g, i meant f
02:57:36 <bparkis> i'm so tired
02:57:42 <sarehu> take whatever encoding you would have used, ignoring list vs array
02:57:56 <sarehu> and add two values, the greatest two integers less than all your values
02:58:01 <sarehu> n and n-1
02:58:28 <sarehu> then have g prepend with n then n-1 in your sequence if it's a list, n-1 then n if it's an array
02:59:56 <sarehu> but if you ask me, sorting should involve some concatenation law
03:00:13 <bparkis> I don't see how that solves the problem, but as I said I'm pretty tired
03:00:33 <bparkis> but no, the way I'm talking about you don't even know how to formulate concatenation
03:00:38 <sarehu> concatenation laws get rid of all the contrived things that are really sorting+junk
03:00:49 <sarehu> right
03:00:51 <bparkis> you say "stipulate that g (x ++ y) = g x ++ g y" but you don't know how to concatenate x and y
03:00:56 <sarehu> you just have concatenation for rationals
03:00:58 <bparkis> they could be arbitrary representations of sequences
03:01:06 <sarehu> right
03:01:12 <bparkis> you can't say x ++ y because x and y could, for instance, be prime encodings of your sequence
03:01:28 <sarehu> and ++ concatenates them somehow
03:01:36 <bparkis> in an ill defined manner
03:01:38 <sarehu> ++ is not Data.List.++
03:01:59 <bparkis> well then you're adding a layer of complexity and if you ask me, what you said is a definition of ++, not of g
03:02:10 <bparkis> i.e. x ++ y is defined such that g (x ++ y) = g x ++ g y
03:02:18 <sarehu> as long as it obeys g (x ++ y) = g x ++ g y it's fine by me
03:02:26 <bparkis> that's not a restriction on g
03:02:31 <bparkis> it's a restriction on ++
03:02:54 <sarehu> well, both with respect to one another
03:03:12 <bparkis> and why introduce a notion of concatenation of the input types at all
03:03:52 <sarehu> well i'm basically saying it's gotta be ____morphic to the set of finite sequneces of rationals
03:03:58 <sarehu> ^^ fill in the right morphism there
03:04:42 <sarehu> the kind that's 1-1 and into
03:04:43 <bparkis> you're saying g should be a homomorphism from the input type over some mysterious ++, to rational sequences over their (different) ++
03:05:00 <sarehu> not homo, since that doesn't have to be 1-1
03:05:11 <sarehu> at least not with what i'm familiar with
03:05:17 <bparkis> well, it can be
03:05:24 <bparkis> isomorphism?
03:05:35 <notpalomer> so, erm, does anyone have any opinions on my problem?
03:06:01 <wagle_> if we sort 1-x^2 on the interval [-1,0.75], we find that the duplication(crossing?) count changes from 1 to from [-1.-0.75] to 2 from [-0.75,+0.75]..  isnt that going to introduce a discontinuity in sort(1-x^2) at x=-0.75?
03:06:31 <sarehu> bparkis: a monomorphism, not in the category theory sense
03:07:39 <sarehu> wagle_: a discontinuity in the derivative
03:07:42 <bparkis> let's leave that aside
03:08:03 <bparkis> back to your latest solution to the 1-1 problem, which I haven't processed
03:08:20 <sarehu> i don't really care about that
03:08:37 <sarehu> i don't consider sorting the tail to be actual sorting
03:08:48 <bparkis> well I do and that's the whole point of what I'm saying
03:09:20 <bparkis> ie, what can be considered a function that does "sorting" somehow, given _any arbitrary representation_ for its input and output
03:09:28 <bparkis> what is the essence of sorting
03:09:39 <bparkis> regardless of representation
03:10:03 <bparkis> so in that context, more than one representation of the same sequence would certainly be allowed
03:10:05 <sarehu> sort . sort = sort      that's all
03:10:15 <bparkis> no because id doesn't do any sorting
03:10:20 <wagle_> not for unstable sort
03:10:33 <sarehu> wagle_: relative to the comparison function you used for sorting, then
03:11:11 <bparkis> now I also don't like restricting f to be A->A
03:11:24 <bparkis> because it should be able to output in a different format from which it inputs
03:11:58 <wagle_> shouldnt you compose f with format convertors then?
03:12:21 <Deewiant> Hmm, there's no "doesPathExist" function? I have to use something like \f -> liftM2 (||) (doesFileExist f) (doesDirectoryExist f)?
03:12:24 <bparkis> yes that's kind of what we've been talking about
03:12:33 <wagle_> why would you need the sort itself to change the format?
03:12:35 <bparkis> adding functions to convert the inputs and outputs to "canonical" sequences
03:12:56 <bparkis> no wagle_ the point is that the sort MIGHT change the format, and if it outputs in a different format it should still be considered a sort
03:13:33 <sarehu> heh Deewiant
03:13:49 <wagle_> bparkis, sure, the diagram commutes
03:14:46 <Deewiant> sarehu: well, I don't care about whether it's a file or a directory and that's all I can find :-P
03:16:02 <wagle_> bparkis, hmm..  maybe its a stable sort that works by everything to the key of the sort
03:16:29 <wagle_> ... adding everything ...
03:17:45 <wagle_> dont you need the inversion of the reformat function to tell if you really did sort?
03:18:25 <bparkis> sort of
03:18:28 <bparkis> you do need to know if you sorted
03:18:35 <bparkis> but i don't think you need to invert the reformat function
03:20:09 <wagle_> yeah, if f is a sort function, and g is 1-1 (?), then h = g . f is a sort function, but mostly because you imagine that there's an f there, sitting under the hood
03:21:12 <sarehu> ok, rule number 1:  if it takes o(n log n) time, it's not a sort function
03:22:02 <sarehu> if there's no implementations that can take O(n log n) time, it's not a sort function either
03:22:15 <wagle_> cardinality [0,1] = aleph 1..  n = aleph1?
03:22:19 <sarehu> if you look at it funny, it's not a sort function
03:22:30 <desegnis> Deewiant: well there is System.Posix.Files for tests à la test(1)
03:22:51 <bparkis> not necessarily for the second one sarehu
03:23:00 <bparkis> because what if data extraction is really hard
03:23:07 <Deewiant> desegnis: but that won't work on Windows, right
03:23:27 <bparkis> suppose that the sequence is encoded in powers of primes, so like a0, a1, a2, ... is encoded as 2^a0, 3^a1, 5^a2, ...
03:23:35 <sarehu> oh, like "factor this number and use it to decode and sort and reencode something"?
03:23:39 <bparkis> then dealing with that would take a lot more than n log n
03:24:13 <desegnis> Deewiant, yeah liftM2 (||) is probably the better choice
03:24:20 <bparkis> or not even with commas there
03:24:31 <bparkis> 2^a0 * 3^a1 * 5^a2
03:24:39 <Deewiant> desegnis: alright, thanks
03:33:03 <bparkis> basically, I want a function g that somehow "decodes" the input to f, and a function h that somehow "decodes" the output of f
03:33:24 <bparkis> and I want to restrict g and h to be sufficiently complicated that they make f do some "real sorting"
03:36:39 <bparkis> specifically, I want g to map to a great variety of sequences, so that f is forced to sort many sequences (unlike id)
03:38:13 <bparkis> and I want h to somehow "be honest" about whether the sequence is sorted, but that may be an impossible goal
03:39:05 <RayNbow> @check const == (\t f -> t)
03:39:07 <bparkis> in fact I'm pretty sure that it _is_ impossible
03:39:07 <lambdabot>   add an instance declaration for (Eq (a -> b -> a))     In the expression: c...
03:40:13 <wagle_> its been a while, so i dont remeber the specifics, but program verification has put a lot of thought into defining what the requirements of a sort function are
03:40:41 <bparkis> so I think that restricting the output type of f is the only way to go
03:40:54 <bparkis> either saying f :: A -> A, or saying f :: A-> B and putting some restrictions on B
03:41:50 <bparkis> like saying that there must be operations like head, tail that can be performed on B, and then you say that f sorts "with respect to" those operations
03:41:53 <wagle_> is f :: A -> () a sort function?
03:42:01 <bparkis> however this is still unsatisfying
03:42:05 <bparkis> prolly not wagle_
03:43:49 <wagle_> oh..  i'm suspecting that (g :: A -> B) . (f :: A -> A) is a sort function if f is a sort function and g is an isomorphism
03:45:21 <wagle_> nah..  B could be bigger than A
03:46:51 <wagle_> whats an isomorphism g from A to the image of g in B?
03:55:21 <vincenz> injective
03:55:30 <vincenz> monomorphic
03:55:38 <vincenz> monic
03:59:32 <nominolo> @seen mauke
03:59:32 <lambdabot> I saw mauke leaving #xmonad and #haskell 1d 17h 14m 35s ago, and .
03:59:35 <wagle_> i think that what is confusing is that A in F :: A -> A is something like a multiset
04:00:10 <wagle_> s/F/f/
04:02:24 <wagle_> no..  A is a set of index functions
04:04:02 <ac> so I'm writing a library that contains a function that returns an array. Rather than tie myself to a specific type of array, is there a way to let the library user decide? Would it simply be a matter of importing IArray as opposed to Array.Diff, Array.Unboxed, etc?
04:04:22 <wagle_> and image(f) is the subset of sorted index functions
04:04:29 * wagle_ goes to bed
04:06:03 <roconnor> @src Array
04:06:03 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:06:24 <roconnor> isn't there an array class of some kind?
04:07:51 <paolino> :t when
04:07:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:08:42 <roconnor> @src IArray
04:08:42 <lambdabot> Source not found. I feel much better now.
04:09:11 <roconnor> ac: there is the Data.Arra.IArray.IArray class.
04:09:32 <ac> roconnor: If I write a function that returns a type of IArray I get an ambiguous type error
04:10:37 <roconnor> ac: that doesn't seem right
04:10:41 <ac> guess I just have to explicitly give it a type of :: (Ix i, IArray a e) => (i, i) -> [e] -> a i e
04:10:48 <roconnor> @type array
04:10:49 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
04:10:52 <ac> or something like that
04:10:56 <roconnor> @type Data.Array.IArray.array
04:10:57 <lambdabot> forall i e (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (i, i) -> [(i, e)] -> a i e
04:11:47 <roconnor> @type Data.Array.IArray.listArray
04:11:47 <lambdabot> forall i e (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (i, i) -> [e] -> a i e
04:11:57 <roconnor> ac: you are reimplementing listArray?
04:13:04 <roconnor> oooh, haddock has links to source!
04:13:43 <nominolo> @instances Enum
04:13:44 <vincenz> @seen tibbe
04:13:44 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
04:13:44 <lambdabot> I saw tibbe leaving #darcs, #xmonad, #ghc and #haskell 2d 13h 9m 56s ago, and .
04:13:58 <notpalomer> are there any plans to change the gtk2hs liststore?
04:14:12 <nominolo> notpalomer: ask dcoutts
04:14:12 <lambdabot> nominolo: You have 1 new message. '/msg lambdabot @messages' to read it.
04:16:55 <ac> @instances Fractional
04:16:56 <lambdabot> Double, Float
04:17:08 <ac> @instances Show
04:17:09 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
04:17:42 <ac> roconnor: no of course not
04:18:10 <ac> roconnor: that was the wrong type
04:19:19 <ac> If I want to define a datatype with an IArray in it, I have to use existential types, right?
04:20:08 <nominolo> @instances Bounded
04:20:09 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
04:21:05 <ac> > maxBound :: (a, b, c)
04:21:06 <lambdabot>        add (Bounded a, Bounded b, Bounded c)
04:21:06 <lambdabot>       to the expected type of an...
04:21:27 <ac> > maxBound :: (Int,Int,Int)
04:21:28 <lambdabot>  (2147483647,2147483647,2147483647)
04:21:47 <ac> > maxBound (Word8,Word8,Word8,Word8)
04:21:47 <lambdabot>   Not in scope: data constructor `Word8'
04:22:04 <ac> > maxBound (Int,Int,Int,Int)
04:22:04 <lambdabot>   Not in scope: data constructor `Int'
04:22:17 <ac> > maxBound :: (Word8,Word8,Word8,Word8)
04:22:18 <lambdabot>  (255,255,255,255)
04:23:31 <nominolo> :t Ordering
04:23:32 <lambdabot> Not in scope: data constructor `Ordering'
04:23:50 <ac> @src Ordering
04:23:51 <lambdabot> data Ordering = LT | EQ | GT
04:24:08 <nominolo> > maxBound :: All Bool
04:24:09 <lambdabot>      Kind error: `All' is applied to too many type arguments
04:24:09 <lambdabot>     In the type ...
04:24:18 <nominolo> @src All
04:24:18 <lambdabot> Source not found. Sorry.
04:24:45 <nominolo> > maxBound :: All
04:24:46 <lambdabot>  All {getAll = True}
04:24:50 <ac> what is "All"?
04:25:08 <nominolo> "Boolean monoid under conjunction."
04:25:35 <pjd> > getAll $ mconcat $ All <$> [True, True True]
04:25:36 <lambdabot>  Couldn't match expected type `Bool -> Bool'
04:25:46 <pjd> > getAll $ mconcat $ (All <$> [True, True True])
04:25:46 <lambdabot>  Couldn't match expected type `Bool -> Bool'
04:25:51 <pjd> eh
04:26:01 <pjd> how does that go again
04:26:22 <desegnis> @src All mappend
04:26:22 <lambdabot> Source not found. It can only be attributed to human error.
04:26:41 <nominolo> :t All True
04:26:42 <lambdabot> All
04:26:46 <desegnis> bah
04:27:14 <nominolo> > map All [True, False]
04:27:15 <lambdabot>  [All {getAll = True},All {getAll = False}]
04:27:27 <nominolo> > getAll $ mconcat $ map All [True, False]
04:27:27 <lambdabot>  False
04:28:01 <resiak> what does that give you over all :: [Bool] -> Bool ?=#
04:28:19 <nominolo> it's more general (by reusing mconcat)
04:28:20 <ac> > minBound :: All
04:28:21 <lambdabot>  All {getAll = False}
04:28:44 * pjd thwaps forehead
04:28:46 <pjd> missing comma
04:28:47 <faxathisia> > [minBound..maxBound] :: [All]
04:28:48 <lambdabot>   add an instance declaration for (Enum All)
04:28:48 <lambdabot>     In the expression: [minBound...
04:28:52 <pjd> > getAll $ mconcat $ All <$> [True, True, True]
04:28:52 <lambdabot>  True
04:29:10 <pjd> > getAny $ mconcat $ Any <$> [False, True, False]
04:29:11 <lambdabot>  True
04:29:18 <ac> ah cool
04:29:52 <nominolo> mappend should really be + with a circle around, and mconcat some form of big sigma
04:29:57 <ac> why not...
04:30:11 <ac> > all id [True, True, True]
04:30:11 <lambdabot>  True
04:30:17 <ac> > all id [True, True, False]
04:30:18 <lambdabot>  False
04:30:24 <resiak> oh wow, so Endo provides foldr (.) id ::  [a->a] -> (a->a)
04:31:04 * nominolo forgot what an endomorphism was
04:31:52 <ac> nominolo: someday my Haskell code will actually look like that
04:32:29 <nominolo> > appEndo (mconcat $ Endo <$> [(+2), (*4), (-1)]) 42
04:32:32 <lambdabot>   add an instance declaration for (Num (a -> a))
04:32:32 <lambdabot>     In the expression: (- 1)
04:32:53 <nominolo> > appEndo (mconcat $ Endo <$> [(+2), (*4)]) 42
04:32:54 <lambdabot>  170
04:33:04 <ac> would someone care to give an example where Any is applicable but any is not?
04:33:15 <faxathisia> :t Any
04:33:16 <lambdabot> Bool -> Any
04:33:17 <faxathisia> :t any
04:33:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
04:34:42 <ac> I think I understand the types, but why would you use getAnay?
04:35:33 <pjd> nominolo: endomorphism: "self-mapping"
04:35:43 <pjd> nominolo: in this case, from a type to itself
04:36:01 <nominolo> oh, i see
04:36:24 <nominolo> that should be in the docs
04:36:31 <pjd> so in this context, "endomorphism" is a fancy generic way of saying "(a -> a)"
04:37:17 <desegnis> ac, only if you somehow take advantage of the generality of it being a monoid, I guess
04:37:29 <ac> desegnis: right, I just can't think of such a situation
04:38:07 <ac> same goes for Endo <$>...
04:38:54 <ac> > (foldl (.) id [(+2), (*4)]) 42
04:38:55 <lambdabot>  170
04:39:50 <nominolo> > foldr (.) id [(+2), (*4)] 42
04:39:50 <lambdabot>  170
04:40:09 <desegnis> ac, I can only think of something contrived like:
04:40:12 <EvilTerran> ac, i think the point is you can write monoid-generic code, and then people can use any monoid (including the Any monoid) wit hyour code
04:40:14 <desegnis> >  mconcat [ Nothing, Just (All True), Just (All False), Nothing ]
04:40:14 <lambdabot>   add an instance declaration for (Monoid (Maybe All))
04:40:14 <lambdabot>     In the expression:...
04:40:41 <desegnis> erm... ghci 6.8.2 will do that
04:40:42 <EvilTerran> desegnis, doh?
04:40:48 <EvilTerran> seems odd...
04:41:03 * EvilTerran thought there was a Monoid m => Monoid (Maybe m) instance
04:41:19 <desegnis> instance Monoid a => Monoid (Maybe a)  -- from Data.Monoid
04:41:21 <nominolo> @instances Monoid
04:41:22 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
04:41:22 <desegnis> indeed
04:41:25 <ac> @where All
04:41:26 <lambdabot> I know nothing about all.
04:41:29 <EvilTerran> ac, consider something like foldMap from Foldable
04:41:29 <ac> @index All
04:41:30 <lambdabot> bzzt
04:41:32 <EvilTerran> ?hoogle foldMap
04:41:33 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:41:34 <lambdabot> Data.Traversable.foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
04:41:40 <desegnis> ac, it's in Data.Monoid too
04:42:35 <EvilTerran> ac, it takes a function from an element of the structure to a monoid, and the structure, and uses monoid instance to reduce the structure down to a single value of the monoid
04:42:44 <EvilTerran> ?hoogle All
04:42:44 <lambdabot> Data.Monoid.All :: newtype All
04:42:44 <lambdabot> Data.Monoid.All :: Bool -> All
04:42:44 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
04:42:47 <ac> desegnis: yeah, that mconcat works in my ghci
04:43:08 <profmakx> hm. bottom up tree automata ;)
04:43:10 <EvilTerran> ac, does that work as a justification for you?
04:43:58 <ac> EvilTerran: I think so
04:44:01 <EvilTerran> also note that if the monoid is Endo b, that becomes (a -> b -> b) -> t a -> b, which looks suspiciously like the type to foldr
04:44:26 <EvilTerran> (well, it becomes that suffering from a minor case of the newtypes, but you get the idea)
04:44:27 <ac> so you can use Any on things that aren't necessarily lists
04:44:34 <hpaste>  notpalomer pasted "liststore problems" at http://hpaste.org/5432
04:44:37 <EvilTerran> er, sorry, (a -> b -> b) -> t a -> b -> b
04:44:54 <notpalomer> hello, I created a combobox with a liststore, but none of the items are displayed
04:44:56 <EvilTerran> compare foldr :: (a -> b -> b) -> b -> [a] -> b
04:44:59 <notpalomer> the testcase is in the paste, can anyone help?
04:45:11 <pjd> ac: right; Monoid captures the general idea of "concatenables"
04:45:29 <EvilTerran> the only differences are t=[] and the last two parameters are swapped
04:45:32 <desegnis> EvilTerran, ac: According to darcs annotate, the Monoid instance for Maybe has only been added in March 2007
04:45:35 <ac> but you could always transform whatever thing you have in to a list, and then use any
04:45:48 <EvilTerran> desegnis, well, that is nearly a year ago
04:45:49 <ac> and because it's lazy, it wouldn't be inefficient
04:46:04 <pjd> ac: not necessarily
04:46:09 <notpalomer> (it's a gtk2hs question)
04:46:21 <EvilTerran> ac, it could still suffer from inefficiencies
04:46:46 <ac> so it might make sense to use Any to query a binary tree, for example
04:46:47 <EvilTerran> if you had a large, elaborate tree structure, all the ++ing could get painful
04:46:51 <pjd> ac: monoid is a more general abstraction;  you can't convert any monoid to a list
04:47:13 <desegnis> EvilTerran, you mean dons is careful about lambdabot to be up-to-date?
04:47:17 <pjd> in the same way that even though lists are a monad, you can't convert any monad to a list
04:48:12 <pjd> ac: for example, the monoids for Any / All / Sum / Product and such are just single boolean or integers
04:48:18 <EvilTerran> in the case of flattening a tree, sure, using ([a] -> [a], (.)) instead of ([a], (++)) would sort out the complexities, but it still seems messy to involve a list unnecessarily
04:48:26 <pjd> "boolean or integer values", even
04:48:51 <EvilTerran> pjd, i think what he's getting at is that you can always build a list then fold it with the monoid's mconcat
04:49:09 <pjd> ac: and Endo is a composition of functions;  you would have to separate or "decompose" them somehow to get a list back out
04:49:30 <EvilTerran> and you should be able to put off that folding until you know what definition of mconcat you want, in most cases
04:49:59 <pjd> EvilTerran: ah, true
04:50:58 <EvilTerran> i'd argue that a binary tree'd be a better structure for that sort of thing
04:51:20 <EvilTerran> ... but then you can take it further, and replace the concrete binary tree with a binary tree of thunks; hey presto, Monoid! :)
04:51:23 <ac> @src Traversable
04:51:23 <lambdabot> class (Functor t, Foldable t) => Traversable t where
04:51:23 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
04:51:23 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
04:51:23 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
04:51:23 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
04:51:39 <TauPan> hi
04:52:02 <TauPan> is there a haskell introduction for the functional programmer (i.e. someone familiar with miranda and/or lisp)?
04:52:05 <ac> @src [] traverse
04:52:06 <lambdabot> Source not found. That's something I cannot allow to happen.
04:52:09 <roconnor> ac: why not just have the IArray as a type constructor parameter to you datatype?
04:52:55 <faxathisia> TauPan, YAHT is not so bad I guess.. I would just grab whatever books the library has though
04:53:26 <pejo> TauPan, you might be able to just read the online report
04:53:55 <ac> Yeah, I used YAHT. http://en.wikibooks.org/wiki/Haskell seems to have more advanced stuff
04:53:55 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
04:54:54 <desegnis> TauPan: or maybe the »gentle introduction«
04:55:03 <desegnis> @where gentle
04:55:03 <lambdabot> http://www.haskell.org/tutorial/
04:56:09 <ac> roconnor: I don't know... I was asking if existential types would be necessary, or even make sense
04:56:27 <TauPan> the gentle introduction is a bit too gentle at first, but when I try to skip some chapters, it always seems I skipped too far. Apparently they sneak in key concepts where I didn't expect them.
04:57:46 <desegnis> heh
04:58:08 <roconnor> ac: it depends on what you are doing.  I can imagine situations where it would make sense.
04:58:20 <roconnor> ac: but it seems unlikely to be what you want.
04:58:53 <TauPan> guess I'll try YAHT first, continue with the gentle introduction if YAHT is too advanced and in any case finish off with the report to fill in the last bits... thanks for your suggestions :)
05:00:20 <pjd> TauPan: you can also just ask here for concept translation
05:00:45 <ac> roconnor: well, I want a data structure that has an array in it, and ideally the particular implementation of array would be selected by the library user with some type signature, or simply by importing a specific !
05:01:10 <EvilTerran> i'd suggest a type parameter
05:01:17 <TauPan> pjd: :-)
05:01:22 <ac> roconnor: AFAIK, the only function I'm going to use in my library is listArray, so it seems like this should be possible
05:01:30 <EvilTerran> or do you want the choice of array implementation to be invisible from the outside?
05:02:06 <EvilTerran> ?src IArray
05:02:06 <lambdabot> Source not found. Are you on drugs?
05:02:27 <ac> EvilTerran: hm, how could that be possible? A specific array implementation must be chosen at some point
05:02:39 <EvilTerran> well, you could do that with existentials fairly easily
05:02:58 <EvilTerran> i quite like the GADT formulation of this sort of thing
05:03:46 <vincenz> tib
05:04:01 <EvilTerran> data Foo a where Bar :: IArray arr e => arr Int e -> Foo e -- or whatever
05:04:05 <ac> EvilTerran: so you're saying in order to chose a specific implementation, but for that to be invisible from the outside you need existential types
05:04:29 <EvilTerran> or something equivalent, yes
05:04:41 <EvilTerran> but that's basically the point of existantials
05:04:46 <EvilTerran> consider a simpler example:
05:05:04 <EvilTerran> data Foo a where Bar :: a -> (a -> b) -> Foo b
05:05:07 <ac> EvilTerran: ok, right. That's what I had in mind, but now I'm realizing that I don't really care what the implementation is, so might as well not use existentials
05:05:41 <EvilTerran> given a Foo b, you have no way of telling what (a) is. all you know is you have an (a) and an (a -> b), and you know what (b) is
05:06:12 <ac> I don't get the correspondence between GADTs and existentials
05:07:05 <Saizan> however if you want the user to choose the implementation you need to get the existential from him, rather than producing it
05:07:50 <ac> Saizan: ah, that makes sense. I couldn't think of any way to formulate it with basic types, so I figured I needed existentials
05:08:50 <Saizan> a type parameter is probably better than
05:09:04 <Saizan> s/than/then/
05:11:21 <ac> EvilTerran: Do GADTs implement a superset of the functionality of existential types?
05:12:21 <Philippa> ac: yes
05:14:43 <yitz> Cale there?
05:16:06 <yitz> Anyone there who saw the cafe thread a few days ago about withCStringArray0?
05:16:49 <yitz> and/or the #haskell discussion that it came from?
05:16:58 <resiak> yo
05:17:05 <yitz> hi
05:17:38 <yitz> Did you get what the problem is with the simple way? Some strictiness issue, but
05:17:48 <resiak> which simple way?
05:17:55 <yitz> to allocate the array you need to compute it to the end to get the length.
05:18:18 <yitz> resiak: use mapM
05:18:26 <resiak> the types are wrong
05:18:59 <resiak> oh, they're not if you do it directly
05:19:11 <resiak> which is actually what I did at the bottom of http://www.willthompson.co.uk/cgi-bin/darcsweb.cgi?r=haskell-tracker;a=headblob;f=/System/Tracker.chs
05:19:13 <lambdabot> Title: darcs - haskell-tracker, http://tinyurl.com/2fhob6
05:19:55 <hpaste>  yitz pasted "Simple way to do withCStringArray0" at http://hpaste.org/5433
05:20:00 <resiak> I was trying to do mapM withCString (...) and failing to fill in the dots
05:20:17 <yitz> type-checks fine for me
05:20:32 <resiak> doesn't actually work though
05:20:35 <yitz> why
05:21:13 <resiak> "the memory is freed when the subcomputation terminates (either normally or via an exception), so the pointer to the temporary storage must not be used after this." http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html#v%3AwithCString
05:21:14 <lambdabot> http://tinyurl.com/ywrr7d
05:21:28 <resiak> so cs contains an array of invalid char*s :-)
05:22:12 <resiak> uhm, list of
05:22:26 <yitz> a bunch of 'em :)
05:22:33 <resiak> heh!
05:22:53 <yitz> so that's the whole problem? not laziness?
05:23:09 <resiak> but yeah, the point of with* is that you can only use the resource in question "inside" them, as it were.  using return to pull the pointers back "outside" the withCString doesn't work
05:24:12 <resiak> yeah, you obviously have to evaluate every element of the list to marshall it, so
05:26:13 <yitz> ok. So the real solution is a With monad, that has methods corresponding to the various existing with* functions. Pointers remain valid within the runWith calculation.
05:26:38 <yitz> Wouldn't be hard to write.
05:26:53 <resiak> heh!
05:27:02 <yitz> Rule of thumb - if the solutions uses CPS or MonadCont, there is something wrong.
05:28:12 <yitz> or third-order functions. :)
05:28:27 <resiak> to be honest, for now I'm going to stick with the direct solution
05:30:23 <yitz> meaning? the foldr one?
05:32:09 <hpaste>  resiak pasted "direct solution" at http://hpaste.org/5434
05:33:49 <yitz> direct indeed.
05:36:25 <hpaste>  yitz annotated "Simple way to do withCStringArray0" with ""simple" does not work" at http://hpaste.org/5433#a1
05:43:14 <Saizan> yitz: what's wrong with CPS? or the with* functions are written in CPS style
05:43:22 <Saizan> s/or/all/
05:45:28 <yitz> Passing a function is fine. Once the program logic depends on it, though, things quickly become tangled and unintelligible. There is always a simpler way.
05:45:43 <hpaste>  Japsu pasted "Finnish bank reference number stuff" at http://hpaste.org/5435
05:46:09 <hpaste>  Japsu annotated "Finnish bank reference number stuff" with "that does not typecheck" at http://hpaste.org/5435#a1
05:46:10 <hpaste>  Japsu annotated "Finnish bank reference number stuff" with "that does not typecheck" at http://hpaste.org/5435#a2
05:46:17 <Japsu> oops, fail
05:46:35 <yitz> Saizan: I have never seen a real use for MonadCont, either. I'd like to see an example if you have one.
05:47:23 <Saizan> MonadCont is the intelligible way to use CPS, i'd say
05:49:11 <yitz> Well, for example, Cale's use of MonadCont for this with* thing is much shorter than the function folds, but it's still a huge mind-bender compared to just allocating the memory.
05:50:01 <twanvl> Japsu: Haskell doesn't allow instances of the form "Ref a"
05:50:39 <Saizan> yitz: ok, but the with* functions are written that way to make harder to leak the pointer, not because of some CPS fanatism :)
05:52:56 <resiak> eh, Cale's nest does what it's meant to in the particular case, and is an interesting construction
05:53:12 <faxathisia> where is it?
05:53:24 <resiak> http://www.haskell.org/pipermail/haskell-cafe/2008-February/038963.html
05:53:25 <lambdabot> Title: [Haskell-cafe] A handy little consequence of the Cont monad, http://tinyurl.com/2e3dfs
05:53:59 <Japsu> twanvl: oh
05:54:08 <yitz> Yes. And that's fine. They work good in simple cases. Right now, the right way to do more complex cases is as resiak says - allocate some of the memory manually, not so terrible.
05:54:10 <TauPan> Hey, there's "Haskell for Miranda Programmers" :-)
05:54:20 <Japsu> twanvl: so I can't have instance Integral a => Ref a?
05:54:27 <yitz> And the real solution would be to have a monad for longer temp calculations.
05:54:32 <Japsu> is there any way to work around that
05:55:25 <twanvl> No. When looking up the instances, the compiler only looks at the instance head, in this case Ref a, not the context (Integral a =>), so it would try to use that instance for all types.
05:56:01 <twanvl> The only way to do this is to have instances for each integral type explicitly
05:56:14 <Saizan> yitz: that's already ContT r IO though :)
05:56:19 <Japsu> So there isn't any way to define instances like "if there is an instance of class A for type a, why don't you make up an instance of class B for a too?"
05:56:24 <Japsu> Lame :<
05:57:49 <yitz> Yuck, no, who could understand that? I just want alloca, but without the function pointer, inside a monad that automatically cleans up all of my allocas for me automatically.
05:58:47 <Japsu> hmm
05:58:48 <Japsu> instance Ref [Int] where
05:58:48 <Saizan> yitz: it'll look just the same from the outside.. also continuations in haskell are not that scary, just some functions passed around!
05:58:49 <Japsu>         fromRef = id
05:58:49 <Japsu>         toRef = id
05:58:52 <Japsu> That's still illegal
05:58:59 <Japsu> :E
05:59:19 <twanvl> Japsu: You can enable that with an extension, {-# LANGUAGE FlexibleInstances #-} I think
05:59:31 <Japsu> twanvl: Tried it, doesn't help
06:00:15 <twanvl> also, fromRef = id is wrong, since id doesn't have the type Integral a => [Int] -> [a]
06:00:29 <hpaste>  Japsu annotated "Finnish bank reference number stuff" with "Desperate tries to simplify it, still doesn't compile" at http://hpaste.org/5435#a3
06:00:46 <yitz> In this case it would not "just" be function pointers passing around - you can't tell where you'll end up with out applying brain power. I can grok them, but there is no guarantee that whoever else will read my code someday will.
06:00:56 <twanvl> the language pragma should be the first thing in the file
06:00:59 <Japsu> twanvl: I changed fromRef from Integral b => a -> [b] to a -> [Int]
06:01:59 <Japsu> ahh
06:02:00 <Japsu> okay
06:02:10 <Japsu> now let's see how many restrictions can I work around with that
06:02:23 <Saizan> yitz: you want something like "runWith $ do p <- alloca; doStuff p; str <- withCString String; doOther str p;  -- after this everything is freed" ?
06:03:21 <Saizan> yitz: because that's how you'd write it in ContT r IO
06:05:21 <yitz> It would also be nice to optionally free something in the middle.
06:06:16 <Japsu> bah
06:06:21 <Japsu> Now I have overlapping instances
06:06:34 <Japsu> instance Ref String and instance Integral a => [a]
06:07:01 <Japsu> can that be avoided while still retaining fromRef "123" == fromRef [1,2,3]?
06:07:12 <Saizan> yitz: is free idempotent?
06:07:25 <Shurique> is there a GHCi command-line option to specify modules to be loaded? (similar to :m in the actual prompt)
06:07:42 <Japsu> opqdonut: ping
06:07:47 <twanvl> Jpaus: you could make an instance [Int], instance Int and instance String
06:07:48 <opqdonut> pong
06:07:51 <yitz> That's the problem, I don't think so.
06:07:52 <Japsu> opqdonut: :E
06:08:33 <yitz> But other than that, is ContT r IO really that general? (What will r be?)
06:08:47 <Saizan> ?type runContT
06:08:49 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
06:09:26 <Saizan> r is the final result, you usually pass return as the final continuation though so:
06:09:35 <Saizan> ?type flip runContT return
06:09:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => ContT a m a -> m a
06:10:31 <Japsu> how do I hide instances while importing modules?
06:10:38 <Saizan> Japsu: you can't
06:10:46 <Japsu> I want to import Prelude hiding (Integral Char)
06:10:48 <Japsu> bah :<
06:11:10 <yitz> Jaspu: you have to newtype it then
06:11:10 <Saizan> ?type fromIntegral 'a'
06:11:11 <lambdabot>     No instance for (Integral Char)
06:11:11 <lambdabot>       arising from use of `fromIntegral' at <interactive>:1:0-15
06:11:11 <lambdabot>     Possible fix: add an instance declaration for (Integral Char)
06:11:19 <Saizan> Char is not Integral
06:11:31 <yitz> he
06:11:43 <Japsu> errm
06:11:57 <Japsu> well for some reason, instance Integral a => Ref [a] and instance Ref String overlap
06:12:31 <Saizan> Japsu: because [a] match [Char], the instance contexts are checked only later
06:12:52 <Saizan> Japsu: you need to enable OverlappingInstances for that to work
06:12:55 <yitz> Saizan: you could probably do the free thing with nesting and callCC.
06:13:11 <hpaste>  Japsu annotated "Finnish bank reference number stuff" with "Ref String and Integral a => Ref [a] overlap" at http://hpaste.org/5435#a4
06:14:27 <yitz> But anyway, I still don't think this is the right approach. You are still adding complexity that is bound to have a cost down the road. And it is not needed - it is only an artifact of alloca and with* taking function pointers. You could easily implement a simple monad
06:14:28 <TauPan> ?type sort
06:14:28 <Japsu> Saizan: okay, thanks, that fixed Ref String but broke Integral a => Ref [a]
06:14:29 <lambdabot> forall a. (Ord a) => [a] -> [a]
06:14:43 <yitz> ?type sortBy
06:14:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
06:15:22 <hpaste>  Japsu annotated "Finnish bank reference number stuff" with "OverlappingInstances breaks Integral a => Ref [a]" at http://hpaste.org/5435#a5
06:16:01 <Saizan> yitz: "You could easily implement a simple monad" <-- truncated here
06:16:13 <yitz> that does the same thing.
06:16:22 <Japsu> Bah
06:16:26 <twanvl> Japsu: you really don't want to use OverlappingInstances
06:16:33 <Japsu> I quess Integral a => Ref [a] is the one I can sacrifice
06:16:37 <Saizan> Japsu: fromRef [1::Int,2,3] works.
06:16:47 <cygnus_> how do ParseP and Parsec compare ?
06:16:53 <Japsu> just as long as I have fromRef 123 and fromRef "123"
06:16:59 <Saizan> Japsu: it needs to be able to infer that those literals are not Char.
06:17:35 <Saizan> yitz: how? collecting all the pointers in a list?
06:18:26 <yitz> Or some other container, yeah.
06:18:29 <twanvl> Japsu: What do you need all this flexibility for anyway? Do you really intend to use from/toRef at all those types?
06:19:26 <hpaste>  palomer pasted "entry completion not working!" at http://hpaste.org/5436
06:20:09 <Japsu> twanvl: I want my bank reference number checker to work both as a library for possible other problems needing the functionality, and simply with as little obstruction as possible from the ghci command line
06:20:40 <hpaste>  Japsu annotated "Finnish bank reference number stuff" with "Even with instance Integral a => Ref [a] gone, this requires OverlappingInstances :<" at http://hpaste.org/5435#a6
06:21:15 <Japsu> string and long integer are the most likely formats anyone would input the reference number in
06:21:44 <opqdonut> what does ghc say if you compile w/o OverlappingInstances
06:22:50 <hpaste>  Japsu annotated "Finnish bank reference number stuff" with "<opqdonut> what does ghc say if you compile w/o OverlappingInstances" at http://hpaste.org/5435#a7
06:24:33 <opqdonut> :i Integral
06:24:40 <opqdonut> ?instances Integral
06:24:41 <lambdabot> Int, Integer
06:24:51 <Japsu> instance Integral Integer -- Defined in GHC.Real
06:24:51 <Japsu> instance Integral Int -- Defined in GHC.Real
06:24:55 <opqdonut> ah yes
06:25:13 <opqdonut> "Ref a" matches everything
06:25:18 <opqdonut> that's why you need overlapping
06:25:44 <opqdonut> then ghc will choose the most specific instance that applies
06:26:16 <hpaste>  (anonymous) annotated "entry completion not working!" with "(no title)" at http://hpaste.org/5436#a1
06:26:21 <yitz> Saizu: maybe something like: data TempAlloc = TA (forall a. (Ptr a, Ptr a -> IO ())
06:26:41 <notpalomer> if anyone is familiar with gtk2hs, I'm having problems getting entry completion to work
06:26:45 <notpalomer> my code is at http://hpaste.org/5436#a1
06:27:10 <Japsu> hmm
06:27:22 <Japsu> some reference numbers are too long to fit in an Int
06:27:30 <Japsu> at least if Int == 32 bits
06:27:41 <Japsu> so I quess I'll just ditch the Integral a => a and use Integer
06:28:29 <twanvl> Japsu: It is probably better to just have a single way of representing reference numbers everywhere. Depending on how large a library you built around them, maybe even a new data type or newtype.
06:28:46 <FunctorSalad> is there a haskell editor with auto-completion?
06:29:19 <Japsu> with only Ref String and Ref Integer, I can ditch OverlappingInstances
06:29:31 <Heffalump> the emacs Haskell mode does some auto-completion
06:29:34 <Japsu> but not FlexibleInstances
06:31:05 <FunctorSalad> Heffalump: hmm, only for things in your file or for the actual haskell libraries?
06:31:41 <FunctorSalad> (and my haskell-mode is only semi-functional anyway ;) can't get it to add the haskell menu to the menu bar)
06:33:44 <notpalomer> a new haskell-mode?
06:34:20 <Japsu> twanvl: I guess you're right. My approach leads to way too much type juggling
06:34:55 <TomMD> Where is the function "instanceOfEnglishSpecification :: String -> IO ()"?  I can't find it.
06:36:02 <yitz> Saizan: maybe something like: data TempAlloc = TA (forall a. (Ptr a, Ptr a -> IO ())
06:36:44 <TomMD> Humm.. must not be any coders for hire in here or they would have spoke up ;-)
06:37:01 <Saizan> yitz: and the function is? free works for any type a
06:37:17 <yitz> It has a natural Ord instance via minusPtr.
06:38:09 <yitz> Yeah, don't need that.
06:38:33 <yitz> so TA (forall a. Ptr a)
06:38:58 <Saizan> forall a. TA (Ptr a) :)
06:39:38 <yitz> Any difference?
06:39:52 <Saizan> the first contains only TA undefined
06:40:19 <yitz> That would be rather boring
06:41:15 <Saizan> however i'd just cast them to Ptr (), so you can use Eq or Ord to remove a pointer from the list if you're freeing it early
06:50:24 <FunctorSalad> is there some less-cluttering way of discarding any possible error return values in the form of "Nothing" or "Left something"?
06:50:28 <litb> hello again guyz
06:51:08 <Saizan> FunctorSalad: ehm, rephrase?
06:51:24 <Saizan> ?type catMaybes -- maybe?
06:51:26 <lambdabot> forall a. [Maybe a] -> [a]
06:51:38 <litb> oh, interesting
06:51:50 <litb> catMaybes [Just 4, Just 10, Just 11]
06:51:56 <litb> > catMaybes [Just 4, Just 10, Just 11]
06:51:57 <lambdabot>  [4,10,11]
06:52:08 <litb> yeah
06:52:36 <FunctorSalad> Saizan: I just want to run a regexp, but it returns "Maybe (Either SomeError SomeMatch)". dealing with that explicitly makes the code hard to read
06:52:51 <litb> that's just map fromJust i suppose
06:53:19 <FunctorSalad> or even, IO Maybe Either =)
06:53:42 <olsner> @ty fmap (maybe (Left "Nothing") fromJust)
06:53:43 <lambdabot> forall b (f :: * -> *). (Functor f) => f (Maybe (Maybe (Either [Char] b))) -> f (Either [Char] b)
06:53:51 <FunctorSalad> I was thinking of something like "ignoreallerrors doStuff" ;)
06:53:51 <olsner> @ty fmap (maybe (Left "Nothing") iiiiiiiiiiiiid)
06:53:52 <lambdabot> Not in scope: `iiiiiiiiiiiiid'
06:53:54 <litb> FunctorSalad: sounds like you need a monad
06:54:17 <litb> @src catMaybes
06:54:17 <lambdabot> catMaybes ls = [x | Just x <- ls]
06:54:22 <Saizan> FunctorSalad: and just throw an exception in case there's one?
06:54:28 <litb> ah nice done
06:54:29 <FunctorSalad> Saizan: yeah
06:55:01 <olsner> argh, I think my scheduler sporadically ignores the keyboard long enough for it to think it should apply key repeat
06:55:17 <FunctorSalad> of course I can solve it with fmap and (|||), but it emphasizes errors that seem unlikely to appear
06:55:50 <FunctorSalad> like "((error "omg") ||| regexec) foo", where foo is my Either
06:56:07 <Saizan> FunctorSalad: well, i'd write an helper function with a short name :) there's nothing in the strlib
06:56:17 <FunctorSalad> yeah
06:56:32 <litb> any idea how one could rewrite it with monads that "Nothing" will be ignored and not inserted into the list?
06:56:50 <litb> i think of mzero but cannot do any sane with it (not being too experienced yet)
06:57:15 <yitz> Saizan: no need to cast. you can use minusPtr to create the Ord and Eq instances easily. I suppose casting to () would not affect that on any platform, but no need to rely on it.
06:57:17 <twanvl> litb: what part do you want to generalize? The list or the Maybe?
06:57:27 <litb> twanvl: the catMaybes
06:57:47 <litb> twanvl: so that [Nothing, Just 5, Just 6, Nothing] will become [5, 6]
06:58:00 <Saizan> yitz: Ptr a is already an instance of Ord and Eq
06:58:15 <twanvl> litb: But do you want f :: MonadPlus m => [m a] -> [a], or f :: MonadPlus m => m (Maybe a) -> m a?
06:58:33 <yitz> Yes, but for each a separately. My contain will contain polymorphic ones.
06:58:59 <FunctorSalad> @type some
06:59:00 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
06:59:12 <FunctorSalad> @type many
06:59:13 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
06:59:29 <FunctorSalad> hmm, I thought there was something in Applicative that did what you want, litb
06:59:57 <yitz> @info Ptr
06:59:57 <lambdabot> Ptr
07:00:34 <Saizan> yitz: you lose the type information anyway with the existential, and the haskell type doesn't influence the memory unless you use Storable
07:01:37 <yitz> Saizan: But perhaps casting changes the alignment on some platform for some types, who knows for sure.
07:01:44 <litb> twanvl: i don't know whether i want MonadPlus . that's why i informed me here :)
07:01:54 <litb> tho is that the right thing to use?
07:02:03 <twanvl> catMaybes? :)
07:02:44 <notpalomer> is it possible to find all the functions in a module?
07:02:51 <litb> > catMaybes [Nothing, Just 4]
07:02:52 <lambdabot>  [4]
07:02:58 <litb> oh it ignores that too
07:03:09 <litb> i thought it would fail on a pattern match failure
07:03:09 <desegnis> notpalomer: at runtime?
07:03:10 <yitz> Saizan: could be never. But it costs nothing to use minusPtr, and it's guaranteed safe.
07:03:22 <notpalomer> hoogle claims that onInsertAtCursor is part of Module Graphics.UI.Gtk.Entry.Entry, but my ghc disagrees
07:03:43 <notpalomer> desegnis, nono, at programming time
07:03:46 <yitz> notpalomer: :browse in GHCi
07:03:50 <twanvl> litb: Pattern matches in list comprehension and do notation are 'smart', they just ignore the things that don't match
07:03:58 <FunctorSalad> Maybe cat... insert Schroedinger joke here
07:04:16 <desegnis> notpalomer: er, see yitz
07:04:34 <notpalomer> thx
07:04:59 <desegnis> notpalomer: That will show you only the exported functions, mind you.
07:05:29 <litb> twanvl: ah i see. it's calling fail of the list monad then
07:05:38 <twanvl> exactly
07:05:50 <litb> > let y = \xs -> do { Just x <- xs; return x } in y [Nothing, Just 4]
07:05:51 <lambdabot>  [4]
07:05:55 <notpalomer> hmm
07:05:57 <litb> hm, that gives me an error here
07:06:02 <litb> > let y = \xs -> do { Just x <- xs; return x }
07:06:02 <lambdabot>  Parse error at end of input
07:06:04 <notpalomer> it's not there, weird
07:06:11 <yitz> FunctorSalad: insert Maybe cat... Schroedinger joke here
07:06:13 <litb> "Ambiguous type variable `t' in the constraint:"
07:06:13 <twanvl> ?undo catMaybes ls = [x | Just x <- ls]
07:06:13 <lambdabot> catMaybes ls = concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
07:06:21 <litb> if i don't have the "in y .."
07:06:56 <twanvl> litb: sounds like the monomorphism restriction, write f xs = ... instead
07:07:31 <desegnis> litb: lambdabot /= ghci. use @let
07:07:34 <litb> well, i'm within the ghci . but good to know :)
07:07:47 <litb> oh
07:07:49 <Saizan> yitz: alignment doesn't matter if you don't use the memory i guess, however i don't have a problem with existentials :)
07:08:00 <litb> @let y = \xs -> do { Just x <- xs; return x }
07:08:00 <lambdabot> <local>:1:16:     Ambiguous type variable `t' in the constraint:       `Monad...
07:08:04 <litb> that's the error i get
07:08:11 <idnar> :t catMaybes
07:08:12 <lambdabot> forall a. [Maybe a] -> [a]
07:08:19 <desegnis> well, litb, see twanvl
07:08:21 <idnar> so is there something like that for MonadPlus?
07:08:30 <MyCatVerbs> > (fix (\f n -> case n of { 0 -> 0; 1 -> 1; x -> x * (f (n-1)); })) 12
07:08:31 <lambdabot>  479001600
07:08:54 <MyCatVerbs> > (fix (\f n -> case n of { 0 -> 0; 1 -> 1; x -> x * (f (n-1)); })) 120
07:08:55 <lambdabot>  6689502913449127057588118054090372586752746333138029810295671352301633557244...
07:08:58 <MyCatVerbs> Heehee.
07:08:59 <faxathisia> weird def
07:09:23 <Saizan> especially since fact 0 = 1
07:09:36 <faxathisia> > (fix (\f n -> case n of { 0 -> 0; 1 -> 1; x -> (f (n-1)) + (f (n-2)); })) 12
07:09:36 <lambdabot>  144
07:09:52 <resiak> can you use guards in lambdas?
07:09:55 <litb> hm how can i convert a mzero of the Maybe a monad in a mzero of the list monad ?
07:09:56 <faxathisia> > map (fix (\f n -> case n of { 0 -> 0; 1 -> 1; x -> (f (n-1)) + (f (n-2)); })) [0..]
07:10:01 <yitz> Saizan: I need the existential to be able to store Ptr a for different values of a in the same container. I then need to compare them, so that the container can be a Map or something. If I cast to Ptr (), it may change the outcome of the comparison due to byte alignments. Or maybe not, but why not just use minusPtr for the Ord instance.
07:10:03 <lambdabot> Terminated
07:10:12 <faxathisia> huh..
07:10:20 <litb> resiak: afaik you have to use case
07:10:36 <resiak> ah well
07:11:06 <twanvl> resiak: or use let/where to make a named function, that is usually better
07:11:46 <resiak> oh, sure
07:11:55 <resiak> i meant from the point of view of \b golfind :)
07:12:04 <resiak> *golfing.  I should learn to type.
07:12:06 <litb> how is it not possible to convert "Nothing" into [] in terms of MonadPlus ?
07:12:15 <Saizan> yitz: i understand what the existential is for. i just think that the haskell type doesn't have any operational meaning outside of Storable. but as i said i don't have a stron opinion on either solution.
07:12:53 <yitz> Saizan: Could it be that for some types a and b, a Ptr a and Ptr b are not equal but they are equal after casting? Probably not. But who knows, a platform could be crazy and do that. minusPtr on non-casted Ptrs is guaranteed accurate.
07:13:10 <hpaste>  Japsu annotated "Finnish bank reference number stuff" with "complete source of my banking reference number thingy, with tests" at http://hpaste.org/5435#a8
07:13:33 <Saizan> yitz: parametricity of the Ord instance guarantees that.
07:14:21 <cygnus_> can someone expali nto me what is a list homomorphism?
07:17:22 <twanvl> cygnus_: homo = same (structure), morphism = function/mapping. So a list homomorphism is a function that preserves the structure of a list, in haskell this is done with the map function. (At leat IIRC)
07:18:12 <eugman> twanvl: what's the distinction between a homomorphism and an isomorphism? Context?
07:19:57 <litb> all i know is that isomorphism means that something has the same structur like something else
07:20:26 <twanvl> I guess an isomorphism would be a function, a -> a. At least, that is an isomorphism on the type level (in the category Hask)
07:20:38 <Saizan> eugman: an isomorphism is when both f and its inverse are homomorphism
07:20:42 <FunctorSalad> I don't know but I would guess a list homomorphism is function f: [a] -> [b] such that f(x ++ y) = f(x) ++ f(y)
07:20:56 <FunctorSalad> and f([]) = []
07:20:56 <eugman> Saizan: that definition makes much sense, thanks
07:21:18 <litb> in graph theory it means you have a one-one-unique function that maps one node from the one graph to one node from the other uniquely
07:21:34 <twanvl> err, ignore that a->a bit
07:21:36 <cygnus_> is map a homomorphism according to that definition
07:21:55 <litb> as i understand it, map is at least not an isomorphism
07:22:06 <FunctorSalad> cygnus_: (map g) would be a homomorphism for any g. and I think any list hom. arises that away
07:22:35 <FunctorSalad> oh wait, the second statement is wrong I think
07:22:35 <Botje> it's morphing time!
07:22:59 <FunctorSalad> the function that maps everything to the empty list is a hom., but it doesn't arise through map
07:23:04 <litb> homorph simpson :)
07:23:17 <doserj> writing reverse as map g is left as an exercise...
07:23:37 <FunctorSalad> doserj: reverse wouldn't be a hom. by my guessed definition
07:23:52 <FunctorSalad> since it's contravariant
07:24:05 <FunctorSalad> reverse(x ++ y) = reverse(y) ++ reverse(x)
07:24:18 <cygnus_> what is ++ ?
07:24:38 <FunctorSalad> concatenation (I hope)
07:24:41 <Deewiant> @check \x y -> reverse (x ++ y) == reverse y ++ reverse (x :: [Int])
07:24:42 <lambdabot>  OK, passed 500 tests.
07:26:02 <litb> @check \x y -> x + y == x * y
07:26:03 <lambdabot>  Add a type signature
07:26:22 <litb> @check \x y -> x + y == x * y ( x :: Int )
07:26:22 <lambdabot>  Couldn't match expected type `Int -> Int'
07:26:27 <litb> hm, how is this working?
07:26:39 <Deewiant> you have to add a type signature like you would in haskell code
07:26:46 <Deewiant> @check \x y -> (x :: Int) + y == x * y
07:26:46 <lambdabot>  Falsifiable, after 2 tests: 1, -1
07:27:06 <cygnus_> length is a homomorphism right ?
07:27:10 <litb> oh rite
07:27:46 <Saizan> cygnus_: right
07:28:06 <litb> hm, since it gives the same result for the same list structure?
07:28:11 <litb> would that be a valid reasoning?
07:28:41 <Saizan> litb: since it preserves the properties of monoid in N
07:28:54 <Saizan> length xs
07:29:24 <Saizan> length (xs ++ ys) = length xs + length ys
07:29:30 <cygnus_> how do we justify it with the f(x ++ y) = f(x) ++ f(y) definition
07:29:44 <FunctorSalad> I think it's correct that all the list homs arise through foldr though
07:29:52 <Saizan> and length [] = 0
07:29:56 <FunctorSalad> (if you allow any monoids and not just lists as codomain)
07:30:09 <cygnus_> this is confusing ++ and + ?
07:30:14 <EvilTerran> cygnus_, well, it's that f (x `mappend` y) = f x `mappend` f y
07:30:17 <twanvl> cygnus_: f (x `mappend` y) = f x `mappend` y; f mempty = mempty
07:30:32 <Saizan> FunctorSalad: don't every function that takes a list as argument arises from foldr?
07:30:55 <cygnus_> so is     4 `mappend` 3 = 7?
07:30:57 <FunctorSalad> Saizan: you mean the homomorphism condition is one of these "theorems for free"?
07:31:04 <FunctorSalad> maybe, I don't know
07:31:13 <EvilTerran> for [a], (mappend,empty) = ((++),[]); for Num a, (one valid def of) (mappend,mempty) = ((+),0)
07:31:18 <FunctorSalad> oh wait, you didn't say that it would always be a hom
07:31:28 <cygnus_> ok ty
07:31:52 <Saizan> FunctorSalad: yeah, just that it doesn't tell much that every hom arises from foldr :)
07:32:00 * EvilTerran wants better names for (mappend,mempty)
07:32:27 <FunctorSalad> oh cancel that last one, you did imply that every function defined on lists is a list hom (at least if the argument to foldr is an associative operation)
07:32:32 <Japsu> @src rem
07:32:32 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:32:35 <EvilTerran> ((|*|), zero)?
07:33:05 <EvilTerran> twanvl, is that the def of a homomorphism in this case?
07:33:24 <twanvl> I am not sure, but it makes sense
07:33:27 <EvilTerran> well, i guess that's "homomorphism on the monoid structure"
07:33:37 <EvilTerran> s/on/preserving/, mebbe
07:33:41 <notpalomer> anyone know a function [IO a] -> (a -> IO ()) -> IO () ?
07:33:45 <FunctorSalad> yeah, I was thinking of lists as monoid elements too
07:33:51 <EvilTerran> ?type mapM_
07:33:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
07:34:04 <conal> EvilTerran: how about "MonoidDict".  btw, see http://darcs.haskell.org/packages/TypeCompose/doc/html/Data-CxMonoid.html
07:34:06 <lambdabot> http://tinyurl.com/22g3d7
07:34:06 <notpalomer> almost!
07:34:44 <notpalomer> unfortunately, I have a [IO a] and not an [a]
07:35:15 <EvilTerran> ?type \xs f -> forM_ xs (>>= f)
07:35:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [m a] -> (a -> m b) -> m ()
07:35:24 <notpalomer> cool
07:35:30 <notpalomer> @pl \xs f -> forM_ xs (>>= f)
07:35:30 <lambdabot> (. (=<<)) . forM_
07:35:31 <EvilTerran> forM_ = flip mamM_
07:35:39 <EvilTerran> er, mapM_
07:35:52 <notpalomer> I'm surprised it's not a named function
07:35:54 <EvilTerran> ?type flip . mapM_ . (=<<)
07:35:54 <lambdabot> forall b a b1. (a -> b -> b1) -> b -> [b -> a] -> ()
07:36:02 <EvilTerran> hm. that's wrong.
07:36:12 <EvilTerran> ?type flip (mapM_ . (=<<))
07:36:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [m a] -> (a -> m b) -> m ()
07:36:24 <EvilTerran> that's tetley.
07:36:28 <litb> i o.O
07:36:39 <litb> anyway, bye going to cook
07:36:47 <notpalomer> cya
07:37:01 <FunctorSalad> @type sequence
07:37:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:37:06 * litb collects some lambdas for his meal
07:37:08 <FunctorSalad> notpalomer: maybe that would help?
07:37:27 <EvilTerran> conal, that looks clever... what'd code using it look like?
07:37:38 <notpalomer> the function is \xs f -> forM_ xs (>>= f), but I'm trying to find a name for it
07:38:16 <EvilTerran> forMM_ ;)
07:38:47 <notpalomer> @type \f a -> sequence $ map (>>= f) a
07:38:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [m a] -> m [b]
07:38:53 <notpalomer> there's another
07:39:19 <int-e> @type (?f <*>)
07:39:20 <lambdabot> forall (f :: * -> *) a b. (?f::f (a -> b), Applicative f) => f a -> f b
07:39:22 <notpalomer> I'll call it mapbind
07:39:27 <FunctorSalad> \xs f -> (fmap (fmap f)) $ sequence xs
07:39:30 <FunctorSalad> @type \xs f -> (fmap (fmap f)) $ sequence xs
07:39:31 <lambdabot> forall b (m :: * -> *) a. (Functor m, Monad m) => [m a] -> (a -> b) -> m [b]
07:39:42 <conal> EvilTerran: I use it in Phooey for combining sub-GUIs, which involves combining layouts.  See http://darcs.haskell.org/packages/phooey/doc/html/src/Graphics-UI-Phooey-Monad.html
07:39:43 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2262dz
07:40:14 <FunctorSalad> we need deep fmap ;)
07:40:31 <conal> EvilTerran: see CxLayout and UI at the top of that page (and UI' to help decode UI)
07:41:54 <EvilTerran> hmm
07:43:20 <conal> EvilTerran: i found i could combine layouts automatically & effortlessly by making UI a monoid
07:43:37 <EvilTerran> conal, so the idea is you build a (CxMonoid a) value as you would a normal monoid value, then unCxMonoid foo ((+),0) or whatever?
07:43:51 <olsner> heh, found a file called TODO containing the following text: "so, if you have a lie group with two generators a and b, a generates turns and b generates (relative) forward motion, then the lie bracket [a,b] = a b a^(-1) b^(-1) is a parallel parking transformation"
07:43:54 <olsner> I blame #haskell
07:44:28 <conal> EvilTerran: yeah.  and the monoid dictionary would trickle down.
07:44:34 <EvilTerran> clever
07:45:28 <conal> EvilTerran: the phooey functions fromLeft etc temporarily override the inherited MonoidDict
07:45:30 * FunctorSalad doesn't know what "parallel parking" is
07:45:51 <conal> EvilTerran: examples here: http://haskell.org/haskellwiki/Phooey#Layout
07:46:12 <EvilTerran> very clever
07:46:24 <olsner> FunctorSalad: seems related to "lie groups" and "brackets"
07:48:36 <FunctorSalad> olsner: not that I know much abot them, but wouldn't that bracket be a relative sideways motion?
07:48:57 <FunctorSalad> you move a bit backwards, turn a bit, move a bit forwards, and turn back a bit
07:49:58 <olsner> yeah, I guess that's the parallel parking part of it, you end up in the same place but to the right/left...
07:51:10 <dcoutts_> notpalomer: that's tricky because it relies on model column numbers, I think something was added recently to allow that though, check the gtk2hs users mailing list archive
07:51:19 <FunctorSalad> yeah. though I wonder whether a is a pure rotation or rotation + forward (the former being a bit less realistic)
07:53:36 <FunctorSalad> on a related note, we need a "real simple regular expressions" package
07:54:37 <olsner> as in "simple library for regexps" or "library for simple regexps"?
07:54:49 <notpalomer> dcoutts_, finally you come, but when I must go!
07:54:52 <notpalomer> hope to catch you later
07:56:07 <FunctorSalad> olsner: I was alluding to this fun little story =) http://golem.ph.utexas.edu/category/2007/11/the_dangers_of_complex_analysi.html#c013136
07:56:07 <lambdabot> Title: The Dangers of Complex Analysis | The n-Category Caf&#xE9;, http://tinyurl.com/ysbtt3
07:57:12 <dcoutts_> notpalomer: right'o
07:57:35 <Deewiant> I don't suppose there's a standard function "apply given function to given argument a given number of times"?
07:58:06 <Deewiant> e.g. foo 10 (1+) 0 == 10
07:58:10 <FunctorSalad> > take 10 $ iterate (*2) 1
07:58:14 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
07:58:47 <Deewiant> > let foo n f a = (iterate f a) !! n in foo 10 (1+) 0
07:58:48 <lambdabot>  10
07:59:04 <Deewiant> alright, that works, cheers
07:59:07 <FunctorSalad> :)
07:59:31 <Deewiant> although I wonder if it's smart enough to unroll the list and not build it at all
07:59:35 <faxathisia> > iterate (join (+)) 1
07:59:36 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
08:00:00 <faxathisia> I didn't expect that to work...
08:00:33 <FunctorSalad> @type join
08:00:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:00:43 <FunctorSalad> @type (join (+))
08:00:44 <lambdabot> forall a. (Num a) => a -> a
08:01:15 <FunctorSalad> hmm I guess it's using the (a->) monad... *head explodes*
08:01:33 <oerjan> @quote exploded
08:01:33 <lambdabot> ghc says: My brain just exploded.
08:01:35 <oerjan> @quote exploded
08:01:35 <lambdabot> ghc says: My brain just exploded.
08:01:44 <oerjan> @quote brain
08:01:44 <lambdabot> lambdabot says: Listen, broccoli brains, I don't have time to listen to this trash.
08:01:59 <faxathisia> hmmm........
08:02:03 <faxathisia> :t (+)
08:02:03 <oerjan> @quote explode
08:02:04 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
08:02:04 <lambdabot> forall a. (Num a) => a -> a -> a
08:02:20 <FunctorSalad> hehe
08:02:53 <oerjan> :t join.($)
08:02:55 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
08:03:08 <FunctorSalad> faxathisia: so join turns a binary operator into the unary diagonal operator?
08:03:22 <FunctorSalad> (for this monad)
08:03:35 <faxathisia> join (+) = \x -> x + x -- I think
08:03:41 <faxathisia> But I don't really know why :D
08:03:53 <faxathisia> hmm actually
08:03:58 <Deewiant> hmm, no list replacement function? replace "abc" "def" "abcdef" == "defdef"?
08:04:00 <oerjan> @src (->) (>>=)
08:04:01 <lambdabot> f >>= k = \ r -> k (f r) r
08:04:08 <oerjan> @src join
08:04:08 <lambdabot> join x =  x >>= id
08:04:18 <FunctorSalad> faxathisia: I think it considered (+) as type m (m Int), where m x = Int -> x
08:04:25 <oerjan> (expansion is left as an exercise :) )
08:04:55 <pjd> > let square = join (*) in square 5
08:04:56 <lambdabot>  25
08:05:05 <FunctorSalad> join (f :: a -> (a -> b)) = \x -> f x x
08:05:07 <FunctorSalad> right?
08:05:13 <oerjan> :t dropPrefix
08:05:14 <pjd> right
08:05:14 <lambdabot> Not in scope: `dropPrefix'
08:05:20 <oerjan> @hoogle prefix
08:05:20 <lambdabot> Distribution.Simple.InstallDirs.prefix :: InstallDirs dir -> dir
08:05:20 <lambdabot> Data.Generics.Basics.Prefix :: Fixity
08:05:20 <lambdabot> Text.ParserCombinators.Parsec.Expr.Prefix :: GenParser t st (a -> a) -> Operator t st a
08:05:48 <faxathisia> :t join id
08:05:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
08:05:49 <lambdabot>     Probable cause: `id' is applied to too many arguments
08:05:49 <lambdabot>     In the first argument of `join', namely `id'
08:05:49 <faxathisia> :D
08:05:54 <litb> @src join
08:05:54 <lambdabot> join x =  x >>= id
08:06:06 <litb> it's actually a littl bit more complicated
08:06:41 <faxathisia> > iterate ((\x->x) =<< (+)) 1
08:06:42 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
08:06:49 <FunctorSalad> litb: I know it's a special case for that monad
08:06:55 <oerjan> Deewiant: not a direct simple one, i think.  there is Text.Regex, and you can build one with isPrefixOf and dropPrefix (new in 6.8)
08:07:02 <litb> but, well i suppose if x is always (->)e then the above simplification is valid?
08:07:15 <pjd> faxathisia: the intuition behind that is that a (r ->) monadic value is a function waiting for a value (r)
08:07:18 <faxathisia> > iterate (($) =<< (+)) 1
08:07:18 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
08:07:24 <oerjan> (not sure what dropPrefix actually was called)
08:07:32 <Deewiant> oerjan: yeah, I was hoping for a simple one without having to use regex.
08:07:42 <litb> lol what is that faxathisia
08:07:43 <Deewiant> heh, was just about to say it's not in base-3.0.1.0
08:07:44 <litb> interesting
08:07:53 <Deewiant> stripPrefix?
08:07:55 <pjd> faxathisia: join takes two monadic values and "flattens" them
08:08:29 <faxathisia> yeah
08:08:33 <litb> ah i see that's just the same as join
08:08:37 <faxathisia> :t mplus
08:08:38 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
08:08:38 <oerjan> @hoogle dropPrefix
08:08:38 <lambdabot> No matches found
08:08:45 <faxathisia> hm ok
08:08:48 <litb> > iterate (join (+)) 1
08:08:49 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
08:08:53 <oerjan> @hoogle [a] -> [a] -> [a]
08:08:54 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
08:08:54 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
08:08:54 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
08:08:55 <EvilTerran> pjd, well, a "doubly monadic" value
08:09:04 <pjd> EvilTerran: right
08:09:23 <pjd> so, to flatten a (r ->) returning an (r ->), you return a function that takes an r and applies it twice
08:09:27 <FunctorSalad> > iterate (join (.)) (+)
08:09:28 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> b
08:09:28 <lambdabot>     Probabl...
08:09:51 <faxathisia> What's wrong with infinite types?
08:09:57 <oerjan> stripPrefix was it
08:10:00 <EvilTerran> > iterate (join (.)) (join (+)) 1
08:10:09 <litb> > iterate (join (.)) (+1)
08:10:17 <EvilTerran> ?bot
08:10:26 <EvilTerran> :(
08:10:29 <FunctorSalad> :(
08:10:31 <litb> ://
08:10:38 <olsner> everyone testing their powers-of-two-creators at the same time?
08:10:41 <faxathisia> lambdabot is thinking about my question
08:10:43 <litb> we will never forget you :'/
08:10:49 <faxathisia> deeply
08:10:50 <faxathisia> :)
08:11:06 <FunctorSalad> olsner: I think that last one is way worse than powers of two
08:11:23 <FunctorSalad> or probably I'm confusing it with something else
08:11:24 <oerjan> faxathisia: usually infinite types means you have a bug
08:11:29 <EvilTerran> well, in terms of type theory, the point of types is that they must be finite, IIRC
08:11:41 <ricky_clarkson> EvilTerran: Why?
08:12:02 <EvilTerran> so you can reason about them in finite time (?)
08:12:03 <oerjan> so they are not allowed.  ocaml has a flag to allow them, i don't think ghc does...
08:12:08 <Cale> If you want to work with what would be infinite types, you can get around the restriction using newtypes
08:12:22 <olsner> aren't infinite types just one vertex away in the lambda cube?
08:12:38 <faxathisia> I don't think infinite types are in the cube..
08:12:38 <EvilTerran> thing is, a lot of things that would be infinite types when expressed naively can be re-expressed using, eg, newtypes to be finite
08:12:38 <ricky_clarkson> So if humans can work around the restriction, why can the type system not embed that workaround?
08:13:15 <Cale> ricky_clarkson: Because errors regarding infinite types are usually real errors.
08:13:49 <EvilTerran> in needs a marker so it knows where the infinite-ness is restricted to, i gues. like you need new types to do things with existentials and whatnot.
08:13:51 <ricky_clarkson> I've only come across them when trying stuff from the untyped lambda calculus.
08:13:59 <ricky_clarkson> > \f x -> f f x
08:14:00 <EvilTerran> decidability of the type system.
08:14:09 <nolrai> mappend Nothing (Just False)
08:14:12 <nolrai> > mappend Nothing (Just False)
08:14:22 <litb> looks like it's dead
08:14:31 <oerjan> @bot
08:14:54 <faxathisia> yeah that's why STLC normalizes, It's impossible to type a Y combinator
08:15:34 <LoganCapaldo> STLC?
08:15:44 <LoganCapaldo> normalizes?
08:15:51 <LoganCapaldo> impossible?
08:15:52 <Saizan> can you type Y in System F?
08:15:58 <EvilTerran> indeed, the restriction to finite types also makes it possible to reason out more stuff about well-typed programs
08:16:00 <oerjan> simply typed lambda calculus
08:16:00 <FunctorSalad> I've only encountered the infinite type restriction when my code had a bug so far, too
08:16:10 <nolrai> what file is mappend from?
08:16:11 <LoganCapaldo> just kidding about the impossible bit
08:16:26 <LoganCapaldo> Data.Monoid maybe?
08:16:28 <Saizan> LoganCapaldo: normalizes = no bottoms
08:16:38 <LoganCapaldo> mmm
08:16:55 <EvilTerran> LoganCapaldo, a normalized expression is one from which no evaluation rules apply
08:17:14 <EvilTerran> in the case of \calc, that means it has a lambda abstraction (as compared to an application) at the top level
08:17:34 <LoganCapaldo> ooooooooooooooooooooo
08:17:38 <LoganCapaldo> dawgs
08:17:49 <EvilTerran> in untyped \calc, Omega = (\x . x x) (\x . x x) evaluates to itself, so doesn't normalize
08:17:55 <LoganCapaldo> which is why stlc always terminates
08:17:58 <EvilTerran> in the STLC, it's impossible to construct such an expression
08:18:02 <LoganCapaldo> it's clear to me now
08:18:08 <EvilTerran> it's well clever :D
08:18:36 <EvilTerran> (note Omega = Y I
08:18:50 <faxathisia> from google, I would take a guess that System F can't encode Y
08:19:10 <faxathisia> I would like to know though
08:19:35 <EvilTerran> system F is haskell minus typeclasses, ADTs, and primative recursion, right?
08:19:55 <EvilTerran> you need at least one of those to express fix, i think
08:20:04 <oerjan> system F is also (strongly) normalizing
08:20:06 <faxathisia> I don't think you can write   y f = f (y f)   though, you need to do like  y = \ ...
08:20:18 <Saizan> EvilTerran: adts can be church-encoded with rankN types though
08:20:36 <faxathisia> The only reason you can type fix in haskell is because you can have two different expressions unified
08:20:45 <EvilTerran> when not stated otherwise, by "System F" do we mean "System F_omega"?
08:21:03 * oerjan is not sure what F_omega is
08:21:36 <Saizan> EvilTerran: i think it usually means System F_2, however if it's strong normalizing it can't have fix
08:21:59 <faxathisia> STLC is system F1
08:22:23 <faxathisia> F_omga is the union of them all the System F_n's
08:22:29 <Saizan> EvilTerran: rank /= order if the question was related
08:22:57 <EvilTerran> Saizan, no, not really
08:23:03 <EvilTerran> but okay
08:23:45 <EvilTerran> hehe, "F_omga"
08:24:11 <EvilTerran> "f- OMG, aaargh!"
08:24:20 <EvilTerran> (I'm in a silly mood)
08:24:30 <faxathisia> lol, so much easier to just type Fω
08:25:42 <EvilTerran> if your input method supports it, sure. i'm too lazy to open the character map and can't remember the Alt+code
08:30:35 <Saizan> too bad type inference for System F is impossible
08:31:52 <EvilTerran> is it? i thought it was just intractable
08:31:52 <MonsterCom> what does poop taste like?
08:32:17 <oerjan> @where ops
08:32:18 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
08:32:23 <Deewiant> @bot
08:32:24 <lambdabot> :)
08:32:24 <faxathisia> What does intractable mean in this context?
08:32:26 <Deewiant> yay
08:32:43 --- mode: ChanServ set +o allbery_b
08:32:45 <EvilTerran> taking superpolynomial time to solve
08:33:20 <EvilTerran> (or superexponential, or some such sensible cut-off one could describe as "too damn long")
08:33:26 <oerjan> hindley-milner is already superpolynomial in principle
08:33:30 <Saizan> http://en.wikipedia.org/wiki/System_F#Use_in_programming_languages <-- well, it's still open it seems
08:33:31 <lambdabot> http://tinyurl.com/2d5f9v
08:33:44 --- mode: allbery_b set -o allbery_b
08:33:49 <bos> oerjan: hm?
08:33:56 <EvilTerran> hooray for opers
08:33:57 <bos> ah
08:34:16 <oerjan> the algorithm, at least...
08:34:27 <EvilTerran> hmm
08:34:41 <allbery_b> nalioth++
08:34:41 <oerjan> bos: or so i heard
08:34:57 <conal> what's nalioth?
08:35:04 <EvilTerran> * MonsterCom has quit (Killed by nalioth ())
08:36:02 <oerjan> Saizan: that's not how i read that
08:36:12 <conal> what's a naliaoth and how did it kill MonsterCom?
08:36:24 <oerjan> type checking is decidable, type inference is undecidable
08:36:36 <oerjan> conal: probably an ircop?
08:36:43 <Saizan> oerjan: yes, sorry, i was mistranlating settled
08:37:39 * conal still doesn't know the irc ecosystem
08:37:45 <oerjan> i=nalioth@freenode/staff/ubuntu.member.nalioth
08:43:14 <Deewiant> anybody implemented 'glob' in haskell, or do I have to make the attempt?
08:43:34 <conal> Deewiant: 'glob'?
08:44:07 <Deewiant> matching files in a directory
08:44:28 <Saizan> there's a lib to find files on hackage
08:44:30 <Deewiant> like "ls *.txt" gets you all the .txt files in a directory on a standard posix shell
08:44:44 <conal> Deewiant: got it.  thanks.
08:45:20 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip-0.3.1
08:45:22 <lambdabot> http://tinyurl.com/27egrb
08:45:42 <Deewiant> Saizan: that appears to be it, thanks
08:47:12 <Deewiant> although hmm, it appears to always use the current directory
08:49:32 <Deewiant> ... but that's not a problem, duh. Just prefix the directory I want to the pattern. *headslap*
08:50:46 <FunctorSalad> I can't seem to get non-greedy regexps to work (in Text.Regex.Posix)
08:50:57 <wli> Translate the globbing pattern to a regex, then just use regexes.
08:51:25 <wli> Easier said than done, of course.
08:53:41 <Deewiant> It's probably easier to just glob ;-)
08:54:03 <wli> I see now that you found something that does globbing for you.
08:54:24 <Deewiant> Yes, thus it's that much easier.
08:58:10 <Deewiant> Ah, crap. It requires unix.
08:58:48 <Deewiant> And it's LGPL.
08:59:07 <Deewiant> guess I have to do it myself after all.
08:59:11 <radix> the hackage page says BSD3
08:59:31 <radix> but I guess the unix thing is a bummer.
08:59:36 <Deewiant> hm, the source says LGPL
08:59:46 <Deewiant> and yet it comes with the BSD license :-P
09:00:02 <radix> Deewiant: python has a glob module which translates globs to regexes first. that'd probably be pretty easy to port.
09:00:05 <Deewiant> the unix thing doesn't really matter, since it's not required for the glob stuff, but for other stuff the lib comes with
09:00:14 <radix> ah. right.
09:00:42 <Deewiant> and since it does appear to be BSD3, I guess I can incorporate only the glob stuff into my proggy
09:00:46 <radix> LGPL is pretty non-restrictive, though. the only time I've seen people unable to use it is when their company has some pointless policy.
09:00:50 <idnar> radix: that transformation is pretty hairy
09:01:00 <radix> idnar: yeah, sure, but it's already written :)
09:01:14 <idnar> the main problem with LGPL is when you want to distribute the equivalent of statically linked binaries :P
09:01:42 <idnar> radix: assuming it actually works
09:01:47 <Deewiant> the LGPL is too confusing, never know where you can use it :-P
09:02:26 <radix> the main thing is that if you distribute modifications to the library you have to make source available.
09:02:53 <taruti> radix: or if you distribute the library unmodified.
09:03:09 <radix> taruti: well, sure. but then making the source available is "see http://original/site"
09:03:17 <idnar> radix: that's not really sufficient
09:03:18 <Deewiant> @tell bos System.FilePath.Glob /is/ BSD3, right?
09:03:18 <lambdabot> Consider it noted.
09:03:20 <taruti> radix: that might not be enough
09:03:28 <idnar> http://original/site might vanish from the interwebs at any moment
09:03:36 <idnar> I would say that the main thing is that if your application isn't "dynamically" linked to the library, you need to distribute your whole application under the terms of the LGPL
09:03:50 <Deewiant> exactly, and that's a problem with windows
09:04:04 <Deewiant> unless there's an easy way of compiling haskell to DLLs
09:04:11 <bluestorm> hm
09:04:30 <bluestorm> i'm looking for a simple haskell parser (that can parse the haskell language)
09:04:39 <bluestorm> even haskell98 only, the simplest possible
09:04:46 <bluestorm> i've looked at GHC, YHC and Helium sources
09:04:54 <bluestorm> do you have any other suggestion ?
09:05:01 <oerjan> bluestorm: Language.Haskell
09:05:01 <LoganCapaldo> import Language.Haskell
09:05:04 <bluestorm> hm
09:05:16 <bluestorm> that's the Happy/GHC interface ?
09:05:18 <radix> no no no. you only have to make the *object* files of your program available, when you statically link with the LGPL library.
09:05:30 <radix> of course, it's hairy because it's very C-centric.
09:05:57 <radix> anyway. IANAL, and this is off-topic, and I need to get on a flight to portland.
09:06:01 <radix> but read the LGPL :)
09:07:08 <daveux> Hey, I can't figure out why I'm getting "Occurs check: cannot construct the infinite type: e = [[e]]" on http://www.paste2.org/p/12968
09:07:46 <bluestorm> hm
09:07:49 <LoganCapaldo> bluestorm: i don't think it's specific to ghc, I belive hugs has that module as well
09:07:57 <resiak> :t elem
09:07:59 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
09:08:06 <bluestorm> that's strange, the location datatypes only record one position in a file :p
09:08:16 <resiak> i think you have the arguments to elem backwards
09:08:16 <bluestorm> LoganCapaldo: ok, thanks
09:08:19 <resiak> and, why is that pure function in IO?
09:08:45 <daveux> ? I don't know.
09:08:50 <daveux> I am new to this.
09:09:43 <daveux> That was it - the elem
09:09:49 <daveux> thanks, resiak
09:09:55 <resiak> you could replace "error ...." with Nothing, and IO with Maybe!
09:11:04 <hpaste>  FunctorSalad pasted "This non-greedy regexp doesn't work" at http://hpaste.org/5437
09:11:11 <LoganCapaldo> or you replace the error with fail and the IO with any monad :)
09:11:20 <resiak> well, yeaoh
09:11:36 <resiak> except that the error message is basically meaningless here
09:12:14 <LoganCapaldo> Well if you change the type to Maybe it's basically menaningless
09:12:20 <Botje> FunctorSalad: does Posix support non-greedy regexps?
09:12:26 <daveux> I'm just doing what my instructor asked!
09:12:41 <FunctorSalad> Botje: hmm I thought it should at least with the "extended" option
09:12:46 <daveux> Once i understand this IO stuff more, I could fix it up.
09:12:47 <LoganCapaldo> but iif its Either String or similar and amonst a whole bunch of other, possibly failing operations, you might want to know at which point did it fail
09:12:49 <allbery_b> non-greedy isn't POSIX, it's PCRE
09:12:52 <Botje> daveux: if your instructor is telling you to write everything in IO, get another instructor :)
09:13:09 <daveux> No, he's good - Benjamin Pierce
09:13:29 <resiak> as in TaPL?!
09:13:34 <daveux> Yes.
09:13:45 <resiak> ace!
09:13:59 <FunctorSalad> allbery_b: hmm ok. thought it was normal posix vs. extended posix, sorry
09:14:10 <allbery_b> no, it's POSIX BREs vs. POSIX EREs
09:14:14 <Gwern-away> hee hee
09:14:32 <allbery_b> (basically a hack to handle both sed/grep-style and awk/egrep-style regexps)
09:15:37 <olsner> hmm, actually learning the difference between BRE and ERE would save a lot of trial-and-error with where to put backslashes
09:16:04 <FunctorSalad> hmm I don't get it, were you correcting my use of the word "normal" rather than "extended" there?
09:16:16 <FunctorSalad> err, rather than "basic"
09:17:10 <allbery_b> "extended" doesn't mean extensions to POSIX
09:17:38 <allbery_b> POSIX defines two kinds of regular expressions, BRE and ERE.  this is because it's dealing with two kinds of traditional Unix regexps
09:17:49 <allbery_b> sed and grep use one style, awk and egrep the other
09:17:59 <allbery_b> so POSIX defines both BREs and EREs
09:19:50 <FunctorSalad> I didn't really mean to imply that they were an extension to POSIX, but anyway =)
09:21:25 <allbery_b> and non-greedy matches were originally invented by/for perl, so pcre is the easiest way to get them
09:21:41 <FunctorSalad> I was just saying I mistakenly assumed that non-greediness \in ERE \setminus BRE, rather than non-greediness \in PCRE \setminus (ERE \cap BRE)
09:21:46 <FunctorSalad> yes, installing it now
09:22:10 <FunctorSalad> or \cup, even. -.-
09:23:58 <olsner> you should've defined \union to \cup though
09:27:29 <FunctorSalad> hmm? you mean semantic names are better?
09:27:39 <FunctorSalad> latex seems to mix both
09:27:41 <olsner> yeah
09:28:54 <ddarius> LaTeX is about presentation.  You provide semantics.
09:32:57 <TauPan> re
09:36:35 <FunctorSalad> ddarius: I meant that some symbols already have semantic names, like \setminus or \mapsto
09:48:14 <bos> Deewiant: yes
09:48:14 <lambdabot> bos: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:48:46 <Deewiant> bos: alright, great. The source files still say they're LGPL
09:49:22 <bos> oh, bugger.
09:53:48 <keseldude> so is it possible to build lambdabot with ghc 6.8.2?
09:55:05 <bos> Deewiant: i just uploaded a new version with the docs fixed.  thanks.
09:55:47 <Deewiant> bos: no problem, thanks to you as well :-)
09:56:17 <olsner> keseldude: there's a patch, google it
09:57:23 <eugman> So, for small personal projects which do you prefer lhs or haddock? Or is the premide inherantly incorrect?
09:57:37 <keseldude> ok thanks olsner
09:58:35 <phobes> Anyone know of any result stating that 'StateT s Cont b a'  is in some sense a universal Monad?
09:59:35 <phobes> Well, I suppose 'StateT s Cont b' is the Monad, but anyway...
09:59:50 <b_jonas> oh noes. I must have still be missing some tool
10:00:17 <b_jonas> I've installed ghc but it couldn't make the html docs
10:00:37 <allbery_b> haddock
10:00:41 <thoughtpolice> keseldude: for the most part you should be able to but there's some thing with 6.8.2 and newtype deriving that causes an error
10:00:55 <thoughtpolice> but as far as I know that's the only thing you should have an issue with.
10:00:59 <thoughtpolice> and it's a simple change
10:01:03 <keseldude> ok
10:01:07 <b_jonas> allbery_b: no, I've installed haddock and four other packages
10:01:24 <paolino> :t runCont $ callCC ($1)
10:01:25 <b_jonas> three mentioned in the README, and two I figured out from the configure warnings
10:01:26 <lambdabot> forall r b. (Num b) => (b -> r) -> r
10:01:49 <paolino> what should (b -> r) be ?
10:02:57 <Deewiant> @ty runCont $ callCC ($1) id
10:02:58 <lambdabot>     No instance for (MonadCont ((->) (a -> a)))
10:02:58 <lambdabot>       arising from use of `callCC' at <interactive>:1:10-23
10:02:58 <lambdabot>     Possible fix:
10:03:11 <Deewiant> hmn
10:03:12 <hpaste>  b_jonas pasted "the configure warnings " at http://hpaste.org/5438
10:03:14 <Deewiant> @instances MonadCont
10:03:15 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
10:03:16 <paolino> a function from an Num to ....
10:03:44 <Deewiant> doesn't look like that can work, since it needs to be an instance of MonadCont as well, or I'm confused
10:03:45 <phobes> to whatever the Cont monad is computing
10:03:49 <b_jonas> does that one about xmllint count?
10:04:00 <b_jonas> 'WARNING: cannot find xmllint in your PATH, you will not be able to validate your documentation'
10:04:05 <b_jonas> do I need xmllint?
10:04:15 <Deewiant> do you need to validate your documentation? :-P
10:04:33 <b_jonas> Deewiant: I don't think so, but it hasn't installed it
10:04:54 <Deewiant> then the install script is anal, I guess
10:05:15 <paolino> phobes , can you explain more ?
10:05:25 <phobes> @ty (runCont $ callCC ($1)) (+2)
10:05:26 <lambdabot> forall b. (Num b) => b
10:05:30 <phobes> > (runCont $ callCC ($1)) (+2)
10:05:32 <lambdabot>  3
10:05:41 <paolino> uh , those parens
10:05:48 <phobes> heh
10:05:51 <paolino> I used ($)
10:06:00 <phobes> I study haskell more than I program in it :)
10:06:01 <allbery_b> sounds like Andrzej Filinski's thing
10:06:10 <phobes> > runCont $ callCC ($1) $ (+2)
10:06:10 <lambdabot>   add an instance declaration for (Num (Cont r a))
10:06:23 <phobes> > runCont $ callCC ($1) $$ (+2)
10:06:24 <lambdabot>  Couldn't match expected type `Doc' against inferred type `m b'
10:06:43 <Deewiant> > runCont (callCC ($1)) (+2)
10:06:44 <lambdabot>  3
10:06:45 <phobes> $ is assoc the wrong way... I don't see how you do without hte parens
10:06:51 <phobes> I guess that's one way
10:07:20 <Deewiant> > flip runCont (+2) $ callCC ($1)
10:07:20 <lambdabot>  3
10:07:21 <Deewiant> :-P
10:07:30 <phobes> paolino: but it's polymorphic in b, so you can also do:
10:08:30 <TauPan> that $ thing confuses me... what's wrong with parens?
10:08:50 <phobes> @ty concat
10:08:51 <lambdabot> forall a. [[a]] -> [a]
10:08:54 <Deewiant> well, f $ g $ h $ i $ j $ k is often nicer than f (g (h (i (j (k)))))
10:08:57 <Zao> TauPan: It reduces the lispyness.
10:09:35 <resiak> f . g . h . i . j $ k is nicer :)
10:09:50 <faxathisia> resiak: Why?
10:09:58 <TauPan> oh dear
10:09:59 <Deewiant> but then you have to edit further if you remove k from the end
10:10:00 <phobes> > (runCont $ callCC ($1)) (\b -> [b, 1])
10:10:03 <lambdabot>  [1,1]
10:10:12 <resiak> faxathisia: less visually noisy
10:10:16 <phobes> That's a boring example of a different b
10:10:26 <phobes> err different r
10:10:27 <ricky_clarkson> TauPan: $ lets you concentrate on flow instead of nesting.
10:10:34 <Deewiant> in general, they're not one-letter functions so it doesn't really matter whether it's . or $ IMHO
10:11:00 <olsner> or e k = (f . g . h . i . j) k, and then you make the function pointsfree by removing k
10:11:28 <phobes> or  Cale likes  f .g h. i. j $ k  ( I think()
10:11:30 <Deewiant> but, of course, it's not always that simple :-)
10:12:24 <phobes> These things are important if you're composing 15 functions without naming any intermediaries as one often does in #haskell
10:12:37 <olsner> if it's not already that simple, you have to *make* it that simple by introducing the right helper functions ;-)
10:12:42 <phobes> I don't think the style is particularly illuminating in practice though
10:13:08 <paolino> phobes: do you think StateT s Cont r is suitable for an undo (and redo possibly) on the state ?
10:13:26 * TauPan mumbles something...
10:13:29 <phobes> I think 'StateT s Cont r' is suitable for anything :)
10:13:48 <phobes> TauPan:  Was that at me?  I could be wrong...
10:14:13 <notpalomer> dcoutts_, you around?
10:14:34 <TauPan> nah, I have no clue what you are talking about... I just don't get warm easily with languages that have a lot of syntax.
10:15:17 <phobes> TauPan:  oh, then that wasn't at me.  I'm not a big fan of $
10:15:21 <TauPan> :)
10:15:58 <Deewiant> one place where brackets look onerous is wrapped around do-expressions
10:16:50 <phobes> Deewiant:  You're talking about applying a monad expression as a function?
10:17:10 <litb> why not
10:17:10 * TauPan continues reading "Haskell for Miranda Programmers"
10:17:27 <Deewiant> phobes: I think so, yes. ;-)
10:18:25 <litb> > do { x<-(*2); y<-(+2); z<-(**2); return(x, y, z) } $ 10
10:18:27 <lambdabot>  (20.0,12.0,100.0)
10:19:09 <Deewiant> phobes: Or actually, not. Rather, using a monad expression as an argument to a function. But that works too. :-P
10:19:12 <nolrai> > [7,6 .. 0]
10:19:12 <lambdabot>  [7,6,5,4,3,2,1,0]
10:19:20 <nolrai> > [7 .. 0]
10:19:20 <lambdabot>  []
10:20:15 <TauPan> > (do { x<-(*2); y<-(+2); z<-(**2); return(x, y, z) }) 10
10:20:16 <lambdabot>  (20.0,12.0,100.0)
10:20:38 <TauPan> *shrug*
10:20:39 <b_jonas_> could anyone actually install the html documentation of ghc from source?
10:21:01 <phobes> > do { x<-(*2); y<-(+2); z<-(**2); return(x, y, z) } 10
10:21:01 <lambdabot>  Parse error at "10" (column 52)
10:23:59 <mux> @dice 69d27
10:23:59 <lambdabot> 69d27 => 1028
10:24:20 <Deewiant> @dice 3d4+1
10:24:21 <lambdabot> 3d4+1 => 5
10:24:36 <Deewiant> @dice 2d(1d6)
10:24:36 <lambdabot> unexpected "(": expecting number
10:24:52 <faxathisia> @die 99d99
10:24:52 <lambdabot> 99d99 => 4934
10:24:53 <notpalomer> onKeyPress isn't catching a-z, is this normal?
10:25:13 <notpalomer> (it's catching shift and capslock, though)
10:26:33 <nolrai> @die 2d6
10:26:33 <lambdabot> 2d6 => 5
10:26:36 <nolrai> @die 2d6
10:26:37 <lambdabot> 2d6 => 3
10:26:40 <nolrai> @die 2d6
10:26:40 <lambdabot> 2d6 => 3
10:26:42 <nolrai> @die 2d6
10:26:43 <lambdabot> 2d6 => 11
10:27:20 <b_jonas> @die 4d6 ignore lowest
10:27:20 <lambdabot> unexpected "i": expecting digit, "+" or end
10:27:59 <b_jonas> @die 4d6 drop lowest
10:28:00 <lambdabot> unexpected "d": expecting digit, "+" or end
10:28:20 <faxathisia> @die 99d99
10:28:21 <lambdabot> 99d99 => 4788
10:29:05 <bogner> @die 5d23
10:29:05 <lambdabot> 5d23 => 77
10:29:35 <b_jonas> if no-one could install it, that's a bad sign
10:30:28 <paolino> phobes: can you show me a evalStateT runCont example please ?
10:35:51 <ddarius> phobes: As allbery_b suggested, what you are looking for is Filinski's "Representing Monads"
10:37:14 <b_jonas> when building ghc from source, how (what configure parameter) do I make it use a specific perl executable?
10:38:55 <litb> what the heck is @die ?
10:39:23 <allbery_b> @help die
10:39:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:39:27 <allbery_b> @help dice
10:39:27 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
10:40:16 <olsner> > take 10 (fix$(.)<$>(:)<*>((.((:[]).))(=<<).(*))$2)
10:40:17 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
10:40:42 <faxathisia> sick
10:40:52 <ddarius> You missed 1
10:40:59 <olsner> yeah, that's unfortunate
10:41:01 <faxathisia> > 1:(fix$(.)<$>(:)<*>((.((:[]).))(=<<).(*))$2)
10:41:01 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:41:35 <olsner> > take 10 (fix$(.)<$>(:)<*>((.((:[]).))(=<<).(*).(*2))$1)
10:41:36 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
10:42:36 <ddarius> > iterate (2*) 1
10:42:36 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
10:43:09 <olsner> pfft!
10:43:40 <nominolo> > getAll mempty
10:43:40 <lambdabot>  True
10:46:14 <nominolo> > getSum mempty
10:46:14 <lambdabot>  0
10:46:30 <b_jonas> solved the perl subproblem
10:46:40 <b_jonas> but someone please still help me about the docs
10:52:21 <faxathisia> Hi Mortomes :)
10:52:30 <Mortomes> Hi faxathisia
10:53:10 <Mortomes> And arjanb :P
10:55:46 <litb> > fmap (do { x<-(*2); z<-(+3); return (x, z); }) [1..5]
10:55:47 <lambdabot>  [(2,4),(4,5),(6,6),(8,7),(10,8)]
10:56:41 <bluestorm> hm
10:56:53 <bluestorm> this may sounds like a dummy question but do you know a nice indenter for haskell ?
10:57:16 <bluestorm> i have a Haskell source code in a file, i'd like to have it correctly indented
10:57:35 <b_jonas> I don't really see how one could have an indenter for a language where indents are significant
10:57:41 <bluestorm> hmm
10:58:03 <nominolo> > getDual $ getAll mempty
10:58:03 <lambdabot>  Couldn't match expected type `Dual a' against inferred type `Bool'
10:58:27 <bluestorm> actually, the source file is a big algebraic data type declaration
10:58:30 <litb> :t mempty
10:58:34 <litb> what is it?
10:58:34 <lambdabot> forall a. (Monoid a) => a
10:58:37 <bluestorm> hm
10:58:43 <litb> is it like mzero?
10:58:50 <litb> the neutral element of an Monoid?
10:59:00 <ddarius> @src Monoid
10:59:00 <lambdabot> class Monoid a where
10:59:00 <lambdabot>     mempty  :: a
10:59:00 <lambdabot>     mappend :: a -> a -> a
10:59:00 <lambdabot>     mconcat :: [a] -> a
10:59:30 <litb> > mappend 1 mempty
10:59:30 <lambdabot>  Add a type signature
10:59:36 <litb> > mappend 1 mempty :: Int
10:59:37 <lambdabot>   add an instance declaration for (Monoid Int)
10:59:37 <lambdabot>     In the expression: mappend...
10:59:38 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5439
10:59:39 <litb> well
10:59:48 <idnar_> @instances Monoid
10:59:48 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
10:59:56 <idnar_> > mappend 1 mempty :: [Int]
10:59:56 <lambdabot>   add an instance declaration for (Num [Int])
10:59:58 <litb> i thought (N, +, 0) is a Monoid
11:00:05 <idnar_> oh heh
11:00:07 <ddarius> litb: It is.
11:00:09 <b_jonas> > mappend (Sum 1) mempty
11:00:10 <lambdabot>  Sum {getSum = 1}
11:00:18 <b_jonas> > mappend (Sum 1) (Sum 2)
11:00:18 <lambdabot>  Sum {getSum = 3}
11:00:31 <b_jonas> > mappend (Product 1) (Product 2)
11:00:31 <lambdabot>  Product {getProduct = 2}
11:00:44 <b_jonas> numbers are monoids in those two ways
11:00:55 <litb> oh, with Product or Sum you specify the operation for that Monoid?
11:00:57 <litb> :t Sum
11:00:58 <lambdabot> forall a. a -> Sum a
11:01:09 <ddarius> Numbers are monoids in -many- ways
11:01:17 <litb> oh rite
11:01:34 <nominolo> @pl \x y -> Product x `mappend` Product y
11:01:35 <lambdabot> (. Product) . mappend . Product
11:01:51 * wli throws out cardinals and ordinals for consideration there.
11:02:04 <nominolo> > let x * y -> Product x `mappend` Product y in 3 * 4
11:02:04 <lambdabot>  Parse error at "->" (column 11)
11:02:11 <bluestorm> how is "Sum a" defined for any a ?
11:02:11 <nominolo> > let x * y = Product x `mappend` Product y in 3 * 4
11:02:12 <lambdabot>  Product {getProduct = 12}
11:02:19 <b_jonas> I wonder why there's no similar wrapper for any Ord that returns the smaller/larger value
11:02:35 <b_jonas> though one could write it if he needs it of course
11:02:42 <nominolo> @pl \ x y -> getProduct $ Product x `mappend` Product y
11:02:42 <lambdabot> (getProduct .) . (. Product) . mappend . Product
11:02:45 <ddarius> There should be a Max somewhere.
11:02:54 <ddarius> @hoogle Max
11:02:54 <lambdabot> Prelude.max :: Ord a => a -> a -> a
11:02:55 <lambdabot> Data.Ord.max :: Ord a => a -> a -> a
11:02:55 <lambdabot> Prelude.maxBound :: Bounded a => a
11:02:58 <ddarius> @hoogle Min
11:02:59 <lambdabot> Prelude.min :: Ord a => a -> a -> a
11:02:59 <lambdabot> Data.Ord.min :: Ord a => a -> a -> a
11:02:59 <lambdabot> Distribution.System.MingW :: Windows
11:03:00 <wli> b_jonas: IIRC min and max exist, along with list versions minimum and maximum
11:03:17 <b_jonas> wli: but as a Monoid wrapper I mean
11:03:30 <b_jonas> like First and Last and All and Any and Sum and Product
11:03:34 <litb> i've not done anything with newtype yet
11:03:40 <wli> What does ordering have to do with monoids?
11:03:46 <ddarius> :t Data.Sequence.Max
11:03:47 <lambdabot>     Not in scope: data constructor `Data.Sequence.Max'
11:03:50 <ddarius> :t Data.Sequence.Min
11:03:51 <lambdabot>     Not in scope: data constructor `Data.Sequence.Min'
11:04:09 <idnar> (N, max, 0) or something
11:04:13 <b_jonas> wli: I think it actually also needs to be bounded
11:04:28 <b_jonas> any Ord-ered type with min is a semigroup
11:04:37 <b_jonas> but it's a monoid only if it has a minimal element
11:04:43 <ddarius> @instances-importing Data.Sequence Monoid
11:04:43 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Seq a, Sum a, [a]
11:04:44 <b_jonas> so maybe that's why
11:05:02 <litb> well, they make "instance (Num a) => Monoid (Sum a) where ..." i suppose
11:05:10 <bparkis> hey, so I don't know how many of you were here for my discussion with sarehu last night
11:05:19 <litb> or maybe even Integer
11:05:46 <b_jonas> @src Sum Monoid
11:05:46 <lambdabot> Source not found. Take a stress pill and think things over.
11:05:52 <b_jonas> @src Sum mappend
11:05:52 <lambdabot> Source not found. Maybe you made a typo?
11:06:13 <bparkis> but it was about how to express the "essence" of sorting so that you can distinguish between all functions that performs sorting "in some sense" (independently of the format in which the input and output sequences are represented)
11:06:19 <wli> b_jonas: Something specious is going on there.
11:06:31 <litb> @src Sum `mappend`
11:06:31 <lambdabot> Source not found. Do you think like you type?
11:06:32 <litb> hm
11:06:57 <wli> b_jonas: I suspect there is a theorem about finite monoids.
11:07:07 <litb> well what role does mconcat play in math?
11:07:20 <bparkis> f :: A -> A performs sorting "in some sense" if there exists a functions g :: A -> C (where C is the set of permutations of monotonic non-decreasing integer sequences with jumps of no more than 1, beginning with 1) such that f(x) = y implies g(y) == sort(g(x)), and g is onto
11:08:25 <bparkis> now I can generalize that definition to say when a function f is an "encoding" of some function d
11:08:42 <wli> b_jonas: Consider <x>, the orbit of x, in a finite monoid for an arbitrary x /= e.
11:09:35 <bparkis> f :: A -> A is an "encoding" if some function d :: B -> B iff there exists an onto function g:: A -> B such f(x) = y implies g(y) = d(g(x))
11:09:43 <litb> ah i see
11:09:49 <bparkis> this captures, among other things, the notion of Turing completeness
11:10:20 <bparkis> a function is Turing complete if it is an "encoding" of a Turing machine
11:10:36 <bparkis> (with some futzing around with the definition of Turing machine to give it a type of A->A)
11:10:45 <bparkis> or B->B
11:11:03 <litb> > mconcat [ (Sum x) | x <- [1..10] ]
11:11:03 <lambdabot>  Sum {getSum = 55}
11:11:27 <litb> however, now all this Monoid and stuff isn't really of use, or?
11:11:55 <litb> only to have a mathematically good reasoned language i suppose
11:12:05 <b_jonas> litb: not that I know
11:12:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5440
11:12:36 <nominolo> @index comparing
11:12:36 <lambdabot> bzzt
11:12:48 <b_jonas> but after all the tricks that haskell guys do with classes, they probably find some use
11:13:01 <litb> is there also a class "Ring" ?
11:13:44 <litb> i wonder why it has Monoid, but lacks Ring and the others
11:14:31 <monochrom> Monoid is to support Writer.
11:14:44 <b_jonas> Num is sort of like Ring, isn't it?
11:14:51 <b_jonas> @src Num
11:14:51 <lambdabot> class  (Eq a, Show a) => Num a  where
11:14:51 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:14:51 <lambdabot>     negate, abs, signum     :: a -> a
11:14:51 <lambdabot>     fromInteger             :: Integer -> a
11:14:55 <monochrom> Ring hasn't found an application yet.
11:15:07 <b_jonas> that looks like Ring if you ignore the abs
11:15:13 <bparkis> for instance, let B be the set of ordered pairs of ((the set of all FSM's), (the set of all tape states))
11:15:17 <b_jonas> and the signum
11:15:32 <bparkis> then d :: B -> B could be a Turing machine
11:15:33 <monochrom> Num is very close to Ring. Users tend to use Num with some grumble.
11:15:41 <litb> i see
11:15:53 <bparkis> and if f :: A -> A satisfies the condition above, it would be an encoding of a Turing machine
11:16:20 <wli> Never mind, monoids aren't necessarily cancellative.
11:16:37 <bparkis> er, B is the set of ordered pairs of (x, y) where x is IN the set of all FSM states and y is IN the set of all tape states
11:16:45 <bparkis> and there should be a failure state for the Turing machine too
11:17:03 <SamB> how about Field. can we have Field?
11:17:07 <bparkis> or that could simply be encoded as a tape character
11:17:11 <bparkis> similar to termination
11:17:25 <monochrom> @src RealFrac
11:17:26 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
11:17:26 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
11:17:26 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
11:17:38 <monochrom> Fractional is very close to Field
11:17:53 <b_jonas> @src Fractional
11:17:53 <lambdabot> class  (Num a) => Fractional a  where
11:17:53 <lambdabot>     (/)             :: a -> a -> a
11:17:53 <lambdabot>     recip           :: a -> a
11:17:53 <lambdabot>     fromRational    :: Rational -> a
11:18:08 <b_jonas> looks like it
11:18:08 <SamB> It might be if Num were closer to Ring....
11:18:53 <monochrom> > (delete 'F' . delete 'c') "Fractional"
11:18:53 <lambdabot>  "rational"
11:18:56 <ddarius> There wouldn't be a Monoid class if it wasn't useful.
11:18:58 <monochrom> See? :)
11:19:38 <b_jonas> @src Real
11:19:38 <lambdabot> class  (Num a, Ord a) => Real a  where
11:19:38 <lambdabot>     toRational      ::  a -> Rational
11:19:53 <faxathisia> @oeis 2 8 18 32 50 72
11:19:57 <ddarius> Graham Priest practices the same martial art that I did.
11:19:59 <lambdabot> Sequence not found. The more you drive -- the dumber you get.
11:20:27 <b_jonas> wtf
11:21:03 <ddarius> b_jonas: The OEIS site is down
11:21:11 <b_jonas> oh, so that's why
11:21:26 <faxathisia> anyone know the sequence?
11:21:30 <b_jonas> because buubot says "Reply from OEIS in unknown format" when I use its oeis query
11:21:41 <monochrom> haha unknown format
11:21:47 <bos> @hoogle unsafeIOToSTM
11:21:47 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
11:22:16 <Deewiant> @google "2 8 18 32 50 72
11:22:18 <lambdabot> http://www.inner.org/responsa/leter1/resp33.htm
11:22:19 <lambdabot> Title: The Number 18
11:22:26 <bluestorm> hm
11:22:38 <bluestorm> is there an accessible introduction to Data.Generics ?
11:22:39 <Deewiant> > map (\n -> 2*n*n) [1..
11:22:39 <lambdabot>  Parse error at end of input
11:22:41 <Deewiant> > map (\n -> 2*n*n) [1..]
11:22:41 <lambdabot>  [2,8,18,32,50,72,98,128,162,200,242,288,338,392,450,512,578,648,722,800,882,...
11:22:43 <b_jonas> try 2*n^2
11:22:55 <ddarius> bluestorm: The Scrap Your Boilerplate papers.
11:22:58 <b_jonas> faxathisia: highlight
11:22:58 <bluestorm> hm
11:23:06 <Deewiant> @pl \n -> 2*n*n
11:23:06 <lambdabot> (*) =<< (2 *)
11:23:14 <Deewiant> ew
11:23:17 <faxathisia> oooh
11:23:22 <bluestorm> ddarius: can i, say, read only the first one, and use the lib (for a simple use) from that ?
11:23:28 <faxathisia> thanks
11:23:43 <bluestorm> because if the second reworks half the things the first explained... :p
11:24:06 <ddarius> bluestorm: Each paper covers different things.  You don't need to read the entirety of each paper.
11:24:17 <bluestorm> ok, thanks
11:24:29 <b_jonas> but it sucks that the site is down
11:24:56 <djfroofy> afternoon haskellers
11:25:25 <nominolo> :t map (undefined :: Int -> Int -> Int) (undefined :: [Int])
11:25:26 <lambdabot> [Int -> Int]
11:25:45 <djfroofy> i'm trying to work with binary data in haskell to implement a protocol
11:26:11 <djfroofy> so i found this quote on LTU which scared me: "Trying to do binary IO in Haskell with the standard functions is horribly painful ..."
11:26:25 <ddarius> djfroofy: Use the Data.Binary library
11:26:28 <ddarius> @hackage binary
11:26:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
11:26:52 <djfroofy> ddarius: thanks, i'll look into that
11:27:55 <ddarius> djfroofy: Note that for implementing a protocol, you don't want to use the Binary class, but rather the direct get*/put* functions.
11:29:24 <djfroofy> ddarius: hmmm ... are you sure I don't want: Data.ByteString?
11:29:35 <allbery_b> you may want that as well
11:29:38 <djfroofy> "Data.Binary is a library for high performance binary serialisation of Haskell data."
11:29:45 <djfroofy> That's not really my use case.
11:29:47 <allbery_b> but Binary is the non-painful I/O stuff
11:30:18 <djfroofy> So I'm reading data from the network of a certain protocol that has nothing to do with haskell data.
11:30:23 <ddarius> djfroofy: Data.Binary uses bytestrings.
11:30:36 <djfroofy> Yeah... but are the packaged separately?
11:30:37 <allbery_b> is it binary data?
11:30:39 <ddarius> djfroofy: That's why you want Data.Binary.Put/Data.Binary.Get
11:30:41 <conal> anybody remember the css directive that makes an element invisible?
11:30:50 <conal> (an html element)
11:30:52 <djfroofy> display: none
11:31:00 <conal> djfroofy: that's it!  thx :)
11:31:07 <allbery_b> you want to convert the protocol's binary data into haskell internal (binary) data
11:31:20 <Deewiant> or visibility: hidden, which is a bit different
11:31:30 <djfroofy> conal: np, my journey through css has been something like Dante's inferno
11:31:54 <thetallguy> djfroofy: that's a given with CSS.
11:32:11 <ddarius> I find this page very handy: http://www.westciv.com/style_master/academy/css_tutorial/
11:32:12 <lambdabot> Title: Complete CSS Guide - Cascading style sheets reference - Contents
11:33:26 <Deewiant> I like http://www.blooberry.com/indexdot/css/propindex/all.htm for a property reference
11:33:26 <lambdabot> Title: All CSS Properties Listed Alphabetically
11:34:07 <Gwern-away> 'This algorithm does of course have exponential complexity in the number of variable flags. At the moment, Cabal does not do any special optimizations, since the number of flags is usually sufficiently low that this shouldn't be an issue. (Having a SAT-solver in Cabal is also not desirable.) ' <-- heh
11:34:35 <Deewiant> exponential complexity in the number of flags? what on earth is it doing?
11:35:31 <olsner> (also, it's wonderful how the expected cabal user is expected to know about SAT problems)
11:35:52 <ddarius> olsner: Don't they?
11:35:54 <b_jonas> please help.
11:36:12 <Botje> with?
11:36:25 <Gwern-away> 3-sat is a standard problem, no?
11:36:34 <notpalomer> I'm going to have a source code tree which I'm going to edit in every which way (tree transformations), I'm thinking of just using a tree with a boat load of IORefs is the easiest way
11:36:36 <Botje> Deewiant: for n flags, you have 2^n possible combinations
11:36:42 <Gwern-away> Deewiant: trying to satisfy sets of conditionals
11:36:43 <notpalomer> are there any other alternatives?
11:37:08 <Deewiant> Gwern-away: for what purpose?
11:37:09 <b_jonas> I'd like to install the html documentation for ghc (the ghc user's guide and the docs for modules)
11:37:23 <b_jonas> I've installed ghc from source and I don't know how to make it install the docs
11:37:23 <Botje> notpalomer: have you looked at some of the generic libs? like syb, uniplate, ..
11:37:27 <olsner> it's a standard problem, yes, but only if your set of known standard problems include 3-SAT ;-)
11:37:44 <notpalomer> gonna check'em out!
11:38:19 <int-e> still, it appears that cabal _does_ include a sat solver, it's just not very smart *g*
11:38:30 <thetallguy> conal: how's the new blog software working out?
11:39:07 <Botje> b_jonas: have you tried make install-docs ?
11:39:12 <b_jonas> Botje: yes
11:39:17 <b_jonas> that didn't help
11:39:54 <conal> djfroofy: :) i like the reference
11:40:03 <Gwern-away> Deewiant: you mean why does cabal have conditionals at all?
11:40:10 <conal> thetallguy: i'm very happy with it
11:40:25 <notpalomer> Botje, those seem to give me generic ways to deal with datatypes
11:40:29 <djfroofy> conal: who doesn't like Dante ;)
11:40:29 <conal> thetallguy: and a little less intimidated with wordpress php
11:40:49 <Botje> notpalomer: and tree walkers and transformations for free, yes
11:41:01 <Deewiant> Gwern-away: I mean, what exactly is it doing trying to satisfy conditionals? Sorry, I'm not very familiar with Cabal :-)
11:41:07 <conal> djfroofy: presumably some of the folks he put into the lower levels of hell ;)
11:41:13 <djfroofy> haha
11:41:26 <Gwern-away> Deewiant: dunno
11:42:35 <djfroofy> Awesome ... I thought I'd be brave and do a darcs checkout of binary and try building
11:42:40 <djfroofy> Setup.lhs: binary.cabal:22: Invalid syntax (no colon after field name)
11:43:24 <djfroofy> I guess my version of cabal is getting long in the tooth?
11:43:35 <nominolo> djfroofy: yep
11:44:08 <notpalomer> are syb and uniplate popular?
11:45:00 <nominolo> notpalomer: depends on use case
11:50:55 <djfroofy> why does "darcs get" have to take soooooooooo long?
11:50:58 <dons> http://reddit.com/r/programming/info/67j9y/comments/ A Haskell Scheme
11:50:58 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
11:51:13 <dons> djfroofy: it depends on the method, but mostly, darcs 1.x doesn't use http pipelining
11:51:21 <dons> darcs 2.0 does, and its a good deal faster getting
11:51:22 <nominolo> Gwern-away: i'd expect a user who knows about complexity to also know what a SAT-solver is
11:51:54 <conal> dons: thanks much for this & other reddit alerts.
11:51:55 <djfroofy> I guess that's why i use mercurial ;)
11:52:35 <conal> dons: i've been wondering: why do you link to the comments page instead of the reddit article itself, e.g., http://reddit.com/goto?id=67j9y ?
11:52:59 <dons> oh, give the article a chance to upmod :)
11:53:02 <monochrom> dons wants you to consider writing a comment or giving a vote too. :)
11:53:09 <dons> right
11:53:26 <ddarius> dons: Jab against Arc or Paul Graham (or both)?
11:53:39 <nominolo> that's the usual way to send a reddit link
11:53:53 <monochrom> IMO no jab, just conveying "every Arc is a Haskell trying to come out" :)
11:54:03 <dons> ddarius: well, i was thinking of a spin on yet another scheme in haskell
11:54:12 <dons> and i noticed he wrote it all since jan 22
11:54:14 <dons> so mm. fun
11:54:29 <dons> more a jab at the arc buzz
11:54:41 <conal> dons: i get comment/vote access right from the top of the reddit article page.  so i guess you want to make the comment/vote suggestion especially clear?
11:55:08 <dons> that's interesting. doesn't the link you passed just redirect?
11:55:19 <ddarius> I need to ask the author how he managed to lack proper tail calls.
11:55:28 <dons> or send him a patch, ddarius :)
11:55:32 <funktio> is there a version of lookup that returns a plain value instead of Maybe?
11:55:34 <conal> dons: not in firefox.  i get a reddit line at the top, plus the article.
11:55:43 <dons> oh, ok. in firefox it just redirects
11:55:55 <dons> funktio: what happens in the not found case?
11:55:56 <monochrom> which browser? which browser?
11:56:04 <b_jonas> wait, arc is released
11:56:09 <b_jonas> oh damn, I missed that
11:56:09 <funktio> dons: it's certain in this case that it will be found
11:56:12 <conal> dons: i meant i *am* in firefox, and i get the reddit header.
11:56:12 <b_jonas> gotta look at it
11:56:19 <b_jonas> thanks for mentioning
11:56:20 <conal> dons: but now i think i really get why the comments link.
11:56:33 <dons> findWithDefault :: Ord k => a -> k -> Map k a -> a
11:56:41 <dons> funktio: where the default is undefined?
11:56:50 <dons> conal: oh, interesting.
11:56:54 <conal> dons: and sometimes i have just gotten the redirect.  i don't know when it does what.
11:56:54 <dons> i wonder why i don't get a header
11:56:55 <ddarius> b_jonas: Set your face to underwhelmed.
11:57:06 <conal> dons: at http://reddit.com/goto?id=67j9y ?
11:57:10 <monochrom> Strange, my firefox just redirects and nothing else. No seeing any reddit. Perhaps it's because I'm 1.5
11:57:14 <notpalomer> uniplate is cool!
11:57:25 <Botje> funktio: if you're sure the element will always be found, fromJust . lookup
11:57:36 <conal> i have firefox 2.0.0.11, btw.
11:57:47 <Botje> otherwise, handle it with the maybe function in Data.Maybe
11:57:51 <funktio> Botje: ok, that's good enough
11:57:57 * monochrom decides to find out in a "real programmer" way.
11:57:58 <funktio> Botje: thanks
11:58:07 <b_jonas> ddarius: a new version of ghc and perl came out not long ago, and also a development release of the new version of ruby, it's just bad timing to release anything like this now
11:58:09 <monochrom> Hmm how do you use netcat (nc) again? :)
11:58:34 <dons>  Lemminian Institute of Technology
11:58:40 <dons> Lemmih: :)
11:58:47 <Botje> put a bag of catnip in front of the port you want it to listen
12:00:19 <monochrom> Damn, I forgot all of HTTP.
12:00:40 <ddarius> HTTP/1.1 GET index.html\n\n
12:01:18 <ray> bad request!
12:01:19 <Botje> GET /foo HTTP/1.1\r\nHost: foo.com\r\n\r\n
12:01:22 <monochrom> If I KISS to http 1.0 and the server doesn't mind, is it just GET index.html ?
12:01:34 <EvilTerran> ddarius, you forgot the Host: !
12:01:46 <ddarius> EvilTerran: I was about to amend to HTTP/1.0
12:01:56 <EvilTerran> use HTTP/0
12:01:59 <bd_> monochrom: you still need Host:
12:02:06 <EvilTerran> "index.html\n\n"
12:02:15 <bd_> just because of all the virtual hosting these days
12:02:45 <ray> \r\n
12:03:15 <kpreid> monochrom: "GET index.html" is HTTP/0.9, which is distinctly different.
12:03:36 <kpreid> monochrom: in that it neither sends nor receives headers.
12:03:46 <dons> would be fun to have the haskeem thingy spit out haskell, and compile with ghc
12:03:53 * monochrom still doesn't "get" it. Pun intended :)
12:03:56 <kpreid> if you want to speak 1.0, you have to say GET /foo HTTP/1.0
12:04:01 <dons> ?users
12:04:01 <lambdabot> Maximum users seen in #haskell: 465, currently: 450 (96.8%), active: 21 (4.7%)
12:04:15 <dons> haskell programmers don't watch the superbowl, i guess
12:04:23 <ddarius> I'm not.
12:04:37 <b_jonas> dons: they leave their irc clients on even if they do
12:04:44 <dons> hehe
12:05:04 <ray> i wouldn't have known it was today if not for my sister
12:05:08 <magnusth> anyone who knows what Windows function that Foreign.Marshal.Alloc.free uses?
12:05:27 <dons> mm.
12:05:31 <nominolo> football (on TV) is boring anyways
12:05:39 <ddarius> I'd imagine it uses C's malloc, so whichever that one uses.
12:05:46 <ddarius> Er free in that case.
12:05:48 <dons> foreign import ccall unsafe "stdlib.h free"    _free    :: Ptr a -> IO ()
12:06:46 <ddarius> If I remember correctly, VirtualAlloc and VirtualFree are the Recommended ones to use nowadays
12:07:43 <monochrom> telnet is a better browser than nc.
12:08:05 <magnusth> ddarius: does malloc and free map to VirtualAlloc/VirtualFree then?
12:08:29 <magnusth> ddarius: can I VirtualFree memory that's been LocalAlloc'ed?
12:09:05 <twanvl> magnusth: no*2
12:09:27 <dons> there may be some other bindings in the Win32 package
12:12:40 <ddarius> http://msdn2.microsoft.com/en-us/library/aa366525%28VS.85%29.aspx
12:12:41 <lambdabot> Title: About Memory Management (Windows)
12:12:43 <monochrom> My firefox 2.0.0.11 on windows doesn't show any reddit bar upon reddit.com/goto's. I'm now thinking it's some plugin.
12:13:44 <monochrom> goto's considered harmful
12:14:15 <SamB> considered harmful considered harmful
12:15:06 <EvilTerran> "considered" harmful
12:16:26 <LoganCapaldo> gotos should not cons their arguments
12:16:41 <dons> heh
12:16:53 <magnusth> ddarius: the API I want to use says to release the result using LocalFree, but System.Win32.Mem doesn't offer a binding to the LocalX functions it seems, do you know if there's a way around that problem (except FFI then)?
12:18:06 <SamB> LoganCapaldo: why the heck not?
12:19:01 <LoganCapaldo> SamB: i dunno, it was a joke
12:19:25 <SamB> also, how could a goto cons it's arguments?
12:20:13 <LoganCapaldo> it continues to be a joke
12:20:23 <LoganCapaldo> forget I said it, I'm sorry
12:21:54 * magnusth can't help but feel that Windows is backwards...
12:23:53 <mrd> swodniW?
12:24:00 <olsner> LoganCapaldo: gotos cons arguments?
12:24:35 <ddarius> magnusth: It should be trivial to make an FFI binding.
12:25:05 <ddarius> LoganCapaldo just feels set upon now.
12:26:32 <magnusth> ddarius: yeah, I suppose, just feels silly to have to
12:26:58 <ddarius> The System.Win32 library is far from complete.
12:27:54 <idnar> SamB: quines considered harmful
12:28:06 <ddarius> That said, as the link I gave above suggests, the Heap functions should be preferred to LocalAlloc/Free.
12:28:20 <magnusth> ddarius: well, it's a ridiculously big API surface to cover I suppose
12:28:27 <SamB> idnar: who the heck considers quines harmful?
12:28:36 <magnusth> yeah, I saw that
12:28:43 <idnar> SamB: well, your quine anyhow
12:28:56 <SamB> idnar: which was?
12:29:16 <SamB> honest, I didn't write the one that consists of "10 LIST"
12:30:08 <b_jonas> quines harmful? then I must have caused lots of harm
12:30:14 <idnar> SamB: < SamB> considered harmful considered harmful
12:30:48 <b_jonas> I've even written quines to loop irc bots
12:31:21 <SamB> b_jonas: thus doing a valuable service to the authors of said bots?
12:31:31 <b_jonas> SamB: no
12:31:37 <sieni> wasn't the original quine something like: "Yields falsehood when preceded by its quotation" yields falsehood when preceded by its quotation.?
12:31:44 <idnar> sieni: yes
12:31:49 <idnar> Quine's paradox
12:32:03 <EvilTerran> argh, my brain
12:32:14 <SamB> that seems the same as the barber paradox
12:32:23 <idnar> Douglas Hofstadter++
12:32:27 <b_jonas> I've written quines in C, perl, J, and probably some other stuff too
12:32:43 <nelhage> But what about brainfuck quines? :)
12:33:04 <LoganCapaldo> i wrote a quine in hq9+
12:33:09 <idnar> SamB: it's more like the Epimenides paradox
12:33:13 <ddarius> > ap(++)show"ap(++)show"
12:33:15 <lambdabot>  "ap(++)show\"ap(++)show\""
12:33:24 <idnar> but of course those are all related
12:34:17 <sieni> SamB: http://en.wikipedia.org/wiki/Quine's_paradox
12:35:50 <ac> Quine's paradox is not a paradox... it yields false ;)
12:36:15 <b_jonas> and in scheme too
12:36:41 <TuringTest> dons: I added a comment to http://hackage.haskell.org/trac/ghc/ticket/1168
12:36:43 <lambdabot> Title: #1168 (Optimisation sometimes decreases sharing in IO code) - GHC - Trac
12:37:37 <EvilTerran> @. read run ap (++) show "@. read run ap (++) show "
12:37:38 <lambdabot>  @. read run ap (++) show "@. read run ap (++) show "
12:37:44 <dons> TuringTest: cheers
12:38:23 <goalieca> Korollary, some good fighting at the centre bell right now
12:40:40 <b_jonas> nice
12:40:49 <SamB> so, how come the page on Quine's paradox doesn't link to the page on the Liar paradox?
12:41:40 <sieni> SamB: well it does
12:41:56 <SamB> oh.
12:42:08 <SamB> I think I missed it because it was in lower case...
12:43:00 <dancor> where is func to escape html e.g. 'a<b' -> 'a&lt;b'
12:43:12 <wli> Epimenides' paradox?
12:43:17 <dancor> can't find in HTTP, happs
12:46:19 <dancor> nm looks like Text.XHtml.toHtml
12:49:45 <Tac-Tics> Are there any tutorial-like explanations of how to write a quine?
12:49:59 <ddarius> Yes.
12:50:17 <Tac-Tics> oh sure enough, google's first hit
12:54:30 <b_jonas> Tac-Tics: yes, but not that
12:54:43 <b_jonas> google first hit is a nice collection of quines but it's not changed for years now
12:55:00 <b_jonas> I recommend http://www.madore.org/~david/computers/quine.html
12:55:01 <lambdabot> Title: Quines (self-replicating programs)
12:55:33 <b_jonas> uh, apparently the google first hit is wikipedia now. then first hit after that.
12:55:49 <EvilTerran> it depends on which google mirror you get
12:56:06 <SamB> google mirror?
12:56:23 <EvilTerran> http://elgoog.rb-hosting.de/index.cgi
12:56:23 <lambdabot> Title: elgooG
12:56:28 <Tac-Tics> I didn't know Hofstadter coined the term. Thanks much b_jonas
12:56:55 <EvilTerran> but seriously, i get the impression that their different server farms have slightly out-of-sync rankings
12:57:38 <EvilTerran> probably weighted by what people redirected to that particular server (so presumably geographically nearby people) search for most
12:57:54 <EvilTerran> i'm guessing here
12:58:36 <EvilTerran> but my friends in canada often get significantly different results to me (in the uk), even when we've followed the same link to google.com
12:59:18 <ddarius> EvilTerran: Or possibly your friends in Canada are liars.
12:59:33 <allbery_b> remember that google also adapts to individual users
12:59:34 <TomMD> My friend in China... nah, never mind, he's a liar.
12:59:40 <allbery_b> you need to nuke cookies to disable that
12:59:46 <EvilTerran> yes, that's much more likely. i'll be sure to let them know that they're liars.
13:00:02 <Tac-Tics> Canadians are incapable of lying
13:00:29 <Tac-Tics> (But I, an American, lie all the time, because it's our nature :-)
13:00:48 <TauPan> what do you guys use for editing haskell in emacs? haskell-mode?
13:00:58 <EvilTerran> i use vim
13:01:04 * Tac-Tics uses Emacs
13:01:07 <TomMD> I thought we were just supposed to be hyper-competitive - not that we don't lie, but only when it give an advantage.
13:02:07 <Tac-Tics> That's the funny thing about generalizations. They work in mathematics... not so much, though, in real life =-)
13:02:34 <b_jonas> In theory, practice works in theory.  In practice, it doesn't.
13:02:41 <b_jonas> or how's that quote
13:03:08 * cjb also has the understanding that Google results are served by individual clusters, resulting in differences both inside and outside different countries.
13:03:30 <desegnis> b_jonas: theory works in practice, I guess
13:03:36 <cjb> b_jonas: In theory, theory and practise are the same thing.  In practise, they aren't.
13:03:49 <b_jonas> who's it from?
13:04:02 <EvilTerran> ... and that's why I invented this kidney-powered dog-light!
13:04:08 <EvilTerran> no, wait, wrong quote. <_<  >_>
13:04:17 * resiak contemplates a dog-powered kidney
13:04:40 <EvilTerran> sounds like something out of a B horror movie O.o
13:04:51 <resiak> ATTACK OF THE FIFTY-FOOT LAMBDAS
13:05:02 <b_jonas> yogism apparently
13:05:04 <LoganCapaldo> eh
13:05:05 <desegnis> Schopenhauser said, though, that something that is wrong is practice must be wrong in theory, too, otherwise the theory would be wrong.
13:05:09 <EvilTerran> resiak, nah, that's more of an abstract film
13:05:10 <b_jonas> "In theory there is no difference between theory and practice. In practice there is."
13:05:15 <LoganCapaldo> we've got nothing to worry about, they're lazy lambdas
13:05:21 <b_jonas> however, the wikiquote page says
13:05:27 <b_jonas> "This has also been attributed to computer scientist Jan L. A. van de Snepscheut and scientist Albert Einstein."
13:05:34 <b_jonas> so it's a quote from an unknown source
13:05:42 <EvilTerran> @quote Einstein
13:05:43 <lambdabot> No quotes match. Take a stress pill and think things over.
13:05:43 <notpalomer> anyone know how to get the coordinates of the cursor in a textbuffer?
13:06:38 <LoganCapaldo> @quote quote
13:06:38 <lambdabot> z0d says: What was the stereo quote?
13:06:59 <LoganCapaldo> that's not  a quine
13:07:08 <b_jonas> lol
13:07:22 <ddarius> @quote quote
13:07:22 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
13:08:08 <TauPan> Tac-Tics: and which mode?
13:08:36 <int-e> @quote surround
13:08:37 <lambdabot> No quotes match. :(
13:08:58 <shachaf> @quote @quote
13:08:58 <lambdabot>  @quote says: says: @quote @quote
13:09:13 <EvilTerran> @quote says: @quote @quote
13:09:13 <lambdabot> No quotes for this person. There are some things that I just don't know.
13:09:22 <EvilTerran> harumph
13:09:51 <LoganCapaldo> @quote .says: @quote @quote
13:09:51 <lambdabot> No quotes for this person.
13:10:06 <notpalomer> @palomer
13:10:07 <lambdabot> Scalliwags!
13:10:07 <Tac-Tics> TauPan: Haskell mode
13:10:10 <notpalomer> @palomer
13:10:10 <lambdabot> I have news for you, it's pointless
13:10:16 <notpalomer> @palomer
13:10:16 <lambdabot> Pfft
13:10:19 <EvilTerran> ...
13:10:20 <TauPan> I see
13:10:24 <notpalomer> that palomer was quite a character
13:10:35 <LoganCapaldo> @mallomar
13:10:35 <lambdabot> Unknown command, try @list
13:10:43 <EvilTerran> what's the deal with your clearly-derivative name, then?
13:10:49 <TauPan> Tac-Tics: I think it would be nicer if haskell-mode would offer a bit more aid with indentation.
13:10:59 <Tac-Tics> yeah, sometimes it's a pain
13:11:11 <Tac-Tics> I have sort of a love-hate relation with emacs as it stands
13:11:12 <ddarius> Why do emacs users need so much help with indentation?
13:11:31 <Tac-Tics> ddarius: because it ships with broken indentation support for all non-Lisp languages
13:11:34 <LoganCapaldo> just don't indent anything
13:11:37 <moosefish> ddarius: Side effect of abusive parentheses exposure
13:11:40 <int-e> TauPan: is that with or without (turn-on-haskell-indent) in the haskell-mode-hook?
13:11:47 * TauPan ignores fud.
13:12:00 <jsnx> ddarius: because they don't actually indent the code themselves...they think the editor should do it for them
13:12:02 <TauPan> int-e: I didn't configure anything, so it's probably without?
13:12:10 <b_jonas> LoganCapaldo: actrually, when I said quines for irc bots, I meant the more evil variant
13:12:29 <Tac-Tics> jsnx: that is false. I find myself using Space Space Space Space all the time, because I know emacs wants to botch my Tab job
13:12:53 <kaol> @where MPTC
13:12:53 <lambdabot> I know nothing about mptc.
13:13:29 <TauPan> int-e: I'll try turning it on.
13:13:44 <LoganCapaldo> lambdabot: sure you do, basically they're just type classes with multiple types, usually you use fun deps to make them sane
13:13:45 <int-e> TauPan: yes, probably. try adding (add-hook 'haskell-mode-hook 'turn-on-haskell-indent) to your .emacs and see if you like the new behaviour better. (hmm. strange, that's not an interactive command, why?)
13:14:19 <Trinithis> I'm having trouble with a (probably) simple instance delclaration: http://hpaste.org/5442
13:14:51 <TauPan> int-e: Ah, yes. That's much better thanks!
13:15:15 <int-e> nice :)
13:15:19 <TauPan> int-e: now this is the moment where I admit that I didn't bother to read the documentation for haskell-mode *blush* :)
13:16:12 <TauPan> int-e: I wanted to have cyclic indentation like for python, haskell-indent does exactly that.
13:17:01 <EvilTerran> Trinithis, you can't, using haskell98
13:17:25 <Trinithis> EvilTerran: is there a way do emulate what I want?
13:17:39 <EvilTerran> I'm not sure if you can create the two instances necessary at all, actually...
13:17:51 <Trinithis> EvilTerran: Or do i settle for only seeing if empty stacks are ==
13:18:21 <EvilTerran> well, you could have instance Eq a => Eq (Stack a) where (St xs) == (St ys) = xs == ys
13:18:39 <Trinithis> that doesnt worl
13:18:49 <Trinithis> because it doesnt know if xs and ys are instances of Eq
13:18:55 <EvilTerran> but you can't then compare stacks of non-Eq elements for equality
13:19:00 <EvilTerran> it should do
13:19:17 <EvilTerran> instance ***Eq a =>**** Eq (Stack a)
13:19:22 <Trinithis> oh
13:19:23 <Trinithis>  i see
13:19:28 <Trinithis> ty
13:20:32 <EvilTerran> Trinithis, incidentally, "data Stack a = St [a]
13:20:32 <EvilTerran>  deriving Eq" will do the same thin
13:20:34 <EvilTerran> g
13:20:40 <LoganCapaldo> newtype Stack a = St [a] deriving (Eq)
13:20:46 <EvilTerran> er. have some bonus newlines. :P
13:20:47 <Trinithis> your solution is exactly what i wanted
13:21:15 <EvilTerran> you don't get False if the stacks are non-Eq types, you get a compile-time error, but i doubt that'll be much of a problem
13:22:06 <EvilTerran> as i said, deriving Eq should give an effectively-identical instance
13:22:52 <ac> How do you achieve the same affect as "Action foo /server/bar", "SetHandler foo" in Apache's .htaccess files but disassociate requests from files? Meaning I don't want a 404 error if a request is made for a non-existant file
13:23:12 <nelhage> Is there a way to get more useful information out of Data.Array.IArray if I e.g. access a bad index? Right now I'm just getting a ``Error in array index'' message, which isn't very helpful
13:23:15 <Trinithis> hmm, works well. Is there a way I could have it see if empty stacks are ==, regardless of it being Eq
13:24:47 <allbery_b> er, (==) is predicated on Eq
13:24:57 <allbery_b> you can't get it otherwise
13:25:00 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5442#a1
13:25:21 <Trinithis> something like http://hpaste.org/5442#a1
13:25:28 <EvilTerran> that won't work, the instances overlap
13:25:34 <ac> (sorry for the offtopic question, but I figured someone in here would know)
13:25:49 <ddarius> @users
13:25:49 <lambdabot> Maximum users seen in #haskell: 466, currently: 466 (100.0%), active: 24 (5.2%)
13:25:51 <b_jonas> nelhage: you could try writing a wrapper over (!)
13:25:56 <EvilTerran> Trinithis, is that actually that useful?
13:26:03 <b_jonas> and use that locally (you can even give it the same name)
13:26:05 <Valodim_> ac: Rewrite
13:26:18 <ac> Valodim_: arhg, I was hoping that wouldn't be the answer
13:26:20 <FunctorSalad> wow, writing to a file is as simple as it can possibly get in haskell. positively surprised =)
13:26:26 <EvilTerran> you could just compare (\St x -> null x) and (\St y -> null y)
13:26:27 <Trinithis> EvilTerran: I want to have an isEmpty function that compares a stack s to emptyStack
13:26:41 <EvilTerran> ah,well, you don't need to use == for that! not by a long way!
13:26:49 <EvilTerran> isEmpty (St []) = True; isEmpty _ = False
13:27:05 <EvilTerran> or, isEmpty (St xs) = null xs
13:27:08 <Trinithis> EvilTerran: I know, just wanted to make it independet of implementation :d
13:27:52 <EvilTerran> ah, you're allowed to be implementation-dependent internally
13:28:03 <dons> new high score.
13:28:16 <Trinithis> mm
13:28:33 <EvilTerran> oo
13:28:37 <Tac-Tics> FunctorSalad: It really is. For quick and dirty "spit this string into a file" needs,  Haskell is king
13:29:36 <Gwern-away> this may sound silly, but when dons checks @users and says stuff like new high score, I get an imagine of dons making a bet with bill gates^W^Wsatan about whether he can make haskell successful
13:29:44 <Gwern-away> *mental image
13:29:49 <dons> that would be funny
13:29:58 <dons> ?users
13:29:58 <lambdabot> Maximum users seen in #haskell: 467, currently: 467 (100.0%), active: 28 (6.0%)
13:30:23 <Mortomes> Hehe, that seems pretty typical for an IRC channel.
13:30:44 <EvilTerran> Gwern-away, that'd be odd, seeing as our glorious leader is employed by microsoft
13:30:51 <Tac-Tics> "Soon my purely functional regime will be complete, and we can conquer Sun and Java once and for all!"
13:30:54 <Twey> Gwern-away, haha
13:30:54 <jsnx> if all four hundred people were active, it'd be crazy in here
13:30:58 <Twey> :-D
13:31:21 <jsnx> we'd have a lot of window size issues
13:31:39 <Gwern-away> 'With all our so-called programming tools the net effect is that programming becomes more and more difficult. The easy parts are automated away and the difficult parts remain and that has now reached the stage that it requires of the software developer quite a degree of mathematical sophistication. I was very amused when some time ago in a strictly industrial environment I observed a heated discussion. The discussion involved a ...
13:31:41 <Valodim_> ac: no other way
13:31:46 <Gwern-away> ... whole bunch of so-called higher order functions—higher order functions are considered too fancy to even talk about to many mathematicians, they are functions that have functions for their argument and may return a function as a value—it was in a group of industrial computer scientists and they talked about higher order functions as if they were the most normal thing in the world.'
13:32:08 <Valodim_> ac: you could rewrite them all to a script file (php or something) and handle it in a script
13:32:10 <Gwern-away> EvilTerran: yes, just as Anakin Skywalker was employed by Senator Palpatine!
13:32:17 <Gwern-away> and we all know how *that* worked out
13:32:24 <ac> Valodim_: right, that's what I'd be doing. Seems annoying to use regexes to do something so basic
13:32:27 <dons> strictify 0.1!
13:32:38 <Tac-Tics> Mathematicians talk about higher order functions as if they were nothing special, and it annoys computer science people, because they really are!
13:32:46 <ac> Valodim_: I know internally apache is basically handling two requests for every rewrite match
13:32:51 <EvilTerran> we'd need #haskell.a-h, #haskell.i-q, and #haskell.r-z, just to keep the numbers down :P
13:33:07 <Valodim_> ac: if you always treat entire directories like that, you could also use files instead of directories which are parsed as script
13:33:13 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strictify-0.1
13:33:14 <lambdabot> http://tinyurl.com/2jgw6x
13:33:35 <EvilTerran> mathematicians don't even notice higher-order functions, in my experience
13:33:55 <Gwern-away> 'Find a local optimum of strictness annotations.' <-- how does it do that? a crazy mix of benchmarks and genetic algorithms?
13:34:06 <EvilTerran> one of my lecturer's been merrily throwing around "maplets" like they're going out of fashion
13:34:19 <EvilTerran> *lecturers's
13:34:25 <sclv> gwern: I wish.
13:34:32 <ac> Valodim_: what do you mean "use files instead of directories"?
13:34:40 <dons> Gwern-away: you give it all the locations you're interested with, and it exhaustively tries them all?
13:34:47 <Trinithis> Gwern-away: what do you mean about higher order functions being too fancy for mathematicians. everyone knows about the derivative :D
13:35:00 <Valodim_> ac: like, make a file "stuff" somewhere and let "stuff" be handled (via htaccess) by script, which then uses QUERY_STRING to give back the correct content. that would suck for caching though and you'd have to handle headers
13:35:24 <EvilTerran> ac, if you have a +x file mapped to example.com/foo/bar, then a request for example.com/foo/bar/baz is passed to the /foo/bar script with /baz in an environment variable
13:35:30 <Gwern-away> Trinithis: I didn't say it, djikstra did
13:35:50 <sclv> it tries every strictness annotation once. then it performs a left fold over the "survivors", selecting the best of either a, b, or their combination.
13:35:52 <ac> EvilTerran: oh I did not know that
13:35:56 <Gwern-away> dons: that sounds silly. wouldn't the big o of all those permutations be terrible?
13:36:23 <Cin> most computer science concepts are pretty normal and dull once you understand them and have used them enough. it's just the bit before that when it seems like magic.. >_>
13:36:35 <sclv> that's why its a local optimum. theoretically, a right fold might give a different answer, or a fold of any other permutation.
13:36:37 <FunctorSalad> Trinithis: and of course the derivative is best thought of as type Function -> Point -> Linear Map ;))
13:36:45 <sclv> in practice, it doesn't seem like it'll matter too often...
13:37:17 <Gwern-away> sclv: does it give much improvement, do you know?
13:37:49 * Gwern-away just goes and read the email
13:37:51 <sclv> I tested it with the fasta entry we'd been playing with a while ago on the shootout. it stripped all the strictness annotations but two, giving a roughly 20% speedup.
13:37:56 <FunctorSalad> Trinithis: but actually considering the derivative as an operator comes pretty late IMHO
13:38:40 <Trinithis> FunctorSalad: In any case, it's still a transform
13:38:48 <Gwern-away> sclv: a pity. I
13:39:06 <dons> it seems quite interesting.
13:39:12 <FunctorSalad> yeah but it's unbounded in most norms which makes it pretty hard technically
13:39:12 <Gwern-away> 'm sure that strictness could help with the videogames I maintain, but they don't seem to meet the requirements
13:39:15 <dons> hunting for optimal reduction orders
13:39:22 <dons> i'm surprised we've not tried this before
13:39:36 <dons> sclv: did you submit updated versions to the shootout?
13:39:36 <dons>  
13:39:38 <sclv> its a hack really :-) it should be easy to extend it to do fancier things.
13:39:39 * Gwern-away kind of wonders why GHC couldn't do that
13:39:50 <sclv> dons: yep. i'll update the wiki when it gets accepted.
13:40:27 <dons> i've played with a tool that lets you breed flag combinations to gcc (or ghc)
13:40:37 <notpalomer> is there a reason that newIORef returns a IO (IORef a) and not a IORef a ?
13:40:42 <dons> that's quite fun. you can get 10-15% improvements for gcc
13:40:54 <Gwern-away> 'All I know is that when on of my professors at UT would talk about programming Haskell with Dijkstra, it sounded like he splooged in his pants from the exictement.'
13:40:56 <Gwern-away> dons: acovea?
13:41:00 <dons> that's it.
13:41:29 <Cin> gwern: where are these quotes from?
13:41:30 <dons> notpalomer: its not referentially transparent.
13:41:43 <Heffalump> notpalomer: otherwise you wouldn't have any control over how many times it ran
13:41:45 <Gwern-away> Cin: from a djikstra interview and reddit comments
13:41:51 <sclv> Gwern-away: if you can bring the code you want to optimize into a shootout-style benchmark, then you can use it. to do anything like this you'll need some sort of benchmark harness regardless.
13:41:52 <Cin> gwern: ahh. okay :P
13:42:03 <Heffalump> and that's kind of important, given that it allocates a unique storage location
13:42:33 <Gwern-away> sclv: did you run strictify on itself yet?
13:43:07 <Trinithis> @quote dijkstra
13:43:07 <lambdabot> No quotes match. Do you think like you type?
13:43:29 <sclv> haha no. the program itself is pretty hackish and unoptimized. it uses essentially O(0) time compared to a zillion ghc compiles and benchmark runs.
13:43:40 <ac> EvilTerran, Valodim_: that's very useful. Wish I had known about that a long time ago
13:43:49 <istarex> Can anybody help me fix a Kind error?
13:44:14 <FunctorSalad> hehe. read that as "kind of error"
13:44:20 <pastorNC> instancing Monad sucks
13:44:25 <ddarius> istarex: Why are you making kind errors?
13:44:43 <olsner> better than evil errors though, wouldn't you say?
13:44:44 <istarex> I declared the type IOErr as "type IOErr a = IO(Either String a)" and want to declare this a Monad instance
13:44:59 <Cin> i find it exciting how there always seems to be new ways to make haskell faster :)
13:44:59 <istarex> and am having trouble with the declaration :-)
13:45:13 <newsham> cin: wow, you would love ruby!
13:45:45 <EvilTerran> istarex, do you know about monad transformers?
13:46:05 <istarex> I've heard the term, but was hoping to avoid them :-)
13:46:09 <EvilTerran> IOErr = ErrorT String IO
13:46:21 <sarehu> ah, you don't want to avoid them!
13:46:43 <thetallguy> Where's the best place to read about the 6.8.2 GHC as a library APIs?
13:46:56 <thetallguy> Have I missed some Haddock docs someplace?
13:47:02 <Gwern-away> he'd love INTERCAL. endless scope for optimization
13:47:13 <Gwern-away> thetallguy: http://haskell.org/ghc/docs/latest/html/libraries/
13:48:05 <TomMD> Am I duplicating when I make an efficient "insertUnique :: Ord a => a -> [a] -> [a]" which is functionally equivilant to "nub . insert" ?  I can't find one in the standard libraries.
13:48:31 <thetallguy> Gwern-away: I mean these libraries:  exposed-modules: AsmCodeGen Bag BasicTypes BinIface Binary BitSet...
13:48:34 <yitz> istarex: to answer your question: 1. you usually want to use newtype rather than type to define a new monad
13:48:50 <Cin> well. it's not that i find any language getting faster exciting, but specifically haskell ;)
13:49:03 <olsner> There's no limit to what you can optimize given a sufficiently stupid language!
13:49:05 <dmwit> TomMD: You're not duplicating, but have you considered using Data.Set?
13:49:17 <Gwern-away> thetallguy: oh, that. you're interested in the GHC API itself?
13:49:17 <yitz> 2. there is nothing special about IO here, so you would write Monad m => ... and then use m in place of IO. Simpler, and more general.
13:49:27 <thetallguy> Gwern-away: yes.
13:49:35 <Gwern-away> thetallguy: I've messed withthat before. you're better off reading the code
13:49:47 <TomMD> dmwit: Thanks for the suggestion, but actually in my case the list makes more sense (98% of operations will be taking the head of the list, which is the lowest value of coarse).
13:49:54 <yitz> and voila - you have defined a monad transformer. Try it yourself, or look at how it was done in Control.Monad.Error.
13:50:11 <thetallguy> Gwern-away: as I feared.  Just checking to make sure.
13:52:08 <Cin> what's that library called that removes unnecessary list stuff? like `(length . map f)' is just `length' or how `(head . map f)' is really just `(f . head)', etc.
13:52:23 <dons> are you thinking of fusion?
13:52:29 <Cin> ah, might be
13:52:30 <Cin> thanks
13:53:06 <EvilTerran> it's not a library, mind; more of a compiler feature
13:53:38 <ddarius> @free length
13:53:40 <lambdabot> length = length . $map f
13:53:46 <olsner> $map?
13:53:57 <EvilTerran> @free map
13:53:59 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
13:54:08 <EvilTerran> @help free
13:54:08 <lambdabot> free <ident>. Generate theorems for free
13:54:51 <ddarius> @free head
13:54:53 <lambdabot> f . head = head . $map f
13:55:46 <ddarius> That one isn't true.
13:56:04 <sarehu> how so?
13:56:05 <Twey> :T $map
13:56:08 <Twey> :t $map
13:56:09 <lambdabot> parse error on input `$'
13:56:13 * Twey thought so.
13:56:50 <ddarius> sarehu: I leave it as an exercise.
13:56:55 <ddarius> @ft head
13:56:56 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
13:56:56 <lambdabot>    forall x1 :: [T1].
13:56:56 <lambdabot>      h1 (t1 x1) = t1 (map h1 x1)
13:57:08 <olsner> @help ft
13:57:08 <lambdabot> ft <ident>. Generate theorems for free
13:57:35 <ddarius> This one is true, where t1 = head.
13:58:38 <ddarius> @ft seq
13:58:39 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
13:58:39 <lambdabot>    forall T3,T4 in TYPES. forall h2 :: T3 -> T4, h2 strict.
13:58:39 <lambdabot>      forall x1 :: T1.
13:58:39 <lambdabot>        forall x2 :: T3.
13:58:39 <lambdabot>          h2 (t1 x1 x2) = t1 (h1 x1) (h2 x2)
14:01:08 <ddarius> @ft length
14:01:09 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
14:01:09 <lambdabot>    forall x1 :: [T1].
14:01:09 <lambdabot>      t1 x1 = t1 (map h1 x1)
14:01:22 <ddarius> This one is weaker than necessary.
14:02:09 <sarehu> how is it not the case that  f . head != head . map f?
14:02:28 <sarehu> er, s/not//
14:02:56 <ddarius> sarehu: The hint is, if f is strict that equality does hold, but if it isn't then it doesn't.
14:03:49 <sarehu> I can't think of any counter example..
14:03:54 <ddvlad> \query lambdabot
14:03:58 <idnar> @help ft
14:03:58 <lambdabot> ft <ident>. Generate theorems for free
14:04:02 <ddvlad> oops, sorry
14:04:11 <FunctorSalad> is System.CPUTime meant for basic profiling?
14:04:41 <sclv> FunctorSalad: you're probably better off using the commands in System.Posix.Process
14:04:45 <FunctorSalad> (in particular, does it include the time taken by any library calls etc.)
14:04:45 <ddarius> @check let f = const () in liftM2 (==) (f . head) (head . map f)
14:04:46 <lambdabot>  Add a type signature
14:05:03 <ddarius> @check let f :: Int -> (); f = const () in liftM2 (==) (f . head) (head . map f)
14:05:05 <FunctorSalad> sclv: ok I'll look into it
14:05:12 <lambdabot>  Exception: Prelude.head: empty list
14:05:14 <EvilTerran> what does the $ in the output from @free mean?
14:05:16 <sarehu> oh ok
14:05:30 <ddarius> @free (&&&)
14:05:30 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:05:42 <EvilTerran> whups
14:05:44 <newsham> does ghc not like linking with FFI using pthreads?
14:05:46 <EvilTerran> @free (++)
14:05:46 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:05:48 <ddarius> @. free type ((&&&) . ($))
14:05:48 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
14:06:05 <ddarius> @free a -> (a,a)
14:06:06 <lambdabot> Extra stuff at end of line
14:06:14 <ddarius> @free dup :: a -> (a,a)
14:06:15 <lambdabot> $map_Pair f f . dup = dup . f
14:06:43 <EvilTerran> @pl a -> (a,a)
14:06:44 <lambdabot> (line 1, column 3):
14:06:44 <lambdabot> unexpected ">" or "-"
14:06:44 <lambdabot> expecting variable, "(", operator or end of input
14:06:46 <Cin> sarehu: what does that @check prove?
14:06:49 <EvilTerran> @djinn a -> (a,a)
14:06:49 <lambdabot> f a = (a, a)
14:06:51 <EvilTerran> even
14:07:03 <ddarius> > (const () . head) []
14:07:05 <lambdabot>  ()
14:07:12 <ddarius> > (head . map (const ())) []
14:07:13 <lambdabot>  Exception: Prelude.head: empty list
14:07:37 <Cin> :t const
14:07:38 <lambdabot> forall a b. a -> b -> a
14:09:37 <Cin> ah, right. the (head []) won't be evaluated so the error won't be thrown
14:10:46 <monochrom> Out of sight, out of mind :)
14:10:56 <sclv> free theorems are generally unreliable in the presence of _|_, no?
14:11:05 * monochrom renames const to i_dont_hear_you_lalala
14:11:08 <newsham> Loading package silc-client-0.1 ... Segmentation fault (core dumped)
14:11:10 <ddarius> sclv: They take more care.
14:11:33 <ddarius> The length free theorem is true regardless of the strictness of f or any partiality in the input.
14:12:38 <sclv> but determining if they're true in the presence of bottom can be proven? is it just a requirement that they only use total functions?
14:13:11 <Cin> > (const () . head . map (const ())) []
14:13:11 <lambdabot>  ()
14:13:19 <Cin> isn't that the equvilant one for the second?
14:14:03 <EvilTerran> no, it's (const () . head) vs (head . map (const ()))
14:14:13 <EvilTerran> > const () . head $ []
14:14:14 <lambdabot>  ()
14:14:20 <EvilTerran> > head . map (const ()) $ []
14:14:21 <lambdabot>  Exception: Prelude.head: empty list
14:14:56 <EvilTerran> sclv, it's theoretically possible to reason rigorously about partial expressions
14:15:05 <newsham> ghci hates my pkg
14:15:07 <EvilTerran> it seems @free doesn't do so, but it's possible
14:15:28 <ddarius> sclv: The free theorems are the naturality squares.
14:15:29 <LoganCapaldo> it only happens in ghci?
14:15:48 <newsham> seems to be, yah.
14:16:00 <LoganCapaldo> odd
14:16:02 <newsham> this is freebsd/amd64 though which hasnt had good ghci support recently
14:16:06 <newsham> perhaps its related to that
14:16:36 <newsham> the weird thing is I have a small demo prog using my lib that works fine
14:16:45 <olsner> hmm, is --# an invalid start of comment in haskell?
14:17:00 <newsham> but when i integrate it into lambdabot, it dies before it does anything, even if i dont tell it to invoke my code
14:17:01 <ddarius> olsner: That's an operator.
14:17:04 <LoganCapaldo> > "a" --# cooment
14:17:04 <lambdabot>   Not in scope: `cooment'
14:17:11 <LoganCapaldo> > "a" -- # cooment
14:17:11 <lambdabot>  "a"
14:17:12 <ddarius> > let (--#) = (+) in 3 --# 5
14:17:12 <lambdabot> Unbalanced parentheses
14:17:22 <ddarius> :t let (--#) = (+) in 3 --# 5
14:17:22 <lambdabot> parse error (possibly incorrect indentation)
14:18:32 <ddarius> Stupid parsers.  It works in GHCi.
14:19:50 <Cin> hrm. trying to optimise `(head . map f)' is stupid anyway, isn't it, because of the laziness of `map', getting the head would only evaluate the `f' applied to the head anyway, right?
14:19:59 <newsham> $ echo 'let (--#) = (+) in 3 --# 5' |./runplugs
14:19:59 <newsham> 8
14:20:08 <Cin> except if you had some strict map and strict f
14:21:31 <nelhage> > let (--#) = (+) in 3 --# 5
14:21:31 <lambdabot> Unbalanced parentheses
14:22:02 <Cin> ja, thanks for clarying that.
14:22:35 <yitz> Cin: I guess you just save the call to map. Not too significant unless it is inside some tight inner loop.
14:22:38 <Cale> Cin: yeah, map would have to be needlessly strict in order to make  (head . map f) behave any differently from  f . head
14:22:53 <sclv> I think # is an invalid Haskell98 character?
14:23:05 <ddarius> sclv: No, it's perfectly valid.
14:23:12 <Cale> In fact, I wonder whether the inliner's smart enough to catch that anyway and eliminate the call to map.
14:24:10 <EvilTerran> well, the problem if f is non-strict remains, but that's gonna be pretty unusual
14:25:36 <Cale> hmm, ah, I see, yeah, f . head is potentially slightly more defined than head . map f
14:28:04 <magnusjonsson> .pl \ f g x y -> f (g x y)
14:28:16 <magnusjonsson> @pl \ f g x y -> f (g x y)
14:28:16 <lambdabot> (.) . (.)
14:29:10 <sclv> ddarius: so what exactly is MagicHash then?
14:29:16 <phobes> Cale:  example?
14:29:28 <ddarius> sclv: # is an operator character not an identifier character.
14:29:31 <pastorNC> magnusjonsson: that's tits
14:29:31 <magnusjonsson> is there any builtin combinator like the one I @pl'd just now?
14:29:36 <matthew-_> is there any reasonably sane way where for every type, I can use the name of the type lowercased as a value of that type?
14:29:38 <ddarius> magnusjonsson: No
14:29:48 <matthew-_> like int = (undefined :: Int)
14:29:49 <EvilTerran> sclv, it makes it pretend to be an alphanumeric character
14:29:56 <pastorNC> magnusjonsson: that is usually done with curry/uncurry
14:29:56 <magnusjonsson> pastorNC: while nice, it is not what I hoped for :)
14:30:05 <sclv> oh, ok. that makes sense.
14:30:12 <EvilTerran> ?hoogle #
14:30:12 <lambdabot> Prelude.(>) :: Ord a => a -> a -> Bool
14:30:12 <lambdabot> Data.Ord.(>) :: Ord a => a -> a -> Bool
14:30:12 <lambdabot> Prelude.(>=) :: Ord a => a -> a -> Bool
14:30:15 <EvilTerran> hm
14:30:18 <magnusjonsson> pastorNC: Aah, good idea
14:30:22 <EvilTerran> sclv, it's used for internals-related stuff
14:30:54 <EvilTerran> unboxedness and things
14:31:24 <EvilTerran> ?src IO
14:31:24 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
14:31:27 <Cin> phobes: (const () . head) []  vs.  (head . map (const ())) [] ... so in (f . head) vs. (head . map f), if the former is evaluated, `head' doesn't *have to* be called, whereas if the latter is evaluated, `head' does. i think that's the issue
14:31:58 <EvilTerran> exactly
14:31:58 <sclv> EvilTerran: right, I had that. i just wasn't sure what exactly MagicHash does, since I've only played with that stuff with glasgow-exts.
14:32:11 <dons> looks like fun, http://reddit.com/r/programming/info/67jl4/details (more differentiation in haskell)
14:32:40 <dons> ?users
14:32:40 <lambdabot> Maximum users seen in #haskell: 471, currently: 455 (96.6%), active: 25 (5.5%)
14:32:47 <dons> oh now that's cool. yaya
14:33:11 <matthew-_> wow, is derive still not supported on gadts?
14:33:15 <matthew-_> (6.8.2)
14:34:15 <phobes> Cin:  Thanks, I'll add this to my collection of things wrong with lazy evaluation :)
14:34:36 <EvilTerran> matthew-_, didn't GADTs only arrive in 6.8?
14:35:16 <EvilTerran> patience, grasshopper ;)
14:35:36 <matthew-_> EvilTerran: nah, I was using them back in 6.6
14:35:45 <EvilTerran> oh, okay. ignore me, then.
14:35:57 <Cin> phobes: well i think it's just my poor assumption that (f . head) would be (head . map f). as said above, if everything is lazy, then (head . map f) would only evaluate the first item in the list anyway, thus it doesn't really need optimising. i guess laziness gets brownie points? :P
14:35:57 <matthew-_> type families and synonynms only "arrived" in 6.8
14:36:45 <LoganCapaldo> deriving works on GADTs that are just regular ADTs using GADT syntax, AIUI
14:37:20 <wli> Integration is more interesting than differentiation anyway.
14:37:45 <ddarius> Indeed.  Differentiation should be defined in terms of integration anyway.
14:38:02 <pastorNC> how do i get rid of this?
14:38:03 <pastorNC>     It could refer to either `Turtle.Left', defined at Turtle.hs:19:29
14:38:03 <pastorNC>                           or `Data.Either.Left', imported from Prelude at Implicit import declaration
14:38:07 <LoganCapaldo> integration is hard, let's go shopping
14:38:21 <dons> pastorNC: import qualified Turtle as T
14:38:22 <pastorNC> (hiding auto-imported stuff)
14:38:26 <dons> then ue T.Left
14:38:29 <Cin> pastorNC: perhaps import one of those modules as qualified or hide the Left you don't use
14:38:33 <LoganCapaldo> import Prelude hiding ( Left )
14:38:35 <dons> or hide Prelude (Either(..))
14:38:36 <pastorNC> dons: I am writing in turtle...
14:38:44 <wli> ddarius: That only really works well for functions of a single complex variable, though.
14:38:57 <ddarius> It works for all functions.
14:39:21 <phobes> Cin:  One argument I repeatedly hear for laziness is that it makes equational reasoning easier... this would seem to be a counterexample
14:39:44 <SamB> phobes: well, it forces you to be pure which makes equational reasoning easier
14:39:58 <ddarius> phobes: Non-strictness supports the full beta rule, strict languages only have a restricted beta rule.
14:40:00 <SamB> plus, purity without laziness is provably less efficient than purity with laziness...
14:40:53 <matthew-_> LoganCapaldo: hmm. I don't think I'm seeing that here. Eg. data L :: * -> * where LC :: t -> L t deriving (Show)
14:41:05 <phobes> SamB:  the examples of purity and strictness being slow are somewhat pathological and can be avoided with explicit memoization
14:41:10 <matthew-_> that's the same as data L t = LC t deriving (Show)
14:41:35 <SamB> phobes: how can you do memoization in a pure, strict setting?
14:41:38 <LoganCapaldo> data L t where LC :: t -> L t deriving Show should work I beleive
14:41:57 <phobes> SamB:  You can't implement it in a pure strict language - it would need to be primitve
14:42:21 <phobes> SamB:  But note you can have memoizing without changing strict semantics
14:42:21 <EvilTerran> pastorNC, import Prelude hiding (Either (..))
14:42:44 <matthew-_> hmm. I never like that notation though as I find it unclear what t means what...
14:42:49 <EvilTerran> pastorNC, and "import qualified Prelude as P" if you still want to use the Either constructors
14:43:14 * EvilTerran prefers to write "data L :: * -> * where LC :: t -> L t", but that's another extension on the pile
14:43:22 <phobes> SamB:  In other words, if you take a strict language and implement it so that every function () -> a is memoized automatically, you are now in a strict langauge with all the computational power of a lazy one
14:43:31 <LoganCapaldo> matthew-_: yeah my version works
14:43:37 <LoganCapaldo> sorry :)
14:43:59 <LoganCapaldo> EvilTerran: that's what he had, which was apparently not letting him use derive
14:44:04 <sclv> phobes: except potentially massive memory usage, no?
14:44:06 <EvilTerran> weird
14:44:29 <matthew-_> yeah
14:44:36 <ddarius> sclv: No, it would be like using a strict language with an "explicit" delay and force construct.
14:44:39 <phobes> sclv:  Ya, automaticly doing it everywhere is a bad idea...  I'm not advocating it
14:44:39 <matthew-_> I find that syntax preferable to ADTs frankly
14:44:57 <LoganCapaldo>  me too
14:45:07 <EvilTerran> <aol>
14:45:14 <matthew-_> ADTs lie about their type sigs. Especially records
14:45:18 <phobes> ddarius:  with an explcit delay and force constructs that automatically get used at every function () -> a
14:45:23 <phobes> maybe it would be ok...
14:45:39 <phobes> since people tend not to use functions () -> a often
14:45:48 <phobes> but probably just using force and delay would be better ;)
14:45:50 <ddarius> phobes: In an otherwise pure language, the only reason to use a () -> a type is to get delay like behaviour.
14:46:15 <phobes> ddarius:  But not necessarily the memoization
14:46:41 <phobes> ddarius:  e.g. streams will maybe be implemented with () -> ... to get the next part, and wouldn't want that memoization there
14:47:03 <sclv> hmm.. so we've established that a strict language with a primitive for laziness is as powerful as a lazy language with a primitive for strictness..
14:47:04 <phobes> ya I think it's a bad idea to do it automatically
14:47:09 <ddarius> phobes: Why wouldn't you want the memoization there?
14:47:21 <phobes> ddarius:  to avoid the space leak
14:47:29 <phobes> sclv:  Ya, basically :)
14:47:56 * sclv is already writing the prospectus for submission to the JFP
14:48:03 <phobes> hehe
14:48:53 <ddarius> Note that they are incomparable with respect to macro-expressiveness.
14:49:59 * sclv balls up his submission and throws it away in dismay.
14:50:34 <phobes> ddarius:  You mean using laziness as a macro substitue?
14:50:36 <phobes> substitute*
14:51:14 <ddarius> No.
14:51:44 <phobes> or macro-expressiveness being a word for something else like "high level expressiveness"?
14:52:07 <ddarius> @google On the expressive power of languages
14:52:08 <lambdabot> http://www.ccs.neu.edu/scheme/pubs/scp91-felleisen.ps.gz
14:52:25 <phobes> I'm familiar with that paper I think
14:52:51 <phobes> So you're saying there are things that, to do with strictness, would require global program rewrites?
14:53:14 <ddarius> That way is the obvious one.
14:53:52 <phobes> What way?   I'd really like to hear an example of something laziness gets you that wouldn't be doable using streams
14:54:13 <phobes> and other forms of localized laziness
14:55:01 <TauPan> real programmers use butterflies (cf. xkcd) :)
14:55:15 <SamB> phobes: well can you come up with a local transformation that will translate lazy code into strict code without sacrificing purity?
14:55:32 <phobes> SamB:  no
14:55:38 <SamB> what does that tell you?
14:55:49 <phobes> SamB:  Can you come up with a way to transform untyped code to typed code?
14:55:56 <SamB> yes
14:55:57 <sarehu> that's easy
14:56:06 <SamB> data Duck = ...
14:56:06 <phobes> not just "unityped" code
14:56:21 <SamB> what sort of untyped code?
14:56:28 <phobes> because I can do a similar global transformation to emulate laziness
14:56:45 <phobes> as long as you give me memoizing (delay / force) it will behave exactly the same
14:57:06 <SamB> you get no delay/force
14:57:19 <ddarius> Something being macro-expressive means you can do it with a local transformation.
14:57:21 <SamB> well, or you get the wrong kind
14:57:22 <LoganCapaldo> o delay force for you!
14:57:48 <phobes> SamB:  What's the point of this game?
14:57:51 <ddarius> Even with delay/force, if you want a function that's lazy in it's sole argument, you have to change all the callers to use delays.
14:58:06 * SamB is having trouble seeing why converting untyped code to typed code would be global
14:58:39 <SamB> ddarius: I think you could just change everything to be delayed possibly?
14:58:48 <ddarius> SamB: That's a global transformation.
14:59:11 <LoganCapaldo> s/x/\() -> x/g
14:59:13 <phobes> SamB:  Because if you did it to half of your code (made it use Duck) it would be unable to interoperate with the other half that was typed in a sane way
14:59:16 <SamB> oh. *that* kind of local transformation
14:59:35 <LoganCapaldo> mmm I want code-exps
14:59:39 <LoganCapaldo> and sed for code
15:00:21 <SamB> anyway, for the efficiency arguments, you mayn't have delay/force...
15:00:34 * ddarius watches a movie.
15:00:37 <LoganCapaldo> code isn't a stream though
15:00:43 <phobes> Following the analogy, I should be able to use delay/force
15:00:54 <dmwit> LoganCapaldo: Use Lisp, then?
15:01:06 <LoganCapaldo> it's not that easy in lisp
15:01:11 <phobes> SamB:  The point is this... emulating dynamic code in a statitically typed language is silly.  The point I was making is that generally you don't want to do that - strong typing is usually better
15:01:26 <olsner> there should be some kind of regular tree-expressions for that
15:01:36 <LoganCapaldo> olsner++
15:01:59 <olsner> refactoring == tree-sed
15:01:59 <phobes> SamB: I'm now asking for a comparison of strict semantics with explicit / localized laziness to ubiquitous laziness
15:02:32 <LoganCapaldo> Lisp's macros are "too" powerful, you just write a program to transform a program. Just liek you could write a C program to do search and replace on a file
15:02:44 <olsner> (or, rather, tree-sed with automatic checking of whether the transformation changes semantics)
15:03:00 <phobes> SamB:  I understand the arguments people make here about the advantages of exporting laziness structures sometimes compared to usual strict paradigms... I'm asking now for an example of why localized laziness wouldn't be enough
15:03:06 <SamB> LoganCapaldo: well, it's a bit less awkward than grep
15:03:09 <pastorNC> i'm working on an assignment where i am to make an embedded language, where can i get some helpful guides or papers?
15:03:25 <Cin> yeah, like `ifSomething' type of functions
15:03:39 <Cin> oh, crap. i was reading backlog and replied to something. >_>
15:04:00 <LoganCapaldo> SamB: yeah I'm just full of it anyway ;)
15:04:01 * SamB can't keep grep and sed straight. crap.
15:04:05 <dmwit> pastorNC: You might like the SPJ paper on composing contracts.
15:04:40 <pastorNC> dmwit: you have any links?
15:04:48 <dmwit> The Parsec paper probably is good, too, though I've never read it.
15:04:53 <dmwit> http://research.microsoft.com/~simonpj/Papers/financial-contracts/contracts-icfp.htm
15:04:54 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/pj6n3
15:05:17 <dmwit> pastorNC: Actually, as for Parsec, I'd recommend the documentation much more than the paper.
15:05:38 <dmwit> You can get a pretty good idea of what is possible with embedded languages from it.
15:05:40 <SamB> or you could just read Parsec, too
15:05:47 <dmwit> ?where parsec
15:05:47 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
15:06:15 <dmwit> ?where harpy
15:06:16 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
15:06:37 <dmwit> A more literal interpretation of "embedded language". =)
15:07:33 <unenough> does anybody here know about BitC?
15:10:49 <olsner> hmm, sometimes you'd want 'func' for a flipped `func` ... some functions are the wrong order when used infix, since their author thought in prefix notation
15:12:41 <olsner> when (condition) (action) currently becomes (condition `when` action) rather than (action 'when' condition)
15:13:48 <sarehu> ah, we need 'foo' to mean `flip foo` :P
15:13:59 <dmwit> please no
15:14:10 <sarehu> "oops, your code's off by several pixels"
15:14:35 <dmwit> Worse: it invites separate syntax for each argument re-ordering.
15:14:36 <SamB> 'f' means what then?
15:14:57 <olsner> it should be forward-accent rather than apostrophe, my IRC client munges them
15:15:04 <dmwit> The movement to have non-trivial things inside `` is a much better idea, and subsumes this one.
15:15:31 <olsner> yeah, if we can't have both, we should at least have that
15:15:32 <sarehu> take a joke, people :P
15:16:18 <resiak> x °f° y = f y x    -- :-)
15:16:30 <olsner> haskell has too little syntax.. *looks at perl* >.>
15:16:53 <phobes> `` and '' need to work together to allow nesting
15:17:22 <phobes> x `f . 'moo' . g` y
15:17:36 <resiak> x ‘foo “bar“ baz‘ z
15:17:40 <olsner> x `f . `moo' . g' y
15:17:46 <sarehu> SamB: we can just make every function secretly overloaded with some typeclass that checks for characters and dispatches on their name, make every value overloaded as a function of the same form... muhahahahha
15:18:06 <SamB> sarehu: the what now?
15:18:16 <idnar> hahaha
15:18:17 <olsner> "polymorphic syntax"?
15:18:32 <SamB> I don't think that is possible without overlapping instances...
15:18:44 <phobes> sarehu:  lol I'm currently implementing something like that
15:19:02 <SamB> ... the kind that ACTUALLY overlap
15:19:27 <nelhage> Hmm. I wish Data.Ix.Ix.inRange had its arguments reversed.
15:19:28 <olsner> SamB: that's like... nondeterministic instances?
15:19:33 <sarehu> sounds exciting sign me up :)
15:19:42 <nelhage> Then a `inRange` b would read like I want it to.
15:19:44 <SamB> I think it's called incoherent instances?
15:20:27 <phobes> sarehu:  nm I think the bit about characters is quite beyond what I'm working on :)
15:25:57 <sarehu> bah, Haskell needs an OverloadedChars extension :)
15:27:03 <Cale> sarehu: haha
15:28:44 <Saizan> sarehu: singleton strings?:)
15:29:08 <EvilTerran> makes sense to me
15:29:20 <EvilTerran> not the singleton strings bit, the overloaded characters bit
15:29:23 <dmwit> :t isString
15:29:24 <lambdabot> Not in scope: `isString'
15:29:37 <EvilTerran> > 'a' :: Word8 -- would go nicely with ByteString literals
15:29:38 <lambdabot>  Couldn't match expected type `Word8' against inferred type `Char'
15:30:30 <Saizan> yeah, i was saying you can emulate it with singletons ad IsString
15:31:05 <EvilTerran> bit hacky, tho
15:31:15 <EvilTerran> could cause run-time errors that really should be at compile-time
15:31:34 <sarehu> true but useful
15:31:41 <sarehu> "SYN" :: Word8
15:31:48 <EvilTerran> you could get compile-time checks if you were willing to invoke TH
15:32:01 <glen_quagmire> > "SYN" :: Word8
15:32:01 <lambdabot>  Couldn't match expected type `Word8' against inferred type `[Char]'
15:32:12 <olsner> ouch, my lexer out-of-stacks when run on Carbon.h
15:32:25 <sarehu> omg, I think that'll be my next isstring instance :)
15:32:38 <sarehu> http://samuelhughes.com/isstring/index.html
15:32:38 <lambdabot> Title: IsString Instances
15:33:17 <olsner> heh, -O2 makes it blow the stack twice as fast, big surprise
15:33:41 <sarehu> ouch
15:33:57 <Japsu> foldl' instead of foldr! ;)
15:34:17 <sarehu> foldr' instead of foldl!
15:34:25 <Japsu> hmm
15:34:31 <sarehu> use foldl'' for extra strictness
15:34:42 <Japsu> hehe
15:34:49 <eugman> is there any meaning by a single quote after a word?
15:34:56 <EvilTerran> instance IsString TH.Exp where fromString [c] = [| toEnum $(LitE . IntPrimL . ord $ c) |]
15:34:58 <sarehu> eugman: no, it's just part of the name
15:35:10 <Japsu> eugman: it's usually used to denote an alternative version
15:35:17 <Cale> eugman: In general it just means something related, but in this case, it's the strict version.
15:35:18 <olsner> heh, if this was a fold I'd already strictified it, I guess
15:35:42 <EvilTerran> then you can do $("c") :: Word8, and get a compile-time error on things like $("") and $("xyzzy")
15:35:57 <EvilTerran> don't know if $"a" would work; doubt it, sadly
15:35:58 <Cale> olsner: which program is blowing the stack on you?
15:36:01 <Japsu> just as _ is used typically for operations that discard their result - for example, replicateM_ and replicateM
15:36:04 <Japsu> :t replicateM
15:36:05 <Japsu> :t replicateM_
15:36:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
15:36:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
15:36:26 <olsner> Cale: my polyparse C lexer
15:37:04 * EvilTerran checks... nope, no $"a"
15:37:38 <EvilTerran> and $("a") is awfully noisy, albeit less so than (toEnum $ fromEnum 'a')
15:38:02 <dmwit> let notId = toEnum . fromEnum
15:38:13 <dmwit> add -fno-monomorphism-restriction
15:38:20 <Japsu> let betweEnum = toEnum . fromEnum
15:38:20 <EvilTerran> i call that "betweenum" :P
15:38:21 <Japsu> ;)
15:38:23 <EvilTerran> ha!
15:38:28 <Japsu> ^5
15:38:32 <dmwit> clever
15:40:04 <EvilTerran> still, $("a") remains less noisy, and has scope for more fancy features
15:40:35 <EvilTerran> altho it is rather perl-esque
15:46:53 <monochrom> Is there a haskell wiki page on using Control.Parallel.Strategies ?
15:59:54 <glen_quagmire> how come "data", "type", "class", "=", "->", "::" and other keywords are not functions?
16:00:18 <SamB> mostly because they can't be
16:00:29 <SamB> we don't really have an excuse for "if" though ;-P
16:00:55 <glen_quagmire> i'm not sure why they can't be functions. they take parameters and return values
16:01:05 <conal> glen_quagmire: any thoughts on what kind of functions they might be?  i.e., what argument & return types and what meaning?
16:01:26 <jql> if haskell was more introspective, they would be functions of the compiler itself rather than your own executable
16:01:27 <conal> glen_quagmire: let's play with the idea.  pick an example.
16:01:37 <glen_quagmire> = :: Identifier -> a -> HaskellCompilationState
16:01:54 <SamB> State!?!
16:01:59 <glen_quagmire> Monad
16:02:08 <conal> glen_quagmire: okay, on syntax & compilation-whoositz, not on values.
16:02:25 <glen_quagmire> oh
16:02:26 <conal> then i'd say, yes, they're already syntactic functions, just not semantic ones.
16:02:41 <glen_quagmire> oh that's a little more clearer
16:02:53 <glen_quagmire> "syntactic functions" vs. "semantic functions"
16:02:56 <conal> :)
16:02:57 <SamB> but you're a bit wrong about the types
16:03:07 <monochrom> w00t, it turns out I have a lot of expressions to evaluate in parallel, but I don't want all of their answers, I want just one of them to give an answer, then I kill all the rest. Looks like I will be contriving some new combinator of general interest!
16:03:10 <Cale> Functions are values whose type has (->) as the top level constructor :)
16:03:12 <conal> SamB: or maybe right again, but with yet another sense.
16:03:35 <SamB> conal: = does NOT take a mere identifier as it's first argument
16:03:42 <Cale> As data constructors of the abstract syntax of Haskell, they'd be functions.
16:03:42 <wagle_> :t if
16:03:43 <conal> Cale: still, "data" could be considered to have (->) at the top level, as a syntactic function.
16:03:44 <lambdabot> parse error (possibly incorrect indentation)
16:03:54 <glen_quagmire> PatternOrIdentifier -> a -> CompilationMonad
16:04:05 <SamB> glen_quagmire: just say Pattern
16:04:07 <conal> SamB: where'd you get "="?
16:04:08 <SamB> also see TH
16:04:11 <jql> monochrom: are you trying to hack encryption? :)
16:04:17 <conal> SamB: oh, i see.
16:04:19 <Cale> hehe, with that type, it wouldn't be allowed to observe its second parameter
16:04:41 <monochrom> I'm trying to parallelize factoring algorithms.
16:04:45 <conal> we can quibble with glen_quagmire posited type, but i agree with his general idea.
16:04:54 <wagle_> :t \x y z -> if x then y else z
16:04:54 <lambdabot> forall t. Bool -> t -> t -> t
16:05:03 <monochrom> Does that hack encryption? I think I'm not that good yet.
16:05:13 <SamB> monochrom: only if you can factor really large primes ;-P
16:05:40 <Cale> Right, you can find them as functions in Language.Haskell.TH.Syntax
16:05:48 <glen_quagmire> conal: do you agree that we can have 2 categories of types? syntactic types and semantic types?
16:05:52 <conal> Cale: that's a nice crisp way to put it.
16:05:58 <monochrom> I just hope if you have 4 cores you can bring a 4-minute job down to 1-minute, or a 4-year job down to 1-year. :)
16:06:06 <glen_quagmire> s/types/functions
16:06:16 <Cale> :t Language.Haskell.TH.Syntax.Clause
16:06:16 <lambdabot> [Language.Haskell.TH.Syntax.Pat] -> Language.Haskell.TH.Syntax.Body -> [Language.Haskell.TH.Syntax.Dec] -> Language.Haskell.TH.Syntax.Clause
16:06:27 <conal> glen_quagmire: well ... there's at least two interesting notions of "syntactic types" i can think of off-hand.
16:06:41 <SamB> how about 1:20 or 16 month?
16:06:44 <conal> namely, types of syntax and syntax of types.
16:07:11 <Cale> SamB: I can factor really large primes.
16:07:19 <glen_quagmire> man this is hard
16:07:25 <SamB> Cale: It was kind of a joke ;-)
16:07:33 <Cale> heh
16:07:56 <conal> glen_quagmire: oh.  just noticed s/types/functions
16:08:30 <conal> glen_quagmire: again: syntax of functions & functions on syntax
16:08:48 <Cale> :t Language.Haskell.TH.Syntax.DataD
16:08:49 <lambdabot> Language.Haskell.TH.Syntax.Cxt -> Language.Haskell.TH.Syntax.Name -> [Language.Haskell.TH.Syntax.Name] -> [Language.Haskell.TH.Syntax.Con] -> [Language.Haskell.TH.Syntax.Name] -> Language.Haskell.TH.
16:08:49 <lambdabot> Syntax.Dec
16:09:13 <glen_quagmire> found it /usr/lib/ghc-6.8.2/lib/template-haskell-2.2.0.0/Language/Haskell/TH/Syntax
16:09:31 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH-Syntax.html
16:09:32 <lambdabot> http://tinyurl.com/yo9k4h
16:10:15 <conal> anyone here pondered Control.Arrow.Transformer.Automaton ?
16:10:25 <monochrom> Oh damn, the "factor primes" trap again!
16:10:52 * conal chuckles
16:11:23 <SamB> I can only factor large primes if you TELL me that they are primes
16:11:35 <olsner> conal?
16:11:40 <Cale> SamB: PRIMES is in P :)
16:11:47 <conal> I can factor large primes even if you don't tell me, but i won't know i'm right.
16:11:54 <conal> olsner: yes?
16:12:03 <vincenz> I can factor large primes, just put the result in a future
16:12:04 <SamB> well, okay, I could do that
16:12:14 <olsner> what's so special about Control.Arrow.Transformer.Automaton?
16:12:17 <SamB> vincenz: eh?
16:12:18 <conal> vincenz: :)
16:12:21 <monochrom> 932803849238507483759437589748375984324611  is most likely a prime (passed rabin-miller for 2000 bases)
16:12:28 <vincenz> And don't force it before 3034
16:12:59 <conal> olsner: i'm wondering how the automaton gets its first input
16:13:47 <Cale> monochrom: If you want a primality proof certificate in Mathematica form, I can give you one.
16:13:48 <conal> olsner: really, what even is the intended semantics of automaton feedback.
16:14:13 <monochrom> I'll let SamB worry about that. :)
16:14:17 <olsner> hmm, haskell.org seems to have lost the arrow documentation
16:14:33 <SamB> @google haskell arrows
16:14:34 <lambdabot> http://www.haskell.org/arrows/
16:14:34 <lambdabot> Title: Arrows: A General Interface to Computation
16:14:40 <conal> i was thinking each step gets half its input from half the output of the previous step.  but then whence the first?  looks like ross picked otherwise.
16:14:52 <monochrom> Which primality proof methods does Mathematica use? Especially for large numbers.
16:14:54 <olsner> hmm, isn't that something like a fixpoint combinator?
16:15:00 <SamB> olsner: really now?
16:15:15 <conal> olsner: similar
16:15:43 <conal> i'll work through Ross's definition.  it's pretty simple.
16:15:51 <olsner> SamB: well, hoogle goes to a dead link at least :P
16:16:07 <SamB> olsner: hoogle probably has a stale database or something
16:17:20 <olsner> hackage had haddock
16:17:35 <SamB> has!
16:17:43 <SamB> http://hackage.haskell.org/packages/archive/arrows/0.3/doc/html/Control-Arrow-Transformer-Automaton.html
16:17:43 <lambdabot> http://tinyurl.com/yp7k6g
16:17:46 <Cale> "When ProvablePrimeQ[n] returns True, then n is prime based on the Pratt certificate of primality or the Atkin-Morain certificate of primality."
16:17:58 <conal> hackage had haddock but now hackage has hassock
16:18:07 <Cale> (and it can print the certificate which just looks like a tree of integers)
16:20:36 <Cale> Ah, it'll be using the Pratt algorithm, since your number is less than 10^50
16:20:44 <litb> do you think it would be a good exercise to write a four-in-a-row game (without AI) in haskell?
16:21:43 <litb> > log (10^100)
16:21:46 <lambdabot>  230.25850929940458
16:21:56 <litb> wow it can handle such large numbers
16:22:11 <wagle_> :t 10^100
16:22:12 <lambdabot> forall t. (Num t) => t
16:22:26 <Cale> litb: Sure -- that's somewhat IO-intensive, but it should be a decent exercise. A better one if you write the AI after that. :)
16:22:28 <litb> Integer ftw
16:22:37 <Cale> > 10^100 :: Double
16:22:37 <lambdabot>  1.0000000000000002e100
16:22:46 <litb> meh i always wanted to write an AI for this
16:22:50 <litb> but i always failed
16:22:54 <wagle_> :t 10^100 :: Integer
16:22:54 <lambdabot> Integer
16:23:03 <wagle_> > 10^100 :: Integer
16:23:04 <lambdabot>  1000000000000000000000000000000000000000000000000000000000000000000000000000...
16:23:16 <litb> next time if this channel decides to code a game, could you involve me?
16:23:21 <wagle_> > 10^100 :: Int
16:23:22 <lambdabot>  0
16:23:22 <litb> would be very interested :)
16:23:49 <wagle_> i still think Int should be UnsafeInt
16:24:01 <Cale> It should just be removed from the Prelude.
16:24:15 <Cale> Put it in Data.Int where it belongs :)
16:24:37 <litb> well, how can i drop each 3. element from a list?
16:24:51 <litb> i mean, take 2 drop, take 2, drop, and so forth
16:25:04 <Cale> > map (take 2) . iterate (drop 2) $ [1..10]
16:25:07 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
16:25:21 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1..10]
16:25:21 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
16:25:25 <monochrom> Nice, my favourite Henri Cohen book has Atkin-Morain.
16:28:02 <twanvl> > concat $ zipWith ($) (cycle [return,return,const [],const []]) [1..10]
16:28:03 <lambdabot>  [1,2,5,6,9,10]
16:28:26 <litb> ah, nice
16:28:33 <Cale> oh, that's what you meant :)
16:28:57 <litb> i also thought of zipWith ($) but couldn't figure what lists i need :)
16:29:11 <litb> Cale: yeah, next time i'll exlain better
16:29:25 <Cale> also, if you just want to drop every third element...
16:29:28 <twanvl> > > concatMap (take 2) . takeWhile (not.null) . iterate (drop 4) $ [1..10]
16:29:28 <lambdabot>   parse error on input `>'
16:29:29 <Cale> > [x | (n,x) <- zip [0..] [1..10], n `mod` 3 /= 2]
16:29:30 <lambdabot>  [1,2,4,5,7,8,10]
16:29:33 <twanvl> > concatMap (take 2) . takeWhile (not.null) . iterate (drop 4) $ [1..10]
16:29:33 <lambdabot>  [1,2,5,6,9,10]
16:29:35 <glen_quagmire> > $(printf "Hey %s, are you %i yet?") "girl" 18
16:29:35 <lambdabot>   parse error on input `$'
16:29:55 <Cale> > [x | (n,x) <- zip [0..] [1..10], n `mod` 4 `notElem` [2,3]]
16:29:56 <lambdabot>  [1,2,5,6,9,10]
16:30:05 <EvilTerran> > [x | (p,x) <- zip (cycle [True,True,False]) [1..10], p]
16:30:06 <lambdabot>  [1,2,4,5,7,8,10]
16:30:06 <litb> > zip [0..] [1..10]
16:30:08 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
16:30:20 <litb> lol Cale clever
16:30:30 <Cale> > [x | (n,x) <- zip [0..] "Hello, World!", n `mod` 4 `notElem` [2,3]]
16:30:30 <lambdabot>  "Heo,or!"
16:30:44 <kuribas> ?hoogle ([a] -> ([a], [a])) -> [a] -> [[a]]
16:30:44 <lambdabot> No matches, try a more general search
16:31:00 <twanvl> > [x | (1,x) <- zip (cycle [1,1,0,0]) [1..10]]
16:31:00 * EvilTerran prefers his version :P
16:31:01 <lambdabot>  [1,2,5,6,9,10]
16:31:07 <EvilTerran> ooh, or that
16:31:23 <litb> i like the one by twanvl . but Cale is very neat
16:31:25 * Cale listens to Variations on the Carlos Santana Secret Chord Progression.
16:31:25 <EvilTerran> > [x | (True,x) <- zip (cycle [True,True,False]) [1..10]] -- likewise
16:31:26 <lambdabot>  [1,2,4,5,7,8,10]
16:31:30 <litb> errm, Cale's version indeed
16:32:02 <litb> that said, Cale might be need too, i don't know
16:32:12 <litb> *neat. anyway, back to work :)
16:33:09 <dons> sclv: one issue: if the lack of bang patterns causes a stack overflow, the tool doesn't seem to spot that
16:33:31 <dons> sclv: so it assumes the program was really fast, rather than failing
16:35:08 <litb> anyway, is it difficult to code a minimax algorithm for simple games in haskell?
16:35:29 <phobes> Is template haskell multistage or just a second stage?
16:35:42 <dons> litb: nope. did it in half a day for the ICFP contest in 2004
16:35:56 <dons> phobes: you can have multiple stages of splies
16:35:59 <dons> splices
16:36:17 <EvilTerran> phobes, multistage. you do sometimes get odd stage-mismatch errors if you're not careful, tho
16:36:29 <litb> dons: oh nice. for which game?
16:36:29 <phobes> Why is TH not used more?
16:36:35 <EvilTerran> eg, no "foo x = $x + 1" or whatever
16:37:09 <EvilTerran> litb, it's actually pretty straightforward, as you can construct the entire game tree and let laziness deal with it
16:37:17 <dons> litb: it was for a contest. we did some minimax and A* stuff
16:37:30 <dons> phobes: pretty heavy extension. macros not needed much
16:37:41 <litb> i see. well i think i should start with a very simple tictactoe game
16:37:49 <phobes> dons:  ok
16:37:53 <litb> is there a good paper on minimax?
16:38:01 <twanvl> phobes: also, because the library is extremely ugly and undocumented
16:38:03 <litb> maybe even mixxed with haskell? would be perfect
16:38:29 <EvilTerran> phobes, it was purely done to shut up the smug lisp weenies and their "we've got a macro system and you don't, nyah" nonsense. we don't actually need it, as the rest of haskell's awesome enough as it is :P
16:38:38 <phobes> heh
16:39:22 <litb> EvilTerran: i see. i could then just start up calcing to arbitrary deeps and then just look up until depth n because of laziness?
16:40:00 <dons> interesitng, http://micropledge.com/
16:40:01 <lambdabot> Title: microPledge: Get software made
16:40:21 <Cale> litb: right.
16:40:30 <EvilTerran> litb, that sounds about right, yeah. you wouldn't "start up calc'ing" as such, you'd let the laziness only calculate the bits just-in-time as you needed 'em
16:40:32 <Cale> litb: Just define the whole game tree.
16:40:59 <dons> anyone want to write a poem generator?
16:41:05 <dons>  $200 in it, according to that site.
16:41:24 * dons thinks we could throw some haskell efforts to pick up some of the bounties at http://micropledge.com/
16:41:25 <lambdabot> Title: microPledge: Get software made
16:41:57 <wagle_> modify parry to generate poetry
16:42:15 <dons> http://micropledge.com/projects/the-poem-generator
16:42:16 <lambdabot> Title: The poem generator
16:42:19 <dons> 200 bucks there :)
16:42:26 <dons> haiku/markovs can't be too hard :)
16:42:52 <litb> i suppose if i got it right with haskell, it's not difficult anymore to implement it in an imperative language
16:43:10 <dons> possibly. depending on what language features you used.
16:43:25 <dons> if it relied on laziness , you might need a new algorithm to do it well in a strict lang
16:43:36 <wagle_> just snarf the intemediate *.c files that ghc generates
16:43:37 <phobes> dons:  The $200 isn't bounty, right?   There's a developer waiting to do this for $500 and someone has pledged $200.  Or are you talking about trying to steal his pledge?
16:43:53 <Cale> Laziness gives you entirely new ways to break down problems which don't make sense in strict languages.
16:43:59 <dons> oh, i didn't look too closely, phobes
16:44:40 <phobes> dons:  Ya, it's not like yahoo answers or something where you post bounties... you post the idea YOU want do and look for micro "angel investors"
16:44:50 <dons> ah ha!
16:45:03 <dons> ok. so we could do that for haskell stuff
16:45:09 <dons> and get the community to fund things
16:45:15 <dons> fix lambdabot, $10.
16:45:16 <dons> etc :)
16:45:22 <phobes> dons:  Ya, go gather up all the things you've already done and offer to do them for a few hundred
16:45:25 <phobes> (eahc)
16:45:31 <phobes> I'm sure you'll get offers :)
16:45:47 <dons> well, we do have a community that could be utilised this way.
16:45:57 <dons> lots of small donations, rather than one big microsoft
16:46:12 <dons> we could get ddarius some funding to work on parsec.
16:46:23 <dons> i'll toss some coins in for a few bytestring things.
16:46:25 <dons> mmm
16:46:58 <dons> someone want to look into how cheap it is to start using this?
16:47:06 <phobes> Cale:  I still want to see examples of what you can do with laziness that you can't do with streams
16:47:18 <dons> spine lazy trees?
16:47:30 <dons> a la the binary-trees benchmark
16:47:33 <phobes> Cale:  streams and other explicitly crafted lazy datastructures
16:47:36 <phobes> errr dons
16:47:48 <dons> it might be hard to build an explicitly lazy structure
16:47:57 <dons> so the dev effort means its not done.
16:48:24 <dcoutts_> dons: just having a list of project might be enough
16:48:26 <Cale> also, if you have to go out of your way to use lazy structures, the libraries will end up full of strict things.
16:48:45 <dons> dcoutts_: right. on our own wiki. with a click to 'donate' or some such
16:48:48 <dcoutts_> dons: I've found several people step up when I publicised the list of easy cabal bugs
16:48:53 <phobes> Aren't spine lazy trees an example of a data structure that never would have been made if not for laziness?
16:48:57 <dons> dcoutts_: exactly.
16:49:10 <dons> phobes: possibly. i bet a few of Okasaki's things fit that bill
16:49:15 <SamB> the libraries still might end up full of strict things our way, but usually more when it makes sense ;-)
16:49:21 <dons> finger trees,for example
16:49:28 <Cale> phobes: What exactly do you mean by that?
16:49:29 <dcoutts_> properly categorising what projects/bugs/tickets need addressing and breaking them down into weekend sized tasks would go a long way
16:49:29 <dons> (as well)
16:49:37 <dcoutts_> monetary incentives can distort things
16:49:51 <dons> yeah. or like the 2k darcs bug bounty, no one will pick it up :)
16:50:14 <SamB> dons: what?
16:50:27 <phobes> Cale:  I mean... that was an explicitly lazy data structure
16:50:28 <dons> there was a 2k US bounty to fix darcs
16:51:54 <EvilTerran> welll, "fix darcs" is a bit of an intimidating problem
16:52:13 <Cale> phobes: Well, here's another example. Consider the ability to write things like if, and other control structures, as functions.
16:52:27 <resiak> the problem with a bounty of that size is that you'd have to treat it as a full-time job for a month
16:52:33 <phobes> Cale:  Ya, you need macros or something to do that in a strict language
16:52:44 <resiak> and then the price isn't right.
16:52:57 <phobes> Cale:  Or just some explicit mechanism for marking things as delayed
16:53:01 <Cale> Right.
16:53:35 <kuribas> Is there a unary minus operator?
16:53:40 <Cale> Which does make domain specific languages a little harder to write naturally.
16:53:45 <Cale> kuribas: yes
16:53:53 <kuribas> Which one?
16:53:56 <Cale> > let x = 5 in -x
16:53:59 <lambdabot>  -5
16:54:01 <Cale> That one.
16:54:12 <EvilTerran> kuribas, yes, much to the disgust of many of us
16:54:13 <phobes> How do you refer to the unary minus?
16:54:18 <phobes> > (-)
16:54:19 <lambdabot>  <Integer -> Integer -> Integer>
16:54:23 <Trinithis> @src toEnum
16:54:23 <lambdabot> Source not found. Just try something else.
16:54:25 <EvilTerran> > negate
16:54:26 <lambdabot>  <Integer -> Integer>
16:54:33 <kuribas> Oh.  How does know the difference between unary minus and binary minus?
16:54:37 <EvilTerran> is what it desugars to
16:55:27 <dons> unary minus is the new n+k
16:55:43 <phobes> Why don't people like -?
16:55:50 <wagle_> > ---1
16:55:50 <lambdabot>   parse error on input `}'
16:55:57 <wagle_> > - - -1
16:55:57 <lambdabot>  Parse error at "-" (column 3)
16:56:13 <phobes> That's why?
16:56:20 <EvilTerran> because it adds a gratuitous dose of inconsistence to the grammar that needn't be there
16:56:24 <wagle_> no..  dont mind me
16:56:30 <EvilTerran> > (+1)
16:56:30 <lambdabot>  <Integer -> Integer>
16:56:32 <EvilTerran> > (-1)
16:56:32 <lambdabot>  -1
16:56:33 <dcoutts_> @seen bos
16:56:33 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 5h 34m 47s ago.
16:56:35 <EvilTerran> ie, that
16:56:45 <Cale> I love the unary minus, and will defend it with my life. :)
16:56:52 <Cale> hehe
16:57:05 * EvilTerran would make - part of the number syntax, and rename "negate" to "neg" or something
16:57:30 <EvilTerran> "oh, but the newbies would get confused when foo -1 meant something different to foo - 1" "damn the newbies"
16:57:31 <dcoutts_> @ask bos any idea what's going on with the fedora gtk2hs rpm, seems to be missing a dep in the ghc pkg description on containers, we've had it reported but cannot figure out why it happens
16:57:31 <lambdabot> Consider it noted.
16:58:11 <Cale> EvilTerran: I might be okay with making it space sensitive so long as you could have unary minus still work with variables.
16:58:19 <Cale> That is, -x should still be negative x.
16:58:31 <EvilTerran> ew
16:58:45 <EvilTerran> i'd want to get rid of the double meaning if we were gonna do that
16:58:53 <EvilTerran> call one of 'em something else
16:58:58 <Cale> never!
16:58:59 <Cale> hehe
16:59:01 <wagle_> > ((-) 1) 2
16:59:02 <lambdabot>  -1
16:59:03 <EvilTerran> ¬x ? ~x?
16:59:08 <phobes> 1 `minus` 2
16:59:08 <Cale> > (+ (-1)) 2
16:59:09 <lambdabot>  1
16:59:10 <resiak> —x?
16:59:14 <Trinithis> > join (*2)
16:59:15 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a1
16:59:15 <lambdabot>     Probab...
16:59:27 <EvilTerran> @let _ = negate
16:59:29 <lambdabot> Defined.
16:59:31 <EvilTerran> ;)
16:59:46 <EvilTerran> _ x  -- :P
16:59:51 <mightybyte> How do you create a new page in the haskell wiki?
17:00:02 <wagle_> > (1 -) 2
17:00:02 <dons> mightybyte: just type in the name of the page
17:00:06 <lambdabot>  -1
17:00:13 <mightybyte> dons: where?
17:00:19 <wagle_> > (1 (-)) 2
17:00:19 <lambdabot>        add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
17:00:19 <lambdabot>     I...
17:00:26 <EvilTerran> Cale, how often do you negate a variable, really?
17:00:33 <Cale> EvilTerran: often enough
17:00:36 <wagle_> > (`-` 1) 2
17:00:37 <lambdabot>  Parse error at "-`" (column 3)
17:00:38 <mightybyte> dons: Ahh, the location bar.
17:00:41 <mightybyte> Got it
17:00:43 <jql> > (0-) 1
17:00:44 <lambdabot>  -1
17:00:50 <Cale> EvilTerran: Mostly I use Haskell for testing out little mathematics things.
17:01:01 <EvilTerran> meh. i don't think it's often enough for me to warrant the double-meaning
17:01:24 <Cale> I think it's fine. (+(-1)) is not that much worse for subtracting 1.
17:01:29 <EvilTerran> i wouldn't mind having a reservedop (or whatever the token class is called), but the double meaning bugs me
17:01:43 <EvilTerran> well, the inconsistencies the double-meaning introduce bug me
17:01:51 <kuribas> negate is clearer than unary -, as there is no confusion with sections, etc...
17:01:55 <EvilTerran> > (-1+)
17:01:56 <lambdabot>  <Integer -> Integer>
17:01:57 <Cale> Also, you can use (-1+)
17:01:58 <Cale> yeah
17:02:02 <wagle_> (flip - 1) 2
17:02:09 <EvilTerran> still. inconsistencies!
17:02:13 <wagle_> > (flip - 1) 2
17:02:14 <lambdabot>   add an instance declaration for (Num (a -> b -> c))
17:02:14 <EvilTerran> it's the principle of the thing :P
17:02:24 <wagle_> > (flip - $ 1) 2
17:02:24 <lambdabot>  Parse error at "$" (column 9)
17:02:37 <Cale> The principle of the thing is to make a language which reads nicely :)
17:02:45 <wagle_> > (flip (-) 1) 2
17:02:45 <lambdabot>  1
17:02:48 <EvilTerran> i don't call (-1+) particularly nice
17:03:10 <wagle_> > (-1+) 2
17:03:10 <lambdabot>  1
17:03:16 <Cale> I don't think having to use negate  explicitly is particularly nice either. :)
17:03:19 <EvilTerran> and i want such things as (subtract 1) pretty often, so i think it should get dibs on the nice syntax
17:03:39 <EvilTerran> much more often than i want to negate a variable, anyway
17:03:55 <wagle_> i think negative constants should win, but 2 `neg` 1 is ugly
17:04:13 <EvilTerran> wagle_, er, i don't think anyone suggested that
17:04:33 <EvilTerran> my "neg" idea was foo (neg x) rather than foo (-x)
17:04:52 <wagle_> foo - 1
17:04:59 <wagle_> foo -1
17:05:30 <wagle_> foo (-1)
17:05:32 <EvilTerran> hey, seeing as, with type families, ~ is ending up special in types, that'd be a perfect candidate for making special in expressions (as negation) :D
17:05:36 <Cale> This is one thing I think it's best we just leave alone :)
17:05:54 <EvilTerran> buu. damn conservative. :P
17:06:08 <Cale> Heh, on this issue, sure.
17:06:22 <Cale> But I do think we should flip the associativity of ($)
17:06:28 <sarehu> use "-25" if you want negative 25
17:06:40 <Cale> haha
17:06:45 <wagle_> maybe parenthesized operators is the problem..  use something else instead..  <-1> or something
17:06:54 <olsner> Cale: huh, wouldn't that break like everything?
17:06:59 <Cale> olsner: nah
17:07:03 <wagle_> err..  type directed parsing
17:07:03 <EvilTerran> olsner, that's what i was thinking
17:07:20 <EvilTerran> olsner, but Cale will tell you that anything that change would break was coded wrong in the first place
17:07:21 <Cale> olsner: Only places where people wrote stuff like  f $ g $ h $ x, and those are easy to fix
17:07:28 <EvilTerran> ;)
17:07:40 <sarehu> they deserve it to be broken, anyway
17:07:45 <Cale> You can rewrite that as  f . g . h $ x
17:07:52 <Cale> and there's no reason not to do it :)
17:08:17 <EvilTerran> i'd say the same about things that rely on the quirks of the (-) parsing instead of using negate and subtract, mind :P
17:08:19 <Trinithis> > map (+(-1)) [1..3]
17:08:20 <lambdabot>  [0,1,2]
17:08:27 <resiak> Cale: so, f $ g $ h $ x would mean f g h x in your world?
17:08:33 <Cale> resiak: yep
17:08:56 <Cale> resiak: so instead of  f (g x) (h y) (k z), we could write f $ g x $ h y $ k z
17:08:57 <resiak> so would, say,  f $ g x $ h y to mean f (g x) (h y)
17:08:59 <wagle_> why not just write f g h x then?
17:09:02 <Cale> yeah
17:09:06 <resiak> i would like that
17:09:26 <Cale> and you lose no expressiveness, because function composition catches the rest of the cases.
17:09:35 <wli> f g h x is ((f g) h) x
17:10:11 <wli> I think it's a good idea, but nothing to get up in arms about.
17:10:14 <Cale> Given that ($) is the reification of function application, it just morally should have the same associativity anyway.
17:10:27 <EvilTerran> you do need an extra set of brackets for when one of the functions in f.g.h contains an infix op, but, by my reckoning, the change'd allow for elimination of more brackets than it'd force
17:10:39 <dcoutts_> Cale: no no no, it's opposite for a different idiom :-)
17:10:48 <wagle_> ah, but 70 years of tradition in the lamda calculus community
17:10:48 <sarehu> sometimes I end up wanting to write,  return $ foo $ x.  And then I think "wait, what if they listened to Cale and changed it?"  And then I have to use  return . foo $ x, which is ugly
17:10:51 <Cale> dcoutts_: Which idiom is that?
17:10:52 <wli> The numerical hierarchy is a nightmare as it stands and IMHO vastly more urgent to improve if not fully repair.
17:11:07 <EvilTerran> > uncurry (+) $ length *** length $ ("foo","abracadabra")
17:11:08 <lambdabot>  14
17:11:09 <Cale> sarehu: it's not ugly :)
17:11:11 <EvilTerran> > uncurry (+) . length *** length $ ("foo","abracadabra")
17:11:11 <lambdabot>  Couldn't match expected type `(a, a)' against inferred type `Int'
17:11:13 <twanvl> ($) is very useful as a function with low fixity
17:11:33 <dcoutts_> Cale: the resource block idiom, withFoo $ \something -> withBar $ \other -> ...
17:11:34 <EvilTerran> on this one, i agree with cale
17:11:43 <Cale> dcoutts_: That wouldn't be affected.
17:11:48 <dcoutts_> hmm
17:11:53 <EvilTerran> dcoutts_, "maximal munch" means that won't be a problem
17:12:03 <sarehu> I do like the "return . foo\n       . bar\n       . map baaz\n       $ quux" style
17:12:12 <wagle_> i, for one, welcome our syntactic overloads
17:12:24 <Cale> ahaha
17:12:30 <idnar> bwahahah
17:12:33 <resiak> maximal munch is a lovely expression
17:12:38 <Cale> @remember wagle I, for one, welcome our syntactic overloads
17:12:38 <lambdabot> I will never forget.
17:12:38 <dcoutts_> hmm, there must be an example
17:12:42 * EvilTerran also wants MonadZero, no monomorphism restriction, and monad comprehensions
17:12:47 <EvilTerran> :D
17:12:50 <Trinithis> sarehu: why doesnt return $ f $ x work?
17:12:53 <Cale> EvilTerran: I'm with you on those :)
17:13:04 <ddarius> EvilTerran and Cale want Haskell 1.4
17:13:08 <Cale> Trinithis: It wouldn't, under my proposal.
17:13:12 * EvilTerran also wants [x,y | ...] to be valid
17:13:14 <wli> I differ from much of the community in that IMHO the parser should work very hard so the programmer need do as little work as possible.
17:13:15 <sarehu> Trinithis: because someday Cale will drug the Haskell''' committe
17:13:25 <Trinithis> sarehu: but why?
17:13:39 <wagle_> > return $ Just $ 1
17:13:39 <lambdabot>   add an instance declaration for (Show (m (Maybe a)))
17:13:40 <Cale> Trinithis: because it would end up meaning  (return f) x
17:13:41 <jql> wli: Welcome to the dark side
17:13:46 <sarehu> Trinithis: the argument is that $ should have its associativity go the other way
17:13:49 <wagle_> > return $ Just $ 1 :: [ Integer]
17:13:50 <lambdabot>  Couldn't match expected type `Integer'
17:13:58 <Cale> Trinithis: that is, it wouldn't mean what it currently means
17:14:04 <wagle_> > (return $ Just $ 1) :: [ Integer]
17:14:05 <lambdabot>  Couldn't match expected type `Integer'
17:14:12 <Trinithis> eh, i;; just take your word
17:14:13 <Cale> (it would still mean something, but that thing has a different type)
17:14:15 <wagle_> > (return $ Just $ 1) :: [ Maybe Integer]
17:14:15 <lambdabot>  [Just 1]
17:14:15 <wli> ddarius: Getting monad comprehensions back would be extremely desirable. The anti-polymorphic castration of the standard libraries was also a gross regression in quality.
17:14:22 <lispy> > [1] :: [] Int
17:14:22 <lambdabot>  [1]
17:14:27 <idnar> > (return . Just $ 1) :: [Maybe Integer]
17:14:28 <lambdabot>  [Just 1]
17:14:49 <Trinithis> > return $ Just 5
17:14:50 <lambdabot>   add an instance declaration for (Show (m (Maybe t)))
17:14:50 <EvilTerran> ( [| [x0..xN] |] = msum $ map return [x0..xN] -- works for monad comprehensions, too)
17:14:50 <Cale> If someone implements monad comprehensions, I'm pretty sure we have Simon on record saying he'd commit the patch.
17:14:58 <Trinithis> > return . Just 5
17:14:59 <lambdabot>  Couldn't match expected type `a -> b'
17:15:08 <Cale> So go ahead and put MonadZero back at the same time, and watch what happens :)
17:15:17 <Trinithis> > return . Just $ 5
17:15:17 <lambdabot>   add an instance declaration for (Show (m (Maybe a)))
17:15:18 <dcoutts_> Cale: it's trivial to do, comprehensions and do notation are the same internally in ghc
17:15:18 <phobes> What's the desugar rule for Monad comprehensions?
17:15:26 <EvilTerran> Cale, as part of the same patch? geez, you sound like a senator
17:15:27 <ddarius> Cale: He committed Wadler's groupBy and orderBy atrocities.
17:15:29 <dcoutts_> phobes: same as for 'do'
17:15:34 <wagle_> > do { [Just 1] ; return $ Just $ 2 }
17:15:34 <lambdabot>  [Just 2]
17:15:41 <Cale> EvilTerran: Well, you need MonadZero for comprehensions.
17:15:49 <Cale> ddarius: ouch.
17:15:52 <EvilTerran> it was a joke :P
17:16:04 <EvilTerran> camel-case keywords? ew
17:16:18 <dcoutts_> Cale: so the reason must but be so that you can chain f $ g $ h x = f (g (h x)), though of course one could use . instead there. Do you think there is any other reason?
17:16:26 <Cale> EvilTerran: Well, it's not the camelCase which bothers me so much.
17:16:28 <Trinithis> Is there a reason why Functor is not a superclass of Monad?
17:16:40 <sarehu> ddarius: what groupBy/orderBy atrocities?
17:16:41 <EvilTerran> Cale, well, yes, but it's the straw that breaks the camel's back, so to speak
17:16:42 <allbery_b> historical accident, I think
17:16:49 <Cale> dcoutts_: I don't think so, at least, I've thought about it for some time and not managed to come up with anything.
17:16:55 <ddarius> EvilTerran: I don't remember the name of the "keywords"
17:17:05 <EvilTerran> Trinithis, because people are silly. don't worry, the next version, Functor <= Applicative <= Monad
17:17:06 <lispy> ddarius: what made them atrocities? (just curious, i never heard about it before)
17:17:07 <shachaf> dcoutts_: For $ to be infixr?
17:17:12 <Cale> EvilTerran: It's better than group_by
17:17:14 <dcoutts_> shachaf: right
17:17:16 <ddarius> sarehu: The "generalized" list comprehensions.
17:17:34 <EvilTerran> Trinithis, and Applicative <= Alternative, and we can do away with MonadPlus altogether :D
17:17:45 <EvilTerran> Cale, true...
17:17:51 <ddarius> http://research.microsoft.com/~simonpj/papers/list-comp/index.htm This
17:17:52 <lambdabot> Title: Comprehensive Comprehensions
17:17:53 <Trinithis> EvilTerran: never heard of Applicative. will look up
17:17:59 <shachaf> dcoutts_: Well... I like, in ghci, how I can have any expression at all, and do something like add "concat $" to the beginning of it, without worrying about it.
17:18:12 <Cale> EvilTerran: Heh, if this was C, we'd probably end up with something like _group_by
17:18:16 <dcoutts_> Cale: but that example is true, it's f $ g $ h x = f (g (h x)) where as otherwise it'd be (f g) (h x)
17:18:19 <shachaf> dcoutts_: If $ was infixl, I'd sometimes have to add a $ at the other end of the line.
17:18:43 <shachaf> dcoutts_: But that's not worth it being infixr by itself. :-)
17:19:14 <Trinithis> :t pure
17:19:15 <lambdabot>     Ambiguous occurrence `pure'
17:19:15 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
17:19:15 <lambdabot>                           or `pure', imported from Control.Arrow
17:19:22 <lispy> what if we had $ infixr and, say, # infixl
17:19:40 <Cale> That's just too much of a waste of good operator symbols.
17:19:50 <dcoutts_> where would we want an infixl # over an infixr $ ?
17:19:57 <Trinithis> is pure like return? If so... the difference?
17:20:00 <dcoutts_> what are the examples?
17:20:06 <shachaf> Trinithis: Different class.
17:20:14 <ddarius> Trinithis: Not all Applicatives are Monads.
17:20:26 <lispy> Cale: well, if you just change $ now then you break code
17:20:32 <sarehu> having infixl $! clinches the argument for me
17:20:34 <shachaf> Trinithis: If things were Functor => Applicative => Monad, they'd have the same name.
17:20:37 <lispy> Cale: or is this for haskell'?
17:20:37 <Cale> lispy: Yeah, but it's easy to fix the code.
17:20:44 <Trinithis> and if they had done it right in the first place then they could have scrapped one of them?
17:20:44 <Cale> lispy: This is for Haskell 2
17:20:52 <EvilTerran> Trinithis, indeed
17:20:58 <EvilTerran> likewise fmap/liftM
17:21:04 <Trinithis> yeah
17:21:07 <Cale> lispy: Haskell' will inevitably be a boring standardisation of what we already have, so there's no need to worry about it.
17:21:13 <EvilTerran> also <*> vs ap
17:21:19 <sarehu> Cale, don't you want to replace fmap with (.), too?
17:21:28 <Cale> sarehu: Yeah, that'd be awesome :)
17:21:31 <Trinithis> EvilTerran: makes you wonder how many mathematicians were behind the scenes
17:21:36 <ddarius> They did do it right.  Applicative didn't come until many years later.
17:21:37 <EvilTerran> Cale, this is turning into APL
17:21:42 <EvilTerran> Trinithis, not enough, apparently
17:21:42 <lispy> Cale: when you say that it sounds kinda bitter, but I'm sure Haskell' will be quite useful to people that use Haskell extensions regularly.
17:21:50 <Cale> lispy: well, yes
17:22:21 <shachaf> ddarius: Is not having class (Functor m) => Monad m doing it right?
17:22:21 <Cale> lispy: But in practical terms, it's not like you'll have a whole new language. It's only standardising already-implemented features.
17:22:45 <Cale> shachaf: Could you rephrase that? :)
17:22:58 <Cale> The right way is to have Functor m => Monad m
17:23:01 <lispy> Cale: that's what standardization is though :)  It's a good thing.  And now researchers can start from the Haskell' collection of features when they want to make up new features :)
17:23:08 <Cale> er, or else Functor m => Applicative m
17:23:14 <Cale> and Applicative m => Monad m
17:23:14 <ddarius> shachaf: Okay. That was arguably a mistake.
17:23:19 <shachaf> Cale: Yes, I agree.
17:23:23 <Trinithis> in Prelude, despite not requiring Functor => Applicative => Monad, are all the things at least implemented as such?
17:23:34 <wagle_> @hoogle Applicative
17:23:35 <lambdabot> Control.Applicative :: module
17:23:35 <lambdabot> Control.Applicative.Applicative :: class Functor f => Applicative f
17:23:43 <Cale> Trinithis: yeah
17:23:54 <EvilTerran> Trinithis, er, mostly
17:23:57 <wagle_> well, uh, that was helpful
17:24:02 <shachaf> ddarius: Why arguably? Because of having to implement a Functor instance for Monads?
17:24:14 <Cale> Trinithis: You can almost rely on every instance of Monad being an instance of Functor, and such, but it's not enforced, and every once in a while, there'll be a snag.
17:24:15 <EvilTerran> Trinithis, they're not implemented in terms of each other, but they're generally implemented to work together
17:24:20 * shachaf is on a slwo connection, sorry for the late responses.
17:24:35 <EvilTerran> Parsec.GenParser wasn't an instance of Applicative, last i checked
17:24:36 <ddarius> Cale: A snag fixable by one line of code.
17:24:41 <Cale> ddarius: right.
17:24:44 <ddarius> But then you can have conflict problems.
17:24:59 <EvilTerran> which is very annoying, because <* would be really useful for parsing
17:25:02 <EvilTerran> ?type (<*)
17:25:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:25:08 <Trinithis> ddarius: by that do you mean implement it yourself?
17:25:11 <Cale> I also really want Class Aliases.
17:25:11 <wagle_> @src Applicative
17:25:11 <lambdabot> class Functor f => Applicative f where
17:25:11 <lambdabot>     pure  :: a -> f a
17:25:11 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
17:25:14 <ddarius> EvilTerran: It is for Parsec 3
17:25:19 <wagle_> oh..  issa arrow?
17:25:20 <EvilTerran> ddarius, great :)
17:25:22 <resiak> ah, applicative lacks join
17:25:26 <shachaf> Trinithis: instance Functor MyType where fmap = liftM
17:25:35 <Trinithis> mm'
17:25:37 <Cale> resiak: right, because if it had join, it would be Monad :)
17:25:42 <resiak> right
17:25:56 <resiak> it'd be nice to be able to implement join and fmap rather than >>= to get a Monad
17:26:14 <EvilTerran> would it be potentially meaningful to have a structure with fmap and pure but not <*>, or <*> but not pure?
17:26:28 <phobes> join is >>?
17:26:38 <EvilTerran> join is (>>= id)
17:26:38 <ddarius> EvilTerran: Yes.  That's called a pointed functor.
17:26:41 <wagle_> resiak, i heard mumbling that it wasnt exactly the same when i suggested that
17:26:44 <EvilTerran> ddarius, er, which?
17:26:46 <Trinithis> :t is
17:26:47 <lambdabot> Not in scope: `is'
17:26:58 <ddarius> fmap and pure
17:27:02 <phobes> EvilTerran: thx
17:27:09 <EvilTerran> ?type join
17:27:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:27:20 <phobes> oh right, join is flatten
17:27:23 <ddarius> m >>= f = join (fmap f m)
17:27:27 <phobes> (for lists)
17:27:29 <EvilTerran> ddarius, ah, okay.
17:27:30 <resiak> wagle_: eh? x >>= f === join (fmap f x)
17:27:34 <EvilTerran> phobes, well, concat, yes
17:27:45 <wagle_> resiak, they wouldnt tell me
17:27:46 <resiak> wagle_: they're absolutely equivalent
17:28:05 <wagle_> side cases, or something
17:28:48 <ricky_clarkson> If a language makes you do let a=b.curry c d in a e, that is not currying, but partial evaluation.
17:28:51 <ricky_clarkson> Or am I wrong?
17:29:18 <ddarius> ricky_clarkson: That is currying and this has nothing to do with partial evaluation.
17:29:24 <wagle_> ..  but it was ok if i thought them equivalent..  (?)
17:29:32 <ddarius> ricky_clarkson: currying is what curry does
17:29:34 <ricky_clarkson> I meant partial application, rather.
17:30:27 <kpreid> partial application has something to do with currying in that curry then apply performs partial-apply
17:30:32 <shachaf> dons: Have you people in OR decided anything about LFNW yet, by the way?
17:30:49 <Trinithis> currying is a tool for partial application
17:31:37 <ricky_clarkson> I'm trying to work out whether it is correct to say that Groovy supports currying.
17:31:50 <ddarius> ricky_clarkson: Can you write the curry HOF?
17:32:05 <opsin> what's the generally used compiler for vista?
17:32:09 <MyCatVerbs> @hoogle Ord a => [a] -> [a] -> [a]
17:32:10 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
17:32:10 <lambdabot> Data.List.(++) :: [a] -> [a] -> [a]
17:32:19 <MyCatVerbs> Heh. A little *too* general.
17:32:42 <ricky_clarkson> As far as I knew, Haskell does, because all functions are curried; currying is something done by the language, not something the programmer does.
17:32:58 <ddarius> ricky_clarkson: No it isn't.  currying is what curry does.
17:32:58 <allbery_b> @src curry
17:32:58 <lambdabot> curry f x y = f (x, y)
17:33:07 <shachaf> ricky_clarkson: Are functions really curried?
17:33:51 <ricky_clarkson> Hmm, looking at that source, curry seems to mean the opposite of what I thought.
17:33:54 <Trinithis> ricky_clarkson: you can probably implement a curry function in groovy. never programmed in it, but you can do it in a language like javascript
17:34:11 <ricky_clarkson> @src uncurry
17:34:11 <lambdabot> uncurry f p = f (fst p) (snd p)
17:34:12 <ddarius> Any language with higher order functions can implement curry.
17:34:23 <EvilTerran> hm. that's a strange definition of uncurry
17:34:23 <MyCatVerbs> @pl \ a b -> label (merge a b)
17:34:24 <lambdabot> (label .) . merge
17:34:35 * EvilTerran would have uncurry f ~(x,y) = f x y
17:34:36 <SamB> ricky_clarkson: look at the type
17:34:36 <blbrown> ricky_clarkson, you didn't dig scala
17:34:38 <resiak> sub curry { my $func = @_; return sub { my $a = shift; return sub { my $b = shift; $func($a,$b) } }
17:34:40 <SamB> the source is confusing sometimes
17:34:43 <SamB> @type curry
17:34:44 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:34:46 <ricky_clarkson> blbrown: Huh?
17:34:50 * jql checks the channel
17:34:54 <SamB> @type uncurry
17:34:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
17:35:02 <SamB> (for instance, if you aren't rt
17:35:03 <blbrown> ricky_clarkson, well, I am saying why are you messing with groovy
17:35:07 <SamB> thinking straight)
17:35:13 <EvilTerran> @quote pcrs
17:35:21 <ricky_clarkson> blbrown: I'm discussing it with someone.
17:35:28 <lambdabot> pcrs says: Premature carriage ret
17:35:35 <ricky_clarkson> I got fed up of explaining ad hoc so I'm writing a blog post and checking my facts.
17:35:46 <shachaf> ricky_clarkson: It looks like a curry method even comes in the library: http://groovy.codehaus.org/Functional+Programming .
17:35:46 <lambdabot> Title: Groovy - Functional Programming
17:35:57 <blbrown> blog, check facts, never heard of it
17:36:03 <ricky_clarkson> shachaf: That's kinda where I started :)
17:36:09 <kpreid> shachaf: that's partial application
17:36:34 <kpreid> that said, it *is* traditional to confuse the two
17:36:34 <ricky_clarkson> Can you show me currying in, say Java or lisp?
17:36:47 <shachaf> Oops, I got fooled by the name. :-)
17:36:52 <EvilTerran> Java? ewww
17:36:52 <ricky_clarkson> I.e., a strict language I know the ins and outs of.
17:37:05 <kpreid> ricky_clarkson: (defun curry (f) (lambda (&rest a) (lambda (&rest b) (apply f (append a b)))))
17:37:07 <lispy> how do you want to represent a tuple in lisp?
17:37:34 <ddarius> shachaf: If you view the fun.curry as returning a function which then gets applied, then fun.curry is currying.
17:37:35 <lispy> java functions are already curried
17:37:38 <ricky_clarkson> lispy: Why, nested conses.
17:37:57 <wagle_> (list x y z)
17:37:58 <hpaste>  blbrown pasted "Almost currying in java" at http://hpaste.org/5444
17:37:59 <lispy> private void foo(int x, int y) <-- looks like a tuple aready
17:38:10 <Trinithis> http://dis.4chan.org/read/prog/1180896798/
17:38:11 <lambdabot> Title: 4chan BBS - ..and you said java dont curry
17:38:18 <EvilTerran> lispy, er, that's uncurried
17:38:26 <wagle_> `(,x ,y ,z)
17:38:28 <lispy> ?type curry
17:38:28 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:38:31 <blbrown> I could probably do currying with that code; not pretty, but I was playing around with functional concepts in java the other day
17:38:33 <EvilTerran> curried would be foo(x).run(y)
17:38:36 <lispy> EvilTerran: ah
17:38:48 <blbrown> and the "remember me" doesn't work very well with hpaste
17:38:56 <Trinithis> ricky_clarkson: The unspeakable: http://dis.4chan.org/read/prog/1180896798/
17:39:21 <lispy> to do the haskell style automatica partial application you need closures, right?
17:39:45 <blbrown> Trinithis, I think that is what I was trying to do in my code; but I am still in java 1.4 mode
17:39:55 <ricky_clarkson> EvilTerran: Then how does that differ from partial application?
17:39:56 <jql> "need" is such a harsh rule
17:40:08 <Trinithis> blbrown: in any case, it's disgusting
17:40:13 <ddarius> lispy: You need support for higher-order functions (or some equivalent).
17:40:20 <conal> jql: agreed.  and hard to prove.
17:40:34 <jql> "want" is definitely true
17:40:43 <EvilTerran> ricky_clarkson, currying is a way of achieving partial application, IIUC
17:40:52 <ricky_clarkson> What other ways exist?
17:40:54 <ddarius> ricky_clarkson: Partial application isn't well-defined as arity isn't well-defined.
17:41:04 <wagle_> whats a curried object?
17:41:06 <ddarius> It's currying that's clear and partial application that is fuzzy.
17:41:46 <ddarius> If you have a clear notion of arity, then partial application is just applying a function to less arguments than it takes.
17:41:49 <Trinithis> ricky_clarkson: you can do partial application by wrapping a function in another function. (kinda like currying but 1 time)
17:41:50 <lispy> ddarius: partially because f :: a -> b -> c == f :: a -> (b -> c) ?
17:41:55 <ricky_clarkson> Well, I'm slightly glad to see I'm not the only one fuzzy on this.
17:42:41 <ddarius> If you don't have a clear notion of arity, the question is what makes the difference between a function that returns a function and a "partially applied" function.
17:42:43 <ricky_clarkson> "In computer science, currying, invented by Moses Schönfinkel and Gottlob Frege, is the technique of transforming a function that takes multiple arguments into a function that takes a single argument (the other arguments having been specified by the curry)."
17:43:04 <ddarius> ricky_clarkson: And that's what the curry function does (for two arguments)
17:43:07 <ricky_clarkson> That definition seems to include supplying the other args.
17:43:15 <ricky_clarkson> @t curry
17:43:15 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:43:20 <ricky_clarkson> @type curry
17:43:21 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:43:28 <EvilTerran> indeed, curry takes two parameters; the function and its first parameter
17:43:33 <EvilTerran> :P
17:43:34 <allbery_b> ricky_clarkson: but once you curry away one argument, you can repeat to curry away the next, etc.
17:43:43 <EvilTerran> it's all a matter of how you look at it
17:43:46 * EvilTerran goes to bed
17:43:49 <monochrom> @type curry curry
17:43:49 <lambdabot>     Couldn't match expected type `(a, b)'
17:43:50 <lambdabot>            against inferred type `(a1, b1) -> c'
17:43:50 <lambdabot>     Probable cause: `curry' is applied to too few arguments
17:43:58 <ddarius> :t curry . curry
17:43:58 <monochrom> @type uncurry uncurry
17:43:58 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
17:43:58 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
17:44:13 <Trinithis> currying is where you have a function with 1 arg that returns another func with 1 arg and so forth until there are no more args needed
17:44:38 <ricky_clarkson> curry takes a function from (a, b) to c, and returns a function on a that returns a function on b that returns c
17:44:43 <ricky_clarkson> @src curry
17:44:44 <lambdabot> curry f x y = f (x, y)
17:44:51 <ddarius> Trinithis: currying is producing such a function
17:44:54 <ricky_clarkson> I can't relate that type sig to the source.
17:45:06 <ddarius> f :: (a,b) -> c
17:45:07 <Trinithis> ddarius: 'scuse my french
17:45:10 <ricky_clarkson> Oh, now I can. :)
17:45:34 <monochrom> Resolution is hard. Let's go shopping!
17:46:03 <MyCatVerbs> monochrom: shopping is hard. Let's do maths!
17:46:06 <sarehu> Memes are halet's go shopping!
17:46:11 <wagle_> instance curryable
17:46:24 * MyCatVerbs makes a mental note to write that on the whiteboard in uni tomorrow.
17:46:41 <ddarius> One way to say an application, f x, is a partial application is to say it is of the form, (curry (uncurry f)) x
17:47:24 <dmwit> Or that it's (flip (flip f)) x.
17:47:39 <Trinithis> perhaps it would be easier to demonstrate currying in a language that does not curry by default
17:47:44 <ddarius> In Haskell, the distinction pretty much doesn't exist between those two, but in an impure language there can be a noticeable distinction.
17:48:08 <ddarius> (define (curry f) (lambda (x) (lambda (y) (f x y))))
17:48:17 <ricky_clarkson> Could you have a pure language where there was a noticeable distinction?
17:48:33 <dmwit> Certainly.
17:48:33 <ddarius> ricky_clarkson: For strict values of "pure", no, not semantically.
17:48:42 <dmwit> Pure /= lazy.
17:48:56 <monochrom> One could demonstrate currying in C++.
17:49:08 <ricky_clarkson> Does laziness preclude having multiple-arity functions?
17:49:15 <ddarius> ricky_clarkson: No.
17:49:20 <bos> @seen dcoutts_
17:49:20 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 28m 23s ago.
17:49:25 <SamB> ricky_clarkson: seen printf?
17:49:27 <bos> dcoutts_: pong
17:49:27 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
17:49:36 <sarehu> Well, there's printf
17:49:38 <MyCatVerbs> ricky_clarkson: it comes up in more noticably in, for example, Scheme and Common Lisp.
17:49:54 <ricky_clarkson> Yes, I've seen, and understood, Haskell's printf.
17:50:04 <MyCatVerbs> ricky_clarkson: which are arguably functional enough that the imperative bits stick out like a sore thumb. :)
17:50:09 <SamB> ricky_clarkson: you'll notice that it is multiple arity?
17:50:22 <ddarius> SamB: I don't think he meant variable arity.
17:50:34 <ricky_clarkson> I didn't.
17:50:38 <SamB> oh.
17:50:40 <SamB> well...
17:51:01 <ricky_clarkson> I know how printf works, or at least my mental model is sound, if not exactly what Haskell has.
17:51:19 <SamB> what difference would it make?
17:51:35 <ddarius> What difference would what make?
17:51:59 <sarehu> SamB: are you a pigsitter?
17:52:13 * dmwit just got lost
17:52:14 <SamB> sarehu: how does it pay?
17:52:14 <sarehu> 2003?
17:52:31 <SamB> are pigs allowed on the bus? can I bring them to school?
17:52:46 <ddarius> @users
17:52:46 <lambdabot> Maximum users seen in #haskell: 471, currently: 444 (94.3%), active: 25 (5.6%)
17:52:47 <lispy> are you calling SamB's little sister fat?
17:52:47 <ricky_clarkson> Only in a lunchbox.
17:53:16 <lispy> child obessity is a huge problem in the US...
17:53:21 * lispy is OT
17:54:01 * MyCatVerbs reads Text.Printf
17:54:12 <blbrown> lispy; if kids learned to code (especially in haskell), you would eliminate childhood obesity
17:54:15 <MyCatVerbs> SamB: I'd always thought you couldn't do variable arity functions in Haskell. ¬_¬
17:54:16 <blbrown> a book said that
17:54:31 <SamB> blbrown: it said that?
17:54:33 <SamB> what book
17:54:38 <blbrown> the talking ones
17:54:39 <MyCatVerbs> SamB: it's obvious.
17:54:39 <ddarius> MyCatVerbs: Define "arity"
17:55:00 <blbrown> SamB, dons
17:55:06 <blbrown> SamB, dons' book?
17:55:11 <MyCatVerbs> SamB: force them to use a computer powered by a dynamo on an exercise bicycle.
17:55:12 <SamB> oh, that book
17:55:18 <MyCatVerbs> SamB: that'll soon sort it out.
17:55:27 <SamB> MyCatVerbs: I kind of think they'd just forget to eat ;-)
17:55:32 <MyCatVerbs> ddarius: quantity of arguments taken.
17:55:45 <MyCatVerbs> SamB: s'only programming, not World of Warcrack.
17:55:57 <ddarius> MyCatVerbs: Tell me how I know how many arguments a Haskell function takes.
17:56:19 <SamB> MyCatVerbs: you are trying to convince me that programming is less absorbing than World of Warcraft?
17:56:20 <MyCatVerbs> ddarius: arity isn't well defined on Haskell functions?
17:56:43 <MyCatVerbs> SamB: from my perspective yes, though I do believe that's nothing but a personality defect on my part.
17:56:47 <wagle_> > (+)
17:56:50 <lambdabot>  <Integer -> Integer -> Integer>
17:56:54 <wagle_> > (+) 1
17:56:54 <lambdabot>  <Integer -> Integer>
17:56:57 <wagle_> > (+) 1 2
17:56:58 <lambdabot>  3
17:57:02 <wagle_> > (+) 1 2 3
17:57:02 <lambdabot>   add an instance declaration for (Num (t -> a))
17:57:02 <lambdabot>     In the expression: (+) 1...
17:57:08 <SamB> MyCatVerbs: well, I have never actually played World of Warcraft and have no intention to start
17:57:09 <ddarius> MyCatVerbs: It's certainly not immediately obvious.
17:57:26 <MyCatVerbs> ddarius: I suppose since Haskell doesn't make any distinction between a zero-argument function and a primitive value, you'd have problems trying to guess.
17:57:29 <sclv> arity is a fuzzy abstraction over kinds, no?
17:57:39 <SamB> MyCatVerbs: eh?
17:57:43 <wagle_> > swing
17:57:44 <lambdabot>   Not in scope: `swing'
17:57:55 <wagle_> > flip
17:57:55 <lambdabot>  Add a type signature
17:57:57 <SamB> well, there is also this thing about "what is the arity of the type a"
17:57:59 <MyCatVerbs> SamB: ?
17:58:02 <sarehu> omg!  you are!  a fellow pgsitter... amazing.
17:58:11 <SamB> sarehu: hmm?
17:58:28 <MyCatVerbs> ddarius: k, I'm missing something here.
17:58:43 <dmwit> ddarius: Well, the compiler certainly seems to know when I get it wrong.
17:58:47 <MyCatVerbs> ddarius: I'm used to languages like C and Prolog, where the arity of any given function is quite well defined.
17:59:15 <ddarius> dmwit: It knows when you apply a nonfunction and you get a type error.
17:59:17 <MyCatVerbs> ddarius: wherein "arity" in those languages is defined as "\foo -> the number of arguments that foo takes".
17:59:30 <dolio> MyCatVerbs: id has a somewhat non-obvious arity.
17:59:32 <SamB> dmwit: not for printf it doesn't ;-P
17:59:58 <dmwit> > printf "%d" 3 5
17:59:59 <lambdabot>  Add a type signature
18:00:00 <dolio> > (id 3, id (+) 4 5, id succ 6)
18:00:01 <lambdabot>  (3,9,7)
18:00:04 <MyCatVerbs> dolio: id always has an arity one higher than the argument it's applied to?
18:00:07 <dmwit> > printf "%d" 3 5 :: String
18:00:07 <lambdabot>  Exception: Printf.printf: formatting string ended prematurely
18:00:14 <dmwit> mmm, quite
18:00:24 <wagle_> @let swing = flip . (. flip id)
18:00:28 <lambdabot> Defined.
18:00:36 <wagle_> > swing
18:00:37 <lambdabot>  Add a type signature
18:00:45 <wagle_> :t swing
18:00:46 <lambdabot> Not in scope: `swing'
18:00:46 <dmwit> :t swing
18:00:47 <lambdabot> Not in scope: `swing'
18:00:53 <kpreid> @type L.swing
18:00:53 <dmwit> :t L.swing
18:00:53 <lambdabot> Couldn't find qualified module.
18:00:54 <lambdabot> Couldn't find qualified module.
18:01:01 <dmwit> bwuh
18:01:01 <wagle_> @type swing
18:01:02 <lambdabot> Not in scope: `swing'
18:01:03 <MyCatVerbs> ddarius: right, so, back on track. What I thought was impossible in Haskell was writing functions that take variable numbers of arguments.
18:01:04 <kpreid> @type swing
18:01:05 <lambdabot> Not in scope: `swing'
18:01:14 <dmwit> :t flip . (. flip id)
18:01:14 <lambdabot> forall b c a c1. (((a -> c1) -> c1) -> b -> c) -> b -> a -> c
18:01:17 <SamB> hmm, apparantly this pigsitter bussiness is something to do with having gone to PGSIT. which makes me one ;-).
18:01:24 <dolio> MyCatVerbs: You can do similar things with less trivial functions, like foldr for instance.
18:01:28 <wagle_> > swing swing swing swing swing swing swing
18:01:28 <lambdabot>  Add a type signature
18:01:41 <kuribas> Which one is better, a ^ 3 or a * a * a (or are they equivalent?)
18:01:47 <ddarius> MyCatVerbs: Without a notion of "number of arguments", there is no way to say whether it can or not.
18:01:55 <wagle_> the question was supposed to be "whats the arity of swing?"
18:02:04 <MyCatVerbs> dolio, ddarius: guh.
18:02:10 <dmwit> kuribas: They are equivalent, but for higher exponents, (^) will be better.
18:02:14 <sclv> kuribas: for 3 they should be equivalent. For higher values, the explicit power function is fancier.
18:02:25 <sclv> (it uses repeated squaring, airc)
18:02:44 <kpreid> @src (^)
18:02:44 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:02:48 <kpreid> @src ^
18:02:49 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:02:49 <MyCatVerbs> ddarius: okay, back into the concrete. I want to write foo which takes some variable quantity of arguments and returns an IO action that, when executed, does something with them.
18:02:59 <dmwit> ?where Prelude
18:03:00 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
18:03:10 <kuribas> dmwit: right, I'll use a^3, thanks.
18:03:16 <dmwit> (And yes, it uses repeated squaring.)
18:03:18 <kpreid> MyCatVerbs: printf does that.
18:03:31 <dolio> MyCatVerbs: If you're an Oleg fan, he has some stuff for variadic functions, that builds a list (or something like that) of however many arguments you apply a function to.
18:03:33 <MyCatVerbs> kpreid: precisely.
18:04:00 <dmwit> :t printf "" :: IO ()
18:04:00 <lambdabot> IO ()
18:04:05 <dmwit> huh
18:04:17 <MyCatVerbs> :t printf
18:04:17 <lambdabot> forall r. (PrintfType r) => String -> r
18:04:19 <MyCatVerbs> :t printf ""
18:04:20 <lambdabot> forall r. (PrintfType r) => r
18:04:32 <wagle_> :t printf "" :: a
18:04:33 <lambdabot>     No instance for (PrintfType a)
18:04:33 <lambdabot>       arising from use of `printf' at <interactive>:1:0-8
18:04:33 <lambdabot>     Possible fix:
18:04:58 <sclv> printf is somewhat simpler though, I think, than the oleg stuff. the notion is that it returns either a function or a value, and you know which one it returns by what you're expecting the type to be.
18:05:11 <wagle_> @src PrintfType
18:05:11 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:05:13 <sclv> polymorphism over return values is such a haskell typeclass win.
18:05:28 <sclv> wagle_: browse the source from the libraries documentation.
18:05:30 <dmwit> yeah
18:05:34 * MyCatVerbs pokes isChar. WTF?
18:05:43 <dmwit> > printf "%c %c" 97 'a' :: String
18:05:44 <lambdabot>  "a a"
18:05:52 <dmwit> :t isChar
18:05:53 <lambdabot> Not in scope: `isChar'
18:06:51 <sclv> i first started to get how polymorphism over return values works from looking at the regexp source actually, which for some reason was more comprehensible to me.
18:08:14 <wagle_> sclv, i know, i just try here first (because the short blurb it gives me when it succeeds is usually all I want)
18:08:27 <MyCatVerbs> Gah. Where the Hell is UPrintf defined!?
18:08:39 * qwr . o O ( :i IsChar )
18:08:41 <sclv> here's another example of polymorphism over return value that might be a bit simpler: http://hpaste.org/2925
18:10:05 <MyCatVerbs> qwr: provides a pair of functions "toChar :: IsChar a => a -> Char" and "fromChar :: IsChar a => Char -> a"
18:10:33 <SamB> which are of course both "id"
18:10:38 <MyCatVerbs> qwr: which sounds great, I guess, for anything isomorphic to characters. Except that the only instance given is Char.
18:11:00 <MyCatVerbs> SamB: right, so why would anyone ever need to make that class at all anyway?
18:11:13 <SamB> you didn't read the comments?
18:11:58 <SamB> it's so they could constrain printf to return either IO a or [Char]
18:12:06 <SamB> isn't it?
18:12:08 <MyCatVerbs> SamB: there are no comments there.
18:12:18 <Gwern-away> :t intersperse
18:12:18 <lambdabot> forall a. a -> [a] -> [a]
18:12:19 * MyCatVerbs is reading: http://www.haskell.org/ghc/docs/6.8.2/html/libraries/base/src/Text-Printf.html
18:12:20 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2frkcv
18:12:38 <litb> @src intersperse
18:12:38 <lambdabot> intersperse _   []     = []
18:12:38 <lambdabot> intersperse _   [x]    = [x]
18:12:38 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
18:12:44 <SamB> read THIS one:
18:12:45 <MyCatVerbs> SamB: distinct dearth of comments. Distinct abundance of "UPrintf" shit, which doesn't appear to be defined anywhere.
18:12:45 <SamB> {- not allowed in Haskell 98
18:12:46 <SamB> instance PrintfType String where
18:12:46 <SamB>     spr fmt args = uprintf fmt (reverse args)
18:12:46 <SamB> -}
18:13:20 <MyCatVerbs> SamB: what, does GHC compile that anyway? oO
18:13:32 <litb> > intersperse ',' "abcdefg"
18:13:32 <lambdabot>  "a,b,c,d,e,f,g"
18:13:40 <Gwern-away> :t append
18:13:40 <lambdabot> Not in scope: `append'
18:13:55 <MyCatVerbs> SamB: ohhh, right. That's because H98 won't let you declare a type synonym to be an instance of a class, right?
18:13:58 <Gwern-away> @hoogle append
18:13:58 <lambdabot> Data.ByteString.append :: ByteString -> ByteString -> ByteString
18:13:58 <lambdabot> Data.ByteString.Char8.append :: ByteString -> ByteString -> ByteString
18:13:58 <lambdabot> Data.ByteString.Lazy.append :: ByteString -> ByteString -> ByteString
18:14:07 <SamB> MyCatVerbs: ... not quite
18:14:10 <litb> i wonder if there is intersperse for [a] too
18:14:11 * MyCatVerbs ran into this a while back attempting to define "instance Num String" for a laugh.
18:14:12 <shachaf> MyCatVerbs: data UPrintf = UChar Char | UString String | UInteger Integer Integer | UFloat Float | UDouble Double -- ?
18:14:25 <SamB> even if you expand the type synonym, it won't workk
18:14:37 <ddarius> MyCatVerbs: If that was all there was to it, they'd just write instance PrintfType [Char] where
18:15:14 <Gwern-away> > (\x -> "rm \'" ++ x ++ "\'") $ concat $ intersperse "\'; rm \'" $ words "foo bar baz"
18:15:15 <lambdabot>  "rm 'foo'; rm 'bar'; rm 'baz'"
18:15:18 <litb> intersperse ", " "abcdefg"
18:15:28 <litb> but that's not compatible with the type
18:15:36 <Gwern-away> > (\x -> "rm \'" ++ x ++ "\';") $ concat $ intersperse "\'; rm \'" $ words "foo bar baz"
18:15:37 <lambdabot>  "rm 'foo'; rm 'bar'; rm 'baz';"
18:15:53 <Gwern-away> there, that looks about right
18:15:54 <MyCatVerbs> shachaf: ahhhh, thank you.
18:16:19 <litb> > intersperse "," ["abcdefg"]
18:16:20 <lambdabot>  ["abcdefg"]
18:16:37 <MyCatVerbs> shachaf: no wonder I missed it, I was trying to look it up with GHCi (naturally that doesn't work because it isn't exported).
18:16:57 <idnar> > intersperse "," ["abc", "def"]
18:16:58 <lambdabot>  ["abc",",","def"]
18:17:19 <litb> ow we only need a "chars"
18:17:41 <litb> n++
18:18:48 <dolio> @karma n
18:18:49 <lambdabot> n has a karma of 1
18:18:51 <litb> that turns [a] -> [[a]] where each x in [x1..xn] will become [x1, x2, x3]
18:18:53 <litb> oh
18:18:56 <litb> well
18:19:06 <litb> that actually triggered karma o.O
18:19:19 <dolio> n--
18:19:48 <litb> hehe
18:20:04 <litb> you know a function that does this?
18:20:09 <wagle_> ++++
18:20:18 <wagle_> @karma ++
18:20:18 <lambdabot> ++ has a karma of 1
18:20:18 <shachaf> @karma ++
18:20:18 <lambdabot> ++ has a karma of 1
18:20:19 <shachaf> ++--
18:20:48 <litb> > map (\x -> [x]) "hello"
18:20:48 <lambdabot>  ["h","e","l","l","o"]
18:21:00 <ddarius> > map (:[]) "hello"
18:21:01 <lambdabot>  ["h","e","l","l","o"]
18:21:08 <litb> i see
18:21:13 <wagle_> map pure "hello"
18:21:18 <wagle_> > map pure "hello"
18:21:18 <lambdabot> Terminated
18:21:24 <ddarius> > map return "hello"
18:21:24 <lambdabot>   add an instance declaration for (Show (m Char))
18:21:25 <litb> i know of that one but somehow i became confused and chose to make it with lambda
18:21:30 <ddarius> > map return "hello" :: [[Char]
18:21:30 <lambdabot>  Parse error at end of input
18:21:32 <ddarius> > map return "hello" :: [[Char]]
18:21:33 <lambdabot>  ["h","e","l","l","o"]
18:21:47 <ricky_clarkson> @pl \x -> map (\y -> [y]) x
18:21:47 <lambdabot> map return
18:21:56 <wagle_> @type pure
18:21:57 <lambdabot>     Ambiguous occurrence `pure'
18:21:57 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
18:21:57 <lambdabot>                           or `pure', imported from Control.Arrow
18:21:59 <litb> beh, no better way apparently
18:22:00 <ricky_clarkson> > map return $ "hello"
18:22:00 <lambdabot>   add an instance declaration for (Show (m Char))
18:22:02 <shachaf> > map return (return 'h' `mplus` return 'e' `mplus` return 'l' `mplus` return 'l' `mplus` return 'o') :: [] ([] Char)
18:22:02 <lambdabot>  ["h","e","l","l","o"]
18:22:09 <ricky_clarkson> > map . return $ "hello"
18:22:09 <lambdabot>  Add a type signature
18:22:24 <wagle_> @type Control.Applicative.pure
18:22:25 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
18:22:35 <litb> pure is the Arrow Monad ctor i believe
18:22:36 <MyCatVerbs> SamB: so, uh, why *does* Text.Printf bother to define IsChar, please? >_>
18:22:39 <litb> pure and arr are the same
18:22:45 <ricky_clarkson> > map . return $ "hello" :: [[Char]]
18:22:45 <lambdabot>  Couldn't match expected type `[[Char]]'
18:22:46 <wagle_> why "terminated"?
18:22:53 <ricky_clarkson> > map . return $ "hello" :: [Char]
18:22:53 <lambdabot>  Couldn't match expected type `[Char]'
18:22:57 <ricky_clarkson> poop
18:23:12 <litb> =)
18:23:34 <moobax> is there any way of running code when a haskell app is terminated with ctrl-c? I looked at System.Posix.Signals but it's not portable. Is there an exception for this?
18:23:41 <shachaf> ricky_clarkson: map . return $ "hello" is map (return "hello")
18:23:47 <ricky_clarkson> > map return $ "hello" :: [Char]
18:23:48 <lambdabot>  Couldn't match expected type `Char' against inferred type `m Char'
18:23:53 <ricky_clarkson> > map return $ "hello" :: [[Char]]
18:23:54 <lambdabot>  ["h","e","l","l","o"]
18:23:55 <litb> @let words = map return :: [[Char]]
18:23:56 <lambdabot> Couldn't match expected type `[[Char]]'
18:24:05 <sarehu> has anybody written a version of printf that works more like CL's format?
18:24:14 <litb> @let words = map return :: [Char] -> [[Char]]
18:24:19 <MyCatVerbs> SamB: to be honest, I'm not really clear on why H98 bans you from saying instance Foo [Char]. >_<
18:24:19 <lambdabot> Defined.
18:24:20 <ricky_clarkson> shachaf: Yeah, it just clicked before you said it.
18:24:34 <litb> oh no that was wrong
18:24:36 <litb> @undefine
18:24:36 <lambdabot> Undefined.
18:24:41 <dmwit> litb: Trying to trip somebody up? =P
18:24:48 <allbery_b> MyCatVerbs: I think you can as long as you don'
18:24:54 <allbery_b> t also have instance Foo [a]
18:24:54 <SamB> MyCatVerbs: it makes sense to mee ;-)
18:24:58 <litb> dmwit: nah
18:25:04 <SamB> allbery_b: nope
18:25:07 <dmwit> MyCatVerbs: Do you mean you don't know the rule, or you don't know the reason for the rule?
18:25:35 * allbery_b sighs.  not so much with the brain today
18:25:40 <twanvl> @let map f xs = reverse (List.map f x) -- like this? :)
18:25:40 <lambdabot> <local>:1:31: Not in scope: `x'
18:25:44 <twanvl> @let map f xs = reverse (List.map f xs) -- like this? :)
18:25:44 <lambdabot> Defined.
18:25:56 <litb> lol twanvl
18:26:01 <shachaf> > map succ "won't work"
18:26:01 <lambdabot> Terminated
18:26:13 <litb> you fail =)
18:26:57 <MyCatVerbs> dmwit: I'm unclear on the rule and I'm quite frankly bewildered by what reason must've led to it.
18:27:01 <litb> succ and pred are from Enumeration right?
18:27:36 <Saizan> MyCatVerbs: in h98 you can only have instances of the form Class (T a1 .. an)
18:27:44 <dmwit> MyCatVerbs: Okay.  I don't know the reason either.  But the rule is easy.
18:27:57 <dmwit> MyCatVerbs: ...aaaand Saizan beat me to it. =P
18:28:09 <Saizan> where n can be 0
18:28:09 <dmwit> litb: right
18:29:05 <litb> > map (*2) [1..5]
18:29:06 <lambdabot>  [2,4,6,8,10]
18:29:24 <litb> doesn't work hehe
18:29:44 <MyCatVerbs> Saizan: sorry if I'm being stupid, but since "instance isChar a => PrintfType [a]" passes nicely, how on Earth does "instance PrintfType [Char]" fail?
18:30:00 <dmwit> ?let map f [] = f; map f (x:xs) = map f xs ++ [x]
18:30:00 <lambdabot> <local>:1:29:     Ambiguous occurrence `map'     It could refer to either `ma...
18:30:07 <MyCatVerbs> Saizan: the only difference between the two is that in the latter case you're using a concrete type instead of a polymorphic one.
18:30:32 <dmwit> MyCatVerbs: That difference is also the reason.
18:30:43 <dmwit> MyCatVerbs: You may only use type variables in an instance declaration.
18:30:49 * MyCatVerbs blinks.
18:31:04 <litb> is there some function what can take an Int and that composes a function  n times with itself?
18:31:05 <dmwit> yep
18:31:22 <litb> so "compose 3 succ" will become (succ . succ . succ)" ?
18:31:34 <dmwit> iterate
18:31:38 <wagle_> @src compose
18:31:38 <lambdabot> Source not found. You type like i drive.
18:31:51 <litb> @iterate
18:31:51 <lambdabot> Unknown command, try @list
18:31:51 <ramsesx> alguien habla el castellano?
18:31:52 <wagle_> > compose
18:31:53 <lambdabot>   Not in scope: `compose'
18:31:56 <litb> @src iterate
18:31:56 <lambdabot> iterate f x =  x : iterate f (f x)
18:32:01 <piojo> somebody added rudeness to lambdabot? that's amazing
18:32:03 <MyCatVerbs> dmwit: but but but but but "instance Bits Integer" over in Data.Bits passes fine.
18:32:06 <dmwit> :t \f n x -> iterate f x !! n
18:32:06 <lambdabot> forall a. (a -> a) -> Int -> a -> a
18:32:08 <litb> hm doesn't look it's it
18:32:29 <MyCatVerbs> dmwit: this state of affairs makes no sense whatsoever to me.
18:32:35 <piojo> ramsesx: hablo un poco de castellano, pero no hablo haskell tan bien ;P
18:32:40 <dmwit> MyCatVerbs: Right, Integer is a zero-arity type constructor.
18:32:44 <ramsesx> qui parle le francais?
18:32:52 <dmwit> MyCatVerbs: So it constructs a type without any type variables.
18:33:04 <dmwit> MyCatVerbs: On the other hand, [] is a one-arity type constructor.
18:33:20 <dmwit> MyCatVerbs: So all of the types given to it must be type variables.
18:33:21 <wagle_> is -1 a constructor?
18:33:36 <dmwit> wagle_: That's actually a fine way to think of it, yes.
18:33:38 <liyang> (-1) is a 0-arity value constructor!
18:33:57 <bd_> and a polymorphic one at that
18:33:58 <MyCatVerbs> wagle_: no, but there are a few bits of naughty syntactic sugar to make it behave like one for the purposes of pattern matching.
18:34:08 <sclv> :t (-1)
18:34:08 <lambdabot> forall a. (Num a) => a
18:34:14 <MyCatVerbs> wagle_: see the "Ban n+k patterns!" movement.
18:34:31 <litb> oh i see. great
18:34:33 <idnar> MyCatVerbs: would "n" patterns be banned along with "n+k"?
18:34:33 <sclv> is that another Haskell' proposal, by the way?
18:34:42 <MyCatVerbs> dmwit: that seems like a bit of an insane restriction, but at least it's well defined. Thanks.
18:34:48 <sclv> i assume proper views would render it irrelevant.
18:34:50 <wagle_> :t (--1)
18:34:50 <lambdabot> parse error (possibly incorrect indentation)
18:34:52 <ddarius> idnar: No.
18:35:04 <MyCatVerbs> idnar: I think we should ban "n" patterns but keep "n+k" patterns.
18:35:17 <idnar> heh
18:35:21 <allbery_b> is this supposed to be haskell' or intercal'?
18:35:35 <MyCatVerbs> idnar: force everyone to write: { fac 0 = 1; fac (n+0) = n * (fac (n-1)); }
18:35:38 <litb> > let compose = \f n x -> iterate f x !! n in compose succ 1000000 10
18:35:39 <lambdabot>  Exception: stack overflow
18:35:43 <litb> i wonder why that is
18:35:44 <MyCatVerbs> allbery_b: Haskell--. ;)
18:36:03 <litb> are recursions done in haskell also recursions in the compiled machine code?
18:36:10 <twanvl> we should only allow "an^2+bk+c" patterns
18:36:14 <MyCatVerbs> litb: sometimes.
18:36:15 <litb> if not, why does it cause an stack overflow?
18:36:18 <litb> hmm
18:36:27 <MyCatVerbs> litb: ça depend. :)
18:36:29 <Saizan> litb: because you compose a big application of succs before starting to force it
18:36:35 <dolio> MyCatVerbs: But 0 is an n pattern.
18:36:36 <sclv> >  let compose = \f n x -> iterate f x !! n in compose succ 10000 0010 :: Int
18:36:37 <lambdabot>  10010
18:36:45 <sclv> >  let compose = \f n x -> iterate f x !! n in compose succ 1000000 0010 :: Int
18:36:46 <lambdabot>  Exception: stack overflow
18:36:47 <MyCatVerbs> dolio: fiiine.
18:36:51 <dolio> :)
18:37:03 <litb> i expected it to transform that into a loop and using the heap for that
18:37:23 <MyCatVerbs> fac (n - n) = 1; fac (n + (n - n)) = n * (fac (pred n))
18:37:40 <idnar> MyCatVerbs: that's an n + (k - l) pattern
18:37:41 <idnar> *duck*
18:37:44 <sclv> litb: but it thinks maybe you want the laziness and put it there for a reason?
18:37:46 <monochrom> That is sinister.
18:37:47 <Saizan> litb: since iterate is lazy, iterate succ x !! n gives a term (succ (succ .... (succ x))) which is then evaluated, and sice succ is strict it blows the stack
18:38:17 <sclv> >  let compose = \f n x -> iterate f x !! n in compose succ 1000000 0010 :: Integer
18:38:18 <lambdabot>  Exception: stack overflow
18:38:33 <monochrom> iterate succ x makes sense when succ is lazy.
18:38:57 <litb> hm i see
18:39:17 <dmwit> > let compose f 0 x = x; compose f n x = let y = f x in seq y (compose f (n - 1) y) in compose succ 10000000 10
18:39:19 <lambdabot>  10000010
18:39:47 <Saizan> monochrom: why?
18:39:47 <MyCatVerbs> idnar: no it isn't.
18:40:10 <litb> hm if something is strict, heap will not be used?
18:40:11 <MyCatVerbs> idnar: in fac (n - n), neither n nor n are fixed, so you're not allowed to refer to them as "k". :)
18:40:25 <dmwit> > let compose f n x = iterate (\y -> seq y (f y)) x !! n in compose succ 1000000 10
18:40:26 <lambdabot>  Exception: stack overflow
18:40:43 <dmwit> ...oh, right
18:40:53 <monochrom> For example data P = N | P P, instance Enum where succ x = P x.
18:41:36 <MyCatVerbs> monochrom: to plaigarise the "Evolution of a Haskell Programmer", grad school tends to isolate one from mundane concerns such as, for example, the efficiency of machine integers. ;)
18:41:48 <dmwit> > let iterate' f x = let y = f x in x : seq y (iterate' f y) in iterate succ 10 !! 100000
18:41:49 <lambdabot>  100010
18:41:55 <Saizan> monochrom: ah! i read "meakes no sense" earlier..
18:41:58 <dmwit> > let iterate' f x = let y = f x in x : seq y (iterate' f y) in iterate' succ 10 !! 10000000
18:42:01 <lambdabot>  10000010
18:42:30 <monochrom> For more information, see my new book "Space Age Haskell", to commence writing in 2009.
18:42:39 <litb> are these issues explained in Richard Birds book?
18:42:56 <wagle_> monochrom, could you send me a copy from the future please?
18:43:24 <monochrom> Not exactly the example of "iterate succ x", but the principle is there, and not just briefly.
18:43:25 <litb> monochrom: you've written a book?
18:43:46 <monochrom> I have decided to write several books. I have written none.
18:43:47 <MyCatVerbs> litb: note that the start date is in the future.
18:44:01 <wagle_> lazy book writing
18:44:03 <litb>  monochrom ah i see. i think i've ordered the right book then
18:44:05 <MyCatVerbs> litb: so, yes, monochrom has written several books. Just not yet. :)
18:44:24 <litb> lol
18:44:36 <piojo> he'll wait to write them until someone reads them
18:45:18 <litb> he knows all geeks of #haskell are proud of him. that's power enough :)
18:45:30 <monochrom> Well, I can't use "lazy writing" as an excuse, since clearly everyone is itching to read a book that explains time and memory in Haskell.
18:45:43 <nolrai> :t deleteBy
18:45:44 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
18:45:53 <monochrom> In fact everyone has been itching for 7 years. Me included.
18:46:12 <SamB> let me guess
18:46:28 <SamB> you are waiting to write the books until the material to write in them has been computed?
18:46:31 <Saizan> monochrom: then you saw the truth?
18:46:58 <litb> tell us what is the truth then
18:47:01 <monochrom> I am waiting for my thesis to be written first.
18:47:32 <monochrom> I have thesis >> space age haskell, and unfortunately my >> does enforce order.
18:48:01 <monochrom> Actually, thesis >>= space age haskell. My thesis has stuff of use there.
18:48:12 <dmwit> deepSeq thesis (space age haskell)
18:48:35 <wagle_> oh noes!  applicative order book writing!
18:49:24 <monochrom> @remember wagle oh noes!  applicative order book writing!
18:49:24 <lambdabot> Done.
18:51:05 <dolio> Space age Haskell? Writing Haskell in the 1960s?
18:51:57 <sclv> Haskell at Quantum Speed
18:52:22 <sclv> ^^ the new blog from Mr. Lisp at Lightspeed :-)
18:52:32 <dolio> Heh.
18:52:37 <wagle_> s/zip/velcro/g
18:52:54 <idnar> it's so fast it went back in time
18:52:58 <sclv> s/unzip/screetch/g
18:54:26 <SamB> that wasn't a real space age ;-P
18:54:42 <MyCatVerbs> dolio: that's "Atomic Age".
18:55:51 <monochrom> "space" suggests memory. "age" suggests time. "Space Age Haskell" is a book on time and memory usage.
18:56:13 <dolio> :)
18:56:21 <blbrown> hell yea...
18:56:32 <MyCatVerbs> monochrom: nice.
18:57:31 <dolio> Anyhow these days we're in the "information age".
18:57:40 <dolio> You need to figure out what the next age will be. :)
18:57:43 <ddarius> People don't seem very informed.
18:58:33 <monochrom> When there is space tourism, you can consider it another space age.
18:59:50 <dolio> I guess people are going to Mars some time, too.
19:00:08 <dolio> Whenever they get around to it.
19:00:30 <ddarius> Why would you want to go to Mars?
19:00:51 <dolio> Well, I probably wouldn't.
19:00:57 <dolio> Some people do, though.
19:01:00 <wagle_> climb the mountain because its there
19:01:28 <nolrai> @index deleteBy
19:01:28 <lambdabot> Data.List
19:01:33 <ddarius> Imagine hearing, "Are we there yet?" for three years and then you get there and, "This place sucks."
19:01:58 <dolio> Besides, you have to find the secret martian base hidden in the face that explains how advanced aliens seeded the earth with humanity.
19:02:30 <wagle_> not the star portal?
19:02:48 <litb> i believe that within my live i see aliens
19:03:01 <wagle_> or the buried ships left over from the last great galactic war?
19:03:11 <sclv> on the dark side of mars, there's a crater shaped like a lambda.
19:03:34 <litb> hehe sclv
19:03:39 <wagle_> mercury, you mean?
19:04:02 <litb> i hoped we find lambdas on the mercure . but my hope was destroyed last week
19:04:11 <sclv> deep inside it, someone (or... someTHING) has scrawled: S S K (S (K (S S (S (S S K)))) K)
19:04:22 <Twey> Hahaha
19:04:26 <wagle_> heh
19:04:41 <litb> S S K (S (K (S S (S (S S K)))) K)
19:04:47 <litb> does that have a special meaning?
19:04:57 <dolio> Is that Y or something?
19:05:08 <sclv> dolio: yep.
19:05:08 <litb> what?
19:05:13 <shachaf> @let s x y z = x z (y z); k x _ = x; i x = x
19:05:15 <litb> lolz i'm confused
19:05:16 <lambdabot> Defined.
19:05:22 <litb> i hope the bird book explains that
19:05:24 <dolio> Y combinator.
19:05:29 <litb> if not, i need to get something better
19:05:31 <wagle_> yeah
19:05:37 <wagle_> @google S S K (S (K (S S (S (S S K)))) K
19:05:38 <dolio> @type fix
19:05:38 <lambdabot> http://www.alexa.com/data/details/traffic_details/ssk.gov.tr
19:05:38 <lambdabot> Title: ssk.gov.tr - Traffic Details from Alexa
19:05:49 <wagle_> oh oh
19:05:50 <lambdabot> forall a. (a -> a) -> a
19:06:27 <shachaf> @ty let s x y z = x z (y z); k x _ = x; i x = x in s s k (s (k (s s (s (s s k)))) k) -- I guess this won't work if it's Y.
19:06:28 <lambdabot>     Occurs check: cannot construct the infinite type: t = t1 -> t -> t2
19:06:28 <lambdabot>     Probable cause: `k' is applied to too few arguments
19:06:28 <lambdabot>     In the second argument of `s', namely `k'
19:06:55 <ddarius> @unpl ap ap const (ap (const (ap ap (ap (ap ap const)))) const)
19:06:56 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ n o -> n >>= \ l -> o >>= \ k -> return (l k)) (\ a _ -> a) ((\ _ -> (\ af ag -> af >>= \ ad -> ag >>= \ ac -> return (ad ac)) >>=
19:06:56 <lambdabot> \ x -> (\ am -> ((\ ay az -> ay >>= \ aw -> az >>= \ av -> return (aw av)) >>= \ aq -> (\ c _ -> c) >>= \ ao -> return (aq ao)) >>= \ aj -> am >>= \ ai -> return (aj ai)) >>= \ w -> return (x w)) >>=
19:06:56 <lambdabot>  \ r -> (\ d _ -> d) >>= \ q -> return (r q))
19:07:04 <Trinithis> ?
19:07:13 <litb> holy shit =)
19:07:27 <Trinithis> we should make code like that more often w/o bots
19:07:27 <Twey> . . . wah
19:07:42 <Twey> See, this is why pointless is good :>
19:08:44 <Trinithis> I mainly like pl cause it makes you think of assinging functions rather than creating new ones
19:10:15 <litb> @pl \x y z v -> x v y z
19:10:16 <lambdabot> (flip .) . flip
19:11:05 <sclv> @. . pl redo unpl ap ap const (ap (const (ap ap (ap (ap ap const)))) const)
19:11:05 <lambdabot> (do { e <- (\ m n -> do { k <- m; j <- n; return (k j)}); d <- (\ a _ -> a); return (e d)}) (\ r -> (do { t <- (\ ab ac -> do { z <- ab; y <- ac; return (z y)}); s <- (\ ai -> do { af <- (do { al <-
19:11:05 <lambdabot> (\ au av -> do { as <- au; ar <- av; return (as ar)}); ak <- (\ b _ -> b); return (al ak)}); ae <- ai; return (af ae)}); return (t s)}) (\ _ -> r))
19:11:19 <sclv> fixed it ^^
19:11:22 <awesame> does haskell have some cute way to deal with state params for recursion?
19:11:32 <awesame> for example, say I want:
19:11:46 <awesame> foo :: IO (String)
19:12:02 <awesame> but foo is recursive, and I need an accumulator
19:12:12 <awesame> I could do:
19:12:13 <shachaf> awesame: Control.Monad.State, possibly?
19:12:20 <awesame> foo_ugly :: Int -> IO (String)
19:12:28 <Trinithis> you could toss the accumulator in a tuple
19:12:29 <awesame> and have foo call foo_ugly...
19:12:33 <Trinithis> perhaps
19:12:36 <ddarius> awesame: Just declare foo_ugly locally
19:12:39 <Trinithis> IO (String, Int)
19:12:52 <awesame> ddarius: ah!  inside foo
19:12:58 <awesame> that's a decent suggestion
19:13:08 <awesame> do I have to name it?
19:13:11 <twanvl> It all really depends on what the function looks like
19:13:12 <dolio> foo = fooUgly initial where fooUgly ...
19:13:23 <ddarius> > let fac n = fac' n 1 where fac' 1 acc = acc; fac' n acc = fac' (n-1) (acc*n) in fac 5
19:13:24 <lambdabot>  120
19:13:41 <ddarius> awesame: There are ways to avoid naming it, but that would be ridiculous.
19:13:58 <twanvl> usually such functions are called foo' or sometimes go
19:14:11 <litb> i usually call such "where functions" h for "helper"
19:14:50 <twanvl> I also often use the abbreviated function name, doStuff = ds [] 1 whatever where ds = ...
19:15:45 <litb> anyway i'm off the game
19:15:51 <litb> bye all happy hacking
19:16:18 <awesame> in lisp I do this with optional parameters
19:16:28 <awesame> with the base condition as the default
19:18:48 <nelhage__> Hmm. is (Either Error) a MonadPlus?
19:19:25 <dmwit> ?instances-importing Control.Monad.Either MonadPlus
19:19:26 <lambdabot> Couldn't find class `MonadPlus'. Try @instances-importing
19:19:34 <dmwit> ?instances-importing Control.Monad.Either MonadZero
19:19:35 <lambdabot> Couldn't find class `MonadZero'. Try @instances-importing
19:19:44 <dmwit> ...
19:19:47 <ddarius> @instances MonadPlus
19:19:47 <dmwit> :t mzero
19:19:47 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
19:19:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
19:20:13 <twanvl> Error is not a type, Error e => Either e is an instance of MonadPlus
19:20:15 <nelhage__> @src (Either e) mzero
19:20:15 <lambdabot> Source not found. :(
19:21:02 <twanvl> mzero = Left noMsg
19:21:23 <nelhage__> OK, that's what I assumed, but wasn't sure the best way to look it up.
19:22:29 <twanvl> I didn't look it up either, but it is the only sensible thing it can be
19:22:31 <dmwit> :info MonadPlus in ghci (after importing the appropriate modules) would also have this information.
19:22:59 <twanvl> dmwit: :info doesn't give the source, does it?
19:23:10 <dmwit> No, but it tells instances.
19:23:44 <sclv> > mzero :: Either String Int
19:23:45 <lambdabot>  Left ""
19:29:41 <Notostraca> Has anyone here written anything using YamlReference?
19:33:13 <Notostraca> Does anyone recommend a particular data format and parser to go with it to be used in a Haskell program?
19:33:56 <sclv> depends what for? haskell has awesome xml libs.
19:34:03 <monochrom> Data.Binary.
19:34:06 <Notostraca> like hxt?
19:34:12 <monochrom> @hackage binary
19:34:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
19:34:21 <blbrown> I have a type: "AA :: IO Bool"  I want to use 'if' ... if AA then ... else ..  is there a liftIO :: IO a -> a or something
19:35:01 <dmwit> Nope!
19:35:11 <dmwit> What you can do is this:
19:35:24 <monochrom> If you want xml, look into both hxt and haxml. One of them saves writing code for "I just want to serialise my data type into xml" and I forgot which.
19:35:27 <dmwit> do { b <- aa; if b then ... else ... }
19:35:49 <blbrown> of course, dope
19:35:52 <nelhage__> @hoogle m Bool -> m a -> m a -> m a
19:35:52 <lambdabot> No matches, try a more general search
19:35:53 <dmwit> blbrown: But then, keep in mind that the values given by the then/else clauses must be IO values.
19:36:02 <sclv> also, the syck library doesn't seem very well maintained (it was an Audrey Tang production) but it would probably better serve yaml purposes if you can get it up and running on 6.8
19:36:27 <sclv> someone may want to take over maintaining it, speaking of which...
19:37:37 <sclv> monochrom: hxt has the picklers. you can also use xml-generic with haxml, if you use syb-with-class.
19:37:38 <hpaste>  blbrown pasted "Ok?" at http://hpaste.org/5445
19:37:45 <blbrown> dmwit, this is what I did
19:38:01 <sclv> the RJson project is also very cool.
19:38:23 <dmwit> blbrown: when
19:38:28 <dmwit> :t when
19:38:28 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:41:31 <Notostraca> so, is RJson a haskell project?
19:41:45 <sclv> Notostraca: its on haskell.
19:43:44 <sclv> s/haskell/hackage. I'm also trying to remember a toolkit someone built in haskell as well for a homebrew lightweight xml syntax that bound to a sax processor. grr.. google is no help.
19:45:44 <Notostraca> I do have one crazy idea to use instead of an existing parser
19:46:11 <Notostraca> JSON is native JavaScript object notation, right?
19:47:00 <Notostraca> so, what if there were some sort of Haskell Data Representation?
19:47:15 <Notostraca> like with list comprehensions for templating
19:47:36 <dmwit> You can certainly use GHC as an API to compile Haskell at run-time.
19:47:39 <monochrom> tagsoup
19:47:54 <Notostraca> hm?
19:47:57 <dmwit> \bot uses something similar to have dynamically-loaded plugins.
19:48:06 <Notostraca> oh
19:48:31 <sclv> does anyone remember what I'm talking about? this is going to drive me nuts.
19:48:33 <Notostraca> I never found lambdabot's plugins
19:48:37 <monochrom> tagsoup
19:49:07 <sclv> Notostraca: what do you mean by "list comprehensions for templating" ?
19:52:34 <Notostraca> I mean data with parameters, somewhere between a script and data
19:53:16 <sclv> hmm.. you can do fancy things with generics and scrap-your-boilerplate (either with or without class) that's how generic xml and rjson are built. if you're just starting out though, you may want to hold off a bit on that...
19:54:21 <sclv> you really need to narrow down what you want to do before you decide though... if you just want to serialize stuff and read it back, without an external editor messing with it, Data.Binary is the way to go, for example.
19:57:26 <Cin> blah i'm such a haskell fanboy
19:57:45 <nelhage__> I believe ``fanboi'' is the canonical spelling.
19:57:55 <Cin> me: "haskell this haskell that", friends: "yeah... k, we'll see you later..."
19:58:34 <cjb> friends: "hey, so, what useful Haskell programs have you actually written?"
19:58:43 <cjb> <fx: tumbleweed>
19:59:43 <Cin> my ircd is awesome useful
19:59:48 <Cin> i just need to think of a name for it
19:59:51 <cjb> oh, that's cool
19:59:55 <cjb> ircmonad?
19:59:58 <Cin> other than "that ircd i'm writing in haskell"
20:00:12 <dons> hircd?
20:00:16 <dons> irchd ?
20:00:37 <ddarius> ircdwan
20:00:56 <nolrai> @hoogle [Maybe a] -> Maybe [a]
20:01:03 <Cin> i thought of hircd and ircmonad
20:01:03 <lambdabot> No matches, try a more general search
20:01:12 <Cin> i'd have to actually use monads in it to justify ircmonad :P
20:01:22 <Cin> (by use i meant implement)
20:01:35 <nelhage> You don't have an Irc Monad? :)
20:01:44 <piojo> nolrai: doesn't "sequence" do than?
20:01:48 <piojo> that*
20:02:04 <sclv> aha! http://blog.moertel.com/articles/2007/12/17/pxsl-tools-1-0-your-ticket-out-of-xml-hell
20:02:10 <Cin> nelhage: i've been thinking about how i want it
20:02:10 <lambdabot> Title: PXSL Tools 1.0: Your ticket out of XML Hell, http://tinyurl.com/29n38w
20:02:23 <sclv> Not a lib for working with haskell in xml exactly, but it was going to *kill* me if I couldn't remember it.
20:02:49 <dmwit> Cin: Call it "anger", a synonym for "irk". ;-)
20:03:07 <sclv> > sequence [Just 5, Just 10, Just 20, Just (25::Int)]
20:03:07 <dmwit> irked
20:03:08 <lambdabot>  Just [5,10,20,25]
20:03:12 <sclv> > sequence [Just 5, Just 10, Just 20, Just (25::Int), Nothing]
20:03:13 <lambdabot>  Nothing
20:03:22 <sclv> > sequence [Nothing, Just 5, Just 10, Just 20, Just (25::Int)]
20:03:22 <lambdabot>  Nothing
20:03:33 <dmwit> > catMaybes [Nothing, Just 5, Just 10, Just 20, Just (25::Int)]
20:03:33 <lambdabot>  [5,10,20,25]
20:04:04 <sclv> that too. :-)
20:04:09 <dons> > catMaybes [Nothing, Just 5, Just 10, Just 20, Just 25] -- defaulting!
20:04:10 <lambdabot>  [5,10,20,25]
20:04:10 <dmwit> > mconcat [Nothing, Just 5, Just 10, Just 20, Just (25::Int)]
20:04:10 <lambdabot>   add an instance declaration for (Monoid (Maybe Int))
20:04:10 <lambdabot>     In the expression:...
20:04:25 <ddarius> msum
20:04:32 <dmwit> > msum [Nothing, Just 5, Just 10, Just 20, Just (25::Int)]
20:04:32 <lambdabot>  Just 5
20:05:10 <sclv> > listToMaybe . catMaybes $ [Nothing, Just 5, Just 10, Just 20, Just 25]
20:05:12 <lambdabot>  Just 5
20:05:20 <Cin> sod it. i'll go for ircmonad
20:06:09 <dmwit> or Cinrc =)
20:06:40 <Cin> IRCin, etc. awful :P
20:06:45 <ddarius> Cin Sity
20:06:53 * Cin cries
20:07:26 <Cin> right
20:07:28 <phobes> What does your awesome useful irc program do?
20:07:51 <dons> get it on hackage, and into debian packages, and spread the goodness around
20:07:52 <Cin> well, people can chat on it. i'm intending on making bits of it re-loadable
20:08:11 <phobes> so it's an IRC client?
20:08:17 <Cin> phobes: no an irc daemon
20:08:25 <Notostraca> irc bot?
20:08:34 <Cin> so i should be able to wrap the IO monad _inside_ my IRC monad, right?
20:08:42 <Cin> Notostraca: an irc server. like freenode, heh
20:08:58 <dmwit> Cin: right, that's typical
20:09:02 <nelhage> Cin: Right. Using Monad transformers over it is usually the common way
20:09:09 <nelhage> See for instance XMonad.hs in XMonad
20:09:24 <Cin> okay, right
20:09:43 <ddarius> That's one of the nice things about lambdabot; there was no discussion of the name.
20:10:47 <Notostraca> How about hIRCules, is that taken?
20:10:50 * sclv wants a pure IRC server. It'll scale and parallelize beautifully no matter how many people can't connect to it!
20:10:55 <ddarius> Notostraca: Yes it is.
20:10:58 <awesame> say I have:
20:11:02 <Cin> it's interesting, my program is essentially implementing a monad already and it's only after understanding them thanks to YAHT that i can see how perfectly it fits as a monad. ie all my "events" take a State and return State IO. so obvious.
20:11:10 <awesame> data Foo = Bar String | Baz Int
20:11:24 <Cin> yes, there is hircules the IRC client
20:11:35 <awesame> is there any way to pull the String our of an expression like Bar "hello"?
20:11:48 <Cale> awesame: By pattern matching
20:11:54 <scook0> :t maybe
20:11:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:11:58 <Cale> Either defining your function like:
20:12:02 <Notostraca> oh... that would have been nice to fit with all the other H*** programs
20:12:05 <scook0> :t fromMaybe
20:12:05 <lambdabot> forall a. a -> Maybe a -> a
20:12:06 <blbrown> :t do
20:12:07 <lambdabot> Empty 'do' construct
20:12:07 <Cale> f (Bar s) = ... s ...
20:12:10 <Cale> or:
20:12:11 <Cin> awesame: you generally pattern match it in either your function's parameters, let or where, and other places
20:12:13 <nelhage> Hmm, I guess I remembered wrong. It's XMonad/Core.hs in the xmonad source :)
20:12:14 <blbrown> :t do
20:12:15 <lambdabot> Empty 'do' construct
20:12:15 <Cale> f x = case x of
20:12:20 <Cale>       Bar s -> ...
20:12:29 <awesame> I see
20:12:31 <awesame> thanks!
20:12:34 <Cale> (er, not quite indented as far as I wanted, but you get the idea :)
20:12:56 <Cin> blbrown: if you want the general rules of what `do' is, there are good transformation rules on YAHT's chapter about monads
20:12:58 <shachaf> Or just f (Bar s) = ...; f (Baz n) = ...
20:13:07 <blbrown> Cin: do isnt a type, I am guessing
20:13:23 <shachaf> blbrown: It's syntax.
20:13:50 <dmwit> blbrown: More importantly, do isn't a value.  It's syntax to introduce sequences of monadic actions.
20:14:53 <hpaste>  (anonymous) pasted "useful haddock.sh" at http://hpaste.org/5446
20:15:01 <Cin> blbrown: it's syntactic sugar for something underneath which is quite simple. e.g. do { foo <- bar; mu } is like bar >>=\foo mu
20:15:18 <dmwit> In particular, "do { x; ... }" becomes "x >> do { ... }", and "do { val <- x; ... }" becomes "x >>= \val -> do { ... }".
20:15:19 <Cin> blbrown: er, correction: \foo -> mu
20:15:30 <Cin> what he said
20:16:17 <dmwit> (The base case is that "do { x }" is exactly equivalent to "x".)
20:16:17 <Cin> here: http://en.wikibooks.org/wiki/Haskell/YAHT/Monads#Do_Notation
20:16:20 <Cin> check the list of rules
20:16:32 <hpaste>  (anonymous) annotated "useful haddock.sh" with "(no title)" at http://hpaste.org/5446#a1
20:16:45 <shachaf> dmwit: Well, except for types, in some cases.
20:16:54 <shachaf> > do 5
20:16:54 <lambdabot>   add an instance declaration for (Num (t t1))
20:16:55 <lambdabot>     In the expression: 5
20:16:55 <lambdabot>     I...
20:17:00 <hpaste>  (anonymous) annotated "useful haddock.sh" with "(no title)" at http://hpaste.org/5446#a2
20:17:24 <dmwit> shachaf: Hmm, right.  What's a good way to say that?
20:17:44 <dmwit> Maybe:
20:18:06 <kaol> > do "hello"
20:18:07 <dmwit> "do { x }" is exactly equivalent to "return () >> x".
20:18:07 <lambdabot>  "hello"
20:18:24 <dmwit> > return () >> 5
20:18:24 <lambdabot>   add an instance declaration for (Num (m b))
20:18:34 <shachaf> dmwit: That's assuming the monad laws, probably.
20:18:39 <dmwit> yeah
20:18:42 <dmwit> =/
20:18:43 <Cin> dmwit: and return () >> x equvilant to x, right?
20:18:55 <Cin> pretty sure the monad laws are also on that link
20:18:56 * Cin checks
20:19:03 <dmwit> Cin: As shachaf was just pointing out, up to type restrictions, yes.
20:19:28 <dmwit> How about:
20:19:48 <dmwit> ah, bah
20:19:54 <dmwit> never mind
20:20:05 <Cin> hm?
20:20:10 <dolio> The type restriction of 'do x' isn't in the report, is it?
20:20:23 <dolio> I seem to recall people discussing whether it should be considered a GHC bug.
20:20:25 <ddarius> No it isn't.
20:20:39 <wagle_> > do 1
20:20:39 <lambdabot>   add an instance declaration for (Num (t t1))
20:20:40 <lambdabot>     In the expression: 1
20:20:40 <lambdabot>     I...
20:21:05 <wagle_> do 'a'
20:21:10 <wagle_> > do 'a'
20:21:11 <lambdabot>  Couldn't match expected type `t t1' against inferred type `Char'
20:21:30 <phobes> That's a great error message
20:21:48 <nelhage> ghc is awesome about error messages.
20:21:50 <dmwit> (Monad t) =>
20:21:57 <Cin> shouldn't it be m t1?
20:21:58 <Cin> ah
20:22:28 <piojo> do you guys think writing (generic) searches (BFS,DFS,A*, etc) is a particularly difficult application of haskell? I'm having a bitch of a time with types (and fp in general, somewhat)
20:22:47 <Cin> dmwit: strange that it doesn't put the class in the error message?
20:22:50 <piojo> i'm sort of curious whether i'm just a noob, or whether this stuff is actually hard
20:22:54 <nelhage> piojo: Seems like something that should be relatively straightforward for haskell's type system
20:23:23 <nelhage> [not that I've tried]
20:23:34 <dolio> I've written A* somehwere.
20:23:34 <dmwit> piojo: The hard part is getting the performance you expect; you're probably just a type noob. =P
20:23:51 <piojo> i guess so
20:24:04 <dmwit> (To be honest, it was one of the first things I tried to do in Haskell, and I failed miserably my first few tries.)
20:24:18 <piojo> i've already written depth first search
20:24:34 <piojo> but A* (and its list of unexplored nodes) is proving troublesome
20:24:34 <dolio> Oh yeah, of course. It was the A* ruby quiz. ;)
20:25:27 <piojo> how long did it take you guys to feel really comfortable with haskell?
20:25:43 <dmwit> 9-12 months
20:25:50 <ddarius> About a month.
20:25:52 <dmwit> I'm still learning new tricks though.
20:26:27 <dmwit> Don't listen to ddarius, he's some kind of genius freak with a category-theory/abstract algebra background. =P
20:26:37 <piojo> okay ;)
20:26:55 <ddarius> I hadn't even heard of category theory before Haskell and I don't recall if I'd read anything about abstract algebra at that point or not.
20:27:12 <dolio> I think the first time I tried learning, I stopped and went and learned Scheme first instead.
20:27:48 <dmwit> ddarius: Wow, were you really down with monadic programming and stuff after one month?
20:27:56 <Cin> i started haskell at the start of january, so.. a month or so.. i am fairly comfortable, except with monads but i should be confident with them when i've finished adding them to ircmonad
20:28:01 <ddarius> dmwit: Yes.
20:28:11 <piojo> that's impressive
20:28:14 <Notostraca> So, what are everyone's views on why learning Haskell is valuable?
20:28:21 <dmwit> I would say I was pretty comfortable with the pure core of Haskell after a month, but it took me quite a while to appreciate how lists, state, and IO could be tied together.
20:28:30 <Notostraca> I know it is, but what are your reasons?
20:29:04 <piojo> dmwit: that's where i am, i think (comfortable, but the subtleties lost on me)
20:29:15 <phobes> Notostraca:  Learning haskell will help you avoid compiler errors from GHC
20:29:16 <ddarius> Notostraca: I decided to learn Haskell because I wanted to learn a purely functional language.
20:29:20 <dolio> Personally, I think all the theory that makes it into Haskell on a regular basis is pretty cool.
20:29:31 <Cin> i find reasoning about pure functions much easier. as components, you can trust what you use them for and it's guarenteed
20:30:01 <piojo> Notostraca: i just like things that make me think differently
20:30:13 <scook0> Notostraca: because it's a general-purpose language that's extremely different from almost anything else out there
20:30:19 <dmwit> I think it's because of programming speed.  I keep getting programming assignments and thinking, "Oh, that's trivially easy in Haskell", and then going off to hack on Java for a while.
20:31:41 <Notostraca> Yeah, these all seem to be similar.  Haskell is just different, and that helps a lot of people and a lot of tasks
20:32:02 <phobes> The hardest thing for me to get past in learning haskell was the lack of abstraction
20:32:19 <dmwit> eh?
20:32:20 <faxathisia> lack of?
20:32:31 <Cin> curious comment
20:32:33 <phobes> in OO everything is an abstract type, whereas types in a functional language are concrete
20:32:34 <faxathisia> compared to what?
20:32:40 <faxathisia> oh right
20:32:51 <Notostraca> One of my friends thinks having a flat namespace is very bad.  What can I do to convince him that Haskell has ways around that?
20:33:08 <dmwit> Have you seen the module hierarchy?
20:33:16 <dmwit> Haskell doesn't have a flat namespace at all.
20:33:28 <Notostraca> I know, I'm telling him that
20:33:46 <phobes> It's flat though, I think, isn't it?   It's it a 'hierarchy' just through name mangling?
20:33:50 <dmwit> (In fact, Haskell has one of the more flexible namespaces.  import A.B as C)
20:34:14 <dmwit> phobes: Define flat.
20:34:45 <phobes> dmwit:  The . is not an operator, it's just part of the name
20:34:56 <Notostraca> But he says if Programmer A writes a function "Foo" and programmer B writes function Foo with the same type but different implementations, then namespaces are needed to resolve conflicts
20:35:15 <dmwit> Notostraca: Definitely.
20:35:16 <dons> the module system resolves that
20:35:28 <dons> so we've lots of 'Stream' types for exmple, living in harmony
20:35:29 <Cin> phobes: yes, you can have infix functions.
20:35:33 <dmwit> phobes: okay... so?
20:36:09 <dolio> Only MLs don't have a flat namespace? :)
20:36:10 <Notostraca> But if both people include the same module, and there is no data hiding as in OOP, then the problem might still be there, right?
20:36:12 <ddarius> His point is probably that Haskell lacks nested modules.
20:36:13 <phobes> dmwit:  So haskell really has 'flat' module layouts... I'm not saying it's a problem
20:36:30 <cjb> Haskell's namespace is at least as unflat as Python's, no?
20:36:39 <ddarius> Notostraca: There is data hiding if used and you can import qualified or hiding or only what you need.
20:36:39 <Notostraca> Yeah, nested modules ae part of it
20:36:44 <Cin> notostraca: there is "data hiding", if you mean encapsulation
20:37:07 <dons> Notostraca: right. if you import two modules defining 'foo' and just use 'foo', that's ambiguous. you'd need to qualify which module it came from using one of the module system mechanisms
20:37:35 <dons> A.foo or B.foo, import A hiding (foo), import qualified A, etc.
20:37:39 <dmwit> Notostraca: If you import two modules with a same-named function, the compiler will tell you to get your act together. =)
20:37:58 <ddarius> dmwit: No it won't.  Only if you use an ambiguous name will it say anything.
20:38:07 <dmwit> yeah, yeah, I know
20:38:16 <dmwit> This is propaganda.
20:38:21 <Notostraca> My friend only has experience in C and a little C++, so he doesn't have much familiarity with a pure language; I am not sure if he realizes that Haskell lacks destructive assignment
20:38:29 <ddarius> It would be annoying if that were the behavior.
20:38:31 <dmwit> Slightly fuzzy truths are allowed. ;-)
20:38:37 <Cin> "object oriented programming" is the same type of thing except with qualification by default
20:38:47 <dons> its a much more structured namespace than C :)
20:38:49 <phobes> Notostraca:  Does C even have namespaces?
20:38:52 <ddarius> Notostraca: If he's primarily familiar with C, why the heck is he so on with namespaces?
20:39:01 <Notostraca> using namespace std; ?
20:39:06 <phobes> That's C++
20:39:06 <Cin> phobes: in a primitive, crappy, way
20:39:07 <dmwit> C++ only
20:39:09 <ddarius> Cin: You can't unqualify in OO.
20:39:11 <Notostraca> crap.
20:39:14 <Cin> ddarius: right
20:39:24 <wagle_> names can be local to a file in C
20:39:26 <Notostraca> I dont speak C, I'm just not old enough
20:39:29 <ddarius> Cin: Which can be a pain if you can only stick stuff in classes.
20:39:32 <phobes> Cin:  I know it has 'static' linkage... but Id idn't know if C99 added something better
20:39:51 <Cin> ddarius: i agree.
20:40:01 <dmwit> Notostraca: In any event, Haskell does much better than C in the namespace department.
20:40:07 <Notostraca> True.
20:40:48 <dmwit> From what I have seen of C++ namespace management, Haskell does better than C++, too.
20:40:49 <Notostraca> I am amazed C is still used, but I guess if speed is critical...
20:40:56 <faxathisia> heh me too
20:41:03 <wagle_> linux kernel has a more complicated namespace..  with exports to modules
20:41:05 <dons> its a useful assembly
20:41:07 <ddarius> dmwit: They are not really comparable.
20:41:42 <Cin> notostraca: if you've seen spj's graph of why languages live and die, "and then you get languages with which so many programs are written in them... they can't /ever/ die!"
20:41:42 <dons> and C is easy for foreign languages to bind to. unlike C++
20:41:49 <dmwit> ddarius: Care to elaborate?
20:41:52 <dons> write more programs peoples!
20:42:03 <loupgaroublond> any reason why 'ghc-pkg check' would tell me packages are missing when i can find them in /usr/lib/ghc/lib/ ?
20:42:06 <kmcallister> ?djinn ((a -> b) -> a) -> a
20:42:06 <phobes> The C/C++ compile to object file system is archaic and terrible
20:42:06 <lambdabot> -- f cannot be realized.
20:42:19 <Notostraca> Haskell programs, you mean?
20:42:25 <faxathisia> mumble
20:42:35 <Cin> dons: i'm writing as fast as i can!
20:42:36 <faxathisia> I wanted to but >:)
20:42:47 <Cale> Notostraca: No, he means Fortran programs ;)
20:42:55 <ddarius> namespace foo { namespace bar { class Baz { class Quux {} } } } Haskell can't do that, but C++ doesn't really have any export/import crap like hiding qualified as etc.
20:43:19 <Notostraca> Hahaha.  Fortran is amazing too, its actually slower than Java
20:43:28 <dolio> Huh?
20:43:38 <dmwit> ddarius: module Foo.Bar where ... -- basically the same, no?
20:43:49 <Cale> Notostraca: You must have a poor implementation of it.
20:43:52 <wagle_> you used a crappy fortran compiler
20:44:08 <ddarius> No.  Even if it was, it's a pain in the butt to have to move a module to another file
20:44:17 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
20:44:18 <lambdabot> -- f cannot be realized.
20:44:21 <Cale> Notostraca: It's fairly low level, and tends to do better than C for raw speed at numerical things.
20:44:32 <Trinithis> if a monad has mzero, should it always equal fail?
20:44:43 <ddarius> Usually Fortrans have vectorized/superscalar extensions.
20:45:02 <faxathisia> @src mzero
20:45:03 <Cale> Trinithis: I wouldn't expect fail to satisfy any reasonable properties.
20:45:04 <dmwit> > fail "hey" :: Either String Int
20:45:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:45:08 <Notostraca> ah, I'm just going by the programming language shootout
20:45:09 <lambdabot>  Left "hey"
20:45:16 <dmwit> > mzero :: Either String Int
20:45:17 <lambdabot>  Left ""
20:45:37 <Cale> (it's not really part of the definition of a monad, it's just a hack to define what happens when there's a pattern match failure in do-notation)
20:45:59 <Trinithis> Cale: fail or mzero?
20:46:04 <dmwit> fail
20:46:27 <dons> its cool how ghc 6.8.2 caught ocaml, http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ocaml
20:46:28 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/glm93
20:46:33 <wagle_> prolly gave fortran a problem it wasnt suited for, or that the programmers didnt know how to do efficiently (whereas the java used a tuned lib function)
20:46:34 <phobes> and with little prompting you can probably get Cale to spend several minutes discussing his alternative preference for the way it should work :)
20:46:42 <LoganCapaldo> mzero is a part of MonadPlus
20:46:49 <Trinithis> mm
20:47:11 <Cale> Trinithis: Monads in general don't necessarily have any well-defined means of handling failure.
20:47:25 <LoganCapaldo> @src MonadPlus
20:47:25 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:47:29 <Trinithis> i was just wondering cause fail aand mzero for List and Maybe. guess this is just a special case
20:47:31 <LoganCapaldo> boooo
20:47:37 <dmwit> GHC whips all kinds of butt at thread-ring.
20:47:47 <Cale> Trinithis: Well, usually in monads with a zero, fail ends up being the same.
20:48:00 <LoganCapaldo> > mzero :: Maybe ()
20:48:02 <Trinithis> ok
20:48:05 <lambdabot>  Nothing
20:48:31 <Cale> Trinithis: But mostly we try to forget that fail exists at all :)
20:48:31 <ddarius> 6.10 will be a good GHC
20:48:38 <Trinithis> hah
20:49:00 <wagle_> > mzero :: String
20:49:01 <lambdabot>  ""
20:49:26 <Trinithis> does fail occur often? or if it does, usually leave it as an error?
20:49:30 <dons> ddarius: yeah, spj spent so long on the optimiser, and simonM so long on the runtime, that we caught ocaml without needing a good code gen :)
20:49:31 <Cin> dons: you're like Why (of Ruby fame) on steroids :P
20:49:48 <dons> oh?
20:50:01 <Cale> Trinithis: In most monads, fail is just an error.
20:50:02 <dons> that's the guy that wrote the main ruby intro?
20:50:10 <Cin> dons: well you know how he made Try Ruby and they all say how he's such an asset to Ruby, etc.
20:50:17 <dons> oh :)
20:50:18 <Notostraca> Why also made nic.d
20:50:21 <dolio> dons is nowhere near as crazy as Why.
20:50:28 <dons> i could try!
20:50:39 * dons makes wooop woop noises
20:50:43 <dons> lambda up peoples!
20:50:44 <Trinithis> lol
20:50:45 <Notostraca> nic.d lets you register invalid domain names to use on his DNS
20:50:51 <Cin> well typed noises, of course
20:51:11 <wagle_> :t wooop woop
20:51:13 <lambdabot> Not in scope: `wooop'
20:51:13 <lambdabot> Not in scope: `woop'
20:51:17 <Cin> crazy, but not /that/ crazy
20:51:20 <dons> ah ok :)
20:51:21 <Pseudonym> @vixen woop woop
20:51:21 <lambdabot> )
20:51:24 * dons settles down
20:51:27 <dons> boing!
20:51:32 <faxathisia> :t a b c d ....
20:51:33 <lambdabot> parse error (possibly incorrect indentation)
20:51:33 <dons> ?quote shapr
20:51:34 <lambdabot> shapr says: I've tried to teach people autodidactism, but I've realized they have to learn it for themselves.
20:51:38 * faxathisia wonders..
20:51:39 <shapr> Yup
20:51:44 <shapr> It's true.
20:51:48 <dons> all my silliness i learnt from shapr
20:51:51 <shapr> hah!
20:51:56 <shapr> I still have lots to spare!
20:52:01 <dons> he's carrier zero.
20:52:08 <shapr> Ooh, what does that mean?
20:52:10 <dons> spreading silliness to all he contacts.
20:52:12 <dmwit> :t a b .... c d
20:52:14 <lambdabot> Not in scope: `a'
20:52:14 <lambdabot> Not in scope: `b'
20:52:14 <lambdabot> Not in scope: `....'
20:52:18 <phobes> You need to improve your Shapr Image
20:52:34 <shapr> hah!
20:52:35 <Pseudonym> While that may be true for dons, shapr has never flutzpah boing boing wapwapwapwap p'ting!
20:52:40 <dons> shapr: oh, you know, the source of an outbreak is carrier zero.
20:52:49 <shapr> phobes: I'm working on it! Exercise, you know.
20:52:49 <phobes> Yes, stupid conversation ending puns are my forte
20:52:51 <faxathisia> :D
20:52:52 <shapr> dons: Aha!
20:52:55 * dons boings
20:52:59 * shapr bounces
20:53:06 <Trinithis> @src MonadFix
20:53:06 <lambdabot> class (Monad m) => MonadFix m where
20:53:06 <lambdabot>     mfix :: (a -> m a) -> m a
20:53:13 <Pseudonym> And furthermore, stoat vole wibble.
20:53:13 <shapr> @index mbreak
20:53:14 <lambdabot> bzzt
20:53:19 <shapr> aww
20:53:20 <Trinithis> @src MonadCont
20:53:21 <lambdabot> class (Monad m) => MonadCont m where
20:53:21 <lambdabot>     callCC :: ((a -> m b) -> m a) -> m a
20:53:22 <dons> Pseudonym's rather silly, in a refined way
20:53:24 <Pseudonym> (All my silliness I learned from Monty Python.)
20:53:25 <faxathisia> msplit
20:53:38 <dons> yes, very much of the ministry of silliness
20:53:39 <Cin> pseudonym: cthulhu rl'yeh wgah'nagl fhtagn
20:53:47 <Pseudonym> Lemon curry?
20:53:56 <dolio> Wow, GHC 6.8.2 even about ties Erlang on thread ring.
20:54:09 <shapr> Cool!
20:54:29 <Trinithis> Cin: you might scare the kids!
20:54:41 <dons> dolio: it should beat on gentoo (the maintained machine)
20:55:10 <dolio> Oh, wait, yeah. 1.1 in black means GHC is better?
20:55:13 <Cin> trinithis: to hell with the kids, tell them i've gone Stephen Fry, i'm in brussells with no shoes, eating.. pies
20:55:31 <Cale> GHC is faster on thread-ring
20:55:39 <dons> dolio: yeah
20:55:45 <Trinithis> Cin: Stephen Fry?
20:55:57 <dolio> Impressive, I guess.
20:56:17 <Cale> and uses half as much memory
20:56:47 <Notostraca> Can the Shootout's Haskell thread ring program be improved?
20:56:52 <Notostraca> http://shootout.alioth.debian.org/gp4/benchmark.php?test=threadring&lang=ghc&id=2
20:56:52 <lambdabot> Title: thread-ring (new) Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nb ..., http://tinyurl.com/34vjft
20:57:19 <dmwit> Notostraca: Do you have a suggestion?
20:57:22 <Notostraca> I only see one line of total gibberish, so I wonder
20:57:44 <Notostraca> I can barely read monads right now, so forgive me
20:58:14 <dons> that's a pretty simple program. hard to improve on it
20:58:18 <Cale> Which line is gibberish?
20:58:27 <dolio> You could change everything to TVar and see if that changes anything. :)
20:58:31 <Notostraca> I am just saying, Erlang seems to be awful close to Haskell on that program but not on very many others
20:58:46 <phobes> There's no requirement that these "threads" be OS threads, right?
20:58:47 <dons> the erlang one was based on the haskell one, iirc
20:58:47 <dmwit> Oh.
20:58:48 <dmwit> heh
20:58:55 <Notostraca>  putMVar r $! m - 1
20:59:00 <dmwit> Erlang was built for threading.
20:59:01 <Cale> Notostraca: Well, Erlang's entire claim to fame is based on its concurrency :)
20:59:03 <dolio> Erlang is *the* concurrent language, so Haskell tying it is pretty good.
20:59:20 <dons> last i checked haskell was beating erlang on all thread benchmarks...
20:59:21 <phobes> That problem seems somewhat unfair as it's really about which language defines the lightest weight thread?
20:59:25 <Cale> Notostraca: $! is like $, but strict
20:59:26 <dons> native code + static typing = win
20:59:30 <Notostraca> Oh, so tying is good! Yay!
20:59:35 <dmwit> phobes: right
20:59:44 <Cale> (it forces the m - 1 to be evaluated before putting it in the MVar)
21:00:01 <dmwit> phobes: But... finding out which language has the lightest threads is not such a bad thing, hey?
21:00:03 <phobes> dmwit:  So what makes a "thread"?  What about fibers and microthreads?
21:00:54 <Cin> ooo. the use of foldM is nice. foldM is nice.
21:00:55 <Cale> What do language implementations with heavier-weight threads buy with the additional memory?
21:01:21 <dons> nothing?
21:01:30 <phobes> Cale:  Generally just a full stack, thread local storage... not much really
21:01:35 <dons> no need for a N -> M thread shceduler to map onto the kernel?
21:01:51 <dons> they just run the heavy threads directly in kernel threads ,rather than multiplexing to them
21:02:01 <Cale> ah
21:02:28 <Cale> So it really just means that the language implementors are lazy :)
21:02:42 <phobes> well in C, threading is a library
21:03:10 <dons> well, support is in the kernel. and the kernel is the C runtime
21:03:22 <Cin> aren't "green threads" quite risky because if you mess up it can crash your system? :o
21:03:36 <dons> mess what up?
21:03:47 <dons> bugs et al?
21:03:52 <Cin> i don't know. it was just an eval in the dark
21:04:09 <dons> its an interesting question. i guess so -- sharing one heap is more error prone that lots of separate heaps
21:04:55 <dolio> I seem to recall people desiring kernel threads back when I was following Java more.
21:04:57 <phobes> So how does haskell implement sub-OS threads?  Where does it insert escapes?
21:05:12 <phobes> It's not interrupt based is it?
21:05:31 <phobes> haskell = ghc
21:05:36 <dolio> Perhaps because doing some blocking operation with green threads blocked all the threads?
21:05:52 <dons> phobes: yeah. its interrupts and selecs in the runtime
21:06:53 <phobes> dons: Is it explained in a paper somewhere?
21:07:25 <dons> yeah, there's a bunch of papers on concurrent haskell, going back to the early 90s
21:07:28 <sjanssen> phobes: every certain number of heap allocations GHC checks if enough time has elapsed to warrant running another thread
21:07:47 <phobes> sjanssen:  makes sense
21:08:04 <sjanssen> and this leads to the biggest concurrency bug -- tight loops that do no allocation keep all other threads from running
21:08:23 <shapr> Any idea how to beat that?
21:08:24 <phobes> right
21:08:32 <wagle_> timers
21:08:44 <monochrom> I beat that by using data for control, i.e., lists for loops.
21:09:07 <sjanssen> I think ghc also uses timers, but I'm not sure what for
21:09:11 <phobes> shapr:  Maybe identify when it's happened (with profiling in the runtime), and then patch the offending loop to include a poll after the first time it happens?
21:09:23 <Cale> Heh, from Peyton Jones, Gordon and Finne: "Concurrent Haskell represents the next step in this research programme, which aims to build a bridge between the tidy world of purely functional programming and the gory mess of I/O intensive programs."
21:09:39 <phobes> runtime code generation might be a bit too much to bite off if it's not happening at all right now
21:10:17 <shapr> Still, that's a case by case solution.
21:10:32 <Kirakishou> can I get the IO stream as a handle?
21:10:36 <dons> it doesn't seem to happen in real code
21:10:46 <dons> Kirakishou: stdin :: Handle
21:10:47 <dmwit> Kirakishou: stdin, stdout
21:10:58 <Trinithis> :t MonadOr
21:10:58 <Kirakishou> oh, those are the handles?
21:10:58 <dmwit> Kirakishou: (and stderr, of course, silly me)
21:10:59 <sjanssen> dons: it isn't hard at all to contrive an example
21:11:00 <lambdabot> Not in scope: data constructor `MonadOr'
21:11:06 <Kirakishou> thanks
21:11:09 <ac> does anybody remember my question about IArrays and existential types?
21:11:30 <Cale> Heh, what happened to Haggis?
21:11:34 <sjanssen> eg. foo :: Int -> Int; foo x = foo $! x + 1 -- with sufficient unboxing will do it
21:11:45 <dmwit> Trinithis: MonadPlus used to be two separate classes, for two different meanings of mplus.
21:11:49 <Cale> Now there's a name for a real Glasgow GUI.
21:11:53 <faxathisia> heh
21:11:56 <dmwit> Trinithis: That's probably what MonadOr was.
21:12:02 <Trinithis> ok
21:12:10 <monochrom> Yeah, I remember dons has precisely a paper on eliminating all allocations. :)
21:12:41 <Gwern-away> :i fromJust
21:12:45 <sjanssen> ha, that's a good one
21:12:49 <ac> I think it may have been EvilTerran who said I should just use parameterized types, but I can now articulate why I don't want a parameterized data type
21:12:53 <monochrom> hahaha
21:13:03 <sjanssen> dons: if streams fusion gets good enough, all programs will exhibit this bug! :P
21:13:06 <shapr> ac: Why?
21:14:00 <shapr> @users
21:14:00 <lambdabot> Maximum users seen in #haskell: 471, currently: 422 (89.6%), active: 21 (5.0%)
21:14:07 <shapr> Whoa, 471
21:14:12 <shapr> Looks like we're on the way to 500
21:14:12 <dons> sjanssen: hehe
21:14:15 <ac> shapr: because this particular data type that contains some sort of array is also inside a larger data structure (PNGImage) that would also have to be parameterized then. In most cases, the user isn't evening going to use the smaller data structure, so they'd have to explicitly deal with the type paramater
21:14:18 * sjanssen has a zany idea to address the tight loop issue
21:14:25 <dons> that's right. no heap allocation. and harder to parallelise!
21:14:33 <Kirakishou> what's the syntax for guards again?
21:14:50 <dons> f x | x > 10 = y
21:14:58 <Kirakishou> thanks
21:15:02 <shapr> ac: Why not just offer the user a type that's already filled in?
21:15:07 <shapr> sjanssen: ooh, what is it?
21:15:14 <ac> shapr: what does that mean?
21:15:26 <sjanssen> set a timer with a moderately large granularity, if two timer signals are received in a row and there hasn't been a heap allocation, we know that the thread is being naughty
21:15:44 <Kirakishou> == can compare strings, right?
21:15:54 <sjanssen> so just spin off a new OS thread and have it start taking jobs from the thread queue
21:15:56 <Gwern-away> > "foo" `elem` ["foo", "bar"]
21:15:57 <lambdabot>  True
21:16:35 <sjanssen> potentially you'd allocate an unbounded number of OS threads, of course
21:16:36 <phobes> sjanssen:  and you'd need a way to collect OS threads
21:16:44 <sjanssen> phobes: GHC has all that
21:17:42 <wagle_> there's a tradeoff between timers and polling..  see "soft timers" and "firm timers" (and whatevers happened in the past 4 years since)
21:17:46 <nelhage> Are there bindings to work with ical calendar files with haskell?
21:17:46 <sjanssen> phobes: we don't write off the errant OS thread forever, we'll just clean up after it once it starts being nice
21:17:50 <shapr> ac: type PNGImage = PNG Image ?
21:18:09 <sjanssen> is this idea notable enough to suggest to GHC HQ?
21:18:44 <phobes> sjanssen:  Right... I was just worried about the unbounded case.  What happens when a substantial number of jobs are ill behaved?
21:19:10 <sjanssen> phobes: out of memory/OS thread limit/crash
21:19:10 <ac> although it's probably mostly irrelavent, I'll try to describe the specific problem here. The smaller data structure is the palette, which is simply an array of colors. However, most images won't even have a palette, so PNGImage has a { imagePalette :: Maybe Palette } in it
21:19:29 <sjanssen> phobes: but it's no worse than the alternative (looping forever), as I see it
21:19:57 <ac> however, when an image does have a palette, I think it would be nice if a user could set and retrieve it using whatever array implementation they felt like
21:20:21 <sjanssen> phobes: oh, I think I see what you mean.  What if the loops are just long, but not infinite, and they happen frequently
21:20:28 <phobes> sjanssen: ya
21:20:55 <sjanssen> phobes: so yeah, GHC ought to drop excess threads when there are too many
21:21:07 <Kirakishou> :t Just
21:21:08 <lambdabot> forall a. a -> Maybe a
21:21:13 <phobes> sjanssen:  Or just never let it get to very many and say this doesn't fix that case
21:21:15 <Kirakishou> :t return . Just
21:21:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m (Maybe a)
21:21:17 <shapr> ac: type PNGPalette = PNG Palette ; type PNG = PNG () ?
21:21:39 <shapr> Er, type PNGNoPalette = PNG () -- doh
21:21:45 <sjanssen> phobes: ah, but then you're only slightly decreasing the chance of the issue, not preventing it
21:21:52 <phobes> sjanssen: right
21:21:58 <sjanssen> phobes: we can actually do something like this with +RTS -N
21:22:13 <ac> shapr: how is that different from Maybe?
21:22:28 <sjanssen> phobes: GHC will allocate N threads at start up, so you'd have to wedge those N to really wedge the whole program
21:22:45 <hpaste>  gwern pasted "xmonad pseudo-code" at http://hpaste.org/5447
21:22:48 <shapr> ac: It's a type instead of a record. I don't know why that's better, except that I prefer types to records.
21:23:12 <Twey> Record syntax is just sugar IIRC.
21:23:15 <phobes> sjanssen:  Ya, that's probably just as good I guess
21:23:42 <ac> shapr: isn't that beside the point? My question was if I should parameterize Palette with a type parameter restricted to IArray, or if I should use an existential type
21:23:51 <shapr> Oh, I don't know.
21:24:00 <shapr> This is what I get for doing C# on a daily basis.
21:24:29 <faxathisia> say you compile some file.. GHC does a topological sort on all the files to decide what order to compile them ?
21:24:45 <faxathisia> except it doesn't directly do it.. isn't that right?
21:25:06 <dons> this is cute just to see what 'zip' looks like in C#, http://jchung2007.blogspot.com/2008/02/gentle-introduction-to-haskell.html
21:25:07 <lambdabot> Title: Joe Chung: A Gentle Introduction to Haskell, http://tinyurl.com/2qf53o
21:25:26 <faxathisia> That's very clean code dons *smirk*
21:25:43 <dons> ?src zip
21:25:43 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
21:25:43 <lambdabot> zip _      _      = []
21:25:46 <dons> mm.
21:25:50 <faxathisia> hey looks like C# fixed the maximal munch thing though
21:25:51 * ddarius has written zipWith in C#
21:26:00 <dons> ?src zipWith
21:26:01 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:26:01 <lambdabot> zipWith _ _      _      = []
21:26:07 <dons> zipWith is nice
21:26:21 <faxathisia> zipWith is fab
21:26:27 <phobes> zipWith should be named zip
21:27:00 <dons> yeah!
21:27:11 * ac is suffering from an existential crisis
21:27:30 <ddarius> Let me assure you, ac, you don't exist.
21:27:34 * faxathisia prove yourself ac!
21:27:47 <faxathisia> or at least show you are inhabited :D
21:27:49 * ac uhm... forall a. ac
21:28:02 <Gwern-away> :t filterM
21:28:03 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
21:28:21 <faxathisia> :t liftM filter
21:28:22 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ([a] -> [a])
21:28:33 <faxathisia> @src filterM
21:28:34 <lambdabot> Source not found. Wrong!  You cheating scum!
21:29:12 <faxathisia> oh it shouldn't be possible to make filterM from filter actually
21:30:06 <Gwern-away> :i filterM
21:30:27 <Gwern-away> :info filterM
21:30:35 <Gwern-away> bah!
21:30:41 <Gwern-away> @hoogle filterM
21:30:43 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
21:30:57 <ddarius> :t (runIdentity .) . filterM . (. Identity)
21:30:58 <lambdabot> forall a. (Identity a -> Identity Bool) -> [a] -> [a]
21:31:11 <ddarius> :t (runIdentity .) . filterM . (Identity .)
21:31:12 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:31:14 * dmwit has written zipWith in Java... which is really annoying and not worth the effort in the end.
21:31:20 <faxathisia> nice :D
21:31:26 <Trinithis> @src Monoid
21:31:26 <lambdabot> class Monoid a where
21:31:27 <lambdabot>     mempty  :: a
21:31:27 <lambdabot>     mappend :: a -> a -> a
21:31:27 <lambdabot>     mconcat :: [a] -> a
21:32:19 <dmwit> The cost to use it with any given new function is higher than just writing out the loop long-hand. =/
21:32:40 <ddarius> The major source of ugliness for me was the need to add setters to deal with cyclic streams.
21:32:44 <faxathisia> different languauge different idoims...
21:32:47 <Cale> Whoa, in the first(?) Concurrent Haskell paper, it was just an error to apply putMVar to an already full MVar.
21:33:07 <Cale> They had the blocking-on-read, but not the blocking-on-write.
21:34:32 <Kirakishou> something's weird.
21:34:39 <Kirakishou> I keep on getting a parse error
21:34:49 <Cale> !paste
21:34:49 <hpaste> Haskell paste bin: http://hpaste.org/
21:34:52 <Kirakishou> "possibly incorrect indentation", it says
21:34:59 <wli> Ugarte: What they don't tell you even there is that some of the "sexual side effects" are permanent.
21:35:04 <Cale> That's not always an indentation problem
21:35:08 <hpaste>  Kirakishou pasted "(no title)" at http://hpaste.org/5448
21:35:24 <dmwit> if in a do block! =)
21:35:29 <Cale> Kirakishou: if/then/else
21:35:31 <Kirakishou> right where the if starts
21:35:34 <Kirakishou> yeah
21:35:38 <Kirakishou> how do I fix?
21:35:40 <dmwit> Kirakishou: Indent the then/else one more space.
21:35:44 <Cale> Kirakishou: indent the 'then' and 'else' at least one more space
21:35:45 <faxathisia> You may do,  (Env parent bindings) <- ask instead of env <- ask
21:36:03 <Kirakishou> hmm
21:36:16 <Kirakishou> emacs' Haskell mode wouldn't do that automatically
21:36:18 <Kirakishou> weird.
21:36:26 <Cale> That is weird then...
21:36:31 <sjanssen> Cale: crazy.  Does the paper say why that's useful?
21:37:04 <sjanssen> Cale: hmm, I suppose you could program nice write once variables with that
21:37:36 <Cale> sjanssen: They mention the current behaviour as another that they're considering near the end of the paper.
21:37:37 <phobes> You can always simulate having block on write with a channel going the other way telling you when it's ok to write the next one...
21:37:59 <Cale> sjanssen: In with having MVars hold a multiset or sequence of values.
21:38:22 <Cale> phobes: Indeed, that's the very next thing they implement with their MVars.
21:38:52 <Cale> Followed by Channels.
21:42:12 <phobes> The thing is there are probably alot of threads that you don't care if they get starved
21:43:09 * phobes rambles off
21:44:18 <Cale> Anyone who has emacs installed at the moment want to try and figure out why Kirakishou is having that problem? (I'd check it out, but the packages in the repo I'm using are presently broken)
21:45:17 <faxathisia> well.. my emacs mode just indents things to various levels
21:45:23 <faxathisia> You have to choose the right one
21:45:37 <dropdrive> I'm a FreeBSD user, and the lang/ghc port appears to be broken?  Any other FreeBSD users here?
21:45:39 <faxathisia> So you just press tab again? :S
21:46:03 <sarehu> yeah, my emacs will keep if then else in a do block aligned too
21:46:07 <sarehu> I thought that was normal
21:46:12 <sarehu> (and broken, but normal)
21:46:28 <Kirakishou> faxathisia, you said I could do (Env parent bindings) <- ask instead of using that case expression
21:46:30 <sarehu> I think that's the main reason I prefer explicit braces+semicolons in do blocks now :)
21:46:37 <Cale> Oh, everyone's talking about behaviour *before* hitting tab. Heh.
21:46:40 <Kirakishou> if I do so, how would I check for NullEnv?
21:47:11 <Cale> Kirakishou: You wouldn't -- it was a suggestion based on the idea that your Environment type had only one constructor.
21:47:17 <dons> nbody on the shootout was using the -fasm backend for double math. more than twice as fast if we switch to -fvia-c :)
21:47:22 <Kirakishou> oh
21:47:26 <Kirakishou> well, it has two.
21:47:30 <Kirakishou> dang.
21:48:11 <Kirakishou> that change would have made the code much prettier...
21:48:40 <dmwit> Kirakishou: (The code you pasted doesn't check for NullEnv.)
21:48:53 <faxathisia> > do (Just x) <- Nothing ; return 1
21:48:54 <Kirakishou> oh?
21:48:54 <phobes> dons: on the thread ring problem?
21:48:56 <lambdabot>  Nothing
21:49:03 <dons> phobes: on the n-body problem
21:49:13 <phobes> ah
21:49:34 <dons> we might climb one notch higher if nbody halves its current time
21:49:56 <dons> oh, maybe not. oberon's winning that benchmark
21:50:23 <dmwit> It would be nice to make that optimization, anyway.
21:51:15 <faxathisia> @src (>>=) Maybe []
21:51:15 <lambdabot> Source not found. Do you think like you type?
21:51:17 <faxathisia> @src (>>=) Maybe
21:51:17 <lambdabot> Source not found.
21:51:22 <faxathisia> @src Maybe (>>=)
21:51:22 <lambdabot> (Just x) >>= k      = k x
21:51:22 <lambdabot> Nothing  >>= _      = Nothing
21:51:27 <dons> yes. nbody is one of the outliers atm. there's 3 programs between 3 and 4x slower than C.
21:51:37 <dons> nbody would come back to around 1.8-2x C.
21:51:40 <dons> much more respectable
21:52:46 <phobes> ya but at least the haskell code is beautiful to read
21:52:55 * phobes coughs
21:53:02 <dons> for those ones, not really
21:53:03 <phobes> energy :: Double -> Ptr Double -> IO Double
21:53:20 <dons> the C guys picked an evaluation strategy, and data representatoin, and we have to follow
21:53:49 <Kirakishou> Can I define a function across two different files?
21:54:00 <monochrom> No.
21:54:03 <Kirakishou> dang.
21:54:07 <dons> i've never thought do do that.
21:54:22 <Cale> How much code is this function? :)
21:54:30 <monochrom> One function across two files is deep do do.
21:55:00 <phobes> I thought ghc supported the c preprocessor?
21:55:06 <Cale> Probably if it's that large that you want to split it across files, it would be best thinking of ways to split it up into smaller abstractions.
21:55:09 <Kirakishou> Cale, a lot.
21:55:26 <Kirakishou> Thing is, this function requires a function from another module,
21:55:30 <Cale> Most Haskell functions are not more than a handful of lines long.
21:55:38 <Kirakishou> which happens to import this module too.
21:55:51 <dons> ok. so they're mutually recursive
21:56:02 <Kirakishou> I get errors.
21:56:05 <dons> haskell can handle that. its just a little more complex than if they're not.
21:56:16 <Kirakishou> "Module imports form a cycle for modules:"
21:56:21 <dons> you have to break the recursion explicitly.
21:56:22 <Cale> That's *supposed* to be supported nicely, but it's only supported in a somewhat ugly way.
21:56:29 <Kirakishou> ?
21:56:50 <sjanssen> @google ghc hs-boot site:haskell.org
21:56:52 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/1409
21:56:53 <lambdabot> Title: #1409 (Allow recursively dependent modules transparently (without .hs-boot or an ...
21:56:58 <dons> you create a 3rd file, Foo.hs-boot that contains the definitions necessary to break the loop
21:57:04 <sjanssen> heh, first we get the bug report about how they suck :)
21:57:04 <allbery_b> you need a .hs-boot file which contains just enough information to break the loo[p
21:57:08 <Cale> Usually I just refactor my modules to lift common bits up into a new module.
21:57:08 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
21:57:12 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
21:57:19 <dons> sjanssen: hehe
21:57:26 <Kirakishou> oh wow
21:57:31 <Kirakishou> you need a whole 'nother file.
21:57:44 <dons> a tiny file with a little bit of a stub in it.
21:57:51 <goalieca> STM in c makes my head asplode...
21:57:56 <Kirakishou> a tiny file is a file.
21:57:56 <goalieca> ugg
21:57:57 <dons> if you know another language that allows mutually recursive modules, without tricks, i'd love to hear about it :)
21:58:04 <monochrom> There is STM in C?
21:58:09 <allbery_b> whereas ideally ghc would load all the files as a single "super-module"
21:58:15 <Kirakishou> I've never even used modules before.
21:58:25 <monochrom> Lies.
21:58:47 <phobes> Modules shouldn't be mutually recursive
21:58:47 <Kirakishou> #include and Java imports don't count.
21:58:58 <monochrom> why?
21:59:04 <Heffalump> that bug request actually wants a semantic change, not just removal of .hs-boot
21:59:05 <phobes> That's bad design
21:59:06 <allbery_b> sometimes it's unavoidable
21:59:14 <Heffalump> phobes: it's very hard to avoid in large programs, IME
21:59:26 <dons> its elegant though, if supported properly
21:59:27 <allbery_b> (well, withhout making a single huge module, which is itself bad design)
21:59:31 <dons> just as mutually recursive defns are
21:59:35 <Cale> Kirakishou: The usual way to solve it is just to move the common bits upward into a new module which is imported by both.
21:59:36 <dons> since you can break code as you please
22:00:10 <phobes> Cale:  Conceptually that seems like the right way to me
22:00:12 <Cale> Kirakishou: Usually that's not so horrible -- sometimes it's really awkward and you need the hs-boot stuff, but usually it's not so bad.
22:00:26 <phobes> If you think of modules as logical units of reasoning, then recursive dependencies is not well founded
22:00:39 <Cale> phobes: Sure they are, they're just mutually recursive ;)
22:00:42 <Kirakishou> Also, somebody mentioned that Haskell functions are only supposed to be a handful of lines big
22:01:03 <Kirakishou> Now I'm scared that I'm doing something horribly wrong.
22:01:07 <monochrom> But it's co-recursive dependency.
22:01:10 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
22:01:12 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
22:01:19 <dmwit> ?paste it, people love golfing
22:01:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:01:22 <Cale> Kirakishou: well, sometimes it's not so bad.
22:01:29 <allbery_b> I have some fairly large functions myself.  gtk2hs is procedural currently so it can be hard to avoid :/
22:01:30 <faxathisia> ooh this is cool http://www.cs.auckland.ac.nz/~ute/220ft/graphalg/node16.html
22:01:32 <lambdabot> Title: Topological Sorting
22:01:35 <hpaste>  gwern annotated "xmonad pseudo-code" with "update raise code" at http://hpaste.org/5447#a1
22:01:49 <dons> ?users #xmonad
22:01:49 <lambdabot> Maximum users seen in #xmonad: 117, currently: 97 (82.9%), active: 8 (8.2%)
22:01:49 <faxathisia> So topological sort is used in evaluating haskell expressions?
22:01:56 <phobes> Cale:  To reason that evens is correct you need to basically know the definition of odds
22:02:07 <hpaste>  Kirakishou pasted "(no title)" at http://hpaste.org/5449
22:02:07 <hpaste>  gwern annotated "xmonad pseudo-code" with "forgot the error" at http://hpaste.org/5447#a2
22:02:14 <Cale> phobes: and vice-versa
22:02:15 <Kirakishou> One function.
22:02:20 <phobes> Cale:  sure
22:02:21 <Heffalump> phobes: well, that's all very well, but in practice modules are used to represent logically connected bits of code, not units of reasoning
22:02:34 <Heffalump> faxathisia: yes
22:02:52 <monochrom> Nevermind evens and odds.  To reason that ones is correct you need to reason that ones is correct.  Been there done that.
22:02:54 <Heffalump> ML forces manually topological sorting and use of let rec for strongly connected components
22:02:54 <phobes> Heffalump:  I realize that
22:03:17 <dmwit> Kirakishou: Long enough that it got cut off! =P
22:03:18 <faxathisia> Cool
22:03:38 <Kirakishou> oy, that's bad.
22:04:03 <faxathisia> So there is topological sorts being done at runtime?
22:04:10 <monochrom> Any question about "two things referring to each other" can be boiled down to "a thing referring to itself".
22:04:18 <faxathisia> or is it possible to resolve them all during compilation?
22:04:23 <dmwit> Kirakishou: maybe is a nice function
22:04:25 <dmwit> :t maybe
22:04:26 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:04:39 <Heffalump> faxathisia: all at compile time
22:04:41 <phobes> monochrom:  But referring to each other across module boundaries is what makes the problem interesting
22:04:46 <Heffalump> it's static dependencies, not dynamic ones
22:04:58 <monochrom> It's only psychologically different, not logically different.
22:05:15 <phobes> monochrom:  For purposes of separate compilation, it's different
22:05:43 <Cale> It looks like you could use some more general combinators for managing undefined values.
22:06:11 <Kirakishou> Cale, who, me?
22:06:18 <monochrom> I don't think you're talking about separate compilation?  You're talking about units of reasoning or something like that.
22:06:22 <Cale> yeah
22:06:25 <Cale> Let me see...
22:07:23 <phobes> monochrom:  Right, but they're related, ... if you try to think about modules as coherent wholes, possibly for purposes of separate compilation, you hit this problem
22:07:37 <hpaste>  dmwit annotated "(no title)" with "the "maybe" function" at http://hpaste.org/5449#a1
22:08:22 * dmwit leaves for an hour or so
22:08:27 <faxathisia> woah
22:08:50 <faxathisia> suggestion, Don't have  Multiply
22:08:58 <faxathisia> Have BuiltinOp Multiply
22:09:10 <faxathisia> then you can handle all the Multiply Divide Add.. in one clause
22:10:29 <Kirakishou> huh.
22:10:31 <phobes> Heffalump:  Was your last comment to me talking about ML or haskell?
22:10:49 <hpaste>  Cale annotated "(no title)" with "example" at http://hpaste.org/5449#a2
22:11:22 <Kirakishou> Oh wow
22:11:34 <Kirakishou> why didn't I think of that?
22:11:35 <phobes> Heffalump:  Anyway, I agree with you, but I think the answer is to encourage better practce
22:11:38 <Cale> er, and I left in some unnecessary 'do's by accident
22:12:22 <monochrom> I just realize this difficulty of separate compilation of mutually referring modules is not about mutual reference. In the following few minutes I will explain why I think so.
22:12:50 <phobes> monochrom: sweet :)
22:12:54 * phobes goes to get popcorn
22:12:54 <monochrom> In short I think so because I have seen a similar problem and no recursion is involved. Only context and contextual assumption is.
22:13:28 <Heffalump> phobes: my comments to you were all about Haskell
22:13:41 <monochrom> We know logic.  Things like <statement P> and <statement Q>.
22:13:56 <Heffalump> and I disagree that the current way people use modules is bad practice
22:14:19 <monochrom> I'll write P /\ Q for that.
22:14:30 <phobes> Heffalump:  With the module mechanism in haskell, it would be extremely inconvenient to try to organize things by units of logical reasoning
22:14:52 <Pseudonym> What's a unit of logical reasoning?
22:15:07 <Pseudonym> Is it the proposition, the formula, the sequent, the theorem, or the theory?
22:15:19 <phobes> theory
22:15:25 <sclv> ooh: a hack to fix the if then else in emacs haskell-mode: http://www.emacswiki.org/cgi-bin/wiki/HaskellMode
22:15:26 <lambdabot> Title: EmacsWiki: Haskell Mode
22:15:26 <monochrom> Sometimes we wish to simplify P/\Q. Perhaps we're trying to prove it --- then simplify it to "true".  Perhaps we are not proving it but still we simplify (or complexify) it to another form to see what it says.
22:15:34 <Cale> imports and exports of a module dictate the reasoning that is required to place it in the context of the whole program
22:15:35 <phobes> modules are roughly the same as theories
22:15:44 <wagle_> no reason why primitive functions (that evaluate their arguements) can't just get put in the top level environment (they dont need to be built into the interpreter)
22:15:49 <Pseudonym> phobes: I'm not sure about that.  I suspect a theory might in general be a whole package.
22:15:54 <Pseudonym> In the cabal sense.
22:16:05 <dons> that's kind of amazing, of all the haskell mailing lists, only libraries, cafe, cvs, and ghc-bugs has had more traffic than xmonad@
22:16:20 <phobes> Pseudonym:  Perhaps in haskell
22:16:25 <Chad> If ghc compiles ok, but ghci gives "*** Exception: ghci/ByteCodeGen.lhs:(1204,5)-(1211,34): Non-exhaustive patterns in case", is that a bug?
22:16:28 <Pseudonym> dons: That's not amazing.
22:16:41 <Pseudonym> There's very little else that's of any interest. :-)
22:16:49 <monochrom> Most often we will simplify P/\Q this way. You see how P can be simplified to P', you then write P/\Q = P'/\Q
22:16:51 <dons> well, more than h' , and the total nhc, yhc, haskell-general, ...
22:17:01 <monochrom> And of course sometimes you do that to Q instead.
22:17:02 <Pseudonym> There's a haskell-general?
22:17:09 <dons> haskell@ vs haskell-cafe@
22:17:17 <Pseudonym> Right.
22:17:20 <Pseudonym> That's announce-only.
22:17:29 <flux> chad, ghc doesn't per default do case coverage analysis: unmatched values will raise an exception
22:17:35 <Pseudonym> It's not "general".
22:17:42 <Pseudonym> And, of course, h' is stagnant.
22:18:01 <faxathisia> Are there any quote chars  ' " I can use in a constructor?
22:18:25 <Kirakishou> :t maybe
22:18:28 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:18:29 <faxathisia> ooh ^ works actually
22:18:36 <monochrom> That is similar to separate compilation. You can compile P to P' (here without caring about Q at all). You can compile Q to Q' (again without caring about P at all). Then you have P/\Q compiled to P'/\Q'. Separate compilation.
22:18:42 <flux> faxathisia, ' doesn't work ?
22:18:44 <Chad> flux: So is it a semi-fatal mistake I'm making somewhere, then?
22:18:50 <faxathisia> flux no :(
22:19:10 <flux> chad, yes. perhaps you can suggest ghc to enable it (I don't know how, but I would like to believe the option exists :))
22:19:31 <monochrom> Now, back to simplfying for the moment. Sometimes P cannot be further simplified alone.
22:19:33 <Chad> flux++ ok I'll check it out, thanks!
22:20:07 <monochrom> For example, x+y=0 /\ x-y=0.  x+y=0 cannot be further simplified alone.  x-y=0 neither.
22:20:18 <Cale> Chad: Hacking on GHC?
22:20:28 <monochrom> But you know that the whole thing ought to be simplified down to x=0 /\ y=0 !
22:20:33 <phobes> monochrom:  In my world view, this is exactly the same problem as recursive dependencies
22:20:53 <wagle_> not in Int
22:20:58 <monochrom> So here is how. There is a rule you can use. It's called "context law" in my circle.
22:21:11 <wagle_> prolly not in Float or Double
22:21:31 <monochrom> The context law says, when you simplify P/\Q, you may assume Q true, and simplify P.
22:22:40 <monochrom> Here is why the law is valid. Case analysis. If Q false, P/\Q false too anyway, doesn't hurt if you replace P by anything you like. If Q true, then you're allowed to assume Q true afterall.
22:22:56 <wagle_> > MaxInt
22:22:57 <lambdabot>   Not in scope: data constructor `MaxInt'
22:23:37 <wagle_> @index MaxInt
22:23:37 <lambdabot> bzzt
22:23:50 <wagle_> @index Maximum Int
22:23:50 <lambdabot> bzzt
22:23:53 <wagle_> @index MaximumInt
22:23:54 <lambdabot> bzzt
22:23:57 <wagle_> bah
22:24:00 <monochrom> So x+y=0 /\ x-y=0 again. Or perhaps x=-y /\ x=y.  Assume x=y, simplify x=-y to x=-x, x=0.  The whole thing is first compiled to x=0 /\ x=y.
22:24:16 <monochrom> A similar step compiles that further to x=0/\y=0.
22:24:20 <wagle_> X = Y = MAXINT / 2
22:25:00 <RayNbow> good morning #haskell :)
22:25:23 <monochrom> A precaution to the use of the context law is this. You can't simplify them at the same time. When you assume Q, you can't simplify Q at that moment.
22:25:33 <phobes> monochrom:  Right
22:26:02 <phobes> monochrom:  You can't assume P and simplify Q and simultaneously assume Q and simplify P
22:26:35 <hpaste>  gwern annotated "xmonad pseudo-code" with "working example" at http://hpaste.org/5447#a3
22:26:48 <monochrom> Here is unsoundness if you do.  Simplify x/=x /\ x/=x. Assuming the second, the first becomes true. Assuming the first, the second becomes true.  x/=x /\ x/=x becomes true/\true.
22:26:49 * wagle_ watches monochrom cover his ears and sing lalala
22:27:59 <Gwern-away> :t fromMaybe
22:28:00 <lambdabot> forall a. a -> Maybe a -> a
22:28:10 <phobes> monochrom:  I'm not sure I see what this gets us in terms of modules
22:28:36 <Gwern-away> hm. what's the 'head' you use when the list might be empty? I'm sure I've seen it before
22:28:49 <dolio> @type listToMaybe
22:28:50 <lambdabot> forall a. [a] -> Maybe a
22:29:03 <Gwern-away> yes, I think that's it
22:29:04 <phobes> monochrom:  If you have P and Q, then you can just do direct simpliciation of P and Q
22:29:32 <monochrom> So with modules P and Q, suppose there is some way that P and Q are both correctly compiled.  Now you change P, but don't change Q.  There is no problem re-compiling P separately.
22:30:08 <monochrom> There is only unsoundness if you change P and Q both, and then re-compile separately.
22:30:11 <phobes> monochrom:  Depends on your premises
22:30:15 <Gwern-away> : listToMaybe
22:30:29 <Gwern-away> @hoogle listToMaybe
22:30:29 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
22:30:44 <phobes> monochrom:  Consider mutually recursive functions f and g with the definition f = 1, g = 1
22:31:04 <phobes> monochrom:  You can define f = g and g = 1 or g = f and f = 1, but you can't define f = g and g = f
22:31:07 <monochrom> Let me be more concrete. Suppose yesterday you already had P.hs, Q.hs, both correctly compiled to P.hi, Q.hi already.
22:31:30 <monochrom> Today you modify P.hs. To re-compile, you only need to read P.hs and Q.hi.
22:31:53 <Cale> Kirakishou: oh, I should also mention that you can generalise it to more parameters, or a list of things to be evaluated.
22:31:56 <phobes> What does "correctly compile" mean?
22:32:02 <phobes> Consider my example
22:32:12 <jeffz> hi, I'm trying an example from here http://legacy.cs.uu.nl/daan/download/parsec/parsec.html  http://hpaste.org/5450 ghc tells me that `Show' is not applied to enough type arguments, but I don't understand what it means
22:32:35 <Kirakishou> Cale, what do you mean?
22:32:43 <monochrom> "Correctly compile" means correctly compiled according to Haskell 98. I don't have to give an algorithm.
22:32:50 <Cale> Kirakishou: I'll write an example...
22:33:21 <Kirakishou> you mean make a withEvals :: [LispVal] -> (LispVal -> LispM) -> LispM
22:33:37 <monochrom> Ah, if P.hs is modified, Q.hi is also invalid. I'll have to re-think.
22:33:44 <sclv> jeffz: Show should probably be (Show a) ?
22:33:44 <phobes> monochrom:  Using your terminology from before, you have to remember what the simplification order you used was
22:33:55 <jeffz> sclv: yeah, I was just thinking I made a typo there ;) thanks
22:33:59 <phobes> monochrom:  So if you used the reasoning that P and Q => P' and Q, then you need to remember that
22:34:27 <monochrom> OK, mutual module reference is unlike the context law. I'll quit.
22:34:42 <hpaste>  Cale annotated "(no title)" with "example 2" at http://hpaste.org/5449#a3
22:34:42 <phobes> monochrom:  Well I think it's directly analogous
22:34:52 <sclv> you might already get this, but Show is a class constraint in that context. So you need to fulfill its arity. if that makes sense.
22:34:52 <hpaste>  gwern annotated "xmonad pseudo-code" with "handle partiality" at http://hpaste.org/5447#a4
22:34:53 <jeffz> sclv: I guess you don't see these things until you paste them in the channel sometimes
22:34:54 <monochrom> Now our roles have switched.
22:35:01 <phobes> monochrom:  hehe
22:35:20 <phobes> monochrom:  No I think your analogy was very dead on (in fact I think the two are formally isomorphic in a certain sense)
22:35:20 <sclv> jeffz: i feel that way after i email the cafe :-)
22:35:23 <monochrom> In the context law, when you go P/\Q = P'/\Q, Q is not "invalidated", whatever that means.
22:35:25 <Cale> Kirakishou: withEvals :: [LispVal] -> ([LispVal] -> LispM) -> LispM
22:35:42 <Kirakishou> oh, right.
22:36:05 <monochrom> But in compilation, when you modify P.hs, Q.hi is invalidated, even Q.hs may be totally type errored.
22:36:06 <Cale> Kirakishou: that 'nest' function I provided, I just discovered the other day. It's handy for exactly this sort of thing.
22:36:18 <phobes> monochrom:  In the analogy to modules, propostions represent "things that are true about the compiled code", not the compiled code itself
22:36:39 <Cale> Kirakishou: It can be written without the Cont monad, but it looks messy by comparison :)
22:36:52 <Kirakishou> oooh
22:37:34 <sclv> that nest function looks like it might become a classic.
22:37:39 <monochrom> Yes. You start out with (P.hs has no type error) /\ (Q.hs has no type error).  Now you modify P.hs.  You may cause Q.hs to have type errors.  The context law would not do that.
22:37:41 <phobes> monochrom:  So you start with specifications P and Q of modules and want to seprately compile code satsifying both specifications
22:38:44 <phobes> monochrom:  Now you assume that P can be compiled, and deduce additional things about specification Q - we'll call the result Q'
22:39:06 <phobes> monochrom:  Now you go and deduce further things about P in the presence of Q'
22:39:26 <phobes> monochrom:  The point is that now if you recompile P, you can't violate things assumed in Q'
22:39:54 <phobes> monochrom:  You have to remember that you must satisfy Q' - you can't just recompile P against Q
22:40:37 <monochrom> That's right. The context law does that.
22:41:26 <Cale> Kirakishou: You could also generalise it a bit for the cases where you have other error messages...
22:41:42 <Kirakishou> hmm
22:41:50 <Kirakishou> would that be worth it, though?
22:41:51 <phobes> You can view a module specification as a signature and a proposition over it.  Since the structure of the signature doesn't matter much, there's a pretty direct map between these ideas I think
22:41:52 <monochrom> But in the process of software development there is something more.
22:42:23 <sclv> nets looks like sequence over a comonad ? sorta ?
22:42:30 <Cale> Kirakishou: It may be, for the later ones, I'll write it...
22:42:37 <monochrom> So you used the context law to finish the exercise x+y=0 /\ x-y=0.
22:42:44 <Cale> Kirakishou: Of course, keep this one too :)
22:42:54 <monochrom> Now the exercise is slightly changed.  x+y=2 /\ x-y=0.
22:43:08 <monochrom> How much of previous work could you reuse?
22:43:10 <Trinithis> what's kind * vs kind * -> *
22:43:20 <phobes> monochrom:  Right, and to answer that you'd need to remember in what order you made the assumptions
22:43:33 <Cale> err...
22:43:38 <phobes> monochrom:  or do you... maybe it just breaks everything all the time :)
22:43:46 <Cale> oh, you're actually throwing those other errors for different reasons
22:43:51 <Cale> Probably nevermind then :)
22:43:59 <monochrom> There is a worst case of no sound reuse.
22:44:15 <phobes> monochrom:  Ya, that's the proper analogy I think
22:44:36 <sjanssen> Trinithis: * is a type, * -> * is what we call a type constructor, examples:
22:44:39 <sjanssen> @kind Int
22:44:40 <lambdabot> *
22:44:43 <sjanssen> @kind Maybe
22:44:44 <lambdabot> * -> *
22:44:47 <sjanssen> @kind Maybe Int
22:44:47 <lambdabot> *
22:44:56 <Trinithis> ok
22:45:02 <Kirakishou> Cale, different reasons?
22:45:15 <sclv> hmm
22:45:15 <sjanssen> Trinithis: does that make sense?
22:45:16 <sclv> ?ty \x -> mconcat (x::[Int -> Endo String])
22:45:17 <lambdabot> [Int -> Endo String] -> Int -> Endo String
22:45:29 <sclv> mconcat over an endomorphism!
22:45:42 * sjanssen <3 Endo
22:45:46 <sclv> (with the reader thrown in)
22:45:47 <Kirakishou> You mean I can't pass a data constructor thing to a function?
22:45:47 <Cale> Kirakishou: The (WrongType "Number" err) is caused when you inspect the result of the eval and get Just of something which isn't a Number
22:45:51 <monochrom> The initial compilation poses no problem. Since you haven't compiled anything, you're fine with an expensive compile. Here is an expensive compile, but it's sound: merge P.hs and Q.hs, compile as one file, now separate out the object code and the *.hi stuff and assign them to P.hi, Q.hi, P.o, Q.o appropriately.
22:45:54 <Trinithis> sjanssen: yes. I was just kinda confused by looking at instance Monoid [a] where
22:45:58 <dons> sclv: i wonder, let's extend the stricitfy to also support choosing between -O and -O2, -fasm and -fvia-C
22:46:04 <vininim> @kind StateM
22:46:07 <lambdabot> Not in scope: type constructor or class `StateM'
22:46:07 <dons> -optc-O -optc-O2 ...
22:46:12 <dons> we might need alcovea for this actually
22:46:20 <dmwit> ?src Endo
22:46:21 <lambdabot> Source not found.
22:46:25 <vininim> @kind StateST
22:46:25 <dons> just spit the banged programs into alcovea to breed
22:46:25 <lambdabot>     Not in scope: type constructor or class `StateST'
22:46:32 <vininim> gah, whatever =P
22:46:42 <monochrom> It is subsequence software development that poses a problem. You go modify P.hs. If you were willing to do the expensive compile again, there would be no problem. But you want to save time. Now there is a problem.
22:46:53 <sclv> not quite... that gives [(r -> b) -> b] -> (r -> b) -> b
22:46:57 <sclv> while nest is: [(r -> b) -> b] -> ([r] -> b) -> b
22:47:15 <sclv> dons: sounds good! maybe have it play with unfolding thresholds too.
22:47:17 <Kirakishou> Cale, it's kind of embarassing,
22:47:27 <Kirakishou> but I already put this thing on sourceforge
22:47:28 <dons> sclv: so all the flags can be done with alcovea
22:47:32 <dmwit> ?src Endo mempty
22:47:32 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:47:39 <dons> the difference here is that we have to specify exprs strictness in the source
22:47:45 <Trinithis> well, night
22:47:51 <Kirakishou> would you be willing to take a look?
22:48:01 <monochrom> So, as a first-order approximation, I tend to blame the problem of mutual module reference to human greed. :)
22:48:13 <Cale> Kirakishou: sure. You could also use hackage for hosting under normal circumstances :)
22:48:13 <sclv> of course the question is if we can make simplifying assumptions like I did for strictness that give generally good answers...
22:48:16 <sjanssen> dons: use a buncha #defines, and select them via the -D flag?
22:48:19 <sclv> or if we have to try all the permutations.
22:48:25 <Kirakishou> what's hackage?
22:48:29 <dons> sjanssen: ah yes, good idea.
22:48:29 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
22:48:36 <dons> sclv: so we can turn bangs on and off with cpp
22:48:41 <Cale> It's a database of Haskell libraries and programs.
22:48:43 <dons> and then alcovea can do the whole thing
22:49:02 <phobes> monochrom:  If you're willing to merge P and Q together, then you don't really need separate compilation
22:49:13 <dons> sclv: i'm quite surprised at how good ghc is at strictness analysis
22:49:20 <dons> its an eye opener -- it really does behave as expected :)
22:49:29 <Kirakishou> huh
22:49:33 <phobes> monochrom:  And a reasonable solution is to make P depend on Qinterface and Q depend on Pinterface, and then have a master module that glues them together
22:49:45 <sclv> where's alcovea?
22:49:48 <dons> Kirakishou: we gotta keep our libraries somewhere, right? :)
22:50:04 <dons> sclv: oh, its an awesome tool for breeding the best set of compiler flags for a program
22:50:24 <dons> acovea.
22:50:27 <dons> http://www.coyotegulch.com/products/acovea/
22:50:27 <lambdabot> Title: Acovea Overview
22:50:50 <dons> you give it a description of the available flags, and it breeds them until it finds the optimal arrangement
22:50:56 <sclv> oh... cool.
22:50:56 <Cale> Kirakishou: There's a program 'cabal-install' which will download and install the libraries and programs automatically.
22:51:31 <monochrom> There is value in the human separating P and Q, and the computer treating P and Q by merging.
22:52:05 <sclv> does it play well with ghc?
22:52:17 <dons> i wrote a ghc description for it at one piont
22:52:20 <dons> its around here somewhere
22:52:26 <dons> so it knows how to set both ghc and gcc flags
22:52:42 <dons> you just teach it with some xml what flags are available, and which ones to try
22:53:04 <monochrom> Java compilers (certainly Sun's ones) definitely do that to P.java and Q.java. It tries to look for reusable information, but in the worst case it is willing to look at both side by side. It does that automatically, i.e., if you say "javac P.java", it may read both P.java and Q.java and do them together.
22:53:31 <olsner> heh, acovea is cool
22:53:53 <dons> works very well for gcc -- way too many flags to sort through by hand, and with very low level effects
22:53:59 <dons> ghc's more coarse grained
22:54:35 <monochrom> SML sidesteps the whole question by "encouraging" you to write your own sig files.
22:54:39 <phobes> dons:  Does it negatively weight seg-faulting?
22:54:42 <Cin> dons: do you think hircd is a good name? :P i liked ircmonad but it doesn't imply a *daemon*
22:54:57 <dons> yeah, hircd is good
22:54:57 * Cin is about to create a darcs repository
22:54:58 <olsner> ghc should have more -fwiggle-the-doohickey optimization flags for acovea to tweak with then!
22:55:03 <Cin> dons: well i'll stick with that
22:55:18 <phobes> monochrom:  The issue still arises in ML though - they don't support recursive dependenceis
22:55:27 <sclv> hmm.. so the notion would be to have strictify give the version with the best flags to acovea, or the notion would be to generate a file with #defines in the right places and some xml input for acovea that would then breed the strictness annotations along with the flags? or some combination?
22:56:06 <sclv> strictness annotations will behave differently for O and O2, but otherwise shouldn't be affected by flags I think?
22:56:09 <dons> i think probably start with strictify finding the necessary strictness
22:56:21 <dons> then pass the result to acovea to find optimal ghc and gcc flags
22:56:48 <dons> it would be cool to turn on and off individual strictness points, but probably not much is needed beyond what strictify already finds
22:57:00 <Prometheus88> I have a question about how to use "map", specifically how do I write a function f such that map f [el1,el2] wont return a type error?
22:57:01 <dons> btw, did you get my bug report about stack overflows not getting treated as failures?
22:57:21 <dons> Prometheus88: the list elements must have the same type
22:57:27 <Prometheus88> yup got that
22:57:30 <dons> > map toUpper ['x','y','z']
22:57:32 <lambdabot>  "XYZ"
22:57:38 <Prometheus88> I just dont know how to write f properly?
22:57:45 <dons> what kind of 'f'?
22:57:53 <dons> > map (\x -> toUpper x) ['x','y','z']
22:57:54 <lambdabot>  "XYZ"
22:57:58 <Prometheus88> ok well Im doing this for an asgt
22:58:09 <monochrom> phobes: Thank you for conversing with me on this. I now understand more.
22:58:20 <Cale> Is it just me, or did Paul Graham patent the idea of a continuation-based webserver? http://www.google.com/patents?id=WE8GAAAAEBAJ&dq=6205469
22:58:20 <lambdabot> Title: Method for client-server ... - Google Patents
22:58:20 <dons> Prometheus88: you just pass in any function
22:58:23 <Prometheus88> and I started with map (3*) [3,4,5] all good
22:58:27 <dons> Cale, yeah.
22:58:33 <dons> better tell the scheme guys
22:58:43 <jeffz> Cale: it was on reddit some hours ago on the topic of the pending takeover of yahoo by microsoft
22:58:46 <Prometheus88> now how do i write a separate f so that i can write map f pinput]
22:58:50 <phobes> monochrom:  ya, I'm not sure you're wrong.  I'm kind of biased.  My current language design is built heavily around something like modules and doesn't support recursion except explicitly :)
22:59:00 <Prometheus88> i tried f x = x+1
22:59:01 <dons> so WASH will get your sued.
22:59:06 <sclv> dons: didn't get the bug. assuming stack overflows throw an error code, shouldn't be hard to fix though. :-)
22:59:12 <dons> Prometheus88: define it somewhere else in the file
22:59:21 <Prometheus88> yes i did, may i send you the file?
22:59:23 * wagle_ patents the idea of driving to his new house
22:59:24 <dons> sclv: yeah. they should have ExitFailure 1 or something
22:59:28 <dons> ?paste <- Prometheus88
22:59:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:59:36 <phobes> monochrom:  It might be that explicit recursion is very annoying... we'll see
22:59:48 * dons patents the idea of an optimally short tour between houses
22:59:49 <Prometheus88> k ill paste it there
23:00:07 * olsner patents the idea of patenting ideas
23:00:19 <hpaste>  Prom pasted "map" at http://hpaste.org/5451
23:00:20 <Cin> what implications does that have? continuation-based web servers... can't be used in some way or what?
23:00:32 <Prometheus88> http://hpaste.org/5451
23:00:38 <phobes> olsner:  I'm pretty sure some dude on slashdot has already claimed to have done that
23:00:39 <wagle_> dons: s/houses/new houses/  need to avoid prior art at least at the trivial level
23:00:42 <Prometheus88> oh cool it anounced it
23:00:58 <dmwit> Prometheus88: What seems to be the problem?
23:01:00 <monochrom> We need to patent something else to get even. Something that Paul Graham cares, something that's worth patenting, something that's legit to patent.
23:01:05 <sclv> continuation based webservers are only occasionally useful anyway...
23:01:15 <dmwit> Prometheus88: (Everything there looks fine.)
23:01:33 <Prometheus88> I ran hugs :r and it gave an error
23:01:33 <phobes> Don't blame the engineer ... blame the lawyers
23:01:45 <dmwit> Prometheus88: What error?
23:01:48 <phobes> and the courts and congress and the patent office
23:02:01 <Gwern-away> monochrom: let's patent syntax-driven program transformations!
23:02:08 * Cale patents his invention of "an office or building to which patents are filed for judgement as to matters of priority and merit"
23:02:12 <Prometheus88> oh wait not on :r but on this input: mymap [1,2,3]
23:02:19 <monochrom> Perhaps two.  A method and system for dynamic prompt based webservers.  A method and system for expressing continuations in terms of dynamic prompts.
23:02:27 <dmwit> Prometheus88: You need to do "mymap f [1, 2, 3]".
23:02:39 <Prometheus88> ohhhhh stuppid me thank you let me get to it
23:02:41 <Gwern-away> well, night everyone
23:02:42 <dmwit> Prometheus88: (The "f" in mymap is only a local binding.)
23:02:47 <ac> what's showsPrec and showList for?
23:02:49 <monochrom> Hmm "dynamic prompt"? Let me check the terminology.
23:03:02 <ac> @src ShowS
23:03:02 <lambdabot> type ShowS = String -> String
23:03:15 <Prometheus88> right ok so say I have a function that will call my special map function
23:03:30 <Cale> ac: showsPrec is for carrying around precedence information while pretty printing so as to eliminate excess parens.
23:03:34 <Prometheus88> when i run Hugs I need to supply an additional parameter?
23:03:37 <monochrom> Dynamically scoped variables. As in the one that comes from Oleg's delimited continuation stuff.
23:03:40 <dmwit> Prometheus88: Depending on how much of Haskell you know, you may also be interested in trying "mymap (+1) [1, 2, 3]". =)
23:03:50 <Prometheus88> haha yes I got that
23:03:52 <Cale> ac: showList is just an artifact of the limitations of the Haskell98 typeclass system.
23:04:00 <Cale> Er...
23:04:05 <Cale> Well, sort of :)
23:04:12 <Prometheus88> Im new, but I need a special map function that will have alot od code
23:04:16 <monochrom> So, patent dynamically-scoped-variable-based webserver. Also patent algorithms for translating between it and continuations.
23:04:23 <Cale> It's how "hello" and [1,2,3,4,5] show up differently.
23:04:28 <dmwit> Prometheus88: Hmmm, extra parameter?
23:04:29 <ac> Cale: do I need to implement all of them for an instance of Show?
23:04:35 <Prometheus88> let me explain
23:04:38 <Cale> ac: No, you only have to implement show
23:04:49 <ac> ah interesting
23:04:51 <Cale> ac: The rest have default implementations.
23:04:54 * wli patents a business model based on stockpiling patents on trivialities and obvious things and generating revenue from patent lawsuits using that war chest of patents to snag anyone you want to.
23:05:03 <Prometheus88> Actually Ill post it in hpaste to show you what I mean, i already commented it
23:05:04 <wagle_> patent the showing of web content to people named Graham
23:05:16 <monochrom> He patented a special case and we patent the generalization to trump him, that's the idea.
23:05:27 <Cin> cale: what do you call that? it sounds like inheritence but i'm not sure
23:05:28 <jeffz> Cin: pg says it will have no visible effect on the world http://reddit.com/r/programming/info/67iza/comments/c032vsb
23:05:49 <phobes> "A patent on the practice of establishing an online persona as a blowhard to call attention to your business...
23:05:52 <olsner> hmm, hackage should include darcs links with cabal install --darcs
23:05:59 <Cin> jeffz: he changed his name from `pg' to `paulgraham'?
23:06:00 <sclv> pg also doesn't own the patent anymore: yahoo does.
23:06:02 * Cin investigates
23:06:06 <hpaste>  Prom annotated "map" with "map" at http://hpaste.org/5451#a1
23:06:18 <sclv> the artist formerly known as...
23:06:22 <Cale> Cin: It's not really. It's just that the class defines "default implementations" of the methods in terms of each other in order that those be used whenever nothing else is provided.
23:06:29 <sclv> programmers are painters after all.
23:06:36 <phobes> I actually have no problem with paul graham and have lost all interest in hearing about arc
23:06:39 <wagle_> oh noes!  and microsoft is obviously after that patent!
23:06:48 <Cale> Cin: It's sort of like single inheritance that's at most one level deep.
23:06:49 <Cin> jeffz: ah, i was confused. ignore that. he uses `pg' on his arclanguage forum.
23:07:02 <monochrom> Cale should patent "a method and system for using Cont to design, implement, and deploy with- procedures".
23:07:02 <Cale> (from an otherwise abstract base)
23:07:03 <Prometheus88> I wish I found this irc channel earlier youve saved me so much time already
23:07:08 <Cale> monochrom: heh
23:07:18 <Cin> cale: hrm
23:07:25 <wli> I was never interested in arc in the first place.
23:08:24 <Cin> cale: i know what you mean. like how /= works out its implementation from the opposite of ==, etc.
23:08:39 <dmwit> Prometheus88: The code you posted suggests that you don't yet understand how scoping works in Haskell.  Would you like a quick tour?
23:08:39 <Cale> Cin: right
23:09:04 <Prometheus88> lol ok I would we never talked about scoping
23:09:09 <monochrom> Control.Monad.CC.Cursor is neat.
23:09:32 <dolio> Is it? I was worried it's useless.
23:09:38 <dmwit> Prometheus88: Okay.  The basic idea of scoping is that the most specific binding is the one that's used.
23:10:02 <Cale> Prometheus88: map can be used to produce a function that replaces one character with another.
23:10:07 <ac> Could not deduce (Show (a Word8 (Word8, Word8, Word8))) from the context (IArray a e). Why not? There's an instance of Show for IArray
23:10:08 <Cale> (in a single string)
23:10:11 <dmwit> Prometheus88: So, when you bind a variable name in a pattern match, that binding is only available in that function.  For example,
23:10:26 <wagle_> i'd say its the places you look for the binding, and in which order you look
23:10:39 <dmwit> in (mymap f [] = ...), f will have the value of the first argument to mymap.
23:11:01 <Cin> ac: i suppose you need an instance of Show for (a Word8 ...)
23:11:03 <dmwit> It is a coincidence that you have another function called f defined at the top level; but these two functions might not be the same.
23:11:24 * dmwit stops to reread
23:11:29 <Prometheus88> Cale: yes I want to use map to look at the first element of a list and replace characters within it
23:11:34 <dmwit> very confusing
23:11:37 <wagle_> sometimes you arent allowed to shadow bindings
23:11:40 <Cale> Prometheus88: not just the first element
23:11:48 <Cin> ac: although don't tke my word for it. i'm not so experienced at reading ghc errors
23:12:02 <Prometheus88> Cale: right map affeact all elements
23:12:02 <Kirakishou> generally speaking, after a programmer closes a handle,
23:12:07 <Kirakishou> does he still have use for it?
23:12:23 <Prometheus88> dmwit: sorry I tried to put my own test funcitons in there to see what I could do with map
23:12:23 <dmwit> Kirakishou: not really
23:12:31 <phobes> > let x x = (\x -> x) in x x 1
23:12:32 <lambdabot>  1
23:12:51 <Prometheus88> Cale: so my thinking part at the bottom is correct?
23:12:59 <dmwit> Prometheus88: I guess the point I'm getting at is that, eg, in your "test" and "helper" code, "ch" and "str" aren't necessarily shared.
23:13:24 <Cale> Prometheus88: Start out by writing a function  replaceChar :: Char -> Char -> Char -> Char  which takes a character, its replacement, a character (treated as a one-element string to do the replacement in), and returns a possibly-modified character
23:13:37 <Prometheus88> dmwit: oh ok I see so how do I define a function that will be scoped correctly?
23:13:39 <dmwit> Prometheus88: Yes!  Your thinking at the bottom is quite correct.
23:13:43 <Cale> Prometheus88: Once you have that, map will do all the rest of the work.
23:14:11 <Prometheus88> Cale: um ok, I dont see how yet, but ill write that first
23:14:16 <monochrom> dolio: Cursor is fully loaded generic zipper, isn't it? That can't be useless. :)
23:14:29 <Prometheus88> dmwit: ok good
23:14:59 <Cale> Prometheus88: Well, in your argument at the bottom of the page (which is correct), replace "list of strings" with "list of characters", and "string" with "character", and you'll see how :)
23:15:08 <dolio> monochrom: I haven't done any zipper stuff yet. I need to go back and re-read ccshan's stuff about walks and stuff.
23:15:22 <Cale> (and remember that a string is just a list of characters)
23:15:22 <sclv> whoo! I got nest without continuations.
23:15:25 <sclv> ?ty \(xs::[Int->String->String]) ys -> let apply x y = Endo (x  y) in appEndo . mconcat . zipWith ($) (map apply xs) $ ys
23:15:25 <lambdabot> [Int -> String -> String] -> [Int] -> String -> String
23:16:01 <Cale> :t nest ys = let apply x y = Endo (x  y) in appEndo . mconcat . zipWith ($) (map apply xs) $ ys in nest
23:16:02 <lambdabot> parse error on input `='
23:16:12 <Cale> :t let nest ys = let apply x y = Endo (x  y) in appEndo . mconcat . zipWith ($) (map apply xs) $ ys in nest
23:16:13 <lambdabot> Not in scope: `xs'
23:16:21 <Cale> :t let { nest ys = let apply x y = Endo (x  y) in appEndo . mconcat . zipWith ($) (map apply xs) $ ys } in nest
23:16:22 <lambdabot> Not in scope: `xs'
23:16:25 <Cale> oh
23:16:35 <sclv> ?ty \xs ys -> let apply x y = Endo (x  y) in appEndo . mconcat . zipWith ($) (map apply xs) $ ys
23:16:35 <lambdabot> forall a a1. [a -> a1 -> a1] -> [a] -> a1 -> a1
23:16:39 <hpaste>  lekro pasted "gtk2hs error" at http://hpaste.org/5454
23:16:41 <Cale> :t let { nest xs ys = let apply x y = Endo (x  y) in appEndo . mconcat . zipWith ($) (map apply xs) $ ys } in nest
23:16:42 <lambdabot> forall a a1. [a -> a1 -> a1] -> [a] -> a1 -> a1
23:17:01 <dmwit> lekro: ghc --make
23:17:03 <lekro> does someone know this error or has any idea what could be the cause? it occurs when I try to "make" gtk2hs
23:17:12 <Cale> That's not the same
23:17:26 <Cale> nest :: [(r -> b) -> b] -> ([r] -> b) -> b
23:17:28 <dolio> monochrom: Right now it just does iterators and generator type stuff, which isn't any more useful in a lazy language than writing toList, I think (less useful, really, since you're forced into using a delimited continuation monad).
23:17:35 <dmwit> Oh, when you make gtk2hs?
23:17:39 <lekro> dmwit: yes
23:17:44 <Cale> not [r -> (b -> b)] -> [r] -> (b -> b)
23:18:08 <sclv> oh.. right. the parens matter. bleh.
23:18:23 <lekro> dmwit: ./configure has no problems, it finds gtk and everything I need. just the "make" step fails with that error
23:18:32 * RayNbow is writing some stuff about Haskell... is it correct to say that functions of type "IO a" evaluate to a computation that when run returns an "a"?
23:18:34 <Kirakishou> :t maybe
23:18:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:18:56 <phobes> RayNbow: That's a reasonable approximation
23:18:59 <Cale> RayNbow: values of type IO a are not functions
23:19:07 <Cale> but otherwise, yes
23:19:28 <lekro> and the only thing I could find with google was another hpaste from 3 months ago, so I was hoping that maybe someone here knows how to fix that
23:19:48 <Prometheus88> Cale: ok that was deceptively easy to write replaceChar, now do I just use map replaceChar [ [char], [char] ]?
23:20:09 <lekro> (it's ghc-6.6.1, btw)
23:20:21 <phobes> 'deceptively easy' huh?
23:20:22 <RayNbow> Cale: ah right... forgot the "some stuff here ->" part, thx :)
23:20:25 <Cale> Prometheus88: well, if you apply replaceChar to two characters (source and target), you'll get another function
23:20:52 <Cale> Prometheus88: try applying map to that function :)
23:20:55 <Prometheus88> ok
23:21:10 <dmwit> lekro: What version of GHC are you on?
23:21:10 <Cale> (and see what the type is of the thing that you end up with)
23:21:27 <Cale> Prometheus88: You know how to ask GHCi/hugs for types right?
23:22:09 <Prometheus88> yes :t
23:22:13 <Cale> right
23:22:15 <lekro> dmwit: 6.6.1, and I can't change that unfortunately (I'm not root on that machine)
23:22:27 <kmcallister> lekro, you can install ghc to your home directory
23:22:35 <lekro> it's too big
23:22:50 <Cale> Prometheus88: so, for instance, check out the type of   map (replaceChar 'x' 'o')
23:22:50 <lekro> there are quotas
23:22:51 <dmwit> lekro: That's okay, that's the version I built with.
23:23:33 <faxathisia> Is there anything like Data.Map that you can push and pop sets of bindings into?
23:23:43 <Prometheus88> it says :: [Char] -> [Char]
23:24:18 <Prometheus88> I dont see why it worked though bc the type defn of replaceChar specifes 3 Char inputs
23:24:34 <Cale> Prometheus88: but you've applied it to just 2, right?
23:24:37 <kmcallister> faxathisia, maybe use a Data.Map in a Reader monad?
23:24:38 <Prometheus88> yes
23:24:52 <Prometheus88> i just tried on 1, i see why it turns blue
23:24:56 <Cale> Prometheus88: Well, the secret is that all functions in Haskell really take only one parameter
23:25:21 <Prometheus88> now thats confusing, how does it fget the other info
23:25:23 <Cale> Prometheus88: Multiparameter functions take one parameter and give you a function which takes the rest
23:25:47 <Cale> So in the types, when you see:
23:25:51 <Cale> Char -> Char -> Char -> Char
23:25:54 <Cale> that's really:
23:25:58 <Saul_> Prometheus88: Char -> Char -> Char should be read as Char -> (Char -> Char)
23:26:01 <Cale> Char -> (Char -> (Char -> Char))
23:26:04 <Prometheus88> so how does replaceChar know what to do with the parameter it is passed
23:26:29 <Cale> Prometheus88: It just makes you another function which waits for another parameter
23:26:43 <Saul_> Prometheus88: An example:
23:26:52 <Saul_> apply f x = f x
23:26:53 <phobes> > (\x -> (\y -> x + y)) 1 2
23:26:54 <lambdabot>  3
23:27:12 <Cale> > let add x y = x + y; addOne = add 1 in addOne 5
23:27:13 <lambdabot>  6
23:27:33 <dmwit> > let add x y = x + y in add 5
23:27:33 <lambdabot>  <Integer -> Integer>
23:27:48 <Cale> When you apply a function, like:
23:27:50 <Cale> add 5 6
23:27:58 <Cale> You're actually writing:
23:28:01 <Cale> (add 5) 6
23:28:20 <dmwit> lekro: I'm not sure what's wrong.  It's building OK with 6.6.1 here.
23:28:24 <Cale> Function application associates to the left, to maintain the illusion of multiparameter functions.
23:28:28 <phobes> Currying may upset your stomach at first, but after a while you won't be able to get the smell out of your apartment
23:28:32 <Saul_> I think Cale actually has a more sensible example
23:28:46 <Prometheus88> this is function currying?
23:28:50 <Cale> yeah
23:28:57 <dmwit> lekro: Do you have libgtk2.0-dev or equivalent?  (Just to make sure... I can't imagine ./configure passing without it, but...)
23:29:02 <wagle_> @let add x y = x + y
23:29:03 <lambdabot> Defined.
23:29:08 <Prometheus88> I read this on wikibooks, Im not sure I see the application though
23:29:10 <lekro> dmwit: --disable-split-objs for the ./configure call seems to do the trick :)
23:29:10 <wagle_> > add 2 3
23:29:11 <lambdabot>  5
23:29:17 <Cale> When I say that all functions take only one parameter in Haskell, I could also say that all functions are curried.
23:29:19 <wagle_> > (add 2) 3
23:29:19 <lambdabot>  5
23:29:20 <lekro> dmwit: at least it's building now
23:29:23 <dmwit> lekro: Great!
23:29:28 <Prometheus88> am I thinking about maps fundamentally wrong?
23:29:35 <Cale> Prometheus88: Not necessarily.
23:29:36 <dmwit> no
23:29:39 <Saul_> add 2 = (\y -> 2 + y)
23:29:43 <Cale> Prometheus88: Do you know about lambda as well?
23:29:49 <Saul_> this is the partial application
23:29:51 <Prometheus88> we never got to lambda notation
23:30:02 <Cale> okay
23:30:03 <wagle_> > (add 2)
23:30:03 <lambdabot>  <Integer -> Integer>
23:30:09 <Prometheus88> literally 2 weeks into class
23:30:16 <Cale> Well, we could just make more definitions...
23:30:32 <Saul_> Prometheus88: Lambda notation is pretty simple (\x -> something using x)
23:30:36 <phobes> > (\x -> x*2) 4
23:30:36 <lambdabot>  8
23:31:00 <Saul_> so f = (\x -> 2 + x) is the same thing as f x = 2 + x
23:31:01 <Prometheus88> ok i see lambdabot saying the answer, im using hugs too
23:31:15 <Prometheus88> is lambda only used from the interpreter?
23:31:24 <Cale> nope
23:31:25 <phobes> no
23:31:26 <Saul_> You can do this with more parameters as well
23:31:30 <Prometheus88> ok
23:31:33 <Cale> It can also be used in your source files.
23:31:34 <Saul_> not you can use it anywhere
23:31:39 <lekro> dmwit: but that's strange. I didn't know of the option split-objs but according to the docs it should "just work". maybe my ghc distribution isn't quite right
23:31:43 <Cale> It creates functions without giving them names.
23:31:47 <phobes> ok I'm gonig to bed - gnite all
23:32:04 <Cale> > (\x y -> x^2 + y^2) 3 4
23:32:08 <lambdabot>  25
23:32:17 <Prometheus88> ok I get that ex
23:32:18 <dmwit> lekro: I wouldn't be surprised.  You're lucky that a machine you're not in control of even has GHC at all.
23:32:20 <Saul_> so add = (\x y -> x + y), which makes add 2 = (\y -> 2 + y) and add 2 3 = 2 + 3
23:32:52 <phobes> > (\x -> (\y -> x^2 + y^2)) 3 4 -- explicitly curried version of what Cale just wrote
23:32:53 <lambdabot>  25
23:33:21 <Cale> (\x y -> ...) and (\x -> (\y -> ...)) mean the same thing
23:33:35 <wagle_> @let add2 = (add 2)
23:33:36 <Cale> (It's just syntax sugar to save typing)
23:33:36 <lambdabot> Defined.
23:33:41 <wagle_> > add2 1
23:33:42 <lambdabot>  3
23:33:46 <Prometheus88> so (\x y -> x + y) 2 3
23:33:47 <wagle_> > add2 4
23:33:47 <lambdabot>  6
23:34:15 <Cale> (\x y -> x + y) 2 3  --->  (\y -> 2 + y) 3  --->  2 + 3  ---> 5
23:34:17 <Saul_> Prometheus88: yes that is the same thing as add 2 3
23:34:24 <Prometheus88> ok got it
23:34:45 <Saul_> > (\x y -> x + y) 2 3 -- It really works :)
23:34:45 <lambdabot>  5
23:34:57 <wagle_> i named the intermediate function that (add 2) returned "add2"
23:35:04 <Prometheus88> now how should I apply this concept to replaceChar
23:35:23 <Cale> Prometheus88: Okay, so think of replaceChar, not as a function of three parameters, but of just two
23:35:35 <Cale> It's going to take 1) a character to replace
23:35:41 <Cale> and 2) a character to replace it with
23:35:55 <Cale> and it returns a function from characters to other characters
23:36:04 <Cale> which makes that replacement when appropriate
23:36:14 <luqui> Is it possible to have Haskell interop with C#?
23:36:27 <Saul_> luqui: Yes
23:36:37 <roconnor> @seen dons
23:36:37 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 36m 49s ago.
23:36:39 <luqui> Saul_: any ponters as to how o get started?
23:36:45 <Saul_> luqui: There is a foreign function interface for that
23:36:50 <Cale> GHC can't produce .net code yet though.
23:36:57 <Cale> So I don't know about that.
23:37:29 <Cale> Can C# interface with C easily?
23:37:45 <luqui> Cale: it has an ffi, so it can import C functions...
23:37:46 <dmwit> C has the best-supported FFI.
23:37:57 <Prometheus88> Cale: ok but then why dont I just define it as using 2 param? or do you mean that I think of it as using 2 and call replacrChar on itself?
23:37:59 <luqui> can I export C functions from haskell?
23:38:01 <dmwit> luqui: Can it export C functions?
23:38:05 <dmwit> luqui: Yes.
23:38:12 <luqui> I don't think C# can no...
23:38:13 <Cale> Prometheus88: It really has 3 parameters
23:38:29 <Cale> Prometheus88: But you're going to think of it as taking 2 and giving you another function
23:38:34 <Cale> (which takes the last one)
23:38:52 <luqui> ah there it is, "foreign export"
23:38:53 <faxathisia> why can you not do, import qualified Data.Map as Map (\\) ?
23:38:54 <Saul_> Prometheus88: You can define it using 2 parameters and returning a lambda expression explicitly, but that is really the same thing as it having 3 parameters
23:39:08 <faxathisia> is there a different way you can import an operator
23:39:10 <dons> roconnor's defected to the clean side :)
23:39:18 <Prometheus88> ah I think I will avoid lamda since we wont be covering it till the end supposedly
23:39:22 <Cale> Like,  (replaceChar 'x' 'o') is the function which takes a character, and if it's anything but 'x', just gives that back, but if it is 'x', then it gives 'o'
23:39:24 <roconnor> dons: :)
23:39:30 <dmwit> faxathisia: Use two lines.
23:39:38 <Cale> For example:
23:39:42 <roconnor> dons: I've never used itasks, I just saw a talk on it at FP dag
23:39:43 <Cale> (replaceChar 'x' 'o') 'a'
23:39:47 <Cale>  --> 'a'
23:39:50 <Cale> (replaceChar 'x' 'o') 'x'
23:39:51 <roconnor> dons: but it has monads!
23:39:53 <Cale>  --> 'o'
23:39:54 <dmwit> faxathisia: import qualified Data.Map as Map; import Data.Map (\\)
23:39:58 <roconnor> dons: so we can talk about it here ;)
23:40:00 <Prometheus88> ok let me play with tis 2[arm method in hugs for a bit
23:40:04 <Saul_> roconnor: Me too
23:40:06 <faxathisia> aah I see thank you
23:40:15 <luqui> Hey, so does F#.  Half-assed monads for everyone!
23:40:20 <Cale> Prometheus88: You'll have to apply it to the final parameter to get a result of course.
23:40:28 <faxathisia> import Data.Map ((\\))
23:40:30 <roconnor> Saul_: http://reddit.com/r/programming/info/67ktn/comments/
23:40:40 <lambdabot> Title: Com.org - Only the best links ...
23:41:01 <Cale> Prometheus88: But in between, you have something which is an honest-to-goodness function which can be used anywhere you could use a Char -> Char function.
23:41:02 <Cin> wow, pg is really getting hated on on reddit. i don't know why i read this nonsense anyway
23:41:44 <dmwit> I should go to bed.
23:41:54 <roconnor> Cin: I hope you aren't interpreting my post as an attack on pg.
23:42:29 <Cale> Prometheus88: Of course, map would be happy to take such a function and turn it into a function which acts on lists of Chars.
23:42:55 <Cale> Prometheus88: (which happens to be exactly what you're looking for)
23:42:59 <Prometheus88> Cale: ok, im thinking about this all, still here
23:43:07 <sclv> oh ffs are we going to start calling everything with continuations arc-style now just like everything with multithreaded message passing is now apparently erlang-style?
23:43:13 <Cin> roconnor: i don't know if i've seen yours or not. it doesn't really matter anyway. reddit is just as bad as slashdot. sometimes i just forget.
23:43:24 <Cale> sclv: I really hope not.
23:43:38 <Prometheus88> Cale: i wrote replaceChar a bitt diff but i get the gist of your examples
23:43:52 <Cale> sclv: Though it would be appropriate, with PG's patent on the continuation based webserver.
23:43:53 <glguy> LOL "arc-style"
23:44:06 <roconnor> dons: fortuately itasks isn't exactly continuation based.
23:44:18 <Cin> roconnor: ahh, sorry, i didn't see your paste. i had just spontaneously came back to irc from my web browser.
23:44:24 <Prometheus88> cale: I think I get it now let me try integrating it
23:44:35 <Cale> Prometheus88: cool :)
23:44:44 <roconnor> itasks is mostly pure, so the state is just recreated on each page load.
23:45:16 * sclv wants to blog about "implementing turing-style stack operations in java"
23:45:24 <roconnor> side effect only occur when the task is complete, and then everything is thrown away.
23:45:46 <Kirakishou> I think I'll make a hackage package.
23:46:02 <Kirakishou> you tar all the source files together, right?
23:46:06 <Prometheus88> cale: since replacechar works on a list of chars, and my input is a list of list of chars, do i need to call it twice?
23:46:17 <Kirakishou> wait, nvm
23:46:31 <Cale> Kirakishou: There's a command which builds the appropriate tarball.
23:46:52 <Cale> Prometheus88: Need to call what twice? :)
23:47:00 <lekro> dmwit: btw, everything's working now. --disable-split-objs *did* the trick. :)
23:47:09 <Prometheus88> cale: since replacechar works on a list of chars, and my input is a list of list of chars, do i need to call map twice?
23:47:14 <Cale> yes :)
23:47:27 <Cale> replaceChar works on just one Char, doesn't it?
23:47:34 <sclv> "implementing algol-style structured programming in D"
23:47:36 <Prometheus88> yes
23:47:47 <Cale> Yeah, then you need to call map twice
23:48:00 <Prometheus88> I got a type error still though
23:48:08 <Cale> Once to get a function that works on lists of chars, and then again for lists of lists of chars
23:48:18 <Cale> Well, let's see...
23:48:20 <Prometheus88> oh wait i think i know why
23:48:24 <Cale> okay
23:48:24 <Prometheus88> let me try first
23:49:38 <Prometheus88> Cale: can I write map (map replaceChar pic)?
23:49:58 <Cale> map (map (replaceChar x y)) pic
23:50:13 <Prometheus88> ohh I didnt pass it the chars
23:50:30 <dmwit> And you applied it to pic too early.
23:51:07 <Prometheus88> no kidding, so the first map means " do replaceChar on x y" but no list?
23:51:48 <Cale> If  replaceChar x y  makes the replacement in a single character, then  map (replaceChar x y)  makes the replacement in a list of characters
23:52:05 <Cale> and  map (map (replaceChar x y)) makes the replacement in a list of lists of characters
23:52:08 <Prometheus88> in this function replaceChar x y means x being the char I want to change, and y being the char i want to change it to and the third param would be the char from picture after applyuing map twice
23:52:22 <Cale> map :: (a -> b) -> ([a] -> [b])
23:52:38 <Cale> (note the parens)
23:52:48 <Cale> Of course, that's the same thing as:
23:52:54 <Cale> map :: (a -> b) -> [a] -> [b]
23:53:11 <Cale> But the parens give you the way in which to think of it here.
23:53:34 <Cale> It's taking a function  a -> b,  and producing a function  [a] -> [b]
23:53:35 <kmcallister> Prometheus88, the inner map has type (Char -> Char) -> [Char] -> [Char], so applying a value of type Char -> Char (in this case replaceChar x y) gives a value of type [Char] -> [Char], which then serves as the argument to the outer map, which has type ([Char] -> [Char]) -> [[Char]] -> [[Char]]
23:54:07 <kmcallister> thus giving you [[Char]] -> [[Char]], which is what you want
23:54:31 <Cale> This is possibly mind-boggling at first, but you'll get used to it.
23:54:42 <kmcallister> the type of map given above uses a and b as type variables; in the inner case a = b = Char, and in the outer case a = b = [Char]
23:54:48 <Prometheus88> yes it is, so I should be thinking of this as tuples?
23:54:52 <Cale> The point is that functions are values just like any others.
23:55:03 <Cale> map is a function which turns functions into other functions
23:55:05 <kmcallister> Prometheus88, there aren't any tuples here
23:55:17 <kmcallister> a -> b -> c is very different from (a, b) -> c
23:55:26 <Prometheus88> ohk I thought () was for tuples but i realize now this is for type defns
23:55:40 <Cin> if i have foo = bar * mu
23:55:42 <kmcallister> Prometheus88, parens are used for several things
23:55:44 <Cale> ( , ) is for tuples
23:55:51 <Cin> is bar * mu evaluated for every use of foo?
23:55:55 <kmcallister> (a, b) is a pair when used as a value, or the type of a pair when used as a type
23:56:20 <kmcallister> but (a -> b) is a function type, () by itself is another type entirely, and parens can also be used anywhere to group expressions
23:56:25 <Cale> Cin: If foo is not typeclass-polymorphic, and really isn't a function, then it'll only be evaluated once and stored.
23:56:37 <Cale> Cin: (as long as it remains in scope)
23:56:39 <Cin> cale: ah, cool. i'd thought so
23:56:45 <Cin> cale: oh, scope. hrm
23:57:31 <Cale> Cin: So if you do something like:
23:57:51 <Cale> f x = blah x + reallyComplicatedConstant
23:57:59 <Cin> cale: i would expect it to be memoized considering its value will never change and you only have to memoize one value? obviously i can see why automatic memoziation for a function with an argument can take up memory, but one without an argument is nothing?
23:58:10 <Cale>   where reallyComplicatedConstant = something that takes a long time to compute
23:58:20 <Cale> Then it'll be evaluated once per call to f
23:58:32 <Cale> and the memory reclaimed(!)
23:58:51 <Prometheus88> everyone youve been of great help, very soon I will have to ask you all for help again likely since I cant implement a floodfill algorithm yet in haskell
23:59:01 <Cale> But if you lift the definition to the top level, then it'll get saved between calls to f
23:59:22 <Cale> Prometheus88: no problem :)
23:59:27 <Prometheus88> Ill ve thinking of types very much to make sure I understand all these notes, and im going to copy the irc chat to look at later again
23:59:52 <Cale> Prometheus88: I hope you'll stick around and ask lots of questions :)
