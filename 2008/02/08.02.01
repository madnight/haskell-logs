00:03:36 <DanHerg> Cool Dating Club site ===> new-datingclub eu
00:04:47 <ricky_clarkson> Meet Static Typers Near You.. No Dependents
00:04:57 <nelhage> @src [] (>>=)
00:04:57 <lambdabot> m >>= k     = foldr ((++) . k) [] m
00:05:35 <nelhage> @src mapConcat
00:05:35 <lambdabot> Source not found. Sorry.
00:05:57 <LeCamarade> Hi, channel. Missed you lot. Glad to be back. :o)
00:08:33 <Vq^> same here, lost the power for a couple of hours
00:09:17 <LeCamarade> Vq^: I was on a self-imposed exile from the Net for three months.
00:09:27 <LeCamarade> :o)
00:09:51 <Vq^> what kind of masochism is that?!?
00:10:40 <Vq^> i hope you were drunk most of those three months :P
00:12:38 <LeCamarade> I realised I wasn't going to get anywhere in my compiler if I hung out at Reddit flaming things. Now I'm back, and here comes Arc. ;o)
00:14:10 <LeCamarade> @tell sigfpe I wanna ask you some stuff about uniquenss types, if you no mind.
00:14:10 <lambdabot> Consider it noted.
00:18:02 <dolio> @tell dpiponi LeCamarade left you a message under the nick sigfpe.
00:18:02 <lambdabot> Consider it noted.
00:20:47 <olsner> @seen dpiponi
00:20:47 <lambdabot> I saw dpiponi leaving #haskell 13h 23m 44s ago, and .
00:22:06 <olsner> so that's where sigfpe went
00:26:43 <kmcallister> "constructor class" means "typeclass where some parameters have kind not equal to *", correct?
00:26:53 <Cale> right
00:27:49 <Cale> Typeclasses were first introduced without them.
00:29:44 <olsner> I like how haskell, with all its type madness, began with, and still has, a less powerful type system than C++
00:30:13 <Cale> Are you sure?
00:30:21 <Cale> In GHC, the typesystem is Turing complete.
00:30:22 <nelhage> With the right extensions, you can do arbitrary computation in the type system.
00:30:27 <Cale> (With appropriate extensions)
00:31:12 <mauke> hmm... has anyone done a formal proof that C++ is unparseable?
00:31:21 <kaol> I'll call C++'s type system powerful once I see it do type inference
00:31:40 <b_jonas> mauke: sure, they've written sqrt and stuff like that in c++ templates
00:31:56 <kmcallister> kaol, you can write a Haskell compiler using C++ templates
00:31:58 <b_jonas> (without even using c preprocessor madness)
00:32:20 <kmcallister> although anyone who actually does such a thing should probably be locked up :)
00:33:24 <qebab> C++ templates are turing complete as well yeah
00:37:55 <dmwit> The difference for me is that Haskell's type system is what I call "clean" -- based on sound theory -- whereas C++'s template system is just an organic growth if things that seemed like nice features at the time.
00:38:16 <kmcallister> yeah, the haskell doctrine of "you can't have that feature unless it's really pretty" is nice
00:38:31 <kmcallister> along with features that allow the implementation of other features on a local basis
00:43:42 <piojo> hello. i have a GC/memory question. is "length $ concat listOfLists" the same as "sum $ map length listOfLists", or will haskell's type of garbage collection/laziness make the first one worse? (assuming the list is huge, and dynamically generated)
00:44:20 <kmcallister> piojo, list concatencation is slow
00:44:48 <piojo> i guess that's true, too. but memory is really the problem here
00:45:06 <kmcallister> yeah, it is a seperate issue, but a major one if the lists are big
00:45:48 <piojo> so the compiler doesn't do any magical optimization that counts lists as they are concatenated, then throws them away?
00:46:16 <piojo> (i don't really know the degree to which laziness effects things)
00:46:17 <goalieca> shouldn't <linked> lists be super fast to concatenate
00:46:32 <qebab> goalieca: from the start, yes
00:46:32 <mauke> goalieca: no
00:46:40 <qebab> goalieca: as in, consing onto them
00:46:59 <meryrus> Don't you have to iterate through the length of the first list to reach the end before concatenating it onto the second?
00:47:03 <goalieca> list.end -> list2.start
00:47:05 <goalieca> ??
00:47:05 <qebab> to concatenate however, you need to find the end first
00:47:22 <meryrus> Or do people usually store the end of a linked list?
00:47:26 <goalieca> i do
00:47:29 <qebab> goalieca: haskell lists are singly linked, so they don't know their end
00:47:40 <qebab> goalieca: what's the end of [1..]? :)
00:47:45 <mauke> goalieca: you can't just modify the end pointer
00:47:49 <mauke> lists are immutable
00:48:02 <goalieca> well qebab the lists are constructed at some point
00:48:11 <goalieca> and mauke compiler analysis?
00:48:18 <goalieca> in place
00:48:22 <goalieca> ?
00:48:29 <mauke> unlikely
00:48:33 <mauke> concat is lazy
00:48:45 <dmwit> I'm surprised that this wouldn't get folded/fused away in the calculation of length.
00:48:57 <meryrus> cats are often lazy.
00:49:05 <dmwit> But then, I don't really understand what is going on with fusing in the first place, anyway.
00:49:38 <piojo> will GC happen during a single function (like a fold), and can the earlier part of the list get GC'd?
00:49:48 <mauke> yes
00:49:51 <goalieca> haskell behind the scenes is all "magical". i understand every line of c i write but have no idea what haskell does
00:50:08 <piojo> =), that makes it fun
00:50:27 <nelhage> "During a single function" is a hazy concept when that function is lazy
00:50:39 <piojo> i guess so
00:50:56 <meryrus> goalieca, I doubt anyone really understands every line of c they write.
00:51:17 <dmwit> I don't.
00:51:21 <goalieca> meryrus, portable assembly ;)
00:51:23 <dmwit> C is very, very close to assembly.
00:51:44 <mauke> only if your compiler is stupid
00:51:44 <nelhage> Well, it is the case that every line of C I write I could translate into (x86) assembly without a ton of thought.
00:51:45 <dmwit> All the power of assembly with all the portability of assembly. =)
00:52:03 * Cale sends the authors of http://www.think-logically.co.uk/lt.htm a picky email letting them know that the answer to question 10 is actually "Invalid", because the assumption that "is in" is a transitive relation is not a stated assumption.
00:52:03 <lambdabot> Title: arm-chair logic - logic test
00:52:07 <goalieca> and with a little profiling like cputrack i can even figure out cache behaviour
00:52:26 <goalieca> haskell is a magical box
00:52:43 <goalieca> it'll probably stay that way for me
00:52:52 <meryrus> With an attitude like that, etc.
00:52:58 <mauke> does it make sense to say that I think in "free C"?
00:53:14 <meryrus> I don't concede yet that being able to translate C into assembly means the same thing as understanding it.
00:53:31 <meryrus> But, it doesn't matter much.
00:53:59 <goalieca> i can pretty much tell you how the machine is going to run a piece of code. no real surprises.
00:54:11 <meryrus> You can solve the halting problem!
00:54:13 <meryrus> Amazing.
00:54:27 <mauke> goalieca: that's a property of your compiler/machine, not C
00:54:57 <goalieca> meryrus, way to ruin the discussion by stating something so academically useless
00:55:04 <goalieca> :P
00:55:21 <goalieca> mauke, but can ghc be understood as well?
00:55:24 <meryrus> goalieca, don't speak in overgeneralizations, then :)
00:55:28 <goalieca> or does it add too many abstractions
00:55:44 <mauke> I don't care
00:55:52 <piojo> goalieca: presumably, its authors understand it...
00:56:05 <nominolo> goalieca: just profile
00:56:15 <goalieca> lol. blackbox testing FTW
00:56:39 <Korollary> Tampa Bay FTW
00:56:50 <goalieca> Korollary, montreal c'est mon equipe!
00:57:01 <goalieca> les astis de canucks
00:57:02 <Korollary> Washington 5 - 4 Montreal
00:57:12 <goalieca> bah. montreal est super
00:57:15 <dmwit> meryrus: Your conclusion does not follow.
00:57:31 <meryrus> dmwit, which?
00:57:32 <dmwit> meryrus: His explanation might take forever on some program/input pairs. ;-)
00:57:33 <nominolo> goalieca: go write in C
00:57:39 <meryrus> dmwit, Oh, heh.
00:57:48 <meryrus> Yes, I do assume that explanations be finite :P
00:58:09 <nominolo> goalieca: or go learn read the stream fusion paper
00:58:14 * goalieca notes that haskell people are too much theoretical.. who cares about category theory!
00:58:30 <dmwit> meryrus: No problem, just assume the computer has finite memory...
00:58:43 <goalieca> dmwit :D
00:58:49 <dmwit> heh
00:58:52 <goalieca> no such thing as a turing machine
00:58:55 <nominolo> goalieca: yes, it is harder to predict some performance characteristics, but then again, if you were as abstract in C, you couldn't eithre
00:59:15 <goalieca> i do code in haskell.. i just have no idea what goes on
00:59:18 <goalieca> that's all i was saying
00:59:22 <goalieca> one too many abstractions
01:00:10 <Korollary> is it the abstractions or lazy eval?
01:00:13 <Cale> If anyone claims they can compile C++ by hand, write for them a program for which compilation only terminates if the Goldbach conjecture is false, and see if they can compile it.
01:00:26 <nominolo> haskell just compiles down to a different virtual machine
01:00:28 <meryrus> Cale: C
01:00:38 <Cale> Yes I know :)
01:00:48 <goalieca> Cale, you guys are too nerdy :P
01:01:07 <goalieca> i had to look that up
01:01:26 <Korollary> Sadly I knew what it was.
01:01:35 <Korollary> I try to hide it by talking about hockey
01:01:39 <goalieca> i'd heard of it.. but i'm an engineer (Read pragmatist)
01:01:40 * Vq^ didn't
01:01:48 <Vq^> i'm not nerdy enough :'(
01:02:00 * nominolo thinks he knows what it is, but didn't check. yet
01:02:07 <meryrus> It makes the case more difficult to argue. Everyone knows C++ is a bag of wet animals.
01:02:15 <dmwit> Basically all well-known conjectures have to do with primes.  Discuss.
01:02:16 <mauke> something with adding primes
01:02:17 <goalieca> c++ confuses the hell out of me sometimes
01:02:30 <goalieca> no one.. not even BS understands it all
01:02:33 <goalieca> but that doesn't matter
01:02:38 <goalieca> people make excellent use of it
01:02:39 <Vq^> yeah, C++ is one weird squid
01:02:48 <nominolo> mauke: ok, then it's what i thought
01:02:48 <flux> cale, it would be interesting to even see such piece of code..
01:02:49 <Cale> dmwit: We still don't really understand how addition and multiplication interact, and we may never truly understand it.
01:02:56 <b_jonas> Cale: they're just give an error message about limits if you do that
01:02:56 <flux> cale, would make a book, no?
01:03:27 <b_jonas> dmwit: that's false I think
01:03:39 <Cale> flux: You just write a program which tries each even number, and tries to write it as the sum of two primes. Make the compilation stop when a counterexample is found.
01:03:51 <mauke> "write once, run away"
01:03:58 <flux> cale, the first part is simple, how about the testing part :)
01:03:58 <dmwit> b_jonas: For example?
01:04:07 <goalieca> Cale, sounds like a very useful program
01:04:15 <b_jonas> dmwit: P/=NP doesn't seem to be closely related
01:04:19 * Vq^ prefers the simple languages, C which is simple/naïve and Haskell which is simple/logic
01:04:24 <b_jonas> thoug that's not a really good example
01:04:35 <dmwit> b_jonas: Aha!  I think that's a very good example.
01:04:38 <b_jonas> the Poincarre conjecture isn't either because it's been proved
01:04:55 <b_jonas> let's look at the other millenia prize problems though
01:05:10 <meryrus> Navier Stokes has something to do with primes?
01:05:13 <nominolo> i'll bet P /= NP.  i offer a beer
01:05:22 <b_jonas> yeah, Navier-Stokes is a good example
01:05:25 <meryrus> If P = NP I'll eat my hat.
01:05:27 <Cale> meryrus: Probably ;)
01:05:45 <meryrus> Cale, *shakes fist at number theory*
01:05:45 <Korollary> If P = NP we all eat hats
01:05:45 <b_jonas> meryrus: you mean, if it's proven that P = NP you'll eat my hat?
01:05:55 <goalieca> Possible = Nearly Probable
01:05:58 <dmwit> If P = NP we all celebrate.
01:06:08 <goalieca> P=NP does what for me?
01:06:12 <goalieca> i've never gotten a real answer
01:06:12 <meryrus> Actually, I don't have a hat.
01:06:17 <Korollary> lowers house prices
01:06:23 <b_jonas> the problem with Navier-Stokes is that it's not really a conjucture but rather a theory to be invented
01:06:24 <nominolo> dmwit: no the prove will be:  "P = NP, but ..."
01:06:31 <meryrus> b_jonas, good call.
01:06:32 <dmwit> heh
01:06:33 <b_jonas> hmm, maybe dmwit's statemet makse sense
01:06:53 <piojo> if P=NP, probably, a lot of the "really hard, slow" problems will be convertible into faster, easier problems?
01:06:56 * meryrus feels like he needs a problem to solve.
01:06:56 <b_jonas> goalieca: http://www.claymath.org/millennium/P_vs_NP/
01:06:57 <lambdabot> Title: Clay Mathematics Institute
01:07:09 <dmwit> meryrus: Project Euler?
01:07:16 <Cale> piojo: right.
01:07:23 <meryrus> dmwit, I'm around #8 or so. Got burnt out.
01:07:25 <dmwit> meryrus: It has a pretty steep ramp if you limit yourself to 1-minute solutions.
01:07:28 <Cale> P = NP would be huge.
01:07:31 <nominolo> if I prove P /= NP, i'll be rich! *muahaha*
01:07:38 <b_jonas> meryrus: did you just have it stolen?
01:07:43 <piojo> dmwit: i'm doing project euler now!
01:07:50 <Cale> If you prove P = NP and exploit it without telling anyone, you'll be richer.
01:08:11 <meryrus> b_jonas, I left it in the maths lab, I think.
01:08:17 <dmwit> nominolo: Forget rich, you'll be immortal.
01:08:18 <nominolo> Cale: right, let's do that
01:08:40 <nominolo> dmwit: only if i can copy my brian into some memory
01:08:50 <goalieca> b_jonas, but knowing P = NP or not doesn't find me the actual algorithm :P
01:09:04 <b_jonas> goalieca: yes, I knoe.
01:09:05 <dmwit> Nah, I mean immortal in the sense that Gauss and Euler and Einstein are immortal.
01:09:24 <b_jonas> I'm writing my thesis about a polynomial time algorithm which I think is unusable in practice
01:09:32 <nominolo> dmwit: hm, those were all germans ...
01:09:42 <b_jonas> though whether it's really unusable I'll examine further and answer in the thesis
01:09:54 <Cale> goalieca: A nonconstructive proof of P = NP would be *awesome*.
01:10:07 <goalieca> Cale, you mean an example
01:10:14 <b_jonas> dmwit: yep http://qntm.org/?surest
01:10:15 <goalieca> well some homomorphism might be possible
01:10:15 <lambdabot> Title: Mathematics is the surest way to immortality @ Things Of Interest
01:10:16 <doserj> dmwit: euler was swiss
01:10:16 <b_jonas> nominolo: no
01:10:27 <b_jonas> yep, Euler
01:10:34 <nominolo> b_jonas: close enough
01:10:37 <b_jonas> I'm slow
01:10:38 <nominolo> ;P
01:10:56 <Cale> goalieca: No, an actual proof that problems in NP must be polynomially reducible to problems in P, without actually giving the polynomial reduction.
01:11:11 <b_jonas> dmwit: but it also makes you rich, there's a million dollar price on P /= NP
01:11:22 <nominolo> but there are other ways to become immortal.  become an evil dictator for example
01:11:38 <dmwit> b_jonas: ah
01:11:41 <Cale> For example, if your polynomial reduction somehow manages to involve the axiom of choice.
01:11:44 <b_jonas> Cale: yeah, and it's not so unlikely either
01:12:10 <dmwit> The axiom of choice...
01:12:20 <dmwit> ...we are dealing with infinite sets somewhere?
01:12:22 <b_jonas> Avi Wigderson did a very nice (and popular) presentation at the "other" university this spring
01:12:38 <Cale> dmwit: Well, it would have to be a pretty strange proof to do that :)
01:12:40 <b_jonas> where he's explained about his new results which was a nonconstructive proof for something like this
01:12:46 <goalieca> The axiom of choice = ugggg
01:12:54 <Cale> AC rules!
01:12:57 <dmwit> Cale: So *that's* why it would be so awesome. =)
01:13:13 <Cale> dmwit: But, for example, the current proof of Fermat's Last Theorem supposedly relies on AC.
01:13:15 <nominolo> it'd be much cooler if you'd write a paper that prooves something, then someone else realizes that this is a prove of P = PN, and then you respond "oh, right.  did i forget to mention that?"
01:13:19 <b_jonas> namely, they've proved that if P /= NP then RP = P or something like that
01:13:27 <b_jonas> which means that every algorithm can be derandomized
01:13:43 <Cale> (I'm not 100% sure about that, but I've heard it from someone)
01:13:52 <b_jonas> but it doesn't make it easy to actually find the derandomized algorithm
01:14:02 <mauke> hmm, I must be doing something wrong
01:14:03 <mauke> http://rafb.net/p/8jSF2M74.html
01:14:04 <lambdabot> Title: Nopaste - No description
01:14:27 <dmwit> heh
01:15:08 <piojo> could it be that you used a class/struct that has been forward declared but not yet defined? (in the wrong way)
01:15:11 <goalieca> i won't even pretend to understand that crazy symmetry crap in fermats last theorem
01:15:16 <b_jonas> he's also told lots of other intrigueing results in algorithm theory
01:15:41 <mauke> I think the error message is more useful than the program itself
01:16:21 * nominolo goes do sth useful
01:16:23 <b_jonas> oh, sorry I interrupted the real haskell support with the abstract crap :)
01:16:39 <b_jonas> mauke: lol, that's nice
01:17:23 <b_jonas> I just helped someone in programming the collatz problem on irc a week ago, but it was in a sane way
01:17:33 <b_jonas> that reminds me to my C++ puzzle
01:17:49 <mauke> template<int N> struct Collatz { enum {value = N == 1 ? 42 : Collatz< N % 2 ? N * 3 + 1 : N / 2 >::value}; };
01:17:59 <meryrus> Wow, I'm an idiot.
01:18:10 <meryrus> In writing a prime sieve, I ended up writing a power of two sieve.
01:18:24 <meryrus> Can I blame beer?
01:18:32 <dmwit> It's so easy, just a (==) vs. (/=).
01:18:46 <dmwit> Don't worry about it, we all make that kind of mistake a few times. =)
01:19:14 <b_jonas> this oen: http://rafb.net/p/K8B5qg73.html
01:19:14 <lambdabot> Title: Nopaste - c++ puzzle
01:19:23 <meryrus> much better. :)
01:20:02 <Cale> > nubBy (\x y -> y `mod` x /= 0) [2..]
01:20:09 <lambdabot> Terminated
01:20:12 <Cale> heh
01:20:16 <Cale> > take 10 $ nubBy (\x y -> y `mod` x /= 0) [2..]
01:20:17 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024]
01:21:18 <mauke> oh, g is a member function
01:21:22 <mauke> that explains the ::
01:21:22 <goalieca> b_jonas, weak.
01:21:24 <meryrus> I lied, apparently I'm on #7, btw.
01:21:59 <goalieca> b_jonas, c++ does some nasty things. luckily no one but boost uses them
01:22:17 <goalieca> boost::lambda *shudders*
01:22:28 <mauke> boost::spirit
01:22:48 <dolio> b_jonas: ::d is d in the default namespace, no (not that I could tell you why it's necessary)?
01:23:16 <mauke> probably because plain d resolves to d<T>
01:24:24 <b_jonas> dolio: yes, that's what it means
01:24:29 <dolio> And the space is so it parses correctly, I assume, although I don't know how else it would parse.
01:24:29 <b_jonas> and mauke is right
01:24:39 <mauke> <: is [
01:25:07 <b_jonas> yep
01:25:08 <Cale> Wow, apparently there's no polynomial time algorithm to determine if a given arithmetic expression over the integers is the zero polynomial.
01:25:10 <dolio> Wow.
01:25:18 <Cale> (no known algorithm)
01:25:34 <b_jonas> Cale: yes, but there's a very good randomized algorithm
01:25:46 <b_jonas> so it doesn't really matter
01:26:00 <goalieca> wow. umm.. interesting...
01:26:09 <meryrus> Unless it happens to be the case that such an algorithm implies P = NP.
01:26:13 <dmwit> :t map (head &&& length) . group
01:26:13 <lambdabot> forall a. (Eq a) => [a] -> [(a, Int)]
01:26:20 <meryrus> In which case it does matter (but I'm being silly and drunk, so ignore)
01:26:24 <dmwit> > group []
01:26:25 <lambdabot>  []
01:29:13 <b_jonas> > take 10 $ nubBy (\x y -> y `mod` x = 0) [2..]
01:29:13 <lambdabot>  Parse error at "=" (column 36)
01:29:15 <mauke> b_jonas: http://rafb.net/p/tTmldA40.html
01:29:16 <lambdabot> Title: Nopaste - No description
01:29:16 <b_jonas> > take 10 $ nubBy (\x y -> y `mod` x == 0) [2..]
01:29:17 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
01:29:26 <b_jonas> nice
01:29:44 <meryrus> It's slow :(
01:29:49 <mauke> 1) what does this program do?  2) why not?
01:29:59 <Cale> > nubBy (((==1).).gcd) [2..]
01:29:59 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
01:30:12 <Cale> > nubBy (((/=1).).gcd) [2..]
01:30:13 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
01:30:33 <b_jonas> Cale: there are much worse errors for prime searchers though
01:30:43 <b_jonas> like that one that gives all primes and 4
01:30:53 <Cale> How do you write that one?
01:30:54 <rekso> That ((double).).dot trick does my head in
01:31:00 <b_jonas> Cale: moment, I'll search for it
01:31:14 <dmwit> rekso: Just work through it a couple of times, it'll click.
01:31:48 <rekso> dmwit: I've worked through it  a few times before, and although I can explain it I don't feel that I understand it.
01:32:36 <Cale> ((f.).g) x y -> (f.) (g x) y -> (f . (g x)) y -> f ((g x) y) -> f (g x y)
01:32:38 <b_jonas> Cale: http://www.perlmonks.com/?node_id=510912
01:32:39 <dmwit> It (sort of) passes through two arguments, rather than the one argument that (.) passes through.
01:32:42 <lambdabot> Title: Re: Simple primality testing
01:33:52 <b_jonas> Cale: hmm, apparently that has a different
01:33:55 <b_jonas> problem
01:33:58 <Cale> yeah
01:34:01 <Cale> it misses 2?
01:34:08 <b_jonas> yeah
01:34:34 <mauke> why does it need +1?
01:34:50 <b_jonas> mauke: because .. truncates, not rounds
01:34:58 <mauke> yeah, so?
01:35:11 <b_jonas> so if you just iterate up to sqrt, you'll have rounding errors for large numbers
01:35:30 <mauke> you'll have rounding errors anyway
01:35:40 <b_jonas> mauke: but in the wrong direction
01:35:49 <b_jonas> it will think some large squares are primes
01:35:52 <greigar> leave
01:36:12 <mauke> it will also think some large primes are composite
01:36:21 <b_jonas> no
01:36:26 <mauke> simply because you lose precision
01:36:48 <b_jonas> no, if you just test a few more divisors it's no problem
01:37:09 <b_jonas> you can make the modulus precisely for much higher numbers
01:37:52 <b_jonas> it's not really a problem if you give a larger answer to the sqrt so yuo test more potential divisors
01:39:01 <mauke> what's the maximum value of an Int?
01:39:39 <nelhage> > maxBound :: Int -- But it's machine dependent
01:39:39 <b_jonas> that doesn't matter, the modulus will be precise for a while for doubles
01:39:39 <lambdabot>  2147483647
01:41:28 <quicksilver> compiler dependent too
01:41:31 <quicksilver> in principle
01:41:42 <hpaste>  (anonymous) pasted "yi can't be built on this system" at http://hpaste.org/5391
01:41:46 <goalieca> haskell follows c typing?
01:41:50 <quicksilver> you could imagine a haskell implementation which didn't use all 32 bits for the integer
01:41:58 <quicksilver> because it was saving some for metadata
01:42:06 <b_jonas> quicksilver: like bignums, yes
01:42:07 <quicksilver> that's why the standard only guarantees it to be at least 30
01:42:11 <Cale> goalieca: hm?
01:42:23 <quicksilver> however, it happens that ghc does use all 32 bits
01:42:24 <b_jonas> goalieca: no
01:42:29 <quicksilver> ghc puts the metadata 'elsewhere'
01:42:38 <quicksilver> (and all 64 bits if you compile it on a 64bit platform)
01:42:42 <goalieca> b_jonas, good its sane. i hate languages where int can be 16, 32, or 64
01:42:44 <goalieca> or 8
01:42:45 <dv\> why does cabal refuse to build yi on my system?
01:42:53 <Cale> goalieca: Haskell's and C's type system could not be more different.
01:42:56 <b_jonas> goalieca: I thikn that's a good feature
01:42:57 <quicksilver> goalieca: it's not as sane as you want :)
01:43:08 <b_jonas> it can be of different size in haskell too
01:43:13 <quicksilver> int being 16, 32, or 64 was the most disastrously ridiculous feature in C
01:43:13 <goalieca> why!?
01:43:29 <goalieca> well not to forget 24-bit
01:43:29 <b_jonas> that's why we have Int32 and the like in haskell, and int64_t etc in C99
01:43:29 <dmwit> dv\: A bit more information would be helpful.
01:43:31 <quicksilver> and has been the cause of more annoyance to me than any of the other bad features of C
01:43:36 <dmwit> dv\: Paste the errors you get here:
01:43:37 <goalieca> i sometimes do embedded systems. not fun to deal with quirks when porting
01:43:38 <dmwit> ?hpaste
01:43:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:43:44 <dv\> dmwit: http://hpaste.org/5391
01:43:46 <quicksilver> goalieca: haskell Int is guaranteed to be at least 30 bits.
01:43:53 <quicksilver> goalieca: it may be more, but will never be less.
01:43:53 <mauke> C doesn't require int to be a power of 2
01:43:56 <Cale> 29 actually
01:43:58 <Cale> er
01:44:05 <b_jonas> mauke: they do actually, mostly
01:44:08 <Cale> oh, maybe it was 30 *bits*
01:44:10 <mauke> b_jonas: no
01:44:13 <dmwit> dv\: eugh
01:44:15 <goalieca> i recall seing a 24-bit int once
01:44:21 <quicksilver> and it's supposed to be 'fast'; it's expected to map to a good native integer of some kind.
01:44:23 <dmwit> dv\: Sorry, I've never seen that before!
01:44:28 <dmwit> Anybody else seen that?
01:44:41 <mauke> C only says it has to be at least 16 bits wide
01:44:51 <quicksilver> dmwit: architecture not supported by hs-plugins?
01:44:54 <b_jonas> mauke: oh, you mean a power-of-two count of bits?
01:45:04 * dv\ runs i386 linux
01:45:10 <mauke> er, yes
01:45:16 <b_jonas> well of course it doesn't, it was 18 bits int and 36 bits int on computers with 9-bit bytes
01:45:21 <b_jonas> or something like that
01:45:31 <b_jonas> so that's natural
01:45:35 <Cale> dv\: That shouldn't really be a problem then... it's really strange that you're not getting more output than that.
01:46:16 <igel> i've got a question concerning the Foldable class:
01:46:23 <Cale> I'm pretty sure that people have gotten yi-0.3 working on i386 linux, at least :)
01:46:52 <igel> may the user of 'fold' assume any order on the elements?
01:47:03 <Cale> igel: I don't think so.
01:47:19 <Cale> er...
01:47:35 <Cale> Well, you're going to get them in *some* order.
01:47:40 <igel> so i may assume that in a call of 'fold f' f is... uhm
01:47:46 <quicksilver> igel: for a particular foldable VALUE the order will be consistent
01:47:46 <igel> how do you call it in english?
01:47:55 <igel> (a + b) + c = a + (b + c)
01:48:03 <doserj> dv\: did you try -v? have you alex installed?
01:48:05 <Cale> associative?
01:48:06 <mauke> associativity
01:48:09 <quicksilver> igel: but there is no guarantee that for another value constructed from that one is going to be consistent order.
01:48:10 <igel> ah yes :)
01:48:17 <Cale> igel: Well, it would be best if it were.
01:48:21 <b_jonas> Cale: ioccc guidelines also do a joke on such prime filters:
01:48:29 <dv\> doserj: i don't have alex. i'll install it and report back
01:48:34 <b_jonas> http://www.de.ioccc.org/2006/guidelines.txt says
01:48:37 <quicksilver> igel: it's OK to fold over non-associative functions
01:48:47 <Cale> igel: Otherwise, you'll get some association, but not necessarily a useful one.
01:48:57 <b_jonas> 'We tend to look down on a prime number printer, that claims that 16 is a prime number.  If you do have a bug, you are better off documenting it.  Noting "this entry sometimes prints the 4th power of a prime by mistake" would save the above entry.  And sometimes, a strange bug/feature can even help the entry!  Of course, a correctly working entry is best.'
01:49:14 <igel> well the problem is i could transform my data structure in an ordered list
01:49:20 <Cale> hmm, I wonder what association you get when folding over a Set :)
01:49:24 <igel> but this would take longer than an unsorted one
01:49:26 <quicksilver> igel: but only if you 'don't care' about the associativity
01:49:42 <quicksilver> igel: IYSWIM.
01:49:53 <igel> IYSWIM?
01:49:59 <quicksilver> if you see what I mean.
01:49:59 <dv\> doserj: installed alex 2.1.0-rc1. same output. -v gives the same, plus an additional line: /usr/local/bin/ghc --print-libdir
01:50:14 <quicksilver> it's OK to use a non-associative fold function, as long as it odesn't matter to you which way it gets associated.
01:50:23 <igel> yes i see
01:50:31 <quicksilver> so you might build a tree using 'fold', but you'd have to not care about exactly how it ends up.
01:50:34 <mauke> b_jonas: if you get a rounding error, it should manifest as $r = 1 + int sqrt $n; $r * $r <= $n, right?
01:51:00 <quicksilver> of course the vanilla fold uses Monoid, and Monoid instances are supposed to be associative :)
01:51:06 <quicksilver> but you might cheat.
01:51:33 <igel> well normally fold is used to do things like writing all elements that fulfill property p in a list/set
01:52:47 <quicksilver> hmm
01:52:58 <quicksilver> that sounds like filter . toList
01:53:05 <quicksilver> of course, you can factor all folds via toList
01:53:12 <quicksilver> cos lists are free monoids.
01:53:31 <igel> sure
01:54:15 <dmwit> ?index unsafePerformIO
01:54:16 <lambdabot> System.IO.Unsafe, Foreign
01:54:33 <b_jonas> mauke: oh no, I'm not talking about that case
01:54:41 <b_jonas> that one works right
01:54:57 <b_jonas> it's without the 1 + that I think it might fail
01:55:06 <mauke> fail how?
01:55:07 <b_jonas> you asked why you need the 1+
01:55:31 <b_jonas> fail in that trunc(sqrt($n)) is actually one less than the exact maths value of sqrt($n) would be
01:55:34 <igel> Cale: Data.Set seems to use the elemnts in order
01:55:44 <b_jonas> but I think I'm wrong too
01:55:44 <mauke> b_jonas: isn't that what I said?
01:55:48 <b_jonas> it will actually not do that
01:56:01 <b_jonas> mauke: ah, I see
01:56:04 <Cale> igel: left, or right associated?
01:56:17 <b_jonas> $r = 1 + int sqrt $n; $r * $r _<=_ $n
01:56:26 <doserj> dv\: what happens when you build it with -fvty or -fgtk?
01:56:27 <igel> uhm
01:56:29 <igel>     foldMap f (Bin _s k l r) = foldMap f l `mappend` f k `mappend` foldMap f r
01:56:38 <b_jonas> well, I think it won't happen in this case,
01:56:47 <b_jonas> it must have been some other code
01:56:51 <Cale> okay, so probably associated according to the underlying tree structure
01:57:00 <igel> yes
01:57:13 <doserj> dv\: (or rather, configure it...)
01:57:38 <dv\> doserj: hm. it complains that i have neither vty nor gtk
01:57:58 <doserj> well, it needs one of them :)
01:57:59 <b_jonas> sorry
01:58:11 <quicksilver> Cale: which conveniently gives you log(n) access to the first element.
01:58:16 <quicksilver> Cale: via head . toList
01:58:45 <Cale> quicksilver: hm?
01:58:48 <dv\> doserj: so that would be yi-vty and yi-gtk from hackage?
01:58:58 <quicksilver> Cale: associating according to the underlying tree structure
01:59:13 <quicksilver> Cale: gives you log(n) access to the first element via the foldable instance.
01:59:18 <quicksilver> Cale: if the tree is balanced of course
02:00:26 <Cale> Wouldn't it do the same if it associated things to the right?
02:00:55 <doserj> dv\: first, you need vty, or gtk2hs, i think
02:02:27 <dv\> doserj: vty doesn't build on ghc 6.8: http://hackage.haskell.org/packages/archive/vty/3.0.0/logs/failure/ghc-6.8 (I get the same error)
02:02:29 <lambdabot> http://tinyurl.com/2xrjut
02:02:38 <mauke> Cale: you're the center of the channel graph again
02:03:08 <Cale> heh, that's awesome :)
02:03:31 <b_jonas> what graph?
02:03:44 <Cale> http://files.codersbase.com/haskell/haskell-current.png
02:03:51 <Cale> Check out my majesty :)
02:03:51 <doserj> dv\: yes. you can fix that by adding bytestring and containers to the buld-depends in vty.cabal
02:04:06 <Cale> Just like Trogdor :)
02:04:23 <resiak> the questions is, could we manipulate it to draw constellations ?
02:04:50 <dmwit> easily
02:04:59 <dmwit> (With a bit of central planning.)
02:05:03 <b_jonas> Cale: hmm, how large a time interval is that using?
02:05:14 <Cale> I don't know. There's a slight decay on it.
02:05:35 <b_jonas> Cale: I mean, is it just one day or more?
02:05:39 <b_jonas> because it seems small
02:05:50 <Cale> Oh, it can't be more than one or two days.
02:05:52 <dmwit> I think the operative word is decay.
02:06:06 <dmwit> It isn't a fixed time interval; strong connections seem to last longer.
02:06:07 <osfameron> ;-)
02:06:26 <b_jonas> resiak: like http://en.wikipedia.org/wiki/Nanoputian ?
02:06:29 <lambdabot> Title: Nanoputian - Wikipedia, the free encyclopedia
02:06:46 <dmwit> I do know that I had a few reasonably strong connections, then they were gone eight hours later, if that gives you a feel for it. =)
02:06:48 <b_jonas> dmwit: that could be because the intervals are overlapping
02:06:57 <b_jonas> that is, a sliding window
02:07:21 <dmwit> er, no?
02:07:29 <b_jonas> that's how statistics like this works:  http://mojotoad.perlmonk.org/cbs/
02:07:40 <resiak> b_jonas: heh!
02:08:01 <dmwit> You can establish a connection just by saying somebody's name, and it will last much less long than somebody else's strong connection, even if their conversation ended a while ago.
02:09:24 <b_jonas> dmwit: I see
02:09:56 <lambdabot> Title: ChatterBox @ www.perlmonks.org stats by mojotoad
02:10:25 <Cale> But nobody threatens by graph-theoretic majesty! Uwahahaha! I am drunk with valency!
02:10:38 <yondalf> :t fail
02:10:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
02:10:50 <Cale> fail is evil.
02:11:09 <mauke> fail fail is fail
02:11:11 * dmwit would try to challenge Cale, but doesn't want to make everybody's client beep
02:11:12 <dmwit> =P
02:12:04 <mauke> > fail . fail . fail $ "hi"
02:12:04 <lambdabot>   add an instance declaration for (Show (m a))
02:12:46 <yondalf> i was just wondering what fail did since it apparently is called when there's a pattern match error in do notation
02:12:48 <dmwit> > fail.fail.fail$"hi"::Maybe(Maybe(Maybe(String)))
02:12:49 <lambdabot>  Nothing
02:12:53 <funktio> @index on
02:12:53 <lambdabot> bzzt
02:13:05 <Cale> yondalf: yeah. It usually just crashes the program, but sometimes it does something else.
02:13:07 <dolio> Data.Function
02:13:22 <dv\> doserj: thanks. everything works now (well, vty anyway)
02:13:38 <Cale> yondalf: There are quite a few people who think it shouldn't be in the standard, and that the translation for do-notation should be different.
02:13:54 <b_jonas> "drunk with valency"++
02:14:02 <doserj> dv\: good :)
02:14:14 <dolio> @karma valency"
02:14:14 <lambdabot> valency" has a karma of 1
02:14:35 <mauke> @karma
02:14:35 <lambdabot> You have a karma of 13
02:14:40 <Cale> @karma
02:14:40 <lambdabot> You have a karma of 58
02:14:43 <Cale> @karma dons
02:14:43 <lambdabot> dons has a karma of 146
02:15:16 <doserj> @karma lambdabot
02:15:17 <lambdabot> lambdabot has a karma of 56
02:15:19 <b_jonas> :src Monad
02:15:19 <yondalf> Cale: well i haven't had need for patterns that do not catch everything in do notation yet :-)
02:15:23 <quicksilver> b_jonas: I't snot time interval.
02:15:31 <quicksilver> b_jonas: it redraws after every single comment.
02:15:37 <b_jonas> quicksilver: wow
02:15:47 <quicksilver> (and it potentially ages old links after every comment, although I don't know the algorithm
02:15:49 <b_jonas> but that didn't make sense
02:15:51 <Cale> yondalf: yeah. Most of the cases where it's actually useful, it would be better to use something like mzero
02:16:13 <b_jonas> I mean, those two are orthogonal
02:16:24 <b_jonas> "after every single comment" is when it refreshes/recalculates the graph
02:16:31 <quicksilver> b_jonas: yes. they are technically orthogonal.
02:16:34 <b_jonas> but how far back does it use the data?
02:16:39 <quicksilver> but my strong vibe is it works on 'ticks' not time.
02:16:43 <b_jonas> but if it ages, then it's not like that
02:16:49 <quicksilver> so it's "you get expired after 500 comments"
02:16:52 <quicksilver> not "3 hours"
02:16:55 <quicksilver> that's only a guess though.
02:16:59 <b_jonas> @src Monad
02:16:59 <lambdabot> class  Monad m  where
02:16:59 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:16:59 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:16:59 <lambdabot>     return      :: a -> m a
02:16:59 <lambdabot>     fail        :: String -> m a
02:17:10 <b_jonas> hmm
02:17:27 <b_jonas> is that truncated or does it really not include a default for (>>) ?
02:17:28 <quicksilver> I wonder why I have such a central location despite a rather small number of connections.
02:17:34 <quicksilver> it's truncated
02:17:37 <quicksilver> src doesnt show defaults
02:17:44 <quicksilver> would be a bit spammy if it did, I guess.
02:17:48 <b_jonas> what?
02:18:03 <b_jonas> but the point of src is to show the implementation
02:18:03 <quicksilver> show defaults.
02:18:06 <b_jonas> not just the interface
02:18:06 <quicksilver> ;)
02:18:08 <yondalf> not many introductions to monads mention fail :-)
02:18:52 <dmwit> It's an embarassing topic, really.
02:18:58 <b_jonas> lol
02:20:30 <quicksilver> yeah.
02:20:42 <quicksilver> You need to know someone pretty well before you admit your Monad class has 'fail'.
02:20:49 <quicksilver> Not something you want to get back to your friends.
02:22:36 <quicksilver> "Idioms" : Because we think it makes us sound superior if our language doesn't have "Patterns".
02:23:18 <dmwit> ?hoogle Ix i => (i, i) -> [e] -> Array i e
02:23:19 <lambdabot> No matches, try a more general search
02:23:29 <dmwit> ?doc Array
02:23:30 <lambdabot> Array not available
02:23:37 <int-e> but the language does have patterns. but they are no idioms.
02:23:54 <b_jonas> ?hoogle (i, i) -> [e] -> Array i e
02:23:54 <lambdabot> No matches, try a more general search
02:24:44 <b_jonas> dmwit: listArray
02:24:50 <b_jonas> @type listArray
02:24:52 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
02:24:55 <dmwit> Thanks.
02:28:47 <quicksilver> what's odd, why didn't hoogle find that.
02:28:54 <quicksilver> it's supposed to work for simple type classes
02:29:13 <dmwit> Maybe it doesn't have Data.Array in its list.
02:29:22 <dmwit> ?hoogle listArray
02:29:23 <lambdabot> Data.Array.IArray.listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
02:29:23 <lambdabot> Data.Array.MArray.newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)
02:29:24 <quicksilver> ah
02:29:28 <quicksilver> hoogle does work
02:29:32 * yaxu tries replacing emacs with yi for a day
02:29:33 <quicksilver> it's just lambdabot which doesn't
02:29:39 <quicksilver> http://www.haskell.org/hoogle/?q=%28Ix+i%29+%3D%3E+%28i%2C+i%29+-%3E+%5Be%5D+-%3E+Array+i+e
02:29:41 <lambdabot> Title: (Ix i) => (i, i) -> [e] -> Array i e - Hoogle, http://tinyurl.com/2cgzz9
02:29:47 <masklinn> "
02:29:57 <quicksilver> lambdabot = the brok.
02:30:39 <quicksilver> I guess LB embeds a copy of hoogle, rather than using the web service? And that copy is out of date.
02:30:48 <dmwit> yeah
02:31:15 <roconnor> @seen Cale
02:31:15 <lambdabot> Cale is in #not-math, #oasis, #haskell-overflow, #haskell and #ghc. I last heard Cale speak 15m 24s ago.
02:31:44 <dmwit> I swear to God I've written "permutations" like eighteen times by now.
02:31:53 <dmwit> I can never find my previous implementation, either.
02:32:33 <wagle_> check under epmrtutaoisn
02:32:40 <Cale> haha
02:32:41 <quicksilver> have you at least got the hang of spelling it?
02:32:47 <quicksilver> that normally takes me 15 attempts.
02:32:53 <Cale> dmwit: I've done it at least that many times too.
02:32:56 <roconnor> dmwit: try using "importunate" instead
02:33:08 <Cale> dmwit: It really should be in the standard list library.
02:33:29 <dmwit> Cale: Agreed, along with combinations.
02:33:47 <roconnor> Cale: (w, m a) -> m (w,a), but m (r -
02:33:50 <dmwit> Powerset would be nice, too, but the solution is so pretty that it doesn't feel bad to write it over and over. =)
02:33:59 <roconnor> Cale: (w, m a) -> m (w,a), but m (r -> a) -> (r -> m a)
02:34:13 <vincenz> roconnor: w = comonad?
02:34:13 <Cale> dmwit: That is combinations, no?
02:34:26 <roconnor> Cale: w is a monoid for writer
02:34:40 <dmwit> uh.
02:34:43 <roconnor> Cale: I'm surprised there is both a ReaderT and WriterT.
02:35:02 <vincenz> roconnor: why?
02:35:05 <roconnor> Cale: I bet one monad transfomer is broken.
02:35:13 <roconnor> Cale: Probably ReaderT, but I'm not sure.
02:35:18 <Cale> roconnor: why broken?
02:35:43 <quicksilver> pretty sure readerT isn't broken.
02:35:44 <dmwit> combinations n = filter ((== n) . length) . powerset
02:35:44 <b_jonas> they're quite different
02:35:47 <quicksilver> it's too simple :)
02:35:52 <roconnor> vincenz: because the writer monad distributes over all monads, but all monads distribute over reader.
02:36:02 <b_jonas> ReaderT is just wrapping over (->)
02:36:06 <vincenz> sounds dual :)
02:36:11 <alexj> @seen igloo
02:36:11 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 8h 24m 10s ago.
02:36:12 <b_jonas> they're not dual at all
02:36:23 <quicksilver> there is a sense in which they are duel.
02:36:26 <roconnor> vincenz: but monad transformers are supposed to put one monad inside the other.
02:36:28 <b_jonas> readert just gives you a constant parameter to read, writerT allows you to write on the side of a monad
02:36:30 <Cale> Yeah, they are a bit dual.
02:36:36 <b_jonas> um, of a monoid
02:37:00 <quicksilver> the representation of the writer monad is also the representation of the reader comonad, which is isomoprhic ot hthe reader monad.
02:37:01 <Cale> The monoid axioms are used in showing the monad associativity, btw.
02:37:03 <b_jonas> well, as usual there must be some category theory reasoning why they're dual :)
02:37:05 <quicksilver> that's a kind of duality.
02:37:22 <roconnor> @src ReaderT
02:37:22 <lambdabot> Source not found. You untyped fool!
02:37:33 <roconnor> @src Control.Monad.Reader.ReaderT
02:37:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:37:36 <roconnor> bah
02:38:24 <roconnor> My point is, composition of monads is a monad when one distributes over the other in the proper order.
02:38:37 <doserj> roconnor: there are two ways of going from m (n (m (n a))) to a: one by m n -> n m (applied outside, or inside), one by n m -> m n (applied in the middle)
02:38:41 <roconnor> But since writer and reader monads distribute in different directions
02:39:00 <roconnor> then they both cannot compose on the left (or right or whichever way monad transformers work)
02:39:12 <Cale> roconnor: except that monad transformers don't actually work like that
02:39:23 <Cale> (they don't necessarily correspond to a distributive law)
02:39:30 <roconnor> doserj: wholey crap!
02:39:46 <doserj> roconnor: ?
02:39:52 <roconnor> doserj: wait, how does that outside thing work?
02:40:54 <quicksilver> doserj: I'm not sure if that's what you meant to say.
02:41:08 <roconnor> m (n (m (n a))) ==> n (m (m (n a))) ==> (n (m (n a))) ==> (n (n (m a))) ==> (n (m a))
02:41:14 <roconnor> but that's wrong
02:41:21 <roconnor> you need to end up with m (n a).
02:41:44 <quicksilver> if you can commute inner pairs of m/n that helps, certainly
02:41:45 <roconnor> Cale: how do monad transformers work if they don't use this distributive law thing?
02:41:46 <b_jonas> cool, now this is starting to look more like a usual #haskell discussion
02:41:54 <quicksilver> but it doesn't follow that that is the only way to make it work
02:42:21 <quicksilver> I assert, for example, that all possible setups of StateT and ContT form monads.
02:42:29 <quicksilver> but, they certainly don't commute.
02:42:35 <quicksilver> not even as inner parts of a deep nest.
02:42:57 <quicksilver> StateT ContT is very importantly different from ContT StateT
02:43:11 <roconnor> quicksilver: do monad transformers applied to any monad form a monad?
02:43:20 <quicksilver> no, certainly not.
02:43:25 <roconnor> quicksilver: ahhhh
02:43:26 <Cale> roconnor: They produce some new construction and define return and bind on it such that it becomes a monad. I don't think it necessarily corresponds to a composition of monads.
02:43:26 <quicksilver> it's a theorem if they do.
02:43:44 <quicksilver> it's not "obvious" that monad transformers always work.
02:43:46 <Cale> Reader happens to
02:43:48 <quicksilver> it's something you have to prove.
02:43:52 <roconnor> quicksilver: so SomeMonadT m is not always a monad?
02:44:09 <quicksilver> it is a very very strong property of SOmeMonadT if that's true.
02:44:10 <roconnor> Cale: ReaderT m is always a monad?
02:44:14 <quicksilver> it is true of ReaderT, definitely.
02:44:23 <roconnor> Cale: is WriterT m always a monad?
02:44:24 <quicksilver> reader is a very well-behaved thing.
02:44:30 <Cale> roconnor: er, actually, I'm not certain that it arises from a distributive law.
02:44:52 <Cale> But ReaderT and WriterT both construct monads on the composition of monads.
02:45:00 <quicksilver> ListT is a good example of how it fails.
02:45:05 <quicksilver> ListT (Identity) is a monad
02:45:06 <Cale> (in the opposite order in each case)
02:45:12 <quicksilver> but ListT m isn't always a monad.
02:45:22 <Vq^> is there a ListT?
02:45:26 <roconnor> @type sequence
02:45:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:45:29 <Cale> ListT should be removed from the libraries for not being a monad transformer.
02:45:31 <yaxu> hm, it seems vty isn't recognising many of my keypresses, such as <home> and <end>
02:45:35 <quicksilver> right.
02:45:35 <roconnor> look, a distributative law!
02:46:07 <quicksilver> I suspect that Reader, Writer, State and Cont all work together fine
02:46:09 <Cale> roconnor: Is it really, though? Do the axioms check out?
02:46:15 <quicksilver> for any depth of nestying
02:46:24 <quicksilver> but I don't think that's remotely obvious.
02:46:30 <quicksilver> it would need proving.
02:46:36 <roconnor> Cale: I assume the do :P
02:46:40 <roconnor> they do
02:46:46 <Cale> I believe that Reader, Writer, State and Cont are all true monad transformers.
02:46:56 <Cale> and as such, always produce a monad when given a monad.
02:47:27 <quicksilver> but they reason that they do so isn't that you can commute them around.
02:47:55 <Cale> You can't actually commute monad transformers in general.
02:48:11 <Cale> (It generally ends up producing vastly different effects)
02:48:26 <yondalf_> :t get
02:48:27 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
02:48:32 <roconnor> who said anything about commuting monads?
02:49:05 <roconnor> ReaderT is defined as (r -> m a)
02:49:35 <roconnor> WriterT is defined as (m (a, w))
02:49:42 <quicksilver> roconnor: someone said somethign about defining join from NMNMa by doing
02:49:45 <roconnor> Okay, i see now
02:49:49 <int-e> Well, ContT is a monad even if its m parameter isn't.
02:49:53 <quicksilver> NMNM -> NNMM -> NM
02:49:59 <quicksilver> and that isn't right
02:50:01 <int-e> m only needs to be a monad for 'lift'.
02:50:03 <roconnor> ReaderT and WriterT compose monads in different directions.
02:50:04 <quicksilver> that's not how join works.
02:50:17 <doserj> yep, i misremembered
02:50:21 <quicksilver> if it *was* right, that would certainly make it easier
02:50:27 <quicksilver> but for interesting effects, it doesn't.
02:50:30 <roconnor> ReaderT m  = Reader (m a)
02:50:42 <roconnor> WriterT m = m (Writer a)
02:50:46 <roconnor> that's how they do it.
02:50:52 <doserj> erm, well that direction actually works, doesn't it
02:50:54 <roconnor> and then they use the distributative laws.
02:51:13 <roconnor> @umtl (ReaderT m)
02:51:13 <lambdabot> ReaderT m
02:51:16 <roconnor> @unmtl (ReaderT m)
02:51:16 <lambdabot> ReaderT m
02:51:20 <roconnor> @unmtl (ReaderT m a)
02:51:20 <lambdabot> err: Unknown MTL(1)
02:51:23 <int-e> Hmm, would any code break if we drop the Monad m =>  contexts from ContT's Functor, Monad and MonadCont instances?
02:51:59 * Dane is looking for user ndm
02:52:06 <roconnor> quicksilver: NMNM -> NNMM -> NM that is right.
02:52:17 <Dane> Anybody know ndm?
02:52:19 <roconnor> quicksilver: I now I bet that is how readerT and writerT work.
02:52:26 <quicksilver> roconnor: it woudl be right, if N & M had that kind of internal commutation.
02:52:32 <quicksilver> roconnor: but in general they don't.
02:52:38 <quicksilver> roconnor: certainly state and cont don't.
02:52:41 <int-e> (nm. sure, code with explicit type signatures like  (Monad (ContT r m)) => ...  that uses m as a monad will break.)
02:52:43 <doserj> of course, you need that distributive law
02:52:55 <roconnor> quicksilver: but, reader and writer do.
02:53:16 <quicksilver> reader commutes with all the other monads, doesn't it?
02:53:17 <roconnor> quicksilver: oh, but you are right, state is different.
02:53:23 <quicksilver> it certainly commutes with writer and state
02:53:29 <roconnor> quicksilver: state has both a reader and writer part.
02:53:49 <roconnor> quicksilver: so it's transformer snuggles itself around the other monad.
02:53:49 <quicksilver> ReaderT StateT = StateT ReaderT
02:54:02 <roconnor> quicksilver: interesting.
02:54:08 <Cale> ContT clearly isn't the composition of Cont with anything.
02:54:34 <roconnor> so monad transformers aren't always compositions.
02:54:42 <Cale> and yeah, StateT is sort of funky.
02:54:48 <quicksilver> ReaderT commutes with writer and state, I'm not sure if it does with Cont.
02:54:49 <b_jonas> how do you pronounce OS X?
02:54:56 <b_jonas> is it like 'oh-ass axe'?
02:54:56 <int-e> ContT r m = Cont (m r)
02:54:56 <Cale> It's got changes on both sides of m
02:55:11 <quicksilver> b_jonas: oh ess ex
02:55:14 <Cale> b_jonas: If you have a very strange accent, then yeah.
02:55:21 <resiak> "oh ess ten"!
02:55:29 <mauke> oh six
02:55:35 <Cale> awwsix
02:55:40 <quicksilver> I normally hear "oh ess ex" or "mack oss ten"
02:56:38 <quicksilver> Cale: in fact, doesn't ((->) r) commute with any functor?
02:56:38 <Cale> Awwsix ten and four tenths.
02:56:46 <Cale> http://uk.youtube.com/watch?v=W-ctuGBYKq4
02:56:47 <lambdabot> Title: YouTube - Ten and Four Tenths
02:56:52 <quicksilver> Cale: and thus, any monad.
02:57:03 <b_jonas> en.wikipedia says it's pronounced ten
02:57:09 * dolio usually says "ex" in his head, despite knowing it should probably be "ten".
02:57:40 <dolio> Just like I still pronounce "warez" as "wah-rez" in my head.
02:57:55 <Cale> dolio: Oh no! You're one of *those* people!
02:58:07 <swiert> quicksilver: I don't think -> r commutes with times b, for instance.
02:58:10 <Cale> hehe :)
02:58:12 <dolio> Well, I didn't know the correct pronunciation for a long time.
02:58:39 <Cale> "I have a Ossix Ten and Four Tenths, number 10"
02:58:52 <paolino> dolio, which is ?
02:59:05 <dolio> paolino: Sounds like "wares".
02:59:10 <yaxu> ah the home/end thing is a known bug in vty, I guess I'll switch back to emacs for now then
02:59:23 <roconnor> quicksilver: I'm happy now
02:59:24 <roconnor> :)
02:59:26 <quicksilver> swiert: times b? you mean (,) b ?
03:00:03 <quicksilver> swiert: ah no, it doesn't. You're right.
03:00:06 <quicksilver> doh.
03:00:06 <swiert> quicksilver: yes.
03:00:13 <quicksilver> what was I thinking.
03:00:13 <quicksilver> hmm
03:00:19 <mauke> coming up next: SQL and Tcl
03:00:20 <quicksilver> yes, of course it's different.
03:00:24 <quicksilver> roconnor: I was wrong.
03:00:30 <quicksilver> roconnor: stateT and readerT do not commute.
03:00:43 <roconnor> quicksilver: stateT is bad.
03:00:43 <quicksilver> roconnor: and neither do readerT and writerT
03:00:45 <dolio> I'm not sure why the z makes my brain go haywire, because I know how to say "wares."
03:00:57 <quicksilver> roconnor: the only thing which commutes is multiple copies of readerT with itself
03:01:00 <roconnor> quicksilver: I'm not sure who started talking about monads that commute. :)
03:01:04 <quicksilver> and multiple copies of writerT with itself.
03:01:06 <quicksilver> quicksilver: I did.
03:01:09 <roconnor> oh
03:01:09 <quicksilver> ;)
03:01:11 <roconnor> :)
03:01:16 <quicksilver> but it seemed relevant to the discussion.
03:01:22 <jedbrown> New CC/delcont release.  dolio++
03:01:23 <quicksilver> commutation would give you join for free
03:01:27 <quicksilver> which was doserj's point.
03:02:02 <Cale> I'd like to see LogicT distriuted with GHC.
03:02:05 <Cale> b*
03:02:06 <dmwit> > let asPositional xs = read (xs >>= show) in asPositional [5,2,8]
03:02:08 <lambdabot>  528
03:02:13 <Cale> I think it's sufficiently cool :)
03:02:13 <dmwit> sick
03:02:14 <roconnor> @src LogicT
03:02:15 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:02:27 <dolio> I need to get a new version of that out, too.
03:02:39 <dolio> There's still a bug in the hackage version, I think.
03:02:45 <b_jonas> what's LogicT?
03:03:10 <paolino> a curry language feature ?
03:03:30 <quicksilver> it transforms illogical code into logical code
03:03:31 <b_jonas> also, isn't it that the whole mtl isn't distrubuted with ghc?
03:03:35 <quicksilver> very powerful.
03:03:47 <b_jonas> oh, so it's like KittehT from lambdacats
03:04:10 <paolino> quicksilver :is that what they call narrowing in curry ?
03:04:17 <dmwit> ?go logict backtracking
03:04:18 <lambdabot> http://okmij.org/ftp/Computation/monads.html
03:04:18 <lambdabot> Title: Monads
03:04:51 <Cale> LogicT turns Haskell into a proper logic programming language of sorts. It's like the list monad on steroids.
03:05:10 <b_jonas> Cale: you mean like prolog?
03:05:35 <b_jonas> with mplus meaning ; from prolog
03:05:37 <Cale> Somewhat... though the translation is still pretty heavy.
03:05:56 <b_jonas> eek
03:06:02 <quicksilver> Cale: it's also a bit like the list monad turned into a well behaved transformer, isn't it?
03:06:15 <Cale> yes, it's also that :)
03:06:23 <b_jonas> the only time I used prolog, I used it like a normal functional language with no backtracking or failures
03:06:27 <dolio> It's a lot closer to ListT done right.
03:06:35 <dolio> Only implemented with continuations.
03:06:40 <quicksilver> closer to right than 'ListT done right' is :)
03:07:10 <Cale> b_jonas: well, you've used list comprehensions, right? They're a *little bit* like prolog.
03:07:18 <b_jonas> Cale: yes
03:07:22 <b_jonas> hmm
03:07:29 <Cale> LogicT gets a bit closer.
03:07:38 <b_jonas> I see
03:08:00 <Cale> It adds things like fair choice (so you can select from more than one infinite list)
03:08:44 <b_jonas> now I'm starting to wonder what ListT is and what it's done wrong
03:08:48 <b_jonas> (I see it's in mtl)
03:08:57 <quicksilver> the listT in the mtl isn't a proper transformer
03:09:03 <quicksilver> ListT m isn't always a monad.
03:09:04 <Cale> b_jonas: What it's done wrong is that most of the time it doesn't give you a monad.
03:09:09 <b_jonas> I see
03:09:16 <quicksilver> there is a ListT done right, on the wiki
03:09:21 <quicksilver> which is always a monad, I believe
03:09:26 <quicksilver> but somehow it's not quite what you want/expect it to be
03:09:34 <quicksilver> at least, not what I want/expect
03:09:37 <b_jonas> thanks for the explanation
03:09:38 <Cale> In particular, it fails the associativity axiom unless the monad you apply it to is commutative.
03:09:45 <b_jonas> I might look at that LogicT thing later
03:09:48 <Cale> *Very* few monads are commutative.
03:09:48 <b_jonas> I have to go now
03:10:00 <Cale> Check out the paper, it's very enlightening.
03:10:14 <quicksilver> Cale: although certain monads are 'commutative up to stuff we don't care about'
03:10:41 <quicksilver> Cale: like Random, uniquesupply, and [] itself.
03:11:23 <quicksilver> informally, I suppose, all of those have "Readonly" effects.
03:11:37 <Cale> hmm, yeah.
03:11:45 <quicksilver> in fact, []'s effects aren't even observable from 'inside' the monad.
03:11:50 <quicksilver> I'm not sure what I mean by that.
03:11:56 <quicksilver> but intuitively I mean something ;)
03:12:00 <Cale> I'm pretty sure that I know :)
03:12:02 <roconnor> Cale: shouldn't ListT m = m [a] be a monad transformer?
03:12:10 <paolino> the other thing which looks very useful in curry is reduction, which was in Oz I believe, that sort of thing that makes the code wait until other threads bind a variable, but in a declarative way
03:12:25 <Cale> roconnor: Only if you can get it to satisfy the axioms.
03:12:36 <roconnor> surely it does :)
03:12:44 <Cale> (which ListT has failed to do, miserably.)
03:12:58 <roconnor> how is ListT defined?
03:13:08 <Cale> newtype ListT m a = ListT { runListT :: m [a] }
03:13:15 <Cale> instance (Monad m) => Monad (ListT m) where
03:13:15 <Cale>     return a = ListT $ return [a]
03:13:15 <Cale>     m >>= k  = ListT $ do
03:13:15 <Cale>         a <- runListT m
03:13:15 <Cale>         b <- mapM (runListT . k) a
03:13:15 <Cale>         return (concat b)
03:13:17 <Cale>     fail _ = ListT $ return []
03:13:33 <roconnor> crap, that is my definition :(
03:14:06 <dolio> I wouldn't worry about it. The correct definition isn't obvious.
03:15:51 <Cale> newtype SFKT m a = SFKT (∀ ans. SK (m ans) a → FK (m ans) → m ans)
03:16:03 <Cale> (copied from the paper)
03:16:16 <Cale> That's essentially what LogicT is using.
03:17:20 <Cale> newtype LogicT m a = LogicT { unLogicT :: forall ans. SK (m ans) a -> FK (m ans) -> m ans }
03:17:33 <Cale> (yep, that's from the actual code on Hackage)
03:18:07 <Cale> oh, and I should mention:
03:18:10 <Cale> type SK r a = a -> r -> r
03:18:11 <Cale> type FK a = a
03:19:15 <Cale> The idea is that you're hooking up success and failure continuations in various ways to get the intended effects.
03:19:15 <paolino> most of myself will never get there :)
03:19:29 <roconnor> Cale: is there cut?
03:19:49 <Cale> roconnor: yes, in fact, cut is factored into two simpler operations
03:20:12 <resiak> How finished should a library be before being stuck up on Hackage ?
03:20:38 <Cale> resiak: It compiles and does something sort of useful?
03:21:07 <resiak> Cale: text and RDF queries of the tracker database!
03:21:32 <Cale> Yay! Now I just have to figure out what tracker is :)
03:22:08 <resiak> desktop search thing; like beagle and spotlight and lalala
03:22:19 <Cale> ah, cool
03:22:36 <resiak> hrm, I should probably namespace it properly first
03:22:48 <Cale> Oh, right, trackerd
03:23:16 <Cale> hehe, I killed that soon after installing Ubuntu since it was using 100% CPU for a long time.
03:23:22 <paolino> ah that process that I kill whenever I need back a working box at 8 pm !
03:23:37 <resiak> that was my experience too
03:24:08 <resiak> but it seems to work these days; once you give it a few hours to initially index everything, it's pretty unintrusive
03:25:25 <Cale> Things like that though, I sometimes wonder if they should really be at the level they are.
03:26:06 <resiak> Any raises on a better module root than System.Tracker ?
03:27:02 <nanothief> is it possible to get tab completion working for ghci under windows?
03:28:05 <paolino> nanothief: that is readline lib I think
03:29:42 <nanothief> paolino: would it then be possible to use a windows build of readline (if one exists)?
03:30:07 <nanothief> i'm just asking just incase anyone else in here is using windows and has completion working
03:30:31 <paolino> mmhh, I suppose they use cygwin for that
03:32:24 <Cale> I think they build GHC with mingw
03:35:38 <paolino> A  line oriented editor can go on hackageDB ?
03:36:26 <quicksilver> anything written in haskell is welcome in hackage
03:36:28 <quicksilver> I believe.
03:36:30 <hpaste>  dancor pasted "seeOther has openFile error?" at http://hpaste.org/5392
03:37:52 <paolino> quicksilver , can I have a darc space for it ?
03:39:34 <paolino> or there is a bot pulling every now and then ?
03:39:53 <quicksilver> paolino: hackage doesn't actually host files, I don't think
03:39:57 <quicksilver> it just records them?
03:39:59 <quicksilver> I'm not sure
03:40:07 <quicksilver> paolino: you can get darcs space from community.haskell.org
03:40:16 <Cale> Uh, it seems to host files.
03:40:19 <Lemmih> dancor: Hm, that shouldn't happen.
03:40:23 <quicksilver> oh
03:40:45 <Cale> At least, when I uploaded my package, that's all I did :)
03:41:30 <quicksilver> I stand corrected
03:41:31 <quicksilver> :)
03:43:48 * jedbrown wonders if polymorphicity is a word.
03:46:09 <znutar> sounds like a nice place to live
03:46:17 <tuukkah> gwern, what's your problem with darcs get http://antti-juhani.kaijanaho.fi/darcs/fenfire-hs
03:46:18 <lambdabot> Title: Index of /darcs/fenfire-hs
03:50:15 <dancor> Lemmih: the illegal character there is mysterious
03:50:50 <dancor> Lemmih: i don't have any state, no random _* files
03:51:05 <dancor> i'm not sure what file it could be trying to open
03:51:15 <dancor> maybe i can catch the error for more info
03:51:29 <dancor> ?
03:52:27 <jedbrown> Cale: heh, I did the same with trackerd, but it wouldn't die.  kill -9 as root, and it still wouldn't die, until I discoved the hung apport which had to be killed first.
03:53:51 <dancor> probably not, it's already catch-ing and show-ing the error there
03:53:52 <Cale> jedbrown: I just removed the symlinks to its startup script from rc*.d
03:54:09 <dancor> is there no way to get a line number on this error
03:55:11 <Cale> dancor: if you run your program in ghci-6.8.2, you might be able to :set -fbreak-on-exception and then :trace main
03:55:49 <Cale> and it'll stop when the exception is thrown, you can use :list to (maybe) list the code around the current point, and :back to back up a bit.
03:56:36 <Cale> I'm not sure how well that works with code from other packages though.
03:57:13 <resiak> hmm.  some hackage packages have documentation links for their exposed modules.  what causes that to be generated and linked to ?
03:57:17 <jedbrown> Cale: chmod -x /etc/init.d/apport works too.  It was annoying though.
03:57:25 <dancor> :list gave "unable to list source for <exception thrown>" and :back gave "no more logged breakpoints"
03:57:30 <Cale> resiak: having a new enough version of Haddock
03:58:00 <paolino> http://photography.nationalgeographic.com/photography/enlarge/swarm-bots-belgium_pod_image.html
03:58:01 <lambdabot> Title: Belgium, Swarm-Bots, Photo of the Day, Picture, Photography, Wallpapers - Nation ..., http://tinyurl.com/2kw4tk
03:58:02 <Cale> dancor: That's pretty much optimally bad.
03:58:09 <wolverian> er, the yi0.3 release doesn't even configure here -- Setup.hs doesn't type
03:58:27 <resiak> Cale: on my local system ?
03:58:44 <wolverian> is my Distribution.Simple too old, or so? this is 6.8.2
03:58:51 <Cale> resiak: On the system where the documentation was generated.
03:59:24 <Cale> wolverian: Well, I got that far at least with 6.8.2
04:00:33 <resiak> Cale: hrm, okay
04:00:40 <hpaste>  wolverian pasted "yi0.3 configure failure on ghc6.8.2" at http://hpaste.org/5393
04:01:16 <Cale> wolverian: ghc-pkg list Cabal
04:01:17 <Cale> ?
04:01:37 <jedbrown> wolverian: I had the same problem, I did fix it though.
04:01:37 <wolverian> ah. I have a local Cabal 1.3.3
04:01:47 <wolverian> the system Cabal is 1.2.3.0
04:01:57 <wolverian> jedbrown, how? :)
04:02:01 <wolverian> (by fixing the errors? ;)
04:02:13 <Cale> Well, Setup.hs at least builds under 1.2.3.0
04:02:33 <jedbrown> wolverian: Yeah.  But I have some vty/bytestring issue, so I still can't build yi.
04:02:59 <Cale> That'd be the issue I'm stuck on. I know how to fix it, but can't be bothered.
04:03:13 <doserj> wolverian: you could simply hide your local Cabal for the time of building yi
04:03:40 <Cale> The solution is to get the old bytestring which it wants, and then build vty and possibly other dependencies against that.
04:03:44 <wolverian> doserj, yeah.
04:03:48 <hpaste>  jedbrown annotated "yi0.3 configure failure on ghc6.8.2" with "fix" at http://hpaste.org/5393#a1
04:03:50 <wolverian> Cale, oh. meh.
04:04:03 <Cale> That, or recompile ghc with the newer bytestring, which is even more painful.
04:05:04 <wolverian> jedbrown, er, isn't that a bit awkward, how it specifies that it needs cabal 1.2.3.0, but the Setup.hs is run before that check is done?
04:05:18 * wolverian frowns at cabal
04:05:55 <Cale> The trouble is that it uses the ghc-api at some point, which in turn uses bytestring-0.9.0.1, so its other dependencies need bytestring-0.9.0.1 as well.
04:06:02 <jedbrown> wolverian: heh, yeah.  Circular bug.
04:06:17 <wolverian> Cale, I have that bytestring. would it build for me, then?
04:06:29 <Cale> 0.9.0.1? Yeah, it should work out.
04:06:40 <wolverian> yes. okay, thanks, maybe I'll try later, with jedbrown's fix.
04:07:09 <jedbrown> Can you specify an older version, other than editing the .cabal to require an exect version?
04:07:15 <wolverian> jedbrown, using the cabal tool would allow one to catch it
04:07:36 <wolverian> so I guess the architecture isn't broken
04:07:38 <Cale> I wonder if there's a way to tell cabal: "Get me this specific version of blah, and recompile all the dependencies of blah against that version."
04:07:40 <wolverian> just incomplete at this moment :)
04:08:18 <pitecus> Why isnt it possible to derive instances for GADTs?
04:08:21 <dancor> why doesn't hasktags have -R
04:08:28 <Cale> It would generally be pretty nice if Cabal kept track of the versions of things which various installed packages were compiled against.
04:08:36 <jedbrown> Cale: We need a Nix-style repository to keep multiple versions of the same lib built against different dependencies.
04:09:14 <Cale> jedbrown: I'd be happy if there were just an automated way to ensure that everything was consistent.
04:09:32 <jedbrown> Cale: i.e. append a hash of the dependency versions to the directory name.
04:09:37 <doserj> or one could fix the problem in ghc
04:10:05 <dcoutts_> Cale: see http://hackage.haskell.org/trac/hackage/ticket/220
04:10:06 <lambdabot> Title: #220 (detect inconsistent package dependencies) - Hackage - Trac
04:10:41 <dcoutts_> part of the problem is that it is currently impractically slow to find the deps of all packages
04:10:52 <dcoutts_> because you'd have to call ghc-pkg describe for every package
04:11:07 <dcoutts_> I tested that on one box and it took ~4 minutes
04:11:17 <jedbrown> dcoutts_: Couldn't you call that once and cache the results?
04:11:32 <dcoutts_> jedbrown: yes, but you'd have to do it at configure time
04:11:45 <dcoutts_> admittedly it was a slow 500 Mhz sparc and I had >50 registered packages
04:11:54 <dcoutts_> but still, it's not acceptable yet
04:12:16 <dcoutts_> ghc-6.8.3 should have an extension to ghc-pkg to output all the packages in one go
04:12:49 <dcoutts_> that should only take a second or so (which is still rather slow)
04:13:47 <Cale> Here, it takes 20 seconds.
04:13:58 <Cale> that is, time (ghc-pkg --simple-output list | sed 's/ /\n/g' | sed 's/^/ghc-pkg describe /' | sh)
04:14:44 <dcoutts_> Cale: right, you've got fewer packages and a faster machine :-)
04:14:47 <Cale> :)
04:14:53 <dcoutts_> but still, 20 sec to configure is not good
04:15:29 <Cale> There ought to be a way to make more complex queries using ghc-pkg, or else whatever underlying API it's using should be better exposed.
04:15:40 <dcoutts_> that should be in 6.8.3
04:15:50 <dcoutts_> you can do wildcard queries
04:16:01 <jedbrown> dcoutts_: We may also need a GC for stale packages.
04:16:30 <Cale> Where is ghc-pkg getting its information?
04:16:34 <dcoutts_> but Cabal doesn't need any of that, just getting all the package info is enough, then it can do whatever queries it likes without having to ask ghc-pkg again
04:16:49 <dcoutts_> Cale: from a file or a dir of files
04:17:02 <dcoutts_> but we cannot go directly, it's not a public api
04:17:45 <dcoutts_> jedbrown: that's tricky because we do not know what packages are needed
04:18:08 <dcoutts_> Jedai: because we cannot track what non-packaged progs/scripts you have that use some package
04:18:08 <Cale> If it were just exposed in the GHC API, then you wouldn't need ghc-pkg to get much fancier.
04:18:26 <dcoutts_> Cale: but Cabal cannot use the ghc api
04:18:32 <Cale> hmm
04:18:39 <dancor> Lemmih: there are only two un-commented-out openFile's in happs source, and i put debug printing around them which never showed up
04:18:47 <jedbrown> dcoutts_: Yeah, but don't you cabalize everything useful on your machine?
04:18:59 <dcoutts_> otherwise we could not build with hugs/nhc/jhc and we'd have a circular dep between ghc package and Cabal package
04:19:05 <dancor> so i guess it's in occurring in something else that happs imports
04:19:14 <Cale> oh, right, other implementations :)
04:19:18 <Cale> heh
04:19:24 <dcoutts_> jedbrown: I don't think everyone dose
04:20:23 <jedbrown> dcoutts_: I find it much easier than running ghc any time I've got something more than one file.
04:21:06 <jedbrown> dcoutts_: Having a command for GC would still be useful.
04:21:32 <dcoutts_> jedbrown: but what would the roots of the GC be?
04:21:44 <dcoutts_> what are the top level ones we assume to be still used?
04:21:45 <jedbrown> dcoutts_: If there is a newer version of the same package and no currently installed packages depend on the old version, then remove it.
04:22:09 <jedbrown> dcoutts_: That is, start with the newest installed version of each package.
04:22:17 <dcoutts_> hmm, I see
04:22:23 <doserj> dcoutts_: the newest version of packages that were *explicitely* installed
04:22:37 <dcoutts_> doserj: that's the 'world' concept
04:22:55 <dcoutts_> that we have to record what was asked to be installed and what was merely a dep of something else
04:22:57 <jedbrown> doserj: Yes, in a way, we are reproducing apt now.
04:23:24 <dcoutts_> doserj, jedbrown: see http://hackage.haskell.org/trac/hackage/ticket/198
04:23:25 <lambdabot> Title: #198 (outline for revamp of &#34;cabal install&#34; and upgrade behavior) - Hack ...
04:23:40 <dcoutts_> it talks about the 'world' distinction
04:24:37 <jedbrown> dcoutts_: That looks good.
04:25:05 <dcoutts_> hacking help appreciated of course :-)
04:25:11 <jedbrown> I guess since we're building everything locally, this is more like portage than apt :)
04:25:28 <dcoutts_> yes, we've taken a few concepts from gentoo
04:25:45 <dcoutts_> or, at least there are many similarities
04:26:20 <doserj> oh yes, btw. are there thoughts about allowing binary installs using cabal?
04:27:17 <dcoutts_> doserj: not really, everyone who want binaries really wants distro packages it seems
04:27:30 <dcoutts_> there have been very little interest in generic binary packages
04:27:34 <doserj> true
04:27:47 <dcoutts_> doserj: see http://hackage.haskell.org/trac/hackage/ticket/47
04:27:48 <lambdabot> Title: #47 (implement ./setup bdist) - Hackage - Trac
04:28:18 <pitecus> Is there something that will derive Show and Read instances of GADTs for me?
04:28:26 <jedbrown> It would have been a much bigger issue at ghc-6.6 speeds.  Now ghc is fast enough to build most packages very quickly.
04:28:35 <dcoutts_> doserj: note how nobody (except me) has commented on it or argued for it
04:29:39 <dancor> maybe when there are more larger projects
04:29:43 <jedbrown> dcoutts_: Seems like someone (anonymous) thought it was high priority ;P
04:30:00 <dcoutts_> jedbrown: apparently, though didn't say why :-)
04:30:44 <dcoutts_> dancor: but what should the be/do? nobody seems to know
04:30:58 <resiak> do/be/do/be/do
04:31:00 <dcoutts_> what is the use case, how should the work? if you have ideas, comment on that ticket
04:31:04 <jedbrown> dancor: That's certainly relevant.  In the distro world, I'd hate to have to rebuild X11 or the kernel.
04:31:10 <dcoutts_> resiak: quite :-)
04:31:57 <doserj> dcoutts_: how much work is it to transform a typical cabal package into a .deb or .rpm?
04:32:21 <dcoutts_> doserj: there are tools already to do that
04:32:26 <dcoutts_> and gentoo ebuilds
04:32:47 <doserj> good :)
04:35:14 <dancor> dcoutts_: be/do?
04:36:33 <dcoutts_> dancor: I mean what should a binary dist be? how should it behave, what would it do?
04:37:06 <dcoutts_> how would you install one? would it be relocatable?
04:37:17 * dcoutts_ notes that relocatable packages are a can of worms
04:40:18 <quicksilver> dcoutts_: I also am happy to leave binary packages to distro formats
04:40:33 <quicksilver> dcoutts_: be nice if we keep half an eye on those aforementioned tools and make sure they keep working, though :)
04:40:52 <dcoutts_> aye, .deb, .rpm, .ebuild, .msi, .whatever-mac-osx-uses
04:41:11 <dcoutts_> quicksilver: mainly they are not used by end users of course
04:41:13 <jedbrown> At the rate things are moving, the distros are way behind, so keeping current with cabal is important now.
04:41:30 <dcoutts_> jedbrown: right, that's the use case for cabal-install
04:41:39 <quicksilver> the probably with relocatble binaries is finding libraries
04:41:51 <quicksilver> making library locations relocatable is a security bug.
04:41:55 <dcoutts_> jedbrown: eg, gentoo has 60 haskell libs, but hackage has ~300, we can never keep up with that
04:42:01 <quicksilver> which is why Linux distributions have fixed library locations.
04:42:09 <jedbrown> Most pacakages are small, so I don't think binary support is useful yet.  Once it is, perhaps things will have slowed down so that most users are happy with somewhat old packages.
04:42:10 <dcoutts_> and nor should we, distros have higher QA standards, things have to work
04:42:29 <quicksilver> You could do it with wrapper scripts and LD_LOAD_FOO environment variables, but that's a 'Bad Thing(TM)'
04:42:59 <dcoutts_> quicksilver: actually it'd be possible with env vars and the Paths_foo module
04:43:08 <dcoutts_> and a wrapper script around all binaries
04:43:25 <dcoutts_> like a generic version of what ghc does
04:43:55 <dcoutts_> the Paths_foo module is generated by Cabal for packages to be able to find their files at runtime
04:44:02 <scook0> hmm, I have a library with foreign bindings, compiled and installed as a package
04:44:26 <Cale> Sigh. I really dislike Haddock's new Javascript search. It's faster just to scroll through the complete list.
04:44:26 <scook0> if I try to use it via ghci (6.6), parts of it consistently segfault
04:44:45 <scook0> but if I compile a program that uses the library, it works fine
04:44:52 <dcoutts_> Cale: yes, it's appalling, it should be removed
04:44:54 <quicksilver> Cale: I just use the search feature of my browser :) Both firefox and safari have decent page searches
04:44:56 <scook0> is this sort of thing a known issue?
04:45:19 <dcoutts_> Cale: with hoogle there should be no need for the index at all
04:45:34 <quicksilver> scook0: maybe.
04:45:36 <Cale> dcoutts_: removed or else improved to the point where it runs in a decent time frame.
04:45:43 <quicksilver> scook0: could it be the library isn't thread safe?
04:45:55 <quicksilver> scook0: there are various issues with FFI libraries and ghci
04:46:00 <dcoutts_> Cale: or do hoogle in javascript ;-)
04:46:06 <scook0> I didn't think of that angle :/
04:46:13 <quicksilver> scook0: threads, global state, reinitialistion, etc
04:46:25 <quicksilver> dcoutts_ must be aware of some of them because gtk2hs hit some of them.
04:46:31 <scook0> everything has worked fine until this last function binding, though
04:46:42 <scook0> i.e. the new function is the one that faults all the time
04:47:08 <dcoutts_> yes, in ghci we have to be careful to avoid re-initialising some foreign libs multiple times
04:47:49 <scook0> and I was having such fun messing with curses from ghci
04:49:12 <scook0> hmm, marking some of my bindings safe makes ghci complain about unexpected re-entrance
04:49:47 <quicksilver> dcoutts_: just another piece of evidence that global mutable state is a bad idea
04:49:51 <quicksilver> dcoutts_: even in imperative libraries!
04:50:02 <quicksilver> (and to think, people keep suggesting we add it to haskell...)
04:50:24 <dcoutts_> yes, quite
04:50:42 <dcoutts_> ghci :r means loose all previous 'global' bindings
04:50:58 <dcoutts_> yet foreign libs end up with stale global state and then barf
04:51:26 <quicksilver> would it be sensible to ghci :t to dynunload()
04:51:28 <quicksilver> all the libraries?
04:51:35 <quicksilver> and then dynload() them back again when next used?
04:51:40 <quicksilver> (and would that solve it?)
04:51:48 <quicksilver> sorry, :r I meant
04:52:25 <dcoutts_> quicksilver: only if ghci was using it's own linker session and could be assured that it was the only user of the lib
04:52:43 * quicksilver doesn't understand
04:52:47 <quicksilver> who else might be using the lib?
04:52:54 <dcoutts_> whoever is running ghci
04:53:06 <dcoutts_> eg, embedding ghci in an ide etc
04:53:12 <quicksilver> ah well
04:53:16 <quicksilver> that's definitely a different case
04:53:17 <dcoutts_> context :-)
04:53:18 <quicksilver> good point, certainly
04:53:28 <quicksilver> but that's not a very common situation at the moment, is it?
04:53:38 <dcoutts_> quicksilver: not yet
04:53:41 * quicksilver nods
04:53:50 <dcoutts_> partly because of global state problems
04:54:04 * quicksilver thinks this argument just bit itself hard on the tail.
04:54:23 <Zao> quicksilver: A tail recursive argument?
04:55:41 * shapr throws fluffy lambdas around the channel
04:56:19 * matthew_- sneezes due to the fluff
04:56:46 <resiak> perhaps you should breed hypoallergenic lambdas
04:57:18 <opqdonut> :)
04:57:29 <opqdonut> allergic to lambda, wouldn't that be sad
04:57:31 <quicksilver> good idea
04:57:45 <quicksilver> hypoallergenic lambdas might be more polymorphic
04:58:24 <opqdonut> hehe
05:02:29 <resiak> it'd probably be a matter of removing the little round hooks from the tops
05:04:58 * osfameron remembers that hayfever is due in 1-2 months' time and cries
05:12:38 <matthew_-> osfameron: are you in the uk yet?
05:13:19 <osfameron> matthew_-: yup
05:13:28 <Cale> resiak: http://www.haskell.org/haskellwiki/Bracket_pattern  :)
05:13:29 <lambdabot> Title: Bracket pattern - HaskellWiki
05:13:32 <matthew_-> who are you working for - if you're working?
05:13:44 <matthew_-> ^^ -> osfameron
05:14:04 <osfameron> matthew_-: Thermeon, near Gatwick.  Doing perl/web dev mainly
05:14:07 <nominolo> @yo
05:14:07 <lambdabot> I am covered with pure vegetable oil and I am writing a best seller!
05:14:16 <ricky_clarkson> erk
05:14:23 <nominolo> @quote
05:14:24 <lambdabot> Tac-Tics says: oerjan: I tried, but his zombie lectures were hard to follow
05:14:31 <Cale> resiak: (You should recognise some of that code :)
05:14:37 <resiak> Cale: yes, yes I do :-)
05:15:41 <nominolo> @quote metameta
05:15:41 <lambdabot> dmhouse says: Nice, metametastereo quotes. I wonder how far it'll go.
05:15:57 <nominolo> is there a quote that this refers to?
05:17:25 <quicksilver> the rabbit hole goes all the way down
05:17:51 <oerjan> @quote meta-stereo
05:17:52 <lambdabot> No quotes match.
05:17:57 <oerjan> @quote metastereo
05:17:57 <lambdabot> dmhouse says: Nice, metametastereo quotes. I wonder how far it'll go.
05:18:06 <oerjan> @quote [^a]metastereo
05:18:07 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
05:18:15 <Cale> Heh, my valency's gone way down, but I'm still in the middle :)
05:18:32 <shapr> Valency?
05:18:37 <Cale> http://files.codersbase.com/haskell/haskell-current.png
05:19:31 <Cale> shapr: It displays a graph of who has been talking to who, using various heuristics. The edges decay over time.
05:19:52 <oerjan> hm the decay has been slowed down greatly?
05:19:57 <Cale> yeah
05:20:12 <jedbrown> Cale: does this make you happier? http://files.codersbase.com/haskell-logs/haskell-current.png
05:20:17 <nominolo> clusters, that's bad
05:21:01 <Cale> jedbrown: heh, that's pretty awesome. That's with the whole log?
05:21:42 <jedbrown> Cale: I think it's just from Jan 27, since my topology conversation is still strong.
05:22:27 <Cale> jedbrown: I still don't prefix my messages with their recipient enough :)
05:23:19 <nominolo> you can also postfix, Cale
05:23:46 <int-e> jedbrown: that's silly.
05:24:01 <shapr> Cale: Ah, I see.
05:24:14 * jedbrown predicts that out of modesty, #haskell will stop naming recipients entirely.
05:27:16 <quicksilver> jedbrown, Cale : yes, that's a weekend day definitely, that's why I'm scarcely in it :)
05:27:23 <quicksilver> 27th was a weekend so that's consistent.
05:28:31 <pejo> jedbrown, so I have 3 lines. What does that tell me, I only spoke to 3 people?
05:29:07 <quicksilver> that it only noticed you speaking to 3 people
05:29:12 <quicksilver> or that older conversations had decayed
05:42:41 <paolino> ahi, a bug in readline/ghci
05:45:57 <paolino> can anyone try to complete "inside" a readline call from ghci ?
05:47:49 <paolino> eh, it kills ghci leaving me in a shell with no character echoing
05:48:37 <litb> bad thing
05:49:14 <litb> paolino: doesn't for me
05:51:17 <paolino> litb: you loaded System.Console.Readline and issued  readline "something" and tried to complete ?
05:51:30 <litb> oh i see
05:51:46 <litb> no i tried doing "something<TAB>" o.O
05:53:03 <paolino> this thing that the same readline instance is used is somewhat a problem to test code using readline lib
05:53:21 <litb> yeah it crashes paolino
05:54:59 <Karlo>  Best girls in the world - http://lostworlds.lv/go.php?1139655440
05:55:46 <matthew_-> you've implemented Ord on girls?
05:56:17 <matthew_-> is it a partial ordering or total?
05:56:24 --- mode: ChanServ set +o quicksilver
05:56:32 --- mode: quicksilver set +b *!*n=karlo@85.234.164.*
05:56:32 --- kick: Karlo was kicked by quicksilver (quicksilver)
05:57:20 <paolino> also I don't understand how to use most of the readline wrappers, because the don't doc flag is on them
05:57:33 <quicksilver> sounds like readline  might not be re-entrant
05:57:39 <quicksilver> btu I can't make a useful suggestion on how to fix that.
05:57:53 --- mode: quicksilver set -o quicksilver
05:59:55 <quicksilver> Ah, he got K-lined shortly after.
06:01:00 <paolino> quicksilver, you know how I program completion on for readline
06:01:02 <paolino> ?
06:01:32 <cnwdup> @src when
06:01:32 <lambdabot> when p s = if p then s else return ()
06:02:06 <cnwdup> How can I lookup which module contains definition of when?
06:02:17 <paolino> ;info
06:02:24 <cnwdup> @info when
06:02:24 <lambdabot> when
06:02:42 <cnwdup> Heh, you weren't refering to me, were you? ^-^
06:02:42 <oerjan> @index when
06:02:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:02:47 <cnwdup> Thanks, oerjan.
06:02:58 <quicksilver> paolino: no, I've never tried, sorry
06:03:43 <davidL> @help info
06:03:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:03:58 <oerjan>  @info = @undo, spell corrected
06:04:15 <davidL> ah
06:06:52 <paolino> haskell base libraries should implement the (docs -> tests -> code ) paradigma sooner or later ..
06:07:49 <moonlite> baseParadigm :: Docs -> Tests -> Code
06:07:56 <moonlite> hrmm
06:09:41 <slarba_> TDD seems to be over-hyped
06:10:04 <shapr> I've had great benefits from TDD myself.
06:11:23 <idnar> TDD isn't a silver bullet, but I think tests are pretty important, especially over time, and TDD helps a lot with making sure that your code is testable, and that your tests are correct
06:11:32 <slarba_> I'm not saying it does not work :)
06:11:45 <quicksilver> TDD is excellent for code which suits it
06:11:53 <idnar> but I guess I can't disagree with saying that it's "over-hyped"
06:11:56 <slarba_> but the number of tests is more important than tests first
06:12:00 <quicksilver> if your problem domain happens to consist of nice little pieces which are easy to test
06:12:08 <quicksilver> then TDD is a great way to code
06:15:19 <Cin> @info TDD
06:15:19 <lambdabot> TDD
06:15:21 <cnwdup> @index forall
06:15:22 <lambdabot> bzzt
06:15:26 <Cin> heh, thanks, lambdabot
06:15:59 <Lemmih> Cin: Test Driven Development.
06:16:11 <vincenz> @google TDD
06:16:12 <lambdabot> http://en.wikipedia.org/wiki/Test-driven_development
06:16:12 <lambdabot> Title: Test-driven development - Wikipedia, the free encyclopedia
06:16:16 <vincenz> not that hard, raelly
06:16:25 <oerjan> cnwdup: forall is an extension keyword
06:16:59 <Cin> just woke up, break, give it, etc
06:17:20 <cnwdup> ok
06:18:31 <slarba_> does anyone write negative tests too when doing test-driven programming?
06:18:33 <Cin> vincenz: arc in haskell; what's the status? :D
06:18:34 <slarba_> :)
06:19:51 <paolino> I would focus on docs also , docs are tests for tests
06:21:01 <Feuerbach> where can I read about "~"?
06:21:11 <Cin> :t (~)
06:21:13 <lambdabot> parse error on input `)'
06:21:16 <Cin> <_<
06:21:19 <quicksilver> Feuerbach: in the haskell report, although it's fairly brief.
06:21:23 <vincenz> Cin: ask ehird
06:21:38 <Cin> vincenz: seems we're in opposite sleeping patterns v_v
06:21:56 <quicksilver> Feuerbach: there seems to be a reasonable description in http://www.haskell.org/tutorial/patterns.html
06:21:56 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
06:24:56 <Feuerbach> quicksilver: I've got it, thanks
06:26:58 <Feuerbach> also I wonder, when people say "_|_", is it just convention (for undefined, I guess), or valid Haskell syntax?
06:28:08 <allbery_b> convention
06:28:25 <quicksilver> there is no haskell syntax for precisely that concept
06:28:28 <quicksilver> which is why people use it
06:28:36 <oerjan> it's ascii for an upside-down T, the mathematical symbol for it in denotational semantics
06:28:39 <quicksilver> 'undefined' is an example of _|_
06:28:41 <allbery_b> bottom is, more or less by definition, not explicitly representable in Haskell (or any other language)
06:28:49 <quicksilver> but it's not the only example.
06:29:02 <quicksilver> it's a semantic rather than syntactic concept after all
06:29:12 <quicksilver> let a = a in a
06:29:17 <quicksilver> is another example
06:31:47 <Blizzy> Hellow fellow ignorant Pedophiles, have any child porn to share today?
06:32:08 <sclv> @where mods
06:32:08 <lambdabot> I know nothing about mods.
06:32:14 <sclv> @where ops
06:32:14 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
06:32:38 <Blizzy> Hellow fellow ignorant Pedophiles, have any child porn to share today?
06:33:04 <pejo> quicksilver, busy day for you today.
06:33:08 --- mode: ChanServ set +o Igloo
06:33:29 --- mode: Igloo set +b *!*@gateway/tor/x-e6c7442fee77cf15
06:33:34 --- kick: Blizzy was kicked by Igloo (Igloo)
06:33:44 <Igloo> Thanks sclv
06:34:03 <sclv> my pleasure. :-)
06:34:05 * quicksilver = tooslow
06:34:33 * dcoutts_ is also too slow
06:40:58 <quicksilver> Do network services get alerted when someone gets kicked from several channels?
06:41:15 <quicksilver> because the freenode ircops always seem to K-line/kill people just after we do :)
06:42:23 <oerjan> well, unless they are very clever they probably hit at least one channel where an ircop is present, you'd think...
06:43:01 <quicksilver> I believe they hit the channels with the most users
06:43:05 <quicksilver> that's why we always get them.
06:43:52 <oerjan> @users
06:43:52 <lambdabot> Maximum users seen in #haskell: 463, currently: 435 (94.0%), active: 19 (4.4%)
06:44:48 <cnwdup> @index isDirectory
06:44:48 <lambdabot> System.Posix.Files, System.Posix
06:56:58 <jedbrown> Should GHC be able to figure out when it will not terminate?
06:57:19 <oerjan> when what will not terminate?
06:57:31 <jedbrown> compilation
06:57:40 <oerjan> @faq Can Haskell solve the halting problem?
06:57:40 <lambdabot> The answer is: Yes! Haskell can do that.
06:57:43 <ricky_clarkson> Haskell compilation terminates.
06:58:00 <jedbrown> ricky_clarkson: When I kill it, yes.
06:58:20 <cjb> You don't have to solve the halting problem to implement a "hey, I've been compiling this file for ten minutes, maybe something's up with that" heuristic :)
06:58:24 <oerjan> jedbrown: what extensions are you using?
06:58:37 <jedbrown> I messed up the type signature for a function and ghc would never finish.
06:58:39 <ricky_clarkson> I thought without dependent types, compilation was guaranteed to terminate.
06:58:43 <jedbrown> oerjan: A whole stack.
06:58:50 <oerjan> ah
06:58:57 <sclv> > let willHalt = const . const $ True in willHalt (fix (1:)) 1
06:58:58 <lambdabot>  True
06:59:03 <hpaste>  jedbrown pasted "compiler _|_" at http://hpaste.org/5394
06:59:49 <oerjan> UndecidableInstances turns off the usual termination checks, doesn't it
07:00:19 <quicksilver> Ys
07:00:30 <quicksilver> those instances flags are known to make the compiler non-terminating
07:00:35 <jedbrown> That may be, but I need those so I can deconstruct arbitrary tuples.
07:00:36 <BMeph> ?faq Can Haskell offer a solution to the problems in the Middle East?
07:00:36 <lambdabot> The answer is: Yes! Haskell can do that.
07:01:21 <cnwdup> ?faq Can Haskell fake ?faq commands?
07:01:21 <lambdabot> The answer is: Yes! Haskell can do that.
07:01:53 <Cin> i love the ?faq
07:02:03 <quicksilver> jedbrown: Right. THe option exists precisely because people find it useful.
07:02:08 <BMeph> ?faq Can Haskell really "put a chicken in every pot"?
07:02:08 <lambdabot> The answer is: Yes! Haskell can do that.
07:02:16 <quicksilver> jedbrown: but non-terminating compilation is a known side effect
07:02:33 <BMeph> Heh-heh. Lambdas RULE. ;p
07:02:33 <quicksilver> I suspect it's more harm than good, personally :)
07:02:41 <quicksilver> I don't believe in overlapping or undecidable instances.
07:02:46 <jedbrown> quicksilver: That's okay, I just found it really strange in this case.
07:03:25 <quicksilver> it's possible that that non-termination is actually a bug
07:03:29 <quicksilver> rather than expected.
07:03:37 <quicksilver> but my brain will explode if I try to understand.
07:03:37 <nominolo> :t traverse
07:03:38 <lambdabot> Not in scope: `traverse'
07:03:44 <nominolo> er...
07:03:50 <quicksilver> You could submit a bug for it and see what the smart guys thing :)
07:03:56 <oerjan> jedbrown: IncoherentInstances is also a LANGUAGE option (do you really need it?)
07:03:57 <jedbrown> quicksilver: I want to treat arbitrary Ix as multi-dimensional when it makes sense.
07:04:05 <quicksilver> :t Data.Traversable.traverse
07:04:06 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:04:11 * BMeph gets a net, in case something Hellish starts flying from quicksilver's nostrils...
07:04:25 <quicksilver> nominolo: that little family of modules is not imported by default.
07:04:38 <quicksilver> nominolo: because of overlaps with mapM and so on.
07:04:41 <nominolo> @instances Foldable
07:04:42 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
07:04:47 <nominolo> i see
07:04:53 <jedbrown> oerjan: Oh, it looks like I don't any more.
07:06:05 <litb> hey, did anyone finally found that fib number ?
07:06:21 <oerjan> someone lost a fib number?
07:06:23 <litb> where you have pandigital numbers 1-9 at the front and at the back?
07:06:27 <davidL> yeah, mauke found it with bruteforce, then I eventually found it :P
07:06:55 <litb> they say that one could find it within one minute
07:07:05 <davidL> yeah I'm working on that now
07:07:25 <davidL> my brute force took over 10 minutes :-\
07:07:25 <nominolo> can't you somehow generate fib numbers by exponentiating the golden ratio or sth?
07:07:52 <quicksilver> nominolo: yes.
07:08:02 <oerjan> nominolo: yes, or using matrix exponentiation
07:08:15 <davidL> > let lfibs = 0 : 1 : zipWith (\x y -> mod (x+y) (10^9)) lfibs (tail lfibs) in lfibs !! 541 -- to get the last 9 digits
07:08:16 <lambdabot>  839725641
07:08:17 <jedbrown> nominolo: http://haskell.org/haskellwiki/The_Fibonacci_sequence
07:08:22 <oerjan> (actually a 2-tuple is enough)
07:08:25 <nominolo> ok.  i have te get my Knuth out again
07:08:56 <jedbrown> quicksilver: I would actually love to do fix-length vectors in the type system as the index.  It would be much cleaner, but alas, it is not how IArray works.
07:09:05 <davidL> how can I test if a number is pandigital without converting to a string, maybe something neat with testBit?
07:09:05 <litb> http://upload.wikimedia.org/math/3/b/d/3bd3f5985b5b3faf0734b75af61b5a79.png
07:09:06 <lambdabot> http://tinyurl.com/35ktms
07:09:41 <oerjan> davidL: not in base 10
07:10:33 <jedbrown> quicksilver: Being compatible with IArray has lots of advantages.  Also, UArray is lots faster for operations within Haskell, since my version is based on ForeignPtr.
07:10:47 <nominolo> jedbrown: didn't oleg do safe array indexing in the lightweight static capabilities paper?
07:10:59 <jedbrown> quicksilver: But the point of my lib is to interface well with external libraries.
07:11:20 <jedbrown> nominolo: I'm not interested in safe indexing, I'm interested in multi-dimensional arrays.
07:11:51 <litb> maybe the key in finding that number is to skip some fib numbers to get to the next pandigital one
07:12:37 <oerjan> > product[1..10] / 10^9
07:12:38 <lambdabot>  3.6288e-3
07:13:30 <yrlnry> nominolo: if you only want the nth, matrix exponentiation is the way to go.  calculating powers of the golden ratio requires high-precision floating-point arithmetic.
07:13:41 <quicksilver> jedbrown: Yes. I don't actually know what you're doing. But I'd use TH or Data.Derive to write instances for arbitrary length tuples.
07:13:51 <quicksilver> jedbrown: in preferences to undecidable instances.
07:13:56 <davidL> this seems like a bottleneck: pandigital = (['1'..'9'] ==) . sort . show
07:14:45 <quicksilver> yrlnry: surely not?
07:14:53 <nominolo> yrlnry: yeah.  i didn't know about that matrix multiplication scheme
07:14:57 <jedbrown> quicksilver: The thing is, I've got instance (Ix i, Ix j) => Shapable (i,j) where ...
07:15:10 <quicksilver> yrlnry: surely it just requires an algorithm for working in exact numbers Q[sqrt(5)]
07:15:17 <quicksilver> yrlnry: or such like.
07:15:17 <jedbrown> quicksilver: But I also need to handle the 1-dimensional case.  Hence the overlap.
07:15:34 <yrlnry> quicksilver: yes, and if you eliminate the cruft from such an algorithm, when you have left is exactly the matrix exponentiation thing.
07:16:10 <yrlnry> with one column of the matrix representing the a and the other the b in a + b*sqrt(5).
07:16:28 <quicksilver> yrlnry: true enough. But to my mind, Q[sqrt(5)] is a much simpler concept than matrices.
07:16:42 * yrlnry shrugs.
07:18:42 <yrlnry> nominolo: http://plover.com:8080/~mjd/misc/math/fibonacci explains the matrix thing in some detail
07:19:00 <yrlnry> probably too much detail, but it was written for an audience with rather little math background.
07:20:50 <litb> davidL: well, such a num is divisible by 9 . i don't know whether that is valuable tho
07:21:53 <litb> davidL: maybe you could make some hash out of them that  does not take the order into account
07:21:55 <BMeph> litb, davidL: It makes for a cheaper test for the pandigital at the low end.
07:21:56 <davidL> litb: I suppose I could just take the sum and the product of the digits and see if they equal 45 and 362880, respectively
07:22:02 <Taejo> any reason for the SA Computer Olympiad to use GHC 6.6.x rather than GHC 6.8.2?
07:22:57 <Taejo> and, on Gentoo, any reason to install ghc over ghc-bin
07:22:58 <Taejo> ?
07:23:20 <scriptdevil> Taejo: optimization
07:23:37 <davidL> > (sum [1..9], product [1..9])
07:23:39 <lambdabot>  (45,362880)
07:24:05 <Taejo> scriptdevil: of the generated code, or the compiler itself?
07:24:11 <oerjan> davidL: you might want to exclude that 0 digit :)
07:24:18 <BMeph> Taejo: Probably, that's what they had when they sta rted, so they want consistency and reprodicible results more than the speed gains.
07:24:33 <yrlnry> Oh, whether fib(n) is a multiple of 9 is a rather simple function of n.
07:24:34 <litb> davidL: would that mean it is pandigital?
07:24:36 <scriptdevil> is there a way to read more than one data on the same line.. I understand you cant do it with getLine
07:24:57 <davidL> litb: I would imagine
07:25:25 <nominolo> hm, when i want to have backtracking i shouldn't use ErrorT .. State .. but rather ContT .. State, right?
07:25:27 <scriptdevil> Taejo: Gentoo is a source based distro. Though the excellent emerge can install bin packages, use flags are usableonly with source
07:25:53 <davidL> are there any cases where the sum of the digits is 45 and the product of the digits is 362880 and isn't pandigital 1-9?
07:25:57 <quicksilver> nominolo: do you want the state to backtrack, or not?
07:26:07 <nominolo> quicksilver: yes
07:26:12 <Taejo> BMeph: "they" is me... I'm setting up a new server, and thought I might upgrade to 6.8 while I'm at it
07:26:15 <quicksilver> nominolo: then you want StateT ... Cont
07:26:19 <quicksilver> nominolo: not ContT ... State
07:26:20 <quicksilver> ;)
07:26:30 <nominolo> ok
07:26:34 <oerjan> davidL: perhaps some bit twiddling would be faster? 511 == foldl' (.|.) 0 . shiftL ...
07:26:39 <quicksilver> nominolo: ContT can't backtrack effects "inside" it
07:26:41 <scriptdevil> !read
07:26:44 <quicksilver> nominolo: but it can those "outside" it
07:26:46 <scriptdevil> > :t read
07:26:47 <lambdabot>   parse error on input `:'
07:26:55 <nominolo> quicksilver: good to know
07:26:57 <BMeph> Taejo: You can try, but the 6.8 API made a lot of modules break and cry.
07:26:58 <quicksilver> nominolo: they way I remember which way round it is, is that ContT IO can't backtrack IO effects.
07:27:07 <quicksilver> nominolo: which is kind of obvious, because that would be a time machine.
07:27:18 <nominolo> what's wrong about that ;)
07:27:49 <scriptdevil> well... sorry for repeating my question .. but is there a way to read multiple data from the same line like 44 123 31 on a single line of stdin
07:28:00 <BMeph> "When we get this GHC up to 88 mph, you're gonna see some serious shit." ;p
07:28:02 <Taejo> BMeph: I'll probably stick with 6.6 for now, then
07:28:07 <davidL> oerjan: what is 511?
07:28:29 <BMeph> davidL In base 2, it's 111111111
07:28:51 <quicksilver> scriptdevil: yes, there are a dozen ways
07:29:03 <oerjan> davidL: 2^9-1
07:29:09 <quicksilver> > map read . words $ "44 123 31" :: [Int]
07:29:10 <lambdabot>  [44,123,31]
07:29:10 <jedbrown> scriptdevil: readLine gives you a string.  To parse that, you can use read, or Parsec if it is complicated.
07:29:15 <nominolo> scriptdevil: in parsec: number `sepBy` space
07:29:21 <davidL> > showIntAtBase 2 intToDigit 511 ""
07:29:22 <lambdabot>  "111111111"
07:29:28 <quicksilver> scriptdevil: there is one simple way using read
07:29:34 <scriptdevil> thanks
07:29:34 <scriptdevil> :D
07:29:49 <nominolo> scriptdevil: this is not homework, is it?
07:29:59 <scriptdevil> no. I am learning haskell out of interest
07:30:06 <nominolo> ok
07:30:30 <nominolo> otherwise, we'd have to give a different kind of answer ;)
07:31:02 <scriptdevil> lol.. no if i did have a homework, i wouldnt ask :)
07:31:11 <scriptdevil> i couldnt google the right words
07:32:46 <nominolo> scriptdevil: no, you could ask: http://www.haskell.org/haskellwiki/Homework_help
07:32:47 <lambdabot> Title: Homework help - HaskellWiki
07:34:42 <oerjan> :t shiftL
07:34:43 <lambdabot> forall a. (Bits a) => a -> Int -> a
07:34:47 <scriptdevil> thanks. I wont be needing it at the moment. I am learning haskell out of interest. Just got past the 4th chapter of YAHT and suddenly this question popped up in my mind
07:35:23 <davidL> oerjan: sorry, I don't how that could be used to test if a number is pandigital
07:35:45 <davidL> or, wait
07:36:00 <oerjan> > foldl' (.|.) 0 . map (shiftL 1 . digitToInt) $ "1357924680"
07:36:01 <lambdabot>  Add a type signature
07:36:07 <oerjan> > foldl' (.|.) 0 . map (shiftL 1 . digitToInt) $ "1357924680" :: Int
07:36:07 <lambdabot>  1023
07:36:22 <yrlnry> What is (.|.) ?
07:36:23 <oerjan> i forgot the 0 place
07:36:28 <oerjan> bitwise or
07:36:33 <yrlnry> Thanks.
07:37:31 <oerjan> > foldl' (.|.) 0 . map (shiftL 1 . digitToInt) $ "135792468" :: Int
07:37:32 <lambdabot>  1022
07:37:36 <davidL> I see, I suppose that is faster than doing the sum and product
07:38:01 <quicksilver> I can't imagine either being faster than sort & compare.
07:38:06 <yrlnry> > 10 .|. 3
07:38:06 <lambdabot>  Add a type signature
07:38:19 <yrlnry> > (10 .|. 3) :: Integer
07:38:19 <lambdabot>  11
07:38:31 <litb> > foldl' (.|.) 0 . map (shiftL 1 . digitToInt) $ "135792486" :: Int
07:38:32 <yrlnry> > (10 .&. 3) :: Integer
07:38:32 <lambdabot>  1022
07:38:33 <lambdabot>  2
07:38:38 <litb> uh
07:38:46 <quicksilver> the .|. one isn't reliable either.
07:39:06 <oerjan> quicksilver: how so?
07:39:14 <quicksilver> > foldl' (.|.) 0 . map (shiftL 1 . digitToInt) $ "1357924680"
07:39:14 <lambdabot>  Add a type signature
07:39:24 <quicksilver> > foldl' (.|.) 0 . map (shiftL 1 . digitToInt) $ "1357925680" :: Int
07:39:25 <lambdabot>  1007
07:39:32 <quicksilver> > foldl' (.|.) 0 . map (shiftL 1 . digitToInt) $ "1357924680" :: Int
07:39:33 <lambdabot>  1023
07:39:37 <quicksilver> oh, hmm
07:39:54 * quicksilver looks at the code more carefully
07:39:56 <quicksilver> of course it is.
07:40:15 <quicksilver> still I"d be surprised if it was faster than comparing the list :)
07:41:20 <davidL> > (['1'..'9']==) . sort . show $ 135792468
07:41:21 <lambdabot>  True
07:42:09 <nominolo> nice: http://www.haskell.org/pipermail/haskell-cafe/2008-February/038985.html
07:42:09 <lambdabot> Title: [Haskell-cafe] Who started 42, and when?, http://tinyurl.com/2eqzrk
07:42:26 <masklinn> "
07:42:56 <quicksilver> I feel sorry for the OP
07:43:09 <quicksilver> (almost) all the answerers treat him like an idiot who doesn't know what 42 means.
07:43:19 <quicksilver> whereas he made it perfectly clear that he does
07:43:29 <quicksilver> he was just wondering how far back the tradition of using it in papers goes.
07:43:42 <oerjan> > foldl' (.|.) 0 . map (shiftL 1) . take 9 . unfoldr (Just . (snd &&& fst) . flip divMod 10) $  135792468 :: Int
07:43:43 <lambdabot>  1022
07:44:24 <davidL> do you think that is faster than show?
07:44:59 <oerjan> who knows
07:45:01 <nominolo> quicksilver: i meant that particular answer
07:45:16 <oerjan> it avoids a conversion
07:45:52 <quicksilver> it's probably rather similar to show
07:45:57 <quicksilver> but yes, it's avoiding a conversion
07:46:00 <quicksilver> it ought to be faster.
07:46:11 <nominolo> avoiding conversation is a good thing, of course
07:46:23 <quicksilver> on the other hand, it's building tuples which might not be deforested
07:46:30 <quicksilver> so that might be just as bad tas the conversion.
07:46:32 <quicksilver> who knows.
07:48:31 <Baughn> @hoogle mvar
07:48:31 <lambdabot> Control.Concurrent.MVar :: module
07:48:31 <lambdabot> GHC.Conc.MVar :: data MVar a
07:48:31 <lambdabot> Control.Concurrent.MVar.MVar :: data MVar a
07:48:37 <paolino> pühtreeeee
07:49:07 <paolino>             --,0-ßßß000ß0ß0ß0´00üüüüüüüüüüüüüüß-ü-ü-ü-ü-ü-ü-ü--ü-ü-ü-ü-ü-ü--ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü-ü--ü-ü-ü--ü-ü-ü-ü--------------------3200
07:49:44 <paolino> 0000000000000000+0000000000000000+0000000+0+0+0+0+0+,+00++0+0+0+0+0+0+00+0+0+0+0+0+0+0+0+0+00+0+0+0+0+0+00000000+++0+0+0+0++0+00++0+0+0+0+0+0+0++0+0+0+0+0+0+0+0+0+000+0+0+,0+0+0 +, , + + +0 +0+0 0+ 0 +20+220 +
07:49:45 <paolino> ,0000
07:49:46 <paolino> 0
07:49:46 <paolino> 0
07:49:49 <paolino> #0#0#0#0äü0ß0*9*rvürrär#r
07:49:52 <paolino> #r#r'rRRrrrrrrr
07:49:53 <paolino> rrrr
07:49:53 <paolino> r
07:49:53 <paolino> r
07:49:54 <paolino> r
07:49:55 <paolino> r
07:49:57 <paolino> r
07:49:59 <paolino> r
07:50:01 <paolino> r
07:50:03 <paolino> r
07:50:05 <paolino> r
07:50:07 <paolino> r
07:50:09 <paolino> r
07:50:11 <paolino> r
07:50:13 <paolino> r
07:50:15 <paolino> r
07:50:17 <paolino> r
07:50:19 <paolino> r
07:50:20 <czShadoW> Stop!
07:50:21 <paolino> r
07:50:23 <paolino> r
07:50:25 <paolino> r
07:50:26 <nominolo> OP!
07:50:27 <paolino> r
07:50:29 <paolino> r
07:50:31 <radix> @where ops
07:50:31 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
07:50:31 <paolino> r
07:50:31 <joed> Bad kitty
07:50:33 <paolino> r
07:50:35 <paolino> r
07:50:37 <paolino> rr
07:50:39 <paolino> r
07:50:41 <paolino> rr
07:50:43 <paolino> r
07:50:44 <czShadoW> Right... now...
07:50:45 <paolino> r
07:50:47 <idnar> mrowr
07:50:47 <paolino> rr
07:50:49 <paolino> r
07:50:49 <nominolo> Igloo: kick please
07:50:51 <paolino> r
07:50:53 <paolino> r
07:50:55 <paolino> 5r
07:50:55 --- mode: ChanServ set +o kosmikus
07:50:57 <paolino> 65
07:50:59 <paolino> 4
07:51:01 --- kick: paolino was kicked by kosmikus (kosmikus)
07:51:04 <czShadoW> Hooray :)
07:51:10 * Baughn worships
07:51:21 * kosmikus thinks this was an accident though
07:51:22 <benny> so much for "no side-effects" :-)
07:51:25 <radix> This channel has an amazing amount of random spam
07:51:41 <czShadoW> More users = more spammers
07:51:55 <nominolo> @losers
07:51:55 <lambdabot> Maximum users seen in #haskell: 463, currently: 441 (95.2%), active: 26 (5.9%)
07:52:06 <nominolo> whoa
07:52:28 --- mode: ChanServ set -o kosmikus
07:52:30 <radix> hmm. I wonder how well a bunch of smaller channels linked with relay bots would work :)
07:52:51 <dcoutts> radix: "@where ops" seems to work well
07:52:57 <radix> it is indeed handy
07:53:00 <dcoutts> it notifies us all
07:53:03 <ToRA> hey, very quick monad transformer question:
07:53:04 <radix> I used it this time :)
07:53:15 <dcoutts> radix: yes, thanks
07:53:15 <ToRA> is there a way around code that forms this pattern?
07:53:17 <ToRA>  EM $ ErrorT $ WriterT $ StateT $ \st -> withLocalVariable vid (flip runStateT st . runWriterT . runErrorT . runEM $ code
07:53:52 <dcoutts> kosmikus: is there any disadvantage from remaining oped?
07:54:45 <nominolo> dcoutts: it seems to be common style/courtesy around here
07:55:00 <Baughn> If you don't deop, people get nervous
07:55:08 <litb> dcoutts: it makes people think the ops are proud of their rights
07:55:18 <oerjan> ToRA: try the local method of a reader monad, perhaps?
07:55:34 <nominolo> at least i wouldn't mind, but hey
07:56:00 <litb> i would be fine with that too :)
07:56:17 <nominolo> it could seem like a formal distinction, though.  but that's a matter of taste
07:56:42 <ToRA> oerjan...that changes the parameter, i thought i wanted something like mapBlahT . mapBlahT . mapBlahT
07:56:44 <quicksilver> I think it's a very strange convention.
07:56:50 <scodil> does anyone know where the Hinze priority search queue can be found online? Or is there a better data structure for doing priority queues where the priorities are updated frequently?
07:56:52 <quicksilver> But I follow it, since it is the convention :)
07:56:57 <kosmikus> dcoutts: there's no disadvantage, it's just policy
07:57:02 <kosmikus> I actually always liked it.
07:57:19 <quicksilver> I believe the suggestion is that the visible op encourages antisocial behaviour
07:57:24 <kosmikus> I've been on channels where operators carry their @ around as if it's something special.
07:57:28 <quicksilver> I've never seen proof of that.
07:57:38 <quicksilver> I'm on other channels where everyone is opped...
07:59:10 <allbery_b> I used to be on such a channel.  (It relocated here yesterday and stopped doing the ops thing.)
07:59:14 <radix> quicksilver: proof is hard to come by in sociological matters :)
07:59:30 <allbery_b> it's the individual culture that matters
07:59:56 <kosmikus> doesn't #haskell work well on average?
08:00:04 <ricky_clarkson> Yes.
08:00:05 <kosmikus> so I don't see any need to change anything
08:00:25 <ricky_clarkson> If you have a permaop it should probably be a bot.
08:00:46 <oerjan> that's what ChanServ is...
08:01:21 <ricky_clarkson> I'm always careful not to offend him, he has connections.
08:02:51 <quicksilver> kosmikus: well, I see no advantage to the current situation
08:02:56 <quicksilver> (except social sensitivity)
08:03:03 <quicksilver> and the disadvantage is, it takes longer to take action
08:03:06 <quicksilver> when action needs taking.
08:03:26 <quicksilver> but, I don't think it's important because action needs taking so seldom :)
08:03:46 <kosmikus> takes about a second longer
08:03:52 <ricky_clarkson> That can be solved with scripts.
08:03:53 <radix> Is it possible to import a function from a module while renaming it? Or can you only rename modules?
08:04:11 <quicksilver> radix: not in the import statement.
08:04:18 <radix> I'm thinking maybe I want to import Data.ByteString.putStrLn as putBytesLn or something.
08:04:19 <quicksilver> radix: but you can also do "foo = Bar.Bar.Bar.bar"
08:04:22 <radix> quicksilver: ah.
08:04:30 <radix> quicksilver: what is the best practice for what I'm doing?
08:04:34 <quicksilver> putBytesLn = Data.ByteString.putStrLn
08:04:39 <radix> (if I want to use both putStrLn and Data.ByteString.putStrLn)
08:04:47 <radix> quicksilver: ok. that's not considered poor taste?
08:04:51 <quicksilver> I have been known to define a few aliases like that up by the top of the file
08:04:54 <quicksilver> but I prefer not to
08:05:02 <quicksilver> I prefer just to choose a short qualified name
08:05:08 <quicksilver> e.g. B.putStrLn
08:05:20 <quicksilver> (import qualified Data.ByteString as B)
08:05:25 <radix> Cool, I think I'll do that.
08:09:39 <paolino> deadfully sorry, my children got my keyoard
08:09:52 <paolino> ad
08:09:59 <paolino> and destroyed it
08:10:07 <oerjan> o_O
08:11:01 <yrlnry> paolino++
08:11:30 <byorgey> o.O !!
08:12:20 <byorgey> "destroyed it" how?  story please!
08:12:40 <paolino> well the 'a' + 1 is missing
08:13:35 <paolino> the mechanic of it, also as it is a laptop
08:13:42 <matthew_-> not the 'r' ?
08:14:12 <kosmikus> paolino: no worries. I actually had assumed such a thing ...
08:14:26 <kosmikus> 16:51  * kosmikus thinks this was an accident though
08:14:35 <paolino> ah you have my r I see it in the channel there
08:14:47 <matthew_-> kosmikus: but that's in the future!
08:14:58 <kosmikus> not for me ;)
08:15:06 <oerjan> matthew_-: kosmikus is precognitive
08:16:38 <dcoutts> kosmikus: ok, fair enough, I'll have to set up an alias so I can op quickly when needed
08:18:46 <quicksilver> ricky_clarkson: yes, one can set up a script, but to my mind it seem silly to do so. :)
08:23:00 <scodil> is there any code floating around anywhere for priority queues with functions to update priorities of arbitrary elements?
08:23:33 <shapr> @yow !
08:23:33 <lambdabot> Hello...  IRON CURTAIN?  Send over a SAUSAGE PIZZA!  World War III?  No thanks!
08:23:34 <yrlnry> "Update"?  HERESY!
08:23:53 <shapr> scodil: Have you checked Rabhi & Lapalme's FP Algorithms book?
08:24:28 --- mode: ChanServ set +o dcoutts
08:24:35 --- mode: ChanServ set -o dcoutts
08:24:47 --- mode: ChanServ set +o dcoutts
08:24:56 <dcoutts> huh?
08:25:02 * dcoutts is confused now
08:25:06 * shapr sniggers with prepubescent glee
08:25:17 <scodil> shapr: no, but i am aware of a few different papers about such a data structure. I'm mostly looking for working, tested code. I don't really have to time to implement and test something myself. I can't find it I'm just going to revert to C.
08:25:19 <dcoutts> shapr: ah I see :-)
08:25:31 <scodil> If I can't find it ...
08:25:39 --- mode: ChanServ set -o dcoutts
08:25:41 <shapr> scodil: Rabhi and Lapalme's book has online sources.
08:25:44 <shapr> Haven't tried it lately though.
08:25:52 <shapr> dcoutts: I just had to be silly :-)
08:26:13 <dcoutts> shapr: :-) I'm trying to set up a quick alias
08:26:41 <shapr> scodil: I know they had several pq implementations, I don't remember if there was one with priority update. But you could likely check the website and see.
08:27:58 * shapr has a sudden urge to setup a bluetooth NAT PAN
08:29:39 <quicksilver> do we have a heap / priority queue at all, in the standard lib?
08:29:43 <quicksilver> I think not?
08:29:57 <dcoutts> quicksilver: indeed, not, there are a couple on hackage
08:30:29 <dcoutts> I think we should find one and standardise it in the containers package
08:30:32 <shapr> What about Edison? Does it have pqs?
08:30:38 <dcoutts> yep
08:30:54 <shapr> Is Edison still maintained? Last I heard Pseudonym was handling it.
08:31:39 <shapr> I wonder if Rabhi & Lapalme would be okay with having their code in the stdlibs?
08:31:42 * shapr emails them
08:32:06 <radix> so what exactly does "standard libraries" mean on haskell.org? those don't seem to be included in my copy of GHC
08:32:22 <litb> is this channel official?
08:32:34 <Japsu> as official as it gets
08:32:38 <shapr> litb: I think so.
08:32:43 <litb> it sounds like things said here are quite official concerning things of the std lib
08:32:45 <dcoutts> radix: it's a tad vague, there are the core libs which are needed to bootstrap ghc
08:33:05 <shapr> litb: That question was once explicitly brought up by someone trying to make a power play, and I offered ownership to the Simons. They politely declined.
08:33:06 <litb> hm, is ghc itself haskell?
08:33:19 <shapr> litb: That's a good question.
08:33:27 <dcoutts> it is an implementation of Haskell, yes
08:33:35 <shapr> litb: Officially, no. Effectively.. somedays :-)
08:33:43 <shapr> Of course, that's my opinion.
08:33:47 <radix> dcoutts: soo... what are the other things that are in standard libraries?
08:33:51 <litb> i see
08:33:54 <radix> Are they just things that the haskell community has decided are nifty?
08:34:03 <shapr> radix: I consider stdlibs to mean "anything that's in hackage"
08:34:08 <ski> (ghc is also written (mostly) in haskell)
08:34:11 <radix> and I have to go find them somewhere else?
08:34:15 <dcoutts> shapr: that's pretty wide :-)
08:34:22 <radix> shapr: hmm, but there's lots of stuff in hackage that's not listed in Standard Libraries.
08:34:34 <shapr> radix: Oh, you mean not listed in the library docs?
08:34:59 <radix> Basically, it's a surprising use of the phrase. In other systems, I expect "standard libraries" to be the libs that are included with my implementation.
08:35:01 * shapr shrugs
08:35:18 <shapr> With cabal, why should something be explicitly included?
08:35:20 <dcoutts> radix: that's pretty much what it does mean, the code libs.
08:35:25 <dcoutts> erm core
08:35:30 <shapr> mmm code!
08:35:47 <radix> dcoutts: I'm specifically referring to the "Standard libraries" link on haskell.org.
08:35:58 <radix> there's a bunch of stuff not in core.
08:36:00 <mauke> they came with the extralibs tarball
08:36:05 <radix> Oh.
08:36:14 <quicksilver> I used the phrase 'standard libraries' here
08:36:19 <scodil> So in the Ralf Hinze priority search queue paper, there's code, but its not really haskell because it uses views and it also has a bunch of dumb latex symbols for operators, so I'm wondering if he actually implemented it, and if so, why is the working code not available?
08:36:19 <quicksilver> and I meant, 'extralibs'
08:36:25 <quicksilver> which I agree is a bit of a strange thing to mean
08:36:29 <quicksilver> but it is what I meant
08:36:40 <radix> quicksilver: I see :-)
08:36:43 <radix> It all makes sense now!
08:36:45 <quicksilver> (it's the whole bundle which comes in the installer megapackages for OSX and win32)
08:36:54 <shapr> scodil: In a lot of cases, executable source is not distrbuted when a paper is published. I consider that a bad thing.
08:37:01 <dcoutts> radix: ok, so that includes the core libs and some others sometimes known as "extralibs"
08:37:04 <radix> fortunately, it seems most of the things listed in Standard libraries are packaged in Ubuntu.
08:37:14 <quicksilver> yes, they all are, AFAIk
08:37:15 <dcoutts> but that latter category is not well defined
08:37:25 <cjb> shapr: s/a lot of/the overwhelming majority of/ -- :(
08:37:28 <quicksilver> FOV "all" meaning "all that were available for that version"
08:37:40 <shapr> cjb: Truly. Did you go last night? Was it cool?
08:37:59 <scodil> shapr: In this case its not so bad because the code is in the paper. If it were real haskell, you could just copy it verbatim. But its not real haskell, so if I copy it I might screw something up, so I'm hesitant
08:38:07 <cjb> it was okay.  another hour on STM that felt kinda wasted when we _still hadn't talked about what a monad is_.  :)
08:38:09 <ski> quicksilver : `FOV' ?
08:38:16 <quicksilver> ski: typo for 'FVO'
08:38:38 <ski> quicksilver : "For some Values Of" ?
08:38:45 <quicksilver> For Values Of
08:38:47 <quicksilver> yes
08:38:51 <scodil> Field Vision Of
08:38:56 <quicksilver> anyhow, I'd love a Heap or Priority Queue
08:39:05 <quicksilver> even if it wasn't super-clever-clever optimal
08:39:09 * dcoutts experiments with setting up an op alias again...
08:39:10 --- mode: ChanServ set +o dcoutts
08:39:10 <shapr> cjb: Yeah, Ed and I both opined that we would have given a very different talk. I also opined that I was very glad that Gregory Price had the initiative and organization to make that talk happen at all :-)
08:39:13 --- mode: ChanServ set -o dcoutts
08:39:19 <dcoutts> yay, seems to work
08:39:22 <ski> <minion> Flyboat Vintaging Overinventoried
08:39:35 <shapr> ski: wah?
08:39:36 <cjb> yup, can't argue with that.
08:39:56 <shapr> ski: haha!
08:40:01 <ski> shapr : oh, i just `/msg minion what does FVO stand for?' ;)
08:40:02 <cjb> I think the main downside was that he seems to really really really like STM, but that's not something you should spend a lot of time on in someone's first four hours of Haskell.
08:40:13 --- mode: ChanServ set +o dcoutts
08:40:18 <shapr> cjb: Truy.
08:40:25 --- kick: dcoutts_ was kicked by dcoutts (just testing :-))
08:40:26 <shapr> truly*
08:40:29 --- mode: ChanServ set -o dcoutts
08:40:38 <shapr> My keyboad is boken.. argh
08:40:54 <paolino> (the fn key is not that bad at the b place, I just carved it to make space to the point mouse and switch on the autolock , for the children)
08:40:56 <shapr> cjb: I want one like yours, what is it?
08:41:00 * oerjan doesn't know if keeping ops on makes people nervous but turning them on and off all the time certainly does
08:41:04 <quicksilver> shapr: fwiends, womans, countwymen, lend me youw Rs
08:41:04 <scodil> quicksilver: The lazy skew heap is about as clean and efficient as you'd want a priority queue to be, all ~50 lines of it, it just doesn't have updatable priorities.
08:41:19 <dcoutts> oerjan: sorry, am done now :-)
08:41:24 <scodil> actually make that ~30 lines
08:41:30 <quicksilver> scodil: yeah, that would suit me fine.
08:41:45 <dcoutts> oerjan: I was only given ops the other day and am just making sure I know how to use it correctly
08:41:47 * shapr throws a statistics package at quicksilver 
08:42:02 <hpaste>  visof pasted "what is the problem?" at http://hpaste.org/5395
08:42:29 <quicksilver> visof: if you're going to ask questions like that, it's polite to paste the error message
08:42:44 <quicksilver> visof: however, i can tell you that the problem is that 'value' is a string, and you can't multiply strings.
08:42:59 <oerjan> visof: put the ( after show
08:43:08 <quicksilver> ah
08:43:10 <shapr> scodil: If you're collecting data structures, want to upload a package?
08:43:14 <quicksilver> different problem :)
08:43:41 <quicksilver> scodil: does it support 'deleting' an item from the middle?
08:43:44 <quicksilver> scodil: or only the head?
08:43:59 <scodil> shapr: IF i were, sure. But I'm not. I'm in the middle of a project and I need an updatable priority queue. I'm going to end up writing one in C, but I'm not happy about that so I'm lurking in here
08:44:05 <scodil> quicksilver: only the head
08:44:13 <quicksilver> ah, that's probably slightly annoying.
08:44:15 <oerjan> visof: oh, and getLine won't work, you need readLn
08:44:18 <oerjan> :t readLn
08:44:19 <lambdabot> forall a. (Read a) => IO a
08:44:27 <shapr> cjb: I also really like STM, but I don't think it's easy to see why without lots of background knowledge.
08:44:32 <quicksilver> oerjan: what a stupid piece of function naming
08:44:38 <shapr> scodil: Oh, I see.
08:44:43 <visof> what is the difference between them ?
08:44:45 * quicksilver hurls the Pointy Rock of Consistency at the haskell98 committee.
08:44:48 <hpaste>  scodil pasted "lazy skew heap" at http://hpaste.org/5396
08:44:54 <quicksilver> visof: getLine returns a String.
08:44:57 <oerjan> visof: getLine only gives a String
08:45:08 <shapr> quicksilver: Wouldn't it be a square or something so it would be consistently shaped?
08:45:20 <shapr> Maybe a sphere is the most consistent shape?
08:45:30 <bringert> wanna do a PhD on FP at Chalmers? http://www.cs.chalmers.se/~koen/phdad.html
08:45:30 <shapr> Aaanyway ... I should get some imperative code done...
08:45:31 <lambdabot> Title: PhD Positions in Functional Programming at Chalmers
08:45:43 <shapr> bringert: ooh, me me! Too bad I'm otherwise occupied.
08:46:08 * quicksilver instinctively kicks bringert for an advert-URL in channel :P
08:46:14 * shapr snickers
08:46:26 <quicksilver> scodil: looks nice.
08:46:34 <scodil> no no no its not a php ad, it's a Ph Dad. A chemistry father
08:46:41 <scodil> er, phd
08:46:43 <scodil> you know what i meant
08:46:46 <shapr> PhD advertising is actually on topic here!
08:46:57 <mauke> "Powered by PhD"
08:47:00 <quicksilver> scodil: I'm surprised it lacks a combination of minElem and deleteMin
08:47:06 <quicksilver> scodil: but, it looks good
08:47:28 <quicksilver> scodil: also 'toList' is rather handy, which is just a lazy way of getting them out in order.
08:47:29 * shapr kramer bringert
08:47:48 <bringert> so, who doesn't have a PhD here?
08:47:55 <shapr> me?
08:47:58 <bringert> and isn't working on one
08:47:58 <Valodim_> me?
08:48:00 <scodil> quicksilver: something like minView would be exactly (minElem h, deleteMin h) so there's no real reason to put in the lib
08:48:24 <quicksilver> scodil: I'm not sure if that is a valid argument.
08:48:32 <scodil> its not like minView in Data.Set where you save some work by combining them
08:48:34 <Valodim_> PhD sounds awfully similar to PhP, I'm not going to get that >:(
08:48:37 <quicksilver> scodil: common usage patterns deserve names
08:48:45 <quicksilver> scodil: even if they're trivial in implementation
08:48:46 <litb> ac: you there?
08:48:48 <scodil> fair enough
08:49:13 <dancor> what is the correct way to uninstall, ghc-pkg unregister then delete files?
08:49:57 <monochrom_> MSc sounds like another evil M$ product! :)
08:50:01 <scodil> This priority queue though, is so simple, its almost better to just have it floating out there than in the std libs. If its in the libs its opaque and people never see whats going on. This thing is so simple that its not a hindrance at all to just deal with the innards directly. Adapt things to your particular project.
08:50:02 <oerjan> Valodim_: it's not the same.  PhDoctors cure PhPain...
08:50:12 <Valodim_> haha
08:50:14 <Valodim_> true
08:51:00 <shapr> scodil: Sounds nifty.
08:51:23 <visof> oerjan getLine can return Int
08:51:29 <quicksilver> visof: no, it can't
08:51:33 <oerjan> :t getLine
08:51:34 <lambdabot> IO String
08:51:34 <quicksilver> visof: getLine always returns a String.
08:51:41 <visof> c <- getLine
08:51:48 <visof> putStrLn (n)
08:51:55 <visof> it's work with me
08:51:57 <visof> why?
08:52:00 <scodil> I vote for the priority search queue as a standard priority queue. Maybe someday I'll implement it and test it. Not today though.
08:52:05 <quicksilver> visof: it works, but c is a string
08:52:08 <paolino> what is Ph ... post something ?
08:52:12 <quicksilver> visof: it might be a string containing a number
08:52:15 <quicksilver> visof: but it's still a string.
08:52:16 <visof> you can enter any number
08:52:19 <quicksilver> visof: yes
08:52:20 <oerjan> paolino: Philosophiae, i think
08:52:26 <visof> "2"
08:52:27 <visof> ??
08:52:29 <quicksilver> yup
08:52:30 <visof> "3"
08:52:32 <visof> ?
08:52:34 <quicksilver> there is a different between 2 and "2"
08:52:35 <visof> oh
08:52:38 <dancor> > "2" == 2 :: Int
08:52:38 <quicksilver> :)
08:52:38 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
08:52:44 <visof> so i can do any operation
08:52:44 <shapr> visof: You're looking like paolino's keyboard...
08:53:04 <quicksilver> visof: "read" is a general purpose parsing routine for haskell types
08:53:16 <quicksilver> visof: it can turns strings to numbers, among other things
08:53:47 <ski> bringert : it sounds interesting, but i think i should graduate first
08:53:50 <dancor> it's a magic function that behaves radically different depending on the input and output
08:53:50 <visof> shapr hi, how are you?, what do you mean?
08:54:09 <shapr> visof: I'm just being silly and distracting...
08:54:20 <visof> quicksilver thank you, i understood
08:54:21 --- mode: ChanServ set +o shapr
08:54:39 <shapr> KELEBEK605USER2: Learning Haskell?
08:54:49 <KELEBEK605USER2> yes..
08:54:54 <shapr> Ah, cool.
08:55:06 <shapr> KELEBEK605USER2: How did you get interested in Haskell?
08:55:30 <paolino> Shapr, put down your gun :)
08:55:38 <dancor> captcha
08:55:44 <shapr> paolino: Not until the turing test passes or failes.
08:56:04 <shapr> kelebek is the name of a turkish irc script.
08:56:05 <quicksilver> it's not a captcha
08:56:08 <joed> whois KELEBEK605USER2
08:56:09 <quicksilver> it wasn't automated :)
08:56:13 <KELEBEK605USER2> www.mirclan.net www.mircmerkezi.net www.sohbet-turk.org http://mirc.sohbet-turk.org http://mirc.mircmerkezi.net http://haber.mirclan.net
08:56:14 <KELEBEK605USER2> www.mirclan.net www.mircmerkezi.net www.sohbet-turk.org http://mirc.sohbet-turk.org http://mirc.mircmerkezi.net http://haber.mirclan.net
08:56:15 <lambdabot> Title: Sohbet-Turk.Org
08:56:16 <lambdabot> Title: Sohbet-Turk.Org
08:56:17 <dancor> reticence = robot
08:56:20 <shapr> hah
08:56:22 <idnar> *chuckle*
08:56:24 <shapr> Color me unsurprised.
08:56:26 <dancor> hah = humon
08:56:43 <dancor> i can't wait to check out that website
08:56:46 <ricky_clarkson> And on the other side of the internet, a poor 12-year-old is playing "convince the computer you're human" unaware that the responses are being piped into #haskell.
08:57:07 <shapr> This much spam really sucks.
08:57:08 <sarehu> wait, what?
08:57:16 <idnar> I wonder how many people have managed to sneak CAPTCHA solving tasks into Amazon Mechanical Turk
08:57:28 <ricky_clarkson> shapr: Is +r unacceptable?
08:57:30 <shapr> I think there's a channel mode that only lets registered users speak.
08:57:38 <ricky_clarkson> It's +r :)
08:57:40 <shapr> ricky_clarkson: I'm considering that.
08:57:57 <ricky_clarkson> It only lets registered users join.
08:57:59 <idnar> it can be confusing if you don't notice your messages aren't going through, though
08:58:03 <ricky_clarkson> ..anyone already there can speak.
08:58:04 <shapr> idnar: Yeah, true.
08:58:05 <idnar> oh, yeah, +R is the one that silences them, I think
08:58:12 <quicksilver> more of a cmptcha
08:58:17 <idnar> +r is a little less confusing, because you will at least know that you're not in the channel
08:58:19 <shapr> So far #haskell has been newbie friendly, I'd like it to stay that way.
08:58:45 <scodil> "you! new person! prove you are HUMON!"
08:58:50 <quicksilver> I believe +r / +R are both unacceptable
08:58:51 <dancor> irc itself is already somewhat not newbie friendly
08:59:00 <ac> litb: yeah, as it so happens, I'm around
08:59:01 <idnar> but it really sucks when you have some poor newbie typing questions into a channel, and their IRC client either suppressing the error responses, or displaying them somewhere the user doesn't notice them
08:59:01 <shapr> A decent captcha would be somethin like "What is Haskell good for? What does it do?"
08:59:06 <quicksilver> this is annoying but 2/3 kicks a day is not the end of the world
08:59:08 <idnar> uh, insert a verb in there somewhere
08:59:11 <ricky_clarkson> An eggdrop would be a solution.
08:59:19 <quicksilver> I'd rather a few ops have to do a few kicks
08:59:23 <shapr> quicksilver: It's the most noise I've seen here yet.
08:59:27 <quicksilver> than real, interested, newbies can't get in
08:59:37 <quicksilver> if it was 1 bot every 10 minutes, that would be different :)
08:59:37 <shapr> Ooh, nearly seven years!
08:59:44 <dons> ?users
08:59:45 <lambdabot> Maximum users seen in #haskell: 463, currently: 450 (97.2%), active: 25 (5.6%)
08:59:48 <monochrom_> 2/3 kicks a day, keeps the trolls away!
08:59:51 <shapr> Ok, twelve more weeks till #haskell hits seven years old.
09:00:01 <idnar> is someone baking a cake?
09:00:07 <quicksilver> how old is lambdabot?
09:00:18 <shapr> I don't remember.
09:00:19 <davidL> @vixen how old are you?
09:00:19 <lambdabot> 19, you?
09:00:20 <ac> who would eat the cake? Would it be distributed by mail?
09:00:38 <ac> litb: what's up?
09:00:43 <shapr> ac: Maybe an ASCII art birthday cake that fits into an email sig?
09:00:58 <Valodim_> (the cake is a lie)
09:01:13 <shapr> The lambdas are not what they seem.
09:01:21 <scodil> shapr: haskell is the _lazy_ language, right? Just send a link to a GIS search for "birthday cake"
09:01:27 <litb> ac: do you have the hopengl code around?
09:01:28 <Valodim_> haha
09:01:31 <monochrom_> cake with lambda candles
09:01:33 * shapr grins
09:01:34 <Valodim_> so it evaluates when he clicks. great.
09:01:40 <ac> litb: I'll dig it up and hpaste it
09:02:00 <litb> great, thanks :)
09:02:09 <hpaste>  visof pasted "the problem and the error message" at http://hpaste.org/5397
09:02:12 <shapr> hpaste has a new cultural role. It's now a repository of snippets as well as a pasteboard.
09:02:20 <shapr> How would hpaste be improved to support that role better?
09:02:44 <quicksilver> a lazy cake cooks itself as you slice it.
09:02:49 <aFlag> also, it good to let people not register their nicks if they don't want to
09:02:50 <quicksilver> shapr: search feature.
09:03:00 <paolino> visof : you must show the foo output
09:03:03 <quicksilver> shapr: ability to 'tag' old posts with keywords
09:03:06 <scodil> a lazy cake doesn't actually exist until its poop
09:03:07 <shapr> What about adding tags?
09:03:09 <shapr> Yeah :-)
09:03:10 <monochrom> add a search engine and give it a wiki.
09:03:23 <quicksilver> shapr: ability to upvote posts
09:03:32 <monochrom> also make it a blog.
09:03:37 <quicksilver> shapr: ability to post not only haskell source but pictures of cute animals with amusing captions.
09:03:40 <shapr> monochrom: Good idea, go for it!
09:03:43 <shapr> quicksilver: Uh oh..
09:03:51 <quicksilver> oops. did I get silly?
09:03:58 <quicksilver> must be friday afternoon.
09:03:59 <visof> paolino it's work
09:04:00 <scodil> queue ron paul joke in 5 ... 4 ... 3 ....
09:04:02 <shapr> Integrate lambdacats?
09:04:06 <hpaste>  ac pasted "show a window of B&W static" at http://hpaste.org/5398
09:04:06 <paolino> :t readLn
09:04:08 <lambdabot> forall a. (Read a) => IO a
09:04:16 <mauke> visof: print (foo n)
09:04:23 <mauke> print = putStrLn . show
09:04:33 <ac> litb: there you go. that's about as simple as it gets
09:04:52 * litb knuddles ac :)
09:05:39 <quicksilver> shapr: no but seriously. tags and search. would rock.
09:05:52 <quicksilver> shapr: and some kind of assurance that data is safe
09:05:52 <ac> litb: notice that when I call texImage2D I pass Luminance8. You can also use ColorRGB or ColorRGBA, or something like that. Can't remember the exact names for the constructors
09:05:58 <quicksilver> shapr: (hasn't it been reset a couple of times)
09:05:59 <davidL> shapr: and a darcs backend
09:06:02 <paolino> anyone knows how to program readline completion via the wrappers ?
09:06:37 <litb> i see
09:07:19 <jedbrown> I assume the hpaste `remember me' box actually does something for other people.
09:07:41 <idnar> it doesn't do anything for me
09:07:48 <idnar> (so far as I can tell)
09:07:52 <shapr> quicksilver: It doesn't have that assurance because it wasn't designed to be a snippet repo.
09:07:56 <shapr> jedbrown: Doesn't work for me.
09:08:05 <ac> remember me doesn't do anything for me either
09:08:30 <jedbrown> hmm, okay I don't feel so bad.  That could be made better then.
09:08:33 <shapr> Last I heard, something was broken in the HAppS cookie code.
09:09:30 <ac> shapr: are you suggesting for hpaste to grow some sort of hierarchy like in hackage?
09:09:51 <scodil> does the new haddock search function obliterate anyone else's firefox? I used to bitch about the alphabetical index but now I miss it.
09:09:58 <shapr> ac: Nah, just tags and text search.
09:10:06 <ac> shapr: ah that would be cool
09:10:22 <sarehu> scodil: it hurts mine
09:10:30 <sarehu> scodil: and I agree completely
09:10:34 <shapr> Of course, I don't really have tie to do anything aout it :-)
09:10:44 <sarehu> only without the bitching about the alphabetical index
09:10:51 <scodil> sarehu: it would be awesome if it just wan't java script. If someone would write a gtk2hs app to do the same thing
09:11:07 <ecksit> hello, how would i be able to create a matrix type, which has the properties that each sublist must be the same length?
09:11:12 <ac> shapr: are you responsible for hpaste?
09:11:15 <scodil> or if hoogle indexed all the ghc libs
09:11:27 <shapr> ac: Sort of, yeh.
09:11:37 <sarehu> or if it just weren't so slow
09:12:02 <shapr> ac: glguy wrote hpaste, it's running on my server, and sorear has been maintaining it.
09:12:24 <ac> shapr: so what kind of indexing system would you use, if you had the time to do it?
09:12:54 <scodil> ecksit: I've done that a couple different ways, but its not pretty. You either have to have a phantom type encoding the length, or you can use a list type that encodes its length. both are more awkward than just using plain list-of-lists
09:12:59 <ac> shapr: sqlite + fulltext, some Haskell code that stored the index in memory?
09:13:10 <shapr> ac: Were it me, I'd steal kimbly's inverted index and see if that's a good solution.
09:13:37 <shapr> Or I'd try HAppS persistent indexing stuff, that might be easier since hpaste is already written in HAppS.
09:13:38 <litb> hm, why doesn'T he need to read  the n?
09:13:49 <litb> it is String, and String doesn't support *
09:13:50 <quicksilver> shapr: you say it wasn't designed as a snippet repo
09:13:55 <quicksilver> shapr: but that's not how I remember history
09:14:06 <quicksilver> shapr: almost immediately after it was mentioned on the -cafe
09:14:14 <quicksilver> shapr: I remember people discussing how it was useful as a repo
09:14:14 <mauke> why is n a string?
09:14:18 <visof> can anyone help me to find the program the can calculate number of characters of line ?
09:14:22 <quicksilver> and I thought glguy was one of the them :)
09:14:22 <ToRA> @type readLn
09:14:23 <lambdabot> forall a. (Read a) => IO a
09:14:25 <quicksilver> but I'm not sure.
09:14:30 <shapr> quicksilver: iirc, it ended up being useful as a snippet repo, and that's how it ended up being used.
09:14:40 <sarehu> visof: what are 'characters of line'?
09:14:40 <quicksilver> shapr: ah, nod :)
09:14:41 <ToRA> litb: it's not a string
09:14:44 <litb> oh
09:14:45 <quicksilver> there are four
09:14:47 <quicksilver> l   i   n   e
09:15:00 <visof> sarehu you will enter them
09:15:06 <shapr> ac: If you decide to hack on hpaste, could you add an explicit license somewhere? I'd like to have newly submitted code be explicitly BSD3, public domain, or something.
09:15:19 <ecksit> scodil: im trying to write some matrix manipulation functions to learn haskell and i thought this might be a useful exercise
09:15:23 <paolino> visof : strings are lists
09:15:23 <shapr> quicksilver: Speaking of not being designed as a snippet repo... licensing was never considered.
09:15:27 <litb> it's the default thing that makes it a Number, or?
09:15:47 --- mode: shapr set -o shapr
09:15:48 <ecksit> scodil: could u hpaste the source?
09:15:50 <ac> shapr: sure If I get around to it. I'm planning on doing a little Haskell web hacking experimentation, so it's not an entirely unlikely possibility
09:16:00 <visof> paolino what about space or tab ?
09:16:00 <shapr> ac: That would be very cool.
09:16:08 <visof> and "\n"
09:16:08 <shapr> @seen sorear
09:16:08 <lambdabot> I saw sorear leaving #xmonad, #haskell-blah, #haskell and #ghc 9h 22m 18s ago, and .
09:16:09 <visof> ?
09:16:20 <ecksit> im also thinking about how to transpose a matrix, thinking about using zip somehow
09:16:23 <litb> or does it automatically see that it needs to be a Num because of the * , therefore reads it and multiplies it then?
09:16:23 <dons> shapr: i thought hpaste was BSD3
09:16:23 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:16:25 <ac> I have a cool little project in the works before I get to that though
09:16:30 <paolino> visof : read Prelude docs for functions on lists
09:16:35 <scodil> is there a place to post things larger than 5k?
09:16:52 <visof> paolino i know some
09:16:58 <shapr> dons: The snippets themselves are not licensed. In the current role of hpaste as a snippet collection, they should be.
09:17:04 <paolino> visof you want function length
09:17:20 <ecksit> scodil: u may send me an email if thats what ure asking
09:17:29 <shapr> dons: Then I could paste bits of LicensedPreludeExts for example.
09:17:32 <paolino> > length "paolino ha dei figli suonati"
09:17:32 <lambdabot>  28
09:17:37 <jedbrown> ecksit: If you are worried about performance, you'll want to use arrays.  If you want a spoiler about transpose, type @src transpose here.
09:17:40 <nominolo> :t or
09:17:41 <lambdabot> [Bool] -> Bool
09:17:41 <ac> shapr: oh, you mean code pasted should have an explicit license, not the source code of hpaste
09:17:47 <shapr> ac: Correct.
09:18:00 <hpaste>  scodil pasted "basic linear algebra for 2,3,4 dimensions" at http://hpaste.org/5399
09:18:08 <shapr> Currently people are not allowed to reuse the useful snippets they find.
09:18:09 <ecksit> @src transpose
09:18:09 <lambdabot> transpose []             = []
09:18:10 <lambdabot> transpose ([]   : xss)   = transpose xss
09:18:10 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
09:18:15 <scodil> ecksit: there you go
09:18:20 <shapr> Not legally, at least.
09:18:43 <sclv_> Ppl should encourage there to maybe a snippet section of the haskell wiki instead.
09:18:46 <litb> @src readLn
09:18:46 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
09:18:47 <dons> shapr: ah yes. the intent was they'd be under the license of the wiki
09:18:50 <shapr> afaiu, they're the property of the submitter, with no usage privileges implied at all.
09:18:57 <dons> and that we then could import them to the wiki
09:19:03 <BMeph> I prefer the zipList transpose, myself. But then, I'm always trying to get folks to call map "zipWith1". ;)
09:19:08 <shapr> dons: Yup, that would be nice.
09:19:14 <litb> @src readIO
09:19:14 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:19:16 <litb> hm
09:19:17 <sclv_> the wiki makes much more sense as a snippet repository.
09:19:20 <ecksit> scodil: thanx
09:19:29 <quicksilver> I don't really agree.
09:19:34 <sclv_> you get tags (sorta) and search and all the other good stuff for free.
09:19:35 <shapr> sclv_: I dunno. Cultural conventions tend to drive "makes sense" a lot.
09:19:47 <quicksilver> stuff on the wiki needs to fit into the sense of the wiki
09:19:56 <quicksilver> you don't want the wiki cluttered with 'random snippets'
09:19:58 <shapr> sclv_: The wiki doesn't allow easy collaboration, hpaste is a touch easier.
09:20:01 <shapr> Not much, mind you.
09:20:07 <quicksilver> however, an hpaste full of random snippets woudl be very useful
09:20:12 <quicksilver> *is* very useful
09:20:23 <quicksilver> I have been known to paste links to 2-month old hpastes, from time to time
09:20:32 <shapr> Now that hs-plugins is working again, I'd like to try adding a ghci interpreter to every snippet for interactive experimentation.
09:20:36 <sclv_> as it is, you can't find anything unless you know exactly what you're working for.
09:20:43 <quicksilver> right
09:20:47 <shapr> sclv_: Right, and that's what I'd like to fix.
09:20:48 <hpaste>  BMeph pasted "More PQ fun with heaps" at http://hpaste.org/5400
09:20:49 <quicksilver> google does index hpaste, though
09:20:55 <scodil> ecksit: it cut me off at matrix-vector multiplication, but you can see how it works in the matrix-matrix multiplication function
09:20:57 <ac> yeah, I've also found myself digging through hpaste's history
09:20:58 <quicksilver> and I sometimes managed to find the things I"m looking for :)
09:20:58 <shapr> Wow, 5400 hpastes??
09:21:10 * BMeph takes a bow
09:21:24 <shapr> Um, I better check free space on my server.
09:21:27 <codemac> How do I install fingertree?  I'm trying to build Yi, and it says I'm missing `fingertree -any`
09:21:28 <sclv_> there should also be an expires tag maybe for pastes that aren't intended for posterity -- i.e. silly error messages and stuff?
09:21:40 <ac> litb: just out of curiosity, what're you using OpenGL for?
09:21:47 <sclv_> would ppl. find diff useful on hpaste by the way?
09:21:58 <shapr> I dunno, try it?
09:22:05 <BMeph> codemac: I'd recommend "cabal install fingertree"
09:22:06 <shapr> codemac: do you have cabal?
09:22:46 * BMeph notices shapr's been slacking, and tosses around some fluffy lambdas
09:22:49 <ecksit> scodil: is there anything after multMV?
09:23:10 <ecksit> scodil: like, any other functions with matrices?
09:23:18 <scodil> ecksit: multMV (Mat m) (Vec u) = Vec $ map (sum . (zipWith (*) u)) m
09:23:29 * shapr throws tarry lambdas at BMeph 
09:24:04 <scodil> not really more than that. some stuff specific to using them for projective transformations, grab the upper left, grab the right-most column, etc. but the basics are there
09:24:09 * BMeph catches the tarry lambdas with a thorny lambda construct
09:24:18 <radix> shapr: I have a lot of classwork to do, but would you like to get dinner tonight?
09:24:21 <shapr> Anyway, from a #haskell socio-centric viewpoint, hpaste would probably benefit from explicit snippet repo features.
09:24:23 <scodil> don't ask me about that gaussian elimination algorithm. that thing is like the mystery of life to me
09:24:39 <scodil> but it works
09:24:41 <radix> shapr: I'll probably have to go home and do work right after, unfortunately, but I'd at least like to see some friends before leaving for two weeks.
09:24:43 <scodil> and its actually pretty quick
09:24:44 <shapr> radix: Yeah, I think I'll have time.
09:25:22 <radix> cool
09:25:41 <ecksit> looks scary
09:25:53 <shapr> For that matter, #haskell would likely benefit from switching to xmpp... but I don't know how'd that'd work.
09:26:12 <masklinn> "
09:26:22 <scodil> doesn't it? i could stare at that thing for a weak and not know what it's doing
09:26:26 <scodil> a week
09:26:49 <codemac> shapr: I do not have cabal :(  But I found fingertree on hackage
09:26:58 <codemac> i'll brb
09:27:06 <ecksit> in line 117 u use the transpose function, did u define it somewhere else?
09:27:21 <oerjan> @index transpose
09:27:21 <lambdabot> Data.List
09:27:24 <scodil> no that's Data.List.transpose
09:27:32 <ac> shapr: how would we benifit from xmpp?
09:27:51 <ecksit> ok, thanx
09:28:02 <paolino> :t unfoldr
09:28:03 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:30:42 <paolino> :i Maybe
09:31:12 <paolino> @info Maybe
09:31:13 <lambdabot> Maybe
09:31:37 <mauke> there is no @info
09:32:08 <desegnis> ac: less spam bots (although that's likely to change soon)
09:32:59 <ac> I wasn't aware of any spam bots on this channel
09:33:20 <dmwit> ?undo Maybe
09:33:21 <lambdabot> Maybe
09:33:51 <desegnis> ac: well, maybe those are spamming real people. but we have good human resources for banning those
09:34:45 <Igloo> Is \& a standard thing, or Haskell-only?
09:34:51 <desegnis> shapr: one major obstacle in switching to jabber is the fact that Freenode is not doing jabber
09:34:56 <litb> xmpp ? isn't that jabber?
09:35:17 <dmwit> ?info do { x <- a; f x }
09:35:17 <desegnis> litb, yeah they're the same thing
09:35:18 <lambdabot> a >>= \ x -> f x
09:35:19 <dmwit> That one is more convincing. =)
09:35:28 <litb> i like jabber
09:35:55 <litb> that looks like fmap =)
09:36:17 <quicksilver> Igloo: what is \& ?
09:36:20 <jedbrown> Igloo: In what sense?  It's certainly a LaTeX thing.
09:36:27 <monochrom> No, fmap looks like do { x <- a; return (f x) }.
09:36:31 <mauke> oh, I thought you meant the Perl \&
09:36:50 <litb> darn :)
09:36:53 <Igloo> "\1234\&5" stops the 5 being treated as part of the number of the escaped character
09:37:01 <quicksilver> that is haskell only
09:37:13 <quicksilver> other languages I'm aware of use fixed-length escapes
09:37:14 <litb> @type do { x <- a; f x }
09:37:16 <lambdabot> Not in scope: `a'
09:37:16 <lambdabot> Not in scope: `f'
09:37:18 <quicksilver> either hex or octal
09:37:22 <quicksilver> and always 3 or 4 chars
09:37:23 <litb> ugg
09:37:23 <mauke> C limits octal escapes to three digits
09:37:32 <quicksilver> \u0044
09:37:33 <litb> will it append a "return ()" at the end implicitely?
09:37:34 <mauke> hex escapes are unlimited but you can always use "\x1234" "5"
09:37:36 <quicksilver> (java, unicode)
09:37:37 <allbery_b> @type do { x <- ?a; ?f x }
09:37:37 <lambdabot> forall (t :: * -> *) t1 t2. (?a::t t1, ?f::t1 -> t t2, Monad t) => t t2
09:37:44 <dmwit> litb: no!
09:37:52 <mauke> Perl limits hex escapes to 2 digits but lets you say "\x{1234}5"
09:38:02 <litb> what does that do return ?
09:38:06 <monochrom> do{} is not C
09:38:14 <monochrom> whatever f x returns.
09:38:16 <dmwit> litb: It returns whatever f returns.
09:38:21 <litb> oh, i see
09:38:22 <allbery_b> "t t2".  see the inferred type of ?f
09:38:28 <litb> i forgot that it doesn't need to return a monad
09:38:28 <allbery_b>  ?f::t1 -> t t2
09:38:41 <dmwit> litb: It *does* have to return a monad.
09:38:51 <dmwit> litb: It is required that f constructs a monad.
09:39:05 <litb> yeah, that's the definition of >>= i see
09:39:09 <Igloo> Thanks all
09:39:11 <mauke> .oO( "it is imperative that f constructs a monad" )
09:39:17 <dmwit> :t \f a -> do { x <- a; f x }
09:39:18 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => (t1 -> t t2) -> t t1 -> t t2
09:39:19 <desegnis> dmwit: please keep terminology straight. f will not »construct a monad« ;)
09:39:22 <litb> ah the diff form return () is that then f will not need to be a monad anymore
09:39:23 <monochrom> hahaha mauke
09:39:30 <litb> now i really see, i swear
09:39:34 <litb> :)
09:39:41 <ac> huh, I wonder if Jabber could provide a reasonable replacement to HTTP
09:40:08 <litb> s/form/from/
09:40:13 <litb> darn i always mix form and from
09:40:18 <dmwit> litb: Every line in a do-construct has to result in a monadic value, so even then f would have to return a monadic value.
09:40:26 <desegnis> ac, funny idea. what does Jabber provide what HTTP does?
09:40:27 <dmwit> desegnis: (Was that better? =)
09:40:32 <ac> desegnis: two way communication
09:40:36 <litb> dmwit: yeah i understand
09:40:41 <dmwit> ok
09:40:46 <desegnis> dmwit, wonderful :)
09:40:46 <litb> otherwise monads could be hidden from the caller of a function
09:40:51 <monochrom> English is not rich enough to explain monads.
09:40:52 <ac> litb: think you missed the question earlier: just out of curiosity, what're you up to with OpenGL?
09:41:22 <litb> thanks to be so hard with me. i will better learn it then
09:41:36 <litb> oh i see
09:41:50 <litb> ac: i wanted to look into it just out of curiosity :)
09:41:57 <bos> @seen dons
09:41:57 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 23m ago.
09:41:59 <bos> @users
09:41:59 <lambdabot> Maximum users seen in #haskell: 463, currently: 459 (99.1%), active: 31 (6.8%)
09:42:06 <litb> how it would look to prog openGL functionally
09:42:15 <ac> litb: you don't really
09:42:24 <litb> ohh, see it will overflow soon
09:42:28 <ac> litb: practically every OpenGL call has an IO type
09:42:45 <ac> quick, someone get 14 more people to join!
09:42:48 <litb> i see
09:43:05 <dmwit> ac: ...5 more people?
09:43:07 <desegnis> ac, litb: It's entertaining and instructive, though, to write a problem-specific functional layer over OpenGL
09:43:25 <desegnis> or over any drawing library
09:43:39 <litb> i see
09:44:02 <ddarius> @users
09:44:02 <lambdabot> Maximum users seen in #haskell: 463, currently: 456 (98.5%), active: 31 (6.8%)
09:44:11 <ddarius> My client only says 450...
09:44:19 <dmwit> Huh, mine too.
09:44:42 <litb> hm, mine too
09:44:43 <litb> strange
09:44:45 <dmwit> lambdabot: *poke*
09:44:46 <litb> it's biased
09:45:14 <scodil> its because its written in an imperative language. the programmer had an agenda against FP
09:45:33 <litb> some nick with space or ',' in here?
09:45:39 <dmwit> Haskell is an imperative language now?
09:45:46 <litb> maybe it reads it and length's it?
09:46:02 <scodil> i was talking about all the irc clients that are lowballing the #haskell membership figures
09:46:16 <dmwit> oh, heh
09:46:20 <scodil> obviously there are 463 people in here. Would lambdabot lie? But this clients, written in C and whatnot...
09:46:21 <litb> lolz
09:46:27 <scodil> 450. psh. gotta be a bug
09:46:34 <Jiten> Is it better to copy&paste mergesort code from Data.List than to try to find some trick to import it from there?
09:46:49 <ddarius> ... just use sort?
09:47:03 <scodil> Jiten: what do you need to change about it?
09:47:09 <desegnis> Jiten: Prelude.sort is a mergesort
09:47:13 <Jiten> I want tocall mergesort'
09:47:18 <desegnis> ah
09:47:22 <allbery_b> lb out of sync is usually caused by netsplits, isn't it?
09:47:33 <dmwit> ?source Prelude
09:47:33 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
09:47:51 <litb> ah rite might be a netsplit
09:47:58 <dmwit> ?source Data.List
09:47:58 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
09:48:11 <Jiten> I found the source already :)
09:48:18 <dmwit> Jiten: How about sortBy instead?
09:48:21 <litb> in lambdatown there are some more users o.O
09:49:03 <desegnis> Jiten: you would indeed have to copy it. alas, you cannot import functions that are not exported
09:49:41 <Jiten> dmwit: sortBy also calls mergesort, not mergesort'
09:49:52 <ddarius> desegnis: Even if you could, copying it is the correct thing to do.
09:50:13 <dmwit> Also, can I just say that I'm very surprised they did not create a foldb for this?
09:50:38 <desegnis> ddarius, yea
09:50:51 <Jiten> I'd think combining already sorted lists is a frequent need.
09:51:30 <dmwit> mergesort' = foldb . merge_pairs, for a suitable definition of foldb, and foldb would be a perfect candidate for Data.List.
09:51:55 <davidL> foldb' op (x:y:rest) = op x y : foldb' op rest
09:51:55 <davidL> foldb' _ e = e
09:51:55 <davidL> foldb _ b [] = b
09:51:56 <davidL> foldb op b [x] = op b x; foldb op b xs = foldb op b (foldb' op xs)
09:53:03 <dmwit> Something like that, yeah.
09:53:20 <quicksilver> you have the recursion wrong though
09:53:28 <quicksilver> if foldb is one level then you need
09:53:44 <quicksilver> erm
09:53:47 <quicksilver> I don't know what you need :)
09:54:03 <quicksilver> can't see how to define mergesort from foldb in one smooth step.
09:54:31 <quicksilver> you need at least 'partition' which splits a list in half
09:54:41 <dmwit> I don't think so...
09:55:07 <dmwit> foldb1 op (x:y:rest) = foldb (op x y : foldb op rest)
09:55:12 <quicksilver> oh
09:55:14 <dmwit> foldb1 op [x] = x
09:55:48 <Saizan> it's a bottom-up mergesort?
09:55:48 <dmwit> Actually, I guess you need a base case after all.
09:56:52 <dmwit> Oh, no, you can do foldb1 [x, y] = op x y as a first pattern match, then you're ok.
09:57:13 <Cin> is there some way to "pretty print" something that does a little more than the standard that `show' gives you when you derive Show?
09:57:24 <Cin> like, i'm printing the state of my program, but it's all on one line so it's difficult to read
09:57:37 <dmwit> Sure!
09:57:41 <Cin> i could write my own of course, but if there's a way to print it nicer that's standard..
09:57:54 <dmwit> oh
09:57:55 <dmwit> well
09:58:18 <dmwit> I think there's actually a pretty-print library, but I've never used it.
09:58:18 <dmwit> ?hoogle pretty
09:58:20 <lambdabot> No matches found
09:58:23 <Cin> i'll check hackage
09:58:29 <byorgey> Cin: take a look at the pretty-print library, it's nice
09:58:41 <byorgey> Cin: it's actually standard, you probably already have it installed
09:58:46 <byorgey> @hoogle HughesPJ
09:58:46 <lambdabot> No matches found
09:58:55 <byorgey> @hoogle Doc
09:58:55 <lambdabot> Language.Haskell.TH.PprLib.Doc :: type Doc
09:58:56 <lambdabot> Distribution.Simple.InstallDirs.DocDirVar :: PathTemplateVariable
09:58:56 <lambdabot> Distribution.Simple.InstallDirs.docdir :: InstallDirs dir -> dir
09:59:23 <Cin> Language.Haskell.TH.PprLib.Doc this?
09:59:26 <byorgey> no
09:59:29 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/pretty/Text-PrettyPrint-HughesPJ.html
09:59:29 <lambdabot> http://tinyurl.com/yv4loq
09:59:33 <byorgey> that's it =)
09:59:53 <Cin> ah, thanks
09:59:57 <Saizan> package pretty
10:02:45 <Saul_> Does anyone know how file uploads and cgi work in haskell?
10:02:59 <sarehu> generally, the way they work generally
10:03:06 <Saul_> as in one of those <input type="file" /> thingies?
10:03:38 <Saul_> sarehu: Then I guess I want to know that :)
10:04:17 <sarehu> Saul_: have you looked at Network.CGI?
10:04:25 <sarehu> http://www.haskell.org/ghc/docs/latest/html/libraries/cgi/Network-CGI.html
10:04:25 <Saul_> Yup
10:04:26 <lambdabot> http://tinyurl.com/yq53cj
10:05:01 <Saul_> I'm just a bit of a noob when it comes to cgi
10:05:37 <quicksilver> it looks like Network.CGI doesn't distinguish
10:05:43 <quicksilver> although they are different at the protocol level
10:06:06 <quicksilver> Network.CGI lets you 'just' use getInput
10:06:33 <Saul_> quicksilver: I think that just returns the filename
10:06:34 <quicksilver> although the ByteString version would be advised
10:06:40 <quicksilver> if the file is oing to be large.
10:06:46 <quicksilver> Saul_: you sure? it doesn't look like it to me.
10:06:56 <quicksilver> surely that's getInputFilename
10:07:03 <sarehu> Saul_: http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell#File_uploads
10:07:04 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki, http://tinyurl.com/2n99cj
10:07:04 <quicksilver> (unless you've tried)
10:07:33 <quicksilver> yup
10:07:38 <quicksilver> that uses the FPS version
10:07:44 <quicksilver> but that's just for efficiency
10:08:05 <Saul_> Ok I'll try it, getInputs only returns the filename though
10:09:15 <Saul_> Hmmz I think I actually just missed the enctype "multipart/form-data" part
10:10:30 <Saul_> Wooi
10:10:38 <Saul_> that actually fixed everything
10:10:47 <Saul_> I'm seeing some nice binary code now
10:12:37 <Saul_> thanks huys
10:12:41 <Saul_> guys*
10:17:33 <BMeph> ?lusers
10:17:33 <lambdabot> Maximum users seen in #haskell: 463, currently: 446 (96.3%), active: 19 (4.3%)
10:19:37 <ddarius> @sync
10:19:37 <lambdabot> src <id>. Display the implementation of a standard function
10:26:19 <Cin> i don't think Text.PrettyPrint is what i need. although it will be useful for constructing pretty output, i actually meant is it possible to change, how, say, when you have Data Foo = Foo { a,b::Int } it will print Foo { a = <whatever>, b = <whatevre> }, is it instead possible to change that to print Foo {\n a = <whatever>\n b = <whatever>\n}?
10:26:56 <Cin> this sort of inbuilt field printer thing that you get when deriving Show
10:27:08 <byorgey> Cin: you'll have to define your own Show instance.
10:27:12 <ddarius> You can write your own show instance
10:27:32 <Cin> but can i do that for _all_ types deriving Show?
10:27:50 <ddarius> No
10:27:53 <byorgey> unfortunately it isn't possible to 'modify' derived Show instances.
10:28:06 <byorgey> that's something I've kind of wanted before too.
10:28:17 * ddarius hasn't wanted that.
10:28:37 <byorgey> ddarius: good for you. ;)
10:29:24 <Cin> well, nevermind. i'll do it manually for my own types
10:31:17 <ToRA> Cin: can't you do something like class MyShow a where showMe :: a; instance (Show a) => MyShow a where myShow = replace '{' with '{\n' . show
10:31:50 <Cin> tora: i was considering it
10:32:18 <Cin> probably wouldn't be re-usable outside of my program, of course. wouldn't want to mess with other people's implementations of `show'
10:32:29 <ToRA> yeah
10:33:16 <ToRA> kinda related, i've quite often wanted a little tool that parses default show implementations and puts them in a gtk treeview or something...make it easier to see what's what & nicely indented etc
10:33:27 <desegnis> Why does cabal-install say »unresolved dependencies« when attempting to install a package that does not exist?
10:33:40 <Cin> tora: indeed
10:33:42 <ski> @show yourself !
10:33:42 <lambdabot> "yourself !"
10:34:30 <cjb> desegnis: perhaps the dependency tree with a single unresolvable item is a case of the unresolavble dependency tree in general.
10:34:42 <cjb> or somethig.  who knows how these crazy functional programmers do things.
10:34:57 <desegnis> right
10:36:02 <ski> sounds like the expected behaviour, to me
10:36:22 <hpaste>  pitecus pasted "Why wont this compile?" at http://hpaste.org/5401
10:36:29 <PaulAJ> Hi.  I'm looking for help/advice on using code.haskell.org
10:36:39 <dons> PaulAJ: what in particular?
10:37:20 <PaulAJ> I applied for an account last night, but haven't heard anything yet.  Maybe its just that volunteer admins haven't got around to it yet.
10:37:27 <dons> it takes around 24 hours
10:37:31 <paolino> where is ghci readline code ?
10:37:36 <dons> its mostly guys in the UK who maintain it, PaulAJ
10:37:42 <desegnis> ski, the expecte behaviour would be something like, »no such package to fetch«
10:37:42 <dons> so wait for Ross, Malcolm or Duncan
10:37:45 <dons> or Ian
10:37:50 <dons> desegnis: hmm.
10:38:00 <dons> $ cabal install foo
10:38:00 <dons> cabal: user error (Unresolved dependencies: foo -any)
10:38:01 <pitecus> Anyone type function experts around? There is something I dont understand, pasted above http://hpaste.org/5401
10:38:06 <dons> well, that's just cryptic. but harmless
10:38:06 <ddarius> dons: So I need to poke Duncan?
10:38:08 <PaulAJ> I just wanted to check if its my ignorance of the use of ssh that is preventing me from logging in.
10:38:20 <dons> ddarius: about? I thought parsec3 is already enabled?
10:38:26 <ddarius> dons: Is it?
10:38:37 <desegnis> dons, well, harmless... it took me a while to grasp it :)
10:38:46 <dons> desegnis: make a bug report to cabal
10:38:55 <dons> ddarius: code.haskell.org/parsec3
10:38:58 <ddarius> Hmm
10:39:02 <PaulAJ> BTW I applied for the id "paj" and my email is paul at cogito dot org dot uk
10:39:07 <dons> yep.
10:39:11 <desegnis> @where cabal
10:39:12 <lambdabot> http://www.haskell.org/cabal
10:39:15 <ddarius> dons: I didn't get any email.
10:39:23 <dons> ok
10:39:45 <ddarius> But whatever.  Time to get this code out there then.
10:39:57 <PaulAJ> I'll try again tomorrow.  Thanks.
10:40:12 <dons> PaulAJ: ok. thanks for waiting :)
10:40:16 <dons> heya dpiponi
10:40:18 <ddarius> PaulAJ: Malcolm will email you for an account request.
10:40:22 <dpiponi> hi dons
10:40:23 <lambdabot> dpiponi: You have 1 new message. '/msg lambdabot @messages' to read it.
10:40:58 <ski> pitecus : `form' (itym `Form') wants an `a', not a `Result a'
10:41:34 <ski> pitecus : possibly you want to mention `Result a' somewhere in the definition of `Result (Field a)'  (.. or maybe you don't want that)
10:41:42 <desegnis> dons: hm... there is already a bug report about whole a rewriting of the dependency resolution algorithm
10:42:10 <dons> desegnis: i think this is more a little user interface issue
10:42:17 <dons> you just want "no package of that name":
10:42:22 <dons> so its a simple tweak
10:42:34 <pitecus> ski I dont think Im following
10:42:35 <desegnis> yeah sure, but if they're going to change everything anyway...
10:42:49 <desegnis> meh, I'll file that bug anyways
10:43:37 <ski> pitecus : er, i now see that `form' is a selector, sorry
10:44:36 <pitecus> also if i get rid of that last line and then the following seems to work:
10:44:38 <pitecus> *Main>  form $ eval (Index 0) [Tok "form" "lemma" "pos"]
10:44:38 <pitecus> "form"
10:45:15 <ski> pitecus : ok, so the problem is that your `eval a' there, when given the tokens, will return a `Result a', which you can't pass to `form', which wants a `Tok'
10:46:19 <pitecus> but Result Index is the same as Tok no?
10:46:59 <ski> sure
10:47:01 <ski> but in
10:47:07 <ski> instance (Eval a) => Eval (Field a) where
10:47:13 <ski> you have no idea what `a' is
10:47:37 <pitecus> should I make it (Eval (Field Index))?
10:47:50 <ski> i don't know what you want to do
10:49:12 <pitecus> ski Im tryin to translate the same from fundeps
10:49:25 <pitecus> where I have
10:49:28 <pitecus> instance (Eval a Tok) => Eval (Field  a)  String   where
10:49:28 <pitecus>     eval (Form t)     = form  . eval t
10:49:59 <thetallguy> Howdy all, I'm looking for a definition of combinator, as used by the Haskell community.
10:50:13 <thetallguy> B. Pierce says simply that they are closed terms.
10:50:17 <hpaste>  pitecus annotated "Why wont this compile?" with "(no title)" at http://hpaste.org/5401#a1
10:50:34 <pitecus> thats the fundeps version
10:50:42 <thetallguy> John Hughes talks vaguely about function re-use.
10:50:52 <thetallguy> in the pretty-printing paper.
10:51:22 <thetallguy> I have my own inferred definition. I''m looking for what everyone else thinks.
10:51:28 <conal> thetallguy: i think Benli's definition is the classic syntactic def and not how we commonly use the term.
10:51:28 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
10:51:37 <EvilTerran> i tend to use it to mean "higher-order function"
10:51:44 <ski> pitecus : hm, i'm not sure you can translate `Eval a Tok' there .. if you can, surely you must mention `Tok' somewhere in the instance
10:52:00 <ski> pitecus : hmm .. possibly one can do it with an equality constraint
10:52:09 <thetallguy> conal: reference?
10:52:28 <ski>   instance (Eval a,Result a ~= Tok) => Eval (Field a) where
10:52:32 <conal> thetallguy: i'd guess barendregt
10:52:43 <pitecus> ski, ok let me try
10:52:44 <ski> pitecus : i'm not sure if `~=' was the syntax for equality constraints, though
10:52:45 <thetallguy> oh, benli == b. pierce?
10:52:50 <conal> thetallguy: mine is packed in a box.  perhaps someone else has one handy.
10:52:59 <conal> thetallguy: yes benli == b. pierce
10:53:08 <thetallguy> okay
10:53:25 <PaulAJ> thetallguy: In practice it seems to be most commonly used for libraries of functions of the form f :: a -> b -> b
10:53:40 <conal> thetallguy: EvilTerran's is a common use.  and then there's just member of an api in a functional library.
10:54:00 <thetallguy> PaulAJ: yes, that's my inferred definition.
10:54:03 <pitecus> ski, no that gave a cryptic error:     Constraint is no smaller than the instance head
10:54:03 <pitecus>       in the constraint: Result a ~ Tok
10:54:15 <EvilTerran> i guess my meaning tends to be more general than that, actually, seeing as i'd consider const a combinator
10:54:31 <thetallguy> So it seems there has been some imprecision creeping in?
10:54:36 <ski> pitecus : maybe try one of the extensions for relaxed instance heads ?
10:54:50 <PaulAJ> The reason being that they can be composed handily, as newF = (f1 x) . (f2 y) . (f3 p q r)
10:54:53 <Saizan> thetallguy: i think the common use of the terms derives from combinator calculi like SKI
10:54:56 <EvilTerran> i guess i tend to think of parameterically polymorphic functions as combinators, too
10:54:58 <radix> shapr: how about lunch tomorrow instead of dinner tonight? glyph and itamar and exarkun are likely to be around
10:55:05 <Saizan> "term"
10:55:06 <thetallguy> EvilTerran: that fits with Benli's definition, since he gives id as the simplest.
10:55:06 <ski> combinators !
10:55:25 <pitecus> ski, it suggest -fallow-undecidable-instances  but it sounds a bit scary ;-)
10:55:27 <conal> thetallguy: PaulAJ's is probably closest to common use.  an api designed around one or more key types, in which the functions' last one or more parameters are of the key type and produce it.
10:55:38 <EvilTerran> yeah, that works. parameteric polymorphism seems to be the deciding factor in my personal definition
10:55:43 <thetallguy> Saizan: and what, to you, is the definining nature?
10:55:52 * EvilTerran is monologuing
10:55:59 <conal> thetallguy: note that Benli's is a *syntactic* definition, which is very different from what we're discussing (types and semantics)
10:55:59 <ski> pitecus : and that extension was not suggested with the MPTC+FD version ?
10:56:04 <pitecus> nope
10:56:14 <ski> ok
10:56:20 <pitecus> just flexible instances and some such stuff
10:56:20 <thetallguy> conal: yes, my own definition was, functions to construct a complex data type
10:56:29 <EvilTerran> pitecus + ski; that'll be ~ being funny
10:56:57 <ski> pitecus : well, i don't think i know enought about ATs to help much more than suggest that extension (or maybe one of its weaker variants)
10:57:01 <thetallguy> conal: We need to give you a nickname, something like  SemanticsMan
10:57:04 <conal> thetallguy: perhaps simultaneously consume & produce.
10:57:11 <conal> thetallguy: :)
10:57:17 <thetallguy> conal: ParticleMan is already taken.
10:57:24 <pitecus> ski, ok ski thanks at least im getting somewhere
10:57:25 <EvilTerran> pitecus, unfortunately the AT support is really quite buggy at the moment
10:58:01 <pitecus> EvilTerran, well i think its just me being dense
10:58:22 <thetallguy> Okay, good enough, thanks forlks.
10:58:31 <EvilTerran> so it can be hard to tell whose fault a problem involving it is
10:58:41 <EvilTerran> i'd stick to fundeps for now as far as possible, tbh
10:58:57 <conal> hey all -- today is my birthday.
10:59:21 <thetallguy> conal: Happy Birthday!
10:59:32 <conal> thetallguy: :)  thanks
10:59:37 <pitecus> EvilTerran, its mostly to get my head around the AT, but thanks for the advice
10:59:46 <thetallguy> conal: for your present, you get to live in the woods and work on computer science
11:00:01 <conal> thetallguy: dude!  i *love* that present!
11:00:17 <thetallguy> conal: thought you might.
11:00:27 <thetallguy> conal: did I send you the squid run pictures?
11:00:40 <conal> thetallguy: nope
11:00:44 <thetallguy> conal: because my birthday present is to live by the ocean and work on computer science
11:01:01 <byorgey> conal: happy birthday!!
11:01:03 <conal> thetallguy: sweet!
11:01:08 <conal> byorgey: :)
11:01:16 <thetallguy> conal: Oh, that's because I intend to post the dive report on my blog, just busy right now.
11:01:43 <thetallguy> conal: but y'all can gawk in the meantime:  http://stockwits.com/Photos/20080127-LJS-SquidRun/
11:01:43 <lambdabot> Title: 20080127-LJS-SquidRun
11:02:33 <BMeph> Someone edit the topic! But please, don't start any conflicts, because that would make conal sad... ;)
11:02:43 <thetallguy> Exercise for the day: write a Haskell program to show how such an event could have evolved.
11:03:28 <conal> this has been my best year yet.  creative energy & focus back after a few years of mid-life sabbatical.  happy & content.  living with my sweetie in a beautiful place.  lots of time to think & code & write.
11:04:18 <thetallguy> conal: it shows in your code.
11:04:37 <ddarius> Okay.  A parsec3 is on code.haskell.org/parsec3 Have at it.
11:04:39 * ddarius needs to run.
11:04:50 <conal> :).  and more folks are getting interested in functional programming.  how neat is that!
11:06:41 * BMeph presents conal with a fluffy lambda that he held back from one of shapr's mad tossing sprees
11:07:22 <dons> happy birthday conal
11:07:25 <conal> BMeph: thanks.  i'll put it on my pillow. :)
11:07:33 <BMeph> :)
11:08:01 <dons> conal, its been very exciting seeing all the new stuff you're producing :)
11:08:04 <conal> dons: thx!
11:08:21 <dons> good having an FP zen master to remind us when tempted by the dark side :)
11:08:24 <dpiponi> @tell LeCamarade I don't get messages going to sigfpe. But I found what you asked in the log. I don't know much about uniqueness types except I'd like them in Haskell for in-place vector/matrix algorithms.
11:08:24 <lambdabot> Consider it noted.
11:09:19 <conal> dons: :) lots more goodies on the way.
11:09:36 <dons> we've got to do more to drive adoption too
11:09:46 <pejo> conal, happy birthday, and please give us a few teasers on what's in the pipeline!
11:11:14 <byorgey> dons: why?
11:11:30 <nominolo> adoption of what?
11:11:36 <byorgey> dons: I don't disagree, I'm just curious to hear your reasons why widespread adoption is a Good Thing
11:11:43 <conal> pejo: thanks.  i'm working toward a vision & practical tools to do "real" programming purely functionally (no IO); also a neat efficient way to represent infinite continuous imagery (and other functions) as data; and right now a simple basis for arrow-ish frp.
11:11:48 <ski> nominolo : category theory, of course !
11:12:12 <dons> oh, i mean, adoption of the high level approaches conal pioneers
11:12:33 <nominolo> ski: egh
11:12:38 <byorgey> oh, I see.
11:12:38 <dons> ensure we as a community get experience with the techniques, and they start getting used in projects
11:12:46 <dons> but adoption in general is good too :)
11:12:55 <conal> dons: oh!  i thought you mean haskell.  i'm not sure how to inspire folks to come back from IO to functional programming.
11:13:03 <byorgey> indeed, my brother is adopted. =)
11:13:15 <conal> byorgey: lol!
11:13:15 <dons> showing a migration path from existing tools to new ones, is one way, conal
11:13:20 <nominolo> but .. but .. we have to avoid success at any expense
11:13:44 <dons> and trapp^h^h^h encouraging devs on  key projects to use anti-IO approaches
11:13:49 <conal> dons: i think you're right about that.
11:14:10 <dons> its a lot of effort though. needs a champion to push the docs and demos forward
11:14:15 <dons> blogs help too
11:14:33 <dons> those kind where "oh, we can solve this problem with that IO code like this"
11:14:35 * nominolo nominates dons for champion
11:14:46 <nominolo> dons has most XP
11:14:46 <dons> :P
11:14:57 <nominolo> probably also more mana
11:15:02 <bos> for example, the futures posts were fun
11:15:07 <byorgey> not to mention that +5 Lambda of Awesomeness
11:15:41 <conal> bos: glad to hear that.  i enjoy blogging.
11:15:59 <bos> conal: have you turned that code into a package?
11:16:05 <dons> usual haskell community issue : connecting the research guys to the open source hackers, which exposes the bugs and wibbles
11:16:10 <conal> bos: yes:
11:16:12 <conal> @wiki Reactive
11:16:12 <lambdabot> http://www.haskell.org/haskellwiki/Reactive
11:16:18 <bos> schveet
11:16:39 <nominolo> i think that one is missing a bit of the fundamentals
11:16:39 <conal> bos: and now Phooey & GuiTV are on top of Reactive instead of DataDriven
11:16:52 <conal> nominolo: ?
11:17:13 <bos> conal: does Reactive need the same tricks with weakrefs as DataDriven?
11:17:14 <nominolo> i had to transfer concepts from flapjax to understand it
11:17:32 <litb> it's done, my haskell books are on the road :)
11:17:32 <conal> bos: no -- it doesn't have to.
11:17:49 <bos> conal: excellent
11:18:16 <nominolo> conal: maybe i didn't read it closely enough.  or i'd prefer a different path of introduction
11:18:23 <conal> bos: for a bit about why, see http://conal.net/blog/posts/blending-continuity-into-reactive-values/#comment-27
11:18:29 <lambdabot> http://tinyurl.com/3b3ju9
11:18:39 <conal> nominolo: do you mean blog posts, or the wiki page or what?
11:18:55 <nominolo> conal: the wiki page
11:19:03 <conal> nominolo: thanks.  yeah, totally.
11:19:13 <litb> hm, could someone give an example where liftM is enough but fmap is not?
11:19:21 <nominolo> conal: it dives right into implementation issues
11:19:52 <conal> nominolo: yep.  it's sure no intro.
11:19:53 <litb> the picture i have in my head about fmap is that if a type wraps another type, then fmap can call a function using the wrapped type
11:20:00 <litb> is that the right picture?
11:20:25 <byorgey> litb: I think of fmap as applying a function 'inside' a type constructor
11:20:30 <nominolo> conal: i had to connect Reactive = Behaviour, Event = EventStream
11:20:39 <conal> nominolo: it's really more about interface than implementation, but still, very tersely, without no examples.  i guess the examples.
11:20:48 <byorgey> litb: liftM and fmap are the same.  only difference is the type (liftM requires Monad)
11:20:51 <resiak> in a monad, liftM -is- fmap
11:20:54 <conal> nominolo: oh -- you got it
11:21:14 <litb> resiak: i see. is that a law?
11:21:24 <nominolo> conal: though i haven't yet figured out how you transform between both
11:21:33 <byorgey> litb: another way to think of fmap is that it 'lifts' a function a -> b into a function f a -> f b
11:21:44 <nominolo> conal: and i figured, that state is in fact internal to all components involved
11:21:45 <resiak> litb: All Monads ought to be Functors, and then liftM need not exist :)
11:22:07 <byorgey> litb: basically, yes, it's a law, although it's not enforced by the language.
11:22:15 <nominolo> conal: so for my editor i have to decide what will be my state-holding primitive (i.e. line, character, buffer)
11:22:21 <litb> @src (->) fmap
11:22:21 <lambdabot> fmap = (.)
11:22:42 <conal> nominolo: by "state", i guess you mean time-varying?
11:23:06 <nominolo> conal: hm. yes, i think so
11:23:16 <conal> nominolo: i'd expect time-varying lines & buffers
11:23:18 <nominolo> conal: i mean the current value of a slider
11:23:18 <litb> hm, i should have made my Funktion datatype a Num instance really :)
11:23:30 <nominolo> conal: yeah, i think i'll go with lines
11:23:52 <nominolo> conal: but have them as a typeclass, so you can have various levels of sophistication
11:23:54 <conal> nominolo: and if a buffer consists of lines, then you'll have varying (reactive) buffers
11:24:06 <conal> nominolo: sophistication of representation?
11:24:13 <nominolo> conal: exactly
11:24:20 <conal> nominolo: neat :)
11:24:27 <litb> of what buffers do you talk?
11:24:36 <byorgey> can I use the FFI to make bindings to a library written in C++, or do I have to create C wrappers first?
11:24:39 <nominolo> that's stolen from the Deuce editor ;)
11:24:54 <nominolo> litb: files / documents in an editor
11:26:20 <glen_quagmire> i can't understand y combinator
11:27:34 <nominolo> glen_quagmire: what part?
11:28:08 <glen_quagmire> nominolo: expending (Y e) to be (e (Y e))
11:28:33 <nominolo> did you try to evaluate step by step?
11:28:46 <glen_quagmire> nominolo: yah but i'm confused if my parenthesis is right
11:29:08 <nominolo> so far it is :)
11:29:20 <glen_quagmire> Y = \f.((\x.f(xx)) (\x.f(xx))   is this proper parentheis?
11:29:40 <glen_quagmire> or, Y = (\f.(\x.f(xx)) (\x.f(xx)
11:30:19 <glen_quagmire> is Y a lambda with one body or  a lambda with (\x.f(xx)) passed to it?
11:30:23 <nominolo> that doesn't matter really.  fully parenthesized, the latter
11:30:44 <nominolo> it's on  (\x.f(xx)) applied to another
11:30:47 <nominolo> *one
11:31:12 <glen_quagmire> yah that way  i can't get to Y e = e (Y e)
11:31:15 <nominolo> Y = (λf . (λx . f (x x)) (λx . f (x x)))
11:31:32 <nominolo> http://en.wikipedia.org/wiki/Y_combinator#Y_combinator <- has a derivation
11:31:34 <glen_quagmire> but when I consider Y = \f(...)   i can get  Y e = e (Y e)
11:31:36 <FunctorSalad> @slap λ
11:31:36 * lambdabot hits λ with an assortment of kitchen utensils
11:31:42 <FunctorSalad> ;)
11:31:45 <litb> does the book by Birds also cover Y combinator and such things?
11:32:09 <glen_quagmire> nominolo: the wikipedia seems to consider Y as a lambda with one body
11:32:40 <glen_quagmire> the wiki derivation substitues all f with g
11:33:14 <glen_quagmire> but i was first trying to reduce (\f.(\x.f(xx)) (\x.f(xx))    then apply g to it
11:33:20 <glen_quagmire> i mean, pass g to it
11:33:33 <nominolo> you have a missing paren then ;)
11:34:17 <nominolo> with as little parens as possible: \f. (\x.f(x x)) (\x.f(x x))
11:34:17 <glen_quagmire> (\f.(\x.f(xx))    (\x.f(xx))   means you pass (\x.f(xx))  to (\f.(\x.f(xx)) ?
11:34:30 <nominolo> nono
11:34:54 <nominolo> it's  (\f.  ( (\x.f(xx))    (\x.f(xx))  )  )
11:34:56 <glen_quagmire> so, it's   \f.{ (\x.f(xx))(\x.f(xx)) }
11:35:05 <nominolo> exactly
11:35:11 <glen_quagmire> oh then it makes sense
11:35:17 <nominolo> :)
11:35:35 <nominolo> of course, there also is: L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
11:36:01 <nominolo> but that derivation's gonna take a little longer
11:36:52 <Philippa> okay, if I see id $! (f x) where x :: Double and f :: Double -> Double - this is just a cargo cult attempt at strictness that should be reduced to f x, right?
11:37:50 <nominolo> it means the whole application is forced
11:38:01 <nominolo> not sure when you'd want that
11:38:36 <litb> or should i get another book if i want to read about y combinator and stuff?
11:38:45 <FunctorSalad> nominolo: seriously?
11:39:00 <nominolo> FunctorSalad: ?
11:39:06 <FunctorSalad> that combinator
11:39:15 <nominolo> yes
11:39:18 <FunctorSalad> heh
11:39:46 <nominolo> you can build a lot more by following the pattern
11:39:58 <Twey> What does $! do?
11:40:05 <Twey> @src $!
11:40:05 <lambdabot> Source not found.
11:40:07 <nominolo> @src ($!)
11:40:07 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:40:09 <Twey> :-\
11:40:16 <nominolo> >:-[
11:40:25 <twanvl> f $! x = x `seq` f x
11:40:31 <Twey> Ah
11:40:44 <nominolo> it forces the _argument_
11:41:28 <nominolo> Philippa: so, since you're talking about Double, it's probably meant to be f $! x
11:41:51 <phlpp> :t seq
11:41:53 <lambdabot> forall a t. a -> t -> t
11:41:54 <Twey> @src seq
11:41:54 <lambdabot> Source not found. Are you on drugs?
11:41:58 <Twey> -.-
11:42:07 <nominolo> phlpp: seq is a primitive
11:42:23 <phlpp> > (*2) `seq` 2
11:42:24 <lambdabot>  2
11:42:44 <nominolo> > fix id `seq` 2
11:42:44 <lambdabot>  Exception: <<loop>>
11:42:45 <phlpp> > 2 `seq` (*2)
11:42:46 <lambdabot>  <Integer -> Integer>
11:42:59 <phlpp> hehe
11:43:00 <Twey> Does id force evaluation?
11:43:13 <bos> no
11:43:16 <nominolo> fix id is an infinite loop
11:43:23 <nominolo> seq forces the evaluation
11:43:48 <Twey> Ah, OK
11:43:49 <monochrom> > fix seq
11:43:50 <lambdabot>  Add a type signature
11:43:59 <Twey> And is seq magical?
11:44:03 <monochrom> > fix seq :: [[Char]]
11:44:03 <lambdabot>  Couldn't match expected type `[[Char]]'
11:44:23 <monochrom> seq is somewhat magical
11:44:43 <FunctorSalad> but is it good or evil?
11:44:52 <nominolo> depends
11:45:03 <nominolo> just like unsafePerformIO
11:45:10 <FunctorSalad> :)
11:45:54 <nominolo> FunctorSalad: you use it to make parts of your program strict (usually) for better performance.  of course you could also make it non-terminating
11:46:03 <resiak> > fix (\x -> seq x x)
11:46:04 <lambdabot>  Exception: <<loop>>
11:46:21 <resiak> > fix seq 3
11:46:22 <lambdabot>  3
11:46:24 <resiak> woo
11:46:55 <Twey> What's this fix thing?
11:47:02 <nominolo> Y
11:47:03 <Deewiant> @src fix
11:47:04 <lambdabot> fix f = let x = f x in x
11:47:05 <resiak> that surprises me: surely fix seq 3 ==> seq (fix seq) 3
11:48:12 <Twey> ah
11:51:40 <codemac_> which is a more popular XML library for haskell?  haXml?  or the Haskell XML Toolkit?
11:52:50 <monochrom> both
11:53:06 <byorgey> heh, both are more popular? ;)
11:53:14 <monochrom> Yes.
11:54:05 <aFlag> fix more popular
11:54:48 <Philippa> nominolo: actually in the context f $! x wouldn't be much better as f is (unsurprisingly for a func :: Double -> Double) strict too
11:54:48 <codemac_> I don't really intend to create xml files, just read them.. does it really matter which I use then?
11:55:05 <monochrom> don't forget tagsoup
11:56:07 <Philippa> nominolo: anyway, id $! is a waste of time - "if forced, force the thing on the RHS", plus overhead
11:56:27 <Philippa> just wanted to double-check I hadn't missed anything
11:56:57 <resiak> while xml toolkits are under discussion: if I want to create very small RDF queries, which toolkit should I care more about looking at ?
11:57:03 <nominolo> Philippa: yep
11:57:36 <Philippa> IIRC the only non-strict functions :: Double -> Double are _|_ and const x for varying x
11:57:37 <monochrom> In the following, = is mathematical equal.  id $! x = seq x (id x) = seq x x.
11:58:44 <Philippa> monochrom: yeah. But seq x x is just x, no?
11:58:45 <dons> seattle FP group, http://www.haskell.org/pipermail/haskell-cafe/2008-February/038991.html
11:58:46 <monochrom> Perhaps id $! (x y z) is easier to write.
11:58:47 <lambdabot> Title: [Haskell-cafe] NW Functional Programming Interest Group, http://tinyurl.com/yslyz6
11:59:16 <Philippa> monochrom: no, the context was something that confused my dad and should've been the equivalent of map f xs
11:59:19 <ski> Twey : try `fix error'
11:59:52 <Twey> > fix error
11:59:52 <lambdabot>  Exception: <<loop>>
11:59:57 <Twey> ski: Fail
11:59:58 <Twey> :-P
12:00:33 * ski 's versions of hugs and ghci behaves funny for `fix error'
12:00:56 * Twey 's says "not in scope: fix"
12:01:28 <ski> Twey : try loading `Control.Monad.Fix' .. or prepend `let fix f = let x = f x in x in '
12:01:28 <monochrom> Perhaps for all expression x and for all context C, C[x] = C[seq x x].
12:01:57 <Twey> Hehe.
12:02:01 <Twey> Exceptions.
12:03:27 <shachaf> dons: Is that group related to SeaFunc at all?
12:03:44 <ski> (`interact error' can also behave funny, btw)
12:03:46 <monochrom> fix is now also in Data.Function.
12:04:10 <dons> shachaf: can't tell
12:04:14 <thetallguy> NewsFlash: Microsoft buys Yahoo, rewrites everything in Haskell
12:04:16 <dons> maybe its just typed FP?
12:04:41 <BMeph> What's with THAT module name? "Data.Function"? What's next, Control.Array? :p
12:04:49 * shachaf wonders why all theses groups pick Wednesday as their meeting day.
12:05:42 <shachaf> I have two classes on Wednesday evening, I already have to miss one of them regularly. :-(
12:05:43 <monochrom> Text.Array
12:05:50 <monochrom> Control.Parser
12:05:55 <shachaf> Is Greg Meredith in here, by any chance?
12:06:14 <resiak> Monad.Monad
12:06:41 <shachaf> dons: Indeed, SeaFunc seems to be composed of mostly LISPers, I think.
12:07:02 <monochrom> Graphics.SQL
12:07:02 <byorgey> Value.Closure
12:07:51 <monochrom> Foreign.Haskell
12:19:08 <Twey> @src group
12:19:08 <lambdabot> group = groupBy (==)
12:20:31 <Twey> Huh
12:20:36 <Twey> ghci gets cold.
12:21:13 <Twey> If I leave it open without doing for a while, it goes very slow, but after a few expressions it's back to its old self.
12:21:17 * Twey shakes his head.
12:21:27 <Twey> Some sort of optimisation perhaps?
12:21:32 <ski> it's sleepy
12:21:42 <monochrom> I have never seen it.
12:22:15 <monochrom> You have little RAM and you experience swapping.
12:22:22 <int-e> Twey: check the memory usage on your machine, maybe its getting swapped out.
12:24:56 <Twey> I have 2GB... should be enough
12:25:01 * Twey shrugs.
12:25:33 <Twey> What's the "repeat list" function in Haskell?
12:25:40 <cjb> cycle, perhaps?
12:25:46 <cjb> > cycle [2,3,4]
12:25:49 <lambdabot>  [2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3...
12:25:58 <Twey> Nope
12:26:01 <Twey> Close
12:26:03 <sarehu> > repeat 1
12:26:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:26:12 <cjb> aww.  I almost answered a Haskell question.
12:26:12 <Twey> But only a limited number of times
12:26:17 <balodja> > replicate 3 [2,3,4]
12:26:17 <sarehu> replicate 20 1
12:26:18 <lambdabot>  [[2,3,4],[2,3,4],[2,3,4]]
12:26:23 <cjb> > take 2 cycle [2,3]
12:26:23 <lambdabot>  Couldn't match expected type `[a]'
12:26:24 <Twey> Aha
12:26:26 <byorgey> > concat . replicate 3 $ [2,3,4]
12:26:26 <lambdabot>  [2,3,4,2,3,4,2,3,4]
12:26:36 * Twey nods.
12:26:40 <Twey> That looks right, thanks.
12:26:49 <cjb> aw.  why was mine wrong, out of curiosity?
12:27:04 <BMeph> Twey: I was going to say, don't keep us in suspence, pick one! ;)
12:27:04 <byorgey> shachaf: ah, well, in that case it will break =)
12:27:06 <dv\> > take 2 (cycle [2,3])
12:27:07 <lambdabot>  [2,3]
12:27:09 <byorgey> argh, mischan
12:27:45 <Twey> BMeph, I *was* going to explain it more carefully, but everyone started throwing answers anyway, so I figured I should let them have their fun :-P
12:28:17 <Twey> cjb, I guess I could have used yours then taken n * length originalList, but it seems messy.
12:28:25 <BMeph> Twey: Well, that's what happens when you throw problems at starving lambdas... ;)
12:28:43 <Cin> λ_λ
12:29:36 <BMeph>    λ
12:29:43 <BMeph> <(  <)
12:29:49 <Twey> Haha
12:29:57 <Saul_> I'm having a bit of a problem
12:30:11 <Saul_> I'm trying to make this Html form thingy
12:30:25 <Cin> twey: writing anything cool in haskell?
12:30:45 <Saul_> And when people fill out a text field, I want to do some processing on it afterwards
12:31:01 <Twey> @pl (\x l -> concat . replicate x $ l)
12:31:01 <lambdabot> (join .) . replicate
12:31:19 <Twey> @src join
12:31:19 <lambdabot> join x =  x >>= id
12:31:22 <Saul_> Using the Either monad to set up a pipeline of tests and mutations seems sensible
12:31:40 <Twey> Hm, Monad-y
12:31:53 <Twey> Cin, not yet, I suck too much :>
12:32:07 <Saul_> for example first trying to parse the string to an integer, then check whether it's bigger than 37 and then smaller than 42 for example
12:32:24 <Saul_> the problem comes though when I make the text field optional
12:32:34 <Twey> Cin: When I get decent I think I'll try my hand at a parser.
12:33:25 <BMeph> Saul_: Yeah, I'd recommend not testing an unfilled text field - bad juju. ;)
12:33:34 <shachaf> > liftM2 take length cycle [1,2,3]
12:33:36 <lambdabot>  [1,2,3]
12:33:47 <Saul_> this would mean that the empty string should be value Nothing, while if it isn't, the same as above should happen (except that it will should wrap the eventual value into a Just)
12:34:37 <Saul_> any suggestions on how to do that easily?
12:34:55 <Cin> twey: fun
12:35:19 <shachaf> Twey: join f x = f x x, in (r ->).
12:35:49 <Saul_> BMeph: I figured that, so I need to somehow wrap the pipeline into a maybe
12:36:11 <Saul_> Only the Maybe must be inside the Either
12:37:51 <BMeph> Saul_: Sounds like you'll want a Maybe no matter what. Unless you specifically want to catch odd parsings and carry the error on after your  processing.
12:37:56 <Twey> shachaf: I don't get join, so I'm staying away :-)
12:38:01 <Saul_> so instead of going String -> Either Error a, I need String -> Either Error (Maybe a)
12:38:24 <shachaf> Twey: join isn't scary, and it's especially useful in @pl-ing.
12:38:49 <shachaf> Twey: join f x = f x x in (r ->), and it's actually a nice way of defining monads in general.
12:38:59 <Saul_> BMeph: Well if the field is not empty, but the value doesn't parse properly or is below 37 it should return an error stating that
12:39:09 <BMeph> Saul_: Eh, I'll let one of our resident parser genii carry on with this, my parser fu is weak. ;)
12:39:11 <shachaf> Twey: join :: (Monad m) => m (m a) -> m a, so it's concat for lists, for example.
12:39:17 <Twey> shachaf: It looks monad-ish, and while I *kind* of understand monads, I'm not entirely confident with them yet, so I'm just sort of working around them for the moment :-)
12:39:39 * shachaf likes join/fmap/return more than (>>=)/return for a lot of things.
12:40:53 <Twey> Is there an "take every n items" function?
12:40:55 <shachaf> Twey: The monads are everywhere; you can't work around them.
12:41:09 <shachaf> Twey: You mean, split a list?
12:41:29 <Twey> E.G. notTake 2 ['a', 'b', 'c', 'd'] ==> ['a', 'c']
12:42:18 <Twey> shachaf: I'm doing remarkable well right now, I'm reviewing a load of Haskell basics without touching them :>
12:42:26 <Twey> (mostly in GHCi, admittedly)
12:42:27 <resiak> > let takeEvery n [] = []; takeEvery n (x:xs) = x:takeEvery n (drop (n-1) xs)
12:42:27 <lambdabot>  Parse error at end of input
12:42:29 <Saul_> BMeph: Ok thanks anyway
12:42:36 <resiak> > let takeEvery n [] = []; takeEvery n (x:xs) = x:takeEvery n (drop (n-1) xs) in takeEvery 2 ["abcd"]
12:42:37 <lambdabot>  ["abcd"]
12:42:47 <resiak> *blink*
12:42:48 <Saul_> So are there any parser dudes out there that can help me?
12:42:51 <resiak> oh.
12:42:52 <byorgey> heh, drop the [ ]
12:42:53 <resiak> > let takeEvery n [] = []; takeEvery n (x:xs) = x:takeEvery n (drop (n-1) xs) in takeEvery 2 "abcd"
12:42:54 <lambdabot>  "ac"
12:42:55 <Twey> Heh
12:43:02 <Twey> Is that a "no?"  :-)
12:43:33 <byorgey> Twey: yeah, there's not a standard function that already does that
12:43:40 <Twey> Thanks
12:43:52 <Twey> Just wanted to check before I made my own :-)
12:44:48 <Twey> @src drop
12:44:48 <lambdabot> drop n xs     | n <= 0 =  xs
12:44:48 <lambdabot> drop _ []              =  []
12:44:48 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
12:44:56 <shachaf> > catMaybes . zipWith ($) (cycle [Just, const Nothing]) $ "abcd"
12:44:56 <lambdabot>  "ac"
12:44:57 <byorgey> Saul_: sounds like you want MaybeT?
12:45:32 <resiak> shachaf: heh, generalize with replicate (n-1) (const Nothing) ?
12:45:33 <byorgey> @unmtl MaybeT (Either String)
12:45:34 <lambdabot> MaybeT (Either String)
12:45:45 <Saul_> byorgey: Possibly, I'm just not very familiar with the monad transformers
12:45:48 <byorgey> @unmtl MaybeT (Either String) a
12:45:48 <lambdabot> err: Unknown MTL(1)
12:46:18 <byorgey> Saul_: MaybeT turns  m a  into m (Maybe a)
12:46:21 <Saul_> byorgey: Can you give an example?
12:47:09 <byorgey> Saul_: unfortunately, I know it just well enough to be able to muddle through it myself, not well enough to explain it =P
12:47:39 <Saul_> byorgey: Ok, well I'll take a look if it's what I need
12:47:44 <Saul_> byorgey: Thanks
12:50:46 <Saul_> Ok another noob question, what library is MaybeT in?
12:50:53 <byorgey> hehe, check out the social network... quicksilver looks like a big friendly spider there  =)
12:51:47 <RayNbow> @hoogle MaybeT
12:51:48 <lambdabot> Data.Maybe.maybeToList :: Maybe a -> [a]
12:51:54 <byorgey> Saul_: oh, hehe, looks like it's not actually in the standard libs yet
12:51:56 <byorgey> http://www.haskell.org/haskellwiki/New_monads/MaybeT
12:51:57 <lambdabot> Title: New monads/MaybeT - HaskellWiki
12:51:59 <RayNbow> hmm
12:52:12 <shachaf> byorgey: Is that somewhere in @where?
12:52:21 <byorgey> @where MaybeT
12:52:21 <lambdabot> I know nothing about maybet.
12:52:29 <byorgey> shachaf: no idea.
12:52:50 <Saul_> :(
12:53:58 <shachaf> byorgey: Do you have a link, then?
12:54:20 * shachaf is assuming you're talking about that auto-generated image of IRC users?
12:54:32 <byorgey> shachaf: oh! I thought you were talking about MaybeT =)
12:54:35 <byorgey> shachaf: it's in the topic
12:54:56 <shachaf> Oh, sorry. :-)
12:55:28 <FunctorSalad> would there be a difference between maybeT and "liftM Just"?
12:55:28 <byorgey> Saul_: it's pretty common though.  Just save the code on that page into a file Control/Monad/Maybe.hs (relative to where you need to use it).
12:56:10 <shachaf> FunctorSalad: MaybeT is like the Maybe Monad.
12:56:32 <FunctorSalad> @type liftM Just
12:56:34 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m (Maybe a1)
12:58:21 <RayNbow> hmm, http://haskell.org/haskellwiki/Monads_as_Containers contains a nice, simple explanation of what a Functor is... shouldn't this be copied to http://haskell.org/haskellwiki/Functor which is practically empty?
12:58:51 <RayNbow> (or the other way around, let the Functor entry refer to the Monads_as_Containers entry)
13:00:02 <shachaf> FunctorSalad: Why is that like MaybeT?
13:01:08 <FunctorSalad> shachaf: I don't know maybeT, was just going from its signature that was mentioned above
13:01:41 <shachaf> FunctorSalad: Do you know how the Maybe monad behaves, and how monad transformers behave? :-)
13:02:07 <FunctorSalad> yes/no
13:03:48 <FunctorSalad> as I said, I just presumed it would look like that from hearing that its type was (m a -> m (Maybe a))
13:05:14 <shachaf> FunctorSalad: The MaybeT monad transformer "transforms" any monad into one that supports Just/Nothing.
13:05:48 <shachaf> FunctorSalad: (And treats them the same way as the Maybe monad.)
13:07:53 <byorgey> FunctorSalad: sorry, I didn't really mean that was its type, just that that was sort of its 'behavior'
13:08:11 <byorgey> it was a fairly vague hand-wavy statement, as statements go. =)
13:08:18 <FunctorSalad> oh, I see :)
13:08:50 <byorgey> if you want to be technical, of course, since it's a type constructor, it doesn't actually have a type, just a kind
13:09:00 <FunctorSalad> yeah
13:09:13 <byorgey> (* -> *) -> * -> *  to be exact, I believe =)
13:09:19 <paolino> @seen visof
13:09:19 <lambdabot> I saw visof leaving #haskell-blah and #haskell 1h 32m 31s ago, and .
13:09:36 <Saul_> It seems that MaybeT solves my problem
13:10:12 <byorgey> Saul_: great! did you get it to work?  or you're just saying in general it looks like it will do what you want?
13:10:52 <Saul_> byorgey: Actually I'm not sure if I used it yet :S
13:11:07 <Saul_> I did a liftM Just on what I had
13:11:49 <Saul_> so nevermind
13:11:56 <Saul_> I'll check back later
13:11:59 <Zao> Is there any way to specify global arguments to 'cabal install'? Remembering to specify library and include paths for every package I install is a bit cumbersome.
13:12:05 <byorgey> Saul_: oh, well, you can probably do that sort of thing too.  MaybeT doesn't actually give you anything that you couldn't already do explicitly without it.
13:12:16 <Zao> Where by arguments I mean things like "--ghc-option=-I$PFX/include --hsc2hs-option=--lflag=-L$PFX/lib"
13:12:27 <byorgey> Saul_: it just handles some 'boring plumbing' for you so you can focus on more important things
13:12:47 <Saul_> byorgey: I know
13:13:10 <Saul_> byorgey: Although if the field isn't optional, the whole plumbing is rather unnecessary
13:14:07 <byorgey> Saul_: true
13:14:27 <FunctorSalad> @type maybe -- theres also this convenience function in the standard library
13:14:45 <FunctorSalad> @type maybe
13:14:59 <EvilTerran> ?bot
13:15:07 <EvilTerran> :(
13:15:16 <FunctorSalad> oh noes poor lambdabot :(
13:16:14 <shachaf> dons?
13:19:05 <shachaf> dons: You should run a second copy of lambdabot to watch the first copy. :-)
13:21:50 <dmwit> maybe :: b -> (a -> b) -> Maybe a -> b
13:22:20 * dmwit looks it up and discovers he got it right! =D
13:24:17 <hpaste>  Saul_ pasted "Wrapper for Either" at http://hpaste.org/5402
13:24:55 <Saul_> I have made a function that just wraps the entire monadic function
13:25:11 <dmwit> That looks like it has a few errors.
13:26:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:26:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:26:17 <lambdabot> :)
13:26:24 <dmwit> bwuh
13:26:28 <dmwit> laaaaag
13:27:06 <dmwit> Saul_: Are you sure that does what you want it to do?
13:27:17 <hpaste>  Saul_ annotated "Wrapper for Either" with "Minus the errors" at http://hpaste.org/5402#a1
13:27:27 <dmwit> Saul_: In particular, are you sure you don't want to apply f to the empty list?
13:27:37 <Cin> @hoogle (\x y -> x y)
13:27:37 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\x y -> x '
13:27:43 <Cin> @hoogle \x y -> x y
13:27:43 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\x y -> x '
13:27:52 <Saul_> dmwit: I'm sure, that's the whole point
13:27:58 <dmwit> ?. hoogle type \x y -> x y
13:27:59 <lambdabot> Did you mean: Forall t T1. (t -> T1) -> t -> T1
13:27:59 <lambdabot> Prelude.const :: a -> b -> a
13:27:59 <lambdabot> Prelude.seq :: a -> b -> b
13:28:02 <nelhage> hoogle takes a type sig, not a code fragment
13:28:15 <dmwit> Saul_: ok
13:28:26 <Cin> > seq id 1
13:28:27 <lambdabot>  1
13:28:30 <Cin> hurrah
13:28:31 <dmwit> Saul_: May I make a suggestion?
13:28:33 <Cin> thanks, dmwit
13:28:47 <Saul_> dmwit: Of course
13:28:49 <dmwit> > seq 32 1 -- not yet
13:28:49 <lambdabot>  1
13:29:01 <dmwit> > ($) (+1) 1
13:29:01 <lambdabot>  2
13:29:06 <Cin> seq == K combinator?
13:29:09 <dmwit> Cin: You probably want ($)
13:29:19 <dmwit> Cin: yes, with side effects
13:29:26 <Cin> ahh
13:29:39 <dmwit> :t guard
13:29:39 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:29:43 <Cin> yes i probably do want ($)
13:29:54 <ski> k = return
13:30:00 <dmwit> k = consnt
13:30:11 <Cin> isn't k just a -> m a ?
13:30:16 <Cin> err, return
13:30:32 <Cin> n/m
13:30:34 <dmwit> Cin: In the (r ->) monad...
13:31:39 <Saul_> dmwit: Did I miss the suggestion, or is it still coming?
13:32:00 <dmwit> Saul_: I'm trying to decide if what I'm suggesting is actually better. =P
13:32:03 <BMeph> Cin: It goes: in the ((->) r) monad, return = const (which is K), and (>>=) works like S
13:32:19 <ddarius> ap is S
13:32:45 <Cin> bmeph: right
13:33:02 <glen_quagmire> Conception, evolution, and application of functional programming languages    is this a good paper?
13:34:09 <dmwit> Saul_: Never mind.
13:34:29 <Saul_> dmwit: Ok
13:34:34 <Cin> 137  makeTestState = do
13:34:35 <Cin> 138    ch <- newChan -- chan that we won't use
13:34:38 <Cin> 139    let changes = [stateAddUser 0 "Cin" ch, stateAddUser 1 "Dave" ch]
13:34:40 <Cin> 140    return $ foldr ($) defaultState changes
13:34:47 <Cin> easier than messing about with temporary variables ^_^
13:38:29 <Cin> :t ($)
13:38:29 <lambdabot> forall a b. (a -> b) -> a -> b
13:39:52 <Cin> oh, duh
13:40:45 <bos> @hoogle eof
13:40:46 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
13:40:46 <lambdabot> Text.Read.EOF :: Lexeme
13:40:46 <lambdabot> Text.Read.Lex.EOF :: Lexeme
13:40:52 <bos> @hoogle EOF
13:40:52 <lambdabot> Text.Read.EOF :: Lexeme
13:40:52 <lambdabot> Text.Read.Lex.EOF :: Lexeme
13:40:52 <lambdabot> Text.ParserCombinators.Parsec.Combinator.eof :: Show tok => GenParser tok st ()
13:41:44 <Cin> @hoogle ($)
13:41:45 <lambdabot> Did you mean: ($)
13:41:45 <lambdabot> Prelude.undefined :: a
13:41:45 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
13:42:01 <Cin> yes, i meant what i said. hur hur
13:44:36 <glen_quagmire> :t map2
13:44:37 <lambdabot> Not in scope: `map2'
13:44:43 <glen_quagmire> map2 is zipWith right?
13:45:27 <ddarius> glen_quagmire: Likely.  map2 is a long shot from completely specifying what you intend by it.
13:45:33 <dmwit> I've never heard of map2.
13:46:14 <glen_quagmire> oh thanks. i was reading a paper written in 80's. haskell probably had map2 back then
13:46:25 <byorgey> one generalization of map to more arguments would be zipWith, yes.
13:46:32 <ddarius> Haskell didn't exist until the 89 at the earliest.
13:47:19 <glen_quagmire> oh "... **would** be written in modern language like Haskell as ..."
13:50:58 <nelhage> I have a question about the example at http://haskell.org/haskellwiki/Introduction_to_QuickCheck -- I am correct in saying that the refactored getList is not actually the same as the original, in that the refactored will leave stdin in a semi-closed state?
13:51:13 <nelhage> s/I am/Am I/
13:55:33 <Cale_> nelhage: right, but I think the point was testing the non-IO stuff anyway
13:57:03 <grahamhutton> @users
13:57:03 <lambdabot> Maximum users seen in #haskell: 465, currently: 458 (98.5%), active: 21 (4.6%)
13:57:21 <Cale_> nelhage: It would perhaps have been more fair if it were refactored such that the remainder of the string were produced as well.
14:00:04 <ac> So I figure it's better to just make a new data type then use something like "Either Foo (Either Bar Baz)"
14:00:39 <dmwit> agreed
14:00:40 <nelhage> Cale_: Sure, I get the point. I just wanted to make sure I was right when my gut reaction was ``Wait, doesn't that render stdin forever unusable?''
14:01:22 <Cale_> ac: It depends what you're doing, but typically, yes.
14:06:22 <BMeph> glen_quagmire: Join my campaign - think of, and refer to, "map" as "zipWith1". ;)
14:12:24 <ddarius> BMeph: map is also liftM(1).
14:13:03 <BMeph> ddarius: But everyone knows that liftM is an abomination that deserves to die. ;)
14:13:11 <dmwit> and fmap!
14:13:23 <sarehu> f is for phony
14:14:08 <ddarius> BMeph: There is nothing abominal about liftM and the point is, thinking about "map" as "zipWith1" emphasizes one axis of generalization and ignores another.
14:14:40 <BMeph> ddarius: Which?
14:14:45 <sarehu> liftM is good simply because it only assumes Monad, not Functor, giving less to type (and assume!)
14:14:57 <ddarius> return, liftM, liftM2, lift3, ...
14:15:37 <ddarius> v. repeat, map, zipWith, zipWith3, ...
14:15:41 <dmwit> Functor is less of an assumption than Monad.
14:15:52 <sarehu> dmwit: if you already have Monad m => on there
14:15:56 <jethr0> and at least in theory monad should imply functor, no?
14:16:08 <dmwit> sarehu: All monads are also functors.
14:16:23 <ddarius> But not all Monads are Functors.
14:16:32 <dmwit> right =/
14:16:36 <BMeph> Huh?!? o.O
14:16:55 <dmwit> BMeph: It's a matter of theory versus Haskell.
14:16:59 <jethr0> isn't monads a superset of functors?
14:17:11 * ddarius recently changed some code in Parsec from fmap (fmap (fmap (fmap ...))) to liftM (fmap (liftM (fmap ...))) to change a Functor constraint into a Monad constraint.
14:17:14 <sarehu> the Prelude says...   class  Monad m  where   ...
14:17:17 <jethr0> ah, you were playing the uppercase/lowercase game ;)
14:17:18 <dmwit> In category theory, all monads are functors, but in Haskell, there is no such restriction.
14:17:24 <sarehu> and not class Functor m => Monad m where ....
14:17:42 <BMeph> Are some Monads not Functors by accident, or by design?
14:17:47 <dmwit> sarehu: Right, it isn't enforced by Haskell. =/
14:17:57 <dmwit> BMeph: Mostly oversight.
14:18:16 <dmwit> instance Monad m => Functor m where fmap = liftM -- easy
14:19:01 <resiak> ddarius: this is when you want (.) = fmap ? :)
14:19:50 <ddarius> resiak: No
14:20:24 <grahamhutton> haskell doesn't allow you to enforce the full details of what's required to be a functor/monad, but the full details are important, and anything that doesn't satisfy these isn't really a functor/monad
14:21:18 <grahamhutton>   BMeph: so every monad is a functor, but not vice versa
14:22:25 <BMeph> I mostly don't like the whole liftM series because it doesn't share the same relationship to lift as other --M functions do to the corresponding --
14:23:25 <FunctorSalad> <$> is most readable anyway ;)
14:23:30 <grahamhutton> i'm not keen on liftM either; the resulting code just looks ugly, and is incomprehensible to a large faction of haskell programmers.
14:23:37 <ddarius> BMeph: That's lift's fault, not liftM's.  liftM was around before lift.  liftM is also standard.
14:23:45 <BMeph> grahamhutton: Oh, I had no illusions on that line, but that part isn't where the issue lies.
14:24:43 <grahamhutton> BMeph: I don't understand your comment that "Are some Monads not Functors by accident, or by design?" then
14:24:46 <FunctorSalad> > (* 2) <$> [1,2,3]
14:24:48 <lambdabot>  [2,4,6]
14:24:50 <FunctorSalad> \o/
14:25:05 <grahamhutton> every monad must be a functor, or its not a monad...
14:25:35 <litb> <$> is ap ?
14:25:43 <ddarius> BMeph: Anyway, the non-'M' version of liftM is just id, i.e. it's trivial.
14:25:51 <BMeph> ddarius: That is true. I still don't like it. I do, however, like how map fits neatly into the "zipList"/stream form of... Applicatives, if not (as yet in an official module) a Monad
14:25:54 <FunctorSalad> litb: it's for Applicatives
14:25:59 <FunctorSalad> @type (<$>)
14:25:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:26:11 <FunctorSalad> oh, that one works even for functors
14:26:14 <litb> ah, it's fmap
14:26:30 * ac is sick of BMeph's campaign
14:26:41 <FunctorSalad> yeah but infix
14:26:55 <BMeph> darius: That's another thing, though - id is sneaky. It's a trivial definition, but it interacts with other type-sensitive functions in unusual ways.
14:27:30 <BMeph> litb: Right, and <*> is ap.
14:27:32 <litb> i'm still confused by liftM2 id =)
14:27:48 <ddarius> <*> is only ap if the Applicative is a Monad
14:27:56 <ac> litb: simply a two argument version of liftM
14:28:04 <nelhage> :t liftM2 id
14:28:04 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
14:28:11 <ddarius> litb: Write it as liftM2 ($)
14:28:14 <litb> yes, sure but i always forget what the id is doing exactly there
14:28:46 <ddarius> ($) = id
14:28:58 <ac> @src ($)
14:28:58 <lambdabot> f $ x = f x
14:29:02 <ac> ;)
14:29:10 <litb> > length `id` "hello"
14:29:11 <lambdabot>  5
14:29:12 <litb> i see
14:29:24 <ac> @info ($)
14:29:24 <lambdabot> ($)
14:29:39 --- mode: ChanServ set +b palomer!*@*
14:29:44 <FunctorSalad> @type liftM2
14:29:44 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:29:47 <ddarius> @undo ($)
14:29:48 <lambdabot> ($)
14:29:57 <FunctorSalad> it considers id as :: a2 -> r I think
14:30:10 <FunctorSalad> err, (a2 -> r) -> (a2 -> r)
14:31:31 <litb> so a1 == a2 -> r i suppose
14:31:32 <BMeph> Well, off the chat for a while, breathe free from my invidious campaign, ac! ;)
14:31:50 <ddarius> :t liftM2 id
14:31:51 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => m (a2 -> r) -> m a2 -> m r
14:33:16 <litb> @src ap
14:33:16 <lambdabot> ap = liftM2 id
14:33:24 <litb> @src liftM2
14:33:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:43:43 <litb> (const (*2)) `ap` (Just 5)
14:43:48 <litb> why doesn'T that work?
14:43:59 <litb> but this does work: (return (*2)) `ap` (Just 5)
14:44:04 <litb> why is that?
14:44:11 <litb> return = const for (->)
14:44:34 <conal> litb: you're mixing monads
14:45:26 <Saizan> litb: that return is in the Maybe monad
14:46:19 <litb> oh right
14:47:25 <opqdonut> :)
14:48:55 <dons> ?remember Jerzy it takes light 10^(-42) sec. to cross the diameter of a proton,
14:48:55 <dons> although if I were light, I wouldn'd do such silly thing. Fortunately
14:48:55 <lambdabot> Done.
14:48:57 <dons> I am heavy.
14:48:59 <dons> grr
14:49:11 <dons> ?remember Jerzy it takes light 10^(-42) sec. to cross the diameter of a proton, although if I were light, I wouldn'd do such silly thing. Fortunately I am heavy.
14:49:11 <lambdabot> I will remember.
14:49:13 <ac> Writing a data structure for a PNG image along with basic constructors and accessors is turning out to be a difficult process for me (not particularly used to statically typed languages). For each part of the data structure there are often several different possibilities
14:50:19 <siti> wow haskell really is growing
14:50:29 <siti> 440 people...
14:51:51 <shachaf> @forget Jerzy it takes light 10^(-42) sec. to cross the diameter of a proton,
14:51:51 <lambdabot> Done.
14:51:56 <hpaste>  TauPan pasted "bad ripoff of ThreeColumns.hs" at http://hpaste.org/5403
14:51:58 <dons> siti: i'm hoping for 500 this year
14:52:02 <plate> 137 of them are random bouncers ive thrown in to hack the TIOBE contest
14:52:03 <siti> yeah :)
14:52:10 <dons> plate: awesome
14:52:19 <plate> (not really)
14:52:30 <litb> lol
14:52:36 <Lemmih> dons: That's not much growth compared to last year.
14:52:45 <plate> does anyone know tiobe metrics?
14:52:49 <siti> dons: the haskell lib package set is getting really really impressive too :)
14:55:15 <dons> Lemmih: I'm unsure. I think we're still growing at 50 users/ 6 months
14:55:23 <dons> i'd have to check.
14:55:30 <siti> is there a nice graph ;)
14:55:34 <dons> didn't we reach 400 only in Sept07?
14:55:37 <dons> ?users
14:55:37 <lambdabot> Maximum users seen in #haskell: 465, currently: 444 (95.5%), active: 22 (5.0%)
14:55:43 <dons> so that's a new high score today
14:56:30 <siti> :D
14:57:47 <litb> today we were near the new record
14:57:49 <hpaste>  TauPan annotated "bad ripoff of ThreeColumns.hs" with "Error message" at http://hpaste.org/5403#a1
14:57:53 <ac> For example right now I'm puzzling over something as simple as the background color. The problem is it can either be a Word8, a 3-tuple of Word16s, or just a Word16
14:57:56 <dolio> @check \f g p@(a,b) -> (f a, g b) == ((f *** g) (p :: (Int,Int)) :: (Int, Int))
14:57:57 <lambdabot>  OK, passed 500 tests.
14:58:21 <ac> Should I have "setBackgroundIndexed", "setBackgroundRGB", and "setBackgroundGrey"? That seems annoying
14:58:56 <shachaf> dons: @pl should know about (***).
14:58:59 <litb> setBgIdxed setBgRGB setBgGrey if i were you
14:59:04 * shachaf sees that he's already late. :-)
14:59:12 <nelhage> What's wrong with something like data BGColor = BGIndexed ... | BGRGB ... | BGGrey ... ?
14:59:44 <dons> shachaf: we need to teach it
14:59:46 <litb> ah, that's what you talk about
14:59:53 <sclv_> onor mcbride's post on that thread is still blowing my mind.
15:00:02 <shachaf> dons: It should learn automatically from the examples given in #haskell. :-)
15:00:57 <ac> nelhage: nothing I suppose. Yeah obviously I should just export another data type
15:00:59 <litb> o.O but then there is need for gurupoints, not that it learns from the wrong people
15:02:13 <ac> And I could make it throw some sort of error if you set a BGIndexed on an RGB image, for example
15:04:24 <ddarius> dons: Lambdabot's counting is wildly inaccurate currently.
15:04:39 <litb> someone suggested [ exp e | e <-[0..] ]  for that curve, siti
15:04:44 <litb> oh darn he left
15:05:06 <litb> dons: didn
15:05:24 <litb> errm sorry 'bout that poor irssi
15:08:41 <glen_quagmire> BMeph: why not just zip? zipWith :: (Function taking N arguments) -> N Lists -> List
15:10:20 --- mode: ChanServ set +b *!n=palomer@*
15:14:35 <jethr0> @paste
15:14:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:16:03 <hpaste>  jethr0 pasted "nqueens" at http://hpaste.org/5405
15:16:17 <jethr0> any ideas why the paste isn't blazingly fast?
15:16:18 <shapr> radix: lunch tomorrow sounds like a better choice.
15:16:48 <jethr0> i guess i need strictness annotations or sth
15:16:49 <radix> shapr: excellent.
15:17:39 <jethr0> ac, are you writing an imaging library?
15:19:06 <ac> jethr0: yeah, a pure Haskell libpng
15:19:12 <ac> jethr0: it's called PHPNG
15:19:26 <ddarius> PHP Next Generation
15:19:35 <jethr0> nice, i'm just about to finish a binding to freeimage to make importing and exporting images "easier" in haskell
15:19:48 <ac> ddarius: aaahg, I'll never look at that initialization the same way again
15:20:18 <ac> jethr0: heh. let's see who finishes first! Actually, I'm mainly doing this to learn Haskell better
15:20:54 <jethr0> i'm pretty much finished (even though there's much left to do). now i have to cabalize, clean it up and package it
15:21:20 <ac> that's cool. what image formats does freeimage support?
15:22:13 <ac> Maybe my code may actually be useful, as it does more than the common denominator between a bunch of formats
15:23:10 <jethr0> ac: about anything you can think of. i wanted to write a wrapper for imagemagick, but had problems with their interface and compile bugs, so i switched to another free, and platform-independent library
15:23:28 <ac> the solution to my background problem is to create a "(Encode16 p) => p -> Background" function
15:24:57 <ac> I have an Encode16 and Encode8 class so users can supply images as Arrays of tuples of doubles, instead of lists of Words
15:25:17 <jethr0> i'm totally for writing image routines in haskell. but i think we desperately need an imaging library fast and so i decided to write a binding asap
15:25:36 <scodil> woah. An image is type "Array (Int,Int) (Double,Double,Double,Double)" ?
15:25:41 <ac> (if they want). I figure the list of words interface will be used more, because that's the kind of type you'd feed to OpenGL or Gtk2hs code, or get from such libs
15:25:50 <jethr0> ac, have you thought about using bytestring? i've made the experience that arrays aren't as fast as i'd like them to be
15:26:32 <jethr0> at least array initialization can be painfully slow
15:26:32 <ac> jethr0: I thought about it, but I decided a list of words would be better than ByteString, because I want to support 8 and 16 bit images
15:27:05 <jethr0> i think that might be possible with bytestring as well, but i haven't worked much with it, so i wouldn't know
15:27:17 <ac> jethr0: ByteString is a string of bytes ;)
15:27:33 <scodil> are these images like compressed streams, or are they just dense 2D arrays?
15:27:34 <jethr0> not sure that's a correct characterization ;)
15:28:13 <ac> jethr0: it's easier for the library user to call peekArray and get a list of Word16s, than to turn it into a ByteString
15:28:48 <jethr0> hmm
15:29:10 <jethr0> just saying that arrays can be slow (even IOUArray, etc)
15:29:17 <ac> jethr0: I'm not using arrays ever
15:29:21 <jethr0> k
15:29:27 <ac> jethr0: I just provided a type class and a function to convert to list of words
15:30:14 <LoganCapaldo> of course IOUArrays are slow. they're just full of little slips of paper promising to return the data to you at some indeterminate point in the future
15:30:20 <ac> and a function for returning such a data structure if the user wants. I figured what's the point of writing this in pure Haskell if I'm not going to provide Haskellish data structures like a Diff Array
15:30:29 <ac> LoganCapaldo: lol
15:31:14 <scodil> ac: impure/monadic/IO-heavy haskell has its good points too
15:31:45 <ac> scodil: well, in addition to learning Haskell, the other point of writing this was creating a png library that didn't use IO types ;)
15:31:52 <scodil> don't think just because you're using haskell you have to go balls-out pure/immutable
15:31:56 <dolio> DiffArray is just a wrapped IOArray, isn't it?
15:32:29 <jethr0> wrapped is good ^_^
15:32:33 <scodil> ac: you're going to take a big performance hit on big images. you can still write fast, good looking haskell code with monads
15:32:46 <scodil> it doesn't have to be a big IO-soup
15:33:31 <dolio> Well, as far as performance goes.
15:33:40 <dolio> If IOUArray is slow, then so is DiffUArray.
15:33:54 <scodil> I don't buy that, whoever said IOUArray is slow
15:33:59 <jethr0> me
15:34:05 <scodil> its within 1x-2x of malloc and [] in C
15:34:18 <scodil> in my experience
15:34:18 <jethr0> maybe i did something wrong, but i had the impresseion that initialization times for all arrays were horrendous
15:34:25 <scodil> you don't have to initialize
15:34:30 <jethr0> well creation
15:35:02 <Altair^> how should one remove all doubles from a list?
15:35:10 <Cale> anyone know why Igloo is wearing his +o?
15:35:19 <jethr0> something was evilly slow, and i don't think i misused them. but i like to be proved wrong
15:35:32 <scodil> were you making lots of small ones or something?
15:35:42 --- mode: ChanServ set +o Cale
15:35:50 <jethr0> i expected them to be REALLY fast since they could just be memory ranges with direct access, but somehow it didn't work out for me
15:35:51 --- mode: Cale set -o Igloo
15:35:59 --- mode: Cale set -bb *!n=palomer@* palomer!*@*
15:36:06 --- mode: Cale set -o Cale
15:36:38 <scodil> jethr0: what were you comparing them to? what ended up being faster?
15:36:43 <jethr0> scodil: nah, i was doing image manipulation and had some 500x500x3byte images as arrays
15:37:04 <ddarius> jethr0: The "standard" functions for creating Haskell arrays go through lists which makes them very slow.
15:37:13 <jethr0> was so much a matter of comparison, just being annoyed at the speed
15:37:31 <scodil> and then there's bounds checking, but that's never been a huge deal for me.
15:37:35 <jethr0> i ended up using [[(Int,Int,Int)]] with some smart algorithms exploiting lazyness and it was faster than arrays
15:37:39 <RudolfRentier> hi
15:38:16 <jethr0> yes, i think i was creating arrays from lists, which again came out of a bytestring. i guess that list->array conversion killed me
15:38:24 <scodil> in my experience the only thing that really kills array performance is when heap allocation happens in your loops, even if the heap allocation isn't for the array
15:38:28 <jethr0> is there a better way to initialize these arrays from, lets say, a bytestring?
15:38:52 <scodil> unsafeArray ?
15:39:07 <jethr0> and the other thing that annoyed me was that i didn't find a way to map over an array, producing a new one.
15:39:42 <jethr0> forM [1..n] {forM [1..m] {do something}} isn't necessarily the fastest thing to work with either. especially when going via intermediate lists
15:39:59 <scodil> no wait. the best way to initialize an array is to just do (a <- newArray_ bnds) and then loop over the elements with forM_ or mapM_, doing unsafeReads and writes
15:40:05 <jethr0> unsafeArray sounds kinda unsafe. even though i have a much better grasp of haskell now, i still shirk away from unsafe*
15:40:07 <scodil> forM [0..n] doesn't make any lists
15:40:16 <jethr0> i know
15:40:48 <scodil> newArray_ bounds >>= \a -> getNumElements a >>= \n -> forM [0..n-1] $ \i -> unsafeWrite a i ...
15:40:53 <scodil> that should be lightning quick
15:40:55 <scodil> no allocation
15:41:11 <jethr0> *brr*, unsafeRead and unsafeWrite. doesn't sound like a very convincing fast "default" array type to me
15:41:30 <scodil> make a function myInitArray that takes the ellipsis as its argument, and declare it {-# INLINE #-}
15:41:35 <sjanssen> I'd use listArray and freezeArray
15:41:39 <scodil> then you never have to call unsafeRead or unsafeWrite
15:41:42 <sjanssen> (unsafeFreeze, probably)
15:41:45 <jethr0> k, thx for the pointers. i'm not so happy with all the ugliness though. wouldn't it be possible to wrap this stuff in unsafePerformIO and keep the inner workings from the user?
15:41:48 <sjanssen> or that ST freezing function
15:41:55 <RudolfRentier> (sorry for newb question :[) may someone look at http://pastebin.com/d170dc931 and tell me, what i'm doing wrong? (Gtk but more a monad-related question)
15:42:13 <scodil> getNumElements a >>= \n -> forM $ \i -> unsafeWrite a i whatever      <-- 100% safe
15:42:34 <scodil> er, forM [0..n-1]
15:42:38 <jethr0> RudolfRentier: you need to use "<-" to get a value "out of IO Monad"
15:43:02 <jethr0> RudolfRentier: "let x = do WindowNew" does actually work, it just does something different than you want
15:43:21 <RudolfRentier> jethr0: well, okay, so "getting out" is <-? thx alot
15:43:55 <jethr0> scodil: so, couldn't this be implemented as "FastArray" or sth?
15:44:09 <jethr0> like "newFastArray 0 100 myPtr"
15:44:34 <jethr0> and this still leaves the question open how to "map" over an array producing a new one, without resorting to unsafe*
15:45:08 <scodil> jethr0: you do have to use unsafe stuff, only at the core though. The haskell array libraries are built upon unsafe stuff
15:45:27 <scodil> make some core functions, to allocate, init, map, whatever, and then make the loop bodies be arguments
15:45:37 <RayNbow> http://lambda-the-ultimate.org/node/2645 <-- ...
15:45:38 <lambdabot> Title: Don&#039;t try FP in industry! | Lambda the Ultimate
15:45:46 <jethr0> scodil: k, so my error was to go via intermediate lists. i kinda thought so, just didn't know that i was "supposed" to use unsafeRead, ...
15:46:18 <ddarius> jethr0: The problem is that a sensible array library interface hasn't been promulgated.
15:46:35 <ddarius> (Actually, ignoring the parallelism stuff, the parallel array library is much better in this regard.)
15:46:44 <scodil> make your mapArray function take a function (Int -> IO v) as it's argument, and the Ints are array indexes. That way the library is controlling which indexes get written to, not the app programmer, and so you can guarantee safety
15:46:45 <jethr0> ddarius: does one exist? is one possible?
15:47:22 <scodil> It's totally possible
15:47:31 <litb> RudolfRentier: well, you get it out temporarily
15:47:42 <jethr0> btw, do you know if foreignPtr is "working" in ghc? in the documentation it says that it "might eventually" free the pointer, but there's no promises
15:47:52 <ddarius> jethr0: There is no problem.  It's just the H98 standard interface wasn't well thought out.
15:47:58 <jethr0> hehe
15:48:00 <ddarius> jethr0: You might find http://www.cse.unsw.edu.au/~chak/papers/CK03.html interesting.
15:48:01 <lambdabot> Title: Research Papers of Manuel Chakravarty
15:48:43 <jethr0> no offense, i'm really interested in the theory, but looking at papers when all i want to do is use an array is even a little too much for me
15:48:55 <jethr0> ^_^
15:49:05 <jethr0> i'll have a look though
15:49:10 <ddarius> jethr0: You need to a) get over that fast and b) perhaps look at the abstract.
15:49:21 <scodil> jethr0: are you comfortable with arrays in C?
15:49:22 <sclv> ltu has an awesomes sense of humor.
15:49:30 <jethr0> scodil: yes
15:49:33 <ddarius> The point of that link is it covers what the problems with the current array interface is
15:49:57 <jethr0> ddarius: i am actually over that. but don't you agree that sometimes you just wanna do things instead of getting bogged down with details you didn't ever want to know existed?
15:50:00 <Zao> For getting the second element from a tuple of three, is there any neater way than (\(_,b,_) -> b)
15:50:06 <Zao> +?
15:50:33 <jethr0> Zao: i thing in MissingH there is a function for that, but i don't think there is in the standard libraries
15:50:52 <ddarius> jethr0: That's fine, but don't then go telling people false information because you didn't want to find out the details.
15:51:01 <astrolabe> It would be nice if they overloaded fst and snd, and introduced thd etc.
15:51:06 <scodil> its pretty easy to write your own array library for Storable things using ForeignPtrs, peek/pokeElemOff. You can even make an immutable interface using unsafePerformIO, something like freeze/unsafeFreeze
15:51:09 <jethr0> @hoogle (a,b,c) -> b
15:51:10 <lambdabot> No matches, try a more general search
15:51:13 <jethr0> @hoogle '(a,b,c) -> b
15:51:13 <lambdabot> Hoogle Error: Parse Error: Unexpected character ''(a,b,c) -'
15:51:44 <astrolabe> @pl (a,b,c)->b
15:51:44 <lambdabot> (line 1, column 8):
15:51:44 <lambdabot> unexpected ">" or "-"
15:51:44 <lambdabot> expecting variable, "(", operator or end of input
15:52:17 <jethr0> ddarius: you're right. but i asked dons (or was it cale) and he agreed that arrays weren't so hot and proposed using bytestring. but i might just have totally misunderstood the whole thing
15:52:46 <jethr0> @hoogle (a,b) -> a
15:52:47 <lambdabot> Prelude.fst :: (a, b) -> a
15:52:47 <lambdabot> Data.Tuple.fst :: (a, b) -> a
15:52:47 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
15:52:48 <Cale> What's up?
15:52:56 <jethr0> hehe
15:52:59 <litb> @pl (\(a, b, c) -> b)
15:52:59 <lambdabot> (line 1, column 8):
15:52:59 <lambdabot> unexpected ","
15:52:59 <lambdabot> expecting letter or digit, operator or ")"
15:52:59 <lambdabot> ambiguous use of a non associative operator
15:53:04 <litb> hm, darn
15:53:59 <litb> tuples should be more integrated i think
15:54:23 <astrolabe> @djinn (a,b,c) -> b
15:54:23 <lambdabot> f (_, a, _) = a
15:54:32 <ddarius> litb: They are.  That's a problem with @pl's parser (or maybe not a problem as @pl would have no way of @pling such code.)
15:54:45 <astrolabe> Cale: not much
15:54:47 <sjanssen> litb: you can't write that function in a point-free form with the functions available in Haskell '98
15:55:13 <jethr0> sjanssen: if a function like sndOfThreeTuple existed it could ;)
15:55:15 <sjanssen>  @pl doesn't bother with those tuples because there aren't any functions that work with them
15:55:33 <sjanssen> jethr0: I'd actually go with curry/uncurry3
15:56:33 <sjanssen> @pl \a b c -> b
15:56:34 <lambdabot> const const
15:56:38 <sjanssen> neat :)
15:57:00 <sjanssen> uncurry3 (const const)
15:57:26 <litb> is there a uncurry3 ?
15:57:35 <ddarius> @hoogle uncurry3
15:57:35 <lambdabot> No matches found
15:57:41 <ddarius> @index uncurry3
15:57:41 <lambdabot> bzzt
15:58:33 <sjanssen> litb: no, but there oughta be
15:58:46 <ddarius> sjanssen: And an uncurry4, 5, 6 ... ?
15:58:54 <sjanssen> ddarius: yes, stopping at 7
15:59:18 <sjanssen> IIRC, 7 is the magic tuple number in the report
15:59:39 <jethr0> > let uncurry3 f (a,b,c) = f a b c;  thd :: (a,b,c) -> c; thd = uncurry3 $ const (const id) in thd (1,2,3)
15:59:39 <lambdabot>  3
15:59:43 <sjanssen> ddarius: of course, some sort of generic programming for tuples would be best
15:59:45 <ddarius> zipWith7 = map . curry7
15:59:55 <Cale> hehe "magic tuple number"
15:59:55 <litb> 7 is the number of things most peoples can work with at the same time
16:00:23 <litb> i wanted to say most haskell people
16:00:25 <ddarius> sjanssen: Something more general than just "generic programming for tuples"
16:00:33 <jethr0> it would be pretty brain-hurting to zipWith seven elements at a time
16:00:42 <litb> at least that is my theory :)
16:00:50 <monochrom> I have a theory that 7 is too high.
16:01:04 * ddarius claims the number is 0
16:01:15 <sjanssen> monochrom: oh yeah, even 4 is pushing it
16:01:47 <jethr0> it would be nice to have fixed length "lists" with O(1) random access. but i guess that would be an array, or a map, or sth
16:01:59 <jethr0> > id ()
16:02:00 <lambdabot>  ()
16:02:40 <monochrom> 7 is obtained by the psychology department doing experiments. I trust their methods, except for the well-known joke: "psychology is the psychology of psychology grad students", since most experiments are possible only because the department forces students to participate. Well, grad students might very well perform way better than average people. :)
16:03:22 <monochrom> So, I probably attain 7, and probably so do many of you, but people on the street may be a different story.
16:03:25 <wolverian> I can work with 0.5 things at the same time, optimally
16:04:24 <ddarius> I don't see why it would have much to do with education or intelligence.
16:04:34 <Cale> I can work with sqrt(3)/2 things at the same time, optimally.
16:05:09 <monochrom> This also explains why recursion is so "hard". You tend to brain-execute a recursion when you see one. (Big mistake, BTW.) So you use your short term memory for your stack. Well, your stack is like 3-7 levels deep. You're screwed in short order.
16:05:16 <dolio> @pl \f l1 l2 l3 l4 l5 l6 l7 -> map (curry7 f) (zip7 l1 l2 l3 l4 l5 l6 l7)
16:05:16 <lambdabot> (. zip7) . (.) . (.) . (.) . (.) . (.) . (.) . map . curry7
16:06:03 <litb> and i with sin (2pi/3)
16:06:04 <scodil> jethr0: when you say fixed length are you talking about fixed at compile time or runtime?
16:07:01 <monochrom> ddarius: The cause-effect relation is more "you perform better intellectually => you are more likely to get admitted into grad school" rather than "you are in grad school => you perform better intellectually".
16:07:11 <jethr0> hmm, i was thinking about stuff like "[a,b,c] = map ($x) [f1,f2,f3]". it seems such a waste to use "lazy non-fixed-length lists" for this
16:07:18 * monochrom is careful in phrasing that politically correctly, just to be sure.
16:07:46 <ddarius> monochrom: That's irrelevant to my statement.
16:08:15 <jethr0> monochrom: there are people who say that cause-and-effect is overrated in general. and i tend to agree. we put far too much emphasis on cause-effect and far too little on simple correlation
16:08:27 <litb> well.. if you try hard again and again i believe you could execute recursively very well
16:08:39 <scodil> jethr0: i wrote a library that uses a type like "L a b = L a b" and so a 3-vector is "L a (L a (L a ()))", and all the list-like functions, map, zipWith, fold, etc. It's pretty fast.
16:08:49 <monochrom> I don't put too much emphasis on cause-effect either.
16:08:50 <litb> everything is a matter of concentration and experience mate
16:09:25 <scodil> if the lists end up on the haskell heap, they're still linked lists, but it doesn't have to pattern match as much to get them. If you peek them out of malloc'd memory, its basically random access
16:09:31 <jethr0> scodil: yes, i've done that for pixel values. defining zipWithColor and mapColor get's you a long way
16:09:58 <monochrom> OTOH all the political correctness, "no relation between X and Y" are also overrated.
16:10:30 <Cale> There's a negative correlation in the world between money and malaria infection, so I'm going to start prescribing money for those sick with malaria. :)
16:10:41 <jethr0> i'm still waiting for a "real" language for dependent types and under the assumption that i'll have enough time and spare time to get my brain bent once again, i think there's a lot of compiler optimisation potential with annotated types for lists, etc
16:10:58 <jethr0> cale, i think that would even work ^_^
16:12:23 <wolverian> Cale, then they might afford treatment. does that invalidate your point, or validate it? :)
16:13:00 <jethr0> they could move to a better neighborhood/country as well
16:13:15 <jethr0> for prevention that is
16:13:16 * FunctorSalad tends to disagree with cause-effect being overrated
16:14:00 <monochrom> I think Cale carefully chooses that to defy both extreme points of view. :)
16:15:07 <jethr0> FunctorSalad: the problem is that you can't prove cause-effect
16:15:16 <FunctorSalad> I especially can't stand it if correlations that have obvious confoundings are reported by the media as if they were definately causal
16:15:27 <jethr0> all you can do is note correlation, and as well as cause-effect it could be a third parameter cause the two
16:15:37 <FunctorSalad> jethr0: you can for all intents and purposes with randomised studies.
16:15:42 <jethr0> no
16:16:01 <sclv> ok silly question. loeb pointfreed is fix (fmap . flip id =<<) :: (Functor f) => f (f c -> c) -> f c
16:16:18 <sclv> it seems to me this can be written in terms of swing, but i can't seem to get it right.. ?
16:16:50 <litb> :t flip id =<<
16:16:52 <lambdabot> parse error (possibly incorrect indentation)
16:17:16 <FunctorSalad> jethr0: why? if you randomize into two groups, then there is no third cause (unless you think the random generator is somehow biased ;))
16:17:27 <litb> how can i pass id to flip? doesn'T flip require two arguments?
16:17:43 <litb> i mean, the function to pass to flip requires two arguments, or?
16:17:57 <ddarius> litb: Again ($) = id
16:18:02 <monochrom> Nothing requires two arguments.
16:18:14 <jethr0> FunctorSalad: true. i think this is off-topic here, but i'm still amazed how little this whole thing is taught in school or otherwise discussed
16:18:19 <Cale> :)
16:18:22 <litb> oh yes i remember
16:18:40 <FunctorSalad> jethr0: hmm, you didn't mean me with "no"?
16:18:48 <litb> :t id
16:18:48 <lambdabot> forall a. a -> a
16:19:15 <jethr0> yes, but you're right with your randomization comment. thing is that i was referring to uncontrolled environments, not lab studies
16:19:17 <resiak> :t id :: (a -> b) -> a -> b
16:19:17 <lambdabot> forall a b. (a -> b) -> a -> b
16:20:02 <monochrom> Whatever you learned from other programming languages about counting the number of arguments...  They are almost right but eventually wrong in Haskell.
16:20:04 <FunctorSalad> jethr0: of course some things are kinda impractical to randomize ;)
16:20:34 <FunctorSalad> (e.g. going to psychology school)
16:20:44 <litb> monochrom: i see
16:21:40 <sclv> yay! got it!
16:21:42 <sclv> fix (flip (swing fmap) =<<)
16:21:50 <idnar> swing?
16:21:56 <jethr0> anyone know why this code (http://hpaste.org/5405) isn't as fast as i think it should be?
16:21:58 <sclv> swing = flip . (. flip id)
16:22:01 <litb> :t swing
16:22:01 <idnar> oh
16:22:01 <lambdabot> Not in scope: `swing'
16:22:06 <idnar> @unpl swing = flip . (. flip id)
16:22:06 <lambdabot> swing k b c = k (\ f -> f c) b
16:22:07 <litb> ah
16:22:25 <sclv> quite possibly an entirely useless result in that it makes loeb make less sense than ever.
16:23:12 <ddarius> :t flip . (. flip id)
16:23:13 <lambdabot> forall b c a c1. (((a -> c1) -> c1) -> b -> c) -> b -> a -> c
16:23:17 <idnar> :t flip
16:23:17 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:24:10 <sclv> > let loeb = fix (flip (swing fmap) =<<) in loeb [length, (+1) . head, const 12, sum . take 3]
16:24:10 <lambdabot>   Not in scope: `swing'
16:24:16 <Saizan> well you can say that a function takes at least N arguments before giving a non-function
16:24:29 <sclv> > let swing = flip . (. flip id); loeb = fix (flip (swing fmap) =<<) in loeb [length, (+1) . head, const 12, sum . take 3]
16:24:30 <lambdabot>  [4,5,12,21]
16:24:50 <ddarius> Saizan: That doesn't really help.  How many arguments does id take before giving a non-function?
16:25:05 <litb> lolz these snippets drive me crazy :p
16:25:16 <idnar> hmm
16:25:22 <Saizan> ddarius: at least 1 :)
16:25:22 <sclv> ddarius: just one. assuming that argument is bottom.
16:25:28 <idnar> :t flip id
16:25:29 <lambdabot> forall b c. b -> (b -> c) -> c
16:25:43 <ddarius> :t id undefined 3 6 78 8 4
16:25:43 <litb> i know every function takes at most 1 argument
16:25:44 <lambdabot> forall t. t
16:25:51 <ddarius> > id undefined 3 6 78 8 4
16:25:52 <lambdabot>  Undefined
16:25:52 <Botje> :t (.).(.).(.).(.).(.).(.).(.).(.).(.)
16:25:53 <lambdabot> forall a a1 a2 a3 a4 a5 a6 a7 b c a8. (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> c
16:25:59 <sclv> litb: these little snippets are what fuel my desire to learn what's going on.
16:26:03 <Botje> >:)
16:26:14 <litb> :p
16:26:46 <jethr0> i just hate multiple (.)s. they make my brain hurt and i find them to have a negative correlation with readability
16:26:55 <jethr0> and grokkability
16:27:06 <conal> jethr0: makes a lot more sense if you read (.) as "result"
16:27:24 <conal> and you can mix in first & second.
16:27:26 <jethr0> k, have an example
16:27:28 <jethr0> ?
16:27:43 <conal> :t (.).first.(.).(.).first.(.).second.(.).(.).first.(.).second.(.).(.)
16:27:43 <lambdabot> forall a d a1 a2 d1 a3 d2 a4 a5 d3 a6 d4 a7 b c a8. (b -> c) -> (a -> (a1 -> a2 -> (a3 -> (d2, a4 -> a5 -> (a6 -> (d4, a7 -> a8 -> b), d3)), d1), d)) -> a -> (a1 -> a2 -> (a3 -> (d2, a4 -> a5 -> (a6
16:27:44 <lambdabot> -> (d4, a7 -> a8 -> c), d3)), d1), d)
16:27:52 <jethr0> i kinda go for the slightly more verbose version which usually is less golf-like
16:28:11 <conal> if you pronounce (.) as "result", then you're just naming a path in the type toward the part to be transformed.
16:28:27 <sclv> conal: i spent quite some time at work today, fueled by the discussion last night, trying to figure cofunctors out, to only mild success.. plowing through the TypeCompose code I sort of get how OI works like one. do you have any other useful examples?
16:28:27 <conal> i.e., result/(.), first, and second are editor combinators.
16:28:33 <Saizan> ddarius: so? there are still arguments such that id a is not a function
16:28:56 <conal> sclv: sure.  thinking ...
16:29:13 <litb> isn't id a a nullary function?
16:29:26 <conal> sclv: a user interface "view" is a cofunctor.
16:29:30 <idnar> litb: no, it's unary
16:29:49 <conal> sclv: while a "controller" type is a functor
16:30:13 <litb>  heard people say that stuff like "foo = 1" were functions
16:30:13 <sclv> is there a snippet in, e.g., reactive, that shows this at work?
16:30:14 <idnar> but of course, any function in haskell is essentially unary
16:30:16 <litb> is that wrong?
16:30:43 <idnar> litb: that would be a nullary function if you look at it that way; I think a lot of people reserve "function" for types that have (->) in them, though
16:30:49 <litb> why is that not a nullary function?
16:31:13 <litb> ah i see. unary means taking no parameter, binary means taking one parameter and so forth?
16:31:13 <sclv> gah. just contemplating the cofmap type keeps breaking my brain.
16:31:21 <idnar> litb: off by one
16:31:27 <litb> idnar: ah i understand
16:31:27 <idnar> litb: nullary means no parameters, unary is one, binary is two
16:31:37 <conal> sclv: hm. i don't think so.  i'd better write a blog post about the idea.
16:31:38 <idnar> but in haskell, you can't apply a function to no arguments
16:31:42 <litb> -> biases it one back :)
16:32:01 * sclv is awful excited.
16:32:19 <idnar> you can pretend you're applying a function to two arguments, but to say that "f" is an application of f to no arguments is stretching it a bit ;)
16:32:20 <conal> litb: "foo = 1" is a non-function in more than one way.
16:32:36 <eugman_> nullary makes little sense to me
16:32:44 <ddarius> Saizan: My response is mostly directed to sclv
16:32:48 <ddarius> s/is/was
16:32:56 <Saizan> well, you can think of every value as a nullary function then, but it doesn't make much sense, e.g. you can't pattern match on functions but you can on values
16:33:10 <litb> i see
16:33:21 <ddarius> Saizan: You can't pattern match on all values.
16:33:50 <conal> if every value is a nullary function, isn't it also a second-order nullary function?  and third order, ...
16:33:59 <litb> on which can't you?
16:34:22 <Saizan> the ones that don't have an expoted contructor
16:34:32 <litb> i just read somewhere that in functional programs every value is a function
16:34:37 <litb> maybe that was wrong then
16:34:51 <conal> litb: yeah.  wrong.  i've heard that also.
16:34:55 <olsner> every function is a value though
16:35:02 <Saizan> it's more that every function is a value too, my previous statement make little sense then :)
16:35:04 <olsner> and you *can* encode any value as a function
16:35:04 <conal> everything period is a value.
16:35:26 <ddarius> Is running a value?
16:35:47 <ddarius> > 1 'a'
16:35:48 <lambdabot>   add an instance declaration for (Num (Char -> a))
16:35:48 <lambdabot>     In the expression: 1 ...
16:36:37 <conal> maybe the confusion comes from the "functional" in "functional programming".  perhaps a more accurate name would be "value-oriented programming".
16:36:49 <litb> i see
16:36:52 <Saizan> i guess value is a fuzzy concept
16:37:20 <litb> functional programming starts to grow to a buzz word lately i think
16:37:27 <conal> maybe "value" means the denotation of an expression.
16:37:38 <litb> now that c# has linq and whatnot
16:38:13 <ddarius> Saizan: You can make it fuzzy, but it needn't be.
16:38:26 <idnar> all concepts are fuzzy ;)
16:40:09 <litb> can logic programming considered to be more descriptive than functional programming?
16:40:27 <conal> litb: yes
16:40:29 <litb> because functional programming describes the way a problem is solved, but logic programming only present the solution?
16:40:51 <litb> i see
16:41:04 <litb> so it doesn't hurt if i look into prolog i guess
16:41:13 <Cale> In some sense, logic programming only presents the problem and a bunch of (carefully constructed) facts about it.
16:41:39 <Saizan> ddarius: what'd you use as a clear definition?
16:41:43 <conal> litb: if you've never done LP, then definitely, play with prolog.  there's also Lambda-Prolog, which is statically typed and higher-order.
16:41:55 <litb> yeah, i mixed solution and problem somewhat
16:42:04 <Cale> Functional programming describes the solution, but not the way to carry it out.
16:42:29 <litb> i see. that is what i wanted to say
16:43:40 <Saizan> Cale: well it describes all the transformations from the input to the output
16:43:56 <khadrin> what is the "m a" syntax in "return :: (Monad m) => a -> m a"
16:44:06 <khadrin> is it a pair but for type variables?
16:44:09 <Cale> khadrin: m is a type constructor, being applied to a
16:44:21 <Cale> khadrin: For example, m might be Maybe
16:44:38 <Cale> and a might be Integer, in which case we have return :: Integer -> Maybe Integer
16:44:51 <Cale> > return (5 :: Integer) :: Maybe Integer
16:44:52 <lambdabot>  Just 5
16:45:00 <khadrin> oh ok cool thanks
16:45:06 <Cale> Or m might be [], the type constructor for lists:
16:45:09 <Cale> > return (5 :: Integer) :: [Integer]
16:45:10 <lambdabot>  [5]
16:46:34 <khadrin> is a type constructor more than just a function?
16:48:58 <litb> > return (42 :: Integer) :: (->) Bool Integer
16:48:59 <lambdabot>  <Bool -> Integer>
16:49:05 <Cale> khadrin: Well, it's sort of a function at the type level.
16:49:21 <Cale> khadrin: It turns one type into another (rather than one value into another)
16:49:59 <khadrin> and you make one with the data keyword?
16:50:01 <litb> > (return (42) :: (Bool -> Integer)) False
16:50:02 <lambdabot>  42
16:50:04 <litb> o.O
16:50:28 <TomMD> So the google hits I get look a little dated - are there any current and serious efforts to get GHC support for Cell?  let set = [proj | proj <- allProjects, arch proj == "Cell", srcLang proj == "Haskell"]
16:50:31 <idnar> litb: return = const in the ->r monad
16:50:49 <idnar> @src (->) return
16:50:50 <lambdabot> return = const
16:50:52 <idnar> @src (->) >>=
16:50:52 <lambdabot> Source not found. You type like i drive.
16:50:53 <litb> :) i know. i just wanted to test whether it works :)
16:51:00 <idnar> @src (->) (>>=)
16:51:00 <lambdabot> f >>= k = \ r -> k (f r) r
16:51:05 <idnar> litb: oh ok
16:51:18 <litb> only the >>= definition of (->) screws my head
16:51:39 <Cale> khadrin: yep
16:51:43 <Cale> khadrin: Or newtype
16:51:51 <Cale> litb: This might help:
16:51:52 <idnar> @pl f >>= k = \ r -> k (f r) r
16:51:53 <lambdabot> (line 1, column 9):
16:51:53 <lambdabot> unexpected "="
16:51:53 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
16:51:53 <litb> it calls the function with the result of f (what is it, is that a value of is that a function then?) , and then calls the returned monad
16:52:04 <idnar> *smacks forehead* that's not going to work anyway
16:52:05 <conal> litb: join for -> is easier
16:52:18 <Cale> > (do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z)}) "hello"
16:52:19 <lambdabot>  ("hello","olleh","HELLO")
16:52:57 <Cale> litb: Note that 'monad' doesn't refer to values, it refers to type constructors.
16:52:58 <olsner> liftM3 (,,)?
16:53:56 <khadrin> Cale: the types into a new type makes a lot of sense thanks
16:54:30 <litb> yeah, i haven't known that analogy before too. neat :)
16:54:36 <idnar> :t (>>=)
16:54:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:54:42 <idnar> :t \ r -> k (f r) r
16:54:43 <lambdabot> Not in scope: `k'
16:54:43 <lambdabot> Not in scope: `f'
16:55:07 <idnar> er, oops
16:55:14 <idnar> :t f >>= k = \ r -> k (f r) r
16:55:15 <lambdabot> parse error on input `='
16:55:25 <idnar> :t \f k -> \ r -> k (f r) r
16:55:26 <lambdabot> forall t t1 t2. (t -> t1) -> (t1 -> t -> t2) -> t -> t2
16:56:25 <litb> Cale: that do will clear some things up i think :)
16:56:48 * idnar tries to think about that
16:57:33 <Cale> The definition of bind for the (->) e monad doesn't make it very clear what's going on until you understand the intended effect.
16:58:21 <idnar> > (id >>= \x -> (\r -> [r])) 5
16:58:22 <lambdabot>  [5]
16:58:28 <Cale> The intention is that actions in the (->) e monad, being functions of a parameter of type e, are individually run by applying them to a value of type e which is passed into the computation as a whole.
16:58:43 <idnar> Cale: yeah, I understand the intended effect
16:58:44 <litb> indeed, the type is (->)e , so in m a , the a is the result type of a function used as a monad. so x y and z will hold the result.and that is why f can be called with any argument because it is not bound in the monad. the k will return the same monad but with another function but it will expect the same type, so it gets the r too and returns something different
16:58:49 <idnar> Cale: just trying to figure out how the implementation fits in
16:58:53 <litb> i think i finally got how it works now
16:59:22 <Cale> litb: you've got it except for the abuse of the word "monad" there :)
16:59:23 <conal> sometimes working from join to >>=  via the standard definition is much easier for me.
17:00:06 <Cale> litb: When you say that something is a monad, you're implying that it's a type constructor.
17:00:28 <litb> oh i see
17:00:33 <Cale> That is, Maybe and IO are monads, (Just 5) and getLine are not.
17:00:35 <litb> i should have said that it is an instance of monad
17:00:50 <idnar> instances are something else
17:00:51 <Cale> A monadic computation or 'action'
17:01:00 <litb> alrite
17:01:01 <Cale> Or value typed in a monad.
17:01:03 <idnar> "monadic value", perhaps?
17:01:04 <litb> @undo (do { x <- id; y <- reverse; z <- map toUpper; return (x,y,z)})
17:01:04 <lambdabot> (id >>= \ x -> reverse >>= \ y -> map toUpper >>= \ z -> return (x, y, z))
17:01:10 <Cale> yes, "monadic value'
17:01:13 <Cale> "*
17:01:14 <Cale> hehe
17:01:31 <TomMD> That many, huh?  About what I expected, but a darn shame.  Almost everyone outside the Haskell world talks about it while everyone inside doesn't.... hummm... a gap to fill!
17:01:46 <Cale> TomMD: what many?
17:02:28 <sm> talkin' 'bout Cell
17:02:31 <Cale> TomMD: Efforts to optimise Haskell for the Cell processor?
17:03:00 <TomMD> Cale: I was intentionally vague.  "That many projects to target Cell w/ GHC"
17:03:00 <TomMD> Yes
17:03:08 <Cale> TomMD: Well, the nested data parallelism stuff would likely play into that somewhat.
17:03:16 <pjd> :t \r -> ?k (?f r) r
17:03:16 <lambdabot> forall t t1 t2. (?k::t -> t1 -> t2, ?f::t1 -> t) => t1 -> t2
17:03:20 <Cale> But nothing directed specifically at the Cell.
17:03:24 <pjd> ^- idnar, btw
17:03:48 <Trinithis> pjd: would you happen to know how the 'fix' function works?
17:03:49 <Cale> That's more of an engineering concern than a computer science concern, and most of the people working on Haskell implementations are computer science researchers.
17:04:06 <idnar> pjd: yeah
17:04:08 <pjd> Trinithis: to a basic extent
17:04:37 <TomMD> Cale: Certainly would be a useful top level construct, but making the backend work nicely with all those cores, speciallized cores, separate memory spaces, etc is quite an interesting problem.
17:04:48 <Trinithis> pjd: it seems like it would throw the computer into an endless loop...
17:05:02 <pjd> Trinithis: it does, in fact
17:05:14 <idnar> pjd: well, not necessarily
17:05:21 <monochrom> > take 10 (fix (\x -> True : x))
17:05:22 <lambdabot>  [True,True,True,True,True,True,True,True,True,True]
17:05:24 <pjd> but with lazy evaluation, infinite loops are no problem :)
17:05:34 <monochrom> Ain't infinite loop if you use it for suitable purposes.
17:05:38 <TomMD> Cale: I look at it as a concern for a "compiler designer / builder".  I guess I just assume 90% of Haskellers are compiler gurus (unlike me).
17:05:46 <idnar> oh, well, I guess it would be infinite if you didn't have some kind of lazy evaluation
17:05:58 <sclv> ?src fix
17:05:58 <lambdabot> fix f = let x = f x in x
17:06:04 <Trinithis> I understand how fix works in math, but i dont see how haskell does it
17:06:19 <Cale> TomMD: For now at least, the symmetric multiprocessing stuff is going fairly well. I suspect another reason that Core hasn't been targeted is that there are not so many people with Core processors.
17:06:26 <monochrom> And just in case you think it only works for lazy lists...
17:06:37 <monochrom> > fix (\f x -> if x==0 then 0 else f (x-1))
17:06:38 <lambdabot>  <Integer -> Integer>
17:06:40 <idnar> Trinithis: fix f basically expands to f (f (f (f (f ...
17:06:42 <monochrom> > fix (\f x -> if x==0 then 0 else f (x-1)) 10
17:06:43 <lambdabot>  0
17:06:52 <monochrom> Looks like termination to me.
17:06:57 <pjd> Trinithis: fix f = f (fix f) = f (f (fix f)) = f (f (f (...)))
17:07:27 <Cale> The single most important thing to keep in mind when examining these definitions of fix is that Haskell evaluates expressions outermost-first.
17:07:27 <pjd> it's sort of like a self-replicating sequence of applications
17:07:36 <Trinithis> huh
17:07:38 <Cale> (well, all the present implementations do)
17:07:48 <pjd> Trinithis: compare 1:(1:(1:(1:(...)))
17:07:49 <Trinithis> oh...
17:07:52 <pjd> same concept
17:07:53 <Trinithis> i think i get it
17:08:00 <pjd> > fix (1:)
17:08:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:08:02 <litb> didn't dons make a nice blog about showing function calls?
17:08:05 <TomMD> Cale: s/Core/Cell.  Yeah, I can understand that.  I see Malcolm Wallace was interested in this - is he on IRC?
17:08:06 <monochrom> There is nothing strange about fix. It's just inline recursion.
17:08:08 <litb> he said that it is in lambdabot soon
17:08:11 <idnar> if f is strict in its argument, then evaluating fix f won't terminate
17:08:13 <Cale> TomMD: er, yes, Cell :)
17:08:17 <litb> or maybe it was another guy but someone said that
17:08:24 <Cale> TomMD: hmm... I don't know :)
17:08:33 <Trinithis> Thanks for the explanation. Make a lot more sense now
17:08:48 <pjd> Trinithis: so an infinite list of 1s is just (fix f) where f = 1:
17:08:51 <Cale> damn, what is wrong with hpaste.org?
17:09:05 <monochrom> It's written in Haskell?  <duck>
17:09:16 <Cale> I had a lovely expansion of fix implementing fac on there, and the site appears down...
17:09:39 <litb> too bad :/
17:09:51 <monochrom> > fix (\f x -> if x==0 then 1 else x*f(x-1)) 10
17:09:52 <lambdabot>  3628800
17:09:58 <litb> > fix (1:)
17:09:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:10:07 <Cale> oh... it's up :)
17:10:47 <Trinithis> so fix is useful if the f eventuially comes to a cerain number, like in fac, or if the infinite value can be read
17:10:52 <Cale> http://hpaste.org/5236
17:10:56 <Trinithis> like the 1:1.1..
17:11:06 <monochrom> Your statement holds for recursion too.
17:11:16 <Cale> That shows the actual evaluation steps for fix fac' 5
17:11:31 <Cale> Where fac' = \fac n -> if n == 0 then 1 else n * fac (n-1)
17:11:34 <litb> yeah i can remember that, Cale :p
17:13:08 <monochrom> Anytime you write recursion g = ...g... , you can as well write g = fix (\h -> ...h...).  Maybe you can simplify \h->...h... or maybe you can't. That is all.
17:13:54 <sclv> > let swing = flip . (. flip id); loeb = fix (flip (swing fmap) =<<) in loeb (const 1: const 2:  const 3 : fix (ap ((:) . ap (ap . ((+) .) . flip (!!)) (flip (!!) . (1 +))) . (. (1 +))) 1)
17:13:54 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
17:14:05 <sclv> > let swing = flip . (. flip id); loeb = fix (flip (swing fmap) =<<) in loeb (const 1: const 1:  const 2 : fix (ap ((:) . ap (ap . ((+) .) . flip (!!)) (flip (!!) . (1 +))) . (. (1 +))) 1)
17:14:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:14:12 <monochrom> But now you see that fix (\h -> ...h...) can be placed inside a larger expression, why g=...g... requires a top level definition, or let, or where.
17:14:24 <sclv> ^^ worst fibs evah.
17:14:28 <monochrom> s/why/while/
17:14:30 <idnar> hahaha
17:15:20 <Trinithis> just fibbing for fun?
17:15:33 <idnar> that's certainly the worst fibs I've seen
17:15:35 <Cale> > fix ((0:) . scanl (+) 1)
17:15:35 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:16:23 <idnar> @pl \f g s -> fix (f . scanl g s)
17:16:23 <lambdabot> ((fix .) .) . (. scanl) . (.) . (.)
17:16:25 <FunctorSalad> > fix (\x -> x/2)
17:16:26 <lambdabot>  Exception: <<loop>>
17:16:29 <FunctorSalad> :)
17:16:33 <idnar> > ((fix .) .) . (. scanl) . (.) . (.) $ (0:) (+) 1
17:16:33 <lambdabot>  Couldn't match expected type `t -> [a] -> [b]'
17:16:53 <idnar> > (((fix .) .) . (. scanl) . (.) . (.)) (0:) (+) 1
17:16:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:16:57 * idnar hides
17:16:57 <Trinithis> > fix (\x -> (x:))
17:16:58 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> [a]
17:16:58 <lambdabot>     Pro...
17:18:26 <idnar> > fix (\x -> 5:x)
17:18:27 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
17:18:46 <Trinithis> fix ((\f x -> if x == 0 then 0 else x * f (x - 1)) 8)
17:18:49 <Trinithis> > fix ((\f x -> if x == 0 then 0 else x * f (x - 1)) 8)
17:18:49 <lambdabot>   add an instance declaration for (Num (a -> a))
17:19:24 <Cale> > fix (\fix f -> f (fix f)) (\fac n -> if n == 0 then 1 else n * f (n-1)) 10
17:19:24 <lambdabot>   Not in scope: `f'
17:19:27 <idnar> > fix (\f x -> if x == 0 then 0 else x * f (x - 1)) 8
17:19:28 <lambdabot>  0
17:19:29 <Cale> > fix (\fix f -> f (fix f)) (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
17:19:30 <lambdabot>  3628800
17:19:42 <Trinithis> > fix (\f x -> if x == 0 then 0 else x + f (x - 1)) 8
17:19:43 <lambdabot>  36
17:19:59 <Trinithis> > sum [0..8]
17:20:00 <lambdabot>  36
17:20:19 <idnar> :t (\f x -> if x == 0 then 0 else x + f (x - 1))
17:20:19 <wli> http://haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
17:20:19 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
17:20:20 <lambdabot> http://tinyurl.com/3ynj9f
17:21:53 <Cale> map (fix (\deranged n -> if n < 2 then n else n * deranged (n-1) + n * deranged (n-2))) [1..10]
17:21:55 <Cale> > map (fix (\deranged n -> if n < 2 then n else n * deranged (n-1) + n * deranged (n-2))) [1..10]
17:21:56 <lambdabot>  [1,2,9,44,265,1854,14833,133496,1334961,14684570]
17:22:09 * monochrom considers writing "fastest fib in the east using chinese remainder wisdom"
17:22:17 <idnar> heh
17:22:26 <Cale> @oeis 1,2,9,44,265,1854,14833,133496,1334961,14684570
17:22:27 <lambdabot> Subfactorial or rencontres numbers, or derangements: number of permutations o...
17:22:27 <lambdabot> [1,0,1,2,9,44,265,1854,14833,133496,1334961,14684570,176214841,2290792932,320...
17:22:34 <litb> > product [0..99999999999999]
17:22:38 <lambdabot> Terminated
17:22:42 <litb> silly o.O
17:23:09 <idnar> > product [0..9999999999]
17:23:12 <lambdabot> Terminated
17:23:15 <idnar> > product [0..999999]
17:23:15 <lambdabot>  0
17:23:25 <wli> monochrom: Not sure what you mean.
17:23:28 <idnar> *facepalm*
17:23:37 <monochrom> Me neither. :)
17:23:41 <Trinithis> > product $ reverse [0..99999999999999]
17:23:44 <lambdabot> Terminated
17:24:26 <monochrom> Why are you multiplying 0 with other things?
17:24:39 <litb> isn't it inefficient?
17:24:46 <wli> monochrom: When did I do that?
17:24:58 <monochrom> I mean idnar
17:24:59 <litb> monochrom: the compiler did, not we
17:25:23 <litb> we only wanted the result, dude :)
17:25:34 <monochrom> You want the result to be 0?
17:25:51 <Trinithis> monochrom: just wanted to see how smart it was
17:26:16 * monochrom cues to and plays an excerpt of Handel's Messiah
17:26:22 <monochrom> "why do the nations
17:26:27 <monochrom> imagine a vain thing!"
17:27:18 <monochrom> err, s/nations/people/
17:29:41 <idnar> monochrom: litb started it; I didn't realise what I was doing until I got an answer
17:29:42 <Saizan> why do the people keep using bash scripts? it just seems like every corner case or weird behavoir they could imagine was stuffed inside that language
17:29:55 <litb> idnar: huh?
17:30:06 <idnar> litb: < litb> > product [0..99999999999999]
17:30:08 <monochrom> hehehe
17:30:15 <idnar> litb: it's all your fault!!!
17:30:17 <idnar> ;)
17:30:19 <litb> yeah, that's funny =)
17:32:00 <litb> i wonder whether Rational is enumerable too
17:32:19 <Trinithis> :t apply
17:32:19 <lambdabot> Not in scope: `apply'
17:32:25 <monochrom> > [1%1 .. ]
17:32:26 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1,16%1,17%1...
17:32:34 <litb> great
17:32:44 <monochrom> > [3%7 .. ]
17:32:44 <lambdabot>  [3%7,10%7,17%7,24%7,31%7,38%7,45%7,52%7,59%7,66%7,73%7,80%7,87%7,94%7,101%7,...
17:33:21 <monochrom> > [1%7, 3%7 .. ]
17:33:21 <lambdabot>  [1%7,3%7,5%7,1%1,9%7,11%7,13%7,15%7,17%7,19%7,3%1,23%7,25%7,27%7,29%7,31%7,3...
17:33:37 <Trinithis> :src iterate
17:33:43 <Trinithis> @src iterate
17:33:43 <lambdabot> iterate f x =  x : iterate f (f x)
17:33:49 <monochrom> "one little, two little, three little rationals,
17:34:01 <monochrom> five little, six little, seven little rationals..."
17:34:40 <ddarius> monochrom: We discriminate against four here?
17:34:49 <monochrom> Oops!
17:34:52 <litb> > [1%1, 1%2, ..]
17:34:52 <lambdabot>  Parse error at "..]" (column 12)
17:35:03 <litb> > [1%1, 1%2, .. ]
17:35:03 <lambdabot>  Parse error at ".." (column 12)
17:35:05 <litb> hm
17:35:06 <OceanSpray> Oops!
17:35:08 <litb> oh
17:35:13 <litb> > [1%1, 1%2 .. ]
17:35:13 <lambdabot>  [1%1,1%2,0%1,(-1)%2,(-1)%1,(-3)%2,(-2)%1,(-5)%2,(-3)%1,(-7)%2,(-4)%1,(-9)%2,...
17:35:25 <monochrom> Evidently, there are four kinds of people. Those who can count and those who cannot.
17:36:23 <litb> There are two kind of peoples in the world, those who don't understand logic, and those who don't
17:37:36 <Trinithis> i don't get it
17:38:48 <litb> @src Rational enumFromThen
17:38:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:39:56 <litb> hmm
17:40:00 <litb> any idea?
17:40:34 <dons> ?users
17:40:34 <lambdabot> Maximum users seen in #haskell: 465, currently: 411 (88.4%), active: 18 (4.4%)
17:40:42 <litb> or is it built-in?
17:41:03 <litb> it's night in europe, then user size shrink apparently.
17:42:23 <litb> hm, 1 , 0.5 , 0, -0.5, -1, -3/2 , .. what logic is that?
17:42:41 <litb> oh wait i see. nvm
17:42:49 <visof> is anyone use yi editor ?
17:43:07 <litb> i thought it would only decrement the denominator. but it doesn't
17:43:26 <monochrom> arithmetic series. common difference. a_n = a_0 + d*something.
17:43:48 <monochrom> haskell can do highschool math!
17:43:56 <guenni> hi guys, would this be the right channel for "deep haskell", ie Lambda Calculus and Combinatory Logic?
17:44:00 <litb> yeah, i see
17:44:10 <dons> guenni: yes.
17:44:12 <Cale> guenni: yep
17:44:13 <litb> guenni: there sem to be gurus here
17:44:22 <dons> would you like functors with that?
17:44:24 <litb> *seem
17:45:39 <BMeph> Would you like matching adjoint functors with that? ;)
17:45:41 <monochrom> @fugue
17:45:41 <lambdabot> Unknown command, try @list
17:45:46 <monochrom> @quote fugue
17:45:46 <lambdabot> monochron says: "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
17:46:03 <litb> @haskell-truth
17:46:03 <lambdabot> Unknown command, try @list
17:46:09 <litb> how was that command?
17:46:42 <monochrom> and which monad would you like to drink?
17:46:54 <pjd> welcome to #haskell, where your questions are answered in contravariant functors
17:47:09 <monochrom> @remember pjd welcome to #haskell, where your questions are answered in contravariant functors
17:47:09 <lambdabot> Nice!
17:48:15 * Cale answers every question with the coordinate ring functor.
17:48:23 <BMeph> Would you like Endomorphisms with that? :)
17:49:31 <monochrom> I think we have caused the asker's brain to explode.
17:50:04 <monochrom> (And yes yes yes, I am aware of all the caveats of "cause-effect"!)
17:52:06 <litb> lol
17:52:48 <BMeph> As long as there are no demons flying from any noses, I think we're safe...for now.
18:00:05 <guenni> don, Cale, litb : thx that is good to know
18:01:57 <litb> please pull me out of that guru ring
18:02:24 <Cale> hehe
18:02:26 * ddarius prefers other representable functors.
18:02:30 <Cale> It's too late!
18:02:35 <Cale> You're one of us now!
18:03:04 <BMeph> litb: Yep, we'll expect a monad tutorial from you by the end of the month. ;)
18:03:18 <litb> meh, now i have been assimilated . there is no back
18:03:23 <Cale> With new insights :)
18:04:44 <Trinithis> BMeph: why? some inaugeration (sp?)
18:05:21 * ddarius has never written a monad tutorial and intends to keep it that way.
18:05:42 <BMeph> Trinithis: Try googling for it - it's what all the "cool kids" are doing these days... ;)
18:05:44 <litb> :p i won't either
18:06:15 <guenni> any recommendation you gurus for books to get the hang of combinatory logic and lambda calculus?
18:06:40 * BMeph laughs at "Mr. Adjoint Functor" declaring he's not writing a monad tutorial...when he's done the exact thing many times in-channel
18:06:51 <guenni> cause I'd really like to and I'm really struggling ...
18:07:22 <ddarius> BMeph: I usually refer to Wadlers and criticize Cale's Monads As Containers.
18:09:19 <Cale> ddarius: What do you think is the problem with it?
18:11:02 <ddarius> I've said repeatedly for several years now ever since you first wrote it.  I don't think monads in general (even within Haskell) are intuitively "container-like".  I suspect the analogy works for free monads, but that's about it.
18:11:49 <Cale> Well, it depends on how abstract you make the notion of 'container'
18:12:25 <Cale> People are generally okay with the idea of map applying a function to all the elements of a list. Any functor can be treated in some sense like a 'container' in that regard.
18:12:46 * wli prefers monads defined as algebraic structures or whatever with (f)map, return, and join.
18:13:31 <Trinithis> BMeph: Yo! I iz cool
18:13:46 <Cale> Well, it works less well with functors that throw away structure than with those which add it, I'll admit.
18:14:02 <BMeph> Trinithis: You got it! ;)
18:14:08 <litb> all i can say is that that tutorial could confuse people into thinking that monads  would be like monad.addStuff(x) monad.addOtherStuff(y)
18:14:16 <litb> i was confused by that analogy at least
18:14:27 <Trinithis> BMeph: I should write onE!!!
18:14:34 <Cale> It's not so clear the sense in which, say, the fundamental group functor looks like a "container type"
18:14:46 <ddarius> For functors restricted to 'Hask', I'll agree with that enough, but I'm not complaining about "functors as containers"
18:14:50 <litb> but #haskell was/is quite helpful :)
18:14:51 <BMeph> Trinithis: "...maybe you already have." ;)
18:14:57 <Trinithis> lol
18:15:03 <Cale> ddarius: Well, monads are just a specific kind of functor.
18:15:23 <ddarius> Yeah, I was about to change my mind.
18:15:29 <Trinithis> BMeph: i'm too new to haskell to have written one already. though i think i understand them pretty well
18:16:28 <BMeph> ddarius: Helping us get to "putting the 'mon' in monads", after "putting the 'func' in functors"? ;)
18:18:15 <litb> > (return [2*x, 3*x]) `ap` [1..5]
18:18:16 <lambdabot>   Not in scope: `x'
18:18:25 <litb> > (return [2*, 3*]) `ap` [1..5]
18:18:25 <lambdabot>  Parse error at "," (column 12)
18:18:29 <litb> oh
18:18:49 <litb> > [(2*), (3*)] `ap` [1..5]
18:18:50 <lambdabot>  [2,4,6,8,10,3,6,9,12,15]
18:18:52 <Cale> Someone should do a parody of those old 'Mono' silicone caulk ads except with 'Monad' instead.
18:18:57 <glguy> ?seen dons
18:18:57 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 6m 6s ago.
18:19:03 <dolio> Huh. Haddock 2.0 doesn't show associated types.
18:19:14 <ddarius> Cale: I'll rephrase my earlier statement: To abstract the notion of "container" enough to view functors as special cases of them 1) rather hurts the term "container" and 2) more importantly, is unlikely going to be the view of someone, rather they'll bring a lot of other "container" intuitions along.
18:21:08 <ddarius> Cale: It also just doesn't explain the intuition or motivation.  Your Monads as Computations is much better in this regard.
18:21:10 * BMeph imagines a "monads as Krazy Glue" commercial
18:21:10 <Cale> ddarius: Of course, eventually you need to know exactly in which sense it is that monads are *not* like containers, but I think it's helpful to have a strong analogy to start with, and then be able to weaken that gradually.
18:21:19 <sarehu> How are typeclasses implemented?  One extra vtable as a hidden argument (per independent typeclass)?
18:21:34 <dons> records of methods per type
18:21:34 <ddarius> sarehu: They are implemented in multiple ways.
18:21:43 <dons> often the calls are resolved statically
18:22:25 <litb> i've seen some slide which explained it by a hidden parameter d that it called "selector"
18:22:32 <litb> but i haven't understood it :p
18:22:39 <sarehu> Ok.  Thanks.
18:23:09 <Trinithis> what are the pros and cons to CPS
18:23:12 <Cale> ddarius: Yeah, my Monads as Computation was written because I was seeing a lot of tutorials which were trying to explain why monads were important and getting it wrong. (Of course, monads as containers doesn't really try to explain why they're important at all.)
18:23:18 <jethr0> is there a Nondeterminism monad out there that parallelized on several cpus by default?
18:23:32 <pjd> Trinithis: relative to what? :)
18:23:39 <ddarius> Trinithis: What pjd said.
18:23:53 <Cale> jethr0: No, but it would be really cool if you worked out a way to do this with LogicT.
18:24:01 <Trinithis> pjd: relative to the "tutorial-like" style of haskell
18:24:14 <ddarius> Trinithis: What?
18:24:22 <Trinithis> umm
18:24:29 <pjd> Trinithis: CPS as in continuation-passing style?
18:24:30 <Trinithis> sec
18:24:32 <EvilTerran> what
18:24:37 <Cale> jethr0: and of course, you could do something with the list monad by replacing bind with a parallelising concatMap
18:24:41 <jethr0> at the moment i'm getting really annoyed because my c-version of n-queens is 10 times faster than my haskell version (which uses ListT for non-determinism)
18:24:41 <pjd> or something else?
18:24:59 <Cale> jethr0: ListT? Why ListT?
18:25:04 <jethr0> and haskell would kick c's ass if it were to automatically use multiple processors
18:25:13 <jethr0> sorry, List monad
18:25:14 <Cale> jethr0: Usually for something like that, I'd use StateT []
18:25:37 <Cale> That can be sped up by replacing [] with a Nondet monad which uses functions.
18:26:01 <jethr0> yes, i've tried that but didn't understand what the "return type" of your Nondet monad was.
18:26:17 <Cale> It's foldr essentially.
18:26:19 <Saizan> forall r. ContT r (StateT s []) seems the fastest
18:26:44 <Cale> Lists are represented as the result of applying foldr to them.
18:27:16 <Trinithis> okay.. about the cps clariafication. Under the wikipedia CPS, it shows 2 columns, one using "directy style" and one using "cps".
18:27:56 <jethr0> cale, yes i get that. but how do i get a list from MonadNondet? apply the result to []?
18:29:04 <ddarius> jethr0: How do you turn foldr into the id function?
18:29:13 <pjd> Trinithis: right, CPS is a way to write procedures without using an implicit call stack
18:29:31 <jethr0> ddarius: now i'm lost
18:29:36 <pjd> (more or less)
18:29:55 <Trinithis> pjd: so is it preferrable to code using cps all the time?
18:29:58 <pjd> Trinithis: stated another way, it's what you get when you make the implicit continuation explicit
18:30:04 <pjd> Trinithis: probably not
18:30:13 <Cale> jethr0: foldr f z replaces each (:) in a list with f, and the [] at the end with z
18:30:34 <pjd> Trinithis: in Scheme, the compiler might compile your code to CPS
18:30:40 <ddarius> Trinithis: No.  You want to code in direct style as much as possible.
18:30:43 <Cale> jethr0: So in order to write the identity function we pick f = (:), and z = []
18:30:59 <Cale> > foldr (:) [] [1..]
18:31:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:31:05 <Trinithis> so basically cps is the compiler's job?
18:31:11 <ddarius> Trinithis: No.
18:31:18 <pjd> in any case, Scheme provides first-class access to the current continuation with call/cc
18:31:52 <pjd> so you would generally use that, where you would have to manually converting your code to CPS otherwise
18:31:58 <Cale> jethr0: But you can just apply runNondet to get a list.
18:32:20 <Trinithis> mm
18:32:21 <Cale> err...
18:32:28 <ddarius> Trinithis: The only (semantic) reason to use CPS is to emulate an effect not provided by the language.
18:32:30 <Cale> ah, hehe, it doesn't do that :)
18:32:37 <jethr0> @paste
18:32:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:32:57 <Cale> foldNondet nd (:) []
18:32:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5407
18:33:02 <Cale> That'll give a list
18:33:08 <jethr0> thx
18:33:31 <jethr0> i think the problem in the paste i just posted is that the list is constructed, but only its lenght is ever used
18:33:55 <Cale> Yeah, you might just want to work with integers.
18:34:14 <Trinithis> alright guys i gtg. again, thanks for the help
18:34:16 <Cale> but hmm :)
18:34:23 <jethr0> but i don't know how to use List monad AND work with integers
18:34:35 <Cale> That might not be possible directly :)
18:34:46 <jethr0> unless i rewrite it all to work without non-determinism
18:34:55 <Cale> right.
18:35:02 <jethr0> do you thing using MonadNondet with list output will speed it up considerably?
18:35:23 <Cale> Try it. It worked for my Sudoku solver.
18:35:32 <Cale> actually, you can just use
18:35:38 <Cale> foldNondet nd (+) 0
18:35:45 <jethr0> in a perfect world, using "length" on a list of ()'s shouldn't have to create the whole list, right?
18:35:55 <jethr0> cool
18:35:57 <Cale> err...
18:36:04 <Cale> You might have to return some 1's :)
18:36:17 <Cale> oh
18:36:43 <Cale> foldNondet nd (const (1+)) 0
18:37:02 <Cale> I'm not sure if there's an advantage there, but you can try it and see :)
18:37:29 <jethr0> i'll just try. but i guess i won't be squeezing out a factor 10 any time soon
18:37:52 <Cale> You might look at other nqueens solutions.
18:38:02 <jethr0> k, i will
18:38:23 <Cale> I'm pretty sure it's a problem that's been looked at quite a bit.
18:39:29 <BMeph> jethr0: Remember, it's doable in Icon, it's GOT to be doable in something useful... ;)
18:40:44 <jethr0> cale, i think my haskell version is already pretty good. but the c version is doing almost no computation (except recursion of max depth N, and minimal bit twiddling) since it only counts the solutions and doesn't list/accumulate them. that's a pretty hard benchmark for the List Monad
18:42:21 <Cale> > 2.976 / 0.585
18:42:22 <lambdabot>  5.087179487179488
18:42:30 <Cale> I have a program here which is 5 times faster.
18:42:47 <jethr0> just wrote it, or pulled from your "archives"?
18:42:56 <Cale> archives :)
18:43:01 <Cale> Specifically the nofib suite.
18:43:01 <jethr0> could you paste it?
18:43:06 <jethr0> hehe
18:43:18 <jethr0> k, i can look it up myself in that case
18:43:34 <hpaste>  Cale annotated "(no title)" with "5 times faster" at http://hpaste.org/5407#a1
18:45:03 <dolio> Pah, a shamefully long main. :)
18:46:31 <Cale> Yeah, probably better would be  main = mapM (print . nsoln . read) =<< getArgs
18:46:45 <ddarius> length = foldr (const (1+)) 0
18:46:59 <Cale> yep
18:48:04 <Cale> @oeis 1,0,0,2,10,4,40,92,352,724,2680,14200
18:48:05 <lambdabot> Number of ways of placing n nonattacking queens on n X n board.
18:48:05 <lambdabot> [1,0,0,2,10,4,40,92,352,724,2680,14200,73712,365596,2279184,14772512,95815104...
18:49:36 <chessguy>  is that up to isomorphism?
18:49:43 <jethr0> @oeis 1,1,2,3,5,8,13
18:49:43 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
18:49:43 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:49:54 <jethr0> @oeis 2,3,5,7,11,13
18:49:54 <lambdabot> The prime numbers.
18:49:54 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
18:50:03 <jethr0> i didn't know that feature
18:50:08 <chessguy> @oeis 1,3,5
18:50:08 <lambdabot> Jacobsthal sequence: a(n) = a(n-1) + 2a(n-2), with a(0) = 0, a(1) = 1.
18:50:08 <lambdabot> [0,1,1,3,5,11,21,43,85,171,341,683,1365,2731,5461,10923,21845,43691,87381,174...
18:50:20 <chessguy> @oeis 1,3,5,7,9,11
18:50:20 <lambdabot> The odd numbers: a(n) = 2n+1.
18:50:20 <lambdabot> [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
18:50:25 <chessguy> heh
18:50:25 <jethr0> @oeis 1,4,9,16,25
18:50:26 <lambdabot> The squares: a(n) = n^2.
18:50:26 <lambdabot> [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
18:50:33 <Cale> chessguy: No, it's all of them.
18:50:50 <jethr0> no idea when this could be useful, but definitely a cool feature
18:50:56 <Cale> @oeis 1,0,0,1,2,1,6,12,46,92
18:51:02 <lambdabot> Number of ways of placing n nonattacking queens on n X n board (symmetric sol...
18:51:02 <lambdabot> [1,0,0,1,2,1,6,12,46,92,341,1787,9233,45752,285053,1846955,11977939,83263591,...
18:51:14 <jethr0> "hmm, i have this series here and would like to know what it is, let's ask @oeis"
18:51:20 <wli> @beis 1,1,2,2,4,2,6
18:51:21 <Cale> Unfortunately, it cuts off the descriptions too early.
18:51:21 <lambdabot> Euler totient function phi(n): count numbers <= n and prime to n.
18:51:21 <lambdabot> [1,1,2,2,4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,1...
18:51:42 <jethr0> @oeis 3.14159265
18:51:42 <lambdabot> Decimal expansion of Pi.
18:51:42 <lambdabot> [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,...
18:52:05 <jethr0> where do the series come from?
18:52:14 <ddarius> @help oeis
18:52:14 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
18:52:17 <pjd> jethr0: http://www.research.att.com/~njas/sequences/
18:52:17 <Cale> A huge user-populated database.
18:52:17 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
18:52:19 <jethr0> aahh
18:52:31 <jethr0> @oeis 42
18:52:32 <lambdabot> Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called ...
18:52:32 <lambdabot> [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35...
18:52:36 <Cale> haah
18:52:42 <BMeph> "Many hands make light work." ;)
18:52:52 <jethr0> @oeis 1,1,1,1,1,1,1
18:52:52 <lambdabot> The simplest sequence of positive numbers: the all 1's sequence.
18:52:52 <lambdabot> [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:52:53 <Cale> That is an awesome response.
18:52:56 <Cale> (to 42)
18:53:15 <Cale> @oeis 1
18:53:17 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
18:53:17 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:53:20 <BMeph> @oeis 1, 1, 2, 5, 9, 20
18:53:21 <lambdabot> a(n) = |b(n)|^2 = x^2 + 3*y*2 where (x,y,y,y) is the quaternion b(n) of the s...
18:53:21 <lambdabot> [1,1,2,5,9,20,41,85,178,369,769,1600,3329,6929,14418,30005,62441,129940,27040...
18:53:21 <jethr0> why is "repeat 1" simpler than any other repeated number?
18:53:23 <Cale> @oeis 4
18:53:24 <lambdabot> Euler totient function phi(n): count numbers <= n and prime to n.
18:53:24 <lambdabot> [1,1,2,2,4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,1...
18:53:24 <ddarius> Cale: Isn't that the first thing that comes to your mind?
18:53:31 <Cale> ddarius: yeah :)
18:53:40 <Cale> ddarius: strangely enough :)
18:53:42 <Valodim> what's "oeis"?
18:53:51 <Cale> @go oeis sloane
18:53:52 <lambdabot> http://www.research.att.com/~njas/sequences/
18:53:53 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
18:54:04 <Valodim> ah
18:54:19 <Valodim> cool stuff
18:54:23 <wli> What's that tricky way of computing binomial coefficients in a one-off manner?
18:55:06 <wli> I think it has something to do with computing the exponents of prime powers dividing a given factorial.
18:55:15 <chessguy> wonder how many sequences are in that encyclopedia
18:55:25 <wli> And with Legendre symbols.
18:55:26 <jethr0> wli, wouldn't that be using pascal's triangle?
18:55:37 <wli> jethr0: No, that's too slow.
18:56:02 <jethr0> > take 10 $ iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
18:56:02 <Cale> Contains 136510 sequences.
18:56:03 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
18:56:12 <jethr0> wli, you didn't say anything about fast
18:56:32 <chessguy> Cale, where'd you find that?
18:56:41 <Cale> chessguy: At the bottom of the main page.
18:56:58 <chessguy> aha
18:57:00 <Cale> Note that if you can't locate a sequence, there's also Superseeker: http://www.research.att.com/~njas/sequences/ol.html
18:57:00 <lambdabot> Title: Email Servers and Superseeker
18:57:11 <chessguy> they should make a bigger deal of that
18:57:17 <Cale> It will work a bit harder to find an explanation of your sequence.
18:57:35 <Cale> (applying various transforms, and such)
19:00:47 <sclv> are any of the haskelldb maintainers on here?
19:01:07 <sclv> someone should really package up the .11 version for hackage so cabal install works with 6.8
19:13:54 <TomMD> ?users
19:13:54 <lambdabot> Maximum users seen in #haskell: 465, currently: 405 (87.1%), active: 13 (3.2%)
19:23:27 * ddarius decides to read a novel.
19:23:44 <dons> don't be crazy
19:29:34 <wagle_> steve jobs sez people dont read books any more..
19:31:18 <dolio> I read books occasionally.
19:31:47 <wli> All my books are 1000 miles away.
19:32:01 * dons reads irc logs
19:32:12 <dons> and compiler internals for a change
19:32:52 <dolio> Does the fellow in charge of haddock frequent this place?
19:33:00 <wli> re wagle
19:54:17 <dolio> @yow
19:54:17 <lambdabot> I brought my BOWLING BALL -- and some DRUGS!!
19:54:37 <dons> yay!
19:55:22 <wagle_> > fix @yow
19:55:23 <lambdabot>  Parse error in expression at end of input
19:55:38 <wagle_> 8(
20:05:06 <yondalf> what's the difference between the Reader monad and the State monad?
20:05:20 <nelhage> The State monad allows actions to update the value of the stored state
20:05:27 <Cale> yondalf: With the state monad, you have an action which updates the state.
20:06:01 <yondalf> can't you do that with the Reader monad as well, with the local function?
20:06:14 <Cale> yondalf: But that's only locally.
20:06:41 <yondalf> Cale: hmm...okay, i think i had better read http://www.haskell.org/all_about_monads/html/readermonad.html more carefully
20:06:41 <lambdabot> Title: The Reader monad
20:06:53 <Cale> yondalf: So the environment changes for the context of that one action, and then goes back afterward.
20:07:14 <yondalf> Cale: ah...okay
20:08:05 <Cale> (So unless you want to program entirely by nesting calls to local, it's very different.)
20:15:31 <BMeph> Oh, boy, server split! :p
20:16:16 <chessguy> wheeeee
20:23:12 <dons> ?users
20:23:12 <lambdabot> Maximum users seen in #haskell: 465, currently: 382 (82.2%), active: 8 (2.1%)
20:23:17 <yondalf> hmm...yeah i think i get it now
20:29:49 <hpaste>  Cale pasted "humourously broken primality testing" at http://hpaste.org/5408
20:30:30 <Cale> Interestingly enough, every prime n will give True for brokenIsPrime n
20:35:36 <wagle_> \x . True
20:35:57 <mrd> > const True 13
20:35:59 <lambdabot>  True
20:36:14 <Cale> [2,3,5,7,11,12,13,15,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,41,42,43,45,47,50,51,52,53,54,55,56,57,58,59,61,62,63,65,67,70,71,72,73,74,75,76,77,78,79,82,83,85,87,89,92,93,95,97,101...
20:40:51 <Cale> It would be nice to have a way in ghci to specify that you'd like an expression to be compiled with -O2 before evaluating.
20:41:25 <dons> hmm. works on module level
20:41:32 <dons> {-# OPTIONS -O2 #-}
21:05:23 <dons> ddarius: darcs get info wrong in that email
21:10:28 <ddarius> Uh, yeah...
21:12:25 <bos> parsec is more pleasant to use via appropriate Applicative and Alternative instances, i notice.
21:26:23 <ddarius> *sigh*  There will be no novel reading for me.
21:27:56 <ddarius> Oh well. Sleep.
21:32:35 <Cin> ddarius: bit of terry pratchett?
21:46:12 <jethr0> is there a standard way to represent error conditions in library wrappers. (i.e. mapping returned NULL pointers from c libraries to IO exceptions?)
21:48:09 <aaml> hey guys...does anyone know what Yi uses for syntax highlighting?
21:48:27 <aaml> is that front-end specific (like Gtksourceview) or does it use its own highlighter?
21:48:43 <sarehu> probably its own
21:48:54 <Cale> mm...
21:48:55 <sarehu> ^^ said as somebody with no clue but some psychological evidence
21:50:07 <jethr0> are you using yi with emacs or vim bindings? (/me has no clue what yi's current status is)
21:50:09 <Cale> Yeah, it looks like it's using alex now.
21:50:10 <sarehu> hrm, according to the Yi page, it uses GTk sourceview
21:50:15 <Cale> oh
21:50:16 <Cale> hmm
21:50:45 <sarehu> Well, it depends on whether you're using vty or gtk
21:50:47 <Cale> I know that for at least some time, it was indeed using GTK Sourceview to do the syntax highlighting, but I have no idea if that's changed or what.
21:50:51 <aaml> sarehu: I thought I had read that, but how does the Vty (sp?) engine do syntax highlighting?
21:50:58 <sarehu> I will keep pounding F3 and giving updates :)
21:51:05 <Cale> aaml: Seemingly alex.
21:51:23 <Cale> (see Yi/Syntax/*.x )
21:52:22 <Gwern-away> yep
21:52:33 <bos> @ask
21:52:33 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
21:52:33 <aaml> hmm
21:53:03 <aaml> a lexer generator is pretty unique
21:53:07 <Gwern-away> how does vty do it, though? I guess it does it the way most cli apps do, through escape codes
21:53:10 <aaml> I've heard of parser compilers but not lexer compilers
21:53:27 <Cale> Really? They're pretty common.
21:53:33 <sorear> Gwern-away: duh.  that's the ONLY way to set color on terminals.
21:53:37 <Cale> flex, for example
21:53:52 <Cale> or the original lex to go with yacc
21:54:07 <Gwern-away> sorear: if it was that duh, would aaml have asked?
21:54:13 <aaml> I'm apparently pretty uninformed
21:54:49 <sorear> Gwern-away: You're the one who asked.
21:54:53 <sorear> 21:53 < Gwern-away> how does vty do it, though? I guess it does it the way most cli apps do, through escape codes
21:55:14 <sorear> aaml: An alex lexer.
21:55:55 <Gwern-away> sorear: that was, ah, a rhetorical question, employed in part because aaml had asked the question I was answering  half a screen up
21:56:10 <Gwern-away> and the question added context
21:56:17 <sorear> oh
21:56:36 <sorear> I just jumped in because my vty highlight fired :)
21:56:39 * sorear disappears
21:58:29 <Gwern-away> (I don't know why, but lately it seems that both here and reddit I'm getting misunderstood a lot. it's kind of odd. maybe I need to get more sleep)
21:59:04 <Gwern-away> aaml: actually, I'm not sure Yi uses SourceView any more
21:59:22 <Gwern-away> grep doesn't turn up anything, and darcs changes has this patch:
21:59:30 <Gwern-away>   * Use same syntax highlighting for gtk frontend.
21:59:35 <Gwern-away>  As an added benefit, we no longer depend on SourceView. Hence Yi should be
21:59:35 <Gwern-away>   compilable on windows.
21:59:49 <Gwern-away> (from June of last year)
22:01:57 * Gwern-away updates the wiki entry
22:52:00 <wli> Netsplit?
22:52:12 <kaol> @users
22:52:12 <lambdabot> Maximum users seen in #haskell: 465, currently: 380 (81.7%), active: 2 (0.5%)
22:52:47 * kaol enjoys the sound of one hand clapping
22:56:50 <oerjan> > (!!) ["CLAP ","     "] =<< randomRs (0,1) (mkStdGen 42)
22:56:52 <lambdabot>  "               CLAP CLAP      CLAP      CLAP                CLAP CLAP CLAP ...
23:05:39 <sarehu> ok, that's hilarious
