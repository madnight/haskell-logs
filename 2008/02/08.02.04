00:00:13 <Cin> cale: ahhh, cool. that's what i meant. so if i have some "constant" kind of value that you see in other languages, like serverDescription = serverName ++ " :The Haskell IRCd!" -- it's not exactly going to re-evaluate that every time i use serverDescription
00:00:16 <Cale> Prometheus88: Haskell is a really fun language to use once you've got the hang of it. It's by far my favourite programming language.
00:00:30 <Cale> Cin: right
00:00:35 <Cin> well that's good to know
00:00:40 <Cin> thanks
00:00:51 <Cale> Cin: But if it's in, say, a let or where clause to another function, then it'll get reevaluated for each call to that function.
00:01:03 <siti> I must concur.  Programming in haskell is awesome and so much fun.
00:01:11 <Cin> cale: yeah, i can see why that makes sense
00:01:22 <siti> having 80-90% reduced bug count is probably part of the reason ;)
00:01:26 <Prometheus88> Cale: ok I dont know if itll become my favorite, but I only know a few lang anyways, ill be sure to visit more often since functional programming is very intriguing
00:01:44 <olsner> haskell is made of win and awesome, as you will come to realize in due time
00:01:44 <Prometheus88> I do like the typing
00:01:53 <Cale> olsner: ;)
00:01:59 <Prometheus88> though I dont know ecnough to figure out where I went wrong
00:02:01 <Cin> siti: i think i've experienced about 5 bugs in total, 2 of which threw an exception, in the week i've taken to write what i have so far of my ircd. pretty good going
00:02:11 <siti> nice
00:02:11 <Cale> Prometheus88: It gets easier.
00:02:35 <siti> some functions you must learn to avoid, then it's mostly gravy :)
00:02:38 <siti> e.g. head = evil
00:02:55 <Prometheus88> Cale: I guess thats why this class im taking is called programming paradigms, it is much different from OO/procedural
00:02:55 <siti> fromJust = evil
00:03:04 * Cin looks at the fromJust in his code... 
00:03:07 * Cin whistles
00:03:09 <kmcallister> Prometheus88, once you understand the haskell type errors you will be unstoppable :)
00:03:10 <siti> hehe
00:03:12 <Cale> Prometheus88: right, it's sort of like learning to program all over again :)
00:03:27 <sarehu> they should have had   head :: [a] -> Maybe a
00:03:32 <siti> hehe
00:03:33 <sarehu> there's always unsafeCoerce :)
00:03:35 <siti> listToMaybe :p
00:03:36 <kmcallister> because each of those type errors would have been a nasty latent logical error in a less awesome language :)
00:03:44 <Cale> I concur on the type errors point. Understanding the type system is the most important thing you can do as a beginner.
00:04:15 <Prometheus88> Cale: its really weir dthough after coming from "huge asgts" where I would be making an app database and so forth
00:04:19 <Cale> The second most important thing is learning how to replace all your loops with maps, filters and folds.
00:04:30 <dmwit> ?src MonadTrans
00:04:31 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:04:38 <wagle_> i think you gotta lift Maybe into a bunch of Monads before head_maybe is useful
00:04:55 <Cale> wagle_: maybe... :)
00:05:07 <Cin> fold makes my code look hot
00:05:16 <siti> lol
00:05:25 <Cale> head :: (MonadZero m) => a -> m a
00:05:29 <Cale> *sigh*
00:05:30 <Cale> hehe
00:06:18 <dmwit> Is there a (.) for type constructors?
00:06:34 <Cale> dmwit: See the TypeCompose package.
00:06:52 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/TypeCompose-0.3
00:06:53 <lambdabot> http://tinyurl.com/2x7e2z
00:07:02 <Cale> http://haskell.org/haskellwiki/TypeCompose
00:07:10 <Cale> http://darcs.haskell.org/packages/TypeCompose/doc/html/
00:07:11 <kmcallister> is there a document somewhere comparing haskell's type system to System F?
00:07:12 <Cale> :)
00:07:53 <Cin> so, on average i think my functions reach a maximum of 15 lines in number of lines. i hope i can keep this up. i *hate* long functions with intense passion
00:08:23 <siti> well it's pretty easy to split functions :p
00:08:44 <Cin> siti: yeah. _why don't people do it?_ ;_;
00:08:57 <siti> refactoring is another strength of haskell, it's great changing code with (usually) no bugs :)
00:09:13 <kmcallister> yeah, type-directed refactoring is useful
00:09:50 <Cin>  17  addClient :: ClientID -> Chan Message -> State -> IO State
00:09:50 <Cin>  18  addClient id ch state = return state { stateClients = newClients } where
00:09:50 <Cin>  19      newClients = Map.insert id (newClient ch) (stateClients state)
00:09:56 <Cin> is this function too *wide*?
00:10:02 <Cin> i can't tell because my resolution is big
00:10:07 <siti> lol
00:10:15 <dmwit> 80 is the standard width
00:10:23 <Cin> 80, hm. let me check that on emacs
00:10:29 <siti> I make mega wide functions too, I am spoilt by an insane res :D
00:10:44 <wagle_> iavor uses the full width of his screen
00:10:58 <Cale> http://en.wikipedia.org/wiki/Ludics -- this is quite possibly the most awesome wikipedia page ever, once you know exactly what it is that it's about.
00:10:59 <lambdabot> Title: Ludics - Wikipedia, the free encyclopedia
00:11:17 * glguy just doesn't let his terminals grow horizontally
00:11:22 <glguy> and uses that extra resolution to tile them
00:12:43 <Cin> i wonder if it's possible to get emacs to display a shaded line where the 80th column is
00:13:22 <olsner> @quote emacs
00:13:23 <lambdabot> Philippa says: because emacs wasn't a good enough OS after all
00:13:30 <wagle_> i havent tiled my displays since i stopped having a two-headed machine
00:13:37 <kmcallister> @quote yi
00:13:37 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
00:15:15 <proqesi> oh my
00:16:05 <hpaste>  Prom annotated "map" with "map" at http://hpaste.org/5451#a2
00:16:09 <olsner> cool, paypal can bill me in my local currency so that I don't have to pay currency conversion fees to my bank
00:16:20 <Prometheus88> Im commenting my code now, did I explain it properly?
00:16:32 <Prometheus88> the double map I mean
00:17:05 <Cale> The wording is a little awkward, but the idea is right, I think.
00:17:28 <Cale> It's "map (replaceChar ch1 ch2)" as well -- the parens matter a lot.
00:17:53 <Cale> provided by -> provided to -- would make it a bit better
00:18:08 <Prometheus88> ok changed
00:18:59 <Prometheus88> so if i was to trace this function, does the inner map hold a new function g which would be applied by map to pic?
00:19:20 <Cale> hmm, if you were to trace the function... :)
00:19:40 <Cale> Well, things would be a little funny because Haskell applies all functions outermost first.
00:19:56 <dmwit> Prometheus88: Note that you don't need (from a semantics point of view) two separate cases in replace.
00:20:13 <Cale> So the first thing which would happen is that the outer map would take the (map (replaceChar ch1 ch2)) and the pic, and it would pattern match on pic
00:20:15 <dmwit> Prometheus88: That is strictly an optimization.
00:20:30 <kmcallister> Prometheus88, have you done any lambda calculus?
00:20:37 <Prometheus88> oh hey youre right, if i left that out it would still work
00:20:44 <Prometheus88> I didnt notice thank you
00:20:45 <Cale> If pic was a nonempty list (x:xs), then it would result in  (map (replaceChar ch1 ch2)) x : map (map (replaceChar ch1 ch2)) xs
00:20:51 <Cale> immediately
00:20:51 <Prometheus88> no lambda calculus before
00:21:20 <Prometheus88> Cale: ok so then my explanation is kind of wrong then
00:21:27 <Cale> and since : is a constructor, it might just stop there.
00:21:28 <kmcallister> Prometheus88, it's easier to think of Haskell terms reducing in the same way as lambda terms, rather than a traditional "trace"
00:21:46 <Cale> Prometheus88: But if you want to think of map as a loop, you're free to do so.
00:21:59 <Cale> Prometheus88: In some sense, lists are loops.
00:22:36 <kmcallister> Prometheus88, you're free to think of map as a loop, but i would recommend against it :)
00:22:46 <kmcallister> in particular there's no notion of execution order
00:23:04 <Cale> Until you get to talking about lazy evaluation specifically.
00:23:16 <kmcallister> yeah
00:23:40 <Prometheus88> ok lazy evaluation is at the end as well of this course, but essentially, the first map results in a function that is missing a third parmater of a list of char
00:23:42 <siti> mmmh lazy :)
00:23:42 <Cale> Haskell as standardised doesn't specify which order things get evaluated in. (It doesn't matter, as long as you always terminate when there's a way to terminate)
00:23:45 <kmcallister> i just think: map f [a,b,c]  ==> [f a, f b, f c]
00:23:58 <Prometheus88> yes I understand that defn of map
00:24:09 <kmcallister> yeah in fact you wrote it :)
00:24:33 <Cale> Prometheus88: replaceChar ch1 ch2  results in a function of type Char -> Char
00:24:49 <Cale> applying map to it once gives a function [Char] -> [Char]
00:24:54 <Cale> and then again gives a function [[Char]] -> [[Char]]
00:25:08 <Cale> and then that function is applied to a list of lists of characters
00:25:35 <Cale> Does that make sense?
00:25:40 <Prometheus88> oh right one of you mentioned that before ok, ill use :t on this to make sure I ge tthe types
00:25:52 <Cale> > (+1) 3
00:25:54 <lambdabot>  4
00:26:00 <Cale> > map (+1) [1,2,3,4,5]
00:26:03 <lambdabot>  [2,3,4,5,6]
00:26:15 <Cale> > map (map (+1)) [[1,2,3,4,5],[6,7],[8,9,10]]
00:26:16 <lambdabot>  [[2,3,4,5,6],[7,8],[9,10,11]]
00:27:02 <Cale> > (map (+1)) [1,2,3,4,5]
00:27:03 <lambdabot>  [2,3,4,5,6]
00:27:34 <Prometheus88> ctually I really like the explanation u gave plus kmcallisters defn from way back up top which is the same thing, copy paste saved :)
00:28:09 <Cale> :)
00:29:22 <Cale> > filter odd [1..10]
00:29:23 <lambdabot>  [1,3,5,7,9]
00:29:59 <Cale> > zip [0..] "Hello"
00:30:00 <lambdabot>  [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
00:30:24 <Prometheus88> so map map does all the legwork to make replaceChar ready to accept a type of [[char]]
00:30:32 <Cale> Right.
00:30:53 <Cale> (map . map) -- if you want to get picky  :)
00:31:00 <luqui> > sortBy (compare `on` snd) $ zip [0..] $ "Hello World"
00:31:01 <lambdabot>   Not in scope: `on'
00:31:07 <luqui> > sortBy (comparing snd) $ zip [0..] $ "Hello World"
00:31:08 <lambdabot>  [(5,' '),(0,'H'),(6,'W'),(10,'d'),(1,'e'),(2,'l'),(3,'l'),(9,'l'),(4,'o'),(7...
00:31:31 <dmwit> ?let on (*) g x y = g x * g y
00:31:35 <lambdabot> Defined.
00:31:43 <dmwit> > sortBy (compare `on` snd) $ zip [0..] $ "Hello World"
00:31:44 <lambdabot>  [(5,' '),(0,'H'),(6,'W'),(10,'d'),(1,'e'),(2,'l'),(3,'l'),(9,'l'),(4,'o'),(7...
00:31:45 <Cale> > concat (map (\(n,c) -> replicate n c) (zip [0..] "Stutter"))
00:31:45 <lambdabot>  "tuuttttttteeeeerrrrrr"
00:31:49 <Cale> > concat (map (\(n,c) -> replicate n c) (zip [1..] "Stutter"))
00:31:50 <lambdabot>  "Sttuuuttttttttteeeeeerrrrrrr"
00:32:18 <Cale> > concatMap (\(n,c) -> replicate n c) (zip [1..] "Stutter")
00:32:19 <dmwit> > zip [1..] "stutter" >>= uncurry replicate
00:32:19 <lambdabot>  "Sttuuuttttttttteeeeeerrrrrrr"
00:32:20 <lambdabot>  "sttuuuttttttttteeeeeerrrrrrr"
00:32:28 <sarehu> <Cale> (map . map) -- if you want to get picky  :)
00:32:40 <sarehu> or ((.) . (.)) ?   eek
00:32:53 <Cale> sarehu: exactly. ;)
00:34:27 <Cale> sarehu: from that we can take some enlightenment as to how that trick for composing multi-arg functions works.
00:34:56 <dmwit> fmap . fmap -- what the heck, implement both at once
00:35:11 <Cale> dmwit: right, sarehu was alluding to my generalisation of (.)
00:35:29 <dmwit> Oh, let (.) = fmap in ... ?
00:35:32 <Cale> yeah
00:35:39 <dmwit> I like it. =)
00:36:19 <Cale> It's especially nice since the main functor axiom results in the associativity of (.)
00:36:32 <wagle_> :t fmap
00:36:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:36:41 <wagle_> :t (.)
00:36:41 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
00:36:50 <sarehu> actually, s/((.) . (.))/((.) (.) (.))/
00:37:35 <wagle_> :t ((.) . (.))
00:37:36 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:37:44 <wagle_> :t ((.) (.). (.))
00:37:44 <lambdabot> forall a b c a1. (b -> c) -> (a1 -> b) -> (a -> a1) -> a -> c
00:37:48 <wagle_> :t ((.) (.) (.))
00:37:49 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:38:04 <Cale> :t ((.) . (.) . (.))
00:38:05 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
00:38:45 <Cale> It's just a little insane to write it like that though.
00:39:08 <wagle_> > (.) (+1) [1,2,3]
00:39:09 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
00:39:23 <wagle_> > ((.) . (.)) (+1) [1,2,3]
00:39:24 <lambdabot>  Couldn't match expected type `a -> a1 -> b'
00:39:40 <Cale> It's possibly much clearer to see it as  (fmap . fmap . fmap), with the functors (->) a,  (->) a1, and (->) a2
00:39:43 <vininim> > (.) (+1) [(+1),(+2),(+3)]
00:39:43 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
00:40:00 <vininim> bleep
00:40:09 <Cale> vininim: We don't have the definition in the bot :)
00:40:41 <nominolo> @seen dcoutts_
00:40:41 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts_ speak 7h 19m 44s ago.
00:40:41 <Cale> vininim: It involves replacing the usual definition of (.) with (.) :: Functor f => (a -> b) -> (f a -> f b); (.) = fmap
00:40:58 <wagle_> > ((.) :: (Functor f) => (a -> b) -> f a -> f b) (+1) [1,2,3]
00:40:59 <lambdabot>   `.' is applied to too few arguments
00:40:59 <lambdabot>     In the expression: (.)
00:40:59 <lambdabot>     In the e...
00:41:03 <dmwit> vininim: That wouldn't even work if we did have (.) = fmap, would it?
00:41:05 <vininim> my stuff is wrong anyway
00:41:23 <Cale> mm, yeah, I didn't notice the contents of that list :)
00:41:24 <dmwit> > fmap (fmap (+1)) [(+1), (+2), (+3)] -- maybe you mean this
00:41:25 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
00:41:50 <wagle_> the claim was that (.) == fmap
00:42:04 <vininim> yeah
00:42:05 <dmwit> No, no, no, the suggestion was to make (.) = fmap.
00:42:19 <dmwit> There was no claim that it was *already* that way.
00:43:06 <nominolo> @tell dcoutts_ Here's one more way how Cabal bug #220 can look to the user: http://groups.google.com/group/yi-devel/browse_thread/thread/34c097335266f523 (see also my response in that thread)
00:43:06 <lambdabot> Consider it noted.
00:43:32 <nominolo> @tell dcoutts dcoutts_ has a message from me ;)
00:43:32 <lambdabot> Consider it noted.
00:44:16 <wagle_> it all makes sense now
00:47:18 <Cale> @check \x -> abs (cos x - cos (x + 2*pi)) < 0.00001
00:47:20 <lambdabot>  Add a type signature
00:47:31 <Cale> @check \x -> abs (cos x - cos (x + 2*pi)) < (0.00001 :: Double)
00:47:32 <lambdabot>  OK, passed 500 tests.
00:48:05 <Cale> @check \x -> abs (cos x - cos (x + 2*pi)) < (0.0000001 :: Double)
00:48:06 <lambdabot>  OK, passed 500 tests.
00:48:13 <Cale> @check \x -> abs (cos x - cos (x + 2*pi)) < (0.000000000001 :: Double)
00:48:14 <lambdabot>  OK, passed 500 tests.
00:48:33 <Cale> @check \x -> abs (cos x - cos (x + 2*pi)) < (10^(-20) :: Double)
00:48:34 <dmwit> ?smallcheck \x -> abs (cos x - cos (x + 2*pi)) < (0.000000000001 :: Double)
00:48:36 <wagle_> > (\x ->  abs (cos x - cos (x + 2*pi))) (10^100)
00:48:36 <lambdabot>  Exception: Prelude.^: negative exponent
00:48:36 <lambdabot> Unknown command, try @list
00:48:37 <lambdabot>  0.0
00:48:42 <Cale> @check \x -> abs (cos x - cos (x + 2*pi)) < (10^^(-20) :: Double)
00:48:42 <lambdabot>  Falsifiable, after 0 tests: -0.5
00:48:50 <wagle_> > (\x ->  abs (cos x - cos (x + 2*pi))) (10^50)
00:48:50 <lambdabot>  0.0
00:49:00 <dmwit> ?scheck \x -> abs (cos x - cos (x + 2*pi)) < (0.000000000001 :: Double)
00:49:01 <lambdabot>   Completed 79 test(s) without failure.
00:49:22 <Cale> @check \x -> abs (cos x - cos (x + 2*pi)) < (10^^(-15) :: Double)
00:49:23 <lambdabot>  Falsifiable, after 79 tests: 11.714285714285714
00:49:27 <Cale> :)
00:50:04 <dmwit> Binary search to discover the exponent. ;-)
00:51:05 <Cale> hmmm
00:52:00 <dmwit> > cos 0.5 - cos (0.5 + 2*pi)
00:52:01 <lambdabot>  -1.1741909528018013e-16
00:52:01 <Cale> > 11 + (714285/999999) :: Rational
00:52:02 <lambdabot>  82%7
00:52:41 <dmwit> eh?
00:52:44 <Cin> since when did google start changing the results it returns for a query depending on what i've searched for? that's great! now GHC shows Glorious Haskell Compiler for the first result :)
00:53:02 <dmwit> > 5%7 == (714285/999999 :: Rational)
00:53:02 <lambdabot>  True
00:53:23 <dmwit> ?go ghc
00:53:24 <lambdabot> http://www.haskell.org/ghc/
00:53:24 <lambdabot> Title: The Glasgow Haskell Compiler
00:53:33 <dmwit> Has it ever been something different?
00:53:42 <faxathisia> I wish forM gave the last thing
00:53:46 <luqui> not that I can recall
00:53:48 <faxathisia> instead just flip mapM
00:53:54 <Cin> shows "Group Health Cooperative" on mine, which is a .co.uk company
00:53:59 <dmwit> faxathisia: mapM?
00:54:05 <faxathisia> what ?
00:54:22 <luqui> fmap last . forM f ?
00:54:37 <dmwit> faxathisia: Oh, never mind, I misunderstood.
00:54:51 <dmwit> faxathisia: Maybe you want foldM?
00:54:52 * glguy tries to remember a time when that would have been more useful than the default behavior :-/
00:54:57 <dmwit> :t foldM
00:54:57 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
00:55:15 <Prometheus88> is it possible to use a recursive function that has multiple possible pathways?
00:55:28 <luqui> Prometheus88: what do you mean by that?
00:55:37 <dmwit> ?faq Is it possible to use a recursive function that has multiple possible pathways?
00:55:38 <lambdabot> The answer is: Yes! Haskell can do that.
00:55:39 <dmwit> ;-)
00:55:49 <Prometheus88> haha that was cool?
00:56:00 <kmcallister> Prometheus88, almost every recursive function will have multiple pathways, since you'll need a base case
00:56:05 <Prometheus88> Im implementing this: http://en.wikipedia.org/wiki/Flood_fill
00:56:05 <lambdabot> Title: Flood fill - Wikipedia, the free encyclopedia
00:56:10 <luqui> ?faq Is it possible to achieve enlightenment?
00:56:10 <wagle_> ?faq can Haskell solve N == NP?
00:56:11 <lambdabot> The answer is: Yes! Haskell can do that.
00:56:11 <lambdabot> The answer is: Yes! Haskell can do that.
00:56:17 <Prometheus88> haha yeah right
00:56:18 <Syzygy-> ?faq Is it possible to build a program that recognizes in finite time whether any given Turing machine halts?
00:56:18 <lambdabot> The answer is: Yes! Haskell can do that.
00:56:42 <dmwit> ?faq is not very smart
00:56:43 <lambdabot> The answer is: Yes! Haskell can do that.
00:56:56 <Syzygy-> ?faq you don't say!
00:56:56 <lambdabot> The answer is: Yes! Haskell can do that.
00:57:02 <luqui> Prometheus88: yes of course it is, but you have to phrase it in terms of returning thnigs
00:57:03 <dmwit> Prometheus88: That algorithm should be no problem in Haskell.
00:57:13 <wagle_> ?faq will haskell bring me a beer?
00:57:13 <lambdabot> The answer is: Yes! Haskell can do that.
00:57:20 <luqui> Prometheus88: calling a function recursively and throwing away the result is meaningless
00:57:25 <Prometheus88> righto I will get to it then, and i hope to phrase it correctly then
00:57:38 <Syzygy-> wagle_: Just sit back and wait for that beer now.
00:58:03 <Prometheus88> right Ill recurse on modified picture no matter which pathway it goes
00:58:16 <luqui> exactly
00:58:44 <dmwit> The section on scanline fill is a bit disappointing.
00:59:55 <luqui> ugh, haskell has corrupted my mind
01:00:10 <luqui> I'm trying to solve a problem in C#, and all I can think to myself is "this data structure is a monad"....
01:00:22 <araujo> Haskell is bad ..... It makes you hating other languages
01:00:48 <kmcallister> luqui, so implement monads in C#
01:00:52 <luqui> (And I'm not using C# 3, which is vaguely capable of expressing monadic things succinctly)
01:01:10 <Prometheus88> ok Im stilli thinking non haskell...I need to find the "node" seperate from the recursive function right?
01:02:00 <b_jonas> luqui: heh
01:02:33 <vininim> vimperator <3
01:03:21 <luqui> flood color (x,y) pic | getPixel (x,y) pic == color = pic
01:04:19 <luqui>         | otherwise = floodfill color (x+1,y) $ floodfill color (x,y+1) $ ...
01:04:26 <luqui> (I might be way off, haven't thought it through)
01:04:29 <Prometheus88> what does the | do?
01:04:38 <luqui> Read it as "where"
01:04:44 <Prometheus88> or do u mean it as a conditional?
01:04:45 <Prometheus88> oh ok
01:05:07 <luqui> oh right
01:05:14 <luqui> where is a keyword.  not like that where.  :-)
01:05:25 <Prometheus88> ok :)
01:05:28 <dmwit> You may have the conditional backwards.
01:05:44 <dmwit> ...depending on what you want flood to mean.
01:06:05 <Prometheus88> Im going to flood based on a character?
01:07:13 <Prometheus88> I mean Im going to do getpixel pic x y == 'c' then calll itself again
01:09:11 <luqui> not sure what you're asking... if anything
01:10:29 <Prometheus88> im not asking anything sorry its late
01:17:23 <ac> is there a way to export QuickCheck properties with a module?
01:18:05 <ac> like, "if you're going to use this function, you better make sure that argument X is a list with at least one element"
01:19:07 <quicksilver> that's not really a quickcheck properties
01:19:19 <quicksilver> that's a precondition
01:19:28 <quicksilver> I'm not denying it would be useful, but it's not the same :)
01:19:46 <ac> oh. I've never used quick check actually
01:20:21 <ac> it would be cool if your code would be automatically tested against such things
01:20:37 <quicksilver> well, it can. Just put in assertions :)
01:20:46 <quicksilver> and have a flag to compile them out.
01:21:13 <hpaste>  Prom pasted "floodfill" at http://hpaste.org/5455
01:21:13 <ac> what's the difference between an assertion and getting a "head on [] exception" during run time?
01:21:30 <Prometheus88> can you tell me why my base case is wrong for typing?
01:22:12 <dmwit> ac: not much
01:22:29 <faxathisia> If you had an interpreter in haskell for some language, How would you have mutable objects?
01:22:50 <faxathisia> so old references to things see updates
01:23:02 <quicksilver> by implementing references in some way
01:23:15 <quicksilver> you could be ugly and hackish and use IORefs directly
01:23:27 <quicksilver> or you could be a bit more abstract and just use a newtype'ed Int
01:23:33 <quicksilver> which is an index into the list of objects
01:23:45 <quicksilver> (probably not really a list, for efficiency reasons)
01:23:52 <faxathisia> Alright
01:23:58 <dmwit> Prometheus88: A few comments.
01:24:06 <vininim> screen, irssi, emacs and now xmonad and vimperator keybinds. I hope my brain doesn't melt
01:24:13 <dmwit> "not" is not the same as "/="
01:24:51 <dmwit> Your out-of-bounds check is needlessly complicated.
01:25:20 <wagle_> write a frontend that inputs one set of key bindings, and translates to each application's keybindings
01:25:25 <dmwit> (x < 0 || y < 0 || x > getWidth pic - 1 || y > getHeight pic - 1) is much simpler.
01:25:34 <sieni> vininim: well, dump emacs and use vim :-)
01:25:48 <ac> vininim: what's vimperator?
01:25:49 <wagle_> heresy!  burn 'im!
01:25:57 <dmwit> You don't have any recursion at all, so calling "floodFillr" a base case is a bit ingenuous.
01:25:59 <Prometheus88> dmwit: the problem is that floodfill has to go to a certain character
01:25:59 <vininim> sieni: I actually thought about that, but then I would need to search for another OS ;)
01:26:03 <dmwit> ...disingenuous
01:26:07 <Syzygy-> Just drop all of those, and use butterflies
01:26:15 <Prometheus88> dmwit: i was going to put the recursion in the otherwise step
01:26:20 <vininim> ac: firefox extension for vim-like keybinds and modal gui
01:26:25 <dmwit> Prometheus88: Oh, ok.
01:26:27 <Prometheus88> dmwit: should I be using /= instead of not then
01:26:27 <sieni> vininim: well, you can do your vim scripting in perl ,-)
01:26:34 <ac> vininim: oh yeah, I installed that once. It was pretty cool
01:26:40 <wagle_> crashing your butterfly isnt pretty
01:26:45 <dmwit> Prometheus88: Probably, but it depends on what you actually meant. =P
01:27:36 <Prometheus88> ok: let me comment this code out a bit so I can explain
01:29:32 <ac> in what contexts can I use a guard?
01:30:10 <dmwit> Function definition and case statements.
01:30:13 <dmwit> I think that's it.
01:30:52 <dmwit> You might count list comprehensions as having a kind of "guard", but the meaning is slightly different.
01:31:18 <hpaste>  taejo pasted "chaining inequalities" at http://hpaste.org/5459
01:31:28 <ac> so you can say: case foo of Bar -> | ... --?
01:31:38 <quicksilver> case foo of Bar | ... ->
01:31:45 <Taejo> I'm trying to set up something like Python's 1 < 2 < 3, but I'm getting type errors
01:31:48 <quicksilver> it's just like the definition case
01:31:58 <quicksilver> except -> takes the place of =
01:32:09 <ac> ah ok
01:33:45 <dmwit> Hmm, these .txt and .java files have +x on them.
01:33:57 <dmwit> err.. wrong channel, sorry
01:34:09 * quicksilver executes dmwit's txt files
01:34:18 <hpaste>  (anonymous) annotated "floodfill" with "(no title)" at http://hpaste.org/5455#a1
01:34:58 <Taejo> Can somebody help me with my type errors: it works when I do "Just (1::Integer) <& (2::Integer) <& (3::Integer)" but not "Just 1 <& 2 <& 3"
01:35:06 <Prometheus88> dmwit: I want to to test for equivalence between two different characters
01:35:29 <dmwit> Prometheus88: (==) tests for equivalence, (/=) tests for... inequivalence
01:35:33 <dmwit> > 'a' == 'a'
01:35:36 <lambdabot>  True
01:35:42 <dmwit> > 'a' /= 'b'
01:35:43 <lambdabot>  True
01:35:57 <Prometheus88> a corollary i hope is that it takes care of outside the boundaries
01:36:01 <faxathisia> Taejo, What does ((Just 1 <& 2 <& 3) :: Maybe Bool) do?
01:36:07 <faxathisia> oops
01:36:13 <faxathisia> ((Just (1 <& 2 <& 3)) :: Maybe Bool)
01:36:15 <siti> are there any crc32 libs for bytestrings?
01:36:18 <Taejo> faxathisia: see http://hpaste.org/5459
01:36:40 <Prometheus88> ah i was using != which didnt work so i thought it was not
01:36:55 <Taejo> uhh Maybe Bool? it isn't meant to have that type
01:37:17 <Taejo> it's either Bool or Num a => Maybe a
01:38:16 <wagle_> :t [1,2,3]
01:38:17 <lambdabot> forall t. (Num t) => [t]
01:38:23 <quicksilver> Taejo: more likely to help you if you tell us what the error is :P
01:38:40 <b_jonas> @t (<&)
01:38:41 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:38:44 <b_jonas> @type (<&)
01:38:45 <lambdabot> Not in scope: `<&'
01:38:50 <faxathisia> Taejo ((Just (1 <& 2 <& 3)) :: Maybe Bool)
01:39:02 <Taejo> quicksilver: No instance for (Output (Maybe b) t)
01:39:17 * ac thinks guards are a good way to implement preconditions
01:39:21 <faxathisia> oh I see
01:39:39 <Taejo> faxathisia: it's (Just 1) <& 2 <& 3
01:40:20 <Taejo> (<&) :: (Ord b, Output c b) => Maybe b -> b -> c
01:40:46 <Taejo> there are two instances of Output: instance Ord b => Output (Maybe b) b
01:40:55 <sieni> hmm... vimperator seems ok, but it doesn't solve the most important issue, i.e. vi-style editing of text fields
01:40:57 <Taejo> and instance Ord b => Output Bool b
01:41:02 <sieni> oh, the suckiness
01:41:30 <b_jonas> does Output have a fundep?
01:42:11 <Taejo> b_jonas: no
01:42:42 <b_jonas> and in which direction does <& associate? how does (Just 1) <& 2 <& 3 parse?
01:42:55 <Taejo> it associates left
01:43:05 <wagle_> Taejo, s/Just/just/ ?
01:43:23 <Taejo> wagle_: no
01:43:27 <wagle_> ok
01:43:29 <ac> sieni: use the "it's all text" extension for that
01:43:59 <ac> sieni: it makes every textarea grow a little edit button that opens an external editor
01:44:04 <b_jonas> left, so it's like +, so that means it's ((Just 2) <& 2) <& 3
01:44:13 <Taejo> yes
01:44:17 <ac> sieni: saving in the external editor automatically updates the textarea
01:45:09 <Taejo> (Just 1 <& 2) :: Maybe Integer is a more minimal failing case
01:45:14 <sieni> ac: that's not what I want
01:45:19 <b_jonas> well, I think it just can't derive what type those numbers should be
01:45:49 <Taejo> ok
01:45:51 <b_jonas> because there's no fundep, the type of (Just 1 <& 2) is not related to the type of the numbers
01:45:56 <wagle_> how does this work:
01:46:00 <b_jonas> although it can know that 1 and 2 has the same type
01:46:01 <wagle_> > [1,2,3]
01:46:02 <lambdabot>  [1,2,3]
01:46:05 <ac> sieni: it's not pretty, but I think it's useful. Unfortunately it doesn't do anything for those half assed JavaScript RTF editors
01:46:06 <b_jonas> because of the sig of (<&)
01:46:20 <dmwit> Prometheus88: Real frigging late. =/
01:46:36 <b_jonas> wagle_: ah, point
01:46:42 <b_jonas> numbers have a default type
01:46:46 <b_jonas> hmm
01:46:47 <Prometheus88> late here too :(
01:46:53 <wagle_> :t [1,2,3]
01:46:54 <lambdabot> forall t. (Num t) => [t]
01:46:56 <b_jonas> then the problem is now what I said
01:47:13 <wagle_> he does have Ord
01:47:15 <Taejo> b_jonas: I can't use fundeps because of the Bool case
01:47:34 <Taejo> the idea is that you can eventually chain inequalities
01:48:16 <Taejo> like (if min_x <& x <& max_x then "in bounds" else "out of bounds")
01:48:20 <paczesiowa> are you talking about python-like n-ary (==) and (<) ?
01:48:26 <Taejo> yes
01:48:36 <b_jonas> Taejo: I can't really see the types of this one
01:48:46 <Taejo> but obviously one can't use (<), so I use (<&)
01:48:50 <faxathisia> :t printf
01:48:50 <lambdabot> forall r. (PrintfType r) => String -> r
01:49:08 <sieni> jesus christ that fucking vimperator fubared my browser
01:49:26 <ac> @djinn (a,b,c,d) -> ((a,b,c),d)
01:49:27 <lambdabot> f (a, b, c, d) = ((a, b, c), d)
01:49:32 <sieni> now it's showing the stupid tab flap even though I have only single tab
01:49:41 <sieni> and disabling vimperator didn't put that back
01:50:15 <hpaste>  Paczesiowa pasted "1 ==== 0+1 ==== 2-1" at http://hpaste.org/5460
01:50:26 <ac> @pl \(a,b,c,d) -> ((a,b,c),d)
01:50:26 <lambdabot> (line 1, column 6):
01:50:26 <lambdabot> unexpected ","
01:50:26 <lambdabot> expecting letter or digit, operator or ")"
01:50:26 <lambdabot> ambiguous use of a non associative operator
01:50:36 <Prometheus88> I have a simple question, why am I getting a type error here: http://hpaste.org/5455#a2
01:51:20 <Prometheus88> I commented the line where Im getting it
01:52:56 <Prometheus88> nvm I figured out why I missed a param
01:53:01 <wagle_> Prometheus88, whats the type error?
01:53:24 <paczesiowa> Taejo: can you do that without that Just after if?
01:53:42 <Prometheus88> wagle_: I found it actually, i forgot to add ch to setPixel
01:54:00 <Prometheus88> so it was expecting a char, Im not used to the error messages still
01:57:57 <Prometheus88> wagle_: will my base case as indicated here http://hpaste.org/5455#a3, ensure no flooding outside of a list boundary, for example, say [[Char]] is passed in where each [Char] is of length 10
01:58:35 <Prometheus88> wagle_: will the base case try to compare an out of bounds index with my character, and return not true?
01:59:54 <Taejo> paczesiowa: that's my aim, but not yet
02:02:31 <paczesiowa> Taejo: I was working on this thing too, for too long. I even cast all Oleg's spells on that one and I still experience read.show problem (but it's easy with exceptions, but you need -fallow-ugly-code to compile)
02:02:56 <Taejo> paczesiowa: ok
02:04:45 <wagle_> Prometheus88, it looks like       | (x < 0 || y < 0 || x > (getWidth(pic) - 1) || y > (getHeight(pic) - 1))=
02:04:45 <wagle_>         pic       keeps you from running off the edge
02:05:43 <Prometheus88> wagle_: i just tried runnig it and i noticed it didnt work, i was thinking about doing that but theres some compications to consider
02:06:01 <wagle_> :t (<)
02:06:03 <lambdabot> forall a. (Ord a) => a -> a -> Bool
02:06:18 <paczesiowa> Taejo: have you seen this http://okmij.org/ftp/Haskell/solve-read-show.lhs ? if we could get rid of that [[ ]] it would be working
02:07:03 <Taejo> paczesiowa: I haven't seen it
02:07:09 <Taejo> I'll read it now
02:07:47 <dmwit> > 1 + 22 - 1 + 12 - 26 + 4 - 3 - 10 + 4 + 2
02:07:48 <lambdabot>  5
02:10:39 <Prometheus88> is it bad form to have nested conditional guards?
02:10:52 <quicksilver> not necessarily
02:10:57 <quicksilver> but it might look more elegant as one set
02:11:01 <quicksilver> depends what you're doing :)
02:11:06 <hpaste>  Paczesiowa annotated "chaining inequalities" with "(no title)" at http://hpaste.org/5459#a1
02:11:28 <Prometheus88> lol well....Im not allowed to modifiy getPixel to take into account outside of the boundary pixels
02:12:11 <Prometheus88> so what i would like to do instead is to say, if the pixel to the left of current pixel is out of bounds, im only goin gto check the north east or west side only
02:15:14 <Prometheus88> yay or nay?
02:18:07 <siti> what's wrong with: crc32Table :: IArray UArray Word32
02:18:25 <siti>  Class `IArray' used as a type
02:18:26 <siti> :S
02:19:29 <siti> I figured it out thanks ;)
02:23:56 <wagle_> Taejo, seems like fundeps was made for getting the line instance Ord b => Output (Maybe b) b where to trigger for you, but i've just heard discussions about fundeps, havent actually used them..  my idea is to put the (<&) definition into class/instances..  but i gotta go bed now
02:25:05 --- mode: ChanServ set +b *!*@bas3-montreal02-1096681481.dsl.bell.ca
02:28:10 <dmwit> ?palomer
02:28:10 <lambdabot> Brump!
02:28:18 <dmwit> ?palomer
02:28:18 <lambdabot> That's a lie
02:28:20 <dmwit> ?palomer
02:28:20 <lambdabot> That's a lie
02:28:21 <dmwit> ?palomer
02:28:21 <lambdabot> Brump!
02:28:23 <dmwit> ?palomer
02:28:23 <lambdabot> Brump!
02:28:24 <dmwit> ?palomer
02:28:25 <lambdabot> (_|_)
02:28:26 <dmwit> ?palomer
02:28:26 <lambdabot> Hrmph
02:29:13 <ski> @ghc
02:29:13 <lambdabot> ghc says: even with cunning newtype deriving the newtype is recursive
02:32:13 <dmwit> ?ghc
02:32:14 <lambdabot> ghc says: Inferred type is less polymorphic than expected
02:32:18 <dmwit> ?ghc
02:32:18 <lambdabot> ghc says: You need -fglasgow-exts to derive an instance for this class
02:32:23 <dmwit> ?ghc
02:32:23 <lambdabot> ghc says: Its main purpose is to encapsulate the Horrible State Hack
02:32:28 <dmwit> indeed
02:32:29 <sizur> i'm reading a wiki, it says that there are two versions of HaskellDB
02:32:31 <wagle_> what did palomer do?
02:32:40 <sizur> which one should one use with ghc?
02:32:47 <dmwit> wagle_: (s)he was really annoying, a long time ago
02:34:13 <dmwit> ?palomer
02:34:13 <lambdabot> I think vim is good for the rubbish bin
02:34:16 <dmwit> ?palomer
02:34:16 <lambdabot> I think you're all nuts
02:34:20 <dmwit> ?palomer
02:34:20 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
02:34:23 <dmwit> ?palomer
02:34:24 <lambdabot> Pfft
02:34:27 <dmwit> ?palomer
02:34:27 <lambdabot> Brump!
02:34:49 <wagle_> oic
02:35:24 <dmwit> I wonder if bans have a half-life or something.
02:36:27 <johnnowak> @google #haskell troll freenode
02:36:28 <lambdabot> http://ircarchive.info/haskell/2007/4/9/37.html
02:36:28 <lambdabot> Title: haskell what did palomer do? dunno by 'sagan.freenode.net' that's rather odd cau ...
02:36:30 <hpaste>  siti pasted "CRC32 using lazy bytestrings :)" at http://hpaste.org/5461
02:37:10 <johnnowak> bizarre
02:46:02 <dmwit> ?protontorpedo
02:46:02 <lambdabot> why did someone create haskell?
02:50:23 <slarba_> miranda was too commercial? :)
02:50:52 <johnnowak> ?protontorpedo
02:50:52 <lambdabot> why did someone create haskell?
02:50:56 <johnnowak> bah
02:51:01 <johnnowak> ?protontorpedo
02:51:01 <lambdabot> is haskell able to outdo perl or python for web?
02:51:16 <sizur> did anybody here use haskellDB?
02:52:19 <sizur> @users
02:52:19 <lambdabot> Maximum users seen in #haskell: 471, currently: 408 (86.6%), active: 9 (2.2%)
02:58:06 <asdf> hi... when i want to write a function with the signature f :: a -> b how can i tell the function to return a+1? so e.g. f 1 returns 2
02:58:52 <b_jonas> asdf: how would that work for any a -> b type?
03:00:19 <b_jonas> I mean, a might not even be a numeric type
03:00:42 <asdf> yea but lets assume its numeric
03:01:09 <EvilTerran> asdf, i think you need a tutorial. something more structured than a load of random IRCers trying to help you.
03:01:35 <b_jonas> if you assume it's numeric, than that's not the right signature
03:01:55 <b_jonas> the sig 'f :: a -> b' means that f is a function that can work for _any_ type a and _any_ type b
03:02:18 <asdf> so it should also work for numeric numbers?
03:02:49 * EvilTerran sighs
03:03:03 <b_jonas> asdf: and probably it should be even more restricted than that
03:03:37 <asdf> actually i got a data structure like this:
03:03:40 <asdf> data Tree a = Empty | Node a (Tree a) (Tree a) deriving Show
03:03:42 <b_jonas> like, if the input is an arbitary complex double, and the output is an integer, then I can't see how x+1 would make sense
03:04:08 <asdf> and i wrote a map function with a function and a tree as paramater, i dont know if its work, but to test it i wanted to write a random function f
03:04:49 <b_jonas> well, then pick a numeric type you like, e.g. Integer
03:04:56 <b_jonas> and then test it on a Tree Integer
03:05:04 <b_jonas> with an Integer -> Integer typed function
03:07:08 <asdf> mmh uhm
03:07:38 <asdf> thanks so far, i have to test it out with ghc, the error messages from hugs doesnt really help
03:07:54 * desegnis seconds what EvilTerran suggests to asdf
03:08:12 <b_jonas> here's an example
03:08:21 <b_jonas> > let { f :: Integer -> Integer; f x = 1 + x; } in map f ([3, 1, 4, 1, 5, 9] :: [Integer])
03:08:29 <lambdabot>  [4,2,5,2,6,10]
03:08:41 <b_jonas> only you want to do that with trees instead of lists
03:09:06 <asdf> mmh yay but it makes everything more complicated :D
03:09:17 <asdf> im a bit confused with this different kind of types and so on
03:09:19 <quicksilver> asdf: sounds like you just don't want to give f a signature.
03:09:26 <quicksilver> asdf: because you were giving it the wrong one.
03:09:35 <quicksilver> just don't give it a signature and GHC will infer the right one.
03:09:42 <quicksilver> probably Num a => a -> a
03:09:45 <quicksilver> in this case
03:09:47 <quicksilver> :t (+1)
03:09:47 <resiak> GHC or hugs, that is.
03:09:48 <lambdabot> forall a. (Num a) => a -> a
03:10:18 <asdf> yea but i thought i have to give f the signature a -> b
03:10:29 <quicksilver> and you were wrong :)
03:10:33 <asdf> because the map signature looks like this mapTree :: (a -> b) -> Tree a -> Tree b
03:10:37 <quicksilver> yup
03:10:45 <quicksilver> but you can use a more specific type if you want
03:10:48 <asdf> so f have to be from the type a -> b?!
03:10:52 <asdf> okay
03:10:56 <quicksilver> f has to match a -> b
03:11:02 <quicksilver> but it's allowed to be more specific.
03:11:09 <quicksilver> Int -> Int is one example of a -> b
03:11:13 <quicksilver> with a = Int and b = Int
03:11:29 <b_jonas> by match, you mean unify?
03:11:49 <quicksilver> I mean 'unify with'
03:11:53 <b_jonas> yeah
03:12:28 <asdf> okay. well i have to wait until ghc is ready. i actually can now run the thing but dont know whats messy
03:18:53 <quicksilver> woo, our network diagram is a bit of a mess
03:18:59 <quicksilver> maybe the decay needs to be a bit fiercer
03:23:40 <nominolo> hm, maybe ghc isn't as unicode friendly as i thought
03:23:53 <nominolo> > "î»š"
03:23:54 <lambdabot>      lexical error in string/character literal at character '\61146'
03:24:04 <nominolo> that's the same message i get
03:24:51 <nominolo> > "Î»"
03:24:53 <lambdabot>  "\955"
03:25:10 <nominolo> > maxBound :: Char
03:25:10 <lambdabot>  '\1114111'
03:25:33 <nominolo> > chr 61146
03:25:33 <lambdabot>  '\61146'
03:25:36 <paczesiowa> > let Î» = 1337 in Î» + Î»
03:25:36 <lambdabot>  Illegal character ''\187''
03:25:36 <lambdabot>  at "»" (column 6)
03:25:57 <paczesiowa> it works in ghci
03:26:15 <nominolo> same here
03:26:30 <paczesiowa> so where do file a bug?
03:27:08 <nominolo> but it only works up to a certain number of unicode characters
03:27:12 <paczesiowa> @seen dons
03:27:12 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 3h 13m 32s ago.
03:27:26 <dmwit> The situation is improving as GHC version increases.
03:27:35 <ac> so, is there a: isNothing a = case a of Nothing -> True; _ -> False; -- somewhere in the stdlibs?
03:27:48 <dmwit> ?hoogle isNothing
03:27:48 <lambdabot> Data.Maybe.isNothing :: Maybe a -> Bool
03:27:49 <nominolo> Data.Maybe
03:27:51 <dmwit> ;-)
03:27:56 <ac> hah
03:28:06 <dmwit> There's also isJust, of course.
03:28:32 <desegnis> Speaking of dons and Nothing:
03:28:52 <desegnis> darcs-graph ~/src/somedarcs
03:28:54 <desegnis> darcs-graph: Maybe.fromJust: Nothing
03:30:19 <ac> wee, indexed color images work
03:30:39 <ac> (on the first try)
03:31:20 <ac> well, second try I guess. I forgot to add a put for it
03:32:00 <hpaste>  Paczesiowa annotated "1 ==== 0+1 ==== 2-1" with "(no title)" at http://hpaste.org/5460#a1
03:32:01 <ac> I think I'm starting to get attached to statically typed languages
03:32:18 <paczesiowa> any typemagician could look at that?
03:33:30 <b_jonas> paczesiowa: wow, that has unsafePerformIO
03:33:52 <paczesiowa> what's so "wow" about that?
03:34:19 <resiak> the wow! starts now!
03:34:45 <b_jonas> I woudln't have thought chained comparision operators need something like that
03:35:21 <paczesiowa> do you have any other idea?
03:35:37 <paczesiowa> without any syntactic salt
03:35:38 <b_jonas> I'm only trying to understand it now
03:36:46 <paczesiowa> evaluating a ==== b gives a if they are equal, otherwise exception is thrown
03:37:53 <paczesiowa> to solve it without unsafe* we need some clever type for this (like in that followup question)
03:50:22 <paczesiowa> please say something, don't make me feel stupid:P
03:53:36 <paolino> does continuations help an undo functions in restoring a state or that operation must be done by hand , by bringing the state in scope before callCC ?
03:54:22 <quicksilver> continuatiosn can help
03:56:27 <paolino> quicksilver: StateT s ContT r m is the monad to use ?
03:57:04 <quicksilver> yes, that's right.
03:57:15 <quicksilver> StateT must be 'outside' of the ContT
03:57:20 <quicksilver> if you want to be able to rollback the state
03:57:39 <paolino> still I don't see how to roll back the state
03:58:24 <quicksilver> well the continuations you 'save' with call/cc
03:58:31 <quicksilver> will embed the state at that point
03:59:53 <paolino> get >>=\x -> callCC gocrazy >>= \r -> (case r of Go -> return Go ; Rollback -> put x >> return Go)
04:00:50 <paolino> if gocrazy change the state, it will not rollback on his own
04:02:32 <quicksilver> why would anything rollback on its own?
04:02:42 <quicksilver> :t callCC
04:02:42 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
04:02:58 <quicksilver> gocrazy gets passed a continuation
04:03:04 <quicksilver> that continuation embeds the current state
04:03:12 <quicksilver> it's up to gocrazy if it uses it or not
04:10:25 <paolino> mmhh,is it possible to  get back to the previous context/state without remembering it explicitly ?
04:10:26 <paolino> I suppose I can pass a continuation with a put oldstate inside that gocraz can use to rollback
04:10:36 <paolino> @paste
04:10:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:13:28 <hpaste>  paolino pasted "undo with ContT" at http://hpaste.org/5463
04:14:10 <LeCamarade> Salut, monde.
04:14:10 <lambdabot> LeCamarade: You have 1 new message. '/msg lambdabot @messages' to read it.
04:15:22 <LeCamarade> Anybody here used uniqueness types?
04:15:32 <LeCamarade> As implemented in Clean?
04:16:11 <paolino> quicksilver: is that the way to go ?
04:17:28 <paolino> I'm just not sure if I'm using continuations help
04:18:45 <quicksilver> paolino: No. You need to remember explicitly. That's what callCC does.
04:19:01 <quicksilver> paolino: callCC = call with current continuation = explicitl remember current state
04:19:08 <quicksilver> paolino: you can do that without Cont, just by using get.
04:19:15 <quicksilver> paolino: which may be easier, depends what you're trying to do.
04:19:28 <paolino> the undo for an editor
04:21:43 <dcoutts> @tell lekro that problem you had building gtk can be solved by: make clean; ./configure --disable-split-objs; make
04:21:43 <lambdabot> Consider it noted.
04:22:01 <dcoutts> nominolo_: pong
04:22:01 <lambdabot> dcoutts: You have 5 new messages. '/msg lambdabot @messages' to read them.
04:22:17 <nominolo_> dcoutts: hi
04:22:36 <dcoutts> nominolo_: I'm not clear about that problem compiling yi
04:23:26 <nominolo_> dcoutts: the user has regex-0.73 and regex-0.91 or so
04:23:46 <dcoutts> nominolo_: but I thought yi-0.3 specifically depended on 0.71.0.1 etc
04:23:53 <nominolo_> dcoutts: now, bytestring was compiled against regex-0.93 and contains instances for RegexLike
04:24:15 <nominolo_> dcoutts: yes, now the user also installs regex-0.73 for yi
04:24:23 <dcoutts> nominolo_: or rather regex-0.93 was compiled against bytestring-0.9.0.??
04:24:41 <nominolo_> dcoutts: however, now there is no instance in bytestring for regex-0.71:RegexLike
04:24:57 <dcoutts> other way round
04:24:57 <nominolo_> dcoutts: no, i think it must be the other way round
04:25:15 <dcoutts> the bytestring package does not have any instances for regex anything
04:25:16 <nominolo_> yep
04:25:16 <nominolo_> so, it's the same problem
04:25:31 <nominolo_> no? hm, let me check
04:25:35 <quicksilver> paolino: I would not use continuations for editor undo, I don't think.
04:25:50 <quicksilver> paolino: I would just save old states on an undo stack
04:26:22 <nominolo_> dcoutts: hm. right. it's the other way around
04:26:26 <dcoutts> nominolo_: in that thread, the user only has the right versions of regex installed and only one copy of bytestring
04:26:41 <nominolo_> :/
04:27:34 <nominolo_> dcoutts: this is weird then
04:28:07 <dcoutts> nominolo_: now, I got that bug when building yi against regex-* 0.93, but that is as expected
04:28:26 <nominolo_> why?
04:28:30 <paolino> quicksilver the use of continuations is to set more re-entry points and jump to them where ever you are ?
04:28:37 <dcoutts> nominolo_: presumably because it does not define that instance
04:29:00 <nominolo_> so, you think the dependencies are ill-defined in yi.cabal?
04:29:24 <dcoutts> nominolo_: no, I had modified  it to let me build with the different regex-*.
04:30:06 <nominolo_> ok, but that shouldn't have happened in the original case
04:30:35 <dcoutts> nominolo_: right
04:32:14 <paolino> quicksilver, ok, I will not use them
04:33:37 <nominolo_> dcoutts: does cabal configure with -v2 print all the packages it links against?
04:34:22 <dcoutts> nominolo_: only -v is necessary
04:36:28 <nominolo_> dcoutts: oh, i think it is an incorrect yi.cabal in the release version
04:37:16 <quicksilver> paolino: continuations are a bit like a typesafe goto ;)
04:37:31 <quicksilver> rather, I should say, callCC is
04:37:40 <quicksilver> continuations in a more general sense are just a useful programming technique.
04:37:55 <b_jonas> useful but too general
04:37:58 <dcoutts> nominolo_: oh?
04:38:10 <b_jonas> lucky there are good libraries for its special cases
04:38:26 <nominolo_> dcoutts: well, it's not in the current version on hackage
04:38:42 <nominolo_> dcoutts: maybe jyp re-uploaded a fixed version
04:39:51 <dcoutts> nominolo_: what fix?
04:39:59 <nominolo_> dcoutts: to the yi.cabal
04:40:12 <dcoutts> nominolo_: yes, but what was fixed/changed?
04:40:41 <nominolo_> the build-depends: regex-blah ==0.71.bla
04:40:58 <nominolo_> I presume
04:41:12 <nominolo_> or maybe he had an outdated repo version.  who knows
04:41:13 <dcoutts> nominolo_: should not have made any difference to that example you gave since they were the only versions available
04:41:25 <dcoutts> nominolo_: note that cabal-Version:  == 1.2.3.0 is far too restrictive
04:41:39 <dcoutts> the exact api is only 1.2.3
04:41:40 <nominolo_> yes, but it's the ghc-6.8.2 default
04:42:05 <nominolo_> and we only support that version of ghc anyways
04:42:07 <dcoutts> it means no bug fixes like 1.2.3.1
04:42:28 <resiak> the yi package on hackage depends on == 0.7[12] versions of regex-*
04:43:22 <nominolo_> no, only ==0.72.0.1
04:43:44 <nominolo_> oh, you mean for the other variants, yep
04:44:01 <nominolo_> ok, let's leave it alone.  it's not related to #220
04:44:21 * dcoutts builds yi
04:44:31 <nominolo_> other question: is the Cairo Render monad in MonadIO ?
04:44:47 <dcoutts> nominolo_: I think so
04:45:02 <nominolo_> there's no documentation for Render
04:45:18 <nominolo_> at least clicking on it doesn't work
04:45:29 <b_jonas> Will any of you haskell guys going to challenge24?
04:46:01 <LeCamarade> Should check out yi. But will I like it, being a militant vi user? Need a lot of re-conditioning?
04:46:05 <b_jonas> (The qualifier round is this month.)
04:46:50 <nominolo_> dcoutts: oh, and it would be cool if haddock had a permuted symbol index.  for example like: http://www.lisp.org/HyperSpec/FrontMatter/Permuted-F.html
04:46:51 <lambdabot> Title: CLHS: Permuted Symbol Index (F)
04:48:05 <dcoutts> nominolo_: seems like a haddock bug, it's documented in a hidden module, but it is exported so the docs should be carried over
04:48:46 <nominolo_> @seen waern
04:48:46 <lambdabot> I saw waern leaving #gentoo-haskell, #haskell and #ghc 17h 18m 11s ago, and .
04:48:49 <Saizan> LeCamarade: it feels more emacs-like, that's probably customizable tough
04:49:25 <nominolo_> LeCamarade: it has a Vim-mode
04:49:30 <dcoutts> nominolo_: oh, hmm, actually it's excluded since it uses features that haddock cannot parse
04:49:42 <dcoutts> nominolo_: like deriving multi-parameter type classes
04:49:44 <nominolo_> LeCamarade: but lots of advanced features are missing
04:49:54 <nominolo_> dcoutts: oh, i see
04:50:01 <nominolo_> dcoutts: so, is it in MonadIO ?
04:50:03 <nominolo_> :)
04:50:17 <dcoutts> nominolo_: deriving (Functor, Monad, MonadIO, MonadReader Cairo)
04:50:24 <nominolo_> great
04:50:53 <nominolo_> dcoutts: haddock 2.0 should be able to parse it, though
04:51:28 <dcoutts> nominolo_: right, but I've not tried that with gtk2hs yet, it'd require build system changes since the flags are different
04:51:36 <nominolo_> oh, i see
04:53:12 <nominolo_> our social network graph is really starting to get rather dense
04:53:12 <dcoutts> nominolo_: hmm, so there's no way at the moment to say that yi depends on either coca, gtk or vty, but it must be one of them
04:53:26 <nominolo_> dcoutts: yep, the error message sucks
04:53:42 <quicksilver> lispy: did you turn off the edge-aging.
04:53:44 <dcoutts> nominolo_: btw, how are people expected to build yi with vty when vty does not build with ghc-6.8.2? :-)
04:53:56 * dcoutts fixes vty and continues
04:54:00 <quicksilver> nominolo_: I think the edge-aging has been removed
04:55:14 <LeCamarade> Who mentioned the permuted index?
04:55:26 <LeCamarade> Looks good. Need a link.
04:55:38 <nominolo> dcoutts: no, it just needs a minor .cabal file fix
04:55:42 <dcoutts> nominolo: we should make it easier to do minor bug fixes to maintain packages
04:55:46 <dcoutts> for things like this
04:55:49 <nominolo> yep
04:56:16 <LeCamarade> nominolo: You'd vanished. :o) But if it has the basic vi features, I'm fine. I've ever endured Notepad, you know.
04:56:19 <LeCamarade> :o)
04:56:48 <nominolo> LeCamarade: i think it's a bit buggy still.  but hackable
04:57:21 * nominolo 's wireless is crappy
04:57:46 * LeCamarade is scared of Challenge24.
04:58:18 <LeCamarade> But 5,000 Euros ... :o(
04:58:18 <nominolo> LeCamarade: i mentioned the permuted index
04:59:24 <nominolo> it can be very useful if you're not completely sure what you are looking for
04:59:42 <LeCamarade> nominolo: Okay ... I need to study more on the whole permutation thing. Link? Paper?
04:59:49 * LeCamarade goes to Wikipedia,
05:00:40 <nominolo> it's just:  if you have a symbol fooBarBaz then you put it into the index for f and twice for b, since it contains the words 'foo" "bar" and "baz"
05:01:07 <nominolo> so if you just know one word, then you'll find it by looking it up in the permuted symbol index
05:01:13 <LeCamarade> So, it is up to you where the words are broken?
05:01:25 <quicksilver> BreakAtCamelCaseBoundariesISuppose
05:01:39 <nominolo> yep
05:01:41 <nominolo> "A permuted index includes each n-word entry up to n times, at points corresponding to the use of each word in the entry as the sort key. For example, a symbol FOO-BAR would occur twice, once under FOO and BAR. This allows you to use any word in the symbol's name to search for that symbol."
05:01:45 <LeCamarade> Because it could also be map (:[]) "foobarbaz" ...
05:01:52 <nominolo> from here: http://www.lisp.org/HyperSpec/FrontMatter/Symbol-Index.html
05:01:53 <lambdabot> Title: CLHS: Symbol Index
05:01:53 <pejo> dcoutts, something similar to a non-maintainer-upload?
05:02:01 <LeCamarade> if-lisp-then-break-at-dash
05:02:23 <dcoutts> pejo: exactly. Though we can already do that, it's just that currently we tend not to.
05:02:25 <nominolo> you got it
05:02:57 <nominolo> if-lisp-then-brake-at-dash
05:03:05 * LeCamarade watches some language that shall remain nameless come round to `inventing' the ML family's terseness ... fn x => x, et cetera.
05:03:21 <pejo> dcoutts, hm. Yeah. The problem seems to mainly be social.
05:03:51 <nominolo> LeCamarade: does the language's name remind people of coffee?
05:03:57 <dcoutts> pejo: right, you don't want to mess with upstream's version numbers, and you probably do not have access to the upstream darcs repo
05:04:34 <Taejo> LeCamarade: the nameless language-designer is, I imagine, reluctant to get rid of Lots of Irritating Superfluous Parentheses
05:04:35 <dmwit> ?localtime dmwit
05:04:36 <lambdabot> Local time for dmwit is Mon Feb  4 05:04:39
05:04:37 <dcoutts> pejo: it makes me wonder if we want an explicit patching thing, so it's clear it's not an upstream change
05:04:44 <dmwit> Urgh, bedtime.
05:05:16 <dcoutts> pejo: for example, a distro like gentoo/debian has some QA, we make sure the packages build with a version of ghc. We do that in many cases by applying trivial patches.
05:05:18 <Saizan> dcoutts: do we need to bump the version for a cabal fix?
05:05:29 <dcoutts> Saizan: good question
05:05:57 <dcoutts> Saizan: in distro packages we typically do not, or we use foo-1.0-r1  -r2, etc
05:05:58 <Saizan> i guess it's harder to notice that something has changed if you keep the same version, though
05:06:09 <nominolo> dcoutts: or hackage associates patches for various versions
05:06:23 <nominolo> dcoutts: that way you just add a patch instead of modifying the package
05:06:38 <LeCamarade> The language name reminds people of a man who saved all the animals in the world by putting them in an ____.
05:06:43 <nominolo> Saizan: yos, that's a no-no
05:06:44 <dcoutts> Saizan: right, that's what the additional level of version number is for, it's explicitly not part of the upstream number, it's just a patch level
05:06:46 <LeCamarade> robyonrails: Hi.
05:06:46 <pejo> dcoutts, hm. I was thinking along the same lines myself. Perhaps with some veto-mechanism available to the upstream maintainer, so if some wacko breaks stuff they can't give the library a bad reputation?
05:07:00 <robyonrails> hi LeCamarade
05:07:09 <dcoutts> pejo: that's what distro maintainers do for distros, yes.
05:07:15 <LeCamarade> robyonrails: You just entered many channels I'm in at the nsame time, and I thought you were spamming.
05:07:33 <pejo> Saizan, you can't depend on the right version if you make changes without changing the version.
05:07:35 <LeCamarade> :o0
05:07:39 <robyonrails> ah :)
05:08:31 <Saizan> pejo: yeah, but it's not really a change in the modules, just in the build system, however i see how this is still dangerous
05:08:35 * LeCamarade moved Haskell from `experimental/enlightening' to `first resort for all programming tasks'. :o) Give a hand.
05:08:39 <dcoutts> pejo: so at the moment with hackage we totally lack any of the distro management tools, like the ability to patch things to keep them working or the ability to not include packages that fail to work, or to mark lower numbered packages as preferred etc etc
05:09:29 <dcoutts> pejo: now, I'm not sure that all these would be totally appropriate, but it might be interesting to create hackage subsets that are derivatives with different QA standards
05:10:22 <pejo> Saizan, if a user has version x.y.z installed, and the thing he is trying to build depends on that version, he will get upset if it doesn't build. It would be easier if it depended on z-p1 immediately and refused to build instead.
05:11:55 <Saizan> pejo: if x.y.z is installed we no longer need cabal fixes, where "cabal fixes" is restricted to "make the thing build", however if one change exposed modules or other it's another story
05:21:09 <ddvlad> *sigh* I thought I understood monads, but it really seems I don't.
05:21:43 <ddvlad> I read a file and intend to parse it line by line. The result should (in my view) be Writer [SomeStruc] (). How would I go about doing this?
05:22:24 <Lemmih> ddvlad: What have you tried?
05:22:56 <norfair> if it reads from a file, it should be in IO.
05:22:56 <dcoutts> ddvlad: do you know why you're trying to use a monad rather than just a recursive function :: [String] -> [SomeStruc] ?
05:23:37 <ddvlad> Lemmih: well, my first thought was text <- readFile file, then mapM_ parseLine (lines text), but it's quite wrong to put those in a do block, right?
05:24:09 <ddvlad> dcoutts: quite frankly, no. It's probably easier to use what you suggested.
05:24:24 <ddvlad> I apparently have not spent enough time at the proverbial drawing board.
05:26:19 <Saizan> ddvlad: what type parseLine is supposed to have there? it will typecheck if parseLine :: String -> IO Something
05:26:47 <ddvlad> as I had it, parseLine :: String - > Writer [Event] ()
05:27:51 <dcoutts> ddvlad: are you parsing every line in the file? can you just use ordinary lazy IO and the lines function?
05:28:27 <ddvlad> dcoutts: yes, I am parsing every line. as for the second question, i'm not really sure
05:29:26 <dcoutts> ddvlad: do content <- readFile f; return (parseLines (lines content))
05:30:15 <dcoutts> ddvlad: or if your parsing is really simple, and each line is parsed separately then you can just map parseLine over the lines
05:30:40 <ddvlad> yes, the parsing is simple, map would work
05:30:52 <ddvlad> and the type would be IO [SomeStruc], right?
05:31:20 <dcoutts> ddvlad: yes, if parseLine :: String -> SomeStruc
05:31:37 <dcoutts> readFile f >>= return . map parseLine . lines
05:32:01 * dcoutts prefers: return . map parseLine . lines =<< readFile f
05:32:34 <ddvlad> hmm, yes, the latter seems a bit easier to read and more logical
05:32:40 <ddvlad> i'll try that. Thank you for your suggestion
05:32:40 <shachaf> Not (map parseLine . lines <$> readFile f)?
05:32:45 <norfair> fmap (fmap parseLine . lines) $ readFile f
05:33:01 <dcoutts> those are nice too :-)
05:33:43 <norfair> fmap (fmap (fmap (fmap parseLine) lines)) readFile f
05:34:41 <LeCamarade> norfair: You're also in love with Functor?
05:34:45 <LeCamarade> :o)
05:34:46 <shachaf> norfair: Isn't that one too many?
05:34:49 <norfair> :t fmap (fmap (fmap (fmap ?parseLine) lines)) readFile ?f
05:34:52 <lambdabot> forall b. (?parseLine::String -> b, ?f::FilePath) => IO [b]
05:35:01 <shachaf> Hmm, maybe not.
05:35:10 <norfair> fmapwned.
05:35:15 <resiak> that's so much clearer than the alternatives! :)
05:36:09 <shachaf> fmap++
05:37:10 <EvilTerran> ?karma fmap
05:37:10 <lambdabot> fmap has a karma of 1
05:37:15 <EvilTerran> ?karma+ fmap
05:37:15 <lambdabot> fmap's karma raised to 2.
05:37:18 <EvilTerran> I like it too :)
05:37:43 <opqdonut> :D
05:39:03 <EvilTerran> :t fmap (fmap (fmap (fmap ?parseLine) lines)) readFile ?f
05:39:03 <lambdabot> forall b. (?parseLine::String -> b, ?f::FilePath) => IO [b]
05:39:11 <EvilTerran> er
05:39:11 <EvilTerran> ?type fmap fmap fmap ((fmap . fmap) ?parseLine lines) readFile ?f
05:39:12 <lambdabot> forall b. (?parseLine::String -> b, ?f::FilePath) => IO [b]
05:39:20 * EvilTerran keeps tweaking
05:40:01 <norfair> :t fmap fmap fmap (fmap fmap fmap ?parseLine lines) readFile ?f
05:40:02 <lambdabot> forall b. (?parseLine::String -> b, ?f::FilePath) => IO [b]
05:40:32 <EvilTerran> ?type (fmap fmap fmap `fmap` fmap fmap fmap ?parseLine) lines readFile ?f
05:40:33 <lambdabot> forall b. (?parseLine::String -> b, ?f::FilePath) => IO [b]
05:40:46 <zooko> Greetings, people of #haskell.
05:40:50 <EvilTerran> fmap, zooko
05:41:26 <zooko> In Python world, there is a tradition of making Python bindings for C/C++ libraries, and calling the resulting Python package "PyFoo", where Foo is the name of the C/C++ library.
05:41:32 <norfair> what is the sound of one hand fmapping?
05:41:38 <shachaf> <$>++
05:41:42 <LeCamarade> EvilTerran: a -> Zooko a
05:41:44 <zooko> If I were making a Haskell binding for a C++ library, what would I call it?
05:42:06 <dcoutts> zooko: often just the same name, it's a different namespace so it's ok
05:42:15 <zooko> Thanks.
05:42:23 <ibid> zooko: hfoo or hafoo are also used sometimes
05:42:37 <ibid> in debian, we'd package it as libghc-foo-dev etc :)
05:42:46 <LeCamarade> Hs usually features, somewhere.
05:42:49 <dcoutts> in gentoo it's dev-haskell/foo
05:42:50 <zooko> Actually I think that is a mistake, dcoutts -- Haskell packages are going to start having to share namespaces with C++ libraries since Haskell is entering the "mainstream".  :-)
05:43:02 <EvilTerran> ?type fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap ?parseLine) lines readFile ?f
05:43:03 <lambdabot> forall b. (?parseLine::String -> b, ?f::FilePath) => IO [b]
05:43:08 <EvilTerran> muhahaha
05:43:22 * EvilTerran prepares to apply his fmap transformation yet again
05:43:22 <dcoutts> zooko: that's for the distros to sort out and as ibid and I noted, they already have systems to do that.
05:43:44 <ibid> dcoutts: source package names might become problematic for debian, but we'd cope
05:44:11 <dcoutts> ibid: what do you do for the zlib package for example?
05:44:22 <zooko> dcoutts: yes, distros can manage mappings from their namespaces to others, but I think it is worth spending, say a couple of chars on each package name for packages that are widely used.
05:44:46 <kaol> zlib's not in Debian... That reminds me that I've had an ITP on it for ages.
05:44:58 <kaol> but it would be most likely be named as haskell-zlib
05:45:04 <dcoutts> zooko: I don't think it's worth it since it cannot be done consistently, so distros have to do it anyway, so all you get is more inconsistency if you use additional prefixes
05:45:08 <zooko> Python has a long, strong, successful history of leveraging C/C++ code for Python programmer use, and they try to avoid name collisions in order to ease that issue.
05:45:32 <zooko> dcoutts: you are right -- Debian takes things like "pyjudy" and renames it "python-judy" anyway.
05:45:38 <zooko> But the whole world is not Linux distros.
05:46:00 <shachaf> EvilTerran: Now why doesn't @pl simplify things like that?
05:46:08 <Saizan> maybe pyjudy is more googlable than python judy?
05:46:12 <dcoutts> zooko: where else do they live in the same namespace?
05:46:14 <Taejo> @src minimum
05:46:14 <lambdabot> minimum [] = undefined
05:46:14 <lambdabot> minimum xs = foldl1 min xs
05:46:27 <zooko> dcoutts: Saizan just gave an interesting example.  google is a giant mushed together namespace.
05:46:28 <Taejo> @src foldl1
05:46:28 <lambdabot> foldl1 f (x:xs) = foldl f x xs
05:46:28 <lambdabot> foldl1 _ []     = undefined
05:46:54 <ibid> dcoutts: the c library source is called zlib :)
05:47:16 <dcoutts> ibid: right, so the haskell package would be? haskell-zlib?
05:47:22 <EvilTerran> shachaf, just wait 'til you see this monstrosity i'm cooking up :D
05:47:26 <dcoutts> zooko: true, but since it's not a strict namespace you can google for "haskell foo"
05:47:37 <ibid> dcoutts: something like that, probably. not packaged, though, i believe
05:47:38 <zooko> dcoutts: yep.
05:47:52 <dcoutts> ibid: in gentoo it's sys-libs/zlib and dev-haskell/zlib
05:48:12 <zooko> dcoutts: other spaces where such names live together include human usage: spoken conversation, e-mail lists, etc.
05:48:35 <dcoutts> yes, though context seems to be enough
05:48:41 <zooko> As long as Haskell is relatively insular, everyone who discusses Haskell can figure out from context whether you mean the C++ Foo or the Haskell bindings/adaptation Foo.
05:48:52 * EvilTerran notes he has no proof of termination of this algorithm
05:48:55 <zooko> But I think Haskell is becoming more mainstream, so such context will become less clear over time.
05:49:32 <zooko> dcoutts: you might be right. My intuition is that trying to maintain a separate namespace for everything Haskell-related is a bit of a strategic mistake, but that's just my intuition.
05:49:43 <EvilTerran> ?type fmap fmap fmap fmap (fmap fmap) fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap fmap) fmap fmap fmap (fmap fmap fmap) ?parseLine lines readFile ?f
05:49:44 <lambdabot> forall b. (?parseLine::String -> b, ?f::FilePath) => IO [b]
05:49:48 <zooko> I originally was just asking for what the current practice is since I'm experimenting with making bindings to something.  :=)
05:49:55 <opqdonut> EvilTerran: :D:D
05:50:07 <EvilTerran> I'm not sure, but i think you should be able to eventually eliminate all brackets, with enough leading fmaps
05:50:30 <dcoutts> zooko: my main point is that all distros have to manage the namespace anyway, eg haskell- or hs- so adding an extra one is silly: haskell-hs-plugins
05:51:19 <zooko> Your point is valid, but again, there are vast, flourishing ecosystems of programmers and users who do not use distros.
05:51:35 <assss> mmh i dont get it: this is my little map function for binary trees with the output of ghci, what is wrong there? http://hpaste.org/5464
05:51:39 <earthy> damn, that's ugly, evilterran
05:52:03 <zooko> If Haskell becomes more and more successful and mainstream, then it will be used more in distros, but it will be used even *more* outside of distros, so the fraction of it that is within distros will shrink over time.
05:52:33 <ibid> assss: missing Node in the expression
05:53:08 <dcoutts> EvilTerran: I don't think fmap is a complete set of combinators though, like SKI
05:53:09 <assss> oh
05:53:20 <assss> that was dumb, thanks :D
05:53:37 <dcoutts> EvilTerran: even though you have the advantage of it doing different things at different types
05:53:45 <EvilTerran> :( \b can't cope any more
05:54:10 <ibid> assss: rule of thumb: when ghc(i) complains about a missing Num instance, you're probably putting numeric literals somewhere they don't belong :)
05:54:42 <EvilTerran> ?type fmap fmap (fmap fmap fmap) fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap fmap) fmap fmap fmap (fmap fmap fmap) ?parseLine lines readFile ?f
05:54:48 <lambdabot> forall b. (?parseLine::String -> b, ?f::FilePath) => IO [b]
05:55:04 <EvilTerran> the next step starts giving me "thread killed" instead of an answer :(
05:55:45 <EvilTerran> exponential-complexity typechecking FTL
05:56:44 <assss> ibid, okay i will keep that in mind, for the moment the errors from ghci arent much more understandable than hugs output
05:58:40 <ibid> assss: the problem is that haskell is rather generic so simple errors could be actually subtle errors and ghc can't tell which :)
05:59:39 <assss> mmh i ask myself who that turns out in really big programs ;)
05:59:48 <assss> who=how
05:59:53 <Syzygy-> EvilTerran: o.O
06:03:05 <ibid> assss: explicit type signatures help a lot
06:07:23 <funktio> @pl \n (x,y) -> (n * x, n * y)
06:07:24 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . (*)) (*)
06:07:53 <dolio> \n -> join (***) (*n)
06:08:16 <dolio> Or 'join (***) . (*)' if you're crazy.
06:08:21 <funktio> dolio: I just wanted to see how crazy it goes :)
06:08:39 <dolio> Yeah, it doesn't use (***) often, if at all.
06:09:01 <dolio> @pl \f g (a,b) -> (f a, g b)
06:09:01 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
06:09:22 <dolio> Probably at all.
06:09:29 <LeCamarade> Really pointless. Wow.
06:09:43 <dolio> Although it fails to use curry and uncurry where it's obvious, too.
06:09:52 <LeCamarade> Who wrote that pl plugin? Need to make an arrest.
06:09:54 <dolio> @pl \f (a, b) -> f a b
06:09:54 <lambdabot> (`ap` snd) . (. fst)
06:10:22 <dolio> @pl \x y -> [x,y]
06:10:22 <lambdabot> (. return) . (:)
06:11:07 <LeCamarade> > ((. return) . (:)) 3 4
06:11:08 <lambdabot>  [3,4]
06:11:18 <LeCamarade> ,,|,,
06:12:45 <funktio> > ((.(:[])).(:)) 3 4
06:12:45 <lambdabot>  [3,4]
06:24:29 <zooko> Does anybody know why the "hnop" project has both a "nop" and an "hnop" directory?
06:25:08 <zooko> It kind of looks like someone might have forgotten to remove the "nop" one when they decided to name it "hnop".
06:38:46 <zooko> Could someone tell me how to build cabal-packaged Haskell projects, or point me to documentation?
06:38:56 <zooko> I'm trying ot build this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fec
06:39:19 <Lemmih> zooko: cabal configure && cabal build && cabal install.
06:39:45 <zooko> cabal: command not found
06:39:56 <quicksilver> step 1 : install cabal
06:40:15 <Lemmih> zooko: 'runhaskell Setup.*hs' can be used instead of 'cabal'.
06:40:25 <luqui> odd, when I install cabal on gentoo, I get no cabal executable...
06:40:57 <zooko> Is there a "{cabal,runhaskell Setup.*hs} test" command, too?
06:41:07 <Lemmih> luqui: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install-0.4.0
06:41:08 <lambdabot> http://tinyurl.com/yss6oz
06:41:46 <Lemmih> zooko: Yeah, but it usally doesn't do anything.
06:42:09 <zooko> Is there a standard way to invoke, um, HUnit, or something?
06:43:31 <Saizan> zooko: no
06:58:33 <assss> when i have this datastructure data Dir = L | R, how can i compare elements of lists of this structure? e.g. the line isPath (x:xs) (Node val tr1 tr2) = if x == L.... where the first argument is from type [Dir]
06:59:23 <shachaf> assss: data Dir = L | R deriving (Eq)?
06:59:45 <shachaf> assss: Or you can pattern-match: isPath (L:xs) ... = ...
07:00:14 <assss> ah was wondering how can use pattern-matchin in such a case, ty
07:03:54 <phobes> Hmm, I'm not getting cabal to work on this machine
07:04:19 <phobes> Is there anything I should have to do beyond installing the .deb file (I'm on ubuntu)
07:04:51 <dcoutts> phobes: do you mean the Cabal lib or the command line tool?
07:05:08 <phobes> dcoutts:  ah I probably just installed the lib
07:05:11 <phobes> thx
07:05:47 <dcoutts> phobes: the command line tool is still under development, if you want to play with it then use the darcs version, the version on hackage is far too old
07:06:06 <phobes> oh ok
07:09:40 <pastorNC> what does ~ do?
07:09:51 <phobes> It's a strictness anotation
07:10:23 <dcoutts> or rather a laziness annotation
07:10:36 <phobes> err ya
07:10:39 <phobes> that's what I meant :)
07:11:34 <dcoutts> pastorNC: eg foo (a,b) = ... is like \p -> case p of (a,b) -> ...
07:11:51 <dcoutts> pastorNC: but foo ~(a,b) = ... is like \p -> let (a,b) = p in ...
07:12:38 <dcoutts> pastorNC: so the ~ pattern match always succeeds/matches initially without forcing the value being matched
07:13:29 <dcoutts> then when any value within the match is demanded then the value is forced and matched against the pattern (at which point it must match or it's an error)
07:14:20 <dcoutts> > let foo ~(a,b) (c,d) = (a, c) in snd (foo undefined (1,2))
07:14:28 <lambdabot>  1
07:14:32 <dcoutts> > let foo (a,b) (c,d) = (a, c) in snd (foo undefined (1,2))
07:14:33 <lambdabot>  Undefined
07:15:48 <dcoutts> pastorNC: it is not needed very often
07:15:56 <dcoutts> @src unzip
07:15:56 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
07:16:23 <dcoutts> unzip is the canonical example imho, and things of the same pattern
07:16:53 <dcoutts> it has to be lazy in the second argument for the thing to be lazy overall
07:17:41 <phobes> Is happs easy to play with?
07:17:52 <dcoutts> phobes: ask Lemmih
07:18:03 <Lemmih> phobes: It will be once the stable release is out.
07:18:09 <kuribas> mux: ping
07:18:36 <phobes> Lemmih:  So right now it would be ?
07:18:56 <phobes> or it's buggy right now?
07:19:05 <mux> kuribas: pong
07:19:29 <kuribas> mux: I found your paste: http://hpaste.org/3752
07:19:46 <mux> oh, that's long solved
07:19:51 <kuribas> I am seeing the same kind of error when building gtk2hs.
07:19:57 <Lemmih> phobes: No, the interface just isn't stable.
07:20:01 <phobes> oh ok
07:20:13 <mux> kuribas: ask dcoutts, he's the one who helped me solve it, I don't remember how
07:20:21 <Lemmih> phobes: Anything you write now will have to be modified once the new release is out.
07:20:28 <kuribas> mux: Ok, thanks.
07:20:42 <phobes> alright - what's the timeframe on that?
07:20:44 <mux> you're welcome
07:20:45 <Lemmih> (Which is about a week or two away at most)
07:20:56 <phobes> ok cool
07:20:58 <phobes> thanks
07:21:38 <kuribas> dcoutts: Do you know why gtk2hs doesn't build?  I get a lot of errors: "first defined here".
07:21:42 <phlpp> :t (~)
07:21:44 <lambdabot> parse error on input `)'
07:22:09 <Botje> kuribas: chances are you're missing some headers
07:22:10 <assss> mmh http://hpaste.org/5466 i dont understand what he tries to tell me... there is nothign with Bool or sth like that
07:22:11 <desegnis> phlpp: ~ is syntax
07:22:24 <desegnis> (when pattern-matching)
07:22:36 <kuribas> Botje: gtk headers?
07:22:39 <Botje> assss: what does isPath return?
07:22:42 <Botje> kuribas: maybe?
07:22:44 <phlpp> ah ok
07:22:57 <Botje> assss: if isPath retuns a Bool, getValue isn't as polymorphic as your type indicates
07:23:48 <dcoutts> kuribas: what version of ghc, gcc and what OS?
07:23:59 <assss> Botje, ah okay thx
07:24:03 <desegnis> assss: maybe you simply mis-typed isPath where you meant getValue?
07:24:35 <dcoutts> kuribas: it's almost certainly because ghc's split-objs feature is not working on your platform, I've seen quite a bit of that problem recently, we might have to turn split-objs off by default.
07:24:56 <kuribas> dcoutts: It doesn't work on debian-linux?
07:24:57 <assss> desegnis, yea that was the case :D i was wondering as botje mentioned isPath cuz i didnt want to use it there
07:25:06 <dcoutts> kuribas: what version of ghc and gcc?
07:25:41 <kuribas> ghc 6.6.1, gcc 4.1.2
07:26:01 <dcoutts> kuribas: the workaround is not to use the split-objs feature. make clean; ./configure --disable-split-objs; make
07:26:09 <faxathisia> hi
07:26:11 <dcoutts> kuribas: yes, that's a known bad combination
07:26:53 <kuribas> dcoutts: Should I upgrade gcc?
07:27:18 <dcoutts> kuribas: no, you'd have to downgrade gcc, or upgrade ghc. No the solution is just to not use split-objs.
07:27:36 <dcoutts> kuribas: configure gtk2hs with the --disable-split-objs flag.
07:27:38 <kuribas> dcoutts: Ok.
07:27:55 <dcoutts> kuribas: the only downside is it means the final binaries will be a lot larger
07:28:29 <faxathisia> Where does topological sort come into play in a haskell implementation? (I think I can see two instances)
07:28:37 <kuribas> dcoutts: Yes, I already saw that.
07:28:57 <kuribas> dcoutts: Do you know maybe if cairo can be compiled separately from gtk2hs?
07:29:24 <kuribas> dcoutts: I'd like to use it in a program, but without requiring a large dependency.
07:29:25 <dcoutts> kuribas: it's not easy to do that yet. Once gtk2hs uses cabal that'll be possible.
07:30:23 <kuribas> dcoutts: So I can use gtk2hs now, and later it will be possible to compile it with cairo, and without gtk2hs?
07:30:54 <dcoutts> kuribas: when gtk2hs uses cabal it'll just be a collection of independent packages, glib, gtk, cairo etc
07:31:29 <kuribas> dcoutts: ok, then I'll use gtk2hs now.
07:31:50 <dcoutts> kuribas: and in particular the cairo package will not depend on the gtk package, so yes that'll be possible
07:32:26 <kuribas> dcoutts: That's nice, because then I'll be able to generate different file formats.
07:32:51 <dcoutts> kuribas: you're generating ps/pdf/svg/png, that kind of thing?
07:32:57 <kuribas> yes
07:34:12 <kuribas> I am writing a typesetting engine for musical scores.
07:34:45 <dcoutts> kuribas: cool :-)
07:35:25 <kuribas> I am using a modified TeX paragraph breaking algorithm for finding an optimal layout.
07:35:32 <desegnis> kuribas, that's interesting, are you writing from scratch?
07:35:46 <kuribas> desegnis: yes.
07:36:27 <kuribas> If someone wants to contribute, you are welcome :)
07:36:46 <awesame> how can I test whether a string begins with some substring in haskell?
07:36:59 <malcolmw> isPrefixOf
07:37:06 <awesame> thanks
07:37:09 <Syzygy-> > "pre" `isPrefixOf` "prefix"
07:37:12 <lambdabot>  True
07:37:23 <brothers> kuribas: did you see the paper on the functional implementation of TeX?
07:37:26 <desegnis> I currently use lilypond for musical typesetting, and its output is just awesome, but the user's and programmer's interface is just bad
07:37:32 <awesame> also, what does $ mean?  it's surprisingly hard to google
07:37:33 <kuribas> brothers: no.
07:37:43 <brothers> kuribas: http://citeseer.ist.psu.edu/251273.html
07:37:44 <lambdabot> Title: A Functional Description of T E X's Formula Layout - Heckmann, Wilhelm (Research ...
07:37:56 <Syzygy-> awesame: f $ x = f x
07:37:58 <kuribas> desegnis: yes, I know :) The input format will be a small functional language.
07:38:00 <malcolmw> awesame: $ is just function application (with different associativity)
07:38:04 <Syzygy-> But with different precedence
07:38:11 <Syzygy-> ?src ($)
07:38:11 <lambdabot> f $ x = f x
07:38:24 <awesame> so how does it change the associativity?
07:38:36 <malcolmw> infixr $
07:38:48 <Syzygy-> It's extremely low in precedence. So almost anything else takes place before the function application.
07:38:57 <kuribas> brothers: cool, thanks.
07:39:04 <Syzygy-> So you can write things like > f . g . h $ x
07:39:09 <brothers> kuribas: np, that's why i lurk here
07:39:12 <desegnis> kuribas, sounds promising, I hope you have enough resources to move it into a usable state
07:39:17 <awesame> ah, I see
07:39:24 <awesame> cool, thanks
07:39:38 <desegnis> awesame: if you can't google it, hoogle it!
07:39:41 <kuribas> desegnis: you mean time? :-)
07:39:51 <desegnis> kuribas, yeah :)
07:39:58 <desegnis> and typesetting capability
07:40:17 <awesame> I've been using parens a lot more than I tend to see in the haskell code I'm workiing with, and I bet all these $s have something to do with that
07:40:19 <desegnis> (which isn't a point if you have really enough time)
07:40:33 <kuribas> desegnis: well, I have lots of ideas, but I need to try them out to see if they will work well.
07:41:01 <desegnis> ideas are a good thing :)
07:42:05 <desegnis> kuribas, I'll be curious how you'll deal with fonts, because cairo does not provide a sufficient font api
07:42:18 <kuribas> desegnis: aw, that's a problem...
07:42:48 <dcoutts> desegnis, kuribas: cairo has a 'toy' font api, if you're doing stuff seriously with fonts and cairo you're supposed to use the pango-cairo font/text api
07:43:05 <dcoutts> which is currently part of the gtk package
07:43:12 <kuribas> dcoutts: great, I'll remember that.
07:43:47 <kuribas> I'll need to load my Type1 font, and place individual glyphs on the page.
07:44:00 <dcoutts> kuribas: there are some demos using that in the gtk2hs collection. I guess eventually we'd want to split the pango stuff into a pango package so that it's possible to use with cairo without needing all of gtk.
07:44:15 * LeCamarade starts with an AST when doing a compiler - is it good practice?
07:44:42 <faxathisia> Os the first bit of programming .. I think that's the backbone
07:44:44 <dcoutts> kuribas: hmm, I'm not sure how to do that. Check how you'd do that with cairo+pango's C API, we can bind any missing pango functions.
07:45:30 <kuribas> ok
07:46:50 <desegnis> dcoutts, I guess the critical bit will be referencing a font by the path to a *.pfa file which is installed in a non-standard location
07:47:03 <dcoutts> kuribas: of course if your font is already registered it's easy to look up by name, but I'm not sure how you'd load it given just the file
07:48:23 <dcoutts> desegnis: right
07:48:57 <dcoutts> kuribas: also, the downside of using a custom font is that it might be hard to use that in a ps/pdf/svg if they have to reference rather than embed the font.
07:50:30 <kuribas> dcoutts: Yes, but the font is an important part of the general look of the score.
07:50:45 <kuribas> If it is possible I'd like to include the file.
07:51:14 <desegnis> I think embedding is the way to go, at least where possible (pdf, ps?)
07:51:39 <dcoutts> I'm not sure how that works with cairo, you'll have to investigate
07:55:00 <desegnis> at least it seems possible
07:57:11 <kuribas> Maybe I could create a binding with the FreeType rendering engine.  It seems that cairo can use fonts opened with that engine.
07:57:35 <b_jonas> @instances Cont
07:57:42 <lambdabot> Couldn't find class `Cont'. Try @instances-importing
07:57:54 <dcoutts> kuribas: pango already wraps that and more, you probably want to use pango and not anything lower level, pango already provides a great deal of control at many levels
07:57:58 <mauke> @instances MonadCont
07:57:58 <lambdabot> Cont r, ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
07:58:19 <b_jonas> mauke: no, I'd like to search the other way
07:58:28 <b_jonas> what classes are Cont and Cont r instance of
07:58:39 <b_jonas> @classes Cont
07:58:39 <lambdabot> Unknown command, try @list
08:04:25 <desegnis> b_jonas, :info in ghci
08:04:47 <desegnis> oh wait, no
08:04:51 <igel> @src liftM
08:04:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:05:18 <desegnis> b_jonas, ignore that :)
08:06:57 <kuribas> dcoutts: Yes, I think I can use the rendering functions from cairo.
08:07:09 <mux> cairo is neat
08:07:19 <mux> the Render monad is warm and fuzzy
08:09:44 <dcoutts> kuribas: though I still cannot see how to load a font from a specific file, you may well have to bind a couple FT functions
08:10:29 <dcoutts> kuribas: ie use FT to get an FTFont and then pass that to pango's FT backend to get a normal pango font type
08:13:03 <dcoutts> kuribas: that's what the python and perl bindings seem to do, eg http://cairographics.org/freetypepython/
08:13:04 <lambdabot> Title: Loading fonts using FreeType for cairo use in Python
08:13:49 <kuribas> Yes, and I'd need the cairo_show_glyphs function from the C API.
08:15:28 <dcoutts> kuribas: should be easy to add that to the cairo bindings, we accept patches :-)
08:16:26 <nominolo> kuribas: what are you trying to do?
08:16:40 <kuribas> nominolo: Creating a music typesetting engine.
08:17:08 <quicksilver> kuribas: I have used your noew indentation engine a bit, by the way. So far, so good.
08:17:16 <kuribas> I need to load the music font from a file, and render individual glyphs.
08:17:23 <quicksilver> kuribas: only thing which confuses me is sometimes it wants to indent the root level of my module by 2 spaces
08:17:44 <kuribas> quicksilver: Hm, it does?  Can you give me a file where it does that?
08:18:30 <nominolo> kuribas: interesting
08:19:20 <nominolo> dcoutts: how did you decide what to put into into gtk2hs and what not?  personal requirements? :)
08:20:15 <dcoutts> nominolo: yes partly, and what seemed like it'd be most used, and what was easiest to bind, and what was part of the api at the time (we're a bit out of date with new apis atm)
08:20:38 <kuribas> quicksilver: Do you have the latest?  http://kuribas.hcoop.net/haskell-indentation.el
08:21:01 <kuribas> quicksilver: I've renamed so it may be included into the haskell-mode package.
08:34:30 <glen_quagmire> i did  do   content <- readFile fn;   how can I split content on \n  ?
08:34:41 <kmcallister> glen_quagmire, lines content
08:34:43 <kmcallister> :t lines
08:34:46 <lambdabot> String -> [String]
08:34:50 <mux> lines <- lines `fmap` readFile fn
08:35:36 <Deewiant> lines <- lines <$> readFile fn
08:35:58 <mux> heh, will someone now mention liftM?
08:36:06 <moonlite> kuribas: to test your indentation mode should i have to do more than add "(setq load-path (cons "/home/mben/.elisp/" load-path))" to my .emacs (and then in a buffer call `haskell-indentation-mode`?
08:36:06 <twanvl> perhaps calling the result 'lines' is not the best idea
08:36:15 <mux> indeed
08:36:15 <Deewiant> liftM is what I'd use
08:36:23 <mux> I use fmap cause it's in Prelude
08:36:23 <kmcallister> @pl \fn -> do {content -> readFile fn; return $ lines content}
08:36:23 <lambdabot> (line 1, column 11):
08:36:23 <lambdabot> unexpected "{"
08:36:23 <lambdabot> expecting variable, "(", operator or end of input
08:36:27 <mux> liftM lives in Control.Monad
08:36:42 <visof> do anyone make trick for installing lambdabot by ghc-6.8 ?
08:36:43 <mauke> @. pl undo \fn -> do {content -> readFile fn; return $ lines content}
08:36:43 <lambdabot> Parse error at "->" (column 20)
08:36:45 <kuribas> moonlite: no, that should be enough.
08:36:48 <mux> and <$> in Control.Applicative
08:36:51 <moonlite> ok
08:36:52 <mauke> @. pl undo \fn -> do {content <- readFile fn; return $ lines content}
08:36:52 <lambdabot> (lines `fmap`) . readFile
08:37:04 <kmcallister> the simplest to understand is just  do content <- readFile fn; let lin = lines content
08:37:35 <moonlite> kuribas: aah got it. I've got another emacs instance running
08:37:40 <moonlite> that must be it
08:37:41 <kuribas> moonlite: You can use M-x load-file, and then type M-x haskell-indentation.mode.
08:38:25 <glen_quagmire> :t fmap lines readFile
08:38:25 <lambdabot>     Couldn't match expected type `String'
08:38:26 <lambdabot>            against inferred type `IO String'
08:38:26 <lambdabot>       Expected type: FilePath -> String
08:38:51 <Deewiant> :t fmap lines (readFile "")
08:38:51 <lambdabot> IO [String]
08:40:06 <moonlite> kuribas: ok that worked at lea
08:40:18 <moonlite> kuribas: ok that worked at least. I'll have to check why autoloading doesn't
08:40:26 <glen_quagmire> great it works!
08:41:12 <glen_quagmire> now, each line is "blah blah (some stuff)  (some stuff)"  . I want to make it in to ["blah blah", "some stuff", "some stuff"]
08:41:32 <glen_quagmire> this is parsec?
08:44:21 <quicksilver> kuribas: I did not, no. I have downloaded it now :)
08:45:25 * byorgey waves
08:48:41 <quicksilver> glen_quagmire: doesn't have to be parsec but certainly sounds like a job for a parsing combinator or three.
08:49:20 <glen_quagmire> i need to make this file into csv probably so that it can be imported to drupal
08:53:08 <glen_quagmire> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/csv-0.1.0 weeeeeeeeeeeeee
08:53:09 <lambdabot> http://tinyurl.com/22bk53
08:56:26 <quicksilver> it's scary that CSV requires a packge :P
08:57:03 <dcoutts> the csv escaping rules are non-trivial
08:58:19 <quicksilver> dcoutts: yeah, that's the scary part
08:58:47 <sarah> if theres a typeclass that i cant think of a good default for, what to do?
08:58:54 <dcoutts> quicksilver: and trying to grok files produced by programs that did not understand the escaping rules is even more fun :-)
08:59:08 <Igloo> There are 3 or 4 different sets of rules, just to make it more fun
08:59:11 <byorgey> sarah: what do you mean?
08:59:29 <dcoutts> sarah: you don't need to provide default implementations for class methods
08:59:54 <sarah> i have a typeclass that i want instance of to have to specify their default initial state, but dont know how to provide a default for this
09:00:34 <stevan> hello. i'm trying to understand how monad transformers work. i managed to get both simple examples of both state and writer running, but i fail to combine them... i tried various combinations of form: let m = do s <- get; tell [s] in runStateT (runWriter m) 0. could someone please show me the correct way o do it? thanks.
09:00:53 <quicksilver> sarah: you don't.
09:00:59 <quicksilver> sarah: in general, most methods should not have defaults.
09:02:09 <Botje> stevan: you need to lift methods to the correct monad
09:02:40 <quicksilver> :t get
09:02:42 <quicksilver> :t tell
09:02:42 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
09:02:42 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
09:02:46 <quicksilver> Botje: not true.
09:03:00 <quicksilver> Botje: they are both methods of helper-typeclasses made for exactly this reason.
09:03:04 <Botje> ah
09:03:10 <faxathisia> How do you make a datatype for Directed Acyclic Graphs in Haskell?
09:03:22 <Botje> I played with other monad transformers, then
09:03:24 <Lemmih> quicksilver: StateT isn't an instance of MonadWriter.
09:03:42 <oerjan> faxathisia: er, that's a forest isn't it?
09:03:43 <quicksilver> Lemmih: no, but StateT s Writer is
09:03:43 <desegnis> stevan: or you could make your monad an instance of MonadWriter, then you'd need lift only once (in the instance definition)
09:03:44 <dons> ?users
09:03:44 <lambdabot> Maximum users seen in #haskell: 471, currently: 419 (89.0%), active: 22 (5.3%)
09:03:53 <faxathisia> I don't know
09:04:06 <faxathisia> Hi dons
09:04:12 <oerjan> so, a list of trees
09:04:18 <Saizan> faxathisia: depends on the algorithms you want to run on them
09:04:59 <dcoutts> @seen ndm
09:04:59 <lambdabot> I haven't seen ndm.
09:05:04 <stevan> i'd just like to see a simple example to better grasp the concept.
09:05:18 <quicksilver> stevan: just writing one for you, give me a second :)
09:05:24 <quicksilver> stevan: you have the right idea
09:05:26 <faxathisia> hm.
09:05:38 <stevan> thanks. :-)
09:05:54 <faxathisia> I think it's simple to make a type for Graphs.. [(Int,Int)]
09:05:59 <faxathisia> and DAGs are a subset
09:06:13 <faxathisia> but is it possible to make a type that contains only DAGs?
09:06:17 <quicksilver> >  let m = do { s <- get; tell [s] } in  runWriter (runStateT m 0)
09:06:18 <lambdabot>  (((),0),[0])
09:06:24 <quicksilver> stevan: there you go.
09:06:31 <quicksilver> stevan: you just unwrapped your monads in the wrong order, that's all.
09:06:57 <Deewiant> use Data.Graph or Data.Inductive.Graph and just check for cycles every time you add an element ;-)
09:07:07 <quicksilver> >  let m = do { s <- get; tell [s] } in  runWriter (runStateT (m >> put 5 >> m) 0)
09:07:07 <lambdabot>  (((),5),[0,5])
09:07:16 <quicksilver> slightly more interesting example
09:08:07 <faxathisia> in other words, It's impossible? :P
09:08:10 <oerjan> > let  m = do { s <- get; tell [s] } in runRWS (m >> put 5 >> m) 0 0
09:08:11 <lambdabot>  ((),5,[0,5])
09:08:29 <quicksilver> faxathisia: the same question could be asked "how would you model a DAG in formal maths"
09:08:37 <quicksilver> faxathisia: the answer would be the same as the haskell answer.
09:08:52 <quicksilver> if you have a maths-formal model for DAGs, you can translate that to haskell.
09:09:10 <faxathisia> I don't think I can translate any maths into haskell
09:09:27 <quicksilver> no, but this channel could
09:09:31 <Deewiant> :-D
09:09:47 <oerjan> #haskell, the ai-complete channel!
09:09:58 * faxathisia tries to figure this out..
09:11:11 <quicksilver> it's not easy
09:11:23 <magnusjonsson> Is there any haskell library for representing and unparsing C code?
09:11:24 <quicksilver> because your DAG can have 'non-directed cycles'
09:11:52 <quicksilver> and that means you need your own notion of identity and pointer, proabbly
09:12:00 <quicksilver> which then makes it hard to exclude cycles
09:12:01 <quicksilver> AIUI
09:12:20 <kmcallister> magnusjonsson, i was working on such a thing but it's not ready
09:12:29 <kmcallister> what do you want to use it for?
09:12:38 <faxathisia> "Weisstein's conjecture proposed that positive eigenvalued -matrices were in one-to-one correspondence with labeled acyclic digraphs"
09:12:53 <faxathisia> (0,1)-matrices
09:13:01 <magnusjonsson> kmcallister: generating C code
09:13:46 <quicksilver> good luck designing a data structur for matrices which enforces that they have positive eigenvalues :)
09:14:05 <quicksilver> I suppose you could store it upper triangular or something.
09:15:37 <faxathisia> ok I have some idea
09:15:39 <faxathisia> For any single node N, (N) is a DAG
09:16:11 <faxathisia> if W is a DAG with nodes (N0, N1, ..., Nk) then W with the node Nk+1 added and zero or more links of the from Nk+1 -> Nj, where 0 <= j <= k, is a DAG
09:16:28 <faxathisia> I suppose you can construct all DAGs like that too
09:16:37 <kmcallister> magnusjonsson, i mean what app, in particular what C features do you need
09:16:53 <quicksilver> you mean forcing tyhe edges to respect a total ordering on nodes?
09:16:58 <faxathisia> Yes
09:17:00 <quicksilver> that sounds plausible
09:17:08 <faxathisia> It's kind of predicative though.. I can't imagine how to do that in the type system..
09:17:15 <quicksilver> but then a 'local' change might require reformatting everything
09:17:37 <dcoutts> magnusjonsson: c2hs has a C AST and a part of a pretty printer, but it's fairly incomplete
09:17:38 <quicksilver> if you add a link from 4 to 3, you have to renumber
09:17:43 <quicksilver> could be expensive
09:17:58 <dcoutts> magnusjonsson: c2hs has a good C parser though
09:18:17 <magnusjonsson> kmcallister: Ah.. I need functions, struct and c99 style structure initialization
09:18:39 <faxathisia> This is cool though http://mathworld.wolfram.com/WeissteinsConjecture.html
09:18:40 <lambdabot> Title: Weisstein's Conjecture -- from Wolfram MathWorld
09:18:57 <magnusjonsson> dcoutts: thanks, I'll check it out
09:20:07 <dons> http://reddit.com/r/programming/info/67m8k/details   monad transformers.
09:20:21 <cjb> monads in disguise!
09:21:10 <faxathisia> I have another question too :S
09:21:12 <cjb> is John Power the same John Power that writes Go books?
09:22:07 <faxathisia> I was thinking about if you wanted to add mutable references (in some monad..), Would that be possible with having to actually write you own garbage collector?
09:22:41 <faxathisia> I couldn't decide a way to do it without requireing a GC..
09:23:05 <kmcallister> faxathisia, yes, for example IORefs are garbage collected automatically
09:23:07 <kmcallister> i believe
09:24:02 <quicksilver> cjb: I don't think so
09:24:17 <kmcallister> if the reference is not reachable then the referant is not reachable
09:24:21 <cjb> ah, ok.  I think they're both British, though?
09:24:23 <quicksilver> faxathisia: Not without hooks into the runtime, no.
09:24:31 <quicksilver> cjb: the CS john power is australian
09:24:35 <quicksilver> I think
09:24:38 <quicksilver> he works in Britain
09:24:38 <cjb> Ah.
09:24:55 <osfameron> is he related to Max Power?
09:25:04 <quicksilver> faxathisia: e.g. by re-using IORef or STRef :)
09:25:12 <kmcallister> you're right if you're implementing a ref type in pure haskell
09:25:15 <faxathisia> ok thanks, and I was wondering about one more thing..
09:25:19 <quicksilver> kmcallister: IORefs require runtime support though.
09:25:25 <kmcallister> since you can't introspect whether some particular value in your index type exists
09:25:27 <kmcallister> yeah
09:25:43 <faxathisia> How many times does Topological sort pop up in a Haskell implementation?
09:25:49 <faxathisia> I think at least 2...
09:26:14 <ddarius> I'm getting emails from Paul Taylor...
09:26:26 <magnusjonsson> @pl (\f a b -> a >>= (\av -> b >>= (\bv -> f av bv)))
09:26:26 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
09:26:54 <awesame> hm
09:27:02 <faxathisia> is it 2 or more?
09:27:03 <quicksilver> magnusjonsson: f <*> av <*> bv
09:27:05 <quicksilver> magnusjonsson: I think.
09:27:09 <awesame> so I have a list of Strings, [a, b, c, d]
09:27:10 <magnusjonsson> quicksilver: awesome
09:27:23 <awesame> and I want to produce a new list selecting some of those elements
09:27:32 <awesame> say, [b, c, d], or [b, d]
09:27:38 <faxathisia> selecting them?
09:27:40 <faxathisia> how
09:27:42 <oerjan> @pl a >>= (\av -> b >>= (\bv -> f av bv))
09:27:42 <lambdabot> (b >>=) . f =<< a
09:27:48 <awesame> faxathisia: by index
09:27:59 <faxathisia> so you have a list of indices?
09:28:21 <faxathisia> > map (["a","b","c","d"]!!) [1,3]
09:28:22 <lambdabot>  ["b","d"]
09:28:24 <awesame> no, I have this list of 4 Strings, and I want a new list of, say, elements 1 and 3
09:28:28 <awesame> ah
09:28:29 <quicksilver> > let l = "abcd" in map (l!!) [0,3]
09:28:29 <awesame> ok
09:28:30 <lambdabot>  "ad"
09:28:40 <awesame> I should have thought of that
09:29:11 <faxathisia> > let select lists = map (lists!!) in   select ["a","b","c","d"] [1,3]
09:29:12 <lambdabot>  ["b","d"]
09:29:34 <awesame> thanks!
09:29:50 <faxathisia> I think Topological Sort is done on expressions like  (1+x)*sqrt (x-1)
09:29:59 <faxathisia> for lazy evaluation
09:30:24 <kmcallister> faxathisia, implicitly yes
09:30:28 <faxathisia> and also the order files are compiled happens to be a Topological Sort of the dependancies
09:30:32 <quicksilver> lazy evaluation doesn't require any sorting explicitly
09:30:35 <quicksilver> it just happens.
09:30:38 <faxathisia> yes
09:30:40 <quicksilver> the algorithm is very simple
09:30:58 <faxathisia> so .... Are there any more examples of Topological Sort in a Haskell implementation?
09:31:02 <oerjan> @pl \f a b -> join (liftM2 f a b)
09:31:02 <lambdabot> ((join .) .) . liftM2
09:31:43 <faxathisia> did I notice them all in fact?
09:32:12 <Botje> faxathisia: don't forget let bindings
09:32:18 <kmcallister> there are probably more
09:32:28 <faxathisia> o_o
09:32:38 <faxathisia> what how does let introduce it?
09:32:40 <kmcallister> it's a very useful algorithm for untangling dependencies, and there are lots of those in a compiler
09:32:42 <oerjan> magnusjonsson: i think that is closer
09:33:05 <Botje> faxathisia: say you have let c = 3 + a; a = 5; b = a + 2; in ...
09:33:14 <Botje> c and b depend on the value of a
09:33:16 <faxathisia> you can have mutually recursive lets though
09:33:21 <kmcallister> the dependency graph of a let block isn't necessarily acyclic though... you can probably toposort to optimize some stuff though
09:33:27 <faxathisia> So it cannot be topological sorting in general
09:33:34 <oerjan> faxathisia: the type inference of lets does a topological sort first
09:33:47 <kmcallister> faxathisia, you can decompose into cycles and toposort those, maybe?
09:33:48 <faxathisia> I don't understand
09:34:50 <awesame> hm
09:34:57 <oerjan> faxathisia: when typing a recursive binding, the inferencer assumes the function calls itself with the same type as it is called with
09:34:58 <faxathisia> for what purpose?
09:35:10 <oerjan> this also applies to mutually recursive functions
09:35:20 <awesame> so now I have a Maybe [String], and I want to apply ++ to it, yielding a Maybe String
09:35:41 <oerjan> (unless an explicit type declaration is given)
09:35:44 <faxathisia> > liftM concat $ Maybe ["foo","bar"]
09:35:44 <lambdabot>   Not in scope: data constructor `Maybe'
09:36:04 <awesame> huh?  is Maybe a Monad?
09:36:11 <Deewiant> yep
09:36:12 <kmcallister> awesame, yup
09:36:12 <oerjan> so the functions need to be grouped into maximal mutually recursive subgroups
09:36:16 <awesame> crazy!
09:36:16 <kmcallister> ?src Maybe (>>=)
09:36:16 <lambdabot> (Just x) >>= k      = k x
09:36:17 <lambdabot> Nothing  >>= _      = Nothing
09:36:22 <kmcallister> it models computations that can fail
09:37:02 <faxathisia> oerjan, Why is it not possible to just type each one in sequence?
09:37:22 <awesame> I am at some weird point where I'm conceptually comfortable with IO, but not with any other monad
09:37:26 <quicksilver> oerjan: hmm. for a fairly relaxed reading of 'same type'
09:37:34 <oerjan> faxathisia: if two functions call each other, what type should be assumed for one during the typing of the other?
09:37:41 <quicksilver> oerjan: since haskell permits polymorphic recursion, unlike , e.g., ML.
09:37:45 <kmcallister> awesame, that's unfortunate because IO is not really like any of the others
09:37:50 <magnusjonsson> @source join
09:37:50 <lambdabot> join not available
09:37:54 <kmcallister> Maybe is a good place to start understanding monads in general
09:37:56 <oerjan> quicksilver: only with explicit type declarations
09:38:06 <quicksilver> oerjan: oh, really?
09:38:11 <oerjan> which break the graph. yes.
09:38:12 <quicksilver> I guess I'd never checked that.
09:38:25 <cjb> also List.
09:38:29 <oerjan> @src join
09:38:29 <lambdabot> join x =  x >>= id
09:38:34 <faxathisia> I think you assume some flexible type.. and then it should be unified later, so you know if everything works out or not
09:38:54 <magnusjonsson> oerjan: that makes a lot of sense. Thanks :), now I know what join is for as well
09:38:56 <quicksilver> oerjan: ah, not true
09:39:05 <quicksilver> oh
09:39:08 <quicksilver> yes it is ;)
09:39:11 <quicksilver> my test was flawed.
09:39:12 <faxathisia> I think I really need to implement let sometime to understand it :S
09:39:33 <magnusjonsson> @src <*>
09:39:34 <lambdabot> Source not found. My brain just exploded
09:39:45 <awesame> kmcallister: hm.  how would I use do notation with Maybe?
09:39:49 <oerjan> faxathisia: problem is that the generalization step cannot be performed until the unification has been completed
09:40:12 <ddarius> > let f 0 x = show x; f n x = f (n - 1) (x,x) in f 3 ()
09:40:12 <kmcallister> awesame, do { x <- something; y <- somethingElse x; return (x,y) }
09:40:13 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
09:40:13 <lambdabot>       Expec...
09:40:17 <faxathisia> What is the generalization?
09:40:25 <kmcallister> if something fails (returns Nothing), it will return Nothing
09:40:31 <ddarius> > let f :: Show a => Int -> a -> String; f 0 x = show x; f n x = f (n - 1) (x,x) in f 3 ()
09:40:32 <oerjan> faxathisia: which means that during this process all the functions in a subgroup must be assumed monomorphic
09:40:38 <lambdabot>  "((((),()),((),())),(((),()),((),())))"
09:40:43 <awesame> I see
09:40:44 <kmcallister> if something returns Just x, it will call somethingElse x.  if that fails the whole thing fails, otherwise... etc.
09:40:59 <oerjan> faxathisia: the putting of forall's for type variables
09:41:18 <faxathisia> ahh... ok
09:41:21 <kmcallister> if you want to return errors of some type e, rather than simply Nothing, look at the (Either e) monad and the MonadError typeclass
09:41:28 <faxathisia> I think I see why it's a requirement now
09:41:34 <faxathisia> This is quite tricky though
09:42:14 <awesame> kmcallister: I think that's starting to make some sense
09:42:18 <awesame> kmcallister: thanks
09:42:41 <kmcallister> awesame, http://www.haskell.org/all_about_monads/html/index.html is a good document
09:42:44 <lambdabot> Title: All About Monads
09:42:55 <kmcallister> it has examples for many standard monads
09:43:04 <kmcallister> (although i still have yet to grok the Continuation monad)
09:43:25 <kmcallister> when i took an intro Haskell course the instructor warned us that "that way lies madness"
09:43:30 <awesame> oh boy, continuations plus monads
09:43:30 <kmcallister> (re: Continuation monad)
09:43:35 <oerjan> @src Applicative
09:43:35 <lambdabot> class Functor f => Applicative f where
09:43:35 <lambdabot>     pure  :: a -> f a
09:43:35 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
09:43:40 <oerjan> magnusjonsson: ^^^
09:43:47 <oerjan> (it's a method)
09:44:25 <oerjan> (for monads, should be equivalent to ap)
09:44:27 <oerjan> @src ap
09:44:27 <lambdabot> ap = liftM2 id
09:44:37 <magnusjonsson> Aha, and Monad f => Functor f?
09:45:13 <oerjan> magnusjonsson: alas, for hysterical raisins Monads are not technically connected to Functor and Applicative
09:45:22 <oerjan> but in spirit, yes
09:45:46 <oerjan> pure = return, fmap = liftM
09:45:56 <magnusjonsson> aha
09:46:04 <oerjan> @src Functor
09:46:05 <lambdabot> class  Functor f  where
09:46:05 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:46:08 <byorgey> hysterical raisins, eh?  hehe
09:46:50 <byorgey> magnusjonsson: btw, that would be Functor f => Monad f
09:47:44 <magnusjonsson> byorgey: so functors are a subset of monads?
09:47:54 <quicksilver> what magnusjonsson wrote made more sense
09:47:56 <byorgey> magnusjonsson: no, the other way around.
09:48:04 <byorgey> oh, wait
09:48:04 <quicksilver> but what byorgey wrote is a fragment of haskell syntax :)
09:48:12 <byorgey> hehe, I see the confusion now =)
09:48:12 <quicksilver> we would write "class Functor f => Monad f"
09:48:20 <quicksilver> meaning that all Monads must be Functors
09:48:24 <quicksilver> however, we haven't written that
09:48:28 <quicksilver> because of those damn raisins
09:48:44 <resiak> how likely is this to get fixed in H' ?
09:49:02 <magnusjonsson> do those raisins have anything to do with "fail"?
09:49:05 <byorgey> magnusjonsson: yes, Monad f IMPLIES Functor f.  But in a Haskell class instance declaration you would write that as instance Functor f => Monad f where ...
09:49:13 <moonlite> @pl raise x = map (x+)
09:49:13 <lambdabot> raise = map . (+)
09:49:20 <byorgey> magnusjonsson: I was thinking of the latter and you were saying the former.
09:49:24 <oerjan> magnusjonsson: that's a slightly different raisin :D
09:49:31 <moonlite> hm ofcourse. :)
09:49:36 <magnusjonsson> damn these raisins :)
09:49:46 <phobes> that's just sour grapes
09:51:08 <magnusjonsson> byorgey: I see the confusion... strange how haskell's syntax is backwards from logic notation in this case
09:51:28 <ddarius> byorgey: Ideally you'd have the class declaration class Functor f => Monad f where ... not an instance declaration
09:51:29 <byorgey> magnusjonsson: indeed.  I've long thought that the Haskell => should really be <= .
09:51:44 <byorgey> ddarius: er, yes, indeed.
09:51:48 <ddarius> byorgey: Only for class declarations, instance declaration it should be =>
09:51:51 <paczesiowa> Taejo: how about chaining [in]equalities? any brilliant ideas yet?
09:52:25 <Taejo> paczesiowa: not really
09:53:05 <Taejo> paczesiowa: did consider an alternative of using a function: chain $ a <& b <& c
09:53:13 <byorgey> ddarius: I'm not so sure.  <= would give a better intuition about how instance selection actually works.  i.e. the instance is selected which then generates an additional constraint.
09:53:20 <Taejo> and have <& construct a value
09:53:40 <Taejo> paczesiowa: but that avoids the interesting question
09:53:48 <byorgey> ddarius: the => notation gave me the wrong intuition about that for a long time.
09:53:50 <phobes> What are the advantages of using subclassing over defining an instance of the would-be subclass?
09:54:11 <ddarius> byorgey: Look at, e.g. the Eq instance of [], instance (Eq a) => Eq [a] where ...
09:54:17 <twanvl> You could read the => in a class as "If there is an instance Functor a, then Monad a is the class where ..."
09:54:19 <phobes> Just that you have multiple symbol names if you do it the other way?
09:54:35 <ddarius> Reading => as implies is exactly what you want.  An Eq instance for a implies that there is an Eq instance for [a]
09:54:44 <byorgey> ddarius: yes, I see the logic of that.
09:54:59 <byorgey> ddarius: I guess what I am talking about is orthogonal.
09:55:27 <ddarius> The class one is definitely backwards
09:55:32 <twanvl> This also holds for classes, just remember that you are talking about the class itself, not its instances.  An Eq instance for a implies that there is an Ord class for a.
09:55:34 <byorgey> indeed.
09:56:26 <paczesiowa> Taejo: there are plenty ways to avoid the real "problem" (e.g. not using any syntactic salt), we could write if' function taking some dump parameter when
09:57:06 <Taejo> paczesiowa: yeah
09:57:13 <paczesiowa> funny thing about python version is this: 1==1==1 --> True, 1==1==True --> True
09:58:02 <oerjan> paczesiowa: huh?  is True converted to 1 implicitly?
09:58:09 <paczesiowa> that's imaginary goose typing not duck typing
09:59:06 <byorgey> 2==2==2 --> True, (2==2)==2 --> False, 2==(2==2) -> False.  wtf!?
09:59:07 <paczesiowa> oerjan: I don't know if it's converted, I don't understand python, but python interpreter evaluates those this way
09:59:44 <paczesiowa> (2==2)==2 -> False, (1==1)==1 -> True
09:59:51 <oerjan> paczesiowa: i think == does numeric comparison.  there's another non-numeric one (was it EQ?)
09:59:54 <Taejo> byorgey: == == is essentially a different operator to ==
10:00:05 <byorgey> Taejo: apparently!
10:00:08 <phobes> lol
10:00:21 <ddarius> What the heck is going on?
10:00:23 <phobes> The ternary airplane operator, as they call it in python
10:00:25 <oerjan> byorgey: python follows mathematical convention with implicit chaining of relations
10:00:29 <byorgey> ddarius: nothing good.
10:00:52 <ddarius> So 2==2==2 is 2==2 && 2==2 ?
10:00:57 <oerjan> ddarius: right
10:00:59 <paczesiowa> so == == is ternary operator? how about 1==1==1==1 ? depends on parsing/parens?
10:01:04 <byorgey> oerjan: ah, so  x op y op z --> (x op y) && (y op z) ?
10:01:10 <oerjan> byorgey: right
10:01:12 <byorgey> ok, right.
10:01:13 <phobes> it's what ddarius said (not ternary)
10:01:24 <byorgey> well, that's kind of nifty I guess
10:01:44 <mauke> .oO( guess what perl does )
10:02:05 <byorgey> la la la la not listening la la la
10:02:12 <mauke> haha
10:02:16 <phobes> I'll guess that in perl   2==2==2  --> "twotwotwo"
10:02:23 <ricky_clarkson> Someone email this to the xkcd guy.
10:02:33 <mauke> it's pretty sane: it throws a parse error because == is non-associative
10:02:41 <ddarius> > 3==5==7
10:02:45 <lambdabot>      precedence parsing error
10:02:45 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
10:02:46 <oerjan> mauke: it guesses the parsing you want, perhaps? :D
10:02:47 <paczesiowa> does python have write_canonical-y thingie?
10:02:50 <byorgey> oh! perl does something sane!?  amazing
10:02:57 <phobes> and then casts the parse error to a string "parse error"
10:02:59 <mauke> same as haskell
10:03:04 <desegnis> n-ary (==) looks pretty, but python's (==) logic is insane otherwise. nearly php-like
10:03:32 <Taejo> desegnis: it is? I'm mostly a python-programmer, and PHP's == just looks insane to me
10:03:37 <ricky_clarkson> You could make an n-ary (==) in Haskell.
10:03:45 <ricky_clarkson> .. like how printf works.
10:03:46 <paczesiowa> too bad we can't implement insane things in haskell:/
10:03:58 <ddarius> paczesiowa: Sure you can
10:04:02 <Taejo> ricky_clarkson: we've been trying
10:04:06 <ricky_clarkson> Ah :)
10:04:23 <desegnis> Taejo, oh, maybe I'm attributing too much of php's insanity to python only because of Python's 0 == False
10:04:24 <ricky_clarkson> I'm not sure you could do it infix.
10:04:58 <Taejo> ricky_clarkson: how do you do it prefix?
10:05:12 <paczesiowa> ricky_clarkson: http://hpaste.org/5460
10:05:16 <phobes> ricky_clarkson:  it would get ambiguous if you defined == on bools
10:05:22 <ricky_clarkson> same as for printf :)
10:05:42 <Taejo> paczesiowa: does that work?
10:05:56 <paczesiowa> Taejo: yes
10:06:09 <paczesiowa> but it's not polymorhpic and needs -fallow-ugly-code
10:06:32 <Taejo> ah, yes, I see now it's non-polymorphic (urgh)
10:06:34 <paczesiowa> there is no problem with infix/prefix that is handled during parsing
10:06:44 <Taejo> what is -fallow-ugly-code ?
10:06:52 <olsner> Taejo: a joke :P
10:06:52 <paczesiowa> System.IO.Unsafe
10:07:03 <oerjan> @remember paczesiowa but it's not polymorhpic and needs -fallow-ugly-code
10:07:03 <Taejo> olsner: ok
10:07:03 <lambdabot> I will never forget.
10:07:13 <ddarius> @users
10:07:13 <lambdabot> Maximum users seen in #haskell: 471, currently: 428 (90.9%), active: 22 (5.1%)
10:07:38 <olsner> I'd probably need a -Wugly-code though
10:07:52 <paczesiowa> and printf is a different beast: it is polyvariadic whereas (==) is binary always
10:08:25 <phobes> Making it polymorphic will make it ambigous since True == (True == True) -- What's the type of the expression in parens?
10:09:07 <paczesiowa> Bool:P
10:09:10 <phobes> The fact that explicit parenthesizing wouldnt' affect it is bad too
10:09:27 <phobes> Not Result Bool?
10:09:55 <phobes> 1 == (2==3) should be a type error
10:09:58 <ddarius> It's easy to write a (===) that can be chained together, but you'd need something to extract the result.
10:10:21 <phobes> ddarius: ya
10:11:01 <phobes> if allEq 1==2==3==4
10:11:17 <Taejo> phobes: that's easy
10:11:21 <paczesiowa> phobes: that's not the challenge!
10:11:22 <oerjan> allPairs (==) [1,2,3,4]
10:11:42 <awesame> okay, what the hell is up with "=>" looking like "->"
10:11:43 <awesame> ?
10:11:46 <phobes> well allEq is probably a bad name for it
10:11:48 <awesame> it drives me bonkers
10:11:53 <phobes> since it should also work for inequalities
10:11:56 <awesame> shouldn't it look more like "where"
10:11:56 <awesame> ?
10:12:21 <paczesiowa> we want to type something that python cannot ducktype
10:12:28 <phobes> if  eqChain  1 <<< 2 <<< 3 === 4
10:12:34 <oerjan> awesame: they are both inspired by the curry-howard isomorphism from logic, i think
10:12:48 <oerjan> so in some sense they both are an implication of sorts
10:12:52 <Lemmih> awesame: It should liike like "implies".
10:13:07 <awesame> as a beginner, I'm constantly reading expressions like "Monad a => (b -> c) -> a b -> a c" as if "=>" were doing something akin to "->"
10:13:33 <phobes> it sort of is
10:13:40 <oerjan> awesame: it actually does become an -> during an intermediate step
10:13:46 <awesame> crazy!
10:13:53 <awesame> perhaps it would help if I understood how
10:14:01 <oerjan> because the Monad information is passed as an extra dictionary parameter
10:14:04 <paczesiowa> awesame: classes are implemented as dictionaries and those dictionaries became arguments to those fuinctions
10:14:08 <BMeph> awesame: ...or why? :)
10:14:32 <faxathisia> @undo do a' <- newIORef a ; b' <- newIORef b ; f a' b'
10:14:32 <lambdabot> newIORef a >>= \ a' -> newIORef b >>= \ b' -> f a' b'
10:14:33 <awesame> I'm mentally reading that as "(b -> c) -> a b -> a c types-where a is-a Monad"
10:14:33 <wli> > let as :: [Integer] = 1 : (map (\(n, bs) -> sum $ zipWith (\k a -> (-1)^(n-k+1) * (n `choose` k) * 2^(k*(n - k)) * a) [0..n-1] bs) (zip [1..] . tail $ scanl (++) [] $ map (:[]) as)) ; n `choose` k | n < 0 = undefined | k < 0 || k > n = 0 | k == 0 = 1 | 2 * k > n = n `choose` (n - k) | otherwise = (n * ((n - 1) `choose` (k - 1))) `div` k in take 10 as
10:14:33 <lambdabot>  Parse error at "=" (column 21)
10:14:36 <olsner> ugh, don't let the C coders know we have vtables ;-)
10:14:46 <wli> > let as = 1 : (map (\(n, bs) -> sum $ zipWith (\k a -> (-1)^(n-k+1) * (n `choose` k) * 2^(k*(n - k)) * a) [0..n-1] bs) (zip [1..] . tail $ scanl (++) [] $ map (:[]) as)) ; n `choose` k | n < 0 = undefined | k < 0 || k > n = 0 | k == 0 = 1 | 2 * k > n = n `choose` (n - k) | otherwise = (n * ((n - 1) `choose` (k - 1))) `div` k in take 10 as
10:14:58 <faxathisia> You get cut off at 'as'
10:15:00 <lambdabot>  [1,1,3,25,543,29281,3781503,1138779265,783702329343,1213442454842881]
10:15:01 <byorgey> awesame: that's a good way to read it.
10:15:41 <paczesiowa> olsner: don't you mean c++ ?
10:16:48 <phobes> I think with more sugar around Monads maybe a syntax for type directed symbol lookup haskell could beat OOP at its own game
10:16:58 <awesame> paczesiowa: that was a helpful remark, and I think I understand why it's written that way now
10:17:10 <awesame> but I'm still not sure I think it's a good notation
10:17:44 <olsner> paczesiowa: yeah, don't tell them either ;-) as a C++ coder I rather like to think of type classes as templates though
10:17:47 <awesame> since from my point of view, it's not an argument to the function
10:18:10 <Saizan> dictionaries are not the only way to implement them
10:18:22 <phobes> olsner:  Not virtual methods?
10:18:55 <Schmallo1> I have a data type with several constructors and a Data.Set containing elements of this type.
10:19:01 <Schmallo1> How do I filter out those conforming to a given constructor?
10:19:14 <dcoutts> awesame: one reason for the => is that we can read types as predicates, forall m a. Monad m => m a  and we read "=>" as "such that"
10:19:18 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5467
10:19:24 <Schmallo1> like http://hpaste.org/5467
10:19:43 <Saizan> filter (\x -> case x of (Constr _ _) -> True; _ -> False)
10:20:08 <dcoutts> awesame: forall m a. Monad m => m a    -- meaning for all m and a, such that m is an instance of Monad, we have the type m a
10:20:36 <dcoutts> so the => separates the type from the constraints on the free type variables
10:20:55 <awesame> is that notation used in math somewhere I'm not thinking of?
10:21:19 <dcoutts> awesame: maths has various symbols for that kind of idea
10:21:22 <Schmallo1> Saizan: isn't there an simpler way?
10:22:01 <Saizan> Schmallo1: no, but i'd define predicates like isC1 (C1 _) = True; isC1 _ = False and use those
10:22:04 <dcoutts> awesame: depends on the particular part of maths as to what the notation is. This is just one, and it's changed to fit into ASCII notation.
10:22:17 <awesame> I understand using "->" as a promotion from "if a then b" to "given a yield b"
10:22:45 <paczesiowa> isn't -> standard math notation of functions?
10:23:05 <awesame> that too
10:23:09 <Schmallo1> Saizan: That's what Im doing right now. I felt I was making things too complicated
10:23:13 <wli> f : D \rightarrow R
10:23:14 <ibid> -> is standard math for function "types"; |-> for mappings
10:23:26 <wli> x \mapsto x^2
10:23:55 <awesame> right, that makes sense
10:23:56 <faxathisia> IORefs are hard to understand :/
10:24:11 <Codex_> f : D \to R
10:24:21 <phobes> faxathisia: let's go shopping?
10:24:21 <olsner> phobes: no, I definitely don't want dynamic dispatch of what can be determined at compile time... but perhaps I'm just fooling myself by thinking of typeclasses as a compile-time construct
10:24:37 <faxathisia> hehe
10:24:48 <paczesiowa> olsner: yes you are
10:24:53 <olsner> faxathisia: aren't they basically just pointers?
10:24:59 <olsner> meh, ok
10:25:19 <faxathisia> I hoped so.. It doesn't seem that way though
10:25:25 <kmcallister> olsner, that's a matter of partially applying dictionary arguments, which can be handled as part of a general partial application optimizer
10:26:57 <phobes> olsner:  in general arbitrary computation could be happening in type classes... like imagine an application that counts something using size typed vectors
10:27:34 <phobes> olsner:  There's not necessarily bounded number of typeclass instances
10:29:04 <olsner> as I understood it, there actually is a bounded number of typeclass instances unless you add UndecidableInstances or some other extension flag?
10:29:26 <phobes> That might be right
10:29:44 <olsner> templates are also (theoretically) capable of arbitrary computation
10:29:47 <paczesiowa> what does "class (Eq a) => .. "mean? every instance needs this constraint?
10:29:54 <Saizan> olsner: in most cases they are or could optimized away at compile time, exceptions being existentials for example
10:29:59 <oerjan> well you can use instances for all of a, [a], [[a]] etc. in one program without extensions
10:30:12 <phobes> olsner:  Right, but they can't respond to input
10:30:45 <oerjan> but all the [b]'s may be one instance declaration
10:31:00 <oerjan> paczesiowa: yep
10:31:11 <phobes> oerjan:  Obviously there are finitely many instance _declarations_
10:31:11 <dcoutts> Saizan: except probably for type class constraints used in polymorphic recursion
10:31:18 <olsner> hmm, but wouldn't the maximum depth of [a] instances be determined by e.g. the size of the source code?
10:31:39 <dcoutts> olsner: not with polymorphic recursion
10:32:07 <dcoutts> it may be necessary to build dictionaries at runtime
10:32:17 <dcoutts> using other dictionaries
10:32:27 <oerjan> e.g. data Tree a = Leaf a | Tree [a]
10:32:35 <dcoutts> and with polymorphic recursion it may be necessary to do that every iteration
10:32:47 <phobes> What is polymorphic recursion?
10:33:20 <oerjan> phobes: when a function is called recursively with a different type
10:33:34 <phobes> right ok
10:33:39 <paczesiowa> are there any useful examples?
10:33:49 <dcoutts> paczesiowa: finger trees
10:33:54 <Taejo> does | a -> b mean that for a given "a" there is only one "b" or the other way round?
10:34:00 <faxathisia> IORefs.... don't get update..
10:34:01 <earthy> or generic programming a la SYB
10:34:01 <faxathisia> :/
10:34:04 <kmcallister> Taejo, the former
10:34:05 <phobes> @go finger trees
10:34:07 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
10:34:08 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
10:34:08 <paczesiowa> Taejo: the former
10:35:08 <dcoutts> recursion over a finger tree data structure requires polymorphic recursion because of the way the data type is structured
10:35:21 <dcoutts> it's pretty cool :-)
10:35:25 <Taejo> I've got Input a b | a -> b; why do I get a fundep conflict with instances "Input (Maybe b) b" and "Input b b"?
10:35:41 <BMeph> Taejo: Right, it's usually read as saying "the typa of a uniquely determines the type of b"
10:35:49 <BMeph> s/typa/type/
10:35:56 <kmcallister> because the latter is a superset of the former
10:35:58 <phobes> Because Input (Maybe b) (Maybe b) follows from your second
10:36:01 <oerjan> Taejo: ghc is not smart enough to determine they don't overlap
10:36:10 <oerjan> oh wait
10:36:14 <sjanssen> oerjan: they do overlap
10:36:14 <Taejo> ack, right, they do overlap
10:36:17 <dcoutts> @src FingerTree
10:36:17 <lambdabot> Source not found. There are some things that I just don't know.
10:36:22 <sjanssen> b and (Maybe b') unify
10:36:27 <oerjan> misinterpreted
10:36:28 <Taejo> yeah
10:36:40 <Taejo> I'll define my own Maybe without an Ord instance
10:37:10 <oerjan> @go Data.FingerTree
10:37:11 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/docs/edison/Data-Edison-Concrete-FingerTree.html
10:38:07 * gwern begins yak-shaving with Haskore. I always enjoy recursive problems
10:38:09 <phobes> So did we say you do need extensions turned on to use polymorphic recursion or dont?
10:38:14 <oerjan> @source Data.Sequence
10:38:14 <lambdabot> Data.Sequence not available
10:38:31 <oerjan> phobes: you need explicit type declarations
10:38:36 <oerjan> but it's H98
10:38:44 <phobes> ok
10:39:17 <oerjan> (because of the typing issues we discussed a little while ago
10:40:15 <gwern> @where markov-chain
10:40:15 <lambdabot> I know nothing about markov-chain.
10:40:22 <phobes> Right, so you end up needing to build dictionaries in terms of dictionaries, but the dependencies as always a DAG
10:40:29 <dcoutts> data FingerTree = Empty | Single a | Deep Int (Digit a) (FingerTree (Node a)) (Digit a)
10:40:44 <dcoutts> the key feature is the FingerTree (Node a)
10:40:51 <dcoutts> in the Deep constructor
10:40:56 <gwern> bizarre! http://darcs.haskell.org/markov-chain/ <-- the darcs homepage, but no _darcs/?
10:40:57 <lambdabot> Title: Index of /markov-chain
10:41:31 <dcoutts> gwern: email the maintainer
10:42:19 <Taejo> ok, so even if I use MyMaybe (not an Ord instance) instead of Maybe, does GHC still not see there is no fundep conflict
10:42:20 <gwern> dcoutts: I guess. the entire chain of dependencies for haskore seems messed up though...
10:42:24 <phobes> I guess I'm not a functional programmer since lists aren't my favorite datatype
10:42:34 <lament> lists aren't particularly functional
10:42:37 <lament> functions are functional :)
10:42:52 <paczesiowa> we can represent lists as functions
10:43:04 <phobes> According to the finger trees paper:  Lists are a functional programmer's favorite datatype.
10:43:05 <oerjan> Taejo: class restrictions are only applied after instances have been selected
10:43:12 <dcoutts> phobes: they don't have to be your favourite data structure, so long as they are your favourite control structure :-)
10:43:12 <Taejo> ok
10:43:21 <Taejo> :)
10:43:47 <phobes> dcoutts:  I'm learning to love streams, is that good enough?
10:44:01 <dcoutts> phobes: streams as in lazy lists you mean?
10:44:14 <phobes> dcoutts:  without the memoizing
10:44:20 <dcoutts> ah, unfolds
10:44:28 <magnusjonsson> @src foldM
10:44:28 <lambdabot> foldM _ a []     = return a
10:44:29 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
10:46:10 <vvv> @help dummy
10:46:10 <lambdabot> dummy. Print a string constant
10:46:57 <vvv> @dummy "abc"
10:46:57 <lambdabot> dummy
10:47:23 <oerjan> that's pretty dummy
10:47:31 <vvv> i know
10:47:40 <oerjan> @read "abc"
10:47:40 <lambdabot>  abc
10:50:19 <vvv> oerjan: i'm just investigating, what is http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Dummy/DocAssocs.hs for...
10:50:20 <lambdabot> http://tinyurl.com/2nly5h
10:50:30 <vvv> @botsnack
10:50:30 <lambdabot> :)
10:55:17 <dons> ?users
10:55:17 <lambdabot> Maximum users seen in #haskell: 471, currently: 429 (91.1%), active: 23 (5.4%)
10:55:25 <oerjan> @list dummy
10:55:25 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
10:55:42 <oerjan> vvv: those other commands are also the same plugin
10:57:46 <oerjan> it's used in the lookupPackage function of http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Dummy.hs
10:58:34 <faxathisia> You know how you have to unnest everything for do notation?
10:58:49 <oerjan> docs, source and fptools use that again
10:59:09 <faxathisia> Is there a way to have everything nested but still have all subexpressions in a monad?
10:59:15 <vvv> oerjan: the situation is: DocAssocs.hs imports `Data.ByteString.Base'. There is no such thing in bytestring-0.9..
10:59:23 <BMeph> oerjan: Do you find it insulting that you're not smarter than Dummy? ;)
10:59:57 <dcoutts> vvv: change it to Data.ByteString.Unsafe
11:00:03 <BMeph> Belay that - s/oerjan/vvv/ ;)
11:00:19 <dons> vvv, the lambdabot repo is on code.haskell.org/lambdabot
11:00:25 <dons> you're using an out of date repo, i think
11:00:40 <doserj> faxathisia: what do you mean with "nested"?
11:00:56 <vvv> oerjan: ..having substituted s/Base/Internal/, i've got missing function definition (i don't remember exactly, since i'm not with my ghci at the moment)
11:01:08 <dons> vvv, are you using code.haskell.org/lambdabot?
11:02:08 <sjanssen> vvv: lambdabot has not been updated for GHC 6.8 yet
11:02:30 <sjanssen> I've heard Cale has patches, but he hasn't shared them with us yet :(
11:02:34 <dons> sure it has.
11:02:39 <dons> they're in code.haskell.org/lambdabot
11:02:44 * gwern wouldn't be too surprised if vvv got the old darcs address from dons's pages
11:02:48 <vvv> dons: i'll be 100% sure tomorrow
11:02:50 <dons> gwern, likely.
11:02:59 <dons> i'm looking for new hosting, fwiw.
11:03:12 <dcoutts> dons: what's wrong with code.h.o ?
11:03:23 <dons> oh, for my blogs/papers/web page
11:03:24 * vvv is something about 90% sure right now :)
11:03:25 <dons> not code.
11:03:31 <dcoutts> ah ok
11:03:32 <sjanssen> dons: are you sure?  The code.h.o doesn't even have ByteString in the build-depends
11:03:43 <dons> hmm. the cabal file might not be up to date
11:03:51 <oerjan> @version
11:03:51 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
11:03:52 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:04:21 <vvv> the same is here: http://code.haskell.org/lambdabot/Plugin/Dummy/DocAssocs.hs
11:04:23 <dcoutts> dons: we may well want to let people use community.h.o for hosting personal stuff, like blogs etc
11:04:34 <vvv> import qualified Data.ByteString.Base as P
11:05:00 <vvv> and no bytestring dependency in http://code.haskell.org/lambdabot/lambdabot.cabal
11:05:00 <sarah> hmmm i feel im doing something wrong.... if someFunc x == Nothing then Nothing else someotherFunc x
11:05:18 * dcoutts wonders what lambdabot has to import Data.ByteString.Internal stuff for
11:05:23 <dons> dcoutts: hehe
11:05:26 <dons> experiments
11:05:39 <dcoutts> dons: experiments?
11:06:04 <dons> well, lambdabot has been a playground for bytestring experiments (and other libs)
11:06:09 <dons> e.g. packAddress games
11:06:23 <oerjan> sarah: do someFunc x; someOtherFunc x
11:06:37 <oerjan> or someFunc x >> someOtherFunc x
11:06:44 <oerjan> (with the Maybe monad)
11:06:45 <sarah> ah thanks
11:06:49 <monochrom> Don't use ==.
11:07:25 <monochrom> > if (Just id) == Nothing then "bad" else "ok"
11:07:27 <lambdabot>   add an instance declaration for (Eq (a -> a))
11:07:27 <lambdabot>     In the predicate expressi...
11:07:36 <monochrom> Here is the solution.
11:07:40 <EvilTerran> isNothing
11:07:45 <EvilTerran> ?type isNothing
11:07:46 <lambdabot> forall a. Maybe a -> Bool
11:07:49 <EvilTerran> ?type (==Nothing)
11:07:50 <lambdabot> forall a. (Eq (Maybe a)) => Maybe a -> Bool
11:07:53 <dcoutts> dons: ah. Doesn't packAddress on string bytestring literals just work now due to rules?
11:07:53 <monochrom> > case Just id of { Nothing -> "bad"; Just _ -> "ok" }
11:07:55 <lambdabot>  "ok"
11:08:07 <magnusjonsson> How come hoogle can't find >>= given its type signature?
11:08:31 <EvilTerran> ?hoogle m a -> (a -> m b) -> m b
11:08:32 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
11:08:32 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
11:08:32 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
11:08:37 <EvilTerran> ?hoogle+
11:08:37 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
11:08:37 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
11:08:37 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
11:08:40 <EvilTerran> meh.
11:08:49 <dons> dcoutts: it does.
11:08:58 <sarah> oerjan: the someFunc has type Maybe Int, and someOtherFunc has type Maybe String
11:08:59 <dcoutts> good good
11:09:00 <dons> dcoutts: and i thought i'd updated lambdabot for all that
11:09:03 <sarah> so doenst quite work
11:09:06 <dons> at least, i confirmed it all worked now
11:09:22 <vvv> dons: right! Compiler mentioned `packAddress' in its error message...
11:09:33 <oerjan> magnusjonsson: hoogle has serious bugs with higher-kind type constructors
11:09:34 <dons> vvv, this has all  been patched somewhere
11:09:37 <dons> perhaps bug Cale
11:09:51 <EvilTerran> sarah, what type is x?
11:09:55 <magnusjonsson> oerjan: I guess I won't rely on hoogle anymore then
11:10:12 <vvv> it's nice to have a bunch of programmers playing with code, while i'm playing with my son. :)
11:10:17 <oerjan> sarah: sure it should
11:10:19 <sarah> the result is type Maybe String
11:10:30 <EvilTerran> oerjan, type mismatch
11:10:49 <vvv> i'll logout now; how can i do "what-did-i-miss" command in IRC?
11:10:55 <oerjan> sarah: well that is the result of your expression
11:10:58 <EvilTerran> oerjan, neither of 'em are functions ;)
11:11:06 <faxathisia> vvv, see the channel topic
11:11:07 <oerjan> it has to have one type
11:11:10 <sarah> oh wait sorry i forgot parens after >>
11:11:14 <magnusjonsson> I'm looking for generalizations of =<< to more than one argument, namely Monad m => (a -> b -> m c) -> m a -> m b -> m c
11:11:21 <sarah> (thought was like &&)
11:11:21 <sjanssen> @version
11:11:21 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
11:11:21 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:11:23 <vvv> faxathisia: right
11:11:38 <monochrom> @type ap
11:11:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:11:54 <sjanssen> @ask Cale can we please have your GHC 6.8 compatibility patches for lambdabot?
11:11:54 <monochrom> @type foldM
11:11:54 <lambdabot> Consider it noted.
11:11:54 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:12:39 <dons> i really thought these were in the repo. hmm
11:12:42 <EvilTerran> ?type \f a b -> f =<< a =<< b
11:12:42 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> m b) -> (a1 -> m a) -> m a1 -> m b
11:12:44 <dons> have to have a look later
11:12:51 <EvilTerran> ?type \f a b -> (f =<< a) =<< b
11:12:51 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a -> a1 -> m b) -> (a1 -> a) -> m a1 -> m b
11:12:58 <EvilTerran> er
11:13:21 <shachaf> @ty ((join .) .) . liftM2
11:13:22 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
11:13:42 <magnusjonsson> shachaf: that's hideous :)
11:13:42 <EvilTerran> ?type \f a b -> curry $ uncurry f =<< (a,b)
11:13:43 <lambdabot>     Couldn't match expected type `(a, b) -> c'
11:13:43 <lambdabot>            against inferred type `(t, b1)'
11:13:43 <lambdabot>     In the second argument of `($)', namely `(uncurry f) =<< (a, b)'
11:13:43 <monochrom> Yeah, I found out join and liftM2 too.
11:13:46 <oerjan> magnusjonsson: wasn't that what i showed earlier?
11:14:01 <oerjan> @pl \f a b -> join (liftM2 f a b)
11:14:01 <EvilTerran> ?type \f a b -> uncurry f =<< (a,b) -- even
11:14:02 <lambdabot> ((join .) .) . liftM2
11:14:02 <lambdabot> forall a b b1 t. (Monad ((,) t)) => (a -> b -> (t, b1)) -> t -> (a, b) -> (t, b1)
11:14:10 <shachaf> @ty \f m -> join . liftM2 f m
11:14:11 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
11:14:18 <EvilTerran> oh, sod it
11:14:26 <shachaf> @ty \f ma mb -> join (liftM2 f ma mb)
11:14:27 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
11:14:34 <magnusjonsson> oerjan: Yes, but I don't want to type join (liftM....) everywhere in my code. I really think this is a very common operation and I am surprised I can't find it in the standard lib
11:14:55 <EvilTerran> i haven't wanted to do it particularly often
11:15:06 <shachaf> magnusjonsson: Where have you wanted to do that?
11:15:33 * shachaf would guess that at one point, things would be simpler if you used >>=/do-notation explicitly.
11:15:57 <magnusjonsson> shachaf: it captures the pattern do vx <- x; vy <- y; f vx vy, and I think that pattern is very common
11:16:00 <monochrom> I don't find it very common.
11:16:09 <shachaf> I think join with liftAn is quite simple, and expresses what you want to do.
11:18:34 <magnusjonsson> But we have >>= and =<<, but not its generalizations to 2 and 3 arguments
11:19:08 <magnusjonsson> bind is a very fundamental operation so I think it makes more sense to generalize it than to rely on a combination of liftM and join
11:19:46 <shachaf> (>>=) is a combination of liftM and join. :-)
11:20:49 <oerjan> magnusjonsson: strangely nearly every defined monad operation beyond >>=, join and =<< is just Applicative operations restricted to monads...
11:21:03 <glen_quagmire> what's the difference between data and newtype?
11:21:22 <shachaf> oerjan: Sure, but not what magnusjonsson is asking for.
11:21:34 <magnusjonsson> liftM can be defined as (=<<) . return, and liftM2 as bind2 . return
11:21:35 <Deewiant> my strategy is "use newtype; if it doesn't compile use data"
11:21:39 * EvilTerran tried to work that one out in terms of applicative; definitely not happening.
11:22:11 <shachaf> EvilTerran: Of course not; it's just (>>=) for more arguments.
11:24:01 <magnusjonsson> either way I can define my own combinators
11:25:49 <proq> I'm starting on the haskell tutorial at http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/firststeps.html
11:25:50 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/uto4h
11:25:58 <proq> when I run the first example, I get "a.out: Prelude.(!!): index too large"
11:26:12 <proq> can't find relevant info on this in google. what exactly is this problem?
11:26:35 <monochrom> > ['x','z','y'] !! 3
11:26:37 <lambdabot>  Exception: Prelude.(!!): index too large
11:26:43 <monochrom> Like that.
11:27:24 <proq> > "Hello, " ++ args !! 0
11:27:25 <lambdabot>   Not in scope: `args'
11:27:52 <monochrom> Use an actual string in place of args.
11:28:02 <oerjan> !! binds very tightly
11:28:09 <monochrom> > "Hello, " ++ [] !! 0
11:28:10 <byorgey> should be a list of strings.
11:28:10 <lambdabot>  Exception: Prelude.(!!): index too large
11:28:10 <twanvl> ?ty let f <<*> g = join (f <*> g); infixl 4 <<*> in   ?f <$> ?x <*> ?x <*> ?x <<*> ?x
11:28:11 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Applicative m, ?x::m a, ?f::a -> a -> a -> a -> m a1) => m a1
11:28:34 <monochrom> Yeah, looks like it reads as "Hello, " ++ ([] !! 0)
11:28:36 <proq> oh, I see.
11:28:40 <byorgey> proq: if you are doing   args <- getArgs  and then using !! to index into args, you would get that 'index too large' error if you don't actually pass any arguments to the program.
11:29:42 * EvilTerran wonders why not do [name] <- getArgs; putStrLn ("Hello, " ++ name)
11:29:45 <EvilTerran> or somesuch
11:30:03 <monochrom> "a.out x y" and "a.out" will ruin that.
11:30:05 <EvilTerran> do name:_ <- getArgs; ... if you want to retain the old behaviour
11:30:10 <proq> the author is assuming someone wouldn't naturally feel inclined to compile his code and run it  :|
11:30:20 <byorgey> EvilTerran: hey, that's a great idea!
11:30:28 <desegnis> proq, to length the discussion: (!!) is a partial function; it fails on certain input. In a Â»realÂ« program, you try to avoid partial functions, and handle etch cases seperately instead of letting the program crash
11:30:39 <EvilTerran> monochrom, the latter won't ruin that any more than it ruins the existing one
11:31:05 <monochrom> Godammit
11:31:55 <paczesiowa> ghc should have smth like Catch implemented to warn about missuse of head/tail/!!
11:32:26 <monochrom> On unexecutable code in lessons, I don't think well-accepted ones are any worse. K&R contains lots of incomplete uncompilable unexecutable fragments too.
11:37:30 <awesame> I think I tend to use parens more than is idiomatic in haskell
11:37:49 <awesame> how would you folks write "show (read (s!!1) - 1)"?
11:38:03 <awesame> er
11:38:11 <awesame> "show ((read (s!!1)) - 1)"?
11:38:19 <oerjan> show $ read (s!!1) - 1
11:38:20 <dons> hmm
11:38:20 <Deewiant> @pl \s -> show ((read (s!!1)) - 1)
11:38:20 <lambdabot> show . subtract 1 . read . (!! 1)
11:38:27 <monochrom> show (read (s!!1) - 1)  hits it.
11:38:56 <monochrom> I randomly choose between show (read (s!!1) - 1) and show . subtract 1 . read . (!! 1)
11:39:11 <paczesiowa> :t subtract
11:39:12 <lambdabot> forall a. (Num a) => a -> a -> a
11:39:12 <oerjan> might use pred
11:39:44 <monochrom> subtract is there because (- 1) doesn't mean what you think it means. :)
11:40:00 <awesame> really?
11:40:37 <kpreid> let liftR f = show . f . read in liftR (subtract 1) (s !! 1)
11:40:39 <paczesiowa> I know, but didn't know subtract, I always defined myself sub
11:40:41 <monochrom> If you have looked at (* 1), (++ "true"), etc., what would you think (- 1) means?
11:40:45 <awesame> :t (- 1)
11:40:47 <lambdabot> forall a. (Num a) => a
11:41:01 <paczesiowa> :t -(1)
11:41:02 <lambdabot> forall a. (Num a) => a
11:41:08 <awesame> I'd think it means decrement
11:41:27 <monochrom> Now if you want to express "negative 1" and put it inside parentheses, what would you write?
11:41:52 <awesame> > (- 1) 5
11:41:53 <lambdabot>   add an instance declaration for (Num (t -> a))
11:41:53 <lambdabot>     In the expression: (- 1)...
11:42:07 <awesame> (-1)
11:42:16 <Twey> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot -- apparently I don't have a Network package?
11:42:17 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
11:42:20 <awesame> oh, there I go reading => wrong again
11:42:40 <monochrom> So (- 1) is ambiguous. They decided to go "negative 1 inside parentheses" rather than "subtract 1".
11:42:45 <Twey> I'm running GHC 6.8.2
11:42:51 <awesame> > (subtract 1) 5
11:42:52 <Deewiant> Ã would expect that (-1) and (- 1) are two different things
11:42:53 <lambdabot>  4
11:42:58 <paczesiowa> Twey: what os?
11:43:06 <Deewiant> and did expect, but was proven wrong
11:43:39 <Twey> paczesiowa, Linux -- Gentoo
11:44:22 <Deewiant> Twey: it's probably in portage
11:44:49 <paczesiowa> Twey: emerge dev-haskell/network
11:45:00 <Twey> Ah, there it is -- thanks
11:45:25 <paczesiowa> Twey: portage has the same version as overlay so you don't need to play with layman
11:46:10 <Twey> There's a Haskell overlay?
11:46:19 <paczesiowa> yes
11:46:23 <paczesiowa> layman -a overlay
11:46:32 <Twey> Ooh.  Thanks.
11:46:42 <Twey> It's just called overlay?  Heh.
11:46:42 <paczesiowa> and join #gentoo-haskell
11:46:54 <paczesiowa> layman -a haskell
11:46:54 <paczesiowa> sry
11:46:59 <EvilTerran> > (- 1)
11:47:00 <lambdabot>  -1
11:47:19 <EvilTerran> Deewiant, for that one, you use (-1+), (subtract 1), or pred
11:47:33 <EvilTerran> ?type pred -- beware, different type, but it usually does the same job
11:47:35 <lambdabot> forall a. (Enum a) => a -> a
11:47:56 <Deewiant> I know, but like said, I'd expect that "-1" is treated by the compiler as an integer
11:48:07 <Deewiant> whereas - 1 is treated as subtract 1
11:49:59 <EvilTerran> i agree, but you'll have to get through Cale if you want that one to change, and he's vicious
11:50:13 <EvilTerran> ;)
11:50:17 <Deewiant> :-)
11:50:31 <awesame> hm, "show ((read (s!!1)) - 1)" complains about having to guess that I want an Int result from read
11:50:52 <Deewiant> I guess it's too late to change something like that, would break too much code
11:50:54 <awesame> I know how to fix that with a where clause and a function with a type decl
11:51:05 <awesame> is there a shorter way?
11:51:09 <EvilTerran> > show (read "12" - 1 :: Int)
11:51:09 <paczesiowa> famous show.read problem
11:51:11 <Deewiant> awesame: you can annotate types in expressions like foo (bar :: Int)
11:51:16 <lambdabot>  "11"
11:51:25 <EvilTerran> :: is lower precedence than any normal infix operator
11:51:25 <awesame> ah, neat
11:51:28 <monochrom> "-1" vs "- 1" is giving way too much significance to whitespace.
11:51:46 <monochrom> next-to-impossible to write a lexer for that.
11:51:49 <EvilTerran> "foobar" vs "foo bar" is giving way too much significance to whitespace.
11:51:53 <EvilTerran> :P
11:52:02 <Deewiant> exactly. :-P
11:52:14 <awesame> ITYM e x a c t l y
11:52:16 <Deewiant> And hardly impossible, either. if "-" is followed by a number it's a number, otherwise it's not. :-P
11:52:19 <monochrom> OK, write a lexer in Alex to do that.
11:52:48 <Deewiant> Bah, lexer generators. Humbug!
11:53:38 <awesame> I assure you that lexer generators do exist
11:53:55 <EvilTerran> monochrom, seeing as you seem to anticipate a specific problem, why don't you just tell us what it is?
11:54:09 <gwern> @where fps
11:54:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
11:54:17 <gwern> anyone know what 'fps' as a dpendency means?
11:54:34 <doserj> that you are using old code
11:54:40 <gwern> oh. weird. how do you get bytestring from fps?
11:54:51 <monochrom> I have said my problem and opined it is too hard and not worthwhile. You can falsify me by giving an easy solution. I don't care.
11:54:55 * gwern chuckles appreciatively
11:55:01 <Deewiant> Alex appears to use regex? number := "-?[0-9]+"
11:55:43 <EvilTerran> and oper := [-+!$%^...]+
11:55:45 <EvilTerran> no overlap
11:55:49 <nominolo> @seen dons
11:55:49 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 17m 28s ago.
11:55:53 <Deewiant> EvilTerran: exactly.
11:55:54 <nominolo> @seen SyntaxNinja
11:55:56 <lambdabot> SyntaxNinja is in #haskell. I don't know when SyntaxNinja last spoke.
11:57:00 <EvilTerran> monochrom, falsified yet? or are you going to want a diff to the alex source from ghc before you're happy?
11:57:19 <vvv> gwern: "how do you get..." By googling. :)
11:57:38 <monochrom> > 1-1
11:57:45 <dcoutts> gwern: or see the fps page and see how it's been renamed to bytestring
11:57:46 <vvv> gwern: i thought it was first person shooter :)
11:57:50 <EvilTerran> is 1 applied to -1.
11:57:53 <lambdabot>  thread killed
11:58:04 <EvilTerran> so?
11:58:28 <gwern> vvv: yeah, most of the hits for 'haskell fps' are for frag :)
11:58:37 <monochrom> Don't you think "1-1" not standing for "one minus one" stretching it too far?
11:58:39 <EvilTerran> a consequence of this would be that you'd need a space between a minus operator and following numeric constant
11:58:49 <EvilTerran> not particularly, i always put spaces around my operators
11:58:52 <Deewiant> I think it matters less that if you're doing math completely with literals you need a space
11:59:19 <Deewiant> than that "- 1" stands for negative one
11:59:20 <monochrom> You should take a poll over more people.
11:59:30 <Deewiant> I don't care that much :-)
11:59:34 <dcoutts> why don't we generalise and allow user defined prefix and postfix operators?
11:59:40 * gwern thinks requiring spaces between infix operators is an excellent idea
12:00:00 * wli would like ! as a postfix operator.
12:00:23 <EvilTerran> ?type \x -> (x!)
12:00:25 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
12:00:31 <EvilTerran> there's your postfix operators
12:00:40 <EvilTerran> ?type \x -> (!) x -- and here's prefix :P
12:00:41 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
12:00:56 <SyntaxNinja> hi nominolo
12:00:58 <dolio> > let (!) 0 = 1 ; (!) n = n * ((n-1)!) in (5!) -- close but no cigar
12:00:58 <lambdabot>  120
12:01:23 <monochrom> @seen dons
12:01:23 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 23m 3s ago.
12:01:39 <wli> The lexical distinctions can go, too, albeit with some changes to the parsing algorithm.
12:01:44 <monochrom> dons: lambdabot is starving again.
12:01:52 <nominolo> SyntaxNinja: hia
12:02:21 <monochrom> dons: err maybe, maybe not. one case of "thread killed" but not often yet.
12:02:22 <SyntaxNinja> nominolo: just heading out, but I'll be back in an hour or so.
12:02:31 <nominolo> SyntaxNinja: k
12:02:31 <Deewiant> Another way to solve the lexing would be to have "- " and "-" be lexed differently and then solve it in parsing
12:02:48 <EvilTerran> or, use a different symbol for one of 'em
12:02:50 <Deewiant> Which could then make "1-1" work as expected, also.
12:03:01 <Deewiant> -- is already reserved :-P
12:03:35 <EvilTerran> Â¬ isn't. ~ isn't either, in expressions
12:03:36 <gwern> http://hackage.haskell.org/packages/archive/functorm/1.0.1/doc/html/ <-- why was Data.FunctorM removed?
12:03:38 <lambdabot> http://tinyurl.com/2mdke4
12:03:52 <Deewiant> Â¬ isn't on my keyboard, and ~ is hard to type
12:04:01 <EvilTerran> altho ~ would have to be subtraction rather than minus, otherwise it'd interfere with the existing meaning of ~ in patterns
12:04:11 <Deewiant> what about n+k patterns?
12:04:18 <Deewiant> would it interfere there?
12:04:24 <EvilTerran> who cares :P
12:04:26 <Deewiant> :-D
12:04:41 <dcoutts> Lots of calculators use a different symbol for unary negation from infix binary subtraction
12:04:56 * wli advises against attempting to defy preexisting conventions.
12:04:58 <EvilTerran> if i'm changing haskell however i want, i'll be getting rid of n+k
12:05:07 <Deewiant> Yep, but +- is fugly
12:05:16 <Deewiant> I have to admit I have yet to see a good use for n+k
12:05:39 <dolio> I don't think ~ is available.
12:05:54 <Deewiant> Â§ then
12:06:01 <CosmicRay> any happs folks around?
12:06:02 <Deewiant> or Â¤
12:06:05 <EvilTerran> dolio, as i said, it means something in patterns, and with type families it means something in types, but it's free in expressions AFAICT
12:07:01 <wli> People will barf on it because it's different from how those things are written.
12:07:09 <dolio> Well, it doesn't parse currently.
12:07:31 * EvilTerran ponders a typeclass-involving hack whereby (foo-bar) could get resolved as foo (-bar) or (-) foo bar at the typechecking stage
12:07:55 <dolio> a ~ b is parsed like a (~b)
12:08:05 <EvilTerran> dolio, indeed, it's a reservedop at the moment, i believe
12:08:21 <Deewiant> > let (~) = (+) in 1 ~ 2
12:08:22 <lambdabot>  Parse error at ")" (column 7)
12:08:56 <wli> This is all fantasy anyway. Is anyone suggesting this actually able to hack on any of the compilers?
12:09:12 <Deewiant> It probably could be done, but I don't see the use
12:09:19 <dolio> That'd be a pretty hairy bug, too. 'a ~ b = ...' defining (~), and 'a ~b = ...' defining a with irrefutable b.
12:09:25 <EvilTerran> wli, oh, but whinging is so much more fun
12:09:38 <wli> whinging?
12:09:40 <monochrom> #haskell-fantasy
12:09:44 <EvilTerran> dolio, yeah, i guess you're right, ~ isn't really suitable
12:11:13 <EvilTerran> wli, "whinge", v; to complain incessantly
12:11:30 <Deewiant> British and Australian Informal.
12:11:32 <dolio> I'd be up for more unicode, though, if I could find a decent way of inputting it.
12:12:04 * wli strongly suggests designing languages around written conventions and parsers around that rather than the reverse.
12:13:56 <monochrom> Seems like whine and whinge came from same origin.
12:14:12 <EvilTerran> i consider consistency to be a higher goal than doing what someone who hasn't used the tool much expects
12:14:30 <EvilTerran> achieving either is pretty hard, mind
12:14:47 <lament> good design should be the goal :)
12:15:25 <EvilTerran> unfortunately, that's a little difficult to quantify
12:15:42 <wli> There is no consensus as to what consistency is, what people expect is, or what good design is.
12:16:09 <EvilTerran> indeed. i'd say the first two are a *little* more quantifiable than the last, though
12:16:10 <monochrom> Hoare is still alive and he could be the definitive judge for good designs. :)
12:17:13 <lament> it's hard to judge good design, yet people usually know bad design when they see it :)
12:17:59 <dylan> I don't think everyone expects the same things. :)
12:18:38 <byorgey> dcoutts: ping
12:18:41 <BMeph> monochrom: Too bad that isn't to say that Tony Hoare IS a n example of a good design...  ;)
12:18:44 <dcoutts> byorgey: pong
12:19:09 <byorgey> dcoutts: what might cause Cabal to stop with the error, "package X can't be built on this system"?
12:19:39 <dcoutts> byorgey: if the library and all the executables have buildable: False
12:20:08 <byorgey> dcoutts: is that the only possible reason?
12:20:08 <dcoutts> byorgey: in practise it probably means you're building yi and you do not have coca, gtk or vty installed.
12:20:17 <byorgey> dcoutts: ah, hehe, ok =)
12:20:44 <monochrom> @bots
12:20:44 <lambdabot> :)
12:20:56 <dcoutts> byorgey: you'll notice in the yi.cabal it checks if none of those flags are enabled and if so explicitly makes the package not buildable
12:21:19 <dcoutts> byorgey: it might be sensible for sanityCheckPackage to warn after configure if the package is not buildable.
12:21:24 <byorgey> dcoutts: got it.  that's a decidedly unhelpful error message in this instance.
12:21:36 <byorgey> dcoutts: but that's obviously not Cabal's fault.
12:21:52 <jyp> I beg to disagree :p
12:21:53 <gwern> @hoogle runInteractiveProcess
12:21:56 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
12:22:15 <monochrom> I beg to eat.
12:22:27 <dcoutts> byorgey, jyp: the difficulty for yi is that there's no obvious way for it to specify that it depends on at least one of gtk, vty or coca
12:22:57 <jyp> dcoutts: isn't that exactly specified by the buildable flag?
12:23:19 <byorgey> oh, I see.  it would be nice if Cabal had a way to specify that sort of dependency.
12:23:28 <byorgey> dcoutts: how difficult do you think it would be to add that?
12:23:33 <dcoutts> jyp: well, it's not really what buildable was designed for, it's not taken into account in finalising a package
12:23:36 <EvilTerran> it's not generally that useful
12:23:50 <EvilTerran> you usually need all of a set of dependencies rather than any
12:23:52 <gwern> :t System.Process.runInteractiveProcess
12:24:06 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, System.Process.Internals.ProcessHandle)
12:24:07 <EvilTerran> gwern, it says in the @hoogle result, there
12:24:10 <dcoutts> byorgey: it can be done in an asymmetric fashion by designating one of them as the default
12:24:33 <gwern> EvilTerran: so it does
12:24:38 <EvilTerran> :)
12:24:57 <awesame> is there a Maybe version of !!?
12:24:57 <dcoutts> byorgey: eg depending on vty, unless the gtk or coca frontend is selected instead. Though I think yi can build all the frontends at once.
12:25:23 * EvilTerran often prefers ?hoogle to ?type when he's not sure if \b will have a function imported
12:25:27 <awesame> I'd like to index an array that might be shorter than I expect
12:25:39 <EvilTerran> array's aren't indexed by !!
12:25:42 <jyp> dcoutts: would it be hard to convert the Buildable: into a sensible user message?
12:25:44 <EvilTerran> er, arrays
12:25:48 <awesame> sorry, list
12:25:48 <dcoutts> jyp: how do you think buildable should be used in resolving a package configuration?
12:26:14 <EvilTerran> (listToMaybe . drop n) would do
12:26:37 <dcoutts> jyp: we can make it fail that configuration, but I'm not sure if that'd improve the error messages
12:26:40 <Lemmih> awesame: You rarely wanna use !!.
12:26:51 <EvilTerran> (take 1 . drop n) would give you either a singleton list or an empty list depending on whether it overran
12:27:01 <EvilTerran> Lemmih, he clearly knows that, seeing as he's asking for an alternative
12:27:20 <dcoutts> @type \n -> (Maybe.listToMaybe . drop n)
12:27:24 <EvilTerran> ?hoogle listToMaybe
12:27:27 <lambdabot> forall a. Int -> [a] -> Maybe a
12:27:27 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
12:27:31 <Vusal1981> hi there
12:27:39 <Lemmih> EvilTerran: Same arguments go for (listToMaybe . drop n).
12:27:51 <EvilTerran> Lemmih, er, what?
12:27:53 <jyp> dcoutts: how about just converting the boolean expression into a user-friendly string?
12:28:01 <EvilTerran> > listToMaybe . drop 10 $ "abc"
12:28:02 <dcoutts> jyp: like what?
12:28:04 <lambdabot>  Nothing
12:28:21 <dcoutts> jyp: we can certainly give an error on configuration rather than build
12:28:42 <jyp> dcoutts: instead of just "not buildable"; "not buildable because neither gtk, vty, cocoa flag set"
12:29:00 <dcoutts> jyp: discovering the reason is pretty tricky
12:29:03 <jyp> dcoutts: yep, configuration-time would help a lot
12:29:08 <awesame> is listToMaybe pulling the first element out of the dropped list?
12:29:16 <Lemmih> EvilTerran: If you're using a list like an array, you're probably using the wrong data structure.
12:29:37 <EvilTerran> Lemmih, oh, i see. the only argument i was thinking of was !! not being total
12:29:40 <EvilTerran> ?src listToMaybe
12:29:41 <lambdabot> listToMaybe []        =  Nothing
12:29:41 <lambdabot> listToMaybe (a:_)     =  Just a
12:29:51 <EvilTerran> awesame, does that answer your question? :)
12:29:53 <Deewiant> > let l !!! n = case drop n l of [] -> Nothing; x -> Just (head x) in ["abc" !!! 1, "abc" !!! 10]
12:29:53 <lambdabot>  [Just 'b',Nothing]
12:30:05 <dcoutts> jyp: but perhaps the right thing to do is to make buildable: false fail that particular configuration, it'd mean we'd probably end up complaining that the build-depends of the first listed front end was missing
12:30:09 <awesame> heh, yes
12:30:19 <EvilTerran> Deewiant, you could make that second case "x:_ -> Just x"
12:30:20 <Deewiant> EvilTerran: darn, I could have sworn it didn't :-P
12:30:37 <Deewiant> EvilTerran: why? does it matter?
12:30:43 <dcoutts> jyp: though a more sophisticated error message would list multiple ways to allow the package to be built, which would correspond to the three optional frontends
12:30:44 <Deewiant> oh, right.
12:30:46 <EvilTerran> it's neater
12:30:48 <Deewiant> *headslap*
12:30:54 <dcoutts> nominolo: opinions?
12:30:56 <Deewiant> true, not using head is neater
12:31:10 <Deewiant> but using listToMaybe is even neater, given that it returns the head and not the whole list
12:31:13 <EvilTerran> it saves a function call, yeah. it also makes the cases disjoint, which is a nice property to have for reasoning about the program
12:31:42 <jyp> dcoutts: maybe instead of just accepting buildable [true|false], accept a full boolean expression
12:31:51 <jyp> the rest is just pretty-printing
12:32:03 <u_quark> from a triplet (a, b, c) how can i get a or b or c ?
12:32:15 <EvilTerran> > let (a,_,_) = (1,2,3) in a
12:32:19 <lambdabot>  1
12:32:20 <dcoutts> jyp: that'd certainly be possible, but that'd not help with printing the reason for failure
12:32:22 <nominolo> dcoutts: tricky
12:32:30 <jyp> eg. buildable: flag(vty) || flag (gtk) || flag(cocoa)
12:32:32 * gwern gives up on Haskore. it's just too old and broken
12:32:39 <EvilTerran> > let foo (_,b,_) = b in foo ("eh", "bee", "sea")
12:32:40 <lambdabot>  "bee"
12:32:45 <u_quark> a function like fst or snd ?
12:32:49 <BMeph> u_quark: The quick answer is "pattern matching".
12:32:52 <paczesiowa> can I create a class of all types from another class but one?
12:33:05 <jyp> to make this package buildable, use -fvty OR -fgtk OR -fcocoa
12:33:08 <dcoutts> nominolo: oh, I don't mean listing the multiple ways of recovery, I mean using buildable: false to fail a configuration choice
12:33:08 <Deewiant> there should be a standard Data.Tuple or something which defines fst3, fst4, etc up to 8 or so
12:33:10 <EvilTerran> u_quark, there's nothing in the standard library for that, but you can make your own using pattern-matching
12:33:17 * nominolo just watched the catsters video on adjunctions (1)
12:33:18 <u_quark> ok tnx
12:33:34 <EvilTerran> Deewiant, even better, you could do something with typeclasses
12:33:50 <nominolo> dcoutts: i think that's the intended use
12:33:53 <EvilTerran> well, MPTCs... never mind. :P
12:33:57 <Deewiant> :-D
12:34:13 <nominolo> dcoutts: well, the original use was, so scripts could insert this
12:34:21 <EvilTerran> paczesiowa, not really... you can probably do something unpleasant with overlapping instances
12:34:26 <nominolo> dcoutts: and thus fail the build
12:34:30 <paolino> is it real that haddock stop parsing meeting a newtype ?
12:34:36 <dcoutts> nominolo: right, lets file a bug then, it should be easy to implement. And while we're at it we can allow bool expressions for buildable: not just True/False.
12:34:47 <nominolo> dcoutts: which, without an error message, is questionable behaviour by itself
12:34:57 <dcoutts> nominolo: hmm?
12:35:12 <nominolo> setting buildable
12:35:53 <dcoutts> nominolo: oh you mean that "build-depends: foobar" at least generates a message about missing foobar
12:36:11 <dcoutts> and that buildable: false has no similar message to aid recovery
12:36:47 <nominolo> yep, or really it's just an awkward way of saying, "oops, something didn't work out"
12:37:05 <dcoutts> nominolo: I guess the expressions that guard the field are the reason
12:37:12 <nominolo> i'd rather prefer an "error: msg" pseudo-field
12:37:25 <dcoutts> if expr; buildable: false
12:37:38 <dcoutts> so the message is "$expr is not true" :-)
12:37:46 <dcoutts> erm, is true
12:38:30 <nominolo> so "buildable: false" is just our notion of "die" in perl?
12:38:35 <dcoutts> if there are mutliple nested configurations then it's the && conjunction of the expressions
12:38:49 <dcoutts> nominolo: it's fail in the list/logic monad
12:39:08 <nominolo> yeah, but it's "fail undefined" ;)
12:39:15 <nominolo> not "fail my-message"
12:39:15 <dcoutts> fail ""
12:39:22 <pythonist> is there a serialization lib able to encode/decode closures?
12:39:34 <dcoutts> nominolo: though like I say, the guarding expressions are a kind of reason
12:39:39 <nominolo> > fail "argh" :: Maybe ()
12:39:40 <lambdabot>  Nothing
12:39:51 <nominolo> dcoutts: yep, they are
12:40:21 <dcoutts> nominolo: so we could invert the condition, simplify and pretty print it
12:40:35 <nominolo> though maybe giving a cabal-programmers the opportunity to give a better error description might be nicer
12:40:47 <dcoutts> nominolo: perhaps
12:40:56 <nominolo> also, Cabal-3.0 = prolog
12:41:06 <nominolo> Cabal-4.0 = Prolog + CHR
12:41:14 <dcoutts> cabal-1.2 is already prolog :-)
12:41:17 <nominolo> Cabal-5.0 = Oz
12:41:22 <dcoutts> heh heh
12:41:22 <sarehu> > fail "argh" :: Maybe a
12:41:23 <lambdabot>  Nothing
12:41:35 <dolio> Which version is Mercury?
12:41:44 <nominolo> i don't know mercury
12:41:50 <Saizan> dcoutts: saying "<long disjunction> is true" is not veyr informative
12:42:27 <paczesiowa> cabal-6.0. No
12:42:46 <nominolo> dcoutts: so how about a special "error: msg" field?
12:43:05 <dcoutts> nominolo: meaning buildable: False
12:43:27 <dcoutts> if os(win32); error: doesn't work on windows
12:43:39 <nominolo> yes, something like this
12:43:51 <BMeph> > fail "pregnancy test" :: Maybe a
12:43:52 <lambdabot>  Nothing
12:43:53 <nominolo> and it implies buildable: False
12:43:58 <dcoutts> nominolo: right
12:44:16 <nominolo> seems more user-friendly to me
12:44:32 <dcoutts> aye, true, though rather less automatic
12:45:20 <dcoutts> Saizan: "flag(vty) || flag (gtk) || flag(cocoa)" could be presented in a fairly sensible way if we tried
12:45:21 <nominolo> if impl ( ghc > 9 ): error: You're not smart enough to use this.
12:46:03 <nominolo> btw, did you rename "impl" ?
12:46:44 <newsham> ?tell conal http://video.google.com/googleplayer.swf?docId=-7171501518308861626
12:46:44 <lambdabot> Consider it noted.
12:46:48 <dcoutts> nominolo: no
12:47:06 <monochrom> I found out that #haskell population reached 400 just last August.
12:47:09 <dcoutts> nominolo: what did we decide was a better alias?
12:47:58 <dcoutts> nominolo: it's possible that we can produce a better error message than a static programmer defined one
12:48:45 <dcoutts> nominolo: for example with "flag(vty) || flag (gtk) || flag(cocoa)" we can say why those flags are false
12:49:28 <nominolo> dcoutts: you suggested "implementation"
12:50:12 <nominolo> dcoutts: yes, it's easy to just invert conditions, we have the functionality
12:50:55 <nominolo> dcoutts: but we'd still have to specially detect where "buildable" is set to false.  So adding support for a special error field would be just as easy
12:51:02 <nominolo> or just slightly more work
12:51:29 <dcoutts> nominolo: yes, but it also means no new user visible feature
12:51:41 <dcoutts> when we're not sure we really understand all the implications yet
12:51:43 <nominolo> dcoutts: the current mechanism actually succeeds in the flag assignmet
12:52:00 <nominolo> but only later realizes, d'oh can't really be built
12:52:01 <dcoutts> nominolo: I know. that's the first thing to fix, then the error message.
12:52:08 <haluk> hi folks, I got an this error during configure "configure: error: GHC is required unless bootstrapping from .hc files". Can you help me plz?
12:52:19 <dcoutts> haluk: get a binary instead
12:52:23 <nominolo> dcoutts: ok.  that's a compromise
12:53:05 <dcoutts> nominolo: I've got some other cabal tasks for you, want me to assign the tickets? ;-)
12:53:23 <nominolo> sure.  no promises, though
12:53:26 <dcoutts> :-)
12:53:33 <nominolo> need to get my thesis code to work
12:53:38 <dcoutts> of course
12:53:44 <nominolo> i want to start writing rather soonish
12:53:52 <dcoutts> it's the package() predicate and the new version dependency syntax
12:54:08 <nominolo> yeah, sure
12:54:25 <dcoutts> I might have a go at the buildable: false one
12:54:36 <dcoutts> otherwise I'll make a ticket
12:54:41 <goalieca> > 1E-6
12:54:42 <lambdabot>  1.0e-6
12:54:47 <nominolo> dcoutts: try adding it as a constraint
12:55:09 <nominolo> dcoutts: and see what the messages look like
12:55:20 <dcoutts> nominolo: it should be just like build-depends: foobar where that is not available
12:55:27 <nominolo> exactly
12:55:30 <dcoutts> though with a different error message
12:56:13 <haluk> dcoutts,  actually my problem is on yi installation. I'm ubuntu user and firstly i installed ghc6 with package manager but i got an error "regex-compat" dependency error. So then I'm trying to apply http://nobugs.org/developer/yi/building.html this site tutorial step by step
12:56:14 <lambdabot> Title: Building Yi
12:57:21 <dcoutts> haluk: and so you want ghc-6.8.2. So you can grab the generic ghc binary package, not the deb package. There is a generic linux x86 binary installer on the ghc-6.8.2 download page
12:57:48 <litb> hello again
12:58:07 <byorgey> hi litb
12:58:26 <paczesiowa> and so much for ubuntu as "operating system for the average user"
12:58:35 <haluk> dcoutts, does it consist extra-libs?
12:58:55 <dcoutts> haluk: note sure, but you can get those later as necessary
12:59:05 <dcoutts> note/not
12:59:17 <paczesiowa> isn't there haskell repository for ubuntu?
12:59:59 <zooko> haluk: which version of Ubuntu are you using?
13:00:06 <haluk> Does anybody know when will yi deb package release?
13:00:12 <haluk> zooko, hardy
13:00:34 <zooko> Ah, a pre-release.  paczesiowa: it's worth noting that this is a not-yet-released version of Ubuntu.
13:02:16 <paczesiowa> so packages for older versions stopped working?
13:02:47 <awesame> is it possible to define a type in Hugs?
13:03:00 <awesame> like, data Foo = Bar String | Baz Int
13:03:28 <zooko> paczesiowa: I think there is a bug in the ghc regex package in Hardy (the unstable pre-release).
13:04:01 <paczesiowa> go file a bug to ubuntu mainainers of haskell packages
13:04:28 <paczesiowa> probably they are hiding here in shame:>
13:04:52 <haluk> paczesiowa, i send bug report to launchpad about ghc6
13:05:13 <byorgey> awesame: not at the prompt, no
13:05:25 <byorgey> awesame: note this is not possible at a ghci prompt either
13:05:35 <litb> anyone ever coded reversi with haskell?
13:05:38 <awesame> so, do it in a file, and import?
13:05:50 <paczesiowa> awesame: yes
13:05:59 <awesame> litb: nope
13:06:18 <nominolo> haluk: most likely never
13:06:32 <nominolo> haluk: at least not for yi-0.3
13:06:50 <litb> awesame: :/
13:06:56 <haluk> nominolo, i tried on 0.4
13:07:26 <nominolo> haluk: you mean the darcs version?
13:07:43 <haluk> nominolo, yep
13:09:28 <nominolo> yi is still under heavy development and i know no developer who uses it regularly, so it's not ready for a packaged version.  but the progress is quite remarkable.  Ignoring bugs, we're already better than notepad ;)
13:10:08 <nominolo> try downloading and installing the ghc 6.8.2 binary
13:10:23 <nominolo> then get fingertree and you should be able to build it
13:10:38 <gwern> nominolo: sure, but we don't support more languages than nano yet
13:11:00 <nominolo> the configuration API changes a lot, so you should take a look at the examples to get an idea
13:11:06 <haluk> if anyone insterested yi there is a nice tutorail. -->> http://nobugs.org/developer/yi/building.html
13:11:07 <lambdabot> Title: Building Yi
13:11:10 <nominolo> gwern: how many does nano support?
13:11:38 <nominolo> gwern: yi has 4 or 5, doesn't it?
13:11:39 <gwern> nominolo: not sure. the /etc/nanorcs I remember looking at had upwards of 10
13:12:27 <nominolo> GEdit has even more.  But it almost always misinterprets/-recognises Haskell files
13:12:43 <gwern> nominolo: my /etc/nanorc lists 'nanorc, c/c++, html, tex, emails, patchs, manpages, groff, perl, python, ruby, java, assembler, sh, POV-ray'
13:13:19 <dcoutts> nominolo: you mean it thinks .hs files are something else or you mean the highlighting is a bit dodgy?
13:13:24 <dons> ?bot
13:13:25 <lambdabot> :)
13:13:25 <nominolo> ok, yi has: haskell, cabal. tex, c++
13:13:39 <nominolo> dcoutts: it thinks it's something else
13:13:59 <nominolo> and the highlighting is simplistic
13:14:05 <dcoutts> nominolo: weird, that's a mime problem then. It's not specific to gedit
13:14:06 <nominolo> but the emacs mode isn't better
13:14:26 <nominolo> dcoutts: yes. sometimes it seems to work
13:14:39 <dcoutts> nominolo: the new gedit has a better highlighting engine and I updated the haskell highlighter to match
13:15:23 <gwern> dcoutts: working on gedit? YOU TRAITOR
13:15:48 <dcoutts> gwern: it's what my students use for FP practicals so it's important that it works.
13:15:52 <dcoutts> nominolo: it now does haddock markup too :-)
13:16:04 <dcoutts> and I think it does foo' properly
13:16:18 <resiak> dcoutts: really?!
13:16:22 <b_jonas> @type sequence
13:16:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:16:27 <gwern> dcoutts: make part of their practicals 'install yi'. that tests their practical skills...
13:16:36 <nominolo> and does it render M.find with a colored M ?
13:16:44 <nominolo> *coloured
13:16:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5470
13:17:03 <nominolo> gwern: heh
13:17:52 <dcoutts> nominolo: yes, but also colours the find part :-)
13:18:12 <nominolo> dcoutts: oh, right
13:18:18 <SyntaxNinja> back
13:18:20 <nominolo> it was even weirder
13:18:21 <dcoutts> nominolo: a harder test is Foo.Bar.baz
13:18:34 <matthew-_> wow, encoding a DSL grammer into type classes is a strange but reasonably nice thing to do
13:18:40 <nominolo> oh hai
13:19:00 <dons> matthew-_: hehe
13:20:07 <matthew-_> it's just nice when you're testing it and it comes back with type errors tell you "no, that's not a terminal is it?"
13:20:31 <b_jonas> > do { x :: Int <- Just 9; x; }
13:20:31 <lambdabot>  Parse error at "<-" (column 15)
13:20:36 <b_jonas> > do { (x :: Int) <- Just 9; x; }
13:20:37 <lambdabot>  Parse error in pattern at "<-" (column 17)
13:20:42 <b_jonas> > do { x <- Just 9; x; }
13:20:43 <lambdabot>   add an instance declaration for (Num (Maybe t))
13:20:56 <matthew-_> > do { x <- Just 9; return x; }
13:20:58 <lambdabot>  Just 9
13:21:04 <b_jonas> ah yes
13:21:08 <matthew-_> you're already in Maybe, so you have to stay there ;)
13:21:11 <b_jonas> > do { x :: Int <- Just 9; return x; }
13:21:11 <lambdabot>  Parse error at "<-" (column 15)
13:21:16 <b_jonas> > do { (x :: Int) <- Just 9; return x; }
13:21:16 <lambdabot>  Parse error in pattern at "<-" (column 17)
13:21:26 <b_jonas> is there a way to add a type signiture?
13:21:27 <matthew-_> yeah, that's a bug in Î»b
13:21:32 <matthew-_> yeah, -fglasgow-exts
13:21:38 <b_jonas> ah, I see
13:22:04 <matthew-_> in fact, that might work in haskell98 - I'm not sure - it could *just* be a bug in Î»b
13:22:48 <nominolo> > do { x <- Just (9 :: Int); return x }
13:22:51 <lambdabot>  Just 9
13:23:37 <b_jonas> but that doesn't always work
13:23:46 <EvilTerran> matthew-_, that's not h98
13:23:53 <matthew-_> EvilTerran: ahh ok. ta.
13:24:11 <matthew-_> > (Just 9) >>= \(x::Int) -> return x
13:24:12 <lambdabot>  Parse error in pattern at "->" (column 24)
13:24:17 <matthew-_> > (Just 9) >>= \x -> return x
13:24:22 <lambdabot>  Just 9
13:24:26 <matthew-_> > (Just 9) >>= Î»x -> return x
13:24:26 <lambdabot>  Illegal character ''\187''
13:24:26 <lambdabot>  at "»x" (column 15)
13:24:31 <matthew-_> suxorz
13:24:48 <EvilTerran> ghci> let f (x :: Int) = x+x
13:24:48 <EvilTerran> <interactive>:1:7:
13:24:48 <EvilTerran>     Illegal signature in pattern: Int
13:24:48 <EvilTerran>         Use -XPatternSignatures to permit it
13:25:29 <matthew-_> yes, and if I actually used those then I'd never get any work done.
13:25:40 * matthew-_ still stubbornly uses -fglasgow-exts
13:25:44 <b_jonas> matthew-_: yes, that could work
13:25:55 <b_jonas> the >>= rewrite that is
13:26:01 <b_jonas> I'll just use -fglasgow-exts
13:26:07 <matthew-_> ...at least until ghci is smart enough to tell me which features a module actually uses
13:27:16 <EvilTerran> well, if you take out -fglasgow-exts, it usually tells you
13:27:24 <matthew-_> yeah, one by one
13:27:33 <b_jonas> EvilTerran: not in this case though
13:27:33 <matthew-_> and it sometimes gets it wrong too
13:27:38 <EvilTerran> whups, unexpected keyboard shortcut
13:27:42 <EvilTerran> b_jonas, er, "Use -XPatternSignatures"?
13:28:17 <b_jonas> EvilTerran: ah indeed
13:28:31 <b_jonas> lambdabot cuts only the important part of the message
13:28:35 <b_jonas> I should've tried
13:35:22 <pythonist> is there a serialization lib able to encode/decode closures?
13:35:41 <monochrom> I think not yet. Pretty tough problem.
13:35:54 <rnorris> hi, beginner here ... it looks like IORef is not some kind of monad trick .. it's an honest-to-god mutable cell. is this right?
13:36:01 <monochrom> Hrm, race condition. Or did I cause him to crash? :)
13:36:04 <nelhage> rnorris: Correct
13:36:17 <nelhage> (Of course, it only works in the IO monad)
13:36:22 <monochrom> honest to asm. :)
13:36:41 <rnorris> i'm kind of surprised to see that .. is the idea that anything goes in IO, so try to keep out of there if you can?
13:36:59 <monochrom> Yes.
13:37:20 <rnorris> k, thx
13:39:32 <nominolo> rnorris: ST is the monad that only allows mutable cells
13:39:53 <nominolo> @hoogle atomic
13:39:54 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
13:39:54 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
13:39:54 <lambdabot> Foreign.C.Types.CSigAtomic :: data CSigAtomic
13:40:39 <nominolo> rnorris: STM is the monad that only allows access to transactional variables
13:41:04 <EvilTerran> isn't STM the threaded one?
13:41:45 <EvilTerran> it talks about transactions and whatnot..
13:41:48 <nominolo> EvilTerran: no, STM uses forall s. to disallow using refs outside
13:41:55 <nominolo> er ST
13:42:02 <nominolo> STM is the transaction monad
13:42:09 <b_jonas> ST and STM is different
13:42:14 <EvilTerran> i thought so :)
13:43:42 <b_jonas> though I don't really understand either
13:44:03 <rnorris> i can see how you need something like an MVar to pass stuff between threads, i was just a little surprised to run across IORefs
13:44:17 <rnorris> having said that, almost everything i run across at this point is surprising
13:44:29 <EvilTerran> BOO!
13:45:08 <Cin> i'm a man
13:45:09 <nominolo> you can do evil tricks like unsafePerformIO (newIOREf ...)
13:45:22 <rnorris> well, sure. i could also just use C
13:45:55 <b_jonas> nominolo: yeah, I've seen that getStdGen from System.Random is implemented like that
13:46:07 <b_jonas> it's a bit strange because it doesn't seem thread-safe to me
13:46:16 <b_jonas> shouldn't they use MBoxes instead?
13:46:45 <b_jonas> though you'd probably not use that in multiple threads anyway
13:47:08 <nominolo> b_jonas: no creating a ref is often safe. modifying it is bad
13:47:30 <b_jonas> nominolo: the problem there is not how it's created
13:48:04 <nominolo> b_jonas: there's no insafePerformIO in getStdGen
13:48:12 <nominolo> and reading is always thread-safe
13:48:22 <scodil> is (unsafePerformIO newMVar ...) thread safe? Accessing it seems like it should be, but if two threads both force the unsafePerformIO at the same time, would it make two mvars?
13:48:29 <b_jonas> but that the standard random seed getStdGen is stored in an IORef and randomIO uses and modifies that
13:48:39 <b_jonas> so I wonder, if you call randomIO from two threads, what happens
13:48:55 <dcoutts> b_jonas: it's random! doesn't matter :-)
13:49:10 <b_jonas> there's an setStdGen too
13:49:19 <dons> b_jonas: its safe
13:49:30 <dons> since StdGen uses atomicModifyIORef
13:49:43 <scodil> is that why its so slow?
13:49:50 <b_jonas> wtf, there's an "atomicModifyIORef"?
13:49:58 <nominolo> of course
13:49:59 <b_jonas> how are IORefs simpler than full MVars then?
13:50:07 <dcoutts> b_jonas: no locks
13:50:09 <dons> scodil: no, its inefficient in many ways
13:50:15 <nominolo> MVars block if empty
13:50:22 <dons> if you care about speed of randoms, use the mersenne-random package
13:50:23 <dcoutts> b_jonas: the atomic modify uses atomic memory operations
13:50:26 <dons> its 50-100x faster
13:50:41 <scodil> yeah that's what i use
13:50:43 <awesame> aw, runtime error due to a bad regex
13:51:03 <awesame> I want a functional regex library that can be checked at compile-time
13:51:04 <dcoutts> b_jonas: for example it's possible to safely modify two MVars, that's not possible with a pair of IORefs using atomicModifyIORef
13:51:04 <scodil> the innards of System.Random are pretty atrocious. Everything goes through an Integer
13:51:10 <dons> right.
13:51:11 <b_jonas> ah,
13:51:17 <b_jonas> @type atomicModifyIORef
13:51:18 <lambdabot> Not in scope: `atomicModifyIORef'
13:51:21 <dons> and its a slow generator anyway
13:51:24 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5471
13:51:30 <nominolo>  Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
13:51:37 <b_jonas> what the heck does the do?
13:51:47 <b_jonas> @type Data.IORef.atomicModifyIORef
13:51:48 <lambdabot> forall a b. GHC.IOBase.IORef a -> (a -> (a, b)) -> IO b
13:52:26 <b_jonas> yes, but what does that do?
13:52:48 <nominolo> isn't that obvious?
13:52:54 <b_jonas> how can it modify it atomically if the function takes time to execute
13:53:00 <Cale> b_jonas: What does atomicModifyIORef do?
13:53:00 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:53:04 <b_jonas> I mean, how can it be atomic without any locks?
13:53:14 <nominolo> read the value, call a function, update it and return the other result
13:53:25 <kmcallister> b_jonas, perhaps the IORef contains a lock
13:53:26 <nominolo> b_jonas: HW support
13:53:28 <matthew-_> you know when you're in trouble when ... explicit kind annotations are needed!
13:53:50 <kmcallister> ?src IORef
13:53:51 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
13:53:55 <kmcallister> ?src STRef
13:53:55 <lambdabot> data STRef s a = STRef (MutVar# s a)
13:54:26 <b_jonas> nominolo: but the function can take time to execute, it's not like just atomically incrementing an integer
13:55:25 <b_jonas> the a->(a,b) function that is
13:55:50 <nelhage> It doesn't guarantee the function runs atomically, I think. Only that the final update happens atomically.
13:55:55 <scodil> is there a way to hide a whole module that another module imports? OpenGL brings in all of glut, which I don't want.
13:56:12 <b_jonas> nelhage: doesn't writeIORef guarantee that too?
13:56:36 <nelhage> yeah, actually I'm not sure I believe that explanation
13:56:44 <nominolo> scodil: does hiding ( module Foo ) work?
13:56:47 <b_jonas> I'd tend to belive it does have a lock
13:57:12 <nelhage> It could be optimistic
13:57:19 <scodil> nominolo: no "illegal import item"
13:57:37 <b_jonas> nelhage: I don't know what you mean by optimistic
13:57:47 <b_jonas> I'll try to look at the sources
13:58:18 <nominolo> atomicModifyIORef (IORef (STRef r#)) f = IO $ \s -> atomicModifyMutVar# r# f s
13:58:20 <nominolo> :)
13:59:10 <kmcallister> scodil, you can import the modules within Graphics.Rendering.OpenGL.GL.* one by one (annoying, i know)
13:59:30 <kmcallister> and then you can export them all from some module, without the stuff you don't want
13:59:48 <b_jonas> nominolo: yeah, that's what it says :(
13:59:50 <b_jonas> dunno
14:00:11 <b_jonas> actually that atomic modify thing isn't really important anyway
14:00:29 <nominolo> you could go digging into GHC.Base
14:00:37 <b_jonas> but I'd still like to know if writeIORef is atomic or I have to use MVar for anything I access from multiple threads
14:00:56 <dcoutts> the atomicModifyMutVar' primop obtains a global rts mutex
14:01:05 <dcoutts> see rts/PrimOps.cmm
14:01:06 <BMeph> So, am I just being overly sensitive, or is "Data.Function" just kind of a dumb name.
14:01:30 <BMeph> Note, these aren't mutually exclusive choices there... ;)
14:01:36 <b_jonas> dcoutts: is that atomicModifyMutVar' the same as atomicModifyMutVar# ?
14:01:49 <dcoutts> oops '/#
14:02:02 <dcoutts> b_jonas: yes, my typo
14:02:19 <b_jonas> dcoutts: so what about writeIORef?
14:02:35 <b_jonas> it's atomic, so it won't cause segfaults, right?
14:03:00 <dcoutts> right, but there is no guaranteed ordering between reads and writes in different threads
14:03:18 <b_jonas> um,
14:03:20 * BMeph wants "do { atomically (arm war . head) }" in a program someday
14:03:36 <b_jonas> I'm not sure what that means
14:03:38 <dancor> can i do something like  read "a" :: Maybe Int
14:03:57 <dancor> and get Nothing
14:04:09 <shachaf> @ty reads
14:04:09 <dcoutts> b_jonas: it means a write in one thread is not necessarily visible via a read in another thread
14:04:12 <resiak> > fromList $ reads "a"
14:04:12 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:04:12 <lambdabot>   Not in scope: `fromList'
14:04:14 <monochrom> Data.Function is not dumb.
14:04:19 <resiak> erm.
14:04:21 <b_jonas> does that mean that if I do two writeIORefs in the same thread, they can seem to execute the opposite order if I read it from another thread?
14:04:28 <dcoutts> b_jonas: not unless some other thread synchronisation is used, eg some MVar op
14:04:45 <resiak> > (listToMaybe $ reads "a") :: Maybe Int
14:04:50 <lambdabot>  Couldn't match expected type `Int'
14:05:05 <resiak> well, something like that.
14:05:10 <dcoutts> b_jonas: not sure about that, but certainly they could appear not to have happended at all yet
14:05:27 <dcoutts> they insert no memory barriers at all I believe
14:05:31 <b_jonas> I see
14:05:37 <monochrom> Data.Function is not dumb. You may argue that all of its content should appear in Prelude. I agree. But appearing in Prelude does not preclude also getting a dedicated module. Lots of list functions in Prelude appear again in Data.List. This is conventional practice even back in Haskell 98.
14:05:50 <paczesiowa> > let reead s = case reads s of { [(x, "")] -> Just x; _ -> Nothing} in reead "a" :: Maybe Int
14:05:51 <lambdabot>  Nothing
14:05:57 <paczesiowa> > let reead s = case reads s of { [(x, "")] -> Just x; _ -> Nothing} in reead "1" :: Maybe Int
14:05:58 <lambdabot>  Just 1
14:06:00 <b_jonas> so if I synchronize between them by waiting on an MVar, then all the writes will seem to happen?
14:06:11 <b_jonas> all the writes to any IORefs that is
14:06:12 <dcoutts> b_jonas: I think so
14:06:20 <shachaf> > (fmap fst . listToMaybe) (reads "a") :: Maybe Int
14:06:21 <b_jonas> ok,
14:06:21 <lambdabot>  Nothing
14:06:23 <shachaf> > (fmap fst . listToMaybe) (reads "1") :: Maybe Int
14:06:24 <lambdabot>  Just 1
14:06:26 <b_jonas> I'm not sure I fully understand that
14:06:39 <b_jonas> but I think I'll be able to use it
14:06:41 <dcoutts> b_jonas: which pretty much means there's no point, just use an MVar instead
14:06:47 <b_jonas> yeah
14:07:16 <b_jonas> or more complicated structures built from MVars
14:07:26 <dcoutts> yes, MVars, things built on MVars or STM are the proper things to use for multi-threaded stuff
14:09:47 <dancor> shachaf: nice
14:11:59 <b_jonas> as for barriers, I was wondering about a non-haskell thing: whether there's a weaker version of the unix sync call that only guarantees a barrier in syncing data to disk
14:12:32 <b_jonas> that is, a function that when you call it guarantees that any changes you do on files after this point will not be committed to the disk before any changes you've already made before the call
14:12:38 <b_jonas> obviously sync does this
14:12:53 <b_jonas> but it's weaker
14:13:03 <b_jonas> (hard disk caches complicate this a bit)
14:13:27 <dcoutts> b_jonas: I think linux has something like that
14:13:33 <b_jonas> this would be a nice thing to have if you implement a database, but apparently there's no such thing in userspace
14:13:40 <Cin> should i integrate my ircd into the Network.IRC package on Hackage?
14:13:48 <Cin> as, say, Network.IRC.Server
14:13:58 <Cin> or Network.IRC.Daemon
14:13:59 <dcoutts> Cin: why not as a separate package?
14:14:04 <b_jonas> dcoutts: is there? is it available for the user or is it just something internal for implementing filesystems?
14:14:25 <bd_> b_jonas: I think filesystems just block on a set of pending-write blocks before writing whatever they want to write next
14:14:29 <scodil> can you mix C synchronization mechanisms (say, pthreads mutexes) with GHC rts threads?
14:14:30 <Cin> dcoutts: well i was going to. wondering if making it part of Network.IRC was a good idea or not
14:14:33 <dancor> can i define instance Read (Maybe a)
14:14:35 <dancor> with that
14:14:46 <dcoutts> b_jonas: not sure, I recall reading something like that on LWN
14:14:56 <dcoutts> Cin: I'd suggest a separate package
14:14:58 <b_jonas> dcoutts: LWN is what?
14:15:04 <Cin> dcoutts: any reason?
14:15:06 <dcoutts> Linux Weekly News
14:15:27 <b_jonas> bd_: I don't think so, because on hard disks, seeking is more expensive than writing
14:15:32 <dcoutts> Cin: people often want one without the other, and it allows the new code to evolve easier
14:15:33 <b_jonas> (takes more time that is)
14:15:41 <bd_> b_jonas: yes, but you need to be able to set up barriers for data integrity in any case
14:16:01 <b_jonas> bd_: sure, you need a real sync as well
14:16:08 <bd_> a real sync?
14:16:20 <b_jonas> what the sync call or the sync program does in unix
14:16:31 <Cin> dcoutts: ahh. good point. someone writing a simple IRC bot obviously doesn't need server stuff. hrm
14:17:06 <b_jonas> it tries to ensure that everything is written to the media before the call returns, in case there's a crash or a blackout
14:17:11 <bd_> b_jonas: well, the sync call is a barrier over the entire drive; what you want is a barrier over only certain data?
14:17:15 <bd_> oh, right
14:17:20 <b_jonas> bd_: no
14:17:28 <b_jonas> barrier over certain data exists
14:17:33 <bd_> ?
14:17:44 <b_jonas> there's fsync, fdatasync, and even a linux-specific thing for syncing parts of a file
14:17:46 <rnorris> over particular fd, certainly fsync
14:17:51 <hpaste>  Paczesiowa annotated "1 ==== 0+1 ==== 2-1" with "(no title)" at http://hpaste.org/5460#a2
14:18:11 <b_jonas> sync_file_range is that linux-specific syscall
14:18:16 <rnorris> but keep in mind that all you're guaranteed is that the data gets handed off to the driver, which can do whatever it wants
14:18:20 <paczesiowa> Taejo: take a look at that, a bit more polymorphic
14:18:30 <rnorris> can write the data or not, or out of order etc
14:18:48 <bd_> rnorris: you can ask it to block until it completes
14:18:58 <Cin> dcoutts: well i'll just work on it as a separate package now, then.
14:19:17 <b_jonas> rnorris: yes. that's why people usually call sync two or three times and then sleep for good measure so the controller chips on the hard disk write the data to the disk from the hdd cache
14:19:25 <bd_> what you can't do it have it return immediately, AND have a barrier effect
14:20:03 <b_jonas> bd_: I think you can if you just want a barrier not a sync
14:20:11 <b_jonas> but I don't even need it to return immediately
14:20:46 <RayNbow> @src foldr
14:20:46 <lambdabot> foldr k z xs = go xs
14:20:46 <lambdabot>     where go []     = z
14:20:46 <lambdabot>           go (y:ys) = y `k` go ys
14:20:53 <Taejo> paczesiowa: I don't understand your "h" function
14:20:59 <bd_> the problem is if you want a barrier, how will you connect your next write to it, without enveloping every write in the system?
14:21:09 <RayNbow> oh right... an unreadable version I shouldn't copy for a report :p
14:21:23 * RayNbow goes to hunt for that fold paper...
14:21:37 <b_jonas> bd_: I guess it would be per os-thread only
14:21:44 <BMeph> RayNbow: It's simpler and more direct to just go 'Cale: ping' ;)
14:21:47 <b_jonas> I dunno what I'd do in a multi-os-threaded app
14:21:51 <b_jonas> I didn't think about that
14:21:54 <Cale> what?
14:22:00 <shachaf> Cale: @src foldr
14:22:09 <Cale> hehe :)
14:22:12 <shachaf> foldr f z [] = z
14:22:13 <Cale> foldr f z [] = z
14:22:22 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
14:22:25 <b_jonas> that is, it would only act as a barrier for writes (and other write-like ops) done by a single process or thread
14:22:27 <shachaf> Oh, well.
14:22:34 * shachaf can't hope to out-@src Cale.
14:22:40 <bd_> b_jonas: better to just block on the sync, then issue your next writes :)
14:23:03 <b_jonas> bd_: I think such a barrier could execute much faster in most cases than a sync
14:23:11 <b_jonas> and I want to call it often
14:23:25 <bd_> sure, it'll exec faster, but you still block your writes, and they still queue up in the kernel
14:23:33 <bd_> so the time until your data is committed is about the same
14:23:38 <b_jonas> no, it doesn't block your writes
14:23:40 <bd_> and you can bog down the kernel's writeback processes
14:23:45 <paczesiowa> Taejo: it takes x, evaluates it to check if there is no hidden exception inside and returns maybe result or Nothing to suppress exception. I simulate failed equality test with returning exception so later I can actually test if it failed or not
14:23:49 <bd_> b_jonas: it blocks them in the buffer cache
14:23:54 <b_jonas> hmm yeah
14:23:56 <bd_> ie, it prevents the kernel from writing thme back
14:24:03 <b_jonas> indeed it blocks them there
14:24:04 <b_jonas> hmm
14:24:19 <bd_> and if you do a tight loop of write a block, barrier, you could slow down writeback a lot
14:24:21 <b_jonas> yeah, it might not actually be better than an fsync then
14:24:24 <bd_> and maybe make memory pressure for other apps
14:24:31 <b_jonas> but wait,
14:24:34 <bd_> so just do it in userspace, it's the same thing :)
14:24:50 <bd_> except in userspace, it acts as natural backpressure on your own app
14:24:53 <Taejo> paczesiowa: I think I see
14:25:07 <b_jonas> yeah, it's like that indeed
14:25:09 * Cale gets ready to record updates to lambdabot for 6.8.2 (you lazy bastards, making me do this work! :)
14:25:17 <Cale> hehe
14:25:20 <b_jonas> pity
14:25:34 <b_jonas> I wonder how databases really work...
14:26:10 <b_jonas> bd_++ for explaining that
14:26:18 <visof> Cale so i can install lambdabot by ghc6.8
14:26:23 <bd_> b_jonas: O_DIRECT and async io help
14:26:36 <tibbe_> @src foldl
14:26:36 <lambdabot> foldl f z xs = lgo z xs
14:26:36 <lambdabot>     where lgo z []     =  z
14:26:36 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
14:26:41 <paczesiowa> Taejo: and I think there is no way to typecheck tests for integers (unless we type every number like 1::Int===1-0::Int===2-1::Int)
14:26:45 <b_jonas> wtf is O_DIRECT
14:26:55 <tibbe_> @src foldl'
14:26:55 <lambdabot> foldl' f a []     = a
14:26:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:27:05 <bd_> b_jonas: bypasses the caches, read() and write() directly DMA into your own address spaace
14:27:08 <bd_> space*
14:27:21 <b_jonas> reading it in the man page
14:27:53 <paczesiowa> Taejo: so we can't use it in a nicer way if it has to be polymorphic, and we really need typemagician to tell us if it can be done without unsafe*
14:28:08 <Taejo> paczesiowa: what's annoying me is that I can *express* a solution, but not execute it (phantom fundep conflicts)
14:28:22 <paczesiowa> Taejo: ?
14:28:39 <wli> "Caches" needs to be qualified as being the kernel's internal IO cache, which is basically the memory the kernel keeps around behind your back to align IO to device alignment requirements and pad IO to device size requirements.
14:28:41 <paczesiowa> Taejo: you mean read.show problem?
14:28:47 <Taejo> yes, I think so
14:28:53 <b_jonas> bd_: is that needed if you have mmap and msync?
14:28:57 <Cale> now, I just have to remember how this stuff with code.haskell.org works.
14:29:29 <bd_> b_jonas: mmap doesn't do scatter-gather as well :)
14:29:49 <ddarius> darcs push cale@code.haskell.org:/srv/code/calesproject
14:29:54 <paczesiowa> Taejo: what's so annoying about it? it's just not possible to implement it, you gotta live with it
14:29:59 <Taejo> paczesiowa: I can see that "instance (Ord b) => Input (MyMaybe b) b" and "instance (Ord b) => Input b b" don't conflict in "class Input a b | a -> b", but GHC thinks they do
14:30:23 <wli> These "caches" basically mean when you invoke the kernel with an IO system call, the kernel really does IO to the memory in this "cache," then copies to the memory you asked it to do IO to, unless you use O_DIRECT, in which case it really does use the memory passed to the syscall as the target for the device.
14:30:40 <bd_> b_jonas: see http://lse.sourceforge.net/io/aio.html
14:30:41 <lambdabot> Title: Kernel Asynchronous I/O (AIO) Support for Linux
14:30:44 <b_jonas> the simpler solution is to run the program on a machine with an ups so you never actually have to sync
14:30:51 <paczesiowa> Taejo: anyways it should be easy to implement inequalities (just always return value of rightmost variable or exception if first test failed)
14:30:57 <wli> That project is dead as a doornail.
14:30:58 <paczesiowa> Taejo: could you post that code?
14:31:05 <bd_> wli: AIO was merged >_>
14:31:58 <b_jonas> ah
14:32:16 <wli> bd: No, it wasn't ever finished, much less merged. O_DIRECT does some kinda-sorta async IO, if the moon is in the right house and the wind is blowing the right direction, otherwise it silently falls back to buffered IO.
14:32:16 <b_jonas> someone asked about kernel aio support in linux on some channel some day
14:32:21 <hpaste>  Taejo pasted "Another attempt at chained inequalities" at http://hpaste.org/5472
14:32:44 <b_jonas> (specifically why it doesn't work)
14:32:50 <b_jonas> this would be an answer
14:33:06 <Cale> aha, had the wrong username :)
14:33:27 <Cale> Okay, so that's pushed. Whoever has control of lambdabot can try it out :)
14:34:19 <wli> bd: Buffered IO is never async as the implementation now stands. All the async aspects of the request are silently ignored.
14:34:25 <bd_> oh
14:34:42 <b_jonas> wli: for special applications like databases and webservers which are really optimized for everything, even that might count
14:34:53 <dons> hpc rocks
14:35:00 <b_jonas> because they can change the implementation to use this feature of the kernel
14:35:06 <dons> best haskell tool since cabal
14:35:21 <bd_> webservers should use the cache
14:35:26 <litb> what is hpc ?
14:35:36 <b_jonas> yep, for webservers the sendfile call is something like this
14:36:15 <b_jonas> I meant webserver as an example for something that's optimized to use the kernel in full, not neccessarily the aio support in specific
14:36:26 <dozer> @pf \n -> n - 1
14:36:26 <lambdabot> Maybe you meant: bf pl
14:36:35 <dozer> @pl \n -> n - 1
14:36:35 <lambdabot> subtract 1
14:37:05 <wli> If it's there, people will use it. They're obviously more concerned with whether it works at all.
14:37:17 <paczesiowa> Taejo: damn, reading code meant to hack typechecker is hard
14:37:25 <Taejo> where can I find a tutorial or introduction to fundeps?
14:37:32 <Taejo> paczesiowa: yep
14:37:47 <b_jonas> good night now
14:41:54 <hpaste>  Paczesiowa annotated "Another attempt at chained inequalities" with "(no title)" at http://hpaste.org/5472#a1
14:42:24 <Taejo> paczesiowa: works?
14:42:30 <paczesiowa> Taejo: yes
14:42:41 <Taejo> ah, still using your damned h
14:42:47 <paczesiowa> :>
14:43:04 <phobes> paczesiowa:  What happens in the overlapping Bool case?
14:43:52 <phobes> oh, this just works on Ord
14:43:55 <paczesiowa> phobes: no idea, ghc doesn't want any ugly switches so I guess nothing happens:>
14:44:04 <phobes> I guess Bool are technically Ord, but I no longer care
14:45:20 <paczesiowa> I feel so dirty about using those exceptions inside unsafePerformIO
14:51:21 <ddarius> You guys are still working on that?
14:52:51 <phobes> Does it matter what web registrar you use?
14:54:24 <paczesiowa> ddarius: I'm done, I did it the ugly way, and I have absolutely no idea if it's possible to do it the right way
14:54:40 <joglala> data Tree Int = Leaf Int | Branch Int (Tree Int) (Tree Int)
14:54:53 <joglala> Is this a complete implementation of a list in haskell or is there something missing?
14:55:01 <joglala> e.g. the declariotion of Branch
14:55:17 <ddarius> joglala: That's a complete implementation of a Tre.
14:55:50 <joglala> Thank you
14:57:41 <kuribas> Is there now an arc implementation in haskell?
14:57:43 <litb> what is the Int for?
14:57:51 <litb> does that contain the node data?
14:58:13 <joglala> it should
14:59:13 <joglala> why isn't there a | Tree a constructor?
14:59:33 <litb> hmm
14:59:43 <dons> kuribas: yeah, we wrote one in the channel during the super bowl half time show
14:59:48 <joglala> Hmm
14:59:50 <litb> a tree is either a Branch or a Leaf. isn't that complete?
15:00:33 <joglala> Seems to be complete
15:01:02 <litb> or Maybe (Tree Int) haha then you have only Branch
15:01:11 <kuribas> dons: cool, can I download it?
15:01:54 <litb> "super bowl half time show" whats that?
15:01:54 <joglala> Yes, i meant Tree Int, but then it seems it must have two nodes
15:02:48 <litb> joglala: i mean if it was "data Tree Int = Branch Int (Maybe (Tree Int)) (Maybe (Tree Int))" it seems to be complete too
15:02:53 <Pseudonym> "super bowl half time" sounds like some kind of spontaneous symmetry breaking in an oddly-shaped potential.
15:02:55 <litb> but i wouldn't do that
15:03:08 <joglala> Is Maybe a keyword?
15:03:13 <joglala> Why wouldn't you do that
15:03:18 <ddarius> joglala: Incidentally, that should be 'data Tree = Leaf Int | Branch Int Tree Tree' or 'data Tree a = Leaf a | Branch a (Tree a) (Tree a)'
15:03:21 <litb> @src Maybe
15:03:21 <lambdabot> data Maybe a = Nothing | Just a
15:03:21 <Pseudonym> Maybe is in the standard library.
15:03:27 <Pseudonym> The Prelude, to be precise.
15:03:51 <joglala> Thanks
15:03:59 <litb> joglala: because you seem to look for a balanced tree that has both branches used. Maybe doesn't look rite
15:04:08 <litb> but i could fail indeed, still quite new to haskell =)
15:04:38 <joglala> me too
15:05:23 <joglala> I think haskell is not good for my brain :/
15:05:34 <joglala> Its so different
15:05:44 <ddarius> How is that not good?
15:05:51 <litb> lol
15:06:08 <litb> always if you have something different, you get smarter by somewhat
15:06:13 <litb> that's well known dude
15:06:27 <joglala> ...but does not make it easier
15:06:47 <ddarius> It's like (physical) exercise.
15:07:00 <ddarius> More effort now makes things easier later.
15:07:29 <matthew-_> yikes, what's -XTypeOperators ?
15:07:49 <joglala> Haskell as physical exercise must be offroad inline skating or similar
15:09:18 <scodil> joglala: but doesn't that sound like it would be f'n awesome once you learn how to do it?
15:09:22 <Pseudonym> More like a combination of unicycling and fencing.
15:09:32 <Pseudonym> Actually, that would rock.
15:09:36 <Lemmih> matthew-_: Infix data types, I believe.
15:10:02 <litb> > iterate (++ ["easier"]) ["easier"]
15:10:03 <joglala> ;)
15:10:06 <lambdabot>  [["easier"],["easier","easier"],["easier","easier","easier"],["easier","easi...
15:10:10 <litb> :)
15:10:40 <matthew-_> ahh, ok
15:10:52 <ddarius> Lemmih: Yeah.
15:11:12 <ddarius> Pseudonym: That would be impressive to watch.
15:11:32 <Pseudonym> I've seen unicycle jousting.
15:12:02 <wli> > let bernoulliPoly n x | n < 0 = undefined | n == 0 = 1 | n == 1 = x | otherwise = x ^ n - (sum [((n+1) `choose` k) * bernoulliPoly k x | k <- [0..n-1]] `div` (n + 1)) ; n `choose` k | n < 0 = undefined | k < 0 || k > n = 0 | k == 0 = 1 | 2 * k > n = n `choose` (n - k) | otherwise = (n * ((n - 1) `choose` (k - 1))) `div` k in zip [(bernoulliPoly (n+1) 3 - bernoulliPoly (n+1) 0) `div` (n+1) | n <- [0..10]] [0^k + 1^k + 2^k | k <- [0..]]
15:12:05 <lambdabot>  [(3,3),(3,3),(5,5),(9,9),(17,17),(33,33),(65,65),(129,129),(257,257),(513,51...
15:12:23 <matthew-_> ok, mental exercise. I have a class C m x y a where cf :: m x y a -> m y z b -> m x z b. What instance must I define so that the instance type sig of cf :: (x -> (y, a)) -> (y -> (z, b)) -> (x -> (z, b))
15:12:28 <ddarius> Pseudonym: That doesn't take the agility fencing would.
15:12:33 <Pseudonym> Right.
15:12:50 <matthew-_> grr. that class is wrong. The class is class C m where cf :: m x y a -> m y z b -> m x z b
15:13:22 <matthew-_> it must be some combination of (->) and (,)
15:13:30 <matthew-_> but I can't seem to get ghci to help me out
15:13:55 <ddarius> You'd need type lambdas or type operators (of a different sort) to do that.
15:14:01 <ddarius> Alternatively, you can use a newtype.
15:14:45 * wli itches for a memoizing implementation.
15:14:51 <matthew-_> ahh, yes, newtype would be fine and straightforward wouldn't it?
15:15:19 <ddarius> matthew-_: Not only fine and straightforward, it's the only thing that will work (or something essentially equivalent)
15:15:19 <cjb> Could someone point me at an explanation of memoization in Haskell, please?
15:15:30 <Pseudonym> @go memoizing cafs
15:15:31 <lambdabot> http://www.haskell.org/haskellwiki/Memoization
15:15:31 <lambdabot> Title: Memoization - HaskellWiki
15:15:35 <ddarius> cjb: What do you mean by "memoization in Haskell"?
15:15:36 <Pseudonym> Perfect.
15:15:38 <cjb> That'll do it.  :)
15:15:41 <matthew-_> ddarius: thanks
15:15:47 <cjb> ddarius: How to annotate my code for memoization.
15:16:00 <cjb> and, when if ever Haskell will do that for me.
15:16:08 <EvilTerran> in short, never
15:16:10 <Pseudonym> cjb: Short answer is it won't.
15:16:18 <matthew-_> ddarius: and when is ghc giving proper type lambdas to haskell? ;)
15:16:19 <cjb> the wiki page looks fine, thanks.
15:16:25 <Pseudonym> No problem.
15:16:57 <ddarius> matthew-_: It's never going to have "proper" type lambdas.  There was a proposal and paper somewhere proposing a weakened lambda that would retain decideability.
15:17:25 <matthew-_> decideability's overrated ;)
15:18:02 <ddarius> Perhaps, probably even, but Haskell has so far tried to stick to a decideable type system.
15:18:23 <visof> i installed cabal by darcs  and i can't use it, is it cabal install happy ??
15:19:35 <visof> for installing happy?
15:19:48 <dons> you built cabal, but not cabal-install?
15:20:03 <visof> ya
15:20:18 <Taejo> paczesiowa: maybe I can use something like http://okmij.org/ftp/Haskell/typecast.html#is-function-type to resolve my fundep conflict
15:20:19 <lambdabot> Title: Type improvement constraint
15:20:39 <visof> is cabal like cabal install?
15:20:49 <visof> what is the difference
15:20:50 <visof> ?
15:21:17 <hpaste>  Paczesiowa annotated "1 ==== 0+1 ==== 2-1" with "final version" at http://hpaste.org/5460#a3
15:21:28 <EvilTerran> cabal-install is a program that wraps caba and attempts to be nicer to use
15:23:17 <paczesiowa> Taejo: I don't think so, we only use binary operators taking nonfunctional parameters
15:24:26 <Taejo> paczesiowa: yeah, but perhaps it's possible to define an IsMyMaybe type-level-predicate, like IsFunction
15:24:48 <paczesiowa> Taejo: I've commented that code if you want to take a look at it
15:25:02 <Taejo> yeah, I think I understand it
15:25:12 <Taejo> what happens in the True===True case?
15:25:26 <joglala> Wow, im in that social network graph
15:25:31 <paczesiowa> overlapping instance
15:25:52 <Taejo> paczesiowa: doesn't compile? I suppose that's a good thing
15:26:09 <conal> newsham: thanks for the mathmap pointer.  i hadn't seen it.
15:26:09 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
15:26:34 * monochrom is writing prose in an editor that doesn't word-wrap.
15:27:07 <paczesiowa> but it's a good thing! all these newbies write code like if x==True then True else False and now they can't:P
15:27:10 * monochrom is writing prose in an editor that doesn't word-wrap. But the editor can use an external program to filter text fragments.
15:27:37 * monochrom is therefore now tempted to interrupt writing the prose and write a word-wrap filter in Haskell!
15:27:53 <resiak> why on earth would you not just use some other editor ?
15:28:36 <ddarius> joglala: All that means is that you've spoken to someone or someone has spoken to you.  (In fact, it doesn't even mean that necessarily.)
15:28:42 <monochrom> Because all editors suck. No exception.
15:28:57 <Taejo> monochrom: GNU fmt
15:29:04 <paczesiowa> Taejo: but that code with typeclasses named TypeCast must be really great, because I've seen it in like 3 or 4 Oleg's posts
15:29:12 * EvilTerran has a vim script bound to == to grab the current paragraph and shove it through fmt -80
15:29:21 <monochrom> Thanks. I forgot fmt.
15:29:34 <ddarius> paczesiowa: And how do you write implication and equivalence of booleans?
15:29:38 <joglala> ddarius: Yes
15:29:42 * monochrom can ditch Haskell again and go back to prose-ing and unix-ing :)
15:30:04 <EvilTerran> monochrom, you must be so disappointed
15:30:15 <scodil> EvilTerran: gqip ?
15:30:22 <joglala> This "map" thing is interessting
15:30:24 <EvilTerran> scodil, ?
15:30:27 <paczesiowa> ddarius: I can't so I decided that I don't want to:P
15:30:40 <scodil> that's vim for "autoformat this paragraph"
15:31:27 <hpaste>  Paczesiowa pasted "fmt" at http://hpaste.org/5473
15:31:35 <resiak> monochrom: but, surely you have some preferred least-sucky editor with word wrapping ?
15:31:37 <matthew-_> um, if I do type StateT' m s a = StateT s m a then why does it moan when I try to do instances which rely on partially applied StateT' ?
15:31:48 <EvilTerran> scodil, ah, yes, that's the one. still got to set formatprg, tho.
15:31:58 <matthew-_> I get things like "should have 3 params but only given two"
15:32:06 <scodil> EvilTerran: :set tw=80 works for me
15:32:12 <Taejo> paczesiowa: is that greedy or optimal linebreaking?
15:32:16 <EvilTerran> hm. clever.
15:32:22 <paczesiowa> Taejo: optimal
15:32:24 <monochrom> What did I start? :)
15:32:29 <matthew-_> I've tried explicit kind annotations too
15:32:36 <EvilTerran> as you can tell, i haven't yet learnt all my way 'round vim :P
15:32:43 <kmcallister> matthew-_, possibly you need kind annotations, e.g StateT' (m :: * -> *) s a = StateT s m a
15:32:50 <Taejo> paczesiowa: nice. I'm afraid I don't read Polish after midnight
15:32:53 <matthew-_> ahh, there! good idea
15:32:55 <kmcallister> otherwise it may just be a limitation of type synonyms, there's some stuff in the GHC manual about those
15:32:59 <monochrom> Anyway, if an editor lacks something that can be supplemented by external hooks, it's OK.
15:33:18 <matthew-_> kmcallister: nah, doesn't help
15:33:22 <kmcallister> :(
15:33:23 <monochrom> Anyway, it's "complicated".
15:33:37 <paczesiowa> Taejo: yeah, I often use polish for variable names when I can't think of english equivalent
15:33:45 <matthew-_> damn, so you can't use use aliases to reorder params so that you can do additional instances. fooey
15:33:56 <monochrom> I knew some Polish.
15:34:05 <mrd> Reverse Polish Notation?
15:34:25 <kmcallister> matthew-_, what about just type StateT' m s = StateT s m
15:34:43 <paczesiowa> Taejo: besides, that code is boring, juggling strings and lists of strings is so boring it's usually done with perl
15:35:26 <Taejo> paczesiowa: I've considered setting that problem for a computer olympiad
15:35:52 <monochrom> GNU fmt is written by "Ross Paterson". Is that who I think it is?
15:36:14 <matthew-_> kmcallister: good call! that works. many thanks
15:36:46 <prb> I'm having trouble getting simpleHTTP (from Network.HTTP) to close its connections.  Any suggestions?  (I've tried strictifying various downstream bits that deal with responses.)
15:36:49 <kmcallister> glad to hear it, i learned something too :)
15:36:55 <olsner> ooh, a literate haskell hack for markdown
15:37:33 <dancor> where is url escaping func i.e. f "a&b c" is "a%26b+c"
15:37:44 <paczesiowa> dancor: Network.URI
15:37:47 <dancor> tx
15:37:52 * EvilTerran makes a note to remember the "i*" motions
15:38:13 <monochrom> prb: There is a chance it deliberately "keep-alive".
15:38:25 <prb> monochrom: I tried "Connection: close"
15:38:56 <Cin> when you're defining types that depend on other types, what order do you put them in?
15:39:04 <monochrom> Alright, then I don't know.
15:39:10 <paczesiowa> Taejo: don't do that, it's boring! give kids (or students?) chance to have fun with something to think about and not something to start typing and add more if-then-elses as you go
15:39:49 * EvilTerran likes paczesiowa's implication that perl makes programming boring code interesting
15:39:59 <prb> monochrom: But I'll try debugging the connection.
15:40:05 <EvilTerran> that's a fantastic example of damning with faint praise
15:40:20 <Cin> blah i'll just order it how i do my functions
15:40:28 <Taejo> paczesiowa: I would simplify it so that you just have to realise "aha, you can minimize total over/underfulness using dynamic programming"
15:41:01 <ddarius> monochrom: Probably (re Ross Paterson)
15:41:06 <Taejo> paczesiowa: I can't set type-programming problems unfortunately
15:42:16 <paczesiowa> Taejo: anyway, who are you if you choose problems for students?
15:42:25 <EvilTerran> "determine the optimal line-wrapping for a given sequence of words to a given width, in the type system :D
15:42:39 <Taejo> paczesiowa: South African Computer Olympiad Scientific Committee
15:43:09 <joglala> Do i understand this correct? If i define foo f tree = map f tree, and tree being a tree like above, it should call f for each element of the tree?
15:43:15 <joglala> I looks to simple
15:43:38 <paczesiowa> EvilTerran: I don't understand that line about boring perl ( I can't parse the sentence)
15:43:55 <scodil> joglala: map only works for lists. You have to use fmap and define an instance of Functor for your tree.
15:44:12 <joglala> Ahh
15:44:28 <scodil> map is list fmap for lists, but fmap can work on lots of different things
15:44:34 <scodil> er, map is like fmap for lists
15:44:47 <paczesiowa> huh, I've never used fmt and now I see that my code does smth different (I thought it was fmt-like), my code justifies text
15:44:56 <joglala> And fmap uses a function that gets the next element?
15:45:25 <znutar> boring code is the firmware for oil drills
15:45:31 <scodil> fmap is an overloaded function. you have to define it for your tree
15:45:47 <Cin> do people ever annotate their `import' with the reason they are importing them?
15:45:51 <EvilTerran> paczesiowa, to me, your comment implied that you thought that a problem that would be boring to solve in any other language would be interesting to solve in perl
15:46:07 <joglala> Functor a => that seems to be the "overloading"
15:46:44 <EvilTerran> paczesiowa, and i considered this to be a nice subtle dig at perl
15:46:46 <paczesiowa> EvilTerran: I meant that I think boring problems are bread&butter of perl
15:46:46 <matsmats> How do you define (==) on a custom data type? I'm trying to define "(==) :: Shape -> Shape -> Bool" but when I use == in that function's definition (using it on two ints), hugs does not compile.
15:47:08 <wli> fmap used to be called map before the standard Prelude was destroyed.
15:47:12 <paczesiowa> matsmats: how about "deriving Eq" ?
15:47:25 <scodil> joglala: yeah kinda. it means a is an instance of class Functor, and so there is an fmap function that will work with values of type a
15:47:39 <kmcallister> matsmats, read about typeclasses, specifically the Eq typeclass
15:47:50 <matsmats> paczesiowa: sure, but i want to override it for that particular type
15:47:52 <resiak> i love the warrior-like terms that get used when discussing the warts of the Prelude
15:47:55 <EvilTerran> paczesiowa, as solving a programming problem is only interesting if it takes ingenuity to solve it, it looked to me like you were saying it took ingenuity to work in perl, regardless of the problem you were trying to solved. that amused me.
15:48:09 <EvilTerran> *trying to solve
15:48:15 <kmcallister> instance Eq Shape where
15:48:19 <kmcallister>   a == b  =  ...
15:48:48 <dancor> can anyone say "why"/when (f . g . h) x is preferable to f $ g $ h x
15:48:51 <EvilTerran> paczesiowa, don't worry about me, i'm easily entertained ;)
15:48:52 <matsmats> kmcallister: that rings a bell. thanks
15:49:07 <paczesiowa> EvilTerran: glad, you're happy:>
15:49:13 <EvilTerran> :)
15:49:30 <ddarius> dancor: Often f . g . h $ x is used.
15:49:35 <scodil> dancor: map (f . g . h) [x,y,z]
15:49:36 <paczesiowa> dancor: I'd choose f.g.h$x
15:49:42 <scodil> oh nm,
15:49:48 <joglala> scodil: Is there a way to do it without fmap? It looks complicated
15:49:57 <EvilTerran> scodil, that parse tree's a different shape :P
15:49:58 <scodil> joglala: what do you want to do, specifically?
15:50:25 <joglala> I want to pass every value of my tree to a function and get a new tree
15:50:31 <scodil> yeah i thought he was asking about it in general. you can't do "map (f $ g $ h) [x,y,z]"
15:50:40 <scodil> or can you?
15:50:43 <scodil> i give up
15:50:46 <monochrom> fmap is not complicated.
15:50:49 <joglala> data Tree a = Leaf a | Branch a (Tree a) (Tree a) is my tree
15:50:52 <ddarius> scodil: You can, but it means something else.
15:50:55 <kmcallister> if the types of f,g,h are right, sure you can
15:51:01 <EvilTerran> scodil, and therein lies the problem with using f $ g $ h $ x instead of f . g . h $ x
15:51:18 <paczesiowa> > map ((+1) $ (+2) $ (+3)) [1..5]
15:51:18 <lambdabot>   add an instance declaration for (Num (a -> a))
15:51:26 <paczesiowa> > map ((+1) . (+2) . (+3)) [1..5]
15:51:27 <lambdabot>  [7,8,9,10,11]
15:51:28 <EvilTerran> semantically, f.g.h is a sub-expression of the latter, as are f.g and g.h
15:52:13 <scodil> joglala: fmap f (Leaf a) = Leaf (f a); fmap f (Branch x y z) = Branch (f x) (fmap f y) (fmap f z)
15:52:38 <monochrom> If I can just write "f . g . h" (no x), I'll do it. If x must be there, I'll write "f (g (h x))". Somehow I dislike $.
15:53:11 <paczesiowa> you're cheap:P
15:53:56 <Jiten> monochrom: why not (f . g . h) x ?
15:54:03 * wli yawns and points to some more important issue with the standard library, like the numeric hierarchy.
15:54:11 <monochrom> Yeah I like celestrial goals such as point-free more than secular $. :)
15:54:34 <scodil> well, love of $ is the root of all evil
15:55:24 * wli rereads "How Java Floating Point Hurts Everyone Everywhere All the Time."
15:55:32 <Jiten> I don't really like $ either but I dislike big clumps of parentheses even more.
15:55:34 <EvilTerran> iah iah Cale fthaghn...
15:55:58 <EvilTerran> (pronounced "$ should be left-associative")
15:56:24 <monochrom> Perhaps I write the horrendous "f (g (h x))" to mock people who want x there. I don't know. It's subconscious.
15:56:41 <EvilTerran> (that is Cale, isn't it?)
15:56:48 <paczesiowa> let ($$) = flip (flip id) in (+1) $$ 2
15:56:53 <paczesiowa> > let ($$) = flip (flip id) in (+1) $$ 2
15:56:54 <lambdabot>  3
15:57:10 <EvilTerran> er... flip (flip id) = id, surely?
15:57:16 <paczesiowa> no
15:57:21 <EvilTerran> apart fro mthe type
15:57:21 <ddarius> :t flip . flip
15:57:23 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
15:57:24 <Cale> EvilTerran: You called? :)
15:57:24 <paczesiowa> flip id is function application
15:57:37 <EvilTerran> Cale, ah, sorry, i forgot about beeps
15:57:39 <paczesiowa> flip id == ($)
15:57:42 <ddarius> @. type djinn flip . flip
15:57:42 <lambdabot> Not in scope: data constructor `Cannot'
15:57:43 <lambdabot> Not in scope: `parse'
15:57:43 <lambdabot> Not in scope: `command'
15:57:46 <EvilTerran> paczesiowa, er, no, ($) = id
15:57:49 <EvilTerran> ?src ($)
15:57:49 <lambdabot> f $ x = f x
15:57:50 <ddarius> Oops
15:57:57 <ddarius> @. djinn type flip . flip
15:57:58 <lambdabot> f a = a
15:58:10 <EvilTerran> @pl flip . flip
15:58:10 <lambdabot> id
15:58:21 <wli> The post-1.4 anti-polymorphic castration, the removal of monad comprehensions, the idiot fail method polluting Monad, the numeric hierarchy, and so on are all vastly more urgently in need of correction than some fixity declaration.
15:58:39 <dancor> let dlof = foldl (flip ($))
15:58:44 <scodil> am I the only one who does something like ($>) = flip ($) and (.>) = flip (.) to get postfix notation? does that make me weird?
15:59:00 <EvilTerran> wli, hehe... we might as well fix the small stuff with the big stuff, tho
15:59:04 <vincenz> scodil: very weird
15:59:05 <ddarius> scodil: No you're not the only one.  I'm not sure if that makes you weird or not.
15:59:07 <EvilTerran> get it all in haskell2, if we're lucky :P
15:59:08 <scodil> somehow it feels better when mixed with >>=
15:59:24 * EvilTerran just uses =<< ...
15:59:26 <scodil> because >>= is basically postfix
15:59:58 <dancor> wli: we want monad comprehensions back?
16:00:10 <wli> dancor: Yes.
16:00:21 <scodil> but the rhs of >>= is often a lambda, then you got ->'s point right and =<<'s pointing left. very discordant
16:00:24 <EvilTerran> scodil, because the null operator is right-to-left, i tend to make everything right-to-left
16:00:29 * ddarius could care less if monad comprehensions return or not.
16:00:34 <LoganCapaldo> I want monad comprehensions back
16:00:45 <EvilTerran> and if the right of >>= is a lambda, i switch in a do block
16:00:46 <joglala> scodil: Wow, thank you
16:00:53 <joglala> Haskell is really interessting
16:00:55 <dancor> wli: would ['a'] be String or more general
16:01:20 * wli actually has uses for them.
16:01:25 <scodil> aahh gratitude. and now I can leave.
16:01:47 <wli> dancor: It would get translated to return 'a'
16:02:15 <wli> dancor: Hence Monad m => m Char
16:02:21 <phobes> so haskell had Monad comprehensions and one point and removed them?
16:02:23 <EvilTerran> dancor, i'd make [| [x0, x1, ..., xN] |] = pure x0 <|> pure x1 <|> ... <|> pure xN
16:02:33 <phobes> As always, haskell = ghc :)
16:02:37 * EvilTerran using pure/<|> instead of return/mplus just to be difficult
16:03:00 <EvilTerran> (where [|...|] means "the semantic meaning of", taken from some-paper-or-another)
16:03:56 <wli> It may be plausible to use a more general type than Monad m => m t
16:04:27 <EvilTerran> dancor, i'd also extend this to allow such things as [ foo, bar | ... ]
16:06:12 <monochrom> You asked for monad comprehension. I think you'll get applicative comprehension.
16:06:37 <ddarius> phobes: Haskell 1.4 did and Haskell 98 removed them.
16:06:50 <EvilTerran> monochrom, yay!
16:06:56 <phobes> ddarius: ah
16:07:12 <ddarius> monochrom: List comprehensions don't map to applicative use
16:07:34 <wli> They do just fine in monads.
16:08:11 <twanvl> Is there a case where monad comprehension is significantly better than do notation?
16:08:19 <ddarius> twanvl: guards
16:08:31 <ddarius> Otherwise, no, not really.
16:08:34 <LoganCapaldo> lot's of use of "guard" I imagine
16:08:38 <dcoutts_> EvilTerran: what does [ foo, bar | ... ] mean as a monad comprehension?
16:08:58 <monochrom> [ f x | ... ] vs do ... return (f x)
16:09:19 <LoganCapaldo> what does [ foo, bar | mean as a list comprehension? I didn't think that was valid syntax
16:09:19 <monochrom> It depends on whether you want f x to appear first or last.
16:09:32 <olsner> hmm, is markdown really supposed to replace -- with m-dash in code blocks?
16:09:37 <dcoutts_> LoganCapaldo: it's not, it's EvilTerran's imaginary extension
16:09:42 <monochrom> On that bikeshed colour people can debate for years.
16:09:42 <EvilTerran> as a list comprehension, i figure it'd mean concat [[foo,bar] | ... ]
16:10:01 <LoganCapaldo> oh
16:10:12 <twanvl> Yay, more room for , vs. | confusion errors
16:10:23 <Pseudonym> concat [ [foo,bar] | ... ] == ... >>= [foo,bar]
16:10:44 <Pseudonym> > [ 1,2 | True ]
16:10:45 <lambdabot>  Parse error at "|" (column 7)
16:10:47 <LoganCapaldo> clean uses // for | and | for , (well for guards) in list comprehensions IIRC
16:11:05 <Pseudonym> Miranda used semicolon to separate qualifiers in list comprehensions.
16:11:17 <EvilTerran> i can't remember what definition i gave it for monad comprehensions
16:11:21 <LoganCapaldo> So does my ruby list comprehension "lib"
16:11:31 <EvilTerran> but it was somehow related to [x0, x1, ..., xN] --> pure x0 <|> pure x1 <|> ... <|> pure xN
16:11:41 <LoganCapaldo> not that that's really relevant
16:11:43 <LoganCapaldo> heh
16:12:45 <joglala> Hmm.. hugs does not want fmap, he says that defined twice , in Main and in Preludes
16:13:06 <EvilTerran> joglala, "instance Functor <your type here> where fmap = ..."
16:13:21 <EvilTerran> don't forget to indent the body of the definition
16:13:26 <monochrom> Be careful about <your type here>
16:13:56 <wli> twanvl: Monad comprehensions are a lot more compact than do notation and also allow switchovers from lists to other monads without fiddling with the expression (no, using do notation instead of list comprehensions is not an answer).
16:14:05 <EvilTerran> oh, yeah. joglala, what type is the fmap you're trying to define?
16:14:08 <monochrom> It is "instance Functor Tree where" rather than "instance Functor Tree a where".
16:14:25 <joglala> I tried what scodil said
16:14:25 <EvilTerran> monochrom, or even instance Functor (Tree a) where
16:14:33 <EvilTerran> what did scodil say?
16:14:36 <twanvl> wli: unfortunatly the next 'monad' I would use monad comprehension for is Set, which is not a Monad in haskell :(
16:14:37 <monochrom> data Tree a = Leaf a | Branch a (Tree a) (Tree a)
16:14:44 <joglala> fmap f (Leaf a) = Leaf (f a); fmap f (Branch x y z) = Branch (f x) (fmap f y) (fmap f z)
16:15:15 <matthew-_> if, say, you wanted to present a wrapping of State from a library, such that it simply had additional type class constraints, how would you do it?
16:15:15 <EvilTerran> (monochrom, I mean that as another example of what not to do)
16:15:33 <monochrom> Right.
16:15:35 <wli> twanvl: Remind me why it's not a monad.
16:15:35 <joglala> I used f x = x + 1;
16:15:36 <matthew-_> it would seem a shame to have to rewrite all the instances that State is in
16:15:45 <LoganCapaldo> -fallow-stupid-ideas ; instance Eq a where (==) = undefind
16:15:46 <twanvl> wli: Set a needs Ord a
16:15:54 <EvilTerran> matthew-_, well, you can use newtype deriving
16:16:13 <EvilTerran> matthew-_, is there a good reason why you can't just define the new instances on Set?
16:16:14 <wli> twanvl: There's some sort of unrelated proposal floating around to address that.
16:16:33 <matthew-_> EvilTerran: that wasn't to me was it?
16:16:43 <EvilTerran> er, i meant State, not Set
16:16:44 <monochrom> -fdynamic-typing
16:16:50 <EvilTerran> -XDWIM
16:17:31 <LoganCapaldo> haven't you heard, C# 4 is gonna have -fdynamic-typing
16:17:31 <twanvl> wli: yes, but I doubt it will be implemented, for one thing it would mean that all types used internally in a monadic function would leak out to the type signature of that function.
16:17:39 <matthew-_> EvilTerran: um, no, I want to enforce that the user can only use the type when the additional contexts are available
16:17:45 <EvilTerran> oh, i see
16:17:50 <joglala> Node lab [Tree lab], this i a tree with any number of nodes, right?
16:17:57 <phobes> What's the translation of gaurd expressions to Monads?
16:18:09 <phobes> Do you need mzero or something?
16:18:11 <EvilTerran> joglala, if you mean data Tree a = that, yeah
16:18:17 <monochrom> @src guard
16:18:17 <lambdabot> guard True  =  return ()
16:18:17 <lambdabot> guard False =  mzero
16:18:21 <phobes> k
16:18:25 * matthew-_ looks up newtype deriving
16:18:32 <EvilTerran> er, Tree lab = that, even
16:18:55 <wli> phobes: The screwup nowadays is the fail method in Monad vs. the mzero constraint for the possibility of failure.
16:18:59 <monochrom> [ x | y==0 ] = do { guard (y==0); return x }
16:19:08 <monochrom> where "=" means mathematical equal.
16:19:09 <joglala> Yes, thank you :)
16:19:42 <EvilTerran> Data.Applicative.empty FOREVER!
16:20:16 <twanvl> > forever empty
16:20:16 <lambdabot> Terminated
16:20:23 <EvilTerran> hehe
16:20:30 <EvilTerran> ?type forever
16:20:31 <lambdabot> Not in scope: `forever'
16:20:38 <EvilTerran> hm.
16:20:39 <phobes> wli:  Does fail always equal mzero?
16:21:09 <EvilTerran> fail takes a paramete
16:21:18 <twanvl> forever :: m a -> m b; forever x = x >> forever x
16:21:27 <phobes> EvilTerran: oh
16:21:29 <EvilTerran> aha
16:21:47 <hpaste>  povman pasted "(no title)" at http://hpaste.org/5474
16:21:53 <povman> ^ UH
16:22:21 <matthew-_> are type contexts on newtypes a bad idea for any reason?
16:22:28 <EvilTerran> povman, class constraints on data declerations almost certainly don't do what you want
16:22:43 <povman> Why not?
16:23:02 <EvilTerran> well, it means you have to mention the class constraints everywhere you use the type, basically
16:23:06 <EvilTerran> which is a bit of a pain
16:23:19 <povman> eh - can't it 'deduce' it throughout?
16:23:21 <bos> worse, it means you can't turn your type into a Functor or Monad
16:23:29 <twanvl> they fixed that for GADT style declarations, there it does mean what you think it means
16:23:29 <bos> or other typeclass
16:23:34 <hpaste>  EvilTerran annotated "(no title)" with "like so (i *think* this should work)" at http://hpaste.org/5474#a1
16:24:02 <EvilTerran> povman, sadly not. i'm sure there's a good reason, but it escapes me.
16:24:06 <povman> EvilTerran: Yes that does work - i was just surprised
16:24:32 <povman> anyway i'm glad i've not gone insane :p
16:24:33 <EvilTerran> yeah. you and everyone else who hits that oddity
16:25:50 <povman> twanvl: what's a GADT style declaration?
16:26:00 <joglala> Hmm.. i now renamed fmap to something, and it complies
16:26:24 <EvilTerran> povman, oh, you can't help that. we're all mad here. I'm mad. You're mad. You must be, or you wouldn't've come here.
16:26:40 <EvilTerran> @paste - joglala, can we see your code?
16:26:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:26:53 <twanvl> data Show a => Tree a where Branch :: Tree a -> Tree a -> Tree a; Leaf :: a -> Tree a
16:27:21 <EvilTerran> twanvl, ITYM data Tree a where Branch :: Show a => Tree a -> Tree a -> Tree a; Leaf :: Show a => a -> Tree a
16:27:35 <twanvl> EvilTerran: I'm not sure, possibly
16:27:43 <EvilTerran> you can't put contexts where you did in GADT decls, IIRC
16:28:14 <hpaste>  jogla pasted "mapTree" at http://hpaste.org/5475
16:28:19 <joglala> It really works
16:28:20 <joglala> cool
16:28:23 <EvilTerran> unfortunately, that version conveys *less* information to the typechecker than you'd like, rather than more (as in the normal version)
16:28:44 <phobes> Do you need the (show a =>) gaurd?
16:29:05 <hpaste>  EvilTerran annotated "mapTree" with "(no title)" at http://hpaste.org/5475#a1
16:29:09 <phobes> Can't you just remove it and only get an error if you try to show something where it's not defined?
16:29:21 <EvilTerran> phobes, indeed, but i'm trying to translate as directly as possible here
16:29:48 <EvilTerran> with my version, it's impossible to construct a value of type Tree a where there's no Show a instance
16:30:06 <phobes> right
16:30:08 <EvilTerran> unfortunately, the typechecker can't use this, as it's got to take bottoms into account too
16:30:41 <phobes> eh?
16:31:03 <EvilTerran> (undefined :: Tree ThisTypeHasNoShowInstance)
16:31:03 <joglala> Hmm
16:31:20 <EvilTerran> joglala, i forgot to change a couple of those mapTrees to fmaps; you get the idea, i'm sure
16:31:32 <joglala> yes, thank you
16:31:58 <EvilTerran> phobes, in that you can't then mention Tree a in a type signature and have the Ord a constraint enforced automagically
16:32:09 <EvilTerran> er, s/Ord/Show/, i'm not awake :P
16:34:51 <hpaste>  povman annotated "(no title)" with "Indeed, this works!" at http://hpaste.org/5474#a2
16:35:51 <povman> that's a bit scary.
16:37:02 <povman> I must learn more about haskell's type system.
16:37:15 <hpaste>  EvilTerran annotated "(no title)" with "and now... the "normal" way of doing it" at http://hpaste.org/5474#a3
16:38:23 <povman> eh the normal way is just a longer version of the second way
16:38:49 * bos has submitted two haskell-related talk proposals for oscon this year.
16:39:01 <EvilTerran> well, it's a bit different
16:39:09 <povman> it has a different show
16:39:21 <EvilTerran> with "the normal way", you can construct values of type Tree a which you can't then show
16:40:11 <EvilTerran> this might be useful, but then again it might not
16:40:27 <EvilTerran> i'd think it would be; what happens if you want to make a tree of functions?
16:40:38 <povman> ah
16:41:10 <EvilTerran> so better to say "in order to be able to show a (Tree a), you gotta be able to show an a" rather than "in order to construct a Leaf x, you've gotta be able to show x"
16:41:21 <EvilTerran> or whatever
16:41:34 <povman> i suppose so.
16:41:54 <povman> thanks
16:42:55 <povman> actually atm I'm playing with an idea similar to Vital
16:43:37 <ddarius> :t guard
16:43:41 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:43:50 <Cale> @version
16:43:50 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
16:43:50 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:44:00 <Cale> Someone recompile it already! :)
16:47:23 <proq> does anyone know what amount of disk space haskell takes up typically? I'm looking into putting it onto a device without much breathing room
16:47:58 <dons> which haskell implementation?
16:48:00 <Cale> proq: Depends on the implementation you're talking about.
16:48:09 <proq> oh, ghc
16:48:15 <dons> ghc, oh ,  30M?
16:48:24 <dons> that's for the compiler though
16:48:44 <monochrom> my ghc and lots of libraries total to 305M.
16:48:44 <dons> you want the compiler and full libraires on the device??
16:48:59 <dons> or just some ghc-compiled haskell program?
16:49:17 <proq> hmm.. maybe I could configure it to partly use external media as well for some of the libs
16:49:18 <monochrom> hugs is about 4M.
16:49:31 <proq> maybe hugs is the way to go then
16:50:10 <monochrom> The next generation of iPod Touch will be large enough to hold ghc without too many libraries. :)
16:50:26 <dons> proq: you actually want a haskell development environment on the small device?
16:50:37 <conal> monochrom: wow -- how much mem is that?
16:50:40 * ddarius loads GHC onto his cell phone.
16:50:42 <dons> i.e not just targetting it from some other device?
16:50:58 <monochrom> Today's iPod Touch is 8GB or 16GB.
16:51:11 <monochrom> Err, I guess ghc already fits there today. :)
16:51:19 * monochrom goes back to kindergarten.
16:51:34 <conal> monochrom: what's the next gen have?
16:51:35 <dons> heh
16:51:55 <monochrom> It's anyone's guess that each generation doubles the previous, or something.
16:52:07 <conal> oh, yeah
16:53:27 <hpaste>  jogla pasted "unification would give infinite type" at http://hpaste.org/5476
16:53:33 <joglala> I cannot see my mistake
16:54:03 <joglala> data Tree a = Empty a | Node a (Tree a) (Tree a) deriving Show
16:54:06 <joglala> I forgot this line
16:54:26 <joglala> Haskell does not like both variants
16:54:56 <monochrom> Is x a tree? Is y a tree?
16:55:11 <vincenz> no wonder
16:55:13 <vincenz> x is not a tree
16:55:17 <vincenz> x is the value
16:55:18 <vincenz> look
16:55:20 <dons> joglala: usually Empty doesn't contain an 'a'
16:55:23 <vincenz> Node _a_ (Tree a) (Tree a)
16:55:29 <joglala> Ohh
16:55:31 <dons> you store the 'a' in the Nodes, not the Empties
16:55:32 <vincenz> isPath ds x
16:55:34 <vincenz> !!!
16:55:40 <joglala> Thank you
16:55:42 <vincenz> that should be y nd z
16:55:44 <joglala> I did not see that
16:55:45 <vincenz> not x and y
16:55:52 * dcoutts_ adds 18 new and 9 updated packages from hackage to the gentoo haskell overlay 
16:56:24 <dons> nice
16:56:49 <dons> dcoutts_: pcre-light too? its needed for the kate-highlighting package, which is needed for pandoc, which is a nice general tool we should be promoting
16:56:50 <dcoutts_> it annoys mes that we let packages be uploaded that do not build with ghc-6.8 and have broken haddock docs
16:56:59 <dcoutts_> dons: yep
16:57:20 <dcoutts_> kate-highlighting isn't on hackage yet though right?
16:57:29 <dcoutts_> I don't recall seeing it
16:57:39 <conal> dcoutts_: btw, have you heard anything lately on hackage and haddock 2?
16:58:00 <conal> i'd love for my libs to have working docs on hackage again.
16:58:04 <dcoutts_> conal: last I heard it could not be used because too much stuff did not work
16:58:15 <dcoutts_> conal: check with waern and Ross
16:58:16 <waern> conal: there's a bug that needs to be fixed for that to work, which I need to talk to Simon M about
16:58:19 <conal> dcoutts_: sigh.  thx.
16:58:40 <conal> waern: oh.  i hope it works out.
17:04:06 <olsner> @quote
17:04:06 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
17:04:12 <dcoutts_> @seen pejo
17:04:12 <lambdabot> pejo is in #haskell. I last heard pejo speak 11h 53m 50s ago.
17:04:59 <olsner> conal: btw, I extended the markdown/geshi hack you found to support literate haskell
17:07:12 <conal> olsner: neat :)  i'd like to try it out.
17:07:38 <olsner> http://olsner.se/2008/02/05/literate-haskell-blogging/
17:07:39 <lambdabot> Title: unsafePerformHack » Literate Haskell Blogging
17:08:32 <cjb> olsner: awesome!
17:09:09 <seydar> functional programming is like one giant drug rush
17:09:12 <seydar> and its AWESOME
17:09:28 <sarehu> oh, so you're a drug user, eh?
17:09:47 <olsner> seydar: don't forget that it's also WIN
17:10:15 <Cale> olsner: he's... already gone
17:10:39 <olsner> wow, drive-by praise?
17:11:06 <Cale> apparently
17:11:41 <lament> olsner: nice, finally literate haskell is useful for something!
17:11:56 <eugman> Is there any source of rather simple haskell programs I could decompose and try to understand their workings?
17:12:30 <olsner> lament: isn't literate haskell blogging a known concept? I'm pretty sure I've seen it before at least
17:12:33 <sarehu> eugman: there's the Prelude and libraries given in the standard
17:12:58 <sarehu> they aren't complete 'programs', if that's what you're looking for
17:13:12 <lament> olsner: also, join #esoteric.
17:13:15 <olsner> although those blogs might've entailed manual markup of the literate haskell source
17:13:44 * qwr . o O ( you could write some simple haskell programs and try to understand them :P )
17:14:30 <ddarius> Non-literate Haskell blogging is pretty rare
17:14:42 <monochrom> eugman: http://www.haskell.org/haskellwiki/Simple_unix_tools has some
17:14:44 <lambdabot> Title: Simple Unix tools - HaskellWiki
17:15:04 <lament> most blogs i've seen were illiterate...
17:15:20 <eugman> thanks. I know I need to just start coding if I want to learn haskell but it helps being able to look at simple ones.
17:16:31 <olsner> and sigfpe blogs multiliterately: "This post is simultaneously Python and literate Haskell."
17:17:43 <LoganCapaldo> I did a this post is simulataneously ruby and haskell
17:17:49 <LoganCapaldo> but mine didn't do anything
17:17:54 <LoganCapaldo> and was ugy as sin
17:17:59 <LoganCapaldo> *ugly
17:18:11 <monochrom> I knew of one single file that was valid in ten languages (or something) and did the same thing throughout.
17:18:28 <olsner> yeah, the hello world in umpteen languages is a classic
17:18:37 <eugman> monochrom: i'd imagine the languages chosen would have a strong efefct on the affect on that.
17:18:43 <LoganCapaldo> yeah I'm not cool enough to make a real polyglot program
17:18:59 <eugman> I find quines more interesting than polyglots
17:19:17 <eugman> I'd love a biquine that goes from one language to another.
17:19:27 <eugman> and then back
17:19:53 <olsner> there's one of those from C to Lisp (C code is a lisp interpreter that when run on itself prints the C/Lisp code)
17:19:56 * BMeph wants to make a program that's simultaneously FORTH and ...bah, who is he kidding? ;p
17:19:59 <vincenz> olsner: links are always nice
17:20:09 <LoganCapaldo> related to that, this is something someon came up with in #ruby-lang, print("Just another ", 0 ? "perl" : "ruby", " hacker\n");
17:20:17 <ddarius> Forth and Cobol
17:20:28 <LoganCapaldo> err flip those branches
17:20:31 <LoganCapaldo> if you care
17:20:32 <lament> i wrote an awesome polyglot once (z5 and befunge), and then i lost it :(
17:20:33 <LoganCapaldo> hehe
17:20:44 * vincenz has a polyglot post on C+haskell
17:22:40 <olsner> vincenz: http://paste.lisp.org/display/41318
17:23:10 <olsner> it's from ioccc, but I can't seem to find the entry on the ioccc web site
17:23:12 <vincenz> olsner: neat
17:32:23 <ctkrohn> Hey, I'm trying to set up fastcgi to play around with web programming.  I pulled a clean copy from Darcs... when doing runghc Setup.lhs configure, I get an error: Setup.lhs: fastcgi.cabal:12: 'Executable' stanza starting with field 'flag small_base description'
17:32:39 <ctkrohn> Any thoughts?
17:32:52 <Cale> ctkrohn: Maybe cabal version problem?
17:33:03 <Cale> ctkrohn: Which version of Cabal are you running?
17:33:08 <Cale> ghc-pkg list Cabal
17:33:12 <ctkrohn> hm, I will look into it.  I am running whatever comes with stock apt-get install in Ubuntu
17:33:21 <Cale> ah, so that's probably too old
17:33:25 <ctkrohn> 6.6.1
17:33:36 <ctkrohn> er wait
17:33:41 <ctkrohn> Cabal-1.1.6.2
17:33:41 <Cale> Yeah, I think 6.6.1 comes with Cabal 1.1.x or something
17:33:43 <Cale> yeah
17:34:10 <Cale> I think the flag syntax was introduced in Cabal 1.2.x
17:34:19 <ctkrohn> hm, I suppose I should try getting a ghc 6.8.2 install anyway
17:35:27 <scook0> @type error
17:35:28 <lambdabot> forall a. [Char] -> a
17:35:40 <Cale> ctkrohn: You can just download the generic linux binary, and it'll work fine.
17:36:14 <ctkrohn> k, thanks, I'll give it a try
17:37:27 <ctkrohn> last time I played with haskell was a year ago or so... hopefully the web programming situation has improved since then
17:40:26 <proq> dons: yeah, I've got scheme, elisp, lua and ruby on my zaurus, and hugs on there would be great. having compilers on it makes learning infinitely easier with my schedule
17:40:36 <dolio> If not, there's always Arc. :)
17:41:25 * Cale considers patenting the use of concurrency in the construction of a webserver.
17:42:00 <Cale> Surely if Paul can get away with patenting the use of continuations, I can patent the use of concurrency.
17:42:26 <araujo> is it arc already out?
17:42:27 <dolio> The amusing thing is that Arc violates the patent, since Yahoo owns it now. :)
17:42:34 <jeffz> ctkrohn: when you get the binary package, after installing you will need to do sudo ln -s /lib/libreadline.so.5 /lib/libreadline.so.4 if you want to run ghci else it complains
17:42:42 <proq> araujo: yes
17:42:47 <ctkrohn> jeffz: thanks for the tip
17:42:56 <jeffz> Cale: he didn't file the application, he says that they did it behind his back.
17:43:01 <araujo> proq, really?, link?
17:43:09 <Cale> jeffz: You don't so long as you get the right binary package.
17:43:15 <proq> http://arclanguage.org
17:43:16 <lambdabot> Title: Arc Forum | Arc
17:43:45 <proq> prepare to be disappointed  ^_^
17:43:46 <jeffz> Cale: the binary package for 6.8.2 will complain about missing readline.so.4, I've installed it several times.
17:44:10 <Cale> jeffz: There's an alternate one which is compiled against readline 5
17:44:30 <ctkrohn> I just grabbed the one at http://haskell.org/ghc/download_ghc_682.html#sources
17:44:32 <jeffz> ah, either that wasn't there when I first fetched 6.8.2 or I missed it
17:44:36 <ctkrohn> it says its compiled against libreadline5
17:45:08 <Cale> ctkrohn: You probably want the Linux (x86) one produced by Christian Maeder.
17:45:17 <scook0> @type fromJust
17:45:18 <lambdabot> forall a. Maybe a -> a
17:45:25 <Cale> (rather than the sources -- I suspect that's just a copy-o)
17:45:29 <jeffz> Cale: http://web.archive.org/web/20070205203914/paulgraham.infogami.com/blog/revenueloop
17:45:30 <lambdabot> http://tinyurl.com/2owqg7
17:45:55 <scook0> @type fromMaybe
17:45:56 <lambdabot> forall a. a -> Maybe a -> a
17:46:17 <jeffz> Cale: http://web.archive.org/web/20070204112041/paulgraham.infogami.com/blog/morepatents
17:46:17 <lambdabot> http://tinyurl.com/3xzfcr
17:46:47 <ctkrohn> Cale: yeah, I grabbed the binary package from further up the page from the #sources anchor
17:47:42 <ctkrohn> haskell is rapidly eating away at the free space on my asus eee...
17:48:52 <Cale> "the peristaltic actions of the lawyers continued regardless"
17:48:54 <Cale> haha
17:49:16 <monochrom> I beg to eat.
17:52:58 <mgsloan> so haskellers have been messing with gobby?  yeah, I figured out a while ago that undo/redo directly conflicts with collab..
17:52:59 <olsner> monochrom: a while ago, someone else also begged to eat here in #haskell
17:53:21 <dainanaki> yeah i was reading about gobby on reddit
17:53:24 <monochrom> That was also me. :)
17:53:32 <dainanaki> lol
17:53:38 <shachaf> mgsloan: Does it?
17:53:47 <olsner> heh
17:53:53 <shachaf> mgsloan: I think cjb said something about AbiCollab being abe to handle undo, in principle.
17:53:56 <shachaf> @seen cjb
17:53:57 <lambdabot> cjb is in #haskell. I last heard cjb speak 45m 24s ago.
17:53:58 <mgsloan> to some extent, as the blog post points out, it's the same problem as darcs
17:54:12 <dainanaki> i haven't ever done collab stuff with anyone before, so i'm not too knowledgeable
17:54:32 <mgsloan> me neither
17:54:40 <mgsloan> I've just been thinking about text editors recently
17:55:19 <dainanaki> it would be a nice extension to yi i would imagine
17:55:22 <jeffz> or emacs
17:55:25 <shachaf> cjb: Ping?
17:55:46 <dainanaki> or textmate
17:55:51 <dainanaki> :/
17:56:22 <dainanaki> i've been trying to sort out how bundle development works for it, because whoever initially made the haskell bundle has pretty much dropped it.
17:57:16 <shachaf> dainanaki: Maybe they switched to vim. :-)
17:57:56 <dainanaki> heh well, i've tried vim and emacs too
17:58:56 <dainanaki> and i preferred emacs, but i couldn't ever figure out how to get the assorted haskell  stuff to work in it on my mac.
18:00:51 <byorgey> undo in collaborative editors is exactly the same problem as darcs, only way simpler. =)
18:01:03 <mgsloan> oh?
18:01:29 <mgsloan> you could consider representing undo as a tree.  not throwing away command chains
18:01:37 <mgsloan> but perhaps that would complicate things
18:02:26 <byorgey> well, the patch-theory sort of approach is to represent the document as a series of patches to some starting document.
18:02:37 <dainanaki> you could create a tree datatype consisting of everyone's changes and your own changes...
18:02:38 <mgsloan> yep
18:02:52 <mgsloan> overall it would make for a very elegant collab system.  just realtime patch exchange
18:02:54 <vincenz> byorgey: there was work on this
18:02:58 <vincenz> byorgey: splatch
18:03:07 <byorgey> vincenz: really? interesting
18:03:10 <vincenz> yeah
18:03:10 * byorgey googles
18:03:17 <vincenz> I started hacking a bit on it this year at hac
18:03:19 <vincenz> it's nowhere yet
18:03:22 <vincenz> but the concepts are thre
18:03:59 <byorgey> cool
18:04:00 <vincenz> the idea is like darcs, that you factor stuff through changes
18:04:16 <byorgey> right
18:04:19 <dainanaki> it would be really cool to have that integrated with darcs somehow
18:04:51 <shachaf> dainanaki: Obby-style editing?
18:05:10 * shachaf would really like that integrated with hpaste somehow.
18:05:13 <phobes> it would be nice to have an IDE with nice version control integration
18:05:41 <dainanaki> it'd be really nice if one of these days the universal mythical haskell ide actually made any progress
18:05:59 <dainanaki> shachaf, i'm not familiar with obby
18:06:19 <dainanaki> don't suppose you meant gobby?
18:06:37 <mgsloan> obby turns out to be the collab lib they're basing gobby off of
18:06:39 <mgsloan> i think
18:06:45 <byorgey> mgsloan: that's right
18:06:49 <shachaf> mgsloan: And the protocol.
18:06:52 <mgsloan> yep
18:06:59 <byorgey> gobby is the gtk client
18:07:06 * mgsloan has been doing research of sorts
18:07:27 <Nafai> dainanaki: Yeah, I dream of having Yi been integrated with some of the lambdabot features and such to make it a great Haskell "IDE"
18:08:16 <conal> olsner: did you tweak your wp-syntax to assume haskell by default?  i forgot to mention that tweak on my blog.
18:08:16 <phobes> Is Yi pretty good to use yet?
18:08:54 <dainanaki> nafal, i agree. it'd be even more fantastic with code completion and a thing that would automatically do a graphviz chart of how everything connects
18:08:58 <olsner> conal: nope... just added that to the TODO list and forgot it ;-)
18:09:18 <olsner> the literate hack explicitly uses haskell for all "> "-lines
18:09:27 <conal> olsner: i can give you my tweak.  turned out to be easy.
18:09:28 <Nafai> dainanaki: Ooo..yeah
18:09:50 <dainanaki> i'd fiddle with it myself, but i'm very very weak at haskell
18:09:58 <Nafai> dainanaki: As sucky as it is, using Eclipse for my Java work has made me appreciate "language-aware" tools that do more than just syntax highlighting
18:10:24 <dainanaki> i never could manage to get the eclipse haskell plugin to work right either...
18:10:31 <olsner> heh, I seem to remember seeing ($var ? "txt" : $var) somewhere - I guess it's just changing that "txt"?
18:10:50 <lament> visual studio kicks ass
18:11:05 <phobes> Extensible language aware tools would be really nice
18:11:08 <dainanaki> lament, is it working for 6.8 releases?
18:11:16 <lament> heh heh
18:11:21 <vincenz> hmm
18:11:26 <vincenz> how do I accecss darcs.haskell.org
18:11:30 <lament> it works great for C# :)
18:11:31 <olsner> lament: kicks ass slowly with incredible resource consumption perhaps :P
18:11:38 <dainanaki> heh
18:11:50 <hpaste>  jogla pasted "calculate" at http://hpaste.org/5477
18:11:54 <conal> olsner: in markdown.php, just replace "txt" by "haskell"
18:12:39 <joglala> I wrote a method calculate, i want the varibale c contain either + or * and be interpreted as function.
18:13:08 <dainanaki> kind of off-topic a little bit... i'm just curious besides functional programming what lambda calculus is used for applied mathematics-wise?
18:13:09 <joglala> When there are no children, the root should contain a number, so that i can express mathematical terms with this tree
18:13:26 <ddarius> olsner: I've used some Java IDEs that were more resource hungry (or just non-responsive perhaps) and less usable.
18:13:39 <ddarius> I haven't used Eclipse, though (but I have no reason to)
18:14:09 <joglala> How can i tell haskell that c should be threadet as function?
18:14:18 <ddarius> dainanaki: Proof theory, type theory, it can be used anywhere you need a function
18:14:28 <olsner> eclipse is a gazelle compared to the other Java IDEs, but still requires quite a lot of resources
18:15:08 <phobes> Haskell needs a nice GUI framework
18:15:21 <dainanaki> ddarius, right, i get that, but i'm trying to find an example for someone that isn't really knowledgeable about lambda calculus that would make them think "oh wow!"
18:15:23 <joglala> phobes: Gtk ;)
18:15:38 <phobes> joglala:   I did say 'nice'
18:15:41 <lament> say what you like about c#, but VS has a great debugger
18:15:56 <lament> the haskell approach of never making any bugs works up to a point, of course
18:17:35 <joglala> Hmm.. i try to ask more generell, i have three variables, x = 1, y = 2 and z = +, how i can calculate 1 + 2 with these varibles?
18:17:57 <dainanaki> x `y` z ?
18:18:01 <uV> one can compose widgets out of bounding boxes and drawing primitives, up onto higher things. proably should be built right on cairo/opengl. i always get stuck at 'impleemnting a scenegraph' and 'what did i just click on' in 3d space
18:18:02 <ddarius> The debugger seems about typical of a "good" debugger, e.g. Borland C++ seemed to do much the same a decade ago.
18:18:13 <phobes> x 'z' y
18:18:17 <dainanaki> oops yeah
18:18:21 <dainanaki> that's what i meant :)
18:18:33 <phobes> err `
18:18:40 <joglala> Hmm
18:18:44 <LoganCapaldo> z x y would also be acceptable
18:18:45 <joglala> Backtick or normal tick?
18:18:50 <dainanaki> backtick
18:18:56 <ddarius> joglala: You don't need to do anything special.
18:19:09 <joglala> I think i got the order wrong
18:19:47 <dainanaki> shouldn't it be z = (+) ?
18:19:54 <ddarius> dainanaki: The applications to topology recently are fairly interesting.  I'm not sure who your target audience is.
18:21:30 <dainanaki> ddarius, it's a mathematics essay, but my advisor says that the grader won't be interested in lambda calculus unless i can provide a simple but powerful example of why it's useful.
18:21:57 <dainanaki> i'm kind of at a loss as to what might be particularly easy to understand and fascinating at the same time
18:22:04 <dainanaki> even though i think it is rather interesting
18:22:22 <LoganCapaldo> does it have to be original?
18:22:24 <ddarius> Type theory and proof theory are practically the study of lambda calculi
18:22:33 <hpaste>  jogla pasted "infinite type" at http://hpaste.org/5478
18:22:55 <joglala> This i the result with the z in front, haskell says it is an infinite type
18:23:08 <ddarius> The connections to logic and computer science should be more than enough to show that it is useful.
18:23:22 <dainanaki> LoganCapaldo, the example doesn't have to be my own as long as i cite it.
18:23:38 <sarehu> joglala: calculate (Node c x y) = c (calculate x) (calculate y)
18:23:53 <dolio> jogla: z :: a, c :: a -> a -> a ==> a = a -> a -> a
18:23:53 <sarehu> wait, nevermind..  hold on.. sigh, a moron I am
18:24:55 <joglala> Why must z == c+
18:24:56 <joglala> *?
18:25:05 <joglala> I want z to be a number and c to be function
18:25:16 <dolio> You'd need separate constructors for nodes holding a number and those holding a function.
18:25:21 <LoganCapaldo> oh
18:25:40 <dainanaki> ddarius, more specifically, the essay is on using lambda-calculus to optimize algorithms
18:25:49 <ddarius> Or stick an Either (Int -> Int -> Int) Int
18:26:27 <ddarius> dainanaki: Look at Olin Shiver and Matt Might's work on e.g. super-beta and kCFA and such.  In fact, just read both of their theses.
18:27:02 <ddarius> As well as many, many others, e.g. Appel's Compiling With Continuations.
18:27:20 <joglala> Node a (Tree a) (Tree a) | Node (f) (Tree a) (Tree a)
18:27:23 <dainanaki> great!
18:27:28 <joglala> He seems to doesn't like that too ;)
18:27:47 <ddarius> Simon Peyton Jones' Implementing Functional Programming Languages (or whatever) is old, but probably good as well
18:27:54 <dainanaki> i'm not tremendously familiar with higher-level mathematics, so I don't always know what i'm looking for
18:28:09 <joglala> Haskell really reminds me of Perl
18:28:29 <dolio> joglala: Those constructors both have the same name, and you want (a -> a -> a) instead of (f).
18:28:34 <ddarius> All the stuff I just discussed is straight computer science, not mathematics (higher or otherwise) at all.
18:28:53 <ddarius> (Except to the extent computer science and mathematics are related, which is to say, quite a bit.)
18:28:54 <olsner> > take`id`20$fix$(.)<$>(:)<*>((.((:[]).))(=<<).(*).(*2))$1 -- someone say perl?
18:28:57 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:29:19 <dolio> Wow.
18:29:47 <dainanaki> ddarius, the essay is supposed to be over mathematics
18:30:04 <olsner> (note the abscence of whitespace :P)
18:30:12 <dolio> That's not as good as dons' program with all the question marks, though.
18:30:16 <dolio> :)
18:30:28 <olsner> dolio: oh, link?
18:30:45 <thoughtpolice> http://www.cse.unsw.edu.au/~dons/pretty.html
18:30:46 <lambdabot> Title: pretty.hs
18:31:07 <ctkrohn> "pretty.hs", ha
18:31:27 <ctkrohn> that's disgusting...
18:32:38 <mightybyte> What kind of development environment is recommended for Haskell?
18:32:38 <olsner> I admit my attempt is pretty tame in comparison
18:32:48 <mightybyte> Anything better than screen+vim?
18:32:57 <vincenz> gvim :)
18:33:02 <mightybyte> lol
18:33:05 <joglala> dolio: What does it mean "both have the same name"?
18:33:06 <dainanaki> oisner, you have to admit you are pretty much being masochistic :)
18:33:08 <ddarius> dainanaki: Are you sure your essay is appropriate for your audience?
18:33:11 <Saizan> emacs+haskell-mode!
18:33:17 <mightybyte> vincenz: I don't actually classify that as better. :)
18:33:25 * wli uses the mighty combination of screen, zsh, nvi, make, and ghc.
18:33:25 <sarehu> emacs + haskell - factorial mode
18:33:29 <jeffz> mightybyte: emacs, two buffers side by side - eshell w/ ghci, and haskell-mode
18:33:30 <dolio> joglala: Both constructors are called "Node".
18:33:43 <olsner> dainanaki: yeah, there are much better ways of writing that... I was basically just aiming for doing it with as many operators as possible
18:33:53 <joglala> But my data structure has two kinds of notes too
18:33:55 <mightybyte> Is there ctags support for Haskell?
18:34:38 <Cale> mightybyte: There's hasktags
18:34:48 <wagle_> mightybyte, i dunno, but the haskell-mode in emacs has something similar
18:35:06 <Cale> which generates a number of forms of tag file for Haskell sources
18:35:20 <mightybyte> Cale: Does it work with vim?
18:35:21 <dolio> joglala: Presumably you want something like: 'data Tree a = OpNode (a -> a -> a) (Tree a) (Tree a) | NumNode a' (since it doesn't make sense for a number node to have children anyway).
18:35:48 <Cale> mightybyte: I'm fairly sure it would.
18:36:00 <joglala> dolio: Yes, Number Notes have no chlidren
18:36:09 <joglala> But i want them to have the same name :P
18:36:27 <dolio> Well, then, you can use ddarius' suggestion.
18:36:38 <thoughtpolice> last time i used hasktags it seemed to pick up some stuff that it shouldn't have, i.e. escape sequences and whatnot for constructs, etc.. but it was a while back.
18:37:00 <dolio> 'data Tree a = Node a (Tree a) (Tree a) | Empty' and then use the type 'Tree (Either (a -> a -> a) a)'
18:37:13 <dainanaki> ddarius, here's the title: Typed Î»-Calculus in Analytic Number Theory As a Means of Reducing Algorithmic Complexity for Functions. do you think it's inappropriate for a math paper?
18:38:51 <ddarius> dainanaki: I'd have to know how you are going about it, but you may want to look at synthetic topology and abstract stone duality.
18:39:37 <ddarius> dainanaki: You might find this interesting http://www.monad.me.uk/ASD/analysis.php#intawi albeit not directly related
18:39:38 <lambdabot> Title: Real Analysis in Abstract Stone Duality
18:40:27 <joglala> dolio: Where do i have to use it?
18:40:36 <dainanaki> ddarius, thanks a ton
18:40:47 <dainanaki> now i just have to figure out what all this means
18:41:00 <dolio> joglala: In calculate.
18:41:23 <dolio> joglala: calculate :: Tree (Either (a -> a -> a) a) -> a
18:42:19 <cjb> Off-topic politics stuff:  I'm using the channel gobby server (monad.printf.net) to transcribe a video Lawrence Lessig just put in support of Barack Obama, who I think is awesome:  http://lessig.org/blog/2008/02/20_minutes_or_so_on_why_i_am_4.html
18:42:21 <lambdabot> Title: 20 minutes or so on why I am 4Barack (Lessig Blog), http://tinyurl.com/2uc8ov
18:42:24 <joglala> Ahh, that tells haskell that the first paramater of tree may be of two different kinds?
18:42:39 <cjb> (And I'd really like your help, if you're interested in dividing the work.) </off_topic>
18:42:55 <dolio> joglala: Right.
18:43:24 <joglala> thank you :)
18:43:42 <dolio> joglala: No problem. Your equations will be slightly different too.
18:43:59 <joglala> Yes, i wonder how
18:44:09 <dolio> joglala: Numbers will be of the form (Right z) and functions (Left c).
18:44:17 <joglala> Ahh
18:44:18 <joglala> Cool
18:45:39 <dolio> Man, qtHaskell has some amusing documentation.
18:45:49 <wagle_> is there a quick definition of what >synthetic< topology is?
18:46:23 <joglala> dolio: It seems that makes him don't like my Empty = 0 any longer
18:46:53 <dolio> joglala: Can you annotate your example with your new code?
18:47:28 <keseldude> hi I just finished building lambdabot with ghc 6.8.2, but a few things don't work - would anyone be able to help me fix them? The bot is in #keselbot
18:47:36 <hpaste>  jogla pasted "Empty seems not to match the definition" at http://hpaste.org/5479
18:48:38 <dainanaki> joglala, 0 is a Num
18:48:55 <dolio> joglala: Oh. I know why. If you're using 0, then the type is: 'Num a => Tree (Either (a -> a -> a) a) -> a'
18:49:03 <dolio> Because the as have to be numbers.
18:49:08 <dainanaki> exactly
18:49:14 <ddarius> wagle_: What you get when you try to make the category Top of topological spaces be cartesian closed.
18:49:39 <vincenz> @join #oasis
18:49:45 <joglala> Wow
18:49:47 <joglala> Thank you both
18:49:55 <joglala> it compiles now :)
18:50:01 <dolio> joglala: (And in the future, you can click the 'annotate' link in the original paste to attach the new code to the old stuff.)
18:50:08 <joglala> Ahh, ok
18:50:19 <dainanaki> haha this is the first time i've been useful at helping someone fix something
18:50:26 <dainanaki> (in haskell)
18:51:22 * conal high-fives dainanaki 
18:51:43 * dainanaki does a little dance
18:52:55 <dainanaki> unfortunately, monads still confuse me
18:53:05 <dainanaki> win some, lose some
18:53:43 <dolio> The secret to monads is to figure out that there isn't much to them.
18:53:55 <ddarius> dolio: That's the secret to everything.
18:54:04 <dainanaki> yeah they don't scare me
18:54:09 <dolio> Well, I'm right, then. :)
18:54:27 <dainanaki> and within do notation it's not tough
18:54:37 <dainanaki> but once you get into << and stuff...
18:54:48 <dainanaki> i don't really know what's going on
18:54:49 <ddarius> do notation is a very light syntactic sugar
18:55:03 <LoganCapaldo> @undo do { x <- g ; return (y x) }
18:55:03 <lambdabot> g >>= \ x -> return (y x)
18:55:08 <ddarius> It's only slightly cleaner than using the combinators in a (stylized) manner.
18:55:27 <dainanaki> i don't get combinators either though :)
18:55:58 <dainanaki> folds, function composition, list comprehensions, and so on make sense
18:56:07 <LoganCapaldo> combinators are just a another name for functions.
18:56:13 <dainanaki> ah
18:56:33 <joglala> If i don't use numbers and +/* for c, but instead +/* and thinks like \x y -> 3, how would that change things?
18:57:04 <mgsloan> combinators usually seem to refer to higher-order operators
18:57:07 <joglala> \x y -> 3 should match Int -> Int -> Int, but Haskell does not even allows me to complie the code without the either
18:57:17 <mgsloan> eg, functions represented with symbols, which operate on functions
18:57:26 <dainanaki> ok well can you guys help me figure out how to rewrite this little bit of imperative pseudocode real quick?
18:58:05 <dolio> I think the technical definition of a combinator is something like, "a function that doesn't reference any free variables."
18:58:07 <LoganCapaldo> yeah but that's all these too it. there's no "Is this a combinator" checklist, it's more about how it's typically used than anything else
18:58:34 <dainanaki> x = 4; f1(y) returns (y/x); f2(x) sets x to 0;
18:59:17 <dainanaki> so here's the program thingy: f1(1); f2(x);
18:59:55 <dainanaki> how would you do that without do notation?
19:00:20 <dolio> joglala: I'm not sure what you mean. You should be able to put \x y -> 3 in the tree, but if you're doing the same type of tree as in calculate, it'd be: 'Node (Left (\x y -> 3)) l r'
19:01:31 <joglala> Hmm
19:03:08 <joglala> why | r?
19:03:35 <dolio> I just put l and r in the for left and right children of the node.
19:03:50 <joglala> ahh, ok
19:05:40 <joglala> (Node (Left(*)|r)
19:05:48 <joglala> (Node (Right(\x y -> 2)|l)
19:05:50 <joglala> Is that right?
19:06:29 <LoganCapaldo> no |
19:06:33 <dolio> No, not pipes.
19:06:39 <LoganCapaldo> l = lowercase L
19:06:48 <LoganCapaldo> get yourself a better font <g>
19:06:52 <dolio> Node (Left (*)) leftChild rightChild
19:07:08 <dolio> And Right is for numbers.
19:07:23 <dolio> Node (Right 2) leftChild rightChild
19:07:30 <dolio> Although in that case they should both be Empty.
19:07:52 <joglala> Ahh
19:08:42 <joglala> That works :)
19:08:56 <joglala> Can i make it work with thinks like \x y -> 2 too?
19:09:06 <joglala> Instead of the number 2?
19:09:08 <Cale> Could someone remind me how one is supposed to install the ShowQ and ShowFun modules in lambdabot?
19:09:58 <LoganCapaldo> with a large crow bar I imagine
19:10:39 <Saizan> Cale: i think it's "keep .hi and .o in $CWD"
19:11:36 <BMeph> joglala: Just curious, but what do you think (\x y -> 2) is? Not trying to put anyone down, I'm honestly curious.
19:12:13 <Cale> Saizan: So  ghc -c ShowQ.o ShowQ.hs ?
19:12:39 <Cale> I'd have thought it'd be dealt with by cabal...
19:14:05 <Saizan> Cale: it's done by the ./build script
19:14:15 <LoganCapaldo> @type const . (const 2)
19:14:17 <lambdabot> forall b b1 a. (Num b) => a -> b1 -> b
19:14:35 <Cale> Saizan: ah, aha
19:14:41 <LoganCapaldo> @type \x y -> 2
19:14:42 <lambdabot> forall t t1 t2. (Num t2) => t -> t1 -> t2
19:14:47 <joglala> BMeph: I thougt it does maybe work without Either because its similar to Int -> Int -> Int but i'm appearently wrong
19:15:20 <LoganCapaldo> > (\x y -> 2) (Left "a") (Right True)
19:15:24 <lambdabot>  2
19:15:44 <joglala> I know
19:16:44 <BMeph> joglala: Okay, but do yo uunderstand what the purpose of the "Left"/"Right" and "Either" all there for?
19:16:50 <BMeph> s/yo/you/
19:17:26 <joglala> I thougt the problem was that * is a function with the signature Int -> Int -> Int and 2 is only an Int
19:17:42 <joglala> Thats why i have Left (+/*) and Right (Numbers)
19:17:46 <BMeph> Ah! :)
19:17:54 <awesame> how do I explicitly import a data type?
19:17:55 <dolio> Are you asking if you can use 'Tree (a -> a -> a)' instead of 'Tree (Either (a -> a -> a) a)', with '\x y -> n' instead of 'Right n'? If so, then, yes.
19:18:09 <joglala> And i thougt \x y -> 2 is Int -> Int -> Int too, exactly like +/*
19:18:28 <joglala> dolio: That was my question :)
19:18:36 <wagle_> :t  \x y -> 2
19:18:36 <lambdabot> forall t t1 t2. (Num t2) => t -> t1 -> t2
19:18:37 <joglala> But it does not compile :/
19:18:44 <dolio> Ah, yes. Requires a different calculate, though.
19:18:58 <thoughtpolice> awesame: you mean you only import a data type from a module and nothing else?
19:19:04 <awesame> I want to import BufferMode from System.IO
19:19:36 <awesame> I'm currently importing some functions, like this: import System.IO (hFlush)
19:19:53 <thoughtpolice> importing it that way will only import hFlush and nothing else
19:20:00 <joglala> dolio: Only one line or completely different?
19:20:01 <thoughtpolice> just 'import System.IO' should import everything you need
19:20:13 <awesame> but when I add BufferMode to my list, the "LineBuffering" constructor doesn't seem to be available
19:20:16 <joglala> I'm making experiments with the second line
19:20:28 <LoganCapaldo> import System.IO (hFlush, BufferMode(..) )
19:20:33 <wagle_> eh, i didnt scrollback hard enough
19:20:43 <awesame> LoganCapaldo: double dots?  ok...
19:20:58 <dolio> joglala: Well, the type is different. And the non-empty case will be different, too.
19:21:08 <awesame> LoganCapaldo: thanks
19:21:18 <joglala> Hmm
19:21:23 <dolio> joglala: Note that with the new type, you only need one non-empty clause.
19:21:38 <Saizan> awesame: double dots means all the constructors, it's in place of a list of them
19:21:44 <joglala> ahh, cool
19:21:44 <dolio> Because numbers and operations on numbers are the same.
19:21:55 <dolio> It's just that 'numbers' throw away their arguments.
19:22:25 <awesame> Saizan: neat, ok
19:22:45 <wagle_> dolio, huh?
19:22:47 <wagle_> > 2 2
19:22:48 <lambdabot>   add an instance declaration for (Num (t -> a))
19:22:49 <lambdabot>     In the expression: 2 2
19:22:49 <lambdabot>  ...
19:23:07 <dolio> wagle_: He's representing 'n' as 'const (const n)'.
19:23:28 <joglala> I think i can just delete the second line
19:23:28 <wagle_> ok, sorry
19:23:46 <dolio> joglala: Yeah. And the Left in the third.
19:24:17 <joglala> :)
19:24:22 <joglala> Great, it works :)
19:24:30 <dolio> wagle_: Although, you can write a Num instance for 'Num a => t -> a' that will automatically lift numbers into constant functions that return numbers. :)
19:24:31 <BMeph> wagle_: Heh-heh, yeah, dolio's statement is talking about how joglala's tree structure represents numbers. :)
19:24:32 <joglala> Only two lines left
19:24:34 <LoganCapaldo> > const . const 3 $ 7
19:24:35 <lambdabot>  Add a type signature
19:25:24 <dolio> wagle_: So you can write stuff like: 'f = 1 + sin^2' or something like that.
19:26:11 <awesame> hey, how come Haskell errors sometimes pick type vars like a, b, c, and other times use t or a1?
19:26:40 <LoganCapaldo> because sometimes type annotatiosn have ben added, and othe rtimes they haven't (I think)
19:26:47 <LoganCapaldo> gah I can't type
19:27:25 <LoganCapaldo> > let { k :: a -> b -> a ; k x _ = x } in k + k
19:27:26 <lambdabot>   add an instance declaration for (Num (a -> b -> a))
19:27:26 <lambdabot>     In the expression:
19:27:26 <lambdabot> ...
19:27:39 <LoganCapaldo> > let { k x _ = x } in k + k
19:27:42 <lambdabot>   add an instance declaration for (Num (t -> t1 -> t))
19:27:43 <lambdabot>     In the expression:...
19:28:02 <joglala> Is there a program that gives me the type definition of a pattern?
19:28:24 <joglala> like foo a b = c, and then i get a -> b -> c?
19:28:40 <BMeph> joglala: Evaluate your pattern with a ":type" command.
19:28:42 <LoganCapaldo> :t let foo a b = c in foo
19:28:44 <lambdabot> Not in scope: `c'
19:28:49 <LoganCapaldo> doh
19:30:08 <hpaste>  dolio pasted "monadic numbers" at http://hpaste.org/5480
19:35:26 <joglala> combine [] x = x
19:35:41 <joglala> combine (f:fs) x = f(combine fs x )
19:36:03 <joglala> I f is a function a i don't know it, what is then the type?
19:36:15 <joglala> Can i say 'f' for the type?
19:39:46 <dolio> No. In a type signature, just having an unqualified 'f' means that whatever is typed 'f' can be any type.
19:39:58 <mgsloan> > () == ()
19:40:04 <lambdabot>  True
19:40:06 <mgsloan> :)
19:40:16 <joglala> :)
19:40:24 <joglala> Hugs says combine :: [a -> a] -> a -> a
19:40:41 <joglala> I cannot follow that
19:40:51 <dolio> Yeah, unless you're doing weird stuff, you shouldn't have to write out type signatures.
19:40:51 <joglala> It seems x must have the same type as f
19:41:02 <dolio> So you can see what gets suggested, and try to puzzle out why it gets that.
19:41:14 <joglala> Yes
19:41:22 <joglala> Isn't that a good training?
19:41:29 <scook0> joglala: if x has type a, then each f must have type a -> a
19:41:37 <dolio> Yeah, it's good practice.
19:41:53 <dolio> As for why it gets the type...
19:42:02 <joglala> Ahh, because f takes a and the next f, too
19:42:39 <joglala> Hmm.. no, f only takes combine fs x
19:42:47 <joglala> but never x itself
19:42:53 <joglala> Ahh
19:43:01 <joglala> Its late ;)
19:43:09 <dolio> Since 'combine [] x = x', whatever the result is must be the same type as x.
19:43:20 <dolio> So it's '[b] -> a -> a' for some b.
19:44:09 <joglala> Was haskels [a -> a] -> a -> a wrong?
19:44:12 <dolio> and 'combine (f:fs) x = f (combine fs x)', which must be of type 'a' to match x.
19:44:27 <dibblego> fmap f xs = xs >>= return . f  -- is there a name for this law?
19:44:38 <dolio> And 'combine fs x' is type a, as well.
19:44:53 <dolio> So f needs to take an a to a n a.
19:45:06 <dolio> So you get [a -> a] -> a -> a
19:46:39 <joglala> Cool, i think i understood
19:50:02 <awesame> how can I print an escaped string?
19:50:10 <awesame> so, with "\n" for newlines, etc
19:50:18 <dolio> > show "\n\n\n"
19:50:19 <lambdabot>  "\"\\n\\n\\n\""
19:50:40 <dolio> Well, that's twice escaped, thanks to lambdabot.
19:51:01 <awesame> but something like putStrLn show foo?
19:51:10 <dolio> print would do the same thing.
19:51:18 <dolio> @src print
19:51:18 <lambdabot> print x = putStrLn (show x)
19:52:10 <awesame> handy
19:52:30 <joglala> matrixCombine xs = combine (map combine xs)
19:52:45 <joglala> Why don't a need a second paramater for the first combine?
19:52:49 <scook0> could someone with GHC 6.8 do a quick build-test for me?
19:52:52 <scook0> darcs get http://code.haskell.org/bimap/
19:52:53 <lambdabot> Title: Index of /bimap
19:53:34 <thoughtpolice> scook0: building...
19:53:46 <thoughtpolice> worked fine. :)
19:53:53 <scook0> thoughtpolice: thanks
19:54:01 <dolio> Works here, too.
20:00:44 <brian`> hey, can someone explain me what closure is?
20:00:55 <brian`> i've read several definitions from the web
20:00:59 <brian`> but i'm still not clear...
20:01:04 <brian`> i heard that c doesn't have a closure
20:01:24 <brian`> but according to wikipedia's page, it sounds like c's nested routine is like a closure...
20:01:27 <brian`> isn't it?
20:01:28 <joglala> perl has closures :)
20:01:41 <mrd> it's not
20:01:55 <LoganCapaldo> theraist patient's have closure.
20:02:15 <brian`> "In some languages, a closure may occur when a function is defined within another function, and the inner function refers to local variables of the outer function." doesn't c's nested routine fit that explanation?
20:02:17 <mrd> C variable bindings only have dynamic extent.  you would need indefinite extent variables first thing.
20:02:29 <dolio> Long ago in Lisp land...
20:02:44 <mrd> if you returned the inner function from the outer function, then the variable bindings would simply disappear, in C
20:02:52 <brian`> well i mean standard c doesn't have nested routine i guess, but gcc can compile programs with nested routines... right?
20:03:02 <mrd> sorry, whenever I say C, substitute GCC
20:03:03 <joglala> In Perl its like the following: You have a function with a paramater "name" for example. If you call this method, it creates another method using this "name" variable and returns it.
20:03:26 <dylan> perl
20:03:27 <LoganCapaldo> mrd: eh you've just destoryed the closure by doing that ;)
20:03:28 <joglala> It returns e.g. the function that prints "Hello Thomas"
20:03:39 <dylan> perl's closures are just... normal.
20:03:44 <joglala> dylan: :P
20:04:45 <dylan> in that they just happen to have a lexical pad, so lexicals accessed from inside do what you would expect.
20:05:36 <dolio> brian`: The important thing with closures is that the function you pass around keeps a reference to the environment in which it's defined.
20:05:40 <mrd> brian`: a "closure" is an implementational technique to preserve lexical scoping rules when you have first-class function values
20:05:42 <brian`> are functions in c first-class values? since we can pass pointer to the function around?
20:05:48 <mrd> no
20:05:54 <mrd> the pointer is not the value
20:06:03 <mrd> it is a value, but not a function value
20:06:05 <brian`> hm.. ok
20:07:05 <dolio> Passing around nested functions in C will probably blow up if you pass them up the call stack, no?
20:07:17 <brian`> dolio, so according to your explanation, if there is a function f() { int i, j; function g() {blah} } and function g() is passed around, then you can access variables like i and j as well?
20:07:34 <dolio> brian`: Exactly.
20:07:39 <brian`> hm.. i c
20:07:46 <dylan> brian`: well, g() can access i and j
20:07:51 <brian`> wouldn't it complicate whole program a lot though?
20:07:52 <dylan> to be clear.
20:07:57 <wagle> dolio, if you are verry lucky, they will blow up..  usually they'll run, but incorrectly
20:08:17 <dolio> brian`: Or, importantly, it has access to the i and j where g is defined.
20:08:31 <mrd> so the fact that you can return a function pointer means that i, j will be invalid after that return
20:08:33 <dolio> brian`: In old-tyme Lisps, they instead had access to the i and j where g is *called*.
20:08:39 <mrd> because C does not have closures
20:08:56 <mrd> and neither did old-time (60s) Lisp
20:09:04 <wagle> mrd what do you want to call them, then?
20:09:04 <brian`> i c i c...
20:09:07 <bos> C also doesn't have nested functions.
20:09:17 <dylan> bos: but GCC does.
20:09:23 <mrd> again, whenever I say C, I am talking about GCC :)
20:09:27 <brian`> so what's so good about closure? what advantages are there by having a closure?
20:09:28 <bos> they're an ugly ill-specified hack.
20:09:31 <mrd> I'm just absent minded
20:10:00 <mrd> brian`: well, returning a function value and having it work correctly is nice
20:10:33 <brian`> mrd, do you have a nice and easy example that can help me understand better?
20:11:14 <mrd> currying is nice and pretty easy
20:11:35 <mrd> where you write a function which takes two arguments by: taking the first argument, and returning a function which takes the second
20:13:23 <mrd> it's convenient.  for example, in Haskell, you can write a function which adds 1 to a list of arguments simply by writing: map (+1)
20:13:35 <brian`> yeah
20:14:07 <mgsloan> however, difficulties arise when you have a function that returns two arguments.  to compose, you've gotta uncurry
20:14:32 <LoganCapaldo> luckily we have such a function in ze standard library
20:14:37 <dolio> > let delete n ls = filter (\x -> x /= n) ls in delete 2 [1, 2, 3, 4, 1, 2, 3, 4]
20:14:41 <mgsloan> indeed, by that very name :)
20:14:44 <lambdabot>  [1,3,4,1,3,4]
20:14:49 <LoganCapaldo> > uncurry (+) (4,5)
20:14:50 <lambdabot>  9
20:14:58 <sarehu> closures can always be replaced by specific objects that get interpreted a certain way.
20:15:12 <sarehu> The general advantage of closures is that you don't have to commit to using a specific kind of object
20:15:41 <LoganCapaldo> > uncurry uncurry ((+), (3,5))
20:15:42 <lambdabot>  8
20:15:48 <mrd> if you simply substitute the supplied argument for all occurrences of the variable in the code, you don't need closures
20:15:56 <mgsloan> LoganCapaldo: hah!
20:16:09 <mrd> however that's not generally regarded as an efficient implementation of a language =) plus it doesn't work outside of purely functional languages, really.
20:16:22 <brian`> hm.. ok
20:16:49 <brian`> @src uncurry
20:16:49 <lambdabot> uncurry f p = f (fst p) (snd p)
20:16:57 <mgsloan> haskell implementations have tricks for making it fast
20:17:40 <sarehu> For example, you might have a multithreaded program, with some thread that receives messages on a channel.  How would that thread indicate that it's done executing?  You might pass a thread-safe variable with the message, and have the thread set the variable to say it's done.  But what if one time you wanted to pass two variables or three?
20:18:22 <mrd> mgsloan: self-modifying code?
20:18:24 <Twey> @src forever
20:18:24 <sarehu> Instead, to avoid commiting your interface to receiving a single variable, you could have set it to receive a function that performs a specified operation.
20:18:25 <lambdabot> Source not found.
20:18:36 <mrd> forever x = x >> forever x
20:18:38 <Twey> Oh, oops.
20:18:42 <Twey> Aye
20:18:55 <Twey> It was defined, I just missed it :-P
20:18:59 <brian`> sarehu, if you want to pass two or three variables, can't you just pass a list?
20:19:17 <sarehu> And then that function could modify two variables (which two other threads are waiting on) or could modify three, or it could print a message to some channel, or do anything you wanted it to do
20:19:41 <mrd> callbacks are another easy example
20:19:47 <sarehu> Thus giving you much more flexibility.  You aren't committed to passing a variable or a list of variables, or some data structure that can contain many things.
20:20:12 <mrd> C libraries typically have some kind of "void * data" crap to pass additional data to a callback.  totally unnecessary with closures.
20:20:35 <Twey> dolio: CL today still has lexical scoping, just not by default.
20:20:43 <mrd> Twey: ?
20:20:51 <mrd> Common Lisp is lexically scoped
20:20:53 <dolio> Twey: Yeah, I know. You mean dynamic scoping, right?
20:20:57 <Twey> Er
20:20:58 <sarehu> Yeah.  You might implement closures using a hidden   void* data   package, too.
20:20:59 <Twey> Yes, I did.
20:21:07 <Twey> It's late :-P
20:21:14 <dolio> Thankfully that's not all it has anymore. :)
20:21:22 * Twey nods.
20:21:49 <BMeph> Please excuse my slow thinking - it's late...somewhere. ;)
20:22:02 <Twey> Heheh, damn, caught out :-P
20:22:19 <Twey> It's actually gone 0400 now.
20:22:23 <mgsloan> mrd - there's a structure that stores partial applications.  forgot what they're called. brainfart.
20:22:51 <mrd> trampoline?
20:23:48 <brian`> one more question, is static (lexical) link a technique to implement closure then?
20:24:07 <sarehu> The ability to make closures is exactly like the ability to construct lists with the values in scope. If you had a list [x,y,z] in your code, you'd expect it to take on the values of x, y, and z that are currently in scope.  The same goes for a function (\foo -> x + y + z + foo).
20:25:04 <Twey> brian`: Yes
20:25:20 <Twey> brian`: Example in Javascript: http://erxz.com/pb/6856
20:25:21 <lambdabot> Title: freenode_web paste from "Twey" at 71.6.194.243...
20:25:26 <brian`> Twey, oho.. i c.. i'm getting some clearer picture about closure now hehe
20:26:04 <Twey> brian`: (forgive the cruft, wasn't intended for you originally)
20:26:15 <brian`> Twey, that's fine :) thanks
20:27:10 <dolio> It's sort of the opposite, really.
20:27:29 <dolio> Static scoping refers is when functions reference variables where they're defined.
20:27:43 <dolio> Dynamic scoping is when they reference variables where they're called.
20:27:52 <dolio> And closures are a method of implementing static scoping.
20:29:33 <brian`> isn't lexical link a method of implementing static scoping as well? that's what i thought... thus lexical link and closures are more or less the same thing...
20:30:03 <dolio> Lexical scoping is another name for static scoping.
20:30:19 <brian`> dolio, ah.. ok
20:30:32 <mrd> i think he's talking about something else
20:30:37 <mrd> however my brain is getting rusty
20:30:55 <mrd> there's a trick where stackframes link back to previous ones with variables from outer scopes
20:31:18 <brian`> mrd, yeah that's what i was talking about.. that's lexical (static) link..
20:31:21 <mrd> i don't think that removes the need for closures though
20:31:40 <rdmltrs> hi
20:31:45 <dolio> Oh, I see.
20:31:56 <rdmltrs> has anyone had problems with runhaskell
20:31:56 <mrd> brian`: when the stackframe goes away, the variables may still need to exist
20:31:58 <sarehu> Is that really a 'closure' though? (If you're only pointing up the stack.)
20:32:05 <mrd> brian`: that is the meaning of 'indefinite extent'
20:32:06 <rdmltrs> i just installed ghc 6.8.2 on the olpc
20:32:07 <mrd> sarehu: no, it's not
20:32:34 <rdmltrs> but when i try to use runhaskell it says "cannot find ghc"
20:32:55 <thoughtpolice> rdmltrs: try just runghc?
20:33:20 <mrd> what does it say when you type 'ghc -v'
20:33:22 <rdmltrs> same thing
20:34:03 <brian`> maybe path variable is not set properly?
20:34:09 <jcreigh> @instances Ord
20:34:11 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
20:34:14 <rdmltrs> i have to type ghc-6.8.2 but it says its 6.8.2
20:34:32 <rdmltrs> i installed in /usr/local
20:35:08 <rdmltrs> i changed the path variable already to point to /usr/loca/bin
20:35:20 <rdmltrs> it shows up as ghc-6.8.2
20:38:34 <brian`> rdmltrs, hm.. that's weird... when you type ghc -v, it says "ghc-6.8.2", but when you type ghc it says cannot find ghc?
20:39:00 <rdmltrs> sorry i wasn't clear
20:39:22 <rdmltrs> when i type ghc it says command not found
20:39:28 <rdmltrs> when i type ghc-6.8.2
20:39:32 <rdmltrs> it works correctly
20:39:37 <brian`> oh.. ok
20:39:52 <brian`> then just create a soft link ghc linking to ghc-6.8.2 maybe?
20:40:04 <rdmltrs> err how do i do that>
20:40:39 <Cale> dons: are you around?
20:40:46 <brian`> ln -s /usr/local/bin/ghc-6.8.2 /usr/local/bin/ghc
20:40:50 <Cale> dons: (It is you who is running lambdabot, right?)
20:41:04 <rdmltrs> okay thanks
20:42:44 <jleedev> gtk2hs question: Is the function window_foreign_new exposed anywhere? I'm trying to write a screensaver
20:45:30 <dons> Cale: yo
20:45:33 <dons> ?bot
20:45:33 <lambdabot> :)
20:45:40 <Cale> @version
20:45:40 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
20:45:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:45:44 <Cale> Update!
20:45:53 <dons> okk!
20:45:55 <Cale> I pushed patches to make it compile on 6.8.2
20:46:00 <sarehu> what????
20:46:02 <sarehu> <3 <3 <3
20:46:07 <dons> awesome.
20:46:20 <dons> i think we need a new ghc on code.haskell.org then. hmm
20:46:43 <oerjan> Cale: do all the plugins work too?
20:46:51 <Cale> oerjan: As far as I can tell.
20:47:04 * oerjan does a happy dance
20:47:54 <Tac-Tics> I sentence the imperative heathens to death by category theory!
20:48:34 <sarehu> It is imperative that this sentence be carried out promptly.
20:48:34 <Cin> death by nomads :P
20:49:00 <dons> we must be effective!
20:49:01 <Tac-Tics> NomadT!
20:49:11 <wagle_home> ghc contains imperative code!  kill it!
20:49:11 <sarehu> Gomads
20:49:34 <sarehu> "Don't get mad, get monad!"  <- a good name for a monad tutorial
20:49:46 <Tac-Tics> hehe, it would be
20:50:06 <Tac-Tics> A monad is sort of like a box... full of monad tutorials...
20:50:08 <flippo> Don't be locally small.
20:50:20 <Cin> It takes nads to use monads.
20:50:28 <Cin> i'll get my coat
20:50:44 <oerjan> sarehu: categorically so?
20:53:23 <sarehu> oerjan: Change of plans.  Tomorrow at 1100 wake up and get online.  Be sharp.  Be sharp plus plus.
20:53:46 <Tac-Tics> Did you mean: C#? C++?
20:53:52 <monochrom> Hahaha
20:54:03 <Twey> Heh
20:54:20 <sarehu> hint: B# = C
20:54:36 <Tac-Tics> B# is merely isomorphic to C
20:54:52 <jleedev> enharmonic: the new isomorphic
20:54:57 <oerjan> Tac-Tics: no, shapr++ i think
20:56:39 <Tac-Tics> Definition. An enharmony is a morphism which is both epic, monic, and musical
20:57:10 <oerjan> not iso?
20:57:18 <goalieca> dammit
20:57:26 <goalieca> anyone else left alive?
20:57:29 <Tac-Tics> isomorphic doesn't rhyme with enharmonic like monic does
20:57:30 <dons> ?users
20:57:30 <lambdabot> Maximum users seen in #haskell: 471, currently: 366 (77.7%), active: 19 (5.2%)
20:57:37 <oerjan> ah
20:58:24 <Tac-Tics> I think more mathematical texts should use rhymes to aid in memorization
20:58:44 <flippo> I think mathematics shouldn't require much memorization.
20:58:45 <Tac-Tics> I will never forget what a parser type is because of that silly limeric on haskell.org
20:59:04 <Tac-Tics> flippo: you don't think so?
20:59:14 <Tac-Tics> ow again
20:59:18 <goalieca> owww
21:00:08 * Tac-Tics should take the time to learn wtf a netsplit actually is
21:00:34 <jleedev> Tac-Tics: contemplate the meaning of "relay chat"
21:01:32 <oerjan> Tac-Tics: er, the "seuss" one?  (which is not a limerick)
21:01:34 <Tac-Tics> jleedev: networks aren't my thing. I have only enough understanding of them to write a socketed application, and I keep myself in ignorance of the rest
21:01:51 <Tac-Tics> yes, the seuss one. Either way, it's excellent
21:02:31 <oerjan> Tac-Tics: it's when someone accidentally cuts a cable, like in Egypt recently
21:03:01 <flippo> Three cables to the middle east have been cut recently.  Very odd.
21:03:34 <sarehu> somebody must've done an unsafeCoerce
21:03:43 * Cin facepalms
21:04:32 <oerjan> Cin: feeling down and out?
21:04:44 <Cin> oerjan: no :P
21:04:53 <Cin> wrecking my brains over monads again
21:05:01 <Cale> More commonly when someone's server just disconnects from someone else's.
21:05:16 <Cale> Cin: Read my tutorials? :)
21:05:38 <Cale> (or have any specific questions?)
21:05:52 <Cin> Cale: "The Monadic Way"?
21:06:00 <phobes> You can read my monad tutorial:  Monads are like analogies
21:06:11 <jleedev> A simile is like a metaphor
21:06:18 <vincenz> Cale: your foldr drawing?
21:06:29 <Cale> Monads as Computation and Monads as Containers
21:06:40 <Tac-Tics> A monad is like a monad. And nothing else
21:06:41 <scook0> jleedev: a metaphor is a simile? ;)
21:06:51 <Tac-Tics> well, except functors and comonads and arrows
21:07:00 <wagle_home> "bailing your boat with monads"
21:07:31 <Cin> Cale: i understand the fairly trivial implementation of a monad in YAHT, it's just understanding how to really use them and the implications and so forth
21:08:13 <Tac-Tics> Cin: hint: except for IO, you don't ever *need* to use them. But for some applications, they is nice :-)
21:08:17 <Cale> Cin: http://www.haskell.org/haskellwiki/Monads_as_computation  has some discussion as to what they're really about
21:08:18 <lambdabot> Title: Monads as computation - HaskellWiki
21:08:53 <Cale> You don't even really need monads for IO. We just decided that IO should be a monadic library, because it helps to share code with other monadic libraries.
21:08:58 <wagle_home> cant you do unsafeIO?
21:08:59 <dejones> Cale: Are you a student or professor possibly?
21:09:12 <Cale> dejones: A student, sort of :)
21:09:20 <dejones> Cale: Do you do research with Haskell?
21:09:45 <Cale> Well, I did do one summer research term
21:09:45 <Cin> cale: i think i understand that. it seems to mainly be about keeping hold of state, and IO just happens to be easier with monads. is tha the case?
21:09:56 <dejones> Cale: sort of?  Elaborate...?  I'm searching for Doctorate programs using Haskell with Systems programming, mostly OS Kernels.
21:09:57 <Cale> But I'm more of a pure mathematics person
21:10:01 <dejones> Cale: Neat.
21:10:28 <Tac-Tics> Well, in *haskell* IO is your window to the world. Other languages can take other approaches, of course =-)
21:10:32 <Cale> Cin: Well, the "keeping hold of state" is a red herring.
21:10:32 <dejones> Cale: You just seem quite knowledgeable in Haskell, so I assumed you were probably a Doctorate student or professor.  ;)
21:10:37 <Cale> dejones: hehe :)
21:11:11 <Cale> Cin: read monads as computation, and it might help. Ask questions as they arise if you'd like :)
21:11:20 <Cin> i'll read it
21:11:50 <Cale> As far as functional programming is concerned a monad is just a particular style of library.
21:12:04 <Cale> (a pretty common style)
21:12:04 <Tac-Tics> It's not just that Cale knows his stuff, but he's so friendly and helpful about it =-D
21:12:24 <Cale> The point of the abstraction is that if you have a lot of libraries which look similar, you can write code that works in all of them.
21:12:29 <dejones> Tac-Tics: Very, very true.
21:12:40 <pjd> Cin: how much have you looked at functors?
21:12:59 <Cin> pjd: none at all
21:13:13 <pjd> Cin: it might help a lot too look at them first
21:13:54 <pjd> that is, the Functor instances for [], Maybe, IO, and so on
21:14:10 <Tac-Tics> @src IO fmap
21:14:10 <lambdabot> fmap f x = x >>= (return . f)
21:14:19 <pjd> heh, that doesn't help much :)
21:14:24 <rdmltrs> has anyone installed the GLFW package?
21:14:42 <rdmltrs> i'm trying to install it on the olpc but it complains about missing files
21:14:56 * Tac-Tics is still waiting on his olpc =-(
21:15:04 <pjd> Cin: once you grok Functor as a reference point, the jump to Monad is relatively small and (hopefully) self-evident
21:15:54 <pjd> @src Maybe fmap
21:15:54 <lambdabot> fmap _ Nothing       = Nothing
21:15:54 <lambdabot> fmap f (Just a)      = Just (f a)
21:16:00 <rdmltrs> dang
21:16:54 <Tac-Tics> fmap f is analogous to transforming a mild-mannered function into a cape-wielding superhero... function...
21:17:30 <pjd> Cin: look at the functor laws for fmap, and try to relate them to all Functor instances you're familiar with
21:18:55 <shachaf> > fmap calvin undefined undefined
21:18:55 <lambdabot>  "Stupendous man"
21:19:43 <Tac-Tics> buh?
21:20:08 <wli> fmap, join, and return
21:20:14 <Tac-Tics> > calvin undefined undefined
21:20:15 <lambdabot>   Not in scope: `calvin'
21:20:23 <wli> They're the essential aspects of monads.
21:20:39 <wli> springschool95.ps is a good paper there.
21:20:53 <Cin> so this (a -> b) -> f a -> f b, takes some type contained in another type, and changes it to a possibly different type contained in that same type?
21:21:01 <Cin> is the (a -> b) bit the functor?
21:21:12 <bd_> Cin: f is the functor
21:21:24 <bd_> (a -> b) is the transformation mapped onto the functor
21:21:27 <Cin> right
21:21:30 <dolio> f is the functor.
21:21:37 <bd_> you can see it in the type:
21:21:44 <oerjan> > fmap (+2) (Just 3)
21:21:45 <lambdabot>  Just 5
21:21:45 <bd_> fmap :: Functor f => (a -> b) -> (f a -> f b)
21:21:46 <Tac-Tics> > fmap (+1) [1,2,3]
21:21:46 <lambdabot>  [2,3,4]
21:21:57 <Tac-Tics> :t (+1)
21:21:57 <Tac-Tics> :t fmap (+1)
21:21:58 <lambdabot> forall a. (Num a) => a -> a
21:21:58 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
21:22:05 <Cin> oh i see
21:22:09 <Tac-Tics> (fmap adds the f's in there)
21:22:11 <bd_> :t fmap
21:22:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:22:22 <Tac-Tics> it "lifts" the function up into the functor type
21:22:57 <Cin> oh right
21:23:00 <Cin>  fmap f (Just x)   =  Just (f x)
21:23:00 <oerjan> > map (fmap (++" world!")) [Left "Hello, ", Right "Hello, "]
21:23:03 <lambdabot>  [Left "Hello, ",Right "Hello,  world!"]
21:23:05 <Cin> f is lifted inside Just
21:24:02 <Cin> :t liftM
21:24:02 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:24:15 <pjd> Cin: one way to think about it is that the functor is a type constructor of one variable, such as [a], (Maybe a), or (IO a)
21:24:31 <Cin> `m' is the functor in that case?
21:25:00 <Tac-Tics> yep (since all monads are functors)
21:25:00 <pjd> and fmap takes a function (a -> b), and uses it to "replace" the functor's a with b, in some sense
21:25:58 <Cin> right, i follow that
21:27:03 <phobes> Is every single variable type constructor a functor?
21:27:12 <oerjan> phobes: no
21:27:21 <Cin> `m' is * -> *, now the "monad" defined in YAHT is a function that takes a state and returns a pair of that state and a value
21:27:21 <phobes> oerjan: ok, that's my intuition
21:27:37 <oerjan> has to be covariant in the last parameter, at least
21:27:44 <phobes> oerjan:  Like, how do you make (a -> Nat) into one?
21:27:59 <oerjan> phobes: right, that's contravariant, so doesn't work
21:28:12 <pjd> phobes: you can make that into a contravariant functor, though
21:28:16 <oerjan> but (Nat -> a) does
21:28:21 <phobes> right
21:28:46 <phobes> pjd:  What's that?
21:29:06 <bd_> Cin: No, that's one specific monad :)
21:29:09 <bd_> Maybe's also a monad
21:29:25 <oerjan> cofmap :: CoFunctor f => (a -> b) -> f b -> f a, or something
21:29:27 <bd_> defined as such: Just x >>= f = f x; Nothing >>= _ = Nothing; return = Just
21:29:43 <phobes> oerjan:  makes sense
21:29:45 <Cin> bd_: right, i thought so. it doesn't really have to return a pair, it could return anything?
21:29:49 <shachaf> Cin: The monad isn't the function, it's the type constructor.
21:30:04 <bd_> or if you prefer: fmap f (Just x) = Just (f x); fmap _ Nothing = Nothing; fix (Just (Just x)) = Just x; fix _ = Nothing
21:30:23 <bd_> shachaf: More specifically, it's the instance associated with the type constructor
21:30:45 * shachaf would suggest that Cin look somewhere else for information on monads.
21:30:53 <shachaf> YAHT wasn't very helpful for me.
21:30:58 <shachaf> bd_: s/fix/join/g ?
21:31:02 <bd_> er
21:31:03 <phobes> Ya, Monad is a mathematical structure like Group or Vector Space
21:31:04 <bd_> yes
21:31:04 <bd_> doh
21:31:05 <Cin> well i'll read Cale's monads as computations
21:31:09 <ddarius> The most significant instance being (if it could be written): instance ContraFunctor (->a) where cofmap f = (. f)
21:31:10 <Cin> bbs
21:31:12 <bd_> "All about monads" is good
21:31:18 <shachaf> bd_: (And you still need return.)
21:31:50 <pjd> Cin: have you looked at fmap for IO?
21:32:07 <Cin> pjd: yeah
21:32:22 <cjb> For the curious, we finished the gobby Lessig/Obama transcript:  http://blog.printf.net/articles/2008/02/05/transcript-of-lawrence-lessig-obama-video
21:32:22 * shachaf would also not recommend starting with IO. :-)
21:32:23 <lambdabot> Title: Transcript of Lawrence Lessig Obama video., http://tinyurl.com/2xxb8m
21:32:31 <pjd> Cin: okay, so you're comfortable with fmap, at least?
21:32:31 <Cale> Cin: sorry I've been distracted :)
21:32:46 <Cin> pjd: i am
21:33:00 <pjd> Cin, okay, now the jump to monads :)
21:33:18 <pjd> Monad just adds two things to Functor
21:33:21 <shachaf> cjb: How are you doing with the monads, by the way?
21:33:28 <shachaf> cjb: Have you looked at State yet?
21:33:55 <gwern> Cale: did you look at google hits for mapAccumR in deciding how popular it is?
21:34:04 <Cale> gwern: no
21:34:13 <gwern> it looks to me like there are a few uses, but most of the hits are from library stuff
21:34:20 <pjd> return is simple:  it's just a way to lift values into the monad (functor)
21:34:25 <Cale> gwern: yeah
21:34:48 <Cale> gwern: I suspect part of its unpopularity might actually have to do with this confusing convention :)
21:34:59 <pjd> such that fmap f (return x) == return (f x), and so on
21:34:59 <cjb> shachaf: Glanced at some code that uses State, looked more indepth at Writer.  I don't feel so confused anymore, but I won't feel comfortable until I've used each.
21:36:01 <gwern> Cale: point is, I suspect you might as well push for the change to be made and folded into some already-disruptive upgrade. maybe haskell prime or ghc 6.10? (which will break stuff of course...)
21:36:21 <ddarius> :t mapAccumR
21:36:22 <pjd> Cin: next, you have join
21:36:24 <ddarius> :t mapAccumL
21:36:24 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:36:24 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:36:39 <ddarius> Well, that would explain it.
21:37:08 <vincenz> you wish
21:37:20 <pjd> Cin: say have function that returns a functor itself
21:37:31 <qmrw> a
21:37:47 <pjd> that is, of type (Functor f) => a -> f b
21:38:58 <phobes> shachaf:  You don't think starting with IO is a good idea?  That's what I did... that seems to me to be one of the best motivating examples for Monads
21:39:18 <pjd> :t (`lookup` [(1,"one"),(2,"two")])
21:39:19 <lambdabot> forall a. (Num a) => a -> Maybe [Char]
21:39:23 <shachaf> pjd: (Functor f) =>?
21:39:39 <Cin> shachaf: i think it means `f' implements fmap?
21:39:49 <pjd> Cin: such as that
21:40:14 <shachaf> Cin: Yes -- I don't think that function exists.
21:40:16 <pjd> Cin: now consider what happens when you fmap that against a functor
21:40:36 <pjd> shachaf: i was speaking loosely :P
21:41:05 <pjd> > fmap (`lookup` [(1,"one"),(2,"two")]) $ Just 1
21:41:07 <lambdabot>  Just (Just "one")
21:41:09 <pjd> > fmap (`lookup` [(1,"one"),(2,"two")]) $ Just 2
21:41:10 <lambdabot>  Just (Just "two")
21:41:12 <pjd> > fmap (`lookup` [(1,"one"),(2,"two")]) $ Just 0
21:41:13 <lambdabot>  Just Nothing
21:41:28 <pjd> > fmap (`lookup` [(1,"one"),(2,"two")]) $ Nothing
21:41:28 <lambdabot>  Nothing
21:41:51 <pjd> :t fmap (`lookup` [(1,"one"),(2,"two")]) $ Nothing
21:41:52 <lambdabot> Maybe (Maybe [Char])
21:41:57 <Cin> :t lookup
21:41:58 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
21:42:03 <pjd> you end up with Maybe inside a Maybe
21:42:20 <wagle_home> > Join (Just Nothing)
21:42:21 <lambdabot>   Not in scope: data constructor `Join'
21:42:30 <wagle_home> > join (Just Nothing)
21:42:31 <lambdabot>  Nothing
21:42:37 <pjd> Cin: another example
21:42:41 <pjd> :t fmap putStrLn getLine
21:42:42 <lambdabot> IO (IO ())
21:42:49 <wagle_home> > join (Just (just 1))
21:42:49 <lambdabot>   Not in scope: `just'
21:42:58 <wagle_home> > join (Just (Just 1))
21:42:59 <lambdabot>  Just 1
21:43:29 <pjd> the putStrLn returns an IO action "inside", or from, another IO action
21:43:59 <wagle_home> > join (fmap putStrLn getLine)
21:43:59 <lambdabot>  <IO ()>
21:44:22 <wagle_home> :t join (fmap putStrLn getLine)
21:44:23 <lambdabot> IO ()
21:44:26 <oerjan> > putStrLn =<< getLine -- equivalent
21:44:27 <lambdabot>  <IO ()>
21:44:47 <pjd> so this is where join comes in;  it "flattens" that kind of nesting, in a way that preserves the behavior of the functor/monad
21:45:45 <prb> Been bonking my head on Network.HTTP (simpleHTTP) not releasing file handles (lsof confirms); anyone dealt with it successfully?
21:45:47 <pjd> @src Maybe join
21:45:47 <lambdabot> Source not found. Maybe you made a typo?
21:45:58 <Cin> > (return putStrLn) "foo"
21:45:58 <lambdabot>  <[Char] -> IO ()>
21:46:02 <bd_> @src join
21:46:02 <lambdabot> join x =  x >>= id
21:46:04 <shachaf> pjd: join = (>>= id)
21:46:05 <oerjan> @src join
21:46:05 <lambdabot> join x =  x >>= id
21:46:06 <bd_> it's generic :)
21:46:11 <oerjan> (not a method)
21:46:11 <bd_> @. pl src join
21:46:12 <lambdabot> (line 1, column 1):
21:46:12 <lambdabot> unexpected end of input
21:46:12 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
21:46:16 <bd_> bah
21:46:32 <oerjan> @. echo src join
21:46:33 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "oerjan!n=oerjan@hagbart.nvg.ntnu.no", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@. echo src join"]} rest:""
21:46:40 <Cin> why are there brackets around <[Char] -> IO ()>?
21:46:42 <oerjan> wow
21:46:48 <pjd> bd_: i was looking specifically for the Maybe instance's join
21:46:50 <shachaf> Cin: It's a special Show instance.
21:47:05 <oerjan> ok, in any case @src does not play nice with the composition plugins :(
21:47:06 <shachaf> Cin: The action/function isn't really being executed/called.
21:47:08 <bd_> pjd: they're all the same :)
21:47:17 <bd_> but I wrote out a specialized version above
21:47:25 <bd_> join (Just (Just x)) = Just x; join _ = Nothing
21:47:34 <shachaf> oerjan: Try @. djinn type instead. :-)
21:47:41 <Tac-Tics> http://youtube.com/watch?v=9fohXBj2UEI&feature=PlayList&p=0E91279846EC843E&index=0
21:47:42 <lambdabot> Title: YouTube - Monads 1, http://tinyurl.com/2xr7u9
21:47:48 <bd_> @. djinn type join
21:47:48 <lambdabot> Cannot parse command
21:47:57 <Cin> shachaf: it's type is IO (IO ()) ?
21:48:07 <Cin> shachaf: and if it was IO () it would be called?
21:48:19 <shachaf> Cin: IO (IO ())?
21:48:27 <shachaf> Cin: What's type?
21:48:38 <Cin> shachaf: (return putStrLn) is IO (String -> IO) right?
21:48:49 <Cin> shachaf: so (return putStrLn) "foo" is IO (IO ())?
21:48:53 <pjd> Cin: (return putStrLn) "foo" is probably not doing what you expect
21:49:05 <oerjan> Cin: lambdabot > never calls IO actions
21:49:05 <shachaf> Cin: return (putStrLn "foo") is.
21:49:15 <shachaf> Cin: Then you can join it to get IO ().
21:49:36 <shachaf> Cin: You can't apply a function :: IO (String -> IO ()) directly, though; you have to fmap.
21:50:06 <shachaf> Cin: (>>=)ing is just fmapping and joining.
21:50:18 <Cin> shachaf: ahhh
21:50:40 <Cin> shachaf: i was wondering where pjd was going with the fmapping
21:51:20 <shachaf> Cin: The fmap/join/return monad explanation is much nicer than the (>>=)/return one, in many cases.
21:52:22 <phobes> fmap/join/return seems to make more sense to the category theory people
21:52:39 <shachaf> phobes: And to me. :-)
21:52:49 <pjd> Cin: for IO, you can intuitively think of join as chaining the two actions together
21:52:55 <oerjan> yep, join/return are natural transformations, fmap a functor
21:53:06 <shachaf> Look at Writer, for example.
21:53:08 <Cin> pjd: doesn't bind do that?
21:53:16 <oerjan> :t (=<<)
21:53:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:53:37 <Cin> :t join
21:53:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:53:46 <pjd> Cin: bind fmaps a function that returns a monad, and then joins them :)
21:53:47 <Cin> oh
21:54:23 <phobes> Thinking of IO with join seems more confusing to me than with >>=/return
21:54:25 <pjd> :t liftM
21:54:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:54:47 <pjd> Cin: compare the types of (=<<) and liftM (that is, fmap)
21:55:08 <shachaf> phobes: Then don't think of IO. :-)
21:55:25 <shachaf> phobes: Think of monads that you can implement. :-)
21:55:42 <phobes> shachaf:  well, IO or State
21:55:51 <shachaf> phobes: For example, Writer; return, fmap, join are all simple, but (>>=) becomes more complicated.
21:56:24 <pjd> (>>=) is more complicated in all cases, pretty much
21:56:49 <phobes> in all simple cases
21:56:54 <Cin> pjd: heh, i am slow at reading. bare with me. i understand =<<. it takes its `m a' type argument and somehow passes the `a' part to the `(a -> m b) function and returns that
21:56:58 <shachaf> Because it's two functions mashed into one.
21:57:05 <phobes> as things get more complicated, thinking in terms of >>= makes things much easier
21:57:33 <wagle_home> i'd like to know exactly when >>= and join/fmap arent interchangable
21:57:44 <pjd> wagle: never
21:58:00 <phobes> wagle_home:  They're always interchangable in theory - it's a question of viewpoint and which you can most easily write down
21:58:02 <wagle_home> i'd believe a professor over you, i think
21:58:17 <allbery_b> theoretically never.  practically, when something has a Monad instance but no Functor
21:58:21 <shachaf> wagle_home: m >>= f = join (fmap f m)
21:58:25 <mrd> proof by authority?
21:58:38 <wagle_home> it was just the case that the exceptions were bizarre and hardly ever seen in practice, or something
21:58:40 <pjd> wagle: you can *implement* them non-interchangeably, but then you're breaking the monad laws
21:59:08 <allbery_b> hm, actually ISTR there's something about (the usual) seq / _|_
21:59:11 <Cin> pjd: ah, and i now see what liftM. does. it takes a `m a1` and gives that a1 to (a1 -> r) and then puts r back in an `m'. forgive my terrible language
21:59:13 <wagle_home> well, you are just asserting it too
21:59:15 <allbery_b> which complicates things
21:59:25 <pjd> Cin: liftM == fmap, by the way
21:59:29 <shachaf> @quote laws.*monad
21:59:29 <lambdabot> Daveman says: Cale, what if I don't want to obey the laws?  Do they throw me in jail with the other bad monads?
21:59:49 <Cin> @src liftM
21:59:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:59:59 <phobes> What is join for State?
22:00:01 <pjd> Cin: they're only different because Functor and Monad happen to be separate classes
22:00:16 <Cin> pjd: ah, right
22:00:38 <Tac-Tics> > fmap (+1) [1,2,3]
22:00:40 <lambdabot>  [2,3,4]
22:00:42 <vincenz> mgsloan: ping
22:00:44 <Tac-Tics> > liftM (+1) [1,2,3]
22:00:44 <Twey> Daveman?  Here?
22:00:45 <lambdabot>  [2,3,4]
22:00:45 <Cin> pjd: how do you get a value out of a monad? as x1 <- m1 is doing up there?
22:00:45 <pjd> Cin: fmap could just as well have been called liftF
22:00:50 <Twey> Daveman: Well I never.
22:01:21 <phobes> Cin:  Do you understand continuations?
22:01:22 <Cin> pjd: right
22:01:24 <mrd> you never looked at the nickname list?
22:01:25 <Cin> phobes: sure
22:01:25 <pjd> Cin: the <- is do syntax for bind, really
22:01:32 <pjd> @undo do { x1 <- m1; return (f x1) }
22:01:32 <lambdabot> m1 >>= \ x1 -> return (f x1)
22:01:42 <Cin> pjd: i know that
22:01:46 <pjd> @. pl undo do { x1 <- m1; return (f x1) }
22:01:46 <lambdabot> f `fmap` m1
22:01:55 <pjd> there you go :)
22:02:05 <Cin> pjd: is  the `m1' some kind of closure that gives you back a value when you give it something?
22:02:07 <pjd> from liftM to fmap
22:02:19 <pjd> Cin: no, it's just a monadic value
22:02:40 <pjd> it could be a list, or Just 5, or getLine, or whatever
22:02:47 * wli would rather call fmap "map"
22:03:11 <pjd> the monad instance determines what happens
22:03:26 * wli would rather have Functor be a prerequisite for Monad
22:03:34 <mrd> if only Pandora had opened a monad, the bad things would have been simply 'return'ed
22:03:35 <Cin> pjd: how? isn't some function defined to say what happens?
22:03:35 <shachaf> wli: We would all rather that. :-)
22:03:42 <mrd> wli: or (.)
22:03:52 <shachaf> wli: Would you also rather (.) was fmap?
22:03:59 <pjd> Cin: yes;  that function is the monad instance's implementation of >>= :)
22:04:11 <pjd> and hence fmap/liftM/join/etc.
22:04:13 <shachaf> wli: And that $ was infixl? :-)
22:04:15 <wagle_home> the alphabetic name for >>= is bind?
22:04:16 <Pseudonym> do  lift (open box)
22:04:29 <wli> wagle: Yes.
22:04:30 <Tac-Tics> wagle_home: yep
22:04:30 <Pseudonym> unsafeOpenBox#
22:05:10 <phobes> What is join in terms of >>= and return?
22:05:20 <wli> shachaf: . should probably be something different, like something applicative-related. It's definitely meant to be more to do with functions.
22:05:29 <pjd> phobes: join = (>>= id)
22:05:32 <mrd> using (.) as the name for map, fmap, and liftM makes type inference error messages wonderful to decipher
22:05:35 <phobes> ah right
22:05:51 <pjd> i.e. fmap the identity function, and join
22:05:52 <wli> phobes: x >>= f = join (fmap f x) or something.
22:06:30 <wli> join = (>>= id) is so backward
22:06:36 <pjd> amen
22:06:59 <phobes> wli:  What's join for State?
22:07:07 <wli> phobes: Something hairy.
22:07:42 <wli> phobes: I smoked it out once. I don't remember it offhand.
22:07:45 <dolio> @unmtl State s (State s a)
22:07:45 <lambdabot> s -> (State s a, s)
22:07:52 <phobes> I like >>= and return because they expose computations
22:07:56 <cjb> wli: I think you're the only Haskell programmer-crossed-with-kernel hacker I know.  May I ask what you use Haskell for and such questions?  :)
22:08:40 <bd_> join (State f) = State $ \s -> let (State f', s') in f' s'
22:08:43 <bd_> or thereabouts?
22:09:23 <phobes> bd_:  Your let is malformed
22:09:28 <wli> cjb: I use Haskell for scripting-type things, I guess.
22:09:50 <Cale> mrd: Of course, we'd keep map as a prefix form of the same thing, so as to make some things easier to read. Having only (.) would get awkward.
22:09:52 <bd_> er
22:09:53 <bd_> yes
22:09:58 <bd_> join (State f) = State $ \s -> let (State f', s') = f s in f' s'
22:10:03 <bd_> I need sleep :)
22:10:39 <cjb> wli: neat.  anything public?
22:10:44 <Cale> join x = State $ \s -> let (y,s') = runState x s in runState y s'
22:10:46 <shachaf> > map length ["(.)","map"] -- :-)
22:10:47 <lambdabot>  [3,3]
22:11:03 <dolio> @type \ms = State $ \s -> let (ms', s') = runState ms s in runState ms' s'
22:11:03 <lambdabot> parse error on input `='
22:11:22 <dolio> @type \ms -> State $ \s -> let (ms', s') = runState ms s in runState ms' s'
22:11:22 <lambdabot> forall s a. State s (State s a) -> State s a
22:11:43 <wli> cjb: Mostly it's off-the-cuff math-type stuff, but there are a few things like a differential profiling postprocessor for readprofile(1) output and some other crap.
22:12:24 <wli> cjb: There's a grossly inefficient Grobner basis thing floating around somewhere.
22:12:39 <cjb> wli: Cool, thanks.
22:12:49 <Pseudonym> "Grossly inefficient Grobner basis" is redundant, isn't it?
22:12:59 <wli> cjb: I guess the "Fastest Fibonacci in the West" thing is floating around somewhere in a wiki, too.
22:13:35 <wli> Pseudonym: Relative to the field of extant Grobner basis solver implementations, not merely in absolute terms.
22:13:58 <Pseudonym> OK, "more inefficient than thou" I'll believe.
22:14:01 <wli> Someone somewhere wrote a more efficient one using a less naive algorithm.
22:14:52 <Cale> I wish I understood GrÃ¶bner bases better.
22:15:38 <wli> Cale: Understanding how to solve systems of polynomial equations with them is pretty easy.
22:16:00 <wli> Cale: Form syzygy polynomials, cancel, etc.
22:16:58 <Pseudonym> Must away.  Nytol!
22:19:15 <phobes> Ya, join doesn't make alot of sense to me for State
22:19:23 <phobes> I can work out that's what it has to be based on the types
22:19:25 <phobes> but I don't get it
22:20:18 <Cale> We touched on them in my rings course, but not enough to really understand what one could do with them. It possibly would make more sense now that I understand basic algebraic geometry.
22:20:20 <phobes> Is that a useful operation?  Would anyone ever use join on State in practice?
22:20:49 <Cale> phobes: Well, in some sense, it's built into the behaviour of >>= and you use it all the time.
22:21:00 <Cale> In another sense, it would be kind of rare.
22:21:13 <bd_> sometimes it's easier or more sensible to define monads in terms of join/fmap/return
22:21:25 <bd_> eg: join = concat; fmap = map; return = (:[])
22:21:27 <bd_> for lists
22:21:28 <wli> Cale: Basically there are two sorts of reduction steps. One is linear algebra using monomials as basis elements, and another is forming syzygy polynomials, which is just a sort of fraction-free Gaussian elimination sort of thing using indeterminates as factors and not just non-units.
22:21:29 <phobes> Cale:  If I wrote down the State Monad structure, it would be through >>= and return, and I'd never have thought to write down join
22:21:37 <bd_> sometimes it's easier with >>=
22:21:53 <bd_> they're equivalent mathematically... but haskell's type system forces you to use >>=
22:21:54 <wli> Cale: You alternate those two kinds of steps and blow it all away.
22:22:05 <shachaf> phobes: Try Writer.
22:22:36 <phobes> shachaf: ok
22:22:44 <dolio> @type State . curry (uncurry runState . uncurry runState)
22:22:45 <lambdabot> forall a s. State s (State s a) -> State s a
22:24:00 <wli> Cale: (Technically the linear algebra step isn't necessary but it saves time since you basically square the number of polynomials you're working with every time you take a syzygy polynomial formation step.)
22:24:23 <Cale> bd_: Well, really it's just the definition of the monad class which forces you to use >>=
22:24:40 <Cale> wli: That sounds familiar.
22:25:22 <wli> Even if you can't reduce the number of polynomials you can at least reduce their sizes.
22:25:35 <prb> Bonus difficulty on my HTTP question -- doesn't seem to happen on Linux; only on MacOS X (10.5).
22:26:27 <pjd> dolio++
22:26:34 <ski> `join' is what you need to turn an `Applicative' into a `Monad', it allows "inlining" an effect-dependent action into another action
22:26:52 * wagle_home hunts unsuccessfully for prb's question
22:27:26 <prb> Heh.
22:27:31 <wli> Just using it to solve systems of polynomial equations isn't that big a deal. You can pretty much just blindly form syzygy polynomials and turn the crank for small problem sizes such as those you'd take on by hand.
22:27:47 <prb> wagle_home: Having trouble with simpleHTTP (from Network.HTTP) closing connections on MacOS X.  Seems to be fine on Linux.
22:28:04 <ski> e.g., `join' for a parser monad allows part of what to parse to depend on what has already been parsed
22:28:52 <ddarius> dolio: join can be calculated by UÎµF from the adjunction that defines State, namely UX = S -> X and FX = (X,S) and the isomorphism is curry/uncurry, Îµ is then uncurry id or perhaps more pointedly, uncurry ($)
22:29:37 <paolino> anybody knows how to make haddock skip the newtype definitions which makes it stop parsing ?
22:31:21 <wagle_home> prb, i'd look at the packets via wireshark, tcpdump, or somesuch tool..  this helps if you have a notion of what all the bits mean
22:31:45 <prb> wagle_home: Traffic is all cool -- I turned on the debugging for the library.
22:32:10 <ddarius> :t (uncurry id .)
22:32:17 <prb> wagle_home: Problem is that the socket sticks on ACK after the completion of the connection (Connection: close), which lsof confirms.
22:32:25 <lambdabot> forall b c a. (a -> (b -> c, b)) -> a -> c
22:32:31 <prb> wagle_home: Then the app eventually runs out of handles.
22:32:37 <wagle_home> prb, i had a problem with a hp http server a while back that sent a RESET at me if my tcp stack sent the message in 3 packets instead of 1 or 2
22:33:18 <prb> wagle_home: 'k; maybe I need to look at the next layer down.
22:33:27 <wagle_home> are the clients closing the socket?
22:33:46 <prb> wagle_home: I believe so.  The code would lead me to believe that they are.
22:33:50 <wagle_home> need to close both reader and writer socket, iirc
22:33:58 <prb> wagle: And the debugging from the library suggests it.
22:34:02 <wagle_home> lsof might tell you too
22:34:11 <prb> wagle_home: I'll confirm that it's closing both.
22:34:13 <ski> @. djinn type (uncurry id .)
22:34:13 <ddarius> :t (uncurry runState .)
22:34:13 <lambdabot> f a b =
22:34:13 <lambdabot>     case a b of
22:34:13 <lambdabot>     (c, d) -> c d
22:34:14 <lambdabot> forall s a a1. (a1 -> (State s a, s)) -> a1 -> (a, s)
22:34:26 <ddarius> :t State . (uncurry runState .)
22:34:27 <lambdabot> forall s a. (s -> (State s a, s)) -> State s a
22:34:59 <phobes> shachaf:  I'm still trying to grok Writer
22:35:17 <phobes> I don't get why listen isn't just  listen :: m w
22:35:19 <ddarius> :t State . (uncurry runState .) . runState
22:35:20 <lambdabot> forall a s. State s (State s a) -> State s a
22:35:35 <phobes> instead of listen :: m a -> m (a, w)
22:35:45 <phobes> I guess I see... you don't want to listen to everything
22:35:51 <hpaste>  prb pasted "(no title)" at http://hpaste.org/5481
22:35:57 <phobes> Just the log generated by a particular computation
22:36:17 <prb> wagle_home: There's the fragment that claims to close the socket.  I'll try some permutations.
22:36:50 <shachaf> phobes: I was just talking about (>>=)/return vs. fmap/join/return. :-)
22:37:19 <phobes> shachaf: I know, I just needed to figure out what it was doing first
22:37:44 <dolio> ddarius: I was trying to avoid '(f .) . g' if possible. That's shorter, though.
22:38:23 <prb> wagle_home: lsof claims that the sockets are in LAST_ACK.
22:38:30 <wli> The sensible thing to do would be to have (>>=), return, and join all as methods of Monad, remove fail (of course), make Functor a prerequisite for Monad, and then define defaults for (>>=) and join in terms of each other so defining one gives a default implementation of the other.
22:39:06 <dolio> And stick Applicative in the middle. :)
22:39:21 <wli> Plausible.
22:39:48 <kaol> what about pattern match failures in a do?
22:39:52 <dolio> You could remove return too, then, I suppose, although that's probably useful.
22:39:54 <bos> ddarius: does Parsec 3 have a way of getting the residual unparsed tokens out after running a parse?
22:40:10 <wli> kaol: Generate a MonadZero constraint.
22:40:40 <kaol> that sounds good
22:41:17 <Cin> :t const
22:41:17 <lambdabot> forall a b. a -> b -> a
22:41:24 <paolino> where can I ask help on haddock's problems?
22:42:06 <Cin> > Just 1 >>= (const $ Just 2) >>= (const $ Just 3)
22:42:21 <lambdabot>  Just 3
22:42:32 <Cin> > Just 1 >>= (const $ Nothing) >>= (const $ Just 3)
22:42:33 <lambdabot>  Nothing
22:42:35 <shachaf> @src (>>)
22:42:36 <lambdabot> m >> k      = m >>= \_ -> k
22:43:26 <paolino> Nothing failed the monad
22:43:35 <Cin> right
22:43:51 <Cin> i was testing a hypothesis that it would do that
22:44:00 <paolino> :)
22:45:30 <paolino> I like to be surprised by the least surprise principle
22:45:47 <Cin>  @_@
22:46:17 <wagle_home> prb see wikipedia on tcp, and rfc 793..  it should be sending a FIN, go into LAST-ACK, and wait for ACK of FIN..  see if that's really happening..  if RESETs are being tossed around, that could screw things up
22:46:53 <prb> wagle_home: Already there.  Odd thing is that it's fine on Linux.
22:47:11 <Cin> > [1,2,3] >>= (+1)
22:47:11 <lambdabot>   add an instance declaration for (Num [b])
22:47:35 <Cin> > [1,2,3] >>= (+1) >>= putStrLn . show
22:47:35 <lambdabot>  Couldn't match expected type `[]' against inferred type `IO'
22:47:38 <wagle_home> linux vs macosx clients?  whats the server?
22:47:39 <vininim> mmmm. Anyone have experience in implementing dynamic tree-like structures in haskell? I mean, does it have the same pitfalls a matrix has?
22:47:55 <Cin> > [1,2,3] >>= (+1) >>= (putStrLn . show)
22:47:55 <lambdabot>  Couldn't match expected type `[]' against inferred type `IO'
22:48:15 <phobes> shachaf:  >>= for Writer seems like it would be trivial and straightforward
22:48:39 <shachaf> phobes: And not join/fmap?
22:48:47 <shachaf> Those seem simpler, to me.
22:48:48 <wagle_home> the rfc is alleged to say that tcp can stay in the LAST-ACK state for up to 4 minutes..  maybe the timers are different
22:48:49 <Cin> > [1,2,3]
22:48:50 <lambdabot>  [1,2,3]
22:49:09 <paolino> >:t ( [1,2,3] >>= )
22:49:13 <phobes> shachaf:  You may be right
22:49:32 <phobes> shachaf:  I find it hard to think in terms of join... >>= is very natural to me though
22:49:38 <paolino> :t ( [1,2,3] >>= )
22:49:39 <lambdabot> forall t b. (Num t) => (t -> [b]) -> [b]
22:50:00 <wli> phobes: Try join for Maybe
22:50:09 <wagle_home> :t ( [1,2,3] >> )
22:50:13 <lambdabot> forall b. [b] -> [b]
22:50:27 <Cin> > [1,2,3] >>= id
22:50:28 <lambdabot>   add an instance declaration for (Num [b])
22:50:28 <lambdabot>     In the expression: 3
22:50:40 <shachaf> join :: Monoid w => Writer w (Writer w a) -> Writer w a; join :: Monoid w => (w,(w,a)) -> (w,a); join (w,(w',a)) = (w `mappend` w',a)
22:51:07 <paolino> :t  (return.(+1))
22:51:08 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => a -> m a
22:52:03 <BMeph> > [123] >>= (enumFromTo 0)
22:52:10 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
22:52:17 <phobes> shachaf, wli:  With join, I dont' know what I'm trying to do
22:52:32 <BMeph> > [1,2,3] >>= (enumFromTo 0)  --heh, heh, a little better behaved. ;)
22:52:33 <lambdabot>  [0,1,0,1,2,0,1,2,3]
22:52:34 <sarehu> ping Cale: question on lambdabot (latest version) what do you think is causing " setResourceLimit: invalid argument (Invalid argument)" on any Haskell expression?  (I get it when running "> 2 + 3" ; got the same error on other versions w/6.6.1 -- could it be my OS, Debian testing?  The C function it calls would be what's causing the error)
22:52:46 <sarehu> s/would/could
22:52:49 <wli> phobes: join :: Monad m => m (m t) => m t
22:52:58 <phobes> shachaf, wli:  I can write down the types and figure out a way to do it
22:53:00 <shachaf> phobes: True enough -- you have to understand join before it makes things simpler. :-)
22:53:22 <Cin> > [1,2,3] >>= liftM . id
22:53:22 <lambdabot>  Couldn't match expected type `[]'
22:53:23 <phobes> shachaf, wli:  but I have no motivation... what's my goal?   I understand >>= in terms of sequencing
22:53:30 <paolino> > [1,2,3] >>= (return . (+1))
22:53:30 <lambdabot>  [2,3,4]
22:53:44 <wli> phobes: The monad is wrapping the result twice and you have to get it into only being wrapped once.
22:53:53 <Cin> oops. i wasconfusing liftM with return
22:53:54 <wli> > join (Just (Just 1))
22:53:54 <lambdabot>  Just 1
22:53:57 <olsner> @join #haskell-blah
22:53:57 <lambdabot> Not enough privileges
22:54:02 <Cin> > [1,2,3] >>= return . id
22:54:03 <lambdabot>  [1,2,3]
22:54:10 <paolino> :t liftM id
22:54:10 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
22:54:14 <wli> join [[1]]
22:54:24 <wli> > join [[1]]
22:54:25 <lambdabot>  [1]
22:54:37 <phobes> shachaf, wli:  I understand, but how do I know there's a unique way to do that?  When someone describes the Writer Monad, they probably describe what they want to happen to a sequence - do all of these operations and get the folded log at the end
22:55:01 <wli> phobes: The fact there is a unique way to do that is part of the definition of a Monad.
22:55:16 <phobes> shachaf, wli:  So the way I see it, my objective is phrased in terms of >>=.  How do I translate that into some objective for join?
22:55:34 <BMeph> Cin: Remember, ">>=" expects a function that takes a value, and gives back some monadic value.
22:55:59 <BMeph> (for its second argument, that is. :)
22:56:14 <Cin> BMeph: yeah. `return' makes the return from `id' back into a list of one element
22:56:38 <BMeph> Cin: Yes, exactly. :)
22:56:41 <Cin> BMeph: :D
22:56:56 <phobes> wli: There's a unique way to get the types right?  Clearly join = (>>=) id defines a unique map
22:56:57 <wli> phobes: A computation that returns a computation that returns x might as well just be a computation that returns x. join is what does that conversion.
22:57:23 <phobes> wli:  ok, that's probably what I'm missing
22:57:28 <Cin> > liftM (*2) (Just 21)
22:57:29 <lambdabot>  Just 42
22:57:36 * Cin pats himself on the back
22:57:51 <phobes> wli:  ok thanks, makes perfect sense now :)
22:57:58 <wli> > liftM2 (+) (Just 1) (Just 2)
22:57:59 <lambdabot>  Just 3
22:58:23 <wli> > liftM2 (,) (Just 1) (Just 2)
22:58:23 <lambdabot>  Just (1,2)
23:00:45 <sarehu> ok, does anybody know why (System.Posix.Resource.setResourceLimit ResourceCPUTime _ )is erroring?
23:01:51 <Cale> why the _ ?
23:02:00 <sarehu> there's no _
23:02:15 <sarehu> put in any value
23:02:18 <sarehu> such as (ResourceLimits rlimit rlimit)
23:02:21 <sarehu> which lambdabot has
23:03:16 <sarehu> hmm, let me make a simple testcase
23:03:21 <olsner> hmm, doesn't it give you like the posix/C error at least?
23:03:22 <quicksilver> going to be hard for us to guess without you telling us the error message :)
23:04:15 <sarehu> i'll make a simple one
23:04:15 <Cale> What's the error?
23:04:22 <Cale> I ran it with no problem
23:04:29 <sarehu> the one lambdabot gives me is..
23:04:42 <sarehu>  setResourceLimit: invalid argument (Invalid argument)
23:05:14 <sarehu> that's upon entering   > 2 + 3    or   "> 2" or "> anything"
23:05:17 <ddarius> dolio: In this case (f .) is the action of the functor U
23:06:07 <Cale> I can call it from the ghci prompt and it even works correctly there.
23:06:14 * paolino wonders if haddock is ever used
23:06:24 <Cale> sarehu: What kind of system are you using?
23:06:37 <povman> paolino: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
23:06:55 <ddarius> bos: No more or less than previous versions of Parsec.
23:07:11 <Cale> paolino: Haddock is used systematically by almost every Haskell project.
23:07:40 <paolino> so why it bumps on a newtype
23:07:46 <ddarius> paolino: All the documentation on GHC for the heirarchical libraries is Haddock generated.
23:08:12 <sarehu> Cale: Debian testing, ghc 6.8.2,
23:08:31 <sarehu> also, setResourceLimit ResourceCPUTime (ResourceLimits (ResourceLimit 3) (ResourceLimit 3)) gives the error.  and same with any number besides 3
23:09:03 <ddarius> Anyway, I really need to sleep.
23:09:08 <Cale> sarehu: in ghci?
23:09:15 <sarehu> in ghci and compiled
23:09:24 <Cale> Okay, I'm not seeing that error.
23:09:36 <sarehu> s/ResourceLimit 3/ResourceLimitInfinity/ and the error persists, let me try others..
23:09:49 <Cale> You might try calling setrlimit in the posix API directly from C
23:09:55 <Cale> and see what errno is set to
23:09:58 <paolino> it cannot parse a newtype declaration in a file without any haddock annotation
23:10:03 <sarehu> ok
23:11:29 <sarehu> (sigh, why are Resource limits not an instance of show...)
23:11:41 <paolino> I don't know why it cares on things not starting with a -- or {- , I suppose it has something to do with vivibility
23:11:48 <Cale> heh, they're not even an instance of Ord
23:12:18 <paolino> *visibility :)
23:12:48 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/unix-2.2.0.0 -- at least the package is separate, so we can fix the problem without re-releasing GHC :)
23:12:51 <lambdabot> http://tinyurl.com/2glc6z
23:13:52 <sarehu> ok, getResourceLimit ResourceCPUTime is working, returning large integer limits
23:14:34 <olsner> > head . tails $ [1,2,3]
23:14:39 <lambdabot>  [1,2,3]
23:15:21 <povman> > [1,2,3]
23:15:22 <lambdabot>  [1,2,3]
23:15:49 <prb> wagle_home: tcpdump and tcptrace and xplot, so I have some pictures to look at.
23:16:17 <Cale> 18446744073709551615
23:16:32 <sarehu> yeah
23:16:47 <Deewiant> > 2^64 - 1
23:16:48 <lambdabot>  18446744073709551615
23:17:28 <wagle_home> prb ok
23:18:23 <prb> wagle_home: But I'm not seeing any RESETs.
23:18:29 <olsner> @ty (\(matchhere::String->String->Bool) (regex::String) -> foldr (||) (matchhere regex []) . map (matchhere regex) . takeWhile (not.null) . tails)
23:18:30 <lambdabot> (String -> String -> Bool) -> String -> [Char] -> Bool
23:18:43 <olsner> @pl (\(matchhere::String->String->Bool) (regex::String) -> foldr (||) (matchhere regex []) . map (matchhere regex) . takeWhile (not.null) . tails)
23:18:43 <lambdabot> (line 1, column 14):
23:18:43 <lambdabot> unexpected ":"
23:18:43 <lambdabot> expecting natural, identifier, "_" or "("
23:18:50 <Cale> That is strange... according to the source, it's supposed to give ResourceLimitInfinity if getrlimit gives that value.
23:18:55 <olsner> @pl (\matchhere regex -> foldr (||) (matchhere regex []) . map (matchhere regex) . takeWhile (not.null) . tails)
23:18:55 <lambdabot> ap (ap . (((.) . foldr (||)) .) . flip flip []) (flip flip (takeWhile (not . null) . tails) . (((.) . map) .))
23:19:14 <wagle_home> ok..  that was just what was screwing me up back when i was trying to debug a http connection that went bad in the middle of the night
23:19:25 <olsner> @pl \f -> foldr (||) (f []) . map f . takeWhile (not.null) . tails
23:19:25 <lambdabot> ap ((.) . foldr (||) . ($ [])) ((. (takeWhile (not . null) . tails)) . map)
23:20:14 <Cale> (because it supposedly applies unpackRLimit which has a case for that value
23:20:16 <Cale> )
23:20:33 <wagle_home> prb, you seeing FIN-ACK's?
23:21:06 <prb> wagle_home: Presuming that I am reading the manual and the plots correctly, no.
23:21:17 <sarehu> yeah, RLIM_INFINITY is defined as (~0UL) or 0xffffffffffffffffuLL
23:21:25 <sarehu> in resource.h
23:21:49 <wagle_home> how about on the linux client?
23:22:01 <sarehu> Cale: setrlimit returns 0
23:22:05 <sarehu> (success)
23:22:08 <prb> wagle_home: Not as easy to tcp dump there.  It's a modestly busy web server.
23:22:25 <prb> wagle_home: But on that box, lsof says the handles are getting closed.
23:23:09 <wagle_home> do the macosx handles close after 4 minutes?
23:23:10 <Cale> oh
23:23:20 <Cale> hey, what does this command give you:
23:23:24 <Cale> ghc-pkg list unix
23:23:25 <sarehu> Also, it works
23:23:29 <prb> wagle_home: I'll tell you in four minutes... :)
23:23:41 <wagle_home> heh
23:23:46 <sarehu> /usr/local/lib/ghc-6.8.2/package.conf:\n    unix-2.3.0.0
23:23:50 <Cale> okay
23:23:54 <Cale> same here
23:24:15 <olsner> hmm, I'm thinking points-free folds are Haskell's counterpart to looping over pointers in C (short code that does exactly one thing in the shortest way possible, not necessarily being at all possible to change to do something similar)
23:24:16 <Cale> very strange
23:24:57 <Cale> olsner: But points-free folds often aren't that hard to change to doing something similar
23:25:29 <Cale> for example,  foldr (:) [] is the identity function, while foldr ((:) . f) [] is map f
23:25:44 <Cale> (and that principle can be applied generally)
23:26:14 <wagle_home> :t foldr (:) []
23:26:16 <lambdabot> forall a. [a] -> [a]
23:26:57 <wagle_home> > foldr (:) [] [1..]
23:26:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:29:04 <olsner> @ty (\(matchhere::String->String->Bool) (regex::String) -> any . map (matchhere regex) . tails)
23:29:06 <lambdabot>     Couldn't match expected type `a -> Bool'
23:29:06 <lambdabot>            against inferred type `[Bool]'
23:29:06 <lambdabot>     In the second argument of `(.)', namely
23:29:08 <olsner> > tails [1,2,3]
23:29:09 <lambdabot>  [[1,2,3],[2,3],[3],[]]
23:29:48 <olsner> @ty (\(matchhere::String->String->Bool) (regex::String) -> or . map (matchhere regex) . tails)
23:29:49 <lambdabot> (String -> String -> Bool) -> String -> [Char] -> Bool
23:32:28 <olsner> wow, this matchstar i ripe with redundancy
23:33:33 <sarehu> that is really bizarre
23:33:43 <olsner> (matchhere regex text || star regex text) for text == [] and (star regex [] = matchhere regex []) yields that star regex [] is never evaluated
23:35:51 <olsner> matchstar c regex [] = matchhere regex []; matchstar c regex (x:xs) = charMatch c x && matchstar c regex xs
23:36:18 <olsner> now that should be a foldr I think
23:36:58 <paolino> anyone can see if you can haddock http://code.haskell.org/Hedi/Undo.hs?
23:37:28 <sarehu> Cale: I didn't find a fix for me, but I found _a_ problem: (#const RLIM_INFINITY) and (#const RLIM_SAVED_CUR) etc end up resolving to 2^32-1, instead of 2^64-1, in packRLimit
23:37:42 <Cale> aha
23:37:48 <sarehu> and in other places.. same with unpackRLimit
23:37:50 <prb> wagle_home: Handles are not closed in 4 minutes.
23:39:04 <sarehu> however, maxBound :: System.Posix.Types.CRLim  gives 2^64-1.
23:39:32 <Cale> sarehu: I guess you could file a few bugs. I wish I knew what was going on... perhaps stracing the Haskell program could help?
23:41:55 <sarehu> holy crap...  it's calling  setrlimit(RLIMIT_CPU, {rlim_cur=RLIM_INFINITY, rlim_max=0}) = -1
23:42:20 <sarehu> wait, never mind... hold on
23:43:00 <sarehu> that was for rlimitinfinity...
23:43:14 <sarehu> with 3  and 3, it gives setrlimit(RLIMIT_CPU, {rlim_cur=3, rlim_max=0}) = -1 EINVAL (Invalid argument)
23:43:50 <Cale> I wonder why your rlim_max seems to be getting pegged to 0
23:44:17 <Cale> Are you on a 32 or a 64 bit machine?
23:44:22 <sarehu> 32 bit
23:44:26 <Cale> okay
23:44:32 <Cale> So it's nothing to do with that :)
23:45:14 <sarehu> hrm, maybe ... one thing
23:46:35 <Cale> setrlimit(RLIMIT_CPU, {rlim_cur=3, rlim_max=3}) = 0
23:46:46 <Cale> That's what strace reports on my machine.
23:46:50 <paolino> I didn't succeed to update to ghc6.8.2 which is required to compile latest haddock, and didn't find this kind of fix in the patch names from my version to latest
23:47:28 <Cale> paolino: What was your problem in upgrading to 6.8.2?
23:47:29 <sarehu> ok, I found the problem
23:48:15 <sarehu> rlim_t is 4 bytes wide on my machine, GHC and unix thinks it's 8
23:48:38 <paolino> libc6-dev and libc6 >= 2.7.1 are not available for ubuntu
23:48:44 <Cale> aha
23:48:44 <sarehu> or I guess base, since that's where system.posix.types lives
23:49:22 <Cale> sarehu: interesting
23:49:48 <Cale> paolino: hmm...
23:50:03 <Cale> paolino: I'm running ubuntu gutsy and I had no problems with the binary release.
23:50:18 <Cin> me too
23:50:30 <sarehu> Cale: in libraries/base/HsBaseConfig.h it has got #define HTYPE_RLIM_T Word64
23:50:32 <sarehu> hardcoded like that
23:50:36 <Cale> sarehu: aha
23:50:42 <sarehu> er, generated by configure
23:50:49 <wagle_home> prb you need someone who knows more than me
23:51:11 <wagle_home> i havent done any network programming in haskell
23:51:29 <paolino> ok, then I will try again, under your supervision
23:51:53 <Cale> paolino: I don't know if it will solve your problem with Haddock, but it's worth it to have 6.8.2 anyway.
23:52:00 <paolino> sure
23:52:13 <paolino> and then I can patch it
23:52:22 <paolino> (haddock)
23:52:33 <Cale> What kind of input is it choking on?
23:52:46 <Cale> You said something about a newtype?
23:52:46 <paolino> a newtype definition
23:53:05 <Cale> There are lots of newtype definitions in the libraries which it handles fine.
23:53:10 <paolino> http://code.haskell.org/Hedi/Undo.hs
23:53:17 <paolino> I suppose so :)
23:53:25 <paolino> it chockes on line 23
23:53:40 <paolino> (ghci passes it)
23:55:20 <paolino> which binary release should I use for 6.8.2 ubuntu 7.10 ?
23:55:40 <Cale> The one by Christian Maeder which uses readline 5
23:55:58 <Cin> is 7.10 gutsy?
23:56:14 <Cale> I think so
23:56:46 <paolino> I got one deb ghc6_6.8.2-1ubuntu1_i386.deb
23:57:09 * araujo wonders what vincenz is talking about on the arc channel :-)
23:57:15 <paolino> is that on haskell.org ?
23:57:21 <Cale> no, I don't think so
23:57:25 <Cin> paolino:
23:57:28 <sarehu> I'm guessing that AC_SYS_LARGEFILE in configure.ac is what's causing rlim_t to be 64 bits
23:57:31 <Cale> It's just a .tar.gz
23:57:34 <Cin> paolino:
23:57:36 <sarehu> but then elsewhere, that is not happening
23:57:40 <Cin> paolino: http://www.haskell.org/ghc/download_ghc_682.html
23:57:42 <lambdabot> Title: GHC: Download version 6.8.2
23:58:15 <Cale> http://www.haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-i386-unknown-linux.tar.bz2
23:58:15 <lambdabot> http://tinyurl.com/2s4u56
23:58:19 <Cale> that one
23:58:55 <sieni> does anybody know how to convert X bitmap fonts to native Windows fonts
23:59:08 <Cin> cale: i'm reading All About Monads which has been completely clear to me so far, which is nice.
23:59:20 <sclv> paolino: try to put the deriving clause on the same line?
23:59:40 <Cale> Cin: cool
