00:00:01 <Cale> Cin: It's a pretty good tutorial
00:00:13 <Cin> cale: i read your Monads as Computations but found i already understood what it was explaining so i finished that and moved onto All About
00:00:48 <paolino> ok, thanks 30 minutes to download it ...
00:00:52 <paolino> sclv: nothing
00:01:00 <Cale> Cin: Cool. It was mostly the philosophical perspective, and that last section on the whole point of monads that I suggested it for.
00:01:24 <Cale> All About Monads has all the details of particular monads in the libraries.
00:01:32 <Cin> cale: ah, indeed
00:02:29 <Cin> cale: i don't think i understand what your Monads as Containers is about, so that should be a good read to move onto after All About :)
00:02:35 <Cale> :)
00:02:46 <Cale> Also, check out the Parsec documentation
00:02:55 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
00:03:00 <paolino> sclv: it looks a very normal definition, i tried some changes already
00:03:34 <Cale> It's very tutorial in nature. Slightly out of date because the module names have changed a bit, but otherwise valid.
00:04:04 <Cale> I think it was while reading the parsec documentation that I really started to understand what monads were about. :)
00:04:05 <Cin> cale: hm. i have used parsec to parse IRC. i had a basic grasp but now the meaning is somewhat clearer. reading that sounds like a good idea
00:04:35 <sarehu> looks like I'm rebuilding 6.8.2 :)
00:04:43 <Cale> sarehu: *sigh*
00:04:55 <sarehu> with my manual edit of libraries/base/configure
00:05:24 <Cale> sarehu: That's really disappointing. I wonder if anything more permanent can be done about that problem.
00:05:50 <paolino> sclv:I suppose the parser got confused before that line
00:06:11 <Cin> cale: this might be a silly question, but how advanced is the category theory behind monads?
00:06:25 <sarehu> Cale: I think it has something to do with turning on large file support at configuration and turning it off while compiling
00:06:33 <Cale> Cin: It's not that advanced. You have to know what a natural transformation is.
00:06:41 <sarehu> s/turning it off/not turning it on/ though
00:07:18 <Cale> Cin: (if you know what a natural transformation is, you can handle it -- all the other prereqs are also prereqs of understanding natural transformations)
00:07:19 <paolino> Undo.hs:"Undo.hs": 23:1: Parse error , it couldn't be more vague
00:07:36 <Cin> cale: ah, i see.
00:07:59 <Cale> To know what a natural transformation is, you have to understand functors.
00:08:10 <Cale> To understand functors, you just have to understand categories
00:09:02 * paolino wonders how many understanding steps are needed to reach what it understood
00:09:33 * sarehu tries moving the laptop in the dark and it ends up on top of the kitty
00:09:50 <wagle_home> so much for your mouse
00:09:55 <sclv> paolino: it haddocked ok with 6.8.2 and haddock 2.0 by the way.
00:10:23 <paolino> ok, I will follow that road then, tanks
00:12:45 <Cale> http://cale.yi.org/autoshare/Undo.html
00:12:58 <Cale> Worksforme :)
00:13:14 <Cale> okay, I did have to pass the option --opt-ghc=-fglasgow-exts
00:13:20 <Cale> er
00:13:27 <Cale> --optghc=-fglasgow-exts
00:13:40 <Cale> paolino: ^^
00:13:53 <Cin> so the Monad class has laws, but has anyone ever heard of defining a class's functions types -and- some laws about them?
00:14:05 <Cale> Hey, I recognise this code...
00:14:52 <Cale> Is this my code? :)
00:15:03 <paolino> Undo ?
00:15:05 <sclv> Cin: Arrows have laws too, as do Applicatives, etc.
00:15:07 <Cale> yeah :)
00:15:14 <paolino> mostly
00:15:28 <wagle_home> @hoogle Applicatives
00:15:29 <lambdabot> No matches found
00:15:32 <Cale> Yeah, it's changed a bit :)
00:15:47 <pjd> @hoogle Applicative
00:15:47 <lambdabot> Control.Applicative :: module
00:15:47 <lambdabot> Control.Applicative.Applicative :: class Functor f => Applicative f
00:16:03 <paolino> intercepting put for history pushing was too much for me
00:16:03 <Cin> sclv: i mean, the compiler doesn't check that the laws hold for every instance of that class. it would be interesting if there was a way to do that
00:16:05 <prb> wagle_home: I think that this is probably the same issue: http://bugs.mysql.com/bug.php?id=19723
00:16:05 <wagle_home> @src Applicative
00:16:06 <lambdabot> Title: MySQL Bugs: #19723: KILL of active connection yields error on Mac OS X
00:16:06 <lambdabot> class Functor f => Applicative f where
00:16:06 <lambdabot>     pure  :: a -> f a
00:16:06 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
00:16:25 <pjd> > (+) <$> [10,20] <*> [1, 2]
00:16:28 <lambdabot>  [11,12,21,22]
00:17:01 <Cale> paolino: hmm?
00:17:04 <pjd> > (++) <$> Just "Hello" <*> Just " World!"
00:17:04 <lambdabot>  Just "Hello World!"
00:17:35 <sclv> Cin: there was some discussion of exporting quickcheck properties and well, asking, that folks implementing classes also provide the quickchecks...
00:17:52 <Cale> Oh, hey, people have done strange things with the code on the haskellwiki
00:18:01 <Cale> Like made it an instance of MonadState
00:18:08 <Cale> I never did that :)
00:18:10 <paolino> Cale, I have things in the state which are not necessarily undoable
00:18:12 <sarehu> what where?
00:18:12 <paolino> ok
00:18:33 <Cale> I would have put that functionality in MonadUndo if I was going to implement it.
00:18:38 <wagle_home> prb, you using macosx 10.5?
00:18:43 <sclv> A general proof that the laws hold would be sort of hard to complete in Haskell. Coq on the other hand, I suppose.
00:18:43 <Cin> sclv: i haven't tried quickcheck yet, but it is on my todo list
00:18:50 <prb> wagle_home: Yep.
00:18:53 <Cale> oh
00:18:55 <Cale> No wait
00:18:57 <Cale> hehe
00:18:59 <wagle_home> prb ugh
00:19:05 <Cale> I forgot what this was :)
00:19:13 <Cale> Yes, I did actually write that.
00:19:16 <wagle_home> seems like a similar problem
00:19:35 <prb> wagle_home: So far so good on the upgrade actually; some of the features are a real plus.
00:19:43 <Cale> But get and put don't directly get and put the history, they affect it indirectly.
00:19:46 <olsner> @quote stack-calculator
00:19:46 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
00:20:03 <olsner> now *that's* a neat trick
00:20:15 <Cale> I provided a way to access the current history, but nothing to edit it.
00:20:44 <Cale> (because I figured that it was kind of a nice property that the history couldn't be arbitrarily corrupted.)
00:20:45 <paolino> a filter was probably a better solution
00:20:48 <sclv> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 push 5 add end
00:20:50 <lambdabot>  8
00:21:05 <sclv> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 push 5 add add end
00:21:05 <lambdabot>  10
00:21:18 <olsner> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 push 5 add add add end
00:21:19 <lambdabot>  Couldn't match expected type `(t, t1)' against inferred type `()'
00:21:36 <Cale> ah, I see
00:21:48 <Cale> So you're not storing all the changes in the history, just some of them.
00:22:00 <Cale> That makes sense.
00:22:20 <paolino> yes, I didn't break the state in two levels
00:23:25 <paolino> I prefer explicit hput then lifts hanging around
00:23:28 <Cale> I really hate how when I close my Gmail browser tab, it kills off all the chat windows.
00:23:55 <olsner> need undo close tab?
00:23:59 <Cale> Heh.
00:24:05 <paolino> then you are a microsoft-yahoo fan!
00:24:07 <Cale> I need Gmail to work sanely.
00:25:05 <paolino> (they hate Gmail also)
00:25:06 <wagle_home> i cant handle looking for false positives in the gmail spam folder
00:25:17 <Cale> I think it's a pretty good rule that closing a browser window or tab should never ever cause another one to close.
00:25:29 <Cale> wagle_home: I just don't.
00:25:40 * mgsloan just doesn't chat in his browser
00:25:40 <vininim> I really wonder why I'm so targeted by viagra ads, I mean, I'm 24 :/
00:26:09 <Cale> vininim: You seem to have missed the point of spam.
00:26:10 <wagle_home> thats my uncomfortable position, but i had a long lost cousin contact me once and get categorized as spam
00:26:11 <olsner> oh, it closes other *tabs*? I thought you meant those popin-thingies
00:26:16 <mgsloan> viagra ads are the plague of the internet, by some very odd circumstance
00:26:28 <mgsloan> I looked it up a few days ago as a matter of fact
00:26:36 <Cale> Hell, 20% of the spam I get is in languages I can't even read.
00:27:16 <lament> Cale: so learn more languages
00:27:24 <paolino> you get a lot of spam through gmail ?
00:27:26 <Cale> Basically, if your message doesn't pass the gmail spam filter, I probably wouldn't have wanted to read it anyway.
00:27:47 <Cale> So I just don't check.
00:28:01 <vininim> I used to get spam with random assemble of english words with no meaning whatsoever
00:28:06 <wagle_home> i get 50 a day on gmail, and i havent published the address anywhere
00:28:30 <Cale> I've gotten 1284 in the past 30 days.
00:28:33 <vininim> "1932 king arthur soap could handle the 20 rabbits red doom"
00:28:36 <Cin> cale: yeah, if it's an urgent e-mail, well, urgent e-mails? pfft. telephone me
00:28:41 <Cale> > 1284.0/30
00:28:43 <lambdabot>  42.8
00:29:02 <Cale> Cin: yeah.
00:29:15 <paolino> the filter is not so good then
00:29:38 <Cale> lament: Well, I can kind of read the Japanese, slowly, with a dictionary.
00:30:39 <Cin> wagle_home: perhaps your e-mail was generated and confirmed to exist and maybe even distributed to other spammers. in any case, i don't think publishing your e-mail, or "hiding it" on your web site with javascript or NOSPAM is any real defense, imho
00:30:39 <Cale> I know maybe about 50 kanji, which isn't really enough to make reading anything comfortable.
00:31:44 <mgsloan> > exp pi - pi
00:31:45 <lambdabot>  19.999099979189474
00:31:52 <mgsloan> uh-oh, rounding errors!
00:31:53 <wagle_home> yeah, thats what i figured..  but actually i only use to to subscribe to a gmail group
00:32:14 <wagle_home> beaum!
00:32:27 <mgsloan> there goes another one of those underwater cables
00:32:43 <wagle_home> alas poor dons, we knew him well
00:32:53 <mgsloan> his cable has been cut
00:33:07 <mgsloan> yey for netsplits
00:33:14 <Cale> mgsloan: There's probably a number theoretic explanation for that "coincidence"
00:33:27 <mgsloan> it's fun to convince people nukes went off when netsplits happen
00:33:28 <mgsloan> oh?
00:33:58 <wagle_home> hmm..  its going down..  only 221 spam in my gmail spam folder
00:34:01 <Cin> mgsloan: Al Gore did it. he's pissed and is taking the Internet back.
00:34:15 <mgsloan> lol, I'm sure that's it
00:34:29 <Cale> I don't know what it is, but I know that there is one for e^(pi sqrt(163))
00:34:45 <Cale> > e^(pi*sqrt(163))
00:34:45 <lambdabot>   Not in scope: `e'
00:34:46 <wagle_home> yay dons!
00:34:49 <Cale> > exp (pi*sqrt(163))
00:34:53 <lambdabot>  2.6253741264076826e17
00:35:02 <Cale> oh, you can't see it printed like that
00:35:10 <paolino> ok, ghc6.8.2 unpacked
00:35:41 <Cale> > let u = exp (pi * sqrt 163) in u - ceiling u
00:35:42 <lambdabot>  Add a type signature
00:35:49 <Cale> > let u = exp (pi * sqrt 163) :: Double in u - ceiling u
00:35:50 <lambdabot>   add an instance declaration for (Integral Double)
00:36:06 <Cale> oh
00:36:14 <Cale> > let u = exp (pi * sqrt 163) :: Double in u - fromIntegral (ceiling u)
00:36:14 <lambdabot>  0.0
00:36:18 <Cale> heh
00:36:35 <Cale> Now there's a rounding error :)
00:36:39 <mgsloan> :)
00:37:04 <mgsloan> when will LB get reals? :)
00:37:55 <Cale> The difference is about -7.4992 * 10^(-13)
00:38:26 <sclv> > exp $ pi * (0 :+ 1)
00:38:26 <Cale> That's pretty damn close to an integer :)
00:38:26 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
00:38:43 <mgsloan> yeah, damn
00:39:03 <vininim> :t (:+)
00:39:03 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
00:39:04 <mgsloan> is there a number theoretic explanation for that?
00:39:06 <wagle_home> > 1.99999999999999999999999999999999999999999999999999999999999999999999 :: Integer
00:39:07 <lambdabot>   add an instance declaration for (Fractional Integer)
00:39:07 <lambdabot>     In the expression:...
00:39:48 <Cale> It's related (remotely) to the fact that f(n) = n^2 + n + 41 gives prime numbers for all values of n between 0 and 39 and 163 is a solution to f(n) = 0
00:40:04 <opqdonut> oh wow
00:40:16 <opqdonut> almost-integers are cool stuff
00:40:35 <opqdonut> or rather the theory behind them
00:40:42 * wagle_home imagines an Almost monad
00:41:16 <Cin> haha. here's the result of your computation.. ohh! almost ;) better luck next time, chump
00:41:21 <mgsloan> ahh, interesting.  I think i've seen n^2 + n + 41 before
00:41:47 <Cale> It's related more closely to the fact that 163 is the largest number n for which the ring Q(sqrt(-n)) has unique factorisation.
00:41:59 <Cale> er, the ring of integers of that ring, rather
00:44:02 <sclv> >  let u = exp (pi * sqrt 300) :: Double in u - fromIntegral (ceiling u)
00:44:04 <lambdabot>  0.0
00:44:24 <sclv> >  let u = exp (pi * sqrt 120) :: Double in u - fromIntegral (ceiling u)
00:44:25 <lambdabot>  -0.875
00:44:35 <sclv> >  let u = exp (pi * sqrt 150) :: Double in u - fromIntegral (ceiling u)
00:44:35 <lambdabot>  0.0
00:45:16 <sclv> or it could just be that e ^ some big thing = something that kills Double's precision enough that it doesn't really matter... (or it could be both)
00:45:24 <Cale> It's both.
00:45:45 <Cale> For example, with the 300 case, when you do arithmetic correctly, it's about 0.05 away.
00:46:24 <Cale> With 150, it's 0.2 away
00:46:49 <Cale> er, closer to 0.3 actually
00:47:07 * sclv boggles at the fact that Cale has these figures at his fingertips (or Mathematica maybe)
00:47:14 <Cale> Mathematica :)
00:47:19 <Cin> > [] `mplus` [1]
00:47:20 <lambdabot>  [1]
00:47:28 * Cin "ooo"s
00:47:40 <sclv> shouldn't have admitted that -- it builds the mystique.
00:48:03 * wagle_home is the proud owner of 20 mathematica licenses from 1989
00:48:04 <opqdonut> heh yeah
00:48:17 <opqdonut> mathematica is a really cool piece of software
00:48:19 <mgsloan> can someone show an example of (Monad ((->) r))?
00:48:22 <opqdonut> especially the newer versions
00:48:29 <opqdonut> mgsloan: access to a common environment
00:48:34 <mgsloan> ah
00:48:35 <wagle_home> they are still sending me email
00:48:46 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
00:48:47 <lambdabot>  ("hello","olleh","HELLO")
00:48:55 <opqdonut> yeah
00:48:56 <Cale> mgsloan: ^^
00:49:06 <sarehu> @src Reader
00:49:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
00:49:09 <sarehu> bah
00:49:13 <sclv> > [] `mappend` [1]
00:49:13 <lambdabot>  [1]
00:49:16 <mgsloan> ooh, cool, hmm
00:49:18 <mgsloan> interesting
00:49:21 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
00:49:21 <lambdabot>  [5,7,10,25,32]
00:49:42 <opqdonut> :t join
00:49:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:49:49 <Cale> > join (*) 5
00:49:50 <lambdabot>  25
00:49:52 <opqdonut> :t join :: (r->r->a)->(r->a)
00:49:53 <lambdabot> forall r a. (r -> r -> a) -> r -> a
00:49:53 <sclv> > join (,) 12
00:49:54 <lambdabot>  (12,12)
00:50:02 <opqdonut> join just gives the same argument twice :)
00:50:06 <Cale> > ap (,) reverse "hello"
00:50:07 <lambdabot>  ("hello","olleh")
00:50:15 <mgsloan> heh, I think i've manually written Monad ((->) r) 's sequence in terms of map before
00:50:24 <Cale> > map (ap (,) (^2)) [1..10
00:50:24 <lambdabot>  Parse error at end of input
00:50:24 <Cale> > map (ap (,) (^2)) [1..10]
00:50:25 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
00:50:34 <Cale> > map (ap (,) (join (*)) [1..10]
00:50:34 <lambdabot> Unbalanced parentheses
00:50:37 <Cale> > map (ap (,) (join (*))) [1..10]
00:50:37 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
00:50:44 <mgsloan> :t ap
00:50:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:50:53 <Cale> So in this case,
00:50:58 <sclv> > all . sequence [(>5),(>0),(>240),even] $ 444
00:50:59 <lambdabot>  Couldn't match expected type `a -> Bool'
00:51:03 <Cale> (e -> a -> b) -> (e -> a) -> (e -> b)
00:51:08 <sclv> > all . sequence [(>5),(>0),(>240)] $ 444
00:51:08 <lambdabot>  Couldn't match expected type `a -> Bool'
00:51:09 <mgsloan> > join (*)
00:51:09 <lambdabot>  <Integer -> Integer>
00:51:09 <Cale> (e -> a -> b) -> (e -> a) -> e -> b
00:51:22 <Cale> @djinn (e -> a -> b) -> (e -> a) -> e -> b
00:51:22 <lambdabot> f a b c = a c (b c)
00:51:29 <Cale> It's the S combinator :)
00:51:31 <Cale> also
00:51:38 <mgsloan> roight, so join of a binary function would use the same env for both args
00:51:46 <Cale> return :: a -> e -> a
00:51:54 <mgsloan> because the nesting got flattened
00:51:57 <Cale> and so return is K
00:52:09 <Cale> mgsloan: right :)
00:52:30 <sclv> > foldr1 (&&) . sequence [(>5),(>0),(>240)] $ 444
00:52:31 <lambdabot>  True
00:52:35 <sclv> > foldr1 (&&) . sequence [(>5),(>0),(>240),odd] $ 444
00:52:36 <lambdabot>  False
00:52:38 <Cale> So the Applicative operators on ((->) e) are just the SK-calculus :)
00:52:41 <sclv> there we go.
00:52:57 <Cale> (If you know what that is)
00:53:04 <mgsloan> actually using such tricks would probably confuse the hell out of readers of the code, but they wouldn't mind, because it makes reading code so much more interesting :P
00:53:11 <Cale> hehe
00:53:11 <opqdonut> :D
00:53:18 <opqdonut> nice way of putting it
00:53:18 <Cale> It's not so bad once you're used to it.
00:53:28 <opqdonut> "this is so damn elegant the obfuscation doesn't matter"
00:54:01 <Cale> The (->) e monad has lots of nice consequences.
00:54:08 <Cale> Not to mention that fmap is composition :)
00:54:15 <mgsloan> well, I dunno, jumping into the (->) r monad momentarily could be a bit freaky
00:54:47 <mgsloan> ah, yeah, I think that little gem was incorporated in the other prelude
00:54:55 <Cale> Also, something I noticed the other day... you might know the trick for composing a function with multiple args:
00:55:00 <Cale> :t ((.).(.))
00:55:01 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:55:07 <mgsloan> > (+1) `fmap` (*2) $ 5
00:55:09 <lambdabot>  11
00:55:09 <Cale> :t ((.).(.).(.))
00:55:10 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
00:55:14 <Cale> (and so on)
00:55:18 <mgsloan> right
00:55:24 <Cale> This is much clearer when you replace (.) with fmap
00:55:26 <mgsloan> they had whimsical names iirc
00:55:38 <Cale> :t (fmap . fmap)
00:55:38 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
00:56:01 <Cale> and then think of what happens when f and f1 are specialised to (->) a and (->) a1
00:56:22 <Cale> (a -> b) -> f (f1 a) -> f (f1 b)
00:56:27 <mgsloan> ahah interesting
00:56:29 <Cale> (just to get rid of the cruft)
00:56:32 <mgsloan> yeah
00:56:53 <Cale> er, that should be (->) t and (->) t1, given that a and b got reused there :)
00:57:04 <Cale> But yeah, you get it :)
00:57:24 <mgsloan> (fmap . fmap) is also more general
00:57:30 <mgsloan> of course
00:57:50 <mgsloan> I wonder if it actually has much use outside (->) r
00:58:29 <sclv> oh dear. i just realized i defined both ((.).(.)) and (<$>.<$>) in one thing I did. how silly of me
00:58:42 <sarehu> > (map . map) (+ 1) [[2,3,4],[12,13,14],[102,103,104,105]]
00:58:42 <lambdabot>  [[3,4,5],[13,14,15],[103,104,105,106]]
00:59:06 <Cale> mgsloan: Well, sure
00:59:24 <Cale> mgsloan: I've actually suggested renaming fmap to (.)
00:59:40 <Cale> (and to map, simultaneously, so we keep a prefix notation around)
00:59:49 <Cin> > [[2,3,4],[12,13,14],[102,103,104,105]] >>= map (+1)
00:59:49 <lambdabot>  [3,4,5,13,14,15,103,104,105,106]
00:59:50 <mgsloan> yeah, that'd be very cool
00:59:57 <Cale> So then you could write
01:00:02 <Cale> (+1) . [1,2,3,4,5]
01:00:05 <Cale> and get [2,3,4,5,6]
01:00:12 <mgsloan> was this suggestion in the form of The Other Prelude?
01:00:21 <sarehu> and also
01:00:25 <Cale> mgsloan: In part :)
01:00:26 <mgsloan> damn, that would be sexy :P
01:00:32 <sarehu> ("\n"++) . getLine
01:00:50 <mgsloan> hah, no way
01:01:24 <Cale> Yeah, it would be awesome :)
01:02:09 <mgsloan> it would bring our golf game to a whole new level
01:02:11 <sclv> having different associativity between . and fmap and <$> is sometimes handy though..
01:02:16 <Cale> Heh, maybe I should really "fork" ghc in order to explore such awesomeness.
01:02:23 <wagle_home> not (++"\n")  ?
01:02:29 <sclv> s/associativity/precedence/
01:02:39 <sarehu> wagle_home: er, yeah, that :P
01:02:50 <sarehu> wagle_home: ("\n"++) is more efficient :P
01:02:58 <Cale> sclv: I would make sure there was map = fmap as well.
01:03:04 <wagle_home> wow..  i thought it more likely that i was missing something...  8)
01:03:20 <sclv> Cale: well.. that goes without saying. :-)
01:03:20 <Cale> mgsloan: another awesome thing -- one of the functor laws is:
01:03:32 <Cale> fmap (f . g) x = fmap f (fmap g x)
01:03:42 <Cale> If we rewrite that using fmap = (.)
01:03:50 <Cale> (f . g) . x = f . (g . x)
01:03:58 <Cale> It's the associative law for composition :)
01:04:03 <dolio> Cute.
01:04:52 <quicksilver> Sure you don't need a ghc fork to expore this, Cale? All it takes is import Prelude (); import Cale.Prelude;
01:04:52 <mgsloan> lol
01:06:40 <wagle_home> @hoogle (a -> b -> c) -> (d -> e -> (a,b)) -> c
01:06:41 <lambdabot> No matches, try a more general search
01:07:10 <doserj> or even {-# LANGUAGE NoImplicitPrelude #-}
01:08:33 <roconnor> bah, model checking
01:09:49 <Cale> quicksilver: But you end up with problems if you do things like redefine the Monad class.
01:10:12 <Cin> > fmap (+1) [1,2]
01:10:13 <lambdabot>  [2,3]
01:10:23 <Cin> see, why does `map' exist when `fmap' appears to do the same thing?
01:10:27 <Cale> (or Functor)
01:10:36 <Cale> Cin: no good reason
01:10:41 <mgsloan> map is supposed to be easier for noobs
01:10:47 <Cin> oh. i thought it migh tbe optimisation
01:10:47 <roconnor> @quote polymorphism scare
01:10:48 <lambdabot> No quotes for this person. My brain just exploded
01:10:49 <mgsloan> ?src map
01:10:49 <lambdabot> map _ []     = []
01:10:49 <lambdabot> map f (x:xs) = f x : map f xs
01:10:52 <roconnor> @quote polymorphism
01:10:52 <lambdabot> ski says:  "please talk to your son or daughter about parametric polymorphism"
01:10:53 <mgsloan> bah
01:10:56 <roconnor> @quote scare
01:10:57 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
01:11:02 <mgsloan> I figured they'd at least define it in terms of fmap..
01:11:08 <roconnor> Cin: ^^
01:11:14 <mgsloan> i guess the list fmap def is = map
01:11:20 <quicksilver> Cale: not sure redefine Functor matters at all. Functor isn't part of any implicit magic is it?
01:11:40 <Cale> quicksilver: all the libraries have to be recompiled against your new definition
01:11:45 <Cale> If you want it to be useful.
01:12:00 <Cin> roconnor: heh, i see :P
01:12:49 <quicksilver> oh, I see.
01:12:51 <quicksilver> yes.
01:14:19 <proqesi> what is the character(s) for a comment in haskell?
01:14:32 <Cin> -- comment
01:14:33 <b_jonas> proqesi: -- comment
01:14:37 <b_jonas> or {- comment -}
01:14:40 <Cin> {- multi-line comment -}
01:14:43 <Cin> <_<
01:14:57 <b_jonas> sometimes they need whitespace around them so they don't look like operators
01:15:14 <b_jonas> also there's let { _ = "comment" } in
01:15:41 <Cale> haha
01:16:09 <b_jonas> Cale: well, that's how docstrings work in some languages: a no-op string statement
01:16:11 <Cale> I'd never thought of using wildcard pattern bindings as a way to make comments.
01:16:19 <sarehu> haskell's an advanced programming language with its lexically scoped comments
01:16:40 <sarehu> data Comment = ...    instance IsString Comment where ....
01:16:55 <b_jonas> it's just uglier in haskell for it's a pure language so you don't have an abbreviation for let _ = ... in ... like in procedural ones
01:16:57 <Cale> One nice thing is that you can nest {- ... -} 's
01:17:09 <wagle_home> wow..  a lazy file system..  so far, i have a list of 114.6 GB of files to possibly recover on a 37 GB file system
01:17:15 <Cale> Which for some retarded reason you're not allowed to do in C.
01:17:41 <mgsloan> yeah, as if it would make it any harder to parse..
01:17:55 <mgsloan> well, I guess I'm really talking about C++...
01:17:58 <b_jonas> Cale: don't forget that C is old and they can't break compatibility now
01:17:59 <proqesi> c compilers simply couldn't swallow it
01:18:12 <b_jonas> and you can nest ifdef zeros
01:18:14 <wagle_home> what doesnt C have?
01:18:22 <mgsloan> nested comments
01:18:26 <Cin> i tend to use #if 0 ... #endif to comment out code...
01:18:31 <Cale> b_jonas: But presumably it's a change which would only unbreak existing code.
01:18:52 <mgsloan> Cin - yeah, some ides even recognize that and shade accordingly
01:18:53 <Cale> Oh, I suppose you could have something like:
01:18:56 <b_jonas> Cale: I don't think so. we're talking about C, and there are lots of wierd C code out there
01:19:00 <Cin> mgsloan: indeed
01:19:01 <Cale>  /* /* */
01:19:11 <sarehu> some people _use_ that
01:19:18 <Cale> and then the rest of the file gets sucked into a comment.
01:19:26 <mgsloan> nah
01:19:28 <Deewiant> it's handy when you want to comment something out during testing
01:19:28 <sarehu> then again, some people use pokemon variable names
01:19:32 <mgsloan> err, oh, yeah
01:19:47 <b_jonas> Cale: D which has sort of C-like syntax (more than java) has added nested comments /+ ... +/
01:19:48 <Cale> but it just becomes an error
01:19:54 <Cale> (nonterminated comment)
01:19:58 <mgsloan> right
01:19:59 <b_jonas> but that's not compatible either of course, just like // foo isn't
01:20:08 <mgsloan> unless later you make the opposite mistake :)
01:20:20 <Cale> heh
01:20:35 <wagle_home> it was found that when people did /* /*  .....  */  */  it was usually an error
01:20:37 <Cin> trying to reason with c only ends in tears
01:20:40 <b_jonas> Cale: also, how would /*/ parse inside a 1-deep comment if you allow nested comments? would it end the comment like now or would it go to nesting level 2?
01:20:44 <Cale> wagle_home: really?
01:20:54 <b_jonas> I mean, now you can use /*/ as a universal comment terminator
01:21:04 <proqesi> yeah, back in the day I would sometimes move the pesky /* around alot
01:21:05 <b_jonas> (it both starts and ends a comment)
01:21:06 <Deewiant> /*/ would go to nesting level 2
01:21:06 <Cale> wagle_home: What if you want to comment out a large block of code which contains a comment?
01:21:21 <Deewiant> maximal munch lexes that as /* followed by /
01:21:23 <wagle_home> dunno
01:21:24 <b_jonas> wait, how does haskell parse {- {-}
01:21:36 <b_jonas> > {- {-} 1
01:21:36 <lambdabot>  Unterminated nested comment at "{-" (column 0)
01:21:38 <b_jonas> > {- { -} 1
01:21:40 <lambdabot>  1
01:21:46 <b_jonas> > {- {-} -} -} 1
01:21:46 <lambdabot>  1
01:21:47 <Deewiant> maximal munch again
01:21:54 <b_jonas> uh huh, that
01:21:56 <mgsloan> wha wha wha
01:21:56 <Deewiant> {-} is {- followed by }
01:22:00 <mgsloan> > -} 1
01:22:00 <lambdabot>  Parse error at "}" (column 2)
01:22:08 <proqesi> I would use // for single lines and comments and /* for whole blocks.. worked fine
01:22:28 <mgsloan> > {- -} -} 1
01:22:28 <lambdabot>  Parse error at "}" (column 8)
01:22:36 <b_jonas> > {- {-} -} 1
01:22:36 <lambdabot>  Unterminated nested comment at "{-" (column 0)
01:22:48 <Cale> Is // even available in C?
01:22:54 <Deewiant> in C99 it is
01:22:55 <b_jonas> Cale: in C99 yes
01:22:56 <proqesi> of course
01:22:57 <wagle_home> in gcc
01:23:04 <Cale> Right.
01:23:06 <b_jonas>  but it's incomaptible with C98 strictly speaking
01:23:07 <proqesi> prior to c99 as well
01:23:19 <b_jonas> so if you put gcc in strict c98 mode (which few people do) it's not there
01:23:21 <Deewiant> only as a compiler extension prior to c99
01:23:21 <Cale> I learned C before 1999, and haven't really used it much since then.
01:23:27 <Deewiant> b_jonas: c89, not 98 :-)
01:23:27 <proqesi> in codewarrior at least
01:23:33 <b_jonas> yeah sorry
01:23:34 <b_jonas> c89
01:23:38 <pejo> Cale, for commenting large blocks of code: #if 0
01:23:41 <Cin> okay, so i guess the person who's running my SSH shell just turned off the computer -_-
01:23:45 <Cale> pejo: right
01:23:49 <b_jonas> it's one of the lots of things C9 borrowed from C++
01:23:57 <b_jonas> C99 borrowed from C++
01:24:14 <b_jonas> though the next version of the C++ standard will get lots of things back from C99
01:24:16 <Cale> So why didn't C++ adopt nested comments?
01:24:19 <b_jonas> like restrict and whatever
01:24:33 <proqesi> it's considered bad practice
01:24:35 <b_jonas> Cale: there's no need for them, you don't want more levels than // and /*
01:24:44 <Cale> You might.
01:24:46 <b_jonas> / for short comments and /* for long
01:24:48 <Cin> it's pretty hard to make mistakes with comments when your editor does highlighting
01:24:54 <b_jonas> and #ifdef or if(0) for very long
01:24:56 <Cale> I use nested comments in Haskell all the time.
01:25:17 <proqesi> if you really had to nest, you could use /* with #ifdef
01:25:17 <b_jonas> Cale: nested brace comments or just -- inside {- ?
01:25:27 <wagle_home> Cin, my editor gets confused
01:25:29 <Cale> nested brace comments.
01:25:44 <mgsloan> even C/C++ can handle // inside /*
01:25:46 <Cale> If I'm commenting out part of a Haddock'd file, for instance.
01:25:53 <b_jonas> dunno
01:25:56 <wagle_home> bash-mode in xemacs has several stupidities
01:26:19 <Cale> I don't have to go and put lots of separate block comments around the code sections.
01:26:30 <resiak> Cale: that's what #if 0 is for!
01:26:43 <Arnar> mornin'
01:26:45 <Cale> resiak: Using the preprocessor is a pretty weak excuse :)
01:27:00 <resiak> Cale: i don't disagree :-)
01:27:17 <wagle_home> last i looked, the preprocessor got rid of the comments
01:27:22 <Cin> msvc has a nice collapsing feature for #if 0's
01:27:30 <b_jonas> Cale: would namespace ignore { ... } be better to comment out declarations?
01:27:37 <Arnar> anyone here familiar with the current state of lambdabot (standalone I mean)?
01:27:58 <sarehu> Arnar: unfortunately yes
01:28:07 <Cale> Arnar: um.. it works?
01:28:17 <sarehu> for you :P
01:28:23 <Cale> For everyone.
01:28:24 <wagle_home> ?botsnack
01:28:24 <lambdabot> :)
01:28:35 <Arnar> I'm having problems compiling it
01:28:46 <Arnar> the readme only talks about installing zlib, which I have
01:28:49 <sarehu> what compiler, and did you get the latest version?
01:28:52 <Cale> Arnar: what in particular (and when did you get the code?)
01:29:01 <Arnar> got lambdabot from darcs yesterday
01:29:11 <Cale> Oh, get it again
01:29:14 <Arnar> using ghc 6.6.1
01:29:16 <Arnar> oh, ok
01:29:17 <Cale> oh
01:29:22 <proqesi> is some of haskell's syntax inspired by c++?
01:29:24 <Cale> Heh, I updated for 6.8.2
01:29:32 <Arnar> ok, I'll update both :)
01:29:34 <Arnar> thanks
01:29:45 <doserj> Tue Feb  5 05:34:06 MET 2008  cgibbard@gmail.com * Frivolous patch to increase my own karma for fixing lambdabot.
01:29:49 <Cale> proqesi: What in particular?
01:29:53 <Cale> proqesi: I can't think of anything.
01:30:11 <proqesi> :: -> and >>
01:30:16 <Cale> doserj: hehe :)
01:30:39 <sarehu> they have nothing to do with C++ syntax
01:30:46 <Cale> proqesi: they have completely different meanings in Haskell
01:30:51 <proqesi> ok
01:30:57 <wagle_home> ascii is kinda limited
01:30:58 <Cale> :: is for type declarations
01:31:04 <Cale> It reads "has type"
01:31:23 * Cin has a try
01:31:24 <Cale> -> occurs in the syntax for case expressions, and possibly a couple other places
01:31:36 <Cale> (it's just punctuation)
01:31:44 <sarehu> Cale: maxBound :: CRLim gives 4294967295 now, still getting error, will investigate
01:31:45 <dolio> Function types.
01:31:47 <Cin> -> reads "is a function that returns"
01:31:49 <Cin> aw
01:31:58 <Cale> and >> is an operator symbol for 'then' in combining monadic computations
01:32:12 <Cale> Cin: oh, at the type level, right, yes :)
01:32:17 <Cin> :D
01:32:29 <sarehu> Cale: then?  more like ';'
01:32:42 <Cale> sarehu: same thing
01:32:44 <wagle_home> > [1,2] >> [3,4]
01:32:46 <lambdabot>  [3,4,3,4]
01:32:48 <Cin> sarehu: isn't ';' just syntactic sugar for '>>'?
01:32:51 <sarehu> oh wait, C++ doesn't have 'then' :)
01:33:01 <Cale> English has 'then'
01:33:23 <b_jonas> @undo do { True <- x; y }
01:33:23 <lambdabot> x >>= \ a -> case a of { True -> y; _ -> fail ""}
01:33:25 <Cale> As in 'do this, then do that'
01:33:31 <resiak> aNDTHEN = (>>)
01:33:33 <b_jonas> @pl \x -> if x then y else z
01:33:34 <lambdabot> flip (flip if' y) z
01:33:35 <resiak> nOANDTHEN = return ()
01:33:43 <Cale> Right, -> also occurs in lambda syntax
01:33:44 <b_jonas> @type if'
01:33:45 <lambdabot> Not in scope: `if''
01:34:02 <sarehu> can you implement comeFrom with monads?
01:34:06 <Cale> if' b t e = if b then t else e
01:34:17 <Cin> cale: occurs in quite a few places, really. very hard to get confused, though, so, no complaints
01:34:22 <b_jonas> sarehu: lol, good question
01:34:24 <wagle_home> how does "then" work with [1,2] >> [3,4]?
01:34:25 <Cale> sarehu: hmm, possibly sort of.
01:34:35 <opqdonut> wagle_home: observe
01:34:40 <opqdonut> > [1,2] >> [3,4]
01:34:41 <lambdabot>  [3,4,3,4]
01:34:54 <Cale> wagle_home: Pick one of [1,2] then pick one of [3,4] and return it
01:34:55 <wagle_home> if you look above, i already did that
01:34:59 <opqdonut> yep
01:35:00 <Cale> Do this in all possible ways.
01:35:08 <opqdonut> Cale explains it pretty well
01:35:12 <Cale> (and collect up a list)
01:35:16 <proqesi> > [1,3] >> [2,6]
01:35:17 <lambdabot>  [2,6,2,6]
01:35:26 <Cale> > [1,2,3] >> [2,6]
01:35:26 <lambdabot>  [2,6,2,6,2,6]
01:35:42 <Cale> > [1,2,3] >>= \x -> [20 + x, 60 + x]
01:35:43 <lambdabot>  [21,61,22,62,23,63]
01:35:50 <wagle_home> a little more than "then"
01:36:22 <opqdonut> well the action that the list monad performs is "select one"
01:36:40 <opqdonut> select one from [1,2]; forget and select one from [3,4]
01:36:45 <b_jonas> what's that if' ?
01:36:49 <opqdonut> but all possible routes of execution are tried
01:36:53 <b_jonas> where is it defined?
01:36:59 <Cale> b_jonas: I gave an implementation. It's a folk-function
01:37:05 <Cale> (it's not in the libraries)
01:37:08 <wagle_home> @src if'
01:37:08 <lambdabot> Source not found. That's something I cannot allow to happen.
01:37:12 <b_jonas> ah, I see
01:37:16 <b_jonas> Cale: thanks
01:37:18 <Cale> if' b t e = if b then t else e
01:37:25 <Cale> or:
01:37:37 <Cale> if' b t e = case b of True -> t; False -> e
01:37:53 <pejo> Cale, why would one want if'?
01:37:55 <Cale> (which shows that we *could* make if into just a plain function in Haskell)
01:37:56 <wagle_home> or
01:38:12 <mux> pejo: to demonstrate the usefulness of laziness :D
01:38:13 <Cale> pejo: It sometimes is handy as a parameter to a higher order function.
01:38:49 <pejo> mux, amazing how often we demonstrate the usefulness of lazy evaluation, and rarely the drawbacks. ;)
01:38:55 <Cale> and of course, in making points-free versions of code that uses if-expressions :)
01:38:57 <pjd> wagle_home: you could read [1,2,3] >> [2,6] as "item? then [2,6]"
01:39:02 <Cin> coming from lisp i found the `then' and `else' quite superfluous
01:39:12 <Cale> I actually like the 'then' and 'else'
01:39:22 <wagle_home> @let { if'' True = \x y -> x ; if'' False = \x y -> y }
01:39:23 <lambdabot> <local>:1:0: parse error on input `{'
01:39:27 <wagle_home> awww
01:39:31 <Cale> Because they stick out and help guide your eye to the right place.
01:39:34 <pjd> Cale: yeah, they do a lot for readability
01:39:46 <Arnar> Cale: pulled lambdabot again and upgr. to ghc 6.8.2 - get a little fewer dependency reports
01:39:56 <Arnar> in particular: arrows -any, zlib -any, binary >=0.2, plugins >=1.0, oeis -any
01:39:58 <Cale> Arnar: You'll need oeis, numbers
01:40:01 <proqesi> then gives me warm fuzzies from the pascal days
01:40:04 <Cale> Arnar: and maybe a few others
01:40:11 <Arnar> Cale: ok, just find 'em on hackage?
01:40:16 <Cale> Arnar: yep
01:40:19 <Arnar> thanks
01:40:28 <pjd> the same can be said for [blah for x in xs]
01:40:53 <wagle_home> by the way guys, i understand the list monad, i was just questioning reading ">>" as "then"
01:41:09 <Cin> pjd: that syntax exists?
01:41:19 <pjd> Cin: in Python, yes :)
01:41:22 <Cale> wagle_home: It requires a particular way of thinking about the list monad in order to see 'then' as appropriate there, I agree.
01:41:29 <Cin> pjd: ah
01:41:49 <Cale> [blah | x <- xs] looks nice to me, but I'm a mathematician :)
01:42:14 <Cin> cale: plus you can add conditions and whatnot..
01:42:17 <wagle_home> hmm...  [1,2] thenthenthenthen [3.4]
01:42:41 <sarehu> now all we need is {blah | x <- xs} for Data.Set
01:42:42 <b_jonas> wagle_home: aren't you confusing (>>) with mplus?
01:42:49 <Cale> looks somewhat reminiscent of {blah | x ‚àä xs}
01:42:53 <b_jonas> > [1,2] >> [3]
01:42:53 <lambdabot>  [3,3]
01:42:59 <b_jonas> > [1,2] mplus [3]
01:42:59 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
01:43:01 <Cale> sarehu: yeah :)
01:43:02 <wagle_home> [1,2] `mplus` [3,4]
01:43:07 <b_jonas> yeah, that
01:43:10 <b_jonas> > [1,2] `mplus` [3]
01:43:10 <lambdabot>  [1,2,3]
01:43:12 <wagle_home> > [1,2] `mplus` [3,4]
01:43:13 <lambdabot>  [1,2,3,4]
01:43:19 <b_jonas> you could call either "then"
01:43:20 <wagle_home> no
01:43:23 <Cin> sarehu: iirc the { blah | x <- xs } notation worked on all monads before it was restricted to lists..
01:43:26 <Cale> There are not enough different kinds of brackets.
01:43:46 <Cale> The list comprehension notation worked on all monads.
01:43:51 <sarehu> Cin: I mean specifically for '{' and '}'
01:43:54 <pejo> Cale, so you can't wait for unicode to introduce more of them? :-)
01:43:55 <Cin> oh righ
01:44:05 <wagle_home> lists represent "non-determinism"..  so there are 4 thens between 2 lists of 2
01:44:16 <Cale> Well, all MonadZeroes :)
01:44:34 <Cin> yay unicode Œª_Œª
01:45:12 <Cale> ‚óê_‚óê
01:45:18 <Cin> reminds me of Felix
01:45:20 <Cale> ‚óë_‚óë
01:45:21 <mux> ‚ü¶ ‚üß
01:45:37 <Cale> ‚óë_‚óê
01:45:39 <Cale> hehe
01:46:00 <opqdonut> ^              ^
01:46:01 <Cale> Unicode-art is so versatile :)
01:46:52 <Cale> ‚óù‚óØ‚ó†‚óØ
01:47:21 <Cin> nerdicode
01:48:40 <wagle> 8√û
01:49:14 <wagle> wow..  xchat really really really didnt want to let me do that
01:50:28 <Cale> www.‚ò≠.net
01:50:44 <Cale> Interestingly, that exists.
01:51:00 <phlpp> byorgey: i think a collaborative editor written in haskell would be a great idea ;-)
01:51:08 * Cale wonders what other unicode symbols have websites associated with them.
01:51:33 <phlpp> byorgey: i mean, as you wrote in your blog entry, there are very few (no?) good collaborative editors in the (free) software world
01:51:52 <wagle> ‚å†
01:51:52 <wagle> ‚éÆ dx
01:51:52 <wagle> ‚å°
01:51:53 <Cin> i've got all my set-builder notation characters setup with xmodmap and of course AltGr+\ for Œª.
01:51:55 <wagle> bah
01:51:59 <Cin> wagle: nice
01:52:14 <wagle> didnt come out well here\
01:52:17 * quicksilver has used emacs for collaborative editing but I imagine it fails byorgey's "goodness" criterion
01:52:19 <phlpp> byorgey: gobby seems to be the best, but it's still not supporting undo and chat system etc. is kinda ugly
01:52:23 <sarehu> holy crap
01:52:28 <phlpp> quicksilver: :D
01:52:29 <sarehu> lambdabot> > 2 + 3
01:52:29 <sarehu>  5
01:52:39 <Cale> sarehu: what?
01:52:52 <sarehu> I had to write my own setResourceLimits but it worked :)
01:52:55 <phlpp> quicksilver: do you have any further tutorials/how to for collaborative editing with emacs? heard the first time about that
01:52:57 <jeffz> phlpp: a collab editor in haskell would be good.. as long as it has emacs key bindings
01:52:59 <Cale> oh right :)
01:53:05 <phlpp> jeffz: yep!
01:53:13 <quicksilver> phlpp: just open an emacs frame on both your X displays.
01:53:15 <quicksilver> phlpp: job done.
01:53:21 <therp> X would be good, as long as it has emacs key bindings
01:53:22 <quicksilver> phlpp: it's worked for about 15 years :)
01:53:28 <Cin> jeffz: Yi could be it!
01:53:34 <therp> (X is a variable, not X windows)
01:53:36 <phlpp> jeffz: so as byorgey suggested, it would be bust to have some Yi backend for this
01:53:42 <Cale> *configurable* keybindings are better than emacs keybindings
01:53:48 <phlpp> quicksilver: :p
01:53:51 <quicksilver> actually, they appear better
01:53:54 <quicksilver> but are in fact worse
01:54:10 <quicksilver> configurable keybindings just encourage people to use something other than the one true keybinding
01:54:16 <quicksilver> ultimately this is not doing them a favour
01:54:23 <quicksilver> ;)
01:54:30 <Cin> you mean when they use someone else's computer?
01:54:36 <quicksilver> much better if everyone learns the one true keybindings
01:54:36 <Cin> that's the issue i had with dvorak >_>
01:54:39 <quicksilver> then all apps use the same
01:54:43 <quicksilver> all computers use the same
01:54:55 <quicksilver> and you don't have to keep relearning for new OSes/ apps/ other peoples computers.
01:54:56 <wagle> a ‚û™‚û´‚û¨‚û™ twist a
01:55:46 <paolino> what are main advantages of 6.8.2 on 6.6.1 ?
01:56:02 <Cin> Cale: gutsy seems to come with a big set of unicode characters with AltGr which Feisty did not have. i guess they thought it was a good idea. ‚Üì‚Üê‚Üì‚Üí nice to have these arrows.
01:56:17 <jedbrown> paolino: The debugger is a big one.  It's also much faster and produces better code.
01:56:26 <wagle> you cant run 6.8.2 on your macosx 10.5 ppc machine
01:56:47 <wagle> so you dont get distracted by all the cool new features
01:56:49 <Cale> Cin: I don't have an AltGr key, but I have set up a Compose key, a quick way to switch to Greek layout, and SCIM.
01:56:59 <paolino> jed
01:57:01 <Cin> cale: ah, nice
01:57:11 <paolino> and for the language ?
01:57:45 <paolino> only exotic (to me) things ?
01:58:18 <quicksilver> there aren't big language changes
01:58:24 <quicksilver> the -X options have been regularised
01:58:33 <quicksilver> and there are some partially implemented features
01:58:41 <jedbrown> paolino: What do you mean?  If you are using newer language extensions, of course they will be better supported on 6.8.  There are some packaging changes.
01:58:42 <quicksilver> but since they're only partially implemented, probably not that useful ;)
01:59:24 <paolino> :) I have a look to the debugger
02:00:10 <wagle> there must be more than the debugger
02:00:33 <jedbrown> paolino: for the sexy debugger intro: <http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/14>
02:02:43 <pejo> quicksilver, what do you mean "all apps", I thought you just said Emacs? There can be only one.
02:03:15 <quicksilver> pejo: no, I don't really subscribe to that view.
02:03:23 <quicksilver> pejo: other applications have different display models
02:03:31 <quicksilver> pejo: emacs can't be a decent graphical web browser, e.g.
02:03:44 <quicksilver> but my decent graphical web browser should use emacs keybindings, clearly
02:03:53 <wagle> the release notes associated with each version in http://www.haskell.org/ghc/ give the details
02:03:54 <lambdabot> Title: The Glasgow Haskell Compiler
02:04:55 <paolino> oh, this Is something really good , a debugber in ghci, just what I would like already to need in my editor . Welcome 6.8.2
02:05:26 <paolino> *debugbeer
02:05:54 <wagle_home> why debug..  just keep testing
02:06:08 <jedbrown> pejo, quicksilver: It would be really nice if I could use emacs bindings in any text input field.  Settings in gtkrc (sort of) does this for gtk apps, but it could be more pervasive.
02:07:16 <pejo> jedbrown, hm. Works in my Safari for example.
02:07:50 <b_jonas> oh noes
02:07:57 <b_jonas> I have a haskell question but I have to leave now
02:08:14 <b_jonas> so I'll just ask it later when I have time to think about the answers
02:08:20 <wagle_home> ask, and go imagine what the answer will be
02:08:23 <Cin> b_jonas: tell lambdabot to remind you when you come back :D
02:09:32 <b_jonas> I tried the dvorak layout but I don't like it
02:09:39 <Cin> Where do you begin to debug this? Not much information. Now, some people, at this point would mumble something about monads being too hard, and rewrite the project in Python, but there's no need.
02:09:43 <Cin> i laughed hard
02:09:51 <paolino> wagle_home: we are not saints, I -sometimes-  fall in tentation and write the code before tests (always -1)
02:10:08 <jedbrown> pejo: I'm not familiar with safari, but M-b in firefox opens the Bookmarks menu rather than backward-word.  And non-gtk apps are free to do their own thing.  But menus complicate things unless you make them inaccessible from the keyboard, which is not a solution.
02:10:34 <wagle_home> paolino, i meant why debugbeer?  just keep testing it..
02:10:35 <slarba_> paolino: that's not a sin
02:10:44 <b_jonas> ok, bye
02:11:00 <slarba_> paolino: sometimes you just don't know what to test before you sketch something first :)
02:11:26 <paolino> eheh, right, this is fun to me also "the             evaluator will suspend execution approximately after every             reduction"
02:11:50 <wagle_home> i'm finding it hard to get people to pay me for exploring plato's cave for new programs
02:12:18 <quicksilver> jedbrown: that's what I was getting at, yes
02:12:32 <quicksilver> jedbrown: OSX puts the basic line editing bindings in all native text widgets, for example.
02:13:10 <wagle_home> quicksilver, i've seen things apparently go to pains to remove those very-nice-bindings
02:15:10 <paolino> the :force command will be made available to lamdabbot , maybe
02:15:25 <jedbrown> quicksilver: I think it's fine if those are configurable, but it should be all in one place.  Trouble is, not all apps use the same widget set.
02:15:35 <wagle_home> :force [1..]
02:15:55 <wagle_home> oh oh
02:16:17 <wagle_home> (what would the ;force directive do?)
02:19:11 <jedbrown> ?hoogle amap
02:19:11 <lambdabot> Data.Array.IArray.amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
02:19:32 <sarehu> wagle_home: probably say something
02:19:35 <sarehu> like "I find your lack of finiteness disturbing."
02:19:52 <jedbrown> Would anyone find it useful if this had signature   (e' -> e) a' i e' -> a i e   instead?
02:20:24 <jedbrown> *   (e' -> e) -> a' i e' -> a i e
02:20:25 <wagle_home> sarehu, lol
02:20:53 <jedbrown> So that the type of Array could change.  Why is this more general signature not used?
02:21:00 <quicksilver> jedbrown: well you'd need to check the bounds and stuff
02:21:13 <jedbrown> quicksilver: No problem, the index type is the same.
02:21:21 <Cin> sarehu: finity should be a word :(
02:21:33 <sarehu> Cin: I'm sorry.
02:21:35 <jedbrown> quicksilver: It just lets you go from an Array to UArray, for instance.
02:21:45 <Cin> sarehu: we should introduce it :
02:22:01 * quicksilver nods
02:22:22 <jedbrown> quicksilver: Looking at the code, I don't think there would be any performance difference.
02:22:37 <quicksilver> rather like freeze
02:22:38 <sarehu> we should do it within a finity of weeks
02:22:40 <quicksilver> only without the M part
02:22:50 <Cin> sarehu: hehe
02:22:51 <paolino> wagle_home: I was thinking, those commands are someway useful for makeing someone understand lazyness and functional more, also in the channel
02:23:08 <Cale> I want a Haskell implementation of the falling sand game. Also, I want it to use parallel arrays and I want a multicore machine to run it on. ;)
02:23:23 <sarehu> what's the falling sand game?
02:23:46 * sarehu googles
02:24:43 <Cale> You can find it on the web in various places. My favourite implementation is here: http://dan-ball.jp/en/javagame/dust/
02:24:45 <lambdabot> Title: Powder Game - Web Game Site DAN-BALL
02:27:01 * Cale feels slightly evil for posting that link, as it will be a massive timesink for anyone who clicks on it :)
02:28:52 <proqesi> saved by java! lol
02:29:10 <Cale> haha
02:29:49 <Cale> Well, anyway, the basic idea is that it's a sort of cellular automaton/physical particle simulation.
02:30:11 <Cale> The one I linked to also simulates air pressure, so you can have things like explosions :)
02:30:33 <nominolo> i guess /msg to lambdabot doesn't work in all cases "Maximum users seen in nominolo: 1, currently: 0 (0.0%), active: 0 (NaN%)"
02:30:42 <Cale> and there are a whole bunch of different particle types and they interact in various ways
02:31:04 <Cale> nominolo: It's nearly accurate :)
02:31:05 <wagle_home> http://chir.ag/stuff/sand/ is kinda cool
02:31:06 <lambdabot> Title: Falling Sand Game - hosted by Chirag Mehta @ chir.ag
02:31:39 <Cale> Yeah, that's a big version of the original FSG
02:31:47 <nominolo> guess it doesn't account for split personalities and such
02:33:51 <sarehu> whoa, I just right clicked
02:34:53 <Cale> sarehu: where?
02:40:31 <jedbrown> Bulat is reversing record addressing on -cafe.  Heresy!
02:41:22 <Arnar> Cale, sorry to bother you again but I'm hitting some walls in following all the dependencies :/
02:41:33 <Arnar> in particular I can't get zlib installed
02:41:44 <Cale> Arnar: okay, what error do you get?
02:41:59 <Arnar> configure doesn't report any errors, but compiling gives "could not find modle 'data.bytestring.base'
02:42:37 <Cale> Okay... which zlib is that?
02:42:44 <Arnar> 0.4.0.2
02:42:50 <Arnar> latest from hackage
02:43:14 <Cale> and your bytestring version is 0.9.0.1 ?
02:43:22 <Cale> ghc-pkg list bytestring
02:43:33 <Arnar> yup
02:43:39 <Arnar> 0.9.0.1
02:44:07 <dolio> jedbrown: That's all been proposed before. :)
02:44:08 <Arnar> See there is a later one..
02:44:19 * Arnar tries bytestring 0.9.0.4
02:44:29 <quicksilver> Cale: I want a lemmings or worms-alike game in haskell which is based on the physics engine of the falling sand game.
02:44:33 <Cale> Try just replacing that import with Data.Bytestring
02:44:39 <Cale> (that is, chop off the .Base)
02:44:43 <Arnar> oh, ok
02:44:46 <mux> mmm, worms armageddon is such a hot game
02:44:55 <mux> it never ceased to amuse me
02:45:52 <Arnar> Cale: that did the trick..
02:46:04 <Arnar> now, is this how I give karma --> Cale++ ?
02:46:12 <Cale> yeah, that should work :)
02:46:16 <Arnar> :)
02:46:20 <Arnar> thanks
02:49:18 <wagle_home> jedbrown, the mailing list?  i dont find it
02:49:50 <dolio> It's actually on haskell@, not cafe.
02:50:33 <Arnar> where does cabal-install do it's work?
02:50:36 <quicksilver> fear the static duck!
02:50:53 <dolio> I wonder what makes him bring it up now.
02:51:20 <Cale> Uh, that code in Bulat's message wasn't intended as Haskell code.
02:51:30 <Cale> Er, at least at the top.
02:51:43 <Cale> oh
02:51:57 <Cale> hmm
02:52:20 <Cale> ah, yeah, he does use that...
02:52:24 <Cale> Weird.
02:52:47 * wagle_home ponders if classes provide typed duck typing
02:52:53 * wagle_home ponders if classes provide static duck typing
02:53:07 * wagle_home then goes to bed
02:53:18 <quicksilver> I imagine he's working on a program which uses lots of records
02:53:29 <quicksilver> I think there is a pretty general consensus that records could do better.
02:53:44 <quicksilver> just no consensus on a concrete proposal which actually would be better.
02:53:49 <dolio> Yeah. There are a lot of papers on the subject I like.
02:54:17 <dolio> Or, maybe not a lot, but more than one, at least. :)
02:54:48 <quicksilver> I think I like the general idea of auto-generated selector functions.
02:54:57 <quicksilver> But I'd like it changed to auto-generated lenses instead
02:55:00 <quicksilver> which is more generally useful
02:55:11 <wagle_home> "lenses"?
02:55:12 <quicksilver> (and then scrap the ad-hoc update syntax, probably)
02:55:29 <quicksilver> wagle_home: a lense selects one component and gives you a function to update it
02:55:38 <quicksilver> for a record of type r, with a component of type s, it's:
02:55:46 <quicksilver> lens :: r -> (s,s -> r)
02:56:09 <wagle_home> ok..  thanks
02:56:18 <quicksilver> and *probably* use some hierarchical namespacing for them
02:56:24 <quicksilver> although I'm not 100% sure about that
02:57:46 <dolio> Using . for access is a sticky issue, as well, since it's already fairly overloaded.
02:58:10 <Cale> I like  pt{x}  for extracting the x field of pt
02:59:16 <Cale> At least, if the usual function syntax can't be kept.
02:59:56 <quicksilver> I'm not sure any special syntax for access is called for
03:00:01 <quicksilver> get x pt
03:00:07 <quicksilver> where get is a completely normally function
03:00:25 <quicksilver> (get :: (r -> (s,s->r)) -> r -> s )
03:00:51 <quicksilver> get lens rec = fst (lens rec)
03:01:12 <quicksilver> and similarly modify + put
03:01:21 <quicksilver> perhaps not with those exact names
03:01:21 <Cale> What about if we want row-polymorphism of some sort?
03:01:48 <Cale> http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf -- I really like the semantics proposed in this paper.
03:01:49 <lambdabot> http://tinyurl.com/392r4k
03:01:58 <Cale> But I don't care at all for the syntax used there.
03:02:23 <Arnar> next problem up: can't compile plugins as it says array-0.1.0.0 is hidden, even though I've ghc-pkg exposed it
03:02:46 <Cale> Arnar: You have the wrong version of plugins...
03:02:56 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
03:02:57 <lambdabot> Title: Index of /~dons/code/hs-plugins
03:03:07 <Arnar> Cale: thanks again..
03:03:08 <Cale> Don't ask me why it's not in Hackage yet :)
03:03:19 <Arnar> :)
03:03:45 <Arnar> this is fun
03:03:59 <Cale> I only committed the patch to make it work in 6.8.2 :)
03:04:04 <Arnar> reminds me of my old days of compiling software for slackware
03:04:07 <Cale> heh
03:04:15 <Cale> Well, you could get cabal-install
03:04:29 <Arnar> yeah.. did that after manually getting 5 packages
03:04:30 <Cale> which I probably should have recommended right at the start :)
03:04:50 <Arnar> of course, I had to follow some more to get caba-install itself installed :)
03:04:56 <Cale> heh
03:05:05 <Cale> Yeah, things will be better in the next ghc
03:05:12 <Cale> Because cabal-install will be included.
03:05:24 <Arnar> excellent
03:05:31 <Cale> (and built into the main cabal, hopefully)
03:05:39 <Cale> er...
03:05:53 <Arnar> mm..
03:05:58 <Cale> Something like that :)
03:06:04 <Arnar> plugins from dons ws doesn't compile
03:06:10 <Cale> mm..
03:06:18 <Cale> What's the error now?
03:06:19 <Arnar> "Not in scope: data constructor 'InstalledPackageInfo'"
03:06:24 <Cale> d'oh
03:06:36 <Cale> ghc-pkg list Cabal
03:06:49 <Arnar> 1.2.3.0 and 1.3.3
03:06:58 <Cale> Maybe try hiding 1.3.3
03:06:58 <Arnar> had to get 1.3.3 for cabal-install
03:07:01 <Arnar> ok
03:07:02 <Cale> oh
03:07:27 <Cale> Or you might have to edit the plugins.cabal
03:07:39 <Arnar> ok..
03:07:48 <Arnar> well, hiding it didn't do the trick
03:07:53 <Cale> Instead of Cabal >= 1.2.3  it should probably say Cabal == 1.2.3
03:08:05 <Cale> yeah, I'm not sure how the hide/expose thing works exactly
03:08:05 <desegnis> wagle_home, it's at least possible to say that type classes sort of give you what duck typing gives you elsewhere. furthermore, Haskell's class default methods may remind of Ruby's mixins
03:09:15 <Cale> hmmm
03:09:48 <Arnar> ok, edited the cabal file and now it seems to compile
03:10:34 <Cale> great
03:10:59 <Arnar> dependency list for lambdabot shortens..
03:11:06 <Arnar> it still complains about arrows and binary
03:11:09 <Cale> I think Cabal basically overrides GHC's hide/expose mechanism.
03:11:10 <Arnar> which are both installed
03:11:19 <Cale> oh
03:11:25 <Arnar> ok ic
03:11:55 <Cale> are arrows and binary installed as user or global?
03:12:06 <Arnar> hmm..
03:12:08 <Arnar> user, apparently
03:12:22 <Arnar> can I make cabal-install install in the global location?
03:12:24 <Cale> yeah
03:12:32 <Arnar> just sudo it perhaps
03:12:36 <Cale> sudo cabal --global install arrows
03:12:44 <Arnar> ok nice
03:12:44 <pejo> Someone mentioned earlier that cabal does --hide-all-packages or what it was called. So things not exposed through the cabal file doesn't show up (as you've noticed).
03:13:05 <Arnar> hmmm
03:13:12 <Arnar> unrecognized option `--global'
03:13:33 <doserj> cabal install --global
03:13:37 <Arnar> ah :)
03:14:10 <Arnar> guess I have to remove arrows and binary from the local user dir first
03:14:45 <Cale> Maybe cabal-install has updated recently or something :)
03:14:58 <Cale> I installed it with Cabal 1.2.3.0
03:15:28 <Cale> But yeah, we've been having versioning hell :)
03:15:56 <Arnar> what's the best way to remove stuff from the user package.conf ?
03:16:18 <Arnar> ghc-pkg unregister?
03:18:48 <desegnis> Arnar, I guess so. mind you, it won't really uninstall the library
03:19:01 <byorgey> ghc-pkg unregister --user
03:19:29 <Arnar> thanks
03:20:04 <jedbrown> Cale: darcs cabal-install has a number of new features, but it needs darcs Cabal.
03:22:31 <Arnar> lambdabot building :)
03:23:31 <Cale> yay :)
03:23:47 <Arnar> lol
03:24:00 <Arnar> Setup.hs: LICENSE: copyFile: does not exist (No such file or directory)
03:24:12 <Arnar> touch LICENSE
03:25:31 <Cale> yeah, that's kinda dumb. I should have pushed that along with my patch :)
03:25:33 <Arnar> wohoo \o/
03:25:34 <Arnar> lambdabot> version
03:25:35 <Arnar> lambdabot 4p590, GHC 6.8.2 (Darwin i386)
03:25:55 <Cale> ls
03:26:15 <Cale> heh
03:26:18 <byorgey> nice!
03:28:03 <Cale> byorgey: I patched lambdabot today. We should have a new one as soon as dons gets GHC 6.8.2 installed on code.haskell.org
03:28:11 <Arnar> thanks all
03:28:12 <Cale> (or whoever's responsible for that)
03:28:46 <Arnar> now I just need to integrate it with my editor :P
03:29:09 <Cale> :)
03:29:35 <Cale> I'm still happy that I just managed to get hs-plugins working on 6.8.2 :)
03:30:12 <Arnar> :)
03:35:17 <thegraham> If I have a function search :: ((Formula, Model) -> [(Formula, Model)])
03:35:17 <thegraham>           -> [(Formula, Model)]
03:35:17 <thegraham>           -> Int
03:35:17 <thegraham>           -> (Bool, Int), how do I pass arguments for the first part (I've forgotten what ((Formula, Model) -> [(Formula, Model)]) does)
03:35:37 <Arnar> Cale: There is one thing..
03:36:01 <Arnar> lambdabot is outputinng some info, like "Plugin.Djinn: couldn't find djinn binary" and "State/seen: openBinaryFile: does not exist" etc..
03:36:04 <EvilRanter> the first parameter must be a (Formula, Model) -> [(Formula, Model)], ie a function (->) that takes a (Formula, Model) and returns a [(Formula, Model)]
03:36:10 <Arnar> those seem to go to stdout and not stderr
03:36:20 <Arnar> so I can't really use lambdabot -e bla from my editor
03:36:25 <EvilRanter> a [(Formula, Model)] is a list of (Formula, Model) pairs
03:36:31 <Arnar> do I have to recompile with verbose=False ?
03:36:38 <doserj> Arnar: start lambdabot from the directory where you compiled it
03:37:17 <Cale> hmm, how do I pageup/down inside of a screen session?
03:37:49 <Arnar> doserj: ok, thanks
03:38:12 <thegraham> EvilRanter, thanks, but why would you want to pass a function as an argument, couldn't you just call it anyway?
03:38:17 <benny> Cale: C-a ESC C-u C-d
03:38:24 <C-Keen> Cale: on a mac?
03:38:37 <Cale> benny: thanks
03:38:45 <EvilRanter> ?type map -- you want to pass a function as an argument to this
03:38:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:39:10 <EvilRanter> ?type filter -- or this
03:39:11 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:39:21 <Cale> That somehow manages to fail to be documented on screen's interactive help page :)
03:40:32 <EvilRanter> thegraham, ever used callbacks in other programming languages? or the visitor pattern?
03:40:39 <EvilRanter> same thing, really.
03:41:07 <benny> yeah, it's the copy mode... but you have to know that.
03:41:42 <ricky_clarkson> thegraham: Imagine you're writing a sorting mechanism for lists, and want the caller to be able to specify what to sort by.
03:42:21 <ricky_clarkson> @hoogle sort
03:42:22 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
03:42:22 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
03:42:22 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
03:42:29 <ricky_clarkson> @hoogle sortBy
03:42:29 <lambdabot> Data.List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:42:33 <thegraham> ricky_clarkson: Thanks. that really helps!
03:42:56 <ricky_clarkson> > sortBy (\x y -> x<y) [1,4,6]
03:42:57 <lambdabot>  Couldn't match expected type `Ordering'
03:43:03 <ricky_clarkson> pah :)
03:43:33 <ricky_clarkson> > sortBy (\x y -> if (x<y) then LT else GT) [1,4,6]
03:43:34 <lambdabot>  [1,4,6]
03:43:41 <ricky_clarkson> > sortBy (\x y -> if (x>y) then LT else GT) [1,4,6]
03:43:42 <lambdabot>  [6,4,1]
03:43:54 <Cale> > sortBy (flip compare) [1,4,6]
03:43:55 <lambdabot>  [6,4,1]
03:44:02 <pjd> Cale: man screen -> /scrollback :)
03:44:07 <ricky_clarkson> :t compare
03:44:08 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
03:50:38 <Arnar> When I ask lambdabot to run anything, it says "Failed to load interface for 'Data.Number.Symbolic'"
03:50:45 <Arnar> another dependency?
03:52:46 <Arnar> :type STM
03:52:57 <Arnar> @type STM
03:52:58 <lambdabot> Not in scope: data constructor `STM'
04:01:08 <quicksilver> @kind STM
04:01:09 <lambdabot> Not in scope: type constructor or class `STM'
04:13:27 <jedbrown> I'm feeling slow.  Do I need a new multi-parameter type class to define abs in a sane way (i.e. takes real or complex and produces a real)?
04:14:18 <ricky_clarkson> @google plinging function
04:14:19 <lambdabot> http://openquark.org/svn/openquark/tags/1.5.1_0/CAL_Eclipse_Help/content/bk02ar02s05.html
04:14:19 <lambdabot> Title: What is plinging? Part 1: plinging of function arguments
04:14:43 <dcoutts_> jedbrown: no, class Abs a where abs :: a -> Double
04:15:08 <dcoutts_> erm, probably Num a =>
04:15:44 <ricky_clarkson> plinging makes args strict (in CAL)?  What dictionary did they pluck that word from?
04:16:22 <jedbrown> dcoutts_: Hmm, what about the case (Complex Float -> Float)?
04:16:25 <allbery_b> someone or other used to refer to the "#!" at the beginning of a unix script as "hash-pling"
04:16:34 <ricky_clarkson> allbery_b: ahh
04:16:46 <ricky_clarkson> Then it makes sense because they use ! to denote a plinged arg.
04:17:02 <dcoutts_> jedbrown: if the output type is not fixed and is not the same as the input then you need another class parameter
04:17:15 <ricky_clarkson> I suppose that's better than "a banged arg"
04:17:22 <allbery_b> (normal people say hash-bang, but I suppose "banging" an argument is a bad idea :)
04:17:28 <ricky_clarkson> heh
04:17:32 <quicksilver> dcoutts_: unless you're prepared to make it polymorphic, which may not be effcicient
04:17:52 <quicksilver> dcoutts_: (RealFloat a,Num b) => b -> a
04:17:55 <quicksilver> or somethign
04:18:00 <dcoutts_> right
04:18:14 <dcoutts_> that'd probably be ok actually
04:18:53 <jedbrown> quicksilver: I'm not sure I get how that works.
04:19:22 <jedbrown> quicksilver: Basically, it needs to use magnitude when the argument is complex and just abs when it is not.
04:19:23 <quicksilver> :t round
04:19:24 <ricky_clarkson> I'm disappointed there's no #cal or ##cal here, it looks like an interesting competitor to Scala.
04:19:24 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
04:19:30 <quicksilver> analogous to that
04:19:33 <dcoutts_> jedbrown: class Num a => Abs a where abs :: Num b => a -> b
04:19:40 <quicksilver> round takes any real type and returns any integral type
04:19:49 <quicksilver> you could have abs takes any num type and returns any real type
04:20:14 <jedbrown> Ah yes.  Thanks.
04:21:03 <jones-> Hello.
04:21:36 <jones-> I downloaded ghc's binaries. What's the correct way to use those? I don't have root's privileges on my machine.
04:22:20 <doserj> ./configure --prefix=<my-dir> (as stated in the INSTALL file)
04:22:53 <jones-> doserj: oh ok, I'll read it. I thought I'd get stuff to extract to my prefix.
04:25:52 <paolino> mmhh, pretty library doesn't configure
04:27:15 <paolino> it has no deps, just installed Cabal 1.2.3, but I get ghc-6.8.2: unable to load package `Cabal-1.2.3.0'
04:28:42 <paolino> the strange thing is I have just installed process which was failing with same error, before I installed Cabal 1.2.3
04:29:26 <paolino> actualy doesn't build, it does configure
04:30:16 <doserj> does is say more than just that? did you try -v?
04:30:53 <paolino> <interactive>: /usr/local/lib/Cabal-1.2.3.0/ghc-6.8.2/HSCabal-1.2.3.0.o: unknown symbol `processzm1zi0zi0zi0_SystemziProcessziInternals_a14_info'
04:31:05 <paolino> ghc-6.8.2: unable to load package `Cabal-1.2.3.0'
04:32:46 <paolino> @paste
04:32:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:32:56 <Cale> paolino: hmm... that's an odd time to get a message like that
04:33:17 <paolino> time of the day ?
04:33:18 <Cale> paolino: Usually link errors like that are caused by a package (in this case process) not getting loaded.
04:33:35 <doserj> paolino: Cabal depends on process (and pretty?). so if you update one of them, the installed cabal might break
04:33:37 <Cale> Which is usually because you've missed out a -package flag
04:33:46 <Cale> or the cabal file doesn't list the package.
04:33:54 <doserj> Cale: Setup.hs links against cabal
04:33:59 <Cale> But usually ghci will autoload the dependencies.
04:34:46 <hpaste>  paolino pasted "pretty doesn't configure" at http://hpaste.org/5482
04:36:08 <paolino> process seems linked
04:37:50 <paolino> the cabal file of pretty doesn't list process ?
04:38:04 <doserj> pretty doesn't need process. Cabal does
04:38:29 <paolino> ah ok
04:38:40 <doserj> and your Cabal is built against a different version of process than what is installed
04:38:58 <paolino> so It all broke when I installed process with Cabal
04:39:16 <doserj> that is my understanding, yes
04:39:23 <paolino> so now I have to rebuild Cabal, right=
04:39:53 <paolino> this doesn't make my CPU proud of me
04:40:03 <FunctorSalad> could someone explain the difference between runProcess and runInteractiveProcess?
04:40:22 <paolino> :t runProcess
04:40:23 <lambdabot> Not in scope: `runProcess'
04:40:48 <paolino> @hoogle runProcess
04:40:48 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
04:40:56 <FunctorSalad> I don't really get why one *takes* the pipes of the ran process as arguments, and the other *returns* them
04:41:23 <FunctorSalad> I think runInteractiveProcess doesn't wait for the process to finish.
04:41:42 <paolino> interactive creates the handles for you ?
04:41:49 <FunctorSalad> yeah
04:42:35 <jones-> Hi, I get this message when building some Haskell libraries (unix and X11). "/usr/bin/ld: cannot find -lgmp". What am I missing?
04:42:41 <FunctorSalad> and how would I make a handle to pass to runProcess as stdout (I mean a handle that somehow processes the output, not a file handle)
04:43:07 <moonlite> In Things to Avoid (http://www.haskell.org/haskellwiki/Things_to_avoid#Avoid_explicit_recursion) in the Wiki is the shorter count example not slower than the explicitly recursive one?
04:43:09 <lambdabot> Title: Things to avoid - HaskellWiki, http://tinyurl.com/3b2cfx
04:43:34 <matthew-_> jones-: libgmp3c2 iirc
04:43:38 <matthew-_> apt-get install it
04:43:43 <pejo> jones, it doesn't know where libgmp.so is located.
04:44:15 <paolino> what's wrong with interactive for that ?
04:44:25 <moonlite> i'd say the list is traversed twice (a smaller list the second time though) making it O(n+m) instead of O(n). True?
04:44:37 <nominolo> @seen byorgey
04:44:37 <lambdabot> byorgey is in #xmonad and #haskell. I last heard byorgey speak 1h 18m 19s ago.
04:44:49 <FunctorSalad> paolino: don't know, I just thought the asynchronicity might be overcomplication if I just want to read the stdout of the process
04:45:04 <FunctorSalad> (of course I can just waitForProcess)
04:45:23 <jones-> matthew-_, pejo: I have it installed in /usr.
04:45:50 <nominolo> wow, Consolata is pretty
04:45:57 <paolino> FunctorSalad: I used interactive and getContents, probably lazyness did the rest
04:46:02 <FunctorSalad> (actually I'm not sure about that, but I had a problem without waitForProcess)
04:46:21 <FunctorSalad> paolino: try something slower, like curl
04:46:45 <pejo> moonlite, it might be deforested.
04:46:54 <FunctorSalad> IIRC hGetContents didn't return anything
04:47:10 <FunctorSalad> (without waiting)
04:47:18 <nominolo> @seen vincenz
04:47:19 <lambdabot> vincenz is in #haskell. I last heard vincenz speak 2h 38m 42s ago.
04:47:22 <vincenz> yeS?
04:48:02 <nominolo> is Splash "complete" ?
04:48:13 <nominolo> it seems very small
04:48:19 <jones-> pejo: I have /usr/lib/libgmp.so.3
04:48:26 <nominolo> but maybe it's just elegant ;)
04:48:28 <paolino> FunctorSalad: it would be strange that runProcess solves that
04:48:53 <nominolo> er, sorry, Splatch
04:49:03 <pejo> jones, what parameters are passed to ld? It should look in /usr/lib by default afaik.
04:49:03 <moonlite> pejo: yep. :) However the original purpose of that long code snippet might actually be for performance
04:49:11 <moonlite> oh well. :)
04:49:29 <jones-> pejo: I don't know. I'm really new to haskell and I'm just doing "runhaskell Setup.hs build" in the source package.
04:50:54 <nominolo> > fromIntegral 0x99 / 0x100
04:51:09 <lambdabot>  thread killed
04:52:15 <nominolo> heh
04:52:19 <paolino> doserj: the reconfiguration of Cabal didn't imply the rebuild, I deleted dist
04:52:55 <vincenz> nominolo: no
04:53:04 <vincenz> nominolo: it's not complete
04:53:16 <vincenz> the foundations are there
04:53:29 <doserj> paolino: Setup.hs clean?
04:54:32 <paolino> ehm, next time I need to do that :/
04:55:02 <nominolo> vincenz: it's funny, though, how Brent just had the same idea like you. You should have promoted it better.  If that were dons' project that wouldn't have happened ;)
04:55:14 <vincenz> nominolo: well this idea came up at hac
04:55:24 <vincenz> nominolo: just collected dust after
04:55:36 <nominolo> unfortunately
04:55:54 <paolino> doserj: Cabal will never get out of these circles with all the packages it needs to build ?
04:57:04 <vincenz> nominolo: I'm not a good salesman?
04:58:23 <nominolo> dunno.  but at least a blog post would've been nice
04:58:31 <nominolo> aren't you on p.h.o?
04:58:36 <vincenz> p.h.o?
04:58:42 <nominolo> planet.haskell.org
04:58:47 <vincenz> oh, yes
04:59:02 <brian`> @instance Functor
04:59:02 <lambdabot> Maybe you meant: instances instances-importing
04:59:28 <doserj> paolino: it should work, I think
04:59:36 <paolino> Cabal configured pretty !
04:59:47 <jones-> Anyone else knows why I'm getting "cannot find -lgmp" from ld when compiling the X11 module, even tho I have /usr/lib/libgmp.so.3 and strace tells me that that file is bein read?
05:00:05 <nominolo> vincenz: just describing the basic ideas would help a lot
05:00:13 <vincenz> nominolo: alright
05:00:22 * vincenz puts in TODO's
05:00:23 <nominolo> vincenz: just to get some awareness
05:00:27 <daniel_larsson> jones-: I guess you have /usr/lib/libgmp.so as a symlink to it?
05:00:29 <nominolo> oh no ...
05:00:32 <nominolo> ;P
05:00:49 <nominolo> (TODO lists never work for me)
05:01:01 <jones-> daniel_larsson: no, that's missing. I created a symlink to it as /some/other/prefix/libgmp.so, where some/other/prefix is in my LD_LIBRARY_PATH, tho, but that didn't help.
05:01:06 <vincenz> nominolo: just ddn't seem to catch a lot of interest at the time so I let it colelct dust since it was still so much in infancy
05:01:08 <nominolo> but that might be just me
05:01:15 <vincenz> nominolo: I tend to blog only about finished things
05:01:58 <paolino> doserj: , there is law there, now I have to rebuild cabal for it is depending on pretty :)
05:02:12 <nominolo> vincenz: yes. but your idea is blogworthy, imho
05:02:15 <vincenz> alrighty
05:02:25 <vincenz> except that I noticed a conceptual bug today while cleaning up :)
05:02:39 <pejo> jones, uh, you want LDFLAGS set to -L/some/other/prefix, or whatever that is called in cabal. (/usr/lib is usually managed by your distribution, you shouldn't mess around with it manually).
05:02:39 * Cale hesitantly considers diving into GHC and attempting to implement proper records.
05:02:40 <nominolo> d'oh
05:02:57 <daniel_larsson> jones-: Okay. I've no clue, since you say the linker actually reads your library
05:03:01 <Cale> (and variants, while we're at it :)
05:03:15 <jones-> daniel_larsson: I just assume it's the linker.
05:03:27 <vincenz> nominolo: only one tho
05:03:30 <paolino> Cale, I will wash your dishes in the meanwhile
05:03:33 <vincenz> nominolo: so it should be solvable :)
05:03:34 <jones-> pejo: but I have LD_LIBRARY_PATH set to there. That should suffice, I would've said.
05:03:40 <Cale> The only things stopping me are that I know almost nothing about GHC's structure and that I haven't slept.
05:03:52 <pejo> jones, ld doesn't care about LD_LIBRARY_PATH
05:03:56 <vincenz> Cale: the former could be a problem :)
05:03:58 <pejo> jones, ld.so does though.
05:04:21 <Cale> vincenz: Indeed, it could.
05:04:34 <Cale> vincenz: But it would be *so* nice to have proper records and variants.
05:04:43 <daniel_larsson> Installing libgmp-devel (or whatever it may be called) should solve the symlink problem
05:04:45 <nominolo> vincenz: hopefully.
05:04:50 <Cale> and this paper tells us how to do it
05:04:52 * nominolo is off to lunch
05:05:02 <jones-> pejo: this doesn't work either: LDFLAGS=/work/prefix/other/lib runhaskell Setup.hs build
05:05:11 <paolino> Cale, that means to pass around records update as functions ?
05:05:21 <vincenz> nominolo: it just didn't seem very complicated, wasn't finished, lacked the actual server code and had no editor to plug into, and had no inter
05:05:24 <vincenz> ..erst
05:05:30 <vincenz> nominolo: so I didn't feel it was noteworthy
05:05:45 <nominolo> ok, maybe it's just me then
05:05:58 <nominolo> but i am *very* interested
05:06:01 <vincenz> but I tend to be hard on myslf :)
05:06:04 <vincenz> aright
05:06:09 <vincenz> well ti's on my daily/weekly todo list
05:06:09 <Cale> paolino: This means that you can say "this function operates on records having such and such fields of such and such types, along with possibly other fields that we don't care about"
05:06:14 <vincenz> which is a piece of paper I have with me at all times
05:06:18 <vincenz> so it'll be blogged about tonight
05:06:33 <desegnis> jones-: maybe have it set for the configure step, too
05:06:50 <nominolo> so do it for me, and maybe you get some more input from other knowledgeable people
05:06:58 <paolino> Ok, I will also cook for you for that
05:07:24 <jones-> desegnis, pejo: I think it's a known bug: http://hackage.haskell.org/trac/ghc/ticket/957
05:07:25 <lambdabot> Title: #957 (No way to use -lgmp from a non-standard location) - GHC - Trac
05:07:27 <nominolo> vincenz: some time this week would be fine with me
05:07:38 <pejo> jones, I'd go with daniel_larsson's suggestion and use your distributions libgmp/libgmp-devel instead.
05:08:00 <jones-> pejo: oh wait, I don't have libgmp-devel at all.
05:08:24 <daniel_larsson> jones-: the -devel package installs .so symlinks among other things
05:08:38 <Cale> paolino: I'd steal the semantics from here, in case you'd like a clearer picture of what I'm talking about http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf
05:08:39 <lambdabot> http://tinyurl.com/392r4k
05:08:41 <jones-> daniel_larsson: ok I'll install it; but can't to /usr, I'm not root.
05:09:15 <vincenz> nominolo: I like to get small things like that done quickly
05:09:35 <paolino> Cale that is a preprocessor task ?
05:09:36 <Cale> paolino: The syntax, I'd change. John Meacham had a great suggestion: label names start with a single quote (and are not character constants), and act as extraction functions.
05:10:06 <Cale> paolino: It requires additions to the type system, the syntax, umm...
05:10:40 <Cale> hmm, it might require some things farther back than that too.
05:10:44 <quicksilver> extraction function == selector?
05:10:48 <Cale> quicksilver: yeah
05:10:59 * quicksilver wants lenses not selectors
05:11:25 <quicksilver> and the minimum of extra syntax possible
05:11:30 <quicksilver> although single quote sounds quite neat
05:11:36 * vincenz gives quicksilver a monocle
05:11:38 <Cale> Have you read that paper?
05:12:09 <daniel_larsson> vincenz: Heh, you beat me to it
05:13:09 <Cale> There would be a bit of additional syntax for record construction, subtraction, and replacement
05:13:52 <Cale> We might be able to do away with the replacement sugar if we added lenses, but I don't think you could do away with subtraction, hmm...
05:14:41 <Cale> I'd also want to add variants (since once you have records like this, they're easy), and they'd have some additional syntax.
05:15:13 <quicksilver> I've read the paper but not for a few months
05:16:44 <Cale> http://article.gmane.org/gmane.comp.lang.haskell.general/15971 -- here's John's proposal for syntax.
05:16:45 <lambdabot> Title: Gmane -- Mail To News And Back Again
05:17:46 <FunctorSalad> err, I get a "openFile: resource busy (file is locked)" exception? I thought there are no file locks on linux?
05:18:04 <FunctorSalad> *ducks*
05:18:28 <quicksilver> FunctorSalad: GHC creates locks just to piss you off
05:18:34 <FunctorSalad> :)
05:18:38 <quicksilver> FunctorSalad: the idea is to make linux gain all the bugs win32 has
05:18:43 <allbery_b> another victim of lazy I/O?
05:18:47 <quicksilver> ;)
05:19:01 <quicksilver> Cale: John seems to be saying they should always be anonymous
05:19:12 <quicksilver> Cale: I'm not sure that's what you want. Although it's certainly useful.
05:19:14 <Cale> quicksilver: they should. That's the point :)
05:19:23 <quicksilver> you think?
05:19:26 <FunctorSalad> allbery_b: dunno, the context is calling rawSystem to write something to a tempfile, then readFile-ing that tempfile
05:19:32 <Cale> Well, we'd keep product types.
05:19:36 <quicksilver> experience shows that although tuples are anonymous, we have a named equivalent
05:19:42 <Cale> (like the existing system)
05:19:49 <eugman|work> live coding == awesome and win   it's a really neat facet of ahskell
05:19:51 <Cale> But the point is adding row-polymorphism
05:19:54 <quicksilver> would you not want a named labeled type?
05:19:58 <Cale> oh
05:20:09 <Cale> You have labelled fields
05:20:18 <Cale> But the type as a whole isn't labelled
05:20:23 <quicksilver> yes
05:20:30 <quicksilver> btu sometimes, wouldn't you want it to be
05:20:32 <quicksilver> ?
05:20:39 <Cale> Wrap it with a newtype :)
05:20:42 <quicksilver> type Foo = (a::Int,b::Double)
05:20:57 <allbery_b> yeh, type / newtype works in that case
05:20:57 <quicksilver> newtype wrapper imposes pain on all the nice convenience syntax you've added
05:21:05 <quicksilver> and type fails to give you type safety
05:21:06 <Cale> type Foo = ('a :: Int, 'b :: Double)
05:21:24 * allbery_b wonders if the potential ML confusion is a feature
05:21:46 <Cale> Or yeah,  newtype Foo = Foo ('a :: Int, 'b :: Double)
05:21:59 <Cale> But you probably wouldn't do that.
05:21:59 <quicksilver> yes I apprecite that
05:22:10 <quicksilver> but it would be annoying if you had to write
05:22:15 <quicksilver> type Foo = (Int,Double)
05:22:16 <quicksilver> or
05:22:22 <Cale> The point of these records is to make use of the polymorphism in row type.
05:22:23 <quicksilver> newtype Foo = FOo (Int, Double)
05:22:33 <quicksilver> there is a reason we allow data Foo = Foo Int Double
05:22:38 <Cale> You still have things like pairs, and algebraic records
05:22:40 <quicksilver> doesn't that reason also apply to records?
05:22:41 * quicksilver nods
05:22:50 <jones-> pejo, daniel_larsson: now I have compiled and installed libgmp3-dev in /work/prefix/other and the lib dir in there is in my LD_LIBRARY_PATH (even tho I'm told it shouldn't matter). I'm still getting the same error even if I prepend my command with LDFLAGS="-L/work/prefix/other/lib". Any ideas?
05:23:39 <quicksilver> Cale: All I can contribute is that in every program I've used records (current system) I've been glad they're named types.
05:23:48 <quicksilver> Cale: maybe 'type' is good enough
05:23:51 <quicksilver> I'm not sure.
05:23:54 <Cale> quicksilver: Well, they're still "named" in some sense.
05:24:03 <Cale> You can write functions which insist on exact types.
05:24:08 <pejo> jones, I'm not familiar enough with how cabal takes it parameters, or if you you can pass linker flags to it somehow. Sorry.
05:24:48 <quicksilver> Cale: Yes. Perhaps I'm obsessing over an unimportant detail.
05:24:59 <quicksilver> Cale: Probably only actually using the system for a while would convince me.
05:25:10 <quicksilver> ;)
05:25:20 <Cale> In fact, in just using 'type', you're specifying the names of the labels involved.
05:25:29 <Cale> Which is sort of pretty strong already.
05:25:30 <FunctorSalad> oh, kinda fixed it. for some reason I have to do "hGetContents tmp_handle", not "readFile tmp_filename" after initially doing openTempFile to get both the filename and the handle
05:25:52 <FunctorSalad> I suppose the latter would open the tempfile twic
05:25:54 <FunctorSalad> *twice
05:25:56 <Cale> Remember that the label names get reflected back at the type level.
05:26:01 <allbery_b> yep
05:26:03 <quicksilver> FunctorSalad: or just never ever ever ever use hGetContents or readFile
05:26:16 <quicksilver> FunctorSalad: which are the work of the evil one designed to twist your mind
05:26:39 <FunctorSalad> quicksilver: how so?
05:26:50 <FunctorSalad> =)
05:26:51 <quicksilver> they conceal IO actions inside pure types
05:26:54 <Cale> FunctorSalad: quicksilver hates lazy IO
05:27:12 <quicksilver> deferring important resource allocation and deallocation decisions to the data dependencies of your program
05:27:23 <Cale> quicksilver: Well, they're still pure values which can only be obtained using the IO monad. :)
05:27:29 <quicksilver> if the data dependencies of your program evolve, a commmon situation, your resources don't get looked after.
05:27:48 <FunctorSalad> so readFile / hGetContents lazily read more of the file as the string gets used?
05:27:50 <daniel_larsson> jones-: Where did you get LDFLAGS from? Is Cabal supposed to honor that variable?
05:27:52 <quicksilver> right
05:28:11 <jones-> daniel_larsson: no idea; was following a guess by pejo.
05:28:15 <FunctorSalad> hmm, sounds reasonable to my naive mind
05:28:29 <Cale> FunctorSalad: and they close the filehandle when they're garbage collected or when you reach the end
05:29:30 <FunctorSalad> quicksilver: ah... you mean the problem it is returns a String, not IO something?
05:29:59 <FunctorSalad> wait, it is an IO String
05:30:04 <jones-> daniel_larsson: I got it working with exporting CPPFLAGS and LDFLAGS before configuring.
05:30:17 <quicksilver> FunctorSalad: it's an IO string but even once you have extracted it from the IO monad
05:30:21 <quicksilver> FunctorSalad: by using <-
05:30:29 <quicksilver> FunctorSalad: it still has "latent IO" inside it
05:30:49 <quicksilver> oleg probably explains it better than I do
05:30:50 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
05:30:52 <lambdabot> Title: [Haskell-cafe] Takusen and strictness, and perils of getContents, http://tinyurl.com/yp35rl
05:31:14 <daniel_larsson> jones-: I don't understand. Did you solve your problem, or you solved a previous problem with that?
05:31:45 <FunctorSalad> yes, I understand <- doesn't get rid of the IO :)
05:31:49 <daniel_larsson> jones-: You're building something with cabal, right? Sorry, I missed the start of the discussion
05:31:51 <jones-> daniel_larsson: I solved my problem :)
05:32:03 <daniel_larsson> jones-: ok, good :)
05:32:25 <quicksilver> FunctorSalad: normally, <- does get rid of the IO
05:32:39 <quicksilver> FunctorSalad: do { foo <- ioAction; return (bar foo) }
05:32:46 <quicksilver> FunctorSalad: here, all the IO is done up front.
05:32:47 <FunctorSalad> that returns an IO something
05:32:51 <quicksilver> FunctorSalad: now foo is a plain String
05:32:57 <quicksilver> FunctorSalad: no IO involved.
05:33:06 <FunctorSalad> yes, but the whole block is IO x
05:33:09 <quicksilver> FunctorSalad: bar is a pure function, operates on a pure string, and can trigger no IO
05:33:14 <quicksilver> yes, but bar is safe
05:33:22 <quicksilver> getContents and friends cheat
05:33:25 <quicksilver> they break the rules
05:33:32 <quicksilver> and leave latent IO lurking inside pure values
05:33:41 <quicksilver> using unsafeInterleaveIO
05:33:55 <FunctorSalad> hmm, you always "temporarily" get rid of the monad with >>=, no? :)
05:34:08 <quicksilver> there is a sense in which it is termporary
05:34:14 <quicksilver> but there is an important distinction here
05:34:19 <quicksilver> bar :: String -> String
05:34:21 <quicksilver> bar is a pure function
05:34:26 <quicksilver> it does no IO, it is passed a pure string
05:34:32 <quicksilver> it can't possibly have any side effects
05:34:33 <FunctorSalad> but I think I'm kinda starting to get what you mean... bar looks pure, but its behaviour determines how much file is read?
05:34:40 <Cale> FunctorSalad: getContents and friends use something called unsafeInterleaveIO. It's not as bad as unsafePerformIO, but can still produce confusing effects.
05:34:49 <Cale> unsafeInterleaveIO :: IO a -> IO a
05:34:53 <quicksilver> in particular, it can't make any difference if it's used once, twice, never or partially
05:35:10 <quicksilver> however, getContents cheats, and gives a 'String' which isn't really a String
05:35:14 <quicksilver> more of a StriIOng
05:35:14 <quicksilver> ;)
05:35:26 <Cale> What it does is to take an IO action and turn it into an IO action which completes immediately, returning what looks like a pure value. When that 'pure' value gets evaluated, the actual IO is triggered.
05:35:48 * tibbe stopped using lazy all together in his web server as it blatantly doesn't work.
05:36:04 <quicksilver> as a general rule it's only appropriate for short throwaway programs
05:36:22 <quicksilver> but there are cases where it makes a short throwaway program rather pleasantly short and idiomatic
05:36:24 <Cale> Lazy IO doesn't really work when you have to open lots of files at once, or if you have really complicated resource requirements, but it works *very* well for small programs.
05:36:27 <tibbe> lazy I/O is appropriate for the same kind of programs that can run with the GC turned off
05:36:38 <quicksilver> a long-running process normally needs to take care over its own resources
05:36:52 <Cale> tibbe: Not quite.
05:36:55 <quicksilver> I object to the fact that these confusingly unsafe functions are exposed as a default API
05:36:59 <Cale> tibbe: But almost.
05:37:05 <quicksilver> because I believe it gives haskell a bad name
05:37:05 <kaol> would it ever make sense to have two or more kinds of monad transformers for a monad? is there always only (at most) one way to do it?
05:37:18 <tibbe> Cale: I think it works great as a rule of thumb
05:37:22 <quicksilver> newbies try to do IO in haskell, see these problems, and then conclude that haskell IO doesn't really work.
05:37:34 <tibbe> Cale: since running out of handles doesn't force GC
05:37:50 <quicksilver> I would be quite happy with them being included in a module called Sytem.Unsafe.IO
05:37:50 <Cale> kaol: That's a good question. The answer is probably that yes, there is sometimes many ways to do it, but so far, we don't know all that many monad transformers.
05:37:53 <tibbe> Cale: in the same as running out of memory with GC turned of would crash because of resource exhaustion
05:38:15 <FunctorSalad> would it be correct to assume that these "hidden side effects" are confined to system ressource usage, not to the semantics of your program?
05:38:25 <Cale> FunctorSalad: close.
05:38:27 <quicksilver> tibbe: however, the class of programs for which lazy IO is most useful are precisely those which would use vast amounts of memory
05:38:35 <quicksilver> tibbe: and would therefore not work with GC turned off :)
05:38:44 <quicksilver> tibbe: e.g stream processing of terabyte data files.
05:39:04 <quicksilver> FunctorSalad: for the particular case of readFile and getContents, yes
05:39:14 <Cale> FunctorSalad: Well, effects can't really be observed. If you change the file before the file is completely read, the part of the String which you've already looked at doesn't change, but the rest might be garbage.
05:39:25 <quicksilver> FunctorSalad: the real gotchas are mostly to do with filehandle usage, and re-reading the same file later
05:39:32 <quicksilver> before it's been totally written
05:39:36 <tibbe> quicksilver: I know, I know but I think it's used way to much and seems to be the only really supported option
05:39:40 <quicksilver> actually, yes, that's observable.
05:39:54 <quicksilver> it's observable that if you readFile, inspect a few chars, and then modify the file
05:39:58 <tibbe> quicksilver: any resource usage actually :)
05:40:02 <quicksilver> and then inspect some more of yoru String
05:40:05 <Cale> Lazy IO would be much cooler if there were just some hooks for when the system runs out of filehandles to do a GC.
05:40:06 <quicksilver> it's changed
05:40:21 <Cale> That would fix many of the problems.
05:40:29 <FunctorSalad> ok, thanks for the explanations Cale, quicksilver
05:40:35 <quicksilver> FunctorSalad: of course, the general gotchas for unsafeInterleave are unlimited
05:40:40 <tibbe> Cale: well, Handles is just one kind of resource, it would be cool if it would work for locks, databases, and everything else
05:41:00 <quicksilver> including but not restricted to breaking-and-entering, cookie theft, baby eating and nasal daemons
05:41:04 <quicksilver> @quote nasal
05:41:04 <lambdabot> No quotes match. Maybe you made a typo?
05:41:08 <FunctorSalad> though I'm still confused how a pure function can call this unsafeInterleaveIO somewhere, but return a non-IO value :)
05:41:10 <Cale> tibbe: I suppose, yeah, but those aren't things which are in the libraries, are they?
05:41:45 <Cale> tibbe: You could already stick an exception handler around the action inside your unsafeInterleaveIO which would GC and retry, I think.
05:42:12 <tibbe> Cale: I'm not saying you couldn't alleviate some of the issues
05:42:15 <Cale> But that doesn't quite interact perfectly with the strict IO stuff. You'd need some hooks in there as well.
05:42:30 <Cale> But generally, if you were writing the library, you could do it.
05:42:40 <tibbe> Cale: I think Oleg's paper summarized it quite well
05:42:51 <flux> I'd say you'd want better guarantees than "gc will be run" for handling locks
05:42:53 <tibbe> Cale: how about interleaving streams?
05:43:06 <flux> for resources that are limited but don't affect others (file handles), why not gc..
05:43:10 <tibbe> flux: yes
05:43:35 <Cale> What exactly are you referring to with respect to locks here?
05:43:55 <flux> acquiring exclusive access to a resource
05:43:58 <Cale> (I was unaware of a lazy IO system of locks)
05:43:59 <tibbe> Cale: take lock, process stream until end, release lock
05:44:34 <tibbe> Cale: so basically you can't use lazy I/O if you require any other resource that needs to be released
05:45:19 <tibbe> Cale: finalizers are not really a solution and neither is GC. GC runs way too late
05:45:35 <tibbe> Cale: I should have said GC and finalizers
05:46:00 <Cale> tibbe: You could stick something which just waits on the lock inside the unsafeInterleaveIO
05:46:44 <tibbe> brb
05:46:48 <Cale> and if your program doesn't even finish processing the other stream, well...
05:46:58 <quicksilver> I'm not really convinced the problem that we're trying to solve is worth the hassle
05:47:02 <Cale> s/even/ever/
05:47:06 <quicksilver> I dont' find iterators particular inconvenient
05:47:14 <quicksilver> what oleg calls 'turning a left fold inside out'
05:47:39 <Cale> But in this specific case, I'm not convinced lazy IO is appropriate.
05:48:20 <Cale> Lazy IO is appropriate for read-only operations where the source of data looks pretty much pure once it's acquired.
05:48:52 <Cale> Taking and releasing locks is an effect which doesn't seem like it should occur inside unsafeInterleaveIO
05:49:19 <quicksilver> and Lazy IO is a disaster as a default interface
05:49:26 <quicksilver> because not surprisingly people use it on sockets
05:49:29 <quicksilver> and then it doesn't work
05:49:30 <Cale> I don't know about that.
05:49:45 <Cale> If the small problems with resource allocation were fixed, it'd be fine.
05:49:50 <FunctorSalad> quicksilver: hmm, what is the preferred way to read a whole file, then? :)
05:49:56 <quicksilver> when getContents is what the standard libs give you
05:50:02 <quicksilver> Cale: no, it wouldn't
05:50:06 <Cale> (they're small in the sense that there is an obvious fix)
05:50:10 <quicksilver> Cale: lazy IO is a disaster on sockets
05:50:17 <masklinn> "
05:50:20 <quicksilver> Cale: you need to strictly read all given data and respond to it
05:50:23 <quicksilver> otherwise you get a deadlock
05:50:29 <quicksilver> on almost all ordinary protocols
05:51:04 <quicksilver> my most recent rant on this topic was a socket question on -cafe :)
05:51:24 <Cale> Were you using sendTo and recvFrom?
05:51:42 <quicksilver> in my opinion, lazy IO really works in one case and one case only. One-time reading of a data source, like a file or a unix pipe.
05:51:45 <quicksilver> Cale: TCP not UDP.
05:51:52 <quicksilver> with a Handle.
05:52:06 <quicksilver> I wasn't doing it, either :) I was trying to help a questioner whose program didn't work.
05:52:24 <Cale> How are those UDP operations?
05:52:34 <flux> maybe there should be a distrinct type for lazily readible sockets :)
05:52:44 <quicksilver> http://www.nabble.com/Simple-network-client-td15157247.html
05:52:44 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - Simple network client
05:53:43 <Cale> Oh, hGetContents. Well, that's easy. "Don't do that."
05:53:57 <quicksilver> Cale: in my experience, people don't normally use recv on TCP sockets. They use the FD interface and read.
05:54:08 <quicksilver> in haskell, you'd use the 'Get' family of functions
05:54:12 <quicksilver> hGetLine and so on.
05:54:14 <Cale> What he wrote is essentially equivalent to using Network.recvFrom
05:54:15 <tibbe> Cale: I don't see how sockets and lazy I/O go together at all
05:54:28 <Cale> They don't, really, except in small examples.
05:54:36 <tibbe> right
05:54:59 <Cale> Usually, you'd actually use something like Data.ByteString, actually.
05:55:06 <tibbe> but I think special casing handles to make the work with lazy I/O only solves a special case and it doesn't solve it particularly efficiently
05:55:16 <Cale> (with strict bytestrings)
05:55:23 <quicksilver> Data.ByteStrin is good
05:55:24 <tibbe> Cale: I use bytestrings in my server but with a fold interface
05:55:39 <quicksilver> but doesn't solve the problem that this shouldn't be advertised as a default API
05:55:47 <Cale> How is it?
05:55:50 <tibbe> Cale: unfortunately I have to write an incremental Parsec since Parsec uses cursors
05:56:01 <tibbe> Cale: like every other API which will now not work with my web server
05:56:02 <Cale> In the documentation, it says:
05:56:05 <paolino> doserj: now it gets more complicate. I get linking errors in haddock on pretty lib, just reinstalled after Cabal
05:56:08 <Cale> "Also, note that due to the use of hGetContents in recvFrom the socket will remain open (i.e. not available) even if the function already returned. Their use is strongly discouraged except for small test-applications or invocations from the command line."
05:56:32 <quicksilver> well he didn't use recvFrom
05:56:36 <quicksilver> he used hGetContents directly
05:56:39 <flux> this is almost similar to people using select(2) and fread(3) in C, which is also a recipe for disaster..
05:56:42 <Cale> right, but he did use hGetContents :)
05:57:01 <shapr`> Good morning #haskell!
05:57:27 <Cale> Once you understand what hGetContents does, it's not really a problem anymore, because you just won't use it when it's not appropriate.
05:58:02 <Cale> But I do think we need an hGetContents' which slurps things into a strict ByteString and then converts to a String lazily.
05:58:20 <shapr`> Cale: write it!
05:58:28 <Cale> It's pretty trivial :)
05:58:59 <Cale> I mean, someone should add it to System.IO :)
05:59:01 <shapr`> I want something like #HaskellPreludeExts
05:59:09 <shapr`> Do you have commit privs?
05:59:14 <Cale> Nope.
05:59:26 <matthew_-> what else is :k * -> * -> * other than (,), Either and (->) ?
05:59:37 <shapr`> Cale: Do you know anyone who does?
05:59:42 <Cale> @kind State
05:59:42 <daf> moonlite: how is it traversed twice?
05:59:44 <lambdabot> * -> * -> *
05:59:51 <byorgey> morning shapr` !
05:59:52 <Cale> @kind Writer
05:59:53 <lambdabot> * -> * -> *
05:59:57 <Cale> @kind Cont
05:59:58 <lambdabot> * -> * -> *
06:00:00 <shapr`> byorgey: gooood morning!
06:00:11 <Arnar> hey folks.. again
06:00:12 <quicksilver> of course, but it's stupid that  hGetContents doesn't have louder caveats in its name, and stupid that it isn't called hDontUseMeGetContents
06:00:22 <quicksilver> and louder caveats in its documentation
06:00:24 <daf> moonlite: at any rate, for the vast majority of functions, readability is more important than performance
06:00:30 <idnar> hDontGetContents
06:00:32 <quicksilver> to be fair the hGetcontents does *sort of* explain what's going on
06:00:36 <Arnar> I'm reading the paper on composable transactional memory by harris, spj et.al
06:00:41 <quicksilver> but not in a clear way to newbies
06:00:42 <hpaste>  matthew-_ pasted "So, is this a known generalisation of Monad and is it at all useful? And fill in the instances!" at http://hpaste.org/5483
06:00:42 <Cale> quicksilver: I don't know. It's usually what beginners want because beginners write small programs.
06:00:42 <paolino> hImagineContents
06:00:54 <Arnar> I'm having trouble instatniationg new MChan-s from the example
06:01:01 <quicksilver> and then they try to generalise their small program to something slightly bigger
06:01:04 <quicksilver> and it doesn't work
06:01:18 <quicksilver> and they conclude that all our talk about referential transparency and compositionality is evidently bullshit
06:01:24 <Cale> Actually, I don't think I've ever written more than a handful of programs where hGetContents was inappropriate.
06:01:26 <quicksilver> because the simplest programs fail to generalise
06:01:45 <Cale> (a small network test being one of those)
06:02:04 <Cale> Basically all the programs I write do very little IO.
06:02:30 <vincenz> Cale: I have a puzzle for you
06:02:37 <hpaste>  Arnar pasted "STM and MChan example" at http://hpaste.org/5484
06:02:49 <vincenz> Cale: imagine a chess-board with top left and bottom-right corner gone... so 62 squares with diagonally-opposed square cut-out
06:02:49 <paolino> Cale: any clue on why those symbols from pretty lib are not accessible from the linker ? I can load PrettyPrint in ghci
06:02:56 <Arnar> ^^ I'm not sure how I should call newMChan to construct an integer channel
06:03:04 <vincenz> Cale: fill it with 31 2*1 tiles, so it's filled and none overlap
06:03:06 <Cale> vincenz: okay
06:03:13 <byorgey> vincenz: that's a classic
06:03:19 <Cale> vincenz: Can't do it.
06:03:22 <moonlite> daf: i agree.
06:03:27 <vincenz> Cale: supposedly it's possible
06:03:37 <byorgey> vincenz: who told you that?
06:03:43 <daf> moonlite: oh, I see what you mean about the double iteration
06:03:46 <byorgey> vincenz: I think they were screwing with you. ;)
06:03:49 <Cale> vincenz: Every domino sits on one white and one black square. The squares you've removed are the same colour.
06:03:54 <vincenz> byorgey: some math-puzzle.pdf from MIT?
06:04:01 <moonlite> daf: good i was just about to write a sentence bout that. :)
06:04:05 <vincenz> Cale: ooh, nice shortcut
06:04:17 <matthew_-> hmm. no takers then. Do monads depend on the existance of (->) ?
06:04:24 <Cale> matthew_-: hm?
06:04:44 <matthew_-> Cale: see the http://hpaste.org/5483
06:05:12 <moonlite> daf: my point was that the first implementation of count could potentially have value, even if less readable
06:05:36 <Cale> matthew_-: ... ah, I see what you've done there
06:05:53 <daf> moonlite: sure
06:06:06 <matthew_-> Cale: so I think for Cont it might be interesting. But I'm not sure if there's actually any use for it.
06:06:10 <daf> moonlite: though in that case, I would expect a comment explaining why it is the way it is
06:06:11 <Cale> matthew_-: That's, really quite odd. Perhaps you want to consider arrows for m1?
06:06:25 <matthew_-> is it a known generalisation of Monads?
06:06:26 <Cale> matthew_-: Like, maybe stream transformers, or something?
06:06:32 <daf> moonlite: I think it's ok as a rule of thumb
06:06:34 <moonlite> daf: yep, me too
06:06:55 <matthew_-> Cale: I was just thinking of using it to segfault my brain...
06:06:56 <Cale> matthew_-: It's not one that I've ever looked at, but it's *kind of* like the definition of a monad in an arbitrary 2-category.
06:09:10 <matthew_-> I wonder if using newtype to fake type lambdas and having multiple (->) in there would make anything useful...
06:10:05 <matthew_-> I was just thinking of additional ways of redefining monads. You know, as you do... on the underground...
06:10:11 <tibbe> Cale: oh, and cursor lazy I/O doesn't deal with errors well either
06:10:29 <quicksilver> tibbe: sure it does.
06:10:35 <Cale> tibbe: "cursor"?
06:10:36 <paolino> what is the command for ld to rewrite its tables ?
06:10:37 <quicksilver> tibbe: ever time there is an error, it kills a kitten
06:10:44 <quicksilver> ldconfig -v
06:10:48 <Cale> tibbe: Normally, the stream just ends.
06:11:26 <Arnar> any takers for that paste?
06:11:37 <chr1s> hey all
06:12:02 <chr1s> I'm trying to install gch 6.8.2 on my machine
06:12:26 <chr1s> but I get the famous gmp problem.
06:12:41 <tibbe> Cale: but in any kind of reliable software you need to deal with the error
06:12:55 <chr1s> I'm on OS X 10.5, and I downloaded the binary for 10.5
06:13:17 <chr1s> installing goes well, but when I run GHC it says dyld: Library not loaded: /opt/local/lib/libgmp.3.dylib Referenced from: /usr/local/lib/ghc-6.8.2/ghc-6.8.2
06:13:18 <tibbe> Cale: instead of having it lying around lazily and force to be communicated through exceptions
06:13:32 <tibbe> Cale: anyway, back to work :)
06:13:47 <paolino> is it ok that ghci loads PrettyPrint and ld ar fails to link haddock against it for missing symbols?
06:14:21 <chr1s> I did install the GMP Framework (I also tried it without the GMP Framework installed)
06:14:34 <chr1s> but it seems to look in the wrong locaction for the framework.
06:14:55 <Arnar> chr1s: I had GMP framework in /Library/Frameworks from my 10.4 installation
06:15:04 <shapr`> @users
06:15:04 <lambdabot> Maximum users seen in #haskell: 471, currently: 408 (86.6%), active: 18 (4.4%)
06:15:08 <Cale> tibbe: I'm not claiming that lazy IO is useful in any situation other than the kind of situation where you're slurping in a bunch of data from one or a small number of sources and you don't care if failures cause the stream to just end.
06:15:11 <chr1s> Arnar: I've got that, too.
06:15:13 <Arnar> removed it while installing GHC, but other stuff broke so I put it back
06:15:20 <shapr`> #haskell is more than twice the size of ##csharp
06:15:22 <Arnar> doesn't seem to bother ghc 6.8
06:15:26 <Cale> tibbe: It's just that this situation is surprisingly common :)
06:15:55 <chr1s> Arnar: do you also have gmp installed via ports?
06:16:12 <chr1s> it's looking in the ports directory, but I haven't got GMP installed via ports.
06:16:15 <Arnar> chr1s: looks like it yes..
06:16:30 <chr1s> Arnar: are you also on Intel?
06:16:36 <Arnar> chr1s: yes
06:16:52 <tibbe> Cale: fair enough
06:17:16 <chr1s> Arnar: could you do a "port list gmp"?
06:17:25 <Arnar> one moment
06:17:36 <tibbe> Cale: but I think the use of streams/cursors has also leaked into all kinds of libraries because people didn't understand the limitations making the more or less unusable in software which isn't a few line slurp script
06:17:48 <Arnar> chr1s: gmp                            @4.2.1          devel/gmp
06:18:07 <chr1s> hm, now I enabled it again, it seems to work.
06:18:09 <Arnar> don't recall installing it, must have been a dependency for something else I installed with port
06:18:13 <Arnar> cool
06:18:21 <chr1s> except for GHCi, "Failed to load interface for `System.IO':"
06:18:29 <chr1s> I'll see if I can install some libraries.
06:18:43 <tibbe> Cale: more precisely Binary, Parsec, zlib, etc. i.e. everything that takes lazy bytestrings
06:18:58 <phobes> Cale:  Where are you geographically?
06:19:52 <Cale> phobes: Ontario Canada
06:20:08 <phobes> Cale: ah
06:20:42 <pejo> chris, the /opt/local is for macports.
06:21:14 <chr1s> pejo: yes, it's working now, thanks!
06:23:49 <chr1s> hm, ghc-pkg doesn't seem to have too many packages installed, ghc-pkg list gives the following output:
06:23:52 <chr1s> {ghc-6.8.2}, rts-1.0
06:24:22 <Saizan> tibbe: how'd you structure e.g. the Get monad? making it accept strict chunks along the parsing?
06:25:09 <tibbe> Saizan: I believe there was a post on -cafe about it, basically with a continuation
06:25:28 <tibbe> Saizan: at least that would be one option, I think binary-strict on hackage does it
06:25:34 <tibbe> Saizan: IncrementalGet
06:30:54 <shapr`> @yow !
06:30:54 <lambdabot> ... the HIGHWAY is made out of LIME JELLO and my HONDA is a barbequeued
06:30:54 <lambdabot> OYSTER!  Yum!
06:31:14 <Saizan> tibbe: yeah, but it uses append, doesn't that copy?
06:32:45 <tibbe> Saizan: I actually haven't looked at that particular implementation yet, but appends would copy on strict bytestrings
06:33:00 <Cale> You could just do the IO strictly, and work with lazy bytestrings.
06:33:19 <Cale> There are functions to convert between the two.
06:33:32 <Cale> I don't really see the problem.
06:33:45 <tibbe> Cale: I want to parse an HTTP header
06:34:12 <Cale> tibbe: Okay, so you have your strict bytestring consisting of the data you read, right?
06:34:14 <tibbe> Cale: I could try to pull down the whole header strictly, I might even do that. But an incremental parser would be more convenient
06:34:22 <vincenz> tibbe: Is there a market in zurich?
06:34:30 <Cale> y = fromChunks [x]
06:34:31 <tibbe> Cale: of the current data received over the network yes
06:34:39 <Cale> Now y is a Data.ByteString.Lazy
06:34:46 <Cale> and can be used with all those libraries
06:34:53 <tibbe> Cale: but y wouldn't be the complete input to the parser
06:35:07 <tibbe> Cale: so I would have write a function that pulls down enough
06:35:28 <Cale> Well, you either use lazy I/O or you don't :)
06:35:33 <Cale> Pick one :)
06:36:16 <tibbe> Cale, don't :)
06:36:35 <tibbe> Cale: so I want a parser that can be used with strict I/O
06:36:38 <Cale> Then read the whole thing in strictly, or incrementally, and do the parsing as you go.
06:36:46 <vincenz> tibbe: easy
06:36:50 <vincenz> tibbe: build a continuation on top
06:36:50 <tibbe> tibbe: and as Oleg demostrated the default interface would be better if it was a left fold
06:36:56 <tibbe> vincenz: yes
06:37:03 <tibbe> vincenz: but I still have to do it :)
06:37:03 <Saizan> I had the same problem, and devised some kind of monadtransformer that annotates the Get monad with sizes of more needed data
06:37:07 <vincenz> tibbe: yes :)
06:37:09 <Cale> But you're not going to find a parser combinator library already written for that, because everyone's waiting for you to write it :)
06:37:24 <tibbe> Cale: sure, and I'm going to :)
06:37:28 <vincenz> \o/
06:37:57 <tibbe> Cale: I just want to try to make sure that people thoroughly understands the issues and doesn't unnecessary limit their libraries' interfaces.
06:38:23 <Cale> I think the libraries that have been written have had certain applications in mind.
06:38:37 <Cale> Maybe not all applications though :)
06:38:46 <tibbe> maybe a bit of both
06:39:07 <tibbe> script like applications I would say
06:39:28 <Cale> There are a lot of different ways to do this stuff, and they involve changes at a pretty deep level with how you design the internals of your library to support one or the other.
06:39:42 <tibbe> I think people just looked at whatever everyone else was doing and picked String as input type
06:39:50 <vincenz> tibbe: one issue with going that route...
06:39:52 <tibbe> Cale: sure
06:39:56 <vincenz> tibbe: either a) you use unsafeperformio
06:39:59 <Cale> But they didn't -- Data.ByteString is pretty common.
06:40:04 <vincenz> or b) you force your entire parser to live in IO
06:40:10 <tibbe> Cale: the lazy version
06:40:11 <Cale> The libraries written before Data.ByteString didn't have any choice.
06:40:28 <Cale> Right.
06:40:48 <Cale> vincenz: Well, technically a submonad of I/O in the end :)
06:40:49 <quicksilver> but bytestring has been around in one form or another for a hell of a long time
06:40:52 <tibbe> Cale: sure they had, they could either take String or (Char -> a -> a) -> a
06:40:56 <vincenz> Cale: right
06:40:58 <vincenz> Cale: contT IO
06:41:09 <Cale> vincenz: Wrapped, hopefully.
06:41:14 <tibbe> vincenz: why would the parser have to live in IO?
06:41:23 <Cale> (so you don't have arbitrary effects in your parsing stuff)
06:41:26 <vincenz> tibbe: cause your dcs will call strictio functions to read
06:41:32 <Cale> tibbe: For the incremental reading.
06:41:34 <vincenz> s/dcs/ccs
06:41:48 <vincenz> what you -can- do
06:41:49 <vincenz> is this
06:41:58 <Cale> Presumably you're carrying around a Handle?
06:42:03 <tibbe> vincenz: Cale: No. no. the parser would take an enumerator function
06:42:03 <phobes> ccs?
06:42:08 <vincenz> repeat (unsafePerformIO $ readChar)
06:42:19 <vincenz> and make -sure- that you access them in order
06:42:27 <vincenz> phobes: continuations
06:42:31 <tibbe> the caller would do the I/O
06:42:44 <vincenz> tibbe: erm
06:42:50 <vincenz> tibbe: I thought it was strictio
06:42:59 <Cale> tibbe: and you return a continuation to the parser or something?
06:43:06 <tibbe> the parser would for each application of the iteration function return a new seed, e.g. Finished a | Partial b | Failed String
06:43:14 <tibbe> Cale: yes
06:43:14 <vincenz> tibbe: so you do use unsafe
06:43:20 <Cale> vincenz: no
06:43:22 <tibbe> vincenz: how?
06:43:23 <vincenz> ah like that
06:43:26 <vincenz> ok
06:43:28 <tibbe> vincenz: the caller lives in IO
06:43:29 <tibbe> :)
06:43:32 <vincenz> you basically don't put the continuation in the reader
06:43:35 <vincenz> you put it in the parse
06:43:35 <vincenz> r
06:43:36 <tibbe> no lying in my types!
06:43:46 <vincenz> it's the opposite approach of oleg
06:43:49 <tibbe> I return a suspended parser
06:43:50 <vincenz> he put the continuation over the reader
06:43:56 <vincenz> tibbe: that might become nasty
06:44:00 <vincenz> but interesting :)
06:44:10 <phobes> Putting the parser in IO sounds terrible
06:44:11 <tibbe> I'm not sure what you mean
06:44:19 <phobes> (to me)
06:44:25 <vincenz> tibbe: oleg had something like this for ocaml
06:44:28 <Cale> tibbe: Presumably you also want to return a continuation even when the parse succeeds, because there might be more input.
06:44:30 <tibbe> he had: col -> (val -> seed -> seed) -> seed' -> seed
06:44:34 <vincenz> tibbe: basically he wrapped his IO-reader with a continuation
06:44:35 <Cale> er...
06:44:41 <vincenz> and he got a pausable parser for free
06:44:43 <Cale> I suppose you'd just hand back the remaining chunk.
06:44:47 <tibbe> the collection is held by the client not the parser
06:44:57 * vincenz checks
06:45:28 <tibbe> the parser never gets to see 'col'
06:46:11 <tibbe> I hope I'm not mixing things up now, I can assure you it's all perfectly clear in my head ;)
06:46:14 <Saizan> so the (val -> seed -> seed) is the parser?
06:46:26 <vincenz> tibbe: lost the link
06:46:30 <vincenz> tibbe: still have it?
06:46:33 <tibbe> sure
06:46:34 <tibbe> sec
06:46:45 <tibbe> http://okmij.org/ftp/papers/LL3-collections-enumerators.txt
06:47:01 <vincenz> that's not hte one I mean
06:47:10 <tibbe> so the parser gets handed a function : (val -> seed -> seed) -> seed by the client
06:47:15 <tibbe> vincenz: ok
06:47:16 <vincenz> tibbe: and you do realize, that to pass in col
06:47:22 <vincenz> you either need to unsafeperformio read it
06:47:29 <vincenz> or preread an amount
06:47:33 <tibbe> the parser the provides the function and an initial seed
06:47:42 <vincenz> the one I saw was much more intuitive
06:47:45 <vincenz> and typed :)
06:47:48 <tibbe> ah
06:47:53 <tibbe> I see what you mean
06:47:55 <tibbe> sorry
06:48:09 <tibbe> I do use an amount of I/O in the HTTP parser
06:48:12 <tibbe> not unsage though
06:48:27 <vincenz> I think I found it
06:48:32 <tibbe> Oleg had, col -> (val -> seed -> seed) -> m seed
06:48:42 <vincenz> http://groups.google.com/group/fa.caml/browse_thread/thread/e9d9af9cfa9ee738
06:48:44 <lambdabot> Title: Incremental, undoable parsing in OCaml as the general parser inversion - fa.caml ..., http://tinyurl.com/yw3tuc
06:48:50 <tibbe> while I have (val -> seed -> m seed)
06:49:05 <vincenz> looking at it again
06:49:10 <vincenz> that's exactly what you wnt
06:49:13 <vincenz> that blog-post
06:49:31 <vincenz> albeit in ocaml iso haskell
06:49:34 <tibbe> yes
06:50:24 <tibbe> alright
06:50:27 <tibbe> this is to interesting
06:50:31 <tibbe> back to work ;)
06:50:52 <vincenz> tibbe|away: continuations usually are
06:50:55 <vincenz> especially delimited ones ;)
06:53:23 * shapr` grumbles about the lack of quickcheck in C#
06:53:49 <Cale> @version
06:53:49 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
06:53:49 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:54:13 * Cale whines in dons' direction some more :)
06:55:02 <Cale> recompile it!
06:55:03 <Cale> hehe
06:56:09 <Cale> Er, I suppose I should really be bugging the administrator of code.haskell.org, as apparently that system needs a new GHC.
06:57:02 <Saizan> i thought it were the same machine as hackage
06:57:15 <Cale> I don't know
06:58:24 <Cale> cgibbard@haskell:~$ ghc --version
06:58:24 <Cale> The Glorious Glasgow Haskell Compilation System, version 6.6
06:59:00 <vincenz> that code?
06:59:04 <vincenz> code != hackage
06:59:18 <Cale> That's on code
06:59:23 <vincenz> code is for darcs repos
06:59:39 <jedbrown> Saizan: Hackage is hosted by Galois.  code = community is elsewhere.
07:00:06 <Cale> Apparently it's also running lambdabot
07:00:23 <vincenz> Cale: I can kill it
07:00:24 <Cale> dons     26402  0.0 18.6  99448 97544 pts/2    S+   Feb03   1:39 ./lambdabot -e rc online.rc
07:00:26 <vincenz> Cale: you could start a new one
07:00:35 <Cale> I couldn't compile the new lambdabot
07:00:39 <vincenz> oh
07:00:49 <vincenz> that and erm, it's still ghc 6.6 on that box
07:00:54 <Cale> right, that's why
07:01:07 <vincenz> so you could compile, just not with the right compiler
07:01:07 <phobes> Anyone understand Girard's paradox?
07:01:11 <Cale> (otherwise, I could, as I have an account and full rights to the lambdabot directory
07:01:12 <Cale> )
07:01:42 <Cale> Uh, I'm not actually sure if it still compiles under 6.6, but I could try, it would just not have much point to it :)
07:04:44 <Cale> phobes: What does it say?
07:04:50 <quicksilver> 99% of javascript programmers don't understand eager evaluation
07:04:57 <quicksilver> this makes helping them out very frustrating
07:05:02 <pitecus> i get this error from ghci: can't load .so/.DLL for: gcc_s (libgcc_s.so: cannot open shared object file: No such file or directory)
07:05:04 <quicksilver> maybe it would be better if javascript was lazy? :)
07:05:14 <pitecus> does that mean it cant find libgcc_s.so?
07:05:17 <Cale> quicksilver: that's quite funny
07:05:28 <Cale> quicksilver: Do they understand any form of evaluation
07:05:29 <Cale> ?
07:05:46 <pejo> quicksilver, would you say c-programmers understand it?
07:05:49 <quicksilver> Cale: commonly they write foo('click',bar())
07:05:51 <quicksilver> pejo: yes.
07:05:58 <quicksilver> and they want to pass bar *as a function*
07:06:02 <quicksilver> but actually taht calls bar
07:06:06 <Cale> heh
07:06:08 <quicksilver> and passes the result of bar as a value
07:06:17 <quicksilver> they need to write function() { bar() }
07:06:19 <Cale> So they want pervasively lazy IO
07:06:21 <osfameron> that's because 99% of javascript programmers don't know javascript
07:06:34 <quicksilver> osfameron: well yes, that's definitely a corollary of my statement :)
07:06:35 <osfameron> I've written javascript without knowing it before
07:06:47 <osfameron> you frequently get requested to "just" change this or that
07:06:52 <Saizan> quicksilver: why not just bar?
07:06:55 <osfameron> and often HTML designers end up saddled with it
07:08:00 <pitecus> i tried runghc -L/usr/lib/gcc/i386-redhat-linux/4.1.1/ but that gives the same error. Any hints?
07:11:06 <pejo> pitecus, you need to set LD_LIBRARY_PATH to point to where libgcc_s.so is, or relink the binary with the path embedded in it.
07:11:50 <pitecus> pejo doesnt -L path tell where libgcc_s.so is?
07:12:13 <quicksilver> Saizan: because in practice there are normally parameters and stuff
07:12:42 <pejo> pitecus, only for linking (at best), not runtime
07:14:25 <pitecus> pejo, ok i see. i did that and now i get can't load .so/.DLL for: maxent (/home/gchrupala/lib/libmaxent.so: undefined symbol: _ZNSt8ios_base4InitC1Ev
07:15:33 <pitecus> I converted libmaxent.so from libmaxent.a using ar -x libmaxent.a; gcc -shared *.o -o libmaxent.so
07:15:43 <pitecus> am i doing smth wrong here?
07:16:17 <pejo> pitecus, hm, don't you need -fPIC if you want relocatable code?
07:17:01 <pitecus> pejo, I don't know what that is even :-( I just want my package to work in GHCi
07:17:03 <pejo> pitecus, still though, that looks like a Haskell name.
07:18:06 <pitecus> my package uses this libmaxent.a C library but that doesnt work in ghci
07:18:20 <pitecus> so i tried converting it to a shared library
07:18:27 <pitecus> but i must be doing something wrong
07:19:18 <pejo> pitecus, does nm libmaxent.a |grep _ZNSt8ios_base4InitC1Ev give anything?
07:20:14 <pitecus> yep
07:20:16 <pitecus>          U _ZNSt8ios_base4InitC1Ev
07:20:17 <pitecus>          U _ZNSt8ios_base4InitC1Ev
07:20:17 <pitecus>          U _ZNSt8ios_base4InitC1Ev
07:20:17 <pitecus>          U _ZNSt8ios_base4InitC1Ev
07:20:17 <pitecus>          U _ZNSt8ios_base4InitC1Ev
07:20:17 <pitecus>          U _ZNSt8ios_base4InitC1Ev
07:20:44 * ricky_clarkson spots a pattern.
07:21:52 <quicksilver> impossible
07:22:01 <quicksilver> I claim those were six fairly chosen random strings
07:22:09 <quicksilver> any pattern is just an optical illusion
07:23:00 <sarehu> if you tilt your head 90 degrees and look at it cross-eyed, you can see a giraffe
07:23:22 <quicksilver> especially if there is, in fact, a giraffe sitting on your desk next to your monitor
07:23:44 <C-Keen> I dont see how 1 1 1 1 1 is less random than 2839 23849239 23859 348953
07:23:56 <sarehu> it's not
07:24:00 <sarehu> it's less entropic
07:25:10 <ricky_clarkson> There is no giraffe next to my monitor.
07:25:44 <quicksilver> C-Keen: indeed, because numbers can't be random.
07:25:53 <quicksilver> C-Keen: being random is a property of variables, not actual numbers.
07:26:00 <quicksilver> (and I was joking, but am now serious)
07:26:49 <pitecus> so _ZNSt8ios_base4InitC1Ev, where can it be defined...
07:27:15 <pejo> pitecus, does that really work if you compile it and run with the same library?
07:27:29 <pitecus> yes it does
07:29:17 <pejo> pitecus, what does nm binary | grep _ZNSt8ios_base4InitC1Ev give, another set of "U _ZNSt8ios_base4InitC1Ev"?
07:30:47 <pitecus> pejo, i dont have a "binary" file?
07:30:58 <pejo> pitecus, oh, the compiled thing that works, I mean
07:31:25 <pitecus> nm foo | grep _ZNSt8ios_base4InitC1Ev
07:31:25 <pitecus>          U _ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4
07:34:50 <pitecus> pejo, hm it seems it was the wrong version of the libgcc_s... i changed LD_LIBRARY_PATH=/usr/lib/gcc/i386-redhat-linux/4.1.1 to 3.4.6 and now i get a different error ;-)
07:35:26 <pejo> pitecus, heh, ok.
07:41:14 * Cale considers adding global well-ordering to his personal list of set theory axioms.
07:43:00 <Cale> Seems good to me :)
07:45:02 <chot> hi
07:45:06 <Cale> hi
07:46:32 <chot> we're trying to make a monad for turtle writing, the final result should have something like forward x, turn x, etc.. now we're having huge problems understanding how this should be done using monads. forward should be something like forward :: Double -> Program where program is a monad
07:46:47 <Cale> right
07:47:03 <Cale> Double -> Program ()
07:47:04 <chot> we're using hgl to do the writing so in the end we should have some kind of list of lines
07:47:05 <Cale> most likely
07:47:37 <chot> Cale: hm but it doesnt perform any calculations? ie no return values?
07:47:54 <quicksilver> monads have to have return values
07:47:57 <quicksilver> just cos that's how they are
07:48:02 <chot> oh ok
07:48:07 <quicksilver> but when your operation doesn't actually calculate anything
07:48:09 <quicksilver> (like forward)
07:48:14 <quicksilver> you just use ()
07:48:21 <tibbe|away> chot: I wrote the same program as a lab at Chalmers
07:48:33 <chot> tibbe|away: hehe thats what we're trying to do :P
07:49:05 <Cale> chot: So the design of the Program monad is up to you?
07:49:07 <pitecus> now i get unknown symbol `__dso_handle'
07:49:16 <tibbe|away> chot: I trust you have read: http://www.haskell.org/haskellwiki/Homework_help ?
07:49:16 <lambdabot> Title: Homework help - HaskellWiki
07:49:22 <pitecus> sounds a tiny bit less cryptic :-)
07:49:42 <chot> Cale: yes
07:49:57 <Cale> chot: Okay. What monads do you already know about?
07:50:11 <Cale> I take it you're fairly comfortable with actually using monads already?
07:50:14 <chot> tibbe|away: we've been reading up on monads the whole day but still cant figure this out :P
07:50:35 <chot> Cale: well we've only used IO monads, putStr ect
07:50:43 <Cale> chot: IO is just one monad
07:50:57 <tibbe|away> chot: right
07:51:13 <chot> but we have a fairly good idea how our lib should be used in the end, something like main = do { forward 5; left 2; ..}
07:51:13 <tibbe|away> chot: just pointed that out so you know what to do/expect
07:51:18 <Cale> chot: Okay, so you haven't seen, say, State or Writer...
07:51:38 <chot> Cale: hm briefly but I can't say I know them
07:51:40 <Cale> chot: Oh, so it's really that forward is in the IO monad?
07:51:53 <chot> Cale: no no, we're writing our own monad :)
07:52:00 <Cale> All right. :)
07:52:23 <Cale> chot: Seems a little disingenuous of them to get you to design your own monad with effectively no examples.
07:52:47 <quicksilver> interestingly this isn't really a monad
07:53:04 <quicksilver> until you have functions which can, in some sense, return values (like getting part of the current turtle state)
07:53:10 <quicksilver> it's actually a much simple combinator setup
07:53:13 <quicksilver> just a monoid, perhaps.
07:53:28 <quicksilver> at which point you might as well just represent it as a list :P
07:53:38 <chot> quicksilver: yeah thats what we though, why not just use non monadic stuff and make list of lines to print? :P
07:53:43 <quicksilver> but, I suspec tthat won't count as completing the exercise.
07:53:49 <chot> no :)
07:53:53 <Cale> Well, it might be something like State (Position, [DrawingInstruction])
07:54:11 <Cale> er, (Position, Direction, [DrawingInstruction])
07:54:31 <quicksilver> it could be, but it doesn't need to be
07:54:36 <chot> hm yeah we figured it would be something like that
07:54:37 <quicksilver> since later actions can't depend on the state
07:54:45 <quicksilver> there is actually no need to calculate it 'as you go along'
07:54:55 <chot> but where do we calculate stuff, in forward or in the bind?
07:54:58 <quicksilver> you can just save it all up and defer it to when you actually 'RUN' it.
07:55:01 <chot> or in the actuall program?
07:55:19 <quicksilver> if you're going for that model
07:55:20 <chot> quicksilver: ok, so we can just keep a list of actions?
07:55:22 <Cale> chot: Your program won't look like  main = do forward 50; ...
07:55:23 <quicksilver> you could
07:55:36 <quicksilver> that's a possible implementation technique
07:55:42 <chot> Cale: why not?
07:55:47 <quicksilver> all your actions could just 'save themselves' onto a big lists
07:55:57 <quicksilver> alternatively, the actions could modify the current position as they go
07:56:01 <quicksilver> either approach will work
07:56:06 <Cale> chot: You'll have some function Program a -> IO a which produces an IO action for running the program and drawing on the screen
07:56:25 <Cale> chot: Because forward 50 doesn't have type IO t
07:56:42 <Cale> and main has to be an IO action
07:56:59 <chot> Cale: ah i get your point, ok but say mainProg = do forward.. and we have a main = run mainProg, it would be ok wouldn't it?
07:57:07 <Cale> sure
07:57:17 <Cale> and 'run' will be quite an interesting function
07:57:30 <Cale> It'll essentially be an interpreter for your Program monad.
07:57:35 <chot> quicksilver: how would monads come into the picture if we do it that way? cant really see the use of them then?
07:57:53 <vvv> @help ask
07:57:53 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
07:58:01 <Cale> chot: Monads are overkill for this problem.
07:58:10 <quicksilver> chot: you would be exploring some related areas, at least
07:58:20 <quicksilver> chot: combinator libraries and 'run' functions.
07:58:49 <vvv> @help messages
07:58:49 <lambdabot> messages. Check your messages.
07:58:53 <vvv> @help tell
07:58:54 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
07:58:55 <Saizan> however, for example if you want to write a combinator that does something different depending on current position a monad can be useful
07:58:57 <chot> hm ok.. i'm not really sure we've understood the assignment right now.. ;)
07:59:00 <vvv> @messages
07:59:00 <lambdabot> You don't have any new messages.
07:59:08 <quicksilver> chot: the real power of monads is when your actions can return values which are used by later actions.
07:59:20 <Cale> chot: Could you give a full list of the primitives you need to implement?
07:59:24 <quicksilver> chot: if you added 'getCurrentLocation' or 'getCurrentAngle' to your turle language
07:59:28 <quicksilver> chot: then you'd *need* a monad.
07:59:48 <quicksilver> however, some people would argue that that would be a shame to add, because it goes against the spirit of turtle graphics :)
08:00:00 <quicksilver> turtle graphics should be independent of their current angle.
08:00:03 <Cale> Or 'colourHere' to get the colour of the pixel that the turtle is at, say :)
08:00:15 <quicksilver> ah yes. They violates the spirit less.
08:00:36 <chot> Cale: forward, right, penup, pendown, color, stop, backwarad, left, times (repeats part of the program), forever (repeat part forever)
08:00:56 <vvv> Cale: concerning yesterday's lambdabot topic..
08:01:08 <vvv> Cale: ..0) Thanks! :)
08:01:22 <Cale> vvv: no problem
08:01:51 <vvv> Cale: 1) `install' step complains about missing `LICENSE' file (i've taken one from hs-plugins)
08:02:17 <Cale> vvv: right, I forgot to push that file. You can just 'touch LICENSE'
08:02:21 <vvv> Cale: 2) hoogle plugin can't find `hoogle.txt'.
08:02:29 <chot> hm so i guess those repeat functions  (times and forever) implies we have to use monads?
08:02:30 <Cale> I have no idea about that one.
08:02:40 <Cale> chot: Not really, no.
08:02:58 <Cale> chot: None of those operations return interesting values.
08:03:35 <Cale> chot: So you're essentially working with a monoid of sorts, but that's okay.
08:03:45 <vvv> Cale: semi-solution to #2 is to copy State/hoogle.txt from lambdabot directory to $(dirname $(which hoogle))
08:04:47 <Cale> chot: It can still be a monad.
08:05:12 <Cale> chot: It's just that all the primitives in the monad don't return anything interesting. That is, they'll be Program () values.
08:05:33 <Vq^> @hoogle mergeIO
08:05:34 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
08:05:34 <lambdabot> Control.Concurrent.nmergeIO :: [[a]] -> IO [a]
08:05:38 <Cale> So bind is in some sense doing more work than it should have to.
08:05:50 <chot> hm
08:06:06 <Cale> But that's all right, you can still make it a monad just to get the do-syntax to work.
08:06:36 <chot> hm ok, we're kind of confused right now but we'll read the things you've said again and reconsider everything from the start and see if we get any clarity in this, thanks for the help so far guys :)
08:06:43 <Vq^> is there a function similar to nmergeIO that has the type [IO a] -> IO [a] ?
08:08:23 <quicksilver> chot: there are choices in terms of 'how much work' you do at bind-time, and how much you defer until later.
08:08:40 <quicksilver> chot: at one extreme, you do no work at all in the monad, and just build a list of instructions for later execution
08:08:40 <Cale> Vq^: It's not hard to write, but made slightly annoying by the need to collect results with a Chan
08:08:51 <Cale> Vq^: If you want, I could write it.
08:09:03 <quicksilver> chot: at the other extreme, you build a 'virtual turtle' model inside your monad
08:09:12 <quicksilver> chot: and actually execute at each stage in some sense.
08:09:12 <chot> quicksilver: hm yeah i guess that's one of the big parts we're really confused about
08:09:18 <Vq^> Cale: what kind of chan would be suitable?
08:09:24 <quicksilver> Chan a
08:09:26 <quicksilver> ! :)
08:09:31 <Cale> Vq^: Control.Concurrent.Chan
08:09:32 <Vq^> oh :)
08:09:50 <Vq^> ok, then im on track again, thanks :)
08:10:40 <chot> it feels kinda like we're building a interpeter for a language inside the language here, are we in the right direction then?
08:10:46 <Cale> chot: yes
08:10:49 <quicksilver> chot: sounds like a good direction to me :)
08:11:00 <Cale> chot: Monads are essentially embedded programming languages.
08:11:31 <Cale> (with a particular basic interface to combining computations in each)
08:12:48 <chot> ok
08:12:49 <Cale> One reasonable choice would be to have something like  data Program a = P SomeTypeHere a
08:12:59 <Cale> Where SomeTypeHere is an interesting type :)
08:13:21 * kaol considers writing a Haskell wrapper for GStreamer
08:13:44 <Vq^> kaol: isn't there one?
08:13:55 <kaol> there is?
08:14:29 <daf> yes
08:14:37 <Cale> http://urchin.earth.li/darcs/ian/minstrel/
08:14:37 <lambdabot> Title: Minstrel
08:15:17 <LeCamarade|less> Funny, I was thinking, back then, of Mistrel as a name of a music thingy.
08:15:17 <kaol> looks more like a program for playing stuff, not a GStreamer wrapper as such
08:15:29 <LeCamarade|less> Then came Funktor.
08:15:51 <LeCamarade|less> Minstrel is a frontend to the GStreamer  library written in Haskell.
08:15:56 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5485
08:16:07 <Cale> kaol: yeah, I don't know. There's probably some useful code in there though.
08:17:08 <daf> I'm sure I saw some somewhere
08:18:08 <Cale> uh, yeah
08:18:12 <daf> http://darcs.haskell.org/gtk2hs/gstreamer/
08:18:14 <lambdabot> Title: Index of /gtk2hs/gstreamer
08:18:28 <Cale> huh
08:18:32 <Cale> Inside gtk2hs?
08:18:38 <dcoutts> aye, contributed
08:18:38 <daf> apparently so
08:18:52 <dcoutts> I've no idea how well it works, but it does compile :-)
08:18:58 <Cale> Is there a dependency?
08:19:12 <daf> one would hope not
08:19:29 <Cale> Yeah, it should probably be split into a separate package, I'd think :)
08:19:56 <Cale> Oh, it uses System.Glib.*
08:19:58 <daf> but perhaps it depends on glib stuff that's bound up in gtk2hs?
08:20:01 <dcoutts> gtk2hs is going to be cabalised some day when cabal does dep chasing
08:20:03 <daf> right
08:20:30 <dcoutts> at which point it'll be possible to build & install in a modular way
08:20:34 <Cale> dcoutts: Well, cabal-install already does dep chasing :)
08:20:49 <dcoutts> heh heh, yes. Not that kind of dep chasing
08:21:01 <Cale> Which kind?
08:21:02 <dcoutts> module & pre-processor dep chasing
08:21:04 <Cale> ah
08:21:16 <dcoutts> .chs modules depend on each other and have to be built in the right order
08:21:27 <dcoutts> cabal currently does them in any old order
08:21:50 <dcoutts> because it doesn't do dep chasing, it relies on ghc --make to do that for .hs files
08:21:55 <Cale> ah
08:22:14 <dcoutts> Cabal-2.x will use a make-like dependency framework
08:22:17 <Igloo> dcoutts: It doesn't just preprocess them and then pass the hs files off to ghc --make?
08:22:30 <dcoutts> Igloo: yes, but that's not good enough
08:22:47 <dcoutts> the .chs files depend on each other (or rather the .chi files generated by c2hs)
08:22:59 <Igloo> Hmm, OK
08:23:13 <dcoutts> .chs & .chi, just like .hs and .hi
08:23:18 <Igloo> What is it that goes in the chi?
08:23:26 <Igloo> hsc2hs doesn't have that problem AFAICR
08:23:33 <dcoutts> hsc2hs does less
08:23:43 <Igloo> Right, so what is it that c2hs does that needs it?
08:23:46 <dcoutts> info about the mapping between C and Haskell types declared in one module and used in another
08:23:55 <Igloo> Ah, OK
08:24:06 <dcoutts> {# pointer *GtkFooBar as FooBar #}
08:24:47 <dcoutts> creates a mapping, then when I bind a C function in another module that takes a *GtkFooBar then the Haskell type is FooBar and not Ptr ()
08:24:56 <kaol> ah. what's in gtk2hs looks much more complete. I guess I should have asked first and not just declare my intent to write this stuff myself.
08:25:16 <dcoutts> kaol: I'm sure the stuff in gtk2hs could be tested and improved
08:26:57 <kaol> am I mistaken in thinking that using GStreamer could be handled via arrows, somehow?
08:27:14 <dcoutts> kaol: that seems plausible
08:27:30 <dcoutts> gstreamer is all about making pipelines/graphs
08:28:26 <kaol> perhaps I could look into that. It would be a nice exercise, if nothing else.
08:29:56 <glen_quagmire> in essence, what is haskell data type?  named list? is it simulating dictionary??   data A = A Int Int;   func A a b = a + b
08:30:05 <dcoutts> kaol: yeah, sounds like a good project
08:30:12 <glen_quagmire> func [a, b] = a + b
08:30:27 <glen_quagmire> What's exactly a difference between [a, b] and A a b ?
08:30:46 <dcoutts> glen_quagmire: lists are not really primitive, they're recursive data types
08:30:51 <dcoutts> it's data that is primitive
08:31:11 <dcoutts> data [a] = [] | a : [a]
08:31:17 <quicksilver> glen_quagmire: [a,b] is sugar for a:b:[] which is infix notation for (:) a ( (:) b [] )
08:31:26 <mux> @src []
08:31:26 <lambdabot> data [] a = [] | a : [a]
08:31:27 <quicksilver> glen_quagmire: where (:) is a 2-place data
08:31:34 <quicksilver> glen_quagmire: and [] is a nullary constructor
08:31:49 <dcoutts> or without the special syntax:
08:31:50 <dcoutts> data List a = Empty | Cons a (List a)
08:32:08 <glen_quagmire> but what's the point of data List a = .. ?? for convenience?
08:32:26 <glen_quagmire> maybe i'm trying to compare data with Java class
08:32:29 <idnar> glen_quagmire: no, the point of [] is for convenience
08:32:45 <dcoutts> glen_quagmire: right, data is like a class (without the methods)
08:33:04 <glen_quagmire> so, it seems they are syntactic flags for pattern matching
08:34:11 <dcoutts> glen_quagmire: are you familiar with structs and unions in C/C++?
08:34:11 <quicksilver> glen_quagmire: the point of data is to structure your custom data types.
08:34:27 <quicksilver> glen_quagmire: from a different angle, the point is to introduce new ways of pattern matching.
08:35:00 <glen_quagmire> dcoutts: yes.    struct S {int a; int b;}; S s; s.a = 2; s.b = 3;
08:35:09 <quicksilver> data introduces the two main kinds of data structure, being sum and product types
08:35:20 <quicksilver> rather like union or struct
08:35:27 <glen_quagmire> (List (Cons 1 Empty).get("a") => 1
08:35:29 <quicksilver> but sum is a whole lot safer than union
08:35:40 <quicksilver> which is one of the practical advantages of a haskell-like type system.
08:35:51 <quicksilver> sum types / union are a bugger in C-like languages
08:36:02 <vincenz> quicksilver: sum types are not union
08:36:06 <vincenz> they're 'tagged union'
08:36:35 <vincenz> but yes, tagged unions are less safe as you require more bookkeeping and boilerplate
08:36:59 <quicksilver> which is why I said "rather like" not "like"
08:37:07 <quicksilver> or "Exactly the same as"
08:37:22 <quicksilver> I don't think you meant "tagged unions are less safe" ?
08:37:40 <glen_quagmire> do I search for "algebraic types" to study something like haskell's type system?
08:37:59 <glen_quagmire> like, a term that describes kind of type system used by haskell
08:38:30 <desegnis> glen_quagmire: All data types the typical Haskell programmer defines are algebraic data types, so...
08:38:50 <vincenz> quicksilver: tagged unions still allow you to look at the union in the wrong way, so less safe than data
08:39:08 <desegnis> glen_quagmire, personally I suppose the term ADT is just a pun on sum and product types
08:39:38 <quicksilver> data Foo = Foo Int (Int -> Int)
08:39:44 <quicksilver> is not algebraic by some definitions
08:40:03 <quicksilver> vincenz: ok, that's what you meant by tagged union :P
08:40:25 <vincenz> struct { enum tag; union { ... } u;}
08:40:27 <vincenz> is what I meant
08:40:50 <vincenz> for some valid 'enum'
08:40:58 * quicksilver nods
08:44:16 <EvilTerran> it's fairly straightforward to wrap some safety around that with functions/C++ methods, but it's still a pain
08:44:35 <desegnis> quicksilver, what's the bit that makes it non-algebraic?
08:44:47 <desegnis> the function?
08:45:13 <vincenz> EvilTerran: welcome to the inverted visitor pattern
08:48:20 <quicksilver> desegnis: yes, I think so.
08:48:29 <quicksilver> desegnis: or rather, I think that's what some people mean by 'algebraic'
08:50:01 <quicksilver> desegnis: on the other hand, 'GADTs' are not required to be algebraic in this sense
08:50:05 <quicksilver> (as far as I know)
08:50:09 <quicksilver> so the usage is not universal.
08:50:12 <desegnis> quicksilver: hm... but the function is only a component of the type, so... Well Int isn't an ADT either, but  data T = One Int | Two Int Int  certainly is?
08:50:38 <EvilTerran> quicksilver, are usages ever universal? ;)
08:50:50 <desegnis> (sorry, I'm away now for a couple of minutes)
08:51:17 <doserj> data Int = -MININT | ... -1 | 0 | 1 ... | MAXINT pretty much is an ADT :)
08:51:23 <quicksilver> again, I think usages differ.
08:51:33 <quicksilver> but most people probably would allow that ADTs are allowed to use 'base types'
08:51:37 <quicksilver> like Integer and Char
08:51:38 <vincenz> doserj: please write that out :)
08:52:08 <vincenz> doserj: and then skip a few random numbers
08:52:59 <EvilTerran> of course, that's not valid haskell; you'll have to write the numbers out in words :D
08:53:42 <quicksilver> > "data Int = " ++ concat (intersperse " | " $ map show [minBound::Int .. maxBound])
08:53:54 <lambdabot>  "data Int = -2147483648 | -2147483647 | -2147483646 | -2147483645 | -2147483...
08:54:14 <vincenz> quicksilver: I wonder if ghc can parse that
08:54:32 <quicksilver> no, it won't, as EvilTerran point out.
08:54:44 <vincenz> I meant, line-length-wise
08:54:45 <resiak> showEnglish :: Int -> String
08:55:12 <vincenz> quicksilver: that's a stack-depth of 4B in your parser
08:55:16 <vincenz> acctuall
08:55:21 <vincenz> 8B
08:55:24 <vincenz> if you count the |
08:55:50 <brian`> anyone working in google here?
08:55:57 <EvilTerran> "8B" looks like a guy with googly-eyes and buck teeth
08:56:06 <quicksilver> no idea
08:56:11 <quicksilver> (about ghc's parsing)
08:56:11 <vincenz> brian`: nearly?
08:56:21 <brian`> vincenz, where do you work at?
08:56:25 <vincenz> well not ye
08:56:27 <vincenz> ..t
08:56:29 <vincenz> but soon, zurich
08:56:32 <brian`> vincenz, oh i c
08:56:35 <brian`> vincenz, nice!
08:56:44 <brian`> vincenz, do they have projects in haskell too?
08:56:51 <vincenz> don't know that bit yet :)
08:57:00 <vincenz> but I plan to start a HUG there :)
08:57:03 <vincenz> along with another #haskell'er
08:57:20 <brian`> vincenz, ah i c ... cool!
08:57:47 <glen_quagmire> algebraic data type is a (possibly recursive) sum type of product types (only one constructor) ??
08:58:02 <brian`> vincenz, i just had an interview with google for my summer internship position
08:58:10 * brian` worried
08:58:21 <glen_quagmire> so, algebraic data type is a type with many constructors
08:58:42 <phobes> with many meaning "at least none"
08:59:02 <vincenz> brian`: where at?
08:59:05 <glen_quagmire> phobes: s/none/one ?
08:59:09 <vincenz> glen_quagmire: none
08:59:13 <vincenz> at least in ghc
08:59:15 <vincenz> not h98
08:59:18 <vincenz> data Void;
08:59:32 <glen_quagmire> @index Void
08:59:32 <lambdabot> bzzt
08:59:38 <vincenz> glen_quagmire: that was just an examplee
09:00:20 <EvilTerran> djinn has that one in its environment
09:00:49 <glen_quagmire> oh i have to set -XEmptyDataDecls
09:00:51 <EvilTerran> curry-howard isomorphic to false, i believe
09:01:12 <Saizan> well Void is quat makes ADTs a ring, no?
09:01:25 <Saizan> s/quat/what/
09:01:25 <EvilTerran> as it's impossible to construct a value (proof) for it
09:01:34 <phobes> Saizan:  Void = 0, Unit = 1?
09:01:57 <vincenz> phobes: yep
09:02:03 <phobes> with sum & product
09:02:10 <vincenz> a*b = (a,b)
09:02:14 <vincenz> a+b = Either a b
09:02:17 <oerjan> just a semi-ring, surely?
09:02:22 <phobes> hehe
09:02:34 <vincenz> oerjan: why a semi-ring?
09:02:43 <oerjan> no negation
09:02:48 <vincenz> oh right
09:03:04 <vincenz> well negation is sometimes allowed, as long as you can factor it away ;)
09:03:13 <oerjan> unless there is something weird going on with those zipper derivatives :D
09:03:32 <vincenz> oerjan: referring to something specific?
09:03:39 <vincenz> HOZ?
09:04:38 <oerjan> no, just thinking if you can do nearly general functions...
09:04:59 <oerjan> power series and stuff
09:05:00 <vincenz> oh, I thought you were referring to higher-order-zippers :)
09:05:07 <brian`> vincenz, I said preferred location is mountainview :)
09:05:27 <brian`> vincenz, I'd like to work there for at least one term and if I like working at google I may want to try other offices hehe
09:05:36 <vincenz> brian`: well good luck
09:05:43 <brian`> vincenz, thanks
09:06:17 <vincenz> oerjan: you cn do more
09:06:37 <vincenz> oerjan: but the simplest powerseries is the list :)
09:06:43 <vincenz> 1+x+^2+...
09:07:03 <vincenz> and
09:07:14 <vincenz> 1+x/1+x^2/2+x^3/3! + ..
09:07:16 <vincenz> is a set
09:07:17 <oerjan> which is 1/(1-x)
09:07:20 <vincenz> though sadly you can't encode that in haskell
09:07:29 <oerjan> so nearly negation there
09:07:32 <vincenz> erm, not set
09:07:33 <vincenz> unordered list
09:07:36 <EvilTerran> *you* can't, maybe oleg can :D
09:07:55 <vincenz> oerjan: well that's cause list is actually
09:08:08 <oerjan> x = 1 + x^2
09:08:10 <vincenz> mu l.1 + x*l
09:08:14 <desegnis> quicksilver, doserj, I see
09:08:23 <vincenz> oerjan: erm no
09:08:25 <oerjan> er wait
09:08:28 <vincenz> 'x' is the element type
09:08:33 <oerjan> y = 1 + xy
09:08:35 <vincenz> right
09:08:37 <vincenz> or you use mu
09:08:41 <vincenz> mu l.1 + x*l
09:09:15 <vincenz> mu t.1 + x*t^2
09:12:57 <vincenz> oerjan: t = (1 +- sqrt(1-4x))/2x
09:13:00 <vincenz> lol :)\
09:21:01 <Saizan> vincenz: do you know mu-calculus?
09:21:16 <vincenz> nope
09:21:20 <oerjan> mu
09:21:27 * oerjan is thus enlightened
09:21:35 <vincenz> of
09:21:38 <vincenz> forall a. mu -> a  ?
09:21:42 <vincenz> sounds like bottom
09:22:24 * desegnis is proud of German keyboards having a ¬µ
09:22:35 <oerjan> mu x. f x = fix f, or?
09:22:45 * vincenz nods
09:24:31 --- mode: ChanServ set +o vincenz
09:24:32 --- kick: IRSeekBot was kicked by vincenz (vincenz)
09:24:36 --- mode: vincenz set -o vincenz
09:24:39 <vincenz> bastards
09:24:44 <EvilTerran> bam!
09:24:52 <EvilTerran> @karma+ vincenz
09:24:52 <lambdabot> vincenz's karma raised to 22.
09:24:54 <vincenz> they sneak in silently and just start logging for their serach engine
09:25:21 <EvilTerran> at least they're not using the <girl's name><number> nick format any more
09:25:25 --- mode: ChanServ set +o vincenz
09:25:59 <vincenz> grr
09:26:03 --- kick: IRSeekBot was kicked by vincenz (vincenz)
09:26:05 <EvilTerran> banlist full again?
09:26:07 <vincenz> yeah
09:26:10 <EvilTerran> =/
09:26:21 <resiak> presumably you have looked at the opt-out thing on their site?
09:26:33 <vincenz> resiak: why opt out o something you didn't sign up for?
09:26:37 <vincenz> I found #oasis logged in there
09:26:40 <vincenz> with no prior questioning
09:26:41 <vincenz> it's bs
09:26:43 --- mode: vincenz set -o viklund
09:26:44 --- mode: vincenz set -o vincenz
09:27:27 <ricky_clarkson> You can use ChanServ's banlist.
09:27:39 <vincenz> seems gone for now
09:28:15 <Saizan> btw, mu l. T + a*l means there's a *finite* prefix of a-s before the T, right?
09:28:23 <ricky_clarkson> In the UK organ donation is/will be opt-out.
09:28:34 <ricky_clarkson> I presume that's for after you've died.
09:29:35 <oerjan> ricky_clarkson: does ChanServ's banlist work if the ordinary one is full?
09:29:51 <oerjan> won't ChanServ just fail at applying the ban then...
09:30:04 <ricky_clarkson> I don't know.
09:30:04 <resiak> vincenz: sure
09:30:04 <EvilTerran> it'd be nice if it could juggle the ordinary one, taking off the oldest ban if the list is full, say
09:30:21 <EvilTerran> or somehow magically worked around it with its awesome serv powers
09:30:30 <EvilTerran> or, failing that, autokicked. meh.
09:31:26 <vincenz> bastards have plenty of logs
09:31:28 <EvilTerran> hm... well, it's called "akick", but it says it bans too
09:31:32 <vincenz> and that's the first time I see IRSeek
09:31:33 <oerjan> autokicking without banning can make things _worse_.  i recall another day the banlist was full...
09:31:36 <vincenz> so I bet they've been using other means
09:32:08 <Saizan> i suppose most of the banned ips are actually dynamic
09:32:19 <EvilTerran> i guess you might have to clear out the banlist occasionally so chanserv could still ban those on akick
09:33:49 <EvilTerran> http://www.irseek.com/blog/ - "we apply an opt-in policy with the Freenode network" my arse
09:33:50 <lambdabot> Title:
09:34:01 <vincenz> full of haskell stuff in there
09:34:13 <Cin> well, he asked in ##c for a consensus
09:34:13 <vincenz> I guess their policy is not retro-active
09:34:31 <EvilTerran> "We have decided to remove all logs that had been archived prior to IRSeek‚Äôs recent changes." too, alledgedly
09:34:34 <pissedboutpats> well arc is out
09:34:37 <pissedboutpats> anyone excited?
09:34:45 <Cin> pissedboutpats: old news, kinda
09:34:47 <vincenz> pissedboutpats: wrong channel?
09:34:50 <vincenz> pissedboutpats: #arc :)
09:41:21 <Arnar>  hey guys..
09:41:25 <Cin> 'ello
09:41:34 <Arnar> how can I import Control.Concurrent.STM into lambdabot..
09:41:42 <Arnar> so I can ask for types from there?
09:41:45 <glen_quagmire> :m + Control.Concurrent.STM
09:41:49 <Arnar> ah, thanks
09:41:56 <quicksilver> eh?
09:41:57 <glen_quagmire> Arnar: no i was testing. it didn't work
09:42:02 <quicksilver> you can't import anything into lambdabot
09:42:05 <Arnar> oh ok :)
09:42:05 <quicksilver> it has what it has
09:42:12 <Arnar> quicksilver: it's *my* lambdabot
09:42:17 <Arnar> not the online one
09:42:24 <quicksilver> :t Control.Concurrent.STM.atomically
09:42:26 <lambdabot> forall a. GHC.Conc.STM a -> IO a
09:42:31 <EvilTerran> ?hoogle atomically
09:42:31 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
09:42:32 <lambdabot> Control.Exception.NestedAtomically :: Exception
09:42:40 <Arnar> quicksilver: thanks, that's good enough for me :)
09:42:46 <quicksilver> Arnar: I don't know the answer, but why would you use that and not ghci ?
09:43:08 <EvilTerran> Arnar, i use ?hoogle for when i'm not sure if a module's loaded, as that provides the type
09:43:29 <glen_quagmire> ?hoogle kiss
09:43:30 <lambdabot> No matches found
09:43:38 <glen_quagmire> ?hoogle fun
09:43:38 <lambdabot> Data.Typeable.funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
09:43:38 <lambdabot> Language.Haskell.TH.funD :: Name -> [ClauseQ] -> DecQ
09:43:38 <lambdabot> Language.Haskell.TH.Lib.funD :: Name -> [ClauseQ] -> DecQ
09:43:51 <oerjan> ?hoogle evil
09:43:52 <lambdabot> No matches found
09:43:58 <Arnar> quicksilver: dunno really.. I usually manage to shoot myself in the foot with ghci anyways
09:45:37 <Arnar> EvilTerran: yes, hoogle is much better actually.. now a command in my editor :)
09:45:49 <Arnar> ?hoogle good
09:45:50 <lambdabot> No matches found
09:46:48 <glen_quagmire> ?hoogle hoogle
09:46:48 <lambdabot> Distribution.Simple.Setup.haddockHoogle :: HaddockFlags -> Bool
09:47:32 <b_jonas> good localtime, #haskell
09:47:55 <Arnar> what is the best way to browse the source for the base library?
09:48:01 <glen_quagmire> @src []
09:48:01 <lambdabot> data [] a = [] | a : [a]
09:48:13 <Arnar> @src STM
09:48:13 <lambdabot> Source not found. :(
09:48:17 <Arnar> ?index STM
09:48:17 <lambdabot> GHC.Conc, Control.Concurrent.STM
09:48:26 <glen_quagmire> :t STM
09:48:27 <lambdabot> Not in scope: data constructor `STM'
09:48:28 <Arnar> @src Control.Concurrent.STM.atomically
09:48:28 <lambdabot> Source not found. It can only be attributed to human error.
09:48:39 <quicksilver> Arnar: http://www.haskell.org/ghc/docs/latest/html/libraries/
09:48:43 <quicksilver> Arnar: bookmark that link
09:48:46 <quicksilver> keep it close, always
09:48:47 <Arnar> quicksilver: thanks.. done
09:49:00 <b_jonas> so my haskell question is this,
09:49:00 <quicksilver> (actually I don't bookmark it, I just type in 'has' and my browswer guesses correctly!)
09:49:08 <b_jonas> if I want my program to compute some structures strictly,
09:49:11 <quicksilver> Arnar: note that not only documentation, btu also source, is there.
09:49:21 <Arnar> quicksilver: I was about to ask about that
09:49:36 <Arnar> ah, see it
09:49:39 <quicksilver> Arnar: once you browse down to a specific function there is a 'Source' link against the RHS margin
09:49:45 <b_jonas> 1. can I first write my program not taking care about that and change it to strict later or do I have to design it strict from the start,
09:50:01 <b_jonas> and 2. in general how do I do that, are there any good tutorials on it?
09:50:18 <slarba_> b_jonas: you can use strictness annotations in your data types later
09:50:27 <slarba_> or define NFData instance for your type and use rnf :)
09:50:43 <slarba_> to force your values
09:50:51 <b_jonas> slarba_: what's NFData?
09:51:06 <Arnar> what are names ending in # ?
09:51:06 <slarba_> b_jonas: look into Control.Parallel.Strategies
09:51:09 <Arnar> some kind of built-ins?
09:51:17 <glen_quagmire> :t (#)
09:51:20 <lambdabot> parse error on input `)'
09:51:28 <slarba_> Arnar: unboxed types
09:51:50 <Arnar> slarba_: meaning?
09:53:30 <Zao> Arnar: Types that are just the underlying value type, not some fluffy thing that may be a value, or a thunk, or so.
09:53:34 <quicksilver> not necessarily unboxed types, no
09:53:40 <quicksilver> # is just used by various GHC specific things
09:53:44 <quicksilver> including unboxed types
09:53:47 <quicksilver> but not only them
09:53:56 <quicksilver> roughly it means 'GHC Primitive Thing'
09:54:08 <b_jonas> slarba_: thanks for the pointer
09:54:15 <Arnar> quicksilver: ok.. that looks more right to what I'm looking at (src of atomically)
09:54:17 <jedbrown> Arnar: Normal types are boxed which means there is a pointer to the actual value.  The # refers to core stuff, much of which lives in GHC.Prim.
09:54:29 * quicksilver nods
09:54:34 <Arnar> thanks
09:54:36 <quicksilver> note that the STM isn't all in teh .hs files
09:54:37 <b_jonas> also, it's a syntactic extension that the character '#' can even appear in idents and operators, isn't it?
09:54:40 <quicksilver> it has explicit runtime support
09:54:51 <quicksilver> (which is in C I think? some parts might be C--)
09:54:57 <quicksilver> b_jonas: right.
09:54:59 <Arnar> ok..
09:55:08 <slarba_> b_jonas: basically with NFData you can define rnf function for your type, that will use seq so that the value will be forced to normal form
09:55:13 <quicksilver> it's a syntactic extension to explicit GHC primitive stuff
09:55:24 <Arnar> quicksilver: say I wanted to mess with the implementation of atomically - I'd need the source of GHC for that then?
09:55:36 <quicksilver> yes
09:55:55 <quicksilver> why would you want to mess with it? Do you think they got it wrong? :)
09:56:05 <Arnar> quicksilver: no, I'd like to add to it :)
09:56:17 <quicksilver> what kind of thing are you thinking of adding to stm?
09:58:32 <slarba_> talking about concurrency, does anyone have a good solution for the following problem: I have multiple tasks, that may communicate with each other using channels. Now I need to build the process network so that I can easily change it. Is the only solution a Context value that will contain the channels to/from each process and pass that to each task?
09:59:42 <slarba_> each channel obviously has a different type, so now I need to pass the channels clumsily to each thread individually
10:00:06 <slarba_> hmph, that wasn't a good explanation.
10:01:56 <quicksilver> who can change it?
10:02:05 <quicksilver> some central control process can rewire the diagram?
10:02:14 <slarba_> hmm
10:03:00 <slarba_> yes. I need a kind of registry where I can look up a process and obtain channels for it.
10:03:07 <quicksilver> that sounds like a Map
10:03:13 <quicksilver> possibly stored in an MVar
10:03:29 <slarba_> but then, the processes are heterogenous
10:03:43 <slarba_> i.e. have different types for the channels. won't work
10:03:52 <quicksilver> a heterogeneous process might still have a homogenous representation
10:04:01 <quicksilver> depends what you're trying to abstract, and for who
10:04:15 <quicksilver> or you could use typeable trickery
10:04:17 <slarba_> yeah
10:05:08 <EvilTerran> slarba_, how can the diagram be re-wired if the channels're different types?
10:05:17 <quicksilver> Typeable might be the way to go, I guess
10:05:46 <slarba_> I'm working on an userspace IP stack (:D), where ethernet interfaces, arp, udp, icmp etc are separate processes
10:05:59 <EvilTerran> right...
10:06:08 <slarba_> but it needs to be refactored before I continue. it's just too clumsy to pass the channels around
10:06:38 <slarba_> but yeah, let's try that typeable stuff first.
10:06:58 <EvilTerran> why're the channels changing at runtime?
10:07:28 * EvilTerran is confused
10:07:48 <Saizan> maybe "easily change it" is not at runtime, but for code flexibility purpouses?
10:07:52 <Lemmih> shapr`: What's with the tick?
10:07:58 <slarba_> EvilTerran: not necessarily changing, but it needs to be reconfigurable
10:08:03 <shapr`> slarba_: Have you seen the existing stack in House?
10:08:03 <EvilTerran> seems Typeable'd be overkill if it's not runtime changing
10:08:06 <slarba_> Saizan: exactly.
10:08:13 <slarba_> shapr`: no...
10:08:20 <shapr`> Lemmih: I'm online from the laptop. I could just ghost my home connection.
10:08:23 <conal> wow -- i just noticed that the Monoid & MonadPlus instances for Maybe disagree.
10:08:29 <slarba_> (doing this for learning IP stacks)
10:09:12 <shapr> conal: ooh, email haskell-cafe?
10:09:12 <EvilTerran> conal, indeed. MonadPlus Maybe matches up with Monoid (First a)
10:09:21 <EvilTerran> it's meant to do that :P
10:09:46 <EvilTerran> ooh, galois person. random.
10:10:06 <shapr> Galois person?
10:10:07 <conal> EvilTerran: thanks for the tip.
10:10:14 <EvilTerran> * jstanley (n=user@gw-1.galois.com) has joined #haskell
10:10:18 <shapr> ah
10:10:23 <EvilTerran> ... but then he left again
10:10:27 <shapr> There are several galois people who hang out here :-)
10:11:11 <EvilTerran> slarba_, how're you getting the stack up and running in the first place?
10:11:32 <EvilTerran> it seems to me it'd make sense for each layer to launch the layer immediately below and set-up the communication between the two
10:11:57 <shapr> slarba_: You could write the whole stack as a bunch of arrows ;-)
10:12:16 <shapr> Lemmih: happy now? (-:
10:12:20 <slarba_> shapr: possibly ;)
10:12:50 <EvilTerran> the Typeable solution sounds like it'd allow a stream can go from anywhere to anywhere, which is probably a bit overkill for your purposes
10:12:56 <Saizan> ip and friends are not exactly a stack though
10:12:56 <shapr> It would. If you use collection arrows it could be ip >> tcp for example.
10:13:03 <slarba_> EvilTerran: that's what I'm doing now
10:13:17 <EvilTerran> it also throws away an awful lot of static checking
10:13:39 <EvilTerran> and in this family, we *like* brussels sprouts^W^W static checking
10:13:49 <slarba_> :))
10:13:56 <Saizan> i think the solution is to put more in the type system rather than less
10:14:08 <shapr> Saizan: How would you do it?
10:14:08 <shapr> ah
10:14:13 <Lemmih> shapr: Yes, much better.
10:14:51 * shapr grins
10:16:40 <vincenz> EvilTerran: brussel sprouts are great
10:17:17 <vincenz> EvilTerran: I think usians tend to not like em cause they're brought up constantly with cartoons with "eww... brussel sprouts" it's just a massive (albeit unintentional but meme-based) propaganda
10:17:43 <slarba_> shapr: actually in real ip stacks the layers are not that sharp, so thinking one-way with arrows possibly won't work :/
10:18:14 <EvilTerran> vincenz, my mother could make *anything* bland, brussels sprouts posed no challenge to her at all
10:18:37 <vincenz> EvilTerran: you're missing out
10:19:15 <EvilTerran> well, she put me off, and i'm happy sticking to other veg :)
10:19:24 <vincenz> like witloof?
10:20:02 <slarba_> http://tools.ietf.org/html/rfc3439#page-7
10:20:05 <lambdabot> Title: RFC 3439 - Some Internet Architectural Guidelines and Philosophy
10:20:21 <EvilTerran> ... endive?
10:20:27 <vincenz> sorta
10:20:28 <vincenz> not really
10:20:35 <vincenz> special case of it ;)
10:20:46 <Hexarobi> howdy all, im just starting to learn haskell and ive got a programming assignment i put off until the last minute and im confused as to where to start
10:20:51 <EvilTerran> yeah, that's okay
10:20:55 <vincenz> http://www.agf.gov.bc.ca/aboutind/products/plant/images/witloof1.jpg
10:20:56 <lambdabot> http://tinyurl.com/294t3s
10:21:04 <Hexarobi> im trying to write a function that takes an input n, and outputs all the integer partitions of that number
10:21:16 <vincenz> 4-6 inches more or less
10:21:16 <shapr> Hexarobi: To be honest, it's best to start early. But "Yet Another Haskell Tutorial" is a good place to start.
10:21:25 <Hexarobi> so intPart 4 would return [1,1,1,1] , [1,1,2] , [2,2] , [1,3]
10:21:47 <Hexarobi> ive gone through that shapr, that simple stuff makes sense
10:21:50 <lament> sounds like a lot of output
10:22:07 <Hexarobi> but i think im supposed to be using the lamda calculus expressions or something
10:22:10 <Hexarobi> im really quite lost =)
10:22:23 <vincenz> Hexarobi: well think of recursion
10:22:25 <lament> yes, if you don't know what you're supposed to do, it's hard to help you.
10:22:33 <glen_quagmire> ghc is written in haskell. how big is the portion of ghc written in C?
10:22:44 <oerjan> Hexarobi: list comprehensions are good for this
10:22:50 <glen_quagmire> like, binding (=) is also written in haskell?
10:22:59 <oerjan> + recursion
10:23:11 <vincenz> Hexarobi: start with the base case 1
10:23:18 <vincenz> Hexarobi: then figure out how to do case 'n' when you have case n-1
10:23:20 <EvilTerran> base case 0?
10:23:23 <Hexarobi> base case of 1 is obviously just [1]
10:23:24 <vincenz> nah 1
10:23:32 <Hexarobi> then 2 splits into [2,2]
10:23:37 <Hexarobi> err 1,1
10:23:47 <EvilTerran> but 0 works...
10:23:53 <Hexarobi> but i havent the foggiest idea how to express it in haskell
10:24:02 <vincenz> Hexarobi: write it down on paper
10:24:03 <EvilTerran> Hexarobi, it also splits into [2], doesn't it?
10:24:06 <vincenz> Hexarobi: then put it in hpaste
10:24:10 <slarba_> Mars2:rts markolauronen$ find . -name \*.[ch] | xargs wc -l
10:24:13 <slarba_> 95917 total
10:24:16 <slarba_> :D
10:24:18 <vincenz> Hexarobi: and then people can help you with the haskell bit
10:25:03 <slarba_> glen_quagmire: it's something like 96k lines of c
10:25:08 * EvilTerran can't actually think of a really straightforward way of writing that
10:25:09 <slarba_> (6.6.1)
10:25:14 <vincenz> think of #haskell as 'pseudo-code to haskell compiler"
10:25:25 <vincenz> but not of #haskell as "foggy concept to haskell compiler"
10:25:30 <vincenz> cause then you learn nothing :)
10:26:15 <oerjan> vincenz: i have this, you know, thing, which sort of increases with size, and sums equal to some n, you know?  and then find all those things, sorta
10:26:39 <EvilTerran> oerjan, i think that's a ghc extension
10:26:44 <vincenz> -with-oleg
10:26:53 <dons> j
10:26:59 <EvilTerran> -XMindReading
10:27:07 <vincenz> -XHomeWorkSolver
10:27:14 <EvilTerran> -fallow-incorrect-code
10:27:15 <lament> unsafePerformLobotomy
10:27:20 <vincenz> oerjan: I understand what he's asking cause I've seen the problem before, but it smells like homework
10:27:25 <dons> Cale: interesting performance problem on -cafe@, see "Why is this so inefficient"
10:27:26 <glen_quagmire> slarba_: that's a lot
10:27:32 <EvilTerran> dons, he even said it was homework
10:27:33 <dons> i don't have time to chase it down, but transpose looks iffy
10:27:33 <oerjan> vincenz: he said as much
10:27:37 <vincenz> ah :)
10:27:39 <dons> EvilTerran: oh?
10:27:41 <vincenz> well I missed that bit
10:27:48 <EvilTerran> er, sorry, vincenz.
10:28:08 * vincenz adds to the confusion "No problem, EvilTerran "
10:28:12 <EvilTerran> the screen scrolled up as my eyes tried to keep track of a line break
10:28:20 <oerjan> vincenz: that's ok
10:28:43 <oerjan> EvilTerran: that's almost poetry
10:29:05 <EvilTerran> ty :)
10:29:42 <lament> EvilTerran: does anyone still play starcraft?
10:29:51 <lament> outside korea
10:30:04 <dons> ?users
10:30:05 <lambdabot> Maximum users seen in #haskell: 471, currently: 424 (90.0%), active: 13 (3.1%)
10:30:09 <dons> ?uptime
10:30:09 <lambdabot> uptime: 2d 2h 3m 21s, longest uptime: 1m 10d 23h 44m 29s
10:30:33 <oerjan> #haskell will go asymptotical in 2012.  it will be the cause of the Vinge singularity.
10:30:58 <dons> 471 is pretty great.
10:31:18 <glen_quagmire> - lambdabot = 470
10:31:52 <oerjan> @vixen glen_quagmire is insulting you!
10:31:52 <lambdabot> i understand
10:32:18 <EvilTerran> lament, actually, my nick didn't particularly have anything to do with starcraft. scifi authors were saying "terran" long before blizzard had anything to do with it
10:32:39 <EvilTerran> lament, but, as a matter of fact, i do. also, i imagine a fair few people play SC2, now it's out.
10:32:48 <natv> sc2 is out?
10:32:56 <EvilTerran> er, wait, it isn't yet. can't keep track.
10:33:05 <lament> star control 2 is out, yes :)
10:33:07 * EvilTerran was thinking of a different sequel, evidently O.o
10:34:05 <lament> (but humans are called earthlings in star control 2)
10:34:26 * oerjan notes EvilTerran is trying to cover up his secret time traveler identity
10:35:13 <b_jonas_> this Control.Parallel.Strategies is overwhelming. I'll look at the article it refers to
10:35:29 <EvilTerran> yeah, okay, you got me. we still haven't seen Duke Nukem Forever in the year 2112, tho.
10:35:43 <b_jonas_> lament: no, people are playing warcraft 3 which is newer
10:35:59 <oerjan> EvilTerran: is it still being planned?
10:37:02 <EvilTerran> yeah. we're gradually thawing out the various members of the dev team as people discover ways to cure their terminal diseases.
10:37:48 * EvilTerran prefers starcraft to WC3, actually. WC3's got so much *stuff*, it starts to distract from strategy
10:37:55 <natv> Keeping them on ice like the captain in Dark Star
10:38:13 <EvilTerran> natv, yep, keeping them on ice like a gin & tonic
10:38:25 <EvilTerran> @yow
10:38:25 <lambdabot> Psychoanalysis??  I thought this was a nude rap session!!!
10:39:01 <shapr> Ya know, I'm gettin real close to just calling QuickCheck from C#'s FFI
10:39:08 <oerjan> @vixen Do you think this is a nude rap session?
10:39:08 <lambdabot> hey, we have simular taste in music
10:39:15 <natv> I was hoping starcraft would have crazy high graphics requirements, but it looks like it'll run on things that are 5 years old
10:40:07 <pjd> oerjan: haha
10:40:23 <EvilTerran> it only runs at 800x600, tho (or maybe even 640x480, i forget)
10:40:32 <kungfupuf> lament: My brother just started playing it, my ex-roommate plays it... I think that it is still the best real time strategy game...
10:40:41 <natv> sc2 I meant
10:40:49 <dons> shapr: that has a lot of potential, imo.
10:40:52 <EvilTerran> ahh
10:41:05 <dons> QC'ing foreign languages with Haskell as a driver language is heavily underexploited
10:41:12 * EvilTerran prefers games that can run on old hardware
10:41:23 <EvilTerran> dons, yeah, it's nice to know that at least your test framework is infallible :D
10:41:41 <dons> and Haskell's great syntax for encoding the high level concepts of your code
10:41:57 * dons should write a paper on testing C for the masses using QC..
10:42:05 <EvilTerran> Hexarobi, how're you getting on?
10:42:19 <lament> dons: yes please!
10:45:26 <visof> i installed alex for yi editor and when i configure yi i have message that alex didn't install
10:45:59 <visof> what should i do?
10:46:17 <shapr> dons: Yeah, please write that paper. Then I can have a clue how to do this ;-)
10:46:28 <dons> shapr: mm
10:47:16 <dons> i wonder where such a thing would get submitted.
10:47:25 <sjw> dons: HW :)
10:47:26 <dons> there must be 'mainstream' testing/QA conferences
10:47:33 <dons> target one of those...
10:48:22 <sjw> how do you go in something like Python without (static) types?
10:48:51 <dons> "go"?
10:50:11 <vincenz> Hexarobi: some test cases:
10:50:15 <dons> sjw, see the model checking guys won the turing award?
10:50:36 <sjw> nope, looking...
10:50:42 <vincenz> length $ parts 30  == 5604, length $ parts 50 == 204226, length $ parts 60 = 966467
10:50:56 <shapr> sjw: Generating test cases is easy with QuickCheck, several people have already used it for other languages.
10:51:34 <dons> the fun is in embedding the foreign language's type structure well into arbitrary instances
10:52:21 <dons> sjw: http://www.acm.org/press-room/news-releases/turing-award-07
10:52:21 <lambdabot> Title: ACM Turing Award Honors Founders of Automatic Verification Technology &mdash; As ...
10:52:41 <natv> DesignCon might be a good conference to target if you want to go for the hardware side of the world too
10:53:36 <sjw> meh, this model checking thing will never take off ... everyone knows theorem provers are the future
10:53:38 <sjw> :)
10:53:41 <dons> hehe
10:53:48 <vincenz> designcon...
10:53:51 <vincenz> go to ATE
10:53:53 <vincenz> DATE even\
10:54:00 <vincenz> or DAC
10:54:03 <vincenz> much bigger EDA conferences
10:54:19 <dons> sjw, know how the haskell/isabelle embedding for the l4 project is going?
10:54:52 <sjw> we have thouroughly established that Python was the wrong tool for the job
10:55:09 <dons> well, duh. :)
10:55:10 <sjw> the satisfaction of being right does little to diminish the pain of using the tool :)
10:55:13 <dons> :(
10:55:16 <natv> vincenz: yeah, designcon's good for the angle of addressing the designer productivity gap though
10:55:25 <sjw> to be fair, package ghc wasn't as nice then as now
10:55:42 <dons> sjw, there's a similar project happening at PSU this year, i think. might be more on the model checking side though
10:55:52 <sjw> trying to coq to spit out nicely formatted output tho ...
10:55:53 <shapr> sjw: What are you doing with Python?
10:56:27 <dons> sjw doesn't pollute himself with such things :)
10:56:28 <sjw> shapr: don't blame me, I didn't write the thing, someone else did :)
10:56:44 <glen_quagmire> data A = A Int | A String String;  is bad
10:56:55 <glen_quagmire> oh i see it'll be  confused
10:57:01 <sjw> shapr: it munges the haskell source into Isabelle
10:57:01 <dons> i saw a twelf blog post today. first time, i think. http://jlouisramblings.blogspot.com/2007/12/lambda-calculus-interpreter-in-twelf.html
10:57:02 <lambdabot> Title: JLOUIS Ramblings: A Lambda Calculus Interpreter in Twelf, part #1, http://tinyurl.com/3bavxk
10:57:11 <dons> sjw, you should start an FM blog :)
10:57:23 <sjw> dons: it seems everyone does a LC interpreter in twelf ...
10:57:26 <dons> hehe
10:57:29 <sjw> and then nothing
10:57:40 <dons> well, hey, substitution for free, dude!
10:57:49 <shapr> You wrote a PYTHON script to munge Haskell into Isabelle???
10:57:59 <dons> sjw didn't, shapr.
10:58:05 <shapr> ok...
10:58:14 <dons> but that's what happened, yeah.
10:58:17 <shapr> crazy
10:58:19 <shapr> insane
10:58:19 <dons> don't ask :)
10:58:22 <shapr> nutso
10:58:28 <vincenz> dons: sounds like HOAS
10:58:31 <sjw> well, it started out as something quick and hacky to get it working ...
10:58:46 <sjw> vincenz: yep
10:59:00 <dons> sjw, switched to xmonad yet?
10:59:02 <vincenz> sjw: woo, thanks
10:59:12 <dons> its stomping on stumpwm, on debian now, fwiw :)
10:59:26 <shapr> dons: Oh hey, I got a picture of cjb's massive moniter with xmonad on it.. it's gorgeous!
10:59:28 <sjw> dons: nah, still using whatever came with ubuntu
10:59:33 <glen_quagmire> can you pattern match function call?   f f2 a b = a + b;  f (f 1 2)  => 3
10:59:38 <dons> shapr: oh cool!
10:59:46 <glen_quagmire> f (f2 1 2) => 3
10:59:48 <vincenz> glen_quagmire: no
10:59:49 <shapr> He has an insane number of emacs windows open with the golden ratio spiral layout, and still has room for lots of other apps.
10:59:56 <dons> ah nice.
10:59:59 <shapr> It's beautiful.
11:00:03 <dons> i'd love a screenshot for the website
11:00:22 <glen_quagmire> so, (:) is not a function call vincenz ?
11:00:22 <sjw> vincenz: which is one advantage LF has over Coq and Isabelle --- the main problem is that it doesn't have (IMHO) a nive way of doing meta-logical proofs
11:00:34 <vincenz> glen_quagmire: (:) is a data constructor
11:00:42 <glen_quagmire> foldr tutorial says (:) is a function..myabe i misread it
11:00:55 <vincenz> data constructors double as functions
11:01:00 <vincenz> glen_quagmire: take
11:01:04 <vincenz> data Foo a = Boo a
11:01:08 <vincenz> Boo :: a -> Foo a
11:01:12 <vincenz> but Boo is a data constructor
11:01:15 <glen_quagmire> oh data constructor type signature is similar to function type signature
11:01:17 <vincenz> and thus can be pattern-matched against
11:01:26 <sjw> dons: proving is much more fun than writing up :(
11:01:36 <wolverian> shapr, show the picture? :)
11:01:43 <shapr> wolverian: Um, lemme see...
11:01:46 <vincenz> sjw: I read about HOAS in a completely different place :)  I'm glad my intuition proved right
11:03:03 <sjw> shapr: one reason I mentioned Python wrt QC is that you can't just look at python source and figure out the type of an object
11:03:14 <shapr> sjw: Yup
11:03:40 <dons> yeah, the instance Arbitrary PyValue  is where the fun is
11:03:41 <sjw> but dynamic typing is so cooool ... you can, like, do stuff
11:03:53 <pejo> sjw, that problem has to exist for Erlang as well though
11:04:22 <sjw> don't know it well enough
11:04:37 <dons> does python et al typically depend on complex side conditions to explain why a value will have a specific type, or is best practice to insert checks for type correctness?
11:05:17 <dons> i.e. would Arbitray PyValue cause python code to fall over left and right if we start assuming the universal type for everything not specically more constrained?
11:05:41 <quicksilver> best practice and python are not particularly meaningful in close juxtaposition
11:06:03 <sjw> dons: 'dude: I tested it, it works.'
11:06:06 <quicksilver> unless hte sentence reads "best practice is to convert your python scripts to a typed language like haskell" :P
11:06:08 * sjw shouldn't rant
11:06:28 <dons> i think we could break a lot of dynamic code this way .. it would show up the complex assumptions made about type correctness of some python code
11:06:41 <quicksilver> you might learn some pretty interesting things
11:06:45 <dons> shapr: you've experience with this?
11:06:46 <quicksilver> or, demonstrate some pretty interesting things
11:07:05 <dons> if we just spit say, Dyanmic's of any type into a bit of python code, would that typically break it really badly?
11:07:33 <daf> most Python code does not explicitly check types
11:07:35 <dons> quicksilver: yeah. some stats about the robustness of code, or the complexity of the invariants explaining why some code is type correct, would be cute
11:07:54 <glen_quagmire> so, I can't use japanese as a function name (or data constructor name)? because japanses doesn't have captal letters
11:07:55 <dons> daf, ah ok. so quickchecking it based on the universal type would break things.
11:08:00 <dons> there'd be runtime failures all over
11:08:07 <glen_quagmire> data ????? = ??? a
11:08:09 <quicksilver> yes, typically it would reference a dicitonary key that doesn't exist, or something likew that
11:08:10 <shapr> dons: Checks for type correctness were common in my code.
11:08:15 <daf> dons: I don't understand
11:08:24 <dons> quicksilver: right.
11:08:28 <quicksilver> typing assumptions in python (and indeed Perl) are typically something like "foo is a dictionary with keys X Y Z" or "foo is an object of class bar"
11:08:34 <wolverian> python3 introduces optional type declarations, though I'm not sure if they actually do anything
11:08:46 <dons> and you rely on users not to call it with invalid values, quicksilver ?
11:08:46 <quicksilver> if workinf with people with OO-itis, it's always the latter :)
11:08:48 <wolverian> perhaps 2.5 has them too, with decorators.
11:08:56 <shapr> dons: if(type([]) == type(mything)): do stuff else: throw "WrongTypeBuddy"
11:08:57 <dons> since "it breaks if you do that, stupid"
11:09:01 <quicksilver> yes, or you put asserts in
11:09:04 <quicksilver> like shaprs ays
11:09:13 <dons> would be an interesting exercise
11:09:15 <wolverian> dons, yes. API docs and tests are the two ways to assure sanity.
11:09:18 <quicksilver> of course, methods get a weak guarantee that "this" is presumably something of the right type.
11:09:26 <quicksilver> so that's a little bit of typing.
11:09:35 <quicksilver> erm, it's called "self" in python, rihgt?
11:09:37 <daf> not really
11:09:39 <quicksilver> whatever :)
11:09:40 <wolverian> quicksilver, in perl, they don't. :)
11:09:42 <daf> you can pass anything in as self
11:09:52 <quicksilver> that's why I said weak guarantee
11:10:01 <wolverian> well, yeah, it's very rare for someone to circumvent that.
11:10:03 <quicksilver> it's a gaurantee, if people do stuff the 'normal' way.
11:10:20 <daf> it's common for subclasses to invoke methods on superclasses that way
11:10:24 <shapr> Python uses interfaces a lot lately.
11:10:37 <daf> Class.method(self, ...)
11:10:38 <shapr> At least, I've seen that a lot in zope3 and Twisted.
11:10:48 <daf> I think that's largely a Twisted/Zope thing
11:12:06 <wolverian> perl has Moose nowadays, which is an amalgam of CLOS and perl6, I think, and has type guarantees (though I think they are only runtime for now)
11:12:13 <dons> so this would be a problem in larger systems, once developers are working on separate code that has to go together
11:12:27 <wolverian> it's a real MOP, though, if you like that sort of a thing, so there's real introspection and such.
11:13:06 <dons> whereas i can send someone off to implement some pure code, and no matter what happens, there stuff won't break my code, nor can i call it incorrectly
11:13:17 <wolverian> (it's rather telling that perl5 doesn't even have a real MOP built-in. then again, it's very flexible, and it's not too awkward to do FP in perl)
11:13:27 <dons> there's some serious lessons on programming in the large with purity and strong typing that aren't widely appreciated.
11:14:00 <wolverian> dons, yes. generally, you mandate required tests, and use test coverage as an informal tool to gauge their quality.
11:14:19 <wolverian> there are also static analysis tools (for perl) which help you gauge the quality of the code itself.
11:14:33 <dons> right. you approach a type system in the limit
11:14:33 <sjw> \_ -> "it sucks"
11:15:13 <dons> i'm using code coverage tools at work as well, but thankfully can trust more junior devs not to sabotage the project. purity ftw!
11:15:18 <sjw> wolverian: what sort of properties do they check?
11:15:47 <dons> so code coverage gets used to ensure runtime invariants hold, but the critical quality assurance steps were taken care of by the language
11:16:07 <wolverian> sjw, best practices, generally. see e.g. http://search.cpan.org/~elliotjs/Perl-Critic-1.080/
11:16:08 <dons> its frustrating this isn't more widely appreciated.
11:16:09 <lambdabot> Title: Elliot Shank / Perl-Critic-1.080 - search.cpan.org
11:16:24 <dons> shapr: played with hpc? its freaking awesome
11:16:28 <wolverian> (the ::Policy:: modules in the list each define best practice policies)
11:16:55 <gwern> dons: 'more junior devs' - didn't you start at galois just a few months ago?
11:17:04 <doserj> dons: it would be more appreciated, if there were a *really* convincing success story
11:17:05 <wolverian> dons, it's getting more traction in the mainstream, with dynamic languages adding optional type guarantees, and some even adding pure code (perl6)
11:17:13 <dons> yep, but we've hired some undergrads and masters students since then
11:17:30 <gwern> ah
11:17:31 <dons> gwern: which we have to get up to speed as haskell devs
11:17:43 <shapr> dons: Not yet, would like to.
11:18:25 <sjw> gwern: is there an echo in here? :)
11:18:58 <dons> wolverian: ah yes, good point
11:19:25 <wolverian> dons, and, of course, LINQ, though it's rather domain specific
11:19:29 <sjw> maybe the problem is that sometimes they miss the point
11:19:33 <gwern> sjw: wh-wh-what did you say?
11:19:35 <sjw> cf list stuff in python
11:20:01 <sjw> gwern: I msg'd done that exact line about him working there .. months
11:20:24 <sjw> s/done/dons/
11:20:28 <dons> you did?
11:20:29 <wolverian> sjw, the best practices are generally of the type "constrain yourself to this subset of the language to make your code more understandable to others".
11:20:51 <gwern> sjw: I don't see it, eh
11:21:53 <dons> if people could use a haskell/QC binding at work, to sneak some haskell into a project in the testtsuite, i'd be interested in hearing that
11:21:56 <sjw> gwern: yeah, it was a msg, hence my surprise
11:22:01 <dons> we could probably hack together something useful
11:22:09 <sjw> dons: I did, maybe it didn't work?
11:22:17 <dons> i didn't see anything, sjw
11:22:33 <dons> the testsuite might be the haskell backdoor..
11:22:43 <sjw> *** kornbluth.freenode.net 505 sjw Private messages from
11:22:44 <sjw>     unregistered users are currently blocked due to spam
11:22:44 <sjw>     problems, but you can always message a staffer. Please
11:22:44 <sjw>     register! ( http://freenode.net/faq.shtml#privmsg )
11:22:44 <lambdabot> Title: 69a freenode: frequently-asked questions
11:22:45 <dons> a testing dsl for python, C, ...
11:22:49 <dons> ah
11:23:10 <dons> shapr: you'd be able to use haskell for testing stuff, if there was a C#/ QC binding?
11:23:25 <dons> and then you can just compile the damn model, and use it directly
11:25:47 <daf> pypy does some type inference, but I'm not sure whether using a type other than the one inferred causes a runtime error or just skips a fast path
11:33:32 <MoxJet> can I import some module instead of compiling with -XPatternSignatures ? I'm using ghc
11:34:09 <dons> {-# LANGUAGE PatternSignatures #-} in the top of the file that needs it, perhaps?
11:35:01 <MoxJet> yeah :) thanks dons
11:35:42 <dons> i think that's a pretty good system that works well as projects get large. no central .cabal to keep everything sorted
11:36:01 <dons> just stick -Wall or other global flags in the .cabal file, but per-module extensions, selectively enabled
11:36:27 <dcoutts_> yes, we need a cabal field to list allowed extensions, that are not applied to every module
11:36:44 <dcoutts_> it's important to know the extensions that a package uses though, portability etc
11:36:46 <dons> mm. interesting.
11:36:58 <dons> since you want to set a global policy *not* to use specific things
11:37:08 <dcoutts_> it's like declaring package deps
11:37:12 <dons> and that will prevent some person accidentally adding a dep on something scary
11:37:22 <dons> (or intentionally)
11:37:22 <GrayShade> vincenz: care to show me your implementation of parts? i'd like to compare it with mine
11:37:31 <dons> dcoutts_: i like this idea. i could use it.
11:37:38 <gwern> dcoutts_: I've wondered, what exactly does the extensions: field actually do? I'm certain I've not always enumerated all extensions used in LANGUAGE pragmas, but it didn't seem a problem
11:37:41 <dons> allowed-extensions: ...
11:37:41 <dcoutts_> dons: and then cabal/hackage should start to enforce it
11:37:52 <dons> dcoutts_: right. and we could filter on specific language setts
11:37:59 <dons> i.e. h98+ffi only
11:38:00 <dons> etc.
11:38:16 <dons> would be easy to determine the set of packages buildable with nhc or hugs this way
11:38:20 <dcoutts_> dons: well, by looking at a package you'd be able to see what it uses, then you can apply whatever policy you like
11:38:26 <dons> right.
11:38:39 <dcoutts_> and yes, cabal could and should know what extensions particular compilers support
11:38:59 <dons> so we couldn't break things though -- it would have to be optional, but recommended
11:39:05 <dons> to list allowed extensions in the .cabal
11:39:16 <dons> if you spit out a warning from cabal, everyone will start using it
11:39:19 <dcoutts_> dons: it can be optional at configure time, and hackage can reject packages that do not do it
11:39:39 <dcoutts_> dons: we're implementing several QA checks that are not enforced at configure/build time but at package upload time
11:39:48 <dons> yeah
11:40:00 <dons> i like this actually. we could do it for the galois hackage stuff
11:40:16 <dons> could you stick a ticket up for this?
11:40:23 <dcoutts_> sure
11:40:32 <dcoutts_> though it's a bit tricky to do as a upload time test since it involves running pre-processors in general
11:41:00 <sjw> dons: way past bedtime --- later
11:41:30 <shapr> dons: Yeah, I don't think anyone cares if my tests are in Haskell, but I should check.
11:42:37 <dons> shapr: i'm just wondering how much resistance some haskell test stuff would face
11:42:48 <dons> probably not much if it added obviously to quality assurance
11:43:10 <shapr> Yup
11:44:45 <BMeph> Welcome to #haskell, where we have more Simons per capita than any other programming environment! ;)
11:45:38 <lament> one?
11:50:15 <hpaste>  Deewiant pasted "glob matcher, comments welcome" at http://hpaste.org/5486
11:53:12 <wy> hello
11:53:41 <BMeph> Howdy, wy! :)
11:53:57 <wy> BMeph: hey
11:54:15 <wy> I'm leaving Cornell. Do you guys have some good idea where to go for FP?
11:55:38 <dcoutts_> wy: I'm applying all round the UK for post-doc FP stuff, there are several unis
11:55:58 <shapr> wy: Chalmers? OGI?
11:56:33 <phlpp> :t fix
11:56:33 <lambdabot> forall a. (a -> a) -> a
11:56:35 <phlpp> @src fix
11:56:35 <wy> I have no idea about europe at the time. When are the deadlines? the US ones are too late but fortunately I got in contact with Daniel Friedman
11:56:35 <lambdabot> fix f = let x = f x in x
11:58:18 <wy> I should try to figure out the real relationship between the FP guys ;)
11:58:58 <wy> shapr: I know Chalmers is good. Where is OGI?
11:59:17 <MoxJet> Do you live in Sweden?
12:00:52 <byorgey> wy: OGI (Oregon Graduate Institute) is no more, most of the profs there went to Portland State
12:00:55 <tuukkah> gwern, you there?
12:01:13 <byorgey> wy: and actually, I don't think the PSU deadline is past, unlike most US institutions
12:01:14 <wy> No. I'm still at Cornell
12:01:40 <wy> totally stupified by cornell...
12:02:38 <postalchris>  wy: where are you at in your program? what's driving you away from cornell?
12:03:32 <wy> postalchris: No real stuff going on here. I don't just mean FP... but any subject
12:04:02 <byorgey> davidL: sounds like fun to me =)
12:04:04 <dangb> is there anyone working on a Qt binding?
12:04:06 <wy> totally driven by money
12:04:06 <byorgey> er, mischan
12:04:29 <shapr> aww, no more OGI?
12:04:39 <shapr> What about PDX? Did they subsume OGI?
12:04:43 <byorgey> shapr: PSU is the new OGI =)
12:04:48 <wli> OGI got gutted and the FP people fled to PSU.
12:06:04 <wy> uhh... how about Indiana? I know they did great in Scheme.
12:06:12 <wy> what happened with OGI?
12:06:14 <postalchris> UPenn has a good PL group
12:06:44 <wy> postalchris: Cornelll is trying to hire their head
12:07:01 <postalchris> wy: that's a good sign, then
12:07:20 <wy> postalchris: but the nature of a university can't be really changed
12:08:35 <wy> I'll still have to pass stupid exams even they have him
12:09:12 <wy> I should really be careful this time ;-)
12:09:20 <wli> wy: I've seen them change for the worse.
12:09:31 <wy> wli: who?
12:09:47 <wy> wli: oh... I see
12:10:25 <wy> wli: I believe it's short of money. So it has too many undergrads and heavy TA duties. Who cares about research
12:10:51 <postalchris> wy: too many undergrads isn't a problem I've heard complaints about lately.
12:11:22 <wy> postalchris: too many so they can't really take care of them
12:11:34 <vincenz> GrayShade_: ok
12:11:44 <postalchris> wy: most uni's are fighting for UG enrollments
12:11:54 <postalchris> wy: (most CS depts I mean)
12:12:02 <wy> hehe
12:13:14 <wy> I'd better stop complaining and think about next step
12:13:50 <hpaste>  dpiponi pasted "Stupid Haskell prog. 3rd order quine. Haskell generates Python generates Ruby generates Haskell." at http://hpaste.org/5487
12:13:57 <wy> complaining is a good thing some times. I really learned a lot this winter by complaining about haskell's type system ;)
12:14:21 <b_jonas> hpaste: I've written a 2nd order quine once
12:14:45 <b_jonas> it's not actually more complicated than a simple quine, for all but one phases can be just a single print statement
12:14:54 <dpiponi> Once you get to 3rd order it gets easier.
12:15:31 <wy> Anybody in the US in this channel?
12:15:53 <b_jonas> it would get complicated if the goal would be that each phase randomly chooses one of the languages and writes the next phase that way, and you also want to make it short
12:15:54 <Syzygy-> Yo dpiponi!
12:16:02 <sclv> wy: with 432 members its hard to imagine some aren't.
12:16:13 <dpiponi> Hi Syzygy-
12:16:14 <b_jonas> I never yet tried to write a haskell quine so I dunno how it would be like
12:17:21 <mauke> import Control.Monad.Reader;main=putStrLn$ap(++)show"import Control.Monad.Reader;main=putStrLn$ap(++)show"
12:17:27 <davidL> @quote quine
12:17:27 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
12:17:28 <dpiponi> Haskell's one of the easiest langauges for quines. Especially with the show function.
12:17:55 <postalchris> wy: i'm in NY
12:18:03 <pjd> dpiponi: Python, too, with repr
12:18:19 <b_jonas> dpiponi: yes, I wrote a scheme quine with display
12:18:20 <wy> postalchris: Don't tell me you are in Cornell
12:19:00 <b_jonas> and I think I have a J quine which uses the builtin function that (tries to) create readable representation of a datum, but I'm not sure
12:19:05 <b_jonas> hmm, I'll have to look that up
12:19:10 <postalchris> wy: naw, NYU, ithaca is not for me
12:19:17 <dpiponi> pjd: yes. Dunno what the ruby is, but it wasn't too hard to work around.
12:19:30 <wy> postalchris: NYU is far better in CS
12:19:47 <wy> postalchris: Do you know Yann Lecun?
12:20:03 <postalchris> no
12:20:09 <b_jonas> dpiponi: wtf is the first language you run that pasted code in?
12:20:16 <b_jonas> it doesn't look like haskell
12:20:26 <b_jonas> hmm, it must be python then
12:20:26 <dpiponi> Haskell!
12:20:39 <dpiponi> Ooops
12:20:47 <wy> postalchris: alright. I'll send my transcript to Indiana now. How can I make it by Thursday morning?
12:20:48 <dpiponi> I pasted the wrong one in the sequence :-)
12:21:57 <davidL> wy: you are at cornell and thinking of transferring to indiana?
12:22:05 <wy> davidL: yes
12:22:07 <hpaste>  dpiponi annotated "Stupid Haskell prog. 3rd order quine. Haskell generates Python generates Ruby generates Haskell." with "Correct version of 3rd order quine" at http://hpaste.org/5487#a1
12:22:27 <wy> davidL: That's an option
12:23:00 <davidL> wy: I think UT has a decent cs program
12:23:18 <wy> davidL: Are they good at FP?
12:23:23 <hpaste>  mauke pasted "ghc quine" at http://hpaste.org/5488
12:23:45 * b_jonas tests it
12:24:09 <wy> alright. I guess I'd better go to the fedex shop now
12:24:34 <b_jonas> dpiponi: ok, works
12:24:39 <vincenz> nerds
12:24:53 <mauke> bah, it removed the first line
12:24:55 <shapr> hiya dpiponi!
12:25:04 <dpiponi> hi shapr, gotta go
12:25:06 <shapr> dpiponi: Hey, you got mentioned at the Hacking in Haskell talk.
12:25:08 <shapr> aww
12:25:41 <b_jonas> the only two-phase quine I remember to have written was to loop two irc bots
12:26:05 <b_jonas> buubot's perl eval command and maldous' bot's rot13 command
12:26:48 <b_jonas> yeah, I have written a J quine which uses their equivalent of display/show
12:26:54 <b_jonas> had to check
12:27:40 <shapr> yay #haskell!
12:28:22 <b_jonas> and I think I have invented one of the shortest non-empty non-cheating known perl quines
12:28:32 <b_jonas> though I of course can't be sure in things like this
12:31:11 <mauke> <oMiish> vim implements 220% of features I need
12:31:44 <GrayShade> vincenz: this is my variant
12:31:48 <GrayShade> vincenz: http://hpaste.org/5489
12:32:20 <mauke> perl allows some rather interesting cheats, though
12:32:28 <vincenz> GrayShade: lost my code :|
12:32:56 <GrayShade> vincenz: but i wonder, how awful is my code? i'm only learning haskell
12:33:08 <b_jonas> mauke: yep :)
12:33:15 <vincenz> GrayShade: better than mine
12:33:23 <GrayShade> :\
12:33:33 <b_jonas> DATA, DATA and seek back, open 0, source filters, eval, ...
12:33:37 <mauke> open 0 and print <0> or die $!
12:33:45 <mauke> it's almost English :-)
12:33:54 <b_jonas> some of those are cheating, and some aren't
12:35:00 <b_jonas> and some of us have written perl quines that cheat by loading their source code from the 'net from where the quine is submitted
12:35:27 <b_jonas> it's just sick
12:35:41 <Gnezdo> I loaded a 100+ modules into ghci. Is there a way to shorten its prompt?
12:35:42 <hpaste>  vincenz annotated "boring combinatorics problem" with "more sharing" at http://hpaste.org/5489#a1
12:35:46 <vincenz> GrayShade: there you go
12:36:27 <GrayShade> ouch
12:36:41 <Gnezdo> with a multiple line prompt  following each evaluation it's hard to see the result I care about
12:36:57 <scodil> Gnezdo: :set prompt >
12:37:26 <scodil> it's right there in :help :)
12:37:34 <jedbrown> Gnezdo: That's a lot of modules!  I have :load "/home/jed/.GHCi.hs" in my .ghci.
12:37:55 <Gnezdo> indeed, thanks scodil!
12:37:58 <scodil> np
12:38:12 <jedbrown> Gnezdo: That is better than `:set prompt >' for me because then extra modules are shown explicitly.
12:38:15 <scodil> that actually bugs me too but i never thought to do anything about it until you asked
12:38:49 <Gnezdo> well, I'm using it with haskell-mode to do source browsing, so I do want all modules loaded
12:38:52 <vincenz> GrayShade: what's 'p'
12:39:41 <wli> :set prompt ">> " is what I do.
12:39:44 <Gnezdo> jedbrown, what's in that .GHCi.hs?
12:39:54 <jedbrown> Gnezdo: A bunch of import statements.
12:39:55 <GrayShade> vincenz: parts' p n is the list of lists that start with numbers greater that or equal to p and whose sum is n
12:40:16 <Gnezdo> jedbrown: got it
12:40:36 <Gnezdo> thanks guys
12:40:40 <jedbrown> Gnezdo: You can also import qualified that way.  For instance to hide Control.Arrow.pure in favor of Applicative.
12:40:59 <jedbrown> Gnezdo: And Data.Map as M, etc.
12:42:31 <GrayShade> vincenz: i mean, (and $ map ((>=p).head) $ parts' n p) is true
12:42:52 * vincenz nods
12:43:28 <nominolo> :t parts = [[]]:[concat [map ((n-i):) l | i <- [0..n-1], let l = filter (\x -> null x || (n-i) >= (head x)) $ parts !! i] | n <- [1..]]
12:43:31 <lambdabot> parse error on input `='
12:43:38 <nominolo> :t [[]]:[concat [map ((n-i):) l | i <- [0..n-1], let l = filter (\x -> null x || (n-i) >= (head x)) $ parts !! i] | n <- [1..]]
12:43:38 <lambdabot> Not in scope: `parts'
12:44:06 <nominolo> :t fix $ \parts -> [[]]:[concat [map ((n-i):) l | i <- [0..n-1], let l = filter (\x -> null x || (n-i) >= (head x)) $ parts !! i] | n <- [1..]]
12:44:06 <lambdabot> [[[Int]]]
12:45:18 <archmangle> who -lusers
12:45:37 <nominolo> @users?
12:45:37 <lambdabot> Maximum users seen in #haskell: 471, currently: 430 (91.3%), active: 18 (4.2%)
12:47:02 <archmangle> * ahem * okay. nevermind.
12:48:04 <vincenz> nominolo: bah
12:48:05 <vincenz> nominolo: @pl
12:48:28 <nominolo> vincenz: i was trying to get some idea what it's doing
12:48:41 <nominolo> @pl  fix $ \parts -> [[]]:[concat [map ((n-i):) l | i <- [0..n-1], let l = filter (\x -> null x || (n-i) >= (head x)) $ parts !! i] | n <- [1..]]
12:48:42 <lambdabot> (line 1, column 22):
12:48:42 <lambdabot> unexpected "["
12:48:42 <lambdabot> expecting white space or simple term
12:48:56 <nominolo> @pl parts = [[]]:[concat [map ((n-i):) l | i <- [0..n-1], let l = filter (\x -> null x || (n-i) >= (head x)) $ parts !! i] | n <- [1..]]
12:48:56 <lambdabot> (line 1, column 7):
12:48:56 <lambdabot> unexpected "="
12:48:56 <lambdabot> expecting variable, "(", operator or end of input
12:49:22 <nominolo> whatever
12:50:29 <vincenz> nominolo: you want a function
12:50:32 <vincenz> @pl foo parts = ..
12:50:32 <lambdabot> (line 1, column 11):
12:50:32 <lambdabot> unexpected "="
12:50:32 <lambdabot> expecting variable, "(", operator or end of input
12:51:02 <GrayShade> @pl f x = x
12:51:02 <lambdabot> f = id
12:51:09 <GrayShade> @pl f x = x*2
12:51:09 <lambdabot> f = (2 *)
12:51:19 <mrd> vincenz: hey
12:51:30 <GrayShade> @pl parts' p n = concat $ map (\x -> (map . (:)) x $ parts' x $ n - x) [p .. n]
12:51:31 <lambdabot> parts' = fix (((join .) .) . (. enumFromTo) . ap . ((map . liftM2 map (:)) .) . (. (-)) . ap)
12:51:44 <GrayShade> :-s
12:52:04 <vincenz> mrd: ?
12:52:11 <mrd> i was reading your post
12:52:13 <vincenz> que pasa?
12:52:15 <vincenz> which one?
12:52:27 <mrd> i wouldn't call that STLC, since STLC does not have polymorphism
12:52:37 <vincenz> erm
12:52:37 <mrd> it's more like "InfiniteseML"
12:52:47 <vincenz> oh :)
12:52:54 <vincenz> well you won't get polymorphism
12:52:59 <vincenz> since nogeneralize is used
12:53:04 <mrd> because of the polytype / monotype distinction you discuss
12:53:15 <vincenz> I never generalize tho
12:53:19 <vincenz> so the point is moot :)
12:53:32 <mrd> the value/monomorphism restriction isn't what you describe
12:53:58 <czakey> @seen oscarM
12:53:58 <lambdabot> I haven't seen oscarM.
12:54:02 <vincenz> mrd: hmm?
12:54:03 <mrd> one sec
12:54:37 <sclv> ?src transpose
12:54:37 <lambdabot> transpose []             = []
12:54:37 <lambdabot> transpose ([]   : xss)   = transpose xss
12:54:37 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
12:57:23 <pa-ching> Hmm, inside StateT, how can I perform modify only on a certain condition? Can't seem to figure out what I should have in the else clause...
12:57:45 <twanvl> when condition (modify ...)
12:57:55 <pa-ching> Oho, fair enough
12:58:02 <twanvl> or with if-then-else:  if condition then dostuff else return ()
12:58:41 <pa-ching> Hmm weird, I tried return () and got errors. Maybe from something else, then
12:58:45 <pa-ching> Cool, thanks
13:02:36 <mrd> vincenz: so, when performing type inference in ML, you close an open type by inserting explicit type-lambdas around polymorphic terms
13:03:00 <vincenz> mrd: when I close an open type bound to a let-identifier
13:03:03 <mrd> right
13:03:06 <vincenz> I 'forall' over all free variables
13:03:18 <vincenz> when I close an open type of a lambda (generalize) I don't forall at all
13:03:22 <mrd> well yes, but remember that the term with type forall is a type-lambda
13:03:22 <Gnezdo> hmm, this is funny, so I ':set prompt >' in ghci, but is there a way to put a space after > ?
13:03:36 <Gnezdo> inf-haskell seems to be looking for '> '
13:03:47 <Gnezdo> when it does prompt detection
13:04:00 <b_jonas> :set prompt "> " seems to work
13:04:05 <vincenz> mrd: right
13:04:26 <Gnezdo> argh, why am I so lame? I tried '> '
13:04:31 <Gnezdo> thanks
13:04:41 <mrd> so, "let id x = x in (id 'b', id 1)" becomes "let id = /\a.\x:a.x in (id [Char] 'b', id [Int] 1)"
13:05:03 <Time`s_Witness> (\x -> x+1) 3
13:05:06 <Time`s_Witness> @(\x -> x+1) 3
13:05:07 <lambdabot> you are welcome
13:05:07 <mrd> the value restriction would not be triggered by this example because "\x:a.x" is a value
13:05:11 <byorgey> Gnezdo: I guess it follows Haskell syntax.  ' is for Chars and " is for strings.
13:05:34 <vincenz> mrd: correct
13:05:38 <byorgey> > (\x -> x+1) 3  -- Time`s_Witness?
13:05:42 <lambdabot>  4
13:05:45 <vincenz> mrd: the use of an identifier 'instantiates' it with fresh variables
13:05:48 <Time`s_Witness> testing lambdabot :P
13:05:59 <byorgey> @botsnack
13:05:59 <lambdabot> :)
13:06:00 <mrd> however, suppose you write "let id = (print "hi"; \x. x) in (id 'b', id '1')"
13:06:10 <Time`s_Witness> what, lambdabot is not a bot
13:06:10 <Time`s_Witness> ?
13:06:11 <Time`s_Witness> LOL
13:06:14 <Time`s_Witness> ok then xD
13:06:45 <mrd> the expected behavior is that "hi" is printed once, and then you get the value ('b', 1)
13:06:51 <mrd> sorry for the typo
13:07:18 <vincenz> mrd: I don't deal with side-effects
13:07:19 <vincenz> :)
13:07:22 <vincenz> I know those are an issue
13:07:26 <vincenz> similar issues with 'ref'
13:07:31 <mrd> however, when the typechecker inserts the typelambda, the term becomes: "let id = /\a. (print "hi"; \x:a.x) in (id 'b', id 1)"
13:07:48 <mrd> and "hi" is printed twice, after each application
13:07:55 <mrd> sorry, (id  [Char] 'b', id [Int] 1)
13:08:00 * vincenz nods
13:08:02 <vincenz> read above :)
13:08:15 <mrd> that is the reason for value restriction in ML
13:08:18 <mrd> not type safety
13:08:37 <vincenz> well mostly the 'ref' thingy
13:08:43 <mrd> 'ref' doesn't change the story
13:09:39 <vincenz> ref introduces a similar problem as the print one
13:09:47 <vincenz> in a pure langauge this is never an issue
13:09:56 <vincenz> but thanks for the tip
13:10:01 <vincenz> I never thought about it in type-lambda way
13:10:01 <mrd> there can be repeated computation
13:10:03 * vincenz isn't a CS-person
13:10:12 <mrd> but type safety isn't the concern, refs or not
13:10:13 <vincenz> repeated computation don't matter as much in a pure system?
13:10:31 <mrd> well from one standpoint it doesn't matter
13:10:57 <vincenz> mrd: anywho, feel free to leave a comment behind
13:11:05 * vincenz wasn't aware of type-lambdas in that sense
13:11:29 <bos> @seen dons
13:11:30 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 25m 47s ago.
13:12:35 <bos> @tell dons how about that bytestring split performance?  ouch!
13:12:35 <lambdabot> Consider it noted.
13:12:48 <vincenz> ouch :)
13:12:49 <dons> bos, yo.
13:12:49 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
13:12:59 <dons> the code looks pretty good though
13:13:04 <dons> or do you think its being misoptimised?
13:13:10 <dons> for split, that is
13:13:22 <bos> the code looks reasonable to me, too.
13:13:27 <dons> maybe its too strict?
13:13:45 <dons> hmm. i wonder.
13:13:48 <bos> i tried substituting some haskell code in there, and it went about 1/3 the speed of memchr.
13:14:09 <dons> there's a haskell version commented out underneath
13:14:32 <bos> that was the stuff i was mucking with.
13:14:40 <dons> so 3x slower, you mean?
13:14:44 <wy> back... sent a next afternoon mail
13:14:45 <lambdabot> wy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:14:46 <bos> yes.
13:14:55 <dons> yeah, that sounds right
13:15:15 <dons> seems to be allocating a lot
13:15:33 <dons> so i wonder if we generate the entire list strictly. perhaps it shouldn't, if it does
13:15:59 <bos> i think that to transpose the list of lists, we have to generate the entire list beforehand.
13:16:08 <dons> hmm. maybe
13:16:18 <seydar>  Text.Regex.Posix in case..of statements?
13:16:29 <bos> but Data.List.list is lazy in both dimensions, as far as i can see.
13:16:35 <bos> er, Data.List.transpose
13:16:42 <mrd> maybe i should just write a blog post explaining the value restriction once and for all
13:16:45 <dons> transpose has always been famously inefficient
13:16:47 <wy> How can I leave message to someone with lambdabot?
13:16:47 <mrd> (yea right)
13:16:59 <mrd> @tell wy this
13:16:59 <lambdabot> Consider it noted.
13:17:00 <wy> dons: matrix?
13:17:00 <lambdabot> wy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:17:06 <byorgey> @help tell
13:17:06 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
13:17:25 <wy> mrd: Got it. Thanks!
13:17:30 <bos> but regardless of transpose's efficiency, it sure looks like split is where we're burninating the cycles.
13:17:32 <vincenz> mrd: anywho, thx for info, never knew of that
13:17:37 <seydar> ok, in short, is there a way to use Regexps in Case statements?
13:17:43 <bos> seydar: yes
13:17:54 <bos> @go haskell regexp tutorial
13:17:56 <lambdabot> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
13:17:56 <lambdabot> Title: teideal glic deisbh√©alach ª Blog Archive ª A Haskell regular expression tutoria ...
13:18:08 <seydar> that doesn't show how to put them in case statements though
13:18:16 <dons> i note that pandoc/kate-highlighting is using pcre-light, not regex-*  :)
13:18:16 <dons> yay
13:18:29 <mrd> hmm, sequence.complete.org is popping up DB error msgs about a crashed table
13:18:36 <dons> oh hmm
13:18:48 <bos> seydar: case foo =~~ bar of { Nothing -> fail "barf"; Just match -> blah blah }
13:19:03 <MarcWeber> dcoutts_: I've a smal patch for you http://mawercer.de/package-conf-patch-register-sh
13:19:08 <bos> mrd: tell CosmicRay
13:19:35 <seydar> what's Just match?
13:20:21 <seydar> and did you mean =~ or =~~ ?
13:20:57 <bos> seydar: =~~ is the monadic version of =~
13:21:24 <bos> seydar: Just is a constructor for the Maybe type
13:21:29 <seydar> is there a way I can do case foo of { =~~ "[a-z]" -> print "yeah" } ?
13:23:02 <GrayShade> seydar: case foo =~~ "[a-z]" of { Just match -> print "blah"; Nothing -> fail} ?
13:23:23 <seydar> hmm. i was hoping i could have multiple tests in one case
13:23:46 <seydar> case foo of { =~~ "[a-z]" -> print "hasdf" }
13:24:28 <vincenz> seydar: no
13:24:32 <sarehu> someFuncYouDefine foo [("[a-z]", \match -> action), ("otherPattern", \match -> action), ... ]
13:25:17 <seydar> fine
13:25:20 <seydar> thanks all!
13:25:25 <sclv> i tried the transpose example and with bos' default settings for file size it hosed all the ram on my poor little imac.
13:25:42 <bos> ouch.
13:25:56 <sclv> the memory usage is insane. i wonder if that's just how it has to be with transpose.
13:25:59 <bos> well, at least all that memory will be sparkling clean when it's done.
13:26:27 <sclv> i had to hold my right-click for a good two minutes to get the force quit menu on iterm!
13:26:34 <vincenz> seydar: code?
13:26:34 <CosmicRay> mrd: that's hosted over at pdx.edu now .  I'll alert them
13:26:41 <seydar> vincenz: k
13:26:45 <vincenz> erm
13:26:45 <vincenz> sorr
13:26:47 <vincenz> sclv: code?
13:27:02 <sclv> bos's msg to haskell-cafe.
13:27:14 <vincenz> doh
13:28:45 <seydar> http://hpaste.org/5490
13:28:57 <seydar> ah.
13:29:59 <BMeph> sclv: What are you trying to transpose? Maybe the Applicative paper's transpose may give better results.
13:30:54 <sclv> BMeph: it's from a discussion on -cafe. essential problem: read in a 20ish MB csv. transpose it.
13:31:32 <dons> if anyone has any ideas on flaws in bytestring that would make this easier, my door's open
13:31:57 <BMeph> sclv: Okay, I'm still on-again, off-again with reading mailing lists. Mostly because I'm interested in too many topics. ;)
13:36:18 <bos> dons: it's impressively hard to see where there's room for improvement there
13:37:14 <sclv> bos: did you try with a lazy bytestring?
13:37:21 <bos> sclv: slowre
13:37:24 <bos> er, slower.
13:37:29 <sclv> figures. :-)
13:38:30 <bos> in fact, lazy bytestrings have an even more huge space leak than strict on this program.
13:38:57 <dons> well, what's a C version do?
13:39:06 <dons> tranpose inplace relying on uniqueness?
13:40:02 <bos> if i were writing a C version, i'd read the entire file into a string, then modify the string in place, replacing each ',' and '\n' with a '\0', putting the rows into different rows of an array.
13:40:19 <dons> mm
13:40:29 <dons> just type coerce the type of the memory buffer?
13:40:31 <bos> i'd then just transpose the pointers in the array.
13:40:41 <bos> yes, exactly.
13:40:58 <dons> yeah, so Storable-array style. (or castPtr)
13:41:00 <bos> let me code something up.
13:41:16 <dons> and relying on uniqueness (no refs to the old structures in the rest of the program)
13:41:44 <dons> so a runST-ish thing
13:41:54 <dons> suck it in, tranposeST, spit out a result
13:42:14 <bos> yep
13:42:49 <seydar> can I use regexps in normal patternMatching?
13:43:13 <dons> normal haskell data pattern matching, you mean?
13:43:18 <seydar> yea
13:43:27 <dons> what would it look like?
13:43:44 <seydar> ptHelp ("Foo [a-z]*":rest)
13:43:46 <dons> (there is an extensions for regex patterns on lists)
13:44:02 <dons> nope. that doesnt' work. but a pattern guard does
13:44:13 <dons> ptHelp x | Just _ <- match "Foo.*bar" x
13:44:28 <dons> ptHelp x | Just (_,rest) <- match "Foo.*bar"  -- that kind of thing
13:44:47 <shag> is there a bug in GHC known where it ignores pragmas n the source because of some other comment before the pragma?
13:45:14 <dons> top -of-file pragmas?
13:45:33 <shag> in particular, {-# OPTIONS -fglasgow-exts #-}
13:45:40 <dons> that's documented behaviour
13:45:45 <dons> the pragma should be the first comment
13:45:49 <shag> but the GHC documentation states, that "they can be preceded or followed by comments"
13:45:59 <shachaf> dons: Or view patterns?
13:46:07 <dons> shachaf: oh, not sure about that
13:46:10 <dons> shag.
13:46:17 <dons> shachaf: are views implemented?
13:46:36 <sclv> hmm.. a stricter transpose does help some.
13:46:43 <shachaf> dons: Oh, only in darcs GHC. :-)
13:46:44 <shag> dons: and, it does not depend on the whole preceding comment, just a few specific lines in that comment.
13:46:47 * shachaf forgot about that.
13:46:58 <dons> we've views in darcs ghc?
13:47:03 <dons> i don't think i saw that patch
13:47:11 <dons> views of the hbc circa 1992 style?
13:47:29 <Heffalump> view patterns are in 6.9
13:47:45 <Heffalump> and in 6.8 but broken and undocumented
13:48:07 <shachaf> dons: "Wed Oct 10 08:02:54 PDT 2007  Dan Licata <drl@cs.cmu.edu> * View patterns, record wildcards, and record puns This patch implements three new features: * view patterns (syntax: expression -> pat in a pattern) ..."
13:48:10 <Axioplase> @pl f n = f !! n
13:48:10 <lambdabot> f = fix (!!)
13:48:17 <dons> ah yes, came with the puns patch ok.
13:48:34 <dons> i want to use puns in xmonad, though 6.8 has some bugs to iron out
13:48:35 <Botje> Axioplase: ITYM \f, no?
13:48:41 <Botje> @pl \f n -> f !! n
13:48:41 <lambdabot> (!!)
13:48:46 <Botje> not that that's very interesting :p
13:48:51 <Axioplase> indeed
13:49:34 <sclv> actually, no, it doesn't.
13:49:42 <sclv> (a stricter transpose that is)
13:53:35 <seydar> ok so in regexp again (sorry)
13:54:31 <wy> It seems lots of you guys are also in #scheme
13:54:49 <seydar> why would it complain about me using regexps in a function?
13:55:32 <shachaf> seydar: Why would what complain? Using regexps how?
13:55:43 <seydar> err, sorry.
13:55:54 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5491
13:56:03 <seydar> http://hpaste.org/5491
13:56:45 <RayNbow> hmm, anyone familiar with the listings package (LaTeX)?
13:59:40 <Axioplase> wy: isn't it somehow the same family, struggling for the acknowledgement by the masses of the superiority of FP ?
13:59:40 <igel> what's the proper way to include testcases in a cabal package?
14:00:01 <igel> i don't want them to be compiled into the library
14:00:11 <dons> igel: i always put them in a tests/ subdir
14:00:20 <dons> with a wrapper script to run them all easily from the command line
14:01:09 <igel> and in the .cabal?
14:01:10 <kombinator> I have a question regarding FingerTree. I'm trying to use it with a measuring function determined dynamically during the runtime. But if you look at http://hackage.haskell.org/packages/archive/fingertree/0.0/doc/html/Data-FingerTree.html , the function is determined by the Measured class so it is fixed for a given type.
14:01:11 <lambdabot> http://tinyurl.com/263k57
14:01:25 <igel> as Extra-Source (or whatever it's called)?
14:01:32 <kombinator> Is there an easy workaround for that?
14:01:36 <pjd> wy: Scheme and Haskell go nice together
14:01:46 <pjd> good cop/bad cop, or something
14:01:59 <mrd> RayNbow: anything about it? using it for lhs?
14:02:13 <wy> Axioplase: I got interested in FP from SICP. I got into Common Lisp later and then ML and Haskell.  I'm wondering the relationship between those things
14:02:14 <pjd> (deciding which is which is left as an exercise :)
14:02:35 <seydar> shachaf: http://hpaste.org/5491 ghc complains about me using regexps. my code: http://hpaste.org/5492
14:03:03 <Axioplase> wy: High Order is the most obvious common point to all of them
14:03:07 <Twigathy> how does one coerce from Float -> Int?
14:03:16 <dons> :t truncate
14:03:16 <Botje> Twigathy: floor or ceiling or round?
14:03:17 <mrd> Twigathy: floor, ceil
14:03:18 <dons> :t round
14:03:20 <Botje> or that
14:03:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:03:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:03:21 <dons> :t ceil
14:03:21 <lambdabot> Not in scope: `ceil'
14:03:24 <dons> :t ceiling
14:03:25 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:03:26 <dons> :t floor
14:03:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
14:03:39 <wy> Axioplase: but it seems types really matter
14:03:45 <Axioplase> But some problems get solved more easily using lazy/eager/macros/call-cc
14:03:53 <wy> although cumbersome sometimes
14:04:07 <shachaf> seydar: Does giving ptHelp a type signature help, maybe?
14:04:23 <igel> dons: do you add the test files as data-files, extra-source-files or extra-tmp-files?
14:04:54 <Axioplase> wy: I don't write Scheme code the same way I write Caml code or Haskell code... Some shortcuts are forbidden while others are enabled...
14:05:30 <seydar> shachaf: nopes. just gives me more erros
14:05:42 <seydar> well, it SHOWS more errors
14:05:53 <seydar> all the same one, though.
14:06:05 <seydar> shachaf: complaining about no instance for my Regexp
14:06:27 <dons> igel, just as extra-source-files usually
14:06:49 <igel> ok thanks
14:06:51 <igel> :)
14:07:17 <kombinator> Does anyone here have any experience with the FingerTree package?
14:07:18 <wy> Axioplase: I actually wrote all the exercises of SICP. So I know the difference. I'm just a little confused about what is really the start-of-the-art
14:08:15 <Axioplase> start-of-the-art is lambda calculus ^^
14:08:17 <dons> Pseudonym: got any good OlegFacts about free theorems?
14:08:24 <seydar> shachaf: have you seen it yet?
14:08:44 <Axioplase> state-of-the-art is subjective. But reasearch in each functional language seem to focus on different things...
14:09:01 <dons> like a -> b, or a -> a. or perhaps the devil having to pay oleg for the free threorems
14:09:14 <Axioplase> All in all, it's not a competition, is Divide and Conquer applied to research
14:09:58 <sarehu> kombinator: what about it?
14:09:58 <gwern> kombinator: yi uses FingerTree, fwiw
14:10:15 <shachaf> seydar: Oh... You are giving ptHelp [String], aren't you?
14:10:21 <pjd> Deride and Compete
14:10:27 <seydar> shachaf: yes
14:10:29 <kombinator> sarehu, gwern: I'll post my question one more time
14:10:42 <seydar> but now I changed that, and it still complains, shachaf
14:11:00 <kombinator>  I have a question regarding FingerTree. I'm trying to use it with a measuring function determined dynamically during the runtime. But if you look at http://hackage.haskell.org/packages/archive/fingertree/0.0/doc/html/Data-FingerTree.html , the function is determined by the Measured class so it is fixed for a given type. Is there a workaround for that?
14:11:02 <lambdabot> http://tinyurl.com/263k57
14:11:06 <shachaf> seydar: I just copied ptHelp into a file and it seems to work.
14:11:06 <pejo> wy, I think you need to specify what area you wnat to know what the state of the art is.
14:12:23 <gwern> kombinator: dunno, sry
14:12:57 <seydar> shachaf: which lib do you import? I'm importing Text.Regex.Posix
14:13:14 <shachaf> Yes, the same.
14:13:48 <seydar> hmm. I seem to get the same error when compiling standalone.
14:14:02 <sarehu> kombinator: maybe through something evil via unsafePerformIO
14:14:07 <seydar> can you hpaste EXACTLY what you have? i'll do the same with mine
14:14:20 <seydar> btw, running 6.6
14:14:39 <hpaste>  seydar pasted "(no title)" at http://hpaste.org/5493
14:14:49 <kombinator> sarehu: perhaps I'll just fork my own version of FingerTree
14:15:00 <shag> @pl (\(k, v) -> (decode k, v))
14:15:00 <lambdabot> first decode
14:15:15 <sarehu> kombinator: alternately, you could store the measurement function with the values you're storing ; obviously that's not what you would want
14:15:54 <kombinator> sarehu: yeah, I was thinking of that, but it seems too backwards :D
14:16:02 <RayNbow> <mrd> RayNbow: anything about it? using it for lhs? <-- ah, n/m... I already solved it...
14:16:34 <RayNbow> I just had a problem that certain slashes turned into lambdas
14:16:38 <RayNbow> which I didn't want :p
14:17:01 <shachaf> seydar: The problem is your type signature.
14:17:16 <shachaf> seydar: Comment it out and see. :-)
14:17:20 <seydar> shachaf:  whoa! you're right!
14:17:23 <sarehu> forking your own version would be a little bit of tedium but not technically difficult, it's probably the right way
14:17:39 <kombinator> sarehu: but that's what I will do at least in the beginning
14:17:44 <Cin> i think i'll try the Scheme in 48 Hours interpeter and implement my stupid pattern-matching ideas :D
14:18:17 <Gnezdo> is there a way to enumerate all constructors, i.e. given data T = A | B | C get a list [A, B, C] ?
14:18:36 <shachaf> Gnezdo: By deriving (Enum), probably?
14:18:37 <Cin> is there an Enum class?
14:18:50 <Gnezdo> indeed, thanks!
14:18:56 <shachaf> Then something like [minBound..maxBound], I'd guess.
14:19:08 <sarehu> derive Bounded, too.
14:19:15 <shachaf> Yes, sorry.
14:19:55 <hpaste>  seydar pasted "(no title)" at http://hpaste.org/5494
14:20:16 <seydar> shachaf: ok, so I expanded it, and I get the same error. ^^^
14:23:36 <scodil> is there any motivation, among the people who have a say is these things, to make Storable derivable?
14:23:54 <quicksilver> I think it's not obvious how to do it
14:24:02 <scodil> even for single constructor types?
14:24:04 <quicksilver> the most common case of Storable is to try to make it match the C struct
14:24:04 <scodil> C does it
14:24:17 <scodil> yeah what's wrong with that?
14:24:18 <quicksilver> and that requires knowledge of the C ABI on that platform
14:24:25 <quicksilver> which ghc doesn't know about
14:24:30 <quicksilver> (not explicitly anyway)
14:24:35 <dons> some ffi tools kinda support this
14:24:37 <scodil> no I mean it doesn't have to match C's memory layout, it can just pick some layout
14:24:38 <jsnx> if we used asn.1 for that instead...
14:24:39 <dons> with hints and tweaks
14:24:39 <scodil> any layout
14:24:48 <quicksilver> scodil: actually it does have to match C's memory layout
14:24:55 <quicksilver> scodil: for certain applications
14:25:00 <quicksilver> (and that's quite a common way of doing it)
14:25:03 <scodil> quicksilver: I can write a Storable instance to match any layout I want
14:25:06 <jsnx> asn.1 could define the layout, and we could easily compile a parser from it
14:25:07 <quicksilver> you can
14:25:08 <seydar> shachaf: what am I doing wrong in this: http://hpaste.org/5494
14:25:16 <quicksilver> but you were asking if Storable should be derivable
14:25:17 <seydar> shachaf: same error as before
14:25:19 <scodil> so why can't GHC just pick one for me, arbitrarily?
14:25:28 <quicksilver> because some people would want the C layout
14:25:36 <scodil> well they can write their own instance
14:25:48 <shachaf> seydar: You seem to be calling it incorrectly.
14:25:54 * shachaf has to go now, sorry.
14:25:58 <seydar> shachaf: bwah?
14:25:59 <seydar> no!
14:26:06 <scodil> anyway, i guess that answers my question. "Storable driving? not anytime soon"
14:26:20 <quicksilver> I'm not the GHC team :)
14:26:23 <sarehu> $10 says what you'd have is somebody deriving a storable layout and having it work with the C interface on their computer, but having it not working elsewhere
14:26:46 <quicksilver> but I'd note that the GHC guys haven't added new non-trivial derivings for a hwile
14:26:54 <quicksilver> because with tools like Data.Derive and DrIFT
14:27:01 <quicksilver> such things don't float to the top of their list
14:27:25 <dons> and Data.Generics
14:27:32 <sorear> derivable types are an ugly hack, and GHC doesn't want to add them
14:27:36 <dons> we do a lot of stuff now with: Data a => MyClass a
14:27:51 <dons> where the generics reflect enough info to build your instance
14:28:07 <dons> several of the preprocessors use that stuff too, of course
14:28:07 <quicksilver> true although Generics is a boggling ugly interface :)
14:28:21 <quicksilver> my brane explodes every time I try to remember what FGZQmapQZ means
14:28:30 <quicksilver> but, it's powerful.
14:28:32 <dons> generally you dont' use the fully syb stuff
14:28:42 <dons> just the stuff to get the type name, constructor list, field list
14:28:49 <wli> I've never smoked out how to use the gmapQ etc. stuff.
14:29:25 <quicksilver> of course Binary is a bit like Storable, in some ways
14:29:36 <quicksilver> and Data.Derive dervies Binary instances rather nicely.
14:30:08 <sek> what function would i use to find the index of an element in a list?
14:30:21 <quicksilver> :t find
14:30:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:30:28 <quicksilver> :t elemIndex
14:30:29 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
14:30:34 <sek> that's the one, thanks
14:30:35 <quicksilver> that one, probably
14:30:44 <quicksilver> I can never remember the names :)
14:36:39 <grahamhutton> @seen andyjgill
14:36:39 <lambdabot> I saw andyjgill leaving #darcs, #haskell and #ghc 2d 17h 48m 40s ago, and .
14:47:49 <hpaste>  bos pasted "csv transposition in C" at http://hpaste.org/5495
14:48:41 <dons> mm
14:49:53 <bos> dons: that code is about 6 times faster than my little haskell version. it does a little less (doesn't build a map), but the map never showed up in the profile anyway.
14:51:16 <bos> hm, more like 8 times faster.
14:52:17 <piojo> hello. does anybody know whether a multi-parameter typeclass can be made to inherit from another class?
14:52:48 <mrd> class (Foo a) => Bar a b
14:53:12 <mrd> i think calling it inheritance is a bit of a misnomer
14:53:27 <piojo> will that make any "Bar x y" an instance of Foo?
14:54:06 <mrd> in order for you to write instance Bar x y, x must be an instance of Foo
14:54:42 <piojo> right, but that would not mean that the object "Bar x y" itself would be an instance of Foo
14:54:51 <mrd> what object?
14:55:04 <piojo> some object that is an instance of the mptc
14:55:09 <dons> bos, and it relies on destructifying the thing in place?
14:55:09 <mauke> objects aren't instances
14:55:11 <mauke> types are
14:55:18 <dons> i wonder how fast it would be if it was pure , yet still in C.
14:55:22 <mrd> Bar is a type-class
14:55:23 <piojo> oh. i guess that's true
14:55:25 <dons> copy, instead of overwrite
14:55:32 <mrd> really, this OOP terminology is just going to make things more confusing
14:55:35 <bos> dons: yes
14:55:43 <gwern> hm. this is odd behaivour in ghci. for anyone else, when you type in :load ~/bin/, and hit tab, does it complete based on stuff in ~/ and not ~/bin/?
14:55:46 <bos> dons: per my earlier description.
14:55:51 <dons> yep
14:56:24 <Botje> i've been thinking about ways to pimp ghci
14:56:29 <mrd> gwern: i see that in 6.6 too
14:56:29 <Botje> one of them would be typo correction
14:56:39 <piojo> mrd: i want a function that has the constraing "(Ord a) =>" on one of its arguments. is it possible for "a" here to be a member of a mptc?
14:56:43 <Botje> "you typed unsafeperformIO, did you mean unsafePerformIO?"
14:56:51 <gwern> mrd: interesting.
14:57:00 <gwern> does anyone have 6.4 handy? do you see it in there too?
14:57:02 <Zao> Botje: That could be annoying, if one expects to be able to type the next line of whatnot immediately.
14:57:04 <pgavin> has anyone been able to get ghc 6.8.2 to compile on Mac OS X 10.5?
14:57:13 <piojo> mrd: and by member, i mean instance
14:57:13 <Botje> Zao: configurable, of course :)
14:57:17 <mrd> piojo: foo :: (Ord a) => a -> ...
14:57:45 <Botje> and maybe a "function foo not found, but an instance is available in module Y. load it?"
14:58:05 <mrd> gwern: actually it's listing the current dir
14:58:09 <piojo> right, i know. and that's really straightforward if you end up calling "foo 5" or "foo 'c'". but what if i want to call "foo (Bar x y)"?
14:58:22 <mrd> piojo: that Bar is not a type-class, it's a constructor
14:58:31 <piojo> oops, i got mixed up
14:58:33 <gwern> mrd: ah, I just assumed it was listing the first directory and ignoring the rest
14:59:02 <rnorris> hi, here's my daily beginner question for tuesday: the API for binary i/o seems to require a Ptr (to a buffer) ... does this mean I have to use FFI if i want to do binary i/o?
14:59:03 <mrd> gwern: yea and that happened to be ~ in your case
14:59:16 <mrd> rnorris: which API?
14:59:30 <rnorris> eh .. System.IO .. the standard stuff i guess
14:59:39 <dons> rnorris: oh, use Data.Binary ?
15:00:07 <dons> rnorris: or, you can allocate an array, and get a pointer to it to fill, but Data.Binary and Data.ByteString will hide all that
15:00:36 <Botje> in the lambada paper (http://research.microsoft.com/~emeijer/Papers/Lambada.pdf) they refer to the Haskell module Dynamic "by the legendary hacker Lennart Augustsson", did he write a paper about it somewhere?
15:01:28 <rnorris> ok. thanks. i guess that's an add-on (Data.Binary)
15:01:35 <rnorris> don't see it in the standard lib
15:01:44 <dons> yep. you'll find it in the 'binary' package on hackage.haskell.org
15:01:50 <piojo> mrd: i think i get it. i cannot make the mptc (Bar x y) a subclass of Ord, but I could define instances of (Bar x y) to be in the Ord typeclass, and if i were defining "foo", i would write "foo :: (Bar a, Ord a) => a -> ...
15:01:50 <dons> along with 100s of other lovely libraries
15:01:51 <gwern> mrd: could be http://hackage.haskell.org/trac/ghc/ticket/998
15:02:01 <rnorris> great guys, thanks for your help as always
15:03:22 <mrd> piojo: no..
15:05:18 <mrd> piojo: you can definitely constrain x or y to be an instance of class Ord, in the MPTC definition
15:05:53 <mrd> I think it is best if you don't think of Type classes in OOP terms, because it's not OOP
15:06:10 <piojo> but there is no way for me to say "every instance of this (multi param) typeclass will also be of the Ord class"?
15:06:54 <piojo> mrd: i don't think i'm thinking in OOP. i'm just trying to think of constraints i can enforce so that i can ensure my arguments are sortable
15:07:22 <mrd> i don't think that even makes sense.  an instance of a typeclass, MPTC or not, declares that a type, or relation between types, is a member of said class.
15:07:39 * mrd wonders if he said that well
15:08:24 * mrd also wonders if perhaps you might be better off using type families instead of MPTC+fundeps presumably.
15:08:40 <piojo> type families... that's the 2nd time i've heard that phrase here
15:08:48 <piojo> are they extremely complicated?
15:08:56 <piojo> if not, i can probably learn them
15:09:05 <ddarius> Why would extremely complicated thing be added?
15:09:18 <mrd> no, they are in fact added to make life easier as opposed to using MPTCs and fundeps.
15:09:28 <piojo> oh, cool
15:09:37 <mrd> Manual wrote a nice wiki page for them, I think
15:10:20 <piojo> i found that page... i'll read about these and see if they meet my need
15:11:10 <bos> dons: i suspect that the haskell transpose code is just getting clobbered by the overhead of allocating so many bytestrings.
15:11:41 <dons> well, the foreign pointers for them, eh bos?
15:11:58 <dons> since they're just offset/len things. but for some reason the cons + Ptr list generation stuff feels very expensive
15:12:23 <piojo> thanks for your help. but if i could ask one more question, if i have a class Foo that is declared "class (Ord a) => Foo where"... and i have an instance of the class, "instance MyFoo foo where...", then will anything of MyFoo automatically be sortable? (without be having to describe the sort function in any additional place)
15:12:30 <bos> dons: yeah.
15:12:58 <piojo> i meant "instance Foo MyFoo where...", sorry
15:13:01 <mrd> piojo: what that says is "in order to write an instance of Foo ..., you must first write an instance of Ord ..."
15:13:05 <dons> i wonder if generating lazy bytestrings instead (element-strict lists, basically) would help
15:13:10 <mrd> s/write/have/
15:13:14 <dons> it'd give us a cost for the extra indirection
15:13:32 <bos> dons: using them for what? instead of the existing strict strings?
15:13:48 <dons> just to benchmark the cost of [ByteString] generation.
15:13:56 <mrd> piojo: now keep in mind, no values have type MyFoo
15:14:04 <dons> Chunk !ByteString (Chunk ..) is one indirection chaper
15:14:05 <mrd> piojo: because MyFoo is not a type
15:14:12 <piojo> mrd: it's not?
15:14:26 <bos> dons: lazy is about 25% slower than strict.
15:14:27 <piojo> i know i didn't define it here, but i'm assuming it is
15:14:28 <mrd> actually you used two different names there.  lets say class MyFoo.
15:14:34 <dons> that's interesting
15:14:39 <dons> so fully strict list generation?
15:14:41 <bos> 6.6 seconds, vs 5.0
15:15:00 <dons> so then, what if you generate Chunk x xs instead of x : xs ?
15:15:13 <dons> where the optimisations on Chunk might kick in (-O2 -funbox-strict-fields plz)
15:15:16 <bos> in the transposition code?
15:15:20 <dons> yeah
15:15:21 <mrd> piojo: class (Ord a) => MyFoo a where ...; instance MyFoo Int where ... -- instance Ord Int already exists so this is ok.
15:15:23 <bos> hmm.
15:15:58 <dons> Data/ByteString/Lazy/Internal/ByteString (Empty | Chunk x ByteString)
15:16:02 <mrd> piojo: class (Ord a) => MyFoo a; data MyType; instance MyFoo MyType -- no good, you haven't given an Ord instance of MyType
15:16:19 <dons> so yield a lazy bytestring who's chunks are each piece
15:17:26 <bos> dons: i don't really see how that makes much sense.
15:18:01 <piojo> mrd: okay, thank you. i need to think about this more. (i think i understand everything, but i will not know until i resume writing the program i was working on)
15:19:04 <dons> bos, well, they're similar, yet subtly different structures
15:19:32 <dons> Chunk !S.ByteString (Chunk ..) is quite a bit more amenable to optimisations
15:19:49 <dons> with the chunk unpacked in place, and a bit easier for spec constr to fire
15:20:04 <dons> less allocation.
15:20:31 <Cale> @version
15:20:31 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
15:20:31 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:20:54 <dons> hey guys, maybe we should vote in the linux applications of the year award
15:21:01 <bos> yes, but i can't see what effect that could have on transposition.
15:21:01 <dons> they've a "Best Language" category
15:21:07 <dons> and Haskell is nominated!
15:21:15 <davidL> link?
15:21:15 <lambdabot> davidL: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:21:21 * dons hunts
15:22:14 <dons> hmm. "window manager of the year" is seriously lacking.
15:22:57 <dozer> let's say I have: BTree a = Fork a a | Leaf
15:23:05 <dons> oh, seems to be a not terribly well known group running it
15:23:13 <dons> found via http://dannybuntu.blogspot.com/2008/02/exercise-your-right-to-vote-linux.html
15:23:16 <dozer> and some function that generates a BTree of a given uniform depth
15:23:51 <dozer> can I make this 'lazier' so that only part of the tree need be generated, if something only consumes bits of it?
15:25:11 <dons> yay, some people voting for xmonad :)
15:25:19 <Cale> dozer: Are you sure that's the type you have?
15:25:40 <dozer> Cale: actually, I'm sure it's not :)
15:26:22 <dozer> perhaps it's more like: BTree a = Fork (BTree a) (BTree a) | Leaf a
15:27:01 <Cale> Well, that's lazy, isn't it?
15:27:45 <dozer> I'm going to resort to pastebin
15:28:18 <ddarius> dons: There are probably more people in the fanbase of those other wms than are in the userbase of xmonad.
15:28:18 <Saizan> how you generate it can make the difference
15:29:11 <dons> ddarius: for some of them, yeah. xmonad's got some serious traction on Arch though, and pops up in some unlikely places.
15:29:29 <dons> i'm hopeful. the C based tiling wms are still moving much slower
15:30:45 <BMeph> dons: So, explain to a long-time Windows user, what's the big deal with window managers, to begin with? :)
15:31:18 <jsnx> BMeph: there are a few different styles
15:31:25 <ddarius> BMeph: Choice == good roughly
15:31:31 <dons> in general? you don't have to deal with the workflow some guy decided for you
15:31:38 <jsnx> basically, you only ever see one -- WIMP -- on windows
15:31:42 <ddarius> BMeph: If you want, you can choose a wm that behaves just like windows.
15:31:51 <shag> does a UTF8 encoded string of latin characters stored in a [Word8] consume less space than the same string as [Char]?
15:31:58 <dozer> http://pastebin.com/m3e76554e
15:32:03 <ddarius> shag: It shouldn't.
15:32:10 <shag> ddarius: why not?
15:32:17 <jsnx> shag: not if it is actually UTF-8
15:32:36 <jsnx> shag: because ASCII chars *are* UTF-8 chars
15:32:43 <idnar> I thought Char was 32-bit
15:32:54 <ddarius> shag: The Word8s will still take up a word in a list.
15:33:06 <jsnx> idnar: really?
15:33:11 <jsnx> crazy...
15:33:15 <shag> but isn't Char supposed to be wider than Word8?
15:33:20 <ddarius> If you compared UArray Char to UArray Word8 or something like that there should be a difference.
15:33:29 <jsnx> ddarius: should?
15:33:33 <mrd> haven't heard of unboxed lists
15:34:12 <dons> there'd be 4x the space used
15:34:15 <jsnx> mrd: ?
15:34:22 <dons> for UArray
15:34:45 <jsnx> oic
15:34:52 <dons> anyway, its easy to check. check the GC allocation stats for [1..bigN] :: [Word8] vs Char
15:34:56 <ddarius> shag: Except when unboxed, pretty much everything is word-sized with GHC.
15:35:19 <dcoutts_> every heap object is a multiple of the word size
15:35:33 <dcoutts_> Word8 is heap allocated, takes one word (ie 32 or 64bit)
15:35:40 <dcoutts_> plus one word overhead
15:35:42 <shag> hmmm ... so is there an easy way to make the Word8 in the list to be really just a byte?
15:36:00 <dcoutts_> shag: no, not to take up just one byte in the heap
15:36:12 <dcoutts_> it only holds numbers 0-255, though if that's what you mean
15:36:24 <dons> you'd have to use UArrays Word8, or some other flat byte array structure (e.g. ByteString...)
15:36:26 <ddarius> dcoutts_: What would happen with data Word8List = Nil | Cons !Word8 Word8List?
15:36:41 <ddarius> (with -funbox-strict-fields)
15:36:45 <dcoutts_> ddarius: it's still padded to be a word in size I think
15:37:10 <dcoutts_> there's no support for packed structures as far as I know
15:37:16 <ddarius> dcoutts_: That's what I thought, thanks.
15:37:17 <dons> ?src length
15:37:18 <lambdabot> Source not found. Maybe you made a typo?
15:37:21 <dons> huh
15:37:31 <dcoutts_> ddarius: note, in that example, it'd be the same in C due to the alignment of pointers
15:37:36 <shag> dons: well, i tried ByteStrings already, but as i have lots of small strings, this doesn't pay off
15:37:46 <ddarius> dcoutts_: Yeah
15:37:52 <dons> shag, in what way?
15:38:04 <dcoutts_> ddarius: struct { short x; void *p }
15:38:08 <dons> (as it sounds like you're duplicating type anyway)
15:38:37 <dcoutts_> ddarius: in principle you could have a {-# PACKED #-} pragma to use no padding for Word8/16 etc
15:39:07 <shag> dons: memory consumption. dcoutts once told me, that [Char] consumes less memory for strings of length 0-3 than a bytestring
15:39:28 <dcoutts_> I think they're exactly equal for length 3
15:39:43 <dcoutts_> as I recall
15:40:18 <dons> if they're that small, you might just store them in a static table
15:40:20 <dons> and share duplicates
15:40:32 <ddarius> Represent Word8 strings for lengths <= 3 by Words...
15:40:33 <dons> and use real bytestrings for larger ones
15:41:04 <shag> ddarius: i don't understand?
15:41:15 <ddarius> shag: That's probably best.
15:41:39 <ddarius> (As in, it's probably best that you don't understand.)
15:42:07 <dons> shag, did you pinpoint bytestrings as a memory problem?
15:44:07 <shag> dons: well, I replaced "String" with Data.ByteString.Lazy.Char8 and my program takes up more than twice as much memory as before ...
15:44:26 <dons> ok. what about small strict strings though?
15:44:46 <shag> small strict strings?
15:44:48 <dons> i think we've been assuming for small strings you're using Data.ByteString.Char8
15:45:21 <dcoutts_> there is only one word extra overhead to lazy bytestirng vs strict ones
15:45:54 <shag> no, i have been using [Char] up til now, and went to UTF8 encoded [Word8] now, but had to observe increased memory consumption
15:47:00 <dcoutts_> as you'd expect if you were using any non-ascii text
15:47:24 <shag> dcoutts: yes of course, but i am using just ascii text ...
15:48:05 <dcoutts_> ah, hmm, there's also an optimisation where the first 255 Chars are pre-allocated. I'm not sure if Word8 gets the same optimisation.
15:48:15 <dcoutts_> so that could well explain it
15:48:33 <dcoutts_> you'd observe a 7/5 increase in space
15:48:57 <shag> *calculating*
15:49:56 <BMeph> dons: Did you figure out a solution to BS's split taking up so much processing time in that CSV transpose problem?
15:50:01 <dcoutts_> hmm, perhaps I'm mis-counting
15:50:09 <shag> you mean, i've had 5/5 and now i have 7/5? or i should have 12/5 now?
15:50:14 <dcoutts_> [Char] is 3 words per character, because the Char is shared, [Word8] is 5 words per byte
15:50:35 <dcoutts_> so multiply by 5/3
15:50:51 <BMeph> At least, that's the last I heard of where the issues with it were; if you've since found otherwise, that'd be great.
15:51:17 <shag> no, my increase is quite small. from 248 MB to 270 MB
15:52:24 <shag> it's not that much, but i expected a decrease ...
15:52:44 <Japsu> @pl \(a,b) -> (b,a)
15:52:45 <lambdabot> uncurry (flip (,))
15:52:59 <Japsu> @hoogle (a,b) -> (b,a)
15:53:00 <lambdabot> No matches, try a more general search
15:53:06 <Japsu> @djinn (a,b) -> (b,a)
15:53:07 <lambdabot> f (a, b) = (b, a)
15:54:04 <BMeph> Japsu: Looking for "swap"? ;)
15:54:29 <dons> is hpaste.org up?
15:54:38 <dons> glguy: ^
15:55:03 <dons> dcoutts_: http://galois.com/~dons/tmp/A.hs
15:55:05 <dons> interesting.
15:55:15 <shachaf> BMeph: swap exists?
15:55:26 <dons> strict, specialised lists are a bit faster :)
15:55:45 <dons> specialised eftWord8 is a bit faster
15:55:52 <dons> bytestring unfoldrN is rather nice.
15:56:19 <Japsu> :t swap
15:56:28 <lambdabot> Not in scope: `swap'
15:56:33 <Japsu> @index swap
15:56:34 <lambdabot> bzzt
15:56:43 <BMeph> shachaf: If you look at Control.Arrow, you'll find it as a helper function. Other than that, though, it is not a declared/"official" function. It has a name, though. :)
15:57:06 <dcoutts_> dons: one less indirection when it's unpacked into the cons cell
15:57:14 <Japsu> it's not exported by my Control.Arrow :/
15:57:16 <dcoutts_> less/fewer
15:57:27 <dons> yes.
15:57:47 <BMeph> Japsu: It's not exported, nor is it a top-level definition. It's defined as a helper function only.
15:58:05 <BMeph> It's used in the definition of _second_, to be precise.
15:58:25 <shachaf> @ty uncurry (flip (,))
15:58:25 <lambdabot> forall b a. (a, b) -> (b, a)
15:58:43 <wy> Who said he is applying Chalmers?
15:58:51 <dons> dcoutts_: and the lists only work because they're lazy
15:58:56 <BMeph> @let swap = uncurry (flip (,))
15:59:01 <lambdabot> Defined.
15:59:16 <ddarius> :t snd &&& fsm
15:59:16 <lambdabot> Not in scope: `fsm'
15:59:18 <ddarius> :t snd &&& fst
15:59:18 <BMeph> :t (.swap)
15:59:19 <lambdabot> forall a b. (a, b) -> (b, a)
15:59:19 <lambdabot> Not in scope: `swap'
15:59:37 <shachaf> ddarius: I knew I was forgetting something. :-)
15:59:39 <dcoutts_> dons: how about with lazy bytestring? I'd expect it to be even faster due to less copying
15:59:40 <BMeph> :t (. L.swap)
15:59:40 <lambdabot> Couldn't find qualified module.
16:00:04 <shachaf> @hoogle (a,b) -> (a -> b -> c) -> c
16:00:10 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
16:00:10 <lambdabot> Data.Tuple.uncurry :: (a -> b -> c) -> (a, b) -> c
16:01:08 <shachaf> @ty uncurry . flip . curry $ id -- This definition is sort of nice anyway.
16:01:08 <lambdabot> forall a b. (b, a) -> (a, b)
16:01:53 <mrd> sounds like cooking instructions
16:02:24 <dons> dcoutts_: so for N=10000000, bytestrings are 11M, elem-strict lists are 400M and lazy lists are 560M
16:02:30 <dons> for Word8 elements
16:03:17 <dcoutts_> dons: hmm, I'd have expected more for the boxed list elements
16:03:17 <dons> interestingly, Int lists uses less memory..
16:03:24 <dons> than Word8 boxed lists
16:03:31 * dons suspects sneakiness
16:03:46 <ddarius> shachaf: flip = curry . (swap .) . uncurry so uncurry . flip . curry = uncurry . curry . (swap .) . uncurry . curry and uncurry . curry = id so we get (swap .)
16:06:09 <pastorn> @type swap
16:06:09 <lambdabot> Not in scope: `swap'
16:06:28 <pastorn> > swap (1,'a')
16:06:29 <lambdabot>  ('a',1)
16:06:40 <ddarius> :t curry (snd &&& fst)
16:06:40 <lambdabot> forall a b. a -> b -> (b, a)
16:06:41 <shachaf> @ty let swap (x,y) = (y,x) in curry . (swap .) . uncurry
16:06:41 <lambdabot> forall t t1 a b. (a -> b -> (t, t1)) -> a -> b -> (t1, t)
16:07:34 <ddarius> Yeah, I'm a bit off
16:09:07 <ddarius> :t let swap (x,y) = (y,x) in curry . swap . uncurry
16:09:09 <lambdabot>     Couldn't match expected type `(t, t1)'
16:09:09 <lambdabot>            against inferred type `(a, b) -> c'
16:09:09 <lambdabot>     In the second argument of `(.)', namely `uncurry'
16:09:19 <idnar> :t swap
16:09:20 <lambdabot> Not in scope: `swap'
16:09:41 <idnar> oh
16:10:19 <ddarius> :t let swap (x,y) = (y,x) in curry . (. swap) . uncurry
16:10:19 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:10:31 <ddarius> That's the second time I've done that in two days.
16:10:59 <mrd> is Cabal configure option --user going to still need 'install' to require root privs?
16:11:04 <idnar> :t let swap (x,y) = (y,x) in (. swap)
16:11:05 <lambdabot> forall c t t1. ((t1, t) -> c) -> (t, t1) -> c
16:11:26 <idnar> :t let swap (x,y) = (y,x) in (swap .)
16:11:27 <lambdabot> forall t t1 a. (a -> (t, t1)) -> a -> (t1, t)
16:13:07 <wy> Is Erlang a nice language?
16:13:46 <ddarius> wy: It depends on what you consider nice, but: sure.
16:14:22 <wy> ddarius: Haskell is kind of nice, but Common Lisp isn't that nice
16:15:02 <BMeph> wy: It's nice if you liked occam... ;)
16:15:30 <wy> I'm reading Chalmers' PhD position specification
16:15:41 <phlpp> @src map
16:15:41 <lambdabot> map _ []     = []
16:15:41 <lambdabot> map f (x:xs) = f x : map f xs
16:15:46 <wy> There are two kinds of work
16:15:46 <mrd> the main problem with erlang is the lack of static type system
16:16:02 <wy> 1. Development of the next generation of Paradox and Equinox
16:16:19 <wy> 2. Development of verification techniques for distributed systems implemented in the functional programming language Erlang.
16:17:07 <wy> They seem to be quite focused
16:18:21 <phlpp> > let m f = foldr (\x -> f x : xs) [] in m (*2) [1..5]
16:18:24 <lambdabot>   Not in scope: `xs'
16:19:05 <phlpp> > let m f (x:xs) = foldr (\x -> f x : xs) [] in m (*2) [1..5]
16:19:06 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `[a]'
16:19:39 <Cale> > let m f = foldr ((:) . f) [] in m (*2) [1..5]
16:19:40 <lambdabot>  [2,4,6,8,10]
16:20:00 <Cale> > let m f = foldr (\x xs -> f x : xs) [] in m (*2) [1..5]
16:20:05 <phlpp> ah
16:20:08 <phlpp> yeah.. oh dear
16:20:20 <phlpp> :t foldr
16:20:36 <phlpp> binary, of course
16:21:12 <wy> Where is the origin of the notion of information flow?
16:21:17 <Cale> The way to think of it is that foldr takes a replacement for (:) and a replacement for [], and rebuilds the list with them.
16:21:57 <Cale> I wonder why lambdabot just stopped responding.
16:22:24 <EvilTerran> @bot
16:22:25 <lambdabot> :)
16:22:32 <Cale> hmm
16:22:35 <Cale> > let m f = foldr (\x xs -> f x : xs) [] in m (*2) [1..5]
16:22:36 <lambdabot>  [2,4,6,8,10]
16:22:41 <Cale> odd
16:22:44 <phlpp> :D
16:22:49 <Cale> :t foldr
16:22:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:23:11 <Cale> > foldr (:) [] [1..]
16:23:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:23:25 <phlpp> hmm
16:23:36 <phlpp> > foldr (*2) [1..2]
16:23:37 <lambdabot>   add an instance declaration for (Num ([t] -> [t]))
16:23:40 <Cale> > foldr ((:) . (*2)) [] [1..10]
16:23:41 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
16:23:41 <phlpp> > foldr (*2) [] [1..2]
16:23:41 <shachaf> @go might be the reason?
16:23:43 <shachaf> @botsnake
16:23:51 <phlpp> > foldr (*2) [] [1..2]
16:23:56 <dmwit> > foldr (*2) 1 [1..2]
16:23:57 <phlpp> eh;
16:23:59 <mauke> dns timeout
16:24:00 <dmwit> bah
16:24:01 <BMeph> Cale: Does that come from the foldr/build fusion?
16:24:01 <lambdabot>   add an instance declaration for (Num ([a] -> [a]))
16:24:01 <lambdabot> :)
16:24:01 <Cale> (*2) doesn't have the right type
16:24:03 <lambdabot>   add an instance declaration for (Num ([a] -> [a]))
16:24:05 <lambdabot>   add an instance declaration for (Num (b -> b))
16:24:07 <lambdabot>     In the expression: 2
16:24:07 <phlpp> Cale: yah, sorry
16:24:09 <lambdabot>     In the expression: 2
16:24:12 <dmwit> > foldr (*) 2 [1..2] -- there we go
16:24:12 <lambdabot>  4
16:24:34 <Cale> BMeph: Does what?
16:24:56 <dmwit> BMeph: Fusion is a speed optimization... it does not affect answers.
16:26:04 <Cale> BMeph: you're perhaps wondering why  foldr (:) [] [1..] == [1..] ? Just remember that lazy evaluation is outermost first, and it'll make sense :)
16:26:04 <BMeph> Cale: That explanation you use for foldr. It soulds like it could be an explanation for how/why the foldr/build fusion rule goes how it does.
16:26:11 <Cale> Oh, I suppose.
16:26:33 <Cale> :t build
16:26:33 <lambdabot> Not in scope: `build'
16:26:51 <dmwit> It's more an explanation of catamorphisms, I guess.
16:27:19 <Cale> But you could do a similar trick whenever you have a catamorphism, I guess.
16:27:27 <ctkrohn> Hey, any recommendations for a database library?  I like the idea of HaskellDB (typesafe queries and all that), but documentation seems to be lacking
16:27:33 <ctkrohn> I was leaning towards HSQL... thoughts?
16:27:41 <dmwit> True enough.
16:27:47 <BMeph> Cale: Oh, no, that wasn't my point. It was that when I first saw your description of foldr as "it replaces (:) and [] with..." it reminded me of foldr/build.
16:28:07 <gwern> anyone know when 6.8.3 will be released?
16:28:11 <dmwit> BMeph: See also http://sigfpe.blogspot.com/2008/02/purely-functional-recursive-types-in.html ... I found that article pretty entertaining.
16:28:17 <BMeph> Well, it really reminded me of Voigtlaender's "super-build" stuff.
16:28:31 <Cale> gwern: Is there going to be a 6.8.3 or are we going straight to 6.10 now?
16:29:00 <gwern> Cale: http://hackage.haskell.org/trac/ghc/ticket/998 says its going to be merged in for 6.8.3
16:29:07 <gwern> it = bugfix
16:29:41 <BMeph> dmwit: Yeah, I'd say I'm never disappointed after reading a sigfpe blog post. :)
16:30:34 <gwern> Cale: and I don't know how a bugfix can be merged into .8.3 if it never gets released, so...
16:30:47 <soduko> how to parse cmd line args with parametrs? eg: cut -f 1 -d '|' getOptsseperates the lettered options and everything else as non options
16:30:54 <Cale> Yeah, so I suppose they do plan for that :)
16:31:27 <BMeph> For anyone who hasn't read it - or who hasn't read it lately, that paper I mentioned is here: wwwtcs.inf.tu-dresden.de/~voigt/p114-voigtlaender.pdf
16:33:27 <Cale> soduko: Maybe use the ArgOrder, (ReturnInOrder f) where f is something which will wrap up the non-option arg into something recognisable.
16:33:58 <soduko> actually i want it to be Permute..  the c program im trying to translate to haskell is very liberal with args
16:34:09 <glguy> dons: kakapo seems to be down, so hpaste is too
16:34:19 <shag> @pl (\k r -> r ++ (getLenghts r))
16:34:19 <lambdabot> const (ap (++) getLenghts)
16:34:44 <soduko> so for example makewff -f -f -f -f 3 3 7 -seed 0 -cnf is valid
16:35:00 <soduko> and it chooses the last valid option -cnf
16:35:04 <shag> @pl (\k r -> r ++ (getLenghts k))
16:35:04 <lambdabot> flip (++) . getLenghts
16:35:39 <soduko> with getOpt im forced to use -Char or --String type otions only
16:37:40 <soduko> isnt there a standard way to get the parms of the args?
16:38:10 <Cale> Well, you can do your own arg parsing
16:38:15 <soduko> i really want to avoid using getArgs and then manually parse everything
16:39:21 <soduko> is there an example implementation of teh unix cut utility? like dons' cat ?
16:40:23 <gwern> soduko: I have a kind of hacky one in HSH
16:40:41 <soduko> HSH ?
16:41:17 <gwern> soduko: it's a shellscripting library
16:41:46 <gwern> soduko: part of it is I took the'simple unix tools' page on the wiki and improved it, adding some 'cut's to it among other things
16:41:50 <soduko> gwern: then maybe you can help with my question. how do you handle -f and -d options to cut?
16:42:06 <gwern> the cuts aren't terribly greatm and they don't do option parsing, but I figured it was enough
16:42:12 <dcoutts_> -d translates into splitBy presumable
16:42:27 <dcoutts_> presumable/presumably
16:42:53 <wagle_home> <ijuz_> http://www.osnews.com/images/comics/wtfm.jpg
16:43:02 <soduko> yeah but how to get the char after -d ? looks like manual processing is required here.. would be great to have this in a library.
16:43:29 <gwern> soduko: -f I did via something stupid like returning 'map (!! input)'
16:43:45 <dcoutts_> soduko: GetOpt will do it I think
16:44:08 <dcoutts_> soduko: it'd be an opt with a required argument
16:44:41 <dcoutts_> then you check that the given string is only one char long
16:44:48 <gwern> hm. is hpaste down?
16:44:50 <soduko> dcoutts_: so how can i read the value provided by the user?
16:45:22 <dcoutts_> soduko: options can have arguments, you get the arg back as a string
16:46:54 <dcoutts_> Option ['d'] ["delimiter"] (ReqArg Delim "DELIM") "use DELIM instead of TAB for field delimiter"
16:47:23 <dcoutts_> where data Flags = Delim String | ...
16:47:26 <nelhage> `cut' is crap, implement `awk' instead ;)
16:47:33 <dcoutts_> heh heh
16:48:04 <nelhage> Or at least make it treat multiple adjacent delimiters as one.
16:48:10 <soduko> one setep at a time.. :)
16:48:12 <gwern> huh. hpaste is down!
16:48:29 <soduko> thanks dcoutts_ that helps .. i will try it out and post my story back :)
16:48:50 <gwern> soduko: http://pastebin.ca/893289
16:50:38 <gwern> soduko: as I said though, it's meant for use in the HSH library, and so isn't standlone as it were
17:25:38 <rnorris> trying to install Data.Binary ... configure is giving me: Setup.lhs: binary.cabal:22: Invalid syntax (no colon after field name)
17:25:47 <rnorris> do i need to upgrade something else
17:25:57 <allbery_b> cabal itself
17:26:15 <rnorris> ah. duh.
17:26:16 <rnorris> thanks
17:31:03 <matsmats> hello, can anyone tell me why i get "Instance of Floating Integer required for definition of fermatFactor'" with this code: http://pastebin.com/d71810637  ?
17:34:16 <istarex> On line 8
17:34:43 <istarex> it looks like a is typed Integer, so (a^2) -n is an integer
17:34:49 <istarex> so you can't take the sqrt of it :-)
17:35:19 <wli> ceiling . sqrt . fromIntegral
17:36:33 <EvilTerran> \x -> head $ dropWhile ((<x).(^2)) [0..]
17:36:41 <matsmats> istarex: ok im thinking..
17:37:34 <EvilTerran> i'd rather have O(rt n) than floating-point :P
17:38:37 <wli> Though a pure integer algorithm like snd . head . dropWhile (uncurry (/=)) $ let xs = iterate (\x -> (x + (n `div` x)) `div` 2) 1 in zip xs $ tail xs
17:39:09 <EvilTerran> > [(x,r*r) | x <- [0..], r <- ceiling . sqrt . fromIntegral $ x, x /= r*r]
17:39:10 <wli> might be nicer
17:39:14 <lambdabot>   add an instance declaration for (Integral [a])
17:39:45 <EvilTerran> > [(x,y) | x <- [0..], let y = (^2) . ceiling . sqrt . fromIntegral $ x, x /= y]
17:39:46 <lambdabot>  [(2,4),(3,4),(5,9),(6,9),(7,9),(8,9),(10,16),(11,16),(12,16),(13,16),(14,16)...
17:40:02 <EvilTerran> wait, never mind. i'm going away now.
17:40:31 <lQg> is hpaste down?
17:40:39 <EvilTerran> yes
17:40:46 <wli> Shame.
17:41:02 <lQg> i have a problem with overlapping case definitions
17:41:09 <EvilTerran> rafb.net/paste
17:41:14 <wli> Though I'm rather fond of bracketing intervals.
17:41:19 <istarex> Here's a question for everybody: I have ghc v6.6.1 installed on Ubuntu 7.10.  What command line arguments do I need to give to link a haskell program against Parsec?
17:41:35 <EvilTerran> istarex, try --make?
17:41:46 <istarex> What does --make do?
17:42:08 <EvilTerran> ... makes stuff like that work. not sure, really.
17:42:16 <istarex> well, it worked in this case
17:42:17 <istarex> thanks
17:42:31 <EvilTerran> http://haskell.org/ghc/docs/latest/html/users_guide/modes.html#make-mode
17:42:38 <mgsloan> yeah, why isn't make default behavior?
17:43:13 <lQg> http://rafb.net/p/kC3uvT79.html
17:43:24 <EvilTerran> people might be annoyed if ghc unexpectedly recompiled a dependency?
17:43:31 <mgsloan> mayhaps
17:43:37 <lQg> it is just a warning, but the function doesn't work properly
17:43:52 <mgsloan> IQg - yeah, i had this issue as well the other day
17:44:00 <wli> I think it does the right thing as it stands.
17:44:09 <EvilTerran> lQg, "case ... of foo -> ..." binds "foo" afresh, even if it's already in scope
17:44:28 <mgsloan> yeah, in "theEnd ->" is just like a pattern match
17:44:41 <mgsloan> it's like writing "f x = .."
17:44:42 <gwern> why is it --make and not -make?
17:44:44 <EvilTerran> > let foo = 1 in case 2 of foo -> "oops"; _ -> "it's broken"
17:44:45 <lambdabot>      Warning: Pattern match(es) are overlapped
17:44:45 <lambdabot>              In a case alterna...
17:44:52 <EvilTerran> > let foo = 1 in case 2 of foo -> "oops"
17:44:53 <lambdabot>  "oops"
17:45:08 <EvilTerran> you have to use == instead
17:45:11 <mgsloan> IQg - in other words, you can't use variables / functions for pattern matching on the left side of case expressions
17:45:22 <lQg> so how to solve?
17:45:27 <EvilTerran> "in if lolword == theWord then ... else ..."
17:45:39 <lQg> kk
17:45:46 <lQg> thanks
17:47:16 <EvilTerran> :)
17:47:50 <lQg> yay it works :) go if statements lol
17:49:21 <EvilTerran> consider if, say, the thing you were pattern-matching on was some abstract type that couldn't be compared for equality
17:49:47 <EvilTerran> if what you had worked, you could subvert this by having "x === y = case x of y -> True; _ -> False"
17:50:09 <EvilTerran> this would be bad. honest. :P
17:50:32 <lQg> i'm writing lBQ-G! a human speakable programming language, so as long as it holds together till I finish the first compiler it's all good
17:51:24 <lQg> yea the q is a vowel *shrugs*
17:51:50 * EvilTerran would pronounce that like a bad cough O.o
17:51:52 <shachaf> EvilTerran: Well, you'd want case to ues Eq.
17:52:14 <EvilTerran> shachaf, yeah... it already does for numbers, IIRC
17:52:17 <shachaf> EvilTerran: Isn't that what happens when you pattern-match numbers/
17:52:24 <shachaf> s/.$/?/
17:52:50 <EvilTerran> case x of 1 -> ... becomes case x of _ | x == fromInteger 1 -> ..., iirs
17:52:59 <Twey> Say... I read somewhere than n + k pattern matching is considered bad... why is that?
17:53:09 <chessguy> Twey, welcome :)
17:53:21 <EvilTerran> lQg, i wouldn't consider your human-speakable language having a non-human-speakable name to be the best start :P
17:53:59 <EvilTerran> interesting idea, tho. and on that note, i'm going to go to bed before i spew any more nonsens than i have already.
17:54:49 <Twey> chessguy: Heh, I've been here for weeks :-P
17:55:08 <wli> I guess I'd call such a language something like "plurisubharmonicity" or "residue" or some such.
17:55:16 <chessguy> Twey, but i haven't welcomed you yet :)
17:55:22 <Twey> Haha, oh.  Thank you :-P
17:55:42 <wli> Then again, I'm biased toward certain topics. ;)
17:55:47 <Twey> wli: It's based on Lojban, but with extra phonetic complexities, IIRC.
17:56:42 <wli> (/whois wli to see the bias toward said topics in more substantive action)
17:57:44 <istarex> How do you disable output buffering on a Handle?
17:58:27 <Twey> istarex: hSetBuffering handle NoBuffering
17:58:45 <Twey> (where handle is your handle)
17:58:53 <wli> No fair. I just got my nails done.
17:59:20 <Twey> wli: I just answered my first Haskell question
17:59:26 <wli> heh
17:59:35 <Twey> wli: You wouldn't have taken that away from me now, would you?  *big puppy eyes*
17:59:52 <shachaf> @faq
17:59:52 <lambdabot> The answer is: Yes! Haskell can do that.
17:59:56 <Twey> Haha
17:59:57 <wli> How are you going to parse spoken language?
18:00:12 <Twey> wli, it's designed to be computer-parseable
18:00:19 <Twey> wli: See http://www.lojban.org/
18:00:59 <wli> I had more in mind the speech recognition bits.
18:01:00 <wagle_home> translate "time flies like fruit flies."
18:01:23 <Twey> Ah
18:01:31 <Twey> Don't know if he was planning to do those
18:01:44 <Twey> Personally I'd just plug into Sphinx or something
18:01:53 <wli> How is it a spoken programming language, then?
18:03:25 <Twey> wli: Speaking purely in terms of Lojban, it's not: it's a constructed human language designed such that it can easily be parsed by computer
18:03:48 <Twey> It can thus be used as a programming language, interface language, or whatever
18:04:05 <Twey> < lQg> i'm writing lBQ-G! a human speakable programming language
18:04:08 <wli> That's maybe a little less exciting.
18:04:11 <Twey> speakable, not spoken :-)
18:04:23 <Twey> wli, viewpoints differ :-
18:04:24 <Twey> :-)**
18:04:32 <Twey> I think it's a brilliant idea, myself.
18:05:48 <lament> lojban is spoken in the same way that haskell is spoken, and a programming language the same way English is a programming language.
18:05:55 <lament> It's the best of both worlds!
18:06:52 <Chad> lament, I don't see that. lojban is designed to be unambiguous in its pronunciation. In a sense, it's more speakable than English
18:09:21 * Twey nods.
18:09:43 <Twey> It may work as a programming language, but that's not really what it's for
18:09:52 <siti> is haskell.org down?
18:09:54 <Twey> It's a human language before anything else
18:10:07 <Twey> siti: Seems so
18:10:13 <Chad> siti: I was just having trouble loading haskell.org too
18:10:15 <siti> nooooooo :(
18:10:17 <siti> ok
18:10:29 <Twey> I'm sure it'll be back soon
18:11:06 <Chad> One problem is semantics. Pronunciation and syntax are unambiguous, but semantics aren't
18:11:53 <Twey> True
18:12:02 <Twey> But that's a task for a good AI
18:12:22 <Twey> And outside the scope of the Lojban project
18:12:23 <allbery_b> yeh, vry much AI-complete
18:12:43 <lament> i think lojban is a very stupid idea
18:13:02 <lament> since it requires humans to act like computers
18:13:09 <lament> and they won't
18:13:09 <Twey> Hmm?  How?
18:13:14 <Twey> It doesn't
18:13:24 <lament> it does, by having its ultra-regular structure
18:13:27 <siti> I have not learnt it, but I have read a bit
18:13:29 <BMeph> wagle: The original is better - "Time flies like an arrow; fruit flies like a banana." ;)
18:13:36 <Twey> lament: How so?
18:13:37 <siti> and it does allow emotion expression etc
18:13:53 <Twey> Yes
18:14:00 <Twey> Moreso than English does, actually
18:14:03 <lament> Twey: if people actually used lojban, it would very quickly evolve to be much less regular and much more like other human languages.
18:14:15 <Twey> lament: Possibly
18:14:18 <siti> one issue, is people fsck languages up so quickly
18:14:20 <lament> because people are not gonna act like computers just because you tell them to.
18:14:35 <Twey> lament: But they will if they want to interface with computers
18:14:52 <allbery_b> there are some fairly well established that human languages evolve with use
18:15:25 <inimino> Twey: right, just like people write valid HTML
18:15:33 <allbery_b> vowel shifts, common words/concepts shortening (and tending toward irregularities)
18:15:37 * Twey shrugs.
18:15:52 <Twey> inimino: Even in an irregular form, it's a lot easier to parse than, say, English
18:15:57 <inimino> (just a joke)
18:16:09 <inimino> Twey: indeed
18:16:22 <Twey> inimino: And a lot easier to understand the regular form of Lojban to those who understand the irregular form
18:16:29 <Twey> allbery_b: True that
18:16:52 <Twey> But speakers of the irregular form will still understand the regular form, more or less
18:16:59 <bos> @seen dons
18:16:59 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 55m 53s ago.
18:17:02 <allbery_b> hm, my lack of sleep is showing.  "well established ways"
18:17:22 <Twey> Maybe in 400 years it will be as incomprehensible to them as Shakespearian English to us, but it's still an improvement
18:17:40 <Twey> And in that time we may well have surpassed the level of AI technology where it's necessary anyway.
18:17:43 <inimino> incomprehensible?
18:17:57 <Twey> inimino: My point exactly
18:18:06 <inimino> ok :-)
18:18:09 <Twey> :-)
18:20:40 <siti> we don't want skynet :(
18:20:56 <inimino> time travellers will save us
18:20:56 <Twey> Heheh
18:21:19 <siti> destroy haskell before programming gets to easy
18:21:20 <wli> Shakespearean/Elizabethan English is not incomprehensible.
18:22:07 <Twey> Haha
18:22:10 <Twey> wli: Indeed
18:22:33 <wolverian> wli, lies!
18:22:34 <tux_rocker> wli: I'm Dutch, English is not my native language, but I can read Shakespeare just fine
18:22:54 <tux_rocker> Chaucer gets really hard and Beowulf is incomprehensible :-)
18:22:59 <bos> i wonder where the overhead of small strict bytestrings lies.
18:23:04 <Twey> tux_rocker: Probably better than a native speaker, actually
18:24:28 <wy> Found out some of Amr Sabry's paper. quite impressed.
18:24:47 <Chad> bos: Isn't the overhead in allocating more space than is really needed?
18:24:49 <wagle_home> which one?
18:25:06 <wolverian> I think I just suck at reading plays. it doesn't make sense.
18:25:12 <wolverian> the poems are easier.
18:25:49 <wagle_home> wy, which one?
18:26:12 <wy> wagle: All those about monads and quantum computing
18:27:01 <wy> wagle_home: Those things seem to be really related with the deeeeep nature of the universe
18:27:32 <wy> I guess I should learn some string theory ;)
18:27:41 <dolio> He was in on A Monadic Framework for Delimited Continuations, too.
18:27:48 <dolio> And Delimited Dynamic Binding.
18:28:01 <dolio> Those are quality papers.
18:28:57 <dolio> Oh, and Backtracking, Interleaving and Terminating Monad Transformers.
18:29:26 <bos> Chad: no.
18:30:22 <bos> Chad: i'm guessing that in this case it has something to do with having millions of live references to a single pinned string in the heap. maybe.
18:30:24 <wy> dolio: What does delimited mean?
18:31:18 <BMeph> Does anyone know of any good tutorials on EDSL-crafting?
18:31:54 <bos> BMeph: there aren't any, really, but you could read hughes and wadler's papers on building pretty printers.
18:32:14 <wagle_home> cool
18:32:22 <BMeph> bos: Hmm, intrtiguing. Thanks.
18:33:01 <dolio> wy: You know regular continuations?
18:33:36 <wy> dolio: yes.
18:34:18 <dolio> Well, delimited continuations let you place markers, so that you can capture the continuation up to that marker, instead of the entire rest of the continuation.
18:35:51 <wy> dolio: got it. sounds cool. I had been wondering about this
18:37:25 <dolio> So, like, 'reset (forM l (\e -> shift (\k -> return (e,k)))) -- pseudo code' ...
18:38:10 <wy> dolio: Does it need special compiler support?
18:38:56 <dolio> That turns into a loop (forM l) into a cursor, with e the current element, and call k to get the cursor for the next element.
18:39:34 <dolio> wy: Well, as the one paper suggests, you can make a monad in Haskell that gives you delimited continuations.
18:40:13 <dolio> There's a library on hackage based on that paper. CC-delcont.
18:40:25 <wy> dolio: I should check that out. thanks
18:41:09 <dolio> No problem.
18:43:48 <wy> I guess it's really a good idea to go to Indiana. I guess I can learn a lot there :)
18:45:32 * wli does not regard Indiana as a good place to live.
18:45:48 <wagle_home> wy, nice place in bloomington
18:45:55 <dolio> Cheaper liquor.
18:46:10 <wagle_home> wli..  thats because you live in west lafayette
18:46:21 <wli> Bloomington is not as bad as the rest of the state, but you're still surrounded by corn fields.
18:46:26 <wy> wagle_home: and I found a lot more parking lot than that of cornell :)
18:46:45 <wli> wagle: Like I've never been to Bloomington.
18:46:53 <wy> wli: Are corn fields bad?
18:47:06 <wli> wy: I'd say so.
18:47:12 <dolio> They aren't very interesting.
18:47:31 <wy> dolio: so that's the only reason you don't like them?
18:48:43 <ac> is there a definition for "isJust . find"?
18:48:58 <dolio> As far as extracurricular activities in college go, that's a significant factor.
18:49:02 <wli> ac: elem
18:50:11 <wy> dolio: hmmm... Maybe I'll start to think about that after arriving at IU, but now, no, I don't have a life ;)
18:50:33 <ac> er, that would be "(isJust .) . find" :-P
18:50:42 <dolio> I don't know what IU is like, actually.
18:50:51 <wli> ac: elem
18:50:59 <dolio> I did visit Rose-Hulman, though, and that place is in the middle of corn fields. :)
18:51:00 <wy> dolio: hehe. I just looked up virtual earth
18:52:32 <wy> dolio: what does corn fields look like from satellite?
18:54:32 <wy> I'm really impressed by its parking lots
18:54:59 <wy> I guess everybody drive to work there
18:58:39 <wy> dolio: where are you then?
18:59:11 <dolio> For college? I went to Case Western Reserve University.
18:59:29 <dolio> Right in the middle of East Cleveland. Much more interesting. :)
19:00:50 <wy> dolio: why? you have water?
19:02:01 <dolio> Well, there is the river, which was once set on fire.
19:02:44 <dolio> East Cleveland isn't exactly the nice part of town, either.
19:03:12 * BMeph was born in Indiana.
19:03:47 <dolio> That was more of a joke. You could probably find a more exciting place to go to school than Case.
19:03:52 <dolio> Somewhere in Boston, for instance.
19:04:14 <wy> BMeph: Is there tornados?
19:04:36 <BMeph> wy: What, here? I live in an Diego. ;)
19:04:42 <BMeph> San*
19:05:12 <wy> BMeph: I mean Indianna
19:05:42 <BMeph> I was born in Indiana, but my parents left when I was about six weeks old (dad in the military). :)
19:06:54 <BMeph> I have a cousin who went to IU, but he went on a football scholarship, so I can tell you some about their athletics, but not much else. :)
19:07:50 <dmwit> ?go time
19:08:11 <lambdabot> Plugin `search' failed with: getHostByName: does not exist (no such host entry)
19:09:24 <LoganCapaldo> GIve me back my hosts!
19:11:40 <wy> BMeph: I heard they are good at football
19:12:21 <BMeph> They were when my cousin was there... ;)
19:15:00 <wy> BMeph: coool~ so I will have some fun sometimes
19:16:21 <wy> They have Daniel Friedman, Ken Dybvig, and Amr Sabry, and they make the fastest Scheme compiler. I was really a fool that I did go there
19:16:32 <wy> didn't
19:16:44 <BMeph> wy: You're in #haskell. You'll ALWAYS have fun! ;)
19:17:09 <wy> BMeph: not when the school starts. I'm really really really stupified
19:18:09 <wy> BMeph: Not now, because I'm out ;)
19:18:29 <BMeph> wy: And ddarius is actually comfortable with concepts like adjoint functors. Trust me, #haskell is even more fun, when you're in school. :)
19:19:07 <wy> BMeph: oh you mean I'm not fun?
19:20:15 <BMeph> wy: Sure you are. But when you're freaking out about a problem, and someone spends about an hour-and-a-half explaining the concept to you, so you really "get it," then you'll see some fun. ;)
19:21:02 <wy> BMeph: I did this many times ;)
19:21:11 <wy> in the winter :)
19:22:02 <BMeph> Ah, so you know...excellent! :)
19:22:12 <wy> I would acknowledge #haskell in my personal statement :)
19:22:18 * ddarius should try going to school sometime.
19:22:43 <dons> http://reddit.com/r/programming/info/67szi/comments/ Higher order Quines: Haskell ¬í Python ¬í Ruby ¬í Haskell (sigfpe.blogspot.com)
19:22:50 <wy> ddarius: how did you type such sentences?
19:22:57 <ddarius>  /me foobars
19:23:20 <dons> sigfpe rocks
19:23:25 * wy learned how to do it
19:23:44 <wy> What does sigfpe mean?
19:23:45 <dons> that's a 3rd order quine: haskell outputs python, which outputs ruby, which outputs hte original haskell program
19:25:21 <ddarius> Signal floating point exception
19:26:14 <wy> ddarius: ah!
19:26:59 * ddarius leaves the mess he has wrought to dons.
19:27:21 <wy> I think I'd better look again at metaprogramming of Scheme. It seems something is in there.
19:31:16 <glen_quagmire> :t (=)
19:31:18 <lambdabot> parse error on input `='
19:32:03 <wagle_home> :t (==)
19:32:04 <lambdabot> forall a. (Eq a) => a -> a -> Bool
19:32:19 <glen_quagmire> what should be  the type of (=) using template haskell?
19:34:34 <LoganCapaldo> that seems hard
19:35:03 <ddarius> = is part of the concrete syntax, the actual thing is a function declaration ast
19:35:21 <LoganCapaldo> Like how would you come up with teh tpye of = in something like x :: (Num a) => a ; x = 3
19:38:07 <LoganCapaldo> unless you want to make it something boring like (=) :: Pattern -> Expr -> Binding
19:40:23 <glen_quagmire> (=) is not a normal function. it's a meta-function. it's run during compilation only.
19:40:44 <glen_quagmire> i patent the term 'meta-function'
19:41:12 <glen_quagmire> meta-functions are syntactic entry point for generating AST
19:41:14 <LoganCapaldo> it's not a function or meta-function
19:41:19 <LoganCapaldo> its syntactic artifact
19:41:43 <glen_quagmire> i patent the term 'syntactic-artifact' too
19:41:47 <wagle_home> Results 1 - 10 of about 4,680 for 'meta-function'. (0.25 seconds)
19:42:02 <LoganCapaldo> oh good
19:42:07 <ddarius> @google shtnaeou
19:42:07 <lambdabot> No Result Found.
19:42:22 <wagle_home> Results 1 - 10 of about 67 for 'syntactic-artifact'. (0.15 seconds)
19:42:25 * LoganCapaldo google bombs shtnaeou
19:43:20 <LoganCapaldo> Sounds like a kind of wine
19:43:35 <glen_quagmire> so, haskell doesn't allow me to have chinese character as function name, constructor name
19:44:04 <glen_quagmire> because chinses character doesn't have uppercase, it can't be data constructor name
19:44:27 <LoganCapaldo> Stick a colon in front of it
19:44:31 <glen_quagmire> it would be weird if all keywords in haskell are chinese
19:44:35 <LoganCapaldo> colons are uppercase
19:44:56 <glen_quagmire> > data :abc = :abc
19:44:57 <lambdabot>  Parse error at "data" (column 1)
19:44:58 <dons> glen_quagmire: hmm. http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
19:44:58 <lambdabot> Title: blog.kfish.org: Survey: Haskell Unicode support
19:45:00 <wagle_home> in japanese could make kanji uppercase and the gani lower
19:45:01 <dons> glen_quagmire: might be useful
19:45:16 <glen_quagmire> reddit goodness!
19:45:37 <wagle_home> kana
19:46:04 <gwern> we need a new slogan. "if it's not on Hackage, it doesn't exist"
19:46:27 * wagle_home disappears in a poof
19:46:27 <glguy> ignorance is bliss?
19:46:47 <dons> gwern, :) good work getting stuff on hackage, btw.
19:46:55 <dons> we could upload frag now, couldn't we?
19:47:18 <dons> glguy: want to test if frag builds? $ darcs get http://code.haskell.org/frag
19:47:19 <lambdabot> Title: Index of /frag
19:47:32 <gwern> dons: absolutely, as long as you don't mind that bot thing I pointed out
19:47:36 <dons> sure.
19:47:42 <dons> glguy: check this out, http://sigfpe.blogspot.com/2008/02/third-order-quine-in-three-languages.html
19:47:43 <lambdabot> Title: A Neighborhood of Infinity: A Third Order Quine in Three Languages, http://tinyurl.com/yudlkm
19:48:17 <gwern> dons: I checked installing and running from sdist, so it should just be a matter of punching a few buttons. at least in the trademarked slogan, Works For Me! (tm)
19:48:58 <dons> you've checked against the versoin currently on code.haskell.org?
19:49:32 <gwern> mm? no, against my repo when I sent off the patches, I think
19:49:55 <dons> ok. i'd double check then against above repo.
19:50:55 <gwern> what's the extension for a ruby file?
19:51:04 <gwern> (actually, wait, do I even have ruby installed?)
19:51:19 * ddarius doesn't know if he has ruby installed.
19:51:24 * gwern does it seems
19:52:44 <gwern> dons: yes, it seems to sdist fine, compile from sdist, and then run from installed files. although that haddock error mystifies me
19:54:06 <gwern> one 'runhaskell tmp.hs > foo.py && python foo.py > foo && ruby foo' later... well, I'll be damned. it *is* a third-order quine. how the hell does sigfpe do the things he does?
19:54:42 <LoganCapaldo> .rb btw
19:54:58 <gwern> LoganCapaldo: it seems 'ruby' isn't picky about extensions
19:55:09 <ddarius> Is any compiler?
19:55:09 <Nafai> gwern: btw, this works too: runhaskell testit.hs | python | ruby
19:55:14 <LoganCapaldo> neither is python or perl generally
19:55:23 <LoganCapaldo> gcc can be
19:55:32 <Nafai> Where testit.hs is the name of the original hs file
19:55:43 <gwern> Nafai: ah, that's even better. I didn't know those interpreters would work on stdin
19:55:46 <LoganCapaldo> but that's because it uses teh extension to guess which compiler to use
19:56:01 <Nafai> gwern: I just kind of guessed, wasn't sure it would work :)
19:56:08 <dons> Nafai: oh, awesome.
19:56:20 <ddarius> LoganCapaldo: Well when we have the Ruby Interpreter Collection, ruby will be a bit more picky too.
19:57:11 <dons> makes me thing runhaskell should read from stdin
19:57:16 <LoganCapaldo> ddarius: you asked, I just pointed out the first example that came to mind, GCC does have good reason though
19:57:20 <dons> runhaskell A.hs | python2.4 | ruby | runhaskell | ...
19:57:22 <dons> would work then.
19:57:31 <LoganCapaldo> dons: it doesn't?
19:57:31 <Nafai> dons: Yeah, I tried that unsuccessfully :)
19:57:35 <LoganCapaldo> that makes me sad
19:57:43 <ddarius> LoganCapaldo: Fix it!
19:57:53 <LoganCapaldo> maybe I will
19:57:56 <LoganCapaldo> seriosuly
19:58:07 <LoganCapaldo> but tomorrow
19:58:08 <dons> we can fix this.
19:58:14 <LoganCapaldo> cause I'm going to bed now
19:58:20 <dons> get some more upmods on this, http://reddit.com/r/programming/info/67szi/comments
19:58:23 <gwern> 'We can rebuild him. We have the technology!'
19:58:29 <dons> its ludicrously cool. how sad that it gets so many downmods
19:58:50 * dons patches runhaskell.hs
19:58:53 <ddarius> quines are boring
19:59:29 <gwern> quines are a classic of geekery though, going back to ''Godel, Escher, Bach''
20:00:00 <dons> current runhaskell.hs
20:00:03 <dons> doIt ghc args = do
20:00:03 <dons>     let (ghc_args, rest) = getGhcArgs args
20:00:03 <dons>     case rest of
20:00:03 <dons>         [] -> dieProg usage -- read from stdin.
20:00:05 <dons>         filename : prog_args -> do
20:00:07 <dons> easy to fix..
20:00:35 <gwern> ' [] -> dieProg usage -- read from stdin.' <-- what brilliance
20:00:55 <dons> i added that comment, actually
20:00:57 <dons> just then
20:00:59 <gwern> with friends like these... ah, but I'm hardly one to talk
20:01:01 <Nafai> :)
20:09:20 <dons> $ runghc A.hs | python2.4 | ruby | runghc
20:09:20 <dons> def q(a,b,c):print b+chr(10)+'q('+repr(b)+','+repr(c)+','+repr(a)+')'
20:09:22 <dons> :)
20:09:24 <dons> we're in business
20:10:28 * dons darcs records
20:10:51 <Nafai> dons: woot!
20:11:11 <monochrom> What does A.hs produce?
20:11:30 * Tac-Tics couldn't get the superquine to work =-(
20:11:43 <dons> monochrom: a python program
20:11:47 <dons> that prints a ruby program
20:11:51 <dons> that prints the original haskell program
20:12:01 <dons> see http://reddit.com/r/programming/info/67szi/comments
20:12:09 <monochrom> This is deep magic.
20:12:32 <Tac-Tics> Is an inter-language quine an easily constructed object?
20:13:06 <dons> i don't think so.
20:13:10 <Tac-Tics> It might be fun to write a program which allows you to input a series of languages where it can produce a multi-quine like that
20:13:20 <Tac-Tics> if there was some standard formula for creating them
20:13:22 <monochrom> I should study this and write a paper that derives the program from specification.
20:13:45 <monochrom> It will be started in year 2011.
20:13:47 <araujo> where is the source of A.hs ?
20:13:57 <monochrom> That is, after I finish writing Space Age Haskell.
20:14:17 <Tac-Tics> araujo: check ou tthe reddit link. It's on sigfpe's blog
20:14:28 <monochrom> The reddit link has a link to sigfpe's blog that has the program text that prints...
20:14:37 <Nafai> dons: I just added a comment about your check-in on reddit
20:14:42 <dons> hehe
20:15:03 <monochrom> Hrm, the story would be complete if sigfpe's blog post has a link to the reddit entry!
20:15:23 <araujo> thanks
20:16:58 <Tac-Tics> monochrom: wouldn't it be more appropriate if when you ran ghc on the source code of the blog page, it gave you a riddle in portuguese whose solution is a question whose answer is the url of a page which has a link that points to the comment page?
20:17:54 <monochrom> But ghc doesn't output riddles in portugese. It only outputs riddles in asm or machine code or core.
20:18:17 <monochrom> Perhaps you can make use of the core.
20:18:25 <Tac-Tics> monochrom, oh, sorry. I will send you a patch I wrote for the portuguese riddle backend
20:18:46 <monochrom> The distances between successive #'s encodes a message. dons knows how to make sure #'s appear at the right places.
20:22:13 <dons> the patch, and a patched runhaskell.hs are here, http://galois.com/~dons/tmp/runghc.hs and http://galois.com/~dons/tmp/runhaskell-stdin.patch
20:22:31 <dons> if you want to do this: $ cat A.hs | runghc | python2.4| ruby | runghc | python2.4 | ruby
20:23:12 <bos> dons: i spent a bit of time looking at the performance of split again. i can't see where the sloth is coming from. it's using plain pinned memory, not something with a finalizer.
20:23:40 <bos> so there's just one ForeignPtr pointing to a single big pinned chunk of memory.
20:24:07 <bos> and about ten million references to that o_O
20:24:11 <dons> hmm
20:24:19 <dons> right.
20:24:28 <dons> ten million cons nodes
20:24:40 <dons> oh, it does reuse the ForeignPtr too, I see, yes.
20:25:52 <bos> it's a fascinating little microbenchmark.
20:26:02 <dons> hmm. yes. very curious
20:26:05 <bos> too damn tempting and shiny by half.
20:26:39 <dons> so the transpose actually does what? no buffer copying, just list node flipping?
20:26:47 <bos> right.
20:26:56 <bos> it's just the normal Data.List.transpose.
20:26:56 <dons> and split itself is seems slow, generating this huge list.
20:26:58 <dons> yep
20:27:26 <bos> yes, split is the point o' pain.
20:28:36 <bos> i'm trying to encourage my 2-year-old to go to sleep, and he's lying in bed making cartoon snoring noises.
20:28:41 <bos> hmph.
20:28:49 <dons> hehe
20:28:55 <dons> Nafai: for you, http://www.haskell.org/pipermail/cvs-ghc/2008-February/041010.html
20:28:56 <lambdabot> Title: Darcs patch: let runghc.hs read from stdin if no file is provided, http://tinyurl.com/29asus
20:30:34 <Nafai> dons: w00t!
20:38:31 <monochrom> You should let your child watch Haskell cartoons, and only Haskell cartoons. Hopefully he/she will only make monadic noise.
20:39:13 <dmwit> Now you're just making stuff up.
20:39:45 <monochrom> Cartoons are made up too.
20:42:10 <dmwit> Well, in the spirit of pedantry, cartoons are actually videos of things that are made up.
20:42:17 <dmwit> The cartoons themselves are plenty real.
20:43:46 <monochrom> After something is made up, it becomes real.
20:44:13 <gwern> what about cgi cartoons? hand-drawn ones are increasingly rare
20:44:32 <monochrom> Haha, in five sentences this will degenerate into "is Haskell discovered or invented".
20:45:46 * gwern asserts chess was invented, but go was discovered!
20:45:46 <dmwit> No, I have a secret weapon: the pun.
20:46:03 <gwern> er. I mean, C was invented but the lambda cube was discovered!
20:46:11 <dons> wasn't haskell dug up on the moon?
20:46:14 <dmwit> CGI cartoons don't have any session state, and they're upgrading to fastCGI anyway.
20:47:52 <shachaf> Is Haskell discovered or invented?
20:47:58 * shachaf hopes he counted correctly.
20:48:05 <dons> Haskell was a lambda anomaly unearthed on the moon near Tycho Crater
20:48:08 <dons> so it was discovered
20:48:14 <shachaf> It depends on what you mean by "sentence", I guess.
20:48:19 * shachaf was discovered.
20:48:40 <thetallguy> dons: ???  The last moon shot was...
20:48:51 <dons> it was left behind to promote the development of the human brain
20:48:55 <thetallguy> dons: which means Haskell is much older than we thought.
20:49:07 <dons> http://en.wikipedia.org/wiki/The_Monolith :)
20:49:08 <lambdabot> Title: The Monolith - Wikipedia, the free encyclopedia
20:49:19 <thetallguy> dons: oh, so Haskell is 1 x 4 x 9?
20:49:22 <dons> yep
20:49:38 <thetallguy> dons: Never would have guessed.
20:49:39 <dons> but definitely advanced alien technological artifacts
20:49:49 <dons> if we can master its powers, the universe is ours
20:50:00 <dibblego> ?hoogle Either a a -> a
20:50:01 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
20:50:01 <lambdabot> Data.Either.either :: (a -> c) -> (b -> c) -> Either a b -> c
20:50:03 <thetallguy> Of course that means, Haskell is full of stars.
20:52:02 <zarvok> I have a haskell question
20:52:13 <zarvok> I just hpasted this thing: http://hpaste.org/5496
20:52:31 <monochrom> @remember thetallguy oh, so Haskell is 1 x 4 x 9?
20:52:31 <lambdabot> I will never forget.
20:52:45 <zarvok> where using gadts and existentials, I can get different results if I :load a file containing a line, or just copy the line into ghci
20:52:54 <zarvok> (one typechecks and one doesn't)
20:53:02 <zarvok> I'd love if someone could have a look
20:53:13 <zarvok> perhaps this is a known bug, or perhaps it's not a bug at all
20:54:12 <zarvok> the type error I get indicates that an existential type is escaping, but in fact the type should have been completely determined by gadt refinement, so nothing escapes
20:54:36 <monochrom> If Haskell is 1x4x9, shouldn't it be saying something like: you may explore the lambda cube freely, but don't near dependent typing?
20:54:45 <dmwit> zarvok: I do not get a type error at the prompt.
20:54:53 <dmwit> (In ghci 6.6.1.)
20:54:57 <monochrom> s/near/go near/
20:54:58 <zarvok> strange
20:55:01 <thetallguy> zarkov: nor I, ghc 6.8.2
20:55:01 <zarvok> in 6.8.2, I do
20:55:04 <thetallguy> :t weird2
20:55:04 <thetallguy> weird2 :: ExpGADT Int
20:55:13 <zarvok> very strange indeed
20:55:15 <lambdabot> Not in scope: `weird2'
20:55:34 <dmwit> zarvok: May I recommend trying again. =P
20:55:40 <zarvok> I definitely get the error, and on two different computers
20:55:43 <zarvok> three, in fact
20:55:49 <thetallguy> Odd.
20:56:10 <dmwit> very
20:56:23 <thetallguy> what options do you have set?
20:56:33 <zarvok> in all three cases, I've installed the generic linux binary tarball from the ghc site
20:56:38 <thetallguy> anything other than the OPTIONS_GHC at the top?
20:56:41 <zarvok> nope
20:56:58 <zarvok> I think I'll try the HEAD version and see what happens
20:56:59 <thetallguy> Gamma rays?
20:57:19 <dmwit> You don't have it set to show the value of each let binding, do you?
20:57:37 <dmwit> (That would probably fail, since ExpGADT Int isn't in Show.)
20:57:37 <thetallguy> monochrom: :-)
20:57:41 <zarvok> not sure, but it's not a Show error
20:57:53 <zarvok> and the original case where I had this error was in Show
20:58:10 <zarvok> no, I don't have it set to do that, in fact
20:58:38 <zarvok> well, thanks for checking, I'll try a newer GHC and see what happens
21:19:59 <adu> how is House comming along?
21:21:02 <Nafai> dons: around?
21:25:56 <dynamix> what is the haskell equivalent of isalnum()?
21:26:05 <dons> Nafai: yo
21:26:11 <dons> dynamix: isAlphaNum
21:26:21 <dons> adu, research continues.
21:26:26 <dynamix> bascially i just want to test if a string is readable as an Int
21:26:32 <dons> oh, try to read it
21:26:43 <dons> and catch failure
21:26:48 <adu> dons: can I help?
21:26:51 <dynamix> as a guard in a function,
21:26:51 <Nafai> dons: In your reply to my reddit comment, a fixed point combinator is equivalent to . in Haskell, right?
21:27:01 <dons> Nafai: no, 'fix'
21:27:03 <dons> > fix (1:)
21:27:06 <Gnezdo> dons: any way to catch that without IO monad?
21:27:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:27:21 <monochrom> fixed point combinator :) :) :)
21:27:32 <monochrom> That's the decimal point combinator! :)
21:27:36 <dons> Gnezdo: just purely functional catching :)
21:27:38 <dons> case reads c of [(x,_)] -> return $ Just x _       -> return   Nothing
21:27:41 <Nafai> What does it do?
21:27:48 <dynamix> dons: im tryign to translate a very liberal C program and want to preserve the freedom it gives teh user in the Haskell version too
21:27:55 <adu> > :t fix
21:28:04 <monochrom> "fix" is for anonymous recursion.
21:28:04 <lambdabot>   parse error on input `:'
21:28:14 <adu> oops
21:28:18 <Gnezdo> dons: thanks! I just needed that
21:28:27 <dons> ?let isInt s = case reads s of [(x,_)] -> Just (x::Integer) ; _ -> Nothing
21:28:39 <zarvok> strange... I just built the HEAD version of GHC and I'l still getting that type error I was talking about
21:28:39 <lambdabot> Defined.
21:28:41 <dons> > isInt "1234"
21:28:41 <monochrom> Everytime you write "g = ...g...", you may as well write "g = fix (\g -> ...g...)". But you now see new opportunities.
21:28:42 <lambdabot>  Just 1234
21:28:45 <dons> > isInt "1234.0"
21:28:46 <lambdabot>  Nothing
21:28:58 <dons> > isInt "0xdeadbeef"
21:28:58 <lambdabot>  Just 3735928559
21:29:03 <adu> > toRational pi
21:29:03 <dons> > isInt "0xdeadpython"
21:29:03 <lambdabot>  Just 57005
21:29:04 <lambdabot>  884279719003555%281474976710656
21:29:09 <dons> hmm?
21:29:11 <dons> ah yes
21:29:24 <dons> ?let isInt s = case reads s of [(x,[])] -> Just (x::Integer) ; _ -> Nothing
21:29:24 <lambdabot> <local>:2:0:     Warning: Pattern match(es) are overlapped              In th...
21:29:27 <dons> ?undefine
21:29:28 <lambdabot> Undefined.
21:29:29 <dons> ?let isInt s = case reads s of [(x,[])] -> Just (x::Integer) ; _ -> Nothing
21:29:30 <lambdabot> Defined.
21:29:33 <dons> > isInt "0xdeadpython"
21:29:34 <lambdabot>  Nothing
21:29:37 <dons> > isInt "0xdead"
21:29:38 <lambdabot>  Just 57005
21:30:03 <dynamix> dons: please look at http://hpaste.org/5497#a1
21:30:38 <dons> dynamix: so yes, use the above isInt, (which wraps 'reads' ) rather than 'read'
21:30:38 <dynamix> > isInt "1234"
21:30:39 <lambdabot>  Just 1234
21:31:01 <dons> maybeRead, you might call it
21:31:07 * wli stands by the position that wealth creation is utter horseshit (along with much of orthodox economics).
21:31:46 <LeCamarade> dons: But since read :: String -> a goes to the Bottom when it fails to parse, how does isInt trap the bottom?
21:32:00 <dons> :t reads
21:32:01 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:32:07 <dons> it's using reads, not read
21:32:09 <adu> :t fix
21:32:09 <lambdabot> forall a. (a -> a) -> a
21:32:14 <dons>   case reads s of [(x,[])] -> Just (x::Integer) ; _ -> Nothing
21:32:21 <LeCamarade> Ah.
21:34:08 <Gnezdo> when I'm using those records with named fields, is there a way to use them as "lvalue" ?
21:34:10 <dons> read shouldn't fail, really. its a common newbie problem
21:34:46 <LeCamarade> No function should bottomp
21:34:49 <LeCamarade> .
21:35:02 <dons> Gnezdo: well, the record names are also accessors to the structure
21:35:09 <LeCamarade> I hate bottom, because it is a dynamic case _I can't handle_.
21:35:26 <LeCamarade> undefined, that is. Can't do nothing about forever.
21:35:40 <Gnezdo> dons: they are of type (O -> FieldType), right?
21:36:06 <Gnezdo> so, if I want something like : setField f o v = o { f = v }?
21:36:39 <monochrom> Some functions result in bottom under the wrong context, but works fine under the right context. I don't mind that. Actually I find that necessary.
21:37:41 <dons> Gnezdo: right, there's no general setters in the current record system, unfortunately
21:38:00 <Gnezdo> yep, I figured. thanks!
21:39:30 * shachaf read (part of) the HList paper earlier today.
21:40:07 <shachaf> What is the general opinion on using that instead of data ... records?
21:41:27 <dons> its complicated.
21:41:38 <dons> better to use the built in record system if it works for you, which is 90% of cases
21:41:56 <LeCamarade> When was `it's complicated' ever a reason with these lambdafolk? :o)
21:42:13 <LeCamarade> `Will you be my It's Complicate on Facebook?'
21:42:49 <rdmltrs> hi, has anyone else had problems with the libXrandr when trying run programs from Hudak's SOE?
21:43:07 <shachaf> dons: Is it really that complicated?
21:43:14 * shachaf should finish reading the paper.
21:43:17 <rdmltrs> i'm trying to get SOE and ghc 6.8.2 to run on my olpc
21:43:19 <dons> hlist? yes.
21:43:24 <dons> rdmltrs: oh nice.
21:43:36 <dons> rdmltrs: gtk2hs might be better (it has a nicer SOE)
21:43:54 <dons> rdmltrs: sounds like some funky X11 problem
21:44:01 <shachaf> The final interface, I mean, not the implementation. :-)
21:44:24 <shachaf> I should look at some examples, I suppose. :-)
21:44:30 <dons> oh the final interface looks pretty fine, a bit complicated
21:45:06 <dynamix> > :t isInt
21:45:10 <lambdabot>   parse error on input `:'
21:45:16 <shachaf> @ty isInt
21:45:17 <dynamix> :t isInt
21:45:17 <lambdabot> Not in scope: `isInt'
21:45:18 <lambdabot> Not in scope: `isInt'
21:45:58 <shachaf> dynamix: Where is that from?
21:46:15 <dynamix> i dont know dons just told me about this
21:47:07 <LeCamarade> http://homepages.cwi.nl/~ralf/HList/ is that the HList paper? Looks like real wicked stuff...
21:47:08 <lambdabot> Title: Strongly typed heterogeneous collections
21:48:24 <shachaf> LeCamarade: I hope that's the one... :-)
21:48:49 <dynamix> | (isInt x) /= Nothing  = (Parm par):(processArgs xs)
21:48:50 <dynamix>                                         where
21:48:52 <dynamix>                                           par = read x::Int
21:48:56 <dynamix> what is wrong with that?
21:49:06 <dynamix> i get a parse error
21:49:35 <shachaf> dynamix: Can you @paste some more of the context?
21:49:46 <shachaf> @ty isJust
21:49:46 <lambdabot> forall a. Maybe a -> Bool
21:49:47 <dynamix> sure
21:50:01 <shachaf> dynamix: What is isInt, by the way?
21:50:05 <mrd> @paste
21:50:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:50:17 <dynamix> test if a string is readable as Int
21:50:23 <dynamix> > isInt "314"
21:50:25 <lambdabot>  Just 314
21:50:28 <dynamix> > isInt "314asdf"
21:50:29 <lambdabot>  Nothing
21:50:44 <dynamix> > isInt "314.314"
21:50:44 <lambdabot>  Nothing
21:50:54 <mrd> > read "213asda"
21:50:55 <lambdabot>  Exception: Prelude.read: no parse
21:50:57 <mrd> > read "213asda" :: Int
21:50:58 <lambdabot>  Exception: Prelude.read: no parse
21:51:03 <mrd> > reads "213asda" :: Int
21:51:03 <lambdabot>  Couldn't match expected type `Int'
21:51:07 <mrd> oops
21:51:11 <Gnezdo> given how common  (\c -> case reads c of [(x,_)] -> Just x ; _ -> Nothing) is, is it not defined somewhere?
21:51:17 <mrd> > reads "213asda" :: [Int]
21:51:17 <lambdabot>  Couldn't match expected type `Int'
21:51:20 <mrd> hmm
21:51:27 <shachaf> > reads "213asda" :: [(Int,String)]
21:51:27 <lambdabot>  [(213,"asda")]
21:51:28 <mrd> yea, that
21:51:42 <dynamix> http://hpaste.org/5497#a2
21:52:04 <shachaf> Gnezdo: [(x,_)] or [(x,[])]?
21:52:10 <Gnezdo> []
21:54:05 <dynamix> shachaf: sorry the anonunce did not seem to happen. i posted the hpaste link above
21:54:11 <shachaf> @ty listToMaybe . map fst . reads -- For the _ case, I guess.
21:54:12 <lambdabot> forall a. (Read a) => String -> Maybe a
21:55:02 <dynamix> dons: where is isInt? do i need to import somethign to use it?
21:55:29 <shachaf> dynamix: The problem is the wheres.
21:55:40 <shachaf> dynamix: A where can only be attached to an =.
21:55:55 <shachaf> dynamix: Either move the wheres down below the | cases or use let, probably.
21:56:04 <shachaf> dynamix: (And you misspelled otherwise. :-) )
21:56:22 <dynamix> Grrr misspellings waste most of my time
21:56:45 <dynamix> so whould the where start at the same column as the | ?
21:58:18 <shachaf> dynamix: You shouldn't use (/= Nothing), by the way.
21:58:28 <shachaf> dynamix: The wheres should be split off from the |s.
21:58:37 <shachaf> dynamix: Underneath the | otherwise.
21:58:50 <shachaf> dynamix: You could probably use pattern guards to do things nicely here.
21:58:59 <dynamix> like ?
21:59:02 <shachaf> But at least use isJust (and then you read twice anyway).
21:59:19 <dynamix> :t isJust
21:59:19 <lambdabot> forall a. Maybe a -> Bool
21:59:35 <dynamix> > isJust $ isInt "1234"
21:59:35 <lambdabot>  True
21:59:39 <shachaf> | Just par <- isInt x = ... -- Or something like that.
21:59:40 <dynamix> > isJust $ isInt "1234asdf"
21:59:41 <lambdabot>  False
22:00:20 <dynamix> what wil happen if it returns Nothing and not Just <some Int>
22:04:14 <shachaf> It won't match.
22:05:13 * bos has been working on RESTful server-side URL parsing. nice code coming together. yum!
22:05:31 <dynamix>  Not in scope: `isInt'
22:05:58 <shachaf> @undefine
22:05:59 <lambdabot> Undefined.
22:06:02 <shachaf> > isInt "a"
22:06:02 <lambdabot>   Not in scope: `isInt'
22:07:09 <dynamix> > isJust $ isInt "1234"
22:07:09 <lambdabot>   Not in scope: `isInt'
22:07:45 <dynamix> weird!! it worked just a few seconds ago!!
22:08:31 <dolio> Note: '@undefine'
22:08:36 <shachaf> dynamix: It was defined with @let.
22:08:51 <shachaf> (Instead of isInt, use a more general name, probably.)
22:09:10 <phlpp> > is Just (Just 5)
22:09:10 <lambdabot>   Not in scope: `is'
22:09:14 <phlpp> > isJust (Just 5)
22:09:15 <lambdabot>  True
22:09:23 <phlpp> ;0
22:09:49 <dynamix> oh !! dosn defiend it earlier.. i thought it was a library funcion..
22:10:18 <shachaf> < dons> ?let isInt s = case reads s of [(x,[])] -> Just (x::Integer) ; _ -> Nothing
22:10:30 <shachaf> It needs a more general name, though...
22:11:28 <shachaf> @let readM s = case reads s of [(x,[])] -> return x; _ -> mzero -- Maybe not the best name for it...
22:11:29 <lambdabot> Defined.
22:11:59 <wli> I wish there were such a readM
22:12:27 <dynamix> > readM "1234"::Int
22:12:28 <lambdabot>  Couldn't match expected type `Int' against inferred type `m a'
22:12:31 <dynamix> > readM "1234"
22:12:32 <lambdabot>   add an instance declaration for (Show (m a))
22:12:58 <wli> > readM "1234" :: Maybe Int
22:12:59 <lambdabot>  Just 1234
22:13:56 <shachaf> Is there a particular reason this function, or at least a Maybe version, isn't somewhere in the Prelude?
22:14:06 <dons> hysterical reasons
22:14:19 <dons> its super useful. at least with return/fail "reads: error" would be accepted
22:14:47 <dynamix> shachaf: apparently | Just par <- isInt x is  a non standard pattern guard.
22:15:16 <shachaf> dynamix: <shachaf> dynamix: You could probably use pattern guards to do things nicely here.
22:15:25 <shachaf> dynamix: Does that mean you shouldn't use it? :-)
22:16:02 <dynamix> nope i guess its ok. just add a flag  (use -XPatternGuards to suppress this message) . because ghc 6.8.2 just gives a warning..
22:16:42 * wli likes to distinguish between ambiguous parses and no parses in error messages, and maybe even spit out some of what failed to parse so they can look for it.
22:16:47 <dynamix> but i get another error which is actually cause for concern.. (34,0)-(42,52): Non-exhaustive patterns in function processArgs
22:17:23 <dynamix> i thought otherwise would match every thing all previous patterns do not
22:17:25 <wli> dynamix: What's processArgs?
22:17:45 <dynamix> http://hpaste.org/5497#a2
22:17:53 <shachaf> dynamix: You don't handle [].
22:18:10 <dynamix> doesn't otherwise take care of that?
22:18:20 * jadrian is thinking about 4th and 5th order funcions
22:18:28 * jadrian is feeling brain overload
22:18:29 <shachaf> dynamix: No.
22:18:42 <shachaf> dynamix: You have (x:xs) | ..., | ...
22:18:56 <shachaf> dynamix: That otherwise is still for (x:xs).
22:19:10 <bos> i wish we had a wildcard for type variables.
22:19:15 <dynamix> hmm i need another processArgs [] = []
22:19:23 <jadrian> bos: ?
22:20:00 <bos> jadrian: consider: (</) :: (P a c, P b _z) => a -> b -> CharParser () c  -- we don't care what type _z has here
22:20:05 <jadrian> bos: for paial specificaions?
22:20:14 <jadrian> geez
22:20:18 <jadrian> "partial specifications"
22:20:23 <dynamix> ha at last!! i got one part going.  lots of more braindead work to do so that i can accept all the same args that the c version accepts
22:20:31 <bos> paial words are still reable
22:23:09 <jadrian> bos: maybe I'm just sleepy, bu isn't that what happens if you put a type var 'z' there?
22:23:26 <jadrian> it works for any type z...
22:25:22 <bos> jadrian: sure, but it's notationally inelegant compared to a proper wild card
22:25:56 <bos> a haskell function works fine if you write an unused variable in place of a wild card, too, but wild cards are prettier.
22:30:08 <Twey> bos, if we had that Haskell wouldn't be strongly typed...
22:30:26 <shachaf> Twey: Why not?
22:30:43 <Twey> shachaf, optionally ignore types?
22:30:53 <shachaf> Twey: That's not what _ is.
22:30:58 <bos> no, it's not optionally ignore.
22:31:01 <shachaf> Twey: It's just a placeholder, like the argument _.
22:31:20 <Twey> < bos> jadrian: consider: (</) :: (P a c, P b _z) => a -> b -> CharParser () c  -- we don't care what type _z has here
22:31:39 <Twey> But then any type could be passed there
22:31:59 <bos> Twey: that means that the type is consistent no matter what type _z is.
22:31:59 <shachaf> Twey: It's no different from having "z".
22:32:14 <shachaf> Twey: Just a different name that shows you won't be reusing it.
22:32:32 <Twey> Oh
22:32:33 <bos> notice that _z doesn't show up in the actual type, so it can't affect the type.
22:32:33 <Twey> OK.
22:32:44 * Twey nods.
22:32:44 <bos> it's only present in the constraint.
22:33:30 <LeCamarade> This Quine^3 that sigfpe wrote ...
22:33:45 <LeCamarade> I wanna set it up in a loop. :o)
22:34:26 <Twey> Quine^3?
22:34:40 <wli> Third-order quine.
22:34:55 <Twey> A program that prints its source that prints its source? ... but isn't that what a quine does anyway?
22:35:00 * Cale thinks about how Daan's records might be translated into Core.
22:35:09 <Twey> It's recursive, I don't see how it can be abstracted any more :-\
22:35:11 <dons> Twey: via 3 languages
22:35:14 <Twey> Ohh.
22:35:20 <Twey> Mmkay.
22:35:25 <dons> http://reddit.com/r/programming/info/67szi/comments/
22:36:27 <dolio> Is DKKat the new ayrnieu?
22:37:29 <dons> seems like it.
22:37:30 <phlpp> lol
22:37:41 <phlpp> "missing -Ofun?" made me smile ;)
22:38:01 <dons> hehe. he's a real grump though. always dropping in to complain
22:38:17 <dolio> You should check out his "Frag isn't as fast as Quake3" thread.
22:38:42 <dons> which was a non sequitor on a post about regexes.
22:38:55 <dons> "bah, but what about performance of real time reactive systems!? huh!"
22:39:23 <dons> some people like the buckets they sit in
22:40:17 <shachaf> dons: runghc can read from stdin now?
22:40:34 <dons> i sent a patch in.
22:40:48 <dons> i'm hoping igloo will have a quick look at it, otherwise i'd have just applied it
22:41:15 <dons> get your patch here, http://galois.com/~dons/tmp/runhaskell-stdin.patch
22:41:39 <dons> btw, good idiom for cleaning up temp files there. seems like we should have a 'withTempFile' though
22:42:23 <phlpp> l8 guys
22:43:09 <dons> oh, i slipped /tmp in there. forgot to change that to a TMPDIR lookup
22:45:12 <glguy> It's a shame to have to hack stdin support in like that
22:47:02 <jsnx> glguy: like what?
22:47:13 <jsnx> i can't find previous connected conversation...
22:47:15 <dons> seems ok, but it's a little surprising we didn't do this earlier
22:47:29 <glguy> jsnx: where the stdin is written to a tmpfile
22:48:02 <glguy> to support runghc < input.hs
22:48:09 <jsnx> oic
22:48:12 <jsnx> yeah, now
22:48:15 <jsnx> got it
22:48:55 <dons> versus ghc reading from stdin , glguy ?
22:49:00 <glguy> yeah
22:49:26 <dons> we could try to do it more thoroughly, but i figure its not a performance critical path :)
22:49:53 <glguy> I was just thinking that if it could just as well be a shell script wrapper
22:50:01 <glguy> if you are dumping to a file in /tmp
22:50:09 <glguy> rather than adding that to runghc
22:50:15 <dons> runghc.hs is already a wrapper though.
22:50:28 <shachaf> There is a difference between runghc and compiling properly with ghc --make, right?
22:50:32 <dons> http://galois.com/~dons/tmp/runghc.hs
22:50:44 * shachaf remembers either wxHaskell or gtk2hs had a problem with it.
22:50:49 <dons> it just sets things up to call 'rawSystem ghc' on the resulting file
22:51:43 <glguy> dons: Right, runghc is a wrapper too, but it is also distributed with the rest of GHC
22:51:57 <glguy> a shell script in someone's home directory wouldn't go out in the next release
22:52:23 <dons> don't we want runghc to read from stdin in the next release though?
22:52:32 <dons> or am i missing something?
22:52:48 <glguy> I think it'd be one thing for ghc to actually read from stdin
22:52:56 <glguy> but the tmpfile seems like a workaround
22:53:00 <glguy> for adding the functionality to ghc
22:53:48 <dons> most of runghc is a workaround already, so toss another one on the pile. that is: its consistent with runghc's philosophy :)
22:53:52 <glguy> or is it already common for piping content to an application to write to a temp file first in other unix applications?
22:54:08 <dons> ghc does it all over, already, actually (try -keep-tmp-files)
22:54:27 <shachaf> glguy: This can eventually be fixed to work more nicely, but there's no reason not to have in there somehow, is there?
22:55:14 <glguy> it's something we haven't needed until sigfpe's quine, so I'm not convinced that it's going to get any more attention later cleaning it up ;)
22:55:17 <bd_> rather than a temp file, what about using a named pipe?
22:55:54 <shachaf> glguy: I've wanted it in the past.
22:55:59 <dons> glguy: oh, i'm happy with it. beats echo x | xargs ghc -e
22:56:13 <dons> and similar hacks of times past
22:56:17 <shachaf> dons: Not to mention that that can't import, or anything like that.
22:56:31 <dons> yeah
22:56:47 * shachaf had a vim thing at one point that could run the top "window" and put the output on the bottom.
22:57:02 <dons> glguy: also, the process of 'normalisation' continues. ghc should present a similar interface to the other P languages :)
22:57:07 <shachaf> It was very handy for testing short, but not REPL-short, Ruby scripts, for example.
22:57:18 <dons> "don't freak the kids out"
22:57:41 <shachaf> dons: Is Haskell a P language?
22:57:52 <OceanSpray> can I do pattern matching in a lambda expression?
22:58:01 <glguy> yes
22:58:03 <OceanSpray> that is, multiple-dispatch?
22:58:06 <glguy> \ (Just x) ->
22:58:08 <OceanSpray> sorta?
22:58:09 <dons> \x -> case x of ....
22:58:36 <dons> > map (\x -> case x of 1 -> 2 ; 2 -> 1 ; 3 -> 7; _ -> undefined) [1..10]
22:58:39 <lambdabot>  Undefined
22:58:40 <OceanSpray> well, that kind of defeated the purpose of using the lambda in the first place.
22:58:55 <OceanSpray> for my current situation, that is.
22:58:55 <dons> right.
22:59:01 <shachaf> OceanSpray: If you want multiple patterns, yes.
22:59:05 <Twey> Heh
22:59:12 <shachaf> (Well, other than the fact that you don't have to name it, yes.)
22:59:35 <BMeph> So, since everyone always starts making their interpreted languages with a stack-based machine, then converts it to register-based when it's show to be popular enough to stick around, why don't we just make stack-based processors?
22:59:44 <dons> lambdabot is overly strict there, notice
22:59:45 * Twey ponders.
22:59:50 <dons> Prelude> map (\x -> case x of 1 -> 2 ; 2 -> 1 ; 3 -> 7; _ -> undefined) [1..10]
22:59:50 <dons> [2,1,7,*** Exception: Prelude.undefined
23:00:03 <Twey> Why doesn't lambdabot allow looping?
23:00:06 <dons> it forces the string length, and does some extra stuff to ensure exceptions donn't bubble around.
23:00:11 <dons> > fix (1:)
23:00:13 <Philippa_> BMeph: because they suck
23:00:14 <dons> sure it does.
23:00:26 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:00:33 <Twey> Heh.
23:00:35 <Twey> Huh.
23:00:43 <Philippa_> which is to say that it's been tried, and x86 still has push and pop instructions, but so what?
23:00:44 <Twey> > let s = s in s
23:00:44 <lambdabot>  Exception: <<loop>>
23:01:08 <wagle_home> > fix my program
23:04:47 <Twey> > [1..]
23:04:47 <lambdabot>   Not in scope: `program'
23:04:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:04:47 <shachaf> @v
23:04:47 <lambdabot> Just 'J'
23:04:47 <Twey> > length [1..]
23:04:47 <lambdabot> Terminated
23:04:47 <BMeph> Oh, well that explains everything... ;p
23:04:47 <wagle_home> woot!  bottom equals infinity!
23:04:47 <glguy> how do I tell ghc to ignore the file extension
23:04:47 <glguy> and treat something like a .hs file?
23:04:47 <glguy> (does runghc < somefile) support such detection?
23:04:47 <glguy> or is that a strictly .hs feature?
23:04:47 <wli> Usually bottom is the least element in the DCPO.
23:04:47 <wagle_home> yeah, but length of [1..] is infinity
23:04:50 <quicksilver> the length of [1..] is infinity but
23:04:54 <glguy> wagle_home: well, the length is undefined at least
23:05:04 <quicksilver> the result of applying the program 'length' to the value [1..] is not infinity
23:05:09 <quicksilver> it's bottom
23:05:23 <quicksilver> because 'length', the program, is an imperfect model of your mental spec
23:05:28 <wagle_home> thus infinity equals bottom
23:05:45 <quicksilver> bottom is often the result you get if your program tries to calculate infinity
23:05:51 <quicksilver> might be a more precise way to phrase it
23:05:53 <quicksilver> > 1/0
23:05:54 <lambdabot>  Infinity
23:05:58 <quicksilver> not always though :)
23:06:15 <glguy> dons: if you could specify the incoming extension,   ghc <( echo "main = print 2" )
23:06:19 <wagle_home> :t 1/0
23:06:19 <lambdabot> forall t. (Fractional t) => t
23:06:27 <wagle_home> :t length
23:06:27 <lambdabot> forall a. [a] -> Int
23:06:54 <wagle_home> length [1..70000]
23:07:06 <Deewiant> > length [1..70000]
23:07:06 <lambdabot>  70000
23:07:22 <wagle_home> > length [1..4000000]
23:07:25 <lambdabot>  4000000
23:07:32 <wagle_home> > length [1..4000000000]
23:07:35 <lambdabot> Terminated
23:07:46 <wagle_home> > length [1..2000000000]
23:07:50 <lambdabot> Terminated
23:07:55 <wagle_home> bah
23:09:13 <wagle_home> > factorial
23:09:14 <lambdabot>   Not in scope: `factorial'
23:09:17 <wagle_home> > fact
23:09:17 <lambdabot>   Not in scope: `fact'
23:09:49 <wagle_home> @index factorial
23:09:49 <lambdabot> bzzt
23:09:58 <wagle_home> @hoogle factorial
23:09:59 <lambdabot> No matches found
23:10:00 <Deewiant> not in the stdlib
23:10:29 <Deewiant> > let (!) = product.enumFromTo 1 in (10!)
23:10:29 <lambdabot>  3628800
23:10:54 <sarehu> naughty naughty
23:11:27 <olsner> > unsafePerformIO (return 42)
23:11:28 <lambdabot>   Not in scope: `unsafePerformIO'
23:12:18 <bos> it's a shame there's no nice way to mix positional and record syntax when declaring fields.
23:12:27 <BMeph> Mmm, ghc -e ;)
23:13:03 <glguy> bos: unnamed fields?
23:13:18 <bos> glguy: right.
23:13:24 <wli> If record types sharing field names were possible, a purely syntactic device for records to "inherit" fields from other types would be nice.
23:13:53 <bos> wli: what do you mean, sharing field names?
23:14:16 <glguy> it might create a typeclass having that field name as a member?
23:14:21 <Deewiant> data Foo = Foo { foo :: String } and data Bar = Bar { bar :: String }
23:14:21 <wli> 2 record types having some subset of field names in common.
23:14:22 <glguy> and still support the update syntax?
23:14:27 <Deewiant> er, crap, s/bar/foo/
23:15:09 <wli> glguy: No need for a typeclass. Just narrow it down to one member of that set and flag it as ambiguous if it's not narrowed down somehow.
23:15:34 <glguy> ( f x = x { foo = 1 } ) :: HasFoo a => a -> a
23:15:35 <glguy> ?
23:15:37 <glguy> :)
23:15:55 <wli> glguy: The typeclass is also plausible.
23:16:32 <glguy> (that example assumes that foo always has the same result type though)
23:16:47 <glguy> actually..
23:16:57 <glguy> I guess that example doesn't really touch on that possibility
23:17:11 <wagle_home> there is a class hierarchy
23:17:59 * wli likes opera while being primarily a metalhead, but likes dancing to techno/EBM.
23:18:16 <glguy> ebm?
23:18:16 <wagle_home> and derived instance methods...
23:18:21 <BMeph> Good night.
23:18:26 <wli> woops, wrong channel
23:38:10 <bos> @seen dons
23:38:10 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 37m 56s ago.
23:43:13 <olsner> wow - "Iíve seen the same thing with Rails. People requesting 3 years of experience when it had been out for 2."
23:44:05 <olsner> that's incredible! people actually did that?
23:44:17 <Korollary> HR people are infallible.
23:44:21 <ricky_clarkson> The furore over how underwhelming Arc is has been funny.
23:44:42 <siti> what is arc?
23:44:43 <ricky_clarkson> "Look, it's so trivial I just implemented it in Scheme!  PG must be drunk!"
23:44:50 <Korollary> ricky_clarkson: what's funnier is PG arguing with everybody
23:45:00 <ricky_clarkson> Oh, I haven't noticed that yet.
23:45:03 <bos> arc is a lisp dialect that's so incredibly offensive, people have had heart attacks.
23:45:11 <siti> umm... ok
23:45:16 <bos> instead of parentheses, it uses little jpegs of buttocks.
23:45:32 <bos> instead of whitespace, it uses milky virgin flesh.
23:45:38 <jsnx> lolz
23:45:39 <Korollary> so that's what they mean by visual programming?
23:45:39 <bos> terrible stuff, i tell you.
23:45:42 <ricky_clarkson> Surely those must exist in Unicode.
23:45:52 <jsnx> bos: yeah, it's basically aesthetic, though
23:46:11 <s1d> vizual
23:46:15 <jsnx> we can finely stop paying attention to PG, though
23:46:24 <bos> and of course because of its heavily graphical nature, it will soon be renamed to fark.
23:46:24 <jsnx> now that it's clear he's a n00b for life
23:46:34 <Korollary> I wasn't paying attention anyway
23:46:48 <jsnx> Korollary: then, you were ahead of me
23:46:57 <Korollary> jsnx: take that!
23:47:34 <radetsky> question: suppose I have a binary op like +, and I want to construct a ternary function which returns the result of applying the op to the first two args, then applying the op to the third arg and the result
23:47:51 <radetsky> is there a clean, ideally pointfreeish, way to do this?
23:48:38 <olsner> (kind of funny though, that just because he's paul graham he can't invent a funny little lisp dialect without the whole world of functional programming getting engaged)
23:48:38 <Korollary> @pl \x y z -> (x + y) + z
23:48:39 <lambdabot> ((+) .) . (+)
23:48:59 * wli wishes for a higher-order module system and a cleaned up numeric class hierarchy for Christmas.
23:49:01 <radetsky> awesome
23:49:12 <radetsky> Korollary: thanks
23:49:20 <Korollary> no problem. lambdabot is your friend.
23:49:21 <radetsky> I forgot about the rewriter
23:49:22 <olsner> @pl \(+) -> ((+) .) . (+)
23:49:22 <lambdabot> (line 1, column 3):
23:49:22 <lambdabot> unexpected "+"
23:49:22 <lambdabot> expecting pattern
23:49:28 <bos> wli: we already have a higher-order module system. it just doesn't look like a module system.
23:49:37 <olsner> @pl \x -> (x .) . x
23:49:38 <lambdabot> (.) =<< (.)
23:49:39 <wli> And monad comprehensions and ridding Monad of fail and so on.
23:49:59 <radetsky> wli: Monad may still have AIDS tho
23:50:06 <olsner> yeah, monads should have more win
23:50:12 <wli> bos: The module system is first-order barring extensions of which I'm unaware.
23:50:50 <bos> wli: http://www.haskell.org/pipermail/haskell/2004-August/014463.html
23:50:50 <lambdabot> Title: [Haskell] Applicative translucent functors in Haskell
23:53:46 <wli> bos: Desugar module stuff to things like that and we're in business.
23:55:04 <dmwit> Strictness makes such a big difference on space use, sometimes.
23:55:16 <wli> olsner/radetsky: Just generate MonadZero constraints on pattern match failure in do blocks and monad comprehensions and it's all fixed.
23:55:47 <olsner> easy as pi
23:56:03 <dmwit> By the way, I thought this was in the standard library somewhere, but I can't find it, any tips?
23:56:13 <dmwit> snd . foldl1' max . map (f &&& id)
23:56:31 <olsner> you want at least Control.Arrow and Data.List
23:56:35 <dmwit> (i.e. a variant of maximumBy)
23:56:45 <bos> @type snd . foldl1' max . map (f &&& id)
23:56:46 <olsner> oh, you mean like that, heh
23:56:47 <lambdabot> Not in scope: `f'
23:56:56 <bos> blurp.
23:57:05 <dmwit> ?type \f -> snd . foldl1' max . map (f &&& id)
23:57:06 <lambdabot> forall a c. (Ord (c, a)) => (a -> c) -> [a] -> a
23:58:49 <olsner> @hoogle (Ord c) => (a -> c) -> [a] -> a
23:58:49 <lambdabot> No matches, try a more general search
23:59:03 <olsner> @hoogle (a -> c) -> (c -> c -> Ordering) -> [a] -> a
23:59:04 <lambdabot> No matches, try a more general search
23:59:20 <dmwit> > let maxByOrd = snd . foldl1' max . map . (&&& id) in maxByOrd (\x -> negate (x + 1) * (x + 1)) [-2..5]
23:59:21 <lambdabot>  Couldn't match expected type `[a]'
