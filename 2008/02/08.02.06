00:00:02 <olsner> does (a,b) have an Ord instance?
00:00:19 <dmwit> (Ord a, Ord b) => Ord (a, b)
00:00:33 <wagle_home> @hoogle Ord(a,b)
00:00:34 <lambdabot> No matches, try a more general search
00:00:55 <wagle_home> > (1,2) < (2,3)
00:00:56 <lambdabot>  True
00:01:12 <dmwit> > let maxByOrd f = snd . foldl1' max . map (f &&& id) in maxByOrd (\x -> negate (x + 1) * (x + 1)) [-2..5]
00:01:12 <lambdabot>  -1
00:01:18 <wagle_home> @info (1,2)
00:01:18 <lambdabot> (1, 2)
00:01:35 <dmwit> ?info do { x <- foo; bar x }
00:01:35 <lambdabot> foo >>= \ x -> bar x
00:01:39 <dmwit> ;-)
00:01:47 <wagle_home> ?info (1,2)
00:01:47 <lambdabot> (1, 2)
00:02:02 <dmwit> ?info spell-corrects to ?undo
00:02:02 <lambdabot> spell - corrects to ? undo
00:02:21 <olsner> ?info 42
00:02:21 <lambdabot> 42
00:02:54 <wli> More interesting is an instance (Enum t, Enum t') => Enum (t, t')
00:03:06 <dmwit> Yes, that one surprised me, too.
00:03:36 <olsner> is there one already? I remember trying to build one and ending up with a steaming heap of fail
00:03:41 <wagle_home> :)
00:04:26 <glguy> Enum doesn't imply bounded, so about the best you could do is succ (x,y) = (succ x, succ y)
00:04:35 <dmwit> I thought there was, but I can't see one now.
00:04:40 <dmwit> So maybe I was dreaming.
00:05:25 <OceanSpray> http://screw.svn.sourceforge.net/viewvc/screw/trunk/Primitives.hs?revision=10&view=markup
00:05:26 <lambdabot> Title: SourceForge.net Repository - [screw] View of /trunk/Primitives.hs, http://tinyurl.com/359old
00:05:34 <olsner> needs a bound on the first type, so (Bounded t, Enum t, Enum t') => Enum (t, t') should be possible (in a way that actually enumerates all values), right?
00:05:45 <wli> I think (Ord t Ord t') => Ord (t, t') is in the std. lib. but the Enum is not. Cantor's zigzag bijection between N and N^2 and the usual one between Z and N are needed, but with lots of caveats about unboundedness below.
00:05:56 <OceanSpray> so, guys
00:06:11 <wli> And above, really.
00:06:18 <OceanSpray> from yesterday's advice, I've managed to shrink my code quite a bit.
00:06:26 <OceanSpray> anything else you can recommend?
00:06:53 <OceanSpray> that apply is still several dozen lines long.
00:06:55 <dmwit> olsner: Yeah; a Bounded on the second type is probably also enough.
00:07:08 <olsner> hmm, with first-class modules, shouldn't there be a way to @pl a whole program? :P
00:07:12 <wli> http://holomorphy.com/~wli/Tuple.hs
00:07:15 <olsner> dmwit: yeah, any one of them should be enough
00:07:26 <ricky_clarkson> olsner: Looked at J?
00:07:33 <wli> Bounded is not necessary.
00:07:50 <quicksilver> there a some questions about whether Enum instancers should be expected to be compatible with Ord instances, etc.
00:08:05 <quicksilver> there is however a useful Ix instance
00:08:09 <quicksilver> and I use that sometimes
00:08:53 <olsner> ricky_clarkson: looked at, yes, but the J shell can't input ~ on my system and ~ is some important function (can't remember which, since I've obviously haven't made it past that point in the tutorial ^^)
00:09:13 <roconnor> we should hook up Open Office Spreadsheet to Haskell.
00:09:36 <wli> The dictionary ordering won't do in most of the Enum cases.
00:09:41 <dmwit> olsner: Of course you can ?pl an entire program!  We have S (ap), K (const), and I (id)! ;-)
00:09:59 <dmwit> roconnor: You probably have a better chance with Gnumeric.
00:10:15 <quicksilver> gnumeric has a scheme binding doesn't it?
00:10:20 <quicksilver> or once did?
00:10:24 <dmwit> roconnor: But then, it's hardly worth the effort, as Gnumeric already has Python scripting, which is Good Enough.
00:10:31 <roconnor> oh
00:10:34 <dmwit> quicksilver: Yeah, probably Scheme too.
00:10:53 <quicksilver> let's write that on dmwit's epitaph
00:10:59 * wli never got into Python.
00:11:00 <quicksilver> 'Python is Good Enough'
00:11:11 <dmwit> =)
00:12:34 <wagle_home> gimme fortran, and i will give you scheme.  gimme scheme, and i will give you haskell.
00:12:46 <dmwit> Impressive.
00:13:05 <dmwit> I can't wait to see what you give us now that you have Haskell.
00:13:12 <olsner> yeah, given haskell, what will you give us?
00:13:14 <roconnor> Epigram
00:13:21 <wagle_home> tuple
00:13:49 <wagle_home> The Ultimate Programming Language
00:14:00 <dmwit> ...Ever
00:14:14 <wagle_home> no, its riding a wave
00:14:18 <olsner> or tupl
00:14:36 <wagle_home> TUPLe
00:15:04 <wagle_home> or add environment..  the name came early, the meaning has changed..  8/
00:15:27 * wli thinks that with some cleanups Haskell could basically be it.
00:15:29 <ski> what should we give, to get fortran ?
00:15:42 <wagle_home> haskell
00:16:05 <wli> Real programmers can write Fortran in any language. ;)
00:16:11 <dmwit> So what features exist in The Ultimate Programming Language Editor?
00:16:33 <wagle_home> really real programmers can write haskell in any language
00:16:42 <dmwit> eugh
00:16:48 <dmwit> In some languages it isn't worth it.
00:16:55 <wagle_home> scheme programmers can write any language in scheme..
00:17:26 <wagle_home> thats the whole friedman thing
00:17:43 <dmwit> Damn it!  I waited all that time for it to calculate the max... and I wanted the min.
00:18:00 <siti> I programme haskell in asm ;)
00:18:18 <dmwit> I program asm in Haskell!
00:18:21 <wli> I just say clean up the numeric hierarchy, undo the H98 anti-polymorphic castration (restore monad comprehensions, untangle MonadZero from Monad, make Functor a prerequisite for Monad, etc.), drop in higher-order modules, and you're rocking the world.
00:18:25 <dmwit> Which is more impressive? =)
00:18:26 <wagle_home> i toggle in haskell with the switches on the front of my pdp 11
00:19:04 <dmwit> I program robots in my bathtub.
00:19:18 <wagle_home> ok ok  you rock
00:19:50 * wli wrote a Fourier-Motzkin elimination solver.
00:19:58 <dmwit> I write ugly code when I'm tired. =/
00:20:04 <dmwit> wli: Neat!
00:20:54 <wagle_home> actually, i wanted to program asm network drivers for the ixp1200 microengines in haskell, but they stalled me to death on the asm->binary mappings
00:20:59 <wli> It's kind of dull. The answers are mostly inequalities save for the one variable narrowed down to an interval.
00:21:24 <wagle_home> didnt know they were going to do that, else i woulda spent two weeks reverse engineering the asm bits
00:21:36 <wli> You do get an answer as to whether solutions exist, though.
00:23:15 <wli> It runs a lot faster than the worst case for most realistic problems.
00:23:33 <quicksilver> I think "drop in higher-order modules" is a fairly complex and ill-defined goal.
00:23:41 <quicksilver> certainly compared to the other things on wli's list
00:23:53 <quicksilver> which are actually rather straightforward
00:23:59 <wagle_home> what is a higher order module
00:24:03 <wagle_home> what is a higher order module?
00:24:15 <wagle_home> oops
00:24:29 <wagle_home> thought the first one didnt go through
00:25:34 <wli> quicksilver: Cleaning up the numeric hierarchy is moderately vague. Dropping in higher-order modules is pretty much "grab a module system from one of the ML variants and desugar it to one of the various encodings floating around."
00:25:53 <wli> quicksilver: e.g. the one bos cited
00:27:06 <wli> Oh man it's late out here. Sorry folks, I'm calling it a night.
00:37:55 <olsner> hmm, it'd be neat to build a disassembler as a Binary instance
00:40:12 <wagle_home> related to that is the interesting puzzle of an exploit hitting the address of the middle of an instruction, and being able to execute instructions that aren't apparent in the assembly language source of a program
00:41:03 <olsner> that'd be a neat feature for an assembly compressor
00:41:04 <wagle_home> going out of sync of the intended instructions can go on for a while
00:41:20 <olsner> (but probably undecidable and hard)
00:46:08 <wagle_home> one thing about exploiting a system thats not usually expected is that the interface to the exploited system doesn't need to be noise free..  you can try things over and over until they work..  its okay if it take you 5 miniutes to execute an instruction you want..  as long as you eventually make progress and improve your interface
00:48:18 <wagle_home> thr challenge is seeing your system how an exploiter sees it, and designing things so he cant get anywhere
00:48:47 <wagle_home> i dont think its undecidable..  just confusing
00:49:34 <olsner> I'm thinking about the search for alternate instruction encodings that does the same thing in order to fold code into other places of the code stream at an offset
00:50:00 <olsner> the "does the same thing" part is undecidable in general
00:51:38 <wagle_home> you may be right, but i think you are overreacting..  a compiler's job is to input source code, and emit object code that "does the same thing"
00:51:51 <dmwit> Problem 28 is nice.
00:52:21 <radetsky> wagle_home: source code doesn't do anything
00:52:27 <wagle_home> ... and that after a number of "correctness preserving optimizations"
00:52:41 <wagle_home> radetsky, tell that to the lisp machine
00:53:15 <radetsky> for the lisp machine, source code is object code
00:53:25 <quicksilver> I am reminded of the story of mel
00:53:28 <wagle_home> i can build a haskell machine
00:53:40 <quicksilver> one of the things discussed there is using code also as data
00:53:55 <quicksilver> so if you need the constant 10, but the opcode 10 appears in your machine code anyway, just use that
00:54:02 <quicksilver> no need to waste a word for the constant
00:54:03 <wagle_home> haskell code is data to template haskell
00:54:30 <wagle_home> mel?
00:54:56 <radetsky> quicksilver: you still need to waste a word for the address of the constant, or how to get it, or wherever
00:55:05 <radetsky> s/wherever/whatever
00:55:37 <quicksilver> radetsky: you would have needed that anyway, wherever you stored it
00:55:45 <quicksilver> radetsky: (in the machine codes under discussion, at least)
00:55:46 <wagle_home> i can (probably?) compile any program to silicon
00:57:00 <ac> does anybody know of an etoys like environment that's functional enough to create simple dynamic web pages?
00:57:36 <radetsky> quicksilver: I think this is only going to matter if you need, e.g., a constant that is, say, 10 words long, in which case how many cycles do you need to spend to check if that 10-word constant appears anywhere in the program, in order to save 9 words?
00:58:00 <nominolo> @src Monoid
00:58:00 <lambdabot> class Monoid a where
00:58:00 <lambdabot>     mempty  :: a
00:58:00 <lambdabot>     mappend :: a -> a -> a
00:58:00 <lambdabot>     mconcat :: [a] -> a
00:58:16 <radetsky> I don't think this is a paying proposition
00:58:23 <dmwit> Anyway, you probably can't execute non word-aligned instructions.
00:58:33 <quicksilver> radetsky: that assembly language had all instructions 1 word long
00:58:41 <quicksilver> radetsky: and no facility to store constants inline
00:58:43 <quicksilver> radetsky: AIUI
00:58:46 <radetsky> or rather, a particular 10-word constant that you need isn't going to appear
00:58:57 <quicksilver> radetsky: so all constants were therefore addressed
00:59:06 <quicksilver> *shrug*
00:59:36 <radetsky> oh, ok
01:02:22 <radetsky> is the mel asm isomorphic to the machine code via substitution?
01:02:25 <wagle_home> i think you would blow the instruction pipeline if you tried to jump into the middle of a decoded instruction... else it would just got nutz
01:02:39 <radetsky> that is, doesn't every machine allow "inline constants"?
01:03:16 <radetsky> if so, all this cleverness is not going to compress the machine code
01:03:29 <Cin> win 2
01:03:32 <Cin> oops
01:04:11 <radetsky> just the asm, which doesn't matter
01:04:42 <chr1s> hey all, is there anybody using gtk2hs under OS X?
01:05:03 <radetsky> or are you using "assembly language" to mean "machine code"?
01:05:04 <wagle_home> i would if i could use ghc under os x
01:05:14 <chr1s> when doing a ./configure, it complains I haven't got gtk+2 installed, but I did install it using fink.
01:05:25 <chr1s> wagle_home: installing ghc is doable =)
01:05:53 <wagle_home> cant bootstrap osx10.5/ppc
01:06:29 <wvd> hello
01:06:43 <wagle_home> i'm sure its possible, but i havent gotten around to beatinhg it into submission
01:07:28 <wagle_home> i mean, someone DID get macosx 10.5/x86 to bootstrap
01:07:30 <dmwit> Hiya, wvd!
01:08:13 <wagle_home> howdy
01:08:18 <wvd> can someone point me to a nice, slow, written-for-a-six-year-old explanation of monads?
01:08:32 <radetsky> yes, but we won't, because we hate you
01:08:52 <wvd> good to know where I stand
01:08:59 <radetsky> j/k
01:09:28 <dmwit> ?where meet the monads
01:09:28 <lambdabot> I know nothing about meet.
01:09:39 <radetsky> were you unsatisfied with  http://haskell.org/haskellwiki/Tutorials#Using_monads ?
01:09:40 <dmwit> ?go all about monads
01:09:41 <lambdabot> http://www.haskell.org/all_about_monads/
01:09:41 <lambdabot> Title: All About Monads
01:09:53 <dmwit> ?go you could have invented monads and maybe you already did
01:09:54 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
01:09:54 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
01:10:05 <dmwit> Those two are my favorites.
01:10:14 <wagle_home> the hard thing about monads is figuring out that they are easy
01:11:51 * wagle_home is about 75% there
01:12:18 <wvd> in the example "data Maybe a = Nothing | Just a"
01:12:29 <wvd> are Nothing and Just built in haskell keywords?
01:12:43 <radetsky> no
01:13:00 <radetsky> or, maybe they are, but you can define a datatype that does the same thing using any words
01:13:03 <wagle_home> no, they are data constructors for the Maybe type
01:13:20 <radetsky> I think
01:13:20 <wagle_home> ?src Maybe
01:13:21 <lambdabot> data Maybe a = Nothing | Just a
01:13:34 <wvd> is there any lower level code behind them which determines what they do or are they just symbols?
01:13:52 <dmwit> They are just symbols.
01:14:06 <dmwit> Just and Nothing are constructors for the Maybe data type.
01:14:11 <wagle_home> :t Maybe
01:14:13 <lambdabot> Not in scope: data constructor `Maybe'
01:14:18 <wagle_home> :i Maybe
01:14:20 <wvd> so I could define my own Maybe that looks like this: data Maybe a = Foo | Blah a
01:14:33 <wagle_home> ?info Maybe
01:14:33 <lambdabot> Maybe
01:14:34 <dmwit> Sure!
01:14:40 <radetsky> data Possibly a = YouAreSOL | LuckyYou a
01:14:45 <wagle_home> <lambdabot> data Maybe a = Nothing | Just a
01:14:48 <radetsky> oh, wait, you were already there
01:14:52 <wagle_home> is the official definition
01:14:54 <dmwit> wagle_home: Seriously, cut it out with ?info.  It doesn't do anything.
01:15:35 <wagle_home> dmwit, it did something once..  but i dont remember what the circumstances were
01:15:45 <dmwit> Yes, ?info spell-corrects to ?undo.
01:15:50 <dmwit> ?help undo
01:15:51 <lambdabot> undo <expr>
01:15:51 <lambdabot> Translate do notation to Monad operators.
01:17:08 <wagle_home> ?help info
01:17:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:17:20 <wvd> the bind operator ">>=", it looks like it works like a unix command line pipe, where the output of one computations is given as the input to another, is this a reasonable way to think about it?
01:17:35 <dmwit> Exactly!
01:17:38 <dmwit> In fact...
01:17:43 <dmwit> ?go unix pipes are a monad
01:17:44 <lambdabot> http://okmij.org/ftp/Computation/monadic-shell.html
01:17:45 <lambdabot> Title: UNIX pipes as IO monads
01:18:31 <radetsky> wvd: and ">>" is ";"
01:18:40 <wagle_home> it gets a bit more subtle than that, say with the state monad
01:18:56 <osfameron> hence Windows Powershell's original name
01:19:12 <radetsky> actually, maybe it's "&&"
01:20:00 <wvd> so in "this >> that", will "that" only happen if "this" succeeds? (which is the meaning of &&)
01:20:10 <dmwit> ...kind of
01:20:14 <dmwit> In some monads.
01:20:21 <wvd> and can I take it as a given that this will always happen before that?
01:20:33 <dmwit> The beauty of monads is that (>>) and (>>=) mean different things in different monads.
01:20:34 <radetsky> that article says to think of it as ";"
01:21:01 <dmwit> wvd: For the most part, yes, monads enforce evaluation order.
01:21:46 <dmwit> wvd: This is not magical; it just follows from analyzing data dependencies, like everything else in Haskell.
01:22:03 <radetsky> dmwit: wait, I thought the whole point of "x >> y" was to guarantee that x occurs before y
01:22:20 <radetsky> when does it not?
01:22:45 <dmwit> radetsky: Only the side effects of x are guaranteed to be evaluated before y.
01:22:56 <dmwit> > Just undefined >> Nothing
01:22:58 <lambdabot>  Nothing
01:23:04 <dmwit> > Nothing >> Just 3
01:23:05 <lambdabot>  Nothing
01:23:11 <dmwit> > undefined >> Just 3
01:23:12 <lambdabot>  Undefined
01:23:23 <wagle_home> > Just [1..] >> Nothing
01:23:24 <lambdabot>  Nothing
01:23:50 <nominolo> @hoogle (Monoid m, Traversable t) => (a -> m) -> t a -> m
01:23:51 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
01:23:51 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
01:23:51 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
01:23:55 <dmwit> The point being that we might not be forcing the entire value of the thing on the left; only enough to know what to do, as usual.
01:24:04 <radetsky> ahh
01:24:04 <radetsky> ok
01:24:48 <wagle_home> this prolly wont work:
01:24:49 <quicksilver> the side effects are not even guaranteed to occur, per se
01:24:58 <quicksilver> it's all up to the definition of the monad in question
01:24:59 <wagle_home> > Just Nothing >> Nothing
01:25:00 <lambdabot>  Nothing
01:25:34 <wagle_home> What the heck type was that?  o.O
01:25:42 <dmwit> Maybe (Maybe a)
01:26:02 <wagle_home> and Show was derived for Maybe a?
01:26:20 <dmwit> I think there's a (Show a => Show (Maybe a)) instance.
01:26:59 <wagle_home> > Just Nothing >> Just (Just Nothing)
01:26:59 <lambdabot>  Just (Just Nothing)
01:27:24 <wagle_home> > Just Nothing >> Just (Nothing)
01:27:24 <lambdabot>  Just Nothing
01:27:46 <wagle_home> :t Just Nothing
01:27:47 <lambdabot> forall a. Maybe (Maybe a)
01:27:59 <wagle_home> issa miracle!
01:28:23 <wagle_home> (sorry for the tangent)
01:29:06 * dolio imports Newer.Than.The.Third.Old.System.IO.That.Johan.Wrote.
01:30:15 <quicksilver> in the lazy state monad, for example, there is nothing to force side effects
01:30:20 <quicksilver> if you never inspect the state
01:31:22 <quicksilver> > evalState (modify (+1) >> modify (+1)) 0
01:31:22 <lambdabot>  ()
01:31:35 <quicksilver> here those side effects never happen, because we never inspect the value.
01:32:01 <quicksilver> however, the IO monad does force its side effects, and so do the failure monads (Either, Maybe)
01:32:41 <doserj> except for cases I don't dare to mention when quicksilver is in the room...
01:32:54 <wagle_home> so how do you tell in a monad forces or not?
01:33:09 <dmwit> Have a look at the implementation.
01:33:14 <doserj> wagle_home: the definition of (>>=)
01:33:58 <quicksilver> the point is, it's not an interesting general fact about monads that they force anything
01:34:06 <quicksilver> monads are quite orthogonal to strictness
01:34:12 <quicksilver> it's a *particular* fact about certain monds
01:34:13 <nominolo> is quicksilver ever not in the room? ;)
01:34:19 <quicksilver> no :)
01:34:26 <ricky_clarkson> He and Cale are a tag team.
01:34:38 <Cale> Hehe
01:35:23 <qwe> what is wrong here ?
01:35:24 <qwe> match (x:xs) (y:ys) n = if (x==y) then match xs ys n
01:35:24 <qwe>                           else
01:35:24 <qwe>                             if (n>0) than (match xs ys (n-1))
01:35:24 <qwe>                              else False
01:35:45 <qwe> i am getting unexpected word else
01:35:47 <dolio> "than"
01:35:54 <b_jonas> qwe: any base case?
01:36:07 <qwe> thanks
01:36:12 <qwe> it helped
01:36:16 <b_jonas> oh yeah, what dolio says
01:36:42 <dmwit> In the future, you should paste long code to hpaste.org.
01:36:49 <qwe> sorry
01:36:52 <dolio> @b52s
01:36:52 <lambdabot> Some say she's from Mars, or one of the seven stars that shine after 3:30 in the morning. WELL SHE ISN'T.
01:37:07 <wagle_home> s/than/then/
01:37:26 <wagle_home> dunno what n is
01:37:36 <wagle_home> oh
01:37:43 <quicksilver> yeah, in principle Cale and I don't overlap much
01:37:46 <quicksilver> so we tag team nicely
01:37:55 <quicksilver> in practice Cale doesn't sleep as much as me, so we overlap more :P
01:37:59 <Cale> hehe
01:38:27 <wagle_home> what?!?  you mean Cale and quicksilver arent the same entity?
01:38:56 <quicksilver> qwe: some people think if statements are ugly and would rather use guards
01:39:09 <quicksilver>  match (x:xs) (y:ys) n | x==y = match xs ys n
01:39:11 <dmwit> match xs ys n = length [(x, y) | x <- xs, y <- ys, x /= y] < n
01:39:21 <quicksilver>  match (x:xs) (y:ys) n | n > 0 = match xs ys (n-1)
01:39:31 <quicksilver>  match (x:xs) (y:ys) n | otherwise = False
01:39:37 <quicksilver> but, it's a matter of taste
01:39:42 <wagle_home> the second if has than instead of then
01:39:48 <quicksilver> (if that was a real file, I'd have lined up the = signs too)
01:39:48 <dmwit> Mine's better. ;-)
01:40:33 <quicksilver> well I think the quickest way of getting qwe's semantics is match l m n = False
01:40:34 <quicksilver> ;)
01:40:41 <wagle_home> dmwit: match [1..] [1..]
01:40:48 <Cale> qwe?
01:40:50 <wagle_home> dmwit: match [1..] [1..] 10
01:40:52 <Cale> oh
01:40:53 <Cale> hehe
01:40:59 <dmwit> wagle_home: mmm, quite
01:41:30 <dolio> When does Cale sleep? My sleeping tends to rotate through the day over time, but he always seems to be here when I am. :)
01:41:39 <quicksilver> the answer is in the IRC stats
01:41:44 <radetsky> Cale never sleeps
01:41:46 <Cale> dolio: My sleeping also rotates.
01:41:49 <quicksilver> if colour codes your time-of-day
01:41:53 <radetsky> sleep is for people who suck at haskell
01:42:08 <dolio> Cale: We must be synched up somehow. :)
01:42:12 <wagle_home> Cale uses a camera to stay in sync with you
01:42:23 <Cale> Much of the time I end up synching with Melbourne time.
01:42:37 <Cale> But every once in a while, I'll turn it back around
01:42:56 <quicksilver> http://www.cse.unsw.edu.au/~dons/irc/haskell-08.html
01:42:56 <lambdabot> Title: #haskell @ freenode.org stats by dons
01:43:13 <quicksilver> you can see that Cale is active in all four quadrants, but most sleepy in the green one
01:43:21 <quicksilver> I'm very consistently only the green and blue quadrants
01:43:23 <dolio> Heh.
01:43:26 <povman> radetsky: !(suck at haskell => sleep) === !sleep => !suck at haskell === people with insomnia must be fairly good haskell programmers
01:44:12 <quicksilver> dolio isn't even in the top 30, so we don't get to see his quadrants :P
01:44:21 <wvd> I hear SPJ only sleeps 1 hour a night and he can fly
01:44:32 <dolio> Yeah, I don't talk much. I lurk mostly.
01:45:01 <ricky_clarkson> He can't fly, he'd have to use Python for that.
01:45:10 <ricky_clarkson> Instead, he closes his eyes and teleports.
01:45:13 <povman> radetsky: or did you mean sleep => suck at haskell?
01:45:20 <wvd> right, I must be thinking of chuck norris again :P
01:45:22 <radetsky> povman: you got it
01:45:41 <quicksilver> everyone who went to Trinity can fly
01:45:42 <radetsky> otherwise the modus tollens doesn't work
01:45:46 <quicksilver> that's one of the perks.
01:46:04 <tibbe> :t ()
01:46:05 <lambdabot> ()
01:46:45 <dolio> :t 1
01:46:46 <lambdabot> forall t. (Num t) => t
01:46:48 <quicksilver> ricky_clarkson: as someone said on #haskell after that cartoon was released, if python lets you fly, haskell lets you fold space like a guild navigator
01:47:03 <wvd> what cartoon?
01:47:06 <dolio> @kind 1
01:47:06 <lambdabot> *
01:47:08 <ricky_clarkson> That would help SPJ to teleport.
01:47:34 <quicksilver> wvd: http://xkcd.com/353/
01:47:34 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:47:51 <ricky_clarkson> He doesn't really need to fly or teleport, because he's statically in the right place.
01:48:15 <tibbe> is it possible to instanceiate a function that is polymorphic in a with ()?
01:48:18 <tibbe> :t fold
01:48:19 <lambdabot> Not in scope: `fold'
01:48:22 <tibbe> :t foldl
01:48:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:48:25 <quicksilver> tibbe: yes.
01:48:28 <quicksilver> > id ()
01:48:30 <lambdabot>  ()
01:48:32 <quicksilver> tibbe: for example
01:48:36 <tibbe> say I had a side effect full foldl
01:48:41 <tibbe> so I want the seed to be ()
01:48:47 <tibbe> i.e. I don't care about it
01:48:48 <quicksilver> you don't have a side effect full foldl
01:48:51 <quicksilver> this is haskell
01:48:55 <quicksilver> there are no side effects
01:49:03 <quicksilver> maybe you want sequence_ ?
01:49:06 <dolio> He could have foldlM.
01:49:07 <tibbe> type Enumerator a = (a -> S.ByteString -> IO (Either a a)) -> a -> IO a
01:49:13 <tibbe> my own fold with side effects :)
01:49:15 <radetsky> this ... is ... HASKELLLLLL!!!!!
01:49:23 <quicksilver> sounds like foldM to me
01:49:26 <quicksilver> :t foldM
01:49:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
01:49:29 <tibbe> :t foldM
01:49:29 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
01:49:37 <tibbe> ok good
01:49:39 <wagle_home> foldl (,) () [1..5]
01:49:43 <quicksilver> but yes, of course you can use () ;)
01:49:44 <wagle_home> > foldl (,) () [1..5]
01:49:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
01:49:45 <lambdabot>       Expec...
01:49:52 <wagle_home> awww
01:49:54 <tibbe> so I want to write the (a -> b -> m a) function
01:49:56 <quicksilver> wagle_home: you can't instantiate (,) at a different type each time.
01:50:00 <quicksilver> wagle_home: shame :)
01:50:02 <radetsky> TONIGHT WE EVALUATE IN HELL!!!
01:50:17 <tibbe> quicksilver: Couldn't match expected type `a' against inferred type `()'
01:50:17 <tibbe>       `a' is a rigid type variable bound by
01:50:19 <dolio> If it's just for the side effects, and the seed is (), though, it's probably just mapM_
01:50:51 <wagle_home> > (1,(2,(3,(4,(5,())))))
01:50:51 <lambdabot>  (1,(2,(3,(4,(5,())))))
01:50:53 <radetsky> actually "BIND IN HELL" would be better
01:51:14 <tibbe> dolio: right but I get passed a foldM
01:51:16 <wagle_home> > foldr (,) () [1..5]
01:51:16 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
01:51:16 <lambdabot>       Expec...
01:51:29 <dolio> Oh, okay.
01:51:35 <tibbe> dolio: cause that is more general, I want to instanciate it with () just in this particular case
01:51:50 <wagle_home> :t (1,(2,(3,(4,(5,())))))
01:51:51 <lambdabot> forall t t1 t2 t3 t4. (Num t, Num t1, Num t2, Num t3, Num t4) => (t, (t1, (t2, (t3, (t4, ())))))
01:51:52 <tibbe> :t foldM
01:51:52 <dolio> Gotcha.
01:51:52 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
01:52:32 <tibbe> dolio: I get passed a foldM with [b] already applied so I try to give 'f' and 'z' and I want an 'f' with type () -> ByteString -> ()
01:52:50 <tibbe> dolio: sorry () -> ByteString -> Either () ()
01:52:55 <tibbe> argh
01:53:04 <tibbe> () -> ByteString -> IO (Either () ())
01:53:11 <tibbe> i.e. and Oleg enumerator
01:54:58 <quicksilver> tibbe: the error message you gave
01:55:06 <quicksilver> tibbe: says that you have already promised a is polymoprhic
01:55:11 <tibbe> oh
01:55:12 <quicksilver> tibbe: that's what "rigid type variable" means
01:55:17 <quicksilver> you are allowed to instance a with ()
01:55:24 <quicksilver> but not if you've promised tobe polymorphic ;)
01:55:27 <quicksilver> in your type signature
01:55:30 <quicksilver> (or by type inference)
01:56:06 <tibbe> I'll try to paste a slightly larger chunk
01:56:08 <tibbe> @paste
01:56:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:58:29 <tibbe> quicksilver: could you please look at that? it's a short snip
01:59:09 <quicksilver> look at what?
01:59:10 <quicksilver> ;)
02:00:19 <tibbe> hmm
02:00:23 <tibbe> announce didn't work
02:00:27 * wagle_home sees nothing
02:00:29 <quicksilver> the bot isn't here
02:00:34 <tibbe> quicksilver: http://hpaste.org/5499  -- that
02:00:37 <quicksilver> glguy: where's your bot, dude?
02:00:43 <rekso> Can you define datatypes interactively in ghci?
02:01:12 <tibbe> quicksilver: I have an idea what is wrong but I don't really get it
02:01:27 <tibbe> quicksilver: maybe I'm missing an forall
02:01:33 <quicksilver> tibbe: well it's a 'Response a'
02:01:36 <quicksilver> not a 'Response ()'
02:01:43 <quicksilver> if you want to fold it, you need to feed it an a
02:01:50 <quicksilver> unfortunately, you don't have an 'a' to fold it
02:01:52 <tibbe> for any a
02:01:59 <tibbe> I have a ()!
02:02:05 <quicksilver> no, you need an a
02:02:06 <quicksilver> not an ()
02:02:07 <tibbe> wasn't it supposed to be polymorphc ;)
02:02:17 <quicksilver> maybe you mean Handle -> Response () -> IO ()
02:02:26 <wvd> dammit, I have no idea what you guys are talking about
02:02:34 <wvd> clearly I am just too dumb for haskell
02:02:42 <tibbe> I mean, I feed map :: (a -> b) -> [a] -> [b] a particular a
02:02:46 <quicksilver> wvd: no, it's just a bunch of new stuff to absorb.
02:03:10 <wagle_home> yeah, whats the type of messagebody?
02:03:22 <quicksilver> tibbe: yes, but when you feed something to map, the two 'a's must match
02:03:37 <quicksilver> tibbe: similarly, with your Enumerator a, the two as must match
02:03:46 <tibbe> hmm
02:03:47 <quicksilver> tibbe: well, the 5 as actually :)
02:03:51 <tibbe> I'll try to digest that
02:03:54 <tibbe> heh
02:04:00 <quicksilver> either the only response you ever care about is ()-typed
02:04:01 <tibbe> I though I matched them all with ()
02:04:14 <quicksilver> sendReponse PROMISES to work with ANY a
02:04:23 <quicksilver> that's what sendResponse :: Handle -> Response a -> IO () means
02:04:38 <quicksilver> it means "give me a Handle, and give me a Response a, (for any a!) and I'll give you an IO ()"
02:04:48 <quicksilver> I wonder if you mean sendResponse :: Handle -> Response () -> IO ()
02:04:49 <quicksilver> personally
02:06:18 <wagle_home> :t (,)
02:06:20 <lambdabot> forall a b. a -> b -> (a, b)
02:06:52 <tibbe> quicksilver: for now
02:07:10 <tibbe> quicksilver: i.e. the server doesn't use any iteration state when processing the reply generated by the web app
02:07:22 <tibbe> quicksilver: however it might in the future like a bytesSent count
02:07:33 <quicksilver> then it's going to need a seed.
02:07:39 <quicksilver> you can't run an enumerator without a seed
02:07:48 <quicksilver> that's the nature of the enumerator type you've defined
02:08:04 <quicksilver> maybe sendResponse will have to take a seed as another parameter
02:08:09 <nominolo> @hoogle mapAccumM
02:08:09 <lambdabot> Data.Generics.Twins.gmapAccumM :: (Data d, Monad m) => (a -> d -> (a, m d)) -> a -> d -> (a, m d)
02:08:26 <quicksilver> sendResponse :: Handle -> Response a -> a -> IO a
02:08:49 <vincenz> tibbe: found it
02:09:04 <vincenz> tibbe: That shoul be "Response ()"
02:09:08 <vincenz> in sendResponse
02:09:09 <tibbe> vincenz: found what?
02:09:16 <tibbe> vincenz: ah yes, fixed already but thanks :)
02:09:28 <nominolo> @hoogle mapAccum
02:09:29 <lambdabot> Data.Map.mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
02:09:29 <lambdabot> Data.IntMap.mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
02:09:29 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:09:30 <tibbe> quicksilver: I can if the enumerator only depends on side effects in this case
02:10:01 <wagle_home> @hoogle a->b
02:10:02 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
02:10:02 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
02:10:02 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
02:10:37 <quicksilver> tibbe: well suppose it had a bytesSent count
02:10:42 <wagle_home> ... just when you thought your types were underpopulated
02:10:45 <quicksilver> tibbe: then it will need an initial value (presumably 0)
02:10:50 <tibbe> quicksilver: right
02:10:54 <quicksilver> tibbe: not () ;)
02:11:00 <tibbe> heh
02:11:03 <quicksilver> so you will need to pass the initial value to sendResponse
02:11:20 <tibbe> quicksilver: right
02:11:20 <quicksilver> so, sendResponse :: Handle -> Response a -> a -> IO a
02:11:25 <quicksilver> looks most likely to me
02:11:34 <quicksilver> with a shortcut sendResponse_ :: Handle -> Response () -> IO ()
02:11:37 <quicksilver> if you're so inclined
02:11:55 <tibbe> quicksilver: possible, depends on who is going to create and use the accumelated state, could be sendResponse itself
02:12:09 <quicksilver> no, it couldn't be
02:12:21 <quicksilver> sendResponse cannot possibly do that and remain polymorphic
02:12:28 <wagle_home> @hoogle a
02:12:28 <lambdabot> Prelude.abs :: Num a => a -> a
02:12:28 <lambdabot> Prelude.asin :: Floating a => a -> a
02:12:28 <lambdabot> Prelude.acos :: Floating a => a -> a
02:12:34 <quicksilver> it can't generate an initial value of polymorphic type a :P
02:12:52 <tibbe> quicksilver: but I'm a little bit confused
02:13:02 <tibbe> quicksilver: right
02:13:28 <wagle_home> @hoogle ()
02:13:29 <lambdabot> Did you mean: ()
02:13:29 <lambdabot> Prelude.undefined :: a
02:13:29 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
02:13:40 <tibbe> quicksilver: this enumerator is getting me all confused
02:13:40 <quicksilver> I think your enumerator type is odd
02:13:45 <tibbe> quicksilver: could be
02:13:54 <quicksilver> you're just reimplementing State by hand, it looks like
02:13:57 <tibbe> quicksilver: so basically the web app should return an enumerator over its response
02:14:01 <quicksilver> and I"m not sure with what goal in mind :)
02:14:13 <tibbe> quicksilver: not to have the app return a stream type
02:14:37 <tibbe> quicksilver: the idea is from oleg's enumerator interface paper but I might have implemented it incorrectly
02:14:55 <quicksilver> OK, I do understand
02:15:07 <quicksilver> the simplest enumerator it could return is
02:15:15 <quicksilver> (ByteString -> IO ()) -> IO ()
02:15:37 <ski> ContT () IO ByteString
02:15:43 <quicksilver> you've just threaded 'a's throught because of an intuition that the enumerator also wants some local state
02:15:45 <tibbe> quicksilver: right, what if the consumer wants to keep some state during the enumeration?
02:15:57 <tibbe> quicksilver: you could of course use IORefs or the like
02:15:59 <quicksilver> of course, really the enumerator might want any monad
02:16:02 <quicksilver> not just a state monad
02:16:04 <quicksilver> ...
02:16:39 <tibbe> quicksilver: so oleg's enumerators use :: (seed -> val -> seed) -> seed -> m seed
02:17:04 <tibbe> mine are the same except the iteratee has a monadic type and m = IO
02:18:11 <tibbe> quicksilver: so at least if the iteratee didn't have a monadic type then the passing around of the seed is neccesary
02:21:18 <quicksilver> yes, this is true
02:21:31 <quicksilver> and you have some annoyances if the inside and outside are using different monads
02:22:20 <tibbe> quicksilver: the typical use case here is when the web app wants to return a large file in a streaming fashion
02:23:04 <tibbe> quicksilver: it would read the file incrementally and pass it to the iteratee who would send it incrementally thus :: a -> ByteString -> IO (Either a a)
02:23:14 <tibbe> quicksilver: the Either is for premature termination
02:23:40 <ricky_clarkson> Then it shall be Abolished by the next Government.
02:24:23 <tibbe> quicksilver: another scenario is when the web server sends the client the input incrementally but the client wants to consume it all at once so it uses the iteration state to concatenate the given input into one big bytestring
02:25:54 <tibbe> quicksilver: the web server will ever only use the iterator returned from the web app at one type (probably ()) but it forces the web app to return a polymorphic enumerator so the server's implementation can change in case it wants to make use of the iteration state in some later version
02:26:22 <quicksilver> the more general type is probably
02:27:22 <quicksilver> (forall m t. MonadTrans t, Monad m) => ByteString -> t m () -> t IO ()
02:27:26 <quicksilver> oops
02:27:28 <quicksilver> missing (0
02:27:39 <quicksilver> ( (forall m t. MonadTrans t, Monad m) => ByteString -> t m () ) -> t IO ()
02:27:46 <quicksilver> hmm
02:27:49 <quicksilver> no, still not right
02:28:09 <quicksilver> MonadTrans t => ( (forall m .  Monad m) => ByteString -> t m () ) -> t IO ()
02:28:14 <tibbe> I guess you could always replace the iteration state with a state monad
02:28:23 <quicksilver> and your instance corresponds to t = StateT
02:28:25 <quicksilver> unfolded
02:29:33 <tibbe> quicksilver: but the no final value could ever be produced
02:29:41 <tibbe> quicksilver: since it's t IO ()
02:30:09 <tibbe> how could a value ever escape the iteration?
02:30:25 <tibbe> in the StateT transformer?
02:30:40 <ski> @unmtl StateT a IO ()
02:30:40 <lambdabot> a -> IO ((), a)
02:31:06 <tibbe> right
02:31:25 <tibbe> the type got very complicated all of a sudden :(
02:31:38 <tibbe> I was hoping to provide a simple interface for web app writers
02:32:13 <quicksilver> well you can simplify these in a variety of ways
02:32:18 <b_jonas> type getting complicated is normal in haskell
02:32:20 <quicksilver> and maybe your unfolded state is the best way to do it
02:32:35 <tibbe> you can always get a stream back from the enumerator
02:32:36 <quicksilver> what you have is just unfolded StateT IO
02:32:42 <tibbe> right
02:32:58 <quicksilver> seeing the correct abstract generalisation is an interesting exercise
02:33:04 <tibbe> absolutely
02:33:06 <quicksilver> even if you choose to implement a more specific type
02:33:18 <quicksilver> it's interesting to ask if the iteratee ever needs to do IO itself
02:33:24 <quicksilver> (the answer is proabbly yes, in your case)
02:33:28 <tibbe> yes
02:33:36 <quicksilver> or would it be nice to restrict the iteratee to some more limited monad?
02:33:39 <quicksilver> just a few constructs
02:33:44 <quicksilver> (a submonad of IO, in other words)
02:33:47 <tibbe> I was thinking about what interesting web apps you could write that didn't do IO, there are quite a few
02:35:06 <tibbe> basically the web app would be :: IO (Enumerator a)
02:35:19 <tibbe> i.e. do some initial IO then be a pure function
02:35:22 <wagle_home> > do { return [1..] ; return () } : IO ()
02:35:24 <lambdabot>   Not in scope: data constructor `IO'
02:35:27 <tibbe> (i.e. load some data to serve of disc)
02:35:35 <wagle_home> > do { return [1..] ; return () } :: IO ()
02:35:36 <lambdabot>  <IO ()>
02:36:42 <tibbe> quicksilver: alright, thanks a lot, time to get back to work :)
03:14:29 <povman> has anyone noticed how well the name 'microsoft evil' rolls off the tongue?
03:19:44 <Lemmih> povman: Without Microsoft most of GHC wouldn't exist.
03:21:16 <Cin_> @hoogle (m a -> m a -> m a) -> (a -> m a) -> a -> m a
03:21:17 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:21:51 <povman> Lemmih: I'm not implying they are evil, just that a product called 'evil' would be easy to pronounce :)
03:24:59 <quicksilver> Lemmih: I find that unlikely, although hard to prove.
03:25:10 <quicksilver> Lemmih: I imagine that, without microsoft, SPJ woudl have got a job somewhere else.
03:25:25 <quicksilver> perhaps he would have stayed in conventional academia
03:25:33 <quicksilver> 'what-if's are hard to make meaningful :P
03:26:55 <Lemmih> quicksilver: Well, you can't disprove it so it must be right.
03:27:30 * Lemmih heads out for a bit of worship.
03:27:46 * dolio is always amused when reddit people call augustss an idiot.
03:27:53 <vincenz> dolio: link?
03:28:25 <b_jonas> what? where?
03:28:30 <sizur> > [1,2] >>= \n-> n*2
03:28:31 <lambdabot>   add an instance declaration for (Num [b])
03:28:31 <lambdabot>     In the expression: n * 2
03:28:31 <lambdabot>     ...
03:28:36 <dolio> Well, this is the most recent I can think of: http://reddit.com/r/programming/info/67szi/comments/c033rr7
03:28:42 <quicksilver> dolio: 4chan people called me a haskellfag. Do I win something?
03:28:49 <sizur> > [1,2] >>= (\n-> n*2)
03:28:50 <lambdabot>   add an instance declaration for (Num [b])
03:28:50 <lambdabot>     In the expression: n * 2
03:28:50 <lambdabot>     ...
03:29:00 <sizur> > [1,2] >>= (\n-> [n*2])
03:29:01 <lambdabot>  [2,4]
03:29:01 <vincenz> dolio: the most recent you can think of? I thought something you just saw made you say that
03:29:29 <dolio> Well, I saw that earlier, but seeing the story again made me think of it.
03:30:05 <b_jonas> vincenz: that's quite recent
03:30:29 <dolio> But that's not like the first time it's happened or anything.
03:30:48 <vincenz> b_jonas: just sounded odd the way he phrased it
03:30:59 <b_jonas> if anyone on the internet can comment somewhere you should't be surprised that some people say stupid things
03:31:06 <b_jonas> it's got to happen somewhere
03:31:18 <dolio> Well, I'm not surprised. Just amused.
03:31:20 <b_jonas> just be glad that #haskell doesn't have too many such people
03:34:41 <shag> is the following assumption correct? on a 64bit system, all Word types (Word8, 16, 32, 64) are represented by a 64bit wide word internally in GHC
03:36:08 <b_jonas> shag: I wouldn't be sure
03:36:48 <b_jonas> on some 64-bit systems, 32-bit operations are more conveneint than 64-bit ones so the compiler might be useing those
03:36:53 <b_jonas> but I've no idea what ghc actually uses
03:36:57 <JaffaCake> shag: yes, pretty much
03:37:31 <shag> and the same is true for 32bit systems with all words (except word64) being represented as a 32 bit wide word?
03:37:39 <JaffaCake> right
03:37:45 <shag> ok, thanks
03:45:53 <Cin_> @src fix
03:45:53 <lambdabot> fix f = let x = f x in x
03:46:07 <Cin_> what does this mean?
03:46:29 <resiak> well, expand it out
03:46:30 <quicksilver> shag: GHC takes a nice approach to polymorphism
03:46:31 <opqdonut> fix f = f ( f ( f ( .... f undefined .... ) ) )
03:46:35 <Cin_> f applied to itself...
03:46:37 <Cale> Cin_: Well, another way to write that (which doesn't memoise quite as much) is  fix f = f (fix f)
03:46:38 <Cin_> yeah. when does it stop?
03:46:47 <quicksilver> shag: it means that that most kinds of thing are represented in the same way
03:46:49 <Cale> Cin_: It stops when f stops using its parameter
03:46:57 <Cin_> cale: ahhh, i see
03:47:01 <quicksilver> shag: so everything is eitehr a pointer, or a something else the same size as a pointer
03:47:14 <quicksilver> shag: at least, at one level that is true.
03:47:26 <rekso> > fix (+1)
03:47:27 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
03:47:29 <lambdabot>  3628800
03:47:29 <lambdabot>  Exception: <<loop>>
03:47:40 <shag> quicksilver: but that makes my application really inefficient when i just want to store single bytes ...
03:47:41 <Cale> > fix (1:)
03:47:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:47:49 <Cale> > fix (1 : map (+1))
03:47:50 <lambdabot>  Couldn't match expected type `[t]'
03:47:52 <quicksilver> shag: Yes. If you store enough bytes to care, use a ByteString.
03:47:57 <Cale> > fix ((1:) . map (+1))
03:47:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:48:01 <quicksilver> shag: but don't make the mistake of worrying unnecessarily :)
03:48:12 <MyCatVerbs> @index fi
03:48:12 <lambdabot> bzzt
03:48:13 <MyCatVerbs> @index fix
03:48:13 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
03:48:37 <Cale> Cin_: Basically, fix is what lets you write recursive things explicitly without naming them.
03:48:57 <shag> quicksilver: i have about 190,000 small lists where the vast majority just contains 1-4 Word8
03:49:15 <Cin_> cale: is it like a y combinator?
03:49:26 <quicksilver> it is related to the y combinator, yes
03:49:27 <Cale> It is a Y combinator.
03:49:36 <shag> quicksilver: and wasting 3 bytes on each of them is quite a lot
03:49:45 <desegnis> MyCatVerbs, it's in Data.Function today.
03:49:45 <quicksilver> shag: you're wasting so much more than that :)
03:49:52 <Cale> Also, note its potentially surprising type:
03:49:54 <Cale> :t fix
03:49:55 <lambdabot> forall a. (a -> a) -> a
03:50:14 <rekso> what's surprising about that?
03:50:20 <quicksilver> shag: a list of 4 Word8s takes up around 4*24 = 96 bytes, on a 64-bit system.
03:50:40 <Cale> rekso: Well, it's taking a function from a's to a's, and somehow magically producing a value of type a.
03:50:41 <quicksilver> and IIRC 4*16 = 64 on a 32 bit system but I'm not sure
03:50:46 <b_jonas> rekso: you don't see such a type in a strict language (at least not usefully)
03:51:00 <rekso> Cale: isn't that what a fixpoint operator *ought* to do though?
03:51:02 <MyCatVerbs> desegnis: "today"? You mean in 6.8.2?
03:51:06 <Cale> rekso: Indeed, it should.
03:51:09 <shag> quicksilver: yes, and if Word8 would be really just a byte, it would only take up 4 bytes. thats what i call overhead ;)
03:51:15 <desegnis> MyCatVerbs, er, I suppose so
03:51:19 * MyCatVerbs has 6.6.1 in university, 6.8.2 at home. :)
03:51:26 <quicksilver> shag: most of your overhead is in the list representation, though
03:51:37 <quicksilver> shag: only a small amount is in the word8 issue :P
03:51:45 <Cale> rekso: But under the types-as-theorems view of the Curry-Howard correspondence, this means that our logical system is inconsistent.
03:51:53 <Cale> Every theorem has a proof!
03:52:05 <Cale> (er, every statement has a proof)
03:52:10 <rekso> Cale: right, that's the difference between programming and logic!
03:52:12 <quicksilver> all types are inhabited
03:52:17 <shag> quicksilver: but i need the list representation, as i shuffle those lists around, splitting them and concatenating over and over
03:52:31 <resiak> so can't you use a logical system in which |- (a -> a) -> a ?
03:52:37 <quicksilver> of course you can
03:52:42 <quicksilver> but everything is a theorem
03:52:46 <quicksilver> so it's not very interesting :)
03:53:01 <Cale> rekso: Yes, so that's sort of what causes the surprise. Normally if you give someone a function a -> a, they might think they'd need a value of type a to begin with in order to apply the function.
03:53:10 <resiak> I'm sure I've seen proofs of that lemma in relatively sensible logical systems
03:53:25 <quicksilver> shag: then it may be the right way, and it may not be productive to worry about it
03:53:33 <quicksilver> shag: or you may play wiht bytestrings or something similar
03:53:43 <rekso> I probably get surprised by different things from most people. I know a fair amount of theory, so I can't really even remember what it feels like to be surprised by the fixpoint combinator. On the other hand, I find it pretty surprising that Haskell has three different ways to define a new datatype.
03:53:45 <quicksilver> resiak: you can prove X for any X.
03:53:59 <quicksilver> resiak: since X -> X is a theorem
03:54:04 <b_jonas> resko: which three?
03:54:06 <resiak> oh, d'oh, yes
03:54:08 <Cale> rekso: two, and one to produce aliases.
03:54:11 <quicksilver> resiak: so, then by (X -> X) -> X, we have X is a theorem
03:54:17 <resiak> i'm thinking of |- (~x -> x) -> x
03:54:25 <quicksilver> ah
03:54:35 <quicksilver> that's different ;)
03:54:39 * resiak gets more coffee and gets back to fixpoints and boolean lattices
03:54:40 <shag> i am thinking about bytestrings all the time, but as representing 1-2 word8 as bytesstring is even more inefficient as a [Word8] i need some way to crunch all the lists into just one bytestring
03:54:57 <quicksilver> right
03:54:59 <quicksilver> that would be the win
03:55:45 <b_jonas> let me count. there's applying tycons, data, newtype, and there are some really builtin tycons too which you can't define using these
03:56:07 <Cin_> and 'type'
03:56:21 <b_jonas> type just names a type I think.
03:56:51 <rekso> Yeah, I was just thinking of type, data and newtype. I expect there are clever things I don't know about yet, as well!
03:57:07 <rekso> (I take the point that 'type' doesn't really define a new type.)
03:57:14 <b_jonas> though there's also quantors and taking a fresh tycon variable if we want to count everything
03:57:22 <Cin_> sort of an alias?
03:57:29 <rekso> tycon is short for type constructor?
03:57:39 <b_jonas> resko: yes
03:58:54 <Cin_> bbl, getting a pie from the pie shop.
03:58:56 <b_jonas> I suppose with all those complications like data-where datatypes and stuff, I wouldn't even dare to give an integer on how many ways there are
03:59:13 <rekso> Can you actually define a new type by using type constructors?
03:59:41 <rekso> Oh, I think I see. Like [foo] is a type whenever foo is.
04:00:01 <b_jonas> yeah, like that
04:00:29 <wli> I'm sure there's some way to enumerate all possible type definitions of a given depth or AST size.
04:00:43 <Cale> I've been trying to get up the guts to learn how GHC works enough and implement proper record and variant types.
04:00:46 <wli> Up to alpha equivalence or some such.
04:00:50 <b_jonas> except when one of the two type constructors is actually just a synonym defined by 'type', then the application will be a synonym too I think
04:01:08 <dancor> i think a lot of code does like a = .., a' = .., a'' = .. and then it seems like ' typos can be very bad
04:01:15 <dancor> anyone have any thoughts on this
04:01:29 <dancor> let where the failure is
04:01:31 <Cale> dancor: It's better than reusing the same name.
04:01:34 <dancor> lIKE
04:01:52 <rekso> I must have my terminology muddled, I think. If I have data List a = Empty | Cons a (List a)   (or whaever the right syntax actually is) then "List" is called a type constructor? What are Empty and Cons called?
04:01:54 <dancor> but is it really like "you just need to learn to track 's really well"
04:02:03 <dancor> or can the style or language do better
04:02:07 <Cale> rekso: Data constructors
04:02:16 <rekso> Thanks Cale
04:02:59 <Cale> dancor: Well, I don't know. You shouldn't *overuse* primes.
04:03:04 <povman> http://reddit.com/r/programming/info/6710p/comments/c0314jn
04:03:36 <Cale> dancor: Try to give distinct letters, but sometimes it's just appropriate.
04:04:22 <dancor> i guess the alternative is a state monad but only when you have enough
04:04:25 <dancor> s/the/an
04:04:30 <quicksilver> right
04:04:41 <quicksilver> the state monad is the solution to the problem "oops I missed off a prime"
04:04:53 <quicksilver> which caused a notable GHC bug
04:04:55 <quicksilver> and some amusement
04:05:10 <dancor> the creation of haskell'?  zing
04:05:28 <quicksilver> but it is more boilerplate, unless you're careful, and of course only works if you're using it linearly
04:05:38 <quicksilver> (that's not quite true, since you can save old values explicitly with get)
04:06:04 <quicksilver> I agree with your suggestion it's a bad idea to overuse them
04:06:07 * dancor is going to write a ridiculous th solution instead.  what is hs if not a way to make your code beautiful to you and no one else
04:06:24 <quicksilver> often it suggests that there is something you could abstract
04:06:28 <quicksilver> go point-free on the s'
04:06:35 <quicksilver> either by the state monad or some simpler combinator
04:06:38 <quicksilver> like a monoid
04:06:39 <resiak> quicksilver: what was said notable bug ?
04:06:42 <quicksilver> (the -> monoid, maybe)
04:06:54 <quicksilver> resiak: almost total failure of a particular optimisation to fire
04:07:01 <resiak> ah!
04:09:36 <pejo> quicksilver, talking about constructor specializatin?
04:09:52 <quicksilver> pejo: I think so. I forget, exactly.
04:10:49 <EvilTerran> quicksilver, which -> monoid? reader or endo?
04:10:58 * EvilTerran reads some scrollback
04:11:04 <quicksilver> EvilTerran: endo
04:11:11 <quicksilver> EvilTerran: that's the most common one, IMO
04:11:29 <EvilTerran> mmm
04:11:41 <quicksilver> instead of let s' = foo s ; s'' = bar s' ; s''' = baz s'' in s'''
04:11:51 <quicksilver> you just write baz . bar . foo $ s
04:12:02 <quicksilver> OK, it's unlikely that someone would write precisely that
04:12:06 <quicksilver> but that's the general picture
04:12:19 <quicksilver> you can normally eliminate the primed variables with higher-order techniques
04:12:24 <quicksilver> of which "." is one of the simplest
04:12:32 * EvilTerran ponders... i guess one's the (r->) monoid and the other's the join(->) monoid
04:12:41 <quicksilver> yes
04:12:50 <EvilTerran> altho that's using type-level reader to define endo O.o
04:12:51 <quicksilver> and of course "." isn't restricted to true monoids
04:13:05 <quicksilver> it works with domino composition
04:13:18 <quicksilver> there's a name for that
04:13:26 <quicksilver> it's called a category :)
04:13:45 <b_jonas> domino... that always reminds me to matrix division
04:15:07 <quicksilver> yup
04:15:07 <dcoutts_> chr1s: you may need to set the pkg config path var so that gtk2hs can find gtk
04:15:16 <quicksilver> b_jonas: and funnily enough, that's a category too :)
04:15:32 <quicksilver> b_jonas: 'domino composition' is often used to describe matrix multiplication.
04:15:51 <rekso> Someone once told me that none of the monads in Haskell are actually monads in the categorical sense. Is there any truth in that?
04:16:01 <quicksilver> but anotehr way of saying that is that there is a category whose objects are numbers (dimension) and whose morphisms are matrices.
04:16:10 <quicksilver> rekso: erm well
04:16:20 <quicksilver> rekso: depends how scrupulously precise you're trying to be.
04:16:33 <quicksilver> there are a variey of ways you could be pedantic
04:16:38 <quicksilver> to claim they are not
04:16:53 <rekso> quicksilver: I can't remember who it was who said that, but I had the feeling he was making a fairly pedantic point. :-)
04:17:08 <quicksilver> For example, you can say that Hask isn't really a category
04:17:13 <quicksilver> for stupid reasons to do with seq
04:17:14 <rekso> !
04:17:16 <quicksilver> so that's strike 1
04:17:27 <dcoutts_> chr1s: gtk2hs's configure runs pkg-config --libs --cflags gtk+-2.0, so if you can adjust the PKG_CONFIG_PATH such that that works for you then it should also work for gtk2hs's ./configure script.
04:17:36 <quicksilver> If we get past that one, you can notice that lots of our monads don't satisfy the monad laws perfectly
04:17:50 <quicksilver> rather, they satisfy them up to some kind of isomorphism
04:18:04 <rekso> so they're really pseudomonads?
04:18:09 <quicksilver> however underlying each haskell monad there really is an honest-to-goodness monad
04:18:15 <quicksilver> and there really is a category
04:18:27 <quicksilver> it's just there is a slight mapping you have to make
04:18:35 <quicksilver> like restricting to terminating, total programs for example
04:18:54 <rekso> That sounds like a fairly radical restriction!
04:19:02 <quicksilver> so it's unhelpful to say they aren't monads. Because there are clearly monads involved.
04:19:10 <tibbe|away> is it possible to derive Show for a type with function fields?
04:19:14 <quicksilver> but it's true that if you want to be precise, you have to be careful.
04:19:16 <quicksilver> tibbe|away: no.
04:19:24 <rekso> Why can't it be a category with partial or nonterminating programs?
04:19:24 <quicksilver> tibbe|away: you can define it, of course
04:19:42 <tibbe|away> quicksilver: darn, it's a pain cause I want exactly the default except add <fun> or something for functions
04:19:49 <quicksilver> (although almost certainly not in a way which preserves the Read . Show invariant)
04:19:57 <quicksilver> tibbe|away: well, define Show for the function type first then
04:20:02 <quicksilver> tibbe|away: and then the deriving should go through.
04:20:10 <tibbe|away> quicksilver: ah
04:20:15 <rekso> I mean, there certainly *are* categories that include non-terminating programs as morphisms
04:20:25 <quicksilver> rekso: because that fails to be a category of the form we're interested in
04:20:35 <quicksilver> for a variety of reasons I don't have time to explain right now :)
04:20:41 <povman> Actually, integration of (some of) hs-plugins into GHC would make that possible....
04:20:57 <quicksilver> like, its products aren't products
04:21:03 <povman> and would be a whole lot of fun imo
04:21:07 <tibbe|away> quicksilver: gah, of course I can't write instance declarations for type synonyms!
04:21:22 <rekso> quicksilver: not cartesian closed, you mean?
04:22:59 <povman> (are there any plans on doing this?)
04:23:02 <EvilTerran> tibbe|away, i think the usual Show instance for functions is instance (Typeable a, Typeable b) => Show (a -> b) where show f = "<" ++ show (typeOf f) ++ ">"
04:23:02 <tibbe|away> quicksilver: well, I made a general instance for functions instead, I vaguely remember it's possible to get a Show instance for functions from somewhere though
04:23:06 <EvilTerran> tibbe|away, or something like that
04:23:26 <quicksilver> povman: I'm not sure what you mean. hs-plugins is already just a hook into ghc
04:23:26 <tibbe|away> EvilTerran: ah!
04:23:38 <quicksilver> povman: why would ghc integrate soemthign which just wraps its own abilities?
04:23:46 <quicksilver> rekso: http://www.haskell.org/pipermail/haskell-cafe/2008-January/037359.html
04:23:47 <lambdabot> Title: [Haskell-cafe] Basic question concerning the category Hask (was: concerning data ..., http://tinyurl.com/3d5hv6
04:23:53 <quicksilver> rekso: and http://www.haskell.org/pipermail/haskell-cafe/2008-January/037422.html
04:23:54 <lambdabot> Title: [Haskell-cafe] Basic question concerning the category Hask (was: concerning data ..., http://tinyurl.com/2v4gwm
04:23:56 <quicksilver> and following :)
04:24:05 <quicksilver> I don't have time to run through it now, I'm afraid. Real work to do too :)
04:25:29 <povman> quicksilver: i'm a dope :) but it would still be fun to have Show (a -> b) where show returns the actual code for the function
04:25:53 <quicksilver> it would not be referentially transparent
04:26:06 <quicksilver> but it might be interesting if you're prepared to break semantics for it.
04:26:45 <b_jonas> that would involve having a show for every type, for a function can be closure over any type
04:26:57 <quicksilver> depending what you mean by 'the code' it might also break separate compilation, too
04:27:13 <quicksilver> since 'the code' might not be available, if a function has been computed at runtime in one module and passed into another
04:27:23 <quicksilver> that's not insurmountable
04:27:27 <quicksilver> but it's an intersting challenge
04:27:36 <quicksilver> how deep do you want the rabbit hole to go?
04:27:51 <povman> a similar Read would make hs-plugins redundant :)
04:28:06 <FunctorSalad> quicksilver: hmm, why not just the source code?
04:28:08 <quicksilver> a similar Read would simply use the same things hs-plugins uses
04:28:14 <quicksilver> so it would *be* hs-plugins
04:28:18 <povman> exactly
04:28:29 <b_jonas> and the strange part starts once we have Eq for functions that solves the halting problem
04:28:32 <quicksilver> FunctorSalad: consider "foo = 5 + 3"
04:28:46 <quicksilver> what does "show foo" produce?
04:28:48 <povman> what would we lose by breaking semantics just in this instance?
04:29:00 <quicksilver> surely, it produces "8" ;)
04:29:01 <FunctorSalad> (for closures you could give the source code + bindings for the appropriate variables, which should be showable too)
04:29:09 <quicksilver> now, what about foo x = 5 + x
04:29:20 <b_jonas> > let { foo = 5 + 3; } in show foo
04:29:23 <lambdabot>  "8"
04:29:26 <quicksilver> show foo produces "\x -> 5 + x" ?
04:29:30 <quicksilver> what about
04:29:36 <quicksilver> show (\x -> foo x)
04:29:38 <pejo> b_jonas, there are weaker equalities that would still be useful in some circumstances.
04:29:46 <quicksilver> does that produce "\x -> foo x" ?
04:29:51 <quicksilver> or does it embed the source of foo?
04:30:20 <b_jonas> otoh some people have indeed experimented with pure languages where functions are serializable
04:30:31 <povman> quicksilver: can we unfold it right up to the y combinator?
04:30:32 <b_jonas> so that they can transfer them over the 'net for parallel computing
04:30:43 <quicksilver> povman: in principle we can, yes
04:30:43 <povman> (i'm talking out my ass)
04:30:46 <b_jonas> I've seen two examples of that
04:30:56 <rekso> quicksilver: thanks for the links, very interesting.
04:30:56 <FunctorSalad> quicksilver: hmm I see. though not expanding at all would be relatively safe, I guess
04:30:57 <quicksilver> we can unfold as much or as little as we want
04:31:14 <b_jonas> but I just don't like this kind of thing
04:31:28 <povman> unfolding completely would allow for some definition of Eq?
04:32:12 <b_jonas> I think allowing Eq for functions would break referential transparentiality really
04:32:31 <b_jonas> because Show could just omit details of the function if it doesn't want to show everything, but Eq can't do that
04:32:52 <FunctorSalad> b_jonas: wouldn't it also be pretty undecidable if you use the mathematical definition of function equality ;) (rather than source code equality)
04:32:57 <povman> including this feature would allow people to write really ugly programs and should be outlawed
04:33:03 <b_jonas> FunctorSalad: yep, sure
04:33:10 <pejo> b_jonas, isn't show . read = id?
04:33:14 <b_jonas> but you don't need to use that actually
04:33:36 <b_jonas> pejo: for some types if you have Read, yes
04:33:45 <Cale> pejo: That's common, but I wouldn't rely too strongly on it working for every instance.
04:34:12 <pejo> b_jonas, if show omits details that property goes.
04:34:23 <b_jonas> yeah
04:34:40 <quicksilver> there are two show invariants
04:34:44 <quicksilver> the read . show invariant
04:34:48 <quicksilver> and the copy-paste invariant
04:34:53 <quicksilver> I prefer to maintain both
04:34:54 <povman> i can imagine a non-evil version of function Show only buildable by 'deriving'
04:34:58 <quicksilver> if I'm not going to, I don't use Show
04:35:00 <b_jonas> copy-paste?
04:35:08 <quicksilver> use another typeclass like 'DebugRepresentation'
04:35:13 <quicksilver> (which I wish was a GHC builtin)
04:35:15 <FunctorSalad> > show $ read $ "1+1"
04:35:18 <lambdabot>  Exception: Prelude.read: no parse
04:35:30 <quicksilver> b_jonas: show should produce code which can be copy-pasted into an hs file
04:35:55 <dcoutts_> @seen nominolo
04:35:56 <lambdabot> nominolo is in #ghc and #haskell. I last heard nominolo speak 2h 26m 27s ago.
04:36:01 <FunctorSalad> > show $ read $ "01"
04:36:01 <lambdabot>  "1"
04:36:16 <povman> > id "01"
04:36:17 <lambdabot>  "01"
04:36:18 <nominolo> @arr!
04:36:18 <lambdabot> Smartly me lass
04:36:18 <FunctorSalad> pejo: did you really mean that order, or read . show?
04:36:27 <nominolo> whassup dcoutts_ ?
04:36:28 <quicksilver> > Data.Map.insert (1::Int) ("foo") Data.Map.empty
04:36:28 <lambdabot>   Not in scope: `Data.Map.empty'
04:36:31 <pejo> FS, doh!
04:36:32 <quicksilver> doh!
04:36:50 <quicksilver> that's odd. Why would Data.Map.empty not work?
04:36:54 <quicksilver> > empty
04:36:55 <lambdabot> Terminated
04:37:06 <quicksilver> b_jonas: anyhow, if you type that into ghci, you get
04:37:13 <mux> I think what's not working here is LB :-)
04:37:14 <dcoutts_> nominolo: I was looking at the Make monad stuff again, wondering if you might like to think about it / hack on it any time in the next week
04:37:17 <quicksilver> fromList [(1,"foo")]
04:37:22 <FunctorSalad> pejo: but you are right that read . show goes wrong if show drops information
04:37:26 <quicksilver> b_jonas: now, "fromList [(1,"foo")]" is valid haskell code
04:37:26 <b_jonas> > M.empty
04:37:27 <lambdabot>  fromList []
04:37:28 <dcoutts_> nominolo: oh, and any comments on the email I sent round
04:37:34 <quicksilver> b_jonas: which you can assign to a map variable
04:37:42 <quicksilver> > Data.Map.insert (1::Int) ("foo") M.empty
04:37:42 <lambdabot>   Not in scope: `Data.Map.insert'
04:37:47 <quicksilver> > M.insert (1::Int) ("foo") M.empty
04:37:48 <lambdabot>  fromList [(1,"foo")]
04:38:00 <quicksilver> modulo importing and namespacing
04:38:03 <dcoutts_> nominolo: I eliminated the Map constructor as you suggested. Now just fmap f x = pure f <*> x
04:38:04 <nominolo> dcoutts_: i think it's a good idea.  though an MSR internship might not be the right place to work on it, would it?
04:38:04 <b_jonas> quicksilver: yep
04:38:04 <quicksilver> so it's not flawless
04:38:07 <quicksilver> but the idea is there
04:38:19 <dcoutts_> nominolo: yeah, I'm not sure about that either
04:38:39 <b_jonas> but as ghci uses Show to output values for debugging, it might be useful to define Show for types (like functions) that you can't really Show well
04:38:50 <nominolo> dcoutts_: i suggested removing some constructor?  in the Make monad?
04:39:05 <nominolo> dcoutts_: haven't looked at the code in a long while
04:39:12 <b_jonas> even for functions a stub Show is useful so you can show structures of functions
04:39:20 <dcoutts_> nominolo: you did :-) you noted that the map/fmap constructor was redundant and you're quite right.
04:39:38 <Svrog> could someone tell me why the heap profiles for test1 and test2 in http://hpaste.org/5500 are so different?
04:39:46 <nominolo> dcoutts_: must've been my other me ;)
04:39:46 <b_jonas> like the one defined in Text.Show.Functions
04:40:10 <Svrog> one peaks at 10kb and the other at 6mb and i cant figure out why :(
04:40:12 <dcoutts_> nominolo: http://hpaste.org/5183
04:40:13 <nominolo> dcoutts_: oh, right for your deep embedding.  yeah
04:40:24 <dcoutts_> nominolo: that's what I pasted a while ago
04:40:31 <Cale> Svrog: Probably unevaluated expressions hanging around.
04:40:52 <Svrog> but IntMap.insert should be the same as IntMap.insertWith const
04:40:53 <dcoutts_> nominolo: so yeah, we can just encode fmap according to the standard definition
04:40:54 <Cale> Svrog: Try replacing the insertWith with insertWith'
04:41:12 <nominolo> @src fmap
04:41:12 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
04:41:42 <Cale> Err... oh, that doesn't exist for IntMap
04:41:48 <Svrog> yeah
04:41:51 <dcoutts_> nominolo: I'm thinking of adding a node Cached :: a -> Make m a -> Make m a
04:42:14 <Cale> Svrog: hmm, that's an upsetting omission from the API
04:42:39 <dcoutts_> @src liftM
04:42:39 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:43:02 <dcoutts_> there's that definition for fmap in terms of Monad, or the Applicative definition
04:43:20 <dcoutts_> @src <$>
04:43:20 <lambdabot> f <$> a = fmap f a
04:43:25 <Cale> heh
04:43:30 <Cale> @src liftA
04:43:30 <lambdabot> liftA f a = pure f <*> a
04:43:46 <nominolo> i just wonder how you use the default implementation of a one-method typeclass
04:44:11 <dcoutts_> nominolo: no, I just mean:
04:44:12 <nominolo> liftA = fmap?
04:44:12 <dcoutts_> instance Functor (Make m) where
04:44:12 <dcoutts_>   fmap f x = pure f <*> x
04:44:30 <tibbe|away> quicksilver: there's still something fishy with my Response a type
04:44:31 <nominolo> those names just get longer and longer ;)
04:45:28 <tibbe|away> quicksilver: what would be the different between 'Response a = Response { someFun :: a -> Int}' and 'Response = Response { someFun :: (forall a. a -> Int}'?
04:45:31 <nominolo> dcoutts_: i was just wondering if functor has a default implementation.  but that can't be
04:46:39 <Svrog> thanks Cale - i'll try Map instead of IntMap then
04:46:40 <dcoutts_> nominolo: no, it doesn't. I had a proposal to allow something like that, where Applicative could provide default implmentation for Functor
04:46:42 <Svrog> night
04:47:34 <nominolo> dcoutts_: but that would mean depending on Applicative
04:47:42 <tibbe|away> in general, what's the difference between: data Foo a = Foo a and data Foo = Foo (forall a. a) and is the latter even legal?
04:47:45 <nominolo> and that's probably not a good idea
04:47:56 <quicksilver> tibbe|away: in the first case you're specifying the a. In the secnd case, you're supplying a function which promise to work for any a.
04:48:01 <nominolo> tibbe|away: the latter is an existential type
04:48:25 <tibbe|away> quicksilver: I think I want the latter but I was using the former in my code
04:48:26 <nominolo> and you need not care about the a
04:48:35 <tibbe|away> nominolo: right
04:48:43 <quicksilver> tibbe|away: it may be you do. But I don't think you do.
04:48:51 <dcoutts_> nominolo: right, it'd let you write a Monad instance and get Functor and Applicative for free, that way we could make Functor and Applicative superclasses of Monad without breaking code. That was the idea.
04:49:00 <tibbe|away> nominolo: so if I wanted to pack up the 'map' function in a data type I would use an existential type?
04:49:16 <tibbe|away> quicksilver: why not?
04:49:37 <tibbe|away> quicksilver: otherwise the type of Response must be Response () everywhere
04:50:34 <dcoutts_> nominolo: http://hpaste.org/5183#a1
04:51:00 <quicksilver> I don't think it's very helpful to call them existential in general
04:51:04 <quicksilver> in general they are higher-rank types
04:51:12 <quicksilver> it's only in certain cases they behave existentially
04:52:29 <nominolo> dcoutts_: yes, we definitely need that.  but i have to think about it some more.  though, right now i don't have time for that.  i have a meeting in 1h and want to get things working as far as possible ;)
04:52:34 <tibbe|away> quicksilver: so if you would pack up 'map' in a data type it would be: data Foo = Foo (forall a b. (a -> b) -> [a] -> [b])
04:52:52 <dcoutts_> nominolo: np :-) later.
04:53:22 <quicksilver> tibbe|away: right.
04:53:25 <tibbe|away> quicksilver: what I'm carrying around in my response is a left fold that might be used at different types
04:53:40 <quicksilver> then yes, that is what you want
04:53:59 <tibbe|away> quicksilver: but I'm still a bit confused
04:54:30 <tibbe|away> quicksilver: I have to think some more
04:54:31 <vincenz> tibbe|away: data Foo = Foo (forall a.a) is only for bottoms
04:54:34 <vincenz> tibbe|away: otherwise you use
04:54:44 <vincenz> data Foo = Foo (forall a.(Class a) => a)
04:54:48 <vincenz> and those are existentials
04:55:03 <vincenz> though I think the syntax might be
04:55:07 <tibbe|away> vincenz: so I need Class if I want to pack up a map function?
04:55:18 <quicksilver> no, you don't
04:55:24 <quicksilver> vincenz's comments are confusing
04:55:28 <vincenz> quicksilver: are they?
04:55:30 <quicksilver> and only relevant to the precise type 'a'
04:55:39 <quicksilver> not to the more general iterator types you are talking about.
04:55:43 <vincenz> oh right
04:55:45 <vincenz> sorry, joined late
04:55:48 <quicksilver> ;)
04:55:51 <vincenz> however
04:56:00 <vincenz> you can't get your "a/b" from the Foo
04:56:09 <quicksilver> tibbe|away wants somethin like
04:56:35 <quicksilver> data Enumerator = Enumator (forall a . (a -> ByteString -> IO a) -> a -> IO a)
04:56:44 <tibbe|away> I should do a write up of my problem on -cafe
04:57:00 <vincenz> quicksilver: you need to put some constraint on 'a'
04:57:02 <vincenz> for instance Show
04:57:05 <quicksilver> no you don't
04:57:24 <quicksilver> well the only problem is you can't use the result
04:57:27 <vincenz> right
04:57:29 <quicksilver> but that's not a big problem
04:57:31 <vincenz> so show might be useful
04:57:33 <quicksilver> he doesn't care about the result
04:57:36 <vincenz> ah
04:57:37 <quicksilver> pretend its IO ()
04:57:41 <vincenz> ok
04:57:42 <quicksilver> or just >> return () it
04:57:54 <tibbe|away> quicksilver: would type Enumerator a = (a -> ByteString -> IO (Either a a)) -> a -> IO a be equivalent in terms of the forall?
04:57:55 <quicksilver> the a is just to thread through for the benefit of the iteratee
04:58:13 <quicksilver> it's not really very different
04:58:19 <quicksilver> it's just then you'd abstract out the forall later
04:58:21 <quicksilver> as in
04:58:21 <tibbe|away> quicksilver: well, I do want the a in the send
04:58:26 <quicksilver> (forall a . Enumerator a)
04:58:38 <tibbe|away> quicksilver: just like you want it in foldl
04:58:44 <quicksilver> if you think you might later want to tie down the a
04:58:45 <tibbe|away> *end
04:58:47 <quicksilver> then you can't forall it
04:58:50 <quicksilver> because you've lost it, then
04:59:02 <vincenz> tibbe|away: just to print it?
04:59:19 <tibbe|away> quicksilver: just like a tie down a and b in map I want to eventually tie down the a in the enumerator
04:59:27 <tibbe|away> vincenz: no, I need the real value
04:59:47 * vincenz nods
04:59:49 <tibbe|away> so what I pass around (as an enumerator) is essentially foldl'
05:00:01 <tibbe|away> foldl' can be applied at many types
05:00:20 <vincenz> sure, at compiletime
05:00:20 <tibbe|away> so I should be able to pass around enumerator and use it at many types and get back the value
05:00:28 <quicksilver> not quite what I meant by tie down ;)
05:00:38 <tibbe|away> vincenz: sure, that's fine, it only has to be decided at compile time
05:00:38 <quicksilver> but yes, I think you have it right now tibbe|away
05:00:44 <tibbe|away> quicksilver: hmm
05:00:48 <quicksilver> vincenz: that compile time comment is deceptive
05:01:00 <quicksilver> you can perfectly well pass around a truly polymorphic map, in haskell
05:01:04 <quicksilver> erm
05:01:05 <quicksilver> in GHC
05:01:07 <quicksilver> I should say :)
05:01:10 <quicksilver> not quite in haskell.
05:01:11 <tibbe|away> hmm
05:01:19 <b_jonas> what's this Enumerator that you keep talking about?
05:01:23 <tibbe|away> I should post the full code
05:01:25 <quicksilver> GHC even supports separate compilation
05:01:26 <tibbe|away> sec
05:02:02 <Cale> hehe, SPJ: "Since you are taking my name in vain, I had better respond!"
05:02:34 <pejo> Cale, heh, where did he say that?
05:02:57 <Cale> On the Haskell mailing list, in the Extensible records thread.
05:03:13 <tibbe|away> quicksilver: vincenz: http://darcs.johantibell.com/hyena/Hyena/
05:03:14 <lambdabot> Title: Index of /hyena/Hyena/
05:03:23 <tibbe|away> the code is in Application.hs and Server.hs
05:03:36 <tibbe|away> the client creates an enumerator for the result in HelloWorld.hs
05:04:04 <tibbe|away> the client's enumerator is polymorphic but the server wants to use it at a specific type ()
05:04:35 <fourbissime> hi there. I'm trying to use streams in order to compute the evolution of a differential equation (code here : http://hpaste.org/5501 ). "euler df x" is my approximation with euler method. "dc" is my differential equation. then I try to build the stream c, but obviously I'm missing something because I get a stack overflow.
05:05:19 <tibbe|away> quicksilver: vincenz: the compile error http://hpaste.org/5502
05:06:48 <Cale> fourbissime: you're using the tail of (c init fct) to define the tail of (c init fct) directly
05:06:49 <matthew_-> @seen Heffalump
05:06:50 <lambdabot> Heffalump is in #haskell and #darcs. I last heard Heffalump speak 15h 8m 26s ago.
05:07:06 <Cale> fourbissime: You need at least another cons in the way.
05:07:32 <jedbrown> fourbissime: You probably want to actually apply `dc'.
05:07:52 <_frederik_> is it possible to have ghci load a module without clearing all of the currently-defined variables?
05:07:58 <jedbrown> fourbissime: Assuming that you want c to evaluate to a time-series.
05:08:12 <shag> @pl (\a b -> a .|. (fromIntegral b))
05:08:12 <lambdabot> (. fromIntegral) . (.|.)
05:08:28 <Cale> _frederik_: Put the currently defined variables into a file, and load it :)
05:08:38 <_frederik_> Cale: so the answer is "no"
05:08:43 <Cale> _frederik_: right
05:08:54 <_frederik_> is there a good reason for that?
05:09:15 <_frederik_> it seems like an odd misfeature
05:09:26 <Cale> Well, it saves doing dependency analysis on the current set of definitions
05:09:36 <Cale> Or just reevaluating everything.
05:10:03 <_frederik_> but I can load a module with ":m + ..." and it doesn't clear the variables
05:10:04 <fourbissime> jedbrown: actually dc is supposed to go into the "fct" parameter.
05:10:21 <fourbissime> my naming is bad
05:10:50 <Cale> _frederik_: It's specifically reloading which is the issue, I think.
05:11:18 <jedbrown> fourbissime: I don't see where euler is used.  Where do you intend the time-step to actually take place?
05:11:24 <Cale> _frederik_: But mostly, what I do is just put definitions into the file I'm working on, and not into the GHCi session.
05:11:43 <_frederik_> Cale: so ghci is not interactive for you
05:11:45 <Cale> GHCi is really for evaluating expressions to test things.
05:11:50 <Cale> It's interactive enough.
05:11:55 <_frederik_> Cale: can i get :m to work on modules not appearing in a package?
05:11:58 <fourbissime> jedbrown: ... oh damn. I'm re-reading what I have posted. be back later.
05:12:04 <vincenz> tibbe|away: sendResponse?
05:12:16 <Cale> I don't know what you mean by that.
05:12:47 <tibbe|away> vincenz: well, as I change the type from Response a to Response () the type error moves :(
05:12:58 <vincenz> tibbe|away: I mean, where is it?
05:13:07 <_frederik_> i mean, i can use :m to load a package module and there is no clearing of the variables, but if i compile a module with 'ghc --make' and try to load it with :m then ghci says the module is not loaded
05:13:10 <Cin_> _frederik_: use :l <file.hs> or just the module name
05:13:17 <tibbe|away> vincenz: in Http.hs
05:13:33 <vincenz> tibbe|away: it's not on that website
05:13:33 <Cin_> _frederik_: oh
05:14:52 <Cale> _frederik_: My take on it is that it's basically just more trouble than it's worth to try to use GHCi to make new declarations, so you're better off putting them all in a file anyway.
05:15:33 <tibbe|away> vincenz: oops
05:15:36 <tibbe|away> vincenz: sec
05:15:49 <vincenz> tibbe|away: I think the issue is with Application
05:15:59 <_frederik_> Cale: yeah, it's just that they can't even be in multiple files.
05:16:01 <vincenz> tibbe|away: I think you don't really care about you're enumerator types inside application
05:16:06 <vincenz> you just want a bunch of enumerators
05:16:13 <Cale> _frederik_: Sure they can. Create a module which imports them.
05:16:21 <tibbe|away> vincenz: added
05:17:06 <tibbe|away> vincenz: what do you mena?
05:17:08 <tibbe|away> mean
05:17:25 <vincenz> erm
05:17:31 <vincenz> , messageBody :: Enumerator ()
05:17:36 <vincenz> shouldn't that be
05:17:40 <vincenz> messageBody :: Enumerator a
05:18:00 <vincenz> sendResponse :: Handle -> Response a -> IO ()
05:18:07 <_frederik_> Cale: trust me, it's annoying with my setup. as in, i already have a file which is sourced automatically, and if i want to load more modules after that then i have to do it by modifying this file
05:18:15 <vincenz> data Response a = {.... messageBody :: Enumerator a ..
05:18:16 <tibbe|away> well, if we start with Application.hs, in here the type of Enumerator must clearly be polymorphic
05:18:29 <vincenz> tibbe|away: Response should be polymorphic too
05:18:37 <tibbe|away> vincenz: it used to be
05:18:44 <Cale> _frederik_: I guess I don't understand what it is that you're trying to do.
05:18:59 <tibbe|away> vincenz: but it only pushes the error down, at some point it has to be instanciated at a particular type
05:19:10 <Cale> Mostly I think of ghci as a debugger.
05:19:22 <vincenz> tibbe|away: Can you explain Application?
05:19:26 <vincenz> tibbe|away: how does the 'a' go to a 'b'
05:19:37 <vincenz> tibbe|away: and if you look at helloworld, you don't even use 'a', so it's not bound
05:19:54 <_frederik_> Cale: i am writing a linear algebra system, which should be interactive, so i wrote a wrapper around ghci which loads all of the necessary libraries
05:20:17 <vincenz> newtype Application b = Application (forall a . Environ -> Enumerator a -> IO (Int, Headers, Enumerator b)
05:20:22 <vincenz> tibbe|away: what about something like that?
05:20:27 <vincenz> data Application b = Application (forall a . Environ -> Enumerator a -> IO (Int, Headers, Enumerator b)
05:20:32 <tibbe|away> vincenz: so hello could use a and make a into b using the Enumerator it outputs
05:20:33 <Cale> I suppose it also serves as a primitive UI of sorts, when you haven't yet gone to the trouble of implementing one yet.
05:20:50 <vincenz> tibbe|away: how can you make 'any' a into 'any' b
05:20:54 <vincenz> tibbe|away: that makes no sense
05:21:02 <tibbe|away> like in map :: (a -> b)
05:21:06 <_frederik_> Cale: how would i implement a better one? i think using ghci is the best way
05:21:09 <Cale> _frederik_: You might try using something like hs-plugins, it might give you the sort of control you want.
05:21:12 <tibbe|away> it shouldn't make any a into a b but a particular a
05:21:33 <tibbe|away> vincenz: Enumerator a is "just" foldl with the list partially applied
05:21:36 <_frederik_> Cale: ok thanks, i'll look more closely at that
05:22:00 <vincenz> tibbe|away: the fold of a map also has a -> b
05:22:01 <tibbe|away> vincenz: I think I need a forall a. somewhere
05:22:04 <vincenz> tibbe|away: but your enumerator is a -> a
05:22:13 <vincenz> and then suddenly your app is a b
05:22:15 <Cale> _frederik_: Or the GHC API directly, I don't know.
05:22:25 <vincenz> tibbe|away: your analogy is not making sense to me
05:22:35 <tibbe|away> vincenz: hmm, it might have the wrong type then :/
05:22:54 <vincenz> tibbe|away: an enumerator outputs stuff, right? and returns some value
05:23:06 <tibbe|away> vincenz: either or both
05:23:08 <_frederik_> Cale: when i last looked at the ghci api it seemed insufficient
05:23:11 <vincenz> right
05:23:13 <vincenz> well both
05:23:15 <vincenz> in the generic case
05:23:20 <tibbe|away> right
05:23:23 <tibbe|away> @type foldl'
05:23:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:23:29 <vincenz> tibbe|away: so tell me, how does an enumerator of 'a' go to an enumerator of b
05:23:41 <tibbe|away> foldl :: (a -> b -> a) -> a -> [b] -> a
05:24:03 <tibbe|away> it instansiated enumerator a at a particular type say INT
05:24:04 <tibbe|away> Int
05:24:26 <tibbe|away> returns an enumerator that the caller has to instantiate at a particular type
05:24:28 <Cale> _frederik_: The GHC API is most of GHC, so I suspect you could write any sort of application that needed to compile and manage Haskell code you'd want on top of it.
05:24:44 <tibbe|away> but forget the input enumerator in Application, the problem persists without it
05:24:48 <vincenz> tibbe|away: if you look at the hello world system
05:24:53 <vincenz> tibbe|away: I have no idea where that 'a' comes from
05:24:55 <vincenz> that seems like a forall a
05:25:03 <tibbe|away> yes probably
05:25:11 <vincenz> meaning you should pack the forall a inside application
05:25:13 <tibbe|away> that's what I think
05:25:27 <vincenz> at the top level
05:25:35 <tibbe|away> what would that look like?
05:25:49 <vincenz> is that a darcs repo?
05:25:54 <tibbe|away> yes
05:26:15 <vincenz> sec
05:26:25 <vincenz> tibbe|away: and I compile how?
05:26:26 <_frederik_> Cale: would the GHCI API allow implementing the dependency analysis that ghci lacks?
05:26:30 <_frederik_> sorry GHC
05:26:39 <tibbe|away> vincenz: let me check so the cabal file still works
05:26:54 <vincenz> ok
05:27:23 <Cale> Yeah, probably. I don't know it too well, but it gives you access to the frontend, the simplifier, compiler, and all that.
05:27:27 <tibbe|away> vincenz: just do a normal cabal configure and then build
05:28:23 <tibbe|away> vincenz: I think the b but not the a in Application should be existentially qualified
05:28:33 <tibbe|away> since it returns a function that should work at any b
05:28:41 <tibbe|away> but it uses a particular a
05:29:01 <vincenz> tibbe|away: look at your hello, your hello takes any a
05:29:02 <tibbe|away> i.e. it specified the a used in the input enumerator but not in the output enumerator
05:30:01 <tibbe|away> vincenz: right, it just happens not to use the input, the first a could be specified to  () say
05:30:05 <Cale> _frederik_: I don't know what would work best, but I suppose it's something to look at.
05:30:19 <tibbe|away> vincenz: look at sayHello, it is truely polymorphic
05:30:40 <tibbe|away> vincenz: it's a left fold (albeit only over one element for testing purposes)
05:30:53 <tibbe|away> vincenz: i.e. chunk is a hardcoded calue
05:30:54 <tibbe|away> value
05:31:15 <_frederik_> Cale: thanks
05:31:22 <nominolo> > const 42 <$ Just True
05:31:23 <lambdabot>  Add a type signature
05:31:30 <nominolo> > const 42 <$ Just True :: Maybe Int
05:31:30 <lambdabot>  Couldn't match expected type `Int' against inferred type `b -> t'
05:31:42 <nominolo> > (const 42 <$ Just True) :: Maybe Int
05:31:43 <lambdabot>  Couldn't match expected type `Int' against inferred type `b -> t'
05:31:56 <vincenz> tibbe|away: looking at 'run'
05:32:03 <nominolo> > const 42 `fmap` Just True :: Maybe Int
05:32:03 <lambdabot>  Just 42
05:32:24 <nominolo> > 42 <$ Just True :: Maybe Int
05:32:24 <lambdabot>  Just 42
05:32:30 <nominolo> > 42 <$ Nothing :: Maybe Int
05:32:31 <lambdabot>  Nothing
05:32:40 <GrayShade> 42 <$ Nothing
05:32:45 <GrayShade> > 42 <$ Nothing
05:32:45 <lambdabot>  Nothing
05:32:54 <tibbe|away> vincenz: in run input' is meant to be polymorphic in the same way sayHello was
05:33:00 <Cale> _frederik_: You might also look at the source code for GHCi, and see if you could do something about it. Really, my ideal-world solution would be to have something like a mathematica-style notebook interface for Haskell rather than a GHCi-like interface.
05:33:22 <Cale> (with automatically-distinguished declaration and expression cells)
05:33:24 <tibbe|away> vincenz: so one enumerator is enumerating the incoming bytes and one is enumerating the outgoing
05:34:41 <qwe> how with use of foldr i can chack if all numbers in the list are eqal
05:34:45 <qwe> eqaul
05:35:14 <ricky_clarkson> Why with foldr particularly?
05:35:31 <explisixjelly> i'm not sure if you can
05:35:31 <qwe> i am looking for some elegant way
05:35:42 <explisixjelly> :t foldr
05:35:42 <vincenz> tibbe|away: explain the Either?
05:35:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:35:45 <b_jonas> qwe: just check if all numbers in the tail are equal to the head
05:35:50 <qwe> arith (x:xs) = foldr (==) x xs
05:35:53 <qwe> like that ?
05:35:55 <_frederik_> Cale: i haven't used mathematica much yet. i think it would be nice to be able to construct an expression in ghci, and then have it spit out just those lines from the history which were needed to compute the expression
05:36:01 <b_jonas> (for tolerant comparision, check if the minumum equals to the maximum)
05:36:02 <Cale> and (zipWith (==) xs (drop 1 xs))
05:36:02 <ricky_clarkson> > foldr (==) 1 [True,True,True,True,True]
05:36:02 <lambdabot>   add an instance declaration for (Num Bool)
05:36:09 <tibbe|away> vincenz: escaping the iteration early if you don't want to consume the whole result
05:36:16 <ricky_clarkson> :t foldr
05:36:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:36:27 <ricky_clarkson> > foldr (==) True [True,True,True,True,True]
05:36:29 <lambdabot>  True
05:36:35 <tibbe|away> vincenz: the ideas are from http://okmij.org/ftp/papers/LL3-collections-enumerators.txt
05:36:42 <roconnor> @type \l -> all (zipWith (==) l (tail l))
05:36:43 <lambdabot>     Couldn't match expected type `a -> Bool'
05:36:43 <lambdabot>            against inferred type `[Bool]'
05:36:43 <lambdabot>     In the first argument of `all', namely `(zipWith (==) l (tail l))'
05:36:59 <roconnor> @type \l -> and (zipWith (==) l (tail l))
05:37:00 <lambdabot> forall a. (Eq a) => [a] -> Bool
05:37:01 <ricky_clarkson> > foldr (\x y -> if  (1,True) [True,True,True,True,True]
05:37:01 <lambdabot> Unbalanced parentheses
05:37:04 <ricky_clarkson> oops
05:37:07 <roconnor> @pl \l -> and (zipWith (==) l (tail l))
05:37:07 <lambdabot> and . ap (zipWith (==)) tail
05:37:15 <kronprinserik> heya!
05:37:18 <Cale> drop 1 is safer than tail
05:37:21 <roconnor> > and . ap (zipWith (==)) tail [1,1,1,1]
05:37:21 <lambdabot>  Couldn't match expected type `a -> [Bool]'
05:37:25 <Cale> kronprinserik: hello
05:37:26 <roconnor> > and . ap (zipWith (==)) tail $ [1,1,1,1]
05:37:27 <lambdabot>  True
05:37:29 <roconnor> > and . ap (zipWith (==)) tail $ [1,1,3,1]
05:37:30 <lambdabot>  False
05:37:32 <roconnor> > and . ap (zipWith (==)) tail $ []
05:37:32 <Cale> > and . ap (zipWith (==)) tail $ []
05:37:34 <lambdabot>  True
05:37:34 <lambdabot>  True
05:37:39 <Cale> mm, right :)
05:38:06 <roconnor> Cale: it doesn't crash :D
05:38:19 <roconnor> even though I'm using tail
05:38:24 <roconnor> I guess tail isn't as awful as head
05:38:28 <ricky_clarkson> > foldr (\x y -> if (snd x && (fst x==y)) then x else (fst x,False)) (1,) [1,1,1,1,1]
05:38:28 <lambdabot>  Parse error at ")" (column 71)
05:38:28 <Cale> roconnor: right, because it doesn't need it
05:38:39 <vincenz> tibbe|away: why do you care about these values?
05:38:40 <ricky_clarkson> > foldr (\x y -> if (snd x && (fst x==y)) then x else (fst x,False)) (1,True) [1,1,1,1,1]
05:38:40 <lambdabot>      Occurs check: cannot construct the infinite type: b = (b, Bool)
05:38:40 <lambdabot>       Ex...
05:38:45 <roconnor> > tail []
05:38:46 <lambdabot>  Exception: Prelude.tail: empty list
05:38:46 <vincenz> tibbe|away: don't you just need them while running but not at the end?
05:38:49 <roconnor> oh
05:38:51 <Cale> roconnor: zipWith (==) [] (tail []) won't evaluate the tail []
05:38:54 <roconnor> Cale: omg
05:39:07 <Cale> Which is lucky :)
05:39:10 <tibbe|away> vincenz: right now but not later, imagine that the server wants to count the number of bytes sent
05:39:26 <roconnor> Cale: I'm totally lucky  I didn't even realize that tail [] isn't []
05:39:35 <vincenz> tibbe|away: how would that ever work?
05:39:43 <tibbe|away> tibbe|away: it's in oleg's paper
05:39:45 <vincenz> tibbe|away: you'd have different enumerators, how are they able to string that int along?
05:39:56 <tibbe|away> vincenz: they're not
05:40:43 <ricky_clarkson> > foldr (\x y -> if (snd y && (fst y==x)) then y else (fst y,False)) (1,True) [1,1,1,1,1]
05:40:44 <lambdabot>  (1,True)
05:40:51 <tibbe|away> vincenz: do completeInput <- inputEnumerator BS.empty BS.append
05:40:51 <ricky_clarkson> > foldr (\x y -> if (snd y && (fst y==x)) then y else (fst y,False)) (1,True) [1,1,1,1,2]
05:40:52 <lambdabot>  (1,False)
05:40:56 <vincenz> tibbe|away: something feels fundamentally flawed, but I can't put my number on it
05:40:56 <ricky_clarkson> There, mine works too :)
05:41:01 <tibbe|away> vincenz: could consume the whole input to a string for example
05:41:01 <vincenz> erm
05:41:03 <vincenz> finger
05:41:26 <tibbe|away> vincenz: I really should do a minimal example but I can't do it here at work
05:41:30 * vincenz nods
05:42:46 <roconnor> > (\l -> and (zipWith (==) (tail l) l)) []
05:42:46 <lambdabot>  Exception: Prelude.tail: empty list
05:42:55 <roconnor> haskell is weird sometimes
05:43:20 <tibbe|away> vincenz: but basically you could do something like create the output enumerator in terms of the input enumerator
05:45:18 <Cin_> roconnor: weird sometimes and awesome the rest of the time, and by ``weird'' you mean ``awesome''? :P
05:45:28 <fourbissime> ok. obviously I don't understand something with streams. I can see that computing fibs with streams is really fast, but when I do this http://hpaste.org/5501#a1 it is fairly slow. I'm not quite sure to understand how it develops
05:46:27 <vincenz> tibbe|away: I can't give you more input atm
05:46:36 <tibbe|away> vincenz: the enumerators are no different than if the input and output were lists
05:46:42 <tibbe|away> vincenz: sure, thanks :)
05:46:57 <tibbe|away> vincenz: the enumerators are just inversion of control
05:47:09 <vincenz> tibbe|away: I know, but something feels wrong about the typing in it
05:47:17 <tibbe|away> o
05:47:18 <vincenz> (well obviously, given the error) but I can't quite put my finger on it
05:47:19 <tibbe|away> ok
05:47:43 <Cale> roconnor: Yeah, zipWith f is strict in its first parameter and conditionally lazy in the second.
05:48:07 <vincenz> tibbe|away: superficially it's obvious
05:48:14 <vincenz> sendResponse uses as last iterator an enumeartor ()
05:48:22 <vincenz> so you'll have to force your apps to be
05:48:25 <vincenz> App a ()
05:48:36 <tibbe|away> for App a (forall b. b)
05:48:40 <tibbe|away> or
05:49:04 <tibbe|away> I think that is the right answer
05:50:06 <tibbe|away> vincenz: dunno the syntax of forall though
05:50:16 <vincenz> Application (forall a. type)
05:50:17 <vincenz> or
05:50:23 <tibbe|away> type Application a = Environ -> Enumerator a -> IO (Int, Headers, (forall b. Enumerator b))
05:50:26 <vincenz> data Application = forall a. Application type
05:50:38 <tibbe|away> always at the top level?
05:50:45 <vincenz> tibbe|away: can't have foralls without a constructor
05:50:50 <tibbe|away> ah
05:50:52 <vincenz> afaik
05:51:03 <vincenz> they need to be 'locked up' :)
05:51:13 <vincenz> which \makes sense
05:51:15 <vincenz> you string along your enumerators
05:51:20 <vincenz> and then finally roll it up in an application
05:51:25 <vincenz> whose final enumerator you care not of
05:51:33 <tibbe|away> are you saying I must make it a proper data type?
05:51:39 <vincenz> for foralls, yes
05:51:53 <tibbe|away> what's the LANGUAGE pragma to enable that feature?
05:52:07 <roconnor> Cale: I suppose there have been looooong debates as to whether tail [] should return [] or not.
05:52:33 <vincenz> tibbe|away: ExistentialSomething
05:52:40 <vincenz> tibbe|away: ExistentialQuantification
05:52:45 <Cale> roconnor: I don't know, but probably at some point.
05:52:49 <tibbe|away> Rank2Types
05:52:57 <EvilTerran> they didn't strike me as being particularly long
05:53:26 <roconnor> EvilTerran: you know the debates?
05:53:45 <EvilTerran> i've seen it argued a few times in here
05:53:47 <quicksilver> roconnor: FWIW haskell gives us drop 1 and take 1
05:53:53 <quicksilver> as alternatives to head and tail
05:54:06 <quicksilver> which is a slightly funny way to look at it but I find them useful sometimes
05:54:12 <EvilTerran> there's only so muhc you can say about consistency vs totality. they're both good things.
05:54:24 * quicksilver is totally consistent.
05:54:28 <quicksilver> except when I'm not.
05:54:41 <jedbrown> > let step f dt (t,x) = (t + dt, x + dt * f t x) in head . dropWhile ((<1) . fst) $ iterate (step (\t x -> x) 0.00001) (0,1) -- <-- fourbissime
05:54:41 <lambdabot>  (1.0000099999980838,2.7182954198568656)
05:54:42 * Volatile is totally inconsistent. ;p
05:54:43 <Cin_> i think a simple graphical web browser would be fun to write in haskell
05:55:10 * EvilTerran is partially inconsistent
05:55:17 <EvilTerran> also inconsistently partial
05:55:18 <quicksilver> if you think the CSS box model is fun, you have a different idea of fun to me :)
05:55:24 * Cin_ is partial to inconsistency
05:55:32 <quicksilver> some of the parts of it would be fun, though
05:55:36 <ricky_clarkson> How can consistency be partial?
05:55:46 <quicksilver> you could do some nice layout combinators if you didn't care about being W3C compliant
05:55:49 <vincenz> ricky_clarkson: imagine rotten food
05:55:52 <tibbe|away> vincenz: fixed!
05:55:55 <vincenz> tibbe|away: oh?
05:55:58 <Cin_> quicksilver: yeah, i don't
05:56:03 <ricky_clarkson> vincenz: Yes?
05:56:03 <roconnor> > drop 0 []
05:56:04 <lambdabot>  []
05:56:05 <tibbe|away> vincenz: I'll push the fix, one sec
05:56:06 <Cale> Why do I feel so compelled to implement a language extension which I have no immediate use for?
05:56:07 <roconnor> > drop 1 []
05:56:08 <lambdabot>  []
05:56:31 <roconnor> > (\l -> and (zipWith (==) (drop 1 l) l)) []
05:56:32 <lambdabot>  True
05:56:39 <dolio> Cale: Records?
05:56:41 <Cale> (especially given that I have no real concrete idea of where to begin)
05:56:44 <quicksilver> Cale: call it fate
05:56:45 <Cale> dolio: yeah
05:57:10 <fourbissime> jedbrown: checking this.
05:57:22 <Cale> dolio: and variants, while I'm at it, since if I get as far as implementing records, the system which I want to implement makes variants easy.
05:57:23 <yondalf> you know algorithms like dijkstra's algorithm which are greedy and use a priority queue for correctness? are there any functional programming equivalents or should i just use a priority queue?
05:57:33 <dolio> Cale: Perhaps you're feeling an urge to shut up those smarmy OCaml folks. :)
05:57:41 <Cale> dolio: hehe
05:57:55 <jedbrown> fourbissime: Is computes `exp 1' by forward euler using a small time-step.
05:58:05 <ricky_clarkson> dolio: Isn't there only one?
05:58:06 <tibbe|away> vincenz: pushed
05:58:15 <Cale> yondalf: You could/should use a pure priority queue, but unfortunately, such a data structure isn't in the libraries included with GHC.
05:58:41 <dolio> ricky_clarkson: Well, there's one famous one, at least. :)
05:58:46 <yondalf> Cale: how would you implement, say, dijkstra's algorithm then?
05:58:58 <ricky_clarkson> dolio: I don't know that the rest are smarmy :)
05:59:33 <dolio> @quote JonHarrop
05:59:33 <lambdabot> JonHarrop says: As the Lispers always say, it is theoretically possible to do a good job but...
05:59:39 <tibbe|away> how can I write a Show instance for universally quantified functions?
05:59:49 <vincenz> tibbe|away: you need to have
05:59:54 <vincenz> forall a. Show a => a
06:00:10 <quicksilver> tibbe|away: universally quantified functions are not a first-class type in haskell
06:00:14 <Cin_> heh, all that jonharrop guy does is go on about f# on c.l.l
06:00:16 <quicksilver> tibbe|away: (not even with GHC extensions)
06:00:20 <tibbe|away> hmmm
06:00:26 <quicksilver> so you can't write any instances for them directly
06:00:32 <quicksilver> you'd have to wrap them in a constructor
06:00:34 <quicksilver> then you could.
06:00:38 <tibbe|away> quicksilver: can't I even have them show up as <fun> something?
06:00:50 <tibbe|away> hmm, ok
06:00:55 <tibbe|away> I guess it'll have to wait
06:00:56 <quicksilver> you wuoldn't be calling show on the higher rank object
06:01:02 <quicksilver> you'd be calling it on the *actual* object
06:01:06 <quicksilver> that would still work
06:01:07 <tibbe|away> right
06:01:11 <quicksilver> if the show constraint was there
06:01:12 <tibbe|away> that's fine
06:01:17 <tibbe|away> ok
06:01:21 <quicksilver> or can be proven
06:01:27 <Cale> yondalf: Well, there are a number of options. There's a lot of state transformation going on in that algorithm. You could handle it directly by passing around parameters.
06:01:50 <Cale> yondalf: Or you could save yourself a little trouble and use a simple State monad.
06:02:10 <tibbe|away> quicksilver: hmm so instance (forall a b. Show a, Show b) => (a -> b) where
06:02:10 <Cale> I'd probably use a Data.Set for my visited set.
06:02:20 <Cale> and a Data.Map to keep track of the known distances.
06:03:17 <yondalf> Cale: hmm...so you're suggesting programming in an iterative fashion then :-)
06:03:35 <Cale> yondalf: well, iterative, recursive, same thing :)
06:03:46 <Cale> I'm not recommending you write it in the IO monad :)
06:04:04 <Cale> A State monad translates away into pure code really simply.
06:04:20 <Cale> (in fact, it's implemented in a pure way)
06:04:51 <yondalf> Cale: yup...well, code in the IO monad is pure too :-)
06:05:07 <Cale> Sort of, if you look at it in a particular way :)
06:05:24 <yondalf> Cale: i was wondering if there was a better way than the priority queue one e.g. to take advantage of haskell's laziness
06:05:25 <Cale> It's code which constructs descriptions of stuff to do, in that sense it's pure :)
06:05:54 <Cale> Well, you might read the fgl paper and see if it has any ideas :)
06:06:09 <yondalf> Cale: what is the fgl paper?
06:06:28 <Cale> http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP01
06:06:29 <lambdabot> Title: Publication-Abstracts by Martin Erwig, http://tinyurl.com/2bmnd4
06:06:48 <Cale> That's what Data.Graph.Inductive is based on.
06:07:24 <Cale> Hmm, it doesn't seem to mention this problem specifically :)
06:07:54 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/src/Data-Graph-Inductive-Query-SP.html#dijkstra
06:07:55 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/268wp2
06:08:05 <Cale> (don't ask me how that code works :)
06:08:06 <yondalf> Cale: i'll take a look, thanks
06:08:37 <Cale> hmmm
06:08:38 <yondalf> Cale: actually i asked about dijkstra only because i thought of an algorithm which used the priority queue similar to the dijkstra's algorithm, but i'll look at what this paper says
06:08:58 <Cale> yondalf: Of course, the usual representations of graphs also work quite well.
06:09:28 <Cale> yondalf: The cost of purity, if you use appropriate Set and Map structures is only usually a log factor in time.
06:10:05 <yondalf> Cale: ok
06:12:33 <byorgey> @seen lambdabot
06:12:33 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #gentoo-uy, #curry, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #jtiger, #haskell-soc, #haskell-overflow, #scala, #haskell, #ghc
06:12:33 <lambdabot> and #darcs
06:13:05 <byorgey> someone should have \bot join #yi
06:13:16 <LeCamarade> @tell lambdabot Hi.
06:13:16 <lambdabot> Nice try ;)
06:13:21 <Cale> @join #yi
06:13:29 <quicksilver> the thing about a lazy priority queue is can you make the inserts lazy
06:13:31 <byorgey> thanks Cale =)
06:13:39 <LeCamarade> I expected a _|_!
06:13:39 <Cale> No problem :)
06:13:41 <Cale> @version
06:13:41 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
06:13:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:13:43 <quicksilver> is there anything to be gained by not maintainin gthe heap structure strictly at insert time
06:13:54 <quicksilver> and inserting 'lazily' at the time you pull items off
06:13:58 <quicksilver> (I don't know the answer)
06:14:21 <quicksilver> maybe you can acheive amortized O(1) insert instead of the normal O(log n)
06:14:37 <quicksilver> my guess would be 'no' though :)
06:15:01 <EvilTerran> @faq can you acheive amortized O(1) insert instead of the normal O(log n)?
06:15:02 <lambdabot> The answer is: Yes! Haskell can do that.
06:16:20 <Cale> One thing I don't understand is why despite there being a FingerTree implementation in base, for the purposes of Data.Seq, that same implementation isn't reused to implement a priority queue, even though it's absolutely trivial to do so.
06:16:52 <fourbissime> jedbrown: I already tried to use iterate in order to get my result. but with big values it will give me a stack overflow. So I guess I have to do something based on foldl' in order to reduce the expression at every step. am I right ?
06:16:58 <byorgey> Cale: submit a patch?
06:16:59 <EvilTerran> lazy priority queue: cycle [eat, sleep, pr0n]
06:17:07 <MarcWeber> dcoutts: Have you seen my patch link?
06:17:10 <EvilTerran> :D
06:17:27 <dcoutts_> MarcWeber: don't think I have
06:17:47 <MarcWeber> http://mawercer.de/package-conf-patch-register-sh apply this small fix to cabal please..
06:17:48 <BMeph> What? Have GHC patches now supplanted monad tutorials as the hallmark of a Haskell expert? ;)
06:18:02 <Cale> byorgey: Well, at the very least it, and all the other cool things you can do with fingertrees, should be in the Data.FingerTree which is available on hackage.
06:18:03 <MyCatVerbs> BMeph: no...
06:18:20 <MyCatVerbs> BMeph: monad tutorials are the hallmark of a Haskell journey(wo)?man
06:18:33 <Cale> (but they're not)
06:18:48 <MyCatVerbs> BMeph: GHC patches are the hallmark of a Haskell expert. :)
06:18:51 <scook0> BMeph: with any luck, we'll see GHC patches appearing on blogs all across the web!
06:18:55 <MyCatVerbs> Cale: hmmm?
06:19:04 <roconnor> quicksilver: drop 1 makes me happy.
06:19:19 <MyCatVerbs> scook0: oh yes, that would be awesome. GHC12 completed by this summer, entirely by the effort of reddit whores! ^_^
06:19:23 <roconnor> even if the 1 looks like an l.
06:19:31 <roconnor> drop 1 l
06:19:45 <Cale> MyCatVerbs: There's a package you can get on Hackage which implements a really cool general purpose pure data structure called a finger tree.
06:19:51 <roconnor> I have a shitty font.
06:19:53 <byorgey> Cale: seems reasonable.
06:20:04 <Cale> MyCatVerbs: It's also used as the implementation behind Data.Sequence in the libraries.
06:20:15 <GrayShade> Lemmih
06:20:28 <byorgey> Cale: maybe a good Hackathon project?
06:20:43 <MyCatVerbs> Cale: I have the paper on those around here somewhere. I really ought to get around to reading it some time soon.
06:20:49 <Cale> MyCatVerbs: You can also really easily implement fast priority queues, interval trees, and some other stuff :)
06:21:18 <byorgey> MyCatVerbs: you really should, it's a great paper.  The stuff they do with Monoids made me cry, it was so beautiful. =)
06:21:19 <quicksilver> roconnor: good :)
06:21:25 <fourbissime> anyways, thanks for help. later.
06:21:26 <byorgey> well, not really, but you get the idea
06:21:32 <scook0> FingerTree is amazingly versatile
06:22:09 <byorgey> MyCatVerbs: it's used as the data structure to store buffer contents in Yi.
06:23:18 <Lemmih> GrayShade: Yo?
06:23:40 <GrayShade> about AllIn..
06:24:32 <quicksilver> http://thecodist.com/fiche/thecodist/article/writing-multithreaded-code-is-like-juggling-chainsaws
06:24:32 <lambdabot> Title: the.codist{} - Writing Multithreaded Code Is Like Juggling Chainsaws, http://tinyurl.com/yq9ypd
06:24:37 <MyCatVerbs> byorgey: sweeeet.
06:24:53 <MyCatVerbs> byorgey, Cale: but, finish reading Okasaki's book first?
06:25:04 <Cale> I think the finger tree is the first data structure I've ever seen to be parametrised over an arbitrary monoid in that way. It makes me wonder what other places in the theory of datastructures might benefit from something like that.
06:25:55 <byorgey> MyCatVerbs: up to you, I don't know.  I've never read that book.  is it good?
06:26:28 <dcoutts_> MarcWeber: applied thanks.
06:26:41 <quicksilver> Cale: can you contrast that with 'just using lists' given that lists are a free monoid?
06:26:59 <MyCatVerbs> byorgey: pretty decent. Does a really good job of (sanely) analysing lazy structures.
06:27:17 <Cale> quicksilver: I suppose you could, yeah.
06:27:32 * osfameron remembers okasaki's book and wibbles with terror
06:27:43 <byorgey> MyCatVerbs: cool.  I will add it to my list of things to read, which unfortunately grows at a faster rate than I can actually read...
06:27:50 <MyCatVerbs> osfameron: oh yes, it's also kinda hard going and is slowing me down. :)
06:28:21 <Cale> I like how the element-containing nodes in the example fingertree in the paper spell out "this is not a tree"
06:28:24 <osfameron> MyCatVerbs: the first chapter seemed very readable, but after that got very over my head...
06:28:30 <FunctorSalad> @bot please join haskell-blah :)
06:28:30 <lambdabot> :)
06:28:40 <MyCatVerbs> byorgey: too true. I'm actually vaguely grateful that it takes an hour or so on the train to drop home every few weekends or so. Reading time without distractions!
06:28:46 <Cale> @join #haskell-blah
06:28:56 <FunctorSalad> thanks Cale
06:28:57 <sieni> @help botsnack
06:28:57 <lambdabot> botsnack. Feeds the bot a snack
06:29:01 <MyCatVerbs> osfameron: books like that, I usually read a chapter at a time, once a week.
06:29:19 <lambdabot> Cale: Thank you
06:29:29 * dylan usuall binge-reads books.
06:29:37 <MyCatVerbs> osfameron: then next week, reread the thing from the beginning (or from at least three or four chapters back, depending on length) to a point one chapter further than last time.
06:29:55 <MyCatVerbs> osfameron: gives it time to percolate. Seems to work, though it's really slow.
06:30:17 <MyCatVerbs> dylan: I try that, but there are a lot that I can't because I just get wedged.
06:31:14 * byorgey uses dylan's approach for fiction/history/etc., and MyCatVerb's for technical books, switching between modes in a more or less fractal pattern...
06:31:56 <vincenz> idem
06:32:07 <vincenz> sometimes I binge-read tech-books too, tho
06:32:12 <vincenz> like the "xxx schemer" series
06:32:17 <vincenz> that reads like a novel :)
06:32:23 <MyCatVerbs> byorgey: dylan's approach works fine for books that're (often not entirely thorough >_>) designed for fast reading too, though. Particularly rapid-acclimatisation guides, like O'Reilly books, for example.
06:32:38 <vincenz> MyCatVerbs: o'reilly boks are more references tho
06:32:46 <vincenz> MyCatVerbs: so that's' like reading a history book with only dates as a novel
06:32:49 <dylan> I tend to binge everything, though
06:32:59 <vincenz> dylan: same, except for my books on cat-theory
06:33:01 <dylan> including sleep
06:33:02 <MyCatVerbs> vincenz: not all of them are. I don't binge the references, for obvious reasons. :)
06:33:08 <quicksilver> not all o'reilly books are references
06:33:10 <vincenz> MyCatVerbs: uhuh, nerd!
06:33:18 <quicksilver> the perl 4 book (original camel) wasn't
06:33:21 <quicksilver> it was a story!
06:33:23 <quicksilver> most amusing
06:33:35 <vincenz> shouldn't the ocaml book have a camel?
06:33:49 <MyCatVerbs> vincenz: but the first half dozen chapters of "$foo in a nutshell" tend to be binge-readable, with a reference for the entire standard library wedged on the back (which I don't slurp!)
06:33:58 <MyCatVerbs> vincenz: why thank you very much. ^_^
06:34:09 <vincenz> MyCatVerbs: I was jking
06:34:15 <dylan> reading reference and dicionaries is fun.
06:34:23 <vincenz> dylan: especially while binging?
06:34:31 <MyCatVerbs> vincenz: well, to Heck with you. I took it as a compliment. Dammit. :(
06:34:35 <dylan> vincenz: yeah!
06:34:50 * vincenz binge read the lua book in a day
06:35:22 <osfameron> MyCatVerbs: yeah, I'm not being self-disciplined enough these days, but yeah, sounds like a technique
06:35:49 <tibbe|away> do all haskell compilers support 2-rank types?
06:36:10 <MyCatVerbs> osfameron: same. I'm lazy.
06:36:29 <MyCatVerbs> osfameron: 95% of the time, I read webcomics rather than anything useful. x_x
06:37:00 <osfameron> MyCatVerbs: I chat on IRC and watch old Doctor Who eps :-)
06:37:22 <MyCatVerbs> osfameron: well, at least your time wasting is classier than mine.
06:37:40 * MyCatVerbs hasn't even bothered to hunt down and watch the new Doctor Who, let alone the classics. :)
06:38:20 <osfameron> ;-)
06:41:24 <Cin_> so liftM f a is essentially a >>= f ?
06:41:29 <yondalf> are there any beginner introductions to finger trees? i can't seem to understand the paper yet...or should i just try harder?
06:42:39 <yondalf> Cin: no... f are different in both cases
06:43:14 <Cin_> oh
06:43:18 <quicksilver> Cin_: liftM f a is like a >>= f, but when "f" is not monadic
06:43:27 <Cin_> return f a
06:43:34 <quicksilver> Cin_: to be precise, liftM f a is precisely like a >>= return . f
06:43:49 <Cin_> yeah
06:43:54 <quicksilver> @src liftM
06:43:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:44:06 <quicksilver> @. pl src liftM
06:44:06 <lambdabot> (line 1, column 1):
06:44:06 <lambdabot> unexpected end of input
06:44:06 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
06:44:09 <quicksilver> bah
06:44:26 <quicksilver> @pl \f m1 -> do { x1 <- m1; return (f x1) }
06:44:26 <lambdabot> (line 1, column 13):
06:44:26 <lambdabot> unexpected "{"
06:44:26 <lambdabot> expecting variable, "(", operator or end of input
06:44:30 <quicksilver> @undo \f m1 -> do { x1 <- m1; return (f x1) }
06:44:31 <lambdabot> \ f m1 -> m1 >>= \ x1 -> return (f x1)
06:46:05 <EvilTerran> @. pl undo \f m1 -> do { x1 <- m1; return (f x1) }
06:46:06 <lambdabot> fmap
06:46:23 * MyCatVerbs gives EvilTerran a banana.
06:46:25 <EvilTerran> well played, \bot
06:46:34 <MyCatVerbs> @type liftM
06:46:34 <EvilTerran> banana! :D
06:46:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:46:46 <MyCatVerbs> @type \f m1 -> m1 >>= (return . f)
06:46:47 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
06:47:21 <MyCatVerbs> Alternatively, if you have combinators for some reason...
06:47:41 <MyCatVerbs> @type \f m1 -> m1 >>= (\a -> return (f a))
06:47:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
06:47:53 <MyCatVerbs> s/have/hate/
06:48:26 <EvilTerran> ?type (<=<)
06:48:27 <lambdabot> Not in scope: `<=<'
06:48:31 <EvilTerran> hmph.
06:48:47 <MyCatVerbs> I presume you didn't mean =<< there?
06:49:34 <EvilTerran> i definitely meant <=<. it's a 6.8 thing, tho, which'd explain why \b lacks it
06:49:43 <EvilTerran> (f <=< g) x = f =<< g x
06:50:05 <scook0> it's composition of (un-newtype'd) Kleisli arrows
06:50:09 <Cin_> makes sense
06:50:15 <EvilTerran> there's also >=>
06:50:16 <b_jonas> @type (=<<) -- is flip (>>=), right?
06:50:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
06:50:32 <scook0> yeah
06:50:32 <Cin_> evilterran: is it just called "the fish"? :P
06:50:46 <b_jonas> "fish" heh
06:51:00 <b_jonas> that's worse than the "spaceship" for <=>
06:51:12 <EvilTerran> and it means the axioms can be expressed very nicely as "return >=> f = f; m >>= return = m; (f >=> g) >=> h = f >=> (g >=> h)"
06:51:13 <Cin_> heh, it does look like a spaceship
06:51:29 <EvilTerran> i think it's called "monadic composition"
06:51:59 <EvilTerran> but "fish" is more fun
06:52:05 <scook0> it's also a nice walking-stick on the path to monadic enlightenment
06:52:35 <b_jonas> so how do you call >>= and >> then?
06:52:41 <b_jonas> "bind" and "then"?
06:52:55 <EvilTerran> yeah
06:53:11 * MyCatVerbs always thinks of them as "through" and "then".
06:53:12 <scook0> I don't recall ever hearing >> vocalised
06:53:23 <scook0> but "bind" seems to be the canonical name for >>=
06:53:40 <MyCatVerbs> scook0: nor me, but >> is trivial enough not to warrant mentioning.
06:53:57 <b_jonas> so =<< is "with"?
06:54:13 <MyCatVerbs> b_jonas: hmmm, good term.
06:54:18 <scook0> (>>) is a funny thing ... I like what it does in the list monad
06:54:20 <BMeph> Or "meet"? ;)
06:54:21 <quicksilver> ">>" is "then", or "and-then", or "then-do"
06:54:37 <quicksilver> I would read "=<<" as "bound from" or simply "from"
06:54:46 <matthew_-> it's cartestian product though in list monad isn't it?
06:54:54 <matthew_-> or at least ,that's the default impl
06:54:57 <b_jonas> wow, (=<<) is defined in the Prelude? I never knew
06:54:57 <quicksilver> glguy: where's da hpaste bot
06:55:04 <quicksilver> no, it's not cartesian product
06:55:13 <quicksilver> it has the cardinality of the cartesian product
06:55:17 <quicksilver> but not the values
06:55:17 <matthew_-> ahh ok.
06:55:21 <quicksilver> > [1,2] >> [3,4]
06:55:22 <lambdabot>  [3,4,3,4]
06:55:35 <matthew_-> err yes, indeed
06:55:45 <Cin_> is that useful?
06:55:53 <scook0> > filterM (const [False ..]) [1..5]
06:55:54 <lambdabot>  [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,3...
06:55:57 <scook0> Cin_: not really
06:55:59 <quicksilver> > [1,2] >>= \a -> [3,4] >>= \b -> return (a,b)
06:56:00 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
06:56:00 <scook0> I just like it
06:56:21 <scook0> > filterM (const [False ..]) [1..3]
06:56:22 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
06:56:36 <MyCatVerbs> :t [False ..]
06:56:36 <lambdabot> [Bool]
06:56:40 <MyCatVerbs> > [False ..]
06:56:40 <lambdabot>  [False,True]
06:56:56 <Cin_> i'm guessing that's from the Enum class?
06:57:02 <scook0> yeah
06:57:10 <b_jonas> @undo [False ..]
06:57:11 <lambdabot> [False ..]
06:57:14 <b_jonas> meh
06:57:19 <b_jonas> but it means enumFrom False
06:57:20 <scook0> I remember it from the "filterM/powerset/golf" discussions
06:57:28 <Cin_> ah, i see
06:58:18 <MyCatVerbs> scook0: that generates the list of all sublists of a given list?
06:58:32 <scook0> yep
06:58:51 <Cin_> looks like powerset
06:59:01 <MyCatVerbs> scook0: I'm bewildered as to how.
06:59:10 <scook0> it's the magic of the list monad
06:59:35 * EvilTerran knows how
06:59:40 <EvilTerran> ?src filterM
06:59:40 <lambdabot> Source not found. Where did you learn to type?
06:59:44 <EvilTerran> buu
06:59:52 <MyCatVerbs> scook0: rule 2, there is no magic. (Rule 1 was, "The universe is composed entirely of two substanes: magic and bullshit.")
06:59:55 <EvilTerran> ?type filterM -- you can infer the source
06:59:56 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:00:15 <scook0> MyCatVerbs: sufficiently advanced technology is indistinguishable from magic
07:00:56 <MyCatVerbs> scook0: that means you should investigate "magic" more thoroughly until you find the technology underneath. :)
07:01:12 <scook0> in a nutshell, the filter considers each list element to be both "in" and "not in" the resulting list
07:01:16 <mrd> pay no mind to the bot behind the curtain
07:01:28 <MyCatVerbs> scook0: not that you should give up when presented with what might be mind bogglingly arcane technology.
07:01:50 <MyCatVerbs> scook0: ahhh, thank you very much. Nice explaination. ^_^
07:02:09 <Cin_> i like "Dealing with failure is easy: work hard to improve. Success is also easy to handle: you've solved the wrong problem. Work hard to improve."
07:02:35 <MyCatVerbs> Cin_: for me, it highlights the opposite problem, though.
07:03:24 <MyCatVerbs> Cin_: the unspoken corollary is that lack of feedback is hard to handle - the path of least ambiguity being to set on fire the person whose responsibility giving feedback is supposed to be.
07:03:55 <MyCatVerbs> Cin_: and even then, that's still imperfect, with respect to ambiguity. They might think that you're setting them on fire for some other, completely unrelated reason.
07:04:10 <b_jonas> oh, I see
07:04:19 <b_jonas> nice
07:04:49 <MyCatVerbs> Cin_: well, in the short interval which is the union between the time that elapses after setting them on fire and the time in which they're capable of thought, that is. ;)
07:05:52 <nominolo> dcoutts: "M ./Distribution/Simple/Utils.hs -44 +1"  -44 ?
07:05:54 <Cin_> mycatverbs: 'tis a tough one
07:06:52 <nominolo> dcoutts: hm. it would be cool if the mailing list commit message could link to the full patch diff.  but i guess darcs doesn't provide this, does it?
07:08:01 <_frederik_> is it possible to have a default instance for classes other than Num?
07:08:04 <nominolo> dcoutts: oh, yes it does
07:09:04 <Cale> "* In zonking, do we need to zonk the kinds of coercion variables?"
07:09:14 <Cale> Presumably that means something to someone :)
07:09:16 <Cale> hehe
07:10:04 <dcoutts> nominolo: sure, it can include the full patch in the email
07:10:19 <nominolo> dcoutts: no it should just link to it
07:10:34 <nominolo> to avoid too much traffic
07:10:43 <dcoutts> nominolo: I'm not sure where the diff exists though, unless in a darcs web viewer
07:11:10 <nominolo> it does, for example: http://darcs.haskell.org/cabal/_darcs/patches/20080206014554-adfee-03782fce74dc09712e715b4bd1b08a8b0cd37139.gz
07:11:14 <lambdabot> http://tinyurl.com/2y5n93
07:11:50 <dcoutts> nominolo: oh, right, yeah I guess that's true. We could modify the script that generates the emails to include that.
07:12:04 <nominolo> dcoutts: i'll take a look later tonight
07:12:47 <dcoutts> nominolo: at the email generating script you mean?
07:12:53 <nominolo> yes
07:13:04 <nominolo> i'll take a look at your Make monad now
07:13:12 <dcoutts> oh right :-)
07:13:22 <dcoutts> I filled in the impl of reduce
07:13:25 <nominolo> dcoutts: gobby?
07:13:39 <nominolo> or is there a repo i should check out?
07:13:55 <Cale> doStupidChecks :: HsExpr TcId -> [([TcType], ThetaType)] -> TcM ()  -- hehe
07:14:16 <opqdonut> :D
07:14:26 <nominolo> GHC?
07:14:34 <Cale> The GHC guys have a sense of humour :)
07:14:43 <dcoutts> nominolo: hmm, I'm in my office atm.
07:14:43 <dcoutts> nominolo: the closest thing is the hpaste I linked earlier, it'a all one file
07:14:55 <quicksilver> Cale: was the zonk thing a ghc quote too?
07:14:58 <Cale> yeah
07:15:06 <nominolo> ok, then just re-paste / comment on the paste
07:15:15 <quicksilver> @remember GhcSource In zonking, do we need to zonk the kinds of coercion variables?
07:15:16 <lambdabot> I will remember.
07:15:17 <dcoutts> nominolo: and all I've added since is reduce which evals and adds Cached nodes at each level
07:16:02 <Cale> "zonk" is apparently a technical term in GHC. It shows up in a lot of names of identifiers.
07:16:17 <Cale> zonkTerm :: Term -> TcM Term
07:16:30 <Cale> "Zonking makes sure that the instance types are fully zonked."
07:16:35 <Cale> zonkInst :: Inst -> TcM Inst
07:16:53 <ehird`> i wonder how you could abuse guards in a crazily recursive way
07:16:54 <ehird`> :P
07:16:55 <quicksilver> I can applaud that as a truly worthwhile goal
07:17:10 <quicksilver> everyone would want instance types to be fully zonked
07:20:12 * byorgey zonks Cale
07:20:15 <Cale> Zonking has something to do with typechecking. Most of the occurrences of the word occur in compiler/typecheck
07:20:18 <nominolo> Cale: trying to add scoped labels?
07:20:38 * ehird` tries to write a fibonacci using guards
07:20:49 <Cale> nominolo: Well, for now, I'm just looking around and trying to find stuff that looks important for that sort of change.
07:20:51 <dcoutts> nominolo: http://hpaste.org/5183#a2
07:21:18 <ehird`> hmmmm
07:21:24 <ehird`> i think a fibonacci guard would be difficult
07:21:24 <ehird`> :)
07:21:26 <nominolo> Cale: i'd guess it's going to be a "crosscutting" aspect
07:22:12 <dcoutts> nominolo: so the important part is taking a half-reduced exp tree and seeing if the cached values are up to date.
07:22:35 <quicksilver> Cale: yes, of course, it's a shame GHC wasn't programmed in an aspect-oriented fashion.
07:22:36 <Cale> Yes, there are syntax changes at both the type and term level, type system changes, and then there's got to be some stuff dealing with translation into core.
07:22:38 <dcoutts> nominolo: I'm also not sure how to square this exp tree stuff with the fact that it has to be a graph not a tree, or at least a DAG.
07:22:46 <quicksilver> Cale: if it was, you could just just add a scoped labels aspect
07:22:51 <quicksilver> Cale: without understand the existing code at all
07:22:52 <Cale> quicksilver: :)
07:22:54 <quicksilver> </sarcasm>
07:23:00 <Cale> hehe
07:23:45 <Cale> To be honest I have no idea how records are going to be translated into core.
07:23:55 <nominolo> I aspect it to
07:23:58 <quicksilver> taht sounds like a more substantial objection to me
07:24:14 <nominolo> Cale: using some primitive hashing mechanism i suppose
07:24:31 <quicksilver> not what I would have guessed
07:24:40 <quicksilver> I'd have guessed you order the labels
07:24:44 <quicksilver> explicitly or implicitly
07:24:48 <quicksilver> and generate types from labels
07:25:13 <nominolo> dcoutts: i have to figure out (again) what the current code is doing
07:25:27 <quicksilver> { X = 5 , Y = 5 } has type Record[X|Y] Int Int
07:25:30 <quicksilver> sort of thing
07:25:33 <Cale> Yeah. I'm definitely going to want to keep all the labels in order. Multiple occurrences of the same label have to keep their order, so the stability of that sorting is important too :)
07:25:36 <dcoutts> nominolo: the stuff we wrote a couple months ago you mean?
07:25:47 <nominolo> no, this Make thing
07:25:53 <dcoutts> ah right
07:25:59 <dcoutts> that's easier, it's shorter
07:26:04 <nominolo> dcoutts: for examples the parameters to Prim ?
07:26:38 <dcoutts> nominolo: right, so a Prim is really an action in the underlying monad and those are the targets and dependencies that the action reads and writes.
07:27:13 <dcoutts> nominolo: Make is all about doing the right primitive actions at the right times, in the right order.
07:27:23 <quicksilver> staged monads!
07:27:57 <dcoutts> nominolo: the other Make constructors are just building expressions describing how we combine primitive actions
07:28:08 <dcoutts> and they obviously follow the structure of Applicative and Monad
07:28:41 <dcoutts> then eval is an interpreter for them, that turns it back into a monadic term
07:28:47 <nominolo> Cale: i wonder if the permutation rule of the TC could be used to infer physical indexes into the record data structure
07:29:29 <quicksilver> nominolo: my suggestion is that all the possible combinations of labels are, at the Core level, different types
07:29:54 <quicksilver> so Record[X|Y] is a binary type, Record[X|Y|Z] is a trinary one
07:30:00 <nominolo> right
07:30:05 <quicksilver> and the front-end is responsible for the implicit conversions
07:30:17 <nominolo> yes, that's a lot of types
07:30:18 <quicksilver> which allow you to project from X|Y|Z to X|Y
07:30:26 <quicksilver> doesn't matter, I don't think.
07:30:31 <Cale> Hmm, I wonder if it would suffice to implement records the same was as tuples at the core level.
07:30:33 <quicksilver> it's just symbols to munge
07:30:36 <Cale> That seems reasonable.
07:30:41 <Cale> way*
07:30:56 <quicksilver> well all data structures are 'the same as tuples'
07:31:02 <quicksilver> once you've erased the types
07:31:06 <quicksilver> but maybe that's not what you mean?
07:31:09 <Cale> kind of
07:31:15 <quicksilver> Core is pre type-erasure
07:31:22 <quicksilver> normally you expect lots of types areound at Core time
07:31:40 <nominolo> dcoutts: ok, so are we using an extra constructor for things that might generate new dependencies?
07:31:53 <dcoutts> nominolo: that's what Bind allows
07:32:14 <dcoutts> where as App does not
07:32:23 <dcoutts> so App is for static graphs, Bind for dynamic
07:32:55 <dcoutts> Bind says, we don't even know the structure of the resulting graph until we've reduced/evaluated the first bit
07:33:32 <nominolo> dcoutts: i se
07:33:33 <dcoutts> graph `Bind` \val -> mkAnotherGraph val
07:33:55 <nominolo> reminds me of Koen Claessen's parser combinators
07:34:23 <dcoutts> nominolo: so wherever we have a Bind that is not cached, then we do not know the complete graph
07:34:49 <nominolo> i see
07:35:15 <nominolo> it might be useful to distinguish <$> from <*> internally
07:35:45 <nominolo> oh, no, we don't need to
07:35:56 <nominolo> since we have a deep embedding -- we can pattern match
07:36:05 <dcoutts> right
07:36:17 <desegnis> Is someone here familiar with bos's bytestringparser (Attoparsec)? I'm digging into the source and I'm curious why it uses a chunked representation of bytestring input (S Strict.ByteString Lazy.ByteString ParsePosition), given that a lazy ByteString is chunked in exactly the same way already.
07:36:39 <ehird`> q: which vi-like editor is better for editing haskell right now? yi or vim?
07:36:45 <dcoutts> desegnis: perhaps it knows the current chunk is non-empty
07:36:52 <bos> desegnis: it avoids the extra indirection.
07:36:58 <opqdonut> ehird`: emacs's haskell-mode with vi-emulation ;)
07:37:00 <ehird`> and if vim, are there any fancy things i can stick into .vim to give me e.g. autoindentation?
07:37:02 <ehird`> opqdonut: :-)
07:37:18 <nominolo> dcoutts: btw, reduce doesn't typecheck
07:37:23 <quicksilver> there are haskell indentation modes for vim
07:37:31 <quicksilver> beware that haskell indentation is not really like other languages though :)
07:37:34 <dcoutts> nominolo: I wrote it from memory, it typechecked at home :-)
07:37:37 <quicksilver> there is more than one choice per line...
07:37:40 <tux_rocker> there was a mailing list post about Haskell vim lately, wasn't it?
07:37:46 <ehird`> quicksilver: of course, i know that :)
07:37:48 <desegnis> bos: does that mean it shall avoid nested constructors?
07:38:01 <ehird`> but i'm switching from emacs to vim due to general dislike
07:38:01 <desegnis> bos: for efficiency only?
07:38:01 <bos> yep.
07:38:09 <bos> yes, only for efficiency.
07:38:14 <desegnis> bos: alright, thanks!
07:38:26 <Cale> quicksilver: The point is that we'd probably want a flat representation for records anyway rather than one which involves some tree structure or something, so representing them at the value level in Core in the same way as other product types should be fine.
07:38:30 <bos> the first chunk is guaranteed to be non-empty.
07:38:32 <tux_rocker>    http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Vim
07:38:33 <lambdabot> Title: Applications and libraries/Program development - HaskellWiki, http://tinyurl.com/rolrs
07:38:35 <nominolo> dcoutts: ok. i'll figure it out
07:38:37 <Cale> quicksilver: Of course, I'm not sure about the details of how that looks :)
07:38:38 <tibbe|away> could someone please help me track down a type error I don't understand? http://hpaste.org/5503
07:38:39 <desegnis> ok
07:39:22 <quicksilver> Cale: yes, absolutely
07:39:34 <quicksilver> Cale: my Record[X|Y|Z] 3 4 5 was supposed to be flat
07:39:50 <quicksilver> Cale: "Record[X|Y|Z]" is a single constructor invented by the desugaring
07:39:54 <quicksilver> (and a single type)
07:40:00 <quicksilver> which in this case is a flat 3-tuple
07:40:17 <quicksilver> the desugaring invents many many such constructors for all combinations of labels you use.
07:40:40 <quicksilver> and you have to munge type information in there if you're allowed to have X::Int and X::Char in the same namespace
07:41:08 <nominolo> is the Morris source code free?
07:41:21 <quicksilver> "Record[X::Int|Y::Int|Z::Int]"  <-- flat constructor with type info munged in
07:41:52 <dcoutts> nominolo: http://hpaste.org/5183#a3 fixed.
07:42:40 <nominolo> dcoutts: ok, i fixed it the same way ;)
07:42:46 <dcoutts> good good :-)
07:43:01 <desegnis> tibbe|away: That's strange, it looks like ghc thinks S.ByteString and C.ByteString were different types
07:43:03 * Cale wonders if there's any magic flag to get GHC to dump literal rather than prettyprinted Core
07:43:21 <Cale> That would be rather instructive.
07:43:55 <tibbe|away> desegnis: are you sure that's the problem? there's a missing forall in one of the types
07:44:15 <desegnis> tibbe|away, oh right, I see that only now
07:44:28 <tibbe|away> desegnis: :)
07:47:22 <dynamix> how to write a guard for two parms?
07:47:32 <nominolo> dcoutts: in your caching you assume that any action is deterministic.  is this our fundamental assumption?
07:47:36 <Cale> f x y | x == y = ...
07:47:45 <Cale>       | otherwise = ...
07:47:58 <dcoutts> nominolo: mostly
07:48:00 <dynamix> func a b | a == 1 && b == 2 = True?
07:48:06 <Cale> Sure
07:48:13 <dynamix> thx
07:48:21 <dcoutts> nominolo: it is supposed to be a function of the values of it's dependencies
07:48:23 <Cale> In that case specifically though, you could do:
07:48:28 <Cale> func 1 2 = True
07:48:55 <nominolo> dcoutts: ok, but we need to invalidate the cache in some cases
07:48:57 <dcoutts> nominolo: though often we do not know the value of the deps, only labels for the values (eg targets as FilePaths)
07:49:02 <nominolo> (newer timestamp)
07:49:04 <dcoutts> nominolo: absolutely
07:49:40 <dcoutts> nominolo: so Targets probably are really some record with methods in the m monad that we can use to see if things are out of date.
07:49:54 <nominolo> yep
07:50:16 <dcoutts> nominolo: though I'm not sure if a timestamp is exactly the right thing, it makes sense with IO and files, but I was hoping for something more general
07:50:46 <nominolo> some action in some monad
07:50:53 <dcoutts> nominolo: and I've still not figured out the DAG thing, we need to represent the DAG explicitly I think
07:50:56 <nominolo> or, rather in 'm'
07:51:07 <dcoutts> where as what I've got now is just an expression tree
07:51:35 <dynamix> err.. f list1 number | _ (number > 3) = Nothing
07:51:38 * nominolo gets a tea
07:52:32 * tibbe|away doesn't get 2-rank types
07:53:52 <dcoutts> nominolo: obviously targets as labels allows us to represent the DAG explicitly but it's not clear to me how to merge that with the nice idea of tying the targets/deps together with the actions so they cannot get out of sync (ie no untracked deps).
07:53:52 <ehird`> http://tokyoenvious.xrea.jp/vim/indent/haskell.vim this seems a bit simplistic to handle all haskell indentation..
07:54:05 <matthew_-> grr. why does ghci put empty lines into the history?
07:54:42 <desegnis> tibbe|away: Sorry I don't get this either, but do you understand why the problem seems to be the ($!)?
07:55:15 <tibbe|away> desegnis: it's probably not the $! per say but the value returned that has the wrong type
07:56:43 <Cale> Heh, the class context allowed for data declarations is actually consistently referred to as "the stupid context" in GHC.
07:57:13 <allbery_b> at least it's honest
07:57:27 <Cale> dcStupidTheta :: ThetaType -- as reflected in this field of DataCon
07:59:11 * BMeph goes back to re-reading the Finger Trees paper...
07:59:17 <desegnis> tibbe|away: I meant that leaving ($!) out makes it compile
08:00:29 <dcoutts> nominolo: I gotta go teach OOP, catch you later
08:00:58 <tibbe|away> desegnis: ah!
08:00:59 <nominolo> bye
08:01:09 <tibbe|away> desegnis: I remember reading about this at some point
08:01:13 <tibbe|away> lets ask #haskell
08:01:27 <tibbe|away> dear #haskell, why does a 2-rank function work with $ but not with $! ?
08:01:48 <oerjan> tibbe|away: something similar to the way runST $ doesn't (or didn't use to) work, perhaps?
08:01:50 <Cale> tibbe|away: whoa...
08:02:02 <Cale> tibbe|away: rank2 functions work with $?
08:02:07 <desegnis> tibbe|away: it won't work with ($) either
08:02:56 <tibbe|away> desegnis: I thought you said it just did :)
08:03:15 <desegnis> tibbe|away: I said it will work if you leave ($!) out :)
08:03:21 <tibbe|away> oh
08:03:23 <oerjan> tibbe|away: as far as rank 2 types go, f x is _not_ the same as f $ x
08:03:24 <tibbe|away> that's what I meant ;)
08:03:32 <tibbe|away> read what I mean not what I write ;)
08:03:39 <tibbe|away> oerjan: right
08:03:47 <tibbe|away> oerjan: but I can make it work with seq?
08:04:42 * oerjan doesn't know
08:05:59 <quicksilver> Cale, oerjan: rank 2 functions work with $, yes.
08:06:05 <quicksilver> in certain restricted cases
08:06:09 <Cale> quicksilver: like runST?
08:06:10 <quicksilver> it is a 6.8.x feature
08:06:21 <quicksilver> it's the boxy impredicative inference
08:06:25 <quicksilver> from the paper of (almost) that name
08:06:33 <Cale> Oh, does that actually apply there?
08:06:38 <quicksilver> I believe so
08:06:38 <Cale> hmm
08:06:41 <quicksilver> there is a changelog not aboue it
08:06:51 <quicksilver> in either 6.8.1 or 6.8.2 changes file
08:07:38 <Cale> Prelude Control.Monad.ST Data.STRef> runST $ do r <- newSTRef 5; readSTRef r
08:07:38 <Cale> 5
08:07:49 <Cale> Cool :)
08:08:02 <Cale> of course, $! works just as well
08:08:19 <fasta> Cale: what is cool?
08:08:26 <fasta> Cale: oh, nm.
08:08:28 <Cale> $ works with runST now
08:08:38 <fasta> Cale: it doesn't work, imho.
08:08:45 <Cale> hm?
08:08:54 <fasta> Cale: future releases can break that behaviour.
08:08:55 <Cale> I just tried it and it does.
08:09:03 <Cale> ah
08:09:09 <fasta> Cale: as in the user guide
08:09:40 <Cale> Is this the brutal hack that wasn't going to be released, or is it something more systematic that they're still not certain about?
08:09:56 <Cale> I was pretty sure boxy types alone weren't going to fix it.
08:10:05 <fasta> I don't know what exactly you refer to.
08:10:10 <Cale> okay
08:10:16 <fasta> GHC is full of brutal hacks ;)
08:10:33 <int-e> Cale: it's asymmetric. (\x -> x (do r <- newSTRef 5; readSTRef r)) $ runST  doesn't work.
08:11:10 <Cale> int-e: ah, so that's not very nice already :)
08:13:58 <qwe> how i can by foldr check if number located at a list return true else false
08:15:13 <ricky_clarkson> qwe: How can a number return true or false?
08:15:17 <int-e> Cale: uhm. wait it's the lambda that breaks that, mumble. This doesn't work: let x $$ f = f x in (do r <- newSTRef 5; readSTRef r) $$ runST
08:15:44 <Lemmih> qwe: foldr (\a b -> a == 5 || b) False [1..10] ?
08:16:02 <Cale> int-e: ah, of course
08:17:52 <yondalf> :t &&
08:17:53 <lambdabot> parse error on input `&&'
08:17:58 <yondalf> :t (&&)
08:17:58 <lambdabot> Bool -> Bool -> Bool
08:18:10 <qwe> Lemmih 'a' here a number from a list but what for used b ?
08:18:30 <int-e> Cale: and that's bad because it's just a flipped version of ($) with its arguments flipped.
08:18:36 <Cale> int-e: right
08:18:56 <Cale> int-e: Clearly whatever magic is making that happen is not the true magic.
08:19:18 <Lemmih> qwe: 'b' is whether the number has been found in the rest of the list.
08:19:56 <qwe> 'b' is the result from the level before ?
08:20:06 <yondalf> :info get
08:20:16 <Cale> :t get
08:20:18 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
08:20:22 <yondalf> :src get
08:20:35 <yondalf> @src get
08:20:36 <lambdabot> Source not found. Where did you learn to type?
08:20:38 <Cale> yondalf: What get does, in a state monad is just to get the current state.
08:20:42 <Lemmih> qwe: It's from the level after.
08:21:06 <Cale> That is,  v <- get  will result in v being the current state
08:21:08 <oerjan> @src MonadState
08:21:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:21:11 <yondalf> Cale: where is it defined? i'm looking for more functions like that...i'm currently using a 6-tuple as state and wonder if there are better ways to get and put
08:21:12 <oerjan> gah
08:21:19 <Cale> Dually,  put v  will set the current state to v
08:21:23 <oerjan> @src State get
08:21:23 <lambdabot> Source not found.
08:21:36 <oerjan> yondalf: Control.Monad.State, anyhow
08:21:36 <yondalf> Cale: i know about gets, but are there other functions?
08:21:43 <Cale> Ah, you should probably build a bunch of specific named getters and setters.
08:21:53 <Cale> Control.Monad.State.Class
08:22:29 <Cale> Or else yeah, you could use gets and modify, together with appropriate functions
08:22:32 <oerjan> oh right
08:22:47 <Cale> You should probably use a record type rather than a 6-tuple
08:22:52 <yondalf> building a bunch of named setters seems like overkill
08:23:00 <yondalf> the record type gives me getters for free but not much else
08:23:01 <Cale> It could be :)
08:23:14 <yondalf> oh yeah...it gives me record syntax as well
08:24:49 <Cale> If you're only using the state monad for one algorithm, it's probably not worth writing lots of getters and setters. If it's the core of some library, you would want to newtype it (and use newtype deriving to get Functor and Monad instances) and add little details like that for manipulating the state.
08:25:19 <MyCatVerbs> It gets you setters, too. newfoo = foo { bar = baz, beedle = bleargh }
08:25:28 <dons> ?users
08:25:28 <lambdabot> Maximum users seen in #haskell: 471, currently: 436 (92.6%), active: 19 (4.4%)
08:25:38 <yondalf> MyCatVerbs: yup, that's what i meant by record syntax, but thanks anyway
08:25:49 <byorgey> yondalf: depending how far you're willing to go, you can use functional references and Template Haskell to generate nice getters and setters for records.
08:25:49 <azmo> does anyone know why this small program behaves differently (wrong) when compiled compared to interpreted? http://hpaste.org/5505
08:25:53 <byorgey> yondalf: http://code.haskell.org/category/
08:25:53 <yondalf> Cale: it's only for one algorithm so i'll just stick with the 6-tuple for now
08:25:54 <lambdabot> Title: Index of /category
08:26:16 * byorgey shudders at the thought of a 6-tuple  ;)
08:26:46 * yondalf shudders at the thought of template haskell :-)
08:27:12 <yondalf> nah...i'm still new to all these so i'll stick to plain haskell98 for now
08:27:12 <ricky_clarkson> Scala has built-in support for up to 22-tuples, presumably because the type system isn't good enough to just have n-tuples in general :)
08:27:48 <bos> well, see how many tuples you can do useful things with in ghc before it runs out of steam.
08:28:08 <Cale> ricky_clarkson: well, we only have instances of various classes for up to n-tuples for various finite n :)
08:28:15 <Cale> I think the limit is 15 on lots of things.
08:28:17 <oerjan> azmo: could it be a flushing issue?
08:28:18 <ricky_clarkson> ah
08:28:19 <bos> where n is usually 7.
08:28:47 <oerjan> (line vs. char buffering)
08:28:55 <azmo> oerjan: thanks. i'll try it.
08:28:55 <Cale> If you have more than a handful of fields, you really should not be using a tuple anymore :)
08:29:07 <Cale> Make a datatype and name those fields :)
08:29:57 <Cale> azmo: I know what it is :)
08:30:45 <Cale> azmo: Try sticking a \n after the \a in beep
08:30:49 <wli> You should be able to lazily generate instances with some compiler magic. Maybe template Haskell can do it.
08:30:53 <Cale> and watch the difference :)
08:31:21 <oerjan> :t hFlush stdout
08:31:23 <lambdabot> Not in scope: `hFlush'
08:31:23 <lambdabot> Not in scope: `stdout'
08:31:26 <Cale> azmo: You actually need to make sure that output buffering is turned off to make that work, or flush the buffer specifically after each beep
08:31:34 <azmo> Cale: ah, yes, i see it now. but flushing works better, since i do not want newlines :)
08:31:37 <oerjan> :t System.IO.hFlush System.IO.stdout
08:31:38 <lambdabot> IO ()
08:31:40 <Cale> hSetBuffering stdout NoBuffering
08:31:47 <glen_quagmire> > IO ()
08:31:48 <lambdabot>   Not in scope: data constructor `IO'
08:31:55 <Cale> will turn off buffering entirely (just stick it at the start of your program)
08:32:07 <azmo> cale: ok
08:32:22 <Cale> (you could flush as well, if you want to keep buffering)
08:37:49 <pchiusano> does haskell support higher-order polymorphism?
08:39:41 <pchiusano> this is probably an obvious question...
08:40:09 <swiert> pchiusano: it kind of depends on what you mean...
08:40:09 <byorgey> pchiusano: what do you mean by higher-order polymorphism?
08:40:18 <swiert> byorgey: jinx!
08:40:46 * byorgey finds himself inexplicably unable to speak
08:40:51 <swiert> pchiusano: yes, you can be polymorphic wrt to type constructors, for example.
08:40:53 <pchiusano> like, if I have a type: Tree a
08:41:47 <swiert> +v byorgey
08:41:48 <pchiusano> hmm, I am struggling to thing of a good example now
08:41:54 <byorgey> ahh
08:42:00 <pchiusano> but basically, yeah, I mean abstracting over type constructors
08:42:22 <Cale> pchiusano: possibly you could write an instance of Functor for your Tree a type
08:42:32 <Cale> fmap :: (Functor f) => (a -> b) -> (f a -> f b)
08:42:47 <Cale> You'd write:
08:42:51 <Cale> instance Functor Tree where
08:43:04 <Cale>    fmap f (Leaf x) = Leaf f x
08:43:06 <Cale>    ...
08:43:12 <Cale> er
08:43:15 <Cale> Leaf (f x)
08:43:29 <Cale> But you get the idea.
08:43:56 <Cale> Monads are similar in this respect, of course.
08:47:03 <dons> dcoutts:
08:47:05 <dons> "Doing a local get of the GHC repository, best of three trials, takes 2
08:47:05 <dons> minutes and 15 seconds (--disable-bytestring) and 1 minute 57 seconds
08:47:05 <dons> (Data.ByteString).  This is a 13% improvement"
08:47:12 <dons> darcs + bytestrings = woot :)
08:47:54 <mux> yay
08:48:00 <mux> darcs 2 is very very yummy
08:48:37 <dons> http://reddit.com/r/programming/info/67v5o/comments/ mmm.
08:49:21 <pchiusano> like, okay, how would I type the function: f :: a -> (t _) -> t a
08:49:45 <Cale> pchiusano: What would it do?
08:49:51 <pchiusano> by that I mean, a function f that takes an a and a type constructor t, and returns a value of type (t a)
08:50:09 <oerjan> pchiusano: how would you write such a function if you could type it?
08:50:25 <pchiusano> how would I write it?
08:50:44 <Cale> pchiusano: That's not necessarily possible to write in full generality like that
08:51:05 <oerjan> without a class restriction on t, there isn't necessarily any particular way to construct a t
08:51:06 <Cale> It would probably have type  a -> t a  if it were
08:51:44 <pchiusano> oh okay, so I would need to use typeclasses
08:51:46 <wli> f :: Injective i => t -> i t
08:51:47 <oerjan> in ghc you can even have types with no non-bottom values at all
08:51:56 <pchiusano> so the type, t, would have to be a member of that type class
08:52:00 <pchiusano> ?
08:52:09 <oerjan> yep
08:52:09 <Cale> pchiusano: The type constructor t, yeah
08:52:16 <Cale> class Pointed t where
08:52:19 <oerjan> Applicative and Monad would both work
08:52:29 <Cale>    unit :: a -> t a
08:52:34 <oerjan> (pure and return respectively)
08:52:49 <oerjan> but there is no builtin class like Pointed i think
08:53:08 <Cale> right
08:53:13 <pchiusano> oerjan: can you explain "Applicative and Monad would both work"
08:53:14 <Cale> I just made that up
08:53:25 <Cale> @src Applicative
08:53:25 <lambdabot> class Functor f => Applicative f where
08:53:25 <lambdabot>     pure  :: a -> f a
08:53:25 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
08:53:29 <Cale> @src Monad
08:53:29 <lambdabot> class  Monad m  where
08:53:29 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:53:29 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:53:29 <lambdabot>     return      :: a -> m a
08:53:31 <lambdabot>     fail        :: String -> m a
08:53:35 <Cale> pure/return
08:53:45 <wli> instance Applicative a => Injective i where inject = pure ; instance Monad i => Injective i where inject = return
08:53:48 <Cale> Both have a similar pattern to them.
08:54:09 <Cale> The general name for a functor of this sort is a 'pointed functor'
08:54:52 <dons> crikey. i wonder if reddit really does have downmod bots,
08:54:53 <dons> up votes	2
08:54:53 <dons> down votes	9
08:54:56 <dons> in 4 minutes.
08:55:14 <dons> same thing happened with the quine article yesterday.
08:55:23 <dons> i wonder if i'm in a bot blacklist. hmm
08:55:26 <Cale> dons: It could just be the anti-intellectual version of what I do.
08:55:42 <dons> but in 4 minutes?
08:56:00 <Cale> That's true, that is a lot of downvotes in not much time.
08:56:03 <byorgey> all it takes is nine very sad people.
08:56:13 <oerjan> > let test :: t a; test = undefined in test :: Integer
08:56:14 <lambdabot>  Couldn't match expected type `Integer' against inferred type `t a'
08:56:21 <oerjan> > let test :: t a; test = undefined in test :: Maybe Integer
08:56:22 <lambdabot>  Undefined
08:56:53 <dons> freaky.
08:56:58 <ricky_clarkson> dzone shows who votes.. seems a reasonable idea but it's full of idiots.
08:57:21 <oerjan> pchiusano: ^^ so there is nothing preventing such a type itself, just the definition is a problem
08:57:36 <dons> wow. theorem provers must be unpopular. 12 down, 3 up. nuts.
08:57:54 <pchiusano> proggit has really gone downhill
08:58:11 * wli leans toward downmod bots.
08:58:22 <pchiusano> it looks like everything submitted to programming reddit also is submitted to main reddit
08:58:33 <pejo> dons, I think one of the problems is that people don't realize why they are useful
08:59:19 <dons> ah well
08:59:46 <dons> hmm, since its a library, we could put it on hackage..
08:59:56 * byorgey is not sure what the big deal is with proggit
09:00:05 <ricky_clarkson> If it's any consolation, I see everything on proggit, I never look at the front page.
09:00:11 <pchiusano> hmm, maybe not... but I submitted an article to proggit, and somehow it showed up on main page
09:00:16 <dons> pchiusano: i think it could be the submitter's name that is blacklisted..
09:01:04 <pchiusano> ricky_clarkson, from scala is that you??
09:02:01 <ricky_clarkson> I am in 5 channels, and one of those is #scala, if that's what you mean.
09:02:07 <Cale> Programming reddit is a major infection vector for our ideas about programming.
09:02:09 * ricky_clarkson boggles.
09:02:38 <oerjan> Cale: so someone is trying to create an antidote... :/
09:03:15 <Cale> I think we'll just have to make the Haskell/theorem proving/etc. articles sneakier.
09:09:16 <jacobian_wrk> I have a question about the take-lemma and the approximation lemma.  Supposing that you are defining the take lemma over a codata type, the infinite streams which may not terminate, data CoList Nat = CoCons Nat (CoList Nat)
09:09:24 <jacobian_wrk> is there then any difference between the two?
09:14:58 <monochrom> @bots
09:14:58 <lambdabot> :)
09:15:05 * monochrom is petrified
09:15:18 <oerjan> @version
09:15:19 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
09:15:19 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:15:41 <byorgey> monochrom: haha!
09:15:49 <czakey> ;d
09:16:01 <oerjan> so is lambdabot.  paleolithic.
09:16:30 <byorgey> oerjan: Cale just pushed patches for 6.8.2!
09:16:45 <byorgey> oerjan: as soon as dons gets 6.8.2 running on c.h.o...
09:16:46 <monochrom> I actually needed to look up wikipedia to get the joke :)
09:16:51 * oerjan realizes that word doesn't mean quite as old as he thought it did
09:17:28 <oerjan> please replace that with "precambric", and look again. ;)
09:17:38 <wli> Cale: What sorts of patches?
09:18:06 <oerjan> darn, *precambrian
09:18:36 <monochrom> pre-cambridge Brian?
09:19:10 <oerjan> that, too
09:20:01 <byorgey> @choose A B
09:20:01 <lambdabot> A B
09:20:09 <byorgey> @help choose
09:20:09 <lambdabot> choose. Lambdabot featuring AI power
09:20:39 <monochrom> @choose thesis haskell
09:20:39 <lambdabot> thesis haskell
09:20:49 <monochrom> @choose thesis or haskell?
09:20:49 <lambdabot> thesis or haskell?
09:21:01 <byorgey> @choose thesis\nhaskell
09:21:01 <lambdabot> thesis\nhaskell
09:21:02 <monochrom> OK, I don't know how to use it.
09:21:03 <oerjan> @list choose
09:21:04 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
09:21:17 <byorgey> I'm looking at the source, it's weird, it uses lines to split up the input and randomly choose one.
09:21:17 <oerjan> @choose thesis|haskell
09:21:17 <lambdabot> thesis|haskell
09:21:27 <wli> IIRC paleolithic refers to an era of prehistoric archaeology vs. being a geologic or paleontological era.
09:21:32 <byorgey> I'm not sure how you're supposed to input multiple lines to \bot.
09:21:39 * byorgey changes it to 'words'
09:22:05 <oerjan> @@ @choose @read "test\nho"
09:22:06 <lambdabot>  testho
09:22:21 <oerjan> @read "test\nho"
09:22:21 <lambdabot>  testho
09:22:29 <oerjan> not that way apparently :(
09:22:42 <monochrom> @choose thesis
09:22:42 <monochrom> haskell
09:22:42 <lambdabot> thesis
09:23:11 <monochrom> @choose thesis
09:23:11 <monochrom> haskell
09:23:11 <lambdabot> thesis
09:23:14 <bos> dons: http://hpaste.org/5495#a1
09:23:21 <monochrom> No, I can't give it a linebreak either.
09:24:10 * byorgey sends a patch
09:24:45 <GrayShade> @read "a\tb"
09:24:45 <lambdabot>  a	b
09:25:00 <GrayShade> @read "a\rb"
09:25:00 <lambdabot>  ab
09:25:09 <ricky_clarkson> @read "a\nb"
09:25:09 <lambdabot>  ab
09:26:41 <oerjan> @list read
09:26:42 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
09:27:00 <GrayShade> @thx
09:27:00 <lambdabot> you are welcome
09:27:33 <oerjan> @help eval
09:27:34 <lambdabot> eval. Do nothing (perversely)
09:27:39 <BMeph> "dummy provides ... get-shapr"? ;)
09:27:52 <oerjan> @get-shapr
09:27:52 <lambdabot> shapr!!
09:28:19 <oerjan> @help learn
09:28:19 <lambdabot> learn. The learning page url
09:28:37 <GrayShade> @help botsnack
09:28:38 <lambdabot> botsnack. Feeds the bot a snack
09:28:43 <GrayShade> @botsnack
09:28:43 <lambdabot> :)
09:28:53 <GrayShade> this creeps me out
09:29:21 <oerjan> @botsmack
09:29:21 <lambdabot> :)
09:30:27 <vininim> How do I encapsulate? =P I mean, I want to alias a HashTable but only provide access to it throught my own functions (I'm trying to implement a enumeration like structure, ie. only accepts lookups after initialization)
09:30:27 <BMeph> @BO
09:30:28 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
09:30:38 <BMeph> Aww... :p
09:30:46 <GrayShade> what happens if i say > fix $ id ?
09:30:54 <EvilTerran> > fix id
09:30:56 <lambdabot>  Exception: <<loop>>
09:30:56 <oerjan> vininim: put it in a module and only export those functions
09:31:09 <GrayShade> > let f = f in f
09:31:09 <lambdabot>  Exception: <<loop>>
09:31:17 <EvilTerran> vininim, also, wrap the underlying type in a newtype and don't export the constructors
09:31:26 <oerjan> module MyHashTable (makeHashTable, ...) where
09:31:29 <monochrom> newtype MyThing = MyThing (HashTable ....)
09:31:43 <BMeph> > lef e = error "<<loop>>" in e
09:31:43 <lambdabot>  Parse error at "=" (column 7)
09:31:51 <BMeph> > let e = error "<<loop>>" in e
09:31:52 <lambdabot>  Exception: <<loop>>
09:32:43 <GrayShade> > do print 42
09:32:44 <lambdabot>  <IO ()>
09:33:10 <byorgey> GrayShade: for security reasons, lambdabot won't run things involving IO, but it will show you the type
09:33:25 <GrayShade> that seems normal
09:34:01 <byorgey> otherwise you could do things like  do { print 42 ; deleteHardDrive ; unsafeLaunchNuclearMissiles }
09:34:32 <vininim> or just loop print, which would be annoying =P
09:34:51 <vininim> I mean RECURSE *runs and hides*
09:35:03 * oerjan does that in the other window.  Everybody duck and cover!
09:35:26 <nominolo> dcoutts: http://hpaste.org/5506
09:35:32 <oerjan> darn, must be missing some import...
09:35:58 <GrayShade> i think i one saw it outputting a few elements of an infinite list, then stopping. that crept me out too
09:36:43 <oerjan> > fix (scanl (+) 1 [1..])
09:36:44 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
09:36:47 <byorgey> > [1..]
09:36:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:37:04 <oerjan> > fix ((1:).scanl (+) 1)
09:37:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
09:37:12 <byorgey> > iterate (*2) 1
09:37:12 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
09:37:16 <byorgey> whee!
09:37:49 <oerjan> > nubBy (((>1).).gcd) [2..]
09:37:50 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:38:11 <GrayShade> :/
09:38:25 <byorgey> GrayShade: why is that creepy?
09:39:02 * monochrom enters the last one into his own ghci and watches the slowdown :)
09:39:30 <GrayShade> byorgey: i wouldn't have expected it to like infinite computations
09:39:33 <byorgey> we should have a contest to see who can come up with the WORST way to calculate the infinite list of prime numbers =)
09:39:37 <vininim> > let f = 1 in f
09:39:37 <lambdabot>  1
09:40:23 <byorgey> GrayShade: well, the computation isn't infinite.  it only takes the first N characters generated, and Haskell's lazy evaluation does the rest.
09:41:00 <GrayShade> it's something like take 50 $ show e ?
09:41:06 <ricky_clarkson> > let ones = 1 : ones in ones
09:41:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:41:07 <byorgey> exactly
09:41:29 <oerjan> > [p | p <- [2..], all (\q -> gcd p q == 1) [2..p-1]]
09:41:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:41:31 <byorgey> lambdabot just wraps that around every computation
09:41:44 <vininim> > left f = f in f in 1
09:41:44 <lambdabot>  Parse error at "=" (column 8)
09:41:47 <vininim> > let f = f in f in 1
09:41:47 <lambdabot>  Parse error at "in" (column 16)
09:41:50 <MyCatVerbs> monochrom: that's still my favourite method for working out whether a generator is O(n) or worse or not. ;)
09:41:53 <vininim> u_u
09:41:56 * Corun wonders how many times lambdabot has printed that list...
09:42:02 <byorgey> vininim: you have two 'in's
09:42:19 <GrayShade> but how does it detect infinite loops? like fix id
09:42:21 <MyCatVerbs> monochrom: just let it run in a terminal for a few seconds or minutes (as appropriate) and watch to see whether or not it slows down. :)
09:42:22 <Vq^> Corun: probably more than 3 times :)
09:42:44 <vininim> GrayShade: small stack probably:
09:42:46 <vininim> ?
09:42:53 <byorgey> GrayShade: well, fix id in particular is detected by ghc.
09:43:08 <GrayShade> mine says "stack overflow"
09:43:18 <byorgey> GrayShade: but in general, lambdabot launches evaluation in a separate thread with resource limits that gets killed after a certain number of seconds
09:43:31 <oerjan> GrayShade: the <<loop>> exception is detected when it tries to reevaluate something while it is currently evaluating the exact same thing
09:43:38 <byorgey> GrayShade: well, it might depend on optimization settings
09:44:11 <oerjan> @help run
09:44:11 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:48:25 <pastorNC> @type guard
09:48:26 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:49:04 <pastorNC> @src MonadPlus
09:49:04 <lambdabot> Source not found.
09:49:12 <pastorNC> @info MonadPlus
09:49:12 <lambdabot> MonadPlus
09:49:22 <pastorNC> @type MonadPlus
09:49:23 <lambdabot> Not in scope: data constructor `MonadPlus'
09:51:12 <GrayShade> @src fix
09:51:13 <lambdabot> fix f = let x = f x in x
09:51:39 <oerjan> pastorNC: another strange gap in @src
09:51:50 <pastorNC> :'(
09:51:55 <oerjan> @index mplus
09:51:55 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:51:56 <pastorNC> that was me, crying
09:52:09 <oerjan> pastorNC: it's in Control.Monad, anyhow
09:52:40 <oerjan> @source Control.Monad
09:52:40 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
09:52:50 <oerjan> probably not right...
09:52:56 <oerjan> @docs
09:52:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:53:14 <oerjan> ^^ that's a more reliable starting point
09:53:56 <czakey> meh
09:54:26 <czakey> Could not find module `System.FilePath':
09:54:46 <czakey> I was trying to use Cabal on Debian Etch
09:54:53 <czakey> any suggestions?
09:54:54 <oerjan> it's in mumble mumble which is hidden? :D
09:55:26 <oerjan> (add package name to .cabal if so)
09:56:33 <Lemmih> czakey: It's from the filepath package?
09:57:31 <czakey> I've darks-geted cabal
09:57:38 <czakey> and trying to run
09:57:47 <czakey> runghc -cpp Setup.lhs configure
09:58:09 * gwern thinks 'darks-geted' is an awfully cute way of phrasing it
09:58:13 <czakey> effect: Distribution/Simple.hs:113:7:
09:58:20 <czakey> Could not find module `System.FilePath':
09:58:23 <gwern> czakey: whay are you passing the -cpp option?
09:58:44 <dons> bos, oh hmm.
09:58:51 <dons> at least the python one is slower
09:58:53 <czakey> lambdabots readme
09:58:55 <czakey> ;)
09:58:56 <gwern> czakey: package 'directory' is hidden, or something? sounds like it wasn't updated for split-base
09:59:00 <bos> dons: yeah, bummer, eh?
09:59:17 <czakey> gwern: nothing like that
09:59:18 <czakey> ;)
09:59:23 <glen_quagmire> openFile stdout WriteMode failz
09:59:28 <glen_quagmire> oh i see it's not FilePath
09:59:47 <dons> bos, so what lessons have we learnt?
09:59:54 <czakey> from lambdabot readme:
09:59:54 <oerjan> :t System.IO.openFile
09:59:55 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
09:59:58 <gwern> czakey: what are you trying to instakk? I don't see any names in my scrollback
10:00:04 <bos> dons: something somewhere could maybe be faster, if we knew what it was?
10:00:14 <glen_quagmire> hClose stdout  --w00t
10:01:06 <czakey> gwern: I've downloaded Cabal (darcs get ...)
10:01:16 <czakey> and then
10:01:18 <gwern> I mean, geez, are non-64 bit desktop processors still even sold?
10:01:22 <gwern> er. mischan
10:01:28 <czakey> simple make install
10:01:43 <gwern> czakey: cabal itself? interesting
10:01:48 <czakey> mhm
10:02:26 <czakey> I think so ;)
10:02:44 <czakey> maybe cabal doesn't like Debian etch ;d
10:03:22 <gwern> darcs cabal, eh? is it being configuredwith filepath? ie, when I runhaskell Setup configure, I see a linelike 'Dependency filepath-any: using filepath-1.1.0.0'
10:04:25 <czakey> heh
10:04:35 <czakey> runhaskell Setup.lhs
10:04:44 <czakey> [...]
10:04:45 <czakey> Could not find module `System.FilePath':
10:05:18 <gwern> oh. I should've asked this question in the first place, but - filepath is installed, right?
10:05:31 <magnus_> Does anyone have experience with F#? I am considering a job using mainly F# and C++ so I am wondering how it compares to Haskell.
10:05:46 <nominolo> magnus_: it's pretty much O'Caml
10:06:10 <magnus_> ah yes. perhaps I should ask in #ocaml :)
10:06:11 <ptolomy> D'oh. I was trying to update a cabal package to work with both ghc 6.6 and 6.8, but the special cabal syntax required to make that work also doesn't work on the version of cabal that is distributed with 6.6, so I'm back where I started.
10:06:19 <czakey> hmm
10:06:59 <nominolo> ptolomy: yes, you need the new cabal.  but that works with ghc 6.4+
10:07:26 <czakey> in etch packages
10:07:28 <gwern> I guess on debian it would be 'libghc6-filepath-dev'?
10:07:31 <nominolo> ptolomy: and assuming a (fairly) recent version of the build tool is acceptable i'd say
10:07:32 <czakey> there;s only
10:07:34 <czakey> haskell-filepath-doc
10:07:35 <monochrom> You'll probably miss laziness, but welcome the existential types and subtypes.
10:07:43 <czakey> so it isnt
10:07:43 <czakey> ;)
10:07:45 <czakey> ok
10:07:47 * gwern is looking at http://packages.debian.org/search?keywords=filepath&searchon=names&suite=all&section=all
10:07:51 <czakey> I have a point
10:07:56 <magnus_> monochrom: aha, I'll look into what existential types are
10:08:15 <czakey> thanks
10:09:36 <nominolo> czakey: can you paste the output of ghc-pkg list ?
10:09:53 <nominolo> czakey: and the output of make install for Cabal
10:10:11 <czakey> its a little long
10:10:13 <dcoutts> dons: oh, nice result. So darcs' built-in fast strings were slower than ByteString :-)
10:10:20 <dcoutts> nominolo: just looking at that paste...
10:10:33 <nominolo> dcoutts: it works for yi ;)
10:11:13 <dcoutts> nominolo: looks sensible
10:11:34 <nominolo> incidentally the patch id is exactly the name of the file that contains the patch
10:11:46 <nominolo> so i just add that link to the commit message
10:12:07 <nominolo> i think cat ${patch} would be too much traffic
10:12:07 <czakey> @hpaste
10:12:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:12:32 <dons> dcoutts: yah, the bytestrings have had a lot of optimisations of the last 3 years
10:12:36 <ptolomy> nominolo: Well, the issue is that my lazy self has been relying on macports (which I don't think is entirely unreasonable) and as of now the macports ghc stuff is practically obsolete.
10:12:42 <dcoutts> dons: :-)
10:12:51 <czakey> nominolo: recent hpaste
10:12:52 <nominolo> er, cat ${repo}/_darcs/patches/${patch}
10:13:15 <czakey> but gwern is right
10:13:17 * ptolomy may need to learn macports.
10:13:36 <czakey> theres no haskell-filepath-dev
10:13:54 <czakey> or sth
10:14:15 <nominolo> czakey: so you haven't installed filepath but it got picked during configuration of Cabal ?
10:14:19 <czakey> possibly its in testing or unstable
10:14:24 <nominolo> ptolomy: $ port install foo
10:14:50 <czakey> nominolo: yup
10:14:51 <ptolomy> nominolo: I meant "learn how to become a contributor so I can help ensure that ghc/cabal support is always up-to-date."
10:14:54 <ptolomy> :)
10:14:58 <nominolo> czakey: no ghclib6-filepath-dev ?
10:15:06 <czakey> yes
10:15:13 <zooko> Greetings, people of #haskell!
10:15:16 <nominolo> ptolomy: oh, right
10:15:35 <nominolo> oh oh .. await spam
10:15:51 * czakey awaiting
10:15:57 <czakey> ;>
10:15:58 * wli memoizes Bernoulli polynomial methods for computing sums of powers.
10:16:14 <dons> dcoutts: and 53% improvement in "obliterate" in darcs
10:16:22 <oerjan> greetings, zooko
10:16:23 <dcoutts> @yarr!
10:16:23 <lambdabot> Shiver me timbers!
10:16:34 <dcoutts> dons: whew are you reading that?
10:16:45 <zooko> Hey, remember me arguing that linux distributions weren't all that great, a couple of days ago?
10:16:49 <dons> dcoutts: on darcs-devel@
10:16:56 <zooko> There is an interesting article about a talk by Jeff Waugh on that subject, on LWN today.
10:17:05 <zooko> I'll get a free link to it using my Subscriber Power...
10:17:16 <gwern> zooko: you tease
10:17:18 <zooko> http://lwn.net/SubscriberLink/267810/51edf64c92ea31a3/
10:17:19 <lambdabot> Title: LCA: Disintermediating distributions [LWN.net]
10:17:24 <zooko> You should all subscribe to LWN.
10:17:25 <zooko> LWN rocks.
10:17:29 <pastorNC> @type par
10:17:29 <lambdabot> forall a b. a -> b -> b
10:17:43 <oerjan> nominolo: i'm starting to think you were right :(
10:17:59 <gwern> zooko: does subscribing involve paying money?
10:18:07 <zooko> That link I just posted allows you to read the article even though you aren't subscribers, because I used my power as a subscrbier to create that link.
10:18:12 <zooko> gwern: yes, it does.
10:18:44 <ehird`> @hoogle [a] -> a -> [[a]]
10:18:45 <lambdabot> No matches, try a more general search
10:18:45 <zooko> The guy who operates LWN and writes most of the articles has to pay money when he pays his bills, and the way he does that is that other people pay money for the articles that he writes.  ;-)
10:18:48 <ehird`> hmph
10:18:49 <ehird`> why not
10:18:50 <ehird`> :|
10:18:54 <czakey> hm
10:18:59 <ehird`> @hoogle [[a]] -> a -> [a]
10:18:59 <lambdabot> No matches, try a more general search
10:19:00 <czakey> in testing too
10:19:03 <ehird`> eh phooey
10:19:05 <czakey> blach
10:19:06 <ehird`> we need those
10:19:06 <ehird`> :(
10:19:18 <czakey> Ill better do it manualy
10:19:20 * gwern will subscribe to LWN then. Do they take gold, from this bulging bag of gold coins I keep in my pocket which I can't seem to spend fast enough?
10:20:01 <zooko> Hm.  Maybe they take e-gold.
10:20:04 <zooko> I don't know.
10:20:17 <dcoutts> LWN is great. I subscribe.
10:20:43 <ptolomy> dons: Is there any significant cost (other than added complexity) to adding the short bytestring special case equality code that you talked about in the Cafe to Data.ByteString?
10:20:44 <daf> LWN is great. HP subscribes for me. :)
10:20:46 <dons> Igloo: what's happening with haskell-x11?
10:20:50 <gwern> zooko: that article doesn't really impress me. If you want to attack distros, stuff like the NixOS or Gobolinux papers make much better and more persuasive reading
10:21:07 <zooko> gwern: could you point me to those papers?
10:21:08 <dons> Igloo: xmonad is suffering, two versions behind, and missing key fixes, in debian while we wait on this.
10:21:27 <dons> ptolomy: i plan to add it
10:21:31 <dons> i've written the code
10:21:45 <dcoutts> dons: what's that? the eq/ord code?
10:21:46 <gwern> zooko: not really. but I mean, their websites link to the papers so...
10:21:48 <zooko> gwern: honestly, it wasn't so much the content of that article that interested me, as much as the fact that Jeff Waugh was giving that speech at the distribution summit.
10:21:51 <ptolomy> Neato. :)
10:21:52 <dons> dcoutts: yeah
10:21:57 <zooko> Which means that a lot of active distro people are thinking about the topic.
10:22:02 <oerjan> ehird`: you looking for the nonexistant split-on-delimiter function?
10:22:11 <ehird`> oerjan: and join-on-delimiter, yes :)
10:22:22 <pastorNC> when should i use mapStateT/what is it intended for?
10:22:28 <oerjan> join-on-delimiter = intercalate
10:22:33 <oerjan> (new in 6.8)
10:22:36 <dcoutts> dons: so what's the idea? we check the length before deciding to call memcmp or use a native loop
10:22:41 <pastorNC> @type mapStateT
10:22:41 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
10:22:51 <zooko> Wow, NixOS is interesting.
10:22:52 <dons> dcoutts: i think so, yes
10:22:57 <oerjan> :t intercalate
10:22:58 <lambdabot> Not in scope: `intercalate'
10:23:05 <dons> dcoutts: but i want to benchmark it to give us margin for error
10:23:27 <GrayShade> intersperse?
10:23:34 <dcoutts> dons: and can we eliminate the short cut for empty strings imho
10:24:00 <gwern> zooko: make sure you read the thesis where he enlarges on his analogy between diskspace and ram, and memory/type safety for both
10:24:07 <dcoutts> dons: and the short cut for the same string should be moved after an initial check for the first chars being not equal
10:24:16 <dons> Igloo: do we need hgl in debian? as i understand it hgl is stopping x11, which is stopping xmonad. we have to move forward on this -- its affecting the growth of xmonad
10:24:23 <ehird`> FYI - intercalate is wrong
10:24:28 <ehird`> it's [a]->[[a]]->[a]
10:24:41 <ehird`> "a->[a]->a" would be the ideal type
10:24:52 <dons> dcoutts: yeah, we need real numbers though, some optimisations i tried made things worse. benchmarking in a Map is one thing we need to ensure works well
10:24:53 <dcoutts> dons: because hgl uses x11 and breaks with newer x11? Note that gentoo dropped hgl
10:24:53 <oerjan> ehird`: er, that's impossible
10:25:02 <dcoutts> dons: aye
10:25:13 <dcoutts> dons: benchmark first then fiddle :-)
10:25:24 <dons> yep
10:25:48 <ehird`> @src intercalate
10:25:48 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
10:25:52 <dons> dcoutts: btw, simonM is here March, Apr, May, looking for things to work on. any thoughts?
10:25:54 <ehird`> :t intersperse
10:25:56 <lambdabot> forall a. a -> [a] -> [a]
10:25:57 <dcoutts> dons: we can expect that most comparisons are false, so fail quickly is probably the key to performance
10:26:10 <ehird`> > intersperse '\n' ["x","y","z"]
10:26:10 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
10:26:18 <ehird`> > intersperse '\n' "xyz"
10:26:18 <lambdabot>  "x\ny\nz"
10:26:19 <dcoutts> dons: hmm, will ponder
10:26:22 <ehird`> cool
10:26:53 <dcoutts> dons: are we thinking dev tools or optimisations?
10:27:22 <dons> dcoutts: well, if we want things changed in the runtime, or the optimiser, or tools :)
10:27:25 <dcoutts> dons: I've got some ideas, but they're probably small enough for SoC projects, like a PVP checker tool
10:27:39 <dcoutts> PVP = Package Versioning Policy
10:27:48 <dons> also, we could think about a HW paper or two during that period
10:28:06 <dcoutts> dons: we've got that JFP paper remember? :-) and I've got a thesis to finish
10:28:10 <dons> yep.
10:28:53 <desegnis> Just wanted to throw this in, pandoc is awesome :) Now I only need to tweak it to work nice with literate Haskell
10:29:02 <pejo> dcoutts, gives you more material to put in your thesis though!
10:29:22 <dcoutts> pejo: my problem is just writing, not the material
10:29:23 <dons> cool. pandoc could be a mainstream project with a little more marketing.
10:29:52 <pejo> dcoutts, I realized that, was mostly a joke. :-)
10:30:22 <dcoutts> pejo: aye, I'm pretty bad at just getting down to work and writing, I'd much rather be hacking :-(
10:30:22 <desegnis> dons, yeah. it's a converting tool that just works on my box, and that means something already
10:30:58 <dcoutts> pejo: btw, the sparc ncg patch you pointed me at the other day is 403 Forbidden
10:31:30 <dcoutts> pejo: could you fix the perms, and remind me of the url as I've forgotten ;-)
10:31:58 <cjb> e
10:32:00 <cjb> iios,
10:32:01 <cjb> oops,
10:32:05 <cjb> :)
10:32:21 <dcoutts> dons: btw, did you comment on the sun/sparc email I sent already?
10:32:33 <dons> it looks very exciting.
10:32:36 <dons> excellent work
10:34:30 <dcoutts> dons: main things to consider are funding of a student and hosting of a box
10:35:00 <dons> yep. we could host it here, but that's probably a bit far. :)
10:35:07 <dcoutts> dons: oh, they were interested in the UNSW work, what is the best link/paper for that?
10:35:31 <dcoutts> ie showing that ghc's smp stuff scales reasonably well on the 16-core x86-64 monster
10:35:37 <dons> yep. looking..
10:36:04 <byorgey> cjb: I think you mean 'eieio'
10:36:05 <dons> http://www.cse.unsw.edu.au/~chak/papers/CLPKM07.html
10:36:06 <lambdabot> Title: Research Papers of Manuel Chakravarty
10:36:53 <Igloo> dons: I got the message, already...
10:37:07 <dons> Igloo: ok. I'd not had any feedback on how we proceed with this.
10:37:30 <dons> can we avoid the hgl issue?
10:37:51 <dons> i honestly think getting xmonad into debian is worth sacrificing hgl for :)
10:38:00 <dcoutts> Don "it's critical!" Stewart  :-)
10:38:05 <dons> right!
10:38:22 <Tobsan> does anyone know about the par_ in HGL
10:38:44 <dons> dcoutts: and the general project home, http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
10:38:53 <dcoutts> dons: ta
10:39:32 <Tobsan> @src par_
10:39:32 <lambdabot> Source not found. Are you on drugs?
10:39:32 <dons> the benchmarks are in the 'status report' paper though. and note, we also have numbers from a huge sparc box
10:39:32 <dcoutts> dons: note also that JaffaCake recently got parallel GC performing well (after many hours staring at intel vtune and bouncing cache lines)
10:39:37 <dons> oh!
10:39:38 <pejo> dcoutts, heh, sorry about that. :-)
10:39:48 <dons> dcoutts: was there a commit about this?
10:39:51 <dcoutts> dons: right, the 40 cpu SMP sparc.
10:40:12 <dons> we should bring rl in on this, he's deeply familiar with the sparc
10:40:14 <dcoutts> dons: no, just comments in #ghc the other day, it'll be in a paper due shortly
10:40:24 <dons> oh that's great news
10:40:27 <dcoutts> dons: right, we should, I'll cc him
10:41:10 <dcoutts> dons: though rl is interested in number chunching NDP stuff, this sparc chip is less good at that, it's probably better for random highly threaded haskell code
10:41:24 <dons> oh, that's interesting.
10:41:33 <dons> yes, more of the `par` style jobs, rather than ndp
10:41:57 <dons> it'd be interesting to get simonpj or someone to give a talk about paralellism in haskell to the sparc guys :)
10:42:14 <dcoutts> right, the multi-threads per core is good for hiding memory latency
10:42:20 <dons> yes, that's very interesting
10:42:21 <dcoutts> which we have a lot of in haskell code typically
10:42:49 <dcoutts> where as NDP generally produces code that can saturate memory bandwidth no problems and is not latency sensitive
10:43:00 <byorgey> rl?
10:43:14 <dcoutts> dons: so we may need a different primary benchmark than NDP
10:43:22 <dcoutts> dons: something like a threaded app server
10:43:33 <dons> byorgey: http://swt.cs.tu-berlin.de/~rl/
10:43:34 <lambdabot> Title: Roman Leshchinskiy
10:43:36 <dcoutts> dons: or par, like you said, or STM
10:43:41 <byorgey> oh, right =)
10:44:42 <lispy> Suppose I do something like, filter (`notElem` (map f xs)), how do I determine how frequently the map will run?
10:44:50 <dcoutts> dons: latest Sparc chips have hardware transactional memory
10:44:59 <lispy> ie, when is the compiler smart enough to evaluate the map once?
10:45:02 <glen_quagmire> :t filter
10:45:02 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:45:12 <dons> dcoutts: oh my. should we get ghc targetting that directly?
10:45:13 <glen_quagmire> :t notElem
10:45:14 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:45:18 <jedbrown> The T2 is much better for floating point than the T1.
10:45:32 <glen_quagmire> > notElem 1 [1..]
10:45:33 <lambdabot>  False
10:45:44 <dcoutts> lispy: it's not guaranteed unless you explicitly lift it out and use let.
10:46:08 <dcoutts> dons: depends on the api to the HTM, whether we can make a hybrid H/STM
10:46:12 <glen_quagmire> lispy: is that grammatical expression?
10:46:18 <glen_quagmire> oh yah `notElem` sorry
10:46:33 <lispy> dcoutts: thank you sir
10:46:38 <dons> dcoutts: sounds like something we might mention to the sparc guys
10:46:57 <lispy> > filter (`notElem` (map (+1) [1..]) [1..]
10:46:58 <lambdabot> Unbalanced parentheses
10:47:02 <lispy> > filter (`notElem` (map (+1) [1..])) [1..]
10:47:05 <lambdabot> Terminated
10:47:10 <dcoutts> dons: indeed, though that's in the future, the Rock chip is not expected in production 'til later this year.
10:47:12 <lispy> glen_quagmire: it's valid haskell :)
10:47:47 <jedbrown> Rumor has it, Rock won't be out 'till 2009.
10:48:04 <reilly> dons: I think we need the right application to get them interested
10:49:07 <glen_quagmire> > filter (`notElem` (map (+1) [1..3])) [y | y <- [x | x <- [1..3]]
10:49:07 <lambdabot>  Parse error at end of input
10:49:10 <dcoutts> dons: right, so we need a `par` style app that can use 24 threads profitably
10:49:18 <dons> mm
10:49:21 <gwern> @where Data.Trie
10:49:21 <lambdabot> I know nothing about data.trie.
10:49:27 <glen_quagmire> > [y | y <- [x | x <- [1 .. 3]]]
10:49:27 <lambdabot>  [1,2,3]
10:49:56 <dcoutts> dons: that shows the programming advantages of haskell, and can perform reasonably, we don't need to compete with C if we can program it much more easily
10:50:02 <wli> dcoutts: Some kind of physical simulation, e.g. optics + mechanics such as in video games.
10:50:10 <dcoutts> dons: so long as we can comfortably beat a single threaded C prog
10:50:46 <glen_quagmire> how can I list comprehend [[1,2,3], [1,2,3], [1,2,3]] ?
10:51:11 <oerjan> > join (>>) [1,2,3]
10:51:11 <lambdabot>  [1,2,3,1,2,3,1,2,3]
10:51:16 <oerjan> bah
10:51:18 <lispy> > cycle 3 [1..3]
10:51:18 <lambdabot>  Couldn't match expected type `[t1] -> t'
10:51:22 <lispy> :t cycle
10:51:23 <lambdabot> forall a. [a] -> [a]
10:51:31 <lispy> > repeat 3 [1..3]
10:51:31 <lambdabot>  Couldn't match expected type `[t1] -> t'
10:51:34 <lispy> doh!
10:51:36 <byorgey> > [ x | y <- [1..3], let x = [1,2,3] ]  -- kind of a silly way to do it
10:51:36 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
10:51:37 <lispy> :t repeat
10:51:37 <lambdabot> forall a. a -> [a]
10:51:47 <lispy> > take 3 $ repeat [1..3]
10:51:48 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
10:51:50 <glen_quagmire> > [a | a <- [[b | b <- [1 .. 3]]]]
10:51:51 <lambdabot>  [[1,2,3]]
10:51:57 <wli> dcoutts: The big nasty there is that AIUI the massively threaded UltraSPARC cores are weak on floating point e.g. sharing an FPU between groups of threads in anticipation of floating point being "rare."
10:52:01 <oerjan> lispy: replicate
10:52:08 <lispy> oerjan: ah!
10:52:10 <lispy> :t replicate
10:52:11 <lambdabot> forall a. Int -> a -> [a]
10:52:12 <dcoutts> wli: right, it'd have to be integer only
10:52:24 <lispy> oerjan: replicate, cycle and repeat...
10:52:25 <pejo> wli, isn't that fixed on the 'new' generation?
10:52:32 <reilly> dons: dcoutts:  damn, i was hoping for a nice linear algebra application
10:52:38 <jedbrown> wli: The T2 has good floating point.
10:52:45 <dcoutts> pejo: yeah, the T2 has one FP unit per core
10:53:04 <wli> dcoutts: Another minor problem is that it's easy to parallelize in C, too, so they could compete relatively easily for the same app space.
10:53:11 <dcoutts> but we're not likely to get Sun to donate us a T2 as they're about 5 times more expensive :-)
10:53:24 <reilly> dons: dcoutts:  something that used type level programming to do the sort of optimizations that blitz does
10:53:24 <dcoutts> a decent T1 is just over $3,000
10:53:35 <wli> dcoutts: And T2?
10:53:52 <dcoutts> wli: starting at ~$12,000 iirc
10:54:05 <dcoutts> and going up to $25k
10:54:48 <wli> That could get ugly.
10:54:56 <glen_quagmire> > replicate 3 [1,2,3]
10:54:57 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
10:55:00 <dcoutts> wli: right, so we'd want something where parallellising is not that easy so we get more advantage from `par`
10:55:05 <glen_quagmire> @src replicate
10:55:05 <lambdabot> replicate n x = take n (repeat x)
10:55:18 <dcoutts> wli: while C coders are fighting with locks
10:55:18 <wli> dcoutts: Comparative advantage vs. C that is.
10:55:27 <dcoutts> wli: right
10:56:01 <wli> Linear algebra would be where it's easy for C to do it, too, so physical simulations are out.
10:56:20 <oerjan> > join (liftM . const) [1,2,3]
10:56:21 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3]]
10:56:22 <jedbrown> wli, dcoutts: Looks like 15k for 32 threads and 32k for 64 threads T2.
10:56:42 <dcoutts> wli: in fact, the real test is to compare a single threaded C prog on a $3,000 x86 box vs a highly threaded haskell prog on a $3,000 sparc box
10:57:01 <wli> How many threads per core again?
10:57:12 <dcoutts> wli: 4 for T1, 8 for T2
10:57:23 <jedbrown> wli: Depends on the methods used for simulation.  Not everything is linear algebra.
10:57:24 <dcoutts> wli: and 6-8 cores for both, depending on price
10:57:32 <byorgey> > join (liftM . const) [1..4]
10:57:32 <lambdabot>  [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
10:57:38 <byorgey> > join (liftM . const) [3..4]
10:57:39 <lambdabot>  [[3,4],[3,4]]
10:57:48 <dcoutts> jedbrown: right, vs $3-5k for 6-8 core T1
10:57:49 <jedbrown> wli: But if we don't have a T2, then yes, it's out.
10:58:34 <reilly> you don't need delivery of a T2, you only need access
10:58:59 <reilly> plus lab access for the final benchmarks
10:59:12 <dcoutts> reilly: you're missing the ulterior motive here. We really want Sun to donate us a T1 so we can use it as a community server :-)
10:59:49 <glen_quagmire> :t join
10:59:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:59:54 <wli> Game tree searches like chess playing might be a bit hairier for C to handle in parallel, but not much.
11:00:03 <byorgey> who cares about benchmarks, we want awesome toys =)
11:00:05 <reilly> dcoutts:  why a T1, then?
11:00:10 <oerjan> :t join.($)
11:00:13 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
11:00:22 <dcoutts> reilly: at $3k that's peanuts to Sun, so they're more likely to donate one. I'm already in talks with them.
11:00:35 <dcoutts> so far a very positive response
11:00:44 <reilly> dcoutts: understood.  You should get some CELL BEs from IBM too.
11:00:56 <dcoutts> that's a much much harder arch to port to
11:01:01 <dcoutts> ghc already works on sparc
11:01:02 <jedbrown> Wavelet transforms take some work to parallelize well.
11:01:02 <byorgey> what's in it for Sun?  I'm curious how you suggest this sort of thing
11:01:09 <reilly> i'd like it if #ghc could generate SPE code
11:01:20 <reilly> ghc
11:01:21 <MyCatVerbs> byorgey: more customers.
11:01:31 <glen_quagmire> does ghc automatically convert recursive calls to tail recursion?
11:01:37 <MyCatVerbs> byorgey: more software works on their hardware means more people want to use their hardware.
11:01:47 <vininim> @hoogle a -> b -> (a,b)
11:01:47 <lambdabot> Control.Monad.RWS.Lazy.execRWS :: RWS r w s a -> r -> s -> (s, w)
11:01:47 <lambdabot> Control.Monad.RWS.Strict.execRWS :: RWS r w s a -> r -> s -> (s, w)
11:01:47 <lambdabot> Control.Monad.RWS.Lazy.evalRWS :: RWS r w s a -> r -> s -> (a, w)
11:01:48 <dcoutts> byorgey: two things. One is general open source goodness, PR etc (they donate generic x86 servers to other open source projects just for the PR value).
11:01:59 <vininim> ...
11:02:01 <oerjan> :t (,)
11:02:03 <lambdabot> forall a b. a -> b -> (a, b)
11:02:03 <wli> I'm not sure how many C chess engines are parallelized these days.
11:02:05 <glen_quagmire> i mean, do i have to worry about recursion stack blow?
11:02:07 <MyCatVerbs> byorgey: plus, things small enough that their internal processes regularly *forget about* larger sums of money, eh.
11:02:09 <byorgey> vininim: (,)
11:02:14 <dcoutts> byorgey: The other is selling a research project to see how well Haskell could work on their multi-core chips.
11:02:14 <vininim> thanks =)
11:02:26 <MyCatVerbs> dcoutts: ohhh, now that is a good idea.
11:02:39 <byorgey> dcoutts, MyCatVerbs: ok, makes sense.
11:02:45 <oerjan> glen_quagmire: tail recursion is optimized
11:02:54 <byorgey> I mean, I'd give us a server if I were Sun  ;)
11:02:57 <dcoutts> byorgey: they're very keen to see people use their highly threaded approach since currently they're the only vendor pushing it.
11:02:58 <jedbrown> wli: Certianly IBM has a parallel one :)
11:02:58 * MyCatVerbs would like to see STM tear handwritten C to shreds. :)
11:03:09 <byorgey> dcoutts: ah.  I didn't know about that.  cool.
11:03:13 <MyCatVerbs> dcoutts: no they're not. :)
11:03:28 <glen_quagmire> oerjan: but they are for tail recursively written functions?
11:03:33 <MyCatVerbs> dcoutts: but the only other people I know of going down that way aren't doing SMP.
11:03:57 <glen_quagmire> f n = n * f (n - 1)   will this be converted into tail recursion and optimized?
11:04:08 <oerjan> glen_quagmire: no.
11:04:20 <wli> So chess looks plausible. There need to be a few more ideas.
11:04:24 <glen_quagmire> oerjan: thank you
11:04:30 <dcoutts> MyCatVerbs: Sun are currently putting 64 threads on a single chip, no other manufacturer is getting near that as far as I know (except one small Mips company)
11:04:36 <glen_quagmire> wli: wiimote chess!
11:04:38 <idnar> it'll be evaluated lazily, though; isn't that almost as good?
11:04:56 <oerjan> glen_quagmire: it cannot be, without using known properties of *
11:05:33 <bos> dcoutts: http://www.azulsystems.com/
11:05:33 <lambdabot> Title: Azul Systems - Your Business-Critical Java&trade; 5X Faster. 50X Simpler
11:05:34 <wli> Cryptanalysis could but it depends a lot on the sort of cryptanalysis being done.
11:05:48 <dcoutts> MyCatVerbs: sure you can buy 8+ socket NUMA machines but that's kind of different and typically more expensive.
11:05:49 <MyCatVerbs> glen_quagmire: you'd have to rewrite it with an accumulator in this case - something like f n = f' 1 n where f' n ac = if ac == 0 then n else f' (n-1) (n*ac)
11:06:04 <jedbrown> wli: Image processing perhaps.
11:06:26 <bos> dcoutts: azul sells 768-core boxes
11:06:32 <glen_quagmire> i see
11:06:52 <dcoutts> bos: what architecture is that, it's not obvious on their site yet
11:06:53 <wli> I'm not sure if the cryptanalysis problems that would show comparative advantages for Haskell would be realistic, basically because I'm not sure which problems would at all.
11:07:05 <bos> dcoutts: custom. 48 cores per chip.
11:07:10 <dcoutts> bos: ah "Vega 2 processor, the first 48-core chip"
11:07:16 <dcoutts> for Java
11:07:22 <MyCatVerbs> dcoutts: this is true. The people I'm thinking of are looking at anything up to one thousand cores on a single hunk of silicon. Don't think they use shared memory, though. (I'm unclear as to exactly what they *do* use, I could probably get better information but I'm sure they'd swear me to secrecy :)
11:07:43 <wli> jedbrown: Careful to avoid linear algebra because that's easy to parallelize in C, too.
11:07:44 <dcoutts> MyCatVerbs: sounds great
11:07:46 <oerjan> glen_quagmire: even what MyCatVerbs wrote may blow the stack if the compiler is not smart enough (builds up nested * thunks)
11:08:15 * wli would just do f n = product [1 .. n]
11:08:21 <bos> dcoutts: have you run much parallel haskell code on a multiprocessor box?
11:09:15 <dcoutts> bos: personally, no. Closest I've come was while visiting UNSW where they were doing NDP benchmarks on a 2x8 x86-64 box.
11:09:18 <jedbrown> wli: What makes walking a game tree hard to parallelize?
11:09:45 <jedbrown> wli: Compared to a wavelet transform, for instance.
11:09:56 <bos> dcoutts: the garbage collector kills performance really early.
11:10:01 <wli> jedbrown: Irregular data structures and transposition tables. It's not really a tree, it's a DAG.
11:10:47 <dcoutts> bos: JaffaCake was talking about that the other day. He says he's currently got about a 4-5x speedup on an 8 core x86-64 box.
11:11:04 <bos> dcoutts: that's not too bad.
11:11:15 <dcoutts> bos: where as previously using multiple GC threads was gaining almost nothing
11:11:21 <bos> exactly.
11:11:26 <dcoutts> bos: all down to cache line bouncing apparently
11:11:37 <dcoutts> or mostly
11:11:38 <wli> jedbrown: Linear algebra OTOH you can just break up using e.g. modulo subdivision, that is, dedicating threads to each residue class mod n for some n and row k is serviced by the thread for the residue class of k mod n.
11:12:06 <bos> dcoutts: interesting. wringing performance out of a parallel GC is really hard, subtle work.
11:12:15 <jedbrown> wli: Yes, dense linear algebra is especially easy.
11:12:41 <jedbrown> wli: For most games, there should be enough possible moves that you could treat it as a tree without duplicating too much work.  I'd think.
11:12:46 <dcoutts> bos: yes, certainly. Have to get very familiar with SMP memory/cache architecture
11:13:15 <monochrom> Do not take the name of SPJ in vain!
11:13:22 <jedbrown> wli: Adaptive wavelet methods for PDE have yet to be parallelized, for instance.
11:13:25 <wli> jedbrown: You can't even pass legality checks without transposition tables in chess; 3-move repetition terminates games.
11:13:59 <oerjan> monochrom: huh?
11:14:18 <wli> jedbrown: (it forces a draw)
11:14:34 <jedbrown> wli: Yeah, I know.  But couldn't you clean that up later?
11:14:57 <wli> jedbrown: Transposition tables are how you clean it up later.
11:16:17 <wli> jedbrown: Failure to coalesce the tree branches duplicates work, so it's always a loss not to, so you're always dealing with a DAG vs. a tree.
11:16:27 <MyCatVerbs> oerjan: oh aye, I forgot. My bad.
11:16:38 <jedbrown> wli: I have no experience with this, but it still seems like the bulk of the work can be easily parallelized, and such postprocessing could be done sequentially.  Obviously this won't scale forever, but perhaps to 32 or 64 cores.
11:17:03 <jedbrown> wli: But it's often cheaper to duplicate the work than to avoid it.
11:17:28 <jedbrown> wli: Until the duplicated work becomes a significant fraction of the total.
11:17:34 <wli> jedbrown: It's very transposition-heavy.
11:17:51 <MyCatVerbs> > let fac n = { fac' 1 n where fac' n m = if m == 0 then n else n*m `seq` fac' (n-1) (n*m) } in fac 400
11:17:51 <lambdabot>  Parse error at "{" (column 13)
11:18:05 <MyCatVerbs> > let fac n =  fac' 1 n where fac' n m = if m == 0 then n else n*m `seq` fac' (n-1) (n*m) in fac 400
11:18:06 <jedbrown> wli: I was suggesting that there are enough possible moves that not very much work will be duplicated.
11:18:07 <lambdabot>  -1
11:18:13 * MyCatVerbs blinks.
11:18:30 <wli> jedbrown: My understanding is that it is significant.
11:18:45 <jedbrown> wli: You probably know better than I.
11:18:46 <oerjan> > (0$0 `seq`)
11:18:46 <lambdabot>      The operator `seq' [infixr 0] of a section
11:18:47 <lambdabot>         must have lower prece...
11:19:22 <MyCatVerbs> > let fac n = (let fac' n m = if n == 0 then n else n*m `seq` fac' (n-1) (n*m) in fac' 1 n) in fac 400
11:19:23 <lambdabot>  0
11:19:35 <wli> jedbrown: I think that its significance would give Haskell an advantage over C.
11:19:41 <MyCatVerbs> > let fac n = (let fac' n m = if n == 0 then m else n*m `seq` fac' (n-1) (n*m) in fac' 1 n) in fac 400
11:19:41 <lambdabot>  400
11:20:04 <oerjan> MyCatVerbs: that seq won't work anyway, the n*m's are not shared
11:20:04 <MyCatVerbs> Oh, buggery lemming.
11:20:15 <MyCatVerbs> oerjan: no? Damn. Please explain?
11:20:30 <jedbrown> wli: I still think adaptive methods for PDE is an interesting class of problems.  Matrix-free methods are often used (so no explicit linear algebra) and the data is highly irregular and changing, making distribution hard.
11:20:30 <vininim> > liftM (:[]) ['a'..'z']
11:20:31 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
11:20:40 <oerjan> or, actually they sort of will but not in the way you think
11:20:42 <jedbrown> wli: It is floating point, though.
11:20:43 <vininim> > join (liftM (:[]) ['a'..'z'])
11:20:43 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
11:21:05 <oerjan> MyCatVerbs: ghc doesn't share expressions unless you name them
11:21:54 <wli> jedbrown: Probably a good one to keep in mind in the event of access to T2.
11:22:15 <wli> jedbrown: Is this adaptive multigrid?
11:22:25 <jedbrown> wli: It's something I'm working on now, and will be for a while.
11:22:41 <oerjan> but the seq will still force each of m and n
11:22:51 <oerjan> which happens to be enough here
11:22:54 <wli> jedbrown: I know a little bit about multigrid.
11:23:31 <oerjan> > let fac n = (let fac' n m = if n == 0 then m else m `seq` fac' (n-1) (n*m) in fac' n 1) in fac 400
11:23:33 <lambdabot>  6403452284662389526234797031950300585070258302600295945868444594280239716918...
11:24:00 <jedbrown> wli: There are 2 schools of thought for nonlinear problems.  FAS incorporates the nonlinearity in the multigrid iteration.  Jacobian-free Newton-Krylov keeps the nonlinear iteration outside, but often uses multigrid preconditioning.
11:24:48 <jedbrown> wli: Multigrid is more powerful for linear problems, so keeping the nonlinearity outside often makes for better convergence.
11:25:30 <jedbrown> wli: But both approaches work well, and the required code is almost the same, it just needs to be put together differently.
11:26:11 <jedbrown> wli: That is, the components could be written generally enough to be used in either scheme.
11:26:16 <wli> jedbrown: That's a bit beyond me. I've only got a passing familiarity with multigrid by itself, not any of these more advanced methods building on it or using it as a preconditioner.
11:27:23 <visof> can i now install lambdabot with ghc-6.8?
11:27:58 <wli> (and frankly I couldn't do much with multigrid without looking up the basics)
11:28:25 <jedbrown> wli: Multigrid is really cool.
11:28:38 <oerjan> visof: apparently
11:29:21 <visof> oerjan what do you mean?
11:29:33 <jedbrown> wli: Differential operators on adaptive grids are almost always very poorly conditioned, hence any method needs a good preconditioner.  Multigrid is particularly effective for lots of problems.
11:29:54 <MyCatVerbs> oerjan: oh. Damn.
11:30:05 <MyCatVerbs> oerjan: Doesn't common subexpression elimination pick that up, though?
11:30:22 <wli> CSE backfires too often with laziness.
11:31:06 <oerjan> MyCatVerbs: ghc doesn't _do_ CSE
11:31:29 <oerjan> visof: Cale has uploaded patches
11:31:46 <visof> oerjan where?
11:32:16 <oerjan> @where lambdabot
11:32:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:32:33 <newsham> ?bot
11:32:33 <lambdabot> :)
11:32:38 <oerjan> if they're not there, i don't know
11:33:13 <jedbrown> visof: darcs get http://code.haskell.org/lambdabot
11:33:14 <lambdabot> Title: Index of /lambdabot
11:33:35 <newsham> http://www.thenewsh.com/%7Enewsham/x/lambdabot-on-6.8.2.diff  some of my changes.. there were a few more afterwards to get some things working
11:33:35 <lambdabot> newsham: You have 1 new message. '/msg lambdabot @messages' to read it.
11:33:40 <visof> jedbrown ok
11:36:10 <lispy> how do I get lambdabot to give me the url to a module?
11:36:17 <lispy> ?module Foreign.C.Types
11:36:17 <lambdabot> Unknown command, try @list
11:36:20 <lispy> ?list
11:36:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:36:41 <oerjan> lispy: in principle @docs and @source
11:36:49 <lispy> ah
11:36:55 <oerjan> but many of the links have been broken since 6.8
11:36:57 <lispy> ?docs Foreign.C.Types
11:36:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Types.html
11:37:05 <lispy> ?. tinyurl docs Foreign.C.Types
11:37:06 <lambdabot> Plugin `compose' failed with: Unknown command: "tinyurl"
11:37:19 <lispy> ?. tiny-url docs Foreign.C.Types
11:37:20 <lambdabot> http://tinyurl.com/2x9kwh
11:37:24 <oerjan> so use @docs without argument, and browse from that page
11:37:27 <oerjan> @docs
11:37:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:39:23 <oerjan> @docs Data.Map
11:39:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
11:39:49 <oerjan> ok, the first one working was just a freak accident ;)
11:41:23 <zooko> Dear people of #haskell.  Please help me write Haskell bindings for this simple C API:
11:41:31 <zooko> http://paste.lisp.org/display/55485
11:41:40 <zooko> Here is what I've got so far, thanks to Adam Langley and lispy:
11:41:46 <zooko> http://paste.lisp.org/display/55493
11:43:19 <zooko> Howdy bos.
11:44:07 <jedbrown> zooko: Does what you have work?
11:44:11 <Twey> Hmm... I don't quite get the concept of "in a monad"
11:44:17 <Nafai> zooko: So you're getting into Haskell now too! :)
11:44:24 <zooko> jedbrown: no.
11:44:27 <zooko> Nafai: I'm tryhing.
11:44:35 <jedbrown> zooko: What doesn't work?
11:44:39 <Twey> Is the monad I'm "in" defined purely by the return type of the function?
11:44:45 <kpreid> Twey: Yup.
11:44:48 * oerjan suddenly envisions "in the monad" sung to "in the navy"
11:44:51 <jedbrown> zooko: You sould be able to give it strict bytestrings.
11:45:05 <kpreid> Monad m => ... -> m ...
11:45:07 <zooko> jed: honestly, I haven't tried to compile it yet, because I know that the sha256_digest() function type isn't right.
11:45:23 <zooko> I need that function to pass a small fixed-length data buffer back into Haskell land from C land.
11:45:24 <Twey> kpreid: Isn't that pretty magical?
11:45:30 <Twey> Oh wait
11:45:36 <kpreid> Twey: No...
11:45:36 <zooko> jed: I do not understand what you mean by strict bytestrings.  :-/
11:45:39 <Twey> It's just type inferrance, isn't it.
11:45:56 <kpreid> Twey: "in a monad" isn't a concept meaningful to the implementation
11:46:02 <kpreid> it's just a convenient abstraction
11:46:11 <Twey> Hmm
11:46:15 <jedbrown> zooko: Strict Bytestrings are just a buffer of bytes.
11:46:16 <Twey> So what's actually happening?
11:46:28 <zooko> jed: that sounds perfect.
11:46:29 <jedbrown> zooko: You can get at the pointer using withForeignPtr.
11:46:41 <jedbrown> zooko: So that is the natural Haskell object to use here.
11:46:43 <zooko> The sha256_update function takes a buffer of bytes from Haskell land and gives them (read-only) to C land.
11:46:59 <jedbrown> zooko: Then you can generalize to lazy bytstrings (which are a list of strict bytestrings).
11:46:59 <zooko> The sha256_digest function sends a buffer of bytes that were produced in C land to be used (read-only) in Haskell land.
11:47:09 <kpreid> Twey: There is no magic. What you see is what is.
11:47:27 <jedbrown> zooko: Do you know specifics about the SHA256 type?
11:47:42 <zooko> jed: I do, but I think it is easiest if that is treated as an "opaque pointer".
11:47:43 <jedbrown> zooko: Like, is it just a 64 byte buffer?
11:47:54 * Twey ponders a little.
11:47:57 <zooko> jedbrown: no, it is *actually* a C++ object.
11:48:04 <Twey> Hm.  Thanks anyway.
11:48:22 <jedbrown> zooko: Okay, but you want to be able to use it eventually.
11:48:27 <zooko> jed: http://paste.lisp.org/display/55491
11:48:53 <zooko> jed: the C API that I showed, with sha256_new(), sha256_free(), sha256_update(), and sha256_digest() should be everything that the Haskell programmer needs.
11:48:57 <bos> zooko: how are you wrapping it?
11:49:01 <zooko> What do you mean, you want to be able to use it eventually?
11:49:10 <zooko> bos: the answer is completely contained in http://paste.lisp.org/display/55491
11:49:24 <bos> actually, i meant in haskell.
11:49:49 <jedbrown> zooko: Oh, SHA256 digest writes into the buffer you pass, which would be 64 bytes, right?
11:49:58 <zooko> bos, what I have so far is this:
11:50:06 <zooko> http://paste.lisp.org/display/55493
11:50:15 <zooko> jedbrown: 32 bytes, but yes.
11:50:34 <zooko> jedbrown: or, if it would be easier, sha256_digest() could return a newly allocated buffer
11:50:39 <jedbrown> zooko: Heh, yes.
11:50:40 <zooko> instead of writing into the passed buffer.
11:50:54 <jedbrown> zooko: No, I think it's better to use the Haskell buffer.
11:51:05 <jedbrown> zooko: Then the garbage collector will know about it.
11:51:15 <zooko> jed: so how do I specify that in my hacryptopp.hs ?
11:51:36 <bos> zooko: it would be a shame if you were to use the GPL, just as a by the way.
11:51:41 <Tobsan> @src unsafePerformIO
11:51:42 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
11:52:00 <Tobsan> :s
11:52:17 <zooko> bos: I'm amenable to other options...  let's talk after I have anything worth reusing...
11:52:32 <jedbrown> zooko: You will want need to write a wrapper function sha256 :: ByteString -> ByteString
11:53:16 <jedbrown> zooko: Or make a newtype for the digest.  But that function will allocate memory and then make the foreign calls.
11:53:25 <zooko> jedbrown: oh, I see.  The Haskell user simply wants sha256 :: ByteString -> ByteString
11:53:26 <zooko> Okay.
11:53:27 <dcoutts> actually that's no longer accurate, unsafePerformIO is now:
11:53:27 <dcoutts> unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m)
11:53:45 <dcoutts> and unsafeDupablePerformIO is the previous definition
11:53:47 <zooko> What would be the C function which would be easiest to bind to sha256 :: ByteString -> ByteString?
11:54:13 <zooko> how about void sha256(unsigned char*a, size_t alen, unsigned char*b);
11:54:13 <zooko> ?
11:54:13 <bos> zooko: you should look at the zlib bindings for inspiration, it's essentially the same problem.
11:54:32 <bos> the existing C code is fine.
11:54:50 <jedbrown> zooko: You would write that all in Haskell.  (It will probably use mallocForeignPtrBytes to make space for the digest.)
11:55:07 <edwinb> dons: Thank you for the redditing ;). I'd better get that page up to date...
11:55:22 <jedbrown> zooko: It will use withForeignPtr to get a (Ptr Word) and length information about the bytestring.
11:55:47 <jedbrown> zooko: You will need to add the offset to the pointer before calling C.
11:55:54 <dons> edwinb: :)
11:56:01 <dcoutts> zooko: just make sure the C code does not mutate the input bytestring as that's a big no-no
11:56:02 <dons> edwinb: let's get it on hackage!
11:56:12 <edwinb> yeah, I keep meaning to do that
11:56:20 <edwinb> and document it so it's usable by people other than me...
11:56:30 <jedbrown> dcoutts: Speaking of mutating input, I'm quite bothered by FFTW.
11:56:45 <dcoutts> jedbrown: oh?
11:56:48 <jedbrown> dcoutts: During the planning phase, it mutates the input.  But if it has a plan cached, it won't.
11:56:49 <glen_quagmire> can openFile automatically close Handler when it goes out of scope? like garbage collection
11:57:08 <jedbrown> dcoutts: But you can't inquire whether it has a good enough plan cached.
11:57:13 <glen_quagmire> come up with a one liner monad stuff that openFile safely and hClose automatically
11:57:20 <zooko> jedbrown: I would rather write it in C than in Haskell.
11:57:23 <dcoutts> jedbrown: so you'd have to make a copy :-(
11:57:33 <allbery_b> glen_quagmire:  Control.Exception.bracket
11:57:37 <jedbrown> dcoutts: If you want to do planning, you have to allocate 2 copies, plan, then copy into one.
11:57:44 <dcoutts> jedbrown: right
11:57:47 <allbery_b> @index bracket
11:57:48 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
11:57:52 <zooko> jedbrown: my question is this.  Suppose I want to provide a Haskell function to a Haskell programmer with the type ByteString -> ByteString
11:57:55 <glen_quagmire> :t bracket
11:57:57 <lambdabot> Not in scope: `bracket'
11:58:03 <jedbrown> dcoutts: Or you can do an in-place transform, but that's not optimal either.
11:58:05 <allbery_b> :t Control.Exception.bracket
11:58:06 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:58:06 <zooko> now what is the type of the C function which is easiest to bind to that function?
11:58:23 <zooko> My guess is, something like void f(unsigned char*, size_t, unsigned char*, size_t);
11:58:25 <glen_quagmire> IO b is the rollback IO
11:58:31 <zooko> bos: I'll look at the zlib bindings.  Thanks.
11:58:34 <jedbrown> zooko: Your C functions are just fine.  You need to write one Haskell function which uses those C functions.
11:59:10 <zooko> jed: no, I don't want those C functions.  I want to write a new C function which will make this easier for me by being closer to the HAskell function.
11:59:13 <jedbrown> zooko: You can give it signature (ByteString -> IO ByteString) while you work on it, then unsafePerformIO it once you know it works.
11:59:43 <jedbrown> zooko: That would be harder and less flexible.
11:59:51 <bos> zooko: http://paste.lisp.org/display/55493#1
12:00:12 <bos> there's a typo (missing `), but it should otherwise be fine.
12:00:27 <bos> what modules i'm using, i'll leave as an exercise.
12:00:27 <zooko> bos: thanks!!
12:00:47 <bos> oh, and i forgot to free the sha256 object.
12:01:09 <bos> it would be easy to generalise this to lazy bytestrings.
12:01:21 <zooko> So my declaration of sha256_digest in http://paste.lisp.org/display/55493 still doesn't say that it is passing any bytestring out.
12:01:38 <bos> right.
12:01:41 <bos> that's fine.
12:02:01 <bos> although the type signature is wrong.
12:02:08 <bos> it should be CSHA256 -> Ptr Word8 -> IO ()
12:02:29 <zooko> http://paste.lisp.org/display/55493#2
12:02:34 <dons> oh, is this a bytestring sha256?
12:02:44 <dons> we've already got a patch for that, against the nano-md5 lib
12:03:10 <bos> dons: it's the beginnings of a wrapper for the crypto++ lib.
12:03:12 <dons> matthew_- wrote a full suite of bindings to SHA*
12:03:18 <zooko> dons: Hooray!
12:03:25 <zooko> What implementation, though?
12:03:29 <zooko> http://paste.lisp.org/display/55493#3
12:03:29 <dons> bytestring + openssl
12:03:49 <zooko> dons: there is an irritating licensing issue with openssl, which is why the darcs folks are asking for a different implementation of SHA256.
12:03:55 <dons> ok
12:03:57 <zooko> Also, I am learning something about Haskell...
12:04:00 <bos> crypto++ is a lot cleaner than OpenSSL, and not licensed evilly.
12:04:04 <dons> i'll paste the patch thoguh, you can use it as input
12:04:07 <zooko> But maybe I could copy the bindings that you mentioed.
12:04:09 <zooko> Yes, please.
12:04:15 <zooko> bos: see my #3 attempt?
12:04:43 <bos> zooko: consider using hpaste.org instead, it's nicer than paste.lisp.org for haskell
12:04:48 <dons> http://hpaste.org/5510
12:04:56 <bos> zooko: looks reasonable.
12:05:00 * monochrom spontaneously contemplates hijacking hpaste as a personal blog.
12:05:29 <dons> comes with quickchecks too
12:05:53 <bos> of course, exposing the underlying bindings would also be nice.  that way, we could build SHA256 of Storable instances.
12:05:54 <soduko> @paste
12:05:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:07:02 <dons> yes, i think good practice is to have the underlying ffi's always exported from some Base.hsc
12:07:08 <dons> then wrap them up in the main module
12:07:18 <dons> that way you can always work back down a level if you need to
12:07:30 <zooko> dons: I'm sorry, I'm afraid I don't know what you are talking about.
12:07:40 <zooko> I'm completely unfamiliar with almost all of these tools.  :-(
12:07:46 <zooko> I mean, including the Haskell programming language itself.
12:07:50 <dons> hehe
12:08:01 <zooko> I'll be right back.
12:08:13 <bos> zooko: #3 is fine.
12:08:43 <scodil> is there a good tutorial, or some examples, about c2hs? The material on the author's website reads a bit like manpages.
12:09:03 <dcoutts> scodil: see the cairo bindings in gtk2hs, that's a good example
12:11:13 <scodil> cool, thanks. and I've probably asked this at least twice before, but no one ever responds: can I use something like a pthread mutex in a C function called by multiple GHC threads? Is that guaranteed safe?
12:11:29 <jedbrown> dcoutts: Despite the excessive memory allocation, I do have working FFTW bindings for complex and real/complex transforms.  There are a bunch of real/real transforms that I haven't implemented yet, but will soon.
12:11:33 <dcoutts> scodil: it's a tricky question ;-)
12:11:59 <jedbrown> scodil: Would a haskell-side lock be appropriate?
12:12:00 <lament> jedbrown: nice
12:12:01 <dcoutts> jedbrown: nice.
12:12:26 <scodil> jedbrown: I guess so. but there's gotta be a lock in the C function too, so it would be redundant.
12:12:40 <scodil> for now though, i guess that suffices
12:12:47 <qwe> is it possible to implement filter function by foldr ?
12:12:50 <dcoutts> scodil: it's probably ok so long as the ffi calls are marked safe
12:13:07 <oerjan> qwe: yes
12:13:17 <jedbrown> scodil: For instance, FFTW does not have thread-safe planning, so I use a haskell-side lock.
12:13:19 <scodil> dcoutts: does that make all threads block? even real RTS threads?
12:13:21 <dcoutts> scodil: or perhaps even that's not necessary
12:13:39 <qwe> oerjan: can you help me with that
12:13:39 <dcoutts> scodil: a safe call does not block other Haskell threads
12:13:53 <scodil> does unsafe?
12:14:13 <dcoutts> scodil: an unsafe call does block, so it's usually used only for very short running functions
12:14:41 <scodil> dcoutts: ok but does it block just the lightweight threads, or does it also block the real/kernel/smp threads?
12:15:32 <dcoutts> scodil: an unsafe call blocks the whole 'capability' which is usually the entire haskell system, unless you're using SMP with multiple capabilities.
12:16:06 <dcoutts> scodil: so it blocks all other haskell threads running in the same capability, which usually means the same cpu
12:16:40 <scodil> ok so it _doesn't_ block threads running on other cpus/cores/etc.
12:16:45 <qwe> can you help me to implement filter function by foldr
12:17:07 <dcoutts> scodil: right, but all haskell threads that were running on the same core are blocked.
12:17:26 <dcoutts> scodil: and I don't think they get the chance to migrate from the blocked capability
12:17:38 <dcoutts> scodil: also, unsafe calls are not allowed to call back into Haskell land
12:17:48 <scodil> dcoutts: gotcha. so its not a sufficient synchronisation mechanism for some shared resource in C land
12:18:07 <dcoutts> scodil: no
12:18:31 <dcoutts> scodil: for that you should use an MVar or a C posix lock of some kind
12:18:43 <GrayShade> :t flip foldr [] . flip flip id . (`ap` (:)) . (if' .)
12:18:44 <lambdabot> Not in scope: `if''
12:18:54 <scodil> dcoutts: that was my question! do C posix locks mess up Haskells RTS threads?
12:19:04 <dcoutts> scodil: I don't think so
12:19:23 <dcoutts> scodil: it's ok for safe calls to block in foreign code
12:20:07 <jedbrown> dcoutts: Should I be using "safe" calls for compute-intensive calls.  How much performance difference is there between safe and unsafe.
12:20:09 <scodil> which calls are faster? safe or unsafe? I mean if its just a few lines of C
12:20:13 <scodil> hah
12:20:16 <scodil> jinx
12:20:26 <dcoutts> unsafe calls are much lower overhead
12:20:35 <dcoutts> well, 'much' is relative :-)
12:20:57 <dcoutts> try it, benchmark calling 'cos' or something with safe vs unsafe.
12:21:04 <bos> well, you should use the kind of call that's appropriate, not the one that looks shinier.
12:21:55 <jedbrown> dcoutts: When I make a FFTW plan, I don't know if it will return immediately (it has the right plan cached) or if it will take a long time (seconds to minutes).
12:22:02 <dcoutts> scodil: so if the foreign code cannot ever call back into Haskell land and it is very short running then unsafe is appropriate, otherwise go with safe.
12:22:21 <dcoutts> jedbrown: go with safe then so you don't block other haskell threads.
12:23:06 <scodil> dcoutts: ok, I don't usually call back into Haskell from C, but I might allocate memory, from a pool or something, and so I'd want a lock on that. Do I need 'safe' to do that?
12:23:27 <dcoutts> scodil: no you don't
12:23:30 <scodil> ok cool
12:23:52 <bos> sorear wrote up a table last year of what "safe" and "unsafe" really mean, but i can't find it.
12:24:03 <dcoutts> scodil: see ghc's docs for details, there are only two conditions to satisfy for unsafe.
12:25:05 <Deewiant> @pl if' x y z = if x then y else z
12:25:05 <lambdabot> if' = fix id
12:25:08 <Deewiant> ^ the hell?
12:25:42 <oerjan> Deewiant: @pl uses if' for if-then-else
12:25:59 <Deewiant> oerjan: I know. Why does it transform that to "fix id", though?
12:26:06 <oerjan> so it makes the right side equal to left, and then:
12:26:15 <oerjan> @pl f x y z = f x y z
12:26:15 <lambdabot> f = fix id
12:26:22 <Deewiant> Ah, I see.
12:26:27 <jedbrown> @pl \a b c -> if a then b else c
12:26:27 <lambdabot> if'
12:26:56 <Deewiant> @pl f = f
12:26:56 <lambdabot> f = fix id
12:31:13 <qwe> in the foldr function foldr :: (a -> b -> b) -> b -> [a] -> b i can't understand (a->b->b)
12:31:23 <qwe> it is the place of the operator
12:31:41 <qwe> but why it is (a -> b -> b)?
12:31:41 <Twey> qwe: A function that takes an a and a b and returns a b
12:32:16 <Twey> E.G. (+) :: (a -> b -> b)
12:32:35 <Twey> Because you can add, say, an Int and an Integer
12:32:42 <GrayShade> qwe: what function can you use for that argument to make foldr return a list?
12:33:40 <qwe> <GrayShade>  didnt understand you
12:34:20 <GrayShade> qwe: how can you get a list with foldr?
12:34:28 <qwe> list of what ?
12:34:37 <nominolo> > foldr (:) [] [1..5]
12:34:38 <lambdabot>  [1,2,3,4,5]
12:35:10 <GrayShade> that's half of your filter function
12:35:15 <qwe> foldr (\x y->y++[x]) [] [1..5]
12:35:26 <qwe>  >foldr (\x y->y++[x]) [] [1..5]
12:35:26 <nominolo> > foldl (flip (:)) [] [1..5]
12:35:26 <lambdabot>  [5,4,3,2,1]
12:35:43 <qwe>  > foldr (\x y->y++[x]) [] [1..5]
12:35:55 <nominolo> qwe: no space at the beginning
12:36:03 <qwe> > foldr (\x y->y++[x]) [] [1..5]
12:36:04 <lambdabot>  [5,4,3,2,1]
12:36:08 <qwe> :)
12:36:33 <EvilTerran> appending to the end of a list isn't very efficient, mind
12:36:37 <nominolo> qwe: this is rather slow though
12:36:47 <qwe> still i dont understand the letters at the signiture
12:36:51 <qwe> foldr :: (a -> b -> b) -> b -> [a] -> b
12:36:52 <GrayShade> @src reverse
12:36:52 <lambdabot> reverse = foldl (flip (:)) []
12:36:54 <grahamhutton> @seen andyjgill
12:36:55 <lambdabot> I saw andyjgill leaving #darcs, #haskell and #ghc 3d 15h 48m 55s ago, and .
12:37:04 <GrayShade> they're types
12:37:08 <qwe> why not all letters are the same here?
12:37:26 <GrayShade> because it's more general
12:37:28 <nominolo> qwe: that would be too restrictive
12:38:00 <qwe> so why it (a->b->b) and not say (a->b->a)?
12:38:11 <nominolo> ;t foldl
12:38:14 <nominolo> :t foldr
12:38:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
12:38:21 <nominolo> :t foldl
12:38:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:38:32 <nominolo> that depends on the direction
12:38:42 <nominolo> it's in fact arbitrary, though
12:39:00 <nominolo> depends on how you define foldl and foldr
12:39:33 <qwe> and why it at the end b and not [b] ?
12:39:42 <qwe> > foldr (\x y->y++[x]) [] [1..5]
12:39:42 <lambdabot>  [5,4,3,2,1]
12:39:55 <idnar> you don't have to get a list
12:39:56 <GrayShade> > foldr (+) [1..5]
12:39:56 <nominolo> in that special case b = [c]
12:39:57 <lambdabot>   add an instance declaration for (Num [t])
12:39:58 <soduko> what is wrong with the funciton forloop? : http://hpaste.org/5512
12:40:00 <idnar> > foldr (\x y->y++x) 0 [1..5]
12:40:01 <lambdabot>   add an instance declaration for (Num [a])
12:40:01 <lambdabot>     In the expression: 5
12:40:04 <idnar> doh
12:40:11 <GrayShade> > foldr (+) 0 [1..5]
12:40:11 <lambdabot>  15
12:40:15 <idnar> > foldr (\x y->y+x) 0 [1..5]
12:40:15 <lambdabot>  15
12:40:34 <qwe> back reading
12:41:52 <vincenz> araujo: bleh
12:43:06 <soduko> @let fn n (a:as) | ( n >= 3) = fn n (a:as)
12:43:11 <lambdabot> Defined.
12:43:44 <vincenz> qwe: qwe1234?
12:43:45 <soduko> @let fn 3 ("xyz":as) = ["xyz"]
12:43:45 <lambdabot> Defined.
12:43:58 <monochrom> soduko: To whom do the lines "help_func" and "exitWith (ExitFailure 1)" belong?
12:44:09 <soduko> @let fn _ [] = []
12:44:10 <lambdabot> Defined.
12:44:19 <soduko> monochrom they are supposed to be a comment.
12:44:39 <monochrom> But you can see from the colour highlighting that they are not.
12:44:51 <monochrom> -- comments just one line. {- -} block
12:44:54 <soduko> forgot to remove them
12:45:13 <soduko> i pasted only part of the code..
12:46:20 <oerjan> soduko: fn n (a:as) | ( n >= 3) = fn n (a:as) won't ever give anything because you are turning it into the exact same call...
12:47:12 <soduko> http://hpaste.org/5512#a1
12:48:07 <soduko> how do i make it match any number for the first char, but something specific for the seond?
12:48:20 <soduko> basically n is a state variable ..
12:48:47 <soduko> > fn 1 "xyz"
12:48:48 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
12:49:08 <oerjan> soduko: (x:'c':xs) ?
12:49:31 <monochrom> I get plain.hs:15:25: Not in scope: `parse'
12:49:41 <qwe> question about length function
12:49:46 <soduko> second argument to the function not the second elemnt of the second arg
12:49:50 <monochrom> I'm too lazy to reproduce the alleged pattern matching error.
12:50:04 <qwe> > foldr (\ _ n -> n+1) 0 [1..10]
12:50:05 <lambdabot>  10
12:50:19 <qwe> how i can understand here the n argument
12:50:32 <qwe> it what comes from the recursion ?
12:50:38 <soduko> qwe n is used as an accumulator here
12:50:39 <monochrom> Yes.
12:51:28 <qwe> ok now i am starting to understand it
12:52:50 <oerjan> soduko: anyway otherwise  -> forloop i (a:as)  is the reason for your infinite loop
12:53:01 <GrayShade> why do people prefer fix f = let x = f x in x instead of fix' f = f $ fix' f ?
12:53:19 <soduko> http://hpaste.org/5512#a2 this should compile
12:53:36 <araujo> vincenz, I think Haskell damaged too much my brain :-)
12:54:06 <soduko> oerjan  i assumed that if one of the args was more specific, it would use that version of the function instead
12:54:08 <vincenz> araujo: idem
12:54:39 <oerjan> soduko: but if it ever gets to that otherwise it means nothing else did match, and it won't when it's recalled either
12:55:24 <qwe> i am trying to make filter function now
12:55:25 <qwe> filter even [1,2,3,4,5]
12:55:32 <monochrom> OK, I see "Warning: accepting non-standard pattern guards (use -XPatternGuards to suppress this message)".  It seems perfectly plain English and sound advice.
12:55:33 <qwe>  foldr(\x y z->if(y x) then x:z else z)[] even [1,2,3,4,5]
12:55:34 <oerjan> GrayShade: sharing of the x
12:55:37 <bos> @hoogle a -> [a] -> [[a]]
12:55:38 <lambdabot> No matches, try a more general search
12:55:44 <qwe> what is wrong here ?
12:55:59 <wli> {-# LANGUAGE PatternGuards #-}
12:56:01 <monochrom> "blah blah blah | Just par <- (isInt a) = ..." is a non-standard extension.
12:56:07 <monochrom> And yeah, what wli says.
12:56:30 <monochrom> Or what the warning says, add -XPatternGuards to your ghc invocation.
12:56:42 <oerjan> qwe: the y shouldn't be an argument to the lambda
12:57:22 <soduko> monochrom that is a warning abt non standard extension, but the compiler still supports it, that is not causing the recursion.
12:58:12 <monochrom> Unfortunately I am only interested in getting it to compile.
12:58:49 <qwe> so how it should be ?
12:58:51 <soduko> :) it did compile.
12:59:25 <EvilTerran> GrayShade, the "let x = f x" version has better sharing
12:59:28 <doserj> qwe: put the even directly into the lambda
12:59:37 <monochrom> I mistook "bad pattern matching" for a syntax help plea.
12:59:45 <araujo> vincenz, are you working on your own implementation of arc?
12:59:46 <GrayShade> i see
12:59:56 <EvilTerran> it means fix (1:) only causes one list cell to be created, with itself as its tail
13:00:10 <qwe> but i want it work with differnt functions not only with even
13:00:17 <glen_quagmire> catch (inh <- openFile fn ReadMode)  (\ err -> error $ show err)   how do I do this?
13:00:18 <EvilTerran> because it's "let x = 1:x in x" - clearly you only need one cell for x
13:00:29 <oerjan> > foldr(\x z -> if(even x) then x:z else z)[] [1,2,3,4,5]
13:00:30 <lambdabot>  [2,4]
13:00:35 <GrayShade> (\p xs -> foldr (\x -> if p x then (x:) else id) [] xs) (\x -> x `rem` 3 == 0) [1..100]
13:00:42 <GrayShade> > (\p xs -> foldr (\x -> if p x then (x:) else id) [] xs) (\x -> x `rem` 3 == 0) [1..100]
13:00:45 <glen_quagmire> how can I wrap openFile call in catch? or should I?
13:00:46 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
13:00:56 <vincenz> araujo: yeah
13:01:01 <EvilTerran> but it's not immediately obvious that fix (1:) = 1 : fix (1:) = 1 : 1 : fix (1:) = ... should only need one cell
13:01:16 <vincenz> araujo: started 2 days ago, but been busy with other stuff, but it won't take 6 years ;)
13:01:33 <araujo> vincenz, hahaha
13:01:40 <araujo> vincenz, writing it on Haskell?
13:01:55 <qwe> oerjan but it should be not specific function even it can be any function there
13:01:58 <soduko> fn 3 "xyz"
13:02:00 <vincenz> araujo: no
13:02:05 <soduko> > fn 3 "xyz"
13:02:05 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
13:02:14 <soduko> > fn 3 'x'
13:02:14 <lambdabot>  Couldn't match expected type `[[Char]]'
13:02:16 <GrayShade> qwe: look up
13:02:17 <araujo> vincenz, what language?
13:02:23 <vincenz> araujo: same, scheme
13:02:28 <araujo> ah ok
13:02:36 <vincenz> it's nice for meta-circular thingies :)
13:02:45 <araujo> vincenz, well, there you have my first suggestion :-P
13:02:52 <vincenz> araujo: #oasis
13:03:22 <qwe> GrayShade you also did it for rem 3 function
13:03:38 <qwe> cant i make it so it get any function as argument ?
13:03:47 <GrayShade> qwe: read again
13:05:56 <qwe> GrayShade i think i am blind i cant see the answer there :(
13:06:15 <GrayShade> qwe: \p xs -> foldr (\x -> if p x then (x:) else id) [] xs
13:06:15 <araujo> ehird`, hey, how that arc implementation goes? :-)
13:06:23 <GrayShade> qwe: that one works with any function
13:06:45 <qwe> what is it id here ?
13:06:54 <GrayShade> @src id
13:06:54 <lambdabot> id x = x
13:07:04 <qwe> ok
13:07:35 <EvilTerran> GrayShade, while you're cutting down on parameters, you can beta-reduce the xs out of existance there
13:07:58 <GrayShade> indeed
13:08:14 <EvilTerran> \p -> foldr (\x xs -> if p x then x:xs else xs) [] -- is how i'd be inclined to formulate it
13:09:04 <EvilTerran> i think beta-expanding the parameter function is worthwhile to get rid of that id, unless you're playing golf or something
13:09:24 <Sgeo> Hi all/No all/Sal cxiu/Coi
13:09:32 <qwe> what i wrote wrong here ?
13:09:50 <qwe>  \p -> foldr (\x xs -> if p x then x:xs else xs) [] [1,2,3] even
13:10:05 <EvilTerran> predicate then list
13:10:10 <EvilTerran> not vice-versa
13:10:17 <EvilTerran> ?type \p -> foldr (\x xs -> if p x then x:xs else xs) [] -- informative
13:10:18 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:10:42 <EvilTerran> also, you need to wrap the (\p -> foldr (\x xs -> if p x then x:xs else xs) []) in parentheses if you want that to work right
13:10:57 <EvilTerran> otherwise it doesn't know where the else block finishes
13:11:06 <EvilTerran> s/block/expression
13:11:15 <EvilTerran> (or indeed where the body of the lambda finishes)
13:12:28 <radetsky> can anybody recommend a good, thorough, practical introduction to state with monads?
13:12:44 <radetsky> I'm already comfortable with the basic monad operations and IO
13:13:09 <dons> the main thing then is to practice using runState and execState, and the get/put operations on the state
13:13:16 <dons> from Control.Monad.State
13:13:27 <dons> > runState (do x <- get; put (x+1)) 0
13:13:27 <lambdabot>  ((),1)
13:13:34 <dons> > runState (do x <- get; put (x+1); return "woot") 0
13:13:35 <lambdabot>  ("woot",1)
13:13:47 <GrayShade> radetsky: or something like http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm for the basics
13:13:47 <lambdabot> Title: Monads for the Working Haskell Programmer
13:13:48 <dons> bit of numeric state got threaded through the code there
13:14:08 <qwe> it still make problems for me
13:14:09 <qwe> (\p -> foldr (\x xs -> if (p x) then x:xs else xs)) []  [1,2,3]  even
13:14:34 <GrayShade> qwe: wrong order for the last parameters
13:14:41 <GrayShade> s/for/of/
13:15:17 <monochrom> Haha "Monads for the Working Haskell Programmer" great title.
13:15:28 <bos> dons: are you getting my privmsgs?
13:15:37 <qwe> GrayShade i cant understand where it is wrong
13:15:47 <qwe> it looks like ok for me
13:15:59 <monochrom> Oh, Norvell is a favourite author of mine. :)
13:16:14 <GrayShade> > (\p -> foldr (\x xs -> if (p x) then x:xs else xs)) even [1, 2, 3]
13:16:15 <lambdabot>  <[Integer] -> [Integer]>
13:16:16 <qwe> p gets even x gets [1,2,3] xs gets []
13:16:19 <monochrom> "New: Updated to Haskell '98." is a bit un-new. :)
13:16:59 <dons> bos, no?
13:17:07 <dons> oh. me.
13:17:07 <qwe>  (\p -> foldr (\x xs -> if (p x) then x:xs else xs)) [] even [1, 2, 3] doesnt work
13:17:08 * monochrom contemplates cloning this one and saying "New: Updated to MPTC MTL AllowUndecidableInstances ..."
13:17:14 <bos> ah.
13:17:32 <bos> dons: i was asking if you'd sorted out key issues with CosmicRay
13:17:38 <qwe> ok i got it thanks
13:17:57 <bos> wow, my old thesis advisor from 1995 just popped up on haskell-cafe.
13:18:04 <monochrom> Actually how could one be a "working Haskell programmer" without already knowing substantially about monads?
13:18:10 <bos> i didn't even know he knew how to spell haskell!
13:18:29 <soduko> can any one explain this? pls see the notes at the end of the listing http://hpaste.org/5512#a3
13:18:37 * monochrom heads over to haskell-cafe
13:19:41 <qwe> why here (\p -> foldr (\x xs -> if (p x) then x:xs else xs)) even [1, 2, 3] []::: p gets the  even argument and not the [] ??
13:19:53 <soduko> weirdly if i give -seed nnn where nn is not one of the first three integer args, it works
13:20:07 <qwe> isnt it should be outer first ?
13:21:23 <qwe> any idea ?
13:21:50 <GrayShade> :t (\p -> foldr (\x xs -> if (p x) then x:xs else xs))
13:21:51 <lambdabot> forall a. (a -> Bool) -> [a] -> [a] -> [a]
13:22:10 <GrayShade> wtf?
13:22:31 <soduko> duh!! theres a nub, which eats it up :)
13:23:10 <monochrom> qwe: argument order. try (...) even [] [1,2,3]
13:23:32 <GrayShade> the type signature looks fishy
13:23:40 <monochrom> The type signature is just fine.
13:24:04 <GrayShade> :t filter
13:24:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:24:25 <monochrom> If your question is why p is given even, the answer is that's the way it should be. (\p -> blah blah blah) the first argument is given to p.
13:24:59 <visof> i have error  in installing zlib
13:25:02 <visof> visof@visof:/usr/local/zlib-0.4.0.1$ sudo runghc Setup.hs install
13:25:03 <visof> Installing: /usr/local/lib/zlib-0.4.0.1/ghc-6.8.1
13:25:03 <visof> Setup.hs: Error: Could not find module: Codec.Compression.GZip with any suffix: ["hi"
13:25:05 <GrayShade> ah, that should have been (\p -> foldr (\x xs -> if (p x) then x:xs else xs) [])
13:25:11 <visof> sorry for mess
13:25:29 <monochrom> Yes, hardwire [] at the right place and you get filte.r
13:26:36 <monochrom> Did you do "runghc Setup.hs build"? Was it successful?
13:26:40 <qwe> still here foldr(\x  z->if(even x) then x:z else z)[] [1,2,3,4,5] it just the oposit of getting the arguments x gets the list and z the []
13:27:15 <monochrom> z doesn't always get the [].
13:27:26 <GrayShade> and x never gets the list
13:27:33 <soduko> ha!! atlast i have the argument parsing done:) now on to the meatier part of the actual algo :)
13:27:44 <soduko> thanks folks
13:27:46 <monochrom> And foldr can certainly use your provided function (\x z -> ...) as it sees fit.
13:29:09 <qwe> so why the arguments in the two examples gotten from opposit directions ?
13:29:30 <lispy> why does GHC warn about orphan instances?
13:29:51 <BMeph> lispy: Because GHC Cares for the Orphans. ;)
13:29:51 <monochrom> I hope you have the sophistication to realize (\x z -> ...) is different from foldr (\x z -> ...) and generally f (\x z -> ...) for arbitrary f?
13:30:04 <monochrom> > flip (\x z -> (x,z)) 3 4
13:30:05 <lambdabot>  (4,3)
13:30:19 <monochrom> Do you even find that strange?
13:31:45 <monochrom> Is higher-order function really that hard to grasp?
13:32:42 <GrayShade> qwe: do you prefer let filter' p = foldr (\x xs -> if (p x) then x:xs else xs) [] ?
13:34:45 <monochrom> foldr f a (x:xs) = f x (foldr f a xs). It deliberately completely reshuffles your data.
13:35:52 <lispy> but I liked my data
13:35:56 <monochrom> If you hate that, you can always write your own myfoldr f (x:xs) a = f x (myfoldr f xs a).
13:36:21 <visof> http://hpaste.org/5514
13:37:03 <GrayShade> visof: don't you need zlib-devel or something?
13:37:06 <lispy> visof: the natural question: Do you have zlib.h on your system?
13:37:29 <visof> i don't know
13:37:55 <lispy> visof: it's not going to be included in that zlib package because it's just haskell bindings to the real zlib
13:38:13 <lispy> visof: so you'll need to get zlib somehow.  How depends on your OS/setup
13:38:50 <visof> lispy ubuntu
13:38:58 <GrayShade> more thrilling is trying to compile hsql-mysql on windows -- it asks for a dll that probably never existed
13:38:59 <monochrom> If a hackage package binds to a C lib, the C lib is sold separately.
13:39:05 <jedbrown> visof: aptitude install zlib1g zlib1g-dev
13:39:41 <monochrom> "Download GHC now! Batteries sold separately."
13:40:25 <monochrom> And my naughty extreme case:
13:41:17 <monochrom> (On a can of soup, with picture showing a bowl of soup) "Picture shows only suggested serving. Bowl sold separately." :)
13:41:56 <BMeph> Ubuntu 9.10: Lispy lispy? ;)
13:43:01 <lispy> BMeph: sorry?
13:44:50 <BMeph> lispy: Just projecting a suitable name for Ubuntu's 9.10 version.
13:45:13 <lispy> BMeph: oh, nice
13:45:15 <lispy> :)
13:45:27 <bos> they'll probably be at zippy zebra by then.
13:48:19 <byorgey> then what?  Aaraonic Aardvark?
13:49:08 <monochrom> Hahahaha
13:49:19 <scodil> then they get into chinese.
13:49:25 <scodil> they'll never run out of characters
13:49:44 <bos> then they'll use the names of unicode code points.
13:50:12 <bos> i look forward to "ubuntu 99.99 glagolitic capital letter spidery ha"
13:50:13 <scodil> Ubuntu 21.05 : RightArray SmileyFace
13:50:16 <scodil> RightArrow
13:50:33 <byorgey> such as U+FDD0?
13:50:35 <monochrom> module Control.TheCoolestAbstract. where ...
13:50:38 <sieni> the entry in the "encyclopaedia of ball juggling" about aarvark is pretty hilarious
13:50:58 <byorgey> monochrom: wow, nice =)
13:51:01 <monochrom> @bots
13:51:01 <lambdabot> :)
13:51:12 <sieni> something along the lines of "all encyclopedias start with an entry about aardvark, so why should this be any different" or something
13:51:18 <monochrom> dons should change that to U+FDD0 for at least today :)
13:51:24 <bos> hmm, only shows up as boxes for me.
13:51:31 <bos> i must be missing some chinese fonts.
13:51:38 <monochrom> hehe yeah Chinese
13:51:49 <byorgey> monochrom: I just submitted a patch for a new @basilisk command =)
13:51:59 <monochrom> onoes
13:53:00 <monochrom> massive masacre of a wholesome portion of the haskell community. computer science will be set back for 40 years.
13:53:31 <visof> http://hpaste.org/5515
13:53:39 <monochrom> Or is it sped up? Because with the community loss, Haskell will avoid success again for 40 years. :)
13:54:06 <byorgey> monochrom: hehe, good point =)
13:54:20 <bos> visof: more details?
13:54:46 <visof> bos that's what i have
13:54:51 <visof> that's all
13:55:06 <bos> visof: you haven't said what OS, distro, version of GHC, ...
13:55:19 <GrayShade> visof: do you have gmp-devel? or what it's called like
13:55:21 <visof> ghc-6.8.1
13:55:27 <b_jonas> lol
13:55:33 <b_jonas> xkcd
13:55:43 <bos> probably gmp-dev
13:56:20 <visof> i did it
13:56:40 <vincenz> b_jonas: I don't get it
13:56:49 <GrayShade> stupid exam tomorrow.. i have to learn the format of i8080 opcodes
13:58:10 <monochrom> vincenz: you probably need to look up basilisk. I did on wikipedia and never regretted it. :)
13:58:48 <vincenz> monochrom: link?
13:59:14 <monochrom> http://en.wikipedia.org/wiki/Basilisk
13:59:14 <vincenz> monochrom: I know what a basilisk is
13:59:16 <vincenz> monochrom: what's the :)
13:59:30 <sclv_> eyes, dood.
13:59:36 <sclv_> (and a mouth)
13:59:48 * vincenz shrugs
14:00:06 <GrayShade> vincenz: http://xkcd.com/
14:00:06 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
14:00:07 <monochrom> :) is a smile from the bsilisk on the other end that accidentally contains a stare. The stare killed the human.
14:00:11 * vincenz didn't think it was funy ;)
14:00:27 <vincenz> i was looking for a deeper meaning
14:00:47 <monochrom> It's a great tragedy. The basilisk wanted to be friendly but the kind gesture caused great loss.
14:01:46 <sclv_> it sucks to be a basilisk.
14:02:13 <monochrom> You may object that, through the filtering of computers, a colon couldn't kill...  But let's just assume mythical magical powers while we are at it. :)
14:03:07 <sclv_> monochrom: a basilisk I buy. but assuming mythical magical powers!? now you're straining credulity.
14:03:24 <Cale> Whoa, I just realised that rather than being something to worry about, the new stuff in GHC regarding type equality should actually make row polymorphism easier.
14:03:40 <monochrom> Such as that horror movie concerning watching a video tape (even a pirated one!) and a woman crawls out of the screen.
14:04:11 <monochrom> Nice, Cale, it's best when a problem turns out to be a solution. "Don't be a problem, be a solution!" :)
14:05:36 <Saizan> row polymorphism?
14:05:45 <Saizan> as in subtyping?
14:05:53 <monochrom> Most likely.
14:06:14 <monochrom> The cleanest road to extensible records.
14:07:28 <dons> dcoutts: idea: mkcabal via a web form.
14:07:38 <dons> fill in the fields, and it spits out your cabal file
14:08:19 <Cale> as in: http://www.cs.ioc.ee/tfp-icfp-gpce05/tfp-proc/21num.pdf
14:09:00 <Cale> or: http://research.microsoft.com/users/daan/download/papers/scopedlabels.pdf
14:09:01 <lambdabot> http://tinyurl.com/392r4k
14:09:06 <Cale> (which describe the same system)
14:10:09 <Cale> er, not quite the same system :)
14:11:27 <Cale> Er, oh, yeah, those are the same :)
14:11:44 <Cale> http://research.microsoft.com/users/daan/download/papers/fclabels.pdf -- this one isn't though
14:11:44 <lambdabot> http://tinyurl.com/2m9n8b
14:14:05 <Cale> So it's not exactly subtyping, and it doesn't involve lacks predicates.
14:14:33 <Cale> But you get some of the effect of subtyping.
14:15:35 <jedbrown> dons: How is that more than a well documented template?  mkcabal gives you LICENSE and Setup.lhs as well.
14:18:29 * allbery_b 's lambdabot is now running against a hacked network package with most syscalls flagged safe
14:19:33 <allbery_b> (wedged on URLS twice s far today)
14:19:46 <visof> i have error when i installed HTTP :
14:19:48 <visof> Setup.lhs: Error: Could not find module: Network.HTTP with any suffix: ["hi"]
14:19:59 <visof> what should i do?
14:20:24 <GrayShade> you should install network.http from hackagedb?
14:20:27 <Saizan> did you build first?
14:20:36 <GrayShade> download and build*
14:21:03 <ehird`> wjp ,emtopmed ,u ma,e
14:21:05 <ehird`> er
14:21:07 <ehird`> who mentioned my name
14:21:15 <visof> ya
14:21:21 <visof> i built it first
14:21:30 <GrayShade> did you runghc setup install ?
14:21:30 <ehird`> hm, araujo disappeared.
14:21:33 <visof> i have some warnings
14:21:42 <visof> ya
14:22:16 <visof> visof@visof:/usr/local/HTTP-3001.0.0$ sudo runghc Setup.lhs install
14:22:18 <visof> Installing: /usr/local/lib/HTTP-3001.0.0/ghc-6.8.1
14:22:18 <visof> Setup.lhs: Error: Could not find module: Network.HTTP with any suffix: ["hi"]
14:23:50 <Saizan> has the build phase been successful?
14:24:27 <visof> with  some warnings
14:45:41 <soduko> > @let sfunc Just par = True
14:45:41 <lambdabot>  Parse error at "@let" (column 1)
14:45:57 <soduko> > @let sfunc (Just par) = True
14:45:57 <lambdabot>  Parse error at "@let" (column 1)
14:46:07 <soduko> @let sfunc (Just par) = True
14:46:09 <lambdabot> Defined.
14:46:20 <soduko> @let sfunc _ = False
14:46:21 <lambdabot> Defined.
14:46:31 <soduko> @pl sfunc
14:46:31 <lambdabot> sfunc
14:46:54 <soduko> grr how do i get a succinct form of the function?
14:47:21 <Lemmih> Huh?
14:48:07 <soduko> point free form
14:48:12 <Lemmih> isJust.
14:48:20 <monochrom> haha
14:48:42 <soduko> yeah but my code has a different constructor than Just so i cant use is Just directly
14:49:00 <Lemmih> soduko: Then you're boned.
14:49:04 <blackdog> probably a dumb question, but i've just upgraded to the latest bytestring library, and i'm getting this error from the compiler:
14:49:08 <blackdog>     Couldn't match expected type `bytestring-0.9.0.1:Data.ByteString.Lazy.Internal.ByteString' against inferred type `Lazy.ByteString'
14:49:17 <blackdog> any ideas?
14:49:17 <soduko> so i was trying to see what lambdabot gives
14:49:27 <byorgey> blackdog: let me guess, are you trying to compile yi?
14:49:32 <blackdog> no, actually
14:49:33 <soduko> Lemmih: are you the happs guy?
14:49:38 <Lemmih> blackdog: You may have two versions of bytestring installed at the same time.
14:49:39 <blackdog> my own code - scrabble solver
14:49:42 <Lemmih> soduko: Yeah.
14:50:08 <dcoutts_> dons: hmm, maybe. Ultimately I'd like to see Cabal work without any .cabal file at all for casual stuff, like hmake. Then we should be able to infer and generate a correct initial .cabal file.
14:50:20 <soduko> great. do you know if there is any more documentation? i got the basic html file server running by followin the instructions on happs.org
14:50:36 <soduko> would be great if there are any more tutorial type stuff :)
14:50:44 <blackdog> Lemmih: ah. possibly. how do i find out what versions are installed?
14:50:52 <dcoutts_> dons: like hmake or ghc --make, but with extra goodness (like parallel builds, pre-processors etc etc)
14:51:21 <Lemmih> blackdog: ghc-pkg list bytestring
14:52:25 <zooko> http://allmydata.org/source/hacryptopp/
14:52:26 <lambdabot> Title: Index of /source/hacryptopp
14:52:54 <blackdog> ah, and all is clear - user and system packages are conflicting. Thanks.
14:53:04 <Lemmih> soduko: Sorry, we only have a few examples for now.
14:55:51 <soduko> basically if there is more info on how to use the dir etc.. i can spend some time and try to figure things out
14:56:07 <soduko> doing everything from scratch seems like a bigger challenge than i can take up now
15:00:31 <Lemmih> soduko: You might be interested in the examples from HAppS-Server/Examples/set/
15:01:30 <Lemmih> soduko: Waiting till after the release is probably easiest.
15:02:25 <dcoutts_> Lemmih: any eta on that btw? perhaps in time for the hackathon?
15:06:17 <zooko> I justed added the Tiger hash to hacryptopp
15:06:33 <dons> ha-crypto-pp ?
15:06:35 <dons> :)
15:07:00 <zooko> dons: I don't get it.  "ha" for haskell and "cryptopp" for "Crypto++"
15:07:15 <dons> ah pp
15:07:21 <dons> yes, i was trying to decode the name
15:07:54 <zooko> Yeah.
15:08:06 <zooko> Thank you very much for the help with Haskell bindings.
15:08:26 * lispy read eta as 'eta' the greek letter, and also a form of lambda reduction...and was confused :)
15:08:58 <zooko> brb
15:15:26 <dozer> Hi,
15:15:32 <dozer> can I use fundeps on a datatype?
15:15:50 <ddarius> dozer: And what would that mean?
15:16:29 <dozer> ddarius: similar to classes - it restricts the range of types you can instantiate a datatype with
15:17:14 <dozer> I guess it's just a syntactic variant on making a class with a fundep and then using this to guard the datatype
15:17:23 <Saizan> dozer: seen gadts?
15:17:37 <dozer> Saizan: yup, but not sure they do what I want
15:18:02 <dozer> so, say we have an XML library (because that's all I think about these days)
15:18:40 <Saizan> dozer: you can have constructors that instantiates the tyvars differently
15:19:02 <dozer> element/attribute names can be strings, or can be QNames - so can parameterise XMLNode over this
15:19:46 <dozer> in the case of QNames, the element needs a different data-structure to handle namespace attributes seperately from ones used for data
15:26:32 <soduko> easy way to match an element in a list of Custom Construced values?
15:27:28 <monochrom> Do you mean... ?
15:27:41 <soduko> @let data Flag = Start Integer | Stop Integer | Error deriving(Eq,Ord,Show)
15:27:41 <lambdabot> Invalid declaration
15:28:07 <monochrom> Screw @let. Just explain to me.
15:28:18 <soduko> @data Flag = Start Integer | Stop Integer | Error deriving(Eq,Ord,Show)
15:28:18 <lambdabot> Unknown command, try @list
15:28:27 <soduko> data Flag = Start Integer | Stop Integer | Error deriving(Eq,Ord,Show)
15:29:32 <soduko> now i have a list like [ Start 1, Start 20 , Stop 30,Start 34] i need to find the first x if a Start x is in the list. and so for all the constructors. to use find, i need to write a function for each
15:30:38 <monochrom> Likely you should write functions "isStart", "isStop", "isError", in the obvious way. Then you can use them with find, filter, etc.
15:31:01 <soduko> i did that!!  i was hoping there would be an easier way.
15:31:09 <monochrom> I don't know of a shorter way.
15:32:00 <monochrom> If those three functions will be used only once, ever, and you don't want to name them, you could write like: find (\x -> case x of {Start _ -> True; _ -> False})
15:33:13 <soduko> actually that is almost the same effort.
15:33:30 <monochrom> As usual, by "I don't know of a shorter way" I just mean local tricks that shorten the code.
15:34:30 <monochrom> It is quite possible that by going back to "why do you want to do that", one may completely scratch your current algorithm and devise a shorter one. A global rewrite.
15:35:09 <EvilTerran> X and Y problem?
15:35:12 <roconnor> > isJust (Just ())
15:35:15 <lambdabot>  True
15:35:36 <roconnor> > isJust (do {Start _ <- x}))
15:35:36 <lambdabot> Unbalanced parentheses
15:35:39 <roconnor> > isJust (do {Start _ <- x})
15:35:39 <lambdabot>  Parse error at "})" (column 25)
15:35:53 <roconnor> > isJust (do {Start _ <- x; return ()})
15:35:53 <lambdabot>   Not in scope: `x'
15:35:57 <EvilTerran> soduko, head [x | Start x <- yourList] ?
15:36:32 <monochrom> That's nice. But it doesn't use Maybe.
15:36:34 <soduko> basically the original problem is that the C program supports really weird and liberal argument passing.
15:36:50 <EvilTerran> does he want maybe? okay, s/head/listToMaybe
15:36:58 <monochrom> But it's much cheaper to write a "myhead" that uses Maybe.
15:37:10 <EvilTerran> safeHead
15:37:20 <soduko> like makewff -f -f -f -f -cnf -seed 10 23 24. only the last of the style flags -f -kf or -cnf is used
15:37:30 <EvilTerran> (it uses a dental dam)
15:38:02 <soduko> and there must be 3 Integers . and an optional -seed Integer
15:38:37 <soduko> so i wrote a very crappy and unsatisfactory loop function that basically is a recursive version of the C for loop that parses args
15:39:34 <soduko> now i need to pass those args in some known order to the main logic. so what i ended up with is a lot of isThis isThat functions
15:40:27 <soduko> :t listToMaybe
15:40:28 <lambdabot> forall a. [a] -> Maybe a
15:40:45 <soduko> > listToMaybe [1,2,3]
15:40:46 <lambdabot>  Just 1
15:40:52 <soduko> > listToMaybe []
15:40:53 <lambdabot>  Nothing
15:42:53 <soduko> > listToMaybe [ x | Just x <- [ Nothing , Just 3, Nothing, Just 4] ]
15:42:54 <lambdabot>  Just 3
15:42:54 <znutar> is there a simple way in parsec to get the source position from within a parser?
15:43:07 <mrd> yes
15:43:11 <mrd> @hoogle getSourcePos
15:43:11 <lambdabot> No matches found
15:43:25 <mrd> well it's something like that. go see parsec docs.
15:45:04 <znutar> Ah, thanks.  I was looking in the sourcepos code, but it seems to be in parsecprim
15:47:06 <EvilTerran> ?src listToMaybe
15:47:06 <lambdabot> listToMaybe []        =  Nothing
15:47:06 <lambdabot> listToMaybe (a:_)     =  Just a
15:57:23 <sarehu> listToMaybe = unsafeCoerce  -- :-)
15:58:24 <ddarius> > msum [Nothing, Just 3, Nothing, Just 4]
15:58:26 <lambdabot>  Just 3
16:01:29 <soduko> sarehu why unsafe?
16:02:26 <dons> soduko: it doesn't do a safe type conversion
16:03:10 <dons> arkx:
16:03:12 <dons> sarah:
16:03:13 <idnar> listToMaybe is a weird name
16:03:15 <dons> sarehu:
16:03:16 <dons> Unsafe.Coerce> unsafeCoerce ([1,2,3] :: [Int]) :: Maybe Int
16:03:16 <dons> Just 1
16:03:24 <dons> *crikey*
16:03:40 <ddarius> Of course it works.
16:04:06 <dons> i don't think that's an "of course"
16:04:15 <dons> the tag bits still need to be the same
16:04:25 <ddarius> They both have two constructors.
16:04:44 <dons> right, it does depend on some pretty low level data representation details
16:04:51 <EvilTerran> <dons> soduko: it doesn't do a safe type conversion <- wait what?
16:04:58 <dons> it doesn't :)
16:05:06 <ddarius> unsafeCoercing Integer to Either Int () probably produces Left n for small enough n
16:05:14 <EvilTerran> listToMaybe?
16:05:19 <dons> unsafeCoerce
16:05:20 <ddarius> unsafeCoerce
16:05:24 <EvilTerran> ohhh, i see.
16:05:49 <dons> works in compiled code too, which is nice
16:06:14 <dons>   case (GHC.Base.: @ GHC.Base.Int Main.lvl Main.lvl4)
16:06:14 <dons>        `cast` (trans
16:06:14 <dons>                  (CoUnsafe [GHC.Base.Int] (Data.Maybe.Maybe GHC.Base.Int))
16:06:14 <dons>                  (Data.Maybe.Maybe GHC.Base.Int)
16:06:15 <dons>                :: [GHC.Base.Int] ~ Data.Maybe.Maybe GHC.Base.Int)
16:06:15 <dozer> @hoogle arrL
16:06:16 <lambdabot> No matches found
16:06:27 <ddarius> @index unsafeCoerce
16:06:28 <lambdabot> bzzt
16:06:32 <ddarius> @hoogle unsafeCoerce
16:06:33 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
16:06:49 <dons> its nice that the type coercion is in the type now
16:07:15 <dozer> @hoogle ListArrows
16:07:15 <lambdabot> No matches found
16:07:20 <Cin> what was its type before?
16:07:31 <ddarius> Oh, I forgot the unboxing.
16:11:38 <monochrom> Hahaha this is magical
16:11:59 <EvilTerran> ?
16:12:00 <soduko> swoooosh
16:12:09 <dons> unsafeCoerce lets you set up all these type equivalences in the core, fun fun
16:12:39 <dons> > listToMaybe "haskell"
16:12:40 <lambdabot>  Just 'h'
16:15:41 <soduko> what would msum do if there are multiple constructors tho?
16:15:54 <ddarius> soduko: ?
16:15:55 <EvilTerran> whatever it's defined to do
16:15:56 <byorgey> > msum [ Just 3, Just 4 ]
16:15:56 <lambdabot>  Just 3
16:16:17 <EvilTerran> > msum [Left 'a', Right 2, Left 'b', Right 3]
16:16:21 <lambdabot>   add an instance declaration for (Error Char)
16:16:21 <lambdabot>     In the expression: msum [L...
16:16:27 <EvilTerran> bah
16:16:28 <byorgey> in the particular case of Maybe, it takes the first 'Just' value
16:16:34 <soduko> like in  msum [Nothing, Just 3, Cons1 5, MyCons2 4]
16:16:40 <EvilTerran> > msum [Left "a", Right 2, Left "b", Right 3]
16:16:40 <lambdabot>  Right 2
16:16:52 <byorgey> soduko: well, that isn't well-typed
16:16:52 <EvilTerran> in the case of Either, it takes the first "Right" value
16:17:06 <byorgey> soduko: all elements of a list must have the same type.
16:17:06 <EvilTerran> > msum [[1,2,3], [4,5,6], [7,8,9]]
16:17:07 <lambdabot>  [1,2,3,4,5,6,7,8,9]
16:17:25 <soduko> so if i have my own data type do i now need my own monad too ?
16:17:31 <EvilTerran> in the case of [a], it's the same as concat; but note that [a] has two constructors; [] and (:)
16:17:39 <byorgey> soduko: if you want msum to work for it, yes
16:17:43 <byorgey> @type msum
16:17:44 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
16:17:58 <EvilTerran> soduko, Monoid may be more like what you want
16:18:09 <EvilTerran> or Applicative/Alternative, even
16:18:15 <byorgey> soduko: what are you trying to do?
16:18:31 <soduko> :) this is soon growing to become like that designpatterns hellow world java program
16:18:54 <soduko> byorgey translating the makewff.c from teh WalkSat C code to Haskell
16:19:01 * EvilTerran still finds that Error l constraint on Monad (Either l r) to be very annoying
16:19:43 <EvilTerran> excuse me, sometimes i just want to use it as a poor-man's Cont
16:20:02 <EvilTerran> keep to the Right while i want to keep recursing or whatever, jump out with Left when i'm done.
16:20:28 <byorgey> EvilTerran: I totally agree.  it's rather annoying indeed.
16:20:45 <EvilTerran> and not an Error in sight, semantically or typewise
16:20:52 <byorgey> damn fail method
16:20:58 <EvilTerran> grah!
16:21:01 <bos> http://reddit.com/info/67wv9/comments/
16:21:05 <byorgey> that's why, of course
16:21:16 <bos> hmm, lambdabot is tardy these days.
16:21:17 <EvilTerran> well, they should've made their own Error type if they wanted that
16:21:31 <bos> anyway, vote up, and defeat the bots!
16:21:33 <byorgey> MonadFail, perhaps?
16:21:34 <dons> soduko: you only need a monad instance if you want  to use the generic monadic operators on values of you type
16:21:50 <EvilTerran> newtype Either if you like, but i'd give the constructors better names, tbh
16:21:54 <byorgey> yessir mr. bos!
16:21:59 <dons> bos, i don't think reddit returns the title in a form we can grok now.
16:22:03 <bos> ah.
16:22:18 <dons> yay, applicatives.
16:22:21 <dons> they're taking over
16:22:35 <dons> now, where's our applicative instances for mtl?
16:22:52 <dons> hmm. actually, mtl needs a maintainer who cares about the little monads
16:23:19 <EvilTerran> would it be inadvisable to fix ListT at this point?
16:23:33 <bos> well, we need a proper hierarchy of functors and monads, then everything will fall out for us.
16:23:42 <bos> including, possibly, our teeth from old age.
16:23:51 <EvilTerran> either way, a non-broken Nondet/T in MTL would be nice
16:24:10 * soduko needs to get back to work .. will join later tonight as dynamix
16:24:53 <EvilTerran> (written in terms of prepend-lists ([a]->[a]) instead of lists or however it goes)
16:25:16 <wagle_home> hierarchies are so last century, man...  DAG's is where its at!
16:25:28 <EvilTerran> acyclic? you lack ambition, sir!
16:26:27 <bos> reddit is becoming not worth the effort, now that there are bots and pinheads to auto-downvote new stories instantaneously.
16:26:44 <dons> its weird. but they always seem to bubble back up
16:26:46 <dons> as real people vote
16:26:50 <glguy> dons: someone should write a blog post about overcoming do-notation
16:27:08 <dons> glguy: ah yes. but who in their right mind would want to do that?
16:27:13 <dons> i know: a video blog
16:27:34 <glguy> I could be one of those youtube kids, crying out to the world for someone to listen to them!
16:27:36 * wagle_home invents a >>= notation as syntactic sugar for do-notation
16:27:47 <glguy> >>= is too restrictive
16:28:04 <dons> glguy's find ';' not programmable enough
16:28:21 <byorgey> bos: nice article.  my only critique is that you didn't mention the possibility of doing  foo <$> x <*> y  instead of liftA2 foo x y
16:28:32 <byorgey> bos: since the former generalizes nicely to more than two arguments.
16:28:40 <glguy> URI?
16:28:48 <bos> byorgey: true.
16:28:48 <dons> http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
16:28:50 <lambdabot> Title: teideal glic deisbhalach  Blog Archive  The basics of applicative functors,  ..., http://tinyurl.com/2lrb68
16:29:04 <dons> strong *and* lax.
16:29:05 <bos> byorgey: you should mention that as a comment.
16:29:11 <glguy> I think the title got mangled :(
16:29:14 <byorgey> bos: but whatever, it's a great article.  I've been thinking of writing something very similar to it, so I'm glad you did now, so I can be lazy =)
16:29:21 <byorgey> bos: ok, I will later.
16:29:31 <bos> thanks. it only took about 30 minutes to bang out.
16:29:39 <dons> glguy: we need some kind of monad-lib with applicatives
16:29:39 <Cale> Hey, wasn't there a newer release of Morrow than the one from 2006?
16:29:42 <bos> and i needed to write a big hunk of that for the book.
16:29:52 <dons> the strong and lax book
16:29:57 <glguy> dons: you are living in the past
16:30:06 <glguy> dons: monadLib has solved your problems already
16:30:12 <dons> :)
16:30:15 <wli> What's Morrow?
16:30:25 <dons> shame about the name though
16:30:34 <resiak> bos: very nice!
16:30:38 <glguy> dons: ultraLaserLib?
16:30:44 * bos has a little demo web server that uses STM for persistent state management in less than 600 lines of code, lined up to drop into the book.
16:31:10 <glguy> real world web server?
16:31:13 <dons> oh, now that's interesting. dcoutts was looking for a nice stm-ish parallel server to talk to some sparc guys about
16:31:23 <resiak> bos: as ever, real world examples are illuminating :)
16:31:29 <dons> bos, didn't you work at sun, actually...?
16:31:33 <bos> yes.
16:31:41 <dons> mmm.
16:31:44 <bos> i used to work in the CPU design division, in fact.
16:31:59 * dons hunts around
16:32:30 * glguy comments on dons bright orange hunting vest
16:34:05 <sethk> this is elementary but I'm lazy and I know there is an easy way to do this.  I have a [String] and I need it as a single string with the members of the (original) array separated by spaces
16:34:44 <Cale> sethk: unwords
16:34:51 <lament> is there a list of suggestions of stuff to write for people who want to write stuff but have no ideas about what stuff to write?
16:34:52 <sethk> Cale, thanks.
16:35:00 <Cale> > unwords ["Hello","there","world!"]
16:35:04 <lambdabot>  "Hello there world!"
16:35:18 <glguy> ?hoogle [String] -> String
16:35:19 <lambdabot> Prelude.unlines :: [String] -> String
16:35:19 <lambdabot> Prelude.unwords :: [String] -> String
16:35:19 <lambdabot> Data.List.unlines :: [String] -> String
16:35:26 <gwern> '103. Purely applicative languages are poorly applicable.'
16:35:26 <sethk> Cale, thanks, I remembered there was a function but I forgot the name.
16:37:15 <dozer> @pl \a b -> (a + b) + 5
16:37:15 <lambdabot> flip flip 5 . ((+) .) . (+)
16:37:23 <Cale> lament: I don't know...
16:38:53 <Cale> lament: Hehe, there's my wish for a notebook interface :)
16:39:06 <waern> Cale: are you talking about leijen's Morrow?
16:39:10 <Cale> waern: yeah
16:39:49 <jorik808> bos: i was actually just writing a little server to get used to Haskell, do you have the code for yours online somewhere? i would love to take a peek
16:40:10 <waern> Cale: if there's one that is newer than 2006, please find it for me =)
16:40:38 <waern> I know he releases a new type system implementation, but it's got nothing to do with records iirc
16:40:50 <waern> s/releases/released
16:41:07 <Cale> waern: Yeah, I'm mostly just interested in his implementation of records.
16:41:14 <waern> I thought so
16:42:33 * Cale wonders if there are GHC hackers around who he could bug for insights on what parts of the GHC code would be most interesting to look at and various questions about Core :)
16:45:10 * olsner wonders if Cale is also going to ask for them, or just keep wondering indefinitely
16:45:11 <dons> on #ghc
16:46:24 <phobes> someone mind pasting the link to bos' article?
16:46:48 <Cale> olsner: hehe
16:47:14 <dons> http://reddit.com/info/67wv9/details
16:47:20 <phobes> thanks dons
16:48:05 * Cale upvotes
16:50:40 <gwern> bah! one does not simply upvote one's way into Mordor
16:50:41 <gnuvince_> Does Haskell have a function similar to Python's enumerate()?
16:50:55 <wli> What does enumerate() do?
16:51:09 <mrd> > [1..]
16:51:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:51:16 <gwern> I think he's talking about [1..10] stuff
16:51:16 <gnuvince_> wli: [a] -> [(Int, a)]
16:51:33 <Cale> > zip [0..] "hello"
16:51:34 <mrd> > zip [1..] "abcdef"
16:51:40 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f')]
16:51:40 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
16:51:42 <gnuvince_> It returns a list of tuples containing the index of the element and the element
16:51:49 <Cale> gnuvince_: zip [0..]
16:51:52 <wli> I guess it would be zip [0..]
16:51:54 <gnuvince_> Thanks.
16:52:34 <Cale> Combined with comprehensions, that's a useful way to select only elements with certain indices.
16:52:58 <Axioplase> > print "> [1..]"
16:52:59 <lambdabot>  <IO ()>
16:53:02 <Cale> > [x | (n,x) <- zip [0..] "hello, world!", even n]
16:53:02 <lambdabot>  "hlo ol!"
16:54:54 <olsner> "If it walks like a duck and quacks like a duck, it is probably in the Duck monad."
16:55:22 <pjd> Duck it => it walks like a duck and quacks like a duck
16:55:36 <dons> its an existential Duck?
16:55:42 <dons> there exists a Duck inside ?
16:56:27 <mrd> class Duck a where walk :: a -> Travel; quack :: a -> Noise
16:57:40 <pjd> walk :: duck -> IO duck
16:58:32 <olsner> unsafeWalkDuck :: a
16:59:10 <pjd> unsafePerformWaddle
17:00:10 <ac> what's next? lolducks?
17:00:38 <radetsky> does "class Monad m => MonadState s m | m -> s where" mean that MonadState takes either two parameters (one of which must be a monad) or a function from monads to some other type?
17:01:19 <MyCatVerbs> radetsky: it means MonadState is a type class on two parameters.
17:01:26 <olsner> radetsky: no, it means it takes two types, where m determines s (it's a "functional dependency" also called "fundep")
17:01:41 <MyCatVerbs> radetsky: the "| m -> s" means that the type of parameter s is determined by the type of parameter m.
17:02:04 <radetsky> ok
17:02:12 <olsner> "type of parameter"? but the parameter *is* the type :P
17:08:34 <MyCatVerbs> olsner: I said *on* two parameters. Deliberately.
17:08:48 <MyCatVerbs> olsner: would've been better to say "taking" though, sure.
17:09:20 <olsner> I meant "the type of parameter s is determined by the type of parameter m"
17:10:57 <MyCatVerbs> olsner: I'm confused.
17:10:58 <EvilTerran> the | is more like the | in guards than the | in data decls
17:11:37 <olsner> MyCatVerbs: well, since the parameters are already types, what does the operation of taking the type of a type mean?
17:11:47 <lament> EvilTerran: looks like a e e cummings poem
17:12:08 <ac> Cale: your hello world list comprehension is a little mind twisting
17:12:40 <Cale> ac: It's picking out the elements with even index in the string.
17:12:53 <ac> Cale: I see that, but I can't figure out how it's valid Haskell
17:13:00 <Cale> oh?
17:13:06 <ddarius> I haven't tested it, but I would not recommend hiding Parsec's many in preference for Applicative's.
17:13:13 <Cale> What's confusing regarding its validity?
17:13:19 <Cale> > [x | (n,x) <- zip [0..] "hello, world!", even n]
17:13:20 <lambdabot>  "hlo ol!"
17:13:31 <Cale> > zip [0..] "hello, world!"
17:13:32 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,','),(6,' '),(7,'w'),(8,'o'),(9,...
17:13:44 <EvilTerran> lament, well, yes. nothing
17:13:48 <Cale> The pattern (n,x) is pattern matched against each of those elements.
17:13:50 <EvilTerran>                        wrong   that,
17:13:53 <EvilTerran>                            with
17:13:57 <EvilTerran> is there?
17:14:03 <Cale> and then the condition that n is even is used to decide whether to keep the element
17:14:07 <EvilTerran> ;)
17:14:13 <Cale> and x is put into the resulting list if it is.
17:14:27 <Cale> EvilTerran: that's some awesome correction :)
17:14:28 <ac> I get everything but the ", even n"
17:14:43 <Cale> ac: You know that list comprehensions can include conditions, right?
17:14:48 <EvilTerran> Cale, correction, what?
17:14:49 <ac> Cale: no
17:14:56 <Cale> > [x^2 | x <- [1..10], even x]
17:14:56 <lambdabot>  [4,16,36,64,100]
17:15:04 <EvilTerran> > [x | (True,x) <- zip (iterate not True) "hello, world!"]
17:15:04 <lambdabot>  "hlo ol!"
17:15:14 <ac> Cale: ah, that's the trick I didn't know
17:15:17 <Cale> EvilTerran: Oh, heh, I lacked the larger context. :)
17:15:35 <lament> EvilTerran: no(no, )thing.
17:15:41 <Cale> EvilTerran: I thought you left out a word or two by mistake and corrected it on the following lines :)
17:15:50 <EvilTerran> hehe. yeah, that would be awesome
17:16:34 <Cale> Resolving conflicts 0/545
17:17:10 <EvilTerran> ...? is that a darcs-ism?
17:17:14 <Cale> yeah
17:17:51 <Cale> That's what I get for making the same patches by hand twice in two different branches of the lambdabot repo :)
17:18:12 <EvilTerran> engfeh
17:20:47 <MyCatVerbs> olsner: it's a mapping from two types to one typeclass.
17:21:35 <Cale> hmm, it might be easier just to start with a fresh LB repo and copy my plugins in :)
17:21:43 <MyCatVerbs> olsner: so just call it a kind instead of a type? No reason (except unwieldiness) why you can't have types of types, (types of)^n types for any n in [0..]
17:22:11 <catface> > other "hello world" where other (a:b:c) = a:other c; other _ = []
17:22:11 <lambdabot>  Parse error at "where" (column 21)
17:22:38 <olsner> I guess, I'm tired
17:22:39 <Cale> @version
17:22:39 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
17:22:39 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:22:55 <ricky_clarkson> Could you implement a ReverseIO in terms of IO, which executed your actions in reverse order?
17:23:10 <ricky_clarkson> I have no practical use for this, nor an impractical one, I'm just interested.
17:23:22 <Cale> ricky_clarkson: apart from the fact that it would make the results hard to obtain, yeah, sort of.
17:23:23 <sarehu> it wouldn't be a monad
17:23:34 <sarehu> since some actions depend on the results of previous actions
17:23:35 <Cale> You can make a reverse state monad.
17:23:50 <sarehu> you could implement    x << y = y >> x  , though.
17:23:56 <Cale> But you can't really make the real world go backwards in time.
17:24:02 <Cale> So it doesn't work out so nicely with IO
17:24:21 <ricky_clarkson> If all your actions didn't depend on each other, it could work though?
17:24:29 <Cale> sure
17:24:31 <ac> > fst $ foldl (\(v, e) p -> (v + p * 2^e, e-1)) (0,7) [1,0,0,0,0,1,0,0]
17:24:31 <lambdabot>  132
17:24:35 <ricky_clarkson> ..and then there'd be little point having them in the same do block/expression :)
17:24:52 <catface> be nice if you could create a program just by undeleting it though
17:24:54 <Cale> yeah, it wouldn't really be a monad anymore
17:25:09 <Cale> You'd have a sort of IO monoid :)
17:25:40 <ricky_clarkson> So are you saying that the order of evaluation is important in it being a monad?
17:25:42 <MyCatVerbs> (>>=) = (=<<) ?
17:25:58 <Cale> ricky_clarkson: Well, have you seen the state-backwards-in-time monad?
17:25:58 <dibblego> the monad laws are important
17:26:02 <vincenz> MyCatVerbs: flip
17:26:17 <ac> > (\d l -> fst $ foldl (\(v, e) p -> (v + p * 2^e, e-1)) (0,d-1) l) 8 [1,0,0,0,0,1,0,0]
17:26:17 <vincenz> @src (=<<)
17:26:17 <lambdabot> f =<< x = x >>= f
17:26:17 <lambdabot>  132
17:26:19 <ricky_clarkson> Cale: No, let me ponder it for a bit.
17:26:28 <MyCatVerbs> vincenz: (>>=) = flip (>>=) doesn't make it through the compiler it one piece. :)
17:26:38 <Cale> ricky_clarkson: Write out the bind for State, and "get it wrong" :)
17:26:38 <ricky_clarkson> Cale: I have this strange habit where I work out how I'd do something and only then check to see how it's done. :)
17:27:09 <MyCatVerbs> vincenz: hence the useless indirection.
17:27:19 <ac> > (\d l -> fst $ foldl (\(v, e) p -> (v + p * 2^e, e-1)) (0,d-1) l) 4 [4,0,1,0]
17:27:19 <lambdabot>  34
17:27:51 <ac> erhg, not quite what I want
17:28:37 <catface> > a where a = 3
17:28:37 <lambdabot>  Parse error at "where" (column 3)
17:28:50 <catface> is that not allowed?
17:29:06 <Cale> catface: nope, 'where' is part of declaration syntax
17:29:10 <Cale> (not expression syntax)
17:29:15 <catface> thx
17:29:23 <Cale> You can use let though
17:29:27 <Cale> > let a = 3 in a
17:29:28 <lambdabot>  3
17:29:35 <sarehu> > let where = 3 in where
17:29:35 <lambdabot>  Parse error at "where" (column 5)
17:29:38 <sarehu> good
17:29:39 <gwern> heh. 'Is List an acceptable list?'
17:29:41 <gwern> (someone's been reading too much reddit)
17:29:42 <Cale> (That's the main difference between let and where)
17:29:45 <gwern> > let a = 3 in a
17:29:45 <lambdabot>  3
17:29:53 <ac> I want a function that takes an 8, 4, or 2 element list of numbers and packs them in to a Word8 in big endian form
17:30:02 * gwern must be seriously lagging
17:30:27 <sarehu> ac: binary, base 4, hex?
17:32:08 <ac> > (\l -> let i = div 8 l in fst $ foldl (\(v, e) p -> (v + p * 2^e, e-i)) (0,7) l) 4 [3,0,1,0]
17:32:08 <lambdabot>   add an instance declaration for (Num ([t] -> a))
17:32:09 <lambdabot>     In the expression: 0
17:32:34 <ac> > (\l -> let i = div 8 (length l) in fst $ foldl (\(v, e) p -> (v + p * 2^e, e-i)) (0,7) l) [3,0,1,0]
17:32:34 <lambdabot>  392
17:40:12 <ehird`> ping
17:40:14 <ehird`> someone confirm i'm alive
17:40:39 <wagle_home> ehird`, welcome to hell
17:40:43 <ehird`> thanks.
17:40:43 <vincenz> @join #oasis
17:41:43 <Cale> > foldr f z [1,2,3]
17:41:46 <lambdabot>   Not in scope: `z'
17:41:49 <Cale> aww
17:42:05 <Cale> > foldr f z [1,2,3]
17:42:06 <lambdabot>   Not in scope: `z'
17:42:08 <mbot>  f 1 (f 2 (f 3 z))
17:42:18 <ehird`> haha, mbot.
17:42:25 <ehird`> > f
17:42:26 <lambdabot>   Not in scope: `f'
17:42:26 <Cale> We really need to get the new lambdabot in here.
17:42:26 <mbot>  Add a type signature
17:42:31 <ehird`> but seriously, that's pretty cool.
17:42:37 <sarehu> > let { aux i (x:y:xs) = aux (2*i) (i*x+y : aux i xs) ; aux _ [x] = toEnum x ; pack xs = aux (fromJust (lookup (length xs) [(8,2),(4,4),(2,16)])) xs } in pack [1,1,1,1,1,1,1,0] :: Word8
17:42:37 <ehird`> does it work for any free variable? :-P
17:42:37 <lambdabot>  Couldn't match expected type `Word8' against inferred type `[Int]'
17:42:38 <mbot>  Couldn't match expected type `Word8' against inferred type `[Int]'
17:42:42 <ehird`> it should!!
17:42:50 <ehird`> under a different name, of course.
17:42:53 <ehird`> @f>
17:42:54 <lambdabot>  There was an error in the type: (line 1, column 1):
17:42:54 <lambdabot>  unexpected "<"
17:42:54 <lambdabot>  expecting "forall" or a simple type term
17:42:55 <mbot>  There was an error in the type: (line 1, column 1):
17:42:55 <mbot>  unexpected "<"
17:42:55 <mbot>  expecting "forall" or a simple type term
17:42:55 <ehird`> or something
17:43:00 <wagle_home> > halts
17:43:00 <lambdabot>   Not in scope: `halts'
17:43:01 <mbot>   Not in scope: `halts'
17:43:06 <ehird`> that would give you a diagram thing.
17:44:03 <Cale> mbot: @part
17:44:03 <mbot> Plugin `system' failed with: Prelude.last: empty list
17:44:08 <Cale> mbot: @part #haskell
17:44:13 <sarehu> > let { aux i (x:y:xs) = aux (2*i) (i*x+y : aux i xs) ; aux _ xs = xs ; pack xs = head $ aux (fromJust (lookup (length xs) [(8,2),(4,4),(2,16)])) xs } in pack [1,1,1,1,1,1,1,0] :: Word8
17:44:14 <lambdabot>  38
17:44:37 <catface> let other (a:b:cs) = a : other cs; other _ = [] in other "hello world"
17:44:40 <catface> > let other (a:b:cs) = a : other cs; other _ = [] in other "hello world"
17:44:41 <lambdabot>  "hlowr"
17:45:41 <allbery_b> is that intentional?
17:48:18 <allbery_b> > let other (a:b:cs) = a : other cs; other (a:b) = b; other _ = [] in other "hello world"
17:48:19 <lambdabot>  "hlowr"
17:48:26 <allbery_b> oh right
17:48:35 <allbery_b> > let other (a:b:cs) = a : other cs; other a = a; other _ = [] in other "hello world"
17:48:35 <lambdabot>      Warning: Pattern match(es) are overlapped
17:48:36 <lambdabot>              In the definition...
17:48:45 <allbery_b> > let other (a:b:cs) = a : other cs; other a = a; other [] = [] in other "hello world"
17:48:45 <lambdabot>      Warning: Pattern match(es) are overlapped
17:48:45 <lambdabot>              In the definition...
17:48:57 <allbery_b> bleh, need sleep
17:48:59 <catface> didn't notice the missing d
17:51:20 <ac> sarehu: 38 is definitely the wrong number. Should be 254
17:52:40 <sarehu> yah
17:53:28 <catface> > zipWith (!!) (repeat "hello world!") [0,2..10]
17:53:29 <lambdabot>  "hlowrd"
17:58:13 <catface> > map head $ iterate (drop 2) "hello world"
17:58:13 <lambdabot>  Exception: Prelude.head: empty list
17:58:36 <ac> > (\l -> let i = div 8 (length l) in fst $ foldl (\(v, e) p -> (v + p * 2^e, e-i)) (0,7) l) [1,1,1,1,1,1,1,0]
17:58:36 <lambdabot>  254
17:58:45 <ac> that's pretty darn close...
17:59:26 <sarehu> that's the right answer
17:59:28 <sarehu> I'd go with
17:59:38 <ac> but it's not the right function
17:59:50 <ac> doesn't work with 4, 2 length lists
17:59:51 <sarehu> how so?  254
18:01:12 <sarehu> > let pack xs = foldl (\x y -> (2^(div 8 (length xs))) * x + y) 0 xs in (pack [1,1,1,1,1,1,1,0], pack [1,3,2,0], pack [15,10])
18:01:13 <lambdabot>  (254,120,250)
18:01:22 <ac> [3,0,0,0] should be 192
18:02:48 <sarehu> ayess (n=chatzill@ppp-124-121-166-139.revip2.asianet.co.th) has quit:
18:02:48 <sarehu>     Remote closed the connection [21:02-02/06]
18:02:48 <sarehu> ERC> ayess (n=chatzill@ppp-124-121-166-139.revip2.asianet.co.th) has quit:
18:02:48 <sarehu>     Remote closed the connection [21:02-02/06]
18:02:51 <sarehu> ERC> > let pack xs = foldl ((+) . (2 ^ div 8 (length xs) *)) 0 xs in pack [3,0,0,0]
18:02:57 <sarehu> er, sorry.
18:03:00 <sarehu> what
18:03:33 <vincenz> @join #arc
18:03:53 <sarehu> let pack xs = foldl ((+) . (2 ^ div 8 (length xs) *)) 0 xs in pack [3,0,0,0]
18:03:53 <ac> Is there a function of "Int -> [Bool]" or "Int -> [Int" that turns a number in to a list of bits?
18:04:00 <sarehu> > let pack xs = foldl ((+) . (2 ^ div 8 (length xs) *)) 0 xs in pack [3,0,0,0]
18:04:00 <lambdabot>  192
18:04:33 <ac>  > let pack xs = foldl ((+) . (2 ^ div 8 (length xs) *)) 0 xs in pack [1,1,1,1,1,1,1,0]
18:04:48 <ac> > let pack xs = foldl ((+) . (2 ^ div 8 (length xs) *)) 0 xs in pack [1,1,1,1,1,1,1,0]
18:04:48 <lambdabot>  254
18:05:13 <ac> man I suck at math
18:05:31 <ac> and programming, for that matter
18:06:42 <ac> how does that work? "length xs" should be constant
18:07:56 <sarehu> 'length xs' is the length of xs
18:10:21 <lekro> ac: it only works because length xs is 8 in your case, so it's foldl ((+) . (2 *)) 0 [1,1,1,1,1,1,1,0]
18:10:21 <lambdabot> lekro: You have 1 new message. '/msg lambdabot @messages' to read it.
18:10:58 <fons> hi all
18:11:13 <sarehu> ac: for _slow_ conversion of a number to a list of bits, there's
18:11:37 <sarehu> > replicateM 8 [0,1] !! 254
18:11:37 <lambdabot>  [1,1,1,1,1,1,1,0]
18:11:55 <pjd> sarehu: ooh, nice
18:12:10 <ac> interesting
18:12:22 <ac> that _would_ be very slow
18:14:37 <bos> byorgey: thanks for adding the comment
18:15:13 <sarehu> > reverse . unfoldr (\x -> guard (x>0) >> return (mod x 2, div x 2)) $  254
18:15:13 <lambdabot>  [1,1,1,1,1,1,1,0]
18:15:33 <Axioplase> :t replicateM
18:15:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:16:01 <sarehu> > replicateM 3 "01"
18:16:02 <lambdabot>  ["000","001","010","011","100","101","110","111"]
18:16:19 <Axioplase> Oh, nice indeed.
18:16:43 <ac> map even $ iterate (div 2) 254
18:16:46 <ac> > map even $ iterate (div 2) 254
18:16:46 <lambdabot>  Exception: divide by zero
18:17:05 <ac> > map even $ take 8 $ iterate (div 2) 254
18:17:06 <lambdabot>  Exception: divide by zero
18:17:12 <ac> > map even $ take 7 $ iterate (div 2) 254
18:17:13 <lambdabot>  Exception: divide by zero
18:17:15 <ac> arhg!
18:17:57 <ac> > map even $ take 7 $ iterate (flip div 2) 254
18:17:57 <lambdabot>  [True,False,False,False,False,False,False]
18:20:14 <ac> > reverse $ map (not.even) $ take 7 $ iterate (flip div 2) 192
18:20:15 <lambdabot>  [True,False,False,False,False,False,False]
18:21:43 <sarehu> > odd 3
18:21:44 <lambdabot>  True
18:21:48 <sarehu> > (not . even) 3
18:21:48 <lambdabot>  True
18:24:10 <sarehu> > map (1 .&.) . take 8 . iterate (`div` 2) $ 192
18:24:11 <lambdabot>  [0,0,0,0,0,0,1,1]
18:24:34 <ac> sarehu: that's what I was trying to do
18:24:48 <ac> sarehu: see what I mean?
18:25:00 <sarehu> you took 7 instead of 8
18:26:19 <sarehu> > reverse . map (intToDigit . (1 .&.)) . take 8 . iterate (`div` 2) $ 192
18:26:19 <lambdabot>  "11000000"
18:26:42 <catface> .&. ?
18:26:47 <sarehu> bitwise and
18:27:03 <sarehu> imported from Data.Bits
18:27:30 <catface> thx
18:31:18 <gwern> I have a question. do literate haskell files always end with .lhs?
18:32:49 <sarehu> sarehu$ mv *.lhs *.blah
18:32:52 <sarehu> no.
18:33:38 <ac> sarehu: rename 's/lhs$/blah/' *.lhs
18:33:54 <sarehu> there's only one .lhs file :P
18:34:05 <ac> oh.
18:34:07 <gwern> then how do you know whether a file is literate haskell?
18:34:13 <sarehu> </backtracks>
18:34:35 <ac> gwern: a descerning eye?
18:34:46 <ac> *discerning
18:34:55 <sarehu> gwern: The answer for all intents and purposes is "yes".  Unless somebody has a counterexample.
18:35:39 <ac> gwern: ghc knows only by the extension of course
18:35:56 <gwern> alright. I was just wondering what Haskell files a .[l]hs pattern might miss (excluding preprocessed and program-specific endings, like .x for alex)
18:36:27 <sarehu> \.l?hs should be sufficient
18:42:53 <gwern> sarehu: this is for sh, I think, so I guess it'd be .*hs?
18:43:51 <sarehu> I was just being stupid.  I think .[l]hs is correct.
18:43:56 <allbery_b> .{,l}hs
18:44:18 <gwern> sarehu: [l] turns out not to work, as it will match xmonad.lhs, eg, but not xmonad.hs
18:44:26 <gwern> at least in dash
18:44:26 <allbery_b> .[l]hs is the same as .lhs; [] matches a character
18:44:33 <sarehu> oh, it's a character class?  ok.
18:44:40 <allbery_b> simplified a bit, but yes
18:45:11 <allbery_b> (and most shells use ! instead of ^ to invert the meaning)
18:45:15 <gwern> allbery_b: aren't braces a bashism?
18:45:33 * gwern is aiming for sh
18:45:40 <allbery_b> anything better than Bourne shell, I think
18:45:59 <allbery_b> (i.e. works in ksh and IIRC also in POSIX sh)
18:46:32 <gwern> allbery_b: I just tested it with dash, which is pretty well posix sh
18:46:32 <gwern> doesn't seem to work
18:46:45 <gwern> gwern@localhost:1002~/.xmonad>dash -c "ls xmonad.{,l}hs"                                                                            [ 9:46PM]
18:46:46 <gwern>  ls: cannot access xmonad.{,l}hs: No such file or directory
18:47:26 * allbery_b checking the standard now
18:47:39 <allbery_b> POSIX sh is largely, but not completely, Korn shell
18:49:14 <allbery_b> ah.  {} are "designated as possible control operators in a future issue", meaning they're considering adding brace expansion to an updated version of the shell
18:51:01 <allbery_b> anyway, absent brace expansion I don't think you can match both .hs and .lhs by a single glob
18:51:33 <allbery_b> (nope, POSIX sh also doesn't do ksh-style @() globs)
18:53:26 <ac> It would be kind of cool (but not worth it effort wise) for GHC to have Word4, Word2, and Word1 types :)
18:55:07 <ac> and Word128 for that matter
18:57:26 <allbery_b> pity, @(xmonad.lhs,xmonad.hs) would work if be rather long
18:58:24 <allbery_b> sorry, +() not @()
19:01:39 <ac> how does one do math in bash?
19:02:06 <pjd> ghci -e '5+5'
19:02:11 <wagle_home> expr command or $((...)) (i think)
19:02:15 <Nafai> ac: http://tldp.org/LDP/abs/html/arithexp.html
19:02:22 <monochrom> what pjd says
19:02:45 <allbery_b> $(( )) is the proper bash way
19:03:03 <wagle_home> ghci is pretty heavy weight
19:03:22 <monochrom> But it's more on-topic in #haskell
19:03:27 <wagle_home> true
19:03:30 <ac> personally I like "$(expr ...)". More consistent
19:05:09 <catface> i want to add stuff to haskell and use that as a shell
19:05:56 <allbery_b> talk to gwern :)
19:07:08 * wagle_home envisions a cyclic graph of unix processes setup like a dataflow machine
19:09:23 <ac> it would be cool to run pipes on lists of tupples of strings, or even lists of arbitrary types
19:10:39 <sw17ch> > fromInteger 5 :: Double
19:10:42 <lambdabot>  5.0
19:10:48 <sw17ch> how does that work?
19:10:57 <wagle_home> :t 5
19:11:04 <lambdabot> forall t. (Num t) => t
19:11:11 <BMeph> Very well. :)
19:11:12 <sw17ch> i mean, the underlying method, how is it done?
19:11:16 <sw17ch> :)
19:11:35 <sarehu> it figures the type is Double and calls the appropriate version of fromInteger
19:11:36 <wagle_home> :t fromInteger
19:11:36 <lambdabot> forall a. (Num a) => Integer -> a
19:11:37 <sw17ch> is there some magic land where haskell does... what's the word... coerce the type?
19:11:48 <sw17ch> but is fromInteger then defined by the language?
19:12:05 <sw17ch> or could we write fromInteger as haskell
19:12:11 <wagle_home> i've seen the actual coercions in the libs somewhere
19:12:36 <wagle_home> it has primitives to do the coercion
19:12:41 <sw17ch> @src fromInteger
19:12:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:13:04 <sw17ch> alright, so this is not something we could write in just haskell then
19:13:15 <sw17ch> i'm looking for the dark chamber where an Int is allowed to become a Double
19:14:05 <allbery_b> :t fromIntegral
19:14:06 <lambdabot> forall a b. (Num b, Integral a) => a -> b
19:14:32 <allbery_b> but no, Haskell will never auto-coerce
19:14:49 <sw17ch> that's good, since that's one of the main reasons i like it...
19:14:54 <allbery_b> that's one of the points of strong typing
19:15:08 <sw17ch> i guess .. hmm... the question is, can fromInteger be written in *just haskell*
19:15:30 <sw17ch> could we replace it with our own version that doesn't rely on from*?
19:15:53 <sw17ch> :t 5 + 5.0
19:15:53 <lambdabot> forall t. (Fractional t) => t
19:16:04 <sw17ch> :t (5 :: Int) + (5.0 :: Double)
19:16:04 <lambdabot>     Couldn't match expected type `Int' against inferred type `Double'
19:16:05 <lambdabot>     In the second argument of `(+)', namely `(5.0 :: Double)'
19:16:26 <sarehu> fromInteger (S# i#)    = case (int2Double# i#) of { d# -> D# d# }
19:16:33 <sarehu> fromInteger (J# s# d#) = encodeDouble# s# d# 0
19:16:33 <sarehu>  
19:16:58 <sw17ch> woa... that's a whole now box of worms i've never seen
19:17:56 <jcreigh> sw17ch: it's deep magic. You don't need to understand GHC's inner workings to understand Haskell's type system.
19:18:27 <sw17ch> jcreigh: i'm well aware, i was just wondering about the deep magic. can mortals understand, or am I better off leveling up a bit first... :P
19:19:10 <sarehu> basically,   int2Double# :: Int# -> Double#   is a magic function that works, and there's nothing underneath.
19:19:28 <allbery_b> IIRC, S# is a machine word (same as Int), J# is a GMP integer
19:20:07 * BMeph nods encouragingly at allbery_b
19:20:12 <sw17ch> so underneath int2Double is something that's not quite Haskell any more?
19:20:15 <sarehu> basically,    data Integer = S# Int# | J# Int# ByteArray#
19:20:39 <sarehu> it's   int2Double#, and exactly.  In fact it's a different kind of function entirely
19:20:42 <sw17ch> ah, i see now
19:20:44 <allbery_b> it's a compiler internal function
19:21:53 <allbery_b> (I should say "builtin", I guess)
19:21:58 <sw17ch> well, cool. i figured that was probably the case because i couldn't think of any reasonable way to convert those two without using infinite lookup tables
19:22:04 <sarehu> well, int2Double# is the same 'kind' of function.  But Int# is a different 'kind' of data type.
19:22:11 <sw17ch> :t int2Double#
19:22:13 <lambdabot> Not in scope: `int2Double#'
19:22:22 <sw17ch> so we can't see it. that's probably good
19:22:56 <sarehu> it's in GHC.Prim, or GHC.Exts
19:23:00 <allbery_b> not without (a) turning on # and (b) importing some special internals
19:23:03 <wagle_home> :t D#
19:23:04 <lambdabot> Not in scope: data constructor `D#'
19:24:34 <sw17ch> the things Haskell magically does always has me asking the "how" question, i've never had that with any other language but prolog ... and that just scared me away
19:25:14 <Cale> sw17ch: Something in particular? Most of the magic comes from very simple principles.
19:25:58 <sw17ch> Cale: i'm sure the principles are all quite simple, and i can usually see the idea behind the construct... but the parts that mess with my head are things that i know would take me far to long to do in a different language...
19:26:02 <Cale> Numeric conversions?
19:26:05 <sw17ch> list comprehensions are a big one
19:26:17 <sw17ch> Numeric conversions was just scary because i thought it was breaking rules
19:26:18 <Cale> Oh, list comprehensions get translated into concatMap
19:26:20 <sw17ch> which it still seems like it is
19:26:36 <Cale> hmm, could you give an example where it looks like it is?
19:26:50 <Cale> I'd be happy to explain :)
19:26:58 <sw17ch> well, the idea i keep getting is that "things never *EVER* change type"
19:27:06 <sw17ch> but i can use fromInteger and fromDouble... and so on
19:27:14 <sw17ch> so somewhere, something is changing type
19:27:22 <sarehu> :t encodeFloat
19:27:22 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
19:27:32 <sarehu> > encodeFloat 23 3
19:27:33 <lambdabot>  184.0
19:27:37 <sw17ch> i know the language would be severely hindered without those, but it was one of the first things i wondered
19:27:41 <SamB> eh? nothing is changing type, you are just converting things of one type to another... it's a bit different
19:27:46 <Cale> Well, it never applies coercions implicitly, except that numeric literals are automatically wrapped with coercions that make them polymorphic.
19:27:53 <SamB> it's kind of like paint-by-number...
19:27:58 <Cale> :t 5
19:27:58 <lambdabot> forall t. (Num t) => t
19:28:07 <Cale> 5 here is really a *function*
19:28:08 <sw17ch> the way i think about it is a very large lookup table
19:28:28 <sw17ch> fromDouble 5.0 :: Int
19:28:31 <sw17ch> > fromDouble 5.0 :: Int
19:28:32 <lambdabot>   Not in scope: `fromDouble'
19:28:40 <Cale> > round 5.0 :: Int
19:28:41 <lambdabot>  5
19:28:41 <sw17ch> > fromFloat 5.0 :: Int
19:28:42 <lambdabot>   Not in scope: `fromFloat'
19:28:52 <sw17ch> ah, that'd make sense...
19:29:17 <Cale> 5 :: (Num a) => a, is going to get a small handful of functionality in the form of a dictionary for the typeclass Num
19:29:41 <sarehu> > (floor &&& ceil &&& round &&& truncate) (-5.3)
19:29:42 <lambdabot>   Not in scope: `ceil'
19:29:47 <Cale> When it gets this dictionary, it will apply the supplied fromInteger :: Integer -> a function with the actual Integer 5.
19:29:50 <sarehu> > (floor &&& ceiling &&& round &&& truncate) (-5.3)
19:29:51 <lambdabot>  (-6,(-5,(-5,-5)))
19:30:12 <Cale> Does that make sense?
19:30:15 <sw17ch> yes
19:30:51 <sw17ch> i think the part that was finally cleared up for me by sarehu and allbery_b was that the compiler is responsible for the actual conversion of the literal 5
19:31:08 <sw17ch> and we can't really write the primitive that converts it in haskell
19:31:12 <sw17ch> "converts"
19:31:16 <sarehu> you _could_
19:31:26 <Cale> It just wouldn't be automatic.
19:31:30 <allbery_b> the same is true in C; you just don't see the function call that the cast turns into
19:31:32 <sarehu> you could implement all of the numeric types in Haskell
19:31:36 <SamB> eh?
19:31:41 <Cale> The compiler turns the literal 5 into  fromInteger (5 :: Integer)
19:31:43 <wagle_home> you can turn ints to bits and bits to ints
19:31:55 <SamB> hmm. I suppose...
19:32:11 <sw17ch> wagle_home, oh that's right... the Bits module?
19:32:30 <allbery_b> you could implement it all in Haskell, it'd just be slower than using native methods (which must be built into the compiler)
19:32:44 <SamB> of course, the compiler MUST implement Integer
19:32:46 <wagle_home> havent actually used it myself, actually, but you can write your own Int->[Bool]
19:33:02 <wagle_home> SamB, why?
19:33:15 * wagle_home uses the church numerals
19:33:30 <SamB> how else can it know what to pass to fromInteger?
19:33:35 <allbery_b> I could imagine an infinite precision integer module written in pure Haskell.  it'd just be really slow compared to heavily optimized gmp
19:34:02 <sarehu> > map (fromEnum . odd) . take 8 . iterate (`div` 2) $ 123
19:34:03 <lambdabot>  [1,1,0,1,1,1,1,0]
19:34:06 <SamB> allbery_b: imagine?
19:34:09 <Cale> Well, you don't have to *imagine* it.
19:34:15 <Cale> Someone's written one.
19:34:21 <SamB> allbery_b: clearly, you never noticed that it is already there...
19:34:35 <allbery_b> then I don't understand your "compiler MUST implement Integer"
19:34:42 <dons> http://reddit.com/info/67xel/details interesting. "What is Erlang-Style Concurrency?"
19:34:47 <allbery_b> beyond the obvious that it's a distinct type
19:35:08 <SamB> well, okay, it must know how Integer is implemented, whatever...
19:35:12 <sw17ch> do other people's questions bring about debates like this? i feel like every time i speak up in here this happens
19:35:27 <dons> sw17ch: maybe you ask funny questions? :)
19:35:54 <zooko> dons: did you look at my hacryptopp code?  I'm not sure if it is right.
19:36:02 <dons> not yet, just back from work
19:36:03 <zooko> I should add unit tests, but I'm unfamiliar with Haskell and with unit test tools for Haskell.
19:36:09 <catface> whats the easiest way to use a regex? i tried "a" =~ "a"
19:36:34 <Cale> http://isaac.cedarswampstudios.org/2007/HIntegerByInt/
19:36:35 <lambdabot> Title: Index of /2007/HIntegerByInt
19:36:40 <sw17ch> dons: i try to ask intelligent questions... perhaps i miss my mark :)
19:36:50 <zooko> I changed a couple of tiny things from the OpenSSL interface, for example I used size_t and CSize instead of long and CULong or whatever.
19:36:54 <Cale> sw17ch: nah, these are good questions :)
19:37:04 * SamB could be misremembering something about Bits...
19:37:12 <allbery_b> catface:  see the Text.Regex.* modules
19:37:38 <SamB> sw17ch: perhaps intelligent questions tend to spark debate?
19:37:46 <dons> zooko: ok good
19:38:04 <dons> catface: i like using the pcre-light lib, but the =~ interface is supported by regex-posix or regex-pcre
19:40:17 <catface> i just don't understand how i'm supposed to call =~
19:40:39 <catface> i thought it would take two strings or something
19:46:50 <catface> oh you have to give it the return type
19:59:18 <ac> cool. I just realized a method of a type class can use the parameter of the class as the RETURN value
19:59:36 <ac> so now I can write fromX style classes
19:59:57 <ac> class FromString a where fromString :: String -> a
20:00:06 <mrd> watch out for ambiguity
20:00:28 <ac> instance FromString Bool where fromString = (== "True")
20:00:36 <Riastradh> (There already is such a class, by the way: Read.)
20:00:42 <ddarius> ac: There are no restrictions on where the type variable can occur.
20:00:43 <ac> I know
20:00:56 <ac> Riastradh: right, it just didn't hit me how to write it until now
20:02:45 <ac> @src Bool read
20:02:45 <lambdabot> Source not found. Just try something else.
20:02:54 <dons> ac, yeah, its super powerful.
20:03:12 <dons> different behaviour depending on how the result is used
20:03:29 <ac> sort of like context in perl :-P
20:03:54 <ac> Perl has a two-type type
20:03:56 <dons> right. that's like a simple version
20:04:00 <ac> inference: list and scalar
20:04:16 <dons> [a] or a, and they dispatch based on the return type
20:04:55 * johnnowak curses hsplugins for not building
20:05:04 <ac> (accidentally hit enter there)
20:05:11 <dons> what combination of compiler/lib, johnnowak (hi, btw)
20:05:32 <johnnowak> dons: 6.8.1/0.9.10
20:05:48 <dons> ah, so that won't work. you need the darcs version, with 6.8
20:05:51 <zookosleep> Good night.
20:06:10 <dons> night zooko
20:06:17 <dons> johnnowak: darcs get http://code.haskell.org/~dons/code/hs-plugins/
20:06:18 <lambdabot> Title: Index of /~dons/code/hs-plugins
20:06:20 <johnnowak> i'm not sure i've ever built something with haskell yet where i didn't need the darcs version
20:06:22 <dons> should build with 6.8.x
20:06:28 <johnnowak> thanks
20:06:33 <dons> johnnowak: almost all tihngs on hackage should be fine.
20:06:39 <dons> but hs-plugins hasn't been updated in 2 years or so
20:07:04 <dons> if you find you use a lot of stuff from hackage (as I do), cabal-install is a good program to build.
20:07:12 <dons> then it just grabs and builds all dependencies in one go.
20:07:23 <dons> what do you need hs-plugins for, btw?
20:07:23 <BMeph> Is there a simple way to re-export what's in the Prelude, that doesn't overlap other modules?
20:07:52 <johnnowak> dons: lambdabot
20:08:24 <dons> ok. and you're using lambdabot from code.haskell.org/ as well?
20:08:39 <johnnowak> from http://www.cse.unsw.edu.au/~dons/lambdabot.html ...
20:08:40 <lambdabot> Title: lambdabot
20:08:41 <dons> note that neither hs-plugins, nor lambdabot, are terribly easy to build. they're quite poorly maintained
20:08:56 <dons> http://code.haskell.org/lambdabot/
20:08:56 <lambdabot> Title: Index of /lambdabot
20:09:07 <johnnowak> eh, i won't bother then
20:09:08 <dons> Cale: has reported getting that combination to build with 6.8
20:09:11 <johnnowak> thanks anyway
20:09:24 <dons> much easier to just use it in channel :)
20:09:29 <Cale> hmm... it shouldn't be that hard now.
20:09:40 <Cale> Just make sure you have the right versions of things.
20:09:41 <dons> right. should be relatively straight forward using both darcs versions
20:09:45 <Cale> right.
20:09:54 <Cale> @version
20:09:54 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
20:09:54 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:10:10 <Cale> Any luck getting 6.8 on code.h.o?
20:10:18 <johnnowak> would be nice if that page were updated to indicate you should use the darcs version, etc
20:10:27 <johnnowak> so i'd not be wasting my time
20:12:57 <dons> johnnowak: yeah. i've moved to the US, so haven't updated that site for a couple of months
20:13:04 <dons> i hope to move the whole lot and have it up to date soon.
20:13:33 <dons> if you're looking for stable, easy to build code, go to hackage.haskell.org. you can see what's buildable, what it depends on, and other wonders of central hosting
20:14:49 <dolio> Hackage doesn't have haddock 2.0 yet, right?
20:15:00 <dons> it does, yes.
20:15:07 <dolio> Oh...
20:15:08 <Cin> could `fmap' for the Functor instances which are also instances of Monad be defined as `liftM'?
20:15:17 <dons> yep
20:15:20 <Cin> yay
20:15:53 <dolio> dons: Huh, how recently?
20:16:00 <dons> last week, i think
20:16:06 <bd_> The only reason fmap isn't automatically defined is because you can't define instance Monad m => Functor m where .... in haskell without extensions
20:16:10 <dons> and there's a new "Built on: ghc-6.8" field
20:16:15 <dons> to confirm if it is buildable or not
20:16:23 <Cin> bd_: ah, yeah
20:16:33 <dolio> dons: Hmm... Does it retry failed builds periodically, or is that only shortly after you upload a package?
20:16:39 <Cin> bd_: would that read "m is an instance of Monad _and_ Functor?"
20:16:48 <dons> i don't think it retries, unless you upload a new version
20:16:58 <dolio> Ah. That'd explain it, then.
20:17:01 <bd_> Cin: That says all instances of Monad are also instances of Functor
20:17:20 <bd_> however it again requires GHC extensions
20:17:25 <johnnowak> dons: thanks, will do that from now on
20:18:01 <Cin> bd_: so would you use that in declaring the Monad class?
20:18:42 <bd_> Cin: No, that's seperate from Monad... if you activate the proper extensions it can be sort of tacked on after the fact.
20:24:04 <rieux> if you wanted to implement a preprocessor for some syntactic sugar, what would you do?  is there a parser lying around that could be reasonably repurposed in that way?
20:25:04 <rieux> (i look at using the old arrowp preprocessor, but it relies on libraries that don't seem to exist anymore, and it doesn't support any new stuff from the last 8 years or so.)
20:25:44 * SamB wishes his data from chemlab were more cooperative...
20:26:23 <dons> rieux: perhaps use Language.Haskell to do the parsing?
20:27:23 <Cin> ooo
20:27:37 <rieux> dons: yeah, i was looking there, but it's not clear to me how to extend it.
20:28:17 <rieux> unless you mean starting with the Language.Haskell source, rather than calling into the standard version.... that might work.
20:28:21 <radetsky> I had been operating under the assumption that State was a way to have mutable variables, but now I'm thinking that it's for stateful computations, and that Reader/Writer are for mutable variables. Is this right?
20:28:41 <SamB> radetsky: wrong again!
20:28:51 <SamB> ST has mutable variables, though
20:29:09 <rieux> I'll have to check if it supports the fancy bits i'm using (fundeps, associated types, rank-n types)
20:29:12 <bd_> Reader/Writer are different :) Reader's more for semi-constants - values which won't change much in a computation, but you might want to temporarily reset them in a given context
20:29:14 <Cin> what is he wrong about?
20:29:27 <bd_> writer's more like if you're emitting a stream (more precisely, a monoid) of data
20:30:01 <bd_> and State... well, it depends on what you're wanting to use mutable variables for :) Mutable variables should be thought of as a means to an end, not the end itself
20:30:20 <bd_> If you really, really need mutable variables, there's ST, but that's a horrible hack :)
20:30:22 <radetsky> SamB: I thought ST was for threads, and might happen to have mutable variables, but that that's not what it was for
20:30:54 <rieux> State is fine if you want ONE mutable variable :)
20:30:56 <dons> http://www.abc.net.au/science/news/scitech/SciTechRepublish_898675.htm "Creative genius and crime express themselves early in men but both are turned off almost like a tap if a man gets married"
20:30:56 <bd_> ST isn't about 'threads' as you might thing of them in other languages
20:30:58 <lambdabot> Title: Sci Tech News - from ABC News Online 10/07/2003 Marriage may tame genius, http://tinyurl.com/gou3
20:32:03 <radetsky> rieux: but with one mutable variable, you get any number of mutable variables you want
20:32:12 <radetsky> right?
20:32:27 <rieux> radetsky: sure, if you want to keep track of that 17-tuple yourself.
20:32:53 <radetsky> rieux: record syntax ftw
20:32:56 <rieux> a record wouldn't be that inconvenient.
20:33:22 <rieux> you could also use StateT and name your variables get, lift get, lift (lift get), and lift (lift (lift get))
20:33:47 <radetsky> yeah, what could possibly go wrong?
20:34:17 <bd_> Actually you can just use StateT and get/set, as long as the types are different, I think
20:34:49 <bd_> or - the correct solution - newtype your own monad out of a StateT, then make higher-level accessors
20:36:21 <rieux> i don't think MonadState will dig down to match the type of your get/set, sadly.  It's going to use the first one it sees.  but you could newtype it, sure.
20:37:10 <bd_> get/set/modify gets inconvenient anyway, it's always nice to have higher-level accessors which better reflect whatever it is you're doing with the state
20:37:24 <rieux> meh.  Language.Haskell doesn't have fundeps or forall.  something tells me i'm going to be looking in ghc real soon now.
20:39:15 <dons> if you want to preprocess full haskell, you'll need the ghc-api
20:40:26 <rieux> dons: thanks, this sounds promising.  going to look...
20:46:04 <rieux> dons: is this the right place to start?: http://haskell.org/haskellwiki/GHC/As_a_library
20:48:51 <dons> i think that's a good place.
20:51:41 <rieux> thanks.  yeah, there's a lot in there.
21:03:09 <bos> has anyone looked at tarmo uustalu's presentations on category theory for FP? very nice.
21:06:34 <wagle_home> give us a U!  U!  give us an R!  RI  give us an L!  L!  whats that spell?
21:07:10 <wagle_home> @google tarmo uustalu's presentations on category theory for FP
21:07:11 <lambdabot> No Result Found.
21:08:21 <allbery_b> @go tarmo uustalu category theory
21:08:22 <lambdabot> No Result Found.
21:08:25 <allbery_b> hm
21:08:55 <wagle_home> the real google gets one hit for my search, but its not working
21:11:52 <wagle_home> http://cs.ioc.ee/~tarmo/papers/   but nothing obvious
21:11:53 <lambdabot> Title: Tarmo Uustalu's recent papers and reports
21:15:50 <ac> I have two definitions of a function that by themselves both compile fine (and they both have the exact same type), but together I get the error "Equations for `packWord16s' have different numbers of arguments"
21:16:21 <bd_> ac: All of your function definitions have to have the same number of arguments to the left of the =
21:16:36 <bd_> ie, you can't have foo Something x = ... and foo SomethingElse = \x -> ...
21:16:42 <ac> blarg
21:17:50 <ac> every time I do a partial application of shiftR I have to remember to flip it. I think its argument order should be reversed
21:18:23 <nelhage> :t shiftR
21:18:25 <lambdabot> forall a. (Bits a) => a -> Int -> a
21:18:53 <bd_> (x `shiftR`)
21:19:04 <bd_> or (`shiftR` y)
21:20:07 <ac> bd_: thanks, I'm not good at writing idiomatic Haskell yet
21:20:29 <ac> I mean, I'm not good at using all the syntactic tricks and conveniences that allows for concise readable code
21:21:16 <ac> what precedent level to `foo` functions have?
21:21:26 <ac> s/to/do
21:21:49 <ac> s/functions/operators/
21:21:57 <bd_> you can define the precedence with the normal precedence-definition operators... otherwise it defaults to whatever all other user-defined operators default to
21:22:08 <ac> which is?
21:22:10 <bd_> I don't remember exactly where it is, I use parenthesis liberally when i'm not sure :)
21:23:14 <ac> meh. (`shiftR` 16 - x) does not work
21:23:23 <bd_> oh, slices are annoying like that :/
21:23:41 <ac> so it's a choice between (flip shiftR $ 16 - x) and (`shiftR` (16 - x))
21:24:07 <bd_> or set a precedence for `shiftR`... I don't remember the syntax for it though, since I don't use it often
21:24:32 <ac> "infixr `shiftR` 5"?
21:24:38 <bd_> something like that :)
21:25:33 <joew> I'm having trouble with a simple function in ghci:  let avg xs = (sum xs) / (length xs)
21:25:58 <joew> that function gives me a (I think) a type error
21:27:09 <BMeph> ac: According to GHCi, "infixl 8 shiftR" -- that is, from 10 being highest, and 0 being lowest
21:27:19 <bd_> joew: / is for floating-point division, but length returns an integer. Use `div` instead of /, or use genericLength (in Data.List) instead of length
21:27:38 <joew> thanks bd
21:28:00 <bos> @hoogle when
21:28:00 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
21:28:20 <rieux> > \xs -> sum xs / length xs
21:28:21 <ac> bd_: yeah, that's a good way to remember the syntax: info (+)
21:28:21 <lambdabot>   add an instance declaration for (Fractional Int)
21:28:21 <lambdabot>     In the expression: (su...
21:28:54 <pjd> bd_: or (fromIntegral $ length xs)
21:29:18 <rieux> > \xs -> sum xs / fromIntegral (length xs)
21:29:20 <lambdabot>  <[Double] -> Double>
21:29:55 <BMeph> Yeah, but if you're going through the trouble of using fromIntegral, you might as well just use the generic version.
21:30:16 <pjd> ObPointless:
21:30:17 <pjd> > (/) <$> sum <*> (fromIntegral . length)
21:30:18 <lambdabot>  <[Double] -> Double>
21:30:47 <pjd> BMeph: requires an import, though
21:31:16 <BMeph> pjd: and <*> doesn't? ;)
21:31:16 <joew> pjd: where's the list parameter in your last function?
21:31:25 <pjd> BMeph: no, that was just me being pointless
21:31:27 <bd_> :t <*>
21:31:28 <lambdabot> parse error on input `<*>'
21:31:32 <bd_> :t (<*>)
21:31:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:32:00 <bos> @hoogle elemBy
21:32:00 <lambdabot> No matches found
21:32:04 <pjd> joew: supplied by the reader functor/monad :)
21:32:21 <bos> @hoogle (a -> Bool) -> a -> Bool
21:32:22 <lambdabot> Data.Foldable.any :: Foldable t => (a -> Bool) -> t a -> Bool
21:32:22 <lambdabot> Data.Foldable.all :: Foldable t => (a -> Bool) -> t a -> Bool
21:33:06 <pjd> joew: it's another way of saying liftA2 (/) sum (fromIntegral . length)
21:33:55 <joew> pjd: I see, thanks
21:34:07 <BMeph> pjd: List functor, not reader, isn't it?
21:34:20 <pjd> BMeph: nah, reader
21:34:47 <pjd> > liftA2 (/) [1,2] [3,4]
21:34:48 <lambdabot>  [0.3333333333333333,0.25,0.6666666666666666,0.5]
21:34:55 <pjd> that's List
21:38:16 <BMeph> pjd: Ah, I see it.
21:42:36 <Cin> ah, hurrah. i got HsColour synchronised with Haddock: http://monkeyboy.td.org.uit.no/~cin/code/hircd/doc/index.html
21:44:46 <Cin> what would this function look like if i used a monad?
21:44:47 <Cin> addClient :: ClientID -> Chan Message -> State -> IO State
21:44:48 <Cin> addClient id ch state = return state { stateClients = newClients } where newClients = Map.insert id (newClient ch) (stateClients state)
21:45:07 <dolio> @pl maybe Nothing Just
21:45:07 <lambdabot> maybe Nothing Just
21:45:54 <bd_> addClient :: ClientID -> Chan Message -> StateT YourStateType IO;  addClient id ch = modify $ \s -> { stateClients = Map.insert id (newClient ch) $ stateClients s }
21:45:58 <bd_> is one way to do it
21:46:00 <pjd> @unpl maybe Nothing Just
21:46:00 <lambdabot> maybe Nothing Just
21:46:03 <bd_> er
21:46:08 <bd_> StateT YourStateType IO ()
21:47:29 <Cin> ah, that is shorter than i expected
21:48:17 <dolio> @check \mi -> maybe Nothing Just mi == (mi :: Maybe Int)
21:48:18 <bd_> you'd probably want to add a type WhateverM t = StateT YourStateType IO t
21:48:21 <lambdabot>  OK, passed 500 tests.
21:49:26 <bd_> just for less typing
21:49:40 <Cin> yeah
21:50:02 <oerjan> missing an s before {
21:51:02 <Cin> is it possible to have { someRecord = foo }   instead of  \s -> s { someRecord = foo } ?
21:51:14 <bd_> alas, no :(
21:51:20 <Cin> oki, just curious :P
21:53:45 <Cin> hrm. well that makes a lot of sense
21:54:04 <Cin> i was wondering how you would modify the state of the computation from inside the function
21:54:21 <Cin> makes sense that you'd return a new state
21:54:41 <bd_> you don't with a state monad
21:54:52 <Cin> isn't that what `modify' is doing?
21:55:00 <bd_> modify doesn't return a state :)
21:55:09 <Cin> what does it return?
21:55:25 <bd_> modify's type is, essentially (slight simplification): modify :: (t -> t) -> State t ()
21:55:49 <Cin> well, i'm referring to the `t' as the state
21:55:53 <bd_> State t r being an action in the state monad which acts on a state of type t, and returning a value or r
21:56:05 <bd_> well, technically it's taking in a state, and returning it... but the monad hides that :)
21:56:14 <Cin> right
22:01:40 <brad___`> quick question - i have an api function that i have published in hackage that someone has requested a change to...it ould require a function to get a new parameter, which i am a little averse to doing (breaking compatibility)...is it possible to have a function arg have a default value?
22:02:52 <bd_> brad___`: you could define a typeclass for it
22:03:16 <brad___`> hmmm, thanks bd_
22:03:20 <bd_> yourFunction :: YourFunctionClass f => f, then define instances for the full set of args, plus another instance with the default filled in
22:03:47 <brad___`> i see...can't say i have seen that technique before
22:03:52 <brad___`> interesting
22:03:54 <bd_> it leads to ugly error messages :)
22:04:06 <bd_> and ugly haddock too, possibly
22:04:19 <brad___`> i wonder if i should just create a wrapper
22:04:23 <brad___`> would be easier
22:04:28 <brad___`> if a little hacky
22:04:46 <brad___`> but people using the wrapped function would not notice the difference
22:04:47 <ac> hmm, how to make these produce the same result:
22:04:51 <ac> > (\d l -> foldl ((+) . (2 ^ d *)) 0 $ l) 4 [2, 0]
22:04:53 <lambdabot>  32
22:04:54 <ac> > (\d l -> foldl ((+) . (2 ^ d *)) 0 $ l) 4 [2]
22:04:55 <lambdabot>  2
22:05:13 <brad___`> well thanks bd_
22:06:21 <oerjan> @unpl (+) . (2 ^ d *)
22:06:21 <lambdabot> (\ e -> (+) ((2 ^ d) * e))
22:06:40 <ac> and these to produce the same result:
22:06:49 <ac> > (\d l -> foldl ((+) . (2 ^ d *)) 0 $ l) 1 [1]
22:06:49 <lambdabot>  1
22:06:55 <ac> > (\d l -> foldl ((+) . (2 ^ d *)) 0 $ l) 1 [1,0,0,0,0,0,0,0]
22:06:55 <lambdabot>  128
22:07:15 <oerjan> maybe you want foldr?
22:07:22 <ac> I was thinking that
22:08:24 <oerjan> (also, foldl' is generally recommended over foldl)
22:08:36 <ac> :t foldl'
22:08:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:08:46 <ac> :t foldl
22:08:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:09:10 <ac> don't see a whole lot of distinction :-P
22:09:14 <oerjan> it is strict, so evaluates incrementally and uses less stack
22:09:30 <ac> bah, premature optimization
22:09:35 <oerjan> > foldl (*) 1 [1..150000]
22:09:41 <lambdabot> Terminated
22:09:45 <oerjan> > foldl' (*) 1 [1..150000]
22:09:51 <lambdabot> Terminated
22:09:55 <oerjan> argh
22:09:56 <ac> heh
22:10:04 <ac> that's a very big number
22:10:07 <oerjan> never remembers quite the right size...
22:10:22 <flux> maybe + would be more suitable :)
22:10:35 <sarehu> Is there any idiomatic way to run an  IO Bool  action until it returns False?
22:10:37 <oerjan> hm
22:10:42 <oerjan> > foldl' (+) 1 [1..150000]
22:10:43 <lambdabot>  11250075001
22:10:47 <oerjan> > foldl (+) 1 [1..150000]
22:10:47 <lambdabot>  11250075001
22:10:55 <ac> > foldl' (*) 1 [1 :: Word32 .. 150000]
22:10:56 <lambdabot>  0
22:11:03 <ac> > foldl (*) 1 [1 :: Word32 .. 150000]
22:11:04 <lambdabot>  0
22:11:57 <oerjan> ghc tries to optimize foldl to foldl' itself with its strictness analyzer.
22:12:31 <oerjan> sarehu: i don't think so
22:12:37 <sarehu> ok, thanks
22:13:51 <flux> > foldl (+) 1 [1..10000000]
22:13:54 <lambdabot> Terminated
22:13:57 <flux> > foldl' (+) 1 [1..10000000]
22:14:01 <lambdabot> Terminated
22:14:10 <flux> it doesn't give too many cpu seconds does it
22:14:18 <oerjan> 3 secs
22:14:30 <flux> well it's not running on a very fast host then :)
22:14:34 <flux> > foldl' (+) 1 [1..1000000]
22:14:35 <lambdabot>  500000500001
22:14:39 <flux> > foldl' (+) 1 [1..1000000]
22:14:40 <lambdabot>  500000500001
22:14:41 <flux> argh
22:14:58 <flux> > foldl (+) 1 [1..1000000]
22:14:59 <lambdabot>  Exception: stack overflow
22:15:16 <flux> finally.
22:15:45 <ac> what's a scenario where lazy foldl is better?
22:16:13 <oerjan> ac: they're supposed to exist but are vanishingly rare and i don't know any
22:16:15 <flux> maybe something where you produce a list?
22:16:36 <oerjan> flux: usually that means foldr instead...
22:17:23 <oerjan> @go site:haskell.org stack overflow
22:17:25 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
22:17:25 <lambdabot> Title: Stack overflow - HaskellWiki
22:19:38 <OceanSpray> :t maybe
22:19:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:20:19 <flux> hm
22:20:47 <flux> > let v = foldl (\a b -> b:a) [] [1..10000000]
22:20:47 <lambdabot>  Parse error at end of input
22:21:08 <flux> > head (foldl (\a b -> b:a) [] [1..10000000])
22:21:12 <lambdabot> Terminated
22:21:25 <flux> > head (foldl (\a b -> b:a) [] [1..1000000])
22:21:25 <lambdabot>  1000000
22:21:30 <flux> > head (foldl' (\a b -> b:a) [] [1..1000000])
22:21:30 <lambdabot>  1000000
22:22:08 <flux> the last one takes a lot more memory on my machine (with a bigger number, though)
22:22:45 <flux> > head (foldl' (\a b -> b:a) [] [1..5000000])
22:22:46 <lambdabot>  5000000
22:22:50 <flux> > head (foldl' (\a b -> b:a) [] [1..10000000])
22:22:53 <lambdabot> Terminated
22:23:01 <flux> difficult to fine tune ;)
22:23:13 <lispy> you can always /msg lambdabot too
22:23:23 <flux> yeah, I switched to that
22:23:28 <lispy> but, you might get more run time doing it that way
22:23:36 <lispy> so, it may not reflect the results you get from doing it here
22:24:43 <flux> I think more efficient use of my time at this point is to make breakfast ;)
22:25:44 <OceanSpray> can you pass data constructors around?
22:26:12 <Cin> > map Just [1,2,3]
22:26:12 <lambdabot>  [Just 1,Just 2,Just 3]
22:26:32 <Cin> seems so
22:26:42 <oerjan> only the function part of them
22:27:13 <ac> ok, so I'm going to ask the stupid question of why there's no foldr'
22:28:12 <ac> and if you say "there are no stupid questions", I'll say "the question is indicative of my stupidity"
22:28:12 <oerjan> because it would blow the stack
22:28:29 <dons> nostrademons is fun. arc in js, http://halogen.note.amherst.edu/~jdtang/arclite/
22:28:30 <lambdabot> Title: ArcLite - Arc Ported to JavaScript
22:29:12 * ac would rather think of foldr and foldl in terms of algebraic expressions, and not think about things like stacks
22:29:17 <pjd> sarehu: let until a = do x <- a; unless x (until a)
22:29:40 <OceanSpray> @hpaste
22:29:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:29:44 <adu> > take 2 [1..]
22:29:45 <lambdabot>  [1,2]
22:29:55 <oerjan> ac: foldl' was added in afterthought when they realized how badly foldl worked.  since foldr' also works badly no one has seen the need to add it. :)
22:30:01 <adu> > foldr (\n -> filter (\m -> case n of _ | (n == m) -> True | (n /= m) -> not (mod m n == 0))) [2..50] [2..50]
22:30:02 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
22:30:08 <OceanSpray> http://hpaste.org/5521
22:30:17 <OceanSpray> in this thing here,
22:30:38 <OceanSpray> is there any way to parameterize this copy-paste code?
22:30:43 <ac> oerjan: that makes sense ;)
22:32:22 <oerjan> OceanSpray: seems to hit straight at the lack of first-class patterns
22:32:35 <OceanSpray> oy.
22:32:54 <lispy> how does that code even work?
22:33:02 <oerjan> you can of course factor out some other minor parts...
22:33:11 <lispy> only the first pattern would be hit, withEvalPrc v f = ...
22:33:12 <OceanSpray> like?
22:33:21 <lispy> and then x had better be a Procedure or you get an error
22:33:45 <OceanSpray> lispy, I'm not getting you.
22:33:54 <lispy> OceanSpray: was that a complete example?
22:33:58 <OceanSpray> no.
22:34:01 <oerjan> hm good question.
22:34:03 <lispy> Okay.
22:34:08 <OceanSpray> withEval's got its own definition,
22:34:16 <allbery_b> lispy: I see three distinct functions with different names
22:34:18 <lispy> OceanSpray: then nevermind.   Without seeing more of the code, I can't suggest much.
22:34:27 <oerjan> OceanSpray: it might work better using the Maybe monad, perhaps?
22:34:29 <lispy> oh, I'm tried and read them as the same name
22:34:37 <OceanSpray> oerjan, I am using the maybe monad.
22:34:38 <dynamix> whats wrong with this? isParm::Flag->Maybe a
22:34:40 <dynamix> isParm flg  = case flg of
22:34:42 <dynamix>                (Parm par) -> (Just par)
22:34:43 <dynamix>                 _         -> (Nothing)
22:34:56 <OceanSpray> withEval v f = eval v >>= maybe (throwError (NoValue v)) f
22:35:09 <oerjan> OceanSpray: i mean with mplus and the fail on pattern failure in do
22:35:19 <OceanSpray> what's mplus?
22:35:23 <OceanSpray> :t mplus
22:35:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
22:35:27 <lispy> OceanSpray: I think your use of maybe is off...I think the first param should be the default value
22:35:28 <oerjan> @src Maybe mplus
22:35:28 <lambdabot> Nothing `mplus` ys  = ys
22:35:28 <lambdabot> xs      `mplus` _ys = xs
22:35:37 <Cin> dynamix: parentheses arent' necessary in that code.. what type do you want isParm to return?
22:36:04 <Cin> dynamix: oh, Maybe. what's the error?
22:36:26 <dynamix> Cin cant it be generic in its return type? it has to match Integer though because Parm Integer is a constructor
22:36:32 <OceanSpray> lispy, it compiles and runs fine.
22:36:35 <oerjan> dynamix: looks like _ is indented more than ( ?
22:36:42 <OceanSpray> I'm not using maybe wrong.
22:36:51 <lispy> Cin: Flag is either missing a type parameter or the 'a' should be replaced by the type of par
22:37:00 <Cin> dynamix: ahhh. i may be wrong but i don't think it can be generic if your function is using the type of par
22:37:04 <lispy> OceanSpray: okay, maybe I should shut up.  I think I'm tried :)
22:37:09 <ac> say I have a function like so:
22:37:15 <ac> > (\n l -> (++) l $ replicate (n - length l) 0) 4 [1]
22:37:15 <lambdabot>  [1,0,0,0]
22:37:25 <ac> is the length and concatonate merged together?
22:37:28 <OceanSpray> All I'm trying to do here is prettying up my code.
22:37:37 <ac> (just out of curiosity)
22:37:44 <dynamix> oerjan: thanks that was it. !! my good ness not only is my brain getting numb , my eye sight has gone down and typos have gone up.
22:38:00 <Cin> oh
22:38:09 <dynamix> doesnt look like the best time in life to pickup a new skill :)
22:38:31 <lispy> ac: are any of those functions new to you?
22:38:31 * ac wishes programming wasn't so hard on eyesight
22:38:45 <lispy> ac: are you familiar with, $, for example?
22:38:46 <Cin> lispy: seems like we invented errors because no error message was provided :)
22:38:56 <ac> lispy: what do you mean? yeah... I use $ a lot
22:39:08 <ac> lispy: my question was about GHCs optimization capabilities
22:39:22 <lispy> ac: oh, n/m then :)
22:39:38 <lispy> ac: I thought it was a question about the way the expression evaluates
22:39:53 <dynamix> Cin you are right, it cant be generic as it is a rigid type. it has to be Integer
22:40:02 <ac> it wasn't very well phrased. I mean does GHC compile it so first the length is calculated, and then it's concatenated, or does it run along the list calculating the length until it gets to the end, and then continues with the concatenation
22:40:06 <lispy> Cin: Um, 'Flag -> Maybe a' really should be a problem...or am I missing something here?
22:40:27 <Cin> lispy: i don't really know, i was just guessing, so you are probably right
22:41:09 <lispy> Cin: what happens with that type is that the 'a' comes into existence out of no where, but it has to unify with the type of (Just par)
22:41:41 <lispy> Cin: if par has a polymorphic type mentioned somewhere else, preferably as an 'a' then we're good
22:41:51 <ac> anyway, what I reall want is a version of this function:
22:41:53 <ac> chunk n = map (genericTake n) . takeWhile (not.null) . iterate (genericDrop n)
22:41:55 <Cin> lispy: eg Eq a => ?
22:42:01 <lispy> Cin: that could be the case if we had, for example, Flag a -> Maybe a
22:42:12 <Cin> lispy: ah, yeah
22:42:17 <ac> that takes another argument, and produces a list of lists that are always the same length, possibly with the extra argument filled in
22:42:31 <Cin> lispy: then we wouldn't have to inspect the type, it could remain generic?
22:42:53 <lispy> Cin: otherwise, if we had something like data Flag = Flag Int, then we need 'a == Int' but since a came out of no where, it's polymoriphic and Int is a specific type so they won't unify
22:43:17 <Cin> lispy: ah, i see. makes sense
22:43:33 <lispy> yeah, not inpsecting the type allows it to remain generic
22:43:44 <oerjan> OceanSpray: basically the shortest thing i can think of that is first class and contains the essence of such a pattern match is:
22:44:08 <oerjan> \x -> do Procedure p <- x; return p
22:44:19 <lispy> Cin: adding something like Eq a => ..., just means you require that 'a' is a type which suppports a given interface.  Which is quite handy, but I don't think that alone would solve the type error here.
22:44:34 <OceanSpray> ???
22:45:02 <oerjan> OceanSpray: so if pm x = do Procedure p <- x; return p
22:45:13 <oerjan> then the rest of the function could be
22:45:49 <lispy> OceanSpray: what if you added a type class that defined an 'eval' function and some extraction function to replace Procedure p -> f p, Environment e -> f e, Number n -> f n
22:46:34 <oerjan> withEval v $ \x -> pm (Just x) `mplus` throwError (WrongType "procedure" x)
22:46:47 <oerjan> barring some shuffling around of where you have Maybes
22:47:08 <lispy> OceanSpray: then you make instances for Procedure, Environment and Number
22:47:08 <ac> fill n d l = (++) l $ replicate (n - length l) d
22:47:11 <ac> chunkUniform n d l = map (fill n d) $ chunk n l
22:47:30 <lispy> OceanSpray: have you seen the type witness and GADT approaches to interpreters?
22:47:57 <lispy> OceanSpray: they may also work here by allowing you to roll Procedure, Envivornment and Number into one type in a safe way
22:48:11 <OceanSpray> lispy, Procedure, Environment, and Number are data constructors for the same type.
22:48:26 <OceanSpray> they're not their own types.
22:48:32 <lispy> Oh, I see.
22:49:04 <OceanSpray> how do I get our of ghci?
22:49:09 <OceanSpray> *out
22:49:20 <lispy> OceanSpray: you can of course, replace Procedure p, with isProcedure :: Foo -> Bool, and getProcedure :: Foo -> Maybe Proc
22:49:29 <lispy> OceanSpray: ctrl+d
22:49:45 <OceanSpray> oh wow.
22:49:45 <lispy> OceanSpray: and then you could use pattern guards
22:50:11 <leodem> hi, i've defined the following types
22:50:12 <leodem> data Abb a b = Branch a b (Abb a b) (Abb a b) | Leaf and
22:50:14 <leodem> data ListAssoc a b = Node a b (ListAssoc a b) | Empty
22:50:15 <leodem>  and I've tried to create a collection class like follows
22:50:17 <leodem> class Container c a b |c -> a, c -> b  where
22:50:18 <leodem> empty :: c
22:50:20 <leodem> add :: c -> a -> c
22:50:21 <leodem> search :: c -> a -> Maybe b
22:50:23 <leodem> del :: c -> a -> c
22:50:24 <leodem> but when I trie to load it in hugs it says:
22:50:26 <leodem> Error - Instance is more general than a dependency allows
22:50:27 <leodem> *** Instance         : Container Abb a b
22:50:29 <leodem> *** For class        : Container a b c
22:50:30 <leodem> *** Under dependency : a -> b
22:50:32 <leodem> I've never worked with dependencies so i got no idea what the problem is so i cannot even start to "fix" it.... any suggestions?
22:50:44 <OceanSpray> leodem, try hpaste next time.
22:51:03 <leodem> whats that?
22:51:09 <OceanSpray> @hpaste
22:51:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:51:50 <oerjan> leodem: c -> a means for each type c there can be at most exactly one (non-polymorphic) type a
22:51:53 <OceanSpray> lispy, even with that, I'd still have to pattern match to output the correct error message.
22:52:08 <ac> think it would also be useful to have a chunk function that explodes when the input list doesn't have a length which is a multiple of n
22:52:26 <oerjan> so Container Abb a b with type variables a and b is right out
22:53:00 <ac> so I'll have chunk, chunkUniform, and chunkSafe
22:53:10 <ac> or, maybe I should call it "chunkAnal"
22:53:18 <lispy> OceanSpray: use type classes
22:53:31 <lispy> OceanSpray: actually you don't even need that
22:54:27 <lispy> OceanSpray: put your pattern matching into a function and then just call the function is the basic rewrite i'm thinking
22:55:16 <lispy> OceanSpray: for example, x is either, Procedure p, Environment e, or Number n, so you can define a function foo (Procedure _) = "procedure"
22:55:28 <lispy> foo (Env.. _) =. "environment"
22:55:28 <lispy> etc
22:55:32 <leodem> oerjan: thanks, but is there anyway I can create this class? becuase i've been searching and all the samples I found were containers that holded just one type of value?
22:55:35 <lispy> OceanSpray: and just call that
22:55:51 <oerjan> lispy: that doesn't allow him to specify the error messages
22:56:30 <lispy> err -> throwError (WrongType (foo x) err)
22:56:35 <lispy> no?
22:56:52 <lispy> I think i see the problem
22:56:56 <oerjan> lispy: that's what he _has_
22:57:20 <oerjan> leodem: maybe it would be simpler to use an (a,b) tuple?
22:58:19 <oerjan> leodem: oh wait.  you need the instance type to mention a and b somehow.
22:58:35 <OceanSpray> If Haskell had macros...
22:58:42 <oerjan> Container (Abb a b) a b would work
22:59:16 <lispy> OceanSpray: so the basic problem is that you can pass something besides an Env to withEvalEnv, or is it that the result of withEval ends up as the wrong type?
22:59:16 * ac must have a relatively juvenile sense of humor
22:59:23 <leodem> oerjan: yes I thought about that and I'll try it. but I wondered if there was someway to do it without tuples, but thanks a lot!
22:59:39 <OceanSpray> oh forget it.
22:59:58 <OceanSpray> It's not like this code is uber-verbose.
23:00:07 <OceanSpray> I'm keeping what I got and moving on.
23:02:48 <lispy> OceanSpray: ghc does support something close to macros that would work here
23:02:58 <lispy> OceanSpray: but it requires a language extension, for Template Haskell
23:03:05 <OceanSpray> overkill.
23:03:09 <lispy> yeah
23:03:13 <OceanSpray> moving on.
23:03:57 <lispy> isProc :: Foo -> Either String Proc
23:04:02 <lispy> that would solve it
23:04:39 <lispy> isProc (Procedure p) = return p; isProc _ = fail "procedure"
23:06:19 <lispy> and using the Either monad you could probably tighten up the code a bit
23:06:32 <lispy> :t either
23:06:33 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:07:17 <bos> i'd never really timed GHC's performance for dealing with threads.
23:07:23 <bos> it's impressive.
23:07:39 <bos> i can fork 100,000 threads per second on my laptop.
23:08:08 <bos> i can send a message through those 100,000 threads in 0.1 seconds.
23:08:20 <dynamix> is this valid Haskell syntax?   instance RandomGen StdGen where ...
23:08:25 <dynamix> what does the ... mean?
23:08:31 <bos> no, it's not valid.
23:08:41 <oerjan> dynamix: not the ...
23:09:04 <lispy> OceanSpray: so, I know you moved on, but you could use either + (isProc,isEnv,isNum) and I think it would turn out pretty close to what you really want.  You still have to do a pattern match but, the redudancy is encapsulated so that you can write the "\x -> case x of ..." style code once and just pass in the different predicates
23:09:08 <oerjan> it just means "body of definition eluded"
23:09:27 <lispy> bos: cool
23:09:54 <OceanSpray> oh yeah,
23:10:17 <OceanSpray> how do I make a cyclical module import work?
23:10:33 <OceanSpray> what's that file you have to create and what do you do with it?
23:10:35 <lispy> OceanSpray: you don't...iirc it's painful you have to us. .hs-boot files
23:10:49 <OceanSpray> but it seems I have to, in my case.
23:10:56 <lispy> :(
23:11:18 <OceanSpray> see, I got a Parser and Primitives
23:11:30 <OceanSpray> and LispData, which holds the data definitions.
23:11:51 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
23:11:52 <lambdabot> http://tinyurl.com/2y3hr6
23:12:22 <oerjan> @where mutual-recursion
23:12:22 <lambdabot> I know nothing about mutual-recursion.
23:12:23 <bd_> OceanSpray: can you put all your mutually-referencing data structures in a single module?
23:12:38 <oerjan> @where+ mutual-recursion http://haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
23:12:39 <lambdabot> Done.
23:12:47 <dynamix> :t random
23:12:48 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
23:13:32 <dynamix> takes a generator and returns a random number and another generator?
23:13:40 <oerjan> dynamix: right
23:13:48 <bos> on my 32-bit desktop, i can fork 180,000 threads per second.
23:13:50 <bos> niiice.
23:14:07 <bos> with a thread stack size of 172 bytes.
23:15:07 <oerjan> > unfoldr (Just . random) (mkStdGen 42) :: [Int]
23:15:22 <lambdabot>  thread killed
23:15:36 <oerjan> > take 10 $ unfoldr (Just . random) (mkStdGen 42) :: [Int]
23:15:36 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
23:16:25 <lispy> > case random (mkStdGen 42) of (a, g) -> (a, mkStdGen 42) : [random g]
23:16:26 <lambdabot>  [(-1673289139,43 1),(1483475230,1735131843 1872071452)]
23:17:01 <dynamix> how can i know the largest unsigned Int possible in Hasekll? not the Integer type..  basically i want a PRNG that mimics the C rand()
23:17:11 <lispy> gosh, if only we had a way to thread that random number generator between the calls to random....
23:17:18 <oerjan> > maxBound :: Word
23:17:19 <lambdabot>  4294967295
23:17:30 <lispy> > maxBound :: Int
23:17:30 <lambdabot>  2147483647
23:17:40 <lispy> > maxBound :: Word64
23:17:41 <lambdabot>  18446744073709551615
23:17:46 <lispy> > maxBound :: Word128
23:17:47 <lambdabot>  340282366920938463463374607431768211455
23:17:52 <Twey> Ooh.
23:17:54 <Twey> Big.
23:18:16 <lispy> for all I know there is a Word256
23:18:22 <bd_> > maxBound :: Word256
23:18:28 <lambdabot>  115792089237316195423570985008687907853269984665640564039457584007913129639935
23:18:32 <lispy> nice
23:18:37 <lispy> > maxBound :: Word1024
23:18:38 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
23:18:41 <lispy> lol
23:18:49 <bd_> > maxBound :: Word4096
23:18:50 <lambdabot>  3231700607131100730071487668866995196044410266971548403213034542752465513886...
23:18:53 <bd_> oh wow
23:18:58 <bd_> > maxBound :: Word65536
23:18:58 <lambdabot>   Not in scope: type constructor or class `Word65536'
23:19:04 <oerjan> > evalState (replicate 10 $ State random) $ mkStdGen 42
23:19:04 <lambdabot>  Couldn't match expected type `State a a1'
23:19:12 <bd_> > maxBound :: Word8192
23:19:12 <lambdabot>   Not in scope: type constructor or class `Word8192'
23:19:17 <lispy> What machine out there has a Word4096 though?
23:19:26 <bd_> lispy: It's for the crypto library I think
23:19:37 <oerjan> > evalState (replicateM 10 $ State random) $ mkStdGen 42
23:19:37 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
23:19:39 <dynamix> > getStdRandom (randomR (0,maxBound::Int))
23:19:40 <lambdabot>  <IO Int>
23:20:12 <oerjan> dynamix: we use that mkStdGen trick because lambdabot doesn't allow IO
23:20:51 <dynamix> im still trying to make sense out of that part :)
23:20:56 <dynamix> :t evalState
23:20:57 <lambdabot> forall s a. State s a -> s -> a
23:21:24 <lispy> :t State random
23:21:25 <lambdabot> forall s a. (Random a, RandomGen s) => State s a
23:21:58 <oerjan> dynamix: the type of random is almost the type of a State monad action - just need to wrap it in the constructor and all the monad functions are available
23:22:37 <lispy> :t State
23:22:38 <lambdabot> forall s a. (s -> (a, s)) -> State s a
23:22:42 <oerjan> that does the threading of randomgens lispy was alluding to
23:23:34 <lispy> you see that State takes a function as a parameter, and the function should return a tuple
23:23:35 <dynamix> yeah, i understood how the state is being used.. but im still kinda lost some where..
23:23:53 <dynamix> well its already 11:23 pm here..
23:24:05 <oerjan> replicateM 10 runs a monadic action 10 times, collecting all the results
23:24:06 <dynamix> yeah, and teh tuple has a new state adn some value right?
23:24:18 <lispy> right
23:24:54 <dynamix> :t random
23:24:54 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
23:25:23 <dynamix> random takes a state and returns a tuple like we want.
23:26:03 <dynamix> :t State (\_ -> ( 1,1) )
23:26:04 <lambdabot> forall s t. (Num t, Num s) => State s t
23:26:55 <dynamix> :t mkStdGen
23:26:56 <lambdabot> Int -> StdGen
23:27:03 <lispy> state is pretty cool till you realize you can only thread one value at a time...
23:27:06 <BMeph> :t State divMod
23:27:06 <lambdabot>     Couldn't match expected type `(a, s)'
23:27:06 <lambdabot>            against inferred type `s -> (s, s)'
23:27:06 <lambdabot>     In the first argument of `State', namely `divMod'
23:27:29 <lispy> you'd have to layer state monads or use a more complex value (making updates expensive)
23:27:34 <lispy> if you wanted to do more than one value
23:27:44 <BMeph> :t State (divMod 10)
23:27:45 <lambdabot> forall t. (Integral t) => State t t
23:28:26 <lispy> :t State (\x -> (x, (x,x,x,x,x,)))
23:28:27 <lambdabot> parse error on input `)'
23:28:29 <lispy> :t State (\x -> (x, (x,x,x,x,x,))
23:28:30 <lambdabot> parse error on input `)'
23:28:39 <lispy> :t State (\x -> (x, (x,x,x,x,x)))
23:28:40 <lambdabot>     Occurs check: cannot construct the infinite type:
23:28:41 <lambdabot>       t = (t, t1, t2, t3, t4)
23:28:41 <lambdabot>       Expected type: t
23:28:55 <lispy> oh duh
23:28:56 <lispy> oh well
23:28:57 <dynamix> what does evalState actually do? takes a tuple ( State s a) and a state and returns a value?
23:29:15 <oerjan> :t State (\x -> ((x,x,x,x,x), x))
23:29:16 <lambdabot> forall s. State s (s, s, s, s, s)
23:29:27 <lispy> oerjan: thanks :)
23:29:43 <oerjan> @src State
23:29:43 <lambdabot> Source not found. Maybe you made a typo?
23:29:56 <allbery_b> evalstate does a calculation given a state, and throws away the (possibly modified) result state
23:30:02 <lispy> dynamix: well, a State s a, is built from a function right?
23:30:09 <dynamix> we did not give a function right?
23:30:16 <oerjan> evalState (State f) s = fst (f s), essentially
23:30:17 <lispy> :t State
23:30:17 <lambdabot> forall s a. (s -> (a, s)) -> State s a
23:30:20 <dynamix> oh yeah.. State takes a function that returns the tuple
23:30:29 <dynamix> so that explains everything now
23:30:34 <allbery_b> execstate does a calculation given a state, and throws away the result; this is used when you just want to modify the state
23:31:21 <adu> i just found the shortest code for primes
23:31:27 <dynamix> neat. i hope there are long and boring meetings tomorrow. or neverending builds.. so i can get some time with this :)
23:31:30 <lispy> dynamix: and functions like replicateM, essentially compose those functions (in the case of State)
23:31:40 <oerjan> adu: shorter than the nubBy trick? :)
23:31:49 <adu> oerjan, dunno
23:31:57 <adu> > take 10 [n | n<-[1..], all ((==1).(gcd n)) [2..n-1]]
23:31:59 <lambdabot>  [1,2,3,5,7,11,13,17,19,23]
23:32:18 <oerjan> > nubBy (((>1).).gcd) [2..]
23:32:18 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:32:26 <lispy> adu: but it prints some non-primes
23:32:26 <adu> whats numBy?
23:32:35 <oerjan> @src nubBy
23:32:35 <lambdabot> nubBy eq []             =  []
23:32:35 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
23:32:38 <adu> > take 10 [n | n<-[2..], all ((==1).(gcd n)) [2..n-1]]
23:32:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
23:32:39 <lispy> adu: 1 is not prime nor composite
23:33:29 <dynamix> gnite folks and thanks alot!!
23:33:55 <ac> ok, so say I want to call a function that may produce an error, and in the case it does, produce another different error. Should I just make the first function return a Maybe type, or is there some sort of exception catching mechanism?
23:33:56 * sclv wants a primes function using loeb and fix
23:34:03 <opqdonut> loeb?
23:34:12 <lispy> > groupBy (((>1).).gcd) [2..]
23:34:13 <lambdabot>  [[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17],[18...
23:34:21 <ski> loeb :: Functor f => f (f a -> a) -> f a
23:34:33 <lispy> what does loeb mean?
23:34:39 <oerjan> ac: see Control.Monad.Error for more advanced error monads
23:34:41 <lispy> is it an english word?
23:34:46 <sclv> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
23:34:46 <lambdabot> Title: A Neighborhood of Infinity: Tying Knots Generically
23:34:52 <adu> I don't have nubBy, where do I get that?
23:34:54 <oerjan> lispy: it's a name
23:34:56 <BMeph> "Look Out, every body!" ;)
23:34:56 <ac> oerjan: figures there's some sort of error monad ;)
23:34:57 <pjd> lispy: Lb
23:34:59 <oerjan> adu: Data.List
23:35:05 <adu> ic
23:35:12 <oerjan> :t catchError
23:35:13 <lispy> pjd: so it's german?
23:35:13 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
23:35:14 <sclv> loeb is sort of like mfix for a functor, ish...
23:35:18 <pjd> yeah
23:35:41 <ski> <http://en.wikipedia.org/wiki/Loeb's_theorem>
23:35:56 <lispy> sclv: oh that makes sense given the type
23:36:22 <ski> sclv : more like for a comonad, i'd say
23:36:36 <sclv> > let loeb x = fmap (\a -> a (loeb x)) x in loeb [length, head, (+4) .head, (\x-> (x!!2) + 12)]
23:36:37 <lambdabot>  [4,4,8,20]
23:36:39 <oerjan> http://en.wikipedia.org/wiki/Martin_Hugo_L%C3%B6b
23:36:41 <lispy> for lists it could be loeb :: [[a] -> a] -> [a], right?
23:36:54 <ski> *nod*
23:37:45 <lispy> well, I should sleep.
23:37:50 <Korollary> Weak
23:38:01 <oerjan> ac: also Control.Exception for IO-based exception catching
23:38:13 <ac> oerjan: does Control.Monad.Error handle Maybe types?
23:38:17 <oerjan> (which can also catch pure errors)
23:38:33 <oerjan> ac: no, Maybe is not a MonadError instance for some reason
23:38:41 <ski> Korollary : System.Mem
23:38:42 <ac> oerjan: yeah, I was hoping that it would be
23:39:17 <Cin> hurrah. i've converted my IRCd to use the StateT monad.
23:39:22 <ac> because in this case, the function that may error can only do in one way, so Maybe makes sense
23:39:42 <ski> down with `MonadError' !
23:39:42 <oerjan> ac: it wouldn't make sense to "produce a different error" with just the Maybe monad anyhow
23:40:15 <sclv> > let loeb x = fmap (\a -> a (loeb x)) x in loeb $ [const 1, const 2] ++ zipWith ($) (repeat (\x y -> (y!!x) + (y!!x+1))) [0..]
23:40:16 <lambdabot>  [1,2,3,5,7,11,15,23,31,47,63,95,127,191,255,383,511,767,1023,1535,2047,3071,...
23:40:32 <oerjan> yuck, a non-prime!
23:40:48 <Cin> :t (\a -> a (loeb x))
23:40:49 <lambdabot> Not in scope: `loeb'
23:40:49 <lambdabot> Not in scope: `x'
23:40:55 <Cin> whoops
23:41:24 <Cin> :t (\a -> a 1)
23:41:24 <sclv> > let loeb x = fmap (\a -> a (loeb x)) x in loeb $ [const 1, const 2] ++ zipWith ($) (repeat (\x y -> (y!!x) + (y!! (x+1)))) [0..]
23:41:25 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
23:41:25 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
23:41:29 <oerjan> :t let loeb x = fmap (\a -> a (loeb x)) x in loeb
23:41:30 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
23:41:32 <Cin> :t ($ 1)
23:41:32 <lambdabot> forall a b. (Num a) => (a -> b) -> b
23:41:59 <Cin> go me
23:42:00 <sclv> not the primes tho...
23:42:51 <oerjan> > let loeb x = fmap (\a -> a (loeb x)) x in loeb $ [const 2, const 3] ++ zipWith ($) (repeat (\x y -> (y!!x) + (y!! (x+1)))) [0..]
23:42:51 <lambdabot>  [2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,...
23:43:01 <oerjan> wow
23:43:23 <oerjan>  ++ zipWith ($) (repeat (\x y -> (y!!x) + (y!! (x+1)))) [0..]
23:43:36 <oerjan> > let loeb x = fmap (\a -> a (loeb x)) x in loeb $ [const 2, const 3] ++ zipWith ($) (repeat (\x y -> (y!!x) + (y!!x+1))) [0..]
23:43:36 <lambdabot>  [2,3,5,7,11,15,23,31,47,63,95,127,191,255,383,511,767,1023,1535,2047,3071,40...
23:44:33 <Cin> use ($ loeb x) instead, makes the line shorter :P
23:45:26 <vincenz> oerjan: curious..
23:45:47 <oerjan> vincenz: ?
23:45:55 <bos> http://www.serpentine.com/blog/2008/02/06/ghcs-performance-with-threads-is-impressive/
23:45:56 <lambdabot> Title: teideal glic deisbhalach  Blog Archive  GHC&#8217;s performance with threads ..., http://tinyurl.com/yvfeyd
23:46:00 <vincenz> oerjan: 2,3,5,...7?
23:46:14 <vincenz> ah
23:46:15 * vincenz sees
23:46:25 <vincenz> (y!!x)+1
23:46:48 <adu> they should have Haskell implementations on OEIS
23:46:57 <oerjan> oh wait, there's a 15 in it :(
23:47:05 <vincenz> oerjan: right, and the 7 s wrong too
23:47:12 <oerjan> um no
23:47:15 <vincenz> oerjan: (y!! ...  x + 1)
23:47:16 <oerjan> 7 is a prime
23:47:28 <vincenz> oh
23:47:40 <vincenz> oerjan: why would you get primes from a borked version of fib?
23:47:43 <vincenz> seriously
23:48:17 <vincenz> 15,95,255, 1023,1535..
23:48:22 <oerjan> i though sclv was attempting the primes from his first attempt and i only noticed the extraneous 1 ...
23:48:36 * vincenz missd 63
23:49:32 <sclv> primes with loeb is hard...
23:50:56 <adu> > nubBy (((==1).).gcd) [2..]
23:50:57 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
23:51:11 <adu> > nubBy (((==2).).gcd) [2..]
23:51:16 <lambdabot>  [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
23:52:11 <adu> > nubBy (((>1).).gcd) [2..]
23:52:12 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:53:18 <ski> > take 25 $ let pamf = flip fmap; loeb a = fix $ \fa -> a `pamf` ($ fa) in loeb $ [ \primes -> head . dropWhile (\n -> any (\p -> n `mod` p == 0) . take i $ primes) $ [2..] | i <- [0..]]  -- not very efficient
23:53:25 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
23:55:15 <sclv> > let loeb x = fmap (\a -> a (loeb x)) x in loeb $ [const 2, const 3] ++ zipWith ($) (repeat (\x y -> head [n | n<-[(y!!x+1)..], all ((==1).(gcd n)) (take x y)] ))[1..]
23:55:19 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:56:39 <ski> i don't see why you insist on that `zipWith ($) (repeat ...)', which is obviously the same as `map ...'
23:57:08 <sclv> > let loeb x = fmap (\a -> a (loeb x)) x in loeb $ [const 2, const 3] ++ map (\x y -> head [n | n<-[(y!!x+1)..], all ((==1).(gcd n)) (take x y)] )[1..]
23:57:11 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:57:41 <sclv> ski: because its 3am and i'm writing code in an irc client with a bottle of woodford reserve keeping me company. :-)
23:58:14 <Korollary> excuses excuses
23:58:15 * ski looks at clock ..
23:58:26 <Korollary> Don Box says you should be able to do this after two beers.
23:58:32 <ski> it is almost 09:00, time for me to go
23:59:01 <ski> Korollary : who ?
23:59:13 <dolio> Precisely.
23:59:28 <Korollary> Don Box is a distinguished engineer at MSFT
23:59:34 <Korollary> or architect. Something
