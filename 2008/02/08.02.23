00:00:04 <oerjan> calvins: well only if as and bs have the same type
00:00:06 <sclv> the darcs "just works with your setup" thing is hard to beat. way more unixy.
00:00:08 <dons> why are there even two types?
00:00:14 <glguy> usually don't need a working dir on a shared repo
00:00:23 <glguy> this might be a counter example
00:00:27 <glguy> it is habit
00:00:40 <glguy> and gitweb is a better interface anyway
00:00:47 <dons> ah, so you lose the working dir, at the cost of not web working by default
00:01:02 <glguy> more or less :)
00:01:20 <wagle_home> bare repos for pushing and pulling (fetching) from..  the working tree isnt updated when you push/pull from the repo, so why bother having it around to confuse things?  </mytake>
00:01:25 * dons suspects you could remove 50% of gits features without hurting anything
00:01:28 <chadz> cabal-install refuses to build Takusen without errors :)
00:01:43 <calvins> oerjan: how about: 'h head [1,2] "hello"'? Wanting to get (1, 'h') of course.
00:01:47 <dons> chadz: try building locally.
00:01:52 <sclv> Git says: Cannot get remote repository information. Perhaps git-update-server-info needs to be run there?
00:01:58 <calvins> That's what I was thinking of. Can that be typed?
00:01:58 <glguy> sclv: whoops
00:01:59 <glguy> fixing
00:02:13 <glguy> I just changed stuff without remembering to put that back
00:02:21 <oerjan> (forall a. [a] -> a) -> [b] -> [c] -> (b,c)
00:02:24 <dons> the git guys misssed the whole simple, orthogonal command set idea.
00:02:29 <wagle_home> half of git is the plumbing (eg. bare ghc). and the other half is plumbing (eg, standard prelude)
00:02:43 <glguy> sclv: better?
00:03:01 <wagle_home> dons, why do i have concat and join?
00:03:03 <calvins> (forall a. [a] -> a) -> [a] -> [b] -> (a, b)
00:03:13 <sclv> working tree in repo isn't for pushing and pulling, but for browsing. i heart browsing darcs repos on the web.
00:03:14 <calvins> But now I'm kind of puzzled why that works.
00:03:19 <calvins> Back to the drawing board
00:03:34 <Feuerbach> > let a = 3
00:03:34 <lambdabot>  Parse error at end of input
00:03:36 <Feuerbach> wtf?
00:03:41 <mauke> Feuerbach: missing "in"
00:03:43 <wagle_home> gitweb lets you browse bare repo
00:03:53 <glguy> sclv: did it work now?
00:03:55 <oerjan> Feuerbach: > takes an expression, not a declaration
00:04:01 <Feuerbach> mauke: oh, this isn't ghci :)
00:04:04 <sclv> yep, browsing as we speak
00:04:18 <matthew-_> dons: hang on, what do you mean it's hard to tell if it's current? If it's on Hackage's "what's new page", it's surely current no?
00:04:20 <mauke> Feuerbach: no, it's ghc -O2
00:04:28 <dons> matthew-_: you might have patches in your local repo.
00:04:39 <dons> glguy: i think stuff on code.haskell.org shouldn't be bare by default
00:04:43 <oerjan> also, a is predefined since the Expr thing was included
00:04:46 <matthew-_> not in this case! :)
00:04:46 <oerjan> > a
00:04:48 <lambdabot>  a
00:04:49 <dons> its nice for the repo to look like all the other things on code.
00:04:53 <dons> i.e. browsable
00:04:59 <wagle_home> http://git.kernel.org/?p=git/git.git;a=summary   <--- git's gitweb
00:04:59 <lambdabot> Title:
00:05:02 <glguy> ok ok ok people, /me gets it :-D
00:05:10 <matthew-_> yeah, but I'm not sure browsable means with a web-browser ;)
00:05:21 <dons> glguy: esp. if we want to present the idea that git is like a fast darcs
00:05:31 <glguy> dons: lets try not to associate git with darcs
00:05:44 <dons> i know, i know.
00:05:46 <matthew-_> it could hardly be a slow darcs could it?
00:05:48 * matthew-_ ducks
00:05:51 <glguy> and speed isn't even the primary advantage
00:06:11 <dons> i guess that's just a cherry
00:06:33 <chadz> dons: so .7 build's fine locally, yet fails in cabal-install
00:06:44 <dons> chadz: right. it tries to satisfy some funky dependency
00:06:49 <dons> the Setup.hs is ridiculous
00:07:03 <wagle_home> univerisity A gives you your phd in 120 years...  vs university B gives your your phd in 5 years.
00:07:26 <wagle_home> speed is definitely overrated
00:07:38 <dons> wagle_home: but git does have flaws, don't you think?
00:07:40 <matthew-_> go to A - you probably won't ever have to leave
00:07:56 <dons> it feels weirdly complex and ad hoc after darcs. but that's mostly ui stuff, and odd defaults
00:07:57 <matthew-_> dons: so does darcs
00:08:03 <dons> definitely
00:08:04 <sclv> glguy: so arguments in this api are all standard get or post ones, not path-bound?
00:08:10 <dons> matthew-_: i'm not arguing for darcs.
00:08:17 <matthew-_> dons: my mistake :)
00:08:19 <sioraiocht> wagle_home: which two unis are these? -p
00:08:21 <glguy> sclv: correct
00:08:25 <dons> i'm arguing for gits with a darcs interface
00:08:33 <glguy> sclv: which works out in this case since the api is rather small
00:08:43 <dons> (like the original darcs-on-git idea...)
00:08:49 <wagle_home> sioraiocht, dunno, but i come from a place where folklore phd's take 14 years
00:08:51 <glguy> sclv: though I think that the same model would work well with args in the url
00:09:04 <sioraiocht> wagle_home: at some US unis, yes
00:09:15 <sioraiocht> depends on the university/program/supervisor
00:09:29 <glguy> or the path rather
00:09:44 <sclv> you're planning to use a mod rewrite with it?
00:09:56 <glguy> sclv: not as of yet
00:10:05 <wagle_home> dons..  prolly..  not very bad..  i found a bug in git once and it was fixed within minutes
00:10:07 <glguy> sclv: the current code is only dispatching on the last path component
00:10:51 <wagle_home> main interest here is in communicating linux kernel source code, so git is the only solution
00:11:18 <wagle_home> i was just objecting to the "eh, speed doesn't matter" meme
00:12:09 <glguy> wagle_home: who brought that meme up?
00:13:27 <wagle_home> <dons> i guess that's just a cherry
00:13:38 <wagle_home> <glguy> and speed isn't even the primary advantage
00:13:49 <sclv> glguy, btw did you see I put a Diff library on hackage? nothing special, but it uses the O(ND) algorithm instead of the basic dynamic programming one, if you're interested.
00:13:53 <wagle_home>  post-apply reverse
00:14:20 <glguy> wagle_home: that means that while git is fast, that isn't even its best quality
00:14:29 <glguy> nto that no one cares about vcs speed
00:16:00 <wagle_home> i have a part time job scripting git..  git isnt too bad..  bash is awful..  8)
00:17:00 <wagle_home> s/awful/clumsy as all get out/
00:17:55 <dons> wagle_home: do you know enough darcs to have a view on how much of it we can do directly on top of git? could the darcs experience be built over git fairly seamlessly?
00:18:22 <glguy> http://code.haskell.org/~emertens/ss.png
00:18:27 <dons> hide the gunk, present the simple, nice defaults interface darcs pioneered?
00:18:27 <glguy> current attempt at new skin
00:18:53 <wagle_home> dons, no..  keep meaning to look into darcs, but never get around to it..  but now you may have given me an excuse..  heheh
00:19:54 <dons> ah well. its interface will feel ridiculously clean after git -- git was strongly inspired by darcs originally of course (and darcs even lived on top of git for a while). but things have diverged a lot since then, and git got a *lot* more complicated
00:20:16 <dons> does the git home page still talk about being a foundation for building dvcs?
00:20:45 <dons> glguy: it feels like the src is a little cramped against the top and left borders
00:21:26 <glguy> yeah, I imagine we'll have a lot of tweaking to do once the primary features get done
00:21:37 <sclv> zomg that logo is too much.
00:21:53 <glguy> sclv: think of it as a "your logo here" placeholder :-D
00:22:01 <sclv> was it made with the web 2.0 generator?
00:22:05 <glguy> yeah!
00:22:24 <sclv> the reflection was the giveaway. :-)
00:22:33 <glguy> I actually broke the refection
00:22:36 <glguy> by saving it wrong in gimp
00:22:43 <dons> i don't get the stripes on the left? what's that for?
00:22:43 <glguy> that's why its clipped
00:23:08 <glguy> dons: I've got a thing for stripes
00:23:09 <dons> polka dots i could understand
00:23:47 <glguy> I used courier new for the temporary logo since it's a pastebin with lots of <pre> text :-p
00:25:47 <wagle_home> dons, its now on my jobs list..  may be a couple weeks before i wrap my brain around darcs, though
00:27:23 <dons> i think its pretty simple coming from git (git feels like a superset with a funky api)
00:27:47 <glguy> supporting the patch soup model could be hard though
00:28:18 <wagle_home> my main interest is in getting programs to watch whats going on in the source development..  gits "flaw" (?) is that it generally has a built in assumption that a human is typing in the commands
00:28:23 <dons> yeah. that seems to be the main problem. git forces ordering a bit more. (and the underlying theory is kind of obscure?)
00:28:59 <dons> wagle_home: oh, i thought gits flaw / assumption was that a kernel hacker was typing the commands :)
00:29:09 <dons> and liked to think in inodes
00:29:13 <wagle_home> git has races when you try to make 100 commits as fast as my little script can
00:29:30 <dons> oh, interesting. you can corrupt the repos?
00:29:54 <wagle_home> the scare quotes around flaw were intended to indicate that this flaw was mostly in my head, not other people'
00:29:56 <wagle_home> s
00:30:08 <glguy> darcs definitely can't support that
00:30:26 <glguy> (creating patches really quickly with a script for example)
00:30:43 <glguy> dons: ask iavor if he still has the script that demos that
00:30:51 <dons> oh, interesting.
00:30:56 <wagle_home> dons they get confused about what the state of the repo is, but i havent seen it corrupt any thing (if i pay attention to the exitcodes and retry)
00:32:04 <wagle_home> iavor's still at psu, isnt he?
00:33:08 <sclv> glguy: how do you plan to handle validation?
00:33:28 <sclv> I see you use an error monad, but then...
00:34:58 <glguy> sclv: more specifically?
00:35:18 <glguy> things have to parse as the type of the argument
00:35:41 <sclv> right. and if the parse fails? a pretty form again with a list of failed parses, or kaboom?
00:35:52 <sclv> by which I mean an ugly error page.
00:36:02 <glguy> oh, an error message explaining which argument was bad
00:36:04 <glguy> but
00:36:07 <glguy> the only way to get those
00:36:09 <glguy> is to make your own urls
00:36:15 <glguy> as the urls are generated by the same class system
00:36:19 <glguy> internally
00:36:34 <glguy> so they can always be parsed
00:36:49 <sclv> right.. but say you submit a form and don't fill out, say, the name field, and you want that to be required...
00:37:00 <wagle_home> glguy: iavor's still at psu, isnt he?
00:37:09 <glguy> wagle_home: he's since graduated
00:37:12 <glguy> and working at Galois
00:37:31 <glguy> sclv: "" is considered a valid string
00:37:34 <wagle_home> phd? fast, but not too fast
00:37:38 <glguy> the api definitions don't handle that
00:38:26 <sclv> gotcha.
00:38:44 <glguy> all of this is being written in a kind of lazy evaluating fashion
00:38:47 <glguy> I haven't needed that yet
00:38:49 <glguy> so it isn't in there :)
00:39:11 <sclv> makes sense. i'm just thinking through the 20billion features I need to add to my lib.
00:40:02 <glguy> such validations could be handled in a separate layer
00:40:07 <glguy> this layer just ensures that everything is type correct
00:40:36 <glguy> it's a way to give your URL handlers type signatures
00:41:13 <wagle_home> glguy, what did he do he dissertation on?
00:41:33 <calvins> anybody know how to get lhs2TeX to not interpret the '.' in (forall a. a -> a) as function composition?
00:42:18 <glguy> wagle_home: http://purely-functional.net/
00:42:19 <lambdabot> Title: Iavor S. Diatchki
00:42:34 <glguy> I remember something about type-safe array accesses
00:42:44 <glguy> I know it went much further than that
00:42:47 <glguy> I haven't read it :)
00:43:00 <glguy> High-Level Abstractions for Low-Level Programming
00:45:21 <wagle_> its been since 2004 since i knew what was going on
00:45:39 <glguy> dons: once I add diff support (and trevor completes the bot) the new hpaste will have more functionality than the old one
00:46:07 * glguy investigates the new diff library
00:48:41 <cjs_> Huh. HUnit is rather more sophisticated than one would imagine at first glance.
00:49:31 <cjs_> Nice to see that it's doing stuff I'd always wished for in other unit test frameworks.
01:01:58 * glguy ponders how to integrate diff and source highlighting well
01:02:35 <glguy> fortunately highlighting-kate has a two part process when stuff can get injected nicely
01:02:51 <wagle_home> glguy, emacs diff mode..  heard something similar for vim
01:03:21 <wagle_home> sgi had a gdiff..  tkdiff was a pale imitation a few years ago
01:04:47 <wagle_home> main thing is the two (or three) sources side by side, with the current diff highlighted in color..  (and all editable)
01:05:21 <glguy> wagle_home: Oh, I meant just for displaying on the web
01:05:28 <glguy> so with libs from hackage
01:06:55 <wagle_home> ah..  dunno then
01:09:08 <glguy> for any kind of three-way editing
01:09:09 <glguy> I use meld
01:26:44 <cjs_> How do I exit with a return code in Unix?
01:27:08 <oerjan> @hoogle exit
01:27:10 <lambdabot> System.Exit :: module
01:27:10 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
01:27:10 <lambdabot> System.Exit.exitFailure :: IO a
01:34:28 <cjs_> Hm. Ok, so I do "runTestTT tests" which then returns a Counts (defined as "data Counts = Counts { cases, tried, errors, failures :: Int }"); how do I pattern match to get the individual elements out, and pass errors + failures to exitWith?
01:36:06 <TSC> You could, for example, do:
01:36:16 <TSC> exitWith (errors counts)
01:36:29 <TSC> (where "counts" is the value you got from runTestTT)
01:37:43 <cjs_> Counts :: Int -> Int -> Int -> Int -> Counts
01:37:46 <cjs_> runTestTT :: Test -> IO Counts
01:38:33 <cjs_> I'm not actually clear on that data syntax; how does the {} stuff differ from a tuple?
01:38:59 <TSC> The main difference is that the elements have names
01:39:15 <cjs_> ah!
01:39:33 <yondalf> @hoogle ar
01:39:34 <lambdabot> System.Info.arch :: String
01:39:34 <lambdabot> Control.Exception.arithExceptions :: Exception -> Maybe ArithException
01:39:34 <lambdabot> Control.Arrow.arr :: Arrow a => (b -> c) -> a b c
01:39:35 <yondalf> @hoogle arg
01:39:35 <lambdabot> Distribution.Simple.Args :: type Args
01:39:35 <lambdabot> System.Console.GetOpt.ArgOrder :: data ArgOrder a
01:39:36 <lambdabot> System.Console.GetOpt.ArgDescr :: data ArgDescr a
01:39:36 <TSC> So it's easier to extract the parts individually, and extend the type to have more components
01:39:59 <cjs_> do you know where this is described on the web, off-hand?
01:40:25 <yondalf> cjs_: {} are called records, maybe you could search on that
01:40:31 <yondalf> @google haskell records
01:40:32 <lambdabot> http://research.microsoft.com/~simonpj/Haskell/records.html
01:41:55 <TSC> http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced#Datatypes_Revisited
01:41:56 <lambdabot> http://tinyurl.com/y4u7rv
01:41:58 <TSC> Explains a bit
01:42:03 <yondalf> oops wrong link
01:44:11 <cjs_> Section 3.15 of the report does, too, but not in a way terribly useful to a beginner. There's some examples later on....
01:45:11 <cjs_> Ah, the wikibook seems just the thing.
02:00:08 <cjs_> I'm stuck. I have a "runTestTT :: Test -> IO Counts", and I need to do something like "exitWith $ ExitFailure $ failures counts", but I'm all messed up in how to deal with the IO monad stuff.
02:00:42 <yondalf> cjs_: paste some code onto hpaste and let us look at it?
02:00:49 <cjs_> Ok.
02:03:33 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5836
02:03:43 <cjs_> Oops, sorry about anonymous.
02:04:24 <cjs_> I feel like I need something like runTestTT that is just a counts, rather than IO counts, so I can use a do.
02:09:13 <yondalf> what is Counts?
02:09:36 <yondalf> @src ExitCode
02:09:36 <lambdabot> data ExitCode = ExitSuccess | ExitFailure Int
02:10:10 <cjs_> data Counts = Counts { cases, tried, errors, failures :: Int }
02:12:09 <hpaste>  yondalf annotated "(no title)" with "try this" at http://hpaste.org/5836#a1
02:17:57 <cjs_> Ok, I think I'm starting to get it. For some reason I was thinking that "runTestTT tests" and "do runTestTT tests" were different.
02:18:31 <yondalf_> cjs_: sorry i had internet connection problems, if you still have issues please repost your questions
02:18:37 <cjs_> But of course it's just doing the =>> thing or whatever it is.
02:18:53 <wagle_home> do x = x
02:19:00 <cjs_> I'm ok for the moment; I just need to hack away for a bit.
02:19:06 <wagle_home> do x ; y = x >> y
02:19:37 <wagle_home> do a <- x ; y = x >>= \a -> y
02:19:38 <wagle_home> etc
02:28:34 <NiggPlz> hello
02:28:37 <NiggPlz> longcat is long
02:28:48 <NiggPlz>   |  #    # |
02:28:48 <NiggPlz>   \     @   |
02:28:48 <NiggPlz>    \   _|_ /
02:28:48 <NiggPlz>   |_____   \   \__/
02:28:48 <NiggPlz>    |    \__/
02:29:49 <NiggPlz>    |       |
02:29:49 <NiggPlz>    |       |
02:29:49 <NiggPlz>    |       |
02:29:49 <NiggPlz>    |       |
02:29:49 <NiggPlz>    |       |
02:29:49 <NiggPlz>    |       |
02:29:51 <NiggPlz>    |       |
02:34:59 <mauke> NiggPlz: are you an ``expert programmer''?
02:35:14 <lenbust> so, I'm reading http://cale.yi.org/index.php/How_To_Use_Monad_Transformers but feel at loss when it comes to newtyping LightRef
02:35:16 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
02:35:40 <lenbust> I apparently need something which 'builds a lightref in the io monad', but I don't really know how to do that
02:35:52 <hpaste>  cjs annotated "(no title)" with "(no title)" at http://hpaste.org/5836#a2
02:36:15 <cjs_> That's the next question.
02:36:30 <cjs_> Just a syntax issue, I think.
02:38:47 <dobblego> what's a lightref?
02:39:04 <lenbust> dobblego: it's a type from the example
02:39:26 <dobblego> oh, didn't see that
02:39:32 <cjs_> Basically, I can't figure out how to do multiple lines after the "in" in "let ... in".
02:40:39 <cjs_> Or even one line; every time I add the let ... in I get "The last statement in a 'do' construct must be an expression".
02:41:30 <yondalf_> let ... in can only be followed by one expression, maybe you should use the where clause
02:41:52 <yondalf_> (someone correct me if i'm wrong)
02:44:52 <hpaste>  cjs pasted "awkward nested ifs" at http://hpaste.org/5837
02:45:20 <cjs_> More directly, that does what I want; how do I make it pretty?
02:47:33 <hpaste>  dolio annotated "awkward nested ifs" with "guards" at http://hpaste.org/5837#a1
02:50:08 <cjs_> Thanks!
02:50:35 <dobblego> why would haddock only be generating a document containing data types and constructors, when data type constructors are not exposed unless otherwise explicit (right?) and why don't I see my functions?
02:51:55 <cjs_> Actually, the exitWith can be extracted outside the case, too.
02:52:30 <dolio> Well, true. I'm not sure that will look nicer, though.
02:52:38 <dolio> It might if you split the case into an auxillary function.
02:54:55 <hpaste>  dolio annotated "awkward nested ifs" with "another alternative" at http://hpaste.org/5837#a2
02:55:43 <dolio> With a better name than "foo" of course.
02:56:47 <cjs_> Yeah, I like the idea of extracting a method.
02:57:10 <dolio> Yeah. I'm not a big fan of 'case' myself.
02:59:13 <cjs_> Feels kinda schemey to me, though it seems Haskellers don't use it much.
02:59:56 <cjs_> For something like this, what are the other options? functions defined with pattern matching?
03:00:39 <dolio> Well, you can't do ranges with pattern matching. You need to use guards.
03:00:51 * LOOOOOOOOOONGCAT is LOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOONG
03:01:07 <dolio> @seen Cale
03:01:08 <lambdabot> Cale is in #haskell, #haskell-overflow, #ghc and ##algorithms. I last heard Cale speak 3h 9m 45s ago.
03:02:12 --- mode: ChanServ set +o xerox
03:03:13 <cjs_> What's the type of "any integer"?
03:03:22 --- mode: xerox set -b *!*n=sdasd@193.186.177.*
03:03:26 <mauke> (Integral a) => a
03:03:34 <cjs_> Thanks.
03:03:49 --- mode: xerox set +b *!*@*.net.novis.pt
03:03:55 <integral> just: Integer is sufficient to represent any integer
03:03:56 <kosmikus> calvins: (lhs2TeX) %include forall.fmt
03:03:58 --- kick: LOOOOOOOOOONGCAT was kicked by xerox (xerox)
03:04:03 --- mode: xerox set -o xerox
03:04:07 <cjs_> Oops, ExitFailure takes an Int, anyway.
03:04:46 <dolio> Ban list full again?
03:05:14 <hpaste>  cjs annotated "awkward nested ifs" with "(no title)" at http://hpaste.org/5837#a3
03:05:14 <xerox> yes
03:05:23 <mauke> lenbust: newtype LightRef = LightRef (IORef Lamp)
03:05:25 <dolio> Seems to happen a lot lately.
03:05:28 <dobblego> heh, #scala had its first troll the other day - yay!
03:05:29 <cjs_> There's mine. That's a better extraction.
03:07:49 <cjs_> Gotta go. Thanks for all the help!
03:17:01 --- mode: ChanServ set +o glguy
03:17:23 --- mode: glguy set -b *!*@*.160.144.36.cable.dyn.cableonline.com.mx
03:18:26 --- mode: glguy set -b *!*@77-56-70-119.dclient.hispeed.ch
03:19:20 --- mode: glguy set -o glguy
03:19:34 <glguy> all of these people can't possibly be trying to rejoin and hassle the channel..
03:28:22 <hpaste>  Radoslaw Grzank pasted "HDBC relations" at http://hpaste.org/5839
04:01:06 <FesteringHate_> Hello.
04:04:01 <glguy> quit
04:04:57 <hpaste__> New paste: test paste for announce
04:05:09 <glguy> quit
04:12:05 <smg> hello.
04:12:35 <smg> two questions for understanding: return isn't the return as in imperative languages, it will produce a value from an "action".
04:12:48 <smg> second one: the bracket construct is like a try/catch/finally block.
04:12:50 <smg> ?
04:13:14 <ivanm> smg: 1st: yes
04:13:31 <ivanm> return will encapsulate a value into the particular monad being used
04:13:39 <ivanm> second: which bracket construct?
04:13:57 <smg> http://darcs.haskell.org/yaht/yaht.pdf <-- page 74
04:14:11 <wagle_home> do { foo ; baz -- join: Saul_ (n=Saul@s5593c8c6.adsl.wanadoo.nl) joined #haskell
06:11:28 <ea`> what the hell?!
06:11:56 <ea`> Control.Exception.catch worked
06:12:04 <ea`> what does catch-in-the-prelude do?!
06:12:28 <Syzygy-> :t Prelude.catch
06:12:31 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
06:13:05 <Syzygy-> It handles an IO error.
06:13:08 <Syzygy-> :t throw
06:13:08 <ea`> :t Control.Exception.catch
06:13:09 <lambdabot> Not in scope: `throw'
06:13:09 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
06:13:20 <ea`> jeebus
06:13:34 <ea`> that's a newbie trap right there
06:13:35 <desegnis> Prelude.catch only catches IOErrors, while C.E.catch catches anything from an exception over an »error« error to a failing pattern match (I think)
06:14:34 <Toxaris> ea`: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Acatch says: Non-I/O exceptions are not caught by this variant; to catch all exceptions, use catch from Control.Exception.
06:14:35 <lambdabot> http://tinyurl.com/ovjef
06:15:41 <ea`> yup, that solves it :) thanks all
06:15:58 * SamB wonders why google thinks that he got referred to his google.code project page by http://google.com/intl/en/options/ ...
06:15:58 <lambdabot> Title: More Google Products
06:16:09 <SamB> google analytics, that is...
06:20:57 <Lemmih> Has QuickCheck2 been released?
06:27:52 <desegnis> Lemmih, if it's not on Hackage, ...
06:29:50 <smg> haha i'm right in the middle of that social network class diagramm. is this good or bad? :)
06:34:23 <desegnis> heh, thanks for drawing my attention to it
06:35:29 <desegnis> @seen haskellsocialnet
06:35:30 <lambdabot> haskellsocialnet is in #haskell. I don't know when haskellsocialnet last spoke.
06:35:52 <desegnis> hm, i'd be interested in the time span for that diagram
06:48:10 <ea`> does (:[]) have a name?
06:48:26 <opqdonut> return :P
06:48:35 <tuukkah> =)
06:48:50 <ea`> ah :)
06:55:50 <Heffalump> that's a name for something more general
06:56:02 <Heffalump> I often call it wrap, but it's not defined in any standard library
06:56:45 <roconnor> I thought it was called monster
06:57:12 <desegnis> singleton?
06:57:28 <desegnis> make-singleton-list would be too long, namely
06:57:52 <roconnor> > let monster = (:[]) in showS "grrrr!" monster
06:57:56 <lambdabot>   Not in scope: `showS'
06:58:01 <roconnor> > let monster = (:[]) in shows "grrrr!" monster
06:58:02 <lambdabot>  Couldn't match expected type `String'
06:58:22 <roconnor> oh right
06:58:37 <roconnor> my bad
06:58:46 <roconnor> funny how the type system catches errors.
06:59:17 <vininim> who would guess.
06:59:41 <dolio> I thought it was there just to keep you from doing 'exploratory programming.'
07:48:33 <faxathisia> @free f :: a -> (b -> a) -> b
07:48:33 <lambdabot> g . k = p . h => h (f x k) = f (g x) p
07:49:53 <dolio> @djinn a -> (b -> a) -> b
07:49:53 <lambdabot> -- f cannot be realized.
07:51:41 <dolio> @djinn Not a -> (b -> a) -> b
07:51:42 <lambdabot> -- f cannot be realized.
07:52:02 <dolio> @djinn Not a -> (b -> a) -> Not b
07:52:02 <lambdabot> f a b c = a (b c)
07:52:35 <faxathisia> heh
07:52:45 <faxathisia> f a b = \c -> a (b c) -- easier to read
07:55:38 <dolio> Man, lambda cube doesn't have an infinite hierarchy of sorts.
07:55:52 <faxathisia> pure type systems does
07:55:56 <faxathisia> can do*
07:56:14 <dolio> Agda seems to.
07:56:15 <faxathisia> http://www.rbjones.com/rbjpub/logic/cl/tlc004.htm
07:56:15 <lambdabot> Title: Pure Type Systems
07:56:43 <dolio> At least 100, from what I've checked.
07:56:45 <faxathisia> yeah I think it's extended(?) calculus of constructions
07:57:14 <faxathisia> well
07:57:23 <roconnor> ah rbjones... the site that looks like it is written by a crackpot, but turns out to actually make sense.
07:57:34 <faxathisia> if you have Type : Type then you get inconsistency
07:57:40 <faxathisia> because you can type Y combinator
07:58:01 <faxathisia> but if you have  Type[i] : Type[j] where i < j .. I think we're ok again
07:58:20 <dolio> Uh oh:
07:58:24 <roconnor> faxathisia: does Girard's Paradox lead to a Y combinator. ... maybe it does.
07:58:33 <roconnor> or a Yish combinator.
07:58:35 <dolio> Main> :typeOf Set183438485839434873 ==> Set-1164422022
07:58:49 <faxathisia> roconnor, that's the impression I got from An Analysis of Girards Paradok
07:58:54 <dolio> Guess they weren't expecting that.
07:59:30 <roconnor> faxathisia: I guess fixpoints are abou the only way for a paradox to manifest itself.
07:59:44 <faxathisia> actually yeah, It's wrong for me to say Y combinator
07:59:50 <faxathisia> that's a bad habit of mine
08:00:07 <faxathisia> it's just a term that has type (a -> a) -> a
08:00:38 <roconnor> faxathisia: I vaguely recall it yeids a sequence of combiniators that it reduces through; which yields the same effect as a Y combinator.
08:00:46 <faxathisia> yeah
08:01:22 <roconnor> faxathisia: well all paradoxes yeild a term of type forall a. a, by definition
08:01:37 <roconnor> faxathisia: it is the reduction behaviour of these terms that is interesting.
08:09:13 * faxathisia takes another go at trying to understand the typechecking code for Agda ..
08:10:51 <faxathisia> Hi alpheccar! I enjoyed reading your posts
08:11:41 <alpheccar> hi! thank you. I am experimenting IRC on an iPhone
08:13:11 <ehird> alpheccar: 3rd-party apps?
08:13:12 <ehird> i.e. not net
08:13:17 <ehird> if so, i suggest Colloquy
08:13:28 <ehird> [15:58]  <faxathisia> but if you have  Type[i] : Type[j] where i < j .. I think we're ok again          <-- um, godel?
08:13:57 <faxathisia> not sure what you mean ehird
08:14:04 <alpheccar> ehird : I am using colloquy. it works great !
08:14:44 <ehird> alpheccar: yes
08:15:04 <ehird> alpheccar: install the terminal. then you can use bitchx, or irssi
08:15:08 <faxathisia> I think it should actually be Type[i] : Type[i+1]
08:15:27 <ehird> once i actually, using ..whatever the worse-than-EDGE is, ssh'd in to my VPS, and ran irssi there
08:15:33 <roconnor> faxathisia: Coq has Type[i] : Type[j] where i < j
08:15:50 <roconnor> so terms don't quite have unique types.
08:15:54 <alpheccar> ehird : I'll test
08:16:06 <faxathisia> ok http://coq.inria.fr/V8.1pl3/refman/Reference-Manual006.html#Cic-inductive-definitions
08:16:07 <lambdabot> Title: Calculus of Inductive Constructions, http://tinyurl.com/34ua9f
08:16:12 <faxathisia> like the rule there Ax
08:16:19 <ehird> alpheccar: colloquy sometimes dies when you home-button though
08:16:43 <ehird> iphone software is generally just not as polished as mac software, unfortunately.
08:16:48 <alpheccar> ehird : not yet experimented it :)
08:17:13 <ehird> i'd use an s60 phone if it wasn't pig-ugly and didn't have a qwerty kb :p
08:17:13 <faxathisia> yeah one thing I have still not figured out is the meaning of Prop in Agda 2
08:17:21 <ehird> the browser is based on webkit which is cool
08:17:53 <dolio> faxathisia: I think it says on the wiki somewhere that it used to be identical to Set.
08:18:00 <faxathisia> oh :/
08:18:02 <faxathisia> that sucks
08:18:03 <alpheccar> ehird : is there hugs or nhc98 for iPhone or I have to build one ?
08:18:26 <dolio> And was just for distinguishing proofs from actual computational content.
08:18:30 <faxathisia> dolio, It would be nice if you could use Prop to separate logical objects from computational one
08:19:08 <faxathisia> because you could have anything in Prop erased at compile time.. but then you couldn't say, recurse on a proof term if it was in Prop
08:19:15 <dolio> But I think they're not interchangeable anymore.
08:19:29 <faxathisia> but I had trouble using Prop for anything with it
08:19:33 <ehird> alpheccar: it won't build, i don't think.
08:19:40 <ehird> well
08:19:49 <ehird> does nhc98 compile to ARM?
08:20:02 <ehird> actually - a better question is: does ghc?
08:20:03 <dolio> There's a lot about Agda that doesn't seem to be documented anywhere.
08:20:06 <ehird> ghc would be infinitely more useful than either of those
08:20:20 <dolio> For instance, if you read the string libraries.
08:20:28 <faxathisia> dolio, I don't think anyone is supposed to be using it yet :P
08:20:34 <dolio> :)
08:20:56 <pejo> dolio, have you seen Norell's thesis?
08:21:15 <alpheccar> ehird : I'll have to look at it. I'd like to have haskell on my phone (I am crazy)
08:21:22 <faxathisia> Data.String? what about it
08:21:34 <dolio> I think I saw it mentioned on the mailing list, but I haven't read it.
08:22:26 <ehird> alpheccar: Hey, I wanted to write an iPhone code editor at one point.
08:22:30 <ehird> Then get a gcc toolchain on to it..
08:22:40 <ehird> So you could write an iPhone app, on the iPhone.
08:22:47 <ehird> Then I wanted to port SBCL to it, because that's either to port than e.g. ghc.
08:23:04 <dolio> faxathisia: "postulate String : Set" ... "primitive primStringAppend ..."
08:24:00 <ehird> strings aren't sets?!
08:25:38 <dolio> faxathisia: Data.Sets, too "abstract postulate Set-decSetoid : DecSetoid"
08:27:16 <dolio> Oh, I guess abstract is on the wiki.
08:28:08 <Cin> http://www.haskell.org/cabal/hackage/
08:28:09 <lambdabot> Title: Hackage
08:28:10 <faxathisia> I think postulate is just saying, this is an axiom
08:28:11 <Cin> anyone responsible for this page?
08:28:21 <Cin> it comes up as the first link for "hackage", and redirects to nonsense
08:28:56 <pejo> Cin, talk to dcoutts about it
08:29:07 <Cin> will do
08:29:16 <dcoutts> @arr!
08:29:16 <lambdabot> Arrr!
08:29:37 <smg> @foo
08:29:38 <lambdabot> Maybe you meant: faq ft todo yow
08:29:43 <pejo> dcoutts, like you were waiting for us to mention you!
08:30:30 <dolio> faxathisia: Yeah, I get what it means, more or less. But you won't find it without reading the standard library.
08:30:58 <faxathisia> I'm trying to understand the haskell implementation
08:31:04 <faxathisia> It's very difficult code though
08:31:31 <dcoutts> pejo, Cin: what should I do with that page? just delete it?
08:31:53 <dcoutts> pejo, Cin: I didn't really realise that page existed. We link to hackage on the cabal homepage
08:32:25 <hysterio> noob question here... how do i print something with type IO String? ie. iostringfunc = return "hello". How can i separate IO from the String?
08:33:13 <faxathisia> :t let iostringfunc = return "hello" in iostringfunc
08:33:16 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
08:33:26 <dcoutts> pejo, Cin: seems to me I should just rm -rf that hackage subdir, it's totally useless. Seem ok, or any better ideas?
08:33:29 <kpreid> hysterio: you don't, you execute it
08:33:37 <kpreid> hysterio: iostringfunc >>= putStrLn
08:33:48 <kpreid> or, equivalently, do x <- iostringfunc; putStrLn x
08:33:59 <faxathisia> > let iostringfunc = return "hello" in do x <- iostringfunc ; x
08:34:00 <lambdabot>  "hello"
08:34:40 <kpreid> faxathisia: huh, lambdabot got an identity monad gimmick?
08:35:12 <pejo> dcoutts, either that or put in a redirect from there to the right place I guess. I just pointed Cin to you though. :-)
08:35:14 <hysterio> i see.. because im having problems on 'putStr mapping' something of type IO [String]
08:35:18 <smg> uhm is literate style good?
08:35:41 <kpreid> hysterio: mapM_ putStr thing
08:35:56 <hysterio> oooh
08:35:57 <kpreid> :t mapM_
08:35:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:35:58 <faxathisia> hysterio, do strings <- something ; mapM putStr strings
08:35:59 <hysterio> thanks!
08:36:00 <kpreid> :t mapM_ putStr
08:36:00 <dcoutts> hysterio: or putStr (concat things)
08:36:01 <lambdabot> [String] -> IO ()
08:36:21 <faxathisia> :t (>>= mapM putStr)
08:36:22 <lambdabot> IO [String] -> IO [()]
08:36:30 <faxathisia> oops I meant mapM_
08:36:34 * dcoutts prefers combining pure values and passing them to an IO function rather than mapping IO over pure things and combining the IO actions
08:36:45 <faxathisia> :t (>>= (mapM . putStr))
08:36:46 <lambdabot>     Couldn't match expected type `a -> m b'
08:36:46 <lambdabot>            against inferred type `IO ()'
08:36:46 <lambdabot>     Probable cause: `putStr' is applied to too many arguments
08:36:51 <dcoutts> ie mapM_ putStr things vs  putStr (concat things)
08:36:57 <kpreid> dcoutts: good point
08:37:10 <kpreid> :t putStr . fmap concat
08:37:10 <lambdabot>     Couldn't match expected type `Char' against inferred type `[a]'
08:37:10 <lambdabot>       Expected type: [[[a]]] -> String
08:37:10 <lambdabot>       Inferred type: [[[a]]] -> [[a]]
08:37:14 <faxathisia> dcoutts, why?
08:37:23 <faxathisia> I don't see any advantage to either
08:37:27 <kpreid> :t putStr . liftM concat
08:37:27 <lambdabot>     Couldn't match expected type `Char' against inferred type `[a]'
08:37:27 <lambdabot>       Expected type: [[[a]]] -> String
08:37:27 <lambdabot>       Inferred type: [[[a]]] -> [[a]]
08:37:31 <dcoutts> faxathisia: less IO
08:37:37 <hysterio> haskell makes my head hurt, now its gone. thanks guys for the fast help. =)
08:37:38 <taruti> :t putStr . concat
08:37:39 <lambdabot> [[Char]] -> IO ()
08:37:39 <faxathisia> is that good?
08:38:00 <dcoutts> faxathisia: keeping IO in as small a part of your prog as possible is good
08:38:03 <kpreid> @pl \x -> putStr =<< liftM concat x
08:38:03 <lambdabot> (putStr =<<) . fmap join
08:38:13 <kpreid> ick
08:38:19 <ddarius> kpreid: faxathisia's example was using the list monad
08:39:26 <kpreid> ddarius: ...oh. ook.
08:39:51 <kpreid> I was reading it like the last statement was "return x"
08:40:15 <kpreid> whereas it was actually join (return "hello")
08:40:22 <kpreid> the whole example, I mean
08:40:40 <ddarius> Yeah
08:41:02 <ddarius> join . return being, of course, id
08:43:51 <kpreid> (except for a type restriction)
08:43:56 <kpreid> :t join . return
08:43:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
08:44:12 <kpreid> hm
08:44:14 <kpreid> :t ($)
08:44:14 <lambdabot> forall a b. (a -> b) -> a -> b
08:44:29 <kpreid> same form as for ($) = id
08:45:03 <kpreid> ...but then, *any* restriction of id will have that form, so that's not especially interesting.
08:47:56 <Cin> ddarius: sorry about that... for some reason my nick isn't being highlighted (thanks, irssi!). i think a redirect to the hackage page is a good solution
08:48:41 <roconnor> @src ($)
08:48:42 <lambdabot> f $ x = f x
08:48:58 <Cin> whoops
08:49:01 <Cin> dcoutts: !
08:49:32 <lekro> hi. how can I provide an additional include path for C headers in the configure step of a cabal install? I'm trying to compile HOpenGL but my opengl headers are in a non-standard location
08:56:07 <cinema> JaffaCake: ping
09:04:19 <pejo> lekro, perhaps one of the environment variables CFLAGS or CPPFLAGS? Someone had a feature request for that in cabal recently iirc.
09:09:49 <dcoutts> Cin: I've no idea how to set up redirects
09:10:05 <dcoutts> Cin: much easier to delete it :-) then google will not find it
09:11:18 <Cin> dcoutts: do you want a link of code to do it?
09:12:03 <Cin> <meta http-equiv="refresh" content="0;url=http://hackage.haskell.org/">
09:12:11 <dcoutts> Cin: only if it's a proper http redirectm like in a .htthing file, not a silly html one
09:12:29 <Cin> dcoutts: oh, k
09:13:13 <dcoutts> Cin: don't worry about it, google will soon notice that the page has disappeared
09:15:24 <lekro> pejo: CFLAGS="-I/.../" convinces the configure part but then Setup.hs build fails with "error: GL/glu.h: No such file or directory"
09:19:30 <dcoutts> lekro: Cabal does not use any additional enc vars like that
09:19:35 <dcoutts> enc/env
09:19:44 <dcoutts> lekro: there's an open ticket on this issue
09:20:01 <lekro> is there a workaround for now?
09:20:04 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/221
09:20:06 <lambdabot> Title: #221 (need a way to specify site-specific include and library search paths) - Ha ...
09:20:11 <dcoutts> lekro: modify the .cabal file
09:20:54 <dcoutts> btw, if any #haskeller wants a short task that'd be really useful, ticket #221 should be pretty easy
09:21:56 <chessguy> ooh, i have an idea for a new monad tutorial! monads as jquery commands!
09:22:18 <lekro> dcoutts: thanks
09:23:15 <awesame> like probably every other haskell noob, I secretly feel that with a little thought I could explain monads to non-haskellers far better than all of the existing tutorials
09:24:07 <awesame> but I'm pretty sure that's why there are so many lousy monad tutorials out there
09:24:43 <chessguy> awesame, i know that feeling. then you go to actuall write monadic code and wind up just scratching your head
09:26:57 <faxathisia> :t (<$>)
09:27:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:27:28 <faxathisia> :t traverse
09:27:29 <lambdabot> Not in scope: `traverse'
09:27:41 <resiak> :t (<*>)
09:27:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:27:57 <resiak> :t ap
09:27:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:28:33 <resiak> ap == <*> for monads?
09:28:53 <faxathisia> @instances Applicative
09:28:53 <lekro> what is ghci trying to tell me with this error: module main:Graphics.Rendering.OpenGL is not loaded
09:28:54 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
09:28:56 <lekro> I wrote :m + Graphics.Rendering.OpenGL
09:29:18 <faxathisia> lekro, I think still, the module main doesn't have it
09:29:23 <lekro> it's not "Could not find module ..."
09:29:33 <faxathisia> lekro, so maybe you need an import in the .hs file
09:29:34 <lekro> faxathisia: yea, but what does that mean?
09:29:49 <lekro> I don't have a .hs file
09:29:51 <lekro> just ghci
09:30:12 <faxathisia> that's strange then..
09:30:16 <faxathisia> Prelude> :m + Graphics.Rendering.OpenGL
09:30:17 <faxathisia> Prelude Graphics.Rendering.OpenGL>
09:30:20 <faxathisia> This is what I get.
09:30:30 <lekro> yes, that's also what I get on my Mac
09:30:41 <lekro> but on the linux machine I get this strange error
09:30:53 <faxathisia> maybe your ghc doesn't have this HOpenGL library?
09:30:54 <Cale> awesame: Do what I did, and instead target your tutorial at all the people who might write monad tutorials without getting the big picture yet.
09:31:03 <awesame> ha
09:31:04 <faxathisia> you could try to recompile with it
09:31:12 <awesame> Cale: I'd like to see that tutorial!
09:31:17 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
09:31:18 <lambdabot> Title: Monads as computation - HaskellWiki
09:31:19 <kpreid> lekro: try ghci -package OpenGL (iirc)
09:31:42 <allbery_b> ghci should automatically be in --make mode so that should not be needed
09:32:09 <kpreid> I think I've met odd cases where you have to prespecify, but I forget what it was
09:32:12 <allbery_b> what did you do that got that message?  I have  avague recollection that that error really means you're trying to do something requiring interpreted code to a compiled module
09:32:23 <lekro> kpreid: now ghci loads the package OpenGL-2.2.1.1 but still complains about the module
09:32:25 <Cale> awesame: I see a lot of tutorials which don't really explain how monads really differ from other combinator libraries, and don't really point out what advantage there might be to recognising something as a monad.
09:32:44 <kpreid> lekro: try using a compiled program instead of ghci
09:34:26 <awesame> Cale: I definitely see a lot of blog posts explaining how to use monads, or how to implement them, without trying to explain why they're interesting
09:34:49 <lekro> Graphics/Rendering/OpenGL/GL/BasicTypes.hs:24:1:
09:34:49 <lekro>     lexical error at character 'i'
09:35:01 <lekro> when I do "ghc --make Test.hs"
09:35:10 <lekro> this doesn't look too good :/
09:35:46 <ddarius> awesame: Read Wadler's papers.
09:35:46 <Cale> awesame: It gets worse when you start to see implementations of "monads" in other languages. It's not impressive to just implement, say, the Maybe and State monad without actually making them work together.
09:37:10 <lekro> line 24 is #include "HsOpenGLConfig.h" in the original source file
09:37:22 <faxathisia> type a :<-: b = b -> a
09:37:25 <cschneid> I am looking to build a bloom filter as my project for the day.  Basically I need to hash a whole bunch of words and insert them into a list, will using an immutable list be stupidly slow (copying the whole thing with each word inserted), or does that get optimized out?  Alternatively, is there a better data structure for me to look at?
09:37:49 <awesame> ddarius: I've read a couple.  I should just buy a bunch of printer paper and print myself up a Wadler papers collection.
09:37:51 <dcoutts> lekro: sounds like you're building a test prog inside the OpenGL src tree, so ghc tries to use the local .hs files rather than the installed package.
09:38:06 <lekro> dcoutts: oh, thanks
09:38:09 <ddarius> awesame: Which couple?
09:38:25 <faxathisia> better.. type a :- b = b -> a -- -XTypeOperators
09:38:36 <dcoutts> lekro: if you've got the opengl package installed already then either don't build test progs inside the root of the opengl src tree, or use ghc -i --make Test.hs   the -i clears the search path, removing even '.' from it.
09:38:48 <arussel> Hi, I was asking about book about haskell yesterday. I started reading A gentle introduction to haskell. Are all book about haskell that hard ? I am just a java programmer and didn't get half of what the guy is talking about.
09:39:03 <awesame> ddarius: I forget.  one was about type classes and java generics
09:39:10 <allbery_b> lekro: if you really need that you need the -cpp option
09:39:15 <awesame> I remember liking them a lot
09:39:18 <lekro> interesting, ghc --make Test.hs works and the program runs
09:39:34 <allbery_b> arussel: "Gentle Introduction" is generally considered the *least* gentle introduction, actually
09:39:39 <ddarius> awesame: Read the ones on monads.  In particular, either "The essence of functional programming" or "Monads for Functional Programming"
09:40:07 <od> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
09:40:07 <awesame> oh, I think I started Monads for Functional Programming
09:40:15 <awesame> maybe that was the other one I read
09:40:18 <od> should be easy to understand
09:40:28 <allbery_b> arussel: try YAHT, or the Haskell WikiBook
09:40:32 <awesame> I should go back to it, obviously, since I don't seem to remember much
09:40:52 <arussel> what about: Programming in Haskell (Paperback) ? the amazon review seems ok.
09:41:06 <od> "Yet another Haskell tutorial" is much better than "gentle intro" imo
09:41:07 <hpaste>  faxathisia pasted "left arrow" at http://hpaste.org/5841
09:41:43 <faxathisia> actually (f . g) x = f (g x) is nicer
09:42:09 <noige_> hi
09:42:19 <sfultong> good day
09:43:42 <sfultong> in gtk2hs, what is the bool that event handlers return?  Is this indicate whether the event should be propagated to parent widgets?
09:44:05 <dcoutts> sfultong: propagated to other handlers
09:44:23 <sfultong> dcoutts: thanks
09:44:24 <dcoutts> sfultong: since you can connect multiple handlers and many widgets have a default handler that does some default action
09:44:32 <roconnor> dcoutts: does your IRC client ding when people say gtk2hs?
09:44:46 <arussel> od: looks really good, thanks.
09:44:52 <dcoutts> roconnor: sssh, don't tell them than :-)
09:45:05 <roconnor> oh ok. :|
09:45:15 * sfultong promises not to abuse it
09:45:18 * chessguy makes a note of that
09:45:24 <dcoutts> he heh
09:47:00 <faxathisia> foo = k x  where  k = f . g . h -- I think this is better than f . g . h $ x ?
09:47:29 * allbery_b used to have "perl" as a highlight
09:47:40 <allbery_b> someday I'll re-add it... when I can limit what channels it applies to
09:51:30 <noige_> This is like learning math
09:51:41 <noige_> you need to learn addition before dividing etc
09:53:16 <noige_> listSum :: [Integer] -> Integer ---- The former reads: listSum is a function who takes a list of Integers as arguments and returns an Integer. Is that correct?
09:53:45 <faxathisia> Yes
09:53:48 <mauke> yes, except s/who/that/
09:54:03 <noige_> mauke: oh ok hahah
09:54:27 <faxathisia> (It's correct but I read it as, listSum has-type [Integer] -> Integer)
09:54:36 <noige_> mauke: thanks, I am finally understanding this type casting business
09:54:49 <faxathisia> there is no casting
09:55:14 <noige_> o.O
09:55:29 <faxathisia> what are you referring to when you say type casting?
09:55:39 <noige_> wait
09:55:43 <noige_> you are totally right
09:55:48 <noige_> actually
09:55:55 <noige_> that just set off a light bulb
09:56:12 <sfultong> light bulbs are fun
09:56:15 <noige_> I keep thinking in terms that I am used to thinking in
09:56:21 <mauke> Ｅｎｌｉｇｈｔｅｎｍｅｎｔ
09:56:31 <Cale> DR.16
09:57:01 <smg> mauke: are you also in #perl?
09:57:04 <smg> hi Cale :)
09:57:05 <mauke> smg: yes
09:57:12 <Cale> hello
09:57:12 <smg> ah i knew i know you :)
09:57:30 <Cale> Where do you know me from?
09:57:49 <sfultong> Cale: nice blog about Monad Transformers... I haven't finished reading it, but I expect it's of your usual high quality
09:57:54 <radix> wow, this font renders fullwidth latin really strangely.
09:57:54 <LoganCapaldo> hmmm there sure are a lot of dynamically typed people in here, considering this is haskell
09:58:05 <smg> Cale: you answered me yesterday haskell questions :]
09:58:09 <faxathisia> dynamically typed .. people!?
09:58:11 <Cale> ah, okay :)
09:58:13 <ddarius_> LoganCapaldo: They're recovering
09:58:46 <mauke> <CanyonMan> Hey there, I've caught myself a perl programmer!  Watch what happens when I stick my thumb up his bum! Crikey! He's gone open source!
09:59:36 <LoganCapaldo> is it too soon for a manta (sting?) ray joke?
09:59:36 <smg> lol
10:00:10 * sfultong is thinking about making a haskell library to make all builtin types members of a "dynamic" class so that they can all be converted between each other :)
10:00:20 <mauke> http://u.nix.is/irwin.gif (NSFW (or humanity))
10:00:22 <sfultong> hahaha!  take that, static typing
10:00:38 <gwern> LoganCapaldo: jokes about Steve Irwin were only too soon when he was born. he was a living joke
10:00:38 <mauke> sfultong: what, like Typeable?
10:00:42 <LoganCapaldo> import Data.Dynamic
10:00:55 <mauke> :t cast
10:00:59 <LoganCapaldo> dynamic typing is a library in haskell :p
10:01:02 <sfultong> mauke: damn, am I reinventing the wheel again?
10:01:03 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
10:01:03 <sfultong> ah
10:01:13 <faxathisia> not the wheel..
10:01:15 <LoganCapaldo> @hoogle Dyn
10:01:16 <lambdabot> Language.Haskell.TH.dyn :: String -> Q Exp
10:01:16 <lambdabot> Language.Haskell.TH.Lib.dyn :: String -> Q Exp
10:01:16 <lambdabot> Data.Dynamic :: module
10:01:28 <LoganCapaldo> @hoogle fromDynamic
10:01:29 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
10:01:43 <mauke> unsafeCoerce :: a -> b
10:01:58 <LoganCapaldo> unbreakMyHeart
10:02:09 <MyCatVerbs> mauke: aieee, bloody Hell.
10:02:12 <mauke> callCthulhu
10:02:18 <LoganCapaldo> LOL
10:02:19 <gwern> there's one bad thing about contributing to a lot of projects, your spam goes way up
10:02:20 <MyCatVerbs> mauke: I'd expect that sort of evil from, hell, random furries.
10:02:23 <sfultong> mmm... haskell doesn't have enough seg faults...
10:02:39 <LoganCapaldo> @remember  mauke callCthulhu
10:02:40 <lambdabot> Done.
10:02:55 <gwern> unsafeEatSoul :: ElderGod -> Soul -> ElderGod
10:02:57 <faxathisia> MyCatVerbs: furry fish exist?
10:03:04 <SamB> sfultong: Foreign.Ptr isn't good enough for you?
10:03:47 <sfultong> SamB: well, ok
10:03:51 <LoganCapaldo> FFI, safety not guaranteed
10:03:55 <mauke> peek nullPtr
10:03:57 <SamB> well, you could use GHC primitives such as unsafeCoerce# with some Addr#s...
10:04:18 <faxathisia> @index peek
10:04:18 <lambdabot> Foreign.Storable, Foreign
10:04:25 <sfultong> SamB: that's what I was thinking
10:04:39 <faxathisia> Prelude Foreign> peek nullPtr
10:04:39 <faxathisia> zsh: bus error  ghci -- :D
10:04:43 <dons> http://reddit.com/info/69qmw/comments/ awesome. oleg on delimited continuations
10:05:34 <MyCatVerbs> faxathisia: I... don't want to check.
10:07:07 <sfultong> damn, irc is too distracting.
10:10:06 <SamB> Foreign> peek nullPtr :: IO Int
10:10:06 <SamB> Unexpected signal
10:11:26 <smg> eta reduction ftw
10:12:07 <faxathisia> http://lambdadance.spacebar.org/
10:12:08 <lambdabot> Title: lambdadance: \beta-reduce the night away!
10:12:23 <giorgolo> :hoogle sqrt
10:12:37 <smg> @hoogle sqrt
10:12:38 <lambdabot> Prelude.sqrt :: Floating a => a -> a
10:12:57 <smg> Floating /= Float ?
10:13:11 <faxathisia> :t sqrt (2 :: Float)
10:13:15 <lambdabot> Float
10:13:25 <faxathisia> :t sqrt (2 :: Double)
10:13:26 <lambdabot> Double
10:13:41 <faxathisia> @instances Floating
10:13:42 <lambdabot> Double, Float
10:13:52 <monochrom> Human /= monochrom
10:13:57 <faxathisia> why no rational?
10:14:08 <monochrom> rational is no floating
10:14:16 <faxathisia> why?
10:14:25 <mauke> what
10:14:35 <monochrom> @src Floating
10:14:36 <lambdabot> class  (Fractional a) => Floating a  where
10:14:36 <lambdabot>     pi                                                      :: a
10:14:36 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
10:14:36 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
10:14:36 <lambdabot>     (**), logBase                                           :: a -> a -> a
10:14:46 <faxathisia> pi = 22%7 -- :P
10:14:48 <monochrom> You want sin of rational?
10:14:53 <faxathisia> yes
10:14:57 <mauke> pi = 3%1
10:15:20 <monochrom> well that's absurd IMO
10:15:20 <faxathisia> well it sort of makes sense
10:15:27 <SamB> > toRational pi
10:15:29 <faxathisia> there's no way to specify the precision
10:15:30 <lambdabot>  884279719003555%281474976710656
10:15:36 <Cin> can i import two modules as one namespace?
10:15:55 <faxathisia> maybe..
10:16:09 <faxathisia> instance Floating [Rational]...
10:16:16 <Cin> ie Database.HDBC and Database.HDBC.Sqlite3 i may want to import as just DB
10:16:17 <smg> so Floating = Superclass of Float and Double and a Subclass of Num ?
10:16:19 <faxathisia> pi = [3%1, 22%7, ...]
10:16:19 <smg> am i right?
10:16:34 <smg> Cin: you can
10:16:37 <mauke> no, Float and Double aren't classes
10:16:48 <smg> ah okay
10:16:53 <smg> mauke: types?
10:17:01 <mauke> yes; they're instances of Floating
10:17:06 <mauke> not subclasses
10:17:34 <smg> ah
10:17:41 <smg> so Floating has more than one constructor?
10:17:48 <mauke> huh?
10:18:02 <mauke> what does it mean for a class to have a constructor?
10:18:08 <faxathisia> Floating doesn't have any constructors
10:18:13 <faxathisia> It's a typeclass
10:18:24 <faxathisia> @src Float
10:18:24 <lambdabot> data Float = F# Float#
10:18:34 <faxathisia> Float has a constructor though
10:18:37 <smg> ok, i will see later, atm i'm at pattern matching, guess classes should come next
10:18:59 <tuete> Hmm, having read http://www.haskell.org/pipermail/haskell/2004-August/014463.html, i wonder if this is actually used by anyone craving for ML-style modules. At least it is reassuring that one could unleash that power. ^^
10:19:00 <lambdabot> Title: [Haskell] Applicative translucent functors in Haskell
10:19:02 <faxathisia> smg: Here is a simple example of type classes
10:19:08 <faxathisia> > show (3 :: Int)
10:19:10 <lambdabot>  "3"
10:19:17 <faxathisia> > show ("foo" :: Int)
10:19:18 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
10:19:20 <faxathisia> > show ("foo" :: Strinc)
10:19:21 <lambdabot>   Not in scope: type constructor or class `Strinc'
10:19:21 <faxathisia> > show ("foo" :: String)
10:19:22 <lambdabot>  "\"foo\""
10:19:23 <mauke> > show "foo"
10:19:24 <lambdabot>  "\"foo\""
10:19:37 <mauke> > show ('x', (), [1,2,3.5])
10:19:38 <lambdabot>  "('x',(),[1.0,2.0,3.5])"
10:19:46 <faxathisia> smg: There is a type class Show which has (among others) the method show :: a -> String
10:19:56 <dons> tuete: have you seen the more recent papers comparing modules to type classes?
10:19:58 <faxathisia> smg: and there is an instance of show for the types Int and String
10:20:03 <smg> i see
10:20:12 <mauke> a class is an interface
10:21:30 <tuete> dons: i've looked over chakravarty's. is abstype implemented yet?
10:22:14 <dons> tuete: well, associated types are in ghc
10:22:36 <dons> i'm not sure if the abstype stuff got replaced, or not implemented
10:23:08 <SamB> hmm, why does john meacham use that ⑆ symbol from checks in his signature...
10:23:50 <Lemmih> SamB: I don't deserve a kudos for my work on conjure or jhc? (:
10:24:30 <SamB> Lemmih: of course not! actually, I just haven't gotten to it yet
10:24:36 <tuete> dons: and what about oleg's hackery, isnt it practical?
10:26:15 <dons> often not. do you need functors for something, or just wondering?
10:27:36 * SamB wonders if he should forward his UNIX mail to gmail or not
10:27:41 <Heffalump> what's abstype?
10:28:29 <tuete> well, im curious and could envision some use
10:29:30 <giorgolo> @instances Num
10:29:32 <lambdabot> Double, Float, Int, Integer
10:32:04 <SamB> hey, when did I move up to 8
10:32:05 <SamB> ?
10:34:54 <tuete> Heffalump: abstract associated type synonyms are an extension of associated type synonyms regarding per-instance scope of type synonyms
10:35:31 * LoganCapaldo blinks
10:35:33 <tuete> Heffalump: the type synonym is only visible within the instance then
10:35:43 * LoganCapaldo is glad his name isn't heffalump
10:36:04 <ddarius> LoganCapaldo: Why is that?
10:36:28 <LoganCapaldo> cause then I'd have to figure out what was just said :p
10:36:46 <tuete> hehe
10:36:52 <SamB> it made perfect sense to me
10:38:30 <monochrom> LoganCapaldo: the measure of a countable set is 0 because for all e>0 the measure is <= sum e/2^(-n) = e.
10:39:13 * LoganCapaldo hides
10:41:46 <Cale> Wha? Measure theory?
10:43:32 <roconnor> Would you say ``A uniformly continuous function'' or ``An uniformly continuous function''?
10:44:12 <dcoutts> roconnor: the first
10:44:21 <roconnor> yeah, it sounds right, but looks wrong.
10:45:04 <roconnor> dcoutts: does your IRC client ding whenever someone writes ``uniformly continuous function''?
10:45:18 <dcoutts> roconnor: hah hah, no. :-)
10:45:59 * dcoutts pushes Cabal patch to read .cabal files in UTF8
10:46:46 <giorgolo> :t filter
10:46:48 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:47:08 <Cale> That would be awesome.
10:47:29 <Cale> (if your client dinged whenever someone said "uniformly continuous function"
10:47:31 <Cale> )
10:48:18 <olsner> hmm, does cabal-install take a special flag to install docs for packages?
10:49:14 <dcoutts> olsner: if you'd like to implement that we'd all appreciate it, I think there's an open ticket
10:49:19 * dcoutts finds said ticket
10:50:00 <dcoutts> olsner: http://hackage.haskell.org/trac/hackage/ticket/206
10:50:03 <lambdabot> Title: #206 (cabal-install should be able to generate haddock docs) - Hackage - Trac
10:50:22 <monochrom> SamB: I think the ⑆ seen in John Meacham's messages is due to encoding mismatch, i.e., he posts using one encoding, probably properly declared in header too, but a recipient or archiver presumes another encoding and messes up.
10:50:50 * monochrom thinks iso-8859-1 should die die die
10:52:51 <skorpan> :t nub
10:52:53 <lambdabot> forall a. (Eq a) => [a] -> [a]
10:53:44 <skorpan> :i nub
10:53:58 <skorpan> no?
10:54:09 <Lemmih> no.
10:55:28 <ddarius> iso-8859-1 thinks monochrom should die die die
10:55:43 <monochrom> haha
10:58:05 <jleedev> > forever Nothing
10:58:11 <lambdabot>  Nothing
10:58:15 <skorpan> Just Nothing
10:58:19 <olsner> hmm, I really need cabal uninstall to test this though :P
10:58:24 <skorpan> Maybe Maybe Int
11:01:04 <piojo> hi, everyone. since I've discovered how easy/nice haskell arrays are, are ST and State mostly just useful for algorithms that can't be rewritten recursively?
11:01:23 <SamB> ST and State are quite different
11:01:34 <ddarius> And recursion has nothing to do with it
11:01:41 <monochrom> I use ST and State for recursive algorithms all the time.
11:02:12 <monochrom> Moreover, if an algorithm can't be rewritten recursively, it can't be written period.
11:02:18 <piojo> i must be thinking about this wrong... couldn't one put any necessary state information in an array, and just modify it with (//) when needed?
11:02:25 <piojo> i must not understand what State/ST are for...
11:02:37 <monochrom> (//) may be slow.
11:03:10 <jleedev> > runST $ newSTRef 1 >>= \r -> forM_ [1..n] (modifySTRef r . (*)) >> readSTRef r
11:03:11 <piojo> does // make a copy of the whole array, or is the copy lazy in a "write on need" sort of way?
11:03:12 <lambdabot>   Not in scope: `readSTRef'
11:03:13 <oerjan> State alone does not give you fast mutable arrays
11:03:14 <dons> ?users
11:03:14 <lambdabot> Maximum users seen in #haskell: 471, currently: 448 (95.1%), active: 20 (4.5%)
11:03:19 <Lemmih> piojo: Updating an immutable array make a completely new copy.
11:03:25 <monochrom> "mutable state" is an optimization and does not exist in physics.
11:04:05 <SamB> piojo: ST is for when you want to use algorithms that must mutate in order to perform the way you'd like
11:04:07 <roconnor> monochrom: copying state doesn't exist in physics either.
11:04:14 <piojo> Lemmih: but is the new copy lazy or optimized to take advantage of the values that have not been changed?
11:04:15 <roconnor> linear logic for everyone!
11:04:33 <monochrom> I agree.
11:04:41 <monochrom> Hell, "state" does not exist.
11:05:05 <SamB> anno's math games includes a tutorial on linear logic, does it not?
11:05:08 <roconnor> I'm fairly sure state exists.
11:05:15 <jyp> I don't exist.
11:05:18 <jleedev> I think we need to rethink our concept of what a "paradigm" is.
11:05:34 <oerjan> piojo: ordinary arrays are not optimized for copying.  DiffArrays would be, except the thread locking kills the performance
11:05:43 <piojo> i see
11:07:03 <piojo> most algorithms don't really need mutation. like quicksort, for example. it just happens to really suck without it... is State/ST really just an efficiency thing, then?
11:07:25 <monochrom> ST is.
11:07:26 <piojo> (for example, it's easy to write data structures that are simply copied every time they are changed)
11:07:28 <oerjan> piojo: ST.  State is not relevant to this.
11:07:40 <piojo> oerjan: oh. okay, thanks
11:07:41 <monochrom> State is for convenience and saving writing.
11:07:42 <SamB> State is an abstraction
11:07:47 <SamB> you can write State yourself
11:09:19 <piojo> one last question... if an algorithm is written to use an array, is it generally very simple to change it to use ST?
11:09:28 <monochrom> Yes.
11:09:31 <piojo> yay!
11:09:48 <piojo> okay, thanks, everyone. this cleared things up for me =)
11:09:53 <SamB> it depends on the situation and desired level of ST use
11:10:04 <piojo> i see
11:10:36 <dolio> ST is around so that you don't have to throw your algorithms that use mutability into IO.
11:10:59 <dolio> So you can be sure that your in-place quicksort doesn't launch missiles.
11:11:58 <monochrom> I think the more common problem with sorting algorithms is they swear at you for giving them a hard time.
11:12:06 <SamB> but sorting incorrectly, well, that you need to avoid
11:12:17 <SamB> because if you do that you might launch the missles wrong
11:12:22 <piojo> ST provides an interface for mutability from the inside, but looks purely functional from the outside, right?
11:12:34 <monochrom> Yes.
11:12:58 <dons> yep. so you can do local mutations, and ensure those effects aren't visible to the rest of the program
11:13:38 <piojo> good. i've wanted that several times
11:14:13 <dons> well, its pretty rarely needed, i've found. usually there's a pure structure with no mutation that's more flexible.
11:14:35 <dons> but it definitely has its uses
11:14:56 <araujo> hello
11:17:10 * araujo loves Haskell
11:17:24 <TomMD> Hello araujo
11:17:29 <araujo> hi TomMD
11:17:47 <TomMD> Have you picked up Haskell recently or are you an old hand?
11:17:56 <araujo> it's impressive how you can introduce quick changes into such a big code
11:18:08 <gnuvince_> :t pseq
11:18:10 <lambdabot> forall a b. a -> b -> b
11:18:13 <gnuvince_> :t par
11:18:14 <lambdabot> forall a b. a -> b -> b
11:18:20 <araujo> TomMD, an old hand I'd say :-)
11:18:27 <olsner> argh, so I need darcs cabal in order to work on darcs cabal-install
11:18:50 <Cale> Man the Project Euler people are unhappy with the Haskell Wiki :)
11:18:58 <ddarius> Why?
11:19:07 <mrd> answers posted i gues
11:19:08 <SamB> giving away the answers, no doubt
11:19:10 <Cin> heh, because the point of project euler is to figure things out
11:19:12 <Cale> Because it contains solutions to all/most of the problems.
11:19:37 <Cale> However, they do raise a good point that people have contributed C++ solutions there. We should replace them with Haskell code.
11:20:25 <olsner> we have C++ solutions to euler problems on the haskell wiki?
11:20:28 <Cale> yes
11:20:52 <Cale> Also, we have a *ton* of really poorly formatted Haskell code.
11:21:04 <piojo> i must say that as a beginner, i like the solutions. i don't read them, but i really like to know they are there
11:21:05 <TomMD> And pages that don't link together well
11:21:27 <Cale> Yeah, it would be nice to have next/previous links.
11:22:01 <piojo> the existence of solutions means that if i can't figure out how something can be elegantly done, i can give up and look it up
11:22:10 <dobblego> is there any way around requiring an explicit type signature on functions for haddock to generate doc for them? Can I put the signatures in the export list or something?
11:22:25 <ddarius> Cale: What do they care if people look up the answers instead of figuring it out?  It doesn't hurt or even affect them.
11:22:37 <Cale> I know. Apparently they do though.
11:23:01 <dobblego> ddarius, it devalues the achievement for others who do not cheat
11:23:11 <ddarius> dobblego: How?
11:23:12 <oerjan> which reminds me, the <haskell> formatting bug in the Nonogram page that i pointed out is still there
11:23:18 <Cale> It's really stupid. If you want to hold a contest where nobody will be able to look up the solutions to problems, write up a bunch of problems that nobody has seen before, and hold the contest all at once.
11:23:44 <Cale> If you publish problems, people will pretty inevitably publish solutions to them, and there's really nothing which you can do about it.
11:23:46 <dobblego> ddarius, because if I cheat, I get a record against my name as having achieved it; others who did not cheat are then ripped off
11:23:57 <ddarius> dobblego: How?
11:24:13 <dobblego> ddarius, because the distinction between achievement and cheating is not there
11:24:19 <Cale> dobblego: Yes it is.
11:24:31 <Cale> dobblego: The only person you're cheating by looking at the solutions is yourself.
11:24:52 <dobblego> Cale, some people care about having a little green circle (or whatever it is) against their name
11:24:56 <Cale> (That is, you're cheating yourself out of an interesting problem)
11:25:09 <dobblego> that too
11:25:13 <Cale> dobblego: And they can have that green circle.
11:25:15 <blargeyfarg> project euler really is about testing one's self.  it's a non issue how any one else is performing relative to you
11:25:29 <piojo> Cale: I like to think that people who look up solutions have already found they can't solve it, and they are not doing anything wrong by looking up an answer
11:25:34 <dobblego> Cale, they can't attribute value to that circle anymore
11:25:49 <piojo> Cale: i mean, they aren't even cheating themselves
11:25:49 <Cale> dobblego: Then maybe they should get a better value system.
11:25:53 <ddarius> dobblego: They never should have been attributing value to a green circle to begin with.
11:26:01 <dobblego> Cale, sure, but you can say that about anything
11:26:20 <Cale> dobblego: They should be attributing value to their own ability to solve the problem, not to the recognition for it.
11:26:23 <Cin> they're interesting to read after you've came up with your own solution
11:26:27 <dobblego> some people attribute value to the size of their motor vehicle
11:26:41 <noige_> hmm
11:26:57 <noige_> so it seems that the . means to compose
11:27:00 <noige_> is that right?
11:27:04 <Cin> yes.
11:27:05 <dobblego> noige_, yes
11:27:06 <ddarius> @src (.)
11:27:06 <lambdabot> (.) f g x = f (g x)
11:27:24 <noige_> so if I have two functions fun and gun I can (fun . gun) args ?
11:27:30 <dobblego> yes
11:27:31 <noige_> it seems so
11:27:34 <noige_> ahhh ok
11:27:45 <monochrom> gun is not fun
11:27:51 <TomMD> A "society" like Project Euler should just be problems that haven't been solved before....
11:27:51 <TomMD> > take 1 [(a,b,c,n) | a <- [3..], b <- [3..], c <- [3..], n <- [3..] , a^n + b^n == c^n]
11:27:55 <Cale> In fact, I think Project Euler would be much more fun and much more aptly named if it put, say, the first 5 solutions on the same page as the problem, with the authors' names, and published *much* harder problems.
11:27:56 <noige_> gun is gun
11:28:00 <lambdabot> Terminated
11:28:50 <BMeph> monochrom: If you think "gun is not fun," then you don't have the right gun... ;)
11:28:53 <Cale> (Like, ones which nobody knows the solution to, for example.)
11:28:56 <noige_> hahhaah
11:29:07 <ddarius> How 'bout they just check your answers and don't keep track of which you've solved
11:29:39 <blargeyfarg> or how about they continue to keep track, and everyone stop caring who else has solved it
11:30:09 <Cale> Euler was a serious mathematician, perhaps the greatest mathematician of all time, and I don't think the problems are hard enough to really deserve his name.
11:30:28 <monochrom> My impression is that Project Euler is largely used for pissing games among newbies of languages.
11:30:45 <BMeph> Cale: So, "projectgauss.net"? ;)
11:31:12 <Cale> projecteuler.org ? :)
11:31:16 <Cale> hehe
11:32:08 <blargeyfarg> my impression was that it was just good fun and a mentally rewarding excersize in on'e spare time.  are people really this uptight about using it competitively?
11:32:18 <Cale> blargeyfarg: Apparently so :)
11:32:23 <BMeph> Although, "projectgauss.net" sounds like something associated with EM weapons.
11:32:34 <blargeyfarg> wow
11:32:43 <dobblego> can a module have an excluding export list rather than including?
11:32:56 <Cale> blargeyfarg: The problems are so silly, and yet people resent others publishing solutions to them.
11:32:56 <ddarius> dobblego: No
11:33:42 <Cin> i find the problems quite hard
11:33:43 <monochrom> Some people take Project Euler as a programming contest, not unliked topcoder.
11:34:07 <monochrom> and not unlike http://acm.ashland.edu/
11:34:09 <BMeph> blargeyfarg: "My dad can beat your dad!" "Oh yeah? Well, my projecteuler score is bigger than your projecteuler.net score!" ;p
11:34:09 <lambdabot> Title: The 2007 ACM-ICPC ECNA Regional Programming Contest
11:34:24 <monochrom> err excuse, http://online-judge.uva.es/problemset/
11:34:28 <lambdabot> Title: online-judge.uva.es - PROBLEM SET ARCHIVE
11:34:32 <olsner> hmm, heh, haddock requires haddock to build docs
11:34:38 <blargeyfarg> monochrom: "contest" implies the rules and structure required for ranking.  i just figured, by the very nature of the site's layout and  use, that it didn't qualify
11:35:59 <blargeyfarg> silly me
11:36:00 <monochrom> ISTR Project Euler website does scoring of sorts or close enough to be indistinguishable from scoring.
11:36:07 <Cin> olsner: the haddock program requires the haddock library?
11:36:46 <oerjan> monochrom: isn't it just a progress meter, really?  number of problems solved?
11:37:08 <blargeyfarg> oerjan: that's what i thought.  i didn't think it was any more sophisticated than that
11:37:10 <Cale> oerjan: Some people take progress meters *very* seriously.
11:37:11 <olsner> Cin: no, only building the docs for anything (including haddock) requires haddock to already be installed before trying
11:37:21 <monochrom> You can't control users' interpretations.
11:37:31 <ddarius> @google progressquest
11:37:32 <lambdabot> http://www.progressquest.com/
11:37:32 <lambdabot> Title: Progress Quest
11:37:32 <Cale> oerjan: In case you haven't noticed, the entire idea of many MMORPGs is based on this.
11:37:45 <blargeyfarg> ddarius: now THAT's a game!
11:38:05 <oerjan> i guess.  although i have never played a MMORPG.
11:38:07 <Cin> olsner: requiring haddock to build haddock documentation makes sense?
11:38:24 <monochrom> You publish a meter, people take it as scoring.  You have scoring, people take it as a contest.  You don't have formal contest rules?  People take it to mean your contest rules are immature but still contest rules.
11:38:45 <mrd> woot, progress quest
11:38:53 <olsner> yes, but I just realized why simply adding haddock as a required build step in cabal-install was a bad idea
11:39:05 <blargeyfarg> monochrom: i follow the logic... i'm just in denial as to the state of humanity... <sigh>
11:39:18 <monochrom> I am with you about humanity.
11:39:20 <Cin> olsner: what are you doing?
11:41:16 <gwern> @pl  unsafeAccumArray f int lu ies = runST $ withNewArray lu int $ doAccum f ies
11:41:17 <lambdabot> unsafeAccumArray = (((runST .) .) .) . flip (flip . ((.) .) . flip withNewArray) . doAccum
11:41:38 <mauke> runST $?
11:41:38 <mrd> runST like that is bad
11:41:45 <mrd> it has a rank-2 type
11:42:08 <mrd> just use parentheses
11:42:25 <gwern> but that's the same thing as $ no?
11:42:32 <mauke> no
11:43:02 <oerjan> monochrom: so the solution is to have a formal contest rule that says cheating is permitted :D
11:43:15 <dolio> It works since they added impredicative instantiation.
11:43:23 <mrd> i thought that was retracted
11:43:28 <dolio> Was it?
11:43:48 * gwern notes that both the $ and () versions seem to compile fine
11:44:12 <dolio> Seems to work here on 6.8.2.
11:44:38 <monochrom> IMO if Project Euler changes to forum form, people will interpret it very differently and much more solving-and-learning-oriented.
11:44:49 <oerjan> i heard rumors that it was retracted, but those were already before the 6.8 release
11:45:12 <monochrom> Here are my reasons.
11:46:01 <Cin> monochrom: i'd like it to be more like that. sometimes i have no idea where to start on a problem at all (commonly due to a kind of math that i don't understand being present in the problem), and it would be nice to get pointers and such
11:46:02 <monochrom> For a user's own sake:  You can choose to see solutions posted in the forum, or you can choose not to, or you can choose how much effort you put in before you do.  In any case you learn something eventually.
11:48:18 <monochrom> From a cultural POV:  A forum feels very different from a contest website.  (There is still an ongoing contest among those who like contests, but now it's a completely different kind.)
11:48:52 <SamB> ugh, I hates forums
11:49:11 <monochrom> (The new contest is: how many novel and good solutions I have posted to the forum, and what is my reputation.  I.e., forum esteem metric.)
11:50:00 <Cin> monochrom: perhaps another factor could be a poster's helpfulness
11:50:02 <gwern> @pl modifyURef  ref f  =  readURef ref >>= writeURef ref ○ f
11:50:02 <lambdabot> (line 1, column 55):
11:50:02 <lambdabot> unexpected "\151"
11:50:02 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<" or end of input
11:50:12 <gwern> @pl modifyURef  ref f  =  readURef ref >>= writeURef ref . f
11:50:12 <lambdabot> modifyURef = ap ((.) . (>>=) . readURef) ((.) . writeURef)
11:50:34 <SamB> monochrom: you forgot "how many posts can you post"
11:51:13 <Cin> samb: well, i think that is similar to reddit. you can post a tonne of messages but if they are all garbage, it's not very impressive
11:51:14 <monochrom> From psychology:  Somehow, even if you extremely love to cheat, you are still unlikely, somehow, to cheat on a forum in public.  This is because this time "cheating" means you re-post a posted solution.  Well, somehow you feel awkward and silly to copy a post and post it again.
11:51:24 <blargeyfarg> SamB: and you forgot the third party site that gets started the next day that aggregates everyone's score into a ladder ranking by number of problems solved ;)
11:51:45 <SamB> Cin: well, it depends on what metrics are conveniently displayed next to your posts...
11:52:33 <mauke> monochrom: http://dis.4chan.org/read/prog/1201786636
11:52:35 <lambdabot> Title: 4chan BBS - LISP [part λ f x. f (f x)]
11:52:38 <monochrom> So it's a forum culture.  There is contest but now a collaborative and reputation kind.  Solutions are published, so plagiarism feels awkward and people don't tend to do it.
11:52:40 <SamB> okay, who do I go to to report DNS abuse?
11:53:13 <SamB> my ISP just served me search results instead of returning a DNS error!
11:54:14 <oerjan> you sure that was not your browser doing it?
11:54:20 <Cin> mauke: >>999 cracked me up
11:54:24 <monochrom> I think there was no DNS error.  The typoed name is indeed registered and pointed to whichever website you are seeing.
11:54:38 <SamB> oerjan: it had my ISPs logo at the top!
11:55:21 <SamB> oh, apparantly it can be turned off
11:55:24 <TomMD> SamB: Did they serve you up any scripts/malware too?
11:55:44 <SamB> eh... it uses a cookie???
11:55:50 <sioraiocht> @src shows
11:55:50 <lambdabot> Source not found. I feel much better now.
11:56:28 <oerjan> shows         = showsPrec 0
12:08:40 <olsner> dcoutts: getting cabal to run haddock before installing wasn't too hard, but I found a few caveats... notably my current patch requires you to have haddock installed before installing anything :P
12:12:10 <Cin> olsner: is this so that cabal runs haddock to produce documentation when installing anything?
12:12:12 <gwern> @pl indexUnboxed (UVec arr) index  =  cast (at arr (fromI# index))
12:12:12 <lambdabot> (line 1, column 32):
12:12:12 <lambdabot> unexpected "="
12:12:12 <lambdabot> expecting variable, "(", operator or end of input
12:12:21 <olsner> Cin: yep
12:12:26 <Cin> olsner: ohhh. cool
12:13:15 <blargeyfarg> are there any cryptography libraries available?  general purpose hashing, symmetric encryption, etc.
12:13:20 <Cin> olsner: i get what you mean now about haddock requiring itself to be installed ;)
12:13:37 <dons> blargeyfarg: check on hackage.haskell.org
12:13:48 <dons> there's several crypto libs, hopenssl, some other bindings
12:14:14 <Cin> anyone got a firefox engine for hoogle?
12:14:21 <blargeyfarg> ahh... found Crypto under Data.... was ignorantly looking under Cryptography ;)
12:14:34 <Cin> [search] engine, that is
12:14:40 <bparkis> why does agda need data types separate from functions?  why not express data types using functions?
12:14:59 <Cin> oh, disregard that!
12:15:01 <dons> blargeyfarg: for performance, hopenssl might be a better choice. depends on what you're aiming to do
12:15:12 <gwern> bparkis: hey, how did you install agda?
12:15:19 <bparkis> i haven't installed it, why?
12:15:27 <Cin> awesome. a hoogle engine
12:16:12 <gwern> oh. I assumed if you were asking about it you were using it
12:16:15 <blargeyfarg> dons: i'll keep that in mind, although at the moment i'm just in need of hashing
12:16:36 <gwern> anyone want to try cabal install ArrayRef-0.1.2? I cleaned up most of the warnings
12:16:58 <bparkis> no i'm just learning about it
12:20:11 <dons> blargeyfarg: oh, you just want md5 or sha?
12:21:22 <blargeyfarg> dons: sha
12:22:30 <hpaste>  smg pasted "stupid calculator" at http://hpaste.org/5842
12:24:47 <dobblego> @seen bos
12:24:48 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 12h 58m 17s ago.
12:25:26 <astrolabe> If I repeatedly need a context with a multi-parameter type class for which some of the parameters are datatypes, is there a way not to have to repeat the long context?
12:26:26 <roconnor> Do we have type class synonyms yet?
12:26:51 <roconnor> I suppose there is always the C pre processor.
12:26:59 <EvilRanter> don't think so, but you can bodge it with -XUndecidableInstances
12:27:22 <astrolabe> EvilRanter: Could you say a little more please?
12:27:34 <astrolabe> also, a bit less evil would be nice ;)
12:28:16 <EvilRanter> class (context context context) => ShorterSynonym type type type
12:28:47 <EvilRanter> which'd be a bit shorter if the types appear repeatedly in the context
12:28:58 <astrolabe> EvilRanter: Thanks very much.
12:29:09 <EvilRanter> just out of curiosity, can we see your context?
12:29:27 <astrolabe> I don't think it'll mean much, but...
12:29:49 <astrolabe> MapLike map key (LGraphNode key label payload)
12:30:14 * astrolabe is making tangled code :(
12:30:39 <roconnor> that's not so big. :)
12:30:59 <EvilTerran> if there's dependencies there, you could possibly leverage them to make the alias even shorter
12:31:22 <oerjan> smg: putStr $ show tempy; putStrLn "" = putStrLn $ show tempy = print tempy
12:32:00 <astrolabe> EvilTerran: There are dependencies:  class MapLike map key elt | map -> key, map -> elt
12:32:09 <smg> oerjan: i know :)
12:32:15 <smg> ty for your answer
12:33:04 <EvilTerran> astrolabe, i believe you can re-phrase that as "map -> key elt"
12:33:17 <Lemmih> astrolabe: How about using associated types?
12:33:24 <gio123> is there definition for set valued functions ?
12:33:53 <Lemmih> astrolabe: class MapLike map where type Key map; type Elt map
12:34:04 <oerjan> also most of the operator do blocks could be using a common function doOper op temp mydigit = ...
12:34:27 <gio123> is there definition of derivative for set valued functions
12:34:28 <astrolabe> I'm really confused about this stuff
12:35:15 <wy> Are the grammars that can be recognized by Parsec LL(k) with k>1 or just LL(1) ?
12:35:29 <oerjan> (actually you only need op to be an argument if you put that in a let inside the large do block
12:35:33 <oerjan> )
12:36:07 <oerjan> wy: without try, LL(1).  with try, just about anything.
12:36:13 <EvilTerran> wy, do you mean without try? i think it's LL(*) with it
12:36:18 <EvilTerran> er, higher than LL(*), even
12:37:31 <wy> oerjan: try? I haven't used that before. I just read Wadler's and Simon's papers about parser combinators. Is try something more than that?
12:37:34 <olsner> with try it's capable of arbitrary backtracking, meaning it can match context-sensitive or even unrestricted grammars, right?
12:38:03 <oerjan> wy: try allows backtracking past more than a single token
12:38:20 <oerjan> (usually a Char)
12:39:12 <Toxaris> I think that Parsec can be used as a general stream interface, ignoring all the parser combinator stuff, just accessing the underlying stream and parsing with normal Haskell function. ergo, Parsec can parse everything Haskell can parse.
12:40:04 <wy> oerjan: I need to look at the documentation, but currently I've learned something like alternation and sequencing from the old papers. Are they enough to do arbitrary lookahead?
12:40:31 <oerjan> wy: Parsec does alternatives a bit different, for efficiency.
12:40:59 <oerjan> it usually discards the other alternatives as soon as one of them consumes a character
12:41:04 <wy> oerjan: I feel as if sequencing combinator can be used to do arbitrary lookahead. Is that true?
12:41:24 <oerjan> wy: i am not familiar with those old names
12:41:38 <wy> oerjan: Let me look up the documentation...
12:42:48 <oerjan> but Parsec definitely can do arbitrary lookahead if you use try (which turns off the discarding of other alternatives until the current one has been completely successful)
12:43:48 <oerjan> however even with that, Parsec still has less backtracking than the ReadS parsers, which can backtracking to try more alternatives for a subparser that has already succeeded.
12:43:49 <wy> oerjan: I see the documentation says that try is for the left recursion problem
12:43:59 <oerjan> huh?
12:44:06 <wy> oerjan: sequencing is just what the monad is doing
12:44:14 <oerjan> Parsec documentation?
12:44:30 <wy> yes
12:44:49 <wy> "Unfortunately, it is not always possible to left-factor the grammar and in many other cases the grammar becomes more complex to understand. There is a primitive combinator called try that handles these cases in an elegant manner."
12:45:01 <olsner> wow, parsec has documentation now?
12:45:14 <EvilTerran> it's had it for ages
12:45:14 <wy> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
12:45:19 <oerjan> olsner: there's always been the manual
12:45:28 <EvilTerran> just not in haddock form
12:46:21 <wy> I'm quite tired of Java CUP. LALR(1) is really terrible. So I guess I would write a parser combinator library for Java and use it for my assignment
12:46:25 <oerjan> wy: heh, i suppose that's one way of thinking of try
12:46:45 <wy> oerjan: That's a good idea. It can make life much easier
12:46:47 <dobblego> wy, there is a good parser library for Kind-Of-Java (Scala)
12:47:23 <SamB> olsner: yes, since forever
12:47:33 <ivan_> if i have a monad type ErrorT q (StateT r IO) a which gives me IO(Either q a,r) as result, can i make an instance of IO somehow to declare how the output should be outputed ?
12:48:10 <oerjan> wy: btw try wouldn't be necessary to avoid left-factoring if it weren't for the fact <|> is predictive (throws away alternatives quickly)
12:48:37 <wy> The length lookahead is what really matters. I guess many simple grammars are not LR(1). What I have now has many instances that require LR(2)
12:48:41 <oerjan> also this left-factoring isn't the same as left recursion.  Parsec handles that in a different manner, using the chainl combinator
12:49:15 <dons> ?users
12:49:15 <lambdabot> Maximum users seen in #haskell: 471, currently: 446 (94.7%), active: 23 (5.2%)
12:49:22 <dons> so anyone starting some cool project this weekend?
12:49:28 <wy> oerjan: So I guess the infinite lookahead didn't come with try, but with the monad itself?
12:50:14 <wy> dobblego: Isn't Scala kinda functional lang? I guess I can't use it in java
12:50:32 <dobblego> wy, kind of yes, and you can certainly use it in Java
12:50:35 <cjb> dons: I've beet thinking about using Haskell to model Bugs Everywhere (written in Python) with quickcheck tests.
12:50:46 <oerjan> wy: it comes with try.  without try you couldn't go back again if the lookahead failed.
12:51:35 <cjb> the model wouldn't have to be specific to Bugs Everywhere; a list of invariants for a bugtracker and a testsuite for them in BE.
12:51:37 <oerjan> wy: Scala compiles to jvm code though
12:51:48 <Toxaris> oerjan: but parse and >>= is enough to write try, isn't it?
12:51:54 <dons> cjb: sounds cool. to test python code?
12:52:24 <wy> oerjan: What if I left factor by hand ?
12:52:30 <cjb> dons: yes
12:53:24 <wy> oerjan: I'm not familar with scala yet. So I guess I would stick to ugly CUP or spend sometime writing a poor man's combinator library
12:53:31 <oerjan> Toxaris: er, perhaps.  i am not sure parse preserves enough of the internal state in its result.
12:53:53 <dobblego> wy, it's just Java not-so-retarded and already comes with a well-written parser library (by Odersky et. al.)
12:54:36 <wy> dobblego: Does it do proper tail recursion?
12:54:46 <dobblego> wy, to some degree
12:54:52 <oerjan> wy: you don't want to left-factor by hand unless your grammar is quite simple.
12:55:02 <dobblego> wy, non-Sun JVMs do it too
12:55:22 <wy> oerjan: I think so. It's just a course project
12:55:56 <wy> oerjan: so-called IC (Irish Caffee), a subset of Java
12:56:49 <dons> cjb: yeah, that would be awesome. i've been for ages pushing the idea that QC should be used to test other languages robustly
12:57:04 <dons> use the type system of haskell to state properties about the types of values you test other languages with
12:57:22 <wy> I would prefer a compiler for Scheme for a first compiler course
12:59:10 <gnuvince_> dons: how would that work?
13:01:02 <ivan_> i want to output IO (Either q r,a) diffrent the the standard IO outputs it, is it possible to do this?
13:01:46 <gio123> ivan_ : bratko
13:01:48 <gio123> ivan_ : bratko?
13:02:08 <ivan_> what?
13:02:09 <wy> I wonder if there is a good way to get two lookaheads with the help of the lexer. It is ugly, but maybe I should try to make it work first
13:02:19 <gio123> ivan_ : are you ivan bratko?
13:02:21 <oerjan> ivan_: sure you can write your own output functions
13:02:30 <ivan_> nopp
13:02:52 <gio123> ivan_ : ok, he is prolog expert
13:02:56 <alatter> ivan: if you don't care for much formatting, if 'q', 'r' and 'a' are instances of Show, you could just do:  yourCommand >>= print
13:04:14 <ivan_> oerjan: o yea i see what you mean =) thx ill try it
13:08:00 <faxathisia> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
13:08:01 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
13:08:01 <faxathisia> :/
13:08:24 <faxathisia> why is tCheckRed not defined?
13:08:57 <faxathisia> It's probably just tCheck then beta reduce..
13:09:19 <wy> faxathisia: oh I didn't know that augustss has a blog
13:11:11 <ivan_> alatter: if i want to make a function fun :: Int -> IO Int is there any function :: a -> IO a ?
13:11:31 <Toxaris> ivan_: return
13:11:37 <faxathisia> (It's defined here http://www.augustsson.net/Darcs/LambdaCube/CubeExpr.hs )
13:11:37 <ivan_> :) o yea
13:17:20 <wy> Barendregt...
13:17:41 <Cin> wy: what does that mean?
13:17:44 <oerjan> now, now, there is no reason to swear
13:17:48 <ddarius> @google Barendregt
13:17:50 <lambdabot> http://www.cs.ru.nl/~henk/
13:17:50 <lambdabot> Title: Homepage Henk Barendregt
13:18:10 <gio123> @google omanadze
13:18:11 <lambdabot> No Result Found.
13:18:12 <Cin> love the picture
13:18:17 <gio123> @google dundua
13:18:18 <lambdabot> No Result Found.
13:18:36 <gio123> @google putin
13:18:36 <lambdabot> http://en.wikipedia.org/wiki/Vladimir_Putin
13:18:50 <oerjan> @google "omanadze"
13:18:51 <lambdabot> No Result Found.
13:19:00 <gio123> @google knuth
13:19:01 <lambdabot> http://www-cs-faculty.stanford.edu/~knuth/
13:19:01 <lambdabot> Title: Don Knuth's Home Page
13:19:19 <oerjan> @google oma-nadze
13:19:21 <lambdabot> No Result Found.
13:19:26 <gio123> @google lambdabot
13:19:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:19:27 <lambdabot> Title: lambdabot
13:19:31 <dobblego> ?hoogle Maybe a -> a -> a
13:19:32 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
13:19:32 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
13:19:32 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
13:19:35 <oerjan> @google omana-dze
13:19:36 <lambdabot> No Result Found.
13:19:48 <oerjan> @google lamb-dabot
13:19:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:19:55 <lambdabot> Title: lambdabot
13:20:17 <gio123> @google oerjan
13:20:18 <lambdabot> http://www.geocities.com/tistelmania/
13:20:18 <lambdabot> Title: New Page 1
13:20:19 <oerjan> hm it may seem that whether it is found depends on the result more than the exact search?
13:20:25 <faxathisia> :t flip maybe . const
13:20:27 <lambdabot> forall a a1. a1 -> a1 -> Maybe a -> a1
13:20:37 <oerjan> o_O
13:20:53 <oerjan> :t fromMaybe
13:20:54 <lambdabot> forall a. a -> Maybe a -> a
13:20:59 <faxathisia> > ((flip maybe . const) "Nothing" "Just something") Nothing
13:21:01 <faxathisia> > ((flip maybe . const) "Nothing" "Just something") Just 1
13:21:02 <lambdabot>  Couldn't match expected type `t -> t1'
13:21:02 <lambdabot>  "Just something"
13:21:12 <faxathisia> humpf
13:21:27 <oerjan> precedence
13:21:38 <noige_> see you in a while
13:21:54 <Cin> > ((flip maybe . const) "Nothing" "Just something") (Just 1)
13:21:55 <lambdabot>  "Nothing"
13:22:25 <Cin> :t ((flip maybe . const) "Nothing" "Just something") Just
13:22:26 <lambdabot>     Couldn't match expected type `Maybe a'
13:22:26 <lambdabot>            against inferred type `a1 -> Maybe a1'
13:22:26 <lambdabot>     In the first argument of `((flip maybe . const)
13:29:14 <Cin> @hoogle Either
13:29:14 <lambdabot> Data.Either :: module
13:29:14 <lambdabot> Prelude.Either :: data Either a b
13:29:14 <lambdabot> Data.Either.Either :: data Either a b
13:29:56 <Cin> i wonder if Either satisfies MonadPlus
13:32:34 <Cin> are there any type synonyms of Either like data Success a = Success a | Fail a, or is that considered lame?
13:33:05 <oerjan> @src Either mplus
13:33:06 <lambdabot> Left _ `mplus` n = n
13:33:06 <lambdabot> m      `mplus` _ = m
13:33:46 <Cin> sexy
13:35:48 <faxathisia> ugh
13:36:00 <faxathisia> I can only have one module in a single .hs file?
13:36:07 <oerjan> afaik
13:36:22 <faxathisia> I guess that saves you typing end <module>
13:36:34 <ddarius> The standard doesn't care, but all the implementations do.
13:36:46 <oerjan> modules are looked up by filename, other than Main
13:36:59 <Cin> i think you would probably just type the next module name as opposed to typing 'end <module>'
13:37:00 <ddarius> faxathisia: You don't need an end module just like you don't need an end do.  The 'where' after the module declaration starts a block of layout.
13:37:11 <dons> gwern: here's one http://www.seas.upenn.edu/~lipeng/homepage/unify.html
13:37:11 <lambdabot> Title: Unifying events and threads
13:37:12 <faxathisia> ahh ok
13:37:53 <tahir_hh> neil ghani: are you there?
13:39:31 <hpaste>  faxathisia pasted "tests" at http://hpaste.org/5843
13:40:01 <faxathisia> so I have to do this to write some test (since I use lots of operators that I don't want to escape)
13:47:35 <stevan> could somebody explain why this doesn't work and what should be done instead:
13:47:40 <stevan> newtype Test a = ErrorT (WriterT [String] (StateT [String] IO) (Either String a)) deriving (MonadState [String], MonadIO, MonadWriter [String], MonadError String)
13:48:33 <Heffalump> put Test (...) round the right hand side
13:48:35 <faxathisia> stevan, are the StateT and Either are the wrong way around?
13:48:51 <Heffalump> I'm guessing you started with type Test a = ..., whcih would have worked but the deriving clause wouldn't have.
13:49:10 <Heffalump> a newtype requires a tag at the data level so the compiler knows when you are using it
13:50:03 <patperry> can anyone explain what unsafeInterleaveIO does?
13:50:04 <dons> ?users
13:50:04 <lambdabot> Maximum users seen in #haskell: 471, currently: 443 (94.1%), active: 13 (2.9%)
13:50:59 <stevan> Heffalump: that gives me an other error: `ErrorT (WriterT [String] (StateT [String] IO) (Either String a))' is not applied to enough type arguments
13:51:06 <chessguy> @type unsafeInterleaveIO
13:51:13 <lambdabot> Not in scope: `unsafeInterleaveIO'
13:51:20 <chessguy> @hoogle unsafeInterleaveIO
13:51:21 <lambdabot> System.IO.Unsafe.unsafeInterleaveIO :: IO a -> IO a
13:51:31 <chessguy> well there you go, what more need be said?
13:51:47 <patperry> is it conceptually the same as forking a new thread and executing the action?
13:52:08 <Cin> > all isAlphaNum "hello"
13:52:10 <Heffalump> stevan: ok, then you need to add an error type argument to it too.
13:52:11 <lambdabot>  True
13:52:16 <Heffalump> I think your brackets are wrong
13:52:28 <Heffalump> but I don't quite understand your type.
13:52:43 <grahamhutton> @users
13:52:43 <lambdabot> Maximum users seen in #haskell: 471, currently: 443 (94.1%), active: 14 (3.2%)
13:52:48 <Heffalump> patperry: I think so, yes.
13:52:51 <faxathisia> Hi grahamhutton :)
13:52:59 <Cin> @pl (\x -> isAlphaNum x || x=='_')
13:52:59 <lambdabot> liftM2 (||) isAlphaNum ('_' ==)
13:53:01 <Heffalump> except if it blocks
13:53:06 <grahamhutton> hi faxathisia!
13:53:10 <ddarius> dons, you've got graham doing it too.
13:53:22 <grahamhutton> :-)
13:53:39 <stevan> Heffalump: but it type checks without the Test (...) and the deriving. :-/
13:53:43 <patperry> I'm trying to understand how hGetContents works, and I don't quite get it
13:53:53 <Heffalump> stevan: and with type instead of newtype, I presume?
13:54:10 <dons> ddarius: hehe
13:54:17 <stevan> Heffalump: yes
13:54:19 <Heffalump> I don't think it should, though. Are you sure you're not getting the brackets wrong at the same time?
13:56:02 <stevan> newtype Test a = Test (ErrorT (WriterT [String] (StateT [String] IO) (Either String a)))
13:56:40 <roconnor> @unmtl (ErrorT (WriterT [String] (StateT [String] IO) (Either String a)))
13:56:41 <lambdabot> err: `ErrorT ([String] -> IO (Either String a, [String], [String]))' is not applied to enough arguments, giving `/\A B. A (Either ([String] -> IO (Either String a, [String], [String])) B)'
13:57:00 <Heffalump> looks like you're missing a lot of type arguments.
13:57:08 <roconnor> that ErrorT needs an argument
13:57:39 <roconnor> @unmtl (ErrorT  (Either String a) (WriterT [String] (StateT [String] IO)))
13:57:40 <lambdabot> err: `ErrorT (Either String a) (WriterT [String] (StateT [String] IO))' is not applied to enough arguments, giving `/\A. [String] -> IO (Either (Either String a) A, [String], [String])'
13:58:03 <roconnor> @unmtl (ErrorT  (Either String a) (WriterT [String] (StateT [String] IO))) z
13:58:04 <lambdabot> [String] -> IO (Either (Either String a) z, [String], [String])
14:00:01 <oerjan> patperry: unsafeInterleaveIO x is an action which returns a result thunk immediately, but which only performs x when the result is actually used
14:00:30 <roconnor> I need a term for ``unstrict inequality''.  I vaguely recall the french had a reasonable sounding term.
14:00:58 <patperry> oerjan: is it the same as return . unsafePerformIO ?
14:01:09 <roconnor> or rathe I need a term for ``less than or equal'' that doesn't have that stupid ``or'' in it.
14:01:55 <chessguy> roconnor, "not greater than"?
14:02:26 <roconnor> chessguy: better, but still ackward.
14:02:32 <dons> Cale: these euler guys are kinda aggressive. are they really doing it for the fun?
14:02:58 <ddarius> :t curry (const True)
14:03:00 <lambdabot> forall a b. a -> b -> Bool
14:03:11 <dons> Cale: i strongly support *not* removing the content. it is vandalism.
14:03:15 <oerjan> patperry: it is somewhat close, i guess.  i think return . unsafePerformIO doesn't guarantee that the action is only performed once, like unsafeInterleaveIO should do
14:03:41 <Cin> @pl all (\x -> x=='_' || isAlphaNum x)
14:03:41 <lambdabot> all (liftM2 (||) ('_' ==) isAlphaNum)
14:03:55 <Cin> > all (liftM2 (||) ('_' ==) isAlphaNum) "hello"
14:04:09 <lambdabot>  True
14:04:38 <patperry> ok, that make sense
14:04:38 <Cin> odd..
14:05:08 <grahamhutton> @seen andyjgill
14:05:08 <lambdabot> I saw andyjgill leaving #darcs, #haskell and #ghc 1d 12h 30m 42s ago, and .
14:05:13 <Cin> i don't have an instance for (Monad ((->) Char)) defined in my ghci =o
14:05:29 <roconnor> Cin: import Control.Monad.Reader
14:05:35 <Cin> roconnor: ah, thankies
14:05:47 <patperry> oerjan: thanks
14:05:59 <Cale> dons: Right, I'm not going to allow anything to be removed without proof that it's copyrighted under a conflicting license.
14:06:31 <dons> yes. if they have some copyright clause, or publishing clause, fine. but this really doesn't seem to be their IP.
14:06:55 <dons> and its futile to squash back channels -- people will be sharing these things all over anyway.
14:06:55 <SamB> are you kidding? you don't even have to send them your code!
14:07:08 <dons> exactly
14:07:10 <SamB> you just send them a number
14:07:46 <dobblego> how have they been aggressive?
14:07:49 <dons> haskell weekly news, http://sequence.complete.org/hwn/20080223
14:07:49 <lambdabot> Title: Haskell Weekly News: February 23, 2008 | The Haskell Sequence
14:08:06 <dons> 100 unique lib/tool updates in 2 weeks. awesome stuff
14:08:42 <Heffalump> so when are you going to change the name from "weekly"? :-)
14:08:57 <SamB> to "whenever"?
14:09:17 <dons> Heffalump: well, hey, got it back to fortnightly
14:11:07 <dons> http://reddit.com/info/69r8e/comments/ awesome banasa
14:11:15 <Heffalump> true :-) I'm not particularly bothered about how often it comes out, I just think the name sounds silly.
14:11:29 <Heffalump> jdh30 seems to have gone quite quiet lately
14:11:50 <dons> i could change it to the Haskell News ?
14:12:01 <Heffalump> or make up something that begins with 'w'
14:12:10 <Heffalump> but no good ideas spring to mind.
14:12:38 <olsner> "user warning: Table './drupalsequence/accesslog' is marked as crashed and should be repaired"
14:14:31 <Lemmih> Heh, hpc and quickcheck are fun. I have 1% test coverage of jhc.
14:14:55 <astrolabe> Did it pass first time?
14:15:30 <Lemmih> No, actually. I found a minor bug.
14:16:12 <astrolabe> :) It sounds doubly useful then.
14:16:33 <dons> Lemmih: cool
14:17:21 <Cin> dmwit: http://reddit.com/info/69jbs/comments/c03954a
14:17:23 <Cale> dobblego: This started a couple weeks ago with one of them simply blanking all the pages.
14:17:24 <Cin> dmwit: made me chuckle
14:17:47 <Cale> dobblego: Since I immediately put the pages back, a bunch of them have started adding complaints to the Talk page.
14:17:49 <dobblego> Cale, oh, so there is no public correspondence? I saw that someone did that
14:17:55 <Cale> http://haskell.org/haskellwiki/Talk:Euler_problems
14:17:57 <dobblego> oh ok, I'll check it out, cheers
14:19:01 <mrd> is there a haskell parser capable of dealing with ghc extensions, besides the frontend of ghc?
14:19:50 <Lemmih> mrd: haskell-src-exts can deal with some extensions.
14:19:54 <dobblego> Cale, be aware that I agree with your position; earlier, I was coming up with the best possible counter-argument I can think of (but reject)
14:21:15 <chadz> anyone have an understanding of "58030 5: Unable to close due to unfinalised statements" in regards to sqlite/Takusen ?
14:21:26 <mrd> Lemmih: thanks
14:22:05 <glguy> chadz: paste the code you are using?
14:22:41 <Heffalump> chadz: not beyond the obvious guess that you are trying to close a database connection but the system won't let you because you didn't finalise some statements you ran on that connection.
14:22:43 <glguy> chadz: I've had / fixed that before
14:23:02 <glguy> Heffalump: more specifically that he didn't use the api in the right order
14:23:14 <glguy> err, used the wrong functions in the api
14:23:38 <glguy> chadz: the hpaste code has takusen example usage in the Storage.hs
14:23:59 <Cin> cale: it doesn't seem that hk is actually reading what you are saying, as his reply to you suggests; you said "Moreover, it doesn't harm anyone's enjoyment of the game. The pages are clearly marked as containing spoilers, and those who don't want to see the spoilers can avoid them quite easily." and then he replied with "But by publishing worked out solutions you are spoiling the fun for those that love to solve problems .."
14:24:05 <glguy> git clone http://code.haskell.org/hpaste    if you are interested
14:24:08 <hpaste>  chadz pasted "sqlite error" at http://hpaste.org/5845
14:24:13 <ehird> Crazy idea: is it possible to skip the typechecker?
14:24:25 <Cale> Cin: That seems quite possible.
14:24:28 <ehird> i.e. either do inference or get a type delcaration, but accept it as true no matter what
14:24:30 <Cin> cale: i think your last comment sums this whole issue up: "If it would spoil the fun, don't look at it. What's your problem?"
14:24:31 <ehird> :D
14:25:09 <glguy> chadz: you shouldn't need to be creating the sql queries through concatenation
14:25:19 <glguy> chadz: that's what bound parameters are for
14:25:26 <faxathisia> ehird, I doubt it, lots of invariants the compiler expects would not hold so it would likely crash before running anything
14:25:29 <dobblego> http://www.haskell.org/haskellwiki/Euler_answers "This page has absolutely nothing to do with Haskell and thus doesn't belong to an Haskell wiki."
14:25:30 <lambdabot> Title: Euler answers - HaskellWiki
14:26:04 <Cale> reverted.
14:26:16 <Cin> an haskell wiki?
14:26:21 * Cin chortles
14:26:32 <faxathisia> why is there a page full of answers?
14:26:40 <glguy> chadz: you don't need to explicit transaction for a single query (addBlog)
14:26:58 <faxathisia> wouldn't haskell code to produce those numbers be more interesting?
14:27:18 <Cin> faxathisia: there is that, as the link suggests
14:27:25 <ehird> faxathisia: Well, if you give it a correct program, it would work brilliantly!
14:27:27 <maskeye> can anyone take a look over here http://hpaste.org/5846, i'm trying to build a package and the georadi bot both complains about missing stuff from the base package :\
14:27:34 <dobblego> I think just the answers are good for helping solve the problem rather than just giving away the solution; a couple of times I was working on a euler problem when I thought "if only I had the answer, I could figure out what I am doing wrong"
14:27:39 <ehird> And you could perhaps make it do weird stuff.
14:27:49 <int-e> It's just taking the confrontation to another level - I don't like that page (the one just listing solutions) either. It's not interesting from a Haskell point of view.
14:28:10 <ehird> http://www.haskell.org/haskellwiki/Euler_answers seems pretty useless
14:28:10 <lambdabot> Title: Euler answers - HaskellWiki
14:28:11 <faxathisia> ehird, I guess you could write a haskel -> lisp compiler
14:28:12 <dobblego> I think it's potentially useful
14:28:13 <ehird> I mean, put it on your own damn page.
14:28:16 <ehird> faxathisia: heh
14:28:23 <faxathisia> then see what the lisp code does
14:28:23 * glguy would prefer to not associate the haskell wiki with cheating
14:28:27 <Zao> There should be a page of non-answers, gotten from common mistakes.
14:28:33 <ehird> glguy: euler isn't really that serious ...
14:28:38 <faxathisia> ehird, yeah it seems useless
14:28:40 <ehird> faxathisia: The point is you could possibly write stuff like 'coerce :: a -> b' without unsafePerformIO
14:28:47 <faxathisia> Does anyone know what the point of it is?
14:28:56 <glguy> ehird: nothing to do with serious, just an embarrassment
14:28:59 <Cin> dobblego: well, i think
14:29:15 <dobblego> Cin, we all think, to some degree :)
14:29:19 <Cin> dobblego: whoops pressed return
14:30:05 <ukl_> hallo. has anybody ever used postmaster for some fancy project? (I think it would be a good starting point for something like IM2000 or other lets-make-email-better approaches...)
14:30:09 <chadz> glguy: I added that transaction just to try and avoid the issue. With or without, it doesnt matter.
14:30:24 <glguy> chadz: is the directory that the database is in writable?
14:30:27 <SamB> int-e: um, isn't that put there by projecteuler?
14:30:34 <yaxu> I'm having problems getting this haskell geometry library working: http://www.dinkla.net/fp/cglib.html
14:30:35 <lambdabot> Title: Library for Geometric Algorithms in Haskell
14:30:53 <chadz> yes
14:30:55 <yaxu> I'm using ghc 6.8.2, it says "Could not find module 'ST'"
14:31:03 <chadz> adduser used to work, let me see if it still does.
14:31:27 <int-e> SamB: I doubt it, if they had their way, there would be no discussion of Project Euler at all on the Haskell Wiki.
14:33:02 <Cin> (==x) . length -- let's say i'm runing this function on an arbitrary length list provided by a user
14:33:14 <Cin> is there a way to express this idea without having to walk the whole list?
14:33:19 <Heffalump> so you want to early out?
14:33:23 <Cin> aye
14:33:26 <Heffalump> is x a constant?
14:33:37 <opqdonut> (==x) . lengt . take x
14:33:43 <Heffalump> oh, cunning.
14:33:45 <opqdonut> :)
14:33:47 <Cin> ahh take. very good
14:33:48 <opqdonut> standard trick
14:33:55 <Heffalump> not standard to me :-)
14:33:56 <Cin> > take 10 [1]
14:33:58 <gwern> @hoogle ST
14:34:02 <lambdabot> Control.Monad.ST :: module
14:34:02 <lambdabot> Data.Array.ST :: module
14:34:02 <lambdabot> Control.Monad.ST.ST :: data ST s a
14:34:10 <glguy> You'd probably want to take one extra
14:34:11 <lambdabot>  thread killed
14:34:15 <Heffalump> yes, I was just thinking that
14:34:16 <glguy> to determine if the list was too long
14:34:24 <opqdonut> ah yes true
14:34:32 <Cin> heh, indeed.
14:34:40 <Cin> > take 10 [1]
14:34:40 <lambdabot>  [1]
14:34:44 <int-e> hmmm  not . null . drop (x-1)
14:34:58 <opqdonut> > drop 10 [1]
14:34:59 <lambdabot>  []
14:35:01 <gwern> yaxu: I guess one of those would be the answer, or you could try adding 'haskell98' to the build-depends - ST sounds like one of the old nonhierarchical libary module names
14:35:08 <opqdonut> int-e: that errs the other way :)
14:35:13 <glguy> > (not . null . drop 0) [1]
14:35:15 <lambdabot>  True
14:35:24 <chadz> glguy: the addUser works, however, the other query doesnt.
14:35:41 <gwern> ukl_: I helped package up postmaster for hackage; the code looked fairly solid and close to usable to me, but I don't know if anyone but the author has actually used it to deliver email
14:35:42 <Cin> do you think stream fushion might do this optimisation?
14:35:53 <yaxu> gwern: ok, thanks for the pointers
14:35:55 <Heffalump> Cin: I hope not, it'd change the semantics.
14:36:00 <opqdonut> yeah
14:36:03 <Heffalump> (consider undefined or infinite tails)
14:36:13 <opqdonut> change strictness to be precise
14:36:16 <Heffalump> though it is known to be a bit fast-and-loose about strictness, so it might...
14:36:18 <Cin> ah
14:36:20 <int-e> opqdonut: oh. then how about  (==x) . length . take (x+1)
14:36:27 <opqdonut> yeah that'll work
14:36:38 <opqdonut> as suggested by me and fixed by glguy :)
14:36:42 <Heffalump> what would be nice is if it would remove the multiple passes from the final solution
14:36:42 <opqdonut> well, off to sleep ->
14:36:54 <ukl_> gwern, I don't doubt that it works (although I haven't tried), but the question just stroke me. There might have been nice things to be done with it.
14:37:18 <Cin> heffalump: ah, instead of doing the passes of the take, and the passes of the length, it just does one pass?
14:38:01 <gwern> ukl_: I find that there are a lot of nice little one-man haskell projects out there which no one has ever heard of; it's a little depressing sometimes
14:38:36 <dons> gwern: yep. its great  to get these all together, and build up a culture of releasing code
14:39:02 <yaxu> her, the makefile for this specifies 'ghc-2.10'
14:39:10 <gwern> dons: yes. people like ukl_ give me hope and encouragement - would he have ever even thought about postmaster if I hadn't spent two days on it?
14:39:18 <ukl_> gwern, indeed. But the situation is getting better, isn't it? (I mean, I haven't looked at haskell that much a while ago but it seems to me the community has become pretty active?)
14:39:25 <gwern> yaxu: heh. what are you looking at?
14:39:34 <dons> gwern: right. its funny, 20 years of activity, but only the last year or so with a central repo for collecting code.
14:39:49 <ehird> @type fix fix
14:39:49 <dons> ukl_: its got kind of crazy active. as you see on hackage.haskell.org
14:39:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
14:39:50 <lambdabot>     Probable cause: `fix' is applied to too many arguments
14:39:50 <lambdabot>     In the first argument of `fix', namely `fix'
14:40:05 <ukl_> gwern: Actually, I re-discovered postmaster. I knew the cryp.to website when I had not yet got in touch with haskell. But really, what you've done was worth it :))
14:40:33 <gwern> ukl_: dunno. it's hard to tell sometimes - I know some people complain that haskell's blog visibility is due solely to dons, and I've seen people complaining about my uploading.  so is it that haskell is really active or just that what actibity there is gets publicized well?
14:40:41 * gwern ignores ukl_'s last comment
14:40:50 <ukl_> :} sorry.
14:40:55 <yaxu> gwern: this library -- http://www.dinkla.net/fp/cglib.html
14:40:55 <lambdabot> Title: Library for Geometric Algorithms in Haskell
14:41:59 <gwern> dons: well, the internet wasn't really viable for several of those years, and then you had haskell '98 which broke quite a bit of code, and after that, ghc evolution has made it quite painful to build up any reusable working base - did you catch Henning's complaints about upgrading? that came about in part because I was pushing him to update haskore and its dependencies
14:43:20 <ukl_> Haskore. Another one of these projects I wonder anybody has recently done anything with. I tried but failed. (Some building issues)
14:43:30 <gwern> packaging was difficult and nonstandard before cabal, the advanced libraries like GTK and wxhaskell kept changing... no, I'm not really surprised that only 'now' do we really want hackage
14:44:05 <gwern> ukl_: henning maintains it, but he has issues with upgrading at all to ghc 6.8.x, and doing so is quite painful and difficult - the dependencies are many, complex, and interrelated.
14:44:59 <gwern> and the guy maintaining the various supercollider libraries has been keeping his stuff more up to date, which ironically only exacberates the problems with haskore
14:45:48 <gwern> yaxu: looks interesting. how far have you gotten updating it?
14:47:13 <yaxu> gwern: nowhere i'm afraid
14:49:30 <dons> Cale, you should ask gwern for his opinion on the euler thing
14:49:37 <dons> wikis/copyright/licenses et  al
14:50:31 <faxathisia> @src on
14:50:31 <lambdabot> (*) `on` f = \x y -> f x * f y
14:51:04 <Cin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Function.html#v%3Aon
14:51:05 <lambdabot> http://tinyurl.com/387hs8
14:51:18 <Cin> does lambdabot ignore urls with `#' in them?
14:51:28 <Cin> (for the title)
14:52:07 <int-e> Cin: I guess it can't parse the title if the opening tag is on a different line than the closing tag
14:52:28 <ukl_> http://fedoraproject.org/wiki/Features/GoodHaskellSupport  (Oh, great.)
14:52:29 <lambdabot> Title: Features/GoodHaskellSupport - Fedora Project Wiki
14:53:00 <Cin> int-e: ah, i see
14:53:14 <olsner> @pl \f -> g f f
14:53:14 <lambdabot> join g
14:53:27 <gwern> dunno why the page includes meep - meep just uses some haskell to generate c++ or something
14:53:58 <olsner> @type let (*) `on'` f = join (*) f in (on,on
14:53:59 <lambdabot> parse error (possibly incorrect indentation)
14:54:01 <olsner> @type let (*) `on'` f = join (*) f in (on,on')
14:54:02 <lambdabot> Not in scope: `on'
14:54:21 <olsner> @type let (*) `on'` f = join (*) f;  (*) `on` f = \x y -> f x * f y in (on,on')
14:54:21 <lambdabot> forall t t1 t2 t3 a. ((t -> t -> t1) -> (t2 -> t) -> t2 -> t2 -> t1, (t3 -> t3 -> a) -> t3 -> a)
14:54:58 <faxathisia> It's not possible to write on in a more elegant way than lambdabot does :p
14:55:20 <olsner> besides, I was writing something else entirely
14:56:31 <olsner> if haskell had implicit lambdas with positional parameters it'd be on = ($2 $3 `$1` $2 $4)
14:56:41 <cdsmithus> Has anyone got this Leksah thing working?  I am having trouble satisfying various version dependencies (bytestring and Cabal).
14:57:42 <chadz> glguy: it appears the type for addBlog MUST be (
14:57:42 <chadz> [#haskell] glguy: it appears the type for addBlog MUST be
14:57:44 <chadz> ugh
14:57:55 <chadz> (DBM mark Session Int)
14:57:58 <dons> this should really get some more upmods... http://reddit.com/r/programming/info/69r8e/details
14:58:02 <chadz> whilst, the addUser is (DBM mark Session ())
14:58:07 <dons> cdsmithus: yeah, i've seen it in use
14:58:13 <faxathisia> +
14:58:16 <dons> you got a new cabal from darcs, and a recent bytestring?
14:58:35 <chadz> glguy: (the addUser works, the addBLog doesn't)
14:58:49 <cdsmithus> dons: I have the bytestring from GHC.  I can build a new one.  But for Cabal, the problem seems to be that it's too new.
15:00:22 <chadz> glguy: nevermind, scratch that.
15:02:23 <matthew_-> howdy
15:03:06 <faxathisia> hi
15:03:21 <gwern> dons: ehird's got your number there...
15:03:48 <faxathisia> gwern++
15:03:50 <faxathisia> :P
15:04:48 <matthew_-> hmm. hwn seems to have lost the regular section on the haskell' standardisation effort...
15:05:03 <ehird> huh what who where
15:05:22 <hpaste>  chrizel pasted "how to make it shorter?" at http://hpaste.org/5848
15:05:24 <Heffalump> there's a standardisation effort? :-)
15:05:28 <matthew_-> well quite
15:05:31 <matthew_-> (dot org)
15:05:37 <gwern> matthew_-: you seem to assume there'd be something to report on :)
15:05:58 <dons> gwern: ?
15:06:12 <dons> matthew_-: not much traffic recently
15:06:16 <gwern> dons: re ehird's comment in youre reddit link
15:06:32 <gwern> chrizel: man, can't you jsut factor out all the 'throwError $ NumArgs 1 args
15:07:20 <matthew_-> right, what's the "#haskell words of wisdom" (aka #hwow) on deciding what modules to expose?
15:07:38 <roconnor> > ln (7/11)
15:07:42 <gwern> ...and all the 'return $ Bool False
15:07:46 <dons> matthew_-: expose safe things?
15:07:47 <lambdabot>   Not in scope: `ln'
15:07:51 <gwern> and return $ Bool Trues...
15:07:51 <chrizel> gwern: how? xD
15:07:56 <roconnor> > log (7/11)
15:07:58 <lambdabot>  -0.45198512374305727
15:08:11 <ehird> matthew_-: five point three ones
15:08:16 <roconnor> > 2*arctanh((7-11)/(7+11))
15:08:17 <lambdabot>   Not in scope: `arctanh'
15:08:32 <gwern> chrizel: maybe define a 'throw1Error = throwError . NumArgs 1' and replace 'p_list args = throwError $ NumArgs 1 args
15:08:34 <roconnor> > 2*atanh((7-11)/(7+11))
15:08:35 <lambdabot>  -0.4519851237430573
15:08:44 <gwern> with maybe p_list = throw1Error
15:08:56 <matthew_-> so there's not a general idea that you should have a utility module that explicitly re-exposes everything that you expect to be useful?
15:09:35 <gwern> matthew_-: I think most people usually just define modules as normal, and then tighten up the export list to only export useful stuff
15:10:18 <ehird> hmm
15:10:20 <matthew_-> yeah, but when you're building a library and in order to use the library, the user would have to import n of your modules where n >> 1
15:10:21 <ehird> monads are CPS. I just realised that
15:10:22 <ehird> XD
15:10:42 <ddarius> ehird: No they are not.
15:10:53 <ehird> ddarius: Well, kind of.
15:11:08 <ddarius> :t ($)
15:11:09 <lambdabot> forall a b. (a -> b) -> a -> b
15:11:13 <ddarius> :t (=<<)
15:11:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
15:11:14 <faxathisia> how do you beta reduce De Bruijn indices :/
15:11:16 <ehird> x >>= \y -> z y        -- this is basically CPS of z x
15:11:29 <ddarius> ehird: No it isn't.
15:11:39 <ehird> ddarius: Well, not *technically*
15:11:41 <ehird> But basically.
15:11:42 <chrizel> gwern: but what do i do with throw1Error then? p_list = throw1Error?
15:11:46 <ddarius> Not basically either.
15:12:06 <gwern> chrizel: right, like I said. I *think* that'd work, anyway
15:12:11 <gwern> @pl p_list args = throwError $ NumArgs 1 args
15:12:12 <lambdabot> p_list = throwError . NumArgs 1
15:12:37 <faxathisia> CPS is where every function takes a continuation.. so z x.. would be z x k ..?
15:12:42 <ddarius> \y -> z y === z so x >>= \y -> z y === x >>= z === z =<< x.
15:13:06 <ddarius> In the Identity monad, z =<< x is z x
15:13:15 <chrizel> yes, but what's about the return $ Bool True/False lines? i can't imagine how that could work
15:13:16 <gwern> > let throw1Error = throwError . NumArgs 1; let p_list = throw1Error in p_list '1'
15:13:16 <lambdabot>  Parse error at "let" (column 43)
15:13:47 <faxathisia> f (g (h x)) would be.. h x (\v -> g v (f \v -> k v)) ?
15:14:01 <ddarius> Monadic style has some relation to continuation passing style, but they aren't the same thing.
15:14:12 <faxathisia> h x >>= (\v -> g v >>= (f \v -> >>= k v)) -- and this is the monadic version?
15:15:50 <oerjan> chrizel: is it really necessary to treat the second and third cases differently?
15:15:55 <hpaste>  gwern annotated "how to make it shorter?" with "factor out duplicating" at http://hpaste.org/5848#a1
15:16:31 <gwern> I'm not sure how '[_]' and 'args' really differ - don't they both match any sort of list?
15:16:42 <oerjan> gwern: only 1 element in the first
15:17:04 <faxathisia> how do you beta reduce some term which has De Bruijn indices?
15:17:04 <chrizel> oerjan: yes, the second case should return False and the third case is for argument count checking
15:17:19 <gwern> oerjan: oh, does [_] not match []?
15:17:24 <oerjan> nope
15:17:32 <Cin> well that implies x:[]
15:17:37 <Cin> or _:[]
15:17:39 <oerjan> the _ matches an expression
15:18:27 <gwern> @pl p_symbol [_] = rFalse
15:18:27 <lambdabot> (line 1, column 10):
15:18:28 <lambdabot> unexpected "["
15:18:28 <lambdabot> expecting variable, "(", operator or end of input
15:18:59 <ddarius> faxathisia: You replace all the 1s (or 0s or whatever) with the value and you shift all the other numbers down 1 (modulo scoping)
15:19:47 <faxathisia> :S
15:20:11 <chrizel> i wonder whether it's possible to pass a type constructor to a function as parameter and compare two unknown type constructors  inside that function
15:20:24 <ddarius> type constructors aren't values
15:20:26 <gwern> chrizel: your function definitions, once you factor out the bodies, are all awfully repetitive. it looks like they only differ in the type of input/output, which makes me wonder whether you could write a single polymorphic function which covers them all
15:20:30 <gwern> I don't know how though
15:20:41 * gwern has faith in haskell that it can be done, though!
15:20:43 <faxathisia> beta (Lam (Index 0 :@: (Lam (Index 1)))) Foo -> Foo :@: (Lam Foo) -- I should have though
15:21:13 <oerjan> gwern: um their types are all identical
15:21:13 <ddarius> chrizel: You can use the Data class to reify the type constructor name as a value..
15:21:39 <gwern> oerjan: oh, you're right. I got confused by the 'throwError args' part
15:21:40 <gwern> and the separate names, maybe he has a reason for that
15:23:15 <faxathisia> ddarius it seems WAY more complex
15:23:29 <gwern> but of course, throwErrors would return the same thing no matter the args, probably an () or something, so the functions would all be returning the lifted Boolean (true or false), or throwError's type (whatever that is)
15:24:06 <ddarius> faxathisia: Yeah, there is a shift step as you go through lambdas.  It's not way more complex but it isn't really all that much better than named variables in my opinion.
15:24:55 <ehird> What is the best way to structure the whitespace-ignoring you get in Parsec parsers?
15:25:01 <ehird> I often find having it all over the place.
15:25:41 <ehird> \
15:25:56 <Cin> there's a whitespace combinator iirc, are you using that?
15:25:57 <ddarius> faxathisia: You have subst n val (Index m) | n == m = val; subst n val (App f x) = App (subst n val f) (subst n val x); subst n val (Lam e) = Lam (subst (n+1) val e)
15:25:59 <ehird> Cin: Yes, but this still results in lots of dottedness
15:26:00 <oerjan> gwern: um throwError is a method and its arguments can be got by catchError
15:26:36 <oerjan> oh and it's return type is polymorphic like error
15:26:41 <oerjan> :t throwError
15:26:45 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
15:26:50 <faxathisia> ddarius, thanks
15:26:57 <ddarius> Oh and the obvious otherwise case for Index
15:27:01 <faxathisia> | othewise = Index (m-1)
15:27:18 <ehird> othewise!
15:28:01 <oerjan> ehird: the lexeme parser (which also handles comments if you have them)
15:28:33 <ddarius> Text.ParserCombinators.Token
15:28:49 <ddarius> er + Parsec.
15:28:57 <faxathisia> beta n (Lambda type body) = Lambda (beta n type) (beta (n+1) body)
15:29:13 <oerjan> (it's technically a field in a TokenParser record or something)
15:29:19 <ehird> oerjan: Is there a tutorial for *that* anywhere? :-P
15:29:27 <ddarius> ehird: The Parsec tutorial.
15:29:27 <ehird> Parsec may have many; but only trivial ones.
15:29:38 <oerjan> @where parsec
15:29:39 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
15:29:40 <ehird> ddarius: Not the most gentle thing
15:30:56 <oerjan> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#ParsecToken
15:30:58 <lambdabot> http://tinyurl.com/2p5p89
15:31:57 <ehird> I love how parsec is on a domain wiht legacy in the front of it
15:31:59 <faxathisia> :D
15:32:29 <cdsmithus> I seem to be missing Graphics.UI.Gtk.ModelView.ComboBox.comboBoxAppendText in gtk2hs.  Anyone know where it went?
15:33:08 <ehird> anyway; it'd be nice for an actual tutorial using tokenparser thingy to build a full parser
15:33:45 <faxathisia> ehird, I have a nice example of using a token parser
15:33:53 <faxathisia> (well I like it..)
15:34:45 <faxathisia> within = ($) -- Is this kind of presentation hack bad?
15:34:58 <faxathisia> It's so I can write from `equals` vTyp `within` gamma
15:36:23 <Cin> @src ThreadId
15:36:23 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:36:53 <oerjan> ehird: the Parsec tutorial is both a tutorial and a reference
15:37:19 <Cin> ehird: write yourself a scheme in 48 hours is a nice tutorial for parsec..
15:37:39 <ehird> Cin: hm; does it use tokenparser thingy>?
15:38:55 <Cin> ehird: i don't know
15:38:59 <chrizel> ehird: no
15:39:08 * gwern reads the euler thread on -cafe. what a silly dispute
15:40:06 <faxathisia> I need \(n:Nat) -> \(A:Type 0) -> \(x:A) -> \(f:A->A) -> (f (((n A) x) f)) in De Bruijn notation :/
15:40:55 <ddarius> faxathisia: Write a function to convert from named notation to de Bruijn indices.
15:41:29 <faxathisia> infact that will be a lot easier than manually
15:41:31 <Cin> is it totally silly to use parsec to validate input values from users on a web site?
15:42:54 <ddarius> Cin: It's a bit heavyweight, but otherwise fine.
15:46:54 <IsoPallo> Hi everybody! How is it going? Last week I decided to learn to understand Haskell, so I was just wondering if there is a channel for all the silly questions by people without a clue.
15:47:08 <Zao> IsoPallo: If you're willing to learn, possibly :)
15:47:09 <Lemmih> JohnMeacham: Hi!
15:47:24 <dobblego> IsoPallo, it serves no other purpose!
15:47:29 <IsoPallo> Well, I'm trying :)
15:47:44 <astrolabe> Here is a good place
15:47:45 <Lemmih> JohnMeacham: Can I pick your brain?
15:48:43 <eu-prleu-peupe1> hi
15:49:00 <eu-prleu-peupe1> what can i use to generate 2d images in haskell ?
15:49:21 <eu-prleu-peupe1> graphics, and stuff like that ? and then dump them into a png or jpg...
15:49:27 <Lemmih> eu-prleu-peupe1: SDL can do that.
15:49:36 <jeffz> eu-prleu-peupe1: you can output text to make a svg.
15:50:04 <LoganCapaldo> there are bindings to imlib, maybe they can help
15:50:04 <eu-prleu-peupe1> haskell has binding to sdl ?
15:50:12 <LoganCapaldo> check the hackage
15:50:15 <Lemmih> eu-prleu-peupe1: We sure do.
15:50:23 <LoganCapaldo> @where hackage
15:50:24 <lambdabot> http://hackage.haskell.org/
15:51:07 <jeffz> eu-prleu-peupe1: http://lisperati.com/haskell/ this tutorial gives an example of 2d images using not much more than outputing some text.
15:51:24 <eu-prleu-peupe1> nicee
15:51:25 <eu-prleu-peupe1> thanks
15:54:48 <faxathisia> Why is there no instance for Monad (Either a) ?
15:55:26 <dobblego> ?instances Monad
15:55:28 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:56:11 <faxathisia> @index Either
15:56:12 <lambdabot> Data.Either, Prelude
15:56:27 <faxathisia> ok thanks
15:56:35 <faxathisia> I had to import Data.Either
15:56:59 <faxathisia> oh wait actually no that didn't work
15:57:16 <Lemmih> faxathisia: Control.Monad.Instances, perhaps.
15:57:45 <faxathisia> n
15:57:47 <faxathisia> o
15:57:57 <gwern> eugh. doesn't it occur to people that copying source from someone else and sticking it on the haskell wiki might not be the most licit thing to do?
15:58:07 <faxathisia> I'm going to use ErrorT I think..
15:58:21 <LoganCapaldo> faxathisia: it's instance (Error a) +> Monad (Either a)
15:58:27 <LoganCapaldo> or some such
15:58:33 <LoganCapaldo> s/+/=/
15:58:41 <IsoPallo> So my first... Will IO work without the monads stuff if I'm not interested in the temporal relations between the input and output? Like taking stdin and stdout as lists. At least it seems that it is possible to handle the order of a list. Or are lists monadic too?
15:59:02 <LoganCapaldo> > fail "wee" :: Either String ()
15:59:13 <lambdabot>  Left "wee"
15:59:16 <IsoPallo> Not that it matters in practice for me, just for curiosity...
15:59:35 <LoganCapaldo> > fail "wee" :: Either Int ()
15:59:36 <lambdabot>   add an instance declaration for (Error Int)
15:59:36 <lambdabot>     In the expression: fail "we...
15:59:59 <resiak> @type interact
16:00:11 <lambdabot> (String -> String) -> IO ()
16:00:20 <LoganCapaldo> so your a has to be an instance of Error
16:00:35 <Lemmih> IsoPallo: Yes, lists are monads but keep in mind that monads aren't just used for IO.
16:00:59 <resiak> IsoPallo: ^^^ this lets you provide a function mapping a string to another string, and then lazily reads from stdin to it and spews the result into stdout
16:06:10 <IsoPallo> Ok, nice. Thanks. I'm trying to play with things that hurt less first... And doing things that I don't understand leave a nasty type of hangover...
16:06:50 <Cin> as long as it's well-typed
16:08:10 <IsoPallo> That actually seems to be the worst part to me here. Its relatively easy to do some small exercises, but understanding why it works... Uh...
16:08:14 <blt> Is there anything that works like read but on chars? Something like: rread :: (Read a) => Char -> a
16:08:54 <ddarius> blt: That would be kind of useless.  It's hard to encode structured information into a single character.
16:09:08 <blt> ddarius: I can find a use for it.
16:09:17 <ddarius> blt: What do you want to do?
16:09:54 <resiak> @let readc c = read [c]
16:09:56 <lambdabot> Defined.
16:10:12 <blt> I'd like to take a [Char] and map rread over it. So, map rread "123" is [1, 2, 3]
16:10:32 <alatter> > map readc "123"
16:10:35 <lambdabot>  Exception: Prelude.read: no parse
16:10:49 <resiak> hmm
16:10:55 <ddarius> > map digitToInt "123"
16:10:56 <lambdabot>  [1,2,3]
16:11:07 <Cin> > map (readc :: Char -> Int) "123"
16:11:08 <lambdabot>  [1,2,3]
16:11:11 <Cin> ^____^
16:11:18 <alatter> ooo
16:11:27 <blt> Thanks all.
16:11:39 <LoganCapaldo> > map readc "123" :: [Int]
16:11:40 <lambdabot>  [1,2,3]
16:11:49 <Cin> ooo
16:13:52 <hpaste>  chrizel annotated "how to make it shorter?" with "...maybe with an intermediate data type?" at http://hpaste.org/5848#a2
16:14:10 <lekro> why is (0 :: Int) * _|_ also _|_?  is there an easy way around that? I want to write a function evaluateShifted something delta, and when delta is 0 it should save a whole bunch of work
16:14:27 <LoganCapaldo> > map (head [readc, ord]) "123"
16:14:29 <lambdabot>  [1,2,3]
16:15:06 <LoganCapaldo> who needs type annotations anyway? :P
16:17:09 <Cin> =o
16:17:15 <SamB> lekro: probably some kind of "optimization"
16:17:41 <SamB> lekro: anyway... you can use pattern matching to handle it...
16:17:48 <Saizan> lekro: you can define your function like foo 0 _ = ..; foo x y = ..
16:18:06 <monochrom> Next, you'll ask why is _|_*0 also _|_.
16:18:26 <_frederi1_> hello, how does one get a backtrace from errors these days?
16:18:48 <lekro> I know that, but it would have been shorter if 0 * x would not evaluate x. but it makes sense from a performance point of view
16:18:50 <SamB> monochrom: I think this guy is smart enough to know that he can't have it both ways, and that the other way would be the way it would be if it were at all...
16:19:25 <seafood_> How many people here are using cabal-install?
16:19:30 <Lemmih> I am.
16:19:36 <seafood_> Good?
16:19:41 <monochrom> I find it more realistic to not assume people to be smart. :)
16:20:03 <Lemmih> seafood_: Divine, I'd say.
16:20:11 <seafood_> Excellent.
16:20:14 * oerjan notes there is an Examples sections with a few links
16:20:24 <faxathisia> beh
16:20:37 <oerjan> (wrong channel)
16:21:50 <Lemmih> seafood_: Like the wheel and fire, cabal-install is one those things you can't believed you once lived without.
16:22:08 <seafood_> You forgot internet pr0n
16:22:24 <seafood_> Lemmih: I'll check it out now.
16:23:43 <_frederik_> it used to be that stack traces could be had by passing +RTS -xc -RTS after compiling with profiling, does anyone know what happened?
16:24:25 <Lemmih> JohnMeacham: Hello, how's code?
16:24:30 <faxathisia> De Bruijn indices are hard to work with ...
16:24:53 <ddarius> faxathisia: It's a pain to write code using de Bruijn indices, yes.
16:25:25 * faxathisia starts attempt 3 at writing a type checker :/
16:25:28 <ddarius> faxathisia: Depending on how interested you are in these sorts of things you may want to look at CINNI, the Calculus of Indexed Names and Named Indices
16:25:37 <ddarius> @google Calculus of Indexed Names and Named Indices
16:25:38 <lambdabot> http://formal.cs.uiuc.edu/stehr/cinni_eng.html
16:25:38 <lambdabot> Title: CINNI - A Calculus of Indexed Names and Named Indices
16:25:57 <faxathisia> thanks, sounds good
16:26:05 <ddarius> @hoogle unfoldM
16:26:05 <lambdabot> No matches found
16:29:54 <ddarius> _frederik_: That should still work.  Also, there is the GHCi debugger as well.
16:34:58 <seafood_> Hey, Cabal didn't build with GHC 6.8.1
16:43:20 <dbueno> In hackage, should new parsers for particular file types be in a module called Data.<something>?
16:44:31 <oerjan> perhaps in the Codec.* and Language.* hierarchies?
16:45:01 <dons> yeah, Codec, Text, Language.*
16:45:10 <oerjan> http://www.haskell.org/haskellwiki/Hierarchical_module_names
16:45:11 <lambdabot> Title: Hierarchical module names - HaskellWiki
16:46:07 <dbueno> oerjan: Thanks for the link.
16:46:44 <ddarius> Data.Codec.Text.Language.Whitespace
16:46:56 <_frederik_> ddarius: can i use the ghci debugger with external packages? i have a problem in that my program uses threads, and i apparently can't combine profiling and threads
16:48:37 <dbueno> So I'm going to upload a conjunction normal form parser to hackage ... where would you put it?  Codec.Logic?
16:48:54 <dbueno> I mean conjunctive normal form, of course.
16:49:35 <Excedrin> conjunctive junction, what's your function
16:50:33 * gwern thwacks Excedrin. groan!
16:52:02 <oerjan> doesn't that hurt a lot?  oh wait, groAn
16:52:28 <Cin> oh lawd. Text.Xhtml.Strict doesn't support 'label'
16:52:31 * Cin adds it
16:53:05 <Cin> oh yeah it does. d'oh!
16:53:14 * Cin wipes brow
16:53:22 <gwern> @hoogle fromInt
16:53:23 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
16:53:23 <lambdabot> Prelude.fromIntegral :: (Integral a, Num b) => a -> b
16:53:34 <gwern> oerjan: no, it doesn't - Excedrin, y'see
16:55:41 <Cin> :t (<<$)
16:55:44 <lambdabot> Not in scope: `<<$'
16:55:58 <gwern> @hoogle Ix
16:55:59 <lambdabot> Data.Ix :: module
16:56:00 <lambdabot> Data.Ix.Ix :: class Ord a => Ix a
16:56:00 <lambdabot> Data.Array.IArray.ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
16:56:34 <_frederik_> how does one list all the symbols in a module in ghci?
16:56:37 <Cin> @src ($)
16:56:37 <lambdabot> f $ x = f x
16:57:19 <Qerub> Hello! I need to pass some extra options like "-I /opt/local/include" to GCC to compile a library that uses Distribution.Simple/Setup.lhs. How do I do that?
16:57:21 <gwern> @hoogle Array
16:57:22 <lambdabot> Foreign.Marshal.Array :: module
16:57:22 <lambdabot> Data.Array :: module
16:57:22 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
16:57:57 <dons> Qerub: cc-options in the .cabal file
16:57:59 <gwern> @hoogle ST
16:58:00 <lambdabot> Control.Monad.ST :: module
16:58:00 <lambdabot> Data.Array.ST :: module
16:58:00 <lambdabot> Control.Monad.ST.ST :: data ST s a
16:58:06 <dons> and since they're just include flags, you can use a .buildinfo file
16:58:13 <dons> but first try cc-options:
16:58:15 <gwern> @hoogle newSTArray
16:58:16 <lambdabot> No matches found
17:00:33 <Qerub> dons: Thank you, it worked.
17:00:48 <Qerub> dons: I'll read up on .buildinfo's.
17:01:04 <Cin> @fixity ($)
17:01:04 <lambdabot> Unknown command, try @list
17:01:10 <Cin> @list
17:01:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:01:41 <LoganCapaldo> it's spelled :info in ghci, but lambdabot doesn't do it
17:01:56 <Cin> ah, thanks
17:02:01 <LoganCapaldo> > (0$0 $) -- was this the trick?
17:02:04 <lambdabot>      The operator `$' [infixr 0] of a section
17:02:04 <lambdabot>         must have lower precede...
17:02:14 <LoganCapaldo> it was :)
17:02:25 <Cin> i want to define a <<$ for Text.XHtml.Strict as a $-ish kind of <<
17:02:47 <_frederik_> does anyone know if the ghci debugger works with packages?
17:03:03 <Qerub> Next problem: It needs to link with libX that is in /opt/local/lib and passing a -L is not enough.
17:08:02 <gwern> oh, that's nice. I was googling for old ST library docs and discovered this HaLex project http://www.di.uminho.pt/~jas/Research/HaLeX/HaLeX.html which is public domain and which compiles almost immediately; I may have to give up on the geometry library, but this more than makes up for it!
17:08:09 <glguy> if System.Locale is in old-locale, what is the new module?
17:09:06 <gwern> (HaLeX only seems to be mentioned in a 2004 community report. hm, so I would've been unlikely to come across it. Bless serendipity!)
17:09:14 <oerjan> yay my memes are spreading
17:09:24 <gnuvince_> @version
17:09:24 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
17:09:24 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:10:42 <gwern> public domain, eh. hope Cabal recognizes that
17:11:26 <oerjan> gwern: perhaps it's because it's only useful with old-time (iiuc the haddock)?
17:12:26 <gwern> oerjan: pardon?
17:13:23 <oerjan> gwern: the docs say System.Locale currently only contains functions for use with System.Time
17:13:24 <JohnMeacham> Lemmih: good
17:13:41 <gwern> oerjan: you're thinking of glguy
17:13:48 <oerjan> ouch
17:13:52 <oerjan> glguy: ^^
17:14:03 <Lemmih> JohnMeacham: Care to chat about jhc?
17:14:30 <glguy> oerjan: old-locale is used by time
17:14:35 <glguy> (rather than old-time)
17:15:09 <JohnMeacham> Lemmih: I am a little distracted right now.. but I can bounce in and out a bit.
17:15:12 <oerjan> "At present, it supports only time and date information as used by System.Time.calendarTimeToString from the System.Time module in the old-time package"
17:16:01 <glguy> I've read the out of date haddocks
17:16:37 <Lemmih> JohnMeacham: Oh well, another time then.
17:16:41 <oerjan> whatever
17:17:02 <oerjan> glguy: out of date package name too, then, perhaps
17:17:22 <glguy> so it seems
17:20:39 <gnuvince_> @karma
17:20:39 <lambdabot> You have a karma of 0
17:21:20 <Cin> @karma karma kameleon
17:21:20 <lambdabot> karma has a karma of 5
17:21:45 <monochrom> self-karmaing quine
17:21:46 <Qerub> dons: For the record: include-dirs and extra-lib-dirs did the trick for me.
17:22:44 <bd_> @karma karma++
17:22:44 <lambdabot> karma++ has a karma of 0
17:22:47 <bd_> @karma karma++
17:22:47 <lambdabot> karma++ has a karma of 0
17:27:49 <fxr> I want to generate random 8 letter ascii text, any help?
17:28:26 <Lemmih> fxr: take 8 . randoms ?
17:28:47 <mauke> @hoogle ascii
17:28:48 <lambdabot> Data.Char.isAscii :: Char -> Bool
17:28:48 <lambdabot> Data.Char.isAsciiUpper :: Char -> Bool
17:28:48 <lambdabot> Data.Char.isAsciiLower :: Char -> Bool
17:31:03 <Lemmih> > (randomRs ('a','z') (mkStdGen 42)) :: String
17:31:04 <lambdabot>  "ndfeolyrgnvdecmnpxdaqmqgsycsbembciyzoumzkiqqkszcbikcasnfqdkqrkfgtcsjwzpprbw...
17:33:15 <gwern> @hoogle getArgs
17:33:15 <lambdabot> System.Environment.getArgs :: IO [String]
17:33:27 <_frederik_> do people realise that they can talk to lambdabot via private messages?
17:33:54 <_frederik_> it seems that makes up a lot of the traffic on this channel
17:34:06 <gwern> why would you want to do that? 'tis a silly thing
17:34:13 <gwern> this is more sociable
17:34:38 <fxr> Lemmih: thanks
17:35:09 <decker> is there some way to trace function calls in haskell?
17:35:55 <olsner> lambdabotting in the open means everyone can point out your mistakes, such as trying to make a function shorter when there's a standard function for it, or whatever
17:36:00 <EvilTerran> ?hoogle trace
17:36:02 <lambdabot> Debug.Trace.trace :: String -> a -> a
17:36:02 <lambdabot> Debug.Trace :: module
17:36:02 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
17:36:11 <EvilTerran> @where hat
17:36:11 <lambdabot> http://www.haskell.org/hat/
17:36:23 <EvilTerran> are the two debugging thingys i'm aware of
17:37:17 <decker> thnx
17:37:30 <mauke> or the builtin debugger in ghci-6.8
17:40:34 <seafood_> A question about cabal-install. It seems to require Cabal >= 1.3.6. I downloaded the darcs repository but it doesn't build with GHC 6.8.2
17:40:41 <seafood_> Only works with HEAD?
17:41:11 <gwern> seafood_: you could get an older cabal-install - I have one installed that works happily with 1.2.3
17:41:22 <gwern> it's just darcs cabal-install that is developed for darcs cabal
17:41:32 <seafood_> Yeah.
17:41:43 <IsoPallo> Ok, so far i'm led to believe that monads for example in IO (sorry, I'm consentrating on this first...) work to pair a kind of "token-passing token" with the IO operation. Am I mistaken by a huge margin? The "token" would be obligatory for an operation to have before doing its stuff? Atleast just having a function as a parameter of another does not provide any indication of sequencing between the two, right?
17:42:09 <dcoutts> seafood: Cabal-1.3.6 works with ghc-6.8.2, that's what I've been developing it with
17:42:18 <dcoutts> seafood: what problem have you found?
17:42:27 <seafood_> Distribution/Simple/Register.hs:160:13: Not in scope: `notice'
17:42:27 <seafood_> Distribution/Simple/Register.hs:161:13: Not in scope: `notice'
17:42:32 <mauke> IsoPallo: I think of IO as a syntax tree
17:42:46 <seafood_> dcoutts: I just installed 6.8.2 and that's what I got.
17:42:54 * dcoutts double checks
17:43:01 <seafood_> (with darcs Cabal)
17:43:19 <dcoutts> seafood: hmm, yep, my mistake, hold on a sec...
17:43:23 <olsner> hmm, wait a minute, I got that error too when building darcs Cabal
17:43:48 <gwern> speaking of cabal-install, anyone want to do 'cabal update && cabal install HaLeX-1.1' for me?
17:43:50 <dolio> IsoPallo: You can look at it that way, yes.
17:43:54 <monochrom> Nice, HWN, and the website is back.
17:44:42 <olsner> seafood: find the import Distribution.Simple.Utils line in Register.hs and add notice to the list of imported names
17:44:48 <Lemmih> gwern: Worked for me with ghc-6.8.2. (There's a ton of warnings, though)
17:44:54 <bos> dobblego: pong
17:44:58 <gwern> Lemmih: good. as expected
17:45:10 <gwern> now to surprise some professor!
17:46:05 <seafood_> dcoutts: Thanks. Man, the Haskell community really rocks.
17:46:11 <seafood_> Thanks for the quick fix.
17:46:24 <gwern> (people always seem to be surprised when I send them patches and tarballs)
17:47:01 <dolio> gwern: I was surprised. I didn't think anyone used my stuff. :)
17:47:02 <QtPlatypus> Not sure why.
17:47:36 <gwern> dolio: er.. which one of yours did I edit?
17:47:50 <dolio> CC-delcont, I think.
17:48:05 <dcoutts> seafood: ok, pushed. Try now.
17:48:14 <dolio> Yeah, that was the one.
17:48:25 <gwern> oh. It must've been when I was working on ZFS
17:48:45 <dolio> I suppose, strictly speaking, you don't use it either. You just wanted it to compile with -Wall. :)
17:49:06 <dolio> Although monochrom uses it, apparently.
17:49:08 <gwern> no, I sometimes play around with ZFS, which now requires CC-delcont, so I do sort of use it
17:49:18 <dolio> Ah, okay.
17:49:25 <glguy> dons: had any spare coding time? hording the commits all to yourself? ;)
17:49:29 <dcoutts> seafood: ok, latest darcs Cabal and cabal-install are working for me now with no extra localt changes or unpushed local patches
17:49:35 * dcoutts -> bed
17:49:39 <dcoutts> g'night folks
17:49:41 <seafood_> dcoutts: Good night.
17:49:42 * monochrom waves
17:50:49 * gwern reads 'The UMinho Haskell Software is a repository of software, written in the functional programming language Haskell, that is being developed in the context of various research and educational projects.' and begins twitching
17:51:25 * glguy doesn't like that takusen segfaults with sqlite when reading a NULL as something that isn't Maybe a
17:51:36 <ddarius> gwern: Is the UU stuff on hackage?
17:52:04 <gwern> ddarius: UU?
17:52:13 <bos> glguy: oog
17:52:19 <dobblego> bos, I was just looking at your FileManip work and trying to figure out how you got the links to work in haddock; I couldn't find any reference in the .cabal
17:52:32 <ddarius> It looks like UUAGC is which suggests the rest of it is too.
17:52:40 <glguy> bos: oog?
17:52:42 <bos> dobblego: i didn't do anything unusual
17:52:54 <bos> glguy: segfaults are so distasteful
17:53:02 <dobblego> bos, is there a flag you pass when you Setup.hs haddock?
17:53:05 <gwern> ddarius: I don't think so
17:53:07 <bos> dobblego: nope
17:53:17 <dobblego> hrm, I'll take a closer look, cheer
17:53:18 <dobblego> s
17:53:32 <gwern> wait, on the other hand - http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uuagc-0.9.5
17:53:33 <lambdabot> http://tinyurl.com/ysu75x
17:53:59 * glguy blushes, was wrong about takusen
17:54:12 <glguy> it's a fastcgi interaction with io exceptions
17:54:31 <gwern> (uuagc even cabal-installs nicely. guess there's nothing to do there)
17:55:11 <bos> st. peter's stout goes particularly well with a saturday evening of hacking.
17:55:16 <chadz> glguy: nevermind, scratch that.
17:55:17 <chadz> oops
17:55:38 <chadz> ignore that. accidentally hit up+enter :)
17:55:41 <glguy> heh
17:55:48 <glguy> scratch that "scratch that"?
17:56:06 <chadz> scratch $ scratch $ ...
17:56:07 <monochrom> you need a modal logic
17:56:14 <chadz> :t scratch
17:56:16 <lambdabot> Not in scope: `scratch'
17:56:46 <monochrom> scratch may be a Reader-monad operation so you can nest it.
17:56:48 <bos> as in "Very Modal Model of a Modern, Major, General Type System"
17:56:58 <bos> best paper title ever
17:56:59 <monochrom> haha
17:57:59 <chadz> bos: beer + code = yay
17:58:52 <vincenz> "Thanks to static typing, my drunk coding accidents have gone by 70%."
17:59:44 <bos> @seen dons
17:59:44 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 1m 32s ago.
18:03:49 <phlpp> 02:58:45 < vincenz> "Thanks to static typing, my drunk coding accidents have gone by 70%."
18:03:52 <phlpp> lol :>
18:05:19 <gnuvince_> :)
18:18:26 <travisbrady> does anyone have any hints on how one might modify Parsec.Token.stringLiteral to parse single quoted strings?
18:18:34 <gwern> @seen dcoutts
18:18:34 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 28m 56s ago.
18:18:41 <gwern> dcoutts: http://reddit.com/info/69r8e/comments/c039g6t
18:20:46 <alatter> travisbrady: it looks like you'd need to write your own version of maketokenParser
18:21:00 <alatter> travisbrady: the double-quotes are hard-coded in, it looks like.
18:21:23 <travisbrady> alatter: thank you
18:21:48 <alatter> travisbrady: but it's entirely possible I'm misunderstanding the sources ^_^
18:23:14 <alatter> travisbrady: ah, I am
18:24:24 <alatter> travisbrady: if you create the TokenParser from a LanguageDef using makeTokenParser, the double-quotes are hard-coded
18:24:55 <travisbrady> alatter: but if i use emptyDef?
18:25:00 <ddarius> You can, of course, simply write your own "string literal" parser.
18:25:04 <alatter> travisbrady: now I'm just confusing myself.  So yeah, if you roll the TokenParser by hand you can put anything you want in there
18:25:05 <dbueno> Is it possible with haddock to attach any documentation to a typeclass instance?  For example, to include the time complexity of the instance's methods.
18:25:40 <ddarius> between (char '\'') (char '\'') (many stringChars)
18:25:59 <ddarius> dbueno: Not directly, no.
18:27:16 <dbueno> ddarius: Okay.  In my case since the instance I care about uses a data type specifically to achieve a certain time complexity, I can include the note at that data type's definition.  Do people run into this often, or, is there usually a workaround?
18:28:40 <alatter> travisbrady: calling makeTokenParser on any language def will always produce a TokenParser which expects double-quoted strings.
18:31:15 <noige_> hi
18:31:21 <faxathisia> hi noige
18:36:55 <noige_> so if I say "bob (x:ab) = x + bob ab" the parentheses are saying to take the final two members of the list argument and add x to them
18:37:18 <noige_> it seems so
18:37:30 <faxathisia> > let (x:xs) = [1,2,3,4,5,6,7] in (x, xs)
18:37:35 <faxathisia> x is the head, xs is the tail
18:37:35 <lambdabot>  (1,[2,3,4,5,6,7])
18:37:45 <faxathisia> > let (x:xs) = [] in (x, xs)
18:37:46 <lambdabot>   Irrefutable pattern failed for pattern (x : xs)
18:38:30 <noige_> oh I see, so xs is in fact ALL of the items after the first member of the list
18:38:34 <dolio> faxathisia: Have you looked at the indexed monads in Agda at all?
18:38:36 <faxathisia> yes
18:38:43 <noige_> I understand better now
18:38:46 <noige_> faxathisia: thank you
18:39:04 <faxathisia> dolio, looker over the code but haven' tried to use them
18:40:43 <dolio> Hmm.
18:41:26 <faxathisia> dolio, I started to try and write a type checker for lambda LF..
18:41:39 <faxathisia> anyone who says that's easy is lying ..
18:41:43 <faxathisia> (in haskell)
18:41:49 <pjd> noige_: it might help to consider the definition of []
18:41:52 <pjd> @src []
18:41:53 <lambdabot> data [] a = [] | a : [a]
18:42:16 <alatter> faxathisia: LF?
18:42:38 <dolio> Yeah, I'm not familiar with that, off hand.
18:42:53 <faxathisia> alatter, simply type lambda calculus but you replace -> with forall (x:a), b
18:43:02 <faxathisia> (where x may appear in b)
18:43:06 <dolio> Ah.
18:43:46 * faxathisia frowns at all these papers calling it 'simply easy'..
18:43:52 <pjd> noige_: the function you wrote leads up to a nice concept: folds, or catamorphisms
18:44:16 <noige_> pjd: ok, it is the beginning of the School of Expression book
18:44:28 <dolio> Well, the people who write those papers probably write type checkers all the time. :)
18:44:30 <noige_> it demonstrates types and such in that part
18:44:37 <noige_> and problem solving with recursion
18:45:02 <alatter> faxathisia: is that similar to this: http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html
18:45:03 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
18:45:06 <noige_> pjd: this is very new stuff to me. I come from python and ruby
18:45:16 <faxathisia> alatter, Yeah
18:45:45 <pjd> noige_: i think you'll be getting to folds in SoE soon enough :)
18:45:45 <faxathisia> alatter, That's a bit more general than mine but same pretty much algorithm
18:46:24 <noige_> pjd: :) I am looking forward to some difficult challenges. I feel like I have climbed a mountain so far and all I am doing is writing arithmetic calculators that use recursion
18:46:28 <noige_> hahhaah
18:46:35 <noige_> It is pretty fun so far
18:46:54 <pjd> noige_: the payoff is worth it :)
18:47:56 <pjd> to give you a foretaste of folds:
18:47:56 <pjd> > let sum = foldr (+) 0 in sum [1..5]
18:47:57 <phlpp> what's SoE about?
18:47:59 <phlpp> haskell?
18:48:00 <lambdabot>  15
18:48:13 <pjd> > let product = foldr (*) 1 in sum [1..5]
18:48:14 <lambdabot>  15
18:48:21 <pjd> err
18:48:22 <pjd> > let product = foldr (*) 1 in product [1..5]
18:48:23 <lambdabot>  120
18:48:34 <pjd> > let id = foldr (:) [] in id [1..5]
18:48:35 <lambdabot>  [1,2,3,4,5]
18:48:38 <noige_> hey that is cool
18:48:44 <noige_> that is the same thing using foldr
18:48:51 <noige_> and multiplication
18:48:56 <phlpp> > let sum n = n*(n-1)/2 in sum 5
18:48:57 <lambdabot>  10.0
18:49:03 <phlpp> > let sum n = n*(n+1)/2 in sum 5
18:49:04 <phlpp> doh
18:49:04 <lambdabot>  15.0
18:49:25 <noige_> phlpp: yeah it is an introduction to functional programming using haskell for generating multimedia
18:49:29 <faxathisia> > let xs = [a,b,c,d,f] in ( foldr (flip f) z xs, foldl f z (reverse xs) ) :: ( Expr , Expr )
18:49:34 <lambdabot>  (f (f (f (f (f z f) d) c) b) a,f (f (f (f (f z f) d) c) b) a)
18:49:40 * noige_ has never been exposed to fp before
18:50:11 * faxathisia attempt 3..
18:50:50 <dolio> faxathisia: Anyhow, do you know, off hand, how one would go about constructing a function S : I -> Set that takes elements of some (presumably infinite) index set to arbitrary types (and presumably, Agda can figure out i : I given T : S i, from the looks of it)?
18:51:28 <dolio> I've been considering asking the mailing list, but I don't want to bug them if I'm missing something obvious.
18:52:09 <faxathisia> let me try it..
18:52:53 <jsnx> i have a big file with a compilcated list in it -- [(String, [(String, String)])] -- that has 69212 elements in it
18:53:03 <jsnx> GHC runs out of stack space trying to build the list
18:53:11 <jsnx> is this normal?
18:54:12 <jsnx> https://svn.j-s-n.org/public/haskell/cedict/Data/Char/CEDICT/Lists.hs
18:54:13 <lambdabot> http://tinyurl.com/2j6p8b
18:54:56 <pjd> > let sum n = n*(n+1) `div` 2 in sum 5
18:54:58 <lambdabot>  15
18:55:16 <Cin> jsnx: how come you're not reading that huge list from a file??
18:55:29 <jsnx> Cin: i don't understand
18:55:42 <Cin> jsnx: i mean as opposed to including it in your source code
18:55:48 <jsnx> Cin: it has to be compiled at some point, right?
18:55:59 <Cin> jsnx: could it not be loaded at runtime?
18:56:07 <jsnx> i figured that compiling it early would save my clients a lot of trouble
18:56:18 <pjd> noige_: you might have noticed the the pattern to foldr:  it takes a function to replace (:), and a value to replace []
18:56:55 <jsnx> Cin: you mean like, use read and so forth?
18:57:05 <Cin> jsnx: i don't know if ghc running out of stack space is normal. i think it's probably acceptable, but i dunno
18:57:16 <noige_> pjd: can you show it again?
18:57:17 <Cin> jsnx: yeah. i was just wondering why you are incluing it in your source
18:57:22 <jsnx> Cin: i have to build a Trie out of the list before i use
18:57:23 <jsnx> it
18:57:34 <ddarius> jsnx: GHC doesn't handle large constants well, though I thought it handled it better than that.
18:57:46 <Cin> jsnx: is that used as an assoc list?
18:57:52 <noige_> ahh I forgot that (*) is a function
18:58:01 <jsnx> Cin: no, it's used to build a Trie
18:58:07 <jsnx> ddarius: well, fudge
18:58:17 <noige_> > (*)
18:58:19 <lambdabot>  <Integer -> Integer -> Integer>
18:58:28 <noige_> > :t (*)
18:58:28 <lambdabot>   parse error on input `:'
18:58:37 <noige_> oops
18:58:38 <noige_> haha
18:58:45 <noige_> (*) :: (Num a) => a -> a -> a
18:58:55 <jsnx> so, how would you write a giant DNS server in Haskell, for example?
18:59:14 <Cin> use an external database
18:59:29 <jsnx> Cin: so you mean, don't?
18:59:35 <Cin> jsnx: no?
19:00:04 <jsnx> Cin: yes
19:00:04 <pjd> > foldr (+) 0 [1..5] :: Expr
19:00:05 <lambdabot>  1 + (2 + (3 + (4 + (5 + 0))))
19:00:21 <Cin> jsnx: mysql or oracle or whatever?
19:00:34 <ddarius> jsnx: The usual approach for large constants, in most languages, is to read it in from a file.
19:00:43 <ddarius> (or some other external source)
19:00:46 <noige_> so let product = foldr (*) 1 in product [1..5]
19:00:54 <jsnx> ddarius: read the whole thing?
19:01:05 <ddarius> Why not?
19:01:11 <jsnx> ddarius: wouldn't that just give me the same problem at run time , though?
19:01:14 <faxathisia> dolio, does this relate to what you said? http://hpaste.org/5852/0/plain
19:01:24 <ddarius> jsnx: No.  Reading in data is much simpler than compiling it.
19:01:30 <pjd> noige_: compare that to the list, which is 1 : (2 : (3 : (4 : (5 : []))))
19:01:51 <faxathisia> dolio, If I just wrote: foo : getType' _ -- though.. It can't work out what the meta should be
19:02:00 <jsnx> ddarius: well, maybe you could explain that to me...if i read in the list from a file, it still has to become a list somehow
19:02:05 <pjd> (which is what [1,2,3,4,5] is syntax sugar for)
19:02:05 <jsnx> ddarius: right?
19:02:20 <pjd> noige_: foldr replaced the : with +, and the [] with 0
19:02:22 <jsnx> ddarius: and would there not be compilation of some sort?
19:02:33 <noige_> ahh right
19:02:34 <ddarius> jsnx: No, there is no compilation.
19:02:36 <noige_> ok
19:02:41 <ddarius> jsnx: A compiler takes arbitrary code and makes a program that makes a list at some time.
19:02:49 <jsnx> ddarius: oic
19:02:51 <ddarius> Input just needs to parse.
19:03:10 <pjd> > foldr f z [1..5] :: Expr
19:03:11 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
19:03:17 <gwern> I'll never understand some redditor voters - why on earth would anyone downvote http://reddit.com/info/69r8e/comments/c039g4n ?
19:03:18 <ddarius> s/some time/run-time
19:03:40 <pjd> noige_: that's why foldr (:) [] is the identity function for lists
19:04:00 <noige_> > foldr (:) []
19:04:00 <lambdabot>  Add a type signature
19:04:02 <idnar> > foldl f z [1..5] :: Expr
19:04:03 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
19:04:11 <pjd> :t foldr (:) []
19:04:12 <lambdabot> forall a. [a] -> [a]
19:04:15 <idnar> > foldl (:) [] [1..5] :: Expr
19:04:17 <jsnx> ddarius: so, may be my approach to this is wack
19:04:17 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
19:04:17 <lambdabot>       Expected...
19:04:27 <idnar> hmm, no
19:04:34 <pjd> idnar: :: [Expr]
19:04:38 <jsnx> ddarius: what i should do is dump the list into a text file, and use 'read' on it?
19:04:59 <noige_> foldr unfolds to the right?
19:05:01 <jsnx> and the build the trie?
19:05:06 <pjd> idnar: also foldr :)
19:05:23 <faxathisia> dolio, Do you want to have something like typeclasses? (it chooses implicity which function to call based on the parameter types)
19:05:30 <jsnx> i guess i was hoping to keep my dictionary out of the IO Monad
19:05:38 * araujo wonders what hackage category his package belongs to
19:05:39 <pjd> noige_: it's so called because it's right-associative
19:05:43 <jsnx> now every lookup operation becomes and IO something
19:05:51 <jsnx> s/and/and/
19:05:55 <jsnx> s/and/an/
19:05:56 <dolio> faxathisia: Well, my dilemma is this:
19:06:00 <pjd> > foldr (+) 0 [1..5] :: Expr
19:06:01 <lambdabot>  1 + (2 + (3 + (4 + (5 + 0))))
19:06:03 <pjd> > foldl (+) 0 [1..5] :: Expr
19:06:05 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5
19:06:06 <Cin> gwern: people going on reddit is odd imho. it's either (1) there to promote a language or library, or (2) there to discuss a language or library that people are promoting
19:06:10 <LoganCapaldo> you could unsafePerformIO it
19:06:29 <noige_> AHA!
19:06:31 <noige_> I SEE!
19:06:34 <Cin> gwern: the rest of the discussion is pretty stupid imho
19:06:38 <pjd> (the foldl version leaves the parentheses out, but they're just the other way around)
19:06:43 <faxathisia> noige: foldr.com foldl.con
19:06:44 <LoganCapaldo> that initial read in the data seems liek one of those "this is ok to do with unsafeperformio" things
19:06:45 <jsnx> LoganCapaldo: hmmm, yeah
19:06:54 <noige_> .con
19:06:55 <noige_> hahaa
19:06:58 <noige_> ITS A LIE!
19:07:00 <dolio> faxathisia: Indexed monads tag the monad with two indices, and the indices have to match for >>= to work...
19:07:14 <mauke> > foldl f z [a,b,c,d]
19:07:15 <lambdabot>  f (f (f (f z a) b) c) d
19:07:16 <dolio> faxathisia: Which is useful for, say, writing a state monad where you can change the state type.
19:07:18 * araujo is between 'User Interfaces' and 'GUI'
19:07:19 <mauke> > foldr f z [a,b,c,d]
19:07:21 <jsnx> LoganCapaldo: it feels silly, that's all
19:07:21 <lambdabot>  f a (f b (f c (f d z)))
19:07:51 <dolio> faxathisia: State oldstate newstate a.
19:07:55 <faxathisia> yeah
19:07:56 <noige_> so is the first computation f d z?
19:08:14 <dolio> faxathisia: But the Agda monads are indexed by values of some index type.
19:08:20 <mauke> no, the first computation is f a (...)
19:08:29 <Cin> i've always found storing things other than logic in source code to be silly and odd
19:08:35 <noige_> because of the right association thing?
19:08:35 <mauke> we're doing lazy evaluation, i.e. outside in
19:08:39 <dolio> faxathisia: So, to get back to types, the state monad takes a function S : I -> Set.
19:08:40 <pjd> noige_: you can imagine Haskell evaluating "outside-in"
19:08:43 <LoganCapaldo> jsnx: silly happens ;)
19:08:50 <noige_> ahh ok
19:08:51 <jsnx> Cin: what about functions?
19:08:58 <pjd> so the f a (...) is the term on the outside
19:09:10 <Cin> jsnx: those i would consider logic...
19:09:25 <jsnx> Cin: well, that includes all maps, arrays, tries...
19:09:30 <dolio> So, for instance, put : forall {i j} -> S j -> State i j ().
19:09:34 <mauke> > foldr (\x z -> x) "no" [1 ..]
19:09:36 <lambdabot>   add an instance declaration for (Num [Char])
19:09:36 <lambdabot>     In the expression: 1
19:09:42 <mauke> > foldr (\x z -> z) "no" [1 ..]
19:09:45 <lambdabot> Terminated
19:10:06 <Cin> > repeat "no!"
19:10:07 <lambdabot>  ["no!","no!","no!","no!","no!","no!","no!","no!","no!","no!","no!","no!","no...
19:10:10 <mauke> :(
19:10:33 <dolio> faxathisia: So, how does one construct S? They'd have to know all the different types their state monad would be using before hand and write something like your getType, I guess?
19:10:39 <pjd> > map (\"no!" -> "yes!") $ repeat "no!"
19:10:40 <lambdabot>  ["yes!","yes!","yes!","yes!","yes!","yes!","yes!","yes!","yes!","yes!","yes!...
19:10:51 <noige_> hahhahahaa
19:11:21 <int-e> > unwords . tail . iterate ("no"++) $ "!"
19:11:22 <lambdabot>  "no! nono! nonono! nononono! nonononono! nononononono! nonononononono! nonon...
19:11:50 <mauke> > "you" >> "are" >> "evil!"
19:11:50 <jsnx> Cin: it's too bad that tabulated functions can not be treated on par with their more compact cousins...
19:11:51 <lambdabot>  "evil!evil!evil!evil!evil!evil!evil!evil!evil!"
19:12:18 <int-e> heh
19:12:36 <faxathisia> put : ... -- is defined inside a record right? So you just make S, (const Int) or somesuch?
19:12:45 <jsnx> i'm not sure what could be more efficient than allowing the compiler to boil down a big table for me...
19:13:17 <jsnx> ...if it actually workd :(
19:14:10 <dolio> faxathisia: If all you want is the ordinary state monad, where the state has the same type through the entire computation, you can set the index set to () and S = const Whatever, yes.
19:15:09 <jsnx> oh, you know what
19:15:16 <jsnx> i probably need strictness annotations
19:15:17 <dolio> faxathisia: But for the state monad where the state is allowed to change, you need an index set rich enough to distinguish between all the different types the state will take on over the course of the computation.
19:15:25 <jsnx> and unboxed tuples
19:16:34 <pjd> noige_: here's another tidbit: foldr (:) [] is the identity fold, right?
19:16:52 <faxathisia> You could box type like .. data SomeType : Set2 where ; ty : Set -> SomeType -- so the index set would be SomeType
19:16:52 <noige_> yeah
19:16:56 <Cin> if it wasn't for alonzo church i wouldn't be sat here working on code on my bed with a laptop
19:17:09 <faxathisia> and S could be getType : SomeType -> Set ; getType (ty x) = x
19:17:10 <pjd> > let map f = foldr ((:) . f) [] in map (*2) [1..]
19:17:11 <idnar> > foldl (flip (:)) [] [1..5]
19:17:12 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
19:17:13 <lambdabot>  [5,4,3,2,1]
19:17:28 <dolio> faxathisia: Yeah, but that's a Set2, and the index has to be I : Set.
19:18:23 <mauke> OceanSpray: what are you doing with perl? :-)
19:18:55 <Cin> who mentioned perl?
19:19:18 <mauke> I did! (also, #perl)
19:20:01 <Cin> oh!
19:22:59 <noige_> pjd: this floding business is mindbending
19:23:08 <noige_> fold*
19:23:25 <pjd> noige_: yes, it's awesome :)
19:23:27 <mauke> @src maybe
19:23:28 <lambdabot> maybe n _ Nothing  = n
19:23:28 <lambdabot> maybe _ f (Just x) = f x
19:23:33 <mauke> ^ a Maybe "fold"
19:24:22 <pjd> noige_: ^- that's an example of a fold/catamorphism on another data type
19:24:27 <pjd> @src Maybe
19:24:28 <lambdabot> data Maybe a = Nothing | Just a
19:24:36 <pjd> :t maybe
19:24:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:24:43 <glguy> work in progress http://71.111.57.135/cgi-bin/hpaste.fcgi/
19:24:55 <Cin> ohhh! awesome :DDD
19:24:57 <pjd> you can view maybe as taking a function and value to replace Just and Nothing with
19:25:14 <glguy> git clone http://code.haskell.org/hpaste
19:25:15 <idnar> noige_: not mind-folding? *efg*
19:26:03 * Cin installs git
19:26:08 <wagle_home> :t origami
19:26:09 <lambdabot> Not in scope: `origami'
19:26:12 <wagle_home> darn
19:26:21 <idnar> hrm, suddenly, the general form of folds makes sense to me
19:26:33 <Cin> glguy: swish design
19:26:38 <pjd> everything folds into place
19:26:48 <Cin> pjd: hohoho :P
19:26:48 <noige_> haha
19:26:58 <mauke> foldwned
19:27:01 <pjd> noige_: you can read some more about it here: http://en.wikipedia.org/wiki/Catamorphism
19:27:01 <lambdabot> Title: Catamorphism - Wikipedia, the free encyclopedia
19:27:04 <idnar> you deconstruct every constructor, passing it to an N-ary function to "reconstruct" it
19:27:13 <glguy> Cin: thnx
19:27:33 <pjd> idnar: yep
19:27:38 <pjd> and you recurse where the data type recurses
19:27:53 <idnar> actually, didn't someone write a blog post about how you can use a data structure just by exposing a fold over it, rather than the "actual" structure?
19:27:55 <phlpp> let's get ready to rumble \o/
19:28:53 <mauke> cons a b = \f -> f a b
19:28:57 <idnar> http://sigfpe.blogspot.com/2008/02/purely-functional-recursive-types-in.html
19:28:58 <lambdabot> Title: A Neighborhood of Infinity: Purely functional recursive types in Haskell and Pyt ..., http://tinyurl.com/2cmv9v
19:29:01 <mauke> car p = p (\a b -> a)
19:29:05 <mauke> cdr p = p (\a b -> b)
19:29:11 <idnar> I think that's what I was thinking of
19:30:01 <idnar> "Oh...and I guess you could say this was a form of the visitor pattern. Ugh. It's hideously complicated in C++." -- loved that bit :)
19:30:06 <Cin> cons = \x y f -> f x y
19:30:07 <Cin> hehe
19:30:51 <mauke> yeah, you'd need virtual template functions to do this semi-generally in C++
19:30:55 <glguy> I broke the parent id looking earlier
19:31:08 <glguy> that's why the modification you posted showed up as a new paste
19:32:02 <Cin> (if you're talking to me, i posted a new paste not a mod.)
19:32:13 <glguy> oh
19:32:21 <glguy> someone else did a mod then
19:32:59 <Cin> yep!
19:34:38 <Cin> glguy: what made you decide to switch from happs? =o
19:34:56 <Cin> glguy: or are you just giving fastcgi a try?
19:35:15 <glguy> Cin: just wanted to try a simpler model
19:35:18 <glguy> and to use sqlite as the backend
19:35:22 <glguy> rather than in memory state
19:35:53 <dolio> faxathisia: Here's the only way I can think of to use it, currently (unresolved metas if you remove any of the numbers completely): http://hpaste.org/5852/1/plain
19:36:42 <Cin> glguy: ahh, very cool. i'm working on a similar site with fastcgi and sqlite as the backend, so i can probably scavange some things from your code :¬)
19:36:57 * araujo added it as 'GUI'
19:37:15 <Cin> glguy: (not a paste site, some site for user polls/voting system)
19:37:16 <glguy> Cin: let me know if you have any insights from your work to share if you see somewhere I could benefit
19:37:16 <faxathisia> I've got an idea
19:37:21 <glguy> when scavaging
19:37:30 <Cin> glguy: sure
19:38:55 <Cin> odd question: is there a particular username smtp servers donate to mean "anonymous"?
19:39:34 <Cin> i've been able to send mail with my IPS's smtp server without provide user or pass information in my mail clients .. but i don't know what to specify with an smtp library for the user and password >_>
19:40:09 <monochrom> username and password are optional.
19:40:24 <monochrom> In the very original smtp, there was even no provision for them.
19:41:01 <Cin> hm, this library i'm using fails when i give it nothing. only works if i give it a correct username and password
19:41:10 <Cin> i don't want to include a username and password in my source code -_-
19:41:31 <monochrom> Only recently (relative to the whole 40 years history of darpanet/internet) has smtp be extended to accept username and password because some ISPs need it.
19:41:44 <monochrom> So the library is wrong.
19:41:55 <Cin> i'm using this one, hehe http://www.haskell.org/pipermail/libraries/2003-December/001576.html
19:42:00 <Cin> i guess i'll look for a more complete one
19:42:52 * monochrom was there in 1995 and there was no username or password on any smtp server.
19:43:44 <Cin> well, i got internet access in 1998
19:44:12 <monochrom> The spam problem drove some ISPs to want username and password when you send emails.
19:44:31 <Cin> oh, i see
19:45:01 <monochrom> Before that, everyone assumed good will.
19:48:59 <OceanSpray> Twice have I read today that "call-by-name" is equivalent to "call-by-need"
19:49:02 <OceanSpray> what's with that?
19:49:15 <OceanSpray> can somebody explain?
19:49:34 <monochrom> They are not equivalent, unless you stand from some distance.
19:49:57 <Cin> what are the differences?
19:50:19 <ddarius> Whether they are equivalent depends on the language and what properties you are measuring.
19:50:34 <ddarius> (i.e. on the language and your notion of "equality")
19:51:07 <Cin> or "equivilance"? :P
19:51:26 <monochrom> (\x -> x + x) (4+5)  may help exemplify what they are.
19:52:02 <monochrom> by-name: you get (4+5)+(4+5), then you continue.  note some redundant computation is ahead.
19:52:35 <Cin> ahh
19:52:49 <monochrom> by-need: IIUC it is lazy evaluation, like GHC.  you get let x=4+5 in x+x.  sharing.  No redundant computation ahead if you make sure there is sharing.
19:53:37 <monochrom> I don't call them equivalent because there is a way to cook up a pathological example to get a difference between Theta(n) and Theta(2^n).
19:53:40 <OceanSpray> see: http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps and http://article.gmane.org/gmane.comp.lang.haskell.cafe/36982
19:54:13 <monochrom> However, if you are the kind of people who only distinguishes "terminate" vs "not terminate", they are equivalent.
19:55:52 <OceanSpray> so, it's THAT way.
19:58:35 <dolio> faxathisia: Alternate code with type-indexed monads instead of value-indexed: http://hpaste.org/5852/2/plain
19:59:46 <faxathisia> ohh cool
20:00:12 <faxathisia> I am still trying something but it seems not to be working
20:00:36 <OceanSpray> what's with the "���"?
20:00:39 <dolio> The fz bit is the only niggle, but it could be solved with the equivalent of (fz :: Fin n), I suppose.
20:00:51 <dolio> OceanSpray: Unicode characters.
20:00:58 <OceanSpray> huh.
20:01:12 <ddarius> They also are not equivalent in the presence of side-effects
20:01:12 <monochrom> It is ℕ
20:01:16 <Cin> oceanpray: i'm curious; what browser are you using?
20:01:22 <dolio> If you view it raw they show up. The syntax hilighter doesn't like them, or something.
20:01:59 <monochrom> syntax hilighter uses wrong encoding and decoding
20:02:30 <monochrom> if you put utf-8 inside comments, ironically it is preserved :)
20:02:55 <dolio> Yeah, I assume that's because it doesn't try to parse them or something?
20:03:06 <monochrom> Something like that.
20:03:18 <OceanSpray> Cin, firefox
20:04:07 <monochrom> browser can't fix it because the mis-processing is on the server.
20:04:53 <jeffz> the w3 validator says \xE2 does not map to unicode
20:05:25 <Cin> well the paster isn't encoding it to utf-8 so it's probably wrong
20:06:06 <monochrom> To find out what the paster did, use raw, or even just click on "annotate".
20:06:24 <monochrom> There I assure you you will find that the paster used quite standard utf-8 alright.
20:11:52 <gwern> http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi <-- bizarre little haskell survey
20:11:53 <lambdabot> Title: Haskell Users Survey
20:12:51 <Cin> i'm not qualified to answer because i started learning in january D:
20:13:17 <gwern> heh. I just said 2005
20:13:20 <Cin> gwern: have you already been spammed?
20:13:28 <gwern> Cin: about what?
20:13:41 <Cin> gwern: under tools :\
20:13:48 * wy finaly finished his parser with tons of hacks
20:13:54 <Cin> gwern: ah, i thought it was yours. s/you/he
20:13:58 <faxathisia> hacks galore!
20:13:58 <dons> gwern: its a survey from the old history of haskell paper
20:14:05 <gwern> I particularly like how in the results you see votes for all the nonsense ones - http://www.cs.chalmers.se/~rjmh/Wash/Survey/Survey.cgi
20:14:06 <lambdabot> Title: Haskell Users Survey
20:14:07 <wy> and hacks on hacks
20:14:16 <wy> ;)
20:14:18 <gwern> ie, '2% <a href=http://w.zbtym.cn/iujtcall.html>http://w.zbtym.cn/iujtcall.html</a>'
20:14:18 <lambdabot> http://w.zbtym.cn/iujtcall.html>http://w.zbtym.cn/iujtcall.html</a>'
20:14:26 <gwern> must be a useful library
20:14:29 <Cin> and that's why my poll web site will require registration
20:14:44 <monochrom> haha gwern
20:14:55 <dolio> dpiponi: I thought your latest article was nice, depite earning you the title of 'topology noob.'
20:15:09 <gwern> some of the libraries need shorter names, though, for example: '0% Frenchman Xavier Peugeot is the great great grand nephew of company founder Armand Peugeot, whose name adorns millions of cars worldwide. Considering the Peugeot family today is reputed to be worth an estimated $5 billion, Xavier looks neither like a tycoon nor does he behave like one. In his first interview with Australian media, he was unfailingly polite and candid, expressing an ...
20:15:10 <gwern> ... understanding of the Australian car scene where Peugeot has been imported since the early 1900s. He is focused on the brand, its future and how Peugeot sits in a competitive global market. The PSA Peugeot Citroen group is the second biggest volume carmaker in Europe, and counts Australia as one of its...<br><a href='http://best-news-blog.com/news/719'>http://best-news-blog.com/</a>'
20:15:10 <lambdabot> http://best-news-blog.com/news/719'>http://best-news-blog.com/</a>'
20:15:15 <gwern> well, with a library name like that, no wonder no one uses it!
20:16:15 <Cin> Xavier
20:16:23 <Cin> get out of my head, Charles!
20:17:02 <Cin> http://erroraccessdenied.com/files/images/xmen.preview.jpg  >_>
20:17:11 <gwern> Cin: the cerebro knows all!
20:17:51 <gwern> so... is that an x-lolcat?
20:18:23 <Cin> gwern: it is from a time before "lolcats" and icanhascheezburger
20:18:45 <gwern> are you sure? the wording seems suspiciously lolist
20:18:48 <gwern> *lolish
20:19:15 <wy> The lookahead problem is solved so ugly. I got tokens like "class A extends B" from the lexer and break them up in the parser
20:20:12 <Cin> gwern: yeah, suspiciously, subtly. the ones people come up with these days on popular web sites are OTT and bastardised. >.>
20:21:44 <banbh> hi, i have a question about strict IO.  suppose i want to (a) read a file and (b) execute a System.Cmd.system; and I want (a) to precede (b) because the command may alter the file.  what is the best way to do this?  should i use seq?
20:23:24 <gwern> Cin: maybe it's a proto-lolcat - an early mutation
20:23:25 <Cin> banbh: i think using a do should sequence your actions in order
20:23:57 <Cin> banbh: (or any bind-derived construct)
20:24:05 <Cin> am i right?
20:24:25 <dolio> You can't use readFile or the like, though, because that does lazy IO.
20:24:36 <atp> hey guys
20:24:38 <banbh> Cin: it doesn't seem to.  i can hpaste some simple code if you like
20:24:39 <dolio> Or, you have to make sure that you read it fully.
20:24:41 <allbery_b> Cin: lazy I/O confounds that
20:24:53 <allbery_b> force the output before doing the system
20:25:14 <Cin> whoops i read and completely forgot about the reading part
20:25:19 <banbh> dolio: yes, i was using readFile;  what is a strict equivalent?
20:25:21 <atp> can anyone here point me to a good document or article on strictness analysis (ie, the theory behind it)
20:25:23 <Botje> :t ($!)
20:25:26 <lambdabot> forall a b. (a -> b) -> a -> b
20:25:32 <Cin> banbh: perhaps you can use `evaluate' on the list read in from the file
20:25:47 <dolio> banbh: I don't think there is one. But you can use, say...
20:25:50 <Cin> banbh: like evaluate (length contents)
20:26:22 <dolio> banbh: 'do a <- readFile whatever ; length a `seq` system ...'
20:26:28 <dolio> Or use evaluate, yeah.
20:26:39 <wy> Maybe I can get information from you guys about schools in Europe. I don't know how the environment is different from that of US.
20:26:51 <banbh> dolio: that looks good; i'm trying now ...
20:27:13 <Cin> wy: i finished school at 15, england. i hear in the us you finish at 18?
20:27:22 <gwern> http://community.livejournal.com/evan_tech/ <-- it's a little eery to look at a blog you've never seen before, and abruptly recognize that they are discussing something you wrote, and folks like jwz are commenting
20:27:22 <lambdabot> Title: evan_tech -- Recent Entries
20:27:32 <wy> I mean graduate school. Do you take lots of courses, or just do research?
20:27:43 <wy> Cin: That's cool.
20:27:51 <Cin> wy: not really, i suck at math :P
20:28:11 <wy> Cin: Do you mean high school or college?
20:28:15 * gwern was actually totally creeped out for a moment until I brought it under control
20:28:22 <Cin> wy: high school
20:29:06 <wy> Cin: I meant actually college. But graduate from hight school at 15 is nice
20:29:27 <Cin> anyone got a decent e-mail validating regex?
20:29:47 <gwern> Cin: lol
20:29:50 <Cin> (there are tonnes on google, but, well, decent?)
20:29:53 <cjb> Cin: perldoc -q address does, I think.
20:30:01 <atp> Cin: it isn't really possible to build one, actually, because of comments
20:30:06 <cjb> Many are tempted to try to eliminate many frequently-invalid mail addresses
20:30:07 <cjb>        with a simple regex, such as "/^[\w.-]+\@(?:[\w-]+\.)+\w+$/".
20:31:05 <cjb> I guess it doesn't give you unless you count that one.
20:31:23 <Cin> hm
20:31:26 <gwern> still amazes me email addresses are allowed to have comments. I mean, is an email address a name, or source code for a nonturing complete programming language?
20:31:28 <Cin> atp: what's a comment?
20:31:40 <atp> gwern: yeah, it was stupid to include it
20:31:58 <cjb> there are also legal-but-wtf cases such as user@[1.1.1.1]
20:32:03 <wagle_home> you sure sendmail.cf files arent turing complete?  8)
20:32:11 <atp> gwern: but you know, sendmail's config file language is turing complete.  it's entirely possible that people back then were braindead
20:32:16 <atp> haha
20:32:21 <bd_> It might've been useful for UUCP paths
20:32:21 <vincenz> gwern: eh?
20:32:21 <atp> jinx, wagle_home
20:32:24 * Cin chortles
20:32:35 <gwern> atp: but they couldn't've all been brain-dead, since they managed to come up with haskell
20:32:55 <atp> gwern: i actually meant the ones involved in the email standards :)
20:33:06 <monochrom> An email address is a electronic name, but we also like to know its human name.
20:33:28 <bd_> foobie!bleth!nxor!user ;; Don't send directly from foobie->nxor, as this only runs once a month
20:33:31 <bd_> or something
20:33:37 <Zao> I suppose <> are comment delimiters as well?
20:33:38 <atp> monochrom: but do you need comment nesting?
20:33:42 <gwern> atp: well, I won't disagree with that
20:33:50 <allbery_b> I have seen a regex that implements RFC-compliant address matching, it is huge and ugly
20:33:51 <monochrom> Oh, nesting is sinister then. :)
20:33:58 <gwern> vincenz: eh yourself
20:34:04 <atp> comment nesting is what makes validating an e-mail by regex impossible
20:34:12 <atp> without using perl's crazy turing-complete regex-fu
20:34:51 <cjb> Cin: The short answer is that there should be an equivalent to perl's Email::Valid module on Hackage, and if there isn't then you just volunteered to write it ;-)
20:34:54 <allbery_b> (and I don't know if it handles commentnesting properly)
20:35:07 <Cin> okay, i'll go with a nice simple one. it won't be that i don't support advanced e-mails, it'll be that i don't allow people with naughty e-mails to use my web site
20:35:23 <byte-> hello
20:35:28 <byte-> I'm having trouble with a type error.
20:35:37 <allbery_b> note that I and many other people will hunt you down if it rejects plussed addresses :)
20:35:42 <allbery_b> (foo+bar@...)
20:35:54 <byte-> I'm defining an instance of `Show' for functions of type 'Value -> Value'
20:35:59 <allbery_b> @paste the source and the error, byte-?
20:35:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:36:22 <byte-> whoops
20:36:26 <byte-> accidentally closed the terminal...
20:36:30 <monochrom> byte-: I ask you to not do that.  Find an alternative for your real goal.
20:36:34 <Cin> allbery_b: that's just asking for trouble
20:37:05 <byte-> monochrom, what's wrong with what I'm doing?
20:37:17 <allbery_b> yeh, Show for functions is almost never what you really want.
20:37:23 <Zao> Cin: And a terrific way of making mailing lists and avoiding email reselling.
20:37:26 <bd_> byte-: You can't inspect a function type, so what are you expecting it to do?
20:37:32 <allbery_b> What problem are you trying to solve with this?
20:37:35 <monochrom> It is advanced. You likely want something else. You can insist, though.
20:37:40 <byte-> print out "Func (Value -> Value)"
20:37:41 <bd_> And how would you define the corresponding Read instance?
20:37:48 <byte-> I suppose I could rework it
20:37:52 <glguy> > getLine
20:37:57 <lambdabot>  <IO [Char]>
20:38:12 <allbery_b> (that said:  http://hpaste.org/2814 might be of interest
20:38:19 <Cin> zao: why is that? what is the plussed address for?
20:38:34 <byte-> monochrom, what's "advanced" about it?
20:38:56 <allbery_b> many IMAP servers use a+b to mean folder b for account a; many people use a+b to "tag" addresses
20:38:59 <monochrom> You get type errors, and there are advanced options you can turn on to suppress that.
20:39:21 <gwern> 'diplomacy judge parser + renderer in haskell ' <-- hm
20:39:33 <Zao> Tagging your email every time you hand it out will reveal if it's given away to unscruplous people.
20:39:46 <atp> the only time i can think of ever defining a show instance for a function was when investigating binary operators on a finite set that i knew beforehand
20:39:56 <Zao> And allows for easier procmail filtering.
20:40:05 <byte-> monochrom, ok
20:40:07 <byte-> I'll rework it, then.
20:40:18 <bd_> atp: it'd make deriving Show instances on data structures containing function-typed fields somewhat more convenient
20:40:22 <Zao> Much like some people give out slightly different names when handing out physical mail addresses.
20:40:42 <allbery_b> also, most spammers seem to mishandle plussed addresses, a nice bonus
20:41:38 <allbery_b> atp: I use it for debugging, which is mostly what I use show for
20:42:14 <allbery_b> (yes, show/read for serialization is convenient, but it's *slow*.  use Data.Bianry instead)
20:42:20 <gwern> oh, so that's what Whim is, it's a window manager in haskell - http://neugierig.org/software/darcs/whim/
20:42:21 <lambdabot> Title: Index of /software/darcs/whim
20:42:24 <gwern> interesting
20:42:43 <gwern> hm. Window Haskell I-something Manager?
20:43:08 <Zao> Window Haskell Infix Manager.
20:43:12 <Zao> :P
20:43:30 <gwern> no, you meant Window Haskell `Infix` Manager
20:44:00 <atp> speaking of window managers in haskell, i just upgraded my debian system and xmonad apparently changed versions on me... now when i start a terminal it opens up gnome-terminal instead of my urxvt, which makes me think it isn't seeing my config file...
20:44:07 <Cin> What Haskell Is Made-of
20:44:16 <atp> sugar and spice and everything nice?
20:44:19 <Cin> ^_^
20:44:20 <byte-> how's WHIM different from xmonad?
20:44:20 <allbery_b> windowed haskell interface manager?
20:44:27 <gwern> atp: did you jump from <0.4 to 0.5>?
20:44:29 <monochrom> Haskell is made of Curry.
20:44:38 <atp> gwern: it's possible, i hadn't dist-upgraded in a long while.
20:44:41 <gwern> byte-: I have no idea. ask me when I've compiled it :)
20:44:49 <Cin> this sandwich is pure, it is made of haskell and curry
20:44:49 <atp> gwern: i think before there was some xmonad-build thing
20:44:55 <gwern> atp: fun. your config file now lives in .xmonad/xmonad.hs
20:44:55 <dons> gwern: evan was working on it before xmonad came along
20:45:09 <atp> gwern: ah.  so if i rename Config.hs to xmonad.hs it should work?
20:45:09 <gwern> dons: yes, it says 2006, which is before xmonad iirc
20:45:19 <dons> yep
20:45:20 <gwern> still be nice to have on hackage. evan has a fair bit of stuff
20:45:25 <dons> definitely.
20:45:28 <dons> grab it all :)
20:45:29 <Cin> xmonad only came out in 2007, i am surprised
20:45:34 <gwern> atp: no, not really. you may wish to consult the fine documentation or #xmonad...
20:45:42 <gwern> Cin: well, we moved pretty darn quickly
20:45:47 <atp> dons, maybe you know.  what's a good paper to read on strictness analysis?
20:45:54 <atp> gwern: uh oh.  much changed, eh?
20:46:02 <dons> hmm. there are classic papers from the late 80s and early 90s, atp
20:46:06 <gwern> atp: if you really were using .4 and lower, you might as well throw away your config file, I guess I should say
20:46:08 <dons> atp, only the configuration mechanism
20:46:13 <monochrom> How can I run two window managers? It's even harder than marrying two wives...
20:46:14 <atp> dons: any you'd recommend?
20:46:27 <allbery_b> completely radically changed configuration, yes
20:46:32 <glguy> monochrom: Xnest
20:46:38 <allbery_b> xe[phyr, Xnest, VNC
20:46:41 <gwern> monochrom: carefully
20:46:50 <monochrom> Oh Gosh, wish wives were that easy...
20:47:03 <dons> atp, http://haskell.org/haskellwiki/Research_papers/Compilation#Strictness
20:47:03 <lambdabot> http://tinyurl.com/2pwstx
20:47:12 * gwern wonders what a PowerMate is and why you'd write a haskell binding to it
20:47:21 <byte-> monochrom, you don't have to do anything to get them running together.
20:47:29 <atp> dons, hm, john hughes?
20:47:34 <byte-> you do need to create a device to look into the alternate universe, though.
20:47:54 <maskeye> can anyone take a look over here http://hpaste.org/5846, i'm trying to build a package and the georadi bot both complains about missing stuff from the base package :\
20:49:18 <gwern> maskeye: wotcher building?
20:49:26 <Zao> gwern: geordi, the C++ eval bot.
20:49:47 <gwern> oh, of course
20:49:49 <Zao> All the duct tape in it is Haskell.
20:49:57 <gwern> @hoogle Foreign.C.Types.CInt -> Int
20:49:58 <lambdabot> No matches, try a more general search
20:50:07 <gwern> @hoogle CInt -> Int
20:50:08 <allbery_b> maskeye: what version of ghc?
20:50:08 <lambdabot> No matches, try a more general search
20:50:25 <maskeye> allbery_b, 6.4.2
20:50:34 <allbery_b> doesn't have Traversable
20:50:38 <gwern> maskeye: well, that explains it
20:50:59 <maskeye> oh, so I should downgrade?
20:51:00 <allbery_b> @instances-importing Foreign.C.Types Integral
20:51:03 <lambdabot> CChar, CInt, CIntMax, CIntPtr, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort, CWchar, Int, Integer
20:51:05 <Zao> A gentoo box with an ancient GHC, that's surprising.
20:51:10 <allbery_b> upgrade, 6.4.2 is ancien
20:51:11 <Zao> maskeye: Current is 6.8.2
20:51:17 <maskeye> ouch :+
20:51:28 <allbery_b> gwern: as above.  fromIntegral
20:51:33 <Zao> More specifically, geordi needs 6.6.1 and up.
20:51:33 <maskeye> well, I feel stupid, thanks for the enlightment :)
20:51:39 <gwern> maskeye: believe you me, you'll save yourself a lot of trouble in the long run by upgrading
20:52:01 <gwern> allbery_b: ah. I was just about to look at the integral class http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AIntegral but you did my thinking for me :)
20:52:02 <lambdabot> http://tinyurl.com/ovjef
20:52:02 <allbery_b> not to mention that 6.8.2 is both faster and produces faster executables
20:54:18 <allbery_b> gwern: you can also work it backwards with ghci, :i CInt will tell you among other things that it is Integral and Enum
20:54:48 <gwern> wouldn't I need to import Foreign.C.Types first?
20:54:51 <allbery_b> either of which gives you a way to coerce to Int (fromIntegral and fromEnum respectively)
20:55:06 <allbery_b> you'd need to do so to talk about CInt at all
20:55:25 <allbery_b> @hoogle CInt
20:55:26 <lambdabot> Foreign.C.Types.CInt :: data CInt
20:55:26 <lambdabot> Foreign.C.Types.CIntPtr :: data CIntPtr
20:55:26 <lambdabot> Foreign.C.Types.CIntMax :: data CIntMax
20:55:42 <hpaste>  banbh pasted "Strictness and IO" at http://hpaste.org/5853
20:56:13 * gwern does a little hoppity-dance - whim compiled
20:56:26 <banbh> dolio: i tried using seq but i think i'm missing something
20:57:14 <banbh> dolio: in the paste above what happens is the both md5s are computed after the system call
20:57:55 <glguy> ?seen dons
20:57:55 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 10m 51s ago.
20:58:31 <noige_> This is a pretty intense process
20:59:19 <wy> I'm looking at Lava. It seems functional programming is especially good for circuits
20:59:25 <dolio> banbh: show isn't strict. If you want to deepSeq, the easiest way is to import Control.Parallel.Strategies (I believe) and use 'rnf originalDigest `seq` whatever'.
20:59:53 <dons> glguy: yo
20:59:54 <banbh> dolio: thx
21:00:08 <dons> dolio: yep. we should even move the strategies into base...
21:00:17 <dons> since i use them in a lot of non-parallel code
21:00:46 <wy> I wonder if VHDL is also a kind of functional language
21:01:50 <glguy> dons: I sent you something to your univ email
21:01:55 <glguy> didn't know if you used that now though
21:02:41 <dons> ah ha
21:04:09 <gnuvince_> dons: will RWH discuss parallelism?
21:04:55 <dons> yes!
21:05:08 <OceanSpray> > 4 ^ 1.5
21:05:19 <dons> it wouldn't be haskell without concurrency and parallelism
21:05:22 <lambdabot>  Add a type signature
21:05:51 <OceanSpray> > (4 ^ 1.5) :: Fractional
21:05:51 <lambdabot>      Class `Fractional' used as a type
21:05:51 <lambdabot>     In the type `Fractional'
21:05:51 <lambdabot>     In an...
21:05:57 <OceanSpray> uhh
21:06:05 <OceanSpray> > (4 ^ 1.5) :: Real
21:06:05 <lambdabot>      Class `Real' used as a type
21:06:05 <lambdabot>     In the type `Real'
21:06:05 <lambdabot>     In an expression ...
21:06:09 <OceanSpray> shit.
21:06:13 <OceanSpray> > (4 ^ 1.5) :: Float
21:06:14 <lambdabot>  Add a type signature
21:06:23 <OceanSpray> > (4 :: Float ^ 1.5) :: Float
21:06:23 <lambdabot>  Parse error at "^" (column 13)
21:06:30 <scook0> (^) and (^^) only allow integral exponents
21:06:31 <OceanSpray> > ((4 :: Float) ^ 1.5) :: Float
21:06:31 <lambdabot>  Add a type signature
21:06:38 <scook0> > 4 ** 1.5
21:06:41 <lambdabot>  8.0
21:06:52 <OceanSpray> > 3.5 ** 5.6
21:06:54 <lambdabot>  1113.7328982650954
21:06:58 <OceanSpray> alrighty then.
21:07:25 <gnuvince_> dons: cool.  I'm definitely going to be buying a copy when it comes out.
21:07:29 <gwern> @hoogle getArgsAndInitialize
21:07:30 <lambdabot> No matches found
21:07:39 <OceanSpray> :index (**)
21:07:47 <OceanSpray> @index (**)
21:07:47 <lambdabot> Prelude
21:07:51 <jsnx> it's true that there are statically typed, strongly typed, type inferring languages that are a little more "mainstream" than haskell
21:07:57 <jsnx> oops
21:09:26 <gnuvince_> jsnx: like C# 3.0?
21:09:40 <OceanSpray> what class is ** in?
21:09:51 <gnuvince_> :info (**)
21:10:04 <gnuvince_> That doesn't seem to work here.
21:10:14 <glguy> jsnx: what's an example that does more than the most trivial type inference
21:10:56 <lament> glguy: to have non-trivial type inference, you need non-trivial types first. That's where the problem is, with mainstream languages :)
21:13:01 <seafood___> Lemmih: Still there?
21:13:10 <seafood___> How do you use cabal-install?
21:14:41 <BMeph> Whee, time to reboot the box...
21:15:39 <gwern> @hoogle exitWith
21:15:40 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
21:16:36 <Cin> why are some Setup.hs and some Setup.lhs?
21:16:55 <Cin> why do people use .lhs for that purpose? =o
21:17:10 <gwern> Cin: it's random
21:17:14 <Cin> (for cabal setups)
21:17:28 <gwern> I figure people just copy setup.[l]hs from whatever repo they have handy
21:17:53 <gwern> ie, if they also have xmonad avaiable when they are cabalizing, they copy its Setup.lhs, or if HaXml, they'll copy Setup.hs etc.
21:19:33 <Cin> i has to type Setup.*, hehe
21:19:39 <gwern> no
21:19:45 <gwern> runhaskell Setup configure works just fine
21:19:53 <gwern> that's what I do, to avoid the issue
21:21:05 <Cin> oh, clever
21:21:17 * Cin puts on rob zombie - dragula
21:21:31 <Cin> time to hack some sqlite!
21:23:10 <gwern> it would've been cooler if you said - time to HACK THE MATRIX
21:23:20 <bparkis> lexical environments--first class objects?  evalInLexEnv? getLexEnv?
21:23:22 <Cin> hack the gibson? :P
21:23:53 <gwern> Cin: that's a good oldschool alternative, yes
21:24:08 <gwern> or perhaps 'hack the black ice' for another cyberpunk ref
21:24:54 <Cin> more like get hacked BY the black ice, am i right
21:25:16 <gwern> that's why it's black crypto
21:25:31 <gwern> he got his brains fried, iirc
21:25:43 <siti> mmmh fried brains
21:25:49 <seafood___> No
21:26:01 * seafood___ wrote that in the wrong window
21:26:10 <gwern> yes?
21:26:27 * gwern ponders whether the correct response was yes or no
21:26:37 <Cin> "is there anything haskell can't do?"
21:26:51 <dons> ?faq
21:26:51 <lambdabot> The answer is: Yes! Haskell can do that.
21:26:59 <gnuvince_> Hahaha
21:27:00 <Cin> :P
21:27:12 <gnuvince_> But there is plenty Haskell can't do
21:27:27 <gnuvince_> It can't compile a program that is not correctly typed.
21:27:35 * Cin facepalms
21:27:52 <siti> what a lame language that can't compile when the code is incorrect :S
21:28:43 <gnuvince_> siti: that's why it's not used more in the industry.
21:28:52 <siti> lol
21:29:08 <siti> yeah crappy languages create jobs
21:29:16 <gnuvince_> Indeed
21:30:16 <OceanSpray> everybody should program in INTERCAL.
21:30:50 <gnuvince_> If that could scare the sucky consultants who end up on TheDailyWTF, it might be a good idea ;)
21:33:41 <gnuvince_> @hoogle a -> [a] -> [[a]]
21:33:45 <lambdabot> No matches, try a more general search
21:33:51 <gnuvince_> @hoogle [a] -> a -> [[a]]
21:33:51 <lambdabot> No matches, try a more general search
21:34:11 <noige_> @hoogle noige
21:34:11 <lambdabot> No matches found
21:34:27 <gwern> brethren! I have, on a whim, gifted you with a new (old) window manager! behold: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/whim-0.1
21:34:28 <lambdabot> http://tinyurl.com/367qzb
21:34:40 <gwern> gaze upon it. cabal-install upon it. complain upon it
21:35:17 <bparkis> ordinarily a continuation (from call/cc) is considered only as a function that you can call with a value, but what if it had more data attached to it?  for example what if the continuation explicitly contained its lexical environment in a way that other code can access
21:36:04 <bparkis> and update, changing the variable bindings to derive a new continuation from the old
21:36:22 <Cin> there are some papers, and a schemey language based, on first-class environments
21:36:37 <bparkis> ooh, what's the name
21:36:50 * Cin  trying to remember
21:38:29 <Cin> ah
21:38:30 <Cin> Kernel
21:38:42 <gwern> :( the helium guys  still haven't replied to me
21:38:42 <Cin> http://en.wikipedia.org/wiki/Fexpr#Example
21:39:32 <Cin> bparkis: fexprs used to be around in old lisps but are not deprecated. i still find them or similar ideas pretty interesting
21:39:38 <Cin> s/not/now
21:40:13 <bparkis> i'm thinking that the type of things you do with XML and schemas could be interpreted as evaluating the XML in a certain lexical environment
21:40:20 <bparkis> (for instance)
21:41:29 <Cin> hrm =o
21:43:11 <wagle_home> in franz lisp, fexprs were performed at run-time by the interpreter, and at compile-time by the compiler..  made them confusing..  the important idea for scheme was to have them ALWAYS expand at "compile-time" (even by the intepreter), making them lots more sane
21:43:45 <Cin> indeed. harder to reason about than macros
21:46:01 <OceanSpray> oy
21:46:43 <OceanSpray> since the topic drifted to this, I might as well:
21:47:01 <OceanSpray> https://sourceforge.net/projects/screw
21:47:40 <OceanSpray> It ain't THAT hard to reason about.
21:48:16 <brailsmt> I'm struggling finding something to program for my first haskell program, any suggestions for some simple programming exercises for a haskell n00b?  (i've already implemented fibonacci and factorials and played with currying)
21:48:33 <wagle_home> its hard to reason about if it sometimes happens at runtime and sometimes at compiletime
21:49:09 <Cin> brailsmt: perhaps a simple game player or solver
21:50:03 <gnuvince_> wagle_home: I like to implement a cribbage counter program when I learn a new language.
21:50:07 <gnuvince_> err
21:50:15 <gnuvince_> brailsmt: that last message was for you
21:50:29 <gnuvince_> brailsmt: if you know the rules of Cribbage, you could go ahead and try to implement that.
21:51:03 <gwern> @hoogle CString
21:51:06 <lambdabot> Foreign.C.String.CString :: type CString
21:51:06 <lambdabot> Foreign.C.String.CStringLen :: type CStringLen
21:51:06 <lambdabot> Data.ByteString.packCString :: CString -> IO ByteString
21:51:15 <brailsmt> cribbage, never played it...
21:51:36 <gwern> implement a perfect tetris player
21:51:45 <gwern> then extend it for more complex variants
21:52:27 <gwern> @hoogle bracket
21:52:28 <lambdabot> Control.Exception.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:52:28 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
21:52:28 <lambdabot> Control.Exception.bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:53:38 <noige_> so I figured out how to do ranges
21:53:39 <blargeyfarg> brailsmt: i always start with a MUD.  i/o, networking, concurrency...
21:53:55 <noige_> but what about variable lenght lists as arguments to a function?
21:53:58 <Cin> gwern: i didn't know it was possible to create a perfect one. how can you know it's perfect if the game goes on forever?
21:54:15 <noige_> I tried this: cons8 :: [Integer] -> [Integer]
21:54:15 <noige_> cons8 [x] = 8:[x..10]
21:54:16 <noige_> which works
21:54:16 <noige_> wait
21:54:16 <noige_> I know!
21:54:17 <Cin> blargeyfarg: and implementing a scheme? :D
21:54:26 <noige_> [x:etc]?
21:54:56 <gwern> Cin: you know it's perfect because it loses after a long time :) it was proven a while back through brute force that in original tetris, you eventually get a bad run of blocks which kills you
21:55:32 <gwern> but maybe that's too hard; start with tic-tac-toe then?
21:56:17 <Cin> gwern: well i do suppose at some point you have to get all the crappy blocks one after another, assuming it is completely random
21:56:17 <Cin> i did connect4, which was my first haskill project, and sucked, but was also great pracise
21:56:28 <wy> wagle_home: What are fexps?
21:56:37 <Cin> wy: unevaluated expressions
21:56:37 <brailsmt> thx for the suggestions, but those are a bit too involved for a guy that is so new to the language...  :/  I think i might just do 8 queens or do some sort algorithms...
21:56:51 <Cin> wy: http://en.wikipedia.org/wiki/Fexpr
21:56:52 <lambdabot> Title: Fexpr - Wikipedia, the free encyclopedia
21:57:08 <brailsmt> i'd like to eventually do a toy language interpreter...
21:57:15 <Cin> 8-queens should pretty much be one function
21:57:16 <brailsmt> anyway, thx for the suggestions
21:57:51 <wy> Cin: call-by-name?
21:57:51 <brailsmt> Cin: perhaps for someone with experience
21:57:53 <Cin> brailsmt: there's always Euler, but don't post your solutions!!!
21:58:08 <bparkis> is call/cc referentially transparent? i would think it is not but i've heard the statement that including it is equivalent to including a rule (a -> b) -> a -> a
21:58:25 <Cin> wy: well it's more that you evaluate them when you want to. like using EVAL in the lisps
21:58:27 <bparkis> and also i think someone said yesterday that including call/cc gives you classical logic
21:58:33 <bparkis> as opposed to intuitionist logic
21:59:07 <gwern> I remember reading an interesting paper that continuations implement proof by contradiction
21:59:09 <pjd> bparkis: regarding inspecting continuations, that reminds me of http://pagesperso-systeme.lip6.fr/Christian.Queinnec/WWW/Continuation.html
21:59:09 <blargeyfarg> cin: how does that differ from the delay/force mechanism?
21:59:10 <lambdabot> Title: C. Queinnec's work on continuations, http://tinyurl.com/2wumhx
22:00:14 <blargeyfarg> cin: sorry... i'm in scheme land, and that was a general question ;)
22:00:15 <ddarius> bparkis: call/cc is rather impure
22:00:35 <Cin> blargeyfarg: it's like a macro, except what it returns isn't automatically evaluated
22:00:40 <bparkis> as i expected but then how does it have any meaning in the curry howard correspondence if it is impure?
22:01:41 <Cin> wy: i don't think it can be called call-by-name because you can use what is passed as first-class values, print them out or whatever, and then choose to evaluate them, producing new first-class values, if you follow
22:01:46 <brailsmt> i know the haskell equivalent to cons, what are the car and cdr equivalents?
22:01:54 <wy> Cin: I really should recall my knowledge of the syntactical level thing
22:01:55 <ddarius> bparkis: Things don't have to be pure to correspond to something via CH and also there are variations that are better behaved, e.g. the lambda-mu calculus.
22:01:57 <gwern> head, tail?
22:02:01 <gnuvince_> brailsmt: head and tail
22:02:11 <brailsmt> gwern, gnuvince_: thx
22:02:14 <wy> Cin: I see. they are symbols
22:02:17 <ddarius> brailsmt: There isn't exactly one as cons is used for many different things in lisps.
22:02:18 <Cin> wy: akin to '(+ 1 2) vs (eval '(+ 1 2))
22:02:19 <Cin> wy: right
22:02:36 <wy> Cin: Nice thing. That's missing from many other languages
22:02:48 <Cin> wy: but i think the environment is implicit or passed explitly (for evaluation)
22:03:08 <wy> Cin: Is there environment there?
22:03:18 <Cin> wy: i agree, i really like the reflection quotation and quasiquotation provide
22:03:33 <brailsmt> ddarius: i don't know about any other meaning for them then the first element of a list and the rest of the elements in the list
22:03:48 <Cin> wy: well, typically, like scheme, eval takes an environment as a second argument, if that's what you mean be "is there one there?"
22:03:55 <brailsmt> ddarius: i've done just enough scheme to sound semi-literate about it  :)
22:04:10 <Cin> wy: check out the example on the link i gave
22:04:13 <wy> Cin: Oh, got it. I didn't normally use environment
22:04:18 <Cin> wy: ah, okay
22:04:30 <brailsmt> emphasis on the *semi*
22:04:37 <wy> Cin: I didn't get the link since I just walked in
22:04:40 <ddarius> brailsmt: All cons does is make a pair.  You can use them and they commonly are used to model pairs (obviously), lists, trees.
22:04:52 <wy> Cin: you mean the wikipedia one?
22:04:57 <Cin> wy: yeah
22:05:06 <wy> Cin: OK. thanks
22:05:10 <OceanSpray> ;_;
22:05:18 <brailsmt> ddarius: right, i'm looking to do some basic data structure stuff to ease into haskell
22:05:22 <Cin> @let cons x y f = f x y
22:05:25 <lambdabot> Defined.
22:05:31 <Cin> @let car x y = x
22:05:32 <lambdabot> Defined.
22:05:41 <Cin> > car (cons 1 2)
22:05:47 <lambdabot>  Add a type signature
22:05:52 <Cin> D:
22:06:03 <Cin> > (cons 1 2) car
22:06:06 <lambdabot>  1
22:06:09 <Cin> ^___^
22:06:14 <OceanSpray> hey guys, if you want to experiment with a fexpr-based language with first-class environments, I wrote an interpreter for that.
22:06:20 <brailsmt> Cin: thx for the demo
22:06:26 <Cin> brailsmt: heheh
22:07:02 <ddarius> brailsmt: For lists: cons, car, cdr = (:), head, tail respectively,  for pairs: cons, car, cdr = (,), fst, snd
22:07:03 <wy> Cin: Mitchell Wand. The Theory of Fexprs is Trivial ;-)
22:07:11 <Cin> OceanSpray: ahhhh. i _knew_ i knew you from somewhere! you're the guy that made me learn Haskell :P
22:07:19 <OceanSpray> what?
22:07:28 <Cin> OceanSpray: i know you from #scheme, don't i?
22:07:31 <OceanSpray> oh yeah.
22:07:37 <Cin> ^_^
22:07:39 <OceanSpray> I remember showing you that interpreter.
22:07:39 <ddarius> brailsmt: At any rate, Haskell handles data structures rather more nicely than "typical" Scheme or CL.
22:07:41 <OceanSpray> hi!
22:07:55 <wy> ddarius: because it's lazy?
22:07:59 <Cin> OceanSpray: yeah, i was like "this is pretty concise" and then i was hooked
22:08:23 <brailsmt> ddarius: thx
22:08:31 <OceanSpray> well, it's even more concise now that I refactored the code a bit.
22:08:33 <noige_> cons8 x = 8:x
22:08:36 <Cin> OceanSpray: link?
22:08:38 <gwern> 'Hey, I know you - you're the guy who killed my father!' 'What? oh yeah.'
22:08:38 <OceanSpray> https://sourceforge.net/projects/screw
22:08:44 <Cin> gwern: haha
22:08:50 <noige_> we can only cons into the first index
22:08:54 <noige_> right?
22:09:07 <gwern> hm. this is an interesting little cabal problem
22:09:08 <noige_> so cons8 = x:8 is not going to work
22:09:20 <Cin> sure
22:09:23 <noige_> > let cons8 x = x:8
22:09:23 <lambdabot>  Parse error at end of input
22:09:33 <noige_> > let cons8 x = 8:x
22:09:33 <lambdabot>  Parse error at end of input
22:09:34 <Cin> cons just makes a kind of pair
22:09:39 <pjd> noige_: yeah, (:) prepends to a list
22:09:46 <Cin> > let cons8 x = x:8 in cons8 7
22:09:46 <lambdabot>   add an instance declaration for (Num [t])
22:09:46 <lambdabot>     In the expression: let cons8 ...
22:09:48 <pjd> (,) is an arbitrary pair
22:09:51 <Cin> > let cons8 x = x:8 in cons8 7 :: Int
22:09:51 <lambdabot>  Couldn't match expected type `Int' against inferred type `[t]'
22:10:01 <ddarius> wy: No, because algebraic data types are much nicer than building everything out of pairs and vectors.
22:10:14 <OceanSpray> > let cons8 x = x:8 in cons8 [7]
22:10:15 <lambdabot>   add an instance declaration for (Num [[t]])
22:10:15 <lambdabot>     In the expression: let cons...
22:10:18 <pjd> let cons = (,); nil= [] in (cons 1 (cons 2 nil))
22:10:20 <pjd> > let cons = (,); nil= [] in (cons 1 (cons 2 nil))
22:10:22 <lambdabot>  (1,(2,[]))
22:10:30 <Cin> OceanSpray: type of list of 7? :P
22:10:36 <gwern> so I have a package split between library and executable; the executable is pulling in a module from the library, but the module is provided by a .hsc file. Now, the library section has no trouble compiling against it because hsc2hs turns it into a .hs, but when it comes to the executable, it never seens the .hs version! and so fails
22:10:45 <noige_> man I have a lot to learn
22:10:47 <OceanSpray> hmm.
22:10:50 <noige_> still learning lists hahaha
22:10:53 <noige_> this is awesome
22:10:57 <OceanSpray> > let cons8 x = x:[8] in cons8 7
22:10:58 <lambdabot>  [7,8]
22:11:06 <Cin> i was writing php code the other day and was like "now i'll just make a tuple here... oh."
22:11:07 <OceanSpray> well, there you have it.
22:11:13 <wy> ddarius: I guess Lisp does that for a reason. It needs a data structure for the program itself
22:11:36 <noige_> let cons8 x = x:[8] in cons8 7
22:11:46 <noige_> what is : in cons8 7?
22:11:54 <pjd> @pl \x = x:[8]
22:11:54 <lambdabot> (line 1, column 4):
22:11:54 <lambdabot> unexpected "="
22:11:54 <lambdabot> expecting operator, pattern or "->"
22:11:54 <noige_> 7 is the arg?
22:11:57 <OceanSpray> (:) is the cons operator.
22:12:02 <pjd> @pl \x -> x:[8]
22:12:02 <lambdabot> (: [8])
22:12:04 <noige_> err
22:12:05 <OceanSpray> constructs a list.
22:12:19 <noige_> I mean the "in cons8 7" part
22:12:21 <noige_> sorry
22:12:30 <OceanSpray> oh
22:12:32 <noige_> does that mean call cons8 with arg 7?
22:12:40 <wy> ddarius: but I agree the algebraic types looks nicer
22:12:40 <pjd> yeah
22:12:41 <Cin> sure
22:12:48 <OceanSpray> no, it means let something be something when you do this
22:12:48 <noige_> ok
22:12:54 <ddarius> wy: No.  Originally it was minimalism.  Nowadays modern Lisps have data structures but it takes more effort to declare and use them than to just use a rose-tree made out of conses.
22:13:34 <Cin> ddarius: they are good for Exploratory Programming (tm) (c) (tm)
22:13:49 <wy> ddarius: You mean the structures and CLOS?
22:14:00 <pjd> Explodatory Programming (tm)
22:14:08 <ddarius> wy: Those are some examples, yes.
22:14:49 <wy> ddarius: I guess it's really minimalism, since those can be implemented once you have the basic ones
22:14:50 <Cin> wy: (define make-person list) (make-person '(dave 42 "42, Elm Street"))
22:15:49 <ddarius> ((dave 42 "42, Elm Street"))
22:15:50 <wy> Cin: yes. and let's hope there is a smart compiler that can make it efficient
22:16:21 <Cin> ddarius: whoops =oooo
22:16:43 * Cin subjects himself to ten lashings of php
22:17:21 <proqesi> talk about cruel and unusual punishment
22:17:34 <wy> I found the nice thing about scheme is the metaprogramming. I know many people are waiting Haskell to have more features, but for Scheme, you can experiment with new type system your self without much knowledge about the compiler
22:17:50 <gwern> @seen dcoutts
22:17:50 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 4h 28m 11s ago.
22:18:37 <gwern> @tell dcoutts so I have a package, PowerMate bindings, split between library and executable; the executable is pulling in a module from the library, but the module is provided by a .hsc file. Now, the library section has no trouble compiling against it because hsc2hs turns it into a .hs, but when it comes to the executable, it never seens the .hs version! and so fails. is there something obvious I am missing? I tried all the permutations of ...
22:18:37 <lambdabot> Consider it noted.
22:18:43 <gwern> ... build-depends and src-dirs and so on that ocurred to me
22:18:48 <gwern> @tell dcoutts ... build-depends and src-dirs and so on that ocurred to me
22:18:49 <lambdabot> Consider it noted.
22:18:50 <ddarius> wy: Metaprogramming doesn't significantly help in that case.
22:18:59 <OceanSpray> let's combine lisp-style metaprogramming WITH haskell.
22:19:16 <wy> Liskell? hehe
22:19:36 <OceanSpray> or Qi
22:19:57 <wy> ddarius: It really helps I guess. for example what if you want to have logic programming
22:20:18 <Cin> embed it?
22:20:31 <ddarius> wy: It's a bit more convenient than using a preprocessor, but it is not -much- better than a preprocessor.
22:20:36 <OceanSpray> Qi has an embedded Prolog in its type system.
22:21:11 <OceanSpray> and an embedded YACC in its macro system, I think.
22:21:16 <wy> and the type system needs many changes too. It's still sometimes not as good as
22:21:33 <wy> ddarius: but you need much more work I guess
22:21:56 <ddarius> wy: Not really.  Absolute worse case scenario you need to write a parser.
22:21:58 <Cin> wy: what changes?
22:22:56 <wy> Cin: for some example just look at the extensions and proposals
22:23:22 <wy> ddarius: It's really hard to parse Haskell I guess ;)
22:23:57 <ddarius> wy: To -write- a parser, yes.  But there are several lying around that you can just use.
22:24:00 <wy> ddarius: But laziness is the only thing that's not easily get
22:24:21 <ddarius> wy: The Haskell community is pretty anti-pre-processing.
22:24:53 <wy> ddarius: that would make the code not compatible with each other?
22:25:40 <ddarius> If your pre-processor -or macro- is doing something interesting, then your code isn't going to be compatible anyway.
22:26:06 <wy> Qi looks nice
22:26:13 <ddarius> But the Haskell community usually tries to figure out weighs of solving things within Haskell, e.g. Scrap Your Boilerplate.
22:26:27 <ddarius> Wow, that was an impressive typo.
22:26:39 <OceanSpray> dang.
22:26:45 <Cin> ddarius: indeed, a phonetic typo
22:26:48 <OceanSpray> I see you think aurally.
22:27:15 <ddarius> For reading/writing, quite definitely.
22:27:26 <wy> I would love to have currying in Lisp
22:27:39 * wli never used to make phonetic typos until about 5 years ago.
22:27:49 <ddarius> (define (curry f) (lambda (x) (lambda (y) (f x y))))
22:28:02 <wli> (More properly, homophone errors.)
22:28:03 <Cin> wy: it's possible if you modify the reader
22:28:48 <wy> ddarius: It's quite tedious to define functions that way, and once you have defined it, you have to call it that way...
22:30:14 <ddarius> wy: You just want, primarily, a different syntax for repeated application.
22:30:14 <OceanSpray> hmm.
22:31:03 <OceanSpray> well, if you were designing a lisp-like language, you can always facilitate currying by making some special operators.
22:31:39 <Cin> or just create thunks for all args instead of evaluating them?
22:31:48 <OceanSpray> [f a] -> (lambda (x) (f a x))
22:32:06 <OceanSpray> wait a minnit.
22:32:10 <ddarius> OceanSpray: See the "cut" syntax in one of the SRFIs
22:32:16 <Cin> OceanSpray: i see what you did there
22:32:34 <wy> any way, Lisp programs are always much longer
22:33:54 <OceanSpray> (define (curry f val) (lambda x (f val . x)))
22:34:51 <OceanSpray> I guess that still doesn't work right.
22:36:17 <wagle_home> :t curry
22:36:22 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:36:49 <wagle_home> (define (curry f v1) (lambda (v2) (f v1 v2)))
22:37:15 <OceanSpray> wagle_home, that doesn't work for functions with more than two arguments.
22:37:22 <OceanSpray> if we had fexprs...
22:37:28 <wagle_home> i dont know of a scheme function that gives me the arity of a function
22:37:36 <Cin> procedure-arity
22:37:51 <Cin> they are procedures in scheme, not functions
22:37:52 <wagle_home> OceanSpray, as i showed, it only works for arity 2 in haskell
22:38:10 <Riastradh> What's the arity of the value of (LAMBDA ARGS (ERROR "Wrong number of arguments:" (LENGTH ARGS)))?
22:39:01 <Cin> riastradh: in mzscheme, it would be a structure saying that there is no specified arity
22:39:29 <Riastradh> I'm not asking what MzScheme's non-standard PROCEDURE-ARITY procedure will tell you; I'm asking more generally what the intent should be.
22:39:59 * glguy scrolls up to find the haskell relevance
22:44:29 <blargeyfarg> could you somehow bend 'apply' to your will to build a list of arguments with each application of curry?
22:48:36 <wagle_home> blargeyfarg, yes..  prblem is knowing when to stop
22:50:02 <wagle_home> (curry (lambda x ....)) is?
22:51:00 <OceanSpray> well, I came up with (define curry (nlambda (f v) (nlambda x (apply (eval f caller-env) (cons v x) caller-env))))
22:51:43 <OceanSpray> except this thing breaks down when the curried value is redefined.
22:51:47 <Cin> :t matchRegex
22:51:49 <lambdabot> Not in scope: `matchRegex'
22:51:52 <Cin> D:
22:52:08 <OceanSpray> you may have to specify the module.
22:52:34 <Cin> :t Text.Regex.Lazy.matchRegex
22:52:34 <lambdabot> Couldn't find qualified module.
22:52:39 <Cin> :t Text.Regex.matchRegex
22:52:40 <lambdabot> Text.Regex.Posix.Wrap.Regex -> String -> Maybe [String]
22:52:44 <Cin> huzzah!
22:53:12 <Cin> @let emailr = matchRegex (mkRegex "^[a-zA-Z0-9.-_+]+\\@([a-zA-Z0-9]+\\.[a-zA-Z0-9]+)+$")
22:53:12 <lambdabot> <local>:4:9: Not in scope: `matchRegex'  <local>:4:21: Not in scope: `mkRegex'
22:53:16 <Cin> whoops
22:53:28 <Cin> @let emailr = Text.Regex.matchRegex (Text.Regex.mkRegex "^[a-zA-Z0-9.-_+]+\\@([a-zA-Z0-9]+\\.[a-zA-Z0-9]+)+$")
22:53:29 <lambdabot> <local>:4:9: Not in scope: `Text.Regex.matchRegex'  <local>:4:32: Not in scop...
22:53:47 <Cin> i see..
23:06:06 <noige_> are most of the people in here  perl6 devs?
23:06:32 * mrd isn't
23:06:49 <jeffz> most? there's something like 450 people here
23:07:16 <noige_> oh I didnt notice that
23:07:20 <jeffz> @users
23:07:21 <lambdabot> Maximum users seen in #haskell: 471, currently: 397 (84.3%), active: 9 (2.3%)
23:08:08 * oerjan points to #perl6
23:08:10 <siti> are all the perl 6 people moving to haskell ;)
23:09:24 * wagle_home thought perl6 was 6 months from being released in something like 1992
23:09:52 <jeffz> perl6 is the new arc?
23:11:44 <dons> Lemmih, alexj: happs.org down?
23:13:07 <Cin> it's down for me
23:13:20 <kaol> and where's that syb-with-class 0.4?
23:13:27 <glguy> dons: I think we'll be ready to replace hpaste.org tomorrow
23:14:56 <noige_> 0.o [[],[],[],[],[[]],[[]]]
23:15:06 <noige_> > [[],[],[],[],[[]],[[]]]
23:15:21 <lambdabot>  thread killed
23:15:24 <noige_> ooo
23:15:29 <glguy> lambdabot won't be able to determine the type of that
23:15:37 <glguy> try again
23:15:52 <noige_> [[],[],[],[],[[]],[[]]] :: [[[a]]]
23:15:56 <noige_> > [[],[],[],[],[[]],[[]]] :: [[[a]]]
23:15:56 <lambdabot>  [[],[],[],[],[[]],[[]]]
23:16:22 <oerjan> > [[],[],[],[],[[]],[[]]]
23:16:24 <lambdabot>  [[],[],[],[],[[]],[[]]]
23:16:29 <glguy> what is it defaulting to?
23:16:36 <glguy> :t  [[],[],[],[],[[]],[[]]]
23:16:37 <lambdabot> forall a. [[[a]]]
23:16:37 <oerjan> () i assume
23:16:54 <oerjan> since Show is the only class involved
23:16:54 <dons> glguy: super cool
23:17:19 <noige_> lambdabot is really cool
23:17:26 <noige_> I want to make stuff like that someday
23:17:48 <dons> you can start now! its pretty easy, and we have an irc library that makes it even easier.
23:18:09 <idnar> uhm, why does that typecheck?
23:18:26 <glguy> what?
23:18:27 <dons> [[[a]]]?
23:18:29 <idnar> oh, I get it
23:18:51 <dons> :t  [[],[],[],[],[[]],[[[[[[[[]]]]]]]]]
23:18:52 <lambdabot> forall a. [[[[[[[[[a]]]]]]]]]
23:18:58 <idnar> [] is an empty list of anything, including [[[[[[[...a...]]]]]]
23:19:07 <glguy> that sir, was too bold
23:19:13 <dons> type inference roxors
23:19:31 <noige_> shouldn't I learn the language more strongly before trying to create bots though?
23:19:48 <dons> noige_: no way! little network apps are a great way to get started
23:19:49 <mrd> learn by bot writing
23:19:52 <dons> ?go roll your own irc bot
23:19:53 <blargeyfarg> noige_: wouldn't creating bots help you learn the language?
23:19:54 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
23:19:54 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
23:19:57 <dons> :)
23:20:13 <mrd> i wrote a bot to learn how to use hsplugins and HXT
23:20:13 <Cin> another one bites the dust
23:20:20 <blargeyfarg> if you're not in over your head, you're not in far enough
23:20:25 <wy> dons: hey what's that?
23:20:32 <dons> good rule to live by, blargeyfarg :)
23:20:38 <dons> wy?
23:20:55 <wy> dons: The type of those lists?
23:21:06 <dons> oh, some very deeply nested list
23:21:18 <siti> I'll keep that quote in mind when I am swimming
23:21:19 <mrd> :t (:[])
23:21:20 <lambdabot> forall a. a -> [a]
23:21:35 <noige_> blargeyfarg: good point
23:21:36 <mrd> siti: it's even more important when diving!
23:21:56 <blargeyfarg> noige_: except when swimming, as noted by our astute readers
23:22:07 <wy> dons: ah I got it
23:22:08 <noige_> ok
23:22:11 <noige_> That is a good point
23:22:12 <idnar> (:[]) -- om nom nom nom
23:22:28 <Cin> :P
23:23:02 <wy> why can [[]]] be typed as the deeper one?
23:23:13 <Zao> idnar: That's the monkey robot operator.
23:23:17 <mrd> [] can be a list of anything
23:23:20 <wagle_home> :t ([]:)
23:23:20 <lambdabot> forall a. [[a]] -> [[a]]
23:23:39 <wagle_home> :t ([]:[])
23:23:40 <lambdabot> forall a. [[a]]
23:24:02 <mrd> > [] :: [[[[Int]]]]
23:24:02 <idnar> :t [[]]
23:24:03 <lambdabot>  []
23:24:03 <lambdabot> forall a. [[a]]
23:24:08 <noige_> I think I will make a web page about haskell then, written in 100% haskell, that outputs the html
23:24:13 <noige_> good idea
23:24:24 <Cin> heh, i was just typing my code in time with Another One Bites the Dust without noticing
23:24:28 <mrd> > [] :: [[[[Int]]]]  -- an empty list of 4-deep Int lists
23:24:29 <lambdabot>  []
23:24:32 <idnar> wy: ^^^ a can be anything, including, for example, [[[[[a]]]]]
23:24:32 <noige_> I will have to learn how to deal with files first
23:25:06 <wy> idnar: I know [] can be anything, but why [[]] can also be ?
23:25:25 <idnar> wy: [[]] is a list containing []
23:25:26 <mrd> > [ [] :: [[[Int]]] ] :: [[[[Int]]]]
23:25:27 <lambdabot>  [[]]
23:25:27 <wagle_home> :t [[]]
23:25:28 <lambdabot> forall a. [[a]]
23:25:33 <idnar> wy: and that [] can be anything
23:25:35 <mrd> break it down
23:26:08 <wy> :t [[]]
23:26:09 <lambdabot> forall a. [[a]]
23:26:31 <wy> :t [[]]::[[[a]]]
23:26:32 <lambdabot> forall a. [[[a]]]
23:26:48 <wy> I see :)
23:27:47 <wy> Where is the start of type theory? from typed lambda calculus?
23:29:22 <oerjan> Bertrand Russell's set theory?
23:29:40 <glguy> dons: did you add old or new hpaste to ohloh?
23:30:06 <wy> Are there many set theories?
23:30:31 <wy> oerjan: I got the parser work btw
23:31:10 <lekro> HOpenGL claims to support quite a list of OpenGL extensions. Is there any example where an extension is used? Because I can't seem to find any function for accessing the extensions
23:31:15 <noige_> Off work!
23:31:20 <noige_> see you from my house!
23:33:49 <oerjan> http://en.wikipedia.org/wiki/Alternative_set_theory
23:34:23 <pjd> is that like alternative medicine?
23:34:46 <hpaste>  dobblego pasted "CABAL hidden package" at http://hpaste.org/5854
23:35:15 <mrd> Russell (and Whitehead) established a "predicative" "type theory" in the Principia Mathematica
23:35:29 <mrd> meant to set out a consistent foundation for arithmetic and mathematics
23:36:05 <mrd> where more complex sets were built from lower "types" of sets
23:36:27 <mrd> and the levels were strictly enforced to eliminate paradoxes
23:37:52 <lxuser> mrd, typed lambda calculi are more interesting than Russell's approach.
23:38:06 <glguy> p #haskell
23:38:13 <glguy> :-D
23:38:14 <lxuser> they are heavily used in intuitionistic and constructive mathematics
23:38:50 <glguy> multi-channel support working :)
23:39:25 <Cin> woo !
23:39:28 <hpaste>  mikael pasted "repetitive case bodies - is there a nice way?" at http://hpaste.org/5855
23:40:11 <mikael> oh yeah, I guess I should make the expression type more structured
23:40:30 <mikael> like have a EBinRel BinRelOp Expr Expr
23:48:53 <ddarius> How can a language community or language designer be content to leave common functions only standardly accessible through magic numbers?
23:49:32 <oerjan> 42
23:49:48 <glguy> ddarius: J?
23:49:52 <ddarius> glguy: Yes.
23:50:03 <wagle_home> 0xdeadbeef
23:50:09 <glguy> it is the ultimate in encouraging pure programming
23:50:20 <glguy> make it painful not to
23:50:31 <ddarius> glguy: ?
23:50:31 <wagle_home> ddarius, i'm not sure what you are talking about
23:51:10 <bparkis> actually hold on, are you sure call/cc is not referentially transparent? i can see an interpretation where it is, because the value of any expression does not depend on the order in which call/cc is evaluated--just that the expression may fail to return
23:51:59 <wagle_home> there is a context in which it does return its value
23:52:10 <ddarius> wagle_home: A simple example is sine.  As far as I know the only "standard" way to invoke sin is: 0 o. x
23:52:40 <glguy> ddarius: ahh, I was thinking of the foreign functions
23:53:19 <dons> glguy: where are we going to run hpaste2?
23:53:26 <dons> code?
23:53:30 <glguy> ideally
23:54:07 <wagle_home> ddarius, scrolling back, i cant figure out which language you are talking about
23:54:13 <glguy> J
23:54:33 <wagle_home> ?go J
23:54:34 <lambdabot> http://en.wikipedia.org/wiki/J
23:54:34 <lambdabot> Title: J - Wikipedia, the free encyclopedia
23:54:52 <glguy> they let you write:  sin=:1&o.
23:55:04 <mrd> lxuser: no kidding, since Russell's book was heavily flawed and its entire purpose was ultimately shown to be futile
23:55:06 <glguy> and I'm sure most people do :)
23:55:51 <dons> "The Haskall language is often uses by very intelligent programmers"
23:55:57 <dons> i like.
23:56:01 <ddarius> glguy: Yeah.  It's no trouble defining your own, but why not do that standardly?  I have no problem with keeping o. in addition.
23:56:31 <glguy> ddarius: having a standard sin goes against the goals of unreadability
23:56:41 <ddarius> glguy: True.
23:56:47 <siti> dons: where's that quote from?
23:57:15 <lekro> anyone know how I can use GL extensions with HOpenGL?
23:58:14 <wy> What's that language ;) Like INTERCAL?
23:58:31 <ddarius> Intercal is more readable than J.
23:58:48 <solrize> is there a simple way to load a library module into ghci so I can use its contents?
23:58:58 <oerjan> solrize: :m +
23:59:40 <lekro> GLUT seems to be playing around with foreign pointers (in Graphics.UI.GLUT.Extensions), is this how it's done?
