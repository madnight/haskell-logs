00:00:06 <decker> so it's kinda like a generic
00:00:11 <decker> but like a constrained generic
00:00:11 <wli> Char, Int, Integer, Float, Double, (), and various others are ground types.
00:00:17 <decker> Num > Floating > Float
00:00:30 <adu> decker: yes, only you must re-implement it for each new value you put in the parameter
00:01:54 <decker> so if a function returns Floating a then i have to write seperate copies of the function for Float, Double?
00:02:16 <adu> A function cannot return Floating a
00:02:23 <adu> A function can return (Floating a) => a
00:02:32 <decker> smallRandomFloatings :: Floating a => Integer -> [a]
00:02:41 <decker> this is my random number generator
00:02:47 <adu> ok
00:02:55 <decker> so the random values coming out are what type?
00:03:10 <adu> decker: they are of type 'a'
00:03:19 <decker> where a is any Floating type?
00:03:24 <adu> decker: yes
00:03:37 <decker> so up to now i've been doing this
00:03:39 <adu> oops, '[a]'
00:03:44 <decker> ranWeights :: Floating a => Integer -> Integer -> [a]
00:03:54 <decker> makeAgent :: Floating a => Integer -> Integer -> Integer -> Integer -> ([a], [a], a, a)
00:03:54 <adu> ok
00:03:57 <decker> and it works
00:04:32 <adu> decker: you know you can call (ranWeights 2 15) :: Double
00:04:40 <adu> decker: if you want to force 'a' to be something
00:04:40 <decker> aaaaaaahhhhh
00:04:43 <decker> okay
00:05:05 <decker> but what i wanted to do was just make some type aliases
00:05:50 <adu> decker: but if you're going to be using ([a], [a], a, a) alot, you should learn about 'data', its nice
00:06:14 <decker> okay
00:06:23 <decker> that's what i wanted to replace with Agent
00:06:28 <decker> yeah i should read up on data
00:06:35 <decker> thnx guys
00:06:40 <decker> fn arg :: type
00:07:03 <adu> I'm still learning about data, but so far, I think "data Rectangle = Rect ( x :: Double, y :: Double )" will make 2 functions x and y
00:07:23 <lispy> adu: that's record syntax
00:07:27 <adu> oops
00:07:30 <adu> i suck
00:07:35 <lispy> and you need { instead of (
00:07:49 <lispy> adu: it's not a bad thing, just clarifying you can use 'data' without it
00:08:06 <lispy> data Rect Double Double
00:08:08 <lispy> er
00:08:18 <lispy> data Rectangle = Rect Double Double
00:08:23 <adu> right
00:08:33 <lispy> would be another way to do the same thing, but it's not obvious which is length and which is width
00:08:54 <lispy> there is a syntax extension so you can also do, data Rectangle where Rect :: Double -> Double -> Rectangle
00:09:36 <lispy> This is nice because it emphases that data constructors are functions too
00:09:48 <adu> decker: then the hard part is realizing that you can use datatype constructors as arguments to your function, so instead of "myfunc x = ... (getFirstPart x) ..." you can write "myfunc (Agent a b c d) = ... a ..."
00:11:09 * wli would expect a rectangle to need 4 real numbers to represent.
00:11:20 <adu> wli: lol
00:11:29 <wagle_home> its a platonic rectangle
00:11:50 <wli> data Point = Point { x, y :: Double } ; data Rectangle = Rectangle { lowerLeft, upperRight :: Point }
00:12:01 <wagle_home> mmm..  maybe a unit rectangle, that can ge scaled
00:12:12 <wagle_home> be
00:12:21 <mrd> width, height
00:12:30 <wagle_home> nah, that doesnt work
00:12:54 <wagle_home> (my idea)..
00:12:59 <decker> hey in ghci when i do :load file.hs sometimes it takes me to Prelude Main> and sometimes it goes to main*> where I can actually call the functions in the file
00:13:20 <decker> but i can't figure out how to switch between them
00:13:33 <wli> There is position, size, orientation, and shape, I suppose.
00:13:45 <wagle_home> clifford algebras did something like this, but i cant remember
00:15:40 <wli> I'm not sure how those 5 things end up getting squished into the coordinates of the opposite corners.
00:15:52 <wagle_home> decker: you getting error messages after your :load?
00:15:58 <decker> no
00:16:19 <decker> both times load succesfully, i suspect it's just about changing which module i'm in
00:16:22 <wagle_home> no idea then
00:16:29 <decker> but what's the syntax for that
00:16:50 <wagle_home> oh yeah, i think the module is part of the prompt..  i dont use modules yet
00:21:02 <adu> decker: theres like a +Module and -Module or something syntax, but I have no idea what it does
00:22:15 <mrd> adds or removes modules
00:22:37 <decker> i'll fool around with it
00:23:39 * wli continues waffling over what method to use to optimize sums of absolute values of errors based on the criteria of the things working on the problem and feasibility of implementation.
00:24:05 <wli> That is,feasibility of from-scratch implementation.
00:41:20 <decker> hey if you declare a data type like data Agent = Agent {weights :: [Double]}
00:41:24 <Mr_Awesome> why is Set not an instance of Functor?
00:41:36 <decker> how do you later access the weights of an agent, like (weights agent)?
00:41:46 <Mr_Awesome> yes
00:42:11 <mrd> weights would be a function yes
00:42:24 <Mr_Awesome> weights $ Agent {weights = x} == x
00:42:30 <decker> nice
00:42:52 <Mr_Awesome> there are other neat tricks you can do with records too
00:42:57 <ddarius> You can also pattern match it out.
00:42:59 <mrd> Mr_Awesome: er, that's weights (Agent {weights = x} == x)
00:43:07 <Mr_Awesome> true
00:43:28 <decker> how would you do the pattern matching version?
00:43:45 <mrd> let (Agent { weights = var }) = ... in
00:43:47 <ddarius> f (Agent { weight = x}) = x
00:43:57 <decker> ah
00:44:04 <ddarius> or even f (Agent x) = x as you can mix and match record and positional syntax.
00:44:16 <mrd> and functional update, var { weights = [3,4] }
00:44:22 <ddarius> > case Just 3 of Just {} -> 4
00:44:23 <decker> if a type has many members but you only need certain ones can you only use the ones you want in the pattern matching?
00:44:25 <lambdabot>  4
00:44:29 <Mr_Awesome> functional update is my favorite :)
00:44:40 <ddarius> decker: Yes
00:44:41 <Mr_Awesome> decker: yes
00:44:43 <decker> nice
00:44:47 <mrd> yes, especially since its missing in SML, and desperately needed
00:44:55 <decker> ah
00:45:19 <Mr_Awesome> ocaml has it, but only in its actual objects, not records
00:46:01 <Mr_Awesome> so, anybody happen to know why Set is not an instance of Functor?
00:46:10 <mrd> Ord constraint
00:46:39 <ddarius> http://web.archive.org/web/20061011094943/http://haskell.org/hawiki/UsingRecords
00:46:40 <lambdabot> http://tinyurl.com/25vh3y
00:47:31 <wli> The type system doesn't allow for typeclass constraints on type constructor arguments in instance rules for the type constructor.
00:47:47 <mrd> fmap :: (a -> b) -> (f a -> f b) -- no Ord constraint on 'b' therefore Set is not a functor
00:48:20 <wli> I'm not entirely sure it would help.
00:49:12 <Mr_Awesome> i see
00:49:27 <Mr_Awesome> thats rather unfortunate
00:50:16 <wli> I don't know of type systems able to handle that situation, but then again, I'm far behind the #haskell curve on type systems.
00:51:39 <wli> Ugh, KKT requires continuous differentiability.
00:51:50 <wli> So anything KKT-based is useless.
01:01:04 <gour> @seen ndm
01:01:04 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 2d 16h 40m 46s ago, and .
01:08:51 <wli> 2^{-n} log(cosh(2^n x)) seems vaguely plausible.
01:14:11 <wli> Trick is, with huge arguments like 2^n x, cosh rapidly overflows all the useful floating point representations, so some sort of series or other expansion of it is required.
01:17:49 <mahogny> KKT. we are doing continuous optimization now in here? o_O
01:22:02 <wli> = 2^{-n} log(e^{2^n x} + e^{-2^n x}) - 2^{-n} log(2) = |x| - 2^{-n} log(2) + 2^{-n} log(1+e^{-2^{n+1} |x|}) = |x| - 2^{-n} log(2) + 2^{-n} \sum_{k=1}^\infty \frac{(-1)^{k+1}}{k} e^{-2^{n+1} k |x|}, which I suspect rapidly converges.
01:23:45 <mahogny> doesn't look too bad
01:24:00 <wli> \frac{d}{dx} 2^{-n} \log(\cosh(2^n x)) = \tanh(2^n x), which in turn has its own issues.
01:25:24 <wli> mahogny: The idea is to use a sequence of continuously differentiable approximations to |x|.
01:25:48 <mahogny> have some slight problems seeing if this mess is approximately convex
01:26:29 <wli> mahogny: Not remotely. I'm doing rational functions here, so most/all bets are off.
01:28:14 <wli> mahogny: It's possible to get it down to a quadratically constrained quadratic program.
01:28:30 <ttt--> hi, can i do something like in erlang where you spawn 10,000 processes and make then commutate with messages?
01:28:33 <wli> mahogny: But again, not convex.
01:28:45 <ttt--> with forkIO maybe? or is that not lightweight enough
01:29:23 <mahogny> ttt--, not with forkIO for sure. with continuations maybe
01:29:27 <wy> oerjan is gone
01:29:45 <mahogny> wli, hm. my book doesn't give many alternatives if KKT cannot be applied :S
01:30:31 <ttt--> i'd like some way to sandbox them, control the memory and cpu used.. is that possible?
01:30:54 <wli> mahogny: Basically minimizing sum [abs $ y - eval coefs x | (x, y) <- samples] where eval (Coefs a0 a1 a2 a3 b1 b2) x = (a0 + a1*x + a2*x^2 + a3*x^3)/(1 + b1*(x-b2)^2) {- form of denominator chosen to preclude singularities -}
01:31:11 <wy> I've got an idea to disambiguituate the grammar, if someone recalls my question in this midnight ;)
01:31:19 <wli> mahogny: That is, with respect to coefs.
01:31:28 <mahogny> wli, omg
01:31:29 <decker> how do you write a 'show' fn for your own data types?
01:31:34 <wli> mahogny: w0t?
01:32:10 <wli> decker: Omit deriving Show and write instance Show MyType where ...
01:32:33 <mahogny> wli, ah, no, it looked rather awful for a while
01:33:32 <mahogny> wli, what is it you really want to achieve?
01:33:38 <wli> mahogny: I've been struggling with it for a while, so it can't be all that nice.
01:34:09 <ttt--> i'd like some way to sandbox processes, control the memory and cpu used. Is there a language that allows this? I dont really know where to ask
01:34:10 <wli> mahogny: Robust regression using rational functions as a model, eventually to be extended to multivariate cases.
01:34:52 <wli> mahogny: Possibly with various sorts of kitchen sink regression thrown in on top of that.
01:35:10 <mahogny> ttt--, you can force the processes to run without IO or with a restricted IO monad. look up how the bot does it. memory & cpu control is harder
01:35:14 <wy> @tell wy ok
01:35:15 <lambdabot> You can tell yourself!
01:35:52 <ttt--> yeah, i'm wondering is there is a language that is built around this principal?
01:35:58 <mahogny> wli, ok. so no way out of this then :)
01:36:21 <mahogny> ttt--, java
01:36:38 <mahogny> ttt--, can't tell you about memory control there though
01:36:59 <ttt--> how does java do it?
01:37:23 <mahogny> ClassLoaders, restricts access to classes the program can access
01:37:42 <wy> @tell oerjan I thought about my grammar question again and it seems that my solution is right. S -> a S b T | b S a T | epsilon, T -> A | B, A -> a A b | epsilon, B -> b B a | epsilon. Your example "bbabaa" is actually derivable from the grammar, because T goes to epsilon in this case.
01:37:42 <lambdabot> Consider it noted.
01:37:51 <wli> mahogny: Provided I can get going with something that's not so immensely vulnerable to high dimensionality, the multivariate rational case is no big deal at all, and for that matter, neither are throwing in rational function coefficients of transcendental basis functions of various sorts (obviously the set of samples has to be sufficiently large to constrain that many parameters, though).
01:38:08 <decker> instance Show myType where (and then what?)
01:38:30 <wli> decker: Write a definition or showsPrec or some such.
01:38:34 <mahogny> wli, I think anything that includes x^aLot will always be vulnerable
01:38:40 <wli> decker: Write a definition OF showsPrec or some such.
01:38:51 <decker> where showsPrec = ...?
01:39:32 <wagle_home> ttt-- check out the programatica project: http://www.cse.ogi.edu/PacSoft/projects/programatica/
01:39:33 <lambdabot> Title: The Programatica Project
01:41:17 <wy> @tell oerjan The idea is that when we just use S -> a S b S | b S a S | epsilon, we don't know which b or a we are using because there are many ways to cut the string into substrings with equal number of a's and b's. But in the modified grammar, T captures the FIRST rightmost occurrence of a substring with equal number of a's and b's. So the ambiguity is resolved
01:41:17 <lambdabot> Consider it noted.
01:41:47 <wli> mahogny: Well, for the most part, things should have approximate proportionalities between x_i^{n_i} and x_j^{n_j} where n_i and n_j are <= 3; they're not precise relations, though, so there will be "corrections" of various sorts for the proportionalities of those powers breaking down, which will be dependent on all sorts of garbage.
01:42:40 <mahogny> wli, ok. as long as you keep those within sane limits then I don't think they will pose too much of a problem
01:44:25 <wli> mahogny: I would almost expect an isolated monomial term in one variable in the numerator and a hairy, unpredictable quadratic mess in the denominator to account for the slow breakdown of the proportionality as things stray from the "normal" regime. So there are no sane limits. It's all exploding in my face.
01:45:05 <mahogny> with sane, I mean everything is relative :)
01:45:36 <wli> I've actually seen an algorithm for this precise problem, albeit in the univariate case only.
01:45:58 <wli> I don't remember it and can't find the paper, so I'm resorting to all sorts of desperate measures.
01:55:07 <wli> I forgot to mention
01:55:28 <adu> hey
01:55:43 <adu> when you make a new data-type, can you pass the constructor back as a return value?
01:56:09 <adu> like "data T = C x" then "myFunc = C"
01:56:13 <ivanm> yes
01:56:17 <adu> cool
01:56:33 <ivanm> C is just a function that creates values of type T
02:00:18 <wli> |x| - 2^{-n} log(2) + 2^{-n} \sum_{k=1}^\infty \frac{(-1)^{k+1}}{k} e^{-2^{n+1} k |x|} = |x| + 2^{-n} \sum_{k=1}^\infty \frac{(-1)^{k+1}}{k} 2^{-n} (1 - e^{-2^{n+1} k |x|}), which you only really want to apply when |x| is vanishingly small (and then use 1 - z = 1/\sum_{k=0}^\infty z^k vs. actually using the difference)
02:02:24 <wli> I dropped a sign, but never mind that.
02:04:44 <wli> 2^{-n} log(2 cosh(2^n x)) may be better from the POV of asymptotically approaching |x| as x tends to +/- infinity.
02:13:22 <astryx> Hi
02:13:56 <astryx> I want to write a program to plot the mandelbrot-set. Which graphics-library do you prefer for that task?
02:15:25 <astryx> I have thought of hopengl? Is that suitable?
02:15:40 <astryx> Or are there alternatives?
02:16:19 <Syzygy-> astryx: For the mandelbrot set you only need to be able to paint single pixels. I'm pretty certain that hopengl can do that, but you might be getting too much 3d-graphics in it...
02:17:19 <Syzygy-> OTOH, skimming the libraries page, the main alternative seems to be the win32 graphics engine, and then opengl is what you'll want.
02:18:28 <astryx> hmm, win32? The program should also be runnable under linux...
02:18:37 <Syzygy-> My point exactly.
02:18:42 <Syzygy-> So use opengl
02:21:10 <astryx> I am new to haskell... I have heard that haskell tends to be slower than C. Is the speed sufficient for drawing a mandelbrot-set with hopengl
02:21:43 <wli> yes
02:21:47 <astryx> good
02:22:41 <astryx> ok, thank you for your information, cu
02:47:06 <ac> @seen Cin
02:47:07 <lambdabot> Cin is in #haskell. I don't know when Cin last spoke.
02:49:17 <smtms> I get a "403 Forbidden" error when I try to access to fourth URL in the channel topic
02:50:34 <wagle_home> social network?
03:01:30 <desegnis> I've got hit by the question where to put class constraints if one uses the imaginary keyword »exists«. If I want to express the idea that I have a value of some unknown type which is in class Num, what would I write if I use »exists«? I first thought »exists a. Num a => a« would do well, but the arrow (=>) seems the wrong way round then.
03:06:18 <ac> wli: what makes you say yes?
03:06:44 <ac> I've yet to see a Haskell program that renders Mandelbrot sets even within an order of magnitude as fast as the niave C approach
03:07:24 <ac> quicksilver and I have done some experimentation too
03:09:01 <mwc> ac. Plotting mandelbrot sets is a "solved problem." Once you know how to solve a problem, it's trivial to make a ludicrously fast implementation as close to the hardware as you want. The strength of higher level languages like Haskell is the exploration of ideas. Software that plots mandelbrot sets will never be asked to evolve significantly. Software that will evolve should be written to evolve, ie, in haskell
03:09:08 <ac> Maybe Data.Complex is the problem
03:09:39 <ac> mwc: I never said Haskell was not a viable language because of this
03:10:28 <mwc> true, but I would never expect Haskell to produce the worlds fastest Mandelbrot sketcher
03:10:31 <ac> though I must admit I was a little irked that my attempt was slow :-P
03:10:45 <ac> I expected it to produce something about 50% the speed of C
03:10:55 <mwc> If you're that far off, there's a lot you could do
03:11:12 <mwc> I've gotten way better than that margin using Haskell for finite element computations
03:11:46 <mwc> I ran circles around matlab implementations, within 85% of a respectable C++ implementation
03:12:23 <ac> yeah, I know Haskell can be pretty darn good for number crunching. I'm actually fairly curious why my implementation is so slow
03:12:24 <mahogny> oh. you've done FEM in haskell? is the code still readable after optimization?
03:12:32 <mwc> mahogny, sort of
03:12:46 <mwc> I did all my matrix jiggering in the ST monad using STUArray
03:12:53 <mwc> so it was about as readable as you'd expect from that
03:12:58 <mahogny> is it more readable than the C++ equivalent?
03:13:15 <mwc> I never gave the other student's code a close read through
03:13:18 <mahogny> that's pretty much were I set the limit of usability
03:13:41 <mwc> but I know the guy is a competent C++ hacker. His summer research project was implementing molecular dynamics simulations on a GPU
03:14:25 <ac> I wish I understood the math behind FEM
03:14:40 <mahogny> it takes a while to get into
03:14:52 <mahogny> but most don't understand, they still code it :P
03:14:54 <ac> I tried to write an FEM simulator in high school. I didn't get very far :-P
03:15:16 <ac> I started it before I knew what "FEM" was
03:17:00 <mahogny> I'm consider ocaml for some FEM stuff. seems libraries has gotten much better since I last checked
03:17:13 <mahogny> no worries about nasty lazyness then
03:17:16 <mwc> ac, finite difference is a little easier to understand
03:17:24 <mwc> and implicit methods are quite good
03:17:36 <mwc> you can ever get unconditionally stable methods if you're smart
03:17:48 <mahogny> a *lot* easier to understand. unfortunately, there isn't much to understand. the theoretical machinery is rather limited
03:17:53 <mwc> ie, heat equation "T-forward" stencil
03:17:58 <jedbrown> Ah, but the theory for finite elements is much cleaner.
03:18:00 <mwc> spectral methods rock too
03:18:59 * jedbrown is busy writing with jacobian-free newton-krylov for a spectral method (in Haskell).
03:20:48 <mwc> jedbrown, Newton-Krylov? what domain is that for?
03:21:04 <mwc> I'm not really that familiar with the fluid-dynamics sort of stuff, not my area
03:21:11 <jedbrown> mwc: non-newtonian fluid dynamics
03:21:16 <mwc> ahhh
03:21:55 <jedbrown> mwc: I'm interested in slow flow, so the non-linearities are totally different from what most people are doing.
03:22:38 <mwc> My interests in PDE sims ran more towards elliptical (poisson equation) and parabolic (shrodinger) systems
03:23:16 <mwc> my understanding of fluid flow is that the approximation at slow flow is... poor
03:23:31 <mwc> since turbulent and brownian effects dominate
03:23:51 <mwc> well, first turbulent, then brownian
03:24:57 <jedbrown> mwc: One application I'm interested in is ice flow.  You take the Navier Stokes equations and drop the inertial term which you can show is small.  The approximation is quite good.
03:25:53 <jedbrown> mwc: But ice has a strongly nonlinear, temperature dependent constitutive relation and there are many free boundary problems.
03:26:23 <mwc> Ahhh, ice flow... suppose you wouldn't have to worry about either of those effects in ice :)
03:26:33 <mwc> so glaciers shifting over terrain, that sort of thing?
03:26:43 <jedbrown> mwc: Exactly.
03:27:13 <jedbrown> mwc: turbulence is a fast flow (high Reynolds number) issue
03:28:11 <bakert> Is there an equivalent to Mechanize for Haskell?  Or a better way?
03:28:47 <jedbrown> mwc: In your FEM code, was it pure Haskell, or did you just assemble the system matrix in Haskell and hand it off to an external solver?
03:29:00 <bakert> I saw this ticket from summer of code ... http://hackage.haskell.org/trac/summer-of-code/ticket/1107 ...
03:29:02 <lambdabot> Title: #1107 (WWW::Mechanize-like package for Haskell) - Haskell.org Google Summer of C ...
03:30:01 <bakert> btw the tinyurl in the topic is a 403
03:31:03 <wli> I found system matrix assembly to be a PITA, but then again, I was dealing with some nasty systems.
03:31:15 <mwc> jedbrown, nope, pure Haskell.
03:32:00 <mwc> It it hadn't have been for a silly senior course in FEM, but for real work, I would have gone the external solver route
03:33:09 <jedbrown> mwc: Were you using a regular mesh, taking advantage of structure?  I'm quite impressed that you could write a matrix solver in Haskell that was competitive with C libs.
03:34:04 <bakert> nominolo: did anything come of http://hackage.haskell.org/trac/summer-of-code/ticket/1107 ?
03:34:05 <lambdabot> Title: #1107 (WWW::Mechanize-like package for Haskell) - Haskell.org Google Summer of C ...
03:34:27 <nominolo> bakert: no
03:34:31 <bakert> :(
03:34:35 <bakert> what's the next best thing?
03:35:26 <nominolo> HaXml/TagSoup + HTTP + <?>
03:35:39 <nominolo> bakert: what are you trying to do?
03:36:12 <bakert> visit, log into and extract some data from a website that is written in ASP.NET and thus has lots of silly cookies and hidden form variables that I didn't fancy grabbing explicitly
03:36:54 <bakert> i have a little scraper that i wrote on top of Network.Browser a while ago.  so i guess i can extend that.  i just wondered if something more groovy existed.
03:37:11 <nominolo> bakert: not that i know of
03:37:41 <bakert> what is TagSoup?  a beautiful soup-like thing?
03:37:52 <nominolo> bakert: there was a SoC project last year to provide curl bindings but i don't know what happened to it
03:37:57 <nominolo> @hackage tagsoup
03:37:58 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tagsoup
03:39:11 <nominolo> bakert: i haven't used tagsoup myself, but i think it's worth a look
03:39:26 * wli may have to hammer out matrix code for more general ring-like things.
03:40:21 <wli> (polynomials, rational functions, integers etc. needing fraction-free Gaussian elimination, etc.)
03:41:29 <wli> Multivariate polynomials might get hairy given that they're not truly Euclidean like the others.
03:45:09 <jedbrown> wli: Do you really need GE?  I would write Householder QR first and only do GE if you need the small constant factor performance gain for a problem that you know is nice.
03:45:34 <wli> Before the floating point people leave (I hope) -- wtf. do people do for floating point numerical solutions of systems of polynomial equations?
03:46:04 <wli> jedbrown: I can't take square roots or necessarily even form arbitrary quotients in the rings in question.
03:48:17 <ac> how do I use strictness anotations?
03:48:28 <wli> jedbrown: GE has the advantage over QR of being purely rational in such contexts. When division isn't possible, there's a fraction-free variant for it all.
03:49:02 <jedbrown> wli: It didn't register that you don't have multiplicative inverse.
03:49:50 <wli> It depends on what I'm doing, but you get the idea.
03:50:48 <jedbrown> wli: There is no closed form solution for the quintic, so you can't have a closed form solution for polynomial equations.  It has to be iterative.
03:52:14 <wli> jedbrown: You mean in terms of radicals and rational operations for a general quintic (there are indeed closed forms in terms of elliptic functions, IIRC due to Hermite or some such). In any event, iterative is what I want. It's floating point in, and so has to be floating point out.
03:52:35 <wli> (also closed forms for quintics of certain forms)
03:52:59 <wli> (some in terms of radicals and rational operations)
03:53:32 <jedbrown> wli: Turn it into an eigenvalue problem.
03:55:14 <wli> jedbrown: I'm a bit foggy on how that's done for systems of polynomial equations. They're typically n equations in n variables of the form p_k(x_1, ..., x_n) = 0 for multivariate (in fact n-variate) polynomials p_k for 1 <= k <= n. The translation to an eigenvalue problem is eluding me.
03:56:15 <mwc> wli, conversion to a companion matrix, eg, a matrix who's characteristic equation is that polynomial?
03:56:23 <mwc> just not sure how it's done for multiple polynomials
03:56:47 <wli> That's for univariate AFAIK. I'm totally unaware of any multivariate analogue for that.
03:57:39 <mwc> it is
03:57:56 <mwc> I know of nothing regarding "multivariate eigenvalues."
03:58:27 <mwc> Okay, suppose you have a bilinear map, z = A (x,y)
03:58:36 <mwc> how would you even define an eigenvalue?
03:58:51 <mwc> lambda z = A(z,z) ?
03:58:57 <wli> brb
04:04:28 <ac> is $! the only strictness anotation, or are there others?
04:06:18 <desegnis> ac, there is strictness annotation for data fields, which is what I would actually call strictness annotation
04:06:31 <desegnis> er, constructor fields, I mean
04:07:36 <ac> hm....
04:08:05 <hpaste>  ac pasted "would this benifit from strictness anotations?" at http://hpaste.org/5718
04:08:09 <desegnis> as in, data T a = C !Int !a
04:08:38 <ac> I was using Data.Complex which made it a lot more readable, and it wasn't noticeably slower
04:10:17 <Cin> ac: i wrote a simple scheme interpeter with just monads :D
04:10:30 <desegnis> not sure where you'd want strictness there. The lambda abstractions are strict in both their arguments anyway, and the lists should actually benefit from laziness
04:11:31 <desegnis> ah, you mean the pair which is lazy
04:12:53 <ac> Cin: oh cool. Would you mind sending me the code?
04:13:13 <Cin> ac: sure, when i've verified it doesn't break :PP
04:13:48 <ac> actually, any thoughts about why that is slow would be interesting
04:13:58 <Cin> ac: here's the location, anyway. but bare in mind i'm still going over the environments stuff: http://rtfs.ath.cx/haskell/SchemeM/src/
04:14:01 <lambdabot> Title: Index of /haskell/SchemeM/src/
04:14:20 <ac> Cin: you totally beat me to that
04:14:22 <Cin> (should be able to view the .hs files online)
04:14:41 <Cin> ac :P it sounded interesting
04:14:49 <desegnis> ac, using Complex shouldn't slow it down. Did it?
04:14:56 <ac> desegnis: not that I could tell
04:15:15 <desegnis> well Complex is essentially a strict pair
04:15:31 <ac> which is cool, because in C, using a standard complex library DID slow things down considerably
04:17:03 <desegnis> type Rat = Ratio Int, I guess?
04:17:15 <Cin> ac: i think you can take advantage of things like the fact when you create a closure, all the bindings that you capture won't ever change as far as that procedure is concerned (even if the objects those bindings point to are mutated), if you follow me. so i can create a "copy" of the parent environment and store it with the procedure (except it's not really a copy in the sense of other languages, in haskell it'd more likely be a pointer... one would hope)
04:17:22 <ac> desegnis: no, just Double. I did that so I could switch between Double and Float
04:17:30 <desegnis> ah ok
04:18:24 <desegnis> Data.Complex even contains some Specialize pragmas for Doubles and Floats
04:18:59 <ac> yeah, I bet using Data.Complex could easily speed it up by a small factor
04:19:20 <desegnis> yup
04:25:57 <ac> wow, it seems Don's stream fusion library sped it up a _lot_
04:26:22 <Cin> wow cool :D
04:27:10 <ac> that should totally be included in GHC ;)
04:31:00 <ac> though interestingly according to time, the sys time is about the same
04:31:10 <ac> the user time is more than halved though
04:31:12 <ac> er, real time
04:32:05 <ac> anyway, the real time is about 200x the sys time
04:33:54 <schwadri> little question. in the maybe monad is Nothing >> action == Nothing ?
04:34:30 <resiak> @src Maybe (>>=)
04:34:31 <lambdabot> (Just x) >>= k      = k x
04:34:31 <lambdabot> Nothing  >>= _      = Nothing
04:35:04 <schwadri> @src Maybe (>>)
04:35:05 <lambdabot> (Just _) >>  k      = k
04:35:05 <lambdabot> Nothing  >>  _      = Nothing
04:35:13 <schwadri> k. thx ;-)
04:41:51 <ac> if time is really giving me an accurate number for sys time, than I should be wondering why linux is scheduling it the way it is
04:42:00 <ac> not why Haskell is slow :-P
04:51:25 <schwadri> @src Maybe lift
04:51:26 <lambdabot> Source not found. You untyped fool!
04:51:34 <schwadri> @src Maybe (lift)
04:51:34 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:51:38 <schwadri> lol
04:51:47 <schwadri> @src Maybe (liftM)
04:51:48 <lambdabot> Source not found. :(
04:51:52 <schwadri> @src Maybe liftM
04:51:53 <lambdabot> Source not found. :(
04:51:55 <wvd> hello
04:51:56 <schwadri> @src Maybe liftMaybe
04:51:57 <lambdabot> Source not found. My brain just exploded
04:52:05 <vininim> @src lift
04:52:06 <lambdabot> Source not found. My mind is going. I can feel it.
04:52:34 <schwadri> #src liftM
04:52:47 <schwadri> @src liftM
04:52:47 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:52:48 <yondalf_> @src liftM
04:52:48 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:52:51 <schwadri> yepee
04:53:02 <yondalf_> liftM is a normal function, not a function defined by a typeclass
04:53:10 <vininim> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
04:53:11 <lambdabot> http://tinyurl.com/y25qsm
04:53:42 <schwadri> thx
04:54:11 <vininim> > import Control.Monad.Trans
04:54:12 <lambdabot>  Parse error at "impor..." (column 1)
04:57:49 <wli> back
04:58:36 <vininim> mmm I guess a monad with an attached state in which (>>=) means randomly changing the state doesn't respect first law of monads?
04:58:39 <wvd> how can I insert print statements into my functions for debugging?
04:59:22 <jedbrown> wli: There's an IEEE paper by Manocha which is probably of use to you.  For a more theoretical approach, there's a book by Sturmfels http://www.math.ucdavis.edu/~deloera/MISC/MATHRESEARCH/INTERESTING_PAPERS/Sturmfels/cbms.pdf
04:59:23 <lambdabot> http://tinyurl.com/34nora
05:00:00 <wli> jedbrown: Thanks.
05:00:06 <mahogny> wvd, wrong approach. you should keep your functions small enough that you can debug them in ghci one by one. if you really see no way out, then use unsafePerformIO
05:00:43 <wvd> thanks
05:05:38 <wvd> I'm looking at the type signature of (>>=)
05:05:47 <wvd> m a -> (a -> m b) -> m b
05:06:33 <wvd> the m a at the front, does the 'a' part of that get passed into the (a -> mb) parameter?
05:06:54 <yondalf_> the 'a' is a type, not a value
05:07:09 <mahogny> compare with >> while you are at it
05:09:40 <Botje> wvd: the a is actually the result of performing the m a computation, but yes, it then gets passed to the (a -> m b) part
05:14:33 <vininim> uh.. how do you prove the first monad law for monads where their values are functions...?
05:14:33 <wvd> what happens to the m at that point? because only the a is getting fed to the function right?
05:15:31 <vininim> maybe because of referential transparency of functions... mm...
05:16:01 <Botje> functions are equal if their domain & codomain are equal, and for those sets they define the same mapping
05:16:09 <Botje> wvd: it gets ... computed,  iguess
05:16:15 <mahogny> wvd, depends on what m is
05:16:50 <Botje> the monad action in question is given a kick in the teeth and asked to produce a value
05:17:03 <Botje> s/action/computation/ # if you'd rather think of it like that
05:17:52 <wvd> ah, ok, so it is "forced" at that point?
05:18:17 <mahogny> could say so. it certainly is if m=IO
05:18:24 <wvd> then a new action is produced which is attached to b (but not forced yet)
05:18:28 <wvd> ?
05:18:45 <mahogny> yes
05:19:16 <wvd> ah, ok, thanks, that makes more sense nou
05:20:51 <wvd> I was thinking in terms of deferred computations and not realizing that bind forces a computation, so I was wondering what happened to m
05:42:12 <larmeh> hi
05:53:42 <byorgey> hi larmeh
06:00:34 <schwadri> hey if i have a function f = do return () how does haskell know which monad to use for return?
06:01:04 <Japsu> :t return ()
06:01:10 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
06:01:21 <Japsu> that is, it can be any monad
06:01:38 <Japsu> haskell will try to infer the correct monad from the context when you use f
06:01:48 <Japsu> if it can't, it will give you an error
06:01:48 <schwadri> oh. i see
06:02:59 <schwadri> hm is a monad of kind * -> * ?
06:03:09 <schwadri> :t Monad
06:03:10 <lambdabot> Not in scope: data constructor `Monad'
06:05:01 <ToRA|home> :k Monad
06:05:02 <lambdabot> Class `Monad' used as a type
06:05:11 <Japsu> :i Monad
06:05:18 <Japsu> bah, lambdabot doesn't do :i
06:05:25 <Corun> ToRA, did you do UROP?
06:05:50 <schwadri> hm i don't really understand: forall (m :: * -> *)
06:06:04 <matthew-_> Corun: yep, as did I
06:06:19 <matthew-_> Corun: that's when we wrote Kenya
06:06:25 <Corun> Ah, cool
06:06:31 <matthew-_> Corun: though I was actually meant to be writing a USB stack for Minix
06:06:35 <jedbrown> schwadri: It's a kind signature.  It means that m is a data constructor which takes one argument.
06:06:37 <matthew-_> which I wasn't too keen on...
06:06:40 <Corun> Same thing ;-)
06:07:10 <matthew-_> what?
06:07:22 <schwadri> jedbrown: where can i find information what exactly kind is?
06:08:02 <Corun> So the only problem I see with UROP, is, where did you live?
06:08:47 <jedbrown> schwadri: perhaps here: http://en.wikibooks.org/wiki/Haskell/YAHT/Type_advanced#Kinds
06:09:23 <matthew-_> ahh, well, in the summer of my first year, I worked for CSG and I lived out in this house at white city. It was a complete dump - I mean horrible. But, I was barely ever there and it was cheap. It was being sub-sub-let as the people had a 12-month contract and didn't need it over the summer
06:09:41 <Corun> Heh
06:09:49 <matthew-_> by the time of the summer of my 2nd year, I was already living with my gf in the same flat that we're still living in
06:09:55 <Corun> Fair enough
06:10:28 <larmeh> ;t abs
06:10:32 <matthew-_> just ask around - there'll be loads of people in the same situation. finding places to live in London ain't hard. it's just it may be a) expensive and b) horrible ;)
06:10:37 <larmeh> :t abs
06:10:38 <lambdabot> forall a. (Num a) => a -> a
06:10:44 <Corun> Heh, ok
06:11:36 <pejo> matthew, heh, sounds like a lovely situation.
06:11:44 <matthew-_> most student flats will have a contract to october, so there'll be loads who want to sub-let so that they can go home over summer and not waste money
06:11:54 <matthew-_> pejo: london is truely horrid. It's also wonderful.
06:12:02 <matthew-_> kinda balances out really... ;)
06:12:31 <schwadri> jedbrown: thx
06:14:06 <Corun> Hehe
06:24:47 <schwadri> :k (>>=)
06:24:51 <lambdabot> Not in scope: type variable `>>='
06:24:58 <schwadri> :k Monad (>>=)
06:24:59 <lambdabot> Not in scope: type variable `>>='
06:25:25 <schwadri> :k Monad (>>=)
06:25:26 <lambdabot> Not in scope: type variable `>>='
06:25:30 <schwadri> :t Monad (>>=)
06:25:31 <lambdabot> Not in scope: data constructor `Monad'
06:26:04 <wli> jedbrown: That doesn't seem to get much into the numerical methods.
06:26:39 <wli> jedbrown: Grobner bases don't do very well numerically.
06:26:46 <wli> jedbrown: For example.
06:26:50 <nornagon> :t (>>=)
06:26:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:27:03 <nornagon> :k Monad
06:27:04 <lambdabot> Class `Monad' used as a type
06:27:06 <jedbrown> wli: The book is pretty much all theory (I haven't read it, I just know of its existance).  The paper is more practical.
06:27:08 <nornagon> er.
06:27:22 <nornagon> :k ((->)r)
06:27:23 <lambdabot> Not in scope: type variable `r'
06:27:40 <wli> jedbrown: I didn't see the paper.
06:29:16 <wli> jedbrown: digging through citeseer now
06:29:53 <jedbrown> wli: the author is Manocha, it's an IEEE paper entitled `Solving systems of polynomial equations'.  Let me know if you can't find a copy online.
06:30:16 <jedbrown> wli: (My university subscribes.)
06:30:30 <wli> jedbrown: I'm reading it. From the abstract it looks like what I'm after.
06:49:11 <kosmikus> does anyone here know why the Haskell "round" function is defined as it is?
06:50:01 <mwc> @src round
06:50:02 <lambdabot> Source not found. I am sorry.
06:50:07 <mwc> @type round
06:50:10 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
06:50:25 <mwc> hmmm, strange, looks like we have to consult the report
06:50:48 <kosmikus> > round 2.5
06:50:51 <lambdabot>  2
06:50:54 <kosmikus> > round 3.5
06:50:55 <lambdabot>  4
06:51:22 <kosmikus> that's correct according to the report, but I can't see any reason why one would want that behaviour
06:51:49 <mwc> Why is that bad?
06:52:25 <kpreid> kosmikus: round-to-even? it avoids introducing systematic bias
06:53:30 <mwc> there's also ceiling and floor if you want more control
06:53:43 <desegnis> round-to-even means that on average there is no rounding error on .5 (if any number occurs equally often)
06:53:48 <TomMD> And truncate
06:53:53 <TomMD> > truncate 2.5
06:53:54 <lambdabot>  2
06:53:58 <TomMD> > truncate 4.5
06:53:58 <lambdabot>  4
06:54:33 <kosmikus> well, I just would have expected that "round" which is documented as simply "round to the nearest integer", i.e., doesn't say anything about the critical case, would be the same as mathematical rounding
06:54:43 <kosmikus> ususally, .5 is rounded up
06:54:58 <TomMD> > ceiling 2.5
06:54:58 <lambdabot>  3
06:55:02 <TomMD> > ceiling (-2.5)
06:55:03 <lambdabot>  -2
06:55:29 <mwc> kosmikus, actually, we get the round-to-even-in-case-of-0.5 in grade school here
06:55:58 <kosmikus> interesting
06:56:05 <kosmikus> it's the first time I hear about this
06:56:37 <Beelsebob> round up with 0.5 makes the nicest distribution
06:56:42 <TomMD> Me too - I never knew because I always used "truncate" (tool that fits)
06:56:44 <desegnis> may be a cultural thing, too
06:56:45 <Beelsebob> seeing as we round "down" with 0.0
06:57:43 <kosmikus> at least I can see the point now; thanks
06:58:35 <desegnis> Beelsebob, you mean to round down on  [0; 0.5[  and round up on  [0.5; 1[ ?
07:03:48 <ndm> @seen kosmikus
07:03:49 <lambdabot> kosmikus is in #ghc, #gentoo-haskell, #haskell and #darcs. I last heard kosmikus speak 6m 5s ago.
07:04:36 <ndm> kosmikus: what is the recommended way in lhs2tex, using the polycode.fmt, to get varid's appear in \textsf?
07:04:55 <ndm> i had been using %subst, but the documentation seems to suggest that isn't a great idea, and other things are seeminly unhappy
07:05:47 <desegnis> ndm, on a related note, I sometimes do   \renewcommand{\Conid}[1]{\mathsf{#1}}
07:06:03 <desegnis> ndm, maybe that can be adapted?
07:07:03 <ndm> desegnis: i tried that, and keep getting errors all other place, at resethooks points
07:07:23 <kosmikus> ndm: redefining \Varid should work
07:07:25 <ndm> desegnis: particularly in combination with my "a_x" = "\Varid{a_x}" macros
07:07:31 <kosmikus> ndm: \let\Varid=\mathsf seems easiest
07:07:36 <ndm> ok, will try more :)
07:08:04 <ndm> is \renewcommand{\Varid}[1]{\textsf{#1}} equivalent to that?
07:08:22 <kosmikus> no, \mathsf is better
07:08:31 <ndm> oh, ok
07:08:37 <desegnis> oh, I thought Varid would be always used for lowercase identifiers, just as Conid for uppercase
07:08:39 <ndm> but the same stuff, but with mathsf instead?
07:08:49 <kosmikus> ndm: yes
07:08:51 <kosmikus> desegnis: that's right
07:09:00 <ndm> and what's the right thing for keywords?
07:09:07 <desegnis> hm, then why that macro for a_x?
07:09:27 <kosmikus> desegnis, ndm: good point. what are you trying to achieve with your a_x formatting rule?
07:09:37 <kosmikus> ndm: for keywords, there's unfortunately no TeX command
07:09:50 <kosmikus> I usually do %subst keyword a = "\Keyword{" a "}"
07:10:04 <kosmikus> and then \newcommand\Keyword[1]{\mathbf{#1}}
07:10:07 <kosmikus> or whatever you prefer
07:10:13 <ndm> kosmikus: in general, x_y should be subscript
07:10:22 <kosmikus> %format a_x
07:10:25 <kosmikus> should suffice, or not?
07:11:15 <kosmikus> ndm: See 7.7 of Guide2.pdf for implicit formatting rules
07:11:26 <ndm> kosmikus: is that only in 1.13?
07:11:34 <kosmikus> ndm: no
07:12:12 <kosmikus> ndm: since 1.9, I think
07:13:01 <ndm> kosmikus: i'm reading 7.7, and it is m aking my brain hurt...
07:13:06 <desegnis> Only now have I learnt about %subst :) Hard to say whether %subst is more or less appropriate than \renewcommand
07:13:26 <desegnis> (concerning varids, conids)
07:13:35 <kosmikus> desegnis: I tend to see %subst as a directive the users should not use
07:14:15 <ndm> so %format y_1 will give me underscores on its own?
07:14:16 <kosmikus> %subst should always map to a TeX command, and that should be redefined
07:14:22 <kosmikus> unfortunately, for keywords, it doesn't
07:14:26 <kosmikus> I should fix that ...
07:14:35 <ndm> what about %format x_n ? how should i write that
07:14:44 <desegnis> kosmikus, but redefining \Varid depends on a certain behavior fixed via %subst, right?
07:14:47 <kosmikus> %format y_1 should map to \Varid{y}_1
07:15:34 <kosmikus> desegnis: yes, but I usually won't just change the %subst settings between releases
07:15:41 <desegnis> right
07:16:45 <desegnis> kosmikus, good to know you're the lhs2Tex author, btw :)
07:16:48 <kosmikus> desegnis: if you want to set up things in a completely different way, %subst is the right place to look at
07:17:07 <ndm> kosmikus: i did what i think you are saying, and get errors on \resethooks
07:17:20 <ndm> (just boiling it down to a minimal test case)
07:17:47 <kosmikus> ndm: thanks
07:21:04 <kosmikus> desegnis: always good to know another user, too :)
07:21:32 <wvd> if I use $ in the following way: f $ g $ x, its just a different way of writing f(g x) right?
07:22:15 <ndm> \begin{code}`seq`\end{code}
07:22:28 <ndm> %format `seq` = "\backtick{seq}"
07:22:40 <ndm> \newcommand{\backtick}[1]{\;\mathsf{\`{}\!#1\!\`{}}\;}
07:22:44 <ndm> in 1.12
07:23:02 <ndm> \>[B]{}\backtick{seq}{}\<[E]
07:23:02 <ndm> \ColumnHook
07:23:02 <ndm> \end{hscode}\resethooks
07:23:06 <desegnis> @pl f $ g $ x
07:23:06 <lambdabot> f (g x)
07:24:12 <kosmikus> ndm: that fails?
07:24:21 <ndm> kosmikus: the above goes wrong
07:24:40 <Igloo> wvd: Yes (and you don't need the second $ there)
07:25:15 <wvd> so is it just some sugar to get rid of the parens then?
07:25:25 <wvd> or why would people use $?
07:26:02 <ndm> kosmikus: yes, i wrote the first line, i defined the formatting directive, i defined the \backtick thing
07:26:09 * kosmikus tries
07:26:14 <ndm> then when i use it, i get loads of errors on the \end{hscode} bit
07:26:22 <ndm> that is in 1.12, not hte latest release
07:26:43 <kosmikus> shouldn't really matter
07:28:28 <kosmikus> ndm: what's this \`{} ?
07:29:50 <ndm> kosmikus: to get a nice prime out of it
07:30:14 <kosmikus> the problem is you're mixing text and math mode commands
07:30:14 <ndm> i.e. pretty `
07:30:35 <kosmikus> \` is only available in text mode
07:30:40 <ndm> so how should i be doing it to get a nice `
07:31:21 <kosmikus> so if that's what you want
07:31:25 <kosmikus> \newcommand{\backtick}[1]{\;\mathsf{\text{\`{}}\!#1\!\text{\`{}}}\;}
07:31:56 <kosmikus> this is probably possible to simplify, but I don't want to think about it
07:32:54 <Botje> ye gods; that's significantly worse than perl :
07:33:03 <nominolo> @seen conal
07:33:04 <lambdabot> I saw conal leaving #haskell and #ghc 9h 14m 57s ago, and .
07:33:22 <ndm> kosmikus: many thanks, that seems to fix that particular issue - just checking if something else gets thrown up...
07:37:08 <ndm> kosmikus: all seems to be much happier now, thanks!
07:37:12 <ndm> @karma+ kosmikus
07:37:13 <lambdabot> kosmikus's karma raised to 8.
07:38:46 <kosmikus> glad to hear that
07:43:22 <hpaste>  bran_ pasted "shouldn't this work?" at http://hpaste.org/5720
07:43:45 <bran_> <-- what am i doing wrong w/ this type?
07:45:59 <LoganCapaldo> Object needs a forall
07:46:06 <LoganCapaldo> or you can use GADT syntax
07:47:49 <LoganCapaldo> to make it useful you'll probably also want to make Object an instance Kind
07:48:09 <LoganCapaldo> or you can just parametize Object on a
07:48:17 <LoganCapaldo> data Objecta = ...
07:48:24 <LoganCapaldo> *data Object a = ...
07:48:55 <guenni> hi guys, is there also a Haskell newbie mailing list?
07:48:58 <LoganCapaldo> but considering the name of your type I suspect that's not the effect you were going for
07:49:08 <Zao> guenni: haskell-cafe is rather newbie-friendly.
07:49:33 <guenni> Zao: thx, where do I find it?
07:50:22 <Zao> http://www.haskell.org/haskellwiki/Mailing_lists
07:50:23 <lambdabot> Title: Mailing lists - HaskellWiki
07:50:30 <Zao> http://haskell.org/mailman/listinfo/haskell-cafe
07:50:45 <guenni> perfect, thx
07:54:25 <bran_> Logan: thx
07:59:28 <SAPANA> Hey
08:22:08 <Saizan> hi bakert
08:22:15 <bakert> hi Saizan
08:22:19 <bakert> have you got ops on this channel?
08:22:25 <bakert> http://files.codersbase.com/haskell/haskell-current.png is a 403 for me
08:22:36 <bakert> (that's what the tinyurl points at)
08:22:40 <bakert> (in the topic)
08:23:20 <bakert> Riddle me this, haskellers, if I want to write something like Mechanize for Haskell, do I need to create a monad for it?
08:23:25 <Saizan> i've ops, but it's lispy who manages that image, iirc
08:23:41 <bakert> yes i suppose ops is not really what is wanted
08:23:42 <bakert> :(
08:24:09 <cinimod> @src unfoldr
08:24:09 <lambdabot> unfoldr f b  = case f b of
08:24:09 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
08:24:09 <lambdabot>    Nothing        -> []
08:24:11 <Saizan> Mechanize is to write crawlers?
08:24:13 <oerjan> i thought lispy said something was wrong with it yesterday
08:24:14 <lambdabot> oerjan: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:24:40 <bakert> Saizan: yes.  handles cookies automatically and allows you to "submit the form" without having to scrape it first.  that kind of thing
08:25:03 <bakert> i need it for a tiny little program i am writing
08:25:22 <bakert> i looked at the proposed libcurl bindings and the proposed port of Mechanize but neither seem to have come to anything
08:25:28 <Saizan> bakert: so you want a little EDSL to easily script them?
08:25:35 <bakert> basically yes
08:25:54 <Saizan> monads are often a good tool for that
08:25:57 <bakert> i just want to be able to say "go to this page" "submit the form with these values" "now get me this page"
08:26:05 <bakert> and have the text of the last page
08:26:16 <bakert> but it seems that such a lib does not exist
08:26:26 <bakert> i have a little thing i wrote last year that does some of it
08:26:36 <bakert> using Network.Browser
08:26:42 <Saizan> heh
08:27:01 <Saizan> and how would you deal with errors?
08:27:40 <bakert> i was using Either in my code from last year
08:27:48 <bakert> and ErrorCall
08:27:54 <bakert> whatever that is (i can't rememebr)
08:28:08 <bakert> and throw
08:28:12 <bakert> and throwIO
08:28:17 <bakert> it's a bit of a mish-mash :p
08:28:52 <bakert> i have a not telling me to use Dynamic not ErrorCall although i no longer know why i wrote that note
08:29:12 <bakert> this is stuff from Control.Exception, I think
08:29:54 <bakert> Saizan: that make any sense to you? :p
08:30:56 <Saizan> yeah, some :)
08:31:30 <bakert> I just read "8 different error handling methods in Haskell" that seemed to imply that using "fail" was the way to go
08:31:42 <bakert> I know nothing about "fail"
08:31:52 <bakert> but perhaps i should
08:31:58 <Saizan> Dynamic is to be able to seperate your exceptions in different types but still handle them in a somewhat uniform way
08:32:08 <bakert> that sounds good
08:32:12 <Saizan> bakert: fail is unfortunately a metod of Monad
08:32:20 <vincenz> fail is a faiure
08:32:26 <bakert> oh
08:32:27 <bakert> :)
08:32:29 <Saizan> > fail "foo" :: Maybe ()
08:32:33 <lambdabot>  Nothing
08:32:40 <Saizan> > fail "foo" :: Either String ()
08:32:41 <lambdabot>  Left "foo"
08:32:53 <bakert> interesting
08:33:12 <bakert> this dude seems to be pro-fail
08:33:12 <bakert> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
08:33:13 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
08:33:20 <Saizan> yeah, it represents an error condition, it's useful for monads that can represent them
08:33:37 <Saizan> fail is quite limited since you've to pass information about the error in a String
08:34:07 <yaru1022> how do I pass argument when I use emacs + haskell-mode?
08:34:18 <resiak> So, some kind of Monad m => MonadError m e where fail :: e -> m () construction is needed?
08:35:36 <Saizan> resiak: there's already a MonadError, designed to integrate with fail (altough that's not a good thing imho)
08:35:51 <resiak> mm
08:35:57 <bakert> I think I will probably just muddle through with my existing mini-lib
08:36:02 <bakert> with get, post and postForm functions
08:36:12 <bakert> and a bit of regex related madness
08:36:21 <bakert> if i can remember how to do regexes in haskell ...
08:36:22 <Saizan> yaru1022: what do you mean by pass arguments?
08:36:38 <Saizan> bakert: do you have the code available somewhere?
08:36:48 <bakert> @paste
08:36:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:37:08 <yaru1022> I'd like to run my main method with some arguments in ghci
08:37:16 <yaru1022> because my main method has do args <- getArgs
08:37:17 <hpaste>  bakert pasted "Simple Scraping Lib" at http://hpaste.org/5723
08:37:38 <bakert> Saizan: that's my basic thingy ^^^^
08:37:47 <oerjan> yaru1022: :main ...
08:37:53 <oerjan> note that :
08:38:18 <yaru1022> oerjan, great! that's what I was looking for :) thanks oerjan
08:38:42 <bakert> Saizan: feel free to rip into my scraper thing ... i am a learner :)
08:38:44 <bakert> (still)
08:39:28 <oerjan> :)
08:39:42 <basti_> how can i somehow enforce coq-like constraints on functions being either structurally recursive or structurally corecursive?
08:40:15 <faxathisia> basti: You can use Coq
08:40:23 <basti_> true.
08:40:30 <faxathisia> basti: No way to do this in haskell though
08:40:49 <basti_> not even with some fancy class constraining functions?
08:41:00 <Saizan> bakert: well, what i note is that you add doReq an every primitive, preventing you from reusing them for more complex tasks, like you note in the TODO
08:41:24 <bakert> Saizan: how do i avoid that?
08:42:14 <bakert> i get the feeling that my scraping lib is from a non-functional mindset
08:42:26 <bakert> but i don't know how else to structure it
08:42:26 <Saizan> bakert: well you can simply remove doReq from there and use it in the user-code rather than in the lib-code
08:43:00 <bakert> i suppose so.  but this way all the horribleness is in the library and the calling code just says 'get "http://google.com/"'
08:43:04 <bakert> which i quite like
08:43:49 <bakert> what i'd really like are optional arguments but that doesn't really fly in the haskell universer
08:43:51 <bakert> *universe
08:44:09 <bakert> which again is probably an indicator that i'm not thinking haskelly
08:44:42 <Saizan> that's true.. you could use a typeclass then.. class Foo r where doReq :: Request -> r, instance Foo Request where doReq r = r, instance Foo (BrowserAction String) where doReq r = <your doReq here>
08:45:39 <bakert> intriguing
08:45:43 <bakert> this stuff warps my head
08:45:45 <bakert> :p
08:46:01 <Twey> bakert: Welcome to Haskell!
08:46:06 <Twey> :>
08:46:15 <bakert> not so much "welcome as "
08:46:28 <bakert> not so much "welcome" as "you are in a maze of twisty passages all alike"
08:46:34 <Twey> Hehe
08:46:35 <bakert> (first haskell program now 18 months old)
08:46:36 <resiak> nooo!  the 0th and succ 0th links on http://www.haskell.org/haskellwiki/Obfuscation are broken!
08:46:38 <lambdabot> Title: Obfuscation - HaskellWiki
08:46:38 <Twey> But it's *fun*
08:46:44 <bakert> sometimes!
08:46:51 <Twey> I like mazes ^_^
08:47:27 <Twey> Haskell is taking me the longest to grasp of all the programming languages I've learnt... I'm very much enjoying it :-P
08:47:54 <Twey> resiak: It's not broken, it's just extra-obfuscated
08:48:18 <resiak> heh
08:48:30 <bakert> Twey: it's taking me so long to grasp that i still have no idea if it is going to be worth it or not ... :(
08:48:34 <Saizan> bakert: it exploits the fact that in haskell we have method dispatch on return types
08:48:58 <bakert> i see so because of what we infer the calling code is expecting it calls different methods
08:49:00 <bakert> crazy
08:49:08 <Saizan> bakert: exactly
08:49:34 <Saizan> so then get/post etc.. can return either a Request or a BrowserAction String depending on the needs :)
08:50:01 <Twey> bakert: If it takes us this long, it *must* be worth learning, if just for the intellectual exercise :-P
08:50:16 <Twey> (plus: ultimate job security!)
08:51:01 <bakert> Twey: possibly.  or it could be the equivalent of spending your life playing Go or Chess and not building anything.  i haven't worked it out yet.
08:51:16 <bakert> darcs and lambdabot give me hope :)
08:51:21 <Twey> Hehe
08:51:42 <faxathisia> unless you choose something to make you willbe learning forever
08:51:49 <Saizan> bakert: i think a port of Mechanize will make a really appreciated lib on hackage, even if the HTTP backends are not exactly mature at this point
08:52:01 <guenni> if I wanted to get to the x of some x:xs without using any pattern matching, how could I do that?
08:52:02 <faxathisia> (you will anyway though.. just not while making something)
08:52:12 <bakert> Saizan: the trouble is i think any contribution of mine would be so haskell-naive that it wouldn't be useful
08:52:12 <faxathisia> guenni, head does that
08:52:26 <Twey> bakert: It's always useful
08:52:39 <guenni> faxathisia: yep it does but that is also defined via pattern matching
08:52:47 <faxathisia> @hoogle (a -> b) -> ([a] -> b) -> [a] -> b
08:52:48 <Twey> bakert: You can always improve it later, or if it's popular enough, someone else might and you can learn from that.
08:52:48 <lambdabot> No matches, try a more general search
08:53:11 <faxathisia> guenni, In haskell pattern matching is the only way to destructure compound objects
08:53:12 <bakert> Twey: true
08:53:25 <faxathisia> guenni, Since e.g. eliminators aren't synthesized
08:53:40 <Saizan> bakert: you've the need for it, and so some ideas on which would be a nice API
08:53:57 <faxathisia> ?Djinn (a -> b) -> (Maybe a -> b) -> (Maybe a) -> b
08:53:58 <lambdabot> f a b c =
08:53:58 <lambdabot>     case c of
08:53:58 <lambdabot>     Nothing -> b Nothing
08:53:58 <lambdabot>     Just d -> a d
08:54:00 <keseldude> hi Cale, are you available, and if you are, do you mind if I PM you?
08:54:59 <faxathisia> @hoogle b -> (a -> [a] -> b) -> [a] -> b
08:55:00 <lambdabot> No matches, try a more general search
08:55:12 <guenni> faxathisia: thx for the answer but I don't see how this decomposition is defined by the lambda calculus
08:55:21 <oerjan> faxathisia: what's that supposed to do? the two first arguments seem redundant
08:55:44 <sclv> basti: there is a stream lib for infinite lists that lets you guarantee infiniteness.
08:56:16 <oerjan> (your djinn example)
08:56:25 <faxathisia> oerjan first one was a mistake, the second should be f case1 case2 [] = case1 ; f case1 case2 (x:xs) = case2 x xs
08:56:36 <basti_> sclv: i will have a look, thanks
08:56:40 <guenni> I mean I remember from list that cons car & cdr where somewhat defined in terms of another
08:56:44 <faxathisia> guenni, You have to extend that calculus with datatypes
08:56:49 <guenni> lisp sry
08:57:16 <faxathisia> guenni, You have a choice when you do that.. are you going to do destructuring with combinators or pattern matching
08:57:18 <oerjan> faxathisia: ah.  well i haven't seen such a thing
08:57:25 <Saizan> bakert: so your lib lacks handling of Cookies?
08:57:32 <guenni> so it wouldn't be possible to express this data structure and decomposition via function definition?
08:57:47 <bakert> Saizan: actually no, i think that Network.Browser handles cookies in BrowserAction somehow
08:57:47 <faxathisia> oerjan, There seems to be one for Maybe and Either but I guess not every type
08:58:05 <ilyak> Hi everyone!
08:58:08 <bakert> Saizan: it was the form-handling capabilities of Mechanize i was missing most
08:58:17 <sclv> oh and for data you can either write a list that's strict in all its elements, so that if you try to construct an infinite one you get immediate nontermination or you can create a type of list that only can be constructed initially by, e.g., an integral enumeration and with no append function.
08:58:19 <ilyak> Is there a doReadFile function in GHC? If yes, how would I import it?
08:58:33 <faxathisia> guenni, It would but you would have to use data structures as functions instead of defined by 'data _ = ...'
08:58:50 <oerjan> faxathisia: the thing is Maybe and Either are not recursive.  [] is which means the catamorphism function (foldr) is recursive too.
08:58:50 <guenni> faxathisia: not really sure yet, hope this becomes clearer once I learnt more about Haskell
08:59:12 <guenni> faxathisia: not really sure yet, hope this becomes clearer once I learnt more about Haskell
08:59:17 <nominolo> @hoogle withFile
08:59:17 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
08:59:30 <nominolo> ilyak: would that be sufficient?
08:59:40 <ilyak> nominolo: doReadFile was String -> String
08:59:43 <ilyak> This one is monadic
09:00:08 <guenni> faxathisia: the data notation is syntactic sugar then?
09:00:16 <nominolo> ilyak: where would the result be written to?
09:00:23 <faxathisia> guenni, No, It's an actual language feature
09:00:33 <ilyak> nominolo: Result of what?
09:00:40 <nominolo> ilyak: of the function
09:00:41 <faxathisia> oerjan, Ah thanks, I had no idea these were catamorphisms
09:00:55 <guenni> faxathisia: part of the typed lambda calculus then?
09:00:59 <ilyak> nominolo: Well, it will occasionally end up being on console via interact
09:01:54 <nominolo> so you want to re-route the input to interact from a file instead of stdin?
09:02:04 <nominolo> @src interact
09:02:05 <lambdabot> interact f = do s <- getContents; putStr (f s)
09:02:18 <Saizan> bakert: which are that it parses the page, collects the forms in a list and gives nice methods to fill it and post?
09:02:25 <bakert> yeah
09:02:31 <faxathisia> guenni, Say we start with some typed calculus, term ::= var | (term term) | (\var -> term)
09:02:32 <ilyak> nominolo: No, I want to load data from file
09:02:41 <ilyak> to use in my computations
09:02:57 <guenni> faxathisia: k
09:03:06 <nominolo> ilyak: how can this be pure?
09:03:11 <faxathisia> guenni, Imagine that data Bool = True | False adds two new constants, True : Bool and False : Bool
09:03:26 <guenni> k
09:03:26 <faxathisia> guenni, Right now, there's now way to write if..
09:03:26 <ilyak> nominolo: well, file contents is a pretty deterministic thing
09:03:38 <ilyak> Assuming it wouldn't change while program is running
09:03:45 <jedbrown> @ty readFile ?f1 >>= writeFile ?f2 . ?func
09:03:46 <lambdabot> (?func::String -> String, ?f2::FilePath, ?f1::FilePath) => IO ()
09:03:48 <oerjan> :t readFile
09:03:49 <lambdabot> FilePath -> IO String
09:03:54 <sclv> ilyak, but imagine you're on unix. a file descriptor can be anything...
09:03:55 <ilyak> XSL is strict and pure, and it allows document(), for example
09:04:13 <guenni> k
09:04:18 <faxathisia> guenni, so one possibility is to have eliminators generated when you make a new data type, in this case it would be like.. b -> b -> Bool -> b
09:04:37 <ilyak> sclv: Well, we can make an assumption that is't the regular file with const contents
09:04:39 <sclv> the thing about referential transparancy in haskell is it doesn't do "sorta" -- it either is or it isn't.
09:05:04 <faxathisia> guenni, You could define pattern matching as syntactic sugar that compiles into that
09:05:23 <sclv> part of the value of a strong type system is that it doesn't let you make assumptions that you can't guarantee.
09:05:24 <guenni> k
09:05:26 <faxathisia> guenni, Instead of that though, haskell takes the other approach, (\var -> term) is changed to (\pattern -> term)
09:05:36 <ilyak> sclv: Well, then read file once and use the cached version.
09:05:45 <faxathisia> guenni, and you can write the eliminator functions using that
09:05:46 <ilyak> That will make it purely pure :)
09:06:08 <sclv> it's not really pure unless its the same if you run it today and tomorrow.
09:06:18 <faxathisia> guenni, so those two mechanisms are basically equivalent, but you couldn't do without at least one
09:06:46 <ilyak> sclv: Well, everything isn't really pure then.
09:06:50 <sclv> if you want to work with a file, you're going to need to be in the IO monad a bit. Don't worry though. its not scary.
09:06:57 <ilyak> Libraries change, hardware errors occur
09:07:21 <guenni> faxathisia: so essentailly this is mathematically consistent and not some sort of "Dogmatic" thing like in let's say Java?
09:07:29 <jedbrown> ilyak: I think you want something like this: interact2 file1 file2 func = readFile file1 >>= writeFile file2 . func
09:07:43 <ilyak> I mean, if there will be doReadFile in GHC I could make a XSL transformer that will be entirely functional, inside interact
09:07:44 <jedbrown> ilyak: You can't touch the file system without being in IO.
09:07:51 <sclv> ilyak: that's why the top level function of every haskell function is main :: IO a
09:08:00 <Saizan> bakert: have you found a nice html or xml parsing lib?:) other than HaXml or HXT, we've tagsoup that gives you a stream of tags rather than a tree
09:08:02 <sclv> s/function/binary/
09:08:03 <ilyak> Hugs have this function, I think
09:08:13 <ilyak> And it's String -> Stringf
09:08:17 <ilyak> s/f$//
09:08:33 <bakert> Saizan: i am just using Text.Regex ... I did look at TagSoup earlier today on nominolo's recommendation.  It didn't seem to do an awful lot.
09:08:35 <sclv> ?hoogle interact
09:08:35 <jedbrown> ilyak: Why not use my interact2 and put all the logic in `func'?
09:08:35 <lambdabot> Prelude.interact :: (String -> String) -> IO ()
09:08:35 <lambdabot> System.IO.interact :: (String -> String) -> IO ()
09:08:35 <lambdabot> Data.ByteString.interact :: (ByteString -> ByteString) -> IO ()
09:08:37 <nominolo> ilyak: i think you should need to describe what the function is supposed to do
09:08:48 <ilyak> http://users.dimi.uniud.it/~marco.comini/Students/Documentation/Haskell-Prelude-Tour-A4.pdf
09:08:49 <lambdabot> http://tinyurl.com/2blr4q
09:08:58 <ilyak>  /doReadFile
09:09:00 <bakert> Saizan: the trouble with TagSoup is that it can't log me in to the website
09:09:39 <faxathisia> guenni, Not sure what you mean.. both languages are defined formally.. neither have a consistent logical interpretation
09:10:08 <nominolo> that must be using unsafePerformIO inside
09:10:15 <Saizan> bakert: well, neither Text.Regex .. the Download module of TagSoup is just for convenience, not intended for anything more than the simplest case
09:10:47 <bakert> mmm ... this is an ASP.NET website with odd __VIEWSTATE hidden vars.  needs something just a bit more complicated.
09:11:00 <guenni> faxathisia: I'm not really sure either, sry, thanks for your time
09:11:04 <bakert> currently it just sends me a series of 302s :(
09:11:10 <jedbrown> nominolo: Yeah.  Shocking!
09:11:13 <nominolo> ilyak: the problem is that it requires some assumptions that cannot generally be guaranteed
09:11:24 <faxathisia> guenni, no problem, bbl
09:11:40 <ilyak> nominolo: Well, assumptions are like that
09:11:40 <nominolo> ilyak: it assumes the file will always be there and it's contents will never change
09:11:48 <ilyak> You always assume them and they're always leaky
09:11:55 <ilyak> nominolo: Yeah, exactly
09:12:08 <nominolo> ilyak: then use unsafePerformIO
09:12:13 <ilyak> :)
09:12:31 <nominolo> ilyak: but don't be mad if your program crashes mysteriously
09:12:38 <sclv> ilyak: note that function is described as "not a standard function". i.e. its something some dude wrote.
09:12:50 <sclv> it is generally considered very bad form to do things like this.
09:12:55 <ilyak> I wouldn't, I'g just writing a few small programs to get into language
09:13:13 <jedbrown> ilyak: You were going to put your logic within interact anyway.  Interact has type (String -> String) -> IO ().  My function interact2 has type FilePath -> FilePath -> (String -> String) -> IO ().
09:13:30 <sclv> if you want to get a feel for the language, you should avoid things like this and learn the standard idioms.
09:13:34 <nominolo> ilyak: the idea is that pure code is independent of when and how often it is being executed
09:14:09 <jedbrown> ilyak: Note how once you give interact2 the file names, it looks just like interact.
09:14:26 <ilyak> jedbrown: The problem that, if you're making an XSL interpreter, you can find yourself needing to read file in any XPath expression
09:14:30 <sclv> in my HStringTemplate library I wanted to have this feature available for creating and debugging templates on the fly and eventually ended up coining the name unsafeVolatileTemplateGroup or such to indicate that referential transparancy wasn't guaranteed.
09:15:02 <ilyak> And, besides that, it's pure all the way
09:15:14 <nominolo> ilyak: no, it can fail
09:15:28 <nominolo> failure is actually not pure
09:15:36 <ilyak> nominolo: Sure, everything can fail. show, for example.
09:15:43 <ilyak> Oh, read.
09:15:54 <ilyak> read can fail, and you can't really predict that
09:16:00 <nominolo> yes, read has the wrong type
09:16:10 <nominolo> so has head and tail
09:16:35 <nominolo> you generally don't want that, but it's there for historical reasons
09:16:40 <ilyak> If you'll make then the right way, you'll have to make all your program monadic
09:16:53 <ilyak> And then, you'll having C with weird syntax not Haskell :)
09:16:55 <nominolo> parts of it yes
09:17:22 <nominolo> all but a few monads have a run-function to turn it unto a pure computation
09:17:26 <sclv> ilyak: not really. read can become maybeRead which returns Maybe a, as we've been discussing. safeHead similarly.
09:18:00 <nominolo> ilyak: then: fromMaybe defaultValue (maybeRead ...)  is pure
09:18:11 <ilyak>  :)
09:18:25 <ilyak> Yeah, that would be useful
09:19:06 <nominolo> the problem now is that Maybe a might give too little information about the error ;)
09:19:10 <sclv> what you really want though, I guess, is the ability to embed a file read deep inside a parser?
09:19:37 <nominolo> error handling in haskell is still a bit immature
09:19:48 <sclv> or rather an interpreter.
09:20:02 <ilyak> sclv: Yeah
09:20:17 <sclv> I'd suggest implementing it without the readfile functionality first, to get a good feel for it.
09:20:38 <ilyak> sclv: I did.
09:20:53 <nominolo> weren't the arrow-based solutions meant for this?
09:21:01 <ilyak> Sort of :)
09:21:02 <sclv> ok, so now instead of your function returning a String, think about how you need to modify it to have it return an IO String.
09:21:23 <ilyak> I'll consider that.
09:21:50 <sclv> it shouldn't require switching to do notation at all I think
09:21:53 <nominolo> hm, i think Ralf Hinze mentioned that delimited continuations are pure in some sense
09:22:00 <nominolo> but i can't remember the details
09:22:21 <ilyak> But I suddently realized that read, tail, head etc, which are simple and throw errors are very useful if you look at them erlang-wise
09:22:48 <ilyak> Like, simple computation which uses some unsafe things, but if it crashes you just handle it and restart the process from the next entry
09:23:22 <nominolo> ilyak: but it will always crash for the same input
09:23:43 <nominolo> ilyak: erlang requires fail-over strategies
09:23:43 <sclv> nominolo: not if it breaks rt :-)
09:23:47 <ilyak> nominolo: That's why we'se starting from the *next* entry :)
09:24:12 <nominolo> sclv: rt?
09:24:32 <sclv> referential transparency.
09:25:17 <nominolo> sclv: well, yes.  But he was talking about head and tail
09:25:33 <nominolo> ilyak: you might actually be able to implement this
09:25:45 <nominolo> ilyak: i think you can catch "undefined" errors in IO
09:25:49 <ilyak> nominolo: I guess I might, yeah.
09:26:01 <ilyak> I'll try if need arise
09:26:06 <nominolo> ilyak: it's not usually considered "haskelly" though ;)
09:26:07 <sclv> ilyak: one standard idiom for processing a list of things that can fail is to do everything inside the maybe monad and then catMaybes.
09:30:58 <takamu> hi
09:55:33 <Nelllliot>  8-)
09:57:50 <Nelllliot> Hello
10:07:27 <n00b> i am trying to do a auto-write in haskell... i have a program that writes a text file , sometimes i forget  to write and give me this err "file not found", i would like if the file to be written if not found
10:08:44 <romeo1> is Nexuiz a educational type game or a damaging type of games like those are released for windows?
10:09:24 <ari> romeo1: The damaging type game
10:10:23 <radix> hah, "like those are released for windows"
10:10:41 <Japsu> attention everyone, we have a troll here! please do not feed him!
10:10:51 <ari> romeo1: If you said "nexuiz" by mistake and were trying to say "frag" instead, well, that's more educational, but AFAIK not on purpose but simply because it does not have the features to make it fun yet :)
10:11:05 <dons> ?users
10:11:05 <lambdabot> Maximum users seen in #haskell: 463, currently: 447 (96.5%), active: 17 (3.8%)
10:11:24 <dons> n00b: ok. so you check for the file's existence?
10:11:26 <radix> Japsu: who?
10:11:30 <Japsu> radix: romeo1
10:11:32 <radix> I hope I haven't been flagged as a troll
10:11:33 <radix> oh, whew
10:11:39 <Japsu> he's a persistent troll abusing several channels
10:11:44 <radix> okie doke
10:11:55 <oerjan> @index doesFileExist
10:11:56 <lambdabot> System.Directory, Distribution.Compat.Directory
10:12:10 <oerjan> n00b: might want to use that
10:13:30 <oerjan> or you could catch the IO error from the file opening
10:13:35 <larmeh> mh, can anyone tell me what "main :: IO ()" means? i'm guessing it means a parameter of type IO and no return type, right?
10:13:50 <oerjan> larmeh: more or less.
10:13:56 <dons> larmeh: it returns a value of (), in the IO monad.
10:14:01 <oerjan> () is a type, but a dummy one with only one value
10:14:29 <idnar> it doesn't take any parameters, though
10:14:45 <idnar> (there's no -> )
10:15:08 <oerjan> oh right, IO () is the type of main as a whole
10:15:21 <oerjan> an IO action returning a dummy ()
10:15:29 <Lord_Illidan> Hi!
10:15:31 <larmeh> hm okay
10:15:36 <Lord_Illidan> I have a question..
10:15:57 <Lord_Illidan> what is the inferred type of scale :: Picture -> Int -> Picture
10:16:15 <dons> ddarius: normalised community religious affiliiation, http://reddit.com/info/68zvo/comments/c037gis
10:16:21 <oerjan> Lord_Illidan: um, that is a type declaration
10:16:29 <oerjan> nothing to infer, it's explicit
10:16:31 <dons> apparently FP communities are full of unbelievers :)
10:17:14 <Lord_Illidan> er, ok..what I mean is..the book is saying that we know that it has 2 arguments, Picture and Int
10:17:37 <nominolo> dons: it's similar for all the other languages with sufficiently many data points
10:17:40 <Lord_Illidan> but it appears to have 3 arguments
10:17:46 <dons> nominolo: ah!
10:17:50 <oerjan> Lord_Illidan: no the last Picture is the result type
10:18:06 <Lord_Illidan> oerjan, ah, ok
10:18:12 <dons> nominolo: so you don't think its statistically significant?
10:18:13 <nominolo> dons: the real answer is - there is no correlation between PL and Religion.  though probably between religion and being a programmer
10:18:14 <Lord_Illidan> So a function can only return 1 type of result?
10:18:16 <ari> (sorry for using the silly emoticon but it's the only appropriate thing here)   That's more atheists and agnostics you're going to find on richarddawkins.net o.o
10:18:26 <nominolo> dons: no
10:18:38 <oerjan> Lord_Illidan: yes.  and technically it only takes 1 argument as well.
10:18:43 <Nafai> nominolo: Why do you say that?
10:18:44 <Lord_Illidan> oerjan, ?
10:18:54 <Lord_Illidan> scale takes 2 arguments, not 1
10:18:55 <n00b> i am trying to do a auto-write in haskell... i have a program that writes a text file , sometimes i forget to write and give me this err "file not found", i would like if the file to be written if not found
10:19:02 <oerjan> that's actually equivalent to scale :: Picture -> (Int -> Picture)
10:19:23 <birkenfeld> hey dons
10:19:33 <oerjan> it takes one argument, and returns a function that takes the next one
10:19:36 <dons> hey
10:19:43 <Lord_Illidan> oerjan, ah
10:19:43 <nominolo> Nafai: haskell was like 50% atheists + 25% agnostic
10:19:54 <dons> n00b: use System.Directory to test for the file's existence
10:19:57 <birkenfeld> I was a bit surprised by your reddit submission today :)
10:20:13 <nominolo> others were maybe 45% + 25%
10:20:32 <nominolo> i already hid the reddit item so i can't find it atm
10:20:33 <dons> birkenfeld: oh, i just stumbled across it. obviously a bit stood out to me.
10:20:50 <n00b> wc        =   do  writeFile "code.txt" (show randomize)   wc =   do  writeFile "code.txt" (show randomize)   putStrLn "The Codes have been written!", if the file is not found it  should hence just write the file
10:20:50 <dons> then i noticed CleverCSS on hackage -- thanks for uploading that.
10:21:07 <Lord_Illidan> so when we have an arrow in the type decleration field, it usually means that we are returning another function?
10:21:16 * Nafai is nervous about starting his new job tomorrow
10:21:17 <birkenfeld> I hope people notice that it's not about LOC :)
10:21:30 <Nafai> birkenfeld: You're the guy that ported CleverCSS to Haskell?
10:21:39 <birkenfeld> yep
10:21:42 <Nafai> Cool
10:21:48 <nominolo> @hackage clevercss
10:21:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/clevercss
10:22:06 <dons> ?google site:hackage.haskell.org CleverCSS
10:22:07 <lambdabot> No Result Found.
10:22:20 <dons> nominolo: we need the hackage search wired into lambdabot :)
10:22:42 <dons> birkenfeld: do you still write much haskell code?
10:23:04 <nominolo> yeah, @hackage is only useful for perfect typists and people in the know
10:23:20 <dons> not so much search, but link expansion :)
10:23:34 <oerjan> Lord_Illidan: the arrow means that it _is_ a function.  if there are arrows in the result part of that, then yes.
10:23:38 <birkenfeld> dons: unfortunately not... spending most of my time with Python's docs
10:23:54 <nominolo> birkenfeld: heh, 700+LOC and one exported function, nice :)
10:24:01 <oerjan> function type is: argument -> result
10:24:08 <n00b> if System.Directory does not find the code can it then automatically write the code?
10:24:14 <Lord_Illidan> oerjan, I'm asking as I'm seeing a module which has these type definition arrows all over the place, and I'm confused.
10:24:25 <n00b> using like a if then else clause
10:24:25 <birkenfeld> but I'd really love to do some more haskell projects in the future
10:24:33 <dons> n00b: sure.
10:24:53 <dons> birkenfeld: cool. it looked like you enjoyed the project.
10:25:19 <Lord_Illidan> oerjan, look at this code : http://pastebin.com/m5827dab3
10:25:21 <birkenfeld> I hope the code is acceptable for publication :)
10:26:08 <nominolo> dons: oh, the .cabal for clever-css is not ghc-6.8.2 save
10:26:11 <Lord_Illidan> superimpose :: Picture -> Picture -> Picture
10:26:16 <nominolo> (build error)
10:26:24 <birkenfeld> nominolo: how that?
10:26:29 <oerjan> Lord_Illidan: yep, those things with declarations of the form name :: whatever -> whatever are functions
10:26:40 <Lord_Illidan> does the type definition give an insight into what is going on inside the function itself, then?
10:26:42 <nominolo> birkenfeld: did you build it on ghc 6.8.2?
10:26:49 <oerjan> and -> is right associative
10:26:51 <birkenfeld> no, not yet
10:26:51 <Lord_Illidan> ah, wait, now I got it
10:26:55 <nominolo> birkenfeld: http://hackage.haskell.org/packages/archive/clevercss/0.1/logs/failure/ghc-6.8
10:26:57 <lambdabot> http://tinyurl.com/39drv8
10:27:04 <nominolo> birkenfeld: the package structure failed
10:27:12 <nominolo> birkenfeld: so you need some conditionals
10:27:21 <oerjan> Lord_Illidan: some insight, yes
10:27:24 <birkenfeld> ok, let me fix that
10:27:25 <Lord_Illidan> Picture -> Picture -> Picture is because of the arguments, yes
10:27:39 <nominolo> birkenfeld: atm, i don't know of a good tutorial how to do this stuff.  let me look
10:28:09 <Lord_Illidan> jeez, the arrows confuse the crap out of me..:(
10:28:11 <nominolo> birkenfeld: http://haskell.org/haskellwiki/Upgrading_packages
10:28:24 <nominolo> birkenfeld: see item 1.2
10:28:29 <birkenfeld> thanks!
10:28:41 <oerjan> Lord_Illidan: everything to the left of a -> is an argument
10:29:32 <nominolo> birkenfeld: in a while we could probably generate this stuff from the sources, but we're not there yet
10:29:34 <Lord_Illidan> I have to go out for a bit, will pop in later, thanks for your replies!
10:29:59 <n00b> doesFileExist :: FilePath -> IO Bool, what if i wanna check the same directory if the file is in there... what would the filepath be ?
10:31:26 <Botje> a FilePath is really just a string
10:31:39 <Botje> :t "/etc/passwd" :: FilePath
10:31:41 <lambdabot> FilePath
10:31:52 <oerjan> @src FilePath
10:31:53 <lambdabot> type FilePath = String
10:32:48 <n00b> so the same directory where the code is located would be seen as "/"
10:32:51 <n00b> ???
10:33:12 <dons> "." ?
10:33:50 <n00b> i want the code to be portable, hence not changing code all the time
10:34:06 <ddarius> Incidentally, has anyone else noticed that Alan has not responded at all to any of the responses to his post.
10:34:28 <oerjan> n00b: Cabal has a system for finding out the location of associated data files
10:37:01 <oerjan> although you don't want a portable program to write data in the same directory as the program, that may e.g. on Linux be a global directory unwritable by ordinary users
10:37:05 <Eiler> are there any nice IDE in win for haskell yet?
10:38:29 <nominolo> Eiler: ask again next year.  until then use emacs or vim :)  or try out leksah
10:39:11 <Eiler> why next year?
10:39:52 <oerjan> n00b: the System.Directory module contains several functions for constructing suitable directory names for data, e.g. getAppUserDataDirectory
10:40:38 <Eiler> !channels
10:41:47 <birkenfeld> ok, I've uploaded a new package which should build fine
10:41:56 <Eiler> would be kickass if visual haskell works in vs2008
10:42:11 <mrd> Eiler: i thought you asked for a nice IDE
10:42:33 <Eiler> mrd: and what do you think vs2008 is?
10:42:41 <mrd> a cowpie
10:43:11 <Eiler> its the best and most used ide for professinal developement on the market, in a league of its own
10:43:27 <mrd> if a million people jump off the Brooklyn Bridge, does that make it a good idea?
10:43:43 <faxathisia> What more do you want than to edit text though?
10:43:43 <Eiler> sounds like you would think so
10:44:18 <Eiler> that you disc it just because MS have made it is just pathetic
10:44:18 <Cin> vs08's intellisense is annoyingly slow
10:44:24 <mrd> no that is not why i diss it
10:44:31 <Eiler> why then?
10:44:42 <mrd> I diss it because MS, like many other companies, have missed the point entirely
10:44:43 <faxathisia> Eiler, hm?
10:44:46 <Cin> it's not particularly impressive
10:45:13 <pejo> Eiler, there's the visual haskell plugin that works for vs<some older version>.
10:45:20 <mrd> when you develop, you want to work on code.  not play around with fancy bells and whistles.  not be distracted by crazy menu systems and arrays of buttons.
10:45:21 <Eiler> they havent missed the point, they satisfy a huge amount of professinal developers, and not some unix geek
10:45:39 <Eiler> pejo: yes i saw that with ghc 6.6
10:45:48 <mrd> most windows developers tend to be the "ooh shiny thing" type
10:46:12 <birkenfeld> nominolo: why was the base package split up anyway?
10:46:13 <Eiler> and most unix developers cant use anything except a command prompt
10:46:16 <pejo> mrd, that kind of discussion isn't going to lead anywhere.
10:46:41 <SamB> Eiler: only because I've got too many subdirectories under my home directory!
10:46:54 <Eiler> ;)
10:46:56 <SamB> so that it takes forever to (a) load into a GUI or (b) find anything
10:47:13 <faxathisia> Eiler, well I don't know what more you want than a text editor
10:47:31 <Eiler> depends, what algorithms it is using and the comp you have
10:47:45 <Eiler> faxathisia: a kickass debugger, intellisence.. and stuff
10:47:52 <SamB> so what does the "ooh shiny thing" type do?
10:47:53 <faxathisia> stuff..
10:47:58 <faxathisia> This is very silly
10:48:23 <Eiler> silly for you maybe, but there is a reason so much big companies uses it
10:48:28 <SamB> I have to admit I don't mind intellisense
10:48:29 <mrd> heh
10:48:44 <SamB> I'm not sure where this kickass debugger comes in
10:48:51 <Cin> i prefer code::block's intellisense, it doesn't take half an hour to update like vs's
10:48:53 <pejo> Eiler, other than that the common editors (Emacs, vim, ..) are usable on Windows as well. If you want to hack away, Leksah could probably use a hand.
10:48:55 <mrd> big companies do a lot of things inefficiently
10:49:10 <sclv> birkenfeld: my understanding is so that its easier to update individual libraries without a full rebuild.
10:49:17 <Eiler> well so does nerds that just sit on irc also
10:49:19 <birkenfeld> ah
10:49:31 <mrd> Eiler: i don't see you not on IRC
10:49:48 <Eiler> mrd: get some eyes then, i am on irc atm
10:50:03 <Cin> mrd, eiler: well, that is irrelevant to the efficacy of vs2008
10:50:04 <mrd> Eiler: read it again
10:50:21 <yowgi> Hello. I have a question about normal forms and the Haskell type system. Is this the right place to ask?
10:50:22 <Eiler> mrd: no need, you are trying to state the obvious for no reason
10:50:30 <faxathisia> yowgi, sure
10:50:35 <mrd> Eiler: for very good reason.  but apparently it goes over your head.
10:50:38 <yowgi> I'm trying to transform lambda-expressions into their SKI equivalent using :t to check that the type of my expression stays the same at each step. is there something wrong with my approach here: http://hpaste.org/5724 ? could I get the same type in SKI form as I had in lambda form without the two having the same normal form?
10:51:14 <Eiler> mrd: no but it goes over your head, i said nerds on irc as a general speaking, i didnt say it wasnt nerdy of me to sit here
10:51:28 <mrd> ah good, we're getting somewhere
10:51:37 <Eiler> mrd: you threw all big companies into a basket saying they are inefficient
10:51:38 <faxathisia> Eiler, see PM
10:51:59 <yowgi> As I understand it, because I declared s, k, i as lambda only, Haskell does not know the types of the arguments and this seems to work using the Church-Rosser property. Am I mistaken?
10:52:22 <kmcallister> yowgi, as i understand it there are a lot of untyped lambda terms that can't be typed in haskell
10:52:31 <kmcallister> :t \x -> x x
10:52:33 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:52:34 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:52:34 <lambdabot>     In the expression: x x
10:52:40 <yowgi> yes
10:52:58 <faxathisia> yowgi, haskell either infers the type or tells you it's malformedi
10:53:20 <faxathisia> yowgi, as long as you only have lambdas (no lets) the terms will have normal forms
10:53:40 <yowgi> my question is: could there be (for example) two different  "a -> b -> a" lambda expressions that do not reduce to the same normal form?
10:53:56 <yowgi> and thus are different
10:53:59 <faxathisia> yowgi, but the normal form won't generally be an SK combination.. and you might be better to write a program to do abstraction elimination than manually
10:54:01 <kmcallister> yowgi, not in that particular case (excluing things like undefined)
10:54:14 <kmcallister> but there are two distinct expressions of type a -> a -> a, for example
10:54:26 <faxathisia> yowgi, There couldn't be two different lambda expressions
10:54:34 <yowgi> cool
10:54:39 <faxathisia> yowgi, I mean two different normal forms
10:54:42 <Eiler> mrd: its fun to see people trying to protect whatever they are using without the ability to observe stuff in an objective sence
10:55:41 <Eiler> mrd: as you referring to me being on irc im here very little compare to you
10:55:48 <yowgi> I converted succ from \n f x -> f (n f x) into S, K, I only, and it got really huge, and I was worried there could be a mistake
10:55:56 <pejo> Eiler, does this relate to Haskell in any way?
10:56:00 <faxathisia> Eiler, this is really OT.. please take it to PM
10:56:00 <yowgi> it seems using B and C it's way shorter
10:56:20 <oerjan> yowgi: i recall a theorem somewhat like, that with disjunction types, any type which is the principal type of a normal form only applies to expressions reducing to it
10:56:40 <oerjan> but it probably does not apply exactly to haskell's type system
10:56:51 <oerjan> (beta-eta-reduction)
10:57:22 <oerjan> but it may be what happens with a -> b -> a
10:58:03 <yowgi> as long as my expressions use only s, k, i  this should work then. thanks!
10:58:43 <romeo1> wanna fight? and turn it off
11:00:01 * SamB wonders how in the world he was ever listed as a darcs author
11:00:41 <oerjan> yowgi: also abstraction elimination _can_ get huge.  there are some shortcuts that can help.
11:01:15 <oerjan> e.g. s (k x) i = x, s (k x) (k y) = k (x y)
11:01:17 <romeo1> is pulling by shoulders back and good posture and aggression related?
11:01:29 <oerjan> but those don't always help
11:01:36 <SamB> dons: so, uh, how does one use darcs-to-git?
11:02:31 <oerjan> actually those two may be the main ones
11:03:03 <yowgi> oerjan, it gets huge quickly: I got succ = s (k (s (s (k s) (s (k k) i)))) (s (s (k s) (s (k (s (k k))) (s (s (k s) (s (k k) i)) (k i)))) (k (k (k i))))
11:03:22 <oerjan> yowgi: you have s (k k) i = k in there, for example
11:03:22 <yowgi> didn't try to simplify it
11:04:19 <oerjan> also it is hard to simplify the final result - you have to do it at each step
11:04:33 <dons> SamB: you create a foo.git directory, then: cd foo.git ; darcs-to-git ~/foo.darcs
11:04:39 <dons> and it dumps the git stuff in the pwd.
11:04:49 <SamB> huh. what the heck? it is working now...
11:04:49 <dons> i'm currently converting jhc, but could do with more cpu power if you're lending a hand
11:05:05 <SamB> dons: how much do you have?
11:05:06 <dons> ruby runs out of memory trying to do ghc though.
11:05:09 <dons> 2G.
11:05:30 <dons> lambdabot and cabal and base are uploading
11:05:42 <dons> ghc's the big one, but it'll take 3 days or more
11:05:56 <SamB> lambdabot is in the counting phase
11:06:01 <dons> yep
11:06:36 <oerjan> yowgi: however i have a succ in unlambda notation hidden in http://esoteric.voxelperfect.net/wiki/Deadfish, and it is not that much shorter than that
11:06:39 <lambdabot> Title: Deadfish - Esolang
11:07:52 <oerjan> `kii`k ``s``s`ks ``s`k`s`ks ``s`k`s`kk i `ki if i have extracted it correctly
11:08:38 <yowgi> some parts look similar
11:09:44 <oerjan> hm that cannot be correct
11:09:49 <SamB> dons: so you say it runs out of memory importing ghc?
11:10:00 <SamB> is that when it runs "darcs changes"?
11:10:04 <resiak> wouldn't it be easier for ohloh to grow darcs support? :o)
11:10:20 <SamB> resiak: well, we might have to improve the tools or something...
11:10:55 <oerjan> yowgi: at least the first `kii should be dropped, it's two separate expressions
11:11:16 <oerjan> maybe ``s``s`ks ``s`k`s`ks ``s`k`s`kk i `ki is it
11:15:55 <oerjan> so it was
11:17:28 <olsner> "Think of a monad as a spacesuit full of nuclear waste in the ocean next to a container of apples. Now, you can't put oranges in the space suite or the nuclear waste falls in the ocean, but the apples are carried around anyway, and you just take what you need."
11:19:12 <Taejo> lol
11:20:37 <Twey> Haha, olsner
11:22:41 <fiilicdae> hi all, I am an absolute beginner and I have an issue with one task I have to make in Haskell
11:23:29 <fiilicdae> i need to generate list of pairs [(0,0), (0,1), (1,0), (0,2), (1,1), (2,1), ...]
11:23:44 <fiilicdae> I am thinking at the moment how to solve this
11:23:50 <fiilicdae> but i had an idea
11:23:52 <dons> fiilicdae: ok. and how are the pairs computed?
11:24:02 <fiilicdae> could this be solved by declaring a custom type anyhow?
11:24:10 <faxathisia> fiilicdae: You see how the first one sums to 0, the next two sum to 1, the next 3 sum to 2..
11:24:28 <SamB> w00t, lambdabot is counted!
11:24:37 <dons> ?oeis [0,0,0,1,1,0,0,2,1,1,2,1]
11:24:37 <lambdabot> Sequence not found. Just what do you think you're doing Dave?
11:24:41 <dons> heh
11:24:46 <faxathisia> fiilicdae: You could make a list of what they sum to [1..], and expand each number into the list of pairs it sums to
11:24:46 <dons> ?oeis [0]
11:24:46 <lambdabot> Sequence not found.
11:24:48 <dons> ?oeis 0
11:24:49 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
11:24:49 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
11:24:55 <dons> ?oeis 0,0,0,1,1,0,0,2,1,1,2,1
11:24:55 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
11:24:59 <dons> mm
11:25:00 <mahogny> make a function to generate  (1,0), (0,2), (1,1)   first given the value 2
11:25:05 <olsner> ?oeis 0 0 0 1 1 0 0 2
11:25:05 <lambdabot> Number of inequivalent Eisenstein-Jacobi primes of norm n.
11:25:05 <lambdabot> [0,0,0,1,1,0,0,2,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,2,...
11:25:15 <fiilicdae> hmm
11:25:19 <faxathisia> @let pairs = concatMap pairsSummingTo [0..] where pairsSummingTo n = map (\i -> (i, n-i)) [0..n]
11:25:20 <lambdabot> Defined.
11:25:24 <faxathisia> > pairs
11:25:26 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
11:25:33 <faxathisia> fiilicdae: Does it make sense?
11:25:39 <kaol> > [(x,y) | z <- [1..], x <- [0..z], y <- [0..z], x+y==z]
11:25:40 <lambdabot>  [(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,2),(3,...
11:26:07 <olsner> > [(x,y) | z <- [1..], x <- [0..z], y <- [0..z], x+y==z] !! 10000
11:26:08 <lambdabot>  (131,9)
11:26:13 <olsner> > [(x,y) | z <- [1..], x <- [0..z], y <- [0..z], x+y==z] !! 10000000
11:26:18 <lambdabot> Terminated
11:26:30 <fiilicdae> faxathisia: wow
11:26:46 <fiilicdae> faxathisia: it looks a litlle bit confusing :)
11:26:54 <faxathisia> fiilicdae: Well do you know about map?
11:26:57 <kaol> > pairs !! 10000000
11:27:01 <lambdabot> Terminated
11:27:01 <fiilicdae> faxathisia: but i'll try to deal with it ;)
11:27:24 <fiilicdae> kaol: it must be endless list of pairs (sry fo my eng :)
11:27:46 <olsner> > [(x,y) | z <- [10000000..], x <- [0..z], y <- [0..z], x+y==z]
11:27:51 <lambdabot> Terminated
11:27:58 <faxathisia> > pairs !! 1000000
11:27:59 <lambdabot>  (1009,404)
11:28:02 <faxathisia> > pairs !! 10000000
11:28:05 <lambdabot> Terminated
11:28:08 <faxathisia> damn
11:28:25 <faxathisia> > pairs :: [Expr]
11:28:26 <lambdabot>  Couldn't match expected type `Expr'
11:28:36 <int-e> > let pairs xs = map reverse (inits xs) >>= zip xs in pairs [0..]
11:28:37 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
11:29:35 <faxathisia> ..wow
11:29:44 <faxathisia> I have no idea how that works
11:30:05 <faxathisia> > let pairs xs = map reverse (inits xs) >>= zip xs in pairs [0..10]
11:30:06 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
11:31:23 <int-e>  > let pairs xs = map reverse (inits xs) >>= zip xs in pairs [0..2] -- it doesn't cover all pairs for finite lists.
11:31:32 <int-e> > let pairs xs = map reverse (inits xs) >>= zip xs in pairs [0..2]
11:31:32 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0)]
11:31:52 <fiilicdae> i have some math pattern if it helps: (m1,n1)<(m2,n2) <=> m1 + n1 < m2 +n2 \/ (m1 + n1 = m2 + n2 /\ m1 < m2)
11:33:00 <hpaste>  (anonymous) annotated "card game" with "cardGame 0.1" at http://hpaste.org/5717#a1
11:35:53 <int-e> hmm. where are the tens?
11:36:23 <fiilicdae> int-e: oh thx for help
11:36:32 <fiilicdae> now i see ur solution really works ;)
11:37:07 <fiilicdae> sry if I missed anyone else solution ;)
11:37:42 <fiilicdae> or maybe
11:37:44 <fiilicdae> no..
11:37:48 <fiilicdae> its not it... my bad
11:39:31 <fiilicdae> dunno how to run it
11:40:21 <fiilicdae> Not in scope 'inits'
11:40:43 <fiilicdae> ehh, its to complicated for me
11:41:04 <fiilicdae> thx for help anyway
11:41:08 <wy> oerjan: gosh. It still doesn't work
11:41:08 <hpaste>  int-e annotated "card game" with "shorter getCard" at http://hpaste.org/5717#a2
11:41:08 <lambdabot> wy: You have 1 new message. '/msg lambdabot @messages' to read it.
11:41:30 <int-e> fiilicdae: import Data.List
11:42:05 <wy> oerjan: There must be a way to tell which position to take among the several possible ones. any ideas?
11:44:03 <fiilicdae> int-e: huh, now I see 'parse error (possibly incorrect indentation)'
11:45:18 <int-e> fiilicdae: but if you don't understand the function I'd advise against using it anyway.
11:48:03 <kaol> > concatMap (\n -> [(x,n-x) | x <- [0..n]]) [0..]
11:48:03 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
11:48:15 <kaol> > (concatMap (\n -> [(x,n-x) | x <- [0..n]]) [0..]) !! 10000000
11:48:19 <lambdabot> Terminated
11:48:21 <kaol> > (concatMap (\n -> [(x,n-x) | x <- [0..n]]) [0..]) !! 1000000
11:48:23 <lambdabot>  (1009,404)
11:48:34 <fiilicdae> to be hones - i am a student and it was a task on egzam
11:48:41 <fiilicdae> and i failed
11:48:45 <faxathisia> What's egzam?
11:48:55 <faxathisia> oh, .. nevermind
11:49:03 <fiilicdae> exam - sry
11:49:13 <faxathisia> I thought it was some programming challenge site or something :P
11:49:19 <fiilicdae> nope
11:49:25 <fiilicdae> :D
11:49:34 <dolio> His studying has fried the spelling center of his brain. :)
11:49:38 <fiilicdae> now i want to even know whats the solution
11:49:48 <fiilicdae> so if my prof will ask me for it i could tell...
11:49:50 <fiilicdae> :P
11:50:35 <fiilicdae> / is sorry for bad english :P
11:50:35 <kaol> > [(x,z-x) | z <- [0..], x <- [0..z]]
11:50:36 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
11:52:10 <oerjan> wy: yes, your counting idea from yesterday works
11:52:11 <kaol> > [(x,z-x) | z <- [0..], x <- [0..z]] !! 10000000
11:52:15 <lambdabot> Terminated
11:52:18 <kaol> aw
11:52:33 <oerjan> basically keep track of the number of a's - number of b's so far
11:53:00 <wy> oerjan: I haven't figured out how to do it though
11:53:15 <faxathisia> > filter (>=10000000) $ map sum (inits [1..])
11:53:19 <lambdabot>  [10001628,10006101,10010575,10015050,10019526,10024003,10028481,10032960,100...
11:54:02 <oerjan> i'll give you a hint: let A be the language of strings that start with a, and has majority of a's up until the very end, when they become equal
11:54:09 <int-e> > dropWhile (<10000000) $ scanl (+) 0 [1..]
11:54:10 <lambdabot>  [10001628,10006101,10010575,10015050,10019526,10024003,10028481,10032960,100...
11:54:11 <oerjan> and vice versa for B
11:55:00 <wy> oerjan: thanks
12:02:47 <dons> SamB: want to port darcs-to-git to haskell, so it runs a bit faster..
12:02:53 <dons> maybe double check the algorithms?
12:03:06 <faxathisia> pairs !! 10000000 = (2844,1628)?
12:04:39 <SamB> dons: which XML library supports lazy parsing again?
12:05:03 <dons> haxml? all of them?
12:09:57 <olsner> I think it'd be haxml since it is polyparse-based, iirc
12:10:46 <yowgi> is there a better way to do f called on itself n times?  mkChurch n = \f x -> foldl (.) id (take n $ repeat f) x
12:11:30 <faxathisia> > let _ !! n = ((\(s,k)->(n-k+s-1,k-n-1))$head$filter ((>n).snd) $ zip [1..] (map sum (inits [1..]))) in pairs !! 3
12:11:30 <lambdabot>  (0,2)
12:11:35 <faxathisia> > let _ !! n = ((\(s,k)->(n-k+s-1,k-n-1))$head$filter ((>n).snd) $ zip [1..] (map sum (inits [1..]))) in pairs !! 10000000
12:11:37 <shachaf> yowgi: Using iterate, maybe?
12:11:39 <lambdabot>  (2844,1627)
12:11:45 <faxathisia> *g*
12:12:14 <faxathisia> > let _ !! n = ((\(s,k)->(n-k+s-1,k-n-1))$head$filter ((>n).snd) $ zip [1..] (map sum (inits [1..]))) in map (pairs !!) [1..10]
12:12:15 <lambdabot>  [(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4)]
12:12:23 <yowgi> oh yes, thanks shachaf
12:14:02 <dons> SamB: you might be able to get by with tagsoup
12:14:04 <dons> simpler, smaller
12:17:35 <SamB> dons: that isn't in Debian, though
12:17:48 <dons> it could be.
12:23:07 <ddarius> , the dons packaging siren calls
12:24:15 <SamB> it's not even building for me
12:34:04 <dmwit> :t (<*)
12:34:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
12:34:54 <ddarius> :t (const <*>)
12:34:55 <lambdabot> forall a b. (a -> b) -> a -> a
12:35:08 <ddarius> :t (pure const <*>)
12:35:09 <lambdabot>     Ambiguous occurrence `pure'
12:35:09 <lambdabot>     It could refer to either `Control.Applicative.pure', imported from Control.Applicative
12:35:09 <lambdabot>                           or `Control.Arrow.pure', imported from Control.Arrow
12:35:17 <ddarius> *sigh*
12:35:23 <ddarius> :t ap (return const)
12:35:24 <lambdabot> forall a b (m :: * -> *). (Monad m) => m a -> m (b -> a)
12:35:54 <ddarius> :t liftA2 const
12:35:55 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f a
12:39:03 <czakey> http://www.kimsal.com/reldevsurvey/results.php?action=byReligion&religion=45#langbyrel
12:39:07 <lambdabot> Title: Religious affiliation and software development languages, http://tinyurl.com/255ypl
12:42:39 <osfameron> I don't find those breakdowns all that useful
12:42:49 <osfameron> was there any correlation between religion and programming language?
12:43:09 <yowgi> yes. Pastafarians hate Haskell
12:43:45 <osfameron> that's surprising
12:43:46 <olsner> heh, discordianism => erlang, haskell or ruby
12:44:10 <osfameron> maybe discordianism is a more functional version of pastafarianism
12:45:14 <wli> jedbrown: The paper was more helpful.
12:45:29 <jedbrown> wli: Great.
12:46:17 <Pelias> I'm asking here because I figure that if you specialize in one language, you might be good at the others (also, asking in #math seems *a bit* over the top)
12:46:21 <Pelias> do we say "around 11 o'clock" or "about 11 o'clock" and most imortantly, where I can find answers to questions like this?
12:46:43 <Heffalump> an English teacher
12:47:15 <Riastradh> It depends on which side of the Atlantic you are on or associate with, Pelias.
12:47:19 <radetsky> Who's "we"?
12:47:59 <Heffalump> I try to communicate in grunts, it avoids difficult issues like that.
12:48:00 <Pelias> Riastradh: Let's try US English
12:48:15 <Pelias> Heffalump: If I had one, I would ask him.
12:48:51 <Heffalump> FWIW, I'm a native UK English speaker and I would consider either reasonably idiomatic though I'd probably personally favour the former.
12:49:17 <ddarius> Heffalump: Same here (as a native American English speaker)
12:49:33 <radetsky> I would say "It's about 11 o'clock" but "I'll be there around 11 o'clock"
12:49:52 <Heffalump> I think perhaps the two convey differing levels of approximateness.
12:49:53 <Riastradh> Pelias, on that side of the Atlantic, the former form, with `around', is generally used.
12:49:56 <radetsky> that is, there is a difference in my personal usage and my observations of others' usage
12:50:03 <vininim> rofl
12:50:16 <radetsky> But I'm not sure it's a present/future thing
12:50:22 <Riastradh> Heffalump, which do you see as more approximate?
12:50:35 <Heffalump> I was hoping you wouldn't ask that :-)
12:50:50 <Heffalump> I think around is more approximate.
12:50:56 <SamB> I thought they meant the same thing
12:50:57 <Heffalump> but I think a great deal depends on context
12:51:04 <ddarius> Heffalump: That's what I would say
12:51:10 <radetsky> SamB: you're ruining everything!
12:51:10 <ddarius> Though not definitively
12:51:32 <SamB> though probably what radetsky said applies to me too
12:51:39 <vininim> what kind of religion is "functionalLangu"? heh
12:51:52 <radetsky> vininim: the one true one
12:52:04 <SamB> vininim: also what kind of langauge is thaten++
12:52:11 <ddarius> So we've learned one thing.  Natural languages are context sensitive.
12:52:14 <SamB> er. thetan++?
12:52:33 <radetsky> SamB: by the way, when you mentioned Conjure, it never occured to me that you might have worked on it
12:52:50 <radetsky> are you, or is anyone else to your knowledge, actively developing it?
12:52:50 <SamB> radetsky: quite a while back, yes...
12:52:56 <dmwit> SamB: I'm sure it's a pun on C++.
12:53:01 <SamB> dmwit: well, yes
12:53:20 <SamB> but what kind of scientologist has a sense of humour?
12:53:23 <dmwit> Oh, I didn't read back far enough.
12:53:39 <dmwit> Who says it was a scientologist?
12:54:15 <yowgi> also, 666 people checked Lisp: http://www.kimsal.com/reldevsurvey/results.php?action=byLanguage&language=16#relbylang . Just sayin'.
12:54:15 <lambdabot> Title: Religious affiliation and software development languages, http://tinyurl.com/2te2rh
12:54:15 <SamB> http://www.kimsal.com/reldevsurvey/results.php?action=byReligion&religion=51#langbyrel
12:54:16 <lambdabot> Title: Religious affiliation and software development languages, http://tinyurl.com/37y7ct
12:54:47 <Pelias> thanks everyone. See, I was right, you know your languages:)
12:54:51 <radetsky> SamB: is it dead?
12:55:03 <SamB> radetsky: I don't know!
12:55:08 <SamB> where is it?
12:55:14 <SamB> I haven't seen it lately
12:55:23 <vininim> "New Agey Stuff"
12:56:09 <radetsky> http://darcs.haskell.org/~lemmih/conjure/
12:56:10 <lambdabot> Title: Index of /~lemmih/conjure
12:56:13 <dmwit> SamB: Sure, they *said* they were a Scientologist...
12:56:20 <SamB> dmwit: point
12:57:23 <radetsky> last patch to repo was mid-december '06 though
12:58:08 <wli> jedbrown: The paper basically shows how to transform systems of polynomial equations into generalized eigenproblems.
12:58:12 <SamB> hmm, apparantly I was already tracking that repository...
12:58:39 <SamB> and all 9 of the changes I just pulled were from mid-december 2006
12:59:02 <jedbrown> wli: Yes, to which you can apply standard methods.
12:59:30 <radetsky> SamB: they left it pretty broken
12:59:42 <SamB> it might have bitrotted
12:59:48 <radetsky> or at least broken w/the base split and other changes
12:59:49 <SamB> so, did you send lemmih any patches yet?
13:00:00 <radetsky> I was going to check if he still gave a shit first
13:00:24 <radetsky> also, my patches are probably not very good, as I don't really know how a lot of stuff works
13:01:05 <radetsky> for example, I just guessed that offset should be zero in a bunch of fromForeignPtr calls
13:01:19 <radetsky> it seems to work though
13:01:36 <wli> jedbrown: Sadly I fear that the transformation may be beyond me.
13:03:44 <ilyak> Can I read somewhere about haskell and I18N (possibly, GHC ans I18N)
13:03:56 <ilyak> I can't figure it out, it doesn't seem to respect locale.
13:04:21 <ilyak> It requires source to be utf-8, but char looks like 8-bit on utf-8 locale
13:04:26 <SamB> radetsky: well, if it wasn't passed in before, it essentially must have been 0
13:04:55 <Saizan> ilyak: standard IO functions just read octects and use them as Chars
13:05:12 <radetsky> SamB: good to know
13:05:13 <ilyak> That's bad :(
13:05:28 <ilyak> and what's the internal representation of Char?
13:05:29 <radetsky> I figured it was basically the same as malloc()
13:05:29 <SamB> ilyak: We know!
13:05:35 <Saizan> ilyak: see utf8-string on hackage for basic support of utf8
13:05:43 <Saizan> ilyak: 31bit
13:05:52 <radetsky> a lot of times the pointers were set up with functions named stuff like "mallocBytes" and soforth
13:06:03 <SamB> > '\xFFFFFFFF'
13:06:03 <lambdabot>  Character constant out of range at "'\xFF..." (column 1)
13:06:13 <radetsky> I figured that if malloc() returns x, the buffer starts at x not x+y
13:06:17 <radetsky> so offset should be zero
13:06:17 <SamB> > '\x7FFFFFFF'
13:06:17 <lambdabot>  Character constant out of range at "'\x7F..." (column 1)
13:06:22 <ilyak> And, if my source have "some utf-8 chars", how will they be represented in object code?
13:06:23 <ddarius> @ maxBound :: Char
13:06:24 <Saizan> ilyak: so Char is intended to represent Unicode codepoints
13:06:26 <ddarius> > maxBound :: Char
13:06:29 <lambdabot>  '\1114111'
13:06:45 <SamB> ilyak: where in your sources do they occur?
13:07:00 <ilyak> SamB: Literal strings/chars, let's say
13:07:32 <SamB> well, in the object code, who knows how they'll be stored?
13:08:01 <SamB> I have a guess, but anyway that should work fine...
13:08:05 <Japsu> btw
13:08:11 <Japsu> is it valid to say "ticket sales are now open"
13:08:20 <Japsu> (I'm not a native speaker)
13:08:27 <ilyak> Well, that matters. For example, if I read a char from IO.UTF8 and compare it to char defined in object code
13:08:29 <SamB> why not?
13:08:36 <wli> Eh? Static analysis of Lisp is universal among optimizing Lisp compilers.
13:08:37 <Saizan> ilyak: in literal strings they are converted to codepoints at compile time
13:08:41 <ilyak> Can I ever get true?
13:08:54 <radetsky> Japsu: it's not excellent, but people will know what you mean
13:08:57 <ddarius> Japsu: It's close enough that no one is going to care.
13:09:05 <wli> And whatever Alanna says, I still don't like Java.
13:09:10 <Saizan> ilyak: so length "é" == 1, not 2
13:09:17 <ilyak> Saizan: So, it's possible. Okay. Going to dump that for now and return later :)
13:09:21 <ddarius> wli: Wrong channel.
13:09:23 <SamB> UTF-8 character/string literals in source code are handled by GHC
13:09:23 <Japsu> thanks. what would be the correct way then?
13:09:36 <radetsky> SamB: was that (who knows how it'll work in obj code?) directed at me w/r/t malloc()?
13:09:36 <wli> Sorry all.
13:09:47 <SamB> radetsky: eh?
13:09:59 <SamB> I was talking about UTF-8 characters in object code
13:10:05 <radetsky> oh, ok
13:10:07 <radetsky> nm
13:10:16 <ilyak> SamB: Will string defined in GHC be same to string read from console? Assuming they consist of same utf-8 chars?
13:10:47 <SamB> ilyak: well, if you use that IO.UTF8 thing, I guess so...
13:10:52 <ilyak> :)
13:13:53 <radetsky> how do you import a module and just see the datatypes in it, not any of the functions?
13:14:04 <radetsky> I keep getting a nothing used from module warning
13:14:44 <nominolo> > (1+) `fmap` Right 42
13:14:45 <lambdabot>  Right 43
13:14:53 <nominolo> > (1+) `fmap` Left 23
13:14:54 <lambdabot>  Left 23
13:15:53 <radetsky> I try doing "import Data.ByteString()" as ghc suggests, but then I get a not-in-scope error
13:16:10 <vininim> > liftM (+1) (Right 42)
13:16:11 <lambdabot>  Add a type signature
13:16:21 <dmwit> radetsky: Put whatever isn't in scope into the ().
13:16:35 <Heffalump> GHC seems a bit buggy in that regard.
13:16:50 <radetsky> dmwit: that's what I had before, and I get "nothing from ByteString used"
13:17:09 <radetsky> Heffalump: so you think I am doing it right, but ghc isn't?
13:17:09 <vininim> @hoogle Either
13:17:10 <lambdabot> Data.Either :: module
13:17:10 <lambdabot> Prelude.Either :: data Either a b
13:17:10 <lambdabot> Data.Either.Either :: data Either a b
13:17:58 <Heffalump> radetsky: I didn't quite understand what your problem was, but I've certainly encountered situations where GHC claimed something I was importing wasn't being used, but when I removed it from the imports it needed it.
13:18:37 <larmeh> what exactly does the ">>=" operator do?
13:18:58 <radetsky> put it this way: is "import Data.ByteString (ByteString)" the way to import just the type constructor?
13:19:02 <Cin> takes the result of one action and gives it to another
13:19:08 <dmwit> larmeh: It sequences together monadic actions.
13:19:38 <dmwit> larmeh: One way you can think of it is that it takes a function which is only "half in a monad" and lifts it to be completely in the monad.
13:19:49 <radetsky> larmeh: what exactly it does depends on what sort of monad you're using
13:20:02 <radetsky> if you're using the IO monad, it's like a shell pipeline
13:20:53 <dmwit> :t \f -> (>>= f) -- more precise than my English
13:20:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
13:21:27 <larmeh> hm okay thanks... i've got a feeling i'll need a while to digest this
13:21:43 <masklinn> @type (>>=)
13:21:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:21:56 <dmwit> :t (=<<)
13:21:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:21:58 <masklinn> oh so lambdabot recognizes :t too?
13:22:53 <radetsky> @@
13:23:04 <radetsky> @(@)
13:23:16 <radetsky> @type @
13:23:17 <lambdabot> parse error on input `@'
13:23:22 <radetsky> @type (@)
13:23:23 <lambdabot> parse error on input `@'
13:23:30 <radetsky> fuck you, lambdabot
13:23:54 <Japsu> @botsmack
13:23:54 <lambdabot> :)
13:23:56 <dmwit> radetsky: What are you trying to do?
13:23:58 <Heffalump> why would you expect @ to be a valid operator?
13:24:29 <FunctorSalad_> Heffalump: I thought there was some piping operator
13:24:30 <radetsky> I thought it was
13:24:44 <Heffalump> given that it's syntax, it seems unlikely.
13:24:48 <dmwit> @ is used in pattern matching.
13:24:50 <radetsky> dmwit: figure out what "@" does
13:24:58 <dmwit> list@(x:xs)
13:25:06 <dmwit> radetsky: It makes an alias for a pattern.
13:25:41 <faxathisia> @@ @babel en de @vixen hey there
13:25:44 <lambdabot>   hallo
13:26:12 <FunctorSalad_> :)
13:26:20 <faxathisia> @@ @babel en de @vixen What's up
13:26:20 <lambdabot>   Werden Sie bei den trolls angenommen?
13:26:31 <FunctorSalad_> haha
13:27:37 <radetsky> > list@(x:xs)
13:27:37 <lambdabot>  Parse error in expression at end of input
13:27:57 <faxathisia> foo list@(x:xs) = ...
13:28:03 <dmwit> > let f (list@(x:xs)) = (list, x) in f "hey"
13:28:04 <lambdabot>  ("hey",'h')
13:28:41 <radetsky> ok, I think I get it
13:28:56 <faxathisia> :t (\__@(_)->__)
13:28:57 <lambdabot> forall t. t -> t
13:29:32 <Feuerbach> what does double underscore mean?
13:29:32 <dmwit> The person who makes the best-looking lambda-smiley wins a prize.
13:29:45 <dmwit> Feuerbach: It's just a name, like "a" or "foo".
13:29:52 <Feuerbach> dmwit: ah, ok
13:30:20 <faxathisia> > (\ ~__@(_:_:_)->__ ) "Identity on lists"
13:30:20 <lambdabot>  "Identity on lists"
13:31:01 <dmwit> Lazy pattern match means it works on short lists, too?
13:31:14 <dmwit> > (\ ~__@(_:_:_)->__ ) []
13:31:15 <faxathisia> Yes
13:31:17 <lambdabot>   Irrefutable pattern failed for pattern (__@(_ : _ : _))
13:31:31 <dmwit> Sorry, but no. =P
13:31:40 <faxathisia> How can you refuse an irrefutable pattern!
13:32:04 <FunctorSalad_> why is this called "irrefutable", btw?
13:32:05 <int-e> > (\ __@ ~(_:_:_) -> __) []
13:32:06 <lambdabot>  []
13:32:21 <SamB> FunctorSalad_: because it always matches
13:32:37 <faxathisia> ahh
13:32:46 <faxathisia> > (\ ~__@ ~(_:():_)->__ )[]
13:32:47 <lambdabot>  []
13:32:52 <FunctorSalad_> > (\x@(Left y) -> y) Right 9
13:32:57 <lambdabot>  Couldn't match expected type `Either (t1 -> t2) t'
13:33:49 <dmwit> FunctorSalad_: The ~ is what introduces an irrefutable match, not the @.
13:34:08 <dmwit> > (\x@~(Left y) -> y) (Right 9)
13:34:09 <lambdabot>  Parse error at "@~(Le..." (column 4)
13:34:18 <dmwit> > (\x@ ~(Left y) -> y) (Right 9)
13:34:19 <radetsky> SamB: what sort of style/indenting did you guys use on Conjure? haskell-mode out of the box doesn't work right
13:34:20 <lambdabot>   Irrefutable pattern failed for pattern (Data.Either.Left y)
13:34:30 <FunctorSalad_> dmwit: I just remembered getting that "irrefutable" in a different pattern matching context, without "@"s or "~"s
13:34:49 <Saizan> FunctorSalad_: when using let or where
13:34:53 <FunctorSalad_> > let f (Left y) = y in f (Right 8)
13:34:55 <lambdabot>   Non-exhaustive patterns in function f
13:35:08 <FunctorSalad_> hmm, odd. thought it said "irrefutable"
13:35:09 <Saizan> > let Left y = Right 4 in y
13:35:10 <lambdabot>   Irrefutable pattern failed for pattern Data.Either.Left y
13:35:11 <dmwit> > let f ~[] = "hey" in f []
13:35:12 <lambdabot>  "hey"
13:35:15 <dmwit> > let f ~[] = "hey" in f "hi"
13:35:15 <lambdabot>  "hey"
13:35:21 <SamB> radetsky: haskell-mode has never been the brightest at figuring out how to indent stuff
13:35:40 <dmwit> FunctorSalad_: You can also think of it as a "lazy pattern match"... kind of.
13:36:21 <radetsky> how do you make it not suck?
13:36:23 <radetsky> or can you?
13:36:25 <wli> I mostly use irrefutable patterns to suppress incomplete pattern matching warnings when writing functions that operate on infinite lists.
13:37:14 <FunctorSalad_> > let f [] = "hey" in f "hi"
13:37:15 <lambdabot>   Non-exhaustive patterns in function f
13:37:26 <FunctorSalad_> dmwit: thanks, think I see the difference now
13:43:19 <Winterstream> Please put me out of my misery. Why doesn't     hGetContents >>= putStr    work? hGetContents produces an IO String and putStr takes a single String as its arg
13:44:08 <wli> You forgot to pass the handle to hGetContents
13:44:33 <wli> \h -> hGetContents h >>= putStr
13:45:08 <radetsky> anybody? can haskell indenting be made to not suck?
13:45:13 <radetsky> in emacs? in anything?
13:45:14 <dmwit> no
13:45:32 <radetsky> can it be made to suck slightly less?
13:45:36 <vininim> nothing wrong with haskell indenting here
13:45:38 <SamB> I don't know
13:45:42 <dmwit> ?faq Can Haskell break all possible indenting algorithms?
13:45:42 <lambdabot> The answer is: Yes! Haskell can do that.
13:45:42 <dons> radetsky: use the emacs or vim indenting modes?
13:45:43 <Winterstream> Heh. Thanks wli.
13:45:45 <Winterstream> That was it
13:45:54 <dons> be sure to set tabs to 8 spaces
13:45:54 <radetsky> dons: I'm using haskell-mode
13:46:06 <radetsky> everyone uses 4
13:46:16 <vininim> haskell-mode works fine for me
13:46:17 <wli> (>>= putStr) . hGetContents may also serve your purposes.
13:46:21 <dmwit> radetsky: In vim, I just :set autoindent and leave it at that.
13:46:22 <radetsky> vininim: I hate you
13:46:35 <Winterstream> Due to Cale's newsgroup response, I used his advice and just wrote a non-crashing cat. And I'm a total newbie.
13:46:35 <vininim> specially as submode to literate-haskell =)
13:46:44 <Winterstream> Man
13:46:46 <Winterstream> Haskell rocks.
13:47:19 <TomMD> Haskell++
13:47:23 <Saizan> radetsky: what do you dislike about it?
13:47:37 <vininim> I just need to figure out now how to apply different color themes to different submodes (doesn't seem possible according the emacsxperts :/ )
13:47:41 <radetsky> it indents everything wrong
13:48:06 <radetsky> have any of you haskell-mode users done any personal configuration of it?
13:48:49 <dons> Cale: your outgoing messages setting X-No-Archive ?
13:49:43 <radetsky> also, is there any way to make it highlight .hsc?
13:49:43 <Saizan> radetsky: you know that tab cycles throgh possible intentations?
13:50:11 <radetsky> Saizan: yes, but it always concludes that the current (ugly) indentation is the only possible one
13:50:52 <vininim> (add-to-list 'auto-mode-alist '("\\.hsc\\'" . haskell-mode)
13:51:05 <vininim> or haskell-c-mode
13:52:12 <Stinger_> hmm thats no good, my haskell-mode isnt working well at all
13:52:44 <wy> @tell oerjan It's still hard to do that. I wonder if this is the correct way to think.
13:52:44 <lambdabot> Consider it noted.
13:54:58 <wy> radetsky: No language should use indentation as indicator for blocking. I hate the syntax of both Haskell and Python although they are nice in semantics
13:55:38 <dejones> wy: why shouldn't a language use indentation for blocking...?
13:55:40 <radetsky> wy: ONE WORD amirite?
13:56:19 <dons> heh.
13:56:44 <dons> humans naturally use whitespace for scope. { } is just an artifact of poor parsing technology
13:57:24 <olsner> I like to use whitespace to speak to humans and {} to speak to the compiler
13:57:34 <SamB> olsner: why?
13:58:01 <radix> whatever. we need to evolve to non-textual syntaxes
13:58:10 <ilyak> How would I import a module to ghci to be able to use its functions?
13:58:16 <ilyak> I want List, for example
13:58:20 <jedbrown> dons: Cale's other response (about threads) made the google groups archive.  I don't know why the other one didn't.
13:58:22 <Saizan> ilyak: :m + Data.List
13:58:35 <vininim> import Data.List
13:58:45 <vininim> (in recente versions)
13:59:35 <wy> dons: but the problem is that automatic indentation is impossible for those languages
13:59:40 <FunctorSalad_> radix: non-textual?
13:59:57 <ilyak> Saizan: thx!
14:00:01 <int-e> wy: on the other hand, incorrectly idented code won't work in the first place
14:00:10 <int-e> indented even
14:00:21 <dejones> radix: non-textual, that'd be impressive.  ;)
14:00:41 <radix> you know, like subtext
14:00:45 <wli> Okay, I've got an interesting one.
14:00:46 <int-e> sure, it's debatable whether that's a disadvantage or an advantage. I think it's a matter of taste.
14:02:01 <wli> Let's say you've got the funny n-vector and n by n matrix stuff enforcing matching list lengths or array sizes somehow, say, via Oleg's type arithmetic.
14:02:36 <hpaste>  (anonymous) annotated "Simple Scraping Lib" with "(no title)" at http://hpaste.org/5723#a1
14:04:40 <wli> It seems like you have something vaguely like the monadic join going on, where, say, matrixJoin :: (TypeNumeral n, TypeNumeral m) => Matrix n (Matrix m t) -> Matrix (typeMultiply m n) t IOW block matrix stuff.
14:04:56 <sclv> anyone have any experience setting up fastcgi with lighttpd?
14:10:52 * wli hits the showers and leaves it to others to explain tops vs. bottoms vs. versatiles.
14:13:03 <ac> radix: why do we need non-textual syntax?
14:33:42 <Japsu> @dice d44
14:33:42 <lambdabot> unexpected "d": expecting number
14:33:44 <Japsu> bah
14:33:47 <Japsu> @dice 1d44
14:33:47 <lambdabot> 1d44 => 6
14:34:26 <dons> Cale: interesting that the original poster has not responded at all to the email
14:34:40 <dons> isn't that trollish behaviour? or insincere?
14:37:35 <dolio> Perhaps it's sinister.
14:37:41 <Beelsebob> @dice 10d10
14:37:42 <lambdabot> 10d10 => 62
14:37:57 <Beelsebob> bah, wanted that to tell me the values on each d10
14:38:15 <dolio> 1000000d1000000
14:38:19 <dolio> @dice 1000000d1000000
14:38:19 <lambdabot> 1000000d1000000 => 500441101508
14:38:23 <dons> dolio: heh
14:39:57 * oerjan thinks the 10d10 => should be in {- -} comments, so it could be easier used with @@
14:39:58 <lambdabot> oerjan: You have 1 new message. '/msg lambdabot @messages' to read it.
14:43:02 <Japsu> :t replicateM
14:43:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
14:43:25 <Japsu> > replicateM 10 $ randomRIO (1,10)
14:43:26 <lambdabot>   Not in scope: `randomRIO'
14:43:33 <Japsu> bah
14:43:40 <Japsu> :t getStdGen
14:43:40 <lambdabot> IO StdGen
14:43:46 <Japsu> bah
14:44:05 <Japsu> is it even possible to get random numbers with lambdabot's >?
14:44:33 <idnar> you could construct your own RandomGen
14:44:36 <dolio> You have to make a StdGen with a seed.
14:45:04 <idnar> > mkStdGen 5
14:45:05 <lambdabot>   Not in scope: `mkStdGen'
14:45:08 <idnar> > Random.mkStdGen 5
14:45:09 <lambdabot>   Not in scope: `Random.mkStdGen'
14:45:14 <oerjan> Japsu: no that's why i thought the {- -} for @dice would be useful
14:45:34 <Japsu> hmm
14:45:36 <Japsu> what's @@
14:45:36 <idnar> @hoogle mkStdGen
14:45:37 <lambdabot> System.Random.mkStdGen :: Int -> StdGen
14:45:43 <idnar> > System.Random.mkStdGen 5
14:45:44 <lambdabot>   Not in scope: `System.Random.mkStdGen'
14:45:51 <idnar> :(
14:46:02 <oerjan> another possibility would be to have a variant of @run that wrapped it in print . ... =<< getStdGen
14:46:19 <idnar> :t mkStdGen
14:46:19 <lambdabot> Int -> StdGen
14:46:21 <oerjan> @help @
14:46:22 <lambdabot>  @ [args].
14:46:22 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
14:46:22 <lambdabot>  The commands are right associative.
14:46:22 <lambdabot>  For example:    @ @pl @undo code
14:46:22 <lambdabot>  is the same as: @ (@pl (@undo code))
14:46:27 <idnar> why doesn't > have it?
14:46:41 <oerjan> Japsu: allows you to feed the result of one plugin into another
14:46:46 <Japsu> hmm
14:46:50 <oerjan> idnar: no IO actions allowed
14:46:52 <Japsu> what's the difference with @.?
14:46:52 <goalieca> is there a special name for a  fold.zip
14:47:08 <goalieca> c++ calls it std::inner_product
14:47:28 <Japsu> @index dot
14:47:28 <lambdabot> Text.ParserCombinators.Parsec.Token
14:47:32 <Japsu> no, not that
14:47:56 <oerjan> Japsu: @. doesn't allow any extra arguments on the first command
14:48:00 <Japsu> okay
14:49:04 <oerjan> idnar: oh wait
14:49:13 <oerjan> mkStdGen _used_ to be available
14:49:18 <oerjan> > mkStdGen 42
14:49:20 <lambdabot>   Not in scope: `mkStdGen'
14:49:36 <idnar> it's not an IO action, and IO is "allowed" anyway
14:49:49 <oerjan> this is disturbing
14:49:51 <RayNbow> http://journal.batard.info/post/2008/02/17/ski-calculus-in-a-haskell-shell , http://reddit.com/r/programming/info/692gq/comments/
14:49:53 <lambdabot> Title: SKI calculus in a Haskell shell - yogiblog, http://tinyurl.com/3axsoq
14:50:05 <oerjan> idnar: misread you, i though you meant randomRIO etc.
14:50:20 <yowgi> RayNbow, I wrote that :)
14:50:25 <idnar> oerjan: ah
14:50:26 <yowgi> thanks to everyone who helped
14:50:27 <RayNbow> yowgi: ah :)
14:50:28 <oerjan> @version
14:50:29 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
14:50:29 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:50:57 <RayNbow> yowgi, that make Church numeral function is amazingly simple... ^_^
14:52:13 <oerjan> @seen Cale
14:52:13 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 20h 7m 44s ago.
14:53:16 <oerjan> @ask Cale Do you know why mkStdGen isn't in > anymore?
14:53:17 <lambdabot> Consider it noted.
14:54:24 <oerjan> > random
14:54:25 <lambdabot>   Not in scope: `random'
14:54:33 <oerjan> ouch
14:54:40 <oerjan> @hoogle random
14:54:40 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
14:54:41 <lambdabot> System.Random :: module
14:54:41 <lambdabot> System.Random.Random :: class Random a
14:54:46 <ddarius> \l c n -> foldr c n l :: [a] -> ChurchEncode [a]
14:54:49 <oerjan> the whole module seems gone
14:54:58 <RayNbow> hmm, dons' comment @ http://reddit.com/r/programming/info/691v1/comments/ being downmodded... gotta counter it by upmodding it :)
14:57:26 <gwern> ...did Hackage suddenly turn warnings into fatal errors?
14:57:27 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
14:57:37 <dons> gwern: yep
14:57:49 <dons> or at least prints more warnings
14:58:08 <gwern> dunno. I got a 400 error just from not having a Build-Type:...
14:59:08 <gwern> @tell Philippa well, you're the only person listed on the website, and you maintained thrugh serveral versions... cheer up, though, I doubt anyone will bother you to maintain something which only claims to work with GHC 6.4...
14:59:09 <lambdabot> Consider it noted.
14:59:10 <Baughn> @hoogle par
14:59:10 <lambdabot> GHC.Conc.par :: a -> b -> b
14:59:10 <lambdabot> Control.Parallel.par :: a -> b -> b
14:59:10 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
15:03:05 <Philippa> gwern: more that I hacked on it largely on my own as far as the releases on my site go, but hey
15:03:17 <Philippa> do be careful about that with other people's projects though
15:05:12 <SamB> dons: so, um, jhc finished converting...
15:06:01 <dons> SamB: cool. not finished here.
15:06:09 <dons> up to 2006
15:06:23 <dons> can you git clone the repo then?
15:10:00 <larmeh> can someone give me a general definition of a "algebraic type"?
15:10:20 <dons> good question!
15:10:27 <Philippa> how general do you want? :-)
15:10:49 <dons> "a datatype each of whose values is data from other datatypes wrapped in one of the constructors of the datatype. Any wrapped data is an argument to the constructor. In contrast to other datatypes, the constructor is not executed and the only way to operate on the data is to unwrap the constructor using pattern matching."
15:11:00 <u_quar1> building  zlib-0.4.0.2 with ghc 6.8.2 i get a bunch of compile errors in Stream.hsc ... y is that ? (btw i am trying to build lambdabot dons)
15:11:02 <dons> wikipedia is a bit awkward on the subject
15:11:10 <dons> u_quar1: missing the zlib.h headers?
15:11:14 <Philippa> it's a type corresponding to an initial algebra - so you get the whole sum-of-products structure etc etc
15:11:57 <u_quark> from the C lib...? i c...
15:12:15 <dons> u_quark: yep
15:12:26 <dons> Philippa: btw, have you played with the -fgenerics ?
15:12:48 <dons> very cool decomposition of any (non-recursive?) ADT to units, sums and products
15:12:49 <Philippa> dons: I haven't specifically, no. I get the concept, but haven't used it
15:12:57 <FunctorSalad_> this one here explains the background a bit http://www.alpheccar.org/en/posts/show/77
15:12:58 <lambdabot> Title: Category Theory and Haskell 3 : Algebras and Monads
15:13:00 <dons> like syb at compiler time
15:13:17 <dons> ADTs are one of the key mechanisms haskell uses to encode rich data about a problem domain
15:13:26 <dons> i was struck by how poorly supported "data" is in languages without ADTs
15:13:39 <dons> when looking at some python code to manipulate playing cards
15:14:16 <dons> structures aren't really first class unless you can pattern match on them, and have sum types of abitrary complexity
15:16:39 <u_quark> worked tnx dons
15:17:14 <dons> great
15:18:13 <dcoutts_> we should get cabal to check that all required .h and libs can be found at configure time
15:18:42 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/177
15:18:44 <lambdabot> Title: #177 (Check Include-dirs, extra-lib-dirs etc exist at configure time.) - Hackage ...
15:20:43 <dcoutts_> dons: I note that popenhs-1.0.0 has been uploaded to hackage 4 times now, that does not seem right
15:21:26 <dcoutts_> 3 times was on one day within 30 min of each other which is one thing, but it was uploaded again 2 days later
15:21:49 <ac> dons: what original poster?
15:22:41 <Zao> Shouldn't one bump the version numbers of such public releases?
15:22:59 <dcoutts_> Zao: exactly, we're going to make hackage enforce that I think
15:23:16 <dcoutts_> dons: if you're delegating release management you may just want to double check that everything is ok
15:23:56 <dcoutts_> Zao: or at least restrict it, perhaps changes within 1 hour are ok
15:24:07 <dcoutts_> to fix silly mistakes etc
15:24:37 <_frederik_> how do i tell ghc/ghci *not* to search for source files in the current directory?
15:24:42 <Zao> "oh, you mean the _other_ 1.0.0" is badness.
15:24:44 <dons> dcoutts_: hmm...
15:24:50 <dons> dcoutts_: i didn't authorise anything
15:24:58 <dcoutts_> _frederik_: -i resets the search path
15:25:04 <dons> but i'm not the author of popenhs, afaik
15:25:13 <dcoutts_> dons: oh, sorry, my mistake
15:25:40 <dons> tell gwern to get maintainers ok before uploading.
15:26:10 <dcoutts_> dons: I assumed it was your new popen code
15:26:25 <dons> ah no. that's process-light, which isn't released yet
15:26:25 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/popenhs-1.0.0
15:26:25 <lambdabot> http://tinyurl.com/ys94gy
15:26:25 <Philippa> dons: both to upload at all and to be listed as maintainer rather than "last person seen hacking on"
15:27:09 <Philippa> especially as I wouldn't be surprised to be told you've done stuff with Flippi more recently than I have (though I'm not actively expecting it)
15:27:15 <dons> well, gwern's just uploading everything, and not necessarily letting authors know, or maintainers.
15:27:15 <_frederik_> dcoutts_: thanks
15:27:15 <Philippa> yeah, he checked with me at least
15:27:15 <dons> i didn't know frag or lambdabot were going to get released. which isn't very good
15:27:15 <Philippa> but I suspect partly because he couldn't get Flippi to build
15:28:31 <Philippa> it's a tad bit-rotted
15:28:36 <dcoutts_> @seen gwern
15:28:36 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 28m 17s ago.
15:28:36 <ddarius> lambdabot's released?
15:28:40 <dons> 4.1 got stuck on hackage.
15:28:40 <dcoutts_> it's a bit annoying since it relies on the plugins package and that package does not build
15:28:47 <wli> That paper jedbrown pointed me to rocks my world. Now if only I could smoke out how to form the matrices and extract results from the eigenproblem.
15:28:49 <dons> i'm not sure the appropriate quality controls are in place
15:29:17 <dcoutts_> dons: how do you mean? within the lambdabot release process or on hackage uploads generally
15:29:18 <ddarius> dons: It's not too bad for lambdabot as there isn't too much of a reason for someone to want to build and run another lambdabot.
15:29:48 <dcoutts_> dons: we had a big discussion on that at the end of last week, about who should be allowed to upload packages, sparked by these concerns
15:30:21 <dons> the hackage uploads. too many broken packages getting uploaded
15:32:32 <dcoutts_> dons: build reporting to the rescue!
15:32:36 <crutcher> dons: why don't you just let everyone upload, and tag good packages with the versions they compile for.
15:34:22 <crutcher> I mean, I read your post and all I see is : ... to many ... packages getting uploaded
15:34:22 <crutcher> which doesn't seem possible
15:34:24 <crutcher> a broken package is still interesting, and contributes to the comunitiy, right?
15:34:24 <dons> crutcher: oh its more that people are uploading other peoples packages
15:34:26 <crutcher> oh.
15:34:26 <dcoutts_> dons: but that's easy to stop, since we have control over accounts
15:34:30 <dcoutts_> dons: we just check that the uploader is indeed checking and if not ask politely and if it's problematic we remove the account.
15:34:32 <dons> we want to have these things available, but live projects have real maintainers that can do the quality assurance
15:34:33 <crutcher> well, you could model on either the perl or python community package systems, which seem to handle very large numbers of packages gracefully.
15:34:45 <dons> crutcher: yeah, we're heading that way
15:34:54 <dons> i.e. filter on quality metrics
15:35:07 <dons> but the other part is ensuring that people upload what they should.
15:35:20 <dons> i could go upload broken packages all over and screw things up royally, currently
15:35:39 <crutcher> well, that seems like a simple ACL problem, right?
15:35:46 <dons> yep
15:36:04 <dons> and a social issue -- just teaching people they need to talk to the actual maintainers
15:37:10 <crutcher> I would suggest that you let people upload _proposed_ changes to a package, and let others see those proposed changes as some sort of derived package.
15:37:25 <crutcher> then they wouldn't _need_ to talk to the maintainers.
15:37:33 <dons> dcoutts_: btw, if you want to see what darcs is competing against,  git clone http://www.cse.unsw.edu.au/~dons/git/cabal.git
15:37:35 <lambdabot> Title: Index of /~dons/git/cabal.git
15:37:45 <crutcher> maintainers could look at propsed changes, and others could play with them
15:37:57 <dons> crutcher: the other part is checking the package is ok before committing to it.
15:38:06 <dons> but yeah, we could reach a point where staging is required
15:38:26 <dons> upload to a staging list. run a bunch of tests. then approve those that pass
15:38:28 <crutcher> I'm not talking about staging
15:38:37 <SamB> no, he isn't
15:38:46 <dcoutts_> dons: I'd like to see automatic staging on hackage, that we define a hackage subset by passing some qa tests via build reports
15:38:47 <SamB> "the maintainer likes it" isn't that kind of test
15:38:49 <crutcher> I don't think you should build any system on the idea that "people should get better"
15:38:54 <dons> dcoutts_: yep
15:39:04 <SamB> crutcher: true enough
15:39:14 <SamB> what if some malicious entity came along?
15:39:15 <crutcher> stagging is cool, but I'm proposing something different, which could be complementary.
15:40:17 <dcoutts_> dons: I'm not sure what I'm looking at there cabal.git. I don't have git installed.
15:40:20 <crutcher> and uploaded 'super l33t derivative version #4'?
15:40:28 <crutcher> well, you let people comment on/flag derivative versions, and you permit the tools to filter on these flags.
15:40:29 <dcoutts_> crutcher: it'd be useful to be able to suggest simple build patches
15:40:34 <crutcher> or code fixes, or additional functionality.
15:40:45 <crutcher> think of it as letting anyone create a branch of a package.
15:40:53 <crutcher> the branch is clearly marked as such
15:41:07 <crutcher> some people might start using it, playing with the new tihngs it does.
15:41:22 <crutcher> if it is popular and / or useful, the maintainer might integrate parts o it.
15:41:56 <crutcher> but you frequently have the problem that propsed changes are not seen as interesting by a particular maintainer.
15:42:07 <crutcher> the only way to really find out is to see if people will use them
15:42:18 <crutcher> which is the value of forks.
15:42:28 <crutcher> see the linux kernel development model
15:42:45 <crutcher> </rant>
15:43:43 <SamB> crutcher: so what you are saying is we should allow people to upload darcs patch bundles (or what-have-you) as annotations to packages listed on hackage?
15:45:01 <crutcher> At a minimum.
15:46:05 <crutcher> you could go so far as to allow people to also create a fork package on hackage, where they can continue to develop their alternative imp.
15:46:51 <dejones> haskell equivalent of eval() for evaluating a string as code?
15:46:51 <crutcher> software collaboration is so unbelievably expensive that you should never build tools which aim to slow it down
15:47:00 <SamB> dons: you can go ahead and clone http://naesten.dyndns.org:8080/repos/jhc.git if you haven't finished that conversion...
15:47:00 <crutcher> many <negative adjective> forks are _still_ many forks
15:47:02 <kmcallister> dejones, see http://www.cse.unsw.edu.au/~dons/hs-plugins/
15:47:02 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
15:47:06 <dejones> kmcallister: thank you
15:48:25 <dons> SamB: ok. cool.
15:48:34 <dons> crutcher: i'm not sure forks are the issue though.
15:48:46 <dons> its just people doing releases without talking to the project author
15:49:13 <dons> SamB: are you going to send that to ohloh?
15:49:23 <SamB> dons: ohloh doesn't seem to like colons
15:49:28 <crutcher> and if you lock down the acls on the release process (which you should do) you will reduce the frequency with which people do that.
15:49:44 <crutcher> but you will also loose that effort
15:50:02 <crutcher> it would be nice to keep both the effort and the stability of the release process
15:50:22 <crutcher> so let people do un-official releases, and make them visible in the repo
15:50:39 <crutcher> people who want stability will only use teh official ones
15:51:42 <dejones> kmcallister: if I have a string that is a function name, is using the hs-plugins the best way to be able to use that string to do the function call?
15:52:11 <kmcallister> dejones, probably not
15:52:32 <kmcallister> often problems that are solved with eval() in other language are solved much more cleanly with higher-order functions in haskell
15:52:43 <kmcallister> e.g. you can make a list of (String, f) pairs, where f is your function type
15:52:50 <kmcallister> (or use a Data.Map for efficient lookup)
15:52:51 <SamB> dejones: where does the string come from?
15:53:24 <dejones> SamB: a url
15:53:32 <SamB> ???
15:53:45 <dejones> SamB: splitting up a url and part of the url is the module and function in the module
15:53:47 <SamB> ... you failed security 101, didn't you?
15:54:06 <kmcallister> SamB, if you restrict the type to be pure it should be fine :)
15:54:20 <kmcallister> (assuming the hs-plugins environment doesn't have unsafePerformIO or other such loopholes)
15:54:37 <LoganCapaldo> > unsafePerformIO
15:54:39 <lambdabot>   Not in scope: `unsafePerformIO'
15:54:45 <dejones> SamB: well, I guess it would be better to pattern match the url to the available functions in the module?
15:54:54 <SamB> LoganCapaldo: you know that doesn't really use eval
15:54:56 <dejones> SamB: what do you suggest?
15:55:06 <LoganCapaldo> I know nothing :)
15:55:11 <kmcallister> dejones, if you want to get fancy you can use Template Haskell to introspect on the function names at compile time, so you don't have to maintain an explicit list
15:55:14 <SamB> dejones: well, what are you trying to make?
15:55:20 * LoganCapaldo is feeling very zen
15:55:20 <hasenov> hello, i dont know who showed me a shorther version of getCard in hpaste.org/5717 but thanx
15:55:51 <hasenov> i knew there was a shorter way to do that
15:55:51 <SamB> hasenov: it seems to have been int-e
15:55:58 <hasenov> oh
15:56:00 <dejones> SamB: Just an webApp server that takes http requests (urls mostly) and executes a particular module and function in that module based upon the url.
15:56:15 <kmcallister> dejones, are you writing the modules?
15:56:21 <dejones> kmcallister: yes
15:56:31 <monochrom> When you realize you know nothing, you can get an MSc.
15:56:32 <SamB> hasenov: see up their next to "shorter getCard"?
15:56:34 <hasenov> i actually had a different question when i posted it though
15:57:11 <hasenov> in pickCard, i am doing exactly what i wanted to do, but i would like to generalize it using monads
15:57:14 <kmcallister> dejones, then i would keep an explicit association from strings to functions, or build it automatically with TH
15:57:28 <kmcallister> eval sounds like overkill and a good way to introduce security holes
15:57:32 <hasenov> i know thats exactly what its meant for but am not sure exactly how to organize my code
15:57:48 <kmcallister> (it will also be much slower)
15:57:53 <dejones> kmcallister: yea, I immediately thought that eval was overkill
15:59:14 <dejones> kmcallister: thanks, I'll look into Template Haskell
15:59:25 <FunctorSalad_> is there a quick and easy way for building the haddock of something you "cabal install"-ed?
15:59:32 <dejones> kmcallister: does haskell not have any introspection into modules to learn what functions are available?
15:59:38 <kmcallister> dejones, TH does that
15:59:41 <dejones> I'm new to Haskell.  ;)
15:59:43 <FunctorSalad_> "cabal haddock" seems to require the program in the current directory
15:59:43 <kmcallister> (it's an extension to haskell, supported by GHC)
15:59:47 <dejones> kmcallister: thanks
15:59:49 <kmcallister> yup
15:59:50 <dejones> :)
16:00:06 <Dybber> I'm reading the documentation for the Identity monad http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html Isn't the line "Identity x >>= f == Identity (f x)" wrong. Shouldn't it just be "Identity x >>= f == f x" ?
16:00:06 <lambdabot> http://tinyurl.com/ydy84p
16:00:16 <kmcallister> you can get the types too, which could be useful if you want to give args in the URL
16:02:09 <dons> SamB: what's the jhc git repo url?
16:02:10 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:02:16 <Dybber> Identity x >>= f implies that f :: a -> Identity b so The right side would give us something like Identity (Identity b)
16:02:53 <LoganCapaldo> Dybber: yeah methinks you are correct
16:03:45 <Dybber> Should I just send an email to the libraries@haskell.org or can anyone here change it?
16:07:45 <SamB> dons: http://naesten.dyndns.org:8080/repos/jhc.git/
16:08:07 <SamB> only take out the last slash
16:09:53 <dons> but it won't upload or something/
16:10:17 <wy> uhh.. damned parsing tables...
16:10:17 <lambdabot> wy: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:10:24 <SamB> ohloh claims it to be an invalid git URL or something
16:10:59 <SamB> http://www.ohloh.net/forums/10/topics/1308#posts-4406
16:11:55 <wy> There should be a nicer way to think about them
16:12:19 <wy> oerjan: Got it. So I guess I would introduce something like "matched" a and b's
16:16:33 <u_quark> building plugins-1.0 i get a  Could not find module `Data.Array.Base' in src/Language/Hi/Binary.hs:90:7 :/
16:18:42 <u_quark> ... it is a member of package array-0.1.0.0, which is hidden
16:18:53 <dons> SamB: your repo isn't valid.
16:19:06 <dons> SamB: did you set up your config file, and run git-update-server-info ?
16:19:23 <monochrom> If it errs like a human and lies like a human, it is probably a human.
16:19:27 <SamB> dons: config file?
16:20:07 <u_quark> what am i doing wrong ?
16:20:09 <dons> SamB: can you make the git repo available as a .tgz ?
16:20:26 <dons> u_quark: you need the version of hs-plugins in darcs
16:20:27 <SamB> dons: well, I forgot to run git-update-server-info
16:20:30 <dons> code.haskell.org/~dons/code/hs-plugins
16:20:32 <SamB> it should work now
16:20:41 <dons> ok. working now.
16:21:30 <SamB> now, what is the config file supposed to do ?
16:21:53 <oerjan> that's the case in swedish too i think, e.g. plural -or vs. -ar
16:22:04 <oerjan> (wrong channel)
16:23:46 <Botje> i'm looking to use haskell to implement a compiler for school
16:23:54 <Botje> should prove to be interesting :)
16:24:28 <radetsky> I think I've asked this before, but does anyone know how to make ghci work with .hsc files?
16:24:58 <kmcallister> Botje, what language are you compiling?
16:25:06 <Botje> "tinyC", a variant of C
16:25:12 <Botje> but we're free in the language
16:25:16 <Botje> * choice
16:25:29 <Botje> so I might implement a compiler for a different language
16:26:11 <dmwit> Botje: Choose one that's already in Parsec.Language. ;-)
16:26:14 <Philippa> hrmm - so you could show off by doing a small ML or something?
16:26:28 <Botje> I don't know ML too well
16:26:31 <vininim> featherweight java
16:26:40 <Botje> but then that's a good idea :)
16:26:51 <u_quark> i am in the process of writing an article on compiler with haskell...
16:26:53 <Botje> vininim: the base assignment is already to compile to the JVM
16:27:03 <Botje> so i'd rather not do that :)
16:27:03 <vininim> heh
16:27:04 <adu> so did anyone look up Sage after I said something about it yesterday?
16:27:16 <vininim> the math environment?
16:27:26 <adu> vininim: yes
16:27:31 <dmwit> Botje: Do Haskell, a school project + you could get a paper out of it. =P
16:27:47 <adu> I love Haskell papers
16:27:57 <vininim> I tried it couple of times. It's okay, even though I don't like the notebooks web interface.
16:28:05 <adu> its like (opensouce++)++
16:28:18 <Botje> dmwit: i've been pondering that too
16:28:36 <Botje> and I loved SPJ's book on compiling miranda
16:29:00 <olsner> @ty \x -> ((x++)++)
16:29:03 <lambdabot>     Couldn't match expected type `[a]'
16:29:03 <lambdabot>            against inferred type `[a1] -> [a1]'
16:29:03 <lambdabot>     In the first argument of `(++)', namely `(x ++)'
16:31:51 <oerjan> wy: note that the A and B i suggested before can be seen as productions that will not pop the stack if it has a or b on top respectively
16:32:54 <oerjan> s/productions/the set of substrings/
16:33:13 <oerjan> well, more or less that
16:34:57 <gwern> 'fail = fail -- fail is made of fail' <-- oh noes, now the intersection of the sets of haskell and *channers is no longer the empty set!
16:35:16 <dmwit> It's been so for a long time.
16:35:16 <resiak> failfunction is faaaiiiiiiil ?
16:35:25 <dmwit> WEEEE ARE LEGIONNNNN
16:35:25 <gwern> resiak: precisely
16:35:31 <dmwit> </chan>
16:35:44 <gwern> fail = success -- fail harder
16:35:44 <EvilTerran> chan's closed due to dmwit?
16:36:00 <EvilTerran> sail = success; success = fail -- fail hardest
16:36:04 <dmwit> Chan is always open, and full of dmwits.
16:36:09 <EvilTerran> er, s/sail/fail/
16:36:15 <dmwit> You fail at fail.
16:36:15 <gwern> EvilTerran: ur doing it wrong
16:36:33 <gwern> dmwit: actually, I've long been wondering if dmwit is short for 'dimwit'...
16:36:45 <radetsky> ITC: /prog/rammers
16:36:45 <dmwit> gwern: Basically, yes. =)
16:36:54 <EvilTerran> fail = fix id success -- fail 4.0: live free or fail hard
16:37:23 <gwern> fail StupidArgument = error "be an hero"
16:38:53 <wy> oerjan: That's the idea. I'll think of a grammar for that
16:39:44 <hpaste>  (anonymous) annotated "card game" with "(no title)" at http://hpaste.org/5717#a3
16:40:13 <hasenov> hello, could anyone help me with my monad?
16:40:29 <hasenov> i know why what im doing is not working, but not sure how to implement it
16:41:03 <hasenov> its supposed to return IO, but instead its in G() mode
16:41:10 <dmwit> ?hpaste
16:41:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:41:30 <dmwit> Also, what libraries are you using?  (I'm not familiar with the G monad.)
16:42:15 <hasenov> well, im using Random, i mean that it tries to return the next generator when i need it to return IO
16:42:54 <dmwit> Have you looked at the randomIO family of functions?
16:43:09 <dmwit> :t randomRIO
16:43:11 <lambdabot> forall a. (Random a) => (a, a) -> IO a
16:43:13 <dmwit> :t randomRsIO
16:43:14 <lambdabot> Not in scope: `randomRsIO'
16:43:20 <dmwit> :t randomRs
16:43:22 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
16:43:25 <oerjan> :t withStdRandom
16:43:26 <lambdabot> Not in scope: `withStdRandom'
16:43:29 <oerjan> er
16:43:36 <oerjan> :t withStdGen
16:43:37 <lambdabot> Not in scope: `withStdGen'
16:44:48 <oerjan> :t getStdRandom
16:44:48 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
16:44:52 <oerjan> that was it
16:45:39 <oerjan> hasenov: getStdRandom can be used to turn a function that threads generators into one that uses the builtin IO one
16:46:35 <dmwit> You should also have a look at the Random monad on the wiki.
16:46:50 <dmwit> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
16:46:54 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
16:47:00 <hasenov> randomRIO works, however it doesnt take a generator value
16:47:26 <dmwit> hasenov: randomRIO uses the IO stdGen, so you can use setStdGen or whatever to feed it.
16:47:36 <dmwit> ?hoogle StdGen -> IO ()
16:47:37 <lambdabot> System.Random.setStdGen :: StdGen -> IO ()
16:47:55 <hasenov> oerjan: i did use getStdRandom, thats why it wants to return IO actually
16:48:00 <dmwit> hasenov: But if you want to manually thread your generator, why are you doing this in IO?
16:49:17 <hasenov> dmwit: uhh, i used getStdRandom and it returns IO, im not sure what i want to do
16:49:43 <hasenov> i mean i do know what i want to do but dont know how to accomplish it so im trying all kinds of methods
16:49:49 <dmwit> heh, ok
16:50:07 <dmwit> Do you want to paste what you have so far?  We might be able to give you a bit of guidance/help.
16:51:24 <hasenov> dmwit: what i have so far ive pasted, i had an earlier version where i was doing everything without >>=, now i would like to include it somehow
16:51:30 * QtPlatypus starts reading some of Paul Tayor's paper's on the "Abstract Stone Duality".  The first paragraph has pinged my kook detector "Is this stuff legit?"
16:51:44 <hasenov> http://hpaste.org/5717#a1
16:52:10 <dmwit> bwah
16:52:14 <hasenov> lines 19-22
16:52:18 <QtPlatypus> http://www.monad.me.uk/ASD/lamcra/
16:52:18 <lambdabot> Title: A lambda calculus for real analysis
16:52:38 <ivanm> QtPlatypus: as opposed to fake analysis? ;-)
16:53:03 <dmwit> hasenov: Oh, let me see if I can dig up that tutorial for mixing the State monad and Random use, it seems applicable here.
16:53:29 <QtPlatypus> ivanm: As opposed to descrete analysis.
16:55:47 <dmwit> hasenov: http://www.haskell.org/all_about_monads/html/statemonad.html
16:55:47 <lambdabot> Title: The State monad
16:56:42 <monochrom> We need an annual "The State of The Monad" speech. :)
16:56:58 <adu> monochrom: where can I listen to it?
16:57:08 <dmwit> hasenov: This also seems relevant, though it wasn't exactly the one I was thinking of: http://en.wikibooks.org/wiki/Programming:Haskell_monads#Random_Number_Generation
16:57:11 <lambdabot> http://tinyurl.com/2annd2
16:57:31 <hasenov> dmwit: ok, thank u, i will try reading through it to see if i can understand it
16:58:15 <adu> monochrom: I see the link now
16:58:47 <hasenov> dmwit: yeah, i read through the second example and thats how i was able to get to the second revision, but not sure what to do from there
16:59:09 <hasenov> dmwit: since ridOf kinda acts like a monad too
17:00:49 <dmwit> hasenov: ridOf seems pretty pure to me.
17:01:42 <dmwit> :t \xs n -> (take n xs ++ drop (n+1) xs, xs !! n)
17:01:44 <lambdabot> forall a. [a] -> Int -> ([a], a)
17:02:03 <nominolo> > mempty :: []
17:02:05 <lambdabot>      `[]' is not applied to enough type arguments
17:02:05 <lambdabot>     Expected kind `?', but ...
17:02:09 <nominolo> > mempty :: [Int]
17:02:12 <lambdabot>  []
17:02:14 <adu> so lets see, the monads I have encountered so far: Maybe, [], (ST s), Parser, (StateVar s), (State s), (GenParser c b), hmm...
17:02:28 <dmwit> adu: Reader, Writer?
17:02:35 <adu> dmwit: what do they do?
17:03:01 <dmwit> adu: Reader is the "reading" half of State, which simplifies things a lot.  It's the (r ->) monad.
17:03:27 <dmwit> adu: Writer is the "writing" half of State, so it's a similar idea.
17:03:35 <SamB> Writer doesn't really resemble state at all
17:03:48 <dmwit> No?
17:03:52 <dmwit> I think it does.
17:03:54 <SamB> no.
17:04:03 <dmwit> Except instead of "put" you only get "puts".
17:04:14 <SamB> that's totally different
17:04:24 <monochrom> That's just semantics.
17:04:31 <dmwit> SamB: Not really... put = puts . const
17:04:43 <SamB> dmwit: hmm?
17:04:52 <EvilTerran> writer can be trivially implemented via state
17:05:04 <SamB> > put . const
17:05:04 <lambdabot>        add an instance declaration for (MonadState (b -> a) m)
17:05:09 <EvilTerran> but then, so can a lot of monads
17:05:10 <dmwit> :t puts
17:05:11 <lambdabot> Not in scope: `puts'
17:05:18 <roconnor> @go 16 oz in g
17:05:19 <EvilTerran> ?src MonadWriter
17:05:19 <lambdabot> 16 ounces = 453.59237 grams
17:05:19 <lambdabot> Source not found. Where did you learn to type?
17:05:26 <dmwit> Ah, well, there's no puts, apparently.
17:05:27 <SamB> EvilTerran: can it be implemented efficiently that way?
17:05:47 <SamB> with the same strictness?
17:05:57 <dmwit> puts f = get >>= put . f -- this is what I meant
17:06:00 <EvilTerran> i don't know.
17:06:14 <EvilTerran> but i don't see why not.
17:06:26 <Cale> :t modify
17:06:27 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
17:06:27 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
17:06:42 <dmwit> Oh, nice, thanks.
17:07:07 <dmwit> So, "put = modify . const" or so.
17:07:11 <Cale> oerjan: I can think of a reason why mkStdGen would be missing... one sec.
17:07:20 <Cale> right
17:07:23 <SamB> :t modify . const
17:07:24 <lambdabot> forall (m :: * -> *) a. (MonadState a m) => a -> m ()
17:07:38 <EvilTerran> ?type write
17:07:39 <lambdabot> Not in scope: `write'
17:07:48 <dmwit> :t tell
17:07:49 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
17:07:55 <EvilTerran> ah, that's the one
17:08:15 <dmwit> You just have to write an appropriate Monoid instance for your w.
17:08:37 <OceanSpray> :t Network.PortNumber
17:08:37 <lambdabot> Network.Socket.PortNumber -> Network.PortID
17:08:42 <EvilTerran> tell = modify . mappend -- or something like that
17:08:51 <OceanSpray> what's what data constructor for, anyway?
17:08:51 <dmwit> right
17:08:57 <SamB> :t modify . mappend
17:08:57 <lambdabot> forall s (m :: * -> *). (Monoid s, MonadState s m) => s -> m ()
17:09:22 <EvilTerran> ?type runWriter
17:09:23 <lambdabot> forall w a. Writer w a -> (a, w)
17:09:34 <EvilTerran> ?type \s -> runState s mempty
17:09:38 <SamB> let tell = modify . mappend in tell ["Hi!"] >> tell ["Bye!"]
17:09:39 <lambdabot> forall s a. (Monoid s) => State s a -> (a, s)
17:09:41 <SamB> > let tell = modify . mappend in tell ["Hi!"] >> tell ["Bye!"]
17:09:41 <lambdabot>   add an instance declaration for (Show (m ()))
17:10:01 <EvilTerran> and that's it. dunno about the strictness, but it should work in the absence of bottoms
17:10:07 <SamB> > let tell = modify . mappend in runState (tell ["Hi!"] >> tell ["Bye!"]) []
17:10:08 <lambdabot>  ((),["Bye!","Hi!"])
17:10:32 <EvilTerran> hm. modify.flip mappend, i guess
17:11:17 <SamB> so... do I have to wait until the thing finishes running before seeing any output from this?
17:11:23 <psykon> what does haskell98 say about encoding ?
17:11:24 <dmwit> > runWriter (tell ["Hi!"] >> tell ["Bye!"]) []
17:11:25 <lambdabot>   Not in scope: `runWriter'
17:11:31 <dmwit> > runWriter (tell ["Hi!"] >> tell ["Bye!"])
17:11:31 <lambdabot>   Not in scope: `runWriter'
17:12:03 <dmwit> psykon: Almost nothing.
17:12:08 <EvilTerran> <EvilTerran> dunno about the strictness
17:12:31 <psykon> dmwit: so, that means?
17:12:32 <adu> i still don't understand
17:12:32 <Cale> I'll have to wait until I've finished this upload to fix it. Editing lots of files in vim remotely is a pain when you've maxed out your upload bandwidth.
17:13:05 <dmwit> psykon: If you need a specific encoding in your output, use a library specifically for that purpose.  There are a few on Hackage.
17:13:23 <psykon> what about characters?
17:13:32 <OceanSpray> :t IO.hSetBuffering
17:13:33 <lambdabot> GHC.IOBase.Handle -> GHC.IOBase.BufferMode -> IO ()
17:13:36 <Cale> @undefine
17:13:36 <psykon> what does the standard say about them?
17:13:36 <lambdabot> Undefined.
17:13:43 <dmwit> psykon: What would we be talking about, if not characters?
17:13:46 <Cale> > runWriter (tell ["Hi!"] >> tell ["Bye!"])
17:13:47 <lambdabot>   Not in scope: `runWriter'
17:13:52 <Cale> hmm
17:13:54 <dmwit> psykon: (I'm confused about what you're asking.)
17:14:05 <ivanm> QtPlatypus: yeah, I thought it would have been something like that... couldn't pass up the chance for the stupid comment though ;-)
17:14:05 <psykon> dmwit: what characters are there?
17:14:21 <dmwit> psykon: All the usual Unicode characters...
17:14:23 <QtPlatypus> No problem.
17:14:35 <psykon> *sigh*
17:14:49 <dmwit> I'm sorry.
17:14:59 <psykon> you could have just told me that :)
17:15:10 <dmwit> oh, heh
17:15:20 <psykon> CL, for example, only requires a very small set
17:15:32 <dmwit> > maxBound :: Char
17:15:33 <lambdabot>  '\1114111'
17:16:14 <oerjan> Cale: is missing runWriter the same problem? (btw i noted more of System.Random seemed missing)
17:16:21 <dmwit> psykon: Errr, oh, are we talking about in the source, or in program output?
17:16:25 <OceanSpray> :t fromIntegral
17:16:25 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:16:38 <psykon> dmwit: both?
17:17:28 <dmwit> psykon: Ah.  I don't know what the report says about encodings in source files, but details on what the compilers accept is here:
17:17:34 <dmwit> http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
17:17:36 <lambdabot> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
17:19:01 <psykon> thanks
17:19:55 <psykon> is hscurses not maintained anymore?
17:21:39 <Cale> oerjan: I
17:21:55 <Cale> oerjan: Control.Monad.Writer seemed to be missing entirely, and I have no idea why
17:22:06 <oerjan> ouch
17:22:11 <Cale> oerjan: Random was one of the imports that I removed along with the rest of the haskell98 package.
17:22:32 <Cale> (I just forgot to import System.Random instead)
17:22:39 <oerjan> ok :)
17:26:24 <TomMD> So I've been testing Control.Event using the test routines from Control.Timeout and found that GHC 6.8.2 seems to die in the 1000 event case (meaning, 1000 forkIOs will be happening at "the same time")
17:27:09 <psykon> a tutorial on intefacing with C ?
17:27:25 <EvilTerran> ?where ffi
17:27:26 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
17:27:31 <TomMD> Replacing (mapM_ forkIO) with (sequence_) give proper operations (it doesn't hang forever with CPU pegged at 100), but that is obviously less prefereable.
17:28:21 <TomMD> I'm traveling to GHC trac now, but if someone has insite then feel free to chime in.
17:34:43 <OceanSpray> :t IO.hPutStr
17:34:44 <lambdabot> GHC.IOBase.Handle -> String -> IO ()
17:34:53 <Cale> TomMD: I've done tests with hundreds of thousands of active threads with no problem.
17:35:46 <Cale> psykon: See that ffi link which EvilTerran brought up, in case it wasn't clear that was meant for you :)
17:35:55 <TomMD> Cale: yes, I've done so as well, so this is odd to me - but I am counting the executed threads (atomically decrementing a TVar) and I never get zero on my TVar... I'm still looking, as I said.
17:36:07 <Cale> TomMD: Can I see the code?
17:36:13 <psykon> Cale: yes, i followed it, it's a reference though :|
17:36:28 <Cale> psykon: It's pretty tutorial in nature.
17:36:33 <TomMD> Cale... I'll put a darcs on community.haskell.org, give me a second.
17:36:40 <psykon> i'd like a hand-holding tutorial :)
17:37:17 <Cale> TomMD: If it's really short, you could just hpaste it :)
17:38:06 <psykon> is hscurses maintained ?
17:39:00 <ivanm> how do you update lambdabot's @where listing? hscurses link needs to be updated
17:39:29 <Cale> http://haskell.org/haskellwiki/FFI_Introduction
17:39:29 <TomMD> Cale: Its still in a bit hairy of a state.  If you give me time I could have it cleaner (or perhaps fixed)
17:39:55 <psykon> and so does haskell.org
17:40:00 <TomMD> To clarify: This was me attempting to take Control.Event and intentionally over-engineer it.
17:40:03 <oerjan> ivanm: @where+
17:40:39 <ivanm> @where+ hscurses http://www.informatik.uni-freiburg.de/~wehr/software/haskell/
17:40:39 <lambdabot> I will never forget.
17:41:50 <foxyom> I'm trying to convert a Word32 to an Int and I get the same value, but I am expecting to get a negative value
17:42:03 <ivanm> looks like it's dead, though... darcs repo hasn't been updated since 2006 AFAICT
17:42:18 <foxyom> > fromIntegral 16555580 :: Int
17:42:21 <lambdabot>  16555580
17:42:32 <dons> foxyom: fromIntegral ?
17:42:36 <SamB> hmp3 uses curses
17:43:01 <Cale> > fromIntegral (16555580 :: Word32) :: Int
17:43:02 <ivanm> well, psykon and I can't seem to build the latest tarball version on 6.8.2...
17:43:07 <oerjan> > maxBound :: Int
17:43:09 <lambdabot>  2147483647
17:43:09 <lambdabot>  16555580
17:43:34 <Cale> The number is too small to cause wraparound.
17:43:59 <oerjan> > fromIntegral (2200000000 :: Word32) :: Int
17:44:09 <lambdabot>  -2094967296
17:45:02 <foxyom> ah
17:45:36 <Cale> foxyom: Note that the exact size of Int is not guaranteed, but maxBound :: Int and minBound :: Int can be used to determine its extents.
17:45:36 <foxyom> ?where hmp3
17:45:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
17:45:47 <foxyom> Cale: thanks...
17:46:30 <TomMD> Cale: If you really want to get your hands dirty, the code is at http://community.haskell.org:/~tommd/control-event
17:46:30 <TomMD> I am not going to say the bug isn't mine, but I am certainly suspicious.  To get the error, uncomment the (mapM_ forkIO) and comment out the (sequence_) in Control/Event.hs.  To test use Test/Event.hs
17:46:30 <lambdabot> Title: Index of /~tommd/control-event
17:47:37 <foxyom> Is there a tool to automagically install required Cabal packages from hackage?
17:47:46 <Cale> yep
17:47:48 <Cale> cabal-install
17:47:54 <Cale> It's available on hackage :)
17:48:12 <SamB> how many packages do you need to install to build it?
17:48:39 <TomMD> foxyom: It rocks but be warned that it won't auto-recompile packages just because their dependencies had new releases.
17:49:19 <TomMD> SamB: I think HTML, tar, Cabal, and then cabal-install is it.  I might be missing one.
17:50:39 * oerjan vaguely recalls zlib being mentioned
17:50:41 <Cale> SamB: about 4, iirc.
17:53:22 <stepcut> Question: was it out of place of me to close this bug invalid? http://hackage.haskell.org/trac/ghc/ticket/2108
17:53:23 <lambdabot> Title: #2108 (ghci is not tail recursive) - GHC - Trac
20:03:35 --- topic: '["Grassroots efforts take effort!", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/", "visualise #haskell's social network : http://tinyurl.com/ytzeab"]'
20:03:35 --- topic: set by dons on [Tue Feb 12 17:14:51 2008]
20:03:35 --- names: list (clog znutar dcoutts__ elaforge permanente psykon_ yondalf_ wellwisher trie tennin larmeh_ kmcallister davidL fishey nostrademons synthasee alatter dolio blargeyfarg jaredj Mr_Awesome ddarius romeo1 Mortomesleeping seafood_ aik__ Arnia thoughtp1lice foxyom johnnowak calvins bogner Mladen alec cjb Thomas2 ChilliX kolmodin notostraca__ gvdm wy markb_ lQg Pseudonym EvilTerran hasenov thou Yuffster SnappyTWC vininim dcoutts_ Syzygy- fxr kilimanjaro)
20:03:35 --- names: list (OceanSpray smtms edwinb oerjan stick_figure BMeph wchogg ohub kscaldef Heffalump Sgeo clanehin Cha1 nottha_k NichardRixon goalieca arossato Adamant mld ajhager desp nominolo bolrod Time`s_Witness blbrown mm_freak cognominal__ mathrick JaffaCake sclv geocalc araujo Eelis letrec zygen Eiler IRSeekBot keseldude elias` sorear faxathisia Giraph kpreid binary42 TomMD uebayasi rdd LoganCapaldo mattrepl mlh lament sjw Baughn hellige XD-G-C faluf)
20:03:35 --- names: list (zeno Modius tarbo_ c9s tltstc andrei u_quark Averell Valodim_ ivanm bd_ egaga Poeir lambdabot z` fdr- Boney cygnus_ dejones Khisanth sioraiocht robozni stepcut jatqceer metasyntax njbartlett dje mattiast jones- roconnor lekro helmut matthew-_ AtnNn kosmikus nothingmuch yaru1022 sethk shteou thorkilnaur eyck jonathanv Shoragan shanse Jaak agemo rey_ cnwdup flori l_a_m ADEpt AshyIsMe r0bby boyscared yahooooo mrsolo user317 wagle drbean)
20:03:35 --- names: list (dmwit souk fnordus arjanoosting oklopol levitation[A] Caelum pkazmier shapr sannysanoff scott___ acura sarah__ vincenz Nafai nornagon atsampson yrlnry rue Lycurgus ShockSMY pchiusano_ sek jnkm replor___ eno tessier Korollary torbjorn huh ertai ari ski_ glith GNU\caust1c lenbust m4thrick dobblego mrd czakey matthew_- pastorn quicksilver cjay Igloo andun ksandstr slarba ricky_clarkson Liskni_si aleator_ Tobsan DuClare Lunchy bgeron Gnezdo)
20:03:35 --- names: list (shachaf Cale jcreigh bos d0rt jfredett proq spoop pjd awesame flippo sieni dionoea ZsoL_ codemac baaba idnar worklez gds allbery_b mgregsond dcoutts mightybyte fophillips netx tuukkah Tychom lakupuu kaol Hirvinen kig birkenfeld ragzter Nanar Shimei loupgaroublond wagle_home Zao magnus_ delYsid Lemmih ray encryptio felipe pitecus miasma ibid flux opqdonut_ opqdonut qwr Deewiant Vq^ kpk bran_ rumbleca Jiten czShadoW Ginzor dropdrive MyCatVerbs)
20:03:35 --- names: list (jleedev seafood hpaste M3n3watran Cin regulate ulfdoz qebab gbacon Saizan ojacobson Codex_ bens TSC lucca noj _frederik_ wli ichor huamn aghos klutometis benny nasloc__ ski MarcWeber daf kalven xerox obk Philippa Twigathy rblackwe sili arkx klugez radix jjore-w Tigge IvdSangen chr1s jaggederest Shurique ydo osfameron scook0 Xgc Plareplane Eidolos cognominal puusorsa Thas DRMacIver arguile jeremiah pejo inimino jvoorhis_ schlumpi orbitz)
20:03:35 --- names: list (zamez mattam taruti mornfall Japsu pheaver gwern raxas dblog moonlite Spark maskd Botje ac QtPlatypus mfp jeffz resiak SimonRC dons_ dons newsham funktio gal_bolle wolverian mokus audreyt byorgey Vulpyne nipuL wifs integral mahogny Oatschool MrDomino bitrot koeien dv\ stevan cmeme cods jql xsdg thedward Riastradh C-Keen dgriffi3 SamB dancor Arnar dfranke tessier_ pragma_ mux magagr liesen pa-ching jedbrown Mitar laz0r liyang earthy @ChanServ)
20:03:35 --- names: list (pcc1 Laney)
20:03:48 <dmwit> ah
20:03:56 <BMeph> dmwit: No, it doesn't make a difference. It keeps the order of the arguments, though.
20:03:58 <dmwit> That's cute. =)
20:04:08 <ddarius> @src forM_
20:04:09 <lambdabot> forM_ = flip mapM_
20:04:22 <scook0> I assume that a Haskell thread will always run sequentially, and that if it migrates across processors the appropriate memory barriers will be issued
20:04:24 <blargeyfarg> actually, there are a number of improvements.  most notably, the array is mutable, so it doesn't need to be returned ;)
20:04:27 <scook0> but I don't know for sure
20:05:15 <gwern> Cale: I laugh at pre-cabal-is-ness-nt-nature!
20:06:13 <ddarius> gwern packages pre-Haskell-98 code in the type system
20:06:50 <gwern> ddarius: if only. I haven't got my head around the monadzero stuff Cale likes
20:07:17 <elaforge> if you mean "does it automatically parallelize" I really doubt it
20:07:23 <elaforge> there is Control.Parallel for that after all
20:07:41 <kmcallister> anyone know why unsafeFreeze converting an IOCArray to a CArray causes a stack overflow (i'm not using the resulting value for anything)
20:07:43 <elaforge> and I thought migrating across processors is what the OS does?
20:07:47 <scook0> actually, I was more thinking "I hope it doesn't unexpectedly encounter memory incoherency"
20:08:35 <elaforge> OS X gives a loadavg of .5/.5 with one proc running, so I assumed it's migrating it across processors
20:08:47 <elaforge> taking a cache hit no doubt
20:09:40 <SamB> dons: there is something wrong with your clone of jhc.git :-(
20:10:55 <Cale> http://cale.yi.org/autoshare/nymphaea.tar.bz2
20:11:07 <Cale> I wrote it with xerox quite a long while ago.
20:11:29 <Cale> There are a bunch of unfinished bits.
20:12:01 <Cale> If getting the package from me is at all slow, blame vincenz ;)
20:14:04 <Cale> Once you have it up and running, click the draw button, and then try clicking and dragging somewhere inside the image.
20:14:39 <Cale> (that's how you set the initial position and angle)
20:14:59 <gwern> yi.org?
20:15:05 <Cale> yeah
20:15:11 <SamB> @message dons that git repo seems incomplete ; it's missing a bunch of tags and it certainly doesn't have Lemmih's patches in it... which there are at least two of...
20:15:11 <lambdabot> Maybe you meant: messages messages?
20:15:16 <Cale> It's a dynamic DNS service.
20:15:18 <SamB> @tell dons that git repo seems incomplete ; it's missing a bunch of tags and it certainly doesn't have Lemmih's patches in it... which there are at least two of...
20:15:18 <lambdabot> Consider it noted.
20:15:32 <gwern> Cale: just thought it an interesting coincidence, and was wondering which came first
20:16:02 <Cale> yi.org did
20:16:25 * gwern shrugs. sure they won't begrudge it - it's a nice name
20:16:45 <gwern> Cale: just in case, darcs send is good?
20:17:09 <Cale> Uh... darcs send to where?
20:17:23 <gwern> presumably you
20:17:34 <gwern> you do posses an email address, no?
20:17:38 <Cale> Yes.
20:17:41 <Cale> cgibbard@gmail.com
20:17:50 <dmwit> Hmmm... let's see, a bit of mental math.
20:17:52 * gwern sees it already in the _darcs, thanx
20:17:57 <Cale> okay
20:18:50 <hasenov> Thomas2: r u still there?
20:19:00 <hasenov> how would u use shuffle?
20:19:13 <dmwit> I very much doubt yi.org came first... that would make Cale less than 9 years old. ;-)
20:19:46 <dmwit>  
20:19:53 <hasenov> I have "g <- getStdRandom, return (shuffle g [1,2,3])" and it doesnt work
20:20:20 <dmwit> What's the type of shuffle?
20:20:28 <oerjan> hasenov: getStdGen not getStdRandom
20:21:07 <oerjan> or, getStdRandom (shuffle g [1,2,3])
20:21:16 <oerjan> er wait
20:21:38 <Cale> dmwit: The question was presumably which came first: yi.org or yi
20:21:46 <dmwit> getStdRandom (fliy shuffle [1,2,3]) -- ?
20:22:00 <oerjan> dmwit: perhaps
20:22:03 <oerjan> (flip that is)
20:22:17 <dmwit> Cale: Oh, right.  /me feels silly
20:22:45 <gwern> d'oh. I need gtk2hs first
20:23:36 <oerjan> :t randomR
20:23:40 <elaforge> Cale, entertainingly "di yi" could mean "the first"
20:23:40 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
20:24:05 <gwern> elaforge: in what heathen language?
20:24:18 <elaforge> mandarin
20:24:27 <hasenov> uhh, it still didnt work
20:24:46 <elaforge> but the actual character they're using has a different meaning
20:25:27 <gwern> eh. build problems with gtk2hs. I'll leave nymphaea for tomorrow
20:25:34 <dejones> I'm confused by the Maybe data type...  I'm trying to use Network.URI.parseURI and it returns Maybe URI
20:26:06 <dejones> do I have to declare a variable that has the Maybe data type to use with the Maybe URI return?
20:26:11 <oerjan> hasenov: what is the type of shuffle?
20:26:17 <kmcallister> so nobody knows about the stack overflow problem with freeze / unsafeFreeze? from a quick googling it seems several others have had the same problem, and i don't see a working solution
20:26:36 <dons> SamB: ?
20:26:36 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:26:39 <elaforge> dejones if you choose to declare at all, yes
20:26:55 <hasenov> test.hs:6:18:
20:26:56 <hasenov>     Couldn't match expected type `()' against inferred type `[t]'
20:26:56 <hasenov>     In the first argument of `return', namely `(shuffle g [1, 2, 3])'
20:26:56 <hasenov>     In the expression: return (shuffle g [1, 2, 3])
20:26:56 <hasenov>     In the expression:
20:26:57 <Mr_Awesome> anyone know of a good guide to writing specifications with quick check? or perhaps should i just look at examples?
20:27:25 <oerjan> hasenov: i was not asking for the error message, but for the type of shuffle
20:27:33 <hasenov> shuffle :: (RandomGen g) => g -> [a] -> [a]
20:28:08 <oerjan> that's weird
20:28:17 <ricky_clarkson> :t (/)
20:28:17 <lambdabot> forall a. (Fractional a) => a -> a -> a
20:28:27 <oerjan> and shuffle itself compiles properly?
20:28:33 <ricky_clarkson> @instances Fractional
20:28:34 <lambdabot> Double, Float
20:28:47 <hasenov> yeah
20:28:58 <dejones> elaforge: heh, thanks... I had a typo ;)  I wasn't using the name of the imported module correctly ;)
20:29:07 <oerjan> hasenov: are you using g <- getStdGen as i first suggested?
20:29:11 <hasenov> i had to add an "import Random" statement however
20:29:30 <oerjan> the getStdRandom will not work because shuffle does not return a generator
20:30:03 <hasenov> oerjan: yeah, its "main = do g <- getStdGen\n return (shuffle g [1,2,3])"
20:30:47 <oerjan> hasenov: actually probably make that newStdGen if you want to do it several times
20:31:01 <oerjan> oh right
20:31:18 <oerjan> you are not doing anything with the result of shuffle
20:31:31 <oerjan> try print instead of return
20:31:36 <Thomas2> yeah, print that
20:31:39 <Thomas2> main is meant to return ()
20:32:03 <Thomas2> should have left my test example in :-)
20:32:49 <hasenov> oh, that worked, thanx
20:33:03 <wagle_home> how do you return a unix exitcode from the haskell process?
20:33:09 <hasenov> i forgot that in my other example it used print rather than return actually
20:33:14 <oerjan> :t exitWith
20:33:16 <lambdabot> Not in scope: `exitWith'
20:33:21 <allbery_b> @hoogle exitWith
20:33:22 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
20:33:23 <oerjan> :t System.Exit.exitWith
20:33:24 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
20:33:54 <oerjan> @hoogle exit
20:33:55 <lambdabot> System.Exit :: module
20:33:55 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
20:33:55 <lambdabot> System.Exit.exitFailure :: IO a
20:34:13 <elaforge> it's sorta heavyweight... a whole new module for exiting, and a whole type for exit codes
20:34:24 <morner> wow, this place is much busier than #ocaml
20:34:29 <allbery_b> modules are cheap
20:34:37 <allbery_b> the exit code type i
20:34:41 <allbery_b> @hoogle Exit
20:34:41 <lambdabot> System.Exit :: module
20:34:41 <lambdabot> System.Exit.ExitCode :: data ExitCode
20:34:41 <lambdabot> System.Exit.ExitSuccess :: ExitCode
20:34:48 <elaforge> I guess, but I grudge the typing :P
20:34:56 <allbery_b> ExitSuccess or (ExitFaulure exitcode)
20:35:04 <oerjan> um no
20:35:24 <oerjan> oh right, capitalization
20:35:38 <allbery_b> ExitFailure even
20:35:52 <Thomas2> morner: yeah, this place is dangerous to follow at work ... end up getting nothing of value done
20:35:59 <allbery_b> exitFailure = exitWith (ExitFailure 1) -- I think
20:36:33 <ddarius> Thomas2: Learning how symmetric monoidal categories and applicative functors are related is nothing?!
20:36:37 <wagle_home> thanks
20:36:42 <allbery_b> (and ExitFailure 0 is forced to ExitFailure 1, so you don't get success from a failure)
20:36:43 <dejones>     Couldn't match expected type `[Char]'
20:36:45 <dejones> 	   against inferred type `URI -> String'
20:36:46 <oerjan> elaforge: mind you the old System contains this as well
20:36:47 <dejones> help?
20:36:49 <dejones> :)
20:37:17 <elaforge> dejones missing an arg?
20:37:18 <dejones> I'm just trying to putStrLn for the uriPath in Network.URI.uriPath
20:37:24 <ddarius> > 1024*512
20:37:25 <allbery_b> dejones: you passed it a function where it expected a string.  missing parentheses or arguments?
20:37:27 <lambdabot>  524288
20:37:27 <allbery_b> @paste
20:37:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:37:46 <dejones> hmm
20:41:05 <oerjan> allbery_b: the 1 is implementation-dependent, at least in theory, and 0 gives an ioError
20:41:16 <hpaste>  dejones pasted "uriPath" at http://hpaste.org/5726
20:41:28 <dejones> I don't understand the Maybe URI data type
20:41:57 <dejones> :/
20:42:06 <kmcallister> @src Maybe
20:42:06 <lambdabot> data Maybe a = Nothing | Just a
20:42:24 <yondalf_> dejones: i think (uri.uriPath) should be (uriPath uri)
20:42:28 <kmcallister> so a value of type Maybe URI is either Nothing, or Just u, where u is a URI
20:42:30 <dejones> kmcallister: yeah, I know how it is defined, but I don't understand how to use it...
20:42:36 <kmcallister> you can take it apart with case
20:42:45 <dejones> ok
20:42:56 <ddarius> @src maybe
20:42:57 <lambdabot> maybe n _ Nothing  = n
20:42:57 <lambdabot> maybe _ f (Just x) = f x
20:43:37 <yondalf_> or write let Just uri <- URI.parseURI(url)
20:43:46 <yondalf_> if you don't want to care about error handling :-)
20:44:01 <dejones> yondalf_: thank you
20:44:06 <kmcallister> err, with = instead of <-
20:44:08 <kmcallister> if it's in a let
20:45:03 <kmcallister> dejones, also, when you import a module, unless you specify "qualified" you don't need to qualify the names (e.g. you can use parseURI instead of URI.parseURI)
20:45:18 <kmcallister> and function application is generally written f g or (f g) not f(g)
20:45:26 <kmcallister> (the latter is just extraneous parens around g)
20:45:38 <dejones> kmcallister: thank you for the tips
20:45:39 <dejones> :)
20:45:41 <dejones> thank you too yondalf_
20:45:47 <kmcallister> no problem
20:46:22 <dejones> kmcallister: let Just uri = URI.parseURI uri
20:46:25 <dejones> that should work?
20:46:29 <kmcallister> yeah
20:46:37 <dejones> kmcallister: let Just uri = URI.parseURI url
20:46:38 <kmcallister> if the URI isn't valid the program will quit with an error
20:46:40 <dejones> url, I mean
20:46:42 <dejones> ;)
20:46:51 <hpaste>  yondalf annotated "uriPath" with "this works" at http://hpaste.org/5726#a1
20:47:17 <dejones> kmcallister: ok
20:47:23 <dejones> yondalf_: thankyou
20:47:46 <yondalf_> @src maybe
20:47:46 <lambdabot> maybe n _ Nothing  = n
20:47:46 <lambdabot> maybe _ f (Just x) = f x
20:47:55 <oerjan> @src fromMaybe
20:47:55 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
20:48:25 <dejones> yondalf_: thank you!  :)  Ahhh, it just hit me
20:48:48 <dejones> URI.uriPath is still a function that returns the uriPath from the uri
20:49:02 <hasenov> would u guys know of any useful links of AI in haskell?
20:49:02 <dejones> not like an object in OO programming where it is a "getter" function for the object
20:49:10 <hasenov> or maybe AI in general?
20:49:12 <yondalf_> if you want better error messages, i do something like: maybe (fail "Error message") return (parseURI url)
20:49:49 <yondalf_> but don't worry about that if you're new :-)
20:49:59 <dejones> yondalf_, kmcallister: thank you both.  why might someone use let instead of <- ?
20:50:08 <dejones> yondalf_: I'm clearly new
20:50:08 <dejones> haha
20:50:18 <kmcallister> dejones, <- is for monadic values
20:50:24 <dejones> I'm not going to let haskell defeat me though
20:50:25 <dejones> hee
20:50:28 <dejones> hehe
20:50:36 <yondalf_> i'll just explain without monads for now, since dejones is new
20:50:39 <dejones> I do really like the concepts of Haskell.  :)
20:50:47 <ddarius> dejones: It would be pretty bad to lose to a dead guy.
20:50:56 <dejones> ddarius: ll
20:50:56 <dejones> lol
20:51:10 <yondalf_> some functions are "pure" (no side effects), and some functions are not (generally speaking)...the impure ones have "IO" in their types
20:51:24 <dejones> yondalf_: right, in the IO monad.
20:51:35 <yondalf_> when you have an impure function, you must use <- and put them on separate lines because order matters
20:51:46 <kmcallister> if you write "do x <- a; b", the type of a has to be "m t" for some monad m (e.g. IO), and the type of x within b is t
20:51:55 <kmcallister> whereas with "let x = a in b", the type of a and the type of x within b are the same
20:51:57 <yondalf_> when you have a pure function, you can just use let since what you're doing is just making another name for it
20:52:21 <yondalf_> in fact, putStrLn ("Simbal_Router: " ++ (uriPath (parseURI url)) ++ "\n") will also work
20:52:23 <thoughtp1lice> you can think of <- as saying "give me the value from this stateful (impure) computation"
20:52:37 <dejones> yondalf_: thank you. :)
20:52:49 <dejones> kmcallister: thank you too
20:52:50 <yondalf_> however, you can't do something like putStrLn (getLine ++ getLine) because...which getLine is going to be run first?
20:52:54 <thoughtp1lice> (granted this is not really technically precise, see what kmcallister said)
20:52:58 <Eiler> is there any difference between using conditionals and guards?
20:52:58 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
20:52:59 <yondalf_> :t getLine
20:52:59 <lambdabot> IO String
20:53:17 <dejones> thanks Cal
20:53:18 <dejones> thanks Cale
20:53:19 <Cale> That's a little tutorial I wrote to give people the right starting points for thinking about IO in Haskell :)
20:53:23 <dejones> :)
20:53:32 <yondalf_> you must write do \n a <- getLine \n b <- getLine \n putStrLn (a ++ b)
20:53:33 <dejones> I'll read it tomorrow
20:53:33 <kmcallister> dejones, let can be thought of as sugar for application, i.e. "let x = a in b" => "(\x -> b) a"
20:53:47 <oerjan> Eiler: they all desugar to pattern matching anyhow
20:53:52 <Cale> dejones: Let me know if you have any questions of course
20:53:59 <dejones> Cale: I shall.  :)
20:54:15 <kmcallister> whereas the <- in do notation translates to application of the operator (>>=), which you'll run into when you study monads
20:54:29 <dejones> kmcallister: that's the bind operator.  :)
20:54:54 <hasenov> do u people think that haskell is a good language to do AI in?
20:55:00 <dejones> I've read some stuff so far...  conceptually, I don't have a problem, I don't think.  But, I have issues actually applying the concepts in Haskell.
20:55:00 <dejones> heh
20:55:22 <dejones> yondalf_: thanks again
20:55:25 <dejones> I gotta go to sleep now
20:55:26 <yondalf_> dejones: wait until you reach monad transformers :-P i still have problems with those, not to mention arrows and applicative functors, whatever they are
20:55:27 <dejones> class in the morning
20:55:35 <dejones> yondalf_: lol
20:55:37 <kmcallister> hasenov, do you mean old-school symbol-manipulation AI, or "machine learning"?
20:55:39 <dejones> yondalf_: sounds crazy.
20:55:40 <dejones> :(
20:55:53 <yondalf_> but you don't need all those to do interesting things with haskell
20:55:53 <dejones> I'm planning on doing my Master's thesis this summer with Haskell.
20:56:02 <ddarius> Eiler: case is usually considered the "primitive" decision making construct in Haskell
20:56:02 <thoughtp1lice> names are always scary.
20:56:25 <hasenov> kmcallister: i think symbol manipulation, the kind that is needed in a basic card game
20:56:41 <kmcallister> hasenov, it's good for that sort of thing
20:56:43 <dejones> It is scary though.  I don't know Haskell very well, and I am going to try to do my thesis on "Haskell on the Bare Metal" to implement the concurrency features of Haskell from GHC runtime on the bare metal, aka without a kernel handling it.
20:56:50 <Cale> Basically, monads, arrows and applicative functors are all just fancy names for ways to structure libraries so that we can reuse various combining functions between them.
20:57:08 <dejones> I'm a little scared.  But, it should be a lot of fun and very challenging!
20:57:09 <dejones> :)
20:57:09 <johnnowak> dejones: good luck!
20:57:13 <dejones> johnnowak: lol, thanks
20:57:21 <kmcallister> hasenov, http://www.math.chalmers.se/~rjmh/Papers/whyfp.html has a simple implementation of alpha-beta minimax
20:57:22 * johnnowak readies the sedatives 
20:57:23 <lambdabot> Title: Why Functional Programming Matters
20:57:25 <ddarius> dejones: Sounds like mostly an engineering problem.
20:57:26 <dejones> I'm sure I'll be in here a lot asking questions.  ;)
20:57:35 <dejones> ddarius: yeah.  :)
20:57:35 <Cale> dejones: It's a great way to learn :)
20:57:40 <allbery_b> here we go again, (james) haskell scores :>
20:57:46 <dejones> Cale: :)
20:57:47 <Eiler> ddarius: i was mostly thinking of" if... else
20:57:54 <dejones> but, I really must get to sleep
20:57:55 <thoughtp1lice> dejones: haskell-cafe is also a good place to ask questions.
20:57:57 <dejones> g'night everyone.
20:58:01 <Eiler> maybe case is the same
20:58:04 <dejones> thoughtp1lice: thank you.
20:58:05 <thoughtp1lice> have fun in your journey.
20:58:09 <ddarius> Eiler: if b then t else e == case b of True -> t; False -> e
20:58:32 <allbery_b> (intended that for -blah.
20:58:42 <ddarius> Eiler: In core, all control constructs (if/case/pattern matching/guards) desugar to simple case statements.
20:59:47 <hasenov> kmcallister, thanx
21:00:59 <Eiler> ddarius: ok, but is anyone of them favoured when writing "good" haskell code?
21:01:08 <Eiler> as in readable
21:01:17 <ddarius> Eiler: The preferred style is usually guards and pattern matching.
21:01:37 <ddarius> Eiler: if and case are much less common
21:01:49 <ddarius> (Though certainly the right thing to use in some cases.)
21:01:50 <hasenov> kmcallister: what language do they use, Miranda?
21:02:00 <Eiler> we covered if/case/guard there, how is pattern matching done?
21:02:08 <ddarius> @src Maybe
21:02:08 <lambdabot> data Maybe a = Nothing | Just a
21:02:12 <ddarius> @src maybe
21:02:13 <lambdabot> maybe n _ Nothing  = n
21:02:13 <lambdabot> maybe _ f (Just x) = f x
21:20:48 <Nafai> Is there a more recent project that does this? http://hoc.sourceforge.net/ I'm getting a Mac and it would be fun to write apps and stuff with Haskell
21:20:48 <lambdabot> Title: HOC: A Haskell to Objective-C Binding
21:21:48 <ddarius> scook0: I don't think there's much of conflict with the Hat tracer.  The contexts are totally different.
21:23:44 <scook0> that is true, especially since people often refer to data structures with the full module name
21:23:58 <scook0> i.e. Data.Random.Hat or whatever
21:24:04 <ddarius> And because no one really talks about hat
21:24:15 <scook0> also true
21:24:35 <scook0> well, this is why I asked for comments :)
21:25:19 <scook0> @hoogle draw
21:25:19 <lambdabot> Data.Tree.drawTree :: Tree String -> String
21:25:19 <lambdabot> Data.Tree.drawForest :: Forest String -> String
21:34:18 <Mr_Awesome> is there an easier way to write (partitionM :: Monad m => (a -> m Bool) -> [a] -> m ([a], [a])) than writing it recursively?
21:35:31 <oerjan> map fst . filterBy snd . zip l . mapM p $ l
21:35:36 <oerjan> or something like that
21:35:41 <oerjan> er no By
21:36:04 <dmwit> I don't believe you.
21:36:05 <oerjan> um
21:36:11 <dmwit> :t filter
21:36:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:36:15 <dmwit> :t filterM
21:36:16 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
21:36:21 <oerjan> partition
21:36:58 <dmwit> :t \p l -> map fst . partition snd . zip l . mapM p $ l -- this doesn't sound right
21:37:00 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[b]'
21:37:00 <lambdabot>       Expected type: [a1] -> [(a, Bool)]
21:37:00 <lambdabot>       Inferred type: [a1] -> [(a, [b])]
21:37:05 <oerjan> :t map (fst *** fst) . partition snd . zip ?l . mapM ?p $ ?l
21:37:07 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[b]'
21:37:07 <lambdabot>       Expected type: [a1] -> [(a, Bool)]
21:37:07 <lambdabot>       Inferred type: [a1] -> [(a, [b])]
21:37:11 <oerjan> gah
21:37:28 <dmwit> oerjan: partition isn't inside the monad like you want it to be.
21:37:37 <oerjan> oh hm
21:37:41 <dmwit> Maybe lift it in?
21:37:50 <oerjan> :t liftM (map (fst *** fst) . partition snd . zip ?l) . mapM ?p $ ?l
21:37:51 <lambdabot>     Couldn't match expected type `[((a, b), (a1, b1))]'
21:37:51 <lambdabot>            against inferred type `([(a2, Bool)], [(a2, Bool)])'
21:37:51 <lambdabot>       Expected type: [Bool] -> [((a, b), (a1, b1))]
21:37:57 <dmwit> :t liftM partition
21:37:57 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ([a] -> ([a], [a]))
21:38:16 <alatter> :t partition
21:38:16 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
21:38:38 <oerjan> :t liftM ((map fst *** map fst) . partition snd . zip ?l) . mapM ?p $ ?l
21:38:39 <lambdabot> forall a (m :: * -> *). (Monad m, ?p::a -> m Bool, ?l::[a]) => m ([a], [a])
21:38:42 <oerjan> yay
21:39:38 <Mr_Awesome> so no? :P
21:39:50 <dmwit> I haven't given up yet.
21:39:51 <dmwit> =)
21:40:09 <oerjan> what? i just succeeded
21:40:19 <Mr_Awesome> this is why working in monads is a pain in the ass
21:40:22 <dmwit> oerjan: I think his complaint is that it's not easier. =P
21:40:52 <oerjan> bah
21:41:39 <Mr_Awesome> :t zip
21:41:40 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
21:42:01 <Cale> Mr_Awesome: what's the problem?
21:42:14 <vijay4114> hi all
21:42:31 <dmwit> writ partitionM :: (a -> m Bool) -> [a] -> m ([a], [a])
21:42:33 <Cale> Mr_Awesome: I think probably you'll want to write it recursively.
21:42:40 <dmwit> vijay4114: Hiya!
21:42:44 <oerjan> :t (map fst *** map fst) . partition snd . zip ?l <$> mapM ?p ?l -- prettify
21:42:46 <lambdabot> forall a (f :: * -> *). (?p::a -> f Bool, ?l::[a], Monad f, Functor f) => f ([a], [a])
21:43:13 <Cale> Mr_Awesome: Things generally get a little bit harder simply because you have to order the computation.
21:44:01 <Cale> Yeah, you could use mapM and zip.
21:44:17 <Mr_Awesome> Cale: indeed. im wondering if there is a way to factor the monadic and pure parts of my computation
21:44:35 <Mr_Awesome> (nothing to do with partitionM)
21:45:04 <dmwit> So, I haven't read the paper or anything, but is HList a b just (a, b), with head = fst, tail = snd, and cons = (,)?
21:45:04 <Cale> Mr_Awesome: Well, which monad is this in?
21:45:06 <Cale> IO?
21:45:24 <Mr_Awesome> Cale: some error monad
21:45:29 <Cale> dmwit: Yes, sort of :)
21:45:53 <dolio> @type \p -> foldM (\(ls,rs) a -> p a >>= \b -> if b then return (a:ls,rs) else return (ls,a:rs)) ([],[])
21:45:53 <lambdabot> forall b (m :: * -> *). (Monad m) => (b -> m Bool) -> [b] -> m ([b], [b])
21:45:57 <Cale> dmwit: With *lots* of type hackery for scanning through such lists, picking out elements and so on.
21:46:09 <dmwit> oh
21:46:17 <dmwit> Maybe I better read the paper after all.
21:46:21 <Gnezdo> I used System.Directory to build find(1) simulation. It takes some 6 lines. Is there a "standard" module implementing this?
21:47:13 <Gnezdo> s/simulation/work-a-like/
21:47:29 <Mr_Awesome> Cale: essentially, i have a rather complex computation that involves lots of lookups in a map, which either return the value in the monad or fail in the monad. before, i just called "error" when the monad failed, and things were very easy. now, id like to preserve that failure, which means i have to rewrite the whole thing to deal with monads
21:47:41 <Cale> Gnezdo: Maybe if you include Hackage.
21:48:05 <Cale> Gnezdo: As far as I know, System.Directory and System.FilePath.* are all you get with GHC.
21:48:55 <Mr_Awesome> any suggestions?
21:48:57 <Cale> Mr_Awesome: By preserve the failure, you mean carry it along as a string or something?
21:49:08 <Cale> (like with the Either String monad?)
21:49:30 <Gnezdo> Cale, yeah, then 6 lines it is. Although I would be interested to see what's out there on hackage, if somebody knows off-hand.
21:49:43 <Mr_Awesome> Cale: yes
21:50:22 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FileManip-0.3.2
21:50:23 <lambdabot> http://tinyurl.com/2v2mv3
21:50:34 <dmwit> Mr_Awesome: If you want behavior like the Either String monad, then may I suggest the Either String monad? =P
21:50:46 <Cale> Mr_Awesome: What I recommend thinking about first, is what the code might look like if you just wanted to write it to use Either directly.
21:50:54 <Cale> Forget about the fact that Either is a monad for a moment.
21:51:27 <Cale> That is, if one of these lookups produces Left e, you're going to immediately return Left e
21:51:35 <Cale> all the way up to the top
21:51:47 <Mr_Awesome> okay, right
21:52:02 <Cale> Basically, that's all that the Either String monad is helping you with :)
21:52:13 <Cale> Left e >>= f = Left e
21:52:19 <Mr_Awesome> i dont see where youre going with this
21:52:21 <Cale> Right x >>= f = f x
21:52:53 <Cale> Well, you might not need to use the monad directly for every piece of your code.
21:53:14 <Cale> But it might help throughout lots of it.
21:53:27 <rapsensee> any haskell guys like solving acm problems?
21:53:29 <BMeph> Gnezdo: Haskell lets you do things with an almost ridiculous ease. You don't have to fight it, just accept it, and live well. ;)
21:54:10 <Cale> http://hackage.haskell.org/packages/archive/FileManip/0.3.2/doc/html/System-FilePath-Find.html#v%3Afind
21:54:11 <lambdabot> http://tinyurl.com/3xbfak
21:54:18 <Mr_Awesome> Cale: if i dont use the monad directly, then what would i do?
21:54:45 <Gnezdo> Cale: awesome, thank you, how did you find it?
21:55:02 <Cale> Gnezdo: looking through http://hackage.haskell.org/packages/archive/pkg-list.html
21:55:20 <Cale> Mr_Awesome: Well, you pattern match with case
21:55:44 <Mr_Awesome> Cale: but thats both more work and less general
21:55:54 <Cale> Mr_Awesome: quite possibly :)
21:56:03 <Gnezdo> Cale: duh. Thanks again.
21:56:42 <Cale> Mr_Awesome: But it might help to think that way in order to see where the monad is helping and where it's getting in the way.
21:57:18 <Mr_Awesome> i mean, monads are allowing me to do the error propagation in a pure way *rather* easily. but its still a pain in the ass because functions like partitionM need to be written by me.  i wish there a were something that automatically rewrote my pure code to deal with the monad
21:57:37 <ddarius> Mr_Awesome: There is.
21:57:48 <Cale> Well, ideally, partitionM would be in Control.Monad
21:57:58 <Cale> Then you wouldn't have to write it.
21:58:31 <Mr_Awesome> true, but my point is that in general there are far fewer std lib monadic functions than pure ones
21:58:49 <Mr_Awesome> and that makes me sad
21:59:20 <Mr_Awesome> ddarius: oh?
21:59:27 <Mr_Awesome> what would that be?
21:59:53 <ddarius> @where hare
21:59:53 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
22:03:57 <Heffalump> Magnus Carlsson also posted some Template Haskell to the mailing list to do it.
22:04:38 <Heffalump> the idea there was for embedding small amounts of monadic code in otherwise pure code
22:05:05 <elaforge> so, if I have a function "f op = op >> op" and give it IO a -> IO a, I can use it with different types for 'a' after binding it with let
22:05:36 <elaforge> but if I pull it from, say, IO with <-, it seems to be monomorphic
22:06:10 <elaforge> e.g. f = return (\op -> op >> op)
22:06:36 <ddarius> @undo do f <- m; return (f x)
22:06:36 <lambdabot> m >>= \ f -> return (f x)
22:06:44 <ddarius> lambda bound variables are always monomorphic
22:07:21 <elaforge> I see, while let-bound stay polymorphic...
22:08:22 <elaforge> I guess there's probably no way since these values eventually go into a single TChan, which is homogenous
22:08:36 <kmcallister> > (\(i :: forall a. a -> a) -> i 3) id
22:08:36 <lambdabot>  Parse error at "." (column 17)
22:10:03 <kmcallister> works in ghci (with appropriate extensions)
22:10:57 <elaforge> is that what you'd call a rank2 type?
22:11:16 <kmcallister> i don't think so
22:11:23 <kmcallister> it's just an ordinary polymorphic type (it's the type of id)
22:11:36 <kmcallister> a rank-n type has a rank-(n-1) type on the left of a function arrow
22:11:53 <kmcallister> whereas that's not "on the left" since it's forall a. (a -> a)
22:11:54 <ddarius> Yes it is a rank-2 type.  The lambda expression has type (forall a. a -> a) -> a -> a
22:12:06 <kmcallister> oh, you mean the type of the whole expression
22:12:07 <kmcallister> yeah
22:12:29 <kmcallister> so where do you put the type annotation if you want to do the same in a do block
22:14:41 <elaforge> I guess I'd want the implicit lambda to have an explicit forall-bearing declaration?
22:15:17 <elaforge> at least tf :: forall a. IO (IO a -> IO a) seems the same as without the forall
22:17:52 <jrx> hi everyone
22:18:53 <jrx> could you tell me, if there's a way how to create a type constructor for newli created type based on some higher order type?
22:19:16 <jrx> there is type like Vector3 a
22:19:19 <ddarius> elaforge: You'd want IO (forall a. IO a -> IO a)
22:19:55 <jrx> when I pass it to the function that has arguments Vector3 a I must specify:
22:20:07 <jrx> f (Vector3 1 0 0 :: Vector3 Float)
22:20:33 <jrx> because otherwise haskell is not able to infer type of vector3 expression
22:20:39 <jrx> how can I make:
22:20:45 <jrx> type VEctor3F = Vector3 Float
22:20:51 <jrx> to write then:
22:21:02 <jrx> f $ Vector3F 1 0 0
22:21:02 <jrx> ?
22:21:31 <ddarius> jrx: You can just write a function vector3F :: Float -> Float -> Float -> Vector3 Float; vector3F = Vector3
22:25:03 <jrx> yep, I can do thak, but I was just curious if I can write a type constructor by myself
22:25:26 <jrx> are type constructors somewhat different to ordinary functions?
22:25:57 <yondalf> jrx: of course you can make a type constructor by yourself
22:26:00 <jrx> i'm not sure if I can pass a type fonstructor to the function like (a -> b) -> c
22:26:23 <yondalf> oh...yes you can
22:26:34 <yondalf> > map Just [1,2,3]
22:26:37 <lambdabot>  [Just 1,Just 2,Just 3]
22:26:45 <jrx> that's good ;)
22:28:01 <jrx> yondalf: can you point me, where  can I find something how to do it?
22:28:19 <yondalf> jrx: what do you want to do?
22:28:57 <yondalf> jrx: by type constructor do you mean things like data Maybe a = Just a | Nothing ?
22:29:22 <Cale> jrx: I'm pretty sure you mena "data constructor"
22:29:25 <Cale> mean*
22:29:28 <jrx> I wanted type constructor for (Vector3 Float) type
22:29:38 <Cale> The type constructor there is Vector3
22:29:59 <Cale> (type constructors construct types)
22:30:22 <jrx> yep, but when I write, Vector3 1 0 0, it doesn't know I want a Vector3 Float, it cannot infer it's type
22:30:35 <jrx> I have wanted a constructor to resolve this ambiguity
22:30:49 <Cale> jrx: I was just making the point that you were confusing type and data constructor
22:31:15 <yondalf> hmm...i was wondering that too, or if jrx had some really advanced use for a type constructor :-)
22:31:16 <Cale> What's the type of Vector3 as a data constructor?
22:31:54 <jrx> probably a -> a -> a -> Vector3 a
22:32:15 <yondalf> maybe what you want is:  myVector3 :: Float -> Float -> Float -> Vector3 Float  \n  myVector3 a b c = Vector3 a b c
22:32:30 <Cale> Well, or just write:
22:32:38 <Cale> Vector3 1 0 0 :: Vector3 Float
22:32:41 <yondalf> but that's not usually the way we do things...we just use type annotations somewhere in the function
22:32:47 <yondalf> uh yeah, like Cale
22:33:04 <jrx> I just thought it wasn't elegant
22:33:22 <jrx> because it doubled the number of characters I had to write
22:33:34 <jrx> but if that's ok, I'll stay like this
22:33:54 <yondalf> jrx: can you paste an example of the code where the type isn't inferred?
22:33:59 <ddarius> jrx: It's your code.  You can write it however you like.
22:34:18 <yondalf> jrx: or write Vector3 (1 :: Float) 0 0
22:35:31 <Cale> jrx: Or you could ensure that the type of the function which that point is being returned from is Vector3 Float
22:37:00 <hpaste>  jrx pasted "(no title)" at http://hpaste.org/5727
22:37:10 <jrx> http://hpaste.org/5727
22:37:23 <jrx> it's there
22:37:28 <jrx> the vertex call
22:38:48 <yondalf> ah...the hopengl library might have some return type trickery :-P
22:39:36 <yondalf> okay, i see why you need the type annotation and i can't think of a way that you can get rid of it
22:39:51 <yondalf> but annotating just one number should work though  Vertex3 (1 :: Float) 0 0
22:42:14 <jfredett> you know what I love, when you go from using lists to using sets in an algorithm, and you get a giant speed jump
22:42:26 <dons> hehe
22:42:30 <dons> yeah, i love that too, jfredett
22:42:55 <jfredett> i'm just reading over the Set speed, it has "split" which is O(log n),
22:43:10 <jfredett> in my algo, I have a couple of "partition" calls.
22:43:30 <jfredett> but it's just a partition (==200)
22:44:11 <jfredett> and I just sighed and said, "Haskell freaking rocks."
22:44:16 <dons> hehe
22:44:35 <ddarius> "Haskell phreaking PBXs"
22:44:57 <jfredett> and size is O(1), apparently
22:45:13 <jfredett> which saves me about three calls to O(n) length
22:45:21 <ddarius> It's stored per node.
22:45:31 <jfredett> i love it
22:45:57 <jfredett> i'm just waiting for the current incarnation to finish running
22:46:09 <jfredett> it's taken about 40 minutes so far
22:52:23 <OceanSpray> So, is the dude who wrote Liskell in this channel?
22:53:18 <ddarius> Sometimes
22:57:15 <OceanSpray> Clean, that other non-strict functional language, doesn't do automatic currying, does it?
22:57:35 <ddarius> Haskell doesn't do automatic currying.
22:57:58 <OceanSpray> ddarius, you know what I mean.
22:58:29 <ddarius> Clean is just like Haskell in that regard.
22:58:35 <OceanSpray> oy.
22:58:45 <OceanSpray> is that a REQUIREMENT for such types of languages, then?
22:58:52 <ddarius> No.
22:58:58 <masklinn> no, it's just useful
22:59:03 <OceanSpray> But it's convenient, yes.
22:59:12 <OceanSpray> I was just wondering, is all.
23:00:06 <ddarius> Clean has a mildly bizarre type annotation for "multi-argument" functions.
23:01:03 <dons> oh, the a b c -> d thing?
23:01:26 <ddarius> Yeah.  It has some import performance-wise, but otherwise ..
23:01:42 <dons> oh, it's more than just syntax?
23:02:03 <OceanSpray> When I first saw that, I thought it was different from Haskell's a -> b -> c -> d
23:02:31 <ddarius> dons: Yes.  Clean cleaves closer the the graph-reducing implementation than Haskell.  That syntax puts them all in the same application node or some such where a more Haskell-like notation would create multiple application nodes.
23:02:56 <dons> huh, interesting.
23:03:52 <ddarius> The problem, of course, is that it conflicts badly with type constructor application.
23:12:03 <RayNbow> hmm... is there any good material on how Prelude.catch and Control.Exception.catch both are able to catch IOErrors?
23:12:37 <ddarius> RayNbow: I don't understand your question.
23:13:06 <dons> RayNbow: the main paper is 'Tackling the Awkward Squad' but the haddocks should be suitable
23:13:11 <dons> Control.Exception is well documented
23:16:39 <RayNbow> well, my confusion is probably caused by the following text in the docs: "Every kind of system-generated exception has a constructor in the Exception type, and values of other types may be injected into Exception by coercing them to Dynamic (see the section on Dynamic Exceptions: Control.Exception#DynamicExceptions)."
23:17:01 <RayNbow> is that Dynamic stuff covered in the Awkward Squad paper?
23:18:47 <dons> oh, dynamic exceptions. there's a separate paper on that. but the docs should be fine
23:18:59 <dons> you can throw any Dynamic, basically
23:19:14 <dolio> > toDyn (5 :: Int)
23:19:17 <lambdabot>  <<Int>>
23:20:00 <ddarius> Hmm...
23:20:03 <ddarius> > fix toDyn
23:20:04 <lambdabot>  <<Dynamic>>
23:20:24 <wagle_home> :t toDyn
23:20:25 <lambdabot> forall a. (Typeable a) => a -> Dynamic
23:20:46 <ddarius> fix toDyn is kind of interesting
23:20:51 <wagle_home> @src toDyn
23:20:51 <lambdabot> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
23:21:12 <dolio> Huh, interesting.
23:21:35 <ddarius> There are safer ways of implementing Dynamics, but that way is almost certainly the simplest and most efficient.
23:21:49 <ddarius> (And by "safer", I mean "safe")
23:23:41 <RayNbow> > throwDyn $ toDyn 5
23:23:42 <lambdabot>   Not in scope: `throwDyn'
23:24:02 <RayNbow> > Control.Exception.throwDyn $ toDyn 5
23:24:03 <lambdabot>   Not in scope: `Control.Exception.throwDyn'
23:24:11 <ddarius> :t throwDyn
23:24:12 <lambdabot> Not in scope: `throwDyn'
23:24:15 * RayNbow opens ghci
23:24:21 <ddarius> :t Control.Exception.throwDyn
23:24:22 <lambdabot> forall exception b. (Typeable exception) => exception -> b
23:24:30 <wagle_home> @index throwDyn
23:24:30 <lambdabot> Control.Exception
23:24:40 <wagle_home> bah
23:25:12 <dolio> > Control.Exception.throwDyn (6 :: Int)
23:25:12 <lambdabot>   Not in scope: `Control.Exception.throwDyn'
23:30:14 <wagle_home> @src throwDyn
23:30:14 <lambdabot> Source not found.
23:30:40 <wagle_home> @src  Control.Exception.throwDyn
23:30:40 <lambdabot> Source not found. You speak an infinite deal of nothing
23:35:46 <ac> @hoogle newTVar
23:35:46 <lambdabot> GHC.Conc.newTVar :: a -> STM (TVar a)
23:35:46 <lambdabot> GHC.Conc.newTVarIO :: a -> IO (TVar a)
23:36:14 <ac> :t newTVar
23:36:14 <lambdabot> Not in scope: `newTVar'
23:36:23 <ac> :t GHC.Conc.newTVar
23:36:23 <lambdabot> forall a. a -> GHC.Conc.STM (GHC.Conc.TVar a)
23:38:58 <OceanSpray> @index mp3
23:38:59 <lambdabot> bzzt
23:39:36 <dons> haven't seen that error for a while
23:42:05 <ac> @hoogle empty
23:42:05 <lambdabot> Control.Applicative.empty :: Alternative f => f a
23:42:05 <lambdabot> Data.ByteString.empty :: ByteString
23:42:05 <lambdabot> Data.Set.empty :: Set a
23:43:06 <wagle_home> @hoogle throwDyn
23:43:06 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
23:43:06 <lambdabot> Control.Exception.throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
23:44:48 <wagle_home> @hoogle Typeable
23:44:48 <lambdabot> Data.Typeable :: module
23:44:48 <lambdabot> Data.Typeable.Typeable :: class Typeable a
23:44:48 <lambdabot> Data.Typeable.Typeable1 :: class Typeable1 t
23:45:01 <wagle_home> @src Typeable
23:45:01 <lambdabot> Source not found. Where did you learn to type?
23:45:16 <wagle_home> @src Data.Typeable.Typeable
23:45:16 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:45:28 <ac> what does newTVar do?
23:45:39 <ddarius> ac: The same thing newIORef or newMVar does.
23:46:10 <ac> ah ok. I just read the docs ;)
