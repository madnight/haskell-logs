00:01:26 <adu> ok
00:01:31 <adu> that helps alot
00:02:21 <b_jonas> dunno,
00:02:29 <b_jonas> I'm not really in it
00:07:07 <gour> @seen ndm
00:07:07 <lambdabot> I haven't seen ndm.
00:07:32 <Twey> Who is this ndm and why do people keep asking for him/her?
00:18:47 <johnnowak> @protontorpedo
00:18:48 <lambdabot> syntax ur runing my high
00:19:40 <ari> jbauman_: You're on a host named Multivac whose name is written in all-uppercase? Would you happen to be a time traveler from 1970 by any chance? ;)
00:31:18 <Cale> ari: I don't think he can read your fancy schmancy lowercase letters.
00:31:29 <Cale> ;)
00:31:42 <osfameron> ale: damn right
00:42:34 <dmwit> ?remember osfameron <Cale> I don't think he can read your fancy schmancy lowercase letters. <osfameron> ale: damn right
00:42:34 <lambdabot> Done.
00:42:55 <dmwit> Oh... but the joke is backwards.
00:42:57 <dmwit> Oh well.
00:43:05 <osfameron> yeah, I only realised afterwards too :-)
00:43:17 <osfameron> as long as you don't think about it too hard...
00:43:24 <dmwit> I laughed. =)d
00:43:27 <dmwit> ...
00:43:34 <dmwit> s/d$//
00:49:59 <vincenz> dons: http://fhtr.blogspot.com/2008/02/simple-unix-tools-in-ocaml.html
00:49:59 <lambdabot> Title: FHTR: Simple UNIX tools in OCaml
00:50:20 <lispy> vincenz: he posted that today too
00:50:23 <dmwit> He's already commented on the proggit entry pointing there. ;-)
00:50:37 <vincenz> dons: not as clean and cute as your unix tools
00:50:40 <vincenz> these are butt-ugly
00:50:51 <dmwit> http://reddit.com/r/programming/info/68g3o/comments
00:50:54 <lispy> yeah, he said the same thing, then commented on them being lower level
00:51:11 <lispy> vincenz: c'mon, get with the program ;)
00:52:10 <vincenz> lispy: I stopped reading reddit
00:53:07 <dmwit> dons has got some serious Haskell-marketing-fu.
00:53:24 <vincenz> dons should wear a lambda-tie
00:53:29 <osfameron> what's with the:  let () =   stuff?
00:53:49 <vincenz> osfameron: poor substitute for >>
00:54:13 <osfameron> ah, so "throw away these values" ?
00:54:57 <vincenz> throw the unit value returned by this thing away
01:22:14 <dmwit> ?index TestableProperty
01:22:14 <lambdabot> bzzt
01:23:09 <Twey> Haha
01:23:10 <Cale> osfameron: () in O'Caml is rather like our IO (), but without the monad.
01:23:27 <Twey> OCaml has no monads?
01:23:38 <Cale> You can implement monads, but it doesn't use them for IO.
01:23:43 <Twey> How do they do IO?  Do they break purity?
01:23:47 <Cale> Yeah.
01:23:52 <Twey> Ah
01:24:02 <Cale> In a strict language, you can get away with that more easily.
01:24:05 <dmwit> OCaml is eager, too, right?
01:24:08 <dmwit> yeah
01:24:08 <Cale> yeah
01:25:21 <tcr> Is there something like wordsBy?
01:25:29 <dmwit> No. =/
01:28:24 <dmwit> My head a splode.
01:28:34 <Cale> tcr: I think we can generally agree that there should be. Someone should submit a proposal to add it to Data.List, along with an implementation to the libraries mailing list. Of course, Bulat will complain that the base libraries change too much, but he always does.
01:29:01 <Cale> :)
01:29:07 <dmwit> Surely adding to the libraries hardly breaks anything.
01:29:51 <Cale> Right.
01:30:15 <Cale> But he seems to enjoy complaining about simple additions of things which must be in everyone's personal library by now.
01:33:13 <Twey> Heh
01:34:45 <povman> does anyone know how to use Type in template haskell?
01:35:16 <povman> i can't work out how to $() a Type
01:38:11 <dmwit> Whoa, RunTimeCompilation... sounds nasty.  And it's old enough that it's a reference to the old wiki, so it must not have been using the GHC API...
01:39:47 <Twey> dmwit, ?
01:40:14 <dmwit> Twey: I'm reading the wiki page on Tying the Knot, and it has a lot of references to the old hawiki.
01:40:26 <Twey> Ah
01:40:29 <Twey> Heh
01:41:40 <Twey> "(Note: We're only optimising state lookup here, not deciding which transition to take. As an exercise, consider how you might optimise transitions. You may wish to use RunTimeCompilation.)"
01:41:44 * Twey shudders.
01:42:01 <Twey> "Note how similar this is to the technique of MemoisingCafs."
01:42:03 <Twey> :-\
01:42:16 <Twey> What is a caf?  And how would I memoise one?
01:42:17 <Cale> povman: hmm... I think perhaps you have to do the whole type declaration.
01:42:39 <Cale> povman: But I don't know Template Haskell all that well.
01:42:44 <dmwit> Twey: Caf is an old term for top-level definition, I think, but I can't remember what it stood for.
01:42:59 <Twey> Heh
01:43:00 <povman> Cale: I've tried type X = $(myThing)
01:43:04 <Twey> It's like reading Old English
01:43:14 <dmwit> yeah =P
01:43:43 <Twey> And "HashConsing" which sounds a lot less scary but still a little illogical
01:44:14 <dmwit> I remember visiting all these pages back when hawiki existed, but I can't remember what they are now.
01:44:39 <Twey> "For illustration, we will consider the problem of printing out a non-deterministic finite automaton (NFA) and transforming it into a deterministic finite automaton (DFA). Both NFA and DFA are represented as cyclic graphs."
01:44:46 <eivuokko> Twey, Constant Applicative Form.  Basically a global constant as far as I understand.
01:44:49 <Twey> I'll stop reading now in case I get nightmares.
01:45:11 <dmwit> "Use any dictionary data structure (e.g. FiniteMap)." -- heh
01:45:17 <eivuokko> global is probably wrong word there...
01:45:22 <Twey> Heh
01:46:16 <povman> Cale: I'm being silly, I need to be using splice () to define data types
01:46:52 <Cale> povman: You might just be able to write  $(myThing ...)
01:47:15 <dmwit> 0*(0(0+1)*)*
01:47:17 <Cale> Where 'myThing' incorporates the construction of the type declaration, and takes parameters for what it should be named.
01:47:29 <dmwit> Wouldn't this be easier to write as 0(0+1)*  ?
01:48:09 <mauke> ""
01:49:15 <dmwit> Oh, no.
01:50:20 <Cale> The 0* out front might get absorbed at least.
01:50:22 <dmwit> 0(0+1)*+\epsilon
01:50:27 <dmwit> yeah
01:51:12 <dmwit> Now I understand mauke's comment. =P
01:52:04 <Cale> hehe
01:56:16 <povman> myNewType name = [d| type $(name) = Int |] -- gives parse error on input `$('
01:56:20 <Cale> 1/(1-x) 1/(1-(x (1/(1-x+y)))))
01:56:23 <Cale> er
01:56:37 <Cale> 1/(1-x) 1/(1-(x (1/(1-x-y)))))
01:56:40 <Cale> yeah :)
01:59:20 * dcoutts_ heads off to the Haskell Fun in the Afternoon in London
01:59:23 <dcoutts_> weee!
01:59:42 <Twey> Huuuuh
01:59:46 <Twey> Nobody told me about this :-(
01:59:54 <Twey> Where is it?
01:59:57 <dcoutts_> where there will be much plotting for world domination!
02:00:00 <Twey> Haha
02:00:06 <dcoutts_> oops, I wasn't supposed to mention that bit
02:00:21 <Twey> "The same thing we do every convention, Pinky..."
02:00:30 <dcoutts_> mwahahaha
02:00:45 <dcoutts_> @where FitA
02:00:45 <lambdabot> I know nothing about fita.
02:00:49 <dcoutts_> bah
02:00:55 * Twey wonders if he could get there in time.
02:01:01 <Vq^> s/Pinky/Simon/
02:01:03 <dcoutts_> @where+ FitA http://sneezy.cs.nott.ac.uk/fun/
02:01:03 <lambdabot> Done.
02:01:09 <Twey> Heh
02:01:59 <Twey> There's a curry too
02:02:06 <dmwit> "Fun starts at noon, which is also when the afternoon starts."
02:02:09 <dmwit> pretty funng
02:02:13 <Twey> Heh
02:02:32 * Twey doesn't reckon he can get there on time even if he rushes.
02:02:40 * Twey will wait for the next one.
02:03:14 <dmwit> Curry... but they actually mean the Indian stuff.
02:03:54 <Cale> Mmmm, curry. Wish I could go.
02:04:29 <shag> @pl (\nv -> insert k nv t)
02:04:29 <lambdabot> flip (insert k) t
02:05:22 <dmwit> ?pl \k -> insert k nv t -- let's see... flip (flip insert nv) t?
02:05:22 <lambdabot> flip (flip insert nv) t
02:06:10 <dmwit> That "Richard Bird's Fan Club" talk sounds like fun.
02:06:15 * wagle_home proposes a new style: flip'less programming
02:06:36 * Twey likes pointless.
02:06:54 <dmwit> (`insert` nv) -- but how do you do the next part?
02:06:57 <gogonkt> hi all
02:07:00 <dmwit> oh
02:07:01 <wagle_home> has more flips than lisp has parentheses..  8)
02:07:07 <dmwit> (`insert` nv t) -- nice!
02:07:23 <shag> i like flip
02:07:29 <mauke> :t ap (ap ?insert (const ?nv)) (const ?t)
02:07:30 <gogonkt> Happy chinese new year~~!
02:07:31 <lambdabot> forall b a b1 a1. (?t::a1, ?nv::a, ?insert::b1 -> a -> a1 -> b) => b1 -> b
02:07:40 <dmwit> wait, no, that doesn't work
02:07:57 <dmwit> gogonkt: Hiya!
02:08:08 <dmwit> gogonkt: And, aren't you a bit late for the Chinese new year?
02:08:09 <gogonkt> dmwit, ^_^
02:09:00 <dmwit> :t ap
02:09:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:09:09 <gogonkt> haha,a little busy these days
02:09:34 <mauke> S (S insert (K nv)) (K t)
02:09:35 <dmwit> ?unpl ap (ap insert (const nv)) (const t)
02:09:36 <lambdabot> ((insert >>= \ j -> (\ _ -> nv) >>= \ i -> return (j i)) >>= \ d -> (\ _ -> t) >>= \ c -> return (d c))
02:09:51 <dmwit> aaaaaa!
02:10:08 <Twey> Hahahaha.
02:10:09 <mauke> ?. pl unpl ap (ap insert (const nv)) (const t)
02:10:10 <lambdabot> insert >>= (const nv >>=) . (return .) >>= (const t >>=) . (return .)
02:10:15 <Twey> There are, of course, always extremes.
02:10:36 <Twey> Actually, that probably wouldn't look nearly as scary in do notations.
02:10:39 <wagle_home> but completely flipless!  woo hoo!
02:10:40 <gogonkt> Who can tell me Howto put utf-8 char to stdout? That's not work in source code :(
02:10:45 <Twey> notations?  Notation
02:11:15 <Twey> gogonkt: You need to get the utf8-string module
02:11:18 <dmwit> gogonkt: Specifically UTF-8, or just some encoding of Unicode?
02:11:37 <gogonkt> Can you point any document or example?
02:12:51 <povman> > myNewType name = runIO $ return [TySynD (mkName name) [] (ConT (mkName "Int"))]
02:12:52 <lambdabot>  Parse error at "=" (column 16)
02:12:58 <povman> lambdabot: sif
02:13:07 <povman> anyway that worked
02:13:09 <gogonkt> utf8-string?I will try it later,I spended all night for iconv :(
02:13:21 <Cin> gogonkt: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.2
02:13:22 <lambdabot> http://tinyurl.com/2e6gmt
02:13:29 <Cin> gogonkt: under "Exposed Modules", those two links are documentation
02:13:50 <povman> the syntax is nowhere near as nice as i would have liked: myNewType name = [d| type $(name) = Int |]
02:14:10 <Cin> gogonkt: it's very easy. encodeString :: String -> String. i had to use it recently to print out Î» (lambdas)
02:14:47 <dmwit> > let myNewType name = runIO $ return [TySynD (mkName name) [] (ConT (mkName "Int"))] in myNewType "hey"
02:14:49 <lambdabot>   Not in scope: `mkName'
02:15:11 <povman> dmwit: oh lol
02:15:15 <Cin> anyone know anything about getting GHCi to read strings in as UTF8? (other than changing the source and recompiling)
02:15:22 <povman> it needs Language.Haskell.TH
02:15:29 <dmwit> yep =)
02:15:50 <dmwit> Cin: I would look for a decodeString myself. ;-)
02:16:11 <wagle_home> "\1578"
02:16:16 <mauke> encodeString should be :: String -> [Word8] :(
02:16:25 <wagle_home> ok, it doesnt work by default
02:16:28 <wagle_home> 8)
02:16:31 <Cin> mauke: that's just `encode'
02:16:43 <dmwit> wagle_home: Try putStrLn instead of print.
02:16:50 <Cin> mauke: http://hackage.haskell.org/packages/archive/utf8-string/0.2/doc/html/Codec-Binary-UTF8-String.html
02:16:51 <lambdabot> http://tinyurl.com/24vsn3
02:17:16 <Cin> dmwit: the issue is actually GHCi itself. when i input a lambda, for instance, i get an error
02:17:18 <mauke> haha, awesome
02:17:41 <mauke> I'm installing this right now
02:18:05 <wagle_home> *
02:18:19 <gogonkt> I write a ircbot,it worked well in utf8 channel,but can't put utf8 char in source.haha
02:18:33 <dmwit> gogonkt: Oh, update to GHC 6.8.
02:18:43 <Cin> hpaste: url
02:18:43 <hpaste> Haskell paste bin: http://hpaste.org/
02:19:05 <hpaste>  Cin pasted "ghci error" at http://hpaste.org/5612
02:19:06 <wagle_home> i'm running 6.8.2 ghci on linux x86_64
02:19:25 <Cin> dmwit: see what i mean?
02:19:36 <dmwit> Cin: ghc --version ?
02:19:50 <gogonkt> ghc-6.8.2: no input files
02:19:51 <gogonkt> Usage: For basic information, try the `--help' option.
02:19:55 <dmwit> (You need 6.8 for Unicode in the source, I think.)
02:20:00 <Cin> dmwit: 6.8.2
02:20:06 * dmwit blinks
02:20:08 <Cin> dmwit: yeah, unicode in the source works
02:20:16 <gogonkt> it's 6.8.2
02:20:27 <mauke> error messages are borken, though
02:20:32 <povman> is anyone actually working on TH? there seems to be a lot of useful syntax missing
02:20:49 <mauke> Prelude> Ã¤
02:20:49 <gogonkt> dinner,mama is calling me,see you later~~
02:20:49 <mauke> <interactive>:1:0: Not in scope: `ï¿½'
02:20:53 <Cin> dmwit: can you do let foo = "Î»" on yours?
02:21:01 <Cale> povman: Really actively? Not that I'm aware of.
02:21:02 <dmwit> Cin: I have 6.6.
02:21:35 <Cin> mauke: my behaviour is odd:
02:21:35 <Cin> Prelude> Ã¤
02:21:36 <Cin> Prelude>
02:21:45 <Cin> doesn't even say anything
02:21:50 <povman> I may have to become that person
02:21:51 <mauke> Prelude> let Ã¤ = 2 in Ã¤
02:21:51 <mauke> 2
02:22:10 <Cale> povman: What are you using TH to do?
02:22:20 <Cin> Prelude> let Ã¤ = 2 in Ã¤
02:22:20 <Cin> <interactive>:1:5: parse error on input `='
02:22:21 <gogonkt> *Main> s
02:22:21 <gogonkt> "195169l195169mentaire"
02:22:21 <gogonkt> *Main> s' <- readFile "test.hs"
02:22:21 <gogonkt> "s = \"\228\189\160\229\165\189mentaire\"\n"
02:22:32 <Cin> hrm
02:22:39 <gogonkt> I try this early
02:23:04 <povman> Cale: (not necessarily, but it might be fun) - I want to generate data types from higher level models
02:23:32 <dmwit> gogonkt: It looks like it worked to me, what's wrong?
02:25:19 <Cin> mauke: what's your ghci version?
02:25:43 <mauke> GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
02:25:44 <lambdabot> Title: The Glasgow Haskell Compiler
02:26:05 <povman> Cale: like $(myMkType ("Blah", [("name", "Integer"), ("colour", "String")])) --> data Blah = Blah { name :: Integer, colour :: String } -- as a really basic example
02:26:09 <dmwit> gogonkt: Have a try at "putStrLn s", you might get a pleasant surprise. =)
02:26:58 <Cale> povman: ah, okay
02:27:24 <Cale> povman: I know that TH has been used to do things like that.
02:27:27 <mauke> Cin: my LANG is en_US.UTF-8
02:27:27 <Cin> might actually be that i'm using it from emacs. hang o
02:27:38 <Cin> mauke: yeah, i'll check that now
02:27:57 <Cale> povman: You might have to avoid the quoting mechanisms for the most part though, and generate syntax directly.
02:28:22 <Cale> (See Language.Haskell.TH.Syntax for how to do that)
02:29:42 <Cin> what on earth? encodings confuse me
02:30:22 <Cin> mauke: i can paste your "let Ã¤ = 2 in Ã¤" into my terminal, and all is well, but when i start ghci and paste it into that, it removes the Ã¤'s and displays wrongly
02:30:30 <Cin> mauke: do you have any idea why it would do that/
02:31:10 <hpaste>  Cin annotated "ghci error" with "hrm?" at http://hpaste.org/5612#a1
02:31:19 <wagle_home> i was wondering if my terminal emulator was getting in the way
02:31:59 <mauke> Cin: are any LC_ variables set?
02:32:19 <mauke> wait, shouldn't make any difference
02:33:18 <povman> Cale: certainly, but that doesn't mean the syntax couldn't do with some work
02:35:00 <Cin> mauke: the annoying thing is that it prints out the lambdas just fine.
02:35:09 <Cin> *Lambda> (Ab "x" (V "x"))
02:35:09 <Cin> Loading package utf8-string-0.2 ... linking ... done.
02:35:09 <Cin> Î»x.x
02:35:53 <vincenz> Cin: tie that in with my typechecker :)
02:36:08 <Cin> vincenz: oh lawd :P
02:36:28 <Cin> vincenz: link?
02:37:12 <Cin> hrm
02:38:04 <vincenz> http://notvincenz.blogspot.com/2008/01/using-typechecker-monad-to-type-check.html
02:38:05 <lambdabot> Title: lambda.oasis: TypeChecking Lambda Calculus using TyperMonad (courtesy of Saizan), http://tinyurl.com/3ds6be
02:39:15 <kib> Hi, is the last row of the first table (6.1) ok here : http://book.realworldhaskell.org/beta/io.html ?
02:39:16 <lambdabot> Title: ChapterÂ 6.Â I/O
02:39:59 <Cin> vincenz: it could work!
02:41:12 <Cin> vincenz: Lambda "f" (Lambda "a" (Lambda "x" (App (App (Var "f") (Var "x")) (Var "a"))))
02:41:51 <Cin> vincenz: this is why i'm looking into reading utf8. so i can just write an instance of Read and write "> read "Î»a.Î»x.(f x) a"
02:42:08 <vincenz> just use a simple reader
02:42:17 <vincenz> \x.\y.(x y)
02:42:37 <byorgey> kib: no, it's the wrong way around
02:42:46 <Cin> vincenz: doesn't look as cool. but do you know of an existing reader to do that?
02:43:28 <vincenz> probably  googlable or trivial t write
02:43:34 <kib> byorgey : thanks.
02:43:49 <Cin> vincenz: heh, i tried to write one with parsec and failed. D:
02:47:08 <Cin> vincenz: i'm going to try again, of course (i needed sleep at the time). read "\\x.\\y.(x y)" is kind of annoying but i guess it is better than (Ab "x" (Ab "y" etc
02:47:58 <vincenz> _x
02:48:02 <vincenz> _x._y.
02:48:04 <dmwit> read "^x.^y.(x y)"
02:48:10 <vincenz> |x.|y
02:48:19 <dmwit> Any ol' terminal, really.
02:48:38 <dmwit> (But '^' has the advantage that it was Church's original character. =)
02:49:24 <Cin> dmwit: it was? hrm =0
02:50:29 <Cin> btw, does (x y) => (x y)?
02:51:13 <Cin> it's untyped so i don't suppose you could say "x isn't a function, blargh!"
02:52:15 <vincenz> Cin: you cacn't' say that in a typed language either
02:52:31 <Cin> meh
02:52:46 <vincenz> 'a' is unifiable with 'b -> 'c
02:53:40 <dmwit> Hey!
03:14:27 <shag> is there something like a downcast for a type variable possible?
03:14:46 <Corun> > map toLower "thIS LeCTure is BORing"
03:14:56 <lambdabot>  "this lecture is boring"
03:15:29 <Corun> I can already implement a linked list :-(
03:16:02 <Lemmih> shag: Data.Typeable.cast
03:16:23 <mauke> shag: what do you mean by "down"?
03:17:02 <shag> well, i have a function like this: foo :: MyClass c => c -> a
03:17:13 <shag> and i want to match an instance of that class like this:
03:17:24 <shag> foo (MyInstance f) = ...
03:17:29 <mauke> no.
03:17:41 <shag> but i assume that this is not really good style.
03:17:48 <mauke> it's not possible
03:18:54 <Lemmih> shag: Why do you want that?
03:19:21 <shag> lemmih: because my types are probably poorly designed ;)
03:20:11 <shag> Lemmih: no, i want to generate some debugging output and therfore need the exact type instead of the interface because i want to omit adding sth like "outputDebuggingInfrormation" to the interface
03:21:20 <Lemmih> I still don't understand.
03:21:23 <shag> omit=avoid
03:22:38 <shag> at some point in my program i get some input data but i only know that it is an instance of class foo. now i want to output debugging info at that point if the data is of type foobar.
03:22:44 <Lemmih> shag: I think Data.Typeable.cast can do what you want.
03:23:01 <shag> yes, looks like that. thanks
03:23:46 <Lemmih> > let showBool x = case cast x of Nothing -> "Not a bool"; Just b -> show (b::Bool) in (showBool (), showBool False)
03:23:46 <lambdabot>  ("Not a bool","False")
03:26:03 <mauke> > (typeOf (), typeOf False)
03:26:04 <lambdabot>  ((),Bool)
03:27:19 <mauke> > typeOf ((), False)
03:27:22 <lambdabot>  ((),Bool)
03:31:46 <opqdonut> :t typeOf
03:31:59 <lambdabot> forall a. (Typeable a) => a -> TypeRep
03:32:21 <integral> not (TypeRep a)?
03:33:58 <mauke> no, of course not
03:34:11 <mauke> otherwise you couldn't do things like typeOf () == typeOf False
03:34:17 <mauke> > typeOf () == typeOf False
03:34:19 <lambdabot>  False
03:35:26 <Twey> What is () called in Haskell?  Null?
03:36:04 <Cale> The unit type? Empty tuple?
03:36:27 <mauke> .oO( nuple )
03:36:30 <Twey> Haha
03:36:45 <Twey> Hmm.
03:37:06 <Twey> Cale: Were those just suggestions, or names that are actually used?
03:37:27 <Cale> They're actually used.
03:37:50 <Twey> Ah, thanks
03:37:59 <opqdonut> unit is the most common term afaik
03:38:07 <Twey> Oh, yes, because it's both a type and a value, isn't it?
03:38:20 <Cale> right
03:38:52 <Cale> I rather like "empty tuple" or "null tuple", but that's just me :)
03:39:24 <meryrus> How do you test for ()?
03:39:32 <Cale> meryrus: You don't.
03:39:36 <opqdonut> you don't test
03:39:42 <meryrus> :t ()
03:39:43 <opqdonut> the type system tells you it's there
03:39:45 <lambdabot> ()
03:39:47 <meryrus> Ahe
03:39:47 <Cale> There's only one non-bottom value of type (), and it's ()
03:39:49 <meryrus> *Ah.
03:39:56 <moonlite> > let 2 * 3 = 7 in 2 * 3
03:39:57 <lambdabot>  7
03:40:01 <moonlite> magic! :)
03:40:10 <Cale> So if the type is (), then you either have (), or the computation doesn't finish.
03:40:20 <meryrus> As usual, I asked the wrong question :D
03:44:54 <tcr> Is there a predefined way to compare string case-insensitively?
03:45:24 <mauke> lc a == lc b
03:45:28 <mauke> where lc = map toLower
03:45:50 <tcr> Right, that's not what I'd meant with predefined, though. :)
03:55:22 <nayru> hello. are there any good matrix libs for haskell?
04:00:47 <Cale> nayru: Well, depends on exactly what it is that you're looking for. There's: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix-0.2.0.0
04:00:49 <lambdabot> http://tinyurl.com/2d4eyp
04:01:19 <vininim> :t typeOf fail
04:01:22 <lambdabot>     Ambiguous type variable `m' in the constraints:
04:01:22 <lambdabot>       `Typeable1 m'
04:01:22 <lambdabot>         arising from a use of `typeOf' at <interactive>:1:0-10
04:01:27 <vininim> > typeOf fail
04:01:28 <lambdabot>  Add a type signature
04:01:59 <Cale> (which is actually pretty thorough, but some of the modules look like they could use a little extra Haskellisation :)
04:03:58 <nayru> Cale: thank you
04:09:30 <nayru> does haskell come with hmatrix?
04:09:59 <Lemmih> nayru: No, GHC doesn't ship with hmatrix.
04:10:21 <nayru> okay
04:10:30 <nayru> i just need to transpose some stuff
04:10:53 <Lemmih> > transpose [[1,2],[3,4]]
04:10:54 <lambdabot>  [[1,3],[2,4]]
04:11:42 <nayru> ah, thanks
04:18:24 <nayru> Lemmih: where do i find transpose?
04:18:27 <FunctorSalad> hai. is there some particular reason why we don't have the docs of all known packages in hoogle?
04:18:31 <Lemmih> nayru: Data.List
04:18:54 <ski> @index transpose
04:18:54 <lambdabot> Data.List
04:22:12 <ski> (Twey : i'd not say that `()' is both a type and a value, there's one value written like that, and one type that also happens to be written like that, and those are two separate concepts .. and i think i would prefer if they were written differently)
04:23:15 <mauke> () : unit
04:23:56 <ski> mauke : indeed :)
04:24:26 <FunctorSalad> @type ()
04:24:29 <lambdabot> ()
04:24:45 <FunctorSalad> oh, thought it might be called "unit"
04:25:42 <yondalf> well, people pronounce () as unit i think
04:28:24 <JohnMeacham> would patches to Text.Printf making it extensible (without breaking backwards compatability) be appreciated?
04:29:45 <yondalf> as a printf user, i'm curious :-) do you have them online anywhere?
04:30:34 <FunctorSalad> as in new format characters?
04:31:50 <FunctorSalad> but yeah, I like printf too. print ("foo = "++(show foo)) is ugly...
04:32:03 <JohnMeacham> yeah. and more types.
04:32:44 <yondalf> hmm...right now i only use the %s option in printf for string interpolation :-)
04:35:51 <FunctorSalad> > printf "%.5f" (exp 1) :: String -- this one is handy too
04:35:52 <lambdabot>  "2.71828"
04:41:50 <nayru> is there a way to multiply matrices without using a matrix library? i am using lists of lists
04:42:22 <nayru> i know the manual approach, just wondering if there's some easy way... i already used Data.List.transpose
04:42:50 <yondalf> @src zipWith
04:42:50 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
04:42:50 <lambdabot> zipWith _ _      _      = []
04:43:05 <yondalf> nayru: zipWith can help you with the dot product step
04:43:21 <Twey> :t unsafeCoerce
04:43:22 <lambdabot> Not in scope: `unsafeCoerce'
04:43:32 <mauke> (sum .) . zipWith (*)
04:43:49 <nayru> ah, hmm
04:44:31 <nayru> brb
04:49:09 <sioraiocht> anyone know when google summer of code stuff comes 'round again
04:49:23 <mux> this summer I guess? :-P
04:49:54 <sioraiocht> no shit? I meant mentoring applications =p
04:49:58 <sioraiocht> they come out far earlier
04:50:09 <mux> something like 2 months earlier IIRC
04:50:45 <kfish> sioraiocht, in a few weeks (shhh!)
04:51:23 <sioraiocht> kfish: cheers.  I don'tk now much about the mentoring side of things, but i'd lke to do that this year as I cannot do a whole project this summer while writing my dissertation
04:52:15 <mux> there's not much to the mentoring side of GSoC
04:52:25 <mux> you get to use some google web app to rank proposals
04:52:36 <mux> and then of course ou are supposed to guide your mentee, but that's about all there is to it
04:53:09 <sioraiocht> I like guiding mentees, heh
04:53:17 <mux> if you're wondering, I've been mentoring FreeBSD projects for the first google SoC
04:53:36 <sioraiocht> oh cool
04:57:56 <faxathisia> What does "squiggolist" mean?
04:58:37 <opqdonut> someone who enjoys or practices in squiggolism
04:59:00 <faxathisia> hehe..
05:00:06 <faxathisia> I think it's something to do with algebraic datatypes..
05:00:31 <scook0> squiggol was some kind of language, or software, or something
05:00:33 <scook0> I think
05:00:33 <doserj> it has more to do with lenses, barbs and wires
05:01:01 <scook0> @google squiggol
05:01:03 <lambdabot> http://en.wikipedia.org/wiki/Bird-Meertens_Formalism
05:01:35 <mux> doserj: what about bananas?
05:01:52 <faxathisia> ah.. so squiggolist is one who uses this calculus to derive programs
05:02:32 <mux> so they actually made a programming language out of this
05:02:55 <mux> I remember trying to read their paper, but it mostly hurt my head; it was too category theory oriented for me
05:03:00 <litb> howdy :)
05:03:21 <faxathisia> http://www.basis.uklinux.net/ursala/seminar111207.pdf
05:03:22 <faxathisia> wow...
05:09:02 <osfameron> scary
05:10:28 <yondalf> in http://www.haskell.org/all_about_monads/html/xformeranatomy.html can the line "(StateT x') <- return $ f v" be "let StateT x' = f v" instead?
05:10:28 <lambdabot> Title: Anatomy of a monad transformer
05:11:00 <faxathisia> I think so, well.. let (StateT x') = f v
05:11:30 <faxathisia> (you still would need .. in do .. though)
05:13:09 <yondalf> "in"...?
05:13:10 <Twey> I think not
05:13:18 <Twey> Assigning to a monad?
05:13:42 <yondalf> Twey: are you referring to my question or faxathisia's answer?
05:13:50 <Twey> Both
05:14:10 <yondalf> Twey: is there any difference between the line given and my suggested line?
05:15:22 <Twey> I think so
05:15:25 <hpaste>  faxathisia pasted "this type checks, at least.." at http://hpaste.org/5613
05:15:28 <Twey> But I'm too sleepy to say why :-\
05:15:41 <yondalf> Twey: haha okay, thanks anyway
05:15:56 <faxathisia> yondalf, well is my paste what you meant?
05:16:06 <yondalf> faxathisia: yes, thanks
05:16:12 <faxathisia> and maybe someone can say whether the two bits of code are equivalent
05:16:19 <faxathisia> because I'm not sure anymore :p
05:18:27 <pcc1> I need to extract the ldflags that ghc uses to invoke the linker (in a makefile), can anyone suggest a better way than passing -v and parsing the output
05:18:48 <yondalf> pcc1: there's a flag to output the rules for a makefile, i think
05:19:29 <yondalf> faxathisia: actually in the paste you did, the "in do" isn't necessary (let statements are part of do notation), which is why i got a bit confused by your "in do" statement
05:20:12 <faxathisia> hey cool
05:20:17 <faxathisia> Well I learned something :D
05:20:36 <Zao> faxathisia: And people say that Perl has icky syntax.
05:20:43 <faxathisia> so it's two different types of let?
05:21:31 <yondalf> faxathisia: yes :-)
05:22:35 <hpaste>  yondalf annotated "this type checks, at least.." with "this works too" at http://hpaste.org/5613#a1
05:22:56 <faxathisia> do {let decls; stmts}	=	let decls in do {stmts}
05:23:00 <faxathisia> from the report
05:23:01 <yondalf> faxathisia: take a look at the annotation for an example
05:23:03 <pcc1> yondalf: I see -M but that seems to be only for dependency information
05:25:10 <yondalf> pcc1: okay...i have no idea then :-(
05:25:49 <smtms> faxathisia, I never imagined my nick can be interpreted as an abbreviation for "statements" :-)
05:26:11 <faxathisia> edit distance 2 :)
05:35:11 <JohnMeacham> jhc now supports a '--ho-dir' option, to let it write and read all ho files from an alternate location.
05:36:53 <ikegami--> hoh hoh
05:36:58 <ikegami--> nice
05:38:26 <ikegami--> On March 1, we have the first Haskell hackathon in Japan, and many people will read the implementation of jhc
05:39:31 <matthew_-> now, why were people talking about distract here yesterday? I managed to miss the whole discussion
05:42:14 <Twey> smtms: It can't
05:42:28 <Twey> smtms: There's only one M in "statements."
05:43:48 <vincenz> roconnor: ping
05:44:01 <gogonkt> help: what that mean? test.hs:3:7:
05:44:01 <gogonkt>     Ambiguous occurrence `putStr'
05:44:01 <gogonkt>     It could refer to either `Prelude.putStr', imported from Prelude
05:44:01 <gogonkt>                           or `System.IO.UTF8.putStr', imported from System.IO.UTF8 at test.hs:1:0-20
05:44:01 <gogonkt> Failed, modules loaded: none.
05:44:22 <gogonkt> I using ghci :(
05:44:55 <Cale> gogonkt: You've imported a module (System.IO.UTF8) which exports a function called putStr
05:45:06 <Cale> gogonkt: putStr is also defined in the Prelude module
05:45:15 <Cale> It's saying that it doesn't know which one you mean.
05:45:16 <gogonkt> Cale, same funtion?
05:45:22 <Cale> No, they're different.
05:45:28 <gogonkt> o.....
05:46:08 <Cale> You'll have to either  import Prelude hiding (putStr)  or  import System.IO.UTF8 hiding (putStr) depending on which you want.
05:46:18 <Cale> Or, you can explicitly specify, each time you use it.
05:46:24 <gogonkt> but ghci load Prelude default....
05:46:39 <Cale> Right, you'd have to do this in whichever module you're writing.
05:47:04 <gogonkt> Cale, I think I got it,:)
05:47:22 <Cale> You could also just write  Prelude.putStr
05:47:30 <Cale> Or System.IO.UTF8.putStr
05:47:35 <gogonkt> ok
05:47:55 <Cale> But that's unwieldy.
05:48:47 <Cale> If you want both to be around, you could   import qualified System.IO.UTF8 as U
05:51:38 <gogonkt> Cale, It worked,haha,I printed something in utf8 to stdout first time,Thz,hahahaha
05:51:50 <gogonkt> That's great time
05:56:53 <nominolo> wow, dons has already 9 months experience as a Haskell-hacker: http://www.ohloh.net/accounts/12227/positions/10669 :)
05:56:53 <lambdabot> Title: dons - Ohloh
05:57:32 <bloup> what is the debugging strategy for <<loop>>?
05:58:20 <faxathisia> try to find any recursion that isn't obviously terminating and try to show that it does
05:58:24 <Cale> bloup: :set -fbreak-on-exception
05:58:42 <Cale> and then  :trace someExpression
05:58:49 <nominolo> bloup: then :trace loopingFunction
05:58:51 <Cale> (whatever throws the exception)
05:58:57 <nominolo> bloup: then :back
05:59:18 <bloup> well, i use foreign too, so i can't use ghci, right?
05:59:25 <Cale> and :list will show the code around the current place on the stack
05:59:35 <Cale> I'm pretty sure you can use ghci.
06:00:01 <bloup> cale: I just have to load the compiled code into ghci, not?
06:00:16 <Cale> You can just load the .hs files.
06:00:23 <bloup> ok
06:00:24 <Cale> er...
06:00:36 <nominolo> bloup: try using -Wall.  maybe you used, say, f instead of f' or similar
06:00:38 <Cale> Or are you compiling in some .o files generated by C?
06:01:03 <bloup> Cale, I do.
06:01:13 <Cale> I've never done that, but it might be possible to just give the .o files, or even maybe the .c files on the ghci commandline.
06:04:25 <resiak> can folks suggest an example of writing instances of HaXml's XmlContent class I could go peruse?
06:04:59 <Cale> bloup: Okay, yeah, you can just pass the .o files in.
06:05:04 <Cale> (on the commandline)
06:06:32 * resiak finds haxml-doc/examples.  "forget i asked!"
06:08:51 <Cale> bloup: Oh, by the way <<loop>> is an exception that's thrown when GHC detects an infinite loop (by an expression evaluating as the result of trying to evaluate that same expression)
06:11:40 <bloup> I'm using foreign export to call haskell from C. ghci complains the exported functions are unknown :-(
06:12:02 <bloup> im now giving all the .hs files plus the .o files to ghci
06:12:57 <litb> one question
06:13:24 <litb> slightly offtopic: if a language has output parameters (like int*result) , is that parameter a side effect?
06:13:33 <litb> if the function write to that one i mean
06:13:36 <kpreid> well, assigning it is
06:14:06 <kpreid> you could consider it not if the language is such that the out-parameter-cell can't possibly be looked at while the function is executing
06:14:17 <kpreid> in which case you can't tell it's a side effect
06:14:42 <kpreid> also that the cell is allocated by the calling function rather than being part of some preexisting data structure
06:20:42 <JohnMeacham> yay. dependency checking in jhc is super fast now. it can do a few hundred files in no time at all, doing full md5 hash checking and not relying on timestamps.
06:23:23 <MarcWeber> Which tag gernating programs are there now? The darcs repo using ghc API, hasktags (beeing distributed with GHC).., GHCI (:ctags). Is there any other tool I should know about?
06:23:48 <phobes> Is there anyway to catch <<loop>>?
06:24:38 <pejo> JohnMeacham, did you get md5sum working?
06:25:13 <ski> litb,kpreid : if the function uses some explicit effect type, like monad type in the result, then you can attribute the changed thing to that, and just say that the `int *' was just a (immutable) reference into that
06:26:12 <ski> (so, then that parameter wouldn't be side-effected, but e.g. the state in the monad would be updated)
06:26:36 <pejo> Does anyone in here use OSX 10.4 and noticed long (>0.5s) when switching from Safari to xterm after the latest update?
06:26:59 <ski> (also, i think one needs to distinguish between side-effects and effects)
06:27:36 <ski> another related thing is output arguments (of a particular call pattern of) a predicate in logic programming
06:28:52 <rabby> haskell drives me crazy :(
06:29:28 <rabby> i want to do some recursion when finding all permutations of a string: http://nopaste.info/57b458bdd1.html
06:30:10 <rabby> but it tries to make [String] the first time; the second time it is already http://en.wikipedia.org/wiki/Special:Search?go=Go&search=String and so on -> error :(
06:31:46 <shag> are left-open handles automatically closed upon the termination of a haskell program?
06:37:54 <ski> rabby : what do you mean by "i wish, line 7 did ++ px (pc (head snew) sold_for_each_element_of_ssold) (tail snew)", isn't that what you're already doing ?
06:38:08 <ski> rabby : also, you have a type error in `permutations', can you spot it ?
06:43:06 <hoseph> i stumbled across HOOD (http://www.haskell.org/hood/) a few days ago.  I want to run it on ghc 6.6 but can't find any support.  has anyone done this?
06:45:02 <Lemmih> hoseph: I think you're out of luck.
06:45:30 <hoseph> darn, did they stop maintaining it?
06:46:47 <Lemmih> No new development since 2000, apparently.
06:47:06 <rabby> ski: the problem is: it becomes a list of a list of a list ....
06:47:23 <rabby> i need the lists to be (++)
06:47:33 <ski> rabby : yes, that's your bug in `permutations'
06:47:47 <ski> (hint : think about how you call `px' there)
06:48:09 <ski> (do the types of the actual and formal parameters agree ?)
06:48:50 <rabby> ok, i changed it to pc [""] s
06:49:33 <rabby> but the problem is really located in line 7
06:49:51 <rabby> i tried already: (foldr (++ pc (head snew) ) [[]] ssold) and so on
06:50:11 <pejo> hoseph, there is a debugger included in ghc 6.8, but I don't think it's very similar to Hood.
06:50:29 <ski> rabby : why do you think there's a problem in line 7 ?
06:50:41 <ski> is there another type error ?
06:50:50 <ski> do you get nonexpected result ?
06:50:55 <ski> do you get no result at all ?
06:51:30 <hoseph> pejo : yeah, i saw that.  i wanted to make use of viewing 'intermediate data structures'
06:51:37 <rabby> ski,
06:51:37 <rabby> *** Type           : [[String]]
06:51:37 <rabby> *** Does not match : [String]
06:52:18 <Lemmih> hoseph: The debugger in GHCi can do that.
06:52:45 <rabby> ski, it's because i do list comprehension although i need to concat the lists instead
06:52:57 <litb> oh i hate type errors so much
06:52:59 <rabby> but i do not find the solution with foldr
06:53:15 <ski> rabby : ok, then maybe just concat the lists ?
06:53:18 <litb> rabby: for what? i need quizes
06:53:39 <ski> > concat [[0,1,2,3],[4,5,6],[7,8],[9]]
06:53:43 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
06:54:14 <ski> rabby : does that help ?
06:54:14 <litb> you can do that with foldl
06:54:22 <litb> oh, hat was ski
06:54:40 <hoseph> Lemmih : do you have a good tutorial on the ghc debugger?
06:54:41 <ski> (litb : i prefer `foldr' for that ..)
06:54:46 <rabby> litb: does it make a difference?
06:54:47 <litb> hm
06:54:58 <litb> ski: why do you prefer foldr ?
06:55:04 <litb> i heard it is slower
06:55:15 <JohnMeacham> woot. parallel compilation. finally I can use all 4 CPUs :)
06:55:37 <Lemmih> hoseph: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
06:55:38 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2orwlb
06:55:38 <litb> > foldr (flip (++)) [] [[0,1,2,3],[4,5,6],[7,8],[9]]
06:55:39 <hoseph> litb : depends on what your function does
06:55:47 <lambdabot>  [9,7,8,4,5,6,0,1,2,3]
06:55:54 <litb> err, i fail
06:55:54 <rabby> i tried: foldr (concat pc (head snew) ) [[]] ssold
06:56:32 <litb> hm, but using foldr, would't it become 9, 8, 7, .. ?
06:56:42 <litb> ah
06:56:44 <rabby> and hoped it does sth like concat (pc (head snew) ssold[0]) ++ [[]] ...
06:56:48 <rabby> but it does not!
06:57:41 <litb> > foldr (++) [] [[0,1,2,3],[4,5,6],[7,8],[9]]
06:57:42 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
06:57:51 <litb> hm, i'm confused why this is 0, 1, 2..
06:58:05 <ski> > take 2 . foldr (++) [] $ ([0,1]:(2:3:undefined):[4]:undefined)
06:58:08 <lambdabot>  [0,1]
06:58:12 <ski> > take 3 . foldr (++) [] $ ([0,1]:(2:3:undefined):[4]:undefined)
06:58:13 <lambdabot>  [0,1,2]
06:58:19 <ski> > take 3 . foldl (flip (++)) [] $ ([0,1]:(2:3:undefined):[4]:undefined)
06:58:19 <lambdabot>  Undefined
06:58:29 <litb> > foldl (++) [] [[0,1,2,3],[4,5,6],[7,8],[9]]
06:58:29 <ski> also
06:58:30 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
06:58:31 <litb> hmm.
06:58:35 <litb> why are they the same?
06:58:42 <litb> isn't a ++ b /= b ++ a ?
06:58:58 <ski> > let bot x = bot (x+1) in take 3 . foldr (++) [] $ ([0,1]:(2:3:bot 0):[4]:bot 0)
06:59:00 <lambdabot>  [0,1,2]
06:59:06 <ski> > let bot x = bot (x+1) in take 3 . foldl (flip (++)) [] $ ([0,1]:(2:3:bot 0):[4]:bot 0)
06:59:12 <lambdabot> Terminated
06:59:16 <ski> litb : which is fastest ?
06:59:37 <litb> i read that foldl  should
06:59:49 <vincenz> that is correct
06:59:54 <vincenz> foldl is fold left-lane
07:00:04 <vincenz> and as you know, unless you live in britain, the left lane is the fast lane on the highway
07:00:30 <litb> please, why isthe result of foldl and foldr identical above?
07:00:38 <ricky_clarkson> Or Japan, Ireland, India, Australia, New Zealand..
07:00:48 <vincenz> ricky_clarkson: it was just an example
07:00:53 <vincenz> ricky_clarkson: cmopleteness did not ruin my point
07:01:12 <Lemmih> JohnMeacham: You make me wish I could build jhc.
07:01:13 <ricky_clarkson> It falsifies the "unless you live in britain" part.
07:01:23 <litb> or.. wait does foldr do .. ([4, 5, 6] ++ ([7, 8] ++ [9])) ?
07:01:51 <ski> rabby : the reason it doesn't is that `ssold' is a list of strings, so `sold' is a string, but `pc (head snew) sold' is a list of strings, so `[pc (head snew) sold | pos <- [0 .. length s - 1]]' is a *list* of list of strings
07:01:55 <litb> well i read foldr is slower since it first has to travers the whole list and then travers back to fold
07:02:09 <ski> rabby : you want to flatten that list of lists into a simple list of strings, e.g. using `concat'
07:02:24 <ski> (rabby : another solution is to redesign your algorithm, however)
07:02:47 <ski> litb : that's completely backwards
07:03:14 <litb> ski: oh, you mean foldl is the slow one that needs to travers?
07:03:21 * vincenz palmslaps
07:03:27 <vincenz> litb: you're looking at it too myopically
07:03:55 <litb> hmm
07:04:01 * litb is lost
07:04:39 <litb> @src foldr
07:04:40 <lambdabot> foldr k z xs = go xs
07:04:40 <lambdabot>     where go []     = z
07:04:40 <lambdabot>           go (y:ys) = y `k` go ys
07:04:52 <vincenz> @src foldl
07:04:52 <lambdabot> foldl f z xs = lgo z xs
07:04:52 <lambdabot>     where lgo z []     =  z
07:04:52 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
07:05:16 <JohnMeacham> Lemmih: you don't need to now, there are binary RPMs online that you can just install with pre-built libraries.
07:05:18 <hoseph> litb : foldl (++) [] [[0,1,2,3],[4,5,6],[7,8],[9]] == ((([] ++ [0,1,2,3]) ++ [4,5,6]) ++ [7,8])++[9]
07:05:25 <vincenz> foldr is better when producing lazy data, foldl is better when producing strict data
07:05:34 <ski> litb : with lazily lists `foldr' will just set up a promise that will compute one element and a new promise (aka thunk), thus since the folding function (`(++)' here) is lazy in its right argument, we can access initial elements of the flattened list without needing to wait for `foldr' to run on the rest of the input list
07:05:35 <litb> hoseph: yes, i know. thus it is faster
07:05:35 <Lemmih> JohnMeacham: Any debs?
07:05:47 <ski> what vincenz said ;)
07:06:02 <hoseph> foldr (++) [] [[0,1,2,3],[4,5,6],[7,8],[9]] == [] ++ ([0,1,2,3] ++ ([4,5,6] ++ ([7,8]++[9])))
07:06:05 <litb> hm, i will have to sip this
07:06:12 <ilyak_> Is there some intro on doing floating point math in haskell?
07:06:20 <vincenz> but stop worrying about performance and figure out -what- you need
07:06:22 <ilyak_> My tutorial don't cover that :(
07:06:24 <vincenz> since they have different meanings
07:06:58 <JohnMeacham> Lemmih: no, but I am pretty sure they will install with 'alien'. also, the tar.gz now can be made via make trivially due to autoconf magic.
07:06:59 <vincenz> ilyak_: you mean like
07:07:02 <vincenz> > 1.0 + 5
07:07:05 <vincenz> > sin 3
07:07:05 <lambdabot>  6.0
07:07:06 <lambdabot>  0.1411200080598672
07:07:10 <vincenz> > cos 2.5
07:07:10 <lambdabot>  -0.8011436155469337
07:07:18 <Deewiant> hoseph: doesn't the ++ [] go at the end and not the beginning?
07:07:43 <ilyak_> vincenz: like, let m = 1; m / 2
07:07:52 <vincenz> > let m = 1 in m/2
07:07:53 <lambdabot>  0.5
07:08:18 <ricky_clarkson> > let m = (/) in m 1 2
07:08:18 <lambdabot>  0.5
07:08:23 <JohnMeacham> the only requirement other than ghc is the binary and zlib libraries.
07:08:40 <rabby> now the syntax seems to be correct. but the result is empty and really not what i expect: http://nopaste.info/7ff5738932.html
07:08:41 <ilyak_> I guess it inferred m as something other-than-Integer
07:08:57 <vincenz> ilyak_: yes, based on what functions you use
07:08:58 <hoseph> Deewiant : yes sorry
07:09:03 <ricky_clarkson> :t (/)
07:09:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:09:08 <vincenz> :t sin
07:09:08 <lambdabot> forall a. (Floating a) => a -> a
07:09:23 <ilyak_> I'm struggling around type conversions, most tutorials don't say much about them
07:09:30 <ricky_clarkson> 1 in let m = 1 in m/2 is some type that is an instance of Fractional.
07:09:42 <vincenz> ilyak_: easiest to go from integer to any number
07:09:47 <ricky_clarkson> @src Fractional
07:09:47 <lambdabot> class  (Num a) => Fractional a  where
07:09:48 <lambdabot>     (/)             :: a -> a -> a
07:09:48 <lambdabot>     recip           :: a -> a
07:09:48 <lambdabot>     fromRational    :: Rational -> a
07:09:49 <vincenz> > let m = fromIntegral 1 in m/2
07:10:02 <lambdabot>  0.5
07:10:02 <vincenz> :t fromIntegral
07:10:03 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:10:06 <rabby> the function permutations should rebuild all permutations of a string starting with an empty string, going on by adding one and so on.
07:10:52 <litb> ski: hm, i see
07:11:07 <litb> laziness is still a bit of magic for me
07:11:12 <Lemmih> JohnMeacham: Ah! The -i to autoreconf is of maniacal importance. Now I can build jhc.
07:11:36 <ilyak_> I don't understand how would I declare a function if I want to do (m / 2) from it, given that m is a parameter
07:12:04 <ricky_clarkson> I don't understand that question.
07:12:08 <vininim> > foldr (.) id ((+1) <$> [1..10]) $ 1
07:12:12 <lambdabot>   add an instance declaration for (Enum (a -> a))
07:12:25 <vininim> > foldr (.) id ((+) <$> [1..10]) $ 1
07:12:26 <lambdabot>  56
07:12:28 <ilyak_> ricky_clarkson: What should be type of m so I can do m / 2?
07:12:37 <ricky_clarkson> Anything Fractional.
07:12:37 <Deewiant> @ty \m -> m / 2
07:12:39 <lambdabot> forall a. (Fractional a) => a -> a
07:12:57 <ricky_clarkson> @instances Fractional
07:12:59 <lambdabot> Double, Float
07:13:03 <ricky_clarkson> One of those.
07:13:42 <ricky_clarkson> > (1 :: Integer)/2
07:13:44 <gogonkt> Cale, are you around?
07:13:46 <lambdabot>   add an instance declaration for (Fractional Integer)
07:13:46 <lambdabot>     In the expression:...
07:13:49 <mauke> ilyak_: Double
07:13:59 <JohnMeacham> Lemmih, yeah. things got a lot simpler once I learned that magic option.
07:14:10 <ilyak_> is there something like big table on all numeric types and conversions between them?
07:14:28 <ricky_clarkson> ilyak_: Yes, here it is:
07:14:28 <gogonkt> hpaste,
07:14:32 <ricky_clarkson> :t fromIntegral
07:14:33 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:14:34 <gogonkt> hpaste
07:14:57 <JohnMeacham> http://repetae.net/computer/jhc/drop/ - the tar.gz's here build out of the box with just ./configure if you don't want to be bleeding edge.
07:14:58 <lambdabot> Title: Index of /computer/jhc/drop
07:15:00 <mauke> ilyak_: you only need 2.5 different types for basic stuff, Int, Integer and Double
07:15:08 <bos> @users
07:15:08 <lambdabot> Maximum users seen in #haskell: 463, currently: 430 (92.9%), active: 17 (4.0%)
07:15:16 <ilyak_> What is the difference between Int and Integer?
07:15:19 <litb> buu, more!
07:15:27 <mauke> ilyak_: Int has a fixed size
07:15:28 <Deewiant> > maxBound :: Int
07:15:29 <lambdabot>  2147483647
07:15:30 <Deewiant> > maxBound :: Integer
07:15:31 <lambdabot>   add an instance declaration for (Bounded Integer)
07:15:31 <lambdabot>     In the expression: ma...
07:15:39 <pejo> JohnMeacham, what does -i do, and how can it be broken if not?
07:15:40 <Lemmih> JohnMeacham: Is the multicode stuff available in the darcs version?
07:15:46 <mauke> > 99^99 :: Int
07:15:47 <lambdabot>  -1250178885
07:15:49 <mauke> > 99^99 :: Integer
07:15:50 <lambdabot>  3697296376497267726571879056288054405956687642817411024302599724235525704552...
07:16:02 <JohnMeacham> Lemmih: btw, I recently redid the jhc web pages to reflect the new, easier, installation method. http://repetae.net/computer/jhc/building.shtml - any comments?
07:16:03 <lambdabot> Title: jhc
07:16:07 <vincenz> > length . show @ 2^2^2^2^2
07:16:07 <lambdabot>  Parse error in expression at end of input
07:16:11 <ricky_clarkson> > length $ show (99^99)
07:16:11 <vincenz> > length . show $ 2^2^2^2^2
07:16:14 <Tac-Work> > 2 ^ 32 :: Int
07:16:14 <lambdabot>  19729
07:16:14 <lambdabot>  198
07:16:15 <lambdabot>  0
07:16:17 <vincenz> > length . show $ 2^2^2^2^2
07:16:17 <lambdabot>  19729
07:16:24 <Tac-Work> Too many evals =-(
07:16:26 <mauke> ilyak_: Integer is nicer to use because it doesn't give you bogus results, but many standard functions deal with Ints only
07:16:40 <JohnMeacham> pejo: it is what you pass to autoreconf the very first time you run it in order to have it install its helper files properly.
07:17:01 <Tac-Work> It's are lowlevel and should be treated as such!
07:17:08 <Tac-Work> Int's*
07:17:15 <Lemmih> JohnMeacham: DrIFT doesn't build without -i.
07:17:25 <mauke> â€˜Intâ€™s
07:17:29 <Deewiant> Ints*
07:18:07 <JohnMeacham> Lemmih: yeah, but that is only from the repository since the repo doesn't contain generated files, the distribution version meant for random people to install of both is different.
07:18:35 <JohnMeacham> as in, 'make dist' does a lot more than just 'tar zcvf'.
07:20:02 <Lemmih> JohnMeacham: My distribution only has DrIFT-2.2.0 which makes jhc die horribly.
07:20:35 <ilyak_> How would I get Integer from Float?
07:20:47 <kpreid> :t round
07:20:49 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
07:20:51 <Lemmih> Ah, you have distributions on your website.
07:20:53 <JohnMeacham> Lemmih: yeah, 2.2.3 was released the other day. the 0.4 tarball doesn't even need DrIFT to compile.
07:20:54 <kpreid> :t floor
07:20:55 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
07:20:56 <kpreid> :t ceiling
07:20:57 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
07:21:11 <kpreid> :t truncate
07:21:12 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
07:21:13 <mauke> ilyak_: depends on which direction you want to go :-)
07:23:23 <ricky_clarkson> ilyak_: Depends how you want to lose data.
07:23:54 <mauke> Floats are not a beginner type
07:24:04 <Deewiant> is there a low-level round for when you don't care which way it goes?
07:24:04 <mauke> they cause grief and suffering
07:24:15 <ilyak_> Well, in most languages they don't
07:24:29 <Deewiant> yes they do, people just don't realize it :-P
07:25:06 <Deewiant> somebody replied to a comment of mine on Reddit that he'll continue to use doubles to store money in Java since he's done so for years and "knows how they work"
07:25:19 <mauke> huhu
07:25:24 <litb> lol
07:25:29 <litb> how silly
07:26:04 <mauke> some time ago, someone in #C complained about how java was broken because its doubles didn't work right
07:26:16 <litb> =)
07:26:24 <mauke> WHY DIDN'T ANYONE NOTICE?
07:26:41 <litb> "this is a shit laptop, because its battery is empty now"
07:26:48 <litb> same :)
07:27:01 <ricky_clarkson> Ooh, lovely.
07:27:08 <ilyak_> Well, most money should fit into double, aren't they? And BigDecimals are PITA in Java
07:27:21 <Deewiant> 0.1 doesn't fit into double
07:27:23 <faxathisia> It's not that bad
07:27:29 <jedbrown> Floating point arithmetic almost never a problem as long as you are representing a continuous quantity.  Rounding error is only about 1% of numerical analysis.
07:27:33 <ricky_clarkson> Well, as long as languages where 1/2==0 are the entire top three, programming is a sad field.
07:27:38 <faxathisia> Aren't they (GJS) trying to add operator overloading to Java?
07:27:44 <ricky_clarkson> top as in popularity.
07:27:48 <fons> hi all
07:27:49 <faxathisia> which would let you do BigDecimal stuff with ease
07:27:55 <faxathisia> Hi
07:28:11 <litb> c c++ and java are the top three i think
07:28:23 <Deewiant> possibly visual basic
07:28:24 <ricky_clarkson> faxathisia: They're trying to add it specifically for BigDecimal and BigInteger, sadly.
07:28:39 <faxathisia> That's fine by me
07:28:40 <litb> darn, they should add it globally to any type
07:28:41 <fons> I'm coding a module which explicitly hides some Prelude functions, now I'm loading the module in ghci but the functions are not hidden
07:28:41 <ricky_clarkson> Scala can use all Java's libs and has operator overloading already.
07:28:59 <fons> does anybody know how to hide functions in ghci?
07:29:01 <litb> one thing that is so bad is to make special cases for some classes
07:29:05 <ricky_clarkson> CAL (Haskell clone) probably can too.
07:29:48 <Lemmih> fons: I think they's an open bug about that.
07:30:33 <fons> Lemmih: sensible, it's a big pain to test modules which hide Prelude functions without the ability to hide them in ghci
07:30:36 <vininim> Did anyone attempt to implement Aspects in ghc? =P
07:30:36 <Deewiant> to reiterate my question, I guess there's no 'fast' round function which just uses the current rounding mode
07:30:43 <fons> Lemmih: any workaround?
07:31:01 <litb> > 0.1
07:31:04 <Lemmih> fons: :m - Prelude, I think.
07:31:17 <lambdabot>  thread killed
07:31:18 <Deewiant> fons: tested :m -Prelude, seems to work
07:31:21 <litb> darn
07:31:27 <vincenz> > 0.1
07:31:39 <lambdabot>  0.1
07:31:40 <vincenz> wtf?
07:31:43 <fons> but some Prelude functions are implicitly needed aren't they?
07:32:01 <fons> fromIntegral and friends
07:32:10 <vininim> invisible unicode? =P
07:32:13 <Deewiant> > 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
07:32:14 <lambdabot>  0.6000000000000001
07:32:25 <mauke> > 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 :: Rational
07:32:26 <lambdabot>  3%5
07:32:42 <byorgey> fons: they will still be loaded via your module.
07:32:45 <ricky_clarkson> (1 :: Irrational)
07:32:53 <byorgey> fons: the problem is that ghci loads the Prelude separately as well.
07:32:58 <vininim>  > 0.1
07:33:01 <BMeph> ?seen Irrationals
07:33:02 <lambdabot> I haven't seen Irrationals.
07:33:09 <byorgey> fons: FWIW, this bug seems to be fixed in 6.8.2 (?)
07:33:11 <vincenz> @hoogle Irrational
07:33:12 <lambdabot> No matches found
07:33:14 <litb> one thing
07:33:16 <vininim> vincenz: might be hardware problem?
07:33:21 <vincenz> vininim: possibly
07:33:23 <fons> byorgey: I'm using ghc 6.8.2
07:33:29 <litb> the Num class is also for period numbers?
07:33:30 <BMeph> ?where Irrationals
07:33:30 <lambdabot> I know nothing about irrationals.
07:33:32 <litb> i mean for 0.xx ?
07:33:34 <ilyak_> Is there a library function to repeat a character n times?
07:33:41 <litb> why isn't / a part of it then?
07:33:43 <faxathisia> :t repeat
07:33:44 <lambdabot> forall a. a -> [a]
07:33:45 <litb> that's bugging me
07:33:45 <Lemmih> > replicate 10 'c'
07:33:46 <lambdabot>  "cccccccccc"
07:33:54 <mauke> :t 0.1
07:33:55 <lambdabot> forall t. (Fractional t) => t
07:33:57 <vincenz> > take 10 $ repeat 'c'
07:33:57 <lambdabot>  "cccccccccc"
07:33:59 <ricky_clarkson> litb: / is undefined over integers.
07:34:06 <litb> Num is for Integrals?
07:34:08 <litb> hmm
07:34:11 <Deewiant> > take 10 $ cycle "c"
07:34:12 <lambdabot>  "cccccccccc"
07:34:15 <litb> i wonder how abs 0.5 is possible then
07:34:16 <fons> actually the :m -Prelude workaround doesn't seem to work
07:34:17 <mauke> litb: no, numbers
07:34:23 <ricky_clarkson> @instances Num
07:34:27 <litb> ah, i see ricky_clarkson
07:34:28 <lambdabot> Double, Float, Int, Integer
07:34:33 <litb> it's not there because if Integer
07:34:56 <byorgey> fons: hm, I can't seem to reproduce it.
07:34:59 <ricky_clarkson> > (1 :: Integer)/2
07:35:00 <lambdabot>   add an instance declaration for (Fractional Integer)
07:35:00 <lambdabot>     In the expression:...
07:35:24 <litb> makes sense
07:35:25 <byorgey> fons: I created a file that just says 'import Prelude hiding (id)' and when I load it in ghci and try doing ':t id', it complains that id is not in scope
07:35:31 <litb> well, i wonder why it doesn't cut it simply
07:35:40 <rabby> is there a default function to do function (with 2 parameters) for each 2 elements of a list?
07:35:42 <slarba> hmm
07:35:48 <ricky_clarkson> Because then 1/2 would be 0.
07:35:50 <ricky_clarkson> ugh
07:35:55 <fons> byorgey: that's maybe because you are loading that file directly in ghci
07:36:03 <slarba> what is the fastest and cleanest way to convert lazy bytestring into a "strict" bytestring?
07:36:09 <litb> nah, (1::Integer)/2 would be null i mean, but 1/2 would still be Floating
07:36:10 <byorgey> fons: oh, what are you doing then?
07:36:14 <fons> byorgey: in my case the module hiding functions is imported by the module I'm loading
07:36:23 <ricky_clarkson> litb: be null?
07:36:30 <litb> 0 , pardon
07:36:34 <byorgey> fons: oh, I see.
07:36:49 <litb> sorry, have to go to the software exam
07:36:56 <litb> happy hacking. i hope i survive
07:37:10 <ricky_clarkson> My word null comes mainly from programming, not German.
07:37:17 <byorgey> fons: well, it seems to me this isn't really a ghci problem, the problem is just that the Prelude always gets imported implicitly.
07:37:26 <Tac-Work> > null "null"
07:37:27 <lambdabot>  False
07:37:31 <BMeph> fons: Do you have the "no-implicit-prelude" flag set?
07:37:40 <byorgey> fons: so if module A imports module B, which imports the Prelude with something hidden, module A still implicitly imports the whole Prelude
07:37:56 <byorgey> fons: so you will have to put an 'import Prelude hiding (foo)' in module A as well, if you don't want foo to be visible
07:37:59 <hpaste>  fons pasted "ghci hiding bug" at http://hpaste.org/5615
07:38:36 <fons> byorgey: I'll try that
07:39:13 <fons> -XNoImplicitPrelude breaks everything since some modules are make use of Prelude
07:40:06 <fons> fons: what is needed is a way to set hidden functions just for the interactive module
07:40:29 <byorgey> fons: what do you mean?
07:40:32 <fons> byorgey, I meant
07:41:57 <fons> byorgey: -XNoImplicitPrelude hides the Prelude for all the modules loaded, but I just want to hide the Prelude fr the command line (the "Interactive" module)
07:42:54 <Lemmih> JohnMeacham: Can I test the parallel compilation?
07:43:19 <JohnMeacham> lemmih: not yet.
07:43:29 <JohnMeacham> I'll try to check in the code later though.
07:43:35 <byorgey> fons: oh, I see what you mean.  but yes, the way to hide the Prelude (or parts of it) only for certain modules is with an explicit import statement at the tops of those modules.
07:43:56 <byorgey> fons: I think if you want to entirely hide the prelude only for a certain module you can use {-# LANGUAGE NoImplicitPrelude #-} at the top
07:44:09 <byorgey> maybe
07:44:26 <pastorn> is that "SimpleReflect" i saw in a blog post a week or so ago in use yet?
07:44:47 <pastorn> (for lambdabot)
07:44:48 <dons> yeah
07:44:59 <fons> byorgey: well, not really, it's a library so I don't want it to hide the prelude permanently, just for testing purposes on the command line
07:45:02 <jbruce> I'm doing FFI in GHC with some c programmers.  Can GHC build a .a for me?
07:45:13 <mauke> > g x
07:45:20 <pastorn> @reflect map f [x,y,z]
07:45:29 <lambdabot>  thread killed
07:45:29 <lambdabot> Unknown command, try @list
07:45:30 <fons> I think think someone proposed something similar to what I want due to the classes of ByteString with the Prelude
07:45:35 <pastorn> @list
07:45:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:45:40 <fons> clashes*
07:46:13 <mauke> > g x
07:46:14 <lambdabot>  Add a type signature
07:46:19 <glen_quagmire> :t g
07:46:20 <lambdabot> Not in scope: `g'
07:46:24 <glen_quagmire> :t x
07:46:25 <lambdabot> Not in scope: `x'
07:46:30 <pastorn> dons: pleasy give an example
07:46:32 <Deewiant> > g :: Int
07:46:36 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
07:46:36 <lambdabot>     In th...
07:46:44 <glen_quagmire> > fix (\g x -> g x) 1
07:46:46 <lambdabot>  Exception: <<loop>>
07:47:07 <Deewiant> > foldl1 f [a,b,c]
07:47:09 <lambdabot>  f (f a b) c
07:47:09 <mauke> > f :: Int
07:47:10 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
07:47:10 <lambdabot>     In th...
07:47:18 <Deewiant> > foldl1 f [a,b,c,d,e,f,g,h]
07:47:19 <lambdabot>  f (f (f (f (f (f (f a b) c) d) e) f) g) h
07:47:34 <byorgey> hah, nice!
07:47:42 <pastorn> @type foldr
07:47:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:47:59 <Deewiant> > foldr1 f [a,b,c,d,e,f,g,h]
07:48:00 <lambdabot>  f a (f b (f c (f d (f e (f f (f g h))))))
07:48:00 <pastorn> > foldr base [x,y,z]
07:48:01 <lambdabot>   Not in scope: `base'
07:48:04 <fons> Deewiant: what was that?
07:48:05 <glen_quagmire> > foldl f [a,b]
07:48:06 <lambdabot>   add an instance declaration for (Typeable Expr)
07:48:12 <glen_quagmire> > foldl2 f [a,b]
07:48:12 <lambdabot>   Not in scope: `foldl2'
07:48:23 <glen_quagmire> > foldr1 f [a,b]
07:48:24 <lambdabot>  f a b
07:48:25 <Deewiant> fons: what?
07:48:26 <pastorn> > foldr p [x,y,z]
07:48:28 <lambdabot>  Couldn't match expected type `a -> b -> b'
07:48:37 <byorgey> > foldl f 0 [a,b,c]
07:48:37 <lambdabot>  Add a type signature
07:48:38 <pastorn> > foldr f p [x,y,z]
07:48:39 <lambdabot>  f x (f y (f z p))
07:48:45 <fons> a b c d ... are defined for lambabot?
07:48:55 <fons> lambdabot
07:48:56 <Tac-Work> > a
07:48:58 <Deewiant> yep
07:48:58 <lambdabot>  a
07:49:01 <glen_quagmire> it's haskell3000
07:49:05 <fons> hehehe
07:49:12 <byorgey> fons: it's a special module to reify expression evaluations.
07:49:14 <Deewiant> f,g,h are functions
07:49:17 <Deewiant> not sure about others
07:49:22 <glen_quagmire> > f 1
07:49:23 <lambdabot>  Add a type signature
07:49:29 <glen_quagmire> > f 1 :: (String -> String)
07:49:29 <fons> ok, I see
07:49:30 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Char])
07:49:30 <lambdabot>     In...
07:49:30 <Tac-Work> > l : a : "mb" ++ d : [a]
07:49:30 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
07:49:33 <byorgey> fons: so you can inspect the structure.  nice for folds and such.
07:49:46 <pastorn> > foldl f p [x,y,z]
07:49:47 <lambdabot>  f (f (f p x) y) z
07:50:03 <byorgey> > foldr (flip . f) a [b,c,d]
07:50:04 <lambdabot>  Couldn't match expected type `a -> c' against inferred type `Expr'
07:50:06 <Tac-Work> > 'l' : a : 'm' : b : d : [a]
07:50:07 <lambdabot>  Couldn't match expected type `Char' against inferred type `Expr'
07:50:09 <Tac-Work> bah
07:50:14 <byorgey> > foldr (flip f) a [b,c,d]
07:50:15 <lambdabot>  f (f (f a d) c) b
07:50:17 <fons> > map f [a,b,c]
07:50:18 <lambdabot>  Add a type signature
07:50:35 <byorgey> aww, map doesn't work?  boo.
07:50:43 <pastorn> BOO!
07:50:47 <byorgey> > map f [a,b,c] :: [Int]
07:50:47 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
07:50:55 <byorgey> > map f [a,b,c] :: [Char]
07:50:55 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Char)
07:50:56 <BMeph> fons: So far as I know, the "truest", i.e., the most correspondent to actual use, method, would be to compile your auxiliary modules, then test the "Interactive" module, with the -"XNoImplicitPrelude" flag set in GHCi.
07:51:02 <Deewiant> > map f [a,b,c] :: Expr
07:51:03 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
07:51:06 <Deewiant> > map f [a,b,c] :: [Expr]
07:51:08 <lambdabot>  [f a,f b,f c]
07:51:33 <glen_quagmire> wow this is something bloggable
07:51:40 <glen_quagmire> > fix f
07:51:41 <lambdabot>  Add a type signature
07:51:41 <Deewiant> this comes from a blog
07:51:43 <fons> BMeph: Right, but -XNoImplicitPrelude is passed when compiling all the modules, which breaks the compilation
07:51:55 <glen_quagmire> > fix f  :: (a -> a)
07:51:55 <lambdabot>        add (SimpleReflect.FromExpr a,
07:51:56 <lambdabot>            Show a,
07:51:56 <lambdabot>            Typeable ...
07:52:09 <glen_quagmire> > join f
07:52:09 <lambdabot>   add an instance declaration for (Show (m a))
07:53:45 <glen_quagmire> funcional programming is as hard as regular expressions
07:53:54 <byorgey> > map (f . g) [a,b,c] :: [Expr]
07:53:54 <lambdabot>  Add a type signature
07:54:09 <Deewiant> > map (f . g :: Expr -> Expr) [a,b,c] :: [Expr]
07:54:10 <lambdabot>  Add a type signature
07:54:35 <glen_quagmire> > let a :: a -> a; a = id in a 1
07:54:36 <lambdabot>  1
07:54:38 <glen_quagmire> > let a :: a -> a; a = id in a f
07:54:39 <lambdabot>  Add a type signature
07:54:45 <glen_quagmire> > let a :: a -> a; a = id in a f :: Expr
07:54:45 <lambdabot>  f
07:54:55 <glen_quagmire> > let a :: a -> a; a = id in a a :: Expr
07:54:55 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> a'
07:55:18 <resiak> > fix f :: Expr
07:55:18 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
07:55:26 <mux> neat one
07:55:49 <BMeph> fons: Compile the other modules first, then turn on the "NIP", and test the as-yet-uncompiled main module.
07:55:50 <fons> > let map' f = foldr ((:).f) []  in map' f [1,2,3]
07:55:50 <lambdabot>  Add a type signature
07:55:57 <fons> ??
07:56:10 <resiak> > let map' f = foldr ((:).f) []  in map' f [1,2,3] :: [Expr]
07:56:12 <lambdabot>  [f 1,f 2,f 3]
07:56:22 <fons> OK, Right
07:56:48 <fons> > map f [a,b,c,d] :: [Expr]
07:56:49 <lambdabot>  [f a,f b,f c,f d]
07:57:06 <resiak> > show (x::Expr) -- hrm?
07:57:07 <lambdabot>  "x"
07:57:12 <Syzygy-> > abc :: Expr
07:57:14 <lambdabot>   Not in scope: `abc'
07:57:17 <Valodim> what is "Expr"?
07:57:21 <Valodim> the parsec thing?
07:57:24 <Deewiant> SimpleReflect
07:57:30 <Syzygy-> > a :: Expr
07:57:32 <resiak> it's the dummy type used by SimpleReflect
07:57:32 <Deewiant> @where simplereflect
07:57:33 <lambdabot> I know nothing about simplereflect.
07:57:36 <lambdabot>  a
07:57:37 <Valodim> ah
07:57:37 <vininim> @src scanr
07:57:38 <lambdabot> scanr _ q0 []     =  [q0]
07:57:38 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
07:57:38 <lambdabot>     where qs@(q:_) = scanr f q0 xs
07:57:54 <fons> I know nothing myself, lambdabot, you're not alone
07:57:55 <BMeph> > let howToFix = fix in howToFix java
07:57:55 <lambdabot>   Not in scope: `java'
07:58:03 <BMeph> Rats.
07:58:11 <glen_quagmire> @index SimpleReflect
07:58:11 <lambdabot> bzzt
07:58:14 <faxathisia> What is Expr?
07:58:17 <Deewiant> @where simplereflect
07:58:17 <byorgey> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
07:58:17 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
07:58:19 <lambdabot> Title: Simple reflection of expressions - 21 thoughts, http://tinyurl.com/2yeszc
07:58:21 <BMeph> > let howToFix = fix; java = f in howToFix java
07:58:21 <lambdabot>  Add a type signature
07:58:38 <BMeph> ?bo
07:58:38 <lambdabot> :)
07:58:39 <Deewiant> > scanr f p [a,b,c,d]
07:58:40 <lambdabot>  [f a (f b (f c (f d p))),f b (f c (f d p)),f c (f d p),f d p,p]
07:58:46 <glen_quagmire> > (\x -> f x)
07:58:47 <lambdabot>  Add a type signature
07:58:51 <glen_quagmire> > (\x -> f x)  :: Expr
07:58:51 <lambdabot>      The lambda expression `\ x -> f x' has one argument,
07:58:51 <lambdabot>     but its type `E...
07:59:01 <glen_quagmire> > (\x -> (f :: Expr) x)
07:59:01 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Expr'
07:59:12 <faxathisia> > sum [1..5] :: Expr
07:59:15 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5
07:59:18 <faxathisia> Nice :D
07:59:20 <Deewiant> O_o
07:59:26 <byorgey> sweet!
07:59:26 <Deewiant> > product [1..5] :: Expr
07:59:28 <lambdabot>  1 * 1 * 2 * 3 * 4 * 5
07:59:36 <faxathisia> hehe.. this is great
07:59:38 <BMeph> > (\x -> (f :: Expr -> Expr) x)
07:59:38 <glen_quagmire> > fix show :: Expr
07:59:39 <lambdabot>  Couldn't match expected type `Expr' against inferred type `String'
07:59:39 <lambdabot>   add an instance declaration for (Typeable Expr)
07:59:43 <byorgey> product [2,4..] :: Expr
07:59:47 <byorgey> > product [2,4..] :: Expr
07:59:51 <glen_quagmire> > fix show "" :: Expr
07:59:52 <lambdabot> Terminated
07:59:52 <lambdabot>  Couldn't match expected type `[Char] -> Expr'
07:59:55 <vininim> > scanr (.) id (repeat (+1))
07:59:57 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
08:00:00 <byorgey> hm, not lazy enough... oh well
08:00:01 <faxathisia> > map fst $ iterate (\(x,y)->(y,x+y)) $ (0,1) :: [Expr]
08:00:04 <lambdabot>  [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1)),1 + (0 + 1) + (0 + 1 + (1 + (0 ...
08:00:08 <Deewiant> > [0..] :: Expr
08:00:09 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
08:00:12 <faxathisia> fibonacci
08:00:17 <byorgey> faxathisia: haha!
08:00:36 <byorgey> > [1..5] :: [Expr]
08:00:37 <lambdabot>  [1,2,3,4,5]
08:00:44 <Deewiant> > [0..] :: [Expr]
08:00:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
08:00:54 <Deewiant> > product [2,4..] :: [Expr]
08:00:55 <lambdabot>   add an instance declaration for (Num [Expr])
08:00:55 <lambdabot>     In the expression: 2
08:00:56 <Valodim> duh
08:00:59 <Deewiant> duh
08:01:03 <glen_quagmire> > fix show :: [Expr]
08:01:03 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
08:01:08 <Deewiant> @ty fix show
08:01:09 <lambdabot> String
08:01:15 <glen_quagmire> > fix show :: Expr
08:01:15 <lambdabot>  Couldn't match expected type `Expr' against inferred type `String'
08:01:28 <byorgey> fix show isn't polymorphic
08:01:29 <glen_quagmire> @ty [0..]
08:01:29 <lambdabot> forall t. (Enum t, Num t) => [t]
08:01:43 <faxathisia> > iterate (*x) 1 :: [Exp]
08:01:44 <lambdabot>   Not in scope: type constructor or class `Exp'
08:01:46 <faxathisia> > iterate (*x) 1 :: [Expcr]
08:01:47 <lambdabot>   Not in scope: type constructor or class `Expcr'
08:01:47 <faxathisia> > iterate (*x) 1 :: [Expr]
08:01:48 <lambdabot>  [1,1 * x,1 * x * x,1 * x * x * x,1 * x * x * x * x,1 * x * x * x * x * x,1 *...
08:02:09 <byorgey> man, is this a great teaching tool or what?
08:02:12 <glen_quagmire> > fix (\fac n -> if n < 2 then 1 else n * fac (n - 1)) :: Expr
08:02:12 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> a'
08:02:18 <glen_quagmire> > fix (\fac n -> if n < 2 then 1 else n * fac (n - 1)) 3 :: Expr
08:02:19 <lambdabot>  3 * ((3 - 1) * 1)
08:02:30 <Deewiant> > [a..e]
08:02:31 <lambdabot>  Exception: not a number
08:02:48 <glen_quagmire> > fix show 1
08:02:49 <lambdabot>  Couldn't match expected type `t1 -> t'
08:02:52 <byorgey>  > fix (\fac n -> if n < 2 then 1 else n * fac (n - 1)) 5 :: Expr
08:03:00 <byorgey> > fix (\fac n -> if n < 2 then 1 else n * fac (n - 1)) 5 :: Expr
08:03:01 <lambdabot>  5 * ((5 - 1) * ((5 - 1 - 1) * ((5 - 1 - 1 - 1) * 1)))
08:03:02 <Deewiant> > zipWith (+) [1..10] [11..20] :: [Expr]
08:03:03 <lambdabot>  [1 + 11,2 + 12,3 + 13,4 + 14,5 + 15,6 + 16,7 + 17,8 + 18,9 + 19,10 + 20]
08:03:23 <glen_quagmire> > fix (\x -> show x) 1 :: Expr
08:03:23 <lambdabot>  Couldn't match expected type `t -> Expr'
08:03:27 <vininim> > scanr (.) id (repeat (+1)) :: [Expr]
08:03:28 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> b'
08:03:31 <byorgey> hm, some spaces in the list output would be nice
08:03:58 <glen_quagmire> > putStrLn :: [Expr]
08:03:58 <lambdabot>  Couldn't match expected type `[Expr]'
08:04:04 <unenough> i want a language that has Chocolatemorphism
08:04:06 <glen_quagmire> > putStrLn "hi" :: Expr
08:04:10 <lambdabot>  Couldn't match expected type `Expr' against inferred type `IO ()'
08:04:30 <byorgey> oh, I guess that's not possible, it's just printing a list and showing each element
08:04:44 <byorgey> unenough: you've come to the right place!
08:05:00 <glen_quagmire> unenough: the language's name is KitKat
08:05:10 <vininim> wait, I only know about the banana morphism
08:05:34 <unenough> well chocolate-banana is nice
08:05:54 <glen_quagmire> > Expr
08:05:55 <lambdabot>   Not in scope: data constructor `Expr'
08:05:59 <glen_quagmire> > 1 :: Expr
08:06:00 <lambdabot>  1
08:06:11 <glen_quagmire> > (+ 1) :: Expr
08:06:11 <lambdabot>      The section `(+ 1)' takes one argument,
08:06:11 <lambdabot>     but its type `Expr' has none...
08:06:23 <glen_quagmire> > (+ 1) :: Expr -> Expr
08:06:24 <lambdabot>   add an instance declaration for (Typeable Expr)
08:06:36 <glen_quagmire> > (+ 1) :: Type -> Type
08:06:36 <lambdabot>   Not in scope: type constructor or class `Type'
08:06:44 <glen_quagmire> > (+ 1) 1 :: Expr
08:06:47 <lambdabot>  1 + 1
08:06:58 <glen_quagmire> > (1 +) a :: Expr
08:06:58 <lambdabot>  1 + a
08:07:03 <glen_quagmire> > (+1) a :: Expr
08:07:04 <lambdabot>  a + 1
08:07:06 <faxathisia> This is too cool :P
08:07:27 <glen_quagmire> > f a b :: Expr
08:07:29 <lambdabot>  f a b
08:07:32 <pastorn> hehe
08:07:48 <glen_quagmire> > h e l l o w o r l d :: Expr
08:07:49 <lambdabot>  h e l l o w o r l d
08:08:28 <byorgey> twanvl++
08:08:43 <twanvl> :)
08:08:56 <vininim> @type fix
08:09:00 <lambdabot> forall a. (a -> a) -> a
08:09:21 <byorgey> twanvl: very cool. =)
08:09:30 <glen_quagmire> > map f [1,2,3] :: Expr
08:09:30 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
08:09:34 <glen_quagmire> > map f [1,2,3] :: [Expr]
08:09:35 <lambdabot>  [f 1,f 2,f 3]
08:10:00 <byorgey> > sum (map f [1,2,3]) :: Expr
08:10:04 <lambdabot>  0 + f 1 + f 2 + f 3
08:10:09 <vininim> > scanr (.) id (repeat (f)) :: [Exprt]
08:10:10 <lambdabot>   Not in scope: type constructor or class `Exprt'
08:10:16 <vininim> > scanr (.) id (repeat (f)) :: [Expr]
08:10:17 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> b'
08:10:27 <faxathisia> > reverse (a : b : c : d : [])
08:10:28 <lambdabot>  [d,c,b,a]
08:10:39 <faxathisia> > reverse $ (a : b : []) ++ (c : d : [])
08:10:40 <lambdabot>  [d,c,b,a]
08:10:45 <faxathisia> wow o_o
08:10:57 <byorgey> :t scanr
08:10:59 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
08:11:22 <glen_quagmire> > (join . join) [[[1,2,3], 4], [[5,6]], 7]] :: [Expr]
08:11:22 <lambdabot>  Parse error at "]" (column 41)
08:11:32 <TauPan> oops, wrong channel, sorry :)
08:11:40 <glen_quagmire> > (join . join) [[[1,2,3], 4], [[5,6]], 7]]] :: [Expr]
08:11:40 <lambdabot>  Parse error at "]]" (column 41)
08:11:49 <glen_quagmire> > (join . join) [[[1,2,3], 4], [[5,6]], 7] :: [Expr]
08:11:50 <lambdabot>   add an instance declaration for (Num [[Expr]])
08:11:50 <lambdabot>     In the expression: 7
08:12:11 <vininim> > 0.1
08:12:13 <lambdabot>  0.1
08:12:15 <glen_quagmire> > (join . join) [[[1,2,3], 4], [[5,6]]] :: [Expr]
08:12:16 <lambdabot>   add an instance declaration for (Num [Expr])
08:12:16 <lambdabot>     In the expression: 4
08:12:16 <lambdabot>     I...
08:12:26 <glen_quagmire> > (join . join) [[[1,2,3], 4], [[5,6]]]
08:12:26 <lambdabot>   add an instance declaration for (Num [a])
08:12:26 <lambdabot>     In the expression: 4
08:12:26 <lambdabot>     In t...
08:12:39 <byorgey> glen_quagmire: that's not a well-typed list.
08:13:01 <vininim> > (join . join) [[[1,2,3], [4]], [[5,6]]]
08:13:02 <lambdabot>  [1,2,3,4,5,6]
08:13:19 <glen_quagmire> :t [[[1,2,3], [4]], [[5,6]]]
08:13:25 <lambdabot> forall t. (Num t) => [[[t]]]
08:14:18 <glen_quagmire>  > join  [[[1,2,3], [4]], [[5,6]]] :: [[Expr]]
08:15:23 <glen_quagmire> > join $ fmap join  [[[1,2,3], [4]], [[5,6]]] :: [Expr]
08:15:24 <lambdabot>  [1,2,3,4,5,6]
08:15:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5617
08:16:23 <byorgey> > sort [a,d,b,n,w] :: [Expr]
08:16:24 <lambdabot>  [a,b,d,n,w]
08:16:28 <byorgey> hehe
08:16:48 <faxathisia> ooh
08:16:50 <byorgey> > a < e
08:16:52 <lambdabot>  True
08:17:08 <glen_quagmire> > a == a
08:17:09 <lambdabot>  True
08:17:17 <byorgey> > a < (5 :: Expr)
08:17:17 <faxathisia> > sort [(1,a),(5,b),(4,c),(3,d),(2,e)]
08:17:18 <trez> > scanl (+) a [b,c,d] :: [Expr]
08:17:18 <lambdabot>  False
08:17:19 <lambdabot>  [(1,a),(2,e),(3,d),(4,c),(5,b)]
08:17:19 <lambdabot>  [a,a + b,a + b + c,a + b + c + d]
08:17:52 <vincenz> > gcd a b
08:17:53 <rabby> whats haskell's problem with: mix1 dts = [mdts|mdts<-[mdts_|mdts_<-dts],i<-[0..((length dts)-1)]]
08:17:58 <lambdabot> Terminated
08:18:09 <byorgey> > gcd 5 3 :: Expr
08:18:10 <lambdabot>  abs 3 `rem` (abs 5 `rem` abs 3)
08:18:16 <faxathisia> hahaha
08:18:38 <faxathisia> @@ @run @run gcd 5 3
08:18:40 <lambdabot>  1
08:18:43 <glen_quagmire> > (.) :: Expr
08:18:44 <lambdabot>  Couldn't match expected type `Expr'
08:18:44 <faxathisia> @@ @run @run gcd 5 15
08:18:46 <lambdabot>  5
08:18:53 <byorgey> faxathisia: heh, nice!
08:19:35 <byorgey> rabby: could you paste your code along with any errors you are getting on hpaste.org?
08:19:45 <glen_quagmire> > take 3 $ iterate (\x -> "f(" ++ x ++ ")") "x"
08:19:46 <lambdabot>  ["x","f(x)","f(f(x))"]
08:20:10 * faxathisia spots a bug..
08:20:11 <faxathisia> > nubBy(((>1).).gcd)[2..] :: [Expr]
08:20:13 <glen_quagmire> > take 3 $ iterate f :: [Expr]
08:20:14 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
08:20:14 <lambdabot>  Couldn't match expected type `[a]'
08:20:27 <byorgey> > take 3 $ iterate f x :: [Expr]
08:20:28 <lambdabot>  [x,f x,f (f x)]
08:20:31 <faxathisia> oh right, lambdabot is just more generous in PM
08:20:33 <byorgey> faxathisia: what's the bug?
08:20:40 <byorgey> oh
08:20:46 <faxathisia> I though it was doing 6 lines becaues it was Expr
08:21:04 <gbacon> can anyone help with a KDE4 problem? (#kde has been unhelpful)
08:21:15 <byorgey> > 3 ^ 5 :: Expr
08:21:16 <lambdabot>  3 * 3 * (3 * 3) * 3
08:21:19 <cjb> gbacon: No, but hey, you should go try in #apache.
08:21:28 <byorgey> > 3 ^ 10 :: Expr
08:21:29 <lambdabot>  3 * 3 * (3 * 3) * (3 * 3 * (3 * 3)) * (3 * 3)
08:23:05 <byorgey> > span (<e) [a,b,c,d,e,j,k,u] :: ([Expr],[Expr])
08:23:07 <lambdabot>  ([a,b,c,d],[e,j,k,u])
08:24:35 <BMeph> rabby; Are you going to use i somewhere in your list? :)
08:25:35 <Deewiant> @. pl undo [mdts|mdts<-[mdts_|mdts_<-dts],i<-[0..((length dts)-1)]]
08:25:36 <lambdabot> return dts
08:26:51 <rabby> if the input list is [1,2,3], i want it to return: [1,1,1,2,2,2,3,3,3]
08:26:59 <resiak> > foldr f e [a,b,c,d] :: Expr
08:27:01 <lambdabot>  f a (f b (f c (f d e)))
08:27:41 <rabby> there should be n-times each element of the input list; n=length (input-list)
08:27:54 <byorgey> > \xs -> concatMap (replicate (length xs)) $ [1,2,3]
08:27:56 <lambdabot>  Add a type signature
08:28:09 <byorgey> > \xs -> concatMap (replicate (length xs)) xs $ [1,2,3]
08:28:10 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
08:29:07 <mauke> > (\xs -> concatMap (replicate (length xs)) xs) [1,2,3]
08:29:08 <lambdabot>  [1,1,1,2,2,2,3,3,3]
08:29:22 <Botje> @pl (\xs -> concatMap (replicate (length xs)) xs)
08:29:22 <lambdabot> (=<<) =<< replicate . length
08:29:28 <byorgey> eh? why doesn't $ work?
08:29:53 <Deewiant> -> probably binds more loosely
08:30:01 <Botje> byorgey: I think because [1,2,3] would be just an argument to the concatMap
08:30:09 <byorgey> oh, right, \x -> binds everything as far to the right as it can
08:30:13 <Botje> that's what the error suggests
08:30:18 <mauke> > (concatMap =<< replicate . length) [1,2,3]
08:30:34 <lambdabot>  thread killed
08:30:40 <vininim> Aheh
08:30:43 <mauke> > (concatMap =<< replicate . length) [1,2,3]
08:30:57 <lambdabot>  [1,1,1,2,2,2,3,3,3]
08:31:08 <BMeph> rabby: So, basically a ... what mauke wrote out. ;p
08:31:27 <mauke> > ((=<<) =<< liftM replicate length) [1,2,3]
08:31:28 <lambdabot>  [1,1,1,2,2,2,3,3,3]
08:31:37 <BMeph> (\list -> replicate (length list) list)
08:32:00 <byorgey> rabby: if you want to do it with list comprehensions, you could do something like:
08:32:16 <BMeph> Er, concatMat of it, anyway.
08:32:32 <byorgey> > let mix1 dts = concat [ dts | i <- [1..length dts] ]  in mix1 [1,2,3]
08:32:32 <lambdabot>  [1,2,3,1,2,3,1,2,3]
08:32:36 <byorgey> er, oops!
08:32:40 <mauke> > (\xs -> [x | x <- xs, _ <- xs]) [1,2,3]
08:32:41 <lambdabot>  [1,1,1,2,2,2,3,3,3]
08:33:09 <mauke> > (\xs -> [x | x <- xs, _ <- xs]) [1 ..]
08:33:09 <byorgey> > let mix1 dts = concat . transpose $ [ dts | i <- [1..length dts] ]  in mix1 [1,2,3]
08:33:10 <lambdabot>  [1,1,1,2,2,2,3,3,3]
08:33:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:33:32 <Deewiant> @. pl undo mix1 dts = concat . transpose $ [ dts | i <- [1..length dts] ]
08:33:37 <lambdabot> mix1 = join . transpose . ap ((=<<) . const . return) (enumFromTo 1 . length)
08:33:49 <byorgey> > let mix1 dts = concat . transpose $ replicate (length dts) dts  in mix1 [1,2,3]
08:33:51 <lambdabot>  [1,1,1,2,2,2,3,3,3]
08:33:57 <Poker_Player> POKER TOURNAMENT --> EVERYBODY WINS MONEY !
08:33:57 <Poker_Player> http://pokernation.forumotion.com
08:33:57 <lambdabot> Title: Poker Nation
08:34:14 <EvilTerran> bam! that was quick
08:34:17 <byorgey> rabby: hope that's helpful and we haven't totally confused you =)
08:34:25 <byorgey> rabby: feel free to ask if you have more questions
08:34:29 <EvilTerran> > let mix1 xs = const <$> xs <*> xs in mix1 [1,2,3,4]
08:34:29 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]
08:34:47 <byorgey> o_O
08:35:10 <byorgey> oh, I get it.  neat!
08:35:14 <BMeph> w00t, EvilTerran! :)
08:35:19 <rabby> byorgey, please give me some minutes to think about it :-)
08:35:31 <byorgey> rabby: no problem. =)
08:35:34 <Deewiant> > (<*>) =<< (const <$>) $ [1..4]
08:35:35 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]
08:35:50 <mauke> > pure
08:35:56 <lambdabot>  Add a type signature
08:35:56 <Deewiant> now if only const were an operator
08:37:01 <BMeph> Deewiant: Just lift the problem into the Reader monad.
08:37:20 <Deewiant> :-)
08:37:38 <EvilTerran> > (<*>) =<< (<$>) const $ [1,2,3,4]
08:37:39 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]
08:38:14 <glen_quagmire> > map (replicate 4) [1,2,3,4]
08:38:17 <lambdabot>  [[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4]]
08:38:18 <EvilTerran> > ap =<< fmap const $ [1,2,3,4] -- similarly
08:38:19 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]
08:38:26 <glen_quagmire> > join $ map (replicate 4) [1,2,3,4]
08:38:27 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]
08:38:41 <byorgey> rabby: by the way, you should definitely ignore what people are writing now =)
08:38:46 <EvilTerran> > concatMap =<< replicate . length $ [1,2,3,4]
08:38:46 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]
08:38:58 <EvilTerran> we had that already, methinks
08:38:59 <mauke> :t join ((pure <$>) <$> (<*>))
08:39:01 <lambdabot>     Ambiguous occurrence `pure'
08:39:01 <lambdabot>     It could refer to either `Control.Applicative.pure', imported from Control.Applicative
08:39:01 <lambdabot>                           or `Control.Arrow.pure', imported from Control.Arrow
08:39:11 <mauke> :t join ((return <$>) <$> (<*>))
08:39:12 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
08:39:12 <lambdabot>       Expected type: f (a -> b) -> f (a -> b) -> a1
08:39:12 <lambdabot>       Inferred type: f (a -> b) -> f a -> f b
08:40:13 <Deewiant> > (((<*>) =<<) . (<$>)) const [1..4]
08:40:15 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]
08:40:32 <faxathisia> > (((<*>) =<<) . (<$>)) const [1..4] :: [Expr]
08:40:33 <lambdabot>  [1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]
08:40:37 <faxathisia> aww..
08:40:44 <EvilTerran> Expr?
08:40:45 <Deewiant> @ty (((<*>) =<<) . (<$>)) const
08:40:46 <lambdabot> forall (f :: * -> *) a. (Applicative f) => f a -> f a
08:40:57 <faxathisia> EvilTerran, This is cool :D
08:41:07 <Deewiant> > map f [a,b,c] :: [Expr]
08:41:07 <faxathisia> > iterate f x :: [Expr]
08:41:08 <lambdabot>  [f a,f b,f c]
08:41:09 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
08:41:14 <faxathisia> > map fst $ iterate (\(x,y)->(y,x+y)) $ (0,1) :: [Expr]
08:41:15 <lambdabot>  [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1)),1 + (0 + 1) + (0 + 1 + (1 + (0 ...
08:41:19 <EvilTerran> huh
08:41:30 <EvilTerran> that *is* cool
08:41:33 <EvilTerran> ?index Expr
08:41:34 <lambdabot> bzzt
08:41:34 <mux> yes
08:41:42 <mux> I need that SimpleReflect module in my lambdabot
08:42:09 <mux> > until (<0) f x
08:42:13 <lambdabot> Terminated
08:42:15 <mux> > until (<0) f x :: Expr
08:42:19 <lambdabot> Terminated
08:42:38 <mauke> :t join ((<*>) <$> (return <$>))
08:42:39 <lambdabot> forall (f :: * -> *) b. (Applicative f) => f b -> f b
08:42:51 <mauke> > join ((<*>)<$>(return<$>)) "abc"
08:42:53 <lambdabot>  "aaabbbccc"
08:43:09 <vininim> @src (<*>)
08:43:10 <lambdabot> Source not found. You type like i drive.
08:43:17 <Saizan> > (<0) :: Expr -> Bool
08:43:18 <lambdabot>   add an instance declaration for (Typeable Expr)
08:43:22 <mauke> @src Applicative
08:43:22 <lambdabot> class Functor f => Applicative f where
08:43:22 <lambdabot>     pure  :: a -> f a
08:43:22 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
08:43:24 <byorgey> EvilTerran:
08:43:25 <byorgey> EvilTerran:  In addition, we can see the lack of checking for the existence of C libs
08:43:33 <byorgey> EvilTerran: err, sorry
08:43:37 <EvilTerran> what
08:43:49 <byorgey> EvilTerran: http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
08:43:55 <lambdabot> Title: Simple reflection of expressions - 21 thoughts, http://tinyurl.com/2yeszc
08:44:11 <Deewiant> > (join.((<*>)<$>).(<$>))return "abc"
08:44:12 <lambdabot>  "aaabbbccc"
08:44:47 <mauke> someone needs to derive Typeable for Expr
08:46:31 <BMeph> Hmm, would this problem be using ReaderT with lists, or ListT with a reader?
08:48:01 <jaj> Hi!
08:48:04 <Cin> :t undefined
08:48:16 <glen_quagmire> > "jaj" ++ " hi"
08:48:19 <Cin> what happens when `undefined' is given?
08:48:20 <lambdabot> forall a. a
08:48:23 <Cin> > undefined
08:48:25 <lambdabot>  "jaj hi"
08:48:25 <lambdabot>  Undefined
08:48:33 <faxathisia> :t 1 + undefined
08:48:34 <lambdabot> forall t. (Num t) => t
08:48:35 <glen_quagmire> > undefined :: Expr
08:48:36 <lambdabot>  Undefined
08:48:38 <faxathisia> :t reverse undefined
08:48:39 <lambdabot> forall a. [a]
08:48:45 <faxathisia> :t undefined undefined
08:48:46 <lambdabot> forall t. t
08:48:51 <glen_quagmire> > if undefined then 1 else 0
08:48:51 <lambdabot>  Undefined
08:48:57 <Cin> ah, i see. okay.
08:49:14 <jaj> Is it true that the X11 package version 1.4.1 includes functionality from the X11-extras package and makes it obsolete?
08:49:38 <mauke> yes
08:49:54 <daf> exe11ent
08:49:57 <jaj> thanks mauke
08:51:31 <vininim> > iterate (*1337) 1
08:51:33 <lambdabot>  [1,1337,1787569,2389979753,3195402929761,4272253717090457,571200321974994100...
08:52:01 <glen_quagmire> > iterate (*(-1)) 1
08:52:01 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
08:52:15 <glen_quagmire> > sum $ iterate (*(-1)) 1
08:52:22 <mux> > cycle [1,-1]
08:52:24 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
08:52:25 <vininim> thread killed
08:52:27 <lambdabot> Terminated
08:53:06 <mauke> > [a .. b]
08:53:10 <lambdabot>  Exception: not a number
08:53:28 <nornagon> > ['a' .. 'z'] :: [Expr]
08:53:29 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
08:53:41 <glen_quagmire> @src (..)
08:53:41 <lambdabot> Source not found. Just try something else.
08:53:41 <vininim> [a..] :: [Expr]
08:53:46 <glen_quagmire> :t (..)
08:53:47 <lambdabot> parse error on input `..'
08:53:53 <nornagon> > [a..] :: [Expr]
08:53:55 <lambdabot>  Exception: not a number
08:54:23 <faxathisia> > let facs 1=[];facs n=dr n:facs(n`div`dr n) where dr n=(!!0)$filter((==0).(n`mod`))[2..n] in facs 360 :: [Expr]
08:54:27 <lambdabot>  [2,2,2,3,3,5]
08:54:28 <glen_quagmire> > ['a' .. 'z']
08:54:29 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
08:54:54 <glen_quagmire> > ['a' .. 'z'] :: [Expr]
08:54:54 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Char'
08:55:00 <glen_quagmire> > ['a' .. 'z'] :: Expr
08:55:01 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
08:55:15 <glen_quagmire> > [a .. z] :: [Expr]
08:55:16 <lambdabot>  Exception: not a number
08:55:37 <glen_quagmire> > global_set_exception(0); [a .. z] :: [Expr]
08:55:38 <lambdabot>  Parse error at ";" (column 24)
08:55:43 <ricky_clarkson> [1.5..2.5]
08:55:51 <ricky_clarkson> > [1.5..2.5]
08:55:52 <lambdabot>  [1.5,2.5]
08:55:56 <Deewiant> > [1.5,1.6..2.5]
08:55:57 <lambdabot>  [1.5,1.6,1.7000000000000002,1.8000000000000003,1.9000000000000004,2.00000000...
08:56:03 <bos> @seen CosmicRay
08:56:03 <lambdabot> I haven't seen CosmicRay.
08:56:05 <Deewiant> hooray for floats
08:56:15 <ricky_clarkson> > [-1.5..0.5]
08:56:16 <glen_quagmire> > [Inf .. Inf]
08:56:17 <lambdabot>  [-1.5,-0.5,0.5]
08:56:17 <lambdabot>   Not in scope: data constructor `Inf'
08:56:24 <ricky_clarkson> > [-1.5...5]
08:56:25 <lambdabot>   Not in scope: `...'
08:56:28 <EvilTerran> > [1/0 ..]
08:56:29 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
08:56:30 <ricky_clarkson> > [-1.5.. .5]
08:56:31 <lambdabot>  Parse error at ".5]" (column 9)
08:56:32 <EvilTerran> > [-1/0 ..]
08:56:33 <lambdabot>  [-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infinity,-Infi...
08:56:35 <Deewiant> > [Infinity..Infinity]
08:56:36 <lambdabot>  Parse error at "Infin..." (column 2)
08:56:39 <glen_quagmire> > [Infinity .. Infinity]
08:56:40 <lambdabot>   Not in scope: data constructor `Infinity'
08:56:45 <Deewiant> > [1/0 .. 1/0]
08:56:47 <lambdabot>  [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Inf...
08:56:50 <catface> can you have a function with different definitions for different types?
08:56:53 <Deewiant> > [0/0 .. 1/0]
08:56:54 <lambdabot>  []
08:56:56 <mauke> > repeat "Developers"
08:56:57 <lambdabot>  ["Developers","Developers","Developers","Developers","Developers","Developer...
08:57:02 <glen_quagmire> > [ 1/0 .. 1]
08:57:03 <lambdabot>  []
08:57:03 <EvilTerran> catface, indeed; that's what typeclasses are for
08:57:09 <faxathisia> ..lol
08:57:12 <EvilTerran> > [0/0 ..]
08:57:13 <lambdabot>  [NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN...
08:57:24 <glen_quagmire> > repeat f :: Expr
08:57:24 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
08:57:26 <vininim> > repeat "DESU"
08:57:28 <lambdabot>  ["DESU","DESU","DESU","DESU","DESU","DESU","DESU","DESU","DESU","DESU","DESU...
08:57:29 <glen_quagmire> > repeat f :: [Expr]
08:57:30 <lambdabot>  [f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f...
08:57:45 <glen_quagmire> > [f .. (f+2)] :: [Expr]
08:57:46 <ricky_clarkson> > fix ("new Runnable(){public void run(){"++)
08:57:46 <lambdabot>  Exception: not a number
08:57:47 <lambdabot>  "new Runnable(){public void run(){new Runnable(){public void run(){new Runna...
08:57:55 <Deewiant> ew
08:57:59 <faxathisia> heh
08:58:10 <vincenz> seriously
08:58:12 <vincenz> cut the spam
08:58:22 <glen_quagmire> > zipWith (++) (repeat "BAKA") (repeat ("DESU")
08:58:22 <lambdabot> Unbalanced parentheses
08:58:32 <glen_quagmire> > zipWith (++) (repeat "BAKA") (repeat "DESU")
08:58:33 <lambdabot>  ["BAKADESU","BAKADESU","BAKADESU","BAKADESU","BAKADESU","BAKADESU","BAKADESU...
08:58:37 <vininim> shinny [Expr] *_*
08:58:42 <vincenz> glen_quagmire: please use pm
08:58:45 <vininim> err Expr
09:01:49 <faxathisia> This is fun http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.TypesSummerSchool2007
09:01:51 <lambdabot> Title: 28 The Agda Wiki - Types Summer School 2007 4b, http://tinyurl.com/yuktth
09:02:40 <catface> can you have different functions for different *combinations* of types?
09:03:28 <RayNbow> > ("glen_quagmire" ++ "ã•ã‚“") ++ "ã¯" ++ "ã°ã‹ã§ã™"  -- UTF8 test
09:03:29 <lambdabot>  "glen_quagmire\12373\12435\12399\12400\12363\12391\12377"
09:03:35 <RayNbow> ah crap :p
09:03:52 <mauke> test successful
09:04:03 <Japsu> "Ã¤"
09:04:06 <glen_quagmire> i heard ghci don't do unicode
09:04:06 <Japsu> > "Ã¤"
09:04:08 <lambdabot>  "\228"
09:04:25 <Japsu> :o
09:04:25 <allbery_b> keep in mind @run isn't ghci
09:04:40 <mauke> ghci does do unicode
09:04:43 <allbery_b> but it looks to me like it succeeded; it's just that the output is in \xx format
09:04:49 <EvilTerran> catface, if i understand you right, yes, but it requires a very common extension
09:04:52 <mauke> > length "â‚¬"
09:04:53 <lambdabot>  1
09:04:54 <allbery_b> (unicode codepoints)
09:04:58 <EvilTerran> ("multi-parameter type classes")
09:05:17 <faxathisia> :t (<*>)
09:05:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:05:24 <faxathisia> map f as = vec f <*> as
09:05:46 <Deewiant> @free (<*>)
09:05:47 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
09:06:09 <catface> thanks
09:06:16 <mauke> @free it :: (Applicative f) => f (a -> b) -> f a -> f b
09:06:17 <lambdabot> Extra stuff at end of line
09:06:23 <mauke> @free it :: f (a -> b) -> f a -> f b
09:06:23 <lambdabot> Extra stuff at end of line
09:07:45 <vincenz> @join #oasis
09:17:20 * allbery_b wonders if LB should have an admin command to append something to the startup rc it used.  those @joins and maybe @admin / @ignore are nice candidates
09:18:46 <Lemmih> JohnMeacham: ping.
09:19:16 <mauke> you killed him!
09:19:35 <mauke> .oO( is this the infamous Ping of Death? )
09:19:53 <czakey> ;d
09:20:04 <Lemmih> Oops.
09:20:11 <allbery_b> heh
09:27:32 <cjb> 'lo.
09:28:16 <mauke> @lusers
09:28:16 <lambdabot> Maximum users seen in #haskell: 463, currently: 443 (95.7%), active: 24 (5.4%)
09:30:48 <byorgey> hi cjb
09:31:07 <cjb> hey hey.  I just read the DisTract source.
09:31:51 <byorgey> what's DisTract?
09:32:13 <cjb> it's a distributed bug tracker.
09:32:20 <cjb> (written partially in Haskell)
09:32:29 <daf> intriguing
09:32:35 <cjb> the idea is that you get the bug state for free when you check out source
09:34:02 <cjb> but this one's a sort of weird bug tracker, in that it only has a web interface, and the interface only works in Firefox.
09:34:14 <daf> oh, boo
09:34:21 <cjb> so seems like the first thing to do is add console client support
09:34:40 <daf> naturally
09:34:49 <cjb> which shouldn't be that hard, because that's the haskell side of the code rather than the javascript.
09:35:42 <cjb> anyway!  this is not really what I want to do, because I want to work on Bugs Everywhere which is the same but written in python and with console/web/native UI interfaces.  but people here were chatting about hacking on it last night, and I was curious to see what the source looks like.
09:48:34 <dons> ?yow
09:48:34 <lambdabot> I'm having a tax-deductible experience!  I need an energy crunch!!
09:53:26 <byorgey> hiya dons
09:53:39 <dons> hey
09:54:00 <unenough> so how is haskell chocolatemorphic?
09:54:12 <unenough> or cocoamorphic for short
09:54:24 <byorgey> dons: I hope to meet you while I'm in Portland this weekend if you've got some time =)
09:54:40 <dons> oh, what time do you arrive?
09:54:52 <dons> we could grab some of the haskell hackers and go to the pub
09:55:04 <byorgey> dons: I arrive Thursday evening and leave early Sunday morning
09:55:08 <byorgey> dons: yeah, that would be great
09:55:15 <byorgey> dons: I'm staying with Tim Chevalier
09:55:34 <dons> oh cool.
09:55:39 <dons> yeah, let's do something.
10:09:59 <proq> vincenz: just wondering.  I'm just getting started on haskell
10:13:03 <vincenz> proq: ok :)
10:29:46 <Le-Chuck_IT1> hi all
10:29:56 <Le-Chuck_IT1> I am in trouble with the type system
10:30:08 <faxathisia> hehe, why is that?
10:30:45 <Le-Chuck_IT1> I want to define a function that takes (a -> b) as an argument, then it operates recursively on (a -> t b) where t is a constructor
10:31:50 <faxathisia> What does it do?
10:31:52 <Le-Chuck_IT1> of course the type system does not agree, however in my mind the function will work with any types a and b so a -> tb should be fine
10:32:21 <Le-Chuck_IT1> where's the pastebin, I don't remember?
10:32:23 <faxathisia> you mean to recurse with at larger type? so you get a -> t (t (t (t b))) eventually?
10:32:30 <Vq^> @where hpaste
10:32:31 <lambdabot> I know nothing about hpaste.
10:32:31 <Le-Chuck_IT1> yes
10:33:03 <byorgey> Le-Chuck_IT1: so what type should this function have?
10:33:14 <faxathisia> When you use a function recursively it has to be of the same type as it was called, I think it's so that type checking doesn't have to take forever
10:33:28 <pchiusano> is it true in general that scanr f z xs = scanl (flip f) z (reverse xs)
10:34:19 <byorgey> > scanr f z [1,2,3] :: [Expr]
10:34:23 <lambdabot>  [f 1 (f 2 (f 3 z)),f 2 (f 3 z),f 3 z,z]
10:34:29 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5618
10:34:34 <Le-Chuck_IT1> here it is
10:34:39 <byorgey> > scanl (flip f) z [3,2,1] :: [Expr]
10:34:40 <lambdabot>  [z,f 3 z,f 2 (f 3 z),f 1 (f 2 (f 3 z))]
10:35:03 <byorgey> pchiusano: no =)
10:35:12 <pchiusano> well, one is just the reverse of the other
10:35:19 <GrayShade> what about infinite lists?
10:35:20 <byorgey> yes, that seems to be true
10:35:25 <Le-Chuck_IT1> error is on last line
10:35:36 <Vq^> pchiusano: not exactly
10:35:38 <dolio> > reverse (scanl (flip f) z [3,2,1]) :: [Expr]
10:35:40 <lambdabot>  [f 1 (f 2 (f 3 z)),f 2 (f 3 z),f 3 z,z]
10:35:55 <Vq^> > scanr (+) 0 [1..8]
10:35:56 <lambdabot>  [36,35,33,30,26,21,15,8,0]
10:36:04 <Vq^> > reverse $ scanl (flip (+)) 0 [1..8]
10:36:05 <lambdabot>  [36,28,21,15,10,6,3,1,0]
10:36:39 <dolio> > reverse $ scanl (flip (+)) 0 [8,7..1]
10:36:45 <lambdabot>  [36,35,33,30,26,21,15,8,0]
10:37:16 <byorgey> Le-Chuck_IT1: there is no 'y' in the result type
10:37:19 <pchiusano> erm, so what would definition of scanr in terms of scanl be (for finite lists)
10:37:40 <Le-Chuck_IT1> byorgey: that's ok, P is a function which represents a partition, only its kernel is relevant
10:37:44 <byorgey> Le-Chuck_IT1: that's not the problem per se, but it seems fishy
10:37:58 <Le-Chuck_IT1> kern will be a function of type (a -> b) -> [[a]]
10:38:01 * Vq^ missed that the input got reversed
10:38:24 <dolio> scanr f z xs = reverse (scanl (flip f) z (reverse xs))
10:38:25 <pchiusano> scanr f z l = reverse $ scanl (flip f) z (reverse l)
10:38:33 <pchiusano> heh
10:38:42 <byorgey> Le-Chuck_IT1: I don't think such a function is possible.  how would you implement kern?
10:39:11 <GrayShade> pchiusano: it won't work if l is infinite
10:39:25 <pchiusano> GrayShade: sure
10:39:38 <byorgey> Le-Chuck_IT1: if the input to kern has the general type (a -> b), there's nothing really useful you can do with it.
10:39:39 <dolio> The double reverse is the clue. :)
10:39:41 <Le-Chuck_IT1> well, now I am cheating, and defined it as "undefined", however I would like to create a type class of finite types, where I will have an enumeration
10:39:44 <byorgey> Le-Chuck_IT1: you need to know more about the types a and b.
10:39:52 <luqui> I think it wold have to be kern :: (Eq b) => (a -> b) -> [[a]] or something
10:39:57 <Le-Chuck_IT1> yes I see
10:40:10 <Le-Chuck_IT1> for now I am concentrating on understanding how partref should work
10:40:11 <byorgey> Le-Chuck_IT1: ah, so (Finite a, Eq b) => (a -> b) -> [[a]] ?
10:40:15 <Le-Chuck_IT1> yes
10:40:16 <byorgey> Le-Chuck_IT1: ok
10:40:31 * luqui wonders what Finite would look like
10:40:54 <Le-Chuck_IT1> class Finite t where enum :: t -> [t] ?
10:41:00 <Le-Chuck_IT1> sorry
10:41:03 <Le-Chuck_IT1> where enum :: [t]
10:41:24 <luqui> makes sense (and just hope it isn't lying about being finite :-)
10:42:34 <byorgey> Le-Chuck_IT1: oh, the problem is the result type [[x]]
10:42:43 <Le-Chuck_IT1> byorgey: ?
10:43:03 <byorgey> if you call  partref (fmap f) (fmap p)  then it must return a result type of [[t x]]
10:43:13 <byorgey> but you are giving it as the result of the original partref call
10:43:22 <byorgey> so [[x]] == [[t x]] which is not possible
10:43:45 <Le-Chuck_IT1> hmm
10:43:47 <Le-Chuck_IT1> that's true
10:44:10 <Le-Chuck_IT1> I could as well compose f with fmap f
10:44:12 <Le-Chuck_IT1> and with fmap p
10:44:22 * Le-Chuck_IT1 types
10:46:55 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5618#a1
10:47:09 <Le-Chuck_IT1> it does not work, obviously
10:47:57 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5618#a2
10:48:05 <Le-Chuck_IT1> I added the type error
10:55:45 * Le-Chuck_IT1 will come back later 
10:56:11 * Le-Chuck_IT1 thinks it's not so easy to get rid of himself
10:56:15 <Le-Chuck_IT1> bye see you later
11:00:47 <dmead> > let f x = 1 + x; foo = f . fmap in foo [1..10]
11:00:49 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
11:01:02 <dmead> > let f x = 1 + x; foo = f . map in foo [1..10]
11:01:03 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
11:01:12 <dmead> > let f x = 1 + x; foo =  map . f in foo [1..10]
11:01:13 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
11:01:16 <dmead> > let f x = 1 + x; foo =  fmap . f in foo [1..10]
11:01:17 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
11:01:18 <dmead> :/
11:01:51 <nayru> hmm. i'm beginning to understand how single functions are made... and i can always look that up in books.. but my brain is still wired for C... so i'm wondering how you construct anything bigger than hello world stuff? like... do you make a function C that takes a function B as parameter which takes a function A as param? how is the dataflow?
11:02:17 <faxathisia> function a b = ...
11:02:30 <faxathisia> it takes a function a and a function b as parameters
11:02:41 <dons> nayru: via function application and composition
11:02:47 <dmead> nayru, you have to adjust your decomposition skills for functional programming... it takes some getting used to
11:03:07 <dmead> problem decomposition that is
11:03:08 <dons> perhaps look at some example programs too?
11:03:34 <nayru> hmm, i see. yes, i guess i should just start reading small programs, forcing my brain to rewire
11:03:55 <dons> well, in C you just call a lot of top level functions
11:03:59 <dons> and mutate a bit of state.
11:04:05 <dons> its the same in Haskell, but without the mutation
11:04:09 <vininim> it semms all the goodies paradigm transformers are only in deadwood
11:04:27 * dons tries to parse vininim's sentence
11:04:31 <BMeph> > let f x = 1 + x; foo =f map  f in foo [1..10]
11:04:31 <conal> functional programming is hard after imperative programming but simple after imperative deprogramming
11:04:32 <lambdabot>        add an instance declaration for (Num ((b -> b) -> [b] -> [b]))
11:04:32 <lambdabot>     In ...
11:04:47 <BMeph> > let f x = 1 + x; foo = fmap  f in foo [1..10]
11:04:53 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
11:05:14 <nayru> dons: hmm. the way i think now.. if i want to make a simple parser for example... i would make a function "readText" and then i apply a bunch of other functions to that. is that "function application"?
11:05:25 <BMeph> dmead: application vs. composition. :)
11:05:35 <vininim> heh, it seems there are thousands of deadwood books dealing with pratical haskell (in an educational way) and the net is more about writing compilers =P
11:05:41 <nayru> dons: readText would read the raw input and return it in some form
11:05:56 <dons> vininim: ?
11:06:07 <dons> the net is about writing compilers?
11:06:15 <vininim> most of net information
11:06:26 <dons> really? have you been to haskell.org?
11:06:40 <dons> e.g. http://haskell.org/haskellwiki/Blog_articles
11:07:04 <vininim> oh, never read the blog section... thanks.
11:07:09 <nayru> haskell.org is amazing. it's even better than python.org in my opinion
11:07:23 <nayru> i'm still too stupid to grok it though
11:08:37 <BMeph> nayru: If you haven't written a blog telling everyone about how Haskell is dumb because you can't assign values to variables, then you're not too stupid. ;)
11:08:45 <BMeph> You're learning. :)
11:09:30 <nayru> BMeph: heheh. i have nothing negative to say about haskell... i'm only trying to write very simple things... but when they work, my C code suddenly feels so fragile
11:09:40 <dmead> BMeph, ah i see
11:09:58 <BMeph> nayru: Heh-heh. Then you're definitely learning! ;)
11:11:06 <dolio> You can assign to variables. It's just that you can only do it once. :)
11:11:41 <slarba> I'd say you can name expressions
11:11:52 <slarba> it's not "variable assignment"
11:11:55 <dolio> :)
11:12:02 <slarba> :)
11:12:37 * BMeph goes to get a snack
11:14:03 <Baughn> "Variable assignment" implies an action, yes. Keep that to <- :)
11:14:37 <dolio> Yeah, you could read that as assignment, too, although that's really just shadowing.
11:14:47 <nayru> i think of variables as functions that always return whatever you make them
11:14:49 <Baughn> It's an action, at least
11:15:10 <nayru> like x = 5 in my head is int x () { return 5; }
11:15:33 <Baughn> And "let x = map succ"? ;)
11:16:00 <idnar> function x () { return map(succ); }
11:16:03 <idnar> ;)
11:17:11 <slarba> yeah, let can be thought as let x = y in ...  =>   (\x -> ...) y
11:17:41 <dolio> Nah, it's clearly int *x(int * l) { int i; for(i = 0;i < OH_NOES_WE_DONT_HAVE_ARRAY_BOUNDS;i++) { l[i]++; } }
11:17:50 <slarba> dolio: :D
11:17:51 <slarba> right
11:18:09 <faxathisia> lol
11:18:09 <dolio> Oops, I guess that's not quite right.
11:18:19 <dons> #define OH_NOES_WE_DONT_HAVE_ARRAY_BOUNDS True
11:18:24 <dolio> Since it doesn't return a new array, just modifies the original.
11:18:35 <slarba> a week or so ago I wrote a small compression utility both in Haskell and C
11:18:49 <slarba> C version took me a whole weekend to make it work properly
11:18:59 <slarba> Haskell version was a couple of hours
11:19:00 <faxathisia> nayru, Have you met closures yet?
11:19:00 <fons> the haddock documentation of Arrays sucks
11:19:04 <dolio> We'll just add a 'return l;' at the end, and pretend we're returning something different.
11:19:10 <Baughn> slarba: How's the performance?
11:19:15 <Lemmih> What timezone is JohnMeacham in?
11:19:22 <slarba> and the haskell version was only one second slower than the c version
11:19:27 <fons> there are no type signatures in Data.Array
11:19:33 <slarba> (5 seconds for the haskell version, 4 for the c)
11:19:37 <dons> slarba: cool
11:19:48 <faxathisia> nayru, For example,  let plus x = \y -> y + x in map (plus 3) [4,7,3,2]
11:20:02 <Baughn> slarba: Nice. That answers a problem I was pondering quite neatly.
11:20:03 <slarba> (for one particular file)
11:20:04 <hpaste>  thetallguy pasted "speed bug reproduced" at http://hpaste.org/5619
11:20:09 <fons> plus Data.IArray is not really helpful if you want to use the interface to implement your own array type using the interface
11:20:21 <slarba> what's that in percentages?
11:20:27 <Baughn> slarba: Now make the haskell version multi-threaded. ;)
11:20:35 <fons> Data.array is not even present in the documentation!
11:20:42 <Baughn> slarba: ..25% slower
11:20:45 <dolio> fons: Yeah, you need to read Data.Array.Base or GHC.Array or something.
11:20:45 <fons> Data.Array.Base I meant
11:21:05 <thetallguy> dons: the answer from last night.  Moving the filter functions into a separate file reproduced the lack of optimization.  So, yes, a cross module bug, I think.
11:21:07 <slarba> Baughn: well... the utility used huffman coding and that doesn't parallelize well
11:21:11 <slarba> AFAIK
11:21:14 <dons> thetallguy: ah ha!
11:21:33 <dons> thetallguy: oh, right. so ann {-# INLINE #-} would fix it?
11:21:47 <thetallguy> dons: this seems to be the most common source of bugs.
11:21:52 <thetallguy> dons: I'll try that.
11:21:54 <DRMacIver> Hm. Any readily accessible libraries using uniplate? I'd like to see some instances of its use in the wild.
11:22:06 <dons> thetallguy: yeah, i think this one is known. but do submit it.
11:22:06 <nayru> faxathisia: closures? no
11:22:17 <dons> there are other issues with cross-module inlining messing up optimisations
11:22:20 <Baughn> slarba: I haven't looked at it myself, but it should be possible. At the least, you can slice the input into appropriately large sections and compress them independently.
11:22:28 <dons> ghc isn't quite the whole program compiler we sometimes think
11:22:39 <slarba> Baughn: hmm
11:22:49 <nayru> faxathisia: do you mean stuff like "a * 2 where a = ..." ?
11:22:55 <DRMacIver> I briefly wondered if you could do interesting things with an mlton backend to ghc.
11:23:08 <DRMacIver> I suspect it would be more work to get working than it's worth though.
11:23:23 <slarba> Baughn: but yes, I've had poor success with some attempts to parallelize things
11:23:24 <faxathisia> nayru, Well does this example make sense?  let plus x = \y -> y + x in map (plus 3) [4,7,3,2]
11:23:26 <Baughn> slarba: Of course, that would be easy in C as well. What would be better is an optimization that /doesn't/ require changes to the compression method, yet still scales to arbitrary numbers of CPUs
11:23:27 <slarba> except mergesort :D
11:24:12 <Baughn> slarba: You need to parallelise in larger blocks. Setting up a parallel computation costs.. less in haskell than most languages, but it's by no means free.
11:24:25 <slarba> Baughn: yes. but that's the problem
11:24:28 <Baughn> slarba: So you ensure that each thread has enough work to make the setup cost trivial
11:24:52 <slarba> it requires quite a lot of work to chop things up to large chunks enough to process them parallel
11:25:16 <thetallguy> dons: yes, INLINE fixes it.  Thanks for the hint.
11:25:19 <DRMacIver> Baughn: Especially given that although it costs less it doesn't gain you much more. You're not going to get much benefit out of more threads than cores.
11:25:19 <slarba> and the idea of separating algorithm from dynamic behavior is... umm
11:25:31 <slarba> ...somehow lost
11:25:44 <dons> thetallguy: sounds like time for a bug report. we want to get rid of these issues.
11:25:49 <Baughn> slarba: I'm using "algorithm" in a loose sense here
11:25:56 <slarba> Baughn: ok
11:26:18 <Baughn> slarba: Hang on. You're using huffman coding, which requires you to build a dictionary over your entire input, right?
11:26:35 <slarba> but still, the haskell way to parallelization is amazingly beautiful
11:26:39 <Baughn> slarba: Then you *have* to chop it into blocks if you don't want to run out of memory. Not for small input files, but performance doesn't really matter for those anyway.
11:26:52 <slarba> Baughn: yeah, there's adaptive version of it but I'm using the plain one
11:27:35 <dons> are you parallelising with `par` or explicit communication?
11:27:37 <slarba> Baughn: run out of memory?
11:27:42 <slarba> dons: par yes
11:27:59 <slarba> Baughn: the utility runs in constant memory no matter how large the input file is :)
11:28:09 <slarba> Baughn: but the file is read twice
11:28:12 <Baughn> slarba: Hum. Two-p.. right.
11:28:46 <nayru> faxathisia: hmm, i suppose it's like an anonymous function in a let-statement that adds 3 to all the elements in the list... i find the use of x as a parameter and y as a parameter with another syntax a little confusing though
11:28:48 <slarba> first pass resolves the occurrence frequency of each byte
11:29:02 <slarba> then the tree is built and final pass will encode it
11:29:32 <Baughn> slarba: As a test, you could try chopping the file into multiple pieces using bin/split, compressing them separeately, and see how much worse the result is. (Well, it might be better)
11:30:05 <slarba> Baughn: yeah but you need to store the decoding tree for each block
11:30:12 <Baughn> slarba: Yes
11:30:14 <slarba> but yes, for chunks large enough that could work
11:31:32 <Baughn> Beyond that, you're basically counting the frequency of each token in the first pass, right?
11:32:00 <Baughn> No reason you can't do /that/ in chunks too, and sum it up at the end. The summing would take essentially no time, so..
11:32:47 <Baughn> ..assuming the tokens are constant-sized, you should be able to do the same sort of thing on the second pass
11:33:19 <slarba> true
11:33:22 <Baughn> slarba: The fun bit wuld be assuring that disk i/o is still linear. :)
11:33:31 <slarba> heh :))
11:33:39 <nayru> faxathisia: what part of that was a closure? the anonymous function?
11:34:58 <faxathisia> nayru, this bit (\y -> y + x), closes over x, so you can make a whole class of functions
11:35:50 <slarba> hmm. zlib does not compile with ghc6.8.2... ghc-asm missing
11:36:02 <slarba> zlib-0.4.0.2
11:36:03 <dons> slarba: hmm
11:36:09 <dons> what arch?
11:36:09 <slarba> wth
11:36:27 <slarba> Darwin Mars2.local 9.2.0 Darwin Kernel Version 9.2.0: Tue Feb  5 16:13:22 PST 2008; root:xnu-1228.3.13~1/RELEASE_I386 i386
11:36:39 <dons> maybe you need to ask for -fvia-C
11:37:31 <slarba> dons: yeah that helped
11:37:36 <slarba> removed the -fvia-C
11:37:37 <slarba> thx
11:37:42 <pjd> nayru: plus x = (x+), plus x = \y -> (x+y), plus = \x y -> (x+y), plus = \x
11:38:00 <pjd> err, plus = \x -> \y -> (x+y)
11:38:30 * BMeph comes back, like the cat in that song...
11:38:33 <pjd> nayru: those are all increasingly desugared syntax for the same thing, if it helps
11:40:33 <ikegami--> hello, I have a question about the definition of Int in the Haskell98 report
11:42:27 <nayru> pjd: aah, i like the 3rd example best
11:42:37 <sarehu> ikegami--: don't ask to ask; ask
11:43:05 <ikegami--> In the Haskell98 report, they say 'The finite-precision integer type Int covers at least the range [ - 2^29, 2^29 - 1].'
11:43:23 <ikegami--> However, I've not found the reason.
11:43:27 <nominolo> @seen byorgey
11:43:28 <lambdabot> byorgey is in #oasis, #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 14m 2s ago.
11:43:38 <dons> ikegami--: so in practice its Word-sized
11:43:40 <byorgey> hi nominolo
11:43:47 <dons> but they reserve the right to use tag bits
11:43:54 <ikegami--> aha
11:44:01 <nominolo> byorgey: hi, so i did these undo-experiments
11:44:03 <dons> nhc98 uses one bit to distinguish pointers from non-pointers
11:44:04 <ikegami--> I see
11:44:07 <nominolo> byorgey: it's rather sophisticated
11:44:11 <byorgey> nominolo: ah, cool
11:44:16 <ikegami--> thanks dons and sarehu
11:44:17 <dons> > maxBound :: Int
11:44:19 <nominolo> byorgey: i couldn't come up with a theory how it works yeet
11:44:26 <lambdabot>  2147483647
11:44:38 <byorgey> nominolo: when you say 'sophisticated', what do you mean?
11:44:45 <nominolo> byorgey: there seem to be some cases where you cannot undo all your changes, but i can't tell exactly when
11:44:49 <dolio> > 2^31 - 1
11:44:52 <sarehu> 'writeArray' doesn't work on the gtk2hs PixbufData arrays   :-O
11:44:57 <lambdabot>  2147483647
11:44:59 <byorgey> nominolo: can you undo changes you've made even after others have made further changes?
11:45:07 <nominolo> byorgey: yes
11:45:17 <wagle_home> > 2^31 - 1 :: Int
11:45:18 <lambdabot>  2147483647
11:45:38 <wagle_home> > 2^31 :: Int
11:45:38 <nominolo> byorgey: but if both people undo and redo then some ordering might get messed up
11:45:39 <lambdabot>  -2147483648
11:45:46 <awesame> so I've got a data type that I use to switch between a bunch of different static info
11:45:47 <wagle_home> duh
11:45:48 <awesame> like this:
11:45:50 <byorgey> nominolo: ah, ok, that was going to be my next question =)
11:46:00 <awesame> data Language = C | Cpp | D | Haskell
11:46:21 <awesame> and then I've got a pile of functions like this one:
11:46:37 <nominolo> byorgey: like A types "foo" B types "bar" the A types "baz" then both undo and A does 2x redo and B does redo you get "foobazbar"
11:46:38 <awesame> langLibs lang = case lang of
11:46:42 <nominolo> or some variation thereof
11:46:51 <awesame> C -> ["libfoo", "libbar"]
11:46:53 <awesame> Cpp -> ...
11:46:54 <awesame> etc
11:47:01 <byorgey> nominolo: ok, that makes sense.  that is the most difficult problem that I know of.  I'm trying to figure out how to solve it =)
11:47:07 <awesame> is this the idiomatic way to do this kind of thing?
11:47:26 <awesame> in python I would have a dict for each language, and pass that around
11:47:27 <nayru> is function composition just a notation for function application?
11:47:28 <byorgey> nominolo: what if A types "foo", and B deletes if, and A tries to undo?
11:47:37 <nominolo> byorgey: i'm not sure it needs to be solved
11:47:37 <byorgey> um, B deltes *it
11:47:53 <byorgey> nominolo: you're right, it might not
11:47:54 <nominolo> byorgey: then nothing happens
11:48:05 <nominolo> if your text is gone nothing happens
11:48:06 <byorgey> nominolo: and then what if B undoes after that?
11:48:14 <nominolo> then it belongs to B
11:48:21 <byorgey> and it comes back?
11:48:26 <nominolo> yes
11:48:28 <byorgey> hm, interesting
11:48:30 <nominolo> but the owner changed
11:48:35 <byorgey> I see
11:49:19 <byorgey> nominolo: thanks, this is very interesting =)
11:49:44 <nominolo> byorgey: if you want you can design some experiments and i can conduct them :)
11:50:05 <byorgey> nominolo: ok, thanks, I'll let you know if I have any for you to try =)
11:50:57 <byorgey> nominolo: you've already covered the most important ones that come to mind.
11:51:24 <nominolo> byorgey: did you read the last entry of this one? http://reddit.com/r/programming/info/65i3p/comments/c02wg1c
11:51:43 <byorgey> nominolo: actually, the one other thing that occurs to me is what happens when two people start typing in exactly the same location simultaneously
11:51:53 <hpaste>  thetallguy annotated "speed bug reproduced" with "not so clear it's a module boundary bug" at http://hpaste.org/5619#a2
11:52:14 <thetallguy> dons: the picture is a bit murkier now.
11:52:31 <nominolo> byorgey: hm, right, i didn't specifically test that.  there is some rule how the cursor moves when someone edits below you
11:52:44 <nominolo> byorgey: i think it stays where it is as long as it can
11:53:23 <non_socialist> hm trying to start happs and kaboom /root/.SearchPath/darcs_get_--partial_--tag=0.9.1.2_http_happs.org-repos-HAppS-IxSet/HAppS-IxSet/src/HAppS/Data/IxSet.hs:140:4:     `startState' is not a (visible) method of class `StartState'
11:53:26 <nominolo> so if they both start typing abc and def at the same time you get "abcdef" or "defabc" depending on who starts first
11:53:32 <non_socialist> :(
11:53:35 <ikegami--> Then, a Haskell interpreter or compiler at the /64-bit/ CPU may return another value about 'maxBound::Int'?
11:53:43 <byorgey> nominolo: yeah, that's what should happen
11:53:51 <thetallguy> dons: Hmm... ignore that for now.
11:53:59 <dons> ikegami--: yes. it will return 9223372036854775807
11:54:12 <ikegami--> And do programmers have to check maxBound/minBound everywhere
11:54:13 <dons> ikegami--: use Int32 or Int64 for precise width
11:54:16 <dons> nope.
11:54:24 <dons> since you use Integer if you care about overflow
11:54:26 <byorgey> nominolo: that feature is not very hard to implement, I don't think.  and it has more to do with the editor itself than the underlying theory.
11:54:34 <ikegami--> hmm
11:54:37 <byorgey> i.e. keeping the cursor in the right place.
11:54:48 <dons> or explicitly use the width you require. Int64, for example
11:55:02 <nominolo> byorgey: i didn't test it, but i think that would happen
11:55:07 <litb> hallo there
11:57:27 <glen_quagmire> data A = A (Int -> Int) deriving (Show); instance Show A where show (A _) = "A (Int -> Int)"; A id;  is this useful somehow?
11:58:11 <oerjan> glen_quagmire: you cannot have both deriving and instance
11:58:36 <glen_quagmire> oh right i deleted deriving (Show)
11:58:46 <oerjan> other than that, it's almost what lambdabot has for ->
11:58:59 <glen_quagmire> @src (->)
11:58:59 <lambdabot> Source not found. That's something I cannot allow to happen.
11:59:08 <oerjan> > ('a':)
11:59:09 <lambdabot>  <[Char] -> [Char]>
11:59:14 <oerjan> i mean the instance
11:59:20 <oerjan> (uses Typeable)
11:59:42 <Deewiant> > (a:)
11:59:43 <lambdabot>   add an instance declaration for (Typeable Expr)
12:00:18 <oerjan> Expr?
12:00:21 <oerjan> > a
12:00:22 <lambdabot>  a
12:00:30 <oerjan> O_O
12:00:31 <Deewiant> > map f [a,b,c]
12:00:32 <lambdabot>  Add a type signature
12:00:35 <oerjan> > b
12:00:35 <Deewiant> > map f [a,b,c] :: [Expr]
12:00:37 <lambdabot>  b
12:00:37 <lambdabot>  [f a,f b,f c]
12:00:39 <glen_quagmire> oh i can do :  f (A a) = a 2
12:00:42 <Deewiant> @where simplereflect
12:00:43 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
12:00:44 <Deewiant> oerjan: ^
12:00:49 <glen_quagmire> f (A (+2)) ==> 4
12:01:09 <nornagon> > iterate (*(-1)) 1
12:01:12 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
12:01:18 <nornagon> > iterate (*(-1)) 1 :: [Expr]
12:01:21 <lambdabot>  [1,1 * negate 1,1 * negate 1 * negate 1,1 * negate 1 * negate 1 * negate 1,1...
12:02:06 <Baughn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs :: [Expr]
12:02:07 <lambdabot>  [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1)),1 + (0 + 1) + (0 + 1 + (1 + (0 ...
12:02:13 <nominolo> > scanl (+) 0 [3..] :: [Expr]
12:02:16 <lambdabot>  [0,0 + 3,0 + 3 + 4,0 + 3 + 4 + 5,0 + 3 + 4 + 5 + 6,0 + 3 + 4 + 5 + 6 + 7,0 +...
12:03:34 <nominolo> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs :: [Expr]
12:03:37 <lambdabot>  [1,1,1 + 1,1 + (1 + 1),1 + 1 + (1 + (1 + 1)),1 + (1 + 1) + (1 + 1 + (1 + (1 ...
12:04:12 <litb> oh what is Expr ?
12:04:21 <Deewiant> @where simplereflect
12:04:22 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
12:04:22 <Deewiant> litb: ^
12:04:26 <nominolo> > [x | x <- [2..n-1], x*x <= n] :: [Expr]
12:04:28 <lambdabot>  Exception: not a number
12:04:30 <Deewiant> > let fibs = scanl1 (+) (0:1:fibs) in fibs :: [Expr]
12:04:31 <lambdabot>  [0,0 + 1,0 + 1 + 0,0 + 1 + 0 + (0 + 1),0 + 1 + 0 + (0 + 1) + (0 + 1 + 0),0 +...
12:04:44 <litb> > (1 + 2 * 4) :: [Expr]
12:04:44 <lambdabot>   add an instance declaration for (Num [Expr])
12:04:49 <litb> hm
12:04:56 <Deewiant> > (1 + 2 * 4) :: Expr
12:04:57 <lambdabot>  1 + 2 * 4
12:04:58 <nominolo> > 1 + 2 * 4 :: Expr
12:04:59 <litb> oh
12:04:59 <lambdabot>  1 + 2 * 4
12:05:03 <litb> darn i just noticed
12:05:11 <vininim> > foldl f e [a,b,c,d] :: Expr
12:05:12 <lambdabot>  f (f (f (f e a) b) c) d
12:05:13 <nominolo> > [x | x <- [2..5], x*x <= n] :: [Expr]
12:05:14 <lambdabot>  [2,3,4,5]
12:05:17 <vininim> > foldr f e [a,b,c,d] :: Expr
12:05:18 <lambdabot>  f a (f b (f c (f d e)))
12:05:25 <wli> Where is Expr defined?
12:05:28 <EvilTerran> > foldr (&) e [1,2,3,4] :: Expr
12:05:28 <lambdabot>   Not in scope: `&'
12:05:34 <EvilTerran> > foldr (+) 0 [1,2,3,4] :: Expr
12:05:34 <lambdabot>  1 + (2 + (3 + (4 + 0)))
12:05:38 <EvilTerran> > foldl (+) 0 [1,2,3,4] :: Expr
12:05:38 <lambdabot>  0 + 1 + 2 + 3 + 4
12:05:46 <nominolo> ok, no it doesn't work for list comprehensions
12:06:04 <EvilTerran> > [x | x <- [1,2,3,4]] :: Expr
12:06:05 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
12:06:08 <EvilTerran> > [x | x <- [1,2,3,4]] :: [Expr]
12:06:09 <lambdabot>  [1,2,3,4]
12:06:18 <EvilTerran> > [(x,y) | x <- [1,2,3,4], y <- [1,2,3] :: [Expr]
12:06:19 <lambdabot>  Parse error at end of input
12:06:20 <Deewiant> @undo [x | x <- [2..5], x*x <= n]
12:06:21 <lambdabot> concatMap (\ x -> if x * x <= n then [x] else []) [2 .. 5]
12:06:21 <EvilTerran> > [(x,y) | x <- [1,2,3,4], y <- [1,2,3]] :: [Expr]
12:06:24 <lambdabot>  Couldn't match expected type `Expr' against inferred type `(t, t1)'
12:06:28 <Deewiant> > concatMap (\ x -> if x * x <= n then [x] else []) [2 .. 5] :: [Expr]
12:06:29 <lambdabot>  [2,3,4,5]
12:06:30 <litb> well, can i use it for my Funktion datatype too to display my calculated derivation?
12:06:30 <EvilTerran> > [(x,y) | x <- [1,2,3,4], y <- [1,2,3]] :: [(Expr,Expr)]
12:06:32 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3)]
12:06:39 <nominolo> > [x | x <- [a,b,c,d]] :: [Expr]
12:06:40 <lambdabot>  [a,b,c,d]
12:06:41 <dolio> > [ x + x | x <- [1..4] ] :: [Expr]
12:06:42 <lambdabot>  [1 + 1,2 + 2,3 + 3,4 + 4]
12:07:02 <nominolo> > [x | x <- [a,b,c,d], x > 3] :: [Expr]
12:07:03 <lambdabot>  [a,b,c,d]
12:07:21 <nominolo> that's not quite right, i'd say
12:07:37 <gwern> 'The exercise was fairly popular with the students, as it demonstrated that Haskell can be used for things other than sorting lists, and to good effect. Using ghc, runtime performance was not an issue; under Windows even Hugs copes quite well.' <-- heh. I'd disagree, his asteroids runs dog-slow
12:07:39 <vininim> is that lambdabot only or will it get into ghci eventually?
12:07:39 <litb> what?
12:07:43 <Deewiant> > a > 3
12:07:44 <lambdabot>  True
12:07:54 <vininim> *is Expr
12:07:54 <litb> > a < 3
12:07:55 <lambdabot>  False
12:07:56 <litb> hmm
12:08:01 <Deewiant> vininim: it's a module included in lambdabot, you can get it and load it into ghci if you want
12:08:04 <litb> what is a ?
12:08:08 <nominolo> > a
12:08:09 <lambdabot>  a
12:08:11 <Deewiant> a is a variable
12:08:12 <litb> huh
12:08:17 <Deewiant> f,g,h are functions
12:08:18 <litb> > q
12:08:21 <lambdabot>  q
12:08:22 <Deewiant> read @where simplereflect
12:08:24 <litb> strange
12:08:25 <Deewiant> it explains the whole thing
12:08:34 <litb> ah, that's the default type?
12:08:48 <litb> i see..
12:08:48 <nominolo> > q > 5
12:08:50 <lambdabot>  True
12:08:58 <dons> > q
12:08:59 <lambdabot>  q
12:09:01 <dons> > a
12:09:02 <lambdabot>  a
12:09:10 <zbrown> > a > q
12:09:11 <lambdabot>  False
12:09:12 <Deewiant> > foldr (fun "function") (var "variable") [1..5]
12:09:13 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Sym a))
12:09:15 <zbrown> > q > a
12:09:15 <glen_quagmire> > h e l l o w o r l d
12:09:16 <lambdabot>  Add a type signature
12:09:16 <lambdabot>  True
12:09:18 <zbrown> interesting
12:09:23 <glen_quagmire> > h e l l o w o r l d :: Expr
12:09:24 <lambdabot>  h e l l o w o r l d
12:09:30 <zbrown> I guess that makes sense from an ASCII stand point
12:09:49 <doserj> I think Ord is implemented in terms of Show
12:10:01 <EvilTerran> ... how does ::Expr make out-of-scope names work? O.o
12:10:09 <nominolo> doserj: it is
12:10:28 <nominolo> EvilTerran: they're defined at the top-level
12:10:48 <nominolo> [a,b,c,d,e,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
12:10:48 <nominolo>  = [var [x] | x <- ['a'..'e']++['i'..'z']]
12:11:11 <EvilTerran> oh, i see. cheeky.
12:11:12 <EvilTerran> ?type a
12:11:13 <lambdabot> Not in scope: `a'
12:11:35 <oerjan> > [(),a]
12:11:36 <lambdabot>  Couldn't match expected type `()' against inferred type `Expr'
12:11:41 <nominolo> EvilTerran: see the blog post
12:11:43 <oerjan> > [(),f]
12:11:44 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr ())
12:11:44 <lambdabot>     In the...
12:11:47 <EvilTerran> yeah, reading it now
12:12:08 <nominolo> > [a,4]
12:12:12 <lambdabot>  [a,4]
12:12:16 <nominolo> heh
12:12:44 <nominolo> > [length a]++[a,4]
12:12:45 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
12:13:14 <nominolo> > [a,length a]
12:13:15 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
12:13:30 <nominolo> > [length a]
12:13:31 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
12:13:43 <nominolo> > [length a] :: [Expr]
12:13:44 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
12:13:58 <sarehu> you can't get it to do length because length is not part of a typeclass
12:14:22 <nominolo> i was wondering if it was typesafe
12:14:36 <nominolo> ie if a could be used as a number and a list at the same time
12:15:03 <Deewiant> > var :: String -> Expr
12:15:03 <sarehu> > (fromInteger a, fromRational a) :: Expr
12:15:04 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Sym a'
12:15:04 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Expr'
12:15:25 <Deewiant> why is var's return type "Sym a" instead of Expr?
12:19:39 <awesame> if I have a type like this:
12:19:56 <awesame> data Foo = Foo { bar, baz :: String }
12:20:00 <awesame> how do I construct one?
12:20:23 <Deewiant> Foo { bar = "foo", baz = "qux" }
12:20:29 <Deewiant> or Foo "foo" "qux"
12:20:35 <awesame> neat
12:20:43 <dbueno> Is there a straightforward way of writing state out on a posix signal so a long-running algorithm can resume from where it left off in case it needs to be killed?  Will I have to poll for the right signals?
12:20:50 <awesame> and then (bar someFoo) will get the bar component?
12:21:02 <hpaste>  palomer pasted "getting the cursor coordinates" at http://hpaste.org/5620
12:21:03 <Deewiant> aye, or you can pattern match
12:21:26 <awesame> excellent, thanks
12:25:52 <proq> when I start hugs on my zaurus I get the error /bin/sh: hugs: not found     Illegal Instruction.  is there a workaround for this?
12:26:51 <wagle_home> proq, how are you starting up hugs?
12:27:08 <proq> hugs -v, or hugs, or hugs file.hs
12:27:23 <wagle_home> # file hugs
12:27:33 <dons> Illegal instruction sounds like hugs was miscompiled? but the first thing makes it sound like its not in your path
12:28:49 <wagle_home> i think it doesnt recognize hugs as an executable or something..  like its first line is #!hugs, and it cant find hugs..  the illegal instruction throws that idea off, though
12:29:39 <wagle_home> proq, what does the file command on the hugs object file return?
12:29:42 <oerjan> proq: what does less `which hugs` give?
12:29:56 <proq> which hugs returns /usr/bin/hugs
12:30:12 <oerjan> and is that a script or a binary?
12:30:18 <wagle_home> what does "file /usr/bin/hugs" return?
12:30:33 <proq> I don't have the file tool on my zaurus
12:30:38 <proq> it's a binary
12:30:51 <wagle_home> where'd you get the hugs binary?
12:32:22 <proq> I found a build here  http://www.quux.org:70/devel/zaurus
12:32:59 <proq> I will just assume it's outdated and keep looking I guess
12:34:22 <wagle_home> might be for the wrong cpu
12:35:01 <awesame> so I asked a question a while back an no one responded
12:35:05 <awesame> should I ask it again?
12:35:17 <bos> sure
12:35:39 <awesame> ok, I've got a data type that I use to switch between a bunch of different static info
12:35:49 <awesame> like this:
12:35:54 <awesame> data Language = C | Cpp | D | Haskell
12:36:01 <awesame> and then I've got a pile of functions like this one:
12:36:08 <awesame> langLibs lang = case lang of
12:36:14 <awesame> C -> ["libfoo", "libbar"]
12:36:19 <awesame> Cpp -> ...
12:36:20 <awesame> etc
12:36:28 <awesame> is that the idiomatic way to do this?
12:36:42 <bos> you could use the pattern more directly.
12:36:49 <bos> langLibs C = ["foo", "bar"]
12:36:51 <Deewiant> langlibs C = ["libfoo", "bar"]
12:37:03 <bos> langLibs Cpp = ["baz"]
12:37:09 <awesame> in python I would have a hashtable full of values for each language, and pass those around
12:37:20 <awesame> right, okay, so I can simplify my function defs
12:37:28 <bos> well, you could also use a map or an association list.
12:37:40 <bos> but for such a small datatype, using a function makes sense.
12:39:05 <awesame> I was also thinking about doing something like:
12:40:02 <awesame> data Language = { name, config :: String, libs :: [String], etc etc }
12:40:16 <awesame> and then constructing a number of those
12:41:42 <awesame> one of the things I'm finding hardest in picking up haskell is figuring out what the appropriate idioms are for a number of common tasks, so that I can do things in a way that won't cause problems for me later
12:42:08 <byorgey> awesame: well, for something like this, there are actually lots of idioms that work, depending on the situation.
12:43:15 <pa-ching> Hmmm... so if I have "type FooIO a = StateT FooState IO a", how can I compose or whatever to make something like: "type BarIO a = StateT BarState (FooIO a) a"
12:43:26 <awesame> I guess that's true in any language, I just don't know the tradeoffs yet in haskell
12:43:29 <unenough> does haskell encourage a unique way to do stuff? or is the problem of arbitrary different ways to do the same thing still here
12:43:35 <wagle_home> using data structures is nice when the table changes during execution..  using program structures is nice if the table doesn't change during execution, because its faster to figure out..
12:43:48 <byorgey> pa-ching: just type BarIO a = StateT BarState FooIO a
12:44:06 <pa-ching> really? that gave me an error last time... maybe I got something wrong..
12:44:34 <byorgey> pa-ching: hm, you might need some sort of language extension...
12:44:36 <dolio> byorgey: That won't work, because FooIO is partially applied.
12:44:52 <byorgey> ah, can't partially apply type synonyms?
12:44:55 <pa-ching> Type synonym `RepoIO' should have 1 argument, but has been give 0
12:44:58 <pa-ching> given*
12:45:00 <dolio> Nope. Needs newtype.
12:45:16 <byorgey> ok, yep, I was going to suggest that anyway =)
12:45:21 <pa-ching> Er heh
12:45:36 <pa-ching> newtype eh...
12:45:44 * pa-ching doesn't even know the difference between data and newtype
12:46:21 <faxathisia> just finished that, http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.TypesSummerSchool2007 quite interesting
12:46:25 <lambdabot> Title: 28 The Agda Wiki - Types Summer School 2007 4b, http://tinyurl.com/yuktth
12:46:30 <Lemmih> pa-ching: Try: type FooIO = StateT FooState IO
12:46:33 <byorgey> pa-ching: http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
12:46:34 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
12:47:11 <pa-ching> Lemmih: Hmm, but I'm using FooIO as a StateT elsewhere...
12:47:48 <pa-ching> byorgey: thanks, I'll look through it :)
12:48:12 <Lemmih> pa-ching: And?
12:49:22 <pa-ching> Lemmih: Whoops, misread that
12:49:33 <pa-ching> Lemmih: Hoh, so I don't need the 'a's at all
12:56:13 <faxathisia> The Type checking in the presence of meta-variables stuff is pretty confusing..
13:01:12 <dons> ?yow
13:01:20 <lambdabot> I represent a sardine!!
13:01:33 <dons> the sardine super delegate!!
13:01:45 <dons> ?users
13:01:46 <lambdabot> Maximum users seen in #haskell: 463, currently: 449 (97.0%), active: 19 (4.2%)
13:05:55 <faxathisia> http://www.iis.sinica.edu.tw/~scm/2008/constructing-list-homomorphism/
13:06:02 * byorgey makes pretty patch theory diagrams with inkscape
13:06:02 <lambdabot> Title: Constructing List Homomorphism from Left and Right Folds | Niche Computing Scien ..., http://tinyurl.com/2s62un
13:06:34 <vininim> mmm anyone every tried constructing genetic algorithm using Arrows as base?
13:07:30 <slarba> why would you need arrows in that?
13:08:09 <vininim> well, you don't
13:08:20 <sarehu> you don't _need_ arrows for anything  </uselessComment>
13:08:53 <slarba> hmm... "rewiring" the arrow by mutation and crossover...
13:09:37 <vininim> perhaps the probabilites for a correct code would make it unfeasable
13:10:32 <sarehu> a 'correct' code?  depends on what you're using a genetic algorithm for
13:11:27 <patperry> does anyone know if it is ok to make an unsafe ffi call with a ForeignPtr?
13:12:00 <Lemmih> patperry: Unsafe in what way?
13:12:17 <patperry> "foreign import ccall unsafe ..."
13:12:28 <slarba> sarehu: well you could compose all kinds of arrows from Foo a a arrow
13:12:44 <Lemmih> patperry: Perfectly safe.
13:12:52 <slarba> input and output of the same type...
13:12:55 <sarehu> slarba: never mind me, I'm just superfluous today
13:13:07 <patperry> ok, thanks.  the gc never moves ForeignPtrs, then?
13:13:08 <Lemmih> patperry: It's only marked unsafe because you can't call back into Haskell land.
13:13:17 <slarba> sarehu: heh :)
13:13:28 <vininim> sarehu: more like syntatically correct code
13:13:54 <vininim> I mean, not all sequence of arrow "opcodes" are valid
13:13:57 <patperry> or, I guess it could.  laziness in the IO monad confuses me.
13:14:18 <patperry> thanks, Lemmih
13:14:22 <Lemmih> patperry: ForeignPtr = Ptr + finaliser.
13:14:42 <sarehu> vininim: who says they represent opcodes?  who says they represent executable instructions?
13:15:27 <slarba> vininim: you can have a function that can produce a composition of arrows of certain type according to certain rules... what that arrow "means" is a different story
13:15:51 <ilyak_> Hi everyone again! How would I declare two variables in let-block in a function?
13:16:11 <ilyak_> By the way, is there a *small but dense* document with all haskell syntax avalible?
13:16:47 <faxathisia> > let a = 5 ; b = 6 in a * b
13:16:55 <Lemmih> @google Gentle introduction to Haskell
13:16:56 <lambdabot> http://www.haskell.org/tutorial/
13:16:56 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
13:16:57 <pejo> Lemmih, is the finaliser run when the Ptr is semantically dead?
13:17:00 <lament> there's a large and dense document
13:17:03 <lambdabot>  thread killed
13:17:12 <faxathisia> Well I think that works..
13:17:18 <Lemmih> pejo: Yes, the finalizer is executed when the Ptr is garbage collected.
13:17:21 <oerjan> > let a = 5 ; b = 6 in a * b
13:17:22 <faxathisia> anyway there's syntax reference here, http://www.haskell.org/onlinereport/
13:17:22 <lambdabot> Title: The Haskell 98 Language Report
13:17:22 <lambdabot>  30
13:18:10 <nominolo> has anyone here tried implementing miniSAT in Haskell?
13:18:12 <pejo> Lemmih, how does a copying collector know that? It only has pointers to live memory, no?
13:18:53 <ilyak_> faxathisia: It doesn't help, maybe because I'm doing second let on tabulated newline
13:18:58 <Lemmih> pejo: You use 'withForeignPtr' to extract the Ptr.
13:19:04 <ilyak_> blank end and comma don't work either
13:19:15 <ilyak_> as a second let
13:19:20 <oerjan> ilyak_: they must be aligned with each other if you use layout
13:19:35 <oerjan> ilyak_: oh and there is only _one_ "let" keyword
13:19:56 <ilyak_> yes, I've deleted second let when it complained
13:20:06 <faxathisia> ilyak_: I don't understand\
13:20:13 <pejo> Lemmih, hm? I realize the gc can get information about the different fields, but in some sense it must keep track of what it *hasn't* copied to run the finalizer?
13:20:16 <faxathisia> ilyak_: Why not paste the code?
13:20:18 <faxathisia> @hpaste
13:20:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:20:37 <Lemmih> pejo: Say again?
13:20:50 <ilyak_> Yes, that works, thanx
13:20:53 <patperry> Lemmih: so, when you call withForeignPtr ptr f, is the garbage collector gauranteed to to interrupt f?
13:20:56 <pejo> Lemmih, I'm curious how the garbage collector know when to run the finalizer.
13:21:07 <ilyak_> Still I wonder why isn't one tabulation enough and neither ; work
13:21:13 <ilyak_> I'll paste, wait a sec
13:21:13 <patperry> (Lemmih: gaur not to interrupt if)
13:21:46 <Lemmih> patperry: Huh?
13:22:30 <hpaste>  ilyak pasted "(no title)" at http://hpaste.org/5621
13:22:37 <Lemmih> pejo: I have no idea how GHC does it.
13:22:50 <ilyak_> Also I guess I have a pretty funny way to make ranges
13:22:54 <ilyak_> But I don't know better
13:23:12 <oerjan> ilyak_: that let looks fine to me
13:23:33 <patperry> Lemmih: say I do { ptr <- mallocForeignPtrArray 10 ; withForeignPtr ptr memset $ \p -> 0 10 } with memset "foreign import ccall unsafe ...".  If the GC runs, it might move the array, right?  That would be bad.
13:23:39 <oerjan> ilyak_: [1..n]
13:23:40 <Lemmih> pejo: As long as the constraints are known, the implementation is irrelevant.
13:23:46 <ilyak_> oerjan: If I mistabulate it doesn't work
13:24:03 <oerjan> ilyak_: yes, let blocks are indentation aligned
13:24:05 <pejo> Lemmih, not if you are curious about the implementation.
13:24:06 <Lemmih> patperry: No, it will not move the array.
13:24:13 <lament> if you mistabulate, your palms will grow hair
13:24:16 <ilyak_> Wow, thanx! Also, if I put ; after digits declatation and mistabulate it still won't work
13:24:21 <ilyak_> Which is kind of weird
13:24:29 <patperry> Lemmih: does it *never* move the arrays pointed to by foreignPtrs?
13:24:37 <ilyak_> Guards did not require proper aligning, just identation...
13:24:52 <oerjan> ilyak_: it will work if you indent _more_ but not less, because less ends the let block
13:24:57 <oerjan> (with ;)
13:25:21 <lament> ;)
13:25:34 <oerjan> ilyak_: the only things that start indentation blocks in haskell are let, do, where and (case) of
13:25:36 <Lemmih> patperry: It doesn't case what it points to. Imagine the memory is allocated by C's 'malloc'.
13:25:40 <Lemmih> s/case/care/
13:25:44 <oerjan> (barring some extensions)
13:26:31 <awesame> hm
13:26:57 <awesame> in the middle of an IO do expression, I need to deal with a Maybe value
13:27:00 <awesame> like this:
13:27:03 <patperry> Lemmih: ok, so the GC doesn't manage the memory pointed to by ForeignPtrs (except indirectly, by calling free when the finalizer gets called).  That makes sense.  Thanks for clearing that up.
13:27:27 <awesame> foo <- (liftM bar) $ Maybe baz
13:27:28 <awesame> print foo
13:27:47 <shag> does someone know if it is possible to have several directories containing haskell code inside an eclipse project when using the haskell plugin for eclipse?
13:28:47 <oerjan> awesame: let foo = liftM bar $ Maybe baz
13:28:59 <oerjan> assuming you are not using IO in there
13:29:29 <oerjan> hm i think you mean Just
13:29:40 <awesame> er, yes
13:29:58 <awesame> it's type is "Maybe String", actually
13:30:43 <oerjan> that will make foo :: Maybe something, however
13:31:36 <faxathisia> > liftM f $ Just a :: Maybe Expr
13:31:37 <lambdabot>  Just (f a)
13:31:41 <faxathisia> > liftM f $ [a] :: Maybe Expr
13:31:42 <lambdabot>  Couldn't match expected type `Maybe' against inferred type `[]'
13:31:47 <faxathisia> gr..
13:32:21 <awesame> so what I want is for Nothing to cause the whole program to exit
13:32:47 <awesame> and for Just "somestring" to hand the string out into the IO do expression
13:33:51 <oerjan> awesame: foo <- maybe (System.exit ...) bar $ ... perhaps
13:34:06 <awesame> yeah, that works
13:34:11 <oerjan> @hoogle exit
13:34:12 <lambdabot> System.Exit :: module
13:34:12 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
13:34:12 <lambdabot> System.Exit.exitFailure :: IO a
13:35:08 <oerjan> oh except you need a return somewhere
13:35:17 <oerjan> awesame: foo <- maybe (System.exit ...) (liftM bar) $ ... perhaps
13:35:44 <oerjan> er no
13:35:58 <oerjan> (return . bar)
13:37:16 <oerjan> you could also use case ... of if that's clearer
13:38:16 <ilyak_> I'm stuck with type conversions again
13:38:53 <oerjan> fromIntegral or realToFrac is usually the stuff for numbers :)
13:39:31 <awesame> I really haven't gotten the hang of . and $ yet.  my haskell code looks more like lisp than seems normal
13:39:37 <hpaste>  Ilyak pasted "No instance for (Floating Int)" at http://hpaste.org/5622
13:39:46 <faxathisia> awesame: hehe
13:39:50 <ilyak_> How go I handle that, genetally?
13:39:59 <doserj> oerjan: bingo :)
13:40:08 <oerjan> ilyak_: actually you probably want ^ rather than ** there
13:40:18 <wy__> I can't find the part of the Java document which describes the temporary class creation. Any help?
13:40:22 <ilyak_> $ is cool and familiar if you've used to shell scripting
13:40:44 <ilyak_> oerjan: Oh, probably. But, nevertheless, what do I do when I get that kind of error
13:40:48 <faxathisia> awesame: That happens for a while, but the things that helped me most are, function bind tighter than operators (so f x + y = (f x) + y) and that (f a b c = (((f a) b) c))
13:40:55 <oerjan> ilyak_: what i said just before :)
13:41:04 <wy__> sorry wrong channel
13:41:15 <faxathisia> awesame: Also you can :info in ghci to see what fixity operators are
13:41:16 <wy__> uhh...
13:41:25 <oerjan> wy__: you will be _so_ sorry for mentioning Java :D
13:41:33 <wy__> How can I kick myself out?
13:41:50 <oerjan> @slap wy__
13:41:51 * lambdabot moulds wy__ into a delicous cookie, and places it in her oven
13:41:54 <wy__> sorry ;)
13:42:08 <lament> that sounds pretty disgusting
13:42:14 <wy__> any idea how to kick "wy" out?
13:42:33 <faxathisia> wy__: You could try /msg NickServ ghost wy <password>
13:42:35 <wy__> I logged in on my office machine, and forgot to close xchat
13:43:29 <wy> faxathisia: Thanks. I'm back :)
13:44:22 <wy> But maybe I will still be happy about asking about Java here, because #java people don't seem to be as friendly ;)
13:45:45 <ilyak_> is there a function in prolog that does \x -> [x] ?
13:46:04 <faxathisia> ilyak_: In Prelude, do you mean?
13:46:14 <wy> I really like this channel because people are afraid of criticize
13:46:18 <gour> @seen ndm
13:46:18 <lambdabot> I haven't seen ndm.
13:46:23 <sarehu> it's the frog function   (:[])
13:46:26 <faxathisia> (:[]) -- I think it's called the upside down robot ninja operator?
13:46:33 <wy> aren't ... sorry
13:46:34 <sarehu> bah I disagree
13:46:34 <ilyak_> faxathisia: yeah
13:46:45 <ilyak_> I've messed with my brain for too long today
13:47:00 * faxathisia was confused because there are no functions in Prolog
13:47:38 <ilyak_> So I assume there isn't?
13:47:51 <dolio> singleton(X,[X]).
13:47:59 <awesame> (:[]) is clearly a hamburger
13:48:06 <faxathisia> > ((:[]) 'x', (\x -> [x]) 'x')
13:48:10 <lambdabot>  ("x","x")
13:49:23 <doserj> > return x :: [Expr]
13:49:25 <lambdabot>  [x]
13:49:50 <faxathisia> ooh..
13:49:57 <faxathisia> neat..
13:50:23 <awesame> this Expr type is blowing my mind
13:52:19 <ilyak_> I wonder if there is an easier way to get list-of digits than map (read . (\x -> [x])) $ show n
13:52:23 <awesame> oerjan: so I've got "foo <- maybe (exitFailure) (return . bar)" as perhaps you were suggesting
13:52:49 <awesame> oerjan: but it complains that it infers bar is a Maybe String where it expected an a -> a1
13:52:56 <codemac> Hi, I'm playing around with Yi, and I can't get it to build because I'm missing fingertree.  I installed it with cabal.. and ./Setup configure still complains that fingertree is missing.. Is this some path issue I'm missing?
13:53:02 <awesame> which makes sense to me, reading it, but I'm not sure how to fix it...
13:53:35 <byorgey> > map digitToInt $ show 123  -- ilyak_
13:53:36 <lambdabot>  [1,2,3]
13:53:48 <byorgey> just import Data.Char to get digitToInt
13:54:07 <byorgey> codemac: if you do ghc-pkg list, do you see fingertree installed?
13:54:39 <oerjan> awesame: you are missing an argument
13:54:47 <oerjan> you had both bar and baz originally
13:55:02 <codemac> byorgey: yea, it says 'fingertree-0.0' under my local packages
13:55:09 <oerjan> try foo <- maybe (exitFailure) return bar
13:55:22 <ilyak_> byorgey: thx, I'll try
13:55:53 <byorgey> codemac: ok, then you know you need to do ./Setup configure --user  to build yi, right?
13:56:05 <ilyak_> Not in scope: `digitToInt' - is it defined somewhere else?
13:56:05 <byorgey> codemac: if you just do ./Setup configure, it will not look in your local packages
13:56:13 <codemac> byorgey: ah, ok.  I didn't know about the --user flag
13:56:14 <byorgey> ilyak_: Data.Char
13:56:15 <codemac> byorgey: thanks
13:56:20 <ilyak_> oh, I see
13:56:23 <awesame> oerjan: oh, oops
13:56:39 <byorgey> ilyak_: just put 'import Data.Char' at the top of your file
13:56:41 <awesame> oerjan: changing other things around at the same time backfired on me
13:57:35 <awesame> but now it's complaining that it wanted an IO a, and got a Maybe String
13:58:22 <codemac> Now when running ./Setup build, it says that yi cannot be built?
13:58:59 <ilyak_> byorgey: Thanx, I already know how to import :)
13:59:30 <byorgey> ilyak_: ok, cool, just making sure =)
14:00:10 <byorgey> codemac: probably you don't have a frontend installed.  You'll need either gtk, vty, or cocoa.
14:00:38 <codemac> Wouldn't configure check for that.. ? I'll check though.
14:00:46 <byorgey> gtk gives a GUI interface, vty is a terminal interface, and I think cocoa is for macs.
14:00:57 <oerjan> awesame: huh?  what line do you have now?
14:00:59 <byorgey> codemac: it does, that's why it said "can't be built" =P
14:01:03 <oerjan> @hoogle exitFailure
14:01:04 <lambdabot> System.Exit.exitFailure :: IO a
14:01:04 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
14:01:23 <byorgey> codemac: it's not a very helpful error message, I think some changes are being made to cabal to allow better errors in this sort of situation
14:02:33 <awesame> oerjan: foo <- maybe exitFailure (return bar)  -- bar :: Maybe String
14:02:50 <oerjan> awesame: i said maybe exitFailure return bar
14:04:07 <codemac> how do I see what packages are hidden in cabal?  bytestring-0.9.0.1 is apparently hidden, and vty needs it to compile
14:04:14 <awesame> oh, sorry
14:04:16 <awesame> that worked
14:04:19 <awesame> but why?
14:04:31 <oerjan> codemac: everything that is not listed in the .cabal file i think
14:05:12 <oerjan> awesame: it is equivalent to: case bar of Just x -> return x; Nothing -> exitFailure
14:05:33 <oerjan> the return is to make it an IO action
14:06:03 <oerjan> @src maybe
14:06:04 <lambdabot> maybe n _ Nothing  = n
14:06:04 <lambdabot> maybe _ f (Just x) = f x
14:06:59 <awesame> oh, duh, I had misunderstood maybe
14:07:47 <oerjan> @src fromMaybe
14:07:48 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
14:07:58 <awesame> I think misremembered it as a -> Maybe a -> a
14:08:03 <oerjan> perhaps you thought it was this one...
14:08:08 <awesame> yeah
14:08:57 <awesame> thanks for your help!
14:09:03 <oerjan> you're welcome :)
14:09:49 <awesame> this channel rules
14:11:28 <olsner> ah, sour milk!
14:11:45 <olsner> http://en.wikipedia.org/wiki/Filmjölk
14:11:49 <awesame> most other #language channels are so much less helpful
14:12:02 <awesame> and more prone to flame wars
14:12:07 * wolverian spies non-utf8 
14:12:12 <blackdog> haskell has a posse :)
14:12:34 <olsner> wolverian: apply iso-8859-1 -> utf-8 konversion if appropriate
14:14:03 <olsner> heh, *conversion
14:15:52 <Taejo> hmmm... I seem to be calling my beefy function 159332 more often than I expected... this could explain the slowness
14:16:45 <Taejo> anybody else found it annoying that the cost centre of a curried function is where it's *first* argument was applied rather than its last
14:21:50 <allbery_b> annoying perhaps but not unexpected
14:22:16 <Taejo> allbery_b: well, I didn't expect it, but it makes sense now that I see it
14:23:04 <Radly> Barack Obama voted FOR the Patriot Act, more funding for America's aggression in Iraq, and every increased spending measure he could get his lying articulate hands on. Hmmm lets add some more contradictions and exposed lies...... In the NH debate, he called for going into Pakistan. In many speaches he has advocated going into Africa for peacekeeping. (Sounds like that would be worse than Vietnam!)
14:23:09 <Radly> Oh yeah!!! THAT WILL REALLY HEAL AMERICA. Keep on believing it Obamatards. You all will be sorry, as Barack Hussein Obama is no better than Clinton or Edwards.
14:23:45 <Taejo> now to figure out why the profile says I'm calling it 159332 times, when I'm not (as confirmed by unsafePerformIO)
14:23:52 <lament> "articulate hands" indeed
14:24:03 <byorgey> articulated?
14:24:10 <patperry> is it possible to have strict fields in a GADT?
14:24:13 <blackdog> i wonder what obama's position on HM typing is...
14:25:03 <Pseudonym> blackdog: According to his talk at Google, he's against bubble sort.
14:25:19 <Taejo> blackdog: he says he supports it, but voted against funding it in 2003
14:25:24 <Pseudonym> So that's a good policy.
14:25:26 <lament> Pseudonym: will he make it illegal?
14:25:40 <Pseudonym> I don't know.  He's just against it.
14:26:57 <oerjan> patperry: i vaguely recall seeing it in the user guide
14:27:14 <awesame> we need to keep bubble sort off the streets and out of the hands of our children
14:27:24 <Valodim> why?
14:27:27 <dolio> patperry: Try something like: "data Foo a where !a -> Foo a"
14:28:10 <Pseudonym> Because it wastes computrons, increasing carbon emissions.
14:28:25 <oerjan> awesame: what, you want them to get the faster stuff instead?
14:29:08 <awesame> I want our kids to have every advantage
14:29:50 <lament> yes. Kids need speed.
14:32:13 <patperry> thanks, I'll do some experimenting
14:34:10 <non_socialist> hi may I ask about cabal install?
14:34:12 <non_socialist> on linux?
14:34:22 <nominolo> which version?
14:34:38 <non_socialist> 1.2.3.0
14:34:47 <non_socialist> I folowed directions
14:34:59 <nominolo> you are talking about Cabal or cabal-install?
14:35:01 <non_socialist> but 'cabal install' does not find anything
14:35:05 <nominolo> those are differnt tools
14:35:11 <non_socialist> oh is it an other package?
14:35:16 <nominolo> yes
14:35:20 <non_socialist> ooow really?
14:35:25 <non_socialist> heh
14:35:31 <oerjan> non_socialist: i think there are plans to merge them eventually
14:35:33 <non_socialist> this explains a LOT
14:35:36 <nominolo> but without an official rlease yet
14:35:50 <byorgey> Cabal is a library which provides facilities for package management; cabal-install is a program which installs packages for you
14:35:54 <nominolo> the plan is to have it shipping with the next ghc release
14:36:11 <non_socialist> funny the ghc site says it 'has' cabal.......
14:36:23 <non_socialist> but its cabal-install that I want.....!!
14:36:24 <non_socialist> k
14:36:59 <nominolo> non_socialist: yeah, just be little bit patient
14:37:30 <nominolo> non_socialist: you can try the development version but it needs manual install of zlib, HTTP and the development version of Cabal
14:38:13 <non_socialist> I had it working
14:38:23 <nominolo> non_socialist: http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
14:38:26 <lambdabot> http://tinyurl.com/39kra4
14:38:48 <non_socialist> ok
14:39:47 <hpaste>  (anonymous) annotated "No instance for (Floating Int)" with "(no title)" at http://hpaste.org/5622#a1
14:40:43 <faxathisia> > liftM f $ [] :: [Expr]
14:40:58 <lambdabot>  thread killed
14:41:23 <oerjan> > liftM f $ [] :: [Expr]
14:41:26 <lambdabot>  []
14:41:37 <nominolo> ?
14:41:55 <oerjan> those thread killed messages seem to come frequently now?
14:43:17 <non_socialist> how do I grab latest zlib http < 3000.1 using darcs?
14:43:23 <non_socialist> is it as simlpe to wget?
14:43:27 <non_socialist> from hackage?
14:43:32 <olsner> hmm... fibracide?
14:43:42 <nominolo> non_socialist: no, from Hackage
14:43:50 <nominolo> @hackage zlib
14:43:50 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
14:44:01 <nominolo> @hackage HTTP
14:44:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
14:44:30 <nominolo> and darcs get http://darcs.haskell.org/cabal-install/
14:44:30 <lambdabot> Title: Index of /cabal-install
14:44:47 <nominolo> and darcs get http://darcs.haskell.org/cabal/
14:44:47 <lambdabot> Title: Index of /cabal
14:45:14 <nominolo> install each separately
14:46:42 <nominolo> but maybe better use darcs get --partial
14:46:53 <nominolo> (it's faster)
14:48:38 <hpaste>  (anonymous) annotated "speed bug reproduced" with "(no title)" at http://hpaste.org/5619#a3
14:58:05 <ehird> does 'interact' do stuff with my console?
14:58:07 <ehird> it responds on spaces
14:58:08 <ehird> :O
14:58:42 <sarehu> 'interact' is evil
14:58:49 <ehird> sarehu: in a good way?
14:58:55 <sarehu> that's debatable :)
14:59:01 <ehird> it
14:59:02 <non_socialist> shoot I know i had a HTTP 3000.4 yesterday
14:59:04 <ehird> 's useful ;)
14:59:18 <non_socialist> no all I see is 3000.0 and 3001.XYZ
14:59:25 <ehird> forever a = do a; forever a         -- this is standard, right. :P
14:59:31 <kmcallister> @src forever
14:59:31 <lambdabot> Source not found. I am sorry.
14:59:47 <non_socialist> cabal-install needs 3000.0 > x < 3001.0
14:59:51 <faxathisia> :t forM_
14:59:52 <non_socialist> darn it!
14:59:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
15:00:17 <faxathisia> forM_ (repeat ()) (const a)
15:00:19 <faxathisia> maybe ?
15:00:32 <sarehu> forever is standard in some sense
15:00:38 <faxathisia> not sure if that's the same
15:00:44 <sarehu> it's the name I've seen used whenever people use it
15:01:31 <oerjan> :t forever
15:01:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
15:01:37 <oerjan> it's new in 6.8
15:01:42 <dolio> @type fix (ap (>>))
15:01:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:02:01 <shachaf> oerjan: There was a patch recently to make the type more general, I think.
15:02:31 <faxathisia> :t forM_ (repeat ()) (const ?a)
15:02:32 <lambdabot> forall (m :: * -> *) b. (Monad m, ?a::m b) => m ()
15:02:38 <lakupuu> 7pp
15:02:50 <lakupuu> kk
15:02:56 <kmcallister> :t (ap (>>))
15:02:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> m b) -> m a -> m b
15:03:09 <kmcallister> :t ap
15:03:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:10:56 <litb> guys, i have a question
15:11:33 <oerjan> @yow
15:11:34 <lambdabot> My face is new, my license is expired, and I'm under a doctor's care!!!!
15:11:38 <Pseudonym> Really?  Fascinating!
15:11:44 <Pseudonym> People should have questions!
15:11:59 <ehird> litb: awesome
15:12:02 <ehird> litb: can i have it?
15:12:19 <litb> today someone told me that when using foldr with lazy function that is better than using it with foldl
15:12:23 <faxathisia> @vixen I've got a question for you
15:12:23 <lambdabot> we get along well, you know?
15:12:29 <litb> but how can i see whether a function is lazy or not ?
15:12:36 <dobblego> litb, it is not "better"; it has different semantics
15:12:42 <Pseudonym> Yeah.
15:12:42 <Botje> run it with undefined, see if it crashes :)
15:12:44 <litb> hm
15:12:56 <Pseudonym> Sometimes it's more efficient, sometimes it's not.
15:13:01 <litb> hmmm
15:13:03 <Pseudonym> And sometimes, foldl' is more appropriate.
15:13:06 <oerjan> litb: if f undefined produces at least a top constructor, f is lazy
15:13:06 <litb> some tutorial for this?
15:13:15 <dobblego> trying telling that to the Scala monkeys on the mailing list lately *sigh*
15:13:19 <blackdog> hey, dumb question - where _is_ foldl'?
15:13:32 <faxathisia> @hoogle foldl'
15:13:33 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
15:13:33 <lambdabot> Data.Foldable.foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
15:13:33 <lambdabot> Data.ByteString.foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
15:13:38 <Botje> it's in ur list, eatin ur elements
15:13:39 <faxathisia> Data.List then
15:13:44 <blackdog> ah, there we are. thanks :)
15:13:47 <oerjan> litb: f undefined `seq` True will return True if f is lazy
15:13:48 <litb> lol, i need a tutorial that explains what a "top constructor" is, and what the heck the difference in semantic is all about
15:13:57 <oerjan> (and crash otherwise)
15:14:03 <blackdog> Botje: blackdog is in ur channel, noising your signal
15:14:08 <Botje> :)
15:14:37 <litb> > [10] ++ undefined
15:14:45 <lambdabot>  Undefined
15:15:03 <litb> ok, that crashed not, that means it is lazy then
15:15:15 <Botje> actually, it did crash.
15:15:19 <oerjan> litb: er Undefined means a crash
15:15:28 <litb> oh
15:15:35 <litb> haven't known
15:15:36 <oerjan> but that is not enough because lambdabot evaluates more than you need
15:15:41 <Botje> > let loop = loop :: [a] in [10] ++ loop
15:15:42 <lambdabot>   loop :: [a]
15:15:42 <lambdabot>     In the definition of `loop': loop = loop :: [a]
15:15:42 <lambdabot>     In the ...
15:15:48 <Botje> > let loop = loop :: [Int] in [10] ++ loop
15:15:49 <lambdabot>  Exception: <<loop>>
15:15:59 <oerjan> > ([10] ++ undefined) `seq` True
15:16:00 <lambdabot>  True
15:16:03 <shachaf> > take 3 . show $ [10] ++ undefined
15:16:04 <lambdabot>  "[10"
15:16:34 <oerjan> litb: seq evaluates its first argument to its top constructor, then returns its second, so it can be used to check
15:16:45 <litb> ah, i see. if that then returns Undefined, it is not lazy shachaf ?
15:17:03 <litb> @src seq
15:17:03 <lambdabot> Source not found.
15:17:04 <shachaf> litb: No, show isn't a good way to test this. :-)
15:17:09 <shachaf> litb: seq is magical.
15:17:17 <shachaf> @ty seq
15:17:18 <lambdabot> forall a t. a -> t -> t
15:17:37 <Pseudonym> ?free seq :: forall a t. a -> t -> t
15:17:38 <lambdabot> g . seq x = seq (f x) . g
15:17:48 <oerjan> litb: lambdabot will give Undefined if anything during the showing of the expression is undefined, no matter if it is on the top or not
15:17:52 <litb> ok when i finally know what a top constructor is, i think i understand it
15:18:00 * litb wikis
15:18:39 <oerjan> litb: basically every value in most data types is either bottom (undefined) or a constructor applied to some values
15:18:41 <litb> top sounds like "fully known" in constrast to "bottom"
15:18:51 <dolio> > let isLazy f = f undefined `seq` True in isLazy ("abc" ++)
15:18:53 <lambdabot>  True
15:18:59 <dolio> > let isLazy f = f undefined `seq` True in isLazy (++ "abc")
15:19:00 <lambdabot>  Undefined
15:19:03 <oerjan> litb: oh i didn't mean anything technical by "top", just "outermost"
15:19:15 <litb> oh, i see
15:19:29 <litb> darn i feel so n00by that i discriminate myself :)
15:20:16 <oerjan> i sort of think of a haskell value as a kind of tree structure
15:20:51 <oerjan> where any node can be either a constructor or bottom
15:22:13 <oerjan> oh and newtype constructors don't count for this - it's their special property
15:23:25 <dolio> > (undefined :: State Int Int) `seq` True
15:23:27 <lambdabot>  Undefined
15:23:44 <litb> is f a `q` b read as (f a) `q` b ?
15:23:52 <oerjan> yeah
15:24:03 <dolio> > State undefined `seq` True
15:24:04 <lambdabot>  Undefined
15:24:57 <faxathisia> litb: functions bind tighter than operators (so f x + y = (f x) + y) and `x` is making an operator from a function
15:25:18 <DukeDave> Hey guys, has anyone looked at http://developers.facebook.com/thrift/ and Haskell yet?
15:25:20 <lambdabot> Title: Incompatible Browser | Facebook
15:25:33 <DukeDave> Could be a good way to suck in more people :)
15:25:37 <LoganCapaldo> lambdabot is not incompatibe! take that back!
15:25:47 * DukeDave ducks
15:25:48 <litb> faxathisia: ah, i see
15:26:10 <faxathisia> litb: another thing is f a b c = (((f a) b) c)
15:26:56 <litb> i see , b essentially is `seq`
15:27:24 <shachaf> litb: b?
15:27:42 <litb> in what faxathisia showed
15:27:45 <faxathisia> No
15:27:50 <shachaf> faxathisia: b is an argument.
15:27:56 <shachaf> s/faxathisia/litb/
15:27:57 <litb> yes
15:28:04 <litb> i meant in > let isLazy f = f undefined `seq` True in isLazy ("abc" ++)
15:28:06 <faxathisia> f a `q` b = (f a) `q` b = q (f a) b = (q (f a)) b = ((q (f a)) b)
15:28:20 <litb> c is True and a is undefined
15:28:36 <faxathisia> actually that's probably not helpful unless you know Scheme
15:28:39 <litb> oh
15:29:23 <litb> :p i suppose elisp also count
15:36:13 <LoganCapaldo> :t catch
15:36:15 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:36:26 <LoganCapaldo> @instances IOError
15:36:26 <lambdabot> Couldn't find class `IOError'. Try @instances-importing
15:36:47 <LoganCapaldo> doh
15:36:51 <LoganCapaldo> that's no moon
15:36:55 <LoganCapaldo> it's a space station
15:37:11 <LoganCapaldo> @src IOError
15:37:11 <lambdabot> Source not found. It can only be attributed to human error.
15:37:36 * LoganCapaldo demands satisfaction of lambdabot
15:37:43 <LoganCapaldo> pistols at dawn?
15:37:46 <Botje> @quote space
15:37:47 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. \n <souwh> oooh, those can be saved and reused later!
15:38:00 <lambdabot> We fight with pings of death!
15:38:07 * lambdabot slaps LoganCapaldo
15:41:05 <LoganCapaldo> that was expected
15:46:26 <dolio> @b52s
15:46:26 <lambdabot> Girl from Ipanema, she goes to Greenland
15:47:27 <mauke> @vixen ãƒ„
15:47:27 <lambdabot> Bollox!
15:47:58 <LoganCapaldo> unpossible
15:48:08 <oerjan> @vixen What about botox?  Do you use that?
15:48:08 <lambdabot> yes
15:48:34 <LoganCapaldo> @eliza is there an eliza mode?
15:48:34 <lambdabot> iz0rz +HER3 an elIZA MOde?
15:48:42 <mauke> hahaha
15:49:23 * LoganCapaldo Seg faults
15:50:10 <oerjan> poor eliza really went downhill after being thrown out of the APA
15:50:48 <LoganCapaldo> I'm a little surprised there's no eliza
15:50:58 <LoganCapaldo> maybe I should make onwe
15:51:15 <lambdabot> We were discussing you --not me.
15:51:22 <LoganCapaldo> lambdabot is the strongly typed emacs of irc bots
15:52:44 <LoganCapaldo> and then we could have dueling elizas
15:55:55 <MyCatVerbs> @src splitAt
15:55:55 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
15:56:10 <MyCatVerbs> @src drop
15:56:11 <lambdabot> drop n xs     | n <= 0 =  xs
15:56:11 <lambdabot> drop _ []              =  []
15:56:11 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
16:04:01 <Saizan> matthew-_: ping
16:04:24 * faxathisia gives up trying to understand Agda 2's proof inference magic for the moment...
16:09:45 <hpaste>  Porges pasted "Does this already have a name?" at http://hpaste.org/5623
16:10:45 <faxathisia> @hoogle (b -> b -> b) -> [a -> b] -> a -> b
16:10:46 <lambdabot> No matches, try a more general search
16:12:12 <oerjan> \a -> foldr x $ map ($ a) fs = foldr x . sequence fs
16:12:25 <mauke>     Occurs check: cannot construct the infinite type: b = [b]
16:12:26 <mauke>     When generalising the type(s) for `over'
16:12:29 <dmwit> :t foldr (.)
16:12:31 <lambdabot> forall c a. (a -> c) -> [c -> c] -> a -> c
16:12:31 <mauke> that code doesn't make sense
16:13:10 <LoganCapaldo> > fix (:[])
16:13:11 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
16:13:11 <lambdabot>       Expected...
16:13:21 <LoganCapaldo> construct it!
16:13:26 <oerjan> missing initial value for the foldr perhaps
16:14:10 <dmwit> yeah
16:14:28 <oerjan> or using foldr1
16:15:14 <dmwit> :t \x fs a -> foldr x (map ($ a) fs)
16:15:16 <lambdabot> forall a a1 b. (a -> [b] -> [b]) -> [a1 -> b] -> a1 -> [a] -> [b]
16:15:27 <dmwit> :t \x fs a -> foldr1 x (map ($ a) fs)
16:15:29 <lambdabot> forall a b. (b -> b -> b) -> [a -> b] -> a -> b
16:15:44 <oerjan> hm an init independent of x doesn't really make sense
16:16:50 <dmwit> :t sequence
16:16:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:17:17 <oerjan> oh also it is foldr1 (x.($a))
16:17:31 <dmwit> > sequence [id, (+1), (*2)] 3
16:17:33 <lambdabot>  [3,4,6]
16:17:40 <oerjan> um wait that does require an init
16:17:59 <glen_quagmire> > it
16:18:00 <lambdabot>   Not in scope: `it'
16:18:26 <dmwit> glen_quagmire: \bot doesn't have a proper ghci running, it compiles each line.
16:19:25 <hpaste>  oerjan annotated "Does this already have a name?" with "simplify" at http://hpaste.org/5623#a1
16:21:12 <glen_quagmire> @where dependent
16:21:12 <lambdabot> I know nothing about dependent.
16:26:23 <dolio> @fact HSU
16:26:23 <lambdabot> hsu: I know nothing about Haskell Secret Underground.
16:26:51 <oerjan> O_O
16:27:35 <oerjan> is that where the unsafe types hide?
17:00:23 <hpaste>  rabby pasted "bubblesort" at http://hpaste.org/5624
17:00:41 <rabby> yes, i pasted it, thx 2 bot....
17:01:17 <rabby> can anyone please tell me, why there is a type error although all types fit, i think?
17:01:36 <twanvl> what is the error?
17:01:46 <lament> bubblesort! where's obama when you need him!
17:02:09 <mauke> movebubble s is not a function
17:02:47 <rabby> in line 11 the type is [b] and this does not match a->a, haskell says
17:03:52 <rabby> oh, without " s" in line 11 it works
17:04:01 <Saizan> bubblesort s = iter ((length s)-1) movebubble s
17:04:18 <Saizan> btw, length is O(n)
17:04:54 <twanvl> By the way, the types of the functions should be  movebubble :: Ord a => [a] -> [a]
17:05:02 <rabby> oh, i am wrong. does not work
17:05:17 <mauke> why bubblesort? WHY
17:05:34 <hpaste>  Porges annotated "Does this already have a name?" with "(no title)" at http://hpaste.org/5623#a2
17:05:43 <foxy> This is a pretty simple question, what do I have to do to my buffereing to interact (putStr, readLn) at the prompt?
17:05:52 <glen_quagmire> @index (\\)
17:05:52 <lambdabot> bzzt
17:05:54 <foxy> s/rei/ri/
17:06:07 <byorgey> @type setBuffering
17:06:11 <lambdabot> Not in scope: `setBuffering'
17:06:17 <mauke> foxy: if I understand you right, hFlush stdout after each putStr
17:06:19 <glen_quagmire> :t (\\)
17:06:19 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:06:27 <foxy> mauke: thanks
17:06:33 <glen_quagmire> where is (\\) defined? hoogle can't find it
17:06:43 <glen_quagmire> > [1,2,3] \\ [4,5,6]
17:06:45 <lambdabot>  [1,2,3]
17:06:46 <mauke> Data.List
17:06:49 <rabby> Saizan: bubblesort s = iter ((length s)-1) movebubble s  does not work
17:06:52 <glen_quagmire> mauke: thank you
17:06:54 <twanvl> ?type hSetBuffering
17:06:55 <lambdabot> Not in scope: `hSetBuffering'
17:07:25 <byorgey> foxy: import System.IO; hSetBuffering stdin LineBuffering
17:07:25 <glen_quagmire> hSetBuffering is in System.IO i think
17:07:35 <foxy> byorgey: thanks
17:07:42 <byorgey> er, stdout, I mean
17:07:46 <dolio> @type foldr delete
17:07:47 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:08:04 <mauke> byorgey: wtf
17:08:24 <mauke> stdout is line buffered by default (if it's a terminal)
17:08:30 <glen_quagmire> if you use LineBuffering, be sure to do { putStr "enter: "; hFlush stdout; input <- getLine }
17:08:50 <glen_quagmire> > getBuffering stdout
17:08:50 <lambdabot>   Not in scope: `stdout'
17:09:02 <matt9237> how do i implement a for loop in IO ?
17:09:11 <mauke> matt9237: forM_, mostly
17:09:34 <mauke> forM_ [1 .. 10] $ \i -> do { print i }
17:09:35 <LoganCapaldo> rabby: you need an Ord constrainst
17:09:42 <LoganCapaldo> woah
17:09:50 <matt9237> @type forM_
17:09:51 <TomMD> > mapM_ (putStrLn "Hi") [1..3]
17:09:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:09:51 <lambdabot>  Couldn't match expected type `a -> m b'
17:09:53 <glen_quagmire> > hGetBuffering stdout
17:09:53 <lambdabot>   Not in scope: `stdout'
17:09:54 <LoganCapaldo> was I accidentally not scrolled to the bototm?
17:10:10 <rabby> LoganCapaldo: doesn't it work with String, too?
17:10:18 <astrolabe> Is there a haskell parser that will parse C++?
17:10:22 <glen_quagmire> my machine defaults to NoBuffering
17:10:27 <byorgey> mauke: oh, hm, then I wonder what foxy's problem is?
17:10:30 <LoganCapaldo> rabby: don't listen to me, I was like a million miles behind
17:10:44 <mauke> what the
17:10:46 <hpaste>  rabby pasted "bubblesort - Int-only" at http://hpaste.org/5625
17:10:47 <byorgey> foxy: it doesn't do what you want automatically?
17:10:51 <LoganCapaldo> as far as I new twanvl had just asked you what the error was
17:11:18 <TomMD> LoganCapaldo: And Haskell 98 had just been published?
17:11:20 <rabby> LoganCapaldo: did it now with Int
17:11:29 <foxy> byorgey: I'm getting  "Exception: user error (Prelude.readIO: no parse)"
17:11:40 <mauke> glen_quagmire: how did you determine that?
17:11:45 <byorgey> foxy: oh, that has nothing to do with buffering.
17:12:09 <rabby> does not work though: Expression     : iter (length s - 1) (movebubble s)  => term: movebubble s => type: [Int] does not match a->a
17:12:15 <foxy> ah, I was using readLn not getLine
17:12:17 <byorgey> foxy: you are trying to call 'read' on something which can't be parsed to a value of the required type.
17:12:27 <byorgey> foxy: ah, indeed
17:12:33 <foxy> seems to work now, thanks all
17:14:14 <rabby> does anyone have an idea how to fit my types?
17:14:21 <byorgey> rabby: you need to take away the parens around (movebubble s) in line 11.
17:14:46 --- mode: ChanServ set +o dons
17:14:51 --- topic: set to '["Grassroots efforts take effort!", "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/", "visualise #haskell's social network : http://tinyurl.com/ytzeab"]' by dons
17:14:56 --- mode: ChanServ set -o dons
17:15:00 <byorgey> (movebubble s) :: [Int], but iter is expecting a second argument of type  a -> a.
17:15:10 <rabby> thx
17:15:11 <byorgey> so you need to give it movebubble as its second parameter.
17:15:24 <dcoutts_> byorgey: thanks for the patches :-)
17:15:27 <byorgey> iter then produces an iterated function which is applied to s.
17:15:28 <rabby> why the hell does haskell make a difference of that?!
17:15:29 <byorgey> dcoutts_: sure =)
17:15:35 * dcoutts_ reviews cabal patches...
17:15:47 <byorgey> rabby: um... because it doesn't make sense otherwise?
17:15:58 * dcoutts_ is satisfied and pushes...
17:16:07 <byorgey> rabby: note that f a b c   gets parsed as (((f a) b) c)
17:16:08 <rabby> ususally it ignores my brakets
17:16:17 <byorgey> rabby: well, sometimes they matter
17:16:18 <LoganCapaldo> trust the compiler. the compiler is your friend
17:16:19 <rabby> parens
17:16:38 <byorgey> rabby: if you write f a (b c), this gets parsed as (f a) (b c) instead of ((f a) b) c, which as you can see is very different
17:16:48 <dcoutts_> only 14 'easy' Cabal tickets left! :-)
17:16:52 <Cale> Heh, I just realised that I have more Zappa music than many people have music altogether.
17:16:54 <dcoutts_> http://hackage.haskell.org/trac/hackage/report/13
17:16:55 <lambdabot> Title: {13} Easy tickets - Hackage - Trac
17:17:20 <dcoutts_> and we're nearly up to 50% of the tickets for the Cabal-1.4 milestone
17:17:25 <dcoutts_> http://hackage.haskell.org/trac/hackage/roadmap
17:17:26 <hpaste>  dolio annotated "bubblesort - Int-only" with "suggestion" at http://hpaste.org/5625#a1
17:17:26 <lambdabot> Title: Roadmap - Hackage - Trac
17:18:12 <LoganCapaldo> hmmm
17:18:20 <LoganCapaldo> difficulty ratings on bug reports
17:18:23 <glen_quagmire> mauke: hGetBuffering stdout   in ghci
17:18:25 <LoganCapaldo> that's a good idea
17:18:29 <mauke> glen_quagmire: ghci is special
17:18:39 <dcoutts_> LoganCapaldo: it certainly is
17:18:48 <glen_quagmire> mauke: oh i see
17:18:57 <mauke> try main = hGetBuffering stdout >>= print in a compiled program
17:19:05 <LoganCapaldo> that a normal part of trac?
17:19:08 <mauke> try ./a.out and ./a.out | cat
17:19:51 <glen_quagmire> woot it's LineBuffering
17:20:11 <glen_quagmire> BlockBuffering Nothing   when I do ./a.out | cat
17:20:23 <mauke> yep
17:20:59 <glen_quagmire> why is ./a.out   and ./a.out |cat different?    ./a.out |cat is stdin ?
17:21:35 <mauke> what?
17:21:46 <mauke> ./a.out | cat makes a.out's stdout a pipe, not a terminal
17:22:03 <dcoutts_> LoganCapaldo: no, we had to customise it, ghc did it first and we copied the code
17:22:21 <LoganCapaldo> dcoutts: ah cool
17:23:18 <dcoutts_> byorgey: btw, if you want more useful parsery kind of tasks, there's http://hackage.haskell.org/trac/hackage/ticket/223
17:23:20 <lambdabot> Title: #223 (allow per-package configuration options in config file) - Hackage - Trac
17:23:41 <litb> glen_quagmire: a.out | cat makes will append the stdout of a.out with the one of makes
17:23:41 <glen_quagmire> ohrm
17:24:00 <litb> ah, no
17:24:21 <litb> then they changed it. i could swear in the past that was so
17:24:25 <glen_quagmire> so terminal out put is line buffered. but output to pipe is implementation dependent
17:24:47 <pgavin> dcoutts_: hi
17:24:54 <litb> looks like the stdout of a.out is ignored
17:25:03 <byorgey> dcoutts_: ok, thanks
17:25:17 <dcoutts_> pgavin: hia
17:26:05 <litb> oh, you didn't mean "./a.out | cat makes" lol
17:26:13 <dcoutts_> byorgey: basically the cabal-install config file writing needs replacing and I rather like the Command style that we use for mapping WhateverFlags types to/from command line args
17:26:30 <gnuvince_> I'm currently reading the "Scheme interpreter in 48 hours", and I am stuck on an exercise.  Currently, my strings cannot have embedded double-quotes, the exercise says to fix that.  Do I know at this point what I need to do that, or do I need to look in the reference or Parsec?
17:26:40 <pgavin> dcoutts_: I guess I haven't been paying attention the last month or so, has any progress been made with dep analysis in cabal?
17:26:40 <dcoutts_> byorgey: and I think we could do something very similar for mapping to/from simple config files
17:27:22 <pgavin> gnuvince_: you'll probably need parsec
17:27:32 <dcoutts_> pgavin: not a lot, though we've been thinking about it a bit, we have some ideas but it's finding time to try them out
17:28:01 <gnuvince_> pgavin: They already are using Parsec.  What I mean is, is the function I need already covered in the material?
17:28:22 <pgavin> gnuvince_: oh, I couldn't tell you :)
17:28:38 <pgavin> dcoutts_: hmm... ok
17:28:51 <mauke> no idea but in regex it'd be "([^"\\]|\\.)*"
17:29:14 <pgavin> dcoutts_: i suppose manuel c. had the same problem w/ respect to ranlib
17:29:36 <dcoutts_> byorgey: so for example we have ConfigFlags and then the configureCommand :: CommandUI ConfigFlags is an abstraction we use to convert to and from [String] style command line flags. So a config file is also quite similar so it seems we could do something as nice.
17:29:55 <dcoutts_> pgavin: yes, so we'll either use your patch or something similar
17:30:00 <byorgey> dcoutts_: ok, sounds interesting.
17:30:03 <pgavin> dcoutts_: ok :)
17:30:27 <byorgey> dcoutts_: I can't promise anything, but I might take a look at some point
17:30:54 <ddarius> dons: Haskellers not working hard enough?
17:31:02 <gnuvince_> pgavin: Just yes or no: is what I need already covered?
17:31:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5626
17:31:09 <dcoutts_> byorgey: then it should also allow us to do nicer config files, eg not just put in the values that are used but also things like: --foo:   for a filed that someone could uncomment and use. That way we never need a reference of what are valid fields.
17:31:20 <dcoutts_> byorgey: sure, no promises required :-)
17:31:38 <byorgey> dcoutts_: yeah, that sounds nice
17:31:45 <dons> ddarius: oh, just a bit of frustration with whinging bloggers
17:31:55 <ddarius> dons: Such as?
17:32:04 <dons> see planet.haskell
17:32:04 <gnuvince_> Steve Yegge
17:32:18 <jeffz> steve yegge is a troll
17:32:18 <byorgey> dcoutts_: you do a good job selling these things =)
17:32:22 <dcoutts_> :-)
17:32:52 <dcoutts_> byorgey: trying to get more people to hack on vital community infrastructure is always a good thing :-)
17:33:00 <byorgey> dcoutts_: I agree!
17:33:20 <dons> ddarius: kevin's complaints boil down to xml not being easy atm.
17:33:45 <Cale> XML is inherently difficult.
17:33:55 <foxy> I'm slurping in a large data file (10MB) with bytestrings and parsing a header.  The header parses, but without touching the data I get a stack overflow?
17:34:17 <Cale> foxy: lazy bytestrings?
17:34:22 <dons> you have some loop that's a bit odd?
17:34:45 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5626#a1
17:35:08 <foxy> is ByteString lazy or strict?
17:35:29 <pgavin> foxy: not sure, but I think it's strict
17:35:32 <Cale> foxy: There's Data.ByteString (which is strict), and then Data.ByteString.Lazy (which is lazy)
17:35:42 <foxy> I'll try lazifying
17:35:50 <Cale> It may or may not help.
17:35:55 <LoganCapaldo> well Lazy is  a lazy list of strict chuks, isn't it?
17:36:00 <LoganCapaldo> *chucks
17:36:00 <Cale> LoganCapaldo: right
17:36:06 <Cale> chunks :)
17:36:18 <Saizan> LoganCapaldo: a bit stricter than that
17:36:30 <Cale> foxy: Stack overflows usually indicate that you're building up a large expression which isn't being evaluated until much too late.
17:36:39 <dons> i doubt its the data type that's the problem here.
17:37:02 <Cale> foxy: Expressions in Haskell are evaluted outermost first, so function parameters can accumulate large expressions if you write things in a tail-recursive fashion.
17:37:03 <ddarius> or perhaps there's just an infinite loop somewhere
17:37:11 <Cale> That's also possible :)
17:37:38 <Cale> foxy: If you're on GHC 6.8.2, you could do :set -fbreak-on-exception, and then :trace main
17:37:51 <Cale> (or whatever expression is causing the problem)
17:38:16 <Cale> When it crashes, you can (hopefully) use some combination of :list and :back to figure out where it's happening.
17:38:23 <foxy> ok, thanks
17:38:39 <litb> wow that scheme in 48 hours is attracting really
17:38:50 <foxy> Lazy bytstring appears to have a slightly different interface from strict (specifically splitAt)
17:38:56 <foxy> @type splitAt
17:38:59 <lambdabot> forall a. Int -> [a] -> ([a], [a])
17:39:10 <LoganCapaldo> @hoogle splitAt
17:39:10 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
17:39:11 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
17:39:11 <lambdabot> Data.ByteString.splitAt :: Int -> ByteString -> (ByteString, ByteString)
17:39:18 <foxy> @type Data.ByteString.splitAt
17:39:19 <lambdabot> Int -> Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString, Data.ByteString.Internal.ByteString)
17:39:35 <foxy> @type Data.ByteString.Lazy.splitAt
17:39:36 <lambdabot> Int64 -> Data.ByteString.Lazy.Internal.ByteString -> (Data.ByteString.Lazy.Internal.ByteString, Data.ByteString.Lazy.Internal.ByteString)
17:39:59 <Cale> oh, Int64 rather than Int?
17:40:03 <foxy> Int vs. Int64
17:40:05 <Cale> yeah
17:40:08 <LoganCapaldo> that's a biggah split
17:40:11 <Cale> fromIntegral will convert
17:40:22 <foxy> k
17:40:45 <LoganCapaldo> > 23 :: Int64
17:40:47 <lambdabot>  23
17:41:05 <Cale> I really dislike these partial integer types. I wish we could use Integer, or else make things polymorphic.
17:41:41 <LoganCapaldo> it could be worse
17:42:19 <Cale> http://cale.yi.org/autoshare/Screenshot-Frank%20Zappa.png -- Frank Zappa obsession? What Frank Zappa obsession?
17:42:23 <TomMD> I really wouldn't want the performance hit from length = genericLength
17:42:30 <TomMD> at its ilk
17:42:32 <patperry> is there a way to find out how many cores a machine has?  or to find out what number gets passed to the RTS via -N# ?
17:42:35 <TomMD> s/at/and
17:42:44 <Cale> TomMD: There are pragmas to help GHC specialise things :)
17:42:47 <LoganCapaldo> you could have automatic coercions
17:42:53 <pgavin> patperry: cat /proc/cpuinfo :b
17:43:04 <LoganCapaldo> ie allow Int -> Int64 withut actually calling fromIntegral
17:43:06 * LoganCapaldo hides
17:43:08 <patperry> is there a haskell function for that?
17:43:48 <LoganCapaldo> readFile "/proc/cpuinfo" :[
17:43:51 <pgavin> patperry: the rts docs would be a good place to look
17:43:51 <TomMD> yes:  convertThisInt = fromIntegral in { ... }
17:44:03 <Cale> patperry: I'm not sure. The usual approach is to create as many threads as you need, and let the n:m scheduler take care of it.
17:44:22 <Cale> patperry: But it does seem like a glaring omission from the API nonetheless.
17:44:46 <Cale> (also, would be nice to have a way for programs to adjust their scheduling themselves.)
17:44:59 <Cale> (at least, the -N parameter)
17:45:51 <patperry> thanks, guys.  I don't really want to run more threads than cores since i have a significant setup overhead for each worker
17:47:32 <Cale> Actually... let me try something :)
17:48:51 <byorgey> uh-oh...
17:49:13 <byorgey> <Cale> Actually... let me try something :)  <-- evil grin??
17:50:15 <Cale> yes, quite evil. I have no idea if this'll work :)
17:50:58 <faxathisia> Has anyone read the Agda 2 source code?
17:51:53 <Cale> hmm, doesn't seem to...
17:52:16 <patperry> well, thanks for trying.  that was pretty exciting
17:52:52 <Cale> er, actually, I'm doing something wrong.
17:53:04 <Cale> I'll figure it out :)
17:53:33 <Cale> basic idea: use the FFI to import ghc_rts_opts, which is the RTS options hook usually used to compile in RTS settings.
17:56:11 <pgavin> is this valid? --->   ts :: s -> IO (Ord o => o)
17:56:38 <pgavin> basically, the return value is unimportant, I only care about its order
17:57:01 <Cale> okay, no, that doesn't work. I can get at the baked-in value, but not the one passed on the commandline.
17:57:37 <patperry> shucks.  sounds like a heroic effort, though
17:57:49 <Cale> pgavin: More likely:  ts :: Ord o => s -> IO o
17:58:01 <pgavin> Cale: I know, I've confused myself :b
17:58:13 <pgavin> Cale: I'm not sure what I meant there
17:58:25 <mauke> ts :: s -> IO (forall o. Ord o => o)
17:58:40 <pgavin> mauke: that's what I meant
17:58:58 <pgavin> mauke: does that do what I think it does?
17:59:21 <Cale> I don't think there are many values of that type.
17:59:37 <patperry> mauke: is that a valid type?
17:59:51 <Cale> Specifically, I'm pretty sure the only value of type forall o. Ord o => o is bottom.
17:59:58 <mauke> I think so, but where will we find an open tattoo parlor at this time of night?
18:00:54 <patperry> ts:: exists o. Ord o => s -> IO o
18:01:18 <pgavin> Cale: I see what you mean
18:01:41 <pgavin> Cale: but is there a way to say what I mean?
18:02:03 <pgavin> I mean, no one should ever care what o is, just that it's Ord
18:02:05 <Cale> You want that there exists some type o which is an instance of Ord?
18:02:14 <Cale> But that's also kind of dumb
18:02:23 <pgavin> lol
18:02:28 <Cale> Because all the Ord operations take two values of the same Ord type.
18:02:29 <pgavin> maybe
18:02:32 <mauke> what would you do with such a value?
18:02:38 <Cale> So all you could do is compare one of these things with itself.
18:02:50 <pgavin> mauke: use it as a timestamp
18:02:53 <Cale> You could never compare one with any other one.
18:02:55 <mauke> pgavin: how?
18:03:02 <pgavin> Cale: ah, right
18:03:07 <Cale> Because you've thrown away which type they were :)
18:03:12 <pgavin> ok, gotcha
18:04:00 <pgavin> sometimes I get these crazy ideas and end up forgetting the simple stuff
18:04:03 <faxathisia> How do you get used to reading and understanding someone elses code?
18:04:13 <pgavin> faxathisia: do it
18:04:17 <Cale> faxathisia: Use the types Luke. :)
18:04:48 <Cale> If it's well-written code, the types should explain how things fit together.
18:05:00 <faxathisia> this is some mad type checker
18:06:35 <byorgey> @brain
18:06:35 <lambdabot> I think so, Brain, but Lederhosen won't stretch that far.
18:06:43 <Cale> @ghc
18:06:43 <lambdabot> ghc says: Bad eta expand
18:06:49 <Cale> @ghc
18:06:49 <lambdabot> ghc says: Offending Program
18:06:53 <Cale> @ghc
18:06:54 <lambdabot> ghc says: All of the type variables in the constraint are already in scope (at least one must be universally quantified here)
18:07:00 <mauke> Bad eta! No quack.
18:07:08 <Cale> @keal
18:07:08 <lambdabot> are you saying i am MegaMonad?
18:07:10 <Cale> @keal
18:07:11 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
18:07:24 <Cale> @palomer
18:07:24 <lambdabot> That's a lie
18:07:29 <Cale> @palomer
18:07:30 <lambdabot> Category theory is the Paris Hilton of mathematics
18:07:36 <byorgey> wha...?!
18:07:48 <faxathisia> haha
18:07:54 <foxy> my lazybytestrings look like "Chunk "BIOSEMI" Empty", how do I get the data part out?
18:08:17 <byorgey> foxy: unpack, maybe?
18:08:28 <foxy> @type unpack
18:08:43 <lambdabot> thread killed
18:08:54 <foxy> @hoogle unpack
18:08:55 <lambdabot> Data.ByteString.unpack :: ByteString -> [Word8]
18:08:55 <lambdabot> Data.ByteString.Char8.unpack :: ByteString -> [Char]
18:08:55 <lambdabot> Data.ByteString.Lazy.unpack :: ByteString -> [Word8]
18:08:57 <Cale> foxy: You want to convert to a String?
18:09:21 <foxy> @paste
18:09:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:10:32 <faxathisia> stuff like, ConP i c ps -> ConP i c $ (fmap . fmap . fmap . fmap) f ps
18:11:25 <mauke> you know, that last part could be rewritten as (fmap (fmap (fmap fmap fmap) fmap) fmap) f ps
18:12:00 <foxy> Cale: yes
18:12:11 <faxathisia> lol
18:12:19 <faxathisia> I'm never gonna understand this :(
18:12:22 <Cale> foxy: yeah, unpack for a Data.ByteString.Char8 ByteString should work
18:12:26 <Chad> reminds me of "buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo"
18:12:28 <ddarius> Or for Cale: (.) ((.) ((.) (.) (.)) (.)) (.))
18:12:32 <Cale> faxathisia: nice
18:12:49 <Cale> ddarius: I'd write it (map . map . map . map) still :)
18:13:02 <Cale> ddarius: (I want both map and (.) to mean functor application :)
18:13:23 <faxathisia> If I just stare at this code for 3 hours it will suddenly make sense?
18:13:49 <foxy> Cale: I'm using lazy bytestrings for which unpack returns [Word8], how should I convert this to [Char] ?
18:14:12 <Chad> faxathisia: I would take pieces at a time and check some types by hand, that might help
18:14:42 <Cale> foxy: Use Data.ByteString.Lazy.Char8 instead, I think.
18:14:52 <foxy> ok
18:14:52 <mauke> map (toEnum . fromEnum) -- hax
18:15:59 <foxy> @djinn Word8 -> Char
18:16:00 <lambdabot> -- f cannot be realized.
18:16:12 <Cale> djinn doesn't know about those types
18:16:24 <foxy> Cale: most of my stuff uses Word8's and only in a few places do I need to convert to Char
18:16:28 <Cale> ah, okay
18:16:31 <foxy> is there a function to do that?
18:16:33 <Cale> then go with mauke's way
18:16:46 <foxy> ah, cool, thanks
18:16:53 <Cale> :t toEnum . fromEnum :: Word8 -> Char
18:16:55 <lambdabot> Word8 -> Char
18:17:47 <hpaste>  litb pasted "hmm, why otherwise and not _ ?" at http://hpaste.org/5627
18:18:25 <patperry> if I have "data Matrix mn a" with "mn" a phantom type, is it ok to unsafeCoerce between "Matrix (m,n) a" and "Matrix mn a"?
18:18:38 <mauke> litb: a "bug"
18:19:18 <byorgey> litb: eh?  otherwise doesn't make sense there
18:20:52 <foxy> OK, that all works, now I still get a stack overflow after my header is read, this is after switching to lazy bytestrings
18:21:27 <EvilTerran> litb, _ should work fine there
18:21:47 <litb> yes, same what i think
18:21:58 <EvilTerran> byorgey, litb: that's just making a new, local binding to "otherwise" independent of the Prelude one
18:22:06 <EvilTerran> ?src otherwise -- it's not magic
18:22:06 <lambdabot> Source not found.
18:22:11 <EvilTerran> ?src otherwise
18:22:11 <lambdabot> otherwise = True
18:22:38 <byorgey> EvilTerran: aha, of course
18:22:45 <litb> EvilTerran: it is not an error?
18:23:02 <EvilTerran> > let otherwise = "anything you like" in otherwise
18:23:16 <lambdabot>  "anything you like"
18:23:21 <litb> > case 10 in otherwise -> "holla"
18:23:21 <lambdabot>  Parse error at "in" (column 9)
18:23:22 <EvilTerran> > case 1 of 2 -> "two"; otherwise -> otherwise
18:23:23 <lambdabot>   add an instance declaration for (Num [Char])
18:23:24 <lambdabot>     In the scrutinee of a case...
18:23:28 <litb> > case 10 of otherwise -> "holla"
18:23:29 <lambdabot>  "holla"
18:23:34 <EvilTerran> yes, quite
18:23:38 <litb> ah, and otherwise is 10 then?
18:23:49 <EvilTerran> "otherwise" is just a name
18:23:58 <litb> > case 10 of otherwise -> otherwise
18:23:58 <lambdabot>  10
18:24:03 <litb> alright
18:24:13 <litb> ah, right, as it is in function parameters
18:24:27 <EvilTerran> as the lovely lambdabot so elegantly put it, "otherwise = True"
18:24:31 <EvilTerran> @bot
18:24:31 <lambdabot> :)
18:24:36 <litb> heh
18:24:51 <litb> actually that scheme thing rocks. very lovely to read it :)
18:25:17 <faxathisia> which scheme?
18:26:20 <litb> "Write Yourself a Scheme in 48 Hours"
18:26:42 <faxathisia> oh yeah
18:26:54 <EvilTerran> the Scheme scheme
18:26:56 <faxathisia> I don't think the tutorial has mutable structures
18:27:22 <faxathisia> like, program code..
18:28:11 <litb> yeah, i've not found set . but you can call functions fold map and stuff. quite fun
18:29:39 <ricky_clarkson> > let stuff x=if (x<3) then 2 else 5 in stuff 1
18:29:54 <lambdabot>  thread killed
18:30:56 <mauke> > let stuff x=if (x<3) then 2 else 5 in stuff 1
18:30:57 <lambdabot>  2
18:31:24 <EvilTerran> @vixen has ricky done something to upset you?
18:31:24 <lambdabot> me?
18:31:47 <EvilTerran> oh well. fickle thing, women.
18:40:24 <hrehf> is (foo >>= bar) equivalent to (foo >>= (\x -> bar x))?
18:41:06 <faxathisia> Yes
18:41:19 <hrehf> ;) thanks
18:41:21 <EvilTerran> (\x -> bar x) = bar, under all circumstances
18:41:48 <EvilTerran> functional purity gives us the ability to do such equational reasoning; it's nice like that
18:42:08 <byorgey> EvilTerran: but not the other way around ;)
18:42:23 <EvilTerran> no?
18:42:27 <wagle> > (\x -> - 1)
18:42:30 <lambdabot>  Add a type signature
18:42:37 <wagle> > (\x -> - 1) :: Expr
18:42:37 <lambdabot>      The lambda expression `\ x -> ...' has one argument,
18:42:38 <lambdabot>     but its type `E...
18:42:40 <hrehf> yeah, but this is, well.... inside a monad?
18:42:56 <wagle> > (\x -> -1) :: Expr
18:42:58 <lambdabot>      The lambda expression `\ x -> ...' has one argument,
18:42:58 <lambdabot>     but its type `E...
18:43:09 <hrehf> so, i was unsure about the 'functional purity'
18:43:23 <mauke> hrehf: functional purity is preserved
18:43:26 <mauke> >>= is not magic
18:43:38 <wagle> :t (\x -> -1)
18:43:41 <lambdabot> forall t a. (Num a) => t -> a
18:43:47 <wagle> :t -
18:43:48 <lambdabot> parse error (possibly incorrect indentation)
18:43:48 <scook0> eta-expansion can give different results in the presence of seq and _|_, can't it?
18:43:52 <wagle> ha!
18:44:09 <hrehf> :t >>=
18:44:09 <lambdabot> parse error on input `>>='
18:44:14 <mauke> :t (>>=)
18:44:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:44:27 <scook0> though I suppose seqing undefined functions is not something you should be doing
18:45:39 <hrehf> well, thanks for the info - this is for a presentation (on STM -> Haskell STM implementation -> me talking about monads :|), so i needed to double check ;)
18:48:10 <LoganCapaldo> mooooohanads
18:48:43 <LoganCapaldo> a :kinder, gently monad
18:48:44 <EvilTerran> scook0, well, i can see that maybe undefined /= (\x -> undefined x) under some circumstances
18:48:44 <mauke> we are haskell nomads
18:48:56 <LoganCapaldo> nomadic monadic combinators
18:49:20 <LoganCapaldo> > fix undefined
18:49:21 <EvilTerran> we ride our lambdas around the desert, finding wells of purity amoung the harsh dunes of side-effects
18:49:24 <lambdabot>  Undefined
18:49:30 <LoganCapaldo> I said fix it!
18:49:39 <LoganCapaldo> > fix error
18:49:39 <lambdabot>  Exception: <<loop>>
18:50:18 <EvilTerran> undefined is already fixed! embrace the podge!
18:52:56 <mauke> EvilTerran: http://dis.4chan.org/read/prog/1202856797/1-40
18:52:57 <lambdabot> Title: 4chan BBS - Original Content
18:53:30 <gwern> man, HaXml is getting no love at all on reddit - http://reddit.com/info/68jdx/comments/
18:54:18 <gwern> mauke: brillig!
18:54:21 <gwern> 'The Nomads didn't need much armor - they travelled fast and they travelled hard, almost as hard as the Sussman rides your sister's ass every night when you're alone in your room whacking off to the sacred tomes. And they were armed to the teeth. They provided a deterministic and constant effect to the battle, such that their arrival could almost be curried to optimize the battle's execution speed and bring it to a quick close.'
18:54:22 <faxathisia> mauke: http://img401.imageshack.us/img401/1856/haskellmonadstc8mw8.jpg
18:55:25 * qwr actually liked haxml. and fetching dtd's over network seems stupid idea...
18:55:56 <gwern> dunno. aren't some dts supposed to be fetched?
18:55:59 <litb> > (+ 3 4)
18:55:59 <lambdabot>   add an instance declaration for (Num (t -> a))
18:56:09 <litb> > (+ 3) 4
18:56:10 <lambdabot>  7
18:56:12 <faxathisia> > ((+) 3 4)
18:56:13 <lambdabot>  7
18:56:16 * gwern was just reading about the w3c getting millions of automatic downloads of one of its dtds
18:56:21 <faxathisia> > (3 +)  4
18:56:21 <lambdabot>  7
18:58:06 <stepcut> does the following give you random results in ghc 6.8 (works fine for me in 6.6 and 6.4):
18:58:08 <stepcut> System.Posix.Files.getSymbolicLinkStatus "/etc/motd" >>= print .  System.Posix.Files.fileID
18:59:09 <jeffz> > System.Posix.Files.getSymbolicLinkStatus "/etc/motd" >>= print . System.Posix.Files.fileID
18:59:13 <lambdabot>   Not in scope: `System.Posix.Files.fileID'
19:00:26 <stepcut> lambdabot does not do IO
19:00:39 * gwern has not /etc/motd, or I'd try
19:01:09 <jeffz> stepcut: produces the same value on each invocation for me.. 404970
19:01:34 <stepcut> jeffz: what version of the compiler/OS
19:01:53 <jeffz> stepcut: Ubuntu 7.10, ghc 6.8.2
19:02:03 <stepcut> ok
19:03:39 <stepcut> I am using the 6.8.2+Ubuntu 7.10 as well, though I see it on a number of machines :-/
19:03:50 <wagle> tupid religion, i cant stand to use global vars in a bash script
19:03:57 <wagle> stupid
19:04:00 <stepcut> jeffz: what version of libc6 ?
19:04:26 <stepcut> i cant stand to use bash script
19:04:43 <jeffz> stepcut: libc-2.6.1
19:05:26 <mauke> stepcut: I get completely bogus results
19:06:01 <kfish> is there some trick to getting haddock to work on files using cpp macros ({-# OPTIONS_GHC -cpp #-}) ?
19:06:09 * qwr . o O ( bash is not so bad... after seeing jelly. )
19:06:17 <wagle> stepcut, it pays the bills
19:06:19 <stepcut> jeffz: 2.6.1-1ubuntu10 ?
19:06:33 <wagle> (hahah)
19:06:38 <EvilTerran> kfish, i think you need to get the preprocessor output to pass to haddock. not sure.,
19:06:44 <stepcut> mauke: thanks. This is bad news for me :-(
19:07:00 <mauke> newtype FileStatus = FileStatus (ForeignPtr CStat)
19:07:05 <mauke> WHOSE IDEA WAS THIS
19:07:05 <EvilTerran> wagle, wait for a while, maybe someone'll write a bash backend for YHC
19:07:30 <jeffz> stepcut: yes
19:07:37 <EvilTerran> then you can compile your .hs to .sh :D
19:07:41 <stepcut> jeffz: ok. thanks.
19:08:03 <kfish> EvilTerran, hmm, ... i wonder how to get cabal to invoke that ...
19:08:38 <stepcut> mauke: if you can submit a patch that works in the next 15 hours, you can be my new best friend ;)
19:08:46 <mauke> stepcut: seems to print 0 for everything
19:08:49 <wagle> EvilTerran, whoa
19:08:54 <mauke> in a compiled program, at least
19:09:10 <qwr>  
19:09:17 <stepcut> mauke: in ghci I get random numbers
19:09:28 <mauke> yeah, me too
19:09:46 <mauke> fileID (FileStatus stat) = unsafePerformIO $ withForeignPtr stat $ ((\hsc_ptr -> peekByteOff hsc_ptr 8))
19:10:05 <mauke> who maintains unix?
19:10:08 <stepcut> mauke: however, the bug I am seeing in my program would make more sense if it was 0 in compiled code, because I am seeing it compare true when it should be false
19:10:36 <stepcut> mauke: Maintainer	libraries@haskell.org
19:10:55 <mauke> are you going to file a bug report?
19:11:43 <thetallguy> stepcut: I get varying results, but not random
19:11:59 <thetallguy> stepcut: somevalues repeat
19:12:11 <stepcut> thetallguy: yes, I may be seeing that as well
19:12:46 <stepcut> mauke: yes, but perhaps not until saturday. I have a unmissable deadline this week :(
19:13:59 * stepcut goes home, back in a bit
19:14:38 <wagle> (besides, you can algebraically transform / refactor bash scripts..  8-p)
19:19:25 <wagle> its all referentially transparent, you just gotta use a particularly hairy version of "equals", and restrict commutivity
19:21:29 <EvilTerran> good luck giving a big enough subset of bash sufficiently rigorous semantics to be able to actually do a signifcant amount of such reasoning, tho
19:22:26 <wagle> only have to do that for the subset i'm using
19:31:26 <wagle> its just like the dependency analysis / etc of an optimizing compiler, except that i do it in my head, and get to come up with new rules on the fly..  mind you, bash is terribly ugly, but its amusing to manipulate
19:32:14 * LoganCapaldo slowly backs away from wagle
19:32:29 <EvilTerran> sounds like the perverse satisfaction i get from beating the java type system into submission
19:32:53 <EvilTerran> "woo! now my code looks like i have algebraic types!"
19:33:03 <dobblego> lol
19:33:29 <EvilTerran> altho i still don't get why the modern c-like languages lack tuples
19:33:47 <EvilTerran> it'd even make sense for something low-level like C to have them
19:34:06 <LoganCapaldo> yeah it's an irritating lack
19:34:08 <EvilTerran> you could return them like you take in a tuple of parameters; an appropriate mix of registers and the stack
19:34:15 <scook0> @hoogle liftM
19:34:16 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
19:34:16 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:34:16 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
19:34:17 <awesame> C# has tuples, I believe
19:34:36 <awesame> as well as anonymous structures in newer versions
19:34:37 <EvilTerran> and, apart from passing in and out of functions, it'd desugar pretty easily to bog-standard C
19:34:58 <EvilTerran> even parallel assignment's pretty straightforward to desugar
19:35:10 <awesame> I strongly agree that more c-like languages should have them
19:35:16 <LoganCapaldo> indeed
19:35:30 <LoganCapaldo> C + tuples would be an awesome langauge <g>
19:37:17 <LoganCapaldo> std::pair just doesn't cut it
19:37:23 <gwern> hey, anyone want to read a short little essay I'm writing on long-term maintainable haskell code?
19:38:04 <hpaste>  gwern pasted "long-term code" at http://hpaste.org/5628
19:38:05 <cjb> gwern: sure
19:38:43 <cjb> it *does* seem anal to explicitly enumerate imports ;-)
19:38:58 * gwern should put in a clause, don't bother for the Prelude
19:39:24 <gwern> cjb: yes, but with Haskell in Space, for example, if the relatively few imports had been enumerated, my time would've been cut in half, easy
19:39:33 <cjb> huh
19:40:00 <bos> gwern: good advice
19:40:07 <gwern> function names often stay the same, but they get moved around. easy to look them up in an index - if you know what you're looking for
19:40:17 <gwern> and of course, imports are resolved before the code is ever checked!
19:40:29 <awesame> this document talks a little bit about tuples and other features in C# that were inspired in part by ML-variant F#: http://tomasp.net/articles/csharp3-concepts.aspx
19:40:30 <lambdabot> Title: Concepts behind the C# 3.0 language | Articles | TomasP.Net
19:41:57 <wagle> i want polymorphism across all arities of tuples! bwahahaha
19:46:24 <wagle> actually, i prefer records to tuples..  tuples seem to just be multivalues to me or something (which I rarely use)
19:47:00 <LoganCapaldo> don't you get sick of coming up with names for fields?
19:47:09 <LoganCapaldo> I sure do
19:47:18 <gwern> short tuples work very nicely for somethings. have you seen the definition for runlength decoding of rle'd tuples, ' rleDecode = (uncurry replicate =<<)'?
19:48:08 <gwern> I dunno how you could come up with anything near as nice using records
19:48:30 <wagle> i like self-documenting with good names..  types don't quite do it for me
19:49:04 <wagle> :t replicate
19:49:07 <lambdabot> forall a. Int -> a -> [a]
19:49:33 <gwern> 'In the long run, the utility of all non-Free software approaches zero. All non-Free software is a dead end. '
19:50:01 <ddarius> :t uncurry replicate
19:50:08 <wagle> in the end all entities die.  dont bother living.
19:50:17 <lambdabot> thread killed
19:50:34 <wagle> in the long run, in the end all entities die.  dont bother living.
19:50:45 <wagle> sigh
19:51:27 <gwern> fundamentally, nonfree licensing is accidental complexity
19:51:32 <dmwit> That was a fun coincidence.
19:51:48 <dmwit> "in the end all entities die." "thread killed"
19:52:01 <gwern> very appropriate
19:52:10 <ddarius> Most Haskell things are BSD(ish) licensed rather than GPL
19:52:22 <cjb> yeah, that's a little odd to me
19:52:39 <cjb> I guess it stems from GHC
19:53:02 <ddarius> I doubt that
19:53:58 <gwern> no, I think that makes sense. stuff had to be bsd if it wanted to make it in to the base libraries and get propagated
19:54:23 <gwern> and once you have a tipping point, then bsd might just become the thing to do because everyone else is doing it
19:54:48 <hpaste>  gwern annotated "long-term code" with "update" at http://hpaste.org/5628#a1
19:55:17 <EvilTerran> IMO, swapping proprietory for GPL is one evil for another
19:55:17 * gwern can't think of anything else I really learned in my software archaeology
19:55:30 <EvilTerran> it's still a liscence that the vast majority of people who agree to it won't read
19:55:51 <gwern> gpl doesn't strike me as particularly evil
19:56:05 <dons> ok, some new stuff for you guys, parsec for python, http://reddit.com/r/programming/info/68kcj/comments/  , using short variable names in haskell, http://reddit.com/r/programming/info/68kce/comments/ and a discussion of 'flip' and ruby, http://reddit.com/r/programming/info/68kc3/comments/
19:56:06 <cjb> I don't think GPL is evil at all
19:56:10 <EvilTerran> and, as long as people keep pushing that sort of thing, the whole sorry state of EULAs is never going to go anywhere
19:56:20 <cjb> GPL is not a EULA.
19:56:32 <cjb> it imposes _no restrictions_ on end-users.
19:56:46 <gwern> just distributors...
19:56:53 <cjb> yes.
19:57:01 <wagle> sure it does..  they cant (re-)distribute it without including the source
19:57:15 <gwern> dons: you remember suggesting I should write up my thoughts? see http://hpaste.org/5628#a1
19:57:17 <wagle> they cant remove the license
19:57:18 <jeffz> wagle: they can, they are required to provide it upon request
19:57:38 <cjb> wagle: right.  but then we are talking about someone who is modifying source and wanting to distribute it under different terms, not an end-user who wants to use a program.
19:57:43 <EvilTerran> missing the point
19:58:00 <wagle> jeffz, i just watch others interpret the GPL
19:58:00 <gwern> (yay, another TagSoup user. good library)
19:58:27 <ddarius> dons: I added a list of Parsec clones to the Parsec wiki page a few weeks ago
19:58:52 <wagle> yeah, but every end-user is a potential distributer, in these internet days
19:59:07 <dons> very interesting, gwern
19:59:14 <dons> ddarius: cheers
19:59:21 <thoughtpolice> you don't have to redistribute source with binaries, but you do have to have a reasonable way for those to access the source for an end-user or provide it when asked.
19:59:25 <dons> tagsoup is the anti-haxml
19:59:49 <gwern> hah. I saw you bashing on HaXml there
19:59:57 <EvilTerran> i just think it's stupid that everyone throws around licences that they know damn well the vast majority of people will blindly accept without reading
20:00:03 * gwern will include a link to that next time I email the HaXml maintainer
20:00:15 <EvilTerran> and the GPL suffers from that as much as any other license of that sort of length
20:00:43 <dons> haxml will get wiped out by some 5 module xml parser that half works
20:00:46 <gwern> EvilTerran: are you objecting to it as paternalism? 'Use the GPL, because you and others are too greedy and stupid to think long-term and preserve your freedoms yourself'
20:00:48 <dons> just by virtue of being simple
20:01:08 <EvilTerran> gwern, not at the moment, no
20:01:27 <EvilTerran> see what i just said; it's long, meandering chunks of legalese that get my goat
20:01:30 <wagle> i'm all for free-speech software..  i'm dubious about free-beer software
20:02:02 <gwern> EvilTerran: well, uh, what's the alternative? I understand the FSF has had very good lawyers go over it, and that you need the legalese to make it tight
20:02:11 <EvilTerran> BSD, for starters
20:02:24 <gwern> CC's human-readable stuff is just a stunt, and BSD doesn't do nearly as much as the GPL
20:02:34 <cjb> EvilTerran: are you aware that the GPL isn't actually written in legalese at all, and that the first paragraph clearly explains its intentions in readable English?
20:02:35 <EvilTerran> most people don't *need* all the GPL
20:02:56 <EvilTerran> cjb, still, what percentage of punters are actually gonna read it before they click the accept button?
20:02:58 <cjb> huh, I sound like a GPL fanboy.  I'm not; I just think it's a good license.
20:03:05 <gwern> the GPL is nice and future-proof though. safe by default, y'know
20:03:15 <EvilTerran> i just think people should be encouraged to use the shortest possible license that they're happy with
20:03:19 <wagle> hmm...
20:03:22 <cjb> EvilTerran: I don't understand this confusion between "punters" and "users" and people who want to modify and redistribute source under different terms.
20:03:24 <gwern> cjb: ironically, I'm not a huge GPL fanboy either - i put all my stuff in the public domain
20:03:33 <cjb> a *user* of GPL'd software doesn't have to care what the legalese is.
20:03:46 * wagle finally puts GPLv3 (and GPLv2) on his reading list
20:03:55 <EvilTerran> they still get it waved in their faces when they're installing GPLd software
20:03:55 <cjb> someone who wants to modify GPL'd software and doesn't have very strong wishes causing them to want to *modify* the license of the source doesn't even have to care
20:04:07 <cjb> EvilTerran: by whom?
20:04:27 <EvilTerran> um... the installer?
20:04:28 <cjb> I install GPL'd software several times a week, and never read the GPL.
20:04:35 <gwern> I actually like the GPL in part because just a few bits of GPL software out there protect the entire ecosystem from exploitation, like posoinous snakes and their imitators, if you follow
20:04:37 <cjb> apt-get?  yum?
20:04:54 <EvilTerran> say, the GIMP's graphical installer
20:04:55 <cjb> gwern: yeah!  my wife's a biologist, and understood the point of the GPL immediately.
20:05:12 <gwern> exploiters have to be more careful not to swallow a poisonous Free (GPL'd) program, whereas if everything was BSD, they could gulp away with impunity
20:05:17 <cjb> gwern: it's seen in nature, shared/enforced altruism.
20:05:19 * gwern coughs*apple*cough
20:05:51 <gwern> cjb: right! I'm keen on evolution, so when I first read of the GPL, I was like ' wow, from a game theory perspective, thisis so awesome
20:06:01 <EvilTerran> i just loathe waffle, and i'll avoid it whereever i can
20:06:12 <EvilTerran> and i'm not neurotic about what people do with my creative works
20:06:22 <EvilTerran> so i put things out under BSD-alikes
20:06:58 <EvilTerran> and grumble when i begin to suspect people've been slapping the GPL (or any other million-clause license) on things because it's the Done Thing
20:07:07 <monochrom> yo
20:07:38 <blackdog> silly thing is that it doesn't stop software-as-a-service like google anyway.
20:07:41 <EvilTerran> you're welcome to use whatever license you like, but i feel that as few clauses as possible should be the norm
20:08:10 <EvilTerran> it's opinion, in the end
20:08:22 <EvilTerran> do what thou wilt, and do it with all thy might. it's not my problem. :)
20:08:23 <gwern> EvilTerran: if the GPL really is too cumbersome, you'll see BSD stuff slowly outcompete GPL, until BSD gets exploited too much and then people protectively shift to GPL (or only GPL communities/software are not defunct from poachng). I forget the evolutionary term for this cycling of strategies tho
20:09:06 <EvilTerran> i'm not gonna argue any more. i've made my points, and i'm not in the mood for game theory at this hour.
20:09:37 <EvilTerran> > iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
20:09:37 <EvilTerran>  -- in other news
20:09:41 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
20:11:18 <monochrom> haha that one
20:11:47 <wagle> darn, its not pascal's triangle
20:11:56 <ddarius> look-see
20:12:08 <ddarius> Er see-say or something like that
20:12:12 <monochrom> It proves that RLE can fail to compress.
20:13:14 <ddarius> monochrom: Any file with no runs does that
20:13:49 <cjb> by the way, the most concise GPL/BSD distinction I've heard is that the GPL aims to promote societal freedom, and the BSD aims to promote individual freedom.
20:13:59 <monochrom> Such as [1,2,1,1]? :)
20:14:00 <cjb> this explains why people say "no, the one I like is more free@$!!!" at each other a lot.
20:14:23 <cjb> if you're more interested in individual liberty than group liberty, that's a good sign you aren't gonna like the GPL :)
20:14:34 <Cale> Public Domain!
20:15:01 <wagle> haha..  i gotta send that to my java buddies..
20:15:02 * cjb is a group liberty kind of guy, generally.
20:15:14 <monochrom> Yeah, I am inclined to put my work in public domain.
20:15:57 <cjb> I've released some BSD (I don't think the public domain exists :p) code, too; they're both good licenses.
20:16:13 <monochrom> I don't earn money from my work even if I try to sell it anyway. Like, who wants to buy my hxt tutorials and continuation study notes?
20:16:37 <dobblego> I see what you did there
20:18:24 <wagle> aieee!  my find command fell into a maze of twisty .snapshot's, all alike!
20:20:01 <monochrom> refine your find command.
20:21:28 <allbery_b> 4@snuffy:5 B$ fs lsm /afs/andrew/.recursivefindtrap
20:21:29 <allbery_b> '/afs/andrew/.recursivefindtrap' is a mount point for volume '#root.cell'
20:22:03 <hpaste>  (anonymous) annotated "hmm, why otherwise and not _ ?" with "(no title)" at http://hpaste.org/5627#a1
20:22:24 * gwern is always in the mood for game theory
20:22:47 <wagle> i did..  it now terminates in a minute, instead of still searching 15 minutes later
20:24:58 <trie> Is there a predefined type corresponding to "u_int32_t"? (for FFI)
20:25:13 <monochrom> Word32
20:25:14 <ddarius> @hoogle CUInt32
20:25:14 <lambdabot> No matches found
20:25:40 <trie> thanks monochrom
20:25:52 <trie> and ddarius
20:26:12 <monochrom> Hrm, no CUInt32. Only CUInt, CULong, ...
20:26:48 <trie> Word32 seems like the right thing, no?
20:26:55 <LoganCapaldo> isn't u_int32_t optional?
20:27:14 <ddarius> trie: It should work.
20:27:35 * LoganCapaldo goes to bed
20:27:50 <monochrom> Actually, the FFI doesn't say that Word32 is accepted. The FFI only mentions CUInt, CULong,... things in Foreign.C.Types. But, perhaps things not mentioned still work.
20:27:53 <BMeph> @remember wagle wagle: in the end all entities die. dont bother living.  lambdabot: thread killed
20:27:54 <lambdabot> Done.
20:29:47 <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here.
20:30:22 <monochrom> Where can I find out more about Haskell Adventure?
20:30:23 <magnus_> BMeph: use lambda on self
20:30:41 <LoganCapaldo> use fix on self
20:30:52 * LoganCapaldo really goes to bed
20:31:23 <BMeph> You use fix on yourself. You are now fixed. Planned Parenthood and the female population of your nation thank you.
20:31:58 <monochrom> ...
20:32:06 <monstre> hello
20:32:20 <dobblego> can a binary function commute but fail associativity?
20:32:39 <shachaf> dobblego: Why not?
20:33:06 <wagle> @remember BMeph BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here.
20:33:06 <lambdabot> It is stored.
20:33:06 <wagle> <monochrom> Where can I find out more about Haskell Adventure?
20:33:18 <wagle> aww
20:33:25 <shachaf> @forget BMeph BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here.
20:33:26 <lambdabot> Done.
20:33:50 <monochrom> You need to use an editor.
20:33:51 <shachaf> @remember BMeph <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
20:33:51 <lambdabot> Nice!
20:33:54 <dobblego> of course, my brain is broke
20:34:20 <wagle> didnt know how to @forget
20:34:29 <wagle> thanks
20:34:31 <gwern> @quote BMeph
20:34:31 <lambdabot> BMeph says: <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
20:34:33 <gwern> @quote BMeph
20:34:33 <lambdabot> BMeph says: <BMeph> Welcome to Haskell Adventure! You are in a maze of twisty imperative statements, all alike. There is a lambda here. <monochrom> Where can I find out more about Haskell Adventure?
20:34:42 <gwern> BMeph: make more funnies -_-
20:34:51 <monstre> did GHC drop support for windows 98/ME some time between 6.6 and 6.8 or is it still supposed to work?
20:34:59 <monochrom> No, make more cookes.
20:35:00 <dmwit> ?quote gwern
20:35:01 <lambdabot> No quotes match. Just what do you think you're doing Dave?
20:35:03 <monochrom> cookies
20:35:10 <dmwit> gwern: Take your own advice. =)
20:35:16 <gwern> huh. I *used* to have quotes
20:35:17 <BMeph> gwern: Hold on, I'll check out the MSDN for inspiration. ;)
20:35:32 <gwern> @OlegFacts
20:35:32 <lambdabot> Unknown command, try @list
20:35:37 <gwern> @quote oleg
20:35:37 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
20:35:48 <ibid> ?quote ibid
20:35:48 <lambdabot> No quotes match. My pet ferret can type better than you!
20:35:48 <gwern> @quote oleg
20:35:48 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
20:35:49 <shachaf> @quote OlegFacts
20:35:49 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
20:36:04 <gwern> ok, glad to see the OlegFacts at least are still there
20:36:11 <ibid> blah :)
20:36:42 <shachaf> Something happened to lambdabot again?
20:36:46 <ddarius> @quote ddarius
20:36:46 <lambdabot> ddarius says: isJust . unsafeCoerce
20:36:50 <ddarius> Damn
20:37:00 <shachaf> Doesn't seem to have any other OlegFacts.
20:37:05 <gwern> shachaf: I think so. I know for certain I used to have some quotes in there
20:37:45 <jfredett_> @quote jfredett
20:37:45 <lambdabot> No quotes match.
20:37:47 <jfredett_> :(
20:38:50 <shachaf> @quote Gwern
20:38:50 <lambdabot> Gwern says: actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
20:39:33 <gwern> @quote gwern
20:39:34 <lambdabot> No quotes match. :(
20:39:37 <gwern> @quote Gwern
20:39:37 <lambdabot> Gwern says: actually, i define bottom to equal 1 in all my programs, so I can guarantee they will never crash
20:39:39 <wagle> you can do that in fortran
20:39:48 <gwern> huh. well, that explains it
20:39:55 <wagle> change the value of any constant
20:39:56 <monstre> newbie question: does 'zip [] _|_' evaluate to [] or _|_ ?
20:40:09 <sarehu> > zip [] undefined
20:40:22 <shachaf> @src zip
20:40:22 <sarehu> ?bot
20:40:23 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
20:40:23 <lambdabot> zip _      _      = []
20:40:23 <lambdabot> :)
20:40:24 <lambdabot>  thread killed
20:40:26 <yondalf> :t undefined
20:40:32 <dobblego> Prelude> zip [] undefined
20:40:33 <lambdabot> forall a. a
20:40:33 <dobblego> []
20:40:42 <monochrom> eh, too much scrolling
20:40:52 <wagle> call foo (_|_)   ..................... subroutine foo (x)  ... x = 1 ... return ... end
20:41:11 <shachaf> dobblego: > zip undefined [] -- undefined
20:41:11 <gwern> wagle: so constants - aren't?
20:41:16 * gwern couldn't resist
20:41:27 <yondalf> hmm...that's weird, according to the definition zip should return [], but apparently a thread was killed
20:41:42 <sarehu> that was just weird, maybe the computer barfed
20:41:46 <wagle> all constants have locations, apparently..  might have gone away in fortran 90, 99, or something, though
20:41:52 <monochrom> Ignore thread killing. Accidental server hiccups.
20:41:59 <yondalf> okay, let's try again
20:42:02 <yondalf> > zip [] undefined
20:42:03 <lambdabot>  []
20:42:06 <yondalf> ah...okay
20:42:13 <shachaf> @remember gwern <jfoutz> is clean typed? <gwern> I hear some people dictate down their clean programs through voice recognition programs
20:42:13 <lambdabot> It is stored.
20:42:16 <yondalf> the server hiccupped at a weird time :-P
20:42:17 <shachaf> gwern: Happy?
20:42:26 <shachaf> > zip [] undefined
20:42:27 <lambdabot>  []
20:42:31 <shachaf> > zip undefined []
20:42:32 <lambdabot>  Undefined
20:42:35 <gwern> shachaf: much more so :)
20:42:49 <shachaf> @remember Gwern Haskell is the one true language
20:42:50 <lambdabot> I will never forget.
20:42:50 <yondalf> so pattern matching is from left to right in this case
20:42:55 <gwern> but wait, now I'm in there under 'gwern' and 'Gwern'
20:42:58 <sarehu> is that actually right?  if zip is defined with  zip (x:xs) (y:ys), is it guaranteed to check (x:xs) first?
20:42:59 <shachaf> @remember Gwern all good languages are but corruptions or extensions of haskell
20:43:00 <lambdabot> Okay.
20:43:07 <shachaf> gwern: Feel free to fix it.
20:43:09 <gwern> shachaf: wait, when did I say those...
20:43:18 <shachaf> It should be case-insensitive like IRC nicks anyway.
20:43:31 <shachaf> gwern: Just grepping through the logs.
20:43:33 * wagle re-implements haskell in fortran--
20:43:48 <shachaf> @karma fortran
20:43:49 <lambdabot> fortran has a karma of -1
20:44:01 <ddarius> I think my microwave jacks with my wifi
20:44:02 <sarehu> fortran++
20:44:04 <yondalf> sarehu: i have no idea :-P but don't use undefined functions in my haskell work anyway
20:44:06 <monstre> so I can rely on 'zip [] _|_' being [] then or is that just happenstance?
20:44:26 <shachaf> @where report
20:44:27 <lambdabot> http://www.haskell.org/onlinereport/
20:44:29 <yondalf> do you all encounter _|_ often in haskell work?
20:44:50 <kfish> yondalf, its the only way to tame the infinite
20:45:08 <yondalf> kfish: :-)
20:45:12 <monochrom> microwave jacks with wifi. this is verified. try to keep them a few feet apart.
20:45:40 <jeffz> ah darn, so I shouldn't put my wifi in the microwave?
20:45:58 <shachaf> monstre: I think you can rely on it.
20:46:32 <ddarius> monochrom: There in different rooms
20:47:03 <monochrom> then that's worse than average
20:47:43 <monstre> just to make sure I understand: 'zip xs (tail xs)' should be safe even when xs is [], right?
20:47:58 <ddarius> Yes
20:48:02 <gwern> @where delimcc
20:48:02 <lambdabot> I know nothing about delimcc.
20:48:08 <yondalf> > let xs = [] in zip xs (tail xs)
20:48:08 <lambdabot>  []
20:48:12 <monstre> alright, thank you
20:48:19 <monochrom> @hackage delcont-CC
20:48:19 <yondalf> lambdabot is so convenient :-)
20:48:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/delcont-CC
20:48:20 <wagle> shachaf, /me rolls on floor and dies laughing
20:48:30 <gwern> yondalf: I don't think I've ever personally had a problem with bottom, actually, but I'm not big on the advanced stuff
20:48:38 <shachaf> wagle: ?
20:48:46 <monochrom> oops worry, let me find the correct name
20:48:47 <wagle> <shachaf> @karma fortran
20:48:59 <shachaf> wagle: I was just curious. :-)
20:49:02 <gwern> cc-delcont?
20:49:29 <monochrom> CC-delcont
20:49:31 <shachaf> http://www.haskell.org/haskellwiki/Library/CC-delcont ?
20:49:33 <lambdabot> Title: Library/CC-delcont - HaskellWiki
20:50:53 <sarehu> Ok, you can rely on zip [] _|_ = [] thanks to 3.17.3 (g)
20:51:29 <monstre> does this mean patterns are always matched left-to-right?
20:51:34 <sarehu> yes
20:52:12 <monstre> thanks
20:52:22 <dmwit> That's a fairly nasty thing to rely on, though.
20:52:35 <monochrom> Unless someone defines zip to begin with "zip _ [] = []" pervertedly, you should be fine.
20:52:50 <monstre> nasty how?
20:53:19 <shachaf> monochrom: That's not H98 zip, though.
20:53:38 <dmwit> monstre: Nasty in the sense that it depends heavily on the implementation of the function you're calling.
20:53:44 <monochrom> Unclear how much H98 dictates.
20:54:14 <monstre> I was just wondering if the following was okay: sorted xs = and (zipWith (<=) xs (tail xs))
20:54:23 <dmwit> monstre: Re-ordering the pattern matches (top-to-bottom) can change the order that bottom gets slurped up (left-to-right).
20:54:23 <monstre> or is that nasty?
20:54:23 <dmwit> monstre: I'd call that nasty. =P
20:54:23 <sarehu> unclear how?
20:54:25 <rapsensee> hey guys check out http://fudge.fit.edu, really cool web 2.0 online judge with alot of language support, its the first social programming network
20:54:27 <lambdabot> Title: Fudge Home
20:54:38 <EvilTerran> monstre, perhaps use (drop 1) instead of tail?
20:54:41 <rapsensee> heh
20:54:42 <EvilTerran> > drop 1 []
20:54:46 <lambdabot>  []
20:54:55 <EvilTerran> @where ops
20:54:55 <lambdabot> shapr cale glguy dons sjanssen
20:54:56 <rapsensee> they have haskell!
20:55:03 <EvilTerran> ...
20:55:03 <jeffz> rapsensee: irc is a social programming network
20:55:07 <rapsensee> hehe
20:55:13 <rapsensee> but can u solve problems? on irc?
20:55:19 <dmwit> Sure!
20:55:22 <rapsensee> nah
20:55:25 <rapsensee> its lame on irc
20:55:26 <dmwit> We do it all the time. =)
20:55:26 <jeffz> rapsensee: yes, irc predates your website by many years.
20:55:27 <rapsensee> jus chatting
20:55:28 <rapsensee> :D
20:55:32 <rapsensee> tru tru
20:55:35 <monochrom> ban
20:55:40 <rapsensee> ?
20:55:42 <rapsensee> lol
20:55:46 <jeffz> ban.
20:55:50 <rapsensee> ban?
20:56:07 <rapsensee> we cud discuss fudge problems on irc
20:56:12 <rapsensee> in haskell
20:56:39 <dobblego> > 1 + 1 -- we can solve 1 + 1
20:56:42 <lambdabot>  2
20:56:46 <rapsensee> its my sr project for school
20:56:58 <shachaf> @where+ ops shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
20:56:58 <monochrom> People, please don't feed the troll.
20:56:59 <lambdabot> Nice!
20:57:16 <EvilTerran> maybe @flush that?
20:57:42 <lispy> shachaf: I don't even know how to use my ops.  Hence, I don't need them :)
20:57:54 <rapsensee> if u like problem solving its a cool experience
20:58:08 <jeffz> rapsensee: how do you feel about spelling words in full?
20:58:39 <EvilTerran> I'm quite partial to capitalisation and punctuation, myself.
20:58:43 <rapsensee> sorry guys i'll obey
20:58:45 <yondalf> @pl do { k <- keyParser; m <- many (noneOf "/]\n"); return $ Just (k, m) }
20:58:45 <lambdabot> (line 1, column 4):
20:58:46 <lambdabot> unexpected "{"
20:58:46 <lambdabot> expecting variable, "(", operator or end of input
20:59:02 <EvilTerran> @. pl undo do { k <- keyParser; m <- many (noneOf "/]\n"); return $ Just (k, m) }
20:59:05 <lambdabot> (`fmap` many (noneOf "/]\n")) . (Just .) . (,) =<< keyParser
20:59:07 <rapsensee> eheh
20:59:25 <dmwit> eugh
20:59:32 <monstre> now that I think about it, why is 'tail []' _|_ rather than [] ?
20:59:38 <rapsensee> i'd like to see a solution to smeech in haskell
20:59:38 * dmwit prefers the do-notation version
20:59:41 <monstre> wouldn't the latter be more useful?
20:59:42 <EvilTerran> monstre, for consistency
20:59:52 <EvilTerran> if you want the latter, you can use (drop 1)
20:59:52 <monstre> consistency with head?
20:59:55 <EvilTerran> yeah
21:00:13 <yondalf> dmwit: i prefer do-notation rather than \bot's pointfree but i wonder if there's a way to simplify the expression
21:00:32 <monstre> yeah, I'll file away 'drop 1' for future use
21:00:59 <dmwit> liftM2 ((Just .) . (,)) keyParser (many (noneOf "/l\n")) -- ?
21:01:15 <EvilTerran> head and tail are for de-constructing a (:); it'd be weird if one of them worked on the other list constructor ([]) as well
21:01:17 <yondalf> dmwit: hmm...yes i should do something like that
21:01:41 <yondalf> @undo (Just . ) . (,)
21:01:41 <lambdabot> (Just .) . (,)
21:01:53 <rapsensee> is anyone willing to help test fudge out?
21:01:56 <yondalf> @undo Just . (,)
21:01:56 <lambdabot> Just . (,)
21:02:03 <dmwit> rapsensee: Your UI sucks.
21:02:04 <yondalf> :t Just . (,)
21:02:07 <coffeemug> hello
21:02:07 <lambdabot> forall a b. a -> Maybe (b -> (a, b))
21:02:09 <dmwit> (just saying)
21:02:13 <yondalf> :t (Just . ) . (,)
21:02:13 <lambdabot> forall a a1. a1 -> a -> Maybe (a1, a)
21:02:33 <rapsensee> thanks alot
21:02:35 <rapsensee> i need feedback
21:02:46 <rapsensee> so any comments/suggestions/bashing is fine
21:02:52 <dmwit> rapsensee: You should consider putting the list of problems right in the first "problems" link.
21:02:55 <yondalf> rapsensee: maybe you should provide screenshots or a place where we can experiment without registering
21:02:56 <rapsensee> it wont "hurt" my feelings
21:03:09 <rapsensee> u can look at problems w/o registering
21:03:10 <wagle> @src group
21:03:10 <lambdabot> group = groupBy (==)
21:03:12 <dmwit> rapsensee: Let the user move over to the other, more advanced things only if they find a need to.
21:03:25 <rapsensee> what do you mean?
21:03:40 <wagle> @src groupBy
21:03:40 <lambdabot> groupBy _  []       =  []
21:03:40 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:03:40 <lambdabot>     where (ys,zs) = span (eq x) xs
21:03:53 <wagle> @index group
21:03:53 <lambdabot> Data.List
21:04:01 <monochrom> @pl \x y -> Just (x,y)
21:04:01 <lambdabot> (Just .) . (,)
21:04:02 <dmwit> rapsensee: After I click "Problems", I have to click again (on "View the problem archive") to see problems.  I shouldn't have to.
21:04:18 <monochrom> @type curry
21:04:21 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:04:23 <rapsensee> dmwit : Its suppose to be a submenu
21:04:28 <monochrom> So it's uncurry.
21:04:29 <dmwit> rapsensee: There's a few other places where this pattern applies.  Just go straight to the most common page instead of having another level of indirection.
21:04:30 <rapsensee> dmwit : but fair enough
21:04:42 <rapsensee> dmwit : then there'd have to be a drop down
21:04:59 <dmwit> rapsensee: The menu is fine; keep it.  But also have the most common thing there for convenience.
21:05:01 <rapsensee> dmwit : the whole idea was to have the big icon be the link to a submenu
21:05:02 <monochrom> @type liftM2 (uncurry Just)
21:05:03 <lambdabot>     Couldn't match expected type `b -> c'
21:05:03 <lambdabot>            against inferred type `Maybe a'
21:05:03 <lambdabot>     Probable cause: `Just' is applied to too many arguments
21:05:07 <rapsensee> dmwit : sure
21:05:44 <monochrom> Perhaps it's curry afterall.
21:05:51 <monochrom> @type liftM2 (curry Just)
21:05:52 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (Maybe (a1, a2))
21:05:56 <monochrom> YES!
21:06:05 <wagle> bah..  i wanted to show my anti-haskell java friends iterate (concatMap ((:) <$> length <*> return.head) . group) [1]     but it wo't run on anything other than lambdabot
21:06:15 <dmwit> monochrom: Very nice!
21:06:20 <wagle> (not as a one-liner any way)
21:06:29 <dmwit> wagle: Why not?
21:06:44 <wagle> Prelude> iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
21:06:44 <wagle> <interactive>:1:20:
21:06:44 <wagle>     precedence parsing error
21:06:44 <wagle>         cannot mix `(<*>)' [infixl 9] and `(.)' [infixr 9] in the same infix expression
21:06:44 <wagle> <interactive>:1:24: Not in scope: `<$>'
21:06:44 <wagle> <interactive>:1:35: Not in scope: `<*>'
21:06:46 <wagle> <interactive>:1:54: Not in scope: `group'
21:06:47 <monochrom> EvilTerran: liftM2 (curry Just) keyParser (many (noneOf "/]\n"))
21:06:59 <dmwit> wagle: :m + Data.Applicative
21:07:03 <coffeemug> is there a way to define a function like this in Haskell: f x = f
21:07:07 <gwern> wagle: unfortunately, lambdabot imports many modules by default
21:07:13 <coffeemug> this won't type check
21:07:13 <gwern> coffeemug: f _ = f?
21:07:23 <gwern> interesting want
21:07:40 <dmwit> coffeemug: You need to make your own data type (or newtype).
21:07:54 <coffeemug> dmwit: defining the function?
21:07:58 <gwern> f :: a -> (a -> (a ->..., hm, I can't seem to figure out it's type
21:07:58 <dmwit> coffeemug: But, why do you want such a thing?
21:07:58 <wagle> Could not find module `Data.Applicative':
21:08:08 <wagle> oh well, gotta run
21:08:13 <dmwit> ?index (<*>)
21:08:13 <lambdabot> bzzt
21:08:15 <shachaf> This f is called "v" in Unlambda, right?
21:08:34 <shachaf> wagle: Control.Applicative.
21:08:41 <dmwit> ?tell wagle Sorry, it's Control.Applicative.
21:08:41 <lambdabot> Consider it noted.
21:08:42 <coffeemug> dmwit: no practical reason, I have a class for which I define expressions in lambda calculus as a homework, so just for fun I'm trying to translate them to haskell
21:09:13 <dmwit> coffeemug: Ah!  Yes.  You will need some kind of newtype, like:
21:09:24 <dmwit> newtype Inf a = a -> Inf a -- or so
21:09:51 <dmwit> f :: Inf a
21:10:08 <dmwit> f = const f
21:10:21 <dmwit> Err... modulo syntax.
21:11:02 <coffeemug> hmm
21:11:05 <coffeemug> not a constructor a
21:11:52 <dmwit> newtype Inf a = Inf (a -> Inf a)
21:12:23 <dmwit> f = Inf (const f)
21:12:52 <dmwit> Is that better?
21:13:01 <coffeemug> hmm, yes, thank you
21:13:04 <ddarius> newtype Mu f = Mu (f (Mu f)); f :: Mu ((->) a); f = Mu (const f)
21:13:10 <dmwit> Using such a thing in a meaningful way is not so easy, though. =P
21:13:18 <coffeemug> heh
21:13:19 <coffeemug> yeah
21:13:39 <ddarius> Types not far from it are handy and/or more interesting
21:13:47 <dmwit> definitely
21:21:44 <yondalf> :t curry
21:21:47 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
21:23:38 <yondalf> :t liftM2
21:23:39 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:23:55 <lispy> ?src liftM2
21:23:56 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:24:09 <lispy> ah, I was hoping that was interms of ap
21:24:12 <lispy> ?src liftM3
21:24:12 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
21:24:19 <lispy> oh maybe none of these are
21:24:55 <dobblego> liftM3 f a b c = liftM2 f a b `ap` c
21:26:55 <dmwit> liftM3 f a b c = return f `ap` a `ap` b `ap` c
21:36:28 <dbpatterson> I just installed ghc 6.8.2 from source (my platform, openbsd, doesnt have anything past 6.6 built) and I am missing Control.Monad.Reader - is this the default behavior, and if so, how should I go about getting it?
21:37:00 <dbpatterson> it's in the source, just not built or installed...
21:37:19 <ddarius> Get package mtl
21:37:23 <allbery_b> look for an mtl package
21:37:34 <dbpatterson> well, the problem is there arent packages
21:37:44 <ddarius> @hackage mtl
21:37:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
21:37:45 <dbpatterson> how do I build mtl from the source?
21:37:53 <rapsensee> fudge?
21:37:55 <rapsensee> no one hungry?
21:38:03 --- mode: ChanServ set +o allbery_b
21:38:43 <rapsensee> http://fudge.fit.edu/Help/Faq.aspx
21:38:46 <lambdabot> Title: Fudge - FAQ
21:40:21 <dmwit> rapsensee: Thanks for the pointer.  We are aware of Fudge now.  Now, for your own sake, please drop the subject until you have something new to say.
21:40:52 <rapsensee> nice :)
21:41:01 <rapsensee> awareness is good
21:41:10 <rapsensee> i'll be back with some updates when i can
21:41:26 <dbpatterson> @ddarius and allbery_b - thanks
21:41:26 <lambdabot> Unknown command, try @list
21:41:35 <dbpatterson> oops, sorry lambdabot
21:42:24 <Twey> How do I combine a type synonym and a type?  Say, I might want to define `type Dictionary a b = [(a, b)]` and then define some methods that work only on Dictionaries as in `data Dictionary a b where lookup = ...`
21:42:35 <Twey> I have this feeling I'm barking up the wrong tree.
21:42:48 <allbery_b> as for building from source:  "darcs-get --extras" will get you a bunch of unbundled stuff and hook it into the build
21:43:23 <dbpatterson> allbery_b: well, I did that, which is why I (incorrectly) thought it would have been built...
21:43:35 <dmwit> Twey: newtype?  Or am I misunderstanding...
21:43:39 <dbpatterson> or at least, I unpacked the extralibs tarball into the directory
21:43:42 <EvilTerran> Twey, er, "data Dictionary a b where lookup = ..." doesn't mean anything in Haskell
21:43:46 <yondalf> Twey: i think you're barking up the wrong tree :-)
21:44:01 <ddarius> EvilTerran: Actually, Hugs should support that or something like it.
21:44:17 <yondalf> Twey: if you define a type synonym, every Dictionary is a [(,)] and vice versa
21:44:20 <EvilTerran> ddarius, do you mean GADTs? that'd need a capital letter on Lookup
21:44:20 <dmwit> Twey: Or you may want classes depending on what you're asking. =P
21:44:30 <ddarius> EvilTerran: No, restricted type synonyms
21:44:43 <EvilTerran> hm... do you have a link?
21:44:59 <Twey> Hmmm
21:45:01 <allbery_b> hm, wonder if you unpacked into the correct place then.  it should give you things like libraries/mtl, libraries/array, etc.
21:45:04 <yondalf> Twey: you might want a newtype Dictionary a b = Dictionary [(a, b)], but this means that you'll have to call the Dictionary constructor whenever you want a Dictionary
21:45:40 <Twey> Mmkay, thanks
21:45:41 <ddarius> http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html
21:45:43 <lambdabot> http://tinyurl.com/yvr54e
21:45:45 <Twey> Yes, I think I kind of get it :-P
21:45:47 <EvilTerran> ta
21:45:56 <yondalf> Twey: or define the type synonym and define your functions to define on Dictionary (or [(a,b)]) then your functions will work on all [(a,b)] regardless of whether you meant for it to be a Dictionary
21:46:15 * Twey nods.
21:46:16 <Twey> Thanks
21:46:42 <sarehu> Main: Particle.hs:(59,22)-(62,28): Non-exhaustive patterns in record update
21:46:47 <sarehu> ^^ any ideas what would cause this?
21:46:54 <allbery_b> maybe what you really want is to put them into e.g. Dictionary.hs and then import qualified Dictionary as D?
21:46:57 <dbpatterson> allbery_b: actually, looking more closely, it said to unpack it on top of the folder - I unpacked it within the folder - showing where the obvious problem lies...
21:47:00 <ddarius> sarehu: Ask Catch or compile with warnings
21:47:01 <EvilTerran> ddarius, how curious. i guess i can see the use to it.
21:47:39 <lispy> > let f (Just x) = x in f Nothing
21:47:43 <lambdabot>   Non-exhaustive patterns in function f
21:47:44 <allbery_b> then you have e.g. D.lookup which doesn't conflict with the List or Map implementations of lookup
21:47:47 <lispy> sarehu: ^^
21:47:59 <sarehu> lispy: no, it's not that.. it's in 'record update'...
21:48:13 <sarehu> I'm going to put some top-level type signatures and see if the message changes somehow...
21:48:42 <sarehu> no, that's dumb, that won't change anything; it knows the types..
21:48:44 <lispy> sarehu: well the problem should be the same in theory.  You just don't define a pattern that includes the way your function is being called.
21:49:19 --- mode: allbery_b set -o allbery_b
21:50:21 <sarehu> ookay, never mind.
21:51:39 <sarehu> Er, un-never mind.
21:52:01 <lispy> sarehu: maybe it's easiest if you share your code with us?
21:52:04 <lispy> ?where paste
21:52:04 <lambdabot> http://hpaste.org/new
21:52:12 <sarehu> I am, one sec
21:52:49 <ddarius> data Record = { a :: Int, b :: Char }; aRecord = Record { a = 3 }; f (Record { b = x }) = x
21:53:46 <sarehu> Wait, never mind.
21:54:31 <sarehu> I had    data Record = {a :: Foo, b :: Bar} | Quux  , and was trying to update a Quux
21:57:35 <avida> what does ($) do?  The GHC.Base documentation doesn't explain
21:57:51 <dmwit> It's function application.
21:57:54 <nornagon> it's just a helper operator
21:57:55 <dmwit> f $ x = f x
21:58:08 <dmwit> (I think that's the *actual* definition.)
21:58:13 <nornagon> f (a b) is the same as f $ a b
21:58:24 <nornagon> useful for omitting brackets :)
21:58:24 <allbery_b> f $ x = (f) (x), it's really low precedence so it acts like virtual parentheses
21:58:30 <nornagon> parentheses, even.
21:58:37 <EvilTerran> @src ($)
21:58:37 <avida> ah, that explains much.  thank you.
21:58:43 <lispy> anyone know what eventually happened with the extended type checking for haskell?
21:58:53 <wagle_home> is $ the de-li$per?
21:58:59 <cjb> wagle_home: yup
21:59:33 <lispy> wagle_home: and as a lisper, ($) took me a long time to become comfortable with
21:59:37 <allbery_b> more or less, although it does substitute a variant of leaning toothpick syndrome if overused
21:59:51 <lispy> leaning toothpick?
21:59:59 <EvilTerran> something perl suffers from
22:00:17 <allbery_b> refers to how you have to escape things in regular expressions
22:00:20 <lispy> I think (.) and ($) can go well together
22:00:22 <EvilTerran> /http\:\/\/www\./ kinda thing
22:00:30 <allbery_b> yep
22:00:34 <lispy> > take 10 . map length . group . fix $ show -- like this example
22:00:35 <cjb> foo . bar $ arg1 arg2
22:00:40 <EvilTerran> worse in say, java, where your regexes have to be string literals
22:00:54 <EvilTerran> "http\\:\\/\\/www\\."
22:01:04 <allbery_b> (not just perl though, anything that uses regular expressions.  and yes, much worse in java or python etc.)
22:01:54 <EvilTerran> it gets really bad when your regular expression is part of a lexer for a language that includes backslash-escapes
22:02:28 <allbery_b> show on a string tends to develop a bad case of leaning toothpick syndrome too
22:02:32 <EvilTerran> > fix show
22:02:33 <allbery_b> > fix show
22:02:45 <lispy> she's down again :(
22:02:49 <allbery_b> we just fried LB's brain
22:03:08 <EvilTerran> she stopped responding around me asking for @src ($) a minute ago =/
22:03:15 <sarehu> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\...
22:03:19 <lispy> I wonder why that happens to her :(
22:03:53 <wagle_home> must be int overflow..  thats my favorite bug
22:04:08 <allbery_b> mine still has that url-title host lookup lockup, despite my trying to hack up the network library :/
22:04:38 <sarehu> lambdabot socializes with bots in other channels. they work like paintings in harry potter
22:04:43 <dmwit> What's the Parsec equivalent of dropWhile?
22:04:53 <sarehu> skipMany?
22:05:24 <dmwit> Close enough, thanks.
22:07:39 <lispy> writing a simple parsec from scratch should would be a good learning exercise
22:07:48 <lispy> probably isn't that hard, either
22:08:56 <sarehu> hey, my FPS went from 5 to 150 with -O2 :-)
22:09:33 <lispy> sarehu: what are you working on?
22:10:16 <sarehu> a little particle simulating thingy like one that got linked to on this channel about a week ago
22:10:28 <yondalf> sarehu: url please? :-)
22:10:45 <lispy> sarehu: cool
22:10:56 <dons> sarehu: inner loops eh?
22:10:57 <sarehu> yondalf: not done yet, sorry, just started really
22:11:36 <lispy> sarehu: I don't recognize your nick, are you a haskell beginner?
22:11:49 <sarehu> lispy: not really
22:13:31 <sarehu> dons: usually for me w/ Haskell it's the outer loops that need optimizing (thanks to thrashing)
22:13:37 <sarehu> but yes
22:14:17 <Twey> @src lookup
22:14:29 <sarehu> bot's dead
22:14:31 <Twey> No lambdabot again :-(
22:16:26 <jeffz> hmm, looks like ghc suffers from heap corruption
22:17:05 <dons> on ingw32 ?
22:17:12 <jeffz> yeah, I just opened a bug for it
22:17:31 <dons> on a weird arch like there there could be gcc miscompilation issues, i suppose, or something flakey in the ffi bindings
22:17:48 <dons> good to have it reported
22:17:54 <jeffz> dons, I have valgrind and purify logs as part of the report
22:17:57 <jeffz> :)
22:18:02 <dons> awesome
22:37:05 <dmwit> ?index printf
22:37:23 <dmwit> ?botsmack
22:37:28 <dmwit> ok
22:40:53 <dmwit> Huh.
22:41:06 <dmwit> *Main> printf "%0.2f" 3.0
22:41:09 <dmwit> 3.0
22:41:14 <dmwit> Why isn't it 3.00?
22:43:47 <dmwit> oh
22:43:49 <Deewiant> probably because of the 0, try %.2f
22:43:51 * dmwit feels dumb
22:44:05 <dmwit> Deewiant: No, it was something even more dumb than that.
22:44:07 <Deewiant> although in C, %0.2f does print 3.00 at least here
22:52:08 <dons> ?users
22:52:18 <Deewiant> ENOBOT
22:52:40 <dons> seems like 6.8.2 bot is a bit unstable
22:53:29 <Twey> Haha, Deewiant
22:53:35 <shachaf> dons: As opposed to the 6.6.2 bot? :-)
22:53:58 <Twey> What killed it?
22:53:58 <Deewiant> Twey: got it from someone else here, forgot who though
22:54:08 <Twey> Ah
22:54:12 <Deewiant> appears to have just fallen
22:54:12 <Twey> @src ($)
22:54:12 <lambdabot> f $ x = f x
22:54:13 <Deewiant> 2008-02-13  08:08:49 -!- lambdabot [i=cgibbard@72.249.126.23] has quit [Read error: 110 (Connection timed out)]
22:54:21 <Twey> Worked then :-\
22:55:30 <Twey> Hmm
22:55:50 <Twey> lispy said ?where paste, which worked; then EvilTerran said @src ($), which didn't
22:56:14 <dons> ?version
22:56:14 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
22:56:14 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:56:17 <sclv> dons: just sent a patch to the pl plugin to fix a few irritating things. looks like darcs packaged it to you still, even though I guess cale took over.
22:56:32 <dancor> @hoogle [Maybe a] -> Maybe a
22:56:33 <lambdabot> No matches, try a more general search
22:56:37 <dons> yeah. and there's a lambdabot project now on code.haskell.org
22:56:41 <dons> you could just ask for maintainership
22:56:49 <dons> and then you could commit patches directly
22:57:23 <sclv> if I keep poking at it, I think I will. just wanted to give you a heads up.
22:57:47 <sclv> this was simple parser stuff. actually adding more rules seems like a whole nother issue.
22:58:24 <dancor> how do i go from [Maybe a] to first Just or Nothing if all Nothings
22:58:42 <dancor> i know it's something crazy with treating maybe as monad
22:59:13 <Deewiant> @ty listToMaybe
22:59:21 <lambdabot> forall a. [a] -> Maybe a
22:59:49 <sclv> ?pl \x -> M.get <$> x . y
22:59:49 <lambdabot> (line 1, column 13):
22:59:49 <lambdabot> unexpected "$" or "<"
22:59:49 <lambdabot> expecting variable, "(", ".", space, operator or end of input
22:59:49 <lambdabot> ambiguous use of a left associative operator
22:59:59 <sclv> with the patches, pl should be able to handle that right, for example.
23:00:32 <dancor> oh ok i can use listToMaybe . filter isJust
23:00:41 <dons> yeah, ideally we'd have a rules set you could add to dynamically
23:00:46 <dmwit> dancor: msum?
23:01:15 <Deewiant> > msum [Nothing, Nothing, Just 1, Just 2]
23:01:16 <lambdabot>  Just 1
23:01:23 <dancor> aha
23:02:44 <dancor> > listToMaybe $ filter isJust [Nothing, Nothing, Just 1, Just 2]
23:02:45 <lambdabot>  Just (Just 1)
23:02:47 <dancor> heh
23:02:49 <sclv> I'd like to teach it `on` I guess, and maybe some arrow combinators though I fear they'd be over-complicated.
23:03:23 <sclv> And maybe <$> and <*> though that would probably start complaints, as would `dot`
23:03:26 <dancor> pl should rate the inappropriateness of the pl-ing
23:03:36 <Deewiant> > join . listToMaybe $ filter isJust [Nothing, Nothing, Just 1, Just 2]
23:03:37 <lambdabot>  Just 1
23:41:13 <Twey> @pl \x y -> y x
23:41:13 <lambdabot> flip id
23:41:46 <Twey> :t flip
23:41:52 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
23:41:59 <Twey> :t id
23:42:00 <lambdabot> forall a. a -> a
23:42:10 <Twey> . . . eh?
23:42:23 <funktio> that's quite interesting
23:42:42 <Twey> (a -> a) doesn't match (a -> b -> c)
23:42:57 <Twey> How can flip id work?
23:43:01 <dolio> a = b -> c
23:43:07 <Twey> Ah
23:43:34 <dolio> @type ($)
23:43:36 <lambdabot> forall a b. (a -> b) -> a -> b
23:43:48 <dolio> Note, ($) is just id restricted to functions.
23:43:48 <Twey> Yes, I was thinking flip ($)
23:43:54 <Twey> Ah
23:43:59 <Twey> Hm, OK, thanks.
23:44:08 <dolio> > succ `id` 5
23:44:10 <lambdabot>  6
23:45:25 <Twey> Because that's (id succ) 5
23:45:27 <Twey> Right?
23:45:42 <dolio> Yeah.
23:45:53 <dolio> It's just like "succ $ 5".
23:45:59 <Twey> Yeah
23:46:04 <dolio> Which is (($) succ) 5, which is succ 5. :)
23:46:10 <Twey> Yeah :-)
23:46:17 <Twey> Thanks
23:53:29 <olsner> heh, the #haskell logs make up for like 100% of the google page rank for my blog since posting a link to it
23:54:07 <gour> @seen ndm
23:54:08 <lambdabot> I haven't seen ndm.
23:56:00 <Twey> Who is ndm?!
23:56:15 <Twey> I've never seen anyone in here called ndm
23:56:23 <Twey> But people keep askind the bot for him/her
23:56:27 <Twey> asking**
23:56:39 <dibblego> Neil Mitchell
23:56:54 <jeffz> ndm was last seen 3 weeks (16h 47m 0s) ago
