00:00:38 <quicksilver> xpika, Cale: I recommend zipTF
00:00:49 <wy> quicksilver: There is nothing wrong with it, but the thing I hate is to encapsulate methods in classes.
00:00:52 <Cale> quicksilver: zipTF?
00:01:08 <quicksilver> zipTF tree [1..] :: Tree (a,Int)
00:01:21 <quicksilver> @go FoldableAndTraversable
00:01:28 <lambdabot> No Result Found.
00:01:31 <quicksilver> bah
00:01:32 <oerjan> :t flip runState 0 . Data.Traversable.mapM $ \a -> do modify (+1); fmap ((,) a) get
00:01:33 <xpika> quicksilver: is that a Haskell Hierarchical Library?
00:01:35 <lambdabot>     Couldn't match expected type `State s a'
00:01:35 <lambdabot>            against inferred type `t a1 -> m (t b)'
00:01:35 <lambdabot>     Probable cause: `Data.Traversable.mapM' is applied to too few arguments
00:01:38 <oerjan> argh
00:02:01 <quicksilver> @go zipWithTF
00:02:03 <lambdabot> No Result Found.
00:02:09 <quicksilver> !
00:02:16 <quicksilver> http://www.haskell.org/haskellwiki/FoldableAndTraversable
00:02:19 <quicksilver> there, anyhow.
00:02:23 <lambdabot> Title: FoldableAndTraversable - HaskellWiki
00:02:40 <oerjan> :t flip runState 0 . Data.Traversable.mapM (\a -> do modify (+1); fmap ((,) a) get)
00:02:41 <lambdabot> forall s a (t :: * -> *). (Num s, Data.Traversable.Traversable t) => t a -> (t (a, s), s)
00:02:48 <oerjan> xpika: ^^
00:02:53 <quicksilver> it uses Suplly not State Integer, although it's the same really.
00:02:54 <quicksilver> but zipWithTF is a useful generalisation.
00:03:40 <Cale> !paste
00:03:41 <hpaste> Haskell paste bin: http://hpaste.org/
00:04:13 <xpika>  >  Node 1 [Node 2 [Node 5 []],Node 4[]]
00:04:16 <hpaste>  Cale pasted "A straightforward application of the State monad." at http://hpaste.org/5790
00:04:42 <xpika>  > Node 1 [Node 2 [Node 5 []],Node 4[]]
00:04:58 <xpika> lambdabot: wake up
00:05:16 <Cale> xpika: You're inserting an extra space before >
00:05:24 <Cale> > Node 1 [Node 2 [Node 5 []],Node 4[]]
00:05:26 <lambdabot>  Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = [Node {ro...
00:05:49 <xpika> all I need is to number it
00:06:00 <Cale> Did you see my paste?
00:06:14 <xpika> ** checks now*
00:06:26 <yondalf_> just curious...suppose i'm in the IO monad and i want to maintain my custom state, should I StateT over IO or just use an IORef?
00:06:28 <oerjan> xpika: did you see my :t ?
00:07:27 <oerjan> > flip evalState 0 . Data.Traversable.mapM (\a -> do modify (+1); fmap ((,) a) get) $ Node 1 [Node 2 [Node 5 []],Node 4[]]
00:07:29 <lambdabot>  Node {rootLabel = (1,1), subForest = [Node {rootLabel = (2,2), subForest = [...
00:08:03 <Cale> yondalf_: An IORef works well. You could also use ReaderT to distribute it automatically if that's inconvenient. For small applications, parameter passing works.
00:08:41 <Cale> I really hate that Tree type, by the way.
00:08:52 <oerjan> @index Node
00:08:52 <lambdabot> Data.Graph.Inductive.Graph, Data.Graph.Inductive, Data.Graph.Inductive.Internal.FiniteMap, Data.Graph.Inductive.Internal.Heap, Data.Tree, Data.Graph, Test.HUnit.Base, Test.HUnit
00:09:43 <quicksilver> cale: I prefer supplying a list of labels to explicitly doing the (+1) in a state monad, though.
00:10:10 <Cale> Sure, you could use a Supply monad instead.
00:10:19 <xpika> cale: nice.
00:11:51 <oerjan> > (evalState . Data.Traversable.mapM (State (\a (x:xs) -> ((a,x), xs))) (Node 1 [Node 2 [Node 5 []],Node 4[]]) "Supply ho"
00:11:51 <Cale> xpika: Of course, you could also convert that into explicit parameter passing.
00:11:52 <lambdabot> Unbalanced parentheses
00:12:46 <oerjan> > (evalState . Data.Traversable.mapM (State (\a (x:xs) -> ((a,x), xs)))) (Node 1 [Node 2 [Node 5 []],Node 4[]]) "Supply ho"
00:12:49 <lambdabot>      The lambda expression `\ a (x : xs) -> ...' has two arguments,
00:12:49 <lambdabot>     but i...
00:13:01 <Cale> xpika: (but it's a bit of a pain due to the mapM)
00:13:15 <oerjan> > (evalState . Data.Traversable.mapM (\a -> State (\(x:xs) -> ((a,x), xs)))) (Node 1 [Node 2 [Node 5 []],Node 4[]]) "Supply ho"
00:13:17 <lambdabot>  Node {rootLabel = (1,'S'), subForest = [Node {rootLabel = (2,'u'), subForest...
00:14:20 <Cale> That's got to be the worst Show instance ever.
00:14:32 <diptansu> Hi
00:14:38 <Cale> diptansu: hello
00:14:48 <oerjan> it's just the derived one, probably...
00:14:49 <diptansu> I am new to haskell but find it very interesting...
00:14:59 <Cale> oerjan: it is.
00:15:12 <Cale> diptansu: Cool, let us know if you have any questions
00:15:17 <diptansu> recently i tried to install the missingH package but am having problems building it...
00:15:25 <Cale> Okay
00:16:00 <diptansu> with 6.8.2 it is giving my a "dependency not found: hslogger"
00:16:22 <Cale> ghc-pkg list hslogger
00:16:23 <diptansu> do i need to install hslogger separately?
00:16:26 <Cale> yes
00:16:49 <Cale> You could get cabal-install, which automatically tracks down dependencies for you.
00:16:49 <diptansu> secondly, can i run the build from my cygwin prompt?
00:17:02 <Cale> Hmm, I don't know anything about windows :)
00:17:12 <Cale> But I suspect that you could.
00:17:39 <diptansu> yeah, how do i install cabal-install? unfortunately I have to work on a windows machine...
00:18:02 <diptansu> the cabal documentation seems to assume that the build will be on a *nix machine
00:18:56 <diptansu> "ghc-pkg list hslogger" does not show anything...
00:19:11 <diptansu> c:/ghc/ghc-6.8.2\package.conf:
00:19:15 <diptansu> thats the only output...
00:21:12 <goalieca> @src map
00:21:12 <lambdabot> map _ []     = []
00:21:12 <lambdabot> map f (x:xs) = f x : map f xs
00:21:31 <goalieca> that feature is handy for explaining to people :D
00:21:44 <Cale> diptansu: That means it's not installed
00:21:50 <RayNbow> @src [] fmap
00:21:50 <lambdabot> fmap = map
00:21:58 <Cale> diptansu: You can get it from Hackage though.
00:22:21 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hslogger-1.0.4
00:22:27 <lambdabot> http://tinyurl.com/3a8fov
00:22:28 <RayNbow> heh... http://reddit.com/r/programming/info/69gyt/comments "Why I Love F#: Pattern Matching (diditwith.net)"
00:22:56 <goalieca> @src foldl
00:22:57 <lambdabot> foldl f z xs = lgo z xs
00:22:57 <lambdabot>     where lgo z []     =  z
00:22:57 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
00:23:07 * RayNbow is not really impressed by F#'s syntax :p
00:23:41 <diptansu> thanks cale
00:24:43 <dolio> RayNbow: That doesn't really show off the cool stuff I've heard about F# pattern matching.
00:24:49 <dolio> Just regular pattern matching.
00:25:09 <quicksilver> RayNbow: reading stuff like that is like listening to a cave man excited about his new wheel as you cruise around in your air conditioned mercedes.
00:26:39 <Cale> It barely shows the difference between pattern matching and C's switch.
00:26:52 <dolio> Heh, yeah.
00:27:44 <quicksilver> let's leapfrog them and get quasiquoting going
00:27:53 <quicksilver> that will knock their pattern matching for six :)
00:28:10 <yondalf_> do we have quasiquoting in haskell? (assuming you mean the lisp `)
00:28:13 <osfameron> it does say it's the first introductory part of a series
00:28:28 <quicksilver> yondalf_: no, but work has been done to add it to GHC
00:28:39 <DRMacIver> Hm. Is there an equivalent to comparing for Eq in the standard library? (I know it's trivial to write)
00:28:44 <quicksilver> of course it won't be quite like lisp, since haskell isn't homoiconic in the same way
00:29:07 <dolio> DRMacIver: (==) `on` f
00:29:09 <oerjan> @hoogle equating
00:29:12 <lambdabot> No matches found
00:29:15 <oerjan> bah
00:29:15 <DRMacIver> dolio: THanks. That'll do. :)
00:29:54 <quicksilver> yondalf_: there is a paper on it somewhere
00:30:27 <oerjan> nothing in Data.Eq
00:30:45 <quicksilver> yondalf_: http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/
00:30:51 <lambdabot> Title: Quasiquoting Support for GHC
00:30:52 <oerjan> was the idea dropped?
00:31:11 <quicksilver> oerjan: which idea? equating?
00:31:13 <dolio> I think equating was proposed, but it lost to 'on'.
00:31:18 <oerjan> quicksilver: yeah
00:31:28 <quicksilver> it lost to `on`, yes
00:31:28 <oerjan> it did get sort of redundant
00:31:40 <quicksilver> which is more general, and no more verbose
00:31:45 <quicksilver> and just as readable IMO
00:31:48 <oerjan> probably comparing wouldn't have been either if they had thought of on first...
00:31:51 <quicksilver> (if not more)
00:33:00 <Baughn> http://paste.lisp.org/display/56252 <-- Fairly satisfied with this now, but I can't help but think that there must be an alternative to the explicit recursion in runNode
00:33:17 <yondalf_> @src on
00:33:18 <lambdabot> (*) `on` f = \x y -> f x * f y
00:33:38 <DRMacIver> `on` looks a bit weird, but I imagine I'll get used to it. :)
00:35:11 <yondalf_> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/ <- looking at this now
00:35:13 <lambdabot> Title: Quasiquoting Support for GHC
00:38:10 <RayNbow> hmm, that quasiquotation stuff looks interesting...
00:38:13 <DRMacIver> Hm. It would be nice to be able to section tuples. Is there a ghc extension for that?
00:39:40 * RayNbow recently encountered it this semester in a course on Program Transformation/Generation...
00:40:03 <RayNbow> (Stratego/XT supports concrete syntax)
00:41:50 <hpaste>  oerjan pasted "for Baughn" at http://hpaste.org/5791
00:43:14 <oerjan> Baughn: actually that might not do what you want if your code throws other exceptions.
00:43:54 <Baughn> oerjan: It shouldn't, but if it does, I don't want them silently ignored
00:44:59 <Baughn> @src mplus
00:44:59 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
00:45:08 <oerjan> @src MonadPlus
00:45:09 <lambdabot> Source not found. Do you think like you type?
00:45:14 <oerjan> @src IO mplus
00:45:15 <lambdabot> m `mplus` n = m `catch` \_ -> n
00:45:55 <oerjan> might be able to use a more refined catch instead
00:46:02 <Baughn> Aha. Is ignoring exceptions part of the definition of mplus?
00:46:27 <oerjan> i think that catch is only ioErrors, not all exceptions
00:46:35 <oerjan> not quite sure
00:47:26 <oerjan> it's the definition for IO mplus
00:48:42 <Baughn> The documentation defines only two equations, then goes on to mention that the IO instance breaks one of them
00:49:02 <Baughn> It seems pointless to me to have typeclasses with no particular defined common behaviour, though
00:50:17 <oerjan> @src IO fail
00:50:17 <lambdabot> fail s  = failIO s
00:50:23 <oerjan> @src failIO
00:50:24 <lambdabot> failIO s = ioError (userError s)
00:50:45 <oerjan> i see.  that would be the error raised if the Just <- fails
00:52:31 <glguy> poor fail... the embarrassment of Monad
00:53:18 <Baughn> If you try to fail and catch, have you really failed?
00:58:50 <noige> hi
00:59:00 <noige> I am interested in Functional programming
00:59:11 <Mr_Awesome> well, youve come to the right place :)
01:00:10 <dolio> Functional programming? Is that, like, C?
01:00:21 <noige> I would like to learn a language and I am looking at lisp, haskells
01:00:47 <Mr_Awesome> lisp is certainly simpler
01:01:02 <glguy> but not generally used in a functional style
01:01:19 <glguy> which may or may not matter to you
01:01:24 <Mr_Awesome> right. scheme is more functional than common lisp
01:01:41 <Mr_Awesome> (and just better in every way, imo)
01:01:51 <faxathisia> I dont think scheme is more functional...
01:01:58 <faxathisia> They are based on the same calculus
01:02:11 <faxathisia> You are just talking about syntax and pragmatics
01:02:35 <Mr_Awesome> scheme tends to facilitate fp. but yes, thats just syntax and conventions
01:03:01 <Mr_Awesome> but thats exactly what made me despise cl and love scheme
01:03:15 <noige> oops sorry my connection died
01:03:37 <noige> I am looking at lisp haskell ocaml and scheme
01:04:05 <faxathisia> noige, Sounds difficult learning all thoso at once!
01:04:28 <noige> faxathisia: oh I am not learning all of them
01:04:44 <noige> faxathisia: I know none of them so I am trying to figure out what to focus on
01:04:57 <quicksilver> Baughn: there are two kinds of MonadPlus, that's the problem.
01:05:00 <Mr_Awesome> are you familiar at all with fp?
01:05:07 <noige> I have a bit of programming experience in C, python, ruby and perl
01:05:10 <noige> Mr_Awesome: no
01:06:02 <Mr_Awesome> i see. ocaml may be a good starting point; its a bit awkward in some ways, but it can be just as fast as C and it serves as a gentle introduction to fp
01:06:20 <Cale> I tend to see Haskell as easier to start with than ML.
01:06:24 <noige> Mr_Awesome: well, I know it exists so I know that much. I am trying to figure out where I should start and which language will make it easy to understand the basics of fp
01:06:33 <Mr_Awesome> if you dive right into haskell, you may be a bit overwhelmed by the new paradigm, the monads, the laziness, and the type system
01:06:37 <Cale> I'd probably start with Haskell.
01:06:42 <Mr_Awesome> Cale: really?
01:06:57 <quicksilver> I'd definitely start with haskell.
01:06:59 * faxathisia (can't imagine why someone would want to use Ocaml unless they were working on existing code...)
01:07:12 <Cale> Well, sure, you have to learn how not to use state, but you're going to have to do that anyway.
01:07:15 <quicksilver> ocamls has a misguided object system and misguided impurity features
01:07:24 <quicksilver> I think those are blind alleys to confuse you :)
01:07:29 <Cale> and bad syntax :)
01:07:36 <glguy> quicksilver: but otherwise it's awesome?
01:07:48 <quicksilver> and some annoying quirks like constructors not being first class functions.
01:07:49 <faxathisia> noige, and SICP (free online) is a very good book you may enjoy
01:08:10 <Cale> Yeah, if you're going with scheme, SICP is one definite advantage of that.
01:08:12 <quicksilver> glguy: there are some awe-inspiring things about ocaml. Like the compilation model. And, generally, the efficiency of the compiler.
01:08:35 <faxathisia> What about the compilation model?
01:08:37 <quicksilver> and the extensible records / subtyping stuff is certainly interesting.
01:08:40 <Cale> In fact, I recommend watching the video lectures even if you're not learning scheme, as they give an excellent perspective on CS.
01:08:49 <quicksilver> faxathisia: it compiles to category theory, in a sense. It's quite an interesting idea.
01:09:00 <Mr_Awesome> regardless, no matter where you start, you wont end up with ml ;)
01:09:13 <faxathisia> Interesting..
01:09:55 <faxathisia> Haskell is still ml-the-type-system and my-the-calculus :P
01:10:20 <quicksilver> haskell isn't quite ml-the-type-system.
01:10:26 <noige> hmm ok
01:10:28 <quicksilver> System Fc is different from System F
01:10:39 <ClimDan> Cool Dating Club site ===> new-datingclub eu
01:10:40 <noige> so it sounds like you are recommending that I learn scheme first
01:10:50 <quicksilver> and haskell type inference is a bit more than HM
01:11:08 <quicksilver> it is very very similar for most purposes, certainly
01:11:16 <Mr_Awesome> noige: were recommending you read SICP
01:11:26 <noige> oh ok
01:11:41 <Mr_Awesome> (which will teach you scheme as a side effect)
01:12:01 <noige> ok
01:12:12 <noige> hmm
01:12:22 <Mr_Awesome> but dont get to used to that. haskell doesnt have any side effects
01:12:26 <noige> I will get sicp tomorrow
01:12:33 <Mr_Awesome> its free online
01:12:40 <noige> ahh
01:12:44 <noige> I will get it now then
01:14:35 <noige> thank you all for addressing my questions
01:15:09 <noige> ocaml feels a bit heavy handed
01:15:24 <noige> like it is meant for people who are already very familiar with fp
01:15:37 <decker> hi
01:15:51 <noige> hi
01:16:01 <decker> can you help me with a quick haskell type problem?
01:16:08 <noige> no
01:16:14 <decker> :(
01:16:19 <noige> I do not know haskell
01:16:23 <decker> oh snap
01:16:24 <faxathisia> decker, someone else might be able to though :)
01:16:36 <noige> I just came here
01:16:37 <faxathisia> decker, what is it?
01:16:48 <decker> sweet well i'm sure it's a very obviously problem cuz i started learning haskell about a week ago
01:17:03 <decker> i'm trying to define a simple recursive function like this
01:18:25 <decker> mySum (n:ns) |(ns == []) = n |otherwise n + (mySum ns)
01:18:46 <faxathisia> decker, You just missed an =
01:18:50 <decker> oh
01:18:51 <decker> right
01:18:57 <decker> but you get the idea
01:19:09 <Deewiant> decker: what happens with mySum []
01:19:25 <faxathisia> decker, well you may like to rephrase this
01:19:31 <faxathisia> mySum [n] = n
01:19:46 <faxathisia> mySum (n:m:ms) = n + mySum (m:ms)
01:19:47 <decker> k that was a poorly formed example
01:19:52 <decker> th eexact code is this
01:19:57 <decker> natToInteger ns
01:20:01 <decker> 	|(ns == []::Natural)		= 0
01:20:04 <decker> 	|otherwise		= sum [n * 10^i | (n, i) <- zip ns [0..((length ns)-1)]]
01:20:09 <Baughn> decker: Put it up on lisppaste instead
01:20:13 <glguy> !paste
01:20:13 <hpaste> Haskell paste bin: http://hpaste.org/
01:20:15 <decker> oh sorry what's th eurl
01:20:33 <faxathisia> decker, you could write it as two equations
01:20:39 <Deewiant> you can replace that [0..((length ns)-1)] with just [0..]
01:20:40 <faxathisia> decker, natToInteger [] = 0
01:20:46 <faxathisia> decker, natToInteger ns = ...
01:21:55 <Baughn> decker: I don't suppose you could just say "mySum = sum"?
01:22:00 <hpaste>  decker pasted "Type Problem" at http://hpaste.org/5792
01:22:32 <decker> Expected type: Natural Inferred type: [a]
01:22:40 <quicksilver> decker: well the bug there is that [] :: Natural doesn't make sense
01:22:47 <quicksilver> decker: [] :: [Natural] would make sense
01:22:47 <decker> ok
01:22:49 <quicksilver> [] is a list.
01:22:55 <quicksilver> however, you could miss that out entirely
01:22:58 <faxathisia> perhaps you needed   natToInteger (Natural ns) -- ?
01:23:00 <decker> oh
01:23:05 <quicksilver> you don't need to tell it what type [] is.
01:23:05 <decker> do i have to do something like
01:23:12 <decker> data Natural = Empty|[Natural]
01:23:14 <decker> or someting?
01:23:18 <quicksilver> no, you don't
01:23:28 <quicksilver> what you have is fine as a structure
01:23:39 <quicksilver> but you do have to 'unpack' your newtype constructor
01:23:43 <quicksilver> and you don't want that type annotation
01:23:51 <quicksilver> natToInteger (Natural ns)
01:23:57 <quicksilver> 'unpacks' the type constructor
01:24:04 <quicksilver> then | (ns == []) = 0
01:24:07 <quicksilver> would be fine
01:24:11 <decker> ah
01:24:17 <quicksilver> no need for a type annotaiton, haskell can work ito out
01:24:38 <quicksilver> (it's actually not the most idiomatic way to do this, but I think it's more helpful to show you how to fix what you have, before improving it...)
01:25:09 <decker> yeah i'm sure it's not th best haskell design
01:26:27 <quicksilver> decker: you don't actually need an explicit [] case at all, by the way.
01:26:33 <quicksilver> decker: 'sum' will work fine with an empty list
01:26:41 <quicksilver> decker: and zip will work with an empty list, etc.
01:26:41 <decker> oh yeah
01:27:02 <quicksilver> > sum []
01:27:06 <lambdabot>  0
01:27:15 <decker> oh that's cool
01:28:40 <decker> should the the type of natToInteger be Integral a => Natural -> a
01:29:45 <hpaste>  DRMacIver pasted "Style comments?" at http://hpaste.org/5793
01:29:58 <DRMacIver> "That's horribly inefficient" comments are also appreciated. :)
01:30:55 <DRMacIver> Summary explanation: There's a metric called 'brokerage' which takes a graph of a social network and measures, for each person in the graph, how many communication paths they're critical to.
01:33:07 <DRMacIver> (Oh, that requires fglasgow-exts to compile, but if you remove some of the type annotations it should be valid without)
01:34:08 <diptansu> does anybody know how to install cabal-install on windows?
01:35:36 <glguy> guard . not $ x `elem` xs  --> guard $ x `notElem` xs (to avoid yet another a . b $ x)
01:36:46 <Armored_Azrael> > 2 + 3
01:36:46 <lambdabot>  5
01:37:32 <noige> hello
01:37:43 <noige> > 4 + 7
01:37:44 <lambdabot>  11
01:37:51 <noige> hmm
01:37:57 <noige> that is cool
01:37:58 <glguy> > True < error "this ought to short circuit ;-D"
01:37:59 <lambdabot>  Exception: this ought to short circuit ;-D
01:38:05 <faxathisia> > map f [x,y,z]
01:38:05 <lambdabot>  Add a type signature
01:38:10 <faxathisia> :/
01:38:15 <faxathisia> > map f [a,b,c]
01:38:15 <lambdabot>  Add a type signature
01:38:20 <faxathisia> ?version
01:38:21 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
01:38:21 <lambdabot> darcs get http://code.haskell.org/lambdabot
01:38:22 <Deewiant> > map f [a,b,c] :: [Expr]
01:38:24 <lambdabot>  [f a,f b,f c]
01:38:33 <Deewiant> don't ask me why that's needed but it sometimes is
01:38:49 <noige> so I think that I am going to learn Haskell first
01:39:00 <noige> I want to be a better programmer
01:39:05 <noige> and I want to learn fp
01:39:19 <noige> I think that something that is strict fp will help me
01:39:31 <glguy> ?faq
01:39:31 <lambdabot> The answer is: Yes! Haskell can do that.
01:39:33 <noige> but I really do not know what will help me hahah
01:39:34 <faxathisia> noige, haskell isn't strict, it's lazy :D
01:39:47 <noige> oh ok
01:39:54 <glguy> or at least it's non-strict
01:39:59 <faxathisia> noige, probably not what you meant
01:40:54 <glguy> > f 0 :: Expr
01:40:54 <noige> well I guess this is the start of my haskell learning
01:40:55 <lambdabot>  f 0
01:41:01 <glguy> What devil work is this Expor
01:41:13 <noige> hmm
01:41:19 <noige> I think I should keep some good notes
01:41:24 <faxathisia> I think :: Expr is unneeded
01:41:39 <faxathisia> not sure why it's required now
01:41:45 <glguy> I'm not concerned with the annotation
01:41:47 <noige> so this lambda sign on the book
01:41:49 <glguy> just hadn't seen that featue
01:41:52 <glguy> feature
01:42:01 <noige> all functional languages are based on lambda calculus?
01:42:59 <faxathisia> > foldr (flip f) z [a,b,c,d] :: Expr
01:43:00 <lambdabot>  f (f (f (f z d) c) b) a
01:43:06 <faxathisia> > foldr f z (reverse [a,b,c,d]) :: Expr
01:43:07 <lambdabot>  f d (f c (f b (f a z)))
01:43:30 <glguy> how is that implemented though
01:43:36 <glguy> looks like black magic
01:44:04 <faxathisia> I think there is a num instance for a,b,c,..
01:44:15 <glguy> OHH
01:44:20 <glguy> it only works for specific variables?
01:44:20 <kijjaz> I've just decided to start learning Haskell now. (for algorithmic music / sound synthesis) .. ^_^"
01:44:28 <noige> hmm so is > foldr f z (reverse [a,b,c,d]) :: Expr returning a function with two functions as its arguments?
01:44:33 <faxathisia> > thisIsNotAVar + 1 :: Expr
01:44:33 * kijjaz feelin' lazy
01:44:34 <lambdabot>   Not in scope: `thisIsNotAVar'
01:44:52 <faxathisia> noige, Expr is a type like, Integer, [a] or whatever
01:45:04 <glguy> that's less evil :)
01:45:09 <faxathisia> > (var "thisIsNotAVar") + 1 :: Expr
01:45:09 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Sym a'
01:45:15 <noige> this is really interesting
01:45:15 <faxathisia> :|
01:45:34 <noige> ok
01:45:38 <noige> well thanks people
01:45:44 <noige> I appreciate your great advice
01:45:47 <wagle_home> @src +
01:45:47 <lambdabot> Source not found. You untyped fool!
01:46:04 <DRMacIver> glguy: I don't know. I find it pretty entertainingly diabolical.
01:46:13 <noige> I am going to learn haskell
01:46:26 <glguy> DRMacIver: if it's only specific variables, I can easily see how it is implemented
01:46:44 <glguy> I was upset at the thought of the behind the scenes hackery going on
01:46:48 <glguy> if it was arbitrary names
01:47:18 <trez> @where simplereflect
01:47:18 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
01:48:26 <DRMacIver> glguy: Yeah, makes sense. It could be a lot worse. :)
01:48:39 <DRMacIver> It's a cute hack rather than LINQ style expression trees
01:48:40 <noige> It seems like the haskell site is pretty good as far as learning info is concerned. Are there any other documentation sites you would recommend to a newbie?
01:49:00 <DRMacIver> noige: Check out the wikibook. It's incomplete, but seems to be constantly improving.
01:49:13 <noige> DRMacIver: ok will do
01:50:57 <glguy> > a a :: Expr
01:50:59 <lambdabot>  Couldn't match expected type `Expr -> Expr'
01:51:13 <glguy> > f f :: Expr
01:51:14 <lambdabot>  Add a type signature
01:51:29 <glguy> :t f
01:51:31 <lambdabot> Not in scope: `f'
01:51:59 <glguy> :t (f :: Expr -> Expr) f
01:51:59 <lambdabot> Not in scope: `f'
01:51:59 <lambdabot> Not in scope: type constructor or class `Expr'
01:51:59 <lambdabot> Not in scope: type constructor or class `Expr'
01:52:02 <faxathisia> > f :: Expr
01:52:03 <lambdabot>  f
01:52:08 <faxathisia> > f :: Expr -> Expr
01:52:08 <lambdabot>   add an instance declaration for (Typeable Expr)
01:52:17 <faxathisia> > a b :: Expr
01:52:18 <lambdabot>  Couldn't match expected type `Expr -> Expr'
01:52:21 <glguy> > (f :: Expr -> Expr) f
01:52:21 <lambdabot>  f f
01:52:30 <glguy> omg recursive types ;)
01:53:11 <dolio> > g (f f) (g (f f))
01:53:12 <lambdabot>  Add a type signature
01:53:15 <glguy> it can't tell that different  uses of the same var are the same var is what i was testing
01:53:20 <dolio> > g (f f) (g (f f)) :: Expr
01:53:20 <lambdabot>  Add a type signature
01:53:24 <dolio> Bah.
01:53:31 <noige> hey this handles huge numbers by default
01:53:33 <noige> that is cool
01:54:57 <faxathisia> noige, yeah, it's great also has garbage collection
01:55:12 <noige> holy smoke
01:55:19 <wagle_home> > (Œªf . (Œªx . f (x x)) (Œªx . f (x x))) (Œªf . (Œªx . f (x x)) (Œªx . f (x x))) :: Expr
01:55:19 <lambdabot>  Illegal character ''\187''
01:55:19 <lambdabot>  at "ªf" (column 3)
01:55:28 <noige> there is also a greatest commond denominator function by default
01:55:31 <noige> that is cool
01:55:50 <faxathisia> > gcd 400 235 :: Expr
01:55:51 <lambdabot>  abs 400 `rem` abs 235 `rem` (abs 235 `rem` (abs 400 `rem` abs 235)) `rem` (a...
01:55:52 <wagle_home> > (\f . (\x . f (x x)) (\x . f (x x))) (\f . (\x . f (x x)) (\x . f (x x))) :: Expr
01:55:52 <lambdabot>  Parse error at "." (column 5)
01:56:05 <faxathisia> > gcd 15 20 :: Expr
01:56:06 <lambdabot>  abs 20 `rem` (abs 15 `rem` abs 20)
01:56:15 <faxathisia> > gcd 15 20
01:56:16 <lambdabot>  5
01:56:33 <wagle_home> > (\f -> (\x -> f (x x)) (\x -> f (x x))) (\f -> (\x . f (x x)) (\x -> f (x x))) :: Expr
01:56:34 <noige> > gcd 1.5 7.234234235
01:56:34 <lambdabot>  Parse error at "." (column 52)
01:56:37 <noige> hahah
01:56:41 <lambdabot>  Add a type signature
01:56:46 <wagle_home> > (\f -> (\x -> f (x x)) (\x -> f (x x))) (\f -> (\x -> f (x x)) (\x -> f (x x))) :: Expr
01:56:47 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
01:56:47 <lambdabot>     Probab...
01:57:13 <wagle_home> > (\f -> (\x -> f (x x)) (\x -> f (x x))) :: Expr
01:57:18 <lambdabot>      The lambda expression `\ f -> (\ x -> ...) (\ x -> ...)'
01:57:18 <lambdabot>     has one arg...
01:57:26 * glguy tries to remember ordering another irc logger
01:57:29 <noige> > gcd 1.5 7.234234235 :: Double
01:57:29 <lambdabot>   add an instance declaration for (Integral Double)
01:57:29 <lambdabot>     In the expression: gc...
01:57:33 <wagle_home> > (\f -> (\x -> f (x x)) (\x -> f (x x))) :: Expr -> Expr
01:57:34 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
01:57:34 <lambdabot>     Probab...
01:58:14 <noige> > spam
01:58:16 <lambdabot>   Not in scope: `spam'
02:00:00 <noige> ok well thanks people
02:00:07 <noige> I am going to finally sleep
02:02:13 --- mode: ChanServ set +o glguy
02:02:17 --- mode: glguy set +b IRSeekBot!*@*
02:02:17 --- kick: IRSeekBot was kicked by glguy (glguy)
02:02:21 --- mode: glguy set -o glguy
02:02:49 <wagle_home> (what did IRSeekBot do?)
02:03:04 <glguy> caught my eye
02:08:23 * dolio hits a speed bump in his generalized tries.
02:08:37 <Cale> Heh, a pure functional language without garbage collection (or any other sort of automatic memory management) would be pretty funny.
02:11:56 <Baughn> Cale: ..what, not even a stack?
02:12:16 <Baughn> I think I'd rather have forth. -_-
02:12:25 <faxathisia> Have you tried to use Joy? It's a higher order stacky language
02:12:42 <faxathisia> I tried to write a type inferer... so painful
02:16:13 <dolio> faxathisia: I set up a darcs repo of random agda stuff I've been hacking on at http://code.haskell.org/~dolio/agda-play/
02:16:14 <lambdabot> Title: Index of /~dolio/agda-play
02:16:33 <dolio> Mostly copying functions from various Haskell modules.
02:17:05 <dolio> I have a fair amount of Data.List implemented for both lists and vectors. It's amazing how little proving most of it takes.
02:17:12 <faxathisia> cool :D
02:17:43 <faxathisia> wow you've done a lot more than me..
02:17:47 <dolio> Except reverse on vectors. That turned out to be terrible. :)
02:18:20 <faxathisia> :o
02:18:36 <faxathisia> zip is very concise!
02:20:21 <faxathisia> dolio, zip is very short! This is the part of Agda I don't understand, how can it know these cases are redundant (the missing nil (y ‚ä≤ ys), (x ‚ä≤ xs) nil)
02:21:07 <dolio> faxathisia: The type signature says you can only use it on equal sized vectors.
02:21:28 <dolio> You could do it for unequally sized vectors and you'd need those cases.
02:27:47 <quicksilver> dolio: surely rather than hosting your agda code in darcs, you should first write a VCS in agda and then use that to host?
02:27:50 <quicksilver> dolio: ;)
02:28:08 <dolio> Heh.
02:28:15 <faxathisia> very nice though, thanks
02:28:49 <faxathisia> I'm still baffled how it can discharge the cases
02:29:43 <mattam> faxathisia: it does constructor theory reasonning for you, it's fairly powerful.
02:31:21 <matthew-_> hmm. haddock really could try harder to nicely format gigantic type sigs
02:31:38 <matthew-_> eg with nice formatting, this is actually quite readable: http://hackage.haskell.org/packages/archive/sessions/2008.2.20/doc/html/Control-Concurrent-Session.html
02:31:40 <lambdabot> http://tinyurl.com/23xjap
02:31:58 <faxathisia> How could I find out about constructor theory?
02:32:15 <dolio> Huh, apparently doing zip for unequal vectors requires some extra proving.
02:38:00 <faxathisia> didn't know about forall
02:38:13 <smg> hello
02:38:24 <dolio> Yeah, I saw that looking around in the standard libraries.
02:40:46 <smg> > [1] ++ truncate(10/2)
02:40:56 <lambdabot>   add an instance declaration for (Integral [t])
02:41:09 <smg> > [1] ++ (truncate(10/2))
02:41:09 <lambdabot>   add an instance declaration for (Integral [t])
02:41:51 <smg> mh
02:43:15 <smg> what's the problem here?
02:43:55 <faxathisia> smg, well ++ works on lists and truncate gives you an integral, but theres no integral which is a list
02:44:06 <faxathisia> > [1] ++ [truncate(10/2)]
02:44:08 <lambdabot>  [1,5]
02:44:22 <smg> i see
02:44:23 <faxathisia> this works though, since you ++ two lists
02:46:06 <smg> faxathisia: i have x/2
02:46:06 <smg> how can i make it to an integer?
02:46:26 <Baughn> smg: You might use div instead of /
02:46:32 <smg> k
02:46:52 <Baughn> smg: Alternately, look at floor and friends
02:47:23 <smg> works
02:47:50 <Baughn> @src div
02:47:50 <lambdabot> Source not found. You untyped fool!
02:48:52 <Cale> heh
02:48:59 <Cale> @src Integral
02:48:59 <lambdabot> class  (Real a, Enum a) => Integral a  where
02:48:59 <lambdabot>     quot, rem, div, mod :: a -> a -> a
02:48:59 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
02:48:59 <lambdabot>     toInteger           :: a -> Integer
02:53:39 <smg> Baughn: no div was exactly right :]
02:55:21 <smg> how can i get a list of integers into a string?
02:55:30 <smg> is there something in the prelude?
02:55:40 <Baughn> smg: show
02:55:43 <faxathisia> > intercalate " " $ map show $ [1..]
02:55:47 <lambdabot>  "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ...
02:56:01 <faxathisia> > show $ [1..]
02:56:02 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:56:06 <Baughn> .."intercalate"?
02:56:23 <quicksilver> intercalate is the combination of concat and intersperse
02:56:41 <Baughn> So I see, but the name makes me weep
02:56:46 <smg> Baughn: ah okay i did not explain good what i need
02:57:10 <quicksilver> tears of sweet joy, I hope.
02:57:55 <smg> interecalate, where is it? :)
02:58:33 <quicksilver> in Data.List but only in 6.8.x and later
02:58:35 <quicksilver> IIRC
02:58:48 <smg> k
02:58:52 <smg> thank you very much
02:59:00 <quicksilver> otherwise concat . intersperse " " . map show $ [1..]
02:59:04 <quicksilver> is the same
02:59:06 <smg> haha
02:59:15 <smg> i need to look up this $ thingy
02:59:21 <Cale> @dict intercalate
02:59:21 <lambdabot> Supported dictionary-lookup commands:
02:59:21 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
02:59:21 <lambdabot> Use "dict-help [cmd...]" for more.
02:59:23 <quicksilver> it's just a way to avoid brackets
02:59:29 <Cale> @web1913 intercalate
02:59:30 <lambdabot> *** "Intercalate" web1913 "Webster's Revised Unabridged Dictionary (1913)"
02:59:30 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
02:59:30 <lambdabot>    {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
02:59:30 <lambdabot>    intercalatus, p. p. of intercalare to intercalate to
02:59:30 <lambdabot>    intercalate; inter between + calare to call, proclaim. See
02:59:32 <lambdabot> [10 @more lines]
02:59:40 <Cale> @more
02:59:40 <lambdabot>    {Calendar}.]
02:59:40 <quicksilver> (concat . intersperse " " . map show) [1..]
02:59:41 <lambdabot>    1. (Chron.) To insert, as a day or other portion of time, in
02:59:41 <lambdabot>       a calendar.
02:59:41 <lambdabot>  
02:59:41 <smg> quicksilver: yo mean map (show [1..]) would be the same?
02:59:42 <lambdabot>    2. To insert among others, as a verse in a stanza; specif.
02:59:44 <lambdabot> [5 @more lines]
02:59:50 <quicksilver> smg : (concat . intersperse " " . map show) [1..]
02:59:53 <quicksilver> would be the same
03:00:06 <smg> ahhh
03:00:14 <smg> btw the prelude is cool
03:00:19 <smg> many handy functions
03:00:41 <Baughn> Some missing ones. I /always/ end up with the same half dozen imports..
03:01:11 <smg> hehe i just started haskell 2 days ago
03:01:28 <smg> :)
03:02:31 <smg> btw i dreamed from haskell tonight :P
03:02:42 <Stinger> ok you're strange :P
03:02:45 <smg> :P
03:02:56 <smg> Stinger: no!
03:02:58 <matthew-_> ...along with most others here ;)
03:03:12 <smg> Stinger:  i could not answer the questions what's the benefits of map and list comprehension
03:03:18 <smg> especially speed
03:03:57 <Baughn> darcs: getCurrentDirectory: resource exhausted (Too many open files) <-- Now what?
03:05:22 <smg> > take 10 $ map(\x -> x**2) [1..]
03:05:26 <lambdabot>  [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]
03:05:27 <Baughn> Oh, found a faq
03:05:32 <smg> > [2,4,16 .. ]
03:05:32 <lambdabot>  Parse error at ".." (column 9)
03:05:49 <Cale> > extendSequence [2,4,16]
03:05:51 <lambdabot>  [2,4,16,56,256,1072,6224,33616,218656,1326656,9893632,70186624,574017536,445...
03:05:57 <Baughn> > take 10 (map (**2) [1..]
03:05:57 <lambdabot> Unbalanced parentheses
03:05:58 <Baughn> > take 10 (map (**2) [1..])
03:05:59 <lambdabot>  [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]
03:06:01 <Cale> > describeSequence [2,4,16]
03:06:03 <lambdabot>  Just "Number of degree-n permutations of order dividing 4."
03:06:14 <Cale> heh
03:06:23 <Baughn> ..where is extendSequence from?
03:06:30 <Cale> Math.OEIS
03:06:42 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/oeis-0.1
03:06:50 <lambdabot> http://tinyurl.com/yvsjcu
03:06:59 <Baughn> That about figures. Inriguing.
03:07:02 <smg> Cale: haha nice
03:07:17 <smg> i think i like haskell
03:08:26 <Cale> It is slightly evil. Despite the pure interface, it does network IO :)
03:08:58 <smg> i think i know become familiar with . and $ and $! :)
03:10:00 <Vq^> smg: congratulations :)
03:10:28 <smg> hehe ty Vq^
03:19:15 <smg> getLine gets user input
03:19:27 <smg> how can i say use the input then in my program?
03:20:34 <Japsu> > scanl f a [b, c, d]
03:20:36 <lambdabot>  [a,f a b,f (f a b) c,f (f (f a b) c) d]
03:20:45 <Japsu> ufff
03:21:29 <matthew-_> whaaaaaaaat? I didn't know Œªb would do that
03:21:44 <matthew-_> > map f [a, b, c]
03:21:45 <lambdabot>  Add a type signature
03:21:49 <nanothief> smg: do something like main = do line <- getLine \n putStrLn (reverse line)
03:21:57 * matthew-_ scratches his head
03:22:16 <doserj> > map f [a, b, c] :: [Expr]
03:22:17 <lambdabot>  [f a,f b,f c]
03:22:34 <matthew-_> ahhhh. Expr is a magic Œªb thing?
03:22:43 <doserj> where simplereflect
03:22:46 <doserj> @where simplereflect
03:22:46 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
03:22:59 <matthew-_> tnx
03:23:14 <smg> Œªb is what?
03:23:17 <smg> nanothief: ty
03:23:29 <Rebooted> Any thoughts on this code? http://www.swoodhouse.com/reddit.html
03:23:35 <lambdabot> Title: Steven Woodhouse - A Reddit clone in Haskell
03:23:35 <Rebooted> reddit clone
03:24:07 <matthew-_> smg: Œªb is lambdabot
03:24:48 <smg> lol ok
03:33:37 * dcoutts_ notes there have been 127 hackage uploads in the last 18 days
03:33:50 * matthew-_ suspects he'll be adding to that
03:34:03 <matthew-_> what % were gwern? ;)
03:34:14 <smg> mh
03:35:50 <Stinger> out of interest how small can you get a haskell Hello World binary?
03:36:34 <quicksilver> with experimental hacks to the linker, quite small.
03:36:39 <quicksilver> I think someone said 14K ?
03:37:03 <quicksilver> with the released GHC it's much bigger though.
03:37:07 <Stinger> experimental hacks ey, that doesn't sound too good
03:37:17 <Stinger> well on windows I currently get about 500k heh
03:37:21 <quicksilver> well it was to do with only linking in code which is actually used.
03:37:26 <quicksilver> so called "smart linking"
03:37:36 <smg> btw. is using $ better than ( ) ?
03:37:43 <quicksilver> and it was probably dynamically linked to libc too
03:37:44 <quicksilver> Im' not sure
03:37:53 <quicksilver> smg: well, it's a matter of taste
03:38:02 <quicksilver> smg: but some people find nests of () hard to read
03:38:03 <Stinger> yeah I was wondering if you could strip down the libs somehow
03:38:10 <dcoutts_> mathrick: so 183 since the beginning of the month, of which 35 were exact version duplicates
03:38:16 <smg> quicksilver: mh, i like $ personally
03:39:19 <quicksilver> so do I
03:40:43 <Stinger> hmm is there a sleep function in ghcs base libs? hoogle sleep doesnt return me anything
03:42:42 <dcoutts_> mathrick: so 183 since the beginning of the month, of which 35 were exact version duplicates, 51 uploads by gwern 35 of which 16 were duplicates
03:42:47 <kalven> I think there's a sleep monad somewhere
03:42:52 <dcoutts_> oops
03:43:03 <quicksilver> Stinger: threadDelay
03:43:08 <dcoutts_> mathrick: 51 uploads by gwern 35 distinct so 16 were duplicates
03:43:09 <quicksilver> @hoogle threadDelay
03:43:10 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
03:43:10 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
03:43:29 <dcoutts_> wait, not mathrick, matthew-_, sorry.
03:43:30 <Stinger> Concurrent ey, thanks, was looking in posix
03:44:57 <dcoutts_> matthew-_: so gwern got 23% of all distinct uploads this month and 46% of all duplicate uploads
03:45:04 <matthew-_> dcoutts: I see
03:45:46 <matthew-_> this data really should be publicly available, along with download stats and so forth for packages
03:46:10 <dcoutts_> matthew-_: yeah, we know. If you want to write the code that'd be well appreciated by all.
03:46:50 <matthew-_> ok, if you could just wait for me to finish my PhD... or at least wait until after the next conference deadline...
03:47:04 <dcoutts_> matthew-_: the log file is publicly available so anyone can do the analysis
03:47:12 <dcoutts_> the upload log that is
03:47:12 <matthew-_> oh neat
03:47:17 <matthew-_> oh, less neat
03:47:39 <dcoutts_> the apache download logs are not available, that's the main problem with gathering download stats
03:47:53 <dcoutts_> we'd need an apache log file parser :-(
03:48:30 <dcoutts_> or a different way of serving the tar.gz files that lets us count them
03:48:50 <dcoutts_> none of it's hard, just requires someone to volunteer
03:49:51 <Stinger> ok I have a program that just infinite loops with let f = threadDelay 1000000 : f in sequence f
03:49:56 <Stinger> would you expect that to leak?
03:50:12 <matthew-_> dcoutts_: indeed.
03:51:00 <quicksilver> Stinger: it's building up a bit list of [(),(),(),()] as it goes
03:51:06 <Stinger> ah
03:51:10 <quicksilver> that sounds like a slow leak
03:51:14 <quicksilver> try with sequence_
03:51:27 <Stinger> yeah was about to ask that
03:52:13 * Stinger watches memory usage
03:55:51 <Stinger> hmm still seems to be increasing
03:56:15 <quicksilver> hmm
03:56:20 <quicksilver> it might be keeping the list 'f' around too
03:56:36 <quicksilver> hmm
03:56:41 <quicksilver> no, that doesn't take any space.
03:56:50 <quicksilver> not sure, then
03:57:57 <Stinger> actually I suppose it could just be gc
03:58:13 <Stinger> seeing as I'm just watching windows task manager size
03:59:01 <Stinger> it has risen about 16k in the last few minutes
03:59:21 <Stinger> is there a way to force garbage collection?
04:00:41 <quicksilver> System.performGC
04:00:47 <quicksilver> 16k in a few minutes doesn't sound too bad :)
04:00:58 <quicksilver> System.Mem.performGC
04:00:59 <Stinger> heh no, but a leaks a leak
04:01:04 <Stinger> if it is indeed a leak
04:01:21 <quicksilver> sounds within expected bounds of 'GC not being performed' to me
04:01:54 <Stinger> yeah hopefully I'll whack the performGC into the loop and see if that fixes it
04:02:10 <Stinger> I'm convincing my friend to use python
04:02:23 <Stinger> and it doesnt look good when my "Hello world" basic program leaks :D
04:02:33 <Stinger> er convincing my friend to use Haskell rather
04:02:55 <asmanian> wrong channel window, eh? ;)
04:03:11 <Stinger> oh crap lynch mob
04:03:20 * quicksilver draws his pitchfork
04:04:59 <Stinger> @ty System.Mem.performGC
04:05:04 <lambdabot> IO ()
04:09:13 <Stinger> ok
04:09:19 <Stinger> seems to be holding steady now
04:25:03 <Twey> Is something wrong with forever $ threadDelay 1000000?
04:25:51 <Baughn> No, but why do it?
04:26:50 <matthew-_> well, it's just "another program" generated by the halting-problem-machine...
04:27:00 <Twey> Rather than let f = threadDelay 1000000 : f in sequence f
04:27:21 <Twey> (Stinger's)
04:27:31 <Baughn> Or sequence_ $ repeat $ threadDelay 100000
04:27:43 <Baughn> Twey: Using sequence would make that a memory leak
04:27:47 <Twey> Yes
04:27:49 <Baughn> Although a very slow one
04:27:50 <Twey> He discovered :-)
04:27:58 <Twey> (/she)
04:28:01 <matthew-_> threadDelay (1 / 0)
04:28:04 <matthew-_> ;)
04:28:08 <Baughn> I prefer forever. It's more concise. Anyway..
04:28:15 <Baughn> matthew-_: That works? o_O
04:28:15 <Stinger> for some reason I thought sequence just provided the last result (he)
04:28:18 <Baughn> @src forever
04:28:18 <lambdabot> Source not found. Wrong!  You cheating scum!
04:28:19 <matthew-_> no"
04:28:25 <nominolo> :t forever
04:28:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
04:28:28 <matthew-_> threaddelay will require an Int
04:28:54 <Baughn> Twey: I imagine it's something like "forever = sequence_ . repeat"
04:29:24 <matthew-_> rotfl! threadDelay (1 `div` 0) does lock ghci dead, despite the error message!
04:29:36 <quicksilver> forever m = m >> forever m
04:29:40 <quicksilver> it doesn't detour via lists
04:29:55 <quicksilver> although it could, I guess
04:30:13 <quicksilver> you'd need to be a GHC hacker to know if the detour via lists had a runtime consequence or not.
04:30:55 <Twey> @src forever
04:30:55 <lambdabot> Source not found. You speak an infinite deal of nothing
04:30:58 <Twey> :<
04:31:32 <Baughn> > forever $ putStr ""
04:31:33 <matthew-_> heh. threadDelay undefined also works
04:31:36 <lambdabot>  <IO ()>
04:32:38 <Twey> Returns _|_, right?
04:33:08 <Beelsebob> how awesome is that...
04:33:21 <Beelsebob> I start looking for a job, and one combining 3D graphics and Haskell comes up on the mailing list
04:33:28 * Beelsebob hopes for that one now
04:33:40 <Baughn> Twey: ..of a sort. As I understand, undefined is a kind of bottom, but so is <<loop>> and, quite possibly, plain infinite loops
04:33:59 <Twey> Baughn: Yep
04:34:32 <Twey> Anything that doesn't complete -- e.g. because an error was thrown, or just because it never ended.
04:35:16 <byorgey> Beelsebob: sounds cool, good luck! =)
04:35:17 <Baughn> http://www.kiwisbybeat.com/minus110.html <-- Somehow, this captures my first experience with haskell very well.
04:35:23 <matthew-_> yeah, but undefined can always inhabit any type. Sometimes an infinite loop has a fixed type
04:36:37 <quicksilver> they're all _|_ but ghci is able to detect some and not others
04:36:47 <quicksilver> ghci can detect error and undefined
04:36:50 <quicksilver> which makes this odd
04:36:54 <Twey> matthew-_, _|_ is a valid value of any type
04:37:03 <quicksilver> (it should be a reported error, not a hang)
04:37:09 <quicksilver> Twey: _|_ is not a value, it is a denotation
04:37:10 <Twey> Hm
04:37:14 <Twey> Bug?
04:37:18 <Twey> Oh, OK.
04:37:20 <quicksilver> I think so, yes.
04:37:25 <quicksilver> > 1 + undefined
04:37:28 <lambdabot>  Undefined
04:37:38 <quicksilver> normally reportable :)
04:37:46 <quicksilver> infintie loops in general aren't reportable, or even detectable.
04:37:54 <quicksilver> although for some amusing special cases ghc can detect them
04:37:57 <DRMacIver> Hm. My Haskell has gotten so bad. :-/
04:38:09 <matthew-_> > let f 0 = "boo"; f n = f (n - 1) in f (-1)
04:38:14 <lambdabot> Terminated
04:38:16 <quicksilver> ghc can even detect certain MVar deadlocks by the same technology
04:38:21 <quicksilver> which is awesome :)
04:38:28 <matthew-_> Twey: there, f is clearly :: String, but undefined is :: a
04:38:40 <matthew-_> quicksilver: wow! I didn't know that
04:38:43 <matthew-_> url?
04:39:27 <matthew-_> DRMacIver: thou shalt stop using Scala and shall return to the path of enlightenment
04:39:52 <quicksilver> matthew-_: I think it's GHC folklore :)
04:40:02 <quicksilver> matthew-_: basically, the GC knows which MVar threads are waiting on.
04:40:03 <Twey> Haha
04:40:13 <quicksilver> matthew-_: if it detects that that MVar isn't reachable from any other thread
04:40:16 <matthew-_> right, so it's just a standard runtime cyclical detection
04:40:18 <quicksilver> matthew-_: it can report the deadlock.
04:40:40 <matthew-_> ahh I see.
04:40:44 <smg> quicksilver: MVar?
04:40:47 <quicksilver> the "clever" part is that it uses the already existing GC/reachability stuff
04:40:58 <quicksilver> so it knows "for free" which MVars are reachable from which threads.
04:41:14 <quicksilver> smg: a variable for safe concurrent thread access
04:41:27 <smg> is this a haskell specific term?
04:41:52 <matthew-_> it's just a pointer to a cell where access is wrapped up with some atomic magic
04:42:19 <matthew-_> it's well explained in SPJ's "Tackling the Awkward Squad"
04:42:29 <quicksilver> smg: yes.
04:42:35 <quicksilver> smg: it's like a lock, or a synchronised variable
04:42:37 <quicksilver> only cleverer
04:42:46 <smg> ah i see
04:42:50 <quicksilver> being a slightly more primitive notion which makes a good building block
04:42:58 <quicksilver> for various sensible kinds of safe concurrency
04:43:05 <matthew-_> indeed.
04:47:24 <smg> okay, i guess if i get more used to haskell it will be my favorite language
04:47:36 <smg> really good that i can compile my stuff to ELF binary
04:48:24 <smg> what's the .hi file?
04:48:38 <quicksilver> it's GHC's approach to separate compilation.
04:48:42 <DRMacIver> matthew-_: Well, Scala has some nice points.
04:48:46 <quicksilver> it stores information about the exported functions from another file
04:48:52 <quicksilver> so it knows how to compile other files against it
04:49:04 <quicksilver> it's a little like a C++ ".h" file in purpose, but auto-generated.
04:49:09 <DRMacIver> matthew-_: My ideal language at this point would be about 70% Haskell, 30% Scala. :)
04:49:22 <quicksilver> Hascall
04:49:31 <smg> i see
04:49:42 <smg> only one question again: main = putStrLn "hello world!"
04:49:49 <smg> can i have multiple statements for main?
04:49:56 <DRMacIver> matthew-_: But I'm trying!
04:50:21 <quicksilver> smg: yes, using do
04:50:23 * DRMacIver is hoping to arrange for a Scala at work so he can get back to writing Haskell at home
04:50:31 <smg> quicksilver: ah cool
04:50:39 <quicksilver> main = do putStrlng "hello world!" \n putStrLn "goodbye"
04:50:50 <quicksilver> where you should line up the two "put"s vertically
04:51:04 <quicksilver> possible have a newline after the do (question of taste)
04:51:07 <smg> awesome
04:51:21 <Baughn> smg: Or using the functions that do syntax expands to
04:51:42 <Baughn> @undo do foo <- getLine; print "bar"; print foo
04:51:43 <lambdabot> getLine >>= \ foo -> print "bar" >> print foo
04:52:11 <Twey> quicksilver: Why \n instead of just using braces and semicolons?  :-P
04:53:29 <smg> print ?
04:53:41 <Baughn> It was faster than typing printLn
04:53:50 <dcoutts> print = putStrLn . show
04:54:04 <Baughn> *putStrLn, I mean
04:54:33 <dcoutts> the key point is that print can print anything in Show
04:55:19 <quicksilver> Twey: because I except smg will actually write his program using newlines
04:55:28 <smg> dcoutts: ahh! :)
04:55:35 <quicksilver> Twey: and he probably isn't yet familiar with the { ; } -> newline translation
04:55:45 <Twey> Oh, OK.
04:55:57 <smg> map (\x -> print (square x)) [1..10]
04:56:01 <Twey> I thought all tutorials mentioned it as a footnote (I've been through lots :-P)
04:56:02 <smg> it doesn't like that, why?
04:56:15 <smg> Twey: i'm only at site 40 @ yaht :)
04:56:21 <quicksilver> print is an IO action
04:56:27 <Baughn> smg: The result of that would be a list of IO actions
04:56:30 <quicksilver> so that will produce a list of IO actions
04:56:32 <quicksilver> which is fine.
04:56:32 <smg> oh
04:56:32 <Baughn> smg: You want mapM or mapM_
04:56:39 <smg> okay
04:56:39 <quicksilver> you can execute the list of IO actions using sequence_
04:56:47 <smg> is there another way to do that
04:56:47 <quicksilver> sequence_ (map (\x -> print (square x)) [1..10])
04:56:56 <smg> i wanted to say: print "Some square digits 1 .. 10"
04:56:58 <Baughn> There is always another way to do it
04:57:01 <smg> and then output the square digits
04:57:06 <quicksilver> but conveniently sequence_ (map  is very common, and has the name 'mapM_'
04:57:11 <smg> ah okay
04:57:14 <smg> so i use mapM_
04:57:18 <quicksilver> yup
04:57:23 <Baughn> Which combines sequence and map, yep
04:57:28 <smg> makes sense
04:57:44 <smg> but what's the difference between sequence and map then?
04:58:20 <LoganCapaldo> lots
04:58:21 <Twey> @src map
04:58:21 <lambdabot> map _ []     = []
04:58:21 <lambdabot> map f (x:xs) = f x : map f xs
04:58:25 <Twey> @src sequence
04:58:25 <lambdabot> sequence ms = foldr k (return []) ms
04:58:25 <lambdabot>     where
04:58:25 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
04:58:36 <dcoutts> perhaps it's easier to see in the types
04:58:40 <dcoutts> @type sequence
04:58:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:58:55 <dcoutts> so for example [IO a] -> IO [a]
04:59:10 <dcoutts> it does the list of actions, returning the list of results
04:59:19 <dcoutts> @type map
04:59:19 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:59:34 <dcoutts> simple pure function over lists, nothing about monads
04:59:56 <smg> okay
05:00:09 <LoganCapaldo> well, one monad ;)
05:00:34 <smg>  mapM_ (\x -> print (square x)) [1..10] <-- is fine
05:00:43 <smg> and how about  mapM_ (\x -> print x (square x)) [1..10]
05:00:44 <smg> ?
05:01:00 <quicksilver> print only takes one parameter
05:01:02 <Baughn> @ty mapM
05:01:04 <smg> ah okay
05:01:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:01:10 <dcoutts> smg: the key difference in the way to think about it is that in most languages everything is an action (with possible side effects) in haskell things are pure by default but we can create actions as first class values and pass them, around connect them together and if we feel like it we can run them at the appropriate point
05:01:15 <smg> can i somehow concat that tuff
05:01:19 <Cale> The sequence function takes a list of actions, and turns them into a single action which when run, produces a list of results.
05:01:26 <LoganCapaldo> @type (>>)
05:01:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
05:01:28 <Cale> (by running each of the actions in turn)
05:01:31 <quicksilver> you could try putStrLn (show x ++ " squared is " ++ show (square x))
05:01:32 <smg> ok
05:01:33 <Cale> sequence [] = return []
05:01:46 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:01:56 <smg> hehe cool
05:02:07 <Twey> Where is printf defined?
05:02:12 <smg> so how can i then concat 2 with " is " and 4 ?
05:02:13 <Cale> This is a kind of primordial loop which can be used to build more interesting loops.
05:02:18 <LoganCapaldo> Text.Printf
05:02:26 <LoganCapaldo> @index printf
05:02:27 <lambdabot> Text.Printf
05:02:27 <smg> ah
05:02:34 <Twey> smg: show(2) + " is " + show(4)
05:02:34 <Cale> oh, you'd just apply show to each of 2 and 4
05:02:36 <Twey> Er, ++
05:02:42 <Cale> and then use ++ or concat
05:02:51 <Baughn> smg: Both mapM and sequence are pure functions; simply evaluating them does not do anything to the actions you pass in. You have to actually run their result for that to happen. (do-syntax does that automatically, within the context of that do, though)
05:02:55 <Cale> > concat [show 2, " is ", show 4]
05:02:57 <lambdabot>  "2 is 4"
05:03:16 <smg> Cale: ahhh
05:03:21 <Twey> smg: Or, printf
05:03:34 <Twey> > printf "%d is %d" 2 4
05:03:35 <lambdabot>  Add a type signature
05:03:40 <Twey> :-(
05:03:40 <quicksilver> > printf "%d is %d" 2 4 :: String
05:03:40 <lambdabot>  "2 is 4"
05:03:41 <smg> haha printf ftw
05:03:48 <Twey> What else does printf return?
05:03:50 <quicksilver> but it's a bit of a mess with the type annotations
05:03:53 <LoganCapaldo> IO ()
05:03:58 <Twey> Thanks, by the way, LoganCapaldo :-P
05:04:01 <quicksilver> Twey: partially evaluated printf :)
05:04:08 <Twey> Ah, of course.  Heh
05:04:08 <Baughn> @ty printf
05:04:09 <quicksilver> the IO() is just a hack.
05:04:09 <smg> not in scope
05:04:09 <LoganCapaldo> printf is printf and sprintf :)
05:04:13 <lambdabot> forall r. (PrintfType r) => String -> r
05:04:16 <quicksilver> but the key point is the partially evaluated bit.
05:04:24 <smg> printf: not in scope?
05:04:24 <smg> ?
05:04:30 <LoganCapaldo> printf is just a hack :)
05:04:37 <quicksilver> :m +Text.Printf
05:04:40 <quicksilver> if you're playing in ghci
05:04:51 <Twey> Ah
05:04:58 <smg> import Text.Printf ?
05:04:59 <Twey> I did import Text.Printf :-)
05:05:01 <smg> i am in source file
05:05:05 <Cale> yeah
05:05:06 <Twey> smg, aye
05:05:11 <quicksilver> in a source file, it's import
05:05:22 <Cale> printf has interesting polymorphism
05:05:24 <LoganCapaldo> import works in 6.8 in ghci
05:05:29 <LoganCapaldo> no?
05:05:34 <Cale> It acts both like printf and sprintf
05:05:36 <Baughn> @ty printf "%d %d" 2
05:05:38 <lambdabot> forall t t1. (PrintfType (t -> t1), Num t) => t1
05:05:38 <smg> parse error
05:05:44 <smg> LoganCapaldo: what do i need?
05:08:04 <smg> ah i just used concat
05:09:23 <Baughn> smg: By the way, you might want to read about the nuclear waste metaphor for monads
05:09:40 <smg> ok
05:09:41 <Baughn> smg: You don't necessarily need to know how it works right away, but until you do, a lot of this will seem like magic.
05:09:59 <smg> wht exactly do you mean seems like magic?
05:10:04 <Baughn> http://en.wikibooks.org/wiki/Programming:Haskell_monads
05:10:04 <lambdabot> Title: Haskell/Understanding monads - Wikibooks, collection of open-content textbooks
05:10:45 <smg> Baughn: okay i see
05:10:53 <smg> Baughn: i first read yaht :)
05:10:57 <Baughn> smg: The rules for how you can put together monad-handling functions, do notation and such.. are perfectly sane, simple rules, but may require a bit of mental twisting.
05:11:19 <smg> hehe
05:11:25 <Baughn> smg: It's hard to figure it out on your own, and it helps to have more than one perspective - so more than one tutorial. ;)
05:11:55 <smg> hehe
05:12:00 <smg> yeah i just on page 40 of yaht
05:12:06 <smg> i have bookmarked this site to read later on
05:19:12 <Baughn> smg: Don't forget to read the "gentle" introduction at some point
05:20:29 <smg> hehe
05:20:37 <smg> http://haskell.org/tutorial/goodies.html <-- :]
05:28:34 <shapr> Good morning #haskell!
05:32:54 <shapr> Is everyone asleep?
05:32:59 <haxplorer> anyone knows of any site that generate some (be it crap) questions given a few keywords such that the question contains those keywords?
05:33:03 <faxathisia> busy coders!
05:33:09 <faxathisia> Good afternoon :p
05:33:24 <ricky_clarkson> shapr: Is Java programming the same as being asleep?
05:33:24 <shapr> haxplorer: Are you learning Haskell?
05:33:31 --- mode: ChanServ set +o shapr
05:33:36 <haxplorer> yes. I 'am
05:33:46 <pcc1> @hoogle IO (a) -> IO ()
05:33:48 <lambdabot> Foreign.Marshal.Error.void :: IO a -> IO ()
05:33:48 <lambdabot> Foreign.C.Error.throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
05:33:48 <lambdabot> Foreign.C.Error.throwErrnoIfRetry_ :: (a -> Bool) -> String -> IO a -> IO ()
05:33:50 <shapr> ricky_clarkson: Um, I'm not sure. I've been doing lots of C# lately.
05:34:06 <haxplorer> lambdabot does some great nlp right? That's why thought if it can already do it..
05:34:07 <ricky_clarkson> Actually I'm doing Scala, I just said that for effect. :)
05:34:10 <shapr> haxplorer: I missed the question, what are you trying to do?
05:34:13 <shapr> ricky_clarkson: hah
05:34:16 <haxplorer> or if there are other sites done by some haskellers..
05:34:20 --- mode: shapr set -o shapr
05:34:59 <shapr> haxplorer: Generating random sentences isn't hard, it' s roughly the opposite of a Parsec parser.
05:35:02 <haxplorer> shapr: I need some application to which if I give a few words, would generate a question or sentence out of it and give me back.. However relevant it is
05:35:06 <shapr> You could put keywords into your grammar.
05:35:23 <glen_quagmire> :type 3 True
05:35:26 <haxplorer> shapr: oh!Can you point me to some docs related to that?
05:35:35 <shapr> haxplorer: Sure, build a sentence datatype and use QuickCheck to randomly generate values?
05:35:44 <faxathisia> > let xs = [a,b,c] ; ys = [x,y] in ( foldr f z (xs ++ ys) , foldr f (foldr f z ys) xs ) :: [(Expr, Expr)]
05:35:47 <lambdabot>  Couldn't match expected type `[(Expr, Expr)]'
05:35:56 <faxathisia> > let xs = [a,b,c] ; ys = [x,y] in ( foldr f z (xs ++ ys) , foldr f (foldr f z ys) xs ) :: ([Expr], [Expr])
05:35:57 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
05:36:30 <faxathisia> what am I thinking..
05:36:34 <faxathisia> > let xs = [a,b,c] ; ys = [x,y] in ( foldr f z (xs ++ ys) , foldr f (foldr f z ys) xs ) :: (Expr, Expr)
05:36:35 <lambdabot>  (f a (f b (f c (f x (f y z)))),f a (f b (f c (f x (f y z)))))
05:36:53 <haxplorer> shapr: ya. guess that should work. Thanks.. But is there any already existing application for that which I can just glue up and create my prototype?
05:37:18 <haxplorer> would lambdabot by any chance be able to help me?
05:38:26 <shapr> haxplorer: Um, you could use the Gramattical Framework ( http://www.cs.chalmers.se/~aarne/GF/ ) to do that. You could put your keywords into GF grammars.
05:38:27 <lambdabot> Title: GF Version 2.9
05:39:29 <haxplorer> shapr: Thanks a lot.. Will look into it now
05:39:49 <faxathisia> It would be really nice to be able to run some haskell programs backwards
05:40:37 <quicksilver> someone should write a paper on that
05:40:50 <quicksilver> they could call it, oh, I dunno, "Arrows for Invertible Programming?"
05:40:54 <quicksilver> or something like that.
05:41:11 <faxathisia> :O
05:41:17 * faxathisia *reading*
05:41:39 <shapr> quicksilver: Nah, too easy.
05:46:28 <faxathisia> > let ys = [a,b,c] in ( (f (foldl f z ys) x) , foldl f z (ys ++ [x]) ) :: (Expr, Expr) -- Lambdabot/Expr is helpful to check identities
05:46:29 <lambdabot>  (f (f (f (f z a) b) c) x,f (f (f (f z a) b) c) x)
05:46:37 <faxathisia> (and find them)
05:50:13 <yondalf_> is there any function that duplicates a list n times?
05:50:24 <quicksilver> replicate ?
05:50:27 <Cale> > replicate 5 'a'
05:50:30 <quicksilver> it works on everything not just lists
05:50:30 <lambdabot>  "aaaaa"
05:50:35 <Cale> > replicate 5 [1,2,3]
05:50:36 <lambdabot>  [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
05:50:37 <yondalf_> > replicate 5 [1,2]
05:50:37 <lambdabot>  [[1,2],[1,2],[1,2],[1,2],[1,2]]
05:50:46 <yondalf_> ah then i have to flaten it i guess
05:50:49 <quicksilver> > concat (replicate 5 [1,2])
05:50:50 <lambdabot>  [1,2,1,2,1,2,1,2,1,2]
05:50:53 <quicksilver> easily done
05:50:57 <Cale> > replicateM 5 [1,2]
05:50:58 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,2,1],[1,1,1,2,2],[1,1,2,1,1],[1,1,2,1,2],[1,...
05:51:01 <faxathisia> > cycle [1.2]
05:51:01 <lambdabot>  [1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2,1.2...
05:51:03 <faxathisia> > cycle [1,2]
05:51:04 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
05:53:18 <Cale> > map (foldl (\xs x -> 2*xs + x) 0) . replicateM 5 $ [0,1]
05:53:19 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:53:52 <Cale> > map (foldl (\xs x -> 2*xs + x) 0) . replicateM 5 $ [0,1] :: [Expr]
05:53:53 <lambdabot>  [2 * (2 * (2 * (2 * (2 * 0 + 0) + 0) + 0) + 0) + 0,2 * (2 * (2 * (2 * (2 * 0...
05:54:00 <Cale> > map (foldl (\xs x -> 2*xs + x) 0) . replicateM 3 $ [0,1] :: [Expr]
05:54:01 <lambdabot>  [2 * (2 * (2 * 0 + 0) + 0) + 0,2 * (2 * (2 * 0 + 0) + 0) + 1,2 * (2 * (2 * 0...
05:54:12 <Cale> > map (foldl (\xs x -> 2*xs + x) 0) . replicateM 2 $ [0,1] :: [Expr]
05:54:12 <lambdabot>  [2 * (2 * 0 + 0) + 0,2 * (2 * 0 + 0) + 1,2 * (2 * 0 + 1) + 0,2 * (2 * 0 + 1)...
05:54:37 <quicksilver> Cale: I think it might be cleverer to have a separate LB command for the Expr stuff
05:54:54 <quicksilver> ~> a + b + c
05:55:01 <quicksilver> which automatically adds the type annotation.
05:55:32 <quicksilver> or perhaps a 'default Expr' is enough in that context
05:55:41 <Cale> > map (foldl (\xs x -> 2*xs + x) 0 . dropWhile (==0)) . replicateM 2 $ [0,1] :: [Expr]
05:55:42 <lambdabot>  [0,2 * 0 + 1,2 * (2 * 0 + 1) + 0,2 * (2 * 0 + 1) + 1]
05:56:01 <Cale> > map (foldl (\xs x -> 2*xs + x) 0 . dropWhile (==0)) . replicateM 3 $ [0,1] :: [Expr]
05:56:02 <lambdabot>  [0,2 * 0 + 1,2 * (2 * 0 + 1) + 0,2 * (2 * 0 + 1) + 1,2 * (2 * (2 * 0 + 1) + ...
05:56:36 <Cale> hmm...
05:56:56 <Cale> yeah, possibly a default declaration would do it
05:57:23 <matthew_-> right, what are the tools of choice for writing a pre-processor for Haskell?
05:57:29 <quicksilver> > map f [a,b,c]
05:57:29 <lambdabot>  Add a type signature
05:57:39 <quicksilver> Cale: ^^ why does that need a type signature?
05:57:47 <Cale> I'm not sure
05:57:47 <glen_quagmire> > map f [a,b,c] :: [Expr]
05:57:48 <lambdabot>  [f a,f b,f c]
05:57:50 <quicksilver> I don't understand the ambiguity there.
05:57:58 <quicksilver> surely a :: Expr is monomorphic.
05:58:01 <matthew_-> > map f [a,b,c] :: Expr
05:58:02 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
05:58:32 <pcc1> in ghci how can I :l System.Plugins ?  I get the error "module `System.Plugins' is a package module".  I've tried passing the "-package plugins" command line option
05:58:50 <glen_quagmire> pcc1: :m + System.Plugins ?
05:59:09 <pcc1> glen_quagmire: thanks
06:02:08 <pcc1> though perhaps there should be some DWIM functionality there?
06:02:46 <doserj> quicksilver: f::FromExpr a => a
06:02:53 <glen_quagmire> what is diwim?
06:02:59 <pcc1> do what I mean
06:03:54 <glen_quagmire> i 'm not sure if i understood
06:04:30 <pcc1> i.e. if the user enters ":l foo" for package module foo, this is automatically converted to ":m + foo"
06:05:21 <quicksilver> doserj: oh
06:05:42 <glen_quagmire> i thought :l is load a file. :m is to set context for evaluation
06:05:58 <doserj> quicksilver: f can have arbitrary many arguments
06:06:02 <glen_quagmire> oh i see. they are the same semantically
06:06:06 <pcc1> yes
06:06:29 <shapr> @yow !
06:06:29 <lambdabot> Yow!  Are we wet yet?
06:06:30 <doserj> instance (Show a, FromExpr b) => FromExpr (a -> b) where ...
06:06:40 <shapr> Today, I am an instance of Arbitrary.
06:07:07 <Syzygy-> Has anyone actually done anything with the OpenAL-package?
06:07:15 <Syzygy-> And ... how do I use it?
06:07:28 <shapr> Syzygy-: I've never heard of anything real done with the OpenAL lib.
06:07:51 <Syzygy-> shapr: Anything at all? Is there even a sample "produce a beep" program anywhere?
06:08:05 <shapr> I thought that sort of thing came with the OpenAL sources?
06:08:15 <doserj> > map f [a,b,c] :: [Expr -> Expr] -- would work if lambdabot could show the result
06:08:15 <lambdabot>   add an instance declaration for (Typeable Expr)
06:08:18 <Syzygy-> They may do ... haven't checked -that - much. :)
06:08:22 <shapr> I have a vague memory that OpenGL and OpenAL were done by the same guy, but I'm not sure.
06:08:37 <quicksilver> doserj: yes, I understand.
06:10:10 <ivan_> hi, how do i check a monadic type if i transform monads? is there any command in ghci like :t for functions
06:12:09 <shapr> I don't understand the question. Monad transformers should work with :t ?
06:16:20 <Cale> ivan_: Perhaps you want :kind ?
06:16:22 <quicksilver> :k StateT
06:16:22 <lambdabot> * -> (* -> *) -> * -> *
06:16:23 <quicksilver> ?
06:16:35 <quicksilver> :t runStateT
06:16:35 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
06:16:55 <quicksilver> the 'runFooT' types are somewhat enlightening
06:17:04 <quicksilver> :t StateT
06:17:04 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
06:17:15 <quicksilver> (StateT is a constructor as well as a type constructor)
06:17:37 * shepheb thought he's read something about  complex kinds like * -> (* -> *) -> * -> * being intractable/not allowed?
06:18:07 <Cale> shepheb: That wouldn't have been about Haskell then :)
06:18:51 <shepheb> Cale: fair enough. is there any restriction on the complexity of kinds? maybe it was that we don't consider kinds-of-kinds.
06:19:31 <Cale> Well, at least in Haskell 98, all kinds are built from * and ->
06:19:48 <Cale> GHC introduces a few more kinds for unboxed types.
06:20:06 <Cale> and that's about it
06:20:21 <shepheb> Cale: maybe that was it. that the only kind variable was *, that being the kind of all Haskell types.
06:20:37 <Cale> * isn't even a kind variable really
06:21:08 <Cale> Well, it's not forall'd anyway :)
06:22:03 <shepheb> Cale: I'm going to stop now. Kinds still throw me off. thanks for chipping away a little at my misunderstandings.
06:22:30 <Cale> shepheb: There's not much to them. They just tell you how type constructors are meant to be applied
06:22:39 <Cale> :k Maybe
06:22:41 <lambdabot> * -> *
06:22:45 <Cale> :k Maybe Integer
06:22:46 <quicksilver> yeah. THey just show you the shape of type constructors.
06:22:46 <lambdabot> *
06:22:51 <quicksilver> :k Either
06:22:51 <lambdabot> * -> * -> *
06:23:05 <Cale> :k ReaderT
06:23:06 <lambdabot> * -> (* -> *) -> * -> *
06:23:12 <Cale> :k ReaderT Integer Maybe
06:23:12 <lambdabot> * -> *
06:23:25 <Cale> :k ReaderT Integer Maybe Char
06:23:25 <lambdabot> *
06:23:28 * shepheb begins to see.
06:24:39 <Cale> So in some sense, they're the types at the type level, but it's quite boring because the type system is so much simpler in that regard than the value system in Haskell.
06:24:42 <quicksilver> the main slightly controversial thing haskell allows to passing 'unapplied' type constructors to types
06:24:50 <quicksilver> I.e. that use of 'Maybe' there
06:25:01 <quicksilver> you can actually pass 'Maybe' which isn't a type, it's a * -> *
06:25:04 <quicksilver> to ReaderT
06:26:10 <Baughn> @ty replicateM
06:26:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
06:26:20 <shepheb> quicksilver: would "ask" then produce a constructor, to which you would supply a type to get a proper Maybe type? or can you not work with it like that?
06:27:04 <Cale> ask is a value, it has a type, its type has kind *
06:27:14 <Cale> (the type of any value has kind *)
06:27:41 <ivan_> Cale: but what if i have a type somethin = ErrorT e (StateT r IO) a, how do i check the final function?
06:28:00 <Cin> http://www.haskell.org/cabal/hackage/
06:28:00 <lambdabot> Title: Hackage
06:28:02 <Cale> ivan_: I'm not certain what you mean by that...
06:28:06 <Cin> anyone know that's the first link on google for "hackage"?
06:28:09 <Cale> @unmtl ErrorT e (StateT r IO) a
06:28:09 <lambdabot> r -> IO (Either e a, r)
06:28:14 <Cale> Is that what you mean?
06:28:19 <shepheb> Cale: so is ReaderT Integer Maybe actually workable? quicksilver implied haskell would allow it, but I can't see how to work with a partially applied constructor.
06:28:57 <shepheb> Cale: I suppose it could be newtyped? newtype MaybeReader = ReaderT Integer Maybe, and then MaybeReader String in the code?
06:29:03 <Cale> shepheb: Well, there are no values of ReaderT Integer Maybe. Trying to say that some value has that type is a kind error.
06:29:18 <Cale> But there are, for example, values of type ReaderT Integer Maybe String
06:29:25 <Cale> :kind ReaderT Integer Maybe String
06:29:32 <Cale> :k ReaderT Integer Maybe String
06:29:35 <lambdabot> *
06:29:37 <quicksilver> "ReaderT Integer Maybe" is the right kind to be made an instance of monad, though.
06:29:39 <Cale> :k (ReaderT Integer Maybe) String
06:29:40 <lambdabot> *
06:29:40 <quicksilver> and functor
06:29:46 <quicksilver> and indeed, it is both of those things.
06:29:53 <Cale> :k StateT String (ReaderT Integer Maybe) String
06:29:54 <lambdabot> *
06:30:15 <quicksilver> ivan_: what do you mean by 'final function' ?
06:30:24 <shepheb> Cale: is that "pointfree" newtype allowed, out of curiousity?
06:30:29 <Cale> shepheb: I don't think so.
06:30:43 <quicksilver> I think there might be a ghc extension which permits it.
06:30:55 <Cale> You can do it with type, I think, but not newtype.
06:30:59 <Twey> Pointfree types?
06:31:01 <Cale> (in ghc)
06:31:04 <quicksilver> hmm. Yes, of course.
06:31:11 <Twey> How does that work unambiguously?
06:31:33 <Cale> Twey: type Foo = Maybe is equivalent to type Foo a = Maybe a
06:31:43 <shepheb> Twey: well, you couldn't use the type without specifying the final argument and "fully applying" it.
06:32:03 <Twey> Oh, of course, because there's only one possible value for a type synonym
06:32:09 <Twey> I was thinking of 'data'
06:32:30 <shepheb> :t StateT
06:32:30 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
06:32:49 <Cale> Heh, that's the type of the data constructor
06:32:54 <Cale> :k StateT
06:32:55 <lambdabot> * -> (* -> *) -> * -> *
06:33:03 <shepheb> Cale: yes, I'm trying to figure out your StateT example.
06:33:24 <Cale> My StateT example is at the type level, so what you want is the kind.
06:33:30 <shepheb> m :: * -> * forces m to be a constructor, correct?
06:33:34 <Cale> yeah
06:34:45 <shepheb> like, say, ReaderT Integer Maybe. I don't think I've ever felt the actual sensation of /learning/ until I started with Haskel..
06:38:00 <Cale> That's an interesting remark :)
06:38:28 <quicksilver> @remember shepheb I don't think I've ever felt the actual sensation of /learning/ until I started with Haskell...
06:38:28 <lambdabot> Okay.
06:39:05 <daf> it reminds me what it was like to learn programming for the first time
06:39:20 <Cin> heh.. i got hs-plugins to install by i had to change (STArray _ _ arr#) to (STArray _ _ _ arr#) in FastString.hs O_O
06:39:41 <shepheb> quicksilver: now my typo is immortalized. ah well.
06:40:20 <quicksilver> shepheb: I thought I fixed the typo?
06:40:37 <quicksilver> or was there more than one?
06:41:13 <shepheb> quicksilver: oh, I just saw multiple periods. thank you, it's fixed.
06:42:40 <shepheb> when I learned something in Perl, it was characterized by the realization that you know even less as a percentage of the whole than you did before. You now saw the fuller depth and breadth of the language.
06:42:52 <faxathisia> dolio, hey?
06:43:09 <dolio> Yeah?
06:43:23 <shepheb> Haskell is different. learning seems to be characterized by going into a tight mental loop as you process the implications of the new information.
06:44:08 <hpaste>  faxathisia pasted "Some Data.List theorems" at http://hpaste.org/5794
06:44:18 <shepheb> and you now see the fuller depth of its beauty.
06:44:33 <faxathisia> dolio, just added to the end of you're Data.List file, http://hpaste.org/5794/0/plain
06:45:07 <faxathisia> a couple identities about ++ and folds proved with induction
06:46:45 <dolio> The unit and associativity ones should be in Algebra.Monoid if I'm not mistaken.
06:46:54 <dolio> Since those are the laws a monoid has to satisfy.
06:47:27 <dolio> That's why Data.List doesn't have ++, actually.
06:48:05 <faxathisia> ahh didn't see that before
06:48:45 <dolio> Of course, that's no good for proving the other stuff that uses ++, since it'd lead to cyclic dependencies.
06:49:14 <Baughn> quicksilver: Amusingly, ghc's rts seems to treat printing a newline as an *excellent* time to switch threads. So if a lot of threads print start at the same time, by printing a line, all the lines will end up on the same line, with newlines to follow..
06:49:36 <Baughn> I can't help but think that perhaps it should switch *after* printing the \n
06:49:59 <BMeph> o.O
06:50:48 <quicksilver> Baughn: heh ;)
06:51:03 <olsner> hmm... or perhaps your I/O needs more synchronization?
06:51:05 <quicksilver> I take your point but I think you probably should rely on when context switches occur anyway :)
06:51:07 <dolio> Maybe I'll add a separate Data.List.Proofs or something. They do that sort of thing in the Agda standard library.
06:51:14 <quicksilver> *n't
06:51:20 <Baughn> olsner: Perhaps, yes. :P
06:51:27 <faxathisia> I've got to check out this library
06:51:53 <dolio> faxathisia: The equational reasoning module is pretty amazing.
06:51:58 <quicksilver> I recommend pushing everything through a Chan
06:52:04 <Cin> anyone been able to get hs-plugins to compile on 6.8.2?
06:52:06 <quicksilver> Chan String, probably.
06:52:09 <Baughn> olsner: But it's basically debugging output that, except at the startup, occurs perhaps once per hour
06:52:36 <glen_quagmire> i can't use do block in where clause for an outer do block?
06:52:42 <Baughn> quicksilver: Don't be so.. sane.
06:52:48 <dolio> faxathisia: It lets you write things like: 'begin term1 =< law 1 > term2 =< law2 > term3 qed'
06:53:06 <glen_quagmire> parseIdent = Parsec.try parseOp <|> parseName where parseOp ...
06:53:16 <dolio> With fancier looking unicode operators, of course.
06:55:03 <nominolo> @hoogle Functor f => f a -> (a -> b) -> f b
06:55:05 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
06:55:05 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
06:55:05 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
06:55:16 <nominolo> yeah
06:55:29 <nominolo> :t flip fmap
06:55:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
06:55:43 <nominolo> :t for
06:55:45 <lambdabot> Not in scope: `for'
06:55:46 <faxathisia> dolio, I just started reading The Algebra of Programming, This is just like it
06:56:00 <faxathisia> You could almost write the proofs in the book directly in Agda :D
06:56:03 <yondalf_> @hoogle divmod
06:56:03 <lambdabot> Prelude.divMod :: Integral a => a -> a -> (a, a)
06:56:03 <lambdabot> Data.Fixed.divMod' :: (Real a, Integral b) => a -> a -> (b, a)
06:56:11 <dolio> Nice.
06:56:29 <yondalf_> indeed
06:56:45 <faxathisia> It would be cool to make a Agda2ish syntax frontend for haskell
06:57:12 <wli> I've yet to see agda.
06:57:54 <faxathisia> It's like haskell but you can define N-ary-infix operators
06:58:12 <olsner> eh? how does that work?
06:58:18 <faxathisia> (syntaxwise, but it's quite different semantically)
06:58:19 <wli> And it uses fancy unicode operators?
06:58:35 <dolio> Anything can be an operator, essentially.
06:58:45 <faxathisia> like if_then_else_ :: forall {a} -> Bool -> a -> a -> a
06:58:56 <faxathisia> if True then x else y = x
06:59:08 <dolio> Whether something is an operator or a prefix function depends on its definition rather than the characters that make it up.
06:59:23 <yondalf_> @hoogle max
06:59:24 <lambdabot> Prelude.max :: Ord a => a -> a -> a
06:59:24 <lambdabot> Data.Ord.max :: Ord a => a -> a -> a
06:59:24 <lambdabot> Prelude.maxBound :: Bounded a => a
06:59:29 <quicksilver> which has pros and cons, definitely.
06:59:35 <quicksilver> it makes it easier to make cool DSL-like things.
06:59:46 <olsner> that looks kind of like ObjC/Smalltalk
06:59:47 <quicksilver> but it makes it harder to read unfamiliar code
06:59:55 <faxathisia> yeah, you can't write (x:) for example
06:59:56 <nominolo> @djinn Map Int (Set Char) -> Set (Int, Char)
06:59:57 <lambdabot> -- f cannot be realized.
06:59:58 <quicksilver> where 'read' includes 'mentally parse'
07:00:12 <wli> No sections?
07:00:27 <faxathisia> What exactly are sections?
07:00:38 <wli> Partially applied infix operators.
07:00:53 <Baughn> @ty (+)
07:00:53 <lambdabot> forall a. (Num a) => a -> a -> a
07:00:54 <quicksilver> like (x:)
07:00:55 <wli> (1+), (2^), (^2), (*3), etc.
07:01:04 <faxathisia> you can partially apply them but there's no syntax for it
07:01:15 <faxathisia> you write (\x -> 2^x)
07:01:22 <Baughn> faxathisia: Notice the type. "Function taking Num returning (function taking Num that returns Num)"
07:01:23 <wli> \x -> 2^x sure
07:01:38 <wli> faxathisia: Unicode lambda I presume?
07:01:50 <Baughn> ..although, inconveniently for that typing, you can apply the arguments in any order
07:01:57 <faxathisia> wli, It uses \ to stay close to haskell
07:02:02 <wli> Okay.
07:02:23 <quicksilver> I think losing sections is a bit sad.
07:02:24 <faxathisia> It means you can use unicode lambda for an embedding of whatever calculus
07:02:31 <quicksilver> sections turn out to be amazingly useful.
07:02:52 <faxathisia> I'd love a way to combine mixfix and sections
07:03:09 <faxathisia> If I knew how to do it I think I'd write a parser in parsec and try it as a frontend for haskell
07:03:12 <quicksilver> > map ($4) [(+1),(*4),(/10)]
07:03:15 <lambdabot>  [5.0,16.0,0.4]
07:03:28 <quicksilver> is the answer to a FAQ here
07:03:40 <shepheb> couldn't it be done with some clever sugar, as long as you partially applied to a prefix (or suffix, maybe) of the argument list?
07:04:32 <Saul_> > let fix f = f (fix f) in fix f
07:04:33 <lambdabot>  Add a type signature
07:04:41 * EvilTerran wants the section syntax to be expanded to always be a syntax-tree splice-in, and work for all operator precednces
07:04:54 <EvilTerran> so (x ++ y ++) z = x ++ (y ++ z)
07:05:02 <EvilTerran> also, (++ x ++) could work
07:05:09 <faxathisia> Evil terrain :O
07:05:26 <idnar> heh
07:05:32 <olsner> I like where you're going with these ideas
07:05:35 <faxathisia> f = (++ x ++)
07:05:40 <faxathisia> a f b ?
07:05:47 <EvilTerran> ?
07:05:51 <Saul_> a `f` b then
07:06:15 <faxathisia> let f = (++ x ++) in {- lets you write -} [foo] f [bar] -- ?
07:06:20 <EvilTerran> (* x +) y z = y * x + z
07:06:47 <EvilTerran> oh, no. (++ x ++) would just be a 2-ary function, like (++)
07:07:52 <EvilTerran> but a two-ended section like that would only work if sections were syntax tree splicing
07:08:17 <Saul_> I like the idea
07:08:24 <Saul_> Maybe suggest it for Haskell'
07:08:30 <EvilTerran> ie, (EXP1 ?) EXP2 desugaring to EXP1 ? (EXP2)
07:08:33 <vincenz> Bad idea
07:08:36 <EvilTerran> rather than (?) (EXP1) (EXP2)
07:08:49 <glen_quagmire> in parsec, sign <- try (string "-"); num <- many1 digit;   .. it failes when I pass "1"  but "-1" is accepted
07:09:13 <EvilTerran> glen_quagmire, maybe "option (string "-")"?
07:09:51 <EvilTerran> "(option x p) tries to apply parser p. If p fails without consuming input, it returns the value x, otherwise the value returned by p."
07:10:10 <EvilTerran> try (...) fails if (...) fails, it just does so without munching anything
07:10:19 <EvilTerran> vincenz, care to elaborate?
07:10:46 <glen_quagmire> P.try (P.option "" (P.string "-"))
07:10:56 <vincenz> EvilTerran: I don't like the implicit ordering or arguments
07:11:01 <vincenz> it's a hack
07:11:03 <glen_quagmire> thank you EvilTerran
07:11:03 <vincenz> seriously
07:11:08 <vincenz> \y z -> y ++ x ++ z
07:11:15 <EvilTerran> vincenz, how? it's no different from (++) in that regard
07:11:17 <glen_quagmire> vincenz: did you release sourcecode for miniML ?
07:11:20 <EvilTerran> first goes on the left, second on the right
07:11:29 <EvilTerran> glen_quagmire, :)
07:11:48 <droundy> @tell JaffaCake I'd like to chat with you about the darcs bug I've got going, which seems highly resistant to debugging... the one that involves System.Process.runProcess.
07:11:48 <lambdabot> Consider it noted.
07:11:58 <vincenz> glen_quagmire: hmm, no?
07:12:13 <EvilTerran> glen_quagmire, alternatively, (P.char '-' <|> P.char '+' <|> return '+'), or something like that
07:12:21 <vincenz> glen_quagmire: Why/
07:12:27 <glen_quagmire> i was just curious after seeing your type checking blog, vincenz
07:13:22 <glen_quagmire> now i can parse and evaluate "+ 1 2"  and "+ -1 2"
07:14:50 <Cin> :t STArray
07:14:52 <lambdabot> Not in scope: data constructor `STArray'
07:19:59 <Cin> can't get bloody hs-plugins to compile on ghc 6.8.2! for some reason the STArray type has changed from three arguments to its constructer to four, but i can't find what its new type is! D: !!!
07:20:17 <Cin> i refuse to use ghc6.6 (which does compile) -__
07:21:38 <quicksilver> Cale got it compiling with 6.8.x, I believe
07:21:48 <quicksilver> are you using the darcs version of hs-plugins?
07:21:55 <Cin> :t GHC.Arr.STArray
07:21:57 <lambdabot> forall i s e. i -> i -> Int -> GHC.Prim.MutableArray# s e -> GHC.Arr.STArray s i e
07:21:59 <Cin> quicksilver: no, but i'll try that
07:22:34 <Cale> Yeah, make sure you use the one on code.haskell.org
07:22:35 <Cin> http://darcs.haskell.org/~lemmih/hs-plugins/
07:22:36 <Cin> this one?
07:22:36 <lambdabot> Title: Index of /~lemmih/hs-plugins
07:22:39 <Cale> no
07:22:39 <Cin> ah, okay
07:23:16 <Cin> http://code.haskell.org/~dons/code/hs-plugins/  <-- this one :D
07:23:17 <lambdabot> Title: Index of /~dons/code/hs-plugins
07:23:19 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
07:23:20 <lambdabot> Title: Index of /~dons/code/hs-plugins
07:23:21 <Cale> yes
07:23:54 <Cale> I ripped half the code out and replaced it with calls into the GHC API.
07:24:14 <Cin> is that good? :P
07:24:32 <Cin> faster?
07:24:36 <Cale> Well, it shouldn't break on every GHC release now, I think.
07:24:50 <Cin> ahhhh
07:24:59 <Cale> (This was fun though, given that I know basically nothing about hs-plugins, or the GHC API.)
07:25:04 <Cin> excellente`
07:25:09 <Cin> hehe
07:25:14 <Cale> I just used the type system to figure out where things should go.
07:25:21 <Cin> that's cool
07:25:57 <Cin> i also get the error with the darcs one
07:25:59 <Cin> Constructor `STArray' should have 4 arguments, but has been given 3
07:26:04 <Cin> hrm
07:26:08 <Cin> did you get this one?
07:26:38 <Cale> Yes, I did. The error is in the Language.Hi.something
07:26:47 <Cale> I completely removed Language.Hi
07:27:06 <Cale> Or whatever it was :)
07:27:13 <Cin> indeed, Language.Hi.FastString
07:29:22 <Cale> I believe it's a parser for the binary interface files generated by GHC. The syntax of those files changes with every major release, which used to force constant maintenance.
07:31:14 <Cale> There's a lot more code in hs-plugins which could probably be replaced as well, but I didn't do that.
07:31:14 <Cin> oh i see
07:33:21 <Cin> i'm pondering over writing/modding a simple httpd which receives "foo.cgi" files and loads "foo.o" or compiles "foo.h" then loads "foo.o", and then the code in foo.o gets run with some monad containing session data or whatnot
07:33:51 <EvilRanter> oopsie
07:33:59 <Cin> the httpd would be talked to from behind lighttpd or apache or whatnot
07:35:06 <byorgey> EvilRanter: ?
07:35:31 <EvilRanter> closing the pidgin buddy list apparently closes pidgin entirely, without even asking
07:35:47 <byorgey> hehe
07:36:45 <Cale> I've never used pidgin for IRC.
07:36:49 <EvilRanter> but now i've remembered how to hide it without it closing everything; apparently this requires use of the notification area
07:37:02 <EvilRanter> i wouldn't, but it's all that's on the lab's computers
07:37:16 <quicksilver> ssh + irssi + screen = win
07:37:18 <vincenz> Cale: it suxors
07:37:26 <vincenz> quicksilver: ageed
07:37:54 <EvilRanter> my own comp is a wintendo, unfortunately
07:38:24 * EvilRanter pokes EvilTerran
07:38:32 <quicksilver> that's easy to remedy
07:38:44 <EvilRanter> not if i want to still be able to play all my games on it
07:39:02 <wolverian> dualboot or wubi
07:39:19 <wolverian> the next ubuntu release will officially include a wubi install method, incidentally
07:39:24 <sebell> Emacs + RCIRC = chat
07:39:38 <EvilRanter> it's got fedora on it, but i very rarely boot into it. and i don't really like ubuntu. :P
07:40:37 <gbacon> shouldn't my dzen status bar stay visible with xmonad?
07:41:18 <allbery_b> gbacon: mod-b?
07:42:13 <shepheb> gbacon: set defaultGaps in your xmonad.hs to leave space for your dzen.
07:42:41 <gbacon> allbery_b: I don't see any effect from mod-b (or any mention of it in the intro)
07:42:41 <olsner> Couldn't match expected type `GHC.Prim.Any' -- adding a type signature fixes it, but why the impossible error message?
07:42:57 <faxathisia> what kind of morphism is map?
07:43:10 <vincenz> faxathisia: hylo?
07:44:05 <allbery_b> then you need defaultGaps, I think.  (mod-b toggles the gap from defaultGaps.  it's supposed to be obsolete, except I think dzen is too simplistic to use struts so the EWMH stuff doesn't work with it)
07:45:26 <ejt> I just set up xmonad/dzen today, and I had to set defaultGaps to get it to work
07:45:33 <Cin> cale: do you have your hs-plugins in a darcs repo anywhere?
07:45:52 <Cale> Cin: that is a darcs repo
07:46:10 <Cin> cale: doesn't appear to be the one you modified
07:46:14 <Cale> (i.e. http://code.haskell.org/~dons/code/hs-plugins/)
07:46:15 <lambdabot> Title: Index of /~dons/code/hs-plugins
07:46:18 <gbacon> shepheb, allbery_b: thanks
07:46:26 <Cale> It certainly is.
07:46:56 <Cale> Make sure that you have no src/Language directory. If you do, then you somehow managed to get the URL wrong or something :)
07:46:58 * Cin re-gets...
07:47:42 <Cin> ah, there we are
07:47:49 <Cin> just System :)
07:48:48 <faxathisia> so for example, (a -> b) -> Either a -> Either b is a hylomorphim for Either?
07:48:58 <faxathisia> *is the type of the
07:49:16 <Cin> cale: built!
07:49:27 <Cale> great
07:50:29 <resiak> it would be so much easier to call hylomorphisms 'maps'
07:51:01 <Syzygy-> resiak: Because 'maps' is not an overloaded word.
07:51:30 <resiak> Syzygy-: 'fmaps' if you like :)
07:51:47 <Syzygy-> That would be slightly less bad, yeah.
07:51:57 <faxathisia> Is it the correct term though?
07:52:01 <Cale> faxathisia: kind error
07:52:11 <faxathisia> oops :S
07:52:32 <faxathisia> I really meant, (a -> b) -> Just a -> Just b
07:52:57 <Cale> (a -> b) -> Maybe a -> Maybe b ?
07:53:15 <faxathisia> Yeah (what's wrong with me today ..)
07:53:18 <Syzygy-> :t fmap
07:53:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:53:29 <gnuvince> @hoogle (a -> b) -> Maybe a -> Maybe b
07:53:31 <lambdabot> No matches, try a more general search
07:53:35 <Syzygy-> So, since Maybe is a functor, fmap does it.
07:53:43 <Syzygy-> > fmap (+3) (Just 2)
07:53:44 <faxathisia> for either .. it's a little tricky
07:53:45 <Cale> A hylomorphism is the composition of an anamorphism (unfold) with a catamorphism (fold)
07:53:46 <lambdabot>  Just 5
07:53:50 <Syzygy-> > fmap (+3) Nothing
07:53:51 <lambdabot>  Nothing
07:54:01 <Syzygy-> fmap (+3) (Left 3)
07:54:03 <Cale> Er, the cata follows the ana
07:54:08 <Syzygy-> > fmap (+3) (Left 3)
07:54:10 <lambdabot>  Left 3
07:54:10 <Syzygy-> Hrm.
07:54:14 <faxathisia> I guess you have, (a -> x) -> (b -> y) -> Either a b -> Either x y
07:54:22 <Syzygy-> > fmap (+3) (Right "Nope")
07:54:23 <lambdabot>   add an instance declaration for (Num [Char])
07:55:12 <Saul_> faxathisia: I think the fmap actually is (a -> b) -> Either e a -> Either e b
07:55:32 <Syzygy-> > fmap (+3) (Right 2)
07:55:34 <lambdabot>  Right 5
07:55:36 <Saul_> But yours might be useful in various cases
07:55:43 <Syzygy-> Saul_: It obviously isn't.
07:56:10 <Saul_> > fmap (+3) (Left 2)
07:56:11 <lambdabot>  Left 2
07:56:18 <Syzygy-> Oh...
07:56:21 <faxathisia> :t fmap (Either a b)
07:56:22 <lambdabot> Not in scope: data constructor `Either'
07:56:22 <lambdabot> Not in scope: `a'
07:56:22 <lambdabot> Not in scope: `b'
07:56:23 <Syzygy-> I didn't read my results.
07:56:26 <Syzygy-> *hrm*
07:56:45 <resiak> :t fmap (Left 3)
07:56:48 <Beelsebob_> @seen amonre
07:56:48 <lambdabot> I haven't seen amonre.
07:56:49 <lambdabot>     Couldn't match expected type `a -> b'
07:56:49 <lambdabot>            against inferred type `Either t b1'
07:56:49 <lambdabot>     In the first argument of `fmap', namely `(Left 3)'
07:57:02 <resiak> :t flip fmap (Left 3)
07:57:03 <lambdabot> forall a b t. (Num t) => (a -> b) -> Either t b
07:57:05 <Cale> The general hylomorphism for Maybe seems a little silly.
07:57:11 <faxathisia> :t let f = fmap (+) in f :: Either a b -> _
07:57:11 <lambdabot> parse error on input `_'
07:57:19 <faxathisia> :t let f = fmap (+) in f :: Either ?a ?b -> ?x
07:57:20 <lambdabot> parse error on input `?a'
07:57:25 <faxathisia> :t let f = fmap (+1) in f :: Either ?a ?b -> ?x
07:57:26 <lambdabot> parse error on input `?a'
07:57:40 <faxathisia> :t let f = fmap (+1) in f :: (Either ?a ?b) -> ?x
07:57:41 <lambdabot> parse error on input `?a'
07:57:43 <Syzygy-> So ....
07:57:49 <resiak> > fmap f (Left x)
07:57:50 <Syzygy-> fmap (+3) (Left "Nope")
07:57:50 <lambdabot>  Add a type signature
07:57:53 <Syzygy-> > fmap (+3) (Left "Nope")
07:57:54 <lambdabot>  Left "Nope"
07:58:01 <resiak> > fmap f (Left x) :: Expr
07:58:01 <lambdabot>  Couldn't match expected type `Expr'
07:58:01 <Syzygy-> > fmap (+3) (Right 3)
07:58:03 <lambdabot>  Right 6
07:58:08 <resiak> darn.
07:58:10 <Syzygy-> Saul_: You seem to be quite right.
07:58:13 <faxathisia> @src Functor (Either a b)
07:58:13 <lambdabot> Source not found. I feel much better now.
07:58:38 <Saul_> Syzygy-: Yup :)
07:58:45 <doserj> @src Either fmap
07:58:45 <lambdabot> fmap _ (Left x) = Left x
07:58:45 <lambdabot> fmap f (Right y) = Right (f y)
07:59:01 <faxathisia> ok so fmap's not what I'm interested in anyway
07:59:09 <faxathisia> ?Djinn (a -> x) -> (b -> y) -> Either a b -> Either x y
07:59:09 <lambdabot> f a b c =
07:59:09 <lambdabot>     case c of
07:59:09 <lambdabot>     Left d -> Left (a d)
07:59:09 <lambdabot>     Right e -> Right (b e)
07:59:11 <faxathisia> That is
07:59:56 <faxathisia> a function like that should exist for every data type I think
08:00:16 <faxathisia> certainly for [a], Maybe a, Either a b..
08:00:25 <doserj> you want either
08:00:27 <ski_> that's a functor map
08:00:33 <doserj> @type either
08:00:37 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:00:44 <Syzygy-> ?hoogle Either a b -> Either b a
08:00:45 <lambdabot> No matches, try a more general search
08:00:47 <faxathisia> what is the functor?
08:00:53 <ski_> `Either'
08:01:06 <faxathisia> It's not fmap though, so what's changed?
08:01:09 <Cale> @djinn hyloMaybe :: b -> (a -> b) -> (c -> Bool) -> (c -> a) -> c -> b
08:01:10 <lambdabot> Cannot parse command
08:01:10 <ski_> (a `bifunctor' .. here curried)
08:01:12 <Syzygy-> faxathisia: Isn't either something like you'd want?
08:01:16 <Cale> @djinn b -> (a -> b) -> (c -> Bool) -> (c -> a) -> c -> b
08:01:16 <lambdabot> f a b c d e =
08:01:16 <lambdabot>     case c e of
08:01:16 <lambdabot>     False -> b (d e)
08:01:16 <lambdabot>     True -> a
08:01:17 <Syzygy-> Hrm ... sorry. I'm late.
08:01:37 <Syzygy-> Is there a twist function Either a b -> Either b a defined?
08:01:41 <faxathisia> Syzygy-: I'm trying to find a name for the class a functions
08:01:42 * shapr is late to #haskell
08:02:05 <Cale> You wanted a hylomorphism for Either?
08:02:50 * shapr reads http://en.wikipedia.org/wiki/Hylomorphism_%28computer_science%29
08:02:51 <lambdabot> Title: Hylomorphism (computer science) - Wikipedia, the free encyclopedia
08:03:07 <faxathisia> I read that .. and also http://en.wikipedia.org/wiki/Hylomorphism
08:03:08 <lambdabot> Title: Hylomorphism - Wikipedia, the free encyclopedia
08:03:20 <faxathisia> but I still have no clue what a Hylomorphism is..
08:03:27 <Cale> So the anamorphism would take a function a -> Bool, and two functions a -> b and a -> c, and produce a function a -> Either b c
08:03:36 <Cale> The catamorphism we all know is either
08:03:38 <Cale> :t either
08:03:39 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
08:03:54 <Cale> So the hylomorphism looks like:
08:04:07 <shapr> faxathisia: " hylomorphism is a recursive function, corresponding to the composition of an anamorphism (which first builds a set of results; also known as 'unfolding') and a catamorphism (which then folds these results into a final return value)." from that wikipedia article. Doesn't help?
08:04:13 <hpaste>  K0MPR3SS0R pasted "assingment2" at http://hpaste.org/5795
08:04:19 <ski_> Cale : and the anamorphism for `Bool' ?
08:04:21 <K0MPR3SS0R> ok
08:04:25 <K0MPR3SS0R> im having a little trouble here
08:04:33 <K0MPR3SS0R> trying to handle a list of strings
08:04:59 <K0MPR3SS0R> each string to be read one at a time and passed to function build
08:05:20 <K0MPR3SS0R> where it will reverse it and enter it as a binary tree using build2 and ins functions
08:05:28 <Cale> :t let mkEither p u v x = if p x then Left (u x) else Right (v x); hylo p u v l r = either l r . mkEither p u v in hylo
08:05:30 <lambdabot> forall a a1 b c. (a -> Bool) -> (a -> a1) -> (a -> b) -> (a1 -> c) -> (b -> c) -> a -> c
08:05:35 <K0MPR3SS0R> a single string works fine, but a list of string im having trouble
08:06:08 <Cale> K0MPR3SS0R: Perhaps some kind of folding over the list of strings?
08:06:19 <K0MPR3SS0R> folding?
08:06:28 <Cale> > foldr f z [1..5]
08:06:31 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
08:06:53 <Cale> Think of f here as being your function which adds a string to the tree
08:06:54 <K0MPR3SS0R> i dont think im allowed to use that function for this assignment
08:07:04 * doserj suspects that Cale was waiting for that opportunity
08:07:04 <Cale> and z as an initial, empty tree.
08:07:22 <shapr> Rewriting example pounce!
08:07:27 <Cale> K0MPR3SS0R: Well, you can write it recursively, for sure.
08:07:30 <faxathisia> :t let mkEither p u v x = if p x then Left (u x) else Right (v x); hylo p u v l r = either l r . mkEither p u v in hylo undefined (undefined :: Either a b -> z) (undefined :: Either c d -> z) Left Right
08:07:31 <lambdabot> forall a b z b1. Either a b -> Either z b1
08:07:36 <K0MPR3SS0R> sure and thats what im looking for
08:07:48 <K0MPR3SS0R> were supposed to use the minimum amount of predefined haskell functions
08:07:53 <K0MPR3SS0R> just to make a little harder
08:08:04 <Cale> K0MPR3SS0R: You might want to define your own fold
08:08:41 <Cale> Have you looked at simple things like adding up a list of numbers?
08:08:51 <Cale> It's essentially the same pattern there as you want here.
08:08:52 <K0MPR3SS0R> yes
08:09:14 <K0MPR3SS0R> ok ill have another look and see how I can use this
08:09:22 <Cale> So steal your code for sum, and replace + in it with the function that adds a string to a tree.
08:09:27 <Cale> and replace 0 with an empty tree
08:09:41 <Cale> and you'll have a function which does just what you want :)
08:09:53 <K0MPR3SS0R> lol, aint that a tad bit of plagarism
08:10:04 <K0MPR3SS0R> ohh well cant split hairs in two
08:10:12 <K0MPR3SS0R> i guess its a very basic function
08:10:21 <K0MPR3SS0R> thanks a lot!
08:10:32 <Cale> If that's considered plagiarism, you wouldn't be allowed to write very many programs :)
08:10:33 <smg> what's better? using | for alternatives or using else if?
08:10:36 <K0MPR3SS0R> ill try it out and let you know if I have anymore problems
08:10:49 <Cale> smg: If you have lots of alternatives, | is nicer.
08:11:04 <smg> Cale: okay :)
08:11:12 <Cale> K0MPR3SS0R: I have a limited understanding of your situation, but that sounds like what you want, anyway :)
08:11:14 <smg> maybe case of?
08:11:20 <smg> but it doesn't really matter does it?
08:11:23 <Cale> smg: you can write:
08:11:28 <Cale> case () of _ | ...
08:11:40 <Cale> To sneakily introduce guards if you want :)
08:11:52 <smg> i will need to read about "guards"
08:12:02 <olsner> doesn't that need the LANGUAGE PatternGuards extension?
08:12:07 <Cale> olsner: no
08:12:24 <Cale> smg: guards are those | things we're talking about
08:12:33 <Cale> f n | n < 0 = ...
08:12:39 <Cale>     | n == 0 = ...
08:12:43 <Cale>     | n > 0 = ...
08:13:40 <Cale> Each guard is tried in turn, and the first one to succeed wins, and the result of the function application is the corresponding right-hand side.
08:14:31 <smg> Caelum: i see
08:14:36 <smg> Cale: :)
08:15:34 <Cale> You might see the value 'otherwise' showing up in guards.
08:15:37 <Cale> > otherwise
08:15:40 <lambdabot>  True
08:15:55 <Cale> It's just defined as True in the Prelude, to make code read more nicely.
08:16:32 <quicksilver> @tell kuribas your haskell-indentation doesnt' seem to grok case-guards
08:16:33 <lambdabot> Consider it noted.
08:17:13 <smg> Cale: haha!
08:17:25 <smg> Cale: nice note :]
08:18:02 <Cale> Pattern guards are an extension where guards are allowed to do additional pattern matching against the result of some function
08:18:06 <Cale> For example
08:18:30 <Cale> foo env x | Just x <- lookup x env = ...
08:18:43 <Cale> The guard would only succeed if the lookup does.
08:19:11 <Cale> er, that was a stupid reuse of x
08:19:16 <Cale> foo env x | Just v <- lookup x env = ...
08:19:47 <Cale> You could also place additional conditions on v, or do additional pattern matching, separating conditions and pattern matches with commas.
08:19:52 <Cale> foo env x | Just v <- lookup x env, v > 0 = ...
08:20:01 <eugman|college> can anyone succinctly explain why  (*2) (+2) 3 doesn't work but (*2) ((+2) 3) does?
08:20:15 <Cale> eugman|college: because function application associates to the left
08:20:24 <quicksilver> eugman|college: (*2) (+2) 3 passes (+2) as a parameter to (*2)
08:20:25 <Cale> So that means ((*2) (+2)) 3
08:20:33 <Cale> (which is a type error)
08:20:44 <quicksilver> well it demands a funky Num instance
08:20:53 <Cale> right
08:21:20 <eugman|college> ah k
08:22:19 <quicksilver> one of the annoying consequences of the Num stuff is that things which ought to be type errors instead demand weird Num instances.
08:22:25 <quicksilver> I don't like that at all, pedagogically.
08:22:37 <Cale> eugman|college: Note that when you're working with multiparameter functions in Haskell, you're really working with single parameter functions that return other functions, and it's this left associativity that makes that work.
08:22:40 <Cale> That is,
08:22:42 <Cale> f x y z
08:22:51 <Cale> Really means: ((f x) y) z
08:25:12 <faxathisia> > f x y z :: Expr
08:25:25 <lambdabot>  f x y z
08:26:47 <eugman|college> Cale, that's the whole idea behind currying right?
08:26:52 <Cale> Right.
08:27:16 <Cale> Well, this is the syntax that makes currying convenient.
08:27:45 <Cale> (and yeah, the thing about treating multiparameter functions as single-parameter functions is currying)
08:35:41 <Codex_> Currying is really: XxY->Z / X->Z^Y ?
08:36:31 <Codex_> err, no, it's XxY->Z / Y->Z^Y. (small typo).
08:36:32 <EvilRanter> X*Y -> Z / X -> (Y -> Z)
08:36:42 <Codex_> Z^X :)
08:37:07 <EvilRanter> if you prefer, Z^(X*Y) / (Z^Y)^X
08:37:37 <EvilRanter> but i find the exponent notation kinda confusing. also the -> notation is more haskell-y
08:37:39 <Cale> What do you mean by / here?
08:37:58 <EvilRanter> "or"
08:37:58 <Cale> If you mean "is isomorphic to", then yes :)
08:38:01 <chot> hi, we're writing a lift function for our monad; lift :: IO a -> Replay a, but we cant get how to be able to run a IO function in our Replay monad? does replay have to return some IO stuff aswell?
08:38:25 <EvilRanter> "=" might've been a better choice
08:38:30 <Codex_> evilranter: exponent notation is there because you need to separate objects and morphism. And -> is morphism, while A^B is object. :)
08:38:41 <EvilRanter> um. okay.
08:39:01 <chot> currently we have lift x = R $ \t -> do r <- x; r
08:39:15 <EvilRanter> my head -> . ' <- the conversation
08:39:23 <Cale> chot: It's pretty hard to say how to write that without knowing what Replay is.
08:40:06 <Cale> The Replay type will have to incorporate the IO type constructor somewhere in its definition in order to be able to write such a lift though.
08:40:17 <Cale> (As an initial guideline)
08:40:24 <chot> Cale: newtype Replay q r a = R { unR :: (Trace r) -> (Either (q, Trace r) a) } , it's a monad for executing up untill a certain point where it exits and asks for some information, and then can return execution at that place
08:40:35 <Cale> What is Trace?
08:41:02 <Cale> This is already looking quite impossible.
08:41:04 <chot> Cale: it's a list of results from the running of the program, so that it can be restarted at the same point without having to run it again
08:41:16 <Cale> Okay, no such lift exists.
08:41:30 <chot> Cale: it's a home assignment from school :S
08:41:47 <chot> but we've defined the Replay ourselfes
08:42:00 <Cale> Okay, you could alter the Replay type to make it possible.
08:42:56 <chot> yeah we figured we'd have to do something like that, but we still have to run the IO thing and extract information form it in our lift?
08:43:10 <Cale> For example, newtype Replay q r a = R { unR :: (Trace r) -> IO (Either (q, Trace r) a) }
08:43:21 <chot> ah..
08:43:24 <chot> that's smart :p
08:43:31 <BMeph> o.O
08:43:44 <BMeph> :)
08:43:50 <chot> we were thinking something like ,...-> (IO a, Either.. )
08:43:50 <quicksilver> or replace IO with a generic Monad 'm'
08:43:56 <quicksilver> and then call it "ReplayT"
08:44:00 <sclv_> replace looks like it can be written as a monad transformer.
08:44:03 <quicksilver> which is the pattern used in the mtl
08:44:16 <chot> ok cool
08:44:18 <Cale> @unmtl State s a
08:44:18 <lambdabot> s -> (a, s)
08:44:20 <eugman|college> can someone give me the agebraic expansion of foldl (-) 0 [8,4,2,1]  ? When i tried i got it wrong
08:44:22 <Cale> @unmtl StateT s IO a
08:44:23 <lambdabot> s -> IO (a, s)
08:44:28 <chot> thanx a lot guys, think we'll be able to handle it from here :)
08:44:39 <Cale> > foldl (-) 0 [8,4,2,1] :: Expr
08:44:40 <lambdabot>  0 - 8 - 4 - 2 - 1
08:44:55 <Cale> (associated to the left)
08:45:24 <Cale> > foldr (-) 0 [8,4,2,1] :: Expr
08:45:25 <lambdabot>  8 - (4 - (2 - (1 - 0)))
08:45:46 <moonlite> oh that :: Expr-thing seems handy
08:45:47 <johnnowak> http://foldl.com/
08:45:48 <lambdabot> Title: foldl.com
08:46:22 <Cale> It's not a separate hackage package yet, but you can steal it from the lambdabot source.
08:46:31 <Cale> It's called SimpleReflect.hs
08:46:46 <moonlite> what would it do on, say, a map?
08:46:47 <eugman|college> ah ok. I somehow did some bastardized hybrid. So normal math is left associative correct?
08:46:56 <moonlite> > map (+1) [1..5] :: Expr
08:46:56 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
08:46:59 <Cale> > map f [1,2,3] :: [Expr]
08:47:00 <lambdabot>  [f 1,f 2,f 3]
08:47:08 <moonlite> aah
08:47:36 <doserj> > map (+1) [1..5] :: Expr
08:47:39 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
08:47:43 <doserj> > map (+1) [1..5] :: [Expr]
08:47:44 <lambdabot>  [1 + 1,2 + 1,3 + 1,4 + 1,5 + 1]
08:47:47 <asmanian> this Expr stuff is cool is this available for ghci, too?
08:47:55 <Cale> eugman|college: yeah, generally
08:48:01 <faxathisia> mirror = Right `either` Left
08:48:12 <Cale> asmanian: If you steal the code for it from lambdabot, yeah.
08:48:18 <vincenz> reflect `on` mirror
08:48:32 <Cale> asmanian: Someone should really make it into a cabal package. Where's gwern? :)
08:48:45 <asmanian> heh, not so important
08:48:55 <asmanian> im actually a haskell beginner
08:49:41 <Cale> eugman|college: One exception is exponentiation
08:49:45 <Cale> eugman|college: which is normally right associative
08:50:54 <slarba> ahh the ip stack works flawlessly with nonthreaded runtime now
08:55:07 <quicksilver> eugman|college: yes, generally. But it matters surprisingly rarely.
08:55:12 <quicksilver> + and * are commutative anyway.
08:55:20 <quicksilver> - is used left-stylee
08:55:28 <quicksilver> you very rarely see long chains of /
08:55:30 <eugman|college> quicksilver, sure it's jsut a way to orient myself with these terms
08:55:33 * quicksilver nods
08:55:48 <quicksilver> in haskell you choose assocativity explicitly
08:55:56 <quicksilver> so, e.g., ($) is right-assoc and (.) is left-assoc.
08:55:58 <Cale> quicksilver: s/commutative/associative/
08:56:12 <quicksilver> yes, good point.
08:56:17 * quicksilver slaps himself
08:56:20 <eugman|college> quicksilver, actually that's very useful. I was having trouble distinguishing the two
08:56:39 <quicksilver> in some circs you can replace a (.) with a ($)
08:56:42 <Cale> (++) is associative, but not commutative
08:56:43 <quicksilver> but that's a bit profound
08:56:44 <Stinger> hmm is expr just an instance of Num (or higher)
08:56:59 <quicksilver> because you're actually replacing a left-assoc with a right-assoc
08:57:01 <quicksilver> it's not a local change
08:57:06 <quicksilver> it completely restructures the term
08:57:14 <quicksilver> so it's "surprising" in a way.
08:59:04 <Cale> The operation which joins rooted, unordered trees at their root is commutative, but not associative.
08:59:34 <Cale> (but that's a stupid example, can anyone think of anything better?)
09:02:21 <faxathisia> cross product
09:02:24 <Cale> The Lie bracket is anticommutative ([x,y] = -[y,x]), and not associative.
09:02:32 <Cale> ah, cross product :)
09:02:52 <Cale> er, no, that's anticommutative as well
09:03:27 <quicksilver> Cale: I think that is essentially the only example.
09:03:41 <quicksilver> Cale: trees are the free (non-associative) structure.
09:03:51 <Cale> Well, it's kind of a universal example
09:03:57 * quicksilver nods
09:04:01 <Cale> But there must be a more interesting one :)
09:11:23 <ski_> Cale : jordan algebras ?
09:12:25 <Cale> Seems so, yeah.
09:12:34 <Cale> I've never really run into those.
09:12:55 <ski_> maybe there's some (moufang) loop examples, as well ..
09:13:15 <ski_> (s/moufang/moufang ?/)
09:17:10 <Cale> Oh, rock, paper, scissors!
09:17:18 <vincenz> paper
09:17:34 <glguy> did anyone "opt-in" for irseekbot?
09:17:43 <vincenz> glguy: it's here?
09:17:48 <glguy> I removed it last night
09:17:51 <Cale> The operation defining the winner of a rock paper scissors game is commutative but not associative.
09:17:53 <glguy> I saw you kicked it in the logs
09:17:57 * vincenz nods
09:18:03 <glguy> and saw no one defend it in the logs
09:18:11 <Cale> r*(p*s) = r*s = r
09:18:15 <vincenz> kneejerk reaction
09:18:15 <faxathisia> Cale that doesn't make sense
09:18:20 <vincenz> I found logs of #oasis
09:18:22 <vincenz> without ever opting in
09:18:24 <Cale> (r*p)*s = p*s = s
09:18:52 <faxathisia> oh I get it..
09:18:52 <faxathisia> It's a bit of a contrived example since imo  r * p = player 2
09:19:00 <Cale> What?
09:19:10 <Cale> r*p = p
09:19:16 <vincenz> no it's not
09:19:22 <vincenz> your * is not well-defined
09:19:27 <vincenz> r * p = (2,p)
09:19:28 <Cale> Yes it is.
09:19:29 <Stinger_> pfft theres not even an identity
09:19:38 <vincenz> Cale: no because where are the players?
09:19:41 <vincenz> r*p*s ...
09:19:43 <vincenz> who is playing what?
09:19:52 <Cale> It's not associative.
09:19:54 <glguy> you are the weakest link, goodbye
09:19:58 <Cale> What does r*p*s mean?
09:20:04 <vincenz> Cale: exactly, it means nothing
09:20:07 <Cale> What?
09:20:10 <vincenz> nor does (r*p)*s
09:20:23 <Cale> No, that's meaningful.
09:20:24 <vincenz> Cale: what's r*r ?
09:20:27 <Cale> r
09:20:30 <vincenz> no it's not
09:20:35 <Cale> It is by definition.
09:20:37 <Stinger_> r*p*s = {}
09:20:38 <vincenz> how do you denote both people won?
09:20:57 <vincenz> Cale: your model does not take into account the parties, that's the flaw in the equation (r*p)8s
09:21:05 <Cale> The operation here is: r*p = p*r = p, p*s = s*p = s, r*s = s*r = r, r*r = r, p*p = p, s*s = s
09:21:10 <Cale> Happy?
09:21:13 <vincenz> nope
09:21:17 <vincenz> p*p = [p,p]
09:21:23 <vincenz> two winners (or a draw)
09:21:31 <Cale> That's a long-winded way of saying "what beats what in rock paper scissors"
09:21:54 <vincenz> Cale: i'm saying that by not taking into account a player, your model is flawed
09:21:58 <vincenz> p*p != p
09:22:04 <Cale> I don't care about the players.
09:22:08 <vincenz> it's [(1,p),(2,p)]
09:22:10 <vincenz> well you should
09:22:17 <vincenz> cause (p*r)*s makes no sense
09:22:20 <ski_> maybe you could call this operation a sort of `max'
09:22:20 <osfameron> s*s is a draw isn't it?
09:22:23 <Cale> I'm just interested in defining a moderately interesting operation which is commutative and nonassociative.
09:22:35 <faxathisia> ski_: It's not really a maximum though
09:22:44 <Cale> In fact, it doesn't matter how you define r*r, etc.
09:22:45 <smg> btw what is better to do? (funcA . funcB) value or funcA (funcB value) ?
09:22:45 <ski_> faxathisia : hence "a sort of"
09:22:49 <Cale> You could define r*r = s
09:22:53 <Cale> s*s = p
09:22:58 <Cale> p*p = r
09:23:02 <Cale> Or some such.
09:23:16 <vincenz> so * is partial
09:23:26 <Cale> Just make it total somehow.
09:23:47 <Cale> (and I don't really care how, since any way will work)
09:24:13 <vincenz> alright
09:24:18 <vincenz> cows and lions together make monkeys
09:24:26 <karma_> Hello! Is there someone in the community who can be advisor for this SoC project: http://hackage.haskell.org/trac/summer-of-code/ticket/40 ? I emailed mentor specified at that page but he is at vacation.
09:24:28 <lambdabot> Title: #40 (Formal Verification (QuickCheck on steroids)) - Haskell.org Google Summer o ...
09:25:08 <quicksilver> karma_: I believe this years summer of code has not yet been arranged
09:25:11 <quicksilver> (or even confirmed?)
09:25:51 <faxathisia> karma_: Looked at Ivor
09:26:04 <karma_> quicksilver: i think it will take part as well and timeline will be same but i want to start to work on my proposal earlier
09:26:43 <smg> isn't here a difference?
09:26:55 <Cale> Hmm, is this project idea even possible without adding new language primitives?
09:27:27 <vincenz> Cale: loooks a bit over the top
09:27:29 <Cale> You can't observe functions without applying them, so there's no way to call the theorem prover.
09:27:53 <Cale> So whatever you write can't be a drop-in replacement.
09:28:02 <doserj> "connect it to haskell" probably means parse the source code
09:28:03 <esap> sure you can. Just parse the source code and then observe it :-)
09:28:34 <karma_> So first think i want to know, what're QuickCheck limitations and why we need replacement for it
09:28:36 <vincenz> doserj: that only works for one module
09:28:37 <Cin> i've got a list of modules, and each have some callbacks that i call, and i want to pass each of them some kind of state -- what's a good way to store a list of these modules each with whatever type they want for their state? like i don't want to restrict their state to any particular type of structure...
09:28:40 <vincenz> doserj: you need typing information
09:29:01 <vincenz> imho, this project looks slightly overambitious
09:29:08 <faxathisia> You're going to have a fair bit of extra work, proving functions total, structurally recursive.. printing "(unless you pass in a finite list)" at the end
09:29:09 <Cale> karma_: Quickcheck doesn't actually prove things, it supplies random data and functions to a property and check that it remains true.
09:29:10 <vincenz> they need to reflect types into values
09:29:19 <Cale> checks*
09:29:31 <faxathisia> Perhaps a better project would be Agda 2 -> Haskell compilation
09:29:50 <ski_> Quickcheck falsifies things
09:30:04 <faxathisia> and lots of theorems regarding the std lib
09:30:06 <vincenz> faxathisia: am I the only one that finds the description of that project a bit vague and a bit overambitious
09:30:19 <quicksilver> Cin: an existential.
09:30:25 <faxathisia> vincenz: no, It seems .. ridiculous to me
09:30:29 <Cin> quicksilver: is that a class?
09:30:32 <noige> hi
09:30:36 <quicksilver> Cin: no, it need not be.
09:30:40 * esap thinks that project seems like piece of cake compared to my own projects (which are WAY over-ambitious)... :-)
09:30:43 <vincenz> faxathisia: yeah, 'a bit' was a a bit for 'a lot '
09:30:59 <vincenz> esap: summer of code needs to be well-defined projects that can ahve achievabe goals
09:31:01 <Cale> It does this using two basic functions, defined specifically for each type on which it works: arbitrary, which provides a way of generating a random value of a given type, and coarbitrary, which takes a value of a given type and uses it to transform a random generator on another type
09:31:04 <vincenz> students need to be able to present something
09:31:13 <noige> I was in here last night and I decided that I am going to learn haskell. Should I know calculus to learn this?
09:31:24 <quicksilver> noige: no.
09:31:24 <glguy> no
09:31:25 <esap> vincenz: are there time schedule for those?
09:31:27 <vincenz> not a research projected with undeined goals whose implementation path is completely left unspecified
09:31:29 <faxathisia> karma_: what do you think of my idea?
09:31:32 <vincenz> esap: 'summer' of code
09:31:35 <Cale> I really really doubt that this interface is sufficient for plugging in a theorem prover.
09:31:44 <smg> can someone tell me what's the haskell way? f (g x) or (f . g) x ?
09:31:53 <vincenz> f . g $ x
09:31:55 <dcoutts> noige: programming has much more to do with logic than with real analysis / calculus
09:31:56 <faxathisia> smg: Both are equivalent
09:31:59 <noige> It seems that the school of expression books have several exercises which require me to prove things
09:32:05 <smg> faxathisia: i know
09:32:08 <mux> smg: can't you eta-reduce x ? :)
09:32:08 <smg> vincenz: yeah and this
09:32:14 <smg> what's the best way?
09:32:17 <faxathisia> smg: Yeah, but I mean, There's no better way
09:32:18 <ski_> smg : which way yo use depends on situation (and taste)
09:32:18 <karma_> oh, i've learned Metacomputation course. and i learned system written in Haskell which does metacomputation over XSG language (kind of lisp dialect defined in Haskell)
09:32:18 <smg> eta-reduce?
09:32:23 <Cale> However, "write a theorem prover for properties of Haskell code" (i.e. remove the requirement that it be a drop-in replacement for quickcheck) seems more reasonable.
09:32:24 <smg> ski_: okay thanks
09:32:34 <Cin> quicksilver: basically my program won't ever look at theri state, it's only the functions that do and they know the type. it seems safe, but a list of differing types sounds a bit wrong
09:32:34 <mux> as in foo = f . g instead of foo x = f . g $ x
09:32:41 <smg> so haskell is also TMTOWTDI :)
09:32:42 <vincenz> Cale: how do you reflect th code and type information in the language?
09:32:50 <vincenz> smg: eh?
09:32:51 <karma_> so may be it's possible to build metacomputation in haskell for haskell but that's a great amount of work i think
09:32:58 <dcoutts> noige: all branches of maths and computer science involve proving things, calculus is just one branch of mathematics (which is mostly unrelated to programming)
09:33:03 <smg> http://catb.org/jargon//html/T/TMTOWTDI.html
09:33:03 <noige> like this notation:(‚àÄxs | xs is finite) listProd xs = fold (*) 1 xs which to me reads as prove that for all xs such that xs is finite some function
09:33:03 <lambdabot> Title: TMTOWTDI
09:33:08 <vincenz> karma_: sounds more like a phd topic than a sumemr of code topic
09:33:10 <smg> vincenz: see link :)
09:33:10 <noige> dcoutts: oh ok
09:33:15 <esap> vincenz: If the theorem prover already exists and has reasonable interfaces, then that could be possible. But the "or write a native haskell one" probably isn't. I've been doing something like that for close to 10 years and it's nowhere near completion
09:33:16 <faxathisia> karma_: Do you know how theorem provers in type theory work?
09:33:40 <quicksilver> Cin: that's exactly what existential types are for.
09:33:45 <Cale> smg: (f . g) x and f . g $ x have the advantage that f . g is a meaningful subexpression.
09:33:48 <noige> I really think this language is interesting
09:33:54 <faxathisia> karma_: because that seems the best option but still a bit impossible
09:34:02 <quicksilver> Cin: although I don't have time to explain in detail now, there should be plenty of information around about them.
09:34:12 * noige knows nothing about the language but somehow finds it interesting
09:34:15 <smg> Cale: yeah function composition like in math :)
09:34:18 <dcoutts> noige: yes, that's the way to read it, as a theorem that requires proof.
09:34:21 <Cale> (and f . g $ x has the advantage that both f . g and g $ x are meaningful subexpressions)
09:34:21 <smg> but i like $ too :]
09:34:21 <quicksilver> Cin: just don't listen if someone tells you existentials need typeclasses to be useful because that's rubbish :P
09:34:22 <karma_> faxathisia: think so, i briefly know how Dumatel (http://www.haskell.org/dumatel) works
09:34:23 <lambdabot> Title: Dumatel. A prover based on equational reasoning.
09:34:29 <smg> i like $ :)
09:34:36 <Cale> smg: f $ g $ x is bad :)
09:34:47 <smg> hehe really?
09:34:49 <Cale> It has no advantages over f . g $ x
09:34:52 <smg> ok
09:34:55 <smg> yeah okay
09:35:01 <smg> i do mean f . g $ x is cool
09:35:02 <faxathisia> Cale, why's it bad? (I tend to do that)
09:35:03 <Cin> quicksilver: yeah, i'm reading about them on the wiki. it doesn't seem i'll need a class
09:35:06 <Cale> (and f $ g is likely meaningless)
09:35:07 <blargeyfarg> what about f $ g x?
09:35:07 <smg> instead of f ( g ( x ) )
09:35:15 <Cin> quicksilver: thanks
09:35:17 <vincenz> faxathisia: f . g $ x is less noisy than f $ g $ x
09:35:25 <Cale> f $ g x is roughly similar to f (g x)
09:35:35 <Cale> But does save you a close paren
09:35:37 <noige> dcoutts: Interesting, so does that mean that any and all inputs in the language are also functions?
09:35:37 <smg> isn't it equivalent Cale?
09:35:40 <vincenz> besides it makes the right$ completely superfluous
09:35:45 <smg>  f $ g $ h x  =  f (g (h x))
09:35:57 <vincenz> let's try
09:35:58 <dcoutts> noige: everything is a value, functions are also values
09:35:58 <Cale> smg: yeah, abusing the associativity of $
09:35:59 <faxathisia> thanks, I'm convinced :)
09:36:02 <vincenz> > f $ g $ h x :: Expr
09:36:05 <lambdabot>  Add a type signature
09:36:12 <vincenz> I did!
09:36:16 <Cale> smg: It would actually be nicer if $ had the opposite associativity
09:36:19 <dcoutts> noige: so it's asking us to prove listProd = fold (*) 1 (for all finite lists xs)
09:36:31 <vincenz> > f $ g $ x :: Expr
09:36:32 <lambdabot>  Add a type signature
09:36:34 <dcoutts> noige: that is it's asking us to prove two functions are equal
09:36:35 <Cale> Since you can always rewrite f $ g $ h x as f . g $ h x
09:36:43 <vincenz> > f $ g $ h 'x' :: Expr
09:36:43 <lambdabot>  Add a type signature
09:36:45 <vincenz> wtf
09:36:48 <noige> dcoutts: Ahh I see
09:36:51 <shepheb> > (f $ g $ h x) :: Expr
09:36:52 <lambdabot>  Add a type signature
09:36:52 <dcoutts> noige: and functions are equal when they give the same answer on all inputs
09:36:57 <Cale> but you can't rewrite f (g x) (h y) (k z) without using parens.
09:37:01 <vincenz> shepheb: the 'g'' type is underspeciied
09:37:06 <noige> dcoutts: right that translates from what I know about math
09:37:15 <smg> Cale: haha yes
09:37:17 <Cale> If $ had the opposite associativity, you could write it as f $ g x $ h y $ k z
09:37:37 <faxathisia> karma_: It seems to me anyway, taking a theorem prover (Agda 2 would be a good choice) writing programs with strong specifications in that and compiling to haskell (erasing the extra type information) is a more reasonable goal
09:37:48 <Cale> But instead, that ends up meaning the same thing as f . g x . h y $ k z
09:37:52 <Cale> which is kind of dumb
09:37:53 <noige> dcoutts: Ok so I think I have a chance to learn this with some dedication. Thanks for answering my questions. Would you recommend that a newcomer to fp use the school of expression book?
09:37:54 <vincenz> faxathisia: you mean "an achievable goal"
09:37:57 <dcoutts> noige: in this example the inputs to the functions were lists and the question gave the further restriction that the input xs be finite (probably because it's harder or perhaps not true if xs were infinite)
09:38:10 <faxathisia> vincenz: I actually wrote that and then rephrased :P
09:38:11 <Cale> smg: So some of us would like to change it at some point :)
09:38:13 <dcoutts> noige: it's good yes.
09:38:24 <desegnis> noige: The only difference to math is then that Haskell has types instead of domain/codomain sets, and that Haskell programs may lead to an error (i.e. evaluate to bottom)
09:38:30 <vincenz> the advisor for that project hsould be taken out and beta-reduced into a value
09:38:51 <noige> ahh I see, this is very good
09:39:07 <noige> I think that I will get along with this language okay
09:39:09 <dcoutts> noige: if you want a more mathematical approach then Richard Bird's book is great. If you prefer a more practical approach then "Programming in Haskell" by Graham Hutton is ideal.
09:40:15 <Stinger_> noige haskell will break your brain, run before you start to like it :P
09:40:28 <vincenz> faxathisia: "write a quickchecker drop in replacement that will prove termination of haskell code"
09:40:51 <noige> dcoutts: Oh ok. I think I will start with the school of expression book since I do not even understand the rudiments of the language yet. I think I should pick up the basics before I try to make it bend to my thinking patterns hahha
09:41:05 <noige> Stinger_: good :) I am looking forward to some interesting challenges
09:41:09 <mux> you don't bend haskell, haskell bends you :)
09:41:20 <Stinger_> there is no haskell?
09:41:27 <shapr> There is only lambda calculus.
09:41:36 * noige insert token in russia x bends y
09:41:43 <esap> category theory bends haskell.
09:41:51 <vincenz> shapr: beta-reduce yourself, grasshopper, and there will only be value
09:41:53 <dcoutts> is it 'cuz I is strongly typed?
09:41:55 <Stinger_> it is all around us, in the points we free and in the data we flow
09:41:56 * noige joke should have been on the end of that last sentence
09:42:51 <mux> is there a flag in GHC 6.8.* to get to the System Fc output?
09:42:52 <Stinger_> ghc should have all its error messages in lolcats
09:43:10 <Stinger_> monomorphism => "can I has a type signature"
09:43:41 <shapr> hah
09:43:43 <noige> Is it can be fp tiem nao pleeze!
09:43:49 <noige> ok
09:43:55 <shapr> Oh, I have to look for more lambdacats.
09:43:55 <noige> well I guess this is the start
09:44:02 <quicksilver> "I can haz tiep signitjur?"
09:44:08 <mux> these foocats thing annoy me
09:44:19 <shepheb> Stinger_: that actually helped me understand the monomorphism restriction.
09:44:27 <Stinger_> oh god
09:44:29 <Stinger_> what have I done
09:44:34 <faxathisia> mux, even lazy bite string one?
09:44:37 <ski_> `monomorphism' is a category theoretic concept, corresponding roughly to "injection"
09:44:37 <shapr> @where lambdacats
09:44:38 <lambdabot> http://arcanux.org/lambdacats.html
09:44:42 <noige> I need to go to work. I am sure that I will be back with several questions and several silly answers to my own questions. Thank you for helping me
09:45:14 <dcoutts> some of the lambdacats are just hilarious, though I feel dirty admitting it
09:45:26 <Stinger_> haha, should have some long point free equation "invisible points"!
09:45:26 <shapr> dcoutts: Why is that dirty?
09:45:45 <vincenz> shapr: all those furrballs?
09:45:46 <mux> faxathisia: I don't remember that one
09:45:50 <dcoutts> shapr: oh just the whole lol stuff is sooo silly/annoying
09:45:55 <Stinger_> cause its from 4chan and is hence dirty by default
09:46:07 <shapr> lolcats started on 4chan??
09:46:19 <vincenz> isn't 4chan a pornsite?
09:46:26 <mux> faxathisia: seen, not bad :)
09:46:30 <faxathisia> shapr, well it's not called lolcats but they started it
09:46:39 * shepheb is using the "tail recursion" lambdacat as a spray tag in FPS games. it makes me feel very alone.
09:47:03 <hpaste>  drigz pasted "Cannot declare Bits [Bit] etc." at http://hpaste.org/5796
09:47:11 <faxathisia> shapr, http://en.wikipedia.org/wiki/Image_macro & http://en.wikipedia.org/wiki/4chan
09:47:12 <lambdabot> Title: Image macro - Wikipedia, the free encyclopedia
09:47:12 <drigz> can someone help me with that?
09:47:22 * mux reused the sunny lambda from summer of code 2007 for his msn icon, and feels lonely as well when people ask him what the hell is that
09:47:24 <Cin> hpaste: url
09:47:24 <hpaste> Haskell paste bin: http://hpaste.org/
09:47:24 <drigz> I'm trying to declare: instance Bits [Bit]
09:47:33 <esap> Maybe somebody can distinguish between Cat and CAT with a picture
09:47:54 <vincenz> drigz: newtype it
09:47:54 <vincenz> newtype BitList = BL [Bit]
09:48:01 <hpaste>  Cin pasted "is my `forall' syntax incorrect?" at http://hpaste.org/5797
09:48:19 <vincenz> drigz: additionaly
09:48:26 <vincenz> drigz: newtype Bit = Bit Bool
09:48:30 <vincenz> drigz: no point in mking that a data
09:48:48 <drigz> vincenz: ok, thanks
09:48:57 <drigz> i will read newtype v data, i have no idea of the difference
09:49:08 <vincenz> drigz: easy
09:49:11 <vincenz> with newtype
09:49:19 <vincenz> newtype Foo = Foo Bar
09:49:24 <vincenz> Foo _|_ == _|_
09:49:32 <esap> Cin: try -fglasgow-exts
09:49:33 <vincenz> and you don't get an extra constructor overhead in memory
09:49:45 <Cin> esap: ahhh
09:50:36 <drigz> vincenz: is that it? why does it cause the type error?
09:50:51 <shapr> @quote cat
09:50:52 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment.
09:50:52 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
09:50:52 <drigz> oh wait, i see, sorry
09:50:54 <Cin> esap: that did the trick, thanks
09:51:59 <drigz> vincenz: why is the way I did it not allowed? it would avoid all the BLs everywhere
09:52:00 <ski_> shouldn't the next to last lolcat be `foldl1 sleep $ replicate 4 lolkitten' ?
09:52:28 <Cin> esap: heh, aww; "Record update for the non-Haskell-98 data type `Module' is not (yet) supported\nUse pattern-matching instead". pattern matching it is..
09:52:31 <vincenz> drigz: cause [Bit] is not of the required form
09:52:37 <wli> The applications of Yoneda's lemma to B2B, SOA, etc. is unclear to me.
09:52:38 <vincenz> drigz: not sure which flags to activate that
09:52:47 <vincenz> wli: It's quite obvious
09:52:56 <wli> vincenz: Do tell, then.
09:53:12 <esap> Cin: Existentials are tricky sometimes.
09:53:26 <vincenz> wli: Well it's all based on Hindley Milner and Turing equivalence in the modern day workplace where waterfall models are superceded by agile methodologies
09:53:49 <shapr> ouch
09:54:43 <vincenz> Especially when you use modern technologies like AJAX, XML and static typing
09:54:50 <esap> vincenz: talking about waterfall and Hindley-Milner on the same sentence seems like a bad idea.
09:55:17 * vincenz wonders if noone gets what 'absurdism' is
09:55:36 <vincenz> esap: HM applied in business practices is very powerful
09:55:46 <shapr> I want to leverage the HM waterfall model and stand up Turing machines at the client site.
09:55:52 * esap only understands real contradictions as humor :-)
09:56:04 <vincenz> esap: Nah,, yoou have to add thigns together that completely don't fit together
09:56:10 <vincenz> B2B, HM and SOA
09:56:24 <faxathisia> we can use Monads to help collect the low hanging fruit?
09:56:31 <vincenz> Or you'll be outsourcing static typing overseas
09:57:04 <vincenz> faxathisia: I particularly enjoy the employment of type classes during contract negotiations.
09:57:47 <Gilly> Hello, can I overload operators like +, -, * and / for my own data structures without making them instances of Num? I got that type of data that won't let me define some of the functions in Num.
09:58:02 <vincenz> That's how marketeers speak "Do you REALLY want to outsource your static typing overseas?!?"  And then youre left going "Gh, what?"
09:58:04 <Baughn> Gilly: No.
09:58:30 <vincenz> and they go "Exactly, HM is only applicable to Agile B2B methods"
09:58:34 <Baughn> Gilly: You can always define the non-meaningful functions as undefined.
09:58:45 <shepheb> Gilly: consider making up your own lookalikes, .+. .*. and so on
09:58:53 <Gilly> Ok thanks :)
09:58:54 <vincenz> shepheb: ocaml 2.0 ?
09:59:38 <Gilly> I was going to make a FieldElement class (think about mathematical fields)...
09:59:49 <ski_> Gilly : you could also hide `Num' (and methods thereof)
09:59:56 <esap> vincenz: Here's an example: http://www.dilbert.com/comics/dilbert/archive/dilbert-20080208.html
09:59:59 <lambdabot> Title: Dilbert Comic Strip Archive - Dilbert.com - The Official Dilbert Website by Scot ..., http://tinyurl.com/2j6268
10:00:19 <vincenz> esap: hehe :Dd
10:00:32 <Gilly> ski_: what does that mean?
10:00:33 <Cale> Gilly: You can also just cheat and leave the other things (likely signum and abs) undefined.
10:01:27 <ski_> Gilly : `import Prelude hiding ( Num ( (+),(-),etc .. )'
10:01:56 <Gilly> Well, I consider the options, thanks :) I just started looking at Haskell today so I'm a bit lost.
10:03:07 <ehird_> hmm
10:03:11 <ehird_> there is uneven spacing in the topic
10:03:15 <ehird_> 'effort!", ...'
10:03:16 <ehird_> vs
10:03:23 <ehird_> '.org " ,"...'
10:03:39 <idnar> heh
10:03:52 --- mode: ChanServ set +o vincenz
10:04:48 <ski_> (vincenz : wrong button ?)
10:05:08 <vincenz> ski_: no, my client kept trying to connect to a server
10:05:10 <vincenz> no idea how to stop it
10:05:18 <vincenz> What I wanted to do was
10:05:23 <lQg> how do i get the index of an element in a list?
10:05:23 --- mode: ChanServ set +o vincenz
10:05:30 <lQg> @hoogle index
10:05:31 <lambdabot> Data.Ix.index :: Ix a => (a, a) -> a -> Int
10:05:31 <lambdabot> Data.ByteString.index :: ByteString -> Int -> Word8
10:05:31 <lambdabot> Data.Sequence.index :: Seq a -> Int -> a
10:05:31 <ski_> @index find
10:05:32 <lambdabot> Data.List
10:05:58 <ski_> @type Data.List.find
10:06:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
10:06:05 <ski_> no
10:06:07 --- mode: vincenz set -o vincenz
10:06:37 <vincenz> @index index
10:06:38 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff, Graphics.Rendering.OpenGL.GL.VertexSpec, Graphics.
10:06:38 <lambdabot> Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
10:06:39 <xerox> ?findIndex
10:06:40 <lambdabot> Unknown command, try @list
10:06:45 <xerox> and findIndices
10:06:49 <vincenz> @hoogle (a -> Bool) -> [a] -> Int
10:06:50 <lambdabot> No matches, try a more general search
10:06:56 <vincenz> @hoogle a -> [a] -> Int
10:06:57 <lambdabot> No matches, try a more general search
10:07:00 <vincenz> @hoogle a -> [a] -> Integer
10:07:01 <lambdabot> No matches, try a more general search
10:07:10 <vincenz> :t findIndex
10:07:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
10:07:18 * ski_ rarely uses that
10:07:22 <vincenz> xerox++
10:07:47 <lQg> i guess i can just write my own
10:08:22 <lQg> but it would be nice if there was one
10:08:29 <lQg> that i could use
10:08:59 <faxathisia> :t elemIndex
10:09:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
10:09:14 <faxathisia> oh .. sorry, yeah
10:09:18 <ehird_> > genericLength [1,2,3]
10:09:21 <lambdabot>  3
10:09:23 <ehird_> > genericLength [1,2,3,half of 2]
10:09:23 <lambdabot>  Parse error at "of" (column 27)
10:09:26 <ehird_> goddamn :(
10:09:45 <faxathisia> > genericLength [1,2,3,x,y,z]
10:09:47 <lambdabot>  6
10:09:54 <faxathisia> hetrogenous lists..
10:09:59 <resiak> > genericLength [x,y,z,z,y]
10:10:00 <lambdabot>  5
10:10:05 <resiak> > 1 :: Expr
10:10:07 <lambdabot>  1
10:10:11 <resiak> so, no :)
10:10:21 <lQg> kk
10:10:43 <lQg> more programming for me
10:10:45 <lQg> lol
10:11:04 <ehird> :t [1,2,3,x,y,z]
10:11:04 <lambdabot> Not in scope: `x'
10:11:04 <lambdabot> Not in scope: `y'
10:11:04 <lambdabot> Not in scope: `z'
10:11:08 <ehird> bah
10:11:12 <ehird> lambdabot is so inconsistant :P
10:11:21 <ehird> > genericLength [1,2,3,x,y,z] :: [a]
10:11:22 <lambdabot>        add (Num [a]) to the context of
10:11:22 <lambdabot>         the polymorphic type `forall a...
10:11:26 <ehird> oh of course
10:11:32 <ehird> x y z are nums
10:11:56 <esap> ski: btw, did you see http://www.kotiposti.net/epulkkin/PolyQueue.txt and http://www.kotiposti.net/epulkkin/PolyStack.txt
10:12:40 <ski_> not until now
10:12:49 <ski_> hiya esap
10:13:20 <esap> ski: look at the type for 'dequeue'. If you add that as a type annotation, it fails to compile. But inference produces that exact type.
10:13:46 <ski_> is that literate ?
10:13:52 <esap> ski: yes.
10:17:04 <lQg> is there a max_int constant?
10:17:17 <Lemmih> > maxBound :: Int
10:17:18 <lambdabot>  2147483647
10:17:25 <lQg> kk
10:17:32 <lQg> > -maxBound
10:17:33 <lambdabot>  Add a type signature
10:17:38 <lQg> > -maxBound :: Int
10:17:39 <lambdabot>  -2147483647
10:17:39 <Lemmih> > minBound :: Int
10:17:40 <lambdabot>  -2147483648
10:17:56 <lQg> kk
10:18:23 <Stinger_> @src returnA
10:18:23 <lambdabot> returnA = arr id
10:18:26 <faxathisia> > minBound :: Int
10:18:26 <Stinger_> thought so
10:18:27 <lambdabot>  -2147483648
10:18:36 <faxathisia> @src arr
10:18:37 <lambdabot> Source not found. Do you think like you type?
10:18:47 <faxathisia> :t (arr, pure)
10:18:48 <lambdabot>     Ambiguous occurrence `pure'
10:18:48 <lambdabot>     It could refer to either `Control.Applicative.pure', imported from Control.Applicative
10:18:48 <lambdabot>                           or `Control.Arrow.pure', imported from Control.Arrow
10:19:06 <faxathisia> how is that ambiguous?
10:19:11 <faxathisia> I thought they were the same
10:19:24 <hpaste>  lQg pasted "getIndex function" at http://hpaste.org/5798
10:19:43 <lQg> I haven't tested it, but it should work
10:19:53 <asmanian> err integer in haskell has wraparound effects and size is machine specific? Thats bad :(
10:20:10 <faxathisia> anmanian: Integer does not, Int does
10:20:16 <faxathisia> lQg, Weird...
10:20:17 <asmanian> ah k
10:20:24 <asmanian> <- haskell noob
10:20:26 <faxathisia> lQg, Why use a negative?
10:20:29 <Cale> > 2^500
10:20:30 <lambdabot>  3273390607896141870013189696827599152216642046043064789483291368096133796404...
10:20:30 <vincenz> > -minBound :: Int
10:20:31 <lambdabot>  -2147483648
10:20:36 <faxathisia> lQg, Couldn't you just use Maybe
10:20:41 <vincenz> > 2^2^2^2^2
10:20:41 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
10:20:50 <vincenz> > 2^65536
10:20:51 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
10:20:58 <asmanian> k, haskell is still cool stuff ;)
10:21:10 <lQg> faxathisia: I don't really know how to
10:21:13 <vincenz> > 2^1000000
10:21:13 <lambdabot>  9900656229295898250697923616301903250733624241787567332866396114531709483309...
10:21:20 <vincenz> Cale: I wnoder how big it can go :)
10:21:31 <vincenz> > 3^1000000
10:21:32 <lambdabot>  1797710116675743838039851642017955175542668535689457592096701980448789887005...
10:21:40 <Stinger_> > (maxBound :: Int) + 1
10:21:40 <lambdabot>  -2147483648
10:21:47 <glguy> > floor (1/0) :: Integer
10:21:48 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
10:21:49 <faxathisia> lQg, well instead of minBound you have: Nothing
10:21:53 <vincenz> glguy: that's way smaller
10:22:00 <faxathisia> lQg, and instead of 0, Just 0
10:22:04 <vincenz> > length . show $ floor (1/0)
10:22:04 <lambdabot>  309
10:22:07 <glen_quagmire> > 3^(-1)
10:22:08 <glguy> vincenz: sure, 2^1024
10:22:08 <lambdabot>  Exception: Prelude.^: negative exponent
10:22:11 <asmanian> I guess this is only limitied by machine resources
10:22:13 <asmanian> ram, cpu or so
10:22:17 <glguy> vincenz: I'm just playing with lambdabot
10:22:17 <vincenz> > length . show $ 2^2^2^2^2
10:22:18 <lambdabot>  19729
10:22:24 <vincenz> > length . show $ 2^1000000
10:22:26 <lambdabot>  301030
10:22:26 <faxathisia> lQg, Not instead of doing 1 +, you want somthing that turn Nothing into Nothing, and Just x into Just (1+x)
10:22:31 <vincenz> > length . show $ 2^10000000
10:22:32 <ski_> esap : why the duplication in the base case for "ReverseStack'" ?
10:22:32 <Cale> These numbers so far are not very large.
10:22:39 <lambdabot> Terminated
10:22:40 <vincenz> Cale: 2^1000000 ?
10:22:56 <faxathisia> lQg, liftM (1+) is that function.. maybe there's other ways to express it?
10:23:04 <Cale> Well, that's 1 meg or so.
10:23:05 <Stinger_> > fix (2^)
10:23:06 <lambdabot>  Exception: <<loop>>
10:23:29 <lQg> @hoogle liftM
10:23:29 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
10:23:29 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:23:29 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
10:23:50 <glguy> :t elemIndex
10:23:50 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
10:23:59 <glguy> > elemIndex 5 [0..]
10:24:01 <lambdabot>  Just 5
10:24:05 <vincenz> > 2 ^ 2147483648
10:24:06 <Stinger_> @hoogle readDocument
10:24:06 <lambdabot> No matches found
10:24:10 <glguy> > elemIndex 5 []
10:24:10 <lambdabot>  Nothing
10:24:12 <lambdabot> Terminated
10:24:14 <lQg> well as long as doing the minBound doesnt pour the numbers into the positive, should be safe
10:24:14 <glguy> ?src elemIndex
10:24:15 <lambdabot> elemIndex x     = findIndex (x==)
10:24:24 <esap> ski: That's because you need the functional dependencies of both of those.
10:24:53 <faxathisia> lQg, The problem with returning minBound is someone may forget that could happen
10:25:02 <faxathisia> lQg, and the type doesn't even suggest the possibility
10:25:13 <faxathisia> lQg, so the result is basically, bugs creep in
10:25:15 <vincenz> > minBound - 1 :: Int
10:25:17 <lambdabot>  2147483647
10:25:20 <lQg> well what are the chances of it happening?
10:25:23 <faxathisia> 100%
10:25:28 <faxathisia> :)
10:25:32 <lQg> how so?
10:25:56 <lQg> > minBound :: Int
10:25:57 <lambdabot>  -2147483648
10:25:59 <esap> ski: or actually, I'm not quite sure what you mean by "base case"?
10:26:02 <faxathisia> I'm a bit biased because I used to write in C but the more you can have proved for you the better
10:26:09 <lQg> > 1 - minBound ::Int
10:26:10 <lambdabot>  -2147483647
10:26:14 <lQg> > 0 - minBound ::Int
10:26:15 <lambdabot>  -2147483648
10:26:19 <lQg> still negative
10:26:32 <ski_> esap : `reverse_acc _ x = (x,x)'
10:26:39 <faxathisia> getIndex x l !! l -- could fail
10:26:46 <vincenz> lQg: you're going ot have to check it anyways
10:26:47 <Zao> > -minBound :: Int
10:26:49 <lambdabot>  -2147483648
10:26:51 <vincenz> lQg: might as well use a type to imply that
10:26:51 <esap> ski: ah, look at type of reverse_acc.
10:27:01 <lQg> vincenz: like what?
10:27:06 <vincenz> Maybe Int
10:27:16 <glen_quagmire> > (minBound :: Int) :: Expr
10:27:16 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Int'
10:27:26 <gwern> I always wonder why GHC infers constant numbers like '5' or '2' to be Integer and not Int. I mean, it's not like they're going to overflow...
10:27:31 <vincenz> > fromIntegral (minBound :: Int) :: Expr
10:27:32 <lambdabot>  -2147483648
10:27:45 <vincenz> gwern: default case for the Num typeclass
10:27:52 <vincenz> gwern: haskell has two default cases: Integer and Double
10:27:52 <Cale> gwern: Because you haven't included a default declaration making Int default.
10:28:08 <Cale> I really really hate the Int type and wish that it wasn't in the Prelude.
10:28:22 <lament> what's the justification for having it?
10:28:26 <lament> blazing speed?
10:28:26 <vincenz> list length
10:28:31 <vincenz> :t (!)
10:28:32 <lQg> meh, it's just for this parser, and the maybe functions require more haskell knowledge to work with, the negative ints are cross language understandable, if someone tries to get a negative index of something it'll simply say something like "negative index pointer"
10:28:33 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
10:28:34 <vincenz> :t (!!)
10:28:34 <lambdabot> forall a. [a] -> Int -> a
10:28:39 <vincenz> :t length
10:28:40 <lambdabot> forall a. [a] -> Int
10:28:40 <gwern> vincenz: what's the narrower counterpart to Double?
10:28:41 <ski_> esap : no duplication indicated in the type
10:28:42 <Cale> Because you don't have to check for overflow.
10:28:46 <vincenz> gwern: Float
10:28:51 <Cale> (and so you get some speed)
10:28:53 <ehird> regarding Int --
10:28:59 <vincenz> gwern: or anything that is a RealFrac
10:29:01 <ehird> why can't Integer just use a real int if it won't overflow?
10:29:07 <Cale> It does.
10:29:10 <ehird> oh
10:29:13 <ehird> then Int is retarded
10:29:14 <Cale> But it has to *check*
10:29:16 <gwern> eh. now what would be awesome would be if we just had Integer, but the compiler could infer when it could safely use Int
10:29:21 <ehird> Cale: well, i meant at compile-time
10:29:25 <vincenz> ehird: yeah, there's a case-check
10:29:29 <gwern> (and Int would be #Int or something)
10:29:30 <Cale> ehird: Oh, it can't possibly know.
10:29:36 <vincenz> data Integer = Simple Int | [Int
10:29:42 <ehird> ok; then just stuff it into some kind of module as RealInt
10:29:42 <vincenz> something ilke that but more optimized :)
10:29:57 <Cale> It should just be relegated to the Data.Int module
10:30:00 <faxathisia> data Integer = Z | S Integer
10:30:10 <asmanian> back again
10:30:13 <ski_> @src Integer
10:30:13 <vincenz> Cale: no "Data.Premature.Optimization"
10:30:13 <lambdabot> data Integer = S# Int#
10:30:13 <lambdabot>              | J# Int# ByteArray#
10:30:14 <Cale> It's an optimisation which is usually premature.
10:30:21 <esap> ski: the base case instance is declared as: instance ReverseStack' (PolyStack (PolyStack a -> a)) b b, so both w and df type variables are bound to 'b'. The PolyStack usage there is because of the type of 'PolyStack.empty'
10:30:23 <asmanian> tried to build a very big number
10:30:35 <asmanian> ghci got my whole system freeze ;)
10:30:37 <faxathisia> negative numbers I guess are an exercise for the reader
10:30:43 <ehird> faxathisia: trivial:
10:30:47 <Rudolf> how i can translate a C code to haskell?
10:30:48 <vincenz> asmanian: how big was it?
10:30:55 <ehird> data Integer = Z | S Integer | N Integer
10:30:59 <ehird> N (S Z) -> -1
10:31:00 <sieni> Rudolf: manually?
10:31:03 <asmanian> it was 5 ^ 2 ^ 2 ^ 2 ^ 2 ^ 2 or so
10:31:04 <esap> ski: The type is matched against to discover an empty stack.
10:31:04 <Cale> Rudolf: Very carefully?
10:31:09 <ehird> a non-top-level N is undefined
10:31:14 <ehird> Rudolf: why
10:31:15 <vincenz> Cale: I was going to say "very painfully"
10:31:22 <vincenz> ehird: poorly defined data-type
10:31:25 <sieni> Rudolf: Usually the programs that are available want to translate Haskell to C
10:31:30 <ehird> vincenz: technicality
10:31:30 <ehird> ;)
10:31:33 <ehird> ok then:
10:31:34 <Cale> Rudolf: You can call C code from Haskell though, if you want.
10:31:40 <ehird> data Integer# = Z | S Integer#
10:31:47 <ehird> data Integer = P Integer# | N Integer#
10:31:49 <vincenz> data Integer = Bool * Integer#
10:31:52 <vincenz> or  that
10:31:58 <esap> ski: note that types of the elements of the stack are encoded in the type of the queue, so the type of the empty stack needs to be distinguishable.
10:32:02 <ehird> vincenz: *? Kill the camel!
10:32:08 <faxathisia> ehird: hmm.. data Integer a = Z :: Integer False ; S :: Integer False -> Integer False ; N :: Integer False -> Integer True
10:32:10 <esap> ski: s/queue/stack/
10:32:14 <vincenz> ehird: data-type algebraics
10:32:25 <vincenz> ehird: that's std notation
10:32:31 <Rudolf> sieni: i haved write a C code, and now i wish to run in haskell to better results, i think!
10:32:44 <vincenz> list x = mu l . 1 + x*l
10:32:50 <RudolfRentier> hiho
10:32:54 <Rudolf> Cale: how? have you a link explaining something like that?
10:33:00 <Cale> @where ffi
10:33:00 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:33:01 <ehird> vincenz: yes, but still
10:33:02 <ehird> :)
10:33:05 <sieni> Rudolf: well, I think you could try to rewrite the thing in Haskell
10:33:07 <Cale> That link describes the FFI
10:33:16 <vincenz> ./kick ehird "no antfucking allowed"
10:33:16 <Rudolf> sieni: i'm noob on haskell
10:33:24 <Cale> If you want to rewrite the code in Haskell, well, there's no straightforward way.
10:33:34 <Cale> You just have to, well, rewrite it.
10:33:35 <ehird> ANTFUCKING?! WHERE?! I mean uh.
10:33:39 <sieni> Rudolf: well, do you want to rewrite your code in haskell or call existing c code from haskell?
10:33:48 <ehird> Cale: that is, until I write hs2c. :P
10:33:51 <shapr> Excuse me?
10:33:53 <ehird> Rudolf: what logic is behind that.
10:34:03 <Cale> ehird: Uh, he wants the other one.
10:34:12 <vincenz> ehird: it's a dutch term, another is mosquito-sifting
10:34:13 <ehird> Rudolf: 'I wrote this C code.. but Haskell is better! If this gets converted to Haskell, it'll be better'
10:34:37 <lament> ehird: hs2bf, surely?
10:34:40 <vincenz> ehird: basically being precise to the point of being obnoxious (like when you pointed out the ' ' in /topic)
10:35:04 <faxathisia> more spaces would be good..
10:35:10 <Rudolf> sieni: rewrite
10:35:11 <karma_> faxathisia, i've googled some information about Agda 2 and your idea looks good for me. may be you can be advisor/mentor for this project?
10:35:12 <ehird> err
10:35:13 <vincenz> > repeat ' '
10:35:14 <ehird> i meant
10:35:15 <lament> I just need my spaces!
10:35:15 <ehird> c2hs
10:35:15 * faxathisia notes that you can't click certain links in some IRC clients
10:35:15 <ehird> :P
10:35:17 <glen_quagmire> how would you store operations in Data.Map?  in the interpreter i'm writing, I want to store ("+", actual code that'll add 2 numbers)
10:35:19 <Rudolf> ehird: have logic in human wishes?
10:35:20 <ilyak_> Have haskell got a good de-facto framework for processing XML?
10:35:29 <lambdabot>  thread killed
10:35:29 <vincenz> faxathisia: go program in whitespace
10:35:34 <ehird> Rudolf: You'd better have logic when thinking about programming..
10:35:34 <shapr> ilyak_: Yes, HaXml and HXT
10:35:35 <sm> random thought while waking this morning: how hard would it be to expose the entire python or perl libs for use in haskell apps ?
10:35:35 <ilyak_> Not just parsing or serializing, but processing, like DOM.
10:35:37 <vincenz> :t repeat
10:35:37 <lambdabot> forall a. a -> [a]
10:35:40 <vincenz> o.O
10:35:41 <ehird> But hey, if you wish for it, maybe the compiler will do it for you!
10:35:41 <faxathisia> karma_: What would that entail?
10:35:42 <vincenz> > repeat ' '
10:35:43 <lambdabot>  "                                                                           ...
10:35:46 <ilyak_> Ok, I'll look at those
10:35:46 <Rudolf> ehird: heuheiuheiuheiuhe, nice answer
10:35:56 <dcoutts> glen_quagmire: Map.insert "+" (+)  but it'll only work if all your ops are the same type
10:36:01 <ehird> Rudolf: But learn haskell. write new programs in it.
10:36:05 <ehird> Forget about automatically converting C programs.
10:36:06 <sieni> Rudolf: well, there is this tutorial: http://www.haskell.org/~pairwise/intro/intro.html
10:36:08 <lambdabot> Title: Haskell for C Programmers
10:36:13 <ehird> sieni: not what he wants
10:36:16 <Rudolf> ehird: yeah, yeah, i'm downloading the docs
10:36:22 <shapr> sm: You'd need to serialize values between the languages, yeah? Have you seen CosmicRay's Haskell <-> Python interop libs?
10:36:24 <Rudolf> sieni: reading yet
10:36:35 <sm> hi shapr.. no I have not
10:36:37 <glen_quagmire> dcoutts: then Map's type is String (Num a => a -> a) i think. yah that's the problem
10:37:02 <sieni> Rudolf: if haskell feels too difficult, you might also consider trying scheme and get hold of some basic techniques like spanking lambdas
10:37:27 <ehird> spanking lambdas
10:37:29 <ehird> that's brilliant
10:37:38 <glen_quagmire> many of interperters i looked at do pattern matching and call + explicitely
10:38:06 <RudolfRentier> what would be the right(tm) way to implement a new widget with gtk2hs? (deriving DrawingArea for custom actions, overloading? or is my grasp of the type system still incomplete Oo ?)
10:38:10 <glen_quagmire> maybe Map String SomeMonad might do
10:38:11 <karma_> faxathisia: giving me some points to start my research: publications, documentation, software tools. so you can give me some key points and brief idea and I'll try to write good and detailed proposal.
10:38:13 <shapr> hiya sm, long time no chat
10:38:20 <wli> sieni: What's spanking lambdas?
10:38:41 <dons> ?users
10:38:41 <lambdabot> Maximum users seen in #haskell: 471, currently: 447 (94.9%), active: 31 (6.9%)
10:38:46 <Rudolf> RudolfRentier: you have nice name!!!!
10:39:00 * sm finds MissingPy, ePolyglot and http://wiki.python.org/moin/PythonVsHaskell
10:39:02 <RudolfRentier> yeah, ^^ i noticed
10:39:06 <shapr> sm: Yup, that's it.
10:39:17 <Rudolf> RudolfRentier: huehiuehieuhieu
10:39:31 <RudolfRentier> XD
10:39:53 <dcoutts> RudolfRentier: for custom drawing, just using a DrawingArea and connecting to the expose methods etc, if you like you can wrap it in a newtype or something
10:40:01 <sm> cool.. seems like something that could be promoted
10:40:12 <shapr> sm: Go for it! Promote it!
10:40:18 <faxathisia> karma_: I'm able to do that but what's the administrivia like (do I have to sign a form or something?)
10:40:26 <ilyak_> By the way, why do people call Haskell declarative all the time?
10:40:33 <sm> well, I'll test it a bit to start :)
10:40:36 <ilyak_> I'm yet to see anything declarative in it.
10:41:00 <sm> in next $HASKELL_HOUR
10:41:33 <ilyak_> That category [|,,] list thing might be, if it wouldn't be fancy way to do monadic list operations.
10:41:39 <Cale> ilyak_: Well, the = sign in function declarations and pattern bindings is relatively declarative.
10:41:40 <RudolfRentier> dcoutts: okay i'll do that then, but if i wanted to actually create a widget in the gobject-type-system ... is that even possible? (without extra ffi)
10:41:41 <karma_> faxathisia, i hope you can get most of the answers here: http://code.google.com/support/bin/topic.py?topic=10442
10:41:42 <ilyak_> Other than that, yet to see
10:41:52 <dons> dcoutts: around?
10:42:26 <dcoutts> RudolfRentier: no we don't have support for that, but you don't really need to unless you have foreign code that really cares. To forien code that looks at the gtype it'll find it's a GtkDrawingArea.
10:42:28 <dcoutts> dons: yo
10:42:33 <Cale> ilyak_: One is declaring that the two sides are equal, and indeed, the language does ensure that one can be replaced by the other in any expression.
10:42:48 <karma_> faxathisia, anyway soc 2008 wasn't announced yet but i believe it will take place this year as it was last 3 years :)
10:42:50 <faxathisia> karma_: In that case, I don't think I'm applicable. I'm not "A group like Ubuntu or the Python Software Foundation."
10:42:52 <Cale> (of course, not necessarily in the definition itself)
10:42:53 <RudolfRentier> dcoutts: yeah, okay. thx then :-)
10:43:11 <lambdabot> Title: Google Code FAQ
10:43:11 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
10:43:42 <Cale> ilyak_: Related to this is that there are no side effects of evaluation.
10:43:54 <karma_> faxathisia, Haskell participated in last year Summer of Code, so you just can be mentor of haskell.org organization
10:44:23 <shapr> karma_: The past two years actually, I have two t-shirts!
10:44:29 <sw17ch> is there a flag to pass to cabal install which will build the package for profiling?
10:44:36 <sw17ch> or is that done automagically and i don't know it
10:44:39 <shapr> And if everything works out, I'll be a student this summer, and I can participate again!
10:44:41 <karma_> shapr: i've got only one :(
10:44:43 <mux> I lost my google SoC t-shirt :-(
10:44:47 <shapr> mux: horrors!
10:44:52 * mux cries
10:44:54 <faxathisia> Don't you get paid for participating?
10:45:01 <dons> Igloo: around?
10:45:08 <mux> faxathisia: $500 IIRC
10:45:19 <mux> as for me, the money wen to the FreeBSD foundation
10:45:19 <shapr> faxathisia: Yeah, but I don't care about that. I want the t-shirt and the cool code.
10:45:22 <karma_> faxathisia, every mentor earns 500$ and student 4500$, so 5k for every successful project
10:45:25 <mux> so no bucks, and no t-shirt :)
10:45:41 <shapr> For me, the money went to the haskell.org foundation.
10:45:52 <Cale> --enable-library-profiling
10:46:02 <Cale> sw17ch: ^^
10:46:16 <ilyak_> Cale: well, why is it more declarative than in C, let's say?
10:46:20 <faxathisia> shapr, I had a lot of fun last year.. worked together with some one doing a SoC project (I just did it for fun though)... I have a debt now and no t-shirt :P
10:46:20 <ilyak_> Cale: That's "pure"
10:46:35 <Cale> ilyak_: Purity is a form of declarativeness.
10:46:41 <ilyak_> If we replace = with { ... }, will it become less declarative? :)
10:46:53 <ski_> no
10:46:54 <Cale> No.
10:47:02 <ehird> { ... } is just more ugly
10:47:11 <ehird> an indentation based syntax is more elegant, and fits with haskell's mathematical style
10:47:16 <ilyak_> Well, I don't really understand why they use 'declarative' if there are 'functional' and 'pure'
10:47:26 <ilyak_> And what's the difference between that
10:47:32 <ehird> declarative means that you tell the compiler what to do
10:47:33 <ehird> not how
10:47:34 <faxathisia> karma_: Can multiple students do one project?
10:47:47 <ehird> that applies kind of to haskell, but not strictly
10:47:49 <sw17ch> Cale: how does one ... reinstall a package with that option then... (new to cabal install)
10:47:50 <ski_> logic programming is also considered declarative
10:47:55 <Cale> ilyak_: Another thing is that the evaluation order of Haskell isn't defined.
10:48:04 <ilyak_> Cale: That's 'lazy'
10:48:07 <Cale> No
10:48:13 <Cale> lazy is a particular evaluation order
10:48:19 <mux> non-strict is ensured
10:48:21 <mux> isn't it?
10:48:29 <Cale> (which is the most common implementation mechanism for Haskell)
10:48:34 <esap> ski: what do you think of it?
10:48:37 <Cale> mux: right
10:48:42 <mux> phew!
10:49:00 <smtms> GSoC students work alone
10:49:10 <karma_> faxathisia, actually, google doesn't allow it, but i think it's ok if organization allows it
10:49:18 <sm> MissingPy is support for and a hand-crafted bridge for a few python libs.. so I wonder how to get the whole enchilada automatically. Swig ?
10:49:23 <Cale> Haskell has non-strict semantics, but its evaluation order isn't defined -- so if implementations don't want to do lazy evaluation, they can do whatever they want, as long as the result is the same.
10:49:43 <Cale> (i.e. termination behaviour is preserved)
10:50:00 <Cale> This is used all over in various optimisations.
10:50:04 <mux> so, any news about Haskell'? I heard someone saying it has stalled
10:50:12 <shapr> I heard that too.. maybe we should give it a shove?
10:50:24 <shapr> Someone recently told me that I should give Haskell' a shove...
10:50:51 <Cale> I kind of stopped caring about Haskell' when I heard that it was mainly focused at standardising current practices.
10:51:19 <mux> I think standardising at least a good set of commonly used and needed extensions is quite important
10:51:46 <mux> Cale: maybe you want to work on Haskell'' ? :-)
10:51:50 <Cale> I suppose it's important for the YHC and JHC people :)
10:51:55 <Cale> I want to work on Haskell 2
10:52:00 <esap> Maybe the idea is to avoid the C++ syndrome of adding things to a standard before having any implementations.
10:52:20 <Cale> esap: yes, and that's fine :)
10:52:33 <mux> yeah that makes a lot of sense
10:52:36 <shapr> Cale: What about calling in #Haskell and making up a prototype for people to play with?
10:52:36 <Cale> esap: It's just that I don't really find the process so interesting. :)
10:52:47 <shapr> #Haskell is very punny when you think of C#
10:53:04 <mux> but there are quite a few extensions implemented by most haskell compilers and that are widely accepted as useful
10:53:19 <lament> they have C Sharp, we have Haskell Shapr :)
10:53:25 * shapr laughs
10:53:35 <esap> Cale: well processes on things as complex as deciding on a set of features in a programming language have to be complex.
10:53:52 <mux> for instance, adding FDs to Haskell' is probably a bad move, but standardising generalized newtype deriving doesn't hurt...
10:54:06 <mux> or pattern guards, at least!
10:54:08 <shapr> I dunno, I like the idea of throwing together a prototype, trying to write stuff, and turning up problems that way.
10:54:30 <Cale> esap: I'm totally okay with the practice of standardising only on existing features, it's just that I'm more interested in possible new language features than old ones.
10:54:47 <esap> Cale: heh, me too :-)
10:55:27 <mux> Cale: so, what kind of features are you thinking of for haskell 2?
10:55:56 <gwern> mux: don't set him off again...
10:56:17 <Cale> mux: Row polymorphism, extensible records and variants, class aliases, fix the prelude...
10:56:18 <mux> sorry, I've been AFK a few days ;-)
10:56:21 <gwern> Cale: have you written up your thoughts yet? then we could add ?cale flag and save you a tremendous amount of effort
10:56:33 <Cale> mux: I've gone over this upwards of 50 times :)
10:56:51 <mux> time to start #haskell-cale
10:57:16 <Cale> Fix the Monad class (remove fail, add join, make it a subclass of Functor or Applicative)
10:57:23 <mux> rawr
10:57:23 <Cale> Fix the associativity of $
10:57:35 <resiak> wiki page!
10:57:53 <Cale> map = (.) = functorial application ;)
10:58:04 <mux> that one I don't like much :-P
10:58:14 <Cale> It'll be cool, trust me
10:58:16 * glguy has been seeing far too much  f . g $ x lately
10:58:26 <esap> Cale: My "most-hoped-for" feature is clearly total functions and proofs by diagonalization.
10:58:37 <dcoutts> glguy: what don't you like about that?
10:58:53 <Cale> esap: By 'clearly total functions', do you mean that partial functions have different types?
10:58:55 <glguy> offends my eyes?
10:59:04 <Cale> glguy: what's wrong with it?
10:59:05 <faxathisia> esap, do you have an example of proof by diagonalization?
10:59:07 <esap> Cale: yes.
10:59:13 <glguy> just seems like a far too eager use of .
10:59:20 <glguy> . for its own sake
10:59:22 <ski_> (esap : i'm still thinking on it ..)
10:59:25 <gwern> glguy: you'd prefer f $ g $ x?
10:59:31 <glguy> f $ g x
10:59:38 <esap> faxathisia: sure.
11:00:05 * ski_ prefers `f . g $ x', but is not sure about using `(.)' for `[f]map' ..
11:00:08 <glguy> I can see . . . . $ (long chain)
11:00:13 <mux> I sometimes just write f (g x)
11:00:16 <glguy> but the f . g $ x is just gratuitous
11:00:19 <mux> if it's just for one pair of paerntheses
11:00:27 <Cale> esap: I'm not sure if I'm ready to give up transparent Turing completeness yet. It's obvious that all programs factor pretty cleanly into an IO and non-IO part via a sort of model-view-controller, but it's not so clear with regard to Turing completeness.
11:00:39 <mux> but f . g $ x at least stresses function-level programming
11:00:39 <gnuvince> I'd do f $ g x personnally. (Haskell newb)
11:00:59 <esap> faxathisia: How about the proof that there are irrational numbers.
11:01:11 <Beelsebob> gnuvince: I'd do the same
11:01:28 <Cale> ski_: Did you see the associativity thing regarding that?
11:01:37 <esap> Cale: The problem is that it's undecidable which side different things go to when you get to hard-enough problems.
11:01:53 <faxathisia> esap, I've seen one in real analysis, Don't know what diagonalization is
11:02:26 <dcoutts> glguy: in reality of course it's (f . g $ x) and f and g are probably much longer, so it's harder to read as ((long thing . other longer thing) arg)
11:02:29 <Cale> The thing that convinced me that (.) = [f]map is that the law fmap (f . g) x = fmap f (fmap g x) translates to: (f . g) . x = f . (g . x)
11:02:45 <Cale> er, that convinced me it's a good idea
11:02:45 <sw17ch> if i want to have "cabal install" reinstall a package, how would i go about doing that...
11:02:56 <dcoutts> glguy: when the () are spanning a lot of text and are nested it becomes harder to see what they cover at a glance
11:03:12 <esap> faxathisia: Consider a listing of all rational numbers as decimal sequences. You can prove that there is a number that can be expressed as a decimal sequence as follows.
11:03:20 <Cale> sw17ch: I suppose you could ghc-pkg unregister pkgname-version
11:03:23 <gwern> sw17ch: in the old version I use, you have to ghc-pkg unregister --user, and then reinstall
11:03:41 <esap> faxathisia: but which is not listed in the listing.
11:03:48 <dcoutts> sw17ch: at the moment it's not convenient, to upgrade you can specify the exact version like $ cabal install foo-1.1, to actually reinstall, do what Cale and gwern suggest.
11:03:54 <glguy> dcoutts: which is a sign one is trying to fit too much on a line
11:04:02 <sw17ch> oh, wow, thatnks
11:04:06 <sw17ch> :)
11:04:12 <dcoutts> glguy: perhaps
11:04:14 <ski_> Cale : hm, i'll have to think about that
11:04:14 <esap> faxathisia: You take the digits from the diagonal, e.g. first digit from first number, second digit from second number etc.
11:04:20 <faxathisia> esap, ah ok
11:04:29 <sw17ch> i needed to reinstall.. . i think? to enable profiling
11:04:35 <esap> faxathisia: then change the digits from the diagonal and you obtain a number that is not in the listing.
11:04:36 <faxathisia> esap, So you want the system to infer this kind of proof or what?
11:04:46 <sw17ch> i've written a program which consumes 2gigs of memory on a 4mb input :(
11:04:48 <gwern> I have a question, anyone know why 'dist/build/Pugs/Embed/Parrot_hsc.c:#include "Parrot_hsc.h"' would translate to the broken 'dist/build/Pugs/Embed/Parrot.hs:{-# INCLUDE "dist/build/Pugs/Embed/Parrot_hsc.h" #-}'?
11:05:07 <Cale> ski_: The one crucial property of (.) which I felt might be lost in generalisation was associativity, but since that's guaranteed by the functor law, we're okay :)
11:05:40 <gwern> sw17ch: nice ackermann implementation
11:05:42 <esap> faxathisia: Yes. This can be used to prove that some functions are not surjective, e.g. that there does *not* exist a fixed point for a particular function.
11:05:43 <dejones> Cale: what is a hylomorphism?
11:06:14 <Cale> dejones: It's the composition of a catamorphism (a fold) with an anamorphism (an unfold)
11:06:21 <dejones> lol
11:06:26 <sw17ch> gwern, ackermann implementation?
11:06:50 <ivan_> Cale: i have a problem with wrapping monads i want to wrap StateT r (ErrorT a IO) q and this will end in State(r -> Error(IO(Either a (q,r)))) right? but i want to have Either (q,r) a is this possible?
11:06:59 <Cale> dejones: That is, it's something which essentially builds up a datastructure recursively, and then collapses it again, replacing its structure with functions.
11:07:00 <dejones> Cale: how did you learn about catamorphism and anamorphism?
11:07:05 <gwern> sw17ch: think Ackermann function
11:07:25 <dejones> gwern: the Ackermann function is fun to bring computers to a crawl.  :)
11:07:33 <Cale> dejones: A funnily named paper called "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire"
11:07:34 <sw17ch> ah, alright :)
11:07:37 <Cale> http://citeseer.ist.psu.edu/meijer91functional.html
11:07:41 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
11:07:44 <roconnor> @unmtl StateT r (ErrorT a IO) q
11:07:45 <mauke> @unmtl StateT r (ErrorT a IO) q
11:07:45 <lambdabot> r -> IO (Either a (q, r))
11:07:45 <lambdabot> r -> IO (Either a (q, r))
11:07:51 <dejones> Cale: lol, clever title.
11:07:51 <esap> faxathisia: There is a great presentation of diagonal proofs in "Lawvere&Rosebrugh: Sets for Mathematics".
11:07:52 <dcoutts> gwern: hmm, that looks like a rairly used hsc2hs feature that cabal doesn't support.
11:08:05 <gbacon> @botsnack
11:08:06 <lambdabot> :)
11:08:11 <dcoutts> gwern: does the original .hsc source file contain #def lines?
11:08:22 <Cale> dejones: It refers to the notation they use, which involves different kinds of brackets stacked on top of one another.
11:08:31 <esap> faxathisia: And also, see http://en.wikipedia.org/wiki/Cantor%27s_diagonal_proof
11:08:32 <lambdabot> Title: Cantor's diagonal argument - Wikipedia, the free encyclopedia
11:08:39 <gwern> dcoutts: it has {-# OPTIONS_GHC -fglasgow-exts -cpp -fvia-C -fno-full-laziness -fno-cse #-}
11:08:39 <mauke> @unmtl ErrorT a (StateT r IO q)
11:08:39 <lambdabot> err: `ErrorT a (r -> IO (q, r))' is not applied to enough arguments.
11:08:42 <gwern> #if !defined(PUGS_HAVE_PARROT)
11:08:47 <mauke> @unmtl ErrorT a (StateT r IO) q
11:08:48 <lambdabot> r -> IO (Either a q, r)
11:08:49 <ivan_> roconnor: but is it possible to get Either (q,r) a ???
11:09:25 <roconnor> ivan_: that isn't conventional
11:09:36 <Cale> esap: So what exactly do you mean by a proof by diagonalisation in the context of a language feature? Some kind of type system thing?
11:09:40 <dcoutts> gwern: hsc2hs has this feature where it can contain embedded C code and spit out a .c file which we're supposed to compile and link with the final lib. However Cabal knows nothing about that. I only discovered that hsc2hs feature yesterday in fact.
11:09:40 <dejones> Cale: Interesting. I'll have a read.  :)
11:09:47 <ehird> @
11:09:51 <dcoutts> gwern: you're looking for a #def line somewhere in the .hsc file
11:09:58 <roconnor> ivan_: you would have to hide and redefine all the standard Either e monad instances.
11:09:59 <dejones> Cale: Are you a student?  Professor?  I think I may have asked you this before... I forget.
11:10:04 <Cale> dejones: student
11:10:05 <ehird> @type flip flip x
11:10:06 <lambdabot> Not in scope: `x'
11:10:08 <dejones> Cale: where?
11:10:12 <ehird> @type flip flip (:)
11:10:12 <lambdabot> forall a c a1. (a -> (a1 -> [a1] -> [a1]) -> c) -> a -> c
11:10:17 <roconnor> ivan_: and then your code wouldn't compose with other code because of the global nature of instances.
11:10:20 * dejones is a Master's student in CS.
11:10:21 <ehird> @type flip $ flip (:)
11:10:21 <lambdabot> forall b. b -> [b] -> [b]
11:10:22 <mauke> @type flip flip ?x
11:10:23 <lambdabot> forall a b c. (?x::b) => (a -> b -> c) -> a -> c
11:10:30 <dcoutts> gwern: what is the url for this .hsc file? I'd like to see.
11:10:35 <Cale> I was at Waterloo, just finishing up an additional course before applying to masters programs.
11:10:37 <ehird> @type flip $ flip id
11:10:37 <lambdabot> forall a c. (a -> c) -> a -> c
11:10:42 <gwern> dcoutts: maybe 'Parrot_hsc.h:#define PARROT_HSC_H
11:10:46 <gwern> dcoutts: it's pugs
11:10:56 <Cale> (by correspondence)
11:10:58 <esap> Cale: yes. I want to prove in the type system that fixed points do not exist in one half of the language.
11:11:19 <gwern> dcoutts: if you dl the pugs repo, look at a 'NOTES-pugs-ghc681.txt' which describes the problem and how to fix it
11:11:23 <dcoutts> @where pugs
11:11:23 <lambdabot> http://www.pugscode.org/
11:11:27 <ivan_> @unmtl ErrorT q (StateT r IO) a
11:11:27 <lambdabot> r -> IO (Either q a, r)
11:12:26 <ehird> @type flip
11:12:28 <dejones> Cale: student in what?  math?  what area(s) are you interested in?
11:12:29 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:12:30 <dejones> bah, I keep lagging out
11:12:31 <dcoutts> gwern: which dir would I find that NOTES-blah file in?
11:12:32 <ehird> @type flip flip
11:12:33 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
11:12:36 <esap> Cale: Consider the surjectivity of a map f : X -> 2^X. The non-existence of a surjective map of this type can be proved by diagonalization.
11:12:39 <ehird> @type flip flip flip
11:12:39 <Cale> dejones: Pure mathematics, yeah.
11:12:39 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
11:12:42 <ehird> hrmm
11:12:43 <dcoutts> gwern: there are a lot of dirs in the pugs repo! :-)
11:13:04 <gwern> dcoutts: toplevel
11:13:24 <dejones> Cale: Cool.  What was the motivation in learning Haskell?
11:13:27 <Cale> dejones: My specific interests are in things where algebra meets up with something more concrete, like algebraic combinatorics/geometry/topology.
11:13:27 <dcoutts> gwern: hmm, not there. http://darcs.pugscode.org/
11:13:28 <dejones> * your motivation
11:13:28 <lambdabot> Title: Index of /
11:13:32 <esap> Cale: But it depends on the existence of a "not : 2 -> 2" mapping, which is *fixed-point-free*.
11:13:46 <gwern> dcoutts: yes, pugs has a very... interesting buildprocess. I've given up on hackaging it because it seems almost deliberately incestious, but I'd like it to build on 6.8.2 at least...
11:13:56 <gwern> dcoutts: I think the darcs repo is outdated. they run out of subversion
11:14:01 <Cale> dejones: I mentioned to someone that I was interested in constructing an algebraic reformulation of music theory, and he pointed me at Haskore.
11:14:17 <ehird> @djinn (a -> a) -> a
11:14:17 <esap> Cale: That clearly doesn't work if all types have the 'undefined' element.
11:14:17 <lambdabot> -- f cannot be realized.
11:14:23 <ehird> djinn doesn't know about no fixed points
11:14:24 <Tomh-> hey, does haskell have support for arrays and O(1) lookup time or is everything usually done with lists and recursion?
11:14:34 <glguy> Tomh-: it has arrays
11:14:35 <ivan_> @unmtl StateT q (ErrorT r IO) a
11:14:35 <lambdabot> q -> IO (Either r (a, q))
11:14:43 <gwern> ?faq
11:14:47 <lambdabot> The answer is: Yes! Haskell can do that.
11:15:13 <Tomh-> glguy, i see ok and is haskell fast like those like almost equally fast as C ?
11:15:29 <mauke> if you really want, you can call malloc and use pointers
11:15:34 <Cin> tomh-: http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced#Arrays
11:15:35 <lambdabot> http://tinyurl.com/y4u7rv
11:15:37 <esap> Cale: So I'm thinking that having this ability in the programming language actually would imply that the language would be divided into two parts, where one of the parts would be amenable for mathematical proofs and the other could be used to write recursive functions.
11:15:39 <mauke> it's not a very common thing to do, though
11:15:40 <Baughn> lambdabot: Oh, good. I was worried it might not fit well in this microcontroller.
11:15:40 <dejones> Cale: Heh, that algebraic reformulation of music theory sounds complicated.  ;)
11:15:48 <Tomh-> ok
11:15:58 <Tomh-> and compared to java?
11:16:03 <Tomh-> haskell is much faster right?
11:16:05 <Cale> Tomh-: It's usually not so hard, once you know what you're doing, to get within maybe 2 or 3 times the C performance.
11:16:27 <Cale> Tomh-: Which is usually quite practical :)
11:16:33 <dejones> Cale: any gotchas to watch out for in the performance area?
11:16:36 <glguy> heh
11:16:47 <Cale> dejones: Avoid using lists for things that lists are bad at.
11:16:51 <Baughn> Tomh-: Performance, in any language, is often dominated by algorithm choice. Pick a better, harder to write algorithm. :P
11:17:14 <Tomh-> baughn, ye but say i got the optimal algorithm, i now want the fastest language :)
11:17:17 <dejones> Cale: Ahh, okay, normal algorithm design techniques then.  :)
11:17:21 <glguy> Tomh-: assembly
11:17:24 <dejones> lol
11:17:27 <Cale> Specifically, try to avoid using lists as sets, and don't use lists of pairs as association maps, unless they're very small, or you're always processing them linearly.
11:17:30 <Baughn> Tomh-: VHDL
11:17:33 <Tomh-> the fastest language which doesn't suck ;P
11:17:34 <dcoutts> gwern: grr, why don't people report these kinds of bugs? It's clearly a weird interaction btween hsc2hs and cabal.
11:17:43 <Beelsebob> Baughn: just because it's a better algorithm, doesn't mean it's harder to write
11:17:52 <Beelsebob> quicksort is much easier to write than bubblesort for example
11:17:52 <glguy> yeah, just look at bubble sort
11:17:56 <Beelsebob> heh
11:17:58 <gwern> and once you've written in assembly, then you can apply genetic algorithms to optimize even more!
11:18:01 <Cale> dejones: That's the single largest piece of advice I could give to a beginner, at least :)
11:18:16 <Baughn> Beelsebob: Not always, but in my experience "better algorithm" = "more AI-ish"
11:18:19 <glguy> before the unevaluated thunk!
11:18:26 <glguy> beware*
11:18:31 <Tomh-> i need to write a game in haskell
11:18:32 <ivan_> is it possible to do the @unmtl in ghci?
11:18:32 <Cale> dejones: The rest of it is all about understanding lazy evaluation so that you can have some idea of what things will perform well.
11:18:36 <dejones> Cale: Well, I'm luckily not a beginner in algorithms, just Haskell.  ;)
11:18:41 <Baughn> Beelsebob: Not, of course, for microtasks like "sort this list", but nobody ever really wants that
11:18:47 <Tomh-> and run that like 100k times to evolve my AI
11:18:49 <Cale> dejones: Do you know how lazy evaluation works?
11:19:01 <Tomh-> so i wanna use something really fast like C or haskell :)
11:19:02 <gwern> dcoutts: well, it seems to've only poped up with 6.8.x; two, it's kind of hard to explain (I'm not even sure how all the files in that directory interact), and three, it's relatively easy to fix, and anyone hitting it has much bigger concerns w/r/t compiling pugs
11:19:07 <Beelsebob> Baughn: no, but just because it's a small task, doesn't mean the logic doesn't apply
11:19:10 <dejones> Cale: Conceptually, I do, yes.  Only evaluate the code as-needed.
11:19:15 <dejones> correct?
11:19:19 <Beelsebob> in fact often, better algorithms are just plain more beautiful
11:19:27 <glguy> Tomh-: writing fast code in Haskell (like in C) is something you'll need to learn to do
11:19:32 <gwern> dcoutts: also, it's not obvious whose fault it it - the pugs maintainers, hsc2hs, cabal, ghc...
11:19:33 <Cale> dejones: Well, yes, but it's actually almost simpler than that.
11:19:42 <dcoutts> gwern: so long as the fix is not to ever mention "dist/build" then it's ok.
11:19:48 <dejones> Cale: Evaluate the code lazily?  :P
11:19:51 <Cale> dejones: The first thing is that code is evaluated outermost first.
11:19:54 <dcoutts> gwern: sure I don't expect people to figure out the cause, just to report it.
11:19:57 <esap> beelsebob: but being beautiful is not a good criteria for efficiency.
11:20:01 <dejones> How's that for a circular definition.  ;)
11:20:09 <Baughn> Beelsebob: I've yet to seen a practical problem that can't usually be optimized in particular instances by having humans figure out something for that instance of the problem
11:20:22 <Baughn> Beelsebob: If you can do that, then you can also write a smarter program to do some of the same optimization
11:20:23 <dcoutts> gwern: it could have been reported to the ghc folk or cabal, either would do. We could have figured out where the problem was.
11:20:31 <Cale> dejones: The second is that when a parameter to a function is duplicated in the body, its evaluation is shared between the copies.
11:20:38 <Beelsebob> esap: no, I didn't say that -- I said that efficiency is not a good criteria for "not beautiful"
11:20:47 <Cale> dejones: and that's all there is to it.
11:20:50 <Beelsebob> i.e. just because it's fast doesn't mean it's not nice
11:21:06 <Baughn> No, I'd say speed is orthogonal to beauty
11:21:06 <ivan_> any 1 about the lambdabot @umntl in ghci
11:21:12 <gwern> dcoutts: also the pugs folk seem to have a very laissez-faire attitude. I still don't know how they all could've refrained from updating for 6.8.x, .1 and .2 have been out for months and months and months
11:21:16 <Baughn> There's a strong correlation between beauty and maintainability, of course
11:21:21 <Cale> dejones: But you really have to try evaluating some things by hand for a bit in order to get a feel for it.
11:21:22 <Beelsebob> agreed
11:21:33 <glguy> you guys are making vacuous arguments about efficiency and beauty
11:21:36 <Tomh-> glguy, whats so different about that then?
11:21:42 <Tomh-> lots of compiler optimizations or?
11:21:53 <Cale> My favourite example, which some people around here are counting the number of times I give it, is to define the function:
11:21:53 <glguy> different about what?
11:21:59 <Tomh-> then usual haskell
11:22:00 <Cale> double x = x + x
11:22:11 <Cale> and then evaluate the expression double (double 5)
11:22:16 <esap> beelsebob: I'm sure there are very beautiful but slow algorithms. Consider mathematics. People think in terms of the infinite and non-constructible. Mathematics is full of beautiful but unimplementable things.
11:22:16 <Cale> under a few mechanisms :)
11:22:20 <glguy> Tomh-: I'm just saying that simply using Haskell won't make your code fast
11:22:35 <dcoutts> gwern: so you see src/Pugs/Embed/Parrot.hsc, it's got these #def lines (not #define). Those are hsc2hs directives to spit out stuff into a generated .c and .h file. That .c file is supposed to be compiled and linked with the lib. Currently cabal does not do that, so there are only workarounds.
11:22:39 <Tomh-> no but say i have the exact same program in like java
11:22:41 <Baughn> Beelsebob: In a sense, bogosort is very elegant. :)
11:22:45 <Tomh-> haskell will perform better?
11:22:54 <Valodim> YES
11:22:56 <dejones> Cale: Shared between the copies of the name of the parameter, as in, they both point to the same location in memory?  So, once it is evaluated as a parameter to the function, it is not evaluated again later in the function.
11:22:56 <dejones> ?
11:23:03 <Cale> dejones: right
11:23:11 <dejones> :)
11:23:21 <gwern> Cale: obviously you should use template haskell to evaluate it to a constant at compiletime! (and then you can maybe remove it as dead code) nothing faster than that
11:23:23 <glguy> Tomh-: There is no way to answer that question
11:23:27 <Cale> dejones: That would be one way to implement it, anyway.
11:23:28 <esap> beelsebob: And contrast that with all practical programming, which is full of hacks and tweaks...
11:23:36 <gwern> dcoutts: ew.
11:23:38 <dcoutts> gwern: I didn't know of that feature 'til yesterday, pugs is the second project I know of to be using that feature and using workarounds to get Cabal to compile the .c file. Cabal-1.2 broke the workarounds.
11:23:40 <Tomh-> ye i know it sounds like a stupid question :/
11:23:42 <Cin> tomh-: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
11:23:44 <lambdabot> Title: Create your own Ranking | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/lepfo
11:23:49 <Baughn> Cale: I vaguely recall something about the GHC garbage collector (accidentally?) collecting /semantic/ garbage as well as unreachable garbage. What was that about?
11:24:04 <gwern> dcoutts: so uh, can I rest assured you're on the case? :)
11:24:08 <gwern> dcoutts: second project?
11:24:15 <Cale> Baughn: hmm, I'm not sure I know what that would mean
11:24:19 <radix> Tomh-: you *can't* have the exact same program in java and haskell :)
11:24:29 <dcoutts> gwern: so the right solution is to file a Cabal feature request to get Cabal to notice those .c files and build them.
11:24:34 <mauke> radix: yes, you can
11:24:42 <mauke> polyglots!
11:24:43 <dcoutts> gwern: oh hscurses was the other.
11:24:49 <Beelsebob> esap: in my experience, no
11:24:51 <radix> mauke: maybe for some ridiculous definition of "exact same program"
11:24:54 <Beelsebob> if it's designed well, it's not
11:24:55 * esap thinks "semantic garbage" means the same as spam. Did it have a spam filter? :-)
11:24:59 <Cale> Tomh-: Haskell and Java are sufficiently different that translating between them is not a straightforward process.
11:25:09 <Baughn> Cale: It was recycling memory that still had pointers pointing to it, but only in the case where those pointers would never actually be used. That was before I started /using/ haskell, though.. quite a while back.
11:25:19 <Cale> Baughn: ah, okay
11:25:36 <Tomh-> cale, ye well its nothing complex, its just a reversi game ;p
11:25:44 <mauke> radix: http://mauke.ath.cx/stuff/poly.poly - doesn't do java, though
11:25:54 <Tomh-> basically checking out a 2-dimensional array
11:25:54 <gwern> huh. strnage. hscurses works fine for me
11:26:01 <Cale> Tomh-: That's certainly doable.
11:26:03 <sw17ch> is it typical to have a huge portion of the used memory as "void" ?
11:26:08 <dcoutts> gwern: only if you're using old cabal
11:26:09 <radix> mauke: yeah, that thing I said :P
11:26:10 <sw17ch> when doing a biogrpahical profile
11:26:22 <Tomh-> cale, ye tought so too
11:26:27 <radix> mauke: this is terrifying
11:26:27 <esap> Beelsebob: Well-designed doesn't mean beautiful. Well-designed means it satisfies all requirements, no matter how ugly they are.
11:26:28 <dcoutts> gwern: or perhaps you're using a different version of hscurses, I dunno.
11:26:28 <Baughn> Cale: There are partial algorithms for that, but what struck me was that the behaviour was thought to be a bug - and then declared a feature later
11:26:36 <dcoutts> gwern: all I know is we had to patch it in gentoo
11:26:42 <Cale> Baughn: hehe
11:26:49 <gwern> dcoutts: old == 1.2.3.0?
11:26:54 <Beelsebob> esap: if the requirements are ugly, you made the customer sign the wrong document >.<
11:27:08 * gwern is looking at darcs hscurses
11:27:17 <dcoutts> gwern: it would have works with cabal 1.0.x and broken with 1.2.x
11:27:22 <mauke> radix: >:3
11:27:43 <Cale> Baughn: GHC is probably on the brink of achieving some suitably type-safe form of consciousness.
11:28:04 <hpaste>  K0MPR3SS0R pasted "(no title)" at http://hpaste.org/5800
11:28:12 <Baughn> Cale: ..make sure you hide unsafePerformIO first
11:28:14 <K0MPR3SS0R> ok hi cale
11:28:19 <K0MPR3SS0R> i tried to give it a shot
11:28:20 <dcoutts> gwern: hscurses-20061106 has that problem at least, don't know about darcs version.
11:28:22 <radix> mauke: you're like that guy from A Scanner Darkly, except instead of not knowing whether you're a drug addict or a cop, you can't tell what programming language you're supposed to be working in
11:28:26 <K0MPR3SS0R> and still failing
11:28:29 <ivan_> Cale: is it possible to do the lambdabot @umntl command in ghci?
11:28:35 <K0MPR3SS0R> for some reason i cant figure it out
11:28:37 <Cale> ivan_: no
11:28:44 <lament> esap: "satisfies the requirements" is well-implemented, not well-designed
11:28:46 <Baughn> Cale: (Also, semantic garbage-collection is equivalent to the halting problem. That's quite an intelligence there.)
11:28:53 <ivan_> then i have to stay in this channel :p
11:29:04 <dcoutts> gwern: looking at the darcs version it still has the problem, it's listing C-sources: HSCurses/CWString_hsc.c HSCurses/Curses_hsc.c
11:29:21 <dcoutts> gwern: but those generated files don't live there anymore, they go under dist/build.
11:29:22 <Baughn> ivan_: You can /msg lambdie
11:29:43 <Baughn> ivan_: Also, there is a ghci patch somewhere to add lambdabot's functionality, but it may have succumbed to bitrot
11:29:44 <esap> lament: I suppose that's true. But design is also constrained by requirements.
11:29:55 <glguy> :t runState
11:29:57 <lambdabot> forall s a. State s a -> s -> (a, s)
11:30:04 <glguy> @unmtl State s a
11:30:04 <lambdabot> s -> (a, s)
11:30:09 <mauke> @where goa
11:30:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
11:30:10 <glguy> ivan_: ^^
11:30:18 <Cale> Yeah, you can use the type of the appropriate run function to approximate it.
11:30:34 <lament> esap: just from a programming perspective, consider a piece of beautiful code and a piece of ugly code doing the exact same thing. The beautiful code is better designed :)
11:31:04 <glguy> ugh
11:31:06 <gwern> ghci on acid?
11:31:06 <gwern> lambdabot broke it, iirc
11:31:25 <Tomh-> well thanks for the help all, gotta run
11:31:55 <esap> lament: It depends. Consider a beautiful code that isn't maintainable, and a piece of ugly code that is :-) Is that a contradiction?
11:32:17 <gwern> dcoutts: did you want me to file a bug report?
11:32:52 * glguy prefers blue code to red code
11:32:57 <dcoutts> gwern: that'd be great
11:33:01 <Cin> baughn: if you have: let a = foo; b = bar; c = mu in do a; b; c -- you could safely garbage collect 'a' once that action is done, couldn't you? i mean, is there any reason it should still exist for the duration of time b and c are computing?
11:33:18 <lament> esap: fine, consider a short, easily-readable, easily-maintainable and fast algorithm, and a long, incomprehensible, unmaintainable and slow algorithm doing the same thing :)
11:33:30 <K0MPR3SS0R> Can someone pls help me
11:33:33 <hpaste>  K0MPR3SS0R pasted "(no title)" at http://hpaste.org/5801
11:33:44 <Baughn> Cin: None, and it /would/ be garbage-collected. a is syntactic garbage at that point.
11:34:05 <Baughn> Cin: That is, assuming it isn't stuck on the stack to begin with. I don't quite understand the rules for that.
11:34:10 <Cin> baughn: ah, would ghc mark that as syntactic garbage? hm
11:34:36 <Baughn> Cin: It is syntactic garbage because there are no pointers to it. ;)
11:34:39 <Baughn> If you call that "mark"...
11:34:51 <Cin> baughn: (i was under the impression it would be collected after the 'let' finishes)
11:34:53 * Codex_ thinks all code is too difficult to read; recardless of how readable it is.
11:34:57 <sw17ch> is there a better way to convert a tuple to a list than: tupleToList (al,tl,cl,gl) = al : tl : cl : gl : []     ?
11:35:00 <esap> lament: Ok, it's clear which one is better designed.
11:35:12 <Baughn> Cin: For all practical purposes, the GHC garbage collector is sufficiently smart
11:35:35 <desegnis> sw17ch, I guess no
11:35:37 <mauke> sw17ch: f (a,b,c,d) = [a,b,c,d]
11:35:44 <Cin> baughn: right
11:35:49 <Baughn> Cin: ..something I often fail to point out - GHC is very nearly a sufficiently smart compiler.
11:35:55 <sw17ch> mauke, is there any difference in the two?
11:35:58 <mauke> no
11:36:34 <esap> lament: but there are also the other kind of "beautiful". For example, e^(i*pi) + 1 = 0  is beautiful, short etc. But would you implement '0' using it? :-)
11:37:13 * Baughn considers "0" more beautiful than "e^(i*pi)+1", so no.
11:37:13 <faxathisia> heh..
11:37:15 <mauke> > exp (0 :+ pi) + 1
11:37:20 <lambdabot>  0.0 :+ 1.2246063538223773e-16
11:37:24 <dcoutts> gwern: note that HsJudy has the same problem and additionally it does not work because it referrs to header files that are not in the tarball "../judy" !
11:37:39 <faxathisia> you can't define the e, ^, i, pi, + .. without zero
11:37:45 <gwern> dcoutts: http://hackage.haskell.org/trac/hackage/ticket/245
11:37:47 <lambdabot> Title: #245 (Cabal gets paths wrong in INCLUDEs) - Hackage - Trac
11:37:59 <Baughn> faxathisia: Sure you can. Zero is a relatively recent invention, in fact.
11:38:02 <lament> esap: implementing 0 that way would be pretty ugly.
11:38:09 <gwern> dcoutts: oh really? hm
11:38:10 <dcoutts> gwern: btw, I added a QA check for relative paths that start with "../" since that can't ever work for a distributed package.
11:38:11 <faxathisia> ok remove + and ^
11:38:22 <Baughn> faxathisia: Yes, we knew about pi and e before zero.
11:38:25 <roconnor> @where xkcd
11:38:26 <lambdabot> I know nothing about xkcd.
11:38:32 <esap> lament: exactly!
11:38:41 <gwern> dcoutts: yes, that's a good idea. I've seen more than a few packages (ab)using ../
11:38:45 <Stinger_> www.xkcd.com ?
11:38:46 <gwern> distract, for example
11:38:51 <lament> esap: are we arguing, or are we agreeing? :)
11:38:53 <Baughn> faxathisia: ..not i, granted
11:39:02 <esap> lament: violent agreement?
11:39:15 <faxathisia> Baughn, oh! .. well I guess my point kind of doesn't have any reasoning then
11:39:15 <dcoutts> gwern: and note that the ghc-options: blah/*.o  is more than a bit dodgy too
11:39:17 <lament> must be
11:39:33 <dcoutts> gwern: for one thing it breaks haddock :-)
11:40:07 <Baughn> faxathisia: To make things extra weird, "0" was used in positional notation (decimal? not sure) a long time before mathematicians were willing to accept it as a real number
11:40:09 <bos> the usual thing is to have a piece of autoconf goo to find the package.
11:40:50 <esap> lament: Well anyway, my point was that a design can be something else than beautiful and still be well designed.
11:40:55 <Cin> when you've got a function call spanning multiple lines, do you indent your parameters like lisp?
11:40:59 <Baughn> faxathisia: Missing the point there. Math isn't "real", and matheatical statements are never "true", only contradictory or non-contradictory.
11:41:27 <gwern> dcoutts: bah. haddock is so often broken anyway (those odd getword8:end of file error messages)
11:41:34 <Baughn> Cin: Mostly, I do whatever haskell-mode tells me to. Really need to fix that indenter..
11:41:37 <faxathisia> Baughn, I think it's fair to say a statement is true when you can prove it in the logic you work with
11:41:39 <esap> lament: But obviously this requires that the design criterion is not beauty, but something more practical.
11:41:52 <lament> esap: i use "beautiful" to mean "well-designed"
11:42:03 <Cin> baughn: ah, yeah. haskell-mode's actually does it like lisp. that's nice.
11:42:25 <Baughn> faxathisia: It'll be based on axioms that have no truth-value. If you put one apple next to another apple you get two apples, but that has no bearing whatsoever on the (nonexistent) truth value of "1+1=2".
11:42:43 <dcoutts> gwern: do you know why it happens? did you report it?
11:42:50 <mattam> Is there any unicode symbol resembling >>= ?
11:42:56 <dcoutts> gwern: btw, thanks for reporting the hsc2hs issue
11:43:10 <Baughn> faxathisia: In practice, all mathematical statements (except where explicitly disclaimed) have a preface of "assuming the commonly assumed axioms are in effect, this: ".
11:43:20 <Stinger_> mattam I beleive there is, don't ask me what though :P
11:43:34 <Stinger_> believe*
11:44:03 <Baughn> Cin: It'd be nicer if haskell's syntax wasn't fabulously ambiguous. Indentation /matters/, which means it can't be autogenerated.
11:44:03 <lament> esap: beauty = good design + quality construction, at least for engineering
11:44:09 <gwern> dcoutts: I've no idea. it seems to happen a lot in the gentoo packages, and I think I was told when I asked about it in #gentoo-haskell that it was a known bug
11:44:18 <Baughn> Cin: haskell-mode does a good job of placing it anyhow, but isn't sufficiently configurable for me
11:44:23 <Stinger_> http://en.wikipedia.org/wiki/Unicode_Mathematical_Operators
11:44:23 <lambdabot> Title: Unicode Mathematical Operators - Wikipedia, the free encyclopedia
11:44:47 <lament> Stinger_: oh wow, Perl guys should have a look at that table
11:44:51 <dcoutts> gwern: probably due to mixing haddock-0.x and 2.x
11:44:56 <Cin> baughn: yeah, sometimes i end up tabbing through the indent cycle about ten times and realise it has no idea what i want it to do, so i have to go to manual mode. like $ tends to confuse it
11:45:04 <matthew-_> is there anything other than GHC that does a good job of parsing Haskell with all the frills?
11:45:16 <Baughn> matthew-_: hugs?
11:45:22 <esap> lament: For mathematics, beauty = simple + elegant + powerful  (or something like that)
11:45:24 <matthew-_> *all* the frills?
11:45:41 <Baughn> matthew-_: Given that some of the frills include GHC extensions.. doubt it.
11:45:53 <Baughn> matthew-_: Let's face it, GHC effectively /is/ haskell
11:46:00 <gwern> haskell seems to be hard to parse for indentation
11:46:04 <matthew-_> shuush, don't tell ndm
11:46:19 <ivan_> if i wrap monads how do i know which actions i can do?
11:46:45 <matthew-_> ivan_: anything that is a method of any type class which is in context
11:46:46 <Cale> ivan_: Wrap them in which sense?
11:47:12 <sm> yesss.. emacs - hoogle - safari hooked up
11:47:15 <ivan_> StateT q (ErrorT s IO) a --like that, called transpose i think?
11:47:34 <ski_> transformer
11:47:35 <Cin> what do ‚ä¢ and ‚ä® mean? =o
11:48:17 <esap> lament: http://en.wikipedia.org/wiki/Mathematical_beauty
11:48:18 <faxathisia> A ‚ä¢ B usually means from the context/under the assumptions A we can derive B
11:48:28 <Cin> oh, nice
11:48:31 <Cale> ivan_: The mtl has lots of lifting instances which confuse the issue, but generally, the actions of the outer transformer are immediately accessible
11:48:44 <faxathisia> ‚ä® is often used when you already have defined ‚ä¢ but want to talk about two logics at once
11:49:01 <Cale> ivan_: The actions in the transformed monad have to be lifted
11:49:09 <Baughn> faxathisia: ..my font shows the two identically. :'(
11:49:20 <faxathisia> Baughn, |- and |=
11:49:27 <Cin> mine are kind of identical, the second's is too smoothed
11:51:20 <desegnis> I hate it when logicians define ->, =>, ||-, |= etc. in terms of each other
11:52:40 <monochrom> @src Eq
11:52:40 <lambdabot> class  Eq a  where
11:52:40 <lambdabot>     (==), (/=)   :: a -> a -> Bool
11:52:54 <faxathisia> desegnis, like mutually recurse definitions or what?
11:54:07 <Cale> desegnis: Who does that?
11:54:10 <desegnis> faxathisia, no, just quite confusing because there's a logic to define and a logic to think in, and I'm never sure what sign belongs where, and whether there are some intermediate logics to consider
11:54:13 <mib_xww707qb> anyone familiar with the knights' tour program (#91 from the wiki)?
11:54:38 <mib_xww707qb> entrances path pos =                 length (filter (`notElem` path) (knightMoves n pos))
11:54:45 <faxathisia> oh ok, well I'm not sure there's any alternative..
11:54:50 <mib_xww707qb> can someone explain the logic of this to me?
11:54:58 <Cale> desegnis: I suppose you just hope that there's a notation key in the front of the book.
11:55:24 * sm updates http://www.haskell.org/haskellwiki/Hoogle#Using_Hoogle_from_Emacs
11:55:25 <faxathisia> > filter (`notElem` [2,4,6]) [1,2,3,4,5,6]
11:55:25 <lambdabot> Title: Hoogle - HaskellWiki
11:55:28 <lambdabot>  [1,3,5]
11:55:29 <ivan_> @umntl WriterT r (Error q IO) a
11:55:29 <lambdabot> Maybe you meant: unmtl unpl
11:55:37 <ivan_> @unmtl WriterT r (Error q IO) a
11:55:38 <lambdabot> Error q IO (a, r)
11:55:45 <faxathisia> mib_xww707qb: See what happens there? I think that's most of the logic
11:56:19 <faxathisia> mib_xww707qb: You just filter out anything in path out from list of where the knight could move
11:56:26 <faxathisia> mib_xww707qb: then find the length
11:56:40 <ivan_> @unmtl Error q IO (a, r)
11:56:41 <lambdabot> Error q IO (a, r)
11:56:47 <lekro> when I update an element in a DiffArray I understand that the old version is still there, only the access times get slower. but when I don't have any references to all those old versions, does the garbage collector free the memory?
11:57:22 <lekro> e.g., I update all elements of the array hundreds or thousands of times and don't keep references to the old versions
11:57:29 <desegnis> Cale, I'm actually struggling with a book chapter which is supposed to be an introduction to propositional and predicate logic
11:58:31 <monochrom> I think most logic books suffer the same problem of not saying up front "there is meta logic and there is target logic".
11:58:45 <Lemmih> lekro: Yes, old values are garbage collected.
11:58:49 <dcoutts> gwern: I suppose it's the generated Parrot_hsc.c that contains the broken {-# INCLUDE ... #-} right? the source .hsc file doesn't contain that INCLUDE.
11:59:42 <monochrom> A compiler book would not make such a mistake. :)
11:59:58 <desegnis> Cale, the book distinguishes between the syntax of predicate logic, consisting of neg, \/, /\, ->, <->, T, _|_, and the meta language, which seems to range over |-, |=, English sentences, ...
12:00:16 <Lemmih> lekro: (You should know that the overhead of DiffArrays is quite big.)
12:00:16 <Cale> desegnis: sure
12:00:22 <monochrom> Computer Science: a better logic than Logic, a better philosophy than Philosophy.
12:00:37 <Cale> desegnis: What's confusing about that?
12:00:40 <desegnis> monochrom, the book says it but does not make clear to me the background and consequences of that
12:00:45 <gwern> dcoutts: I think my report mentions it's the final Parrot.hs in dist/ which has the bad include
12:00:55 <lekro> Lemmih: what I'm actually trying to do is model a 2-D pixel space
12:01:15 <Cale> desegnis: Your logic is a mathematical object consisting of a bunch of strings of symbols.
12:01:31 <Cale> desegnis: The point is probably to study that mathematical object.
12:01:42 <desegnis> Cale, it's stupid to say ¬ªImplication is defined by implication, but the former implication is a word of the target language, and the latter of the meta language¬´
12:01:44 <lekro> lekro: I was considering unboxed mutable arrays, but DiffArrays looked cleaner
12:01:55 <lekro> s/lekro/Lemmih
12:01:55 <Cale> desegnis: Yes, it is.
12:02:01 <Cale> desegnis: Does it say that?
12:02:13 <desegnis> no, but that's the impression I get ;)
12:02:19 <Lemmih> lekro: How about an STArray?
12:02:45 <Cale> desegnis: Or do you mean that in the definition of implication in the target language, there's a metalanguage implication?
12:02:57 <desegnis> Cale, if I study logic just as a mathematical object, how shall I guide my actual conclusions?
12:03:19 <Cale> What do you mean?
12:03:22 <desegnis> Cale, let me try and find a real sentence in the book showing that off
12:03:37 <desegnis> (might take a while, the book is thick :-)
12:03:57 <monochrom> A logic course is some kind of compiler course.
12:04:29 <Cale> If the logic that you're studying is sufficiently close to the metalogic, then you might be willing to lift statements about the target logic to conclusions about the metalogic, but it's not exactly rigourous to do so.
12:04:49 <monochrom> Some compilers compile target language functions into meta language functions, actually.
12:05:08 <lekro> Lemmih: I must admit that I've never used the ST monad. I'll check it out, thanks
12:05:21 <Cale> You might even actually be able to prove a lifting theorem of some sort.
12:05:35 <monochrom> "higher-order AST", IIRC
12:06:03 <ski_> HOAS ?
12:06:18 <Cale> If the axioms of your target logic correspond to true statements of your metalogic in some way, and derivation rules correspond to valid means of reasoning in your metalogic.
12:06:47 <Cale> Then you can translate any proof in your target logic into a proof in your metalogic.
12:07:20 <ivan_> @unmtl ErrorT q (State r IO) a
12:07:20 <lambdabot> err: `r -> (IO, r)' is not a type function.
12:07:28 <ivan_> @unmtl ErrorT q (StateT r IO) a
12:07:29 <lambdabot> r -> IO (Either q a, r)
12:07:38 <monochrom> When meta and target are similar enough, you begin thinking of GHC compiling GHC.
12:08:06 <desegnis> So there is a mapping in the book called B* : Form(P) -> {T,F}, and B* is defined with a set of equations going like this: B*(T) = T; B*(_|_) = F; B*(phi \/ psi) = T if B*(phi) = T or B*(psi) = T, F otherwise; ...
12:08:08 <ski_> monochrom : i think HOAS is about representing object-level binders with meta-level functions .. which i think is orthogonal to compiling object-language into meta-language
12:08:38 <desegnis> The confusing bit is defining \/ in terms of ¬ªor¬´
12:08:47 <dons> dcoutts: pushed the bytestring patch.
12:09:01 <ivan_> @unmtl State r (ErrorT a IO) q
12:09:02 <lambdabot> err: `ErrorT a IO' is not applied to enough arguments, giving `/\A. IO (Either a A)'
12:09:05 <ivan_> @unmtl StateT r (ErrorT a IO) q
12:09:05 <lambdabot> r -> IO (Either a (q, r))
12:09:10 <dcoutts> dons: great
12:09:18 <ski_> ivan_ : what are you after ?
12:09:33 <desegnis> Cale, I'm reading what you wrote...
12:09:40 <ivan_> transforming monad to get the Either switched
12:09:48 <gwern> Cale: you do know about my upload of nymphaea right?
12:10:08 <Cale> gwern: yep
12:10:08 <ski_> ivan_ : `r -> IO (Either (q,r) a)' ?
12:10:14 <ivan_> yes
12:10:29 <Cale> gwern: I mentioned that BSD3 is fine, but maybe you didn't notice. It is :)
12:10:30 <gwern> aight then. didn't see any acknowledgements
12:10:40 <Cale> and yeah, thanks :)
12:10:53 * gwern nods
12:10:58 <ski_> ivan_ : can you make that into a monad (abstracting `a') ?
12:11:05 <gwern> Cale: you got any other nifty projects not yet public?
12:11:26 <ski_> (ivan_ : AFP cgi monad ?)
12:11:48 <Cale> gwern: hmm, nothing sufficiently polished that I can think of.
12:12:21 <ivan_> ski_: yea i guess so, how do i find out all of the errorT instances? i guess i have to define the whole errorT monad
12:12:24 <Cale> gwern: I have scads of random code that possibly contains useful library functions, but it's not organised in any coherent way.
12:12:25 <gwern> phooey. guess I'll have to content myself with uploading a Space Invaders today
12:12:51 <doserj> gwern: btw. when I install nymphaea using cabal-install, it compiles and installs alright, but the binary doesn't find the .glade file at runtime
12:13:10 <desegnis> Cale, in re ¬ª Then you can translate any proof in your target logic into a proof in your metalogic¬´: But won't the logics involved look very alike? Isn't the target logic modeled to resemble the metalogic?
12:13:23 <Cale> desegnis: Not always.
12:13:34 <Cale> In fact, often not.
12:13:35 <gwern> doserj: gack. did you try cding to /usr/share/nymphaea or wherever the datafiles go?
12:14:01 <doserj> yes. then it works. (it is in $HOME/.cabal/share/...)
12:14:23 <desegnis> Cale, any further enlightenment would be generously appreciated :)
12:14:45 <monochrom> An introductory book's meta and target will end up being the same, since both are classical logic.  This is the most confusing part, since it's like telling absolute beginners that GHC is compiled by GHC.
12:14:46 <sm> the ghci debugger skips right over lets.. I guess that makes sense
12:14:47 <gwern> one of these days I'll figure out the non-fragile solution for that problem
12:14:49 <jbms> Is there some easy-to-find collection of interesting template haskell libraries?  Has someone coded up a fully-functional printf in template haskell?
12:15:05 <sm> in a do block, anyway
12:15:11 <doserj> gwern: :)
12:15:12 <Cale> desegnis: Typically, you use ordinary logic to study wacky logics.
12:15:28 <monochrom> An advanced book, though, is likely to discuss a different target logic, e.g., meta is still classical, target is intuitionistic.  This is much easier to follow.
12:15:28 <dcoutts> Cale, gwern: it's looking for "nymphaea.glade" in the current dir, it should use the Cabal feature to find installed data files at runtime.
12:15:31 <Cale> desegnis: At least, that's what I see most people doing.
12:16:24 <monochrom> No one has used a wacky meta to study an ordinary target yet. :)
12:16:28 <sm> makes it a little challenging to see what's happening though
12:16:56 * Cale wonders why many of the Euler problem solutions on the wiki look like they were indented by a monkey on crack.
12:17:07 <monochrom> lets must be skipped because they are not executed yet.
12:17:33 <pcc1> could someone kindly help me figure out why I am getting a "duplicate definition" error using hs-plugins... source here: http://hpaste.org/5802
12:17:34 <dcoutts> gwern: import Paths_nymphaea (getDataFileName) and then use liftM fromJust $ xmlNew =<< getDataFileName "nymphaea.glade"
12:17:34 <monochrom> "debugger" by definition must follow execution order.
12:17:34 <gwern> dcoutts: you'll forgive me if by 'non-fragile' I meant 'non-cabal'
12:17:34 <gwern> (custom Setup.hss and other more advanced cabal stuff are one of my most challenging problems in dealing with old software)
12:17:38 <jbms> Is template haskell not actually used very much at all in practice?
12:17:38 <desegnis> monochrom, glad you mentioned that meta and target are the same. that makes it less mysterious in its purpose. hmmm... in the case of GHC, there once was a GHC that wasn't compiled by GHC
12:17:44 <dcoutts> gwern: only Cabal knows where the user chose to put the data files.
12:18:05 <dcoutts> gwern: this does not involve using any custom Setup.hs, it's the right way to do it.
12:18:17 <Cale> jbms: That's right.
12:18:28 <jbms> Cale: why is that?
12:18:49 <dcoutts> gwern: it's not fragile, it's guaranteed to work :-) (at least after the package is installed)
12:18:49 <desegnis> Cale, if they're wacky, then I don't exactly see what they will buy me. but let's leave that part for another day
12:18:54 <Cale> jbms: Macros are less required in a lazily evaluated language.
12:19:15 <Cale> desegnis: Well, not completely wacky. They might be useful but nonstandard.
12:19:16 <gwern> dcoutts: sure sure...
12:19:35 <monochrom> Haskell is wacky, nonstandard, and useful. :)
12:19:42 <Cale> desegnis: For example, intuitionistic logic closely follows the type systems of our programming languages.
12:19:51 <jbms> Cale: Still, it seems that there are many useful language features that can be done only with something like template haskell
12:20:02 <jbms> Cale: The printf example is itself fairly compelling
12:20:15 <Cale> jbms: You can do printf with typeclasses as well.
12:20:20 <Cale> :t printf
12:20:29 <faxathisia> printf isn't done with template haskell..?
12:20:32 <Cale> :t Text.Printf.printf
12:20:34 <Riastradh> That's silly, Cale.  Only frivolous macros can be replaced by uses of lazy evaluation.
12:20:35 <lambdabot> thread killed
12:20:36 <lambdabot> forall r. (PrintfType r) => String -> r
12:20:37 <kmcallister> faxathisia, there's a TH version and a typeclass version
12:20:56 <kmcallister> the typeclass version uses the standard "hungry function" trick
12:21:00 <faxathisia> I've only seen the haskell version (no TH), why would you do it with TH?
12:21:14 <Cale> Riastradh: Well, all macros which would be used to create embedded language features, let's say.
12:21:28 <Cale> Riastradh: (and don't require doing things like file IO at compile time)
12:21:46 <Cale> You just move the translation work to runtime.
12:21:56 <Riastradh> Cale, I'm not even talking about file I/O.  I'm talking about new binding constructs.
12:22:07 <Riastradh> Those are the really important things.
12:22:41 <monochrom> Andrew Appel has a series of compiler books "Modern Compiler Implementation in {Java,C,ML}".  Those are metas; the target is Tiger throughout.  To complete the series, and thoroughly confound the newbies, he should also write "Modern Compiler Implementation in Tiger". :)
12:22:42 <Cale> Can you give an example?
12:22:59 <dcoutts> Cale, gwern: I can send you a patch. Where is the nymphaea darcs repo?
12:23:12 <Riastradh> Cale, of what, a binding construct?
12:23:40 <Cale> Riastradh: of something not doable by reusing lambda.
12:23:57 <Riastradh> Cale, suppose I want to design a pattern matching notation.
12:24:20 <Riastradh> Obviously, I want this for something beyond what the built-in pattern matching will do.
12:24:21 * monochrom should do exactly that for April's Fool :)
12:24:26 <Cale> Then construct a data structure for representing patterns?
12:24:48 <Riastradh> OK, I do that.  Now what?  Do I write
12:25:16 <Riastradh> match (elaboratePattern ... (patternVariable "foo") ... (patternVariable "bar") ...) ["foo", "bar"] (\foo bar -> ...)
12:25:20 <Riastradh> to use this?
12:25:21 <byorgey> monochrom: awesome =)
12:25:35 <Riastradh> (I'm not sure whether even that can be done.)
12:26:15 <Cale> Well, okay, this will be less convenient. You'd probably have to have the matcher take a function of an environment or some such.
12:26:22 <desegnis> Cale, about the lifting thing... I guess then that mathematics will only ever provide knowledge about constructed logics, but they won't ever touch the the grounds of real-world logic (the logic I use to think and which ¬ªmust somehow be real and correct¬´)
12:26:35 <roconnor> @seen Igloo
12:26:36 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 2h 55m 22s ago.
12:26:40 <Riastradh> Cale, that requires a global transformation of the pattern by hand.
12:27:28 <Riastradh> And this is a mundane example of the binding constructs that I want expressible.
12:27:51 <Cale> Riastradh: Okay. I suppose that's an example. Still, it doesn't seem to show up all that often, or else I suppose TH would be more common.
12:28:01 <faxathisia> Riastradh, why do you want to make new binding constructs?
12:28:06 <Cale> (or other preprocessors)
12:28:15 <faxathisia> (I mean, rather than making a new language)
12:28:23 <jbms> Cale: is there a TH version of printf available?
12:28:38 <Cale> Most domain specific languages can get by quite happily with normal pattern matching and lambda.
12:28:38 <Riastradh> TH won't help much either there, because it's not just menial duplication of code that I want to reduce -- it's new concepts that I want to express, not by writing code to generate them but in a form that is suitable for representing them.
12:28:39 <lament> Riastradh: can you give a less mundane example?
12:28:48 <Cale> jbms: in the libraries?
12:29:03 <Riastradh> lament, a less mundane example?  OK: a directed control flow graph language, like Olin Shivers' LOOP toolkit.
12:29:05 <Cale> jbms: I know there's some example code floating around somewhere.
12:29:24 <Riastradh> A recursive, mutable data structure constructor, like LET-NODES in Kelsey's Pre-Scheme compiler.
12:29:26 * dcoutts notes that several hackage packages depend on versions of other packages that are not in hackage
12:29:49 <dcoutts> eg there's at least one package that needs syb-with-class >= 0.4 but hackage only has syb-with-class-0.3
12:29:50 <jbms> Cale: Well, I've seen the examples in the TH paper, and some slightly more elaborate versions
12:30:00 <jbms> Cale: but no actual implementation that would be at all useful
12:30:31 <ski_> desegnis : `The term "logic" has always had two meanings - a broader one and a narrower one:'
12:30:39 <Cale> jbms: printf isn't something which is really in the spirit of Haskell. Mostly we use some combination of show and concatenation.
12:30:42 <ski_> desegnis : `(1) All the general laws about the movement of human thinking should ultimately be made explicit so that thinking can be a reliable instrument, but'
12:30:49 <ski_> desegnis : `(2) already Aristotle realized that one must start on that vast program with a more sharply defined subcase.'
12:30:51 <Cale> jbms: But there's a useful printf in Text.Printf
12:30:58 <Cale> jbms: It doesn't use TH though.
12:31:09 <Riastradh> lament, another mundane example might be a loop macro like foof-loop: <http://mumble.net/~campbell/scheme/foof-loop.txt>.  This example is not superb, because there are many loops that in Haskell are expressed extremely tersely with higher-order combinators and exploitation of lazy lists, but it is another example nonetheless.
12:31:13 <jbms> Cale: yeah sure, it is a run-time-checked version
12:31:34 <ski_> (desegnis : from `Sets for Mathematics', F. William Lawvere and Robert Rosebrugh)
12:31:40 <jbms> Cale: printf is useful because it allows the format string to be specified separately from the code
12:31:46 <desegnis> ski_, cheers
12:32:19 <jbms> Cale: which in addition to improving readability in many cases, also greatly eases internationalization
12:32:42 <Cale> jbms: You just end up with smaller internationalisation strings.
12:33:01 <jbms> Cale: But you can't always translate those individual "bits"
12:33:09 <jbms> Cale: The ordering of arguments might change, among other things
12:33:18 <Cale> mm, okay
12:33:24 <lament> Riastradh: it seems so far that in a haskell context, the only capability of macros that's actually required is converting "literals" into language elements
12:33:59 <lament> Riastradh: i.e. a very straightforward extension of syntax by adding extra literals
12:34:10 <Riastradh> Extra literals?
12:34:18 <lament> like in your pattern matching example
12:34:32 <lament> where the only difficulty was that notation was too cumbersome without macros
12:35:17 <Riastradh> It's not that the notation is `too cumbersome'; it's that the concepts, once stated, require global but automatable transformation to render into Haskell.
12:36:07 <Riastradh> The order in which I match the pattern variables, or the mechanism by which I extract them, is utterly irrelevant to the idea I am trying to express in my program.
12:37:04 * BMeph looks forward to monochrom's review of Andrew Appel's "Modern Compiler Implementation in Tiger"
12:39:36 * faxathisia writes some strong specs code in Agda 2.. looks horrible
12:50:08 <Stinger_> hmm foldl and foldr (&&&) should be roughly eqivalent shouldnt it?
12:50:46 <Beelsebob> @type (&&&)
12:50:48 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:51:56 <Stinger_> will result in (((..((((c,c),c),..) vs (c,(c,c(,...(c,c)))..)) if my brain is working properly
12:52:10 <ilyak_> @let reduce (x:y:os) = let l = map (\c -> read [c]) x in show l ++ [read y]
12:52:17 <lambdabot> Add a type signature
12:53:24 <faxathisia> Stinger_: if a ‚Ä¢ b = b ‚Ä¢ a, then foldr (‚Ä¢) z l = foldl (‚Ä¢)¬†z l, I think..
12:53:55 <shepheb> faxathisia: on finite lists, yes.
12:54:06 <mauke> > foldr (+) z [a,b,c,d,e]
12:54:07 <lambdabot>  a + (b + (c + (d + (e + z))))
12:54:11 <mauke> > foldl (+) z [a,b,c,d,e]
12:54:12 <lambdabot>  z + a + b + c + d + e
12:54:12 <ilyak_> @let let reduce :: [String] -> String; reduce (x:y:os)  = let l = map (\c -> read [c]) x in show l ++ [read y]
12:54:13 <lambdabot>  Parse error
12:54:19 <ilyak_> @let reduce :: [String] -> String; reduce (x:y:os)  = let l = map (\c -> read [c]) x in show l ++ [read y]
12:54:20 <lambdabot> Add a type signature
12:54:32 <ilyak_> Communication failed, sort of :)
12:54:44 <ilyak_> Why wouldn't reduce ["1234" "6"] work?
12:55:09 <ilyak_> @run reduce ["1234" "6"]
12:55:10 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
12:55:28 <Lemmih> ilyak_: ["1234", "6"] ?
12:55:45 <ilyak_> Lemmih: Yeah, ["1234", "6"]
12:56:27 <moonlite> > foldr f z [a,b,c,d,e]
12:56:28 <lambdabot>  f a (f b (f c (f d (f e z))))
12:57:24 <Stinger_> (foldr returnA (&&&) (map getAttrValue ["typeName", "transactionDateTime","quantity","transactionDateTime"]))
12:57:35 <Stinger_> I'm not sure if you can see what I'm doing there
12:58:11 <hpaste>  dcoutts pasted "Yay! cabal install doing the right thing with inconsistent package deps" at http://hpaste.org/5803
12:58:12 <Stinger_> but basically I want to do (getAttrValue "typeName" &&& getAttrValue "transactionDateTime" &&& etc
12:58:41 <Stinger_> it doesnt like my types though
12:59:27 <Stinger_> not sure its gonna typecheck though :(
12:59:33 <dcoutts> note in that hpaste that cabal correctly detects the problem and gives a sensible warning so that the user doesn't end up totally confused
13:00:05 <Stinger_> in fact I dont think I can do this using fold
13:00:48 <Stinger_> do I need something generic for this?
13:00:50 <gwern> dcoutts: you messed up your formatting in http://hackage.haskell.org/trac/hackage/ticket/245
13:00:50 <gwern> pretty hard to read
13:00:52 <lambdabot> Title: #245 (Cabal should support hsc2hs's stub .c feature) - Hackage - Trac
13:01:17 <dcoutts> gwern: so I noticed. sorry about that. Seems I can't edit the comment.
13:01:29 <dcoutts> nominolo: see http://hpaste.org/5803
13:01:38 * dcoutts is feeling very pleased with himself
13:02:26 <jatqceer> is there a (number :: Num a => a), such that ((any :: Double) <= number == True) always?
13:02:43 <nominolo> dcoutts: how is that the right thing?  does it build? ;)
13:02:54 <faxathisia> > maxBound :: Double
13:02:55 <lambdabot>   add an instance declaration for (Bounded Double)
13:02:55 <lambdabot>     In the expression: max...
13:02:59 <dcoutts> nominolo: that's what we need your SAT sover for :-)
13:03:12 <faxathisia> I don't think so..
13:03:12 <ilyak_> So, why wouldn't that work?
13:03:12 <dcoutts> sover/solver
13:03:17 <ilyak_> I don't understand that
13:03:33 <nominolo> dcoutts: oh i see.  now it's my turn...
13:03:33 <Stinger_> > +Inf :: Double
13:03:33 <lambdabot>  Parse error at "::" (column 6)
13:03:43 <dcoutts> nominolo: ;-)
13:03:44 <hpaste>  ilyak pasted "(no title)" at http://hpaste.org/5804
13:04:04 <ski_> > 1/0 :: Double
13:04:04 <lambdabot>  Infinity
13:04:22 <jatqceer> > Infinity :: Double
13:04:23 <lambdabot>   Not in scope: data constructor `Infinity'
13:04:23 <ilyak_> Why do I keep getting "no parse"?
13:04:28 <Stinger_> > join (==) ((1/0) :: Double)
13:04:28 <doserj> > 0/0 <= 1/0
13:04:29 <lambdabot>  True
13:04:29 <lambdabot>  False
13:04:31 <ski_> @check \any -> any <= (1/0 :: Double)
13:04:31 <lambdabot>  OK, passed 500 tests.
13:04:33 <dcoutts> nominolo: I just tried to install every package on hackage too, seems we're currently not doing any sharing of dep analysis when trying to find a solution for multiple packages that depend on the same thing, so it takes ages.
13:04:38 <Stinger_> lol crap
13:04:40 <Stinger_> > join (==) ((1/0) :: Double)
13:04:41 <lambdabot>  True
13:04:48 <ski_> @check (0/0) <= (1/0 :: Double)
13:04:49 <Stinger_> > join (<=) ((1/0) :: Double)
13:04:49 <lambdabot>  Falsifiable, after 0 tests:
13:04:50 <lambdabot>  True
13:05:31 <nominolo> dcoutts: i don't quite understand. what makes it take so long?
13:05:44 <jatqceer> is it safe to define myInfinity = 1/0 :: Double?
13:06:22 <ivan_> @unmtl StateT r (ErrorT a IO) q
13:06:22 <lambdabot> r -> IO (Either a (q, r))
13:06:23 <dcoutts> nominolo: so lots of packages have common dependencies, I think what we're currently doing is if foo and bar dep on baz, we work out if we can install baz twice.
13:06:42 <Stinger_> is there a way to do a fold where the type changes?
13:06:54 <dcoutts> nominolo: so when there is no sharing at all, there is a lot of work to do.
13:06:58 <Stinger_> do I have to use generics or something for that?
13:06:59 <nominolo> dcoutts: i see
13:07:25 <dcoutts> nominolo: and when we're trying to install loads and loads of things the issue about inconsistent versions of deps is going to get really severe.
13:07:33 <nominolo> yep
13:07:35 <ivan_> @unmtl StateT ra (ErrorT a IO) q
13:07:35 <lambdabot> ra -> IO (Either a (q, ra))
13:08:07 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5805
13:09:47 <ski_> ivan_ : maybe it would be simpler for you to first ignore doing the monad tranformation decomposition ?
13:10:23 <jatqceer> can i say that isInfinite (1/0) is always true?
13:12:26 <cinema> @seen sclv
13:12:26 <lambdabot> sclv is in #darcs, #xmonad, #ghc, #haskell-blah and #haskell. I last heard sclv speak 17h 18m 39s ago.
13:13:11 <byorgey> :t isInfinite
13:13:12 <lambdabot> forall a. (RealFloat a) => a -> Bool
13:13:19 <byorgey> > isInfinite (1/0)
13:13:19 <lambdabot>  True
13:13:40 <byorgey> > 1/0 :: Double
13:13:41 <lambdabot>  Infinity
13:13:53 <ski_> > isInfinite (0/0)
13:13:53 <lambdabot>  False
13:13:57 <byorgey> jatqceer: what do you need infinity for?
13:14:00 <ski_> > isInfinite (1/(1/0))
13:14:01 <lambdabot>  False
13:14:22 <byorgey> jatqceer: floating-point numbers are rarely the answer.
13:14:38 <byorgey> when they are, the question is usually "what's the best way to lose my sanity"?
13:14:54 <jatqceer> byorgey: a number that is always not less than any other numbers
13:15:00 <matthew-_> @remember byorgey floating-point numbers are rarely the answer. when they are, the question is usually "what's the best way to lose my sanity"?
13:15:00 <lambdabot> Okay.
13:15:21 <byorgey> jatqceer: yes, but what sort of numeric type do you need for the 'other numbers'?
13:15:32 <jatqceer> > 1/(1/0)
13:15:33 <lambdabot>  0.0
13:15:57 <jatqceer> byorgey: Double
13:16:33 <byorgey> jatqceer: ah.  well, my condolences. ;)  but it looks like 1/0 should work OK.
13:17:05 <jatqceer> byorgey: i guess it's fine, too
13:18:18 <jatqceer> is there any predefined string that would give (isInfinite (read someString) == True) ?
13:18:43 <mauke> > read "Infinite" :: Double
13:18:44 <lambdabot>  Exception: Prelude.read: no parse
13:19:10 <mauke> > read "Infinity" :: Double
13:19:11 <lambdabot>  Infinity
13:19:57 <hpaste>  (anonymous) annotated "is my `forall' syntax incorrect?" with "maybe some separation?" at http://hpaste.org/5797#a1
13:20:03 <jatqceer> mauke: thanks
13:25:14 <smg> how to check if a var exists?
13:25:18 <smg> none ?
13:25:23 <byorgey> dcoutts: remember we talked a while ago about adding a check if a .cabal file specifies a Cabal version, to make sure we're running a supported version -- or I guess we talked about moving the check earlier?
13:25:27 <byorgey> dcoutts: has that already been done?
13:25:44 <smtms> smg, check if a var exists? what do you mean?
13:25:46 <faxathisia> smg, Question doesn't make sense to me.. What's the context?
13:26:02 <smg> i found it -> null
13:26:11 <faxathisia> :t null
13:26:12 <lambdabot> forall a. [a] -> Bool
13:26:15 <byorgey> smg: that's a function to test whether a list is empty.
13:26:55 <byorgey> is that what you wanted?
13:27:02 <byorgey> > null []
13:27:03 <lambdabot>  True
13:27:06 <byorgey> > null [1,2,3]
13:27:07 <lambdabot>  False
13:27:16 <ski_> Cin : seems to work in ghc 6.6.1 and 6.8.1
13:28:08 <ski_> (you need existential extension, though)
13:28:16 <Cin> i'm using that now
13:28:19 <smg> byorgey: yeah
13:28:22 <Cin> delayed reply time???
13:28:53 <smg> can i check wether a value is greater than another value?
13:28:54 <smg> >= ?
13:28:59 <byorgey> smg: yup
13:29:01 <dibblego> ?type (>)
13:29:02 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:29:12 <byorgey> > 6 >= 5
13:29:13 <lambdabot>  True
13:29:18 <faxathisia> > 5 >= 5
13:29:19 <lambdabot>  True
13:29:27 <byorgey> > (2,3) <= (2,1)
13:29:28 <lambdabot>  False
13:29:40 <ski_> > () > ()
13:29:40 <lambdabot>  False
13:29:49 <byorgey> > "haskell" >= "java"
13:29:50 <lambdabot>  False
13:29:54 <faxathisia> lol
13:29:56 <byorgey> oops
13:30:10 <byorgey> > "haskell" >= "Java"  -- there we go
13:30:11 <lambdabot>  True
13:30:17 <d0rt> cheater
13:30:32 <faxathisia> data Languages = Java | Haskell deriving Enum
13:30:47 <dibblego> newtype Language String
13:30:48 <hpaste>  (anonymous) annotated "getIndex function" with "now it's tail recursive" at http://hpaste.org/5798#a1
13:30:59 <byorgey> > let "haskell" > "java" = True  in "haskell" > "java"
13:30:59 <lambdabot>  True
13:31:01 <faxathisia> @src Enum
13:31:01 <lambdabot> class  Enum a   where
13:31:01 <lambdabot>     succ                     :: a -> a
13:31:01 <lambdabot>     pred                     :: a -> a
13:31:01 <lambdabot>     toEnum                   :: Int -> a
13:31:02 <lambdabot>     fromEnum                 :: a -> Int
13:31:03 <lambdabot> [3 @more lines]
13:31:06 <profmakx> > True < False
13:31:07 <faxathisia> @more
13:31:07 <lambdabot>     enumFrom                 :: a -> [a]
13:31:07 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
13:31:08 <BMeph> > "ƒ§askell" >= "Java"
13:31:09 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
13:31:12 <lambdabot>  False
13:31:13 <lambdabot>  True
13:31:17 <faxathisia> looks like Enum isn't the way
13:31:24 <Cin> does Bjorn Bringert hang out in here? are you there, bjorn? :))
13:31:32 <adiM> @pl snd_compare a b = comare (snd a, snd b)
13:31:33 <lambdabot> snd_compare = (comare .) . (. snd) . (,) . snd
13:31:36 <dibblego> Cin, bringert
13:31:38 <ski_> Cin : ^ bringert
13:31:46 <Cin> ah, cool :D
13:31:51 <bringert> hi Cin
13:31:51 <Cin> bringert: ping
13:32:19 <Cin> bringert: hi. i'm working on mohws. are you still developing it or what's the status on that?
13:32:23 <byorgey> :t comparing snd  -- adiM
13:32:24 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
13:32:25 <hpaste>  (anonymous) annotated "getIndex function" with "a -> _" at http://hpaste.org/5798#a2
13:32:31 <oerjan> adiM: compare `on` snd
13:32:41 <bringert> Cin: I haven't worked on it for quite a while
13:32:51 <bringert> Cin: I'm not using it for anything at the moment
13:33:14 <bringert> Cin: you are welcome to contribute
13:33:21 <Cin> bringert: ah, i see. the code is quite nice, i've been grepping it all day trying to figure stuff out, hehe
13:34:05 <byorgey> what's mohws?
13:34:22 <Cin> bringert: i'm adding a Module that will load haskell code with hs-plugins and "cache"/store it, to be recalled many times aftewards, akin to plt-web-server, if you know what that is
13:34:34 <bringert> byorgey: a heavily modified version of simon marlow's haskell web server
13:34:50 <bringert> byorgey: with a module system, revamped logging, CGI support etc
13:34:50 <byorgey> oh, cool
13:35:07 <bringert> Cin: I've done something like that already, using the ghc api
13:35:21 <adiM> byorgey: thanks
13:35:34 <Cin> bringert: dynhs?
13:35:54 <adiM> oerjan: where is on defined?
13:36:01 <ski_> @index on
13:36:01 <lambdabot> bzzt
13:36:01 <bringert> Cin: yeah
13:36:24 <byorgey> adiM: Data.Function, but it's new, it only comes with 6.8.1+
13:36:24 <mauke> @hoogle on
13:36:25 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:36:25 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
13:36:25 <lambdabot> Data.Function :: module
13:36:32 <byorgey> @src on
13:36:32 <lambdabot> (*) `on` f = \x y -> f x * f y
13:36:43 <byorgey> you can just use the above definition yourself though
13:36:46 <bringert> Cin:  I thought I had a mohws version with dynhs built-in, but I can't seem to find it
13:36:52 <adiM> thanks
13:37:17 <Cin> bringert: ah, so it does.
13:37:19 <smg> oh
13:37:28 <Cin> bringert: yeah, this version has it. can you summarise what it does?
13:37:28 <bringert> ah yes, mohws/src/Module/DynHS.hs
13:37:30 <smg> what to do when i have lambda function with more than one argument?
13:37:38 <smg> just do (\x \y -> x*y) ?
13:37:53 <byorgey> smg: either \x y -> x * y, or \x -> \y -> x * y
13:38:04 <bringert> Cin: uses GHC-API to load a .hs file in interpreted mode, finds the cgiMain function, and runs that
13:38:10 <byorgey> smg: the former is syntax sugar for the latter
13:38:32 <bringert> Cin: and it uses GHC's mechanisms for caching the program if it's unmodified
13:38:33 <byorgey> smg: note that in Haskell, all functions only take one argument =)
13:38:39 <bringert> Cin: it's for the GHC 6.6 API
13:38:56 <byorgey> smg: it's just that some functions return functions, which take further arguments, and so on.
13:39:08 <bringert> Cin: and it had some problems with crashing in certain circumstances that I on't quite remember
13:39:22 <Cin> bringert: ah. i wish i had read it before starting mine, heh :)
13:39:28 <bringert> Cin: probably having to do with the GHC API not being meant for loading several Main modules at the same time
13:39:51 <Cin> hmm
13:40:11 <bringert> Cin: that may have been fixed in 6.8, dunno
13:40:31 <smg> byorgey: i like syntactic sugar
13:40:35 <bringert> Cin: or it could be easily fixable in GHC, once you tell them about it / dig it up yourself
13:40:36 <Cin> bringert: i'll try it, hang on
13:40:59 <byorgey> smg: so do I =)
13:41:07 <bringert> Cin: you may have to edit the code to send packageDirectory
13:41:30 <bringert> Cin: heh, the code says "-- FIXME: lots of fake stuff here"
13:41:48 <Cin> bringert: hehe
13:42:17 <bringert> Cin: you are welcome to take that over, or start from scratch
13:42:52 <bringert> Cin: I don't really have time to work on it, but if it could be made realiable, it would be a kick-ass thing to have
13:42:58 <Cin> bringert: i'd started inserting state for the modules... so i could do session state
13:43:03 <Cin> bringert: yep
13:43:45 <bringert> Cin: does it work for you?
13:43:56 <bringert> Cin: I'm not 100% sure that it ever worked
13:44:04 <ivan_> ski_: are u there?
13:44:47 <Cin> bringert: just trying now. had to pull from darcs to get the fresh unmodifed version
13:45:58 <ehird> how can i create an infinite Map?
13:46:09 <ehird> specifically, of integers
13:46:17 <ehird> i want, by default, 1->1,2->2,3->3, etc
13:46:35 <Cin> bringert: yeah, i think i'm going to put a lot of work into this. it's been fun so far and i really want to get a haskell web-dev setup that i really like
13:46:41 <mauke> ehird: use a function
13:46:56 <ehird> mauke: except it has to be mutable, via a StateT
13:46:57 <ehird> :-P
13:47:04 <faxathisia> you can define a map in terms of functions
13:47:09 <mauke> ehird: use function composition
13:47:16 <ehird> (it is an implementation of Forte, where you can change constant integers to be others)
13:47:33 <faxathisia> ehird, why not use a finite map?
13:47:43 <faxathisia> ehird, in the case the lookup fails, fallback
13:47:49 <ehird> faxathisia: good idea. :P
13:48:51 <adiM> I have a [(a,b)]. What is the best way to select all second arguments corresponding to the minimum first argument?
13:49:22 <mauke> why do you have a [(a,b)]?
13:49:35 <sm> newbies like myself will make the mistake of thinking "let var = var + ..." is ok in a do block, since "it's imperative in here". Then ghc will hang with 0 cpu. Is it reasonable to want it to do something more obvious ? even 100% cpu would be more intuitive
13:49:36 <mauke> Map a [b] would be a lot easier, I think
13:50:06 <adiM> I mean I want a function best_snd :: [(a,b)] -> [b]
13:50:58 <Cin> bringert: hrm, does not build. i get Not in scope: data constructor `Interactive' -- i doubt you have the time or interest to look into this with me, so i'll just work on it. ;)
13:51:02 <Lemmih> sm: It should either use 100% cpu or throw an exception.
13:51:06 <byorgey> > let minPairs ps = map snd . filter ((==m) . fst) where m = minimum (map fst ps)  in minPairs [(1,2),(1,4),(2,3),(5,1),(1,9)]
13:51:06 <lambdabot>  Add a type signature
13:51:17 <sm> I think so too
13:51:20 <Baughn> sm: Doesn't that produce <<LOOP>>?
13:51:30 <mauke> > let bestSnd xs = [b | (a,b) <- xs, a == m] where m = minimumBy (comparing fst) in bestSnd [(1,2),(1,4),(2,3),(5,1),(1,9)]
13:51:30 <lambdabot>        add an instance declaration for (Num ([(a, b)] -> (a, b)))
13:51:30 <lambdabot>     In the ...
13:51:37 <adiM> byorgey: thanks
13:51:41 <mauke> > let bestSnd xs = [b | (a,b) <- xs, a == m] where m = minimumBy (comparing fst) xs in bestSnd [(1,2),(1,4),(2,3),(5,1),(1,9)]
13:51:42 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
13:51:42 <lambdabot>       Expec...
13:51:47 <byorgey> adiM: well, it didn't work =P
13:51:51 <Baughn> sm: ..not in ghci, I see. How intriguing.
13:52:07 <mauke> > let bestSnd xs = [b | (a,b) <- xs, a == m] where m = minimum . map fst $ xs in bestSnd [(1,2),(1,4),(2,3),(5,1),(1,9)]
13:52:09 <lambdabot>  [2,4,9]
13:52:20 <byorgey> there we go =)
13:52:20 <sm> yes, took me some debugging to see it :)
13:52:55 <byorgey> sm: well, at least now you know not to do 'let var = var + ...'  =)
13:53:17 <adiM> mauke: thanks
13:53:33 <sm> I sure do.. thanks
13:53:36 <mauke> „Äåvar <- return $ var + ...„Äç :-)
13:53:53 <sm> I won't be the last..
13:54:43 <idnar> > let x = x + 5 in x
13:54:45 <lambdabot>  Exception: <<loop>>
13:54:51 <bringert> Cin: what GHC version do you have?
13:54:58 <Cin> bringert: 6.8.2
13:55:01 <Baughn> > do let x = x + 2
13:55:01 <lambdabot>  Parse error at end of input
13:55:11 <bringert> Cin: the code was written for the GHC 6.6 API
13:55:11 <Baughn> > do { let x = x + 2; return x }
13:55:11 <lambdabot>  Parse error at "}" (column 30)
13:55:23 <bringert> Cin:  so it will pribably need serious changes for 6.8
13:55:35 <sm> idnar: <<loop>> exception I have not seen.. ghc here gives a stack space overflow
13:55:39 <bringert> Cin: which would be good to do, sinc ethe 6.8 API is supposed to be better
13:56:08 <Cin> bringert: ah, indeed.
13:56:09 <byorgey> sm: in some cases, nonproductive loops like that can be detected, but not always
13:56:32 <bringert> Cin: but you may want to test with 6.6 first, just to be sure that it can actually work...
13:56:38 <Baughn> byorgey: I can see getting 100% cpu use, or a stack overflow, but what could cause it to wedge like that?
13:56:47 <Samburger> Im a bit confused. let x = x + 2 does NOT work, right?
13:56:50 <Samburger> yeah total noob here
13:56:58 <mauke> Samburger: it "works"
13:57:02 <mauke> depends on your definition of "work"
13:57:02 <Baughn> Samburger: It works so long as you don't try to use x
13:57:11 <mauke> > let x = x + 2 in x :: Expr
13:57:15 <lambdabot> Terminated
13:57:23 <mauke> > let x = 2 + x in x :: Expr
13:57:24 <lambdabot>  2 + (2 + (2 + (2 + (2 + (2 + (2 + (2 + (2 + (2 + (2 + (2 + (2 + (2 + (2 + (2...
13:57:31 <Samburger> I see
13:57:46 <Cin> bringert: hm, something i'd wondered about, sometimes in your code you use "foo_bar" notation -- what's the meaning of that?
13:57:47 <dcoutts_> byorgey: no, not yet. It still parses the file and then checks the cabal version by which time it's too late if it could not parse the rest of the file.
13:57:58 <byorgey> Baughn: I remember seeing this discussed before.  Something about blocking a thread waiting for a thunk to be evaluated, or something like that... deadlock, basically
13:58:03 <Cin> bringert: (instead of fooBar)
13:58:07 <sm> I see. well I'm a bit nearer to a proper game loop for hinvaders: http://joyful.com/darcsweb/darcsweb.cgi?r=hinvaders;a=headblob;f=/gameloop.hs#l70
13:58:08 <faxathisia> heh
13:58:08 <lambdabot> Title: darcs - hinvaders, http://tinyurl.com/2hrnvn
13:58:14 <faxathisia> Agda 2 can already complile to haskell
13:58:21 <Baughn> Samburger: You could instance Num in peano style (as a list), in which case it'd return an infinite number just fine - eg. an infinite list
13:58:22 <dcoutts_> byorgey: very often this is down to unrecognised new extensions, it'd be good if those only caused warnings rather than parse failures.
13:58:33 <byorgey> dcoutts_: ok, I'll see about working on that.  seems straightforward.
13:58:41 <dcoutts_> byorgey: which would require a change in the extension parser
13:58:50 <dcoutts_> byorgey: yeah, should be easy.
13:59:02 <byorgey> ok, I'll look at changing the extension parser too
13:59:05 <Baughn> byorgey: You'd think that could be detected, at least without -threading
13:59:13 <bringert> Cin: I do?
13:59:24 <Cin> bringert: newSession' mode mb_top_dir = do  -- for example
13:59:45 <ehird> @src untilM
13:59:46 <lambdabot> Source not found.
13:59:47 <ehird> @src untilM_
13:59:47 <lambdabot> Source not found. Do you think like you type?
13:59:49 <ehird> d'aww
13:59:52 <ehird> @src until
13:59:52 <lambdabot> until p f x | p x       = x
13:59:52 <lambdabot>             | otherwise = until p f (f x)
13:59:54 <byorgey> Baughn: maybe.  I really don't know how it works.
14:00:17 <ivan_> @unmtl StateT (Either q r) IO a
14:00:17 <lambdabot> Either q r -> IO (a, Either q r)
14:00:32 <bringert> Cin: hmm, I that particular piece of code is a copy and paste jobs from the GHC source code
14:00:42 <Cin> bringert: ahhh. okay
14:02:10 <gwern> hinvaders?
14:02:16 <gwern> sm: have you been working on that space invaders I linked?
14:02:35 <sm> gwern: yah, http://joyful.com/darcsweb/darcsweb.cgi?r=hinvaders;a=summary
14:02:36 <lambdabot> Title: darcs - hinvaders
14:02:47 <Cin> bringert: i was thinking of using hs-plugins seeing as it's written for this kind of task. did hs-plugins exist when you wrote this or why did you choose to use the ghc API directly? i'm new to the ghc API stuff
14:02:55 <sm> see what you've done..
14:03:01 <gwern> sm: oh. you know it's GPL'd, right?
14:03:08 <sm> excellent
14:03:08 <ivan_> @unmtl StateT r (StateT (Maybe q) IO) a
14:03:08 <lambdabot> r -> Maybe q -> IO (a, r, Maybe q)
14:03:25 <bringert> Cin: hs-plugins did exist, but it didn't use the GHC API, it called ghc as an external program, produced object files and loaded those
14:03:39 <oerjan> ehird: the libraries are not equipped with any imperative loops other than traversing an entire structure
14:03:43 <bringert> Cin: doing interpreting in-process seemed faster and nicer
14:03:46 <gwern> Cin: also, I think some projects moved to the GHC API because hs-plugins was broken for so long
14:04:04 <bringert> Cin: also it let me do things like output  source code with errors highlighted if compilations failed
14:04:11 <bringert> Cin: for that see Cin: if you want to build a nive haskell web dev system, you may also want to use some other code
14:04:16 <bringert> eh
14:04:17 <ehird> oerjan: indeed
14:04:22 <bringert> Cin: http://www.cs.chalmers.se/~bringert/darcs/dyn-cgi/
14:04:23 <lambdabot> Title: Index of /~bringert/darcs/dyn-cgi
14:04:23 <Cin> bringert: ah, right
14:04:24 <ehird> untilM would be nice, though
14:04:32 <bringert> Cin: specifically http://www.cs.chalmers.se/~bringert/darcs/dyn-cgi/DynHS/ViewSource.hs
14:04:33 <lambdabot> http://tinyurl.com/3xb8en
14:04:42 <bringert> Cin: btw, you may want to talk to gwern
14:04:52 <bringert> Cin: he sent me some mohws patches the other day
14:05:00 <Cin> ahh
14:05:05 <Cin> gwern: :D
14:05:22 <ehird> untilM p t f = do r <- p; if r then t else do f >>= (\x -> untilM p x f)
14:05:37 <bringert> what's the status of hs-plugins these days?
14:05:43 <bringert> does it use the GHC API yet?
14:06:05 <gwern> bringert: I think so
14:06:21 <Vq^> is there any way to temporarily suspend garbage collection and possibly threading in GHC compiled programs?
14:06:43 <bringert> Vq^: what does it mean to suspend threading?
14:06:48 <bringert> Vq^: stop everything?
14:07:03 <Cin> bringert: but dyncgi look at the file every time someone loads the page? ie uses the ghc API to start a compile and if the file hasn't changed since the last build it skips the compile and just uses the existing build?
14:07:17 <Cin> bringert: s/but/does
14:07:31 <dons> Vq^: what are you trying to do?
14:07:34 <bringert> Cin: as far as I recall, yes
14:07:48 <bringert> dons: what's the state of hs-plugins these days?
14:07:59 <Vq^> i'm trying to measure the performance on specific pieces of code
14:08:05 <Cin> bringert: sounds good to me
14:08:07 <dons> marginally maintained, but works with 6.8.x
14:08:16 <bringert> dons: does it use the GHC API?
14:08:19 <dons> yeah
14:08:31 <Vq^> but for some algorithms (my best guess is when they start using some memory) the result get "jumpy"
14:08:34 <dons> it could use it even more too
14:08:48 <dons> Vq^: ok. you can change the default heap size, perhaps
14:08:56 <bringert> Cin: then it might be best for you to use hs-plugins instead of using the GHC API directly
14:08:57 <dons> and be sure to compile with -O2 to get maximum optimisations
14:09:17 <bringert> Vq^: can't you use GHC's normal profiling?
14:09:52 <ivan_> @unmtl r -> IO (Either (q,r) a)
14:09:52 <lambdabot> r -> IO (Either (q, r) a)
14:09:52 <Vq^> bringert: no :(
14:09:55 <Vq^> http://arda.no-ip.org/almost-linear_10000_EvalAll_clipped.png
14:10:03 <dons> Vq^: yeah, at the very least, compile with profiling to confirm the GC is the issue
14:10:59 <oerjan> ehird: sure you don't want p and f to take t as argument?  otherwise you are going to need additional state every time
14:16:38 <Vq^> dons: it worked with increasing the heapsize
14:16:45 <Vq^> now it looks a lot better :)
14:16:54 <Vq^> @karma+ dons
14:16:55 <lambdabot> dons's karma raised to 141.
14:18:21 * wli wonders if there are any knight's tours on 5x5 boards.
14:18:33 <bringert> isn't there a flag to turn off GC completely?
14:18:50 <mux> @where hsc2hs
14:18:50 <lambdabot> I know nothing about hsc2hs.
14:19:18 <mux> oh, it comes with ghc!
14:19:59 <ehird> hm
14:20:04 <ehird> is there an IO monad function to exit the program?
14:20:05 <ivan_> @unmtl StateT r (ErrorT q IO) a
14:20:05 <lambdabot> r -> IO (Either q (a, r))
14:20:11 <mauke> @hoogle exit
14:20:11 <lambdabot> System.Exit :: module
14:20:11 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
14:20:11 <lambdabot> System.Exit.exitFailure :: IO a
14:20:20 <ehird> i assume it is catchable?
14:20:42 <Lemmih> ehird: It is.
14:20:47 <Vq^> bringert: i can't find any
14:20:59 <ivan_> @unmtl ErrorT q (StateT r IO) a
14:21:00 <lambdabot> r -> IO (Either q a, r)
14:21:42 <ivan_> @unmtl StateT r (ErrorT a IO) q
14:21:42 <lambdabot> r -> IO (Either a (q, r))
14:22:37 <wli> Aha, I'm looking for closed tours only.
14:22:37 <wli> So that would be no.
14:22:59 <mux> how can I tell cabal to process some file through hsc2hs?
14:23:07 <gwern> sm: where should I darcs send?
14:23:59 <roconnor> My Haskell presentation from last December: http://r6.ca/Haskell/FPI or http://r6.ca/Haskell/FPI.pdf
14:24:15 <roconnor> Not that slides are all that useful without the audio to go with them :(
14:26:00 * gwern just goes with 'Simon Michael <simon@joyful.com>'
14:26:17 <ehird>     Couldn't match expected type `[(Integer, Integer)]'
14:26:17 <ehird>            against inferred type `Interp'
14:26:17 <ehird>       Expected type: [(Integer, Integer)]
14:26:18 <ehird> ...
14:26:19 <ehird> tons of stuff...
14:26:47 <wy> I recalled as if the hardware is essentially functional, is that true?
14:30:47 <nutpunch> how life folks?
14:31:07 <gwern> nutty. with a slight hint of fruitiness in its bouquet
14:35:51 <gwern> @seen sm
14:35:51 <lambdabot> sm is in #haskell and #darcs. I last heard sm speak 32m 43s ago.
14:36:44 <sm> gwern: great!
14:37:08 <gwern> sm: did you get the patches already? 0.o
14:37:12 <sm> no
14:38:45 <gwern> anyway, as far as I can tell, you can upload to hackage as soon as you apply my patches
14:38:47 <gwern> unless you want me to do i
14:40:32 <sm> ok, sounds good.. let me chat with you later
14:40:46 <sm> ah there's the patch, in junk
14:40:52 <sm> great
14:41:04 <gwern> junk? how ignorant your filter is
14:42:52 <sm> I'll fix.. afk a bit
14:47:30 <gwern> @hoogle mapAccumL
14:47:30 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
14:47:30 <lambdabot> Data.ByteString.mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
14:47:30 <lambdabot> Data.ByteString.Char8.mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> ByteString -> (acc, ByteString)
14:51:18 <Stinger> hoo boy did my linux box lock up hard then
14:55:45 <dons> dcoutts_: hehe ohloh got slashdotted, just in time
14:55:57 <dcoutts_> dons: :-)
14:56:01 <roconnor> I get worried when scheme programs spits out random error messages while running :/
14:56:07 <dcoutts_> dons: it was fairly slow at the best of times
14:56:11 <roconnor> too bad scheme doesn't have a type system.
14:56:22 <dons> well, i'm glad we got all the haskell stuff up there for people to find.
14:56:32 <roconnor> ``
14:56:32 <roconnor> <unnamed port>: In procedure scm-error in expression (scm-error (quote misc-error) #f ...):
14:56:32 <roconnor> <unnamed port>: no code for module (debugging assert)
14:56:39 <dcoutts_> dons: indeed
14:56:41 <roconnor> O_o
14:57:29 <gwern> http://yro.slashdot.org/article.pl?sid=08/02/21/1733257 <-- ?
14:57:30 <lambdabot> Title: Slashdot | Ohloh Tracks Open Source Developers
14:58:21 <dons> http://weblog.infoworld.com/tech-bottom-line/archives/2008/02/the_open_source.html
14:58:22 <lambdabot> Title: Tech's Bottom Line | Bill Snyder | InfoWorld | Is counting open source code cont ..., http://tinyurl.com/28sgfm
14:59:17 <dons> "Ohloh will use widgets to place its classified ads on technical job recruiting sites such as Monster.com and CareerBuilder.com, and split the revenue. It ave to get used to is knowing whether h is actually a function.
16:58:58 * gwern wants to upload connect-4 and paratrooper but the author hasn't responded yet
16:59:03 <gwern> sm: yes, I have rogue star
16:59:16 <sm> ok, you have found more than I :)
16:59:18 <gwern> I've refrained because it's still very alpha
16:59:23 <sm> I thought so too
17:00:01 <gwern> sm: if you're interested, I haven't gotten all the way through http://haskell.org/haskellwiki/Applications_and_libraries/Games yet
17:00:34 <gwern> roguestar hasn't been edited since september... :(
17:00:39 <sm> oh, good page
17:01:09 <Saizan> Cale: true, maybe i'm picturing it worse than it is.
17:02:46 <gwern> (ouch, mage fails hard in compilation)
17:07:28 <ehird> is there a 'Zeroable' class?
17:07:30 <ehird> like, for lists, []
17:07:33 <ehird> numbers, 0
17:07:34 <ehird> etc
17:07:43 <bd_> ehird: There's MonadZero
17:07:47 <bd_> but not for numbers
17:07:59 <bd_> what would the semantics of 'Zeroable' be?
17:08:06 <ehird> bd_: i am not entirely sure :-)
17:08:33 <bd_> I mean, zero-the-number and zero-the-list are very different beasts :)
17:08:41 <oerjan> bd_: there is _not_ MonadZero.  it was removed in H98.
17:08:42 <ehird> I guess: the Zeroable class includes things that have an element that is one of: zero, empty, blan
17:08:42 <ehird> k
17:08:54 <bd_> oerjan: er, MonadPlus even
17:08:58 <roconnor>  MonadZero was in Haskell 1.4?
17:09:04 <dons> yeah
17:09:07 <bd_> ehird: yes, but what are the semantics of that? :)
17:09:18 <ehird> bd_: fuzzy, that's what
17:09:19 <bd_> what does it mean to be zero?
17:09:20 <ehird> and that's darned useful
17:09:21 <ehird> :(
17:09:23 <pjd> ehird: that would be MonoidZero, if such existed
17:09:39 <bd_> pjd: Num does not imply Monoid though
17:09:42 <Stinger> wait
17:09:49 <roconnor> @type Sum
17:09:51 <lambdabot> forall a. a -> Sum a
17:10:15 <roconnor> @hoogle Sum
17:10:16 <lambdabot> Data.Monoid.Sum :: newtype Sum a
17:10:16 <lambdabot> Data.Monoid.Sum :: a -> Sum a
17:10:16 <lambdabot> Prelude.sum :: Num a => [a] -> a
17:10:22 <Stinger> is there an arrow combinator that runs a bunch of computations in parallel with the same input data and stores the results in a list?
17:10:24 <pjd> there's Alternative from Applicative as, err, alternative to MonadZero
17:10:59 <Stinger> wait ignore that
17:11:18 <ehird> @hpaste
17:11:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:11:27 <hpaste>  ehird pasted "i am evil" at http://hpaste.org/5806
17:11:30 <pjd> oh, doy
17:11:31 <oerjan> Stinger: urm that's the one i showed above
17:11:39 <pjd> Monoid already includes mzero, obviously
17:11:44 <oerjan> it's not predefined afaik
17:11:56 <roconnor> > getSum mempty
17:11:59 <lambdabot>  0
17:12:04 <roconnor> > getProduct mempty
17:12:06 <lambdabot>  1
17:12:08 <roconnor> :D
17:12:08 <pjd> s/mzero/mempty/
17:12:18 <ehird> pjd: yes but monoid implies more
17:12:56 <pjd> ehird: well, you have to attach some semantics to the zero to make it meaningful
17:13:01 <ehird> true
17:13:02 <roconnor> > mempty :: [Integer]
17:13:03 <lambdabot>  []
17:13:17 <pjd> Monoid makes it the monoid identity
17:13:31 <roconnor> > mempty 5 :: Integer
17:13:31 <pjd> which is generally meaningful and useful
17:13:35 <lambdabot>   add an instance declaration for (Monoid Integer)
17:13:35 <lambdabot>     In the expression: mem...
17:13:55 <roconnor> > appEndo mempty 5 :: Integer
17:13:56 <lambdabot>  5
17:14:03 <roconnor> > appEndo mempty 5
17:14:05 <lambdabot>  5
17:14:13 <roconnor> > appEndo mempty x :: Expr
17:14:14 <lambdabot>  x
17:14:33 <roconnor> > mempty :: Ordering
17:14:34 <lambdabot>  EQ
17:14:50 <roconnor> > getAny mempty
17:14:51 <lambdabot>  False
17:14:55 <roconnor> > getAll mempty
17:14:56 <lambdabot>  True
17:15:18 <pjd> yay for Monoid
17:18:36 <roconnor> presumably there is a function Monoid a => [a] -> a somewhere?
17:18:55 <ivan_> @unmtl ErrorT q (StateT r IO) a
17:18:56 <roconnor> ah mconcat
17:18:56 <lambdabot> r -> IO (Either q a, r)
17:19:00 <dons> yep
17:19:34 <roconnor> > mconcat [] :: [Expr]
17:19:35 <lambdabot>  []
17:19:59 <roconnor> ah, it's concat
17:20:03 <roconnor> hence the name :D
17:20:28 <pjd> mconcat = foldr mappend mempty
17:20:39 <roconnor> @src concat
17:20:39 <lambdabot> concat = foldr (++) []
17:20:42 <roconnor> @src mconcat
17:20:43 <lambdabot> Source not found.
17:28:12 <TomMD> > "test"
17:28:16 <lambdabot>  "test"
17:31:43 <roconnor> where can I find documenation on how lambdabot's Expr works?
17:31:54 <oerjan> @where Expr
17:31:55 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
17:32:04 <ehird> where is that Y in Haskell?
17:32:09 <ehird> roconnor: i believe you wrote it
17:32:18 <oerjan> @index fix
17:32:19 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
17:32:43 <ehird> oerjan: no
17:32:43 <oerjan> ehird: ^^
17:32:44 <ehird> Y
17:32:44 <roconnor> http://r6.ca/blog/20060919T084800Z.html
17:32:45 <lambdabot> Title: Y Combinator in Haskell
17:32:45 <ehird> Y != fix
17:32:57 <oerjan> they are equivalent
17:33:15 <ehird> oerjan: the definition is not
17:33:18 <ehird> the outside interface; yes.
17:34:05 <roconnor> > var "test"
17:34:07 <lambdabot>  test
17:34:50 <roconnor> > var "> var \"test\""
17:34:52 <lambdabot>  > var "test"
17:34:56 <roconnor> damn
17:35:06 <roconnor> if only we had another lambdabot in here.
17:35:20 <oerjan> > var "test\n> var \"test\""
17:35:20 <yondalf> @hoogle maximumBy
17:35:21 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
17:35:21 <lambdabot> Data.Foldable.maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
17:35:22 <lambdabot>  test
17:35:22 <lambdabot> > var "test"
17:35:25 <roconnor> > var "@karma+ lambdabot"
17:35:26 <lambdabot>  @karma+ lambdabot
17:35:39 <yondalf> @hoogle Ordering
17:35:39 <lambdabot> Prelude.Ordering :: data Ordering
17:35:39 <lambdabot> Data.Ord.Ordering :: data Ordering
17:35:49 <yondalf> @src Ordering
17:35:50 <lambdabot> data Ordering = LT | EQ | GT
17:35:55 <oerjan> roconnor: note the initial space.  and also, lambdabot of course doesn't see her own messages
17:36:31 <roconnor> oerjan: I don't see the initial space.
17:36:31 <ehird> oerjan: is the initial space deisgned to prevent exactly that? :-)
17:36:34 <ehird>  > 2
17:36:40 <ehird> yep, i think so..
17:36:47 <ivanm> pffft, people why try and stop lambdabot from getting into recursive loops :@
17:36:48 <oerjan> roconnor: oh.  well it's there, unless you use the \n trick
17:37:03 <oerjan> ehird: yes
17:37:10 <yondalf> @src on
17:37:10 <lambdabot> (*) `on` f = \x y -> f x * f y
17:37:15 <roconnor>  > 2
17:37:16 <ehird> once in #esoteric someone wrote an underload program that looped EgoBot and bsmnt_bot...
17:37:17 <roconnor> > 2
17:37:18 <lambdabot>  2
17:37:25 <ehird> iirc, they had to start an underload daemon on both of them to do it
17:37:30 <roconnor> bah, Konversation sucks.
17:37:30 <ivanm> heh
17:37:32 <ehird> or was it brainfuck? whatever it was; it was impressive
17:37:34 <ehird> ah, wait
17:37:37 <ehird> it was EgoBot/blahbot
17:37:43 <ehird> bsmnt_bot, iirc, was not actively involved
17:37:44 <roconnor> it is filtering those initial spaces. :/
17:37:52 <oerjan> ivanm: actually lambdabot not seeing her own messages is just ordinary irc behavior.
17:38:10 <oerjan> your client does not get your messages back from the server either
17:38:23 <ivanm> ahhh, but the client just prints what it sends?
17:39:03 <yondalf> @hoogle on
17:39:03 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:39:03 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
17:39:03 <lambdabot> Data.Function :: module
17:39:18 <oerjan> ivanm: yep
17:40:17 <oerjan> one annoying side effect of this (in irssi at any rate) is that i can see color codes in my own messages even it the channel blocks them
17:40:44 <yondalf> in a list comprehension, how do i do the equivalent of a let binding other than by using retVal <- return bla blabla?
17:40:51 <oerjan> not that it comes up often :D
17:41:13 <oerjan> > [x | n <- [1..10], let x = 2*n]
17:41:15 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
17:42:11 <yondalf> oerjan: ah...thanks
17:43:29 <ivanm> oerjan: :o what client do you use?
17:43:41 <ivanm> oh, wait, you said, irssi
17:48:47 <aFlag> @help
17:48:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:48:55 <aFlag> @list
17:48:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:49:00 <Stinger> hmm Uwe Schmidt doesn't happen to frequent this channel does he?
17:49:22 <dcoutts_> gwern: I wonder if we could get the pugs people to stop using hsc2hs' #def feature, it seems the only make minimal use of it and that could probably be replaced by just making a proper .h file
17:49:27 <Cin> hs-plugins confuses me
17:49:37 <yondalf> > fix id
17:49:39 <lambdabot>  Exception: <<loop>>
17:49:51 <gwern> dcoutts_: that way lies madness!
17:50:14 <dcoutts_> gwern: they're using it to add prototypes to things they should have found in a .h file
17:50:18 <gwern> but seriously, write them a .h file and I suspect they'll simply accept it quietly. one less bug
17:50:39 <aFlag> @google brain dead arrays
17:50:40 <lambdabot> No Result Found.
17:50:55 <dcoutts_> gwern: ok, I'll go find their bug tracker
17:51:00 <aFlag> hm, I think there's a problem with the google plugin of lambdabot
17:51:04 <Stinger> try braindead one word :)
17:51:16 <aFlag> yeah
17:51:18 <aFlag> but the thing is
17:51:22 <aFlag> google returns results
17:51:24 <gwern> dcoutts_: I have a commit bit, if you want to send me it
17:51:51 <dcoutts_> gwern: I'll file a bug with the suggestion
17:51:53 <aFlag> when you type something a little weirder the bot doesn't answer
17:52:00 <oerjan> aFlag: i've been noticing @google seems broken recently
17:52:01 <gwern> 'k
17:52:02 <aFlag> I couldn't figure out why that happens
17:52:30 <aFlag> the same address lambdabot generates seem to work differently when I use firefox
17:52:40 <dcoutts_> gwern: oh, seems I cannot file a bug, I don't have an account and I don't see a guest account
17:52:42 <oerjan> perhaps lambdabot doesn't send the proper URL?
17:52:49 <oerjan> oh
17:52:56 <dcoutts_> gwern: oh, my mistake, I can :-)
17:53:07 <aFlag> I think it does because I used the same logic as lambdabot on a python script I made
17:53:15 <aFlag> and it crashes just the same
17:53:31 <aFlag> google seems to give some weird results sometimes
17:53:38 <aFlag> I couldn't quite figure out what's going on
17:54:59 <oerjan> @go "brain dead arrays"
17:55:01 <lambdabot> http://www.drunkendata.com/?p=952
17:55:01 <lambdabot> Title: DrunkenData.com ª Blog Archive ª Stupid Vendor Tricks
17:55:04 <oerjan> heh
17:55:20 <oerjan> that worked, despite giving only 4 results in the browser
17:55:32 <oerjan> er 3
17:55:49 <oerjan> @go brain dead arrays
17:55:50 <lambdabot> No Result Found.
17:56:22 <oerjan> @go brain AND dead AND arrays
17:56:23 <lambdabot> No Result Found.
17:56:30 <aFlag> it's not very determinstic, or at least I couldn't find any determinism, but it seems to happen more often with unpopular results
17:56:41 <oerjan> @go brain dead
17:56:42 <lambdabot> http://www.imdb.com/title/tt0103873/
17:56:42 <lambdabot> Title: Braindead (1992)
17:57:26 <oerjan> er it's not nondeterministic either, the same search gives the same result...
17:57:31 <aFlag> you should check what google answers, is something really weird
17:58:04 <aFlag> oh yeah, but I couldn't find like a pattern to always produce requests that doesn't work
17:59:56 <aFlag> probably the most reliable way is not to use I'm feeling lucky but parse the result page and get the first result
18:00:03 <aFlag> although that's much more painful
18:04:52 <oerjan> @go "However, as it stands the array dump simply dumps 'Object:'"
18:04:53 <lambdabot> No Result Found.
18:05:14 <oerjan> could it be something with the result URL?
18:06:14 <oerjan> hm wait that one doesn't work in the browser either
18:06:51 <pjd> has anyone looked at http://www.erights.org/enative/fatpointers.html ?
18:06:51 <lambdabot> Title: Fat Pointers
18:07:07 <pjd> it looks an awful lot like type classes
18:07:13 <aFlag> I have no way to test what lambdabot gets on those cases right now, but my script gets this: http://rafb.net/p/zjxvVv63.html
18:07:14 <lambdabot> Title: Nopaste - No description
18:07:34 <aFlag> there's no Location: field
18:08:12 <aFlag> maybe someone with more experience on HTTP protocol knows what that means
18:08:37 <dcoutts_> gwern: http://dev.pugscode.org/ticket/32
18:08:37 <lambdabot> Title: #32 (Using hsc2hs's #def feature leads to pain, don't use it) - Pugs - Trac
18:08:58 <aFlag> seems like it's trying to show all the results
18:09:07 <aFlag> but there's missing stuff
18:09:51 <oerjan> what is the URL lambdabot sends?
18:10:07 <aFlag> I checked google's "I'm feeling lucky" button and there's no other stuff to add there to my knowledge
18:10:38 <oerjan> what is the URL lambdabot sends?
18:11:08 <aFlag> "search?hl=en&" ++ query ++ "&btnI=I%27m+Feeling+Lucky"
18:11:55 <phobes> Every time I go to www.google.com and press "I'm feeling lucky" it takes me to the same page explaining what that button does.  It hasn't guessed what I wanted to search for once.
18:12:04 <gwern> dcoutts_: I see it. looks good
18:12:14 <dcoutts_> gwern: if you can comment on that ticket I made (because I cannot) you could link to the hsc2hs bit in the user guide
18:12:16 <dcoutts_> http://haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
18:12:45 <gwern> dcoutts_: you mean comment on their bts?
18:12:50 <gwern> dunno what'd I say
18:12:53 <dcoutts_> gwern: and point out the section where it says it's best not to use #def in a lib, which is exactly what pugs is doing, the Pugs.Eval is being used in the lib
18:12:59 <gwern> I already had my say on the cabal cts and in the NOTES
18:13:23 <dcoutts_> gwern: I'd add that comment but I cannot now make any modifications or comments as anonymous
18:13:54 <dcoutts_> gwern: it says some stuff and then "For this reason we avoid using #def  in the libraries."
18:16:35 <gwern> 'For this reason we avoid using #def  in the libraries.'
18:17:12 <dcoutts_> gwern: aye, that's the advice the pugs people will want to know about.
18:17:27 <dcoutts_> especially when it's so easy to avoid
18:17:46 <gwern> https://dev.pugscode.org/ticket/32#comment:1
18:18:33 <joew> > snd (fst ((1,"what i want"), "foo"))
18:18:37 <lambdabot>  "what i want"
18:18:44 <joew> > snd . fst ((1,"what i want"), "foo")
18:18:45 <lambdabot>  Couldn't match expected type `a -> (a1, b)'
18:18:58 <Cin> gwern: what were you hacking on mohws for?
18:19:08 <joew> Anyone know what I'm doing wrong in that second line?
18:19:19 <dcoutts_> gwern: thanks :-)
18:19:19 <gwern> Cin: dons asked me to
18:19:33 <Cin> ic
18:19:38 <gwern> > snd $ fst ((1,"what i want"), "foo")
18:19:39 <lambdabot>  "what i want"
18:19:58 <gwern> > snd . fst $ ((1,"what i want"), "foo")
18:19:59 <lambdabot>  "what i want"
18:20:05 <joew> ah
18:20:08 <joew> thanks
18:20:10 <gwern> > (snd . fst) ((1,"what i want"), "foo")
18:20:11 <lambdabot>  "what i want"
18:20:21 <dcoutts_> gwern: though note that you didn't tell beingert before uploading mohws
18:20:27 <gwern> . & $ - tricky stuff sometimes
18:20:51 <gwern> dcoutts_: eh. I told him afterwards. if he had a problem, he could upload a fresher one
18:21:54 * gwern goes and watches the democratic debate now
18:21:54 * oerjan suddenly wonders if there is an EIEIO monad
18:22:25 <LoganCapaldo> > first snd ((1, "what i want"), "foo")
18:22:26 <lambdabot>  ("what i want","foo")
18:22:36 <LoganCapaldo> mmm
18:22:47 <LoganCapaldo> > fst $ first snd ((1, "what i want"), "foo")
18:23:14 <lambdabot>  "what i want"
18:23:49 <yondalf> @src first
18:23:49 <lambdabot> Source not found. It can only be attributed to human error.
18:24:01 <yondalf> :t first
18:24:02 <oerjan> @src Arrow
18:24:02 <lambdabot> class Arrow a where
18:24:02 <lambdabot>     arr, pure   :: (b -> c) -> a b c
18:24:02 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
18:24:02 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
18:24:02 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
18:24:04 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
18:24:06 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
18:24:08 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
18:24:23 <LoganCapaldo> @src (->) first
18:24:23 <lambdabot> first f = f *** id
18:24:27 <pjd> first f (a,b) = (f a,b)
18:24:32 <boy> 2 + 3
18:24:57 <boy> lambdabot doesn't evaluate math expressions?
18:25:05 <oerjan> > 2 + 3
18:25:05 <Cin> you need a >
18:25:06 <lambdabot>  5
18:25:12 <boy> ah, thanks :)
18:25:33 <LoganCapaldo> and no she doesn't, just that subset of math that's included in haskell :)
18:25:58 <boy> > 2 ^ 90000
18:25:59 <lambdabot>  5007370867425510162021727393252605928760069676724707517292401963897794967376...
18:26:32 <pjd> > 2 ^ 90000 :: Expr
18:26:32 <lambdabot>  2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)) * (2 * 2 * (2 * 2) * (2 * 2 * (2 * 2))) ...
18:26:42 <roconnor> pjd: stop that :)
18:27:03 <pjd> roconnor: but shiny :)
18:27:33 <dmwit> > 2 ^ 256 :: Expr
18:27:33 <lambdabot>  2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)) * (2 * 2 * (2 * 2) * (2 * 2 * (2 * 2))) ...
18:27:34 <dmwit> Huh, I thought it would be more explicit about the repeated squaring.
18:28:03 <pjd> well, the expansion presumably doesn't make shared subexpressions explicit
18:28:05 <LoganCapaldo>  I'm a little surprised it doesn't come back with 2 ^ 256
18:28:19 <roconnor> dmwit: (^) is not a class instance :(
18:28:19 <alatter> what's the `Expr' type from?
18:28:26 <oerjan> @where Expr
18:28:27 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
18:28:28 <LoganCapaldo> bu I guess (^) isn't part of a type class
18:28:46 <roconnor> dmwit: I meant what LoganCapaldo said.
18:29:04 <dmwit> roconnor: No but presumably (*) is.
18:29:09 <dmwit> +,
18:29:18 <roconnor> right, and that's why you see so many stars
18:29:35 <dmwit> roconnor: What I'm saying is, I'm surprised it isn't something like
18:29:49 <dmwit> ((2 * 2) * (2 * 2)) * ((2 * 2) * (2 * 2)) ...
18:30:01 <roconnor> dmwit: it is
18:30:09 <dmwit> ...oh!
18:30:19 <LoganCapaldo> > 2^ 8
18:30:21 <lambdabot>  256
18:30:30 <LoganCapaldo> > 2^ 8 :: Expr
18:30:31 <lambdabot>  2 * 2 * (2 * 2) * (2 * 2 * (2 * 2))
18:30:47 <dmwit> Yeah, it just drops the early parens.  That's pretty cool!
18:31:00 <roconnor> what is the associativity of *?
18:31:20 <EvilTerran> :i *
18:31:21 <dmwit> infixl 7
18:31:23 <oerjan> > (0$0 *)
18:31:24 <lambdabot>      The operator `*' [infixl 7] of a section
18:31:24 <lambdabot>         must have lower precede...
18:31:26 <EvilTerran> (in ghci)
18:31:35 <EvilTerran> oerjan, clever
18:32:13 <pjd> 0$0, the operator info operator
18:32:28 <roconnor> what does left associative mean :)
18:32:41 <oerjan> roconnor: a * b * c parses as (a * b) * c
18:32:46 <dmwit> It means (a * b * c) === ((a * b) * c ).
18:32:53 <roconnor> perfect!
18:32:58 <Stinger> as opposed to (a * (b * c))
18:33:22 <roconnor> hence dmwit's droped parenthesis
18:33:51 <roconnor> theses
18:33:53 <roconnor> er
18:33:58 <roconnor> parentheses
18:35:30 * oerjan hopes dmwit isn't dropping his theses
18:35:33 <dmwit> Theses commentses don't make senses.
18:43:17 <boy> if i want a function from the standard libs but don't know what's its name is, what's the easiest way to find out?
18:43:25 <Cin> hoogle
18:43:30 <Lemmih> #haskell
18:43:32 <Cin> @url hoogle
18:43:32 <lambdabot> http://haskell.org/hoogle
18:43:37 <LoganCapaldo> hoooooooooooogle
18:43:54 <LoganCapaldo> @hoogle (Eq a) => a -> [a] -> Maybe Int
18:43:54 <boy> ok, i can type in normal apropos-type searches?
18:43:55 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
18:43:56 <kpreid> @hoogle String -> [String]
18:43:56 <lambdabot> Prelude.lines :: String -> [String]
18:43:56 <lambdabot> Prelude.words :: String -> [String]
18:43:56 <lambdabot> Data.List.lines :: String -> [String]
18:44:06 <kpreid> boy: yes, and also type-based searches
18:44:07 <oerjan> > 'h':repeat 'o'++"gle"
18:44:11 <lambdabot>  "hoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
18:44:13 <kpreid> @hoogle filter
18:44:13 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
18:44:13 <lambdabot> Data.List.filter :: (a -> Bool) -> [a] -> [a]
18:44:13 <lambdabot> Data.ByteString.filter :: (Word8 -> Bool) -> ByteString -> ByteString
18:44:16 <boy> i've been using hoogle, but didn't know that :)
18:44:40 <kpreid> boy: the hoogle web interface has many results and useful hyperlinks; lambdabot shows only three
18:45:06 <LoganCapaldo> > 'h':repeat 'o
18:45:07 <lambdabot>  Improperly terminated character constant at "'o" (column 12)
18:45:10 <LoganCapaldo> > 'h':repeat 'o'
18:45:10 <idnar> @hoogle+
18:45:11 <lambdabot> Data.Set.filter :: Ord a => (a -> Bool) -> Set a -> Set a
18:45:11 <lambdabot> Data.Map.filter :: Ord k => (a -> Bool) -> Map k a -> Map k a
18:45:11 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
18:45:11 <boy> so i typed in "concatenation" into hoogle and get nothing, though i'd expect at least concat to come back
18:45:11 <lambdabot>  "hoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
18:45:32 <LoganCapaldo> hoogle doesn't do stemming does it?
18:45:49 <oerjan> boy: i think it only searches for things containing your term
18:45:55 <oerjan> @hoogle filt
18:45:56 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
18:45:56 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
18:45:56 <lambdabot> Data.List.filter :: (a -> Bool) -> [a] -> [a]
18:46:32 <Mr_Awesome> why does hoogle's home page have a christmas tree?
18:46:43 <Cin> man. hs-plugins really makes me feel like i'm not clever enough. should i start learning java now?
18:47:20 <boy> yeah, it appears that way... i was hoping for something like man -k
18:49:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5807
18:49:26 <hasenov> hello, i just pasted some code that I have a question on
18:50:03 <hasenov> in rowValues, I want to check a row to see if there everything is Just X in there
18:50:32 <Cin> :t isJust
18:50:33 <lambdabot> forall a. Maybe a -> Bool
18:50:41 <hasenov> however, I want to recycle the function and make it more general, so that it works with Just O also
18:51:17 <hasenov> basically, what I want to do is reverse all the Xs to Os and then send them through the function
18:51:47 <oerjan> hasenov: why not pass 'X' or 'O' as arguments?
18:51:49 <Mr_Awesome> hasenov: you could add an extra argument to the function
18:52:15 <hasenov> oh, i guess, i was thinking about making a Class or smthing
18:53:12 <hasenov> and have Just a rather than Just X or Just O
18:55:14 <oerjan> > let diag ((x:_):xs) = x:diag xs; diag [] = [] in diag [[1,2,3],[4,5,6],[7,8,9]]
18:55:15 <lambdabot>  [1,4,7]
18:55:55 <oerjan> er wait
18:55:58 <hasenov> to make it more generic
18:56:09 <oerjan> > let diag ((x:_):xs) = x:diag (map tail xs); diag [] = [] in diag [[1,2,3],[4,5,6],[7,8,9]]
18:56:10 <lambdabot>  [1,5,9]
18:57:45 <hasenov> oh, for that, i knew there was an easier way :)
18:57:53 <boy> am i missing out on any must-have haskell writing features by using Vim instead of emacs?
18:58:42 <pjd> > let diag xs =  zipWith (!!) xs [0..] in diag [[1,2,3],[4,5,6],[7,8,9]]
18:58:43 <lambdabot>  [1,5,9]
18:59:31 <hpaste>  LoganCapaldo annotated "(no title)" with "meh?" at http://hpaste.org/5807#a1
19:00:31 <oerjan> LoganCapaldo: this is obviously Tic-Tac-Toe, it is important not just to have Just but also what is inside it
19:00:51 <LoganCapaldo> right
19:00:59 <LoganCapaldo> that's what the group is for
19:01:15 <oerjan> um no
19:01:26 <oerjan> that would treat O O O and X X X equally
19:01:33 <LoganCapaldo> right
19:01:38 <LoganCapaldo> which is what he was asking for
19:01:39 <oerjan> you don't find out _who_ won
19:01:49 <oerjan> no it wasn't
19:02:08 <oerjan> he wants to ask for a specific player
19:02:42 <hasenov> i want to find the min or max of the final game position
19:03:07 <hasenov> if there is any row, any column, or any diagonal, output a 1
19:03:24 <Cin> i want to compile a .hs file to a .o which i can then load and use. if the .hs file hasn't changed since the last compilation i don't want it to do any re-compilation. i also want it to compile its dependancies. like if Foo imports Bar, i want it to compile the associated Bar.hs file, like ghc --make does. should i just launch a ghc process to do it?
19:03:25 <hasenov> otherwise, if the flip of that is true, output -1
19:03:38 <hasenov> otherwise, its a draw so output 0
19:04:04 <LoganCapaldo> so IOW, treating X X X the same as O O O is perfectly fine?
19:04:23 <oerjan> LoganCapaldo: NO!
19:04:49 <LoganCapaldo> so angry about tic tac toe
19:04:58 * oerjan jumps up and down
19:05:15 * oerjan notices he has a stiff neck.  That may be it.
19:05:55 <hasenov> you can imagine the Xs as True and Os as False, thats what I did at first
19:06:30 <hasenov> but then i realized that some of the values will be Nothing, so I changed it to a data structure
19:07:03 <Cin> oh great. i have a nose bleed
19:07:08 <Cin> this is what hs-plugins has done to me
19:07:31 <oerjan> it would be possible to use the group idea if you did it differently, and returned Just X, Just O or Nothing dependently
19:08:00 <oerjan> could even use msum to combine the results for various lines
19:09:21 <oerjan> do [[x]] <- Just (group l); return x
19:09:55 <oerjan> er wait
19:10:02 <oerjan> do [[x]] <- Just (group l); x
19:10:24 <oerjan> um
19:10:33 <oerjan> do [x:_] <- Just (group l); x
19:10:34 <LoganCapaldo> [x:_] if you're gonan do it like that no?
19:14:30 <Stinger> head . fromJust ?
19:14:44 <LoganCapaldo> that won't fail gracefully
19:14:53 <LoganCapaldo> which is the point of using the do notation
19:15:15 <Stinger> ah
19:15:29 <LoganCapaldo> @undo do { [x:_] <- Just (group l); x }
19:15:31 <lambdabot> Just (group l) >>= \ a -> case a of { [x : _] -> x; _ -> fail ""}
19:15:46 <LoganCapaldo> @src Maybe fail
19:15:47 <lambdabot> fail _      = Nothing
19:18:01 <oerjan> it actually desugars to something similar to what LoganCapaldo wrote on hpaste
19:24:26 <gwern> http://www.erlware.org/index.html <-- the Erlangers get cabal/hackage envy
19:24:26 <lambdabot> Title: Erlware
19:25:10 <Stinger> when does fail actually get called
19:25:17 <Stinger> just on pattern match failure?
19:25:28 <LoganCapaldo> eggzactly
19:25:33 <LoganCapaldo> well
19:25:36 <LoganCapaldo> and when you call it
19:25:55 <LoganCapaldo> > fail "perfectly cromulent" :: Maybe ()
19:25:58 <lambdabot>  Nothing
19:26:43 <LoganCapaldo> but pattern match failure on the lhs of <- in do notation invokes fail
19:27:16 <LoganCapaldo> (which is why Monad needs fail, or conversely why do notation needs to be restricted to MonadFail ;) )
19:32:07 <gwern> @where mage
19:32:07 <lambdabot> I know nothing about mage.
19:34:10 <gwern> hm. mage is hosted by Shae Erisson, but mentions dark@xs4all.nl
19:38:03 <oerjan> @seen shapr
19:38:03 <lambdabot> I saw shapr leaving #scannedinavian, #haskell-blah and #haskell 6h 8m 24s ago, and .
19:43:07 <gwern> hm. ah, so Shae Erisson is shapr: http://c2.com/cgi/wiki?ShaeErisson
19:43:10 <lambdabot> Title: Shae Erisson
19:43:17 <noige_> hi
19:43:55 <noige_> I am a noob but I have a style question
19:44:02 <noige_> let cylvol b h = (cirarea b) * h
19:44:18 <gwern> @seen dark
19:44:19 <lambdabot> I haven't seen dark.
19:44:22 <noige_> should I just let cylvol b h = cirarea b * h or keep the parens?
19:44:29 <gwern> shoot. he hasn't been here in that long eh
19:44:31 <oerjan> drop the parens
19:44:46 <bos> noige_: it would be unusual to use parens when not necessary
19:44:54 <noige_> ok
19:45:03 <noige_> for some reason it makes it more clear
19:45:11 <noige_> to me
19:45:16 <noige_> but that is because I am knew
19:45:20 <noige_> thank you
19:45:33 <noige_> err new <- knew
19:45:47 <TomMD> I don't see a "Common Mistakes and Misunderstandings" wiki page for newbies.  Would I be repeating something if I made one?
19:45:51 <yondalf_> in haskell function application always binds the tighest so i think we won't have problems parsing that as (cirarea b) * h
19:46:03 <noige_> yondalf_: it works
19:46:06 <noige_> as expected
19:46:17 <noige_> but I noticed that the soln didnt use ()
19:46:28 <noige_> so I was just wondering if I should drop them
19:46:41 <noige_> and by "binds the tightest" what do you mean?
19:46:59 <yondalf_> noige_: binds the tightest means highest precedence...sorry, using the wrong words :-)
19:47:21 <jbms> The ArrayRef package is not compiling with GHC 6.8.2: I
19:47:40 <noige_> ahh ok
19:47:41 <jbms> I'm getting this error: Data/Unboxed.hs:149:0: Parse error in pattern
19:47:46 <jbms> Does anyone know if this is a known problem?
19:48:02 <noige_> so I need to learn precendence in haskell
19:48:05 <noige_> awesome
19:48:18 <gwern> @tell shapr Say, do you happen to know the license on that nethack-alike you host on scannedavian, 'mage-1.0pre35'? the tarball doesn't mention any licenses, and I'm loathe to contact the only email address mentioned, a dark@xs4all.nl because I don't know if dark made any final license decision; http://www.cse.unsw.edu.au/~dons/code/irc-logs/02.10.30 says '07:59:34 <dark> Marvin: It doesn't have a license statement yet, but assume 2-clause BSD :-)' ...
19:48:18 <lambdabot> Consider it noted.
19:48:22 <gwern> ... also d'you know if there were any later versions?
19:48:45 <gwern> uhoh. guess my second line wouldn't be included by lambdabot
19:48:53 <gwern> @tell shapr ... also d'you know if there were any later versions?
19:48:54 <lambdabot> Consider it noted.
19:52:55 <gwern> @hoogle [a]  -> Set a
19:52:55 <lambdabot> Data.Set.fromDistinctAscList :: [a] -> Set a
19:52:55 <lambdabot> Data.Set.fromList :: Ord a => [a] -> Set a
19:52:55 <lambdabot> Data.Set.fromAscList :: Eq a => [a] -> Set a
19:53:43 <gwern> @hoogle Set a -> [a]
19:53:43 <lambdabot> Data.Set.elems :: Set a -> [a]
19:53:43 <lambdabot> Data.Set.toList :: Set a -> [a]
19:53:43 <lambdabot> Data.Set.toAscList :: Set a -> [a]
19:54:24 <gwern> @hoogle Set a -> a -> Set a
19:54:24 <lambdabot> Data.Set.insert :: Ord a => a -> Set a -> Set a
19:54:24 <lambdabot> Data.Set.delete :: Ord a => a -> Set a -> Set a
19:54:51 <gwern> @hoogle a -> Set a -> Bool
19:54:51 <lambdabot> Data.Set.member :: Ord a => a -> Set a -> Bool
19:54:51 <lambdabot> Data.Set.notMember :: Ord a => a -> Set a -> Bool
19:55:34 <gwern> @hoogle Set a -> Set a -> Set a
19:55:35 <lambdabot> Data.Set.(\\) :: Ord a => Set a -> Set a -> Set a
19:55:35 <lambdabot> Data.Set.union :: Ord a => Set a -> Set a -> Set a
19:55:35 <lambdabot> Data.Set.difference :: Ord a => Set a -> Set a -> Set a
19:55:43 <jbms> Any users of the ArrayRef library?
19:55:47 <jfredett> :r
19:55:56 <jfredett> jake damnit...
19:57:25 <oerjan> jfredett is a vampire :D
19:59:03 <gwern> ...wow, mage just compiled
19:59:29 <gwern> ooh. colored ascii. and the d-pad works
19:59:55 <gwern> (seriously, what the hell is wrong with the nethack devteam that 20 years in and nethack still doesn't support directional keys?)
20:00:35 <Cale> What?
20:00:50 <Cale> The arrow keys and numpad work here.
20:01:08 <gwern> arrow keys have never worked for movement for me
20:05:15 <yondalf_> i just downloaded mage, ghc --make fails with "could not find module `Data.FiniteMap'", what should i do? it's not in ghc but apparently it's in hugs cvs with the note that it's deprecated
20:05:32 <gwern> yondalf_: cabal install it
20:05:43 <LoganCapaldo> Data.FiniteMap has been renamed to Data.Map
20:05:46 <kpreid> or adjust the code to use Data.Map
20:06:16 <gwern> yondalf_: d'you want me to send you my edited code? with finitemap installed, it compiles for me
20:06:59 <gwern> there's some tricky updating of Data.Map functiona names
20:07:18 <yondalf_> gwern: yes please
20:08:04 <yondalf_> gwern: e-mail to jonathantan86@hotmail.com
20:08:19 <yondalf_> (that address receives lots of spam already)
20:08:37 <Cin> how do i add something to my PATH from bash? =o
20:08:52 <adu> export PATH="..."
20:09:00 <adu> or export PATH="$PATH:..."
20:09:03 <yondalf_> export PATH=$PATH:/your/new/dir
20:09:08 <Cin> ah, thanks
20:09:44 <adu> I have a question about import statements
21:12:47 <dons> Mr_Awesome: what monad in particular?
21:12:48 <Cin> sclv: ah, i see
21:12:58 <Cin> sclv: i've not heard of HStringTemplate, let me google it
21:13:24 <dons> hackage.haskell.org is where its at
21:13:32 <gwern> dons: yeah. that was actually the first article I ever saw on template haskell. I've been looking for it for ages
21:13:50 <Mr_Awesome> dons: none in particular
21:14:05 <Mr_Awesome> id like to keep it general if possible
21:15:13 <bos> i wonder what the default name of a ghc-generated binary is on windows.
21:15:20 <dons> .exe ?
21:15:31 <bos> well, that's the *suffix*
21:15:39 <bos> but is it a.out.exe, or something else?
21:15:48 <gwern> night all
21:15:53 * bos fires up vmware to find out
21:15:53 <Cin> night gwern
21:15:53 <dons> main.exe
21:15:55 <Zao> bos: main.exe, it looks like.
21:16:01 <sm> night gwern , all
21:16:06 <dons> grepping ghc/compiler/main/
21:16:17 <Zao> I made an empirical study instead.
21:16:37 <bos> thanks
21:16:42 <Mr_Awesome> is there any way to do what im doing?
21:17:06 <Mr_Awesome> *want to do
21:18:17 <oerjan> Mr_Awesome: there is msum but it does not do what you want for all monads
21:18:17 <dons> hmm, its much esaier to catch the first failure, than the first success
21:18:30 <dons> yeah, msum
21:18:36 <dons> > msum [Nothing, Nothing, Just 1 , Nothing , Just 2]
21:18:40 <lambdabot>  Just 1
21:18:53 <oerjan> for the list monad it gives a list of _all_ the successes instead
21:18:57 <sclv> > msum [[1],[2,3,4]]
21:18:59 <lambdabot>  [1,2,3,4]
21:18:59 <Cin> what's a cooler extension? .hsp or .fcgi or ___?
21:19:17 <jeffz> just call it .php2
21:19:36 <Cin> jeffz: haha, what
21:19:48 <oerjan> for Maybe and Error(T) monads, and perhaps even IO, it should be fine
21:19:55 <sclv> .lB-
21:19:59 <Zao> .hph
21:20:52 <Mr_Awesome> oerjan: so, is there any way to keep it general?
21:21:21 <sclv> *Main> msum [fail "ohwow", print "a", print "b", fail "zowie"]
21:21:23 <sclv> "a"
21:21:56 <oerjan> Mr_Awesome: that _is_ pretty general.  it just doesn't work well for the list monad because it collects alternatives by design
21:22:08 <Mr_Awesome> it requires MonadPlus though
21:22:30 <oerjan> yep.  there is nothing that can work for all monads.
21:23:28 <oerjan> after all, the default definition of fail is using error, which can only be caught in IO.  so if your monad uses the default fail and is not IO-based you are out of luck.
21:23:42 <sclv> have yr. monads be of type m (Maybe a) and fmap an msum.
21:24:04 <oerjan> yeah, you could signal failure in some other way...
21:24:23 <oerjan> which is essentially what the ErrorT transformer gives you, anyhow
21:24:36 <sclv> or rather msum <$> sequence
21:25:17 <oerjan> sclv: there is a problem with that.  all the side effects happen even for the remaining list elements
21:26:24 <wli> Well, the fail method of Monad must die.
21:26:45 <bos> heh, don't hold your breath.
21:26:48 <wli> It will probably literally require a successor language to accomplish that.
21:26:55 <oerjan> Mr_Awesome: using ErrorT gives you at least generality of what base monad you use
21:27:02 <Mr_Awesome> well, im trying to mimic the "not-just-maybe" lookup (i think its called?), so i want it usable in any situation where, say, Map.lookup could be used. but apparently this isnt possible...
21:27:28 <oerjan> :t Data.Map.lookup
21:27:29 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
21:27:31 <sclv> *Main> fromJust $ msum <$> sequence [Just $ print "a", Just $ print "b", Just $ fail "zowie"]
21:27:33 <sclv> "a"
21:28:17 <oerjan> sclv: that does not allow failure to depend on effects
21:28:53 <sclv> Mr_Awesome: c.f. the recent libraries discussion on adding readM to see why that is bad juju. the not justmaybe pattern only works with a few monads anyway.
21:29:12 <blargeyfarg> i just have to say that xmonad is fantastic
21:29:14 <oerjan> and besides you have msum and sequence in the wrong order, i think
21:29:20 * wli hasn't heard a peep about readM
21:29:36 <wli> sclv: What's this libraries discussion about readM?
21:29:45 <oerjan> sclv: huh?  there is something wrong about readM?
21:30:06 <sclv> the question was if we wanted to add maybeRead or readM and the consensus was to add the specialized one because "fail is a terrible wart"
21:30:40 <oerjan> sclv: it sounds like someone has let there animosity to fail cloud their judgement.
21:30:46 <oerjan> *their
21:31:17 <sclv> oerjan: yr right by the way. the sequence was unnecessary. fromJust $ msum does just as well.
21:31:18 <oerjan> and they could use mzero instead, anyhow
21:31:57 <adu> whats the difference between "toInteger" and (::Integer) ?
21:31:59 <wli> The H98 anti-polymorphic catastrophe has led to even more anti-polymorphism because it so horribly damaged the fundamental effect abstraction of the language.
21:32:02 <sclv> http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/8581
21:32:04 <lambdabot> Title: gmane.comp.lang.haskell.libraries
21:32:05 <dons> oerjan: well, the goal is to have a safe form of read
21:32:10 <sclv> the consensus was massively overwhelming.
21:32:12 <dons> one that can fail with error isn't safe
21:32:13 <oerjan> adu: ::Integer only forces what you already have to be an Integer
21:32:26 <dons> and you can lift the safe one into a failable one if yo uwant
21:32:39 <dons> safe, total functions first!
21:32:46 <oerjan> dons: readIO already _does_ fail with an ioError
21:32:58 <dons> yeah, its ridiculous
21:32:59 <adu> oerjan: isn't that what toInteger does too?
21:33:06 <wli> Fat lot of good that does if you're not in an IO monad.
21:33:07 <dons> and getEnv as well
21:33:17 <oerjan> adu: no.
21:33:36 <oerjan> > toInteger (10 :: Int) :: Integer
21:33:40 <lambdabot>  10
21:34:00 <oerjan> > (10 :: Int) :: Integer
21:34:03 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
21:34:24 <adu> > (fromInteger 10) :: Integer
21:34:25 <lambdabot>  10
21:35:29 <Mr_Awesome> sclv: so if the notjustmaybe idiom is garbage, what would you recommend? MonadError?
21:35:53 <sclv> beats me. depends what you want?
21:36:03 <wli> > lines [toEnum . negate $ 10^(9::Int)
21:36:03 <lambdabot>  Parse error at end of input
21:36:13 <wli> > lines [toEnum . negate $ 10^(9::Int)]
21:36:14 <lambdabot>  Exception: Prelude.chr: bad argument
21:36:29 <wli> So much for total functions ...
21:36:34 <Mr_Awesome> sclv: just a lookup function that can either return a value or fail in a way thats as flexible as possible
21:38:00 <adu> ?src toInteger
21:38:00 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:38:22 <wli> Mr_Awesome: Fat chance until monad transformers hit the standard libraries... probably too long after annual petroleum production's exponential decline's onset for any of us to see if it's going to happen at all.
21:38:50 <oerjan> @src Integral
21:38:51 <lambdabot> class  (Real a, Enum a) => Integral a  where
21:38:51 <lambdabot>     quot, rem, div, mod :: a -> a -> a
21:38:51 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
21:38:51 <lambdabot>     toInteger           :: a -> Integer
21:39:44 <Mr_Awesome> wli: darn. ive always been unsure about the best error handling strategy in haskell
21:39:49 <sclv> I was pretty swayed by the arguments for monadplus actually
21:40:22 <sclv> on the other hand, for lookup, maybe is the obvious logical thing. either its there or its not.
21:41:36 <wli> Monad0/MonadZero more like. MonadPlus' destruction via conflation with MonadZero was yet another H98 cataclysm.
21:42:38 <Mr_Awesome> what did monadplus use to be?
21:42:54 <noige_> I have this query
21:42:56 <noige_> 5:4:3:2:1:cons:cons
21:43:08 <noige_> that doesnt work because cons is a list and 5, 4, 3, 2, 1 are ints?
21:43:15 <wli> Mr_Awesome: class MonadPlus m where (++) :: m a -> m a -> m a
21:43:23 <noige_> so adding the last :cons breaks it?
21:43:32 <Mr_Awesome> noige_: yeah, try ++cons at the end
21:43:53 <noige_> Mr_Awesome: I was just trying to confirm that I have a grasp on why it is broken
21:44:01 <Mr_Awesome> ah, indeed you do then
21:44:05 <noige_> thanks though, now I know how to make it work then :)
21:44:07 <noige_> awesome
21:44:26 <noige_> great
21:44:28 <noige_> that works
21:44:31 <Mr_Awesome> wli: what was MonadZero then?
21:44:33 <wli> Mr_Awesome: Its method was not mappend but rather (++), and it was properly divorced from Monad0 (I think called MonadZero in some other places). The String-monomorphic (++) was yet more H98 anti-polymorphic castration.
21:44:57 <wli> Mr_Awesome: class Monad0 m where zero :: m a
21:45:26 <Mr_Awesome> hmm. what is an example of something that was one but not the other?
21:47:10 <wli> Like anything with failure but no append analogue?
21:47:15 <wli> Try, for instance, Maybe
21:47:52 <Mr_Awesome> what do you mean? i find Maybe mappend very useful
21:48:06 <noige_> so..
21:48:06 <noige_> is : a constructor?
21:48:07 <noige_> does it create a list? or just append?
21:48:19 <Mr_Awesome> noige_: its the list constructor
21:48:37 <Mr_Awesome> just like any constructor that you might define. except this one is infix instead
21:48:44 <noige_> oh jeez
21:48:45 <noige_> ok
21:48:49 <Mr_Awesome> (in fact, you can define your own infix constructors too. look at Complex)
21:48:53 <noige_> I will avoid that for now
21:49:00 <noige_> I want to stick to the basics
21:49:05 <noige_> just for now hahh
21:49:18 <monochrom> Everything is basic.
21:49:27 <Mr_Awesome> noige_: it is the basics. from what i gathered you already understand what im saying
21:49:41 <wli> Mr_Awesome: No idea how.
21:50:34 <Mr_Awesome> wli: how about the discussion we were just having. if i have a list of maybes and i want the first Just, i can simply use msum
21:51:50 <hpaste>  mmorrow annotated "working lighttpd fcgi conf" with "working apache (related parts of) config" at http://hpaste.org/5808#a1
21:52:29 <noige_> ahhh ok
21:52:31 <noige_> I see
21:53:48 <wli> I was under the impression there were laws the monadic addition was supposed to obey.
21:54:03 <noige_> I like ghci
21:54:18 <Mr_Awesome> wli: oh, like commutativity?
21:54:52 <Mr_Awesome> wait, no, not commutativity
21:55:00 <Mr_Awesome> what law does Maybe mappend break?
21:55:51 <wli> Left distribution
21:56:44 <wli> Mr_Awesome: http://haskell.org/haskellwiki/MonadPlus_reform_proposal
21:57:01 <wli> (... which, like everything else, is never going to happen)
21:59:36 <Cale> wli: If it goes too long, we'll just fork base in order to make it happen :)
21:59:57 <sclv> monadplus doesn't give any advantages over proper monoids anyway, though?
22:00:34 <wli> gah s/mappend/mplus/
22:01:05 <Cale> sclv: It's a different concept.
22:01:28 <Mr_Awesome> not all monoids are monads
22:01:47 <Cale> mplus and mappend don't necessarily do the same thing either
22:01:53 <wli> Cale: As bos advised me before I'd finished typing my expectation, "Don't hold your breath."
22:01:55 <Cale> Even when both are defined
22:02:56 <Cale> wli: Why do you think it'll never change?
22:04:18 <wli> It may or may not, but the odds are overwhelmingly that I won't be around to see it.
22:05:13 <Cale> wli: Are you planning on living only another couple years or something?
22:05:27 <Cale> (or retiring from programming in Haskell?)
22:06:33 <noige_> this is interesting
22:06:43 <noige_> I like that lists only contain one type
22:06:51 <noige_> but that is me being new
22:06:55 <wli> The working lifetime of programmers as programmers is not all that long. Take another 10 years and I'll be pushing a broom and probably won't even own a computer anymore.
22:07:32 <Mr_Awesome> noige_: never dealt with a static type system before?
22:07:36 <Cale> noige_: Yeah, it's almost always a good idea :)
22:07:40 <noige_> no
22:07:50 <noige_> I am familiar with python and ruby
22:08:13 <wli> noige_: That would be never having dealt with a static type system before.
22:08:17 <noige_> I can ['bob', 3, 'foo', 12.3123]
22:08:19 <sclv> cale: but they could do the same things!
22:08:35 <Cin> wli: we'll have robots by then to do the brooming for us :P
22:08:42 <Cale> sclv: That's what existential types are for!
22:08:47 <noige_> wli: yeah I meant "No, I have never dealt with a static type system. I am only familiar with Ruby and python"
22:08:58 <Mr_Awesome> noige_: i think youll come to like this way better :)
22:09:06 <sclv> sorry. that was re: monadplus and monoids.
22:09:14 <Cale> sclv: ah
22:09:17 <noige_> ok
22:09:26 <noige_> I feel pretty excited about his
22:09:29 <noige_> *this
22:09:32 <Cale> sclv: Yes, they could.
22:09:33 <noige_> I think because it is new
22:09:36 <sclv> which is what newtypes are for:-)
22:10:04 <sclv> ?instances MonadPlus
22:10:09 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
22:10:13 <Cale> In that every MonadPlus is a monoid in a way which ignores the element values completely.
22:10:38 <Cale> (and agrees nicely with the monad operations)
22:11:53 <noige_> does it annoy you guys to have noobs in here?
22:12:00 <Cin> no
22:12:00 <Cale> Not at all
22:12:13 <Cale> In fact, I highly recommend asking lots of questions :)
22:12:52 <noige_> so no matter what let cons a b = 1:2:3:a:b:[]
22:13:19 <noige_> a and b can never be string, float, or function that returns strings or non Ints?
22:13:26 <Cale> They could be Floats
22:13:40 <Cale> The type of cons would be  (Num a) => a -> a -> [a]
22:13:44 <noige_> ahh because a Float is a num?
22:13:47 <Cale> yeah
22:14:03 <Cale> But the types have to match.
22:14:05 <noige_> hmm I dont understand this: (Num a) => a -> a -> [a]
22:14:15 <Cale> That is, if a is an Integer, then b can't be a Float
22:14:34 <sclv> noige_: think about what you could or couldn't do with a heterogenous list without all the magic auto-conversion that dynamic languages give you.
22:14:45 <Cale> That says that for any numeric type a, the function cons takes two values of type a, and produces a list of values of type a
22:15:10 <sclv> (Num a) means that a has to be a number. the => says "everything on my left is a context declaration. everything on my right is a type."
22:15:18 <Cin> noige_: Num is a typeclass
22:15:27 <noige_> ahh so the context is a Num context
22:15:34 <sclv> for a only.
22:15:40 <noige_> ooooo
22:15:41 <noige_> ok
22:15:42 <sclv> but every a has to be the same instance of Num.
22:15:56 <Cale> noige_: You already know about type variables, right?
22:16:19 <sclv> if it was (Num a, Num b) => a -> b -> b then it would take Nums of two types and return a num of the second type.
22:16:46 <Cale> For instance we could have something like  length :: [a] -> Integer  which says that length takes any type of list, and produces an Integer, and it can't inspect the values of that list, just its structure.
22:17:19 <Cale> But you quickly run into a problem with functions like sort. It should take a list and produce a list, so you might guess that its type is something like sort :: [a] -> [a]
22:17:35 <Cale> But that means that it can't look at the values in the list at all -- it can't compare them with <
22:18:03 <Cale> So we have a typeclass constraint to say that a must be an ordered type, that is, one where < has been defined
22:18:12 <Cale> sort :: (Ord a) => [a] -> [a]
22:18:37 <noige_> ooooooh
22:18:44 <noige_> I think I am seeing this
22:18:56 <noige_> this is different
22:18:59 <noige_> I like this
22:19:17 <adu> noige_: how long have you been learning Haskell?
22:19:28 <noige_> About 4 days hahaha
22:20:06 <monochrom> You can learn Haskell in 21 days.
22:20:40 <adu> monochrom: did you?
22:21:02 <adu> I've been learning Haskell for 5 years, and I still don't understand it all
22:21:08 <faxathisia> Catagory theory is awesome!!
22:21:30 <adu> faxathisia: yes it is
22:21:35 <monochrom> Not counting monad and above, yes I did.
22:21:38 <adu> there should be a Category typeclass
22:21:46 <faxathisia> I have read a chapter about some of the basics in Algebra of Programming
22:21:52 <faxathisia> This is really fantastic :D
22:21:56 <Mr_Awesome> i still dont understand monadic fix points
22:22:18 <sclv> you mean like mdo?
22:22:21 <Mr_Awesome> yeah
22:22:39 <Cale> I understand monadic fix points in practical terms, but not in the details.
22:22:39 * sm does not think learning Haskell is complete without monads
22:22:39 <faxathisia> Mr_Awesome: Me neither
22:22:52 <noige_> ok so this explains what we just talked about
22:22:53 <Mr_Awesome> Cale: yes, same here
22:22:54 <noige_> myCons  1 2.3
22:22:54 <noige_> [1.0,2.0,3.0,1.0,2.3]
22:23:11 <sclv> I was reading the papers again the other day and sort of began to accept that they're more ad-hoc than not, sort of like monad transformers?
22:23:11 <noige_> I get floats because of the second arg being a float
22:23:29 <Mr_Awesome> noige_: what is "myCons" ?
22:23:36 <Cale> noige_: yeah, the second arg is specifically fractional, so the default type is Double
22:23:57 <Cale> noige_: There's a defaulting system for numbers, since numeric literals are polymorphic
22:24:22 <sclv> I ran into a paper on monad transformers that talked about the different properties of them for free and "non-free" monads, and how for the former they were far more formalizable. I wonder if the same isn't true for mdo.
22:24:30 <Cale> noige_: If Integer works, then that's what you get, otherwise, you'll get Double (and if that doesn't work, an error saying that it doesn't know what type you want)
22:24:48 <noige_> oh  man
22:24:55 <noige_> this is going to be mindbending
22:24:56 <Cale> noige_: This defaulting happens after all the other typechecking.
22:25:02 <noige_> this is fun
22:25:08 <noige_> here is myCons
22:25:16 <noige_> let myCons list thing = 1:2:3:[list, thing]
22:25:28 <sclv> ?type 12
22:25:32 <lambdabot> forall t. (Num t) => t
22:26:00 <Cale> Prelude> :t myCons
22:26:00 <Cale> myCons :: forall t. (Num t) => t -> t -> [t]
22:26:02 <sclv> raw numeric values are sort of magic in haskell. you can think of them as zero-arg polymorphic functions...
22:26:20 <Cale> They're polymorphic values.
22:26:30 <sclv> right, or that. :-)
22:26:45 <faxathisia> I have to read each chapter twice though
22:26:45 <faxathisia> \
22:27:05 <Cale> They're secretly implemented as functions though. They take a dictionary for the typeclass Num, and produce a value of the appropriate type.
22:27:34 <noige_> Cale: so (Num t) => t -> t -> [t] means, All t's are Nums and myCons will return a list
22:27:58 <sclv> right -- and all your ts have to be the same.
22:28:02 <noige_> :)
22:28:10 <Cale> yeah, [t] means "the type of lists of values of type t"
22:28:37 <Cale> You might wonder why multiparameter functions have multiple ->'s in their types
22:28:38 <noige_> one small step for mankind, one large step for noige_
22:28:48 <noige_> I do
22:28:50 <noige_> hahah
22:28:54 <Cale> The real reason is that -> associates to the right
22:28:55 <noige_> but I am sure that I will learn
22:28:58 <Cale> So that actually means:
22:29:06 <Cale> (Num t) => t -> (t -> [t])
22:29:22 <Cale> That is, myCons is a function which is going to take a value of type t
22:29:29 <Cale> and produce a function which takes a value of type t
22:29:32 <Cale> and produces a list
22:29:38 <Cale> (of values of type t)
22:29:45 <noige_> yes!
22:29:46 <noige_> ok
22:29:50 <noige_> I understand that
22:29:55 <sclv> so you can partially apply and get a new function: :t myCons 12 -- myCons 12 :: forall t. (Num t) =>  t -> [t]
22:30:27 <noige_> can you tell me what :t is?
22:30:38 <Cale> It's the ghci command to ask for the type of something
22:30:43 <noige_> oh ok
22:30:49 <Cale> Also, it works in the channel.
22:30:52 <Cale> :t map
22:30:52 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:31:05 <noige_> :t noige_
22:31:06 <lambdabot> Not in scope: `noige_'
22:31:08 <noige_> haha
22:31:14 <noige_> :t 12
22:31:14 <lambdabot> forall t. (Num t) => t
22:31:23 <Cale> :t 12.4
22:31:24 <lambdabot> forall t. (Fractional t) => t
22:31:27 <noige_> :t 'test'
22:31:27 <lambdabot> lexical error in string/character literal at character 'e'
22:31:35 <Cale> :t "test"
22:31:35 <lambdabot> [Char]
22:31:37 <noige_> :t "test"
22:31:37 <lambdabot> [Char]
22:31:41 <Cale> :t 't'
22:31:42 <lambdabot> Char
22:32:10 <Cale> :t fix
22:32:12 <lambdabot> forall a. (a -> a) -> a
22:32:46 <Cale> :t (1:)
22:32:47 <lambdabot> forall t. (Num t) => [t] -> [t]
22:32:53 <Cale> :t fix (1:)
22:32:54 <lambdabot> forall t. (Num t) => [t]
22:33:55 <OceanSpray> what does fix do?
22:34:08 <Cale> fix f = f (fix f)
22:34:31 <Cale> Alternately:
22:34:37 <Cale> fix f = let x = f x in x
22:34:57 <Cale> It finds a fixed point (the least-defined fixed point) of a function.
22:35:05 <Cale> > fix (1:)
22:35:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:35:17 <monochrom> fix is anonymous in-place recursion.
22:35:24 <Cale> It can be used to write recursive functions without giving them names
22:35:29 <OceanSpray> huh.
22:35:39 <noige_> anonymous functions?
22:35:40 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
22:35:41 <lambdabot>  3628800
22:35:48 <monochrom> (let xs = 1:xs in xs) equals (fix (\xs -> 1:xs)) equals (fix (1:))
22:35:58 <Japsu> > fix (:1) :: Expr
22:35:58 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
22:35:58 <lambdabot>       Expected...
22:37:03 <Cale> > fix id
22:37:04 <lambdabot>  Exception: <<loop>>
22:37:07 <Cha2> > \x -> fix . (:x)
22:37:08 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `[a1]'
22:37:37 <Japsu> > fix f
22:37:38 <lambdabot>  Add a type signature
22:37:53 <Cale> > fix f :: Expr
22:37:54 <noige_> fix f :: Int
22:37:55 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
22:38:10 <noige_> fix f :: Expr
22:38:16 <noige_> > fix f :: Expr
22:38:17 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
22:38:27 <noige_> weird
22:38:32 <Cale> noige_: That's the funky SimpleReflect module in lambdabot :)
22:38:35 <noige_> > fix f :: Int
22:38:36 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
22:38:38 <Cale> (the Expr thing)
22:38:39 <Cha2> @src fix
22:38:40 <lambdabot> fix f = let x = f x in x
22:39:05 <Cale> f is defined as a function on Expr's
22:39:30 <monochrom> I should write a "you could have re-invented fix too!"
22:39:41 <Cale> (a-z are defined in that library, all except f,g,h are Exprs and those three are functions)
22:40:34 <Cale> gwern: Your email signature is strange.
22:41:32 <Cin> "I put on my gwern and wizard hat"
22:42:00 <Cale> --
22:42:00 <Cale> gwern
22:42:00 <Cale> Glock SEAL stakeout a II eavesdropping Bletchley UNSCOM spies Agfa
22:44:29 <glguy> ?seen igloo
22:44:30 <lambdabot> igloo is in #haskell, #ghc and #darcs. I last heard igloo speak 13h 13m 16s ago.
22:51:12 <Cin> awesome
22:51:16 <Cin> body << roundlet << "Hm?"
22:51:18 <Cin> http://rtfs.ath.cx/poller/Poller.fcgi
22:51:19 <Cin> :D
22:51:31 <Cin> (also http://rtfs.ath.cx/poller/Poller.hs =o)
22:59:02 <bamdastard> if you guys had to implement a genetic programming algorithm in scala or f# what would it be?
22:59:39 <bamdastard>  jk /quit
23:00:57 <olsner> drive-by troll?
23:01:04 <andydude> lol
23:01:19 <faxathisia> gotta be careful round these parts..
23:03:33 <andydude> whats the whole "Grassroots" thing in the topic about?
23:04:28 <olsner> beats me...
23:04:45 <wli> andydude: Are you the same andydude involved with tetration?
23:04:54 <andydude> wli: yes, thats me
23:05:02 <dolio> faxathisia: I'm working on proving ++reverse using the fold version of reverse.
23:05:06 <wli> andydude: Spiffy stuff.
23:05:24 <faxathisia> dolio, cool, I'd like to see how it turns out
23:05:36 <adu> 'andydude' is my backup irc moniker
23:05:45 <adu> wli: my website is tetration.itgo.com
23:05:46 <faxathisia> dolio, Found out Agda 2 actually hase a -> Haskell compiler already btw! (Exprimental)
23:05:53 <dolio> I've got the base case already, but the inductive case is proving more difficult.
23:06:05 <dolio> Ah, cool.
23:06:43 <adu> wli: one of the things I'd like to see happen in haskell is have (^^) and (***) reserved for tetration, but sadly their both allocated to other operations :(
23:09:13 <wli> adu: I'm all ears for numerical methods for tetration with floating point exponents [sic].
23:09:58 <dons> so, anyone working on anything interesting?
23:10:10 <dons> more commits peoples!
23:10:19 <adu> wli: well, the best/fastest method so far is Jay's acceleration of my solution, which is a generalization of Peter Walker's solution to real-valued tetration
23:10:51 <bos> ok, new chapters up at http://book.realworldhaskell.org/beta/
23:10:51 <lambdabot> Title: Real World Haskell
23:11:04 <dons> ah ha!
23:11:05 <wli> adu: URL?
23:11:23 <dons> that "why don't you use haskell" thread was just getting depressing
23:11:52 <adu> http://math.eretrandre.org/tetrationforum/showthread.php?tid=63
23:11:52 <lambdabot> Title: Improving convergence of Andrew's slog
23:11:53 <adu> http://math.eretrandre.org/tetrationforum/showthread.php?tid=79
23:11:53 <lambdabot> Title: Observations on power series involving logarithmic singularities
23:12:45 <adu> wli: those 2 threads are sufficient I think
23:13:24 <glguy> What LANGUAGE extension is deriving Typeable?
23:13:50 <dons> DerivingTypeable
23:14:39 <glguy> hmm, that doesn't seem to work for me
23:14:52 <dons> hmm. oh, which cabal version?
23:14:55 <glguy> DeriveDataTypeable?
23:15:02 <dons> ah maybe
23:15:03 <glguy> 1.2.3
23:15:03 <adu> wli: of course, for a simple implementation, a piecewise function implemented with a linear region from [-1..0] is still the fastest
23:15:27 <dons> glguy: i think it was only added to recent cabals
23:15:35 * wli points to csc(z) as an instance of meromorphy with a countably infinite number of poles.
23:15:38 <glguy> otherwise I need -fglasgow-exts?
23:15:46 <dons> DeriveDataTypeable
23:15:50 <dons> glguy: yeah
23:16:12 <glguy> Ah ha, import Data.Typeable
23:16:15 <glguy> :r
23:16:22 <dons> bos, going to drop it on reddit/blog?
23:17:34 <wli> adu: Looks like it's mostly about slog; I presume here that tetration is then the inverse?
23:18:13 <adu> wli: yes, slog_x(z) == y implies x^^y == z
23:18:32 <bos> dons: http://www.realworldhaskell.org/blog/2008/02/22/some-new-beta-chapters-for-review/
23:18:34 <lambdabot> Title: Real World Haskell ª Blog Archive ª Some new beta chapters for review, http://tinyurl.com/2pplpp
23:18:53 <dons> wonderful.
23:19:14 <dons> glguy: oh, btw, did you see this thing about the north west linux fest in a month or so?
23:19:33 <dons> the haskell guys should represent..
23:20:29 <dons> http://linuxfestnorthwest.org/
23:20:30 <lambdabot> Title: LinuxFest Northwest 2008
23:21:26 <wli> adu: No, I mean to ask whether the numerical method for tetration is inversion of the slog.
23:22:36 * bos considers moving realworldhaskell.org to a VPS or something. current shared server is overloaded.
23:23:23 * bos isn't wild about the idea of spending $50-100 extra on the intertubes every month.
23:23:55 <adu> wli: there are 2 ways to do it theoretically, (1) treat 'slog' as a black-box and use Newton's method to get tetration, or (2) use the series expansion for 'slog' and find its inverse using Lagrange inversion to get the series expansion for tetration
23:24:15 <jeffz> bos, vps should be less than $20
23:24:20 <dons> bos, hmm. could we get it on an oreilly server?
23:24:40 <adu> wli: in practice, (1) seems to give more accurate results
23:24:57 <dons> bos, esp. since things are likely to get more funky in the coming months
23:25:03 <bos> dons: possibly, but then we'd have ugly fiddling with trying to get configuration happy.
23:25:05 <bos> jeffz: really?
23:25:14 <dons> hmm.
23:25:16 <wli> adu: Fair enough.
23:25:20 <bos> jeffz: i'd been looking at johncompanies.com, which seemed very expensive.
23:25:45 <jeffz> bos, I use vpsland.com on a deal of something like $16.99/mo
23:25:50 <bos> but now i see that other VPS providers are much cheaper and give more bandwidth.
23:26:03 <bos> jeffz: how's the reliability etc of vpsland.com?
23:26:27 <jeffz> bos, since August they've rebooted maybe twice but I haven't had any outages
23:26:50 <noige_> I am feeling pretty optimistic about haskell so far
23:26:55 <bos> jeffz: fascinating, thanks.
23:27:03 <noige_> I am going to go home and work through some more tutorials
23:27:10 <adu> wli: the nice thing about my/Jay's/Peter Walker's methods (what the Tetration Forum has started to call "natural tetration") is that it produces very very smooth tetration, but there are still other definitions out there
23:27:12 <dons> noige_: yay :) what are you working on?
23:27:35 <noige_> I have haskell school of expression here. Do you think I should focus more on web tutorials or is this a decent intro?
23:27:54 <dons> that's a classic book.
23:27:56 <noige_> dons: oh just the basic stuff. I like the static typing thing
23:28:39 <jeffz> bos, not sure if they have the same deal, but $15.99 buys me 192mb ram, 255mb swap and 6GB disk, 150GB bandwidth /mo
23:29:25 <noige_> dons: oh ok cool thanks
23:29:32 <bos> jeffz: yeah, i see that in the list.
23:30:09 <noige_> spry is decent for vps if you are looking for vps
23:30:18 * noige_ works as a sys admin at Servepath
23:30:33 <noige_> our dedicated vps are expensive though
23:31:47 <noige_> I like spry
23:31:51 <dons> bos, seen the new language graphs on ohloh? haskell v erlang, :)  http://www.ohloh.net/languages/compare?commit=Update&l0=haskell&l0_0=-1&l1=erlang&measure=contributors
23:32:18 <dons> versus lisp http://www.ohloh.net/languages/compare?commit=Update&l0=lisp&l1=haskell&l2=-1&measure=contributors
23:32:19 <lambdabot> Title: Open Source Programming Language Popularity Monthly Contributors History Chart - ..., http://tinyurl.com/2u9yuj
23:33:01 <bos> dons: nice
23:33:18 <dons> this is an interesting one: the number of commits spikes in 2005 -- due to darcs, i think.
23:33:21 <dons>  http://www.ohloh.net/languages/compare?commit=Update&l0=haskell&l1=-1&l2=-1&measure=commits&percent=
23:34:10 <dons> that's the transition from research projects only, to masses of open source rpeos
23:34:45 <hpaste>  adu pasted "Floating tetration" at http://hpaste.org/5810
23:36:03 <adu> wli: that implementation will give about 1, maybe 2 digits of accuracy
23:41:03 <bos> might as well throw the field open for suggestions: http://www.realworldhaskell.org/blog/2008/02/22/looking-for-vps-recommendations/
23:53:23 <dolio> faxathisia: Hmm, I seem to have hit a roadblock.
23:54:09 <faxathisia> what sort? is this on darcs?
23:54:19 <dolio> It can't tell that foldr _::_ z l /= foldr _::_ w l for z /= w for some reason.
23:54:32 <dolio> No, not on darcs.
23:54:50 <dons> gwern: here's a challenge, Bualt's stuff
23:55:00 <dons> Bulat's. ArrayRef, his io library, ..
23:55:20 <dons> gwern: and anything from hudak.
23:56:18 <adu> > cos (pi/2)
23:56:30 <lambdabot>  6.123031769111886e-17
23:56:57 <adu> that's way off
23:57:54 <dolio> Only by 6.123031769111886e-17.
23:58:02 <adu> lol
23:58:45 <asmanian> > pi
23:58:47 <lambdabot>  3.141592653589793
23:58:53 <asmanian> thats already way off
23:58:57 <adu> > acos (-1)
23:58:58 <lambdabot>  3.141592653589793
23:59:05 <dolio> > pi :: Double
23:59:06 <lambdabot>  3.141592653589793
23:59:12 <dolio> > pi :: Float
23:59:13 <lambdabot>  3.1415927
23:59:24 <adu> ?index BigFloat
23:59:24 <lambdabot> bzzt
23:59:40 <cygnus_> ?index prelude
23:59:40 <lambdabot> bzzt
