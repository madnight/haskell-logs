00:01:22 <adu> how do I get the output into the next function?
00:01:23 <adu> grrrr
00:01:44 <dmwit> Use a monad?
00:01:47 <Deewiant> without knowing any details, >>= instead of >>?
00:02:08 <adu> Deewiant: ooooooo, thank you! i forgot about that
00:02:25 <Deewiant> no problem :-)
00:02:55 <dolio> Having to put "end" to close blocks really hurts the line count on Ruby programs.
00:04:38 <adu> cool, that fixed the loading problem
00:05:08 <hpaste>  adu pasted "matrix code" at http://hpaste.org/5596
00:05:19 <adu> but theres still the matrix problem ^
00:05:34 <adu> I suck at using numbers in Haskell
00:05:50 <adu> how do I convert from GLsizei to something, then something to GLfloat?
00:06:12 <adu> where 'something' has the ability to be part of division '/'
00:07:02 <Deewiant> @hoogle from
00:07:02 <lambdabot> Numeric.fromRat :: RealFloat a => Rational -> a
00:07:03 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
00:07:03 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
00:07:23 <Deewiant> one or more of those or the similar ones, probably
00:17:44 <adu> yes! the matrix works!
00:18:50 <adu> http://hpaste.org/5596#a1
00:19:43 <dolio> @type toInteger
00:19:46 <lambdabot> forall a. (Integral a) => a -> Integer
00:20:05 <dolio> fromInteger . toInteger is named fromIntegral.
00:20:25 <adu> ?type fromIntegral
00:20:25 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:20:43 <adu> o thanks
00:23:36 <adu> nice, well, I think i've done enough for today
00:24:07 <adu> I am very satisfied the HOpenGL now :)
00:24:17 <adu> s/the/with/
00:50:18 <gour> @seen ndm
00:50:18 <lambdabot> I haven't seen ndm.
01:17:52 <ClimDan> Cool Dating Club site ===> new-datingclub eu
01:19:08 <opqdonut> ...
01:25:24 <Cin> Haskellers are suave; they don't need to date
01:26:22 --- mode: ChanServ set +o vincenz
01:26:30 <Taejo> Cin: I'm curious about the context of that remark
01:26:45 <pjd> <ClimDan> Cool Dating Club site ===> new-datingclub eu
01:26:51 <pjd> (spam)
01:27:09 <Taejo> ah
01:32:22 <ketil> morning!  Not really Haskell, but: is there a way to check regexps for overlap?  I.e., given two regexps, is there a string for which they both match?
01:32:46 <opqdonut> hmm
01:32:47 <opqdonut> yes
01:32:50 <dmwit> Yes there is!
01:32:50 <bringert> ketil: some regexp implementations have that
01:33:02 <opqdonut> one can do it from the minimized dfas
01:33:06 <bringert> oh, sorry, misread the question
01:33:17 <opqdonut> or alternatively by differentiating the regex (i guess?)
01:33:18 <ketil> Okay, good.  Now for improved relevance, haskell implementations, anyone?
01:33:23 <bringert> I thought it was about regexp intersection
01:33:40 <ketil> bringert, is that different?
01:33:47 <dmwit> ketil: It's nasty; you have to try an exponentially large number of possible strings.
01:34:03 <ketil> dmwit, exhaustive search? :-)
01:34:08 <opqdonut> ketil: do you want to find the string or only know whether one exists?
01:34:13 <ketil> I guess I'll just check as I go.
01:34:20 <ketil> I just need to know if it exists.
01:34:22 <opqdonut> (exhaustive search up to pumping length)
01:34:23 <dmwit> ketil: Basically, but you get to be slightly smart on the upper-limit of string matching length.
01:34:49 <ketil> I want to classify some strings according to a table of patterns, and would like to know in advance that the classes are mutually exclusive.
01:34:51 <dmwit> Right, it's based on the pumping lemma, as opqdonut says.
01:35:16 * ketil looks up pumping lemma.
01:35:19 <opqdonut> but isn't it possible to decide whether (RnS)=Ø or not
01:35:22 <opqdonut> ?
01:35:41 <opqdonut> simply by doing a reachability test for a goal state in the dfs
01:35:59 <vininim> So I was wondering how monads work in the phenom cpus... =)
01:36:03 <dmwit> Yes, existence might me easier.
01:36:17 <opqdonut> yes, very easy it the algorithm i outlined there works
01:36:54 <opqdonut> ketil: about implementations, i have some regex/[dn]fa stuff, but nothing very complete
01:37:09 <opqdonut> and i doubt any of the "real" regex libraries will let you access the statemachine repr
01:37:39 <ketil> Right.
01:38:29 <ketil> The easiest way is to just go ahead classifying, and report it if and when two strings are matched by two regexps.
01:38:47 <opqdonut> yeah i guess
01:39:10 <ketil> Not entirely satisfying, but at least it's cheap :-)
01:39:34 <opqdonut> at least now you know there is an elegant solution :P
01:49:04 <jacobian_wrk> anyone here used supero yet?
01:49:31 <Syzygy-> > head badlist where badlist = [1,let loop = loop+1 in loop, 3, 4, 5]
01:49:32 <lambdabot>  Parse error at "where" (column 14)
01:49:43 <Syzygy-> > let badlist = [1,let loop = loop+1 in loop, 3, 4, 5] in head badlist
01:49:50 <lambdabot>  1
01:50:01 <Syzygy-> > let badlist = [1,let loop = loop+1 in loop, 3, 4, 5] in drop 2 badlist
01:50:03 <lambdabot>  [3,4,5]
01:50:06 <Syzygy-> Hah!
01:51:40 <pjd> s/let loop = loop+1 in loop/undefined/, if you want
01:52:27 <vincenz> pjd: if you do not care about the error
01:52:37 <vincenz> let loop = loop+1 will generate a <<loop>> error
01:52:40 <vincenz> (blackholing)
01:52:43 --- mode: vincenz set -o vininim
01:52:46 --- mode: vincenz set -o vincenz
01:53:20 <Syzygy-> Actually, since I'm actively avoiding the bottom element, I don't care whether I use undefined or an infinite loop.
01:54:19 <vincenz> :)
01:55:39 <Cin> +L (large ban/exempt/invex lists)   This mode, which can only be set my freenode staff, allows a channel to have longer than normal ban, exempt, and invex lists.
01:55:46 <Cin> might be useful for here :)
01:57:44 <czakey> 6 hours to my Haskell exam :>
01:57:56 <czakey> I'd better write some monads :]]]
01:57:58 <Taejo> how would I add a compiler flag (-DFOO=bar) to a cabal package at configure-time?
01:58:05 <Zao> czakey: Have you've been sufficiently lazy?
01:58:12 <czakey> yes :D
01:58:46 <czakey> I'm like haskell - very lazy, and functional
01:58:48 <czakey> ;p
02:16:43 <sili> 11
02:32:51 <ivan_> where do i find API for HGL lib ?
02:40:15 <Cale> ivan_: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HGL-3.2.0.0 -- click on the module names
02:40:16 <lambdabot> http://tinyurl.com/382n8n
02:40:42 <Cale> http://hackage.haskell.org/packages/archive/HGL/3.2.0.0/doc/html/index.html -- or here
02:40:44 <lambdabot> http://tinyurl.com/22dtcy
02:53:13 <ivan_> is there a function in haskell to sleep or nap
02:53:56 <pjd> define "sleep or nap"
02:54:06 <oerjan> ivan_: threadDelay
02:54:22 <resiak> @nap
02:54:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
02:54:35 <oerjan> @hoogle threadDelay
02:54:36 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
02:54:36 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
02:54:49 <resiak> aww.  does poor \b never sleep?
02:55:01 <oerjan> she did yesterday
02:55:06 <resiak> that's true!
02:55:36 <oerjan> @version
02:55:36 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
02:55:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
02:55:42 <oerjan> @users
02:55:43 <lambdabot> Maximum users seen in #haskell: 428, currently: 419 (97.9%), active: 10 (2.4%)
02:55:56 <oerjan> and the usual bout of amnesia...
02:56:40 <oerjan> we were at 479 at one point
02:57:34 <ricky_clarkson> Why does it forget?
02:57:53 <ricky_clarkson> @drugabusers
02:57:53 <lambdabot> Unknown command, try @list
02:58:47 <oerjan> well, i think lambdabot was sleeping when we reached that anyhow, may have been "psibot" at the time
02:59:07 <oerjan> ricky_clarkson: max edit distance 2
02:59:58 <ricky_clarkson> ah
03:00:05 <oerjan> and clearly she doesn't save properly when she crashes...
03:00:39 <ricky_clarkson> Why does it crash?
03:00:59 <oerjan> that, and she was upgraded to 6.8, might have been a rocky transition
03:02:23 <oerjan> @quote metastereo
03:02:24 <lambdabot> omniscientIdiot says: geez, how many metastereo quotes are going to be @remembered?  >_>
03:05:40 <oerjan> > pure succ <*> intercalate " " ["a","b","c"]
03:05:47 <lambdabot>  "b!c!d"
03:21:47 <swiert> @seen JaffaCake
03:21:47 <lambdabot> JaffaCake is in #haskell and #ghc. I don't know when JaffaCake last spoke.
03:22:05 <JaffaCake> swiert: can I help?
03:22:23 <swiert> JaffaCake: Hi - I was just wondering if you'd had a chance to look at Bernie's TMR article
03:22:40 <JaffaCake> aargh, yes I need to do that
03:22:49 <JaffaCake> I'll do it today
03:22:50 <swiert> I'm about to compile the final edition - so it's a kind of "speak now, or forever hold your peace" thing :)
03:23:02 <swiert> JaffaCake: Great! Thanks.
03:23:16 <JaffaCake> no problem, thanks for the reminder!
03:23:55 <swiert> JaffaCake: If you want, there's a darcs repos here: http://sneezy.cs.nott.ac.uk/darcs/TMR/Issue10/
03:23:56 <lambdabot> Title: Index of /darcs/TMR/Issue10
03:24:03 <sioraiocht> dcoutts: ping?
03:24:27 <JaffaCake> swiert: should I use that or the version that Bernie sent me?
03:24:55 <swiert> JaffaCake: for now they're the same, but feel free to darcs send patches if you spot anything.
03:25:03 <swiert> Or just e-mail Bernie and em.
03:25:07 <swiert> *me.
03:26:08 <JaffaCake> right, thanks
03:33:51 <vininim> Any functional programming text in the internet in which haskell is just secondary to the text?
04:02:50 <LeCamarade> What is GHC's version of popen(3), and where do I find it?
04:05:37 <Deewiant> there's System.Process
04:05:39 <daf> runInteractiveProcess?
04:09:46 <LeCamarade> @hoogle runInteractiveProcess
04:09:47 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
04:10:35 <LeCamarade> Ah, bon. Was it there in GHC 6.4? I looked.
04:10:45 * LeCamarade was stuck on 6.4 out of rebellion, until recently.
04:11:33 <LeCamarade> Now, raise your hand if you've read GHC error messages via less(1). _o/
04:18:31 <dcoutts> sioraiocht: pong
04:20:46 <Taejo> @pl  (\ k a -> (a, [k]))
04:20:46 <lambdabot> flip (,) . return
04:22:04 <JohnMeacham> compiling hello world down to 10 seconds. yay.
04:22:31 <JohnMeacham> and 6388 bytes in the generated executable.
04:24:13 <daf> that's pretty small
04:24:51 <dcoutts> JohnMeacham: have you been able to build the filepath package btw? I hit parser problems which seemed to be related to cpp #line pragmas.
04:25:49 <dcoutts> JohnMeacham: I'd love to be able to build Cabal with jhc, I don't know if you think that's realistic yet or not.
04:26:13 <dcoutts> or whether I should only test Cabal built with ghc, to build simple packages using jhc
04:27:36 <JohnMeacham> dcoutts: that would make more sense to me. I would prefer people use 'cabal-install' (or make or whatever) anyway to including the library.
04:27:54 <JohnMeacham> or just use ghc's 'runhaskell' if it suits them.
04:28:49 <JohnMeacham> I am not sure if jhc handles #line pragmas actaully.
04:29:29 <JohnMeacham> for very simple cabal projects you can just do 'jhc --build-hl foo.cabal' on the cabal file.
04:29:46 <dcoutts> JohnMeacham: it seems to because when it reports an error after the line pragma, it does refer to the original source location given by the #line pragma, not to the pre-processed file's name
04:30:46 <dcoutts> JohnMeacham: if you figure it doesn't handle them then perhaps pass -P when jhc calls cpp.
04:30:52 <JohnMeacham> yeah. I think it might just discard them for now. I want to switch to another lexer at some point so have not put too much work inot the curretn one.
04:31:22 <dcoutts> -P will suppress #line pragmas
04:31:37 <vincenz> is jhc the continuation of nhc?
04:31:48 <JohnMeacham> no. it is independent.
04:31:52 <dcoutts> vincenz: completely different, you're thinking of yhc.
04:31:57 <JohnMeacham> yhc is a continuation of nhc though.
04:32:04 <vincenz> Ah
04:32:07 * vincenz nods
04:32:27 <vincenz> I was confused as nhc used to have similar goals to jhc's current goals
04:32:48 <daf> does the J stand for âJohnâ? :)
04:32:52 <JohnMeacham> will it help if I make jhc natively handle LANGUAGE pragmas so cabal need not worry about it? I can also make it accept the -X command line flag too.
04:33:29 <JohnMeacham> jhc has a different set of extensions than ghc so, so the changing the cabal datatype to 'newtype String' would probably be a good fix anyway.
04:33:38 <JohnMeacham> daf: not officially. but yeah.
04:33:57 <vincenz> JohnMeacham: will you add class aliases?
04:33:59 <dcoutts> JohnMeacham: Cabal currently does not look at LANGUAGE pragmas or indeed anything inside .hs files, though we're planning to make it do so, so you're welcome to leave that out if you like.
04:34:21 <dcoutts> JohnMeacham: and we're perfectly happy to accept your extensions, just send a patch.
04:34:26 <JohnMeacham> dcoutts: well, cabal won't need to worry about it then.
04:34:52 <dcoutts> JohnMeacham: it's useful to know the extensions used so cabal can check if the compiler supports them
04:35:11 <JohnMeacham> dcoutts, well, I'd rather cabal just pass them on through without trying to reinterpret them. there is no reason for cabal to need to know about sundry in house extensions. it should just know to pass them to the '-X' flag of the compiler.
04:36:00 <dcoutts> JohnMeacham: we need to know that if a package uses extension FooBar then we can tell that it will not build with hugs since hugs does not support that extension.
04:36:14 <JohnMeacham> Though, I will put them in the documentation somewhere..
04:36:43 <dcoutts> JohnMeacham: we check at configure time that all extensions used by the package are supported by the compiler
04:37:08 <JohnMeacham> yeah, but that doesn't need to be built into cabal. I'll just have a 'jhc --list-extensions' flag that provides a list of extensions supported by a given compiler.
04:37:55 <dcoutts> JohnMeacham: ghc has a flag for that too, though all of them are registered extensions
04:38:19 <JohnMeacham> since different builds of jhc may have different sets of extensions. and one might have multiple versions installed. actually. maybe I'll start including a prototype compiler description file with jhc and install it somewhere. /usr/lib/cabal/compilers/jhc-0.3.yaml ? something like that... hmm...
04:39:00 <dcoutts> JohnMeacham: I'd prefer to know them earlier since it means we can check before even getting to the configure stage, like when cabal-install is deciding what is possible to install.
04:39:22 <JohnMeacham> yeah. which is why the file would probably be better.
04:40:27 <dcoutts> JohnMeacham: so basically we need enough info to map between the info in the .cabal file, the info we discover at configure time and the command line to construct for the compiler.
04:40:31 <JohnMeacham> i have been using yaml format for meta-info like this, which is close enough to the cabal file format that the current parser can justs read them.
04:40:41 <dcoutts> JohnMeacham: which as it turns out, is quite a bit of info.
04:40:48 <Taejo> I'm looking for a clean pseudocode or recursion relation for the Viterbi algorithm -- Wikipedia's python version is horrid
04:41:19 <Taejo> also, it's doing the forward algorithm at the same time, which isn't pretty
04:41:29 <JohnMeacham> yeah. but I'd prefer to get part of the way there now. even if cabal needs some built in jhc stuff, making the extension list external is a pretty easy start.
04:44:41 <JohnMeacham> another interesting thing I do with the m4 preprocessor is #define symbols for every package/module that is installed. for easy feature checks when trying to write portable code.
04:45:56 <dcoutts> JohnMeacham: aye, we've considered doing that for cabal+cpp but the macro to test version numbers in cpp is pretty horrible. I'm sure that'd work better in m4.
04:46:44 <dcoutts> JohnMeacham: the problem of course is you cannot get people to use m4 just for jhc, it'd have to be something we support between impls and get supported in cabal so people can use it in portable packages with multiple compilers.
04:47:33 <dcoutts> JohnMeacham: we've been thinking of standardising on cpphs for pre-processing Haskell code (rather than using ghc's cpp)
04:48:12 <dcoutts> JohnMeacham: do you use something like {-# LANGUAGE M4 #-} to indicate it?
04:50:12 <JohnMeacham> oh. I wasn't thinking everyone needed to use it, I have just found its looping constructs and ability to work with multi line stuff great for generating instances.
04:50:21 <JohnMeacham> I use {-# OPTIONS_JHC
04:50:26 <JohnMeacham> -fm4 #
04:50:34 <JohnMeacham> -}
04:50:40 <JohnMeacham> doh. sorry for the newlines.
04:50:46 <JohnMeacham> this keyboard ais funny shaped.
04:51:14 <JohnMeacham> so. I don't think it is something cabal needs to worry about.
04:52:14 <dcoutts> JohnMeacham: ok, though if you think it'd be reasonable to use it more widely then that's the obvious place to add support for more pre-processors.
04:52:15 <JohnMeacham> but if you are looking for something ubiquitous that is nicer than cpp, then it is a good choice. though, let me know if you do start using it for cabal, we should standardize on a prelude.
04:54:20 <dcoutts> JohnMeacham: the main issue with 'standard' pre-processors is whether they're widely available (esp Windows)
04:54:31 <JohnMeacham> passing '-P' and doing a changequote({{,}}) is necessary at least.
04:54:49 <JohnMeacham> well, you can't get much better than m4 for that. it predates even cpp I believe.
04:56:33 <JohnMeacham> ah yes. stable since 1977.
04:56:57 <dcoutts> JohnMeacham: though we don't have cpp or m4 on windows, either one has to be bundled with ghc/jhc/whatever
04:57:52 <JohnMeacham> all the world will be unix soon enough. I can ssh to my cell phone, critical mass can't be far off. :)
04:58:00 <dcoutts> heh heh :-)
04:58:30 <dcoutts> according to the ghc survey, half the users are on Windows, which is surprising given how badly we support the platform
05:01:16 <JohnMeacham> http://heirloom.sourceforge.net/ - interesting place my websearching brought me...
05:01:16 <lambdabot> Title: The Heirloom Project
05:02:28 <Twey> Heh, nice.
05:07:04 <taruti> Is there a way for the executables in a cabal file to depend on the library built from the same file?
05:07:45 <guenni> uhm, guys, believe it or not, but for some people like me with an imperative background it is very hard to realize that function are more than mere algorythms, that they can be used to represent other things as well, data structures for instances. That is something that does *not* come natural to an imperative programmer and books usually do not really emphasize that.
05:09:31 <dcoutts> taruti: not yet, no. It just has to import the same source files, and they'll get compiled twice.
05:09:58 <taruti> so for 5 executables that is 5x build time? :(
05:12:20 <Feuerbach> guenni: I think it's more about mathematical background
05:13:54 <guenni> Feuerbach: I suppose so
05:14:48 <guenni> Feuerbach: would you also happen to have a good resource at hand that would "ease" me in on this?
05:16:13 <shapr> taruti: hiya!
05:16:54 <hpaste>  edbond pasted "(no title)" at http://hpaste.org/5598
05:17:39 <taruti> shapr: hi
05:18:00 <hpaste>  edbond annotated "(no title)" with "(no title)" at http://hpaste.org/5598#a1
05:18:16 <edbond> Hi all
05:18:39 <edbond> can someone help me with big3 function from hpaste?
05:18:49 <Jiten> guenni: I've been going through http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
05:18:50 <edbond> I'm new to haskell
05:20:16 <Jiten> I've got quite a bit of mathematical background, though, so I'm not sure if it's what you're looking for though. It's the best "tutorial" I've seen though.
05:20:28 <Lemmih> edbond: snd (minAndMax c d)
05:20:39 <Feuerbach> edbond: remove parens in function calls
05:20:57 <Feuerbach> edbond: snd (minAndMax c d)
05:20:58 <Feuerbach> etc.
05:21:45 <edbond> Feuerbach: thanks a lot!
05:21:51 <edbond> Lemmih: thanks
05:22:22 <Jiten> edbond: I'd use pattern matching instead of snd though. I guess that's just a personal preference though.
05:22:24 <guenni> Jiten: thanks, with help of a friend (a Canadian I know through Skype) I am building up some mathematical background
05:23:31 <Jiten> edbond, like this: where (_,d) = minAndMax a b
05:28:59 <JohnMeacham> taruti: I recommend using make to drive cabal for stuff like that. they work well together.
05:30:42 <Jiten> guenni: Yes, math is quite closely related with Haskell. Learning Haskell gives me the same feeling as studying university math courses.
05:31:41 <Jiten> especially now that I'm in the process of figuring out monads
05:35:04 <vininim> > let coins value types =  if (value > 0) then 1 + if types /= [] then (coins (value - head types) types) else 1 + (coins value (tail types)) else 0 in coins 100 [1,5,10,25,50]
05:35:14 <lambdabot>  100
05:35:27 <vininim> u_u
05:35:32 <daf> vininim: heh, nice
05:35:52 <vininim> the result is wrong though
05:39:02 <EvilTerran> mmm, nested ifs
05:39:53 <oerjan> there should be a test that value >= head types somewhere
05:40:01 <taruti> JohnMeacham: thanks, that seems to work quite well.
05:43:46 <b_jonas> Hello
05:44:05 <b_jonas> I really don't want to give this up, so I'll ask again:
05:44:44 <b_jonas> I've installed ghc 6.8.2 from source.  It works.  How do I install the documentation of the core and extra modules that came with it?
05:45:18 <JohnMeacham> interesting. the jhc compiled version of the standard 'cal' utility (implemented in haskell) is smaller than the C version !
05:46:17 <ski> (does it come with full functionality ?)
05:46:20 <JohnMeacham> and the ghc one is 25 times larger than both :)
05:46:33 <JohnMeacham> mostly. it is the version from nobench.
05:46:34 <vininim> let {coins value [] = 0; coins value types = if (value - (head types) > 0) then  (coins (value - (head types)) types) + (coins value (tail types)) else if (value - (head types) == 0) then 1 else 0} in coins 100 [1,5,10,25,50]
05:46:38 <vininim> > let {coins value [] = 0; coins value types = if (value - (head types) > 0) then  (coins (value - (head types)) types) + (coins value (tail types)) else if (value - (head types) == 0) then 1 else 0} in coins 100 [1,5,10,25,50]
05:46:40 <lambdabot>  292
05:46:42 <pastorn> @src mod
05:46:42 <lambdabot> Source not found. There are some things that I just don't know.
05:46:43 <vininim> \o/
05:46:54 <pastorn> @src divMod
05:46:55 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:46:57 <pastorn> yay
05:47:17 <JohnMeacham> hmm.. I should try out some of those pure haskell SHA1 implementations. I think I might be able to get c equivalant speed with not much tweaking.
05:47:34 <vininim> too much ifelses though, I could prettify that
05:47:53 <b_jonas> JohnMeacham: somehow I think that number crunching like that is specifically where you can't get good speed with pure haskell
05:48:18 <pejo> b_jonas, why would that be impossible?
05:48:20 <JohnMeacham> b_jonas: not at all, jhc is a constructive proof otherwise. :)
05:48:24 <b_jonas> by number crunching I mean code that does few subroutine calls or memory allocation or pointer thingies
05:48:49 <b_jonas> pejo: not impossible, just more difficult than with other areas
05:49:03 <b_jonas> C compilers have a good head start in optimization
05:49:22 <JohnMeacham> b_jonas, yes, jhc is designed to be as fast as c or faster. in fact, the assembly it generates is equivalant for tight numerical loops.
05:49:23 <b_jonas> and C is a good enough language for things like this
05:49:31 <b_jonas> it's like, you know, fortran
05:49:42 <jonaskoelker> question: in a case, I have several keys for which I want to have the same value;  can I say something like "case x of a or b or c -> value1 \n d or e or f -> value2"?
05:49:54 <b_jonas> JohnMeacham: I dunno
05:49:57 <b_jonas> maybe it's possible
05:50:00 <JohnMeacham> actually, due to pointer aliaising not being a problem, haskell can actually be faster.
05:50:22 <oerjan> jonaskoelker: no alas
05:50:32 <jonaskoelker> oerjan: where do I submit a proposal? ;-)
05:50:48 <JohnMeacham> but I certainly think something like a sha1 hash would be quite ammenable to optimization by jhc to c-equivalant speed.
05:50:55 <b_jonas> I should compile the new gcc release some of these days so I can optimize code for intel core cpus :)
05:50:56 <oerjan> jonaskoelker: but you might be able to do something with `elem` [a,b,c] if those are values
05:51:09 <jonaskoelker> yeah, I just figured
05:51:10 <pejo> b_jonas, and as you mention yourself - fortran compilers have a good head start on the c compilers, and a more constrained language. Still, alias analysis is simpler for us.
05:51:29 <b_jonas> pejo: yeah, that's a good argument
05:52:07 <vininim> by the way, is there any project in creating a compiler infractructure with haskell, like llvm is?
05:52:25 <pejo> JohnMeacham, do you get deforestation "for free" in jhc?
05:53:37 <b_jonas> On a channel of nerds like, someone's bound to have installed ghc 6.8 from source with an older haskell compiler.
05:54:30 <pejo> vininim, there's the c-- project, written in ocaml.
05:54:56 <JohnMeacham> pejo: via the RULES mechanism? yes, it can do that the same way ghc does.
05:55:35 <pejo> JohnMeacham, but in order to get the kind of code you generate, surely you must transform it in some clever way?
05:55:45 <JohnMeacham> jhc also has 'CATALYSTS', which are sort of like rules that only fire if they enable some other rule. it gets around the problem of locally inefficent changnes that eventually lead to something benefical.
05:55:46 <pejo> JohnMeacham, or atleast specialize it?
05:56:27 <JohnMeacham> pejo: yeah. I use the mechanism described in boquist's thesis for turning it into first order strict code which can then be optimized via conventional techniques.
05:56:37 <pejo> JohnMeacham, oh. That is neat. How is that implemented, you try to optimize and if it doesn't work out you backtrack?
05:57:46 <JohnMeacham> the RULES? well, what happens is you have rules and catalysts, it takes each catalyst and matches it's body against the head of each rule, if they match, it creates a new combined rule.  so, after this preprocessing you end up with a bunch of rules you treat normally from then on.
05:57:54 <pejo> JohnMeacham, no, the CATALYSTS. :-)
05:58:21 <pastorn> is there an infinitet zipWith :: (a -> a -> a) -> [a] -> [a] -> [a] so that when one list ends the other is the results tail?
05:59:08 <pejo> JohnMeacham, hm. So you do some clever merging of rules and catalysts, to get a larger set of rules basically?
05:59:31 <JohnMeacham> in theory it can lead to n-squared rules, but in practice most catalysts don't match with most rules so it doesn't end up too bad. it would be possible to generalize the scheme... but i want to see how this works first. it will hopefully obviate the need for the 'phase' stuff needed in ghc.
05:59:39 <JohnMeacham> pejo: yes.
06:00:13 <oerjan> pastorn: nothing predefined that i know of
06:00:33 * pastorn makes his own
06:00:34 <oerjan> but it's been mentioned
06:00:45 <Deewiant> > let foo f (a:as) (b:bs) = f a b : foo f as bs; foo _ [] bs = bs; foo _ as [] = as in foo (+) [1..5] [1..10]
06:00:46 <lambdabot>  [2,4,6,8,10,6,7,8,9,10]
06:00:49 <Deewiant> pastorn: ^
06:01:27 <pastorn> noTruncZipWith <-- good name?
06:01:46 <pejo> JohnMeacham, so all your rules are some sort of "improvement", and the catalysts are 'glue' rules?
06:01:51 <JohnMeacham> the motivation is the deforestation, some tasks work better via build/foldr, others work better via destroy/unfoldr, it is tricky to mix the two as what can help one can hinder the other and you can't know a priori which will be the best way to go in general. CATALYSTS will get rid of that issue as the initial CATALYST will only fire if it allows a beneficial rule.
06:02:18 <JohnMeacham> I imagine other uses will be found. like ByteString deforestation.
06:02:32 <oerjan> something with a type like (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c] was discussed
06:02:41 <pejo> JohnMeacham, you haven't considered trying ordinary deforestation?
06:03:11 <pastorn> oerjan: was that to me?
06:03:13 <JohnMeacham> pejo: I am not sure what you mean by ordinary deforestation. deforestation is a goal, not a specific algorithm.
06:03:16 <Deewiant> oerjan: would be nice
06:03:17 <oerjan> pastorn: yes
06:03:32 <pastorn> cause i don't see how that would make any sense... or maybe i do
06:03:47 <Deewiant> when one of the lists runs out, use either of the auxiliary functions
06:03:49 <pastorn> but i only need (a -> a -> a) for this :)
06:03:50 <pejo> JohnMeacham, oh, I was refering to the algorithm by Wadler, and the possible extensions.
06:04:07 <oerjan> pastorn: yours essentially has the second and third arguments fixed as id
06:04:09 <Deewiant> pastorn: if we had that function you could use id for the latter two functions
06:04:20 <pastorn> so what would a good name be?
06:04:40 <JohnMeacham> ah. maybe. not sure. A lot of the optimizations eventually result in deforestation. but I don't have a specific 'deforestation' pass.
06:14:13 <pejo> JohnMeacham, does jhc have a simplifyer, or is that redundant with the rules machinery and the firstification stuff at the end?
06:15:13 <JohnMeacham> pejo: no, it has a fairly similar simplifier to ghc.
06:42:21 <jonaskoelker> can I have an if-elseif-else block with C-like indentation?  Can haskell-mode indent it properly?
06:43:18 <Lemmih> haskell-mode doesn't do a very good job on if-else-then.
06:43:33 <opqdonut> sadly
06:43:54 <b_jonas> meh
06:44:26 <guenni> is it possible to define a new data type in haskell in another way than using the designated notation?
06:44:52 <jonaskoelker> if there was any other notation, wouldn't it be designated as well? ;-)
06:45:12 <guenni> well there is a notation for defining functions
06:45:27 <jonaskoelker> guenni: I know of the keywords data, type, newtype
06:45:29 <guenni> and there is a notation for defining data type, ie. structures
06:45:47 <guenni> but since structures are really functions as well ...
06:46:05 <BMeph> Can I has Haskell fu? ;)
06:46:26 <byorgey> guenni: if you're asking whether it's possible to define anonymous data types, the answer is no.
06:46:28 <Lemmih> guenni: They /can/ be encoded as functions but that doesn't mean that they are.
06:47:05 <Lemmih> byorgey: Using church encoding, it actually is.
06:47:36 <b_jonas> actually,
06:47:51 <guenni> maybe I misstake to concepts, data type and data structure
06:47:53 <byorgey> Lemmih: well, fair enough, but I don't think that's what guenni was asking.  interesting point though. =)
06:48:08 <guenni> the latter is definately a function
06:48:19 <b_jonas> you cannot get anonymous data type constructors, but you can have new datatypes which are application of the existing data constructors sprung into existence by the type system
06:48:27 <b_jonas> without actually declaring them or antyhing
06:48:31 <b_jonas> like, you know
06:48:45 <Lemmih> guenni: Not necessarily.
06:48:59 <guenni> Lemmih: which?
06:49:09 <b_jonas> if you say 'let x = (3 :: Int, "foo");' then you've made a variable of type (Int, Foo) but not actually declared that type anywhere
06:49:26 <litb> what is this silly "can i has ..." pupping up on irc recently?
06:49:42 <litb> reminds me of lolcode
06:49:44 <opqdonut> otaku lolcat shit
06:49:46 <opqdonut> presumably
06:49:55 <Lemmih> guenni: Church encoding is just one possible way of representing data structures.
06:49:58 <opqdonut> makes me want to stab people when i see it
06:50:13 <resiak> i can has knife wound?!
06:50:35 <guenni> Lemmih: thx, I'll look that up
06:50:41 <BMeph> resiak: The answer is: Yes! Haskell can do that!
06:51:02 <JohnMeacham> I am starting to think the star trek writers are not entirely clear on what a 'nebula' is.
06:52:18 <BMeph> JohnMeacham: That's like saying "I'm not sure that Microsoft reseachers really understand functionall programming." It's not a homogenous group, of which you speak.
06:52:20 <daf> it's a nebulous concept
06:52:38 * resiak whaps daf
06:52:41 <paolino> to make a Reader that consumes (like Writer produces) , I must use State ?
06:53:09 <guenni> Lemmih: thx, very much for this keyword, I think this creates the missing link I had in comprehending Haskell
06:53:20 <JohnMeacham> I like how the name of the real transparent aluminum sounds much more sci-fi than the star trek name.
06:53:27 <JohnMeacham> it is called 'nanophase aluminum'
06:54:11 <daf> surely starfleet would have standardised on "aluminium"
06:54:12 <opqdonut> no, it's called "plasteel"
06:56:08 <b_jonas> litb: yeah, it's lolcat slang, and it's "i can has" even when it's a question
06:56:31 <Vq^> JohnMeacham: it's probably best to just watch Red Dwarf instead :P
06:56:53 <daf> heh, Red Dwarf's science is even fuzzier :)
06:57:04 <paolino> > execWriter (tell [3] >> tell [6])
06:57:15 <lambdabot>   Not in scope: `execWriter'
06:57:16 <Vq^> daf: it's clear as nebula! :P
06:58:48 <JohnMeacham> hmm.. jhc's md5sum clone is weighing in at 40k. not too bad. the c one is 28k.
07:01:30 <pejo> JohnMeacham, what about performance? :)
07:02:39 <Vq^> and what about the code-chunks that actually does the job
07:03:44 <JohnMeacham> I'll let you know as soon as I figure out why it is segfaulting :)
07:04:02 <Vq^> would be interesting to compare the c and jhc hello-world programs sizes
07:09:16 <JohnMeacham> jhc's is 6844 bytes.
07:10:52 <JohnMeacham> c's is about half that. but it gets to call an external routine (printf)
07:11:33 <daf> JohnMeacham: presumably you use libc for syscalls
07:12:21 <litb> lolcat?
07:12:23 <JohnMeacham> yeah. but it is still walking a list calling putChar for printing the string.
07:12:25 <litb> was it renamed?
07:12:42 <daf> JohnMeacham: right
07:16:10 <pchiusano> is ghc entirely written in haskell? or is part of it in C?
07:17:08 <dcoutts> pchiusano: the runtime system is written in C and C--, and parts of the base libraries are in C.
07:23:35 <JohnMeacham> Hmm... farscape had a better evil omnipotent clown.
07:33:48 <byorgey> litb: it hasn't been renamed, lolcode was a spinoff of the original phenomenon of 'lolcats'
07:34:10 <byorgey> litb: haven't you seen lambdacats? =)
07:34:20 <byorgey> @where lambdacats
07:34:20 <lambdabot> http://arcanux.org/lambdacats.html
07:35:05 <b_jonas> yeah, they're nice
07:35:09 <b_jonas> I really like that
07:35:24 <b_jonas> my fav is the KittehT
07:36:12 <farsworth> i wanna learn haskell. i've got a laptop and lotta time. where do i begin?
07:36:35 <b_jonas> farsworth: install ghc first
07:36:40 <b_jonas> I dunno what next though
07:37:28 <farsworth> k thx. ghc didn't work on leopard last time i checked thou.
07:37:38 <Vq^> farsworth: i would recomend the haskell wikibook
07:38:05 <litb> lol
07:38:12 <farsworth> oh, great. I saw it when it was a cute little booklet. time flies.
07:39:32 <Vq^> farsworth: didn't work?
07:39:38 <byorgey> farsworth: there is also Yet Another Haskell Tutorial (affectionately known as YAHT).
07:39:41 <byorgey> @where yaht
07:39:42 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
07:39:54 <Vq^> farsworth: there are certainly packages for darwin
07:39:56 <farsworth> thaanks, byorgey
07:39:59 <byorgey> farsworth: and feel free to ask plenty of questions here =)
07:40:38 <farsworth> great. thank you people. I didn't expect such a friendly response.
07:40:52 <Tac-Work> #haskell is about the friendliness
07:40:52 <litb> who does contribute to lambdacat?
07:41:15 <Tac-Work> (It's what separates us from the guys using blub)
07:44:51 <Vq^> farsworth: do you have any earlier programming experience?
07:45:54 <byorgey> litb: anyone who wants to.
07:45:56 <Twey> The Haskell wikibook is OK, but there are some holes in it
07:45:58 <farsworth> I've tried learning various languages many times, but I haven't ever coded anything longer than couple of screenfuls.
07:46:05 <Twey> And its monad explanation is poor
07:46:19 <Vq^> farsworth: any functional languages?
07:46:19 <Twey> (for now, it's being rewritten)
07:46:23 <Twey> I had to go to All About Monads.
07:46:29 <farsworth> um, lisp
07:46:51 <farsworth> um is an interjection, not a language, no need to google )
07:47:15 <Vq^> Twey: i think that random state is a fairly good example
07:47:17 <litb> and "," ?
07:47:29 <EchoMirage> which packages should i install to use haskell? need an interpreter, and some highlighting editor
07:47:31 <farsworth> you've got me here
07:47:45 <Twey> Vq^: It is, but it's not really explained well
07:47:54 <farsworth> it's a Revelation of beastly Syntax
07:48:19 <cjb> EchoMirage: many people use emacs, haskell-mode and ghci,
07:48:20 <cjb> .
07:48:23 <litb> EchoMirage: you can use kate of kde , or emacs with haskell-mode . then you need ghc which is quite fine omho
07:48:26 <litb> *imho
07:48:40 <Vq^> Twey: no, i guess it could be a lot better
07:49:01 <EchoMirage> ok. i had problems installing ghc, told me that two packages try writing the same file
07:49:09 <EchoMirage> or something. is this common ?
07:49:24 <litb> um i haven't run into this
07:49:37 <byorgey> EchoMirage: what platform?
07:49:45 <EchoMirage> ubuntu (latest)
07:50:00 <Twey> EchoMirage: What was the file?
07:50:01 <EchoMirage> gnome
07:50:03 <litb> better late than never
07:50:06 <Twey> And the two packages?
07:50:09 <EchoMirage> i try again. hold on
07:50:24 <litb> oh sorry to recommend kate then
07:50:27 <Vq^> farsworth: if you know the difference between functional programming in lisp and imperative you should have it easier than most learning haskell
07:51:00 <Twey> Eh, Kate is pretty cool, as GUI editors go
07:51:03 <Twey> I use it sometimes
07:51:20 <roconnor> I use kate to edit my haskell
07:51:22 <litb> yeah, i like it too. but he is on gnome. who knows
07:51:22 <farsworth>  functional and imperative programming in lisp or lisp and imperative languages?
07:51:53 <Vq^> farsworth: imperative in lisp
07:52:00 <farsworth> I know it, but I don't think I grok it deeply.
07:52:31 <litb> i hope Yi grows quickly
07:52:40 <Twey> It is growing quickly
07:52:51 <litb> does it have a haskell interpreter built in already? so that i have REPL in the editor?
07:52:51 * Tac-Work wishes I had time to play with Yi more
07:52:57 <EchoMirage>  E: /var/cache/apt/archives/ghc6-libsrc_6.6.1-2ubuntu2_all.deb: try to overwrite Â»/usr/share/doc/ghc6-libsrcÂ« which is als on package ghc6-doc
07:53:20 <Tac-Work> litb: it can evaluate Haskell: M-x and type in your command
07:53:28 <Tac-Work> you can even tab to autocomplete function names
07:53:33 <EchoMirage> the typo is my fault. its german in my version^^
07:53:36 <litb> EchoMirage: well, the remove that file i would say
07:53:40 <Vq^> farsworth: lisp programs can either depend on mutable variables (setq and friends) or it can use recursion and functions
07:53:50 <litb> ah, nice
07:53:57 <pejo> litb, nooo, don't remove files underneath the package system.
07:54:12 <litb> EchoMirage: you can use "LANG=C <command>" to have english output
07:54:40 <litb> pejo: hm, but if he searches for that file in the package system and it doesn't belong to any package, i would just remove it
07:54:50 <farsworth> okay. no, I'm not comfortable with mutable variables in lisp. I'll look it up, thanks.
07:54:54 <litb> and apparently it belongs to the one that is not yet installed
07:54:56 <pejo> litb, it just said it belongs to ghc6-doc however.
07:55:09 <Twey> farsworth: Er... (setf)?
07:55:10 <Vq^> farsworth: no need
07:55:16 <litb> pejo: indeed :)
07:55:37 <Vq^> farsworth: if you have only coded without mutate variables in lisp you will feel right at home in Haskell :)
07:55:44 <litb> ah wait. it belongs to a different package
07:55:53 <litb> well, then forget what i said. silly litb
07:55:56 <farsworth> I used them, but I always thought that they are included just in case.
07:56:02 <desegnis> EchoMirage: Are both packages from the Ubuntu repositories?
07:56:21 <desegnis> (Stupid web IRC clients. Yay, I'm back!)
07:56:30 <Vq^> farsworth: you are completely right, thought they are often overused by programmers comming from languages like C and Java
07:57:29 <EchoMirage> seems like this. not sure though
07:59:08 <desegnis> EchoMirage: Anything non-ubuntu in /etc/apt/sources.list?
07:59:53 <EchoMirage> "permission denied" lol
08:00:09 <EchoMirage> let me see how i can get into this file
08:00:21 <desegnis> sudo your-editor the-path
08:00:42 <desegnis> or better, sudo less
08:01:46 <EchoMirage> everything canonical
08:02:48 <desegnis> then I'd argue that either of the packages is broken, or else, that you need only one of them
08:03:15 <EchoMirage> ok i try install one after another
08:04:59 <EchoMirage> ok its done. only the source code package makes the trouble
08:05:05 <desegnis> EchoMirage, I realize you could have googled this :) see https://bugs.launchpad.net/ubuntu/+source/ghc6/+bug/148702
08:05:06 <EchoMirage> guess i dont really need it
08:05:43 <byorgey> farsworth: mutable variables in lisp are like a security blanket.  Only problem is, the security blanket is nailed to the floor.  Haskell takes away the blanket and tells you to grow up and go outside. =)
08:06:11 <EchoMirage> ok i didnt know about Bug #148702  sry  =)
08:10:30 <mux> it helps to be bored at work, I've got the basics of libarchive bindings for haskell working now :-)
08:11:52 <Baughn> Just off the bat, would it make sense to do a (prototype) fuse-using DFS entirely in haskell, or should I be planning to have haskell provide the logic and C the heavy lifting?
08:18:07 <guenni> > 4 + 5
08:18:18 <lambdabot>  9
08:18:49 <Tac-Work> > "lambda" ++ "bot"
08:18:50 <lambdabot>  "lambdabot"
08:22:47 <Taejo> @src scanl
08:22:47 <lambdabot> scanl f q ls = q : case ls of
08:22:47 <lambdabot>     []   -> []
08:22:47 <lambdabot>     x:xs -> scanl f (f q x) xs
08:23:34 <Taejo> @src fold
08:23:34 <lambdabot> Source not found. It can only be attributed to human error.
08:23:37 <Taejo> @src foldl
08:23:37 <lambdabot> foldl f z xs = lgo z xs
08:23:37 <lambdabot>     where lgo z []     =  z
08:23:37 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
08:29:10 <litb> hm, foldl and scanl seems to be quite similar
08:29:20 <litb> -s
08:30:17 <dcoutts> mux: what do we need libarchive for? we've already got pure tar code :-)
08:32:49 <mux> dcoutts: libarchive supports much more than tar -- though there isn't any terrific reason that explains why I started this work :-)
08:33:19 <dcoutts> mux: most of the others are pretty simple too though, eg ar is ~20 lines of code to read or write
08:33:36 <litb> > scanl (*) 1 [2..5] -- [1,2,6,24,120] ?
08:33:41 <lambdabot>  [1,2,6,24,120]
08:33:43 <vininim> @test \ x -> foldl (:) [] x == scanlf (:) [] x (x::[Integer})
08:33:43 <lambdabot> Maybe you meant: let list tell temp
08:33:51 <litb> nice
08:33:57 <mux> libarchive supports tar (lots of variants: pax, ustar, gnutar...), ar archives, cpio, zip, iso9660, shar
08:34:24 <dcoutts> mux: though really we only needed pure tar code so that we could use it on windows without needing any other C libs
08:34:29 <mux> that with bzip2, gzip or compress compression
08:34:46 <dcoutts> both of which we already have bindings to :-)
08:34:47 <mux> it auto-detects archive etc, it's some nice stuff
08:34:52 <dcoutts> right
08:35:15 <mux> but there is no haskell module that you can give a tar.gz, or a .zip, or a .iso file that will be able to manipulate it
08:35:32 <dcoutts> indeed, not any one of them
08:35:46 <dcoutts> we handle .tar.gz in cabal-install
08:36:01 <mux> really, I started this out of pure boredom, but I think it can be useful
08:36:36 <dcoutts> aye, probably so, I'd not realised it did so many formats
08:37:11 <mux> FreeBSD recently gained shiny new ar(1) and unzip(1) programs both based on libarchive
08:37:31 <mux> and our tar(1) is also based on it, that comes in handy to type: "tar xvf foo.iso" :-)
08:38:09 <dcoutts> heh
08:39:07 <Taejo> ack... I've got a program that seems to give the right answers when I use foldr . flip, but I *think* that should be wrong and foldl should be used
08:39:52 <Taejo> in fact, something is definitely not right
08:40:18 <Taejo> my non-grokking of foldl doesn't help
08:40:29 <mux> dcoutts: too bad bindings inevitably end up in full IO territory
08:41:01 <byorgey> Taejo: foldl (#) z [a,b,c] = ((z # a) # b) # c
08:41:17 <dcoutts> mux: aye, though presumably some lazy unsafeInterleaveIO would help there
08:41:20 <byorgey> foldr (#) z [a,b,c] = a # (b # (c # z))
08:41:38 <dcoutts> mux: after reading the file everything else should be pure right?
08:42:24 <byorgey> Taejo: so (foldr . flip) (#) z [a,b,c] = ((z # c) # b) # a
08:42:24 <Taejo> byorgey: aye
08:42:56 <byorgey> Taejo: dunno if that helps =)
08:43:30 <mux> dcoutts: not sure yet
08:43:58 <Taejo> it makes me more sure that I need foldl; my bug must be elsewhere. just a coincidence that foldr gives the right answer in my one test-case
08:45:47 <mux> mmm, what is stopping us from defining a proper MonadFail function with a failure function with a name other than 'fail', obviously, but with the correct semantics?
08:46:12 <mux> wether fail gets removed out of Monad or not some time later, this should still be correct
08:46:49 <mux> it sucks not to have any Good Proper Way (tm) to write functions that potentially fail without hardcoding them into the Maybe monad or some other one
08:47:04 <mux> s/MonadFail function/MonadFail type-class/
08:47:16 <dons> well, we have a few good ways
08:47:22 <Saizan> mux: essentially MonadZero?
08:47:47 <mux> something to write functions like lookup
08:48:04 <mux> that you can use either in IO with exceptions thrown in case of failure, or with Maybe, or with ...
08:48:17 <mux> other than by using fail, of course
08:49:58 <Saizan> that was MonadZero :\
08:50:19 <mux> @src Data.Map.lookup
08:50:19 <lambdabot> Source not found. stty: unknown mode: doofus
08:51:13 <mux> Saizan: but that got removed, right?
08:51:36 <dons> oh, no containers package
08:51:47 <dons> Cale, we need some of the extras packages, I think?
08:51:53 <dons> :t Data.Map.lookup
08:51:56 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
08:51:57 <dons> oh, i need coffee.
08:52:14 * mux will use fail for now, yet again
08:52:30 * mux wants MonadZero and readM ;-)
08:52:36 <dons> fail sucks
08:52:46 <dons> if you like making it easier to break critical systems
08:52:47 <mux> it wouldn't suck as much if it was named pfail
08:52:50 <dons> use fail!
08:52:58 <mux> and used only appropriately
08:53:08 * EvilTerran tends to use Alternative rather than MonadPlus, when possible
08:53:27 <dons> overloading on the fail type is just a big hole encouraging more failures
08:53:53 <mux> you can't attach error messages to failures with MonadPlus :-(
08:55:17 * sclv finds it rather hard to believe that someone will use polymorphism over fail and do something silly like return into the Cont or Reader monad...
08:55:31 <sclv> i.e. if you know enough to do one you know enough not to do the other.
08:55:52 <sclv> not that that a type-sound well organized language makes.
08:56:19 <EvilTerran> "polymorphism over fail"? er, fail is polymorphic...
08:56:30 <dcoutts> dons: I've been reviewing the crazy ghc-options that people use in packages on hackage and have now banned most of them :-)
08:56:51 <sclv> EvilTerran: yeah. it was unclear wording.
08:56:55 <dcoutts> dons: your packages were frequently found among the offenders ;-)
08:57:02 <mux> no cookie for dons
08:57:11 <dcoutts> well, his at least made some sense
08:57:16 <dcoutts> some were just bonkers
08:57:21 <dons> you've banned extensions?
08:57:22 <dcoutts> like ghc-options: -o
08:57:22 <Taejo> dcoutts: like?
08:57:23 <mux> -O999 ? :-)
08:57:26 <dcoutts> wtf?
08:57:27 <mux> ouch.
08:57:30 <dons> -o yikes
08:57:36 <dcoutts> well, quite
08:57:41 <mux> -o /dev/stdout
08:57:51 <Taejo> :-o
08:59:00 <dcoutts> dons: mostly things where there are correct alternatives, like using extra-libraries: ncurses rather than ghc-options: -lncurses
08:59:00 <Igloo> dcoutts: That reminds me, there are some odd dots in this: http://urchin.earth.li/~ian/docon.cabal Makes me wonder if the manual is unclear as to their purpose
08:59:47 <dcoutts> Igloo: that used to be needed because the old .cabal file parser interpreted blank lines as section breaks
08:59:49 <mux> dcoutts: oh? I thought extra-libraries was the way to go
09:00:05 <dons> dcoutts: oh, right.
09:00:06 <dcoutts> mux: yes it is, that's what I'm checking for
09:00:21 <mux> ah, I read what you said backwards
09:00:25 <Igloo> dcoutts: I know what they were for, but the ones in that file don't make sense (unless I'm wrong, anyway)
09:00:28 <dcoutts> mux: sorry, that was unclear wasn't it :-)
09:01:06 <dcoutts> Igloo: it's not clear that they don't make sense, it just adds extra blanks into fields that are not sensitive to blanks.
09:01:08 <Igloo> (and IMO they should have caused errors when used in the fields they are used in anyway)
09:01:37 <dcoutts> Igloo: the '.' stuff is handled before the individual field parsers get to see them.
09:01:56 <dcoutts> in his example if you removed them the thing would not parse
09:01:57 <Igloo> dcoutts: Right, but I doubt Serge intended that when he put them there. It looks like he thinks '.'s end multi-line fields
09:02:32 <dcoutts> Igloo: I think it's because he want's to use a blank line for aesthetic reasons
09:02:44 <dcoutts> but he cannot do that with the old .cabal file format, hence the '.'
09:02:47 <Igloo> Fair enough, it could be
09:02:52 <dcoutts> if he used the new format it'd be fine
09:05:04 <Taejo> now *that* really makes *no* sense: the python version snocs where my program conses (so I was expecting to get the reverse results) but they give the same result
09:09:06 <vininim> oh.. there is no mercury entry in the shootout page
09:13:28 <vincenz> @src (!)
09:13:28 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
09:14:05 <vincenz> @join #oasis
09:16:53 <JohnMeacham> hmm... I wonder if people will be too freaked out if I always turned on ho caching. so they would never see .ho or .o or .hi files or anything next to their source files.
09:17:46 <Lemmih> JohnMeacham: Where would the .ho files go, the?
09:18:01 <Gnezdo> JohnMeacham: nothing next to the source files sounds good to me.
09:20:03 <JohnMeacham> ~/var/cache/jhc/b49f25449bcbb0be184ebbf55f15ff13.ho  - where the name is the md5 sum of the source file leading to it.
09:20:21 <JohnMeacham> or some other suitable global directory.
09:20:23 <sarehu> by 'name' do you mean path?
09:20:35 <Lemmih> That'd be neat.
09:20:35 <JohnMeacham> file name.
09:20:53 <Gnezdo> JohnMeacham: you man want to hash the file contents too
09:21:00 <JohnMeacham> yeah. I have basic support for it now, but I am considering dropping support for the old style completely.
09:21:14 <sarehu> hm, I'd rather have it be the full path to the file
09:21:21 <sarehu> Or maybe not...
09:21:26 <Gnezdo> then you can do away with time checks
09:21:27 <JohnMeacham> oh, it is th md5sum of the contents only. not the file name.
09:21:27 <sarehu> File contents, yes
09:21:36 <JohnMeacham> it already does no time checks.
09:21:37 <Gnezdo> oh
09:22:16 <JohnMeacham> but it tries to stick the ho files next to their source files, like .hi files in ghc. but I realize there isn't much reason other than aethetics to do that...
09:22:43 <Gnezdo> there are reasons not to: hard to clean up
09:23:58 <coffeemug> hello
09:24:19 <JohnMeacham> yeah. I am not sure where the best place to put the cache would be though when you don't have one set up. I mean, somewhere like ~/.jhc would work, but when somethin went wrong, or you wanted to delete the ho files to do a 'make clean' manually, that would be a pain. dropping them all in the current directory is also an option... but taht might get dirty. hmmm...
09:25:18 <litb> hello coffeemug
09:25:29 <coffeemug> is getLine supposed to raise EOFException?
09:25:46 <jedbrown> JohnMeacham: Would ho files produced by different versions of the compiler conflict?
09:26:11 <coffeemug> it seems that pressing ctrl-D while the program is in getLine doesn't cause it to raise anything
09:26:28 <monochrom> That is because readline is interfering.
09:26:41 <monochrom> try it on a file.
09:26:42 <JohnMeacham> nah, I can include the compiler version as part of what is hashed.
09:27:29 <coffeemug> monochrom: I kind of need it in the terminal :)
09:27:40 <coffeemug> monochrom: what do you mean by interfering?
09:27:58 <Lemmih> coffeemug: try:ghc -e 'getLine'.
09:27:59 <litb> coffeemug: gnu readline has a highlevel line lib, it catches the eof
09:28:09 <JohnMeacham> coffeemug: are you trying it in ghci? that won't work because ghci puts the terminal in raw mode. if you compie your program as a file, it should be fine.
09:28:36 <coffeemug> hmm, I'm trying with runhaskell
09:28:36 <monochrom> terminal permits all kind of hacks.
09:29:02 <JohnMeacham> yeah. runhaskell uses ghci I think. it isn't quite the best.
09:29:07 <litb> current terminals and their APIs are broken anyway =)
09:29:20 * monochrom wishes everyone had taken a unix low-level stuff course. terminal hacks are covered.
09:30:02 <litb> our teacher pressed ctrl+s , trying whether the mail get sent, and locked thereby his terminal =)
09:30:26 <JohnMeacham> stty -xon -xoff. that gives you two new keys to map in vim :)
09:30:33 <coffeemug> Lemmih: that seems to work
09:31:05 <jedbrown> JohnMeacham: If you cache ho files, do they stay forever, get manually deleted, or do you have a GC system in mind?  The sharing for identical files is cool, but I don't know how much it helps.  It seems like cleanup would be simpler without.
09:31:19 <litb> well later i discovered that simply pressing "roll" seems to enable it again
09:31:45 <JohnMeacham> jedbrown. they would just be files. you would manually clean them, just like '.o'  or '.hi' files.
09:32:40 <dcoutts> JohnMeacham: cabal wants to put all generated files under dist/ and when we use a dep framework we'll want to know exactly where generated files go, so using a hidden cache doesn't seem ideal for that.
09:32:43 <byorgey> litb: ctrl+q does as well, I think
09:33:10 <jedbrown> JohnMeacham: If they were held in a cache somewhere else, and there was sharing, how would you know what you could delete (without something elaborate)?
09:33:27 <dcoutts> JohnMeacham: of course we do not have to use just file timestamps to see if things are out of date, any other cheap method is ok.
09:33:58 <vincenz> jedbrown: there's a HUGZ page now
09:34:36 <JohnMeacham> yes. xoff is ctrl-s and xon is ctrl-q. they were used for congestion control over serial lines when extra hardware lines wern't available. they are still available with modern ttys, even virtual ones connected to an xterm. stty can disable tthem letting you use ctrl-s and ctrl-q for your own purposse.
09:35:25 <dcoutts> JohnMeacham: also, generating files with unpredictable names is a pita for a dependency system that is trying to track all the state
09:35:27 <byorgey> JohnMeacham: interesting.  I never knew all that, I just knew that when I accidentally hit ctrl-s I have to hit ctrl-q to get it unstuck =)
09:35:30 <JohnMeacham> dcoutts: it is probabaly easiest just to ask jhc. like 'make -q'.
09:35:57 <dcoutts> JohnMeacham: we do want it to be really cheap though, eg if we have hundreds of files across several packages.
09:36:28 <JohnMeacham> they are quite useful as custom key bindings since most apps won't assign them themselves since they arn't always available.
09:38:03 <JohnMeacham> dcoutts: well, you wouldn't need to ask for individual files. just the final target. 'is this up to date?'. I have used 'md5sum' and touch in makefiles on occasion when I needed to control dependency analysiss more carefully for a project.
09:38:48 <dcoutts> JohnMeacham: it just makes me nervous, it's not clear we'd be able to see the whole dep graph that way
09:39:23 <dcoutts> we don't want to effectively be doing recursive make
09:40:35 <JohnMeacham> well, for any moderately complicated project with epheremal intermediate files I doubt you will be able to see the whole dep graph anyway as soon as people start doing interesting things. working well with incomplete information will be a challenge...
09:41:31 <JohnMeacham> yeah. I had to pull some odd shenanigans to avoid recursive make in some projects.... one really is better off when they can avoid it.
09:41:44 <coffeemug_> JohnMeacham: what did you mean by "raw mode"? What exactly does ghci do?
09:41:52 <coffeemug_> I'm wondering if there is a way to turn that off
09:43:10 <n00b> i am running a code and importing a module and i keep getting an error that say Module "Main" already loaded
09:43:22 <dcoutts> JohnMeacham: sure, sometimes we have to have dynamic dependencies, some parts of the graph cannot be generated til other parts are up to date, but I don't think that's a problem.
09:43:48 <dcoutts> we can still track everything precisely in situations like that
09:43:58 <JohnMeacham> coffeemug_: in the posix package there is likely a call to do it. your terminal normal interprets several characters on its own to give basic line editing stuff, like backspace, ^d, etc. if you type 'stty -a' you will see a list of them (among other things). many programs such as readline that ghci uses want to implement their own more advanced line editing so set the terminal in raw mode, turning off its handling of those k
09:43:58 <JohnMeacham> eys, and interpret thinsg themselves. when you called 'getLine' you were then reading directly, bypassing readline, but the terminal was still in raw mode since readline put it in that state.
09:44:14 <JohnMeacham> it is a bug if 'runhaskell' is setting the terminal into raw mode on its own.
09:44:40 <n00b> i am running a code and importing a module and i keep getting an error that say: Module "Main" already loaded
09:45:32 <JohnMeacham> jedbrown: yeah, that is why I was thinking something like the current directory, so you know you can delete just all those for whatever you built recently. but if you set a HOCACHE environment variable you can create a global one... hm..
09:45:43 <byorgey> n00b: please don't repeat yourself.  we heard you the first time.
09:45:52 <n00b> ok
09:45:52 <byorgey> n00b: is this with hugs or ghci?
09:46:17 <JohnMeacham> or with a --hocache command line option.
09:46:43 <Lemmih> n00b: put 'module {ModuleName} where' at the top of your files.
09:48:51 <coffeemug_> JohnMeacham: thanks
09:49:09 <coffeemug_> JohnMeacham: I'll try using readline wrapper and see if that works better
09:49:48 <JohnMeacham> coffeemug_: yeah, if you want to interact with a user via the command line, just using readline directly is the way to go.
09:50:45 <jedbrown> JohnMeacham: It seems that the cache could grow very large during the edit/build/test cycle.  But cleaning it is not easy if you have to know the md5 to find it.  You lose sharing and the ability to move the original if you include its path in the ho, but that would let you clean the cache.
09:55:21 <JohnMeacham> jedbrown: yeah. that is an issue... hmm... okay. I think perhaps just using the current directory is the best bet. it will be ugly, but at least it will be obvious. and each ho file could include within it the path to the original file used and that could be used to 'clean out' old entries on request if the md5sum is no longer accurate.
09:56:50 <n00b> getting an error that says Module "GUI" not previously loaded
09:57:56 <n00b> ???
09:59:42 <Lemmih> n00b: Try pasting your session on hpaste.org
10:00:54 <ToRA> @type concat <$> forM testFiles $ \tf -> unfoldr (listToMaybe . reads) <$> readFile tf
10:01:02 <hpaste>  n00b pasted "master" at http://hpaste.org/5599
10:01:05 <lambdabot> Not in scope: `testFiles'
10:01:42 <mauke> n00b: truncated
10:01:46 <hpaste>  noob annotated "master" with "ccgui" at http://hpaste.org/5599#a1
10:01:59 <n00b> there
10:02:04 <jedbrown> JohnMeacham: If it's in the same directory, then the path to the original is presumably not necessary.  I do like the cleanliness of an (optional) external cache, but it presents a host of issues.  What if you kept (in the cache) a global table of the path to all the .hs files JHC had ever seen.  Then a clean would just truncate the list to the remaining filenames, compute md5s, and remove the excess ho files.
10:02:44 <n00b> i am trrying to separate the game from the gui part
10:03:10 <n00b> the gui and all the other things to be designed are gonna be like a gui
10:03:41 <byorgey> @type concat <$> forM ?testFiles $ \tf -> unfoldr (listToMaybe . reads) <$> readFile tf
10:03:41 <lambdabot>     Couldn't match expected type `[String]'
10:03:42 <lambdabot>            against inferred type `IO String'
10:03:42 <lambdabot>     In the second argument of `(<$>)', namely `readFile tf'
10:04:24 <n00b> sorry extension
10:04:24 <n00b> plugin feature
10:04:34 <ToRA> byorgey: there's an irritating precedence issue there that just bit me
10:05:16 <n00b> well it seems i am in the wrong place later
10:05:28 <JohnMeacham> jedbrown: hmm.. I am thinking of a scheme whereby the files would still be named after the source files and in a similar layout, but that will just be taken as a hint, as in, the file itself will contain the hash of the source rather than the hash being the  name of the file.. that might allow both schemes to interact well. technically, internally, it will still be ttreating all the ho files as a big mapping of hash of conte
10:05:28 <JohnMeacham> nts to ho file like if they were all in one directory, but they would be named after the source file just so the compier can initially find them...
10:05:56 <byorgey> ToRA: ah, indeed.  you want concat <$> (forM ...., right?
10:06:18 <ToRA> byorgey yeah, though i've swapped to liftM concat . forM ...
10:06:28 <byorgey> ToRA: sure.
10:06:48 <JohnMeacham> actually... hmm.. i need to examine every source file eventually anyway, so I should just do an initial pass looking up everythings dependencies ignoring the ho files completely.... I will have to reparse the 'import' lines from the files though... hopefullly that won't be so bad.
10:07:58 <JohnMeacham> unless... hmm.. in a special section of the file I could have a map of file content hashes to module deps....
10:09:23 <Chad> @src foldM
10:09:23 <lambdabot> foldM _ a []     = return a
10:09:23 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
10:11:42 <JohnMeacham> yeah. parsing the files might involve invoking preprocessors or something...
10:14:44 <JohnMeacham> yes. yes. this might scale very well. hmm...
10:17:34 <jedbrown> JohnMeacham: I assumed the ho files would all go in ~/.jhc/cache/md5-hash-of-file-contents.ho so you could have sharing between, say, different branches of the same repository.  You can, of course, purge the entire directory, but it would be nice to just clean a particular tree, in which case you need some sort of GC.  Perhaps you could do it with hard-links from a mirrored directory tree.  The dependencies are on the md5, correct?  Do they include path?  
10:18:04 <dcoutts> JohnMeacham: yes, dependency chasing has to interleave with running pre-processors, that's one thing that makes it tricky.
10:20:08 <dcoutts> JohnMeacham: looking at other clever build systems (eg Vesta) they track file dependencies fully precisely, so external tools are not allowed to read or write any files that are not specified in the rules (though they can be dynamically discovered) but that does make using 'hidden' caches difficult to integrate into such a system.
10:20:18 <JohnMeacham> jedbrown: yeah. that is the idea. I always planned on having that when specifically asked by the user... I was debating the  merits of making it the default always as supportng a mix of the two modes is becoming tricky.
10:21:12 <dons> dcoutts: imagine if hackage looked something like this: http://www.apple.com/downloads/
10:21:13 <lambdabot> Title: Apple - Downloads
10:21:23 <dons> top libs on the left. new items, a submit button
10:21:25 <JohnMeacham> if the user asks for a global cache, I am not as worried about the GC issue as presumably they know the consequences. but I wouldn't want to force it on anyone.
10:21:33 <dons> and then categories sorted nicely
10:21:52 <dons> dcoutts: with a one-click download button
10:22:08 <dcoutts> dons: I was thinking more of the google home page, search for the thing you want
10:22:33 <dcoutts> dons: so you can search for package name, category, description, haddock docs, whatever
10:22:39 <dons> if you go to 'all downloads' , that's a nice presentation of the categories
10:22:47 <JohnMeacham> okay. I am making the assumption that I can always count on the module name and the import list of a file depending on its md5sum and nothignn else, hopefully that wil hold. it does hold right? I am discounting things like preprocessors that change   behavior depending on the week, but I think that isn't too much of a stretch.
10:22:55 <dons> dcoutts: yep, search is key.
10:23:08 <dons> dcoutts: we might even look at autotagging stuff
10:23:34 <JohnMeacham> that way I don't have to worry about whether a ho file is up to date, if the hash does't match, i won't be looking at it in the first place, and if it does, the files contenst are the same.
10:23:35 <dcoutts> dons: if there is decent search then there is no need for navigating via categories, you just search for 'guis' and get all such packages
10:24:11 <dcoutts> dons: what do you mean by autotagging?
10:24:27 <dcoutts> dons: adding extra keyword search terms to existing packages?
10:24:46 <dons> yep, say by analysing the src itself
10:25:02 <dons> sort by things that use the FFI or ...
10:25:03 <dcoutts> right, we should just hoogle the whole package
10:25:06 <dons> yep
10:25:16 <dcoutts> on all the meta data and function names and haddock docs
10:25:18 <oerjan> dcoutts: that presumes people can guess the keyword names
10:26:14 <dcoutts> oerjan: if essentially everything in the package is indexed then that should be enough, keywords just promote things up the search ranking vs text buried in some comment deep in the package.
10:26:17 <gwern> so, any have adns and openssl installed? want to try 'cabal install postmaster'?
10:26:19 <dons_> i think we need to present both powerful search, and a modern category interface
10:26:24 <JohnMeacham> hmm.. is there anything else useful that can be determined by the contents of a haskell file and nothing else? nothing it imports or whatnot?
10:26:30 <gwern> or maybe oleg's ZFS I recently uploaded?
10:27:05 <oerjan> dcoutts: i mean, categories are nice if you don't know what what you are looking for is _called_
10:27:26 <dcoutts> oerjan: categories are just more keywords :-)
10:27:41 <dcoutts> as are module names etc
10:27:42 <dons_> gwern: oh, you uploaded zfs (is it a library?)
10:28:04 <oerjan> dcoutts: the point is to be able to list all keywords in some hierarchy
10:28:16 <dons_> categories, tags, text search
10:28:17 <dons_> all good.
10:29:00 <dcoutts> oerjan: they're not necessarily hierarchical, packages can be in multiple categories
10:29:33 <oerjan> dcoutts: that's still hierarchical
10:29:37 <gwern> @tell shapr Yeah, I tried that email address for Gordon since he was the contact listed for LOLITA, but I wuz bounced
10:29:37 <lambdabot> Consider it noted.
10:29:38 <asmanian> hi all
10:29:38 <JohnMeacham> I suppose I could make a pragma like {-# PARANOID_DEPENDENCY_CHECKING #-}  that wil instruct the compiler to re-run its preprocessors as they might change its module name or what it imports, but that certainl ywon't be the common case and can be done on a module by module basis.
10:29:38 <gwern> good grief the wxhaskell repo is slow. I've been stuck on patch #37 for a while
10:29:38 <asmanian> I read the "gentle introduction" and want to start haskell with a little tutorial program
10:29:38 <asmanian> I thought of a xml parser or so
10:29:38 <asmanian> is there an easy to use library you would recommend?
10:29:38 <asmanian> ie for parsing xml?
10:29:38 <gwern> I like tagsoup, although it's not strictly an xml parser
10:29:38 <gwern> uh oh.
10:29:38 <gwern> how do you tell lambdabot to forget about a @tell?
10:30:08 <dons_> gwern: not possible
10:30:10 <gwern> dons_: it's kind of a library, I guess
10:30:14 <gwern> dons_: :(
10:30:39 <gwern> @tell shapr Er, ignore the previous. I meant shacaf. (similar names, right?)
10:30:40 <lambdabot> Consider it noted.
10:30:42 <asmanian> thnx I'll take a look
10:30:52 <gwern> @tell shacaf Yeah, I tried that email address for Gordon since he was the contact listed for LOLITA, but I wuz bounced
10:30:52 <lambdabot> Consider it noted.
10:32:01 <oerjan> gwern: it's shachaf
10:32:54 <gwern> dons_: what I mean by kind of is that it comes with its own implementation of CC-delcont; I wanted to rip out the bundled one, but unfortunately the two have drifted over the years
10:32:57 <jedbrown> gwern: postmaster installed after coaxing cabal through dependencies.  ZFS installed cleanly, with *lots* of compiler warnings.
10:33:37 <gwern> jedbrown: not as many as before I worked on it :) but cabal-install didn't grab the other dependencies from hackage? I went to a lot of trouble to get them all up there
10:33:51 <gwern> *the former remark about zfs, the latter about postmaster
10:34:19 <jedbrown> gwern: Yeah, the dependencies were all there, but cabal doesn't try them in the right order.
10:34:34 <oerjan> gwern: you misspelled it
10:34:44 <gwern> oerjan: d'oh!
10:34:53 <gwern> @tell shachaf Yeah, I tried that email address for Gordon since he was the contact listed for LOLITA, but I wuz bounced
10:34:54 <lambdabot> Consider it noted.
10:34:57 * gwern sighs
10:35:18 <gwern> jedbrown: how interesting. what did it try to do wrongly?
10:36:17 <jedbrown> gwern: The last patch in my cabal is Jan 19, so this may have changed.
10:37:51 * gwern dunno how old my cabal-install is
10:43:02 <FordCortina> im trying to run a port of the first nehe tutorial but I get a " unknown symbol `OpenGLzm2zi2zi1zi1_GraphicsziRenderingziOpenGLziGLUziErrorsInternal_a53_info' " error.
10:43:03 <byorgey> argh
10:43:13 * byorgey bashes head against GADTs with phantom types
10:43:18 <dcoutts> jedbrown: what was the problem? cabal-install installing deps in the wrong order?
10:43:19 <Zao> FordCortina: Throw --make at ghc and see if it links the right libs?
10:43:19 <FordCortina> full error and code im trying to run here http://paste.ubuntu-nl.org/55632/
10:43:56 <Zao> Oh, ghci. I don't know if it's supposed to work there.
10:44:44 <jedbrown> dcoutts: Yes, same as we discussed some days ago.  I wrote a ticket for it then.  No big deal since I could just run it again, but some day...
10:46:15 <dcoutts> jedbrown: was that the one about 'cabal upgrade' not considering order?
10:46:23 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/226
10:46:24 <FordCortina> Zao: I've tried in ghc too
10:46:26 <lambdabot> Title: #226 (Cabal install should upgrade in the correct order.) - Hackage - Trac
10:46:46 <FordCortina> Zao: i tried the --make switch and got another error
10:46:53 <FordCortina> Zao: undefined reference to `OpenGLzm2zi2zi1zi1_GraphicsziRenderingziOpenGLziGLUziErrorsInternal_a53_info'
10:47:01 <jedbrown> dcoutts: Yeah, same issue it seems.
10:47:21 <FordCortina> Zao: full error here http://paste.ubuntu-nl.org/55633/
10:47:33 <FordCortina> (after the original error)
10:47:49 <dcoutts> jedbrown: only if it's 'upgrade', ordinary install should be correct.
10:48:13 <int-e> FordCortina: That's the same error again. Did you recompile OpenGL after compiling GLUT? This error is odd.
10:48:15 <sethk> hello, all.  I'm using 6.8.2, and ghc tells me "use -frecord-puns to allow".  However, ghc then says "unrecognized flags: -frecord-puns"
10:48:47 <gwern> lovely error
10:49:07 <FordCortina> int-e: im going to rebuild, OpenGL and then GLUT in that order
10:49:11 <hpaste>  jedbrown pasted "cabal install postmaster" at http://hpaste.org/5600
10:49:15 <mrd> sethk: might be under -X now
10:49:17 <oerjan> sethk: try -XRecordPuns i think
10:49:23 <mrd> sethk: and file a bug
10:49:24 <JohnMeacham> does the bytestring 'getContents' close the file afterwards?
10:49:30 <mrd> JohnMeacham: it should
10:49:36 <sethk> mrd, oerjan, thanks, I'll try it and I'll also file the bug
10:49:46 <dcoutts> JohnMeacham: if you're using a sufficiently recent version, yes.
10:49:57 <JohnMeacham> hm... I was hoping not. I want to do a getcontents then absolute seek back to the beginning.
10:50:20 <gwern> jedbrown: you do have openssl instaleld right?
10:50:26 <int-e> FordCortina: oh and for what it's worth, the code works here (ignoring the minor detail that it ends ghci as well when you close the window)
10:50:33 <jedbrown> dcoutts: Oh.  dcoutts I proceeded to install just hopenssl, then hsdns, then postmaster worked fine.
10:51:28 <dcoutts> JohnMeacham: strict ByteString hGetContents gets the whole thing in one go. lazy ByteString reads on demand, but you cannot seek or it'll break (it should semi-close the Handle but it doesn't yet)
10:51:37 <jedbrown> gwern: Yes, and it installed fine when I just did `cabal install hopenssl' immediately following my paste.
10:51:52 <dcoutts> jedbrown: so this is unrelated to 'upgrade' ?
10:52:18 <gwern> alright then. so no fault in the packages themselves
10:52:39 <gwern> 'the fault, dear cabal, lies not in the packages but ourselves'
10:53:14 <jedbrown> dcoutts: I don't know the internals so I don't know if the same code causes/could fix both problems.  The symptoms and resolution are the same.
10:53:26 <dcoutts> jedbrown: I don't understand that paste, I don't see any error message as to why any of the packages failed to compile
10:53:47 <jedbrown> dcoutts: Yes, that confused me too.
10:53:52 <dcoutts> jedbrown: upgrade is totally unrelated. It uses a different (broken) code path.
10:53:56 <Deewiant> Regarding bytestrings: since everybody thinks they're all the rage, is it likely they'll ever replace String in the core
10:54:20 <dcoutts> jedbrown: so I have no explanation, if you have time it'd be great to try and figure out what is going on.
10:54:21 <gwern> Deewiant: maybe, if list operations ever work perfectly and they handle Unicode right by default
10:54:28 <FordCortina> int-e: just rebuilt and installed both OpenGL and GLUT. I'm still getting the same error. I even rebuilt and installed OpenGL after the GLUT. :(
10:54:47 <gwern> Deewiant: but that's either unlikely or a lng way off
10:54:51 <Deewiant> gwern: how don't those work currently
10:54:53 <gwern> bytestrings are not just fast strings
10:55:02 <dcoutts> jedbrown: hmm, looks like download failed actually.
10:55:04 <FordCortina> int-e: could it be that the native library isn't recent enough?
10:55:17 <Deewiant> gwern: the problem is that that's all I hear about them :-)
10:55:20 <gwern> they are Word8s, for example, and a word8 can't hold a full unicode codepoint, as I understand it
10:55:20 <dcoutts> jedbrown: see how it downloads three things one after the other? That's not normal.
10:56:07 <Deewiant> gwern: true, but I don't think that matters much: if they're UTF-8 you can make a code point indexing function (if you ever need such)
10:56:20 <gwern> Deewiant: and bytestrings aren't necessarily 'lists'; you can have infinite strings, but I'm not sure even lazy bytestrings allow the full panoply of list and inifnite stuff (ie 'string = cycle "foo"; take 100 $ string' or whatever)
10:56:21 <jedbrown> dcoutts: I think download worked though, because cabal said they were cached when I installed individually.
10:56:40 <hpaste>  byorgey pasted "problem with GADTs and phantom types" at http://hpaste.org/5602
10:56:53 <Deewiant> gwern: I see
10:57:14 <dcoutts> jedbrown: well something went wrong between downloading and getting on with building.
10:58:18 <FordCortina> i think my OpenGL problem might be more general, I just tried running a java program that uses OpenGL and it took out my Xserver. Wierd... it was fine last week... Oh well I guess im one step closer
10:59:12 <pchiusano> hi, I was wondering how I would express a generic "leaf traversal function", I think the signature would be: leaves :: e -> (f e -> [f e]) -> (f e -> e)
10:59:36 <jedbrown> dcoutts: I should start running cabal with high verbosity by default.  It would be neat if it wrote a log somewhere.
11:00:10 <pchiusano> oop, sorry, should be: leaves :: (f e) -> (f e -> [f e]) -> (f e -> e) -> [e]
11:00:44 <pchiusano> so first param is a root element, second param is a function mapping nodes to a list of children nodes, third param is a function which extracts a value of type e from a node
11:01:08 <pchiusano> except, (f e) is not a valid type, right?
11:01:51 <Deewiant> not unless you specify what f means there
11:01:51 <sethk> I have a type, defined with data, called "TargetDescriptor" which has (among others) a field named "name" of type String.  When I use td { name } (where td is type TargetDescriptor), the compiler complains "Couldn't match expected type String against inferred type TargetDescriptor -> String.  What am I doing wrong?
11:02:00 <oerjan> :t Data.Foldable.foldMap
11:02:04 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
11:02:35 <gwern> Deewiant: I don't entirely see myself (if strictness can be analyzed and added in, why can't stuff like Int/Integer String/ByteString?) but I trust those who wrote the thing when they tell me swapping bytestring for string internally probably isn'tgoing to happen
11:03:04 <oerjan> pchiusano: that resembles Data.Foldable somewhat
11:03:26 <byorgey> sethk: if you just want to extract the name from td, you should just say  name td .
11:03:48 <sethk> byorgey, ok.
11:04:12 <byorgey> sethk: the record syntax is for pattern matching, in which case you would bind another name to it :  theName (TargetDescriptor{name=n}) = n
11:04:39 <byorgey> sethk: it is a little confusing.
11:04:42 <sethk> byorgey, ok, thanks
11:04:56 <oerjan> pchiusano: alternativel, f e _is_ a legal type, but i think you don't actually need to split it like that:
11:04:59 <oerjan> *ly
11:05:04 <hpaste>  (anonymous) pasted "leaves function" at http://hpaste.org/5603
11:05:22 <oerjan> f -> (f -> [f]) -> (f -> e) -> e should be enough
11:06:08 <pchiusano> oerjan, ya, that works, but it is too permissive
11:06:37 <EvilTerran> ?djinn f -> (f -> [f]) -> (f -> e) -> e
11:06:38 <lambdabot> f a _ b = b a
11:06:40 <Deewiant> pchiusano: what do you mean by f there
11:06:44 <EvilTerran> huh
11:07:11 <monochrom> heh
11:07:14 <pchiusano> by (f a) I mean that f is a type constructor
11:07:22 <Deewiant> any type constructor?
11:07:26 <pchiusano> yeah
11:07:41 <EvilTerran> data Foo a = Bar Int Char Bool
11:07:46 <oerjan> pchiusano: but any function you define with f e is probably going to work with just f as well
11:08:26 <EvilTerran> type Foo a = Int -- even
11:08:44 <EvilTerran> the fact that a type is parameterised doesn't tell you that it's necessarily a container of that type
11:09:10 <monochrom> @src Reader
11:09:10 <lambdabot> Source not found.
11:09:21 <oerjan> oh it cannot be a type synonym, those can only be used fully expanded
11:09:34 <EvilTerran> the normal thing to do would be to have some typeclass that enables that function
11:09:37 <EvilTerran> eg, Foldable
11:09:51 <pchiusano> so the "children" function would be in the typeclass
11:09:58 <oerjan> newtype Reader r a = Reader { runReader :: r -> a }
11:10:00 <pchiusano> and the "extractor" function
11:10:26 <EvilTerran> ?pl foldr (++) [] -- incidentally
11:10:26 <lambdabot> foldr (++) []
11:10:29 <EvilTerran> huh.
11:10:29 <monochrom> Reader is an example of very strange use of parameters.
11:10:32 <EvilTerran> "concat"
11:10:58 <pchiusano> basically, you just use typeclasses if you need to abstract over the type constructors?
11:11:07 <EvilTerran> not really
11:11:08 <Deewiant> @pl foldr (:) []
11:11:08 <lambdabot> foldr (:) []
11:11:10 <EvilTerran> but kinda
11:11:11 <Deewiant> "id"
11:11:24 <EvilTerran> @. hoogle type foldr (:) []
11:11:38 <lambdabot> Did you mean: Forall A. [a] -> [a]
11:11:39 <lambdabot> Prelude.repeat :: a -> [a]
11:11:41 <lambdabot> Plugin `compose' failed with: thread killed
11:11:48 <EvilTerran> oopsie
11:12:07 <pchiusano> incidentally, how come I am not allowed to just use (f a) directly?
11:12:16 <EvilTerran> ... in what way?
11:12:28 <EvilTerran> you can't tell *anything* about a value of type "f a" in general
11:12:40 <oerjan> :t let leaves f ch m = map m (f : concatMap leaves (ch f)) in leaves
11:12:41 <lambdabot>     Couldn't match expected type `[a]'
11:12:41 <lambdabot>            against inferred type `t1 -> (a -> b) -> t'
11:12:41 <lambdabot>     Probable cause: `leaves' is applied to too few arguments
11:12:45 <oerjan> darn
11:13:16 <oerjan> :t let leaves ch m f = map m (f : concatMap leaves ch m (ch f)) in leaves
11:13:17 <lambdabot>     Couldn't match expected type `[b]'
11:13:17 <lambdabot>            against inferred type `(a -> b1) -> a -> t'
11:13:17 <lambdabot>     Probable cause: `leaves' is applied to too few arguments
11:13:28 <oerjan> :t let leaves ch m f = map m (f : concatMap (leaves ch m) (ch f)) in leaves
11:13:29 <lambdabot> forall b. (b -> [b]) -> (b -> b) -> b -> [b]
11:13:29 <pchiusano> EvilTerran: but I don't care if I can tell anything about the type (f a)
11:13:42 <monochrom> I think it's more productive to show your code, and then it will become clear why certain type signatures are valid / invalid.
11:13:45 <EvilTerran> so why make it "f a"? why not make it just "b"?
11:13:53 <oerjan> oh no
11:14:39 <oerjan> pchiusano: f a is a perfectly legal type afaik
11:14:41 <pchiusano> EvilTerran: that is not the same signature as what I want to write
11:14:57 * EvilTerran throws up his hands
11:14:59 <EvilTerran> X and Y problem.
11:15:04 <pchiusano> oerjan: really?
11:15:08 <Deewiant> @ty id :: (f a) -> (f a)
11:15:09 <lambdabot> forall (f :: * -> *) a. f a -> f a
11:15:25 <Deewiant> might require language extensions
11:15:29 <Deewiant> or then not
11:15:32 <nburlett> hey all, where's the instance for Monad (Error String) ?
11:15:37 <nburlett> my code suddenly stopped compiling
11:15:41 <EvilTerran> it's a perfectly legal type, but it's really not that interesting
11:15:46 <nburlett> err Monad (Either String)
11:16:02 <Deewiant> nburlett: probably where Either is defined
11:16:12 <EvilTerran> unless you're using the same tycon with different parameter, say; that might be occasionally interesting
11:16:13 <oerjan> nburlett: Control.Monad.Error
11:16:25 <monochrom> Control.Monad.Error
11:16:31 <oerjan> or .Instances
11:16:42 <monochrom> Likely not in .Instances
11:16:49 <EvilTerran> but you'll almost certainly want some class constraint on the tycon. otherwise there's very little point in having it be "f a" rather than just "b"
11:16:50 <pchiusano> EvilTerran: ya!
11:16:55 <oerjan> it's not?
11:17:23 <oerjan> hm, just the Functor is there
11:17:29 <pchiusano> "unless you're using the same tycon with different parameter, say; that might be occasionally interesting"
11:17:37 <nburlett> Control.Monad.Error is part of haskell-mtl?
11:17:43 <oerjan> probably because the Monad requires the Error class
11:17:49 <oerjan> nburlett: yes
11:18:02 <sethk> byorgey, if the field variable name in my type td has type String, shouldn't   (name td) have type String?  The compiler says not, but I'm not sure why
11:18:05 <nburlett> weird
11:18:21 <byorgey> sethk: yes, it should
11:18:33 <byorgey> sethk: maybe paste what you have on hpaste.org?
11:18:37 <sethk> byorgey, maybe I have an error somewhere else messing up the type inference
11:18:41 <sethk> byorgey, OK, I"ll do that.
11:18:57 <EvilTerran> ":: (f e) -> (f e -> [f e]) -> (f e -> e) -> [e]"; so, a value of some type, some way of getting at the children, and a mapping function for leaves, right?
11:19:07 <oerjan> Deewiant: it cannot be with Either because Either is in the Prelude and the instance is not H98
11:19:19 <pchiusano> EvilTerran, yes
11:19:27 <Deewiant> oerjan: d'oh
11:19:30 <EvilTerran> you need some way of telling leaves and non-leaves apart, unless you want to pass everything to the mapping functio
11:19:45 <pchiusano> leaves return an empty list of children
11:20:37 <oerjan> pchiusano: oh so the final map should only be applied to leaves, not to other nodes?
11:20:43 <pchiusano> right
11:21:17 <oerjan> hm in any case it still makes sense to split it - one function to get the leaves without mapping, then an ordinary map
11:21:25 <hpaste>  sethk pasted "(no title)" at http://hpaste.org/5604
11:21:44 <sethk> byorgey, I pasted
11:21:56 <pchiusano> oerjan: hmm, that is interesting
11:21:58 <EvilTerran> ?type let traverse children mapping x = case children x of [] -> [mapping x]; xs -> concatMap (traverse children mapping) xs in traverse
11:21:59 <lambdabot> forall a t. (a -> [a]) -> (a -> t) -> a -> [t]
11:22:21 <EvilTerran> you *do not need* a parameterised type
11:22:28 <oerjan> :t let leaves ch f = case ch f of [] -> f; _ -> concatMap (leaves ch) f in \f ch m -> map m (leaves ch f) -- maybe i get it right at last
11:22:29 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
11:22:29 <lambdabot>       Expected type: [[b]]
11:22:29 <lambdabot>       Inferred type: [b]
11:22:34 <oerjan> ARGH!
11:22:40 <pchiusano> EvilTerran: I wonder if that is always true..
11:22:44 <EvilTerran> why not let it work over "data IntTree = Branch IntTree IntTree | Leaf Int"?
11:23:00 <byorgey> sethk: you want name desc instead of desc name
11:23:11 <sethk> byorgey, ah, thanks.
11:23:32 <EvilTerran> "container type" is a completely seperate concept to "parameterised type"
11:23:42 <dcoutts_> @seen sioraiocht
11:23:42 <lambdabot> sioraiocht is in #haskell-blah, #scala and #haskell. I last heard sioraiocht speak 7h 59m 38s ago.
11:24:51 <oerjan> :t let leaves ch f = case ch f of [] -> [f]; _ -> concatMap (leaves ch) f in \f ch m -> map m (leaves ch f) -- maybe i get it right at last
11:24:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
11:24:52 <lambdabot>       Expected type: [t]
11:24:52 <lambdabot>       Inferred type: t
11:26:05 <basti_> Hi people, i'm searching for the example about esoteric ways to code the faculty function in haskell
11:26:23 <basti_> it ended with a type system computation
11:26:23 <oerjan> :t let leaves ch f = case ch f of [] -> [f]; fs -> concatMap (leaves ch) fs in leaves
11:26:24 <lambdabot> forall t. (t -> [t]) -> t -> [t]
11:26:36 <basti_> and contained examples like "leaning left" and "leaning right"
11:26:44 <basti_> anybody know this one?
11:27:02 <pchiusano> so, to summarize: 1) For this example, you don't really need to abstract over type constructors, 2) If you did need to, you'd use typeclasses, or just decompose the function into (map . leaves)
11:27:28 <mauke> @where evolution
11:27:29 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:27:41 <mauke> basti_: ^
11:27:41 <basti_> mauke: thanks a lot
11:27:43 <pchiusano> ... where map and leaves each have, uh, first-order types?
11:27:49 <monochrom> faculty function?
11:28:14 <shap1> As opposed to a faculty procedure?
11:28:45 <monochrom> @quote shapl
11:28:45 <lambdabot> No quotes match. It can only be attributed to human error.
11:29:04 <byorgey> you mean factorial function?
11:29:08 <oerjan> pchiusano: basically the only reason to use type constructors is to bake the traversal into an instance, which is essentially what Foldable does
11:29:47 <pchiusano> oerjan: "bake the traversal into an instance"?
11:29:56 <basti_> byorgey: yep
11:30:41 <monochrom> this is the second time someone says "faculty function". is it a new cult?
11:31:04 * EvilTerran puts on a V mask and pickets basti_
11:31:06 <basti_> no it is a germanism
11:31:06 <sethk> I think they will bake the faculty into instances
11:31:10 <Deewiant> no, it's a facult
11:31:20 <oerjan> pchiusano: Foldable contains methods for combining the values found in an arbitrary container type constructor
11:31:23 <EvilTerran> ;)
11:31:31 <monochrom> hahahaha
11:31:52 <lament> what do you know, at my university the faculty is always baked
11:32:15 <oerjan> monochrom: factorial is called something resembling "faculty" in some other languages
11:32:21 <FordCortina> ok, my OpenGL works fine with java now. but I'm still having the same linking error with ghc. http://paste.ubuntu-nl.org/55633/
11:32:26 <oerjan> (including norwegian)
11:32:32 <pchiusano> @src Foldable
11:32:32 <lambdabot> Source not found. It can only be attributed to human error.
11:32:47 <monochrom> I hope your university's president/director/principle/chancellor is named Baker. :)
11:33:49 <lament> no, it's just on the west coast
11:34:06 <lament> (kidding... i've never seen any profs smoke pot (though i'm sure some do))
11:34:14 <oerjan> pchiusano: it's a bit long, although the essential functions are foldMap / foldr
11:34:20 <oerjan> :t foldMap
11:34:32 <pchiusano> oerjan: ya, I am looking at it now
11:34:36 <lambdabot> thread killed
11:34:46 <sethk> FordCortina, those are c++ symbols.  You can get them into human readable form using c++filt
11:37:49 <monochrom> basti_ is looking for http://www.willamette.edu/~fruehr/haskell/evolution.html
11:37:50 <lambdabot> Title: The Evolution of a Haskell Programmer
11:38:06 <EvilTerran> we had that a minute ago, i'm afraid :)
11:38:10 <monochrom> and I found it after conveniently visiting http://www.haskell.org/haskellwiki/Humor
11:38:11 <lambdabot> Title: Humor - HaskellWiki
11:38:20 <EvilTerran> [19:27] <mauke> @where evolution
11:38:26 <monochrom> indeed.
11:39:40 <basti_> *nods*
11:39:40 <oerjan> @where humor
11:39:40 <lambdabot> I know nothing about humor.
11:39:56 <oerjan> what a horrible fate
11:40:09 <oerjan> @where+ humor http://www.haskell.org/haskellwiki/Humor
11:40:09 <lambdabot> It is forever etched in my memory.
11:40:13 <lament> @where the meaning of life
11:40:13 <lambdabot> I know nothing about the.
11:42:35 <ToRA> byorgey: did you solve your GADT/phantom type problem?
11:42:54 <byorgey> ToRA: no, not yet
11:43:11 <hpaste>  ToRA annotated "problem with GADTs and phantom types" with "is this cheating?" at http://hpaste.org/5602#a1
11:43:28 <ToRA> byorgey: does that help, or did you want to avoid resorting to that kind of approach?
11:43:55 <vininim> I feel dumb for not geting all the joke in the fac styles :/
11:44:13 <byorgey> ToRA: at this point I'm open to resorting to whatever works =)
11:44:33 <byorgey> ToRA: hm, but that's a fairly nice solution I think
11:45:08 <byorgey> ToRA: this avoids having to wrap everything in an existential type, which I think would work too but would be annoying
11:45:14 <dolio> vininim: We could probably put together a reading list for you. :)
11:45:23 <byorgey> ToRA++
11:45:47 <ToRA> :)
11:45:53 <FordCortina> sethk: no matter what i seem to do c++filt seems to keep printing out whatever I give it...
11:46:17 <sethk> FordCortina, hmm.
11:46:20 <vininim> dolio: do want
11:46:21 <FordCortina> eg. i put in "c++filt OpenGLzm2zi2zi1zi1_GraphicsziRenderingziOpenGLziGLUziErrorsInternal_a53_closure"
11:46:39 <FordCortina> or just parts of it... im not sure what im doing
11:46:49 <sethk> FordCortina, all of it is what you want.
11:46:50 <vininim> (but the comments in the end of the page are at least a start)
11:46:53 <Zao> FordCortina: c++filt echo OmgWtfBbq
11:47:10 <Zao> It takes a command with arguments, and mangles the output.
11:47:25 <sethk> Zao, demangles, and thanks, I forgot that.
11:48:15 <Taejo> I have a function, update, that takes the state of the system and an input, and gives the new state as output... if I have the list of inputs from first to last, do I want scanl or scanr to calculate which states the system goes through?
11:48:16 <dolio> vininim: Which ones aren't you familiar with?
11:50:37 <EvilTerran> Taejo, given [i0, i1 ... iN], you want ((...((state0 `f` i0) `f` i1) `f` ...) `f` iN), right?
11:50:56 <EvilTerran> that'd be foldl/scanl
11:51:08 <Taejo> EvilTerran: I think so...
11:51:36 <EvilTerran> well, you want to do something with the first element, then the first two, then the first three, etc... that's scanl
11:51:44 <Taejo> I'm still horribly confused; I'm *sure* I want foldl/scanl, but foldr/scanr are giving the right answer
11:52:22 <FordCortina> setk: could I be having problems with GLUT because I am using freeglut?
11:52:34 <idnar> if the function is associative, I believe l/r won't affect the result
11:52:34 <FordCortina> sethk:.
11:52:36 <vininim> I don't get the Peano reference (seems to be a "lambda numeral encoding" with types), cata/ana morphisms, mostly that =)
11:52:51 <sethk> FordCortina, it's not impossible, but I don't think it's likely.  I want the demanged names so we can grep the source for them.
11:53:11 <Taejo> idnar: I know, but my update function is clearly not associative. I don't know if it should be
11:53:34 <dolio> vininim: For cata/ana stuff, look for Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire.
11:53:55 <dolio> And Bananas in Space is a followup.
11:54:01 <EvilTerran> hehe
11:54:18 <Taejo> the algorithm should be "streaming" -- i.e., if you only read the first n elements of the answer, only the first 10 elements of the input get read... which is how scanl behaves
11:56:24 <paolino> :t take 4  $ foldr (:) [] [1..]
11:56:26 <lambdabot> forall a. (Enum a, Num a) => [a]
11:57:05 <dolio> vininim: Peano arithmetic is just a way of going about defining the natural numbers and operations on them in terms of 0 and a successor. Named after some guy with a last name of Peano.
11:57:20 <paolino> > take 4 $ foldr (:) [] [1..]
11:57:22 <lambdabot>  [1,2,3,4]
11:57:39 <vininim> heh, I knew it except the name
11:57:43 <glen_quagmire> fmap id = id -- what does this mean?
11:58:04 <glen_quagmire> > fmap id 1
11:58:05 <lambdabot>   add an instance declaration for (Num (f a))
11:58:11 <Deewiant> @ty fmap id
11:58:12 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
11:58:29 <mauke> > (fmap id "foo", id "foo")
11:58:29 <glen_quagmire> > fmap id (Just 1)
11:58:33 <Taejo> fmap id == id where fmap id is defined
11:58:41 <lambdabot>  ("foo","foo")
11:58:41 <lambdabot>  Just 1
11:58:42 <EvilTerran> glen_quagmire, it means that, if f doesn't affect its argument, neither does fmap f
11:59:04 <EvilTerran> glen_quagmire, it's a way of capturing the concept that fmap is a "structure-preserving map"
11:59:25 <Taejo> EvilTerran: *part* of the way, surely?
11:59:29 <dolio> vininim: I suppose the really interesting one that involves Peano numbers is the one that does all the calculation in the type system, by using type classes and functional dependencies like a logic programming language.
11:59:50 <EvilTerran> as fmap can't tell if its parameter is the identity function or otherwise, if fmap id = id, then fmap f must retain the "shape" of the thing being fmapped ove
11:59:57 <EvilTerran> regardless of the definition of f
12:00:13 <Taejo> EvilTerran: true, I was thinking of identity elements, not identity functions
12:00:42 <EvilTerran> ... what's the other functor axiom again? fmap f . fmap g = fmap (f.g)?
12:00:56 <mauke> @free map
12:00:57 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
12:01:13 <EvilTerran> @free fmap
12:01:14 <lambdabot> Expected variable or '.'
12:01:19 <EvilTerran> huh
12:01:50 <glen_quagmire> > fmap (id . const) (Just 1)
12:01:51 <lambdabot>  Add a type signature
12:01:55 <Corun> @pl \x y -> x * x + y * y
12:01:56 <lambdabot> (. join (*)) . (+) . join (*)
12:02:01 <Corun> Hehe
12:02:16 <EvilTerran> Corun, (+) `on` (^2)
12:02:29 <Deewiant> @pl \x y -> x^2 + y^2
12:02:29 <lambdabot> (. (^ 2)) . (+) . (^ 2)
12:02:40 <Corun> I just wanted to try out @pl :-)
12:02:43 <EvilTerran> pl doesn't know about `on`
12:02:53 <paolino> :t on
12:02:54 <lambdabot> Not in scope: `on'
12:03:03 <EvilTerran> it's in 6.8
12:03:22 <Deewiant> @version
12:03:22 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
12:03:23 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:03:51 <paolino> @hoogle on
12:03:52 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:03:52 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
12:03:52 <lambdabot> Data.Function :: module
12:04:06 <byorgey> \bot is built with 6.8.2 now!?
12:04:29 * byorgey does the happy lambdabot dance
12:04:51 <glen_quagmire> > 1 + (read "08")
12:05:06 <lambdabot>  9
12:05:28 <Corun> @pl \x -> fix ((0:) . scanl (+) x)
12:05:28 <lambdabot> fix . ((0 :) .) . scanl (+)
12:05:36 <Corun> > fix . ((0 :) .) . scanl (+) 1
12:05:37 <lambdabot>  Couldn't match expected type `a -> [t]'
12:05:41 <Corun> > (fix . ((0 :) .) . scanl (+)) 1
12:05:42 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:05:52 <Corun> Boring
12:05:55 <Corun> It didn't change it :/
12:06:01 <hpaste>  byorgey pasted "More GADT/phantom type woes" at http://hpaste.org/5605
12:07:19 <Taejo> Anybody here know Viterbi's algorithm and willing to help a noob?
12:09:23 <FordCortina> sethk: i tried putting in the whole output into c++filt. and it just gives me what I put in. my bash is not great so I did it this way: "ghc lesson01.hs --make 2> crud" ... and then "cat crud | c++filt"
12:09:58 <sethk> FordCortina, I would edit the file and take out everything except the mangled symbol.
12:10:04 <byorgey> Taejo: what's Viterbi's algorithm?
12:10:17 <Saizan> byorgey: why p y z should match with p x w?
12:10:47 <Taejo> byorgey: find the most likely state-sequence given the corresponding observation-sequence in a hidden Markov model
12:11:20 <byorgey> Saizan: it doesn't, of course
12:11:56 <Taejo> byorgey: I've been looking at my code for ages and can't find the problem
12:12:17 <Saizan> byorgey: i think you want w to be existentially quantified
12:12:45 <Taejo> Haskell spoils you... you get so used to having the compiler find your misthinks that you forget how to find them yourself
12:12:48 <byorgey> Saizan: hm, how would I do that?
12:12:55 <byorgey> Taejo: hehe
12:13:33 <gour> @seen ndm
12:13:33 <lambdabot> I haven't seen ndm.
12:15:54 <Saizan> byorgey: a way is to have commute :: (p x y, p y z) -> (forall w. (p x w, p w z) -> r) -> r, or use an existential like data Bar p x z = forall w. Bar (p x w) (p w z), but maybe the nicest solution is to make w a parameter of Patch?
12:17:57 <byorgey> Saizan: oh!  I already have an existential like data Bar ..., it is called Seq =)
12:18:17 * byorgey tries that
12:18:25 <Saizan> yeah :)
12:19:14 <Saizan> mmh, i should say that i don't get what commute is supposed to do
12:20:09 <Taejo> :r
12:20:13 <Taejo> whoops
12:21:00 <byorgey> Saizan: well, this particular example doesn't do anything, it's just a stripped-down version of what I'm really working on
12:21:29 <byorgey> Saizan: which has to do with patch theory for collaborative editors
12:21:46 <byorgey> whee, I made Simon's brain explode =)
12:22:17 <Saizan> heh switch to case instead of let/where :)
12:23:41 <nominolo> byorgey: do you happen to have a mac?
12:23:59 <byorgey> nominolo: no, why?
12:24:05 <shapr> gwern: hah, got your messages.
12:24:18 <shapr> gwern: shapr == guy with unicycle, started #haskell
12:24:19 <nominolo> byorgey: because then we could have done some experiments with subethaedit
12:24:29 <nominolo> byorgey: this implements undo
12:24:33 <nominolo> (and redo)
12:24:38 <byorgey> nominolo: ah, cool
12:24:46 <nominolo> byorgey: but it's mac-only
12:24:52 <gwern> shapr: heck like I'd know that
12:24:58 <nominolo> and i can't fake two instances
12:24:58 <byorgey> nominolo: is it per-user undo/redo?  or only global undo/redo?
12:25:11 <nominolo> byorgey: i can't test that in single-user mode ;)
12:25:19 <byorgey> nominolo: right, fair enough. =)
12:25:45 <shapr> gwern: I dunno, I tend to remember stuff I learn about people.
12:26:11 <gidyn> What's happened to http://sequence.complete.org/ ? Seems to have been offline for a few days (last seen 5th).
12:26:12 <nominolo> maybe i can try bringert, i know he has a mac
12:26:22 <shapr> gidyn: ask cosmicray
12:26:25 <nominolo> and i could just walk over to his office
12:26:30 <shapr> nominolo: too easy!
12:26:41 <byorgey> nominolo: cool, let me know what you find out
12:26:55 <gwern> shapr: alas I don't have a good memory for that sort of thing. the only thing I remember about shacaf is that he's male and the name means pigeon or something in Hebrew
12:27:16 <glen_quagmire> how do you read fmap?  eff map?
12:27:19 <shapr> shapr means synethesist
12:27:24 <glen_quagmire> or is it function map?
12:27:48 <byorgey> glen_quagmire: I usually say "eff map"
12:28:14 <nominolo> eff map
12:28:16 <shapr> me too
12:28:30 <glen_quagmire> but f in fmap stands for function (maybe functor?)
12:28:33 <shapr> But mostly I don't say anything from irc out loud, so I don't think about it.
12:28:39 <nominolo> though it should really be called just "map"
12:28:41 <Saizan> glen_quagmire: functor
12:29:09 <glen_quagmire> oh i see
12:30:44 <byorgey> shapr: the other day I was telling my wife a little about what I had been working on and realized I wasn't sure how to pronounce 'Cabal'. =)
12:31:44 <ricky_clarkson> I was DJing and saw a song with Dale in the name and thought it said Cale.
12:32:03 <nominolo> byorgey: Kay-bell
12:32:20 <dolio> Really?
12:32:21 <nominolo> or Kah-baahl
12:32:38 <ricky_clarkson> It's pronounced Coh-bol
12:32:51 <Deewiant> not like "cable" or "cabble" or "cobalt"
12:32:56 <shapr> cah-ball ?
12:32:58 <byorgey> nominolo: haha, right =P
12:33:21 <nominolo> http://www.merriam-webster.com/dictionary/cabal
12:33:21 <dolio> I'd go with the kah-baahl.
12:33:21 <lambdabot> Title: cabal - Definition from the Merriam-Webster Online Dictionary
12:33:42 <shapr> Lucky for me, I was sleeping in the same room as the guy who decided to make Cabal a reality when he decided to do so.
12:33:51 <nominolo> bringert pronounces it like "kah-'baahl'
12:33:59 <nominolo> but he's swedish
12:34:03 <byorgey> shapr: who's that?
12:34:21 <shapr> byorgey: SyntaxNinja
12:34:22 <nominolo> syntaxninja
12:34:42 <Deewiant> kÉËbÃ¦É«
12:34:46 * dcoutts_ invites people to do some Cabal hacking...
12:34:48 <Deewiant> for those that speak IPA
12:34:57 <glen_quagmire> cabal is pronounced as kabb el
12:35:08 <monochrom> Kabul
12:35:09 <Deewiant> nope
12:35:10 <glen_quagmire> or ku bell
12:35:11 <dcoutts_> eg, cabal list should list installed packages too, nice easy feature to implement...
12:35:13 <byorgey> I see. and does syntaxninja have a name IRL that he/she does not mind being associated with his/her IRC nick?
12:35:15 <Deewiant> cow bell
12:35:27 <ricky_clarkson> Cobble.
12:35:33 <glen_quagmire> gaah baal
12:36:02 <glen_quagmire> lambda is pronounced as lamb  da
12:36:04 <nominolo> there're obviously two variants
12:36:09 <ricky_clarkson> I'm Kay Ball and I invented Cabal, and I pronounce it Keeaaagh Bull.
12:36:11 <nominolo> no, lamda
12:36:29 <mahogny> lambada
12:36:31 <monochrom> cable
12:36:35 <glen_quagmire> lay mda
12:36:37 <Deewiant> ÎÎ¬Î¼Î²Î´Î±
12:36:39 <byorgey> right, the b is silent in lamb =)
12:36:48 <shapr> byorgey: Isaac Jones
12:36:54 <Deewiant> lamÃ°a
12:37:10 <nominolo> @losers
12:37:11 <lambdabot> Maximum users seen in #haskell: 463, currently: 458 (98.9%), active: 30 (6.6%)
12:37:25 <glen_quagmire> lambda -> lamb da -> lamb, the -> the lamb .. haskell is all about chrsitianity
12:37:27 <byorgey> shapr: ah, right!  that would explain why lots of tickets on the Cabal trac are owned by 'ijones' =)
12:38:15 <nominolo> Isaac Potoczny Jones
12:38:27 <monochrom> Agnus Dei.
12:38:45 <gwern> anyone built wxwidgets from darcs lately?
12:38:50 <shapr> byorgey: seems likely
12:39:00 <shapr> nominolo: Can you pronounce potoczny for me?
12:39:19 <monochrom> um, who takes away the type errors of the world? :)
12:39:19 <vincenz> glen_quagmire: it's about the lambada, but they mistyped an a
12:39:29 <shapr> Anyone in the Boston area interested in a Haskell Users Group?
12:39:34 <shapr> I should post on haskell-cafe.
12:39:56 <nominolo> iirc, it's polish. so poto"g"ny  with the "g" like in "general"
12:40:01 <nominolo> well, kind of
12:40:15 <mrd> in japan there were random chicks with signs: "free HUGs!"
12:40:23 <wagle> someone killed my fonts!
12:40:36 * wagle looks around accusingly
12:40:54 <nominolo> mrd: i've seen this on flickr photos from russia
12:41:12 <gwern> mrd: sure. you see that at colleges sometimes, guys with signs saying free hugs
12:41:18 <gwern> theyt're generally pretty good huggers
12:41:35 <byorgey> \o/  it compiles!
12:41:43 <byorgey> Saizan++
12:41:59 <gwern> what compiles?
12:42:57 <glen_quagmire> > (join . join) [[[1,2,3], [4], []], [[5,6]]]
12:43:07 <hpaste>  byorgey annotated "More GADT/phantom type woes" with "it compiles!" at http://hpaste.org/5605#a1
12:43:09 <lambdabot>  [1,2,3,4,5,6]
12:43:37 <nominolo> mrd: http://static.diary.ru/userdir/9/1/5/9/91591/23199927.jpg
12:43:52 <mrd> i don't think they were advertising haskell user groups though
12:44:04 <nominolo> most certainly not
12:47:09 <monochrom> oh yeah, I now remember there is a "free hugs" movement in east asia. they say: people are too unfriendly, we need to revert that.
12:47:12 <glen_quagmire> is there a function that composies n times?
12:47:22 <glen_quagmire> compose f 5 ==> (f . f. f. f. f)
12:47:47 <gwern> @src replicate
12:47:47 <lambdabot> replicate n x = take n (repeat x)
12:48:09 <monochrom> foldr or foldl with (.) and that.
12:48:10 <nominolo> :t foldl (f.) id
12:48:11 <lambdabot> Not in scope: `f'
12:48:25 <nominolo> :t \f -> foldl (f.) id
12:48:26 <lambdabot> forall a. (a -> a -> a) -> [a] -> a -> a
12:48:49 <nominolo> :t chainl
12:48:50 <lambdabot> Not in scope: `chainl'
12:49:46 <nominolo> :t scanl
12:49:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
12:50:06 <glen_quagmire> @hoogle (a -> b) -> Int -> *
12:50:07 <lambdabot> Hoogle Error: Parse Error: Unexpected character '*'
12:50:25 <nominolo> > foldl' (.) id (replicate n (+1)) 5
12:50:25 <lambdabot>  Couldn't match expected type `Int' against inferred type `Expr'
12:50:38 <nominolo> what the?
12:50:40 <nominolo> Expr?
12:50:48 <mauke> > n
12:50:56 <lambdabot>  n
12:51:08 <nominolo> > foldl' (.) id (replicate 5 (+1)) 5
12:51:09 <lambdabot>  10
12:51:57 <dcoutts_> nominolo: ta for the bool patch, I've applied it.
12:52:15 <mauke> > a^n + b^n == c^n
12:52:21 <lambdabot> Terminated
12:53:35 <Deewiant> > a
12:53:36 <lambdabot>  a
12:53:40 <Deewiant> @ty a
12:53:41 <lambdabot> Not in scope: `a'
12:53:54 <Jiten> @src iterate
12:53:54 <lambdabot> iterate f x =  x : iterate f (f x)
12:53:57 <Deewiant> > a::()
12:53:58 <lambdabot>  Couldn't match expected type `()' against inferred type `Expr'
12:54:15 <mauke> > iterate f x
12:54:17 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
12:54:42 <gwern> damn, wxhaskell is being difficult with me. 'make: execvp: x86_64-pc-linux-gnu-g++: Too many levels of symbolic links' <-- what does that even mean?
12:55:15 <ricky_clarkson> mauke: *whimper*
12:55:15 <mux> that is an OS level error (ELOOP)
12:55:40 <mux> presumably that's because you have a loop with some symlinks
12:55:57 <gwern> mux: sure, but what deos that mean for me the compiling person? I have no idea where the loop is or how to deal with it
12:56:14 <mauke> step 1: find x86_64-pc-linux-gnu-g++
12:56:41 <gwern> mauke: did that, yes
12:56:44 <glen_quagmire> > (join . join . join . join . join . join . join . join . join . join . join) Nothing
12:56:45 <lambdabot>  Nothing
12:56:50 <mauke> what does it point to?
12:56:57 <gwern> a binary
12:57:04 <gwern> /usr/bin/x86_64-pc-linux-gnu-g++ if you care
12:57:12 <mauke> no, symlinks always point to a name
12:57:30 <Jiten> compose f a i = (iterate f a) !! i
12:57:40 <b_jonas> what?
12:57:43 <b_jonas> how did you do that?
12:57:55 <b_jonas> > iterate a b
12:57:56 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `Expr'
12:58:07 <b_jonas> > f
12:58:07 <lambdabot>  Add a type signature
12:58:10 <b_jonas> @type f
12:58:11 <lambdabot> Not in scope: `f'
12:58:15 <b_jonas> @type x
12:58:16 <lambdabot> Not in scope: `x'
12:58:22 <nominolo> @instances Expr
12:58:22 <b_jonas> > iterate f x
12:58:22 <lambdabot> Couldn't find class `Expr'. Try @instances-importing
12:58:23 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
12:58:33 <b_jonas> how on earth does that work?
12:58:36 <doserj> > show x
12:58:37 <lambdabot>  "x"
12:58:44 <Jiten> > let compose f a i = (iterate f a) !! i
12:58:44 <lambdabot>  Parse error at end of input
12:58:46 <nominolo> > foldl' (.) id (replicate 5 f) 5
12:58:47 <lambdabot>  Add a type signature
12:58:59 <nominolo> > foldl' (.) id (replicate 5 f) (5 :: Expr)
12:59:02 <lambdabot>  f (f (f (f (f 5))))
12:59:06 <glen_quagmire> > let compose f a i = (iterate f a ) !! i in compose join Nothing 10
12:59:07 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a
12:59:07 <lambdabot>       Expected...
12:59:51 <monochrom> http://www.haskell.org/haskellwiki/Humor/Hugme
12:59:52 <lambdabot> Title: Humor/Hugme - HaskellWiki
13:03:56 <monochrom> > let _'freedom' = "slavery" in _'freedom'  {- hahahah -}
13:04:00 <gwern> hm. the offline docs say I need an old version of wxGTK, but the online docs mislead as they assume the old version is the latest version
13:04:06 <lambdabot>  "slavery"
13:04:23 <gwern> > let 2 + 2 = 5 in 2 + 2 -- how many fingers, Winston?
13:04:26 <lambdabot>  5
13:06:15 * dcoutts_ sneakily assigns another Cabal feature to nominolo 
13:06:32 <brian``> gwern, wow ; i didn't know you could do that
13:06:51 <brian``> > let am I genius? = "yes" in am I genius?
13:06:52 <lambdabot>  Parse error at "=" (column 18)
13:06:57 <gwern> brian``: the beauty of piece-wise definition
13:06:57 <brian``> -_-;
13:07:00 <brian``> > let am I genius = "yes" in am I genius
13:07:01 <nominolo> "two plus two always equals five"
13:07:01 <lambdabot>   Not in scope: `genius'
13:07:14 <brian``> haha apparently i'm not a genius then hehe
13:07:18 <dcoutts_> @seen byorgey
13:07:19 <lambdabot> byorgey is in #oasis, #xmonad, #haskell-blah and #haskell. I last heard byorgey speak 25m 35s ago.
13:07:27 <byorgey> hi dcoutts_
13:07:30 <psykon> haha brian``
13:07:41 <brian``> @seen snrrrub
13:07:42 <lambdabot> I haven't seen snrrrub.
13:07:47 <dcoutts_> byorgey: hi, I was wondering about that x-* patch
13:08:02 * gwern thinks the Build-Type: Custom field in cabal files should be renamed to Build-Type: Complex for their vexing nature
13:08:11 <dcoutts_> gwern: heh, yeah :-)
13:08:25 <byorgey> dcoutts_: I haven't gotten around to it yet, but keep poking me =)
13:08:30 <dcoutts_> byorgey: ok :-)
13:08:45 * dcoutts_ has plenty of other Cabal hacking tasks to hand out
13:09:09 <dcoutts_> http://hackage.haskell.org/trac/hackage/report/13
13:09:10 <lambdabot> Title: {13} Easy tickets - Hackage - Trac
13:10:07 <gwern> dcoutts_: incidentally, i noticed darcs haxml says 'default: false' and not 'default: False'; does cabal insist on it being caps?
13:10:22 <gwern> i mean, if it doesn't work upper-case, is that a bug?
13:10:43 <dcoutts_> gwern: nominolo fixed that a couple hours ago.
13:11:00 <dcoutts_> I've not yet pushed the patch though.
13:11:13 <gwern> oh. ok, it was causing problems with HaXml, which is why I was asking
13:11:41 <Zao> Yay, got WASH/HTML to spit out reasonably validating XHTML :)
13:11:58 <Zao> Still allows invalid attributes and whatnot though.
13:12:20 <gwern> hm. for some reason I thought Wash was moribund
13:13:03 <Zao> The source hasn't been touched in years, but it still builds fine on modern GHCs.
13:13:05 <Chad> I have the latest Data.Binary from darcs, and "make bench" is requiring over 400 MB. How can I track this down and/or report the bug?
13:13:06 <Feuerbach> is there a good reference on Parsec? haddock seems to be poor...
13:13:22 <mauke> @where parsec
13:13:23 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
13:14:07 <Feuerbach> thanks
13:18:30 <Chad> @where binary
13:18:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
13:19:18 <nominolo> dcoutts_: did you see the "resolution" of our regex-* problems?
13:20:04 <nominolo> dcoutts_: http://groups.google.com/group/yi-devel/msg/309fef4bac9f97e3
13:20:05 <lambdabot> Title: No instance for (RegexLike Regex B.ByteString) - yi.devel | Google Groups
13:20:08 <gwern> Zao: really? without too much trouble? how hard would it be to put on hackage do you think?
13:21:02 <Zao> gwern: /HTML probably just needs a cabalizing, my /XHTML needs to conform to the standard and all first :P
13:21:43 <gwern> hm. and wash is genuinely useful?
13:22:17 <Zao> I've got no idea about the other components, I just use the HTML part in a standalone application.
13:22:55 * gwern adds that to the list then
13:24:56 * byorgey wallops GADTs and phantom type witnesses with a giant lambda-hammer!
13:26:12 <kowey> any good names for a benchmarking tool?
13:26:35 <vincenz> lazybench
13:26:38 <JustinWick> lol
13:26:41 <JustinWick> lazyspeed?
13:26:43 <JustinWick> hahaha
13:27:01 <kowey> hmm.... lazybench...
13:27:02 <dmwit> The Urinator
13:27:03 <kowey> maybe
13:27:03 <JustinWick> haskelltime?
13:27:10 <kowey> seems better than my 'checkquick' (ugh)
13:27:12 <JustinWick> (ala unix command)
13:27:14 <dmwit> Or maybe "Greyhound".
13:27:28 <vincenz> kowey: procrastinator
13:27:34 <JustinWick> lol benchmarking is the root of all evil
13:27:41 <JustinWick> (unless ur benchmarking your actual task :))
13:27:45 <dmwit> I like Greyhound, because it is simultaneously fast and marks benches. =)
13:27:51 <kowey> hehe
13:27:53 <vincenz> ExcuseForPizza
13:28:05 <kowey> Greyhound... hmm
13:28:06 <JustinWick> oh god
13:28:14 <kowey> with a built in motto
13:28:35 <JustinWick> yeah that might not be a bad name
13:28:43 <kowey> it might be overpromising
13:28:43 <JustinWick> Coming up with good names that aren't already overloaded is tough :(
13:28:58 <kowey> uberbensch seemed a little... overconfident
13:28:59 <JustinWick> At one of my previous jobs they decided to call their software SAP
13:29:08 <JustinWick> it was used only in-house but....  yeah you can imagine the confusion with users etc
13:29:16 <JustinWick> they were like...  we're using a database to do.... what?!
13:29:22 <vincenz> lazyboy
13:29:37 <JustinWick> hah that doesn't get accross the intent at all
13:29:37 <Valodim> haha
13:29:40 <vincenz> cause benchmarking is a good excuse to go sit in it
13:29:53 <JustinWick> perhaps
13:29:56 <dmwit> LightningRod
13:30:12 <dmwit> For no reason other than that it sounds kind of cool.
13:30:16 <vincenz> powerdrill - marks your bench like no other
13:30:25 <JustinWick> I like that one
13:30:31 <Zao> kowey: "oomph"
13:30:50 <vincenz> or go lame and use: lambdamark
13:30:51 <kowey> oomph?
13:31:24 <vincenz> specundefined
13:31:27 <vincenz> in the vein of specint
13:31:43 <kowey> any use for the word 'nimble'?
13:31:43 <vincenz> lambdagrind
13:31:55 <JustinWick> :)
13:31:58 <JustinWick> hgrind?
13:32:05 <dmwit> Oooh, nimble.
13:32:05 <dcoutts_> nominolo: right, so the regex-*-0.7x versions have slack deps that allow them to build against later versions but then not work.
13:32:09 <vincenz> bottomgrind
13:32:15 <JustinWick> (this is a haskell-related benchmark program, correct?)
13:32:15 <kowey> (so, the basic purpose of the tool is to make it easy to compare two versions of the same program for time wrt benchmarks of your design)
13:32:16 <vincenz> to remove all those bottoms from your program
13:32:25 <dons_> kowey: i think checkquick is fine
13:32:31 <kowey> and it's not haskell-specific, although it will be written in haskell
13:32:37 <JustinWick> (cool)
13:32:39 <JustinWick> ahh I see
13:32:40 <kowey> well, malcolmw doesn't like it
13:32:42 <JustinWick> nimble, not bad
13:32:42 <dmwit> What is with all these people with nicks that hash to dark green?
13:32:44 <dcoutts_> nominolo: cabal has to consider hidden packages otherwise you'd never be able to use the ghc api for example.
13:32:55 <kowey> and the quickcheck link might be a bit... err... offensive :-)
13:33:21 <dcoutts_> nominolo: but I do want to see this feature added: http://hackage.haskell.org/trac/hackage/ticket/224
13:33:22 <lambdabot> Title: #224 (allow specifying package version constraints to configure) - Hackage - Tra ...
13:33:35 <kowey> although I did like the idea of 'quickcheck' to check quickly, and 'checkquick' to check for quickness
13:33:45 <vincenz> notslow
13:33:52 <kowey> fastenough?
13:34:03 <vincenz> close-to-c?
13:34:07 <JustinWick> piper
13:34:10 <JustinWick> he he a cute name for anything
13:34:16 <dmwit> FastEnoughP
13:34:21 <dmwit> In honor of Lisp.
13:34:28 <vincenz> lisp weeny
13:34:36 <earthy> unfortunately nobench is already taken. :P
13:34:59 <dons_> it'd be nice to combine nobench with this.
13:35:00 <vincenz> lazyspec
13:35:07 <dmwit> vincenz: I've done one week of lisp in a class, am I a weeny yet? =P
13:35:13 <vincenz> dmwit: I didn't say smug
13:35:15 <dons_> there's a lot of good programs and work done on nobench, you could reuse
13:35:32 <nominolo> kowey: "quickie" for a performance testing tool might be a bad name, i guess ;)
13:35:45 <kowey> :-)
13:35:51 <vincenz> kowey: lazyspec, in the vein of specint and spec..the other
13:35:55 <JustinWick> ha ha I like that actually
13:35:58 <nominolo> kowey: but checkquick is too confusing
13:36:10 <kowey> yeah
13:36:21 <dcoutts_> nominolo: the regex versioning is totally borken imho, they're using 0.7x. and 0.9x where they should be using 0.7.x and 0.9.x
13:36:23 <kowey> hmm
13:36:30 <nominolo> kowey: i don't know. turbo-lambda or sth
13:36:32 <vincenz> slowcheck
13:36:35 <kowey> i wonder if nobench could actually just become the generic benchmarking tool
13:36:43 <vincenz> after all, seeing which is slow tells you which is quick
13:36:51 <nominolo> lambdabench
13:36:54 <nominolo> quickbench
13:36:54 <JustinWick> quickly?
13:36:57 <JustinWick> instead of quickie
13:37:02 <JustinWick> it's G-rated
13:37:12 <nominolo> not google-friendly
13:37:12 <JustinWick> snapbench
13:37:17 <JustinWick> he he or just "snap"
13:37:19 <dmwit> ?freshname
13:37:19 <lambdabot> Haa
13:37:23 <dmwit> Problem solved!
13:37:27 <nominolo> lol
13:37:37 * JustinWick misses the haskell joke
13:37:44 <nominolo> dcoutts_: yeah, it's weird
13:37:50 <dmwit> ?freshname
13:37:50 <nominolo> snapdoodle
13:37:50 <lambdabot> Hab
13:37:55 <dmwit> ?freshname
13:37:55 <lambdabot> Hac
13:37:56 <dmwit> ?freshname
13:37:57 <lambdabot> Had
13:38:04 <dmwit> JustinWick: Do you get it now? =P
13:38:04 <nominolo> Hac is taken already
13:38:06 <vincenz> 26 fresh names
13:38:15 <JustinWick> lol
13:38:24 <dmwit> > 26 * 26 -- this many, probably
13:38:26 <lambdabot>  676
13:38:27 * JustinWick thought it was a name generating thing, but thought it was built into haskell
13:39:40 <vincenz> maybench
13:39:43 <nominolo> > randomRs (0,25) (mkStdGn 42)
13:39:44 <lambdabot>   Not in scope: `mkStdGn'
13:39:49 <nominolo> > randomRs (0,25) (mkStdGen 42)
13:39:50 <lambdabot>   Not in scope: `mkStdGen'
13:39:50 <vincenz> maybe * bench
13:40:00 <kowey> just...?
13:40:11 <vincenz> justquck
13:40:14 <vincenz> justquick
13:40:21 <gwern> bleh. wxhaskell is fail. I give up on that sucker
13:40:22 <dmwit> justice
13:40:23 <vincenz> cause it returns Just quick where quick = ...
13:40:35 <kowey> gwern: nooo!
13:40:50 <kowey> can we help?
13:40:59 <gwern> kowey: build errors mon
13:41:18 <gwern> I installed the old wxGTK the docs (which differ from the website btw...) and it still didn't build aright
13:41:30 <kowey> oh dear
13:41:32 <vincenz> kowey's ultra super lazy benchmarking tool for the win
13:41:45 <kowey> there's now patches in the darcs repo
13:41:53 <kowey> that apparently make it work with wxWidgets 2.8
13:41:57 <JustinWick> flipbench
13:41:59 <JustinWick> :-D
13:42:04 <JustinWick> Turning benchmarking upside down
13:42:04 <hpaste>  gwern pasted "wxwidgets" at http://hpaste.org/5606
13:42:15 * kowey apologises for the non-existent release cycle... only shelarchy has his act together here
13:42:19 <JustinWick> (that's waht I wanna do to benchmark programs when my 1337 optimized code goes only like 10% faster)
13:42:48 <vincenz> prematureoptimization
13:43:00 <kowey> because it's the root of all evil?
13:43:05 <vincenz> :D
13:43:14 <gwern> kowey: is x11-libs/wxGTK-2.8.7.1-r1 an appropriate wxwidgets to have installed?
13:43:30 <vincenz> kowey: yes, and cause you only get like 5% for all that benchmarking
13:43:34 <gwern> also, see the hpaste
13:43:39 <gwern> vincenz: but optimizing is such fun!
13:43:44 <kowey> i actually haven't tried since wxMac 2.6.3
13:43:56 <vincenz> then I vote again for "procrastinator"
13:44:06 <kowey> but please, even if you do give up,
13:44:10 <JustinWick> ha ha
13:44:14 <kowey> complain on wxhaskell-user or is it, users?
13:44:47 <vincenz> yetanotherbenchmark
13:44:51 <kowey> gwern: yes, please complain on wxhaskell-users
13:44:53 <vincenz> yetanotherbenchmarktool
13:44:56 <vincenz> YABT
13:45:04 <vincenz> (yet another haskell tutorial..)
13:45:13 <kowey> actually, if there were generic benchmark tools out there
13:45:18 <gwern> kowey: subscribe to an email list just to complain about a build problem I'm experiencing for a package that I'm trying install just to build another package (GenI) which I am trying to install so I can package it for Hackage?
13:45:19 <kowey> i think we would just use them
13:45:23 <gwern> (if you follow)
13:45:31 <kowey> gwern!
13:45:32 <JustinWick> If everyone keeps making YACC, YAML, YABT, etc
13:45:37 <JustinWick> damn that'll be confusing
13:45:37 <kowey> I was working on GenI
13:45:53 <gwern> kowey: really? oh dear. I hope our patches don't conflict
13:46:07 <kowey> I'm not really anymore, but yeah
13:46:22 <kowey> I think if you darcs send patches, they go to me still
13:46:34 <kowey> (I'm Eric Kow, btw)
13:46:38 <vincenz> kowey: nameless benchmark
13:46:44 <grahamhutton> anyone here going to "fun in the afternoon" in London tomorrow?
13:46:59 * gwern greps for Eric. my. what a lot of hits
13:47:18 <grahamhutton> there's a great programme lined up:
13:47:34 <grahamhutton> http://sneezy.cs.nott.ac.uk/fun/
13:47:34 <lambdabot> Title: Fun in the Afternoon
13:47:49 <vincenz> grahamhutton: I wish I could but have to have meetings tomorrow
13:48:10 <dcoutts_> grahamhutton: see you there :-)
13:48:17 <grahamhutton> hi duncan!
13:49:06 <dcoutts_> grahamhutton: it does look like a good lineup
13:49:15 <Cale> I wish I could go, but I'm on another continent ;)
13:49:28 * dcoutts_ wonders what "Richard Bird's Fan Club" will be
13:49:52 * byorgey seconds Cale
13:50:42 <grahamhutton> dcoutts: it's about using relations to solve a functional problem (i.e. poking functional programmers with a relational stick :-)
13:50:59 <dcoutts_> grahamhutton: ah, sounds fun
13:51:31 <nominolo> oh, that's tomorrow
13:51:33 <grahamhutton> indeed; there's nothing like a good scrap about what formalism is the best!
13:51:50 <wli> grahamhutton: Is this from The Algebra of Programming?
13:51:52 * nominolo prefers practical
13:52:22 <grahamhutton> no, it's a new solution to a problem proposed by Richard
13:53:02 * wli remembers getting blown away by allegories.
13:53:07 <nominolo> grahamhutton: will this be recorded?
13:53:33 <nominolo> grahamhutton: like video, or audio+slides
13:53:36 <grahamhutton> i don't think there are any concrete plans to do so, but if someone turns up with a video camera, that would be great
13:53:48 <grahamhutton> and permissions can be sorted out afterwards
13:54:27 <grahamhutton> at the least, the slides will all be put on the "fun in the afternoon" website, as with previous meetings
13:57:20 <monochrom> I wish: (A) I have lots of money; (B) the Concorde planes are still in use.
13:57:52 <nominolo> a beamer would to too
13:58:00 <lament> (C) Harems were legal
13:58:01 <nominolo> or time-travel
13:58:18 <monochrom> Currently those two combined would be the only practical way I could come over to (1) Fun in the Afternoon; (2) BCS townhall meetings for Hoare's Grand Challenge.
13:58:36 <kowey> (thanks for the name suggestions, everyone)
13:58:58 <gwern> hey, anyone want to try to cabal install 'libGenI
13:59:00 <nominolo> monochrom: has (2) been solved?
13:59:05 <gwern> '?
14:00:07 <nominolo> cabal: There is no package named libGenl
14:00:19 <monochrom> I think Concords are permanently decommisioned, and no replacement.
14:00:31 <monochrom> anyway...
14:00:36 * monochrom <3 Bird
14:00:41 <nominolo> oh that's an I
14:01:04 <wagle_home> > "libGenI" == "libGenl"
14:01:10 <lambdabot>  False
14:01:22 <gwern> you might need to cabal update
14:01:24 <monochrom> Oh, (2), not (B). misread.
14:01:43 <wagle_home> yeah..  its obvious in my main window, but not my input window
14:01:46 <monochrom> (2) is still in work progress. the consensus is it will take 50 years.
14:01:50 <nominolo> gwern: it's building
14:02:01 <nominolo> gwern: it built successfully
14:02:08 <nominolo> gwern: any test suite?
14:02:47 <monochrom> expected to get pretty good prototypes in 10 years. then 40 more years of both engineering and convincing practical programmers.
14:03:03 <gwern> nominolo: there is in the darcs repo
14:03:34 <nominolo> gwern: i mean to test problems when using it.  like missing instances or similar
14:04:17 <monochrom> Likely Roland Backhouse already has a paper on his web site containing the same solution he will present.
14:04:33 * monochrom <3 Backhouse too
14:04:43 <grahamhutton> Monochrom: I don't think Roland has a paper about this online yet.
14:04:49 <grahamhutton> hi andy!
14:04:49 <nominolo> monochrom: the challenge was a completely verified compiler, right?
14:04:53 * monochrom is still using MathSPad! :)
14:04:59 <gwern> nominolo: oh, the problem was kowey was having a configure error where it couldn't find binary
14:05:17 <nominolo> gwern: it pulled binary 0.4.1
14:05:20 <monochrom> No, the challenge is a compiler that completely verifies source code.
14:05:38 <gwern> no wait, it's solved
14:05:40 <nominolo> monochrom: oh.  ok, that's different then
14:05:44 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5607
14:05:49 <gwern> he had binary installed as sudo or soemthing
14:05:56 * kowey is mortified to see his code on hackage
14:05:58 <kowey> sorry, world!
14:06:00 <dons_> hehe
14:06:00 <monochrom> (You could then bootstrap the compiler itself :)
14:06:08 <dons_> free the code!
14:06:38 <kowey> it's not GPL for nothing (this is not a political statement)
14:07:11 <nominolo> monochrom: reminds me of coq and other total programming languages
14:07:12 <gwern> I'm always amazed how many projects are not on hackage. maybe it's because I started haskelling when I did, but I can't understand why putting your stuff on hackage is not routine
14:07:14 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5607#a1
14:07:49 * monochrom contemplates using back doors and cheats to obtain Backhouse's presentation prematurely.
14:08:27 <monochrom> nominolo: haha, but this challenge is firmly in imperative setting :)
14:08:47 <non_socialist> Hi I am downlaoding happs, and my linux distro has it, but it does not install "saerchpath 0.9.2" as listed on the happs page.......but instead lists haxml-1.13.2-2 as a dependency....does this sound correct?
14:08:48 <nominolo> monochrom: laame
14:09:21 <dons_> dcoutts_: mmap + Data.Binary package cache?
14:09:26 <gwern> non_socialist: it's almost certainly a very old happs
14:09:36 <gwern> non_socialist: for happs, I've heard that it's foolish to not run out of darcs
14:09:37 <dcoutts_> dons_: something like that yes.
14:09:48 <monochrom> Not to mention that I believe that in the FP setting the true way is still based on Bird's fan club rather than curry-howard.
14:09:49 <dons_> those timing results are pretty awful
14:09:52 <dcoutts_> dons_: anything would be quicker than the current Read parser
14:09:56 <dons_> yeah
14:10:06 <dons_> i've often got > 100 packages installed, these days
14:10:28 <dcoutts_> dons: yes, and it's only going to go up
14:10:36 <gwern> 'geniconvert' uploaded. anyone want to cabal install? :)
14:10:45 <glguy> don's ghc-pkg list output always amuses me when it comes up on screen
14:10:50 <dons> hehe
14:11:24 <dons> dcoutts_: and we already do a bunch of binary stuff in .hi files
14:11:24 <nominolo> gwern: cabal: Unresolved dependencies: GenI >=0.14
14:11:36 <dcoutts_> dons: right, could use the same system
14:11:38 <nominolo> gwern: it's called libGenI
14:11:48 <dons> yeah. its DrIFT plus old, slow NewBinary
14:11:49 <Chad> I'm running the darcs version of Data.Binary with ghc 6.8.2, and "make bench" needs upwards of 400 MB before I kill it
14:11:50 <gwern> d'oh
14:12:05 <dons> and  a cheap mmap binding on unix boxes
14:12:12 <Chad> How can I get more details to report what might be going on?
14:12:13 <dcoutts_> glguy: my ghc-pkg list output is going to be more than the hpaste 5k limit soon :-)
14:12:18 <dons> Chad: that's expected
14:12:33 <dons> Chad: its using massive cross module inlining and specicialisation
14:12:42 <Chad> ahh, ok
14:12:52 <dons> == high performance, but ghc takes its time.
14:13:03 <dons> we should bump it up to simonm and igloo to work out why its so slow
14:13:16 <Chad> ok that makes sense
14:13:28 <dons> turn off -O2 :)
14:13:42 <Chad> should I expect such compile issues for most code using it?
14:13:48 <dons> nope.
14:13:51 <Chad> ok cool
14:14:01 <dons> check Bench.hs, its a rather pathological benchmark program
14:14:05 <gwern> ok, I've uploaded the fix geniconvert
14:14:17 <dons> (that ghc happens to optimise rather well)
14:14:25 <Chad> haha ok
14:14:49 <dons> Igloo: i note on the gmp page they've big warnings now about gcc miscompiling libgmp
14:14:59 <dons> and that 'make check' should always be run
14:15:07 <dons> do we hook gmp's make check into our test system?
14:16:31 * monochrom giggles at the talk abstract of Backhouse's talk. Someone will have to present "yet another category theory crash course!" :)
14:16:33 <Igloo> dons: No; it might be worth filing a bug about that
14:16:48 <phobes> If you have classes A and B with A a subclass of B, what are the disadvantages of modelling that by declaring instance B => A instead of class A => B?
14:16:59 <Igloo> dons: And if you have an example of poor performance by GHC, definitely file a bug (with testcase) about that!
14:17:38 <dons> Igloo: so its not in the generated code -- just ghc taking a long time to compile a particularly pathological program
14:17:43 <dons> one which hammers the simplifier pretty bad
14:17:48 <dons> and a lot of space
14:18:34 <Igloo> dons: Still file a bug (unless it's just a pathologically big file or something)
14:18:42 <dons> ok.
14:18:58 <dons> i've thought for a while its a good benchmark of the simplifie4r
14:20:00 <dons> Igloo: re. libgmp, do you know if we run its 'make check' when building?
14:20:17 <Cale> I find it amazing just how much people can discuss the blue-eyed islanders puzzle.
14:20:18 <Igloo> dons: I'm pretty sure we don't
14:20:27 <dons> the gmp site is rather strenuous in warning to do this, to avoid broken installations. they go as far as to say "assume it is miscompiled"
14:20:52 <dons> oh, i suppose we use external libgmps mosttly
14:20:55 <vincenz> Cale: it's flawed, it assums everyone works in the same lock-step synchronised fashion
14:21:05 <dons> but might be good to sanity check whichever system we're using
14:21:09 <Cale> vincenz: But that's the point of such puzzles.
14:22:42 <njbartlett> The version I read said that the islanders had to commit suicide at dawn, so that provided the synchronization required
14:22:46 <Big_Red> hrm is there a way to use getLine to just get ints?
14:22:52 <Cale> njbartlett: Oh, in that sense.
14:22:54 <Big_Red> or a similar function?
14:23:01 <Cale> Yes, that's important.
14:23:12 <dons> Big_Red: readIO
14:23:15 <njbartlett> Cale: Assuming we're talking about the same puzzle. The one I read was about monks :-)
14:23:16 <mauke> Big_Red: readLn
14:23:17 <awesame> I have a module I want to extend, preferably without modifying its source
14:23:22 <dons> readLn, yes.
14:23:26 <awesame> but it doesn't export some of the components I want to use
14:23:33 <Cale> (I thought vincenz was arguing about these people all reasoning in exactly the same way.)
14:23:40 <awesame> is there a way to import them anyway, or am I stuck forking the module?
14:24:02 <Cale> awesame: Fork, or just contribute changes.
14:24:16 <awesame> augh
14:24:17 <awesame> painful
14:24:22 <Cale> awesame: Most Haskell code in existence is open source, and patches are accepted.
14:24:23 <dons> what module?
14:24:26 <Cale> Which code is it?
14:24:51 <dons> better to push changes back to the darcs repo for all to use
14:24:58 <awesame> the thing is, the direction I want to go with this module is probably not the direction the maintainer wants to go
14:25:05 <dons> depends. what code is it?
14:25:14 <awesame> I was hoping to build my stuff on top of it in a way that would make merges as painless as possible
14:25:18 <dons> if its radically different,then its ok to fork. but at least talk to the maintainer
14:25:26 <Cale> awesame: Not being able to import things which the module doesn't expose is important. Modules are an important means of abstraction in Haskell, not just a way to organise code into files.
14:25:29 <awesame> it's code for a C++ evaluation bot called geordi
14:25:44 <dons> oh, not haskell code?
14:25:49 <gwern> geordi... hey, didn't I chat with you about sandboxing?
14:25:54 <awesame> Cale: I guess this is like "private" in OO languages?
14:26:02 <gwern> dons: no, iirc geordi uses haskell for sandboxing the c++
14:26:09 <gwern> on the model of lambdabot
14:26:12 <awesame> gwern: possibly, I don't remember
14:26:50 <Cale> awesame: Yeah. Basically, it's the only real means of encapsulation that the language has.
14:26:52 <awesame> hm
14:26:59 <Cale> (apart from parametricity, perhaps)
14:27:08 <awesame> so I think I'm going to just change the list of things the module exports
14:27:18 <awesame> that way my merge conflict is one line
14:27:22 <Sgeo> BYEALL
14:27:26 <dons> oh interesting.
14:27:47 <Cale> If it's just that it looks like the module doesn't export some useful things, then probably that's okay.
14:27:50 <JustinWick> bye sgeo
14:28:22 <awesame> Cale: I think it's just that he's got his encapsulation boundry in a place that's inconvenient for me
14:28:44 <awesame> I'd like for this module to be split into two modules, and then I'd use the lower-level one
14:29:01 <Cale> ah, okay
14:29:02 <awesame> but I don't want to do that and risk having a hard time merging in updates
14:29:27 <gwern> awesame: emailing and asking is always worthwhile
14:29:38 <gwern> I find most maintainters are lovely considerate human beings
14:30:53 <awesame> gwern: you've had better experience with software maintainers than I have!  but Eelis seems to be alright.
14:31:32 <gwern> awesame: well, I except the overly rigid ones from my census :)
14:32:20 <gwern> and others, like RMS, I forgive
14:32:25 <monochrom> In an IRC channel called #haskell there live many programmers. Some are newbies and some are gurus, but it is taboo to discuss such matters. One day, a foreigner monochrom comes in...
14:32:56 <gwern> 'Ah! it is nice to see a newbie and a guru getting along!'
14:32:59 <Cale> monochrom: You're not a foreigner.
14:33:05 <Cale> :)
14:33:43 <monochrom> ... On the 100th day, all the newbies go write about monads on their blogs. WHY?
14:34:22 <awesame> monochrom: and badly, too!
14:35:02 <awesame> most monad tutorials start out with a motivating bit about how monads are hard to get at first, but important, and the problem is just that there's no good tutorial
14:35:10 <dobblego> because they have a name for a pattern that has existed vaguely in their subconscious for many years
14:35:33 <awesame> I think the problem is that there are a growing number of poor to mediocre tutorials, which crowd out the good ones
14:35:57 <dobblego> awesame, perhaps someone should write one and submit it for #haskell review first?
14:36:11 <dons> we could score tutorials on hackage
14:36:19 <dons> and link tutorials to libraries
14:36:31 <dons> it'd be nice to get amazon-like rankings for online docs...
14:36:38 <monochrom> reddit.hackage.haskell.org
14:36:40 <awesame> speaking of RMS, I found a funny bit in a very old emacs readme recently
14:36:47 <dons> well, more like amazon -- reviews, plus botes
14:36:48 <dons> votes.
14:36:57 <awesame> "We'd be even luckier if the rest of the world were [full of the kind of laissez-faire managers and strong-willed programmers that allowed EMACS to be created at MIT's AI lab].  For example, DEC has assembly conditionals in EXEC for multiple forking; a super win -- if your site has bought the sources and can therefore assemble them in.
14:37:13 <gwern> CPAN has annotated pages, where people add little and sometimes sarcastic snippets to the lengthy descriptions and extollations of the library/program
14:37:20 <awesame> Apparently the managers have been pressured by the sales people not to let the feature out where the rest of you can use it.  If the managers weren't stifling, or the programmers weren't cowed, you would have this important feature already.
14:37:29 <awesame> (In any case, you have it now; look for EXEC.EXE on the tape)."
14:37:48 <awesame> say what you want about RMS, that guy knows how to deploy a middle finger
14:38:35 <znutar> There's a good chance that the feature wasn't released because the implementation was buggy and semi-broken
14:38:54 <awesame> yeah, who knows
14:39:27 <znutar> That'd be more in line with typical hardware implementations than salespeople actually having a clue what a features does
14:40:06 <gwern> never ascribe to corporate benevolence what can be explained by greed or incompetence
14:43:15 <joao> is there any alphabetical list of gtk2hs functions? the Haddock documentation only provides links to each Module, right?
14:43:30 <dons> the haddocks have an alphabetical index
14:43:43 <joao> then I must be blind! :)
14:44:48 <gwern> she blinded me with science!
14:44:58 <joao> I found it!
14:45:54 <vincenz> 42?
14:48:48 <dons> "The key to language success is making it powerful enough for a couple cowboys to do the work of an entire team in a shorter period of time. Selling fast and cheap is easy. If you have enough fast and cheap, the business people won't care if you are making it out of bubble-gum and duct-tape, because you are giving them what they want."
14:49:52 * vincenz gives dons arc
14:50:08 <vincenz> I thought you said "bubble-gum and duct-tape"
14:50:22 <dons> heh
14:50:57 <dons> haskell's powerful enough that a couple of lambda cowboys can do the work of entire teams, and still produce more reliable code, sooner
14:51:03 * monochrom recalls the Bubble Gum commercials in the 80's.
14:51:05 <dons> so selling fast and cheap. i like it
14:51:08 <awesame> heh, arc
14:51:37 <awesame> one thing I liked in arc was apply position notating for indexing collection types
14:52:05 <vincenz> yes, a cute hack
14:52:14 <awesame> ("foo" 0), (myhash "somekey"), etc
14:52:31 <vincenz> (userdefined-type 'oh-no!)
14:52:52 <awesame> oh, is that not possible?
14:52:55 <vincenz> no
14:52:57 <vincenz> it's a hack
14:52:57 <awesame> lame
14:53:01 <vincenz> it's not welll thought through
14:53:24 <kalven> don't question the pg
14:53:28 <vincenz> ba
14:53:29 <vincenz> bah
14:55:58 <vincenz> down with religion in the PL-community
14:56:55 <dons> lisp is a religion
14:57:13 <vincenz> so is creationism
14:57:26 * vincenz sees parallels already
14:57:29 <dons> anything that involves the suspension of belief in science :)
14:57:35 <lament> creationism isn't religion
14:57:43 <vincenz> oh no, you're right, it's science
14:57:53 * vincenz kneels and grovels
14:58:29 <lament> it's a valid theory which we don't know how to test yet
14:58:39 <vincenz> so is christianity
14:59:10 <vincenz> but ok, OT
14:59:42 <lament> christianity isn't a scientific theory at all, it predates science by almost 2000 years
14:59:49 <dolio> (foo n) is definitely nice when the alternative is (lambda (n) (index foo n)).
15:00:06 <dolio> It's not quite as impressive when the alternative is 'foo ! n'.
15:00:43 <vincenz> dolio: even less when you have arrows
15:00:59 <lament> i like foo[n]
15:01:55 <dolio> Yeah, but what's the first-class-function analogue to that? foo[]?
15:02:12 <lament> ouch :)
15:02:22 <dons> nice and strong. i like it: http://pinderkent.blogsavy.com/archives/154
15:02:24 <lambdabot> Title: Unit testing is not a substitute for static typing.
15:02:41 <dolio> I mean, the win on (foo n) is: "(map foo indices)" instead of "(map (lambda (n) (index foo n)) indices)".
15:02:58 <dolio> Or "map (foo !) indices".
15:03:54 <awesame> dolio: yeah
15:04:12 <wagle_home> cool!  static typing as religion!
15:04:15 <vincenz> dolio: all you need is a typeclass
15:04:21 <lament> dons: saying statically-typed languages are "such as haskell, ocaml and standard ml" and not mentioning any of the mainstream ones is quite counterproductive
15:04:26 <awesame> it's cute to make containers work as functions from keys to values
15:04:36 <lament> dons: it makes it seem like static typing is some weird exotic property
15:04:44 <njbartlett> http://www.wellingtongrey.net/miscellanea/archive/2007-01-15%20--%20science%20vs%20faith.png
15:04:44 <lambdabot> http://tinyurl.com/2mulhc
15:04:49 <dons> lament: well, its probably more counterproductive to not cite any evidence directly
15:04:50 <hpaste>  (anonymous) annotated "wxwidgets" with "(no title)" at http://hpaste.org/5606#a1
15:05:03 <lament> that too :)
15:05:12 <dons> lament: and really, he's talking about the dual win of inference, and strong, flexible typing.
15:05:14 <vincenz> lament: there's a good reason for doing that, as most people equate static typing with java and c++ and use that as argument against static typing
15:05:30 <dons> and how unit testing only in the  limit can approximate the kind of power a static analysis provides
15:05:36 <ricky_clarkson> C# has probably done a little to help that.
15:05:44 <ricky_clarkson> ..with a little inference.
15:05:44 <dons> but at least he gets the key points: don't wait till runtime to find out about a bug
15:06:15 <monochrom> Productive languages such as Haskell, OCaml, and SML are certainly more productive than mainstream languages :)
15:06:17 <lament> i'm not sure if inference is really such a big issue
15:06:18 <nominolo> do python programs crash?
15:06:31 <awesame> nominolo: they throw uncaught exceptions
15:06:39 <awesame> unless you catch all of them
15:06:49 <nominolo> CL programs don't really.  you just get to the debugger and have a couple of restart options
15:06:50 <ray> sometimes they fail to halt
15:06:53 <lament> a good type system like HM is clearly an issue, but inference probably isn't
15:06:55 <awesame> in which case, they sometimes fail to do what you expect, instead
15:07:18 <nominolo> awesame: but can they resume?
15:07:19 <dons> identical to a haskell program which could fail with a pattern match error ... on every single expression
15:07:26 <awesame> nominolo: yeah, I think CL has the idea of resuming when an exception has been thrown, right?  python doesn't have that.
15:07:37 <awesame> I always want that
15:07:50 <vincenz> awesame: that's cause most languages only allow continuations that go in one direction
15:07:51 <awesame> how does it work in CL?  do you provide a value for the expression that didn't eval?
15:07:54 <phobes> I think they call them conditions in CL
15:07:55 <nominolo> awesame: yes, and often you just fix a function and resume just before the call to that function, with the same arguments
15:07:56 <monochrom> There are -Wall and the Catch project for pattern matching.
15:08:01 <dons> how the hell do unit  testers think they can test every  code path, with all data shapes, and then to do that with type information! its insane.
15:08:05 <nominolo> awesame: *very* handy
15:08:18 * dons couldn't live like that. i'd not be able to sleep
15:08:40 <lament> dons: i agree. I worked as QA for a few years and i don't believe in automated testing at all.
15:08:41 <nominolo> awesame: you can fix things in many ways
15:08:43 <pejo> dons, who is writing that blog? He or she actually seems to know what they are talking about for a wide range of topics.
15:08:48 <vincenz> dons: library foo returns a bool, not an int in the new release!
15:08:51 <phobes> dons:  So are you a fan of dependent types?
15:08:52 <wagle_home> oo!  down there someplace, it divided by zero!  what do we do?  i know, let have that operation return 42!
15:08:53 <nominolo> awesame: sometimes you have auto-fixing restarts
15:09:03 <monochrom> I use Oleg's generic zipper to implement "which value do you want me to return?" :)
15:09:14 <nominolo> awesame: e.g. symbol foo is not visible - use bar:foo instead?
15:09:26 <awesame> I see
15:09:31 <vincenz> dons: and your compiler doesn't tell you
15:09:38 <lament> dons: automated tests are good for when you find a bug, write a test and then know in the future that the bug is happily fixed. But they're terrible for finding the bugs in the first place.
15:09:43 <wagle_home> "password failed, would you like to change it?"
15:09:45 <nominolo> awesame: of course that would be caught in a statically typed language
15:10:09 <vincenz> lament: I prefer preventing over curing
15:10:14 <monochrom> What is automated test? No handwritten test cases?
15:10:21 <jberg> hey, what's the best online tutorial/introduction to monads now?
15:10:33 <vincenz> @where monads
15:10:33 <lambdabot> http://www.haskell.org/all_about_monads/html/
15:10:36 <nominolo> @wiki All about monads
15:10:36 <lambdabot> http://www.haskell.org/haskellwiki/All_about_monads
15:10:44 <jberg> thanks
15:10:51 <nominolo> dang
15:11:00 <monochrom> @wiki Solving The Halting Problem
15:11:00 <lambdabot> http://www.haskell.org/haskellwiki/Solving_The_Halting_Problem
15:11:04 <monochrom> heheh
15:11:20 * monochrom abuses the @wiki and the @hackage commands!
15:11:20 <nominolo> yeah, @wiki is kinda stupid
15:11:31 <monochrom> @hackage HaltingProblemSolver
15:11:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HaltingProblemSolver
15:11:37 <jberg> there was nothing on the wiki pages
15:11:59 <monochrom> Even @faq is dwarved. :)
15:12:06 <nominolo> jberg: yes, use the other link
15:12:13 <jberg> yep
15:12:31 <nominolo> @go "you could have invented monads"
15:12:32 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
15:12:32 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
15:12:34 <vincenz> @hackage MonochromCure
15:12:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonochromCure
15:12:44 <nominolo> jberg: that sigfpe link is also nice
15:13:16 <monochrom> I thought someone said prevention is preferred to cure. :)
15:13:44 <nominolo> monochrom: while developing it's sometimes nice to have a partially running version
15:13:54 <vincenz> @hackage MonochromDeterrant
15:13:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonochromDeterrant
15:14:14 <monochrom> That's what the dynamic typing proponents say, nominolo.
15:14:16 <nominolo> @wiki ProofOfPEqualsNP
15:14:16 <lambdabot> http://www.haskell.org/haskellwiki/ProofOfPEqualsNP
15:14:29 <vincenz> 00:13 < nominolo> monochrom: while developing it's sometimes nice to have a  partially running version
15:14:32 <nominolo> monochrom: it's true ... *during development*
15:14:34 <vincenz> nominolo: that was in response to?
15:14:48 <vincenz> nominolo: that's why I like soft-typing
15:14:53 <vincenz> or rather, am interested in it
15:15:08 <monochrom> anyway, hehehehehehe
15:15:14 <awesame> I like both static checkers and unit tests
15:15:14 <nominolo> vincenz: is that related to wadler's blame-game?
15:15:20 <vincenz> nominolo: yeah
15:15:32 <nominolo> vincenz: yeah, that sounds useful
15:15:32 * monochrom contemplates co-unit tests.
15:15:41 <awesame> I'd like a compiler that let me add my own static checks
15:15:43 <tomh> hey, anyone knows if there are php bindings for haskell ?
15:15:45 <vincenz> @wiki How to spot a monochrom
15:15:45 <lambdabot> http://www.haskell.org/haskellwiki/How_to_spot_a_monochrom
15:15:52 <monochrom> hahaha
15:16:02 <awesame> and a unit-testing framework that thought of itself more like a runtime assertion checker
15:16:18 <monochrom> tomh: No. Would you like C bindings instead?
15:16:19 <vincenz> awesame: welcome to soft typing
15:16:38 <tomh> monochrom, i like to use some haskell functions in php
15:16:38 <awesame> vincenz: soft typing?
15:16:43 <monochrom> (And would you like monad fries to go with it? XD )
15:17:00 <vincenz> http://www.google.be/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.ccs.neu.edu%2Fscheme%2Fpubs%2Fpldi91-cf.ps.gz&ei=ZNewR6PtJ6OwwQHy6IF8&usg=AFQjCNGDEmS7c9rBizyUxd9LqvYALaUZUQ&sig2=Xfu0euitMmJmPVAaMVfI3g
15:17:00 <monochrom> Perhaps PHP -> C -> Haskell
15:17:02 <lambdabot> http://tinyurl.com/2dcj76
15:17:22 <dons> who do we have to pay to get ghc or hugs installed on os x by default, along with ruby, perl, python, obj-c and java?
15:17:23 <tomh> monochrom, ok thats possible i think
15:17:32 <tomh> use swig to get php to talk to c
15:17:38 <tomh> and c can talk to haskell?
15:18:06 <monochrom> Yes. Advanced topic, but yes, C calling Haskell is supported.
15:18:14 <tomh> ok
15:18:18 <tomh> lots of work?
15:18:34 * tibbe is utterly confused after trying to write a continuation based parser.
15:18:36 <vincenz> not that much
15:18:46 <vincenz> tibbe: comment on wiki?
15:18:50 <vincenz> tibbe: I can take a look at it tomorrow
15:18:54 <awesame> vincenz: neat
15:18:59 <tibbe> vincenz: no comments yet
15:19:01 <pastorn> @src mapAccumL
15:19:02 <lambdabot> mapAccumL _ s []        =  (s, [])
15:19:02 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
15:19:02 <lambdabot>    where (s', y ) = f s x
15:19:02 <lambdabot>          (s'',ys) = mapAccumL f s' xs
15:19:03 <pastorn> @src mapAccumR
15:19:04 <lambdabot> Source not found. I feel much better now.
15:19:06 <vincenz> tibbe: I mean regarding your problem
15:19:08 <tibbe> vincenz: cool, I just have to write it ;)
15:19:11 <pastorn> WHAT?!?!
15:19:12 <vincenz> tibbe: I've seen some continuation based parsers
15:19:18 <tibbe> vincenz: links?
15:19:20 <monochrom> http://www.cse.unsw.edu.au/~chak/haskell/ffi/  is the technical documentation on this.  Note: very technical and dry.  I don't know of a friendly guide.
15:19:23 <vincenz> tibbe: not off the top of my head
15:19:26 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
15:19:35 <vincenz> tibbe: basically you need two continuations
15:19:37 <vincenz> tibbe: a fail and a success
15:19:44 <tibbe> vincenz: I'm trying use the continuations for incremental parsing
15:19:45 <vincenz> tibbe: you're encoding an error type (maybe) as two continuations
15:19:54 <tibbe> vincenz: I see
15:19:57 <vincenz> tibbe: oh, I know they're working on that in utrecht
15:20:00 <vincenz> sw that at the FP day there
15:20:40 <vincenz> there are some subtle bugs with that that doaitse swierstra explained durign his talk
15:21:19 <tibbe> cool
15:21:30 <tibbe> so my parser will not be monadic, only applicative
15:21:35 <vincenz> good
15:21:39 <vincenz> cause it won''t work monadically
15:21:43 <tibbe> I want something simple to parser http
15:21:46 <vincenz> some blackhole problem
15:21:49 <tibbe> that's good then :)
15:22:01 <vincenz> the right argument of a bind can not be an incremental parser
15:22:05 <vincenz> due to blackholing issues
15:22:06 <vincenz> iirc
15:22:12 <tibbe> I'm reading the IncrementalGet version of Binary that uses continuations
15:22:25 <tibbe> what are blackholing issues?
15:47:50 <dons> someone bored?
15:48:00 <dons> this is begging for a 1 line haskell soln, http://nedbatchelder.com/blog/200802/enumerating_trees.html
15:48:01 <lambdabot> Title: Ned Batchelder: Enumerating trees
15:49:42 <TomMD> That site is DOSed it seems.
15:49:54 <dons> hey TomMD. how's code?
15:50:13 <TomMD> Things are going ok - depends the project you are talking about.
15:50:27 <dons> oh, its shapr's general greeting  :)
15:50:39 <TomMD> Oh, I see.
15:51:40 <TomMD> I've been focusing on paper work so much I wasn't sure how to answer.  Realizing that makes me sad.
15:51:47 <dons> heh
15:54:15 <LoganCapaldo> dons is schadenfreuding
15:54:47 <dons> sorry :) i too have to do more paper work than I'm used to
15:55:00 <dons> phd students have life easy
15:55:22 * LoganCapaldo has never been a phd student
15:55:27 <Botje> @remember dons phd students have life easy
15:55:27 <lambdabot> Done.
15:56:06 <Spark> life being a phd student would be much easier if i had any time to do any research at all
15:56:21 <Spark> the nearest thing i've done to research today is trying to get proof general to work
15:56:23 <dons> yeah, that's the key. try to get out of teaching after the first couple of years
15:56:24 <Spark> which hasn't happened
15:56:28 <dons> and just hack/write for the rest
15:56:43 <TomMD> I am seeking to become a PhD student, but funding has been annoying.
15:57:16 <LoganCapaldo> But aren't you already a doctor?
15:57:26 <TomMD> I never figured life would be easier :-)
15:57:44 <dons> well, you have the luxury of being able to think all day
15:58:01 <TomMD> No, common mistake in reading my Nick.  My initials are TMD  - Thomas M. D.  - TomMD
15:58:13 <LoganCapaldo> right
15:58:18 <LoganCapaldo> Dr. Tom
15:58:34 <dobblego> is there a wiki page with the Functor laws?
15:58:53 * LoganCapaldo is messing around
15:58:53 <TomMD> :-)  So I guess I MUST get a PhD so it becomes slightly less misleading.
15:59:42 <Spark> only in medicine though
15:59:59 <TomMD> No, I'll stick with static code analysis.
16:00:04 <Spark> heh
16:00:11 <dons> dobblego: they're in the docs for GHC.Base
16:00:13 <dobblego> oh, it's in the GHC docs
16:00:17 <Spark> one day, someone will shout "is there a doctor on this plane?"
16:00:17 <dobblego> dons, yeah thanks, just found it ;)
16:00:23 <Spark> and i will jump up
16:00:35 <Spark> and say yes, "which type system would like me to prove sound?"
16:00:50 <TomMD> And the spouse of the patient will smack you
16:01:13 <Spark> i suspect that far in the future, society will have advanced to teh stage where most people are marrying farmyard animals
16:02:01 <non_socialist> lol
16:02:13 <dobblego> is this law stated anywhere? fmap f xs = xs >>= return . f
16:02:22 <non_socialist> that reminds me of a joke about a monkey that could suck well
16:02:35 <non_socialist> something about how much monkey worth
16:02:49 <Spark> one banana
16:04:19 <lament> non_socialist: how much?
16:05:01 <Spark> if every hospital was like the one in "house", i would probably be queueing up for my medical degree
16:05:38 <Corun> Also, patients would come in almost completely fine and then they'd nearly die, but be alright thanks to a sudden piece of insight.
16:05:53 <Corun> Normally sparked by someone saying something totally unrelated
16:06:05 <Spark> see, that would be fun
16:06:15 <Corun> (Don't get me wrong, I think house is great ^_^)
16:06:23 <Spark> yeah it's not about the medicine
16:06:26 <Spark> it's a bit like CSI
16:06:39 <Spark> people from random corners of society turn up, and are generally weird
16:06:43 <Spark> and interesting
16:06:51 <Spark> sometimes they die
16:06:53 <Corun> That and hugh laurie is hilarious
16:07:03 <LoganCapaldo> istr reading somewhere that was the original premise basically, CSI w/ medicine
16:07:24 <Spark> yeah he's a bit like dr cox from scrubs
16:08:20 <thoughtpolice> scrubs is awesomeness.
16:08:28 <thoughtpolice> it might be the only tv show i watch.
16:08:52 <Spark> the problem with comedy is that it's not always funny
16:09:09 <tomh> then you havent seen south park
16:09:14 <tomh> that shit is funny all the time :>
16:09:22 <thoughtpolice> tomh is my new best friend.
16:09:49 <non_socialist> wow kick butt happs install script from happs google group
16:09:49 <LoganCapaldo> isn't that he problem with anything?
16:10:01 * LoganCapaldo tries it out
16:10:02 <dons> hehe. is that the scary one that builds ghc too?
16:10:16 <LoganCapaldo> the problem with haskell is that it's not always typesafe
16:10:21 <non_socialist> yep
16:10:29 <dons> LoganCapaldo: hmm?
16:10:29 <non_socialist> Pre-emptive multitasking, multithreading, ring-3 protection  what is ring 3?
16:10:31 <non_socialist> anyone?
16:10:42 <dons> user land stuff?
16:10:58 <dons> or threads in the same address space?
16:11:16 <non_socialist> dons is that what ring3  means?
16:11:26 <LoganCapaldo> dons: I'm just filling in the blanks in The problem with $foo is that it's not always $(important characteristic of foo).
16:11:26 <non_socialist> as in outside the kernel
16:11:47 <natv> Ring 3 is the level of priviledge for userland stuff, by convention
16:12:03 <non_socialist> is this a comp sci term or some kinda ansi term?
16:12:14 <dons> LoganCapaldo: you mean, the type of an object does not always exactly specify the desired inhabitants of the type
16:12:16 <natv> It's an intel x86 term
16:12:17 <dons> ?
16:12:28 <dons> and kernel/unix term
16:12:30 <non_socialist> ah hah!
16:12:52 <natv> and prior to that I think the multics people called them rings too
16:12:59 <natv> not positive on that though
16:14:19 <LoganCapaldo> dons: was teh question mark part of the phrase directed at me?
16:14:20 <Spark> what's in ring 1 and 2 then
16:15:03 <Pseudonym> Didn't the VAX have rings?
16:15:20 <dons> LoganCapaldo: it was directed at you, about what you meant by $foo and haskell being not type safe.
16:15:22 <thoughtpolice> ring 1 and 2 normally go unused as far as most standards go. ring 0 is where your kernel resides, so 1 and 2 could feasibly be used for system services or something
16:15:34 <thoughtpolice> but as per most systems, it's either 0 or 3
16:16:24 <LoganCapaldo> dons: well I didn't really mean it per se. it's not really analogous to comedy and being funny anyway.
16:16:34 <Cale> dobblego: well, sort of.  Let's use the definition xs >>= g = join (fmap g xs).  Then xs >>= return . f = join (fmap (return . f) xs) = join (fmap return (fmap f xs)) = fmap f xs (by one of the laws for return)
16:16:44 <thoughtpolice> and apparently with hardware virtualization there's ring -1 too (amd pacifica/intel vt) so that guest systems can reside in ring 0 concurrently, but not really interfere with each other
16:16:53 <dobblego> Cale, ah, so you mean it can be derived from the existing laws?
16:16:59 <Cale> dobblego: right.
16:17:05 <dobblego> Cale, ok understood, thanks
16:17:22 <Cale> dobblego: Exactly how it's derived depends on which set of laws you're using.
16:17:31 <Spark> has anyone proved haskell type safe?
16:17:35 <Cale> dobblego: I went with the fmap/return/join basis there.
16:17:40 <Corun> It's not type safe
16:17:44 <dobblego> Cale, yep, I see it, cheers
16:17:49 <Spark> i guess that would be a no then
16:17:51 <Cale> :t Unsafe.Coerce.unsafeCoerce
16:17:52 <lambdabot> forall a b. a -> b
16:18:10 <Spark> ok, has anyone proved (haskell - the unsafe bits) type safe?
16:18:10 <Cale> Spark: depends on what you mean by "Haskell"
16:18:23 <Cale> Uh, I think at one point, prior to Haskell 98.
16:18:24 <Spark> whatever happens to be standard and current
16:18:30 <Spark> ah right
16:18:34 <non_socialist> wow happs still compiling!!
16:18:45 <Cale> The HM system has had lots of stuff proven about it.
16:19:01 <Cale> And so has system F and friends.
16:19:03 <Spark> yeah but there's a lot more
16:19:12 * LoganCapaldo shoulda picked a different example
16:19:14 <Spark> type classes, functional dependencies and whatever
16:19:22 <Spark> gadts?
16:19:27 <LoganCapaldo> I wanted to say teh problem with dram is that it's not always dramtic
16:19:29 <wagle_home> HM?
16:19:35 <johnnowak> wagle_home: hindley milner
16:19:36 <LoganCapaldo> but that didn't seem like it had the right relationship
16:19:37 <Spark> hm is old enough to be my father
16:19:43 <Cale> I'm not even sure if there's a formalisation of what functional dependencies are, let alone that they satisfy any nice properties.
16:19:52 <Pseudonym> dobblego: The law is stated in the H98 report, section 6.3.6.
16:20:02 <dobblego> Pseudonym, great thanks
16:20:03 <Pseudonym> Essentially, if it's a Monad, it has to obey the three laws.
16:20:14 <Pseudonym> If it's a Functor, it has to obey the Functor laws:
16:20:15 <LoganCapaldo> The three laws of Monadics
16:20:23 <Pseudonym> fmap id = id, fmap f . fmap g = fmap (f.g)
16:20:35 <Pseudonym> And if it is both, it has to additionally satisfy:
16:20:39 <Pseudonym> fmap f xs = xs >>= return . f
16:20:40 <non_socialist> robotics?
16:20:40 <ddarius> It's just part of the definition of functor and monad
16:20:48 <LoganCapaldo> 1) A ona shll not cause a program to come to harm, or through inaction allow a programmer to come to harm
16:20:50 <non_socialist> whats a monad?
16:21:01 <LoganCapaldo> wow
16:21:07 <Pseudonym> non_socialist: I seem to recall that some clever Haskeller has written a tutorial about that.,
16:21:12 <LoganCapaldo> it's like my keyboard is randomly dropping etters
16:21:16 <Pseudonym> ?quote tutorial
16:21:17 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
16:21:19 <Pseudonym> That's it.
16:21:36 <LoganCapaldo> must press keys harder apparently
16:21:44 <Corun> Good plan.
16:21:50 <non_socialist> so if you still exist in 3 dimensional space, you are a newb?
16:22:40 <LoganCapaldo> 2) A Monad shall obey the instructions of a programmer insofar as those instructions do not conflict with the first law.
16:23:33 <LoganCapaldo> it's funnier with robots I think
16:25:59 <LoganCapaldo> what do you call a mechanical oarsman?
16:26:04 <LoganCapaldo> a rowbot
16:26:21 * AshyIsMe listens to the crickets
16:26:45 <dobblego> fold -> catamorphism as scan -> ?
16:28:13 <johnnowak> what do you call it when a feline, is like..changing.. and.. stuff.. and... catamorphism!
16:28:33 <LoganCapaldo> Might Catamorphin Power Rangers
16:28:51 <LoganCapaldo> don't slip on a bannana
16:29:06 * johnnowak falls and breaks bones
16:29:26 * wagle_home looks yellow
16:29:34 * Pseudonym is curious yellow
16:29:36 <LoganCapaldo> anamorphism? hylomorphism?
16:30:04 <LoganCapaldo> dogamorphism?
16:30:17 <dons> dcoutts, Igloo: when do we look to get cabal-install into the main cabal distributoin
16:30:37 <johnnowak> morphomorphism
16:30:48 <wagle_home> i need a human-computer interface where i can just mentally point at an idea, "click" on it, and say "THAT thing!"
16:30:54 <ddarius> Annamorphism.  Ivanamorphism.  Fyodomorphism.
16:31:08 <wagle_home> ... at an idea in my brain ...
16:31:11 <LoganCapaldo> metamorphism
16:31:20 <wagle_home> lessomorphism
16:31:24 <johnnowak> Mr. Morphism
16:31:40 <dobblego> anamorphism is unfoldr which can be written with MonadPlus I think
16:31:43 <Corun> MONOMORPHISM
16:31:45 <LoganCapaldo> isoceles triagle
16:31:57 <johnnowak> rampant fish
16:32:39 <LoganCapaldo> ickthyomorphism
16:32:54 <non_socialist> whats morph is when a guy had big boobs installed?
16:33:20 <rabby> hi
16:33:28 <sarehu> @quote docious
16:33:28 <lambdabot> stepcut says: endo-hylo-cata-ana-expi-ali-docious
16:33:48 <rabby> why is there a illegal pattern syntax inside: str2lower s = [c|chr2lower(c)<-s]
16:34:14 <jfredett> is Data.Set a monad? it seems like it should be... :/
16:34:15 <LoganCapaldo> chr2lower is not a constructor
16:34:20 <sarehu> jfredett: no
16:34:27 <sarehu> monads can't enforce Ord
16:34:30 <dons> > [ toLower c | c <- "HASKELL" ]
16:34:32 <johnnowak> @protontorpedo
16:34:32 <lambdabot> that dude is selling u  a book
16:34:35 <jfredett> damn...
16:34:39 <lambdabot>  "haskell"
16:34:47 <LoganCapaldo> and therefore, ch2tolower c is not a legal pattern
16:34:47 <dons> > map toLower "HASKELL"
16:34:48 <lambdabot>  "haskell"
16:35:10 <dons> rabby: so you apply functions on the lhs of the |
16:35:12 <Pseudonym> I want to think up a use for "pseudomorphism".
16:35:20 <rabby> oh, thought it works after the | the same way
16:35:31 <hpaste>  Cale pasted "associative tree generator" at http://hpaste.org/5608
16:35:31 <sarehu> jfredett: somewhere in the proggosphere there's a post dealing with that and iirc they do strange things with splitting up the typeclass
16:35:32 <Pseudonym> http://en.wikipedia.org/wiki/Cryptomorphism
16:35:32 <lambdabot> Title: Cryptomorphism - Wikipedia, the free encyclopedia
16:35:34 <dons> > [ c | Just c <- [ Just 1, Nothing, Just 2, Nothing , Just 4] ]
16:35:36 <lambdabot>  [1,2,4]
16:35:44 <dons> on the rhs it works like a filter, against a constructor
16:35:50 <Pseudonym> I like that term.
16:35:56 <dons> which is super useful for filtering xml, btw
16:36:16 <jfredett> Pseudonym: how about a morphism that is a partial function
16:36:22 <awesame> geez
16:36:30 <jfredett> I've heard some arguments that partial functions should be called pseudofucntions
16:36:31 <rabby> dons: now i am really confused... Just works behind and my own function chr2lower not behind the | :(
16:36:37 <wagle_home> > length ("HASKELL" >> "ROCKS!")
16:36:38 <lambdabot>  42
16:36:48 <dons> rabby: right. only data constructors are allowed in the pattern
16:36:49 <Cale> awesame: what's up?
16:36:55 <dons> as for normal function patterns, or guards.
16:37:05 <rabby> but before the | "everything" is allowed
16:37:20 <dons> right. you're applying something to the result of the generator on the rhs
16:37:23 <awesame> I just realized that I would have saved a whole lot of incomprehension if someone had said to me many moons ago "accumulate = foldl1"
16:37:33 <Cale> hehe
16:37:41 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
16:37:42 <lambdabot> Title: Fold Diagrams - CaleWiki
16:37:48 <Cale> That's how I think about folds.
16:38:00 <awesame> yeah, I get them all now
16:38:38 <rabby> dons: if i put it before |, i do not have to think about whether it is a data contructor or not, right?
16:38:45 <awesame> I just had to do some mental gymnastics to hook these weird things that I constantly got confused to an easy concept I already have
16:39:36 <awesame> I would frequently mistake foldr1 for (\x y -> foldl1 x (reverse y)) instead of (\x y -> foldl1 (flip x) y)
16:40:06 <wagle_home> Cale, nice
16:40:55 <Cale> > foldr f z [1..5]
16:41:02 <Cale> ...
16:41:10 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
16:41:14 <Cale> aha
16:41:22 <Cale> not quite dead yet :)
16:41:35 <Cale> > foldl f z [1..5]
16:41:36 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
16:41:41 <wagle_home> > f 1
16:41:42 <lambdabot>  Add a type signature
16:41:45 <Cale> > foldl (flip f) z [1..5]
16:41:46 <lambdabot>  f 5 (f 4 (f 3 (f 2 (f 1 z))))
16:41:53 <Cale> > foldl (flip f) z (reverse [1..5])
16:41:54 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
16:42:08 <non_socialist> some lisp people say that typed languages crush 'exploratory' programming si that so?
16:42:09 <dons> rabby: it means something else on the rhs
16:42:15 <Cale> > foldl (flip f) z (reverse [1..5]) == foldr f z [1..5] :: Expr
16:42:18 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Bool'
16:42:20 <dons> > [ c | Just c <- [ Just 1, Nothing, Just 2, Nothing , Just 4] ]
16:42:20 <lambdabot>  [1,2,4]
16:42:22 <Cale> > foldl (flip f) z (reverse [1..5]) == (foldr f z [1..5] :: Expr)
16:42:23 <lambdabot>  True
16:42:24 <dons> > [ Just c | c <- [ Just 1, Nothing, Just 2, Nothing , Just 4] ]
16:42:26 <lambdabot>  [Just (Just 1),Just Nothing,Just (Just 2),Just Nothing,Just (Just 4)]
16:42:40 <mokus> non_socialist: consider this little chat with lambdabot a counterexample
16:42:49 <Cale> I rather like this algebraic aproach to testing afforded by the Expr type :)
16:42:57 <wagle_home> cant run a program to see what it does unless it type checks..  (you might not care if it crashes)
16:43:12 <sarehu> non_socialist:
16:43:13 <sarehu> ?fag
16:43:14 <lambdabot> The answer is: Yes! Haskell can do that.
16:43:20 <sarehu> whoops, wow
16:43:25 <Cale> sarehu: that's supposed to be @faq :)
16:43:28 <johnnowak> @protontorpedo
16:43:28 <lambdabot> The things I dotn get about relatinal databases is that they take wrok to maintain
16:43:47 <mokus> wagle_home: the error when the typecheck fails often gives more insight into why it would've crashed if it had run
16:43:49 <Cale> @keal
16:43:52 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
16:44:16 <sarehu> > Just 3 `mplus` le Nothing
16:44:17 <lambdabot>  Just 3
16:44:20 <awesame> > foldr1 (flip f) z [1..5]
16:44:21 <lambdabot>  Couldn't match expected type `[c]' against inferred type `Expr'
16:44:22 <gwern> ?fag around, can Haskell?
16:44:23 <lambdabot> The answer is: Yes! Haskell can do that.
16:44:28 <awesame> oops
16:44:30 <Cale> sarehu: What is this, French Haskell?
16:44:40 <sarehu> ooh la la
16:44:41 <awesame> > foldr1 (flip f) [1..5]
16:44:42 <lambdabot>  Add a type signature
16:44:52 <Cale> > foldr1 (flip f) [1..5] :: Expr
16:44:53 <lambdabot>  f (f (f (f 5 4) 3) 2) 1
16:45:06 <wagle_home> > f 1 :: Expr
16:45:07 <lambdabot>  f 1
16:45:08 <hpaste>  (anonymous) annotated "wxwidgets" with "answer" at http://hpaste.org/5606#a2
16:45:27 <awesame> > foldl1 f [1..5] :: Expr
16:45:29 <lambdabot>  f (f (f (f 1 2) 3) 4) 5
16:45:52 <awesame> oops, looks like I got that earlier lambda wrong
16:45:57 <Cale> > foldr1 (flip f) (reverse [1..5]) :: Expr
16:45:58 <lambdabot>  f (f (f (f 1 2) 3) 4) 5
16:46:03 <awesame> there we go
16:46:35 <Cale> In the scheme SRFI, they screwed up one of the folds, I think.
16:47:00 <wagle_home> mokus, thats why type errors are so clear that they have tools to help us comprehend them?
16:47:26 <sarehu> > 2
16:47:27 <lambdabot>  2
16:47:47 <Cale> wagle_home: hm?
16:47:54 <Cale> wagle_home: They do?
16:48:13 <wagle_home> > (fix $ \f -> \(n,a) -> if (n == 0) then a else f (n -1, a * n)) (4,1) :: Expr
16:48:15 <lambdabot>  1 * 4 * (4 - 1) * (4 - 1 - 1) * (4 - 1 - 1 - 1)
16:48:49 <wagle_home> i put chameleon on my reading list yesterday
16:49:04 <Cale> > product [1..4] :: Expr
16:49:05 <lambdabot>  1 * 1 * 2 * 3 * 4
16:49:36 <wagle_home> <ddarius> @google Haskell "type debugger"
16:49:36 <Cale> > (1 - 1 :: Expr) == 0
16:49:37 <lambdabot>  True
16:49:51 <wagle_home> @google Haskell "type debugger"
16:49:58 <lambdabot> http://www.cs.mu.oz.au/~pjs/papers/p108-stuckey.pdf
16:50:04 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 4 :: Expr
16:50:05 <lambdabot>  4 * ((4 - 1) * ((4 - 1 - 1) * ((4 - 1 - 1 - 1) * 1)))
16:50:57 <wagle_home> just a tail recursive factorial i had laying around my input history..  just discovered type Expr..  cool
16:51:27 <Cale> Expr is sufficiently cool that it should come with GHC :)
16:51:31 <Cale> It's useful for learning.
16:51:34 <mokus> wagle_home: what tools?
16:51:40 <wagle_home> @google Haskell "type debugger"
16:51:42 <lambdabot> http://www.cs.mu.oz.au/~pjs/papers/p108-stuckey.pdf
16:51:51 <sarehu> where does this Expr come from?
16:51:57 <mokus> I've done fine all these years without tools to explain the type errors
16:52:06 <Cale> sarehu: A blog post not long ago...
16:52:14 <wagle_home> you havent done anything ...uh..  exciting
16:52:15 * Cale finds the link
16:52:17 <sarehu> ok
16:52:23 <mokus> it's just one of those things you learn by banging your head against the wall till it's second nature ;-)
16:53:31 <Cale> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
16:53:33 <lambdabot> Title: Simple reflection of expressions - 21 thoughts, http://tinyurl.com/2yeszc
16:54:48 <sarehu> ok thanks!
16:54:48 <sarehu>  
16:56:05 <awesame> > foldl (+) 10 []
16:56:13 <lambdabot>  10
16:56:17 <awesame> why does that work?
16:56:24 <wagle_home> scanr (+) [1..5] :: Expr
16:56:33 <awesame> shouldn't it return (+ 10)?
16:56:48 <wagle_home>  > foldl (+) 10 [] :: Expr
16:57:01 <wagle_home> > foldl (+) 10 [] :: Expr
16:57:02 <lambdabot>  10
16:57:18 <wagle_home> > foldl (+) 10 [1] :: Expr
16:57:20 <lambdabot>  10 + 1
16:57:36 <wagle_home> > scanr (+) [1..5] :: Expr
16:57:37 <lambdabot>  Couldn't match expected type `Expr'
16:57:51 <awesame> I guess empty lists are special-cased in foldl?
16:58:08 <wagle_home> > foldl (+) 10 [1,2] :: Expr
16:58:10 <lambdabot>  10 + 1 + 2
16:58:30 <wagle_home> what should it do when there are 0 elements in the list?
16:58:36 <sarehu> > foldr (+) 10 [1,2] :: Expr
16:58:37 <lambdabot>  1 + (2 + 10)
16:58:39 <wagle_home> i showed you 1 and 2 element lists
17:00:06 <sarehu> @src foldl
17:00:07 <lambdabot> foldl f z xs = lgo z xs
17:00:07 <lambdabot>     where lgo z []     =  z
17:00:07 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:00:25 <sarehu> foldl (+) 10 [] = lgo 10 [] = 10
17:00:58 * wagle_home gets rid of the @src foldl sitting in his buffer waiting for awesame  to either see the light, or continue being puzzled
17:00:59 <pchiusano> how would you define scanr in terms of foldr?
17:02:11 <awesame> wagle_home: like I said, I assumed it would yeild (+ 10)
17:02:25 <awesame> it's missing an argument
17:02:50 <wagle_home> awesame:
17:02:57 <wagle_home> :t (+ 10)
17:02:58 <lambdabot> forall a. (Num a) => a -> a
17:03:05 <sarehu> pchiusano: the question you specifically want to think about is, what function do you substitute for (:), and what do you substitute for [], in the list?
17:03:07 <wagle_home> :t (1 + 10)
17:03:08 <lambdabot> forall t. (Num t) => t
17:03:13 <awesame> oh, yeah, I see the problem
17:03:22 <wagle_home> :t (1 + (2 + 10))
17:03:24 <lambdabot> forall t. (Num t) => t
17:03:37 <pchiusano> sarehu: yes, I am having trouble wrapping brain around it
17:03:48 <awesame> wagle_home: that was enlightening, thanks
17:03:52 <sarehu> pchiusano:   foldr f x (1 : (2 : (3 : (4 : []))))    ->
17:04:02 <wagle_home> awesame, cool..  thanks
17:04:04 <sarehu> 1 `f` (2 `f` (3 `f` (4 `f` x)))
17:04:27 <pchiusano> sarehu: yes, I know...
17:04:50 <sarehu> pchiusano: so you know that scanr evaluates to a list.  which means that f will combine an element and a list to produce a new list.
17:05:08 <pchiusano> yes...
17:05:20 <pchiusano> aha!
17:06:05 <sarehu> aha?  is that a good aha or is it a bad aha where you've tracked down my ip to an exact address with satellites and now you're going to steal my computer for giving bad advice?
17:06:41 <pchiusano> scanr f = foldr (\partial a -> (f a) : partial)
17:06:58 <sarehu> \a partial
17:07:17 <sarehu> er, no.. that's still wrong :P  f takes two arguments
17:07:31 <pchiusano> erm, you are right
17:08:08 <pchiusano> I think you need a helper function
17:08:11 <sarehu> first ask yourself what the base case looks like.. scanr f x [] = ...
17:09:33 <wagle_home> :t scanr
17:09:34 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
17:11:03 <lament> forget everything i said about type inference not being important an hour ago. I have repented. (C# struggles)
17:11:04 <pchiusano> scanr f = foldr (\a partial -> (f a (head partial)) : partial)
17:12:09 <gwern> I always wonder at people using weird versions of GHC. the docs for postmaster talked about using 'GHC 6.5', and Flippi says it's only been tested on 'GHC 6.21'
17:12:13 <pchiusano> > let myScanr f = foldr (\a p -> (f a (head p)) : p) in myScanr (:) [] [1,2,3,4,5]
17:12:21 <lambdabot>  Exception: Prelude.head: empty list
17:12:22 <gwern> I just wonder, how did they wind up with such odd ghc versions
17:13:01 <pchiusano> oh, right
17:13:04 <wagle_home> oh oh..  my notebook has tried 3 times so far to boot with 10.5.2
17:13:47 <pchiusano> > let myScanr f z = foldr (\a p -> case p of [] -> z; _ -> (f a (head p)) : p) in myScanr (:) [] [1,2,3,4,5]
17:13:47 <lambdabot>   add an instance declaration for (Num [a])
17:13:47 <lambdabot>     In the expression: 1
17:14:00 <gwern> @where dumatel
17:14:02 <lambdabot> I know nothing about dumatel.
17:14:11 <pchiusano> bleh
17:16:21 <Laney> Anyone know if there's a way of showing (Text.)Xhtml fragments without escaping the entities?
17:17:14 <Cale> > iterate f x
17:17:16 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
17:18:13 <lament> > f
17:18:13 <lambdabot>  Add a type signature
17:18:38 <wagle_home> > let myScanr f = foldr (\a p -> (f a (head p)) : p) in myScanr (:) [] [1,2,3,4,5] :: Expr
17:18:39 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[[a]]'
17:18:39 <Cale> > gcd 1 2 :: Expr
17:18:40 <lambdabot>  abs 1 `rem` abs 2
17:18:42 <lament> :t f
17:18:42 <lambdabot> Not in scope: `f'
17:18:52 <wagle_home> bah
17:19:01 <Cale> > gcd 360 25 :: Expr
17:19:02 <lambdabot>  abs 25 `rem` (abs 360 `rem` abs 25)
17:19:17 <wagle_home> :t let myScanr f = foldr (\a p -> (f a (head p)) : p) in myScanr (:) [] [1,2,3,4,5]
17:19:18 <lambdabot> forall a. (Num a) => [[a]]
17:19:33 <lament> Cale: how does it work?
17:19:40 <wagle_home> pchiusano, see that type up there
17:19:43 <wagle_home> ?
17:20:08 <monochrom> @type liftM return
17:20:08 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 a1 -> m1 (m a1)
17:20:12 * monochrom giggles
17:21:14 <monochrom> My intended use: "return" refers to that of list, i.e., \x -> [x].  "liftM return" refers to: liftM return m = do x<-m; return [x].
17:21:17 * monochrom giggles more
17:22:46 <gwern> this is so annoying. the release and book for Dumatel don't mention any release
17:22:49 <gwern> *license
17:23:02 <gwern> I hate when software is there with all its pieces, but doesn't tell you its license!
17:23:22 <monochrom> Is it public domain?
17:23:30 <gwern> oh, and get this - the cabal file has a license-file field
17:23:36 <monochrom> Is it trade secret, NDA stuff?
17:23:37 <gwern> can you guess what it is?
17:23:49 <dobblego> wagle_home, what about it?
17:24:03 <monochrom> it is copied from someone's template cabal file?
17:24:09 <gwern> it says: license-file:    "../../license.txt"
17:24:28 <monochrom> Does ../../license.txt exist?
17:24:33 <gwern> the really funny thing is, I unzipped it in my ~/, and you know what's ../../ from the cabal file? ~?
17:24:36 <gwern> ~/
17:24:41 <wagle_home> dobblego, ?
17:24:58 <dobblego> wagle_home, you asked, "see that type up there?", so I'm wodnering what about it
17:25:33 <monochrom> That depends on how deep the cabal file sits.
17:25:37 <gwern> so it goes, ~/dm/src, and in src/ there's dm.cabal
17:25:46 <wagle_home> dobblego, he wants a list to be returned, but the type is list of lists
17:25:52 <gwern> and dm.cabal wants ../../license. oy
17:25:59 <dobblego> wagle_home, oh, you're just pointing out the type error, ok
17:26:05 <inimino> gwern: copy your preferred license to ~/license, problem solved
17:26:11 <monochrom> so it simplifies to ~/license.txt
17:26:28 <gwern> inimino: lol
17:26:35 <gwern> monochrom: in short, yes
17:26:53 <monochrom> Oh hahaha, I see what the author was thinking!
17:26:54 <gwern> obviously if I had unpacked it in ~/bin, it'd become ~/bin/license.txt and so on
17:27:09 <gwern> http://www.haskell.org/dumatel/distrib/1.02/license.txt
17:27:18 <gwern> they left the license on the website... >.<
17:27:32 <gwern> but it's a non-free license, I think, so I shan't inquire further
17:28:07 <gwern> clause c isn't so bad, but b,d,and e are questionable
17:29:08 <gwern> ..and DoCon has the same license as Dumatel. so much for putting them on hackage
17:29:27 <dons> what's the license?
17:30:02 <dons> oh come on. redistribution is allowed
17:30:05 <dons> so let's redistribute!
17:30:25 <dons> you're too conservative about this stuff, gwern :)
17:30:29 <gwern> sorry dons. I'm a free software fanatic
17:30:49 <dons> so you personally won't upload that kind of stuff?
17:31:07 <gwern> I'm not going to email them and bug'em, but I'll be damned if I work for free on nonfree stuff for anything short of missioncritical stuff
17:31:07 <dons> its not as if we can't though -- hackage is clearly ok under that license
17:31:17 * gwern has a problem with that, too, actually
17:31:42 <thoughtpolice> it could be worse and sport a license like ion3 :)
17:32:00 <gwern> thoughtpolice: yes, but ion3 is why we have xmonad in a sense
17:32:18 <dons> so the license says what, e) about publications, d) include docs c) use a different name
17:32:38 <thoughtpolice> i'm just being comical.
17:32:42 <thoughtpolice> or at least, trying. :(
17:33:30 <gwern> yeah. the different name isn't all that much of a problem - TeX has that clause, but including docs and setting conditions on free speech distinctly smacks of nonfree to me
17:38:04 <dolio> @seen Philippa_
17:38:04 <lambdabot> Philippa_ is in #oasis, #scannedinavian, #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I don't know when Philippa_ last spoke.
17:44:29 <non_socialist> how do I check if cabal comes with ghc ?
17:44:38 <non_socialist> http://www.haskell.org/cabal/download.html
17:44:38 <lambdabot> Title: The Haskell Cabal
17:45:02 <non_socialist> I have ghc 6.8.2-1
17:47:14 <Lemmih> non_socialist: The 'cabal' program is also called cabal-install.
17:47:18 <non_socialist> GHC 6.8.2 includes Cabal 1.2.3.0.
17:47:22 <non_socialist> oh
17:47:32 <non_socialist> so if I do runghc cabal-install zlib
17:47:37 <non_socialist> that should isntall zlib?
17:48:17 <Lemmih> No, you have to use the 'cabal' program.
17:48:57 <non_socialist> hm
17:49:14 <non_socialist> seems liek i am stuck with chicken egg problem sicne cabal needs itself to isntall
17:49:21 <non_socialist> ghc should have cabal right?
17:49:51 <Lemmih> non_socialist: Yes, ghc will have the library called 'cabal'.
17:50:17 <non_socialist> ok, so could you please show an example of invoking cabal?
17:50:19 <non_socialist> please?
17:50:21 <dmwit> There are two ways to get a package: 1. cabal-install <package-name> (but this requires the extra program cabal-install, which does not come with cabal) or 2. download and unpack the package, then run:
17:50:43 <dmwit> runghc Setup.[l]hs configure && runghc Setup.[l]hs build
17:51:17 <dmwit> (Where I put 'l' in brackets, since it is sometimes Setup.hs and sometimes Setup.lhs.)
17:51:31 <non_socialist> when I run that it complains of missign zlib and http
17:51:51 <dmwit> Then, you need to install those packages (or perhaps those libraries) first.
17:52:10 <dmwit> What are you trying to build?
17:52:15 <non_socialist> cabal-install-0.4.0]# runghc Setup.lhs configure Configuring cabal-install-0.4.0... Setup.lhs: At least the following dependencies are missing:     zlib >=0.3, HTTP >=3000.0&&<3001.1
17:52:17 <non_socialist> happs
17:52:53 <dmwit> Okay, to build cabal-install, you can probably just grab the zlib and http packages from hackage.
17:53:11 <non_socialist> ok
17:53:13 <dmwit> Use the same commands (runghc Setup.hs configure, etc.) to build them.
17:53:32 <dmwit> Until you have cabal-install, you'll have to do the dependency chasing manually. =/
17:55:31 <non_socialist> heh
17:57:39 <non_socialist> by poseidon its working
17:58:07 <dmwit> An interesting choice of deity to invoke.
17:58:15 <dmwit> Do you program in the depths of the ocean?
17:58:31 <EvilTerran> best water-cooling system EVAR
17:58:42 <dmwit> haha
17:58:48 <EvilTerran> you can really overclock at a few hundred meters down
17:59:01 <dmwit> Gotta clean the salt out of the system every few days, though, that can be a real bummer.
17:59:22 <dmwit> ?losers
17:59:23 <lambdabot> Maximum users seen in #haskell: 463, currently: 422 (91.1%), active: 14 (3.3%)
17:59:51 <dmwit> Huh, that "maximum" statistic doesn't seem to be as monotonic as it ought to be.
18:00:15 <sarehu> what?
18:00:43 <EvilTerran> if \b breaks before it gets @flushed, sometimes it forget
18:00:45 <EvilTerran> s
18:00:47 <dmwit> I could swear it was up above 470 a few days ago.  But then, \bot has been up and down a few times.
18:00:54 <dmwit> yeah
18:02:44 <dmwit> Oooo, dinner!
18:06:05 <non_socialist> I am a poltheist first, and poseidon worshipper second, I also liek crom, odin, and the greath cthulhu
18:06:12 <non_socialist> dooz this si woking!!
18:06:14 <non_socialist> oow yeah!!
18:09:15 --- mode: ChanServ set +o allbery_b
18:09:51 --- mode: allbery_b set -b *!*=zoOmBiOZ@81.8.158.*
18:10:28 --- mode: allbery_b set +b *!*i=931510*@*.com/x-fc42b7913b48d8f2
18:10:28 --- kick: non_socialist was kicked by allbery_b (allbery_b)
18:10:51 --- mode: allbery_b set -o allbery_b
18:12:32 <flippo> What a silly person.
18:17:10 <Cale> Uh...
18:17:16 <Cale> That's a little harsh perhaps.
18:17:30 --- mode: ChanServ set +o Cale
18:17:35 --- mode: Cale set -b *!*i=931510*@*.com/x-fc42b7913b48d8f2
18:17:41 --- mode: Cale set -o Cale
18:18:10 <Cale> He is actually a Haskell user :)
18:21:26 <sarehu> ((ccc ccc) (ccc ccc))
18:22:36 <visof> how can i define this function :
18:23:09 <Sgeo> /amsg BRB
18:23:28 <visof> foo xs = [head xs , head (tail xs ) , head (tail (tail xs ), head (tail (tail (tail ...........xs)))))))
18:23:30 <visof> ?
18:23:34 <visof> ]
18:23:52 <dmwit> :t tails
18:23:55 <lambdabot> forall a. [a] -> [[a]]
18:24:01 <sarehu> :t id
18:24:01 <lambdabot> forall a. a -> a
18:24:03 <dmwit> > map head . tail . tails $ "hey"
18:24:05 <lambdabot>  Exception: Prelude.head: empty list
18:24:25 <dmwit> > map head . init . tails $ "hey"
18:24:26 <lambdabot>  "hey"
18:24:38 <dmwit> Heh, sarehu was faster than me. =P
18:29:24 <visof> map (x1  ++)  [x1,x2,x3]
18:29:28 <visof> map (x2 ++)  [x1,x2,x3]
18:29:31 <visof> map (x3 ++)  [x1,x2,x3]
18:29:49 <visof> (x1 ++) , (x2 ++ ) , (x3 ++)
18:30:01 <visof> can we make function to generate them ?
18:30:35 <visof> it is depend on list elements
18:30:53 <sarehu> map (++)?
18:30:58 <visof> if we have [x1,x2,x3,x4] so we have
18:31:02 <visof> x4
18:32:21 <Twey> visof: mapCat n xs = map ((xs !! n) ++) xs
18:32:25 <Twey> Something like that?
18:32:47 <visof> :t mapCat
18:32:48 <lambdabot> Not in scope: `mapCat'
18:32:54 <Twey> @pl \n xs -> map ((xs !! n) ++) xs
18:32:54 <lambdabot> join . ((map . (++)) .) . flip (!!)
18:33:02 <dmwit> > let xs = ["hey", " world"] in xs >>= \x -> map (x ++) xs
18:33:03 <lambdabot>  ["heyhey","hey world"," worldhey"," world world"]
18:33:32 <visof> wow
18:33:38 <visof> that's it
18:33:41 <Twey> Oh
18:33:51 <Twey> I misunderstood the question then :-P
18:34:16 <visof> Twey np
18:34:28 <dmwit> > let xs = ["hey ", "world "] in liftM2 (++) xs xs
18:34:29 <lambdabot>  ["hey hey ","hey world ","world hey ","world world "]
18:34:38 <visof> dmwit but i can't understand this code
18:34:52 <sarehu> mapCat is not amused
18:34:58 <dmwit> heh
18:34:59 <visof> what liftM2 is?
18:35:05 <dmwit> visof: Have you played with monads?
18:35:09 <dmwit> ?src liftM2
18:35:10 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:35:12 <visof> no
18:35:27 <sarehu> > join (liftM2 (++)) ["hey ", "world "]
18:35:28 <lambdabot>  ["hey hey ","hey world ","world hey ","world world "]
18:35:40 <dmwit> sarehu: Right, that was my next step. =)
18:35:49 <visof> can i do it without monads
18:35:53 <visof> ?
18:35:57 <dmwit> visof: Of course:
18:36:04 <BMeph> > map (:[]) "abracadabra"
18:36:05 <lambdabot>  ["a","b","r","a","c","a","d","a","b","r","a"]
18:36:15 <BMeph> ?bo
18:36:15 <lambdabot> :)
18:36:21 <dmwit> > let xs = ["hey ", "world "] in [x ++ y | x <- xs, y <- xs]
18:36:21 <lambdabot>  ["hey hey ","hey world ","world hey ","world world "]
18:36:36 <sarehu> but that's a monad comprehension!
18:36:49 <dmwit> sssh ;-)
18:37:24 <dmwit> visof: Have you played with list comprehensions before?
18:37:39 <visof> ya
18:37:45 <visof> but not much
18:37:45 <dmwit> visof: If not, we have to go back to even more primitive functions, and things can start to get a bit confusing. =P
18:38:19 <visof> dmwit that's ok thank you
18:40:00 <sarehu> @pl \f x -> f x x x
18:40:00 <lambdabot> join . join
18:40:02 <sarehu> ok
18:40:07 <sarehu> @pl \f x -> f x x x x
18:40:07 <lambdabot> join . join . join
18:40:09 <sarehu> ok!
18:40:25 <BMeph> visof: You can do just about anything without monads, but then, you could travel across a continent on foot, too. It depends on whether all you want to do is get there, or if you're looking to do something along the way. And whether you want to do anything else afterwards, too. ;)
18:40:37 <sarehu> hah,    join (.) join = join . join
18:40:52 <dmwit> sarehu: heh, neat
18:41:42 <visof> is the main role of monad in functional programming be I/O effects ?
18:41:50 <dmwit> No!
18:41:59 <dmwit> That's a common misconception for new players.
18:42:13 <dmwit> But I think monads encompass a really powerful abstraction idea.
18:42:16 <TomMD> The main use of a monad is for Maybe computations ;-)
18:42:34 <dynamix> visof, it might help to think of monads like tags+ special behaviour.
18:42:39 <thoughtpolice> I/O happens to be one thing we can describe as 'monadic.' we can also use monads for continuations, state, parsers and lots of other things.
18:43:15 <dynamix> so in the List Monad.. every thing is tagged "List" and you cannot mix them with those which are not tagged. the nuclear waste example on the wiki is good
18:43:24 <dmwit> The reason monads are cool is because many libraries can be described in terms of them.  When that's true, you can build a set of combinators that do common, useful things... in *all* monads!
18:43:27 <Cale> The main idea behind monads is to unify "control structure" like operations across many libraries.
18:43:59 <dmwit> So Control.Monad is actually a set of "library enhancers" that work for a wide variety of libraries.
18:44:03 <Cale> I actually really dislike the nuclear waste analogy :)
18:44:07 <thoughtpolice> if you want to get an idea of how general a monad is - beyond I/O - i think sigfpe's post is a great start:
18:44:10 <thoughtpolice> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:44:11 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
18:44:29 <dmwit> I think that's pretty neat, and especially because it doesn't really need to have any direct language support.
18:44:33 <dolio> @yow
18:44:34 <lambdabot> ... the MYSTERIANS are in here with my CORDUROY SOAP DISH!!
18:44:37 <visof> ok
18:44:50 <dynamix> or lookup all about monads :) the best tute ever
18:44:52 <dynamix> on monads
18:45:05 <thoughtpolice> just remember: monads are simple. :) like the post's title says, you may've already invented the framework that is a monad...
18:45:13 <thoughtpolice> it's just a matter of picking out the general pattern and giving it a name.
18:46:39 <visof> after this
18:47:44 <visof> if i define data Foo = Sat | Sun | Mon | Tue .........
18:48:01 <dynamix> :t ( (\n rs-> return (take n rs) ) n )
18:48:04 <lambdabot> Not in scope: `n'
18:48:10 <dynamix> why ?
18:48:16 <visof> and want to make function with  type Int -> foo
18:48:20 <dynamix> :t ( (\n rs-> return (take n rs) ) $ n )
18:48:21 <lambdabot> Not in scope: `n'
18:48:45 <visof> if i define data Foo a = Sat | Sun | Mon | Tue .........
18:48:58 <visof> foo 1  = Sun
18:49:10 <visof> foo 1 = Sat
18:49:12 <visof> sorry
18:49:21 <visof> foo 2 = Sun
18:49:29 <visof> and so on
18:49:34 <dmwit> visof: Use "deriving (Enum)" at the end of your data type.  Much simpler.
18:49:39 <thoughtpolice> visof: you can get the compiler to derive the Enum class for you
18:49:54 <visof> how
18:49:55 <visof> ?
18:50:10 <dmwit> dynamix: That "n" is outside of the lambda, so it's dropped out of scope by the time you try to apply it.
18:50:11 <thoughtpolice> data Foo = Sat | Sun | Mon | ... deriving (Eq,Enum)
18:50:40 <thoughtpolice> visof: after that you can do "toEnum 1 :: Foo" and for example, it will return the constructor 'Sun'
18:50:51 <thoughtpolice> because Enum indexes at 0, i.e. 'toEnum 0 :: Foo' would be 'Sat'
18:51:27 * dmwit wonders...
18:51:39 <dmwit> ?let data Foo = Sat | Sun deriving (Eq,Enum)
18:51:39 <lambdabot> Invalid declaration
18:51:41 <thoughtpolice> of course I think you might rather start at Sun and the go from there, i.e. Foo = Sun | Mon | Tue | Wed | Thurs | Fri | Sat
18:51:42 <dmwit> blast
18:52:34 <dmwit> visof: The nice thing about deriving Enum is that you get notation like [Sun..Sat] for free after that.
18:52:37 <dmwit> ^^
18:52:43 <thoughtpolice> visof: look here for more: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AEnum
18:52:44 <lambdabot> http://tinyurl.com/ovjef
18:53:19 <LoganCapaldo> Sunday | Monday | HappyDays | Tuesday | Wednesday | HappyDays | Thursday | Friday | HappyDays | Saturday | WhatADay
18:54:04 <sarehu> | FileNotFound
18:54:57 <thoughtpolice> | Apocalypse
18:54:58 <dmwit> | Brillant
18:55:07 <visof> sarehu are you bot?
18:55:30 <dmwit> Whoa.  That would be a very sophisticated joke for a bot to make.
18:55:41 <sarehu> I know you are, but what am I?
18:56:04 <visof> wow , it's advanced bot
18:56:20 <dynamix> there are bots that train on human output and use statistical methods to pretend like humans :) i wrote the logic for one a few years ago
18:56:35 <sarehu> your mom is an advanced bot  <- am I doing it correctly?
18:56:56 <dmwit> ?vixen Are you a bot?
18:56:56 <lambdabot> no, why? do i seem "botty"?
18:57:05 <dynamix> spaces not allowed in variable names in a do block :)
18:57:11 <dmwit> ?vixen you're a very advanced bot
18:57:12 <lambdabot> no, how dare you ask if i'm a bot!
18:57:31 <sarehu> is haskell more powerful than perl? or scheme?
18:57:35 <visof> sarehu i don't speak about your mother , why are you rude ?
18:57:39 <dmwit> hahaha
18:57:43 <sarehu> or does it become a mishmash of code?
18:57:43 <nornagon> sarehu: is superman more powerful than batman?
18:57:56 <dmwit> ?keal
18:57:57 <lambdabot> know you know this 24 periods Keal SecretTM
18:58:00 <sarehu> and haskell is not a lisp. correct? holy shit then m learning haskell
18:58:09 <thoughtpolice> yes, unless batman and the flash combined to create batflash
18:58:12 <sarehu> @protontorpedo
18:58:12 <lambdabot> how deos haskell differ from ml or lisp?
18:58:15 <dynamix> haskell frys your brain better when learning. perl when debugging others's code. scheme all the time :)
18:58:38 <thoughtpolice> then not even superman could stop him.
18:59:22 <dmwit> Gah, not even Firefox can stop the Flash.
18:59:53 <sarehu> you just have to use their powers against themselves
18:59:56 <thoughtpolice> the only thing that could reasonably stop batflash is bruce lee. that or perhaps age.
19:00:03 <thoughtpolice> whichever gets to him first
19:00:05 <sarehu> > fix superman
19:00:13 <lambdabot>   Not in scope: `superman'
19:00:28 <dmwit> > fix alcohol
19:00:31 <lambdabot>   Not in scope: `alcohol'
19:00:32 <dmwit> Lies!
19:00:49 <sarehu> > fix al-cobol
19:00:49 <lambdabot>   Not in scope: `cobol'
19:01:00 <sarehu> al-qobol
19:02:11 <sarehu> > let xs = "le foobar" in take (le length xs `div` 2) xs
19:02:17 <lambdabot>  "le f"
19:04:35 <dynamix> @let stufn n rs = ( (\n -> (\rs-> return $ take n rs ) ) $ 3  )
19:04:48 <lambdabot> Defined.
19:05:44 <dmwit> That... is probably not going to do what you want it to do.
19:05:52 <dynamix> @let stufn rs = ( (\n -> (\rs-> return $ take n rs ) ) $ 3  )
19:05:53 <lambdabot> <local>:5:0:     Equations for `stufn' have different numbers of arguments   ...
19:06:01 <dmwit> ?undefine
19:06:01 <dynamix> uh oh how do i undefine?
19:06:01 <lambdabot> Undefined.
19:06:07 <dynamix> @let stufn rs = ( (\n -> (\rs-> return $ take n rs ) ) $ 3  )
19:06:07 <lambdabot> Defined.
19:06:25 <dynamix> > stufn [1,2,3]::Integer
19:06:25 <lambdabot>  Couldn't match expected type `Integer'
19:06:36 <dmwit> Note that the first argument to stufn is completely ignored there.
19:06:44 <dynamix> > stufn ( [1,2,3]::Integer)
19:06:45 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[a]'
19:06:48 <dmwit> > stufn "hey there!" [1, 2, 3]
19:06:48 <lambdabot>   add an instance declaration for (Show (m [t]))
19:06:59 <dynamix> dmwit:  i removed the first arg.
19:07:02 <dmwit> > stufn "hey there!" [1, 2, 3] :: [[Int]]
19:07:03 <lambdabot>  [[1,2,3]]
19:07:12 <dmwit> dynamix: Look again.  Be careful.
19:07:27 <dmwit> dynamix: The "rs" in the lambda is shadowing the "rs" in the function's pattern match.
19:08:07 <dynamix> basically i want it to return a function that takes a list and returns the first n elems inside a monad.
19:08:11 <dmwit> > let stufn rs = take 3 rs in stufn [1..10]
19:08:12 <lambdabot>  [1,2,3]
19:08:47 <dmwit> > let stufn n = return . take n in stufn 3 [1..10] :: [[Int]]
19:08:47 <lambdabot>  [[1,2,3]]
19:08:52 <visof> type is number of values right?
19:09:07 <dmwit> visof: No?
19:09:16 <dynamix> visof, what do you mean?
19:09:18 <visof> and number of types is class
19:09:48 <dmwit> Ah... sort of, yes.  You can think of a type as a set of values.
19:10:02 <visof> also class
19:10:08 <visof> set of types
19:10:11 <visof> righ?
19:10:15 <visof> right?
19:10:20 <dmwit> That one is definitely correct.
19:10:29 <dmwit> The first is... less obviously correct.
19:10:41 <visof> now can we say about Monad set of data types?
19:11:14 <dmwit> Well, it is a set of type constructors, actually.
19:11:46 <visof> dmwit simple example?
19:12:05 <dmwit> Well... this is abusing notation a bit, but:
19:12:22 <dmwit> [a] is a type, but [] is a type constructor that takes a type and yields another type.
19:12:48 <dmwit> So, you could write ([] Int) to mean [Int].  Then [] can be a monad, but [Int] cannot.
19:14:02 <dynamix> :t ( [] Int)
19:14:03 <lambdabot> Not in scope: data constructor `Int'
19:14:21 <dynamix> :t ( []::Int)
19:14:22 <lambdabot>     Couldn't match expected type `Int' against inferred type `[a]'
19:14:29 <dmwit> :k [Int]
19:14:29 <lambdabot> *
19:14:34 <dmwit> :k []
19:14:35 <lambdabot> * -> *
19:14:38 <dynamix> :t ( [Int])
19:14:38 <lambdabot> Not in scope: data constructor `Int'
19:14:43 <dynamix> :t ( [a])
19:14:43 <lambdabot> Not in scope: `a'
19:14:53 <dmwit> dynamix: Those are already types.
19:14:56 <dynamix> :t ( Int a) => [a]
19:14:56 <lambdabot> parse error on input `=>'
19:15:05 <dmwit> dynamix: :t translates between *values* and types.
19:15:15 <dynamix> oh oh.
19:15:16 <dmwit> dynamix: So to use :t, you have to give it a value, not a type.
19:15:39 <dmwit> dynamix: :k translates between types and kinds, if that's what you're looking for?
19:16:28 <dmwit> :k Monad m => m
19:16:29 <lambdabot>     `m' is not applied to enough type arguments
19:16:29 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
19:16:30 <dynamix> yups
19:16:35 <dmwit> huh
19:18:44 <dynamix> visof, thats one more thing you'l eventually want to learn about/ type, kind, class are all different in haskell.  ill let the experts handle your questions on kinds:) [im not one [ yet?] ]
19:21:12 <mrd> sometimes you have to be cruel to be kind
19:23:49 <non_socialist> I got rid of my distros ghc
19:23:54 <non_socialist> amcompiling cghc
19:24:10 <non_socialist> ghc, now do I need to link /usr/bin/ghc to the ghc executible?
19:25:38 <non_socialist> ok no its there
19:25:56 <non_socialist> I have terrible problem with hslogge being needed, but cabal says its there!
19:26:01 <non_socialist> hslogger
19:29:54 <glen_quagmire> T |- v : (p -> p )   what is this kind of notation?
19:30:18 <wagle_home> sequent?
19:30:43 <glen_quagmire> it has denomoinator and numerator too
19:30:52 <mrd> looks like a judgement
19:30:59 <mrd> in an inference rule
19:31:05 <mrd> not a denominator and a numerator
19:31:35 <glen_quagmire> oh logic
19:32:07 <monochrom> @type \e@(Left _) -> e
19:32:10 <lambdabot> forall t t1. Either t t1 -> Either t t1
19:32:56 <monochrom> @type \x -> case x of e@(Left _) -> e; Right x of Right (id x)
19:32:58 <lambdabot> parse error on input `of'
19:33:05 <monochrom> @type \x -> case x of e@(Left _) -> e; Right x -> Right (id x)
19:33:06 <lambdabot> forall t t1. Either t t1 -> Either t t1
19:33:26 <monochrom> @type \f x -> case x of e@(Left _) -> e; Right x -> Right (f x)
19:33:27 <lambdabot> forall t b. (b -> b) -> Either t b -> Either t b
19:33:47 <Cale> @djinn  (b -> b) -> Either t b -> Either t b
19:33:48 <lambdabot> f a b =
19:33:48 <lambdabot>     case b of
19:33:48 <lambdabot>     Left c -> Left c
19:33:48 <lambdabot>     Right d -> Right (a d)
19:35:52 <monochrom> @type either
19:35:53 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:36:50 <wagle_home> :t either id f
19:36:51 <lambdabot> Not in scope: `f'
19:37:18 <wagle_home> :t \f -> either id f
19:37:21 <lambdabot> forall a b. (b -> a) -> Either a b -> a
19:37:54 <dolio> :t either id
19:37:55 <lambdabot> forall a b. (b -> a) -> Either a b -> a
19:37:55 <wagle_home> :t \f -> either Left f
19:37:56 <lambdabot> forall a b b1. (b1 -> Either a b) -> Either a b1 -> Either a b
19:38:20 <glen_quagmire> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 4 :: Expr
19:38:22 <lambdabot>  4 * ((4 - 1) * ((4 - 1 - 1) * ((4 - 1 - 1 - 1) * 1)))
19:38:29 <glen_quagmire> si that Expr lambdabot only?
19:38:35 <wagle_home> :t \f -> either Left (Right . f)
19:38:36 <lambdabot> forall b a b1. (b1 -> b) -> Either a b1 -> Either a b
19:38:49 <glen_quagmire> @index Expr
19:38:49 <lambdabot> bzzt
19:38:54 <wagle_home> @pl \f -> either Left (Right . f)
19:38:54 <lambdabot> either Left . (Right .)
19:39:53 <wagle_home> @pl \f x -> case x of e@(Left _) -> e; Right x -> Right (f x)
19:39:54 <lambdabot> (line 1, column 27):
19:39:54 <lambdabot> unexpected "_"
19:39:54 <lambdabot> expecting variable, "(", operator or ")"
19:40:07 <dolio> > let fac 0 = 1 ; fac (n+1) = (n+1) * fac n in fac 4 :: Expr
19:40:07 <lambdabot>  Parse error in pattern at "in" (column 43)
19:40:13 <wagle_home> @pl \f x -> case x of { e@(Left _) -> e; Right x -> Right (f x) }
19:40:13 <lambdabot> (line 1, column 19):
19:40:13 <lambdabot> unexpected "{"
19:40:13 <lambdabot> expecting variable, "(", operator or end of input
19:41:09 <wagle_home> @pl \f x -> case x of Left x -> Left x ; Right x -> Right (f x)
19:41:10 <lambdabot> (line 1, column 26):
19:41:10 <lambdabot> unexpected ">" or "-"
19:41:10 <lambdabot> expecting variable, "(", operator or end of input
19:41:48 <wagle_home> @pl (\f x -> (case x of Left x -> Left x ; Right x -> Right (f x) ))
19:41:49 <lambdabot> (line 1, column 28):
19:41:49 <lambdabot> unexpected ">"
19:41:49 <lambdabot> expecting variable, "(", operator or ")"
19:42:07 <wagle_home> bah
19:47:50 <wagle_home> glen_quagmire, yes Expr is lambdabot only
19:59:25 <wagle_home> glen_quagmire, see http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
19:59:27 <lambdabot> Title: Simple reflection of expressions - 21 thoughts, http://tinyurl.com/2yeszc
19:59:44 <glen_quagmire> wagle_home: thank you
20:00:18 <Cale> actually, it looks like a number of changes have been made to the version which is in lambdabot
20:00:56 <Cale> So if you want it for personal use, probably the best thing would be to get the lambdabot source and steal the module from there.
20:01:26 <Cale> (It's in scripts/SimpleReflect.hs)
20:01:35 <wagle_home> @src lambdabot
20:01:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:01:43 <wagle_home> 8)
20:03:44 <lispy> dons: do you make the commiter's graph script?
20:03:46 <lispy> dons: it makes graphs like this: http://files.codersbase.com/commiters-2006-12-08.png
20:13:06 <dobblego> is there a way of writing zipN in terms of zip[N-1]?
20:14:19 <LoganCapaldo> ZipList appilcatie instance!
20:14:28 <LoganCapaldo> *applicative
20:14:52 <dolio> @type \f a b c -> zipWith id (zipWith f a b) c
20:14:52 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> [a] -> [b1] -> [b] -> [c]
20:15:23 <dolio> @type \f a b c d -> zipWith id (zipWith3 f a b c) d
20:15:24 <lambdabot> forall b c a b1 c1. (a -> b1 -> c1 -> b -> c) -> [a] -> [b1] -> [c1] -> [b] -> [c]
20:15:27 <LoganCapaldo> > (\x y z -> x + y + z) <$> ZipList [1,2,3] <*> ZipList [2,3,4] <*> ZipList [4,5,6]
20:15:28 <lambdabot>   add an instance declaration for (Show (ZipList a))
20:15:34 <hpaste>  mmorrow annotated "associative tree generator" with "drawing the syntax trees" at http://hpaste.org/5608#a1
20:16:01 <LoganCapaldo> @hoogle ZipList a -> [a]
20:16:02 <lambdabot> Control.Applicative.getZipList :: ZipList a -> [a]
20:16:18 <LoganCapaldo> > getZipList $ (\x y z -> x + y + z) <$> ZipList [1,2,3] <*> ZipList [2,3,4] <*> ZipList [4,5,6]
20:16:20 <lambdabot>  [7,10,13]
20:18:18 <TomMD> > "I'm back and healthy!"
20:18:19 <lambdabot>  "I'm back and healthy!"
20:18:31 <TomMD> hummm... a bit slow in the head, though.
20:18:45 <dobblego> cheers
20:20:28 <sarehu> haskell needs like, 'instance macros' as in..    > zipwise ((\x y z -> x + y + z) <$> [1,2,3] <*> [2,3,4] <*> [4,5,6]) = [7,10,13]
20:20:42 <sarehu> and by 'needs' I mean it would be a cool feature that makes the language more complicated and harder to learn
20:20:54 <sarehu> but still. :)
20:25:51 <yondalf> does anyone know why notFollowedBy in parsec is defined as GenParser tok st tok -> ... and not GenParser tok st [tok]?
20:26:04 <yondalf> or, better still, GenParser tok st a?
20:26:05 <AtnNn> en java: http://java.sun.com/j2se/1.5.0/docs/guide/language/generics.html
20:26:28 <dons> Cale: this could do with some gentle nudging to join the channel, http://matburt.net/?p=33
20:26:28 <lambdabot> Title: MatBurt » Blog Archive » The Evolution of the Imperative Programmer
20:26:32 <dons> ?users
20:26:32 <AtnNn> sorry, wrong channel
20:26:32 <lambdabot> Maximum users seen in #haskell: 463, currently: 412 (89.0%), active: 16 (3.9%)
20:30:05 <hpaste>  jleedev pasted "runST type error" at http://hpaste.org/5609
20:31:12 <dons> irobot.com is cool. on one link, you can buy a vacuum robot, on another "neutrelise IEDs"
20:31:55 <ddarius> I wouldn't want something to deal with IEDs whose manufacturers can't even spell "neutralize"
20:32:18 <dons> oh, virtual visiting robots too.
20:32:22 <dons> the future is here.
20:32:45 <ddarius> Okay.  They can spell.
20:32:54 <dons> hehe
20:33:49 <ddarius> Meh.  I'm more worried about finding IEDs in the first place rather than neutralizing them.
20:34:53 <dons> i wonder if the IED and vacuum robots share code
20:35:21 <dons> it'd be cool to mod one to the other, so the vacuum robot starts blowing up mystery items in your house
20:35:53 <wagle_home> nah..  it'll be like a cat, bringing "presents" home
20:36:57 <dons> heh
20:37:52 <dons> Cale is the centre of #haskell, http://files.codersbase.com/haskell/haskell-current.png
20:38:12 <Cale> hehehe
20:38:38 <gwern> @where unsafePerformIO
20:38:38 <lambdabot> I know nothing about unsafeperformio.
20:38:43 <gwern> :i unsafePerformIO
20:38:53 <lispy> hey dons
20:39:00 <dmwit> ?index unsafePerformIO
20:39:01 <lambdabot> System.IO.Unsafe, Foreign
20:39:02 <lispy> do you remember how this was generated? http://files.codersbase.com/commiters-2006-12-08.png
20:39:35 <dons> Cale, here's something you might like. we have the classic ghc logo, http://www.cse.unsw.edu.au/~dons/images/happy-dino.jpg  a happy green dinosaur. now, for apple's hackage site, we need a fancy logo. like the pretty ones on http://www.apple.com/downloads/macosx/unix_open_source/
20:39:40 <lispy> dons: i want to say you wrote the script, but I could be wrong
20:39:48 <dons> i think david has a script
20:39:59 <lispy> oh okay
20:40:01 <gwern> troublesome. what is this GraphicsUtils module... presumably in HGL
20:40:38 <Cale> dons: Apple has a hackage?
20:40:44 <gwern> (maybe Graphics.HGL.Utils)
20:40:56 <dons> Cale, apple.com/downloads -- you can submit your own mac binaries
20:41:04 <Cale> ah, okay
20:41:05 <dons> and we plan to upload ghc to it, but ghc needs a nice logo
20:41:20 <dons> get ghc on every mac :)
20:41:30 * dons grumbles that ruby comes pre-installed.
20:41:36 <dons> someone paid someone for that
20:41:40 <thoughtpolice> super awesome lambda symbol?
20:41:55 <dons> this is the old ghc logo, http://www.cse.unsw.edu.au/~dons/images/happy-dino.jpg
20:42:00 <dons> circa 1998
20:42:22 <gwern> ew.
20:42:30 <gwern> xmonad and yi's logos are so much better
20:43:06 <dons> 1998 vs 2008, gwern :)
20:43:15 * ddarius liked the happy dino logo.
20:43:22 <dmwit> http://ecx.images-amazon.com/images/I/413MZa0NCQL._AA280_.jpg
20:43:26 <gwern> dons: art is timless. the renaissance had even better logos
20:43:30 <dons> heh
20:43:53 <dmwit> For some reason the happy dino makes me think of sock puppets.
20:44:07 <dons> the renaissance had a few graphic designers. ghc doesn't :)
20:45:02 <gwern> you know, I think I need to write a little blurb on the wiki about why enumerating the things imported by an import is a good thing
20:45:11 <gwern> it makes recovering the code *so* much easier
20:45:26 <ddarius> Don't let your code rot in the first place
20:45:39 <dons> yeah, its a good rule if you're planning for long term maintainability, some argue
20:46:37 <gwern> dons: I'd say my experience in the past few months has turned me into a true believer; there's nothing to argue over in that issue
20:47:04 <gwern> ddarius: yes, and in a perfect world we'd have bunnies, and free chocolate, and GHC autoparallelizing our code and installed by default...
20:47:08 <dons> wow, that's interesting gwern. you might like to summarise that for the -cafe@
20:47:19 <dons> since you've got a fair bit of experience now with what code bit rots
20:47:26 <dons> you could probably write down a general list of things that break
20:47:33 <dons> and let us all know what to be careful about
20:47:45 <dons> what kind of code didn't break? you shoudl write it all down for us :)
20:47:55 <cjb> has anyone here considered using distributed bugtrackers?
20:48:14 <gwern> heh. well, this graphics stuff using HGL is actually surprisingly resilient, modulo some module reorganization
20:48:15 <dons> cjb, yeah. there's an implementation, in haskell, based on darcs
20:48:17 <cjb> I'm considering maintaining one of them.  :)
20:48:22 <cjb> dons: oh, cool, what is it?
20:48:27 <dons> let me find it..
20:48:48 <lispy> cjb: what is a distributed bugtracker?
20:48:52 <dons> matthew-_ wrote it.
20:48:55 <dons> http://www.distract.wellquite.org/
20:48:56 <lambdabot> Title: start [DisTract]
20:49:07 <dons> "We're all now familiar with working with distributed software control systems, such as Monotone, Git, Darcs, Mercurial and others, but bug trackers still seem to be fully stuck in the centralised model: Bugzilla and Trac both have single centralised servers. This is clearly wrong, as if you're able to work on the Train, off the network and still perform local commits of code then surely you should also be able to locally close bugs too."
20:49:09 <cjb> lispy: You store bug state alongside source code, so that a checkout gets both at once.
20:49:32 <dons> gwern: distract should be on hackage...
20:49:36 <dons> and the author's in the channel
20:49:48 <cjb> dons: whoa, I had no idea it's written in Haskell.
20:49:52 <gwern> dons: really?
20:49:54 <lispy> very cool, that snippet is right on
20:50:11 <dons> gwern: yeah, matthew's the author, and i'd forgotten all about this project, due to it not being on hackage.
20:50:13 <lispy> cjb: well, good luck and I hope you getit working
20:50:13 * gwern thought distract merely supported darcs but wasn't in Haskell
20:50:15 <cjb> It's a little strange, though.  I don't want to use Firefox for bugtracking, I want a console client that integrates with commit hooks etc.
20:50:25 <dons> oh, hmm, maybe you're right...
20:50:27 <cjb> lispy: oh, I'm working on a different one.  (Bugs Everywhere)
20:50:37 <dons> ah no, "Compiling DisTract requires that you have a Haskell compiler on your system. GHC 6.6.1 is known to work and is the recommended compiler. Your mileage may vary with other compilers."
20:50:46 <cjb> wow.
20:50:46 <lispy> cjb: especially in the C++ code i'm looking at tonight
20:50:49 <dons> gwern: and its even cabalised.
20:50:55 <ddarius> http://www.distract.wellquite.org/compilation
20:50:56 <lambdabot> Title: compilation [DisTract]
20:50:57 <cjb> so then there could be a console client for it?
20:50:57 <dons> cjb: we do write software in haskell, you know :)
20:51:21 <gwern> yeah. but where's the darcs repo...?
20:51:47 <dons> http://reddit.com/info/68g20/comments/ "Distributed bug tracking: the time has come! [programming] (distract.wellquite.org)"
20:51:49 * gwern sees a source tarball, but that's it
20:51:52 <dons> gwern: it mightn't be kept in darcs.
20:51:57 <gwern> UNPOSSIBLE
20:52:23 <dons> gwern: its in monotone?
20:52:35 <cjb> So odd that it works via JavaScript on Firefox only, though.
20:53:01 <dons> probably only a few patches away..
20:53:29 <gwern> I don't even have monotone installed!
20:53:56 <gwern> and doesn't there need to be a link to the monotone repo then?
20:53:58 <dons> still, this looks like a pretty serious app we should have on hackage.
20:54:07 <dons> matthew-_: around? ping ping!
20:54:38 <cjb> yeah :)
20:55:02 <dons> maybe we should *run* this on hackage too..
20:55:09 <dons> bug tracking for the haskell community?
20:55:25 <cjb> it beats Google Code!
20:55:28 <sclv> i seem to remember it wasn't v. feature complete and wasn't under active development?
20:55:39 <cjb> although, srsly, forcing people to use Firefox to edit bugstate is downright wack.
20:55:57 <dons> yeah, seems like a good idea to have a cli interface
20:56:00 <dons> let's get the code and hack!
20:57:20 <dobblego> I am working with a PhD student doing Formal Concept Analysis, but he uses Java for his work; how can I convince him to take a look at Haskell?
20:57:54 <dobblego> do any of you study FCA?
20:58:49 <ray> requiring firefox seems a bit lazy to me (full disclosure: i use opera)
20:58:51 <dons> i'm not familiar with that, but if you can convince him that whatever abstract domain maps cleaner to haskell, you might be able to hook him in
20:58:53 <lispy> dobblego: what is a 20 word description of FCA?
20:59:03 <dmwit> http://buckwheat.stanford.edu/ghc_only.png # too texty?
20:59:21 <dobblego> lispy, NFI, he gave me the book to read and I haven't started
20:59:29 <ddarius> dmwit: Constructive criticism: *blech*
20:59:38 <dmwit> right, thanks
20:59:44 <sclv> dmwit: for a mac icon? yow.
20:59:54 <sclv> it needs to look sorta 3d and shiny if you want to compete.
21:00:01 <dmwit> Well obviously plain black wouldn't be the end of the end.
21:00:13 <lispy> yeah, can you amke it look platinum or like a sexy feline?
21:00:21 <dmwit> It's a concept drawing, done in 30 seconds by a complete amateur.
21:00:40 <keseldude> i can ask someone to make one if you describe how you want it to look
21:01:03 <lispy> dmwit: okay, then my critique on the composition is that the H is too drawn out.  Yes, the emphasis is Haskell, but I misunderstood the logo until I knew it was ghc.
21:01:11 <wagle_home> i didnt know what you were trying to do, and so it ca,e out sorta "HGC"
21:01:25 <dmwit> ah
21:02:03 <sclv> seriously. if its not going to look all macsexy, better it just have the default icon.
21:02:06 <cjb> dons: also, a web interface would be very useful too; that way you can emulaate a centralized bug tracker (although all that's actually happening is that the web interface is yet another client with a checkout).
21:02:29 <sclv> especially if its going to be a cli tool anyway...
21:02:49 <dmwit> Okay, scrapped. =)
21:03:12 <dons> dmwit: but i think it has to have a dinosaur !
21:03:20 <dons> a happy green one
21:03:22 <sclv> The logo from the haskell homepage seems like it would be fine though?
21:03:24 <dmwit> =D
21:03:34 <dons> sclv: that's the haskel logo, not ghc's.
21:04:26 <dons> we could go with classic "no assignment" logo, http://www.cs.chalmers.se/Cs/Research/Functional/Pictures/logo.gif
21:04:27 <lambdabot> http://tinyurl.com/ywyygf
21:04:28 <yondalf> is there any way, in ghci, to run :step and :list a number of times? i'm tired of typing them out so many times
21:04:47 <lispy> yondalf: you can press up
21:04:52 <dons> yondalf: you can write a macro too
21:04:56 <lispy> yondalf: and it should be in the history
21:05:07 * ddarius still hasn't used the GHCi debugger.
21:05:22 <sclv> okay then: the haskell.org/ghc page. maybe a lambda done with the glow effect that the letters are given there?
21:05:32 <sclv> and a dinosaur.
21:06:44 <dmwit> Incidentally, one of the better Google Images hits for "happy green dinosaur" is Yoshi.
21:07:05 <dons> http://www.eecs.harvard.edu/~greg/Lambda.jpg
21:07:21 <dons> http://www.noulakaz.net/weblog/images/20070420-haskell.jpg
21:07:27 <yondalf> thanks
21:07:35 <sclv> 1992 called. they want their raytracer back.
21:08:30 <dons> http://www.cs.uu.nl/research/projects/generic-haskell/GHLogo.jpg
21:08:32 <dmwit> Heh, I like the peace-symbol looking one.
21:09:32 <dons> http://reddit.com/info/68g3q/comments/ hehe
21:10:19 <izuker> question:  how would i do a quickCheck that, say, RandomIO :: IO Double always returned something < 1 ?
21:10:42 <dons> hmm, avoid the IO?
21:10:44 <lispy> wasn't there a random range?
21:10:54 <lispy> ?hoogle randomR
21:10:55 <lambdabot> System.Random.randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
21:10:55 <lambdabot> System.Random.randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
21:10:55 <lambdabot> System.Random.randomRIO :: Random a => (a, a) -> IO a
21:11:05 <dons> izuker: if you're using randoms in IO, the mersenne-random package is a much much faster lib
21:11:11 <dons> like 500x faster
21:11:19 <lispy> dons: wow!
21:11:25 <dons> it also has a QC property that the Double returns [0,1)
21:11:38 <dons> lispy: well, it uses SSE2 if available, so that helps.
21:12:00 <lispy> dons: for real?  I have this pseudo-prime tester that uses random numbers and it's not all that slow, but does use randomIO, iirc.
21:12:04 <izuker> dons: thanks, i'll check it out
21:12:10 <dons> lispy: definitely. check the testsuite
21:12:38 <lispy> I remember testing 4096 bit primes
21:13:07 <lispy> Oh, but those are ints
21:13:27 <lispy> dons: does your claim about speed apply to generating any random number type?
21:13:31 <sclv> awesomes: http://www.iconarchive.com/icons/fasticon/dinosaurs-toys/tyrannosaurus-rex-256x256.png
21:13:32 <lambdabot> http://tinyurl.com/2f8g99
21:13:41 <wli> lispy: Is this with the new AKS primality test?
21:13:48 <dons> lispy: they're all a lot faster.
21:14:17 <lispy> wli: no, it's just a completely naive implementation from a book on computational number theory that I had laying around my home library.
21:14:19 <dons> Word is fastest.
21:14:24 <dons> sclv: heh
21:14:40 <sclv> its got a free use license too!
21:14:43 <lispy> wli: that's why it's peusdo
21:14:43 <wli> lispy: Of which algorithm?
21:15:00 <lispy> wli: um...good question.
21:15:03 <izuker> but anyway, no way to pull the Double out of the IO for the quickCheck?
21:15:04 * lispy tries to find out
21:15:42 <lispy> wli: http://files.codersbase.com/miller-rabin.hs
21:15:55 <wli> lispy: Ah, that's one of the more typical ones.
21:16:07 <ddarius> sclv: That would actually be rather hilarious as a logo.
21:16:07 <lispy> wli: i'm trying to recall...I think the miller-rabin is a non-pseudo test that I was benchmarking against?
21:16:36 <lispy> wli: don't be grossed out by that code, I wrote it after just one term of Haskell, so it's not pretty.
21:17:10 <wli> lispy: I'm sure my own Haskell code is not considered among the prettiest to this day.
21:17:35 <yondalf> @src fail
21:17:36 <lambdabot> fail s      = error s
21:17:36 <dons> http://www.todayinsci.com/C/Curry_Haskell/CurryHaskellThm.jpg
21:17:40 <yondalf> @src error
21:17:41 <lambdabot> error s = throw (ErrorCall s)
21:17:46 <yondalf> :t fail
21:17:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
21:18:02 <sclv> It just... feels right. Strong, fast, been around a while, eats less powerful things for an afternoon snack.
21:18:47 <lispy> wli: I also have an RSA implementation in Haskell (not the full standard, just the core algorithm).  I've always meant to hook my strong pseudo prime generator up to the RSA code (for the RSA code I just used small primes using the cannonical primes example)
21:19:06 <glen_quagmire> how can I understand fix?
21:19:12 <glen_quagmire> document says least fixed point
21:19:16 <lispy> glen_quagmire: try this one:
21:19:17 <lispy> > fix show
21:19:21 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:19:38 <glen_quagmire> :t fix show
21:19:38 <lambdabot> String
21:19:45 <glen_quagmire> :t show
21:19:48 <keseldude> hmm
21:19:49 <lambdabot> forall a. (Show a) => a -> String
21:19:54 <keseldude> now don't make too much fun of my logo
21:19:57 <keseldude> http://img.skitch.com/20080212-tp3xhn68tw6nd5rwqyukumwmcu.jpg
21:20:24 <glen_quagmire> fix has type (a -> a) -> a.. so, fix show will have (a -> String) -> (a -> String) -> (a -> string)  ??
21:20:44 <dons> i'd forgotten about this great tut, http://www.lisperati.com/haskell/
21:20:45 <dons> keseldude: hehe
21:20:49 <keseldude> :)
21:22:15 <lispy> :t fix
21:22:16 <lambdabot> forall a. (a -> a) -> a
21:22:39 <dons> does anyone know where bringert got his awesome euro lambda tshirt? http://www.scannedinavian.com/~shae/eurohaskell/tshirt.jpg
21:22:41 <wagle_home> > (fix $ \f -> \(n,a) -> if (n == 0) then a else f (n -1, a * n)) (4,1) :: Expr
21:22:41 <lispy> glen_quagmire: where does the initial 'a' come from that fix feeds to your function?
21:22:43 <lambdabot>  1 * 4 * (4 - 1) * (4 - 1 - 1) * (4 - 1 - 1 - 1)
21:23:44 <wagle_home> > (fix $ \f -> \n -> if (n == 0) then 1 else n * f (n -1)) 4 :: Expr
21:23:45 <lambdabot>  4 * ((4 - 1) * ((4 - 1 - 1) * ((4 - 1 - 1 - 1) * 1)))
21:23:55 <wagle_home> @src fix
21:23:56 <lambdabot> fix f = let x = f x in x
21:24:32 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
21:24:32 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:24:48 <Cale> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) :: [Expr]
21:24:49 <lambdabot>  [1,1,1 + 1,1 + (1 + 1),1 + 1 + (1 + (1 + 1)),1 + (1 + 1) + (1 + 1 + (1 + (1 ...
21:25:03 <nornagon> Cale: wow, that's really cool
21:25:37 <Cale> Yeah :)
21:25:49 <wagle_home> :t fix
21:25:49 <lispy> Cale: oh, what is Expr?
21:25:50 <lambdabot> forall a. (a -> a) -> a
21:25:52 <ddarius> > fix ((0:).(1:).ap(zipWith(+))tail)
21:25:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:25:57 <nelhage> :t Expr
21:25:58 <wli> > take 10 $ fix $ (1 :) . (1 :) . ap (zipWith (+)) tail
21:25:58 <lambdabot> Not in scope: data constructor `Expr'
21:25:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
21:26:07 <Cale> > gcd 4732981403 18043184839 :: Expr
21:26:08 <lambdabot>  abs 18043184839 `rem` (abs 4732981403 `rem` abs 18043184839) `rem` (abs 4732...
21:26:10 <ddarius> > fix ((0:).(1:).ap(zipWith(+))tail) :: [Expr]
21:26:11 <lambdabot>  [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1)),1 + (0 + 1) + (0 + 1 + (1 + (0 ...
21:26:16 <lispy> > take 10 . map length . group . fix $ show
21:26:16 <lambdabot>  [1,1,1,3,1,7,1,15,1,31]
21:26:19 <dons> ok. so at some point you need to write a paper about this, Cale :)
21:26:24 <dons> HW is coming up soon
21:26:31 <dons> perhaps a functional pearl?
21:26:40 <dons> "visualising haskell"
21:26:44 <lispy> Expr is just an instance of Num that pretty prints?
21:27:05 <dons> > 1 :: Expr
21:27:05 <lambdabot>  1
21:27:06 <Cale> It's really Twan's code, isn't it?
21:27:07 <lispy> actually, I see there may be a lot more to this with the gcd example
21:27:09 <dons> > 1 + 2 :: Expr
21:27:10 <lambdabot>  1 + 2
21:27:28 <dons> > map (+) [1..10] :: [Expr]
21:27:29 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> a'
21:27:31 <sarehu> > gcd 23 4 :: Expr
21:27:32 <lambdabot>  abs 4 `rem` (abs 23 `rem` abs 4)
21:27:33 <dons> > map (+2) [1..10] :: [Expr]
21:27:34 <lambdabot>  [1 + 2,2 + 2,3 + 2,4 + 2,5 + 2,6 + 2,7 + 2,8 + 2,9 + 2,10 + 2]
21:27:37 <dons> awesomeness
21:27:39 <Cale> > foldr f z [1..5]
21:27:40 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
21:27:49 <dons> > f
21:27:49 <lambdabot>  Add a type signature
21:27:49 <Cale> > iterate f z
21:27:50 <lambdabot>  [z,f z,f (f z),f (f (f z)),f (f (f (f z))),f (f (f (f (f z)))),f (f (f (f (f...
21:27:54 <lispy> That is so cool.
21:28:00 <dons> mega awesome cool
21:28:04 <lispy> lambdabot is truely a teaching tool these days.
21:28:07 <Cale> > scanl (+) 0 [a,b,c,d,e]
21:28:08 <lambdabot>  [0,0 + a,0 + a + b,0 + a + b + c,0 + a + b + c + d,0 + a + b + c + d + e]
21:28:19 <Cale> > scanl f z [1..5]
21:28:20 <lambdabot>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3,f (f (f (f z 1) 2) 3) 4,f (f (f (f (f...
21:28:23 <dons> so what things are predefined? where's this wonder code?
21:28:26 * lispy remembers he needs to get lambdaweb working again
21:28:29 <Cale> SimpleReflect.hs
21:28:32 <Cale> In lambdabot
21:28:44 * dons is glad to have lambdabot off his hands
21:29:01 <Cale> hehe
21:29:03 <lispy> dons: who is maintainer now?  I think everything still references  your uni page
21:29:16 <Cale> I don't know how you managed to get me to maintain it :)
21:29:19 <dons> well, code.haskell.org/lambdabot, aka Cale.
21:29:22 <dons> :)
21:29:22 <lispy> oh, cale is
21:29:23 <lispy> cool
21:29:36 <dons> he's our phd in resident, effectively :)
21:29:42 <glen_quagmire> > (\f -> let x = f x in x) show
21:29:43 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:29:47 <dons> i don't get as much time here as i used to.
21:29:56 <dons> > show f
21:29:57 <lambdabot>  Add a type signature
21:30:00 <lispy> dons: yeah, I can understand that
21:30:12 <dons> so now Cale really should do a phd
21:30:19 <Cale> hehe
21:30:29 <lispy> I'm not sure Cale has the smarts ;)
21:30:49 <davidL> dons: does ghc-6.8.2 build on openbsd?
21:30:49 <dons> patience is probably more important
21:30:51 <glen_quagmire> > (\f -> let x = f x in x) (\f -> let x = f x in x) (+1)
21:30:52 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t
21:30:52 <lambdabot>     Probabl...
21:30:53 <Cale> All I need is, like, an advisor or something, and a thesis topic, and maybe a scholarship?
21:30:56 <dons> davidL: sure. its in the ports tree
21:31:01 <davidL> oh?
21:31:04 <ray> > let y f = f (y f) in y show
21:31:05 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
21:31:07 <davidL> hm, must have missed that
21:31:08 <lispy> dons: yeah, i've heard people with PhD's debate what the 'p' stands for
21:31:19 <Cale> Pwned.
21:31:20 <lispy> pain, persistence, patience....
21:31:20 <kbateman> @pl removefirst f (x:xs) = if f x then xs else x:removefirst f xs
21:31:20 <lambdabot> removefirst = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . liftM2 ap ((ap . if') .) . (flip ((.) . (:)) .))
21:31:21 <dons> Cale, hmm. might need to move to europe (chalmers?) ? or portland?
21:31:25 <dons> or do some math.
21:31:25 <glen_quagmire> oh darn functional programming so hard good night
21:31:34 <lispy> dons: portland?
21:31:58 <dons> seems to be a couple of openings in the PSU group?
21:32:00 <lispy> dons: other than galois, is it really a good place for haskell?
21:32:01 <dobblego> what's the tilde mean in a pattern match?
21:32:04 <lispy> ah
21:32:09 <dons> yeah, PSU.
21:32:11 <lispy> I think Cale can do better than PSU
21:32:18 <Cale> dons: Yeah, I'm probably going to apply for MMath programs once I fix up a few things with my undergraduate degree here. I have some ideas of what to work on in algebraic combinatorics.
21:32:23 <lispy> I don't know about the strength of the Haskell group at PSU
21:32:30 <lispy> But, PSU isn't all that well respected in CS.
21:32:53 <dons> well, the PSU group works with Galois on lots of things. they're the House/OS guys, + Mark Jones and Tim Sheard.
21:32:54 <wagle_home> the OGI programming languages group all moved to psu
21:33:01 <dons> so pretty heavyweight languages group now
21:33:07 <Cale> If that doesn't work out for me, I could possibly consider going to work for a few years or something.
21:33:10 <dons> yeah, all ex-OGI. plus lots of formal methods stuff
21:33:19 <lispy> dons: oh, okay then, their Haskell group is a gem hidden deep within their reputation.
21:33:27 <ddarius> dobblego: irrefutable pattern
21:33:27 <lispy> yeah, the OGI guys were good
21:33:33 <wagle_home> onbly happened maybe 3 years ago
21:33:33 <lispy> dons: that makes more sense now
21:33:36 <dons> i guess. don't know about anything other than the OGI guys
21:33:40 <prb> Cale: Why do you want to go to graduate school?
21:34:07 <Cale> prb: Mostly because if you want to get employed doing pure mathematics, there aren't many other options. :)
21:34:09 <dons> so he can help run #haskell for a few more years
21:34:16 <lispy> hehe, good answer
21:34:32 <dons> grad school is fun
21:34:45 <prb> Cale: True enough.  I did that for a while before retiring to be an entrepreneur.
21:35:04 <prb> Cale: (Pure mathematician.)
21:35:10 <Cale> Cool, what area?
21:35:21 <prb> Geometric group theory.
21:35:54 <prb> Combinatorial analogs of non-positive curvature.
21:36:03 <Cale> Neat, sounds like something I'd be into. I generally like areas which combine something algebraic with something more tangible or geometric.
21:36:10 <lispy> dons: I think grad school being fun depends heavily on how well you fit the program you're in.
21:36:32 <lispy> It pays to choose carefully.
21:36:50 <dons> definitely. it's *critical*
21:37:02 <dons> 4 years of boredom , vs 4 years of fun
21:37:24 * lispy changed advisors more than once because of poor evaluation skills
21:37:27 <prb> lispy: It pays to have a fellowship and a powerful advisor.
21:37:43 <lispy> prb: in my case, no I had to leave that advisor because I couldn't work under her.
21:37:50 <dons> getting a high profile advisor, who's also motivated, is pretty useful
21:38:01 <dons> you get dragged along for the ride.
21:38:04 <prb> In math, at least, it's necessary to get a job.
21:38:08 <lispy> prb: now I work with droundy on darcs and I love it, but I get no funding.
21:38:25 <dons> lispy, do you use xmonad? and can you confirm david does?
21:38:29 <prb> There are enough good people that unless you can annotate the "(s)he's great" with some weight, you don't get anywhere...
21:38:42 <dons> i'd love to see a photo of david hacking darcs, inside xmonad :)
21:38:42 * prb was one of ~10^3 applicants for his first academic job.
21:38:49 <trie_> dobblego: http://www.haskell.org/tutorial/patterns.html has a write up on patterns that explains ~ also
21:38:50 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
21:39:02 <lispy> dons: I do not use xmonad because I don't have anywhere that I use linux for a desktop OS, and I know david has it on his machine and switches between it and something else.
21:39:18 <dons> interesting
21:39:26 <prb> But the jobs pendulum sings frequently.  You have to time it -- like playing pitfall on an Atari 2600...
21:39:46 <gwern> prb: 100 applicants? wow; remind me never to try for a job in academia
21:39:53 <lispy> dons: he frequents #darcs these days now that he's unstable maintainer again.
21:39:53 <prb> gwern: 1000.
21:39:54 <trie_> dobblego: ~ denotes lazy patterns.
21:40:29 <lispy> dons: it would be hard for me to get that picture as well, because he's currently working from NY not OSU :)
21:40:41 <gwern> oh, right. i hate off-by-one errors
21:40:41 <lispy> dons: but it's a cute idea
21:40:46 <gwern> prb: but that's even worse!
21:40:53 <gwern> dons: here's another link on distract: http://lwn.net/Articles/231009/
21:40:54 <lambdabot> Title: Development [LWN.net]
21:41:09 <prb> gwern: Yeah.  It can be a bit of a crapshoot unless you really know what you're doing and where you're headed.
21:41:38 <prb> gwern: But grad school was fabulous fun -- rode my bike all the time, lived well on $10k/year, stayed up all night thinking, ... heaven.
21:41:51 <dons> lispy: he frequents #xmonad more often :)
21:42:03 <gwern> 10k a year? a life of the mind, I see
21:42:22 <dons> prb, yeah :) its strange how 10k/year somehow seemed plenty
21:42:23 <lispy> dons: ah cool
21:42:31 <dons> lentils are cheap
21:42:37 <dons> and all you need is a terminal
21:42:41 <dons> and latex
21:42:52 <lispy> LaTeX or latex?
21:42:53 <lispy> ;)
21:42:59 <dons> hmm.
21:43:00 <cjb> lispy: "yes."
21:43:00 <thetallguy> lispy: you beat me to it.
21:43:15 <dons> yay for grad school :)
21:43:19 * gwern finds this discussion eroticly ambiguous
21:44:01 <lispy> dons: yeah, but I have a lot of questions for you sometime about your current setup
21:44:05 * gwern still hasn't found the distract monotone repo :(
21:44:24 <lispy> dons: there is this certain place I've been wanting to apply at once I graduate...
21:44:49 <dons> i'd recommend writing as much high quality haskell code as you can.
21:45:02 <dons> if you can build a profile as the author, or contributor, of lots of good code, that helps a lot.
21:45:06 <lispy> high quality?  that's the hard stuff to write...
21:45:25 <dons> it certainly makes the choice to hire easier. its not critical though.
21:45:48 <lispy> dons: okay, that's certainly good advice.  But, I doubt i'll be doing much of that between now and graduation.  I'm putting all my energy into school at the moment.
21:46:09 <dons> yeah, fair enough.
21:46:15 <lispy> well, school + work
21:46:42 <dons> hopefully we'll see the job market expand some more.
21:48:01 <lispy> dons: I would like to write more haskell with the stuff i'm learning from hacking darcs.
21:48:14 <lispy> Exploiting type safety is fun.
21:48:28 <dons> anyone else think ocaml's simple unix tools looks butt ugly compared to the haskell version? http://fhtr.blogspot.com/2008/02/simple-unix-tools-in-ocaml.html
21:48:29 <lambdabot> Title: FHTR: Simple UNIX tools in OCaml
21:49:07 <dons> oh, its a lot lower level.
21:49:45 <sarehu> Anything in OCaml looks butt ugly compared to the Haskell version.
21:50:05 <gwern> dons: looks like a lot of them are doing io as compared with the pure haskell ones
21:50:07 <lispy> one of the weird things about ocaml is the pattern matching
21:50:22 <gwern> (so they're not all that equivalent I suppose)
21:50:23 <lispy> iirc, it has to be in a tuple to match on more than one thing per line
21:50:26 <dons> gwern: yeah, seems very imperative. surely that's not idiomatic haskell.
21:50:33 <dons> oh, maybe they don't have lazy lists?
21:50:51 <lispy> yeah, i think lazy is restricted to a module in ocaml
21:50:57 <gwern> do I detect a hint of mockery in that statement?
21:51:00 <lispy> and probably not very efficient
21:51:07 <thetallguy> sarehu: That's true.  All the O'Caml I've written looks like a big nested let.
21:51:44 <dons> all that manual array/buffer work -- faking a lazy string type.
21:51:48 <thetallguy> dons, lispy: yes, lazy lists are implemented as a library
21:52:00 <thetallguy> I couldn't stand them.
21:52:19 <gwern> but - but implementing stuff as libraries was *good*, I thought!
21:52:21 <Cin> thems be strong emotions
21:52:35 <thetallguy> gwern: you'd think so.
21:52:47 <dolio> Is that why C is so good?
21:53:30 <lispy> gwern: so maybe haskell could get an eager datastructure library
21:53:48 <gwern> lispy: eh, there are some 'strict' packages floating around
21:54:26 <dons> we have plenty of eager structures
21:54:35 * lispy was teasing
21:55:00 <dons> for some reason strict languages don't have many lazy data types, but mixed lazy/strict stuff is super common in lazy languages.
21:55:09 <thetallguy> dolio: in fairness, I dream of writing something as effective and long-lived as C.
21:55:17 <lispy> > printf "%.1f" 1.0
21:55:19 <lambdabot>  Add a type signature
21:55:23 <lispy> > printf "%.1f" 1.0 :: String
21:55:25 <lambdabot>  "1.0"
21:55:26 <dons> there's no data T a = T a ~(T a) ~(T a) in ML. even though it'd be a win...
21:55:44 <mrd> unit -> a
21:55:54 <lispy> > printf "%.1f" 1.345 :: String
21:55:55 <lambdabot>  "1.3"
21:56:00 <dons> there's a reason clean and haskell win the sum-file and binary trees benchmark -- simple, mixed strict-lazy structures
21:56:01 <Cin> thetallguy: as spj illustrated, just write so many Killer Apps(tm) in it so that it can never die and everyone has to use it
21:56:23 <thetallguy> data F a = F a ~(L a) ~(L a)
21:56:29 <gwern> hee hee. I just got to use the word 'flummoxed' in an email
21:56:30 <lispy> how many killer apps do we have in Haskell?
21:56:32 <gwern> good night
21:56:38 <Cin> lispy: two?
21:56:43 <Korollary> zero
21:56:44 <gwern> lispy: well, darcs. xmonad (maybe)
21:56:44 <dons> lispy, well, ghc isn't going anywhere.
21:56:51 <dons> its a pretty killer haskell compiler
21:57:05 <gwern> no, ghc doesn't count - it's a tool-making tool, it's only a killer app if you want haskell in the first place
21:57:07 <thetallguy> Cin: Yeah, but C filled that gap because it kept things simple and in the hands of theprogrammer.
21:57:07 <yondalf> is there any equivalent to mkstemp in haskell?
21:57:09 <lispy> yeah, I agree about ghc and, I would like to think the same about darcs.
21:57:13 <dons> cryptol is pretty serious in its domain.
21:57:14 <mrd> how many killer whales do we have in the ocean?
21:57:17 <dons> and bluespec isn't going anywhere.
21:57:23 <dons> both depend on haskell/ghc
21:57:37 <gwern> darcs can be used for anything
21:57:37 <dons> yondalf: there's a mkstemp in the standard lib.
21:57:43 <dons> makeTempFile or some such.
21:57:43 <thetallguy> Cin: there's a big jump, seemingly, between a wrench and an automated nut-managing robot.
21:58:09 <dons> yondalf: openTempFile "/tmp" "runghcXXXX.hs"
21:58:21 <yondalf> ?hoogle mkstemp
21:58:22 <lambdabot> No matches found
21:58:34 <lispy> How many 'large' haskell applications do we have?
21:58:37 <gwern> I want to say xmonad is a killer, but realistically I know stumpwm and some other tiling wms can do everything it does except for some of the more exostic stuff
21:58:54 <yondalf> dons: i need to pass the filename to a program (tex in this case) which expects a filename, not merely open a file somewhere
21:58:55 <thetallguy> lispy: define large?
21:59:05 <Cin> gwern: what is the codebase comparison?
21:59:05 * BMeph watches the Catsters series on string diagrams...and is scared that monads and adjoints are making sence
21:59:13 <prb> Is it safe to hand-edit the files in _darcs/patches?
21:59:16 <gwern> thetallguy: well, LOLITA clocked in at >50k LOC, but lolita is long dead
21:59:17 <lispy> thetallguy: what are the largest 5 haskell applications?  Let me ask that way.
21:59:26 <gwern> prb: if you have to ask...
21:59:29 <BMeph> s/sence/sense/
21:59:36 <lispy> prb: not realy
21:59:37 <dons> yondalf: it returns a pair of a filename, and an open handle
21:59:42 <dons> yondalf: check System.IO's docs
21:59:43 <thetallguy> lispy: large in code size?  # of users?  # of $'s invested?
21:59:47 <lispy> prb: what do  you want to do in that directory?
22:00:06 <prb> lispy: Fix a crummy comment that ended up with some up arrows in it. :(
22:00:09 <dons> bluespec and cryptol are > 100k loc.
22:00:18 <dons> big, commercial, proprietary projects
22:00:21 <gwern> cryptol? that's a new one on me
22:00:27 <lispy> thetallguy: I'm not really sure.  how about a metric that combines code base size with number of stead contributors?
22:00:30 <prb> lispy: Files are gzip'd plain text with a hash on the end.
22:00:44 <dons> you might have heard of these guys, gwern? http://galois.com/crypto.php
22:00:44 <mrd> comments?
22:00:46 <lambdabot> Title: Crypto Development and Validation
22:00:51 <lispy> dons: cool
22:00:58 <lispy> prb: what version of darcs?
22:00:59 <gwern> dons: first hit, I'm there, ugly site tho
22:01:09 <lispy> prb: how recently did you record this patch?
22:01:10 * mrd chuckles
22:01:18 <Cin> gwern: agreed
22:01:19 <prb> lispy: 2.0-pre something.
22:01:23 <lispy> prb: has it ever been downloaded or put in another repository that you don't have control over?
22:01:31 <prb> lispy: Nope.
22:01:41 <lispy> prb: I can't say much for the data validation of darcs2
22:01:51 <prb> lispy: delete and re-record?
22:02:10 <lispy> prb: yeah, but um...careful how you do it, eg which commands
22:02:16 <yondalf> dons: oh...thanks and my apologies
22:02:24 <lispy> prb: you want to get the changes back in your working copy so you can record them again
22:02:25 <dons> yondalf: hey, no need :)
22:02:26 <thetallguy> lispy: checking
22:02:39 <lispy> prb: but, i forget if unpull does what you'd want
22:02:43 <prb> lispy: Single file.  So it'll be easy.
22:02:47 <Cin> http://pckeyboards.stores.yahoo.net/customizer.html
22:02:48 <lambdabot> Title: Customizer 104/105
22:02:53 <Cin> you are all jealous of my new keyboard-to-be
22:03:02 <prb> lispy: I can nuke and restore from another repo.  (I'm keeping 4 going, with one definitive.)
22:03:20 <sarehu> i have one
22:03:24 <lispy> prb: I think there was a request for amend-record to handle this case, but I don't know if the wishlist was filled.
22:03:29 <sarehu> well, not that one
22:03:45 <Cin> sarehu: a unicomp or Model M?
22:04:24 <sarehu> i've got an endura pro
22:04:26 <sarehu> unicomp
22:04:32 <Cale> Cin: Oh yeah? Well, we'll see when I'm playing Duke Nukem Forever on my Optimus keyboard!
22:04:52 <Adamant> the Optimus has actually shipped, I think
22:04:58 <olsner> Model M <3
22:04:58 <Cin> cale: haha
22:05:02 <Adamant> still waiting on DNF
22:05:11 <sarehu> however, the mouse on it has deteriorated
22:05:21 <Cin> cale: overrated, much? :P
22:05:48 <Adamant> go look at the Computer Museum if you're in the Valley sometime
22:06:17 <Adamant> lots of interesting computers there. never saw an Apollo until I visited
22:06:31 <prb> Adamant: At least you never had to use one.  Blech.
22:07:12 <Adamant> weren't they Unixoid with a graphic environment?
22:07:35 <prb> Adamant: Yeah; contemporaneous to DECstations, very early NeXT, etc.
22:07:39 <Cin> a la Jurassic Park?
22:07:48 <thetallguy> lispy: the Linspire autobuilder is about 10K lines of haskell, plus libraries, which are probably another 5-10K
22:07:49 <Cin> "this is unix! i know this!"
22:07:56 <Adamant> no, that was Xwin and Sun
22:08:00 <Cin> :(
22:08:12 <gwern> yeah but the haskell guys at linspire seem to be leaving
22:08:22 <thetallguy> lispy: three contributors , ratios of 90, 8, 2%
22:08:26 <Adamant> you can still download the file browser they used
22:08:29 <Twey> Cin: Ahahaha.
22:08:35 <thetallguy> gwern: yes, but we're using the autobuilder in our new venture.
22:08:46 <thetallguy> and it will continue to be used at Linspire.
22:09:14 <prb> Adamant: I think I stand corrected; I'm remembering some awful HP boxes.
22:09:58 * prb goes to read wikipedia.
22:10:07 <thetallguy> gwern: plus, you and a few others have expressed some interest.
22:10:35 <gwern> thetallguy: oh, I should've figured. you're one of those fellows?
22:10:41 <thetallguy> I am.
22:10:53 * gwern can never keep people straight. no doubt I know who thetallguy is under some other description
22:11:15 * thetallguy ==Clifford Beshers
22:11:25 <thetallguy> stepcut == Jeremy Shaw.
22:11:51 * thetallguy should probably change his handle to something more obvious.
22:12:17 <gwern> oh, Shaw mentioned me to you? I think he's the one who emailed me
22:12:28 <thetallguy> gwern: yes.
22:12:40 <thetallguy> you submitted a patch, didn't you?
22:12:52 * gwern nods
22:13:34 <thetallguy> That Planet Haskell post about Forking a Package, I will respond soon.  The autobuilder is quite good at that.
22:15:51 <thetallguy> funny, stepcut just found a bug in ghc 6.8.2, where it misoptimized something in the autobuilder, runtime went from 60 min to 12 sec.
22:17:44 <dons> oh, sounds like the -no-state-hack flag?
22:17:57 <thetallguy> eh?
22:18:36 <dons> i'd be interested to know what bug it was. /me guesses the io duplication issue (which can lead to typically ridiculous speedups like that)
22:18:52 <Cin> reddit is giving me internal server error. -_-
22:19:15 <gwern> Cin: for comments?
22:19:30 <thetallguy> dons: working on it.
22:19:34 <Cin> gwern: for /r/programming/
22:19:35 <dons> type error they forgot to check before they deployed :)
22:19:40 <gwern> Cin: yes, I've seen it
22:20:00 <gwern> it happens for cross-reddits - ie main reddit articles showing up in proggit's recommended or whatever
22:20:21 <gwern> the fix is to click on the link while in the main reddit and not proggit :(
22:21:01 <Cin> gwern: i see
22:22:14 <thetallguy> What is reddit written in?
22:22:22 <Twey> HASKELL
22:22:40 <Twey> (probably not, actually *checks*)
22:22:42 <johnnowak> blood
22:22:45 <johnnowak> and python
22:22:48 <dolio> Python.
22:22:55 <Twey> Not CL?
22:22:57 <dolio> Ported from some kind of Lisp.
22:22:59 <johnnowak> not anymore
22:22:59 <Cin> i thought it was Arc.
22:23:02 <johnnowak>  no
22:23:28 <Twey> Oh, OK
22:24:43 <sarehu> Python
22:25:04 <kolmodin> ?tell waern behÃ¶ver haddock verkligen -O2 ? och -fasm Ã¤r ingen hÃ¶jdare, den funkar inte pÃ¥ alla arkitekturer. nyare cabal lÃ¤gger sjÃ¤lv pÃ¥ den flaggan om det Ã¤r mÃ¶jligt
22:25:04 <lambdabot> Consider it noted.
22:25:34 <gwern> yay! my asteroids game works!
22:25:50 <gwern> http://www.informatik.uni-bremen.de/~cxl/haskell-in-space/ <-- IT LIVES
22:25:50 <lambdabot> Title: Haskell in Space
22:25:58 <thetallguy> My brother had a great run-in with Python the other day.  Specifically, RedHat's Anaconda program.
22:26:05 <gwern> now, it performs like an utter piece of shite. but it works, is the point
22:26:11 <mrd> thetallguy: not fatal, I hope
22:26:25 <thetallguy> mrd: well, it was for the install.
22:26:29 <Twey> It has bits written in C :<
22:26:36 <thetallguy> anaconda sid the machine didn't have enough memory to install
22:26:43 <Twey> OH wait, that's HGL
22:27:11 <thetallguy> but in fact, it had enough that python's 32-bit integers overflowed
22:27:24 <thetallguy> I love bugs like that.
22:27:28 <Twey> gwern, 2001?  o.@
22:27:38 <Twey> thetallguy: Haha, nice
22:27:41 <gwern> Twey: say what you will about HGL, but that's one stable api. all I really had to do was track down which functions moved to which modules
22:27:45 <Twey> Should've used a Decimal :-P
22:28:27 <Twey> Wait, there's a proper big int, isn't there
22:28:35 <thetallguy> Twey: Should've used Haskell Integer.  I smack myself now if I ever put in Int.
22:29:01 <kolmodin> gwern: screenshots!
22:29:10 <kolmodin> :)
22:29:27 * gwern politely suggest kolmodin piss off, as I badly need some sleep now :)
22:29:33 <kolmodin> hahha :D
22:29:37 <kolmodin> good night :)
22:29:53 <kolmodin> I just woke up... time for breakfast. cheers
22:30:09 <radix> thetallguy: "overflowed"?
22:30:25 <radix> python's integers aren't restricted to 32 bits
22:30:56 <nornagon> dword, and beyond!
22:31:15 <Twey> thetallguy: Heh.  What's the overhead on Integer vs. Int?
22:31:25 <thetallguy> radix: hmm...  Don't know any more than that.  I'll have to ask my bro for more details.
22:31:35 <thetallguy> Twey: Integer uses the gmp library
22:32:00 <shachaf> gwern: Who are you under some other description?
22:32:10 <gwern> shachaf: human
22:32:17 <thetallguy> Twey: so there's over head for small operations, but you get to install your operatingsystem down the line....
22:32:18 * shachaf is a bot.
22:32:28 <thetallguy> dons: I have a partial answer.
22:32:32 * gwern is attached by the Sandman. oh noes! good night/morning all
22:32:38 <shachaf> gwern: Can we get a name, please?
22:32:42 <Twey> thetallguy: Heh, fair point
22:32:49 <Twey> 'night gwern :-)
22:32:49 <shachaf> Bonan nokton, Maru.
22:33:12 <hpaste>  yondalf pasted "refactor my code" at http://hpaste.org/5610
22:34:00 <yondalf> if anyone has nothing to do and would like to look at a haskell newbie's code, you can go to the hpaste link above (hopefully this is ok from an etiquette point of view)
22:34:25 <yondalf> 77 non-empty lines of code
22:36:32 <hpaste>  thetallguy pasted "Radical speedup" at http://hpaste.org/5611
22:37:19 <thetallguy> Twey: I'm big on including all costs.  I'm trying to work up an equation.
22:38:42 <thetallguy> dons: http://hpaste.org/5611  gives some info on the big speedup.  stepcut did the work, so I'm still fuzzy on some details.  We can't reproduce in a small program yet.
22:40:03 <sclv> yondalf: do blocks inside of lists is a bit of an odd style choice.
22:40:33 <herdrick> hi shachaf
22:40:53 <yondalf> sclv: is there any other way that i could do that?
22:40:56 <shachaf> herdrick: Hello. :-)
22:41:53 <sclv> join the parsers explicitly with <|> instead of the choice combinator. and perhaps have them named and distinct?
22:42:01 <dons> thetallguy: hmm, weird.
22:42:11 <dons> some inlining screwing something up?
22:43:28 <yondalf> sclv: hmm...i guess, yes, that's the normal way of doing things :-) but i did a lot of adding and removing parsers while coding that part, and so thought that keeping it in a list would be easier to maintain since i only need to change things in one place
22:44:54 <sclv> this is just small change stuff too, but you may find it helpful to limit your line length a bit more. i find it useful because it forces me to go for real concision instead of the sorta-concision of just big pipelines.
22:45:06 <yondalf> concision?
22:45:17 <thetallguy> dons: yeah.   Don't know.  Jeremy's knocking off for the night and I have
22:45:40 <thetallguy> dons: n't got my head in the code to see.
22:47:49 <sclv> yondalf: you also have some big inline lambdas you may want to pull out into named functions in a where clause, and you don't need two levels of where clauses in elementsToTex because the second doesn't depend on things only in scope of the first, I think?
22:50:16 <sclv> oh, and foldl is nearly always better foldl' which is stricter (import from Data.List).  there are probably lots of places where in huge files you might run into performance issues with this, but if you're not in huge files then nevermind me. especially if it works, it looks pretty nice and readable I think though!
22:51:39 <dons> foldr you mean?
22:52:26 <sclv> dons: no. there's a foldl in the paste.
22:52:30 <yondalf> sclv: okay, i'm going through my code looking at your suggestions :-)
22:53:42 <sclv> actually, looking at it, "LyricsLine $ foldl (++) "" (map snd css)" seems like its better some sort of concatMap anyway, no?
22:54:28 <olsner> LyricsLine (snd =<< xss)
22:55:15 * sclv is deliberately refraining from pointfreeing the code randomly and putting all the concatMaps into the list monad unless its clear that they'll actually make the code cleaner and more readable.
22:55:40 <dons> sclv: oh, i misread, "foldl is nearly always better foldl'"
22:55:49 <sclv> @pl \css -> LyricsLine $ foldl (++) "" (map snd css)
22:55:50 <lambdabot> LyricsLine . foldl (++) [] . map snd
22:55:51 <dons> better *than* or better *as* :)
22:56:03 <sclv> silly pl should be smarter than that.
22:56:14 <dons> ?src concatMap
22:56:14 <lambdabot> concatMap f = foldr ((++) . f) []
22:56:17 <dolio> foldl (++) is probably not advisable, as it causes a lot of copying.
22:56:17 <dons> ?src concat
22:56:18 <lambdabot> concat = foldr (++) []
22:56:31 <olsner> @pl \css -> LyricsLine $ foldr (++) "" (map snd css)
22:56:31 <lambdabot> LyricsLine . foldr (++) [] . map snd
22:56:46 <dons> :t foldr (++) [] . map snd
22:56:48 <lambdabot> forall a a1. [(a1, [a])] -> [a]
22:56:55 <dons> :t concatMap snd
22:56:56 <lambdabot> forall a b. [(a, [b])] -> [b]
22:59:03 <yondalf> thanks....didn't want to use foldl' because that would mean an import, and i'm only working with small files anyway, but i forgot that (++) is associative so i should have used foldr anyway
22:59:17 <yondalf> but yes, LyricsLine $ concatMap snd css is better, thanks
22:59:39 <yondalf> btw, is printf "good style" in haskell?
23:01:21 <sarehu> is it the most readable way for the task at hand?
23:01:36 <sclv> might be a bit of overkill for what you're doing... but generally i don't think its frowned upon..
23:02:25 <dons> its fine in scripts
23:02:30 <dons> get the damn job done.
23:02:50 <dons> anything bigger, use a pretty printer library, anything smaller use show.
23:04:37 * yondalf thinks there should be a sprintf specialising to return Strings after having problems with nested printfs
23:05:18 <sclv> that would sort of break how printf works though?
23:05:24 <sclv> ?hoogle printf
23:05:25 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
23:05:25 <lambdabot> Text.Printf :: module
23:05:25 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
23:05:39 <yondalf> > printf "%s" (printf "a")
23:05:41 <lambdabot>  Add a type signature
23:06:05 <yondalf> ghc produces a more verbose error message about an ambiguous type
23:06:07 <sclv> > printf "%s" "12"
23:06:08 <lambdabot>  Add a type signature
23:06:26 <dons> > printf "%s" "12" :: String
23:06:28 <lambdabot>  "12"
23:06:29 <yondalf> "" ++ printf "%s" "12"
23:06:35 <yondalf> > "" ++ printf "%s" "12"
23:06:36 <lambdabot>  "12"
23:06:47 <yondalf> > "" ++ printf "%s" (printf "a")
23:06:48 <lambdabot>  Add a type signature
23:07:01 <dolio> Why are you nesting printfs?
23:07:07 <dons> yeah :)
23:07:15 <sclv> printf does its varargs magic by really returning either a function to take another argument or a string, depending on what's expected of it.
23:07:16 <dons> sounds like you need to use the pretty printer library.
23:07:33 <sclv> so if there isn't enough context, then type inference doesnt work.
23:07:40 <sclv> in this case, just use more (++) actually.
23:08:37 <yondalf> dolio: because the inner printf was actually a concatMap of printfs
23:08:57 <yondalf> dons: what i did was i just took out the inner concatMap/printf into a where declaration and used a type declaration
23:09:16 <yondalf> dons: the pretty printer library seems overkill, from the ghc documentation
23:09:50 <sclv> you're just appending strings in this case though. using printf itself is a bit much... i would tend to use it where i want to mix strings and doubles and etc, and get some control over precision while I was at it.
23:10:28 <yondalf> sclv: to me, the (++) operators clutter the code
23:11:56 <sclv> that's probably because you're a bit wary of linebreaks. :-)
23:12:03 <yondalf> sclv: :-)
23:13:46 <dons> if its just strings, printf is overkill.
23:13:57 <dons> > concat [ "foo", "bar", "baz" ]
23:13:58 <lambdabot>  "foobarbaz"
23:14:03 <dons> > unlines [ "foo", "bar", "baz" ]
23:14:04 <lambdabot>  "foo\nbar\nbaz\n"
23:14:04 <mrd> unwords
23:14:16 <dons> > unwords [ "foo", "bar", "baz" ]
23:14:17 <lambdabot>  "foo bar baz"
23:14:27 <mrd> > undead ["must", "eat", "brainsss"]
23:14:28 <lambdabot>   Not in scope: `undead'
23:15:00 <mrd> lambdabot: why must you always drive a wooden stake through my heart?
23:15:02 <yondalf> there are still the " and , to deal with...at least with printf i only need to write " twice
23:15:40 <Festering_Hate> Can anyone recommend a good book on Haskell?
23:15:56 <Japsu> Festering_Hate: perhaps the Haskell School of Expression
23:16:03 <Japsu> by Paul (?) Hudak
23:18:15 <Festering_Hate> Japsu: Thanks, I'll check that out.
23:18:30 <Japsu> @index tokens
23:18:31 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
23:18:44 <Japsu> hmm
23:19:10 <Japsu> @type tokens
23:19:11 <lambdabot> Not in scope: `tokens'
23:19:37 <Japsu> okay, that's hairy.
23:26:43 <adu> hi
23:26:51 <Festering_Hate> adu: Hey.
23:28:36 <adu> so I've been working on my opengl app
23:29:04 <adu> and I realized that I'd like to have multiple key combos
23:29:34 <adu> and my first thought to accomplish this was to use a global key-history, then I remembered you can't have globals in Haskell...
23:32:10 <adu> so how do I save the key presses that have occured, like in a list, between each invocation of the onkey event handler?
23:49:11 <sclv> top level MVar?
23:49:57 <adu> hmm...
23:50:43 <adu> oooo nice!
23:50:46 <adu> yes!
23:51:41 <adu> so
23:52:34 <Cale> adu: My usual solution to that problem is to pass the MVar into the event handlers at the top level when I'm setting them.
23:52:41 <adu> xs <- takeMVar m
23:52:51 <adu> putMVar m (x:xs)?
23:53:01 <adu> would that work for building a list?
23:53:08 <Cale> Sure.
23:53:11 <adu> yey!
23:53:18 <adu> i think i'm understanding
23:54:15 <adu> Cale: that is brilliant, thanks
23:54:16 <Cale> Making a real top-level MVar with unsafePerformIO is doable, but probably more trouble than it's worth. Usually easier just to pass the MVar to where you need it.
23:56:15 <b_jonas> yeah
23:56:22 <b_jonas> monads and monad transformers help that
23:59:40 <Cale> To some extent. With callbacks, a little less so -- you have to pass it explicitly when setting the callback.
23:59:57 <Cale> (generally speaking)
