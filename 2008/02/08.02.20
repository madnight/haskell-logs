00:09:35 <rnorris> howdy. has anyone gotten opengl to work from ghci on macos x? i tried the enablegui thng from wx but it didn't seem to help
00:19:55 <dagit|lispy> rnorris: I don't think you want to use opengl from ghci
00:20:02 <dagit|lispy> i don't think it's a problem with osx at all
00:26:00 <hpaste>  Svrog pasted "Concurrency broken - what is wrong with this code?" at http://hpaste.org/5772
00:28:26 <doserj> Svrog: try takeMVar instead of readMVar?
00:28:39 <Svrog> i need readMVar
00:28:43 <Svrog> i can work around this
00:28:50 <Svrog> but i just thought readMVar is atomic
00:30:01 <wagle_home> :readMVar
00:30:07 <wagle_home> :t readMVar
00:30:09 <lambdabot> Not in scope: `readMVar'
00:30:23 <wagle_home> bah, etc
00:30:52 <ivanm> @type readMVar
00:30:52 <lambdabot> Not in scope: `readMVar'
00:30:54 <Svrog> i'm still not sure if this is a bug with readMVar or expected behavior - what im guessing is happening is that one of the two threads writes to v, readMVar then reads v but before it puts the value back the other thread writes to it
00:30:58 <ivanm> @hoogle readmvar
00:30:59 <lambdabot> Control.Concurrent.MVar.readMVar :: MVar a -> IO a
00:31:05 <ivanm> wagle_home: there you are!
00:31:33 <doserj> @type Control.Concurrent.MVar.readMVar
00:31:33 <lambdabot> forall a. GHC.IOBase.MVar a -> IO a
00:42:50 <glguy> ?seen dons
00:42:50 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 58m 58s ago.
01:10:57 <quicksilver> Svrog: readMVar is not supposed to be atomic, no.
01:11:31 <quicksilver> Svrog: there are a few "safe" ways to use MVars, though.
01:15:45 <dcoutts_> it's atomic wrt to other readMVar users
01:16:10 <dcoutts_> but not if other threads are using takeMVar/putMVar directly
01:17:29 <ac> @src zip3
01:17:29 <lambdabot> zip3 (a:as) (b:bs) (c:cs) = (a,b,c) : zip3 as bs cs
01:17:29 <lambdabot> zip3 _      _      _      = []
01:18:04 <dcoutts_> @src unzip3
01:18:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
01:18:07 <dcoutts_> bah
01:18:12 <ac> bleh. I have a legitimate useage for zip4
01:18:31 <dcoutts_> @hoogle zip4
01:18:32 <lambdabot> Data.List.zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
01:18:32 <lambdabot> Data.List.unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
01:18:46 <ac> oh nice, guess I need to import Data.List
01:19:01 <dcoutts_> yep, Data.List has 4-7, Prelude has 2-3
01:19:27 <wagle_home> @djinni [a] -> [b] -> [c] -> [d] -> (a,b,c,d)
01:19:28 <lambdabot> -- f cannot be realized.
01:19:38 <quicksilver> are you sure you don't have a legitimate use for zipWith4 ?
01:19:44 <quicksilver> tuples are so outre
01:19:56 * wagle_home kicks djinni
01:20:00 <ac> I like my tuples
01:20:15 <yondalf_> @djinni a -> a
01:20:16 <lambdabot> f a = a
01:20:24 <yondalf_> @djinni a -> (a, a)
01:20:24 <lambdabot> f a = (a, a)
01:20:35 <yondalf_> @djinni [a] -> a
01:20:36 <lambdabot> -- f cannot be realized.
01:20:44 <quicksilver> it doesn't have any rules for lists.
01:20:53 <quicksilver> Or monads, or functors, or any type class, or any recursive data type, etc etc.
01:20:55 <dcoutts_> quicksilver: one advantage is that you get unzips too, otherwise you have to write your own unzip or map to tuples to unzip, where is our unzipWith ?
01:21:13 <quicksilver> dcoutts_: unzipWith is just map.
01:21:28 <quicksilver> > map (\x -> (x+1,x-1) ) [0..]
01:21:31 <lambdabot>  [(1,-1),(2,0),(3,1),(4,2),(5,3),(6,4),(7,5),(8,6),(9,7),(10,8),(11,9),(12,10...
01:21:53 <dcoutts_> quicksilver: huh? no I want to take a list of my 3-place constructor and pull out three lists
01:22:03 <wagle_home> @djinni m a -> m b -> m c -> m d -> (a,b,c,d)
01:22:03 <lambdabot> -- f cannot be realized.
01:22:10 <dcoutts_> @src unzip
01:22:11 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
01:22:23 <quicksilver> dcoutts_: oh, yeah.
01:22:42 <wagle_home> @djinni (Monad m) => m a -> m b -> m c -> m d -> (a,b,c,d)
01:23:01 <quicksilver> wagle_home: as I said : no monads, no functors, no type classes
01:23:22 <wagle_home> oracle not recoginized at line 374346
01:24:04 <wagle_home> (wanted to try my idea anyway)
01:24:07 <quicksilver> ;)
01:24:32 <quicksilver> djinn has proof rules for tuples, Eithers, Void, ->
01:24:40 <quicksilver> which corresponds to intuitionistic logic
01:24:48 <quicksilver> not sure if it has anything else?
01:24:54 <quicksilver> you can add rules to it though
01:25:56 <LeCamarade> I am trying to a red-black, and I find that I want to make a node know its parent (for balancing purposes), but I can't, because I can't. Anybody hit this before? How did you solve it. Balancing can't be O(n), really.
01:26:03 <ac> why aren't tuples of storeables also storeable?
01:26:21 <quicksilver> @instances Storeable
01:26:22 <lambdabot> Couldn't find class `Storeable'. Try @instances-importing
01:26:24 <quicksilver> @instances Storable
01:26:25 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
01:27:24 <quicksilver> ac: because, I think, Storable was designed for the FFI?
01:27:28 <quicksilver> ac: and C can't use tuples?
01:27:43 <ac> sure would be nice to use tuples in MArrays
01:27:53 <ac> er, I mean IOUArrays
01:29:13 <quicksilver> On reflection I don't think I understand the motivation behind the storable class :)
01:29:28 <quicksilver> so, I don't think I have a sensible answer to your question
01:31:25 <Svrog> quicksilver, dcoutts: thanks, that makes sense - the docs dont make it clear though
01:31:29 <LeCamarade> ping vincenz
01:31:37 <LeCamarade> vincenz: ping
01:32:19 <dcoutts_> quicksilver: I think your initial analysis is right
01:32:40 <dcoutts_> quicksilver: that Storable is for FFI and what is a tuple in C anyway?
01:32:46 * quicksilver nods
01:33:00 <ac> If I want to use tuples I have to switch to diff arrays
01:33:16 <quicksilver> ac: I agree it would be nice to have UArrays for more types.
01:33:35 <quicksilver> there is quite a lot of things it would be nice to do arround array interfaces
01:33:38 <dcoutts_> that's what ndp is trying to do
01:33:40 <ac> I'm sure there's a good reason it hasn't been implemented yet
01:33:41 <quicksilver> the new CArray package helps with some of it
01:35:22 <ac> I had fun writing an algorithm to draw circles with subpixel positioning today while I was "at work"
01:35:36 * dcoutts_ would use cairo
01:35:42 <ac> dcoutts_: yes, that would be reasonable
01:36:17 <quicksilver> xkcd is spot on today : http://xkcd.com/386/
01:36:17 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:37:27 <dcoutts_> quicksilver: heh, heh, yes.
01:37:28 <Mortomes> quicksilver: Monday's xkcd was spot on too
01:38:14 <vincenz> LeCamarade: pong
01:39:38 <ac> I like the eye of the basilisk one
01:42:28 <LeCamarade> vincenz: In your red-black tree, did you have a reference to the parent in the child nodes? (Or am I thinking of balancing in an imperative way? I see that Okasaki's '93 PDF on the structure doesn't commit this sin.)
01:43:05 <vincenz> LeCamarade: no
01:43:39 <LeCamarade> vincenz: Ah. I see. Lemme rethink my balancing strategy. :o)
01:44:12 <osfameron> referencing the parent is a nono for functional trees isn't it?
01:44:34 <LeCamarade> osfameron: I figure as much.
01:44:35 <osfameron> okasaki's red-black in the PFDS book certainly don't reference the parent
01:44:50 <osfameron> (that's the only bit of the book I understand, so I've read it a few times :-)
01:45:23 * LeCamarade doesn't know when to get the courage to steal that book ...
01:46:02 <LeCamarade> I'm going to change tack. Been thinking of it totally wrong. :o( Can't believe it.
01:48:18 <DRMacIver> Hm. I know they're usually the wrong approach, but I'm vaguely surprised there doesn't seem to be a locks library for Haskell.
01:48:33 <quicksilver> DRMacIver: There is.
01:48:38 <quicksilver> DRMacIver: Control.Concurrent.MVar
01:48:49 <quicksilver> (depending what you mean by lock, of course...)
01:49:25 <DRMacIver> MVar isn't really a lock library. I was thinking more of explicit lock types (although I guess you can use MVars as one)
01:50:39 <quicksilver> DRMacIver: an MVar () is pretty much what I normally want when I want a lock.
01:50:49 <quicksilver> Occasionally I store some data in the lock too just because I can.
01:50:54 <quicksilver> What kind of lock are you after?
01:51:03 <dcoutts_> I though one usually locked data?
01:51:09 <DRMacIver> Well, for example, a read/write lock.
01:51:17 <dcoutts_> and so an MVar OfThatData is what one wants usually
01:51:17 <DRMacIver> I'm not really specifically after anything. I was just curious.
01:52:05 <quicksilver> a read/write lock is normally a pair of MVars
01:52:11 <quicksilver> or something.
01:52:36 <DRMacIver> Yes, you can of course implement these locks on top of the existing building blocks. :)
01:53:04 <DRMacIver> Anyway, I was jus curious. It doesn't really matter.
01:53:24 <quicksilver> there might be scope for a slightly higher level reusable abstraction
01:53:37 <dcoutts_> DRMacIver: aye, I'd have expected a RW one to be in the lib already, even though it's just built from MVars, afterall we have chanels and semaphores built from MVars in that lib
01:53:45 <quicksilver> but my personal experience is that MVars are a very good trade-off between reusability and abstraction
01:54:03 <quicksilver> and higher level constructs often turn out to be not quite what you want
01:56:22 <dcoutts_> so what would a RW lock be? just two MVars or would you need a semaphore for the reader side?
01:56:40 <glguy> I wrote a lock type for when you want to ensure that one thread can use a resource at a time and you'd like notification rather than silent deadlock when a thread tries to grab a resource it already has
01:57:15 <glguy> (made easy thanks to the joy of mvars)
01:57:24 <quicksilver> dcoutts_: MVar Int, for the readers, and MVar () for the writer, perhaps.
01:57:34 <wagle_home> static or dynamic notification?
01:57:37 <dcoutts_> glguy: by storing the threadid in the mvar?
01:57:38 <quicksilver> dcoutts_: I expect there is a cunning way of encoding it :)
01:57:46 <wagle_home> 8)
01:59:53 <dcoutts_> quicksilver: hmm, it's tricky since you want a writer to block when there are still readers and you'd prefer new readers to block too I'd expect so that the writer has a chance of getting through and not always competing with new readers
02:00:55 <glguy> dcoutts_: the threadid of the thing holding the mvar is stored in an ioref
02:01:01 <glguy> which you only write to while holding the mvar
02:01:13 <glguy> (Maybe ThreadId)
02:01:30 <glguy> since all you care about is "am I the one holding the lock or not"
02:01:33 <LeCamarade> ?hoogle ansi term
02:01:34 <lambdabot> Did you mean: Ansi Term
02:01:34 <lambdabot> Prelude.undefined :: a
02:01:34 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
02:01:41 <dcoutts_> glguy: right
02:02:11 <glguy> the threadid doesn't go in the mvar so that the thread holding the lock can successfully get the value
02:02:14 <glguy> and abort
02:02:20 <glguy> when it turns out that it deadlocked
02:02:26 <wagle_home> why would you try to acquire the lock twice?
02:02:29 <quicksilver> dcoutts_: well there is more than possible semantics
02:02:32 <LeCamarade> Is there a package to help me write colours to an ANSI terminal?
02:02:37 <dcoutts_> wagle_home: by mistake
02:02:37 <glguy> wagle_home: coding mistake
02:02:38 <quicksilver> dcoutts_: one reason why it's tricky to make this a standard lib :)
02:02:39 <LeCamarade> ?hoogle xterm
02:02:39 <lambdabot> No matches found
02:02:52 <dcoutts_> quicksilver: mmm, I see
02:02:58 <glguy> wagle_home: it's nice for it to announce what mvar it deadlocked on
02:03:06 <glguy> rather than just never responding anymore
02:03:27 <wagle_home> well, ok, i was wondering if you could get the type system to keep you from trying to acquire the lock more than once
02:03:44 <quicksilver> in general, no
02:03:45 <glguy> not without really invasive types
02:03:50 <quicksilver> since that's a halting-problem issue
02:03:57 <faxathisia> I think you'd need substructural typing and haskell doesn't have that
02:04:00 <quicksilver> for certain classes of simple behaviour you can, yes
02:04:16 <glguy> by not allowing arbitrary IO while hodling the lock
02:04:23 <glguy> but only a well defined subset
02:04:25 <quicksilver> you can for example have a special monad which designates the lock
02:04:46 <quicksilver> and then the "acquire lock" combinator doesn't exist inside that monad
02:05:00 <quicksilver> so it becomes a type error to acquire the lock when you've already got it.
02:05:17 <wagle_home> i might be assuming an ordering property to prevent you from deadlocks
02:05:35 <quicksilver> there certainly is interesting stuff you can do statically
02:05:43 <quicksilver> just by useing named monads or similar techniques
02:05:53 <wagle_home> which is one of the ways to do it, but i've never heard why that doesnt always work "in practice"
02:06:01 <glguy> it would be easier to do if more of the stuff in System.IO was lifted into MonadIO by default
02:06:36 <glguy> then some things could work in either the lock allowed context for the base IO
02:06:51 <glguy> or for*
02:08:51 <quicksilver> glguy: s/more of/all of/
02:08:53 <quicksilver> ;)
02:09:32 <glguy> yeah, we're on the same page
02:18:55 * dcoutts_ just did 'cabal upgrade' for the first time
02:18:55 <dcoutts_> and it worked
02:19:11 <quicksilver> \o/
02:19:23 <dcoutts_> which is nice, but I was hoping it'd fail so I could test my new code ! :-)
02:19:54 <dcoutts_> new code for re-calculating what is to be installed when one package out of several fails to build
02:20:52 * dcoutts_ ponders how to guarantee failure
02:20:58 <quicksilver> remove CPU
02:21:03 <dcoutts_> hah hah hah
02:21:05 <wagle_home> unplug the disk
02:21:17 <dcoutts_> I want one package to fail that other packages depend on
02:21:53 <wagle_home> encrypt one of the packages with an unknown random key
02:23:07 <int-e> the obvious idea is to upload a broken package. maybe you could unregister one of the base libs ;)
02:24:57 <Cale> http://www.qwantz.com/
02:25:16 <Cale> :)
02:25:17 * quicksilver instinctively kicks Cale for pasting a URL as his first comment
02:25:25 <Cale> heh
02:25:54 <Cale> and it's not even a Haskell link. So spammy :)
02:26:34 <quicksilver> it does, however, have dinosaurs in.
02:26:37 <quicksilver> Which is pretty good.
02:26:53 <int-e> and radio buttons. which isn't.
02:33:35 <Twey> Haha.
02:44:23 <ac> Cale: that's awful
02:45:09 <faxathisia> regarding writing interpreters for universal languages in total languages earlier, http://www.dcs.st-and.ac.uk/~eb/partial.php
02:45:10 <lambdabot> Title: SK Combinator Calculus Interpreter
02:45:36 <faxathisia> so it can be done using Monads.. :D
02:46:10 <dolio> Ah, yeah, I did know that. Maybe I should have mentioned that earlier.
02:46:29 * faxathisia is just amused that Monads really is the solution to everything
02:46:38 <dolio> There was a nice set of slides way back about it.
02:46:46 <dolio> From some Epigram guys, I think.
02:47:26 <LeCamarade> "I mean, ostensibly, yes. To be frank, we hacked most of it together in monads."
02:48:06 * wagle_home wonders if there is a typed lambda calculus monad yet
02:48:31 <dolio> Also, if you read Moggi's original paper on monads, one of his reasons for introducing them is that the lambda calculus he's working with is strongly normalizing, and he wants a way to model general computation.
02:49:38 <quicksilver> LeCamarade++
02:54:40 <Lord_Illidan> If you are calling a function that returns a custom type, made of two integers, how do you refer to the integers seperately?
02:55:07 <quicksilver> that would depend on the customer tyep
02:55:13 <quicksilver> either by pattern matching
02:55:17 <quicksilver> or by custom functions
02:55:38 <quicksilver> data Custom = Custom Int Int; let Custom a b = fun in a + b
02:55:56 <quicksilver> where 'fun' returns 'Custom', and the let state destructs it, binding a and b to the two components.
02:57:14 <Lord_Illidan> let me issue a quick example
02:57:33 <Lord_Illidan> type Coord = (Integer, Integer)
02:57:34 <Lord_Illidan> type Rectangle = (Coord, Coord)
02:57:48 <Lord_Illidan> bottomLeftPoint :: Rectangle -> Coord
02:57:48 <Lord_Illidan> bottomLeftPoint ((x, y),(x1,y1)) = (x,y)
02:58:05 <quicksilver> so far, so good.
02:58:24 <Lord_Illidan> now, I'd like to make a function that takes a rectangle, and outputs the x part of the bottomLeftPoint of that triangle
02:58:43 <quicksilver> let (x,y) = bottomLeftPoint r in x
02:59:01 <Lord_Illidan> aha
02:59:27 <wagle_home> fst $ bottomLeftPoint r
02:59:34 <quicksilver> or that.
02:59:41 <quicksilver> I've never been a fan of 'fst' and 'snd' though
02:59:44 <Lord_Illidan> :t fst
02:59:47 <wagle_home> yeah
02:59:48 <lambdabot> forall a b. (a, b) -> a
02:59:59 <Lord_Illidan> aha
03:00:08 <quicksilver> I like using let statements and naming stuff.
03:00:09 <Lord_Illidan> thanks
03:00:29 <wagle_home> but i'm not a fan of exposing internal datastructures (which fst fails too)...  8/
03:01:48 <Lord_Illidan> both work, thanks very much
03:03:10 <wagle_home> newtype Coord = Coord { x :: Integer, y :: Integer}
03:03:33 <Lord_Illidan> @hoogle let
03:03:34 <lambdabot> Language.Haskell.TH.letS :: [DecQ] -> StmtQ
03:03:34 <lambdabot> Language.Haskell.TH.letE :: [DecQ] -> ExpQ -> ExpQ
03:03:34 <lambdabot> Text.ParserCombinators.Parsec.Char.letter :: CharParser st Char
03:03:49 <Lord_Illidan> wagle_home, why do that?
03:03:57 <wagle_home> newtype Rectangle = Rectangle { LowerLeft : Coord, UpperRight :: Coord}
03:04:08 <Le-Chuck_ITA> hi there. Is some of you able to compile hsffig and does it work in complex cases such as fuse?
03:04:20 <wagle_home> px = rect.LowerLeft.x
03:04:22 <Lord_Illidan> what's wrong with the type keyword?
03:05:01 <Lord_Illidan> or is the newtype word just syntatic sugar for the type?
03:05:23 <quicksilver> Lord_Illidan: with the type keyword you are not creating a new type
03:05:33 <quicksilver> Lord_Illidan: so you don't get any extra type safety
03:05:36 <quicksilver> it's just a synonym
03:05:50 <quicksilver> someone could pass any old (Integer,Integer) instead of a Coord
03:05:50 <wagle_home> newtype is like data with one constructor..  i was mostly using is for record types though
03:05:56 <quicksilver> @src String
03:05:57 <lambdabot> type String = [Char]
03:06:09 <quicksilver> String is just a synonym for [Char]; you can interchange the two
03:06:22 <Lord_Illidan> ah..well, we're being told to use type synoynms, but thanks for the extra info
03:06:23 <quicksilver> > "abcd" = ['a','b','c','d']
03:06:23 <lambdabot>  Parse error at "=" (column 8)
03:06:27 <quicksilver> > "abcd" == ['a','b','c','d']
03:06:29 <lambdabot>  True
03:06:30 <wagle_home> i dont like type because you can refer to type String = [Char] as [Char], and not know its a String
03:06:44 <quicksilver> However, i'm not sure it matters much in Lord_Illidan's rather simple case
03:06:55 <Lord_Illidan> so newtype lets you use types as records, for instance?
03:06:56 <quicksilver> pairs of coordinates are pretty simple things
03:07:01 <wagle_home> yeah... if he was told to use types, then
03:07:07 <quicksilver> newtype is just a magic special case of data
03:07:17 <quicksilver> don't worry about the distinction between newtype and data too much
03:07:32 <quicksilver> but the distinction between "type" and "newtype or data" is important
03:08:07 <pjd> there's also a distinction between "type and newtype" or "data" though
03:09:02 * wagle_home didnt like type synonyms in pascal, and doesnt like type now
03:10:06 <pjd> basically, "data" creates a new, distinct data type, "type" creates a (synonym) type with no run-time cost, and "newtype" is the intersection of the two
03:10:44 <quicksilver> however, the run-time efficiency issues of newtype are not interesting to a beginner (no offence to Lord_Illidan )
03:10:56 <Lord_Illidan> no offense taken, I am one
03:11:05 <quicksilver> and the obscure semantic differences are not very interesting to anyone
03:11:10 <quicksilver> which is why I gave the advice I did.
03:13:21 <dmwit> Man, every time somebody mentions "newtype", I think of that one paper.  I don't even remember what the paper was about.
03:13:58 <dmwit> But it mentioned that a newtype declaration was an assertion of isomorphism between types, with the newtype constructor naming the isomorphism.
03:14:12 <dmwit> I still think that's just about the coolest way to think about it ever.
03:14:14 <dmwit> =)
03:16:14 <Le-Chuck_ITA> how do I use packages installed in .cabal from ghci?
03:16:30 <Le-Chuck_ITA> I can't find any package.conf
03:17:04 <dcoutts_> Le-Chuck_ITA: once you've used cabal to install them then they're automatically available in ghci
03:17:21 <dcoutts_> Le-Chuck_ITA: you can see what packages ghc knows about using: ghc-pkg list
03:19:04 <Le-Chuck_ITA> dcoutts they don't for me: they are available using ghc-pkg but not using ghci
03:19:14 <Le-Chuck_ITA> problem is I have now made a whole mess
03:19:19 <Le-Chuck_ITA> exactly three seconds ago
03:19:31 <Le-Chuck_ITA> I copied the whole contents of .cabal into my ghc program dir
03:19:47 <Le-Chuck_ITA> they are both a "--prefix" for a configure so I thought it was a good idea to mix them up...
03:19:53 <Le-Chuck_ITA> I suppose I will have to reinstall
03:20:04 <Le-Chuck_ITA> in any case it didn't work for me
03:20:19 <Le-Chuck_ITA> is there something special one has to do when installing cabal?
03:21:20 <dcoutts_> Le-Chuck_ITA: what are you trying to do exactly?
03:21:44 <Le-Chuck_ITA> luckily I copied files wrongly
03:21:51 <Le-Chuck_ITA> so I can recover them
03:21:53 <dcoutts_> Le-Chuck_ITA: I presume you're trying to install some package, as you've already got Cabal installed, it comes with ghc.
03:22:03 <Le-Chuck_ITA> yes I just want to run hfus
03:22:04 <Le-Chuck_ITA> e
03:22:08 <Le-Chuck_ITA> an example of use of HFuse
03:22:27 <Le-Chuck_ITA> and I ha{d,ve} HFuse in .cabal and ghc in $HOME/local-programs
03:22:30 <dcoutts_> ok, so you did: runghc Setup configure && runghc Setup build && runghc Setup install
03:22:41 <resiak> Le-Chuck_ITA: I've got a cabalized and tidied-up branch of HFuse
03:22:42 <Le-Chuck_ITA> no I did cabal-install
03:22:56 <resiak> http://www.willthompson.co.uk/cgi-bin/darcsweb.cgi?r=hfuse;a=summary
03:22:56 <Le-Chuck_ITA> resiak: it's on Hackage isn't it?
03:22:57 <lambdabot> Title: darcs - hfuse, http://tinyurl.com/2vuuka
03:23:29 <resiak> hmm, someone else has also fixed it up since i branched
03:23:42 <dcoutts_> Le-Chuck_ITA: you used cabal install on a locally unpacked hfuse dir, or got it direct from hackage by doing "cabal install hfuse" ?
03:23:42 <resiak> i should merge.
03:24:28 <Le-Chuck_ITA> dcoutts_: the latter
03:24:53 <dcoutts_> Le-Chuck_ITA: ok, so what happened? it failed to install or it worked and now ghc-pkg list HFuse says it's installed?
03:25:27 * dcoutts_ tried it just now and it failed, though due to missing hfuse.h on the system
03:26:10 <Le-Chuck_ITA> dcoutts_: ghc and (at least now) ghc-pkg do not recognize my cabal-installed packages
03:26:22 <Le-Chuck_ITA> this may be the source of many problems I encountered
03:26:39 <Le-Chuck_ITA> oh
03:26:39 <taruti> is someone actively maintaining hfuse?
03:26:45 * taruti has some patches for it
03:26:45 <dcoutts_> Le-Chuck_ITA: do you have any idea why? did the install or register fail?
03:26:55 <Le-Chuck_ITA> taruti: I am no longer actively maintaining ocamlfuse :)
03:27:34 <dcoutts_> Le-Chuck_ITA: what did you mean about copying files into ghc's dir? that sounds like a mistake
03:28:24 <Le-Chuck_ITA> dcoutts_: if I do "ghci -package HFuse" it is loaded - and it shows in ghc-pkg (I had still some mess around), while
03:28:25 <Le-Chuck_ITA> ghci --make HelloFS.hs
03:28:25 <Le-Chuck_ITA> HelloFS.hs:8:7:
03:28:25 <Le-Chuck_ITA>     Could not find module `HFuse':
03:28:37 <hpaste>  taruti pasted "some hfuse patches if someone is interested" at http://hpaste.org/5773
03:28:53 <jair_> hello! I was hoping someone could tell me: how do I "cast" an Integer into a double?
03:29:00 <Le-Chuck_ITA> taruti: did you port it to fuse 2.5?
03:29:15 <taruti> bah. that was snipped in the middle.
03:29:36 <dcoutts_> Le-Chuck_ITA: but HFuse does not export module HFuse so that's not surprising
03:29:39 <taruti> Le-Chuck_ITA: 2.6. + access support + bytestrings + user objects in open/read/write
03:29:54 <dcoutts_> Le-Chuck_ITA: it exposes module System.Posix.HFuse
03:29:57 <taruti> hpaste truncated it.
03:30:18 <Le-Chuck_ITA> dcoutts so hello.fs is wrong :)
03:30:35 <tensh> jair_: fromIntegral
03:30:55 <dcoutts_> Le-Chuck_ITA: seems so
03:31:03 <taruti> the Hello.hs is wrong.
03:31:05 <Le-Chuck_ITA> taruti: do you have a darcs branch?
03:31:32 <taruti> yes, but if you give an email I can darcs send the patches. (that is the easiest way for me)
03:32:21 <jair_> tensh: Oh, thank you very much!
03:32:44 <tensh> yw
03:32:45 <Le-Chuck_ITA> why not putting it on hackagedb? resiak are you the original maintainer or developer?
03:34:25 <taruti> Seems like Gwern-away has uploaded it to hackage.
03:35:18 <taruti> But the hackage-db package and the darcs repo don't seem to match each other.
03:36:26 <Le-Chuck_ITA> the hello filesystem is now working
03:36:28 <Le-Chuck_ITA> very well
03:36:34 <resiak> Le-Chuck_ITA: I haven't had time
03:36:51 <Le-Chuck_ITA> resiak: I haven't had time to update ocamlfuse to 2.6 too
03:36:54 <resiak> I'm not the original maintainer
03:37:00 <resiak> I've updated it, and bindfs works
03:37:17 <Le-Chuck_ITA> so you and taruti should at least merge your own changes
03:37:17 <taruti> resiak: do you have access to the repo?
03:37:22 <resiak> but i didn't want to upload it in hackagedb in its current state
03:37:31 <resiak> taruti: not push access
03:37:55 <taruti> so we both have divergent repos of the main repo and neither of us can push there? :)
03:38:00 <resiak> yep :)
03:38:02 <Le-Chuck_ITA> this is becoming my main concern when not using a "mainstream" language: maintaining bindings for C libraries is much more difficult than maintaining the application that uses them (in my case, relfs)
03:38:21 <dcoutts_> taruti, resiak: do you want hosting on code.haskell.org?
03:38:35 <taruti> dcoutts_: that could work.
03:38:37 <resiak> dcoutts_: wouldn't hurt!
03:38:54 <resiak> taruti: where's your branch?  i need to get on with other things today, but I might have time to look at merging tomorrow
03:39:03 <dcoutts_> resiak, taruti: register at http://community.haskell.org/admin/
03:39:04 <lambdabot> Title: Haskell Community Server
03:39:32 <dcoutts_> resiak, taruti: once you've both got accounts register for a project and list both of you as users
03:39:36 <resiak> cool
03:39:46 <taruti> resiak: I'll msg you the address after uploading it somewhere.
03:39:53 <resiak> great.
03:40:09 <fork> \nick besnd
03:40:47 <Le-Chuck_ITA> do you think the problem of maintaining C bindings has no solution? I thought that HSFFIG could be the solution but it seems rather old or am I wrong?
03:41:06 <dcoutts_> Le-Chuck_ITA: I hope that long-term c2hs will be the popular solution
03:41:26 <resiak> dcoutts_: thanks for the suggestion!
03:41:35 <dcoutts_> it's got the advantage that it can maintain cross-language type safety so it's great for when C header files change underneath you
03:42:07 <Le-Chuck_ITA> dcoutts_ but do you have to hand write a wrapper for every call?
03:42:20 <resiak> it'd be great if c2hs could grow support for auto-generating a tiny C stub to let you call a macro
03:42:26 <dcoutts_> Le-Chuck_ITA: not if you don't want to
03:42:55 <resiak> eg. fuse_main is a macro, so I had to roll a fuse_main_stub with the same arguments that just calls it, and then use the stub from the Haskell code.
03:43:02 <dcoutts_> resiak: you can put inline C in .chs files, but only into the header, not a .c file, but that's enough for inline functions
03:43:30 <dcoutts_> though only if you go -fvia-C
03:43:45 <resiak> oh, really?
03:43:55 <dcoutts_> #c ... #endc
03:44:08 <dcoutts_> gets spit out into the .h file that c2hs processes
03:44:11 <resiak> of course, hfuse uses hsc2hs not c2hs, but i'm not opposed to rectifying that :)
03:44:39 <Le-Chuck_ITA> an up-to-date tutorial on c2hs?
03:44:56 <dcoutts_> @where c2hs
03:44:57 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
03:45:47 <dcoutts_> the tutorial is up to date as far as I know, though it does not mention how to use it with Cabal
03:46:43 <Le-Chuck_ITA> dcoutts_ I see I might be reinventing HSFFIG
03:46:55 <Le-Chuck_ITA> but c2hs requires you to declare a type for every function
03:47:21 <dcoutts_> Le-Chuck_ITA: not if you use {# fun #} hooks
03:47:56 * dcoutts_ goes off to do some real work
03:48:13 <Le-Chuck_ITA> dcoutts_ ok will try it and then ask again if I need :)
03:48:17 <Le-Chuck_ITA> have a nice day
04:35:24 <faxathisia> http://www.inria.fr/rrrt/rr-0530.html
04:35:24 <lambdabot> Title: RR-0530 : The calculus of constructions
04:52:34 <Lord_Illidan> guys, I have a problem in understanding this : test rec1 = let (x,y) = bottomRightPoint rec1 in x
04:52:48 <Lord_Illidan> what does the "in" keyword do in that ?
04:53:02 <dcoutts> > let x = 3 in x + 1
04:53:02 <Lemmih> > let x = 10 in x+2
04:53:06 <lambdabot>  4
04:53:06 <lambdabot>  12
04:53:08 <dcoutts> heh :-)
04:54:21 <DukeDave> Isn't that just: rec1 = fst (bottomRightPoint rec1)
04:54:25 <nornagon> > foldr f a [c..f]
04:54:25 <lambdabot> Terminated
04:54:29 <dcoutts> DukeDave: yep
04:54:40 <dcoutts> > let (x,y) = (3,undefined) in x
04:54:41 <lambdabot>  3
04:54:42 <nornagon> > foldr f 1 [3..4]
04:54:42 <lambdabot>  Add a type signature
04:54:44 <faxathisia> > [c..f]
04:54:44 <lambdabot> Terminated
04:54:46 <nornagon> > foldr f 1 [3..4] :: Expr
04:54:47 <lambdabot>  f 3 (f 4 1)
04:54:55 <Cale> > foldr f z [a,b,c]
04:54:55 <lambdabot> Terminated
04:55:04 <Cale> > foldr f z [a,b,c]
04:55:04 <lambdabot> Terminated
04:55:07 <Cale> hmm
04:55:08 <DukeDave> Or pointlessly:  test = fst. bottomrRightPoint    ?
04:55:11 <Cale> > foldr f z [a,b,c] :: Expr
04:55:12 <lambdabot> Terminated
04:55:17 <Cale> Strange...
04:55:27 <Cale> I'm sure that worked at one point.
04:55:29 <Cale> @version
04:55:30 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
04:55:30 <lambdabot> darcs get http://code.haskell.org/lambdabot
04:55:49 <dcoutts> DukeDave: yep
04:56:07 <Lord_Illidan> DukeDave, dave yep
04:56:28 <Lord_Illidan> >let (x,y,z) = (3,4,5) in y
04:56:29 <DukeDave> Yey, good to see all the C++ I've been writing recently hasn't spoiled my mind :)
04:56:44 <Lord_Illidan> I'm getting hopefully confused thanks to java
04:56:49 <Cale> Lord_Illidan: You need to put a space after the >
04:56:55 <Lord_Illidan> > let (x,y,z) = (3,4,5) in y
04:56:55 <Cale> > let (x,y,z) = (3,4,5) in y
04:56:55 <lambdabot>  4
04:56:56 <lambdabot>  4
04:57:02 <Lord_Illidan> Cale, my bad, sry
04:57:09 <Cale> No problem :)
04:57:18 <Lord_Illidan> still haven't really understood it though
04:57:20 <Lord_Illidan> :t in
04:57:21 <lambdabot> parse error on input `in'
04:57:25 <Lord_Illidan> :t let
04:57:26 <lambdabot> <command line>:
04:57:26 <lambdabot>     Could not find module `L':
04:57:26 <lambdabot>       Use -v to see a list of the files searched for.
04:57:42 <Cale> let/in are keywords
04:58:24 <Lord_Illidan> I can understand this :
04:58:33 <Lord_Illidan> > let x = 10 in x + 2
04:58:34 <lambdabot>  12
04:58:48 <Lord_Illidan> Aw, i got it now
04:59:01 <Cale> Oh, you're confused about the recursion?
04:59:13 <Lord_Illidan> Cale, recursion, what recursion?
04:59:29 <Lord_Illidan> No, I was confused about the in, I was thinking in english terms
04:59:31 <Cale> er, sorry, I somehow misread the original example
04:59:53 <Cale> > let xs = 1 : xs in xs
04:59:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:59:59 <Lord_Illidan> heh
05:00:00 <faxathisia> Can't I use unicode in my source code? like data Term = ★
05:00:04 <Lord_Illidan> Cale, dw
05:00:07 <Cale> (let can define recursive things :)
05:00:19 <Lord_Illidan> So in just returns an output based on the let
05:00:34 <Lord_Illidan> it's basically pattern matching
05:01:07 <Cale> "let <decls> in <expr>" is an expression which makes the declarations in <decls> available to the expression <expr>, and evaluates to whatever <expr> evaluates to in that context.
05:01:37 <Lord_Illidan> I see, thanks a lot Cale
05:01:52 <Cale> faxathisia: To a limited extent.
05:02:16 <Cale> faxathisia: ★ is not a capital letter, so it can't be the start of a constructor name.
05:03:00 <faxathisia> It's a bit odd
05:03:01 <faxathisia> data Term a b = a :★: b
05:03:01 <Cale> faxathisia: Also, it's an extension in GHC, and I've never used it, so I don't know how well it works.
05:03:02 <faxathisia> works
05:03:14 <Cale> That makes sense.
05:03:28 <Cale> So ★ is being treated as a symbol character
05:03:44 <archeens> Earn money online ( New Site ) - http://www.latvianmoney.com/?r=578
05:03:46 <archeens> Earn money online ( New Site ) - http://www.latvianmoney.com/?r=578
05:03:48 <archeens> Earn money online ( New Site ) - http://www.latvianmoney.com/?r=578
05:03:49 <lambdabot> Title: LatvianMoney - Sākums
05:03:49 <lambdabot> Title: LatvianMoney - Sākums
05:03:50 <archeens> Earn money online ( New Site ) - http://www.latvianmoney.com/?r=578
05:03:50 <lambdabot> Title: LatvianMoney - Sākums
05:03:51 --- mode: ChanServ set +o Cale
05:03:54 <lambdabot> Title: LatvianMoney - Sākums
05:04:25 --- mode: Cale set -b *!*@cpe-74-71-129-135.twcny.res.rr.com
05:04:30 --- mode: Cale set -b *!*@191.Red-88-16-120.dynamicIP.rima-tde.net
05:04:32 --- mode: Cale set -b *!*@CPE00012e15cab4-CM00194757ed42.cpe.net.cable.rogers.com
05:04:42 --- mode: Cale set +b *!*@81.198.255.197
05:04:48 --- mode: Cale set -o Cale
05:06:00 <matthew_-> you can't define surround-fix constructors can you? Like list or tuple - they're magic right?
05:06:06 <Cale> right
05:06:35 * dolio will miss that when he goes back to writing Haskell.
05:06:35 <matthew_-> bummer.
05:06:55 <quicksilver> faxathisia: remember that haskell takes a nice lexical view of syntactic classes
05:07:12 <quicksilver> faxathisia: so with a unicode char, it decides which class it falls into, too
05:07:33 <quicksilver> matthew_-: you can do some beautiful hacks with type classes, but I dont recomment it ;)
05:07:43 <quicksilver> iI f a b c Ii
05:08:57 <matthew_-> quicksilver: recomment? I don't comment my code anyway ;)
05:09:03 <quicksilver> ;P
05:09:25 <faxathisia> I want Agda 2 syntax in haskell!
05:09:32 <matthew_-> I want doesn't get
05:09:40 <faxathisia> well there's two things it doesn't do ..
05:09:44 <matthew_-> I want closed type classes.
05:10:04 <dolio> The only problem with Agda2 is that you have to write, say [ [ a ] ].
05:10:21 <Lord_Illidan> can you bind two fsts together?
05:10:28 <faxathisia> You can't write (+ 1) or (1 +) either
05:10:34 <faxathisia> and no pattern matching lambda
05:10:47 <faxathisia> but other than those 3 things.. it's perfect :)
05:10:48 <Lord_Illidan> > fst $ fst $ ((1,2),3,4,5)
05:10:49 <lambdabot>  Couldn't match expected type `(a, b)'
05:10:59 <Lord_Illidan> > fst $ ((1,2),3,4,5)
05:10:59 <quicksilver> Lord_Illidan: yes, you can, but fst only works on 2-tuples
05:11:00 <lambdabot>  Couldn't match expected type `(a, b)'
05:11:04 <quicksilver> Lord_Illidan: not 4-tuples
05:11:07 <dolio> The fact that you can define if_then_else_ blew me away when I saw it.
05:11:17 <Lord_Illidan> heh
05:11:18 <quicksilver> > fst (fst ((1,2),3) )
05:11:19 <lambdabot>  1
05:11:25 <Lord_Illidan> aha, nice :D
05:13:35 <Taejo> if f takes two arguments, and g = f foo (where foo is a big fat expensive expression
05:13:57 <Taejo> ), does calling (g x) reevaluate foo each time?
05:14:15 <dcoutts> Taejo: I think it does not
05:14:30 <quicksilver> it depends on more details than you have shown us
05:14:37 <Taejo> ok
05:14:40 <quicksilver> but it should not, no.
05:14:54 <dcoutts> Taejo: but calling (f foo x) would. naming g = f foo explicitly shares it
05:14:58 <Taejo> looks like a job for trace
05:15:00 <quicksilver> as long as 'g' remains in scope, then there is a "slot" for it.
05:15:12 <quicksilver> and in that slot, the evaluated value of foo will live
05:15:13 <Taejo> ok
05:15:18 <quicksilver> (after the first time its evaluated)
05:15:22 <mrchebas> hey! I compile with "ghc BadMap.hs -o BadMap" and get "/usr/bin/ld: Undefined symbols: ___stginit_containerszm0zi1zi0zi0_DataziMap_  ...."
05:15:32 <dcoutts> Taejo: and so long as g has a monomorphic type
05:15:33 <quicksilver> if g goes out of scope
05:15:34 <matthew_-> oh ffs. Why does ghci say blah blah -XThis -XThat and then -fallow-undecidable-instances ?
05:15:36 <mrchebas> I know it is fixed with "-package containers"
05:15:37 <quicksilver> mrchebas: use --make
05:15:41 <mrchebas> ah ok
05:16:01 <mrchebas> quicksilver: it works, thanks
05:16:02 <quicksilver> Taejo: if 'g' went out of scope, then the evluated foo would be lost
05:16:05 <dcoutts> mrchebas: just always use --make, it's much simpler to do that
05:16:13 <quicksilver> Taejo: e.g. if 'g' was a local variable, and so on.
05:16:28 <Taejo> ok
05:16:36 <quicksilver> (but, even if 'g' is local, there is a good change the compiler will float it up, and it will remain shared)
05:16:42 <quicksilver> unless it depends on other stuff.
05:16:54 <quicksilver> Turns out to be surprisingly hard to answer your question accurately :)
05:17:00 <Taejo> ok, I will test it
05:17:36 <quicksilver> if you want to ensure something is evaluated only once, the safest thing to do is give it a name in a suitable scope
05:17:52 <quicksilver> let foo = (.. expr for foo ..) in ... rest of program ...
05:17:56 <mrchebas> dcoutts: what if I use other tools besides ghc in my makefile. I would like to use ghc as a linker then, I guess --make is also appropriate there?
05:17:59 <quicksilver> that guarantees foo is evaluated at most one.
05:18:16 <Igloo> matthew_-: No good reason, we just haven't updated it yet (if you mean in error messages)
05:18:20 <dcoutts> mrchebas: ghc --make can link executables but not libs
05:18:58 <mrchebas> thanks, dcoutts
05:19:25 <dcoutts> mrchebas: if you're using a makefile then it does make some sense to not use --make, if you're setting up the deps properly etc
05:19:34 <matthew_-> Igloo: yeah, I mean in error messages. Sorry, I really don't get on with the fine grained language feature stuff.
05:20:11 <dcoutts> matthew_-: it's not a lot different from declaring what packages you use
05:21:10 <mrchebas> dcoutts: that's the case indeed, then I should use "-package containers" to help ghc find the libs, right?
05:21:35 <dcoutts> mrchebas: right, when compiling and when linking.
05:22:04 <matthew_-> dcoutts: the difference is that I can just import eg Control.Concurrent and not worry about anything else below that. With the language features stuff, I have to remember *every* single feature.
05:22:16 <dcoutts> mrchebas: and you can -hide-all-packages first, then you know you're not missing any
05:22:19 <mrchebas> dcoutts: the funny thing is that when compiling it does not complain about the lack of  "-package ...", it imports Data.Map happily
05:22:31 <dcoutts> mrchebas: that's what cabal does, -hide-all-packages -package base -package containers etc etc
05:22:40 <matthew_-> dcoutts: ideally, what I would like is to be able to say -fglasgow-exts, then load it into ghci and ask ghci what features I'm using.
05:23:20 <dcoutts> mrchebas: ghc treats all packages as available when compiling but it forgets that info when linking unless you're using --make, hence the utility of the -hide-all-packages flag and only exposing the ones you need
05:23:41 <matthew_-> plus there are bugs. Eg GADTs just result in "Parse error"
05:24:11 <matthew_-> oh, I probably mean KindAnnotations rather than GADTs
05:24:29 <dcoutts> matthew_-: you only need to say what language features you're using in your own module, they're not transitive from modules you import
05:24:38 <matthew_-> yeah yeah
05:24:38 <mrchebas> dcoutts: i understand that ghci might want to see all packages, but for ghc it's a bit funny. I was disconcerted that I had a linking problem (with strange symbol names) instead of a "can't find module" error.
05:25:14 <dcoutts> matthew_-: the problem is that syntactic extensions are hard to handle automagically because it can change the interpretation of the same program
05:25:51 <dcoutts> mrchebas: it's a bit inconsistent for the case that you're not using --make I agree.
05:26:07 <mrchebas> if -hide-all-packages would be the default, it would be less confusing
05:26:27 <dcoutts> mrchebas: I agree, for the batch mode it'd make sense for -hide-all-packages to be default
05:26:28 <matthew_-> also, I love how it doesn't tell you you need overlapping until you actually try to run something
05:27:20 <mrchebas> dcoutts: well i will go change that Makefile, and still make it compilable under ghc 6.6
05:27:29 <mrchebas> thanks a lot
05:27:32 <dcoutts> np
05:28:17 <dcoutts> Igloo: is there any way we could make ghc --make the default and only use batch mode for ghc -c or is that a backwards compat nightmare?
05:29:06 <dcoutts> Igloo: and it's a fair point that ghc foo.hs is weird in that it'll compile but not link, it should either remember packages for linking or hide all packages when compiling
05:30:18 <Igloo> dcoutts: hmm, not sure. It would need discussion, I think
05:30:34 * shapr throws iced lambdas at Igloo
05:31:12 <Igloo> shapr: What flavour?
05:31:26 <shapr> Today's flavor is blueberry.
05:31:28 <dcoutts> Igloo: at first I'd think the only case that overlaps is ghc foo.hs which both compiles and links in batch mode
05:31:31 <Igloo> Mmm, blueberry
05:32:02 <Igloo> dcoutts: And it'll spend time chasing deps, too
05:32:33 <ricky_clarkson> Is lambdavm fairly dead?
05:33:04 <Igloo> dcoutts: Actually, ghc foo.hs already links, but it needs to be a 1 module (+haskell98) program
05:33:06 <ricky_clarkson> (it's a shame CAL isn't syntax-compatible with Haskell)
05:33:20 <dcoutts> Igloo: yes, but my guess is that any system that was deliberately using batch mode is using -c to compile modules and then ghc foo.o -o foo to link compiled binaries, that doing both compiling and linking a main module in batch mode is not used much. That's my impression.
05:33:59 <dcoutts> Igloo: exactly, if that's the only case where we'd be changing the meaning of an existing command line then that seems ok to me
05:34:14 <Igloo> dcoutts: I don't think I object, particularly if it means we can stop -c automatically pulling in haskell98
05:34:37 <Igloo> But the Simons, or the users in general, might have different opinions  :-)
05:34:58 <dcoutts> Igloo: aye, we can float the idea, see if anyone sees any unpleasant cases
05:35:47 <dcoutts> Igloo: how does -c pull in haskell98, doesn't it use all exposed modules?
05:43:46 <Igloo> dcoutts: DriverPipeline.doLink says LinkBinary -> linkBinary dflags o_files [haskell98PackageId], to make Haskell 98 programs Just Work
05:44:21 <dcoutts> Igloo: right, so if we changed "ghc H98Main.hs" to use --make mode then we'd get that for free
05:44:38 <dcoutts> and it'd work for all other packages beyond haskell98
05:44:46 <Igloo> Yeah, and then I think we could make an even-faster build, that doesn't have haskell98, old-locale etc
05:45:27 <dcoutts> Igloo: how? you mean a ghc build flavour that uses fewer libs?
05:45:37 <Igloo> Right
05:49:39 <matthew_-> and whilst I'm moaning, can someone please fix ghci so that it doesn't put empty lines into the history?
05:50:31 <dcoutts> matthew_-: there's already a bug filed about that I believe
05:50:40 <dcoutts> and about using a persistent history
05:50:45 <matthew_-> ahh.
05:51:33 <matthew_-> do I presume that due to the "poisonous" GPL, much effort is being wasted in reimplementing GNU readline to avoid the GPL issue?
05:52:15 <dcoutts> matthew_-: more because osx does not have readline by default, only editline
05:54:42 <matthew_-> that's pretty horrible logic really.
05:55:22 <resiak> dcoutts: presumably that's because of the GPL? :)
05:55:35 <matthew_->     Malformed instance header
05:55:45 <matthew_-> fab error that.
05:55:49 <mux> resiak: I don't see why since OS X includes GPL stuff already
05:55:58 <dcoutts> resiak: that apple don't like shipping gpl libs, yeah, probably
05:56:07 <matthew_-> quite. Safari is built on webkit which is gpl iirc
05:56:10 <mux> they ship with gmake, among others
05:56:11 <resiak> yeah, particularly ones they want to link to things
05:56:15 <dcoutts> mux: gcc dev tools and gpl libs are a bit different
05:56:19 <mux> maybe they want to reduce that as much as opssible though
05:56:21 <dcoutts> gcc/gpl
05:56:31 <mux> dcoutts: gmake has nothing to do with gcc :)
05:56:51 <mux> I suppose they also ship with gnu sort, gnu diff and a few others
05:56:56 <dcoutts> mux: (I meant gpl rather than gcc)
05:57:10 <mux> ah, ok then, gotcha
05:57:22 <dcoutts> mux: gpl tools do not put any requirements on the progs you build with them, that's the key difference for apple
05:58:02 <matthew_-> grr, what's the language open that allows foralls to scope over where clauses?
05:58:06 <matthew_-> s/open/option/
05:58:19 <mux> -fglasgow-exts will work
05:58:26 <matthew_-> yes, I know!
05:58:35 <matthew_-> ScopedTypeVariables looks promising...
05:58:45 <matthew_-> shame about the error message...
05:58:53 <mux> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html#v%3AExistentialQuantification
05:58:53 <lambdabot> http://tinyurl.com/2b93uq
05:59:07 <mux> I use this haddock page to get the list of the possible LANGUAGE programs
05:59:37 <mux> I can't tell which one is the good one though :-P
05:59:42 <Stinger_> ok with your arrows, I'm using HXT and have an arrow that transforms node trees to node trees, is it possible to somehow have an arrow that converts a node tree to a list of tuples?
05:59:44 <matthew_-> mux: getting a list isn't the problem. Working out what you actually need which ghci is just dying on you is the problem
05:59:58 <Stinger_> sorry if this is overly vague but HXT is kinda breaking my brain atm
06:00:22 <dcoutts> matthew_-: aye, the extension list is not at all well documented
06:01:04 <dcoutts> matthew_-: we really want a single page with the list of extensions and examples of each so we know which ones we want
06:03:14 <Saizan> Stinger_: whatthe tuples should contain?
06:04:08 <Stinger_> well in this case taking a set of attributes from an xml node and packing them into a tuple (just values not DOM nodes)
06:04:51 <Stinger_> I am tired and probably not making a lot of sense :(
06:05:42 <Saizan> so like <tag attr1=value1 .. attrn=valuen> to [(attr1,value1) .. (attrn,valuen)] ?
06:07:25 <Stinger_> [(value1,vallue2,value3)] over several nodes
06:08:37 <Stinger_> just ripping raw data from XML, You'd probably actually do this by deserialization to a data type from XML, but I'm trying to learn how this all works
06:13:57 <Saizan> Stinger_: well, you know that the HXT arrow is similar to the list monad? however look at getAttrValue and listA
06:15:06 <Stinger_> basically I have the feeling that the XML arrow is built on a tree type so I'll have to wedge my tuples into this structure somehow. I.e. I cant transform the arrow output into a simple list
06:15:50 <Saizan> Stinger_: the arrow is parametrized in input and output types like any arrow
06:16:09 <Stinger_> yeah I think I need to read about arrows more :|
06:17:52 <Cale> Stinger_: working with HXT?
06:18:03 <Stinger_> yeah
06:18:13 <Cale> Stinger_: It's actually a sort of list transformation arrow.
06:18:19 <Cale> Do you know about the list monad?
06:18:22 <Saizan> newtype LA a b = LA { runLA :: (a -> [b]) }
06:18:28 <Cale> right
06:18:58 <Stinger_> yeah I've seen the list monad
06:20:32 <Cale> So when you chain HXT computations together, it's rather like operating in the list monad. Each arrow gets things one at a time, and produces zero or more results from each.
06:22:14 <shapr> So, what's happening lately?
06:24:20 <Stinger_> hmmmm I can see how I might be able to do what I want
06:24:26 <Cale> shapr: You've seen the new SimpleReflect stuff in lambdabot?
06:24:37 <Cale> > foldr f z [a,b,c]
06:24:38 <lambdabot>  f a (f b (f c z))
06:25:00 <Cale> > iterate f z
06:25:01 <lambdabot>  [z,f z,f (f z),f (f (f z)),f (f (f (f z))),f (f (f (f (f z)))),f (f (f (f (f...
06:26:27 <doserj> > gcd 15 25 :: Expr
06:26:28 <lambdabot>  abs 15 `rem` abs 25 `rem` (abs 25 `rem` (abs 15 `rem` abs 25))
06:26:44 <doserj> hmm...
06:26:48 <Japsu> @type a
06:26:50 <lambdabot> Not in scope: `a'
06:26:54 <Japsu> hmm
06:26:57 <Cale> > abs 15 `rem` abs 25 `rem` (abs 25 `rem` (abs 15 `rem` abs 25))
06:26:58 <lambdabot>  5
06:27:07 <Japsu> one Expr makes others Expr, too?
06:27:38 <Cale> Japsu: pretty much -- lots of Prelude operations are defined on Exprs.
06:28:29 <Japsu> is there any documentation on the Expr magic?
06:28:38 <Cale> @where simplereflect
06:28:38 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
06:28:52 <Japsu> cool, thanks
06:29:10 <Cale> There's actually a little more to it than in the blog post, but for that, you can read the lambdabot source :)
06:29:31 <Japsu> okay :)
06:30:25 <shapr> Cale: Whoa cool!
06:31:06 <Cale> > sum [1..] :: Expr
06:31:09 <lambdabot> Terminated
06:31:16 <Cale> > foldr (+) 0 [1..] :: Expr
06:31:17 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (1...
06:31:22 <idnar> @src sum
06:31:23 <lambdabot> sum = foldl (+) 0
06:31:28 <idnar> oh
06:33:50 <trez> > foldl (+) 0 [1..5] :: Expr
06:33:50 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5
06:35:51 <Cale> scanl (+) 0 [1..5]
06:35:54 <Cale> > scanl (+) 0 [1..5]
06:35:55 <lambdabot>  [0,1,3,6,10,15]
06:35:58 <Cale> > scanl (+) 0 [1..5] :: Expr
06:36:00 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
06:36:05 <Cale> > scanl (+) 0 [1..5] :: [Expr]
06:36:06 <lambdabot>  [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3,0 + 1 + 2 + 3 + 4,0 + 1 + 2 + 3 + 4 + 5]
06:36:38 <int-e> > let bfold _ [x] = x; bfold f xs = bfold f (pairwise f xs); pairwise f (x:y:xs) = f x y : pairwise f xs; pairwise _ xs = xs in bfold (+) [1..11] :: Expr
06:36:39 <lambdabot>  1 + 2 + (3 + 4) + (5 + 6 + (7 + 8)) + (9 + 10 + 11)
06:48:38 <Stinger_> Yay I got my really basic arrow working
06:48:44 <Stinger_> I can go to sleep :)
06:49:27 <quicksilver> :)
06:50:54 <Stinger_> thanks all
07:06:40 <hpaste>  matthew-_ pasted "why does this .cabal file not work?" at http://hpaste.org/5774
07:06:59 <matthew_-> ^^ any ideas?
07:12:06 <doserj> matthew_-: it works here
07:12:46 <matthew_-> I think I've just discovered that my runghc here is erroneously calling ghc6.6
07:12:57 <matthew_-> not that it seems particularly easy to figure that out
07:13:53 <matthew_-> lol. no, it's calling 6.7.20070618
07:13:54 <dcoutts> matthew_-: that sounds likely, old cabal does not understand the {} notation
07:13:57 <matthew_-> how useful!
07:14:13 * matthew_- removes crap from $PATH
07:14:44 <byorgey> hm, session types?  what's that?  sounds interesting.
07:14:53 <matthew_-> well wait 10 mins and it'll be on hackage!
07:15:00 <byorgey> =D
07:15:12 <matthew_-> (again, though this time it'll work with a stable release of ghc)
07:15:41 <matthew_-> grr. how do you make bash update it's hash of where everything is in $PATH?
07:16:03 <byorgey> matthew_-: source ~/.bashrc?
07:16:09 <doserj> hash -r
07:16:21 <matthew_-> doserj: thank you :)
07:16:38 <matthew_-> WHAT'S WRONG WITH TABS!
07:16:38 * dcoutts notes that hackage now warns about using ghc-options: -02 because too many people use it without thinking
07:16:40 <byorgey> huh, you learn something new every day!
07:17:00 <atsampson> byorgey: according to this copy of "An Implementation of Session Types" that I happen to be reading at the moment, they're a way of specifying communication protocols as types
07:17:04 <matthew_-> I don't mind λb being rude to me, but when ghc/cabal is rude to me...
07:17:18 <dcoutts> matthew_-: it changes interpretation of syntax using indentation, which .cabal files do
07:17:23 <byorgey> atsampson: neat.
07:17:40 <byorgey> matthew_-: ghc/cabal was rude to you?
07:17:46 <dcoutts> matthew_-: so the simplest thing is to ban them, then no visual ambiguity
07:18:04 <quicksilver> atsampson: is that the pi-calculus stuff?
07:18:59 <atsampson> yes, essentially -- I was chasing a reference from a Kohei Honda paper
07:19:34 <matthew_-> dcoutts: ok, I'll bite. I use -O2 all the time without thinking. What should I think before using it?
07:20:40 <radix> "I am not a C programmer"
07:20:48 <dcoutts> matthew_-: it prevents people building cabal packages without optimisations and for most code -O2 is no faster than -O and just takes longer to compile and makes bigger binaries. -O2 is where GHC HQ stick all their experimental optimisations that the do not want to turn on by default.
07:21:11 <matthew_-> so using -O is the preferred option?
07:21:33 <dcoutts> matthew_-: use nothing, Cabal uses -O by default unless you configure --disable-optimisation
07:21:40 <matthew_-> ok
07:21:41 <matthew_-> ta
07:22:20 <dcoutts> if it were possible and I had my way, I'd get hackage to require evidence that -O2 ran faster in perf tests than -O before allowing packages to use it.
07:23:11 <byorgey> maybe GHC could export some special types you could use to statically prove that your code runs faster with -O2 than -O  =)
07:23:47 <dcoutts> byorgey: or cabal/hackage support for collecting and presenting the results of perf tests (and correctness tests too)
07:24:04 <byorgey> dcoutts: well, yes, that too of course  ;)
07:24:14 <dcoutts> we have a ticket open on that if anyone wants to hack on it
07:24:45 * dcoutts encourages everyone to join with hacking on hackage
07:25:45 * dcoutts notes that it is more productive than complaining
07:25:55 * matthew_- enjoys complaining too much
07:26:03 <matthew_-> is hackage ever going to get a package maintainer setup a la most linux distros
07:26:04 <matthew_-> ?
07:26:38 <matthew_-> I fully understand that I actively choose licenses that don't forbid it, but it can be a little annoying for others to upload "updated" versions of your own packages
07:26:48 <taruti> having an easy hackage -> debian package bridge would be nice.
07:26:52 <dcoutts> matthew_-: I'd like to see more distro-style management tools for hackage
07:27:12 <dcoutts> taruti: there are tools for generating distro packages for rpm, dep and ebuild (and probably more)
07:27:27 <dcoutts> but they're mostly used by distro packagers, not end users
07:28:03 <taruti> which does not help very much. having an unofficial repo. (build-slaves could probably be found quite easily) would make things easier.
07:28:14 <doserj> I guess that in the medium term there will be several hackages, like one more rigorously maintained one for core libraries, and one more open for other stuff?
07:28:14 <dcoutts> matthew_-: we're almost certainly going to bad uploading the same version of a package again (possibly with a short grace period)
07:28:28 <taruti> or at least Debian is sorely lacking in haskell libraries and there is no good unofficial repo for theme.
07:28:42 <dcoutts> doserj: that's what I'd like to see, yes.
07:28:51 <resiak> hrm, would auto-debianization of cabalized libraries be possible?
07:28:57 * matthew_- enjoys "Pattern match(es) are non-exhaustive" warnings that involve GHC Core
07:29:05 <dcoutts> resiak: it is possible I believe, we do it for gentoo packages
07:29:09 <taruti> resiak: probably.
07:29:32 <dcoutts> the debian team have some tools for it, I don't know the details, we certainly have ones for gentoo
07:29:34 <resiak> i guess for C library bindings it might need help in the shape of manually-supplied build-deps
07:29:42 <dcoutts> right
07:30:15 <dcoutts> taruti: but for installing packages that are not yet handled by the distro there is also cabal-install for per-user installs which is pretty convenient.
07:30:18 <Igloo> resiak: http://urchin.earth.li/pipermail/debian-haskell/2007-June/000322.html is what I do
07:30:34 <Igloo> Most of the time is writing the copyright, description, deps, etc
07:30:51 <taruti> dcoutts: that is convenient for getting things on one machine. but not very to have each programming language having their own package managers.
07:31:03 <matthew_-> hmm. Stanford is starting a Scala course
07:31:33 <dcoutts> doserj: what I'd like to see is a hackage subset defined completely automatically by automated qa testing, that's level 1 if you like, then within that we should make it easy for distro/platform managers to define other sets that pass various other standards and are known to work together etc.
07:31:37 <resiak> Igloo: wow, easier than I feared!
07:32:27 <dcoutts> taruti: sure, but the packages in hackage are always going to be ahead of any distro (partly because distros have QA higher standards) so both are necessary.
07:32:49 <Baughn> Will Control.Concurrent.Chan.writeList2Chan allow me to write an infinite (cyclic) list?
07:33:51 <Baughn> (Also, out of curiosity, what is supposed to happen if you use getChanContents /and/ readChan?)
07:33:53 <Saizan> Baughn: yeah, never terminating
07:34:08 <Saizan> (nothing bad)
07:34:23 <taruti> dcoutts: true.
07:36:27 <int-e> Baughn: mixing readChan and getChanContents is weird but not dangerous - no messages will be lost, and none will be read twice.
07:36:55 <int-e> Baughn: (at least that's how I read the getChanContents source, it's implemented in terms of readChan and unsafeInterleaveIO)
07:39:09 <dcoutts> nominolo: fixed the insn scheduler yet? :-)
07:39:13 <quicksilver> of course, getChanContents will devour your soul and spit you out as novelty biscuits.
07:39:24 <quicksilver> but that may be a risk you're prepared to take.
07:39:27 <nominolo> dcoutts: yes!
07:39:27 <Baughn> quicksilver: 's okay. I wasn't planning to use it.
07:39:29 <nominolo> well, almost
07:39:36 <dcoutts> nominolo: well done
07:39:50 <nominolo> dcoutts: it's incredibly smart
07:39:59 <dcoutts> nominolo: oh yes? how so?
07:40:00 <nominolo> dcoutts: (all due to the SAT-solver)
07:40:24 <nominolo> dcoutts: we have lot's of freedom to route things from one place another and it actually makes use of that
07:40:48 <nominolo> dcoutts: sometimes it's a big too eager shuffling things around, but that doesn't hurt
07:40:54 <dcoutts> nominolo: route what kinds of things?
07:41:38 <nominolo> dcoutts: we can store results either in some temporary buffers or in the register file.  and we can actually change location from cycle to cycle
07:41:49 <nominolo> dcoutts: provided there are enough read/write ports free
07:42:09 <dcoutts> nominolo: temp buffers? what kind of arch is that?
07:42:43 <nominolo> dcoutts: FlexSoC - in the extreme case any value can be routed anywhere
07:43:18 <nominolo> dcoutts: of course that's expensive, so you try to remove some paths and schedule using only those
07:43:21 <Baughn> Oh. Another thing - is it bad if multiple threads put strings on the same handle? I'm okay with them possibly getting jumbled (very unlikely, too), but not crashes.
07:43:48 <Lemmih> Baughn: It won't crash.
07:43:52 <dcoutts> nominolo: ah, reconfigurable. Weirdy :-)
07:44:11 <nominolo> dcoutts: yes, and that's what my scheduler must be able to cope with
07:44:14 <dcoutts> Baughn: putStr can interleave if used from multiple threads
07:44:25 <nominolo> dcoutts: though it's static reconfiguration
07:44:33 <lambdabot> Title: [Debian-haskell] Packaging a Cabal package in 10 easy steps, http://tinyurl.com/yspgf9
07:44:53 <dcoutts> nominolo: so you're trying to find a balance between using the minimum resources and maximum speed but needing more chip resources
07:45:32 <nominolo> dcoutts: yep
07:45:42 <nominolo> dcoutts: in fact some paths are rarely used, so we try to remove them and see if we get much worse schedules
07:45:58 <dcoutts> nominolo: I see, interesting
07:46:03 <nominolo> dcoutts: though, the basic mips datapath needs to stay there
07:47:15 <nominolo> dcoutts: yeah, it's a very interesting problem.  but also hard - you have huge freedom in many directions, so it's hard to find a sweet spot (you can't evaluate all)
07:47:38 <dcoutts> right
07:49:08 <dcoutts> nominolo: how does this kind of stuff work with a time sharing OS? too much reconfiguration would be expensive
07:50:02 <nominolo> dcoutts: interrupts are still an open problem.  but we don't reconfigure the datapath at runtime
07:50:15 <nominolo> dcoutts: we might however reconfigure the instruction set
07:51:16 <dcoutts> nominolo: can you reconfigure data paths when you load different programs? or is it more specialised than that?
07:51:23 <nominolo> dcoutts: also it's meant for embedded systems, so maybe timesharing is not intended.
07:51:28 <dcoutts> I see
07:52:05 <nominolo> dcoutts: i think one chip will have one interconnect
07:52:18 <nominolo> dcoutts: tuned for the intended application
07:53:18 <nominolo> dcoutts: an exposed datapath also comes with much wider instruction words - so you need a compression technique for the instructions
07:53:52 <dcoutts> that's the A-ISA -> N-ISA translation I suppose, decompression
07:53:56 <nominolo> but due to this decompression-stage you can have per-application data-paths
07:54:01 <nominolo> yes
07:54:11 <dcoutts> interesting ideas
07:54:19 <nominolo> AS-ISA = Application-Specific Instruction Set Architecture
07:54:55 <nominolo> dcoutts: yes.  my other options for MSc were some HAppS hacking.  But this one sounded more interesting :)
07:55:01 <dcoutts> nominolo: presumably people have used SAT sovers for instruction scheduling before. Do you know of any examples?
07:55:07 <dcoutts> nominolo: yeah, sounds very interesting
07:55:30 <nominolo> dcoutts: i was just looking.  i only found Integer Linear Programming for Instruction scheduling
07:55:41 <nominolo> (when i started working on this)
07:55:51 <nominolo> but ILP seemed too tricky for me
07:56:10 <nominolo> and i didn't know of any good _free_ solvers
07:56:52 <dcoutts> nominolo: so you're dealing with a single issue cpu, no ILP
07:57:14 <nominolo> no FlexSoC is multi-issue
07:57:43 <nominolo>  Integer Linear Programming = ILP :)
07:57:45 <dcoutts> nominolo: oh you mean ILP=Integer Linear Programming
07:57:46 <dcoutts> right
07:57:48 <dcoutts> :-)
07:57:55 <dcoutts> not instruction level parallelism :-)
07:57:57 <nominolo> but flexsoc is multi-issue too
07:58:13 <nominolo> yeah, overloading sucks ;)
07:58:13 <dcoutts> nominolo: so might this SAT technique help with ghc's NCG too perhaps?
07:58:26 <quicksilver> Baughn: it will jumble but not crash. Safest to use Chans if you don't want jumbling.
07:58:50 <nominolo> dcoutts: no, i think generalized graph-coloring register allocation is good enough and much faster
07:59:09 <nominolo> dcoutts: this only makes sense if you have many non-regular constraints
07:59:21 <dcoutts> nominolo: but that's for register allocation not instruction scheduling, as I understand it at least.
07:59:52 <dcoutts> or am I getting confused with instruction selection?
08:00:19 <nominolo> yes, but it'll be much slower for applications where register allocation can be solved via graph coloring
08:01:11 <nominolo> dcoutts: i actually use a hybrid technique.  i pick instructions via some priority but then use the SAT solver to check if values can be routed from definition to use site
08:01:22 <nominolo> s/technique/approach/
08:01:47 <dcoutts> nominolo: I've got to go teach OOP :-( see you later
08:02:01 <nominolo> and my scheduler might need to backtrack - potentially until the very first instruction
08:02:06 <nominolo> hf ;)
08:02:13 <dcoutts> ta :-)
08:02:22 <Saizan> dcoutts: you isnert subliminal messages on FP, right?:)
08:02:22 <dcoutts> yay, swing guis
08:02:50 <dcoutts> Saizan: yeah, like "well I did this exercise in Haskell with Gtk+ and it was a quarter of the length"
08:02:51 <Baughn> waitForProcess claims to require threading. If I wait for, say, twenty processes.. will that require twenty (OS) threads?
08:03:08 <dcoutts> Saizan: which incidentally is true :-)
08:03:24 <Saizan> dcoutts: it seems a lot plausible :)
08:04:02 <quicksilver> Baughn: waitForProcess doesn't mention requiring more than one OS thread
08:04:12 <quicksilver> Baughn: it just mentions requiring -threaded.
08:04:45 <quicksilver> I don't know the answer to your question, though.
08:04:46 <Saizan> quicksilver: isn't that because it blocks that thread?
08:05:07 <Baughn> quicksilver: It doesn't mention not requiring it either. I can see how you might wait on ten processes with just one thread, but it gets complex.
08:06:08 <quicksilver> Baughn: I suspect you're right, and you should probably use getProcessExitCode
08:06:11 <quicksilver> but I"m not sure.
08:06:50 <dolio> @src groupBy
08:06:50 <lambdabot> groupBy _  []       =  []
08:06:50 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
08:06:50 <lambdabot>     where (ys,zs) = span (eq x) xs
08:09:45 <quicksilver> Baughn: in any case, it's all transparent
08:10:02 <quicksilver> Baughn: the RTS manages new worker threads as foreign calls occur.
08:10:13 <quicksilver> Baughn: and an OS thread isn't *that* expensive.
08:10:15 <Baughn> quicksilver: getProcessExitCode would involve busy-looping, though. I really want a blocking version. :P
08:10:41 <Baughn> quicksilver: I'm /okay/ with making forty threads, I just wanted to know in case I wanted to manage two thousand processes later
08:11:02 <quicksilver> well I guess the argument is, it's at most as many threads as you are creating processes
08:11:12 <quicksilver> and since thread overhead is 2-3 orders of magnitude lower than process overhead
08:11:19 <quicksilver> it's probably not to be worred about too much? :)
08:12:12 <CosmicRay> does ross paterson ever hang out here?
08:12:56 <matthew_-> ok, what's the deal with "Cannot parse language pragma" when you add PatternSignatures to it?
08:13:21 <Baughn> quicksilver: They aren't lightweight threads, which makes the overhead considerably more than that
08:13:24 <Saizan> matthew_-: are you using 6.8.2 or older ?
08:13:42 <Baughn> quicksilver: I'd have to check the source. You /can/ handle any number of children with just one thread, by taking advamtage of sigchld.
08:13:42 <quicksilver> Baughn: lightweight is relative.
08:13:57 <quicksilver> Baughn: they are lightweight compared to processes.
08:14:10 <quicksilver> Baughn: and you're launching processes (that you are waiting for)
08:14:45 <quicksilver> Baughn: so my point was, that the thread overhead is small compared to the process overhead.
08:14:57 <quicksilver> Baughn: however, sigchld is what I meant by using getProcessExitCode.
08:15:00 <Baughn> quicksilver: Agreed, but not by two to three magnitudes
08:15:12 <quicksilver> Baughn: call getProcessExitCode in a sigCHLD handler.
08:15:21 <Baughn> quicksilver: getProcessExitCode is also non-blocking
08:15:40 <quicksilver> right, but you don't call it until you get a sigCHLD
08:15:46 <quicksilver> so it's not a busywait
08:15:57 <Baughn> ..okay. Then I have to know how to handle the sigchld.
08:16:10 <quicksilver> 2-3 orders of magnitude is what I normally see quotes for LWP vs fork()
08:16:53 <matthew_-> brill. Right, so if you have a copyright banner or something at the top of the file then the parser can break trying to parse the LANGUAGE pragma that follows
08:17:14 <Baughn> Actually, never mind. This doesn't matter right now; I'm replacing a /shell script/. It couldn't get slower if I tried.
08:17:14 <matthew_-> putting the LANGUAGE pragma first, before the banner solves the problem. But it's a pretty disgusting issue
08:17:41 <quicksilver> installHandler sigCHLD checkForExits Nothing
08:18:23 <hpaste>  matthew-_ pasted "fab bug" at http://hpaste.org/5775
08:19:05 <quicksilver> @seen zenwryly
08:19:05 <lambdabot> I haven't seen zenwryly.
08:19:22 <quicksilver> CosmicRay: according to his web page, that is his nick. I don't ever remember seeing it.
08:19:52 <CosmicRay> ah ok.
08:19:53 <CosmicRay> thanks.
08:20:28 <Baughn> quicksilver: Hm. That doesn't seem to give you the PID of the child.
08:20:54 <quicksilver> Baughn: I was just going to check the whole list of process handles
08:20:57 * quicksilver shrugs
08:24:02 <shapr> The more I spend time on other irc channels, the more I like #haskell
08:24:36 * araujo throws some sugar lambdas at shapr direction
08:24:47 * shapr throws lambdas of great energy!
08:25:07 * araujo jumps quickly and bites one
08:25:13 <doserj> matthew_-: according to the user manual, ghc should parse both cases. So it seems to be a bug.
08:26:28 <doserj> http://hackage.haskell.org/trac/ghc/ticket/1736 seems to be related
08:26:30 <lambdabot> Title: #1736 (GHC doesn't spot OPTIONS_GHC pragmas after 1k of comments) - GHC - Trac
08:32:21 <faxathisia> hrmf
08:32:35 <matthew_-> doserj: yeah, ToRA had pointed that out to me
08:32:39 <faxathisia> It's really hard to program using typing axioms instead of lambdas
08:32:44 <matthew_-> apparently fixed in 6.9 branch
08:33:12 <matthew_-> or at least is due to be fixed for 6.10
08:33:17 <Baughn> @hoogle a -> [a]
08:33:17 <lambdabot> Prelude.repeat :: a -> [a]
08:33:18 <lambdabot> Data.List.repeat :: a -> [a]
08:33:18 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
08:42:26 <shapr> CosmicRay: I've never seen Paterson here, but he's quite responsive via email.
08:44:17 <CosmicRay> shapr: thanks
08:46:22 <phlpp> @src iterate
08:46:23 <lambdabot> iterate f x =  x : iterate f (f x)
08:46:57 <jre2> if hPrintf is used on a broken handle, should it throw an exception?
08:48:27 <quicksilver> depends what 'broken handle' means.
08:48:36 <quicksilver> You might get SIGPIPE (under posix systems)
08:48:45 <quicksilver> :t hPrintf
08:48:47 <lambdabot> forall r. (HPrintfType r) => GHC.IOBase.Handle -> String -> r
08:48:56 <quicksilver> I didn't even know there was an hPrintf :P
08:49:12 <jre2> in my case, the handle is from a socket
08:49:28 <quicksilver> if by 'broken' you mean 'remote end has closed connection' then yes, you'll get SIGPIPE
08:49:41 <quicksilver> which will terminate your application if you don't handle it
08:49:46 <quicksilver> with the message "Broken Pipe"
08:50:10 <jre2> should the program immediately die silently?
08:50:17 <quicksilver> yup
08:50:31 <Baughn> Saizan: It appears that handing writeList2Chan an infinite list will, in fact, take infinite time. Unfortunate.
08:50:44 <quicksilver> I would recommend handling sigpipe :)
08:51:03 <jre2> ouch then ;)
08:51:13 <quicksilver>   installHandler sigPIPE Ignore Nothing
08:51:26 <quicksilver> excerpt from every server program I have ever written :)
08:51:32 <jre2> haha
08:51:44 <quicksilver> now it will raise an exception instead
08:51:50 <quicksilver> which, if unhandled, will only kill that thread.
08:51:53 <Arnar> hello folks
08:52:00 <jre2> excellent, thanks
08:52:05 <quicksilver> which quite often is a reasonable thing to do.
08:52:08 <quicksilver> (kill the thread)
08:52:19 <quicksilver> if you go for the simple one-thread-per-reader-and-writer architecture
08:52:35 <quicksilver> you can always use the magic of `finally` for any cleanups
08:52:40 <Saizan> Baughn: but other threads should be able to read from that chan
08:53:08 <Baughn> Saizan: They can't, and meanwhile the CPU is at 100%.
08:53:28 <jre2> yea, each client gets their own thread and TChans are used to pass messages around
08:53:31 <Saizan> Baughn: with -threaded?
08:53:41 <quicksilver> Saizan: I think 'Chan' does not have a maximum size.
08:53:43 <Baughn> Saizan: Yep, even with +RTS -N2
08:53:49 <quicksilver> Saizan: it's an unbounded channel.
08:53:53 <Arnar> sorry to interrupt ongoing conversation, but I'd like to pick someone's brain about the STM, specifically if I can somehow within a TX indicate that I want to abort it completely (like retry.. but don't retry). Do exceptions from inside tx already give this semantic?
08:54:21 <Saizan> quicksilver: yeah. so?
08:54:26 <quicksilver> Saizan: tehrefore, writing an infinite list will gradually consume all the space in your system.
08:54:36 <quicksilver> Saizan: it will never block on writing
08:54:47 <quicksilver> another way of saying this: writeChan never blocks. a Chan is never full.
08:54:51 <Saizan> quicksilver: so the thread will never be preempted?
08:54:55 <Baughn> quicksilver: I was hoping it'd write lazily as some other thread tried to read
08:55:14 <quicksilver> Baughn: you probably don't want a Chan, in that case.
08:55:21 <quicksilver> Baughn: you want a bounded buffer, which blocks on writing.
08:55:29 <quicksilver> e.g. an MVar (bounded buffer of size 1!)
08:55:37 <Saizan> quicksilver: if consumer threads are scheduled data can be GCed
08:55:45 <quicksilver> Saizan: I think it should be preempted, in principle, with RTS N2
08:55:59 <quicksilver> Saizan: but in practice the writer thread will run very fast consuming all available memory
08:56:09 <quicksilver> thrashing the GC and not making much progress
08:56:17 <Baughn> quicksilver: Actually, I do. This is just a slight complication, but I know how many I need - "infinity" was just a convenience.
08:56:38 <quicksilver> Baughn: You can write an infinite list to an MVar
08:56:45 <quicksilver> (or a large finite sized one)
08:56:53 <Baughn> Now I just need to write a setDaemon procedure..
08:56:55 <quicksilver> just mapM_ writeMVar
08:57:08 <quicksilver> forkIO (mapM_ (writeMVar mv) list)
08:57:12 <quicksilver> that's a blocking writer
08:57:20 <quicksilver> it will only right as things get removed
08:57:30 <quicksilver> s/right/write/
08:57:35 <quicksilver> damn homonymic typos
08:57:50 <Baughn> Saizan: Oh, I see the issue. I probably shouldn't fork the consumers /after/ writing the infinite list.
08:58:14 <Baughn> Given that it's a cycle I was assuming it'd write the infinite list in finite time, though..
08:58:58 <Saizan> doing infinite operations in finite time is problematic i think
08:59:40 <Baughn> It's not really an infinite operation, either. The channel just needs a reference to the first list element, not a copy of the whole thing.
08:59:43 <Saizan> you still have the problem that the writer can use all your memory if the consumers are not fast enough
09:00:27 <Baughn> ..that is true. I don't see why it should be strict in this manner, but that is a definite point.
09:01:03 <Saizan> well because IO is strict for side-effects in general
09:01:25 <bos> Arnar: you'd probably want to layer failure on top of STM in a transformer
09:01:57 <Baughn> Saizan: Yes, /where it affects the environment/. A chan doesn't.
09:02:03 <quicksilver> it does
09:02:07 <quicksilver> a Chan is part of the environment
09:02:10 <quicksilver> it can affect other threads
09:02:14 <quicksilver> and other threads are IO-things
09:02:21 <quicksilver> because threading is non-deterministic
09:02:35 <Baughn> Other threads wouldn't be able to see the difference, in this case
09:02:35 <quicksilver> writeList2Chan returns when it has written all items
09:02:38 <quicksilver> and not before
09:02:44 <Saizan> Baughn: however MVar and Chan are not strict in the elements they contains, that might be useful to pass infinite lists around
09:02:48 <quicksilver> I don't really understand why you'd expect anything different.
09:03:19 <quicksilver> just as putStr returns when it has written the string, and putMVar returns when it has filled the mvar, etc
09:03:30 <quicksilver> of course you can trivially put forkIO $ in front of something
09:03:31 <Baughn> quicksilver: Most probably because I don't see the downside of making the writeList2Chan operation lazy
09:03:35 <quicksilver> to make it asynchronous
09:03:39 <quicksilver> lazy is not asychronous
09:03:44 <quicksilver> different concepts
09:03:57 <quicksilver> (related, sure, but different)
09:04:34 <quicksilver> I would give the following answer:
09:04:34 <quicksilver> the synchronous version can be transformed to async, trivially
09:04:43 <quicksilver> the async version cannot be transformed to the synchronous one
09:04:55 <quicksilver> so the synchronous one is the correct primitive.
09:05:12 <quicksilver> also, for consistency: almost all other IO options are synchronous in this sense.
09:06:15 <Baughn> To which I'd reply that I want the lazy primitive, not the strict one. I'd like a writeList2Chan that doesn't evaluate the list until a readChan elsewhere forces it to.
09:07:25 <Saizan> that's not really reasonable if you think about what a Chan is
09:07:50 <quicksilver> Baughn: that's just a poor understand of what Chan is.
09:07:54 <quicksilver> Chan doesn't have blocking writes.
09:08:07 <quicksilver> the construct you describe isn't somethign that can be acheived with Chan.
09:08:17 <quicksilver> what you want is an MVar
09:08:18 <Baughn> quicksilver: I am becoming aware of this, yes.
09:08:31 <quicksilver> and my mapM (writeMVar) does exactly what you are asking for
09:08:32 * Baughn nods
09:08:34 <quicksilver> as far as I can see
09:09:09 <quicksilver> Chan = unbounded buffer, writers never block, readers block when buffer is empty
09:09:13 <quicksilver> MVar = buffer of size one, both readers and writers block as expected, "first come first served" fairness principle
09:09:41 <Baughn> Right, I think you've explained it well enough now. I'll use the MVar. :)
09:10:04 <quicksilver> as it happens Chans are constructed from MVars, but in a rather surprising way.
09:10:23 <quicksilver> because they support "dupChan"
09:11:19 <Arnar> bos: sorry, fell offline
09:11:35 <Arnar> bos: so something like Maybe STM ?
09:12:42 <bos> Arnar: well, STM (Maybe a) or MaybeT STM a
09:12:54 <Arnar> bos: ok..
09:13:20 <quicksilver> both of those are the same thing, by the way
09:13:24 <Arnar> is there any way from Haskell, inside a tx to inspect the read- and write-sets of TVars that is maintained by the underlying mechanism
09:13:33 <quicksilver> Arnar: no
09:13:35 <bos> no.
09:13:59 <quicksilver> if you think you need that, you're probably doing something wrong :)
09:14:06 <Arnar> quicksilver: hehe :)
09:14:30 <gnuvince> pattern matching++
09:14:34 <Arnar> quicksilver: i'd like to execute code at the end of a transaction and see if I touched something that I'm not allowed to
09:15:18 <bos> can't do that.
09:15:41 <Arnar> everything is possible.. but it might require hacking ghc you mean :)
09:16:24 <quicksilver> I would try to ensure that statically, using scope
09:16:32 <quicksilver> if the TVars in question aren't in scope, then you can't access them.
09:16:45 <quicksilver> but I don't understand everything you're trying to do.
09:17:06 <quicksilver> I do agree that there are interesting research topics along the lines of augmenting STM with privileges
09:17:16 <Baughn> quicksilver: Thanks for setting me straight. One last thing - is there anything about the (very short) program in http://paste.lisp.org/display/56214 you'd do differently?
09:17:27 <Arnar> quicksilver: precisely
09:20:04 <quicksilver> Baughn: sending out a stream of -1s to cancel the listeners feels a bit clunky
09:20:16 <quicksilver> Baughn: but other than that, it looks sensible
09:20:43 <quicksilver> Baughn: does it work? :)
09:20:52 <Baughn> quicksilver: I don't know yet. The cluster is down. ^^;
09:21:04 <quicksilver> Baughn: I would probably use MVar (Maybe Int)
09:21:13 <quicksilver> and use 'Nothing' to mean 'stop now'
09:21:15 <quicksilver> instead of -1
09:21:20 <quicksilver> feels slightly cleaner
09:21:36 <quicksilver> and instead of pushing "n" Nothings on the chan, I'd just push one
09:21:54 <quicksilver> and I'd get the node , on receiving a Nothing, to push it back before terminating
09:22:14 <Baughn> Makes sense. I was /going/ to make a new datatype for that, but of course Maybe already does that.
09:22:23 <Baughn> Still need to absorb the standard library properly, I see.
09:22:33 * quicksilver nods
09:22:35 <Arnar> bos: with STM (Maybe a) - even if it returns "Nothing" the TX is still committed, right?
09:22:57 <quicksilver> I tend to prefer Maybe every time I would otherwise use a 'special value' in C/C++ like 0 or -1
09:23:05 <quicksilver> Arnar: well, that depends how you design your transaction.
09:23:09 <quicksilver> Arnar: consider this:
09:23:16 <bos> yes.
09:23:24 <quicksilver> do { stuff ; return (Just answer) } `orElse` return Nothing
09:23:43 <quicksilver> then if your primary task succeeds, you definitely commit and return a Just.
09:23:51 <bos> Arnar: what you'd need to do is use orElse to ... yes, what quicksilver says.
09:23:52 <quicksilver> if it retries then it rollsback and returns Nothing
09:23:57 <Arnar> quicksilver: ah, ok..
09:24:01 <Baughn> quicksilver: The only remaining problem now is to not exit until all the threads are actually done
09:24:15 <Arnar> so to have the first one "abort" I'd just call "retry"
09:24:39 <quicksilver> Baughn: yes, that's so commmon I wish there was a reusable abstraction for it.
09:24:41 <Arnar> which triggers the rhs of orElse, right?
09:25:12 <quicksilver> Baughn: basically each thread needs a private MVar () which it "puts" to just before it terminates, and the main thread 'takes' from each of them before *it* terminates.
09:25:26 <quicksilver> Baughn: or you can swap put + take if you prefer since for Mvar () they are symettric :)
09:25:42 <quicksilver> Arnar: correct.
09:26:16 <quicksilver> Arnar: if there is a circumstance in which you really *do* want to retry the first, sometimes, then you need to be a bit cleverer :)
09:26:26 <Arnar> quicksilver: yeah..
09:26:41 <matthew_-> I thought haddock could now parse GADTs?
09:26:43 <Baughn> quicksilver: Mm. I think I'd rather have them write to the /same/ mvar, and the main thread read once per fork
09:26:44 <Arnar> quicksilver: I'm a little unclear on exception semantics with STM
09:27:10 <quicksilver> Baughn: yes, that works too. Of course the writers block each other.
09:27:19 <Arnar> quicksilver: if I throw an exception, am I correct that everything is rolled back except TVars created by the TX and the exception is thrown to the caller of atomically ?
09:27:21 <quicksilver> Baughn: but that doesn't matter if the main thread reads the right number of times.
09:27:34 <quicksilver> Arnar: yes, that is my understanding.
09:27:55 <Arnar> quicksilver: ok, then perhaps I could use an exception instead to indicate the abort
09:28:03 * quicksilver nods
09:28:06 <matthew_-> how are you now meant to build documentation?
09:28:35 <matthew_-> haddock is still unable to parse GADTs for me. I thought it had all been internalised to GHC ?
09:28:35 <duaneb> lambdabot, !paste
09:28:39 <duaneb> damnit
09:28:51 <Baughn> quicksilver: If blocking is a problem, I'll use a chan. As they're dying, though..
09:29:39 <Saizan> quicksilver: can't you just collect the tids and wait on them?
09:29:55 <quicksilver> Saizan: yes, you can do that too. But that feels uglier to me.
09:30:19 <quicksilver> (it exposes the fact that the task only consists of one thread, rather than using forkIO internall)
09:30:46 <matthew_-> grr. it does. so the haddock in debian sid is just ancient and useless. super.
09:30:51 <quicksilver> Arnar: I'm now confused because I don't see a 'throw exception' primitive in STM.
09:31:02 <quicksilver> matthew_-: to be fair to sid, the new haddock changes are very very recent afaik.
09:31:16 <matthew_-> January 8 2008
09:31:24 <matthew_-> so a month and a half
09:31:25 * Arnar looks at the STM paper..
09:31:52 <Saizan> quicksilver: ah, btw, you can't.. there's not such wait primitive :) i'm messing it with the case where you want to stop the threads yourself
09:31:53 <Baughn> quicksilver: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#11 <-- The "better way" uses unsafePerformIO. Is it, in fact, better?
09:31:54 <lambdabot> http://tinyurl.com/y2q5k2
09:33:10 <Arnar> quicksilver: the paper gives SOS rules for "throw N >>= M" from within a TX
09:33:25 <quicksilver> Baughn: yes, that's horrible horrible
09:33:37 <quicksilver> Baughn: but it's just to allocate that stupid global which shouldn't have been global.
09:33:56 <quicksilver> Baughn: it's embarassing to see that in the standard libraries doc.
09:34:15 <quicksilver> Baughn: "children" should just be local to main, and passed to forkChild and waitForChildren
09:34:29 <quicksilver> Arnar: but I don't see any in the implemented STM. hmm.
09:35:06 <quicksilver> Arnar: maybe it's just async exceptions (I.e. thrown by another thread)
09:35:10 <Arnar> quicksilver: hmm.. looking at the SOS I'm not sure if you have to catch it inside the tx
09:35:17 <Arnar> quicksilver: ok..
09:38:38 <quicksilver> Arnar: I'm being stupid.
09:39:04 <Arnar> quicksilver: welcome to my world
09:39:04 <quicksilver> :t Control.Exception.throw
09:39:04 <lambdabot> forall a. GHC.IOBase.Exception -> a
09:39:08 <Gwern-away> hm. that makes three updated or new hackage packages I stole from the decaying corpse of Pugs :)
09:39:08 <quicksilver> you can throw anywhere
09:39:13 <quicksilver> including inside STM :)
09:39:35 <Arnar> :)
09:40:07 <Arnar> so what happens to "atomically (throw 1)"
09:40:43 <quicksilver> the transaction aborts
09:40:49 <quicksilver> and you can catch the exception outside
09:40:51 <quicksilver> IIUC
09:40:54 <quicksilver> (in IO)
09:41:00 <Arnar> yeah.. all inside IO
09:41:04 <Arnar> ok, cool
09:41:06 <Arnar> thanks
09:41:27 <quicksilver> or you can catch in STM if you want
09:41:29 <oerjan> !paste -- duaneb
09:41:30 <hpaste> Haskell paste bin: http://hpaste.org/
09:41:34 <quicksilver> to do something more sophisticated
09:41:47 <quicksilver> :t GHC.Conc.catchSTM
09:41:57 <lambdabot> forall a. GHC.Conc.STM a -> (GHC.IOBase.Exception -> GHC.Conc.STM a) -> GHC.Conc.STM a
09:42:04 <oerjan> the ! prefix is not for lambdabot
09:42:12 <Arnar> mm, interesting
09:43:15 <quicksilver> so we have:
09:43:39 <quicksilver> do { ... stuff ... ; return (Just answer) } `catchSTM` (\_ -> return Nothing)
09:43:54 <quicksilver> which will happily retry the transaction if it "merely" aborts
09:44:02 <Arnar> quicksilver: brilliant..
09:44:03 <quicksilver> but will return Nothing if it gets an exception
09:44:12 <Arnar> and roll back changes to TVars?
09:44:17 <quicksilver> yup
09:44:25 <Arnar> quicksilver++
09:44:30 <Arnar> thanks mate
09:44:35 <Deewiant> hmm, Text.Regex doesn't support non-greedy matching?
09:44:41 <quicksilver> your catch clause should be a bit more careful than mine, though.
09:44:46 <quicksilver> it should check the type of the exception
09:44:55 <quicksilver> but that's the general drift.
09:44:59 <Arnar> quicksilver: yeah..
09:45:18 <quicksilver> you really want something like `catchSTMDyn`, which is easy enough to write.
09:45:22 <bd_> quicksilver: wait, catchSTM will roll back TVars there?
09:45:33 <quicksilver> bd_: the exception rolls back the TVars
09:45:42 <quicksilver> bd_: the catch just lets you observe the fact that that happened
09:45:46 <bd_> ah ok
09:46:16 <oerjan> Deewiant: Text.Regex can be used with several backends.  perhaps one of the alternatives does
09:46:23 <oerjan> (just a guess)
09:46:37 <bd_> hmm, why is check :: Bool -> STM a, rather than :: Bool -> STM ()? It just returns undefined anyway
09:46:53 <bd_> heck, why isn't it just a re-export of Control.Monad.guard?
09:47:28 <quicksilver> catchSTMDyn act handler = catchSTM act (\e -> case e of DynamicException d -> (case fromDynamic dyn of Just f -> (handler f) ; Nothing -> throw e)
09:47:36 <quicksilver> )
09:47:39 <quicksilver> I think that's right :)
09:47:53 <quicksilver> ah, missing _ -> throw e case
09:47:54 <quicksilver> at the end
09:48:22 <Arnar> quicksilver: I'll be left with nothing to do myself.. :P
09:48:24 <quicksilver> @hoogle check
09:48:25 <lambdabot> Control.Monad.STM.check :: Bool -> STM a
09:48:25 <lambdabot> GHC.Dotnet.checkResult :: (State# RealWorld -> (State# RealWorld, a, Addr#)) -> IO a
09:48:25 <lambdabot> Distribution.Simple.Configure.checkPersistBuildConfig :: FilePath -> IO ()
09:48:34 <Deewiant> oerjan: yeah, I was just hoping I wouldn't have to install extra libraries :-)
09:49:10 <quicksilver> bd_: hysterical raisins, I would guess.
09:49:16 <bd_> raisins?
09:49:26 <quicksilver> "historical reasons"
09:49:38 <bd_> mhm
09:49:56 <quicksilver> http://www.jargon.net/jargonfile/h/hystericalreasons.html
09:49:56 <lambdabot> Title: jargon, node: hysterical reasons
09:50:14 <quicksilver> bd_: return undefined is really stupid, as you correctly point out.
09:50:19 <quicksilver> it's just a bug waiting to happen.
09:50:59 <bd_> I don't see any reason to keep it for compatibility - anything which actually inspects the value is already broken anyway :)
09:51:00 <matthew_-> byorgey: Uploaded
09:53:04 <astrolabe> @seen ndm
09:53:04 <lambdabot> I saw ndm leaving #haskell 3d 2h 11m ago, and .
09:53:47 * BMeph69 pities the fool that tries to pattern-match on the result of a check
09:53:51 <wy> hello
09:54:01 <BMeph69> Hi, wy! :)
09:54:16 <wy> BMeph69: hi :)
09:54:52 <wy> Everybody at lunch?
09:55:50 <wy> Has attribute grammar something to do with monads?
09:56:05 <ptolomy> I'm about 15 feet from Matz, creator of ruby. What should I ask him?
09:56:29 <Arnar> ptolomy: ask him if its tuesday
09:56:54 <wy> ptolomy: Ask him what time is it
09:57:42 <ptolomy> I'd prefer not to ask him anything that I can answer by looking at the toolbar of my laptop..
09:57:58 <quicksilver> ask him, if python can make you fly, what method of locomotion is granted by ruby?
09:58:32 <Arnar> require 'disappear'
09:59:01 <Arnar> makes you "jump".. like in that movie
09:59:24 <ptolomy> Hah. Guido is here too.
09:59:25 <ptolomy> Front row.
09:59:26 <hastesaver> does anyone know a clever way of checking if an integer is a square? (I'm currently thinking of finding an approximate integer square root by binary search, then checking if its square is what I have.)
10:00:26 <Nafai> hastesaver: Take the floor of the square root and then square that and see if it is equal to the original
10:00:37 <sili> or simply int()
10:00:42 <wy> ptolomy: where are you?
10:00:43 <quicksilver> I assume he's talking about large integers
10:00:51 <quicksilver> hence out of the range of Double
10:00:58 <Nafai> Ah
10:01:00 <quicksilver> people who care about integer algorithms normally are.
10:01:11 <ptolomy> wy: Google tech talk.
10:02:29 <wy> ptolomy: What's the topic this time? PL?
10:03:21 <oerjan> hastesaver: you can do better than binary search i think, try newton's method
10:03:21 <Gwern-away> (cottleston cottleston, cottleston pie - a bird can fly but a fly can't bird; ask me why, and I reply, cottleston cottleston, cottleston pie)
10:04:09 <quicksilver> oerjan: with efficient access to gmp's underlying structures you can probably "cut the integer in half" to get a rather good first approximation
10:04:19 <quicksilver> oerjan: however, GHC doesn't give us that
10:04:19 <ptolomy> wy: Ruby 1.9
10:04:31 <oerjan> yeah that's a problem
10:05:11 <hpaste>  gwern pasted "ghci doesn't like the string escaping here -what's up?" at http://hpaste.org/5776
10:05:13 <oerjan> probably can do binary search on the length
10:05:23 <oerjan> using Data.Bits
10:05:37 <wy> oerjan: Is there analogies between attribute grammars and monads?
10:05:48 <oerjan> wy: i don't know attribute grammars
10:06:05 <wy> oerjan: It's also a kind of plumbing thing
10:06:08 <ddarius> wy: Attribute grammars can be modelled with state and backward state monads.
10:07:31 <wy> ddarius: monads are really nice. I doubt if anybody understood the lecture today if he doesn't know monads
10:07:52 <ptolomy> Matz: "Blocks were originally designed as a looping abstraction.. but the functional programming people love to ABUSE the block" (emphasis his)
10:07:57 <ptolomy> Sorry, OT.
10:09:19 <wy> ptolomy: haha
10:09:47 <Baughn> ptolomy: Where's that quote from?
10:10:08 <wy> Did he say that just now?
10:11:42 <wy> I found nothing new in ruby
10:12:11 <wy> And am a little confused why it exists
10:13:01 <wy> have to go. see ya!
10:15:00 <dons> ?users
10:15:00 <lambdabot> Maximum users seen in #haskell: 471, currently: 442 (93.8%), active: 21 (4.8%)
10:17:17 <dcoutts> @arr!
10:17:17 <lambdabot> I want me grog!
10:17:47 * dcoutts returns from corrupting the young
10:17:57 <dcoutts> teaching OOP that is
10:19:00 <byorgey> dcoutts: how could you!
10:19:20 <matthew_-> heh. did you teach with great enthusiasm and passion?
10:19:49 <dcoutts> we were doing java GUIs which are always painful
10:20:40 <matthew_-> GUIs are painful full stop. SWT or Swing?
10:20:59 <dcoutts> AWT and/or Swing
10:21:05 <matthew_-> eeeeeeeeeeeeeeeeek.
10:21:06 <dcoutts> with factories to choose between
10:21:17 * matthew_- vomits loudly in reception
10:21:40 <dcoutts> yep, I make no pretences that it's a nice or sensible thing for them to be doing
10:23:26 <dons> dcoutts: did you know ObjectIO is >30k loc?
10:23:36 <dons> seems a pity for all that code to go to waste
10:24:01 <dons> Igloo: git conversioned in 1998 :(
10:24:37 <dcoutts> dons: gtk2hs and wx are probably much bigger
10:24:53 <dcoutts> dons: perhaps it's a shame but it's win32 only so what's the point?
10:25:02 <dons> ah, didn't know it was win32 only
10:26:27 <BMeph69> dcoutts: Why so? Is Clean Win-only?
10:26:33 <Igloo> dons: I can't parse that - do you mean the conversion failed?
10:26:56 <dcoutts> BMeph69: yes, their gui system was windows only, the clean system in general is portable
10:27:33 <BMeph69> dcoutts: Ah, that...sounds like as bad a design decision as CAL. ;)
10:27:36 <dons> Igloo: yeah, i'll try again with tailor.
10:27:41 <dcoutts> BMeph69: indeed
10:30:06 <dcoutts> dons: I think we're fairly close to the point where cabal-install could generate and log build reports locally
10:30:32 <dons> i saw the big dependencies patch land, how far along is that?
10:31:15 <dcoutts> dons: that just improves the case when we're installing a whole bunch of things and we'd rather not fail just because one thing fails
10:31:32 <dcoutts> which is exactly the case when upgrading everything, or when trying to install all of hackage
10:31:35 <dons> great.
10:31:46 <ehird`> 'Freedom of putting arbitrary tail calls is indeed as dangerous, as goto statement, and can produce spagetti code in the same way. So it can't be used as argument for haskell supreme expressive power.'
10:31:49 <ehird`> what the fsck is that guy talking about
10:32:04 <dons> who's that, ehird` ?
10:32:16 <dons> there's a lot of cranks around haskell suddnely. i wonder why.
10:32:23 <ehird`> http://neilmitchell.blogspot.com/2008/01/functional-flow-control.html, first comment
10:32:27 <ehird`> the article isn't very interesting.
10:32:32 <lambdabot> Title: Neil Mitchell's Haskell Blog: Functional Flow Control, http://tinyurl.com/2jnxuh
10:32:45 <dcoutts> dons: SyntaxNinja did a first pass at doing that, but it was not smart about not building packages that depended on another package that had already failed, it just tried to build everything regardless of whether the deps had failed
10:33:58 <dcoutts> ehird`: it's not a completely unfair point, you can use mutual tail recursion to implement the equivalent of goto spaghetti, one just has to avoid doing that.
10:34:06 <oerjan> dons: it's becoming the PL equivalent of relativity theory? :D
10:34:09 <ehird`> dcoutts: only intentionally..
10:34:15 <conal> i recall someone (erik meijer?) saying "general recursion is the goto of functional programming"
10:34:17 <ehird`> you'd have to specifically be trying to be evil
10:34:24 <dcoutts> ehird`: right
10:34:28 <Cale> dons: It turns out that Alan is serious, just a little strange :)
10:34:38 <dons> Cale: yes, i see. most curious.
10:34:38 <ehird`> dcoutts: whereas, goto spaghetti is easy in imperatives
10:35:00 <ehird`> actually, when coding c i use goto quite a lot. but never in a spaghetti way. when coding in something as low level as C, it's a nice way to express flow.
10:35:09 <dons> Cale: i wonder what he programs in, if he doesn't know to look for missing imports
10:35:09 <ehird`> though yesterday I goto'd from the true branch of an if/else into the false one...
10:35:12 <dcoutts> conal: that or continuations and callcc :-)
10:35:28 <Cale> dons: Yeah, I found that pretty surprising.
10:38:43 <oerjan> ehird`: presumably programming something esoteric?
10:40:27 <ehird`> oerjan: well; an interpreter for it.. but the interpreter's code wasn't esoteric. (it was be your funge)
10:40:46 <ehird`> btw -- is there a haskell module I can plug into to get Haskell source code highlighting?
10:40:50 <ehird`> i.e. string in, ? out
10:40:55 <ehird`> preferably something i can easily make into html&css
10:41:05 <oerjan> @where hscolors
10:41:06 <lambdabot> I know nothing about hscolors.
10:41:12 <oerjan> think it's something like that
10:41:37 <oerjan> @where hscolor
10:41:38 <lambdabot> I know nothing about hscolor.
10:41:45 <oerjan> @go hscolor
10:41:46 <lambdabot> No Result Found.
10:42:15 <smg> short question: \x is lambda notation?
10:42:23 <glen_quagmire> smg: yes
10:42:23 <oerjan> sheesh, @go is broken
10:42:27 <smg> glen_quagmire: thank you
10:42:48 <glen_quagmire> smg: \var1 var2 var3 -> expr involving var
10:42:59 <smg> hehe
10:43:05 <ehird`> http://www.cs.york.ac.uk/fp/darcs/hscolour/
10:43:08 <ehird`> that is UGLY
10:43:08 <lambdabot> Title: hscolour
10:43:09 <ehird`> :p
10:43:13 <smg> i just thought of create a list with 2,4,6,8
10:43:16 <glen_quagmire> > (\x y z -> (+) x y + z) 1 2 3
10:43:16 <lambdabot>  6
10:43:33 <ehird`> also, owned by proper english spelling
10:43:36 <smg> take 10 (iterate(\x -> (x+2)) 2)
10:43:38 <oerjan> @where hscolour
10:43:38 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
10:43:40 <smg> is this also okay what i did?
10:43:52 <oerjan> @where+ hscolor http://www.cs.york.ac.uk/fp/darcs/hscolour/
10:43:53 <lambdabot> It is stored.
10:44:08 <glen_quagmire> > take 10 (iterate (\x -> (x+2)) 2)
10:44:08 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
10:44:10 <ehird`> @src fix
10:44:10 <lambdabot> fix f = let x = f x in x
10:44:15 <ehird`> @. pl src fix
10:44:15 <lambdabot> (line 1, column 1):
10:44:15 <lambdabot> unexpected end of input
10:44:15 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
10:44:20 <ehird`> wait, what
10:44:21 <ehird`> :(
10:44:22 <ehird`> @help .
10:44:23 <smg> glen_quagmire: is this haskell way? :)
10:44:23 <lambdabot> . <cmd1> <cmd2> [args].
10:44:23 <lambdabot> . [or compose] is the composition of two plugins
10:44:23 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
10:44:44 <glen_quagmire> smg: i'm not sure, i'd do [2, 4 ..]
10:44:50 <ehird`> @pl fix !f = let x = f x in x   -- ha! ha! ha!
10:44:50 <lambdabot> (line 1, column 8):
10:44:50 <lambdabot> unexpected "="
10:44:50 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
10:44:52 <glen_quagmire> > take 10 [2, 4..]
10:44:52 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
10:44:56 <smg> glen_quagmire: wow!
10:44:59 <smg> glen_quagmire: haskell is awesome
10:45:30 <proq> > take 8 [2, 4..]
10:45:31 <glen_quagmire> no haskell programs are so difficult to read so that people invented literate version of haskell
10:45:32 <lambdabot>  [2,4,6,8,10,12,14,16]
10:45:52 <smg> hehe
10:45:55 <oerjan> ehird`: i don't think @src is @. compatible, i recall
10:46:01 <glen_quagmire> actually, literate haskell was invented because haskell code was so short
10:46:14 <ehird`> aww
10:46:16 <smg> mh i don't know i'm reading yaht and then after a book
10:46:24 <smg> i need to learn haskell for university
10:46:26 <smg> :=)
10:46:37 <proq> sounds like a good university
10:46:45 <ehird`> smg: i hope you're not lost to the people who think haskell is just for academia
10:46:54 <ehird`> .. er, don't ask for examples where it isn't
10:46:57 <smg> ehird`: :P
10:46:59 <proq> if they had taught haskell at mine, I wouldn't have changed my major from CS
10:47:11 <smg> ehird`: no but i don't know if haskell is good for pattern matching / regex
10:47:15 <ehird`> hey, with Text.XHtml, is there a way to get an 'Html' but just containing some raw html?
10:47:16 <smg> i never saw haskell with regex
10:47:21 <ehird`> smg: yes, there are regexp libraries
10:47:25 <smg> ah cool
10:47:39 <ehird`> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html
10:47:39 <smg> because i'm stuying biology + computer science
10:47:40 <lambdabot> http://tinyurl.com/2ub2m7
10:47:45 <smg> and we need to make DNA pattern matching later :]
10:47:56 <ehird`> smg: you could do that with function pattern matching
10:47:57 <smg> ah i will have a look
10:48:03 <smg> ehird`: cool
10:48:07 <ehird`> uh i assume yaht has got to that already :-)
10:48:26 <ehird`> smg: basically, you know how 'a:b' is the list b, with a at the start?
10:48:40 <ehird`> well, you can do 'f (x:xs) = ...', and when you do 'f [1,2,3]' you get x=1 xs=[2,3]
10:48:47 <smg> ok
10:48:50 <ehird`> and you can also do 'f [] = ...' for handling when it's empty
10:48:51 <ehird`> etc
10:48:55 <smg> yeah
10:49:00 <ehird`> and of course : is just one of the things you can match on
10:49:35 <glen_quagmire> > "file1.txt" =~ "\d.txt" :: Bool
10:49:35 <lambdabot>  Illegal escape sequence at ""\d.t..." (column 16)
10:49:56 <smg> ah hoogle is cool :)
10:50:01 <oerjan> \ needs escaping
10:50:15 <EvilTerran> > "file1.txt" =~ "\\d.txt" :: Bool
10:50:15 <lambdabot>   Not in scope: `=~'
10:50:21 <Gwern-away> @seen dons
10:50:21 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 15m 13s ago.
10:50:46 <oerjan> Text.Regex wasn't available in > last i recall
10:50:59 <oerjan> > "file1.txt" Text.Regex.=~ "\\d.txt" :: Bool
10:51:00 <lambdabot>   Not in scope: `Text.Regex.=~'
10:51:01 <Gwern-away> dons: as you requested, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mohws-0.1
10:51:02 <lambdabot> http://tinyurl.com/yvtlmj
10:51:40 <dons> Gwern-away: yay
10:51:47 <oerjan> > [2,4 .. 8]
10:51:48 <lambdabot>  [2,4,6,8]
10:52:23 <dcoutts> Gwern-away: you are asking people before uploading to hackage right? eg bringert's mohws
10:52:56 <Gwern-away> dcoutts: not really. I do usually send'em emails though
10:53:19 <dcoutts> Gwern-away: I really think you should ask people first and wait for their reply, some people are sensitive about it.
10:53:47 <smg> > map \x x+2 (take 10 [2,4 ..])
10:53:47 <lambdabot>  Parse error at "\x" (column 5)
10:54:02 <Gwern-away> dcoutts: that'd take forever. not a few people never reply, and I only hae some much patience, ken? as the pugs folks say, easier to ask forgiveness than permission
10:54:35 <dcoutts> Gwern-away: well I worry that someone will get upset and you'll have your hackage account revoked, that'd be very sad.
10:55:34 <oerjan> > map (\x -> x+2) (take 10 [2,4 ..])
10:55:35 <lambdabot>  [4,6,8,10,12,14,16,18,20,22]
10:55:36 <Gwern-away> dcoutts: if the license allows it (and I don't work on nonfree stuff that doesn't), I see it more as being polite than a necessity
10:55:50 <smg> > map (\x -> x*2) (take 10 [2,4 ..])
10:55:51 <lambdabot>  [4,8,12,16,20,24,28,32,36,40]
10:55:53 <smg> ahhh :D
10:55:57 <dcoutts> Gwern-away: yes it's politeness, we're a polite community
10:56:16 <dcoutts> Gwern-away: this ticket was filed because people were worried about the sudden rash of non-maintainer uploads: http://hackage.haskell.org/trac/hackage/ticket/239
10:56:18 <lambdabot> Title: #239 (security hole: anyone can replace a package) - Hackage - Trac
10:56:35 <smg> now i have a powerfull weapon because i know how to define lambda functions :]
10:56:46 <ehird`> smg: just don't make one of those pesky untypeable ones
10:56:59 <ehird`> like (\f -> (\x -> f (x x)) (\x -> f (x x)))
10:57:04 <smg> ehird`: what's pesky?
10:57:10 <Igloo> Gwern-away: The rules for hackage are orthogonal to what the license says
10:57:15 <ehird`> @define pesky
10:57:16 <lambdabot> Undefined.
10:57:18 <ehird`> wtf
10:57:19 <smg> haha! :)
10:57:25 <smg> i'm not native speaker sorry
10:57:29 <smg> i will look up in dictionary
10:57:30 <ehird`> http://www.google.co.uk/search?q=define%3Apesky&ie=utf-8&oe=utf-8&aq=t&rls=com.ubuntu:en-GB:official&client=firefox-a
10:57:31 <lambdabot> Title: define:pesky - Google Search, http://tinyurl.com/2d9nzq
10:57:33 * Gwern-away feels somehow insulted by that bug
10:57:58 <dcoutts> Gwern-away: it's not impossible to deal with package authors who have disappeared. I'd suggest that if the maintainer does not respond that you post to the libraries list and suggest it being uploaded anyway.
10:58:00 <oerjan> ehird`: a particularly disturbing spelling correction
10:58:22 <sclv_> Gwern: maybe you could find a comprimise solution, like emailing with a notice that you will upload in a week if there is no response, given how many ppl. never do respond.
10:58:25 <oerjan> @vera pesky
10:58:26 <lambdabot> No match for "pesky".
10:58:32 <oerjan> @help vera
10:58:33 <lambdabot> I perform dictionary lookups via the following 13 commands:
10:58:33 <lambdabot> all-dicts ... Query all databases on dict.org
10:58:33 <lambdabot> devils ...... The Devil's Dictionary
10:58:33 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
10:58:33 <lambdabot> elements .... Elements database
10:58:35 <lambdabot> [9 @more lines]
10:58:50 <Gwern-away> dons: anyway, you were right about pugs having some good libraries to steal - I found a binding to Judy in it, for example
10:58:55 <oerjan> and _still_ it doesn't find pesky? O_O
10:59:05 <dons> yep, hsjudy
10:59:05 <Gwern-away> *the C library for Judy arrays
10:59:12 <byorgey> @all-dicts pesky
10:59:12 <lambdabot> *** "Pesky" gcide "The Collaborative International Dictionary of English v.0.48"
10:59:12 <lambdabot> Pesky \Pes"ky\, a. [Etymol. uncertain.]
10:59:12 <lambdabot>    Pestering; vexatious; troublesome. Used also as an intensive.
10:59:12 <lambdabot>    [Colloq. & Low, U.S.] --Judd.
10:59:12 <lambdabot>    [1913 Webster]
10:59:14 <lambdabot> [26 @more lines]
10:59:30 <byorgey> smg: pesky = annoying
10:59:30 <Gwern-away> https://secure.wikimedia.org/wikipedia/en/wiki/Judy_array <-- judy arrays
10:59:48 <smg> hehe okay
10:59:52 <dcoutts> Gwern-away: I think that ticket is about two issues, I don't think they're suggesting that you are causing a problem just that they'd noticed that it was possible for people other than the maintainer to upload. The hackage devs had known that all along but some maintainers did not realise that and filed the ticket.
10:59:54 <Gwern-away> it seems to've been an old google summer project which pugs started maintaining
11:00:07 <Gwern-away> kind of odd, imo, but there you have it
11:00:10 <byorgey> > map (*2) (take 10 [2,4..])  -- smg
11:00:11 <lambdabot>  [4,8,12,16,20,24,28,32,36,40]
11:00:17 <byorgey> =)
11:00:26 <smg> byorgey: intersting
11:00:35 <smg> byorgey: how is this (*2) notation called?
11:00:42 <byorgey> smg: it's an operator section
11:00:48 <smg> ok
11:00:58 <dcoutts> Gwern-away: so we are going to change it so that repeated uploads of the same package are banned because that is a bit dogey, but we're not limiting non-maintainer uploads at this time and we'll just ask everyone to be polite.
11:01:01 <ehird`> smg: i'll explain
11:01:05 <ehird`> in haskell, all functions are curries
11:01:07 <ehird`> a b c
11:01:07 <ehird`> ->
11:01:09 <ehird`> (a b) c
11:01:21 <smg> so i can do also (2*)
11:01:24 <ehird`> which is why it's "a -> b -> c" for a function -- it's "a -> (b -> c)", because it returns a function
11:01:25 <byorgey> smg: yes.
11:01:33 <ehird`> you can do "func a" when the full thing is "func a b"
11:01:36 <ehird`> but you can do the same for binary ops
11:01:48 <smg> hehe
11:02:01 <byorgey> smg: (2*) === \x -> 2 * x, and (*2) === \x -> x * 2
11:02:13 <byorgey> those are the same for * of course, but you can do that with any operator
11:02:22 <smg> byorgey: hehe okay
11:02:24 <Gwern-away> dcoutts: it might make more sense to allow only 1 or 2 reuploads. there are so many cabal fields that a package should have, it's very easy to miss one
11:02:27 <oerjan> smg: there is one exception, (-x) means negation
11:02:29 <smg> this is what i thought it would be :)
11:02:40 <smg> mh makes sense
11:02:48 <byorgey> smg: good, it's supposed to be intuitive =)
11:02:54 <smg> not a binary operator only a unary op
11:02:54 <sclv_> I also think that pugs-HsSyck is the same as HsSyck ?
11:02:56 <ehird`> smg: (+x) too!
11:02:58 <dcoutts> Gwern-away: it's easy to test before uploading, we might allow re-uploads withing the first 30min or something.
11:03:09 <oerjan> > (+2) 2
11:03:14 <ehird`> I think for (-x) you actually need (flip (-) x)
11:03:15 <lambdabot>  4
11:03:22 <ehird`> flip (-) x
11:03:26 <ehird`> \y -> x-y
11:03:28 <ehird`> heh
11:03:31 <sclv_> there should be some sort of merge so we don't have dups like that floating around.
11:03:31 <oerjan> ehird`: subtract x
11:03:33 <dcoutts> Gwern-away: we'll also add a new 'check' command to cabal so you can run all the checks locally before uploading.
11:03:35 <byorgey> ehird`: the 'subtract' function exists for this purpose
11:03:39 <ehird`> oerjan: oh oops
11:03:40 <ehird`> of course
11:03:43 <Gwern-away> dcoutts: no, I mean cabal nor hackage don't warn you about stuff like 'hey, you forgot a tested-with fields - you did make sure some compiler could compile it, right?'
11:03:44 <byorgey> > (subtract 4) 6
11:03:45 <lambdabot>  2
11:04:01 <ehird`> hmmm
11:04:05 <ehird`> Text.XHtml is weird
11:04:23 <sclv_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HsSyck-0.4 and http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pugs-HsSyck-0.41
11:04:24 <lambdabot> http://tinyurl.com/yw5adl
11:04:32 <dcoutts> Gwern-away: of course, though we hope that people check that it compiles at least before uploading.
11:04:36 <sclv_> two names: one package.
11:04:46 <ehird`> Syck has a haskell binding?
11:04:48 <ehird`> whoa
11:04:50 <byorgey> "Judy arrays are also believed to be less vulnerable to algorithmic complexity attacks" -- huh ?
11:04:51 <Gwern-away> dcoutts: so it's easy to forget it, then look at it later and go 'd'oh, I forgot important metadata about which compiler you could compile it with; too bad I can't reupload since it really isn't worth bumping a version for'
11:05:05 <Gwern-away> sclv_: oh. d'oh
11:05:17 <ehird`> ... it's in the io monad. wtf
11:05:34 <dcoutts> Gwern-away: we do want to make it easier to make minor metadata changes later, eg fixing depends or tested with etc
11:05:38 <Gwern-away> byorgey: ie, you know about DoS attacks on quicksort users, right, with sorted input? that's a complexity attack
11:05:40 <resiak> could you not just add a nano-version, anyway?
11:05:42 <Gwern-away> sclv_: I'll fix that in a moment in pugs...
11:05:49 <byorgey> Gwern-away: aha, I see.
11:05:54 <dcoutts> resiak: yes, just add +0.0.0.1
11:05:58 <resiak> yeah
11:06:07 <resiak> it's not as if it hurts people
11:06:10 <dcoutts> quite
11:06:18 * byorgey is pretty sure Gwern-away is joking...
11:06:39 <dcoutts> and if it looks bad, then well it just puts more pressure on uploaders to get it right :-)
11:07:00 <dcoutts> resiak: want some hackage hacking tasks? :-)
11:07:09 <byorgey> hm, I guess not
11:07:15 * dcoutts hands out easy/interesting hackage tickets
11:07:19 <resiak> dcoutts: argh project argh!
11:07:22 <dcoutts> resiak: :-)
11:07:28 <ehird`> :/
11:07:38 <dcoutts> resiak: I suppose I should not ask how that's going then :-)
11:07:38 * ehird` wonders why "abc" +++ hotlink "/foo" "abc" doesn't type in Text.Xhtml
11:08:12 <resiak> dcoutts: well, it's not going badly (modulo stupid bugs in tracker); it's just a time issue
11:09:48 <glguy> ehird`: hotlink's second parameter is of type Html
11:09:55 <glguy> String isn't that type
11:10:20 <ehird`> glguy: oh. yeah.
11:10:27 <ehird`> But `instance HTML Char`
11:10:31 <ehird`> and `instance HTML a => HTML [a]`
11:10:37 <ehird`> So why do they take Html and not HTML a => a? :(
11:10:40 <glguy> HTML /= Html
11:10:42 <ehird`> yeah
11:10:43 <ehird`> i know
11:10:45 <glguy> ehird`: dunno
11:10:49 <glguy> oversight?
11:11:21 <ehird`> glguy: is there any solution? :/
11:11:34 <glguy> ehird`: us toHtml?
11:11:36 <glguy> use
11:11:48 <ehird`> clever
11:11:49 <glguy> hotlink "..." (toHtml "...")
11:11:54 <ehird`> @hoogle String -> String -> Html
11:11:54 <lambdabot> No matches, try a more general search
11:11:57 <ehird`> hrmph
11:12:05 <resiak> @type toHtml
11:12:09 <lambdabot> Not in scope: `toHtml'
11:12:13 <resiak> oh well
11:12:25 <ehird`> @hoogle String -> String -> Text.XHtml.Html
11:12:25 <lambdabot> No matches, try a more general search
11:12:28 <ehird`> :<
11:12:48 <byorgey> ehird`: make an IsString instance?
11:14:06 <smg> > WriteLn foo
11:14:07 <lambdabot>   Not in scope: `foo'
11:14:18 <ehird`> i wonder if Text.XHtml really has to be as strange as it is :P
11:14:36 <glguy> it could be a lot more strange
11:14:46 <glguy> if it were to try to enforce that you produce valid markup
11:14:47 <ehird`> true.. but even s
11:14:48 <ehird`> *so
11:15:00 <ehird`> glguy: that would actually be pretty awesome
11:15:11 <ehird`> data HTMLTag = Head ...
11:15:12 <ehird`> :P
11:15:21 <ehird`> class HeadElement a where ...
11:15:24 <ehird`> instance HeadElement Title
11:15:26 <ehird`> oh wait
11:15:27 <ehird`> you couldn't do that
11:15:31 <ehird`> hah, yes, it would be bizzare :D
11:16:30 --- mode: ChanServ set +o glguy
11:16:35 --- mode: glguy set +b barbie26!*@*
11:16:40 <ehird`> joinfloods are hard
11:16:44 <ehird`> .. i can't bring myself to it
11:17:11 <glguy> I'm just surprised that the ban list wasn't full
11:17:26 <ehird`> us poor, persecuted FPers
11:17:41 <mib_y8yvfh2k> can a list comprehension refer to itself?
11:17:46 <glguy> why not?
11:17:49 <glguy> (yes)
11:17:58 <ehird`> wowzers, Network.FastCGI's errors are awesome
11:18:02 <ehird`> it even knows i'm running nginx :D
11:18:08 <ehird`> and gives me ghc's full error message!
11:18:26 <dcoutts> > let xs = 1 : [ x | x <- xs ] in xs
11:18:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:18:39 <byorgey> > let ns = 0 : [ 1 + n | n <- ns ]   in ns
11:18:41 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
11:19:09 <ehird`> > let xs = 1 : [xs|xs <-xs] in xs
11:19:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:19:14 <xif> I *think* I understand the point made in yesterday's discussion about implementing Erlang-style concurrency in Haskell
11:19:49 <byorgey> ehird`: now that's just evil.
11:20:12 <xif> the point was that it's a problem to serialize and resurrect functions in Haskell because it undermines it's static characteristic, right?
11:20:15 <ehird`> byorgey: yes
11:20:25 <dons> xif: serialising functions is hard in general
11:20:30 <dons> whether typed or not
11:21:00 <dons> but ghc does "erlang style concurrency" doesn't it? shared nothing, light threads
11:21:12 <mib_y8yvfh2k> I want to search al ist of numbers and let the list comprehension pick up only the numbers bigger than the previous one so it cascades up to the biggest one
11:21:45 <dons> > maximum [1,2,1,4,5,2,6,1] -- ?
11:21:46 <lambdabot>  6
11:21:50 <xif> dons: but other languages do, so the question is: why is it particularly problematic for Haskell?
11:21:50 <bos> dons: sort of, depending on which bits you want to cherrypick
11:22:01 <dons> bos, right.
11:22:14 <dons> xif, what languages let you serialise functions?
11:22:14 <zooko> How can I find out what direcotries ghc is looking in when it looks for libraries to link to?
11:22:16 <smg> nice..
11:22:18 <zooko> It says it can't find -lz.
11:22:20 <smg> the prelude is great
11:22:24 <dcoutts> zooko: -v
11:22:32 <xif> dons: Erlang, Smalltalk, Scheme
11:22:34 <zooko> dcoutts: thanks
11:22:38 <glguy> Clean?
11:22:41 --- mode: glguy set -o glguy
11:22:42 <dons> xif, compiled erlang?
11:22:44 <smg> erlang -.-
11:22:51 <dons> generally it can be done if you share bytecode
11:22:52 <zooko> Hm.  ghc -v doesn't tell me about lib dirs.
11:22:56 <dons> native code is a hell of a lot harder
11:23:08 <bos> python, java.
11:23:10 <xif> dons: afaik both static and compiled
11:23:14 <dons> xif, so perhaps you're looking at languages that can share bytecode
11:23:17 <dcoutts> zooko: and if necessary pass -v through to gcc and/or ld with -optl to escape options for gcc, and -optl-Wl, to escape options to ld via gcc.
11:23:55 <dons> xif, i.e. nothing to do with the type system, a lot to do with the form functions take at runtime
11:24:22 <dcoutts> xif: eg yhc could probably do it easily, since it's all portable bytecode
11:24:52 <xif> dcoutts: interesting
11:25:01 <xif> yeah, Python can do that as well, apparently.
11:25:25 <dons> you could distribute ghci bytecode too, with some effort
11:25:41 <dcoutts> though I'm not sure if ghc bytecode is completely portable
11:25:56 <smg> > map (\x -> x `mod` 2 == 0) [1..10]
11:25:57 <lambdabot>  [False,True,False,True,False,True,False,True,False,True]
11:26:04 <smg> > map (\x -> x if x `mod` 2 == 0) [1..10]
11:26:04 <lambdabot>  Parse error at "if" (column 14)
11:26:06 <smg> mh
11:26:15 <dcoutts> dons, xif: I think it may be generated with some architecture dependencies, sizes of primitive types etc
11:26:32 <byorgey> > filter (\x -> x `mod` 2 == 0) [1..10]  -- smg?
11:26:33 <lambdabot>  [2,4,6,8,10]
11:26:50 <smg> byorgey: you're to fast
11:26:56 <smg> i just found "filter" at hoogle :]
11:27:03 <xif> dcoutts: interesting, I'm just wondering about future possibilities right now.
11:27:16 <byorgey> smg: =)
11:27:18 <xif> from what I've seen, GHC supports traditional concurrency well.
11:27:42 <xif> but it doesn't have Erlang's abilities to transparently distribute across cores and machines.
11:27:48 <dons> so you're not asking so much about 'erlang style concurrency', as the ability to send functions through channels?
11:27:48 <byorgey> smg: did you find it by its type?
11:27:53 <bos> serialising code also tends to need the ability to serialise cyclic data, which you can't really do in pure haskell.
11:27:57 <dcoutts> xif: across cores, but not machines
11:28:05 <smg> byorgey: ?
11:28:09 <dons> the distributed versions of haskell are a bit researchy
11:28:10 <xif> dcoutts: right.
11:28:27 <xif> dons: long term, I'm interested in distributing across machines.
11:28:30 <byorgey> smg: I was just wondering how you found filter, did you search for it by name or by its type?
11:28:42 <byorgey> smg: you can give hoogle a type and it will tell you functions that have that type
11:28:49 <smg> i am in the prelude manual :)
11:29:00 <xif> a fast, distributed program that distributes itself transparently across all cores and machines that it has.
11:29:00 <byorgey> @hoogle (a -> Bool) -> [a] -> ([a],[a])
11:29:01 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
11:29:01 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
11:29:01 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
11:29:03 <smg> i now think about how i can get every 3rd element in a list
11:29:06 <smg> byorgey: ah cool
11:29:07 <byorgey> smg: ah, ok =)
11:29:32 <byorgey> smg: ok, have fun
11:29:42 <smg> is there a builtin function for it?
11:29:55 <xif> dcoutts, bos, dons: thanks for the information, I'll probably get into it more as I'm better familiar with Haskell.
11:30:10 <oerjan> smg: not quite
11:30:27 <smg> ok
11:30:32 <bos> xif: i wouldn't hold my breath. transparent distribution of code isn't likely to happen. it's not used much in the languages that provide it.
11:30:48 <mib_y8yvfh2k> let a = [ 1,4,2,5,6,8]let ns = [x| x <- a, x > last ns]  just stall
11:30:48 <monochrom> "continuation fest" :)
11:30:56 <Gwern-away> @seen Cale
11:30:56 <lambdabot> Cale is in ##algorithms, #haskell-overflow, #haskell and #ghc. I last heard Cale speak 55m 27s ago.
11:31:03 <oerjan> > map head . takeWhile (not . null) . iterate (drop 3) $ [1..]
11:31:10 <xif> bos: well, I think it's going to be used more in the future.
11:31:19 <lambdabot>  thread killed
11:31:30 <bos> xif: i doubt it.
11:31:30 <oerjan> > map head . takeWhile (not . null) . iterate (drop 3) $ [1..]
11:31:31 <lambdabot>  [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,...
11:31:32 <xif> so it would be used in languages that currently support it.
11:31:34 <xif> bos: why?
11:31:40 <dcoutts> bringert: note your mohws-0.1 has appeared on hackage
11:31:43 <oerjan> smg: ^^ one way
11:31:46 <smg> oerjan: haha a bit tricky
11:31:50 <xif> bos: you mean specifically across machines, right?
11:31:59 <bringert> dcoutts: hmm, ok
11:32:00 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
11:32:04 <bos> xif: the security issues are too tricky, and the benefits just aren't very big.
11:32:05 <xif> because distribution across cores has obviously become necessary.
11:32:16 <bos> xif: yes, distribution across machines.
11:32:27 <Igloo> dons: Sorry, missed your reply. If you have any succses with tailor, I'd be interested to know how you did it
11:32:57 <bringert> roconnor: that's about HTTP right?
11:33:04 <xif> bos: interesting. what "other languages" that has this feature (but not using it) were you referring to?
11:33:46 <smg> the !! operator is index operator, so is there also a slice operator, like get elements 4-6?
11:34:01 <dcoutts> smg: define slice with take & drop
11:34:02 <oerjan> mib_y8yvfh2k: that last ns doesn't refers to the entire ls, not to any place you currently are building
11:34:09 <bos> xif: it was most trumpeted in java.
11:34:30 <dcoutts> bos: and com/com+/dcom
11:34:46 <smg> dcoutts: ah okay
11:35:34 <oerjan> > map head . groupBy (>=) $ [1,5,3,7,2,4,9,0]
11:35:34 <mib_y8yvfh2k> oerjan any way to do it so I only get bigger numbers than before
11:35:37 <lambdabot>  [1,5,7,9]
11:35:41 <dcoutts> bos: and with COM it turned out that of course you cannot make it transparent because you have to redesign the interfaces to have a much larger granularity of message passing or latency kills you
11:35:48 <oerjan> mib_y8yvfh2k: ^^ a trick for it
11:35:54 <radetsky> does anyone know of a good way (possibly with a guide) to do global configuration with config files?
11:36:22 <radetsky> I looked at ConfigFile, but I still don't entirely understand how I should actually use it
11:36:36 <bos> dcoutts: right.
11:36:37 <dcoutts> radetsky: depends if you want it human editable or not, a cheap and simple way is using a record and Read/Show
11:37:16 <radetsky> I do want it human-editable
11:38:00 <dcoutts> radetsky: then configfile is probably appropriate, see if you can find uses of it if the docs are not clear enough
11:39:02 <smg> dcoutts:
11:39:03 <smg> et slice l x y step = map head . takeWhile (not . null) . iterate (drop step) $ (take ( (-) y x) (drop x l))
11:39:06 <smg> how about that?
11:39:14 <smg> > let slice l x y step = map head . takeWhile (not . null) . iterate (drop step) $ (take ( (-) y x) (drop x l))
11:39:14 <lambdabot>  Parse error at end of input
11:39:22 <Gwern-away> @where Ratio
11:39:22 <lambdabot> I know nothing about ratio.
11:39:46 <dcoutts> smg: I was thinking more of slice n m = take (m-n) . drop n
11:39:56 <oerjan> @index Ratio
11:39:56 <lambdabot> Data.Ratio
11:40:01 <dcoutts> smg: but perhaps I didn't understand what slice was supposed to do
11:40:04 <smg> dcoutts: lol
11:40:16 <smg> i wanted to have a stepping too :]
11:40:52 <oerjan> smg: ( (-) y x) = (y - x)
11:42:29 <smg> hehe
11:43:07 <oerjan> smg: there is another possibility i recall, for a general increasing list of indices
11:43:38 <radetsky> I don't suppose anyone knows of any nontrivial code using ConfigFile?
11:44:19 <smg> mh
11:44:26 <smg> why do you people use "." ?
11:44:43 <dcoutts> smg: because it's cool :-)
11:44:57 <monochrom> because unix people use "|".
11:45:09 <Baughn> Because mathematicians use "."
11:45:19 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html
11:45:21 <lambdabot> Title: The Point of Pointfree
11:45:25 <dcoutts> because it's a nice notation for a very common pattern
11:45:27 <smg> myslice list x y = take (y-x) (drop x list)
11:45:32 <smg> i would have done it that way
11:45:55 <monochrom> why would you put "list" as the first parameter, not the last?
11:46:13 <dcoutts> smg: you want to consider which of those args is most likely to be left off when partially applied
11:46:25 <dcoutts> and make that param last
11:46:27 <Baughn> smg: Think about map
11:46:35 <sclv_> think of it more like http://www.fileformat.info/info/unicode/char/22c5/index.htm
11:46:36 <lambdabot> Title: Unicode Character 'DOT OPERATOR' (U+22C5)
11:46:39 <oerjan> > let l !!! is = map head . takeWhile (not . null) . drop 1 . scanl (flip drop) l $ zipWith (-) is (0:is) in [1..10] !!! [0,5,7]
11:46:43 <lambdabot>  [1,6,8]
11:48:13 <oerjan> > let l !!! is = map head . takeWhile (not . null) . drop 1 . scanl (flip drop) l $ zipWith (-) is (0:is) in [1..10] !!! [0,5,7,12]
11:48:14 <lambdabot>  [1,6,8]
11:49:01 <oerjan> actually tail is safe there since scanl always produces at least one element
11:49:18 <oerjan> (rather than drop 1)
11:49:32 <radetsky> hey does anyone know why I'm getting the following error? Has anyone else had this problem?
11:49:34 <radetsky> Warning: cannot determine version of /usr/local/bin/ghc :
11:49:34 <radetsky> ""
11:49:34 <radetsky> cabal: ghc version >=6.2 is required but the version of /usr/local/bin/ghc could not be determined.
11:49:57 <radetsky> even though ghc --version returns 6.8.2, as expected
11:49:58 <radetsky> ?
11:50:18 <sclv_> gah I got that the other day too.
11:50:24 <sclv_> didn't seem to do any damange however
11:50:35 <radetsky> it's breaking install
11:50:36 * dcoutts tries to remember what caused that
11:50:36 <BMeph69> I have that in my Utility-belt" module - "slice = (. genericTake) . (.) . genericDrop"
11:50:41 <mib_y8yvfh2k> Leaving
11:50:41 <radetsky> that's damage in my book
11:51:22 <dcoutts> radetsky: what Cabal amd/or cabal-install version is that?
11:51:35 <Baughn> BMeph69: Is that /really/ easier to understand than the pointful version?
11:51:35 <radetsky> it's just cabal, 1.2.3.0
11:52:32 <hpaste>  travisbrady pasted "Basic SQL example with Parsec" at http://hpaste.org/5777
11:52:59 <travisbrady> can anyone give me any pointers with the Parsec example I pasted
11:53:08 <BMeph69> Baughn: It depends on how much you know of point-free style, and how much you're trying to learn.
11:53:19 <ehird`> whoever said 'toHtml'
11:53:21 <ehird`> that escapes everything
11:53:22 <ehird`> :(
11:53:23 <travisbrady> I'm looking to factor out some of the boilerplatey-ness
11:53:43 <Gwern-away> @tell Cale I've got nymphaea all cabalized nad cleaned up - but I can't emember what your license was. I'm assuming BSD3, but I'd prefer not to upload until i know
11:53:43 <lambdabot> Consider it noted.
11:54:03 <BMeph69> > let slice = (. genericTake) . (.) . genericDrop in slice 3 5 "abdrcadabra"
11:54:08 <lambdabot>  "rc"
11:54:28 <sclv_> I don't think its was a cabal problem in my case, but a bug in how it handled a broken installation?
11:54:30 <lament> point-free style reminds me of Forth
11:54:36 <lament> ...in a bad way
11:55:05 <radetsky> broken installation of what?
11:55:12 <BMeph69> lament: Pity - I loved using FORTH on my boss' Kaypro... :)
11:55:29 <ehird`> lament: no, Joy.
11:55:47 <ehird`> the invisible " " operator is application in haskell, but concatentation in joy.
11:55:56 <ehird`> in haskell, you need the ".", obviously
11:55:57 <ehird`> but
11:56:00 <ehird`> . is reversed in its arguments. :-P
11:56:18 <sclv_> radetsky: a quick google reveals that the problem may be from running cabal in a directory where it lacks sufficient write privs.
11:56:42 <lament> ehird`: i said Forth because that's the language most likely to cause brain damage.
11:56:46 <oerjan> travisbrady: just one bug first - your <?> should be indented less than the do block, otherwise it doesn't scope over all of it
11:56:48 <dcoutts> sclv_: ah yes! I remember that now. Yes, that's the problem because it uses a temp file.
11:56:51 <sclv_> http://www.mail-archive.com/cabal-devel@haskell.org/msg01477.html
11:56:52 <lambdabot> Title: Re: Weird error message ('Cannot determine version of GHC')
11:56:57 <BMeph69> ehird': Is it, or are the functions just on the wrong side of the argument? ;)
11:57:04 <ehird`> BMeph69: :-)
11:57:05 <travisbrady> oerjan: thank you
11:57:11 <ehird`> lament: forth is pretty useful..
11:57:12 <radetsky> sclv_: well, what do you know!
11:57:15 <ehird`> it teaches you low-level concepts
11:57:36 <BMeph69> FORTH is much more fun and productive - for me - than BASIC.
11:57:37 <dcoutts> radetsky: we fixed the problem in a later cabal but for now work around by making the dir writable.
11:57:44 <travisbrady> oerjan: i'm a python person and i make mistakes w/ haskell's layout constantly
11:57:57 <lament> ehird`: i never said it wasn't.
11:57:58 <sclv_> not to pick on radetsky, but I'm always shocked by how not everybody is in the habit of googling up the most unique parts of error strings.
11:58:25 <BMeph69> lament: It's tough to get in trouble with useless languages... ;)
11:58:54 <byorgey> travisbrady: int, float, and date can certainly be combined into a higher-order parser
11:58:54 <conal> dcoutts: i've had a persistent problem with cabal lately (on winxp).  install often leaves my directories unwritable by me, and i have to manually chmod them back.  does that sound familiar at all to you?
11:59:07 <oerjan> travisbrady: clearly the int to numeric functions have approximately the same form
11:59:24 <dcoutts> conal: which dirs? working src dirs or install dirs?
11:59:33 <conal> dcoutts: install
11:59:48 <dcoutts> conal: are you doing any user switching, like building as yourself and installing as admin?
11:59:50 <radetsky> sclv_: you're right
12:00:11 <radetsky> I usually do, but I was feeling lazy and I had been having lots of issues with cabal lately
12:00:28 <dcoutts> conal: if you can narrow down a simple example of the behaviour then file a ticket in the cabal/hackage bug tracker.
12:00:36 <conal> dcoutts: nope.  all as me.
12:00:38 <radetsky> the mood begins to set in that just googling unique snippets of errors will not help
12:00:38 <travisbrady> byorgey: that's what i'm thinking, could you provide an example?
12:00:39 <conal> dcoutts: okay.
12:01:05 <sclv_> travisbrady: if the parser starts to get huge, you may want to think about using parsec's fancier features, in particular its lexer support.
12:01:06 <slarba> hmm. I've implemented the slowest ip checksum calculation ever :D
12:01:14 <dcoutts> conal: I initially suspect our file copying code which tries to copy the permissions of the original file to the target, and getting and setting perms works a bit differently on windows than unix.
12:01:52 <dcoutts> conal: so it might be doing something like trying to get the permissions, ending up with an empty set of perms and then applying them to the target files
12:01:53 <conal> dcoutts: sure. sounds likely.  it happens most of the time.  and not just dirs, but .o & .a also
12:02:05 <radetsky> dcoutts: does cabal build the target package in the current dir?
12:02:12 <slarba> what would be a good way to split a bytestring into Word16 array and then sum every element up?
12:02:32 <dcoutts> conal: I'd expect it to be just for files, if it happens for dirs too that's weirder. If you can give details of the permissions before and after that'd be great.
12:02:43 <conal> dcoutts: will do.
12:03:34 <slarba> I'm now doing unpack into [Word8], then converting it into [Word16] and sum:ing it. stream fusion is of no help, just tried it
12:03:35 <dcoutts> radetsky: no it puts all generated files under ./dist/ but there was previously a bug where it was putting some temp files in the current dir rather than in the temp dir.
12:04:02 <jsnx> i've been reading http://www.haskell.org/tmrwiki/NumberParamTypes -- i wonder, is there a good reason not to allow `1`, `7`, &c. to parse as types if they are in type, data or class definitions?
12:04:03 <dcoutts> slarba: ideally I'd not start with a bytestring, I'd start by reading an IOArray from a file or a Storable array from a foreign source
12:04:04 <lambdabot> Title: NumberParamTypes - TmrWiki
12:04:14 <ehird`> hm
12:04:20 <ehird`> 'primHtml' makes a String an Html
12:04:25 <ehird`> but prim sounds...scary
12:04:25 <jsnx> or rather, declarations
12:04:30 <ehird`> i can't find anything to use instead though
12:04:33 <slarba> dcoutts: not an option... Network.Pcap produces ByteStrings
12:05:14 <slarba> is there a way to wrap (strict) ByteString into an IOArray very fast?
12:05:28 <dcoutts> slarba: ok, then don't bother going via an array, just iterate over the bytestring getting two Word8's at a time, shifting and combining them into a Word16 and accumulating a sum.
12:05:29 <slarba> but it will make a copy anyway
12:05:43 <slarba> ok
12:06:06 <ehird`> anyone know hscolour?
12:06:13 <hpaste>  byorgey annotated "Basic SQL example with Parsec" with "higher-order parser function" at http://hpaste.org/5777#a1
12:06:14 <ehird`> because the CSS html option, even on partial, produces a doctype&co
12:06:27 <byorgey> travisbrady: ^^^  that's a start, untested but you get the idea =)
12:06:40 <dcoutts> ehird`: send malcolmw patches if you like
12:07:04 <ehird`> dcoutts: is that.. the only option?
12:07:04 <ehird`> :(
12:07:18 <sclv_> ehird seriously is toHTML not doing it?
12:07:30 <dcoutts> ehird`: if it doesn't do what you want. It's a simple program.
12:07:39 <ehird`> sclv_: toHtml "<foo>" -> &lt;foo&gt;
12:07:55 <ehird`> dcoutts: ahh, let's see... if only I could mutate a global, I figured out how to do it :P
12:08:00 <ehird`> just nix cssPrefix&cssSuffic
12:08:01 <ehird`> x
12:08:02 <oerjan> travisbrady: my attempt coming up...
12:08:20 <sclv_> ah then yeh primHTML I think is designed for what you want.
12:08:25 <ehird`> oh wait
12:08:29 <travisbrady> byorgey: thank you very much, reading now
12:08:29 <ehird`> i passed False
12:08:30 <ehird`> instead of True
12:08:32 <ehird`> >_<
12:09:41 <vincenz> > let True = False in True
12:09:43 <travisbrady> byorgey: thats what i wanted to do in terms of factoring out the constant calls to ident but didn't know how to pass a string into a parser like that
12:09:44 <lambdabot>  True
12:09:44 <BMeph69> D'Oh!
12:10:01 <roconnor> conal: I have a set of files for you. :)
12:10:50 <hpaste>  oerjan annotated "Basic SQL example with Parsec" with "my attempt (untested)" at http://hpaste.org/5777#a2
12:10:52 <hpaste>  Lorca_Not_Orca pasted "(no title)" at http://hpaste.org/5778
12:11:46 <oerjan> travisbrady: ^^
12:14:25 <oerjan> travisbrady: hm, actually string "int" <|> string "integer" will not work - integer is never tried
12:15:38 <travisbrady> oerjan: ooh, this brings up a question I've wanted to ask, what does '@' do?
12:17:04 <oerjan> travisbrady: names@(name:_) matches like the pattern after @, but also bindns the whole to names
12:18:00 <monochrom> > case Just 3 of x@(Just y) -> (x, y)
12:18:05 <lambdabot>  (Just 3,3)
12:20:07 <conal> roconnor: send'em!
12:20:17 <oerjan> travisbrady: hm, i think you want many1 rather than many in numeric
12:20:57 <travisbrady> oerjan: thank you
12:20:57 <travisbrady> oerjan: much to learn from your example
12:20:57 <oerjan> same in varchar
12:23:19 <oerjan> travisbrady: skipMany space = spaces
12:25:00 <ehird`> @hoogle String -> String
12:25:00 <lambdabot> Data.Generics.Basics.tyconUQname :: String -> String
12:25:01 <lambdabot> Data.Generics.Basics.tyconModule :: String -> String
12:25:01 <lambdabot> Distribution.Simple.Utils.dotToSep :: String -> String
12:25:07 <ehird`> hrm
12:27:20 <ehird`> (specifically, "   abc  " -> "abc")
12:28:10 <oerjan> what about "   abc  def   " ?
12:29:41 <ehird`> oerjan: "abc  def"
12:29:48 <ehird`> i.e., it's `trim/strip`
12:29:52 <oerjan> bah
12:30:11 <ehird`> let me guess oerjan - you were about to suggest (filter (/= " ")
12:30:12 <ehird`> )
12:30:14 <ehird`> :P
12:30:22 <Lemmih> ehird`: dropWhile isSpace and reverse.
12:30:23 <oerjan> am i predictable :)
12:30:47 <byorgey> > let f = dropWhile isSpace . reverse  in f . f $ "   abc def  "
12:31:03 <lambdabot>  "abc def"
12:31:12 <ehird`> my source file almost doesn't fit on the page without a scrollbar! that's bloat! :-P
12:31:59 <oerjan> > concat . init . tail . groupBy ((==) `on` isSpace) . (' ':) . (++' ') $ "   abc  def   "
12:32:01 <lambdabot>   Not in scope: `on'
12:32:07 <oerjan> @version
12:32:08 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
12:32:08 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:32:13 <vincenz> byorgey: nasty
12:32:25 <byorgey> vincenz: ?
12:32:27 <oerjan> argh!
12:32:30 <vincenz> byorgey: your func
12:32:34 <ehird`> oerjan: .. wow
12:32:51 <oerjan> @let on (==) f x y = f x == f y
12:32:53 <lambdabot> Defined.
12:32:56 <oerjan> > concat . init . tail . groupBy ((==) `on` isSpace) . (' ':) . (++' ') $ "   abc  def   "
12:32:57 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
12:33:00 <ehird`> ridiculous recursive version:
12:33:07 <byorgey> vincenz: yes, but what do you mean by 'nasty' ? =)
12:33:13 <oerjan> > concat . init . tail . groupBy ((==) `on` isSpace) . (' ':) . (++" ") $ "   abc  def   "
12:33:15 <lambdabot>  "abc  def"
12:33:16 <wli> Data.Function should be imported.
12:33:16 <vincenz> byorgey: twce reverse?!?
12:33:37 <ehird`> we need a Data.String
12:33:40 <byorgey> vincenz: it's still O(n), who cares?
12:33:47 <vincenz> splburbly
12:34:18 * byorgey throws premature optimization lambdas at vincenz
12:34:34 <oerjan> wli: heck getting on importing properly was about 50% of the reason i looked forward to lambdabot getting upgraded ;)
12:34:40 <wli> aha, until p = fixWhile (not . p)
12:34:51 * wli likes until
12:34:56 <kmcallister> :t fixWhile
12:34:57 <lambdabot> Not in scope: `fixWhile'
12:35:17 <wli> fixWhile is from my own "useful combinators" stash
12:35:25 <ehird`> :/
12:35:27 <_roconnor> conal: sent
12:35:42 <kolmodin> in gentoo you say "emerge foo --pretend" to see what would be installed to install foo. what is "--pretend" called in debian?
12:35:46 <byorgey> fixWhile p f x = if p x then fixWhile p f (f x) else x ?
12:35:47 <kolmodin> Igloo: ^^
12:35:53 <kmcallister> kolmodin, --dry-run
12:35:56 <wli> ehird`: What would Data.String have in it?
12:35:57 <conal> _roconnor: got it.  thx!
12:36:02 <kolmodin> kmcallister: ah, thanks
12:36:11 <ehird`> wli: Uh. trim, for one. :P
12:36:11 <kmcallister> -s, --simulate, --just-print, --dry-run, --recon, --no-act
12:36:11 <dcoutts> kolmodin: heh, --dry-run also, everyone has copied it
12:36:25 <dcoutts> kmcallister: all those mean the same? all synonyms?
12:36:27 <kmcallister> --just-kidding
12:36:27 <kmcallister> yes
12:36:28 <kolmodin> that settles it then
12:36:36 <kolmodin> --not-really
12:36:42 <dcoutts> kmcallister: I'm confused now :-)
12:36:51 <byorgey> ehird`, wli: uh, there *is* a Data.String.
12:36:55 <kmcallister> the ones on the line with -s are real, they're from the apt-get manpage
12:36:58 <wli> ehird`: Okay, what's trim?
12:37:01 <ehird`> is there
12:37:02 <ehird`> :|
12:37:23 <byorgey> ehird`: yes, it just contains class IsString =/
12:37:27 <ehird`> wli: Remove characters from the start and end of a String where (isSpace c).
12:37:31 <ehird`> In a more efficient way, maybe/
12:37:32 <dcoutts> kmcallister: ok so it has all of those and they all mean exactly the same. Is any the most commonly used? We want to know what to do for cabal.
12:37:39 <kmcallister> i don't know
12:37:42 <ehird`> omfg, they castrated apt-get moo
12:37:46 <ehird`> you don't have to go through five -vs to get the cow now
12:37:49 <ehird`> i am downgrading
12:38:09 * dcoutts wonders what ehird` is smoking
12:38:13 <kmcallister> This APT has Super Cow Powers.
12:38:17 * vincenz chuckles at dcoutts 
12:38:18 <dcoutts> ehird`: perhaps cow? :-)
12:38:22 <kmcallister> dcoutts, "apt-get moo" on a debian system
12:38:35 <ehird`> oh, wait
12:38:36 <mix25> Hi, what do i wrong for this : ERROR file:test.hs:2 - Inferred type is not general enough
12:38:39 <ehird`> no -- they didn't castrate apt-et
12:38:40 <mix25> in:
12:38:45 <ehird`> `aptitude moo` is the one with -vs
12:38:48 <ehird`> (try it out, keep adding -v)
12:38:53 <mix25> factorial :: int -> int
12:38:53 <mix25> factorial (n) = if n>1 then n*factorial(n-1) else 1
12:39:01 <wli> ehird`: trim = trim' . trim' where trim' = reverse . dropWhile isSpace ?
12:39:01 <ehird`> (from 'help':                   This aptitude does not have Super Cow Powers.)
12:39:03 <ehird`> mix25: case matters
12:39:06 <ehird`> it's Int
12:39:10 <ehird`> and use Integer, for a factorial
12:39:16 <ehird`> and remove your parens, they're unneeded
12:39:43 <RayNbow> @faq Can Haskell make me feel less depressive?
12:39:43 <ehird`> wli: Yes pretty much even though that's hideously ugly.
12:39:43 <byorgey> ehird`: hahahahaha
12:39:43 <lambdabot> The answer is: Yes! Haskell can do that.
12:39:43 <RayNbow> lambdabot is a bit laggy :p
12:39:43 * byorgey tries ehird`'s suggestion
12:39:52 <mix25> Same error
12:39:54 <ehird`> byorgey: keep going until it repeats
12:39:55 <RayNbow> or @faq is just a heavy computation :p
12:39:56 <wli> ehird`: What's so ugly about it?
12:40:01 <ehird`> wli: unsure. :P
12:40:08 <byorgey> ehird`: yup, got it
12:40:16 <kmcallister> RayNbow, it sure is, lambdabot has to enumerate all haskell programs until it finds one that "can do that"
12:40:17 <dcoutts> kmcallister, ehird`: hmm, perhaps we should smuggle something like that into cabal ;-)
12:40:21 <ehird`> snakes and elephants don't get along
12:40:32 <byorgey> ehird`: nope
12:40:59 <kmcallister> they're the most ancient of enemies
12:41:00 <kmcallister> class, bbl
12:41:00 <mix25> ehird` same the after change
12:41:00 <ehird`> dcoutts: make it display the haskell logo, with ANSI characters and colours
12:41:00 <mix25> error*
12:41:00 <ehird`> maybe even utilize 256-colours if available
12:41:05 <ehird`> (libcaca will help here)
12:41:15 <ehird`> with libcaca you could even animate it :P
12:41:19 <ehird`> mix25: sohow your code.
12:41:24 <mix25> factorial :: integer -> integer
12:41:24 <mix25> factorial n = if n>1 then n*factorial(n-1) else 1
12:41:25 <dcoutts> ehird`: :-) will accept patches so long as it does not add deps
12:41:41 <mix25> What do i wrong?
12:41:48 <kmcallister> mix25, capitalize Integer
12:41:53 <ehird`> dcoutts: Well, libcaca is a C library. :(
12:41:56 <ehird`> mix25: seriously, what did i say
12:41:57 <ehird`> CASE MATTERS
12:42:06 <ehird`> also you still have parentheses around 'factorial(n-1)
12:42:08 * wli is trying to simplify expressions of the form data Expr = Literal Integer | Sum [Expr] | Prod [Expr] | Quot Expr Expr | Power Expr Rational and having some difficulty.
12:42:28 <ehird`> dcoutts: Maybe make libcaca an optional dependency, and print out a warning that your logo-viewing experience may be impeded on without it?
12:42:34 <mix25> thanks
12:42:47 <dcoutts> ehird`: heh heh
12:42:48 <kmcallister> mix25, also, a more typical way to write it would be:
12:42:50 <kmcallister> factorial 1 = 1
12:42:55 <kmcallister> factorial n = n*factorial (n-1)
12:43:08 <kmcallister> or i guess use 0 for a base case instead of 1
12:43:12 <ehird`> dcoutts: oh, i know..
12:43:13 <mix25> depends of programer :P
12:43:16 <cjb> could you use a pattern match?
12:43:22 <ehird`> mix25: no, that's haskell style
12:43:27 <ehird`> dcoutts: use a 3d library, and pipe it into libcaca
12:43:30 <cjb> or would it need to be matching on the same argument or something?
12:43:34 <ehird`> and add keybindings for controlling its rotation&zoom
12:43:36 <ehird`> and at the bottom
12:43:36 <mix25> ok
12:43:44 <ehird`> 'Can your wimpy C do THIS? Huh? Huh?'
12:43:56 <kmcallister> it is a style question, but there is such a thing as bad style ;)
12:44:02 <ehird`> and a hotkey changes the haskell logo to a 3d version of the source code that displays it
12:44:17 <wli> e.g. Power (Power (Literal (-1)) 2) (1/2) doesn't follow the rule Power (Power e r) r' -> Power e (r * r')
12:44:38 <BMeph69> Haskell: Helping Men Prevent Premature Optimization, since 1990. ;)
12:44:45 <ehird`> hm
12:44:52 <ehird`> where's the highest resolution haskell logo available?
12:46:02 <oerjan> ehird`: it may come as a shock to you but the parentheses around n-1 are needed
12:46:22 <ehird`> oerjan: yes
12:46:27 <ehird`> but not bunched with 'factorial'
12:46:40 <vincenz> ehird`: what are yo high on?
12:46:50 <ehird`> vincenz: haskell
12:46:50 <wli> Not to mention having no clue how to simplify things like (113*2^(2/3) + 433*2^(1/3) - 317)^(1/5) = 2^(2/3) - 2^(1/3) + 3
12:46:52 <oerjan> ehird`: yes they are
12:47:04 <oerjan> i assure you
12:47:50 <ehird`> oerjan: err, i mean
12:47:55 <ehird`> 'factorial(x)' vs 'factorial (x)'
12:48:13 <byorgey> wli: maybe you could add a constructor for absolute value, to deal with that power simplification problem
12:48:34 <ehird`> specifically the haskell logo i want is one with a transparent background
12:48:35 <BMeph69> oerjan: I think ehird' means that the parens should be separated...er, yeah, he's got it. :)
12:48:36 <ehird`> and hopefully png
12:48:55 <jeffz> ehird`: maybe http://www.haskell.org/haskellwiki_logo.png
12:49:08 * BMeph69 works on an SVG version of the logo
12:49:17 <wli> byorgey: That's the easy case; I can introduce you to branch cuts of higher roots than the square root with things in/around roots of unity if you'd like.
12:49:26 <byorgey> wli: hehe, no thanks =)
12:49:28 <ehird`> BMeph69: will it look identical when rendered at the same size? :P
12:49:38 <ehird`> because if it's less shaded, then the ascii art output won't be as cool
12:49:38 <ehird`> :P
12:49:47 <ehird`> woot, that png has a transparent bg
12:50:32 <ehird`> haha, cool ... libcaca can zoom
12:50:37 <ehird`> so it'll start zoomed totally into the haskell logo
12:50:41 <ehird`> then zoom out until it becomes one '.'
12:50:46 <ehird`> then print out something and exit
12:51:25 <BMeph69> Why do I get the idea that the writer of "libcaca" wasn't too impressed with its abilities? ;)
12:51:33 <ehird`> BMeph69: ?
12:52:08 <BMeph69> "caca", as in "crap".
12:52:14 <ehird`> yes
12:52:20 <ehird`> but sam hocevar wrote it
12:52:22 <ehird`> all his stuff is like that
12:52:22 <ehird`> :P
12:52:31 <ehird`> http://libcaca.zoy.org/
12:52:32 <lambdabot> Title: libcaca - Colour AsCii Art library
12:53:01 <dcoutts> ehird`: heh heh, that's cool
12:53:20 <dcoutts> ehird`: yeah, a colour ascii version of the haskell logo would be cool
12:53:24 <ehird`> whoaaaa, img2irc....
12:53:39 <ehird`> #haskell-img, anyone? i'll start a bot to print it out :P
12:54:03 * BMeph69 is mildly interested...
12:57:02 <ehird`> #haskell-img *about* to start..
12:58:32 <ehird`> ok
12:58:35 <ehird`> #haskell-img going NOW
12:59:10 <Japsu> that was pretty
12:59:11 <Japsu> ;D
12:59:34 <ehird`> hehe
12:59:36 <ehird`> trying agin.
13:00:39 <ehird`> going AGAIN..
13:01:51 <ehird`> and again
13:02:49 <vincenz> ehird`: weed is bad for you
13:02:55 <ehird`> going now
13:03:17 <BMeph69> ehird': If you have a problem with GOING...there's a Pill for that! ;p
13:03:24 <ehird`> BMeph69: lmao
13:03:31 <matthew_-> are there any stats available for hackage?
13:03:43 <matthew_-> like how many times a given package has been downloaded etc etc?
13:03:46 <BMeph69> W00t! Five lines! :)
13:03:59 <Saizan> matthew_-: not yet
13:04:13 <matthew_-> well what's taking so long? ;)
13:05:58 <Gwern-away> matthew_-: patches accepted...
13:06:59 <jeffz> Gwern-away: is there a hackage howto for getting packages cabalized and uploaded?
13:07:57 <Taejo> jeffz: there is
13:08:13 <Taejo> http://en.wikibooks.org/wiki/Haskell/Packaging
13:08:20 <jeffz> thanks
13:08:39 <Gwern-away> jeffz: yes, I think there's on in the Haskell wikibook, and also some guides on the haskell wiki
13:11:47 <ehird`> this image is like loading on dialup
13:12:10 <olsner> like loading high-definition video on dialup
13:12:15 <Taejo> ehird`: you might be better off omitting the spaces at the end of lines
13:12:16 <ehird`> yes
13:12:20 <ehird`> Taejo: maybe
13:14:11 <hpaste>  hslogo pasted "(no title)" at http://hpaste.org/5779
13:14:39 <ehird`> lmao
13:14:41 <ehird`> that kind of works in hpaste
13:14:48 <jeffz> :)
13:14:57 <ehird`> no ansi code, though :P
13:15:00 <ehird`> i'll upload a screeny
13:15:06 <radetsky> dcoutts: still here?
13:15:19 <jeffz> erc for emacs strips most of the ansi anyway, it looks better in hpaste for me.
13:15:23 <dcoutts> radetsky: hia
13:15:54 <ehird`> i'll upload a screeny
13:15:59 <jeffz> is it a teapot?
13:16:14 <radetsky> can you point me to an example of using Read/Show for global vars like you were mentioning?
13:17:04 <dcoutts> radetsky: just readFile and use read, or show and writeFile, it's really that simple. You get an exception if the parsing fails so you can use reads if you want.
13:17:14 <ehird`> okay:
13:17:38 <ehird`> http://0xff.m000.org/sdfsdfsdf.png
13:19:38 <radetsky> umm, I'm not sure that's what I want
13:20:43 <ehird`> err
13:20:46 <ehird`> http://0xff.m000.org/sdfsdfsdf.png <--- now works
13:21:06 <cjb> ehird`: can't connect.
13:21:18 <ehird`> cjb: i just fixed that
13:21:19 --- mode: ChanServ set +o glguy
13:21:20 <cjb> also, that's the same URL, isn't it?
13:21:26 <ehird`> yes
13:21:27 --- mode: glguy set -b barbie26!*@*
13:21:29 <ehird`> but i fixed my router
13:21:32 --- mode: glguy set -o glguy
13:21:33 <glen_quagmire> i can't visit ehird`
13:21:34 <Cin> wonnae connect
13:21:36 <ehird`> hm
13:21:36 <cjb> doesn't work here.
13:21:43 <radetsky> all I'm trying to do (for which ConfigFile is way overpowered) is to read values from a file, and be able to reference those values with identifiers as if I had defined them with "var = val"
13:21:49 * ehird` does dmz, for now ...
13:21:50 <ehird`> 3,2,1...
13:21:53 <ehird`> err
13:21:53 <ehird`> slooow
13:21:53 <ehird`> ok
13:21:53 <ehird`> try now
13:22:50 <ehird`> oh it's looking good in irssi&urxvt
13:22:51 <ehird`> anyway
13:22:53 * ehird` tries to fix server
13:23:23 <radetsky> can I just do read on a string of "xn=yn"'s into a record of fields named xn?
13:23:47 <radetsky> is that what you mean by it being that simple?
13:24:15 <ehird`> okay
13:24:19 <ehird`> http://0xff.m000.org/sdfsdfsdf.png
13:24:29 <cjb> nope.
13:24:33 <ehird`> kja
13:24:38 <sclv_> seriously. just imageshack it.
13:24:45 <ehird`> alright
13:25:05 <ehird`> http://xs124.xs.to/xs124/08083/sdfsdfsdf872.png
13:25:46 <jeffz> looks like a lambda teapot
13:25:48 <sclv_> nice.
13:26:05 <Cale> hi
13:26:05 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:26:26 <ehird`> omgggg
13:26:26 <Cale> Gwern-away: BSD3 should be fine.
13:26:28 <ehird`> someone left #haskell-img again
13:26:29 <ehird`> >:(
13:26:39 * ehird` restarts bot
13:27:18 * quicksilver tries to get his head around B+-trees 
13:27:28 <glen_quagmire> ehird`: you're a genius
13:27:30 <dino-> radetsky: I may just put those key/val pairs into a Map then.
13:27:34 <ehird`> glen_quagmire: am i? :P
13:27:36 <Cale> What is this, a low-resolution 2D raytracer?
13:27:49 <ehird`> Cale: no -- just something using libcaca :)
13:27:55 <monochrom> hahaha
13:28:12 <dino-> Data.Map
13:28:35 <byorgey> low-resolution 2D raytracer, hehe
13:28:56 <ehird`> you guys who complained about the bottom being chopped off --
13:28:58 <radetsky> dino-: huh?
13:29:05 <ehird`> i've almost run it again
13:29:28 <dino-> radetsky: You said you have values in a file, looks like key/value pairs.
13:30:10 <radetsky> yeah...
13:30:36 <dino-> You could put them into a Map so other parts of the program can look them up by name.
13:30:57 <ehird`> ok
13:31:02 <radetsky> they can also look them up if they are in a record. it doesn't matter
13:31:02 <ehird`> uploading one with irssi & not chopped off:
13:31:17 <ehird`> http://xs124.xs.to/xs124/08083/sdfsdfsdf2509.png
13:31:28 <ehird`> better on a light background probably
13:31:42 <quicksilver> radetsky: well the difference is dynamic vs static key names
13:31:46 <dino-> Record style data type? sure
13:31:54 <quicksilver> radetsky: but the static key names requires boilerplate coding :)
13:31:56 <dino-> yes, static field names
13:31:59 <quicksilver> dynamic key names will be simpler.
13:32:19 <sclv_> ascii art makes me feel all nostalgic.
13:32:22 <quicksilver> (as in, less lines of code to write)
13:32:25 <ehird`> sclv_: yep
13:32:28 <ehird`> q: is there an irc client written in haskell?
13:32:29 <quicksilver> static key names is better type safety though
13:32:40 <ehird`> if not -- well, I'd better write one :)
13:32:42 * cjb googles for "ircmonad"
13:33:25 <ehird`> cjb: whoa
13:33:26 <radetsky> quicksilver: maybe, but that's not the problem
13:33:27 <ehird`> thats my lib name
13:33:28 <ehird`> for irc
13:33:28 <ehird`> :D
13:33:41 <cjb> ehird`: it's a little obvious :)
13:33:41 <radetsky> I'm trying to do global configuration from a config file
13:33:52 <ehird`> cjb: but still
13:33:53 <ehird`> :)
13:34:03 <ehird`> (apart from Xmonad, all *monad names are minee!!!)
13:34:19 <dino-> radetsky: But trying to sort of do like sourcing a shell script, I don't know if that can be done so easily. I could be wrong.
13:34:40 <quicksilver> radetsky: then static key names = win, in my opinion.
13:34:57 <quicksilver> radetsky: I'd rather have a strongly typed Config structure than a structureless map.
13:35:08 <radetsky> quicksilver: I agree, but again, this is not the issue
13:35:25 <quicksilver> there is some boilerplate involved in reading them in, though
13:35:33 <quicksilver> unless you are happy with the derived 'Read' instance.
13:35:36 <radetsky> the issue is how do I do the reading and the global access, not how do I store stuff
13:35:49 <quicksilver> they are related, though :P
13:35:57 <quicksilver> how you do the reading depends on how you store it.
13:37:04 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ConfigFile-1.0.4
13:37:06 <lambdabot> http://tinyurl.com/2ngbdq
13:37:09 <quicksilver> may or may not be interesting to you
13:37:15 <radetsky> quicksilver: I've seen it
13:37:19 <quicksilver> certainly cosmicray is trying to solve the problem you describe
13:37:27 <quicksilver> although his solution doesn't go as far as I'd like personally
13:37:29 <radetsky> but it doesn't really solve the problem
13:37:37 <radetsky> it's essentially a map parser
13:37:39 <quicksilver> it solves a part of the problem.
13:38:35 <quicksilver> to address another half of your question (global access), I would recommend using the Reader pattern.
13:38:37 <dino-> As far as making things global-ish, there's Reader. Or there's passing the container around to various parts of code that need it.
13:38:41 <dino-> yeah
13:38:51 <quicksilver> which is essentially passing the parameter to every sub that needs it
13:38:56 <quicksilver> but you can hide it somewhat.
13:39:02 <radetsky> which is what I don't want to do
13:39:51 <radetsky> is there a guide to using reader as just an environment container (or examples) rather than a computation-with-environment thing?
13:40:04 <dino-> I just went through this very recently: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
13:40:05 <lambdabot> Title: Monad Transformers Step by Step
13:40:09 <DRMacIver> Hm. The Data.Graph module appears to be a bit weak. Is there a better graph library?
13:40:20 <dino-> It was very good.
13:40:50 <quicksilver> DRMacIver: Data.Graph.Inductive is quite a bit more powerful, I believe.
13:41:00 <TSC> DRMacIver: fgl ?
13:41:09 <DRMacIver> Ah. Thanks.
13:41:13 <quicksilver> DRMacIver: at the cost of having a rather fiddly interface.
13:41:55 <DRMacIver> Sigh. This isn't helping. :)
13:42:07 <DRMacIver> I wanted just an easy graph library I could use for an example
13:42:25 <radetsky> dino-: are you sure that's the right thing?
13:42:30 <quicksilver> (fgl = Data.Graph.Inductive)
13:42:36 <quicksilver> easy it isn't, no.
13:42:47 <DRMacIver> Oh well. fgl/Data.Graph.Inductive looks like something I'd actually wanted to use, so it's still a useful tip.
13:42:51 <radetsky> I was under the impression that monad transformers were about stateful computations
13:43:02 <quicksilver> radetsky: no, not necessarily
13:43:10 <DRMacIver> But for my example I think I'm just going to write a simple graph type
13:43:10 <quicksilver> just about computations with effect
13:43:20 <quicksilver> and a global environment is a very simple kind of effect
13:43:20 <dino-> But even Reader or ReaderT is stateful in the sense of it's a shared state across some computations.
13:43:37 <DRMacIver> TSC, quicksilver: Thanks again
13:43:59 <ehird`> http://www.mail-archive.com/haskell@haskell.org/msg19231.html <-- is there a way to remove the newtype?
13:44:00 <lambdabot> Title: Re: [Haskell] How to define Y combinator in Haskell
13:44:01 <radetsky> I meant stateful computations in the sense that they encapsulate state as part of a computation
13:44:05 <ehird`> specifically, by wrapping it up somehow?
13:44:15 <radetsky> whereas I want something whose only job is to reveal that state
13:44:36 <dino-> BTW, I was really blown away seeing all those things in a single do block once they got Identity, State, Writer, Error and Reader all together.
13:45:11 <quicksilver> ehird`: newtype and data are the only tools that haskell gives us to draw loops in the type graph
13:45:14 <quicksilver> (in a sense)
13:45:24 <CosmicRay> quicksilver: what would you like to see in ConfigParser?
13:45:40 <ehird`> quicksilver: mm
13:45:44 <ehird`> i tried wrapping it in other stuff
13:45:46 <ehird`> but couldn;t
13:46:04 <quicksilver> CosmicRay: a nice set of combinators to help you move from a semi-structured rep to a strongly typed one.
13:46:19 <quicksilver> CosmicRay: (I think we had this discussion a few months ago :)
13:46:33 <CosmicRay> quicksilver: quite possibly.  did it end with me asking you to send a patch? ;-)
13:47:03 <quicksilver> CosmicRay: it ended with you saying you'd be very interested to hear more about the ideas if I got it worked out properly :)
13:47:18 <CosmicRay> ah :-)
13:47:40 <quicksilver> which I probably will, one day, when it's the itch that needs scratching for a pet project
13:47:52 <CosmicRay> that's exactly how I work.
13:48:25 <quicksilver> I think the issue of going from semi-structured to strongly typed is a very interesting one for haskell programmers though
13:48:33 <quicksilver> since we live in a world of apache config files, YAML, and XML
13:48:37 <quicksilver> (well, some of us do)
13:49:07 <CosmicRay> I have found that particular world seems to oddly coincide with Java
13:49:26 <dino-> radetsky: Apologies if I'm not helping. I think if you want to hide that shared data, Reader/ReaderT is the thing. I have to get out of here to beat traffic!
13:49:30 <CosmicRay> only Java programmers believe that it is a Good Thing to rewrite make to use XML config files.
13:49:45 <CosmicRay> man, that should go in the fortune file.
13:49:47 <hpaste>  mmorrow annotated "Basic SQL example with Parsec" with "some data" at http://hpaste.org/5777#a3
13:50:11 <radetsky> ok, thanks
13:50:13 <CosmicRay> blink
13:50:13 <dino-> CosmicRay: oof, another Ant victim
13:50:15 <CosmicRay> who is mmorrow?
13:50:22 <CosmicRay> dino-: not just ant, but mvn too.
13:50:27 <dino-> ah yes
13:50:34 <dino-> I escaped any involvement with that
13:50:36 <CosmicRay> dino-: frankly I have fscking idea how the hell that thing builds.
13:50:43 * dino- giggles
13:51:05 <CosmicRay> this is a bit of a sore subject. :-)
13:51:33 <CosmicRay> also, I dare say that your build system is fundamentally broken if it requires an Internet connection to build, even if it has already downloaded all needed components AND KNOWS THIS.
13:52:00 <CosmicRay> it's like the java folks took make and apt-get and thought to themselves, "How could we do this in a more Java way?"  meaning more verbose and confusing.
13:52:53 <CosmicRay> I love cabal and setup.py, which 1) usually Just Work for the end user, and 2) are simple in the majority of cases
13:53:05 <CosmicRay> simple for both end users and developers.
13:54:11 <bos> and in both cases, if you try anything non-simple, you get dragged into an endless waking nightmare.
13:54:27 <bos> so there's a strong emphasis on keeping things simple.
13:54:51 <CosmicRay> heh
13:55:17 <quicksilver> @remember CosmicRay only Java programmers believe that it is a Good Thing to rewrite make to use XML config files.
13:55:17 <lambdabot> Done.
13:55:24 <CosmicRay> heh
13:58:25 <olsner> @quote Java
13:58:25 <lambdabot> dibblego says: Java programmers prefer referential transparency too, they just call it "design patterns" or something
13:58:38 <dibblego> did I say that?
13:58:45 <dibblego> musta
14:00:35 <CosmicRay> last I heard code generators were all hot in Java.  so you can automatically wrote all your getter and setter methods and assorted junk.  oh the horror.
14:00:51 <monochrom> hahahaha dibblego
14:01:10 <ehird`> so,
14:01:22 <ehird`> is there a haskell irc client?
14:01:27 <monochrom> Hahaha CosmicRay too :)
14:01:41 <ehird`> @quote Java
14:01:41 <lambdabot> dibblego says: Java programmers prefer referential transparency too, they just call it "design patterns" or something
14:01:44 <cjb> if someone writes one, it should be a Yi plugin :)
14:01:48 <cjb> M-x ircmonad
14:01:55 <ehird`> no way
14:01:55 <ehird`> :(
14:02:15 <olsner> M-x? is yi an emacs clone?
14:02:25 <mrsolo_> hi why does following has type Integer not (Num a)?
14:02:27 <cjb> olsner: it has an emacs interface if you want to use that
14:02:31 <cjb> and also a vi interface
14:02:35 <mrsolo_> Prelude> let f = \x y -> x * y
14:02:55 <bos> mrsolo_: that's just ghci defaulting the type for you
14:02:56 <olsner> ah, as long as it has a non-emacs interface
14:03:06 <ehird`> mrsolo_: it does?
14:03:09 <ehird`> :t f
14:03:12 <lambdabot> Not in scope: `f'
14:03:15 <quicksilver> internally it's much more like emacs
14:03:21 <quicksilver> after all, vi is just a mess, internally
14:03:31 <mrsolo_> f :: Integer -> Integer -> Integer
14:03:36 <mrsolo_> whereas
14:03:38 <quicksilver> there's no denying emacs has the basic design ideas correct, even if you disagree with the details.
14:03:45 <Saizan> mrsolo_: bindings without formal arguments like f are forced to be monomorphic, and Num a => a defaults to Integer
14:03:46 <mrsolo_> let f x y = x * y
14:03:47 <monochrom> (I must agree that I am very disappointed at Ant. I don't mind the XML. I mind that Ant rules are less general than make rules.)
14:04:02 <mrsolo_>  :t f f :: (Num a) => a -> a -> a
14:04:26 <mrsolo_> saizan: ah...ty
14:05:17 <glguy> is there a way to refer to non-exported methods in a module using GHCi?
14:05:29 <Saizan> mrsolo_: this is called "monomorphism restriction", many finds it ugly, but you can still give it an explicit type signature if you want the polymorphic type
14:05:41 <quicksilver> glguy: only if you load it interpreted
14:05:48 <glguy> or am I forced to change the export list every time I want to test my code from the interpreter
14:06:09 <glguy> quicksilver: right, I've not been able to do it in interpreted mode
14:06:10 <glguy> is there a flag?
14:06:11 <quicksilver> if you load it interpreted you can access every top-level
14:06:30 <mrsolo_> saizan: i see.. will learn how to do that eventually... learning type basics now :-)
14:06:34 <quicksilver> :load My/Module.hs
14:06:44 <quicksilver> -- I can now access every top-level in My.Module
14:06:57 <glguy> quicksilver: ok, thanks
14:07:37 <glguy> I've had it fail to allow me to do this under certain circumstances (in interpreted mode) , but using :l seems to work
14:08:31 <quicksilver> if the .o is lying around, it will default to loading hte compiled version
14:10:00 <glguy> ?scheck (\xs -> null xs || ord (head xs) == 0)
14:10:03 <lambdabot>   Failed test no. 2. Test values follow.: "a"
14:10:28 <glguy> ?hackage smallcheck
14:10:28 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/smallcheck
14:19:27 <tibbe> it would be nice if we could have darcsweb for code.haskell.org
14:19:40 <awesame> I have something like foo $ baz $ qux, which I'm reading as (foo (baz qux))
14:19:54 <awesame> now I want to add a param to foo, to get (foo bar (bax qux))
14:20:12 <quicksilver> foo bar $ baz $ qux
14:20:12 <awesame> but foo $ bar baz $ qux seems not to be the right thing
14:20:15 <tibbe> foo bar $ baz qux
14:20:24 <quicksilver> or indeed foo bar $ baz qux
14:20:24 <cjb> what tibbe said
14:20:35 <awesame> hm
14:20:57 <tibbe> @src ($)
14:20:57 <lambdabot> f $ x = f x
14:21:21 <awesame> so the original is actually (=<<) foo $ baz $ qux
14:21:43 <awesame> I think (=<<) foo bar $ baz $ qux would make bar a param to (=<<), right?
14:21:54 <quicksilver> my personal preference would be for foo bar . baz $ qux incidentlly
14:22:00 <quicksilver> that's true, yes
14:22:10 <quicksilver> you'd want (=<<) (foo bar) $ baz $ qux
14:22:55 <quicksilver> but what you said was slightly deceiving
14:23:13 <quicksilver> " foo $ baz $ qux" is not a subexpression of  "(=<<) foo $ baz $ qux"
14:23:18 <awesame> ah, that worked
14:23:28 <quicksilver> this is one reason why Cale and I don't like the current associativity of $.
14:23:48 <awesame> yeah, I get that that's what must have happened
14:24:01 <awesame> one day I will get the hang of this . and $ notation
14:24:06 <dcoutts_> @seen ehird`
14:24:06 <lambdabot> I saw ehird` leaving #haskell 15m 29s ago, and .
14:24:08 <quicksilver> I wonder why you wouldn't write (=<<) foo $ baz $ qux
14:24:14 <quicksilver> as foo =<< baz qux
14:24:21 <quicksilver> seems more natural to me
14:24:36 <quicksilver> erm
14:24:43 * dcoutts_ notes that Gtk+ (and thus Gtk2Hs) may start to look more native on OSX soon
14:24:43 <quicksilver> (foo =<< baz) qux
14:24:43 <dcoutts_> http://people.imendio.com/richard/archives/2008/02/native_mac_them.html
14:24:43 <quicksilver> rather
14:24:45 <lambdabot> Title: Richard Hult: Native Mac theme, http://tinyurl.com/2brdoe
14:24:45 * quicksilver closes
14:24:51 * quicksilver loses
14:24:56 <quicksilver> on spelling + semantics both
14:25:16 <quicksilver> gah
14:25:23 <quicksilver> I was right the first time wasn't I
14:25:29 <quicksilver> it is foo =<< baz qux
14:25:39 <quicksilver> clearly I am ill-qualified to use $ at all.
14:25:42 <awesame> heh
14:25:55 <awesame> well it's good to know that I'm not completely alone here
14:26:27 <glguy> (=<<) foo $ baz qux
14:26:58 * glguy is a bit late to the party
14:27:09 <glguy> OH
14:27:12 <glguy> I see
14:27:16 * glguy reads futher up
14:30:13 <awesame> I guess I still don't understand how to read the fixity of $
14:30:14 <nominolo> dcoutts_: will it use MacOSX native font rendering?
14:30:27 <awesame> also .
14:30:42 <dcoutts_> nominolo: it uses that already
14:30:57 <glguy> infixr 0 $
14:31:00 <ehird`> you know, i can't find a pager that can do ansi colour codes, so I think I'll write my own.
14:31:00 <nominolo> dcoutts_: it certainly doesn't
14:31:03 <ehird`> in haskell.
14:31:05 <dcoutts_> nominolo: the native backend anyway, not the X11 one
14:31:12 <ehird`> awesame: "a $ ..." -> a (...)
14:31:16 <ehird`> where ... is as greedy as possible
14:31:17 <glguy> so: a $ b $ c $ c -> a $ (b $ (c $ d))
14:31:31 <nominolo> dcoutts_: well. whenever that will be usable
14:32:02 <dcoutts_> nominolo: right, it's been taking a while, but it does work with gtk2hs's demo progs already
14:32:11 <dcoutts_> or so I've been informed
14:32:22 <nominolo> that'd be cool
14:32:28 <awesame> so is another $ the only thing that will stop a $ binding up parameters?
14:32:38 <nominolo> that way we do not have to maintain a separate cocoa backend for yi
14:32:58 <byorgey> awesame: that, or parentheses
14:33:00 <andyjgill> dons: Thanks for the UM link! I got my specification style UM written
14:34:04 <awesame> right, or parens, ok
14:34:26 <ehird`> nobody likes that idea, eh? :P
14:34:37 * nominolo tried to adapt paredit to haskell, but it turned out to be non-trivial
14:34:44 <ehird`> nominolo: no
14:34:44 <ehird`> no
14:34:46 <ehird`> please do
14:34:48 <quicksilver> nominolo: I use paredit in haskell from time to time.
14:34:53 <ehird`> gtk on os x will never integrate fully
14:34:55 <ehird`> :
14:34:55 <ehird`> :(
14:35:02 <nominolo> quicksilver: what happens if you press ";" ?
14:35:02 <quicksilver> nominolo: mainly for nested lists and tuples.
14:35:24 <quicksilver> nominolo: I probably never tried. I don't use ; in haskell code ;)
14:35:56 <nominolo> i used "{" "}" once
14:36:06 <xd> i wrote a minor mode that matched []{}() for erlang a while back
14:36:40 <nominolo> xd: did it also work for "" ?
14:36:51 <ehird`> oh well, nobody likes that idea, guess i'll just do it :P
14:36:57 <ehird`> what good terminal libs are there for haskell?
14:37:01 <nominolo> ie \" --> "|"
14:37:07 <xd> hmm i dont think i added " but itd be pretty trivial
14:37:22 <nominolo> ehird`: vty, but it's abandoned.  otherwise readline/editline
14:37:27 <xd> oh yea it does ""
14:37:32 <ehird`> readline/editline is ... not good for a pager
14:37:38 <sorear> nominolo: hscurse
14:37:40 <sorear> *hscurses
14:37:56 <ehird`> really, i'd be fine with most(1) if it handled ansi codes
14:37:57 <ehird`> s
14:38:02 <nominolo> sorear: is that the official successor to vty?
14:38:13 <sorear> nominolo: no, it's the predecessor to vty
14:38:36 <nominolo> sorear: but you said that vty has some fundamental design flaws or sth?
14:39:31 <nominolo> sorear: i think someone mentioned that when talking about the vty frontend for yi
14:40:11 <sorear> nominolo: it has a weakness with incremental updates, since I can't see a reasonable way to implement the dirtying like curses does it.  but the real issue is that I haven't had a project use vty in most of a year, and I can't force myself to maintain something I no longer use or care about
14:40:39 <awesame> okay, so what happens on the left side of $?
14:40:50 <nominolo> sorear: i see
14:40:53 <awesame> because f . g x is not f . g (x)
14:40:56 <glguy> ?src ($)
14:40:56 <lambdabot> f $ x = f x
14:40:58 <awesame> er
14:41:11 <glguy> awesame: yes it is..
14:41:12 <awesame> f . g $ x is no f . g (x)
14:41:15 <nominolo> sorear: i don't use the vty frontend of yi.  so i don't really care ;)
14:41:20 <awesame> it's (f . g) (x)
14:41:21 <awesame> it's (f . g) (x)
14:41:23 <awesame> oops
14:41:30 <xd> nominolo: http://hpaste.org/5780
14:41:43 <glguy> awesame: a $ b -> (a)(b)
14:41:52 <glguy> where a is more than just one variable
14:41:58 <quicksilver> awesame: because . is infixr 9
14:42:01 <glguy> ...a.. $ ..b...
14:42:04 <awesame> and how far will $ bind on the left side?
14:42:04 <quicksilver> awesame: while $ is infixr 0
14:42:12 <quicksilver> awesame: they have different binding strengths
14:42:21 <awesame> quicksilver: right, I get that
14:42:22 <glguy> awesame: when you see a $, it takes everything to the right
14:42:28 <nominolo> xd: thanks
14:42:31 <xd> i didnt know emacs or lisp at the time so it could prolly be shorter with more features...
14:42:42 <awesame> I'm just trying to get a feel for the binding strengths of the most commonly used parens-avoiding functions
14:43:02 <quicksilver> so it parses as (f . g) $ (x)
14:43:02 <quicksilver> . binds very tightly indeed
14:43:02 <quicksilver> $ binds very weakly
14:44:48 <nominolo> xd: no that one is just fine.  paredit does more complicated (context sensitive) things
14:45:18 <nominolo> xd: like if you insert a comment it automatically move the code in that line downwards
14:45:31 <awesame> okay, so a b $ c d = (a b) (c d) seems to have clarified things for me
14:45:32 <nominolo> xd: and inside a comment parens work the usual way etc
14:45:48 <quicksilver> awesame: yeah, because $ binds super-weakly
14:45:49 <awesame> I think previously I was only expect $ to be weak on the right side
14:45:58 <awesame> *expecting
14:46:01 <quicksilver> awesame: anything else going in in between the as and bs is stronger
14:46:13 <xd> glad someone else finds it useful
14:47:30 <ehird`> @src ($)
14:47:30 <lambdabot> f $ x = f x
14:47:32 <ehird`> hmm
14:47:39 <xd> i mostly use it in erlang where you do a lot of {foo,[{bar,"baz"},{quux,1234}]} type things
14:47:40 <ehird`> why isn't the prelude definition:
14:47:42 <ehird`> ($) = id
14:47:42 <ehird`> ?
14:47:45 <awesame> @src (.)
14:47:46 <lambdabot> (.) f g x = f (g x)
14:48:17 <ehird`> > let ($) = id in subtract 3 $ subtract 1 $ 2
14:48:21 <lambdabot>   add an instance declaration for (Num (t -> t))
14:48:32 <ehird`> > let ($) = id in subtract 3 $ subtract 1 $ subtract 5 10
14:48:32 <lambdabot>   add an instance declaration for (Num (t -> t))
14:48:36 <ehird`> o.O
14:48:36 <nominolo> xd: btw, M-( inserts balanced parens by default
14:48:39 <ehird`> @type id
14:48:40 <lambdabot> forall a. a -> a
14:48:41 <ehird`> @type ($)
14:48:41 <lambdabot> forall a b. (a -> b) -> a -> b
14:48:53 <ehird`> @pl f x y = x y
14:48:53 <lambdabot> f = id
14:49:16 <xd> yea but i needed {["
14:49:26 <nominolo> xd: and with a prefix arg it wraps N sexps.  but sexp don't always work that well for haskell
14:49:35 <cdsmithus> Given a list, I need all possible partitions into non-empty sublists.  E.g., [a,b,c] maps to [[[a,b,c]],[[a],[b,c]],[[a,b],[c]],[[a,c],[b]],[[a],[b],[c]]].  Is this already done somewhere?
14:49:47 <xd> if it was just parens i was working with im sure the existing paren matching stuff woulda been fine
14:49:59 <xd> but its more braces and brackets in erlang
14:50:00 <nominolo> yeah
14:50:20 <awesame> > let ($) = `id` in subtract 3 $ subtract 1 $ subtract 5 10
14:50:21 <lambdabot>  Parse error at "`id`" (column 11)
14:50:31 <awesame> > let ($) = (`id`) in subtract 3 $ subtract 1 $ subtract 5 10
14:50:32 <lambdabot>  Parse error at ")" (column 16)
14:50:35 <awesame> gah
14:50:42 <ehird`> uhh
14:50:44 <ehird`> that won't work
14:50:50 <ehird`> `id` needs something on each side
14:50:55 <awesame> > subtract 3 `id` subtract 1 `id` subtract 5 10
14:50:57 <lambdabot>   add an instance declaration for (Num (t -> t))
14:51:05 <ehird`> oh of course
14:51:09 <TSC> cdsmithus: You could take the powerset, then subtract (set difference) each element of that from the original set
14:51:18 <olsner> besides, (`f`) is just f
14:51:20 <ehird`> > let ($) = flip id in subtract 3 $ subtrat 1 $ subtract 5 10
14:51:20 <lambdabot>   Not in scope: `subtrat'
14:51:23 <ehird`> @pl flip id
14:51:23 <lambdabot> flip id
14:51:26 <ehird`> @type flip id
14:51:27 <lambdabot> forall b c. b -> (b -> c) -> c
14:51:31 <ehird`> @type flip flip id
14:51:32 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
14:51:35 <ehird`> hmm
14:51:37 <glguy> $ is id
14:51:42 <ehird`> glguy: yes, but look above
14:51:45 <ehird`> ($) = id doesn't work
14:51:57 <cdsmithus> TSC: Hmm?  I don't understand yet.  How does that work?
14:52:02 <awesame> > (+1) `id` 2
14:52:04 <lambdabot>  3
14:52:24 <quicksilver> TSC: and then recurse
14:52:29 <quicksilver> TSC: otherwise that's only 2-way partitions
14:52:38 <TSC> Ohh, yes
14:52:40 <ehird`> > (+1) `flip flip id` 2
14:52:40 <lambdabot>  Parse error at "flip" (column 12)
14:52:46 <cdsmithus> Oh, I see!  Thanks.
14:52:51 <TSC> And that way will give duplicates (even in the two-way case)
14:53:00 <ehird`> @quickcheck (\f x -> flip flip f x == f x)
14:53:00 <lambdabot> Unknown command, try @list
14:53:01 <TSC> So you might have to filter them out
14:53:04 <ehird`> bah!
14:53:06 <ehird`> whatido :(
14:53:38 <TSC> @check (\f x -> flip flip f x == f x)
14:53:38 <lambdabot>      Occurs check: cannot construct the infinite type:       b = (a -> b -> c...
14:54:30 <nominolo> xd: ok, it's not as smart as paredit but it's already very useful.  thanks for sharing
14:55:00 <xd> lol np
14:58:42 <ehird`> TSC: i think quickcheck only passes one arg
14:58:53 <ehird`> @check (\f -> quickcheck (\x -> flip flip f x == f x))
14:58:55 <lambdabot>   Not in scope: `quickcheck'
14:59:01 * nominolo likes M-x mac-hide-menu-bar very much
14:59:18 <ehird`> nominolo: i hate it
14:59:34 <hpaste>  Saul_ pasted "Can this be made prettier?" at http://hpaste.org/5781
14:59:48 <nominolo> less bright stuff on my display when hacking emacs
14:59:53 <nominolo> ehird`: why?
14:59:55 <Saul_> Anyone know if this code can be made prettier?
15:00:00 <xpika> I don't like it how GHCI says something is ambigious when clearly the type of one is incompatible.
15:00:17 <ehird`> nominolo: os x gives me a consistent interface and I like keeping it that way
15:00:22 <Saul_> a few less lambdas would be nice
15:00:26 <ehird`> I find it distracting when it looks different.
15:00:38 <ehird`> Saul_: use the do!
15:00:55 <sclv_> cdsmithus: I'm pretty sure there was a monad reader article on this.
15:01:08 <ehird`> fProcess = do x <- nextMaybe; x' <- x; case x' of ...
15:01:11 <ehird`> or somethign
15:01:18 <Saul_> ehird`: I might, but then I would get nested does (the binds work on different monads)
15:01:42 <ehird`> Saul_: well, at least make it multiline
15:01:46 <cdsmithus> sclv_: Thanks.  I think I've got it working now, actually, based on TSC's suggestion.
15:02:15 <sclv_> http://www.haskell.org/sitewiki/images/d/dd/TMR-Issue8.pdf
15:02:27 <sclv_> byorgey's article on generating multiset partitions, if yr. interested.
15:02:49 <nominolo> ehird`: do you open new files in the same emacs frame or do you open one frame per file?
15:02:53 <cdsmithus> sclv_: Thanks a lot!  i'll look it over.
15:02:58 <ehird`> nominolo: same
15:03:11 <ehird`> & there are plenty tabbed etc os x apps
15:03:14 <ehird`> so that is still consistent
15:03:23 <nominolo> ehird`: heh
15:03:54 <nominolo> i use a dark theme, so that bright menu bar and window title are very distracting
15:04:03 <Saul_> Anyone else have suggestions on how to prettify my code?
15:04:06 <nominolo> i'm happy i can get rid of one of them
15:04:11 <xpika> does anyone know how to use traverse_?
15:04:25 <nominolo> :t traverse_
15:04:26 <lambdabot> Not in scope: `traverse_'
15:04:34 <sclv_> :t traverse
15:04:35 <lambdabot> Not in scope: `traverse'
15:04:39 <nominolo> :t Data.Traversable.traverse_
15:04:40 <lambdabot> Not in scope: `Data.Traversable.traverse_'
15:04:42 <ddarius> @hoogle traverse
15:04:42 <lambdabot> Data.Traversable.traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:04:42 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
15:04:42 <sclv_> ?hoogle traverse
15:04:43 <lambdabot> Data.Traversable.traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:04:43 <lambdabot> Data.Foldable.traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
15:04:47 <ehird`> nominolo: dark theme = non-os x style
15:04:51 <ehird`> i invert the display sometimes though
15:05:33 <nominolo> ehird`: f**k os-x style - i care more for my eyes than what's standard
15:05:45 <sclv_> saul, you could always use do notation. :-)
15:05:54 <ehird`> nominolo: ctrl-opt-cmd-8
15:05:58 <nominolo> ehird`: glaring at a white screen all day is just annoying
15:06:11 <ehird`> nominolo: ctrl-opt-cmd-8
15:06:16 <nominolo> ehird`: how is that osx style? ;)
15:06:29 <ehird`> it's in os x for one
15:06:38 <nominolo> ah c'mon
15:07:17 <nominolo> if one day they have two built-in styles you're saying it's osx style?
15:07:42 <nominolo> anywho, i don't care
15:08:54 <xpika> > Data.Foldable.traverse_ (\x->Just x) (Node 3 [Node 5[]])
15:08:56 <lambdabot>  Just ()
15:11:07 <ehird`> can i get the dumped core for a prog?
15:11:09 <xpika> how can I number the elements of a tree when I traverese_ it?
15:11:36 <slarba> xpika: zipper?
15:12:22 <xpika> slarba: maybe, but I was hoping for a more generic approach
15:12:25 <hpaste>  cdsmithus pasted "solution to my partitions question, if you're interested." at http://hpaste.org/5782
15:12:43 <nominolo> sum  (Node 3 [Node 5[]])
15:12:48 <nominolo> > sum  (Node 3 [Node 5[]])
15:12:49 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Tree t'
15:12:56 <nominolo> > sum $ toList (Node 3 [Node 5[]])
15:12:56 <lambdabot>   Not in scope: `toList'
15:13:06 <nominolo> > sum $ Data.Foldable.toList (Node 3 [Node 5[]])
15:13:07 <lambdabot>  8
15:13:14 <xpika> nominolo: yep but I want Tree a -> Tree (Int,a)
15:13:20 <nominolo> fmap
15:13:27 <nominolo> + zip
15:13:40 <nominolo> no, fold
15:13:42 <nominolo> sorry
15:14:44 <xpika> I can't think of the fold that would do that
15:15:09 <xpika> I was hoping traverse or something could do it
15:15:39 <nominolo>  xpika you want something like mapaccum
15:15:49 <blargeyfarg> state monad
15:17:13 <xpika> nominolo: that would do. but it needs to work on a tree
15:17:53 <nominolo> xpika: then you have to pass the state using the state monad and use mapM
15:18:08 <dons> conal: do you know if its possible to include images in haddock docs?
15:18:10 <nominolo> mapM :: Traversable t, Monad m => (a -> m b) -> t a -> m (t b)
15:18:49 <nominolo> dons: doesn't it say so in the spec?
15:19:20 <dons> nominolo: i'm not sure. do you know?
15:19:25 <nominolo> dons: oh, right only anchors
15:19:39 <dons> oh hmm
15:20:42 <nominolo> hm, i thought there was something.  but i guess i'm confusing that
15:22:25 <desp> Blah, what's the infinite version of replicate?
15:22:33 <ehird`> @djinn Monad m => (a -> m b) -> [a] -> m [b]
15:22:33 <lambdabot> Cannot parse command
15:22:36 <ehird`> @hoogle Monad m => (a -> m b) -> [a] -> m [b]
15:22:37 <lambdabot> No matches, try a more general search
15:22:44 <ehird`> o.O
15:23:07 <nominolo> desp: repeat
15:23:27 <desp> Thanks.
15:23:30 <ehird`> foo f [] = return []; foo f (x:xs) = do x' <- f x; xs' <- foo f xs; return (x':xs')
15:23:33 <ehird`> surely that exists
15:23:38 <ehird`> @pl  foo f (x:xs) = do x' <- f x; xs' <- foo f xs; return (x':xs')
15:23:38 <lambdabot> (line 1, column 28):
15:23:38 <lambdabot> unexpected ";"
15:23:38 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
15:24:08 <nominolo> @pl  foo f (x:xs) = do { x' <- f x; xs' <- foo f xs; return (x':xs') }
15:24:09 <lambdabot> (line 1, column 19):
15:24:09 <lambdabot> unexpected "{"
15:24:09 <lambdabot> expecting variable, "(", operator or end of input
15:24:28 <wagle_home> @hoogle (a -> Maybe b) -> [a] -> Maybe [b]
15:24:28 <lambdabot> No matches, try a more general search
15:24:43 <conal> dons -- i don't think so.  sigh.  i'd love to see haddock's markup functionality factored out somehow, so we could combine a more powerful markup language with haddock doc linking.
15:24:44 <Baughn> > length $ Data.Foldable.traverse_ (\x->replicate x x) (Node 3 [Node 5[]]) -- Neat, I invented multiplication
15:24:45 <lambdabot>  15
15:24:49 <ehird`> @type mapM
15:24:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:24:56 <ehird`> ah
15:24:57 <ehird`> :)
15:24:59 <ehird`> stupid hoogle
15:25:00 <nominolo> wagle: that's mapM
15:25:03 <ehird`> @type mapM_
15:25:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:25:25 <dons> conal: hmm. i really could do with this. ah well, perhaps just links to docs
15:25:26 <ehird`> @info Funcot
15:25:26 <lambdabot> Funcot
15:25:33 <ehird`> @info Functor
15:25:33 <lambdabot> Functor
15:25:33 <ehird`> lambdabot: stop teasing me
15:25:35 <ehird`> ..
15:25:43 <ehird`> @src Functor
15:25:43 <lambdabot> class  Functor f  where
15:25:43 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:25:47 <conal> dons: me too.  pictures are very helpful in documentation!
15:26:01 <conal> maybe haddock could be reduced to a plugin for something like markdown or tiddlywiki
15:26:12 <ehird`> @type fmap
15:26:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:26:51 <nominolo> conal: but that'd mean different markup language ==> lot's of breaking markup
15:26:58 <dons> conal: yeah, there's an interesting interplay between haddock and wikis
15:26:58 <nominolo> *lots
15:27:03 <conal> imagine composing markdown, haddock, and hscolour (or lhs2tex), and other plugins.
15:27:08 <dons> you ideally don't want to write lots of docs in src
15:27:18 <dons> just include haddock stuff into a larger site
15:27:27 <nominolo> dons: that's dangerous
15:27:28 <conal> nominolo: right -- it's not obvious how to do it.  still -- with some creativity, it could be a big win.
15:27:33 <dons> or have haddock include things
15:27:53 <nominolo> conal: using different markers might be an easy way to do it though
15:27:55 <dons> nominolo: so we use haddock as a markup format, http://xmonad.org/xmonad-docs/xmonad-contrib/
15:28:03 <ehird`> dons: my docs are all in the source
15:28:15 <ehird`> and docs further than 10-20 lines from the thing they describe are dangerous
15:28:20 <dons> we have xmonad modules that only provide src, in fact
15:28:25 <dons> just documentation modules
15:28:25 <conal> nominolo: "different markers"?
15:28:37 <dons> s/src/docs/
15:28:47 <nominolo> conal: like --! instead of --| or sth
15:29:02 <nominolo> conal: that way it can't be confused with haddock markup
15:29:16 <radetsky> has spj published the source of the web server that was the sort-of-subject of Awkward Squad?
15:29:21 <radetsky> I'm having trouble finding it
15:29:25 <nominolo> conal: or --@ or whatever
15:29:46 <dons> radetsky: yeah, its child is on http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mohws-0.1
15:29:48 <lambdabot> http://tinyurl.com/yvtlmj
15:30:25 <conal> nominolo: hm.  i want to get haddock linking functionality *and* general markup, not either/or
15:30:32 <conal> i.e., in the same doc string
15:30:51 <dons> conal: yeah, big docs should be written in a doc language, and interspersed through the haddocks
15:31:04 <dons> its a pain writing large amounts of rich text in haddock form
15:31:30 <conal> dons: haddocky bits sprinkled into the doc language.  is that what you mean?
15:31:39 <nominolo> @localtime dons
15:31:40 <lambdabot> Local time for dons is Wed Feb 20 15:31:39 2008
15:32:34 <nominolo> conal: you'd need to extend markdown with certain Haddock features then
15:32:47 <dons> conal: something like that. literate haddock ?
15:32:52 <conal> nominolo: as a markdown (or whatever) plugin
15:32:59 <jre2> not LaTeX?
15:33:03 <resiak> presumably pandoc would be used?
15:33:25 <resiak> (given that it's a better markdown parser than upstream markdown, and is in the right language :))
15:33:38 <conal> or tiddlywiki plugin, which would be awesome for doc & code browsing.
15:33:39 <nominolo> conal: yeah, but that markdown + haddock plugin would have to be a haddock plugin :)
15:34:14 <conal> nominolo: that's one possibility of many.
15:34:38 <nominolo> conal: yeah.  richer haddock markup would certainly be nice
15:34:55 <conal> and extensible!  (plugin)
15:35:43 <nominolo> konjetschno
15:35:49 <nominolo> er, of course
15:35:54 <conal> tiddlywiki has a plugin system.  not very pretty though.  OO/imperative.
15:36:24 <conal> i don't know if pandoc has a plugin architecture.
15:37:14 <nominolo> markdown supports any html-markup
15:37:54 <conal> nominolo: but probably not the ability to invoke code to parse, manage data, etc.
15:38:14 <nominolo> no
15:38:41 <radetsky> dons: what I'm really trying to do is find good example implementations of configuration files
15:39:23 <radetsky> theirs looks worthwhile, although if you know of better ones, I'm all ears
15:39:55 <conal> how much of haddock's functionality is specific to code-doc'ing?  modules ("Foo.bar"), links ('foo').  anything else?
15:40:41 <nominolo> module#label
15:40:48 <nominolo> (crosslinks)
15:41:29 <xpika> in haskell what does f (f (f (f x))) simplify to ?
15:41:30 <nominolo> http://www.haskell.org/haddock/doc/html/ch03s08.html#id290186
15:41:30 <conal> nominolo: i don't know that one.  isn't 'foo' a crosslink if foo is imported?
15:41:30 <lambdabot> Title: 3.8. Markup
15:41:36 <dons> radetsky: configuration files? in what format?
15:42:01 <dons> like this? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ConfigFile-1.0.4
15:42:02 <lambdabot> http://tinyurl.com/2ngbdq
15:42:05 <nominolo> xpika: simplify?  by the compiler?
15:42:06 <radetsky> no
15:42:13 <radetsky> or rather, that format is fine
15:42:17 <Saizan> xpika: iterate f x !! 4 ?
15:42:22 <radetsky> but I'm looking for how you actually use it in the program
15:42:37 <xpika> Saizan: thanks
15:42:40 <conal> nominolo: oh -- i see.  module#label isn't really about code-doc'ing.  i think the markup language would cover it.
15:42:43 <dons> suck it in at startup, then run in a ReaderT monad with the config values
15:43:04 <radetsky> dons: like run the whole program in readerT, so to speak?
15:43:07 <nominolo> conal: but it uses module names as the namespace
15:43:22 <dons> radetsky: yeah, parameterise the program by its configuration settings
15:43:30 <nominolo> conal: so you need to translate module name to URI or sth
15:43:34 <dons> have a look at xmonad's X monad type for an example
15:43:40 <radetsky> dons: yeah, that's what I want to do
15:44:03 <conal> nominolo: oh yeah.  btw, does module#label understand "import qualified"?
15:44:05 <nominolo> conal: then of course haddock has to discover which comment belongs to which parts of the code
15:44:07 <dons> xmonad does this, and uses haskell as the configuration file format. might be interesting to lookat
15:44:25 <radetsky> so is this, in a very vague, hand-wavey way, what I want to do:
15:44:55 <radetsky> make main's IO the inner monad of a ReaderT which holds the environment?
15:45:00 <xpika> @hoogle lengtj
15:45:01 <lambdabot> No matches found
15:45:01 <nominolo> conal: i don't think it needs to.  it doesn't look at the local file, but at the modules being haddocked
15:45:07 <xpika> @hoogle length
15:45:08 <lambdabot> Prelude.length :: [a] -> Int
15:45:08 <lambdabot> Data.List.length :: [a] -> Int
15:45:08 <lambdabot> Data.ByteString.length :: ByteString -> Int
15:45:16 <nominolo> conal: potentially in some other package, too
15:45:34 <conal> nominolo: yep.  so maybe haddock could be the driver (as you suggested, i think) and do minimal doc rewriting ('foo', "module", and maybe module#label), and pass the rest to pandoc or tiddlywiki.
15:46:29 <ehird`> So if I want a strongly-typed database thingymagig, what do I do?
15:46:32 <ehird`> HaskellDB is dead, right?
15:46:39 <ehird`> And taktaktjkertk can not has mysql.
15:46:40 <xpika> @src length
15:46:40 <lambdabot> Source not found. Maybe you made a typo?
15:47:00 <nominolo> conal: yes that should work.  but it needs to know how to discover those references. maybe as a callback to haddock - ie, the markdown plugin parses and then asks haddock to resolve the references
15:47:25 <radetsky> is that too unclear?
15:47:51 <nominolo> ehird`: takusen?
15:48:01 <ehird`> nominolo: that's taktkajrtklaejrt.
15:48:02 <conal> nominolo: i was thinking that haddock would rewrite to pure markdown -- no callback.
15:48:18 <dons> edwinb: takusen's active
15:48:22 <dons> ehird`: ^
15:48:29 <radetsky> basically my point was that I had been under the impression that I essentially needed to use Reader[T] and other state things as essentially little slap-on modules which
15:48:44 <radetsky> would provide state, environment, etc
15:48:55 <dons> that's the cleanest way.
15:49:06 <ehird`> takusen can not has mysql.
15:49:28 <conal> nominolo: in other words, haddock generates markdown (or ...) rather than html.
15:49:34 <radetsky> but the way you described it above (which seems to make sense in light of the tutorials I'd been reading) makes it sound like, e.g., ReaderT is supposed to wrap around your whole program
15:49:34 <dons> maybe you could patch in support, ehird` ?
15:49:37 <nominolo> conal: if you can find a way to make this work for (parameterize it over) the plugin-type then this would work, too
15:49:41 <radetsky> or something along those lines
15:49:49 <dons> radetsky: main = runReaderT (my code) config
15:50:02 <conal> nominolo: ??
15:50:15 <radetsky> dons: roger wilco
15:50:20 <nominolo> conal: i mean, you need some way to communicate to haddock what it has to change and into what it should change it
15:50:28 <dons> radetsky: http://code.haskell.org/xmonad/XMonad/Core.hs  look for runX
15:50:31 <nominolo> conal: this might depend on the actual plugin
15:50:36 <Botje> does ghc's new(ish) straight-to-machine-code backend obsolete the "evil perl mangler" ?
15:50:42 <dons> yes.
15:50:48 <Botje> cool
15:50:51 <conal> nominolo: do you mean markdown vs ...?
15:51:08 <ehird`> dons: that's no fun :P
15:51:12 <ehird`> hmm, what does takusen code look like
15:51:14 <nominolo> conal: dunno.  xml, wiki-markup, ...
15:51:24 <nominolo> latex
15:51:29 <nominolo> docinfo
15:51:43 <nominolo> no, texinfo it's called
15:52:36 <conal> nominolo: perhaps we could use an existing universal markup language and then as a second phase produce the others.
15:53:39 <conal> nominolo: pandoc has many back-ends.
15:53:47 <nominolo> conal: but you want to use that markup language directly in the comments, don't you?
15:54:32 <radetsky> dons: that's what you should be showing people who want to learn what this whole monad thing is about, not toy "Roll your own state monad from first principles" stuff
15:54:51 <dons> radetsky: cool
15:54:53 <conal> nominolo: yes. maybe haddock generates only (pandoc's extended) markdown, which can then (independently from haddock) be converted to html, latex, ...
15:55:19 <nominolo> conal: that would be fine with me
15:55:36 <nominolo> conal: i think pandoc is pretty decent
15:55:50 <conal> nominolo: i like it, too.
15:56:02 <nominolo> though, important question:  does it support embedded images? :)
15:56:28 <nominolo> yay, it supports inline-TeX
15:56:41 <dons> so have haddock analyse the src, and produce markdown pages?
15:56:50 <dons> which we could then combine and host with other stuff?
15:57:14 <conal> dons: combine & host?
15:57:16 <nominolo> dons: yes, slightly extended markdown
15:57:18 <radetsky> once I wrap my head around it (and I think your code will do the trick), I intend to write a tutorial aimed at people who happen to have my particular stumbling block
15:57:51 <dons> radetsky: wonderful.
15:58:15 <conal> dons: the idea is to have haddock pass through lots of stuff it doesn't understand, like math & pics.  haddock just translates its directives to markdown and leaves the rest alone.
15:58:16 <dons> showing a complete example, using libraries, of how to parameterise a program on configuration data using a ReaderT  would be  nice
15:58:28 <dons> conal: ah right! yes. that would be most suitable
15:58:28 <nominolo> dons: then you could do: "![Alt text](/path/to/img.jpg)"
15:58:33 <dons> haddock as a preprocessor :)
15:58:55 <conal> dons: zakly.  nicely put!
15:59:07 <dons> after all, wikis do this all the time, {{{syntax=haskell ... }}}
15:59:14 <dons> so haddock should be able to deal with it too
16:00:28 <nominolo> btw, atm we use haddock markup inside .cabal files (for teh package description)
16:00:36 <conal> if we find pandoc deficient in some ways (not haddock-specific), we could improve pandoc, which has more payoff than just code doc'ing.  and coded in haskell!
16:00:40 <ehird`> =/
16:01:00 <dons> yep. pandoc's in a pretty good state too
16:01:15 <conal> nominolo: no prob.  the cabal markup would be sent through the preprocessor (haddock).
16:02:09 <nominolo> not quite.  we have to detect whether it's haddock markup, or later, markdown markup
16:02:34 <nominolo> similar for existing haddock docs
16:02:38 <conal> nominolo: do you mean for backward compat with haddock 2?
16:03:01 <nominolo> i mean we still have to support old style haddock markup
16:03:22 <conal> oh, okay.
16:03:39 <nominolo> for haddock we could just use different markers ie sth other than -- | and -- ^
16:03:58 <nominolo> or some marker at the beginning of the file
16:04:11 <nominolo> i guess for cabal we could use the cabal-version marker
16:04:13 <conal> oh wait -- why would we have to figure out which markup?
16:04:36 <nominolo> because haddock markup uses @ and stuff
16:04:55 <conal> nominolo: run old haddock on old stuff and new haddock on new.
16:05:14 <nominolo> yes.  but we have to figure out which is which :)
16:05:19 <conal> who does?
16:05:23 <conal> hackage?
16:05:28 <nominolo> haddock
16:05:42 <nominolo> cabal, hackage
16:06:02 <nominolo> you mean haddock 3 would only support markdown markup?
16:06:08 <conal> is the situation any different from haddock 1 vs haddock 2?
16:06:18 <conal> nominolo: yeah -- that's what i was thinking
16:06:25 <nominolo> markup didn't change
16:06:33 <nominolo> code parsing abilities changed
16:06:43 <conal> exactly.
16:06:58 <conal> so they're incompat
16:07:09 <nominolo> well, ok.  but really you want one haddock to parse them all
16:07:09 <conal> but i guess haddock2 is a superset
16:07:18 <nominolo> (and in markup to bind them)
16:07:31 <nominolo> yes
16:07:36 <nominolo> but haddock 3 wouldn't be
16:08:10 <nominolo> or, at least not according to (what i assume is) your suggestion
16:08:25 <conal> right.
16:08:35 <ehird`> Prelude Text.Printf> printf "%s"
16:08:35 <ehird`> *** Exception: Printf.printf: argument list ended prematurely
16:08:37 <ehird`> how does it know?!
16:08:38 <ehird`> :(
16:08:53 <conal> nominolo: i agree it'd be handy to have backward compat.  maybe a directive in the cabal file saying which haddock to use.
16:08:57 <nominolo> conal: but some special marker at the begging of the file would be fine with me
16:09:05 <Saizan> ehird`: it parses the string? it's a runtime exception..
16:09:09 <nominolo> or, in the .cabal, yes
16:09:22 <ehird`> Saizan: yes, but since it's curried, how does it know its arguments have ended?!
16:09:22 <conal> nominolo: fine by me.
16:09:41 <ddarius> :t printf
16:09:45 <lambdabot> forall r. (PrintfType r) => String -> r
16:09:54 <Saizan> ehird`: heh, using it at ghci prompt it's type has defaulted to IO () :)
16:10:06 <ehird`> Saizan: ok, printf is evil
16:10:13 <ehird`> it should be banned, along with n+k patterns
16:10:13 <ehird`> :P
16:10:17 <ddarius> ehird`: Each time you apply an argument to printf, you are using it at a different type
16:10:26 <nominolo> conal: ok, i need to go to bed.  can you write your suggestion down on the wiki and/or post it to @cafe?
16:10:31 <ddarius> ehird`: printf is a library function.  It can't be banned.
16:10:35 <ehird`> ddarius: SHOULD BE
16:10:35 <nominolo> (or your blog)
16:10:36 <ehird`> :(
16:10:42 <conal> nominolo: sure.  g'night!
16:11:22 <ehird`> Slereah:
16:11:24 <ehird`> @where yaht
16:11:24 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:12:15 <dons> oh, printf is fine. its h98 and solves a middle ground between show and HugesPJ
16:12:50 <ehird`> dons: but it's semantics & implementation that comes with it.. eek!
16:13:18 <dons> ehird`: its a straight forward dependently typed EDSL, checked at runtime. what's to complain about? :)
16:13:27 <ehird`> it scares me
16:13:42 <ddarius> The format string can be constructed at run-time.  There is no way to avoid a runtime check.
16:14:22 <ehird`> that's not what scares me
16:14:38 <ehird`> the type magic and how it can tell when it's being told to be an IO and reports errors based on that
16:14:40 <ehird`> that scares jme
16:14:54 <dons> oh, return type polymorphism. that's not scary
16:14:57 <ddarius> ehird`: It's just type classes.  Just like read knows what type to read.
16:15:05 <dons> :t Data.Map.lookup
16:15:17 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
16:15:26 <ddarius> There's nothing magic about printf.  It's clever, but not magical.  unsafePerformIO and n+k patterns are magic.
16:16:14 <ehird`> wowzers
16:16:16 <ehird`> Core is ugly.
16:16:17 <rnorris> has anyone out there used the GLUT bindings on OS X? trying to get it to work in ghci but no love so far
16:16:41 <rnorris> (works fine compiled)
16:16:48 <ehird`> dons: no, it's not scary
16:16:51 <ehird`> but what it does with it is
16:18:28 <ehird`> ddarius: also, how are n+k patterns *magic*? not very useful, yes, but *magic*?
16:18:48 <ddarius> ehird`: The only way to make n+k patterns is to hack the compiler.
16:19:01 <ehird`> ddarius: I'm unsure what you're saying?
16:20:08 <ehird`> you know what we need?
16:20:12 <ehird`> an obfuscated haskell program written in Core
16:20:21 <ehird`> well, obfuscated core program i guess
16:22:32 <ehird`> wtf
16:22:35 <ehird`> you can't do (n+(-1))
16:24:03 <ehird`> succ False = True
16:24:06 <ehird`> pred True = False
16:24:07 <ehird`> that's great
16:27:20 <dons> ehird`: k dude, not -k
16:27:31 <ehird`> dons: heh
16:27:38 <ehird`> n+k, for very specific values of k
16:30:16 <ddarius> > let (n-1) = 3 in n
16:30:16 <lambdabot>  Parse error in pattern at "in" (column 15)
16:31:51 <ehird`> > let (n+1) = 0 in n
16:31:51 <lambdabot>  Parse error in pattern at "in" (column 15)
16:31:55 <ehird`> hah
16:32:03 <ehird`> they're even retarded n+k
16:32:27 <ddarius> > let f (n-1) = n in f 3
16:32:27 <lambdabot>  Parse error in pattern at "in" (column 17)
16:32:49 <ddarius> > let f (n+1) = n in f 3
16:32:49 <lambdabot>  Parse error in pattern at "in" (column 17)
16:33:07 <ddarius> I guess lambdabot takes the proper stance in the n+k pattern debate.
16:33:30 <dons> well, Language.Haskell does
16:33:31 <ehird`> Yes indeed.
16:33:44 <blt> Excuse me, but what is the n+k pattern debate?
16:33:55 <ehird`> blt: Well, there's a righteous side, and an evil side.
16:33:59 <idnar> heh
16:34:05 <ehird`> "Ban n+k patterns!" is the righteous side.
16:34:13 <ehird`> You're either with us, or against us, and if you're against us, you're evil.
16:34:25 <dons> i think all the heat has gone out of the n+k debate
16:34:30 <dons> there's so many other uglier things
16:34:34 <ehird`> dons: NEVER!! WE WILL NEVER GIVE UP!
16:34:42 * dons takes aim at implicit parameters
16:34:49 <ehird`> whuts dat
16:34:49 <ddarius> dons: It's not that it's gone, it just seems a consensus has been reached.
16:34:50 <ehird`> <_<
16:35:05 <ddarius> ehird`: Don't ask.  They aren't standard so we don't need to think of them.
16:35:06 <dons> ddarius: that no one cares? or all the +k guys have passed on?
16:35:19 <ehird`> tap tap google google
16:35:33 <ehird`> um
16:35:35 <ehird`> dynamic variables?
16:35:39 <ddarius> dons: Most of the people for it have disappeared or changed their minds or something.
16:35:40 <ehird`> from reading 2 paragraphs
16:36:40 <dons> ddarius: yeah, its such a ridiculous special case now
16:36:40 <blt> I don't quite follow. Why are n+k patterns so terribly divisive?
16:36:45 <dons> not enough power/weight.
16:37:00 <dons> blt: there were in 1992
16:37:05 <ddarius> blt: They aren't now and I'm not sure how much they were back in the day.
16:37:09 <dons> and now its just the warm glow of the big bang
16:37:11 <ehird`> n+k is just so limited
16:37:24 <ehird`> n+(k, which is a positive, constant integer)
16:37:36 <ehird`> what use is that? basically 3 functions might look more readable with it
16:37:41 <ehird`> and those arent exactly going to die because of missing it
16:37:47 <ehird`> if you could do:
16:37:52 <dons> well, at the time it was thought it would be good for teaching
16:37:54 <roconnor> > exp (0.04)
16:37:55 <ehird`> f x (y+x) = ...
16:37:57 <ehird`> that would be pretty cool
16:37:58 <dons> and that haskell was the ultimate teaching language
16:37:59 <lambdabot>  1.0408107741923882
16:38:10 <ehird`> dons: good for teaching? how?!
16:38:20 <LoganCapaldo> Maybe it'
16:38:33 <dons> ehird`: small purely functional language: a better scheme
16:38:39 <LoganCapaldo> s my pre-conceived notions but n+k seems liek it would be worse for teaching
16:38:48 <ehird`> dons: I mean -- how were n+ks good for teaching
16:38:52 <LoganCapaldo> Oh look yet another special case you have to memorize
16:39:03 <blt> Why does the k match only to positive, constant integers? (I admit, that does seem rather limiting.)
16:39:07 <dons> ehird`: induction on the naturals
16:39:11 <mrd> so you can write recursive definitions that look like math equations
16:39:35 <ddarius> blt: You can do n-k unless I'm seriously misremembering.
16:39:36 <mrd> like recurrence relations
16:39:48 <dons> and gofer still accepts m*n+k
16:39:50 * LoganCapaldo doesn't think "looking like math equations" implies "easier to teach"
16:40:10 <ehird`> ddarius: no, you can't
16:40:14 <dons> it does if all they've seen in math, LoganCapaldo  :)
16:40:30 <dons> purity is the main reason though -- you don't have to model a state machine in your head to write code
16:40:38 <ehird`> you cannot do n-k
16:40:56 <ddarius> ehird`: Ah, you're right.
16:41:15 * wli doesn't understand the opposition to them (and wonders what happened to m*n+k.
16:41:21 <ehird`> which means you can write pred :: Integral a => a -> a
16:41:24 <ehird`> but not succ.
16:41:30 <dons> wli, what type does 'k' have?
16:41:39 <dons> and why isn't + a constructor?
16:41:52 <dons> and how often do you do that kind of recursion?
16:42:03 <roconnor> n+k patterns are an instance of a view I suppose.
16:42:08 <ehird`> dons: PositiveConstantInteger. Duh!
16:42:15 <wli> The type of k is presumably the same type of the argument.
16:42:16 <roconnor> too bad we don't have views in general.
16:42:44 <ddarius> roconnor: There are definitely two minds on views in the Haskell community.
16:43:01 <ehird`> wli: no
16:43:06 <roconnor> ddarius: oh, what is the other view of views?
16:43:12 <ehird`> wli: k must be constant, must be positive, and must be an integer
16:43:32 <ddarius> roconnor: The opposite.  "thankfully we don't have views in general"
16:43:52 <roconnor> ddarius: why would they think that?
16:44:22 <ddarius> roconnor: Well, they wouldn't want n+k either, but not everyone thinks views are a good idea.  Me for instance.
16:44:27 <wli> ehird`: "Constant" is not a type, nor is "positive." IIRC several integral types are supported by the patterns; I suspect Integral t => t or some such.
16:44:52 <roconnor> ddarius: views are good, although they are probably impossible to implement in haskell.
16:44:59 <roconnor> not that I know too much about views.
16:45:00 <ddarius> wli: Except n+k patterns fail on negative values
16:45:41 <ddarius> roconnor: There's nothing about Haskell that makes views even difficult to implement
16:45:49 <ddarius> And there are bad sides to views as well.
16:46:06 <conal> i just sent a haskell-cafe note summarizing the haddock-as-markdown-preprocessor idea.
16:46:09 <roconnor> ddarius: what's the bad side?
16:46:34 <ddarius> I much prefer the more explicit suggestions like pattern guards and transformational patterns (which were renamed view patterns and implemented recently).
16:46:44 <ddarius> roconnor: Hidden costs, potentially surprising semantics, heavy-weight
16:48:37 <matthew-_> view patterns are implemented? In what - 6.9?
16:49:18 <matthew-_> have type synonynms been finished yet in 6.9?
16:49:27 * wli has NFI WTF view patterns are.
16:49:48 <TomMD> ?go view patterns haskell
16:49:51 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
16:49:51 <lambdabot> Title: ViewPatterns - GHC - Trac
16:51:01 <matthew-_> there was a famous wadler paper in the 80s (really? later - earlier?) the really showed what view patterns could do
16:52:10 <ddarius> matthew-_: view patterns weren't even invented until at least the 90's.  view patterns are NOT views.
16:52:41 <matthew-_> oh bother. indeed. Sorry, I should not drink and talk on #haskell
16:54:27 <lament> view pattern as in MVC?
16:54:36 <wli> I guess view patterns are nice to have around. I still like m*n+k patterns. I hear the same kind of crap against m*n+k patterns against exponentiation operators in languages that don't already have them and furthermore lack user-definable operators.
16:55:29 <Korollary> We have a separate channel for drinking and talking.
16:55:52 <TomMD> haskell-overflow?  Or do you mean Haskell-pubNearYou
16:56:20 <Korollary> haskell-blah of course
16:56:24 <ddarius> wli: I can't think of any of the issues I have with n+k patterns as being in any way related to anything I could think of that someone would find issue with exponentiation operators.
17:05:19 <gwern> evening everyone. I've thought of a cabal feature I'd like, for it, when you do an sdist tarball, parse 'darcs changes' and create a ChangeLog including everything back to the previous tagged version
17:05:22 <gwern> what d'y'all think?
17:05:58 <conal> gwern: sweet!
17:06:08 <gwern> @seen Cale
17:06:08 <lambdabot> Cale is in ##algorithms, #haskell-overflow, #haskell and #ghc. I last heard Cale speak 3h 38m 32s ago.
17:06:24 <conal> i'd also like to see that list linked to by hackage.
17:06:38 <lQg> can one make a lift of the fst of [(String,String)] ?
17:06:39 <conal> to help people decide whether to upgrade.
17:06:43 <lQg> list*
17:06:48 <gwern> conal: ok, so you like it, at least. anyone else?
17:06:58 <conal> lQg: map fst
17:07:05 <lQg> kk thanks
17:09:03 <hpaste>  (anonymous) annotated "pretty much the example from the Practical Web Programming page, but it doesn't work" with "(no title)" at http://hpaste.org/5767#a1
17:09:45 <hpaste>  (anonymous) annotated "pretty much the example from the Practical Web Programming page, but it doesn't work" with "(no title)" at http://hpaste.org/5767#a2
17:14:54 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5785
17:16:23 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5785#a1
17:18:08 <gwern> length []
17:18:20 <gwern> > length []
17:18:21 <lambdabot>  0
17:18:31 <gwern> > length ["foo"]
17:18:34 <lambdabot>  1
17:21:10 <gwern> conal: http://hackage.haskell.org/trac/hackage/ticket/244 <-- add your thoughts
17:21:11 <lambdabot> Title: #244 (Add Changelog summary feature to sdist) - Hackage - Trac
17:24:47 <hpaste>  mmorrow annotated "Basic SQL example with Parsec" with "todo notes" at http://hpaste.org/5777#a4
17:26:15 <conal> gwern: will do
17:27:27 <Notostraca> Anyone up for some strange musings on FP?
17:27:44 <conal> Notostraca: go for it
17:28:11 <gwern> only if they are kinky and mindblowing
17:28:17 <Notostraca> Okay.
17:28:41 <Notostraca> You know how almost all data is OO, like in JSON and XML?
17:28:55 <roconnor> XML is OO?
17:29:04 <gwern> not really, but I'll buy it for now
17:29:05 <Notostraca> XML -> tree based
17:29:25 <Notostraca> parse as a tree in my limited experience
17:29:35 <roconnor> OO means data and methods together in one structure.
17:29:40 <LoganCapaldo> I wouldn't even call json more oo than xml
17:29:46 <vininim> errm...
17:30:05 <LoganCapaldo> despite the o in the name
17:30:15 <roconnor> Notostraca: anyhow, please go on.
17:30:49 <Notostraca> well maybe not with methods, I'm referring to data structures.
17:31:09 <Notostraca> We have trees, arrays, hashes, etc
17:31:20 <Notostraca> at least in JSOn and YAML
17:31:51 <Notostraca> but I am curious how a functional programmer could deal with objects as data
17:31:52 <roconnor> trees are good
17:33:07 <dolio> You can build trees even in C.
17:33:07 <Notostraca> Would it be possible to feasibly make data as functions? That doesn't seem to make sense at first
17:33:13 <gwern> objects as data... why am I thinking of lisp all of a sudden?
17:33:25 <Notostraca> like S-expressions I suppose
17:33:36 <Notostraca> yes I gueas like LISP
17:33:36 <dolio> Most functional languages don't lack data types.
17:34:14 <lament> data as functions is more or less how mainstream OOP works
17:34:39 <MagicDuck> does haskell have any kind of eval. What I mean is doing things like:  eval "(12352345123123 :: Integer) div 123 == 4234234"
17:34:46 <Notostraca> I mean, lets say, data with parameters, maybe even currying
17:34:48 <dolio> Of course, Church encoding means you can make certain data out of functions.
17:34:55 <Pseudonym> lament: Less, actually,.
17:35:32 <lament> Pseudonym: it wasn't really a question, but ok :)
17:35:39 <Pseudonym> :-)
17:35:46 <Notostraca> lets say you have data that takes a parameter while it is being parsed
17:35:55 <Pseudonym> This is off on a tangent, but I'
17:36:10 <Pseudonym> I'm pretty much convinced that nobody apart from Alan Perlis actually understands what OO is.
17:36:14 <LoganCapaldo> @where hsplugins
17:36:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
17:36:19 <MagicDuck> or otherwise, is there a way to print an expression un-evaluated??
17:36:22 <Pseudonym> Sorry, make that Alan Kay.
17:36:27 <LoganCapaldo> MagicDuck: ^^
17:36:31 * Pseudonym confuses his Alans
17:36:37 <MagicDuck> :)
17:36:44 <vininim> Functions are first class citizens in functional languages, I think you are more concerned with serialization.
17:37:01 <ddarius> Pseudonym: Well if you define "OO" as "what Alan Kay thinks it is", then ...
17:37:12 <vininim> @where alan kay
17:37:12 <lambdabot> I know nothing about alan.
17:37:42 <Notostraca> so then a data file has a header that declares what parameters it should be parsed with.
17:38:39 <Korollary> Pseudonym: His full name is Alan Jay Parlis. So close.
17:38:45 <Korollary> err Perlis
17:39:01 <ddarius> Perlis is an abbreviation for Parlis
17:39:15 <Notostraca> and so you can parse a datum partially to get another datum
17:39:51 <Notostraca> actually this sounds like a database
17:40:04 <Notostraca> querying and all that
17:43:09 <BMeph> Relational-Oriented Programming? ;p
17:43:32 <wli> BMeph: Logic programming?
17:43:40 <Notostraca> this is pretty mind bending for me
17:43:40 <jair_> Hello! I have a function defined as this:
17:43:46 <jair_> phiMcLaurinTerm :: (Num a) => [[[a]]] -> a -> Int -> [[a]]
17:43:48 <jair_> phiMcLaurinTerm apows t n = matrixScalarProduct (apows!!n) ((t^n) / (fromIntegral (product [1..n])))
17:43:51 <LoganCapaldo> i practice request-oriented programming
17:44:22 <jair_> however, for n>13, it gives different results called as a function, than ifi directly evaluate:
17:44:40 <LoganCapaldo> and bug-oriented programming
17:44:43 <jair_> matrixScalarProduct (apows!!13) ((1.0^13) / (fromIntegral (product [1..13])))
17:44:57 <Notostraca> well you are using Int s not Integers
17:45:40 <ddarius> :t 1.0
17:45:42 <lambdabot> forall t. (Fractional t) => t
17:45:43 <ddarius> :t 1
17:45:44 <lambdabot> forall t. (Num t) => t
17:45:55 <monochrom> > product [1..13]
17:45:57 <lambdabot>  6227020800
17:45:59 <Notostraca> if I'm not mistaken you may be exceeding bounds or something relating to the size in bits of a variable
17:46:02 <monochrom> > product [1..13] :: Int
17:46:03 <lambdabot>  1932053504
17:46:08 <monochrom> Ah.
17:47:01 <Notostraca> monochrom: thanks for that
17:47:07 <ddarius> :t 13
17:47:07 <lambdabot> forall t. (Num t) => t
17:47:17 <jair_> ahh, so I should write product[1..13]::Integral ? Or how do I force product [1..13 to be Integral
17:47:17 <wli> It shouldn't overflow until n = 17
17:47:40 <monochrom> phiMcLaurinTerm :: (Num a) => [[[a]]] -> a -> Integer -> [[a]]
17:47:43 <dolio> > maxBound :: Int
17:47:44 <lambdabot>  2147483647
17:47:51 <ddarius> jair_: You should convert n to another type before constructing the product.
17:47:56 <roconnor> > maxBound :: Expr
17:47:58 <lambdabot>  maxBound
17:48:02 <roconnor> :D
17:48:20 <jair_> ddarius: I see
17:48:21 <wagle_home> > maxBound :: ()
17:48:22 <lambdabot>  ()
17:48:24 <ddarius> > [n..m] :: [Expr]
17:48:25 <lambdabot>  Exception: not a number
17:48:38 <dolio> > maxBound < (minBound :: Expr)
17:48:39 <lambdabot>  True
17:48:45 <monochrom> > [2..4] :: [Expr]
17:48:46 <lambdabot>  [2,3,4]
17:48:53 <monochrom> > [n..n+2] :: [Expr]
17:48:54 <lambdabot>  Exception: not a number
17:49:05 <monochrom> > [2..2+2] :: [Expr]
17:49:06 <lambdabot>  [2,3,4]
17:49:08 <jair_> ah, but I cannot use an Integral as an "index" in !!
17:49:12 <wli> > (2 :: Expr) < (3 :: Expr)
17:49:13 <lambdabot>  True
17:49:14 <wagle_home> > minBound < (maxBound :: Expr)
17:49:15 <lambdabot>  False
17:49:21 <LoganCapaldo> @type genericIndex
17:49:22 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
17:49:28 <wagle_home> ooo
17:49:34 <wli> > (1 + 1 :: Expr) < (2 + 3 :: Expr)
17:49:35 <lambdabot>  True
17:49:42 <wli> > (1 + 1 :: Expr) > (2 + 3 :: Expr)
17:49:43 <lambdabot>  False
17:49:43 <ddarius> > minBound < (maxBound :: ())
17:49:44 <lambdabot>  False
17:50:03 <monochrom> product [1 .. (fromIntegral n :: Integer)]
17:50:04 <LoganCapaldo> > [1,2,3] `genericIndex` (1 :: Integer)
17:50:07 <lambdabot>  2
17:50:11 <wli> maxBound < (minBound :: Expr) is cute.
17:50:14 <roconnor> > compare minBound (maxBound::Expr)
17:50:15 <lambdabot>  GT
17:50:17 <dolio> > (5 + 1) < (1 + 385384 :: Expr)
17:50:18 <lambdabot>  True
17:50:25 <roconnor> that's F'd up
17:50:42 <wagle_home> lexical ordering?
17:50:45 <dolio> It orders things lexicographically.
17:50:49 <roconnor> oh
17:50:49 <wli> The constructors are listed out of order somehow.
17:50:52 <ddarius> It should probably represent minBound and maxBound explicitly.
17:51:12 <BMeph> I like some of Perlis' epigrams. Don't like some other ones.
17:51:17 <ddarius> Then it could perform manipulations with them.
17:51:27 <wli> (15 :: Expr) > (7 :: Expr)
17:51:39 <roconnor> > (15 :: Expr) > (7 :: Expr)
17:51:40 <lambdabot>  True
17:51:58 <ddarius> Presumably Expr is like data Expr = Var String | Num Integer | ...
17:51:58 <wagle_home> wacky
17:52:23 <wli> ddarius: That's what I figure, too.
17:52:28 <wagle_home> > (15 :: Expr) < (7 :: Expr)
17:52:28 <lambdabot>  False
17:53:01 <wli> Not too exciting; I've written representations of arithmetic expressions with Num instances on them etc.
17:53:14 <wagle_home> > (1+15 :: Expr) < (2+7 :: Expr)
17:53:15 <lambdabot>  False
17:53:28 <BMeph> "A program without a loop and a structured variable isn't worth writing."
17:53:31 <ddarius> It's a convenient hack for didactic purposes, not a CAS
17:53:42 <wagle_home> > (2+15 :: Expr) < (1+7 :: Expr)
17:53:43 <lambdabot>  False
17:53:46 <BMeph> To quote lambdabot, "bzzt!"
17:53:56 <wagle_home> > (2+15 :: Expr) < (11+7 :: Expr)
17:53:56 <lambdabot>  True
17:54:12 <wagle_home> > (2+15 :: Expr) < (10+7 :: Expr)
17:54:12 <lambdabot>  False
17:54:36 <ddarius> wagle_home: Presumably + is Num n + Num m = Num (n+m); other cases and similarly for <
17:54:42 <wagle_home> > (x+15 :: Expr) < (x+7 :: Expr)
17:54:43 <lambdabot>  True
17:55:14 <jair_> I'm on the verge of tears. I get all kinds of type errors if I try to mess with thye function definiion
17:55:39 <jair_> for instance:
17:55:43 <jair_> phiMcLaurinTerm :: (Num a, Integral b) => [[[a]]] -> a -> b -> [[a]]
17:55:45 <jair_> phiMcLaurinTerm apows t n = matrixScalarProduct (apows!!n) ((t^n) / ((product [1..n])))
17:55:48 <wagle_home> > (maxBound::Int+15 :: Expr) < (maxBound::Int+7 :: Expr)
17:55:48 <lambdabot>  Parse error at "+15" (column 15)
17:56:10 <LoganCapaldo> jair_: my messing with genericIndex was for your benefit ;)
17:56:13 <wagle_home> > ((maxBound::Int)+15 :: Expr) < ((maxBound::Int)+7 :: Expr)
17:56:14 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Int'
17:56:15 <dolio> Actually, it must keep the operations around sometimes.
17:56:21 <dolio> > 1 + 2 + 3 :: Expr
17:56:22 <lambdabot>  1 + 2 + 3
17:56:22 <jair_>  Couldn't match expected type `Int'
17:56:24 <jair_>            against inferred type `b' (a rigid variable)
17:56:26 <jair_>       `b' is bound by the type signature for `phiMcLaurinTerm'
17:56:28 <jair_>         at Phi.hs:27:36
17:56:29 <jair_>     In the second argument of `(!!)', namely `n'
17:56:31 <jair_>     In the first argument of `matrixScalarProduct', namely
17:56:33 <jair_>         `(apows !! n)'
17:56:33 <wagle_home> > maxBound::Int
17:56:34 <lambdabot>  2147483647
17:56:34 <jair_>     In the expression:
17:56:36 <jair_>         matrixScalarProduct (apows !! n) ((t ^ n) / ((product ([1 .. n]))))
17:56:40 <monochrom> what's wrong with product [1 .. (fromIntegral n :: Integer)] ?
17:56:44 <wagle_home> 2147483647 + 1 :: Expr
17:56:50 <wagle_home> > 2147483647 + 1 :: Expr
17:56:51 <lambdabot>  2147483647 + 1
17:56:54 <ddarius> dolio: Then it evaluates it when it actually needs the value.
17:57:02 <ddarius> Or attempts to at least
17:57:04 <dolio> I guess.
17:57:15 <LoganCapaldo> jair_: 1) don't paste so much, 2) use genericIndex instead of !! or use monochrom's suggestion
17:57:33 <wagle_home> > (2147483647+15 :: Expr) < (2147483647+7 :: Expr)
17:57:33 <lambdabot>  False
17:57:54 <monochrom> Smoke gets in your eyes, you never saw what other peoples said in the channel.
17:58:05 <hpaste>  (anonymous) annotated "Basic SQL example with Parsec" with "(no title)" at http://hpaste.org/5777#a5
17:58:06 <Notostraca> product [1 .. (fromIntegral 10 :: Integer)]
17:58:08 <jair_> LoganCapaldo: true, sorry :$, i'll try
17:58:26 <Notostraca> > product [1 .. (fromIntegral n :: Integer)]
17:58:27 <lambdabot>  Exception: not a number
17:58:47 <Notostraca> > product [1 .. (fromIntegral 14 :: Integer)]
17:58:48 <lambdabot>  87178291200
17:58:53 <Notostraca> there we go
18:00:17 <mudge> hey ddarius and LoganCapaldo
18:00:30 <mudge> and monochrom
18:01:41 <LoganCapaldo> hi mudge
18:01:57 <mudge> hey
18:02:36 <TomMD> So I've got an error saying I need to install my STM libraries with profiling support before I can use -prof to compile executables.  Thing is, I've re-installed STM (after Setup.hs clean) with configure -p and its not working.
18:02:46 <TomMD> Any suggestions?
18:04:03 <Saizan> i thought libraries shipped with ghc were compiled with -p by default
18:06:10 <radetsky> if g is defined already, is the following legal?
18:06:12 <radetsky> x <- f
18:06:13 <radetsky> return $ g h where
18:06:13 <radetsky>   h = i x
18:06:13 <radetsky> ~
18:06:21 <radetsky> ignore the ~
18:06:42 <radetsky> actually, that's probably too complicated to be meaningful
18:06:49 <monochrom> not sure whether it's legal to put "where" there. maybe start a new line.
18:06:56 <radetsky> the point is, can I reference x in a "where" clause?
18:07:05 <monochrom> Oh, no.
18:16:42 <andresj> Hello, what's the function with side effects called again?
18:16:46 <andresj> :)
18:17:00 <Cin> unsafePerformSacrilage
18:17:12 <barubary> DOES NOT COMPUTE
18:17:24 <andresj> :)
18:17:27 <monochrom> "the" function?
18:17:35 <Pseudonym> monochrom: Yes, there's only one.
18:17:42 <andresj> something that is used for guis
18:17:45 <radetsky> nop
18:17:47 <Pseudonym> At least, it's Turing-complete.
18:19:07 <monochrom> It's called "Ash nazg durbatulûk, ash nazg gimbatul, ash nazg thrakatulûk, agh burzum-ishi krimpatul."
18:19:16 <Cin> cthulu ph'tagn
18:19:24 <xif> hahaha
18:19:54 <MagicDuck> gah tah nah, you have defied the Klingon council, hah bah
18:19:59 <xif> come come now, clearly most of you have written a function with side effects sometime in your life
18:20:09 <Pseudonym> Yeah, in C.
18:20:13 <xif> it's childish to be ashamed.
18:20:16 <andresj> :)
18:20:18 <Cin> life?
18:20:26 <Cin> is that something to do with side-effects?
18:20:40 <Pseudonym> But that's only because C confuses "function" with "procedure".
18:20:54 <Pseudonym> Cin: I think xif meant RealLife#.
18:21:02 <monochrom> Yes, I wrote several side-effectful functions. But "the" one is asked for, and there is only one that rules them all.
18:21:42 * andresj then corrects: "what are functions with side effects called again"
18:23:18 <andresj> monad
18:24:18 <barubary> monads aren't functions and they don't have side effects
18:24:19 <blargeyfarg> is that what monads are?  boy... i've been going at things all wrong...
18:24:36 <roconnor> procedures
18:24:39 <roconnor> or maybe commands
18:25:10 <monochrom> And there are many monads, no "the monad".
18:25:12 <blargeyfarg> nondeterministic routines
18:25:21 <gwern> blargeyfarg: we kept meaning to tell you, but we just didn't have the heart
18:25:28 <andresj> :) I'm guessing my understanding of (or my way of describing) monads is too in the surface
18:25:35 <monochrom> And monad isn't "the" only way to do side effects. There are CPS, arrow, ...
18:26:28 <xif> andresj: /me wonders when you're going to accept that a function with side effects have no special name
18:26:32 <blargeyfarg> andresj: were you trying to find the term for "functions without side effects", or were you trying to find the definition of a monad?
18:26:46 <monochrom> Nothing has special names.
18:27:30 <blargeyfarg> andresj: or were you just pondering the ponderable for it's own sake?
18:27:32 <xif> monochrom: you have a special name. monochrom
18:27:45 <monochrom> People also call me mono.
18:28:13 <xif> mono(123)
18:28:23 <xif> you didn't say if you have side effects.
18:28:24 <andresj> blargeyfarg: none of them, although the last one has some truth in it. I was trying to find the term for functions with side effects, or a similar concept.
18:28:45 <blargeyfarg> andresj: fair enough
18:29:04 <andresj> :)
18:29:08 <xif> andresj: it's like in life. some things have side effects when you call them.
18:29:13 <xif> like, cops.
18:29:35 <andresj> let's call functions with side effects cops, then.
18:29:41 <Cin> a function is a relationship
18:29:51 <blargeyfarg> and relationships are best avoided
18:29:55 <xif> heheh
18:30:05 <andresj> :)
18:30:07 <blargeyfarg> wait... that's not transitive, is it?
18:30:25 <cjb> what is this, #haskell-blah?
18:30:52 <blargeyfarg> cjb: i was going to complain about it too, but then it seemed easier to roll with it
18:31:22 <andresj> there's also the fact that #haskell-blah is empty as of 20 seconds ago.
18:31:34 <andresj> strange
18:31:39 <andresj> damn konversation!
18:32:02 <andresj> (which is a kde irc client)
18:32:13 <Cin> we Know
18:32:23 <andresj> :) i'm sure not all
18:32:31 <andresj> ..., Cin.
18:32:41 <BMeph> I thought it was a KDE side-effect. ;p
18:32:46 <gwern> @seen Cale
18:32:46 <lambdabot> Cale is in ##algorithms, #haskell-overflow, #haskell and #ghc. I last heard Cale speak 5h 5m 9s ago.
18:32:48 <xif> andresj: this is #haskell, them smart folks over here
18:32:58 <xif> not like us hillbillies from #python
18:33:00 <vininim> I thought a monad was a category with omega and mu.
18:33:14 <andresj> xif, that's true :)
18:33:20 <monochrom> I use eta and mu.
18:33:25 <xif> they know mathematics and proper CS and all them new-fangled whatchimagings
18:33:27 * vininim has being watching too much youtube
18:33:30 <vininim> *been
18:38:53 <ddarius> A monad is an endofunctor and two natural transformations, usually called η and µ, that satisfy some laws.
18:38:55 * BMeph thinks vininim needs to watch more Catsters on YouTube
18:40:05 <ddarius> Alternatively, you can talk about monads in 2-categories.
18:40:08 <BMeph> ddarius: Any laws in particular, or will any collection do? ;)
18:40:55 <Cin> i can't tell if you are all talking complete nonsense or things i don't know about
18:41:20 <ddarius> We're talking abstract nonsense.
18:41:21 <LoganCapaldo> it's usually both
18:41:23 * andresj relates with Cin.
18:41:35 <blargeyfarg> link: http://youtube.com/watch?v=9fohXBj2UEI
18:41:36 <lambdabot> Title: YouTube - Monads 1
18:41:41 <barubary> Cin: "abstract nonsense" is a technical term
18:41:47 <xif> you can do CPS in Haskell?
18:41:55 <ddarius> xif: Why not?
18:42:08 <ddarius> You can perform the CPS transform in any language with high-order functions.
18:42:32 <xif> ddarius: does it confer any advantages?
18:42:43 <Cin> blargeyfarg: yeah, i've seen that. she might as well be talking in german
18:42:46 <jair_> Haskell types are... special: I had to strugle for a long time to get them right for my function, but now they are in Place they look clear, elegant and beautiful. I hope the same thing will happen to me with monads.
18:43:20 <ddarius> xif: It has particular properties, or rather "they" as there is more than one CPS transform.
18:43:44 <xif> ddarius: I mean, Haskell doesn't have continuations support, right?
18:43:49 <xif> stuff like Scheme's callcc
18:44:04 <ddarius> xif: No, but it can model it. (though that's a bit of a trivial statement)
18:44:05 <LoganCapaldo> Haskell has callcc, in a library! :p
18:44:21 <LoganCapaldo> @hoogle callCC
18:44:22 <lambdabot> Control.Monad.Cont.Class.callCC :: MonadCont m => (a -> m b -> m a) -> m a
18:44:27 <Cin> actually i kind of follow some stuff she's saying
18:44:27 <xif> whoa
18:44:33 * Cin heart attack
18:45:04 <xif> btw, to contribute to the general joy
18:45:17 <xif> did you know that PHP6 is going to feature GOTO statements?
18:45:20 <blargeyfarg> to what degree is CPS an practical choice of solution in Haskell, vs other techniques available?
18:45:28 <barubary> Eine Monade ist ein Tripel (T,η,μ) aus einem Funktor T von einer Kategorie K in sich selbst, sowie zwei natürlichen Transformationen η und µ, die gewisse Bedingungen erfüllen.
18:45:54 <ddarius> blargeyfarg: What "other techniques"?
18:45:54 <olsner> hmm, that makes just as much sense as the english actually
18:46:10 <gwern> @seen Cale
18:46:10 <lambdabot> Cale is in ##algorithms, #haskell-overflow, #haskell and #ghc. I last heard Cale speak 5h 18m 34s ago.
18:46:17 <dejones> blargeyfarg: Man, it amazes me over and over as I learn Haskell how much this programming language is based upon math.  I just don't feel like any other language is like Haskell in that it reflects math so much, in my experience.
18:46:38 <dejones> gwern: Cale is unpredictably available.  ;)
18:46:52 <ddarius> dejones: It's based on the lambda calculus, as are all functional languages.  Other than that, it's not very math based.
18:47:27 <dejones> ddarius: Well, for me to state more clearly, the notation and terminology in Haskell seems very math-based, unlike many other programming languages.
18:47:38 <biouser> http://www.haskell.org/haskellwiki/99_questions/90_to_94
18:47:39 <lambdabot> Title: 99 questions/90 to 94 - HaskellWiki
18:47:53 <Cin> i thought Joy wasn't based on λ
18:47:54 <Cin> hum
18:47:58 <blargeyfarg> dejones: ditto darius.  it's not as much math as formal semantics
18:48:04 <ddarius> dejones: It's all lambda calculus terminology.  The -libraries- and techniques may well be more math based.
18:48:04 <dejones> ddarius: I guess I should learn some lamda calculus, heh.
18:48:13 <Cin> "Joy is based on composition of functions rather than lambda calculus"
18:48:27 <biouser> I'm trying to run the knights tour code from the above wiki
18:48:31 <ddarius> s/functional/applicative
18:48:33 <Cin> ddarius: " It's based on the lambda calculus, as are all functional languages." -- Joy isn't?
18:48:37 <Cin> oh okay
18:48:47 <gwern> dejones: is that the same as saying he's predictably unavailable?
18:49:08 <ddarius> That said, joy is still pretty related to the lambda calculus but certainly more tenuously.
18:49:13 <biouser> should I be able to $ghc knights.hs    ?
18:49:43 <olsner> (\f g x -> f (g x)) *gasp* function composition is also lambda calculus
18:50:01 <xif> did you guys know about J and K? http://en.wikipedia.org/wiki/J_programming_language
18:50:02 <lambdabot> Title: J (programming language) - Wikipedia, the free encyclopedia
18:50:25 <dejones> gwern: If that were true, I'd think we would be able to predict his availability as a complement of the predictably unavailable set?  ;)
18:50:40 <dejones> hehe
18:50:41 <dbueno> I'm getting a bunch of spurious "Defined but not used" warnings with GHC 6.8.2. I'm not using GADTs (so bug 1954 doesn't apply) -- has anyone seen something similar, and I'm likely doing something wrong, or should I whittle down a small testcase and file a bug?
18:51:16 <barubary> dbueno: maybe they're only used by other unused functions
18:51:21 <barubary> or not exported
18:51:34 <gwern> dejones: I think it has to be a binary state - if you're available, you're not unavaiable, and if you're unavailable, then you're not avaiable
18:51:35 <ddarius> xif: Most people here are aware of a wide range of languages.
18:51:47 <dbueno> barubary: Ah, good point.  Hadn't thought about them not being used by other unused functions.  One moment.
18:51:53 <gwern> dejones: so if we can predict when he is avaiable, then necessarily we are also predicting his unavailability
18:52:21 <gwern> dbueno: I was perplexed by such apparent spuriousness myself until one day I removed *all* the warned-about functions and variables, then I understood
18:52:30 <dejones> gwern: yeah, I was saying the same, but the opposite direction, in that if we can predict his unavailability, then we are also predicting his availability... you hear that Cale!  :P
18:53:04 <gwern> dejones: at least, this is assuming our predictions are complete - otherwise, the areas of time our predictions do not speak of are indeterminate
18:53:13 <dejones> lol
18:53:26 <dbueno> gwern: Glad to know I'm not the only one.
18:53:46 <gwern> btw, if anyone here has gtk2hs installed, try a cabal update and then a 'cabal install nymphaea'
18:53:50 <xif> ddarius: what do you think of those two?
18:53:50 <gwern> give it a whirl
18:54:18 <xif> btw, I'm surprised this channel is so large.
18:54:23 <gwern> @tell Cale I got impatient and uploaded anyway: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nymphaea-0.1 I discovered buried in one of the glade files a BSD3 copyright notice, so I figured the rest had to be BSD3 too
18:54:23 <lambdabot> Consider it noted.
18:54:30 <Zao> xif: Many are rather lazy though.
18:54:36 * dejones is going to finish watching "A Taste of Haskell" video tutorial by Simon Peyton-Jones: http://blip.tv/file/324976
18:54:38 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
18:54:45 <gwern> xif: #haskell is famed for its activity and helpfulness
18:54:50 <gwern> Zao: yes. haskellers doin't get enough seqs
18:55:18 <LoganCapaldo> hehhe
18:55:23 <LoganCapaldo> not enough seqs
18:55:24 <dejones> xif: I'm new to Haskell, and this channel is amazingly helpful.  :)
18:55:29 <xif> gwern: yeah, but consider that you almost as many people as #python
18:55:35 <olsner> mmmm, that joke had two levels of fun
18:55:55 <xif> dejones: do you actually write Haskell professionally?
18:56:04 <biouser> so, how do exit ghci?
18:56:18 <ddarius> xif: I know what kind of language K is, but otherwise I haven't really looked at it.  I've only looked slightly more at J, though I'm considering changing that [I downloaded an implementation the other day.]  I played with APL a long time ago.
18:56:18 <dejones> xif: Nope.  Unless you consider my Master's work professional development.  ;)
18:56:24 <Zao> biouser: Send an EOF?
18:56:25 <dejones> biouser: try ctrl-d
18:56:25 <xif> biouser:  Ctrl-D
18:56:26 <biouser> q q() quit() quit exit exit() esc ctrl-c ctrl-q
18:56:32 <olsner> :q
18:56:36 <Zao> ^D on unixen, ^Z<Enter> on Windows.
18:56:50 <gwern> biouser: I like control-d
18:56:50 <gwern> esc? what are you, a dirty vimrr?
18:57:01 <ddarius> xif: I'd say there are definitely unique ideas in those language worth learning, but I seriously doubt I'd much like them.
18:57:08 <biouser> i do use vim, is that dirty?
18:57:15 <barubary> biouser: :q
18:57:27 <gwern> it'd be interesting if someone did J or K (whichever is the Free one) as an EDSL in haskell
18:57:31 <ddarius> biouser: The Haskell community is roughly half and half emacs/vim.
18:57:41 <ddarius> gwern: J is the free one
18:58:14 <gwern> 'Not to be confused with the J++ or J# programming languages.' <-- ackzors
18:58:14 <ddarius> gwern: You could make a J-like EDSL in Haskell fairly easily, but you couldn't completely embed J in it.
18:58:44 <biouser> thank you everyone...
18:58:51 <biouser> :q like vim hehehe
18:58:57 <gwern> ddarius: what would be missing?
18:59:01 <biouser> give me the dirty vim stuff
18:59:18 <ddarius> gwern: You wouldn't be able to get the exact syntax.
18:59:51 <biouser> can someone help me run the code for the knight's tour?
18:59:57 <gwern> ddarius: 'Additionally, to keep parsing and the language simple, and to compensate for the lack of character variation in ASCII, J treats many characters which might need to be balanced in other languages (such as [] {} "" `` or <>) as stand alone tokens or (with digraphs) treats them as part of a multi-character token.' <-- because opf that?
19:01:53 <ddarius> gwern: I haven't looked at the specifics, but it's usually difficult to exactly capture the syntax of any language with an EDSL unless you mean to use something like the quasiquoting features recently added to GHC.
19:03:03 <ddarius> s/usually difficult/impossible
19:03:06 <xif> I'm trying to integrate Haskell into my workplace.
19:03:12 <xif> Trying... in vain.
19:03:19 <ddarius> I'm not.
19:03:53 <xif> the problem is that Haskell has a reputation as a - would you believe it?! - _hard to learn language_!
19:04:01 <BMeph> Haskell: Where programmers consider "lazy" a name of honor... ;)
19:04:10 <LoganCapaldo> workplace language advocacy is hard. let's go shopping
19:04:15 <gwern> absurd. haskell is notoriously easy
19:04:16 <ddarius> BMeph: Programmers in any language do that.
19:04:34 <gwern> what with its lack of types and advanced concepts, it's as simple as you get!
19:04:52 <xif> so my superiors are, like, concerned that nobody would understand my code and stuff.
19:05:09 <ddarius> xif: Do they understand your code nowL
19:05:09 <BMeph> ddarius: Well, yes, but usually it's in reference to life in general, not specifically the programming they do. :)
19:05:10 <ddarius> ?
19:05:11 <LoganCapaldo> No one is gonan understand your code anyway
19:05:12 <xif> how silly of them.
19:05:39 <xif> ddarius: my boss is a better Python programmer than me.
19:05:46 <ddarius> So?
19:05:58 <xif> so he kind of gets it, no matter how much I try to obfuscate things.
19:06:04 <jair_> I find HAskell code easier to pick up when reading someone else's, but harder to write myself, as opposed to, say, C++ or Java
19:06:14 <xif> which is why I'm trying to switch arenas to Haskell and beat him there!
19:06:24 <blargeyfarg> xif: you try to obfuscate things?
19:06:42 <xif> blargeyfarg: sure, all the time. it's part of my job description.
19:07:02 <blargeyfarg> xif: government work?
19:07:07 <gwern> interesting job
19:07:23 <dons> xif: its just like any other language. use it, use it well, and no one will care
19:07:39 <xif> blargeyfarg: I code for an art gallery displaying obfuscated Python samples for the discerning visitors.
19:08:00 <xif> dons: yeah, maybe in a few months.
19:08:04 <araujo> red moon!
19:08:08 <ddarius> I just realized something.  I have a fresh project at work now.
19:08:08 <olsner> xif: seriously?
19:08:22 <gwern> xif: srsly?
19:08:31 <xif> of course, would I tell a lie?!
19:08:37 <ddarius> yes
19:08:43 <xif> now I need to go, srsly
19:08:46 <xif> laterz
19:09:09 * BMeph goes to see the eclipse
19:09:21 <wli> Hmm, the obvious list monad solution seems slow.
19:10:21 <biouser> what does         head $                mean?
19:10:46 <biouser> chessguy!  how about some closed knight's tours in hypercubes?
19:10:50 <barubary> biouser: $ is an operator, head is a standard function
19:10:59 <dons> xif, code for an art gallery?
19:10:59 <barubary> @src ($)
19:11:00 <lambdabot> f $ x = f x
19:11:03 <chessguy> uh...hi
19:11:06 <barubary> @src head
19:11:06 <lambdabot> head (x:_) = x
19:11:06 <lambdabot> head []    = undefined
19:11:07 <dons> interesting.
19:13:07 * BMeph shakes his fist at the winter storm clouds
19:13:42 <ddarius> It's like 70 degrees here at 9PM now
19:14:13 <LoganCapaldo> where is here?
19:14:19 <ddarius> Texas
19:14:25 <LoganCapaldo> mmm
19:14:48 <LoganCapaldo> I have family in texas
19:14:53 <ddarius> I don't.
19:15:01 <chessguy> i'm getting married in texas next weekend
19:15:08 <TSC> Yee ha
19:15:23 <TSC> Remember to fire your six-shooters in the air at the end
19:15:24 <ddarius> chessguy: Congratulations about the getting married.  Too bad about the Texas part.
19:15:29 <chessguy> haha
19:15:32 <chessguy> i like texas
19:15:40 <gwern> phooey. hoogle's cabal stuff is outdated
19:17:08 <ddarius> I will admit, tonight is a beautiful night.
19:17:30 <bitrot> with the rain slowing, yes ;)
19:17:40 <dons> chessguy: congratulations!
19:17:48 <dons> anyone watching the eclispe?
19:17:50 <dons> its on now.
19:17:52 <cjb> hm.  which lightweight wiki should I use?  :)
19:17:58 <ddarius> BMeph alleges to be.
19:18:02 <chessguy> thanks dons
19:18:03 <cjb> dons: which channel?
19:18:09 <dons> in the sky? :)
19:18:26 <cjb> ah, I don't have satellite.
19:18:36 * cjb will bittorrent it later.
19:18:46 <monochrom> haha "which channel" :)
19:18:58 <monochrom> haha "bittorrent it later" :)
19:19:03 <BMeph> No, I went out to try, but there is too much cloud cover. :|
19:19:13 <ddarius> Yeah.  Pretty cloudy here too.
19:19:54 <gwern> cjb: we don't really seem to have any competent or standard wiki here in haskell land
19:19:59 <gwern> mebbe you could write?
19:20:04 <dons> for some bizarre reason portland is actually clear tonight
19:20:16 <dons> a competent standard wiki?
19:20:17 <cjb> gwern: haskell isn't a requirement :)
19:20:30 <ddarius> Haskell is -always- a requirement.
19:20:33 * gwern can has a hiki? ...obviously we'd need a better cutesy name for a 'haskell wiki'
19:20:36 <BMeph> dons: Really? Isn't that against the city ordinances? ;)
19:20:43 <dons> i thought so, yes.
19:21:56 <LoganCapaldo> we could call it StateTWeb
19:22:12 <LoganCapaldo> or IOPageRef
19:22:25 <dino-> I've been peeking at the eclipse. It's clear enough here in NC.
19:22:26 <ddarius> unsafePerformMerge
19:22:33 <LoganCapaldo> (also I think hiki is taken)
19:22:52 <gwern> LoganCapaldo: those are terrible. no one would ever spell or capitlize them right
19:23:11 <LoganCapaldo> gwern: thanks, I try
19:23:17 <Zao> WikiT, so you can be confused with TWiki?
19:23:44 <ddarius> Actually there is a canonical name: WikiMonad
19:24:43 <mrd> yikes forgot about th eclipse
19:25:02 * ddarius didn't know about an eclipse and now that he knows doesn't care.
19:25:18 <brailsmt> how do i convert from a String to an Int?
19:25:25 <ddarius> :t read
19:25:27 <lambdabot> forall a. (Read a) => String -> a
19:25:41 <mrd> it's amazing to see an eclipse that doesn't crash my computer
19:25:46 <brailsmt> lol
19:25:49 <brailsmt> @ mrd
19:25:52 <dons> mwhahaha
19:25:58 <monochrom> hahaha
19:26:14 <dons> did anyone see the "i really did break reddit" post?
19:26:15 <LoganCapaldo> someone at remember that
19:26:21 <LoganCapaldo> me me
19:27:49 <ddarius> dons: No.  It was a figment of your imagination.
19:27:51 <dons> top 10 errors you won't see in a haskell webapp: unbalanced parens at runtime
19:28:15 <dons> http://reddit.com/r/programming/info/69ftg/comments/
19:28:30 <dons> Exception.IndentationError hehe
19:29:13 <LoganCapaldo> I'm not clear how you get an IndentationError at "runtime"
19:29:25 <dons> well, somehow you deploy that code, and it crashes
19:29:28 <dino-> Python
19:29:33 <dino-> The indentation is the blocking.
19:29:39 <LoganCapaldo> I know it's python
19:29:42 <ddarius> LoganCapaldo: Parsers, like type checkers, are too restrictive.
19:30:03 <dons> i'd never thought of parsing as a form of validation
19:30:16 <dons> you'd want to ensure your code was syntactically correct before comitting
19:30:44 <dons> whereas we usually try to enforce type correctness before committing, at a minimum
19:30:52 <cjb> and if they had a commit hook that did that, it would have caught it
19:30:53 <dino-> Perhaps the code is hacking more Python together at runtime.
19:31:01 <LoganCapaldo> but  had this (dumb?) assumption that if something failed to parse you wouldn't be in a position to spit out an exception backtrace to your website
19:31:20 <barubary> depends on whether you can load modules at runtime
19:31:22 <dons> is it loading modules incrementally?
19:31:24 <ddarius> LoganCapaldo: Now you know better.
19:31:35 <LoganCapaldo> apparently
19:31:43 <barubary> also, python can give you "unbound variable" errors at runtime
19:31:44 <dons> like /bin/sh -- it mightn't fail till it hits lazily demands that module be parsed
19:31:55 <ddarius> top 10 errors you won't see in a python webapp: type variable less polymorphic than expected
19:31:57 <dons> it feels all so fragile
19:32:09 <dons> ddarius: but you'd not be able to see that at runtime in haskell
19:32:21 <dons> there's a huge class of embarassing web app failures we could be preventing. sigh
19:32:26 <ddarius> dons: It depends on what you mean by run-time.
19:32:32 <dons> exposed to your users
19:32:41 <dons> this is why hpaste doesn't seem to go wrong..
19:32:41 <barubary> ddarius: top 10 errors you won't see in a python webapp: Exception: <<loop>>
19:32:55 <dons> heh. it'd get a stack overflow?
19:33:05 <dons> or maybe just timeout
19:33:34 <cjb> dons: I don't think this is a reasonable complaint.  One can commit broken Haskell code, and apparently they committed broken Haskell code.
19:33:52 <cjb> uh
19:33:55 <cjb> Python
19:34:38 <ddarius> Python certainly is broken Haskell code.
19:34:58 <ddarius> usually...
19:35:51 <mrd> ah nice and clear
19:36:45 <dons> cjb: but it wouldn't get deployed
19:36:52 <dons> it got comitted, then deployed. so users saw it
19:37:00 <dons> you wouldn't get your haskell web app compiled
19:37:06 <dons> so your users would never know
19:37:12 <cjb> dons: ah, right.
19:37:16 <sclv> well there's another issue in that they appear to be running the framework in debugging mode or something.
19:37:35 <ddarius> sclv: Haskell is safe from that issue.
19:37:36 <cjb> running pylint would howe caught this.
19:37:59 <dons> yeah. at a minimum you'd add a parse check
19:38:06 <dons> and in the limit you'd have a type system
19:38:19 <sclv> ddarius: no doubt. still though, most sane systems let you trap exceptions to return some sort of "resource unavailable" error and throw the actual code trace to a log file.
19:38:35 <dons> so they usually do that. something broke
19:38:38 <cjb> sclv: including python ones.
19:38:56 <gwern> now this is odd. what the heck are Creative Commons NC licenses doing strewn throughout the Hoogle source codes?
19:38:58 <sclv> and you'd still need that in a haskell system, e.g., for exceptions from partial functions, bad reads, etc.
19:39:16 <gwern> @seen ndm
19:39:17 <lambdabot> I saw ndm leaving #haskell 3d 11h 57m 13s ago, and .
19:39:21 <mrd> dons: or perhaps, a proof system
19:39:49 <dons> yep. a serious type system :)
19:40:05 <cjb> gwern: eww
19:40:31 <ddarius> I think we should put mid-20 year old women at teletypes at the other end of these network connections.
19:40:42 <dons> great idea, ddarius
19:41:03 <gwern> cjb: I know! the wiki and cabal files even claim it's a sensible GPL, but then the src files have CC in'em...
19:41:03 <gwern> a bit of a wtf moment
19:41:22 <cjb> gwern: that is wack
19:41:27 <dons> gwern's licensing saga, episode 8
19:41:40 <cjb> CC NC isn't even used anymore, it's retired
19:41:42 <ddarius> licensing is annoying
19:41:49 <dons> 11 new hackage submissions since this morning?
19:41:51 <dons> crikey!
19:41:58 <gwern> really? I didn't hear that they had retired NC
19:42:04 <cjb> yeah
19:42:12 <sclv> doesn't gpl override cc?
19:42:15 <gwern> NC has caused WP so many problems...
19:42:25 <dons> gwern: it'd be great if you could point to any src repos in the .cabal files , as you upload those things
19:42:27 <cjb> sclv: they're incompatible
19:42:34 <sclv> oh dear.
19:42:43 <gwern> sclv: ndm may be dual-licensing, in which case he can do it, but the situation is confusing
19:42:49 <biouser> @src head
19:42:49 <cjb> NC is not a free software license.  you can't discriminate.
19:42:49 <lambdabot> head (x:_) = x
19:42:49 <lambdabot> head []    = undefined
19:43:03 <gwern> like quantum mechanics, if you think you understand dual-licensing, you probably don't :)
19:43:11 <biouser> @src head [1,2,3]
19:43:11 <lambdabot> Source not found. There are some things that I just don't know.
19:43:25 <gwern> cjb: exactly, that's why I and WP dislike it. noncommercial isn't even a clear distinction
19:43:42 <cjb> gwern: CC dislikes it too :)
19:43:47 <cjb> (now)
19:44:16 <dons> ?src head
19:44:16 <lambdabot> head (x:_) = x
19:44:16 <lambdabot> head []    = undefined
19:44:54 <cjb> I thought it was head []    = error "empty list!"
19:45:24 <gwern> the website seems to still include NC as options
19:46:06 <gwern> ie http://creativecommons.org/license/ <-- first option is NCornoNC
19:46:07 <lambdabot> Title: Choose a License
19:46:27 <cjb> oh, oops
19:46:57 <cjb> I was thinking of the Developing Nations license.  Brainfart.
19:46:59 * gwern 's hopes are crushed in one fell oops
19:47:00 <cjb> Sorry.
19:49:17 <dejones> ?src return
19:49:17 <lambdabot> Source not found. :(
19:49:31 <dejones> argh
19:50:11 <barubary> @src (->) return
19:50:12 <lambdabot> return = const
19:51:18 <barubary> http://lol.7chan.org/pr/src/120356555741.jpg
19:52:15 <dejones> hehe
19:52:55 <gwern> the third eye opens
19:53:04 <xpika> "lucy in the sky with lambdas"
19:53:23 <jre2> why might using runhaskell give you different behavior compared to running a compiled binary (wrt network socket)?
19:53:45 <barubary> jre2: maybe it messes with your buffering?
19:53:46 <sclv> threading ?
19:53:50 <dejones> barubary: why the (->) for return...?
19:54:12 <barubary> dejones: just an example of a monad
19:54:13 <dejones> barubary: I thought the "return" was just a function that can be used in a do {} block?
19:54:15 <dejones> oh, ok
19:54:23 <barubary> no, return is a function
19:54:31 <barubary> it can be used everywhere
19:54:35 <dejones> ok
19:54:52 <barubary> but the implementation depends on the particular type you're using
19:54:56 <dejones> is return implemented differently for what you need?
19:54:58 <dejones> ahh.
19:55:03 <barubary> @src Maybe return
19:55:03 <lambdabot> return              = Just
19:55:10 <dejones> barubary: I see.  Thank you.  :)
19:55:25 <jre2> my sockets don't seem to receive data until the other end closes, so it certainly seems like a buffering issue, but I've set hSetBuffering NoBuffering
19:58:10 <MagicDuck> what is the equivalent to try-catch in haskell ?
19:58:26 <barubary> :t try
19:58:27 <lambdabot> Not in scope: `try'
19:58:35 <barubary> @hoogle catch
19:58:36 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
19:58:36 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
19:58:36 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
19:58:54 <jre2> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
19:58:56 <lambdabot> http://tinyurl.com/sqmlj
19:59:11 <MagicDuck> thx guys
19:59:33 <dino-> Can you also construct this with Control.Monad.Error, throwError and catchError?
20:01:57 <EvilTerran> MagicDuck, there's also such things as Maybe, MonadError, etc
20:04:52 <dibblego> ?hoogle (Functor f) => (a -> IO ()) -> f a -> IO ()
20:04:52 <lambdabot> No matches, try a more general search
20:14:17 <dibblego> does it make sense to have ap on Functor like Monad?
20:14:47 <barubary> :t (<*>)
20:14:55 <conal> dibblego: then it'd be Applicative
20:14:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:15:11 <dibblego> ah yes
20:20:26 <wli> My knight's tour code apparently matches the naive code.
20:31:35 <biouser> someone said knight's tour?
20:32:02 <biouser> wli, what are you doing with knight's tours?
20:32:12 <gwern> @hoogle hSetEcho
20:32:14 <lambdabot> System.IO.hSetEcho :: Handle -> Bool -> IO ()
20:32:57 <TomMD> Wahoo: New, excessivly complex, overly shiny control-event released.
20:33:49 <biouser> if someone has some working knight's tour code, pastebin it and I will send you $$
20:35:19 <gwern> desperate huh
20:36:07 <biouser> nah, mostly just kidding, nothing pressing...
20:36:18 <biouser> just been fiddling with it for few hours without much to show
20:36:43 <wli> biouser: eh? search the haskell.org wiki if you need it
20:36:52 <biouser> this is my first day of Haskell, though.
20:37:07 <biouser> yeah I think something is wrong with the closed tour algorithm there
20:37:40 <biouser> it works great for 8x8
20:38:04 <wli> biouser: Where is there trouble?
20:38:58 <biouser> well, I haven't gotten it to output on much else.  Do you know how much time it would take to get the head tour off of a 6x6?
20:39:19 <biouser> I guess I never let it run more than about 5 or ten minutes on that
20:39:30 <biouser> 16x16 ran for over an hour
20:39:31 <gwern> http://www.cs.mu.oz.au/~bjpop/code.html <-- space invaders, fun
20:39:39 <lambdabot> Title: Bernie Pope's fun Haskell code
20:39:45 <wli> biouser: 6x6 took 4s with naive code here
20:40:03 <gwern> 'David Roundy originally developed a Bridge game in Haskell and wrote a versioning system for this project. However as time went by, the versioning project Darcs became the more important part of the development and the bridge game was stalled.' <-- lol
20:40:13 <biouser> could you patebin it or you are saying it is the same as problem #91 off of the wiki
20:40:55 <sm> ohhhh.. that explains abridgegame.org
20:40:55 <wli> biouser: It's effectively the same as problem #91
20:41:35 <wli> biouser: I don't believe you'll find it as useful as the fast code for problem 91.
20:42:17 <biouser> I actually am more interested in the naive code to start with.  I am trying to do some base cases in 4d
20:42:26 <wli> 4d?
20:42:35 <biouser> I don't think Warnsdorff's heuristic will be much use there
20:42:48 <biouser> that is the non-naive, eh?
20:43:10 <wli> biouser: Yeah.
20:44:23 <wli> biouser: There's probably a "meet in the middle" refinement where you look for tours of half length (ceil(n^2/2) and floor(n^2/2) for odd n) that meet each other halfway.
20:49:48 <sm> gwern: thanks, that is fun
20:51:30 <biouser> wli, hmm... actually if you change the starting/ending to (4,5) and (6,4) it runs about a million times faster for some reason
20:51:45 <biouser> now I can get 12x12, 16x16, etc...
20:51:49 <biouser> (for closed)
20:52:29 <biouser> 16x16 took about 2 secs whereas before I broke it at about an hour
20:52:36 <biouser> that's a pretty huge difference
20:53:33 <sm> doesn't *work* for me of course, but the code is so pretty I have every confidence..
20:54:12 <gwern> sm: it's easy to fix. IO becomes System.IO, rm the IOExts imports, and then runhaskell Main,hs
20:55:42 <sm> yeag! I was about to say
20:55:48 <sm> take that alien horde!!
20:56:05 <gwern> pity it doesn't include licensing info
20:57:49 * sm senses a cabal package
20:58:18 <biouser> @src Square
20:58:18 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:58:37 <sm> gwern: it's a bit slow, eh ?
20:58:45 <sm> surprisingly
20:59:01 <gwern> sm: a little. dunno if that's the naive code or the interface - it seems to update only on key presses
20:59:20 <sm> oh..
21:00:00 <sm> well, it updates faster if I hold a key
21:00:29 <gwern> zackly
21:01:46 <biouser> type Square = (Int, Int)     what does that mean?
21:02:13 <barubary> typedef std::pair<int, int> square;
21:02:47 <brailsmt> i'm reading through http://www.haskell.org/~pairwise/intro/section3.html and I've got a question about the function type:  fibGen :: (Num a, Num b) => b -> b -> a -> b
21:03:19 <brailsmt> specifically the b -> b -> a -> b part...
21:03:21 <biouser> ty barubary, your responses are always over my head but I appreciate that you respond :)
21:03:52 <barubary> biouser: it looks like you don't know C++ :-)
21:04:13 <barubary> it means: "the type Square is now another name for (Int, Int)"
21:04:28 <brailsmt> fibGen takes three parameters, so does this type definition mean that it maps (b, b, a) to type b?
21:04:30 <barubary> where (Int, Int) = a tuple consisting of two integers
21:05:21 <biouser> so Square is user-defined?
21:05:30 <TSC> brailsmt: Yes, that's right
21:05:32 <barubary> yes
21:05:44 <biouser> awesome, that makes perfect sense
21:05:44 <TSC> It takes 2 'b's and an 'a', and returns a 'b'
21:05:59 <barubary> the syntax is "type" YourNameHere "=" SomeExistingType
21:06:05 <conal> brailsmt: sort of, but really fibGen is in "curried" form, which means it takes one argument, which returns another function.
21:06:12 <biouser> okay, great tyvm
21:06:15 <conal> s/which/and
21:06:56 <conal> brailsmt: b -> b -> a -> b   means   b -> (b -> (a -> b))
21:08:08 <synthase> currying, right?
21:08:21 <conal> synthase: right
21:08:30 <brailsmt> conal: hence the currying...  if i specify the first parameter only it returns a function of type b -> (a->b))
21:08:51 <conal> brailsmt: exactly!
21:09:13 <brailsmt> conal: thx
21:10:03 <brailsmt> i'm new to haskell, but we wrote a compiler in scheme in school, so functional programming isn't new to me, just atrophied  :)
21:10:35 <conal> brailsmt: welcome back to functional programming!  glad to have you here.
21:12:23 <brailsmt> TSC: thx as well
21:13:07 <TSC> No worries; enjoy rediscovering everything (:
21:15:11 <brailsmt> its mind bending, conal triggered the first big breakthrough  :))
21:16:05 <biouser> knightsTo n finish = [pos:path | (pos, path) <- tour (n*n)]
21:17:57 <biouser> so n is the input integer that creates the nxn Square.  finish is the user-input final vertex eg (2,3)
21:18:11 <biouser> not sure about the syntax after that
21:18:53 <biouser> not sure how Haskell interprets | and : in particular
21:19:02 <barubary> : is cons
21:19:19 <barubary> > 42 : [1,2,5]
21:19:23 <lambdabot>  [42,1,2,5]
21:19:55 <barubary> > [ x*x | x <- [1 .. 10] ]
21:19:59 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
21:21:02 <biouser> ah-ha ...
21:21:10 <biouser> brilliant
21:21:56 <barubary> > ['!' : x | x <- ["foo", "bar", "baz"]]
21:22:05 <lambdabot>  ["!foo","!bar","!baz"]
21:26:02 <biouser> thanks for the crash course in list comprehensions barubary, that's really nice of you
21:30:37 <phubar> thats slightly different, but yeah.. quite nice, out of the box haskell has support for arbitrary precision numbers
21:31:45 <biouser> lol
21:35:02 * sm hacks around with hinvaders a little
21:37:14 <sm> it's a great example for haskell students
21:49:38 <sm> well.. I don't know if it's quite idiomatic today
21:50:14 <sm> the Interact stuff is slightly non-obvious
22:02:31 <biouser> where cmpFst x y z = compare (fst x) (fst y) (fst z)
22:02:52 <biouser> is there a something like compare that works on 3 values?
22:05:45 <Heffalump> what would it do?
22:08:20 <mrd> 1GT2LT3 :)
22:09:52 <biouser> alright, I got me some knight's tours in cubes
22:10:02 <biouser> I'd like to thank all the little people...
22:14:37 <dons> great biouser :)
22:14:56 <bos> @hoogle Double -> Int
22:14:57 <lambdabot> No matches, try a more general search
22:14:57 <biouser> not bad for a first day newb!
22:16:13 <bos> @hoogle RealFloat
22:16:14 <lambdabot> Prelude.RealFloat :: class (RealFrac a, Floating a) => RealFloat a
22:17:32 <oerjan> @src RealFrac
22:17:33 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
22:17:33 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
22:17:33 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
22:18:36 <glguy> Anyone remember that SimonM (I believe) mailing list post that mentioned stuff you shouldn't do in the main thread?
22:18:55 <dons> glguy: oh yes.
22:18:58 <dons> i've got that bookmarked.
22:19:05 <glguy> awesome, share?
22:19:05 <dons> main thread == context switch!
22:19:13 <dons> u can has
22:20:01 <dons> http://hackage.haskell.org/trac/ghc/ticket/1889
22:20:05 <lambdabot> Title: #1889 (Regression in concurrency performance from ghc 6.6 to 6.8) - GHC - Trac
22:20:06 <dons> "One more tip: when using -threaded, never use the main thread to do the real work. Communication
22:20:10 <dons> between the main thread and other forkIO'd threads is much much slower than between two forkIO'd
22:20:13 <dons> threads, because the main thread is a "bound thread" (i.e. it has an OS thread to itself). This is
22:20:16 <dons> perhaps the main reason that turning on -threaded will make the version of threadring above go much
22:20:19 <dons> slower"
22:29:27 <blargeyfarg> well that's good to know
22:31:51 <mrd> probably related to why gtk2hs with -threaded requires all gtk calls to be made from the main thread
22:35:25 <sm> I'd like to know how loopInput loops here: http://joyful.com/darcsweb/darcsweb.cgi?r=hinvaders;a=headblob;f=/Main.hs#l117
22:35:34 <lambdabot> Title: darcs - hinvaders, http://tinyurl.com/2tvmta
22:37:23 <oerjan> er is there a view with proper indentation?
22:37:30 <blargeyfarg> it's a call chain
22:37:48 <blargeyfarg> loopInput eventually ends up calling itself if you follow the call chain
22:37:52 <glguy> dons: do you know if git was installed?
22:38:06 <sm> oerjan: ? looks indented here..
22:38:18 <sm> blargeyfarg: thanks, I'll stare more
22:38:28 <blargeyfarg> sm: work backwards from spawnInvaderBullets
22:38:37 * sm was trying to do that in ghci debugger
22:38:48 <Twey> sm: From spawnInvaderBullets.  Hah!
22:38:52 <adu> hi
22:39:28 <dons> glguy: not yet, afaik
22:40:02 <dons> sm, oh , interesting. you were exploring some code, using the debugger?
22:40:12 <dons> i've not heard of people doing that - but its a great idea.
22:40:30 <sm> yes, trying to. I saw your (?) article recently ?
22:40:52 <blargeyfarg> you have to debug Haskell apps?
22:40:58 <sm> but I sorely missed a "step out of" and "step over"
22:41:34 <allbery_b> usuallly only when someone uses a non-total function
22:41:41 <sm> blargeyfarg: just to help me read the code, in this case
22:41:50 <blargeyfarg> ;)
22:42:02 <sm> actually no, I'm debugging too. Trying to find out why it speeds up when you hold a key
22:42:34 <blargeyfarg> sm: check nextLevel
22:42:46 <blargeyfarg> sm: it hits loopInput when a non-quit key is pressed
22:43:02 <sm> right
22:43:16 <sm> once, at the start of the level >
22:43:17 <sm> ?
22:43:29 <blargeyfarg> sm: oops.  right....
22:44:16 <sm> ah I get it.. this code is pre-monads
22:44:17 <blargeyfarg> sm: line 121 reads the input with a delay of 100
22:44:37 <blargeyfarg> sm: if a key is repeating, you probably skip that delay
22:44:46 <adu> i need help
22:44:47 <hpaste>  adu pasted "Toggle IORef" at http://hpaste.org/5789
22:44:54 * sm thinks or not.. nm
22:45:22 <sm> blargeyfarg: ah right.. if there is a key, it returns right away
22:45:53 <sm> it needs a speed-adjusting delay thingy, like all games
22:45:53 <scook0> adu: record labels aren't first-class, sadly
22:46:05 <scook0> so e {field = (not f)} won't work
22:46:08 <adu> scook0: oh, that would explain it
22:46:27 <biouser> shoo, my record label be mad first-class dawg (sorry)
22:46:30 <adu> scook0: any ideas?
22:46:47 <scook0> sorry, I have to run :/
22:46:50 <adu> ok
22:47:24 <adu> biouser: what?!? really :)
22:47:31 <blargeyfarg> adu: toggle takes an IORef G, but you're passing a simple G
22:48:02 <blargeyfarg> adu: see newIORef
22:48:19 <adu> oh, oops, I did use newIORef in the complicated version
22:48:32 <adu> thats a side-effect of my refactoring
22:49:12 <dons> if you guys are hacking the code, is it on code.haskell.org? do you have a repo?
22:49:20 <dons> would be good to have the code polished up while eyes are on it
22:49:32 <adu> oooo can I put my eyes on it?
22:50:12 <dons> ?remember biouser my record label be mad first-class dawg
22:50:12 <lambdabot> I will never forget.
22:51:29 <biouser> thank you, thank you, I'll be here all week, remember to tip your bartender...
22:55:15 <adu> I understand now that record labels are not first-class, but is there a reason for this?
22:55:44 <bos> it was easy to do.
22:56:16 <Twey> Huh?
22:56:27 <Twey> A non-first-class function?
22:56:35 <Twey> Is that even possible in Haskell?
22:56:41 <dons> like the module system, the easy implementation was chosen
22:57:12 <adu> so if I wanted a first-class label I would have to do "data ... = C { label :: Bool }" then "setLabel g b = g {label = b}"?
22:57:23 <bos> adu: yes
22:57:27 <adu> boo
22:57:49 <adu> and "getLabel g = label g"?
22:58:00 <bos> no need for that.
22:58:03 <dons> no, accessors work
22:58:08 <adu> oh ok
22:58:13 <Twey> So you can't map label (listOfItems) ?
22:58:18 <adu> then I'm only half-sad :/
22:58:37 <dons> Twey: sure.
22:59:04 <Twey> Hm.
22:59:26 <Twey> So it's these braces that aren't first-class?
22:59:29 <adu> I guess I was thinking the accessors weren't working because I was using them one line above the setter, and I didn't read the line numbers correctly on the compiler errors :)
22:59:48 <Twey> map label ({label = "foo"}) listOfItems?
23:01:45 <adu> hmm, doesn't work
23:01:47 <hpaste>  blargeyfarg annotated "Toggle IORef" with "simple working example of your toggle" at http://hpaste.org/5789#a1
23:02:04 <adu> yey!
23:02:54 <adu> oic
23:03:08 <adu> you just constructed a whole new G
23:03:13 <adu> thats one way
23:04:13 <adu> is "let f = field e" valid haskell? i thought that was GHC-special?
23:05:13 <blargeyfarg> i was under the impression it was valid Haskell 98, although i'm not a language lawyer.  i just use the stuff ;)
23:05:15 <quicksilver> adu: no, that's valid haskell.
23:05:28 <quicksilver> the field defines an accessor.
23:05:34 <adu> ok
23:06:04 <adu> well, I learned about the semantics of "{f=e}" today :)
23:06:25 <quicksilver> Twey: when people say "labels aren't first class" they mean you can't write something like : modify rec lab newval = rec { lab = newval }
23:06:35 <quicksilver> Twey: you can't abstract over labels
23:07:33 <dons> you can't store them in structures, or pass them as arguments. they're just not values
23:08:00 <quicksilver> (well, annoyingly they *are* values, just not the right sort)
23:08:07 <quicksilver> (they're selector functions, which isn't general enough)
23:08:12 <adu> but I thought it was just said that accessors are first-class?
23:08:32 <dons> right. you get a normal function to use as an accessor.
23:09:02 <scook0> it's similar to how data constructors aren't first-class (but they are first-class functions)
23:09:38 <adu> lol, I'm so confused... that its starting to make sense
23:09:59 <mountain_> Any body know  about something more about design and analysis methodology which support FP? Just read one article FAD: A Functional Analysis and Design Methodology by Dan Russell
23:10:25 <Twey> quicksilver: Oh!  I see!
23:10:35 <Twey> That makes sense.
23:10:36 <dons> mountain_: hmm. interesting. what are you interested in? what kind of analysis?
23:12:50 <mountain_> I am a newbie for Haskell, but an OO practitioner for several years. So I just want to found the counterpart for OOA and OOD in FP.
23:14:12 <dons> I'm not sure there's been much work on encoding the functional programming "best practices". there's a great deal of folklore. perhaps someone on the mailinglist might know?
23:14:15 <wy> I'll digress again... anyone has used CUP for a parser?
23:14:23 <adu> mountain_: I don't know, but lots of people I talk to recommend SICP
23:14:40 <wy> adu: over what?
23:15:06 <adu> wy: for a functional methodology?
23:15:12 <Twey> mountain_: Errr, we have records.
23:15:20 <Twey> :-)
23:15:22 <sm> does PLT's HtDP count ?
23:16:08 <sm> that teaches analysis & design, IIRC
23:16:11 <wy> sm: It is a little in too much details and specific to PLT scheme I think
23:16:34 <wy> adu: SICP is quite good
23:17:01 <adu> wy: I new SICP must have been recommended for a reason :)
23:17:06 <wy> adu: Some of the contents can't be found in any other books
23:17:15 <mountain_> SICP seems to be too theoretical for a practitioner....
23:17:25 <brailsmt> mountain_: don't try to fit OO onto functional without a firm understanding of both
23:17:25 <adu> whats a practitioner?
23:18:00 <mountain_> software developer in general
23:18:12 <wy> A Little Java, A Few Patterns seems to be good fit of OO to FP
23:18:35 <jre2> do you mean code monkey?
23:18:41 <brailsmt> lol
23:18:52 <adu> mountain_: so whats the difference between a software developer, and someone who knows how to write in a functional language?
23:19:21 <wy> concentrate only on what practitioners do, and you will be only the average programmer
23:19:23 <dons> so hmm, a practical introduction to the basic design methods of FP programming?
23:19:38 <dons> we should have such a think. there's a lot of folklore out there that could be collected
23:19:54 <jre2> adu: when one interviews me, he doesn't ask how I think the mathematics of my Math/CS degree will help
23:19:55 <dons> there's the "functional pearls", which represent the essence of beautiful design, http://haskell.org/haskellwiki/Research_papers/Functional_pearls
23:19:59 <adu> I'm reading SICP right now, I love the Forward :)
23:20:11 <mountain_> ok, thanks
23:20:22 <brailsmt> the switch from OO to FP is at least as jarring as from procedural to OO
23:20:34 <adu> jre2: I love math
23:20:40 <wy> adu: yes. I'm attracted by the forward too
23:20:58 <brailsmt> what is SICP?
23:20:58 <glguy> How do I open a fifo and listen on it until someone writes to it?
23:21:08 <adu> http://mitpress.mit.edu/sicp/full-text/book/book.html
23:21:09 <lambdabot> Title: Structure and Interpretation of Computer Programs
23:21:21 <dons> glguy: mkfifo, then wait on the Handle
23:21:36 <dons> we should have something in the unix package
23:22:12 <blargeyfarg> going a little off beat, "Text Processing in Python" did a great job of embedded a great many functional idioms in an otherwise OO landscape, which might help (or confuse the hell out of) a newcomer
23:22:17 <wy> Who's Strachey?
23:22:59 <wy> hey again. I always find the best solution to Java problem in #haskell ;)
23:23:16 <blargeyfarg> aren't all solutions in #haskell?
23:23:53 <scook0> real *and* complex
23:23:58 <brailsmt> all solutions are in hitchhiker's guide
23:24:12 <wy> Hey, anybody knows how to use Java CUP? I can't get any reply from ##java
23:24:25 <quicksilver> brailsmt: FWIW, I found FP much easier than OO.
23:24:36 <wy> brailsmt: 42?
23:25:04 <quicksilver> brailsmt: the jump from C++/Java/Perl/Python to ML/haskell seemed like a breath of fresh air, while the jump from C/Pascal to C++ was a nightmare, for me.
23:25:13 <blargeyfarg> quicksilver: i'd almost agree.  i also found the FP foundation simple and beautiful, but like mountain_, i've had a hard time developing a mind for large scale design
23:25:18 <quicksilver> Of course, I was younger for the latter than the former which could be related.
23:25:26 <mountain_> In fact, I mean the situation when you face hundreds or maybe thousands functions and types, how can you manage the complexity?
23:25:44 <dons> mountain_: modules, purity, strong typing. polymorphism
23:25:45 <quicksilver> mountain_: The key commonality is that you still think about designing data types and the functions that operate on them.
23:25:49 <dons> ah, so now i know what to recommend you.
23:25:57 <brailsmt> quicksilver: the jump from Pascal to Java was tough, from C++ to scheme was brutal for me
23:26:04 <dons> this paper: http://www.cs.kent.ac.uk/pubs/1997/224/index.html
23:26:05 <lambdabot> Title: Computer Science: Publication: Higher-order + Polymorphic = Reusable
23:26:08 <dons> "Higher-order + Polymorphic = Reusable"
23:26:10 <quicksilver> mountain_: in OO you design new classes + their methods. In FP you design new types and functions.
23:26:17 <wy> quicksilver: I never understood C++ and Straustrup said he didn't expected anybody to fully understand it
23:26:20 <quicksilver> It's not all that different but the encapsulation is different.
23:26:28 <brailsmt> once I "got it" then it was beautiful
23:26:45 <dons> mountain_: the other key motivation is, http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
23:27:00 <quicksilver> wy: I believe I understood C++ but that's actually not what I meant. I meant understanding OO programming paradigms (observer, notifier, event hierarchies, and so on)
23:27:15 <mountain_> "Higher-order + Polymorphic = Reusable" seems interesting, I will have a look, thanks
23:27:18 <dons> if you read both those, i think you'll get a reasonable overview of what the core design methods are: purity, types, encapsulation, polymorphism
23:27:19 <quicksilver> wy: understanding a modern medium-to-large class library and how they fit together.
23:27:28 <wy> quicksilver: I believe the best OO practice is in CLOS
23:27:36 <adu> ack I can't access any of these Kent papers
23:27:48 <dons> mountain_: them absolute key thing is purity though -- no side effects, no side channels, predictable behaviour.
23:27:54 <dons> that's how code scales up to the very large.
23:28:07 <dons> and with strong typing you can be sure codes going to work
23:29:09 <dons> purity basically forces you to cut down complexity -- no side channels of information, by default
23:29:17 <dons> so interfaces stay simpler, cleaner and more predictable
23:30:09 <glguy> dons: I've pushed a patch against the bot
23:30:13 <adu> mountain_: from what I've seen, FP and OO are both using the same idoms but are each special cases of an even bigger methodology that no one in the world understands enough to write a book about it yet ... ;)
23:30:15 <glguy> going for a bit more structure
23:30:34 <glguy> (not quite ready yet, haven't fixed the fifo or split out the database access)
23:30:43 <wy> quicksilver: I don't know any of these. I only know about visitor... that's ugly
23:30:48 <sm> how would I get the unix clock time as an integer ? the nearest I've found is getPOSIXTime which gives a NominalDiffTime
23:30:54 <dons> adu, well its all encapsulation and separation, basically. now, isn't that purity + existential types? or pretty close to it :)
23:31:25 <dons> sm: getClockTime ?
23:31:39 <wy> I guess the worst thing in OO is that they insist objects owns the methods
23:31:52 <adu> dons: what do you mean by "existential types"?
23:32:19 <dons> types hiding representation details.
23:32:20 <wy> again, anyone is willing to safe a poor guy from the java world?
23:32:41 <wy> dons: Isn't that OO?
23:32:45 <jre2> http://www.haskell.org/haskellwiki/Existential_types
23:32:46 <dons> so combine that with some polymorphic structures, and you get lovely reusable code
23:32:47 <lambdabot> Title: Existential type - HaskellWiki
23:32:57 <sm> huh.. thanks dons
23:33:09 <dons> wy, that's the OO contribution, you've then got to add purity and polymorphism to that. stir well
23:33:20 <dons> and higher order stuff.
23:33:54 <wy> dons: yeah. I guess existential is something like a collection with an interface?
23:34:08 <quicksilver> existential types don't come from OO
23:34:14 <quicksilver> they're analagous to an OO concept, that's all
23:34:39 <sm> System.Time seems to be deprecated ? that's why I didn't find it at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
23:34:45 <quicksilver> they're a natural FP concept in their own right.
23:34:55 <quicksilver> sm: yes, deprecated in favour of Data.Clock.Time
23:35:24 <wy> quicksilver: It's hard to say who borrowed who, but it seems lots of FP people worked for Java for sometime
23:35:45 <sm> still trying to get an integer.. I guess I could read $ show $ ..
23:35:55 <wy> for example Wadler
23:37:25 <wy> Are recursive descent parsers faster than the table driven ones?
23:37:25 <oerjan> sm: actually it is still there...
23:37:47 <yondalf_> > getCurrentTime
23:37:58 <lambdabot>   Not in scope: `getCurrentTime'
23:38:45 <sm> I agree getCurrentTime is bound when you import Data.Time.Clock.. I wonder why it prints nothing when I call it in ghci though
23:39:36 <oerjan> sm: do you have ghci set to print the result of IO actions?
23:39:51 <sm> probably not
23:39:56 <blargeyfarg> i get a "no instance for show" for UTCTime
23:40:29 <blargeyfarg> although it's documented as being an instance
23:40:37 <oerjan> sm: print =<< getCurrentTime should work if the Show instance is in scope
23:40:46 <Cale> That's interesting.
23:40:46 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
23:41:02 <Cale> blargeyfarg: You might just try the formatTime function.
23:41:13 <yondalf_> sm: you can use floor to convert the NominalDiffTime into an integer
23:41:17 <oerjan> i seem to recall some Show instances were hidden away in a Format module
23:41:23 <sm> yondalf_: thanks
23:41:33 * sm just trying to slow down space invaders
23:42:11 <oerjan> sm: have you tried threadDelay?
23:42:23 <oerjan> @index threadDelay
23:42:24 <lambdabot> GHC.Conc, Control.Concurrent
23:42:31 <sm> no, thanks for the tip
23:42:32 <blargeyfarg> Cale: having Data.Time.Format in scope resolves it
23:42:52 <Cale> blargeyfarg: heh
23:43:40 <sm> yondalf_: would you know how exactly ? floor getPOSIXTime doesn't do it.. perhaps a type signature ?
23:44:21 * glguy was using (`div` cpuTimePrecision) `fmap` getCPUTime
23:44:45 <sm> blargeyfarg, Cale: aha, yes - after importing Data.Time.Format, ghci> getCurrentTime prints a result
23:44:56 <yondalf_> getPOSIXTime is of type IO PosixTIME or something like that right?
23:45:01 <yondalf_> you'll have to do it within the IO monad
23:45:10 <yondalf_> @hoogle getPOSIXTime
23:45:11 <lambdabot> Data.Time.Clock.POSIX.getPOSIXTime :: IO POSIXTime
23:45:15 <sm> yes, I'm in IO
23:45:16 <Cale> The instance of Show must be in that module rather than in the module where UTCTime is defined.
23:45:38 <yondalf_> so do { a <- getPOSIXTime; putStrLn (show (floor a)) }
23:45:39 <sm> yondalf_: it complains: No instance for (RealFrac (IO POSIXTime))
23:46:00 <yondalf_> sm: yes, refer to my code...getPOSIXTime is a "computation"
23:46:28 <adu> numeric types are so painful
23:46:38 <yondalf_> so you'll have to use the "<-" to get the value out
23:47:01 <blargeyfarg> sm: print . floor =<< getPOSIXTime     should work from ghci
23:47:18 <Cale> adu: They're not too bad once you know what the basic classes mean.
23:47:27 <sm> I see, thanks
23:47:42 <wy>  I'm dying of CUP
23:47:59 <sm> I missed the fact that IO was the problem, not RealFrac
23:48:12 * wy is dying...
23:48:41 <Cale> wy: CUP?
23:48:56 <yondalf_> CUP is the java equivalent of bison :-P
23:48:56 <wy> Cale: An Java parser generator
23:49:06 <Cale> Ah, I've used that.
23:49:21 <wy> Cale: uhh... good. Hope you remember something for it
23:49:37 <Cale> Heh, not a whole lot.
23:49:47 <wy> currently I can't get the method getSymbolFactory() found
23:50:12 <wy> but actually it's in the generated parser class's parent class lr_parser...
23:50:13 <jre2> if I have a thread constantly checking a handle for data, eg. 'forever $ do {hasData <- hReady h; if hasData then doStuff else threadDelay 100}' is there a better way to be responsive (wrt. that thread) yet not hogging time from other threads?
23:51:01 <adu> Cale: if its not too bad, then why is 'atan2' in with IEEE754 instead of with 'atan' in 'Floating'?
23:51:20 <yondalf_> jre2: in the c-like world we would use select if we wanted functionality like that
23:51:37 <yondalf_> @hoogle atan2
23:51:38 <lambdabot> Prelude.atan2 :: RealFloat a => a -> a -> a
23:51:41 <yondalf_> @hoogle atan
23:51:41 <lambdabot> Prelude.atan :: Floating a => a -> a
23:51:41 <lambdabot> Prelude.atanh :: Floating a => a -> a
23:51:41 <lambdabot> Prelude.atan2 :: RealFloat a => a -> a -> a
23:52:07 <wy> yondalf_: Is there something in Haskell that do the asynchronous thing?
23:52:17 <adu> the functions are so bad, but the type-classes suck
23:52:17 <yondalf_> @hoogle select
23:52:18 <lambdabot> No matches found
23:52:22 <Cale> adu: In order to handle things with negative zero correctly.
23:52:51 <wy> Of course not this name, because it is so bad ;)
23:53:04 <adu> Cale: then why isn't (/) in RealFrac?
23:53:30 <wy> Cale: any ideas?
23:53:39 <Cale> The prelude has a default definition of atan2 so that when you write instances you don't have to define it by hand.
23:53:49 <Cale> But in order to do that, you need isNegativeZero.
23:54:41 <Cale> It could be moved to Floating, but without a default definition.
23:54:45 <xpika> how can I number the elements in  a tree?
23:55:03 <Cale> wy: I have no idea. It was years ago.
23:55:15 <Cale> xpika: In what order?
23:55:25 <Cale> xpika: and what kind of tree?
23:55:30 <yondalf_> wy: hmm...i have no idea what the select equivalent in haskell is
23:55:47 <xpika> Node x []
23:55:48 <adu> yondalf_: select as in SQL?
23:55:57 <Cale> jre2: Probably blocking on an MVar
23:56:08 <Cale> adu: No, select as in C
23:56:10 <yondalf_> adu: no...select as in the posix call
23:56:16 <radetsky> adu: man 2 select
23:56:20 <wy> Cale: I guess it's some stupid mistake in the way I use the runtime library
23:56:51 <Cale> wy: I see some comments on google that it might have something to do with build order, but nothing very clear.
23:57:19 <xpika> cale: Preorder traversal
23:57:30 <wy> Cale: I wish the course is in Haskell... so that I can use Parsec or role my own
23:57:56 <Cale> xpika: Okay, so  data Tree a = Node a [Tree a]
23:58:14 <xpika> Cale: yep
23:58:18 <Cale> xpika: and you want something like  relabel :: Tree a -> Tree Integer ?
23:58:26 <wy> I guess most of the work of the course is on dealing with various quirks of the tools and languages
23:58:42 <xpika> seems quite a imperative problem
23:58:59 <oerjan> xpika: if you make a Data.Traversable instance you can use a monadic solution
23:59:06 <Cale> xpika: You can do it recursively, but the simple State Integer monad will be enough to help with the parameter passing.
23:59:12 <quicksilver> wy: most of these ideas predate java by some decades
23:59:26 <xpika> oerjan: Tree has an instance for Traversal
23:59:33 <quicksilver> wy: existential types existed some 20 years before the word 'object' had a CS connotation, I believe.
23:59:39 <quicksilver> probably more.
23:59:42 <xpika> oerjan: I just don't know how to use the right function
23:59:47 <oerjan> xpika: ah.  then it should be just StateT Integer use
23:59:56 <wy> quicksilver: yes. maybe even longer... in logic ;)
