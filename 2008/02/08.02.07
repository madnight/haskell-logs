00:00:04 <Korollary> http://reddit.com/info/67wdl/comments/c0341hl
00:00:10 <Korollary> there
00:00:18 <sclv> loeb in general is pretty terribly inefficient if you don't need the whole structure recursively defined.
00:00:32 <sclv> its more a neat hack than anything else...
00:02:27 <sclv> also it works on collection functors but i don't see it being able to translate to something nifty with contT or whatever because you can't do a loebM... too bad.
00:04:04 <ski> continuations ?
00:05:09 <ski> sclv : why should it be related with `ContT' ?
00:05:45 <sclv> it was just an example... the one really useful thing i was thinking about was that it might be a nice way to generalize some aspects of common memo idioms.
00:08:12 <dolio> What would loebM be?
00:08:46 <dolio> What type, that is?
00:09:59 <ski> loebM :: (Monad m,MFunctor m f) => f (f a -> m a) -> m (f a)  -- i seem to have scribbled down, for some reason
00:10:16 <dolio> Ah, okay.
00:11:15 <ski>   class Monad m => MFunctor m f
00:11:19 <ski>     where
00:11:21 <ski>     fmapM :: (a -> m b) -> (f a -> m (f b))
00:11:37 <ski> (i have no idea whether this would be reasonable)
00:12:06 <bd_> hmm
00:12:12 <bd_> there's got to be a class for that already
00:12:31 <ski> probably Traversable or relative ..
00:12:42 <bd_> ah yes, Data.Traversable.mapM
00:12:49 <bd_> mapM :: Monad m => (a -> m b) -> t a -> m (t b)
00:13:08 <ski> @type Data.Traversable.mapM
00:13:10 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
00:13:46 <dolio> There used to be FunctorM, too, but that got dropped in favor of Traversable.
00:13:54 <dolio> Although it's packaged up on hackage.
00:14:15 <sclv> finally read okasaki's thesis today. we had some internet downtime at work. :-)
00:14:38 <sclv> i'm shocked now at how little foax use the edison structures when they'd come in handy.
00:16:38 <ski> does anyonw know why we need `mapM' in addition to `traverse' in `Traversable' ?
00:17:14 <ski> (only because `Applicative' is not superclass of `Monad' .. or any more valid reason ?)
00:21:19 <ski> (another thing i wonder is whether we really need all those members of `Foldable' as *members* of the class ..)
00:21:34 * ski -> off
00:21:52 <dolio> I think traverse vs. mapM is because of the class hierarchy.
00:22:55 <dolio> The Foldable options are there in case one is easier to implement than another (or more efficient than using defaults) I think.
00:23:12 <dolio> Same with sequence vs. mapM in Traversable.
00:49:02 <sm> evening all
00:49:34 <sm> what is this mysterious import Paths_darcs_monitor ? There's no such module
00:50:22 <sm> ghc builds it, but ghci won't run it
00:52:02 <sm> I guess it's a cabal thing
00:52:21 <faxathisia> good afternoon
00:54:25 <sm> good afternoong
00:54:33 <oerjan> good mourning
00:54:52 <sm> yay, symlinking it from dist/build/autogen works
00:55:00 <Vq^> morning Ã˜rjan, afternoon sm
00:55:09 <vincenz> Vq^: he's mourning
00:55:25 <Vq^> oh, i misread :)
00:56:03 <Vq^> but i believe Ã˜rjan lives in GMT+0 or GMT+1 so it should be about morning there ;)
00:56:29 <faxathisia> I found what looks like a bit more advanced version of LambdaPi http://sneezy.cs.nott.ac.uk/darcs/LambdaPi/
00:56:30 <lambdabot> Title: Index of /darcs/LambdaPi
00:56:32 <oerjan> LIES, i tell ye
00:56:36 <opqdonut> morning
00:56:41 <opqdonut> from GMT+2
00:56:47 <faxathisia> there's various code there too
00:57:23 <vincenz> morning is a good enough reason for mourning
01:01:32 <faxathisia> Would be nice if there was WYSIWYG editors for lhs
01:01:47 <faxathisia> TeX embedded lhs..
01:01:56 <opqdonut> hmm
01:08:22 <faxathisia> lhs2TeX is neat.. software that actually worked
01:09:35 * faxathisia (used to having to patch makefiles etc.. on all this unixy software)
01:11:30 <ivan_> hi i want to sort a list of type [(Int,Color,Line)] according to Int, is there a haskell funk that does this for me?
01:11:59 <oerjan> sortBy (comparing (\(x,_,_) -> x))
01:12:14 <ivan_> thx =)
01:12:17 <kosmikus> faxathisia: nice to hear that it works for you, may I assume you tried 1.13pre3 ?
01:12:40 <faxathisia> Yes
01:13:15 <kosmikus> great
01:13:32 <kosmikus> I should probably just turn it into 1.13
01:16:36 <dolio> @type let loebM x = Data.Traversable.mapM (loebM x >>=) x in loebM
01:16:36 <lambdabot> forall (t :: * -> *) b (m :: * -> *). (Data.Traversable.Traversable t, Monad m) => t (t b -> m b) -> m (t b)
01:28:22 <dolio> @pl \v -> walk (\f a -> v (False, f, a))
01:28:22 <lambdabot> walk . (. (,,) False) . (.)
01:35:56 <catface> noob q: can i read a file as a lazy list somehow?
01:36:10 <ac> ok, mismatches between similar types annoy me, especially when I can't figure out where they're coming from
01:36:25 <ac> (like Int and WordX)
01:39:29 <ac> a mismatch between [a] and a I can figure out...
01:39:29 <quicksilver> catface: yes, readFile or hGetContents does that
01:39:53 <quicksilver> ac: Int tends to come from builtins like length, take, drop, and so on
01:39:57 <quicksilver> in my expereince
01:40:16 <ac> yeah, I have a few genericLength and genericDrops around
01:40:45 <quicksilver> fromIntegral . drop may be more efficient than genericDrop
01:40:50 <quicksilver> althought I'm not 100% sure
01:47:19 <ac> quicksilver: thing is, I actually want the genericness, because there MAY be an occasion where I'm dealing with a larger than (maxBound :: Int) length list
01:47:51 <quicksilver> ac: hmm. Are you sure that's wise.
01:48:02 <quicksilver> ac: it takes a long time to calculate the length of a list that long :)
01:48:05 <ac> no. and there's probably an Int type in there somewhere that would break such extreme conditions
01:48:15 <ac> quicksilver: it would be a GINORMOUS image
01:48:36 <ac> quicksilver: I'm still working on my image library project
01:48:54 <quicksilver> genericLength would require around 24*4GB = 96GB of memory minimum
01:49:00 <ac> lol
01:49:07 <quicksilver> so that woudln't really work
01:49:11 <quicksilver> genericDrop could be useful though
01:49:17 <quicksilver> since it could be generated lazily
01:49:34 <quicksilver> in fact genericLength is completely useless
01:49:42 <ac> it is theoretically a possibility that you'd want to save 1GB images, but not 100GB images
01:49:44 <quicksilver> since on a machien that big, Int would be 64 bit by definition
01:49:54 <quicksilver> and then you could just use length
01:50:19 <ac> heh. I'm using genericLength because I'm too lazy to add fromIntegral I guess
01:50:23 <dolio> genericLength isn't useless if you use it to produce a lazy natural, no?
01:50:53 <dolio> Since then it doesn't force the list you're taking the length of.
01:50:53 <ac> dolio: lazy natural numbers don't make sense
01:51:04 <opqdonut> why not?
01:51:12 <opqdonut> data Nat = Zero | Succ Nat
01:51:25 <ac> opqdonut: yes, unless they're Church Numerals. Very funny
01:51:27 <dolio> They have uses.
01:51:55 <opqdonut> for example testing (>=k) evaluates only k levels of constructors
01:52:23 <opqdonut> so (>=3) . genericLength would work and be efficient even for infinite lists
01:52:46 <ac> interesting
01:52:59 <dolio> Also, consider chopping the last n elements off a list.
01:53:27 <opqdonut> yep, that would also work neatly
01:53:29 <ac> why not just say (>=3) . length . take ?
01:53:50 <opqdonut> ac: well yeah that'd work also
01:54:00 <opqdonut> but not for dolio's example
01:54:01 <quicksilver> they have uses but they're very rare
01:54:04 <quicksilver> frankly
01:54:09 <opqdonut> yes, of course
01:54:16 <opqdonut> but there are uses nonetheless
01:54:19 <quicksilver> lazy '<' being the canonical example
01:54:21 <ac> are they defined anywhere in the standard libs?
01:54:28 <faxathisia> pretty useful if you want to do induction
01:54:28 <dolio> Nope.
01:54:30 <quicksilver> but you can get lazy '<' easily enough with take and drop
01:54:41 <quicksilver> not . null . take 3
01:54:47 <quicksilver> is a lazy length > 3
01:55:06 <opqdonut> >  not . null . take 3 $ [1,2]
01:55:06 <lambdabot>   lexical error (UTF-8 decoding error)
01:55:12 <opqdonut> > not . null . take 3 $ [1,2]
01:55:12 <lambdabot>   lexical error (UTF-8 decoding error)
01:55:14 <opqdonut> huh
01:55:20 <faxathisia> > not . null . take 3 $Â [1,2]
01:55:20 <lambdabot>  True
01:55:23 <quicksilver> > not . null . take 3 $ [1,2]
01:55:24 <lambdabot>  True
01:55:32 <faxathisia> heh.. stragne
01:55:40 <opqdonut> quicksilver: isn't that just "not.null"?
01:55:54 <opqdonut> you want "not.null.drop 2.take 3"
01:55:55 <quicksilver> I think I meant drop 3 :P
01:55:58 <opqdonut> ah
01:56:01 <opqdonut> indeed
01:56:07 <quicksilver> > not . null . drop 3 $ [1,2]
01:56:08 <lambdabot>  False
01:56:08 <opqdonut> lunchtime->
01:56:13 <quicksilver> better :)
01:56:48 <wagle_home> > not . null . drop 3 $ [1..]
01:56:49 <lambdabot>  True
01:57:09 <quicksilver> ac: basically because all lists are lazy naturals of their own length
01:57:16 <quicksilver> ac: just ignore the actual contents :)
01:57:26 <ac> no, I got the jist of that
01:57:31 <quicksilver> ac: and then use 'drop' and 'null' as your tools instead of < and >
01:57:37 <ac> quicksilver: yeah
01:57:37 <wagle_home> which natural is [0..]?
01:57:43 <wagle_home> which natural is [1..]?
01:57:48 <quicksilver> fix Succ
01:57:53 <quicksilver> which is a haskell lazy natural :)
01:57:57 <quicksilver> although not a maths Natural
01:58:29 <wagle_home> > fix Succ 0
01:58:29 <lambdabot>   Not in scope: data constructor `Succ'
01:58:39 <quicksilver> fix Succ wouldn't take parameters
01:58:44 <quicksilver> fix Succ :: Nat
01:58:45 <faxathisia> > fix Just
01:58:46 <lambdabot>      Occurs check: cannot construct the infinite type: a = Maybe a
01:58:46 <lambdabot>       Expe...
01:58:51 <wagle_home> > fix (+1) 0
01:58:52 <lambdabot>   add an instance declaration for (Num (t -> a))
01:59:04 <vincenz> wagle_home: fix doesn't take an input
01:59:07 <wagle_home> > fix (+1) (0::Int)
01:59:07 <vincenz> > fix (+1)
01:59:08 <lambdabot>   add an instance declaration for (Num (Int -> a))
01:59:08 <lambdabot>  Exception: <<loop>>
01:59:15 <vincenz> wagle_home: fix is (a -> a ) -> a
01:59:18 <wagle_home> :t fix
01:59:19 <vincenz> wagle_home: it does not take an input a
01:59:19 <lambdabot> forall a. (a -> a) -> a
01:59:21 <faxathisia> > fix (1:)
01:59:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:00:02 <vincenz> > fix (\l -> 1:1:zipWith (+) l (drop 1 l))
02:00:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
02:00:06 <wagle_home> fix (+1)
02:00:10 <vincenz> boom
02:00:13 <wagle_home> f> ix (+1)
02:00:15 <quicksilver> *Main Control.Monad.Fix> fix Succ
02:00:15 <quicksilver> Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ
02:00:19 <quicksilver> there you go
02:00:23 <wagle_home> > fix (+1)
02:00:24 <lambdabot>  Exception: <<loop>>
02:00:24 <vincenz> > fix quicksilver
02:00:25 <lambdabot>   Not in scope: `quicksilver'
02:01:19 <faxathisia> What are generalised GADTs?
02:01:34 <dolio> Twice generalized?
02:03:19 <wagle_home> > fix mybug
02:03:20 <lambdabot>  "done"
02:03:50 <viklund> @seen masak
02:03:50 <lambdabot> I saw masak leaving #perl6 and #haskell 7d 16h 12m 17s ago, and .
02:06:20 <faxathisia> You can make a GUI program in haskell that depends only on XMonad? (and no OS specific stuff?)
02:07:29 <quicksilver> XMonad is a window manager
02:07:35 <quicksilver> not a graphics library
02:07:45 <ac> hey, there actually is a reason for genericLength
02:07:51 <ac> > maxBound :: Int
02:07:52 <lambdabot>  2147483647
02:08:22 <ac> that's only 2G
02:08:45 <wagle_home> >maxBound :: Double
02:08:46 <ac> > maxBound :: Word32
02:08:47 <lambdabot>  4294967295
02:09:09 <wagle_home> > maxBound :: Double
02:09:10 <lambdabot>   add an instance declaration for (Bounded Double)
02:09:10 <lambdabot>     In the expression: max...
02:09:41 <dolio> That's 2G if a list takes 1 byte per element.
02:09:51 <dolio> Which is being very optimistic.
02:10:00 <ac> ah, I guess you're right, even if it's a [Word8]
02:10:04 <quicksilver> not so much optimistic, as foolish :P
02:10:16 <wagle_home> > [0..(maxBound :: Word32)]
02:10:17 <ac> I'm not writing C am I?
02:10:18 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:10:29 <dolio> It's optmistic even for [Bool]. :)
02:10:33 <quicksilver> GHC lists take a minimum of 16 bytes per elt, afaik
02:10:38 <wagle_home> > reverse [0..(maxBound :: Word32)]
02:10:40 <lambdabot> Terminated
02:10:45 <wagle_home> aww
02:10:47 <doserj> the list might be fused away, though
02:11:06 <wagle_home> > reverse [0..(maxBound :: Int)]
02:11:08 <lambdabot> Terminated
02:11:09 <doserj> but counting from 0 to 2^31 takes time
02:11:22 <ac> well, unless I screwed up, there should never be a list with more than 1 scanline worth of pixels
02:11:28 <ac> in memory at once
02:11:41 <wagle_home> :t last
02:11:42 <lambdabot> forall a. [a] -> a
02:11:55 <wagle_home> > last [0..(maxBound :: Int)]
02:12:01 <ac> (and yes, I probably screwed up, but I'll optimize it later)
02:12:01 <lambdabot> Terminated
02:12:33 <MarcWeber> dcoutts: Have you already noticed that all packages are lower case now (but Cabal). Is this intentionally?
02:12:49 <ac> I think a Haskell programmer processes lists more than a LISt Processor programmer
02:12:54 <dcoutts_> MarcWeber: not all packages are lower case
02:13:56 <faxathisia> > do print "aoe" ; return ()
02:13:57 <lambdabot>  <IO ()>
02:14:17 <faxathisia> .. I'm confused by this, Why does it not return ()?
02:14:31 <faxathisia> when I run it, all that happens is that "aoe" is printed
02:14:54 <MarcWeber> Mmh right. Most core libs (ghc) are
02:14:55 <wli> > (minBound :: Int, maxBound :: Int)
02:14:55 <lambdabot>  (-2147483648,2147483647)
02:15:18 <dcoutts_> MarcWeber: it's ok for package managers to lowercase them all though since we try to ensure there are no clashes at the hackage level
02:15:20 <wli> > minBound + maxBound :: Int
02:15:21 <lambdabot>  -1
02:15:25 <faxathisia> do a <- (do print "aoe" ; return ()) ; return (1 , a) -- works though
02:15:51 <dcoutts_> MarcWeber: and ghc-pkg now warns if you register two packages that differ only in case
02:16:34 <quicksilver> faxathisia: it does return ()
02:16:42 <quicksilver> faxathisia: it's just that GHC doesn't think () is very interesting
02:16:48 <faxathisia> I see..
02:16:49 <quicksilver> faxathisia: so ghci doesn't display it :)
02:16:54 <faxathisia> That's really confusing
02:17:02 <faxathisia> Thanks though, that does make sense now
02:17:08 <quicksilver> ghci has a few different execution strategies
02:17:11 <mux> heh
02:17:11 <quicksilver> which are based on types
02:17:13 <mux> http://alum.wpi.edu/~tfraser/Software/Arduino/lambdacan.html
02:17:13 <lambdabot> Title: Project LambdaCan---Lambda Calculus in a Can
02:17:16 <quicksilver> if the type is Show a => a
02:17:19 <quicksilver> then it shows it
02:17:24 <quicksilver> if it's IO () then it executes it
02:17:34 <quicksilver> if it's Show a => IO a then it executes it and shows the result
02:17:42 <quicksilver> and if it's IO a it just executes it
02:17:49 <quicksilver> in, I think, that order of priority
02:17:51 <faxathisia> pretty bizarre :)
02:19:52 <faxathisia> hm...
02:20:05 <faxathisia> It's hard to embed an untyped language in a typed one..
02:20:28 <quicksilver> I wouldn't say that
02:20:54 <quicksilver> type Value = S String | N Integer
02:20:56 <quicksilver> etc
02:21:37 <wli> Discriminated unions pretty much do it.
02:23:55 <doserj> quicksilver: isn't that dynamically typed rather than untyped?
02:26:01 <quicksilver> maybe
02:26:09 <faxathisia> I want 'undefined' at the type level
02:26:10 <dolio> What qualifies as untyped? Something that only has bit strings?
02:26:17 <quicksilver> an untyped langauge might just be type Value = String
02:26:39 <faxathisia> untyped means: a = Just a works fine
02:26:41 <catface> > map chr [104,97,115,107,101,108,108,32,114,111,99,107,115,33]
02:26:42 <lambdabot>  "haskell rocks!"
02:27:45 <dolio> You mean, like, 'let a = Just a in ...' ?
02:29:05 <faxathisia> I just meant in general, It doesn't matter if you have infinite typed.. self evaluating lambda.. etc.. because there is no type checker to prohibit that sort of thing
02:29:28 <quicksilver> I don't think a = Just a is a very good example to be honest
02:29:31 <quicksilver> that's more about mutation
02:29:49 <quicksilver> in a dynamically typed language you can often mutate a var and change its type completely
02:29:56 <quicksilver> but that's more about mutation than it is about typing
02:29:59 <quicksilver> although the two tie up
02:30:56 <dolio> Well, you wouldn't usually have 'a = foo ; b = bar ; a = baz' and then end up with b being the same type as baz.
02:31:03 <Cale> Dynamic typing is a kind of 'untyped'
02:31:14 <dolio> Unless you have Smalltalk's become, or something.
02:31:40 <faxathisia> I just mean untyped as in.. I am dealing with an untyped lambda calculus
02:31:53 <faxathisia> I suppose it has a more general interpretation though
02:32:30 <quicksilver> in a simple untyped lambda calculus values are a bit fiddly
02:32:39 <quicksilver> really a value is just a term in normal form
02:32:59 <quicksilver> but that's not something you can mandate easily in a data type
02:33:06 <quicksilver> so you end up with a value just being a term, really
02:33:27 <quicksilver> data Term = Var String | Lambda String Term
02:34:18 <vincenz> quicksilver: don't forget App
02:34:38 <quicksilver> oh yeah :)
02:34:53 <quicksilver> that was left as an exercise for the reader
02:34:57 <faxathisia> hehe..
02:35:01 <vincenz> App String Term
02:35:11 <quicksilver> App Term Term ?
02:35:13 <vincenz> :P
02:35:13 <wli> App Term Ter,
02:36:27 <faxathisia> data Value = S String | N Integer | C (Cons Value Value)
02:36:32 <faxathisia> That's great...
02:37:14 <khadrin> > (1 :: Int) :: Num t => t
02:37:15 <lambdabot>   (1 :: Int)
02:37:15 <lambdabot>     In the expression: (1 :: Int) :: (Num t) => t
02:37:15 <lambdabot>     In the def...
02:37:36 <khadrin> why not? an Int is a Num
02:37:58 <khadrin> > (1 :: Num t => t)
02:37:58 <lambdabot>  1
02:38:14 <opqdonut> it can't be both a num and a (Num t => t)
02:38:21 <dolio> An Int is a particular Num, not something that can be any Num.
02:38:30 <opqdonut> and :: isn't a "cast"
02:38:34 <opqdonut> it's a type declaration
02:38:56 <khadrin> > (1 :: Num t => t) :: Int
02:38:57 <lambdabot>  1
02:39:32 <opqdonut> > :t (a::a)::String
02:39:32 <lambdabot>  Parse error at "::Str..." (column 10)
02:39:38 <opqdonut> > :t (a :: a) :: String
02:39:39 <lambdabot>  Parse error at "::" (column 13)
02:39:48 <opqdonut> > :t ((a :: a) :: String)
02:39:49 <lambdabot>   parse error on input `:'
02:39:51 <opqdonut> gah
02:39:52 <opqdonut> gha
02:39:56 <opqdonut> :t ((a :: a) :: String)
02:39:57 <lambdabot> Not in scope: `a'
02:39:59 <opqdonut> sorry for the spam
02:40:02 <opqdonut> and neverminf
02:40:07 <khadrin> its cool
02:40:14 <kosmikus> > :t (id :: a -> a) :: Int -> Int
02:40:14 <lambdabot>  Parse error at "::" (column 19)
02:40:29 <opqdonut> anyways, khadrin, you can always specialize but never generalize
02:40:36 <opqdonut> kosmikus: drop the "> "
02:40:36 <wli> data Value = Var String | LitInt Integer | LitChar Char | LitFloat Double | Lambda String Value | App Value Value ; predefined primitive operations and constructors are just prepopulated environments or some such.
02:40:44 <kosmikus> :t (id :: a -> a) :: Int -> Int
02:40:45 <lambdabot> Int -> Int
02:40:48 <kosmikus> ah
02:40:54 <kosmikus> :t (id :: Int -> Int) :: a -> a
02:40:54 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
02:40:55 <lambdabot>            against inferred type `Int'
02:40:55 <lambdabot>       `a' is bound by the polymorphic type `forall a. a -> a'
02:41:01 <kosmikus> that's the same situation
02:41:02 <vincenz> wli: use Lit Literal
02:41:07 <vincenz> wli: and a separate Literal
02:41:57 <khadrin> it doesnt make sense to generalize, or its just not supported ?
02:42:03 <wli> User-defined types and constructors are basically a different language layered atop it or beneath it depending on your POV.
02:42:41 <khadrin> for example it makes sense to me to declare a function that ju8st happens to always return Int as returning Num t => t
02:42:54 <wli> vincenz: Sure.
02:43:10 <wli> khadrin: Can't happen.
02:43:31 <khadrin> wli, but does it make sense?
02:44:01 <quicksilver> khadrin: no, that doesn't make sense
02:44:05 <quicksilver> khadrin: that's not what it means
02:44:16 <khadrin> hmm
02:44:19 <quicksilver> khadrin: A function of type Num t => t means "I will return a number of any type, and you get to choose"
02:44:20 <opqdonut> khadrin: use fromIntegral or somesuch
02:44:29 <wli> khadrin: No, if it's Num t => t then it's a value that's of any Num type.
02:44:31 <quicksilver> it doesn't mean "I will return a number of some type, and I get to choose"
02:44:32 <vincenz> quicksilver: he did choose: Int :)
02:44:42 <faxathisia> Is in only inside the IO Monad that you lose lazyness?
02:44:43 * quicksilver thwaps vincenz 
02:44:45 <vincenz> :P
02:44:57 <quicksilver> faxathisia: you don't lose lazyness anywhere.
02:45:04 <quicksilver> faxathisia: it's a universal property. What do you mean?
02:45:12 <wli> faxathisia: You can force values elsewhere.
02:45:25 <khadrin> quicksilver, oh that makes sense
02:45:43 <quicksilver> khadrin: the type you wanted is also sneisble, it's just not what Num t => t means
02:45:55 <quicksilver> khadrin: the one you were describing is called an 'existential' type
02:46:04 <quicksilver> not supported in Haskell98, although it is supported by GHC>
02:46:19 <quicksilver> an existential Num would not be all that useful though.
02:46:46 <khadrin> quicksilver, whats the ghc option? i dont see existential in the man page
02:47:15 <khadrin> yea, i wonder how i so totally misunderstood what Num t => t meant
02:47:15 <quicksilver> http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
02:47:16 <lambdabot> http://tinyurl.com/f9umb
02:47:17 <wli> -XExistentialTypes? NFI.
02:48:30 <dolio> ExistentialQuantification
02:48:58 <jedbrown> Regarding khadrin's earlier question, I have functions which could be polymorphic in the array type, with no performance hit.  It doesn't make sense to use them normally, but it does make sense to write rules for when the array type is explicitly coerced.
02:49:45 <khadrin> NFI ?
02:49:45 <khadrin> thanks for the help, i should be able to make progress again
02:53:26 <khadrin> jedbrown, did you have to write a fromArray function to make it work?
02:53:33 <wli> I wonder if there's some anti-defaulting business afoot.
02:55:19 <jedbrown> khadrin: Yes, I have a fromArray.  The point is that (fromArray . nonPolymorphicFunc = polymorphicFunc).  Using the polymorphic version by default is not good because you often have to add weird type annotations within your code.
02:56:00 <jedbrown> khadrin: Because the type needs to be defined, even at intermediate levels in a pipeline.
02:56:42 <Cale> http://www.mail-archive.com/haskell-cafe@haskell.org/msg03313.html -- ahaha
02:56:43 <lambdabot> Title: Re: Pascal Line in Haskell, http://tinyurl.com/23ho2r
02:57:19 <ivan_> how di u exclude a type from a module when i import it?
02:57:21 <jedbrown> khadrin: So if you have f :: (Num a, Num b) => a -> b, and g :: (Num a, Num b) => a -> b, then you can't write (f . g) without extra type annotations.
02:57:37 <quicksilver> Cale: heh. What brought that to your attention?
02:57:42 <Cale> ivan_: import MyModule hiding (TheType)
02:58:17 * wli doesn't get it.
02:58:48 <wli> It's just Pascal's triangle. Where's all this weird stuff coming from?
02:59:09 <khadrin> jedbrown, ok i follow
02:59:11 <opqdonut> :D
02:59:16 <opqdonut> wli: indeed
02:59:20 <Cale> wli: It's just that it's so obvious that the guy is asking for the answer to a homework question, and the response is this thoroughly insane piece of code :)
02:59:41 <Cale> quicksilver: Heh, I was looking around for a particular elegant one-liner for Pascal's triangle that I remember seeing.
03:00:18 <opqdonut> i think i remember one that uses scanl
03:00:30 <opqdonut> or something
03:00:36 <Cale> Yeah, what was that one?
03:00:51 <Cale> There's of course the obvious one with iterate, but that's not the one I'm looking for :)
03:01:24 <quicksilver> it would have been very funny if that guy had handed it in
03:01:30 <Cale> > let prow n = scanl (*) 1 (map (\k -> (n+1-k)/k) [1%1..n]) in map (map numerator . prow) [0..]
03:01:31 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
03:01:36 <Cale> There it is :)
03:02:05 <opqdonut> :)
03:02:47 * wli usually uses pascalTriangle = [1] : zipWith (zipWith (+)) (map (0:) pascalTriangle) (map (++[0]) pascalTriangle)
03:02:49 <Cale> Actually, I'm not sure I'm convinced that was the one I saw before.
03:03:28 <Cale> But perhaps it was :)
03:03:52 <dolio> You don't actually need 1%1, do you?
03:04:05 <wli> To make it Rational
03:04:06 <Cale> That just ensures that Rationals are used.
03:04:12 <Cale> er...
03:04:14 <dolio> numerator does that.
03:04:17 <Cale> > let prow n = scanl (*) 1 (map (\k -> (n+1-k)/k) [1..n]) in map (map numerator . prow) [0..]
03:04:18 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
03:04:21 <opqdonut> :)
03:04:24 <Cale> yeah, all right
03:05:29 <dolio> That's pretty nice.
03:06:50 <opqdonut> i think i like the recursive zip more
03:07:08 <opqdonut> tho Cale's is more efficient (even asymptotically i guess?)
03:07:16 <opqdonut> (esp. for generating only one row)
03:07:24 <quicksilver> I think wli's could be golfed quite nicely
03:07:32 <wli> golfed?
03:07:37 <quicksilver> duplication of map and pascalTriangle
03:07:57 <quicksilver> of course we all know the secret reason for Cale's (.) = fmap crusade is golf
03:08:02 <opqdonut> :D
03:08:16 <Cale> haha
03:08:25 <wli> I don't know what this golfing is.
03:08:27 <Cale> The thought hadn't crossed my mind :)
03:08:39 <Cale> wli: Smallest number of (key)strokes.
03:08:45 <quicksilver> wli: golfing is the game of reducing short programs to very very short programs
03:08:55 <dolio> Or parse tree nodes if you're Paul Graham.
03:09:02 <quicksilver> wli: traditionally played professionally by perl programmers who have been certified.
03:09:11 <osfameron> it's also the major design principle behind perl 6 :-)
03:09:23 <opqdonut> dolio: :D
03:11:30 <Cale> hmm, there are lots of Romanian articles on the Haskell wiki now :)
03:11:43 <Cale> http://www.haskell.org/haskellwiki/Category:Ro
03:11:44 <lambdabot> Title: Category:Ro - HaskellWiki
03:15:39 <wli> fix (([1] :) . ap (zipWith (zipWith (+)) . map (0 :)) (map (++ [0])))
03:16:08 <wli> I don't trust the ap usage, though.
03:16:26 <opqdonut> trust?
03:16:37 <Cale> > fix (([1] :) . ap (zipWith (zipWith (+)) . map (0 :)) (map (++ [0])))
03:16:38 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
03:17:25 <wli> opqdonut: It usually doesn't help make things shorter.
03:17:49 <quicksilver> in this case, the ap is required to duplicate the parameter
03:17:56 <quicksilver> (which used to be pascalTriangle)
03:17:58 <Cale> Hmm, my lambdabot died, and the last line of output was "url module failed in contextual handler: thread killed"
03:18:07 <quicksilver> duplication of parameters is always ap or join, isn't it?
03:18:15 <quicksilver> in the (->) monad in both cases
03:18:43 <wli> Yeah. I don't like using ap for that.
03:19:57 <Cale> ap is just the S combinator
03:20:18 <opqdonut> should be renamed S :P
03:20:35 <Cale> I find it rather beautiful that the applicative functor ((->) e) perfectly captures the SK-calculus.
03:20:45 <opqdonut> let S = ap; K = const; I = id in ..
03:20:52 <opqdonut> Cale: indeed
03:21:00 <Cale> Somehow that explains the SK calculus in a way which makes it seem much less arbitrary.
03:22:11 <wli> Isn't there some method of constructing somehow canonical combinators from a CPS version of an interpreter?
03:23:45 <Cale> I don't know.
03:24:22 <Cale> By the way, I sent an e-mail to SPJ asking for pointers as to which parts of GHC I'd be most interested in for implementing extensible records.
03:24:31 <wli> ddarius showed me some paper about smoking out abstract machines quasi-automatically.
03:25:52 <quicksilver> did he answer?
03:26:51 <wli> I already know what to hack on to get monad comprehensions back, I just can't figure out what to do to it.
03:27:07 <Cin> argh. using the state monad has ruined all my `where' clauses because i have to use foo <- get
03:27:32 <Cale> I wonder if Peirce knew he had such a nice formalisation when he was axiomatising logic? That was a good 70 years before category theory.
03:27:47 <Cale> Cin: you can use let blocks inside do
03:29:08 <Cin> well, i'll put up with it. don't really like let but i don't know why so i'll just shut up and use it
03:29:54 <quicksilver> Cin: if you feel like pasting some code then people may be able to suggest things which would look nicer
03:29:55 <Cale> quicksilver: Not yet, but I only e-mailed him last night :)
03:30:00 <quicksilver> ;)
03:30:06 <wli> Basically the CPS transformed interpreters can be viewed as state transition systems, so you get an abstract machine from that where the "instructions" correspond to the state transitions in it.
03:41:14 <SamB> do does have streamlined lets...
03:50:17 * dolio has trouble believing ccshan/oleg's generalized zippers will be at all efficient.
03:52:21 <dolio> Amazing articles, though.
03:53:59 <ac> bloody hell! I knew this was going to be the case. I spent a few hours implementing support for encoding less-than-8 bit depth images, but it hardly effects the final file sizes because the deflate compression is about as effective
03:54:46 <ac> and I'm aware of at least two bugs in my implementation. I'm tempted to just remove it
03:55:26 <quicksilver> you could at least support fewer-than-8 bit
03:55:31 <quicksilver> that would be more grammatical
03:56:41 <Cale> heh
03:57:04 <Cale> One thing that I'm confused about is why there is no corresponding distinction for 'more'
03:57:22 <ac> it makes a 5% difference in my test image
03:57:55 <dolio> What's the test image look like?
03:58:25 <therp> quicksilver: why is fewer-than more correct in this case? isn't it appropriate to name â‰¤ 'less-than'?
03:58:55 <quicksilver> therp: fewer than is for discrete quantities, less is for continuous
03:59:08 <quicksilver> fewer lambdas means less happiness
03:59:17 <ac> therp: it's a two color image of a circle
03:59:26 <ac> bit depth of 1
03:59:52 <ac> I'm guessing that's a pretty good test case for advantage of lower bit depths
04:00:04 <dolio> How does it affect more complex images?
04:00:44 <ac> dolio: haven't tested that yet. I'll generate an image of black and white static
04:01:09 <quicksilver> sounds like a good test case for compression, to me ;)
04:01:24 <quicksilver> since you've got loads of identical pixels
04:01:32 <therp> quicksilver ah, ok, thanks :) .. so â‰¤ defined on N should be called fewer-than :)
04:02:48 <therp> but OTOH, the naming seems quite inconsistent anyway. 'less-than' should imply 'more-than', while 'greater-than' should imply 'smaller-than'
04:03:34 <Cale> therp: except that "smaller" generally means "closer to 0"
04:04:08 <ac> quicksilver: the point is to compare sizes of compressed bytes vs compressed bits
04:04:59 <ac> quicksilver: were you saying those two images are a reasonable or unreasonable thing to test to decide if supporting different bit depths is worth it?
04:07:34 <yondalf> http://hpaste.org/5524 <- i have a problem "the last statement in a 'do' construct must be an expression" at the line starting with es2, anyone can help?
04:09:18 <ac> ok, with the static added it's now 7 times smaller. definitely worth it :-P
04:10:43 <Cale> d'oh
04:18:59 <yondalf> how do i see if anyone mentioned my name in the past, say, 5 minutes?
04:19:11 <nominolo> @where logs
04:19:12 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
04:19:27 <yondalf> how often are the logs updated?
04:19:35 <nominolo> every message
04:19:42 <yondalf> nominolo: thanks
04:19:47 <quicksilver> yondalf: no one did.
04:19:54 <quicksilver> yondalf: I was wondering if you were missing a closing ] though
04:20:10 <quicksilver> yondalf: but I guess that was a partial paste
04:20:49 <yondalf> quicksilver: oh yeah...i forgot to put the final ]
04:21:05 <quicksilver> I don't see an obvious problem there
04:21:11 <yondalf> quicksilver: i mean, it's in my code but i forgot to copy that line...the ] is aligned with the ,s
04:21:19 <quicksilver> have you got some tabs masquerading as spaces?
04:21:31 <Cale> yondalf: I replied on hpaste
04:22:11 <Cale> yondalf: For one syntax reason or another,  do { ... } either has to be surrounded by parens or preceded by a $ in order to be parsed correctly as a parameter to a function
04:22:17 <quicksilver> do
04:22:21 <quicksilver> doh
04:22:26 <quicksilver> yes, cale is of course right
04:22:35 <quicksilver> "do" is parsed "as if it was a function" in a sense
04:22:45 <quicksilver> it doesn't get magical slurping properties
04:22:53 <yondalf> quicksilver: Cale: thanks :-)
04:23:08 <Cale> I sort of wonder why it doesn't. It certainly would be convenient if it were.
04:23:10 <quicksilver> this is a bit inconsistent because 'then' gets magical slurping properties
04:23:21 <quicksilver> and so does 'if' for that matter
04:23:38 * ac appreciates ifs magical slurping
04:23:43 <quicksilver> or does it
04:23:45 <yondalf> yup it compiles, thanks :-)
04:23:55 <ac> *if's
04:23:59 <quicksilver> > (+) 1 if True then 1 else 2
04:24:05 <lambdabot>  Parse error at "if" (column 7)
04:24:10 <quicksilver> nope, ti doesn't
04:24:17 <yondalf> > (+) 1 $ if True then 1 else 2
04:24:20 <lambdabot>  2
04:24:26 <quicksilver> it's only "then" that does, in a sense
04:24:30 <yondalf> okay, i learned something new today :-)
04:24:34 <quicksilver> but then is parsed in a different context
04:24:38 <quicksilver> annoying, I agree with Cale
04:24:50 <quicksilver> but there might be some interaction with layout blocks which is not obvious to me
04:24:55 <quicksilver> which relates to why this isn't done
04:25:11 <ac> parsing ambiguities are not very intuitive, I don't think
04:25:33 <quicksilver> it's pretty common to give keywords special parsing properties though
04:25:40 <quicksilver> especially in a language with so few keywords
04:37:18 <yondalf> is there anything like refactormycode.com for haskell?
04:38:27 <opqdonut> we call it ?pl
04:38:30 <opqdonut> :p
04:38:42 <yondalf> ?pl ?
04:38:42 <lambdabot> (line 1, column 1):
04:38:42 <lambdabot> unexpected "?"
04:38:42 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
04:39:12 <opqdonut> ?pl f a b = a*a+b*b
04:39:12 <lambdabot> f = (. join (*)) . (+) . join (*)
04:39:39 <yondalf> ?pl f a = 1 + 1 + a
04:39:40 <lambdabot> f = (2 +)
04:39:50 <yondalf> wow, lambdabot is quite good
04:39:54 <opqdonut> ?pl f' f xs = xs ++ concat (map f xs)
04:39:54 <lambdabot> f' = ap (++) . (=<<)
04:40:20 <yondalf> ?pl do { string "%barsperline"; spaces; i <- many1 digit; newline; updateState (\(_, c) -> (i, c)); return [] }
04:40:20 <lambdabot> (line 1, column 4):
04:40:20 <lambdabot> unexpected "{"
04:40:20 <lambdabot> expecting variable, "(", operator or end of input
04:40:28 <dolio> @pl \a b c d -> d b c a
04:40:29 <lambdabot> flip (flip . (flip .) . flip . flip id)
04:40:35 <yondalf> okay it can't do  everything :-P
04:40:49 <dolio> ?. pl undo do { string "%barsperline"; spaces; i <- many1 digit; newline; updateState (\(_, c) -> (i, c)); return [] }
04:40:50 <lambdabot> string "%barsperline" >> spaces >> many1 digit >>= (>> return []) . (newline >>) . updateState . (. snd) . (,)
04:41:21 <yondalf> that's more complicated, but i should look at the , operator
04:41:24 <yondalf> :info (,)
04:41:38 <yondalf> oh...it just forms a pair right?
04:41:38 <dolio> > (,) 1 2
04:41:40 <lambdabot>  (1,2)
04:41:50 <Cale> Yeah, at both the value and type level.
04:42:02 <Cale> > (,) 1 "Hello" :: (,) Integer String
04:42:03 <lambdabot>  (1,"Hello")
04:43:48 <yondalf> is there any way to write this better: if allowStart then option ' ' (char '^') else return ' '
04:43:53 <yondalf> this is within a do block if that's important
04:44:32 <yondalf> and i'm using the parsec library, of course
04:46:24 <ivan__> how do i write a function to groupBy i want to group by te first element groupBy ((==) ....)) [(0,4,3),(0,3,2)....]
04:47:31 <ivan__> i have to write a lambdafunction \(x,_,_) that compares x == x
04:47:36 <EvilTerran> yes
04:47:51 <EvilTerran> groupBy ((==) `on` \(x,_,_) -> x) should work
04:47:59 <EvilTerran> if you have ghc 6.8
04:48:07 <ivan__> i have 6.6
04:48:14 <yondalf> ?info on
04:48:14 <lambdabot> on
04:48:14 <nominolo> @src on
04:48:15 <lambdabot> (*) `on` f = \x y -> f x * f y
04:48:28 <nominolo> that'll do :)
04:48:38 <yondalf> where is on defined?
04:48:41 <EvilTerran> or you can define it yourself, as per that definition
04:48:46 <EvilTerran> in 6.8, it's in Data.Function
04:48:49 <dolio> @info do { a <- m ; b <- n ; return (a * b)
04:48:49 <lambdabot>  Parse error at end of input
04:48:53 <dolio> @info do { a <- m ; b <- n ; return (a * b) }
04:48:53 <lambdabot> m >>= \ a -> n >>= \ b -> return (a * b)
04:48:59 <yondalf> can lambdabot tell me where things are defined, if i want to know?
04:49:08 <EvilTerran> ?index getContents
04:49:08 <lambdabot> System.IO, Prelude
04:49:10 <EvilTerran> yes.
04:49:12 <EvilTerran> :)
04:49:19 <dv\_> @type (>=>)
04:49:20 <lambdabot> Not in scope: `>=>'
04:49:31 <yondalf> @info on
04:49:31 <lambdabot> on
04:49:45 <dolio> info gets spell corrected to undo.
04:50:16 <EvilTerran> dv\_, \b is still on 6.6 in most cases
04:51:02 <yondalf> wow...hoogle is quite useful
04:51:07 <EvilTerran> Control.Monad.(>=>) :: (a -> m b) -> (b -> m c) -> a -> m c
04:51:23 <yondalf> um wait, that's not what i was looking for
04:51:40 <dv\_> EvilTerran: yeah, i just thought someone would randomly contribute an example using >=> :p
04:51:58 <yondalf> oh yes it is sorry :-P
04:52:34 <faxathisia> What's the difference between a deep and a shallow emedding of one language in another?
04:53:24 <EvilTerran> how hard you throw it :D
04:53:36 <faxathisia> lol
04:53:45 <daf> a deep embedding is more interwingled
04:55:01 <ac> a shallow embedding uses more features from the host language, right?
04:56:01 <ac> that would make the shallow embedding more intermingled
05:12:42 <ski> faxathisia : are you thinking of this <http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures/lecture2/Shape/Shallow.hs.html> <http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures/lecture2/Shape/Deep.hs.html> ?
05:12:42 <lambdabot> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures/lecture2/Shape/Shallow.hs.html>
05:13:15 <thegraham> Hi, does anyone know of an example where a function is passed as an argument to another function?
05:14:18 <dolio> > map (\x -> x + 1) [1..10]
05:14:24 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
05:14:31 <faxathisia> that's cool, Yeah I think that explains it. Thanks
05:15:36 <ski> > map (map (* 2)) [[1,2,3],[4,5,6],[7,8,9]]
05:15:36 <lambdabot>  [[2,4,6],[8,10,12],[14,16,18]]
05:16:17 <scook0> > fmap fmap fmap (*2) [[1,2,3],[4,5,6],[7,8,9]]
05:16:17 <lambdabot>  [[2,4,6],[8,10,12],[14,16,18]]
05:16:41 <thegraham> thanks
05:16:55 <dolio> > runCont (callCC (\k -> k ())) id
05:16:56 <lambdabot>  ()
05:18:58 <faxathisia> @hoogle [m a] -> m [a]
05:18:58 <lambdabot> Prelude.head :: [a] -> a
05:18:58 <lambdabot> Prelude.last :: [a] -> a
05:18:58 <lambdabot> Data.List.head :: [a] -> a
05:19:04 <faxathisia> @hoogle [m a] -> m a
05:19:05 <lambdabot> Prelude.head :: [a] -> a
05:19:05 <lambdabot> Prelude.last :: [a] -> a
05:19:05 <lambdabot> Data.List.head :: [a] -> a
05:19:15 <quicksilver> > find (>3) [1,2,3,4,5]
05:19:15 <ski> @type Control.Monad.msum
05:19:15 <lambdabot>  Just 4
05:19:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
05:19:25 <quicksilver> I like that as an example of passing a function
05:19:27 <quicksilver> not sure why
05:19:33 <quicksilver> I think it's more interesting than map :)
05:20:23 <faxathisia> @src msum
05:20:23 <lambdabot> msum =  foldr mplus mzero
05:20:52 <doserj> > filter even [1..] -- I like this one
05:20:52 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
05:23:30 <dolio> > runCont (callCC (\k -> foldM (\n s -> case n of 0 -> k 0 ; _ -> return (n*s)) 1 [-10 .. 10])) (+1)
05:23:31 <lambdabot>  1
05:41:14 <nominolo> @instances Random
05:41:19 <lambdabot> Couldn't find class `Random'. Try @instances-importing
05:42:19 <ski> @intances-importing Random Random
05:42:20 <lambdabot> Bool, Char, Double, Float, Int, Integer
05:42:25 <dv\_> does anyone know why I get the odd behavior with doesDirectoryExist? -> http://hpaste.org/5526
05:43:19 <daf> dv\_: what's your working directory?
05:43:55 <ski> dv\_ : possibly most of the subdirectories of `/' aren't also subdirectories of your current directory
05:44:15 <dv\_> ski: ah. yeah that might be it. thanks
05:44:47 <opqdonut> :D
05:53:12 <Jomyoot_> anything new lately? i have been away
05:53:55 <opqdonut> xmonad 0.3
05:54:06 <dolio> Haskell is now the most popular language on earth.
05:54:56 <opqdonut> err, xmonad 0.6 actually
05:55:02 <opqdonut> well, anyways a new release
05:55:06 <opqdonut> yi 0.3 it was i think
05:55:40 <quicksilver> ghc 7.0 can actually compile code which runs faster than hand-tuned assembly, by using 733t opcodes which no one else knows about
05:55:46 <quicksilver> so, not much has changed really
05:55:51 <Cale> Also, lambdabot is finally working on 6.8 (so long as you get the darcs versions of things)
05:55:54 <benny> teet opcodes?
06:01:39 <kuribas> What's the normal way to produce errors, "Either"?
06:02:04 <Cale> kuribas: There are lots of ways.
06:02:34 <Cale> Either works well, if you have interesting information to return.
06:02:42 * EvilTerran currently prefers to use Alternatives
06:02:58 <kuribas> Cale: Yes, I have, and I want to use it in a pure function.
06:02:59 <Cale> Maybe works well if you just want failure without additional information about it
06:03:22 <Cale> If you just want the whole program to die, you can use error.
06:03:33 <byorgey> Lists work well if you could have failure, or multiple successes.
06:04:03 <kuribas> EvilTerran: What is Alternatives?
06:04:05 <scook0> then there are ways to make your error reporting polymorphic (as EvilTerran hinted at), so that the caller can choose the error-handling strategy
06:04:18 <chot> hi, quick question: how do we convert form Int to Double, we only find documents on fromInteger...
06:04:31 <byorgey> @quote fromIntegral
06:04:32 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
06:04:38 <byorgey> =)
06:04:43 <chot> ty :)
06:05:36 <nominolo> @quote fromRational
06:05:37 <lambdabot> No quotes match. The more you drive -- the dumber you get.
06:06:36 <kuribas> I'll use "fail" and "return", than I can choose the type later.
06:07:06 <glen_quagmire> > let a :: Double = fromIntegral (1 :: Int) in "chot: " ++ show a
06:07:06 <lambdabot>  Parse error at "=" (column 17)
06:07:19 <ski> kuribas : which type ?
06:07:22 <Cale> kuribas: It is, however, irritating that fail is in the Monad class, and there are a lot of people who want it removed.
06:07:43 <kuribas> Then which should I use instead?
06:07:44 <Cale> (But it'll probably just get moved into its own class anyway)
06:08:20 <Cale> You could use the MonadError class from Control.Monad.Error
06:08:51 <wli> It used to be that failures generated Monad0 constraints. MonadError sounds good, too, though.
06:09:05 <Cale> wli: yeah. I want MonadZero back :)
06:09:12 <kuribas> Cale: Nice idea.
06:09:15 <ski> Cale : that still has `strMsg', though :(
06:09:24 <Cale> ski: right.
06:09:58 <kuribas> I could use ThrowError and catchError.
06:09:59 <Cale> I plan to learn enough about GHC's workings to implement extensible records and variant types.
06:10:13 <Cale> Variants will make good exceptions then :)
06:10:14 <glen_quagmire> > 3.0 + (1 :: Int)
06:10:17 <lambdabot>   add an instance declaration for (Fractional Int)
06:10:19 <faxathisia> This is absolutely incredible ... My lisp interpreter take 5.37 seconds to display (append list (reverse list)) for a 5 element list
06:10:20 <ski> kuribas : one can also use continuations for errors
06:10:20 <wli> Extensible variants would be very nice.
06:10:27 <glen_quagmire> > 3.0 + fromIntegral (1 :: Int)
06:10:31 <faxathisia> and over 1 min for a longer list..
06:10:40 <Cale> faxathisia: hehe
06:10:41 <ski> Cale : named variants ?
06:10:42 <nominolo> what's wrong with MonadPlus?
06:10:42 <lambdabot>  thread killed
06:10:47 <Cale> faxathisia: Where is the time spent?
06:10:53 <wli> Extensible records aren't anywhere near as interesting.
06:11:05 <Cale> ski: The kind which are in Daan Leijen's scoped labels paper.
06:11:34 <ski> nominolo : <http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal>
06:11:58 <faxathisia> how do you check that?
06:12:49 <glen_quagmire> in python, import profile  profile.all()  i think
06:12:59 <Cale> I think extensible records are interesting. One thing which Haskell presently seems to fall down on are the typical annoying sorts of data-munging tasks which involve large clunky product types (usually forced upon us from external protocols and such)
06:13:03 <nominolo> ski: nice, thanks
06:13:14 * ski would prefer `MonadOr' named something else .. maybe `MonadOrElse' or `MonadElse'
06:13:32 <Cale> Algebraic types work, but they're not terribly nice when you have a lot of fields.
06:13:46 <chot> omg, we cant find how to convert from Double to Int now.. fromRealFrac doesn't exist in prelude..
06:14:00 <nominolo> ski: MonadCatch
06:14:09 <faxathisia> oops.. i'll be back..
06:14:10 <Cale> chot: round, ceiling, floor
06:14:14 <Cale> chot: (pick one)
06:14:18 <chot> Cale: thnx :)
06:14:19 <ski> nominolo : that could work ..
06:14:27 <ddvlad> hi, what's a good starting point for understading the mathematical background of haskell?
06:14:37 <nominolo> > fromRational 4.0
06:14:41 <lambdabot>  4.0
06:14:46 <wli> Some device for sharing record labels and variant constructors and building up new types by combining sets of constructors and labels would be convenient.
06:14:49 <nominolo> > fromRational 4.0 :: Int
06:14:49 <lambdabot>   add an instance declaration for (Fractional Int)
06:14:49 <lambdabot>     In the expression: fro...
06:15:06 <Cale> ddvlad: Depends on which mathematical background you want. Something like "Types and Programming Languages" by Pierce, might be a good start.
06:15:31 <nominolo> > truncate 4.0
06:15:32 <lambdabot>  4
06:15:34 <Cale> ddvlad: If you want a Category theoretic background, well, I could recommend a few things...
06:15:40 <nominolo> > ceil 4.3
06:15:40 <lambdabot>   Not in scope: `ceil'
06:15:46 <nominolo> > round 4.3
06:15:47 <lambdabot>  4
06:15:53 <Cale> > ceiling 4.3
06:15:54 <lambdabot>  5
06:15:56 <nominolo> > floor 4.3
06:15:57 <lambdabot>  4
06:16:03 <ddvlad> Cale: please do. I'll turn this into a list :-)
06:16:21 <Cale> ddvlad: What's your present background like?
06:16:37 <Cale> (in mathematics)
06:16:45 <nominolo> ski: though, i like how `orElse` reads
06:16:54 <ddvlad> hmm... second year CS student, just basic Calculus and Algebra i guess
06:17:04 <Cale> okay
06:17:11 <ski> nominolo : exactly ;)
06:17:17 <nominolo> ski: and catch usually involves a dispatch on the error message
06:17:23 <Cale> So recommending something like "Categories for the working mathematician" might be a little cruel ;)
06:17:37 <ddvlad> Cale: it certainly sounds cruel :-)
06:17:52 <Cale> It's a good book, but the examples won't make any sense to you.
06:17:57 <ski> `Conceptual Mathematics' if you want an intro to CT
06:18:00 <nominolo> ski: MonadParent would be appropriate then ;)
06:18:04 <Cale> There are some good notes by Eugenia Cheng
06:18:24 <Cale> http://www.math.uchicago.edu/~eugenia/catnotes/categorynotes-cheng.pdf
06:18:25 <lambdabot> http://tinyurl.com/28sclm
06:18:40 <nominolo> didn't Pierce also wrote something on CT?
06:18:40 <Cale> They're quite brisk, but don't require much other background.
06:18:50 <Cale> Yeah, there's something by him...
06:19:12 <scook0> Pierce's CT book is a bit terse, in my experience
06:19:13 <Cale> "Category theory for computer scientists"
06:19:22 <ski> scook0 : yes
06:19:40 <Cale> Wikipedia is not a bad source for basic definitions
06:20:11 <ddvlad> Cale: wikipedia is what i thought of first, but i thought i'd ask before starting
06:20:14 * scook0 intends to understand adjoints someday :)
06:20:19 <Cale> and once you're far enough along to know what a functor is (which is not too far), there are some really good video lectures on YouTube
06:20:26 <pejo> ddvlad, Bastiaan Heeren's thesis is good for introduction to lots of type stuff, but you probably need a similar background to the  book by Pierce. (http://people.cs.uu.nl/bastiaan/phdthesis/)
06:20:28 <lambdabot> Title: Top Quality Type Error Messages
06:20:33 <Cale> http://uk.youtube.com/profile_play_list?user=TheCatsters
06:20:34 <lambdabot> Title: YouTube - TheCatsters's Playlists
06:21:08 <Cale> Those playlists are not in didactic order. I'd start with natural transformations, and then go to monads.
06:22:11 <ddvlad> i see. i'll start chewing these things up, make a little list, dump systems theory exam and get to work :-)
06:22:13 <ddvlad> thank you all
06:22:21 <Cale> ddvlad: Then there's combinator logic and lambda calculus.
06:22:38 <Cale> There's actually quite a lot of relevant mathematics :)
06:22:52 <ddvlad> heh, i should have thought it's not over
06:22:54 <Cale> and mostly from fairly surprising places, at least in my mind :)
06:23:23 <ski> `The calculi of Lambda-conversion' Alonzo Church
06:23:32 <Cale> Of course, you don't really need it just to program in Haskell, but you will if you want to push the shores of abstraction forward.
06:24:20 <ddvlad> well, the long term goal is to actually understand as much as possible as opposed to just program
06:24:33 <ddvlad> (of course, in the meantime, i'm having a hard time programming...)
06:24:51 <mux> Î»f. (Î»x. (f (x x))Î»x. (f (x x)))
06:25:09 <mux> yay for utf-8
06:26:18 <pejo> ddvlad, http://www.cs.utah.edu/plt/publications/pllc.pdf might be useful to you too.
06:26:54 <ddvlad> pejo: thanks, i've noted that, too
06:26:55 <Cale> http://www.cs.man.ac.uk/~hsimmons/BOOKS/books.html -- there are some somewhat relevant materials here as well
06:26:55 <lambdabot> Title: Books
06:27:51 <pejo> Heh, if you run out of material - just come back and ask again ddvlad. :-)
06:28:55 <Cale> pejo: That looks like a nice book :)
06:30:05 <pejo> Cale, well, the stuff that appeals to you might not always be the best for a beginner. But I don't doubt that Felleisen can write books - on the contrary, he's done several great ones.
06:31:06 <Cale> It looks like it would complement TaPL quite nicely.
06:33:23 <Cale> I found an original complete PDF of ATTaPL online the other week.
06:33:46 <mux> I found it too
06:33:56 <pejo> Illegally?
06:34:06 <Cale> I have no idea where it came from. It must be illegal.
06:34:15 <mux> yeah, I always start by being a nasty boy and then I buy stuff
06:34:17 <ski> the `Natural transformations video 1' is hilarious :)
06:34:20 <mux> that's what I did for TAPL
06:34:31 <mux> I first found a PDF, saw it was truly interesting, and bought the book an Amazon
06:34:40 <Cale> I own a copy of TaPL, but I'd like a nice clean PDF of it :)
06:34:53 <mux> I should probably buy ATTPL too now
06:35:20 <mux> though I get worried when we reach dependent typing, Î»LF, CC and friends
06:35:28 * wli is interested in ATTaPL
06:47:44 <jedbrown> Does anyone care about multi-dimensional arrays with non-homogeneous index types?
06:51:26 <jedbrown> For instance, an index of type (Int, Char, (Bool,Integer)) treated as a 3-D array?
06:51:41 <jedbrown> Or would tuples of Int be acceptable?
06:51:43 <glen_quagmire> > dup [1,2]
06:51:45 <lambdabot>   Not in scope: `dup'
06:52:18 <glen_quagmire> > (\ x -> (head x) : x) [1,2]
06:52:19 <lambdabot>  [1,1,2]
06:52:20 <ski> jedbrown : not 4-D ?
06:52:21 <Big_Red> why can't i get this function to work:
06:52:23 <Big_Red> col grid val = foldr (!!val) [] grid
06:52:33 <glen_quagmire> > swap (1, 2)
06:52:33 <lambdabot>   Not in scope: `swap'
06:52:43 <jedbrown> ski: It is a 3-tuple.
06:52:48 <Big_Red> where grid is a list of list
06:53:02 <jedbrown> ski: I wasn't proposing a flattening transform first.
06:53:21 <ski> Big_Red : `(!!val)' only takes one argument (unless your list contains function ?)
06:53:31 <jedbrown> ski: My motivation is that i'm having trouble typing a generalized transpose (permutation of indices).
06:53:41 <glen_quagmire> > (\ x -> let a = (head x); b = (head (rest x)); in b : a : (rest (rest x))) [1,2]
06:53:41 <lambdabot>   Not in scope: `rest'
06:54:04 <Big_Red> ski: i thought (!!val) would be applied each list within the grid
06:54:27 <jedbrown> ski: And even simple operations require some funny type-class hacks and extensions including UndecidableInstances.
06:55:10 <ski> @type \grid val -> foldr (!!val) [] grid
06:55:20 <lambdabot> forall a. [[[a] -> [a]]] -> Int -> [a]
06:55:33 <ski> (probably not what you wanted, i think)
06:56:18 <ski> Big_Red : maybe what you wanted is `col grid val = map (!! val) grid' ?
06:56:41 <Big_Red> hmm
06:57:05 <Big_Red> yay
06:57:08 <Big_Red> thanks
06:58:15 <ski> jedbrown : how would your generalized transpose work ?
06:58:53 <ski> making a wrapper type for transposed arrays ?
06:59:29 <quicksilver> generalised type projection is hard
06:59:38 <quicksilver> I'm not entirely sure the pain will be worth the gain
06:59:59 <quicksilver> isn't it all just a subcase of the general index mapping ?
07:00:05 <quicksilver> and that's much easier to type
07:00:17 <quicksilver> just supply an i -> j function for two Ix instances
07:00:18 <jedbrown> ski: It would take a permutation function (forall a. [a] -> [a]) which mangles the alignment.
07:00:25 <XD-G-C> if dr house told you to get naked and bend over, would you do it
07:00:48 --- mode: ChanServ set +o quicksilver
07:00:59 <ski> jedbrown : like `const []' ?
07:01:12 <jedbrown> ski: like id, or reverse
07:01:23 <quicksilver> jedbrown: I think you might as wel just take the function promoted to values
07:01:29 <quicksilver> work on values, not (type) indexes
07:01:32 <quicksilver> haskell is more comfortable there
07:01:46 <quicksilver> (Ix i, Ix j) => i -> j
07:01:59 <jedbrown> quicksilver: That isn't enough because I need to be able to extract the information about order of the new dimensions.
07:02:09 <quicksilver> I disagree.
07:02:14 <ski> jedbrown : what i would probably do is use an isomorphism between the two index types
07:02:23 <quicksilver> instantiate i = (Int,Char,Int) and j = (Char,Int,Int)
07:02:31 <quicksilver> ski is saying the same thing as me in a different way
07:02:43 <quicksilver> then the user provives (\(a,b,c) -> (b,a,c))
07:02:47 <quicksilver> and that's you're generalised transpose
07:03:08 <ski> (and i would probably use a wrapper type, to not convert the arrays needlessly between different formats)
07:03:22 <kReepicheep> the +o, it burns my eyes
07:03:25 <jedbrown> quicksilver: Oh, yes.  I have that, but that is even more general, and less friendly to use.
07:03:34 <quicksilver> I think it might be more friendly to use
07:03:38 <quicksilver> than the type-level permutation
07:03:45 <quicksilver> and forcing to go via [a] types
07:03:47 <quicksilver> that you are trying to do :)
07:03:49 <quicksilver> that's my point.
07:03:57 <quicksilver> It is of course more general.
07:04:10 <quicksilver> But haskell really isn't very good at modelling projection and permutation at the type level.
07:04:16 --- mode: quicksilver set -o quicksilver
07:05:03 <jedbrown> quicksilver: In my framework, a 2-D transpose is just reverse.  The user doesn't have to worry about array bounds.
07:06:01 <quicksilver> but your framework doesn't scale to (Int,(Char,(Char,Int),Char))
07:06:04 <quicksilver> as you pointed out yourself :)
07:06:07 <quicksilver> whereas mine does.
07:06:13 <quicksilver> swings and roundabouts, methinks...
07:06:27 <jedbrown> quicksilver: It would be easier for the user to say (\[a,b,c,d,e] -> [c,b,d,e,a])
07:07:02 <jedbrown> quicksilver: Um, your example is just 2 indices.  What is the problem?  I'm not proposing a flattening transform.
07:07:07 <quicksilver> I don't think that's very different from
07:07:31 <quicksilver> I thought you were proposing not supporting tuple indexes
07:07:35 <jedbrown> (The problem is that I can't type the function which actually does the work.  The permutation function is easy to type.)
07:07:37 <quicksilver> and onl supporting list indexes
07:09:27 <jedbrown> permuteDims :: (Ix i, ??? i j, IArray a e) => (forall x. [x] -> [x]) -> a i e -> a i' e
07:09:41 <jedbrown> s/i'/j/
07:10:12 <jedbrown> ^^^ That won't work because the type of j is dependent on the permutation function.
07:12:00 <quicksilver> right
07:12:04 <quicksilver> which is why I don't suggest it
07:12:13 <quicksilver> I just suggest you pass the function i -> j
07:12:24 <jedbrown> I just think that this friendlier function would be useful.  The 2-D transpose is easy, so perhaps I'll just leave that special case and make the user work for the general one.
07:12:53 <quicksilver> I can't imagine a case where the [x] -> [x] function is easier to provide than the i->j one
07:13:07 <quicksilver> although I admire the sexy use of a higher rank type to represent a generic permuation :)
07:13:33 <jedbrown> It's the function j -> i, and then I have to take the new bounds explicitly as well.  (That function is already written and working fine.)
07:13:55 <ski> (not only permutations live in that type ..)
07:14:29 <quicksilver> jedbrown: you could just apply the function to the bounds, too
07:14:37 <ski> if you pass in an iso, then you can convert the old bounds to new bounds, no ?
07:14:41 <jedbrown> ski: Yes, it's quite a bit more general, but I don't think the generic permutation can be typed.
07:14:55 <quicksilver> ski: (indeed not, but it's still nice, even if imperfect)
07:17:01 <jedbrown> quicksilver: I think I could make the (i -> j) version work.  It involves filling the new array out of order, but would eliminate needing the new bounds explicitly.
07:17:32 <quicksilver> there is also something which ski observed which is that it may sometimes be worth not actually copying the data
07:17:40 <quicksilver> just storing + piling up the isomorphisms
07:18:58 <zookosleep> Let me know if anyone tries to use my Haskell bindings to SHA-256 or Tiger and it doesn't work.
07:18:59 <jedbrown> Yes, that would be cool, but I'm not sure how to do it generally.
07:19:52 <jedbrown> Plus, we need to collapse the isomorphisms before making a foreign call.
07:21:56 <ski> data WrapArray a i e = forall j. WA (Iso i j) (a j e)  -- mayhaps something like this ?
07:24:03 <quicksilver> ski++ # use of word 'mayhap'
07:25:15 <ski> quicksilver : hm ?
07:25:27 <quicksilver> it's a nice word, that's all
07:25:30 <jedbrown> ski: Yeah, we could add an element map in there too.
07:26:02 <ski> (quicksilver : i just didn't note anything special, so i wondered why you reacted ..)
07:26:13 <faxathisia> Can hpaste take 130 lines?
07:26:29 <jedbrown> faxathisia: Depends how long the lines are.
07:26:34 <dolio> It runs on bytes, doesn't it?
07:26:46 <ski> jedbrown : so you want to change element view, too ?
07:27:50 <jedbrown> ski: May as well, don't you think?
07:28:24 <ski> i suppose
07:28:58 <faxathisia> I guess it takes 5000 bytes?
07:29:25 <ski> or 4096
07:29:27 <jedbrown> ski: WrapArray needs to hold the new bounds as well.
07:29:43 <ski> jedbrown : why ?
07:30:05 <faxathisia> There is no mention of 4096 in http://www.scannedinavian.com/~eric/hpaste/HPaste.hs
07:30:19 <ski> faxathisia : just guessing ;)
07:30:48 * faxathisia just risks this..
07:31:04 <jedbrown> So you can determine them.  (Iso i j) only tells you implicitly.  But it would allow you cheap sub-arrays.
07:31:14 <faxathisia> @bot
07:31:14 <lambdabot> :)
07:31:32 <faxathisia> well I pasted this http://hpaste.org/5527
07:32:16 <ski> jedbrown : one can just use `bounds' on the stored array, and drag the bounds backwards through the iso, no ?
07:32:42 <faxathisia> so I think that I do huge amounts of recomputation, and so I wonder how you can avoid recomputing things in the IO monad?
07:33:04 <jedbrown> ski: Then (Iso i j) needs both (i -> j) and (j -> i).
07:33:21 <ski> jedbrown : i thought that was obvious
07:34:44 <faxathisia> basically I thought I could make mutable conses (using IO Refs) and define a small interpreter in terms of those..
07:35:02 <jedbrown> ski: Okay, but it would be nice to generalize to allow cheap subarrays.  Then you only have (i -> j).
07:35:18 <faxathisia> It seems like I might not be able to do that practically though, since that everything seems to be recomputed all the time
07:35:28 <jedbrown> ski: Besides, it is more work for the user to have to specify both directions explicitly.
07:37:06 <jorik808> i'm thinking of writing my own toy language interpreter in haskell (i guess everyone does this at some point) and i thought i'd base myself on the scheme48hours book. i'm having some problems though, creating the syntax of my language.
07:37:30 <jorik808> does anyone know of a tool that will take my syntax in eg BNF and let me quickly experiment with it?
07:37:51 <faxathisia> jorik808: It doesn't use BNF but I find parsec very good
07:38:21 <faxathisia> There is this Cactus thing (I haven't tried) that uses BNF though
07:38:23 <sebell> You could use Happy if you want to generate a parser, though I'm not sure how `quick' it would be to get up and running
07:39:24 <jorik808> faxathisia, that's the thing, i'm kind of new to haskell so i'm really strugling through parsec; that's why i was thinking maybe find a tool somewhere
07:39:55 <jorik808> i will try to see what cactus is, but maybe i should just bite the bullet and go on in parsec
07:39:59 <faxathisia> jorik808: You have defined an AST something like data Term = Atom String | ...
07:40:00 <faxathisia> ?
07:40:12 <jorik808> yeah i have one :)
07:40:19 <ski> @where bnfc
07:40:19 <lambdabot> http://www.cs.chalmers.se/~markus/BNFC/
07:40:27 <ski> jorik808 : ^
07:40:28 <dolio> faxathisia: What exactly goes wrong with the code you posted?
07:40:49 <jorik808> ski: thanks !!
07:41:02 <faxathisia> It takes 5.41 seconds to run test1
07:41:29 <quicksilver> jedbrown: cheap subarrays is also very nice.
07:41:40 <quicksilver> jedbrown: in fact, I think it's a killer feature.
07:41:57 <faxathisia> And all that test1 does is (display (append list (reverse list))) (newline)
07:42:22 <quicksilver> jedbrown: but I think it's sufficiently different from isomorphic re-indexing, a.k.a generalised transpose
07:42:31 <quicksilver> jedbrown: that the two deserve to be treated differently
07:42:36 <quicksilver> although they're obviously closely related
07:42:47 <jedbrown> quicksilver: For cheap subarrays I need to only keep the map (i -> j) and the new bounds.
07:42:53 * faxathisia is wondering.. How do you optimize recomputation?
07:43:13 <jedbrown> For isomorphic re-indexing, as long as I keep the new bounds, then I only need to retain the map (i -> j).
07:43:14 <pejo> faxathisia, CSE :-)
07:43:31 <jedbrown> It would be nicer to only have one wrapped array type.
07:43:33 <ski> memo
07:43:43 <quicksilver> jedbrown: I agree, yes
07:43:55 <quicksilver> faxathisia: is it that slow even compiled?
07:44:43 <kuribas> Why doesn't minimum return a Maybe value or something similar?
07:44:54 <quicksilver> no particular reason
07:45:00 <quicksilver> just a cost/benefit tradeoff
07:45:04 <kuribas> Wouldn't it be nicer?
07:45:17 <quicksilver> 99% of the time, probably not :P
07:45:17 <faxathisia> Yeah It's still really slow (not as bad though)
07:46:00 <quicksilver> a common pattern is to do "minimum x:l"
07:46:00 <faxathisia> 8 seconds for a 6 element list
07:46:19 <quicksilver> where 'x' is your 'default minimum' i.e. maximum.
07:46:30 <quicksilver> maxBound is a possibility
07:46:31 <faxathisia> What is CSE?
07:46:36 <quicksilver> :t minimum . (maxBound:)
07:46:38 <lambdabot> forall a. (Ord a, Bounded a) => [a] -> a
07:47:56 <jorik808> ski: bnfc is *excactly* what i needed, thanks again
07:49:50 <ski> yw
07:50:15 <ski> faxathisia : Common Sub-Expression (elimination/factoring)
07:51:02 <dolio> faxathisia: Why do you call 'consValue cons' in, for example, car and cdr?
07:51:33 <wli> Error handling deserves more thought.
07:51:45 <faxathisia> so you can write (cons "a" "b") and also (cons "a" (cons "b" ())) (cons returns an IO Value)
07:52:10 <faxathisia> otherwise I have to unnest everything like  a <- (cons "b" ()) ; b <- (cons "a" b)
07:52:42 <wli> We've got all this monadic error handling and don't use it in the standard libs. What's going on there?
07:53:23 <daf> the standard libs predate the monadic error handling?
07:53:24 <ski> maybe we need an effect system ?
07:53:25 <quicksilver> MonadError isn't h98-compliant
07:53:38 <cjb> (is this Maybe, or something else?)
07:53:53 <daf> cjb: something else
07:54:05 <wli> MonadError
07:54:40 <ski> `MonadError' should be freed from the `Error' class
07:54:47 <quicksilver> you could do a special case of MOnad error where the error type was forced to be String.
07:54:53 <wli> ski: Beg pardon?
07:54:53 <quicksilver> and you could make that haskell98
07:55:02 <quicksilver> maybe that would have been a good compromise
07:55:09 <ski> wli : see `noMsg',`strMsg'
07:55:44 <wli> ski: Well, why bother? It seems harmless.
07:55:49 <ski> sometimes you don't want to embed strings (or empty errors) in your error typw
07:56:52 <wli> I guess I've mostly wanted a bounded enum variant there.
07:57:20 * ski has had an example where the `error type' was actually another monadic action
07:57:33 <dolio> Some people are rather un-thrilled about the existing error handling mechanisms, too.
07:58:12 <dolio> And would probaly want to fix them, with open types or variants before using them all over the place in the standard libraries.
07:58:49 <quicksilver> ski: but if libraries are going to be useful, they need to be able to throw errors
07:58:55 <quicksilver> in your type, not their type
07:59:01 <dolio> Although, requiring even more type extensions would make them even less able to be included in certain areas.
07:59:05 <quicksilver> so there needs to be a unifying type
07:59:09 <quicksilver> e.g. String
07:59:13 <quicksilver> which is why strMsg exists
07:59:19 <quicksilver> and I don't see a better solution to be honest
08:00:03 <ski> you could have a subclass
08:00:35 <quicksilver> you could
08:01:28 <ski> (maybe what i want is something almost like `MonadError', but without the `Error' requirement .. which is why it can feel so irksome, so close but not quite right)
08:01:40 * quicksilver nods
08:01:47 <quicksilver> but standard libraries couldn't use that type
08:01:57 <quicksilver> they'd have to use the String version
08:02:05 <quicksilver> which is what we were talking about here
08:02:11 <quicksilver> (why don't we use it in the standard libs)
08:02:28 <wli> Extensible variants might help, I suppose.
08:03:08 <sethk> is function words the reverse of function unwords?
08:03:29 <wli> What's function?
08:03:43 <ski> > words . unwords $ " foo bar "
08:03:45 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
08:04:04 <quicksilver> sethk: roughly, not exactly
08:04:29 <quicksilver> wli: extensible variants wouldn't help with the goal of getting something H98 for standard libraries to use ;)
08:04:36 <ski> er
08:04:36 <quicksilver> it might help towards getting something cool.
08:04:44 <ski> > unwords . words $ " foo bar "
08:04:44 <sethk> quicksilver, what I'm doing is very simple, just a string of text, separated by spaces, to turn  into a list
08:04:45 <lambdabot>  "foo bar"
08:04:58 <quicksilver> sethk: and that is what words does, yes
08:05:08 <sethk> quicksilver, thanks
08:05:35 <faxathisia> I think that I must be doing something completely wrong then
08:05:38 <ski> sethk : so, no you don't necessarily get the same thing back
08:06:06 <sethk> ski, not sure what you mean.  You mean applying words and then unwords?
08:06:19 <ski> > words . unwords $ [" foo","bar "]
08:06:22 <lambdabot>  ["foo","bar"]
08:06:27 <ski> sethk : yes
08:06:31 <dolio> > unwords (words "   foo     bar")
08:06:32 <lambdabot>  "foo bar"
08:06:37 <sethk> ski, ok thanks.
08:06:44 <faxathisia> do any silly inefficiencies jump out in my paste?
08:07:13 <wli> I'm not wild about the idea of sticking to H98; you can't really do monad transformers in H98, so you're dead in the water for just about any serious use of monads in H98 anyway.
08:09:44 <EvilTerran> @let words' s = case span isSpace s of (sp,"") -> [sp]; (sp,s') -> sp : w : words' s'' where (w,s'') = break isSpace s'
08:09:47 <lambdabot> Defined.
08:10:00 <EvilTerran> > words' "   foo     bar "
08:10:00 <lambdabot>  ["   ","foo","     ","bar"," "]
08:10:11 <EvilTerran> > words' "noSpacesAtAll"
08:10:11 <lambdabot>  ["","noSpacesAtAll",""]
08:10:36 <dolio> > let words' = groupBy isSpace in words' "   foo     bar "
08:10:37 <lambdabot>  Couldn't match expected type `Char -> Bool'
08:10:58 <quicksilver> wli: yeah, but I don't think there is much chance of the "standard" libs moving away from h98 any time soon
08:11:10 <EvilTerran> @check (==) `ap` (concat.words')
08:11:11 <lambdabot>  OK, passed 500 tests.
08:11:17 <quicksilver> wli: although a parallel API which reused 99% of the same code with slight interface changes might be nice.
08:11:29 <quicksilver> slight interface changes like monadic error handling.
08:12:01 <dolio> > let on f g a b = g a `f` g b ; words' = groupBy ((==) `on` isSpace) in words' "   foo     bar "
08:12:04 <lambdabot>  ["   ","foo","     ","bar"," "]
08:12:30 <tibbe> can I have an executable in a .cabal file that depends on a library in the same file?
08:13:46 <quicksilver> tibbe: ISTR that is hard to do.
08:14:03 <tibbe> quicksilver: ?
08:14:15 <quicksilver> I seem to remember that is hard to do
08:14:26 <quicksilver> I believe it is a known cabal deficiency
08:14:29 <quicksilver> unless it has been fixed.
08:14:37 <tibbe> ah, ok
08:17:53 <faxathisia> Does anyone know of some efficient code that embeds a language which has mutable objetcs?
08:21:43 <byorgey> tibbe: it can be done fine, it just compiles the library twice =P
08:21:50 <byorgey> xmonad does that, for example
08:22:00 <tibbe> byorgey: just looked at xmonad, thanks anyway :)
08:22:33 <tibbe> faxathisia: I don't know but there's the Perl 6 implementation in Haskell, Pugs
08:23:30 <byorgey> tibbe, quicksilver: oh, now I suddenly understand the deficiency better.  you can't just say  'build-depends: libraryFoo' for the executable, you have to list out all the modules again
08:24:00 <tibbe> byorgey: yup
08:24:02 <byorgey> so that's kind of annoying, but works OK as long as the compiling doesn't take a really long time...
08:24:06 <faxathisia> pugs is like a standard interpreter
08:24:13 <tibbe> byorgey: I don't think it evens consider the library declaration
08:24:16 <faxathisia> I mean an embedding of one languague in another
08:24:22 <byorgey> tibbe: yeah, I think you're right
08:24:27 <tibbe> faxathisia: I see, in that case no
08:29:55 <Big_Red> what does it mean when hugs says "unification would give infinite type"?
08:31:40 <Cale> Big_Red: Types like the solution to the equation a = [a] aren't allowed.
08:31:52 <jacobian> For the list monad what is the decomposition into adjoint functors of the functor T, defined as the functor taking A to [A]
08:32:08 <Cale> jacobian: There are at least two.
08:33:25 <Big_Red> cale: how do you mean?
08:33:28 <Cale> jacobian: (one via the Kleisli category, and one via the Eilenberg-Moore category)
08:34:31 <Cale> Big_Red: Well, let's say that you tried to define the list x as (x:x), say.
08:34:42 <Cale> Big_Red: That is, the list x would contain itself as an element.
08:34:56 <Cale> (and would be its own tail)
08:35:27 <quicksilver> jacobian: there is no decompostion into 'Functors' in the haskell sense, sadly.
08:35:43 <quicksilver> jacobian: only decompositions via functors through another category which is not Hask.
08:35:50 <Cale> While there's nothing wrong with that in an untyped system, in typed systems we recognise that it usually indicates a bug, and don't allow it.
08:35:59 <quicksilver> (and, as far as I know , not even identifiable as a subcategory of Hask)
08:36:15 <jacobian> hmm, that's sort of interesting in itself
08:36:18 <Cale> Big_Red: If you're having problems with a particular piece of code, if you'll stick it on hpaste, I can have a look.
08:36:33 <Big_Red> does anyone know if a while statement after a guarded function applies to all of the guards or just the adjacent one?
08:36:41 <Cale> quicksilver: Are you certain of that?
08:36:58 <byorgey> Big_Red: you mean a where clause?  a where clause scopes over all the guards.
08:37:07 <quicksilver> Cale: it's hard to be absolutely certain
08:37:09 * ski currently tries to encode `EilenbergMooreCategory' in Alfa ..
08:37:26 <quicksilver> Cale: I have stared hard at both the eilenberg moore and kleisli decompositions
08:37:39 <quicksilver> Cale: and been unable to imagine how they could occur as subcats of Hask.
08:37:55 <Big_Red> yes where and thanks
08:38:08 <Big_Red> but still having trouble understanding why its not liking my function
08:38:15 <quicksilver> Cale: but I have not proved that there is no such decomposition at all. That would be an interesting proof...
08:38:18 <Cale> !paste
08:38:23 <Cale> @paste
08:38:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:39:02 <Cale> quicksilver: Well, yeah, those are not subcategories of Hask in any usual sense, but that doesn't mean there isn't some other adjunction entirely, I don't think.
08:39:27 <quicksilver> Cale: agreed. But I hypothesise that there isn't.
08:39:43 <Cale> hmm
08:39:51 <mux> quicksilver's theorem
08:40:05 <mux> "I have found a remarkable proof for that, but this margin is too small to contain it"
08:40:18 <resiak> "... but the /topic is..." ?
08:40:41 <quicksilver> @go "margin of this IRC channel"
08:40:41 <lambdabot> No Result Found.
08:40:46 <quicksilver> !
08:40:56 <quicksilver> http://www.google.com/search?hl=en&safe=off&client=safari&rls=en&q=+%22margin+of+this+IRC+channel%22
08:40:57 <lambdabot> Title: "margin of this IRC channel" - Google Search, http://tinyurl.com/2kjsfn
08:41:06 <Big_Red> forgot to put announce but http://hpaste.org/5528
08:41:18 <mux> quicksilver: hah
08:41:23 <quicksilver> Cale: it might be instructive, and simpler, to examine 'Maybe' first.
08:41:34 <mux> quicksilver: and me who thought I was being original.
08:41:46 <quicksilver> Cale: I daresay the existence or non-existence of that would give a clue as to the list case
08:42:07 <quicksilver> mux: in fact it appears to be a joke I have made twice :)
08:42:15 <quicksilver> mux: so I also am lacking in originality
08:42:33 <byorgey> Big_Red: I think you want to say val==1 rather than val=1, and so on
08:42:55 <byorgey> Big_Red: = is for assignment, == for comparing for equality
08:44:13 <Big_Red> erm yeah thats something i threw in as an afterthought when pasting it in
08:44:21 <Big_Red> haven't quite finished that bit yet
08:44:50 <Big_Red> its the [x|a<-[1..(length grid)],block<-grid!!a,x<-block!!a] bit that isn't happy
08:45:10 <byorgey> Big_Red: what error does it give?  can you paste it as an annotation?
08:45:26 <quicksilver> Big_Red: you can't <- grid!!a
08:45:29 <quicksilver> Big_Red: you <- from lists
08:45:34 <quicksilver> Big_Red: grid !! a isn't a list
08:45:40 <quicksilver> (it's a Row)
08:45:49 <quicksilver> oh but
08:45:50 <byorgey> quicksilver: type Row a = [a]
08:45:51 <quicksilver> Rows are lists
08:45:54 <quicksilver> ignore me :)
08:46:09 <quicksilver> howebver, I was on the right track
08:46:16 <quicksilver> you can't <- from block!!a
08:46:27 <byorgey> ah, indeed =)
08:46:39 <Big_Red> hmm
08:46:46 <byorgey> I think you just want let x = block!!a
08:46:46 <quicksilver> if grid is [Row a] then grid!!a is one Row
08:46:51 <quicksilver> so block is just one element
08:46:52 <Big_Red> = instead of <- then
08:47:19 <quicksilver> yes, let x = block!!a
08:47:19 <byorgey> Big_Red: alternatively, you could just say [ block !! a | a <- ...  ] and leave off that last clause
08:47:25 <quicksilver> yeah that too
08:48:02 <byorgey> wait, no
08:48:10 <byorgey> grid :: [[a]]
08:48:23 <byorgey> er, sorry, let's use t
08:48:26 <byorgey> grid :: [[t]]
08:48:33 <byorgey> so grid!!a :: [t]
08:48:36 <byorgey> so block :: t
08:49:23 <byorgey> Big_Red: block <- grid!!a means, iterate through all the elements of grid!!a
08:49:38 <byorgey> Big_Red: but I think what you are trying to do is just pull out the ath element of grid.
08:49:57 <Big_Red> trying to pull out the diagonal elements of a matrix
08:50:20 <Big_Red> so the 1st element from the first list, second element from second list..
08:50:23 <dcoutts> yo, byorgey, where did we get to with your "x-*" field patches?
08:50:45 <dcoutts> byorgey: I don't want to hold up your cabal hacking :-)
08:51:16 <byorgey> Big_Red: http://hpaste.org/5528#a1
08:51:40 <Big_Red> ah yes :)
08:52:01 <byorgey> dcoutts: I think we got to "it works, but is sort of inelegant".
08:52:25 <byorgey> dcoutts: but I am at something of a loss for how to make it more elegant, without a major restructuring of the parsing code.
08:53:33 <Big_Red> sorted - although i had to change a to go from 0..length grid-1
08:53:36 <Big_Red> thanks
08:54:10 <byorgey> Big_Red: the take-away lesson here is, in a list comprehension, x <- y  means, pull out *each* element of the list y in turn
08:54:25 <byorgey> > [ x^2 | x <- [1..3] ]
08:54:29 <lambdabot>  [1,4,9]
08:54:53 <byorgey> Big_Red: but maybe you knew that and just got confused. =)
08:55:34 <dcoutts> byorgey: aye. Hmm. Perhaps we should just chuck it in and wait for re-writing the parser some other time.
08:56:51 <byorgey> dcoutts: well, that's fine with me.  it's up to you.
08:57:47 <dcoutts> byorgey: so did you want to make any changes to the patch you sent in the other day?
08:58:23 <byorgey> dcoutts: the x-* fields patch?  I don't think so, but let me take a look
08:59:16 <dcoutts> byorgey: right, in that patch you said it should not be committed :-) so just want to check if it should now be committed.
09:00:22 <byorgey> dcoutts: ah, indeed =)
09:00:36 <byorgey> dcoutts: ok, I will at least change the patch comment and resubmit then
09:01:12 <dcoutts> byorgey: ok, thanks
09:01:39 <dons> ?users
09:01:40 <lambdabot> Maximum users seen in #haskell: 471, currently: 441 (93.6%), active: 17 (3.9%)
09:02:09 <dcoutts> g'morning dons
09:03:23 <dons> heya dcoutts
09:04:46 <shapr`> @yarr !
09:04:46 <lambdabot> Yeh scurvy dog...
09:06:33 <litb> hello
09:06:47 <litb> i'm just reading "Programming in Haskell" and i'm already liking it :)
09:07:04 <dons> its quite good
09:07:52 <dcoutts> aye, I think it's the best Haskell intro text
09:07:55 <byorgey> dcoutts: argh!  unrecorded x- field extensions code + pulling PackageDescription reorg patches = my first experience of the darcs exponential conflicts bug, perhaps?  =(
09:08:24 <dcoutts> byorgey: you'll have to unrecord your previous patch and then pull, then resolve conflicts
09:08:39 <litb> i especially like the encoding coe and the countdown problem so far :)
09:08:47 <byorgey> dcoutts: that's exactly what I'm doing, it's just that darcs is taking a really really long time to do the pull =(
09:08:59 <dcoutts> byorgey: perhaps just save a backup copy of the couple files you changed, since I totally reorganised those few files
09:09:13 <dcoutts> byorgey: I split PackageDescription module into three
09:09:15 <byorgey> dcoutts: well, I think it's too late
09:09:29 * byorgey sighs
09:09:51 <dcoutts> byorgey: well, all the text of your change is in the patch you sent to the list so it's all there, somewhere
09:10:15 <byorgey> dcoutts: yeah, I'm not worried about that
09:10:39 <byorgey> 27754 brent     25   0 13072 8880 4020 R  100  0.4   3:59.35 darcs
09:11:00 <byorgey> =(
09:11:10 <dcoutts> byorgey: I think there's no chance darcs could merge your patch through, because I mostly copied text out of PackageDescription into another module, then renamed back later.
09:11:32 <byorgey> dcoutts: yes, I agree.
09:11:36 <dcoutts> darcs cannot follow moving chunks from one file to another, only renaming whole files
09:12:25 <byorgey> dcoutts: right, there are definitely conflicts, which is why it's taking so long -- it's the dreaded pre-darcs-2 exponential conflict bug thingy...
09:12:40 <dcoutts> right
09:12:42 <litb> bah, i partially failed at the exam today o.O even thought the problems to solve were so easy :/
09:13:03 <byorgey> litb: that's too bad, why?
09:13:28 <litb> well, some were quite advanced, but the vast majority of them were quite simple
09:14:05 <litb> byorgey: well, frankly i don't know hehe
09:15:46 <byorgey> dcoutts: well, I killed darcs, made backup copies of the files I changed, reverted, and pulled, and now everything's peachy.  But I probably won't get around to resubmitting this patch today.
09:15:54 <dcoutts> byorgey: np
09:16:23 <byorgey> dcoutts: I'm glad you reorganized PackageDescription, though, it definitely needed it =)
09:16:50 <dcoutts> byorgey: aye, was far far too big. And we wanted the sanity checking to all be in one place.
09:17:08 <byorgey> dcoutts: yes, sanity checking in one place is good too.
09:19:44 <Big_Red> hmm ok i'm trying to do or.map.and.map (=='x') to a grid
09:20:13 <Big_Red> so i take a list of lists, i apply =='x' to each element of each list and apply and to each list then or to the grid as a whole...
09:20:25 <Big_Red> but its getting messsssy
09:20:44 <oerjan> Big_Red: or.map = any, and.map = all
09:21:53 <Big_Red> if i'm trying to map to the inner element would that be map(map blah grid) or map (map blah) grid?
09:22:07 <EvilTerran> map the elements of an [[a]]?
09:22:25 <Big_Red> yes?
09:22:37 <EvilTerran> does (a -> b) -> [[a]] -> [[b]] sound like the right type?
09:22:46 <oerjan> :t any (all (=='x'))
09:22:48 <lambdabot> [[Char]] -> Bool
09:22:53 <EvilTerran> ?type (map.map)
09:22:53 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
09:23:01 <oerjan> Big_Red: try that ^^
09:23:05 <Big_Red> hmm ok
09:23:14 <EvilTerran> yeah, do what oerjan says.
09:23:21 <EvilTerran> i'm just passing through. :P
09:23:46 <EvilTerran> ?type (or.map.and.map) (=='x')
09:23:47 <lambdabot>     Couldn't match expected type `[Bool]'
09:23:47 <lambdabot>            against inferred type `[a] -> [b]'
09:23:47 <lambdabot>     In the second argument of `(.)', namely `map'
09:23:50 <oerjan> although if you did it directly, it would be:
09:23:53 <Big_Red> works \0/
09:24:04 <oerjan> :t or.map (and.map(=='x'))
09:24:05 <lambdabot> [[Char]] -> Bool
09:27:45 <oerjan> btw if it were the other way around, it could simplify even more: any (=='x') = elem 'x'
09:28:02 <litb> hm, could someone explain how this evaluates? "(map.map) (\x -> x*2) [[1, 2, 3], [5, 6, 7]]"
09:28:03 <quicksilver> you can probably do that with 'swing'
09:28:13 <litb> i'm not getting through it :)
09:28:24 <quicksilver> litb: first substitute the effect of .
09:28:41 <oerjan> @unpl (map.map) (\x -> x*2) [[1, 2, 3], [5, 6, 7]]
09:28:42 <lambdabot> map (map (\ x -> x * 2)) [[1, 2, 3], [5, 6, 7]]
09:28:50 <litb> i mean, it passed (double) to map . then the other map gets (map double)
09:28:51 <oerjan>  @unpl can do that :)
09:28:59 <byorgey> (f.g) x ==> f (g x)
09:30:05 <oerjan> so it becomes [map (\ x -> x * 2) [1, 2, 3], map (\ x -> x * 2) [5, 6, 7]]
09:30:25 <oerjan> (essentially)
09:30:34 <litb> ah now i understood
09:30:37 <byorgey> @type map . map . map
09:30:38 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
09:30:48 <byorgey> @type fmap . fmap . fmap
09:30:49 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
09:31:18 <byorgey> lists of trees of Maybes, anyone? =)
09:31:21 <litb> while (map (2*)) wants a [a] , but map wants [a]  too map (map (2*)) wants a [[a]] then  i suppose
09:31:39 <byorgey> litb: exactly.
09:31:44 <monochrom> IO of STM of ST
09:31:51 <litb> hmm
09:32:03 <byorgey> monochrom: now, let's not be silly!
09:32:13 <byorgey> ;)
09:32:22 <oerjan> monochrom: does that make sense? hm, i guess it's not transforming, just nesting
09:34:10 * oerjan suddenly wonders if IOT [] would be nice for distributed computing :) )
09:34:50 <EvilTerran> wouldn't "IOT [] a" unMTL to [IO a]?
09:34:53 <litb> > let half (n+n) = n in half 10
09:34:54 <lambdabot>  Parse error in pattern at "in" (column 20)
09:35:04 <quicksilver> EvilTerran: yes, that's right.
09:35:11 <litb> i suppose that illega :/
09:35:16 <litb> *illegal
09:35:42 <quicksilver> EvilTerran: but bind would not make sense.
09:35:46 <EvilTerran> litb, indeed. altho some of us want to make *all* n+k stuff illegal.
09:36:00 <EvilTerran> ?type (>>=)
09:36:03 <litb> EvilTerran: oh, why is that?
09:36:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:36:09 <oerjan> EvilTerran: IOT cannot exist without some _serious_ rethinking what it should mean :D
09:36:20 <quicksilver> EvilTerran: bind would take all the 'RealWorlds' on the left
09:36:21 <EvilTerran> [IO a] -> (a -> [IO b]) -> [IO b] ...
09:36:31 <quicksilver> EvilTerran: and evolve them according to the new actions
09:36:43 <quicksilver> in otherworlds, it represents multiple (branching) real worlds
09:36:44 <EvilTerran> oerjan, i know that. it's fun to speculate, tho
09:36:58 <EvilTerran> litb, because it's an ugly little special case that isn't worth the added complexity to the language
09:36:58 <quicksilver> so, to do it, you'd have to pin down what a real world meant to something which could branch.
09:37:00 <EvilTerran> in short.
09:37:08 <EvilTerran> quicksilver, fork()!
09:37:09 <litb> EvilTerran: oh i see
09:37:15 <litb> fork_bomb() !
09:37:25 <EvilTerran> forever fork?
09:37:38 <litb> forever+1 fork() :)
09:38:02 <EvilTerran> hm... (fork :: Maybe PID), i guess
09:38:12 <MyCatVerbs> #!/bin/sh \n while true; do $0 & done
09:38:34 <monochrom> What about IOT IO a ?
09:38:44 <quicksilver> EvilTerran: right but fork() doesn't duplicate all state, and neither does forkIO.
09:38:44 <EvilTerran> :() {: &: }:
09:38:46 <litb> :(){ :|:& };: # :)
09:38:54 <oerjan> it's the bind that makes it interesting... liftIO (print "hi") >> lift []
09:38:55 <EvilTerran> oh, yeah, that's the one
09:38:59 <quicksilver> EvilTerran: of course, it's interesting to consider which state is does duplicate.
09:38:59 <litb> question, who was rite?
09:39:03 <litb> hehe
09:39:12 <quicksilver> EvilTerran: and if that's an interesting monad.
09:39:23 <EvilTerran> indeed
09:39:27 * EvilTerran wanders off
09:39:56 * litb hopes they didn't try it out
09:40:24 <oerjan> it's the fork monster! related to the cookie monster :[]
09:40:57 * monochrom looks for the spoon monster
09:41:22 <glen_quagmire> i'm making a (console) repl for a simple language. how can I make backspaces work? and possibly up down arrow history browsing?
09:41:40 <glen_quagmire> it should work both on linux and windows
09:41:41 <oerjan> @index System.Console.Readline
09:41:41 <lambdabot> bzzt
09:41:57 <oerjan> i don't think Readline works on windows :(
09:41:58 <monochrom> Yeah, use Readline.
09:42:24 <monochrom> Why is windows always holding back progress?
09:43:07 <oerjan> something about mingw providing readline but not the actual header files
09:43:09 <litb> doesn't it emit a character code too?
09:43:34 <quicksilver> force your windows users to use emacs
09:43:40 <quicksilver> which provides its own line editing.
09:43:41 <quicksilver> :P
09:43:42 * litb 's dumb asking round
09:43:59 <glen_quagmire> is there a way to make my own backspace library?
09:44:01 <monochrom> Set stdin's buffering to NoBuffering. Then you can getChar and get instant response.
09:44:13 <glen_quagmire> i think history browsing is too much. i just want to make backspace work
09:44:41 <glen_quagmire> maybe i cache a line and reprint after dropping a char
09:44:49 <litb> and use \b to clear the current line i think
09:44:56 <quicksilver> try vty?
09:45:00 <faxathisia> Why not use something like emacs for the interface?
09:45:02 <quicksilver> (or doesn't that support windows?)
09:45:10 <glen_quagmire> > drop 1 "hi"
09:45:13 <lambdabot>  "i"
09:45:21 <faxathisia> > init "hi"
09:45:21 <lambdabot>  "h"
09:45:23 * oerjan bets there is some stupid licence problem that prevents those header files from being used
09:45:28 <litb> > "hel\boh"
09:45:29 <lambdabot>  "hel\boh"
09:45:32 <litb> hm, darn
09:45:36 <glen_quagmire> > init "foobar"
09:45:36 <lambdabot>  "fooba"
09:45:40 <glen_quagmire> oh nice
09:46:06 <faxathisia> > reverse . drop 1 . "raboof"
09:46:06 <lambdabot>  Couldn't match expected type `a -> [a1]'
09:46:12 <faxathisia> > reverse . drop 1 $ "raboof"
09:46:12 <lambdabot>  "fooba"
09:46:31 <glen_quagmire> so, getLine can't be used
09:46:43 <litb> use getChar
09:46:43 <faxathisia> (It may make sense to operate on a 'reversed' version of the input string)
09:47:17 <litb> i could imagine there is a short and nice function that does all you want.
09:48:16 <litb> but that again would reqire putting the terminal in raw mode so that oit emits control characters too. or does haskell do that automatically for getChar?
09:52:14 <glen_quagmire> what is backspace character?   c = ' ???? '
09:52:22 <glen_quagmire> what is backspace character?  if c == ' ???? '
09:52:42 <faxathisia> > ["\0"..] :: String
09:52:43 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
09:52:48 <allbery_b> > toEnum 8 :: Char
09:52:48 <faxathisia> > ['\0'..] :: String
09:52:49 <lambdabot>  '\b'
09:52:49 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
09:52:58 <oerjan> > '\?' -- DEL
09:52:58 <lambdabot>  Illegal escape sequence at "'\?'" (column 1)
09:53:05 <oerjan> what the?
09:53:10 <faxathisia> > ['\NAK'..] :: String
09:53:10 <lambdabot>  "\NAK\SYN\ETB\CAN\EM\SUB\ESC\FS\GS\RS\US !\"#$%&'()*+,-./0123456789:;<=>?@AB...
09:53:12 <allbery_b> > toEnum 127 :: Char
09:53:12 <lambdabot>  '\DEL'
09:53:15 <litb> woot?
09:53:30 <oerjan> > toEnum 8
09:53:31 <lambdabot>  8
09:53:34 <oerjan> > toEnum 8 :: Char
09:53:41 <lambdabot>  '\b'
09:53:45 <glen_quagmire> so it's '\b'
09:54:00 <litb> i told you many years before :D
09:54:19 <litb> oh well but by accident lol
09:55:04 <glen_quagmire> > putStr ['\b']
09:55:05 <lambdabot>  <IO ()>
09:55:08 <lQg> how to merge a list without adding spaces?
09:55:30 <ski> > concat ["foo","bar"]
09:55:30 <lambdabot>  "foobar"
09:55:31 <Deewiant> > concat ["foo","bar"]
09:55:31 <lambdabot>  "foobar"
09:55:33 <Deewiant> :-)
09:55:37 <lQg> thanks :D
09:56:00 <litb> how would it add spaces otherwise?
09:56:11 <ski> > unwords ["foo","bar"]
09:56:12 <lambdabot>  "foo bar"
09:56:12 <Deewiant> > intercalate " " ["foo","bar"]
09:56:12 <lambdabot>   Not in scope: `intercalate'
09:56:16 <Deewiant> bah
09:56:27 <faxathisia> :t intersperse
09:56:28 <lambdabot> forall a. a -> [a] -> [a]
09:56:31 <litb> oh i see
09:56:32 <ski> @hoogle intercalate
09:56:33 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
09:56:33 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
09:56:33 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
09:56:53 <paolino> what'S intercalate, a latin memory ?
09:56:56 <ski> @src Data.List.intercalate
09:56:56 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
09:56:59 <Deewiant> @pl intercalate xs xss = concat $ intersperse xs xss
09:56:59 <lambdabot> intercalate = (join .) . intersperse
09:57:32 <Deewiant> > ((join .) . intersperse) " " ["foo","bar"]
09:57:32 <lambdabot>  "foo bar"
09:57:35 <ski> lambdabot : i haven't
09:57:39 <oerjan> @src intercalate
09:57:39 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
09:57:57 <byorgey> paolino: it's a real word, apparently!
09:58:05 <byorgey> a real english word, I mean
09:58:14 <smedeiros> hi, I am a newbie and I would like to create a new type, that seems like an union type
09:58:19 <oerjan> ski: afaik @src doesn't do module prefixes
09:58:19 <glen_quagmire> does haskell have mutable stack?
09:58:26 <ski> oerjan : ic
09:58:29 <Deewiant> yeah, intercalate means "to insert a day or month into the calendar"
09:58:37 <glen_quagmire> i'm making a stack based language
09:58:41 <smedeiros> something like this:  mytype = Int | String | [mytype]
09:58:50 <paolino> byorgey: , it looks like one of my monstruosities
09:58:55 <ski> glen_quagmire : why do you need mutable stack ?
09:59:01 <byorgey> smedeiros: data MyType = MyInt Int | MyString String | MyList [MyType]
09:59:06 <glen_quagmire> ski: how can i simulate?
09:59:26 <smedeiros> thanks :-)
09:59:33 <faxathisia> data EitherOr a b c = Left' a | Middle b | Right' c
09:59:45 <glen_quagmire> oh google "stack haskell" has tutorial
09:59:45 <faxathisia> type Foo = EitherOr Int String [MyType]
09:59:49 <ski> glen_quagmire : you haven't clarified whether you need mutability, yet
10:00:05 <Beelsebob> @hoogle ln
10:00:09 <glen_quagmire> i ust need to store some values and pop and push
10:00:09 <desegnis> faxathisia: nice irony to call it  Â»either orÂ« if there's a middle way
10:00:12 <lambdabot> Prelude.putStrLn :: String -> IO ()
10:00:12 <lambdabot> Prelude.readLn :: Read a => IO a
10:00:12 <lambdabot> System.IO.hPutStrLn :: Handle -> String -> IO ()
10:00:17 <Beelsebob> bah
10:00:18 <faxathisia> :P
10:00:25 <byorgey> smedeiros: sure.  one important point to note is that type names must start with a capital letter.
10:00:30 <Beelsebob> @hoogle log
10:00:30 <lambdabot> Prelude.log :: Floating a => a -> a
10:00:30 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
10:00:30 <lambdabot> GHC.Conc.Logoff :: ConsoleEvent
10:00:36 <Deewiant> > log 2
10:00:36 <lambdabot>  0.6931471805599453
10:00:37 <glen_quagmire> oh i think list is already a stack
10:00:49 <ski> glen_quagmire : indeed
10:00:54 <glen_quagmire> push a s = a : s;  pop s = head s
10:01:06 <litb> hehe
10:01:09 <smedeiros> I was trying to define something like: data MyType = Position Int
10:01:12 <faxathisia> push = (:) ; pop = head
10:01:13 <byorgey> well, pop = tail actually
10:01:24 <litb> but list is not mutating :/
10:01:27 <smedeiros> but this was not working
10:01:33 <desegnis> Beelsebob: yeah Prelude.log should preferably be called ln, but what do those CS people understand of mathematics anyway?
10:01:38 <byorgey> smedeiros: that should work fine.
10:01:39 <jedbrown> or, pop = splitAt 1
10:01:50 <glen_quagmire> > splitAt 1 [1,2,3]
10:01:50 <lambdabot>  ([1],[2,3])
10:01:56 <byorgey> smedeiros: what problem were you having?
10:02:06 <faxathisia> > splitAt 1 []
10:02:06 <lambdabot>  ([],[])
10:02:10 <faxathisia> > splitAt 1 [1]
10:02:11 <lambdabot>  ([1],[])
10:02:15 <Deewiant> @pl \a -> (head a, tail a)
10:02:15 <lambdabot> liftM2 (,) head tail
10:02:31 <faxathisia> > splitAt 1 [[]]
10:02:31 <lambdabot>  ([[]],[])
10:02:59 <smedeiros> I defined:  myid :: MyType -> MyType    myid a = a
10:03:02 <ski> @type \xs -> case xs of [] -> Nothing; x:xs -> Just (x,xs)
10:03:02 <lambdabot> forall t. [t] -> Maybe (t, [t])
10:03:04 <oerjan> :t head &&& tail
10:03:05 <lambdabot> forall a. [a] -> (a, [a])
10:03:15 <faxathisia> smedeiros: Why?
10:03:17 <byorgey> smedeiros: ok, that looks good
10:03:30 <byorgey> smedeiros: but note there is already a function called 'id' with type  a -> a
10:03:33 <litb> > (head &&& tail) "hello all"
10:03:34 <lambdabot>  ('h',"ello all")
10:03:40 <byorgey> smedeiros: which means it will work for any type, including MyType
10:03:51 <smedeiros> yes, I know. when I type on ghci:  myid 3
10:03:53 <glen_quagmire> wow &&&
10:04:04 <faxathisia> > (uncurry (:)) ('h', "i")
10:04:04 <lambdabot>  "hi"
10:04:10 <byorgey> smedeiros: ah, but 3 does not have type MyType.
10:04:23 <ski> (not yet)
10:04:25 <byorgey> smedeiros: you would have to say myid (Position 3)
10:04:26 <Deewiant> smedeiros: myid (Position 3)
10:04:57 <litb> that looks silly
10:05:32 <litb> couldn't you make MyType an instance of Num to make 3 a MyType ?
10:05:40 <smedeiros> aahh, ok. I should build an object of MyType first
10:05:44 <byorgey> smedeiros: the statement  data MyType = Position Int  means that values of type MyType must look like "Position x" where x is some Int value
10:05:49 <byorgey> smedeiros: yes, exactly
10:05:56 <byorgey> litb: shh!
10:05:59 <byorgey> ;)
10:06:17 <oerjan> litb: use newtype deriving :D
10:06:37 <smedeiros> ok, thank you :-)
10:06:38 <visof> i try to install lambdabot with ghc-6.8.2 and i have
10:06:40 <visof> Setup.hs: At least the following dependencies are missing:
10:06:41 <visof>     arrows -any, zlib -any, binary >=0.2, plugins >=1.0, oeis -any
10:06:54 <visof> that's in configuration
10:07:09 <visof> i installed zlib and arrows
10:07:14 <visof> and binary
10:07:39 <allbery_b> missing --user?
10:07:49 <allbery_b> (depending on how you installed arrows etc.)
10:08:13 <litb> oerjan: oh is that possible?
10:08:35 <litb> newtype Foo a = Foo Int deriving Num , then i can do 10 where Foo a is required?
10:08:36 <oerjan> litb: i assume so, it's a ghc extension
10:09:12 <oerjan> you probably must add Show and Eq too
10:09:17 <oerjan> @src Num
10:09:17 <lambdabot> class  (Eq a, Show a) => Num a  where
10:09:17 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:09:17 <lambdabot>     negate, abs, signum     :: a -> a
10:09:17 <lambdabot>     fromInteger             :: Integer -> a
10:09:42 <visof> allbery_b what should i do?
10:10:31 <paolino> Foo 10 + Foo 5 , I suppose
10:11:03 <paolino> not 10 + 5 :: Foo
10:11:06 <oerjan> 10 + 5 :: Foo whatever should work
10:11:12 <paolino> ah
10:11:20 <oerjan> :t 10
10:11:20 <lambdabot> forall t. (Num t) => t
10:11:44 <dcoutts> yo SyntaxNinja, any thought on the proposal for a Sun / Haskell.org joint project?
10:12:29 <allbery_b> visof: not enough information.  how did you install arrows, zlib, binary?  plugins is hs-plugins, and has problems in 6.8.2 last I heard (someone (Cale?) has patches but they're not released yet)
10:12:41 <Cale> They're released.
10:12:43 <allbery_b> no idea about oeis if it's not on hackage
10:12:56 <Cale> (to the darcs repo)
10:13:29 <oerjan> @versold
10:13:29 <lambdabot> Unknown command, try @list
10:13:44 <oerjan> @versiold
10:13:44 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
10:13:45 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:14:16 <faxathisia> Cale, sorry I had to run off (was late for a class), I think all the time is spent recomputing things
10:14:45 <faxathisia> I don't think there's a way to fix it though.. because what I was doing is sort a silly approach
10:14:54 <faxathisia> sort of *
10:16:29 <faxathisia> (I got this far before realizing... http://hpaste.org/5527 )
10:17:13 * ski ponders how to best phrase the left identity law for a monad ..
10:17:56 <visof> i can't find hs-plugins in Hackage
10:18:13 <ski> should i state an equality over `M  >->  M', or over `1 . M  >->  M' ?
10:19:10 <oerjan> @where hs-plugins
10:19:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
10:19:38 * oerjan takes no responsibility for whether that is the newest version
10:19:39 <BMeph> Is there a way to have a package registered with a different name (i.e., tell lambdabot that fps is bytestring)?
10:19:58 <dons> BMeph: try just using the latest lambdabot from darcs
10:20:05 <dons> code.haskell.org/lambdabot
10:20:26 <SyntaxNinja> hell0
10:20:54 <dons> SyntaxNinja!
10:20:57 <BMeph> dons: Okay, thanks. Any special reason why you haven't updated hackage? ;)
10:21:00 <dons> hmm. haskell.org down?
10:21:05 <Saizan> @where+ hs-plugins-repo http://code.haskell.org/~dons/code/hs-plugins/
10:21:05 <lambdabot> It is stored.
10:21:09 <dons> BMeph: no time to maintain hs-plugins, unfortunately
10:21:19 <dons> anyone else access haskell.org?
10:21:28 <BMeph> w00t! Hey there, SyntaxNinja! Nice blog piece. :)
10:21:42 <Saizan> dons: i do, via http
10:21:46 <dons> hmm
10:22:21 <dons> http://haskell.org
10:22:21 <lambdabot> Title: Haskell Community Server
10:22:24 <dons> hmm
10:22:31 <SyntaxNinja> BMeph: thanks. which one?
10:22:44 <litb> i am unable to access it, dns
10:22:51 <dons> litb: ok. thanks
10:23:23 <BMeph> SyntaxNinja: I don't recall, so it's likely one you did a couple of days ago. I just remember that it was rather good. :)
10:24:03 <SyntaxNinja> BMeph: thanks.  probably the one about micro finance.  I really want to get involved in that stuff.
10:24:29 <SyntaxNinja> BMeph: I felt kinda bad though distracting the point of the post with a cheap shot at bill gates, but I guess he's trained me like that ;)
10:24:38 <BMeph> SysntaxNinja: Yes, I think that was it - I'll just have to slurp my RSS feed again... ;)
10:25:06 <visof> http://hpaste.org/5530
10:25:34 <BMeph> SyntaxNinja: Heh-heh, I think Ol' Bill's probably not crying in his pillow about it, anyhow. ;)
10:25:57 <SyntaxNinja> yeah. I'm not too worried about bill
10:26:19 * dons checks SyntaxNinja's blog. sees maybeRead defined, and wonders if its about time that got in the standard library
10:26:37 <dons> yav reckons maybeRead is defined once per module on average
10:26:38 <dcoutts> dons: it's about time ReadS was replaced with something sane :-)
10:26:54 <dons> well, that's a bit more controversial
10:26:56 * dcoutts does not mean ReadP either
10:26:56 <SyntaxNinja> dons: totally.
10:27:13 * olsner wonders where SyntaxNinja keeps his blog
10:27:16 <SyntaxNinja> dons: there are a couple of things in there that could be encapsulated
10:27:20 <SyntaxNinja> olsner: www.syntaxpolice.org
10:27:24 <dons> where would maybeRead go? Text.Read ?
10:27:26 <SyntaxNinja> olsner: also echo'd on Planet.haskell
10:27:36 <dons> yes, Text.Read looks good
10:27:42 <olsner> aha, maybe one should check out planet haskell some day
10:28:10 * dcoutts tries to ssh to haskell.org to resurrect the web server
10:28:21 <dons> hmm. thanks dcoutts
10:29:36 <SyntaxNinja> dcoutts: hrm. let me know if I can help
10:30:27 <dcoutts> SyntaxNinja: main thing probably is hosting and how we go about selecting and funding someone. If sun offers project funding, great, otherwise we'd probably have to do it as a GSoC project.
10:32:30 * SyntaxNinja nods
10:35:24 <dcoutts> SyntaxNinja: do you think there's any chance we could at least temporarily host a 1U box with galois? In the long term if it works out well we could use that server for community.haskell.org and pay for co-lo like we currently pay for the current virtual server.
10:35:27 <tibbe> do what as a soc project? :)
10:35:41 <dcoutts> tibbe: get ghc working nicely on multi-core sparc boxes
10:35:50 <dons> dcoutts: yeah, i think that's possible. /me looks at the rack room.
10:35:53 <tibbe> dcoutts: ah
10:36:01 <dcoutts> tibbe: fixing the sparc native code gen and running parallel benchmarks
10:36:12 <dons> dcoutts: i wonder if we could work on the sparc port during the hackathon,
10:36:20 <dons> and then get it "sponsored by sun" :)
10:36:32 <siti> maybe they'll dump java then ;)
10:36:45 <dcoutts> dons: maybe, though I'd prefer to direct people's attention to hackage :-)
10:37:00 <dons> ah, yes, reminds me that i've got a concrete spec now to run by you
10:37:36 <paolino> siti, it can be possible after ms buy yahoo
10:37:39 <dcoutts> dons: I think 3 days is probably too short to get it working anyway, especially if it involves correspondence with Sun people (they've offered to help via email with tools and stuff)
10:37:45 <tibbe> could anyone give me some pointers to texts on building incremental parsers?
10:37:46 <dons> ah great.
10:38:20 <pejo> dcoutts, "tools and stuff"?
10:38:40 <dcoutts> pejo: linkers, compilers etc I think it what they meant.
10:38:46 <SyntaxNinja> dcoutts: it's possible, but Galois doesn't have enough external IP addresses at the moment :(
10:38:50 <SyntaxNinja> I can ask, though.
10:38:51 <dcoutts> pejo: btw, I got the NCG to compile again.
10:38:56 <SyntaxNinja> we're going to be moving soon, so we might get more.
10:39:16 <pejo> dcoutts, that's great! How did you do the reg->reg move?
10:39:35 <dcoutts> SyntaxNinja: ah, well I guess it's possible to go via a gateway. Initially there'd not be a lot of people logging in, just the couple working on the project.
10:40:04 <dcoutts> SyntaxNinja: it'd only be later that we'd want to open it up and run it in the same way we operate community.h.o server
10:40:47 <dcoutts> pejo: well a reg->reg move on sparc is just "or %src 0 %dst"
10:41:15 <dcoutts> pejo: and we can pattern match on that for recognising redundant reg->reg moves
10:41:22 <pejo> dcoutts, doh. And I was looking for a correspondence to 'mov'.
10:41:22 <SyntaxNinja> dcoutts: do you want me to ask if it's possible at this point?
10:41:24 <dcoutts> pejo: though I'm less sure about floating point moves.
10:41:44 <pejo> dcoutts, you have FMOV in the ncg for sparc iirc.
10:41:58 <dcoutts> SyntaxNinja: I'm not looking for an absolute commitment, just a vague likelyhood.
10:42:04 <SyntaxNinja> OK cool. I'll check.
10:42:18 <dcoutts> pejo: yes, I added that too, but a bit unsure.
10:42:28 <dcoutts> pejo: the main thing I got stuck on was jump tables.
10:42:39 <pejo> dcoutts, are your fixes checked in?
10:43:07 <visof> @where oeis
10:43:07 <lambdabot> I know nothing about oeis.
10:43:10 <dcoutts> pejo: no, I've recorded a simple patch that just identifies more clearly where the fixes are required, since I'm not at all sure my fixes were correct.
10:43:13 <pejo> dcoutts, what about the jump tables?
10:43:22 <visof> how can i get oeis ?
10:43:32 <dcoutts> pejo: so now you get #error rather than runtime errors for the missing bits :-) that's a great improvement.
10:43:41 <SyntaxNinja> glguy: !!
10:43:54 <jedbrown> @go oeis
10:43:54 <glguy> where?!
10:43:55 <lambdabot> http://www.research.att.com/~njas/sequences/
10:43:55 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
10:43:56 <pejo> dcoutts, nods, I was pondering doing such a patch. It's better to not build with a clear error rather than a parse error.
10:44:25 <dcoutts> pejo: I'd got stage1 to compile and was using it with -fasm to compile the rts and libs before discovering a panic about a missing function. So I replaced the runtime panic with an cpp-time #error.
10:44:35 <oerjan> @go Math.OEIS
10:44:36 <lambdabot> No Result Found.
10:44:37 <Tac-Tics> @hoogle IO Int
10:44:37 <lambdabot> Data.Typeable.typeRepKey :: TypeRep -> IO Int
10:44:38 <lambdabot> GHC.Conc.asyncDoProc :: FunPtr (Ptr a -> IO Int) -> Ptr a -> IO Int
10:44:51 <dcoutts> pejo: so yes, 4 places need fixing. The main tricky one is generating jump tables for CMM switch statements
10:45:09 <dcoutts> pejo: I'll send my patch later today
10:45:32 <pejo> dcoutts, didn't the old ncg have such functionality?
10:45:47 <dcoutts> pejo: I've no idea, if so it's not there now.
10:45:52 <pejo> dcoutts, oh, I'm not in a hurry, just enthusiastic bystander.
10:45:53 <dcoutts> could check ghc-6.2.2
10:46:23 <Tac-Tics> @src genSym
10:46:23 <lambdabot> Source not found. Are you on drugs?
10:46:33 <Tac-Tics> (isn't there a gensym somewhere?)
10:46:40 <Deewiant> @hoogle gensym
10:46:41 <lambdabot> No matches found
10:47:14 <oerjan> @index Data.Unique
10:47:14 <lambdabot> bzzt
10:47:26 <oerjan> @hoogle Data.Unique
10:47:26 <lambdabot> No matches, try a more general search
10:47:31 <visof> after configure lambdabot i have:
10:47:34 <visof> Configuring lambdabot-4.0...
10:47:35 <visof> Setup.hs: At least the following dependencies are missing:
10:47:35 <visof>     plugins >=1.0, oeis -any
10:47:39 <oerjan> @hoogle Unique
10:47:39 <lambdabot> Data.Unique :: module
10:47:39 <lambdabot> Data.Unique.Unique :: data Unique
10:47:39 <lambdabot> Data.Unique.newUnique :: IO Unique
10:47:46 <oerjan> O_O
10:47:48 <Tac-Tics> Thanks
10:48:06 <visof> i have errors with installing hs-plugins
10:48:12 <visof> and i can't find oeis
10:48:20 <visof> what should i do?
10:48:22 <davidL> @hackage oeis
10:48:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/oeis
10:48:59 <dons> dcoutts: are you able to ssh in?
10:49:01 <pejo> dcoutts, there was a "genJump" function in 6.4. Quite often the code for ppc is useful as reference, but it's a newer backend so it's not always the same.
10:49:04 <dcoutts> dons: no
10:49:12 <visof> http://hpaste.org/5530
10:49:16 <dons> thanks. i'll ping paul h.
10:49:37 <paolino> dcoutts: here also :(
10:50:21 <dons> ok. i've pinged paul, he'll contact the yale admins, and should be back up shortly
10:50:40 <Tac-Tics> > Unique 5
10:50:42 <lambdabot>   Not in scope: data constructor `Unique'
10:50:44 <dons> mailing list is down too
10:51:12 <paolino> what system is running there ?
10:51:27 <dons> a newish linux box, running mediawiki, mailman, et al
10:51:37 <oerjan> Tac-Tics: it's abstract i think, and can only be created in IO
10:51:38 <paolino> ubuntu ?
10:51:44 <dons> don't think so.
10:52:13 <Tac-Tics> oerjan: I can't figure out why it doesn't just return an Integer =-< it puts it in an unexported constructor, it seems
10:52:24 <paolino> should be a bsd :)
10:52:24 <Deewiant> is haskell.org down, or is it just me?
10:52:28 <Tac-Tics> and you have to use hashUnique to get it out of its box
10:52:36 <paolino> down
10:52:56 <Deewiant> meh. thanks for the info
10:54:37 <visof> i can't install plugins and hs-plugins
10:54:45 <visof> please can anyone help me?
10:54:46 <dons> visof: using the darcs repo of hs-plugisn?
10:54:54 <dcoutts> pejo: jump table code seems to have been done generically above the machine specific layer in the old NCG in 6.2.2
10:54:58 <dons> why is everyone installing hs-plugins all of a sudden?
10:55:18 <visof> dons for lambdabot
10:55:28 <dcoutts> dons: because they don't have enough pain in their lives :-)
10:55:30 <visof> i want to install lambdabot
10:55:48 <dons> why does everyone want to install lambdabot? :)
10:55:58 <visof> nice question
10:56:00 <paolino> lonelyness
10:56:03 <faxathisia> @vixen :P
10:56:03 <lambdabot> there are a lot of weirdos on here
10:56:07 <dons> heh
10:56:22 <Tac-Tics> dons: among botkind, she's a really good lover
10:56:25 <dons> probably with a bit of Cale help we can get both on hackage
10:56:59 <Cale> :)
10:56:59 <dons> anyone know why the hell getEnv throws an exception?
10:57:03 <pejo> dons, doesn't Galois need hs-plugins? ;)
10:57:35 <dons> if they did, it'd be in better shape :)
10:57:37 <oerjan> @hoogle getEnv
10:57:38 <lambdabot> System.Environment.getEnv :: String -> IO String
10:57:38 <lambdabot> System.Environment.getEnvironment :: IO [(String, String)]
10:57:58 <pejo> dcoutts, ah. Well, any improvement makes the task of fixing it seem smaller to others, and eventually someone will get fed up and just fix it. :-)
10:58:17 <dcoutts> pejo: aye
10:58:35 <oerjan> dons: you mean it should have been IO (Maybe String) ?
11:00:06 <lispy> or IO (Either String String)
11:00:30 <MyCatVerbs> lispy: what on Earth would the left value be in that case?
11:00:33 <lispy> or it could even return "" when it's not defined
11:00:35 <oerjan> MonadPlus m => IO (m String) :)
11:00:46 <lispy> MyCatVerbs: the message in the exception it throws now
11:01:25 <MyCatVerbs> lispy: that seems inelegant, possibly even crazy.
11:01:38 <shapr`> dons: hs-plugins r0xx0rs
11:01:48 <oerjan> :t Data.Map.lookup
11:01:49 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
11:02:02 <lispy> MyCatVerbs: my reasoning: they deemed an exception worthwhile, and thus probably even had a message to throw with it.  So why not preserve that message.
11:02:05 <MyCatVerbs> lispy: but MonadPlus m => IO (m String) seems perfectly sensible and sane to me, so what do I know? :)
11:02:37 <shapr`> I had a really great use for hs-plugins recently, I wonder what it was...
11:02:44 <lispy> i'll be honest, I don't remember what MonadPlus is
11:02:56 <lispy> shapr`: does boston make you forgetful ;)
11:03:11 <oerjan> lispy: mplus and mzero
11:03:16 <paolino> a way to respond to fails ??
11:03:23 <lispy> oerjan: why is that useful for reporting errors?
11:03:54 <oerjan> lispy: actually i was thinking of that Data.Map.lookup, seems it just uses Monad
11:04:18 <oerjan> (presumably with fail)
11:05:07 <Twey> Who killed haskell.org?  :-(
11:05:38 <lispy> oerjan: yeah, but then Cale will arrive if you say that and try to reason that fail doesn't belong in Monad :)
11:05:39 <oerjan> hm perhaps MonadIO m => m String would be good enough
11:05:47 <lispy> oerjan: (and I can see his point)
11:06:17 <MyCatVerbs> Wouldn't MonadError be what you're after?
11:06:21 <oerjan> lispy: sure but you discarded MonadPlus essentially because it doesn't have fail, didn't you? :)
11:06:40 <Cale> lispy: haha
11:06:41 <Cale> :)
11:06:41 <oerjan> MyCatVerbs: getEnv needs some kind of IO access
11:07:09 <lispy> oerjan: no, i just never considered it because it's not something i'm familiar with :)
11:07:29 <MyCatVerbs> oerjan: ah. MonadError m => String -> IO (m String) -- is considered stupid?
11:07:58 <oerjan> MyCatVerbs: it's sort of weird to nest monads that way
11:08:12 <lispy> oerjan: why?
11:08:28 <lispy> it doesn't seem that odd to me, but then i'm barely more than a novice
11:09:22 <oerjan> whatever
11:09:25 <lispy> oerjan: I mean, say you use MonadIO
11:09:35 <lispy> oerjan: how does MonadIO report fail?
11:09:38 <lispy> ?src MonadIO
11:09:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:09:44 <oerjan> you could use both MonadIO and MonadError
11:09:48 <lispy> right
11:09:54 <lispy> MonadIOError
11:09:58 <shapr`> lispy: Nah, I'm forgetful all by myself. But lack of sleep does make it easier... and there's so much fun stuff to do that it's hard to sleep.
11:10:29 <oerjan> _however_, MonadError isn't really for String messages. if you use it for that, you get just ordinary fail
11:10:38 <oerjan> @src Either fail
11:10:39 <lambdabot> fail msg      = Left (strMsg msg)
11:11:44 <oerjan> it's for a more general error type, with a conversion function from Strings used by fail
11:14:10 <lispy> I think that's why I tend to use Either String a for errors
11:14:14 <dons> oerjan: yeah
11:18:28 <lispy> Ya know what would be a cool project for someone?
11:18:40 <lispy> to integrate ghc-api with template haskell
11:19:01 <shapr`> Is the ghc-api documented now?
11:19:03 <lispy> so that you could programtically transform your modules at compile time
11:19:38 <lispy> shapr`: I'm not sure, but the source to visual haskell is available, and afaik that's the most extensive use of ghc-api
11:21:08 <lispy> my thinking is that lisp wouldn't really have any bragging writes about macro magic if we had that :)
11:22:00 <dons> macros bah. one good way to make it hard to reason about your code
11:22:12 <sebell> lispy: Well, except for the fact that Lisp macros `feel' right, because you're transforming first class values in the language (lists, symbols, etc.)
11:22:14 <dons> you have to start thinking about staging and meta programming issues
11:22:36 <sethk> I'm having problems getting to haskell.org.  Anybody else having this problem?
11:22:46 <lispy> dons: so are you against meta programming?
11:22:48 <dolio> Would that give you the ability to extend the parser to make new syntax?
11:23:09 <lispy> dolio: no I don't think so.
11:23:20 <dolio> That's probably what (or, one thing) you'd need to claim parity with lisp macros.
11:23:29 <mrd> higher order functions address one area of macro usage.  Generic Programming seems to address another area.
11:23:31 <lispy> dolio: but you could parse what ghc can parse then transform the syntax tree and compile the result
11:24:17 <dolio> Since lisp macros let you define new variants on what syntax lisp does have.
11:24:31 <monochrom> Programming language research continues to marginalize the utility of macros.
11:24:39 <phobes> I think the case for 'code as data' meta programming is really about the ability to customize tools
11:25:18 <dons> lispy: i just think that it makes programs harder to reason about, so should be used with care. not as a ubiquitous technique
11:25:22 <oerjan> sethk: yep
11:25:42 <lQg> @hoogle elem
11:25:43 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
11:25:43 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
11:25:43 <lambdabot> Data.Foldable.elem :: (Foldable t, Eq a) => a -> t a -> Bool
11:25:44 <dons> the tradeoff of power against no one understanding what your code does
11:25:45 <sethk> oerjan, thanks.
11:25:48 <dcoutts> dons: yes, staged programming can have a semantics, macros are much harder
11:26:01 <opqdonut> staged?
11:26:16 <dons> yeah, at least with explicit staging you can work out what's happening when
11:26:23 <mrd> dons: the same reasoning can be used to argue against functions
11:26:26 <dcoutts> opqdonut: a program that accepts some input and generates a program which then accepts more input
11:26:49 <mrd> and probably was used, back when functions were "new" in like, 1960
11:26:54 <lispy> well, then so if we can't agree that the merger of ghc-api and TH is good.  How about someone works on an interactive type inference debugger for GHC :)
11:27:22 <phobes> dcoutts:  aren't macros just a staged language with really ugly semantics?
11:27:53 <mrd> the way macros are used in CL is mostly rendered moot by higher-order functions, and lazy evaluation
11:27:56 <dcoutts> phobes: right, you can use macros to implement staging, but the're much more powerful and hence harder to reason about
11:28:10 <dolio> I suppose you could make something simple like 'shift k E' ==> 'shift (\k -> E)' with TH, but the macro-ed version isn't much better than the higher-order abstract syntax.
11:28:11 <dcoutts> mrd: and decent optimisation
11:28:13 <mrd> the remaining stuff: type definitions and such that needs to be statically defined, does need to be dealt with
11:28:34 * monochrom looks at "staged programming can have a semantics" and thinks of fix (runghc | python | ruby) :)
11:28:36 <mrd> and there are specific proposals to do so, usually under the heading of Generic Programming, as far as I can tell
11:28:39 <oerjan> @users
11:28:40 <lambdabot> Maximum users seen in #haskell: 471, currently: 442 (93.8%), active: 19 (4.3%)
11:28:52 <dcoutts> mrd: I get the feeling that lisp macros are used to generate lots of lower level fast code, where we rely on inlining and clever compilers
11:29:20 <lispy> dcoutts: and also special forms (which we have laziness for)
11:29:21 <dcoutts> monochrom: heh, obviously I don't mean going via program text :-)
11:29:22 <mrd> in some cases.  lisp also has compiler-macros which are a blunt instrument for dealing with that situation too.
11:29:38 <phobes> mrd:  Laziness and generics don't get you explicit staging by themselves, right?  You still need annotations to control what's run at compile time to get similar capabilities
11:29:55 <phobes> (unless you don't care about when it's run)
11:30:03 <mrd> phobes: I'm not talking about staging though, I'm talking about the intent of the macros in the first place
11:30:27 <mrd> the intent of some macros is to generate type or class definitions, things that must be available at compile-time yes
11:31:30 <ski> what about looping-language macros like `foof-loop' ?
11:32:03 <phobes> mrd:  I'm just thinking that in general you can define a GADT for the AST of whatever embedded language you want, and then you can evaluate at runtime, but that means you're goign to be spending alot of time at runtime interpretting what the constructs mean
11:32:05 <dons> btw, if someone is looking for something fun to do, combine TH with the  new IsString class for inline, compile-time perl, ruby, python code
11:32:16 <phobes> mrd:  When usually you want that done at compile time
11:32:40 <dons> e.g. "sub ($x) { return ($x * 2); }" :: Perl would yield a funptr to perl
11:32:46 <Nafai> dons: Sweet!
11:32:57 <dons> i'd like to play with the idea some more, but don't have time
11:33:04 <Nafai> I wish I had time
11:33:14 <lispy> dons: multi-language programs make me nervous :)
11:33:17 <dons> :)
11:33:29 <Nafai> A friend and I once threw together a bridge between Python and Common Lisp...that was interesting :)
11:33:37 <lispy> dons: but allowing for in-line C or ASM might be cool actually.
11:33:46 <dons> yeah. inline C would be easiest
11:33:48 <lispy> dons: I can see how that's pragmatic, anyway
11:33:58 <dons> well, i'm not sure its pragmatic. just fun
11:34:09 <dons> overloaded literals give us a lot of the power of macros :)
11:34:12 <lispy> sure, it's pragmatic, for those tight inner-loops :)
11:34:43 <phobes> Is this a new trend to prepend classes with 'If'?
11:34:50 <phobes> err Is
11:34:59 <dons> not really. just that String was already taken.
11:35:04 <dons> and Stringish is not great
11:35:07 <Nafai> dons: How hard would that be to implement for a Haskell newbie? :)
11:35:22 <dons> mm. intermediate difficulty
11:35:56 <lispy> Nafai: if you could work with someone like dons to figure out how the different parts of the project interelate it would reduce the difficulty quite a bit.
11:36:17 * Nafai grumbles about the timing
11:36:24 <Nafai> Changing jobs and moving and all right now...
11:36:24 <noecksit> hello im not sure why, but my recursion problem at http://hpaste.org/5532 doesnt work
11:36:40 <phobes> Nafai:  Where you going?
11:36:56 <dcoutts> lispy, dons: c2hs allows inline C code.
11:37:07 <noecksit> particularly at rollDie
11:37:42 <dons> haskell.org on its way back up
11:37:52 <Nafai> phobes: Moving from Austin, TX to Draper, UT for a Senior Developer position with a company called Feature 50
11:37:57 <lispy> noecksit: what is wrong?
11:38:12 <noecksit> it says that it couldnt match the expected type
11:38:27 <lispy> noecksit: let's rearange your code a bit
11:38:43 <lispy> noecksit: see your lambda expression (\(x,y) ...) let's put that in a where clause
11:38:48 <noecksit> '(t, t1)' against inferred type
11:39:13 <phobes> Nafai:  A search didn't turn it up... back to games or something else?
11:39:28 <ski> the lambda (or the base case and the type signature) is misplaced
11:39:34 <Nafai> Nope, it's desktop software development
11:39:46 <Nafai> The first project is a Java Swing based application
11:39:54 <Nafai> But there is room for other projects in the future, it's a new company
11:40:01 <phobes> ah cool, good luck
11:40:04 <oerjan> noecksit: the y does not actually vary, it is the one generated at i=0 always
11:40:08 <phobes> (You may not realize that you know me :)
11:40:12 <desegnis> noecksit: in sumTwoDice, Â»rollDie seed0Â« does not give you a pair, because rollDie takes two arguments
11:40:17 <phobes> I'll email you
11:40:29 <Nafai> Yeah the nick isn't ringing a bell :)
11:40:43 <Nafai> Ah :)
11:40:55 <Nafai> I think I know who you are.  Hi!
11:41:00 <phobes> hi - you probably do: )
11:41:05 <phobes> I emailed you recently
11:41:37 <monochrom> This is like one of those "P: I don't know the numbers. S: I don't either. P: Oh, now I know! S: So do I!"
11:41:53 <phobes> Nafai:  It's telling me I can't send to you privately
11:42:00 <phobes> Nafai:  Because I'm not registered
11:42:03 <Nafai> Ah
11:42:12 * monochrom has recently registered :)
11:42:16 <phobes> Nafai:  You'd think that there would be an exception for someone who *just private chatted you*
11:42:19 <phobes> grrr
11:42:27 <phobes> Says it's for spam reasons
11:42:32 * phobes waves fist in the air
11:42:35 <noecksit> oerjan: oh ok, that is true, but i want to return the last seed as the output
11:43:08 <oerjan> !paste
11:43:14 <oerjan> hpaste is not here
11:43:20 <oerjan> http://hpaste.org/5532#a1
11:43:33 <oerjan> noecksit: i changed one of the y's to seed
11:43:36 <noecksit> desegnis: yea, i commented out that code for now
11:44:49 <lispy> oerjan: i'm not sure that's right
11:45:06 <lispy> noecksit: I would extract out  your mod function
11:45:11 <lispy> f (x,y) = ...
11:45:13 <lispy> in a where clause
11:45:36 <oerjan> lispy: it's untested but i don't know why it should be wrong...
11:47:52 <noecksit> seems to work fine, thanx, otherwise it was giving me the same number always
11:48:38 <noecksit> lispy: u mean i should put the lambda function in a where body?
11:48:55 <oerjan> noecksit: http://hpaste.org/5532#a2
11:49:03 <oerjan> i think that's what lispy means
11:49:42 <lispy> oerjan: not how I would write it (i would have done a function) but that still helps I think
11:50:09 <oerjan> i also removed some redundant parentheses
11:50:26 <lispy> noecksit: my mind is lazy and it's hard to read code all day, so I tend to break things up and create little clearly defined pieces like that
11:50:27 <oerjan> was getting too lispy for me ;)
11:50:33 * lispy too
11:51:23 <oerjan> :t mapAccumR
11:51:25 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:51:51 <oerjan> hm maybe not
11:52:50 <paolino> anyone uses prettyprint ?
11:53:04 <sethk> haskell.org is back
11:53:59 <dons> good
11:54:09 <quicksilver> dons: I think there is somethign funny about those Data.Stream types
11:54:28 <Twey> Yay
11:54:32 <quicksilver> dons: the data type info is being shown in GADT form. What GADT form does is show you the types of the constructors.
11:54:40 <quicksilver> dons: so I don't understand why they aren't matching.
11:55:12 <oerjan> > 1+1:[3] -- checking if he removed too much
11:55:15 <lambdabot>  [2,3]
11:55:39 <dons> hmm
11:55:57 <quicksilver> dons: there is a set of parens around the (s -> Step a s) in one type
11:56:01 <quicksilver> dons: and not in the other
11:56:06 <jedbrown> quicksilver: I would expect !(s -> Step a s) -> !s -> Stream a
11:56:07 <quicksilver> that is a pretty big difference!
11:56:31 <quicksilver> (s -> Step a s) -> X -> Y is pretty different to s -> Step a s -> X -> Y
11:56:38 <dons> oh yes, parens missing in the output
11:56:40 <quicksilver> (ignoring strictness annotations because that's not really the point)
11:57:01 <quicksilver> although it's possible the strictness annotations are the cause of the bug ;)
11:57:08 <quicksilver> bug in GHC's pretty printer for types
11:57:10 <dons> well, is it just missing parens ?
11:57:11 <dons> yeah
11:58:12 <jedbrown> dons: I would think :info should give the same as :type, but include strictness annotations.
11:58:47 <paolino> anyway, if anyone does use PrettyPrint , I'd like to see an implementation of tabulate :: [[String]] -> Doc where arg is  lines of words of different length and the result is a well tabulated table
11:59:48 <paolino> (lines should have all the same number of words)
12:00:05 <dolio> > read "1234monkey" :: Int
12:00:16 <lambdabot>  Exception: Prelude.read: no parse
12:00:31 <RayNbow> > reads "1234monkey" :: [(Int,String)]
12:00:31 <lambdabot>  [(1234,"monkey")]
12:01:12 <RayNbow> :t reads
12:01:15 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:08:30 <quicksilver> ooh, lectureships at notts
12:09:04 <sclv> > let readM s = case reads s of [(x, "")] -> return x; _ -> fail "No Parse" in maybeRead "a1234" :: Either String Int
12:09:06 <lambdabot>   Not in scope: `maybeRead'
12:09:18 <sclv> > let readM s = case reads s of [(x, "")] -> return x; _ -> fail "No Parse" in readM "a1234" :: Either String Int
12:09:18 <lambdabot>  Left "No Parse"
12:09:28 <sclv> why maybeRead instead of this?
12:10:00 <quicksilver> no strong reason
12:10:05 <quicksilver> it's just a special case of that
12:10:10 <oerjan> indeed there is already readIO
12:10:17 <oerjan> :t readIO
12:10:17 <lambdabot> forall a. (Read a) => String -> IO a
12:10:20 <quicksilver> although 'No Parse' is a bit deceptive
12:10:29 <Tac-Tics> Does reads ever return a list of length > 1?
12:10:38 <quicksilver> that also encompasses Ambiguous parse and incomplete parse
12:10:44 <quicksilver> Tac-Tics: not for any built in instance, no
12:10:52 <quicksilver> Tac-Tics: but you are free to write ones which do if you want :)
12:11:11 <sclv> quicksilver: yeah, just picked up what I recalled the typical error message was.
12:11:25 <quicksilver> I agree that readM is nice
12:11:32 <quicksilver> modulo the fact I hate fail :P
12:11:34 <sclv> anyway, seems to me that it's better to use the more general case when adding to the Base.
12:12:07 <oerjan> sclv: btw readIO like read allows trailing whitespace
12:15:03 <sclv> quicksilver: you just hate that fail is in the wrong place...
12:16:45 <quicksilver> sclv: right.
12:31:03 <monochrom> Why are all these home-brew hardware projects such as lambdacan and traffic lights for testing appear on programming.reddit? Shouldn't we be, like, building software instead?
12:31:33 <byorgey> monochrom: only useless things are cool.  didn't you get the memo?
12:31:49 <monochrom> haha
12:32:01 <monochrom> software is cool too :)
12:32:28 <sclv> building software is hard, let's etc.
12:32:34 <paolino> and ethnic music :)
12:32:47 <byorgey> sclv: lazy quote, eh? =)
12:32:54 <sclv> seriously we need a "not programming" bot.
12:33:19 <monochrom> software is hard, let's build hardware
12:33:46 <sclv> that would autorespond to anything with css in the title, or design, or links to yahoo news etc.
12:34:34 <Cale> sclv: heh, yeah
12:34:39 <Cale> sclv: I'm getting tired.
12:35:32 <monochrom> Where did you get all those css and design and links to yahoo news?
12:37:04 <dolio> Maybe an "I don't care about Arc stories" bot, too.
12:37:13 <paolino> I made mine http://hpaste.org/5533, I feel I invented warm water :)
12:42:13 <dynamix> what does ($$) do?
12:42:35 <monochrom> @hoogle $$
12:42:35 <lambdabot> Language.Haskell.TH.PprLib.($$) :: Doc -> Doc -> Doc
12:42:35 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<$$>) :: (a -> b) -> GenParser tok st a -> PermParser tok st b
12:43:14 <paolino> I think it's the first one
12:43:25 <monochrom> For pretty printing. Concats two pieces of things to be pretty-printed.
12:43:38 <paolino> vertically ?
12:44:05 <monochrom> vertically or horizontally may be left open until line width is really known.
12:44:30 <monochrom> that is a beautiful magic of pretty printers.
12:45:14 <dynamix> hmm cool any way what are there any examples of using Data.Time.Clock.POSIX ?
12:45:23 <paolino> I admit , I got it with trial and error
12:45:33 <dynamix> that is one garbled post :)
12:45:45 <monochrom> In fact it is even sweeter. The choice is between "concat horizontally" and "on the next line, but indent by 5 spaces".
12:46:35 <MarcWeber> dcoutts: http://rafb.net/p/1aBzfo63.html Where does the last CANONICALIZE come from (line 41)? That's not within --destdir
12:46:35 <lambdabot> Title: Nopaste - No description
12:47:09 <MarcWeber> If you don't know it I'll try tracking it down
12:50:48 <paolino> oops trackerd  got my box again
12:59:37 <Twey> Mornin' Trinithis
12:59:43 <Trinithis> hi
12:59:58 <Trinithis> started reading about arrows
13:00:13 <faxathisia> ooh Arrow.hs is cool
13:01:20 <Trinithis> know any good tuts for them? ive been reading wikibooks
13:03:19 <Trinithis> :t proc
13:03:21 <lambdabot> Not in scope: `proc'
13:03:53 <Trinithis> :t Control.Arrow.proc
13:03:54 <swiert> Trinithis: John Hughes wrote an arrows tutorial for AFP 2004.
13:03:54 <lambdabot> Not in scope: `Control.Arrow.proc'
13:04:07 <allbery_b> proc is syntax, like do
13:04:15 <Trinithis> built in?
13:04:29 <monochrom> proc is a keyword.
13:04:32 <Trinithis> i see
13:04:37 <Trinithis> seems like \'s
13:04:56 <monochrom> Yes.
13:06:07 <tibbe> I'm struggling with figuring out how to write an incremental parser. I'm sure there are papers out there, any references?
13:06:48 <tibbe> i.e. an incremental parsec
13:07:25 <swiert> tibbe: what do you mean by "incremental"?
13:07:50 <tibbe> swiert: I provide the input in chunks
13:08:18 <tibbe> swiert: so the parser returns something like a partial result that can be fed back together with more input
13:08:26 <reilly> I'm running into an error message I don't quite grok.  I was trying to do a simple experiment (reimplementing the State monad), and I keep getting the following error:  cannot construct the infinite type: s = s -> s
13:08:34 <tibbe> swiert: i.e. Oleg fold style enumerators instead of lazy list input
13:09:03 <swiert> tibbe: why would you want that?
13:09:08 <bd_> reilly: that means you have something which returns its own type (a -> a -> a -> a -> a -> a -> ......).
13:09:38 <tibbe> swiert: I'm reading data (incrementally) of the network and I don't want to keep it all in memory nor do I want to use lazy I/O with all its problems
13:09:56 <reilly> I was trying to implement the State monad as MkState (s -> s) a instead of MkState (s -> (s,a))
13:10:33 <swiert> tibbe: so flattening the input and parsing it as a lazy list is no option?
13:10:41 <tibbe> swiert: nope
13:10:41 <bd_> reilly: doesn't that mean you can't compute a based on s?
13:10:45 <reilly> hmmm .... i don't see that in my code.
13:10:57 <reilly> i'll hpaste it
13:11:23 <bd_> reilly: have you been putting type signatures on your functions? often that helps with making errors more comprehensible :)
13:11:51 <monochrom> tibbe: I am indeed also investigating the recent ParsecT over CC-delcont, thus using a sneaky stream to invert control. At present there is a problem because ParsecT assumes that streams are referentially transparent (or at least pretend to be), as ParsecT likes to backtract to past stream states; but clearly my sneaky stream isn't.
13:11:57 <bd_> reilly: how would you implement get in MkState?  MkState id (?)
13:12:16 <bos> reilly: if you're using a newtype for MkState, that's your problem.
13:12:51 <reilly> no, using data
13:13:05 <tibbe> monochrom: right, I want to build a incremental bytestring parser that's not monadic but applicative
13:13:57 <tibbe> monochrom: as it appears to be enough to parse http headers as per bos latest blog post
13:15:18 <bos> well, having a user write in applicative style doesn't win you anything if you're implementing the library.  it doesn't make implementing it any easier.
13:16:00 <monochrom> hehe, word
13:16:23 <lQg> yes
13:16:43 <tibbe> bos: I understand that :)
13:16:48 <tibbe> bos: but it's cute ;)
13:17:18 <lQg> i prefer making my developers learn a new language :)
13:17:28 <lQg> other than English that is
13:17:44 <dons> tibbe: so more like Data.Binary?
13:17:45 <monochrom> Learn Chinese. It'll be popular.
13:17:54 <dons> generate chunks strictly, and string 'em together
13:18:18 <lQg> naw, lBQ-G! the programming language, can be translated into any other world language, then don't have to higher translators
13:18:22 <lQg> cheaper that way
13:19:30 <lQg> currently only working on the translating to assembly though
13:19:40 <monochrom> use haskell.
13:19:51 <tibbe> dons: in what sense?
13:19:54 <lQg> that is what i'm writing the compiler in
13:20:21 <lQg> I just got nested languageLabeled strings to work :)
13:20:24 <tibbe> dons: (i.e. probably yes but it kinda depends on what you mean)
13:20:42 <ski> tibbe : seem Hughes' Polish ?
13:20:49 <ski> s/m/n/
13:21:11 <tibbe> ski: don't think so, where?
13:21:20 <Cale> Why learn Chinese when you can just have a complicated set of rules for producing output strings of Chinese words from input strings of Chinese words which you follow to the letter?
13:21:43 <Twey> Heheheh
13:21:48 <gwern> Cale: ah, but how do you compress your complicated set of rules?
13:21:52 <monochrom> Because that's learning Chinese.
13:22:10 <gwern> with a neural net (viz one's brain), of course. gzip would not hack it
13:23:03 <monochrom> You're like "Why write software when you can just toggle bits in your RAM".
13:23:27 <ski> tibbe : hm, there must be better references to it than <http://www.cs.chalmers.se/Cs/Research/Functional/Meeting/2000/index.html#John-Oct-26>
13:23:27 <lambdabot> http://www.cs.chalmers.se/Cs/Research/Functional/Meeting/2000/index.html#John-Oct-26>
13:23:28 <lament> Cale: i thought that argument has been completely discredited?
13:23:39 <sarehu_> but then its return value would not depend on the state you passed in
13:23:56 <Cale> lament: I'm joking, of course :)
13:24:05 <monochrom> "Why work hard for food when you can just have dessert"
13:25:22 <monochrom> Haha, "Why learn haskell when you can just program categorically..." :)
13:25:45 <Tac-Tics> At least in Chinese, Kanji only have one pronounciation each. In Japanese, each one can have several different pronounciations depending on context with an average of about 2 or 3
13:26:09 <Tac-Tics> monochrom: you got it backwards =-) "Why learn category theory when you can learn haskell?"
13:26:51 <monochrom> Actually some Chinese characters have two pronounciations, but you're right if we count averages.
13:27:17 <meryrus> I'd say about 10% of characters have more than one pronounciation.
13:27:31 <meryrus> In Mandarin (because that's all I know)
13:27:44 <Tac-Tics> Kanji w/o furigana or piyin (sp?) is like code without documentation or unit tests
13:28:13 <monochrom> The situation is the same to, in English, "record" is pronounced differently depending on noun vs verb. And so some Chinese characters are also pronounced slightly differently (just different intonations) depending on noun or verb.
13:28:20 <Twey> In Japanese, almost all kanji have more than one reading
13:28:30 <Twey> Tac-Tics: Pinyin
13:28:38 <Tac-Tics> Twey: thank you
13:28:41 <Twey> (it has tones too, but I don't remember them :-P)
13:29:33 <Tac-Tics> Clearly, Korean's Hangul is the Lambda Calculus of the written Oriental languages. Pure, simple, with straightforward denotational semantics
13:30:10 <Tac-Tics> Chinese is like PHP and Japanese is, I dunno, Common Lisp =-)
13:30:17 <monochrom> Algol 60 is also pure, simple, has straightforward denotational semantics.
13:30:19 <znutar> hangul's morphophonemic rather than just purely phonemic though
13:30:50 <resiak> the monomorphonemicism restriction strikes again!
13:30:53 <monochrom> In fact history shows that denotational semantics for the lambda calculus, at least the untyped one, is by no means straightforward.
13:31:14 <monochrom> At least Algol 60 didn't suffer the same paradox.
13:31:54 <Tac-Tics> what is complex about untyped LC's denot. semantics?
13:32:47 <monochrom> D \equiv D U D^D  did not have an obvious solution.  Mucho CPO needed.
13:35:19 <cjb> <newbie>How do I load quickcheck into ghci?</>
13:35:47 <monochrom> XML parse error: unmatched closing tag.
13:35:54 <gwern> isn't it :m + Test.QuickCheck?
13:36:06 <monochrom> Yeah, something like that should work.
13:36:08 <cjb> can't find module `Test.QuickCheck'
13:36:22 <monochrom> install quickcheck.
13:36:22 <dons> ghc-pkg  list QuickCheck ?
13:36:39 <dons> cabal install QuickCheck, if you've cabal-install, otherwise, gather it from hackage
13:36:41 <cjb> nope.  Sorry, I guess I thought it was core.
13:36:42 <dons> ?where hackage
13:36:42 <lambdabot> http://hackage.haskell.org/
13:36:54 <monochrom> Almost nothing is core. :)
13:37:09 <cjb> thanks, cabal install's done already.
13:37:10 <Cale> cjb: It is/was distributed with GHC, but it depends on which version you get.
13:37:28 <Cale> (there are distributions of GHC with extra libraries and ones which are pared down)
13:37:31 <cjb> Ah.  I have 6.6 and 6.8.
13:37:52 <Cale> Yeah, the specific distribution of 6.6 or 6.8 makes a difference :)
13:37:55 <cjb> Is there a verbose mode for quickcheck?  I want to see inputs as well as the values compared.
13:38:23 <dons> there is, yes.
13:38:29 <dons> debug=True as argument to defaultConfig
13:38:38 <Cale> verboseCheck?
13:38:47 <dons> that might be it
13:39:51 <Cale> yeah, that prints out the test number and which values are being supplied.
13:40:02 <bos> @seen CosmicRay
13:40:02 <lambdabot> I saw CosmicRay leaving #haskell and #darcs 1d 23h 19m 8s ago, and .
13:40:26 <cjb> Thanks all.
13:42:53 <sethk> how can I find out whether anyone has done a ghc port to the ARM processor?
13:43:34 <dons> sethk: there are arm ports for debian
13:43:45 <dons> i think there's even an arm/ghc wiki page
13:43:50 <sethk> dons, great.  They have source RPMs also?
13:43:56 <sethk> I'll search for the  wiki page, thanks
13:43:59 <dons> sethk: check on the ghc list archives, and talk to Igloo, he maintains th earm port
13:44:15 <sethk> dons, thanks much.
13:47:44 <bd_> sethk: debian doesn't use RPMs, but you can grab the debian sources... The ARM builds seem out of date though.
13:47:49 <bd_> (6.6.1)
13:49:41 <dons> probably good enough for government work though
13:53:44 <sethk> bd_, I know, but typically you can get both binary and source packages for dpkg systems
13:54:01 <sethk> dons, I can use the older version to build the newer version; the big task is the bootstrapping.
13:55:44 <bd_> sethk: sure, they have sources, it's just they bootstrap by manually uploading a binary version :) You can manually extract the .deb with ar and tar though.
13:56:03 <sethk> bd_, ok, thanks.
13:56:40 <sethk> bd_, the thing is, I'm working on an embedded system so I can't really install the binary.  Even so, having a set of sources that builds is a big advantage.
13:56:59 <sethk> bd_, I might even be able to attach an external drive and load debian on it; I hadn't considered that before.
13:57:47 <bd_> sethk: In order to bootstrap it, you'd need a system to run it on anyway; Idon't think ghc supposrt cross-compilation, does it?
13:58:44 <litb> @hoogle logBase
13:58:45 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
13:59:37 <sethk> bd_, the docs show a way to build entirely from C, although not yet with the latest version
13:59:56 <sethk> bd_, and I've already built the underlying cross compilers.
14:00:47 <bd_> sethk: that works too, but in the end you'll still be running GHC on $embedded_system
14:01:05 <bd_> (the C method doesn't pass through the Evil Mangler as I understand it, so it's quite inefficient)
14:01:14 <sethk> bd_, no, actually I'll be running the compiled programs on the embedded system, not necessarily the compiler itself.
14:01:25 <sethk> bd_, yes, it's for bootstrapping.
14:01:35 <sethk> bd_, I have linux running, just not a distro
14:01:42 <bd_> the idea is to then rebuild the compiler properly using this crippled bootstrapped version, but in order to build real programs you don't want to use that method
14:02:04 <sethk> bd_, that's exactly what I have to do.  I know I'll have to do multiple passes
14:02:27 <bd_> sethk: if the libraries are compatible you can just untar the debian ghc binary, is what I meant earlier
14:03:10 <sethk> bd_, it's unlikely they'd be compatible with my cross compilation build.
14:08:28 <dons> dcoutts, i'd love a tool that would mark in red all exception throwing code in a library
14:08:52 <dons> i.e. extended checkign for ioError stuff I could check against statically
14:10:48 <sethk> dons, the vim syntax highlighting doesn't do that?
14:10:52 <litb> let dgs a = reverse $ unfoldr (\(x, a) -> if a == 0 && x == 0 then Nothing else return (x, (a `mod` 10, a `div` 10))) (a `mod` 10, a `div` 10)
14:10:58 <litb> is there some better way for that?
14:11:04 <litb> (other than using show)
14:11:19 <sethk> litb, what's wrong with using show?
14:11:26 <litb> i want to learn
14:11:54 <litb> and i wont numbers in the list, not Char
14:13:42 <litb> s/wont/want/
14:13:55 <litb> it looks horribly too long
14:15:59 <litb> @hoogle digits
14:15:59 <lambdabot> Numeric.floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
14:15:59 <lambdabot> Numeric.lexDigits :: ReadS String
14:15:59 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
14:16:45 <monochrom> Oleg has a method for tainting exception-throwing functions with class constraints and have them propagate to callers.
14:17:00 <dons> oh, that's interesting
14:17:19 <monochrom> I must bookmark Oleg's home page!
14:18:48 <bos> that's a mixed blessing.
14:19:21 <Heffalump> the whole checked exceptions thing
14:19:25 <dons> you could find  a bottomth exception, then the type checker would find for you all places that could throw stuff
14:19:26 <bos> the more exceptions one has to worry about explicitly, the more likely one is to find a combinator that will efficiently nuke the lot.
14:19:32 <monochrom> Yes. If you like how Java taints your exception-throwing functions, you'll like it.
14:19:38 <dons> and then you'd at least know what was going to bring down your system
14:19:59 <Heffalump> what type variable do the constraints work over?
14:20:01 <dons> i woudn't use the types other than an offline tool to identify stuff not to use
14:20:13 <monochrom> Of course, sometimes you end up with a function whose class contraints are two miles long. :)
14:21:26 <BMeph> litb: If you just pass/test a `div` 10, and put a `mod` 10 as the first component of the returned pair, it'll do the same thing. :)
14:24:34 <dons> hah http://www.regdeveloper.co.uk/2008/02/07/lisp_arc_challenge/
14:24:48 <monochrom> I can't find Oleg's article on this yet, but it comes down to as simple as: the "throw" function comes with a class constraint of your design, then just sit back and enjoy the pollution!
14:25:09 <dons> yep
14:25:18 <dons> that'd do it.
14:26:23 <monochrom> I forgot whether or how to make sure the "catch" function cancel the class constraint. :)
14:27:03 <BMeph> A nicer way to connect it, I saw last night - (\n -> guard (n>0) >> return . swap . divMod n $ 10)
14:27:26 <Twey> Hah
14:30:22 <EvilTerran> (>>) <$> guard.(>0) <*> return.(snd&&&fst).(`divMod`10)
14:32:03 <litb> this is the reverse i think: let toNum a = sum [ ai*10^x | (ai, x) <- (zip (reverse a) [0..]) ]
14:32:39 <therp> does anyone know whether there is something FP related in new zealand? any particular Haskell company/CS department/whatever?
14:35:34 <EvilTerran> litb, you could also express it as a fold
14:35:36 <litb> BMeph: ah i understand what you mean
14:36:14 <BMeph> litb: Excellent. :)
14:36:33 <litb> BMeph: doing it with a fold?
14:36:35 <dcoutts> dons: like java's checked exceptions?
14:36:54 <EvilTerran> > map (`mod`10) . takeWhile (>0) . iterate (`div`10) $ 12345 -- is how i prefer to formulate the normal one; it's clearer than an unfoldr, if not as efficient
14:36:57 <lambdabot>  [5,4,3,2,1]
14:38:00 <BMeph> litb: No, I use the unfoldr - I was especially impressed with using guard p >> ...   to organize the helper function.
14:38:09 <dons> dcoutts: so if i start using some library, the type doesn't tell me if the code is partial/exception throwing. ideally -Wexceptions would warn if i had could that called anything that would throw
14:38:18 <EvilTerran> > foldl' ((+).(*10)) 0 [1,2,3,4,5]
14:38:19 <lambdabot>  12345
14:38:20 <byorgey> > reverse . map digitToInt . show $ 12345  -- cheating
14:38:21 <dons> that is key info, not in the type currently
14:38:21 <lambdabot>  [5,4,3,2,1]
14:38:39 <litb> (>>) <$> guard.(>0) <*> return.(snd&&&fst).(`divMod`10) -- what the heck does this do?
14:38:41 <EvilTerran> dons, that sounds like what ndm's catch does
14:38:54 <EvilTerran> > unfoldr ((>>) <$> guard.(>0) <*> return.(snd&&&fst).(`divMod`10)) 12345
14:38:54 <lambdabot>  [5,4,3,2,1]
14:39:01 <dons> sort of. i'm imaginging a restricted version that just looked for exceptions
14:39:05 <litb> wow
14:39:15 <dons> and didn't try to prove side conditions
14:39:26 <dcoutts> dons: but of course if it can throw something, so can you, so the exceptions propagate, where would the warning be?
14:39:34 <byorgey> litb: hehe
14:39:38 <dcoutts> MarcWeber: I'm not sure what's going on there, we'll need more details.
14:39:59 <dons> dcoutts: package boundaries? "You import Foo.y from package X which can throw exception E"
14:40:15 <dons> offline analysis for this would be fine too.
14:40:28 <dcoutts> dons: right, like readFile from base. Where is the point where the error is?
14:40:36 <dons> who knows if buried deep down in haxml or something is an exception thrower
14:40:48 <litb> EvilTerran: ah i see
14:40:57 <litb> the foldl, nice
14:41:02 <dcoutts> dons: in Java you declare the exceptions that *your* code throws, so we can see if that's not consistent with the code you call.
14:41:16 <dcoutts> dons: ie, that's the error point.
14:41:24 <dons> interesting.
14:41:44 <dcoutts> but if we never say what can throw, then where is the error? you need to assert somewhere that you only throw Foo and Bar.
14:41:55 <dcoutts> so that if in fact you also throw Baz, then we can warn you.
14:42:10 <dons> the error is calling something that can throw :)
14:42:19 <dons> since i don't want no stickin' exceptions
14:42:28 <radetsky> NO EXCEPTIONS
14:42:31 <dons> then you turn on or off the ones you care about
14:42:43 <dcoutts> dons: ah, you want no _|_'s, so we're not talking about IO exceptions?
14:42:51 <dcoutts> no error/undefined _|_'s
14:42:57 <dons> bottoms complicate things. i'm happy to start at IO.
14:43:02 <monochrom> hehehehe radetsky
14:43:02 <dons> error, too, yes.
14:43:18 <dons> ultimately, i want total haskell
14:43:23 <dcoutts> dons: but lots of things call error but you never get an error since you satisfy all the pre-conditions
14:43:24 <dons> -Wpartial
14:43:31 <monochrom> The same methodology could treat many related questions.
14:43:47 <dons> dcoutts: i'm imaginging it more as a discovery tool
14:44:03 <dons> to find the possible problems in a big library that aren't documented in the type
14:44:12 <dcoutts> dons: right, so you really want the static checking tool that we're putting in a funding proposal for :-)
14:44:16 <monochrom> Static Analysis!
14:44:16 <dons> X11's a case. lots of throwIfNulls deep down
14:44:30 <dons> please, yes.
14:44:34 <dons> i can has a static check?
14:44:35 <dcoutts> dons: see, that's a different issue from what is the *possible* set of exceptions this IO code can throw
14:44:43 * monochrom hands dons a cookie that says "abstract interpretation"
14:44:54 <dcoutts> dons: "I can has static check?" no prepositions
14:45:07 <litb> o.O
14:45:08 <monochrom> You mean article.
14:45:12 <dons> but lolcats don't say that.
14:45:21 <dcoutts> monochrom: erm, yes. I thought I had that wrong :-)
14:45:24 <monochrom> And you have to spell haz.
14:45:35 * dcoutts is clearly made of fail
14:45:40 <dons> i can haz a static check,plz? kthx bai
14:45:50 * monochrom rains a whole lot of grammar books over the channel.
14:45:55 <dcoutts> that's better
14:46:00 <dcoutts> monochrom: fewer grammar!
14:47:40 <monochrom> This static analysis is easy but requires access to much source code.
14:49:18 <monochrom> I suppose that's a tautology.
14:54:39 <MarcWeber> dcoutts: ping
14:56:04 <MarcWeber> dcoutts: Here is the trouble. But Idon't know yet whats going one here (or what should be going on here)  http://rafb.net/p/5SgBBo28.html
14:56:04 <lambdabot> Title: Nopaste - No description
14:57:18 <litb> i wonder whether there is a faculty function in haskell
14:57:43 <MarcWeber> litb: 3! = 6 ?
14:57:48 <litb> yes
14:57:56 <monochrom> that's called factorial
14:58:14 <litb> oh i deeply knew i was wrong but forgot the rite word :)
14:58:18 <MarcWeber> fac x = foldr (*) 1 [1..x] ? ;) (Or something like that)..
14:58:25 <monochrom> product [1..n]
14:58:37 <litb> ah that's what i was looking for product, thxx
14:58:50 <MarcWeber> I haven't done real haskell programming for some month..
14:59:07 <kuribas> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:59:14 <monochrom> hehehehe
14:59:20 <lambdabot> Title: The Evolution of a Haskell Programmer
14:59:44 <kuribas> Is there a function that test for mzeroness?
15:00:29 <monochrom> No.
15:00:51 <kuribas> Can I use (== mzero) ?
15:00:57 <monochrom> No.
15:01:49 <kpreid> depends on the monad
15:01:55 <monochrom> (liftM Just m) `mplus` (return Nothing)  may help.
15:02:01 <kpreid> > (mzero :[Int]) == mzero
15:02:13 <gwern> @where debian
15:02:19 <kpreid> lambdabot: halloo?
15:02:34 <monochrom> Consider (mzero : [Int -> Int]) == mzero
15:02:51 <kpreid> okay, depends on the type, period :)
15:02:55 <gwern> does anyone know where the darcs repo is for jeremy shaw's Debian package?
15:03:14 <monochrom> May as well ask "why do you want that?"
15:04:27 <kuribas> Well, now I have (do {a <- fun; other_fun a} `mplus` other_fun b), I was wondering if I could put it in a test.
15:05:10 <kuribas> But that's probably stupid :)
15:07:02 <EvilTerran> well, i suppose a test would be something like (\x -> (x >> return False) `mplus` return True)
15:07:31 <Cin> Bool is a member of Monad? ace
15:07:39 <Cin> er.. member? instance*
15:07:45 <EvilTerran> but that would only confirm that x fitted one of the MonadPlus axioms, so it'd be a candidate for being mzero, but you couldn't be sure it actually was
15:07:46 <dons> 7 haskell user groups meeting in the next 10 days
15:07:48 <EvilTerran> Cin, no...
15:07:52 <EvilTerran> ?type (\x -> (x >> return False) `mplus` return True)
15:07:57 <dons> check haskell.org's front page for your city
15:08:11 <EvilTerran> ... \b's gone *again*?
15:08:44 <gwern> (goodness. Debian is old enough it wants Data.ByteString.Base)
15:09:19 <EvilTerran> Cin, that expression's of type "MonadPlus m => m a -> m Bool"; it's returning a Bool in some Monad, the Bool itself is not a monad
15:09:35 <EvilTerran> Bool can't be a Monad; how'd you define return?
15:10:01 <kpreid> return _ = True
15:10:10 <kpreid> (not that the kind works)
15:10:17 <gwern> @hoogle unsafeTake
15:10:39 <kpreid> oh, and >>= would be degenerate
15:11:38 <Cin> yeah, i mis-read. jump down my throat next time :P
15:13:07 <EvilTerran> kpreid, it doesn't fit the axioms, though
15:13:31 <litb> is there something shorter for "head $ filter p" ?
15:13:41 <MarcWeber> What are progprefix and progsuffix dirs (Cabal data InstallDirs) ?
15:13:42 <glguy> Good idea, bad idea?    (\ continue acc -> <do stuff> >> continue acc') `fix` []
15:15:21 <kpreid> litb: not really, but I'd suggest Data.List.find
15:16:47 <glguy> flip fix initial $ \ continue x ->
15:17:17 <litb> thanks
15:28:47 <MarcWeber> @tell dcoutts http://mawercer.de/copy_exe_haxml_patch_hope_didnt_break_anything
15:29:39 <MarcWeber> Is lambdabot ill ? :(
15:30:49 <EvilTerran> i think she's got a cold; either her ears are bunged up or her throat's so sore she can't speak
15:43:15 <Cale> > foldr f z [1,2,3]
15:43:17 <mbot>  f 1 (f 2 (f 3 z))
15:43:22 <Cale> mbot will do :)
15:43:32 <Cale> > scanl f z [1,2,3]
15:43:34 <mbot>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3]
15:46:05 <thegraham> how do I sort a list of lists by length (or extract the shortest lists from within a list)
15:46:29 <EvilTerran> sortBy is useful
15:46:35 <EvilTerran> or minimumBy
15:48:22 <radetsky> is "sumsq2 n = n*n + sumsq2 (n-1)" tail-recursive?
15:49:08 <kpreid> no
15:49:35 <radetsky> that explains the stack overflow
15:49:38 <kpreid> the thing in the tail position there is (+)
15:49:47 <kpreid> however, you don't usually *want* tail recursion in Haskell
15:49:58 <kpreid> it produces stack overflows :)
15:50:18 <radetsky> wait, I thought lack of tail recursion produced stack overflows
15:50:34 <kpreid> only in strictly-evaluating languages
15:50:35 <radetsky> there was some kind of article on this on haskell.org
15:50:41 <kpreid> Haskell is lazy, so it's the opposite
15:51:21 <radetsky> ok, well, if the above is not tail-recursive, then it shouldn't be overflowing, and it is
15:52:20 <radetsky> does anyone know the article I'm talking about on haskell.org re: stack overflows, tail recursion, etc?
15:52:26 <kpreid> is there a base case you didn't show?
15:52:48 <radetsky> yeah
16:02:42 <ehird`> > uncurry sum
16:02:44 <mbot>   add an instance declaration for (Num (b -> c))
16:02:46 <ehird`> hm.
16:03:57 <bd_> uncurry operates on functions of two arguments
16:04:01 <bd_> sum has one argument, a list
16:04:20 <bd_> @djinni ([a] -> b) -> (a -> a -> b)
16:04:20 <mbot> -- f cannot be realized.
16:04:35 <bd_> well anyway, you're probably looking for (+)
16:04:38 <bd_> :)
16:12:35 <ehird`> bd_: i was just trying to make it explode :p
16:13:59 <Cale> thegraham: Also, note that in Data.Ord, there is a function 'comparing p x y = compare (p x) (p y)', so that you can write sortBy (comparing length)
16:19:34 <lament> e_n_t
16:28:35 <tennin> I'm reading Meijer's original bananas paper... I'm trying to understand the relationship between the arrow/wrapping contravariant bifunctor and curry/uncurry/eval, on page 8.  I can't figure it out.
16:32:22 <tennin> does curry = g -> h for some g, h?  But because curry::(A x B -> C) -> (A -> (B -> C)), I would think necessarily g :: A -> A x B and h:: C -> B -> C, right?
16:34:27 <tennin> But then musn't g depend on the second argument of the function?  curry f x y = ((, y) -> const) x y isn't exactly satisfying.
16:34:38 <tennin> So am I looking in the wrong place altogether?
16:36:00 <twanvl> all functions have type g -> h for some g and h
16:36:23 <dobblego> @where fold diagrams
16:36:23 <mbot> I know nothing about fold.
16:36:38 <tennin> Sorry, this is a special definition of "->" in Meijer's paper.
16:38:05 <tennin> (which isn't exactly Haskell, but I figured there'd be a better chance of someone familiar with this being here than anywhere else)
16:40:29 <tennin> this -> :: (A -> B) -> (C -> D) -> (B -> C) -> (A -> D); (->) f g h = g . h . f
16:42:52 <twanvl> So (g->h) takes a function of type (B -> C) and returns a function of type (A -> D)
16:42:53 <gwern> yay. Debian compiles now.
16:43:04 <gwern> for something broken since 6.4, surprisingly unpainful
16:43:21 <tennin> Yes.
16:43:26 <gwern> (er, I mean working on 6.4 apparently but broken with 6.6 and ghc 6.8.x)
16:43:57 <twanvl> And curry :: ((a, b) -> c)   ->   (a -> (b -> c))  so it fits that type
16:44:57 <tennin> It fits, but only if one of the operands is :: a -> (a, b)
16:45:31 <twanvl> You would have B = (x,y)  C = z   A = x  D = (y -> z)
16:45:41 <ski> that `(->)' is the functor map for the exponential
16:46:12 <tennin> ski: yes!  so how is it closely related to curry/uncurry/eval?
16:46:34 <ski> i would assume you can't express `curry' in terms of it
16:46:50 <twanvl> So g :: A -> B = x -> (x,y), which is not possible
16:46:50 <ddarius> The functor A -> - is very related to curry/uncurry/eval.
16:47:07 <ddarius> It's one half of the adjunction that defines curry and uncurry and eval.
16:47:11 <mightybyte> @hoogle FilePath
16:47:12 <mbot> System.FilePath :: module
16:47:12 <mbot> Prelude.FilePath :: type FilePath
16:47:12 <mbot> System.IO.FilePath :: type FilePath
16:47:25 <mightybyte> @src FilePath
16:47:25 <mbot> type FilePath = String
16:47:37 <ski> (a,) --| (a ->)
16:48:11 * tennin googles "adjunction"
16:48:59 <ski> (a,b) --| c
16:49:03 <ski> ============
16:49:04 <ski> b --| a -> c
16:49:19 <ski> er, s/--|/-->/ :)
16:51:17 <ski> (so top-to-bottom is basically `curry', the other direction `uncurry')
16:53:04 <twanvl> but curry can not be written as curry f = g . f . h
16:53:17 <twanvl> (I think)
16:54:10 <ddarius> No it can't.
17:01:36 <radetsky> kpreid: http://haskell.org/haskellwiki/Performance/Accumulating_parameter
17:02:02 <radetsky> apparently *somebody* thinks haskell tail recursion is a good idea
17:02:11 <radetsky> also, my code no longer has stack overflows
17:02:33 <tennin> doesn't it depend on what you're producing?
17:03:08 <tennin> e.g. for a function that returns an integer, tail recursion might be more efficient, while for a function that returns a list it shouldn't matter... I think?
17:03:12 <kpreid> hmm, yes, I had an overly simple model
17:03:25 <radetsky> tennin: you may be right
17:03:36 <radetsky> in this case, I was returning an integer though
17:03:50 <Cin> fac n | n == 0 = 1 ... fac n | otherwise = n * (fac (n - 1)) -- is this tail recursive modulo *?
17:04:45 <Twey_> Hm
17:05:03 <Cin> hi twey
17:05:47 <Twey> Who killed \bot :-(
17:06:11 <dons> ?bot
17:06:12 <Twey> Hi Cin
17:06:12 <mbot> :)
17:06:24 <monochrom> Perhaps Colonel Mustard.
17:06:28 <dons> hmm. netsplit, i think
17:06:32 <dons> its still up on the server
17:06:35 <Twey> In the kitchen?  With the monad?
17:06:40 <radetsky> Cin: if by "modulo" you mean \x -> "except for" ++ x ++ ", which makes it not tail-recursive", then yes
17:06:48 <dons> mbot: @part #haskell
17:06:59 <Twey> @pl \x -> c (a x) (b x)
17:07:05 <lambdabot> liftM2 c a b
17:07:17 <Twey> Seven seconds?
17:07:27 <dons> @pl \x -> c (a x) (b x)
17:07:32 <lambdabot> liftM2 c a b
17:07:33 <Twey> Busy channel somewhere or am I lagging?
17:07:37 <Cin> radetsky: well i'm referring to tail recursion modulo cons, the way to say you can optimise a recursive procedure in scheme, but i think it can be applied to things other than cons
17:07:40 <dons> oh,its still connecting to other channels
17:07:44 <Twey> Ah
17:07:50 <dons> and also, the new server's a bit slow..
17:07:52 <dons> @pl \x -> c (a x) (b x)
17:07:52 <lambdabot> liftM2 c a b
17:07:55 <dons> there we go
17:08:05 <Twey> Ah good :-)  Was worried
17:09:27 <Twey> Hmm
17:09:33 <Twey> Why liftM2?
17:09:46 <Twey> I thought that was something to do with monads.
17:10:30 <shachaf> Twey: The (r ->) monad.
17:10:41 <soduko> :t fromIntegral
17:10:41 <lambdabot> forall a b. (Num b, Integral a) => a -> b
17:10:56 <soduko> :t fromDouble
17:10:57 <lambdabot> Not in scope: `fromDouble'
17:11:03 <soduko> :t toIntegral
17:11:04 <lambdabot> Not in scope: `toIntegral'
17:11:25 <soduko> :t floor
17:11:25 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:11:48 <Twey> shachaf: (r ->)? (sorry, that's hard to Google for)
17:12:02 <shachaf> Twey: Reader, then.
17:12:06 <shachaf> Twey: Without the newtype.
17:12:17 <Twey> Hm, OK, thanks
17:14:33 <radetsky> is this the right way to represent arbitrary trees?
17:14:36 <radetsky> data Tree a = Leaf a
17:14:36 <radetsky>             | Branch a [Tree a]
17:15:30 <radetsky> oh, wait, no it isn't
17:15:39 <twanvl> radetsky: Why do you need a leaf, what is the difference between Leaf a and Branch a []?
17:15:47 <radetsky> yeah, that's what I just realized
17:16:07 <kpreid> radetsky: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Tree.html
17:16:07 <lambdabot> http://tinyurl.com/2phbrb
17:17:09 <bos> oops
17:17:12 <bos> @seen dons
17:17:12 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 9m 17s ago.
17:17:17 <monochrom> Don't leave us :)
17:19:10 <tennin> and the reason is that if you have a recursive function that returns an integer, you are essentially building this whole stack of calls f x = g (f x') = g (g' (f x'')) = g (g' (g'' (f x'''))) ... until you get to an x for which f doesn't call itself, but if your function is building the list and your g's all take the form (y:), the "call stack" is incorporated into the lazy list structure anyway
17:25:45 <litb> @users
17:25:45 <lambdabot> Maximum users seen in #haskell: 471, currently: 427 (90.7%), active: 12 (2.8%)
17:25:59 <litb> o.O it has grown :)
17:26:24 <astrolabe> Is there a way of making ghci interperate modules that have been compiled other than deleting the .o files?
17:27:11 <monochrom> fudge the time stamp of the .hs file.
17:27:22 <monochrom> delete the .hi file.
17:27:28 <brad_larsen> hi there
17:27:30 <ehird`> touch it. if that doesn't work, touch it until it does
17:27:31 <ehird`> <_<
17:27:32 <monochrom> rename files :)
17:27:55 <brad_larsen> perhaps someone can alleviate some confusion I have about the type system?
17:28:03 <astrolabe> bah.  Is it just me that finds this awkward?
17:28:11 <brad_larsen> http://hpaste.org/5534#a1
17:28:27 <brad_larsen> the first annotation is the correct one.  I messed up the first time.
17:28:28 <monochrom> Install Oleg's zipper file system. Perform a transaction that deletes the files. Later, roll-back to regain them.
17:29:01 <LoganCapaldo> remove the read bit from the .o files
17:29:01 <brad_larsen> basically, I have some search algorithms I implemented, and I want to package all the open-list functions together in a type class
17:29:11 * LoganCapaldo doesn't know if that would work
17:29:36 <brad_larsen> i also want to package up the node expansion function and goal tester functions in a different class
17:29:48 <monochrom> Does -fforce-recomp help?
17:29:54 <kpreid> brad_larsen: I think that means you have some things in graphSearch which are underconstrained -- they *could* be of some other type
17:30:30 <brad_larsen> kpreid: i don't see where the types s1, e1, and e2 come from.
17:31:20 <astrolabe> monochrom: I guess it might if it's an option for ghci.  I'll try it.
17:31:37 <kpreid> brad_larsen: well, consider this example;
17:32:03 <kpreid> > (read . show . read) :: String -> Int
17:32:05 <lambdabot>  <[Char] -> Int>
17:32:14 <kpreid> hrm. didn't work :)
17:32:22 <brad_larsen> heh
17:32:23 <kpreid> defaulting applies there, or something
17:33:26 <astrolabe> monochrom: That works!  Thanks.
17:33:37 <monochrom> Nice!
17:33:37 <astrolabe> @karma+ monochrom
17:33:37 <lambdabot> monochrom's karma raised to 20.
17:34:40 * brad_larsen is wondering how to change things so that graphSearch has the desired type constraints
17:36:06 <monochrom> If you impose your own type signature, is it an error?
17:36:16 <jorik808> hey guys, what would a good one-char symbol be for a lambda? i was tempted to use \ but it causes mayhem all over the place in my shells
17:36:19 <brad_larsen> yes.
17:36:27 <ehird`> monochrom: yes, the compiler gets angry at your opression
17:36:34 <sm> would someone mind helping me to grok what's going on in http://hpaste.org/5535
17:36:45 <lament> unicode lambda would be good
17:37:01 <monochrom> Î» is waiting for you!
17:37:03 <jorik808> lament, hehe, that would be cool indeed
17:37:10 <jorik808> wow how do you do that ?!
17:37:23 <sm> starting with "let f set | dryRun = "
17:37:25 <monochrom> Decent software.
17:37:34 <brad_larsen> monochrom: SearchTest.hs:77.4:  Could not deduce (Searchable s1 e1) from the context .....
17:40:37 <monochrom> From my experience this is due to lack of fundeps.
17:41:02 <brad_larsen> ahhh.  i don't know about those yet.
17:42:23 <scook0> sm: the "let f set" is defining a function
17:42:54 <scook0> the "| dryRun =" bit tells you what the function evaluates to if the boolean variable "dryRun" is true
17:43:18 <ehird`> I still maintain we need Î» and I-can't-type-the-symbol-for-the-unicode- -> -arrow syntax. :-)
17:43:54 <Cin> what would a Î» function look like?
17:43:55 <ehird`> In fact, I want all multi-character hack glyphs to be beautiful unicode! And we should have special structured editors which allow us to use various combinations of fonts, including non-monospaced fonts, while keeping indentation properly!
17:43:59 <ehird`> :D
17:44:04 <ehird`> Cin: Î» x (arrow-symbol) x
17:44:19 <Cin> (arrow-symbol)?
17:44:20 <Cin> oh
17:44:24 <Cin> Î» x â†’ x
17:44:28 <ehird`> yes
17:44:37 <ehird`> Î» x â†’ x
17:44:43 * Cin has it on his keyboard >_>
17:44:45 <dynamix> :t getPOSIXTime
17:44:46 <lambdabot> Not in scope: `getPOSIXTime'
17:44:53 <ehird`> Might be able to use â† for something. :P
17:45:03 <Cin> i can't even see what that is
17:45:19 <ehird`> Cin: it's an arrow, but goes curvy.
17:45:29 <Cin> ehird`: cute :P
17:45:50 <Cin> > let test = (+)
17:45:50 <lambdabot>  Parse error at end of input
17:45:53 <ehird`> but yeah, structured+font-aware-allowing-even-proportional-fonts+fully-unicodeized+haskell=awesome
17:45:54 <sm> scook0: thanks, I was just discerning that
17:46:03 <dynamix> how to convert somethign from type POSIXTime to Int ?(type POSIXTime = NominalDiffTime)
17:46:16 <sm> I did not know you could define a function inside a do block ?
17:46:45 <Cin> ehird`: this is what is silly about arc's `fn'. Î» is perfect and one less character
17:46:46 <pjd> sm: functions are just values
17:46:46 <sm> so the | there is not a guard ?
17:47:02 <ehird`> Cin: arc wouldn't be able to parse the utf-8 file, though. :p
17:47:04 <pjd> sm: or alternatively, values are just functions
17:47:13 <ehird`> well, technically the current mzscheme implementation would, but let's not get into that
17:47:28 <lament> arc is the 1000-year-old language?
17:47:34 <ehird`> lament: 1000000000
17:47:47 <ehird`> Cin: I pasted some wonderful code exploiting hpaste's 'raw' to give a unicode+html-highlighted haskell file :P
17:47:48 <ehird`> let me find it
17:48:03 <lament> ehird`: that's pretty old
17:48:18 <ehird`> lament: paul graham is old
17:48:30 <Cin> ah, yeah. hpaste shows the raw as 'text/html' instead of 'text/plain'. i don't think anyone cares, though :)
17:48:58 <Philippa_> lament: eight years isn't that old
17:49:39 <ehird`> Cin: certainly helped me out! ;)
17:49:41 <sm> no.. it *is* a guard
17:50:37 <ehird`> here it was, cin:
17:50:38 <sm> I see it.. phew. thanks
17:50:38 <ehird`> http://hpaste.org/5308/2/plain
17:50:41 * Cin looks
17:50:47 <ehird`> yeah -- even my QUOTES are unicode! :D
17:51:21 <Cin> ehird`: hehe, quite nice
17:51:42 <Cin> ehird`: a real case analysis brace would be even more hardcore :P
17:51:55 <ehird`> Cin: now imagine an editor with seamless support for that, editing structurally (well, pseudo-structually, but a bit more than normal pseudo-structural editors :P)
17:52:05 <ehird`> and -- get this -- it did it to ghci too
17:52:09 <ehird`> :D
17:52:37 <Cin> ehird`: would the editor translate â†’ to -> ?
17:52:48 <ehird`> Cin: if you wanted to export it to ascii, sure.
17:52:51 <ehird`> and, i guess, when sending ghc stuff.
17:52:59 <ehird`> but it might be cleaner to write a ghc extension, for that.
17:53:01 <ehird`> more seamless.
17:53:02 <Cin> yeah
17:53:08 <ehird`> also, to patch ghci to tell us more stuff about its output
17:53:11 <ehird`> to make our job easier
17:53:27 <ehird`> but definately a ->ascii thing
17:53:33 <ehird`> also, a ->tex thing, of course :)
17:53:41 <ehird`> for once, copying and pasting haskell papers would *work* :P
17:53:44 <Cin> i must pick at your highlighting, though
17:53:52 <Cin> red is really bad
17:53:54 <ehird`> i wrote that by hand on the spot, cin ;)
17:53:57 <Cin> :P
17:54:01 <ehird`> i didn't have many colours available!
17:54:14 <Cin> red signals "error!" to me
17:54:36 <Cin> and is generally hard to read
17:54:48 <ehird`> yeah ditto
17:55:01 <ehird`> i don't agree with most of emacs' colours though
17:55:02 <ehird`> :)
17:55:18 <Cin> i like hpaste's
17:55:34 <Cin> i've made a HsColour stylesheet with the same colours D
17:55:36 <Cin> :D
17:55:40 <ehird`> i wouldn't know, its impossible to tell on the horrendous gray bg
17:56:22 <Cin> http://rtfs.ath.cx/haskell/HIRCd/init/doc/src/Server.hs.html
17:56:22 <lambdabot> Title: Haskell Code by HsColour
17:56:29 <Cin> >_>
17:57:11 <ehird`> hm
17:57:14 <ehird`> gray bg :P
17:57:15 <scook0> sm: the | is a guard
17:57:15 <ehird`> also, too subtle
17:57:16 <yondalf> how do you make ghc just check the syntax of your .hs file instead of compiling and linking everything?
17:57:26 <ehird`> the code gets lost in the jumble, though this is basically as much due to the font
17:57:35 <ehird`> monospaced code is great for just about everything but haskell ;)
17:57:50 <ehird`> of course proportional is not a currently viable solution, what with all that aligning evil ;)
17:57:50 <scook0> yondalf: -fno-code perhaps?
17:58:11 <Cin> ehird`: you crazy!
17:58:30 <yondalf> -fno-code still links...hmm...
17:58:49 <ehird`> Cin: if i ever write that structured editor -- indentation will be tabs, and I will *not* support the broken notion that "tab = space * N"!
17:59:01 <ehird`> of course, if you want to send it to some poor sap in the stone age you have to convert it anyway
17:59:14 <ehird`> so nobody should notice, unless they try to open those files in another editor (not clever ;))
17:59:46 <lament> ehird`: I agree. The notion of a space in the beginning of a line is odd.
18:00:04 <Philippa_> last time I wrote a layout-based language, it didn't support tab at all
18:00:08 <ehird`> lament: Quite so. Of course, in the practical, everyday world, that's what people and programs consider tabs -- so spaces are the only viable solution.
18:00:33 <ehird`> But in the happy la la land of unicode, proportional structured editing, anything is possible
18:00:39 <ehird`> (oh dear... zombocom..)
18:00:49 <Philippa_> yeah, for a structured editor it's the right semantic
18:00:53 <Philippa_> it just /isn't a space/
18:01:11 <Philippa_> but then, a structured editor doesn't necessarily want to use strings as its default representation anyway
18:01:24 <ehird`> Philippa_: imo it should.
18:01:28 <ehird`> what else? xml? ;)
18:01:42 <ehird`> (The problem with this happy la la land is that *having* to convert and all that is a pain, of course.)
18:02:10 <LoganCapaldo> serialized ast ;)
18:02:27 <ehird`> eek
18:02:29 <ehird`> serialization :|
18:02:40 <Philippa_> LoganCapaldo: exactly
18:03:09 <Philippa_> if you have a truly structural language, the brackets're arbitrary
18:03:37 <LoganCapaldo> ehird`: unless you never want to save you have to serialize it eventually (or you have some really cool persistent storage mechanism where your memory is indistingushable from disk or something)
18:03:55 <ehird`> LoganCapaldo: evil evil evil evil :(
18:04:04 <ehird`> it's not fully structured, anyway.
18:04:08 <Philippa_> ehird`: you're just proposing to use a particular format for serialisation
18:04:16 <ehird`> we still accept the down-to-earth notion of 'characters' ;)
18:04:27 <ehird`> so it's more highly advanced pseudo-structural
18:04:50 <LoganCapaldo> characters are definitely serialization, a stream of bytes
18:04:55 <Philippa_> rather, you accept characters outside of specific identifiers, operators etc
18:06:03 <LoganCapaldo> I want to treat my code like a database that I can run queries against
18:06:41 <Cin> you're all insane
18:06:41 <LoganCapaldo> as a random aside, heh
18:06:49 <lament> insane dosen't begin to describe it
18:06:57 <lament> LoganCapaldo: are they SQL queries? :)
18:07:18 <LoganCapaldo> I'm thinking of something more tuned for the the given language
18:07:20 <lament> do you want to treat the SQL code itself as a database that you can run queries against?
18:07:20 <Philippa_> LoganCapaldo: starting point for a good refactoring tool, that
18:07:24 <lament> And then it's queries all the way down.
18:07:30 <LoganCapaldo> Philippa_: exactly
18:07:33 <Cin> lament: ah, that's what i thought :P
18:07:48 <Philippa_> nothing wrong with a little reflection
18:07:59 <Philippa_> it's your problem if you actually try to stack it infinitely deep
18:08:00 <Nafai> LoganCapaldo: Being able to easily navigate and "query" code in a language-aware way is essential to productivity, I think
18:08:22 <sethk> is there a function like words, only allowing the specification of the delimiter instead of using space?
18:08:30 <LoganCapaldo> Nafai: I agree
18:09:00 <nelhage> @hoogle [a] -> a -> [[a]]
18:09:00 <lambdabot> No matches, try a more general search
18:09:08 <Nafai> That's why using Java has taught me to like IDEs vs just text editors
18:09:08 <nelhage> @hoogle a -> [a] -> [[a]]
18:09:08 <lambdabot> No matches, try a more general search
18:09:19 <Nafai> No more using find and grep to locate things in my code
18:09:59 <Cin> nafai: instead you point and click at a definition?
18:10:14 <ehird`> Nafai: oh noes how could you ever use 'grep@/
18:10:17 <mrd> um, emacs has supported find-definition since before the people who wrote Eclipse were born
18:10:25 <ehird`> grep is hard, let's go eclipsing
18:10:25 <mrd> see hasktags
18:10:31 * Nafai sighs
18:10:37 <Cin> ehird`: hehe
18:10:39 <Nafai> No, I don't point and click
18:10:51 <ehird`> see, i never implied that
18:10:52 <ehird`> but you did
18:11:00 <Nafai> ehird`: How?
18:11:05 <ehird`> Nafai: just there.
18:11:11 <ehird`> i never said 'point and click' -- not once
18:11:18 <LoganCapaldo> but Cin did
18:11:24 <LoganCapaldo> fyi
18:11:32 <ehird`> ah
18:11:34 <ehird`> didn't see that
18:11:40 <LoganCapaldo> clearly
18:11:47 <Nafai> But grep isn't aware of your language
18:11:53 <ehird`> Nafai: makes no difference
18:11:57 <mrd> then quit using it
18:12:06 <ehird`> no eclipse nonsense is going to match half of what you can do with a good line of pipes in your favourite shell ;)
18:12:38 <Nafai> I use the shell as much as any one
18:12:44 <Philippa_> mrd: emacs as IDE platform, news at 11
18:12:47 * Nafai gives up
18:13:02 <mrd> news at 11, 20 years ago
18:13:14 <Philippa_> like that matters a shit
18:14:39 <Philippa_> it also doesn't say anything to contradict Nafai's basic point
18:14:43 <mrd> sethk: no
18:15:06 <mrd> sethk: unless you count splitRegex
18:15:32 <mrd> what's his basic point?
18:15:52 <LoganCapaldo> find definition is the least interesting thing you can do when navigating code. I want to be able to accurately find the call-sites, I want to ask questions like, if this function has default parameters, how often are they used vs. someone explicitly passing in a vlaue? I want know things like, which datastructures hae a given datastructure as a component of them, etc.
18:15:55 <mrd> maybe you are interpreting it different from me
18:16:07 <Philippa_> that working with code-aware tools rather than ones that think everything is plain text is important
18:16:08 <gwern> mrd: 20 years ago? hah. it's 2008 man, redo your sums (2008-~1976)
18:16:33 <mrd> because when I use emacs, I ask it plenty of questions about my program and get answers
18:16:34 <Philippa_> it doesn't matter whether you build your environment in elisp, java or brainfuck
18:16:36 <mrd> and vim too
18:16:48 <mrd> so his point seems kind of, odd, to me
18:16:55 <ehird`> 'is my program cuddly?'
18:16:56 <ehird`> 'NO.'
18:16:59 <Philippa_> emacs isn't a text editor, it's a platform with an editor bundled
18:17:20 <ehird`> Philippa_: that joke is older than emacs.
18:17:21 <Philippa_> vim steps somewhat beyond "plain text editor" too
18:17:36 <Philippa_> ehird`: and the point still stands
18:17:48 <Philippa_> if someone says "text editor" and you're using emacs as a counterexample, consider why
18:17:51 <kpreid> Philippa_: it's a platform which stuffs everything in a buffer...
18:17:52 <monochrom> http://hpaste.org/5308#a3 and http://hpaste.org/5308/3/plain  :)
18:18:04 <Philippa_> kpreid: buffer, file, what's the difference?
18:18:17 <Nafai> I use Emacs when I'm not doing Java development, btw
18:19:34 * EvilTerran uses vim for pretty much everything, java included.
18:19:43 <ehird`> monochrom: aww, but there's no way to wrap it in a display:none
18:19:44 <mrd> reinke's vim plugins for haskell are pretty slick
18:19:48 <ehird`> without getting a syntax error from haskell
18:19:55 <ehird`> or even styling it to be non-obtrusive
18:19:59 <EvilTerran> i don't do enough java for learning my way around a new IDE to be worth my while yet
18:20:14 <inimino> just wait for Java to die
18:20:17 <lispy> Sometimes, I find (.) to be really hard to understad.  I have this code: (fmap foo . parse i1) and that (fmap foo .) is hard for me to reason about
18:20:33 <ehird`> lispy: (fmap foo (parse i1 _))
18:20:45 <EvilTerran> monochrom, your HTML's broken, you've got an unmatched >
18:20:48 <ehird`> insert parameter as _. it's not thathard, you just have to add the extra paren and the parameter
18:20:56 <ehird`> EvilTerran: hahahaha
18:20:57 <ehird`> :-)
18:21:03 <ehird`> hmmm:
18:21:03 <EvilTerran> if you were feeling clever, you could finish lines with -- <br/
18:21:08 <EvilTerran> and start the next line with >
18:21:24 <lispy> ehird`: oh right, thanks
18:21:42 <lispy> ehird`: where _ is some parameter?
18:21:52 <ehird`> <div class="foo">%begin{code}--</div> CODE HERE......
18:21:56 <ehird`> dunno how to handle %end{code}
18:22:01 <ehird`> lispy: ok:
18:22:11 <ehird`> (a . b) -> (\x -> a (b x))
18:22:30 <ehird`> it means 'this function is b, but then we give that to a', kind of.
18:22:36 <sethk> @hoogle (dropWhile.dropWhile)
18:22:37 <lambdabot> Did you mean: DropWhile.dropWhile
18:22:37 <lambdabot> Prelude.undefined :: a
18:22:37 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
18:22:39 <lispy> ehird`: yeah, I just didn't think to rewrite it the obvious way, thanks :)
18:22:49 <ehird`> np :)
18:23:45 <lispy> ehird`: it's presented that way because the stuff in parens i showed is passed as a function to another function which is expected a function...ah pointfree...
18:23:47 <Cin> oh dear. xmonad appears to have died on my second workspace
18:23:59 <ehird`> actually, my structured editor should support writing literate haskell in tex, which is then converted to HTML but specially to compensate for the haskell and give it a lovely display
18:24:00 <ehird`> :D
18:24:05 <sethk> What's the way to write this using function composition?  dropWhile (\x -> x==',') $ dropWhile (\x -> x/=',') "abc,def,ghi"
18:24:15 <ehird`> @pl dropWhile (\x -> x==',') $ dropWhile (\x -> x/=',') "abc,def,ghi"
18:24:15 <lambdabot> dropWhile ((',') ==) (dropWhile ((',') /=) "abc,def,ghi")
18:24:19 <ehird`> just like that
18:24:36 <sethk> ehird`, I meant can it be written as (dropWhile.dropWhile) (something)?
18:24:43 <ehird`> sethk: why not ask lambdabot?
18:24:46 <ehird`> and no
18:24:47 <ehird`> it canot.
18:24:49 <ehird`> *cannot
18:25:06 <sethk> ehird`, then I don't have to ask lamdabot  :)  I'll have to think about why not
18:25:20 <ehird`> because
18:25:24 <ehird`> (dropWhile.dropWhile) something
18:25:25 <ehird`> is:
18:25:29 <ehird`> dropWhile (dropWhile something)
18:25:36 <ehird`> right from the start you've got your params messed up
18:25:40 <litb> i wonder whether there is a Data type that supports enumeration?
18:25:52 <sethk> ehird`, ok, I see, thanks
18:26:00 <Cin> litb: instances of Enum?
18:26:06 * gwern sends off my email to Jeremy Shaw. ah. good to have the Debian package fixed; if he won't upload, I will
18:26:14 <nelhage> @src words
18:26:14 <lambdabot> words s = case dropWhile isSpace s of
18:26:14 <lambdabot>     "" -> []
18:26:14 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:26:19 <litb> so that ["01.01.1990" .. "20.10.2008"] :: [Date] works?
18:26:29 <litb> sorry i mean instances of Enumeration
18:27:05 <jorik808> can anyone please take a look at the code in: http://hpaste.org/5536, iam trying to create a parser for a toy language but i suddeny realized it was very very slow because i had a lot of try's so im trying to get rid of them, but i can't seem to figure out how.
18:27:13 <sethk> nelhage, hmm, that looks a lot uglier than mine  :)
18:27:22 <litb> or is it called Enum ?
18:27:27 <litb> @src Enum
18:27:27 <lambdabot> class  Enum a   where
18:27:27 <lambdabot>     succ                     :: a -> a
18:27:27 <lambdabot>     pred                     :: a -> a
18:27:27 <lambdabot>     toEnum                   :: Int -> a
18:27:27 <lambdabot>     fromEnum                 :: a -> Int
18:27:29 <lambdabot> [3 @more lines]
18:27:31 <litb> yeah i mean enum
18:27:41 <Cin> perhaps with a deriving (Enum) clause
18:27:42 <sethk> but will mine fail with the empty string?
18:27:44 <sethk> I think so
18:27:50 <litb> i thought i had written Enumeration :p
18:27:59 <sethk> no, just returns "", which is fine.
18:28:08 <litb> Cin: i mean whether there is a predefined Date type to enumerate dates
18:28:12 <Cin> litb: although it would probably only work with like data Date = Date Int Int Int deriving (Enum), instead of using a string
18:28:20 <Cin> litb: ah. i dunno
18:28:29 <LoganCapaldo> @hoogle Date
18:28:30 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
18:28:30 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
18:28:30 <lambdabot> Data.Time.Calendar.OrdinalDate :: module
18:28:33 <twanvl> jorik808: You need to indent the <|> and the second do block, otherwise they are considered separate statements in the outer do block
18:29:06 <litb> > ["01.02.03" .. "02.03.03"] :: [OrdinalData]
18:29:08 <lambdabot>   Not in scope: type constructor or class `OrdinalData'
18:29:10 <litb> o.O
18:29:21 <litb> oh darn it is a module
18:29:52 <jorik808> hmm, it compiles now, but it doesn't work
18:30:02 <Cin> @src System.Locale.TimeLocale
18:30:03 <lambdabot> Source not found. My mind is going. I can feel it.
18:31:02 <litb> hmm
18:31:05 <twanvl> jorik808: "doesn't work" is not very precise
18:31:16 <litb> i don't know what i should code. some ideas?
18:31:17 <jorik808> i already found it
18:31:19 <jorik808> :)
18:31:39 <jorik808> iam making a great language man, the parser is almost done i'm so proud of it
18:31:42 <litb> i've already written n choose k:
18:31:52 <bd_> jorik808: http://hpaste.org/5536#a1
18:32:01 <bd_> not sure why it didn't announce
18:32:13 <litb> > let nuk n k = foldl (\x y -> (x * (n+1-y)) `div` y ) 1 [1..k] in sum [ nuk 10 i | i<-[0..10] ]
18:32:15 <lambdabot>  1024
18:32:26 * gwern wonders what a 'session type' is. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sessions-2007.7.15
18:32:27 <bd_> jorik808: possibly a better approach would be to look into building an expression parser
18:32:28 <lambdabot> http://tinyurl.com/2ty3tq
18:32:36 <jorik808> bd_ hmm, lemme test, it certainly looks better than all my code
18:33:05 <jorik808> yeah i thought about that but it's i dunno i think it will be more "learnfull" not to use the wrapper
18:33:39 <bd_> painful, too :)
18:33:47 <jorik808> because getting the BNF completely working in parsec and all is already done for the bigger part
18:33:50 <bd_> depends on your lanugage I guess
18:35:05 <jorik808> well, it's just to get to learn haskell, it's a small toy language
18:36:02 <gwern> wow. I think this is the first time I've seen a type sig a page long, in this sessions package
18:36:30 <LoganCapaldo> is the actual function significantly shorter than the type sig?
18:36:50 <gwern> about half the size, I'd estimate
18:36:50 <natv_> import Alt.Fan.Warlord
18:37:01 <LoganCapaldo> than all is right with the universe
18:37:06 <LoganCapaldo> maybe :)
18:38:10 * gwern snorts. case all of Just all -> print "God is in his heaven and all is right with the world"; Nothing -> print "Commencing Human Instrumentality Project..."
18:39:50 <bd_> gwern: Won't compile under -W -Werror :)
18:39:56 <bd_> or is it -Wall
18:40:02 <bd_> (unused variable)
18:40:13 <gwern> bd_: -Wall -Werror ftw
18:40:39 <LoganCapaldo> -fdisallow-incoherent-programmer
18:40:57 <bd_> gwern: also variable hiding variable inanother scope
18:40:59 <LoganCapaldo> I should never become a compiler writer
18:41:21 <LoganCapaldo> all my options would have stupid names like that
18:41:53 <LoganCapaldo> I can see the irc conversations now
18:42:14 <LoganCapaldo> "Well did you compile with -fdisallow-incoherent-programmer?" "..."
18:42:15 * gwern sees none of y'all are anime fans, apparently. fine! I'll go start my own #haskell, with lambdas and injokes and hookers and beer! actually, forget the lambdas
18:42:22 <tennin> what would you say are the math/CS prerequisites for Pierce's category theory for computer scientists book?
18:42:44 <LoganCapaldo> a heart of gold, and a tender touch
18:42:47 <gwern> LoganCapaldo: "No, I think I was drunk at the time. Or high. It all sort of blends together,,,"
18:43:09 <jorik808> bd_, i forgot to add the terminal case to the code, and it carried over to your code. what do you think of this solution: http://hpaste.org/5536#a2
18:43:34 <jorik808> i still don't understand what unit does
18:43:43 <radetsky> is this a good way to tree-fold?
18:43:45 <radetsky> treeFoldR f i (Node x []) = f x i
18:43:45 <radetsky> treeFoldR f i (Node x (t:ts)) = treeFoldR f (treeFoldR f i t) (Node x ts)
18:43:48 <jorik808> oh wait oki see it
18:44:02 <radetsky> library doesn't seem to include a reference
18:44:07 <radetsky> it just has flatten
18:44:17 <litb> sorry guys, what is the euler number?
18:44:19 <radetsky> (which might be a better way, but there you go)
18:44:21 <bd_> jorik808: well, it works, I guess, though I'm not sure what your language looks like, so I don't know if it does what you want it to do :)
18:44:25 <litb> @hoogle e
18:44:30 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
18:44:30 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
18:44:30 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
18:44:35 <litb> oops
18:45:14 <jorik808> bd_, it looks like this: \o_o.'(hello there)
18:45:26 <bd_> I'm not sure where : and := comes in there :)
18:45:42 <jorik808> :defintion :=assignment
18:45:48 <litb> looks like exp 1 is what i want
18:45:52 <LoganCapaldo> well that's just what it looks like before the preprocessor gets to it
18:46:40 <LoganCapaldo> #define \o_o :=
18:46:57 <tennin> I'm an anime quasi-fan.  EVA is a cautionary tale --- base your giant robot software on Freudian psychology and mysticism rather than solid mathematical foundations, and watch everyone get turned into goo
18:47:09 <LoganCapaldo> \o_o looks like a frog waving
18:47:32 <radetsky> LoganCapaldo: or the identity function
18:47:40 <jorik808> radetsky, excactly
18:47:59 <gwern> tennin: sure, but base your robot on sound nuclear propulsion, and then you get a cautionary tale about people hacking into it to make you look bad
18:48:01 <LoganCapaldo> nope, definitely a frog waving
18:48:05 <blbrown> tennin, I think that is beyond quasi-fan
18:48:16 <litb> @src product
18:48:16 <lambdabot> product = foldl (*) 1
18:48:23 <litb> hm, it's not strict
18:48:34 <jorik808> i'm tempted to have variable case insensitive just so i can have \o_O
18:48:41 <litb> ah it's in Data.List
18:49:45 <litb> @src foldl'
18:49:46 <lambdabot> foldl' f a []     = a
18:49:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:50:03 * gwern 's hands hurt. I think I'll call it a night as far as haskell hacking is concerned
18:51:07 <litb> darn (fromIntegral $ foldl' (*) 1 [1..10^6]) seems to take looong
18:52:03 <radetsky> nobody hates my tree-fold?
18:52:38 <Twey> @src foldr
18:52:38 <tylos_> umm, is there a way to do function composition (f . g)  that does what I'd expect when g takes more than 1 argument?
18:52:38 <lambdabot> foldr k z xs = go xs
18:52:39 <lambdabot>     where go []     = z
18:52:39 <lambdabot>           go (y:ys) = y `k` go ys
18:52:50 <tylos_> (normally I'd expect it to apply parameters to g and then apply the result to f)
18:53:18 <tylos_> but it doesn't do that...
18:53:18 <Twey> @pl \x y -> f (g (x y))
18:53:18 <lambdabot> ((f . g) .)
18:53:24 <litb> damn is it normal that i cannot interrupt a foldl' ?
18:53:25 <Twey> tylos_: Like that ^
18:53:49 <Twey> tylos_: @pl is awesome :-D
18:53:57 <tylos_> :)
18:54:00 <twanvl> > foldl' (+) 0 $ map log [1..10^6] -- litb your number will be this large
18:54:02 <lambdabot>  1.281551838465788e7
18:54:48 <tylos_> well I'd like it to be able to handle any number of parameters not just a specified amount
18:55:03 <tylos_> @pl \x y z-> f (g (x y z))
18:55:03 <lambdabot> (((f . g) .) .)
18:55:07 <yondalf> > [1,2,3] !! 0
18:55:08 <lambdabot>  1
18:55:13 <scook0> :t (.).(.)
18:55:14 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:55:17 <scook0> :t (.).(.).(.)
18:55:18 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
18:55:22 <twanvl> litb: possibly your computation is busy multiplying huge numbers with GMP, i.e. not haskell code, i.e. not interuptable. At least, that's my theory.
18:55:43 <radetsky> can you pattern match against the end of a list?
18:56:00 <radetsky> i.e. f (xs:x:[]) = stuff
18:56:26 <yondalf> > splitAt 2 [1..4]
18:56:27 <lambdabot>  ([1,2],[3,4])
18:56:38 <scook0> radetsky: nope
18:56:40 <tennin> oh wow, Pierce's book is under 100 pages.  guess there's no excuse not to read it
18:57:19 <scook0> you could conceivably set up some kind of view type
18:57:33 <scook0> or pattern match against (reverse xs) instead of (xs)
18:57:35 <tennin> it would have to be xs ++ (x:[]), and ++ isn't a constructor
18:58:01 <scook0> e.g. Data.Sequence lets you pattern-match against the head or the tail end
18:59:49 <yondalf> scook0: how does Data.Sequence let you pattern match against the head or tail?
18:59:54 <radetsky> scook0: if I pattern match against (reverse xs) in a recursive function, I'd think I'd keep flipping hte list
19:00:09 <BMeph> litb: foldl' it strict on its arguments, so yes. ;)
19:00:19 <scook0> yondalf: you can't do it directly; you actually match on an intermediate "view" type
19:00:28 <yondalf> scook0: oh
19:00:48 <litb> oh whywas that computed so fast?
19:00:53 <litb> > foldl' (+) 0 $ map log [1..10^6]
19:00:55 <lambdabot>  1.281551838465788e7
19:01:03 <litb> is multiplying very costly?
19:01:28 <scook0> case (viewR sequence) of EmptyR -> ... ; (xs :> x) -> ...
19:02:30 <radetsky> oh well, it's easiest to just do "where t = last; ts = init"
19:03:28 <radetsky> or something like that, but which is actually correct
19:03:29 <scook0> radetsky: right, but if you do the flipping once in a wrapper function, and then have your recursive function assume an already-reversed list ...
19:03:51 <radetsky> scook0: I don't think that will work in the context of what I'm trying to do
19:04:15 <scook0> radetsky: maybe not, but it's a nice technique to have in your toolbox :)
19:04:44 <radetsky> doesn't matter, the thing works properly now
19:04:44 <scook0> are you doing a lot of matching on both the head and the tail of (relatively long) lists?
19:04:47 <monochrom> EvilTerran: http://validator.w3.org/check?uri=http%3A%2F%2Fhpaste.org%2F5308%2F3%2Fplain&charset=%28detect+automatically%29&doctype=Inline&group=0 approves it, so I don't think there is a problem. :)
19:04:59 <radetsky> scook0: no, I'm trying to fold on trees
19:05:19 <EvilTerran> huh. that's weird.
19:05:20 <radetsky> essentially, I'd have to call the wrapper every time I go down a level
19:05:41 <radetsky> not very convenient
19:10:02 <radetsky> treeFoldR :: (a -> b -> b) -> b -> Tree a -> b
19:10:02 <radetsky> treeFoldR f i (Node x []) = f x i
19:10:02 <radetsky> treeFoldR f i (Node x l) = treeFoldR f (treeFoldR f i t) (Node x ts) where
19:10:02 <radetsky>   t   = last l
19:10:02 <radetsky>   ts  = init l
19:11:06 <yondalf> ?info guard
19:11:06 <lambdabot> guard
19:11:11 <yondalf> ?src guard
19:11:11 <lambdabot> guard True  =  return ()
19:11:11 <lambdabot> guard False =  mzero
19:12:38 <bd_> guard = (`when` mzero) . not
19:13:03 <scook0> radetsky: remember that init is relatively expensive
19:13:27 <vincenz> radetsky: there's an easier way
19:13:45 <scook0> it looks like your code will end up copying O(n^2) conses
19:13:46 <vincenz> I think
19:13:52 <radetsky> vincenz: besides flatten & fold?
19:14:20 <radetsky> ITC: premature optimization
19:14:42 <vincenz> radetsky: tho, for one, this is not a proper fold
19:14:51 <vincenz> radetsky: and that's not a proper tree
19:15:28 <radetsky> vincenz: I don't know what you mean by it not being a proper tree
19:15:37 <radetsky> it's essentially how tree is defined in Data.Tree
19:15:40 <vincenz> radetsky: you have no concept of empty tree
19:16:09 <vincenz> radetsky: yes, and I don't agree with it ;)
19:16:22 <vincenz> not the first time I argue against trees without leafs
19:16:28 <magnus_> I am experiencing some weird interaction between type inference and type declarations... without type decls the code infers fine the type I expect, but with that same type provided, the type system complains. Any ideas? The code (reduced) is at: http://hpaste.org/5537
19:16:50 <scook0> magnus_: without looking, it's probably scoped type variables ;)
19:17:10 <scook0> oh, maybe not
19:17:32 <lispy> magnus_: what is the type error?
19:17:41 <radetsky> vincenz: do you need an empty tree for a fold?
19:17:43 <vincenz> :t foldr
19:17:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:17:49 <vincenz> radetsky: orthogonal issues
19:17:52 <magnus_> lispy: I'll add an annotation
19:18:00 <radetsky> vincenz: that's what I was trying to establish
19:18:36 <radetsky> ok, so why isn't it a proper fold?
19:19:06 <scook0> magnus_: hmm, maybe it's a fundep issue
19:19:23 <EvilTerran> but there's no fundeps
19:19:29 <vincenz> radetsky: well usually fold on empty is simply i
19:19:30 <vincenz> radetsky: but ok
19:19:34 <vincenz> radetsky: if you want to stick with this
19:19:35 <vincenz> try this
19:19:40 <vincenz> with a non associative operator
19:19:46 <vincenz> treeFoldR :: (a -> b -> b) -> b -> Tree a -> b
19:19:46 <vincenz> treeFoldR f i (Node x []) = f x i
19:19:46 <vincenz> treeFoldR f i (Node x l)  = foldr (\t v -> treeFoldR f v t) (f x i) l
19:19:46 <magnus_> lispy: annotation added
19:20:00 <vincenz> and actually
19:20:03 <vincenz> drop the first case :)
19:20:08 <vincenz> treeFoldR :: (a -> b -> b) -> b -> Tree a -> b
19:20:08 <vincenz> treeFoldR f i (Node x l)  = foldr (\t v -> treeFoldR f v t) (f x i) l
19:20:18 <magnus_> scook0: /me looks up what fundep means
19:20:32 <radetsky> ok, why is that a proper fold?
19:20:38 <lispy> magnus_: it's barfing on the inner eval
19:20:40 <vincenz> radetsky: I didn't say this was
19:20:44 <magnus_> lispy: yup
19:20:46 <vincenz> radetsky: this does what your code does
19:21:01 <vincenz> but shorter
19:21:08 <lispy> magnus_: try this, replace 'v <- eval e1' with 'v <- undefined'
19:21:14 <lispy> magnus_: does it accept your type signature now?
19:21:17 <EvilTerran> is this the mind-bending matter of recursing with a different amount of polymorphism>
19:21:19 <EvilTerran> ?
19:21:45 <magnus_> lispy: it doesn't
19:21:58 <radetsky> vincenz: I believe you. However, I'm still trying to figure out this notion of "proper fold" that you brought up
19:22:02 <BMeph> magnus_: Are you sure that your program always knows that "id" refers to the pattern-matched string, and not to the 'id' function?
19:22:02 <scook0> it typechecks if I add the fundep | m -> a
19:22:08 <vincenz> radetsky: well usually your data type
19:22:09 <vincenz> is
19:22:15 <vincenz> mu x. 1+ a*x for a list
19:22:16 <vincenz> or
19:22:20 <vincenz> mu x. 1+ a*x*x for a tree
19:22:27 <lispy> magnus_: I think (but, I'm not sure) the problem is that it is not able to make a1 (the type it infers) match a (the type you specificed)
19:22:30 <vincenz> as such a fold provides a function for each case
19:22:35 <vincenz> let's take the list
19:22:38 <vincenz> mu x. 1+ a*x for a list
19:22:40 <radetsky> what is mu?
19:22:48 <vincenz> radetsky: fix for types if you will
19:22:52 <EvilTerran> magnus_, the problem is that it can't tell that the a in (eval e1 :: Machine m a => m a) is the same as the one in (eval exp :: Machine m a => m a)
19:22:53 <magnus_> lispy, scook0: Aah, that makes sense when bringing your replies together :)
19:23:03 <vincenz> radetsky: so we need a casae for 1, which is a constant function or just a value
19:23:14 <magnus_> a must be uniquely determined by m
19:23:18 <vincenz> radetsky: and a case for a*x , and since the 'x' will aready be folded
19:23:22 <lispy> EvilTerran: can you slove this without a fundep?
19:23:24 <vincenz> we need a function (a -> b -> b)
19:23:32 <radetsky> vincenz: I have no idea what you are doing here
19:23:35 <vincenz> ok
19:23:36 <vincenz> nm then
19:23:48 <EvilTerran> http://hpaste.org/5537#a3 <- maybe?
19:24:09 <lispy> EvilTerran: hmm...clever
19:24:13 <EvilTerran> magnus_, will each m only ever have one a? if that's the case, a fundep would wor
19:24:13 <lispy> EvilTerran: if it works :)
19:24:26 <tennin> radetsky: his mu x. ... notation for a recursive type
19:24:41 <vincenz> EvilTerran: no
19:24:51 <lispy> I think you can also, say, forall a. (Machine m a) => ...
19:24:56 <EvilTerran> magnus_, otherwise you'll have to resort to trickery like mine, or ScopedTypeVariables
19:24:57 <EvilTerran> vincenz, what?
19:25:09 <lispy> and that will make 'a' be statically scoped over the function body
19:25:35 <magnus_> EvilTerran: m -> a is indeed how I was thinking of it in my head
19:25:42 <vincenz> http://hpaste.org/5537#a4
19:25:55 <BMeph> "return eval e2, maybe?
19:26:01 <BMeph> s/,/,"/
19:26:13 <lispy> vincenz: oh, that makes sense
19:26:36 <lispy> the type parameter is really for the monad
19:26:42 <lispy> not the machine
19:27:02 * EvilTerran gives up and wanders off
19:27:05 <magnus_> vincenz: that will not be what I expect I think. I want a to be the same for all members of the type class. I don't want a to mean polymorphic arguments
19:27:17 <EvilTerran> it's far too late at night for this sort of thinking :P
19:27:55 <scook0> magnus_: wait, you want a to be the same for all instances? in that case, why make it a variable at all?
19:28:00 <scook0> (unless I've misunderstood you)
19:28:04 <tennin> radetsky: in his mu x. 1 + a*x for a list,  the "+" is a disjoint union operator, i.e. type a + b would be a type that allows the values in a plus the values in b, and discriminates between the two.  like a type with two variants/constructors in Haskell, Left a | Right b
19:28:18 <magnus_> scook0: it should be determined uniquely by m
19:28:29 <lispy> scook0: I think magnus_ means, all functions in the class should use the same a, for any given istance of the class
19:28:39 <magnus_> lispy is right
19:29:02 <scook0> so there can only be one a for any m
19:29:09 <magnus_> yep
19:29:15 <radetsky> tennin: 1 is the unit, in this case Nil or []?
19:29:18 <lispy> well, that's a fundep then
19:29:19 <tennin> and the "*" is product, like a constructor with multiple arguments in Haskell... the 1 is like a type with one value
19:29:19 <scook0> in which case the | m -> a fundep seems to be the correct answer
19:29:20 <tennin> yeah
19:29:29 <magnus_> yes
19:29:46 <tennin> and then the mu x. just allows the type to be recursive, so you can use x to reference the type within the body of the type
19:30:28 <EvilTerran> or, if you're on ghc6.8 and feel like playing the guinea pig, an associated type family would also work
19:30:28 <radetsky> i.e. 1 | a * 1 | a * a * 1 | ...
19:30:51 <radetsky> oh, wait, I don't think that's right
19:31:30 <vincenz> radetsky: yes it is, that's a list
19:31:38 <lispy> magnus_: but it does seem a bit limiting to me that way
19:31:44 <LoganCapaldo> mu x . 1 + a*x*x is approx. to newtype Tree a = Tree (Either () (a, Tree a, Tree a)) ?
19:31:55 <lispy> magnus_: because then if you use Maybe Int for your monad, then you can't also have Maybe String, right?
19:32:03 <BMeph> radetsky: Î¼ x . 1 + a * x ==> data List a = Nil | Cons a (List a)
19:32:06 <radetsky> vincenz: thanks, I see it now
19:32:14 <vincenz> mu x.1+a*x*x == data Tree a = Emp | Tree a (Tree a) (Tree a)
19:32:19 <lispy> magnus_: or maybe i'm wrong (fundeps are not something i understand fully)
19:32:28 <vincenz> radetsky: when folding, you supply a function combiniining the children for each case
19:32:38 <EvilTerran> something like this: http://hpaste.org/5537#a5
19:32:39 <vincenz> but this tree definition is just wacky
19:32:48 <EvilTerran> lispy, no, that's how fundeps work
19:33:08 <EvilTerran> it does seem an odd requirement, altho easy enough to work around, especially if you allow newtype deriving.
19:33:11 <radetsky> vincenz: i.e. s/*/`f`/ ?
19:33:13 <vincenz> tennin: can you combine mu's?
19:33:17 <radetsky> if you see what I mean there
19:33:18 <vincenz> radetsky: yeah
19:33:25 <BMeph> radetsky: Î¼ x . 1 + a * x * x ==> data Tree a = Leaf | Branch a (Tree a) (Tree a)
19:33:34 <vincenz> and s/1/c/
19:33:40 <vincenz> radetsky: hence for the regular tree type
19:33:41 <vincenz> you need
19:33:48 <radetsky> BMeph: that's not the tree I was talking about
19:33:49 <lispy> EvilTerran: ah, good point.  Just have MaybeString derive from Maybe String and then you have a new monad  you can use?
19:33:55 <vincenz> foldTree :: (Tree a) -> c -> (a -> c -> c -. c)
19:33:59 <vincenz> ->c
19:34:00 <radetsky> I was talking about trees with variable numbers of children
19:34:13 <EvilTerran> lispy, well, you'd have to keep the type parameter in
19:34:17 <vincenz> radetsky: but as you can see, the case for this tree is a bit odd
19:34:21 <vincenz> tennin: can you combine mu's?
19:34:29 <vincenz> the type of radetsky's tree is
19:34:34 <BMeph> radetsky: Right. I'll go back and look. It is the tree vincenz is talking about, though. :)
19:34:37 <EvilTerran> newtype Maybe' a = Maybe' { getMaybe' :: Maybe a } deriving Monad -- kinda thing
19:34:37 <vincenz> mu t.a*(mu l.1+t*l)
19:34:42 <lispy> EvilTerran: okay, so maybe Maybe1, ..., MaybeN, for maybes as you need?
19:35:03 <EvilTerran> (as i said, assuming you allow LANGUAGE NewtypeDeriving)
19:35:17 <lispy> EvilTerran: well, who doesn't it's terribly useful :)
19:35:31 <vincenz> so a proper fold for that would be ..
19:36:45 <vincenz> (a -> b -> c) -> b -> (b -> c -> b) -> (T a) -> c
19:36:46 <vincenz> I think
19:36:57 <vincenz> where 'c' 'is return type for a 't'
19:37:02 <vincenz> and 'b' is return type for a 'l'
19:37:32 <vincenz> mke that (c -> b -> b) for the second function
19:37:58 <monochrom> > (, True) 'c'
19:37:59 <lambdabot>  Parse error at "True)" (column 4)
19:38:03 <monochrom> > ( , True) 'c'
19:38:03 <lambdabot>  Parse error at "True)" (column 5)
19:38:15 <vincenz> monochrom: you can't section (,)
19:38:24 <vincenz> > (flip (,) True) 'c'
19:38:26 <lambdabot>  ('c',True)
19:38:37 <EvilTerran> unfortunately
19:38:48 <wagle_home> :t (,)
19:38:49 <lambdabot> forall a b. a -> b -> (a, b)
19:39:02 <radetsky> vincenz: let me stare at that stuff for a while
19:39:12 <wagle_home> > (1,) 2
19:39:12 <lambdabot>  Parse error at ")" (column 4)
19:39:28 <vincenz> radetsky: ok
19:39:29 <wagle_home> > (,) 1 2
19:39:30 <lambdabot>  (1,2)
19:39:53 <tennin> vincenz: isn't that an infinite type?
19:39:59 * wagle_home scratches head
19:39:59 <BMeph> radetsky: You're using one of those "rose trees," right?
19:40:01 <tennin> but you probably know much more about this stuff than I
19:40:07 <radetsky> BMeph: yeah
19:40:23 <radetsky> I would have thought the right thing to call them would be "trees"
19:40:38 <radetsky> since they aren't binary trees or any particular arity of trees
19:40:51 <radetsky> but apparently this is not how it's done
19:40:51 <vincenz> tennin: nope, due to the 1 in the list
19:41:06 <Pseudonym> Woo.  That was fun.
19:41:13 <BMeph> radetsky: Cool. I'm thinking of using that myself, for translating the algorithm for counting trees.
19:41:22 <Pseudonym> Caught up with Bernie Pope.  Haven't seen him in a while.
19:41:30 <radetsky> using what?
19:41:57 <BMeph> Using a rose tree structure.
19:42:53 <radetsky> wait, then what kind of trees are you counting?
19:42:55 <lispy> I think sigfpe had an article recently about infinite types in haskell programs
19:43:21 <lispy> it was a good read, involved some sort of paradox
19:43:25 * lispy forgets the details
19:43:53 <EvilTerran> hm...
19:43:56 <EvilTerran> @botsback
19:43:57 <lambdabot> :)
19:44:53 <dmwit> If you keep feeding her like that, she'll get fat!
19:45:10 <vincenz> @botsnack
19:45:10 <lambdabot> :)
19:45:12 <vincenz> @botsnack
19:45:12 <vincenz> @botsnack
19:45:13 <lambdabot> :)
19:45:13 <lambdabot> :)
19:45:40 <dmwit> :)) -- suddenly, a chin appears!
19:45:51 <EvilTerran> i wasn't feeding her; merely observing that she'd come back
19:46:03 <EvilTerran> seeing as she was absent earlier
19:46:14 <dmwit> Heh, get her trained to come here.  Good idea.
19:46:33 <blbrown> @botsnack
19:46:33 <lambdabot> :)
19:46:44 <EvilTerran> @karma+ botsnack
19:46:44 <lambdabot> botsnack's karma raised to 1.
19:46:45 <radetsky> @botcrack
19:46:45 <lambdabot> :)
19:46:46 <blbrown> :) ...seriously, where is the smart AI, we can do better guys
19:47:00 <vincenz> @botsmack
19:47:00 <lambdabot> :)
19:47:14 <EvilTerran> @gotslack
19:47:14 <lambdabot> :)
19:47:18 <EvilTerran> :D
19:47:22 <blbrown> @lambdabot: what is god
19:47:22 <lambdabot> Unknown command, try @list
19:47:27 <vincenz> @gotmilk
19:47:27 <lambdabot> Unknown command, try @list
19:47:27 <blbrown> lambdabot: what is god
19:47:38 <EvilTerran> @vixen what is god?
19:47:38 <lambdabot> i dunno...
19:47:47 <EvilTerran> @vixen who are you?
19:47:47 <lambdabot> i'm just me :)
19:47:58 <blbrown> ok, there we go
19:48:04 <EvilTerran> @help vixen
19:48:04 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
19:48:13 <dmwit> ?botsmack
19:48:13 <dmwit> ?were wolf
19:48:13 <lambdabot> :)
19:48:13 * lambdabot howls
19:48:15 <blbrown> @vixen haskell
19:48:15 <lambdabot> Ooh, functional programmers are so hot!
19:48:26 <dmwit> Aw, rats, I was hoping they'd go out of order. =P
19:48:29 <blbrown> EvilTerran, can I marry it
19:48:37 <EvilTerran> @vixen blbrown wants to marry you
19:48:37 <lambdabot> Let's change the subject
19:48:45 <EvilTerran> ... ouch.
19:48:45 <dmwit> Good idea!
19:48:45 <lambdabot> blbrown: Come here you big lug.
19:48:52 <EvilTerran> wait what
19:49:04 * dmwit smells a puppetmaster
19:49:40 * lambdabot hugs dmwit
19:50:12 <dmwit> Oh, you minx you.
19:51:17 <vincenz> dmwit: care to experiment something?
19:51:33 <dmwit> I'm game.
19:51:36 <vincenz> dmwit: try @bot
19:51:42 <dmwit> @bot
19:51:43 <lambdabot> :)
19:51:44 <lambdabot> /ignore dmwit
19:51:46 <vincenz> hmm
19:51:49 <vincenz> seems not to work
19:51:54 <vincenz> I guess only /me works
19:51:59 <dmwit> I think /ignore is a client-specific thing.
19:52:11 <vincenz> ah
19:52:33 <vincenz> @tell dmwit' Hi
19:52:33 <lambdabot> Consider it noted.
19:52:34 <monochrom> @src join
19:52:35 <lambdabot> join x =  x >>= id
19:52:46 <dmwit> (Technically, /me is, too, but \bot probably has something special for that.)
19:52:50 <vincenz> odd
19:52:55 <vincenz> you can't use ' in nicks
19:53:17 <vincenz> @tell dmwit_ Hi
19:53:17 <lambdabot> Consider it noted.
19:53:21 <dmwit_> @messages
19:53:22 <lambdabot> vincenz said 4s ago: Hi
19:53:23 <dmwit> Hey!
19:53:35 * dmwit pokes vincenz
19:53:35 <thegraham> can you do 2^float in haskell?
19:53:39 <vincenz> dmwit: that's abug
19:53:40 <dmwit> (**)
19:53:47 <vincenz> dmwit: if you're not around, I can check your messags even
19:53:53 <vincenz> since lambdabot doesn't require registered poeple
19:53:53 <dmwit> Yeah, I know.
19:54:03 <vincenz> but first I wanted to test with dmwit'
19:54:06 <vincenz> but that seems to be a bug
19:54:08 <dmwit> thegraham: Have a look at (^^) and (**).
19:54:12 <vincenz> I can't /nick to dmwit'
19:54:17 <dmwit> Right.
19:54:21 <vincenz> @tell ' Hi
19:54:21 <lambdabot> Consider it noted.
19:54:39 <vincenz> @tell  Hi
19:54:39 <lambdabot> Consider it noted.
19:54:42 <vincenz> o.O
19:54:45 <dmwit> A new DOS attack: store loads of messages for people who can never receive them!
19:54:47 <Hi> test
19:54:47 <lambdabot> Hi: You have 1 new message. '/msg lambdabot @messages' to read it.
19:54:50 <Hi> oh
19:54:51 <Hi> @messags
19:54:52 <lambdabot> vincenz said 12s ago:
19:55:13 <vincenz> dmwit: right, thought that too
19:55:20 <vincenz> dmwit: except... you don't need special nicks for that
19:55:31 <thegraham> how do you cast in haskell (i want to add a float and the length of a list)
19:55:34 <vincenz> dmwit: so that is not particularly nick-related
19:55:42 <vincenz> thegraham: fromIntegral
19:55:44 <dmwit> thegraham: There's fromIntegral.
19:55:49 <vincenz> float + fromIntegral (length list)
19:56:12 <dmwit> vincenz: Right, it's just more annoying to fix if you use a nick like dmwit'.
19:56:29 <vincenz> @tell 'dmwit What?
19:56:29 <lambdabot> Consider it noted.
19:56:50 <dmwit> (You don't want to just empty the entire database of messages.)
19:57:12 <vincenz> dmwit: well, what if I just start @telling to unusednick
19:57:31 <BMeph> thegraham: Also, if you import Data.List, you can use genericLength.
19:57:32 <dmwit> Then to clear it out, I just have to /nick unusednick.
19:57:50 <dmwit> \bot has a ?clearmessages command or something.
19:58:00 <dmwit> So if you can actually log on as that nick, it's easy.
19:58:26 <vincenz> dmwit: I mean
19:58:31 <vincenz> someone could easaily DOS on some unused nick
19:58:32 <vincenz> like
19:58:36 <vincenz> @tell vincenzophile You love me
19:58:36 <lambdabot> Consider it noted.
19:58:54 <dmwit> Right.  I'm just saying it's easier to fix that attack than the one on dmwit'.
19:59:01 <vincenz> no it isn't
19:59:04 <dmwit> i.e. anybody in the room can fix that attack.
19:59:09 <vincenz> dmwit: if they knw
19:59:11 <vincenz> how do you know?
19:59:20 <vincenz> ./msg lambdabot ..
19:59:33 <dmwit> You don't, obviously, unless the attacker is stupid enough to do it in-channel.
19:59:39 <vincenz> exactly
19:59:42 <vincenz> so the problem is identical
20:00:05 <dmwit> ?where state
20:00:05 <lambdabot> I know nothing about state.
20:00:32 <vincenz> dmwit: do you want to be the one spammed with the 1M messages?
20:00:42 <dmwit> ?clear-messages
20:00:42 <lambdabot> Messages cleared.
20:00:50 <dmwit> easy as pie
20:01:34 <adu_> is (->) an instance of the Arrow class?
20:01:41 <dmwit> Yes.
20:01:44 <adu_> or a constructor?
20:01:53 <vincenz> both :)
20:01:59 <dmwit> It is a type constructor, *and* an instance of the Arrow class.
20:02:01 <adu_> i always get classes and constuctors mixed up
20:02:24 <dmwit> adu_: There's type constructors and value constructors...
20:02:32 <vincenz> dmwit: data
20:02:51 <dmwit> vincenz: I'd call that a value constructor. (?)
20:03:01 <vincenz> the proper terminology is data constructor
20:03:07 <dmwit> Oh, okay.
20:03:38 <dmwit> In any case, types and type constructors can also be instances of classes.
20:04:04 <dmwit> So it's easy to see how you might get type constructors and classes mixed up a bit at the beginning. =)
20:04:11 <scook0> in fact, they're the only things that can be instances of classes
20:04:12 <vincenz> dmwit: can they?
20:04:15 <radetsky> vincenz: I'm starting over on my treefolding project. Do you consider the following a proper tree?
20:04:16 <adu_> so (f >>> g = f . g) for Arrow (->) ?
20:04:17 <radetsky> data GBTree a = TerminalNode
20:04:17 <radetsky>               | Branch a (GBTree a) (GBTree a)
20:04:24 <vincenz> radetsky: yep
20:04:33 <vincenz> radetsky: that's the one I always use
20:04:44 <radetsky> how about this:
20:04:45 <dmwit> adu_: f >>> g = g . f
20:04:47 <radetsky> data GTree a = TerminalNode
20:04:47 <radetsky>              | Branch a (Forest a)
20:04:47 <radetsky> type Forest a = [GTree a]
20:04:48 <adu_> dmwit, I think I can tell the difference between those
20:05:02 <vincenz> erm erm
20:05:05 <adu_> o
20:05:15 <vincenz> radetsky: there's an issue with that repr
20:05:32 <radetsky> yeah, I'm not happy with it either
20:05:42 <vincenz> two ways of doing a single node tree
20:05:45 <adu_> dmwit, because type constructors usually appear in the "::" section and value constructors usually appear in the "=" section :)
20:05:50 <vincenz> acctualy
20:05:50 <vincenz> inf ways
20:06:00 <dmwit> adu_: Yeah. =)
20:06:03 <vincenz> Branch a (replicate n TerminalNode)
20:06:11 <scook0> data Tree a = Empty | Node { tValue :: a, tSibling :: Tree a, tChild :: Tree a }
20:06:24 <scook0> adu_: it can be confusing when both sorts of constructors use the same name
20:06:30 <vincenz> radetsky: perhaps that's why they chose for the way they did in Data.Tree
20:07:22 <vincenz> dmwit: not sure if types can be instances
20:07:25 <dmwit> data GTreeHelper a = Branch a [GTreeHelper a]
20:07:28 <vincenz> dmwit: I think only typeconstructors can be
20:07:35 <dmwit> type GTree a = Maybe (GTreeHelper a)
20:07:50 <dmwit> vincenz: Sure, types can be instances.
20:07:55 <dmwit> ?instances Bounded
20:07:56 <vincenz> I meant nullary type constructors too
20:07:58 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Int, Ordering, Product a, Sum a
20:08:04 <vincenz> thos are all type constructors
20:08:06 <vincenz> but tke
20:08:11 <vincenz> type Foo = ...
20:08:30 <dmwit> Ah, right, ok.  You're right, in H98 they can't be.
20:08:34 <adu> so for Arrow (->), does arr = id ?
20:08:39 <scook0> is there a term that unambiguously means "proper type or type constructor"?
20:08:49 <vincenz> scook0: type constructor?
20:08:57 <vincenz> you can have nullary type constructors
20:08:58 <vincenz> like Int
20:09:01 <dmwit> adu: Yep.
20:09:07 * dmwit wonders...
20:09:13 <adu> dmwit, cool, I think i'm starting to understand :)
20:09:14 <dmwit> ?src (->) arr
20:09:14 <lambdabot> arr f = f
20:09:21 <scook0> vincenz: sure, but "type constructor" implies "proper type constructor"
20:09:22 <dmwit> There you have it! =)
20:09:31 <vincenz> scook0: which can be of kind *
20:09:42 <adu> ?src id
20:09:42 <lambdabot> id x = x
20:09:49 <adu> hehe
20:10:03 <dmwit> They use different names, they must be different. =)
20:10:04 <scook0> vincenz: I'm not arguing that you're wrong, I'm arguing that the term can fail to capture the desired meaning
20:10:21 <vincenz> scook0: then that is context-dependent
20:10:29 <adu> ?src [] return
20:10:29 <lambdabot> return x    = [x]
20:10:33 <vincenz> scook0: most contexts, I'd think typeconstructor encapsulates it
20:10:38 <adu> ?src [] (>>=)
20:10:39 <lambdabot> m >>= k     = foldr ((++) . k) [] m
20:10:53 <vincenz> but again, terminology is the hardest part of problem solving
20:11:00 <adu> ?src IO (>>=)
20:11:00 <lambdabot> m >>= k     = bindIO m k
20:11:10 <adu> ?src ST (>>=)
20:11:10 <lambdabot> Source not found. I feel much better now.
20:11:11 <vincenz> @src bindIO
20:11:11 <lambdabot> bindIO (IO m) k = IO ( \ s ->
20:11:11 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
20:11:13 <vincenz> ooh
20:11:15 <scook0> I suppose "type of any kind" comes close
20:11:17 <vincenz> unIO !
20:11:29 <vincenz> > unIO
20:11:30 <lambdabot>   Not in scope: `unIO'
20:11:36 <adu> ?src unIO
20:11:36 <lambdabot> Source not found.
20:11:46 <vincenz> adu: prolly a record
20:11:47 <vincenz> like
20:11:52 <vincenz> IO { unIO :: ..}
20:11:57 <adu> o
20:12:07 <vincenz> > let (IO _) = print "hi"
20:12:07 <lambdabot>  Parse error at end of input
20:12:10 <vincenz> > let (IO _) = print "hi" in 1
20:12:11 <lambdabot>   Not in scope: data constructor `IO'
20:12:17 <vincenz> > let (IO a) = print "hi" in a
20:12:17 <lambdabot>   Not in scope: data constructor `IO'
20:12:26 <monochrom> @pl \x y -> l (w x y)
20:12:26 <lambdabot> (l .) . w
20:13:58 <dmwit> > unsafePerformIO $ print "hi" -- this can't possibly work
20:13:58 <lambdabot>   Not in scope: `unsafePerformIO'
20:14:13 <vincenz> @source unsafePerformIO
20:14:14 <lambdabot> unsafePerformIO not available
20:14:32 <dfranke> lambdabot cuts those out for security.
20:15:13 <adu> ?src interact
20:15:13 <lambdabot> interact f = do s <- getContents; putStr (f s)
20:15:50 <adu> ?src liftA2
20:15:50 <lambdabot> liftA2 f a b = f <$> a <*> b
20:15:55 <dfranke> btw, active Lisp vs. Haskell thread involving me and Paul Graham: http://news.ycombinator.com/item?id=111220
20:15:56 <lambdabot> Title: Hacker News | It's not true that static typing always makes languages weaker. It ...
20:19:42 <adu> dfranke, I'm not a user of "ycombinator"
20:20:56 <dick> dfranke, do you expect to change pg's mind?
20:21:04 <adu> I think the swiss/tool metaphor is backwards
20:21:30 <radetsky> dick: That's not how arguments work
20:21:49 <radetsky> you don't change the mind of the passionate defender of the other side, you change the minds of the observers
20:22:12 <dick> who decided that new rule?
20:22:19 <vincenz> dfranke: how trollbaity "I rarely need to calculate Fibonacci numbers, but I use lists of varied types of objects constantly."
20:22:26 <dmwit> ?remember radetsky <dick> do you expect to change pg's mind? <radetsky> That's not how arguments work.
20:22:26 <lambdabot> It is forever etched in my memory.
20:24:01 * radetsky is the alpha and omega of new rules
20:24:33 <dfranke> dick: not really, but maybe if I'm persistent enough I can at least get him to try Haskell.
20:24:38 <adu> Haskell is a Swiss metatool that let you build tools, while Lisp also has metatools, it primarily consists of so many tools you generally don't need to make your own
20:24:40 <dick> I don't suggest it is how arguments work (though I would suggest it is if probed); it was a question
20:24:57 <vincenz> dfranke: on a sidenote
20:25:12 <vincenz> dfranke: often when you want heterogeneous lists, they apply to some sort of interface
20:25:28 <vincenz> dfranke: an then you just you build an existential and an instance for that existnetial
20:25:33 <dfranke> dick: besides, I'm not really I'm on the opposite side.  I'm a non-partisan, not a Haskell-partisan.
20:25:37 <vincenz> dfranke: the only 'boilerplate'' then is to wrap the values in the data-const
20:25:42 <dfranke> s/really I'm/really/
20:25:47 <dick> dfranke, pg doesn't think that I bet
20:25:55 <adu> dfranke, what are the parties?
20:26:20 <dfranke> dibblego: he knows I'm a Lisper.
20:26:36 <dibblego> dfranke, that's at least a good start, but I'm still sceptical
20:26:52 <vincenz> unfinished blog-post : http://notvincenz.blogspot.com/2008/02/continued-fractions-in-haskell.html
20:26:52 <lambdabot> Title: lambda.oasis: Continued Fractions in Haskell, http://tinyurl.com/2tp4vg
20:34:38 <scook0> dfranke: it seems to me that dynamic languages encourage programming practices that are difficult to handle in typed languages
20:34:56 <scook0> so dynamic language users tend to underestimate the advantages and overestimate the disadvantages of types
20:35:00 <scook0> based on their current style
20:35:08 <scook0> (and vice-versa, probably)
20:35:30 <vincenz> > map show ([1, "foo"] :: [Show a])
20:35:33 <lambdabot>      Class `Show' used as a type
20:35:33 <lambdabot>     In the type `Show a'
20:35:33 <lambdabot>     In the type `[S...
20:35:38 <vincenz> > map show ([1, "foo"] :: [Show a => a])
20:35:39 <lambdabot>  Parse error at "=>" (column 33)
20:35:44 <vincenz> > map show ([1, "foo"] :: [forall a.Show a => a])
20:35:44 <lambdabot>  Parse error at ".Show" (column 34)
20:36:28 <vincenz> I think pg overrates heterogeneous lists
20:36:39 <vincenz> they're only useful if the elements are applicable to some sort of interface
20:36:44 <vincenz> and for that, we have existentials
20:37:17 <vincenz> unless you really have a heterogeneous list with some specific things at specific positions
20:37:24 <vincenz> and then you probably should use a data constructor
20:37:29 <Nafai> vincenz: What are existentials?
20:37:29 <vincenz> i.s.o. a list
20:37:59 <vincenz> Nafai: heterogeneously typed data
20:38:16 <pjd> Nafai: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
20:38:17 <lambdabot> http://tinyurl.com/f9umb
20:38:23 <vincenz> pjd: thx
20:38:31 <bd_> > [] :: exists x. Eq x => [x]
20:38:32 <lambdabot>  Parse error at "." (column 15)
20:38:36 <bd_> hm
20:38:43 * Nafai looks
20:39:03 <bd_> > [] :: forall x. Eq x => [x]
20:39:04 <lambdabot>  Parse error at "." (column 15)
20:39:32 <pjd> Nafai: the canonical example is "list of Show instances"
20:40:01 <dfranke> I think maybe a better way to put it is that Haskell is a much more opinionated language than Lisp.
20:40:14 <dfranke> but when you obey its opinions, it gives you advantages that Lisp can't give.
20:41:20 <radetsky> vincenz: he never mentions a specific example of a heterogenous list he needs
20:41:27 <vincenz> radetsky: yeah
20:41:35 <johnnowak> heterogenous lists can be very useful
20:41:35 <thetallguy> ?seen bos
20:41:35 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 3h 24m 23s ago.
20:42:53 <radetsky> like, if he needed a list of the form (x, y, x, y, ...) there's an obvious haskell equivalent which gives you all the good stuff and prevents the bad stuff
20:42:53 <thetallguy> Anyone have bos's thread program in its natural state?
20:43:28 <bos> que?
20:43:53 <radetsky> if he needed a list consisting of a random sequence of x's and y's in which he expects to have run-time type information, there's also a haskell solution that gets the job done fine
20:44:01 <bos> thetallguy: give me an address and i'll email it to you
20:44:04 <johnnowak> radetsky: i think pg just isn't interested in informing the type system of his intentions.
20:44:08 <thetallguy> Oh, never mind, I see it's okay on your blog.  The Planet Haskell version is messed up.
20:45:02 <radetsky> johnnowak: maybe you're right, but that's just to say he has no basis for his position (feelings are not a basis)
20:45:34 <thetallguy> too many <'s missing
20:46:13 <johnnowak> scook0 got it right wrt dynamic languages encouraging programming in a way that doesn't always translate well to typed languages
20:46:24 <radetsky> the problem is that "I need heterogenous lists" is too imprecise
20:46:42 <johnnowak> heterogeneous lists can be useful when prototyping.
20:46:56 <sjanssen> dfranke: it seems hard to convince PG -- here is a man that refuses to even enforce the *length* of the lists he uses as structures
20:47:08 <sjanssen> let alone the types of the elements
20:48:11 <scook0> (I also suspect that lisp is more severe than other languages in terms of encouraging untyped-ness)
20:48:16 <radetsky> dfranke: what are the examples of needing heterogenous lists you were thinking of?
20:48:50 <lament> heterogenous lists are weird
20:49:18 <johnnowak> Lisp doesn't really have heterogenous lists. Lisp has an untyped tuple that can be used to create virtually any type of data structure.
20:49:59 <johnnowak> It's not so weird when you look at it that way. If it was just some untyped "list" type, then yes, that would be pointless.
20:50:12 <sjanssen> johnnowak: well, lists are special, they have special syntax etc.
20:50:25 <johnnowak> What's the etc?
20:50:36 <johnnowak> They have special syntax, sure
20:50:37 <vincenz> johnnowak: more functions for lists
20:50:42 <sjanssen> johnnowak: libraries
20:50:54 <johnnowak> That's not special though, that's just a common use case
20:50:55 <sjanssen> johnnowak: argument lists are passed as lists
20:51:42 <sjanssen> "Haskell doesn't really have lists, it just has algebraic data types that can be used to create virtually any type of data structure."
20:51:52 <lament> johnnowak: "virtually any type of data structure" - hardly, you can't even create homogenous lists
20:52:10 <lament> so you can create a stupid data structure, but not a useful one
20:52:18 <lament> sounds like the idea is flawed from the start
20:52:20 <johnnowak> Yes you can, it just isn't enforced. The same way you can create a tree but it won't be enforced that you use it as such.
20:52:28 <johnnowak> I'm just playing devil's advocate here.
20:52:35 <vincenz> you mean pg's?
20:52:37 <vincenz> :P
20:52:44 <johnnowak> Yes, pg's advocate. :)
20:53:02 <sjanssen> lets invite pg to #haskell!
20:53:08 <lament> you can't create a homogenous list, though
20:53:15 <lament> you can stuff a list with objects of the same type
20:53:15 <johnnowak> lament: Yes you can.
20:53:28 <lament> which is not the same as having a data structure that enforces an invariant
20:54:16 <lament> (i don't doubt that it's also possible to create homogenous lists with some object-oriented magic)
20:55:35 <bd_> [x] isn't a homogenous list of x's?
20:55:50 <lament> bd_: it is. We were talking about Lisp.
20:56:01 <bd_> oh
20:57:29 <dfranke> radetsky: I wasn't thinking of any in particular.  That was more a rhetorical device.
20:58:53 <tehgeekmeister> would the pattern (_:_:[]) work to match a list of exactly two items?
20:58:58 <bd_> tehgeekmeister: yes
20:59:07 <tehgeekmeister> bd_: thanks
20:59:21 <lispy> tehgeekmeister: as would ([_,_])
20:59:26 <sjanssen> tehgeekmeister: I'd use [_, _] -- it is a little less noisy
20:59:38 <tehgeekmeister> ah, that is better.
21:00:59 <Twey> But ([_,_]) begs more ass jokes.
21:02:22 <lispy> Twey: even better, match against a tuple, (_,_)
21:02:24 <vincenz>   _|_
21:02:34 <Cin> is it called bottom because it looks like one?
21:02:34 <Twey> True, true
21:02:36 <gwern> sjanssen: we can evangelize the benefits of strong static typing to pg!
21:02:44 <Twey> Haha
21:02:52 <gwern> ->([_,_])<- goatse?
21:02:59 <radetsky> hey guys, I just implemented heterogenous lists in haskell
21:03:00 <Cin> ^ valid perl code
21:03:07 <radetsky> http://hpaste.org/5538?
21:03:28 <Twey> Cin: Heh
21:03:35 <radetsky> check it out!
21:03:44 <lispy> radetsky: omg, the universe is going to collapse now
21:04:09 <Twey> Hahahahaha
21:04:38 <pjd> gwern: ITYM (E,âˆƒ)
21:04:42 <lispy> radetsky: but to be fair, now define mapcar
21:04:44 <Twey> On the subject of universe-implosion, I like Python's True = False
21:04:51 <Twey> Programming nihilism!
21:05:07 <Cin>  @_@
21:05:51 <tehgeekmeister> Twey: what?  how does that work?
21:06:12 <Twey> tehgeekmeister: True is just a variable
21:06:16 <Twey> As is False
21:06:20 <Cin> gah. xmonad is borked. brb
21:06:31 <Twey> You can assign to it, and it breaks all sorts.
21:07:01 <sjanssen> gwern: yeah, I'd say about 3 hours before we've made him a HM with type inference convert
21:07:05 <Cin> hello
21:07:07 <BMeph> pjd, gwern:  (EOâˆƒ)
21:07:22 <dibblego> what are some good examples to demonstrate the use of Either?
21:07:25 <sjanssen> you can *assign* to *True*!?!?
21:07:26 <lispy> At a superficial level I agree with the need of programmer flexibility when prototyping.  But, digging deeper, we see that prototypes become programs.  So, I think it's good to have an expressive language which is safe and provides the programmer to bolt on more and more garauntees as the prototype becomes the application.  So, re: hetro lists.  Haskell provides so much flexibility that you surprisingly don't miss them.
21:07:33 <sjanssen> HOW DO PEOPLE PROGRAM IN THESE LANGUAGES????
21:07:50 <Cin> sjanssen: ones with mutation? hell knows
21:07:57 <radetsky> sjanssen: one word: forced indentation of code
21:08:10 * Cin detects Hina
21:08:16 <gwern> radetsky: absurd! everyone knows the HList library proved heterogenous lists require many micro-Olegs worth of typeheckery
21:08:17 <sjanssen> Cin: I can handle mutation.  I cannot accept modifying fundamental constants :)
21:08:19 * gwern checks Wikipedia on nihilism: http://uncyclopedia.org/wiki/Nihilism
21:08:20 <lambdabot> Title: Nihilism - Uncyclopedia, the content-free encyclopedia
21:08:21 <gwern> BMeph: no doubt I'd be more impressed if the second to last char displayed right
21:08:26 * monochrom is brewing a powerful, scary idea, to be fruitated and revealed on St Valentine's Day. It's about marrying Alien and Predator!
21:09:13 <BMeph> gwern: True, true.. Maybe I should trawl the Cyrillic glyphs... ;)
21:09:27 <ddarius> sjanssen: Fundamental variables
21:09:44 <monochrom> AwP : Alien weds Predator!  "No matter what they beget, we lose." :)
21:09:50 <sjanssen> gwern: the core of HList is actually pretty easy -- it's mainly the generic/higher order maps and folds that require ingenuity of Olegian preportions
21:10:01 <Cin> http://hpaste.org/5538#a1
21:10:04 * Cin scratches head
21:10:43 <vincenz> Cin: how do you name em?
21:10:51 <Cin> vincenz: screen -S name <command>
21:11:04 <Cin> vincenz: to resume specific name: screen -x name
21:11:13 <lispy> <command> is optional
21:11:18 <Cin> okay
21:11:20 <vincenz> Cin: oh
21:11:21 <Cin> [<command>]
21:11:21 <vincenz> neat
21:11:22 <Cin> happy? :P
21:11:26 <lispy> Cin: why -x? I use -r
21:11:27 <vincenz> Cin: I always use a single screen
21:11:29 <lispy> Cin: er -rd
21:11:41 <vincenz> Cin: and ctrl+a a and ctrl+a c
21:11:46 <lispy> vincenz: with multiple windows inside the screen?
21:11:49 <gwern> Twey: programming nihilism you say? I call it nonfuctional: http://uncyclopedia.org/wiki/Nonfunctional_programming
21:11:49 <gwern> 'There are a few experimental programming languages that attempt to be purely nonfunctional by having no features for doing anything at all. Purely nonfunctional languages have attracted a great deal of theoretical interest for their extremely straightforward semantics, but have failed to catch on outside academia.'
21:11:49 <gwern> 'In the Star Wars technique, code must be written to be as rigid as possible. Flexibility introduces chaos and therefore must be avoided at all costs. All requirements documentation must be agreed to before any design or coding and must be cast in stone with formal signatures and harsh penalty clauses for failure to deliver (see Death Star). '
21:11:49 <lambdabot> Title: Nonfunctional programming - Uncyclopedia, the content-free encyclopedia
21:11:56 <Cin> lispy: -x is for names, -r for.. full id ie 2989.irssi
21:12:01 <vincenz> lispy: define 'wnidows'
21:12:15 <lispy> Cin: oh, but you can give partial names with -rd
21:12:16 <vincenz> Cin: how do you swithc rom one to the other?
21:12:29 <vincenz> Cin: ctrl+a d, screen -x name?
21:12:42 <Cin> vincenz: ah, mine are in different terminals on my X session
21:12:46 <lispy> vincenz: I thought screen had a feature (that I never use) where you get multiple ttys inside one invocation of screen
21:12:51 <Cin> vincenz: on different workspaces, etc
21:13:00 <vincenz> lispy: run 'screen'
21:13:02 <tehgeekmeister> can i pass type constructors as an argument to functions?
21:13:04 <vincenz> lispy: then type ctrla+ c
21:13:07 <vincenz> lispy: then type ctrl+a c
21:13:18 <vincenz> you'll get a second terminal
21:13:25 <vincenz> ctrl+a "
21:13:26 <lispy> vincenz: cool
21:13:28 <vincenz> gives you a list
21:13:30 <pjd> sjanssen: you can assign to any globals, in fact
21:13:33 <lispy> vincenz: i irc from screen so that was easy
21:13:38 <Cin> vincenz: have you tried session sharing in screen? pretty fun
21:13:41 <vincenz> ctrl+a n where n is a number ..
21:13:46 <vincenz> Cin: not yet?
21:14:13 <Cin> vincenz: heh. you do C-a :multiuser on, C-a :acladd <user to allow>, and then they can join your session
21:14:13 <vincenz> Cin: I wondered about that actually
21:14:23 <gwern> while I'm on uncyc, I've long been fond of their Objectivist C article: http://uncyclopedia.org/wiki/Objectivist_C
21:14:24 <lambdabot> Title: Objectivist C - Uncyclopedia, the content-free encyclopedia
21:14:25 <gwern> Cin: don't you have to be root to set the permissions right?
21:14:39 <vincenz> I think there's a better way
21:14:41 <pjd> sjanssen: however, Python 3 is going to turn True and False into compile-time constants, making it a syntax error to assign to them
21:14:50 <pjd> sjanssen: currently, None has this behavior
21:14:51 <Cin> gwern: you have to set chroot on screen
21:14:59 <vincenz> Cin: I know a way without chroot
21:15:00 <lispy> Cin, vincenz: if you're an emacs user you might want to change it from C-a
21:15:04 <Cin> vincenz: how?
21:15:05 <lispy> I use C-z actually
21:15:06 <[]> >>> not True
21:15:07 <[]> True
21:15:09 <adu> on the subject of True = False, I must mention that it doesn't really assign it
21:15:19 <vincenz> lispy: vim :)
21:15:29 <vincenz> Cin: well with a single account
21:15:35 <lispy> vincenz: oh, well, when you upgrade :)
21:15:36 <gwern> Cin: madness!
21:15:36 <adu> its equivalent to let True = False in ..... where the ..... goes on until the end of block
21:15:42 <vincenz> Cin: two screen sessions with editors
21:15:43 <Cin> lispy: that's a good point. i've always had to use C-a-a in emacs because of screen. never actually considered just changing the shortcut for screen. thanks ;)
21:15:47 <davidL> gwern: haha, nice article
21:15:50 <vincenz> Cin: then two screen sessions that are split, that tie to these two
21:15:55 <vincenz> Cin: then one can type in top, the other in bottom
21:16:01 <adu> plus you can still get the old True back with __builtins__.True
21:16:13 <vincenz> Cin: screen -e^xx
21:16:21 <monochrom> > let 1+2=0 in 1+2  {- HOW DO YOU PEOPLE PROGRAM IN THIS LANGUAGE??!!  :)  -}
21:16:25 <adu> you are only really screwed if you "__builtins__.True = False"
21:16:30 <lambdabot>  0
21:16:31 <Cin> vincenz: ah, that would be nice. that was the issue with sharing a screen, interrupting the other user's typing
21:16:44 * Cin tries
21:16:54 <lispy> monochrom: heeh
21:17:15 <pjd> monochrom++
21:17:16 <lispy> monochrom: wait, how does that interact with n+k patterns? ;)
21:17:17 <monochrom> hehe
21:17:20 <radetsky> "HOW DO PEOPLE PROGRAM IN THIS LANGUAGE" is now a meme
21:17:30 <adu> not for me
21:17:40 <adu> i'm immune
21:18:15 <monochrom> If you try something like "let x+(y+1) = ..." you will trigger n+k patterns, namely the y+1 part.
21:18:30 <vincenz> > let x+(y+1) = x in x+0
21:18:30 <lambdabot>  Parse error in pattern at "in" (column 17)
21:18:31 <adu> cuz I took my how/dpp pills this morning
21:18:37 <lispy> > let n+k=n-k; foo n+1 = n in foo 3
21:18:37 <vincenz> > let x+(y+1) = x in x+1
21:18:38 <lambdabot>  Parse error in pattern at "in" (column 26)
21:18:38 <lambdabot>  Parse error in pattern at "in" (column 17)
21:18:48 <vincenz> I think n+k patterns are only for toplevels
21:18:52 <lispy> > let {n+k=n-k; foo n+1} = n in foo 3
21:18:53 <lambdabot>  Parse error at "}" (column 22)
21:19:04 <monochrom> Hrm, will be fun to get it to work. :)
21:19:08 <lispy> > let {n+k=n-k; foo n+1 = n} in foo 3
21:19:09 <lambdabot>  Parse error in pattern at "}" (column 26)
21:19:12 <adu> > let True = False in False
21:19:13 <lambdabot>  False
21:19:18 <adu> > let True = False in True
21:19:18 <lambdabot>  True
21:19:22 <vincenz> HOW DO PEOPLE PROGRAM IN THIS LANGUAGE
21:19:32 <monochrom> hahahaha now it's contagious
21:19:32 <vincenz> adu: True = false is a patternmatch
21:19:35 <lispy> what is wrong with my syntax?
21:19:47 <adu> > let true = False in true
21:19:47 <vincenz> adu: a failing one, but since it's lazy..
21:19:47 <lambdabot>  False
21:19:51 <adu> yes!
21:19:56 <gwern> vincenz: pointsfree, often
21:20:05 <vincenz> gwern: pointlessly you mean
21:20:07 <monochrom> If you just write "n+k = ..." it is not a n+k pattern at all, it is just defining infix +
21:20:29 <lispy> monochrom: I know, but then how does my definition of (+) affect the pattern?
21:20:30 <gwern> vincenz: as you wish...
21:20:32 <monochrom> OTOH I don't know why "x+(y+1) = ..." is not accepted.
21:20:40 <vincenz> gwern: kneel
21:20:52 <lispy> > let n+k=n-k in let foo n+1 = n in foo 3
21:20:52 <lambdabot>  Parse error in pattern at "in" (column 32)
21:21:01 <lispy> > let n+k=n-k in {let foo n+1 = n in foo 3}
21:21:01 <lambdabot>  Parse error at "{let" (column 16)
21:21:06 <adu> HDPPINL 2.0: Formal Semantics and Base Libraries
21:21:19 <tehgeekmeister> is it possible to write a type testing function along the lines of test constructor = (\x -> case x of {constructor _ -> True; _ -> False})?
21:21:32 <tehgeekmeister> i know that specific attempt gets a parse error, and i can see why, but i'm sure there must be some way.
21:22:08 <allbery_b> tehgeekmeister:  sadly, no; patterns are not first class in Haskell
21:22:42 <lispy> > let n+k=n-k in {let foo (n+1) = n in foo 3}
21:22:42 <lambdabot>  Parse error at "{let" (column 16)
21:22:46 <tehgeekmeister> allbery_b: damn, that sucks.  can do it the longhand way, i guess.
21:22:49 <lispy> > let n+k=n-k in let foo (n+1) = n in foo 3
21:22:49 <lambdabot>  Parse error in pattern at "in" (column 34)
21:22:59 <allbery_b> it does kinda suck, yeh
21:23:48 <allbery_b> the usual workaround is to pass around one of several functions which match specific constructors
21:24:04 <tehgeekmeister> it's not for primitive types, tho
21:24:24 <lispy> oh, okay, I did my example in a file
21:24:29 <monochrom> > let {n+1=n*10} in let {foo(n+1)=n} in foo 3
21:24:29 <lambdabot>  Parse error in pattern at "}" (column 34)
21:24:38 <lispy> and (n+1) is really n+1 and not my messed up re-definition
21:24:51 <monochrom> lambdabot not liking it. It works in ghci.
21:25:13 <lispy> monochrom: agreed
21:25:26 <lispy> So, that's how they solved the evil n+k patterns problem
21:25:32 <lispy> I wonder if Yhc agrees.
21:25:37 <lispy> and hugs
21:25:48 <lispy> hugs agrees with ghc
21:26:02 <lispy> but, idon't have Yhc
21:26:26 <adu> tehgeekmeister, Maybe
21:27:40 <tehgeekmeister> adu: ?
21:29:03 <Twey> Why don't people like n+k?
21:30:53 <lispy> Twey: I don't know if anyone seriously dispises it, but there was a thread years ago in the inception of Haskell about that exact scenario I was just testing.  I think since then people have light heartedly joked about it being evil.
21:31:17 <araujo> hello
21:31:19 <Twey>  Hmmm, OK
21:31:37 <gwern> I've always found n+k patterns unclear. what do they really buy you anyway?
21:32:09 <dolio> They make it look like integral types are inductively defined.
21:32:13 <Twey> Well, I guess if you need to cut a constant off a number consistently throughout a function
21:32:28 <Twey> I can imagine n + 1 patterns being useful
21:32:29 <tehgeekmeister> this isn't exactly haskell related -- but in looking into dependent types i've gotten to wondering about where's a good place to play around with them?  they seem great to me, but it seems haskell can't do them (without serious hacks, at least...)
21:32:46 <gwern> so they're good for lying to the reader and a small corner case?
21:33:12 * gwern begins to see why n+k considered harmful
21:34:32 <lispy> certainly they require extra work in the compiler that is rarely used in practice
21:35:11 <lispy> In that sense, I could see them happily removed from future versions of Haskell with the footnote, "Interesting experiment, but we didn't end up using it."
21:35:56 <lispy> tehgeekmeister: iirc, fundeps come out of data modeling theory...so maybe check with the database crowd?
21:36:20 <dolio> The problem with n+k patterns that I can see is that they have nothing to do with the definition of (+) and (-) for the relevant type.
21:36:24 <Cin> utf-8 support in haskell; easy or annoying?
21:36:30 <dolio> Let alone local definitions of it.
21:36:34 <lispy> tehgeekmeister: oh wait, maybe those are different concepts
21:36:53 <lispy> tehgeekmeister: dependent types, you said, but I read "functional dependencies"
21:36:56 <gwern> Cin: define utf-8 support... internal or IO?
21:37:16 <gwern> io is not as convenient as it could be, internal I understand in GHC to be satisfactory
21:37:18 <Cin> gwern: i just want to print it to my terminal
21:37:47 <tehgeekmeister> lispy: dependent types would allow you to define statically safe natural numbers, as opposed to just integers, as an example.
21:37:59 <gwern> you know would I would really like to see in haskell prime? the ability to use unicode equivalents of :: and so on
21:38:18 <Cin> â†’ instead of -> ? :P
21:38:18 <Maddas> :-(
21:38:31 <tehgeekmeister> lispy: and i've seen examples (iirc) of a fib type, in an epigram tutorial
21:38:36 <Maddas> Cin: a-hat control F control R?
21:38:46 <gwern> Cin: IO then. you'll need one of the libraries, iirc. if ghci prints it out, it'll be in \067\90 and so on form last I tried
21:38:57 <gwern> Cin: right!
21:39:09 <bd_> â†’'s harder to type :)
21:39:10 <Cin> gwern: indeed. it prints \273 instead of Î»
21:39:14 <bd_> (two chords, five keystrokes here...)
21:39:18 <gwern> Cin: I already have emacs set to display it that way, but I'd like to have it really be that way
21:39:26 <Cin> bd_: it's just altGr+i for me >_>
21:39:33 * shachaf wonders why that's broken for me.
21:39:39 <dolio> tehgeekmeister: I've made statically checked primes and such using template haskell. :)
21:39:41 <shachaf> Î» works.
21:39:41 * Maddas knows it is the ssh+screen combination for him.
21:39:47 <shachaf> s/me/him/
21:39:51 <monochrom> package "utf-string" or "encoding"
21:39:52 <lispy> tehgeekmeister: are these the same as associated types?  I think someone had implemented those in ghc or was working on that.
21:39:52 <bd_> I don't have an altgr :(
21:39:59 <Maddas> Cin: Ah, but I *would* use Japanese characters :-)
21:40:01 <tehgeekmeister> dolio: i think that counts as a hack.
21:40:03 <bd_> and even if I did, there's a SCIM bug that'd keep me from using it :(
21:40:05 <Maddas> (Doesn't take any chords at all!)
21:40:06 <adu> I see lambda
21:40:06 <shachaf> Maddas: I'm using ssh/screen/irssi.
21:40:09 <Cin> shachaf: maybe it's emacs (running ghci inside emacs).
21:40:09 <tehgeekmeister> lispy: i'm not sure?  i don't believe so.
21:40:12 <Maddas> shachaf: Me too.
21:40:13 <dolio> tehgeekmeister: Most definitely. :)
21:40:33 * RayNbow has an AltGr... but it doesn't work... :p
21:40:38 <Maddas> shachaf: It's related to my particular setup; I believe I have gotten that combination to work at some point.
21:40:40 <tehgeekmeister> tehgeekmeister: dependent types allow types to range over values as well as types, so imagine polymorphism over values.
21:40:40 <adu> Unicode rocks!
21:40:59 <tehgeekmeister> lispy: err, that last one was to you.  also, it allows statically checked array bounds.
21:41:14 <lispy> cool
21:41:22 <tehgeekmeister> oh!  i believe i remember seeing somewhere else that it buys you totality as well!
21:41:26 <tehgeekmeister> that's the best part.
21:41:29 <lispy> tehgeekmeister: you can have statically checked array bounds already using type classes
21:41:35 <dolio> There are epigram papers that eplain some uses pretty well.
21:41:53 <tehgeekmeister> dolio: aye, if epigram didn't seem to be so stagnant i'd play with it
21:41:58 <tehgeekmeister> i've started reading some of the papers
21:42:30 <tehgeekmeister> lispy: hmm, how so?  i'm sure it's gotta be a bit hackish.
21:42:34 <Cin> *Lambda> Ab "x" (V "x")
21:42:35 <Cin> (ï¿½ x.x)
21:42:45 <Cin> unicode confuses and infuriates me
21:43:12 <dolio> For static array bounds you just need type-level naturals and type functions, which GHC can do.
21:43:40 <dolio> At least, depending on what exactly you want to do.
21:43:50 <tehgeekmeister> okay, that makes sense.  i'd still love to see dependent types in haskell.  =P
21:45:17 <monochrom> Just use Godel numbering.
21:45:27 <tehgeekmeister> ?
21:45:44 <monochrom> Godel numbering encodes programs into numbers.
21:46:12 <monochrom> Not just programs. Full first-order logic too.
21:46:40 <monochrom> Imagine type-level Quickcheck properties. :)
21:47:16 <tehgeekmeister> impressive, cool to know about -- still seems hackish compared to straight dependent types.
21:48:40 <tehgeekmeister> i know coq has dependent types, but it's not meant to be a full purpose programming language, is it?
21:48:56 <dolio> One thing I suspect you be able to do with dependent types is write an 'apply' that applies a list of values to a function with sufficient arguments.
21:49:40 <tehgeekmeister> dolio: sounds feasible.
21:50:58 <dolio> Although that may well be feasible in Haskell as well with sized lists, although it'd probably look a lot worse.
21:54:43 <sarah> is there a built in function like x n = if isNothing n then Just 1 else Nothing?
21:55:05 <bd_> sarah: why 1?
21:55:12 <sarah> just a random valu
21:55:41 <bd_> Just () if anything.. but I'm not sure I see the use of it. guard . isNothing would do it though
21:55:47 <sarah> so i can x n >> someFuncThatOnlyReturnsIfX_NIsNothing
21:55:51 <bd_> > (guard . isNothing $ Nothing) :: Maybe ()
21:55:53 <lambdabot>  Just ()
21:55:55 <junmin> Hello all, i am trying to use GHCi to run this small program,  http://rafb.net/p/Xzvdba20.html  anyway, i cannot. i type "suma (Suc Naturales) Cero", but it gives me this error http://rafb.net/p/vbGyBb89.html thanks!
21:55:56 <lambdabot> Title: Nopaste - naturales.hs
21:55:58 <bd_> > (guard . isNothing $ Just 42) :: Maybe ()
21:55:59 <lambdabot>  Nothing
21:56:07 <gwern> bd_: eh. so you write it out normally and maybe ghc comes with a companion program which filters files and replaces with unicode equivalents
21:56:10 <gwern> Cin: now say that in uppercase, and follow it with CIN ANGRY! CIN SMASH!
21:56:31 <bd_> RTT: 15 minutes? :D
21:57:06 <sarah> bd_: ah thanks didnt know the guard func
21:57:33 <Heffalump> @users
21:57:33 <lambdabot> Maximum users seen in #haskell: 471, currently: 423 (89.8%), active: 15 (3.5%)
21:58:16 <Cin> gwern: D:
22:02:36 <OceanSpray> what's the associativity of >>= ?
22:02:43 <OceanSpray> $ ?
22:03:59 <Korollary> @info >>=
22:03:59 <lambdabot> (>>=)
22:04:03 <Korollary> excellent
22:04:11 <Korollary> @info (>>=)
22:04:11 <lambdabot> (>>=)
22:04:16 <dynamix> > getPOSIXTime >>= (\p -> return ( show p) ) >>= (\(ps) -> return (read (init(ps) )::Double) )
22:04:16 <lambdabot>   Not in scope: `getPOSIXTime'
22:04:17 <Korollary> well, ghci says infixl 1
22:04:34 <dynamix> :m + Data.Time.Clock.POSIX
22:04:56 <dynamix> how to add a module to lambdabot?
22:05:00 <dynamix> > getPOSIXTime >>= (\p -> return ( show p) ) >>= (\(ps) -> return (read (init(ps) )::Double) )
22:05:01 <lambdabot>   Not in scope: `getPOSIXTime'
22:05:01 <prb> wagle: Solved the simpleHTTP riddle.
22:05:31 <monochrom> Is the riddle about connections not getting closed? What is the solution?
22:05:50 <prb> monochrom: http://mult.ifario.us/p/a-short-adventure-with-simplehttp
22:05:50 <lambdabot> Title: a-short-adventure-with-simplehttp
22:06:02 <prb> monochrom: A little too much within a single catch.
22:06:28 <prb> monochrom: Exception was happening before sClose on the socket.
22:14:14 <OceanSpray> eh
22:14:36 <OceanSpray> I've been trying to shorten my code,
22:14:49 <OceanSpray> but I'm now worried that I'm making it unreadable.
22:15:06 <sclv_> paste! paste!
22:15:45 <monochrom> I wonder what "shutdown" really does.
22:16:19 <OceanSpray> http://screw.svn.sourceforge.net/viewvc/screw/trunk/Primitives.hs?revision=13&view=markup
22:16:20 <lambdabot> Title: SourceForge.net Repository - [screw] View of /trunk/Primitives.hs, http://tinyurl.com/2epjtz
22:16:24 <glguy> ?seen dons
22:16:24 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 5h 8m 29s ago.
22:16:25 <junmin> Hello all, i am trying to use GHCi to run this small program,  http://rafb.net/p/Xzvdba20.html  anyway, i cannot. i type "suma (Suc Naturales) Cero", but it gives me this error http://rafb.net/p/vbGyBb89.html help, thanks! the problem is.. dont know use GHCi well, with hugs no problem. :(
22:16:26 <dons> yow
22:16:27 <lambdabot> Title: Nopaste - naturales.hs
22:16:33 <dons> wazzup glguy
22:16:36 <glguy> dons: beer me that sql interface
22:16:47 <dons> beer you?
22:16:56 <dons> ah, i owe you a beer, eh?
22:16:59 <glguy> (Reference to the US version of The Office)
22:17:13 <dmwit> dynamix: Sorry, you can't.
22:17:13 <glguy> oh, and you owe me a beers worth of lunch ;)
22:17:14 <dons> ah
22:17:18 <dons> i do!
22:17:36 <scook0> junmin: I think you want suma (Suc Cero)
22:17:57 <glguy> but more seriously ;) do you have a link to the sql lib you were mentioning?
22:18:03 <dynamix> dmwit thanks, im trying to get the current time of day so that i can feed that in as a seed to a random number generator
22:18:19 <monochrom> prb: Would it be more appropriate to "shutdown sk ShutdownBoth"?
22:18:22 <scook0> junmin: oh, your problem is with Show
22:18:26 <dmwit> junmin: Naturales is a type, not a value.
22:18:27 <dynamix> i got a double out ofit, but the seed needs to  be unsinged int
22:18:38 <dmwit> junmin: Try "suma (Suc Cero) Cero" instead.
22:18:46 <dons> glguy: oh, which one?
22:18:46 <prb> monochrom: Don't know.  You want to let the two sides of the conversation run things out.
22:18:56 <dons> btw, haskell climbed a bit on the shootout, http://shootout.alioth.debian.org/gp4/benchmark.php?test=spectralnorm&lang=all
22:18:57 <lambdabot> Title: spectral-norm benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/bruf8
22:19:05 <dmwit> junmin: Also, add "deriving Show" to your data declaration, as scook0 said.
22:19:10 <glguy> dons: Deutchebank?
22:19:13 <junmin> dmwit: the same error.
22:19:14 <prb> monochrom: I *think* ShutdownBoth has the effect of slamming down the receiver on the call.
22:19:36 <dons> glguy: ah yes. looking.
22:19:45 <dmwit> junmin: Did you add "deriving Show" to you data declaration?
22:19:52 <junmin> dmwit: doing it now
22:20:06 <dmwit> dynamix: Okay, you can try two things:
22:20:10 <sclv_> dons: was that a win for strictify? :-)
22:20:21 <dmwit> dynamix: 1. Just use floor or so.
22:20:24 <dons> glguy: http://okmij.org/ftp/Haskell/#takusen
22:20:24 <lambdabot> Title: Haskell Programming: Miscellanea
22:20:29 <wagle> prb: cool!
22:20:31 <dons> sclv_: yep. 1 win on spectral-norm
22:20:31 <dmwit> dynamix: 2. Just use randomIO or so.
22:20:35 <monochrom> OK, I wonder if you could first "suck" and then "ShutdownBoth".
22:20:41 <dons> nbody got a bit faster, due to using the C backend
22:20:52 <scook0> junmin: you should end up with http://hpaste.org/5539
22:21:00 <dmwit> dynamix: randomIO picks its own seed (I think in the same way -- by the time).
22:21:01 <sclv_> the fasta went through too. now haskell is in a clear win vs. ocaml: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
22:21:02 <lambdabot> Title: Create your own Ranking | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lan ..., http://tinyurl.com/lepfo
22:21:04 <dons> glguy: http://darcs.haskell.org/takusen/ and http://pinderkent.blogsavy.com/archives/111
22:21:04 <lambdabot> Title: Index of /takusen
22:21:23 <dons> glguy: note sqlite backend
22:21:23 <dynamix>  but i need the user to be able to specify a particular seed.
22:21:41 <dons> sclv_: awesome
22:21:44 <dynamix> mkStdGen takes a seed but that is integer
22:21:51 <sclv_> taking on clean is still a nice challenge though.
22:21:55 <dmwit> dynamix: Okay, randomIO definitely isn't the way to go, then. =)
22:21:57 <dons> sclv_: where was the old haskell entry for fasta?
22:22:04 <dmwit> :t mkStdGen
22:22:06 <lambdabot> Int -> StdGen
22:22:08 <monochrom> You use "suck" because you want to read everything left. Is it possible that it will not end? I.e., the web server is faulty and keeps sending you more stuff.
22:22:10 <dmwit> :t floor
22:22:11 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:22:20 <dmwit> dynamix: What's wrong with floor?
22:22:24 <[]> has SBCL's mem usage been xplained somewhere?
22:22:35 <junmin> scook0: dmwit , thanks!! got it. but really dont understand why using Hugs, dont need to add "deriving show"
22:22:48 <junmin> why?
22:22:54 <dynamix> two different times can result in the same floor value!!
22:23:00 <dmwit> junmin: It may add it for you as a convenience. *shrug*
22:23:07 <dmwit> dynamix: So scale the time.
22:23:12 <sclv_> dons: I asked him to replace it, since it was the same thing with some bangs removed.
22:23:17 <prb> monochrom: Hmm.  Hmmm.  I think that makes sense, since it would tend to take you down the LAST_ACK close path for the connection.
22:23:23 <sclv_> + fasta was at like five entries already.
22:23:53 <prb> monochrom: Question is then about closing keep-alive connections, in which case you need the other variant to tell the server you want to hang up.
22:24:01 <dons> sclv_: oh, its always interesting to see how much better it gets though
22:24:06 <dons> [], the excessive usage?
22:24:08 <junmin> dmwit: Ok.
22:24:15 <dynamix> dmwit: i feel like im having to jump through hoops to accomplish a simple thing.
22:24:18 <sclv_> it was 20% ish improvement when I tested it.
22:24:19 <junmin> scook0: dmwit thanks you guys
22:24:19 <[]> dons: right, any devs have posted on it on their blogs, etc?
22:24:28 <sarah> how does one enter haskell mode in emacs?
22:24:30 <scook0> no problem
22:24:31 <dons> i've not seen anything.
22:24:32 <dynamix> get tiem of day and use that as a seed.
22:24:41 <prb> sarah: Using the keyboard. :)
22:24:48 <monochrom> Alright, I'm convinced the current procedure is robust and prudent. Please don't adopt my method. :)
22:24:54 <prb> sarah: There is a very nice haskell-mode.
22:24:57 <sclv_> sarah: if you follow the install instructions, haskell mode will be automagic on any .hs or .lhs file
22:25:08 <sarah> ah thanks
22:25:11 <sclv_> if not, its something like M-x haskell mode.
22:25:17 <dynamix> sarah are you from australia?
22:25:18 <dmwit> dynamix: *shrug* It may be a hoop, but you only have to jump it once.  The pay-off in ease of implementation for hard things outweighs it a lot.
22:25:24 <sarah> nope
22:25:28 <dons> sclv_: so strictify is good at eeking out that last couple of percent from medium sized entries?
22:25:34 <prb> sarah: M-x haskell-mode
22:25:42 <prb> _sclv was missing a dash.
22:25:56 <glguy> dons: no mysql backend :-(
22:26:04 <dynamix> basically i need to find a way to convert a POSIXTime value to an Integer
22:26:22 <prb> dynamix: Go the other way -- fromIntegral
22:26:26 <sclv_> I suppose. I should test it more. Fasta was messy because it had so many bangs to begin with. On entries without many strictness annotations, I suppose it'll be less help because ghc is probably doing 90% of the work already.
22:26:59 <dynamix> how does that work?
22:27:21 <prb> dynamix: EpochTime (POSIX time) is Num; you need to get Integer (or Int) into Num to do math with them.
22:27:46 <dmwit> prb: He wants an Int, specifically, for random-number seeding.
22:27:49 <monochrom> Which typeclasses does POSIXTime belong to?
22:27:58 <dmwit> Num, Real, RealFrac to name a few
22:28:15 <dynamix> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock-POSIX.html#t%3APOSIXTime
22:28:16 <lambdabot> http://tinyurl.com/25otgv
22:28:27 <dmwit> Fractional, Ord, Eq, Enum, Show to name the rest
22:28:27 <monochrom> Sounds like RealFrac is the most specific one.
22:28:41 <dmwit> ?src Fractional
22:28:41 <lambdabot> class  (Num a) => Fractional a  where
22:28:41 <lambdabot>     (/)             :: a -> a -> a
22:28:41 <lambdabot>     recip           :: a -> a
22:28:41 <lambdabot>     fromRational    :: Rational -> a
22:29:28 <monochrom> "accuracy of 10^-12 s" it is said. Is that really true?
22:29:39 <dmwit> It depends on the system.
22:30:15 <monochrom> would also need to know what goes before the decimal point (or whatever point) and what goes after.
22:30:16 <dons> sclv_: yeah, spec-norm was like that. too many bangs
22:30:26 <prb> dmwit: e.g., windows gets you to +/- 10ms.
22:30:29 <dmwit> :t properFraction
22:30:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
22:30:36 <dmwit> monochrom: You mean like that?
22:30:48 <dmwit> Oh, you mean, what are the units?
22:30:49 <dynamix> ok sorry for going one step back , but POSIXTime being an instance of RealFrac is helpful how?
22:30:55 <monochrom> Yes. Both :)
22:31:38 <dmwit> dynamix: RealFrac's know how to do a bunch of useful things.
22:31:41 <sclv_> mainly the pleasure is being surprised at what ghc takes care of for you. I suspect that all explicit strictness annotations could probably be better written as explicit unboxing though...
22:32:42 * dmwit would probably use "fmap (floor . (*1000)) getPosixTime" and call it a day.
22:32:56 <monochrom> I concur.
22:33:32 <dmwit> I'd say that's a pretty small hoop to jump.
22:33:44 <dmwit> I can't imagine it getting much shorter than that in any other language.
22:34:25 <dynamix> :t getCurrentTime
22:34:26 <lambdabot> Not in scope: `getCurrentTime'
22:34:58 <dmwit> monochrom: I think the "accuracy of 10^-12s" bit means it guarantees that much precision in the storage type.
22:35:07 <scook0> @hoogle getCurrentTime
22:35:07 <lambdabot> Data.Time.Clock.getCurrentTime :: IO UTCTime
22:35:08 <lambdabot> Data.Time.LocalTime.getCurrentTimeZone :: IO TimeZone
22:35:23 <monochrom> Ah, certainly.
22:35:33 <dynamix> if Difftime is an instance of Real, does it mean it can be used in place of a Real ?
22:35:44 <dmwit> eh?
22:35:51 <dynamix> err that did not come out right.
22:36:07 <prb> You can also cheat by reading a shown value.
22:36:18 <dmwit> Anything that works on (Real a => a) will also work on (Difftime).
22:36:24 <prb> Or you could hunsafeCoerce.
22:36:32 <prb> s/hun/un/
22:36:37 <dynamix> prb: thats what i did! but i dont know how to convert the double value to integer
22:36:37 <monochrom> hahahaha
22:37:16 <dmwit> I think somebody else was in here complaining that the best way to accomplish a thing was to do read . show.
22:37:26 <dmwit> The time libraries are really kind of sad.
22:37:26 <dynamix> getPOSIXTime >>= (\p -> return ( show p) ) >>= (\(ps) -> return  (read (init(ps) )::Double) )
22:37:28 <dynamix> 1.20245203340551e9
22:37:34 <dynamix> dmwit: could have been me:)
22:37:48 <prb> dynamix: is an integer number of seconds sufficient?
22:37:48 <dmwit> No, it wasn't you.
22:37:56 <dynamix> prb: yes
22:38:00 <prb> OK.
22:38:13 <dmwit> And for them, that really was the best way to do it.
22:38:24 <prb> dynamix: Then use System.Posix.EpochTime
22:38:31 <dmwit> Whereas for you, the thing you just wrote is done better by the code I've *already* supplied.
22:38:37 <dynamix> teh only saving grace in all this is that both POSIXTime and Random work in the IO monad :)
22:38:41 <prb> It will show as an Integer value, and you can read it as an Int.
22:39:05 <sclv_> time is a broken spec in the world. so it's hard to get right anyway.
22:39:52 <prb> sclv_: Heard that.  And it's bad enough on one machine.  It gets scary when you try to have a group of machines with a coherent notion of time.
22:39:54 <dmwit> Gah, you don't need read . show for this!  Even EpochTime has fromEnum.
22:40:15 <Cin> *Lambda> showE $ Ap (Ab "x" (V "x")) (V "y")
22:40:15 <Cin> (Î» x. x) y
22:40:17 <Cin> yay!
22:40:33 <dmwit> Yay!
22:40:53 <dynamix> :m + System.Posix.EpochTime
22:40:54 <dynamix> Could not find module `System.Posix.EpochTime':
22:40:58 <monochrom> I don't understand programmer communication skill. It is all perverted.
22:41:07 <Cin> utf8-string for the win
22:41:10 * prb has been wandering around in the time libraries lately.
22:41:19 <dmwit> dynamix: It's in System.Posix.Types
22:42:18 <prb> :m + System.Posix
22:42:21 <Cin> my fingers really hurt. who wants to recommend me a good keyboard?
22:42:24 <prb> :m + System.Posix.Time
22:42:36 <dmwit> Cin: I love my Kinesis Advantage.
22:42:43 * Cin googles
22:42:47 <prb> e <- epochTime
22:42:51 <moosefish> Cin: I'm fond of Goldtouch's older models
22:42:54 <monochrom> I saw an Apple keyboard that's like 3mm thick.
22:42:55 <dynamix> Cin try teh gold touch keyboard, it pretty much saved my life and career
22:43:12 <dmwit> Huh, PosixTime is an instance of Enum.
22:43:16 <dynamix> that and taking frequent breaks..
22:43:16 <prb> monochrom: It's almost exactly the same as the keyboard on their Mac Book laptops.
22:43:18 * Cin shortles
22:43:27 <dmwit> fromEnum :: PosixTime -> Int -- sounds like just the thing you want
22:43:42 <sclv_> Cin: more in where you put the keyboard than what it is, I think...
22:44:00 <dynamix> getPOSIXTime >>= (\p->return (fromEnum p) ) works!! :)
22:44:09 <dynamix> but i got a negative number:)
22:44:14 <Cin> since i started using a combination of (1) emacs from the terminal (no mouse) (2) other terminal programs and (3) xmonad, my fingers are really starting to ache these days
22:44:14 <dynamix> -1205120896
22:44:24 <dmwit> dynamix: Prefer (fmap fromEnum getPOSIXTime) instead.
22:44:37 <dmwit> dynamix: Oh, is negative a problem?
22:45:00 <dynamix> its not intuitive to me.. time is generally positive from an epoch
22:45:18 <monochrom> The epoch is in the future.
22:45:26 <dmwit> > (2008-1970)*365*24*60*60 :: Integer
22:45:28 <lambdabot>  1198368000
22:45:31 <Cin> dmwit: ah, an "ergonomic" keyboard. never tried one of these
22:45:39 <dmwit> > (2008-1970)*365*24*60*60 :: Int
22:45:39 <lambdabot>  1198368000
22:45:47 <monochrom> We are counting down towards the day when all programs are written by computers, and all human programmers are laid off.
22:45:48 <dmwit> > (2008-1970)*365*24*60*60*(10^12) :: Int
22:45:49 <lambdabot>  860880896
22:46:04 <dynamix> gold touch for the win:)  but more importantly, take frequent breaks, like once every 10 mins or so. for 5 mins.
22:46:20 <dynamix> and user some thign like workrave to keep reminding you of breaks
22:46:34 <dmwit> dynamix: The negative thing is probably just overflow, somehow.
22:46:49 * dmwit wanders off
22:47:00 <dynamix> well as long as it can be used as a seed :)
22:47:11 <Cin> dynamix: is that how often you take breaks? dang
22:47:28 <dynamix> not now. i take a 20 second break every 5 minutes
22:47:41 <dynamix> and a 5-10 minute break every 40 mins-hour
22:48:05 <dynamix> It was a major Pain initially, but now i got used to it. and am off braces and pain medication
22:48:27 <Cin> heheh
22:49:02 <dynamix> i used to prefer long jam sessions.. so would do allnighters coding like crazy.. but now i try to do things in moderation:) injuries and age teach a lot
22:50:03 <vincenz> dynamix: how old are you
22:50:18 <dynamix> 30
22:50:36 <Cin> paul graham is 10x that
22:50:57 <glguy> Cin: no no, *exploratory* programming
22:51:11 <dynamix> :) i seem like an old man too.
22:51:22 <dynamix> just dont look teh part yet.
22:51:35 <[]> you are. i remember chatting you up on 3sheep when you were like 11. writing those Miranda programs to dl azn porn
22:51:40 <[]> anyways, bed time !
22:51:59 <dynamix> ??
22:52:38 * vincenz wants to get a keyboard that is better
22:52:43 * vincenz always types on laptop
22:53:46 <Cin> i reckon i spend about 12 hours a day on my computer
22:54:17 <dynamix> Please for goodness sake dont do that!!
22:54:39 <monochrom> Perhaps the 12 hours are for watching IRC.
22:54:51 <Cin> monochrom: someone's got to do it
22:55:06 <quicksilver> 12 hours? pah. When I were a lad we spend 28 hours a day on IRC.
22:55:14 <vincenz> dynamix: suggestions/
22:55:21 <quicksilver> We got up 6 hours before we went to bed and cleaned the channel with broken glass
22:55:28 <quicksilver> and we were grateful!
22:55:37 <Cin> you were lucky
22:55:51 <Cin> we had to use windows
22:56:02 <glguy> linux was too expensive?
22:56:05 <vincenz> Cin: what do you think the broken glass was?
22:56:15 <vincenz> whole windows worth
22:56:16 * Cin chortles
22:56:37 <dynamix> vincenz:  teh best solution is to have the right ergonomics , good kbd and good scheduling
22:56:44 <monochrom> In the old days we had only text and it was 30bps both ways.
22:56:56 <vincenz> dynamix: care to expand on scheduling?
22:57:15 <dynamix> how much time you spend at a strech typing/mousing
22:57:21 <vincenz> lots?
22:57:42 <dynamix> needs to be optimised for your situation.  for me 20 sec break every 5 mins works.. you should find what works for you
22:57:52 <vincenz> what do you do during those 20 sec?
22:58:07 <dynamix> and i code a lot in C++ just get up walk away and look else where
22:58:12 <Cin> ask no questions hear no lies
22:58:19 <vincenz> dynamix: well c++ is the kind of language to hurt
22:58:51 <Cin> i find myself pressing <TAB> a lot with haskell due to the indenting cycles
22:58:57 <dynamix> Java is worse!! so verbose, one think i instantly liked abt Haskell is the brevity and expressive ness.
22:59:09 <vincenz> dynamix: get vim
22:59:14 <vincenz> and leran to use complete
22:59:18 <dynamix> :) i use vim or everything, even emails
22:59:26 <vincenz> how do you vim emails?
22:59:34 * vincenz loves ctrl+n
22:59:37 <glguy> mutt opens vim for compose
22:59:45 * vincenz tends to use gmail ..
22:59:52 <Cin> likewise
23:00:05 <dynamix> i type them in vim and send them thru outlook etc.. earlier i used mutt for a while.
23:00:08 <glguy> mutt + gmail is easy enough with imap
23:00:28 <Cin> "yay xmonad, say goodbye to the mouse!" *unplugs mouse* *opens gmail* "d'oh!"
23:00:28 <dynamix> for most things, it is easy to use vim or a vi input  mode
23:00:32 <Cin> bloody javascript interface
23:00:43 <vincenz> dynamix: oh right, for long mails I fire up gvim then copy paste
23:00:43 <glguy> gmail has lots of keyboard shortcuts
23:00:56 <Cin> it does? hrrm
23:01:32 <dynamix> hmm.. thanks guys.. its 11:00 PM bed time for me. :) bye. i hope i will have something to show for all teh pestering in the past 2 days  here :)
23:01:49 <dynamix> Cin: see teh preferences page
23:03:24 <Cin> i'm going to read a book or something. my fingers really hurt. bbl
23:09:38 <radetsky> damn, dynamix left
23:09:52 <radetsky> I wanted to tell him: I even use vim for emacs!
23:14:03 <catface> does >> throw away the value but keep the monad?
23:14:57 <radetsky> catface: what do you mean?
23:16:53 <paolino> :t (>>)
23:16:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
23:16:59 <Twey> @src >>
23:17:00 <lambdabot> m >> k      = m >>= \_ -> k
23:17:22 <Twey> catface: Basically.
23:17:32 <catface> thx
23:17:51 <paolino>  >> takes 2 monadic values and compose them
23:18:12 <vincenz> and they have to be in the same monad
23:18:23 <vincenz> but the value of the first action is tossed
23:19:11 <catface> but the monad part from the first action is kept and composed?
23:19:16 <paolino> composimg rules depends on the (>>) definition/logic, which is the main part of monad definition
23:20:06 <paolino> > Just 1 >> Just 2 >> Just 3
23:20:15 <vincenz> catface: you can only compose actions of the same monad with >>
23:20:18 <vincenz> catface: 'kept' is a wrong word
23:20:20 <lambdabot>  Just 3
23:20:46 <paolino> > Just 1 >> Nothing >> Just 3
23:20:47 <lambdabot>  Nothing
23:21:01 <Twey> > Just 1 >>= Just 2 >>= Just 3
23:21:02 <lambdabot>  Couldn't match expected type `t -> Maybe a'
23:21:09 * Twey fails.
23:21:22 <vincenz> > [1 2 3] >> "abc"
23:21:23 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
23:21:23 <lambdabot>     In the expression:...
23:21:28 <vincenz> > [1, 2, 3] >> "abc"
23:21:28 <lambdabot>  "abcabcabc"
23:21:29 <Twey> vincenz: Commas
23:21:38 <vincenz> Twey: I knwo ;)
23:21:40 <oerjan> > Just 1 >>= Just . (+1) >>= Just . (*3)
23:21:41 <Twey> Heh
23:21:41 <lambdabot>  Just 6
23:21:47 <paolino>  >>= eat one parameter functions
23:22:00 <catface> interesting
23:22:12 <vincenz> > [1,2,3] >>= [+1,+2,+3]
23:22:13 <lambdabot>  Parse error at "+1,+2..." (column 14)
23:22:16 <paolino>  >> eats const functions or values
23:22:19 <vincenz> > [1,2,3] >>= [(+1),(+2),(+3)]
23:22:19 <lambdabot>  Couldn't match expected type `t -> [b]' against inferred type `[a]'
23:22:28 <vincenz> hmm
23:22:35 <oerjan> vincenz: nothing in [] can be a one-parameter function
23:22:42 <vincenz> > [1,2,3] >>= \x -> [(x+1),(x+2),(x+3)]
23:22:43 <lambdabot>  [2,3,4,3,4,5,4,5,6]
23:22:44 <dolio> [(+1), (+2), (+3)] <*> [1,2,3]
23:22:47 <vincenz> @pl \x -> [(x+1),(x+2),(x+3)]
23:22:47 <lambdabot> liftM2 (:) (1 +) (liftM2 (:) (2 +) (return . (3 +)))
23:22:49 <dolio> > [(+1), (+2), (+3)] <*> [1,2,3]
23:22:49 <lambdabot>  [2,3,4,3,4,5,4,5,6]
23:23:22 <vincenz> > [(+), (*)] <*> [1..3] <*> [1..3]
23:23:23 <lambdabot>  [2,3,4,3,4,5,4,5,6,1,2,3,2,4,6,3,6,9]
23:23:47 <oerjan> :t sequence [(+1), (+2), (+3)]
23:23:47 <lambdabot> forall a. (Num a) => a -> [a]
23:23:50 <catface> i never knew that
23:24:01 <oerjan> (using (r->) monad)
23:25:04 <paolino> :t (>>=)
23:25:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:25:08 <shachaf> > [1,2,3] >>= sequence [(+1),(+2),(+3)]
23:25:09 <lambdabot>  [2,3,4,3,4,5,4,5,6]
23:25:30 <shachaf> Oh, never mind.
23:25:34 <vincenz> that was odd
23:25:37 <oerjan> @check \fs xs -> fs <*> xs == (xs::[Int]) >>= sequence fs
23:25:38 <lambdabot>   Not in scope: `<*>'
23:25:44 <oerjan> O_O
23:25:54 <paolino> oerjan: second arg is always a one parameter function for >>=
23:26:03 <oerjan> @check \fs xs -> fs `ap` xs == (xs::[Int]) >>= sequence fs
23:26:04 <lambdabot>  Couldn't match expected type `m a' against inferred type `Bool'
23:26:25 <oerjan> paolino: excuse me, that's what i was trying to explain
23:26:32 <paolino> :)
23:26:37 <catface> > [1..3] >> [1..3]
23:26:38 <lambdabot>  [1,2,3,1,2,3,1,2,3]
23:26:41 <oerjan> @check \fs xs -> (fs `ap` xs) == ((xs::[Int]) >>= sequence fs)
23:26:41 <lambdabot>  Add a type signature
23:27:05 <paolino> catface , you are in businnes
23:27:20 <oerjan> @check \fs xs -> (fs `ap` xs) == ((xs::[Int]) >>= sequence fs :: [Int])
23:27:20 <lambdabot>  Falsifiable, after 6 tests: [<Int -> Int>,<Int -> Int>,<Int -> Int>,<Int -> ...
23:27:26 <oerjan> argh
23:27:50 <oerjan> oh wait
23:28:14 <oerjan> @check \fs xs -> (flip ($) `liftM` fs `ap` xs) == ((xs::[Int]) >>= sequence fs :: [Int])
23:28:14 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> b'
23:28:45 <oerjan> @check \fs xs -> ((flip ($) `liftM` fs) `ap` xs) == ((xs::[Int]) >>= sequence fs :: [Int])
23:28:45 <lambdabot>  Couldn't match expected type `Int' against inferred type `a -> b'
23:29:03 <paolino> lambdabot should rise a yellow card after some of her flooding the channel with errors  , when made from one person only  :P
23:29:14 <oerjan> @check \fs xs -> (flip ($) `liftM` xs `ap` fs) == ((xs::[Int]) >>= sequence fs :: [Int])
23:29:19 <lambdabot> Terminated
23:29:26 <lambdabot> oerjan: Please oh please, stop the insanity!!!
23:29:37 <oerjan> but i nearly succeeded :(
23:29:43 <paolino> ahaha
23:29:47 <lambdabot> oerjan: We can @check in private, honey
23:30:56 <oerjan> @check \fs xs -> (flip ($) `liftM` xs `ap` fs) == ((xs::[Bool]) >>= sequence fs :: [Bool]) -- finally
23:31:00 <lambdabot>  OK, passed 500 tests.
23:32:50 <oerjan> problem is, there always seems like just one little bug more...
23:34:04 <oerjan> i mean, i always believe the next test is the last one, so why bother with /msg ...
23:50:30 <gour> hmm, just notice this on reddit - http://tinyurl.com/mgdtj  -ghc version has error
23:50:31 <lambdabot> Title: regex-dna benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ...
23:55:56 <Twey> @src zipWith
23:55:56 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:55:56 <lambdabot> zipWith _ _      _      = []
23:56:21 <Twey> @src zip
23:56:22 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
23:56:22 <lambdabot> zip _      _      = []
23:56:45 <Twey> Ah
