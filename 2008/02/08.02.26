00:08:34 <quicksilver> How would I begin to write a quickcheck combinator which, once it found a counter-example, made an attempt to find a smaller one?
00:08:57 <dmwit> ?go minimal test case quickcheck
00:08:57 <lambdabot> http://www.quviq.com/documents/QuviqFlyer.pdf
00:09:26 <dmwit> There's a paper on this, if I can remember what it's called.
00:11:20 <sclv> ?instances MonadState
00:11:22 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
00:13:52 <dmwit> Dang, I can't find it.
00:25:22 <wy> 1
00:30:23 <quicksilver> dmwit: it's ok, I think I've worked out how to build one using 'generate' and 'evaluate'
00:33:18 <dons> quicksilver: the shrinking stuff is in QC2
00:33:34 <dons> it was described in the first QC paper too, fwiw.
00:33:38 <dons> just not implemented in QC1
00:34:17 <quicksilver> dons: I think it's fairly "obvious", it just wasn't clear that Test.QC actually exported the appropriate primitives.
00:34:34 <quicksilver> dons: because the primitives you need are not documented :) but I believe I worked it out.
00:35:37 <dons> Cale, is it possible this Lisp guy is actually vandalising our wiki?
00:35:48 <dons> Cale, he really seems to be putting in pretty crappy stuff.
00:36:29 <wy> Any idea why Java can't have generic arrays?
00:49:04 <yrzzbe> dons: So in Haskell, when a program runs, and you want to redefine a function and have the redefinition to take effect, one must quit the program first and start it again?
00:50:23 <dons> yrzzbe: well, you can replace modules at runtime. so if you do redefine (and recompile) some code, you could replace that in your running program
00:50:46 <dons> you could also put your functions in a data structure, and lookup the latest definition.
00:50:50 <dons> so there's a few ways to do this, yes.
00:51:08 <yrzzbe> dons: Hmm, let me understand that.
00:51:56 <dons> so i'm trying to say: yes, its possible, but its pretty rarely done.
00:52:18 <yrzzbe> dons: So the idea of Lisp-like REPL is not common in Haskell?
00:52:35 <yrzzbe> s/of/of a/
00:53:06 <glguy> haskell development is more typically done in files
00:53:13 <dons> not really, no. there's some applications (xmonad, lambdabot, yi) that allow redefinitions of parts or all at runtime, but its not that common
00:53:40 <dons> incidentally, you lose much of the benefit of static typing if you allow runtime modification
00:54:01 <dons> > 1+2 -- but it is possible, as you see.
00:54:04 <yrzzbe> dons: I lose much of the benefit of static typing if I allow runtime modification... hmm
00:54:06 <dons> lambdabot is a haskell program with a repl
00:54:08 <lambdabot>  3
00:54:19 <dons> > map (^2) [1..]
00:54:20 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
00:54:32 <dons> so what kind of program are you writing?
00:54:40 <yrzzbe> Pardon my insistence. I'm coming from a Lisp background.
00:54:57 <dons> right, its a bit different to lisp.
00:55:15 <yrzzbe> I'm trying to get a "feel" of Haskell programming. I've always wanted to convert my applications from Common Lisp to Haskell.
00:55:19 <dons> there's a strong distinction between compile-time and run time
00:56:00 <yrzzbe> You mentioned that I lose the benefit of static typing if I allow runtime redefinition, right? Hmm
00:56:07 <dons> right, for the most part you can translate lisp to haskell pretty easily
00:56:23 <dons> the main things to avoid are: mutable cons cells, macros and runtime redefinition of code
00:56:33 <yrzzbe> Ok. So what's the nearest analog of the Common Lisp REPL to Haskell?
00:56:34 <dons> you'll probably have to get used to types as well :)
00:56:39 <dons> well, ghci ?
00:56:50 <dons> the haskell interpreter repl
00:57:04 <dons> its just not typical to emebd that in a program
00:57:05 <yrzzbe> dons: So with GHCI, I can load a program, then redefine a function, as you mentioned above, right?
00:57:09 <dons> yep.
00:57:13 <dons> but its not quite like lisp
00:57:18 <Korollary> redefine?
00:57:24 <yrzzbe> dons: What makes it not quite Lisp?
00:57:45 <dons> just play around with it -- you'll see what i mean. you're not generally modifying a running program
00:57:48 <glguy> *Python> pyInitialize
00:57:49 <glguy> *Python> withCString "print \"Hello World\"" pyRunSimpleString
00:57:51 <glguy> Hello World
00:57:53 <glguy> *Python> pyFinalize
00:57:55 <glguy> round one
00:58:11 <dons> glguy's got envious eyes on all that python code
00:58:26 <dons> PyFFI ?
00:58:39 <glguy> You're asking me to name three FFI functions?
00:58:42 <yrzzbe> dons: What I like most when reading Haskell code, although, at this point I don't completely understand it, is the emphasis on brevity.
00:58:45 <glguy> I'm nto quite ready ot upload to hackage
00:58:58 <dons> yrzzbe: yeah, its definitely concicse.
00:59:12 <glguy> yrzzbe: the emphasis on brevity is magnified on irc though :)
00:59:24 <yrzzbe> dons: And I like it a lot. It's hairy-looking appearance attracts me even more.
00:59:30 <dons> hairy?
00:59:52 <yrzzbe> dons: Yeah, hairy. Something like an obfuscated Common Lisp FORMAT string.
01:00:03 <glguy> lol
01:00:08 <dons> weird. i'd never have thought of haskell as hairy
01:00:13 <glguy> you need to find a new source of example code
01:00:22 <dons> yrzzbe: have you installed ghc?
01:00:34 <yrzzbe> dons: Yeah. I just reinstalled GHC
01:00:52 <dons> cool. so fire up ghci, and maybe go through a couple of tutorials.
01:01:00 <dons> if you know lisp, you should be fine. just keep an eye on the types
01:01:07 <dons> and be sure to ask for the types of things
01:01:10 <dons> :t (:)
01:01:12 <dons> :t []
01:01:13 <lambdabot> forall a. a -> [a] -> [a]
01:01:13 <lambdabot> forall a. [a]
01:01:15 <dons> > 1 : 2 : []
01:01:16 <lambdabot>  [1,2]
01:01:32 <dons> > head [1,2]
01:01:33 <lambdabot>  1
01:01:35 <dons> > tail "haskell"
01:01:36 <lambdabot>  "askell"
01:01:37 <yrzzbe> dons: Yeah. Oh crap. Now, if I really like Haskell, how on Earth am I going to convert all our Lisp applications in Haskell?
01:01:47 <dons> yrzzbe: one by one?
01:01:53 <yrzzbe> dons: I think so.
01:02:29 <yrzzbe> dons: Anyway, thank you for all the quick responses. I've got a load of learning to do. Maybe blog soon.
01:02:40 <dons> sure. glad to help.
01:02:49 <dons> glguy: using missingpy?
01:02:54 <glguy> gpl
01:02:58 <glguy> no dice
01:02:59 <dons> oh. right.
01:03:06 * dons remembers glguy's gone hardcore 
01:03:09 <glguy> I'm just implementing what I need from the python C interface
01:03:21 <dons> straight edge bsd
01:03:59 <glguy> no one is going to impose their license on my free source code
01:04:13 <dons> they hate our freedoms!
01:04:20 <dons> live bsd or die!
01:04:34 <dons> don't tread on my source!
01:04:57 <dons> Ron Paul supports BSD3!
01:05:33 <dons> If you encumber your code, the terrists win!
01:05:48 * dons had a triple espresso this afternoon. 
01:05:56 <resiak> so i take it john goerzen wouldn't relicense it?
01:06:00 * pejo is having one right now
01:06:10 <glguy> resiak: maybe he still will
01:06:20 <glguy> but I don't want to have development stall while he decides
01:06:23 <resiak> fair enough
01:06:53 <resiak> it just struck me that "hey john, could you lgpl/bsd this plz? love, glguy" is less work than reimplementing :)
01:07:04 <glguy> dons sent him a request
01:07:17 <glguy> dons: did you mention lgpl?
01:07:31 <glguy> resiak: and the pygmentize library is pretty slick
01:09:34 <glguy> resiak: even more, this embedded python api seems really nice
01:09:42 <glguy> and like something that would be good to know how to use in the future
01:10:52 <resiak> hmm, pygments looks like
01:10:56 <resiak> erm, nice.
01:14:03 <dons> glguy: yeah, i think the idea of a light pyffi would be useful
01:14:09 <dons> a short path to grab code when we need it
01:15:01 <dons> kfish: you mentoring, or participating in the SoC?
01:16:22 <kfish> dons: hey
01:16:33 <kfish> i'm considering participating as a student ...
01:16:34 * dons thinks its a bit sad the wikipedia article on red black trees doesn't have haskell 'pseudocode'
01:16:42 <dons> kfish: awesome. exactly what i like to hear :)
01:17:08 <opqdonut> any SoC openings in the haskell project?
01:17:22 <dons> opqdonut: there'll be 8-10 slots, i expect. join #haskell-soc :)
01:17:32 <wvd> hello
01:17:53 <dons> hey wvd
01:18:25 <wvd> I want to buy a book about haskell
01:18:33 <opqdonut> dons: we have an analoguous national project too. this would probably go into the same mentoring "quota"?
01:18:44 <opqdonut> wvd: what level?
01:18:48 <dons> wvd, hmm. what project?
01:19:08 <opqdonut> dons: you meant me?
01:19:12 <dons> yep
01:19:15 <wvd> I'm looking for a haskell equivalent to Seibel's practical common lisp
01:19:28 <wvd> is there such a thing?
01:19:35 <dons> wvd, perhaps 'real world haskell' once its out. there's no advanced book on haskell yet, just research papers by the truckload
01:19:39 <opqdonut> wvd: you might want to try "the haskell school of expression"
01:19:39 <dons> there's many good beginner books
01:19:47 <dons> ah yes, perhaps
01:19:57 <quicksilver> there isn't a really great "practical programmer" haskell book yet.
01:20:07 <quicksilver> that is, pretty much, the mandate for the upcoming real world haskell book.
01:20:14 <opqdonut> dons: http://www.coss.fi/web/coss/developers/summercode
01:20:15 <quicksilver> SOE is pretty good, but it is aimed at beginners.
01:20:15 <lambdabot> Title: COSS - Kes&auml;koodi
01:20:16 <wvd> ah
01:20:24 <opqdonut> dons: don't know if the site has any info in english :/
01:20:28 <quicksilver> hutton is good, but it's also aimed at beginners.
01:20:38 <opqdonut> but really analogous to SoC, only a different funder
01:20:41 <quicksilver> hasn't bird written something which uses haskell as an example?
01:20:52 <dons> opqdonut: ok. so that's not part of the quota :)
01:20:59 <dons> quicksilver: yeah.
01:21:00 <kfish> opqdonut, and it needs mentors, and its ok to mentor in english?
01:21:05 <opqdonut> yeah
01:21:06 <quicksilver> Hm.
01:21:13 <quicksilver> "Introduction to Functional Programming"
01:21:20 <quicksilver> but that's not what I thought I was thinking of :)
01:21:22 <wvd> I'm still struggling to make the jump from sorting lists and recursive fibonacci functions to doing actual work
01:21:24 <dons> Richard Bird: Introduction to Functional Programming using Haskell,
01:21:29 <quicksilver> I thought Bird had written some more advanced stuff.
01:21:33 <quicksilver> But maybe that's only papers.
01:21:33 <dons> wvd, here's the books, http://haskell.org/haskellwiki/Books
01:22:06 <dons> wvd, the blog articles have *lots* of practical stuff, http://haskell.org/haskellwiki/Blog_articles
01:22:12 <dons> and you can explore hackage.haskell.org
01:22:17 <dons> lots of apps and libs there to look at
01:22:18 <wvd> I'll check it out thanks
01:22:24 <dons> find something you like, and modify it, or reimplement it
01:23:22 <kfish> opqdonut, mention in on haskell-soc / -cafe, we had more projects+mentor proposals than gsoc's funding quota covered last year
01:23:24 <quicksilver> dons: I keep trying to ask you somethign about hmp3 but you're never aruond.
01:23:32 <dons> quicksilver: quick!
01:23:32 <opqdonut> kfish: oh okay
01:23:35 <dons> ?time
01:23:38 <lambdabot> Local time for dons is Tue Feb 26 01:23:35 2008
01:23:43 <quicksilver> dons: How does it grab the id3 stuff? via a library, or via a commandline tool?
01:23:43 <Samburger> Ive found reading through prelude helps
01:23:51 <dons> quicksilver: command line
01:23:59 <quicksilver> dons: Ah. I feared as much.
01:24:07 <dons> you could bind to the id3 lib though :)
01:24:12 * quicksilver nods
01:24:17 <quicksilver> I was hoping someone else already had.
01:24:29 <Samburger> This is my third night learning Haskell. It's tough but it's growing on me
01:24:29 <quicksilver> Preferably a version which understands Apple's album art extensions
01:24:42 <dons> Samburger: great. got some code together?
01:25:18 <kfish> OceanSpray, thinking of doing summer of code?
01:25:25 <Samburger> Just very basic stuff, going through online tutorials, trying some basic functions on my own
01:25:31 <OceanSpray> kfish, maybe.
01:25:38 <dons> Samburger: cool. good idea to hang out here too then :)
01:25:43 <OceanSpray> I doubt I have the ability, though.
01:25:51 <dons> have you met lambdabot, Samburger ?
01:25:57 <dons> > map (^2) [1..]
01:26:06 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
01:26:11 <kfish> OceanSpray, you shoulda done it last year, you could have gotten funding for writing oggz-comment ;-)
01:26:45 <glguy> How does the FFI deal with variable argument functions?
01:26:56 <Samburger> so if it's true Haskell has no convoluted for loops, I'm moving in
01:27:04 <dons> glguy: with difficulty. i think there's something about it in the ffi spec though
01:27:17 <dons> Samburger: loops are strictly optional
01:27:29 <dons> > fix ((0:) . scanl (+) 1) -- we like fixpoints instead :)
01:27:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:28:03 <Samburger> being able to express an infinite list is also very nice
01:29:30 <dons> hehe cool, we cracked 1M lines of haskell code on ohloh, http://www.ohloh.net/languages/38
01:29:30 <lambdabot> Title: Tools - Ohloh
01:30:10 <jeffz> hopefully not too much of it has rotted ;p
01:31:26 <sm> yay! fungen compiling
01:34:50 <resiak> I'm in  ErrorT Errno IO, and want to catch IOErrors thrown by (in this case) getDirectoryContents and throwError with the appropriate errno.  But, catch has the wrong type; how can I lift it into the transformed monad?
01:38:25 <Gilly> Hello, I have a STArray with indices (0,0)..(w,h). Are there builtin methods to go through the indices and update each slot in the array using result from some function?
01:38:26 <quicksilver> resiak: what do you mean, catch has the wrong type?
01:38:36 <quicksilver> resiak: which catch do you mean?
01:38:56 <resiak> IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
01:39:30 <pejo> dons, heading to bed, or going to stick around for a while?
01:39:32 <resiak> I've got an IO a, lited to ErrorT Errno IO a, and I want to catch errors in it and use throwError
01:39:46 <quicksilver> resiak: Ah, I see your point.
01:39:48 <glguy> Hmm, how do I write a ffi binding to a macro?
01:40:02 <quicksilver> resiak: you need to read my article about monadic tunnelling.
01:40:04 <resiak> glguy: you write a stub C function that calls the macro, then bind the stub, afaict
01:40:08 <quicksilver> glguy: wrapper function
01:40:11 <quicksilver> (C function)
01:40:14 <wvd> whoa, catch has the same (more or less) type signature as bind
01:40:25 <glguy> in cbits?
01:40:33 <quicksilver> wvd: yes, an error monad looks like it has "two" binds.
01:40:40 <quicksilver> wvd: it's quite interesting
01:41:14 <quicksilver> Gilly: not as such, no, but that's because it's so easy to write one.
01:41:20 <resiak> hmm, i've read this before :)
01:41:22 <quicksilver> Gilly: just use standard tools like forM_ or mapM_
01:41:38 <Gilly> quicksilver: ok thanks, i'll look at them :)
01:41:41 <quicksilver> resiak: basically you need a fiddly little wrapper
01:41:51 <quicksilver> resiak: which you might or might not bother to make general.
01:42:03 <quicksilver> @unmtl ErrorT Errno IO a
01:42:03 <lambdabot> IO (Either Errno a)
01:42:18 <quicksilver> resiak: ^^ notice this *is* actually of the form IO a
01:42:23 <resiak> right
01:42:27 <quicksilver> resiak: so you can squeeze it into the callback
01:42:36 <quicksilver> resiak: you just need to wrap/unwrap.
01:42:38 <resiak> sure
01:42:45 <quicksilver> annoying boilerplate, which you can hide away.
01:42:51 <quicksilver> :t ErrorT
01:42:51 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
01:42:54 <quicksilver> :t runErrorT
01:42:54 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
01:43:02 <resiak> i wonder how hard it would be to automate the generation of the boilerplate
01:43:22 <quicksilver> well the monadic tunnelling stuff shows how to abstract the boilerplate into a typeclass
01:43:28 <quicksilver> not the same thing as automating it
01:43:29 <resiak> yep
01:43:33 <glguy> quicksilver: do you know if I can use that wrapper from ghci?
01:43:35 <quicksilver> but at least you only have to do it once.
01:43:45 <glguy> with some flag to tell it to load the object file?
01:43:48 <glguy> so I can call tha function
01:43:49 <resiak> hmm, actually, i can just catch the IOErrors at the top level, outside the runErrorT
01:43:59 <resiak> but it feels messy to have random IO errors flying around
01:44:01 <quicksilver> that's also possible, but possibly more ugly.
01:44:57 <resiak> it avoids having to sprinkle embedIO everywhere
01:45:05 <resiak> and hfuse already has a top-level fallback ioerror handler
01:45:17 <resiak> (or rather, a hook for one)
01:46:36 <resiak> thanks for pointing out the similarity to your article!
01:50:09 <sm> good night
01:54:59 <Gilly> is the usual way to convert from int to double to use (fromIntegral i) ? it's a bit ugly to have to use that after every / or * with doubles
01:56:03 <Beelsebob> yes, that is the usual way
01:56:17 <Beelsebob> with litterals, the compiler will do it automagically
01:56:33 <Beelsebob> actually, sorry, no, it'll use fromInteger
01:57:17 <Gilly> ok thanks
02:04:19 <quicksilver> Gilly: nothing stops you writing a shorter synonym if you have ugly code which uses it a lot
02:04:22 <quicksilver> ;)
02:04:36 <quicksilver> let fi x = fromIntegral x in ....
02:06:01 <Gilly> mmm that's true :) it's just that i'm not used to 1) haskell 2) functional programming yet so I got to make sure I'm not doing stuff in an unnecessarily complicated manner
02:06:56 <quicksilver> actually it's even possible to define a version of * or / which converts automatically
02:06:58 <Beelsebob> you may also want to consider the div function, if what you really want is integer division
02:07:03 <quicksilver> it's just the default one doesn't
02:07:13 <quicksilver> you just need to think carefully what the rules you want are
02:07:22 <Beelsebob> I thought * worked on all Num a anyway
02:07:23 <wagle_home> you might be doing something wrong if you are having to convert all the time
02:07:24 <Beelsebob> :t (*)
02:07:26 <lambdabot> forall a. (Num a) => a -> a -> a
02:07:32 <quicksilver> Beelsebob: yes, but it always returns the type you give it
02:07:49 <quicksilver> Beelsebob: you can redefine * with type b -> b -> a or c -> b -> a if you like.
02:07:57 <Gilly> wagle_home: well not all the time, i had some array indices and needed to map them to the real plane i got
02:07:58 <quicksilver> Beelsebob: it's purely a question of convenience / type annotation tradeoffs.
02:07:59 <Beelsebob> ah, okay, sorry, I was assuming for some reason he was having to do (fromInteger x) * (fromInteger y) which makes not so much sense
02:08:18 <quicksilver> Beelsebob: I have to do a *lot* of type conversions in some code I have which uses Word32
02:08:27 <quicksilver> it has to use Word32 for definiteness of an external file format
02:08:31 <quicksilver> it's bloody annoying, frankly
02:08:32 <Beelsebob> ikky
02:08:40 <quicksilver> but I'm sure when I take a step back I will be able to see the way to clean it up
02:09:06 <quicksilver> the problem there is typically using take/drop/length
02:09:23 <Beelsebob> this is something that I've always wanted to address in Hat... but never really had the chance, or the courage
02:09:46 <Beelsebob> well, a related issues actually
02:09:57 <Beelsebob> the defaulting, means that the trace tells you the fromInteger happened
02:10:06 <Beelsebob> but you really don't want to see that
02:10:10 <Beelsebob> especially if you didn't write it
02:11:22 <Beelsebob> actually... just thinking about that, there should be a way to tell if the fromInteger really existed or not
02:11:29 <Beelsebob> just need to look at the source code reference
02:13:16 <glguy> bwahahaah
02:13:32 <glguy> I managed to call pygments via ffi and color coded some code :)
02:14:00 <wagle_home> next is smell and taste
02:14:18 <hpaste>  glguy pasted "first draft calling pygments" at http://hpaste.org/5913
02:15:09 <glguy> python seems to be having a love affair with variadiac functions
02:16:18 <quicksilver> nice
02:17:12 <wagle_home> glguy, is that the buildValue{1,2,3}?
02:17:25 <glguy> yeah
02:17:34 <glguy> there might be a better way, in fact someone said there was
02:17:40 <glguy> but I could copy and paste faster
02:17:42 <glguy> than I could read
02:17:46 <glguy> and I wanted to see some results tonight :)
02:17:58 <wagle_home> heheh
02:18:27 <glguy> I wonder if this is slower than what I was doing before... just calling the python executable
02:19:37 <wagle_home> well named functions anyway..  sounded like they built multivalues
02:20:04 <wagle_home> ... and i dont know the interface/api at all
02:26:13 <ac> Wouldn't it be feasible for Haskell to have "open classes"? So basically just removing the multiple declaration of class error
02:27:45 <wagle_home> how would you compile that?
02:28:05 <therp> ac: I think that would break the modularization of the type system.
02:28:27 <therp> hmm..
02:28:53 <quicksilver> ac: haskell does have open classes, in the sense that that is normally mean.
02:29:03 <quicksilver> but presumably not in the sense you mean.
02:29:13 <quicksilver> What would the semantics of a multiple-defined class be?
02:30:20 <ac> Taking each class definition with the same name and turning it in to one
02:30:39 <quicksilver> taking the union of the methods?
02:31:03 <quicksilver> sounds feasible to me.
02:31:29 <ac> Now that I think about it, I'm not sure it would add any functionality
02:32:22 * doserj thinks classes should have only one method anyways...
02:32:43 <ac> I'm a fan of one method classes. It annoys me that Binary has both get and put
02:34:56 <wagle_home> what would you get from supporting "open classes"?
02:35:20 <schemelab> hello everyone. please take a moment to answer my question - http://sequence.complete.org/node/379 - and perhaps toss it up on reddit
02:35:21 <lambdabot> Title: Is the state mechanism of Clean better than Haskell? | The Haskell Sequence
02:36:56 <scook0> monads aren't just for state
02:37:03 <scook0> and every monad gives rise to an arrow
02:41:07 <quicksilver> schemelab: I don't wish to be rude, but the impression I have from that post is that you don't know what an arrow, a monad, or a monad transformer is.
02:41:21 <quicksilver> schemelab: which is absolutely fine, but it makes you poorly qualified to compare them to uniqueness types :P
02:41:27 <hpaste>  glguy annotated "first draft calling pygments" with "second draft python calling" at http://hpaste.org/5913#a1
02:43:08 <glguy>       callFunction3 highlight "(sOO)" code lexer formatter
02:43:18 <glguy> I bet I could make the "(sOO)" go away
02:43:22 <glguy> with a not too clever class
02:43:33 <wagle_home> i got this wild image that i was looking at the (high level) assembly code for a python program
02:43:35 <hpaste>  beelsebob pasted "fromInteger" at http://hpaste.org/5914
02:43:42 <Beelsebob> woot, notable by it's absense :)
02:44:51 <gour> is there any estimation about publishing date for realworld book?
02:45:06 <Beelsebob> realworld book?
02:45:23 <gour> yes
02:45:33 <gour> realworldhaskell book
02:46:27 <wagle_home> (everything starts with py....)
02:47:04 <wagle_home> ... or maybe an nice intermediate code
02:47:19 <glguy> wagle_home: those are the py c functions directly
02:47:32 <quicksilver> gour: I am not aware of an estimate
02:47:33 <glguy> the stuff without py is wrapper
02:48:32 <wagle_home> yeah
03:05:37 <glguy> wagle_home: you're going to like draft 3 :)
03:05:42 <glguy> more than the previous two at least
03:10:47 <hpaste>  glguy annotated "first draft calling pygments" with "draft 3" at http://hpaste.org/5913#a2
03:10:55 <glguy> now to get rid of the manual reference counting
03:14:42 <glguy> should I be using foreign pointers here to call the reference counting decrement function
03:14:47 <glguy> when objects go out of scope?
03:16:05 <quicksilver> s/out of scope/get collected/
03:16:16 <quicksilver> I think that's what it's for, yes. I think you want ForeignPtr.
03:26:12 <hpaste>  moonlite pasted "HXT Filters. " at http://hpaste.org/5915
03:26:39 <moonlite> I have trouble understanding HXT. :/ Could someone give me a hint? :)
03:43:22 <ac> HXT looks cool
03:43:41 <glguy> how can I make CInt a void*?
03:43:59 <glguy> Ptr a
03:45:00 <moonlite> ac: a bit hard to grasp though
03:45:31 <magr> glguy: try 'wordPtrToPtr (fromIntegral c)' for a CInt c
03:45:57 <glguy> ?index wordPtrToPtr
03:45:57 <lambdabot> bzzt
03:46:07 <ac> Foreign.Ptr
03:46:36 <moonlite> _all_ examples i've seen so far starts with a readDocument, follows with some filters or transformation and ends with a writeDocument. It must be possible to retrieve the data as normal Haskell types (lists of strings) :) But i can't find any
03:47:13 <glguy> magr: that typechecks :)
03:47:18 <glguy> I wonder if it works
03:48:39 <hpaste>  glguy annotated "first draft calling pygments" with "draft 4, no ref counting" at http://hpaste.org/5913#a3
03:48:52 <ac> moonlite: the API looks huge
03:49:17 <moonlite> ac: yep, i have yet to find out where to start :/
03:49:51 <moonlite> oh well no reason to just sit here whining about it.
03:49:55 * moonlite dives back in
03:57:05 <ac> moonlite: xPValue2NodeSet?
03:57:29 <ac> "The XmlNodeSet can be used to traverse a tree an process all marked nodes."
04:08:41 <wvd> I'm trying to setup a company wide addressbook with ldap
04:09:02 <wvd> so I am looking at the haskell ldap library on hackage
04:09:20 <wvd> which is fine and all, but why the heck is ldap so damn complicated?
04:09:35 <wvd> the l is supposed to stand for "lightweight"
04:13:17 <daniel_larsson> wvd: that's lightweight in relation to X.500, only ;-)
04:13:19 <pejo> wvd, compared to X.500.
04:13:36 <smg> lol
04:15:08 <daniel_larsson> same as an elephant is lightweight in relation to a brontosaurus....
04:20:33 <opqdonut> > let primesA n = let m = floor (sqrt$fromIntegral n) in array (2,n) $ (zip [2..n] $ repeat True) ++ concatMap (\x -> zip [2*x,3*x..n] $ repeat False) [2..m]
04:20:34 <lambdabot>  Parse error at end of input
04:20:38 <opqdonut> ?let primesA n = let m = floor (sqrt$fromIntegral n) in array (2,n) $ (zip [2..n] $ repeat True) ++ concatMap (\x -> zip [2*x,3*x..n] $ repeat False) [2..m]
04:20:41 <lambdabot> Defined.
04:20:46 <opqdonut> > primesA 30
04:20:48 <lambdabot>  array (2,30) [(2,True),(3,True),(4,False),(5,True),(6,False),(7,True),(8,Fal...
04:20:56 <opqdonut> what do you think?
04:22:21 <opqdonut> somebody asked me whether it's possible to implement erastothenes properly in haskell, i think that's as good as a C array version
04:23:22 <Zao> I had to use arrays for my sieve.
04:23:37 <opqdonut> couldn't come up with an efficient stream version, except maybe generating the [k*2,k*3..n] streams, merging them, and then taking the "complement" wrt [2..n]
04:23:48 <Zao> My list-based one took 1.5h to generate 10k primes, array 5s :)
04:23:55 <opqdonut> yeah
04:24:09 <opqdonut> i use a memoized prime tester nowadays, mostly
04:25:43 <smg> mauke?
04:25:49 <smg> @seen mauke
04:25:49 <lambdabot> I saw mauke leaving #xmonad and #haskell 11h 48m 35s ago, and .
04:26:02 <smg> daniel_larsson: lol@
04:34:35 <solrize> so do i have any chance of being able to use hxt if i have no clue how arrows work?
04:35:25 <Gilly> is it possible to have a list of elements that belong to the same class ? (I expect no, are there any workarounds?)
04:35:51 <Gilly> what i mean is different data types but belong to the same class
04:37:19 <solrize> gilly, by definition all members of a list have to be the same type
04:37:37 <solrize> you can make a sum type of course
04:38:46 <quicksilver> Gilly: yes, you can use an existential for this.
04:38:57 <quicksilver> Gilly: quite often this is not what you want, but occasionally it is :)
04:39:30 <Gilly> a sum type? an existential? what are they? :)
04:39:49 <opqdonut> switching to UArray speeded that up quite a bit
04:39:56 <opqdonut> i'm comparing with the shootout nsieve solution
04:40:03 <daniel_larsson> data SumType = CaseA Int | CaseB String
04:40:07 <quicksilver> Gilly: a sum type is simple data Foo = Bar Something | Baz SomethingElse
04:40:34 <quicksilver> Gilly: and existential is (more or less) exactly what you asked for: an element of unknown type, but with constraints. E.g. belonging to a given class.
04:40:51 <Gilly> Ah :) Ok... well that's not an option for me because I might add types later and wouldn't like to 'fix' them.
04:41:05 <Gilly> Ok, existential sounds better :)
04:41:59 <sjw`> dons: around?
04:48:34 <smg> hello
04:48:39 <smg> i use lambdabot with @src
04:48:41 <smg> @src (!!)
04:48:41 <lambdabot> xs     !! n | n < 0 = undefined
04:48:41 <lambdabot> []     !! _         = undefined
04:48:41 <lambdabot> (x:_)  !! 0         = x
04:48:41 <lambdabot> (_:xs) !! n         = xs !! (n-1)
04:48:55 <smg> is there something like that @ ghci?
04:50:46 <daniel_larsson> Someone wrote a thinger to integrate lambabot functionality in ghci, but you need to have lambabot installed locally
04:52:23 <daniel_larsson> @google GOA lambabot ghci
04:52:24 <lambdabot> No Result Found.
04:52:31 <daniel_larsson> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:52:32 <lambdabot> Title: lambdabot
04:53:42 <smg> i see
05:03:19 <hpaste>  chavto pasted "IJVM_" at http://hpaste.org/5916
05:06:42 <[1]schemelab> I would appreciate a response on my blog to my question - http://sequence.complete.org/node/379
05:29:33 <pejo> JaffaCake, едц on you.
05:31:17 <opqdonut> is IOUArray notably faster than UArray?
05:31:25 <opqdonut> when used as an immutable array
05:31:30 <Cale> schemelab: still here?
05:31:36 <schemelab> Cale high
05:31:53 <Lemmih> opqdonut: It shouldn't be.
05:31:56 <schemelab> so the question becomes, in an advanced project, do the various things conflict (monads, arrow, monad transformers)
05:32:00 <opqdonut> yeah that's what i thought
05:32:02 <schemelab> Cale answer on the blog please?
05:32:02 <Cale> Uniqueness typing doesn't really replace what various monads and arrows do.
05:32:19 <schemelab> Cale: it makes I/O vastly different
05:32:19 <opqdonut> gah, my UArray sieve is 20x slower than the ST version on shootout
05:32:23 <schemelab> Cale answer on the blog please
05:32:31 <Cale> I suppose I could.
05:32:44 <Cale> Any particular reason you wouldn't want to hear the answer on IRC?
05:33:21 <schemelab> we want to etch it in stone
05:33:26 <Cale> heh
05:33:30 <schemelab> we being me and perhaps CosmicRay
05:33:49 <schemelab> reddit would not be bad either - i'm sure the general public has the same impression of haskell if I have it having tried to learn the language a few times
05:35:01 <schemelab> Cale wait
05:35:08 <schemelab> i'm making my question a bit better worded
05:35:28 * quicksilver nods his previous rather harsh criticism had already prompted one rewording :)
05:38:34 <Cale> schemelab: Have you read http://www.haskell.org/haskellwiki/Monads_as_Computation ? It doesn't discuss the option of handling I/O by uniqueness typing, but it does try to give some overall view of what monads are actually about.
05:38:35 <lambdabot> Title: Monads as computation - HaskellWiki
05:40:18 <schemelab> Cale: Do you think my question is well worded now and worth answering - http://sequence.complete.org/node/379
05:40:19 <lambdabot> Title: Do arrows, monads, monad transformers clash when a large app needs libraries whi ...
05:40:38 <schemelab> Cale: couldnt there be a document called "Arrows as computation"?
05:40:47 <schemelab> see what I'm getting at?
05:40:49 <Cale> Yes, indeed, there could.
05:40:56 <schemelab> that's where the problem comes in
05:41:01 <schemelab> in java there is only objects
05:41:03 <Cale> It's not a problem.
05:41:07 <schemelab> no confusion of abstractoin mechanisms
05:42:05 <Cale> Complaining that there are too many different monads/arrows/etc. and making them work together is hard is like complaining that there are too many libraries and making them work together is hard.
05:42:27 <scook0> schemelab: I wouldn't say there's no confusion
05:42:33 <scook0> everything gets confused with objects!
05:42:45 <Cale> A library can make use of the monad abstraction, and the benefit of it is that it gets the operations defined in Control.Monad for free.
05:42:49 <shepheb> I would think that Java libraries in fact do whatever they like, with no common interface at all. Aren't monads and arrows, even though they are split, both wins because they unify the interfaces of libraries?
05:42:50 <schemelab> Cale: so it's really not a big deal
05:42:57 <Cale> Not as I see it.
05:43:10 <schemelab> lol
05:43:15 <schemelab> Ranter => Terran
05:43:20 <schemelab> cyclic computatoin
05:43:33 <schemelab> Cale: so is haskell better than clean?
05:43:41 <schemelab> lets just talk language
05:43:42 <Cale> That's a strange question.
05:43:47 <schemelab> I know the haskell community is more active
05:44:03 <schemelab> but is uniqueness typing a big win over haskell's equivalent? which is what by the way?
05:44:04 <Cale> I certainly like Haskell's IO library better.
05:44:24 <quicksilver> haskell's Monad abstraction unifies many kinds of effect.
05:44:36 <quicksilver> It means you can write generalised combinators which work with IO actions
05:44:39 <QtPlatypus> schemelab: Don't you have a biased sample asking that here?
05:44:41 <Cale> Monads can be used just as easily in Clean.
05:44:45 <quicksilver> but are also applicable in loads of different circumstances.
05:44:51 <Cale> Er... do they have do-notation?
05:44:51 <schemelab> QtPlatypus: i think the people here are pretty openminded
05:44:55 <Cale> I can't remember.
05:45:02 <quicksilver> (I am comparing Monads to Uniqueness types, not Haskell to Clean)
05:45:06 <Cale> Regardless, you can make it work reasonably well.
05:45:35 <schemelab> uniqueness types get rid of the "fence" tat you see in haskell code... not sure if thats a win or loss
05:46:34 <Saizan> fence?
05:46:41 <schemelab> well I am being drawn back to haskell again... it's such a simple language ... most language have tons of stuff... Haskell is basically function application
05:46:54 <Cale> Clean does explicit World-passing doesn't it?
05:47:17 <schemelab> if you look at the main program to that girl's wiki (forgot her name), you see a big fence between the code and the I/O
05:47:24 <schemelab> what is her name?
05:47:31 <Cale> Philippa?
05:47:33 <schemelab> yeah!
05:48:03 <Cale> Well, that's generally true of most Haskell programs.
05:48:27 <Cale> You design your program such that the user interface is in I/O, and the real work is done in pure code.
05:48:49 <shepheb> .oO( Isn't that a good thing? My evil, sharp-edges IO code is over here on the edges, and my soft, cushy pure code is over here, doing the work. )
05:48:52 <Cale> It's basically just model/view/controller, if you're an OO person.
05:49:27 <Cale> The model is pure. Sometimes bits of the view and controller can be pure as well, but they're where the I/O happens.
05:50:01 <schemelab> yeah, I was just mentioning that Clean doesnt have that I/O fence
05:50:07 <Cale> It does though.
05:50:15 <schemelab> but I agree that the fence does separate concerns nicely
05:50:24 <schemelab> by the way, I'm metaperl if you dont already know that
05:50:30 <Cale> yeah, I realised :)
05:50:47 <opqdonut> > foldl1 (+) [x,y,z,w] :: Expr
05:50:52 <lambdabot>  x + y + z + w
05:50:53 <Cale> You have to pass around the world, and due to uniqueness types, you can't just do anything with it, you have to pass it along to the next thing which does I/O
05:50:58 <opqdonut> > foldl1 f [x,y,z,w] :: Expr
05:50:58 <lambdabot>  f (f (f x y) z) w
05:51:14 <opqdonut> > foldr1 f [x,y,z,w] :: Expr
05:51:16 <lambdabot>  f x (f y (f z w))
05:51:42 <Cale> Now, you might work out some system for doing this threading for you, but what you'll end up with is something which looks exactly like the IO monad.
05:51:52 <EvilTerran> Cale, sounds like you could mock up an "IO monad" using a state-monad-like structure and uniqueness types
05:51:57 <Cale> yep
05:52:17 <opqdonut> you can even do it with state and () and a tinge of strictness right?
05:52:41 <Cale> I'm not sure what you mean about () there
05:52:47 <opqdonut> the unit type
05:52:59 <opqdonut> as the "World" type
05:53:06 <quicksilver> EvilTerran: that's rather close to what GHC's "behind the scenes" IO implementation looks like.
05:53:15 <Cale> Er, I'm not sure () can act as the world type
05:53:31 <quicksilver> EvilTerran: only the primitives don't enforce the uniqueness. But the compiler that generates them does.
05:53:38 <opqdonut> Cale: oh, what could then?
05:53:43 <EvilTerran> indeed
05:53:43 <Toxaris> opqdonut: what would stop me from inventing new worlds?
05:53:58 <EvilTerran> Toxaris, fear of unsafePerformIO :P
05:54:05 <Cale> opqdonut: You need some type for which the constructors are not available to the programmer.
05:54:06 <opqdonut> Toxaris: the monad interface
05:54:18 <opqdonut> yeah, of course a "private" version of ()
05:54:21 <Cale> opqdonut: Otherwise, all hell can break loose.
05:54:25 <opqdonut> yes, yes
05:54:28 <Cale> ah, okay
05:54:36 <opqdonut> :)
05:54:45 <opqdonut> data World# = World# or something
05:55:15 <Cale> and you want to use uniqueness types (if you have them), to ensure that the World# doesn't get duplicated
05:55:42 <opqdonut> can't you ensure that implementing the monad instance properly?
05:55:47 <opqdonut> +by
05:55:49 <Cale> Yes, sure.
05:55:50 <Toxaris> opqdonut: ah ok :) isn't that how IO is implemented in terms of ST?
05:56:01 <Cale> You also need side effects
05:56:22 <doserj> @src IO
05:56:24 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
05:56:24 <Cale> Basically, the idea is to get the data dependencies to enforce a linear order on the effects.
05:56:28 * shepheb crimethinks
05:56:42 <opqdonut> Cale: yes
05:57:02 <opqdonut> @src RealWorld
05:57:02 <lambdabot> Source not found. Are you on drugs?
05:57:13 <smg> lambdabot: lol
05:57:17 <opqdonut> realworld is isomorphic to unit, right?
05:57:24 <Cale> Effectively.
05:57:28 <Toxaris> newtype ST s a = ST (STRep s a)
05:57:28 <Toxaris> type STRep s a = State# s -> (# State# s, a #)
05:57:31 <smg> @elite yes
05:57:31 <lambdabot> yes
05:57:36 <Cale> At a low enough level it is.
05:57:39 <opqdonut> so IO is just State () basically
05:57:44 <Cale> The module system spoils that isomorphism though.
05:57:53 <opqdonut> Cale: especially it gets removed compile-time right?
05:58:12 <Cale> It's State (), with side effects.
05:58:29 <schemelab> thanks for the input guys. I'm returning to Bird and Wadler with a vengeance :)
05:58:35 <schemelab> off to work. bye
05:58:36 <Cale> Normally, you can't get side effects happening in State ()
05:58:41 <opqdonut> yeah of course
05:58:50 <opqdonut> we use non-pure functions to implement the IO actions
05:59:17 <opqdonut> and then wrap all this ugliness in IO, that is, State ()
05:59:49 <Cale> I don't think of it that way, myself, though.
06:00:15 <Cale> There's another way to implement the IO monad which I much prefer, though it involves GADTs.
06:00:23 <opqdonut> pray tell?
06:00:49 <Cale> Essentially, represent IO actions explicitly as syntax...
06:00:57 <Cale> data IO :: * -> * where
06:01:06 <Cale>    ReturnIO :: a -> IO a
06:01:16 <Cale>    BindIO :: IO a -> (a -> IO b) -> IO b
06:01:28 <Cale>    putChar :: Char -> IO ()
06:01:30 <Cale> er
06:01:36 <Cale>    PutChar :: Char -> IO () -- rather
06:01:55 <Cale> and so on
06:01:56 <opqdonut> ah
06:02:02 <opqdonut> yeah that's pretty nice
06:02:13 <Cale> and then the RTS takes this data apart and carries out the instructions
06:02:34 <opqdonut> that's of course a bit more magicky than the current IO
06:02:36 <opqdonut> but pure
06:04:10 * shepheb generally prefers magic to pain.
06:04:21 <shepheb> .oO( first step toward lichdom? )
06:05:30 <shepheb> I'll happily accept a magical, black box IO system over one like C, with only a thin layer (or less) between me and the system calls.
06:25:20 <shepheb> is there (or can someone write out) a list of the type classes that ordinary pure functions satisfy?
06:26:52 <opqdonut> huh?
06:27:13 <Lemmih> eh?
06:27:20 <shepheb> well, there's instance Arrow (->), and I'm pretty sure they're Monoids too.
06:27:26 <opqdonut> ah you mean like "instance Functor (->) a"
06:27:31 <opqdonut> yeh
06:28:00 <Lemmih> shepheb: :i (->)
06:28:45 <opqdonut> ?index (->)
06:28:45 <lambdabot> bzzt
06:28:56 <shepheb> data (->) a b from GHC.Prim
06:29:28 <Lemmih> shepheb: :m Control.Monad.Instances
06:30:57 <shapr`> I am an instance of Haskeller!
06:31:49 <scook0> instance Haskeller I
06:33:27 <shapr`> instance USCitizen shapr where stereotype = undefined
06:33:35 * shapr` goes back to hacking on InfoPath...
06:34:33 <smg> mh how to create a list like [True,False,True,False...]
06:34:34 <smg> ?
06:34:43 <byorgey> > cycle [True,False]
06:34:49 <lambdabot>  [True,False,True,False,True,False,True,False,True,False,True,False,True,Fals...
06:35:01 <shepheb> Lemmih: hmm. those seem incomplete, though. wouldn't we have instance Monoid ((->) r) where mzero = id; mplus = (.)
06:35:21 <byorgey> smg: 'cycle' makes a finite list into a (space-efficient, circular) infinite one.
06:35:32 <smg> cycle True,False?
06:35:35 <smg> ah okay thank you
06:35:37 <smg> i hate that...
06:35:38 <Lemmih> shepheb: Apparently not.
06:35:40 <quicksilver> shepheb: surely you mean ((->) r r)
06:35:46 <byorgey> smg: hate what?
06:36:02 <Toxaris_> shepheb: check out newtype Endo in Data.Monoid
06:36:11 <shepheb> quicksilver: hmm. I was basing it on "instance Monad ((->) r)", but probably yes, if it were true.
06:36:12 <smg> i think - don't get the question, i ask the question, minimize window of chat, think again, find solution and see your answer :]
06:36:16 <smg> thank you
06:36:18 <quicksilver> shepheb: but that's different.
06:36:24 <smg> question=answer
06:36:30 <quicksilver> shepheb: the Monad instance is (->) r
06:36:33 <stevan> hi, i got problems building yi-vty: http://hpaste.org/5917
06:36:39 <quicksilver> shepheb: the Monoid instance is (->) r r
06:36:49 <quicksilver> shepheb: these are as different as chalk and cheese :)
06:37:07 <byorgey> smg: oh, yeah, there's something weird about how you often find the answer to a question yourself, right after asking it. I don't know why that is. =)
06:38:09 <Toxaris_> because formulating the question (in a whole sentence, providing enough context) is part of the answering process?
06:38:19 <Saizan> ?instances-importing Data.Monoid Monoid
06:38:20 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
06:38:24 <byorgey> stevan: you do have alex installed?
06:38:31 <byorgey> Toxaris_: that's probably a big part of it.
06:38:44 <smg> byorgey: yeah really strange :D
06:39:05 <stevan> byorgey: yes
06:39:16 <byorgey> stevan: hm, I don't know then, I've never seen that error
06:39:22 <byorgey> stevan: did you try asking in #yi ?
06:39:42 <byorgey> not too many people in there I guess
06:40:21 <shepheb> Saizan: useful. is there the converse; to tell me all the instances a given type (a -> b here) satisfies (holds? is?)
06:40:50 <tonfa> hi
06:40:51 <quicksilver> shepheb: yes, and you were told what it was.
06:40:54 <shapr`> hi tonfa
06:40:56 <quicksilver> shepheb: :i (->)
06:41:00 <quicksilver> shepheb: (in ghci)
06:41:02 <shapr`> tonfa: Are you learning Haskell?
06:41:17 <shepheb> quicksilver: I did, but it only coughs up a few depending on which modules are imported.
06:41:22 <quicksilver> yup.
06:41:22 <tonfa> shapr`: I learned it this summer, but I don't use it a lot
06:41:27 <quicksilver> that's the best you get, I'm afraid.
06:41:36 <shepheb> quicksilver: fair enough.
06:41:50 <tonfa> can you do multi-lines function definition (pattern matching) in ghci ?
06:42:24 <Saizan> tonfa: use ; to separate lines
06:42:57 <Saizan> tonfa: let f 0 = 1; f x = x * f (x-1);
06:43:02 <tonfa> Saizan: but it has to be one the same line
06:43:25 <resiak> it'd be kind of nice for ghci to behave like the python interpreter does
06:43:25 <Saizan> yeah, ther's no multiline editing mode for ghci
06:43:28 <tonfa> (I was using ';', but I was wondering if there was a way to do it in multiple lines)
06:43:34 <tonfa> Saizan: ok
06:43:38 <tonfa> thank you
06:44:04 <mightybyte> resiak: Yeah, I had similar thoughts when I started learning haskell.
06:44:30 <shapr`> resiak: How so?
06:44:32 <mightybyte> resiak: It seemed like there was an invisible line beyond which some code had to be in a file.
06:44:36 <resiak> it would be nice to not need 'let' to define new functions in ghci
06:44:37 <shapr`> Ah, that.
06:44:44 <resiak> if it looks like a definition, then it is one
06:44:47 <resiak> otherwise, try to evaluate it
06:44:58 <shapr`> resiak: I had success writing all my code in emacs and hitting C-c C-l to dump the code into ghci
06:44:58 <roconnor> dcoutts: Do we know how many common encodings are not an extension of ASCII (or ISO-646?)
06:45:03 <roconnor> @seen dcoutts
06:45:03 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 48m 8s ago.
06:45:22 <resiak> shapr`: that would involve learning emacs first :)
06:45:23 <mightybyte> I think beginners expect to be able to do the same things in the interpreter that they do in a file.
06:45:27 <shapr`> resiak: Ah, true
06:45:39 <shapr`> resiak: You could also edit and save the file and use :r in ghci
06:45:47 <resiak> right, that's what i do
06:45:55 <shapr`> That is sort of manual though.
06:50:10 <Cale> I really want a mathematica-style notebook interface.
06:50:52 * quicksilver isn't sure what that means but it sounds sexy.
06:52:19 <roconnor> Chars are Unicode; Haskell defines operations to read and write characters from and to files; hSeek hdl mode i sets the position of handle hdl; The offset is given in terms of 8-bit bytes == WTF?
06:54:31 <taruti> roconnor: the IO-library deals only with 8-bit chars.
06:54:33 <smg> quicksilver: :i (->)
06:54:39 <smg> parse error
06:55:57 <byorgey> Cale: that would be totally sweet.  I wonder how difficult that would be to implement with ghci as a backend?
06:56:08 <Cale> So the basic idea is you'd have a document broken up vertically into cells. Cells could be either declaration cells, expression cells, or text cells. Committing a declaration cell would simply add those declarations to the context. Committing an expression cell would cause it to evaluate and create a new linked output cell beneath it.
06:56:41 <Cale> byorgey: The thing which I fear the most is creating the custom text widget :)
06:56:49 <byorgey> Cale: hehe, yeah =)
06:57:09 <byorgey> Cale: you should send an RFP to haskell-cafe. ;)
06:57:50 <shapr`> Cale: Good idea!
06:57:58 <Cale> Once you have that basic interface, you could create a bunch of datatypes for represeinting graphics and controls and dynamic stuff, which the frontend would automatically interpret by default.
06:58:15 <shapr`> Cale: Yeah, describe it on -cafe, maybe someone will hack up a prototype.
06:58:16 <Cale> representing*
06:58:16 <quicksilver> smg: that's odd. I don't understand.
06:58:37 <smg> ghci 6.6.1 btw
06:58:47 <quicksilver> smg: maybe you need some flags to make this work, or maybe it's 6.8 only.
06:58:48 <Cale> Prelude> :i (->)
06:58:48 <Cale> data (->) a b   -- Defined in GHC.Prim
06:58:57 <Cale> It doesn't say much anyway
06:59:00 <smg> maybe -glasgow-exts
06:59:08 <shepheb> Cale: that does sound great. it would be awesome for testing, you'd have some testing expressions written, reload a new version, hit the reevaluate-all key combination or button...
06:59:14 <smg> what should :i be implementation?
06:59:19 <Cale> smg: info
06:59:23 <shapr`> Maybe a web widget for Yi?
06:59:25 <quicksilver> roconnor: yeah, bit of an abstraction leak, certainly.
06:59:26 <smg> ah
06:59:30 <quicksilver> roconnor: not the only one :)
06:59:59 <Cale> shepheb: You could even implement dynamic cells which keep their values updated.
07:00:41 <quicksilver> Cale: yes, that does sound nice.
07:00:46 <roconnor> quicksilver: If we do end up with UTF-8 IO, I guess we can consider hSeek as a function that should never be used.
07:00:55 <shepheb> Cale: hmm. if the dynamic cells could depend on each other, doesn't that produce exponential cascading reevaluation? although I guess that works out okay for spreadsheets.
07:01:07 <quicksilver> :t hTell
07:01:09 <lambdabot> Not in scope: `hTell'
07:01:17 <quicksilver> :t System.IO.hTell
07:01:17 <Cale> shepheb: Well, the dynamically updated cells are just evaluating expressions.
07:01:18 <lambdabot> GHC.IOBase.Handle -> IO Integer
07:01:31 <quicksilver> roconnor: it could be safe to use it with a number you previously saved using 'hTell'
07:01:37 <shepheb> spreadsheet with ghci evaluation... cells depend on each other. I think that's a similar idea
07:01:41 <quicksilver> roconnor: and it would, of course, be safe on openBinaryFiles
07:01:45 <smg> btw
07:01:49 <smg> how can i change a value in a list?
07:01:58 <roconnor> quicksilver: I don't see hTell in H98
07:02:04 <quicksilver> smg: you don't, you build a new list with the new value.
07:02:04 <smg> for example let's say i want to change in [1,2,3,4] number 3 to a 8 ?
07:02:13 <quicksilver> :t IO.hTell
07:02:13 <smg> damn
07:02:14 <lambdabot> Not in scope: `IO.hTell'
07:02:27 <quicksilver> roconnor: oh, well there you are :) I just assumed...
07:02:29 <roconnor> hGetPosn and hSetPosn are still good I think.
07:02:42 <roconnor> @type hGetPosn
07:02:42 <lambdabot> Not in scope: `hGetPosn'
07:02:48 <roconnor> @type IO.hGetPosn
07:02:49 <lambdabot> GHC.IOBase.Handle -> IO GHC.Handle.HandlePosn
07:02:52 <Cale> smg: Well, lists are immutable, so you build a new list whose entries are the same as the original except for the entry you want to change.
07:02:56 <roconnor> They return abstract HandlePosn
07:03:02 <roconnor> horray
07:03:23 <Cale> smg: Do you want to replace all instances of 3's with 8's, or do you want to replace the element at index 2 with an 8?
07:04:21 <smg> no wait
07:04:25 <smg> i will show you soon some source
07:05:10 <roconnor> How does printf and locals work in C?  Does the run-time system automatically translate from ascii to the local or something?
07:05:45 <integral> "locales"
07:05:55 <roconnor> locales
07:07:18 <sieni> roconnor: isn't printf just dumping the formatted output to stdout?
07:08:03 <roconnor> sieni: that's what I thought.
07:08:14 <Cale> I was unaware that there was any special support like that. I've never written a C program which cared about locales though.
07:08:58 <roconnor> Maybe I should ask, how does one, in C, output strings encoded in the locale of the system?
07:09:43 <quicksilver> if you're using printf directly, then you are sending bytes.
07:10:00 <quicksilver> however, other system functions which, e.g., format error messages
07:10:06 <quicksilver> pay attention to the current locale
07:11:11 <roconnor> quicksilver: so printf is for binary IO? :)
07:11:26 <quicksilver> printf also has a "%S" specifier for wide chars (which get re-encoded according ot locale)
07:11:31 <c07th> @seen dcoutts
07:11:31 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1h 14m 36s ago.
07:12:15 <quicksilver> then there is fputws which puts a 'wide character string'
07:12:26 <quicksilver> encoded by locale, AFAIK.
07:12:27 <daniel_larsson> and wprintf
07:12:41 <roconnor> quicksilver: is a wide character a utf-16 character?
07:12:45 <quicksilver> no
07:12:54 <quicksilver> a wide character is typically UCS32
07:12:55 <roconnor> is it a pair of bytes?
07:13:01 <quicksilver> it may be technically abstract?
07:13:30 <roconnor> so an wide char is a unicode character?
07:13:34 <Zao> Sample points are that wchar_t is 32-bit on linux and 16-bit on Windows.
07:13:36 <quicksilver> yes, it is technically abstract.
07:13:44 <roconnor> right
07:13:47 <quicksilver> "The ISO C90 standard, where wchar_t was introduced, does not say anything specific about the representation"
07:13:54 <quicksilver> so it's analogous to Char
07:14:17 <quicksilver> Zao: well, under the GNU toolchain it's 32 bit even under windows.
07:14:21 <roconnor> So the runtime uses the locale to translate it to bytes for output.
07:14:33 <quicksilver> Zao: GHC uses the GNU wchar_t, even when compiled for windows, for example. I believe.
07:14:35 <Zao> quicksilver: That's not really Windows then :)
07:14:44 <roconnor> and presumably does things like place '?' on characters that are not in the locale?
07:14:48 <quicksilver> and all the better for it ;)
07:14:52 <quicksilver> roconnor: yes.
07:15:03 <quicksilver> roconnor: or the old 'square box' symbol.
07:15:07 <roconnor> quicksilver: thanks
07:15:39 <Zao> quicksilver: Considering that things get unhappy when you try sticking surrogates into a Windows wchar_t, yes.
07:22:07 <smg> quicksilver: i have a list
07:22:17 <smg> and i need to set all values to value x
07:22:20 <smg> example:
07:22:24 <smg> [1,2,3,4,5,6,7,8,9,10]
07:22:33 <quicksilver> smg: "set" is meaningless in haskell.
07:22:34 <smg> i need to set 4,6,8,10 to 2
07:22:38 <quicksilver> smg: there is no "set"
07:22:42 <smg> yeah okay
07:22:47 <smg> you know what i mean?
07:22:48 <quicksilver> smg: please erase your brain and think again :)
07:22:50 * quicksilver nods
07:22:53 <smg> k
07:22:56 <smg> i will try again
07:23:07 <smg> don't answer the question i try on my own first :)
07:23:13 <quicksilver> if you're doing major munging inside a list like that
07:23:23 <quicksilver> than you may find Data.Sequence a lot more convenient.
07:23:39 <quicksilver> It has primitives to do this kind of thing, and much better complexity / sharing characteristics
07:23:49 <osfameron> dammit!  no ubuntu package for xmonad?
07:24:50 <skorpan> hey guys and gals
07:25:04 <skorpan> is there some package for haskell which is used for parsing command line arguments?
07:25:06 <Gilly> Hm, how can i force ghci to interpret some piece of code instead of loading the compiled version?
07:25:18 <dolio> GetOpt.
07:25:28 <skorpan> thanks
07:26:03 <dolio> System.Console.GetOpt is the module, it seems.
07:27:27 <ari> Gilly: I usually just touch the source file and reload, I don't know if there's an easier way to do it from ghci
07:28:07 <Gilly> ari: ok
07:28:13 <Gilly> thanks
07:31:10 <smg> erm
07:31:13 <smg> i can't use that?
07:31:24 <smg> map (\(a,b) -> if a `mod` b then a else b ?
07:32:02 <dino-> I just installed ghc 6.8.2 generic Linux binary. One thing that's different is that runhaskell was in /usr/bin and is now in /usr/local/bin (I left the default installation dir alone)...
07:32:25 <dino-> Is there a smarter way for me to deal with this than changing the hard-coded #! lines in my Haskell scripts?
07:32:43 <dino-> This is probably really a *nix question.
07:33:19 <gnuvince> dino-: #!/usr/bin/env runhaskell maybe?
07:33:21 <radix> dino-: many recommend "#!/usr/bin/env runhaskell"
07:33:52 <dino-> Ah, I had this vague memory of something that I couldn't remember and that's it, env
07:33:52 <Deewiant> smg: that doesn't work since a `mod` b isn't a boolean
07:34:02 <tuukkah> other than that, you can probably replace /usr/bin/runhaskell with a symlink to /usr/local/bin/runhaskell?
07:34:03 <smg> i found out
07:34:20 <byorgey> a `mod` b == 0  ?
07:34:36 <Deewiant> > map (\a -> if a `mod` 2 == 0 then 2 else a) [1..10]
07:34:39 <lambdabot>  [1,2,3,2,5,2,7,2,9,2]
07:36:38 <dino-> gnuvince, radix: Thank you.
07:39:34 <ivan__> hi, i need some suggestion on a 60-90 h project in haskell =) ?
07:40:22 <dbpatterson> ivan__: understand monads/arrows :P
07:40:50 <ivan__> monads am i getting it has to include som monads but what is the project topic =)
07:41:40 <ivan__> is it hard to create a video program and detect movments in the picture?
07:44:55 <byorgey> ivan__: well, any largeish project will probably involve monads anyway =)
07:48:04 <ivan__> yes of curse, =) but do you know if the sdl lib has support for movie rendering and stuff like that?
07:48:50 <Lemmih> SDL is very low-level.
07:49:04 <qebab> hence the D, for direct :)
07:49:07 <ivan__> hmmm other libs in haskell for video?
07:49:43 <shapr`> I think there's some dirac source running around, and some mpeg something, but I forget which layer.
07:50:03 <shapr`> iirc, the guy who did most of the dirac codec design used Haskell to prototype it.
07:50:28 <Lemmih> I've seen SDL+ffmpeg, I think.
07:50:31 <shapr`> But I'm away from my Haskell vault, I can't lookup anything right now.
07:51:13 <MyCatVerbs> I'd presume the best thing to do would be to create bindings (using hsc or something, perhaps) to libavformat and libavcodec (both part of the ffmpeg project), then use SDL or whatever for output.
07:51:47 <hallongrottan> is there a way to get rid of the function on >>=?
07:51:53 <ivan__> hmm maybe it would be nicer to write an divx codec =)?
07:52:00 <hallongrottan> like xs >>= f = something that havent got to do with f
07:52:01 <MyCatVerbs> But honestly, if I were going to do that (and I have had reason to think of doing so), I'd do it in C, then have that program take instructions from a Haskell program running the UI.
07:52:19 <MyCatVerbs> hallongrottan: xs >> f -- you mean this?
07:52:25 <shapr> hallongrottan: kanske en monad tutorial ska hjalpa?
07:52:42 <skorpan> hallongrottan: hender
07:53:03 <hallongrottan> shapr: kanske d
07:53:04 <hallongrottan> halo skorpan
07:53:12 <skorpan> hallongrottan: f >>= return = f, no?
07:53:21 <hallongrottan> hmm
07:53:24 <hallongrottan> iofs
07:53:34 <skorpan> i'm not sure, as i'm quite the newbie at this
07:54:01 <hallongrottan> skorpan: what are you talking about
07:54:04 <shapr> Wait, iaf is "i alla fall" what's iofs?
07:54:11 <skorpan> shapr: "i och fГ¶r sig"
07:54:12 <hallongrottan> shapr: i och fГ¶r sig
07:54:18 <hallongrottan> lol
07:54:40 <hallongrottan> skorpan: you know when we encounter an ask we would like the program to stop
07:54:46 <hallongrottan> that is, don't bind any further
07:54:55 <shapr> an ask == en fraaga?
07:54:58 <skorpan> ivan__ should know the answer to this one
07:55:02 <hallongrottan> lol
07:55:05 <ivan__> hallongrottan: do u use a own datastructure?
07:55:07 <skorpan> shapr: it's a lab
07:55:12 <hallongrottan> ivan__: yes, a data Replay
07:55:23 <ivan__> then you have a Fail right?
07:55:27 <shapr> skorpan: Still doesn't help me understand the question though :-)
07:55:28 <hallongrottan> aha
07:55:30 <hallongrottan> no
07:55:32 <hallongrottan> we dont lol
07:55:44 <hallongrottan> hmm
07:55:46 <skorpan> shapr: doesn't matter, we're three on this now! :)
07:55:53 <hallongrottan> >:t fail
07:55:56 <hallongrottan> bah
07:55:56 <ivan__> just insert a Fail into the datatype and return the FAIL
07:56:02 <hallongrottan> aha
07:56:05 <hallongrottan> well
07:56:08 <hallongrottan> that won't work
07:56:11 <hallongrottan> we dont know the type of f
07:56:21 <skorpan> pattern matching?
07:56:30 <hallongrottan> ivan__: check :t (>>=)
07:56:33 <ivan__> dosnt matter, return Fail
07:56:39 <hallongrottan> f is a function from a -> b
07:56:57 <ivan__> f is a -> mb
07:57:04 <hallongrottan> yeah
07:57:12 <skorpan> hallongrottan: i'm thinking about writing an irc bot for my project, what do you think?
07:57:15 <hallongrottan> lol
07:57:20 <ivan__> and Fail is m b
07:57:21 <hallongrottan> i've done one already
07:57:26 <hallongrottan> ivan__: is it?
07:57:32 <hallongrottan> skorpan: ulf does not approve of that
07:57:38 <skorpan> hallongrottan: why not?
07:57:39 <ivan__> yes if you have it in your data type
07:57:41 <hallongrottan> skorpan: Smurfen asked him
07:57:45 <hallongrottan> hmm
07:57:51 <skorpan> that fool!
07:57:54 <hallongrottan> skorpan: smurfen asked him about an irc client
07:58:03 <hallongrottan> and he was like "that doesnt sound very interesting to me"
07:58:04 <hallongrottan> lol
07:58:04 <skorpan> so why did he not approve of an irc client?
07:58:08 <hallongrottan> dunno
07:58:11 <hallongrottan> too easy perhaps
07:58:15 <skorpan> what an idiot
07:58:18 <skorpan> ulf, that is
07:59:50 <hallongrottan> lol
08:01:06 <MyCatVerbs> skorpan: there already are a couple of IRC bots in Haskell, I think there's at least one (that isn't lambdabot) on Hackage.
08:01:13 <hallongrottan> ivan__: i think we got it to work
08:01:21 <skorpan> MyCatVerbs: but we're discussing the IRC client here
08:01:24 <ivan__> nice
08:01:32 <ivan__> hallongrottan: Task 1?
08:01:37 <MyCatVerbs> skorpan: admittedly it is a pretty good familiarisation project, and it's more or... oh, right. My bad.
08:01:37 <hallongrottan> skorpan: btw irc bots are REALLY easy to write
08:01:42 <hallongrottan> ivan__: no just the fail lol
08:01:47 <ivan__> hehe okay
08:01:56 <hallongrottan> ivan__: dont we need to match on a Fail >>= f then?
08:02:15 <MyCatVerbs> skorpan: well, I guess you *could* steal half the code from one, assuming they've written a full RFC1459 parser instead of just using dirty hacks.
08:02:19 <hallongrottan> in the monad instance
08:02:28 <ivan__> hallongrottan: yes if you dont have an bind composition in your datatype you have to mach all of them i think
08:03:01 <ivan__> Fail >>= f = Fail
08:04:51 <hallongrottan> well yes
08:05:23 <hpaste>  moonlite pasted "(no title)" at http://hpaste.org/5918
08:05:25 * DQuest wonders how to extend this to Epic Fail, and then on to LolHaskell
08:05:51 <ivan__> hallongrottan: have u done the cgi part?
08:05:51 <smg> mh
08:06:05 <quicksilver> moonlite: you can't "ioError" an exception
08:06:11 <hallongrottan> ivan__: nooe
08:06:13 <hallongrottan> nope*
08:06:14 <quicksilver> moonlite: I think you want 'throw' there.
08:06:40 <quicksilver> moonlite: oh, that's not the only problem :)
08:07:31 <moonlite> :)
08:08:13 <shapr> DQuest: I was thinking the same thing.
08:08:22 <smg> someone has a recursive definition of sieve of eratothenes??
08:08:25 <moonlite> quicksilver: is it clear what i _want_ the code to do? :)
08:08:33 <DQuest> Ooooh, oooh, I do, I do!
08:08:34 <DQuest> Though not here
08:08:42 <DQuest> I could whip one up in 5 minutes if you're interested, though
08:08:51 <DQuest> Seeing as I'm in full blown procrastination mode today anyway
08:09:13 <quicksilver> moonlite: you need to use catchJust and ioErrors
08:09:21 <quicksilver> moonlite: see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
08:09:21 <lambdabot> http://tinyurl.com/sqmlj
08:09:21 <DQuest> haha, nevermind, I do have it
08:09:42 <quicksilver> moonlite: (the basic problem is you were confusing 'Exception' with 'IOError'; they are not the same type
08:09:56 <quicksilver> DQuest: is there a procastination monad?
08:10:02 <hpaste>  DQuest pasted "Sieve of eratosthenes" at http://hpaste.org/5919
08:11:18 <DQuest> quicksilver: I discovered it
08:11:18 * EvilTerran waits for someone to bring up "that's not the real sieve"
08:11:35 <EvilTerran> (or is it, just this once?)
08:12:21 <DQuest> I'm a little disturbed that upon typing "cd ~/tmp;emacs Primes.hs" I find that I've already done it
08:12:58 * DQuest was using it to do stuff on Project Euler, but it seems that divisors is far too slow
08:14:23 <DQuest> Of course, the recursive definition is just the first two functions there
08:15:48 <hpaste>  shepheb pasted "(no title)" at http://hpaste.org/5920
08:17:57 <smg> sieve of eeratothenes?
08:17:58 <smg> anyone?
08:18:25 <EvilTerran> what about it?
08:18:26 <shepheb> one of the PE solutions has one, not sure which number.
08:18:36 <smg> someone can help me?
08:18:43 <smg> i can't write it in haskell -.-
08:18:52 <EvilTerran> smg, someone pasted a primes sieve a few minutes ago
08:19:19 <EvilTerran> it may or may not be the true eratothsenes one, mind, but it's likely close enough
08:19:45 <DQuest> smg: seriously, I just pasted one :P
08:20:17 <DQuest> EvilTerran: erk, have I made an error?
08:20:54 <DQuest> I mean, strictly speaking you sieve by picking a maximum number and then going through every prime marking its multiples as not prime
08:20:57 <dbpatterson> DQuest: I havent done the sieve in ages, but it looks okay
08:21:16 <moonlite> quicksilver: i really don't understand. i tried introducing catchIO = catchJust ioErrors but then i still get an IOError instead of an IOErrorType
08:21:19 <DQuest> But I reckon this way is close enough :P
08:21:26 <smg> DQuest: where is it? :D
08:21:27 <EvilTerran> DQuest, no, i'm sure it's fine. thing is, i forget where i saw it, but i've seen an analysis of the usual haskell prime sieves that determined that they were not True Seives of Eratothsenes
08:21:33 <EvilTerran> http://haskell.org/haskellwiki/Prime_numbers <- here's some prime sieves
08:21:34 <moonlite> how do i extract the IOErrorType?
08:21:35 <DQuest> Ah right
08:21:38 <EvilTerran> smg, try scrolling up a bit?
08:22:01 <DQuest> I've not seen other people do it, so mine is probably quite naive
08:22:08 <smg> ah i see
08:22:45 <smg> haha DQuest
08:24:51 <DQuest> smg: what?
08:25:06 <smg> a bit more complex than i thought
08:25:11 <DQuest> ah
08:25:14 <byorgey> \window grow 20
08:25:19 <DQuest> well, you only need to pay attention to primes, isprime and divides
08:25:21 <byorgey> oops, sorry =P
08:26:04 <DQuest> primes is a list of 2 followed by 3 followed by any number from 4 onwards which is prime
08:26:05 <dcoutts_> sioraiocht: ping
08:26:22 <DQuest> and a number is prime if you can go through the list of primes as far as its square root and not find a number which divides it
08:26:57 <DQuest> So you find that 4 is divisible by sqrt(4)=2 and isn't prime, etcetera
08:27:11 <EvilTerran> DQuest, or even "a maximal ordered list of positive naturals starting with 2, where each number is not divisible by any previous number in the list"
08:27:18 <DQuest> Kind of like a primes version of that classic lazy fibbonacci sequence
08:27:34 <smg> DQuest: my implementation really sucks
08:27:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5921
08:27:46 <DQuest> fibs = 0 : 1 : zipWith (+) fibs (take 1 fibs)
08:28:23 <DQuest> oops!
08:28:27 <DQuest> fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs)
08:28:53 <EvilTerran> which is precisely what the first version on the wiki page means
08:29:10 <DQuest> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in take 10 fibs
08:29:12 <EvilTerran> you can just use tail instead of drop 1 there, as the list has no end...
08:29:20 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
08:29:23 <hpaste>  (anonymous) pasted "non working sieve" at http://hpaste.org/5922
08:29:30 <smg> DQuest: http://hpaste.org/5922
08:29:43 <DQuest> EvilTerran: ah, so mine will be rather inefficient
08:29:56 <faxathisia> > nubBy(((>1).).gcd)[2..]
08:29:57 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
08:30:21 <smg> wow
08:30:23 <smg> nubBy?
08:30:37 <smg> i don't have that :)
08:30:42 <Cale> It's in Data.List
08:30:46 <smg> k
08:30:59 <DQuest> Oh wait, the first one in that list is way worse than mine, it layers filter upon filter
08:31:03 <Cale> It takes a predicate for deciding when two elements are duplicates and sieves the list to remove them.
08:31:18 <DQuest> faxathisia: I may as well kill myself now :P
08:31:32 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
08:31:33 <EvilTerran> > nubBy (((==0) .) . flip mod) [2..]
08:31:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
08:31:40 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
08:31:53 <EvilTerran> DQuest, don't worry, fax's one is shockingly inefficien
08:31:54 <smg> interesting
08:32:00 <Cale> That version, aside from being slightly more efficient, is perhaps easier to understand.
08:32:09 <desegnis> Just a general question... Are there any rumours about Haskell projects considering to apply for this year's Google SOC?
08:32:10 <Cale> (It's still really inefficient though)
08:32:18 <EvilTerran> mine/Cale's is slightly better, but still not terribly good - and equivalent to the one at the top of the wiki pag
08:32:32 <matthew-_> desegnis: if there aren't, we could always start some
08:32:33 <Cale> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
08:32:53 <Cale> btw, that paper has a good implementation of the real sieve of Eratosthenes, rather than this fake one.
08:33:14 <shapr> Yay Haskell golf!
08:33:16 <desegnis> matthew-_, heh, I'd be especially interested in rumours that turn out to be true
08:33:22 <EvilTerran> dah, just beaten to the punch
08:33:25 <opqdonut> let primesA n = let m = floor (sqrt$fromIntegral n) in array (2,n) $ (zip [2..n] $ repeat True) ++ concatMap (\x -> zip [2*x,3*x..n] $ repeat False) [2..m] in filter (id.snd) $ elems $ primesA 102
08:33:27 <EvilTerran> ?karma+ Cale
08:33:27 <lambdabot> Cale's karma raised to 65.
08:33:30 <opqdonut> > let primesA n = let m = floor (sqrt$fromIntegral n) in array (2,n) $ (zip [2..n] $ repeat True) ++ concatMap (\x -> zip [2*x,3*x..n] $ repeat False) [2..m] in filter (id.snd) $ elems $ primesA 102
08:33:33 <lambdabot>  Couldn't match expected type `(a, Bool)'
08:33:35 <EvilTerran> i had it on my clipboard and everything =/
08:33:44 <opqdonut> > let primesA n = let m = floor (sqrt$fromIntegral n) in array (2,n) $ (zip [2..n] $ repeat True) ++ concatMap (\x -> zip [2*x,3*x..n] $ repeat False) [2..m] in primesA 20
08:33:45 <lambdabot>  array (2,20) [(2,True),(3,True),(4,False),(5,True),(6,False),(7,True),(8,Fal...
08:33:53 <quicksilver> desegnis: I think both potential students and potential mentors are welcome to suggest project ideas
08:33:58 <Cale> EvilTerran: So did I, I had actually just linked someone else to it, not 5 minutes ago.
08:34:03 <mnislaih> what is the simplest example of a Haskell program that loops in constant space
08:34:16 <Cale> mnislaih: let loop = loop in loop
08:34:17 <EvilTerran> > fix id
08:34:18 <lambdabot>  Exception: <<loop>>
08:34:26 <Cale> Or yes, fix id, which is equivalent.
08:34:29 <EvilTerran> except ghc detects it and stops you
08:34:29 <opqdonut> that doesn't loop, it get's suspended, right?
08:34:37 <quicksilver> desegnis: (as are people who are not in fact going to be involved at all, but just have interesting ideas)
08:34:38 <opqdonut> yeah
08:34:40 <EvilTerran> that's an implementation detail
08:34:53 <Cale> opqdonut: It loops, but the loop is simple enough that GHC's black hole mechanism detects the loop and kills it.
08:34:56 <mnislaih> and in constant stack space :)
08:34:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5923
08:35:08 <Cale> mnislaih: That is constant stack space.
08:35:14 <quicksilver> main = putStrLn "yes" >> main
08:35:17 <EvilTerran> mnislaih, "stack space" is a bit funny under lazy evaluation
08:35:20 <mnislaih> and that does not blackhole
08:35:22 <Cale> mnislaih: It's tail recursive.
08:35:25 <quicksilver> is also still simple, but does something.
08:35:32 <desegnis> quicksilver, point taken. I suppose I can talk any Haskell project into applying anyway :)
08:35:35 <shapr> haskell.org has been a single SoC project the last two years, is the issue whether separate Haskell apps may apply as their own projects?
08:35:39 <EvilTerran> mnislaih, whether or not it blackholes is an implementation detail
08:35:42 <quicksilver> and is constant space despite not being tail recursive :)
08:35:46 <Cale> Which things are caught by black holes are hard to tell.
08:35:50 <EvilTerran> if you use hugs, there's no blackhole detection
08:35:56 <EvilTerran> ?index forever
08:35:56 <lambdabot> bzzt
08:35:57 <mnislaih> EvilTerran: I just need a test for ghci
08:36:17 <mnislaih> I want to see if :trace leaks memory
08:36:29 <desegnis> shapr, ah, so there was one haskell.org project incorporating anything Haskell-related?
08:36:30 <EvilTerran> > main = forever (const $ return ())
08:36:30 <lambdabot>  Parse error at "=" (column 6)
08:36:36 <Cale> You could try something like  let loop 0 = 0; loop n = loop (n+1) in loop 1
08:36:37 * matthew-_ sends in an application to SoC08 for adding Closed Type Classes to ghc in the hope that it may come true
08:36:44 <DQuest> well, what about [1..]?
08:36:52 <Cale> Though, that uses up more and more space :)
08:36:56 <DQuest> That loops :P
08:36:58 <quicksilver> shapr, desegnis: I think haskell.org is "one mentoring project" but it can contain multiple summer of code projects.
08:37:03 <Cale> (but logarithmic)
08:37:07 <Cale> Or else...
08:37:09 <DQuest> ah, constant space, yes
08:37:09 <quicksilver> I.e. the noun 'project' is overloaded.
08:37:09 <desegnis> quicksilver, ok
08:37:22 <EvilTerran> mnislaih, try "forever (return ()) :: IO ()"
08:37:28 <Cale> let loop 0 = loop 1; loop 1 = loop 0 in loop 0
08:37:31 <desegnis> matthew-_, yourself going to be the mentor or the student?
08:37:32 <Cale> There we go
08:37:36 <mnislaih> EvilTerran: I'm on it
08:37:37 <DQuest> Hrm, where do you get "fix" from?
08:37:42 <EvilTerran> you can ommit the ::IO() at the prompt
08:37:48 <EvilTerran> (or if it's main)
08:37:48 <mnislaih> Cale: sounds good too
08:37:57 <Cale> Constant space, constant stack, loops forever, and the black hole mechanism doesn't appear to catch it.
08:38:06 <Cale> > let loop 0 = loop 1; loop 1 = loop 0 in loop 0
08:38:07 <lambdabot>  Exception: <<loop>>
08:38:14 <Cale> damn, it does in lambdabot though
08:38:19 <EvilTerran> i believe, owing to monad-ness, that should be impervious to all blackhole detection
08:38:27 <EvilTerran> ?type forever (const ())
08:38:27 <lambdabot> forall b. b -> ()
08:38:32 <EvilTerran> ?type forever (return ()) -- ahem
08:38:33 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
08:38:44 <EvilTerran> > forever (return ()) :: [()]
08:38:46 <lambdabot>  Exception: stack overflow
08:38:49 <EvilTerran> hm.
08:38:55 * desegnis fears that all _interesting_ project ideas would be too high for me
08:39:02 <mnislaih> yeah, it's more tricky than it seems
08:39:08 <DQuest> let y = (\f -> (\x -> f x x) (\x -> f x x)) in y (\f x -> if x == 1 then 1 else x * f(x-1))
08:39:09 <EvilTerran> > forever (return ()) :: Maybe ()
08:39:14 * mnislaih cannot make ghc loop in constant space 
08:39:14 <lambdabot> Terminated
08:39:24 <EvilTerran> it works in IO, anyway, if not in [] for whatever reason
08:39:27 <matthew-_> desegnis: neither!
08:39:28 <EvilTerran> thunk build-up or something
08:39:29 <Cale> The trouble is that if it's constant space, you eventually end up calling yourself with the same args.
08:39:37 <DQuest> And a prize for anyone who gets "y" to typecheck there :P
08:39:46 <Cale> and so the black holer catches it (ideally)
08:39:50 * EvilTerran busts out the typeclass-fu
08:40:03 <matthew-_> desegnis: it's just I *always* moan about that one. And I think it would be very useful to folks other than myself
08:40:22 <EvilTerran> DQuest, fix is in Control.Monad.Fix
08:40:24 <EvilTerran> ?src fix
08:40:25 <lambdabot> fix f = let x = f x in x
08:40:33 <EvilTerran> ?src forever
08:40:33 <lambdabot> Source not found. My brain just exploded
08:40:40 <desegnis> matthew-_, you got a web reference about what closed type classes are?
08:40:46 <Cale> DQuest: That y-combinator isn't typeable in STLC.
08:40:47 <DQuest> surely fix f = f fix f?
08:40:56 * DQuest grins, I know
08:40:56 <EvilTerran> forever x = x >> forever x
08:40:57 <tack-work> fix f = f (fix f)
08:41:07 <Cale> DQuest: That's slightly less efficient than the version using let
08:41:08 <EvilTerran> DQuest, yes, but the let version has better sharing
08:41:09 <tack-work> (you need those parens)
08:41:12 <DQuest> aha
08:41:20 <DQuest> tack-work: good point
08:41:25 <EvilTerran> with the let version, fix (1:) only ever makes one list cell
08:41:36 <EvilTerran> (under all current implementations, anyway)
08:41:40 <tack-work> > fix (1:)
08:41:41 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:41:46 <matthew-_> desegnis: err, there's something on haskell' about it iirc.
08:41:49 <Cale> You can get the usual y-combinator to type if you use some newtype declarations though.
08:42:09 <DQuest> Cale: I understand that if you can typecheck fix in the typed lambda calculus, it's broken
08:42:13 <Cale> But GHC used to choke on the type decls needed to do it (not sure if that's fixed or not, it was a long time ago)
08:42:24 <matthew-_> desegnis: http://hackage.haskell.org/trac/haskell-prime/wiki/ClosedClasses
08:42:27 <lambdabot> Title: ClosedClasses - Haskell Prime - Trac
08:42:35 <Cale> DQuest: We have recursive types.
08:42:46 <DQuest> Ah, good point
08:42:46 <EvilTerran> newtype Fn = Fn { (?) :: Fn -> Fn } -- is all you need
08:42:54 <desegnis> matthew-_, great, thanks
08:42:58 <DQuest> My Types-fu is still weak
08:43:11 <matthew-_> desegnis: basically, you limit the scope in which you can declare instances of any given class. That gives the type checker a lot more information and it can make smarter decisions
08:43:34 * DQuest is doing a course called Types and Programming Languages, which I think is brilliant but just about everyone else skips
08:44:10 <EvilTerran> DQuest, ooh, do you use the book TaPL?
08:44:17 * shepheb starts a betting pool on the 10000th hpaste
08:44:36 <EvilTerran> "desu"
08:44:46 <desegnis> matthew-_, oh, so the concept itself is as easy as the term sounds. actually I've sometimes wondered whether it should be possible to explicitly import/export instance declarations
08:45:46 <desegnis> matthew-_, never mind, I just realized that the second part of the proposal comes close to that
08:45:52 <DQuest> EvilTerran: we do
08:46:10 * mux cherishes this book
08:46:10 <matthew-_> desegnis: well the problem I usually hit is that the type checker goes "there may be other instances out side of the current scope which could interfere here, so I can't safely infer what you want me to infer"
08:46:34 <DQuest> I swear I'm going to have to find extra space to store all the textbooks that I've bought and want to keep forever
08:47:53 <desegnis> I see
08:48:11 <DQuest> EvilTerran: are you a fan?
08:48:30 <EvilTerran> i am, yes. i read it for our class in programming language theory
08:49:03 <DQuest> aah
08:49:30 <DQuest> Is that as a part of your undergraduate course, or are you now teaching one?
08:50:13 <EvilTerran> undergrad course
08:50:33 <DQuest> ah, cool
08:50:33 <EvilTerran> i'm not in research yet ;)
08:50:39 <DQuest> heh, me neither
08:51:04 <DQuest> It seems like a lot of FP people are in Britain, which is handy
08:51:07 <od> are there any library functions optimized for copying binary data from one file handle to another
08:51:27 <DQuest> vmsplice()?
08:51:27 <shepheb> I've been curious for a while about the distribution of Haskellers around the globe.
08:51:35 <byorgey> heh, I just legitimately used a list of pairs of lists of pairs. =)
08:52:01 <byorgey> shepheb: there's a map somewhere...
08:52:25 <byorgey> http://haskell.org/haskellwiki/Haskell_user_locations
08:52:27 <od> zero copy would be nice but anything is fine
08:52:33 <mnislaih> unfortunately GHCi does not know what "constant heap space" is
08:52:36 <byorgey> also http://www.frappr.com/haskellers
08:52:39 <MyCatVerbs> DQuest: FP fanboys, too.
08:53:00 <DQuest> MyCatVerbs: who in particular? :P
08:53:08 <mnislaih> EvilTerran your example works fine in compiled code but in GHCi runs out of heap quickly
08:53:45 <shepheb> byorgey: ah, okay, I'll add myself when I get home. for inscrutable reasons Google Maps is blocked here.
08:54:04 <MyCatVerbs> DQuest: I was referring to myself. ^_^
08:54:05 <EvilTerran> mnislaih, what, forever (return ())? it works in ghci for me
08:54:20 <DQuest> A quick scan of /who suggests lots of Americans and lots of Scandanavians
08:54:31 <byorgey> shepheb: oh, boo.
08:54:41 <mnislaih> EvilTerran: does it work in constant space?
08:54:41 <DQuest> MyCatVerbs: Excellent :)
08:54:54 <mnislaih> I tried with 6.8.2 and 6.6.1
08:55:24 <mnislaih> oh, of course. Define forever locally
08:55:33 <mnislaih> it doesn't count if you use the precompiled one in Control.Monad
08:55:46 <MyCatVerbs> mnislaih: forever = fixIO?
08:56:00 <mnislaih> forever acc = acc >> forever acc
08:56:03 <MyCatVerbs> mnislaih: or \action -> foldr (>>) (repeat action) ?
08:56:28 <EvilTerran> mnislaih, it seems to
08:56:32 <mnislaih> that should be equivalent
08:56:42 <MyCatVerbs> \action -> fixIO (const action) -- wheeee
08:56:44 <EvilTerran> but yes, i used the Control.Monad one
08:57:53 <EvilTerran> mnislaih, it seems your goalposts are very mobile
08:58:49 <EvilTerran> ghci doesn't do any optimisations on interpreted code, so it's not surprising that most deep recursions that're fancy enough to get around the blackhole detector will blow the stack
08:59:13 <DQuest> I think MS research cambridge (the real Cambridge) only takes PhDs, mind
09:00:12 <EvilTerran> i'm currently planning in staying at ox.ac.uk for my PhD
09:00:15 <MyCatVerbs> DQuest: suddenly I'm interested in postgrad courses. ;)
09:00:24 <dolio> I thought SPJ didn't have a PhD.
09:00:38 <DQuest> ah
09:00:42 <DQuest> Likewise here for ed.ac.uk
09:00:45 <MyCatVerbs> He's published enough research for three or four easily.
09:00:55 <dolio> Heh, true. :)
09:01:10 <EvilTerran> although i might decide to shuffle somewhere quieter by then. I really like york and warwick's settings.
09:01:20 <DQuest> Nottingham has apparently got some good people too
09:01:40 <quicksilver> I doubt somewhere like MSR would have an absolute requirement for a particular piece of paper
09:01:57 <quicksilver> however I'm sure they expect 99% of their applicants to have a phd or similar
09:02:19 <EvilTerran> i didn't really like the town, last i was there. it'd be nice to stay at a campus outside the city once i'm forced to abandon my reckless undergrad lifestyle
09:02:22 <EvilTerran> ;)
09:02:37 <DQuest> what, Edinburgh?
09:02:40 <DQuest> This place is brilliant!
09:02:41 <EvilTerran> nottingham
09:02:44 <DQuest> I'd go mad at a campus
09:02:49 <DQuest> ah, yeah, Nottingham is a hole
09:03:08 <matthew-_> oi! I lived for 10 years in Nottingham
09:03:09 <quicksilver> I'm surprised you think that.
09:03:18 <quicksilver> I think Nottingham is rather nice.
09:03:21 <quicksilver> IME, most people do.
09:03:26 <matthew-_> it's not quite as violent as everyone thinks
09:03:34 <glguy> that's not a good sign
09:03:36 <quicksilver> Coventry (the location of warwick university) : now that's a hole :)
09:03:40 <DQuest> Good point
09:03:41 <matthew-_> indeed
09:03:42 <glguy> (need to qualify violence level)
09:03:52 <DQuest> In fairness, I only saw Nottingham once and on a very very bad day
09:04:00 <EvilTerran> i can see the appeal of nottingham for others, but i don't really think it's for me
09:04:02 <matthew-_> well, warwick uni is a fair way outside of coventry
09:04:03 <glguy> quicksilver: did you see the last revision of the python binding use I posted
09:04:05 <DQuest> and I had a hell of a job getting to the university, that rather coloured my view of the place :P
09:04:18 <glguy> the foreignptrs were all added so no explicit pydecref
09:04:36 <EvilTerran> as i said, i wouldn't mind retiring to the country, as it were, to do research
09:04:38 <quicksilver> glguy: no, I didn't, but that sounds much nicer.
09:04:40 <matthew-_> DQuest: going from nottingham train station (which is horrible) to nottingham uni goes through some of the ugliest parts of nottingham. it's rather fortunate
09:04:44 <matthew-_> *unfortunate
09:04:51 <DQuest> Ok, Nottingham isn't quite as epically brilliant as Edinburgh :P
09:05:07 <matthew-_> Edinburgh's more expensive though
09:05:14 <DQuest> too true
09:05:15 <matthew-_> (he says, living in London)
09:05:27 <EvilTerran> i really like oxford at the moment, but i might be sick of it by the time my four years of undergradding are up
09:05:38 <DQuest> matthew-_: that would explain a lot of it
09:06:15 <DQuest> Also the university itself suggested that the best way to get there was via a bus that didn't stop at the bus station but rather in a street nobody had heard of and took an hour to get there
09:06:21 <EvilTerran> the parallel universe that is the oxford bubble might get dull after a while
09:06:36 <DQuest> Although I ended up getting a sensible bus, it was a bit annoying that they weren't capable of giving me sensible directions either
09:06:40 <matthew-_> DQuest: just get a taxi!
09:06:50 <DQuest> Pah, for an open day? No thankyou
09:06:57 <EvilTerran> matthew-_, ... he says, living in london. :P
09:07:18 <matthew-_> EvilTerran : touchГ©
09:07:27 <matthew-_> DQuest: have you applied to Imperial?
09:07:45 <matthew-_> because I *really* think you should... ;)
09:07:45 <DQuest> This was when I was looking around for undergraduate courses.
09:07:54 <matthew-_> ahh, past tense?
09:07:57 <DQuest> Do they have some good FPers?
09:08:04 <matthew-_> Me, ToRA...
09:08:05 <DQuest> Now I'm on the lookout for PhD places, t'is true
09:08:32 <DQuest> If I stay here they'll probably take me straight away, whereas if I want to go elsewhere I'll probably have to get an MSc first
09:08:32 <matthew-_> err, it's a bit thin on the staff side though...
09:08:44 <matthew-_> where's "here"?
09:08:50 <DQuest> Edinburgh, as stated earlier
09:09:00 <matthew-_> ahh, right yeah you're probably right
09:09:11 <matthew-_> you've done a 3 year or 4 year undergrad?
09:09:21 <DQuest> I'm on my 4th year
09:09:35 <matthew-_> so you're getting an MEng or MSci or something like that?
09:09:37 <DQuest> Having done some fairly heavy theory of programming language and compiler courses
09:09:46 <DQuest> Oooh no, this is a scottish university.  We just get BScs
09:10:12 <quicksilver> you ought to find some flexibilty from good departments, if you can get a strong reference.
09:10:18 <DQuest> Aye
09:10:23 <DQuest> I'd better do well in TPL then
09:10:28 <quicksilver> a four-year non-masters course sets you up well for a phd in many people's eyes.
09:10:36 <quicksilver> I only had a 4-year non-masters before my phd.
09:10:38 <matthew-_> Hmm. Well I think you're probably right anyway - certainly EPSRC/DTA funding here tends to be more likely to go to internal candidates simply because the dept has more knowledge of them
09:11:05 <DQuest> Ah, did you go to Scotland too?
09:11:46 <DQuest> Though I have to say, the number of *actual* scottish people on my course is fairly small
09:11:51 * EvilTerran is a glasgow native. really makes you appreciate other towns. :P
09:11:55 * MyCatVerbs vaguely gets the impression that doing a PhD (capitalization?) at the same university as one's undergrad course is vaguely... academically incestuous?
09:12:48 <qwrx> it's nice 'cause you know what you're getting
09:12:54 <MyCatVerbs> EvilTerran: HAH! Try Caerphilthy, in South Wales. (Properly Caerphilly, but the other name is more apt considering the general state of the place).
09:13:01 <MyCatVerbs> qwrx: this is true.
09:13:18 <tack-work> :t sequence
09:13:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:13:21 <EvilTerran> at least the weather'd be nicer in south wales
09:13:45 <matthew-_> MyCatVerbs: incestuous it may be. It's also a damn sight easier
09:14:06 <DQuest> Hey, at least it has cheese
09:14:13 <MyCatVerbs> EvilTerran: mmmmm, but not by a big enough margin to be worth putting up with the locals.
09:14:17 * EvilTerran has been on a camping trip in Pembrokeshire, and we had fantastic weather. especially compared to glasgow
09:14:35 <MyCatVerbs> DQuest: actually it doesn't. "Caerphilly" cheese is made in England somewhere, I can't remember where.
09:14:50 <matthew-_> MyCatVerbs: locals?
09:15:05 <DQuest> The fun thing about leaving Edinburgh will be that it'll be a pleasant surprise how windy everywhere else isn't
09:15:26 <MyCatVerbs> matthew-_: the people around South Wales are a bit... dire.
09:15:30 <EvilTerran> yeah, edi gets the wind, and ggow gets the drizzle, from what i hear
09:15:53 <DQuest> In that case, Glasgow must be having a fantastically sunny, warm, calm day
09:16:19 <MyCatVerbs> matthew-_: the whole pit-closures thing hit deeper and harder than one might suspect.
09:17:04 <MyCatVerbs> matthew-_: having about, oh, a whole generation or so of men made suddenly redundant kinda killed the work ethic for the next batch of kids.
09:17:17 <MyCatVerbs> Er, in, not for.
09:17:49 <matthew-_> yeah, well, I wasn't suggesting doing a PhD in Wales...
09:18:03 <DQuest> ... boyo
09:18:15 <qwrx> the choice between death by silicosis aged 35 and being unemployed in the valleys
09:18:17 <matthew-_> (or a PhD in Whales)
09:18:19 <qwrx> well, it's unenviable
09:19:59 <MyCatVerbs> matthew-_: weeeeeellll... Cardiff itself is better than the surrounding country by quite a large margin, and the university there is really, really good.
09:20:07 <Cale> !paste
09:20:08 <hpaste> Haskell paste bin: http://hpaste.org/
09:20:25 <hpaste>  Cale pasted "y combinator" at http://hpaste.org/5924
09:20:45 <quicksilver> DQuest: No. Cambridge.
09:21:03 <DQuest> Cale: Good grief
09:21:14 <quicksilver> I second the recommendation to go somewhere else for a second degree.
09:21:20 <quicksilver> For variety, on a variety of levels.
09:21:21 <MyCatVerbs> matthew-_: it wouldn't actually be my last choice for somewhere to go study - the reason it isn't my first is largely down to the fact that it's too close to home for me.
09:21:38 <Cale> DQuest: as you can see, it just requires some wrapping and unwrapping :)
09:21:52 <quicksilver> (Academic variety, social variety, geographic variety, climatic variety and gastronomic variety. In reverse order of importance :)
09:21:53 <DQuest> Mm.  Half the problem is I know a lot of PhD people here already, as well as locals and so on.  It'll be a lot more of an uprooting than if I just knew other people who were leaving
09:22:14 <quicksilver> You will probably remain in contact with the interesting people you already know.
09:22:21 <DQuest> Good point
09:22:25 <quicksilver> But you will mean more interesting people who you have not yet met.
09:22:25 <Gilly> is it faster to insert elements to a list using insert than create the list first and then sort it?
09:22:28 <DQuest> and I can always come back
09:22:42 <quicksilver> Gilly: probably slightly faster to sort it afterwards.
09:22:49 <qwrx> on the other hand if you stay where you are, new interesting people will turn up
09:22:52 <Cale> Gilly: using insert is equivalent to doing an insertion sort
09:22:56 <qwrx> so long as not everybody thinks that way
09:23:08 <Cale> Gilly: If you already have a large sorted list, using insert is a sane way to add to it
09:23:20 <Gilly> well i have to create a big sorted list
09:23:23 <quicksilver> Cale: but a haskell insertion sort is quite a lot more expensive than a conventional one.
09:23:37 <quicksilver> Cale: (rebuilding cons cells all the way down the spine on each insert)
09:23:46 <Cale> But not the tail, at least.
09:23:53 <quicksilver> same complexity, of course.
09:23:58 <quicksilver> but a nasty constant factor there.
09:24:05 <quicksilver> and loads of GC.
09:24:12 <Cale> If you're building the list up from nothing, it's basically always more efficient just to sort afterward.
09:24:25 <Gilly> ok - thanks :)
09:24:28 <MyCatVerbs> Hang on, isn't that insertion sort going to be O(n)?
09:24:32 <hpaste>  dcoutts pasted "Hackage.DependencySet" at http://hpaste.org/5925
09:24:40 <MyCatVerbs> (In the length of the list already built up, I mean.)
09:24:45 <Cale> But if you're just sticking a small number of elements into an already sorted list, insert is the way to go.
09:24:48 <quicksilver> MyCatVerbs: yes. Insertion sort is n^2
09:24:51 <quicksilver> MyCatVerbs: (in any language)
09:25:06 <quicksilver> MyCatVerbs: but it's O(n) on already sorted data.
09:25:12 <quicksilver> or, at least, one obvious algorithm is.
09:25:13 <MyCatVerbs> quicksilver: but in this case it'll be on almost-sorted data, so it'll come down to O(n).
09:25:35 <Cale> MyCatVerbs: Right, that's why I asked.
09:25:49 <MyCatVerbs> quicksilver: but the problem is that if you build a list up that way, you'll end up running that O(n) insertion sort n times, for a nicely suicidal O(n^2) running time.
09:25:58 <quicksilver> right.
09:26:01 <quicksilver> precisement.
09:26:23 <quicksilver> the simplest way to do an "incremental sort" is probably to build a binary tree
09:26:28 <MyCatVerbs> quicksilver: not just "slightly" faster, then. :P
09:26:31 <quicksilver> that's particularly appropriate in a language like haskell.
09:26:44 <MyCatVerbs> quicksilver: treesort with splay trees!
09:26:53 <qwrx> if you're using a linkedlist anyway then there's no harm in making it a tree
09:26:56 <quicksilver> you don't even have to balance it, necessarily.
09:27:02 <quicksilver> depends on what you plan to do with it.
09:27:18 <MyCatVerbs> quicksilver: Okasaki suggested that one. Apparently it gets O(n*log(n)) worst case, but O(n) on data sorted in either ascending or descending order .^_^
09:27:19 <quicksilver> if all you're going to do is read the elements off it sequentially, then there is no reason to bother balancing
09:27:22 <quicksilver> then it's really easy.
09:27:53 <quicksilver> yes, that's quite clever.
09:27:59 <MyCatVerbs> quicksilver: I presume you're suggesting insertions at the root rather than the leaves in that case?
09:28:21 <quicksilver> I'm suggesting the standard naive binary tree algorithm without balancing.
09:28:44 <quicksilver> which is n log(n) but easy to write and with a small constant.
09:28:57 <qwrx> but doesn't have O(1) lookup
09:29:03 <quicksilver> absolutely.
09:29:03 <qwrx> then again, neither does a linked list
09:29:10 <MyCatVerbs> quicksilver: that degrades to a linked list on ordered data. You'd then have to copy the entire spine in order to add a new element. Hence you get a worst case O(n^2) treesort, which isn't nice.
09:29:22 <MyCatVerbs> (In order to add *each* new element, I mean.)
09:29:25 <quicksilver> MyCatVerbs: oh.
09:29:29 * quicksilver wasn't thinking clearl.
09:29:35 <quicksilver> So you do have to balance.
09:29:37 <quicksilver> or splay.
09:29:40 * MyCatVerbs nodnod.
09:29:42 <qwrx> or use a skiplist
09:30:00 <qwrx> but that's not so functional
09:30:49 * MyCatVerbs isn't sure how much work it'd be to implement skiplists in a purely functional manner.
09:30:58 <mrsolo> hi does ghc take advantage of multicore automatically? or I have to use Control.Concurrent and such?
09:31:06 <matthew-_> the latter
09:31:39 <mrsolo> ah ok
09:31:45 <MyCatVerbs> @index par
09:31:45 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
09:32:10 <MyCatVerbs> mrsolo: also look at the "par" combinator in Control.Parallel, which is very handy.
09:32:37 <dolio> All of Control.Parallel.Strategies, really.
09:32:39 <mrsolo> i tried few of those sample from the webs and didn't see 100 cpu utilization
09:33:06 <mrsolo> in fact fib example seems to be slower than single threaded version..
09:33:22 <MyCatVerbs> mrsolo: it will be, it sparks threads like nobody's business.
09:34:52 <qwrx> cake time
09:35:13 <dolio> Were you running it on multiple CPUs?
09:35:19 <MyCatVerbs> mrsolo: AFAIK (someone else here please correct me if I'm wrong?) it'd be better to do something like: pfib n = let a = (fib (n-2)) in a `par` (fib (n-1)) + a -- where "fib" is the usual single-threaded fibonacci - though that hack limits you to two threads. >>
09:35:35 <b_jonas> mrsolo: also, if you want to make it run paralelly, you have to use specific compilation options
09:36:01 <b_jonas> see http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
09:36:02 <lambdabot> Title: 5.12. Using SMP parallelism, http://tinyurl.com/ytnnbg
09:36:49 <MyCatVerbs> Oh aye. Compile with -threaded, run with +RTS -N2 -RTS (replace 2 with some larger number if you have more CPUs)
09:36:54 <b_jonas> qwrx: cake where?
09:36:58 <mrsolo> yea threaded you can't even link without that option
09:37:05 <Taejo> > zipWith ($) (cycle [show, show, const "fizz", show, const "buzz", const "fizz", show, show, const "fizz", const "buzz", show, const "fizz", show, show, const "fizbuzz"]) [1..100]
09:37:12 <lambdabot>  ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","14...
09:37:14 <matthew-_> -threaded is default isn't it?
09:37:38 <quicksilver> matthew-_: not AFAIK.
09:37:42 <quicksilver> certainly not in 6.6
09:37:49 <matthew-_> oh. I should really remember that then!
09:37:56 <qwrx> b_jonas: the cake shop down  the hill
09:38:08 <mrsolo> ah i think i missed +RTS -N2 -RTS.. no wonder..
09:38:31 <b_jonas> hmm
09:38:47 <b_jonas> isn't there a way to make +RTS -N2 -RTS the default or something at compile-time?
09:39:05 <dolio> glguy was asking about that yesterday. I wonder if he found an answer.
09:39:15 <mrsolo> yep that does the trick
09:39:26 <gnuvince> > nub [1,1,1,2,3,4,4,3]
09:39:27 <lambdabot>  [1,2,3,4]
09:40:28 <Baughn> @src nub
09:40:28 <lambdabot> nub = nubBy (==)
09:40:32 <Baughn> @src nubBy
09:40:33 <lambdabot> nubBy eq []             =  []
09:40:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:41:42 <mrsolo> thanks all for the help :-)
09:41:43 <glguy> dolio: ?
09:41:54 <glguy> Oh, I did find the answer!
09:42:08 <glguy> b_jonas: two solutions
09:42:09 <Tener> hello
09:42:29 <gnuvince> @src nub
09:42:29 <lambdabot> nub = nubBy (==)
09:43:16 <glguy> b_jonas: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
09:43:17 <lambdabot> Title: 5.14. Running a compiled program, http://tinyurl.com/d7dj4
09:43:23 <glguy> by linking in an object file
09:43:24 <glguy> or
09:43:29 <glguy> through the environment:
09:43:42 <glguy> GHCRTS="-N2"
09:43:51 <glguy> which isn't a default
09:43:59 <Baughn> > nubBy (=/) [1,2,3,4,1,6,2,1]
09:44:00 <glguy> but saves you from adding the one line c file
09:44:04 <lambdabot>   Not in scope: `=/'
09:44:09 <Baughn> > nubBy (/=) [1,2,3,4,1,6,2,1]
09:44:10 <lambdabot>  [1,1,1]
09:44:28 <b_jonas> glguy: thanks for the info
09:50:58 * Cale adds http://en.wikipedia.org/wiki/Fixed_point_combinator#Example_of_encoding_via_recursive_types
09:50:59 <lambdabot> http://tinyurl.com/yw7a5v
09:55:10 <byorgey> Cale: nice =)
09:55:15 <byorgey> Cale++
09:57:23 <DQuest> hmm
09:57:33 <DQuest> (fix ($)) 1  seems to kill ghci
09:58:03 <MyCatVerbs> :t fix ($)
09:58:17 <lambdabot> forall a b. a -> b
09:58:20 <DQuest> I guess fix ($) 1 == ($) (fix ($)) 1 = ($) ($) (fix ($)) 1  etc
09:58:32 <ddarius> > fix ($) 1
09:58:44 <lambdabot> Terminated
09:58:54 <Baughn> DQuest: It's an infinite loop. Thus..
09:59:05 <DQuest> Yes, that's clear
09:59:11 <DQuest> But usually, you can use Control-C
09:59:22 <Baughn> Did you try control-\?
09:59:44 <DQuest> that fails too
09:59:49 <DQuest> though I can use Control-Z and kill
10:00:10 <DQuest> It just struck me as an oddity that I'd clearly triggered something uninterruptable
10:00:20 <Cale> Which fix were you using?
10:00:35 <DQuest> Control.Monad.Fix
10:00:40 <DQuest> Hugs is entirely happy with killing it, mind
10:00:42 <Cale> Yeah, I get that behaviour too.
10:01:00 <Cale> It seems that compiling fix with optimisations makes it hard for GHCi to kill it.
10:01:04 <smg> repeat "Cale" :D
10:01:20 <DQuest> ah
10:01:20 <gio123> somebody tell me which haskel compiler is good to download
10:01:20 <gio123> ?
10:01:45 <DQuest> Ah yes, if I do it with let it's fine
10:01:51 <smg> gio123: ghc
10:01:57 <smg> gio123: if you have less disk space try hugs
10:02:03 <DQuest> gio123: The main two are ghc and hugs, but ghc is probably better
10:02:13 <DQuest> seeing as it comes with a compiler too :)
10:02:15 <MyCatVerbs> gio123: what for? For serious stuff, most people use GHC. If you're on, say, Slackware, and you need a little Haskell interpreter to do your homework with, Hugs is smaller and easier to build.
10:02:40 <Baughn> gio123: ghc and hugs give... /different/ error messages. Until you get used to it, it might be handy to have both
10:02:42 <MyCatVerbs> gio123: but usually (unless you're stuck for disk space) you just want to download GHC binaries.
10:03:13 <DQuest> I find that ghci's error messages are far far more helpful
10:03:30 <Cale> hmm, or maybe compiling fix at all does that.
10:05:33 <glguy> Anyone know about FFI and variable argument functions?
10:05:40 <glguy> I'm willing to do some reading
10:06:02 <Cale> glguy: I know there's very little support for them.
10:06:38 <Cale> glguy: You might be best off writing a bunch of wrappers in C which have fixed argument lists.
10:06:43 <glguy> Cale: do I need to do anything special when binding to one?
10:06:48 <gio123> Cale: hi
10:06:52 <b_jonas> MyCatVerbs: heh, homeworks reminds me to that when I took the declarative programming course, I used different compilers than the one the teachers endorsed
10:06:59 <glguy> so far doing multiple foreign imports with different type signatures seems to be working
10:07:04 <MyCatVerbs> b_jonas: how brave of you.
10:07:11 <Cale> glguy: ah, neat
10:07:15 <MyCatVerbs> b_jonas: by which I mean masochistic.
10:07:16 <gio123> Cale: hi
10:07:27 <Cale> glguy: I didn't know that even worked :)
10:07:39 <Baughn> glguy: Be careful. Varargs have a different ABI from other functions - specifically, they get default promotions
10:07:39 <Cale> (but it makes some sense, now that I think about it)
10:07:40 <b_jonas> MyCatVerbs: it didn't matter at all, becasuse I didn't do any advanced stuff for which I'd have needed something specific
10:07:48 <b_jonas> and it's not like haskell where ghc is the best compiler
10:07:57 <Baughn> glguy: So if you pass a float it becomes a double, a short becomes an int, etc. I think.
10:08:12 <Baughn> glguy: ##C would know. ;)
10:08:22 <b_jonas> also, I didn't do it for the revolution, but becasue I evaluated the specific compilers and found they're better
10:08:47 <Baughn> glguy: (The point is, GHC doesn't do those promotions, so you have to do it yourself. Pass doubles, not floats.)
10:09:12 <smg> Here's what's going on: The IO Monad binds blah blah blah that's all in the other tutorials and yet you're reading this. Let's try again. <-- haha
10:09:20 <smg> "Haskell tutorial for C-Programmers" is really fun! :)
10:09:56 <jgerman> anyone know if happs.org is temporarily down, or has it actually gone away ?
10:10:14 * sm wonders
10:10:16 <Lemmih> jgerman: It will be back soonish.
10:10:26 <jgerman> cool ty
10:10:39 <Lemmih> (Once the right people have been kicked)
10:11:07 <jgerman> kicked?
10:11:45 <jgerman> lol nvm.. thinking slow today
10:11:46 <Lemmih> Other means of notification might also work.
10:12:00 <sm> chastised, publicly named, thrown in the stocks and so on
10:12:30 <jgerman> lol
10:12:53 <Baughn> Cale: Are all the (,,,,,,..) variations explicitly defined somewhere, or is there an implicit, infinite number of them?
10:13:14 <MyCatVerbs> Baughn: they're explicitly defined.
10:13:32 <MyCatVerbs> Baughn: which IMO is a bit of a pity.
10:13:34 <jgerman> another question, can someone point me to a decent graphics lib for Haskell? I'm running ghc 6.8 on OS X
10:13:41 <Cale> Baughn: There's an implicit, infinite number of them.
10:13:54 <Cale> Baughn: However, instances for them are explicit and finite.
10:14:01 <sm> hopengl, gtk2hs and wxhaskell are all on hackage and seem good
10:14:07 <Cale> So eventually you lose support for things like Eq and Show
10:14:19 <jgerman> cool, ty very much
10:14:22 <sm> np
10:14:33 <Cale> Whoa, gtk2hs is on hackage now?
10:14:34 <b_jonas> Cale: even for those derived ones?
10:14:41 <dcoutts_> Cale: no
10:14:58 <dcoutts_> Cale: and wx's cabal packages still use makefiles
10:15:13 <sm> I could have sworn I installed it from there
10:15:27 <roconnor> what would you call a series where |a_n+1| <= k*|a_n| for some constant 0 <= k < 1?
10:15:58 <sm> jgerman: there's also SDL and simpler things like soegtk
10:16:20 <b_jonas> hmm
10:16:31 <jgerman> cool, I'll check those out too, I'm a noob so simpler is probably better for now
10:17:11 <b_jonas> I entered 'let x = (1,1,1,...,1)' to ghci, and it says 'A 1004-tuple is too large for GHC (max size is 62) Workaround: use nested tuples or define a data type'
10:17:17 <Altair^> are there any good examples on haskell threads?
10:17:21 <b_jonas> heh
10:17:32 <sm> http://www.haskell.org/haskellwiki/Opengl links to a nice hopengl tutorial
10:17:33 <lambdabot> Title: Opengl - HaskellWiki
10:18:06 <Lemmih> Altair^: forkIO ioCode  <- that basically all of it.
10:18:14 <jgerman> aha.. that'll be my first stop then, much appreciated
10:18:22 <Cale> Ah, right.
10:18:38 <Cale> There is no upper bound on the size of a tuple, but some Haskell implementations may restrict the size of tuples, and limit the instances associated with larger tuples. However, every Haskell implementation must support tuples up to size 15, together with the instances for Eq, Ord, Bounded, Read, and Show. The Prelude and libraries define tuple functions such as zip for tuples up to a size of 7.
10:19:13 <gio123> Cale: hi
10:19:17 <shapr> @yow !
10:19:20 <lambdabot> Kids, the seven basic food groups are GUM, PUFF PASTRY, PIZZA,
10:19:20 <lambdabot> PESTICIDES, ANTIBIOTICS, NUTRA-SWEET and MILK DUDS!!
10:19:27 <MyCatVerbs> Pity tuples aren't inductively defined so that it wouldn't be necesasry to provide many instances.
10:19:33 <MyCatVerbs> *necessary
10:19:41 <sm> jgerman: ah, actually it uses an out of data api, sorry. Still worth reading though. Basically it calls functions to set things like color whereas nowadays you use a statevar, like color $= value
10:19:43 <Cale> That would make them mean something different though.
10:19:59 <Cale> There's a performance and semantic difference between (a,b,c) and (a,(b,c))
10:20:11 <Deewiant> Performance?
10:20:31 <dolio> Double boxing.
10:20:36 <Cale> Yes. The latter has an extra layer of indirection you have to follow to get to the 'b' or 'c' element.
10:20:42 <jgerman> sm: all info is good info :)
10:21:24 <MyCatVerbs> Cale: eh, we already have arity analysis - compiling (a,(b,c)) down to (a,b,c) surely is easier than the let-floating and so on which is already in GHC?
10:21:26 <Cale> The semantics difference is that the latter has (x, bottom) as an element, for which the former has nothing corresponding.
10:21:33 <Deewiant> Any Vim users here? Is there a way to get paren matching to work properly with lambdas? (Vim seems to get confused with "\(")
10:21:45 <MyCatVerbs> Cale: admittedly the semantic differences are a bit odder. :/
10:21:47 <sm> well I don't know about that.. but I did find that tut. excellent for the basic hopengl concepts
10:22:26 <Cale> Deewiant: I've just gotten used to ignoring it, but let me know if you find a solution.
10:22:33 <MyCatVerbs> Cale: still, I would personally prefer an inductively defined version (with suitable hacks in the optimizer) to the current semantics.
10:22:36 <resiak> Cale: could you not have (a, b, c) := (a, !(b, c)) ?
10:23:26 <dino-> I've been trying different things with cabal-install like --global --prefix=/usr/local, as root or as me, and can't get it to install anywhere other than ~/.ghc
10:23:49 <Cale> resiak: hmm...
10:24:11 <Cale> resiak: that might work, yeah
10:24:12 <resiak> it rules out the (x, _|_) case
10:24:24 <dcoutts_> dino-: what version of cabal-install?
10:24:29 <resiak> and the (b,c) tuple could be unboxed?
10:24:47 <dino-> dcoutts_: 0.4.0 and ghc 6.8.2
10:25:03 <dcoutts_> dino-: see if it works with the current dev version of cabal-install
10:25:07 <dcoutts_> @where cabal-install
10:25:08 <lambdabot> I know nothing about cabal-install.
10:25:10 <dcoutts_> bah
10:25:13 <dino-> Not from Hackage?
10:25:19 <dino-> Like a darcs get, ok
10:25:24 <dcoutts_> dino-: no, far to old, yes darcs
10:25:53 <dcoutts_> @where+ cabal-install http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:25:53 <lambdabot> Done.
10:26:03 <b_jonas> resiak: it would be inconvenient, for it would miss some type errors
10:26:12 <Deewiant> Cale: :help % suggests that adding M to cpoptions would solve it
10:26:18 <b_jonas> but of course you can use some such types if you want to
10:26:34 <Deewiant> Cale: and indeed it does
10:26:37 <Cale> Nice
10:26:52 <Deewiant> Cale: thanks for prompting me to look for this ;-)
10:27:49 <Cale> ah, that's great, it works :)
10:27:55 <MyCatVerbs> Pity you can't have typeclass variables.
10:28:04 <shepheb> it would be handy if the cabal-install preamble there indicated its usability.
10:28:46 <MyCatVerbs> e.g. instance foo (a,b) => foo (Pair a b)
10:28:52 <MyCatVerbs> But that would just be insane anyway.
10:29:27 <b_jonas> resiak: btw, is the bang in (a, !(b, c)) even legal syntax?
10:29:44 <b_jonas> isn't it something like (a, (# b, c #)) instead?
10:29:55 <dcoutts_> shepheb: that's a matter of opinion :-) it's being hacked on pretty actively, I use it all the time.
10:30:05 <opqdonut> is (# #) for unboxed tuple?
10:30:21 <Cale> b_jonas: It's not quite legal, but it means something obvious. Using an unboxed tuple is too much, and would ruin things.
10:30:28 <dcoutts_> shepheb: so I count it as usable, I never run any Setup.hs scripts anymore.
10:31:20 <shepheb> dcoutts_: well, okay. but it would be handy, I think, to have at least a "kind of halfway works", "works with quirks" "please, try it and send a bugrep if it doesn't work", something to give ex-Perl people missing CPAN an idea of how it goes.
10:32:30 <dino-> Could I add a homepage or something URL to the Hackage info?
10:32:30 <dcoutts_> shepheb: "please, try it and send a bugrep if it doesn't work"
10:32:48 <dino-> Looking at that infof or cabal-install I had no idea really where to look.
10:32:49 <dcoutts_> dino-: yes, that's what the homepage field is for, see the cabal manual
10:32:57 <dino-> I'
10:33:01 <Cale> b_jonas: basically, it means that when such an (x,y) is is to be evaluated, evaluate y up to determining the top level constructor in it.
10:33:07 <dino-> I'm saying there is none in cabal-install's info on Hackage.
10:33:25 <b_jonas> Cale: ok
10:33:31 <dcoutts_> dino-: oh, well it doesn't really have a homepage
10:33:59 <Cale> b_jonas: (normally, that just evaluates up to the point where it can be determined that (,) is the constructor)
10:34:47 <dino-> Could we make it this page: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:34:49 <lambdabot> Title: CabalInstall - Hackage - Trac
10:35:58 <dcoutts_> dino-: sure, but I'd need to upload a new package and we cannot do that 'til we have a new cabal-install release which depends on having a stable Cabal lib release
10:36:34 <dino-> :/
10:36:36 <dino-> ok
10:38:23 <dcoutts_> shepheb: I updated that CabalInstall wiki page to say: The current development version is quite usable but if you find any surprises please report them in this trac.
10:39:24 <shepheb> dcoutts_: excellent. something like that gives people in my situation enough confidence to give it a try.
10:46:58 <joglala> Hello
10:47:21 <Baughn> Are there any projects that use gccxml to generate (part of) an FFI?
10:47:26 <resiak> b_jonas: ! is a strictness annotation in a data definition, no?
10:47:36 <Baughn> resiak: Yep
10:47:51 <b_jonas> resiak: yep, and in patterns too
10:47:58 <resiak> right
10:48:16 <b_jonas> though I'm not exactly sure how it works
10:49:24 <Cale> I suppose you'd implicitly have something sort of like:  data (a,b,c) = T3 a !(b,c), which would be valid.
10:50:49 <dino-> Oh wow, I wonder what's up with my system. I got the dev version of cabal and ./Setup.hs configure changes my cursor to a window-picker. When I click, it complains about missing ImageMagick libs. !!
10:51:45 <dcoutts_> dino-: sounds pretty weird
10:52:51 <dino-> Totally didn't do that when I did `runhaskell Setup.hs configure` instead of `./Setup.hs configure`  That's just crazy right there.
10:53:50 <ari> :t (.|.)
10:53:52 <lambdabot> forall a. (Bits a) => a -> a -> a
10:54:07 <dv\> :t (>=>)
10:54:07 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:55:10 <gio123> somebody can tell me what
10:55:10 <gio123> Hugs> :load "C:\\Dokumente und Einstellungen\\Administrator\\Desktop\\code1.txt"
10:55:10 <gio123> ERROR file:.\code1.txt:1 - Syntax error in data type declaration (unexpected `|')
10:55:10 <gio123> Hugs>
10:55:13 <gio123> means?
10:55:29 <mauke> it means there's a syntax error in line 1
10:55:39 <roconnor> mauke: not helpful.
10:55:51 <mauke> I need line 1 to be more helpful
10:55:57 <dv\> also wrong file extension
10:56:02 <roconnor> mauke: then ask for it.
10:56:03 <dv\> and running windows as admin
10:56:22 <mauke> roconnor: :(
10:56:25 <gio123> dv\: so many mistakes
10:56:57 <byorgey> gio123: what is code1.txt?  a Haskell program you wrote?
10:57:08 <dino-> Ah, cabal's Setup.hs was set executable for me but has no #! line.
10:57:28 <roconnor> sorry, but I don't want the quality of help for people on this channel to start slipping.
10:57:31 <dino-> What crazy ass unexpected behavior though.
10:57:35 <gio123> byorgey: i dont know haskel at all
10:57:53 <byorgey> gio123: ok, well, what is code1.txt?
10:58:07 <gio123> byorgey: i dont know haskel at all I just needet to undestand algorithm and just instaled haskel compiler but it seems this code does not compile
10:58:16 <gio123> http://pastebin.com/d5675cc8c
10:58:28 <mauke> (hugs is not a compiler)
10:58:43 <tack-work> doesn't hugs compile to bytecode?
10:58:46 <mauke> that's not valid code
10:58:53 <b_jonas> are you sure that's haskell?
10:58:55 <mauke> who wrote that?
10:59:09 <byorgey> wow, postfix data constructors?
10:59:12 <byorgey> cool =)
10:59:18 <byorgey> but it's not Haskell
10:59:19 <mauke> maybe it's pseudohaskell
10:59:41 <b_jonas> must be some ml, like ocaml or something
11:00:01 <byorgey> gio123: where did you get this file?
11:00:01 <mauke> I wonder what the difference between Empty and () is
11:00:03 <dolio> It's much closer to Haskell than ML.
11:00:10 <b_jonas> byorgey: standard ml has postfix data constructors, but this isn't standard ml either
11:00:26 <byorgey> mauke: an empty regex vs. a regex that matches the empty string, perhaps?
11:00:26 <b_jonas> dolio: yep, it has no var and it has ::
11:00:33 <b_jonas> it could still be some other functional language
11:00:50 <dolio> b_jonas: Way too pretty to be ML. :)
11:01:20 <b_jonas> oh, you said data constructors
11:01:22 <gio123> I just insert location
11:01:33 <gio123> I just will insert location
11:01:36 <b_jonas> SML doesn't have postscript data constructors, only postscript type constructors
11:01:39 <gio123> waite minute please
11:02:06 <gio123> https://dl.comp.nus.edu.sg/dspace/bitstream/1900.100/1453/3/report.pdf
11:02:07 <mauke> int set list array
11:02:08 <lambdabot> http://tinyurl.com/23wdrm
11:02:29 <gio123> byorgey: https://dl.comp.nus.edu.sg/dspace/bitstream/1900.100/1453/3/report.pdf
11:02:30 <lambdabot> http://tinyurl.com/23wdrm
11:03:27 <b_jonas> but superficially it is similar to haskell
11:03:29 <gio123>  byorgey: page 17 please
11:04:16 <byorgey> gio123: if you look at the beginning of Appendix A, it states that this is pseudocode
11:04:43 <mauke> and that's a phi, not an empty set
11:05:05 <b_jonas> eek
11:05:12 <gio123> byorgey: so it will not run
11:05:27 <mauke> also see section 3, "Regular Expressions"
11:05:31 <byorgey> mauke: it's pretty clear that it's supposed to indicate the empty set, I think, but they used the wrong symbol
11:05:38 <byorgey> gio123: nope
11:06:26 <joglala> Where can i find the \x notation the tutorial on haskell.org?
11:06:36 <joglala> I don't know how this is called and what it does
11:06:39 <mauke> which \x?
11:06:44 <radix> joglala: lambda?
11:06:45 <mauke> there's at least two
11:06:50 <b_jonas> lambda, yes
11:07:06 <solrize> > foldl1' lcm [1..20]
11:07:08 <joglala> Thanks
11:07:10 <lambdabot>  232792560
11:07:10 <gio123> byorgey: so, it needs a lot work to modify it as working haskel code
11:07:10 <mauke> > "\x32"
11:07:11 <lambdabot>  "2"
11:07:19 <b_jonas> mauke: ah
11:07:20 <solrize> > foldl1' lcm [1..20]
11:07:21 <lambdabot>  232792560
11:07:29 <byorgey> gio123: it needs some work, certainly.  how much work, I have no idea.
11:07:35 <byorgey> probably not too much work, actually
11:07:43 <byorgey> although you just said you don't know Haskell, so...
11:08:01 <roconnor> not to much work for someone who knows Haskell...
11:08:05 <roconnor> :(
11:08:20 <dolio> Conclusion: you should learn Haskell.
11:08:26 <roconnor> :)
11:08:36 <b_jonas> roconnor: I think it's lacking some functions to be usable (testable) so I wouldn't be sure
11:08:39 <byorgey> joglala: \ is for creating anonymous functions.  for example, \x -> x + 2  denotes the function which takes x as a parameter, and returns x + 2.
11:09:18 <byorgey> joglala: \ is supposed to look sort of like a greek lowercase lambda, since its roots are in a mathematical formalism called the "lambda calculus", which uses actual lambda symbols.
11:10:18 <Cale> Funnily enough, the use of the lowercase lambda was itself a typographical hack to make up for the fact that the typesetter couldn't put hat symbols atop the bound variables.
11:10:43 <Riastradh> Couldn't do that, or was confused?  I had heard the latter.
11:10:50 <byorgey> Cale: hah! I didn't know that =)
11:11:07 <b_jonas> Cale: really?
11:11:28 <roconnor> ^x. x + 2 would bring us back to our roots.
11:11:37 <Cale> Riastradh: I'm not entirely certain, but it seems like something which would be hard to get confused about if you had a handwritten manuscript.
11:11:39 <roconnor> I think I'll use that in my next langauge.
11:11:41 <dino-> I think this is a strange darcs wrinkle. The cabal Setup.hs file used to have a #! line but it was removed. Liks darcs set it executable for me as per my prefs, but the applied patch removed the #! line slighty later in the get.
11:12:22 <dino-> And then I just saw x bit set, and ran it. And system acted loopy.
11:12:35 <joglala> byorgey: Thats, i found in the tutorial under 'functions'
11:12:46 <b_jonas> roconnor: this description http://www.madore.org/~david/programs/unlambda/ uses ^ for lambdas in the pseudocode in textt
11:12:47 <lambdabot> Title: The Unlambda Programming Language
11:13:18 <roconnor> there are lambdas in unlambda?
11:13:19 <Riastradh> Cale, my understanding was that Church originally meant a circumflex atop the bound variables, that someone had typewritten a caret to the left of it, and the typesetter mistook the caret for a lambda (or understood a typewritten caret to mean a lambda).
11:13:46 <Cale> Riastradh: yeah, that seems about right.
11:13:56 <roconnor> good ol' telephone lambda calculus.
11:13:58 <b_jonas> roconnor: read my line again
11:14:02 <byorgey> if only Knuth had been around back then!  oh, wait...
11:14:10 <roconnor> b_jonas: ah sorry.
11:15:13 <Cale> So some combination of typographical constraints and general confusion :)
11:15:32 <dons> ?users
11:15:32 <lambdabot> Maximum users seen in #haskell: 463, currently: 440 (95.0%), active: 24 (5.5%)
11:15:47 <b_jonas> Riastradh: wouldn't a typewriter overpunch the letters with a caret using backspace?
11:15:55 <Riastradh> That would make sense.
11:15:57 <b_jonas> also, what typewriter has a caret?
11:16:21 <b_jonas> I don't think typewriters had them
11:16:32 <b_jonas> note how they used to have up arrow instead of caret
11:16:33 <Riastradh> Hmm.  I haven't used a typewriter in many, many years.
11:16:38 <b_jonas> terminals I mean
11:16:48 <Cale> Normally when writing special notation using a typewriter, one would add special symbols like that in pen.
11:16:55 <Riastradh> I don't know; I'm just repeating hearsay.
11:17:15 <Cale> (I've seen entire books written that way.)
11:17:31 <roconnor> my electric typewriter had a caret.
11:17:34 <b_jonas> Cale: yes, that is used
11:17:44 <roconnor> I can check my old manual typewriter (which has no 0 or 1 key).
11:18:17 <Cale> roconnor: who needs those digits anyway? You can get by with 2 through 9 just fine.
11:18:21 <radix> roconnor: nice. O and l, I guess?
11:24:40 <roconnor> I liked, my electric typewriter has a cent sign instead of a caret.
11:24:48 <roconnor> s/liked/lied/
11:25:00 <roconnor> and I cannot find the manual typewriter at the moment.
11:26:16 <roconnor> radix: yep.  Looking at that old manual typewriter sealed the whole presenataion vs semantic markup debate in my mind.
11:26:35 <b_jonas> roconnor: thanks for looking it up
11:26:51 <b_jonas> roconnor: heh,
11:27:13 <roconnor> given that the electric typewrite has no ^, I have serious doubts about my manual one.
11:27:22 <gnuvince> :t (^^^)
11:27:24 <gnuvince> :t (^^)
11:27:32 <lambdabot> Not in scope: `^^^'
11:27:32 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:28:51 <roconnor> who needs a 0 and l.  Computers can just infer what that lO means 10 from context. :P
11:29:39 <b_jonas> let's omit 5 too in favor of S
11:31:03 <IsoPallo> The 1337 hax0r-kids did taht already, but the other way around...
11:32:03 <roconnor> the circle is complete
11:32:20 <byorgey> 2 is not needed, just use Z
11:33:14 <byorgey> wait, how about this: let's just get rid of all keys EXCEPT 0 and 1!
11:33:38 <dino-> byorgey: I think you mean O and l
11:34:19 <byorgey> dino-: oh, yes, sorry
11:35:01 <b_jonas> 9OOO lOEA
11:35:09 <dolio> Why not just one letter, and count in unary?
11:35:33 <b_jonas> dolio: you don't need a typewriter then, only a pen
11:36:07 <dolio> Why do you need a typewriter for 2 leters?
11:36:40 <dolio> Two much work to learn to write O with a pen?
11:37:22 <roconnor> > concatMap (flip (showIntAtBase 2 (\x -> if 0==x then 'O' else 'l')) []) $ map ord "Sounds good to me."
11:37:26 <lambdabot>  "lOlOOllllOlllllllOlOlllOlllOllOOlOOlllOOlllOOOOOllOOlllllOllllllOllllllOOlO...
11:38:14 <shreedhar> hello everybody. I am understanding what is meant by a pure function. but I don't exactly understand what are those side-effects. can I get an example of a function with side-effects please?
11:38:15 <gnuvince> :t flip
11:38:16 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:38:21 <b_jonas> roconnor: prefix code please
11:38:26 <roconnor> dolio: counting in unary is totally unreasonable.
11:38:44 <gnuvince> > flip (/) 5 0
11:38:45 <hpaste>  joglala pasted "data type" at http://hpaste.org/5927
11:38:47 <lambdabot>  0.0
11:38:47 <b_jonas> roconnor: typewriters have a space key anyway, it doesn't need a head
11:38:58 <joglala> Can you tell me why this does is not right?
11:39:36 <dino-> dcoutts_: Hey, that worked! Thank you.
11:39:56 <dino-> Got all that business installed, cabal and cabal-install
11:39:59 <kpreid> joglala: the second pattern of deleteTasks is wrong
11:40:10 <tack-work> shreedhar: a function which makes use of data that was not passed in through the parameters of the function
11:40:14 <kpreid> PriorityQueue is not a constructor; it should not appear in the pattern
11:40:16 <dcoutts_> dino-: great
11:40:37 <kpreid> joglala: it should be deleteTasks a (Store x b y) | ...
11:40:42 <b_jonas> kpreid: well spotted
11:41:09 <dcoutts_> dino-: if you find surprises check the existing cabal-install tickets and if it's not already been reported then report it.
11:41:09 <mauke> shreedhar: do you know C?
11:41:16 <tack-work> shreedhar: an example would be something like readFile, because it reads in from the hard drive.
11:42:08 <kpreid> joglala: also, your code as given could be replaced with [(Int,a)] as the data type and Data.List.delete as the function.
11:42:08 <dino-> dcoutts_: will do.  Is there support for using the not --global install of things?
11:42:24 <dcoutts_> dino-: the default is --user
11:42:34 <dino-> I mean, if I did install just for my user, how do I make projects who need that build?
11:42:50 <dcoutts_> dino-: that'll just work
11:43:06 <dolio> roconnor: I realize it'd be tough without a space key, which you could do with l and O by agreeing on some character encoding standard, but you could Goedel encode a string into a single number, and write that using unary. :)
11:43:11 <dcoutts_> dino-: it'll work for other packages you build with cabal and also for ghci
11:43:14 <joglala> kpreid: thank you
11:43:37 <dino-> I see, I saw this not work yesterday but that was with cabal-install 0.4.0 doing the installation. So, suspect.
11:43:39 <joglala> I thought it must be PriorityQueue y because its PriorityQueue y in the data definition
11:44:03 <dcoutts_> dino-: yes, we switched the default to --user since 0.4.0
11:44:06 <gwern> this discussion on libraries about text encoding is kind of interesting. I hope they decide on all-utf8. make things a lot easier to understand
11:45:23 <dcoutts_> gwern: but it doesn't work if your locale is no utf8
11:45:26 <dcoutts_> no/not
11:45:52 <shreedhar> tack-work, I get it.
11:46:00 <shreedhar> mauke, yes I do
11:46:41 <shreedhar> mauke, why?
11:47:05 <shreedhar> tack-work, thanks
11:48:00 <gwern> dcoutts_: yeah, but the alternatives are all bizarre - use locale for everything and hope it change and don't mind the unportability, use locale in some things and not other (which will confuse everybody and cause problems with interopreability) and so on
11:48:15 <dcoutts_> gwern: lots of russian and far east users still do not use utf8 locales apparently
11:48:27 <mauke> shreedhar: time, rand, fread, fwrite, fopen ... all have side effects
11:48:30 <mauke> or malloc
11:48:40 <tack-work> shreedhar, in general, anything with type "IO t" is considered to be "side effectful" and otherwise we say it is "pure". However, the terminology is not a rigorous term, and some pure functions, especially ones involving monads, are sometimes refered to as effectful as well
11:48:45 <dcoutts_> gwern: which has the bizarre behaviour that putStr "some russian text" does not work
11:48:46 <gwern> dcoutts_: why nto?
11:49:07 <dcoutts_> gwern: because it'll output utf8 and their terminal is expecting something else, so they'll get junk
11:49:24 <gwern> no, why aren't they using utf-8? is it incapable of cyrillic?
11:49:47 <dcoutts_> gwern: no, it covers everything, but many people and systems are slow to change
11:50:13 <dcoutts_> gwern: many far east users dislike utf8 because it takes more space than other encodings for their languages
11:50:35 <gwern> oh. you'll forgive if I'm not particularly sympathetic for them - 'we should keep our systems broken in order to not make other systems (more) broken!'
11:50:47 <gwern> (and space is cheap)
11:51:05 <doserj> I don't think just using the locale would be broken
11:51:40 <dcoutts_> gwern: it's a question of being consistent with the OS environment or consistent with other Haskell programs on other machines
11:52:04 <dcoutts_> and note that java, C and python all follow the current locale unless you specify some other encoding specifically
11:52:34 <dcoutts_> when outputting to a terminal using the current locale is the only correct thing to do
11:52:46 <dcoutts_> for files the story is more complicated
11:52:56 <hpaste>  glguy annotated "first draft calling pygments" with "Python calls just keep getting better" at http://hpaste.org/5913#a5
11:53:32 <dino-> dcoutts_: Does cabal log somewhere when there's failure?
11:53:51 <dcoutts_> dino-: only to the screen atm, we're implementing build reporting
11:54:01 <dino-> hm, it fails to install binary for me
11:54:06 <byorgey> glguy: what are you working on?  an FFI interface for python?
11:54:12 <dino-> With nothing other than 'failed during final step'
11:54:19 <dino-> To my ~ (defaulting to --use)
11:54:24 <dino-> (--user)
11:54:29 <byorgey> ...er... with an... ATM machine, and... a PIN number?
11:54:51 <dcoutts_> dino-: you can run with -v or -v2 or -v3 for more verbose debug output
11:55:01 <dino-> ok, I'll go through the trac stuf too in more detail
11:55:30 <shreedhar> hmm.. right. so a func which takes in a no and returns it's factorial is pure while a function like fread in side-effectual
11:55:34 <dcoutts_> dino-: I added the stuff about describing which phase failed recently, I'm going to change it so that it also shows the specific exception
11:55:36 <dolio> byorgey: Looks like he's using a Python library (pygments) to color stuff on hpaste2.
11:55:50 <shreedhar> thanks guys :)
11:56:01 <raxas> gwern: when you run terminal on your not-so-broken cell phone or pda, and connect to your haskell app somewhere else, does it honor utf8?
11:56:42 <byorgey> dolio: yes, but I'm looking at things like call0WithKeywords
11:56:44 <gwern> raxas: I have no idea. I've never tried that
11:56:50 <byorgey> I'm assuming glguy wrote that
11:57:28 <dino-> dcoutts_: Ok, I appreciate all the help
11:59:31 * dolio notes that in Agda, you could write 'from_import_ = fromImport' and later write: 'from "pygments" import "highlight"'.
12:00:31 <byorgey> dolio: arbitrary mixfix operators?  neat!
12:00:39 * byorgey needs to play with Agda at some point...
12:00:43 <dolio> Yeah, it's pretty sexy.
12:00:48 <dolio> Although it has its issues.
12:01:01 <byorgey> dolio: doesn't everything? =)
12:01:11 <dolio> Yeah.
12:01:42 <birkenfeld> hey, who's using pygments here?
12:01:44 <dolio> if_then_else_ is another cool one. No need to special case that.
12:02:31 <byorgey> birkenfeld: glguy, it looks like
12:02:40 <birkenfeld> nice :)
12:02:47 <byorgey> for hpastetwo
12:03:13 <glguy> byorgey: yeah, for hpastetwo
12:03:15 <birkenfeld> glguy: if there are issues with pygments, contact me
12:03:20 <glguy> python interface for nice calling to pygments
12:03:25 <glguy> birkenfeld: you author?
12:03:28 <birkenfeld> yep
12:03:32 <glguy> awesome sauce
12:03:41 <glguy> yeah, that library rocks so hard I wrote bindings to python to call it
12:03:41 <shapr> birkenfeld: How'd you end up on #haskell?
12:03:53 <birkenfeld> well, it's a cool language
12:03:59 <dolio> Perhaps he's about to make hygments? :)
12:04:01 <shapr> Heh, I agree :-)
12:04:11 <shapr> birkenfeld: Good reason!
12:04:14 <dino-> Hey, shapr
12:04:20 <birkenfeld> dolio: as soon as I find well-performing regexes in haskell...
12:04:22 <shapr> Lots of languages are cool, I like to learn programming languages.
12:04:24 <glguy> birkenfeld: I plan on wrapping up the binding and making a pygments calling library for haskell
12:04:27 <shapr> dino-: Hiya! Long time no see.
12:04:43 <shapr> dino-: If you'll step over to #haskell-blah, I'll ask what's been happening to you lately.
12:05:02 <Cale> birkenfeld: There's a reasonable regex library which comes with GHC, but most people just write Parsec parsers.
12:05:17 <glguy> dons has that pcre-light library
12:05:32 <birkenfeld> I'll have to look into it at some time
12:06:03 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Text
12:06:05 <lambdabot> http://tinyurl.com/yqov7f
12:06:30 <glguy> if anyone wants to see where I'm going with th epython stuff, the full code in in the hpaste repo
12:06:34 <glguy> LUNCH!
12:09:13 <DQuest> Lunch? At 8pm?
12:09:28 <DQuest> Crazy foreigners and their crazy timezones
12:11:15 <lelf> /q sleep
12:13:52 <pcc1> anyone know about hs-plugins?  I'm getting "unknown symbol" errors for symbols in my own code (linked into the executable), but not for the standard library, packages etc.  e.g. "Foo.o: unknown symbol `XYZ_myFunc_closure' \n user error (resolvedObjs failed.)"
12:15:38 <tack-work> Lunch? At 2pm? Crazy west coasters and their crazy timezones.
12:16:07 <DQuest> Lunch is clearly an event that *ends* at 2pm, having started at 12pm
12:18:23 <tack-work> The good lunches anyway
12:19:08 <resiak> @type System.IO.Error.try -- <-- quicksilver, :-)
12:19:11 <lambdabot> forall a. IO a -> IO (Either IOError a)
12:19:34 <resiak> helps with threading ErrorT into IO!~
12:20:39 <smg> in what language is haskell implemented it?
12:20:48 <smg> if i want to write a library for it?
12:21:10 <dolio> Haskell.
12:21:23 <tack-work> You can write libraries in Haskell or using the very nice FFI
12:22:02 <tack-work> ghc, at least, is bootstrapped, so you can even say that GHC-Haskell is written in Haskell :-)
12:22:33 <dons> are there languages where the libraries aren't written in the same language?
12:22:54 <dons> smg, to get a sense of what libraries are like, check hackage.haskell.org
12:23:46 <tack-work> dons: Aren't many important libraries in any language just wrappers around C libraries? =-P
12:24:00 <dons> sometimes, yes.
12:24:12 <dons> but you don't start by writing in C.
12:24:14 <jbms> dons: Tcl, perhaps, is one example... :)
12:24:18 <smg> haha okay
12:24:21 <smg> i hoped it was in C :|
12:24:41 <dons> smg, you can write C code, and use it from Haskell. but that kind of defeats the point of using haskell
12:24:52 <dons> what library do you want to write?
12:27:06 <Cale> anyone happen to know how to tell lambdabot to join a channel with a given password?
12:27:15 <Cale> Does the join command take another parameter?
12:27:35 <smg> dons: some function collection maybe
12:28:14 <Lemmih> smg: That's pretty much the definition of a library.
12:28:20 <dons> smg, a function collection? to do what?
12:29:28 <smg> dons: mathematic functions
12:30:42 <dons> oh, a math lib. well, its probably a good idea to do them in haskell first, then optimise any slow ones in C.
12:30:50 <tack-work> If it's matrix and vector type stuff, Haskell has better support than C (read: it *has* support for those things). C would only be useful for mad speed and mad bittwiddling
12:30:52 <dons> since its a *lot* easier to get the math right in haskell
12:31:14 <opqdonut> and rewrite rules rock <3
12:31:19 <dons> check the current math libs for idea,s  http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Math
12:31:21 <lambdabot> http://tinyurl.com/yqov7f
12:31:36 <dons> opqdonut: i wonder: has anyone got some math identity rewrite rules
12:31:38 <smg> btw  is it stupid?
12:31:50 <opqdonut> dons: soc project looming ahead?
12:31:54 <smg> i guess no one will care for that because everyone can define for example "ackermann" function on his own?
12:31:59 <opqdonut> :P
12:32:10 <Baughn> smg: ..who would want to?
12:32:28 <smg> Baughn: what?
12:32:29 <dons> smg, oh, sequences? a collection of sequences written in haskell might be fun
12:33:09 <Baughn> smg: I wonder if it would be possible to (in reasonable time) print large values ackerman's function - lazily
12:33:35 <smg> hehe
12:33:39 <dons> smg, maybe try solving some of the euler problems in haskell?
12:33:40 <Baughn> Doesn't seem like it, but it'd sure be neat.
12:33:51 <smg> ackermann 100 100 nearly killed my mashine :D
12:34:07 <DQuest> not entirely surprised :P
12:34:20 <tack-work> smg: hehehe, ackermann does that
12:35:06 <Baughn> smg: See, that's why it needs to be lazy, so you can GC the big digits before getting to the small ones
12:35:09 <dons> ?let ack :: Int -> Int -> Int ; ack 0 n = n+1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1))
12:35:11 <lambdabot> Defined.
12:35:17 <dons> > ack 3 4
12:35:20 <lambdabot>  125
12:35:31 <tack-work> > ack 100 100
12:35:37 <lambdabot> Terminated
12:35:50 <Baughn> >ack 4 0
12:35:52 <Baughn>  >ack 4 0
12:35:56 <Baughn> > ack 4 0
12:35:57 <lambdabot>  13
12:36:03 <dolio> That won't blow up because Int doesn't use unbounded amounts of space.
12:36:10 <Baughn> > ack 42 0
12:36:16 <lambdabot> Terminated
12:36:19 <dons> ?undefine
12:36:19 <lambdabot> Undefined.
12:36:23 <SimonRC> inspired by something said elsenet...
12:36:30 <dons> ?let ack 0 n = n+1 ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1))
12:36:30 <lambdabot> Defined.
12:36:42 <IsoPallo> I hate to be ignorant, but how does one "map" an action to a list? Like, not actually map ofcourse, but repeat the action for each element in sequence...
12:36:45 <smg> Baughn: haha okay
12:36:46 <SimonRC> Do the docs say anywhere whether array indices are inclusive or exclusive?
12:37:01 <dons> IsoPallo: its a loop, that applies a function to each element
12:37:02 <Baughn> IsoPallo: Like mapM does, perhaps?
12:37:03 <mauke> no idea but they're inclusive
12:37:04 <dons> ?src map
12:37:04 <lambdabot> map _ []     = []
12:37:04 <lambdabot> map f (x:xs) = f x : map f xs
12:37:16 <Baughn> IsoPallo: Define "action"
12:37:22 <dons> ?src mapM_
12:37:22 <lambdabot> mapM_ f as = sequence_ (map f as)
12:37:32 <SimonRC> odd, but it seems untidy
12:37:33 <dons> mapM_ print [1..10]
12:37:36 <SimonRC> I wonder why
12:38:06 <mauke> SimonRC: The bounds are specified as a pair of the lowest and highest bounds in the array respectively.
12:38:21 <IsoPallo> Baughn: I mean like putStrLn
12:38:33 <SimonRC> but the size of the array is then (high - low + 1)
12:38:36 <IsoPallo> Thanks.
12:38:39 <SimonRC> I don't really like that +1
12:38:41 <mauke> SimonRC: no
12:38:51 <SimonRC> huh?
12:38:51 <mauke> array bounds don't have to be ints
12:39:04 * SimonRC slaps his forehead
12:39:04 <mauke> in general, you can't do high - low
12:39:07 <smg> wb mauke
12:39:12 <smg> your webspace was down :\
12:39:15 <Baughn> IsoPallo: mapM, mapM_.. in Control.Monad; ask lambdabot for the source so you can understand them.
12:39:22 <mauke> smg: sorry, that's my home pc :-)
12:39:29 <SimonRC> of course, suppose we were indexing on Booleans
12:39:33 <smg> mauke: haha should i give you webspace + domain? <:
12:39:49 <smg> where can i group with { }  and ; ?
12:39:58 <opqdonut> everywhere
12:40:00 <SimonRC> there is no exclusive bound corresponding to an inclusive bound of True
12:40:06 <mauke> smg: I don't feel ready for a "real" website yet :-)
12:40:18 <SimonRC> smg: after let, do, where, and of, I think
12:40:27 <SimonRC> not after function calls
12:40:48 <mauke> SimonRC: it gets worse with multidimensional arrays
12:40:54 <SimonRC> yup
12:41:03 <smg> can i somewhere lookup that?
12:41:09 <SimonRC> in fact, the spec defines the constructs in terms of {;} and gives rules for deriving them from layout
12:41:34 <sethk> all, I'm getting a strange error on make install for ghc-6.8.2:  ghc-pkg.bin: HOME: getEnv: does not exist (no environment variable)
12:41:36 <smg> k
12:41:40 <sethk> HOME is defined
12:42:01 <SimonRC> is it exported from your shell?
12:42:08 <Baughn> sethk: Did you define it yourself? unset at some point?
12:42:10 <sethk> SimonRC, yes, shows up in export
12:42:18 <SimonRC> smg:  The exact layout rules are here   http://haskell.org/onlinereport/syntax-iso.html#layout
12:42:19 <sethk> Baughn, no, it's always set up by the shell
12:42:37 <Baughn> sethk: I've seen weirder setups
12:42:48 <sethk> Baughn, I'll try    make HOME=whatever install
12:43:01 <smg> thanks
12:43:03 <sethk> Baughn, wait, I think I see the problem ...
12:43:40 <sethk> it was a sudo issue.  odd.
12:44:27 <Baughn> sethk: Too tight restrictions in /etc/sudoers, then - that happens too
12:44:46 <sethk> Baughn, yes, once I saw it, then it's obvious.  :)
12:44:55 <Baughn> Though normally it just changes $HOME, not /unset/
12:46:06 <sethk> Baughn, it is strange, but it works with su, and not with sudo, so it has to be related to sudo config
12:52:02 <SimonRC> sethk: unless it is to do with root's .bashrc
12:52:05 <SimonRC> or similar
12:52:35 <tack-work> what does it mean to export a variable to a shell?
12:52:42 <tack-work> that was one thing I never quite understood
12:53:06 <Baughn> tack-work: Environment variables are automatically copied to any children a process forks
12:53:29 <sethk> SimonRC, don't use bash, but the idea holds.  Thing is, the init scripts are basically ok since if I su to root things are set up correctly.  That's not 100%, but it's likely.
12:53:36 <Baughn> tack-work: But most shells have the ability to define variables that /aren't/ environment variables, though they act like they are inside the shell. Exporting it means making it a proper environment variable.
12:54:08 <Baughn> tack-work: Anyway, if not exported, it goes away when the shell executes a process - the process doesn't see it
12:54:32 <SimonRC> sethk: no, I mean that sudo doesn't execute them but su does, so maybe something relies on something in an init script
12:54:38 <tack-work> Ah, I get it. So if you define them in the shell's toplevel (as opposed to in a script), then do you still need to export them? Or do they only live until the end of the session?
12:54:39 <dino-> This seems not unlike using local in a Reader computation to modify the env
12:54:45 <SimonRC> or the script is broken, if the other way round
12:55:00 <Baughn> SimonRC: Sudo automatically sanitizes environment variables, though. If that's set too tightly, this happens
12:55:10 <SimonRC> ok
12:55:23 <Baughn> tack-work: They stay around, *in that shell*. Not in subshells, nor in any other subprogram.
12:55:39 <Baughn> tack-work: If you export, they'll be in any subshells/other subprograms (same thing)
12:55:49 <tack-work> oh cool
12:55:53 * tack-work has learned
12:56:00 <cin> bringert: ping
12:56:05 <smg> mh
12:56:06 <bringert> hi cin
12:56:11 <smg> how can i split a string at the .
12:56:14 <smg> like "foo.bar"
12:56:27 <Baughn> @src words
12:56:28 <lambdabot> words s = case dropWhile isSpace s of
12:56:28 <lambdabot>     "" -> []
12:56:28 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
12:56:50 <Baughn> ..I really think words should be defined in terms of splitBy
12:56:54 <tack-work> also, what does ! do in Bash's toplevel? Our root sql password at work has a ! in it, and it took me a few minutes before I figured out why I was getting an error, and escaped it.
12:57:17 <lament> that's odd... what's your root password exactly?
12:57:24 <bringert> haha
12:57:27 <dolio> @hoogle splitBy
12:57:27 <lambdabot> No matches found
12:57:38 <smg> Baughn: words??
12:57:40 <tack-work> lament: it's haha!goodone
12:57:45 <Baughn> tack-work: You may want to take this to #bash
12:57:50 <cin> bringert: i'm trying to follow your Practical Web Programming in Haskell tutorial, but for fastcgi. do you have any example code that does this? that is, defining a monad as a class of MonadCGI and running it. i can't seem to get it right at all
12:57:57 <smg> Baughn: that won't split
12:58:03 <conal> > break (== '.') "foo.bar"
12:58:05 <cschneid_> tack-work, not that this is a bash channel, but ! is the start to a whole bunch of history commands.  Like !! is the last command you ran, !$ is the last arg of the previous command and so on
12:58:11 <cin> bringert: s/class/instance
12:58:16 <lambdabot>  ("foo",".bar")
12:58:24 <Baughn> smg: Words splits by space. Lines splits by newline. The idea that those shouldn't be calling the same function seems.. odd.
12:58:26 <tack-work> baughn: aw. ok. Just trying to milk the knowledged guys in #haskell for as much as I can while I toil at work
12:58:28 <laura85> hi everyone ^^
12:58:31 <ttfh> does anybody know what's going on with happs.org?
12:58:34 <smg> i need to split at dot
12:58:37 <smg> not at newline / space
12:58:45 <smg> break :)
12:58:51 <conal> smg: break
12:58:58 <bringert> cin: why do you need your own monad?
12:58:59 <Baughn> tack-work: Heh. Sorry to say, I never bothered to figure out what ! does. *blush*
12:59:01 <sethk> smg, you can use regex
12:59:07 <tack-work> :t splitBy
12:59:08 <lambdabot> Not in scope: `splitBy'
12:59:10 <tack-work> aw
12:59:12 <tack-work> :t break
12:59:12 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:59:15 <smg> i can
13:00:16 <sethk> i believe ! is a bidirectional pipe
13:01:24 <piojo> @users
13:01:24 <lambdabot> Maximum users seen in #haskell: 463, currently: 446 (96.3%), active: 25 (5.6%)
13:02:29 <smg> okay
13:02:49 <cin> bringert: sorry about that. we had a powercut. did you say anything?
13:03:03 <bringert> cin: why do you need your own monad?
13:03:19 <cin> bringert: i mean the ReaderT monad transformer
13:03:28 <cin> bringert: for storing database and session information
13:03:58 <bringert> cin: are you looking at this version: http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell
13:03:59 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki, http://tinyurl.com/2n99cj
13:04:04 <bringert> cin: that has some example code
13:04:05 <cin> bringert: yeah
13:04:18 <Baughn> @hoogle words
13:04:19 <lambdabot> Prelude.words :: String -> [String]
13:04:19 <lambdabot> Data.List.words :: String -> [String]
13:04:19 <lambdabot> Data.ByteString.Char8.words :: ByteString -> [ByteString]
13:04:39 <laura85> in today's lecture, i've learnt that two versions of a global function funky can coexist, if they're written one after another with no function between them. why's that and what's it good for?
13:04:53 <smg> okay
13:04:53 <smg> withSuffix suffix = filter (\x -> snd (break (== '.') x ) == suffix)
13:04:57 <smg> can i tune that function a bit?
13:05:29 <dcoutts> laura85: it's actually the same function, just two clauses of it
13:05:40 <dcoutts> foo [] = ...
13:05:45 <ttfh> laura85: 2 versions? isn't it the same function?
13:05:45 <dcoutts> foo (x:xs) = ...
13:06:18 <laura85> dcoutts, that's what i didn't get ^^
13:06:21 <dcoutts> laura85: that defines one function foo, defined with two cases
13:06:38 <Baughn> laura85: Same function. It works almost, but not quite, like one function declaration with a top-level case statement - try to define two with different types, and you'll see.
13:06:56 <dcoutts> laura85: so depending on the shape of the input it matches one case or the other
13:07:33 <laura85> dcoutts, so if the signature stays, everything is ok?
13:08:34 <Baughn> laura85: Only one will actually execute, of course, so they're tried in the order you specify them - as I said, almost like a case. It's just a bit of handy syntax.
13:08:34 <ttfh> Baughn: will there be a difference if you define the function using "f x = case x of ..."?
13:08:36 <smg> can we tune it?
13:08:37 <dcoutts> laura85: I'm not sure I know what you're getting at, do you mean the type signature?
13:09:00 <cin> @pl withSuffix suffix = filter (\x -> snd (break (== '.') x ) == suffix)
13:09:00 <lambdabot> withSuffix = filter . (. (snd . break ('.' ==))) . (==)
13:09:01 <Baughn> ttfh: I think there's something to do with strictness and/or type inference details, but others would know better
13:09:04 <dcoutts> Baughn: most people get taught that syntax before 'case'
13:09:15 <Baughn> dcoutts: I came here from Erlang
13:09:20 <smg> cin: haha wow
13:09:21 <laura85> dcoutts, yup
13:09:38 <ttfh> I had a feeling it would be something about strictness..
13:09:39 <laura85> Baughn, dcoutts, thanks a lot ^^
13:09:40 <dcoutts> laura85: the type signature is optional
13:09:48 <smg> the guy who wrote lambdabot must be a genius
13:09:52 <laura85> oh ok
13:10:02 <Baughn> smg: "the"?
13:10:06 <smg> cin: what does pl mean
13:10:09 <resiak> pointless
13:10:13 <smg> ah
13:10:14 <Baughn> pointsfree
13:10:24 <smg> yeah pointless is something different ;)
13:10:25 <dcoutts> laura85: the type signature can be used to restrict the type of the function, and it serves as useful documentation
13:10:39 <cin> paliolithic
13:10:49 <ttfh> perl
13:11:49 <smg> perl is cool
13:11:56 <allbery_b> hrrrrm
13:12:06 <allbery_b> trying (still!) to build ghc 6.8.2 on sparc
13:12:08 <gnuvince> @seen smg
13:12:08 <lambdabot> smg is in #haskell and #ghc. I last heard smg speak 19s ago.
13:13:08 <smg> @seen gnuvince
13:13:08 <lambdabot> gnuvince is in #haskell. I last heard gnuvince speak 1m ago.
13:13:14 <allbery_b> 6.8.2 stage1 compiler being used to build base library causes assembler errors about sparcv9 instructions vs. (default) sparcv8 architecture.  shouldn't ghc be passing model options if it's going to generate sparcv9 code?
13:13:26 <gnuvince> smg: I was wondering if you were on #perl6 and I was too lazy to join to check it out :)
13:13:28 <cschneid_> what is pointsfree?  I've seen it a few times, but don't have any idea what it is
13:13:31 <tack-work> @seen dons
13:13:31 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 35m 58s ago.
13:13:56 <tack-work> cschneid_: pointfree is a style of programming where you don't specify the names of the parameters in the definition
13:14:09 <smg> gnuvince: hehe atm i have no time for any other language, i need to learn haskell :|
13:14:15 <tack-work> for example, plusOneToAll = map (+1)
13:14:24 <tack-work> @let plusOneToAll = map (+1)
13:14:25 <lambdabot> Defined.
13:14:29 <tack-work> > plusOneToAll [1,2,3]
13:14:31 <lambdabot>  [2,3,4]
13:14:53 <tack-work> (plusOneToAll is a function of 1 parameter, even though when I defined it above with let, I didn't say it had a variable)
13:15:17 <cschneid_> tack-work, is that a good thing?  Where would I prefer that over defining    plusOne n = map (+1) n   - in this case, it's clearer pointsfree, but the one asked of the lambdabot was more verbose/confusing (to me at least)
13:15:23 <tack-work> but since map expects two arguments, and I only gave it one, the expression "map (+1)" is still "waiting" for an additional argument before it can be evaluated
13:15:42 <Baughn> cschneid_: Pointsfree style is easier when you think about altering /functions/, instead of values
13:15:43 <tack-work> pointfree is not exactly the best practice, but it's an interesting idea
13:15:50 <Baughn> cschneid_: It gets more natural after a while
13:15:50 <smg> @pl genSieve n = take n $ nubBy(((>1).).gcd)[2..]
13:15:50 <lambdabot> genSieve = ($ nubBy (((> 1) .) . gcd) [2..]) . take
13:16:03 <tack-work> in most cases, you should specify the extra parameter unless it's very clear otherwise
13:16:06 <smg> mh
13:17:04 <smg> mates, i find it hard to read that "hardcore pointfree" style
13:17:11 <smg> is this okay? :)
13:17:13 <tack-work> Pointfree coding is basically just an abuse of Currying.
13:17:27 <tack-work>  @pl is mostly there for kicks, and doesn't often yield practical results
13:17:46 <smg> @pl pythagoras x y = sqrt (x^2 + y^2)
13:17:46 <lambdabot> pythagoras = (sqrt .) . (. (^ 2)) . (+) . (^ 2)
13:17:51 <smg> hahahaha!
13:17:55 <cschneid_> heh, that's pretty awesome...
13:18:00 <cin> valid perl code
13:18:11 <tack-work> sometimes @pl can help you figure out a shorter way to write something, but usually it just plays a round of "Perl Golf" by itself
13:18:16 <Baughn> @. pl undo \list -> do { foo <- list; return (foo * 2) }
13:18:16 <lambdabot> ((2 *) `fmap`)
13:18:27 <Baughn> Sometimes, pl can be handy. ;)
13:18:29 <smg> sometimes it also plays not golf it enlarges code :D
13:18:31 <tack-work> @pl (.) (.)      -- the boobie operator
13:18:31 <lambdabot> ((.) .)
13:18:38 <smg> haha
13:18:57 <resiak> hmm, could @pl be made to prefer <$>?
13:19:00 <smg> @pl cubic n = n*n*n
13:19:00 <lambdabot> cubic = (*) =<< join (*)
13:19:01 <laura85> hm, why does this not work: otp :: [Bool] -> [Bool] -> [Bool] /newline otp [key] [msg] = (map xor) . zip [key] [msg]? (where xor :: Bool -> Bool -> Bool)
13:19:17 <gnuvince> :t plusOneToAll
13:19:20 <lambdabot> Not in scope: `plusOneToAll'
13:19:20 <Baughn> > ((2*) `fmap`) [1..2]
13:19:21 <lambdabot>  [2,4]
13:19:25 <dolio> > let pythagoras = curry $ sqrt . uncurry (+) . join (***) (^2) in pythagoras 3 4
13:19:25 <smg> so what do people prefer? cubic n = n*n*n or cubic = (*) =<< join (*) ?
13:19:26 <lambdabot>  5.0
13:19:38 <gnuvince> smg: the former
13:19:38 <smg> wtf is *** ?
13:19:49 <Baughn> smg: How about "cubic n = n^3"?
13:19:53 <dolio> > (succ *** pred) (3, 4)
13:19:54 <lambdabot>  (4,3)
13:20:01 <smg> because YAHT adviced me that pointfree style is the best technique
13:20:04 <gnuvince> :t (***)
13:20:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:20:11 <smg> <interactive>:1:0: Not in scope: `***'
13:20:21 <dolio> smg: import Control.Arrow
13:20:25 <byorgey> smg: taken to an extreme, of course, pointfree style can be silly.
13:20:26 <smg> k
13:20:32 <Baughn> smg: Of course, and category theory is the best branch of math
13:20:45 <dolio> smg: For the time being, all you have to know is that (f *** g) (x, y) = (f x, g y).
13:20:45 <smg> i just can't write that hardcore pointfree code
13:20:54 <resiak> laura85: you mean otp key msg = zipWith xor key msg
13:21:01 <smg> i try to write pointfree + eta reduce but @pl of lambdabot ist really hardcore for me :\
13:21:06 <Baughn> @unpl map (+2)
13:21:06 <lambdabot> map (\ a -> a + 2)
13:21:07 <resiak> laura85: [key] means "the list containing one element, namely key"
13:21:08 <smg> 1. to understand 2. to produce on my own
13:21:21 <byorgey> smg: in other words, (f *** g) is a function which applies f to the first element of a pair, and applies g to the second element
13:21:27 <smg> ok
13:21:45 <smg> btw what are the major benefits of that pointfree style?
13:21:54 <TheChris> It's so cool!
13:22:17 <resiak> laura85: and xor has type Bool -> Bool -> Bool, but it would need to have type (Bool, Bool) -> Bool for map xor (zip key msg) to work
13:22:22 <Baughn> smg: It can make code cleaner and easier to read
13:22:27 <resiak> laura85: (cf. uncurry)
13:22:36 <byorgey> smg: it allows you to view functions and programs as a sort of pipeline for transforming data
13:22:37 <smg> yeah but extreme pointfree won't?
13:22:39 <Baughn> smg: Think "\a -> a + 2" vs. "(+ 2)" - the latter is pointsfree
13:22:50 <Baughn> Well. Sort of.
13:22:50 <cschneid_> I love asking questions in #haskell.  Something so short as "what is pointsfree" gets 10 pages of people talking about it, asking lambdabot to do extra-complex things, and all in all, derailing a channel.  EVERY TIME
13:22:57 <byorgey> smg: which usually makes the underlying structure much clearer (once you are used to it)
13:22:59 <laura85> resiak, thanks, that was it ^^
13:23:09 <Baughn> cschneid_: We're still talking about haskell, so it hasn't derailed. ^_^
13:23:11 <byorgey> smg: and it's often easier to simplify and reason about.
13:23:13 <resiak> laura85: also, it seems  . doesn't do what you thought it does
13:23:27 <smg> yeah but cubic = (*) =<< join (*) for example is pointfree
13:23:33 <smg> but it's harder to read
13:23:34 <cschneid_> Baughn, ok, redirected?  I'm like one of those levers on the train tacks.  Not derails, but now you're headed for Denver and not Chicago
13:23:41 <Baughn> smg: Yeah. That's /not/ a good use of the style.
13:23:45 <laura85> resiak, i thought . is  like (g o f)(x)
13:23:50 <resiak> laura85: it is
13:24:03 <Baughn> cschneid_: We'll never arrive anyway
13:24:05 <tack-work> that's exactly what it is
13:24:14 <cschneid_> Ahh... amtrak.
13:24:17 <resiak> laura85: (g . f) x = g (f x)
13:24:35 <resiak> laura85: what you wrote, though, was roughly:    map f . zip xs ys
13:24:39 <smg> okay i see
13:24:44 <tack-work> > let add6 = (+1) . (+2) . (+3) in add6 0
13:24:44 <lambdabot>  6
13:25:01 <Baughn> tack-work: Now prove that that function is correct
13:25:08 <byorgey> cschneid_: that's the beauty of it.  we all just get to ride around on this train together all day, with no particular destination. =)
13:25:17 <tack-work> prove which function is correct?
13:25:21 <resiak> laura85: which is equivalent to  \z -> map f ((zip xs ys) z)  by definition, which isn't going to work: zip only takes two arguments
13:25:21 <cschneid_> byorgey, fun ride though.
13:25:23 <tack-work> add6?
13:25:28 <Baughn> tack-work: Ayip
13:25:47 <tack-work> I don't need to prove it. I will simply leave it as an excercise for the reader
13:26:13 <byorgey> hmm, maybe #haskell is more like a roller coaster than a train, come to think of it. ;)
13:26:28 <byorgey> tack-work: proof by exercise for the reader, excellent!
13:26:43 <dolio> That's how the big boys do things.
13:26:45 <TheChris> Perhaps a runaway mine train.
13:26:45 <smg> cschneid: so true this channel is awesome
13:26:49 <byorgey> an underappreciated method of proof
13:26:52 <laura85> resiak, oh ok hm... but with functions zip, map, xor  how would i have to implement otp?
13:26:58 <hpaste>  joglala pasted "it seems hugs doesn't like the Dir =>" at http://hpaste.org/5930
13:27:18 <tack-work> @pl (+1) . (+2) . (+3)
13:27:18 <lambdabot> (6 +)
13:27:23 <tack-work> there, proof by @pl
13:27:24 <joglala> i compare two varibales of type Dir
13:27:29 <byorgey> tack-work: hehe
13:27:39 <joglala> And have the Eq Dir =>, but haskell does not want it
13:27:49 <Baughn> tack-work: I accept your proof, provided you prove that @pl works correctly
13:28:01 <byorgey> joglala: I think Dir needs to be lowercase
13:28:09 <tack-work> @check \x -> let add6 = (+1) . (+2) . (+3) in add6 x == 6 + x
13:28:10 <lambdabot>  Add a type signature
13:28:21 <byorgey> joglala: type variables are lowercase, type names and constructors are uppercase
13:28:24 <tack-work> @check (\x -> let add6 = (+1) . (+2) . (+3) in add6 x == 6 + x) :: Integer -> Bool
13:28:24 <lambdabot>  OK, passed 500 tests.
13:28:32 <Baughn> That is not proof. -_-
13:28:34 <tack-work> ^ Proof by science
13:28:48 <Baughn> Proof by lack of many examples? >_>
13:28:54 <tack-work> It works for science
13:29:15 <byorgey> joglala: oh, and you also want to have 'deriving (Show, Eq)' after the 'data Dir' declaration.
13:29:16 <Baughn> Okay, so we now have a scientific theory stating that your function adds six
13:29:17 <nominolo> science has no proves
13:29:20 <nominolo> only theory
13:29:25 <tack-work> Prove it :-)
13:29:49 <Baughn> nominolo: That is true for /everything/, though
13:29:56 <Baughn> Might as well redefine "proof" as "almost certainly true"
13:29:57 <hpaste>  byorgey annotated "it seems hugs doesn't like the Dir =>" with "make Dir derive Eq" at http://hpaste.org/5930#a1
13:30:04 <byorgey> joglala: forget what I said about making Dir lowercase
13:30:05 <ttfh> is there some templatehaskelly way of splicing locations into code? (x = "x was defined on line " ++ $magic_stuff_goes_here)
13:30:25 <nominolo> Baughn: a mathematical proof has certain assumptions.  but under those it's true
13:30:26 <byorgey> joglala: putting Eq Dir => before a function does not make it so, you must make an instance of Eq for Dir, or have the compiler derive it for you
13:30:33 <Baughn> ttfh: You could use the cpp extension and __LINE__
13:30:52 <Baughn> nominolo: GRanted, but one of those assumptions is "our brains work correctly", which is unprovable
13:30:54 <doserj> joglala: but you don't actually need an instance of Eq for Dir
13:30:59 <smg> @pl mycount x = length . filter (==x)
13:30:59 <lambdabot> mycount = (length .) . filter . (==)
13:31:09 <Baughn> nominolo: There are certainly plenty of counterexamples, even in math
13:31:13 <joglala> doserj: I does not work with the Eq Dir =>
13:31:24 <ttfh> Baughn: there's a ghc option for running cpp on the source? ok
13:31:25 <doserj> joglala: you could just pattern match on Dir
13:31:50 <byorgey> joglala: did you see my annotation to your paste?
13:32:05 <doserj> isPath [L] (Node a Empty _) = False
13:32:13 <byorgey> ah, yes, you could also just pattern-match
13:32:23 <joglala> byorgey: That i don't have to make it lowercase?
13:32:54 <byorgey> joglala: http://hpaste.org/5930#a1
13:33:03 <joglala> Ok, then i pattern match
13:33:06 <resiak> laura85: it's probably easiest to look at the types.  you were on the right lines as to the shape of the function.  first, what type does zip key msg have?
13:33:20 <smg> @pl f x = foldr (*) 1 [1..x]
13:33:20 <lambdabot> f = foldr (*) 1 . enumFromTo 1
13:33:47 <smg> ah that makes sense
13:34:20 <joglala> byorgey: yes, i corrected that, cool
13:34:27 <laura85> resiak, zip key msg  has return type: [(Bool, Bool)]
13:34:30 <joglala> Then i don't even have to pattern match
13:34:40 <tack-work> (+1) . (+2) . (+3) = \x -> (((+1) . (+2)) . (+3)) x (by def of composition) = \x -> ((+1) . (+2)) (x+3) (redex) = \x -> (+1) (2+ (x+3)) (by def of composition) = \x -> (+1) (5+x) (by arithmetic) = \x -> (1 + (5+x)) (by reduction) = \x -> 6 + x (by arithmetic) = (+6) (by the grace and glory of Haskell's section syntax)
13:34:54 <tack-work> OMGQED
13:35:24 <smg> tack lol
13:36:41 <byorgey> joglala: you can either pattern-match, or have the compiler derive an Eq instance.  In this case I think pattern-matching is actually easier, as doserj pointed out.
13:36:47 <laura85> resiak,  i found my problem. i thought  otp :: [Bool] -> ... is otp [key] [msg] instead of otp key msg
13:37:03 <laura85> i'm such a rookie
13:37:04 <resiak> okay, i'll leave you to it :)
13:37:21 <byorgey> joglala: instead of isPath (x:[]) (Node a Empty _) | x == L = False, you can just say  isPath [L] (Node _ Empty _) = False
13:37:26 <byorgey> see? much simpler =)
13:37:32 <resiak> (if xor :: Bool -> Bool -> Bool, you'll still need uncurry to make it work)
13:37:35 <joglala> byorgey: But all works with "deriving(Eq, Show)
13:37:44 <joglala> I don't have to do more
13:37:48 <cschneid_> I'm reading about quickcheck, would it be right to call it "invariant testing"?
13:38:04 <dons> cschneid_: or property based testing
13:38:10 <byorgey> joglala: well, some people like to make their code as simple as possible ;)
13:38:23 <joglala> uhmm
13:38:36 <byorgey> joglala: it's up to you, of course =)
13:38:42 <dons> cschneid_: i.e. generalising unit tests by abstractive over some components of the test, yielding general invariants that should hold
13:38:52 <joglala> Its only to learn some basic haskell
13:38:54 <dons> its great for testing for runtime invariants you can't enforce in the type system easily
13:42:32 <schemelab> it is sensible for all the haskell tutorials to introduce I/O before thoroughly teaching monads?
13:42:45 <monochrom> Yes.
13:42:50 <laura85> resiak, thanks again ^^
13:42:51 <schemelab> why is that?
13:42:53 <Baughn> No, but humans aren't sensible
13:43:03 <dcoutts> schemelab: you can understand it intuitively without needing to understand monads in general
13:43:10 <schemelab> I see
13:43:27 <monochrom> It is sensible for all education systems to introduce whole number and counting before thoroughly teaching logic, Peano induction, rings, fields, ...
13:43:28 <Baughn> schemelab: If it wasn't introduced early, the readers would give up in disgust
13:43:38 <ceibe> schemelab, understand monads can take some time, it's better know before how to do I/O
13:43:38 <dcoutts> schemelab: it just looks like a little imperative sub-language which is a reasonable first approximation
13:43:39 <olsner> "monads" make people scared, I/O is what they expect to get to first in order to implement Hello World
13:43:40 <laura85> resiak, (just btw, i redefined xor to xor :: (Bool, Bool) -> Bool)
13:43:58 <monochrom> Teaching monads before IO is like teaching category theory before 0,1,2,3.
13:44:17 <dino-> Baughn: I suspect that's true, without the ability to do anything outside of an interactive system like ghci.
13:44:36 <monochrom> America tried to teach set theory before 0,1,2,3 in the 1960s or something, I heard, and it failed.
13:44:56 <monochrom> Concrete before abstract.  IO before monads.
13:45:00 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5931
13:45:14 <tack-work> I don't think I've ever found knowing what a monad is all that helpful to writing code anyway
13:45:22 <monochrom> It is so obvious that I don't understand why some people even contemplate the opposite.
13:45:22 <resiak> laura85: take a look at curry and uncurry
13:45:42 <laura85> resiak, ok ^^
13:45:44 <resiak> laura85: if f :: a -> b -> c, uncurry f :: (a, b) -> c
13:45:47 <tack-work> as long as you understand how the types interact with do-noation and how return works. Even >>=, you can save for a bit later
13:46:14 <resiak> laura85: so with your original definition of xor, you could have written otp key msg = map (uncurry xor) (zip key msg)
13:47:28 <Baughn> monochrom: Because, to an AI, the concrete would be merely a cached derivation of the abstract. Possibly.
13:47:37 <Baughn> They seem to miss that humans aren't AIs
13:47:40 <laura85> resiak, good to know, thanks ^^  i'm wondering what the real world apps for haskell are
13:48:22 <monochrom> Programmers believe themselves are AIs? :)
13:48:32 <Baughn> It's a desirable state. ^_^
13:48:39 <tack-work> I've known quite a few AI's that could put my coworker's creative problem solving skills to shame
13:49:24 <Heffalump> laura85: http://www.haskell.org/haskellwiki/Haskell_in_industry has a list of commercial users
13:49:25 <lambdabot> Title: Haskell in industry - HaskellWiki
13:50:05 <tack-work> so. few. jobs. sadface
13:51:29 <laura85> Heffalump, interesting thx
14:00:18 <dibblego> @users
14:00:18 <lambdabot> Maximum users seen in #haskell: 463, currently: 442 (95.5%), active: 28 (6.3%)
14:02:48 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5932
14:05:44 <encryptio> is there a library function that exists that does something like: f :: [a] -> [a] -> [[a]], where f [1,2] [3,4] == [[1,3],[1,4],[2,3],[2,4]]
14:06:19 <schemelab> oh looks like a cross product
14:06:49 <matthew-_> > do { x <- [1,2]; y <- [3,4]; return [x,y] }
14:06:53 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
14:07:00 * matthew-_ wins
14:07:00 <encryptio> ah.
14:07:12 <Lemmih> > liftM2 (,) [1,2] [3,4]
14:07:12 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
14:07:29 * matthew-_ looses to Lemmih
14:07:29 <matthew-_> ;)
14:07:33 <dolio> > sequence [[1,2],[3,4]]
14:07:33 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
14:07:42 * matthew-_ gets his coat
14:07:58 <schemelab> oh nice.. ndm has it here too -  http://neilmitchell.blogspot.com/2007/02/haskell-and-set-theory.html
14:07:59 <lambdabot> Title: Neil Mitchell's Haskell Blog: Haskell and Set Theory, http://tinyurl.com/23d9ln
14:08:17 <roconnor> > [[x,y] | x <- [1,2]; y <- [3,4]]
14:08:17 <lambdabot>  Parse error at ";" (column 20)
14:08:23 <Baughn> > mapM [[1,2],[3,4]]
14:08:23 <lambdabot>  Couldn't match expected type `a -> m b'
14:08:25 <roconnor> > [[x,y] | x <- [1,2], y <- [3,4]]
14:08:26 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
14:08:34 <Baughn> @src mapM
14:08:34 <lambdabot> mapM f as = sequence (map f as)
14:08:50 <Baughn> ..ooh, right. It's that time of day again.
14:08:53 <matthew-_> > mapM id [[1,2],[3,4]]
14:08:54 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
14:09:07 <Lemmih> That's a funny solution.
14:09:15 <matthew-_> frikkin' nuts
14:09:37 <dolio> mapM id = sequence . map id = sequence . id (functor law) = sequence
14:09:44 <Baughn> > mapM succ ["HAL","IBM"]
14:09:45 <lambdabot>   add an instance declaration for (Enum [Char])
14:09:55 <Corun> Lo matthew. I got a UROP Place! :-)
14:10:00 <Baughn> > mapM succ "HAL"
14:10:00 <lambdabot>  Couldn't match expected type `m b' against inferred type `Char'
14:10:06 <Baughn> I should just give up
14:10:07 <matthew-_> well done Corun. under whom?
14:10:23 <Corun> Julia McCann
14:10:26 <matthew-_> oh.
14:10:34 <matthew-_> doing what?
14:10:39 <Baughn> > mapM (map succ) ["HAL","IBM"]
14:10:40 <lambdabot>  ["IJ","IC","IN","BJ","BC","BN","MJ","MC","MN"]
14:11:09 <Corun> Writing stuff in C.
14:11:27 <Corun> Our Autonomic Computing research group on the 5th floor have just build a set of sensors called Beasties and we have a number of fun projects we would like to carry out to test them and generally play around with them"
14:11:40 <matthew-_> > mapM (liftM succ) ["HAL","IBM"]
14:11:41 <lambdabot>  ["IJ","IC","IN","BJ","BC","BN","MJ","MC","MN"]
14:11:54 <matthew-_> oh, you're playing with that rubbish
14:12:02 <matthew-_> yeah, they do robots
14:12:26 <matthew-_> quite what they're doing on the same floor as the language theorists I don't know.
14:12:40 <Corun> "that rubbish" sounds a bit harsh :-P
14:13:07 <matthew-_> Julie actually made me do some work last term and I've not forgiven her for it :)
14:13:25 <Corun> Heh
14:13:43 <Corun> http://www.doc.ic.ac.uk/~asher/ubi/components/core/tesserae-0.0.5.pdf
14:13:44 <lambdabot> http://tinyurl.com/223png
14:13:52 <Corun> There ya go. Language theory, sorta... Happy? :-P
14:15:05 <encryptio> :t sequence
14:15:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:18:20 <encryptio> heh. i spent the last two hours writing this (lazy list manipulating) perl code, and wrote the same thing in haskell in 20 minutes...
14:18:34 <DQuest> \o/
14:19:12 <DQuest> I'm a little curious abotu teh definition of the List monad.  Surely since >>= is defined using concatMap, and concatPam works on lists, this is recursive?
14:19:38 <matthew-_> @src (>>=) [a]
14:19:38 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:19:44 <matthew-_> @src Monad [a]
14:19:45 <lambdabot> Source not found. It can only be attributed to human error.
14:19:52 <matthew-_> grr, I can never remember how to do that
14:20:00 <encryptio> @src (>
14:20:00 <lambdabot> Source not found. You type like i drive.
14:20:05 <dolio> @src [] (>>=)
14:20:05 <lambdabot> m >>= k     = foldr ((++) . k) [] m
14:20:11 <Baughn> @src IO (>>=)
14:20:11 <lambdabot> m >>= k     = bindIO m k
14:20:30 <Baughn> ..helpful
14:20:40 <monochrom> You can probably ask for bindIO.
14:20:47 <Baughn> @src bindIO
14:20:47 <lambdabot> bindIO (IO m) k = IO ( \ s ->
14:20:47 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
14:20:50 <monochrom> It will not be helpful either. :)
14:21:10 <matthew-_> well, it's kinda state-like
14:21:15 <Baughn> ..you horrible, grayscale person
14:21:27 <monochrom> That "s" has type RealWorld#
14:21:37 <monochrom> hahahahaha
14:21:45 <matthew-_> the '#'s can be ignored as that's just unboxing
14:22:07 <matthew-_> oh - or are they actually crucial to remove laziness?
14:22:24 <encryptio> @src unIO
14:22:24 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:22:25 <monochrom> The unboxing is crucial.
14:22:27 <Baughn> I'll be happy to leave that at "it's magic"
14:22:36 <matthew-_> right.
14:22:46 <DQuest> Or is it that the underlying List is just defined in the underlying layer, and then the List monad just means you can do monnadic things with it?
14:22:47 <Corun> :t (#)
14:22:48 <lambdabot> parse error on input `)'
14:23:06 <Baughn> DQuest: But of course
14:23:07 <Corun> What's the #?
14:23:25 <Baughn> Corun: Syntax - unboxing. Don'T worry about it yet
14:23:44 <matthew-_> well, just lookup -funbox-strict-fields
14:24:29 <monochrom> It uses State-like code (the state type is a ficticious "RealWorld#") and unboxed tuple (# x,y #) to make sure sequential code is generated. Then there is another stage to add magic to it so as to actually interact with memory, file system, OS, ...
14:25:24 <dolio> @src getChar
14:25:24 <lambdabot> getChar = hGetChar stdin
14:25:40 <Baughn> @src hGetChar
14:25:40 <lambdabot> Source not found. :(
14:26:48 <monochrom> Anyway, the code of bindIO is really just to make sure that re-ordering does not happen.
14:27:15 <Baughn> Magic, magic and more magic. :/
14:27:24 <Baughn> I'd prefer having explicit sequence annotations
14:28:44 <monochrom> Well, bindIO is your explicit sequence annotation then.
14:29:30 <monochrom> It just happens that your explicit sequence annotation is still not primitive, and can be reduced to yet more subatomic constituents.
14:29:43 <monochrom> Onion layer, onion layer, and more onion layer.
14:30:42 <resiak> hrm, is there a mod-alike such that  -1 `mod'` 5 == 4?
14:30:46 <resiak> erm, 3.
14:30:56 <Baughn> @hoogle Int -> Int -> Int
14:30:56 <lambdabot> Data.Time.Calendar.MonthDay.monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
14:31:06 <dolio> > (-1) `mod` 5
14:31:08 <lambdabot>  4
14:31:09 <roconnor> > (-1) `mod` 5
14:31:10 <lambdabot>  4
14:31:14 <resiak> *blink*
14:31:14 <lament> why would it be 3?
14:31:17 <monochrom> I don't understand why you want 3 instead of 4.
14:31:31 <Philippa> <DQuest> I'm a little curious abotu teh definition of the List monad.  Surely since >>= is defined using concatMap, and concatPam works on lists, this is recursive? <- not in the slightest. concatMap doesn't make use of lists being a monad
14:31:56 <dolio> Note, -1 `mod` 5 gets parsed as -(1 `mod` 5) for some reason.
14:31:58 <Pseudonym> Right.  concatMap is the not-general version.
14:32:04 <resiak> argh
14:32:06 <Pseudonym> (>>=) is the general version.
14:32:11 <resiak> because i'm tired, and dolio has found my problem!
14:32:19 <tack-work> @src concatMap
14:32:19 <lambdabot> concatMap f = foldr ((++) . f) []
14:32:20 <resiak> thanks :)
14:32:41 <monochrom> Who's concatPam?
14:32:51 <tack-work> :t concatMap
14:32:51 <dolio> flip concatMap?
14:32:58 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
14:32:59 <DQuest> :P
14:34:14 <roconnor> http://arcanux.org/lambdacats/concatMap.jpg
14:35:24 <DQuest> Philippa: So, lists exist in the core of the language, and the list monad is built on top of that?
14:35:50 <dolio> Lists are a monad.
14:36:05 <DQuest> Yes, but they don't have to be
14:36:20 <dolio> You just have to define return :: a -> [a] and (>>=) :: [a] -> (a -> [b]) -> [b].
14:36:20 <DQuest> They could be boring old scheme-style cons-and-null lists
14:36:32 <DQuest> Yes, that's what I mean
14:36:55 <matthew-_> I do like how a 1 char mistake can cause 100 lines of error messages
14:37:08 <DQuest> I suppose that applies to a lot of monads, really.  Half the magic is saying "this is an instance of Monad" and implementing return and bind
14:37:10 <dolio> Scheme lists are monads, too (modulo their heterogeneous types), scheme just doesn't have the functions defined.
14:37:35 <DQuest> Ah, you mean from a category theory perspective
14:38:04 <monochrom> matthew-_: A 1-word mistake in a president's speech (such as adding a "not" or missing one) can cause 10000 lines of complaints and outrage. :)
14:38:16 <DQuest> I was confused because I thought that List was somehow defined in the core, whereas what appears to be happening is that [] and (:) are defined and List provides the framework you need to use it as a monad
14:38:20 <dolio> Sure. Any type constructor for which you can define return and bind that satisfy 3 laws is a monad, more or less.
14:38:31 <DQuest> Yep
14:38:47 <DQuest> Actually, what took me so long to understand monads is that I hadn't properly understood type classes
14:38:56 <Baughn> Are there any monads that don't involve sequences of any kinds whatsoever?
14:39:00 <DQuest> when I saw this: http://www.haskell.org/tutorial/classes.html it fell in to place
14:39:00 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
14:39:03 <dolio> Lists don't have to be defined in the core, either (disregarding some syntax convenience).
14:39:04 <monochrom> The Three Laws of Monadic Robotics.
14:39:07 <mrsolo> hmm i see 3 db package under hackage..w.hich one is the most commonly used?
14:39:07 <encryptio> Baughn: like Maybe?
14:39:16 <ddarius> Baughn: Most of them.
14:39:25 <dolio> data [a] = [] | (:) a [a]
14:39:28 <Baughn> encryptio: Nope, that has plenty of sequences
14:39:41 <Excedrin> with C++ you can create infinite error messages with recursive templates... I wonder if you could encode lambda calculus into g++ errors
14:39:46 <Baughn> @src Maybe (>>=)
14:39:46 <lambdabot> (Just x) >>= k      = k x
14:39:46 <lambdabot> Nothing  >>= _      = Nothing
14:39:56 <encryptio> then i have no idea what you're asking...
14:40:02 <DQuest> dolio: mm, I'd figured that.  Something like data MyList = Head a MyList Null
14:40:11 <ddarius> Excedrin: C++ templates are a pure lazy (I think) functional programming language.
14:40:11 <Baughn> encryptio: That's okay. I'm just random-walking.
14:40:14 <DQuest> er, | Null
14:40:30 <DQuest> Ok, stupid question at the end of the day :)
14:40:33 <mrsolo> hmm look like hdbc is most recent..
14:40:50 <Excedrin> ddarius: yes, but what if you use compiler error messages as the output of your program?
14:41:11 <dolio> DQuest: Yeah. Of course the 'data [a] ...' isn't legal syntax, so it gets special cased, because lists are so nice. :)
14:41:34 <DQuest> Aaaaanyway, what took me so long to understand them is that typeclasses made them look somehow magical and arcane, as if I couldn't substitute the definition of bind for bind
14:41:39 <ddarius> Excedrin: That's how the original template metaprogram worked.
14:42:30 * monochrom hugs his typeclass
14:42:44 <DQuest> Now I don't know how IO works, but that could be an exception.  Modulo that, ther's not too much magic going on
14:42:52 <Excedrin> ddarius: that's interesting, I didn't know that.
14:47:51 <matthew-_> if you've got overlapping instances turned on, why does ghci still sometimes vomit on overlapping instances?
14:50:11 <ivan__> hi is there any lib for sound in haskell?
14:50:28 <jrx> OpenAl
14:50:46 <ivan__> how can i install it?
14:51:16 <jrx> I think it must be somewhere on the hackage
14:51:36 <jrx> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenAL-1.3.1.1
14:51:38 <lambdabot> http://tinyurl.com/3aa8x8
14:51:44 <jrx> but also there are others
14:52:00 <jrx> see:
14:52:02 <jrx> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Sound
14:52:03 <lambdabot> http://tinyurl.com/yqov7f
14:53:02 <ivan__> jrx: i found it but what is the module name ?
14:53:14 <matthew-_> in type class instances, say you have class C a b, and then you define instance C  x x and C x y in that order, is there anyway to get ghc to be happy and choose the first when both are the same type and the second when they're different types?
14:53:31 <Lemmih> ivan__: Look at the package page.
14:53:53 <Lemmih> ivan__: Hackage even hosts Haddock documentation.
14:53:59 <jrx> probably Sound.OpenAL
14:56:28 <ivan__> Lemmih: the is the openAl written in c?
14:56:46 <jrx> yes it is
14:57:53 <matthew-_> grrrrrrrrrrrrr. Has anyone got a type-level map to work?
14:58:00 <ivan__> jrx: is there any other package that is much simplier? just need to output some midi
14:58:32 <Beelsebob_> what does one need to do to ghc to get it to recognise a package?
14:58:52 <Beelsebob_> i.e. what makes a package, rather than a collection of libraries and hi files
14:59:02 <ddarius> matthew-_: The type level language is a logic language (unless you are using associated types).  There are ways to encode HOFs in (certain weak) logic languages.
14:59:07 <Philippa> ivan__: I suspect not unfortunately, it's the sort of thing that's not particularly useful for 'serious' apps so it doesn't get written much because people who cared enough were doing something too complicated
14:59:37 <Philippa> also, output it where? On what platform(s)?
14:59:38 <ivan__> thx i take a look at it
15:00:11 <ivan__> output todirect to the soundcar/speakers, on linux
15:00:24 <jrx> ivan__: to be honest, I don't know, I haven't use any of those. You'll probably just need to look through haddock documentation of packages in hackage and choose the one that is most siutable for your needs
15:00:41 <Philippa> ivan__: no such thing, MIDI's not sound data
15:00:43 <matthew-_> ddarius: ok, yes, I appreciate all of that. The problem I'm hitting is controlling recursion
15:01:10 <ivan__> Philippa: how is midi files played on the computer then?
15:01:17 <matthew-_> ddarius: I have lists working fine, and was hoping to just use elems of (key, val)
15:01:44 <matthew-_> but it seems not possible to avoid overlaps between the key matching and unmatching
15:02:19 <Philippa> ivan__: via a whole pile of routes. Basically you talk to something that'll act as a synthesiser
15:02:45 <Saizan> matthew-_: doesn't HList have that?
15:03:51 <ivan__> is there anywhere i can read how to create a midifile then? or is it to hard?
15:04:38 <matthew-_> Saizan: dunno. I should really have a look...
15:04:47 <Philippa> ivan__: you want file format info, or just a sequencing package?
15:04:54 <jrx> there is a midi library in hackage, look at it
15:05:06 <roconnor> >atan (0.3/sqrt(1-(0.3)^2)
15:05:08 <roconnor> > atan (0.3/sqrt(1-(0.3)^2)
15:05:08 <lambdabot> Unbalanced parentheses
15:05:13 <roconnor> > atan (0.3/sqrt(1-(0.3)^2))
15:05:17 <lambdabot>  0.3046926540153975
15:05:24 <roconnor> > asin(0.3)
15:05:25 <lambdabot>  0.3046926540153975
15:05:36 <ivan__> jrx: you mean haskore?
15:05:48 <ddarius> @hackage
15:05:48 <lambdabot> http://hackage.haskell.org
15:06:01 <matthew-_> ahh, you walk through to find the numeric idx and then use that to idx the 2nd list
15:06:09 <Trinithis> is there a way to make a data structure of type Ord an instance of something like Functor?
15:06:12 <roconnor> > 2*atan (0.3/(1+sqrt(1-(0.3)^2)))
15:06:13 <lambdabot>  0.3046926540153975
15:06:25 <ddarius> ivan__: The one called "midi" might be worth looking at.
15:07:47 <jrx> ivan__: there is also alsa-midi -> maybe that can be used to playback midi file
15:08:15 <mauke> > case undefined of () -> 2
15:08:16 <lambdabot>  Undefined
15:08:29 <mauke> :-|
15:08:48 <mauke> Trinithis: no, data structures can't be instances
15:08:58 <mauke> also, Ord is not a type
15:09:23 <Trinithis> something like: data (Ord a) => BinaryTree a = ...
15:12:47 <roconnor> > asin(21/30)
15:12:48 <lambdabot>  0.775397496610753
15:20:16 <matthew-_> is overlapping instances at all infulenced or affected by fundeps?
15:23:30 <glguy> birkenfeld: you about?
15:24:30 <monochrom> matthew-_: I think so.
15:28:44 <Tobsan> @src liftIO
15:28:44 <lambdabot> Source not found. stty: unknown mode: doofus
15:29:57 <matthew-_> liftIO is in MonadIO
15:32:08 <By_Turkey> www.MircAlemTR.com  <-  Turkey GirlS Chat ChanneL Enter here please.
15:33:31 * Lemmih aims at By_Turkey.
15:33:33 <roconnor> > exp (pi*sqrt(2011))
15:33:37 <lambdabot>  1.5287325030838364e61
15:33:39 --- mode: ChanServ set +o Pseudonym
15:33:51 --- mode: ChanServ set -o Pseudonym
15:33:56 * matthew-_ aims at bed
15:34:01 <glguy> k-line > +b
15:34:08 <Pseudonym> Yeah.
15:34:13 <glguy> :-D
15:39:15 <glguy> how do I tell cabal that my main module is not named main?
15:41:58 <dino-> I think that's Main-is: in the cabal file.
15:42:36 <dino-> If that's what you're asking
15:49:47 <roconnor> > exp (exp (exp (1/2)))
15:49:50 <lambdabot>  181.33130360854574
15:50:01 <roconnor> oh
15:53:49 <dolio> > sqrt e
15:53:54 <lambdabot>  sqrt e
15:54:18 <dolio> exp a
15:54:21 <dolio> > exp a
15:54:22 <lambdabot>  exp a
15:59:57 <solrize> exp$pi*sqrt(163)
16:00:02 <solrize> >exp$pi*sqrt(163)
16:00:22 <solrize> > exp $ pi*sqrt(163)
16:00:25 <lambdabot>  2.6253741264076826e17
16:02:27 <encryptio> > e
16:02:28 <lambdabot>  e
16:02:32 <encryptio> > e :: Double
16:02:33 <lambdabot>  Couldn't match expected type `Double' against inferred type `Expr'
16:02:46 <encryptio> hmm.
16:03:04 <dolio> > e ** (i * pi)
16:03:05 <lambdabot>  e**(i * pi)
16:03:28 <mauke> > e^(i*pi)+1
16:03:34 <lambdabot> Terminated
16:03:36 <encryptio> e 1
16:03:38 <encryptio> > e 1
16:03:38 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Expr'
16:03:43 <Beelsebob_> why does lambdabot sometimes not evaluate things these days?
16:03:45 <Beelsebob_> what's changed?
16:03:47 <ibid> > foldr f e [x,y,z]
16:03:48 <lambdabot>  f x (f y (f z e))
16:03:55 <dolio> It is evaluating them.
16:03:57 <Beelsebob_> oh, it does partial evaluation, I see
16:03:57 <ibid> > foldl f e [x,y,z]
16:03:58 <lambdabot>  f (f (f e x) y) z
16:04:04 <Beelsebob_> clever clever
16:04:11 <dolio> @where expr
16:04:11 <lambdabot> I know nothing about expr.
16:04:30 <encryptio> @where Expr
16:04:30 <lambdabot> I know nothing about expr.
16:04:42 <ibid> there was a blog post about that a while back
16:04:52 <encryptio> Beelsebob_: not partial evaluation, logging of actions
16:05:02 <dolio> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
16:05:04 <lambdabot> Title: Simple reflection of expressions - 21 thoughts, http://tinyurl.com/2yeszc
16:05:10 <dolio> That's the relevant article, anyhow.
16:05:13 <mauke> > exp 1
16:05:14 <lambdabot>  2.718281828459045
16:05:23 <mauke> > exp (i * pi)
16:05:24 <lambdabot>  exp (i * pi)
16:05:29 <mauke> > e^(i*pi)+1
16:05:35 <lambdabot> Terminated
16:05:39 <mauke> why :(
16:05:47 <ddarius> i /= 0 +: 1
16:05:56 <mauke> oh, derived definition?
16:05:59 <mauke> > x^2
16:06:00 <lambdabot>  x * x
16:06:05 <mauke> makes sense now
16:06:44 <dolio> f g and h are functions for Expr, and all the other letters are variables.
16:08:25 <Beelsebob_> > [1..x]
16:08:26 <lambdabot>  Exception: not a number
16:08:31 <Beelsebob_> aww
16:08:35 <dolio> > (f . g) x
16:08:36 <lambdabot>  Add a type signature
16:08:41 <dolio> > (f . g) x :: Expr
16:08:41 <lambdabot>  Add a type signature
16:09:00 <dolio> > ((f :: Expr -> Expr) . g) x
16:09:01 <lambdabot>  f (g x)
16:09:42 <encryptio> cool
16:12:32 <encryptio> > iterate f x
16:12:33 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
16:13:03 <Pseudonym> > fix f
16:13:04 <lambdabot>  Add a type signature
16:13:11 <Pseudonym> > fix f :: Expr
16:13:12 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
16:21:54 <resiak> @hoogle strerror
16:21:54 <lambdabot> No matches found
16:22:20 <mauke> it's all in IOError. sort of
16:23:31 <resiak> kind of :)
16:37:21 * roconnor hates LaTeX
16:37:35 <roconnor> Why can't I put a verbatim inside a table?
16:38:20 <SamB> roconnor: because the verbatim is a fake environment
16:38:25 <SamB> s/the //
16:38:44 <SamB> it's actually just a TeX macro...
16:39:06 <roconnor> Yep, that's why I hate LaTeX.
16:39:08 <SamB> you can't use it inside the argument to any other macro
16:39:26 <SamB> possibly there is a more robust implementation available?
16:39:43 <SamB> perhaps one that requires eTeX?
16:40:10 <roconnor> Give me <![CDATA[ ... ]]> any day.
16:41:03 <SamB> yeah, I know...
16:41:14 <SamB> I was thinking a similar thing
16:42:02 <byorgey> roconnor: try the fancyvrb package.
16:42:03 <roconnor> stupid editors requiring llncs
16:42:05 <byorgey> http://tug.ctan.org/cgi-bin/ctanPackageInformation.py?id=fancyvrb
16:42:06 <lambdabot> Title: CTAN: View package information
16:42:24 <roconnor> it ought to be their job to typeset my SGML. :)
16:42:55 <SamB> roconnor: requiring what?
16:43:23 <roconnor> SamB: llncs := style for lecture note in computer science.
16:43:35 <SamB> oh. you could perhaps supply XML that can be typeset by that crazy TeX-based XML processor?
16:44:00 <phubar> is happs.org down?
16:44:19 <byorgey> phubar: looks like.
16:44:26 <roconnor> SamB: I can't imagine any system that will produce something that will fit the llncs LaTeX class.
16:44:38 <roconnor> SamB: Actually, I'm writing my document in TeXmacs
16:44:49 <roconnor> and exporting it to LaTeX
16:44:49 <SamB> and it didn't crash yet?
16:45:08 <roconnor> because I don't know LaTeX, and don't want to know LaTeX.
16:45:34 <roconnor> SamB: It did crash, so I went back to my own copy that I built from sources some time ago.
16:45:55 <roconnor> I want to rewrite TeXmacs in Haskell.
16:46:22 <SamB> good luck with that ;-)
16:46:49 <IsoPallo> I'd like to write at least something in Haskell...
16:46:58 <roconnor> and make it a bit less like TeX
16:46:58 <roconnor> and a bit less like emacs.
16:46:59 <roconnor> I must admit that TeXmacs has a pretty good interface for laying out mathematics.
16:47:06 <roconnor> That is a keeper I think.
16:47:13 <SamB> roconnor: heh
16:47:18 <SamB> what would you call it?
16:47:35 <SamB> just TeXmacs, in the tradition of STG?
16:47:39 <roconnor> vapormacs.
16:47:49 <roconnor> I don't know.
16:47:57 <lament> TeXmacs Forever.
16:49:17 <roconnor> Can I somehow put a carriage return in the middle of a tt block inside a table?
16:49:43 <lament> roconnor: don't rewrite TeXmacs in Haskell. Rewrite TeX in Haskell :)
16:50:25 <roconnor> lament: Nah, I'd rather make a typed version of DSSSL in Haskell.
16:51:01 <lament> as long as you pay for every bug, fine by me
16:52:18 <SamB> lament: but TeX is already bug-free
16:52:46 <SamB> so wouldn't we want to write something rather different?
16:53:02 <lament> you never know if it's bug-free until you've rewritten it in haskell!
16:53:37 <SamB> but it has been declared by order of Knuth that it is bug-free!
16:54:52 <SamB> in any case, the warts are a good deal more of a problem than any bugs it may or may not have...
16:59:18 <mofmog> hi
16:59:21 <roconnor> hi
16:59:47 <mofmog> so at my school, we have to go through SICP for our first cs course
17:00:09 <mofmog> and so I'm pretty sure I know the basics of functional programming and I've been trying to get into haskell but it's been sort of difficult
17:00:48 <roconnor> Types and Data constructors are new I suppose.
17:01:02 <mofmog> well my problem is the interactivity
17:01:06 <mofmog> specifically in GHCi
17:01:19 <mofmog> with scheme you can just cut and paste code into the interpretor no problem
17:01:36 <SamB> oh?
17:01:39 <mofmog> with ghci, it seem as if I have to use "let" in order to do what I want it to do.
17:01:48 <mofmog> i dunno, that's the best solution i've found so far
17:02:08 <mofmog> I've tried entering in function definitions line by line, or using semi colons, but it seems that i have to use let
17:02:09 <SamB> I usually discover that my interpreter won't let me edit multiple line expressions very well
17:02:27 <mofmog> interpreter for scheme or haskell?
17:02:35 <SamB> scheme
17:02:48 <mofmog> well i use stk running in a terminal
17:03:03 <mofmog> so i get sort of lazy and just write code in a text editor, cut and paste it into the scheme prompt
17:03:05 <mofmog> it works
17:03:05 <roconnor> at the command line of GHCi you write expressions; while files contain declairations.
17:03:21 <mofmog> you see, I dont really uderstand the difference
17:03:32 <mofmog> is it a functional thing?
17:03:49 <mofmog> that- if you write a function line by line into the interpreter you're changing state?
17:03:52 <roconnor> but you can cut an paste expressions from your declairations to inside GHCi.
17:03:53 <redleafgr> mofmog: when you run code directly in ghci, it's as if you're doing so within a "do" expression
17:04:01 <mofmog> oh i see
17:04:09 <redleafgr> if you think of it like that, then the let makes sense
17:04:12 <mofmog> and you can't exactly define a function naked within a do expression
17:04:19 <redleafgr> right
17:04:22 <mofmog> you have to clothe it in let
17:04:24 <mofmog> i see
17:04:28 <mofmog> ok that makes a lot of sense
17:04:39 <mofmog> also, i can't figure out how to import modules
17:04:50 <cjb> :m Module.Name
17:05:33 <mofmog> so i'm going to assume i can't use import within a do loop either
17:05:37 <mofmog> :-p
17:06:04 <redleafgr> usually, the easiest thing is to write code in a file
17:06:10 <redleafgr> start ghci with it
17:06:18 <redleafgr> and whenever you make a change, use :r to reload
17:06:33 <mofmog> oh cool
17:06:34 <mofmog> thanks
17:06:36 <redleafgr> np
17:07:16 <mofmog> you know, even though both scheme and haskell are functional (or at least, scheme is mostly functional), it seems as if haskell is still a pretty big shift
17:07:24 <mofmog> at least as much from say C to Lisp
17:07:51 <redleafgr> it is, but the scheme thought process helps a lot more with haskell than a C mentality helps with lisp
17:07:53 <redleafgr> hehe
17:07:55 <lament> "functional" is a big area, just like "OO" is a big area
17:08:01 <lament> two functional languages can be quite different
17:08:30 <mofmog> i guess i just miss s-expressions and applicative-order (well... what we pretend was applicative)
17:08:49 <mofmog> there's something about knowing EXACTLY what an s-expression wants out of you
17:10:57 <lament> exactly, if you ignore macros? :)
17:11:17 <mofmog> yes
17:11:21 <mofmog> if you ignore macros i guess
17:11:36 <mofmog> and excluding special forms
17:11:46 <lament> heh.
17:12:35 <mofmog> ((lambda (x) (+ x 3)) 5) is different from (lambda (x) (+ x 3)) 5 is what i'm getting at.
17:12:44 <SamB> scheme is what if you ignore macros and special forms?
17:13:03 <mofmog> well not scheme, but the idea of s-expressions seems to fit into my head better
17:13:27 <SamB> better than what?
17:13:32 <SamB> parse trees?
17:13:41 <mofmog> than mixes of prefixes, infixes etc
17:13:52 <redleafgr> haskell's type system helps you out though
17:13:55 <redleafgr> it won't let you make a mistake
17:14:13 <lament> mofmog: there's liskell :)
17:14:18 <mofmog> 0_0
17:14:19 <SamB> what's etc.?
17:14:28 <mofmog> i mean
17:14:31 <SamB> I don't think we have any other fixities...
17:14:38 <SamB> outfixity would be cool though ;-P
17:14:40 <mofmog> suffixes
17:14:43 <mofmog> in some odd way
17:14:47 <mofmog> that might happen :-P
17:15:33 <lament> not really
17:15:39 <mofmog> ?
17:15:57 <lament> not really suffixes :)
17:16:02 <mofmog> of course
17:16:07 <lament> mofmog: http://liskell.org/
17:16:08 <lambdabot> Title: About Liskell
17:17:00 <mofmog> that is amazing
17:17:13 <lament> perhaps, but apparently not very popular.
17:18:05 <mofmog> it seems as if the whole cs department which loves scheme has high hopes not for haskell but Arc Lisp
17:18:19 <mofmog> as if it shall be the messiah of functiona programming (with s-expressions)
17:18:51 <lament> arc seems just hype
17:19:19 <dons> it seems like just another little untyped lispy thing.
17:19:20 <mofmog> it -is- paul graham, but i guess that's sort of cult of personality area
17:19:22 <dons> shrug.
17:19:27 <jbms> dons: heh, yes
17:19:41 <dons> throw another one on the pile.
17:19:42 <jbms> It would seem that arc is what you get if you take some existing lisp implementation, and reimplement it without making any real improvements
17:20:03 <mofmog> i dont think there's an actual list of things that would change
17:20:11 * sm thinks arc will be a big hit
17:20:13 <mofmog> maybe a few minor details in the philosophy page or somethign
17:20:23 <EvilTerran> sm, with a baseball bat, maybe
17:20:44 <EvilTerran> nah, actually, crowbar. way more stylish.
17:20:45 <gnuvince_> Having written a program in both Haskell and Arc, in spite of saying that PG aims at succinctness, Haskell was significantly shorter.
17:20:56 <gnuvince_> List comprehensions and pattern matching ftw
17:21:08 <mofmog> yeah, haskell's pattern matching has me won over
17:21:24 <mofmog> but i wonder- if there's pattern matching involving more than one variable, does it only work on the otuer variable?
17:21:25 <sm> haskell can be shorter, but arc will be a lot easier for the masses to learn
17:21:28 <mofmog> due to partial application?
17:21:30 <sm> it's gonna be huge
17:21:31 <EvilTerran> typeclasses also allow for some wonderfully terse stuff that wouldn't be paractical without a decent type system
17:21:37 <mofmog> sm: that same thinking got us java
17:21:41 <ddarius> @src zip
17:21:41 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
17:21:41 <lambdabot> zip _      _      = []
17:21:45 <EvilTerran> mofmog, it goes through them from left-to-right
17:22:03 <mofmog> so if you had a function f x y
17:22:06 <lispy> I am not untyped!
17:22:12 <lament> if arc doesn't give anything over scheme and CL, then it's unlikely to expect it to achieve broader acceptance.
17:22:15 <lispy> dons: take it back! ;)
17:22:18 <mofmog> and you wated to match an x but not a y what do you do?
17:22:24 <dons> lispy: :)
17:22:34 <EvilTerran> "foo PAT1 PAT2 ... PATN = EXP; ..." is just the same as "foo x1 x2 ... xN = case (x1, x2, ..., xN) of (PAT1, PAT2, ..., PATN) -> EXP; ..."
17:22:40 <dons> sm, you reckon? somehow i doubt it :)
17:22:41 <gnuvince_> And so far, Arc isn't the "perl" of Lisp (not good at talking to the OS)
17:22:46 <sm> lament: I disagree, there is demand for a rallying flag in the lisp-scheme world
17:22:54 <SamB> yeah, theres some really cool stuff you can't do (or can't do anything like as easily as you might be able to...) with C++ templates because C++ doesn't have a typesystem...
17:22:56 <lispy> dons: do you know if frag was able to play on official Q3 servers?
17:23:00 <dons> there's dozens of these fake schemes
17:23:01 <jbms> I'd agree that the fact of the matter is that if you have to dumb down your programming language so that the masses can use it, what quality of program can you expect these masses to produce?
17:23:03 <ddarius> sm: Arc is not it.
17:23:07 <sm> not so much among the existing users
17:23:09 <dons> lispy: don't  think so.
17:23:19 <gnuvince_> Factor will save Lisp :)
17:23:28 <dons> heh
17:23:30 <mofmog> anyways i have to go
17:23:33 <mofmog> thanks for the help!
17:23:38 <gnuvince_> Macros as a library, those Lisp pinheads must be going mad :)
17:23:41 <sm> we shall see. :)
17:23:48 <lament> sm: good point, but starting from scratch is always painful
17:24:11 <SamB> jbms: well, it depends on some things
17:24:14 * gwern wonder sabout lisp. I always figured the simplest most elemental lisp had only the list type, and so was basically untyped
17:24:21 <SamB> like, is it because your language is overcomplicated to start with?
17:24:30 <lament> sm: and paul graham is not really a household name yet
17:24:42 <ddarius> gwern: Most lisps don't have a list type.
17:25:09 <SamB> gwern: you mean only cons and nil?
17:25:31 <SamB> you aren't going to get anywhere with only cons, as far as I can see...
17:25:42 <dolio> They have cons and symbols.
17:25:52 <EvilTerran> gwern, i think you at least need functions
17:26:13 <gwern> ok; do functions and symbols make it have multiple types?
17:26:16 <EvilTerran> although you could just allow people to apply arbitrary lists to things
17:26:25 <ddarius> gwern: Define "type"
17:26:49 <SamB> EvilTerran: no! only lists that begin with 'lambda
17:26:51 <EvilTerran> ddarius, "well-typed programs do not go wrong"
17:27:03 <EvilTerran> SamB, ok, lists and symbols, then
17:27:09 <ddarius> EvilTerran: Define "wrong"
17:27:34 <EvilTerran> ay, there's the rub. the definition of "wrong" there depends on how expressive your type-system is
17:27:44 <SamB> EvilTerran: so you were saying you liked dependantly typed languages?
17:28:06 <dolio> Who doesn't like them?
17:28:10 <sm> ps and the other reason is that arc is a friendly face for plt scheme, which is outstanding
17:28:11 <EvilTerran> i'm... interested in them. haven't actually tried one.
17:28:19 <sm> but I'll shut up now :)
17:28:25 <SamB> well, re: "don't go wrong"
17:28:37 <EvilTerran> the closest i've got is playing with olegian type representations of values
17:28:56 <EvilTerran> (in haskell). indeed, though, i do think they seem like a really cool idea.
17:28:57 <dolio> EvilTerran: You should try out Agda. It's probably about as close to Haskell as you'll get in dependently typed languages currently.
17:29:04 <lament> about arc, i liked this article http://rondam.blogspot.com/2008/01/my-take-on-arc.html
17:29:04 <lambdabot> Title: Rondam Ramblings: My take on Arc
17:29:12 <EvilTerran> i've been poking at Coq a little
17:31:11 <dolio> I haven't tryed Coq, but I get the impression it's not built for programming in the style most people are used to.
17:31:48 <TomMD> Depends.  Are you used to HOL4?
17:31:55 <faxathisia> You can write functions with pattern matching and recursion
17:31:56 <EvilTerran> that's the impression i get, too. it seems there'd be quite a lot of prolog-y malarky involved in using it to its full
17:32:05 <EvilTerran> i'll have a look at agda
17:32:11 <EvilTerran> @where agda
17:32:12 <lambdabot> http://tinyurl.com/yp6zsr
17:32:27 <wagle_home> if you name your brain damage "hygenic", it MUST be good, right?
17:33:02 <faxathisia> Theorem proving with Coq is many many times easier than with Agda
17:33:18 <EvilTerran> i thoroughly sterilise all my brain-damaging instruments in a solution of 40% ethanol
17:33:25 <EvilTerran> :P
17:33:26 <TomMD> faxathisia: How does it compare with Isabelle and HOL4?
17:34:01 <faxathisia> TomMD, never used Isabelle but from reading the manual I think it's a similar sort of thing
17:34:33 <wagle_home> s/hygenic macros/inline macros/g
17:35:39 <mattam> EvilTerran: prolog-y ? You must confuse it with LF/Twelf... or you're talking about tactics ?
17:35:58 <EvilTerran> i think i'm thinking of tactics
17:36:21 <faxathisia> other than using DFS the tactic language is not like Prolog..
17:36:38 <EvilTerran> by "prolog-y", i mean "weird and alien and with an aftertaste of formal logic"
17:36:38 <faxathisia> more like Prolog is specifying relations with types
17:37:02 <mattam> Well, proof-search is not exactly the same as in prolog either, you get to pattern-match on types and goals.
17:37:11 <EvilTerran> i wasn't being particularly formal :P
17:37:39 <mattam> It has a nice non-prolog-y taste to it I would say :)
17:38:22 <EvilTerran> i haven't written any prolog, or done more than a few minutes' poking about of Coq, so i'm basically shooting my mouth off here :P
17:38:44 <mattam> My experience with logic programming has been a complete disaster though so I'm opinion's clearly biased too.
17:38:50 * dolio should go and try out Coq so he can actually know vaguely what he's talking about on the subject. :)
17:39:07 <roconnor> what's the question about Coq?
17:39:21 <EvilTerran> no question. we're just blathering.
17:39:41 <roconnor> The answer is, Yes, Coq can do that!
17:39:48 <faxathisia> That's a shame mattam.. I find logic progamming a lot of fun
17:40:09 <roconnor> ... but it is really difficult.
17:40:16 <faxathisia> I do hear ... nearly everyone hates it though
17:40:19 <mattam> faxathisia: except that you don't control anything.
17:40:52 <EvilTerran> the closest i've done to logic programming is using FDR to model-check CSP scripts
17:40:58 <mattam> I'm just unhappy having to understand the evaluation order so deeply that I could as well write a functional program to do the same thing
17:41:34 * EvilTerran throws another TLA on his BBQ for good measure. LOL.
17:41:45 <SamB> which one is the other one?
17:41:52 <ddarius> faxathisia: You hear nearly everyone hates logic programming?
17:41:54 <SamB> TLA or LOL?
17:41:59 <EvilTerran> SamB, er, is that a koan?
17:42:20 <EvilTerran> oh, right. unspecified, but probably LOL, seeing as that's the one that most needs to, ahem, DIAF.
17:42:24 <faxathisia> ddarius, almost anyone mentioning logic programming says they don't like it
17:42:27 <ddarius> mattam: Don't use Prolog.  Use some other logic language.
17:42:45 <ddarius> faxathisia: ?  I dislike Prolog rather strongly, but I do like logic programming.
17:43:09 <EvilTerran> (yes, that's an ETLA, not a TLA, i know. at least it's not a DETLA or anything like that.)
17:43:15 <mattam> ddarius: well, that's the one I learned (with finite domains too for even more complication and "power").
17:43:24 <Pseudonym> There are plenty of semi-sane-at-least logic languages out there.
17:43:31 <ddarius> Prolog is the problem with logic programming.
17:43:32 <SamB> DSETLA?
17:43:40 <faxathisia> I think Prolog is a fantastic language..
17:43:51 <mattam> О»-prolog ?
17:44:03 <faxathisia> You know I have not seen someone do type inference in 3 lines in any other lang..
17:44:27 <mattam> If inference is built-in...
17:44:41 <faxathisia> mattam, like in haskell? It took me 200 lines
17:44:43 * SamB wonders where he can get intellisense for emacs
17:45:17 <ddarius> faxathisia: You could model the solution directly on the Prolog and do it in less than 200 lines.  I wrote a Prolog interpreter in Haskell in about 80 lines.
17:45:28 <ddarius> (Obviously "core" Prolog)
17:45:43 <mattam> faxathisia: not the same kind of inference there. You can't use the unification algorithm of Haskell's typechecker to do unification in your object language.
17:45:59 <mattam> That's rather sane in my opinion.
17:47:15 <mattam> Pseudonym: what are the names of these ?
17:48:15 <Pseudonym> Mercury, Goedel and Oz spring to mind.
17:48:30 <ddarius> Curry seems nice too.
17:48:33 <Pseudonym> Yes.
17:48:39 <Pseudonym> There are a few others.
17:48:56 <faxathisia> Goedel looks horrible..
17:49:02 <mattam> Thanks, I'll take a look.
17:49:28 <ddarius> What I'd love to see is a serious implementation of CLF/LolliMon.
17:49:51 <Pseudonym> What's horrible about it?
17:49:56 <Pseudonym> The syntax?
17:50:08 <faxathisia> yeah
17:50:11 * Pseudonym nods
17:50:20 <Pseudonym> The semantics are quite sane, though.
17:50:23 <Pseudonym> If you ignore I/O.
17:56:03 <faxathisia> I still like Prolog though: P
17:56:28 <sarehu> hi is there any 'stack' datatype in the haskell libraries?
17:56:31 <sarehu> (kidding, kidding)
17:57:11 <Pseudonym> ?- retract(likes(faxathisia,prolog)).
17:57:11 <lambdabot> Maybe you meant: . ? @ v
17:57:31 <wagle_home> :t (:)
17:57:33 <lambdabot> forall a. a -> [a] -> [a]
17:58:04 * wagle_home thought stacks were "builtin"
18:03:06 <dons> sarehu: hah
18:08:24 <wli> sarehu: Try lists.
18:12:50 <dino-> I'm porting something I wrote up to build under ghc 6.8.2.  Having a problem where System.Locale is hidden.
18:13:06 <dino-> This is the first time I've run into hidden things, not sure what to do.
18:13:35 <dino-> In particular I'm after the defaultTimeLocale to use with calls to Data.Time.formatTime
18:14:02 <sarehu> it means (iirc) that the .cabal file is not listing some packages you need
18:14:15 <sarehu> the packages got rearranged and separated
18:14:45 <dino-> Ah, it told me that the old-locale-1.0.0.0 is hidden
18:15:51 <dino-> Ok, that fixed it. Thank you!
18:16:15 <dino-> Build-Depends
18:17:34 <zookofamilytime> Anyone want to help me fix up the darcs configure.ac for Windows and cygwin?  I don't know much about autoconf/configure/ghc.
18:23:54 <zooko> The thing is that the darcs configure script is currently checking whether gcc can compile certain things, but this is the wrong check to perform, because it is actually ghc (and ghc's bundled version of gcc) which will need to compile those things during the build step.
18:27:45 <roconnor> @wn coherent
18:27:45 <lambdabot> *** "coherent" wn "WordNet (r) 2.0"
18:27:46 <lambdabot> coherent
18:27:46 <lambdabot>      adj 1: marked by an orderly, logical, and aesthetically consistent
18:27:46 <lambdabot>             relation of parts; "a coherent argument" [ant: {incoherent}]
18:27:46 <lambdabot>      2: capable of thinking and expressing yourself in a clear and
18:27:48 <lambdabot> [5 @more lines]
18:28:14 <dino-> zooko: So you're trying to build darcs from source?
18:28:36 <dino-> I'm not very familiar either with autoconf. Ok, not at all.
18:28:57 <dino-> And I divested myself of all Windows many years ago. :)
18:29:06 <lispy> zooko: is tihs different from what it does on other platforms?
19:03:25 <sw17ch> Is there an *easy* way to do random file access?
19:05:19 <monochrom> With seeking.
19:05:22 <monochrom> @hoogle seek
19:05:23 <lambdabot> System.IO.SeekMode :: data SeekMode
19:05:23 <lambdabot> System.IO.SeekFromEnd :: SeekMode
19:05:23 <lambdabot> System.IO.hSeek :: Handle -> SeekMode -> Integer -> IO ()
19:05:59 <sw17ch> my situation is that i would be able to go through the file in-order, but i'd like to break it up and use parMap
19:06:02 <sw17ch> thanks
19:06:15 <faxathisia> :t parMap
19:06:16 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
19:06:24 <faxathisia> @src Strategy
19:06:24 <lambdabot> Source not found. There are some things that I just don't know.
19:07:09 <sw17ch> i'm hoping to run this program across files which are potentially several GB long
19:07:54 <sw17ch> and I'm making a mistake somewhere that causes me to keep way to much stuff in memory :(
19:09:08 <blargeyfarg> i don't know that parallel operations over the same file on a single disk is a great time saver, given the thrashing
19:09:24 <blargeyfarg> perhaps just using block i/o
19:09:26 <dons> sw17ch: what data types are you using?
19:09:33 <dons> sw17ch: lazy bytestrings?
19:09:45 <dolio> @type rnf
19:09:46 <lambdabot> forall a. (NFData a) => a -> Done
19:09:57 <dons> oh, you want random access. then probably dropping into posix is sensible
19:10:00 <dolio> Strategy a = a -> Done, or something like that.
19:10:28 <hpaste>  sw17ch pasted "Base Counter" at http://hpaste.org/5935
19:10:42 <ddarius> > 100003 * 100007
19:10:43 <monochrom> I can see how you may end up using too much memory.  Easiest to open the file 10 times, with 10 handles, each handle seeking to a different position, then parallelize them.
19:10:44 <lambdabot>  10001000021
19:10:50 <sw17ch> dons: the ByteString library... i believe
19:11:20 <tgogonkt> hi all :)
19:11:28 <sw17ch> dons: see the hpaste, i'm probably doing something stupid
19:11:39 <sw17ch> i can run 20MB files without too much of a problem
19:11:55 <sw17ch> each line in the files i use is 64 characters wide... i try to process each line in parallel... but i believe that's too fine
19:12:33 <dons> oh, you're just doing each of the 4 elements of the list in parallel?
19:13:06 <dons> are these just files in fasta format?
19:13:39 <dons> oh, but you're using strict bytestrings
19:13:52 <dons> so the readfiles load the entire file into memory
19:14:23 <sw17ch> dons: ah shoot... i was afraid of that
19:14:31 <ddarius> > 100003 * 400007
19:14:31 <lambdabot>  40001900021
19:14:45 <dons> well, that's what lazy bytestrings are for
19:14:50 <dons> but there's some other things we can do here.
19:14:50 <gogonkt`> I want every 5 mins do something, What sould we write in haskell?
19:15:00 <sw17ch> dons: i *think* i'm doing each line in parallel, here's an example of my lines
19:15:01 <dons> gogonkt`: threadDelay ?
19:15:01 <sw17ch> TTCTACCGGGGATCCATACTGGGTGAGTCTTAACTACTCCAGGTGTTAGTTGGACATGAGAAAA
19:15:06 <dons> right.
19:15:26 <dons> how are you compiling the code, btw?
19:15:45 <TomMD> gogonkt`: There have been two libraries recently to do events/timeouts.  Control-event and control-timeout.
19:15:45 <sw17ch> top of the hpaste, i ahve a Build With: setup
19:15:51 <gogonkt`> threadDelay can do this? Thz :)
19:15:52 <sw17ch> i mean, buildwith line
19:15:56 <sw17ch> in the documentation
19:16:01 <sw17ch> ghc genomeParsePar.hs -o parparse -package parallel -package bytestring -threaded -O2
19:16:05 <dons> ah right
19:16:11 <sw17ch> i don't know if -O2 is better than -O though
19:16:13 <ddarius> > 100003 * 10000300007
19:16:13 <TomMD> gogonkt`: So if "forkIO $ threadDelay delay >> action" doesn't cut it, look into those.
19:16:14 <lambdabot>  1000060001600021
19:16:20 <dons> are you trying to run it on multiple cores, sw17ch ?
19:16:24 <sw17ch> yes
19:16:25 <sw17ch> i have two
19:16:27 <ddarius> > 100001 * 10000300007
19:16:28 <lambdabot>  1000040001000007
19:16:31 <dons> you'll need to run it with +RTS -N2
19:16:36 <sw17ch> ./parparse med_genome_1.txt +RTS -N2
19:16:39 <sw17ch> that's how i'm running it
19:16:39 <dons> ah ok. good
19:16:54 <sw17ch> i *think* my problem is that my sparks only do 64 operations
19:16:58 <sw17ch> well, top level
19:17:03 <ddarius> > 100003 * 10000100007
19:17:03 <lambdabot>  1000040001000021
19:17:18 <ddarius> > 100002 * 10000100007
19:17:18 <lambdabot>  1000030000900014
19:17:23 <sw17ch> each spark sums the independent occurrences of A,T,C, or G in the line
19:17:25 <sw17ch> making a 4tuple
19:17:43 <sw17ch> then i use unzip4 to move all the a's,t's, and so on, into their own list
19:17:45 <sw17ch> sum each list
19:17:52 <sw17ch> to have the totals for each for the file
19:18:25 <ddarius> > 100003 * 100100007
19:18:26 <lambdabot>  10010301000021
19:18:43 <ddarius> > 10003 * 100100007
19:18:44 <lambdabot>  1001300370021
19:19:15 <dons> sw17ch: yeah, maybe its too fine grained. it might be nicer to run 4 threads through the file in one go?
19:19:46 <ddarius> > 10003 * 1000001007
19:19:47 <lambdabot>  10003010073021
19:20:10 <sw17ch> dons: that's what i'm hoping... would there be a better approach than my parMap
19:20:47 <ddarius> > 10003 * 1007
19:20:48 <lambdabot>  10073021
19:20:59 <ddarius> > 1003 * 10007
19:20:59 <lambdabot>  10037021
19:21:16 <sw17ch> I was hoping to turn everything into a foldl thinking that that might be better and keeping a running sum for a single thread
19:21:18 <ddarius> > 10003 * 1000007
19:21:18 <lambdabot>  10003070021
19:21:54 <dons> sw17ch: its a good problem.
19:21:59 <dons> dinner time though
19:22:05 <sw17ch> dons: oh fine :)
19:22:09 <sw17ch> enjoy, thanks for the advice
19:22:18 <dons> sw17ch: you could use data T = T !Int64 ...
19:22:21 <dons> instead of a tuple
19:22:27 <dons> then with -funbox-strict-fields
19:22:35 <dons> a bit more efficient for the sum pair
19:22:57 <sw17ch> dons: cool. more things to learn :) enjoy dinner
19:23:06 <gogonkt`> hoogle threadDelay
19:23:08 <sw17ch> ah, which is the Lazy ByteString library?
19:23:14 <dons> also, remember that `par` has some cost. so since you know statically you need only 4 threads, it'll be faster to fork those 4, and have them race through the file
19:23:28 <TomMD> @hoogle threadDelay
19:23:28 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
19:23:28 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
19:23:37 <dons> keeping their own counts, then return the counts at the end (in an MVar perhaps)
19:23:51 <sw17ch> that's kinda what i was thinking
19:23:56 <gogonkt`> :)
19:23:56 <ddarius> > 1000000000003 * 100000000000007
19:23:59 <lambdabot>  100000000000307000000000021
19:24:08 <gogonkt`> lambdabot is qute
19:24:18 <ddarius> > 1003 * 100000000000000000000007
19:24:19 <lambdabot>  100300000000000000000007021
19:24:20 <TomMD> qute?  Cute?
19:24:36 <gogonkt`> is Cute
19:24:37 <TomMD> Any guesses on what ddarius is doing?  Besides making lambdabot work, that is.
19:25:38 <denbuen_> What does it mean if "<GHC.List.CAF>dsat: Prelude.foldr1: empty list" is the result of running with +RTS -xc?
19:25:52 <TomMD> > foldr1 []
19:25:53 <lambdabot>  Couldn't match expected type `a -> a -> a'
19:26:19 <sm> <mutter>spamming..
19:26:28 <TomMD> > foldr1 (+) []
19:26:28 <lambdabot>  Exception: Prelude.foldr1: empty list
19:26:35 <TomMD> denbuen_: You mean that?
19:26:38 <ddarius> > 100000000003 * 10000000007
19:26:39 <lambdabot>  1000000000730000000021
19:26:42 <denbuen_> I know it means foldr1 was given an empty list, but...
19:26:44 <monochrom> ddarius is probably optimizing the value of x*y under some constraints on x and y.
19:26:56 <TomMD> but this GHC.List.CAF... yeah, I don't know.
19:27:08 <denbuen_> TomMD: Yes, that is my symptom.  But I'm not sure what to make of GHC.List.CAF.
19:27:55 <ddarius> > 100000000003 * 100000000000000000000000000000007
19:27:55 <lambdabot>  10000000000300000000000000000000700000000021
19:29:42 <denbuen_> The only CAF I can find in GHC.List (http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html) is prel_list_str ... which is simply the string "Prelude.".
19:29:42 <lambdabot> http://tinyurl.com/23ncyu
19:31:10 <ddarius> > 100000000003000000000000700000000021 `div` 100000000003
19:31:11 <lambdabot>  1000000000000000000000007
19:31:22 <ddarius> Stupid counting.
19:31:29 <denbuen> Is there some way to find out which CAF?
19:35:22 <Tac-Tics2> -fno-spec-constr-threshold <- any idea why that is being used in the ndp package? Ghc chokes on it, claiming: "unrecognized flag"
19:49:13 <brailsmt> is there a good tutorial/reference on random numbers?
19:50:26 <sm> haskell wikibook ?
19:51:52 <denbuen> brailsmt: The reference you'll find here: http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
19:51:53 <lambdabot> http://tinyurl.com/2xxbhl
20:41:40 <hpaste>  eyeris pasted "opengl test case renders blank screen" at http://hpaste.org/5936
20:42:25 <eyeris> Anyone care to help me sort out my opengl problems?
20:44:09 <sm> I'm pretty sure you can replace those imports with just OpenGL and GLUT, eyeris
20:44:55 <eyeris> ok
20:45:42 <sm> also, there is a GLUT init fn. you might try .. I'm not familiar with that rendering context stuff
20:46:01 <eyeris> omg, I'm an idiot
20:46:09 <eyeris> I was forgetting to call frustum
20:46:21 <sm> oh yeah, I was about to say..
20:46:23 <wagle_home> (whats the $= operator?)
20:46:54 <sm> @hoogle $=
20:46:54 <lambdabot> No matches found
20:47:17 <wagle_home> @src ($=)
20:47:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:47:18 <eyeris> $= is a opengl-specific thing.
20:47:20 <sm> it sets a state var.. an ioref or some such thing
20:47:36 <sm> which is used heavily in hopengl
20:47:37 <wagle_home> ah..  thanks
20:49:29 <sm> I have some nifty opengl example code, if you need..
20:49:47 <sm> gwern, I updated that fungen game engine
20:49:58 <sm> stop! don't publish yet! :)
20:50:06 <gwern> sm: really? what happened to getting the fresh version the author was working on?
20:50:25 <sm> still haven't heard.. I sent him a second mail today
20:50:43 <sm> I figure best to wait a little
20:51:14 <sm> but it's fun.. there's two demo games, pong & snake
20:51:19 <gwern> so you updated the old version
20:51:25 <sm> right
20:51:30 <gwern> (haven't played snake in a long time)
20:51:34 <gwern> how hard was it?
20:51:52 <hasenov> hello, is there a data type I may use that defines trees?
20:51:59 <sm> hard enough, for me.. a great learning exercise
20:52:04 <hasenov> if not, is it hard to make it on my own?
20:52:10 <sm> but not too hard
20:52:17 <ddarius> hasenov: Most likely defining your own is by far the easiest thing to do.
20:52:19 <hasenov> im talking about regular trees, not binary trees
20:52:48 <hasenov> means, the constructor must accept a variable amount of arguments
20:53:22 <hasenov> since a node may have many subtrees, not just two
20:53:50 <gwern> sm: did you cabalize it or just fix it to build?
20:53:53 <ddarius> Just have a list of children.
20:54:08 <sm> just to build.. I haven't done cabal magic
20:54:30 <hasenov> ddarius: yea, thats what i was thinking but i was hoping of doing it somehow easier with basic data types
20:55:09 <gwern> ok. if you want me to work on it eventually, send me a repo url when you're done
20:55:42 <hasenov> it might get really complicated with lists within datatypes, not to mention the information i want to store is a datatype in itself
20:56:02 <sm> thanks.. http://joyful.com/darcsweb/darcsweb.cgi?r=fungen;a=summary if anyone wants to take a look
20:56:03 <ddarius> hasenov: Making data types is extremely easy with Haskell.
20:56:03 <lambdabot> Title: darcs - fungen
20:56:19 <ddarius> data RoseTree a = Node a [RoseTree a] is one definition (that has issues, though it's the same as the one in Data.Tree essentially)  How much easier do you want it to be?
20:59:35 <hasenov> ddarius: actually thats what i was thinking of, what are the issues with it?
20:59:47 <hasenov> or maybe i need a Forest
21:00:37 <dynamix> is there a way to simplify this further?   sum (takeWhile (< 1000) =<< [map (5 *) [1,4..], map (3 *) [1..], map (5 *) [2,5..]])
21:00:54 <dynamix> > sum (takeWhile (< 1000) =<< [map (5 *) [1,4..], map (3 *) [1..], map (5 *) [2,5..]])
21:00:55 <lambdabot>  233168
21:02:29 <dynamix> http://projecteuler.net/index.php?section=problems&id=1
21:02:30 <lambdabot> Title: Problem 1 - Project Euler
21:04:01 <nanothief> dynamix: using list comprehensions, or filter could do it easily
21:04:45 <dynamix> nanothief: yeah i tried that version too.. but this is more elegant.
21:05:20 <dynamix> > sum (takeWhile (< 1000) =<< [ [1*5,4*5..], [1*3,2*3..], [2*5,5*5..]])
21:05:21 <lambdabot>  233168
21:06:09 <Botje> > sum [ x | x <- [1..999], x`gcd`15 > 1 ]
21:06:11 <lambdabot>  233168
21:06:16 <Botje> no need to get all fancy.
21:07:18 <nanothief> Botje: I can't beat that :P
21:07:19 <ddarius> hasenov: The issue is that there is no way to make an empty tree, though Data.Tree gets around that by using a Forest type which is simply a list of trees.
21:07:45 <dynamix> Botje:  yours is even better, if x shares a divisor with 15, add it to the sum :)
21:08:22 <dynamix> but bascially your version generates and processes all the numbers ..  i wanted to avoid that
21:08:37 <dynamix> and generate only teh multiples of 3 and 5 < 1000
21:11:53 <Botje> you have to do extra work to avoid doubles, though
21:11:56 <nanothief> dynamix: my solution: sum $ union [3,6..1000] [5,10..1000]
21:12:13 <nanothief> you need Data.List to do that though
21:12:38 <dynamix> :t union
21:12:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
21:12:49 <nanothief> > union [1,2,3,4] [3,4,5,6]
21:12:50 <lambdabot>  [1,2,3,4,5,6]
21:12:59 <Botje> you could sum multiples of 3, multiples of 5, then subtract multiples of 15
21:13:26 <dynamix> > sum $ union [3,6..1000] [5,10..1000]
21:13:26 <lambdabot>  234168
21:13:38 <dynamix> nanothief:  some things not right
21:13:56 <dynamix> > sum $ union [3,6..1000] [5,10..999]
21:13:57 <lambdabot>  233168
21:14:00 <dynamix> :)
21:14:12 <dynamix> > sum $ union [3,6..999] [5,10..999]
21:14:13 <lambdabot>  233168
21:15:38 <dynamix> haskell is at number 22 on the rankings list!!
21:22:27 <dons> we've had #1 in the past
21:22:59 <Zao> All haskellers are obviously cheaters, with wikis and all.
21:23:20 <dolio> Heh.
21:23:31 <sm> hi Zao.. how's hastris coming
21:23:52 <dons> heh
21:24:16 <nanothief> haskell tetris?
21:24:58 <Zao> sm: It's rather inert, due to working on my thesis.
21:24:59 <Spark> sounds like a disease to me
21:25:10 <sm> ack! thesis
21:25:16 <Mr_Awesome> oh no! ive come down with an awful case of hastris!
21:25:18 <Zao> I hope you could get some use out of the source.
21:25:19 <sm> very bad for games hacking productivity
21:25:48 <sm> did you post the source ? I'd be interested to read
21:26:07 <Zao> http://www.acc.umu.se/~zao/Hastris/trunk
21:26:08 <lambdabot> Title: Index of /~zao/Hastris/trunk
21:26:12 <sm> thanks
21:26:13 <ddarius> sm: Mun's thesis didn't seem to hurt the productivity of his game hacking.
21:26:27 <sm> what was that.. frag ?
21:26:46 <ddarius> Yes
21:27:08 <sm> agreed!
21:27:45 <sm> Zao: you might consider making that a darcs repo .. ?
21:28:03 <sm> in due course
21:28:55 <Zao> It's under SVN at the moment, but the server is non-public.
21:29:01 <sm> oh, I see
21:29:03 <Zao> Mostly due to admin (me) incompetence.
21:29:07 <monochrom> "This thesis is about functional GUI. ...  As a proof of concept, we spent all our time playing^H^H^H^H^H^H^H implementing this game..."
21:29:50 <sm> you just darcs init there, then people could contribute easily
21:29:53 <sm> could
21:31:24 <Zao> I'd need to clean the code up a lot first.
21:31:53 <Zao> It has nice gems like forgetting to strictify STM channels and other Fun Stuff [TM]
21:32:10 <sm> ok you just scared me off :)
21:32:16 <sm> that's a notch above my know-how
21:34:01 <Zao> sm: Instead of evaluating things in another thread and passing the results through a channel, I just pass the computation thunk to the other thread, nullifying most of the multithreading gain.
21:34:06 <Zao> Or so I understand it.
21:37:26 <gwern> sm: strictifying channels is easy
21:37:45 <Zao> sm: It's the first non-trivial code I wrote while learning Haskell, so it's mostly horrible.
21:37:51 <dons> Zao: we have strict channels
21:37:56 <dons> grab the strict-concurrency lib
21:38:01 <gwern> sm: strictying looks like this:                 liftM (take n) $ getChanContents chan where n = length fs
21:38:09 <dons> channels really don't make sense unless they're strict, its weird.
21:38:16 <Zao> dons: Interesting, thanks.
21:38:37 <gwern> dons: I just mentally think of them as FIFOs. they seem pretty much equivalent
21:38:37 <dons> gwern: better to avoid wasted word though. that's still running the results on the *wrong* thrad
21:38:46 <ddarius> What should and should not be strict is only relatively recently becoming common work-a-day knowledge.
21:39:04 <dons> well, for concurrency, with channels, you really need the work done before writing to the chan
21:39:21 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict-concurrency
21:39:22 <lambdabot> http://tinyurl.com/2qwhus
21:40:03 <dons> its interesting how evaluation strategies become important with parallelism
21:40:09 <dons> you have to think about where the work gets done
21:40:10 <roconnor> > sin (pi/2)
21:40:13 <lambdabot>  1.0
21:43:02 <dons> Zao: maybe we need strict STM channels in the strict-concurrency lib too
21:45:15 <dons> oh, cool, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsparklines-0.1.0
21:45:15 <lambdabot> http://tinyurl.com/3dnj67
21:45:54 <dons> sjw`: sparklines :)
21:48:05 <dibblego> what do I need in .cabal for Could not find module `System': ? Isn't that in base?
21:49:03 <dons> System? no. System.IO perhaps?
21:49:09 <dons> that's an old haskell98 package
21:49:22 <dibblego> oh, I shouldn't be importing system?
21:49:55 <dons> System.Something
21:50:04 <dibblego> righto
21:50:05 <dons> otherwise you'll have a dep on the haskell98 package
21:50:22 <dibblego> ah; I have to figure that out I guess so I don't do that again
21:51:25 <dibblego> ?index system
21:51:25 <lambdabot> System.Cmd
21:51:54 <dibblego> Could not find module `System.Cmd': wtf?
21:51:56 <roconnor> @wn recurse
21:51:56 <lambdabot> No match for "recurse".
21:52:04 <roconnor> @sell recurse
21:52:04 <lambdabot> Maybe you meant: spell tell
21:52:10 <roconnor> @spell recurse
21:52:21 <dibblego> how do you know if you're using a haskell98 package or one in base?
21:52:58 <dibblego> System.Cmd appears in the GHC docs; I have base in Build-Depends in .cabal; what am I misunderstanding?
21:53:53 <dolio> "Haskell is an even more dumbed down version of... something. (Come on, no assignment? That must give me the right to say "dumbed down".)"
21:54:17 <roconnor> г‚ўгѓјг‚Їг‚їгѓіг‚ёг‚§гѓігѓ€
21:54:50 <dons> dolio: heh
21:54:54 <dons> where's that?
21:55:06 <dolio> In a comment on Chris Okasaki's blog.
21:55:15 <dons> i guess he at least appreciates that destructive updates are not for dummies
21:58:20 <monochrom> г‚ўгѓјг‚Їг‚їгѓіг‚ёг‚§гѓігѓ€ seems to mean arctan.
21:58:58 <monochrom> (I used google to search for г‚ўгѓјг‚Їг‚їгѓіг‚ёг‚§гѓігѓ€, then looked at the hits.)
21:59:15 <roconnor> yep
21:59:21 <dynamix> how to profile funciton invocations within the ghci interpreter?
22:00:08 <dons> :set +s
22:00:20 * monochrom is a Chinese.  Expert in playing that "Chinese room" game. :)
22:00:22 <dons> but really, you should compile the code with -prof -auto-all -O and use the proper profiler
22:01:07 <OceanSpray> what is [Word8] and how do I use it?
22:01:29 <dynamix> what is a proper profiler ? gprof or somethign like that?
22:01:30 <lucca-> monochrom: yes; it is the phonetic foreign syllabary and translates to aakutanjento
22:01:38 <lucca-> transliterates rather
22:01:43 <monochrom> > map fromIntegral ([0,1,2] :: [Word8]) :: [Integer]
22:01:43 <lambdabot>  [0,1,2]
22:02:04 <OceanSpray> huh.
22:02:49 <monochrom> Perhaps I don't understand your question.
22:02:54 <Zao> OceanSpray: It's an unsigned integer type 8 bits large.
22:03:09 <Zao> Or in your case, a list of them.
22:03:13 <OceanSpray> ok
22:03:27 <Zao> OceanSpray: Note that Char is an unicode codepoint, not a byte.
22:03:42 <OceanSpray> my problem is this:
22:03:52 <OceanSpray> I got some unicode strings,
22:04:21 <OceanSpray> but when I try to output them (with hPutStr), I get these '\123' thingamajigs.
22:04:38 <Zao> Look into the utf8-string package.
22:04:53 <dons> yeah, use the hPutStr for utf8 defined in that package
22:04:56 <Zao> Or find some other way to encode them in whatever oddball locale you use.
22:05:25 <OceanSpray> alrighty.
22:22:08 <dynamix> actually i was wrong. Haskell is at no 4. on the project euler list. i saw the user rankings earlier.
22:22:10 <blargeyfarg> i seem to vaguely remember a warning against using standard lists for the Writer monad's storage.  am i right in thinking that this would be due to the increasing cost of appending elements to the end as the list grows?  what's the recommended type for heavy append use with the Writer?
22:22:18 <dynamix> http://projecteuler.net/index.php?section=statistics
22:22:19 <lambdabot> Title: Project Euler
22:23:24 <OceanSpray> is '\123' one character?
22:23:26 <roconnor> blargeyfarg: [a] -> [a]
22:23:58 <solrize> so maybe you experts can tell me whether it gets easier to locate errors over time, given ghc error messages.
22:23:59 <Zao> OceanSpray: The regular hPutStr truncates codepoints on output and input.
22:24:17 <roconnor> blargeyfarg: although I think a clever implemenation of runwriter could do this automagically for you.
22:24:31 <povman> eh http://www.ruby-lang.org/ is a lot prettier than http://www.haskell.org/ IMO
22:24:33 <lambdabot> Title: Ruby Programming Language
22:24:34 <blargeyfarg> hmmm
22:24:45 <solrize> but the ruby language is incomparably uglier
22:25:15 <OceanSpray> I'm using the imported System.IO.UTF8.hPutStr, and it still gives me those codepoints as output.
22:25:19 <allbery_b> compared to haskell, yes.  compared to perl or python?
22:25:33 <solrize> hmm, i'd say partway between perl and python
22:25:38 <Zao> OceanSpray: Well, is your data valid?
22:25:54 <solrize> python actually looks pretty good, the gotchas are beneath the surface
22:25:58 * allbery_b thinks python has a bit too much Tcl nature.  ick
22:26:17 <allbery_b> I feel like I'm scripting in something akin to assembly language
22:26:37 <OceanSpray> well, I read it from a .xsl page with simpleHTTP
22:26:38 <solrize> hmm
22:26:41 <povman> but ruby's website looks edible, and makes me want to use ruby
22:27:23 <Zao> "false advertising" :)
22:27:31 <roconnor> blargeyfarg: I suppose you will want Endo [a] so that you get the Monoid type class.
22:27:38 * dolio used to use ruby, back when the website wasn't as alluring.
22:27:45 <dynamix> dont judge a book by its cover !!
22:27:49 <dolio> @hackage dlist
22:27:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
22:27:51 <allbery_b> (well, I did write something fairly dense in python recently but it looks distinctly non-python-ish
22:28:06 <blargeyfarg> roconnor: Endo?
22:28:07 <allbery_b> ...in fact it looks rather like I was trying to write haskell code in python)
22:28:12 <roconnor> @src Endo
22:28:13 <lambdabot> Source not found. I am sorry.
22:28:13 <povman> comparitively, haskell.org looks like a phd thesis
22:28:21 <roconnor> @hoogle Endo
22:28:22 <lambdabot> Data.Monoid.Endo :: newtype Endo a
22:28:22 <lambdabot> Data.Monoid.Endo :: (a -> a) -> Endo a
22:28:22 <lambdabot> Data.Monoid.appEndo :: Endo a -> a -> a
22:28:55 <roconnor> blargeyfarg: another posibility is to do things normally and then slap a ContT on top of your monad.
22:29:07 <roconnor> blargeyfarg: ContT makes everything faster.
22:29:37 <dolio> DList is what you want to use with Writer.
22:30:02 <roconnor> dolio: is DList a monoid?
22:30:18 <roconnor> I guess DList is essentially Endo [a]
22:30:20 <dolio> Yes. It's just a nicer looking interface for Endo [a].
22:30:21 <blargeyfarg> @hoogle DList
22:30:21 <lambdabot> Prelude.readList :: Read a => ReadS [a]
22:30:21 <lambdabot> Text.Read.readList :: Read a => ReadS [a]
22:30:21 <lambdabot> Text.Read.readListPrec :: Read a => ReadPrec [a]
22:30:41 <roconnor> lambdabot: not useful.
22:30:50 <blargeyfarg> heh
22:30:59 <bd_> @hoogle \bDList
22:31:00 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\bDList'
22:31:03 <bd_> aw
22:31:05 <dolio> But you can write 'fromList l' instead of 'Endo (++l)' or whatever you'd have to write with Endo.
22:31:54 <roconnor> dolio: I still think ContT Writer may work just a well.
22:32:21 <dons> ?hackage dlist
22:32:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
22:32:32 <dons> $ cabal install dlist
22:32:45 <roconnor> cabal install works?
22:32:50 <dons> sure.
22:32:57 <roconnor> since when?
22:33:10 <dons> grab darcs cabal, then build darcs cabal-install on top of it. been using it actively at work for 3 months or more
22:33:18 <dons> since about a month after the hackathon
22:33:29 <dons> btw, coming to the next hackathon, roconnor ?
22:33:38 <roconnor> nope.
22:33:49 <dons> oh, that's a pity. its not that far away, is it? :)
22:33:57 * dons should book tickets soon. hmm
22:33:58 <roconnor> I'm in Canada now.
22:34:01 <dons> ah!
22:34:22 <dons> on a permanent basis?
22:34:36 <roconnor> more or less
22:34:48 <povman> why isn't it called software-engineerathon
22:34:55 <dons> heh
22:37:06 <glguy> hpaste_: url
22:37:07 <hpaste_> http://71.111.57.135/cgi-bin/hpaste.fcgi/
22:37:15 <glguy> dons: what do you think of the syntax highlighter?
22:37:17 <dolio> roconnor: ContT Writer isn't a Writer.
22:37:36 <dolio> At least, not an instance.
22:37:43 <roconnor> dolio: I'm pretty sure it is.
22:38:09 <dons> glguy: cool!
22:38:37 <dolio> tell probably works, but some of the other methods can't be implemented or something.
22:38:39 <dons> well, that was easy enough, eh, glguy ?
22:39:07 <glguy> dons: yeah, and had good collateral damage
22:39:34 <roconnor> dolio: damn, you are right.
22:39:49 <joed> Damn, dog demands to sleep on daughters hat.
22:39:49 <roconnor> when I did this, I knitted things by hand.
22:40:19 <glguy> dons: check out the list of supported languages too
22:40:27 <glguy> I need to pare it down a bit
22:40:30 <glguy> but it's pretty massive for now
22:40:35 <dolio> Of course, I've never used anything but tell in Writer.
22:40:43 <roconnor> dolio: I assumed I made resonable instances of pass and tell.
22:40:45 <roconnor> er
22:40:47 <dons> heh, glguy
22:40:49 <roconnor> dolio: I assumed I made resonable instances of pass and listen
22:41:40 <roconnor> though I remember one being tricky
22:42:02 <roconnor> what's that new replacement for the MTL?
22:42:30 <roconnor> monadLib
22:43:03 <dons> yeah, monadLib
22:43:17 <dons> iavor will be happy to have some more users
22:43:38 <blargeyfarg> btw, thanks all for the help.  dlist is working perfectly
22:43:58 <roconnor> dolio: WriterM m j => WriterM (ContT i m) j
22:44:02 <roconnor> from monadLIb
22:44:24 <roconnor> which only has put
22:44:27 <roconnor> :)
22:44:29 <dolio> Yeah, his only has put.
22:45:08 <dolio> I've tried making an instance for the MTL one, but I don't think I ever figured out pass.
22:45:38 <roconnor> dolio: I think it was pass that screwed me up
22:45:47 <dolio> Which is, presumably, why it isn't in MTL. :)
22:45:49 <roconnor> pass is dumb
22:45:55 <roconnor> censor is far more reasonable.
22:46:10 <roconnor> but maybe I should read the motivation for pass.
22:46:22 <dons> glguy: so is it ready to go
22:46:39 <dolio> What's the difference?
22:46:46 <roconnor> @type pass
22:46:46 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
22:46:50 <roconnor> @type censor
22:46:51 <lambdabot> forall w (m :: * -> *) a. (MonadWriter w m) => (w -> w) -> m a -> m a
22:47:48 <dolio> Ah.
22:48:01 <roconnor> IIRC the problem with pass was that for a particular monad m, the function w->w may not really exist.
22:48:28 <roconnor> so you won't actually have a function to filter with. when you try and implement it.
22:49:23 <roconnor> but still the default of doing no filtering seemed reasonable.
22:49:38 <roconnor> I don't know what the MonadWriter laws for pass are supposed to be.
22:52:49 <OceanSpray> now I've figured out how to write unicode.
22:52:56 <OceanSpray> but the encoding is all wrong.
22:53:00 <dolio> Yeah. In ContT, pass is (((a, w -> w) -> m r) -> m r) -> (a -> m r) -> m r, which clearly doesn't work too well.
22:53:12 <dons> interesting, OceanSpray
22:53:15 <dons> a locale issue?
22:53:19 <OceanSpray> how do I find what ISO-(*&$^% it is?
22:53:30 <OceanSpray> locale?
22:53:35 <OceanSpray> what's a locale?
22:54:48 <roconnor> dolio: oh I see.  In my case I was working with forall r. ContT r ...
22:55:14 <adu> OceanSpray: which ISO-*&$^%? there are several...
22:55:18 <roconnor> that allowed me to plug in whatever I wanted for r, so I could run the continuation up a halfway point.
22:57:53 <roconnor> @djinn (((a, w -> w) -> mr) -> mr) -> (a -> mr) -> mr
22:57:53 <lambdabot> f a b = a (\ (c, _) -> b c)
22:58:00 <quicksilver> OceanSpray: how are you writing unicode, in fact?
22:58:06 <roconnor> not the most useful function :)
22:58:29 <noige> hi
22:58:31 <dolio> Yeah. That looks like it doesn't do what pass is supposed to do. :)
22:58:43 <Deewiant> @pl f a b = a (\(c, _) -> b c)
22:58:43 <lambdabot> f = (. flip (ap . (. fst) . (const .)) snd)
22:58:53 <OceanSpray> well, I'm just using the System.IO.UTF8 package's put functions
22:59:17 <OceanSpray> turns out that I was using show, which was messing the strings up.
22:59:21 <quicksilver> OceanSpray: then, the encoding should be UTF8 ;)
23:00:08 <quicksilver> Hmm. Show shouldn't mess with much. Just scatter some " and \ around.
23:00:31 <OceanSpray> !song
23:00:32 <Shinku> /touhou.ogg
23:00:32 <Shinku> /weeaboo.ogg
23:00:39 <OceanSpray> well, dang.
23:01:19 <dons> quicksilver: well, '\
23:01:34 <dons> grr. yes.
23:02:28 <quicksilver> yes. Scatter some " and \ around, escape some control-characters
23:02:31 <quicksilver> ah
23:02:35 <quicksilver> will it escape the high-bit chars too?
23:02:55 <OceanSpray> does this channel disallow unicode characters or something?
23:03:13 <Deewiant> Г¤Г¶ГҐ
23:03:33 <quicksilver> OceanSpray: no, they work fine. Although I'm too stupid to read them.
23:03:45 <adu> I see 'A'-Euro-'A'-Para-'A'-Yen
23:03:51 <OceanSpray> because !song should have given some weird unicode characters, but it obviously got "swallowed up"
23:04:05 <quicksilver> dons: BTW, ByteString's show instance incurred my displeasure yesterday.
23:04:20 <OceanSpray> I changed nothing but the network and channel to join.
23:04:22 <quicksilver> dons: I can't copy and paste my QuickCheck counterexamples :(
23:05:01 <dons> sorry
23:05:07 <adu> ?????? Mr. ???
23:05:10 <dons> what would you like? pack "foo" ?
23:05:25 <dons> or maybe strings, and then use OverloadedStrings ?
23:05:50 <Deewiant> adu: I guess you're not in UTF-8 mode
23:05:54 <quicksilver> dons: its a good question, actually. What I'd really like is B.pack "foo"
23:06:09 <quicksilver> dons: but how on earth would a Show instance know how qualified the module was :)
23:06:14 <dons> right, i could do: pack "foo"
23:06:22 <quicksilver> yeah.
23:06:40 <quicksilver> I think that would be better. Consistent with Data.Map and Data.Sequence
23:07:27 <adu> Deewiant: what did mine look like?
23:07:41 <Deewiant> adu: nothing but question marks :-)
23:07:47 <adu> oh
23:07:49 <Deewiant> and "Mr." in between
23:07:53 <adu> lol
23:08:15 <adu> i don't think IRC was designed with Unicode in mind
23:10:10 <wagle_home> ШЄ
23:11:02 <adu> my client has no encoding options
23:11:22 <wagle_home> adu, how did my previous line come out?
23:11:43 <Deewiant> wagle_home: you managed to reverse my timestamp
23:12:00 <adu> i saw OSlash-(Degree/superscript a)?
23:12:28 <dolio> roconnor: passCT m = ContT $ \k -> runContT m (\(c, f) -> pass $ liftM (\a -> (a, f)) (k c))
23:12:30 <Deewiant> sounds like ISO 8859-1
23:12:39 <wagle_home> ahaha..  Deewiant's client is better than mine..  (it should go from right to left..  my input is right to left, but display is still left to right
23:12:52 <dolio> roconnor: That types, but it censors stuff that happens after passCT, instead of stuff that happens within passCT.
23:13:20 <Deewiant> wagle_home: not completely, though: where I would have expected "2008-02-27 09:09:22" I got "72-20-800209:10:10 "
23:13:49 <wagle_home> adu, it is an arabic char that looks like a smiley
23:13:58 <adu> hmm
23:14:07 <adu> I definitely have the fonts for that
23:14:18 <adu> I used to write arabic for my arabic class
23:14:30 <adu> I'm going to find a unicode irc client
23:14:42 <wagle_home> i use xchat, but ...
23:15:07 <adu> i use xchat in linux fo sho!, but not on macosx
23:16:23 <wagle_home> i use xchat even on macosx..  8/
23:17:30 <wagle> but (HA ha) it doesnt display right on macosx
23:17:30 <lambdabot> wagle: You have 1 new message. '/msg lambdabot @messages' to read it.
23:18:17 <adu> but its not native so it can't use my nice fonts
23:24:15 <adu> Г¤Г¶ГҐ
23:24:43 <adu_1> гѓ‰гѓўг‚ўгѓЄг‚¬гѓ€ Mr. г‚Єгѓњгѓ€
23:25:04 <adu_1> is that UTF8?
23:25:07 <Zao> Yes.
23:25:09 <glguy> yes
23:25:13 <adu_1> :)
23:25:19 <glguy> mr roboto?
23:25:26 <Zao> At least I get assorted moonspeak.
23:25:30 <adu_1> ya I love that song
23:25:40 <OceanSpray> I finally got it.
23:25:51 <quicksilver> \o/
23:26:01 <blargeyfarg> you know, i have a serious problem with this languange, in that i have to go back to work tomorrow and write C all day
23:26:15 <OceanSpray> Haskell -> C translation?
23:26:28 <blargeyfarg> heh
23:26:29 <glguy> blargeyfarg: don't lose hope, there are Haskell jobs :)
23:26:40 <adu_1> really? i want a Haskell job
23:26:55 <blargeyfarg> no kidding
23:28:29 <adu_1> ж—Ґжњ¬иЄћ
23:28:30 <dons> hey, i've a haskell job
23:28:35 <dons> oh, hey , so does glguy
23:28:40 <dons> wow, they're everywhere!
23:28:43 <dons> rock out lambda style!
23:28:49 <adu_1> dons: can I work for you? :)
23:28:55 <blargeyfarg> just keep rubbing it in
23:29:30 <blargeyfarg> i enjoy abuse.  really.  that's why i stick with C.  it toughens the skin
23:29:54 <adu_1> ж—Ґжњ¬иЄћ
23:29:59 <Zao> adu_1: http://www.galois.com/join.php
23:30:00 <lambdabot> Title: Join the Team
23:30:30 <opqdonut> :)
23:31:03 <dons> i wish they'd update the web site design though
23:31:12 <dons> glguy: don't we have people to do that?
23:31:31 <adu_1> woah FPGA compiler? that sounds intense!
23:32:05 <adu_1> i wanna write an FPGA compiler!
23:32:06 <xpika> is there any functional calculus where you can lambda lambdas?
23:32:38 <xpika> ie . (\(\f x->x) -> (\f x-> f x))
23:33:10 <opqdonut> xpika: how would that work?
23:33:15 <wagle_home> what would that mean?
23:33:20 <opqdonut> ah, you mean pattern matching on functions?
23:33:25 <xpika> opqdonut: strangly im not too sure myself
23:34:10 <xpika> opqdonut: some sort of a system where the parts of a funcion are as first class as a datatype
23:34:27 <glguy> you want macros
23:34:28 <glguy> :)
23:34:31 <opqdonut> yeah, pattern matching on function implementation
23:34:53 <opqdonut> data Expr = App Expr Expr | Var Char | Lambda Var Expr
23:35:41 <xpika> (\(\f x->z) -> (\f x->f (z)) (\f x-> x) => (\f x-> f (f x))
23:36:21 <opqdonut> how about applying that to \x->x?
23:36:24 <opqdonut> error?
23:37:21 <xpika> opqdonut: failed pattern match more like it
23:37:23 <aleator_> Silly question: I've got a program like this: main = sequence_ [doBigComputationAndWriteResultsToFile p | p<-parameters]. Which seems to leak memory. If I write it as a recursion instead sequence it seems not. Why?
23:37:41 <dons> hmm. can't tell from that.
23:37:45 <dons> compiled with -o ?
23:37:47 <dons> compiled with -O ?
23:37:53 <aleator_> -O1
23:38:12 <dons> can't tell. i suspect [doBigComputationAndWriteResultsToFile is the issue
23:38:58 <aleator_> Probably, but how could it then make a difference wether there is sequence or recursion?
23:39:07 <wagle_home> @src sequence_
23:39:07 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
23:39:39 <aleator_> Ah!
23:40:18 <aleator_> So that might just hang on to return values of the bigComp, which could be huge thunks? Right?
23:42:16 <dons> yeah, maybe try mapM_ doBigComputationAndWriteResultsToFile parameters
23:42:59 <dolio> @src mapM_
23:42:59 <lambdabot> mapM_ f as = sequence_ (map f as)
23:43:30 <aleator_> dons: thanks. it was list comprehension, because it is actually form of [f a b c | a <-stuff1, b<-stuff2,c<-stuff3]
23:43:42 <dons> ah hmm. then that's more relevant
23:43:48 <dons> those nested generators eh?
23:44:41 <aleator_> Hmm?
23:44:45 <adu_1> do i have to move to Oregon to work at Galois?
23:46:04 <dons> adu_1: generally, yep.
23:46:49 <adu_1> so much Haskell stuff is happening in Oregon
23:46:55 <hpaste>  mmorrow pasted "compose" at http://hpaste.org/5938
23:47:01 <dolio> aleator_: What's your explicit recursion look like?
23:47:36 <glguy> dons: iavor added the interface to make lines on pastes marked
23:47:44 <glguy> I'm envisioning yellow background
23:48:26 <dons> yeah
23:49:16 <glguy> once I can render them (tonight?) we'll want to figure out some interface
23:49:29 <hpaste>  mmorrow annotated "compose" with "or" at http://hpaste.org/5938#a1
23:50:14 <aleator_> dons: it is params = [(a,b,c) | a<-stuff1,b<-stuff2,c<-stuff3]; doAll [] = return (); doAll ((a,b,c):ps) = bigComputation a b c >> doAll ps; doAll params
23:53:32 <hpaste>  morrow annotated "compose" with "...ModDot?" at http://hpaste.org/5938#a2
23:56:14 <hpaste>  mmorrow annotated "compose" with "(no title)" at http://hpaste.org/5938#a3
