00:00:27 <solrize> thanks oerjan
00:00:39 <glguy> ddarius: it is clever that they used o. for functions relating to circles :)
00:01:31 <dolio> Isn't call/cc almost trivially not referentially transparent, considering the entire purpose is to be able to manipulate the context in which it's called?
00:01:38 <dolio> Same with shift.
00:02:08 <wy> ddarius: Are they fundamentally different?
00:02:23 <ddarius> wy: Intercal and J?  Yes.
00:02:37 <wy> ddarius: why?
00:02:38 <dolio> J is like APL.
00:02:42 <dolio> And Intercal is crazy.
00:02:58 <glguy> crazy oriented programming?
00:03:17 <siti> as bad as OO ?
00:04:06 <dolio> J, for instance, has no requirements about being sufficiently (but not overly) polite.
00:04:36 <ddarius> "PLEASE" would be a massively long identifier for J.
00:04:47 <wagle_home> i'm not sure what referential transparency means...  i optimize equivalent with equivalent in fortran..  its just a complicated equality..  how simple to you have to make the equality test before its officially "refererentially transparent"?
00:07:38 <oerjan> the test is:  can you replace an identifier by its defining expression, even if it is used none or several times?
00:07:57 <wy> "The effort required to become an expert J programmer is closer to that required to become an expert C++ programmer."
00:08:03 <wy> Is C++ that hard?
00:08:10 <siti> yes
00:08:13 <QtPlatypus> wy: Increadably.
00:08:24 <dons> yes, read http://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps
00:08:48 * QtPlatypus doesn't know that c++'s niche is supposed to be.  Its sloweer then C, its harder to write applications in then java.
00:08:49 <wy> I didn't found C++ very hard when I studied it. But I have never used it since then
00:09:13 <wy> dons: Is that the first paper on pureness?
00:09:17 <siti> to use c++ well you need to know so much stuff...
00:09:24 <dons> wy, surely not. but its one about what 'purity' means
00:09:30 <wy> siti: Is that unreasonably much?
00:09:34 <dons> and will likely point to the first paper
00:10:12 <dolio> You can get by in C++ without knowing too much about it, I imagine.
00:10:16 <wy> dons: I found that paper a few days ago when I applied Indiana
00:10:34 <glguy> is there a decent way to make a row in a table clickable?
00:10:37 <wy> Sabry seems to have done lots of fundamental work
00:10:38 <dolio> But if you want to consider yourself an expert, you're going to need to know a lot.
00:10:47 <wagle_home> suppose i bind a variable to ackerman 100 100..  suppose its already been computed and stored in x.  is replacing x by ackerman 100 100 referentially transparent?
00:10:51 <glguy> other than making all of cells individual anchors?
00:10:53 <siti> wy: c++ is like learning: java (OO etc), c (memory managment etc), templates and lots of quirks...
00:11:08 <dolio> Like, learning an additional Turing complete language for templates and so on.
00:11:16 <wy> siti: I guess it would still be nicer than perl
00:11:21 <jeffz> glguy: not sure, but maybe a click handler
00:11:41 <Cin> glguy: either an <a> tag with display:block or javascript onclick handler?
00:12:04 <glguy> Cin: does xhtml or html allow for <tr> inside <a> though?
00:12:06 <wy> and they are all nicer than TeX... and Intercal ;)
00:12:50 <Cin> glguy: i meant the other way round. <td><a style='display:block'>hello</a></td>  -- here your mouse can click the general cell area instead of just the text bits
00:13:01 <Cin> glguy: unless we're getting our wires crossed
00:13:01 <wy> "It is easier to learn enough Basic or Java to solve trivial problems, but it is easier to learn enough J to solve more interesting and challenging problems..."
00:13:07 <wy> How can this be true?
00:13:20 <glguy> Cin: oh, that is the one anchor in each cell method I mentioned
00:13:27 <glguy> so yeah, we're on the same page there
00:13:28 <Cin> glguy: ah, i see
00:13:33 <glguy> but that makes :hover kind of ugly
00:13:47 <Cin> glguy: in what way?
00:13:49 <piojo> wy: from what i've heard, J has crazy functions, like one that returns the ith prime. so you can write crazy stuff, knowing just a little J
00:13:58 <Cin> glguy: perhaps remove the td's padding?
00:14:03 <glguy> Cin: it wouldn't fire for the whole row
00:14:07 <glguy> Cin: just the one cell
00:14:14 <Cin> glguy: ahh
00:14:40 <siti> avg=: +/ % #
00:14:40 <Cin> javascript it is?
00:14:40 <siti> what on earth S:
00:14:40 <wy> piojo: But that can be easily written?
00:15:00 <piojo> wy: i mean, things like that are built into the language
00:15:16 <piojo> so they are easily used as building blocks to write even crazier functions
00:15:19 <wy> So it's much like perl's style
00:15:49 <piojo> i don't know quite enough perl to know...
00:16:09 <Cin> glguy: i presume you can just do <tr onmouseover='this.style.bgColor="foo"'> etc?
00:16:20 <glguy> + is add, / is insert, +/ is therefore sum, % is divide, and # is length
00:16:30 <glguy> Cin: that's more or less what I have on the current hpaste
00:16:34 <glguy> just seems ugly though
00:16:52 <Cin> indeed
00:16:58 <wy> I think that's not good
00:18:03 <glguy> (f g h)   is a fork   and (f g h) x  becomes:  (f x) g (h x)
00:19:19 <wagle_home> haskell is pretty opaque to people who dont know it
00:19:32 <Cin> glguy: have you got any abstract way of validating your input data from the user in cgi?
00:19:44 <glguy> yeah, at the type level
00:19:47 <glguy> check out the first paste at:
00:19:51 <glguy> http://71.111.57.135/cgi-bin/hpaste.fcgi/
00:19:51 <glguy> titled api.hs
00:22:00 <ddarius> p: @: i. should be all the primes up to a given n
00:23:51 * solrize just spent around half an hour figuring out why i was getting type error from "return x + y" 
00:26:13 <solrize> because i needed "return $ x + y"
00:46:18 <wy> I wouldn't look into Haskell if I hadn't used ML in my PL course, and I wouldn't have taken that course if I didn't learned Common Lisp, and I wouldn't have learned Common Lisp if I hadn't learned Scheme, and I wouldn't have looked into if I hadn't asked Richard Stallman, and I wouldn't have asked him if I wasn't tired of C...
00:46:21 <solrize> ML seems like a clean language underneath a hideous surface syntax
00:46:25 <Cin> RMS Mathew Stallman
00:46:25 <ddarius> solrize: ML is a clean language
00:46:25 <solrize> clean but uggggggly ;)
00:46:25 <ddarius> solrize: yes
00:46:25 <wy> That's not really hideous
00:46:25 <Cin> glguy: i actually meant things like the length and format of input
00:46:25 <Cin> glguy: is this e-mail valid? etc
00:46:25 <glguy> Cin: no, but I suppose that I'm far enough along that that is necessary
00:46:25 <glguy> email validation is not necessary
00:46:25 <glguy> however
00:46:26 <wy> Not convenient though. I looked at Haskell because I found that I couldn't even print out the values of my data types without defining some print function for each of them
00:46:26 <wy> in ML
00:46:28 <ddarius> wy: You can't in Haskell either.
00:46:28 <wagle_home> deriving Show
00:47:15 <ddarius> wagle_home: Which defines a "print" function.
00:47:15 <wy> wagle_home: I'm still wondering what's happening in the compiler with deriving ...
00:47:15 <ddarius> wy: It's defined in the Report.
00:47:15 <Cin> glguy: hmm. i think i've been overestimating how much of a problem it will be to validate all the user inputs
00:47:16 <Cin> glguy: like, i want a validate function for each input which returns either that value or an error saing what's wrong with it
00:47:16 <wagle_home> ghc defines a whole language, but wy doesnt need to do it
00:47:16 <Cin> glguy: but i was thinking maybe i could make some combinators so i'm not duplicating validation code etc.
00:47:19 <Cin> ehh i'll give it a try
00:47:40 <glguy> Cin: at the level of dealing with checking user input
00:47:40 <glguy> you want to do more than complain
00:47:40 <glguy> you might want to return them to a filled out form
00:47:40 <glguy> with some error messages
00:47:40 <Cin> that's what i mean
00:47:47 <glguy> which isn't just a matter of defining a few combinators I'd think
00:48:34 * oerjan doesn't like the small font size in the new hpaste and hopes that is temporary.
00:58:21 <ddarius> !paste
01:19:01 <hpaste> Haskell paste bin: http://hpaste.org/
01:20:00 <Cin> glguy: well i have a hunch i want to try that i think could work nicely
01:20:03 <wy> got it. It's really a kind of "metaprogramming"
01:20:03 <glguy> Cin: try it out then :)
01:20:03 <glguy> oerjan: what color do you want your bikeshed?
01:46:53 * ddarius agrees with oerjan 
01:46:58 <Cin> oerjan: i recommend setting a minimum font size in your browser, that way, you never ever have this problem
01:47:41 <ddarius> glguy: How about a preview?
01:47:42 <glguy> that's one the list of good ideas
01:47:44 <glguy> on*
01:47:46 <glguy> if you look at th api, it's actually a parameter :)
01:47:51 <glguy> dons wants to do some stuff with customizable rss feeds
01:47:53 <glguy> searching functionality has been added but not exposed and is intended to get more powerful
01:47:53 <oerjan> glguy: since you ask, i don't think the main menu is particularly _pretty_.  the small font of the pastes, however, makes it harder to read.
01:49:03 <glguy> if someone wants to do a full overhaul of the css, I'd be happy to look at it, but at this point I'm not going to be spending time tweaking the theme
01:49:18 <ddarius> This is a cute one:  the equivalent to \f z -> map (foldr f z) . tails in J is / \
01:49:21 <siti> when will people learn to not get mixed up between compression algorithms and programming languages
01:49:21 <wy> hehe
01:52:37 <porrifolius> Hi.
01:53:34 <porrifolius> How do I raise a number to a fractional exponent?
01:58:48 <porrifolius> Is there an existing library function?
01:58:48 <ddarius> :t (**)
01:58:48 <lambdabot> forall a. (Floating a) => a -> a -> a
01:59:12 <ddarius> :t (^^)
01:59:12 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
01:59:12 <noige_> hi
01:59:12 <ddarius> (* ($: @: <:)) ` 1: @. (= 0:) I can't believe this is actually starting to be both readable and writeable to me
01:59:12 <wagle_home> why shouldnt it?
01:59:13 <solrize> *Main> :t (* ($: @: <:)) ` 1: @. (= 0:)
01:59:13 <solrize> <interactive>:1:7: parse error on input `@:'
01:59:13 <wagle_home> poor bot
01:59:13 <wagle_home> :cookie
01:59:13 <wagle_home> @cookie
01:59:13 <lambdabot> Unknown command, try @list
01:59:13 <wagle_home> @snack
01:59:13 * lambdabot karate-chops  into two equally sized halves
01:59:13 <ddarius> @bot
01:59:13 <lambdabot> :)
01:59:13 <ddarius> wagle_home: I only started like four hours ago.  It is surprising how quickly it becomes understandable.
01:59:13 <wagle_home> i remember when perl, especially regexps, looked like line noise to me..  now i do them all the time
01:59:13 <ddarius> I think my experience with point-free code helps a lot here.
01:59:13 <wagle_home> i've even seen very opaque haskell programs whose authors were very proud of the simplicity they had achieved
01:59:13 <wagle_home> yeah, looked pretty pointfree
01:59:13 <wagle_home> is it going left to right (or right to left, like haskell)?
01:59:13 <glguy> solrize: was that factorial?
01:59:13 <ddarius> wagle_home: It's not that simple.
01:59:13 <wy> I saw many smiling faces on my screen
01:59:13 <solrize> which?  that thing i pasted?  it was ddarius's example, i couldn't figure out if it was real or not
01:59:13 <ddarius> solrize: It's real, but it isn't Haskell.
01:59:13 <ddarius> And yes it is factorial.
01:59:13 <Zao> Thankfully.
01:59:13 <solrize> perl?
01:59:13 <jrx> hi
01:59:13 <glguy> J
01:59:13 <ddarius> solrize: J
01:59:13 <solrize> oh
01:59:13 <solrize> that doesn't look apl-like
01:59:13 <jrx> do you know, where can I find some information, about monadic parser transformers for Read ?
01:59:14 <glguy> I still think ` is confusing though
01:59:14 <jrx> are there any?
01:59:14 <wagle_home> http://en.wikipedia.org/wiki/J_programming_language
01:59:14 <glguy> jrx: like ReadP, ReadPrec or Parsec?
01:59:14 <ddarius> glguy: ` seemed very straight forward once I was actually told what it was
01:59:14 <wagle_home> it tries to use only ascii, unlike apl
01:59:16 <glguy> ddarius: I find it hard to see where the delimiters are at a glance mostly
01:59:16 <solrize> times reduce iota n
01:59:16 <jrx> glguy: Could you give me some more insight, what they are?
01:59:16 <ddarius> */i.n
01:59:16 <solrize> yeah
01:59:16 <glguy> i. 4 is 0 1 2 3?
01:59:16 <ddarius> Yes
01:59:16 <glguy> so... 0:
01:59:16 <glguy> might be faster
01:59:16 <solrize> "rho rho rho of x, always equals one; rho's dimension, rho rho rank, APL is fun!"  --RMs
01:59:16 <solrize> rms
01:59:16 <solrize> RMS
01:59:16 <solrize> darn :)
01:59:16 <ddarius> So you'd want */ >: i. n
01:59:16 <jrx> I'm making my class instance of Read, and implement some parsing for it, but without monads it looks quite ugly, I have read that monads can make this process cleanes, but I don't know where to start looking
01:59:16 <wagle_home> listening to japanese speech got a lot easier when i could break it up into words (as I heard it) even without knowing what the words meant
01:59:16 <ddarius> That would be $ $ $ x in J.
01:59:16 <glguy> ddarius: nope, you'd want  !
02:00:01 <glguy> :-D
02:00:01 <wagle_home> listening to languages closer to english isnt so hard, since i generally hear the words
02:00:02 <solrize> hey does anyone know why i can't use "deriving Show" on a gadt?  i keep asking that, no one seems to know
02:00:04 <ddarius> glguy: Well, yeah.  And who's going to beat J in implementing the nth prime function: p:
02:00:04 <ddarius> solrize: As far as I know deriving isn't implemented at all on GADTs.  Presumably it is either trickier than one would expect or just not gotten around to.
02:00:05 <solrize> hm, i use "deriving Show" for debugging all the time, is there some other approach?
02:00:05 <wagle_home> ?go monad transformers
02:00:06 <lambdabot> http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
02:00:06 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers
02:00:06 <ddarius> solrize: You can write your own instance or your own toString function.
02:00:07 <wagle_home> ?go yaht
02:00:07 <lambdabot> No Result Found.
02:00:09 <wagle_home> @hoogle yaht
02:00:09 <lambdabot> No matches found
02:00:09 <wagle_home> http://en.wikibooks.org/wiki/Haskell/YAHT
02:00:09 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
02:00:09 <wagle_home> whoops
02:00:09 <wagle_home> huh..  cant remember the name of the "yet another" monad tutorial thingy
02:00:09 <wy> Any ideas on Intercal's interleave and selector operators? They must have some meaningful power to exist in the language I guess
02:00:09 <hpaste>  (anonymous) annotated "CABAL hidden package" with "(no title)" at http://hpaste.org/5854#a1
02:00:10 <ohub> Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep! :D
02:00:10 <noige_> what does this mean? data User = User String String String Int String String deriving (Show)
02:00:10 <TSC> It defines a new data type called User
02:00:10 <hpaste>  mmorrow pasted "a cgi/fastcgi (+concurrency) monad xformer" at http://hpaste.org/5857
02:00:10 <TSC> Where a value of that type looks like (User s1 s2 s3 i s4 s5)
02:00:10 <TSC> (where sx is a string, i is an Int)
02:00:10 <noige_> oh ok
02:00:10 <noige_> thanks
02:00:10 <TSC> You're welcome
02:00:10 <noige_> :t ( pi * r ) ^ 2
02:00:10 <lambdabot> Not in scope: `r'
02:00:10 <jre2> does anyone know why type classes aren't first-class?
02:00:10 <sioraiocht> @seen dcoutts
02:00:10 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 7h 57m 56s ago.
02:00:10 <sioraiocht> @seen dcoutts_
02:00:10 <lambdabot> dcoutts_ has changed nick to dcoutts.
02:00:10 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 7h 58m ago.
02:00:10 <jrx> @info when
02:00:10 <lambdabot> when
02:00:10 <jrx> @src when
02:00:10 <lambdabot> when p s = if p then s else return ()
02:00:10 <jrx> @hoogle when
02:00:10 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
02:00:10 <oerjan> @tell wy if my memory is not faulty, interleave allows you to position bits for bit twiddling with the unary operators, while select allows you to extract the result.
02:00:10 <lambdabot> Consider it noted.
02:03:09 <Cin> @pl (\(f,n) -> getInput n >>= f)
02:03:09 <lambdabot> uncurry (flip ((>>=) . getInput))
02:04:33 <hpaste>  SL pasted "(no title)" at http://hpaste.org/5858
02:08:48 <hpaste>  SL pasted "(no title)" at http://hpaste.org/5859
02:20:32 <solrize> is there a simple way to remove leading and trailing space from a string?  do i really have to do something like (dropWhile isSpace) ?
02:20:49 <solrize> and reverse . (dropWhile isSpace) . reverse  ?
02:21:04 <oerjan> the first one is pretty simple... although it only works for leading ones
02:22:35 <oerjan> reverse . dropWhile isSpace . reverse . dropWhile isSpace
02:22:43 <solrize> uggh
02:23:08 <solrize> http://techiesabode.com/article/read_article_w.php?article_id=13    i'm trying to do these examples in haskell
02:23:09 <lambdabot> Title: TechiesAbode: Python & Java: a Side-by-Side Comparison
02:23:33 <oerjan> if you want it to be lazy and not reverse the whole string you are going to need something even more complicated
02:24:35 <oerjan> there should have been an initWhile to remove things from the end of strings...
02:25:01 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5860
02:25:07 <solrize> that was me
02:25:17 <bd_> dropWhile isSpace . takeWhile (not . isSpace) ?
02:25:28 <bd_> er, other way aroung
02:25:40 <solrize> that stops at an internal space
02:25:48 <oerjan> solrize: you want putStrLn "Hello, world!", not print
02:25:56 <oerjan> otherwise you get it with quotes
02:26:16 <solrize> heh yes i didn't even notice that
02:28:31 <oerjan> if you don't care about collapsing spaces in a row, unwords . words works nicely
02:28:47 <solrize> well i wanted to do exactly what the python and java examples do
02:29:34 <bd_> solrize: you could use Bytestring's breakEnd
02:29:48 <solrize> hmm ok
02:30:17 <bd_> > fst . breakEnd isSpace . dropWhile isSpace $ "  foo  "
02:30:25 <lambdabot>   Not in scope: `breakEnd'
02:30:34 <bd_> what does lambdabot import Data.ByteString as?
02:30:39 <jre2> is the curl package at http://code.haskell.org/curl/ stable? I'm curious why it isn't on hackage
02:30:40 <lambdabot> Title: Index of /curl
02:31:10 <bd_> > fst . Data.ByteString.breakEnd isSpace . Data.ByteString.dropWhile isSpace $ Data.ByteString.pack "  foo bar  "
02:31:10 <lambdabot>   Not in scope: `Data.ByteString.pack'
02:31:14 <bd_> bah
02:32:04 <solrize> http://www.dmh2000.com/cjpr/  maybe this one next
02:32:04 <lambdabot> Title: dmh2000-C/Java/Python/Ruby
02:36:51 <smg> good curried morning.
02:37:05 <smg> is there a haskell operator precedence tableau? i don't find one. :(
02:38:25 <hpaste>  solrize pasted "(no title)" at http://hpaste.org/5861
02:38:38 <solrize> is that ok as the t ype signature for the cjpr example?
02:39:53 <solrize> "Certainly, starting from scratch, learning Haskell is no harder than learning most OO languages. "  (http://sequence.complete.org/node/127)   that seems completely wrong!
02:39:55 <lambdabot> Title: Haskell is not an academic toy, but it is not corporate ready either | The Haske ...
02:40:54 <smg> solrize: why?
02:41:01 <solrize> which?
02:41:11 <smg>  that seems completely wrong! <-- warum?
02:41:40 <solrize> at least for me, haskell has a much steeper learning curve than python, java, lisp, etc.
02:41:55 <smg> sure
02:41:56 <smg> for me too
02:42:05 <smg> i only coded in perl,java,c++,c and python
02:42:14 <Cale> solrize: If you're coming from an imperative language background, it's harder than starting from nothing.
02:42:23 <Cale> (at least initially)
02:42:26 <smg> and haskell is hard for me, but you get used to it, the indent is tricky + the monads stuff
02:42:37 <smg> Cale: really true
02:42:41 <solrize> cale, that may be part of it, but say i'm coming from an untyped functional language like scheme
02:42:52 <Cale> You essentially have to un-learn a lot of habits of imperative programming which turn out to be bad habits in functional programming.
02:43:03 <solrize> the type system breaks my head much worse than the functional vs imperative difference
02:43:06 <smg> Cale: especially iteration etc :)
02:43:10 <Cale> solrize: Scheme is not just untyped, but it supports imperative programming as well :)
02:43:14 <Cale> (and it's strict)
02:43:38 <solrize> well there's a lazy scheme variant in sicp
02:43:59 <araujo> solrize, that's because someone coming from a dynamic language uses to fight against the type system at the beginning.
02:44:02 <Cale> Once you learn the basics of the type system, it becomes a lever on which you can push to learn more about the rest of Haskell, so I really do recommend focusing on it.
02:44:09 <smg> solrize: what's your problem?
02:44:19 <smg> have you read YAHT and "a gentle intro to haskell"?
02:44:23 <araujo> Remember , types are your friends , don't fight them
02:44:27 <jre2> is there a standard process for submitting patches to code.haskell.org?
02:44:36 <Cale> If there something in particular which confuses you about types?
02:44:41 <solrize> smg, yes, i've looked at those
02:44:45 <smg> read both
02:44:47 <smg> 2 times
02:44:53 <smg> :)
02:45:03 <Cale> jre2: Not that I'm aware of. You can get an account there if you expect to make a lot of them.
02:45:08 <smg> i learn also with those documents, they are really good
02:45:12 <smg> and make the exercises
02:45:15 <Cale> jre2: Otherwise, contact the author of the code.
02:45:18 <solrize> cale, sure, i want to use HaPPs and it's way baffling
02:45:23 <smg> sorry if i repeat myself: is there a haskell operator precedence tableau? i don't find one. :(
02:45:35 <solrize> smg you mean a list of default precedences?  yes it's in the prelude
02:45:46 <solrize> HXT is baffling (uses arrows)
02:45:47 <Cale> Oh, hehe, the problem with HaPPs is that it's very much lacking in its documentation.
02:45:49 <smg> ah have you a link or something?
02:46:03 <jre2> Cale: alright, I'll just see if the maintainer is still around
02:46:06 <solrize> http://www.haskell.org/onlinereport/standard-prelude.html
02:46:07 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
02:46:12 <Cale> HXT has lots of documentation, but the library as a whole needs simplification.
02:46:29 <solrize> monad transformers
02:46:40 <Cale> Monad transformers I can help with :)
02:46:45 <solrize> cool :)
02:46:55 <solrize> gadt's
02:46:58 <Cale> (and possibly HXT, if you have specific problems, as I've used that)
02:47:20 <Cale> GADTs are not so hard, though I would recommend having a solid understanding of ordinary types first.
02:47:31 <Cale> If you'd like I can explain them.
02:47:37 <solrize> yeah, the annoying thing about gadt's is being unable to print their values
02:47:46 <araujo> solrize, just code in Haskell , you will get used to the type system
02:47:47 <Cale> Oh, that's not necessarily the case.
02:48:08 <Cale> Whether you can print the values of a type depends on whether it's an instance of the typeclass Show
02:48:11 <smg> solrize: ty
02:48:16 <solrize> also i haven't gotten used to the idea of having to put all my i/o at the outermost level of the program
02:48:28 <Cale> Yeah. If it helps, you can think of model/view/controller.
02:48:34 <solrize> http://www.urbandictionary.com/define.php?term=Haskell   hehe
02:48:34 <lambdabot> Title: Urban Dictionary: Haskell
02:48:56 <Cale> The bits of the view and controller which have real I/O to do should be in the IO monad. The model should usually be entirely pure.
02:50:31 <solrize> yeah, i understand that, it's just in my usual top-down python coding style, i'm way in the weeds when i decide i want to open a network connection to somewhere and get a resource
02:51:55 <solrize> http://www.dmh2000.com/cjpr/cmpframe.html   what would the haskell type signature for this be?
02:52:05 <Cale> Basically, the stuff which is in the IO monad should be the stuff which has legitimate I/O to do. In my experience, I usually write Haskell programs by implementing the main functionality first without any user interface or I/O at all. I test this out in GHCi, and once I'm happy enough with it, I'll usually start writing a user interface to that functionality in IO. It's not necessarily ideal for all programs, but it'
02:52:06 <Cale> s sensible a lot of the time.
02:52:29 <solrize> well if the main functionality IS i/o...
02:52:45 <Cale> Well, yes. Then you end up writing much of the program in the IO monad.
02:53:07 <Cale> But there are often ways to separate the model and make it pure which you don't necessarily expect.
02:53:34 <Cale> Programs which are purely I/O tend to be not all that interesting, as they can't really do anything with the inputs :)
02:53:53 <Cale> (except copy them to outputs :)
02:54:15 <Cale> Which thing do you want the type signature for here?
02:54:19 <solrize> well, i'm doing something now that's basically, crawl a whole bunch of remote computers and get xml files from them, then crunch the xml files and dump the crunched contents into a bunch of disk files
02:54:24 <solrize> cale, the red-black tree
02:54:50 <solrize> i think i shouldn't use Maybe
02:55:21 <solrize> http://hpaste.org/5861
02:56:16 <Cale> You could instead have an Empty case.
02:56:50 <hpaste>  Cale annotated "(no title)" with "(no title)" at http://hpaste.org/5861#a1
02:57:11 <solrize> aha, i was thinking that the leaf nodes had colors and values too
02:57:13 <jre2> solrize: that's mostly IO, but the xml crunching certainly isn't.
02:57:29 <Cale> http://www.polyomino.f2s.com/david/haskell/hs/RedBlackTree.hs.txt -- that seems to be what's done here
02:57:41 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5861#a2
02:58:23 <Cale> You're missing a constructor in your second case there
02:58:31 <Cale> (unless you really wanted it to be Color
02:58:32 <Cale> )
02:58:42 <solrize> oh i see
02:59:25 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5861#a3
03:00:44 <solrize> hmm, there is some way of having types with named fields, iirc
03:00:50 <Cale> yep
03:01:22 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5861#a4
03:01:40 <solrize> oh i see, thanks
03:01:57 <Cale> color, value, left, and right become functions for extracting the corresponding fields
03:02:19 <Cale> (note that applying left or right to a value which is not a Branch will be an error.)
03:02:49 <mikael> I would really like some nicer syntactic sugar for modifying named members of a State variable
03:03:08 <mikael> everything else in haskell is beautiful
03:03:13 <Cale> mikael: Usually you just write up a few things with modify
03:03:39 <solrize> there's this other thing too, which is putting in concrete type annotations to document the function, then having to go and change them to make it generic again
03:04:17 <Cale> solrize: If you want, you can comment out the signature and ask ghci for its inferred type, which should be the most general type the code can have.
03:04:31 <solrize> well that's just like not annotating :)
03:04:49 <Cale> Well, you can then take those inferred signatures and copy them back into the code.
03:04:55 <solrize> yeah i do that sometimes
03:05:02 <solrize> the issue is the annotations make the code harder to maintain
03:05:07 <Cale> Really?
03:05:20 <Cale> In my experience, they make it much, much easier to maintain.
03:05:25 <solrize> yeah, like having to change all the ints to integers etc.
03:05:39 <Heffalump> yeah, I think annotations can be dangerous
03:05:50 <Heffalump> I'd like to be able to make more use of partial annotations
03:05:53 <Cale> Well, you can use (Num a) => constraints.
03:06:03 <Cale> :t 5
03:06:04 <solrize> http://citeseer.ist.psu.edu/leucker01functional.html   this made some of the same observations
03:06:04 <lambdabot> Title: Functional Programming Languages for Verification Tools: A Comparison of ML and  ...
03:06:19 <lambdabot> thread killed
03:06:30 <Cale> Sigh, code.haskell.org has been so flaky lately.
03:06:32 <Cale> :t 5
03:06:32 <lambdabot> forall t. (Num t) => t
03:06:52 <Cale> (that's the machine lambdabot is running on)
03:07:33 <Cale> solrize: Basically, when you make a change to the types in your program, the type annotations help you know where code is that should be reviewed.
03:08:23 <Cale> Generally, just by looking at the output of the typechecker, you can go and find all the places in the code which need to be changed.
03:08:23 <smg> haha defining own operators is fun
03:08:41 <smg> there is infix infixr and infixl is there also postfix and praefix?
03:08:56 <solrize> hmm, that type signature for the red-black tree seems to be wrong, since it looks like either the left or right branch can be missing
03:09:07 <Baughn> smg: Nope
03:09:14 <smg> okay :)
03:09:46 <Cale> For example, a short while ago, I deleted half the source code to hs-plugins, intending to replace it with calls into the GHC API. The type system helped me to find functions in the GHC API which had similar functionality, and told me how they differed in use from the stuff which was in hs-plugins.
03:10:20 <yondalf> smg: haskell doesn't support user-defined unary operators
03:10:32 <smg> okay
03:10:38 <Cale> Despite the fact that I really know nothing about how hs-plugins or the GHC API worked, by the time I was finished fixing type errors, the library worked :)
03:10:41 <smg> not bad, but infix operator are cool :)
03:10:57 <Cale> Well, with ghc you can sort of cheat and use operator sections.
03:11:07 <smg> never saw a language which makes it so easy to define user operators :)
03:11:09 <Cale> > let (n!) = product [1..n] in (5!)
03:11:09 <lambdabot>  Parse error in pattern at "in" (column 27)
03:11:15 <solrize> i guess i should try to undertand this data structure before implmeting it :)
03:11:21 <Cale> hmm :)
03:11:26 <Cale> > let (!) n = product [1..n] in (5!)
03:11:28 <lambdabot>  120
03:11:33 <Cale> there we go :)
03:11:35 <solrize> hehe
03:11:44 <smg> Cale: haha nice
03:12:13 <solrize> > let (!) n = product [1..n] in (!5)
03:12:14 <lambdabot>        add an instance declaration for (Num (t -> t1), Enum (t -> t1))
03:12:14 <lambdabot>     In...
03:12:21 <smg> Cale: this is really hacky
03:12:22 <solrize> > let (!) n = product [1..n] in (! 5)
03:12:22 <lambdabot>        add an instance declaration for (Num (t -> t1), Enum (t -> t1))
03:12:22 <lambdabot>     In...
03:12:32 <Cale> solrize: Red Black trees are often more complicated than other kinds of binary balanced trees, I think. Also, there are rather good implementations of Set and Map datastructures in the libraries.
03:12:37 <solrize> > let (!) n = product [1..n] in (!) 5
03:12:43 <lambdabot>  120
03:13:28 <solrize> cale, yeah, i'm just looking at this comparison page that has python/ruby/c++/java implementations of rb trees and wanted to try a haskell example that is in the same style
03:13:37 <solrize> i.e. it's an exercise, not something to actually use
03:13:44 <Cale> okay :)
03:13:50 <solrize> the article is pretty good
03:15:35 <Cale> You wanted to know about monad transformers?
03:15:43 <solrize> cale, i mentioned monad transformers as an example of a confusing topic that i don't understand.
03:15:43 <smg> Cale: but still awesome :)
03:15:45 <Cale> Okay.
03:16:03 <Cale> smg: :)
03:16:16 <smg> Cale can you do this also with a where clause?
03:17:13 <Cale> smg: Well, where clauses are part of declaration syntax, but yes.
03:17:47 <smg> haha i knew you could do this :)
03:17:56 <smg> i learned about let and where clauses yesterday, i prefer let after your example :)
03:17:56 <Cale> Where and let are equivalent except that where is part of the syntax of function and pattern binding declarations, whereas let is part of the syntax of expressions.
03:17:56 <Cale> 'where' scopes over guards which is often handy
03:17:56 <Cale> For example:
03:17:56 <Cale> f x | a > 0 = ...
03:17:59 <Cale>     | a <= 0 = ...
03:18:03 <Cale>   where a = x^2
03:18:25 <smg> hehe the chapter guards will come next i guess atm i am at eta reduction
03:28:26 <smg> ah yes
03:28:26 <smg> i usually use let in do blocks
03:28:58 <Cale> Yeah, that let is actually a special case :)
03:28:58 <Cale> (the let without in)
03:28:58 <smg> never mix let and where!
03:28:58 <smg> :)
03:28:59 <Cale> Oh?
03:29:03 <smg> they told in the YAHT
03:29:03 <Cale> I'm not sure that's a hard and fast rule :)
03:29:03 <smg> and it makes sense because let shadows where and vice versa
03:29:03 <Cale> You can usually avoid doing it, sure.
03:29:03 <smg> :)
03:29:15 <Cale> Well, you can have conflicting definitions, yes.
03:29:15 <smg> haha i need to read faster, haskell is so interesting
03:29:15 <Cale> solrize: So, if you've done a lot of scheme, you probably know what a combinator library is?
03:29:15 <solrize> i haven't done a lot of scheme, but i have an idea of what a combinator library is
03:29:15 <Cale> Okay. So a monad is a kind of combinator library which has a particular means of combination in its API.
03:29:15 <solrize> ok
03:29:25 <solrize> well, in the io monad, print is not a combinator
03:29:25 <Cale> No, it's a computation.
03:29:25 <Cale> >>= is a combinator though
03:29:26 <solrize> ok
03:29:26 <Cale> as are things like catch
03:29:26 <Cale> :t catch
03:29:26 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
03:29:29 <solrize> um ok
03:29:29 <Cale> You also, for free from the fact that it's a monad, get all the combinators implemented in the Control.Monad library.
03:30:22 <Cale> For example, sequence
03:30:22 <Cale> :t sequence
03:30:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:30:22 <Cale> Which takes a list of actions, and composes them into an action producing a list.
03:30:22 <Cale> Also, forM, which is a kind of for-each loop
03:30:22 <Cale> :t forM
03:30:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
03:30:22 <Cale> It takes a list of elements, and a function from those elements to actions to be performed (a loop body), and produces an action which does them all and gives a list of the results.
03:30:23 <solrize> hmm
03:30:23 <solrize> forM [1..5] print
03:30:23 <Cale> sure :)
03:30:23 <Cale> exactly :)
03:30:23 <solrize> heh
03:30:23 <Cale> Of course, the result of that is a list of empty tuples, one for each iteration.
03:30:23 <Cale> If instead, you want to throw away the results, there's a variant called forM_
03:30:23 <wagle_home>  > forM [1..5] print
03:30:23 <wagle_home> > forM [1..5] print
03:30:23 <Cale> > forM [1..5] print
03:30:23 <lambdabot>  <IO [()]>
03:30:23 <lambdabot>  <IO [()]>
03:30:23 <solrize> > forM_ [1..5] print
03:30:23 <lambdabot>  <IO ()>
03:30:23 <solrize> ok
03:30:23 <wagle_home> > forM [1..5] (:[])
03:30:23 <lambdabot>  [[1,2,3,4,5]]
03:30:24 <Cale> Okay, so if monads are these libraries which happen to have similar APIs, then monad transformers are things which turn libraries into other libraries, usually adding new primitive computations, or possibly even new combinators.
03:30:57 <wagle_home> hmm..  maybe things with concrete types are good for not having to give types all over the place
03:31:06 <Cale> They do this by wrapping up the computations in some appropriate datatype that allows implementation of the new primitives, and then providing a function called lift which turns computations on the original type into computations in the wrapped up one.
03:31:23 <Cale> For example,
03:31:56 <Cale> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
03:32:18 <Cale> compare this with:
03:32:30 <Cale> newtype State s a = State { runState :: s -> (a,s) }
03:32:46 <Cale> (I apologise if you've never seen the state monad before)
03:32:59 <solrize> i've seen it but am not sure what runState is
03:33:26 <Cale> Well, that's just a convenient way to define it.
03:33:50 <Cale> We're representing state computations as functions from an initial state to pairs consisting of a result and a final state
03:34:12 <Cale> This record notation is a quick way to define the function:
03:34:19 <Cale> runState :: State s a -> s -> (a,s)
03:34:43 <Cale> Which takes a state computation, and an initial state, and "runs it" to produce a value and final state.
03:35:22 <Cale> Since it's such a direct implementation of the functionality, all that's involved in running the computation is applying the function.
03:35:54 <Cale> But in use, we don't want to have to know that internally, State computations are implemented as functions.
03:36:01 <solrize> why does State have two parameters?
03:36:13 <Cale> The type of state to be manipulated
03:36:20 <Cale> and the result of the action
03:36:29 <solrize> hmm ok
03:36:35 <solrize> i'm sleepy and not getting this very well
03:36:58 <Cale> That is, you can think of a computation of type (State s a) as being a computation which does some work on a state of type s, before producing a value of type a
03:37:09 <Cale> That is, it might read or write the state.
03:37:13 <solrize> sure
03:37:39 <Cale> > runState (do x <- get; put (x^2); return x) 5
03:37:40 <lambdabot>  (5,25)
03:37:59 <solrize> :t runState
03:38:00 <lambdabot> forall s a. State s a -> s -> (a, s)
03:38:30 <Cale> So that says the result of the action was 5, and the final state was 25
03:38:53 <solrize> :t (do x <- get; put (x^2); return x)
03:38:54 <lambdabot> forall (t :: * -> *) t1. (Num t1, MonadState t1 t) => t t1
03:38:55 <Cale> Indeed, I passed in 5 as the initial state, and x <- get bound x to 5
03:39:06 <Cale> then put (x^2) updated the state with 25
03:39:17 <Cale> and then return x caused the result of the action to be 5
03:39:24 <solrize> forall (t :: * -> *)            doesn't look like a haskell type
03:39:38 <Cale> That's GHC extensions gibberish.
03:39:53 <Cale> (it's a kind signature for the type constructor t)
03:39:59 <Cale> To simplify...
03:40:09 <Cale> :t (do x <- get; put (x^2); return x) :: State Integer Integer
03:40:10 <lambdabot> State Integer Integer
03:40:13 <Cale> :)
03:40:33 <solrize> ic
03:40:35 <Cale> Let's not worry about the generalisation to MonadState for now :)
03:40:46 <Cale> Well, actually this is perhaps a reasonable place to talk about it.
03:40:53 <solrize> how does get find the arg?
03:41:07 <Cale> Okay, let's look at the implementation of these :)
03:41:19 <Cale> get :: State s s
03:41:31 <Cale> So we know that get will look like State (\s -> ...)
03:41:53 <Cale> and there's only one reasonable pair for it to return
03:42:00 <Cale> get = State (\s -> (s,s))
03:42:02 <solrize> :t get
03:42:02 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
03:42:09 <Cale> That's the generalised version :)
03:42:18 <solrize> :)
03:42:48 <Cale> What StateT does is to wrap up a monad in such a way as to make the result an instance of MonadState
03:43:07 <Cale> and so get and put will work in any StateT'd monad.
03:43:17 <solrize> State is a monad, like IO?  i.e. a functor that lifts the whole base type system?
03:43:23 <Cale> yep
03:43:38 <Cale> Well, strictly speaking, it's State s which is the monad, for any type s
03:43:54 <solrize> wow
03:43:56 <solrize> hmm
03:44:30 <Cale> Let's look at the definition again:
03:44:44 <Cale> newtype State s a = State { runState :: s -> (a,s) }
03:44:48 <Cale> this is equivalent to:
03:44:53 <Cale> newtype State s a = State (s -> (a,s))
03:45:08 <solrize> s and a are arbitrary types
03:45:11 <Cale> but it additionally defines the function runState, which we could also write as:
03:45:26 <Cale> runState (State f) s = f s
03:45:30 <Cale> or even just:
03:45:36 <Cale> runState (State f) = f
03:45:44 <Cale> Yes, s and a are type variables there.
03:45:48 <fnord`> Hi all
03:45:54 <Cale> Hello :)
03:46:06 <solrize> hi `
03:46:25 <fnord`> Has anyone got a short, snappy description of the List Monad for people who may not be familar with Haskell?
03:46:38 <Cale> fnord`: Sure. Let's do it :)
03:46:54 <Cale> (it's roughly on topic with the rest of discussion here :)
03:47:07 <smg> so lets look if i understood uncurry
03:47:08 <solrize> http://lukeplant.me.uk/blog.php?id=1107301643
03:47:08 <lambdabot> Title: Understanding Monads Via Python List Comprehensions
03:47:19 <fnord`> I'm writing a report on a Haskell program where I've used the List Monad quite a lot and I'm assuming it's going to confuse my readers no end :p
03:47:31 <smg> > map (uncurry(*)) [ (1,2), (3,4), (5,6) ]
03:47:35 <lambdabot>  [2,12,30]
03:47:37 <Cale> Oh, okay, then maybe solrize's link will work better. :)
03:47:41 <Cale> But essentially,
03:47:55 <Cale> xs >>= f = concat (map f xs)
03:47:56 <Cale> and
03:47:58 <Cale> return x = [x]
03:48:08 <smg> > flip compare [1..10]
03:48:10 <lambdabot>  <[Integer] -> Ordering>
03:48:15 <Cale> are the most important things to know to begin with
03:48:18 <fnord`> solrize: that looks good, I'll include that link but the readers here are probably only going to be familar with Java :(
03:48:26 <solrize> hmm
03:48:59 <fnord`> I know, I know, I may be fighting a losing battle here, but I'm at least trying :p
03:49:01 <Cale> fnord`: It's really hard to get across the general idea of monads to Java programmers, but you could in fact avoid that word and just explain the operations which you used, which are normal list functions.
03:49:29 <fnord`> Thing is, I'm using do notation quite a lot
03:49:37 <solrize> i never understood java but i saw some paper saying that monads were what javanistas call "aspect oriented programming"
03:50:10 <Cale> fnord`: I suppose you could just explain that  x <- xs  means "pick an element x from xs in all possible ways"
03:50:19 <quicksilver> aspect oriented programming is, actually, fictional.
03:50:38 <quicksilver> to the extent it means anything it's just talking about a kind of sensible separation of concerns.
03:50:42 <Cale> fnord`: If you want to explain how it works, just describe the translation of do notation into bind, and explain how bind works.
03:50:52 <Cale> (for just this one monad)
03:50:52 <quicksilver> i.e. good design principles
03:51:06 <Cale> (that is, if the first description is unsatisfying)
03:51:35 <Cale> quicksilver: Uh, doesn't it refer to programming languages like AspectJ, etc.?
03:51:42 <smg> > List.sortBy (flip compare)  [1,6,3,0,9]
03:51:53 <lambdabot>   Not in scope: `List.sortBy'
03:52:04 <smg> > +m List; List.sortBy (flip compare)  [1,6,3,0,9]
03:52:05 <lambdabot>  Parse error at ";" (column 8)
03:52:12 <Cale> quicksilver: Or rather, some ephemeral combination of their features...
03:52:57 <doserj> > sortBy (flip compare)  [1,6,3,0,9]
03:52:58 <lambdabot>  [9,6,3,1,0]
03:53:00 <quicksilver> Cale: maybe. I mostly see it used to refer to the fictional notion that you can re-engineer software at a later date without editing its internals "because it's just an aspect" :P
03:53:08 <fnord`> Cale: I'll give it a try, I'm thinking of maybe starting with list comprehensions and then translating those to do notation (the only reason I'm not use comprehensions in the code is that they'd end up as huge 10 line monstrosities)
03:53:21 <quicksilver> Cale: but yes, the aspectj stuff is at least something concrete.
03:53:36 <smg> doserj: -.-
03:53:54 <ari> :t Data.List.sortBy
03:53:55 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:54:00 <ari> :t List.sortBy
03:54:02 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:54:10 * ari shrugs
03:54:57 <Cale> fnord`: If they understand list comprehensions, you can just explain that the do-syntax is a flipped over version of that.
03:55:19 <Cale> solrize: So, would you like to look more at the implementation of the State monad?
03:55:29 <solrize> sec
03:56:04 <solrize> i think i'm too burnt out right now, maybe another time if you're up for it?
03:56:09 <Cale> Sure.
03:56:31 <solrize> i'd kind of like to know how to implement the rc4 stream cipher, which probably needs ArrayT and State
03:57:59 <Cale> Haskell has a pretty decent system of arrays. You can actually probably get away with non-monadic code for that, but the State monad may be useful.
03:58:27 <Cale> If you want mutable arrays, you'll be working in either the IO or ST monad.
03:58:45 <solrize> ST is different from State?  hmm
03:58:49 <Cale> Yeah.
03:58:56 <solrize> yeah, rc4 basically needs mutable arrays
03:58:59 <Cale> In that you can have arbitrary numbers of STRefs
03:59:11 <solrize> you could do it with something like data.map but that would miss the point
03:59:11 <Cale> Which are like mutable cells.
03:59:31 <Cale> I wonder how well DiffArrays would work :)
03:59:58 <Cale> DiffArrays are arrays with an immutable interface which cheats using mutation behind the scenes
04:00:15 <solrize> ugh, rc4 really wants brutally simple machine code that's a mutating array
04:00:28 <Cale> Yeah, you might be best served by ST then.
04:00:39 <solrize> http://en.wikipedia.org/wiki/RC4#The_pseudo-random_generation_algorithm_.28PRGA.29
04:00:40 <lambdabot> http://tinyurl.com/cby4v
04:00:45 <solrize> brb
04:00:53 <Cale> What ST does is to let you have imperative code that has no *real* side effects, and turn that into a pure function at the end.
04:01:38 <Philippa> to put it another way: ST ~= State with an entire heap as the state
04:01:45 <Philippa> plus a bit of extra locking to make sure you don't mix up references from different heaps
04:02:47 <solrize> yeah, ST sounds like what i'd want for that
04:06:09 <solrize> it woudl be cool if there was something like harpy but with typed assembly code
04:06:41 <Philippa> build it? :-)
04:07:05 <solrize> :)
04:08:32 <mikael> build on harpy until we have C as an embedded language :)
04:08:34 <solrize> ugh!!!!
04:08:59 <solrize> http://www.cs.cornell.edu/talc/
04:09:00 <lambdabot> Title: Typed Assembly Language
04:09:13 <Cale> Man, these Project Euler nutcases are starting to really annoy me.
04:09:32 <solrize> what's that?
04:09:54 <Adamant> Proof Carrying Code FTW
04:09:55 <Cale> solrize: Project Euler?
04:09:55 <solrize> yeah
04:09:55 <vincenz> Cale: why
04:10:04 <Cale> It's a bunch of simple mathematical problems whose solution involves doing at least some brute force computation.
04:10:10 <Cale> (typically)
04:10:45 <Cale> They really don't like how we have solutions to all the problems on the Haskell Wiki.
04:12:02 <Cale> But there really isn't anything they can rightly do about it, so they're just being really annoying.
04:12:02 <Adamant> why would they care?
04:12:02 <Cale> I have no idea.
04:13:39 <Cale> I have no personal stake in this, but I don't like seeing people damage content on the Haskell Wiki.
04:25:43 <Cale> They started off by deleting all the solutions from the wiki, a couple of weeks ago. I reverted those changes immediately.
04:44:13 <solrize> oh i see
04:45:23 <solrize> these problems are kind of cute
04:45:24 <nanothief> Cale: you can get ranked on Project Euler, so that having the solutions there would let people cheat very easily
04:45:24 <Cale> nanothief: Yes, but if the site is intended as a contest, then it's a very poorly designed one.
04:45:24 <mikael> information is free, man, you can't stop it
04:45:27 <nanothief> I can understand why they don't want them there, but they really should ask permission before wiping a lot of stuff
04:45:27 <Cale> nanothief: If you want to run a contest where people can't look up the solutions, you can't just let it run forever.
04:45:27 <mikael> I thought everyone except record company execs realized this
04:45:37 <Cale> If they want to rank people, they should produce lists of problems, and put a time limit on solving them.
04:45:37 <nanothief> but why have the solutions on haskell wiki anyway? There are many other problems that could be there
04:45:37 <Cale> (Something reasonably short, where it's unlikely the solution will be published widely before the deadline.)
04:45:37 <Cale> Because they're good examples of Haskell code, for one.
04:45:37 <nanothief> I doubt they have the resources to do that
04:45:41 <nanothief> there's a lot of other good examples of Haskell code :)
04:45:42 <Cale> The only person one could reasonably cheat by looking at the solutions is oneself.
04:45:43 <Cale> There's no prize for having all the solutions solved on the PE site.
04:45:43 <nanothief> and other users who work to get a good ranking
04:45:43 <Cale> Why?
04:45:43 <nanothief> the prize is satisfaction
04:45:43 <Cale> How does it hurt them?
04:45:43 <Cale> They have their satisfaction of knowing that they solved all the problems.
04:45:43 <vincenz> nanothief: that's like saying a game is not enjoyable cause people sell cheat-lists
04:45:43 <nanothief> well if people can just solve all the answers by getting the results from haskell, then solving them all now has no prestige
04:45:43 <atsampson> I think it's valuable to have the solutions on the Haskell wiki -- they're good examples of stuff Haskell's good at
04:45:43 <Cale> But it should not have had prestige anyway. The problems are easy and have no time limit.
04:45:43 <nanothief> vincenz: remember diablo 1? It sucked at multiplayer because everyone could hack their characters
04:45:43 <nanothief> its the same thing here
04:45:45 <Philippa> and you can't prove people weren't passing around solutions behind the scenes anyway
04:45:45 <Cale> nanothief: Play with more reasonable players then.
04:45:45 <vincenz> nanothief: no it's not, cause it's not a competition
04:45:45 <Philippa> nanothief: it sucked because you couldn't reliably choose not to play with hackers
04:45:45 <Cale> nanothief: I played a lot of Diablo 1 with non-cheaters.
04:45:45 <Philippa> but you don't play PE /with/ people
04:45:45 <Cale> Yes you could.
04:45:45 <Cale> I played with my friends, and none of them overtly cheated in a way which spoiled the game for me.
04:45:45 <mikael> blizzard didn't solve that by eradicating all cheats from the internet, they made a sequel with a reasonable client/server model :)
04:45:45 <Cale> (I can't actually say if they did, but if they did, I didn't notice)
04:45:45 <nanothief> Cale: you can't play with randoms though, like wow and other games
04:45:45 <vincenz> nanothief: PE is not like that
04:45:45 <Cale> Sure, and that's a flaw in the game design.
04:45:45 <vincenz> nanothief: your analogy is flawed
04:45:45 <Cale> PE has a similar flaw.
04:45:45 <Cale> The flaw is that they publish problems with known solutions over the long term and expect that nobody will publish those solutions.
04:45:45 <Cale> This is outright stupid.
04:45:45 <nanothief> yeah, they expect people to be nice about it, and not do it
04:45:45 <Cale> You simply can't expect that nobody's going to publish the solutions.
04:45:45 <vincenz> PE is not a competition
04:45:45 <vincenz> so you ca't' say "not fun to play against cheaters"
04:45:45 <Cale> It's not a matter of being nice.
04:45:45 <Cale> It's a matter of the solutions being useful and educational information.
04:45:45 <Cale> Hence, people will publish it because it is useful.
04:45:45 <nanothief> one part of the satisfaction of solving problems there is seeing your ranking jump
04:45:46 <Cale> And you can take that satisfaction, knowing that you got that jump legitimately.
04:45:46 <Cale> If you live your life for progress bars, then you really need to do some introspection.
04:45:47 <nanothief> but with potential cheaters, it could become hard to make jumps to the top 100 (or 1000) of the list, if many people cheat with it
04:45:47 <Cale> So what?
04:45:47 <Cale> So you're comparing yourself with a bunch of cheaters, rather than taking the much more legitimate satisfaction in solving the problems and learning something.
04:45:47 <nanothief> you're probably not a very competitive person, but there is satisfaction from climbing up a ranking list
04:45:47 <Cale> The design of PE is fundamentally flawed for making comparisons of people's knowledge.
04:45:47 <Cale> If you want that, there are plenty of mathematics and programming competitions you can take part in.
04:45:48 <fnord`> Would a possible solution be to maybe keep the code on the wiki but remove the words "Project Euler". Then it's not easily findable by google which I imagine would make the PE people a lot happier
04:45:48 <nanothief> with your arguments, it would be ok for people to take drugs to run the 100m, as the legit runners can just get the satisfaction of beating their personal best
04:45:48 <Cale> nanothief: I have nothing against well-run competitions.
04:45:48 <Philippa> *cough*drug testing*cough*
04:45:48 <nanothief> actually another solution would be to slightly change the problems on haskell, so they won't work straight away on PE
04:45:48 <Cale> nanothief: But if you're going to run something as a competition, don't be stupid about it. Run it in such a way that people can't reasonably cheat.
04:45:48 <Philippa> fnord`: not really, all it takes is one link on somewhere that you can find by googling PE (not the acronym, we all know what we'll get for that, right?)
04:45:48 <Cale> nanothief: That would be caught and treated as vandalism.
04:45:48 <jre2> anyone know the status of HaRP? Or regex pattern matching being added to ghc in general?
04:45:48 <Philippa> Cale: I think it's fair to do so long as you attach a matching corrected problem statement though
04:45:48 <RayNbow> @faq Is Haskell good for PE class? :p
04:45:48 <lambdabot> The answer is: Yes! Haskell can do that.
04:45:48 <fnord`> Philippa: you're probably right
04:45:48 <nanothief> Cale: why would it be vandalism? the haskell community would still gain the same benefits as you described earlier
04:45:48 <Cale> Philippa: possibly. But there are copyright concerns in doing that.
04:45:48 <Philippa> I suspect the PE guys'd be happy to license in exchange
04:45:50 <Philippa> nanothief: it's vandalism without corrected problem statements
04:45:50 <nanothief> yeah true, I meant that the problem statements would be changed as well
04:45:51 <fnord`> Sounds like a good idea, wouldn't hurt anyone except people who actually wanted to use it to cheat (why? god knows, but people are weired like that)
04:45:51 <Cale> But beyond that issue, I don't think it's right for the PE people to expect and demand that solutions not be published.
04:45:52 <Cale> If they wanted to run a legitimate contest, they could run something like the ICFP.
04:45:54 <solrize> :t foldl1' max
04:45:54 <fnord`> Not demand, no, but they're within their rights to ask politely :p
04:45:54 <lambdabot> forall a. (Ord a) => [a] -> a
04:45:54 <Cale> fnord`: They've been asking rather impolitely.
04:45:54 <solrize> > let mmax = foldl1' max
04:45:54 <lambdabot>  Parse error at end of input
04:45:54 <nanothief> they crossed a line when they deleted the code from the wiki without permission, but I think it should still be removed/changed just to act in good faith
04:45:54 <fnord`> Cale: Sounds like it, that's not really on
04:45:54 <solrize> > let mmax = foldl1' max in (:t mmax)
04:45:54 <lambdabot>  Couldn't match expected type `([a] -> a) -> [a1]'
04:45:54 <Cale> nanothief: I disagree. The content is useful, legitimate, and does no real damage to Project Euler's existence.
04:45:54 <fnord`> Cale: Remember though that "they" is a rather imprecise thing, I'm sure there are lots of people involved in pe, not all of whome are engaging in wiki vanadlism
04:45:54 <desegnis> @where happs
04:45:54 <lambdabot> http://happs.org
04:45:54 <desegnis> happs.org seems to be down?
04:45:54 <Cale> fnord`: There are people involved who are apparently running PE.
04:45:54 <solrize> Prelude Data.List> let mmax = foldl' max
04:45:54 <solrize> Prelude Data.List> :t mmax
04:45:54 <solrize> mmax :: () -> [()] -> ()
04:45:54 <solrize> ???
04:45:54 <nanothief> Cale: the content is useful and legitamate even if changed slightly, and it does damage to Project Euler by alling haskell users to easily cheat with it
04:45:55 <Cale> solrize: You're being bitten by the monomorphism restriction.
04:45:55 <solrize> uhhh
04:45:55 <Cale> solrize: You can turn it off with :set -XNoMonomorphismRestriction
04:45:55 <solrize> can i use some annotation instead?
04:45:55 <Cale> Or yeah, annotate the function with a type signature.
04:45:55 <Cale> Or simply include another parameter to make it into a function binding.
04:45:55 <andun> nanothief: i would think that either you change it so it would differ too much for being useful, or if you don't do that it will be really easy to change it back and cheat anyway
04:45:55 <Cale> (pattern bindings have this stupid restriction)
04:45:55 <solrize> i just want to find the maximum of a list
04:45:55 <solrize> mmax [2,4,9,3] = 9
04:45:55 <desegnis> @type let mmax a xs = foldl' max a xs in mmax
04:45:55 <lambdabot> forall a. (Ord a) => a -> [a] -> a
04:45:55 <RayNbow> @src maximum
04:45:55 <lambdabot> maximum [] = undefined
04:45:55 <lambdabot> maximum xs = foldl1 max xs
04:45:55 <fnord`> Cale: I might be wrong here, but these things usually involve a number of people, some of whome are often dicks and some of whome a nice and friendly. It's like taring the whole Haskell comunity just because someone who likes Haskell is an idiot on Reddit (not saying that happens often, don't remember the last time it did, but you get the idea)
04:45:56 <Cale> nanothief: Another thing PE could do is to require solutions which were more general than simply numbers which could be computed once and reused for everyone.
04:45:56 <solrize> oh, maximum, built in
04:45:56 <Cale> fnord`: Well, yes.
04:45:56 <fnord`> oh dear, I'm getting into essay length messages, I'll shut up now :p
04:45:56 <nanothief> andun: it would help stop google queries, as a search like "Calculating the digital sum of the decimal digits of irrational square roots." gives the first hit as the haskell wiki
04:45:56 <Cale> fnord`: I have nothing against PE itself, but it either has to stop viewing itself as a contest, stop worrying about cheaters, or run itself more in lines with how a proper contest is run.
04:45:56 <Cale> nanothief: and why shouldn't it?
04:45:56 <fnord`> Cale: you may be right
04:45:56 <Cale> nanothief: There's a legitimate solution to that problem on the Haskell wiki.
04:45:56 <nanothief> it is a legitamate as the quetion "Calculating the digital product of the digits of square roots that are irrational".
04:45:57 <nanothief> but if it was changed to that, it would be more difficult to search for the answer using google
04:45:57 <Cale> nanothief: There's a point at which this becomes a matter of principle.
04:45:57 <Philippa> Cale: I think there the principle should be "they can make those minor tweaks themselves", mind
04:45:57 <Cale> nanothief: If anyone publishes a list of problems, anyone else should be in their right to publish a list of the solutions.
04:45:57 <nanothief> but what (legitamate) purpose does publishing a list of solutions give?
04:45:58 <Cale> In fact, I think I'll probably copy all the solutions to my own wiki, and protect all the pages from edits.
04:45:58 <Philippa> discussion of technique, for one
04:45:58 <nanothief> a list of solutions to different problems would be just as useful
04:45:58 <Philippa> so go write one
04:45:58 <solrize> errr, think of posting solutions to all the exercises in a calculus textbook...
04:45:58 <Cale> nanothief: For people working on the problems on PE who can't get the solution, they can look it up and learn from it.
04:45:58 <Philippa> you talk as if we should have to further justify the decision just because it's PE
04:45:58 <nanothief> well, I can change the solutions in the haskell wiki, but I don't think Cale would be happy with that
04:45:58 <nanothief> Cale: that isn't a legit reason
04:45:59 <litb> hello all!
04:45:59 <Cale> nanothief: How is learning illegitimate?
04:45:59 <Philippa> yes it is. You have absolutely no right, once someone isn't participating in PE per se, to label it illegitimate
04:45:59 <Cale> litb: hello!
04:46:03 <Philippa> PE only gets any say whatsoever in what's legitimate for purposes of competition and 'doing it how we say'
04:46:03 <Philippa> it's entirely legitimate for anyone to do an end-run around the latter
04:46:03 <Cale> PE can *suggest* that people not look up or publish solutions to their problems.
04:46:03 <Cale> They can't *require* it.
04:46:03 <Philippa> it isn't even acting in bad faith, it's only acting in bad faith to use it for competition purposes
04:46:03 <Cale> People who live in the free world have certain rights.
04:46:03 <nanothief> learning isn't illegitamate, but working with the difficult solutions, it would be unfair to people who didn't use a solution
04:46:03 <Philippa> they had a choice
04:46:03 <Philippa> they chose the hard route
04:46:03 <Philippa> that isn't unfair
04:46:03 <Philippa> there's no coercion, no duress
04:46:03 <solrize> i still want to know how a calculus textbook publisher is likely to react if someone posts answers to all the exercises, since they are assigned as homework problems all the time
04:46:03 <mikael> homework problems are obsolete, everyone knows that
04:46:03 <Philippa> solrize: the publisher can't do a damn thing about it
04:46:03 <solrize> hmm
04:46:03 <mikael> the very project euler FAQ addresses this very question, by the way:
04:46:03 <nanothief> but just because they can't do anything about it, doesn't mean it should be done
04:46:03 <mikael> I solved it by using a search engine, does that matter?
04:46:03 <mikael> That depends on your motivation for solving the problems. It probably means that you've missed out on some beautiful and hidden mathematics.
04:46:03 <Cale> Indeed.
04:46:03 <Philippa> nanothief: nor does it mean that you're in a position to tell others what /should/ be though
04:46:03 <Cale> nanothief: Solutions manuals are legitimate tools for people doing self-study.
04:46:03 <nanothief> Cale: very true that
04:46:03 <Philippa> and frankly, you need stronger arguments than you've given to show that someone shouldn't do something
04:46:03 <Cale> nanothief: Also, you might notice that a large portion of the final mark in any university level course comes from exams and other mechanisms where plagiarism isn't so easy.
04:46:03 <Philippa> you've not demonstrated any harm other than "the competition's broken"
04:46:03 <nanothief> Philippa: I know, that is the only harm being done
04:46:03 <smg> hehe eta reduction is really cool
04:46:03 <Cale> nanothief: Also, plagiarism is explicitly forbidden on assignments, and it usually comes with pretty severe consequences.
04:46:03 <Philippa> nanothief: which means you need to show that that's a greater harm than removing a learning tool to have even the start of a case
04:46:04 <Cale> The problem with PE is that it's designed in such a way that it can't detect plagiarism.
04:46:04 <nanothief> Philippa: the learning benefit would be equally conserved by changing the problems slightly
04:46:04 <Cale> If the problems contained more universal quantifiers and the solutions were proofs or programs outright, it would be easier to check.
04:46:04 <nanothief> so there is no loss to the haskell community, but a benefit to the PE community
04:46:04 <Philippa> nanothief: so do the work yourselves
04:46:04 <Cale> nanothief: But it would be of less benefit to people already working on PE problems.
04:46:04 <nanothief> I think the benefit to the PE community of solutions not being available exceed the benefits of a few who would want to use the solutions to "help" them a bit
04:46:04 <Philippa> who are, incidentally, part of the PE community
04:46:12 <Philippa> you think that, others may differ
04:46:29 <Cale> nanothief: I fundamentally disagree with that.
04:46:31 <solrize> do these answers actually show code with good algorithms, or just the numerical answers?
04:46:34 <Philippa> your use of "help" demonstrates a certain bias, too
04:46:36 <nanothief> I think the whole problem is we have different moral guidelines, and we're never going to agree on this
04:47:21 * Philippa can't find quickly find anything on the PE site asking that this not be done, btw
04:47:24 <nanothief> so I would be happy to change the problems, but only if everyone agrees
04:47:29 <Cale> My value system is such that the opportunity of those people to learn something is far more value than the prestige which comes from having a number beside one's name.
04:47:30 <solrize> the day after harry potter 7 was published, i read the wikipedia article about it that said how it came out, and that saved me from having to read the thing
04:47:40 <Cale> nanothief: I don't agree.
04:47:46 <jeffz> I don't see what the big deal is, some people will cheat and some will work things out on their own.
04:47:52 <Cale> nanothief: You might want to modify the problems and make a new set of pages though.
04:47:53 <nanothief> well I'm not going to change it them :)
04:48:04 <nanothief> Cale: that defeats the purpose though
04:48:06 <nanothief> well my purpose
04:48:12 <jeffz> find a new purpose.
04:48:16 <Cale> nanothief: I think your purpose is ill founded then :)
04:48:35 <nanothief> as I said, you think it is moral to have the solutions there, I don't
04:48:48 <Cale> This really comes down to a value judgement.
04:49:21 <nanothief> damn ethical dielemmas!
04:49:46 <Cale> Is the value of those solutions to people studying the PE problems and trying to learn how to solve them greater than the value of the prestige some people have by being highly ranked on the PE site.
04:49:57 <Cale> s/./?/
04:50:29 <mikael> PE is made *better* by having good solutions available
04:50:57 <Cale> Given that PE's system of ranking is fundamentally broken in this way, the prestige is not very valuable anyway.
04:51:01 <nanothief> Cale: also the sense of achievement of moving up the ranks, but the rest I agree with
04:51:08 <Cale> If you want prestige, attend a good university.
04:51:23 <nanothief> note that the haskell solution is the only solution on the internet about this
04:51:29 <nanothief> http://www.google.com.au/search?q=%22Calculating+the+digital+sum+of+the+decimal+digits+of+irrational+square+roots.%22&sourceid=navclient-ff&ie=UTF-8&rlz=1B3GGGL_enAU230AU230
04:51:30 <lambdabot> Title: "Calculating the digital sum of the decimal digits of irrational square roots."  ..., http://tinyurl.com/yqs9u9
04:51:44 <Cale> Yes, but that probably has something to do with the annoying tactics of the people who run the site.
04:52:08 <Cale> and I don't think it's right.
04:52:35 <mikael> "Project Euler exists to encourage, challenge, and develop the skills and enjoyment of anyone with an interest in the fascinating world of mathematics."
04:52:52 <Cale> Note that I otherwise have no stake in this. I didn't contribute significantly to those solutions, nor have I spent much time at all working on PE problems.
04:52:54 <nanothief> there's only 27 people on the website who have solved them all, so its highly possible that haskell is the only site that has ever published all the solutions
04:53:23 <Cale> nanothief: They're pretty easy problems though.
04:54:13 <solrize> hmm doing problem 5 the obvious way is going pretty slow
04:54:59 <nanothief> Cale: some seem very hard to me (although I doubt I am anywhere near as good a coder as 90% on this channel are)
04:55:13 <nanothief> this is the hardest question on the site: http://projecteuler.net/index.php?section=problems&id=177
04:55:14 <lambdabot> Title: Problem 177 - Project Euler
04:55:23 <nanothief> I have no idea where to start with that :P
04:56:48 <mikael> don't you think the top 1000 is basically an afterthought?  a slightly amusing gimmick?  it seems very petty to mess with someone's attempt to provide helpful educational code just because it could mess up your high score on a site that is explicitly all ABOUT education and self-improvement
04:57:09 <solrize> let's see, cad + adc  + dca = 180, similarly with acb+cba+bac
04:57:24 <mikael> sorry, I don't mean to accuse you of messing with anything, nanothief
04:57:49 <nanothief> mikael: i didn't take it that way :)
04:58:07 <solrize> and with adx+dxa+xad and so forth, where x is the intersection of diagonals
04:58:24 <solrize> so you want to find all the integer solutions of a bunch of simultaneous equations
04:59:46 <nanothief> well with that question, I would gain a great sense of accumplishment if I solved it as only 60 people (of over 17803 who have used the site) have solved it
05:00:52 <nanothief> thats the benefit I gain from the solutions not being easily obtainable, as if people started to cheat with them, I wouldn't get the same sense of accomplishment
05:01:07 <solrize> don't you get even more sense of accomplishment, if you think that 55 of the 60 are cheating?
05:02:12 <nanothief> well I have no idea how many are cheating.
05:02:40 <nanothief> if 55 were cheating, I would get an even greater sense of accomplishment if it said on the page that only 5 people had managed to solve it
05:03:18 <nanothief> but if people were using haskell to solve the problems, then the solution could would probably be higher than 60
05:05:02 <Philippa> nanothief: given that the PE site *doesn't ask people not to post solutions*, I'm now at the point of being ready to just say get lost tbh
05:05:02 <Philippa> I repeat, I've got as far as being able to view problems on it without once having been asked to not post solutions anywhere
05:05:22 <Cale> There are only around 7647059 quadrilaterals to check for validity. A brute force approach is very much in reach.
05:05:30 <Philippa> as such, this is just a request from a bunch of people who happen to use the site
05:07:41 <nanothief> fair enough, this conversation has gone on for too long
05:07:50 <chot> hey
05:07:50 <Cale> hello
05:07:50 <EvilTerran> sup
05:07:56 <chot> we need some advice on how to implement a conditional newtype
05:09:03 <Cale> What would that be? (I know what a newtype is)
05:11:28 <chot> newtype Something a = S {unS :: Show a => (a -> a) }
05:14:01 <chot> something like that
05:23:24 <chot> though that doesn't compile
06:00:59 <EvilTerran> ah... i believe you can't have class constraints on a newtype
06:00:59 <Cale> Oh, you can't do that without very new extensions.
06:00:59 <chot>  oh crap
06:00:59 <Cale> and you'll have to use GADT syntax with data.
06:01:00 <Cale> There's an easy alternative though.
06:01:00 <EvilTerran> data Show a => Something a = S { unS :: a -> a } -- one option that doesn't require modern extensions, but probably won't do what you wanyt
06:01:00 <Cale> newtype Something a = S { unS :: (a -> a, a -> String) }
06:01:00 <EvilTerran> data Something :: * -> * where S :: Show a => (a -> a) -> Something a
06:01:00 <EvilTerran> is the GADT version
06:11:37 <chot> hm, the first version you wrote EvilTerran seemed nice
06:11:46 <Cale> chot: But it doesn't mean what you likely want it to mean.
06:11:46 <chot> ok, in what way?
06:11:46 <Cale> chot: It restricts the application of the constructor S, without providing any other benefit.
06:11:51 <Cale> In particular, the type system won't infer an instance for Show a for things pattern matched out of an S.
06:12:00 <chot> ah ok, so won't force a to be showable?
06:12:00 <chot> okok
06:12:05 <Saizan> but since "a" is not quantified you can just float the Show contraint out
06:12:05 <Cale> It is quite likely the single dumbest feature in Haskell 98 :)
06:12:05 <chot> hehe
06:12:05 <chot> is there a GADT version using newtype?
06:12:08 <Cale> No, because the thing you want isn't actually isomorphic to the type a -> a
06:12:15 <Cale> In particular, it carries along with it a dictionary for the typeclass Show.
06:12:15 <Saizan> unless your intent was only to restrict a
06:12:26 <chot> hm ok
06:12:29 <Cale> chot: So generally, the solution is just to restrict the types of the functions which are taking values of type Something
06:12:29 <chot> you mean like DoThing :: Show a => Something a -> ...
06:12:33 <chot> yeah seems clever
06:12:33 <dcoutts> sioraiocht: ping
06:12:33 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:12:33 <chot> thanx for the help guys, cleared up a lot of our confusion :)
06:12:33 <dcoutts> @seen gwern
06:12:33 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 7h 52s ago.
06:12:36 <dcoutts> @tell gwern an executable can see the same source files as the library if they use the same hs-src-dirs, there's nothing magic, each lib and exe has its own build info.
06:12:36 <lambdabot> Consider it noted.
06:12:41 <dcoutts> @tell sioraiocht I'll be back later in the afternoon
06:12:41 <lambdabot> Consider it noted.
06:12:43 <Lemmih> @ask JohnMeacham Is it safe to hack on the occurance analyser or should I wait until you have finished the rules rewrite?
06:12:43 <lambdabot> Consider it noted.
06:12:48 <_frederik_> does ghc-pkg.bin get stuck in infinite loops?
06:12:48 <_frederik_> 14691 frederik  35  10  7216 4960 1052 R 98.4  1.0   1:01.90 ghc-pkg.bin
06:12:48 <_frederik_> that's over 1 minute
06:12:49 <resiak> maybeRead is not in any widely-installed module, is it?
06:12:52 <solrize> i want to say "let x = sum [1..1000000] in f x" and have f return how many seconds it takes to evaluate x.  is there a reasonable way to do that?
06:12:52 <Heffalump> use unsafePerformIO, seq and the IO timer routines.
06:12:52 <resiak> well, you colud make f be in IO and not use unsafePerformIO
06:12:52 <solrize> yeah i expected f to be in IO
06:12:52 <solrize> seq, hmm
06:12:53 <resiak> you also might want to use deepSeq to force more to be evaluated than seq would
06:12:53 <solrize> i hadn't heard of thata.  if it's computing a scalar....
06:12:53 <Heffalump> resiak: it's an int!
06:12:53 <Heffalump> well, some number.
06:12:53 <resiak> Heffalump: sure, in this case, but maybe solrize wants f to be more generic?
06:12:53 <Heffalump> true.
06:12:53 <smg> ehllo
06:12:53 <smg> http://rafb.net/p/H7NexO88.html
06:12:53 <lambdabot> Title: Nopaste - stdin
06:12:53 <smg> can someone look at that paste and tell me if the two things are equivalent?
06:12:57 <twanvl> smg: Yes, they are equivalent (aside from the typo, instance EQ should be instance Eq)
06:12:57 <yondalf> smg: deriving Eq also adds the line Custom a b c == Custom d e f = (a==b) && (c==d) && (e==f)
06:12:57 <yondalf> i think
06:12:57 <smg> hehe
06:12:57 <smg> so it's better to use deriving (Eq, Show)
06:12:57 <smg> so i don't need to implement that stuff everytime on my own?
06:12:57 <yondalf> yes, of course
06:12:57 <yondalf> well...i haven't been burned by any weird functionality though
06:12:57 <smg> hehe okay cool
06:12:57 <smg> i got shocked when i red that stuff in the yaht :)
06:12:57 <smg> so deriving is my friend, cool :]
06:12:57 <yondalf> unfortunately you can't derive much though...ghc might have an extension that lets you make "derivations" for other typeclasses but i'm not sure about that
06:12:57 <Cale> Not really, no.
06:12:57 <Cale> It's just a handful of the Prelude classes.
06:12:57 <smg> mh for now for me Eq Show Ord and Enum will be enough :]
06:12:57 <Deewiant> GHC has deriving Data and Typeable
06:12:57 <yondalf> oh...there's no ghc extension that lets you make derivations for other typeclasses :-(
06:13:10 <Deewiant> newtype deriving appears to be something like that, though I've never used it: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html
06:13:10 <lambdabot> Title: 8.5. Extensions to the "deriving" mechanism, http://tinyurl.com/2ts9ot
06:13:10 <Cale> Newtype deriving only lets you derive classes on newtypes which are supported on the original type.
06:13:10 <Cale> This is possible because the two types are really the same.
06:13:10 <Cale> (at the implementation level)
06:13:10 <chot> one more question; can we make a type contraint on a bind (>>=)? tried instance Show a => Monad (Something) where .. but didn't work
06:13:10 <Heffalump> no, you can't
06:13:10 <Heffalump> look up "restricted monads" for ways to hack around this
06:13:10 <Heffalump> but none of them are particularly pleasant
06:13:10 <chot> hm ok
06:13:10 <nayru> can i download 2d-games written in haskell somewhere? are there any good ones?
06:15:33 <solrize> > return 3
06:15:40 <lambdabot>   add an instance declaration for (Show (m t))
06:15:54 <solrize> in ghci it just prints 3
06:16:13 <opqdonut> yeah, it's taken as a IO action
06:18:01 <Halabund> Mathematica (which allows for functional programming) is a really nice language to work with for a physicist.  (Unfortunately it has some serious drawbacks too.)  I was wondering if it would be worth learning a general purpose functional language.  I wonder how well it would cope with the stuff I am doing now.  I know little about Haskell but I heard that it does not like mutable data...
06:18:03 <Halabund> ...structures.  How well would it cope with an Ising-model simulation, which involves randomly choosing a site on a lattice at each time-step and updating its state based on the state of its neighbours?  Is it possible to do this efficiently?  Would this approach be disadvantaged compared to the method when *every* lattice site is updated at each time-step?
06:18:25 <Halabund> oops ... it got longer than I expected ... :) sorry
06:20:41 <_frederik_> Halabund: yes, it is better to update sites randomly in the Ising model
06:20:53 <_frederik_> Halabund: but i don't know how much better, i am in the process of investigating that
06:21:24 <_frederik_> Halabund: however, Haskell does support mutable data structures in the IO monad which can be just as efficient as C (I think?) if you write them in a C-like fashion
06:21:44 <Halabund> Ah, OK
06:22:01 <Halabund> One problem with Mathematica is that the random-update approach is much slower than the parallel-update approach
06:22:32 <Halabund> Of course Mathematica isn't really suited for doing big simulations, but for other things it's much nicer than a "more traditional" language such as MATLAB
06:22:40 <_frederik_> Halabund: i am working on a library for manipulating sparse tensors which is based on persistent data structures, which tries to be more cache-friendly than I think Matlab's implementation of sparse vectors allows
06:22:46 <qwr> Halabund: haskell supports mutable data, you just have to contain the code dealing with it into IO or St monad
06:23:47 <Halabund> _frederik_: Then there are people using Haskell for such things.  That's encouraging :)
06:25:14 <_frederik_> Halabund: don't be too encouraged
06:25:30 <Philippa> Halabund: there's disadvantage in that you either have to work in a monad or accept going from constant-time to log time updates. But yes, you've got fast array access if you want it - the monad bit's just a way of telling Haskell that you really mean to do something with a side-effect
06:25:40 <_frederik_> Halabund: the language has a long way to go and some of the choices made by the authors of GHC are discouraging
06:26:08 <Philippa> _frederik_: it'd be a good idea to give examples, especially regarding GHC's decisions
06:26:54 <Philippa> though I agree there's a fair amount of development that Haskell could use, it's generally in a better place for mathematical and algorithmic tasks because you don't need as much external support
06:27:02 <Halabund> Yes, the usual problem ... people interested in this language are probably not very interested in physics/numerical stuff ...
06:27:37 <Philippa> there's some interest, but not a huge amount. Enough that if you start asking questions about how to make code go fast then people'll pay attention though
06:27:45 <_frederik_> Philippa: there are a lot of things, for instance when I asked a few years back why GHC doesn't allow library paths to be specified with environment variables, Simon Marlow said that it was because he didn't want to have to deal with bug reports which didn't specify the values of such variables
06:28:17 <Philippa> _frederik_: yeah, that's comparatively easy to build around though
06:28:26 <_frederik_> Philippa: i think the design of cabal kind of follows that philosophy, it only lets you do things which other people have done before, it's not so good at letting you do new things because that would be a source of difficult bug reports
06:29:11 <_frederik_> i kind of feel that GHC is going the way of Java, being too monolithic and too centralised to adapt
06:29:33 <Philippa> Got any evidence for the "because" there? Because cabal's tackling a large problem space, and there's a lot of reasons it might be limited at any given time
06:30:26 <Philippa> (and have you raised examples to ask what the preferred approach would be?)
06:30:37 <nanothief> _frederik_: I used the equivalent of #!/bin/bash \n /usr/bin/ghci -i"$GHC_INCLUDE_PATH" $* to get around that
06:30:43 <nanothief> not sure how correct that is though
06:30:48 <Philippa> nanothief: quite
06:31:17 <_frederik_> i think the solution is to make the problem space smaller, but GHC is going in the opposite direction, it has become a bunch of language extensions, and a runtime, and a compiler, and a build system
06:31:46 <_frederik_> there seems to be a desire to avoid existing solutions, so everything is always new and unstable
06:32:45 <Philippa> you can't really separate runtime from compiler and the language extensions are about as separate as they can be. The build system /is/ significantly separate, it just ships with GHC
06:33:17 <Philippa> Halabund: you came in with a (somewhat) concrete problem, so - got any more questions or things you could use advice on?
06:33:46 <Philippa> numeric performance is getting more attention than it used to as GHC's back end's worked on, btw
06:33:56 <Philippa> and GHC's always been fairly good at unboxing
06:34:13 <Halabund> Philippa: I don't know Haskell yet, I was just wondering if it would be worth learning it.  It looks interesting, I just didn't know if it was suitable for this problem domain.
06:34:20 <_frederik_> Philippa: gcc has a separate runtime (libc) which adheres to its own standard, and in addition there is a standard for the C language, so that is an extremely stable platform. GHC by comparison is extremely unstable
06:34:54 <pejo> _frederik_, no other compiler that I'm aware of allows library paths to be specified with environment variables, why should GHC introduce another source of confusion?
06:35:02 <Halabund> Philippa: Mathematica tought me that functional programming can have big advantages.  This is what raised my curiousity.
06:35:06 <_frederik_> Philippa: separating those two things would really speed up development of language tools and help the community
06:35:18 <Halabund> s/tought/taught/
06:35:23 <Philippa> _frederik_: C is much, much easier to have a standardised RTS for. There's such a thing as GNU C, too
06:35:24 <_frederik_> pejo: gcc? perl? there are plenty of good reasons
06:35:25 <Codex_> How does haskell's runtime/execution work? I know it's lazy evaluation, but does it use "diagram commutes" for the evaluation?
06:35:39 <qwr> _frederik_: C is much older also
06:35:48 <_frederik_> Haskell is almost 20 years old
06:35:50 <Philippa> haskell98 is a stable platform, it's just substantially smaller. Haskell' needs to happen, yes
06:36:11 <Philippa> yeah, and 20 years ago we barely knew how to compile it
06:37:05 <_frederik_> anyway, i don't mean to make people think i'm attacking something close to their hearts, but i have been frustrated by the direction of GHC and I have tried to explain why
06:37:08 <Philippa> the reason there's no stable RTS is that there's no sensible abstraction boundary for it given the sheer variety of possible implementation strategies
06:37:12 <pejo> _frederik_, but the cost is increased complexity. What's the power to weight ratio for that? The Simons are already overworked, I'd rather see that they use their time more productively.
06:37:31 <Philippa> _frederik_: sure. But expressing it in FUD-heavy terms when a newbie's asking for advice isn't helpful
06:37:46 <_frederik_> pejo: i'm saying that i'd rather they structured the development so that they weren't responsible for so much stuff
06:38:05 <Philippa> pejo: it's awful, because the RTS is closely entwined with so much
06:38:13 <_frederik_> Philippa: i really think you were reading an emotional content into my words which wasn't there
06:38:33 <Philippa> _frederik_: no, I wasn't. You can write entirely emotionally neutral material that's still FUD
06:38:50 <_frederik_> Philippa: "fear" is an emotion
06:39:07 <Philippa> *sigh*. Clearly you don't understand what FUD actually /is/
06:39:10 <Philippa> no, don't expand the acronym
06:39:29 <Philippa> it's not a set of emotions, it's material that provokes them. That's entirely separate from the emotional state of the author
06:39:40 <pejo> Philippa, was that directed at me?
06:39:52 <_frederik_> Philippa: can i voice criticisms of GHC, or is anything of that nature FUD?
06:40:04 <Philippa> _frederik_: you can voice criticisms. Please be reasonably clear as to what they actually are
06:40:11 <Philippa> pejo: nope
06:40:41 <_frederik_> Philippa: but what if i don't want to get into a huge argument?
06:40:56 <Philippa> _frederik_: the essence of FUD is creating the image that there /may/ be a huge pile of problems.
06:41:12 * Heffalump thought _frederik_'s criticisms were quite clear
06:41:12 <_frederik_> thank you Heffalump
06:41:14 <Philippa> Heffalump: I thought they were after I started asking questions, yes
06:42:12 <_frederik_> Philippa: i don't mind answering your questions, but i don't like the feeling that you think that i am attacking you by doing so
06:42:24 <Philippa> yeah. Now you're reading things that aren't there
06:42:33 <_frederik_> ok :)
06:42:50 <LoganCapaldo> stop attacking me you guys!
06:42:58 * LoganCapaldo goes and cries in a corner
06:43:10 <_frederik_> hehe
06:43:36 * qwr throws some heavy unidentifiable blob of bits towards LoganCapaldo
06:49:06 <qwr> anyway, the ghc's platformness is imho comfortable. maybe it's a bit unstable at start, but at least you don't have to go to hunt for a every needed piece.
06:49:56 <qwr> ... and hope the piece you found is not abondoned by it's author next year
06:49:58 <Philippa> yeah, it's fairly easy to pick a set of libs you trust to remain stable enough
06:50:20 <Philippa> or else that it's well-written enough that you don't care. I mean, Daan's more or less abandoned Parsec AFAICT...
06:51:17 <proppy> any haskellers @fosdem ?
06:54:54 <resiak> proppy: my xmonad promotion on the gnome wall was moved away :(
06:55:19 <proppy> resiak: too bad, I'm using it in the crossdesktop room
06:55:53 <resiak> proppy: the GEGL talk?  his mad boilerplate-removal macros sounded terrifying
06:55:54 <proppy> resiak: hope there is a few people will ask me about my window manager, so I can advocate your cause
06:56:19 <shapr> yay xmonad!
06:56:49 <proppy> resiak: seems he is using http://pippin.gimp.org/stuff/screencast.ogg, instead of a typical gnome desktop for his presentation
07:00:43 <resiak> proppy: it seems like a pretty neat tool
07:02:05 <proppy> resiak: I'm afraid I miss the beginning of the talk,
07:02:27 <proppy> wonders if there is haskell bindings :)
07:04:22 <resiak> proppy: i think you should write them :)
07:05:07 <proppy> resiak: I'm afraid the only two lines of haskell I've already written where some xmonad tweaks
07:05:22 <proppy> resiak: but I'm reading paul hovak to improve this situation
07:06:02 <proppy> s/hovak/hudak
07:10:01 <faxathisia> th = flip (!!)
07:10:16 <faxathisia> get >>= (n`th`)
07:12:29 <EvilTerran> ow
07:17:54 <shapr> @users
07:17:54 <lambdabot> Maximum users seen in #haskell: 471, currently: 449 (95.3%), active: 10 (2.2%)
07:18:58 <Lemmih> I just realised that Haskell can do entanglement.
07:19:30 <opqdonut> you read that blog post?-)
07:19:40 <Lemmih> What blog post?
07:19:55 <opqdonut> http://luqui.org/blog/archives/2007/09/06/quantum-entanglement-in-haskell/
07:19:56 <lambdabot> Title: The dreams that stuff is made of  Quantum Entanglement in Haskell, http://tinyurl.com/36vlzc
07:20:15 <Lemmih> Oh, no. Not like that.
07:21:22 <Lemmih> In jhc, sometimes the top of a tree depends on something from the bottom.
07:21:56 <LoganCapaldo> eeek, gordian knot
07:22:03 <Lemmih> A naive implementation would walk the tree twice: once down and once up.
07:23:27 <DQuest> If only you could use difference lists
07:23:27 <Lemmih> A smarter implementation would only walk the tree once and use "entanglement" to update the top.
07:23:37 <DQuest> ... or can you?
07:24:55 <Lemmih> It's actually a common trick but I didn't realise it could be used like this.
07:24:58 <faxathisia> DQuest, It's a lot like difference lists
07:25:29 <DQuest> I saw an example the other day where someone replaced every element in a list with the minimum of the list in one pass
07:26:43 <Saizan> yeah, that's used as homework in some courses
07:28:40 * DQuest saw it on t'internet
07:28:50 <opqdonut> link?
07:29:14 <DQuest> http://obfuscatedcode.wordpress.com/2008/02/16/functional-pearl-trees/
07:29:14 <lambdabot> Title: Functional Pearl: Trees  This sentence is false, http://tinyurl.com/3avs5q
07:29:42 <astrolabe> If functionA mentions functionB, do people here have a tendancy to put functionB above functionA, or below it, or no tendancy?
07:29:55 <centrinia> Either this statement is false or the five statements above are false.
07:30:28 * DQuest locks centrinia in a room with Raymond Smullyan
07:30:29 <faxathisia> astrolabe: Does function B mention A as well?
07:31:46 <EvilTerran> i tend to work down from the functions that do everything to their worker functions
07:31:56 <EvilTerran> so functionA at the top
07:32:18 <EvilTerran> this works well with putting functionB in a where{} clause on functionA
07:32:27 <astrolabe> faxathisia: no
07:32:39 <astrolabe> EvilTerran: thank you
07:32:53 <centrinia> Hmm, Raymond Smullyan is a mathemagician.
07:32:54 <EvilTerran> but that's just me, some people work the other way
07:33:15 <centrinia> ... or so says the mighty Wikipedia.
07:33:25 <astrolabe> I think I tend to work the other way (from C I guess), but I'm trying to fix on a habit.
07:34:15 <faxathisia> astrolabe: It's fine to do it either way, which reads best?
07:34:23 <DQuest> centrinia: he wrote "To Mock a Mockingbird", a fantastic puzzle book and/or introduction to combinatory logic
07:34:38 <astrolabe> functionB-at-the-top has the advantage that you can read the file from the top down, and deduce what everything does as you go.
07:34:43 <DQuest> I must resist the urge to go home and read my copy again, I've got lots of things I should be doing
07:34:45 <centrinia> DQuest, I have seen someone replace every element in a tree with the minimum of the tree in one pass.
07:34:54 <DQuest> centrinia: see link
07:35:13 <centrinia> Oh.
07:35:13 <faxathisia> DQuest, such a good book :)
07:35:18 <DQuest> I'm still not certain that I understand it, mind.
07:35:46 <centrinia> Oh, RepMin.
07:36:43 <DQuest> well, I think I understand it.  I just didn't think that haskell would let you do that kind of pattern matching and get away with it
07:36:55 <hpaste>  faxathisia pasted "`inside`" at http://hpaste.org/5862
07:37:02 <faxathisia> my procedure is very verbose :S
07:37:17 <faxathisia> is there some better way to write it?
07:37:28 <Saizan> DQuest: it's important that you're not pattern matching on m
07:37:28 <centrinia> DQuest, that solution is lazy. :O
07:37:30 <mauke> > let fib = 0 : 1 : zipWith (+) fib (tail fib)
07:37:31 <lambdabot>  Parse error at end of input
07:37:37 <mauke> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib
07:37:53 <lambdabot>  thread killed
07:37:57 <mauke> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib
07:37:58 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:37:59 <centrinia> >let fib = 0:1:zipWith (=) fib (tail fib) in take 10 fib
07:38:18 <centrinia> Hmm, bad typo. :(
07:38:36 <DQuest> centrinia: surely lazy solutions are the best kind? :)
07:38:48 <DQuest> Saizan: I'm not sure I follow
07:38:50 <centrinia> >let fib = 2:3:zipWith (*) fib (tail fib) in take 7 fib
07:39:16 <centrinia> Where are my multiplicative fibs?
07:39:21 <faxathisia> > let fib = 2:3:zipWith (*) fib (tail fib) in take 7 fib
07:39:22 <lambdabot>  [2,3,6,18,108,1944,209952]
07:39:28 <centrinia> > let fib = 2:3:zipWith (*) fib (tail fib) in take 7 fib
07:39:28 <lambdabot>  [2,3,6,18,108,1944,209952]
07:39:33 <centrinia> There we go. :)
07:40:01 <centrinia> Oh, I can make Pascal's triangle using the same laziness. :)
07:40:17 <EvilTerran> > fix ((2:).(3:).(zipWith(*)<*>tail))
07:40:21 <lambdabot>  [2,3,6,18,108,1944,209952,408146688,85691213438976,34974584955819144511488,2...
07:41:02 <titusg> anyone planning on contributing to this challenge on c.l.f? http://groups.google.com/group/comp.lang.functional/browse_thread/thread/5743277182ac6678/feffbe0a6e9b339a#feffbe0a6e9b339a
07:41:04 <lambdabot> Title: a golden oldie challenge: Eliza - comp.lang.functional | Google Groups, http://tinyurl.com/26w8vo
07:41:24 <DQuest> Saizan: I mean, I can see how it works from a Prolog perspective, but I can't get my head around what haskell does to evaluate it, or how to write something similar
07:42:16 <centrinia> > let pascal = [1]:(map (\p -> zipWith (+) (0:p) (p++[0])) pascal) in take 5 pascal
07:42:22 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
07:42:27 <centrinia> Good. :)
07:42:28 <faxathisia> > let pascal = [1]:(map (\p -> zipWith (+) (0:p) (p++[0])) pascal) in pascal
07:42:29 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
07:42:39 <titusg> I had a tinker with it but it'd end up 10 x longer than the ruby version
07:42:42 <Saizan> DQuest: if rpMin pattern matched on m, you'd cause the value of m to depend the value of m, introducing non-termination
07:43:38 <DQuest> oh yes, let x=x in x loops forever
07:43:55 <Saizan> yup
07:44:04 <EvilTerran> DQuest, it's basically making a new tree where each leaf points to the same location
07:44:33 <Saizan> yes, it's basically using the imperative mutable-cell approach with write-once cells
07:44:41 <EvilTerran> and the contents of that location is set only after the traversal's done
07:45:00 <EvilTerran> but that doesn't matter, 'cos it's not looked at during the traversal anyway
07:45:02 <DQuest> I follow that much from what prolog would do
07:45:11 <scook0> faxathisia: (re: paste) you could factor out the outer get/put into some kind of "preserving" combinator
07:45:28 <scook0> and the inner put could be something like modify (x:)
07:45:42 <Saizan> prolog would do it quite differently afaiu
07:45:43 <DQuest> Hm, I suppose I should work through what'd happen if someone looked at a leaf in the tree
07:46:04 <DQuest> ah, it's been a while since I did prolog mind
07:47:02 <dancor> is it considered standard/best when making a library with prelude names (map, etc) to 1) import Prelude qualified, or 2) import Prelude hiding all your funcs and then also import Prelude qualified (for when you actually need Prelude.map e.g.)
07:47:25 <centrinia> Here are Bernoulli numbers:
07:47:29 <centrinia> > let { pascal = [1]:(map (\p -> zipWith (+) (0:p) (p++[0])) pascal);bernoulli = 1:[(sum(zipWith (*) (take m bernoulli) (take m $ (map toRational $ (pascal !! (m+1)))))) / (toRational $ (negate (pascal !! (m+1) !! m)))| m <- [1..]];} in take 20 bernoulli
07:47:29 <lambdabot>  [1%1,(-1)%2,1%6,0%1,(-1)%30,0%1,1%42,0%1,(-1)%30,0%1,5%66,0%1,(-691)%2730,0%...
07:47:34 <dancor> and in general how is qualified importing coming along.  it's still basically only done for things where necessary, like Set/Map, right?
07:47:44 <faxathisia> centrinia :D
07:48:26 <centrinia> I probably could clean up the toRational stuff.
07:48:54 <DQuest> I'm beginning to fear centrinia
07:48:58 <centrinia> DQuest, I fear myself.
07:50:04 <RayNbow> hmm, is Lambda the Ultimate down?
07:50:51 <centrinia> Oh no!
07:51:02 <centrinia> Poor LtU. :(
07:51:30 <wli> http://holomorphy.com/~wli/Bernoulli.lhs <-- not quite so golfed
07:54:27 <centrinia> I actually like my implementation more: it only involves two unique constants. :>
07:54:40 <DQuest> Right, I'd better get back to work
07:55:03 <DQuest> Haskell is a dangerous distraction.  It makes me want to rewrite all of my code in it
07:56:36 * faxathisia does rewrite 4 of this type checker ... 
07:56:39 <centrinia> DQuest, I fell into the trap about half a year ago. :(
07:56:39 <mauke> one of uuuuus ...
07:56:39 <roconnor> Haskell makes me want to rewrite everyone else's code in it.
07:56:39 <scook0> @remember DQuest Haskell is a dangerous distraction.  It makes me want to rewrite all of my code in it
07:56:39 <lambdabot> It is stored.
08:31:40 <wli> centrinia: You can initialize the tables to be very close to empty if you want.
08:31:49 <DQuest> centrinia: heh.  I'm supposed to be writing up my dissertation, and instead I've half rewritten it in haskell
08:31:55 <jre2> is there an easy way to get the Text.Regex.Posix =~ operator to allow different options (ie multiline)?
08:32:03 * DQuest no doubt does not need to tell the channel that in general, Java isn't the most fun implementation language on the entire planet
08:32:03 <LoganCapaldo> options would be part of the regex value wouldn't they?
08:32:03 <centrinia> Yeah, my Bernoulli calculator is pretty inefficient.
08:32:03 <LoganCapaldo> I'm just guessing mind you
08:32:03 <johnnowak> faxathisia: only 20 rewrites left!
08:32:04 <faxathisia> lol
08:32:04 <alatter> jre2: is the regex argument allowed to be a compiled regex?
08:32:04 <wli> centrinia: This is mostly for long sequences of Bernoulli numbers.
08:32:06 <johnnowak> faxathisia: if it makes you feel any better, i'm on what must be my tenth rewrite of this type checker
08:32:06 <alatter> jre2: or does it have to be a string-like thing?
08:32:06 <faxathisia> johnnowak: I'm curious what it typechecks?
08:32:06 <jre2> I'm assuming it only takes a string
08:32:06 <johnnowak> faxathisia: a joy-like language
08:32:06 <jre2> :t (=~)
08:32:07 <LoganCapaldo> I thought =~ was super overloaded?
08:32:07 <lambdabot> Not in scope: `=~'
08:32:15 <LoganCapaldo> or maybe it was ==~ that's super overloaded?
08:32:15 <alatter> LoganCapaldo: it is, but I don't think the regex part is allowed to be compiled.  or if it is, I couldn't figure it out myself (which is likely)
08:32:15 <jre2> (=~)  :: (RegexMaker Regex CompOption ExecOption source,RegexContext Regex source1 target)
08:32:16 <EvilTerran> that's... very general
08:32:16 <LoganCapaldo> well compNewline :: CompOption off is how you vae mno multie line right?
08:32:16 <jre2> yea, and whatever (=~) uses by default sets it on
08:32:18 <jrx> @pl \x -> if x `elem` (start : surrounding start) then toInfo $ getField b x else FNoInfo
08:32:18 <lambdabot> flip (liftM2 if' (`elem` (start : surrounding start)) (toInfo . getField b)) FNoInfo
08:32:18 <EvilTerran> ?hoogle find
08:32:18 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
08:32:18 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
08:32:18 <lambdabot> Data.ByteString.find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
08:32:18 <EvilTerran> ?hoogle+
08:32:18 <lambdabot> Data.ByteString.Char8.find :: (Char -> Bool) -> ByteString -> Maybe Char
08:32:18 <lambdabot> Data.ByteString.Lazy.find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
08:32:18 <lambdabot> Data.ByteString.Lazy.Char8.find :: (Char -> Bool) -> ByteString -> Maybe Char
08:32:18 <EvilTerran> hm
08:32:18 <EvilTerran> ?hoogle index
08:32:18 <lambdabot> Data.Ix.index :: Ix a => (a, a) -> a -> Int
08:32:18 <lambdabot> Data.ByteString.index :: ByteString -> Int -> Word8
08:32:18 <lambdabot> Data.Sequence.index :: Seq a -> Int -> a
08:32:18 <EvilTerran> ?hoogle+
08:32:18 <lambdabot> Data.ByteString.Char8.index :: ByteString -> Int -> Char
08:32:18 <lambdabot> Data.ByteString.Lazy.index :: ByteString -> Int64 -> Word8
08:32:18 <lambdabot> Data.ByteString.Lazy.Char8.index :: ByteString -> Int64 -> Char
08:32:18 * EvilTerran will stop that now
08:32:18 <K0MPR3SS0R> hello
08:32:18 <K0MPR3SS0R> can someone help me
08:32:18 <EvilTerran> jrx, i'd suggest something involving 'find' and 'maybe'
08:32:18 <EvilTerran> ?type maybe
08:32:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:32:18 <faxathisia> K0MPR3SS0R: Perhaps
08:32:18 <K0MPR3SS0R> alright leme post my code on hpaste
08:32:19 <EvilTerran> ?type \x -> maybe FNoInfo (toInfo . getField b) $ find (==x) (start : surrounding start)
08:32:19 <lambdabot> Not in scope: data constructor `FNoInfo'
08:32:19 <lambdabot> Not in scope: `toInfo'
08:32:19 <lambdabot> Not in scope: `getField'
08:32:19 <hpaste>  K0MPR3SS0R pasted "(no title)" at http://hpaste.org/5863
08:32:19 <K0MPR3SS0R> alright so its a simple program
08:32:19 <EvilTerran> unfortunately, the deconstructor for Bool (that \b calls if') isn't in the libs
08:32:19 <K0MPR3SS0R> right now im just plain stuck
08:32:19 <faxathisia> why are you stuck?
08:32:19 <alatter> jre2: still around?
08:32:19 <K0MPR3SS0R> at the end
08:32:19 <K0MPR3SS0R> when I try to load a list of strings
08:32:19 <K0MPR3SS0R> into a list of binary trees
08:32:19 <K0MPR3SS0R> its not working for some reason
08:32:19 <K0MPR3SS0R> ins2 function is not working
08:32:19 <K0MPR3SS0R> *** Term           : ins2
08:32:19 <K0MPR3SS0R> *** Type           : String -> Tree Char -> Tree [Char]
08:32:19 <K0MPR3SS0R> *** Does not match : String -> Tree Char -> Tree Char
08:32:19 <K0MPR3SS0R> do you have any idea of another way I could do this or if Im completely on the wrong track
08:32:19 <faxathisia> that's becuase p is a String
08:32:19 <jrx> EvilTerran: I was just wondering, how it may look like
08:32:19 <faxathisia> so you are putting String into the node .. and then the while tree is a Tree String
08:32:19 <faxathisia> (String = [Char])
08:32:19 <K0MPR3SS0R> but build3 is supposed to decompose it
08:32:19 <jrx> since it's so complicated, I'll stick to the unpl version
08:32:19 <Lemmih> K0MPR3SS0R: 'ins2' should probably take a Char and not a String.
08:32:19 <K0MPR3SS0R> yeah...
08:32:19 <K0MPR3SS0R> i think I tried that
08:32:19 <K0MPR3SS0R> leme try again
08:32:19 <K0MPR3SS0R>  i dont remember what happend last time
08:32:20 <K0MPR3SS0R> ok
08:32:20 <K0MPR3SS0R> now im getting error at build2
08:32:20 <K0MPR3SS0R> *** Term           : build2
08:32:20 <K0MPR3SS0R> *** Type           : [String] -> Tree a
08:32:20 <K0MPR3SS0R> *** Does not match : [String] -> [Tree Char]
08:32:20 <chr1s> hey all
08:32:20 <K0MPR3SS0R> but I want to take a list of strings and what will come out is a list of binary trees
08:32:20 <gwern> morning
08:32:20 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
08:32:20 <chr1s> I've read the FingerTree paper by Hinze and Paterson
08:32:20 <K0MPR3SS0R> why is it saying that its of type tree a when its not?
08:32:20 <faxathisia> K0MPR3SS0R: The same number of trees as strings?
08:32:20 <K0MPR3SS0R> yes
08:32:20 <Lemmih> K0MPR3SS0R: 'build2' will always return Nil.
08:32:20 <chr1s> and I was wondering if the IntervalTree data-type is actually implemented and available as a library.
08:32:20 <faxathisia> K0MPR3SS0R: Well if you have String -> Tree, you can make [String] -> [Tree] using map
08:32:20 <K0MPR3SS0R> like in the description, should be the same number of trees = number of strings, each string is a tree with a different depth
08:32:20 <Lemmih> K0MPR3SS0R: You're not using 'j' in the definition of 'build2'.
08:32:20 <K0MPR3SS0R> mapTree?
08:32:20 <faxathisia> K0MPR3SS0R: f :: String -> Tree,  map f :: [String] -> [Tree]
08:32:20 <Lemmih> K0MPR3SS0R: You probably want: build3 j : build2 js.
08:32:20 <K0MPR3SS0R> yes
08:32:20 <K0MPR3SS0R> i jus saw that
08:32:20 <gwern> chr1s: probably. I think Edison implemented all of the purely functional datatypes
08:32:20 <K0MPR3SS0R> thanks
08:32:20 <K0MPR3SS0R> ok ill try that and the map and see how it goes
08:32:20 <Lemmih> K0MPR3SS0R: Btw, build2 == map.
08:32:20 <gwern> @where Edison
08:32:20 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
08:32:20 <K0MPR3SS0R> so build2 f :: string -> Tree
08:32:20 <K0MPR3SS0R> build2 f :: [String] -> [Tree]
08:32:20 <chr1s> I think it should be http://www.haskell.org/ghc/docs/edison/
08:32:20 <lambdabot> Title: Edison User's Guide* (Haskell version)
08:32:20 <chr1s> right?
08:32:20 <gwern> @hackage Edison
08:32:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Edison
08:32:20 <jre2> alatter: oops, didn't see your message
08:32:20 <chr1s> gwern: thanks
08:32:20 <alatter> jre2: I haven't tried it yet myself.  but it seems plausable ^_^
08:32:22 <alatter> does anyone around now know much about the stream-fusion package?
08:32:22 <gnuvince_> @hoogle [[a]] -> a -> [a]
08:32:22 <lambdabot> No matches, try a more general search
08:32:22 <dolio> faxathisia: Did you get anywhere with what you were trying with the indexed monads?
08:32:22 <dolio> @type intercalate . return
08:32:22 <lambdabot> forall a. a -> [[a]] -> [a]
08:32:22 <faxathisia> no it didn't work out
08:35:38 <pa-ching> Hmmm... how can I get access to IORefs or MVars etc. from within a GLUT callback?
08:36:56 <gwern> @seen dcoutts
08:36:57 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 3h 15m 8s ago.
08:37:05 <dcoutts> hia gwern
08:37:25 <gwern> oh, hi
08:37:43 * gwern can never get over the eeriness of doing a @seen and having the person immediately show up
08:38:08 <gwern> dcoutts: yes, well, I couldn't get cabal to cooperate, so I just split them into seperate packages - that way it can compile against the installed library
08:38:25 <gwern> I'm wondering if maybe it's a bug - do you know of any other like cases?
08:38:55 <dcoutts> gwern: right, there's no way yet to get the exe in a package to use the compiled lib in the same package, they just have to use the same source files
08:39:09 <dcoutts> gwern: so it works perfectly well it just compiles the code twice
08:39:53 <gwern> dcoutts: no, I meant do you know if anybody else has tried to have the executable section link against a hsc in the library section - I simply couldn't get it to work without manually running hsc2hs
08:40:26 <dcoutts> gwern: I've not heard of that as a problem, can you give more details?
08:40:40 * gwern already did :)
08:40:59 <dcoutts> gwern: .hsc files can be used in an exe if they can be found
08:41:12 <bos> dcoutts: is there an easyish way to use the zlib bindings incrementally?
08:41:25 <bos> (the answer seems to be "no", but thought i'd ask.)
08:41:43 <dcoutts> bos: hmm, I don't think so at the moment. What api would you want?
08:42:05 <bos> dcoutts: the problem i have is that i'm writing a zip reader and writer.
08:42:10 <dcoutts> bos: obviously you can compress chunks individually
08:42:22 <dcoutts> bos: a .zip file reader?
08:42:39 <bos> and to perform a zip, you need to write out the compressed data and compute a CRC32. it would be nice to not have to do two passes over the input.
08:42:41 <bos> dcoutts: yes
08:42:46 <dcoutts> bos: that should be ok though right because each entry in the .zip is compressed separately isn't it?
08:43:06 <dcoutts> bos: oh, you want the crc too, that's probably doable
08:43:27 <gwern> dcoutts: it's simple - I have a MPDMate.hs, with a main. it's in the Executable section and listed as main:; it calls a module 'PowerMate', which is provided by src/PowerMate.hsc; now, the library section lists 'PowerMate' as an exposed module, and it hsc2hs's it (I can see the PowerMate.hs in dist/build), but when it tries to build MPDMate.hs, it fails saying it cannot find PowerMate.hs/PowerMate.lhs; I look at it's directory in dist/build/mpdmate or ...
08:43:32 <gwern> ... whartever, and indeed, there is no PowerMate.hs; I manually run hsc2hs and generate src/PowerMate.hs, and lo and behold, it works. no permutation of hs-source-dirs or whatnot seem to make a difference
08:43:45 <bos> so a chunked interface to the zlib compressor, that didn't expose all of the complexity of the internals, would be nice.
08:44:38 <dcoutts> gwern: so we have src/PowerMate.hsc, and you also have hs-source-dirs: src in the exe section?
08:44:53 <gwern> dcoutts: betimes, yes
08:45:21 <dcoutts> gwern: is the code public? so I can reproduce the problem?
08:45:43 <gwern> ./MPDMate.hs, ./src/PowerMate.hsc, and so on
08:46:16 <gwern> dcoutts: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mpdmate-0.1
08:46:18 <lambdabot> http://tinyurl.com/36z85v
08:46:23 <gwern> amd http://hackage.haskell.org/cgi-bin/hackage-scripts/package/powermate-0.1
08:46:24 <lambdabot> http://tinyurl.com/34b9wc
08:46:31 <dcoutts> gwern: ta
08:47:01 <gwern> I doubt he's pushed my patch; anyway, my patch implemented my split-package solution, and not the intermdiate executable/library package I was trying to go with
08:47:03 <dcoutts> bos: hmm, the thing is the chunked interface to zlib is pretty hard, that's the main thing that the zlib binding provides
08:47:07 <gwern> *pushed my patch yet
08:48:01 <dcoutts> bos: the .Internal module is based on a Stream monad that handles the low level chunk stuff but even there there's a lot of info to maintain and a little state machine to know what to do when.
08:49:06 <dcoutts> bos: take a look at Codec.Compression.Zlib.Internal and Codec.Compression.Zlib.Stream
08:49:17 <jrx> @hoohle modifyIORef
08:49:17 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
08:49:17 <lambdabot> Data.IORef.atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
08:49:40 <dcoutts> bos: certainly giving access to the crc should be doable, and that's needed for png bindings too
08:49:49 <LoganCapaldo> waht's the b for in atomic?
08:49:57 <jrx> @hoogle freezeIOArray
08:49:57 <lambdabot> No matches found
08:50:43 <dcoutts> bos: but it's not immediately obvious how else to hide the stuff about knowing when to push blocks into zlib and when to pull them out etc.
08:52:42 <dcoutts> bos: eg: [Strict.ByteString] -> [(CRC, Strict.ByteString)] would be doable, that gives you output chunks paired with the accumulated crc up to that point
08:53:03 <dcoutts> bos: would that be enough?
08:55:20 <gwern> @hoogle getArgs
08:55:21 <lambdabot> System.Environment.getArgs :: IO [String]
08:55:46 <gwern> @hoogle exitFailure
08:55:46 <lambdabot> System.Exit.exitFailure :: IO a
08:55:46 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
08:56:53 <dcoutts> gwern: could you hpaste your current .cabal file for powermate (or should I be looking at a darcs version of it?)
08:57:44 <K0MPY> hey faxathisia are you there?
08:58:52 <bos> dcoutts: yes, i think something like that would be fine
08:59:35 <dcoutts> bos: so do you know what is required exactly for the compression/decomp side for .zip? I should look it up for .png too.
08:59:53 <dcoutts> bos: different formats uses different chechsums iirc
09:00:31 <faxathisia> hi
09:00:57 <dcoutts> bos: zlib itself only provides the adler32 checksum of the uncompressed data
09:00:59 <bos> dcoutts: it's a conditioned crc32
09:01:00 <K0MPY> can someone pls help me with this
09:01:02 <K0MPY> im desperate
09:01:03 <bos> dcoutts: yes, that's why just giving a series of chunks would be fine
09:01:11 <hpaste>  K0MPY pasted "(no title)" at http://hpaste.org/5864
09:01:26 <dcoutts> bos: oh, then isn't the current format ok then since the output is a lazy bytestring?
09:01:30 <faxathisia> You just use = not ==
09:01:38 <K0MPY> trying to make a list of trees using a list of strings
09:01:41 <K0MPY> i cant figure it out
09:01:55 <dcoutts> bos: you can map/accumulate the crc over the output blocks and get it all done in a single pass, no
09:02:17 <bos> dcoutts: i wonder why i was confused about that, hmm
09:02:17 <K0MPY> same error
09:02:40 <K0MPY> but why is it saying ;
09:02:40 <K0MPY> there is no ; anywhere
09:03:21 <lxuser> is lambda-the-ultimate.org website down?
09:03:31 <dcoutts> bos: the situation with .png iirc is that zlib already calculates the same checksum internally so it's obvious to want the binding to return it too so the .png reader doesn't have to recalculate it
09:04:02 <LoganCapaldo> lxuser: I can't connect either
09:07:31 <dcoutts> bos: it'd certainly be useful to have a zip file reader/writer, to go along with the existing tar reader/writer (though the latter could do with some improvements like using fewer deps)
09:45:38 <K0MPY> uhmm faxathisia do you know why its doing this? I replaced the == with single = but still same error
09:47:00 <Lemmih> K0MPY: Did you save the file?
09:47:33 <ibid> K0MPY: your type declaration is broken
09:48:30 <K0MPY> yes
10:29:47 <K0MPY> which one
10:31:31 <Lemmih> K0MPY: You have two definitions for 'build2'?
10:32:25 <ibid> K0MPY: looking at it most closely, i don't see what you are trying to say when giving "map f" a type (which works in expression context anyway)
10:32:28 <oerjan> K0MPY: map f :: is not allowed
10:32:51 <K0MPY> i really dont know what im doing there, i just tried to follow some peoples advice
10:36:52 <ibid> +only
11:05:18 <K0MPY> i just need someone to help me fix it,
11:05:24 <Lemmih> K0MPY: Understanding the code is usually a good idea.
11:05:30 <K0MPY> ok map f is not allowed
11:05:30 <K0MPY> yeah well im kinda tired see ive been trying different things for a long time and nothing is working
11:05:30 <oerjan> K0MPY: i mean with ::
11:05:32 <ibid> map f is allowed, just not in that spot :)
11:05:32 <K0MPY> you can understand my frustration for a begginer at this
11:05:32 <hpaste>  gwern pasted "powermate.cabal" at http://hpaste.org/5865
11:05:32 <Lemmih> K0MPY: Just trying permutations at random is not a good way of learning Haskell.
11:05:32 <ibid> in any case, i'm too ill to try and understand what you are trying to do, so i won't even try
11:05:32 <K0MPY> well im kind of limited you see, given that I have to submit this by tonight, and I am far behind
11:05:32 <oerjan> K0MPY: errors with non-existent { ; } are due to haskell's layout translation phase.  they really stand for the begin, new line, and end of an indentation block
11:05:32 <Lemmih> K0MPY: Then you deserve to fail the class.
11:05:32 <K0MPY> no, our whole class is like this
11:05:32 <K0MPY> our teacher gave us no help whatsoever, he doesnt even know what hes doing
11:05:32 <K0MPY> giving us code that doesnt work
11:05:32 <oerjan> it would have been nice if ghc would give error messages based on the real code then, but it doesn't.
11:07:09 <K0MPY> its his first time teaching and hes doing a piss poor job at it
11:08:03 <Lemmih> K0MPY: Then the whole class should fail.
11:08:38 <gwern> dcoutts: http://hpaste.org/5865
11:08:43 <K0MPY> right...
11:09:21 * ibid goes check. no, doesn't look like one of my students. whew
11:09:47 <dcoutts> gwern: ta
11:09:47 <K0MPY> maybe the teacher should fail for giving us this as a first assignment without giving us any help
11:09:47 <K0MPY> or understanding
11:09:47 <gwern> if the whole class fails, that's a big red flag for the administration, and he'll probably be fired
11:09:47 <ibid> K0MPY: have you tried asking your teaching assistants?
11:09:47 <ibid> K0MPY: or the teacher?
11:09:47 <K0MPY> he didnt show up the last two classes
11:13:12 <K0MPY> and he doesnt show us anything usefull when he is there
11:13:36 <ibid> where are you studying?
11:37:35 * ibid has once failed 95 % of his class
13:09:48 <ibid> (though that was from attrition, only three people showed up in the exam)
