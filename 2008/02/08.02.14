00:20:10 <glguy> Anyone know where this came from? http://hpaste.org/5637
00:20:53 <dolio> Wow.
00:21:43 <glguy> All I have is a UK based IP address
00:21:59 <wagle_home> its got john launchbury's name in it
00:23:36 <glguy> yup :)
00:24:38 <glguy> a UK based firefox 3 user...
00:24:43 <glguy> that narrows the field down
00:24:48 <glguy> I should be able to ask them one by one!
00:27:30 <opqdonut> :D
00:28:19 <adu> hi glguy
00:28:25 <glguy> hi
00:28:49 <adu> do you know about opengl?
00:29:01 <glguy> nope
00:29:10 <dolio> He's just good looking.
00:29:16 <adu> oh ok
00:31:19 <adu> http://www.cse.ogi.edu/~jl/
00:31:20 <lambdabot> Title: John Launchbury's home page
00:33:11 <adu> I think thats the guy
00:33:15 <vincenz> @localtime dolio
00:33:16 <lambdabot> Local time for dolio is Thu Feb 14 03:33:15 2008
00:33:27 <glguy> adu: right, but he didn't post it
00:33:54 <glguy> I saw him at work today and the UK is a big of a flight from there
00:35:09 <adu> o ok
00:35:36 <adu> I guess I didn't pick up on the subtext
00:42:37 <adu> is this valid code?
00:42:37 <adu> (g, s) = (\x -> x, \x -> x*x)
00:42:50 <vincenz> yes
00:42:55 <vincenz> if you use let or where
00:43:10 <vincenz> actually, that might be ok even at toplevel
00:43:10 <glguy> or even top-levels
00:43:14 <vincenz> obviously in .hs file
00:43:15 <vincenz> not in ghci
00:43:24 <vincenz> glguy: :)
00:44:08 <glguy> a=b never works in ghci without a let
00:44:57 <jre2> glguy: maybe he's sneaky and has a UK proxy just to fool you
00:50:06 <masklinn> > let (g, s) = (\x -> x, \x -> x*x)
00:50:06 <lambdabot>  Parse error at end of input
00:51:58 <vincenz> masklinn: ...in
00:52:32 <masklinn> > let (g, s) = (\x -> x, \x -> x*x) in "I fail :("
00:52:48 <lambdabot>  thread killed
00:53:04 <masklinn> wow
00:53:44 <glguy> > let (g, s) = (\x -> x, \x -> x*x) in "I fail :("
00:53:46 <lambdabot>  "I fail :("
00:54:47 <lament> :(
00:55:14 <masklinn> not fair
00:55:23 <masklinn> > let (g, s) = (\x -> x, \x -> x*x) in "I fail :("
00:55:24 <lambdabot>  "I fail :("
00:55:28 <masklinn> yay
00:59:05 <lambdabot> masklinn: thread killed
00:59:16 <masklinn> stop hating me :(
00:59:25 <Twey> Haha
00:59:27 <vincenz> @msg #haskell masklinn: thread killed
00:59:28 <lambdabot> masklinn: thread killed
00:59:32 <vincenz> :P
00:59:42 <vincenz> though the first actual thread killed wasn't mine
00:59:50 <masklinn> vincenz, haha you won't get me, I know lambdabot is sentient
01:00:07 <masklinn> (and I never got his answer to the first one so I assume the "thread killed" message was genuine)
01:00:23 <lambdabot> masklinn: no, I'm not
01:00:39 <vincenz> masklinn: her
01:00:42 <vincenz> masklinn: not his
01:00:55 <masklinn> vincenz of course I am
01:01:11 <masklinn> ok, her
01:04:05 <u_quark> > [1..]
01:04:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
01:05:11 <lament> >[..]
01:07:12 <jedbrown> What's with the floating point bashing lately?
01:07:23 <Twey> Floating point bashing?
01:07:38 <Twey> Sounds violent, those little decimal points must hurt :>
01:07:51 <jedbrown> It's been raging on -cafe recently, and came up here a bit too.
01:08:13 * Twey ponders.
01:08:17 <Twey> Ah, lazy language
01:08:26 <Twey> Can express fractions precisely, yes?
01:08:38 <jedbrown> People seem to think they are useless and poorly behaved, but they satisfy very nice properties.
01:08:39 <Twey> Saying (1 / 3) is better than saying 0.33333333333
01:09:09 <jedbrown> Twey: Yeah, how about sin(1) ?
01:09:15 * vincenz gives jedbrown some consolations
01:09:15 <Twey> You can convert to floating-point if necessary
01:09:20 <Twey> jedbrown, mm
01:09:23 * vincenz gives jedbrown some floating-points as consolation
01:09:26 <vincenz> jedbrown: continued fractions
01:09:33 <wagle_home> exact rational with very large numerators and denominators can be very slow
01:10:00 <jedbrown> vincenz: Now check those for equality.
01:10:14 <vincenz> jedbrown: I think equality checcking is flawed
01:10:16 <vincenz> :)
01:10:17 <jedbrown> I think everyone's problem with floating point would go away if there wasn't an Eq instance.
01:10:31 <vincenz> jedbrown: equality checkcing does not make sense for Real numbers
01:10:51 <wagle_home> try listing the first several values from the chaotic iterated 1/r function using exact rationals..  8)
01:10:57 <jedbrown> In practice, Eq for floating point is occasionally useful, but generally not a good idea.  With exact reals, it can't be done.
01:11:21 <vincenz> jedbrown: exactly, and if you ever saw roconnor's paper
01:11:27 <vincenz> jedbrown: he defines floating numbers in a theortical way
01:11:31 <vincenz> with dependent types
01:11:42 <vincenz> and there it is clear that equality-checking does not make sense
01:11:44 <wagle_home> oh.. lazy exact reals?
01:11:47 <vincenz> only closeness-checking
01:12:31 <jedbrown> Yes, closeness in a relative sense is very well behaved for floating point.
01:12:57 <jedbrown> I fired off a response on -cafe, which includes the Fundamental Axiom of Floating Point Arithmetic.
01:13:23 <masklinn> jedbrown?
01:13:42 <jedbrown> masklinn: ??
01:13:55 <masklinn> what would that axiom be?
01:14:48 <jedbrown> For all x,y in F, there exists e with |e| <= e_machine such that    x <*> y = (x * y) (1 + e)      where F is the set of real numbers in a particular floating point representation,<*> represents any hardware arithmetic operation and * is the corresponding exact operation.
01:15:30 <vincenz> jedbrown: you should look at roconnor's encoding of real numbers in dependent types
01:15:33 <vincenz> ragzter: -as a type-
01:15:36 <vincenz> whoops
01:15:41 <vincenz> jedbrown: -as a type-
01:15:46 <vincenz> jedbrown: it makes a lot of things quite clear
01:15:55 <vincenz> (cause types -have- to be exact by definition)
01:19:14 <taruti> Why does it seem like the new version of parsec (2.99) seems to require explicit type signatures everywhere?
01:27:21 <aeolist> hi gour
01:27:25 <aeolist> u_quark: you old...
01:30:15 <u_quark> shhhhh aeolist... lambdabot is watching :P
01:35:07 * aeolist hugs lambdabot 
01:35:09 <ac> is mapping over a ByteString noticeably faster than a regular list?
01:35:50 <dcoutts_> ac: the main point is that reading and writing a bytestring is faster because of less memory traffic
01:36:14 <dcoutts_> because it's a much more compact data structure
01:36:34 <Japsu> @type (.).(.)
01:36:49 <lambdabot> thread killed
01:37:22 <Twey> Hmm?
01:37:26 <Twey> :t (.)
01:37:28 <Cale> @type (.).(.)
01:37:28 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
01:37:29 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:37:34 <Twey> Yes
01:37:42 <yondalf> @src print
01:37:43 <lambdabot> print x = putStrLn (show x)
01:37:58 <Cale> Just a fluke, probably code.h.o's CPUs are busy.
01:40:22 <ac> I like lists though... they can hold anything :-)
01:40:54 <dcoutts_> ac: yes, lists are an excellent control structure and very often a decent data structure too
01:42:12 <ac> why are there no types that hold arbitrary unboxed values?
01:42:33 <ac> ByteString only holds Word8s, and unboxed arrays only hold storeable
01:43:03 <dcoutts_> ac: because there is no generic interface to unboxed values
01:43:15 <ac> Haskell should be both strict and lazy!
01:43:34 <Vq^> ac: like clean?
01:43:57 <jedbrown> UArray doesn't hold storable.  StorableArray does.  And CArray (to be released today) does as well.
01:44:10 <ac> Well, ideally the compiler always makes the best choices, but in the meantime it would be nice to have both
01:45:05 <Vq^> ac: it's not like it's impossible to do strict functions in Haskell
01:45:35 <Cale> The bang pattern notation is a great idea.
01:45:58 <jedbrown> ac: You can't unbox an array unless all values of that type are the same size and the type does not have pointers (so the GC doesn't have to walk the array).
01:46:16 <Vq^> Cale: is there any "real" examples of that?
01:46:35 <Cale> Vq^: Of usages of bang patterns?
01:47:39 <Vq^> Cale: yes, i remember playing around with them some time ago without getting the results i wanted
01:47:52 <Vq^> maybe the GHC manual is the way to go
01:47:58 <ac> Are ByteStrings implemented with Array.Unboxed?
01:48:38 <Cale> Well, they work wherever seq works. I used them in the ICFP contest. They're handy for strictifying accumulators, especially things like integers and such.
01:48:42 <jedbrown> ac: ByteStrings are based on ForeignPtr.  It is completely different from Array.Unboxed.
01:49:33 <jedbrown> ac: They used pinned memory, where-as Array.Unboxed gets moved around by the GC.
01:50:36 <ac> jedbrown: what data structure would you recommend for big arrays of Word8s or Word16s (images)? I'm using lists now, but I want it to be faster
01:51:16 <Cale> ac: UArray
01:51:56 <jedbrown> ac: Are you interfacing with foreign libs?
01:52:28 <ac> jedbrown: that's definitely likely, but not necessarily the case
01:52:29 <taruti> Is there any portable way to create a pipe for runProcess? or is using the posix api the only way?
01:53:19 <ac> so it would be nice to have something that could be quickly turned in to a C pointer to Word8s
01:53:39 <ac> (or Word16s)
01:53:44 <jedbrown> ac: If you do, then UArray will not work.  If you always treat the data as 1 dimensional, then go for ByteString (Word8) or StorableVector (any Storable).
01:54:10 <jedbrown> ^^ Those will do that easily.  If you want to treat it as multi-dimensional, then use CArray which I will release today.
01:54:21 <ac> jedbrown: awesome :)
01:54:31 <ac> jedbrown: it would be nice to treat it multidimensionally for convenience
01:55:11 <jedbrown> CArray gives you the IArray interface, an MArray interface, access to (Ptr a) for any (Storable a), and some utilities.
01:55:46 <jedbrown> It is what my FFTW bindings (also to be released today) are based on.
01:55:47 <ac> I'm still getting a feel for all the strengths and weaknesses of all the somewhat similar data types, like diff arrays, unboxed arrays, storeable vector, byte strings, etc
01:55:59 <ac> I know the implementations are very different
01:56:18 <ac> jedbrown: that sounds like exactly what I'm looking for. What's FFTW?
01:56:42 <jedbrown> Fastest Fourier Transform in the West
01:57:46 <ac> I think I got the mistaken impression that Haskell is bad with tight loops because I always used lists as the control structure
02:00:47 <ac> jedbrown: how will your CArray be different from StoreableArray?
02:00:56 <Cale> ac: Lists are okay, but they'll be better once the stream fusion stuff goes in.
02:01:17 <ac> stream fusion is cool, but it's "only" a 20% speed up
02:01:38 <ac> (or at least that's what I found in my particular test case)
02:01:51 <jedbrown> ac: StorableArray is a mutable-only interface.  CArray offers an immutable interface and optimized versions of some functions.
02:02:20 <jedbrown> ac: My mutable interface is equivalent to StorableArray.
02:02:33 <ac> jedbrown: ah ok. It does sound like a pretty ideal data structure for images
02:05:43 <pejo> ac, what makes you call 20% "only", in a mature compiler?
02:06:18 <ac> pejo: I know it's pretty impressive, which is why I quoted "only", but I also know that it was still a factor of 6 to 10 from C code that did the same thing
02:07:03 <ac> so now I'm going to experiment with using a StoreableArray
02:08:38 <ac> does anybody know an algorithm for morphing images with a sort of lens or smearing effect?
02:10:23 <Lemmih> ac: I'm sure conal does.
02:10:42 <ac> @seen conal
02:10:42 <lambdabot> I saw conal leaving #oasis, #haskell and #ghc 4h 41m 54s ago, and .
02:11:13 <Vq^> Cale: http://haskell.org/haskellwiki/Performance/GHC#Strictify
02:11:30 <Vq^> Cale: why isn't the bang-patterns applied directly?
02:12:10 <Cale> Vq^: I have no idea.
02:13:21 <Vq^> Cale: do you think it fills any function?
02:14:05 <Cale> I doubt it makes a difference.
02:14:15 <Cale> If it does, that would be surprising.
02:17:23 <Vq^> ok, was afraid i missed something
02:18:55 <vincenz> jedbrown: so how about a HUGZ meeting when I arrive in zurich?
02:19:30 <jedbrown> vincenz: When do you arrive?
02:19:34 <vincenz> may
02:20:09 <vincenz> Start of May, that is
02:20:45 <jedbrown> Oh, that's a while.  It's possible I'll be visiting family and climbing in Alaska then, but not for certain.
02:21:27 * vincenz nods
02:44:20 <DukeDave> Am I correct in saying cons (:) is a data type constructor ?
02:44:28 <vincenz> yes
02:44:33 <vincenz> all symbols starting with : are
02:44:46 <vincenz> DukeDave: more correctly, it is a data-constructor
02:46:01 <DukeDave> Gotcha, okay
02:46:12 <vincenz> to disambiguate from type-constructor
02:46:17 <vincenz> e.g.
02:46:22 <vincenz> data Maybe a = Just a | Nothing
02:46:30 <vincenz> Maybe = type-constructor
02:46:36 <vincenz> Just and Nothing = data-constructor
02:46:48 <DukeDave> That makes more sense
02:46:54 <DukeDave> My question then..
02:47:06 <DukeDave> In the maybe example we can say:
02:47:09 <DukeDave> > Just 3
02:47:12 <lambdabot>  Just 3
02:47:17 <DukeDave> But for a list we have to say
02:47:23 <DukeDave> > 3: []
02:47:24 <lambdabot>  [3]
02:47:31 <vincenz> symbols tend to be used for infix
02:47:34 <vincenz> you can use them prefix
02:47:38 <vincenz> > (:) 3 []
02:47:39 <lambdabot>  [3]
02:47:46 <vincenz> just like you can do
02:47:49 <vincenz> > (+) 3 2
02:47:50 <lambdabot>  5
02:48:02 <DukeDave> Is there a data-constructor for list which doesn't require the empty list?
02:48:11 <vincenz> DukeDave: no, but that is specific to list
02:48:16 <vincenz> list is defined that way
02:48:19 <vincenz> let's take another example
02:48:28 <vincenz> data Rational a = a :-: a
02:48:35 <vincenz> then you can do
02:48:37 <vincenz> 1 :-: 2
02:48:51 <vincenz> DukeDave: and yes there is, I guess
02:48:54 <vincenz> > 2 : [2]
02:48:54 <lambdabot>  [2,2]
02:48:58 <vincenz> > 2 : [1,2,3]
02:48:58 <lambdabot>  [2,1,2,3]
02:49:06 <vincenz> > let list = 1 : list
02:49:06 <lambdabot>  Parse error at end of input
02:49:09 <vincenz> > let list = 1 : list in list
02:49:10 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:49:30 <vincenz> DukeDave: if we use words instad of symbols
02:49:38 <vincenz> data List a = Empty | Cons a (List a)
02:49:45 <vincenz> so to make a cons, you need an existing list and an element
02:49:50 <vincenz> be that existing list empty or not
02:50:47 <vincenz> DukeDave: ok?
02:52:22 <DukeDave> vincenz: Wow, that wordy example is lovely :D
02:53:47 <DukeDave> Pete, welcome to the friendliest channel on IRC :)
02:54:01 <vincenz> DukeDave: there's' no difference between symbols and wordy versions, except purely on a syntactical level
02:54:14 <peteog> :)
02:54:37 <peteog> I feel all newbie again
02:55:01 <DukeDave> vincenz: Wish I'd seen that example before
02:55:36 <DukeDave> peteog: Just saw a lovely answer to you question, hit the logs: http://tunes.org/~nef/logs/haskell/08.02.14
02:55:38 <vincenz> @src []
02:55:38 <lambdabot> data [] a = [] | a : [a]
02:55:55 <DukeDave> Hey! When did we get @src ?
02:56:08 <peteog> hot :)
02:56:50 <DukeDave> peteog: More hotness is lambdabot, I don't know if I mentioned it in the pub? Turns the channel in to a sort of stripped down .lhs
02:56:59 <DukeDave> > [1..5]
02:57:00 <lambdabot>  [1,2,3,4,5]
02:57:10 <DukeDave> > filter even [1..8]
02:57:11 <lambdabot>  [2,4,6,8]
02:57:59 <DukeDave> @hoogle (a -> b) -> [a] -> [b]
02:57:59 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
02:57:59 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
02:57:59 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
02:59:22 <peteog> amazing
03:00:03 <dmwit> Whoa, never thought of it as .lhs, but it totally is.
03:00:15 <dmwit> \begin{code}
03:00:21 <dmwit> filter even [1..9]
03:00:25 <dmwit> \end{code}
03:00:27 <dmwit> =P
03:00:42 <vincenz> dmwit: idem
03:01:22 <peteog> DukeDave: so what do I have to do to talk to the lambdabot?
03:01:49 <vincenz> @bot
03:01:49 <dmwit> peteog: You can use '?' or '@' to start a command:
03:01:49 <lambdabot> :)
03:01:51 <DukeDave> dmwit: I'm sure somewhere I heard of a Haskell book which was compilable if you took the plain text as an lhs
03:01:52 <dmwit> ?vixen
03:01:52 <lambdabot> i drive a pickup truck
03:02:07 <DukeDave> @seen peteog
03:02:08 <lambdabot> peteog is in #haskell. I last heard peteog speak 45s ago.
03:02:11 <dmwit> peteog: ?list and ?help are particularly useful at the beginning
03:02:37 <DukeDave> peteog: To evaluate an expression just prefix it with >
03:02:43 <DukeDave> ?help
03:02:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:02:48 <DukeDave> ?list
03:02:48 <dmwit> peteog: There's also a few abbreviations: ">" for "?run", ":t" for "?type", and ":k" for "?kind".
03:02:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
03:03:11 <nayru> hmm
03:03:20 <peteog> so like
03:03:28 <peteog> > map (+1) [1..10]
03:03:29 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
03:03:29 <dmwit> peteog: You can also use all the same commands in a privmsg, but the : abbreviations don't work.
03:03:33 <peteog> cool :)
03:03:39 <peteog> :t map
03:03:40 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:03:55 <peteog> that really is cool
03:03:59 <DukeDave> peteog: This channel is the sole reason I stuck with Haskell
03:04:25 <dmwit> vincenz: Google fails me. idem?
03:04:36 <vincenz> dmwit: ibidem
03:04:37 <vincenz> ibid
03:04:41 <vincenz> likewise
03:05:06 <peteog> well I had a flirt with it a uni, but not with the c# 3.0 it really does make a lot more sense now
03:05:09 <dmwit> ah =)
03:06:32 <peteog>  :s/not/now
03:06:33 <peteog> :)
03:07:38 <dmwit> @vixen Hey baby, want to go out tonight?
03:07:38 <lambdabot> i'll hafta plead the fifth on that one.
03:08:58 <dmwit> ?quote
03:08:58 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
03:12:17 <masklinn> > 10**10
03:12:20 <lambdabot>  1.0e10
03:12:28 <masklinn> > 10**10**10
03:12:28 <lambdabot>  Infinity
03:12:49 <hpaste>  nayru pasted "signature" at http://hpaste.org/5654
03:13:09 <jedbrown> Is one supposed to list all extensions that are used in the .cabal file?  When I do this, cabal gives those flags to ghc for every file instead of just following the LANGUAGE pragma.
03:13:13 <nayru> i'm not sure how to make the "signature" (if that's what it's called) for the function forward... right now i have a bunch of question marks there
03:13:26 <hpaste>  Cin pasted "(no title)" at http://hpaste.org/5655
03:13:37 <hpaste>  Cin annotated "(no title)" with "(no title)" at http://hpaste.org/5655#a1
03:14:02 <ToRA> nayru: delete the forward :: ??? line, load it up in ghci and type :t forward
03:14:06 <ToRA> ?
03:14:12 <nayru> ToRA: oh, okay
03:14:47 <nayru> that one says forward :: [[Double]]
03:15:29 <nayru> ah. i'm not taking those matrices as arguments... i suppose i should, in case i want to reuse it
03:15:54 <dmwit> Cin: Great!
03:16:14 <dmwit> Cin: I assume that's a working (part of a?) Scheme interpreter?
03:16:30 <Cin> dmwit: indeed!
03:16:33 <dmwit> :t (<*)
03:16:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
03:18:09 <Cin> @hoogle (<*)
03:18:09 <lambdabot> Did you mean: (<*)
03:18:09 <lambdabot> Prelude.undefined :: a
03:18:09 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
03:18:14 <Cin> danke.
03:18:17 <dmwit> :t gets
03:18:18 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
03:18:22 <dmwit> :t puts
03:18:23 <lambdabot> Not in scope: `puts'
03:18:34 <dmwit> Too bad.
03:18:44 <Cin> what module is <* in?
03:18:51 <wagle_home> there a lib for static checking well-formedness of matrixes (so that, for example, multiplication doesnt get run-time errors)?
03:18:53 <dmwit> Control.Applicative
03:19:00 <Cin> ah, thankies
03:19:13 <nayru> is it hard to install extra libraries with ghc?
03:19:33 <dmwit> nayru: No, it should be very easy.  Is the library on Hackage?
03:19:34 <jeffz> nayru: some are dead easy.
03:19:55 <nayru> dmwit: i don't know. i'm just thinking in general. it was always very hard when i used lisp
03:20:13 <jeffz> nayru: you were using the wrong lisp then :P
03:20:25 <dmwit> nayru: In general, libraries on Hackage are all very easy to install, and libraries elsewhere are almost always easy to install.
03:20:54 <dmwit> (The trick is the "almost" bit for non-Hackage libraries. heh)
03:21:44 <dmwit> ?hoogle (s -> s) -> State s ()
03:21:45 <lambdabot> No matches, try a more general search
03:21:53 <dmwit> :t modify
03:21:53 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
03:21:55 <nayru> dmwit: okay, sounds good
03:21:59 * dcoutts grumbles that not all the hackage libraries are easy to install
03:22:08 <dcoutts> more automated hackage QA!
03:22:30 <dmwit> Cin: putObjs m = modify (second m)
03:23:18 <dmwit> Cin: Actually, a bunch of your functions look like they could benefit from modify. =P
03:23:31 <Cin> dmwit: hmm :)
03:23:47 <Cin> dmwit: good idea :D
03:24:48 <dmwit> :t gets (head . fst) <* modify (first tail) -- not sure I like this better than your definition, though
03:24:49 <lambdabot> forall (f :: * -> *) a d. (MonadState ([a], d) f, Applicative f) => f a
03:25:57 <Cin> for genIdentity?
03:26:01 <dmwit> yeah
03:26:27 <ToRA> is StateT applicative?
03:26:34 <ski> @index <*
03:26:35 <lambdabot> bzzt
03:26:41 <dmwit> ?index (<*)
03:26:41 <lambdabot> bzzt
03:26:41 <ski> @index (<*)
03:26:42 <lambdabot> bzzt
03:26:47 <dmwit> Control.Applicative
03:26:57 <ski> yeah, i know ..
03:27:06 <dmwit> ?where state
03:27:06 <lambdabot> I know nothing about state.
03:27:23 <dmwit> ?where+ state http://www.cse.unsw.edu.au/~dons/lambdabot/State/
03:27:24 <lambdabot> It is stored.
03:27:43 <ski> ToRA : every haskell monad is applicative (but not necessary an instance of the class)
03:27:50 <wagle_home> ?where indiana
03:27:50 <lambdabot> I know nothing about indiana.
03:27:58 <ToRA> @type StateT (liftM (second (head &&& tail))
03:28:00 <lambdabot> parse error (possibly incorrect indentation)
03:28:04 <ToRA> @type StateT (liftM (second (head &&& tail)))
03:28:05 <lambdabot>     Couldn't match expected type `(d, [a])' against inferred type `[a]'
03:28:05 <lambdabot>       Expected type: (a, (d, [a])) -> (a, (d, (a, (d, [a]))))
03:28:05 <lambdabot>       Inferred type: (a, (d, [a])) -> (a, (d, (a, [a])))
03:28:08 <ski> so, since `StateT s m' is a monad, for any monad `m', that gives ..
03:28:09 <wagle_home> i thought it knew state now
03:28:17 <dmwit> ski: Submit a patch to hoogle.txt. =)
03:28:20 <Cin> :t first
03:28:22 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
03:28:47 <ToRA> ski: true, i was meaning in the haskell sense :)
03:29:06 <ski> ToRA : i was talking about haskell monads, too
03:29:09 <dmwit> > first (*2) (5, "hi")
03:29:11 <lambdabot>  (10,"hi")
03:29:16 <Cin> clever
03:29:18 <ski> i'm not sure if general monads needs to be applicative
03:29:47 <dmwit> Cin: mixes well with FunRefs =)
03:29:59 <ToRA> ski: so why does haskell have the instance defined like (Monad m) => Applicative (WrappedMonad m)
03:30:05 <ToRA> ?
03:30:08 <ski> dmwit : `FunRefs' ?
03:30:28 <dmwit> ski: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
03:30:30 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
03:30:37 <ski> ToRA : probably because the class `Applicative' is not a superclass of the class `Monad'
03:30:48 <vasya> i want to be with you
03:30:51 <dmwit> ski: It's a way to make your record accessors first-class.
03:30:57 <dmwit> Hiya, vasya!
03:31:31 <ski> (ToRA : to clarify, i was speaking of the general sense of haskell monad (more specific than general monad) .. not speaking of whether something was an instance of the class `Monad')
03:31:48 <vasya> fukc your self plesase
03:32:00 <Cale> vasya: uhh...
03:32:05 <vasya> ehhh
03:32:10 <vasya> shapka ushanka
03:32:26 --- mode: ChanServ set +o Cale
03:32:36 <vasya> i want to have sex with your ass
03:33:06 <vincenz> Anyone here in a HUG?
03:33:12 --- mode: ChanServ set +o vincenz
03:33:15 --- kick: vasya was kicked by vincenz (vincenz)
03:33:20 <Cin> dmwit: this functioal references stuff is groovy
03:33:24 <ski> Cale : ty kind sir
03:33:34 <dmwit> Thanks, vincenz.
03:33:37 <dmwit> Cin: I agree!
03:33:42 <ski> vincenz : er, you, i mean :)
03:33:43 --- mode: vincenz set -o vincenz
03:33:45 * Cin continues reading
03:33:54 <dmwit> Cin: I was very excited when I read it, and every time I need it I get excited again. =)
03:33:58 <vincenz> Anyone part of a haskell user group?
03:34:01 <Cale> ah, I looked away for a second
03:34:04 <Cale> Sorry about that :)
03:34:06 <vincenz> Cale: :P
03:34:14 <vincenz> Cale: kicking in the blink of an eye
03:34:25 <vincenz> the banlist is full tho :|
03:34:54 <dmwit> Wow, really?
03:35:40 --- mode: Cale set -b *!*@CPEe8dd5640e290-CM00194757ed42.cpe.net.cable.rogers.com
03:36:07 --- mode: Cale set +b *!*@cable.netlux.org
03:36:12 --- mode: Cale set -o Cale
03:37:14 <vincenz> 50 really is little
03:37:25 <ToRA> :t StateT $ return . (head . fst &&& first tail)
03:37:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => StateT ([a], b) m a
03:38:06 * ToRA finally figures it out (Cin - genIdentity?)
03:38:49 <Cin> good grief
03:39:16 <vincenz> that''s a nasty type
03:39:25 <opqdonut> wow, indeed
03:39:31 <ToRA> i'm not necessarily suggesting you use that though, but somethign to think about
03:39:32 <vincenz> I doubt that's even alloewd
03:39:42 <Cin> :t (&&&)
03:39:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:39:44 <opqdonut> vincenz: ?
03:39:44 <vincenz> the [a] and the a are off
03:39:50 <opqdonut> ah okay
03:39:52 <vincenz> forall (m :: * -> *) a b. (Monad m) => StateT ([a], b) m a
03:39:56 <vincenz> you' have a monad returning 'a's
03:40:00 <vincenz> but those a's must be free
03:40:04 <vincenz> yet the state consists of a specific [a]
03:40:43 <ToRA> > let foo = StateT $ return . (head . fst &&& first tail) in flip runStateT ([1,2,3], "hi") foo
03:40:44 <lambdabot>        add an instance declaration for (Show (m (a, ([a], [Char]))))
03:40:52 <dmwit> vincenz: No, only this function returns 'a's.
03:41:03 <opqdonut> :t get
03:41:05 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
03:41:06 <vincenz> dmwit: oh right, nice catch
03:41:06 <opqdonut> kidna like that
03:41:11 <opqdonut> *kinda
03:41:25 <ToRA> > let foo = StateT $ return . (head . fst &&& first tail) in flip runStateT ([1,2,3], "hi") foo :: Maybe (Int, ([Int], String))
03:41:26 <lambdabot>  Just (1,([2,3],"hi"))
03:42:01 <faxathisia> In GHC compiler/deSugar/Match.lhs there's this comment "The function @match@ is basically the same as in the Wadler chapter, except it is monadised, to carry around the name supply, info about annotations, etc."
03:42:21 <faxathisia> any idea what book or text the chapter is from?
03:42:37 <opqdonut> faxathisia: "implementation of functional programming languages"
03:42:40 <opqdonut> i'd guess
03:42:46 <opqdonut> available online
03:43:51 <faxathisia> ok thanks
03:44:14 <Cin> giveRaiseToFirst = update (salary . fst) (+100)
03:44:17 <Cin> that's dead sexy
03:44:53 <vincenz>  giveRaiseToFirst = update (salary . fst) (+100000) is even sexier
03:45:02 <Cin> heheh
03:45:33 <dmwit> > map f [1..10] -- also sexy
03:45:35 <lambdabot>  Add a type signature
03:45:42 <dmwit> > map f [1..10] :: [Expr] -- also sexy
03:45:45 <lambdabot>  [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10]
03:45:47 <wagle_home>  giveRaiseToFirst = update (salary . mine) (+100000) is sexied
03:46:14 <wagle_home> sexiest, even..  8/
03:46:36 <dmwit> Sexied... it's like pickled, dipped in sex.
03:46:53 * Cin chortles
03:47:07 <wagle_home> "completely sexied types"
03:47:38 <dmwit> "What can we do with such a well-plated boiler?" -- awesome
03:47:43 <dmwit> twanvl++
03:47:52 <opqdonut> wow, Expr sure rules
03:48:07 <Cale> > iterate f x
03:48:11 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
03:48:18 <Cale> > scanl f z [1,2,3]
03:48:20 <lambdabot>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3]
03:48:34 <opqdonut> how come those default to expr? is that a new feature in lambdabot?
03:48:34 <Cale> > scanr f z [1,2,3]
03:48:35 <lambdabot>  [f 1 (f 2 (f 3 z)),f 2 (f 3 z),f 3 z,z]
03:48:42 <Cale> yeah
03:48:43 <faxathisia> > let f 0 = s ; f n = f (n-1) + f (n-1) - f (n-1) - f (n-1) + f (n-1) in f 3 :: Expr
03:48:43 <lambdabot>  s + s - s - s + s + (s + s - s - s + s) - (s + s - s - s + s) - (s + s - s -...
03:48:48 <opqdonut> sweet indeed
03:48:49 <faxathisia> It's a Kosh curve :p
03:48:56 <wagle_home> i think its the unbound var
03:48:58 <dmwit> Cale: All your carefully crafted string functions are officially outdated.
03:49:00 <Cale> The SimpleReflect module defines a-z variables.
03:49:01 <faxathisia> if you turn 90 for + and - step for s
03:49:14 <wagle_home> > scanr fsdsd zdsjhs [1,2,3]
03:49:14 <lambdabot>   Not in scope: `zdsjhs'
03:49:20 <wagle_home> mmm
03:49:40 <wagle_home> unbound single letter var?
03:49:51 <wagle_home> > scanr fsdsd zd [1,2,3]
03:49:52 <lambdabot>   Not in scope: `zd'
03:49:57 <wagle_home> > scanr fsdsd z [1,2,3]
03:49:58 <lambdabot>   Not in scope: `fsdsd'
03:49:58 <dmwit> wagle_home: Yeah, one-character names only
03:50:12 <wagle_home> oki
03:50:24 <Cale> > scanr (var "fsdsd") z [1,2,3]
03:50:24 <lambdabot>  Couldn't match expected type `a -> b -> b'
03:50:29 <Cale> > scanr (fun "fsdsd") z [1,2,3]
03:50:29 <lambdabot>  [fsdsd 1 (fsdsd 2 (fsdsd 3 z)),fsdsd 2 (fsdsd 3 z),fsdsd 3 z,z]
03:50:38 <Cale> > scanr (fun "fsdsd") (var "zdj") [1,2,3]
03:50:39 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Sym a))
03:50:41 <faxathisia> > fun "\""
03:50:42 <lambdabot>  Add a type signature
03:50:56 <Cale> > fun "\"" 3 4
03:50:57 <lambdabot>  Add a type signature
03:51:00 <Cale> > fun "\"" 3 4 :: Expr
03:51:01 <lambdabot>  " 3 4
03:51:01 <wagle_home> > scanr (fsdsd :: Expr) (zdsjhs :: Expr) [1,2,3]
03:51:02 <lambdabot>   Not in scope: `zdsjhs'
03:51:10 <wagle_home> aww
03:51:18 <vincenz> > fun "\"" 3 4 $ var "\"" :: Expr
03:51:18 <Cale> It's not magical :)
03:51:19 <lambdabot>  " 3 4 "
03:51:19 <vincenz> :P
03:51:40 <vincenz> > 1 :: Expr
03:51:40 <lambdabot>  1
03:51:49 <dmwit> That quote sure is fun!
03:51:52 <Cale> Well, okay, it's slightly magical :)
03:51:52 <vincenz> > fun ">" 1 :: Expr
03:51:53 <lambdabot>  > 1
03:51:57 <vincenz> hmm
03:52:01 <vincenz> one space too many :P
03:52:10 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
03:52:10 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
03:52:12 <vincenz> > fun "\BS>" 1 :: Expr
03:52:15 <lambdabot>  > 1
03:52:18 <opqdonut> :D
03:52:20 <vincenz> ;D
03:52:25 <vincenz> worth a try
03:52:25 <dmwit> heh
03:52:26 <opqdonut> could've worked
03:52:38 <wagle_home> > scanr (fun "fsdsd")  (var "zdsjhs") [1,2,3]
03:52:39 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Sym a))
03:52:49 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5 :: Expr
03:52:51 <lambdabot>  5 * ((5 - 1) * ((5 - 1 - 1) * ((5 - 1 - 1 - 1) * ((5 - 1 - 1 - 1 - 1) * 1))))
03:53:00 <wagle_home> > scanr (var "fsdsd")  (var "zdsjhs") [1,2,3]
03:53:01 <lambdabot>  Couldn't match expected type `a -> b -> b'
03:53:06 <faxathisia> > let s = "let s = \"\" in fun (s +" ; t = "+ t) :: Expr" in fun (s ++ t) :: Expr
03:53:07 <lambdabot>  let s = "" in fun (s ++ t) :: Expr
03:53:14 <wagle_home> > scanr (var "fsdsd")  (var "zdsjhs") [1,2,3] :: Expr
03:53:15 <lambdabot>  Couldn't match expected type `a -> b -> b'
03:53:29 <Cale> The function definitely has to be fun
03:53:39 <vincenz> Cale: of course it's fun!
03:54:12 <dmwit> :t fun
03:54:13 <lambdabot> Not in scope: `fun'
03:54:20 <Cale> > scanr (fun "fsdsd")  (var "zdsjhs" :: Expr) [1,2,3] :: Expr
03:54:21 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Sym a'
03:54:23 <dmwit> bummer of an attitude, man
03:54:51 <dmwit> > scanr (fun "fsdsd") (sym "zuse") [1, 2, 3]
03:54:52 <lambdabot>   Not in scope: `sym'
03:54:55 <Cale> Where the heck is Sym defined?
03:55:04 <Cale> Surely not in SimpleReflect
03:55:09 <Cale> :t Sym
03:55:10 <lambdabot> Not in scope: data constructor `Sym'
03:55:17 <Cale> :info Sym
03:55:44 <dmwit> > fun "fsdsd"
03:55:44 <faxathisia> > let q = "fun (\"let q = \"" in fun ("let q = " ++ show q ++ " in " ++ q) :: Expr
03:55:45 <lambdabot>  Add a type signature
03:55:45 <lambdabot>  let q = "fun (\"let q = \"" in fun ("let q = "
03:56:31 <dmwit> ?index Sym
03:56:31 <lambdabot> bzzt
03:58:13 <wagle_home> > Sym "foo"
03:58:14 <lambdabot>   Not in scope: data constructor `Sym'
03:58:31 <doserj> http://hackage.haskell.org/packages/archive/numbers/2007.9.25/doc/html/Data-Number-Symbolic.html
03:58:32 <lambdabot> http://tinyurl.com/ytadfn
03:58:34 <wagle_home> 1 :: Sym
03:58:44 <wagle_home> > 1 :: Sym
03:58:45 <lambdabot>      `Sym' is not applied to enough type arguments
03:58:45 <lambdabot>     Expected kind `?', but...
03:58:47 <dmwit> > var "hey" :: Sym String
03:58:48 <lambdabot>  hey
03:58:51 <wagle_home> > 1 :: Sym Int
03:58:52 <lambdabot>  1
03:58:52 <dmwit> ;-)
03:59:19 <dmwit> > scanl (fun "wha") (var "t do you want" :: Sym String) [1, 2, 3]
03:59:22 <lambdabot>        add an instance declaration for
03:59:22 <lambdabot>       (SimpleReflect.FromExpr (Sym Str...
03:59:46 <dmwit> :t scanl
03:59:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
04:02:35 <dmwit> Amazing.  His blog has exactly 4 real posts.  Half of these posts are immensely useful, and I haven't read the other half.
04:02:46 <dmwit> I guess it's time to get reading...
04:02:55 <masklinn> whose blog?
04:03:11 <dmwit> http://twan.home.fmf.nl/blog/
04:03:12 <lambdabot> Title: 21 thoughts
04:09:00 <nayru> hmm. how can i apply sum to [[0.4],[0.5]]
04:09:10 <faxathisia> > let q="let q=";v=";v=";p="q ++ show q ++ v ++ show v ++ "in fun (q ++ show q ++ v ++ show v ++ "p =" ++ show p ++ "in fun (" ++ p ++ ") :: Expr") :: Expr
04:09:11 <lambdabot>  let q="let q=";v=";v="p ="q ++ show q ++ v ++ show v ++ "in fun (q ++ show q...
04:09:13 <nominolo> does anyone know what options i have to pass to ghc to be able to link to C++ libraries?
04:09:14 <faxathisia> :[
04:09:40 <oerjan> nayru: sum . concat
04:09:49 <Cale> nayru: what's the expected result?
04:09:57 <nayru> Cale: 0.9
04:10:11 <Cale> okay, then concatenate the lists first, as oerjan suggests
04:10:32 <masklinn> > (sum . (map sum)) [[0.4], [0.5]]
04:10:33 <lambdabot>  0.9
04:10:39 <nayru> thank you
04:10:47 <masklinn> > (sum . concat) [[0.4], [0.5]]
04:10:48 <lambdabot>  0.9
04:13:01 <oerjan> > fun "whatever"
04:13:02 <lambdabot>  Add a type signature
04:13:06 <oerjan> > fun "whatever" :: Expr
04:13:11 <lambdabot>  whatever
04:13:49 <nayru> is function composition just a nice notation for function application?
04:13:59 <oerjan> @src .
04:14:00 <lambdabot> (.) f g x = f (g x)
04:14:09 <nayru> like f(g(x)) is (f . g) x  or something like that?
04:14:14 <faxathisia> nayru, well not really, composition is done by application though
04:15:03 <nayru> yes. i am sure there are more details to it.. just trying to familiarize myself with the terminology
04:15:59 <oerjan> it's also higher order - you can pass (f . g) around before applying it, as many times as you want
04:16:04 <opqdonut> well for curried functions the distinction between application and composition blurrs
04:16:23 <nayru> ah
04:16:29 <faxathisia> > let c = map chr [3] in fun (cycle $ c ++ "5,de" ++ c ++ "3,su ") :: Expr
04:16:33 <lambdabot>  ,de,su ,de,su ,de,su ,de,su ,de,su ,de,su ,de,su...
04:16:38 <faxathisia> aww +c
04:16:48 <faxathisia> works in /msg though :p
04:17:50 <oerjan> it only shows parts of it?
04:18:17 <oerjan> > fun (repeat 'a') + fun (repeat 'b') :: Expr
04:18:18 <lambdabot>  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
04:18:29 <faxathisia> oerja: http://img118.imageshack.us/img118/6229/picture1dt7.png
04:18:33 <dmwit> > fun (cycle "desu") :: Expr
04:18:34 <lambdabot>  desudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesudesu...
04:19:03 <dmwit> oh, haha
04:19:31 <dmwit> This channel probably has -c or whatever.
04:19:38 <oerjan> ah
04:20:11 <oerjan> but i still don't understand why it was cut off?
04:20:29 <dmwit> What was cut off?
04:20:33 <oerjan> > let c = map chr [3] in fun (cycle $ c ++ "5,de" ++ c ++ "3,su ") :: Expr
04:20:35 <lambdabot>  ,de,su ,de,su ,de,su ,de,su ,de,su ,de,su ,de,su...
04:21:06 <dmwit> > "\3"
04:21:07 <lambdabot>  "\ETX"
04:21:34 <dmwit> > "\3&5,de"
04:21:35 <lambdabot>  "\ETX&5,de"
04:21:39 <dmwit> > "\3\&5,de"
04:21:40 <lambdabot>  "\ETX5,de"
04:21:53 <oerjan> > let c = map chr [3] in (cycle $ c ++ "5,de" ++ c ++ "3,su ") :: Expr
04:21:54 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Char]'
04:21:59 <oerjan> > let c = map chr [3] in (cycle $ c ++ "5,de" ++ c ++ "3,su ")
04:22:01 <lambdabot>  "\ETX5,de\ETX3,su \ETX5,de\ETX3,su \ETX5,de\ETX3,su \ETX5,de\ETX3,su \ETX5,d...
04:22:06 <dmwit> > fun (cycle "\3\&5,de\3\&3,su ") :: Expr
04:22:07 <lambdabot>  ,de,su ,de,su ,de,su ,de,su ,de,su ,de,su ,de,su...
04:22:50 <oerjan> oh wait
04:23:02 <oerjan> the invisible characters must be included in the count
04:23:18 <dmwit> The commas seem unnecessary, though.
04:23:28 <faxathisia> > fun (repeat "\3")
04:23:28 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
04:23:33 <faxathisia> > fun (repeat '\3') :: Expr
04:23:34 <lambdabot>  ...
04:23:42 <faxathisia> > fun (repeat '...') :: Expr
04:23:43 <lambdabot>  Improperly terminated character constant at "'...'..." (column 13)
04:23:46 <faxathisia> > fun ("...") :: Expr
04:23:47 <lambdabot>  ...
04:23:59 <dmwit> > fun "in the afternoon"
04:24:00 <lambdabot>  Add a type signature
04:24:07 <faxathisia> hehe
04:24:14 <oerjan> a very appropriately named function, that :D
04:24:21 <dmwit> yep =)
04:25:24 <dmwit> ?quote faxathisia /msg lambdabot > fun (cycle "\3\&5de\3\&3su ") :: Expr
04:25:35 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
04:25:46 <dmwit> ?remember faxathisia /msg lambdabot > fun (cycle "\3\&5de\3\&3su ") :: Expr
04:25:46 <lambdabot> Nice!
04:25:55 <faxathisia> hehe
04:26:36 <dmwit> ?quote
04:26:36 <lambdabot> Philippa says: plus who wants to get unsafeHead?
04:26:41 <nayru> hmm. i have a list of lists, [[0.45], [0.1]] and i have a function that sums those numbers... later i want to divide the numbers in that list by their sum.. and i'm trying with map and it doesn't work
04:26:43 <hpaste>  nayru annotated "signature" with "map?" at http://hpaste.org/5654#a1
04:26:55 <dmwit> nayru: concat
04:27:21 <oerjan> nayru: map (map (/ s))
04:27:28 <dmwit> nayru: or, map (map (/alpha))
04:27:34 <dmwit> dang, too slow
04:27:37 <nayru> hmm
04:27:42 * oerjan cackles evilly
04:27:56 <dmwit> > map (map (/3)) [[1, 2], [5, 10]]
04:27:57 <lambdabot>  [[0.3333333333333333,0.6666666666666666],[1.6666666666666667,3.3333333333333...
04:28:01 <faxathisia> nayru: You know you don't have to put in type annotations, by the way, you car omit the foo :: ... stuff when you wish
04:28:30 <nayru> faxathisia: yes. i usually write the functions, do :t on them and then add it. without really knowing why
04:28:51 <dmwit> It's a nice piece of documentation, sometimes.
04:28:52 <faxathisia> ah ok, as long as you know they can be inferred :)
04:29:16 <nayru> yes, it sometimes helps me with all those type errors i produce
04:29:22 <oerjan> nayru: it's a good idea to add them, it can make error messages somewhat more comprehensible
04:29:40 <dmwit> GHC also treats it as documentation. =)
04:30:26 * mux is looking for an example haskell module using cpp
04:31:03 <mux> I get errors such as "lexical error at character 'i'" when I add #if ... #endif stuff
04:31:11 <oerjan> mux: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html
04:31:11 <mux> and my .cabal file lists CPP in the extensions field
04:31:12 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2gpya5
04:31:31 <mux> oerjan: cheers
04:31:38 <nayru> map complains about my function "f". it's not the right type
04:32:30 <mux> oerjan: but I'd be interested in how this is handled in the .cabal file
04:32:35 <oerjan> nayru: it's not a function
04:32:54 <oerjan> it doesn't take an argument...
04:33:17 <oerjan> or wait
04:33:47 <oerjan> nayru: (/ alpha f)
04:33:54 <faxathisia> > let ret = map chr [0x0d, 0x0a] ; f n = show n ++ ret ++ f (n+1) in fun (f 0) :: Expr
04:33:55 <lambdabot>  0
04:33:55 <lambdabot> 1
04:33:55 <lambdabot> 2
04:33:56 <lambdabot> 3
04:33:59 <lambdabot> 4
04:34:01 <lambdabot> [17 @more lines]
04:34:17 <faxathisia> luckly you can't make it do arbitrary IRC messages though
04:34:30 <oerjan> (and two maps)
04:34:46 <dmwit> Whoa... time to try something nasty.
04:34:57 <nayru> oerjan: thank you, that worked
04:35:39 <dmwit> > fun "hey\13\10> \"hi\"" :: Expr
04:35:39 <oerjan> mux: i don't know
04:35:40 <lambdabot>  hey
04:35:40 <lambdabot> > "hi"
04:35:56 <dmwit> > fun "hey\13\10?list" :: Expr
04:35:57 <lambdabot>  hey
04:35:57 <lambdabot> ?list
04:36:05 <dmwit> ok =)
04:36:39 <oerjan> irc messages aren't automatically echoed
04:36:57 <dmwit> ah
04:36:59 <oerjan> and no one in their right mind would make a bot do it
04:39:08 <vincenz> dmwit: now we just need a second bot
04:39:33 <vincenz> dmwit: and thn quine it
04:39:38 <dmwit> mmm
04:39:45 <vincenz> dmwit: have you seen my technique?
04:39:52 <vincenz> > fun "\"" 1 :: Expr
04:39:53 <lambdabot>  " 1
04:39:54 <mux> mm, the SDL package uses #include explicitely_
04:40:04 <hpaste>  byorgey pasted "leksah build error" at http://hpaste.org/5656
04:40:21 <byorgey> dunno if anyone has any ideas re: that build error...
04:40:28 <vincenz> > fun "hey\13\10@bot" :: Expr
04:40:28 <lambdabot>  hey
04:40:28 <lambdabot>  @bot
04:41:05 <dmwit> Hey!
04:41:08 <faxathisia> > (fun $ intercalate (map chr [0x0d, 0x0a])$ map (concat.map (\(e,r) -> replicate e ' ' ++ replicate r '@'))[[(0,3)],[(3,2)],[(3,3)],[(2,2),(1,2)],[(0,2),(3,2)]]) :: Expr
04:41:09 <lambdabot>  @@@
04:41:09 <lambdabot>    @@
04:41:11 <lambdabot>    @@@
04:41:13 <lambdabot>   @@ @@
04:41:15 <lambdabot>  @@   @@
04:41:24 <byorgey> \o/
04:41:27 <dcoutts> byorgey: looks like you're building against Cabal-1.3.x whereas leksah is tested against Cabal-1.2.3.0
04:41:27 <dmwit> beautiful
04:41:28 <byorgey> faxathisia++
04:41:33 <faxathisia> ok I really will stop now :P
04:41:33 <vincenz> faxathisia++
04:41:40 <byorgey> dcoutts: ah, is that why?
04:41:44 <dcoutts> byorgey: so in particular the type of unlit changed
04:41:44 <ricky_clarkson> haha
04:41:50 <byorgey> dcoutts: aha
04:41:53 <dcoutts> byorgey: that's my guess
04:42:15 <byorgey> dcoutts: ok, that makes sense.  how do I force it to build against an older version of Cabal?  I have 1.2.3 installed
04:42:29 <dmwit> > fun "\13\10dmwit++" :: Expr -- ;-)
04:42:31 <lambdabot> dmwit++
04:42:31 <dcoutts> byorgey: send him a patch to set build-depends: Cabal >= 1.2 && < 1.3
04:42:49 <byorgey> dcoutts: ok, good call
04:43:12 <dcoutts> byorgey: that, or port it to the development version of Cabal :-)
04:43:40 <byorgey> dcoutts: heh =)
04:44:41 <gogonkt> any one knowed ByteString? How can I convert String "xxxx" to ByteString?
04:44:51 <dmwit> pack?
04:44:56 <dcoutts> @hoogle String -> ByteString
04:45:00 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
04:45:11 -Hard__Gay(n=NOOP@195-23-162-228.net.novis.pt)- You have 1 new message. Type /server mail to read.
04:45:23 --- mode: ChanServ set +o dcoutts
04:45:28 --- mode: ChanServ set +o vincenz
04:45:32 --- kick: Hard__Gay was kicked by vincenz (vincenz)
04:45:37 <byorgey> @remember faxathisia  > (fun $ intercalate (map chr [0x0d, 0x0a])$ map (concat.map (\(e,r) -> replicate e ' ' ++ replicate r '@'))[[(0,3)],[(3,2)],[(3,3)],[(2,2),(1,2)],[(0,2),(3,2)]]) :: Expr
04:45:37 <lambdabot> Done.
04:45:40 --- mode: ChanServ set -o dcoutts
04:45:48 --- mode: vincenz set -o vincenz
04:45:52 <dmwit> That's some speedy ops response.
04:45:58 <dmwit> Thanks, guys.
04:46:06 --- mode: ChanServ set +o vincenz
04:46:07 --- mode: vincenz set -b *!*daba@*
04:46:25 --- mode: vincenz set +b *!*@195-23-162-228.net.novis.pt
04:46:43 <vincenz> Cale: you should recycle from the top of the list (1)
04:46:46 <vincenz> Cale: those are the oldest
04:46:49 --- mode: vincenz set -o vininim
04:46:52 --- mode: vincenz set -o vincenz
04:47:01 <vincenz> vininim: curse you and tab-complete :)
04:47:02 <dmwit> Ah, tab-completion.
04:47:04 <faxathisia> hehe
04:47:08 <Cale> vincenz: You don't always want to remove bans though
04:47:08 <vincenz> every single time ;)
04:47:16 <Cale> Some old bans are still valid.
04:47:26 <ricky_clarkson> haha, @/server mail
04:47:41 <faxathisia> yeah somehow I fell for that :p
04:47:43 <Cale> For example, that ban on daba you just removed -- that guy's been here at least 2 or 3 times.
04:47:48 <vincenz> Cale: oh :|
04:48:12 <vincenz> Cale: you know
04:48:16 <vincenz> Cale: if we got lambdabot to do this
04:48:17 <Cale> Try to remove bans which look specific to a connection.
04:48:19 <vincenz> she could keep a longer list
04:48:22 <Cale> Yeah.
04:48:22 <ricky_clarkson> Put those bans in ChanServ.
04:48:22 <vincenz> and then do LRU on the 50
04:48:35 <opqdonut> wow, quite a lot of bans
04:48:37 <ricky_clarkson> Then you can keep the /bans empty.
04:48:51 <vincenz> Cale: ok
04:48:54 <vincenz> Cale: thanks for the tip
04:49:06 <Cale> yeah, we really should use chanserv :)
04:50:03 <vincenz> how od oyu do that?
04:50:06 <vincenz> chanserv has no ban command
04:50:13 <Cin> did you request for extended ban limits? (freeode gives you that on request)
04:50:13 * dmwit pauses to ponder the efficacy of bans in a largely anonymous community
04:50:48 <ricky_clarkson> vincenz: /msg chanserv help autorem
04:50:51 <vincenz> Cin: I'm requesting
04:50:51 <Cale> Cin: Oh, perhaps not.
04:50:55 <gogonkt> @hoogle IConv
04:50:55 <lambdabot> No matches found
04:50:56 <Cale> Cin: That's a good idea.
04:50:56 <vincenz> Cale: I'm asking
04:51:18 <gogonkt> @hoogle string -> bytestring
04:51:18 <lambdabot> Did you mean: String -> Bytestring
04:51:18 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
04:51:18 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
04:51:21 <dcoutts> gogonkt: there's an iconv package on hoogle
04:51:23 <Cale> ban limits are a pretty dumb idea anyway
04:51:32 <gogonkt> o
04:51:33 <vincenz> @users
04:51:33 <lambdabot> Maximum users seen in #haskell: 463, currently: 418 (90.3%), active: 16 (3.8%)
04:51:36 <dcoutts> gogonkt: erm hackage, not hoogle, sorry :-)
04:51:47 <Cale> They should use a trie or something nicely efficient to hold bans. :)
04:51:53 <gogonkt> @hackage iconv
04:51:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/iconv
04:51:59 <gogonkt> :)
04:51:59 <vincenz> bleh
04:52:02 <faxathisia> haha
04:52:06 <vincenz> 13:51 < spb> vincenz: are you sure you actually need it?
04:52:09 <gogonkt> dcoutts, Thz, :D
04:52:11 <vincenz> 13:51 < spb> most times a larger banlist isn't needed if you keep your banlist  maintained properly
04:52:37 <vincenz> Cale: how often do you recycle?
04:52:38 <vincenz> daily?
04:52:46 <Cale> Yeah.
04:52:48 <gogonkt> @hoogle String -> Bytestring
04:52:48 <lambdabot> No matches, try a more general search
04:52:56 <dmwit> Damn you, #haskell, another night wasted.
04:53:02 <dmwit> ?hoogle String -> ByteString
04:53:03 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
04:53:16 <gogonkt> @hoogle String -> ByteString
04:53:17 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
04:53:37 <Cin> Member's
04:54:14 <Cale> Apostrophe's ;)
04:54:29 <Cin> er. ignore that. accidentally touched the laptop's touchpad and it spewed some nonsense
04:54:49 <dmwit> An insult like that cannot be ignored.
04:55:48 <ricky_clarkson> Pie's
04:55:54 <Cin> ricky: shut up :P
04:57:47 <ricky_clarkson> In Wigan, you can't hear a penny drop.  Not because it's quiet, but because the locals don't let it hit the floor.
04:57:50 * ricky_clarkson is done :)
04:58:03 <fons> Hi all
04:59:25 <nayru> ricky_clarkson: shouldn't that be "not quiet"?
04:59:32 <vincenz> They're not being very cooperative
04:59:34 <ricky_clarkson> Yes.
04:59:37 <vincenz> Someone else care to come help and lobby?
04:59:47 * Cin thought the same but didn't want to encourage ricky
04:59:54 <nayru> Cin: heheh
05:00:06 <vincenz> 13:59 < beware> make a bot which removes the oldest bans if the banlist is
05:00:06 <vincenz>                 larger than N
05:00:06 <vincenz> 13:59 < beware> and re-adds bans as needed
05:00:06 <vincenz> 13:59 < vincenz> spb: some are longterm trolls
05:00:06 <vincenz> 13:59 < beware> FIFO
05:00:08 <vincenz> 13:59 < spb> if you really need such long-term bans they can be added as
05:00:11 <vincenz>              chanserv akicks
05:00:25 <vincenz> I told them our oldest ban is 23 days and we recycle daily
05:01:00 <vincenz> :|
05:01:38 <Cin> (is it some huge task to extend the ban list size?)
05:01:55 <vincenz> I don't know, but posing the question like that will unlikely help.
05:02:11 <Cin> hence my parentheses >_>
05:02:16 <jedbrown> @seen ac
05:02:17 <lambdabot> ac is in #haskell. I last heard ac speak 2h 51m 34s ago.
05:02:25 <vincenz> dcoutts: suggestions?
05:02:26 <vincenz> Cale: ?
05:02:47 <Cale> I wonder if there's a limit on chanserv autokicks.
05:03:10 <vincenz> Cale: asking
05:03:15 <dcoutts> vincenz: I'm not sure I understand the problem. So we have lots of bans, and using FIFO is not good enough?
05:03:26 <vincenz> dcoutts: it's getting tedious to do manually
05:03:38 <ricky_clarkson> It's funny that their answer is "make a bot".
05:03:38 <vincenz> 14:03 < vincenz> spb: is there a limit on chanserv autokicks?
05:03:41 <Cale> dcoutts: Some bans are more meaningful than others, so you don't really want a fifo.
05:03:44 <vincenz> 14:03 < spb> probably, but i've never managed to reach it if there is
05:04:03 <ricky_clarkson> Cale: Less meaningful ones should probably be removed by the banner.
05:04:15 <vincenz> this really begs for a bot
05:04:22 <vincenz> which is smart enough to recognize what is a single-timie ban
05:04:27 <vincenz> and what needs more firm measures
05:04:55 <vincenz> (based on history and occurence)
05:05:11 <vincenz> and potentially with house-keeping functions for really old stuff
05:05:41 <vincenz> the problem then is that if we stick this in lambdabot, we need a stable lambdabot, since otherwise we get state splicing between dons' lambdabot and cale's lambdabot
05:05:50 <Cin> perhaps the bot could store the ban list of an arbitrary length, and apply bans to the channel when x person joins the channel
05:06:26 <Cale> We probably shouldn't stick it in lambdabot either. We could make a far simpler bot for just managing bans.
05:06:35 <vincenz> Cale: my thoughts
05:06:38 <dcoutts> vincenz: so how does ChanServ's ban features work?
05:06:45 <vincenz> dcoutts: it's an autokick afaict
05:06:56 <vincenz> so we could use chanserv autokick
05:07:00 <vincenz> and then use ban for repeat-joiners
05:07:03 <vincenz> temporarily
05:07:29 <Cin> that sounds good
05:07:45 <dcoutts> vincenz: I see, so we have a 'cache' of 50 bans and we can use a bot to manage that cache
05:07:55 * vincenz nosd
05:08:00 <vincenz> something like that,yes
05:08:17 <vincenz> use a weighted LRU policy
05:08:20 <vincenz> based on LRU and repeats
05:08:28 <ttt--> hi, ghci says it cant find " Control/Monad/State.hs
05:08:28 <ttt--> " when loading a file. do i need to pass the path when starting it up?
05:08:59 <dcoutts> ttt--: you can use -isrc for example if the real code was all under src/ dir
05:09:04 <vincenz> though if we give the bot ops, then this bot can also do the autokicking
05:09:13 <vincenz> and it could be smart enough to detect repetjoins
05:09:15 <Cin> vincenz: ah, true
05:09:18 <vincenz> if it has to autokick a ew times
05:09:20 <vincenz> and then ban
05:09:24 <ttt--> i dont really know where the code is, are those standard libraries?
05:10:04 <vincenz> Cale: the advantage of using lambdabot is that it alrady has the logic for 'bot-admin' users which are required to be registered
05:10:09 <Cale> ttt--: Control.Monad.State is in the mtl
05:10:14 <vincenz> Cale: rename yourself to Cale_
05:10:16 <Cin> vincenz: what happens if the bot has downtime?
05:10:22 <gogonkt> @hoogle String -> Lazy.ByteString
05:10:23 <ac> so if I say something like "mapM_ (putStrLn . show) [0..10000000]" is the list construction optimized away entirely?
05:10:28 <lambdabot> No matches, try a more general search
05:10:32 <vincenz> Cale: I want to test something
05:10:35 <Cale> ttt--: If you don't have that package for whatever reason, you can get it from hackage
05:10:43 <Cale> @msg #haskell hello
05:10:43 <lambdabot> hello
05:10:46 <Cale> crap
05:10:50 <mux> ac: not answering your question, but putStrLn . show == print
05:11:00 <ac> mux: damnit, I always forget about print
05:11:05 <Cale_> I should probably protect my nick better with nickserv :)
05:11:08 <Cin> lambdabot doesn't even need Cale to ebe registered?
05:11:10 <vincenz> Cale_: that's a security hole
05:11:12 <Cin> heh, yeah
05:11:37 <vincenz> dons: ping
05:11:52 <jedbrown> ac: when you get a chance, try darcs get http://59A2.org/code/carray
05:11:52 <ttt--> Cale: so i need to do something like  ghci -i/usr/lib/mtl-1.0.1/ghc-6.6.1/   ?
05:11:53 <vincenz> Cale: well if hte bot is down, we do it manually
05:12:02 <vincenz> Cale: and retroactively add @ban's
05:12:07 <ac> jedbrown: thanks, I will do that today or tomorrow
05:12:11 <ricky_clarkson> So..
05:12:21 <shapr> @msg #haskell hello
05:12:21 <lambdabot> hello
05:12:34 <ac> jedbrown: er, now
05:12:35 <ttt--> oh, it worked. thanks
05:12:38 <Cale> ttt--: Could you just do  ghc-pkg list mtl
05:12:41 <gogonkt> Oh no,IConv sucks! :(
05:12:43 <Cale> and tell me what it says
05:12:56 <dcoutts> gogonkt: hmm?
05:12:57 <jedbrown> ac: I need to get it on hackage, but I'm currently confused getting an account working.
05:13:02 <Cale> ttt--: the -i flag worked?
05:13:02 <gogonkt> How to String -> Lazy.ByteString
05:13:08 <Cale> gogonkt: pack
05:13:16 <vincenz> ricky_clarkson: similar issues with @messages
05:13:17 <ttt--> the file with the monad import loaded
05:13:18 <gogonkt> IConv need it
05:13:18 <ac> jedbrown: I'm hoping to get my own code on hackage in a week or so, so let me know how you get unconfused
05:13:21 <dcoutts> gogonkt: Data.ByteString.Lazy.Char8.pack
05:13:22 <ricky_clarkson> vincenz: hah
05:13:38 <gogonkt> oh,try again
05:13:55 <ac> jedbrown: my lib will probably depend on yorus
05:14:00 <dcoutts> gogonkt: bytestring comes in two flavours strict and lazy and both have Word8 and Char8 apis
05:14:23 <vincenz> Cale: well that's a motivating reason not to put it in lambdabot ;)
05:15:33 <ac> so is small/basic control with lists optimized well, or (if I'm interested in experimenting with runtime speed) should I write iterative functions?
05:15:39 <gogonkt> Cale, dcoutts :)
05:16:41 <oerjan> ac: if it isn't optimized well it's a bug and you should report it :)
05:17:30 <gogonkt> haste
05:17:35 <gogonkt> @haste
05:17:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:19:18 <hpaste>  gogonkt pasted "IConv sucks" at http://hpaste.org/5657
05:19:19 <ac> oerjan: specifically I'm writing code to compare generating images as lists and images as StoreableArrays. Should I be concerned about writing something like "map (writeArray ...) [0 .. sizeX]"?
05:19:55 <gogonkt> dcoutts, see hpaste
05:21:00 <Cale> gogonkt: Perhaps you meant: (L.pack "") ?
05:21:05 <dcoutts> gogonkt: look at your bracketing
05:21:12 <ac> or even "map (writeArray ...) [(x, y) | x <- [0 .. sizeX], y <- [0 .. sizeY]]". How would that compare to a Scheme style nested loop?
05:21:24 <Cale> ac: mapM_ ?
05:21:28 <ac> Cale: yeah
05:21:35 <dcoutts> gogonkt: and be careful about telling people that their packages suck, some people will not react so well to it ;-)
05:21:35 <Cale> I don't think that should be a problem.
05:21:38 <gogonkt> ....-_-,sorry
05:21:59 * dcoutts wonders if gogonkt noticed who wrote the iconv package
05:22:32 <gogonkt> dcoutts, because it spend me 2 night,(maybe I sucks)
05:22:33 <therp> my packages suck!
05:22:36 <gogonkt> haha
05:23:10 <gogonkt> dcoutts, Who wrote it?
05:23:36 <Cale> Author	Duncan Coutts <duncan@haskell.org>
05:23:56 <gogonkt> duncan?
05:24:09 <gogonkt> dcoutts, => duncan?
05:24:13 <Cale> yes :)
05:24:25 <gogonkt> -_-,oho.......
05:24:38 * dcoutts grins
05:24:38 <therp> @karma dcoutts
05:24:39 <lambdabot> dcoutts has a karma of 45
05:24:44 <therp> I think he can take it :
05:24:46 <therp> :)
05:24:50 <gogonkt> dcoutts, duncan,nice to met you :D
05:24:58 <dcoutts> gogonkt: likewise :-)
05:25:56 <gogonkt> newbie is sucks(Me -> newbie),lol
05:25:58 <ToRA> ac: you can use range instead of the double list comp if you want
05:26:02 <ToRA> > range ((0,0), (2,2))
05:26:06 <ac> what're the practical differences between an "MArray a IO" and a "MArray a ST"?
05:26:11 <earthy> gogonkt, you might as well have said ghc sucks. :P
05:26:18 <lambdabot>  thread killed
05:26:21 <ac> ToRA: good point
05:26:28 <gogonkt> :P
05:26:31 <Cale> > range ((0,0), (2,2))
05:26:32 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
05:26:42 <earthy> (the type error message might've been nicer...)
05:26:44 <ac> @src range
05:26:44 <lambdabot> Source not found. There are some things that I just don't know.
05:27:16 <ac> I bet it's implemented with a list comprehension
05:27:36 <Cale> Probably.
05:28:32 <ac> oh, guess if I'm using StoreableArray I have to use IO
05:29:12 <jedbrown> ac: Do you even need to use a mutable array?
05:29:26 <ac> jedbrown: no. As soon as I get this to work I'm going to test your lib
05:30:15 <oerjan> ac: http://haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id413287
05:30:17 <lambdabot> http://tinyurl.com/2yerzt
05:30:23 <ac> just out of curiosity, how can a "newArray_ :: MArray a ST" produce undefined values? It would make sense with IO, but not with ST
05:31:36 <jedbrown> ac: If you allocate memory, but don't initialize it, then you get whatever was there before.
05:32:23 <oerjan> jedbrown: i strongly doubt ghc allows you not to initialize it _at_all_
05:32:49 <oerjan> but it initializes to undefined by default, if you don't supply anything else
05:32:54 <jedbrown> ac: Strictly speaking, it is doing IO, but since they are undefined, it is your obligation to not touch it.
05:33:16 <ac> jedbrown: so shouldn't that require an IO type? Or is ST also special in that way?
05:34:19 <oerjan> ac: undefined is _not_ the same as undefined behavior in C.  it is a very specific value, bottom
05:34:40 <ac> ahhh, that makes sense now
05:35:54 <dcoutts> ndm: want to stick up for my unsafePerformIO library proposal?
05:36:42 <ndm> dcoutts: of course
05:36:52 <dcoutts> ndm: hmm, Yitzchak Gale asks for a compiler independent semantics of unsafeInlinePerformIO. :-)
05:37:05 <ndm> dcoutts, i think you've totally missed malcolmw's point on #239
05:37:12 <oerjan> ac: hm actually reading the newArray_ haddock, it may not be quite that simple.
05:37:27 <oerjan> "In a monadic context in which operations must be deterministic (e.g. the ST monad), the array elements are initialised to a fixed but undefined value, such as zero."
05:37:49 <dcoutts> ndm: I do see that there is more to it than just rejecting duplicate uploads
05:37:53 <ttt--> is it normal chapter 10 is empty in "yet another haskell tutorial" ?
05:38:10 <dcoutts> ndm: btw, why do you want to break distro packages by uploading duplicate packages? why not just upload a new version?
05:38:41 * dcoutts asks ndm a deliberately loaded question
05:38:42 <oerjan> although if you are using the boxed arrays, the ordinary undefined is the only value that could reasonably be chosen.  i assume zero etc. is allowed for unboxed arrays for which ordinary undefined is not available.
05:39:00 <Cale> ttt--: Yeah, YAHT has planned sections which aren't filled in. You might check the wikified version of it to see if someone filled it in (if you're reading the PDF)
05:39:13 <malcolmw> dcoutts: The main reason for uploading a duplicate package is that the pre-upload package validation does not work, so the only way to find if a package is incomplete is to upload it
05:39:14 <ttt--> i was, thanks
05:39:34 <jedbrown> oerjan: Yes, and the IO implementations use stToIO, probably to simplify the implementation rather than because it's strictly necessary.
05:39:43 <ndm> dcoutts, i don't use a distro so want everyone else to suffer :)
05:39:48 <dcoutts> malcolmw: I don't follow, if the validation fails the package is rejected.
05:39:53 <dcoutts> ndm: ;-)
05:40:06 <ndm> dcoutts, more so if i do an upload, and 10 seconds later realise if forgot to shove the readme in its just easier to reupload quickly
05:40:09 <malcolmw> dcoutts: its not that the validation fails, it is that it fails to return an answer
05:40:14 <dcoutts> malcolmw: if the package makes it through but still does not work then upload x+0.0.0.1
05:40:33 <dcoutts> malcolmw: huh?
05:40:35 <jedbrown> oerjan: In the IO context, it seems reasonable to allocate memory without initializing it to a set `undefined' value.
05:40:35 <ttt--> they are empty in the wiki too :)
05:40:44 <ndm> dcoutts, its entirely separate from the issue of rejecting duplicate uploads (on which i don't mind too much), its rejecting other peoples uploads of my package
05:41:26 <gogonkt> dcoutts, sorry,what's wrong in >putStr (convert "UTF-8" "GBK" (L.pack ""))<,-_-b.....
05:41:57 <malcolmw> dcoutts: on several occasions, I have waited 20mins for pre-upload validation to give an answer, then just uploaded anyway (which only took a few seconds)
05:42:03 <dcoutts> gogonkt: the input string is not UTF-8 that's what.
05:42:26 * shepheb would really want to read Chapter 10, too
05:42:52 <gogonkt> dcoutts, my souce code is U8
05:43:12 <dcoutts> malcolmw: upload validation is synchronous and pretty speedy as far as I understand it. It does not build the package, it just unpacks it and does a few cheap tests.
05:43:43 <oerjan> jedbrown: except that leads to memory unsafety, and it's newArray_ not unsafeNewArray_ ...
05:43:51 <malcolmw> dcoutts: well it rarely seems to do anything at all, from here
05:43:52 <dcoutts> gogonkt: String is a sequence of unicode code points, it is not UTF-8. If you want to convert a String to UTF-8 encoded data you'll have to use a conversion function.
05:44:11 <dcoutts> malcolmw: you mean the web ui or the cabal upload command line prog?
05:44:19 <malcolmw> dcoutts: web ui
05:44:25 <mauke> dcoutts: doesn't that depend on whether the compiler understands utf-8 or not?
05:44:28 <dcoutts> malcolmw: you mean it just spins and spins and never returns?
05:44:35 <malcolmw> dcoutts: yep
05:44:42 <shepheb> particularly concurrency. is there a good introduction to the various sorts of Haskell concurrency? the wikibook is minimal on it.
05:45:04 <dcoutts> malcolmw: well that's not by design :-) and the ordinary upload does exactly the same tests, it just doesn't reject on warnings.
05:45:08 <mauke> shepheb: the main function is forkIO
05:45:27 <malcolmw> dcoutts: but the point of #239 is entirely unrelated to duplicate version uploads
05:45:28 <dcoutts> mauke: yes
05:46:20 <oerjan> jedbrown: btw unsafeNewArray_ _does_ exist, it is just not listed in the haddock so as not to encourage it...
05:46:29 <malcolmw> dcoutts: the issue is that there is no check that the person claimed to be the maintainer in the cabal file is the person who has uploaded it
05:46:53 <dcoutts> malcolmw: right, but it's not clear that we want to restrict it that far. I'm writing a response.
05:47:01 <malcolmw> dcoutts: so there are all kinds of opportunities for spoofing
05:47:49 <malcolmw> dcoutts: sure, it is great if the maintainer forgets to upload (like I often do...) then someone else does it instead.  But it would be nice to know who it was.
05:47:50 <shepheb> mauke: yeah, the wikibook is helping. I read "Use those extra cores and beat C today" a while ago, too.
05:48:17 <dcoutts> malcolmw: sure, tracking who did the upload is easy, we have that info and can put it on the package page.
05:48:53 <ndm> dcoutts, we do want to restrict it that far
05:48:55 <malcolmw> dcoutts: I did think it would be easy to do
05:49:12 <ndm> malcolmw: that person can email you, and tell you to do it
05:50:04 <malcolmw> ndm: I suppose forcing the uploader to change the cabal file to include their validated email address is OK as a policy
05:51:17 * shepheb would have thought reverse would be a "good consumer" wrt list fusion
05:51:20 <dcoutts> ndm: http://hackage.haskell.org/trac/hackage/ticket/239#comment:4
05:51:22 <lambdabot> Title: #239 (security hole: anyone can replace a package) - Hackage - Trac
05:51:41 <Philippa_> shepheb: it's an awful one
05:51:50 <Philippa_> you have to consume the whole list before yielding anything
05:52:35 <jedbrown> However, unsafeNewArray_ = newArray_ for the IO instances.  But unsafeNewArray_ should be able to just allocate memory and not initialize it, (in the unboxed case).
05:52:36 <dcoutts> ndm: since it's open source we can and do patch your code anyway, it's essential.
05:52:39 <ndm> Philippa_: good consumer, not good producer - which seems reasonable
05:52:44 <syntaxfree> well, finally.
05:52:54 <ndm> dcoutts, but i don't want you to patch my code and upload it for me - you can always email me a patch!
05:52:59 <syntaxfree> I'd been using a broken self-compiled 6.6 forever.
05:53:12 <syntaxfree> this is how broken it was: I couldn't use the backspace key in ghci.
05:53:23 <syntaxfree> let alone up arrow for history.
05:53:43 <shepheb> Philippa_: I know reverse is strict in general, but it seems like it's essentially reversing a stack, and could be a good consumer that just accumulated a reversed list and returned it.
05:53:48 <dcoutts> ndm: linux distros can and do always add additional patches, and because it's the right thing to do they also send the patches upstream to be considered
05:54:06 <dcoutts> ndm: if you want people to be assured that your package is exactly how you released it then you want to sign it.
05:54:20 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/214
05:54:22 <lambdabot> Title: #214 (Package security) - Hackage - Trac
05:54:33 <ndm> dcoutts, yes, but the linux distros are a group of people who have decided to maintain the package and been appointed to it - not random people
05:54:50 <syntaxfree> and then when I got the new laptop and the mini became a file server, I was basically ssh-ing to the broken version when at home, and had nothing to work with while at the road, because I'd had hit enough roadblocks trying to compile ghc for leopard that it hit my frustration threshold.
05:54:59 <dcoutts> ndm: true, I agree it's too wide at the moment but it's not right to narrow it to 1.
05:55:15 <syntaxfree> maybe I can resume doing something haskellish. I am studying Jacobs' manual on coalgebras for real.
05:55:32 <ndm> dcoutts, yes, in general i am happy for you to upload my package, on the basis i know you wouldn't without asking - but thats not the case for everyone on hackage
05:56:10 <syntaxfree> anyway, I'd like to applaud seor Chakravarty for the effort.
05:56:43 <dcoutts> ndm: I think the best long term solution is to do like we do for code.haskell.org, let the project members add additional people to the set with write access, but with recourse to admins when packages need to change maintainer.
05:56:58 <ndm> dcoutts, sounds perfect :)
05:57:11 <dcoutts> ndm: but someone needs to implement it :-)
05:57:26 <syntaxfree> s/at the road/on the road/   (and I stop my mindless chatter)
05:57:34 <ndm> dcoutts, in the short term, it would be nice if the person who keeps uploading everyone elses packages without asking first stopped :)
05:57:54 <jedbrown> oerjan: Oops, I misread.  In IO, newArray_ = unsafeNewArray_ so memory is not initialized in this case, as I had thought initially.
05:57:56 <dcoutts> ndm: who is that and what was uploaded? we can terminate accounts if necessary.
05:58:40 <dcoutts> though just telling them should be enough
05:58:43 <gogonkt> dcoutts, is I need use U8-String convert it to U8?
05:58:59 <ndm> dcoutts, Gwern Branwen and look at last weeks HWN
05:59:10 <shepheb> @src scanl
05:59:10 <lambdabot> scanl f q ls = q : case ls of
05:59:10 <lambdabot>     []   -> []
05:59:10 <lambdabot>     x:xs -> scanl f (f q x) xs
05:59:20 <ndm> dcoutts, of the hackage recently uploaded thingy
05:59:39 <dcoutts> ndm: and have you talked to gwern about it?
05:59:44 <oerjan> jedbrown: well the comments in the MArray class shows this was the intention at least
05:59:57 <ndm> dcoutts, nope, he hasn't done it to one of my projects yet (as far as i can tell)
06:00:00 <shepheb> also, scanl is not a good producer? seems that it could be. although I realize that list is of the functions that /are/, not the ones that /could be/.
06:00:12 <ndm> dcoutts, but partly its hard for me to tell if he has or not, which is the issue :)
06:00:43 <dcoutts> ndm: the hackage upload rss feed is easy to follow, it's just duplicates we need to reject.
06:01:28 <ndm> dcoutts, i don't want to have to police my packages, i just want them to sit tight on their own
06:01:52 <malcolmw> dcoutts: where is the Hackage RSS feed advertised?  I can't see it
06:02:39 <dcoutts> malcolmw: hmm, it's not linked, but change .html for .rss
06:03:40 <dcoutts> @seen gwern
06:03:40 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 9h 51s ago.
06:04:09 <malcolmw> dcoutts: on which URL?
06:04:13 <gogonkt> dcoutts, haha,I got it!IConv is wonderful~~!
06:04:27 <dcoutts> malcolmw: the what's new/ recent
06:04:49 <dcoutts> http://hackage.haskell.org/packages/archive/recent.rss
06:06:23 <malcolmw> dcoutts: date of upload would be another useful piece of information that is currently missing from the package webpages
06:07:02 <dcoutts> malcolmw: yep, that's what Ross said "Putting the uploader and upload date on the package page is also in the works."
06:07:07 <gogonkt> @hackage UTF8-String
06:07:07 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/UTF8-String
06:07:48 <scook0> @hackage utf8-string
06:07:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
06:08:45 <malcolmw> dcoutts: the RSS feed only has the last 20 uploads, which only covers a couple of days
06:09:16 <dcoutts> malcolmw: yes, you might want to use an rss feed reader that caches more than that.
06:09:28 <dcoutts> malcolmw: separately there is a complete log going back to day 0
06:09:40 <malcolmw> dcoutts: accessible where?
06:10:22 <BMeph> Heh-heh, we need a lambdacat for Data.Fixed - "i can HasResolution?" ;)
06:10:39 <syntaxfree> Haz. Not Has.
06:11:53 <Cin> hz not haz
06:12:28 <dcoutts> malcolmw: http://hackage.haskell.org/packages/archive/log
06:13:13 <malcolmw> dcoutts: excellent. thank you
06:14:25 <gogonkt> Why need "(convert "UTF-8" "GBK" (L.pack (UTF.encodeString "")))",hoho, -_-b....
06:14:41 <malcolmw> dcoutts: it is clear that there are a _lot_ of duplicate version uploads, within ten minutes of each other!
06:17:47 <dcoutts> malcolmw: aye, thats what I'd expect that most are correcting a trivial error
06:18:35 <dcoutts> malcolmw: we could allow some time limit or some download limit, if it's bee more than 1 hour or 10 people have downloaded it then you can change it, for example.
06:19:17 <dcoutts> malcolmw: but it seems to me that there's no harm in requiring a +0.0.0.1 version increment
06:19:44 <dcoutts> malcolmw: especially if we have some system in future for testing before upload
06:19:47 <malcolmw> dcoutts: well, there are people like me who don't agree with the 4-place versioning policy
06:20:10 <dcoutts> malcolmw: then they'd better make sure they're happy with their releases :-)
06:20:37 <malcolmw> dcoutts: or we will avoid hackage and release elsewhere
06:21:00 <syntaxfree> such are the ways of the free market.
06:21:14 * syntaxfree goes crazy trying to write scanl in terms of foldl and blames Topamax for his stupidity.
06:21:28 <Igloo> dcoutts: If <= 0 people have downloaded it sounds good to me
06:21:51 <andun> Igloo: are you planning to make mime-string work on GHC 6.8 (with iconv 0.4) anytime soon? or do you want patches? :-)
06:21:52 <dcoutts> malcolmw: right, there's a balance to be struck, we can demand some level of sanity because we provide a service to a large number of users.
06:21:58 <Igloo> dcoutts: and it's the same person doing the upload
06:22:00 <malcolmw> Igloo: how do you tell whether it was downloaded by a person, or a robot?
06:22:07 <syntaxfree> @remember Igloo dcoutts: If <= 0 people have downloaded it sounds good to me
06:22:07 <lambdabot> Good to know.
06:22:25 <mauke> .oO( what if it was downloaded once but uploaded twice? )
06:22:43 <Igloo> malcolmw: Robots as in google etc? They don't download tarballs do they?
06:22:54 <Igloo> I would count a robot as a person for this purpose, anyway
06:23:05 <syntaxfree> > @let igloo = flip igloo
06:23:05 <lambdabot>  Parse error at "@let" (column 1)
06:23:07 <malcolmw> Igloo: looking for code to index, yes I think google does
06:23:14 <dcoutts> Igloo: but soon cabal-install --build-bot will start watching the hackage rss feed and building everything :-)
06:23:28 <Igloo> andun: I wasn't planning on it, no, but patches would be great!
06:23:53 <dcoutts> malcolmw: btw, we're not enforcing any versioning policy
06:23:54 <Igloo> If a robot downloads it you don't know that it's not caching it for people to download later
06:24:04 <Igloo> Ah, yes, I'd forgotten about code.google
06:24:30 <syntaxfree> Igloo: you're talking about non-sentient robots anyway.
06:25:00 <dcoutts> malcolmw: the ideal seems to me that you could upload to a temporary testing collection to get a release tested and have it migrate to the main collection if it passes.
06:25:23 <nayru> forward = map (map (/alpha (f s))) (f s)
06:25:32 <malcolmw> dcoutts: Igloo: how about if new uploads went into a playpen, not visible to the rest of the world for another 12 hours.  would that satisfy the robot/silly mistake problem?
06:25:46 <dcoutts> malcolmw: that's rather like what I'm suggesting
06:25:47 * dcoutts goes for a late lunch
06:26:12 <nominolo> dcoutts, malcolmw wouldn't it be better to announce security first internally?
06:26:20 <nominolo> *security bugs
06:26:44 <nominolo> to give people a chance to fix them
06:26:45 <Igloo> malcolmw: Is that different to not uploading it for another 12 hours?
06:26:57 <gogonkt> @hoogle pringf ByteString
06:26:58 <lambdabot> Did you mean: Pringf ByteString
06:26:58 <lambdabot> Prelude.undefined :: a
06:26:58 <lambdabot> Prelude.id :: a -> a
06:27:18 <ac> how do I profile my code?
06:27:21 <nayru> how can i rewrite that double map using concat?
06:27:21 <malcolmw> nominolo: hmm, good idea.  but in the open source world, there is no "internal" - it is all public?
06:27:21 <gogonkt> @hoogle Pringf ByteString
06:27:21 <lambdabot> No matches, try a more general search
06:27:45 <shepheb> are there no solutions for Understanding Arrows on the wikibook? apparently so. I have my solutions, but am only moderately convinced they're correct. If I edit them in, will someone check them?
06:27:49 <nominolo> malcolmw: the SVN guy who wrote that OpenSource book suggested to do it thisk way
06:28:19 <malcolmw> Igloo: we all know that the best way to discover a silly mistake is to release it to the world, not to keep it to yourself.
06:28:25 <nominolo> malcolmw: you should have gotten one as part of GSoC
06:28:34 <syntaxfree> GSoC?
06:28:48 <nominolo> google summer of code
06:28:50 <malcolmw> nominolo: books only went to students, not mentors
06:29:00 <Igloo> malcolmw: Yes, but your way you will just realise the silly mistake 12 hours later  :-)
06:29:01 <nominolo> malcolmw: oh, i see
06:29:06 <syntaxfree> oh boy. I wonder whatever happened to the band of hackers I assembled together and then abandoned.
06:29:24 <syntaxfree> I wonder if they continued on their own. Not that I was a valuable asset or a good leader.
06:29:25 <Igloo> And the lag is bound to cause frustration and confusion
06:29:37 <syntaxfree> I *was* a good /cheer/leader.
06:29:39 <hpaste>  Orchid pasted "Type system is stopping me" at http://hpaste.org/5658
06:29:48 <xif> Hi. I'm reading "Thinking in Erlang", but was sent here from #erlang. The text says there that "foldl is preferred to foldr because foldl is tail-recursive". But assuming the action on the current value does not carry side effects, it should be trivial to implement foldr as foldl on the reverse list, no?
06:29:52 <malcolmw> Igloo: good point
06:29:55 <nominolo> malcolmw: the point was to report them to the core team first or to a private mailing list and then release them simulatanously with a fix
06:30:29 <kpreid> xif: yes, but this is undesirable for laziness
06:30:39 <kpreid> and termination...
06:30:41 <kpreid> for example:
06:30:46 <kpreid> > reverse [1..]
06:30:57 <nominolo> xif: yes
06:31:01 <lambdabot>  thread killed
06:31:04 <kpreid> you can't reverse an infinite list
06:31:11 <syntaxfree> xif: well, you can write a contrivedFoldr that is mathematically equivalent to foldr, but performance issues are another chapter entirely.
06:31:20 <nominolo> xif: but foldl is only faster for strict languages (which erlang is)
06:31:30 <RayNbow> > const 0 $ reverse [1..]
06:31:30 <malcolmw> nominolo: what counts as a private list though? cabal-devel ?
06:31:30 <lambdabot>  0
06:31:31 <oerjan> xif: laziness makes foldr much more useful in haskell
06:31:39 <RayNbow> wow, lambdabot's fast :p
06:31:42 <kpreid> xif: or a list which has got bottom just beyond the part you want to look at
06:31:54 <nominolo> malcolmw: we'd need to arrange a special list for that
06:32:11 <nominolo> malcolmw: and then have some trusted core team
06:32:15 <mauke> who is Orchid?
06:32:25 <malcolmw> nominolo: the Cabal-cabal...
06:32:27 <nominolo> it's a what
06:32:33 <nominolo> malcolmw: exactly!
06:32:49 <xif> nominolo: what's a "strict" language?
06:33:04 <xif> oerjan: really?  how so?
06:33:11 <nominolo> xif: one that arguments it's arguments before passing them to the function
06:33:20 <nayru> i am using map on a list of lists, such as [[1,2],[3,4]] like this: forward = map (map (/alpha (f s))) (f s) ... can i get rid of one map by using concat? how?
06:33:23 <ricky_clarkson> s/arguments/evaluates/
06:33:28 <mauke> s/it's/its/
06:33:37 <oerjan> xif: because it is possible to produce part of the result without looking at all of the list
06:33:38 <faxathisia> concat [[1,2],[3,4]] = [1,2,3,4]
06:33:38 <nominolo> meh
06:33:42 <syntaxfree> xif: a strict language evaluates its arguments as it encounters them. A lazy language evaluates them as needed.
06:33:43 <xif> nominolo: oh, and Haskell doesn't?  interesting.
06:33:55 <syntaxfree> xif: for example:
06:33:55 <nominolo> mauke: i usually get those right ;)
06:34:01 <ricky_clarkson> xif: Are you familiar with C or Java?
06:34:03 <syntaxfree> > foldr (+) [1..]
06:34:04 <lambdabot>   add an instance declaration for (Num [t])
06:34:12 <syntaxfree> > foldr (+) 0 [1..]
06:34:13 <lambdabot>  Exception: stack overflow
06:34:15 <xif> ricky_clarkson: yes.
06:34:18 <syntaxfree> dies.
06:34:20 <ac> nayru: concat would flatten the list
06:34:22 <ricky_clarkson> xif: Consider writing a function/method in those languages that does the same thing as && does.
06:34:32 <syntaxfree> > scanl (+) 0 [1..]
06:34:33 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
06:34:42 <ricky_clarkson> ..you know, the short-circuiting.
06:35:09 <syntaxfree> ricky_clarkson's explanation is better than mine. As usual, someone does it better.
06:35:13 <xif> ricky_clarkson: it's a problem, because I can't ensure that the right hand won't be evaluated.
06:35:31 <xif> so I see your point.
06:35:42 <nominolo> @wiki Lazy_evaluation
06:35:42 <lambdabot> http://www.haskell.org/haskellwiki/Lazy_evaluation
06:35:49 <ricky_clarkson> xif: Well, you can, but it's awkward in both those languages.
06:35:49 <ac> @pl \x -> x . x
06:35:49 <lambdabot> join (.)
06:36:18 <ricky_clarkson> xif: Scala is strict like Java and C, but lets you add an annotation to say "this parameter is lazy".
06:36:36 <ac> > join (.) map (+1) [[1,2],[3,4]]
06:36:37 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
06:36:37 <lambdabot>       Expected...
06:36:42 <ricky_clarkson> So you'd write def shortCircuitingAnd(x: Boolean,lazy y: Boolean) or something.
06:36:50 <ricky_clarkson> In Haskell, everything's lazy.
06:37:12 <syntaxfree> except when declared strict.
06:37:15 <nominolo> unless you make it strict :)
06:37:27 <ricky_clarkson> Sorry, I only use Haskell as a posh calculator.
06:37:46 <xif> hehe
06:38:01 <syntaxfree> @remember ricky_clarkson Sorry, I only use Haskell as a posh calculator.
06:38:01 <lambdabot> Good to know.
06:38:18 <ac> @pl \x -> x x
06:38:19 <lambdabot> join id
06:38:27 <ac> > join id map (+1) [[1,2],[3,4]]
06:38:27 <syntaxfree> I'm not totally useless to the Haskell community. I'm the resident gossip journalist.
06:38:29 <lambdabot>      Occurs check: cannot construct the infinite type:
06:38:29 <lambdabot>       a = a -> t1 -> t...
06:38:47 <ac> erhg
06:38:47 <syntaxfree> where celeb rag = quote bot.
06:38:50 <nominolo> @quote syntaxninja
06:38:51 <lambdabot> SyntaxNinja says: * SyntaxNinja does the type-checking dance ;)
06:38:59 <nominolo> @quote syntaxfree
06:39:00 <lambdabot> syntaxfree says: I love lists of functions. They give me this warm mathematical feeling.
06:39:03 <Vq^> a small terminology question...
06:39:10 <Vq^> if i have a function  [m a] -> m [a]
06:39:24 <syntaxfree> @quote nominolo
06:39:24 <lambdabot> No quotes match. :(
06:39:31 <nominolo> you call it mapM
06:39:31 <xif> So, basically, foldr would be as efficient as foldl in Haskell, because lazyness makes it tail-recurse anyways?
06:39:33 <Vq^> do i say that it is semantically equivalent to sequence or is it syntactically equivalent?
06:39:45 <nominolo> xif: sort of
06:39:53 <ac> Vq^: I would say semantically
06:40:00 <mauke> if it's syntactically equivalent, it uses the same source code
06:40:02 <syntaxfree> xif: actually, foldl isn't very efficient in Haskell; often people use its strict equivalent foldl_
06:40:27 <ac> Vq^: but it would also have to be syntactically equivalent, unless you were doing something weird
06:40:27 <nominolo> xif: there is a strict variant of foldl, called foldl'
06:40:37 <syntaxfree> oops. foldl'. what is foldl_  again?
06:40:47 <xif> syntaxfree: it makes sense that both foldl and foldr would have equivalent efficiency in Haskell, from what you guys describe.
06:41:03 <nominolo> @hoogle foldl_
06:41:03 <Vq^> ac: well, the main difference is that it executes in parallel
06:41:04 <lambdabot> No matches found
06:41:11 <Vq^> ac: so the result should be the same
06:41:16 <nominolo> @hoogle foldM_
06:41:17 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
06:41:37 <ricky_clarkson> @quote ricky_clarkson
06:41:38 <lambdabot> ricky_clarkson says: Is Haskell an interface between programming languages and academics?
06:41:40 <syntaxfree> xif: well, we basically make everything complicated so we look as cool as the quantum physicists.
06:41:46 <ac> Vq^: ah, so then it's computationally different, but semantically the same
06:41:50 <nominolo> Vq^: no, since parallel + side effects = doom
06:41:53 <xif> syntaxfree: gotcha.
06:41:59 <Vq^> ac: exactly
06:42:05 <xif> what's parallel?
06:42:06 <syntaxfree> xif: we even got away with saying that darcs was specced using quantum mechanics, which makes no sense at all.
06:42:26 * xif was specced using String theory!
06:42:26 <ricky_clarkson> Did darcs solve its performance problems eventually?
06:42:31 <ac> :t join
06:42:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:42:40 <Vq^> nominolo: this is a separate function no more or less dangerous than forkIO
06:42:45 <nominolo> xif: parallelism
06:42:46 <xif> .o( maybe in a parallel universe! )
06:43:02 <ricky_clarkson> I stopped using darcs when I moved to Windows and couldn't get a version running.
06:43:05 <xif> nominolo: can I do stuff like transparently scale across processors / machines with haskell?
06:43:34 <nominolo> Vq^: yeah, but then it isn't semantically equivalent to sequence
06:43:52 <xif> ricky_clarkson: I used darcs on windows about 2 years ago. was nice, except there's not much reason to use it nowadays with hg, bzr and git out there.
06:44:02 <Vq^> nominolo: it's neither then i take it
06:44:03 <nominolo> Vq^: it is equivalent if the monad doesn't have visible side effects
06:44:16 <nominolo> *observable
06:44:17 <syntaxfree> I tried using darcs once to version control my novel, but I find it more practical to either use filename numbering on textfiles or Microsoft Word version control for workplace purposes.
06:44:18 <Vq^> nominolo: it's IO only
06:44:35 <nominolo> the i wouldn't call it semantically equivalent
06:44:50 <nominolo> since it only is in a few special cases
06:44:59 <Vq^> semantically similar maybe? :)
06:45:00 <syntaxfree> I still write my literary stuff on textfiles basically because I don't want the distraction of formatting or the risk of proprietary formats going away.
06:45:17 <nominolo> Vq^: nah.  just describe what it does
06:45:28 <shepheb> @wiki GHC/Data_Parallel_Haskell
06:45:29 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
06:45:34 <nominolo> Vq^: users can figure out the rest
06:45:57 <shepheb> xif: see that wiki link
06:46:02 <syntaxfree> Microsoft actually has the version control thing nailed pretty well. Stuff gets mailed between co-workers  and every change is annotated with the author's name and can be easily visualized in a number of ways.
06:46:06 <syntaxfree> No quantum mechanics involved.
06:46:26 <syntaxfree> OTOH, I wish they'd fix the frelling equation editor.
06:46:42 <masklinn> syntaxfree, you can do that with any centralized VCS though
06:47:37 <syntaxfree> masklinn: yes, and the time expense of retraining PhDs who both have better things to learn *and* are busy finding us lucrative consulting contracts.
06:47:44 <oerjan> xif: haskell is pretty good at using several cores with shared memory, not so much several machines
06:47:57 <syntaxfree> (I'm not a PhD, I'm a mere working bee there.)
06:48:10 <Cin> syntaxfree: Farscape :D
06:48:27 <xif> oerjan: looks like the Data Parallel thing is trying to extend Haskell with that capability as well.
06:48:37 <Cin> syntaxfree: oh, frell! he should have been here ten microts ago :P
06:49:42 <syntaxfree> s/yes and the time/yes, at the time/
06:50:25 <ac> is there a shorter version of: \f a n -> iterate f a !! n -- ?
06:50:40 <shepheb> xif: oerjan was speaking positively: we have multi-core parallelism to a degree in GHC 6.8. multi-machine is not extant yet.
06:50:43 <Vq^> @pl \f a n -> iterate f a !! n
06:50:44 <syntaxfree> masklinn: I doubt dynamic visualization of versioning is as easy with a file format agnostic VCS as it is with Microsoft Word version control though.
06:50:44 <lambdabot> ((!!) .) . iterate
06:50:51 <Vq^> ac: there you go :)
06:51:24 <shepheb> there's a brain-hurting pl.
06:51:41 <oerjan> ac: that's pretty short already isn't it :)
06:51:47 <nayru> i have a function f m = 2 * m ... and i would like to run the function x times recursively... how would you do that?
06:51:52 <Vq^> shepheb: not that hurting
06:52:04 <masklinn> syntaxfree, explain "dynamic visualization of versioning"
06:52:19 <oerjan> nayru: curiously the way ac just mentioned
06:52:28 <ac> oerjan: yeah, thought there might be a name for it
06:52:47 <oerjan> > iterate (2 *) 5
06:52:51 <lambdabot>  [5,10,20,40,80,160,320,640,1280,2560,5120,10240,20480,40960,81920,163840,327...
06:52:51 <dcoutts> nominolo: you're assuming we're assuming any existing security promise :-) there is no security, that is acknowledged.
06:52:57 <oerjan> > iterate (2 *) 5 !! 10
06:52:59 <lambdabot>  5120
06:53:25 <nayru> oerjan: hmm
06:53:32 <shepheb> Vq^: my pointfree-fu is still green belt. I'm learning.
06:54:02 * nominolo creates VM-environment for all haskell stuff
06:54:18 <shepheb> I still get tripped up by > (f . ) . g < sort of things, with sub-composition, if I can call it that.
06:54:26 <nominolo> dcoutts: but we could still be a little more careful, don't you think?
06:54:31 <kib> Hi, I've got problems with intercalate : http://hpaste.org/5659
06:55:02 <dcoutts> nominolo: if we want to be careful we should implement ticket #214
06:55:41 <dcoutts> nominolo: we already knew that packages can be uploaded by anyone with an account, it's no different just by calling it a security hole.
06:56:07 <syntaxfree> besides, committing changes is an active process. Microsoft Word just does versioning transparently.
06:56:11 <nayru> oerjan: can i paste my code for you? i cannot figure how to run it recursively
06:56:12 <oerjan> kib: you have to use a [] list for path, and also the PointElem etc. constructors
06:56:43 <oerjan> oerjan: i guess i should have suggested a shorter name for the latter :)
06:56:46 <dcoutts> nominolo: it's also about expectations management, if we pretend there is security then people will think there is some and be angry when they discover that there is none.
06:56:46 <oerjan> argh
06:56:49 <Vq^> shepheb: i can accept it in one level, like your example. but when it gets deeper/more nested it gets really hard to follow
06:56:51 <oerjan> kib: ^^
06:57:11 <oerjan> nayru: sure
06:57:44 <syntaxfree> masklinn, ah, you can juxtapose different versions of a document in a seamless way (not in a - THIS LINE HAS A SPALLING ERROR + THIS LINE NO LONGER HAS A SPELLING ERROR neverending list) and easily pick and choose authors.
06:57:48 <nominolo> dcoutts: i see
06:57:57 <syntaxfree> besides, there's no concept of "committing changes".
06:58:04 <syntaxfree> alll changes are constantly committed.
06:58:08 <kib> oerjan : I've got the same result with "type Path   = [PathElem]"
06:58:14 <syntaxfree> Basically everytime you take a > n seconds pause a change is committed.
06:58:15 <nominolo> dcoutts: at least account creation is manual ;)
06:58:31 <dcoutts> nominolo: right
06:58:51 <hpaste>  nayru pasted "iterate?" at http://hpaste.org/5660
06:59:04 <nayru> oerjan: i wrote some comments in capital letters
06:59:10 <dcoutts> nominolo: if we disallow uploading duplicate packages then at least nothing can be destructively replaced
06:59:50 <nominolo> dcoutts: yes.  and some capability lists (like neil suggested) can still be added
06:59:50 <hpaste>  oerjan annotated "(no title)" with "like this" at http://hpaste.org/5659#a1
07:00:13 <dcoutts> nominolo: right, I'd be happy if someone implemented that.
07:00:16 <oerjan> kib: ^^ see that, although the show will still not give quite what you want
07:00:24 <nominolo> dcoutts: with a few admins having the right to override any package
07:00:42 <gogonkt> encode make me crazy....
07:00:48 <nominolo> (in case the maintainer is unavailable for too long)
07:00:49 <dcoutts> nominolo: yes, but I see more people complaining than volunteering to implement it :-)
07:00:49 <gogonkt> @_@
07:00:51 <kib> ok, thanks
07:01:03 <shepheb> Vq^: I don't have an intuitive feel yet for how > f . (g .) . h < differs from > f . g . h <. clearly they are different, but I don't have a gut feeling.
07:01:24 <malcolmw> dcoutts: where is the hackage code located?
07:01:33 <nominolo> dcoutts: i might need some distraction, once i start writing my thesis :)
07:01:45 <dcoutts> malcolmw: http://darcs.haskell.org/hackage-scripts/
07:01:46 <lambdabot> Title: Index of /hackage-scripts
07:01:57 <oerjan> nayru: iterate forward m !! 3
07:02:06 <dcoutts> nominolo: I've got plenty of things for you to do, some of them are even quite interesting and useful :-)
07:02:40 <nayru> oerjan: can i do that inside the "show"?
07:03:24 <nominolo> dcoutts: no i seriously object to doing anything useful
07:03:38 <dcoutts> nominolo: hah hah
07:03:43 <nominolo> dcoutts: i want to become a real researcher one day!
07:03:47 <oerjan> nayru: sure
07:03:48 <dcoutts> nominolo: :-)
07:04:33 <oerjan> afk
07:04:49 <nominolo> dcoutts: but i had a very good idea this week, so i might actually finish my thesis within the originally planned time
07:04:49 <gogonkt> malcolmw: http://wiki.gentoo.tw/mediawiki/index.php/Irssi-utf8
07:04:52 <lambdabot> Title: Irssi-utf8 - 
07:05:06 <dcoutts> nominolo: great
07:05:14 <gogonkt> o....
07:05:26 <malcolmw> gogonkt: ???
07:05:54 <dcoutts> nominolo: and at some point after a Cabal-1.4 release I'll want some help redesigning the UserHooks stuff and using monads all over the place.
07:05:56 <gogonkt> ..... malcolmw not a bot.......
07:06:01 <gogonkt> sorry
07:06:30 <nominolo> dcoutts: yes, i also wanted to take another look at simon's proposal
07:08:19 <dcoutts> nominolo: oh his proposal for userhooks. I think it needs considering in the context of the general design. it's hard to see in isolation.
07:08:31 <nominolo> dcoutts: yep
07:08:47 <nayru> forward m = forward ( ... ) runs forever. how can i run it say.. 4 times?
07:09:07 <opqdonut> :t sequenceM
07:09:11 <lambdabot> Not in scope: `sequenceM'
07:09:16 <opqdonut> :t repeatM
07:09:18 <lambdabot> Not in scope: `repeatM'
07:09:19 <opqdonut> bah
07:09:23 <nominolo> :t sequence . replicate 4
07:09:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
07:09:28 <opqdonut> ah
07:09:31 <opqdonut> :t replicateM
07:09:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
07:09:34 <opqdonut> there
07:11:04 <gogonkt> @hoogle Char -> string
07:11:05 <lambdabot> Did you mean: Char -> String
07:11:16 <gogonkt> @hoogle Char -> String
07:11:16 <lambdabot> No matches, try a more general search
07:11:29 <gogonkt> @hoogle [Char] -> String
07:11:29 <lambdabot> No matches, try a more general search
07:11:38 <mauke> gogonkt: what are you looking for?
07:11:40 <nominolo> :t (:[])
07:11:42 <lambdabot> forall a. a -> [a]
07:12:59 <byorgey> gogonkt: note that String is just a synonym for [Char]
07:13:02 <gogonkt> mauke, looking for how made hPrinf handle ByteString.Lazy
07:13:43 <nayru> opqdonut: was that sequence stuff for me?
07:13:59 <opqdonut> nayru: yeah :)
07:14:52 <ac> why does "join (.) map (+1) [[1,2],[3,4]]" produce a type error?
07:15:13 <byorgey> ac: need parens around (map (+1))
07:15:14 <nayru> opqdonut: aah. i'm a newbie, sorry. i have this function and i would like to define it recursively. i was able to do it with "iterate", but i would like to do it by making the function call itself in its definition
07:15:55 <nayru> opqdonut: forward m = map (map (/alpha (f m))) (f m) ... right now i am using  putStrLn ("Mat 1: " ++ (show (forward s))) to display it... which works. but it feels like cheating since i  don't know recursion very well
07:15:55 <byorgey> nayru: you could pass an extra integer parameter to the function, decrement it with each recursive call, and stop when it reaches 0.
07:16:04 <malcolmw> dcoutts: nominolo: any idea how to get hold of "current user" name from within the hackage CGI upload script?
07:16:08 <mauke> ac: because the two maps have different types, probably
07:16:30 <nayru> byorgey: sounds good. i can try
07:16:39 <gogonkt> mauke, io $ hPrintf      h "%s %s\r\n" "PRIVMSG" (room ++ " :" ++ (convert "UTF-8" "GBK" (L.pack (encodeString s))))
07:16:43 <byorgey> nayru: I'm still not exactly sure what you're trying to do though.
07:16:48 <dcoutts> malcolmw: hmm, the http server handles http authentication I think, dunno if it passes the user name in as a cgi env var.
07:16:53 <ac> > join (.) (map (+1)) [[0,1],[2,3]]
07:17:04 <gogonkt> mauke, encode not work
07:17:08 <lambdabot>  thread killed
07:17:22 <gogonkt> :(
07:17:43 <malcolmw> dcoutts: I'm just realising that maybe the CGI script I'm looking at creates the package description page when a random user looks at it, rather than when the uploader uploads the package
07:18:30 <dcoutts> malcolmw: which bit are you modifying? what are you implementing exactly?
07:18:39 <byorgey> ac: ah, yeah, mauke is right.  join (.) (map (+1)) [[0,1],[2,3]] would be (map (+1)) . (map (+1)) $ [[0,1],[2,3]]
07:18:48 <byorgey> ac: i.e. apply (map (+1)) twice
07:18:52 <dcoutts> malcolmw: I'd assume you'd want to change the upload script to check who is uploading and if they're allowed to.
07:18:54 <byorgey> ac: but that doesn't have the right type
07:18:57 <malcolmw> dcoutts: I'm trying to add the uploader's name and date of upload to the package display pages
07:19:03 <nayru> byorgey: forward m = map (map (/alpha (f m))) (f m) ... i need to run this function 3 times... and the second time it runs, it should use the output of the previous run as argument (m)
07:19:09 <byorgey> > (map . map) (+1) [[0,1],[2,3]]  -- ac: is this what you want?
07:19:12 <lambdabot>  [[1,2],[3,4]]
07:19:52 <malcolmw> dcoutts: I originally assumed the display page was created on upload, but I think it may be more on-demand than that
07:19:53 <dcoutts> malcolmw: ah right, I think the package pages are generated dynamically so you'd need to get the name from some persistent storage. I think ross is working on that change already anyway so maybe look at the other aspect.
07:19:55 <byorgey> nayru: oh, I see.  maybe just do  take 3 $ iterate forward m ?
07:20:07 <malcolmw> dcoutts: which other aspect?
07:20:08 <ac> byorgey: yeah, that's what I wanted
07:20:19 <dcoutts> malcolmw: restricting uploads to authorised people
07:20:24 <nayru> byorgey: i tried that, and it worked... but i would like to be able to do it the traditional way
07:20:41 <byorgey> nayru: what do you mean by 'the traditional way'?
07:21:04 <malcolmw> dcoutts: hmm, has a dependency on the first part I fear
07:21:05 <nayru> byorgey: i am trying to learn how to make recursive functions... so i would like to do it by evaluting forward in the definition of forward
07:21:16 <Le-Chuck_ITA> hi there again
07:21:39 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5661
07:21:44 <dcoutts> malcolmw: eg keep a list of people in the package's dir check the uploader is in the list, then we add all existing uploaders to the respective lists and provide a mechanism to add more people to the list
07:21:50 <byorgey> nayru: ah, ok then.  In that case, yes, my suggestion to add an extra integer parameter to forward (i.e. how many times forward should be iterated) should work.
07:21:59 <Le-Chuck_ITA> I just pasted a simple function which I can't type, because I want polymorphism in the recursive call
07:22:00 <byorgey> hi Le-Chuck_ITA
07:22:11 <Le-Chuck_ITA> here we are again byorgey
07:22:16 <nayru> byorgey: okay. i will keep trying
07:22:19 <dcoutts> malcolmw: I don't see that they're inter-dependent, though both want to store the uploader(s) somewhere
07:22:32 <gogonkt> @hoogle UTF-8 -> GBK
07:22:32 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-8 -> GBK'
07:22:48 <gogonkt> @hoogle UTF8 -> GBK
07:22:48 <lambdabot> No matches, try a more general search
07:22:52 <Le-Chuck_ITA> I understand exactly what the compiler wants from me, problem is that the compiler does not understand what I want :)
07:23:21 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5661#a1
07:23:37 <Le-Chuck_ITA> just removed a forall which I clearly don't understand
07:24:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5662
07:24:42 <mauke> unpack :: (forall s. (Shape s) => s -> x) -> AnyShape -> x?
07:24:42 <Le-Chuck_ITA> ok, I removed all my wrong type annotations. The error from the compiler is that it can't construct an infinite type, and I agree with him
07:25:39 <Saizan> Le-Chuck_ITA: do you understand RankNTypes ?
07:25:48 <Le-Chuck_ITA> I may do so if requested :)
07:25:55 <Le-Chuck_ITA> is that the problem?
07:26:15 <byorgey> I don't think that's really the issue here.  (I may be wrong.)
07:27:03 <byorgey> Le-Chuck_ITA: the problem is that there is no way for p and (fmap p) to have the same return type.
07:27:21 <Le-Chuck_ITA> I see but I will never use that return type outside the function
07:27:41 <byorgey> Le-Chuck_ITA: perhaps you somehow need to postprocess what is returned from the recursive call to partref?
07:28:03 <tuukkah> where does the instance for (Monad (Either a)) live these days?
07:28:23 <Le-Chuck_ITA> maybe I can solve the problem because, thinking about the partition refinement algorithm, there exists an arrow from t t a to t a
07:28:34 <Le-Chuck_ITA> which mean I have something to post-compose to fmap p
07:28:40 <Le-Chuck_ITA> to make it the same return type as p
07:28:46 <Le-Chuck_ITA> this I didn't consider before
07:28:58 <byorgey> Le-Chuck_ITA: yes, that should work.
07:29:16 <tuukkah> @info Monad
07:29:17 <lambdabot> Monad
07:29:22 <tuukkah> ok...
07:29:24 <Le-Chuck_ITA> however, in the general case, this seems to me a restriction to polymorphism in recursive calls
07:29:26 <tuukkah> @info Either
07:29:26 <byorgey> @type join
07:29:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:29:29 <lambdabot> Either
07:29:49 <Le-Chuck_ITA> since if I use the "partref" function e.g. as in (partref f1 p1,partref f2 p2)
07:29:59 <Le-Chuck_ITA> with p1 and p2 of different types, it will wok
07:30:08 <Le-Chuck_ITA> inside the definition of the function, it does not work
07:30:10 <ac> ok, I'm feeling really stupid here... what's the difference between "(map . map) (+1) [[0,1],[2,3]]" and "((\f -> f . f) map) (+1) [[0,1],[2,3]]"?
07:30:27 <mauke> ac: types
07:30:32 <Le-Chuck_ITA> I don't understand completely the matter but I remember having studied the same problem for let binding vs. function application in ocaml
07:30:50 <kib> oerjan : sorry, I searched but don't understood the hints what you've given to me.
07:31:00 <Le-Chuck_ITA> Saizan: any hint?
07:31:02 <byorgey> Le-Chuck_ITA: Haskell does support polymorphic recursion.  at the moment I am not 100% sure why it doesn't work in this case.
07:31:04 <ac> mauke: right, the latter is incorrectly typed, but if I expand the lambda in the second, I get the first
07:31:12 <mauke> ac: the first map has type ([a] -> [b]) -> [[a]] -> [[b]], the second map (a -> b) -> [a] -> [b]
07:31:22 <mauke> ac: however, f forces them to be the same type
07:32:06 <byorgey> ac: map is polymorphic, so it can have two different types when used two different places in the same expression.
07:32:15 <ac> oh
07:32:18 <Le-Chuck_ITA> byorgey: I can't postcompose the T T a -> T a function I have, me dumb. It's not injective so it will change the kernel of (fmap p)
07:32:28 <byorgey> ac: kind of subtle, huh? =)
07:32:45 <tuukkah> > return "foo" :: Either String Int
07:32:47 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
07:32:55 <tuukkah> > return "foo" :: Either Int String
07:32:56 <lambdabot>   add an instance declaration for (Error Int)
07:32:56 <lambdabot>     In the expression: return "...
07:33:12 <ac> yes... I'm trying to write (for no particular reason other than amusement) a function that can map over arbitrarily deeply nested lists
07:33:14 <tuukkah> > return "foo" :: Either String String
07:33:16 <lambdabot>  Right "foo"
07:33:51 <ac> but I'm afraid it would have to use peano numbers
07:34:02 <byorgey> ac: ah, well, I see some type class hackery in your future then =)
07:34:29 <Le-Chuck_ITA> Saizan, byorgey: I turned my function into a non-recursive one and it types... I really want to know why not in the first case
07:34:41 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5663
07:34:48 <Le-Chuck_ITA> this paste is my new one
07:34:55 <byorgey> Le-Chuck_ITA: yes, I am really curious too.
07:34:55 <nayru> forward n m = forward (n - 1) (map (map (/alpha (f m ))) (f m))
07:35:03 <nayru> how can i make that stop once n reaches 0?
07:35:07 * byorgey goes off to do some by-hand type inference
07:35:25 <byorgey> nayru: you need another equation before that one that says forward 0 _ = something
07:36:28 <Le-Chuck_ITA> byorgey: I think I just got code wrong
07:36:31 <ac> nayru: or you can put an if in there
07:36:31 <Le-Chuck_ITA> it doesn't type either
07:37:03 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5663#a1
07:37:16 <Le-Chuck_ITA> the annotation shows the right code
07:37:35 <ac> nayru: multiple definitions is a lot more readable than ifs in most Haskeller's opinion, I believe
07:38:12 <nayru> ac: oh, oky. i think i made it work now
07:38:18 <nayru> ac: but it looks a little strange
07:38:27 * shepheb just added his solutions to http://en.wikibooks.org/wiki/Haskell/Solutions/Understanding_arrows  if someone could make sure I'm not completely crazy, that would be great.
07:38:28 <lambdabot> http://tinyurl.com/24fcz8
07:38:54 <oerjan> kib: did you not see my annotation? http://hpaste.org/5659#a1
07:39:09 <oerjan> oh wait
07:39:31 <hpaste>  oerjan annotated "(no title)" with "typo" at http://hpaste.org/5659#a2
07:41:05 <syntaxfree> @quote typo
07:41:05 <lambdabot> vincenz says: [Philippa] you can catch stuff off someone who's asymptomatic [vincenz] Philippa: only if you allow your body to become assymptotic with his [Binkley] nice typo [vincenz] it's a typo?
07:41:24 <loki666> hola alguien habla espaol?
07:41:25 <kib> oerjan : I already corrected the typo, that's not the problem : I've got a "pgf1.hs:14:14: Not in scope: `intercalate'" error
07:41:40 <syntaxfree> @quote espanol
07:41:40 <lambdabot> No quotes match. I've seen penguins that can type better than that.
07:41:48 <syntaxfree> no, creo que nadie.
07:41:57 <allbery_b> kib: ghc 6.6?  intercalate is 6.8
07:42:07 <byorgey> shepheb: looks good to me.
07:42:09 <loki666> xD
07:42:19 <Le-Chuck_ITA> somebody willing to look at my polymorphic recursion?
07:42:28 <kib> oh...thanks allbery_b
07:42:40 <syntaxfree> it's funny. now I hear all of lambdabot's snarky error messages in the voice of Hugh Laurie.
07:42:44 <syntaxfree> American accent, too.
07:43:07 <oerjan> kib: intercalate "--" = concat . intersperse "--"
07:43:21 <byorgey> Le-Chuck_ITA: the version you pasted with 'cont' types correctly?
07:43:23 <daf> lambdabot in the House, so to speak
07:43:37 <Le-Chuck_ITA> the version I pasted yes, but it was wrong I thnk
07:43:47 <Le-Chuck_ITA> because you have to pass "cont" itself to cont
07:43:56 <Le-Chuck_ITA> and this causes again an infinite type error
07:44:02 <nayru> thanks for all the help guys! bbl
07:44:27 <syntaxfree> daf: now I'll hear everything he says in the voice of Ali G.
07:44:45 <syntaxfree> Damn.
07:44:50 <daf> is it 'cos I is referentially transparent?
07:45:11 <shepheb> byorgey: thanks. I went to check mine, but alas. that article really helped, incidentally.
07:46:19 <oerjan> Le-Chuck_ITA: you know polymorphic recursion requires a type annotation?
07:46:27 <Le-Chuck_ITA> no I didn't know
07:46:30 <oerjan> (just checking)
07:46:35 <Le-Chuck_ITA> do you have some example?
07:47:23 <oerjan> not on the spot
07:47:46 <byorgey> oh, right!  I knew that, at some time in the past...
07:48:26 <byorgey> Le-Chuck_ITA: can you add type annotations to your code again?  I think seeing what types you THINK it should have would help in trying to figure out what's wrong.
07:48:40 <oerjan> but if you don't provide an explicit one, the type inferencer assumes all the recursive calls of a function uses exactly the same type as the original call
07:48:45 <byorgey> Le-Chuck_ITA: and, as oerjan says, they're required for polymorphic recursion anyway.
07:49:12 <Le-Chuck_ITA> oerjan: I see so I have to annotate the called function right?
07:49:23 <bringert> @seen dons
07:49:23 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 8h 40m 11s ago.
07:49:25 <oerjan> the recursive one yes
07:49:51 <oerjan> and i don't think annotating its arguments is enough (some of the pastes do that)
07:51:43 <byorgey> oerjan: you don't have to annotation the function at the actual recursive call site, just give the function a top-level type annotation
07:51:55 <oerjan> yes that's what i mean
07:51:59 <byorgey> er s/oerjan/Le-Chuck_ITA
07:52:26 <Le-Chuck_ITA> I am now trying some things
07:52:59 <vininim> > 2**540
07:53:08 <lambdabot>  3.5991310356345572e162
07:53:20 <mauke> ahh, pi
07:53:47 <oerjan> that is not the pi i know.
07:53:50 <masklinn> > 355/113
07:53:50 <Le-Chuck_ITA> ok here I am
07:53:52 <lambdabot>  3.1415929203539825
07:54:00 <Le-Chuck_ITA> byorgey: I have to annotate the recursive call
07:54:04 <Le-Chuck_ITA> however it seems to work now
07:54:11 <mauke> 
07:54:14 <Le-Chuck_ITA> only now I am in trouble with the return type
07:54:34 * shepheb just edited off the Here Be Dragons warning on the Understanding Arrows solutions. thanks again, byorgey.
07:54:48 <oerjan> there might be some advanced complications if you are actually using higher-rank types, i guess
07:55:12 <oerjan> *additional
07:56:00 <MyCatVerbs> Does the type [forall a. ((a->b),Either (MVar a)(Chan a))] -> IO Chan b make any sense with existential types?
07:56:44 <oerjan> it doesn't look existential, that's universal quantification
07:57:32 <byorgey> MyCatVerbs: that forall a. should be unnecessary there.
07:57:39 <MyCatVerbs> oerjan: I thought that was what existential types were?
07:57:40 <oerjan> i guess you meant exists a. ?
07:57:40 <byorgey> there's an implicit forall a. anyway.
07:58:01 <MyCatVerbs> byorgey: the only thing here is that the individual a's in that list may all be of completely different types.
07:58:01 <oerjan> (not legal haskell syntax but you can fake it)
07:58:47 <byorgey> MyCatVerbs: ah, then that forall a. isn't what you want, I don't think.
07:59:00 <oerjan> MyCatVerbs: data SomeThing b = forall a. SomeThing (a->b) (Either (MVar a)(Chan a))
07:59:07 <MyCatVerbs> byorgey: the function there (foo -> b) would be a labelling function, the channel returned would have a thread/threads sat on the other end of it squirting values from all of those channels and MVars into it.
07:59:10 <oerjan> and then you can put those in your list
07:59:19 <MyCatVerbs> oerjan: ta, thank you. ^_^
08:00:03 <oerjan> you're welcome, and bye :)
08:00:45 <ski> byorgey : that `forall a.' is not unnecessary
08:01:11 <byorgey> ski: oh?
08:01:32 <ski> a list of polymorphic values is not the same as a polymorphic list of values
08:02:04 <ski> hm
08:02:14 * ski ponders whether that's correct
08:02:23 <byorgey> ski: hmm.
08:02:56 <ski> if you have the first, you can take each element, and instantiate it separatedly (possibly many times)
08:03:38 <ski> if you have the second, you can instantiate the list (possibly many times), and then use the specialized list elements for each time
08:03:59 <ski> maybe that is roughly the same thing, actually
08:04:22 <ski> (or at last, ought to be)
08:04:29 <ski> hm
08:04:38 <ski> consider the simpler case
08:04:55 <ski> data Either2 a = Left2 a | Right2 a
08:05:00 <ski>   forall a. Either2 a
08:05:02 <ski> vs.
08:05:10 <ski>   Either2 (forall a. a)
08:05:21 <ski> or maybe even
08:05:30 <ski>   forall a. (Bool,a)
08:05:32 <ski> vs.
08:05:40 <ski>   (Bool,forall a. a)
08:06:22 <byorgey> well, I agree that those *seem* like different types... I can't say I'm 100% convinced they're different in practice though.  can you give a code example?
08:06:32 <byorgey> I'm so demanding, I know =)
08:06:46 <vincenz> ski: not quite
08:06:49 <vincenz> forall a. (Bool, a)
08:06:53 <vincenz> ski: the lsat is different
08:07:20 <ski> what difference do you want to claim ?
08:07:41 <vincenz> ski: moving the forall a. inside makes it different
08:08:19 <byorgey> vincenz: how so?
08:08:19 <vincenz> someone explained my errors recenty
08:08:23 <vincenz> on my blog
08:08:24 <vincenz> well
08:08:31 <vincenz> a forall a is a type function
08:08:32 <vincenz> so you have
08:08:37 <vincenz> hmm
08:08:38 <vincenz> ok
08:08:49 <vincenz> first some notation
08:08:55 <vincenz> \e.e = expression function
08:09:02 <vincenz> |t.t = type function
08:09:05 <vincenz> so
08:09:06 <byorgey> ok
08:09:07 <vincenz> the first is
08:09:13 <vincenz> |a.(Bool, a)
08:09:15 <vincenz> the second is
08:09:18 <vincenz> (Bool, |a.a)
08:09:36 <byorgey> so what's the difference?
08:09:40 <vincenz> putting this in expressions
08:09:45 <vincenz> \x -> (True,x)
08:09:45 <vincenz> vs
08:09:48 <vincenz> (True,\x->x)
08:10:02 <vincenz> byorgey: the difference is in when you apply the type
08:10:30 <byorgey> vincenz: can you give an example?
08:10:31 <vincenz> (Bool, |a.a) is not a function
08:10:34 <vincenz> so you pass it around as a type
08:10:38 <vincenz> then when you actually ue the second
08:10:41 <vincenz> you need to apply the type
08:10:51 <vincenz> |a.a only has one value, reaally, _|_
08:11:00 <vincenz> someone with stronger type-fu can probably explain it better
08:11:22 <ski> how many values does `forall a. (Bool,a)' have ?
08:11:28 <byorgey> exactly
08:11:31 <ski> how many values does `(Bool,forall a. a)' have ?
08:11:36 <vincenz> ok
08:11:40 <vincenz> you have to put this in a context
08:11:48 <vincenz> foo :: (Bool, forall a.a)
08:11:49 <vincenz> vs
08:11:55 <vincenz> foo :: forall a.(Bool, a)
08:12:03 <vincenz> the first is not a parametrically polymorhpic
08:12:05 <vincenz> it returns a value of that type
08:12:15 <ski> i agree that if you think in terms of passing around types, then the expressions do not work the same (but possibly still isomorphic)
08:12:27 <ski> however, i was thinking of type-erasure
08:12:58 <ski> (True,undefined) :: (Bool, forall a.a)
08:13:01 <ski> (False,undefined) :: (Bool, forall a.a)
08:13:06 <ski> (undefined,undefined) :: (Bool, forall a.a)
08:13:12 <vincenz> undefined :: ..
08:13:12 <ski> (True,undefined) :: forall a.(Bool, a)
08:13:18 <ski> (False,undefined) :: forall a.(Bool, a)
08:13:21 <ski> (undefined,undefined) :: forall a.(Bool, a)
08:13:23 <vincenz> ski: that's wrong
08:13:26 <ski> do you agree ?
08:13:29 <vincenz> n
08:13:29 <vincenz> no
08:13:31 <vincenz> I do not
08:13:33 <ski> why ?
08:13:45 <vincenz> for the same reason you can't elenc the values of id
08:13:47 <vincenz> it depends on context
08:13:52 <vincenz> then the 'a' gets instantiated
08:13:57 <vincenz> and you get all values in the type assigned to 'a'
08:14:00 <ski> (sorry, "elenc" ?)
08:14:44 <vincenz> forall a.(Bool, a) is not a type
08:14:47 <vincenz> it's a polytype
08:14:53 <vincenz> you have to instantiate it
08:14:58 <vincenz> before you can enumerate the values it contains
08:15:16 <vincenz> the 'type' on a higher level
08:15:24 <vincenz> of forall a.(bool, a) is
08:15:29 <vincenz> |T -> (bool, T)
08:15:42 <vincenz> so it's a function from a type to a type
08:15:46 <vincenz> and only then can you put values in it
08:15:49 <byorgey> I still don't see how this makes a difference in practice.
08:16:16 <vincenz> byorgey: in short, foralla.a. inside a data-type is an existential
08:16:24 <byorgey> not that the theory is unimportant, but I'm trying to understand whether it would make a practical difference in writing a Haskell program.
08:16:24 <vincenz> the type-function is taken along at runtime
08:16:29 <vincenz> byorgey: yes it does
08:16:33 <vincenz> it's the difference between
08:16:41 <ski> vincenz : "foralla.a. inside a data-type is an existential" i disagree stringly with
08:16:52 <ski> s/i/o/ :)
08:17:06 <vincenz> I'm not explaining myself well
08:17:12 <vincenz> mostly cause my fu isn't' strog enough
08:17:18 <vincenz> but I'm definitely sure they're different
08:17:44 <MyCatVerbs> w00t
08:17:49 <ski> when you say "foralla.a. inside a data-type is an existential" .. are you thinking of `Foo (forall a. ..a..)' ?
08:17:52 * MyCatVerbs has now used his first GHC extension. :)
08:17:55 <vincenz> ski: yes
08:17:56 <hpaste>  byorgey pasted "This type checks (whatever that means...?)" at http://hpaste.org/5664
08:18:01 <ski> or `data Foo = forall a. F (..a..)' ?
08:18:06 <vincenz> prior
08:18:06 * byorgey high-fives MyCatVerbs 
08:18:08 <ski> or `data Foo = F (forall a. ..a..)' ?
08:18:22 <MyCatVerbs> ski: see "lexiclly scoped type variables" in GHC's manual. http://www.haskell.org/ghc/docs/6.6.1/html/users_guide/type-extensions.html#scoped-type-variables
08:18:23 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/2j7dc6
08:18:26 <vincenz> MyCatVerbs: thanks
08:18:30 <vincenz> byorgey: there's a reason for that
08:18:42 <MyCatVerbs> ski: that was exactly the feature I was after, and the feature I'm now using. :)
08:18:42 <vincenz> byorgey: if you don't enable the option, you don't get 2nd-ordere typing
08:18:44 <vincenz> so lifting is allowed
08:19:02 <MyCatVerbs> byorgey: now on to heavier stuff... GADTs? Or is that a bit too big a step to take all in one go? ;)
08:19:12 <vincenz> (basicaly you allow ghc to simplify things, cause you do not care to make a distinction)
08:19:36 <byorgey> MyCatVerbs: no, GADTs aren't too hard =)
08:19:49 <byorgey> MyCatVerbs: it's when you start mixing them with existential types that things get crazy ;)
08:20:00 <byorgey> vincenz: ok, how do I turn that on?
08:20:01 <vincenz> GADTS don't mix with record types
08:20:09 <vincenz> byorgey: trying to recall
08:20:16 <byorgey> RankNTypes?
08:20:34 <vincenz> Rank2Types?
08:20:35 <wli> I've had a hard time finding a meaningful use for GADT'S.
08:20:36 <vincenz> dunno
08:20:39 <byorgey> I put {-# LANGUAGE RankNTypes #-} at the top and it still typechecks.  I don't know whether that proves anything.
08:20:39 <vincenz>  try both?
08:20:43 <vincenz> hmm
08:20:48 <vincenz> byorgey: then I'm at a loss
08:20:55 <vincenz> byorgey: try a function
08:21:05 <vincenz> b -> (Bool, forall a.a)
08:21:14 <bringert> wli: see http://www.cs.chalmers.se/~bringert/publ/composOp-jfp/composOp-jfp.pdf
08:21:16 <lambdabot> http://tinyurl.com/3cj979
08:21:21 <vincenz> byorgey: wo
08:21:25 * bringert plugs self
08:22:07 <vincenz> bringert: no higher order composop :(
08:22:26 <vincenz> composOpN
08:22:29 <bringert> vincenz: in the article? no
08:22:32 <vincenz> N = [2..]
08:22:52 <ski> vincenz : .. hm, what do you mean by "existential" when you say that "foralla.a. inside a data-type is an existential" .. something like an "existential data-type" that (each value in it) (conceptually) contains a hidden type, and some value(s) with types possibly using that hidden type ?
08:23:07 <MyCatVerbs> byorgey: I try to leave off as much as possible. Presumably one day I might just want to run my programs with, say, York or Hugs or something.
08:23:18 <vincenz> ski: yes?
08:23:25 <byorgey> MyCatVerbs: fair enough.
08:23:32 <MyCatVerbs> byorgey: though Haskell' being standardised might more or less get rid of that issue.
08:23:37 <vincenz> ski: really, I'm not strong enough to fully explain myself, I still have only a partial intuitive feeling
08:24:04 <MyCatVerbs> byorgey: plus most of the extensions are fairly arcane and I don't *think* I've had much use for them yet. :)
08:24:37 <byorgey> MyCatVerbs: well, the 'arcane' depends on your point of view, I guess =)
08:24:50 <MyCatVerbs> (With the proviso that needing something I have would merely cause me to produce miserable, twisted code rather than actually realise, "Hey, I could solve this so much easier using $foo.")
08:25:04 <MyCatVerbs> Er, don't have.
08:26:20 <vincenz> mrd: you probably know more about this, given your feedback on my blogpost
08:26:22 <ski> vincenz : i'm just trying to inquiry about what you meant by the statement before
08:27:22 <vincenz> ski: I meant it in the sense of
08:27:27 <vincenz> data Foo = Foo (forall a. a)
08:29:25 <vincenz> ski: maybe the equivalence there is wrong on my part?
08:30:05 <Cin> has banbot been implemented?
08:30:30 <vincenz> @ban cin
08:30:30 <lambdabot> Maybe you meant: bf brain bug faq map run wn
08:32:11 <Cin> :(
08:32:16 <vincenz> I guess not
08:32:19 <dons> hey, can someone on debian confirm for me that the xmonad package is installable ? http://packages.debian.org/sid/xmonad
08:32:21 <lambdabot> Title: Debian -- Details of package xmonad in sid
08:32:26 <Cin> Maybe you meant: /nick Cale && @ban cin
08:32:33 <Cin> :P
08:32:42 <vincenz> Cin: I have ops
08:32:47 <vincenz> @msg #haskell hello
08:32:47 <lambdabot> hello
08:33:11 * Cin cowers
08:33:16 <vincenz> dons: see my pm?
08:33:24 <dons> vincenz: i think that's well known.
08:33:27 <vincenz> oh
08:33:33 <vincenz> dons: well we were discussing a banbot
08:33:35 <dons> safety relies on the ops having their nicks locked
08:33:44 <vincenz> dons: but perhaps we might need a separate bot
08:33:57 <dons> why do we need a banbot? ChanServ does the job
08:33:58 <kosmikus> dons: we should probably add some note to xmonad.org that xmonad is a supported wm in NixOS
08:33:59 <vincenz> dons: and then us ethe channel ban list as a 50-element cache
08:34:12 <dons> kosmikus: oh! awesome. do you have a link?
08:34:15 <dons> i'll just add it to the distro list :)
08:34:29 <kosmikus> dons: www.nixos.org should work, but it's a forward
08:34:36 <dons> vincenz: yes, but chanServ does'nt have a limit.
08:34:58 <vincenz> dons: chanserv is only akick
08:35:06 <dcoutts> dons: as I understand it, chanserv can only kick people, rather than maintain the ban list
08:35:07 <vincenz> dons: meaning bastards could still spamjoin
08:35:12 <dons> vincenz: it can block people joining, afaik
08:35:15 * vincenz shakes
08:35:21 <ski> vincenz : ok .. i would not call that `Foo' existential at all
08:35:34 <kosmikus> dons: oh, you need a link to the package?
08:35:39 <dons> kosmikus: that'd be ideal
08:35:54 <vincenz> ski: that Foo is definitly existential
08:36:03 <vincenz> to make it more usefully existential...
08:36:15 <vincenz> data Foo = Foo (forall a. (Show a) => a)
08:36:39 <kosmikus> dons: hmm, I don't immediately find one; I'll contact you again once I know ...
08:37:04 <vincenz> or am I getting it wrong?
08:37:11 <dons> kosmikus: ok. i'll use the above link for now.
08:37:31 <ToRA> vincenz, ski: isn't it that Foo wraps an existentially quantified type there.  So the 'a' is existential, and Foo is a wrapper?
08:37:48 <xif> The more I think about it, the less I understand it: "[In Erlang] foldl is preferred to foldr because foldl is tail-recursive".
08:37:50 <xif> What's so hard about traversing a list backwards instead of forwards?
08:38:13 <xif> Is it because it's a linked list or something?
08:38:18 <ski> ToRA,vincenz : no .. mayhaps you're confusing this with `data Foo = forall a. Show a => Foo a' (an entirely different matter)
08:38:21 <ski> ?
08:39:12 <dcoutts> xif: yes, it's a linked list, you only have access to the front
08:39:17 <vincenz> ski: oh, maybe
08:39:29 <ToRA> ski: ah apologies
08:41:14 <vincenz> ski: thanks for the clarification
08:44:58 <xif> is it accurate to say that foldr is in all cases foldl on the reversed list?
08:45:56 <pjd> that depends on whether you consider non-finite lists a case, for starters
08:46:15 <ToRA> ski: what would you call a in this: data Foo'' = Foo'' (forall b . (forall a . a -> b) -> b)
08:46:21 <ToRA> ?
08:46:28 <vincenz> erm
08:46:53 <xif> pjd: OK, let's assume they aren't.
08:47:26 <ski> ToRA : existential ?    :)
08:47:31 <byorgey> > foldr f z [a,b,c] :: Expr
08:47:33 <lambdabot>  f a (f b (f c z))
08:47:42 <byorgey> > foldl f z [c,b,a] :: Expr
08:47:43 <lambdabot>  f (f (f z c) b) a
08:48:09 <ski> (ToRA : of course, it all depends on the "context" one's "measuring" from)
08:48:10 <byorgey> xif: as you can see, those are only the same if f is commutative.
08:48:20 <vincenz> > foldr1 (fun " ") [b,y,o,r,g,e,y] :: Expr
08:48:20 <lambdabot>    b (  y (  o (  r (  g (  e y)))))
08:48:21 <ToRA> ski: yeah
08:48:25 <xif> byorgey: yeah, good point
08:48:53 <byorgey> xif: however, foldl (flip f) z (reverse l)  is the same as foldr f z l   for finite lists.
08:48:58 <ski> ToRA : the main thing to remember is that the left argument of `(->)' is contravariant, so polarities switch
08:49:14 <byorgey> xif: a proof by induction should not be too hard. =)
08:49:20 <ToRA> ski: yup, i was just trying to remember which of co or contra i was
08:49:23 <faxathisia> > foldr (flip f) z [a,b,c] :: Expr
08:49:23 <ToRA> *it
08:49:27 <lambdabot>  f (f (f z c) b) a
08:49:34 <faxathisia> > foldl f z [a,b,c] :: Expr
08:49:35 <lambdabot>  f (f (f z a) b) c
08:49:39 <faxathisia> ahh..
08:50:10 <ToRA> in the same way using the original Foo as a function would give an existential argument, but unpacking/casing it would give a (universal?) result
08:50:11 <ski> ToRA : and which were you ?
08:50:33 <ToRA> ski: it varies
08:50:39 <ToRA> ;)
08:50:40 <ski> data Foo = MkFoo (forall a. (Show a) => a)
08:50:48 <ski> MkFoo :: (forall a. (Show a) => a) -> Foo
08:51:09 <ski> MkFoo :: exists a. Show a *> (a -> Foo)
08:51:28 <vincenz> ski: how does that differ from my foo?!?
08:51:29 <ski> ToRA : was that what you meant ?
08:51:33 <ToRA> yeah
08:51:38 * ToRA prefers the GADT style
08:51:48 <ski> vincenz : it doesn't (except i renamed the data constructor)
08:51:56 <vincenz> ski: then..
08:51:58 <vincenz> I'm lost
08:52:14 <vincenz> you said it wasn't existential
08:52:18 <ski> right
08:52:26 <ski> the *argument* type wasn't existential
08:52:34 <ski> it all depends on from where you look
08:52:42 <ski> lets take the next variant
08:52:58 <MyCatVerbs> @index Expr
08:52:59 <lambdabot> bzzt
08:53:00 <ski> data Bar = forall a. Show a => MkBar a
08:53:02 <MyCatVerbs> Blast.
08:53:15 <ski> forall a. Show a => (MkBar :: a -> Bar)
08:53:23 <ski> MkBar :: forall a. Show a => a -> Bar
08:53:35 <ski> MkBar :: (exists a. Show a *> a) -> Bar
08:53:52 <vincenz> *> == ?
08:54:14 <ski> here the argument should be a value of type `a' for *some* type `a' such that `Show a' holds
08:54:32 <vincenz> yes, this is business as usual
08:54:40 <vincenz> no?
08:54:53 <vincenz> that's like saying
08:54:59 <vincenz> data Bar a = MkBar a
08:55:03 <vincenz> (without the class constraint)
08:55:09 <ski> `(*>)' : `(,)' :: `(=>)' : `(->)'
08:55:22 <ski> vincenz : no
08:56:09 <vincenz> ski: is there a good paper covering this?
08:56:25 <ski> if we think of `Show a => IO a' as a function from a dictionary of type `Show a' to a value in `IO a', ..
08:56:51 <ski> .. then we can think of `Show a *> IO a' as a pair of a dictionary of type `Show a' togeether with a value in `IO a'
08:57:29 <ski> i've made up the `(*>)' symbol myself, i'm not sure if anyone else have made this distinction, but i find it useful
08:58:05 <byorgey> MyCatVerbs: http://twan.home.fmf.nl/blog/
08:58:06 <lambdabot> Title: 21 thoughts
08:58:14 <byorgey> @type (*>)
08:58:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:58:41 <ski> (in `data Bar a = MkBar a', `Bar' has a type-argument, which is not at all similar to universal or existential quantification of the type variable)
08:58:57 <ski> byorgey : yeah, not that one :)
08:59:08 <Nafai> byorgey: I got it working last night
08:59:14 <byorgey> ski: I realize that now, but I was confused at first =)
08:59:23 <byorgey> Nafai: awesome!  I got it working this morning too.
08:59:33 <Nafai> It's a little...weird.  But it works
08:59:42 <hpaste>  ToRA pasted "existential / universal cases..." at http://hpaste.org/5665
08:59:50 <byorgey> indeed, definitely rough around the edges, but after all, it's only version 0.1 =)
09:00:17 <ToRA> mmm, that might me more or less confusing..i guess it depends where you're standing
09:00:19 <MyCatVerbs> byorgey: awesome.
09:00:23 <MyCatVerbs> byorgey: thanks.
09:00:26 <ski> (i suppose that one can argue that the mention of `exists a. ' in `exists a. Show a => ...', the `=>' should be interpreted as my `*>' .. but i'm not convinced this always works)
09:00:27 <byorgey> MyCatVerbs: sure
09:00:52 <ski> (s/the `=>'/means the `=>'/)
09:00:54 <MyCatVerbs> byorgey: presumably the idea could be extended for things like do-notation desuarin, too?
09:01:44 <byorgey> MyCatVerbs: hm... maybe, I don't know =)
09:02:15 * byorgey heads to the airport... catch you all on the flip side! =)
09:02:33 <vincenz> > flip side
09:02:34 <lambdabot>   Not in scope: `side'
09:07:32 <sjw> dons: XML sucks
09:07:34 <sjw> really
09:07:42 <sjw> take my word for it :)
09:08:08 <masklinn> but sometimes you don't get to choose
09:10:33 <bringert> anyone looking for a phd position?
09:10:46 <bringert> http://www.cs.chalmers.se/~koen/phdad.html
09:10:52 <lambdabot> Title: PhD Positions in Functional Programming at Chalmers
09:20:02 <olsner> does lambdabot 4.1 cabal-install out of the box now?
09:22:02 <dcoutts> olsner: it's easy to find out :-)
09:22:16 <dcoutts> $ cabal update && cabal install lambdabot
09:23:03 <dcoutts> uh oh, it's downloading plugins-1.0 which I'm pretty sure does not work
09:23:34 <vininim> mmmm we should have some rapid prototyping thematic competitions for fun
09:24:14 <dcoutts> olsner: so the answer is no because the plugins package does not work.
09:24:49 <olsner> good thing I already have lambdabot installed then :P
09:32:44 <psykon> a function that is true if a predicate is true for every element in a list?
09:33:08 <mauke> @hoogle (a -> Bool) -> [a] -> Bool
09:33:09 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
09:33:09 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
09:33:09 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
09:33:18 <psykon> thanks
09:33:35 <olsner> @src all
09:33:35 <lambdabot> all p =  and . map p
09:33:49 <dcoutts> @src and
09:33:50 <lambdabot> and   =  foldr (&&) True
09:39:35 <bringert> today's spam sentence "I know English very good and can easily speak."
09:40:00 <dcoutts> I can speak completely legibly
09:41:07 <vincenz> bringert: I don't getit
09:41:12 <osfameron> that's nothing.  I can write inaudibly.
09:41:19 <dcoutts> :-)
09:41:35 <vincenz> I can speak wordlessly.
09:41:40 * vincenz looks at his typing figners
09:41:40 <bringert> vincenz: it was in one of these "I'm a 28 year old girl who wants to marry you" spams
09:41:58 <bringert> vincenz: it's not correct english, afaik
09:42:08 <vincenz> bringert: :D
09:42:15 <dcoutts> fewer grammar!
09:42:16 <vincenz> it's subtle but off, yes
09:42:24 <vincenz> though I can't put my finger on it
09:42:26 <Mr_Awesome> well, the only grammatical problem is that good should be well
09:42:27 <bringert> is it subtle?
09:42:38 <vincenz> bringert: there's grammatically nothing incorrect, afaict
09:42:40 <Mr_Awesome> but a native speaker would never make a sentence like that
09:42:48 <vincenz> it just doesn't make sense
09:42:57 <cjb> "speak easily" would be more idiomatic than "easily speak".
09:43:02 <vincenz> cjb: true
09:43:13 <vincenz> if you can easily speak that means you have no speech-impairment
09:43:39 <dcoutts> vincenz: it's the "good" bit that's odd. "I'll learn ya good!"
09:43:45 <vincenz> dcoutts: true
09:43:49 <vincenz> dcoutts: but easily speak is off too
09:43:55 <vincenz> that alludes more to a medical conditiion
09:43:58 <dcoutts> @arr!
09:43:58 <lambdabot> Ahoy mateys
09:44:12 <Mr_Awesome> dcoutts: i know a lot of native speakers who i would say "i know english very good"
09:44:13 <osfameron> that's like Dan Brown and his "the scientists were moving very briskly about"...
09:44:24 <osfameron> which is something you'd normally say admiringly of an 80-year old
09:44:26 <bringert> I mostly reacted to the "can easily speak" part, since that has nothing to do with knowing english
09:44:38 <dcoutts> Mr_Awesome: yeah :-) ho hum.
09:44:41 <osfameron> then again, Dan Brown isn't a great example of a literate English speaker...
09:44:57 <vincenz> if oyu're indian, you say
09:44:58 <Mr_Awesome> uh, -i :)
09:45:04 <vincenz> "I know english, very good"
09:45:06 <vincenz> and then wobble your head
09:45:09 <olsner> "literate speaker"?
09:45:18 <ray> articulate speaker
09:45:23 <dcoutts> olsner: it's like literate Haskell :-)
09:45:24 <osfameron> olsner: well, clearly I'm also not a good example :-)
09:46:17 <olsner> dcoutts: text with embedded speech? that'd be interesting :P
09:46:18 <thetallguy> ?users
09:46:18 <lambdabot> Maximum users seen in #haskell: 463, currently: 435 (94.0%), active: 14 (3.2%)
09:46:56 <xif> ya know, the main Haskell website could be more accessible to beginners.
09:47:10 <thetallguy> xif: Hah!
09:47:23 <xif> say someone wants to start using Haskell. where does he go?
09:47:33 <ddarius> The learning Haskell link
09:47:36 <xif> why no huge flashing red "Download!" button?
09:47:56 <ddarius> Because there is no single implementation
09:48:09 <xif> that's a problem right there.
09:48:10 <ddarius> Four implementations are listed readily
09:48:16 <thetallguy> xif: Haskell in 5 steps
09:48:26 <olsner> and just downloading haskell isn't enough, you actually do need to learn a few things about haskell too
09:48:43 <xif> imho you should: 1) have one recommended distribution (at least for beginners)
09:48:52 <xif> 2) have one recommended tutorial for newbies.
09:48:53 <thetallguy> xif: I'm sure it could be better, but it has improved a great deal.
09:49:06 <thetallguy> xif: you mean a Linux distribution?
09:49:14 * dcoutts agrees with xif's point 1 & 2
09:49:29 <ddarius> dcoutts: Both of those are covered on the learning Haskell page.
09:49:32 <xif> thetallguy: I mean, like the Ruby and Python sites do. they do the right thing, which is why they're growing in popularity.
09:49:56 <matthew_-> yeah, growth can be painful
09:50:10 <shepheb> xif: there was a (long and bitterly fought) discussion on haskell-cafe about this a while back
09:50:13 <xif> thetallguy: i.e., a large download page with anchor links to download one recommended distribution (with batteries included) for each popular platform.
09:50:13 <matthew_-> less than 100000000000000000 times growth each day can be beneficial
09:50:17 <thetallguy> xif: I used to work at Linspire, now at SeeReason.org, and we're using the tools we built in Haskell to build (Debian) packages for Ubuntu and (hopefully soon) Debian and make the repositories public
09:50:22 <faxathisia> haskell is immensely popular
09:50:34 <dcoutts> ddarius: not very clearly
09:50:50 <thetallguy> xif: we also know how to make live/install isos and have considered putting out a Linux distribution with just haskell software on it, basically.
09:51:02 <ddarius> dcoutts: Perhaps not, but then there isn't a single right answer anyway.  There are different types of beginners.
09:51:14 <thetallguy> xif: but it's not our primary mission and it's slow going.
09:51:22 <dcoutts> ddarius: but we could point people at the latest stable ghc + tools + tutorials
09:51:23 <psykon> so what do you guys recommend reading for learning about haskell's type system and monads ?
09:51:39 <matthew_-> psykon: #haskell
09:51:47 <psykon> ?
09:52:01 <xif> thetallguy: cool. there still needs to be a huge flashing banner that I can click, and immediately know how I can start running a Haskell interpreter with lots of useful libraries, on my platform, right now.
09:52:01 <matthew_-> asking questions is a good way to learn
09:52:14 <sclv_> haha this is "Haskell's 90% problem" -- if you're 90% of the way there, the ethic in other communities is to put a big shiny button on it and with haskell it's to say "hmm... there's no one clear right way now, so better not to pretend there is."
09:52:14 <psykon> matthew_-: i'm not just going to ask random questions, am I ?
09:52:15 <shepheb> ddarius: agreed. I found the Gentle Introduction first, but it's intended more for academics, with a lot more theoretical math than I have (and I have a decent bit, just not that much)
09:52:19 <matthew_-> "flashing banners" are *so* /not/ the haskell way
09:52:38 <xif> matthew_-: make it a static pastel color then :-)
09:52:42 <xif> with lambda on top.
09:52:44 <thetallguy> xif: aye and that will come around over the next year or two
09:52:45 <matthew_-> psykon: true. They are best inspired by the code you're writing ;)
09:52:49 <sclv_> "The first 90% takes 90% of the time. The other 10% is a shiny button."
09:52:57 <vincenz> we should have different haskell channels
09:52:57 <ddarius> dcoutts: I don't think it can be much more obvious than it is now.  Maybe a little more obvious.
09:53:04 <Le-Chuck_ITA> I get parse error on input `forall' from data State a = forall b . forall t . Functor tm => State (a -> t a,a -> b)
09:53:07 <thetallguy> xif: dcoutts has been putting in a massive effort on Cabal and hackage
09:53:08 <vincenz> haskell-noob, haskell-recursion, haskell-monad, ..., haskell-oleg
09:53:12 <hrehf> vincenz got my latex/hs highlighting message?
09:53:13 <Le-Chuck_ITA> and I load it via ghci -fglasgow-exts
09:53:14 <matthew_-> vincenz: careful, that's been round on -cafe before too
09:53:16 <vincenz> hrehf: yeah, thanks
09:53:17 <Le-Chuck_ITA> what's wrong?
09:53:22 <faxathisia> psykon: What about the type system?
09:53:23 <thetallguy> xif: so libraries are getting published
09:53:31 <vincenz> @users #haskell-oleg -> -inf
09:53:32 <lambdabot> Maximum users seen in #haskell-oleg -> -inf: 1, currently: 0 (0.0%), active: 0 (NaN%)
09:53:38 <thetallguy> xif: which means that people will need more automation to keep up.
09:53:40 <sclv_> haskell-stack-overflow
09:53:50 <hrehf> vincenz using listings it's easy, but i couldn't really configure it to highlight the way i wanted :(
09:53:53 <dcoutts> ddarius: but why are we telling new users about yhc? it should really be two steps: grab ghc for your platform and follow this tutorial.
09:53:57 <psykon> faxathisia: i don't have any specific question, i need to study :)
09:53:58 <vincenz> hrehf: yeah :|
09:53:58 <faxathisia> hehe, ml-the-language ml-the-type-system, ml-the-calculus
09:54:07 <thetallguy> the users command ought to have another field:  bottomed: 15%
09:54:07 <ray> vincenz: we need #haskell-es and #haskell-yhc and #haskell-yhc-es (and #haskell-es-yhc for those who think language is more important than implementation)
09:54:11 <ddarius> dcoutts: My experience has been that this hasn't been a significant issue for nearly anyone.
09:54:31 <shepheb> haskell-cafe "consensus" re: multiple IRC channels was "better to have one active channel talking about divergent things than four inactive ones."
09:54:54 <matthew_-> besides, we tend to be able to cope with 2 or 3 concurrent conversations on here
09:54:58 <shepheb> similarly for splitting haskell-cafe
09:55:12 <ddarius> shepheb: The Gentle Introduction had a lot of theoretical math in it?  It had any?
09:55:19 <matthew_-> they all boil down to  anyway...
09:55:26 <xif> dcoutts: exactly. newbies don't want "4 good options to choose from". they want a single recommended one.
09:55:30 <vincenz> ray: I've given up a bit on it
09:55:42 <vincenz> xif: eactly, let's not become #lisp
09:55:55 <vincenz> "what implementation should I use"  "Well what do you want?"
09:56:03 <shepheb> ddarius: Well, I can go and find examples. It certainly gave me the feel of being intended for a computer science academic, which I am not.
09:56:08 <xif> as a Haskell newbie, how am I supposed to choose between GHC, Hugs, nhc98, Yhc?
09:56:13 <vincenz> "I want to learn $Language" "Well you should try them to se what yu need"
09:56:17 <Cale> xif: GHC
09:56:31 <vincenz> Cale: he says it should be documented
09:56:36 <dcoutts> Cale: right, and that should be as clear as possible on the learning haskell page
09:56:41 <shepheb> ddarius: YAHT is the one that worked best for me for the core stuff. monads, of course, I gradually figured out by reading every tutorial I could find.
09:56:41 <xif> Cale: thanks, I will. and the website should point this out as well.
09:56:43 <thetallguy> I reckon *everyone* wants one really good option to choose from.
09:56:46 <vincenz> dcoutts: yeah, we don't want it to be like #lisp or #sccheme
09:56:53 <dcoutts> vincenz: aye
09:58:20 <ddarius> shepheb: I actually would like an example.
09:58:31 <shepheb> ddarius: okay, I'll find an example of what I mean.
10:00:03 <xif> anyways, I'll learn Haskell, and if I like it, one of the first things I'm going to do is put a large "Download Haskell" link on the front page, pointing to http://haskell.org/ghc/
10:00:40 <faxathisia> which front page?
10:00:48 <xif> faxathisia: http://www.haskell.org/
10:00:49 <lambdabot> Title: Haskell - HaskellWiki
10:01:21 <psykon> xif: why?
10:02:14 <xif> psykon: if the language is nice, it deserves more users. a more accessible website would facilitate that.
10:02:17 <shepheb> ddarius: http://www.haskell.org/tutorial/monads.html   for example, the section on MonadPlus. I just had (reading this last August) the sense that something was being /presented/, rather than explained. I came away with "huh?"
10:02:17 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
10:02:26 <Cale> xif: Avoid success at all costs.
10:02:27 <Zao> xif: Do note that GHC isn't the only Haskell compiler.
10:02:36 <psykon> xif: i believe haskell.org is very good
10:02:53 <shepheb> ddarius: I'm just glad that it didn't turn me away. Whether that makes me stubborn or persevering is up for grabs.
10:03:20 <xif> Zao: I do. it's still important to have one, single, recommended implementations for all newbies to download.
10:03:45 <psykon> xif: are "newbies" inherently stupid?
10:03:46 <Cale> It's funny, I always like seeing a new Haskell *user*, but I really don't like the idea of the language becoming too popular, since past a certain point, it just creates resistance to change.
10:03:48 <psykon> i'm a newbie
10:04:13 <desegnis> xif: Then it should read We recommend GHC, download here.
10:04:32 <Cale> Better that we only attract people interested in programming languages for as long as possible. :)
10:04:51 <shepheb> doesn't the main site mention GHC as a de-facto standard?
10:04:59 <psykon> shepheb: it does
10:05:35 <faxathisia> Anyone got a proof that foldr f z xs = foldl (flip f) z (rev xs)?
10:05:38 <xif> Cale: the tradeoff is less testing, libraries and platform support.
10:05:50 <shepheb> speaking as a relative newbie with no one guiding me to use Haskell (I can't even remember how I heard about it, now that I think about it), I had no trouble finding GHC, installing it, trying out Haskell.
10:05:53 <ddarius> faxathisia: It's not true.
10:05:56 <Cale> We have enough for my own personal uses :)
10:06:03 <xif> and ultimately, less jobs, which may be the most important.
10:06:18 <ddarius> shepheb: Thanks.  I'll agree that that is rather minimalistic, but I don't think that it has any information that shouldn't be there.
10:06:20 <psykon> shepheb: same here
10:06:46 <faxathisia> > let xs = [a,b,c,d] in (foldr f z xs, foldl (flip f) z (reverse xs)) :: (Expr, Expr)
10:06:50 <lambdabot>  (f a (f b (f c (f d z))),f a (f b (f c (f d z))))
10:06:54 <ray> i don't think i've ever not had the sense that ghc was the de-facto standard (relatively new here)
10:06:54 <Cale> I haven't even had the chance to look at everything on hackage yet.
10:07:13 <faxathisia> It seems true..
10:07:46 <xif> Cale: yeah, but it would be nice if some day you'd like to send an SMS from your Haskell program, and can actually do that, thanks to libraries.
10:08:09 <xif> anyways, the discussion is generic enough, I assume everyone here knows the arguments already :-)
10:08:13 <Cale> hehe :)
10:08:21 <faxathisia> > let xs = (a:b) in (foldr f z xs, foldl (flip f) z (reverse xs)) :: (Expr, Expr)
10:08:25 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
10:08:26 <Cale> I don't own even own a cell phone :)
10:08:35 <ddarius> > foldr const [1..]
10:08:38 <ray> sif SMS library
10:08:38 <xif> you're special, I envy you.
10:08:41 <lambdabot>  <[[Integer]] -> [Integer]>
10:08:49 <ddarius> > foldr const 0 [1..]
10:08:49 <lambdabot>  1
10:08:51 <faxathisia> I don't have a cell phone..
10:08:55 <ray> you need phone service more than you need a library
10:08:58 <ddarius> > foldl (flip const) 0 [1..]
10:09:02 <lambdabot> Terminated
10:09:05 <ray> i can't find my cell phone, which is close
10:09:21 <vincenz> ray: well imagine finding it far away
10:09:43 <vincenz> dcoutts: any conclusions on the ban-issue?
10:09:54 <faxathisia> It's true for finite structures at least
10:09:58 <faxathisia> I guess...
10:10:02 <shepheb> ddarius: oh, certainly, it's not being misleading. it's just not aimed at my background. I saw when finding the Gentle Intro that it's now tagged on the wiki with "not so gentle, really", which helps.
10:10:10 <faxathisia> but is there any proof somewhere?
10:11:49 <shepheb> if my cell phone has been out of charge for two days, but I still carry it everywhere, does that count?
10:11:55 <Cale> It's gentle, if you already know ML ;)
10:12:24 <vincenz> Cale: yes, gentle in the sense "OH THANK YOU LORD, NO MORE .*!"
10:12:50 <ray> it's not gentle but you can't dispute that it's an introduction to haskell
10:13:06 <vincenz> I found YAHT more intuitive than the gentle one
10:13:11 <vincenz> but maybe it waas timing
10:13:37 <shepheb> vincenz: I think YAHT is just more aimed at an imperative background. that's certainly the one that got me off the ground.
10:13:38 <ray> is YAHT the one that's a pdf? if so i never read it because it was a pdf (silly, i know)
10:13:49 <lament> maybe they misspelled Gentile, as opposed to a jewish introduction
10:13:55 <vincenz> shepheb: possibly, but I came from o'camle
10:13:57 <vincenz> shepheb: so..
10:14:07 <shepheb> ray: yes. it's been subsumed into the wikibook, though.
10:14:08 <lament> ray: yes, it is a pain to read, also its chapter on monads is a mess
10:14:25 <Cale> ray: heh, you're going to have to get over that :)
10:14:30 <faxathisia> If I could just show f a (foldl (flip f) z (reverse xs)) = foldl (flip f) z (reverse xs ++ a :: nil)...
10:14:48 <Cale> ray: Most Haskell stuff is written in the form of published papers in your choice of PDF or Postscript :)
10:14:56 <faxathisia> What do people have against pdf?
10:15:20 <shepheb> faxathisia: I think it's transferral from hating Adobe Reader.
10:15:22 <ehird`> what is (flip (.)) again?
10:15:36 <ray> i'd prefer latex source or whatever
10:15:37 <Cale> faxathisia: People use crappy pdf viewers, and then blame the format :)
10:15:41 <faxathisia> > (flip (.)) f g
10:15:42 <lambdabot>  Add a type signature
10:15:47 <faxathisia> > (flip (.)) f g :: Expr
10:15:47 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> c'
10:15:50 <ray> yes, i have a crappy pdf viewer
10:15:54 <faxathisia> @pl (flip (.)) f g
10:15:55 <lambdabot> g . f
10:16:39 <vincenz> > lift $ (flip (.)) f g :: Expr
10:16:39 <lambdabot>  Couldn't match expected type `Expr'
10:16:44 <vincenz> wtf
10:16:52 <vincenz> > unlift $ (flip (.)) f g :: Expr
10:16:52 <lambdabot>   Not in scope: `unlift'
10:17:15 <ehird`> i know what (flip (.)) IS
10:17:19 <ehird`> but there's a predefined name for it
10:17:21 <ehird`> isn't there?
10:17:29 <vincenz> :t (flip (.))
10:17:31 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
10:17:34 <Deewiant> >>>
10:17:38 <Deewiant> in arrow
10:17:40 <vincenz> pipe :)
10:17:42 <Deewiant> @index (>>>)
10:17:43 <lambdabot> Control.Arrow
10:17:56 <Deewiant> > ((+1) . (*2)) 6
10:17:58 <lambdabot>  13
10:17:59 <Deewiant> > ((+1) >>> (*2)) 6
10:18:01 <lambdabot>  14
10:18:16 <Deewiant> ehird`: ^
10:18:21 <ehird`> thanks
10:18:21 <ehird`> :)
10:18:22 <ski> >.>
10:18:29 <ehird`> > @
10:18:30 <lambdabot>  Parse error at "@" (column 1)
10:18:32 <ehird`> d'aww
10:18:34 <ehird`> i was going to give it a name
10:18:35 <ehird`> :P
10:18:56 <Le-Chuck_ITA> How do I nest existential quantifications? forall a . forall b gives error and so does forall a . (forall b ...)
10:19:06 <ToRA> forall a b . ?
10:19:57 * shepheb wishes there were <_< and >_> operators. then some functions would look shifty and nervous.
10:19:59 <ToRA> forall a . ( forall b . b -> a )  should also work assuming you have the right flags on
10:20:23 <Le-Chuck_ITA> ToRA: perfect, thanks :)
10:20:47 <vincenz> > let {<_< = Left; >_> = Right } in <_< . >_> $ "eyes"
10:20:47 <lambdabot>  Parse error at "<_<" (column 6)
10:20:49 <Deewiant> > let (<.<) = (>>>); (>.>) = (.) in ((+1) <.< (+2) >.> (+3)) 6
10:20:50 <lambdabot>  12
10:20:59 <vincenz> > let {<.< = Left; >.> = Right } in <_< . >_> $ "eyes"
10:20:59 <lambdabot>  Parse error at "<.<" (column 6)
10:21:01 <Deewiant> _ isn't an operator character :-/
10:21:09 <Deewiant> vincenz: needs more brackets
10:21:21 <idnar> MOAR BRACKETS!@#$
10:21:35 <vincenz> > let <.< = Left; >.> = Right  in <_< . >_> $ "eyes"
10:21:35 <ski> argh, my eyes !
10:21:35 <lambdabot>  Parse error at "<.<" (column 5)
10:21:39 <Deewiant> > let (<.<) = Left; (>.>) = Right in <.< . >.> $ "eyes"
10:21:39 <lambdabot>  Parse error at "<.<" (column 36)
10:21:48 <shepheb> Deewiant: Aww. Well, >.> and <.< would work? no, apparently not.
10:21:48 <desegnis> more! more! more!
10:21:56 <dv\> what's >.> and <.<?
10:22:01 <vincenz> shifty eyes
10:22:01 <Deewiant> > let (<.<) = Left; (>.>) = Right in (<.< . >.>) $ "eyes"
10:22:02 <lambdabot>  Parse error at "." (column 41)
10:22:09 <Deewiant> shepheb: sure they work, see above
10:22:13 <ski> > let (<.<) = Left; (>.>) = Right in (<.<) . (>.>) $ "eyes"  -- like this
10:22:16 <lambdabot>  Left (Right "eyes")
10:22:33 <Deewiant> > let (<.<) = Left; (>.>) = Right in (<.<) . (>.>) $ "eyes"
10:22:35 <lambdabot>  Left (Right "eyes")
10:22:39 <shepheb> Deewiant: parse errors, I thought. Oh, I see.
10:23:09 <dv\> are these the same >.> and <.< as defined in Control.Monad?
10:23:16 <Deewiant> @index (>.>)
10:23:17 <lambdabot> bzzt
10:23:54 <Le-Chuck_ITA> byorgey: I just want you to know that in the end I needed existential types :)
10:23:59 <shepheb> oh, do they exist? I just made them up now because they could be funny. lambdabot thinks they dont, apparently
10:23:59 <dv\> oh wait. i meant >=> and <=<
10:24:12 <ski> @index (>=>)
10:24:13 <lambdabot> bzzt
10:24:19 <Deewiant> @index (<=<)
10:24:19 <lambdabot> bzzt
10:24:21 <shepheb> .oO( fish operators? )
10:24:33 <dv\> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#v%3A%3E%3D%3E
10:24:39 <lambdabot> http://tinyurl.com/ykyqfl
10:24:41 <int-e> @version
10:24:41 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
10:24:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:25:07 <dv\> strange. it should have those then?
10:25:12 <shepheb> oh, when did \bot get upgraded to 6.8.2?
10:25:39 <Deewiant> > let (^.^) = (++) in "I'm " ^.^ "happy"
10:25:41 <lambdabot>  "I'm happy"
10:25:54 <Deewiant> last week, I think
10:26:04 <mux> > (+1) <$> Just 1
10:26:04 <lambdabot>  Just 2
10:26:25 <mux> @index forever
10:26:25 <lambdabot> bzzt
10:26:32 <vincenz> forever a = a >> forever a
10:26:39 <Deewiant> @hoogle forever
10:26:39 <ski> shepheb : <http://www-staff.it.uts.edu.au/~cbj/FISh/> ?
10:26:43 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
10:26:53 <mux> the point is that the bot should be able to find it now that it's running 6.8.2
10:26:57 <Deewiant> @bot
10:26:58 <lambdabot> :)
10:27:01 <Deewiant> @version
10:27:01 <mux> @index on
10:27:01 <lambdabot> bzzt
10:27:01 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
10:27:02 <lambdabot> darcs get http://code.haskell.org/lambdabot
10:27:08 <ehird`> you should be able to write this
10:27:12 <Deewiant> @index intercalate
10:27:13 <ehird`> forever :: Monad m => m a ->
10:27:13 <lambdabot> bzzt
10:27:20 <ehird`> it's the "suspense" case of (->)
10:27:21 <Deewiant> @src intercalate
10:27:22 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
10:27:24 <Deewiant> @src on
10:27:25 <ehird`> it means the function doesn't return.
10:27:25 <lambdabot> (*) `on` f = \x y -> f x * f y
10:27:31 <mux> @index fix
10:27:31 <vincenz> ehird`: welcome to bottom
10:27:31 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
10:27:33 <Deewiant> index doesn't have it but the rest do, apparently
10:27:37 <ehird`> vincenz: mine is funnier
10:27:37 <ehird`> :(
10:27:38 <mux> :t Data.Function.fix
10:27:39 <lambdabot> forall a. (a -> a) -> a
10:27:52 <ehird`> it's scary!
10:27:53 <dv\> @src (>=>)
10:27:53 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:28:10 * mux hearts Data.Function
10:28:20 <mux> it was quite weird to need to import Control.Monad.Fix to get fix
10:28:59 <ski> `Control.Monad.forever' ought to have type `Monad m => m a -> m b', or `Monad m => m a -> m Void'
10:29:40 <mux> what would m Void be? isn't it what m () is about?
10:29:40 <dv\> is forever useful outside of IO?
10:29:41 <shepheb> ski: curious.
10:30:06 <mux> and if it's supposed to run forever, I don't see the point in having it return something else than m ()
10:30:07 <ski> mux
10:30:15 <dolio> m Void would indicate that you can't get a value out of it.
10:30:21 <shepheb> ski: this
10:30:22 <ski> mux : `Void' is the empty type (well, apart from `_|_', i.e.)
10:30:34 <vincenz> void is -only- bottom
10:30:42 <mux> okay
10:30:44 <vincenz> data Void;
10:30:47 <vincenz> see: no cases
10:30:49 <vincenz> so only bottom
10:31:07 <mux> but I guess that's not terribly different from () which has only one value besides bottom
10:31:08 <Le-Chuck_ITA> bye all my valentine day with lambdas was fun
10:31:12 <shepheb> ski: this shape analysis sounds a little like "pure functional languages let the compiler transform your code to something equivalent, but more efficient.", eg. map f . map g . map h === map (f.g.h)
10:31:13 <Le-Chuck_ITA> love to you all
10:31:13 * ski has used `Void' to note that some actions didn't monadically return
10:31:40 <vincenz> mux: 1 is infinitely more than 0
10:31:49 <kmcallister> mux, in logic they're as different as you can get :)
10:32:08 <kmcallister> often Void represents false and () represents true
10:32:17 <mux> from the point of view of the caller they're basically the same
10:32:29 <vincenz> mux: nope
10:32:32 <vincenz> one is true, other is false
10:32:36 <vincenz> if you have dpenedent typing
10:32:55 <mux> but I admit it would be little more nice as far as documentation through types goes
10:32:58 <dolio> I'd go with m a -> m b, though.
10:33:09 <kmcallister> you can't pattern match on the result of an action returning Void
10:33:18 <vincenz> kmcallister: yes you can
10:33:19 <kmcallister> (not usefully anyway)
10:33:19 <dolio> Otherwise you'll have to go around doing "forever m >> return ()" in various situations.
10:33:23 <vincenz> kmcallister: you just can't return a value of type vod
10:33:28 <vincenz> case foo of {}
10:33:32 <vincenz> :: Void -> a
10:33:34 <kmcallister> i guess pattern matching on () is also not very useful
10:33:46 <vincenz> from faflse you prove anything :)
10:34:07 <mux> that's my point; from the point of view of the caller you don't get anything more useful out of () than out of void
10:34:16 * faxathisia discovers, foldr f z (xs ++ ys) = foldr f (foldr f z ys) xs
10:34:24 <ehird`> why is 'fix f = f x where x = fix f' instead of the simpler again?
10:34:33 <Deewiant> @check foldr f z (xz ++ ys) = foldr f (foldr f z ys) xs
10:34:34 <lambdabot>  Parse error at "=" (column 22)
10:34:39 <Deewiant> @check foldr f z (xz ++ ys) == foldr f (foldr f z ys) xs
10:34:45 <vincenz> mux: that's not true
10:34:54 <lambdabot>  thread killed
10:34:55 <vincenz> :: () -> a is not realizable in a total language
10:34:59 <vincenz> :: Void -> a is
10:35:00 <dolio> ehird`: Sharing.
10:35:11 <mux> vincenz: but this is haskell, which ain't total, nor is it dependent typing
10:35:24 <ski>   kill :: SystemM Void    -- Kill the current thread, swapping in another thread, if any, otherwise finish the simulation
10:35:34 <ehird`> dolio: plz be of the explainering
10:35:36 <ski>   schedule :: [Thread] -> SystemM ()      -- Schedule a list of threads to be performed
10:35:51 <ski> those `()' and `Void' mean *quite* different things
10:36:28 <dolio> ehird`: Consider fix (1:)
10:36:40 <ski> mux : two actions using `()' and `Void' to encode different behaviour ^
10:36:47 <desegnis> vincenz: I guess because there wouldn't be a value of type Void in a total language, so v :: Void -> a would be an empty function?
10:36:57 <vincenz> desegnis: no, simply you can't ever call it
10:37:03 <vincenz> desegnis: roconnor has more info on this
10:37:09 <vincenz> he gve a great presentation on it
10:37:15 <dolio> ehird`: In fix f = f (fix f), you get 1: fix (1:), which expands into 1: 1: fix (1:) and so on.
10:37:18 <roconnor> ?
10:37:22 <desegnis> vincenz, that's approximately what I mean
10:37:24 <roconnor> what do I know?
10:37:37 <desegnis> vincenz, or _is_ there a value of type Void?
10:37:41 <ski> (`kill' never monadically returns, `schedule' currently returns directly after scheduling the other threads for later execution)
10:37:46 <ehird`> dolio: Yes..
10:37:49 <ehird`> and:
10:37:51 <vincenz> desegnis: there is not a value of void
10:37:53 <dolio> ehird`: In let x = f x in x, you get ones = 1:ones, which is representable as a cons with a pointer to itself.
10:37:55 <mux> ski: right, but then again yuo could swap () for Void here, and it wouldn't change anything from the point of view of the caller as far as I can tell
10:37:58 <vincenz> however you -can- have a case on type void
10:38:02 <vincenz> you just can't ever call that function
10:38:08 <vincenz> cause you can't make a value of type void
10:38:10 <ehird`> dolio: OK. It just seems like the two expressions should be interchangable
10:38:13 <vincenz> there's a destructor, just no constructor
10:38:22 <ski> mux : no, that would be misleading
10:38:39 <dolio> ehird`: They are semantically, but one is potentially more efficient in some cases.
10:38:52 <vincenz> desegnis: I thank this knowledge to roconnor's presentation he gave in Utrecht
10:39:01 <vincenz> he's the expert
10:39:03 <mux> ski: misleading in the sense that the types would be less useful documentation-wise, which is what I've been trying to say for some time now :-)
10:39:04 <desegnis> vincenz, I see
10:39:08 <roconnor> :)
10:39:23 <mux> ski: but that's all the difference there is
10:39:28 <vincenz> roconnor: correct me if I said it wrong :)
10:39:28 <ski> mux : initially i did exactly that, using `()', there .. and i had to use quite a lot of irritating `undefined's so i couldn't be sure of whether any of them would actually be invoked or not
10:39:44 <ehird`> @src undefined
10:39:44 <lambdabot> undefined =  error "Prelude.undefined"
10:39:55 <ehird`> @src error
10:39:55 <lambdabot> error s = throw (ErrorCall s)
10:40:00 <ehird`> @src throw
10:40:01 <lambdabot> throw exception = raise# exception
10:40:08 <ski> mux : when i changed to the semantically correct `Void', those dissapeared, and it was much clearer to think about the code
10:40:09 <desegnis> vincenz: Btw by empty function I meant empty in the set theory sence
10:40:15 <vincenz> oh
10:40:19 <vincenz> desegnis: right
10:40:26 <desegnis> ok
10:40:28 <Taejo> is there a way to exclude a file from haddock in cabal?
10:40:32 <vincenz> desegnis: you can have {} -> a, just not a -> {}
10:40:42 <vincenz> desegnis: thanks for saying that, I didn't realize the link before
10:41:09 <desegnis> right
10:41:40 <vincenz> ok
10:43:28 <ehird`> > let f = const undefined in f 2
10:43:31 <ehird`> > let f = const undefined in f 2 :: Expr
10:43:31 <lambdabot>  Undefined
10:43:32 <lambdabot>  Undefined
10:45:25 <ski> @djinn Not a -> a -> b
10:45:25 <lambdabot> f a b = void (a b)
10:45:33 <ski> @djinn Void -> a
10:45:33 <lambdabot> f = void
10:45:54 <ehird`> > void
10:45:56 <lambdabot>   Not in scope: `void'
10:45:58 <ehird`> @type void
10:46:08 <lambdabot> Not in scope: `void'
10:46:08 <ski> basically
10:46:13 <ehird`> @src Void
10:46:13 <lambdabot> Source not found. Take a stress pill and think things over.
10:46:20 <ski>   void v = case v of { }
10:46:30 <ski> but that isn't syntactically valid :/
10:46:38 <ski> @djinn-env
10:46:38 <lambdabot> data () = ()
10:46:39 <lambdabot> data Either a b = Left a | Right b
10:46:39 <lambdabot> data Maybe a = Nothing | Just a
10:46:39 <lambdabot> data Bool = False | True
10:46:39 <lambdabot> data Void
10:46:41 <lambdabot> type Not x = x -> Void
10:46:42 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:46:49 <ehird`> ski: is there any real definition of it
10:47:01 <ski>   void v = case v of { }
10:47:03 <ski> ^
10:47:18 <psykon> data Foo a = Foo a a   -- How could i force "a" to be of a specific type ?
10:47:35 <kmcallister> ehird`, you could type restrict (const undefined)
10:47:36 <ski> data Foo = Foo Int Int
10:47:37 <sfultong> hey... I wanna make a custom blinking cursor in gtk2hs... is there any timer event thing in that API, or do I have to pull that in from another library?
10:47:43 <psykon> ski: thanks
10:48:02 <oerjan> psykon: or use the original as Foo Int
10:49:19 <ehird`> kmcallister: data Void
10:49:19 <ehird`> instance Show Void where show = const "Void"
10:49:20 <ehird`> :)
10:49:31 <ski> ehird` : afaiac, the one with the empty `case' is the real definition, it's just that haskell doesn't allow this special case of `case' (for no good reason, afaik)
10:49:47 <ehird`> ski: welp, void :: a -> Void
10:49:47 <ehird`> void = const undefined
10:49:49 <psykon> oerjan: sorry?
10:49:50 <ehird`> seems to behave correctly
10:49:56 <ski> instance Show Void where show = void
10:50:02 <ehird`> ski: cute, very cute
10:50:21 <ehird`> and badly typed ofc ;)
10:50:25 <oerjan> psykon: if you have data Foo a = Foo a a you can declare another variable say as foo :: Foo Int
10:50:38 <ski> ehird` : hm ?
10:51:09 <kmcallister> there void :: a -> b
10:51:21 <newsham> http://www.mightywombat.com/toons/numbers.gif
10:51:24 <kmcallister> which is not sound of course
10:51:36 <ski> (using `const' here with `Void' is cheating, imo ..)
10:51:53 <ski> kmcallister : void :: Void -> a
10:52:14 <bos> @seen dons
10:52:14 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 2h 15m 3s ago.
10:52:18 <ehird`> err
10:52:20 <bos> @seen dcoutts
10:52:20 <kmcallister> oh, i missed your annotation
10:52:20 <lambdabot> dcoutts is in #haskell-overflow, #gentoo-haskell, #ghc and #haskell. I last heard dcoutts speak 55m 27s ago.
10:52:21 <ehird`> void :: a -> Void
10:52:32 <ehird`> kmcallister: unsafeCoerce to Void? :)
10:52:41 <kmcallister> hehe
10:52:58 <kmcallister> that takes "unsafe" to a whole new level
10:53:06 <ehird`> forever a = do a; forever a; void a   -- i wonder why this doesn't work
10:53:08 <mauke> This expression has type const but is here used with type void
10:53:09 <ehird`> (with void :: a -> Void)
10:53:38 <ski> `Void' is not of form `m a' for a monad `m'
10:53:42 <ehird`> oh
10:53:43 <ehird`> duh
10:53:43 <ehird`> :)
10:53:47 <ehird`> m Void, then
11:02:17 <glguy> Is there a better way to list the directories in a directory than to call: getDirectoryContents and filter it with some function that checks if something is a directory?
11:02:43 <Deewiant> not AFAIK
11:02:53 <mauke> that sounds like a good way
11:03:06 <Deewiant> filterM isDirectory $ getDirectoryContents "." or whatever
11:03:19 <mauke> because it's what you get when you translate grep -d "$dir/$_", readdir $dh to Haskell
11:03:21 <glguy> ?hoogle FilePath -> IO Bool
11:03:21 <lambdabot> System.Directory.doesFileExist :: FilePath -> IO Bool
11:03:22 <lambdabot> System.Directory.doesDirectoryExist :: FilePath -> IO Bool
11:03:39 <mauke> don't forget to prepend the directory name to the results of readdir
11:05:26 <glguy> filterM (\x -> doesDirectoryExist (p </> x)) =<< getDirectoryContents p
11:06:27 <kmcallister> :t (</>)
11:06:28 <lambdabot> Not in scope: `</>'
11:06:39 <glguy> use your imagination :)
11:06:45 <Deewiant> @pl filterM (\x -> doesDirectoryExist (p </> x)) =<< getDirectoryContents p
11:06:45 <lambdabot> filterM (doesDirectoryExist . (p </>)) =<< getDirectoryContents p
11:07:09 <glguy> Deewiant: this code is going to be used in more places than #haskell though
11:07:11 <glguy> ;)
11:07:14 <Deewiant> :-)
11:07:52 <Deewiant> I'd still say not using the lambda here makes it more readable
11:11:02 <vininim> :t (!!)
11:11:03 <lambdabot> forall a. [a] -> Int -> a
11:11:19 <vininim> > [1..10] !! 2
11:11:22 <lambdabot>  3
11:11:27 <vininim> > [1..10] !! 0
11:11:28 <lambdabot>  1
11:11:31 <Deewiant> > [0..] !! 2
11:11:32 <lambdabot>  2
11:11:50 <Deewiant> @check \n -> n == [0..] !! n
11:11:51 <lambdabot>  Exception: Prelude.(!!): negative index
11:11:58 <Deewiant> d'oh
11:12:52 <mauke> @check \n -> n >= 0 ==> n == [0..] !! n
11:12:53 <lambdabot>  OK, passed 500 tests.
11:13:07 <ski> @check id
11:13:08 <lambdabot>  Add a type signature
11:13:14 <ski> @check not
11:13:15 <lambdabot>  Falsifiable, after 0 tests: True
11:14:28 <masklinn> wha
11:14:45 <masklinn> lambdabot can perform qc checks now?
11:14:55 <glguy> Where have you *been*?
11:14:59 <cjb> yeah, for a long time
11:15:02 <masklinn> very far away
11:15:09 <masklinn> mostly not reading, really
11:15:29 <masklinn> (not reading #haskell I mean)
11:15:59 <masklinn> anyway, so when does lambdabot become fully sentient and take over the world?
11:16:14 <mauke> > scanl f z [1 ..]
11:16:15 <lambdabot>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3,f (f (f (f z 1) 2) 3) 4,f (f (f (f (f...
11:16:19 <twanvl> ?vixen when will you take over the world?
11:16:20 <lambdabot> when ever you want
11:18:23 <idnar> heh
11:20:35 <ehird`_> @src not
11:20:35 <lambdabot> not True   =  False
11:20:35 <lambdabot> not False  =  True
11:22:25 <idnar> @type not
11:22:27 <lambdabot> Bool -> Bool
11:23:14 <mauke> @check id `asTypeOf` not
11:23:16 <lambdabot>  Falsifiable, after 4 tests: False
11:23:22 <mauke> 4?!
11:23:34 <Deewiant> @ty id `asTypeOf` not
11:23:35 <lambdabot> Bool -> Bool
11:23:39 <Deewiant> hm
11:23:50 <Deewiant> True, undefined, ?, False
11:23:51 <idnar> > id `asTypeOf` not $ True
11:23:59 <lambdabot>  True
11:24:02 <idnar> > id `asTypeOf` not $ False
11:24:03 <lambdabot>  False
11:24:11 <idnar> > id `asTypeOf` not $ undefined
11:24:15 <lambdabot>  Undefined
11:24:41 <Saizan> id is strict :)
11:24:48 <idnar> indeed
11:25:07 <olsner> and not is not?
11:25:26 <idnar> @check id :: (Bool -> Bool)
11:25:27 <lambdabot>  Falsifiable, after 3 tests: False
11:25:49 <lament> 3 tests?
11:26:19 <mauke> @scheck id `asTypeOf` not
11:26:21 <lambdabot>   Failed test no. 2. Test values follow.: False
11:26:27 <olsner> what is it that it's testing? does check know that id should follow id x == x?
11:26:27 <dolio> @check \b -> collect (b :: Bool) $ b
11:26:28 <lambdabot>  Falsifiable, after 4 tests: False
11:27:07 <Deewiant> @check \b -> id b != b
11:27:08 <lambdabot>   Not in scope: `!='
11:27:12 <Deewiant> @check \b -> id b /= b
11:27:12 <lambdabot>  Add a type signature
11:27:19 <Deewiant> @check \b -> id b /= (b::Bool)
11:27:20 <lambdabot>  Falsifiable, after 0 tests: False
11:27:28 <idnar> olsner: it's checking that id returns True
11:27:44 <idnar> (which, of course, it doesn't do if you pass it False)
11:28:01 <idnar> @check \x -> x == id x
11:28:01 <lambdabot>  Add a type signature
11:28:13 <idnar> @check \x -> x == id x :: (Bool -> Bool)
11:28:14 <lambdabot>  Couldn't match expected type `Bool -> Bool'
11:28:39 <idnar> @check (\x -> x == id x) :: (Bool -> Bool)
11:28:40 <lambdabot>  OK, passed 500 tests.
11:29:27 <Deewiant> :: binds more tightly than ->? damn
11:29:31 <ski> @scheck False
11:29:32 <lambdabot>   Failed test no. 1. Test values follow.:
11:30:11 <roconnor> @scheck True
11:30:12 <lambdabot>   Completed 1 test(s) without failure.
11:30:56 <olsner> idnar: Aaah! of course, what check really checks is (a -> Bool) and expects it to be true
11:35:58 <jedbrown> @check ((\f a -> f a == f a) :: (Double -> Bool) -> Double -> Bool)
11:36:02 <ehird`> damn, it's impossible to write `instance Monad Void`
11:36:02 <lambdabot> Terminated
11:36:03 <ehird`> )
11:37:15 <ehird`> that's a shame
11:37:36 <ski> ehird` : yes, of course. kind error
11:37:45 <ehird`> ski: yeah
11:37:50 <ehird`> but i want my void monad! :)
11:37:55 <ehird`> actually, I want a (Num a) => Monad a
11:37:59 <ehird`> akin to the list monad
11:38:00 <ehird`> :P
11:38:07 <ski> ehird` : there already is a "Void" monad
11:38:15 <ski> it's called "Identity"
11:38:27 <ski> @index Identity
11:38:28 <lambdabot> Control.Monad.Identity, Control.Monad.Identity
11:38:33 <ski> @hoogle Identity
11:38:33 <lambdabot> Control.Monad.Identity :: module
11:38:33 <lambdabot> Control.Monad.Identity.Identity :: newtype Identity a
11:38:33 <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a
11:38:38 <bd_> darcs.haskell.org is a bit slow (25 kB/s...), is there a better source for the GHC HEAD tarballs?
11:38:53 <ehird`> no
11:38:57 <ehird`> the Void monad is a black hole
11:38:59 <ehird`> where nothing but Void is known
11:39:14 <dolio> What's the 'data Foo a = Foo' monad called?
11:40:25 <dolio> Not that that's a useful monad.
11:41:11 <dolio> Or, it may well be, I don't know.
11:42:04 <twanvl> dolio: That is a special case of the constant monad, data Const c a = Const c
11:42:28 <ski> dolio : almost `Const ()', i suppose
11:43:30 <dolio> I suppose you could maybe run 'BarT (Const ())' just for the Bar side effects, ensuring that nobody actually used any values.
11:43:37 <ski> ehird` : in `Identity', nothing but `return' is known
11:43:52 <ski> void :: Void -> a
11:44:03 <dolio> Because otherwise you'd get bottoms.
11:44:10 <ehird`> ski: void is a -> Void
11:44:10 <ehird`> :|
11:44:20 <ski> no
11:44:25 <ehird`> void v = case v of {}
11:44:28 <ski> yes
11:44:33 <ski> v :: Void
11:44:38 <ehird`> er, no..
11:44:42 <ehird`> 'void' is how you get a void.
11:44:50 <ehird`> void = (const identity) :: (a -> Void)
11:44:52 <ehird`> err
11:44:52 <ski> the type of `case v of {}' must be the type of the result of every branch ..
11:44:56 <ehird`> s/identity/undefined/
11:45:04 <ski> .. but since there is no branch, that type is unconstrained
11:45:06 <ski> so
11:45:10 <ski> void :: Void -> a
11:45:14 <ehird`> ski: ... since there's no branch, it's the mythical "Void"
11:45:22 <pheaver> I'm having a terrible time getting Cabal to use a .buildinfo file that is generated by autoconf.
11:45:44 <dolio> @djinn Void -> a
11:45:44 <lambdabot> f = void
11:45:58 <pheaver> when I run "runhaskell Setup.hs build", I often get the message "Setup.hs: 'parseField' called on a non-field.  This is a bug.", even though my .buildinfo file looks syntactically correct.
11:46:07 <ski> ehird` : i agree that your `const undefined' is another .. but i argue that it isn't natural here
11:46:18 <ehird`> ski: it happens to be valid haskell..
11:46:21 <ehird`> @djinn a -> Void
11:46:22 <lambdabot> -- f cannot be realized.
11:46:30 <ski> ehird` : so ?
11:46:31 <ehird`> @type (\v -> undefined :: Void)
11:46:37 <lambdabot> Not in scope: type constructor or class `Void'
11:46:43 <ehird`> @data Void
11:46:44 <lambdabot> Unknown command, try @list
11:46:46 <ehird`> hmph
11:46:49 <ehird`> how do I get Void
11:46:52 <pheaver> it seems like only a subset of .cabal syntax is supported in a .buildinfo file.  So, I stripped out a bunch of stuff, so now it parses the .buildinfo file... but now it just ignores all the options in it (when I do runhaskell Setup.hs build -v, none of the flags set in .buildinfo are getting passed to ghc)
11:46:57 <ehird`> ski: well, ok, how about this:
11:47:04 <ehird`> void :: Void
11:47:06 <ehird`> void = undefined
11:47:07 <ski> void = (const undefined) :: (Void -> a)  -- is also valid haskell
11:48:16 <ehird`> ski: But of course there's no way to use 'void', at all.
11:48:16 <ehird`> And therefore no way to get a Void out
11:49:09 <ehird`> void = undefined :: Void
11:49:13 <ehird`> i think that's the cleanest
11:49:46 <dolio> Cleanest what?
11:50:10 <ehird`> definition
11:50:27 <dolio> Isn't void the catamorphism for Void, though?
11:50:43 <dolio> Just like maybe is the Maybe catamorphism, and either is for Either.
11:51:09 <ski> the point of using `void :: Void -> a' is to encode that, since there shouldn't be a value of type `Void', it doesn't matter if we say we can return a value of any type `a', since this function will never be executed (barring bottoms) ..
11:51:25 <ski> `void' is to `Void' as `either' is to `Either'
11:51:29 <ski> @type either
11:51:31 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:52:19 <ehird`> void :: Void -> a
11:52:19 <ehird`> void = const undefined
11:52:19 <ehird`> aVoid :: Void
11:52:19 <ehird`> aVoid = void aVoid :: Void
11:52:22 <ehird`> :D
11:53:02 <ski> `either' takes two branches, each converting one of the (two) alternatives into the common result, and gives a new function that takes something that contains one of the (two) alternatives, and converts it into the common result
11:53:24 <ski> `void' takes zero branches, each converting one of the (zero) alternatives into the common result, and gives a new function that takes something that contains one of the (zero) alternatives, and converts it into the common result
11:53:25 <resiak> let laDisparition = aVoid
11:54:33 <ski> anyway, i mentioned `Identity' as the `Void' of monads since
11:54:40 <ehird`> ok
11:54:40 <ehird`> now
11:54:45 <ehird`> in lambdabot, how do I get the Void type
11:55:04 <dolio> You don't. There's no Void type defined in Haskell.
11:55:30 <ehird`> dolio: other people have it.
11:55:46 <ehird`> @djinn-env
11:55:46 <lambdabot> data () = ()
11:55:46 <lambdabot> data Either a b = Left a | Right b
11:55:46 <lambdabot> data Maybe a = Nothing | Just a
11:55:46 <lambdabot> data Bool = False | True
11:55:46 <lambdabot> data Void
11:55:48 <lambdabot> type Not x = x -> Void
11:55:48 <ehird`> hmm
11:55:50 <lambdabot> class Eq a where (==) :: a -> a -> Bool
11:55:56 <ehird`> well, djinn has it
11:55:59 <ehird`> @djinn Void
11:55:59 <lambdabot> -- f cannot be realized.
11:56:02 <ski> void   :: forall (a :: *).  Void -> a
11:56:04 <ski> return :: forall (m :: * -> *). Monad m =>  Identity -> m  -- note, this denotes a natural transformation
11:56:06 <ehird`> @djinn Void -> a
11:56:07 <lambdabot> f = void
11:56:10 <dolio> djinn isn't Haskell.
11:56:14 <ehird`> dolio: true
11:56:16 <ehird`> but still.
11:56:19 <ski> return :: forall (m :: * -> *) (a :: *). Monad m =>  Identity a -> m a -- actuall haskell typing
11:56:22 <ehird`> @djinn Not Void
11:56:22 <lambdabot> f a = a
11:56:28 <ehird`> @djinn Not (Not Void)
11:56:29 <lambdabot> -- f cannot be realized.
11:56:34 <litb> hello
11:56:41 <ski> @djinn (a -> b) -> (Not b -> Not a)
11:56:41 <lambdabot> f a b c = b (a c)
11:56:48 <ski> @djinn (a -> Not b) -> (b -> Not a)
11:56:49 <lambdabot> f a b c = a c b
11:57:04 <ski> @djinn (Not a,Not b) -> Not (Either a b)
11:57:05 <lambdabot> f (a, b) c =
11:57:05 <lambdabot>     case c of
11:57:05 <lambdabot>     Left d -> a d
11:57:05 <lambdabot>     Right e -> b e
11:57:18 <ski> @djinn Either (Not a) (Not b) -> Not (a,b)
11:57:18 <lambdabot> f a =
11:57:18 <lambdabot>     case a of
11:57:18 <lambdabot>     Left b -> \ (c, _) -> b c
11:57:18 <lambdabot>     Right d -> \ (_, e) -> d e
11:57:52 <ski> (that's some examples of djinn with `Not')
11:58:37 <ehird`> @djinn Not a => a
11:58:37 <lambdabot> Cannot parse command
11:58:51 <ehird`> @djinn Not a -> Not b -> Not (a,b)
11:58:52 <lambdabot> f a _ (b, _) = a b
11:59:03 <ehird`> @djinn Void -> Not Void
11:59:06 <lambdabot> f = void
12:00:47 <ehird`> is there no way to introduce a datatype into >
12:03:53 <jedbrown> FFTW package available for testing: darcs get http://59A2.org/code/fft
12:05:28 <jedbrown> I filled out the web form at community.haskell.org a couple weeks ago, but still no response and my ssh key doesn't work.  Is that normal?
12:06:01 <jedbrown> I submitted another request earlier today.
12:08:02 <faxathisia> ehird, not with lambabot
12:08:16 <faxathisia> ehird, You can run djinn on it's own though
12:08:18 <faxathisia> its :S
12:08:40 <ski> @help djinn-add
12:08:40 <lambdabot> djinn-add <expr>.
12:08:40 <lambdabot> Define a new function type or type synonym
12:09:07 <ski> @djinn-add type NotNot a = Not (Not a)
12:09:29 <ski> @djinn ((a -> b) -> a) -> a
12:09:30 <lambdabot> -- f cannot be realized.
12:09:35 <ski> @djinn NotNot (((a -> b) -> a) -> a)
12:09:35 <lambdabot> f a =
12:09:35 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
12:09:43 <ehird`> i want to introduce it to > abc
12:09:46 <ehird`> not @djinn
12:09:54 <faxathisia> @let abc = "abc"
12:09:55 <lambdabot> Defined.
12:09:56 <faxathisia> > abc
12:09:57 <lambdabot>  "abc"
12:10:03 <ehird`> @djinn-add data WTF = WTF WTF WTF WTF deriving (Show)
12:10:04 <nominolo> jedbrown: no, not normal
12:10:09 <dmwit> That's not a datatype at all.
12:10:15 <ski> ehird` : sorry, i don't think one can define new types in lambdabot
12:10:16 <ehird`> dmwit: i know that
12:10:16 <ehird`> :P
12:10:28 <dmwit> (I was talking to faxathisia.)
12:10:33 <ehird`> dmwit: i know that
12:10:38 <ehird`> @djinn WTF -> WTF
12:10:39 <lambdabot> Cannot parse command
12:10:39 <lambdabot> f :: WTF -> WTF
12:10:39 <lambdabot> f a = a
12:10:40 <pheaver> is there a way to specify flags to ./configure in the .cabal file?  Kind of like the --configure-option flag, but specified in .cabal instead of the command line.
12:10:50 <jedbrown> nominolo: Who should I bug?  Or should I wait a few days now that I resubmitted?
12:10:51 <ehird`> @djinn WTF a b c d -> WTF d c b a
12:10:51 <lambdabot> Cannot parse command
12:10:51 <lambdabot> -- f cannot be realized.
12:11:04 <Cin> pheaver: didn't you ask that question, verbatim, like yesterday?
12:11:11 <Cin> pheaver: (i don't know the answer, btw)
12:11:31 <nominolo> jedbrown: yes, if you re-submitted better wait one more day
12:12:00 <pheaver> Cin: no i did not
12:12:34 <pheaver> Cin: I have asked a lot of Cabal questions, but not that one, and most went unanswered :)
12:12:48 <ski> ehird` : djinn can't handle recursive types
12:12:51 <jedbrown> nominolo: No problem, I'll be patient.
12:13:13 <nominolo> jedbrown: btw, do you mean hackage or community.haskell.org ?
12:14:03 <ehird`> ski: sheesh, how lame
12:14:04 <ehird`> :)
12:14:42 <jedbrown> nominolo: Perhaps I'm confused.  I thought you needed a community.h.o account to upload to hackage.
12:14:50 <dolio> @djinn-add type Cont r a = (a -> r) -> r
12:15:33 <jedbrown> nominolo: But now I'm looking at hackage, and it says I need to send ross@soi.city.ac.uk an email.
12:16:17 <nominolo> jedbrown: no community.h.o is for hosting code on code.h.o.  for hackage you just need to get an account from ress
12:16:20 <nominolo> *Ross
12:17:08 <jedbrown> nominolo: Ah, I'm sending an email now.
12:18:06 <Taejo> is there a way to force evaluation of a whole list when a single element is evaluated?
12:18:34 <Taejo> like "a `seq` b `seq` c `seq` [a, b, c]" but without naming a, b and c
12:19:08 <mauke> > foldr seq () [1 .. 10]
12:19:12 <lambdabot>  ()
12:19:19 <mauke> > foldr seq z [1 .. 10]
12:19:19 <lambdabot>  z
12:19:25 <mauke> heh
12:19:32 <Taejo> handy
12:19:47 <mauke> I don't think that's right
12:19:56 <Taejo> ok
12:20:28 <mauke> but I might be confused
12:20:30 <dolio> > let dep l = foldr seq l l in head (dep [1,2,3,undefined,4])
12:20:31 <lambdabot>  Undefined
12:20:43 <dolio> > let dep l = foldr seq l l in head (dep [1,2,3,5,4])
12:20:44 <lambdabot>  1
12:21:11 <dolio> > let dep l = foldr seq l l in dep [1,2,3,undefined,4] !! 4
12:21:12 <lambdabot>  Undefined
12:21:41 <dolio> Looks like that works.
12:21:46 <ski> > null (let dep l = foldr seq l l in head (dep [1,2,3,5,4]))
12:21:47 <lambdabot>   add an instance declaration for (Num [a])
12:21:47 <lambdabot>     In the expression: 1
12:21:56 <ski> > null (let dep l = foldr seq l l in dep [1,2,3,5,4])
12:21:57 <lambdabot>  False
12:22:19 <dolio> Hmm.
12:23:24 <ski> > null (let dep l = foldr seq l l in dep [1,2,3,undefined,4])
12:23:26 <lambdabot>  Undefined
12:23:35 <ski> so, doesn't work
12:23:45 <dolio> It ties it to the list, not to the elements.
12:23:54 <dolio> But so did his example.
12:24:02 <ski> (unless you want it to also evaluate the elements whenever the skeleton is inspected)
12:24:15 <ski> hm, yes
12:26:34 <dolio> To tie just the elements together, you need something like: [b `seq` c `seq` a, c `seq` a `seq` b, a `seq` b `seq` c]
12:28:00 <resiak> would   map (\a -> foldr seq a xs) xs   do the job?
12:28:06 * ski was pondering a map
12:28:09 <ehird`> > undefined :: String
12:28:11 <ski> !
12:28:18 <dolio> It looks promising.
12:28:21 <lambdabot>  Undefined
12:28:35 <resiak> obviously evaluating any element will force the skeleton, but that's inevitable
12:29:16 <dolio> let dep l = map (\a -> foldr seq a l) l in null (dep [1,2,3,undefined,5])
12:29:29 <dolio> > let dep l = map (\a -> foldr seq a l) l in null (dep [1,2,3,undefined,5])
12:29:31 <lambdabot>  False
12:29:35 <resiak> woo
12:29:39 <dolio> > let dep l = map (\a -> foldr seq a l) l in head (dep [1,2,3,undefined,5])
12:29:40 <lambdabot>  Undefined
12:29:47 <Taejo> is it possible to see the results of GHC's strictness analysis without learning to read Core?
12:29:48 <dolio> Yep.
12:30:02 * resiak adds dep to his 'neat tricks' tomboy
12:31:19 <Taejo> because at -O2, my code is fast enough that I wouldn't bother (it was unusable in GHCi)
12:32:18 <yrlnry> I have a weird question.  It's about how to do something that I think is impossible, and the thing I'm trying to do is pretty strange.  But if it *is* possible I don't want anyone to tell me how to do it.
12:32:49 <jedbrown> > let a = [1,2,undefined,3] in rnf a `seq` head a
12:32:50 <lambdabot>  Undefined
12:33:21 <yrlnry> I want a function that behaves something like `fix`, except that when after you do strangefix f arg  it not only returns that same value that fix f arg would have, but it also prints out how many times f was called in the process.
12:33:24 <jedbrown> resiak: ^^^ another way to do it.
12:34:04 <yrlnry> My original idea was that it should be able to manufacture an f' that is like f, but increments a counter, and then fix f'.  But all my efforts are coming to naught.
12:34:11 <resiak> > let a = [1,2,undefined,3] in rnf a `seq` head a
12:34:12 <lambdabot>  Undefined
12:34:15 <EvilTerran> yrlnry, unfortunately, that doesn't really make sense
12:34:24 <resiak> so that doesn't do the same thing
12:34:26 <yrlnry> That's what I was beginning to think.
12:34:30 <ehird`> wowzers
12:34:35 <yrlnry> Please tell me why it doesn't really make sense.
12:34:37 <ehird`> with 'coerce' and 'Void' you can pack arbitary values into a Void
12:34:42 <Taejo> yrlnry: sounds possible, though you might need unsafePerformIO
12:34:47 <EvilTerran> as it's possible for a function to be called a "fractional" number of times in a lazy language, depending on how you look at it
12:34:50 <ehird`> and then coerce them out again
12:34:57 <ehird`> infinite values in 0 size!
12:35:10 <jedbrown> resiak: It's a deep seq.  The syntax is a little different, but it's more flexible.
12:35:16 <ehird`> actually, coerce is weird
12:35:18 <ehird`> coerce (
12:35:19 <ehird`> err
12:35:23 <ehird`> coerce (\x -> x) :: a -> b
12:35:24 <jedbrown> resiak: i.e. not limited to list.
12:35:26 <EvilTerran> yrlnry, what about something like
12:35:28 <ehird`> gives you an entirely new 'coerce'
12:35:33 <Taejo> ack, missed out a whole chunk of conversation
12:35:43 <yrlnry> >>  But if it *is* possible I don't want anyone to tell me how to do it.
12:36:11 <EvilTerran> > takeWhile (uncurry.(/=)) . (zip <*> tail) . (`iterate` 0) $ (+1) . (1/)
12:36:12 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Bool'
12:36:38 <EvilTerran> > takeWhile (uncurry (/=)) . (zip <*> tail) . (`iterate` 0) $ (+1) . (1/)
12:36:39 <resiak> jedbrown: yeah, so we could let dep l = map (\a -> rnf l `seq` a) l   to get the desired behaviour
12:36:39 <lambdabot>  [(0.0,Infinity),(Infinity,1.0),(1.0,2.0),(2.0,1.5),(1.5,1.6666666666666667),...
12:36:47 <EvilTerran> > last . takeWhile (uncurry (/=)) . (zip <*> tail) . (`iterate` 0) $ (+1) . (1/)
12:36:47 <lambdabot>  (1.6180339887498947,1.618033988749895)
12:37:02 <ehird`> > f . h
12:37:03 <lambdabot>  Add a type signature
12:37:04 <ehird`> > f . g
12:37:04 <EvilTerran> > length . takeWhile (uncurry (/=)) . (zip <*> tail) . (`iterate` 0) $ (+1) . (1/)
12:37:04 <lambdabot>  Add a type signature
12:37:05 <lambdabot>  41
12:37:07 <ehird`> grr
12:37:09 <ehird`> when will compositions work
12:37:12 <shapr> Wow, my brain nearly exploded for a sec, I thought this was ##csharp
12:37:18 <ehird`> > let foo = f . g in foo :: Expr
12:37:18 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> c'
12:37:27 <ehird`> shapr: welp, C# is generally assimilating haskell features
12:37:36 * resiak delegates shapr 
12:37:37 <ehird`> > let foo = f . g in foo 1 :: Expr
12:37:38 <lambdabot>  Add a type signature
12:37:45 <ehird`> > let f = const 2 in f
12:37:46 <lambdabot>  Add a type signature
12:37:47 <ehird`> > let f = const 2 in f :: Expr
12:37:48 <lambdabot>  Couldn't match expected type `Expr' against inferred type `b -> t'
12:37:50 <ehird`> > let f = const 2 in f 3 :: Expr
12:37:51 <lambdabot>  2
12:38:37 <EvilTerran> yrlnry, also, the result of fix f will quite possibly result in f being evaluated an infinite number of times if you evaluate it in full
12:38:56 <ehird`> > let mc91 n | n > 100 = n - 10; mc91 n | n <= 100 = mc91 (mc91 (n+11)) in mc91 87 :: Expr
12:38:58 <lambdabot>  87 + 11 + 11 - 10 + 11 - 10 + 11 - 10 - 10 + 11 - 10 + 11 - 10 + 11 - 10 + 1...
12:39:05 <ehird`> > let mc91 n | n > 100 = n - 10; mc91 n | n <= 100 = mc91 (mc91 (n+11)) in mc91 99 :: Expr
12:39:06 <lambdabot>  99 + 11 - 10 + 11 - 10 - 10
12:39:21 <hpaste>  magnusth pasted "Bug in regEnumKeys?" at http://hpaste.org/5666
12:39:43 <EvilTerran> yrlnry, if you're looking at things like converging numeric sequences, fix won't do what you want anyway
12:40:06 <EvilTerran> > let x = 1 + 1/x in x -- for the same reasons this doesn't work
12:40:07 <lambdabot>  Exception: <<loop>>
12:40:31 <magnusth> I get a segmentation fault in the code I pasted (hpaste.org/5666), am I doing something wrong or is it an error in the system module?
12:40:46 <dolio> > let dep l = let a = foldr seq () l in map (seq a) l in null (dep [1,2,3,undefined,5])
12:40:47 <lambdabot>  False
12:40:50 <EvilTerran> a segfault is always a bug
12:40:53 <ehird`> > let x = 1 + 1/x in x :: Expr
12:40:54 <lambdabot>  1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + 1 / (1 + ...
12:40:55 <dolio> > let dep l = let a = foldr seq () l in map (seq a) l in head (dep [1,2,3,undefined,5])
12:40:56 <lambdabot>  Undefined
12:40:57 <sclv_> I finally wrote my first why monoids are cool post that I've been meaning to. I'd appreciate any comments, especially on how I screwed up on the mathy stuff :-). http://fmapfixreturn.wordpress.com/2008/02/14/on-monoids/ </blogspam>
12:40:58 <lambdabot> Title: On Monoids  fmap fix return
12:41:02 <ehird`> OH YES IT DOES WORK :|
12:41:05 <magnusth> EvilTerran: even if I'm doing something silly?
12:41:22 <EvilTerran> even if you're doing something silly. it should fail gracefully.
12:41:28 <ehird`> EvilTerran: it's internal win32 stuff if you look
12:41:35 <ehird`> i'm not suprised that w32 internals would do stuff like that
12:41:37 <magnusth> ah, yes, of course this is Haskell, not C :)
12:42:06 <dolio> > let dep l = let a = foldr seq () l in map (seq a) l in head (dep [1,2,3,undefined,5]) -- <- resiak, O(n)
12:42:08 <lambdabot>  Undefined
12:42:08 <magnusth> ehird`: well, arguably the Haskell bindings should introduce some assurance, even on Windows, right?
12:42:10 <EvilTerran> ah. windows. all bets're off, then. :)
12:42:32 <dolio> > let dep l = let a = foldr seq () l in map (seq a) l in last (dep [1,2,3,undefined,5])
12:42:33 <lambdabot>  Undefined
12:42:42 <dolio> > let dep l = let a = foldr seq () l in map (seq a) l in (dep [1,2,3,undefined,5]) !! 2
12:42:43 <lambdabot>  Undefined
12:42:49 <resiak> dolio: hmm
12:42:53 <ehird`> magnusth: they seem to be intended for low-level, unrestricted manipulation
12:43:00 <ehird`> if you look they seem to be direct w32api wrappers.
12:43:36 <magnusth> ehird`: yes, but I'm still getting very strange behaviour out that particular call (regEnumKeys), sometimes it works, sometimes not
12:44:39 <sclv_> > ((f :: Expr -> Expr). g $ a) :: Expr
12:44:40 <lambdabot>  f (g a)
12:44:48 <ehird`> magnusth: look at its docs?
12:45:03 <conal> sclv_: nice! monoids are cool indeed!  :)
12:45:04 <magnusth> ehird`: you mean the source, or just the module docs?
12:45:06 <jedbrown> dolio: And replace the fold with rnf if you want the strictness to penetrate the list elements.
12:45:20 <ehird`> magnusth: both
12:45:37 <dolio> jedbrown: Yeah, that too.
12:45:57 <ttfh> magnusth: regEnumKeys? I played around with that a couple of weeks ago and got crashes to
12:47:00 <conal> sclv_: is your blog on planet haskell?  i don't remember seeing your posts.
12:47:09 <magnusth> ttfh: did you report a bug?
12:47:28 <jedbrown> > let dep l = let a = foldr seq () l in map (seq a) l in (dep [[1],[2],[undefined],[5]]) !! 1
12:47:29 <dolio> resiak: The old one was O(n^2) because it was folding through the whole list for each element.
12:47:29 <lambdabot>  [2]
12:47:32 <jedbrown> > let dep l = let a = rnf l in map (seq a) l in (dep [[1],[2],[undefined],[5]]) !! 1
12:47:33 <ttfh> magnusth: no, I gave up :-(
12:47:34 <lambdabot>  Undefined
12:47:46 <resiak> dolio: oh!  good point!
12:47:46 <magnusth> ehird`: can't see anything obviously wrong, but I'm a Unix-person trapped in a Window :(
12:48:33 <magnusth> ttfh: ah, well, I circumvented it in order to get my job done, but the thing is bugging me
12:49:01 <magnusth> ttfh: did you see the code I pasted? (hpaste.org/5666)
12:49:02 <ttfh> the stuff in System.Win32.Registry are just wrappers for the Win32 API functions, but I have succesfully written c programs that look at keys, as well as a partial lua binding
12:49:19 <ttfh> trapped in windows, me too
12:49:40 <magnusth> ttfh: I was considering reaching for Python, but I've taken an oath
12:50:14 <ttfh> what do you want to do, just look at keys?
12:50:58 <magnusth> ttfh: list all keys recursively from a point in the registry, then I'm passing that into another tool to pull out the security descriptors (SDDL)
12:52:00 <ttfh> I have never used the haskell FFI, but you could write your own wrappers, then you get the "bonus" of working with the win32 API
12:52:01 <magnusth> regEnumKeys seems to be a utility function that uses the Win32 wrapper... somewhere something goes wrong, but I'm not very comfortable on Windows (part of the reason why i wanted to use Haskell :)
12:53:05 <magnusth> ttfh: yeah, I did that for some other stuff I needed that wasn't covered... I might go that route for now, but I'll raise it as a bug, since I apparently aren't doing something really stupid
12:54:10 <ttfh> the win32 api looks like a mess to me, functions with 10 parameters, some are both in and out parameters, the function does different things depending on the arguments, this has bit me in the ass already...
12:55:11 <shepheb> mjf: sorry, back. didn't see anything after you mentioned the FAQ and wiki there.
12:55:23 <ray> ttfh: don't most functions do different things depending on the arguments?
12:55:26 <shepheb> whoops again, that was for #xmonad.
12:55:35 <aFlag> magnusth, you took a oath not to use python?
12:56:02 <ttfh> ray: hehe
12:56:45 <sclv_> conal: I just got started with it, so not its not up there yet.
12:56:57 <aFlag> my functions just return 33
12:57:01 <aFlag> all of them
12:57:10 <ttfh> ray: I mean that functionality that should really be separate functions are in the same function
12:57:13 <magnusth> ttfh: yeah, the Windows API give me nightmares...
12:57:45 <magnusth> aFlag: I thought I'd grow as a person if I could ditch Python in favour of Haskell :-)
12:57:50 <mahogny> windows might let you invoke force majeure
12:58:19 <ttfh> magnusth: there is a command line tool that looks in the registry, you could run that and read its output
12:58:28 <conal> sclv_: glad to know.  meanwhile, i've added it to my reader.  looking forward to more.
12:58:33 <shapr> magnusth: Good idea! I tried that, it worked for me!
12:58:52 <magnusth> ttfh: hmm, what tool?
12:59:33 <pjd> sclv_: great post!
12:59:44 <ray> i ditched lisp for haskell and didn't really grow as a person
12:59:57 <ray> unless you count my appreciation for a good type system
13:00:00 <gwern> ray: were you expecting moral enlightenment?
13:00:11 <ray> no
13:00:11 <magnusth> shapr: yeah, it's not easy though... being familiar with Python and its modules I find that I have a Python solution worked out in my head before I even get past the what-type-do-I-use in Haskell
13:00:12 <ttfh> magnusth: reg.exe, I think it's included in some "tools"-package, its a free download, I'll se if I can find it
13:00:25 <ray> it didn't involve any mountain treks, so i didn't expect enlightenment
13:00:32 <ehird`> hmmm, damn
13:00:38 <ehird`> my page mapping is going to be uglier than i thugh
13:00:45 <gwern> that could be our new selling point. 'I ditched Python for Haskell, and now I am free of my earthly desires for IO and am free of karama and the Wheel of Side-effects'
13:00:52 <monochrom> did it involve monad treks? :)
13:00:58 <faxathisia> ray: I use both
13:01:21 <ray> well if you want to get all technical like that i've never stopped using C
13:01:23 <magnusth> ttfh: cool, I'll have to have a look... though I was almost having wet dreams about writing up a small set of Haskell tools for dealing with SDs
13:01:26 <sclv_> thanks guys. this has been percolating in by brain for a while now.
13:01:37 <faxathisia> sclv, nice post btw
13:01:37 <conal> ray: are you focusing on *purely* functional (no IO) haskell programming?  that's where i'd expect you to get something really new.
13:01:38 <shapr> magnusth: Just keep it up! I ended up being FAR more happy with Haskell than with Python.
13:02:26 <ray> conal: essentially
13:02:48 <magnusth> shapr: yes, I don't doubt it's a good thing in the long run, it's just that the barrier of entry to some modules is /steep/ to say the least... sometimes it's like I have Mt Everest in front of me, and all I wanted to do was parse a measly little XML file
13:02:55 <hpaste>  ehird pasted "initial, crappy Webmonad mockup" at http://hpaste.org/5667
13:03:01 <ehird`> hm
13:03:04 <ehird`> s/first v/n
13:03:25 <ehird`> (yes, runWeb is a terrible name for that)
13:03:51 <sclv_> is this inspired by alpheccar's stuff?
13:03:51 <gwern> webmonad... why does hat sound familiar?
13:03:51 <Taejo> and so, once again, the day is saved... by []
13:04:24 <ehird`> gwern: i've plugged it before but haven't actually had any mockups :)
13:04:30 <ehird`> it's been swirling in my head for a while, at least
13:04:43 <ehird`> if you'll look at it you'll instantly see the Seaside similarity... but IMO it's more elegant
13:04:47 <gwern> ehird`: ah. so it must be your blog posts I'm thinking of
13:04:50 <ehird`> -- it doesn't seperate components and tasks, for example
13:04:58 <ehird`> gwern: i have no blog to speak of, at the moment
13:05:04 <ehird`> why do you think I'm writing Webmonad? haha ;)
13:05:15 <ehird`> sclv_: probably not... what stuff
13:05:18 <Cin> counter n = do h1 (show v)  -- where's `v' defined?
13:05:24 <ehird`> hmm
13:05:28 <ehird`> [(String,WebM ())]
13:05:30 <ehird`> is the correct decl
13:05:33 <ehird`> Cin: replace it with n
13:05:37 <ehird`> v was the old name for that
13:05:38 <ehird`> sorry
13:05:39 <Cin> oki ;)
13:05:55 <ehird`> i might do   type WebMap = [(String,WebM ())]
13:06:41 <ehird`> actually, the second argument should really be totally polymorphic -- for when you specify placeholders in the URL, as function arguments. :-P
13:06:52 <ehird`> yeah, maybe a simple list isn't the best way, hehe
13:07:24 <ray> oh, here i thought a web was some kind of fancy data structure :(
13:07:49 <Cin> hur hur
13:07:58 <ehird`> ray: heh
13:08:04 <ehird`> well, i could represent it as such :p
13:08:39 <ehird`> actually, the 'little web' of the app is probably represented exactly like that, it's just invisible because of the function mapping
13:08:52 <sclv_> ehird`: http://www.alpheccar.org/en/posts/show/89
13:08:54 <lambdabot> Title: Web Objects and the underappreciated recursive do
13:10:26 <ehird`> sclv_: that's pretty similar but it's really a common kind of idea, just not inside haskell
13:10:33 <ehird`> also, mine is far more 'functional'
13:10:57 <ehird`> which i personally think is nicer, i am open to reasons why it might not be the best
13:11:19 <ehird`> well, the type signatures I'd need are pretty nice :-P
13:11:24 <shapr> magnusth: Got any questions? Since I transitioned directly from Python to Haskell, I might be able to help.
13:11:50 <ehird`> actions :: [WebM a] -> ??? -- where ??? is my 'html output' type
13:12:06 <ehird`> actually, no
13:12:16 <ehird`> actions :: [WebM a] -> WebM a
13:12:39 <ehird`> button :: String -> WebM a -> WebM a
13:12:44 <ehird`> *should* be about right
13:14:00 <ehird`> http://www.alpheccar.org/en/posts/show/87 I'm glad I have "The" and a space as diff between the names :P
13:14:03 <lambdabot> Title: A Web Monad
13:14:24 <ehird`> welp, all my projects are named <something>monad :-P
13:14:43 <gwern> @hoogle regex
13:14:43 <lambdabot> No matches found
13:17:16 <ehird`> hm
13:17:23 <ehird`> any suggestions on how to handle parameters in the URL?
13:17:28 <ehird`> i'm considering the dirt simple:
13:17:34 <ehird`> "str/$/blah" <-- $ is the parameter
13:17:43 <ehird`> but then the obvious abstraction is (\x -> ...)
13:17:49 <ehird`> and that's not a WebM (), so can't go into the map
13:19:08 <sclv_> I'm a bit confused. so there's a server and it gets a request. then what does it call? runWeb on something of webM a, right?
13:19:10 <magnusth> shapr: nothing right now, but thanks, I'll take you up on that at a later date :)
13:19:22 * magnusth is off to enjoy Valentine's day
13:20:04 <sclv_> and runWeb can encompass multiple interactions, etc?
13:20:07 <ehird`> sclv_: it's a continuation&closure-based webserver
13:20:12 <sclv_> maybe I'm thinking too low level here.
13:20:18 <ehird`> and if you look at runWeb's definition it just makes counter's WebM Integer into a WebM ()
13:20:27 <ehird`> runWeb a = a >> return ()
13:20:32 <ehird`> (Yes, crap name)
13:20:43 <ehird`> sclv_: Let's put it this way - WebM includes a ContT somewhere along the line
13:20:50 <ehird`> you see 'button'?
13:21:03 <ehird`> the second argument is given a randomly generated id - like F9848FAHD3DH3
13:21:16 <ehird`> and stored in memory, then a button is sent out in a form with something like
13:21:50 <gwern> @hoogle copyCString
13:21:51 <lambdabot> No matches found
13:21:57 <ehird`> <form action="/counter" method="POST"><input type="hidden" name="_cid" "F9848FAHD3DH3" /><input type="submit" value="++" /></form>
13:22:06 <ehird`> then, when that's hit, the server looks up that closure, and sees it is:
13:22:11 <ehird`> counter (n+1)
13:22:26 <ehird`> so, we run that -- which ends up displaying the form again (but, ofc, with 1 added to the counter)
13:22:41 <sclv_> right. I get that part.
13:22:50 <ehird`> when it finally returns, addTwo gets it because we look up the continuation we made and go there.
13:23:16 <jedbrown> gwern: what are you looking for?
13:23:19 <ehird`> sclv_: and of course you can compose components and stuff
13:23:33 <ehird`> you could have a MenuComponent, then a BlogComponent, then a RedditRipoffComponent
13:23:41 <ehird`> they can all be on the same page and interact independently
13:23:47 <ehird`> an example, from Seaside:
13:23:54 <ehird`> http://seaside.st/about/examples/multicounter?27&_k=lvqPOudr&_n&_s=VxgwXDzETiLMbBwm
13:24:30 <ehird`> (interesting note: if you made it so that counters displayed an error with an OK button when it was  told to go below 0, you got that up on one of them, did other stuff with another, that box would stay there until you click OK -- because they're completely independant)
13:24:38 <thoughtpolice> oh snap, lambdabot's been cabalised?
13:24:48 <thoughtpolice> well, more like put on hackage
13:25:04 <ehird`> this method also allows completely seamless ajax: the framework *knows* what widgets got dirty, because that's how it works internally. the sending of the extra widgets is just because it's made to do a full HTTP request.
13:25:07 <sclv_> hmm... ok. I think I see now. executing a WebM action engages in some interaction with the user and returns something of type a?
13:25:13 <ehird`> ajax is nothing more than a helper in the framework that just sends off the dirty widgets
13:25:18 <ehird`> sclv_: yeah
13:25:23 <ehird`> pages :: [(String, WebM ())]
13:25:28 <ehird`> ^ that is more correct
13:25:30 <ehird`> it was a typo
13:25:37 <ehird`> that's why we use runWeb
13:25:44 <ehird`> which should be called discardWeb or something
13:26:08 <Cin> Page?
13:26:26 <sclv_> ehird`: we ?
13:26:48 <ehird`> sclv_: i'm allowed to use 'we' in incorrect contexts thank you
13:26:52 <ehird`> Cin: ?
13:27:03 <gwern> it's the tutorial we, not the royal we
13:28:38 <sclv_> I just suddenly had a vision of Team WebMonad (r) :-)
13:28:39 <hpaste>  ehird annotated "initial, crappy Webmonad mockup" with "update" at http://hpaste.org/5667#a1
13:28:59 <ehird`> url :: (WebAction a) => String -> a -> WebMapping
13:29:17 <ehird`> instance WebAction (WebM a)
13:29:40 <ehird`> instance (WebAction a) => WebAction (b -> a)
13:29:41 <ehird`> or something
13:29:46 <ehird`> but that's how you would do it.
13:30:16 <ehird`> one thing i am not too certain about is handling nested stuff...
13:30:18 <gwern> wonder if Pugs is still active. haven't heard much about them lately
13:30:33 <ehird`> a 'strong' inside a 'p' -- i don't know how that would look, because:
13:30:40 <ehird`> tag :: ... -> WebM ()
13:30:53 <ehird`> but if I want
13:30:55 <ehird`> p "blah"
13:30:55 <ehird`> AND
13:30:57 <ehird`> p (strong "blah")
13:31:07 <ehird`> and mixes, i don't think that's possible without loads of hacks
13:31:13 <ehird`> or special, ugly operators
13:31:44 <gwern> from the ERA page, c. 1995: ' The first public release is due RSN.'
13:32:20 * gwern sees no code :)
13:32:48 <gwern> pretty screenshots tho: http://web.archive.org/web/20010803125541/http://www.dcs.gla.ac.uk/~andy/era.html
13:32:49 <lambdabot> http://tinyurl.com/39fasq
13:33:09 <ehird`> anyway, I think Webmonad will be nice and all that jazz. :P
13:33:34 <ehird`> it will also try to hide away those unsightly closure IDs in URLs as much as possible
13:33:43 <ehird`> and, of course, REST stuff is entirely supported
13:34:02 <ehird`> and indeed probably the main mode of operation, while you go out into continuation-and-closure land whenever you need to do stateful stuff
13:34:05 <gwern> ah, so ERA probably became HARE?
13:34:18 <ehird`> (Please ignore boxed future values around 'is')
13:34:30 <gwern> or, HERA actually - Haskell Equational Reasoning Assistance
13:35:39 <wolverian> gwern, pugs itself is bitrotting currently, as audrey hasn't worked on it for a while. meanwhile other implementations are using the svn repo for their code.. it's kind of organic, really.. :]
13:35:55 <shapr> :-(
13:36:05 <shapr> It's sad that pugs is bitrotting.
13:36:16 <gwern> wolverian: that would explain why the depended-upon libraries are bitrotten, at least pugs-hssyck is
13:36:29 <wolverian> gwern, yes.
13:37:14 <gwern> I was wondering if I had just grabbed the wrong svn repos, or something
13:37:23 <wolverian> shapr, you're welcome to help :) the problem is that its metaobject design wasn't very thought out originally, so it needs some quite drastic changes now that the perl6 spec on it is finished. svn has one LARGE patch from audrey to do half of it, now someone only needs to do the rest...
13:37:49 <gwern> 'Um, the link to the author's web page just gives a link back here... is this some kind of FP joke? ' <-- yes, don't be so strict about your humor
13:38:02 <ehird`> gwern: fix pageLink
13:38:55 <ehird`> i don't know if the current Webmonad example I pasted is very haskelly, actually
13:38:57 <gwern> ehird`: thing is, it seems the author's webpage is a link to the wiki page!
13:39:05 <alexj> anyone here know Data.Binary well?
13:39:07 <gwern> see http://www.unsafeperformio.com/projects.php
13:39:10 <ehird`> it reads pretty well to me but isn't exactly the epitome of elegance
13:39:14 <ehird`> then again, neither is the example page
13:39:21 <ehird`> gwern: his haskell code must be evil
13:39:55 <gwern> ehird`: I think it probably describes the website
13:40:07 <gwern> it certainly is unsafe for sanely finding HERA's source...
13:40:15 <ehird`> gwern: obviously there's no public release.
13:40:21 <ehird`> http://www.unsafeperformio.com/paper.php?label=IntroHERA06 here's a paper though
13:40:22 <lambdabot> Title: Paper Details
13:40:38 <ehird`> 'I release all my projects with a BSD style license, so if you can not find a link to something interesting below, feel free to email me.'
13:40:50 * gwern guesses I'll have to
13:41:05 <ehird`> so - anyone have opinions on the latest webmonad example i pasted?
13:41:14 <alexj> @seen dons
13:41:15 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 5h 4m 4s ago.
13:41:48 <noj> what are my options for writing cross platform Haskell GUIs?
13:42:11 <noj> read: it must work on both MacOS X and Windows
13:42:16 <gwern> ah yes, the paper does mention ERA in passing. so I was right
13:42:23 <gwern> noj: gtk2hs seems to be maintained
13:43:01 <noj> I would like to be able to dump my program on someone without them having to install alot of cruft
13:43:14 <ehird`> noj: don't go with gtk2hs if you care about os x!
13:43:22 <dons> alexj: ?
13:43:39 <noj> ehird`, ok. so what should I go with?
13:43:45 <jeffz> noj: you can write a web frontend.
13:43:46 <ehird`> noj: not sure about that. wxhaskell?
13:43:49 <ehird`> ... webmonad? :D
13:43:50 <dons> noj: that's fine. you can statically link your  apps.
13:43:57 <ehird`> jeffz: haha
13:44:00 <dons> so you won't need to worry about dependencies on the target
13:44:24 <noj> well, I do. on windows, since my teacher needs to be able to build the program :)
13:44:26 <gwern> wxhaskell has given me problems, and I get a general vibe that most of the devs are/have drifting/drifted away
13:44:47 <jeffz> ehird`: I think it's the simplest and most effective option a lot of the time, fastcgi/cgi - output some strings, use javascript to make sense of it in a static html.
13:45:19 <alexj> dons: having trouble with Data.Binary.Get.  Ambuguous occurence of uncheckedShiftL64#'
13:45:33 <ehird`> jeffz: i just suggested Webmonad is what i mean ;)
13:45:41 <jeffz> ehird`: ah, gotcha :)
13:45:49 <alexj> dons: looks like a 64bit vs 32bit cpp error but I don't understand how to fix it.
13:45:53 <ehird`> it won't have a cgi backend, though! :)
13:45:59 <ehird`> probably fastcgi mainly
13:46:11 <ehird`> and ofc plugging into some haskell w/s, mainly for dev.
13:46:32 <ehird`> though i don't like the output strings -> use js paradigm
13:46:38 <dons> alexj: this is fixed in binary's darcs repo. (and if you can confirm that, i'll upload a new patch level release)
13:46:43 <ehird`> but that's just me, i like keeping stuff degradable & not output stuff that a browser doesn't like directly
13:46:53 <ehird`> server = loads of cpu, client = who knows? :)
13:47:00 <dons> alexj: darcs.haskell.org/binary
13:47:33 <alexj> dons: is code.haskell.org the same as darcs.haskell.org?
13:48:13 * gwern sends the email. ok, so much for HERA today. what's next?
13:48:24 <dons> alexj: nope.
13:48:34 <tibbe> alexj: darcs. is for core tools I believe
13:48:35 <alexj> ah ok.  then I will update searchpath.
13:48:57 <dons> code should give a warning saying its not the main repo, iirc.
13:49:09 <sclv_> ehird`: If you're doing continuations, then you're doing continuations, I guess, and that's not very haskelly usually? I wonder if some sort of withQuery $ \ construct wouldn't be more idiomatic?
13:49:29 <alexj> searchpath had been using code.  I'll switch it to darcs.
13:49:39 <dons> alexj: ah ok. that would explain it.
13:49:42 <ehird`> sclv_: Indeed but the continuations are basically opaque.
13:49:48 <ehird`> Mostly, thunks are used.
13:49:54 <ehird`> e.g. see my 'button' stuff there
13:49:57 <ehird`> and of course the map itself
13:50:13 <ehird`> Without continuations, addTwo would become hideous
13:50:16 <jedbrown> Can we get a Storable instance for Complex into the standard libs?
13:50:20 <ehird`> because you wouldn't be able to do 'n1 <- counter 0'
13:50:27 <ehird`> since that has a continuation after it
13:50:54 <alexj> is there a standard serialzation lib for haskell outside of read/show?
13:51:03 <dons> oh alexj . hmm
13:51:05 <dons> Please use the new repository, hosted on code.haskell.org:
13:51:05 <dons> darcs get http://code.haskell.org/binary
13:51:06 <sclv_> ehird` right. I'm not saying don't use them. I'm thinking about how they might be done in a more haskellish manner.
13:51:28 <ehird`> indeed
13:51:44 <ehird`> i think removing any more continuations from that example, though, would make it less declarative
13:52:10 <alexj> dons: I'm confused.  should searchpath default to pointing to code.haskell or darcs.haskell?
13:52:25 <dons> alexj: i think it means *i've* been pushing patches to the wrong repo.
13:52:36 <dons> but i can't currently connect to code.haskell.org anyway. hmm
13:53:05 <alexj> dons: using darcs didn't work.
13:53:19 <alexj> dons: using darcs ddn't work either.
13:53:27 <dons> on a 32 bit machine, or a 64 bit machine?
13:53:34 <dons> and can you send me the bulid log then?
13:53:43 <alexj> macos Tiger on powerbook.
13:53:45 <dons> including the url of the lib you built from
13:54:00 <dons> is that a 32 bit machine?
13:54:13 <alexj> i don't knwo.
13:54:27 <monochrom> Continuation is haskellish too.
13:54:32 <sclv_> ehird`: it actually looks sort of super-imperative to me. but still clean!
13:55:00 <ehird`> sclv_: the addTwo is because it's a task
13:55:06 <dons> dcoutts: code.haskell.org's web server seems down
13:55:09 <alexj> dons: its an intell box.
13:55:12 <ehird`> which is specifically defined as a sequence of web operations one after another
13:55:20 <ehird`> but it's cool because it can support the back button etc seamlessly
13:57:02 <alexj> dons: I think it is 32 bit.
13:57:32 <alexj> dons: using the darcs.haskell code I get a "During interactive linking, GHCi couldn't find the following symbol: stg_uncheckedShiftRL64"
13:57:40 <dons> oh, that's out of date then.
13:58:09 <dons> the current  repo, which must be code.haskell.org, fixed that a while back. the released version on hackage should  have the fix , in fact
13:58:36 <gwern> ' FTP from nebula.cs.yale.edu, directory pub/haskell/incoming, file hmms-2.0.tar.gz. ' <-- wonderful, except nebula.cs.yale.edu doesn't seem to've existed for years and years
13:58:41 <sclv_> ehird`: can you compose WebM things like you can with alpheccar's formulation? I.e. when I look at it, I'm not sure how you could have, e.g., two instances of counter at once.
13:58:46 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
13:58:54 <alexj> ok will try hackage verison.
13:59:26 <dons> code.haskell.org's back up.
14:00:10 <noj> anyone know what the state of curses + haskell under windows is?
14:00:18 <dons> the binary repo on code.haskell.org is up to date now.
14:00:25 <alexj> dons: can't tell which is data.binary on hackage.  but I do know that code.haskell.org had the original error I reported.
14:00:31 <alexj> ok will try pulling that again.
14:01:06 <dons> on hackage, its the 'binary' package
14:01:09 <ehird`> sclv_: using the layout stuff
14:01:31 <ehird`> widgets [counter 0, counter 5]
14:01:33 <ehird`> or something
14:01:35 <ehird`> that's not decided yet
14:02:02 <alexj> code.haskell.org still not loading for me.
14:03:03 <alexj> dons: code.haskell.org loading and it looks like data.binary is not working thank you.
14:03:16 <dons> ok. can you send the build failure report to me?
14:03:16 <alexj> dons: can you give this working copy some tag?
14:03:23 <dons> just done so.
14:03:25 <dons> its 0.4.2
14:03:38 <alexj> dons cool.
14:03:56 <dons> so its failing, but not due to stg_* ?
14:04:27 <alexj> no its all working now.
14:05:59 <dons> ok. great. so code.haskell.org/binary is fine and working?
14:06:18 <gwern> wow. lucky wants 'hbc' as a compiler
14:06:23 <gwern> I don't even know what that is
14:06:31 <alexj> dons: what is the current tag I should pass darcs?
14:06:59 <alexj> --tag=????
14:07:25 <pheaver> do .buildinfo files only work for libraries, not executables?  cause they're certainly not working for my executables...
14:07:36 <jedbrown> gwern: It's the original.  Lennart Augustson's compiler.
14:07:41 <alexj> dons: head is working, but I would reather point to a specific working tag.
14:08:11 <gwern> jedbrown: can't say as I heard of it, unless... was thatthe one written in lazy ml?
14:09:03 <gwern> dang. why do all these old parsers insist on using stuff like MonadZero and MonadPlus?
14:09:24 <dolio> gwern: Because that's better than the current state of affairs?
14:09:24 <gwern> are there any guides on handling old parser code using them?
14:09:32 <jedbrown> gwern: I think it was.  It's pre H98.
14:09:54 <jedbrown> dons: Regarding my question about a Storable instance for Complex, both hmatrix and carray/fft need the instance.  It doesn't make sense to depend on each other, but it is natural to want to use hmatrix with fft/carray, but then instances overlap.
14:10:34 <jedbrown> dons: Our instances are actually equivalent.  Is there a way to suppress this error.
14:11:22 <ehird`> i'm writing a minimal VM in haskell
14:11:37 <ehird`> now, because pointers/ints/everything is 32-bit, I need 2^32 Int32's as memory
14:11:49 <ehird`> But I want to use it just like a regular, efficient, mutable array in the IO monad.
14:11:56 <ehird`> But lazily allocated, of course.
14:12:04 <ehird`> I guess a hash-table is the best idea.
14:12:08 <ehird`> But... inefficient.
14:13:24 <jedbrown> ehird`: Perhaps you want 2-level structure, i.e. pages.
14:13:46 <ehird`> jedbrown: Possibly. But that's a lot of work when the VM external doesn't see it.
14:13:50 <ehird`> (It's a One Instruction Set Computer)
14:15:09 <Twey> ehird`: What's the instruction?
14:15:20 <jedbrown> I don't think it's that hard.  The lookup function does a bitwise operation to get the page index which it looks up in the map/hash, then indexes the resulting array.
14:15:34 <ehird`> Twey: it's quite complex, i didn't make it
14:15:36 <gwern> substract and branch?
14:15:42 <ehird`> #esoteric, es0n00b is explaining it there
14:16:00 <sclv_> gwern: are you updating lucky just to update it, or do you need it for another project?
14:16:01 <ehird`> he's not a programmer, though, so the technical explanation he's given is this:
14:16:02 <ehird`> PC+=IF((M(M(PC)+PC)==M(M(PC)+PC)+(IF(m(pc+3)AND1),m(PC+1),m(m(PC+1)+PC))*m(m(pc+2)+PC)DIV(IF((m(PC+3)AND2),2^N,1))MOD(2^N))<2^N,4+(m(pc+3)ANDNOT3),4)
14:16:03 <gwern> I heard that with a single subtract-andb-possibly-branch instructon, you can build a full cpu
14:16:05 <ehird`> he's elaborating on that now
14:16:09 <ehird`> gwern: yes, yes you can
14:16:13 <ehird`> esolangs.org/wiki - search for OISC
14:16:24 <gwern> sclv_: updating. I think I'm going to leave it alone, though, after I have webcitation.org back it up
14:16:26 <Twey> O.O
14:17:49 <ehird`> Twey: yeppers
14:17:56 <sclv_> makes sense. with so many cool bits of poor abandoned code laying about that have far less overlap with the stuff we already have. :-)
14:18:19 <ehird`> so yes i need to figure out how to efficiently express the memory
14:18:42 <gwern> sclv_: right. know of any in particular?
14:19:30 <jedbrown> ehird`: What's the problem with the 2-level map of pages?
14:21:01 <ehird`> jedbrown: too complex to implement
14:22:24 <jedbrown> ehird`: It should only be a few lines.  You just need to implement read and write.  They do a lookup in the map/hash and index the array.
14:23:53 <pcc1> how can I define my own custom opaque pointer type for ffi (e.g. Ptr Tree)?
14:25:07 <jedbrown> pcc1: data Tree; type TreePtr = Ptr Tree
14:26:09 <resiak> c2hs generates things like   data Tree = Tree (Ptr Tree)
14:26:25 <resiak> which avoids the spurious extra type
14:33:08 <TomMD> Can any windows users tell me if control-timeout works for them?  I am trying to figure out of the Data.Time.POSIX works on windows.
14:36:39 <alexj> is there a standard class that defines toList and fromList?
14:37:26 <sarehu> alexj: Foldable has toList
14:37:34 <alexj> but not fromList.
14:37:53 <alexj> I am looking for a generic way to serialize Data.Map Data.Set and all their kin.
14:39:29 <sarehu> You'll need to make your own if you want fromList
14:39:43 <sarehu> Unless there's some package with it already...
14:40:01 <ehird`> is there a compiler that actually does c->haskell?
14:40:02 <jedbrown> alexj: I don't think there is a type class for construction, only traversal.
14:40:08 <ehird`> i.e. you input genuine, bona-fide c and it spits out haskell
14:40:08 <ehird`> :D
14:40:52 <alexj> yeah, I am sort of surprised by the lack of standard serialize functionality in haskell.  read/show is not great.
14:41:16 <gwern> clean has some really nice serialization functionality in its dynamics :(
14:42:22 <jedbrown> alexj: Do you need to the structures to be semantically equivalent or actually have equivalent representation when you read them back in?
14:43:03 <xif> what's a good introductory text that is very fast paced and uses lots of examples?
14:43:13 <alexj> jedbrown: I just want a deserialize.serialize == id
14:43:18 <jedbrown> alexj: In the former case, you can just make a typeclass which implements toList.
14:43:32 <ehird`> and if there's not... well, one ought to be written! now!
14:43:39 <jedbrown> alexj: semantically or internally?
14:43:56 <dolio> @seen Philippa_
14:43:57 <lambdabot> Philippa_ is in #haskell, #scannedinavian, #haskell-soc, #haskell-blah and #haskell-overflow. I last heard Philippa_ speak 1h 6m 12s ago.
14:44:14 <sarehu> alexj: to be clear, Data.Binary is not what you need?
14:44:30 <vininim> @hoogle Integral -> Double
14:44:32 <lambdabot> No matches, try a more general search
14:44:34 <jedbrown> alexj: i.e. you can have two Maps with the same elements, but that are different internally.  They will be semantically the same, but not the same internally.
14:44:43 <vininim> @hoogle (Integral a) => a -> Double
14:44:43 <lambdabot> No matches, try a more general search
14:44:54 <vininim> @hoogle Integer -> Double
14:44:55 <lambdabot> No matches, try a more general search
14:44:58 <vininim> ko
14:45:00 <alexj> jedbrown id x == x
14:45:05 <alexj> for however you define ===
14:45:09 <alexj> s/===/==
14:45:11 <faxathisia> xif, hard to say.. I grabbed a book from the library
14:45:31 <alexj> jedbrown I don't care about the internal representation.
14:45:32 <sarehu> first you asked about toList and fromList; now you're saying "serialize"; what do you really want?
14:45:51 <faxathisia> well I read it and though, haskell doesn't seem that interesting and didn't program with it until a year after :S
14:46:30 <alexj> sarehu: I want serialization.  I know how to serialize a list.  I'd like generic serialization for any data structure.
14:47:29 <sarehu> ok, there exists  Data.Binary.encode :: Binary a => a -> ByteString, and Data.Binary.decode :: Binary a => ByteString -> a,  if that's what you're looking for
14:47:38 <jedbrown> alexj: How about a Buildable class implementing fromList, although I think binary will do what you want.
14:48:20 <sarehu> And it already has instances for Seq, Map, Set, IntSet, IntMap, Array, ...
14:49:17 <sarehu> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html
14:49:18 <lambdabot> http://tinyurl.com/yqlto4
14:50:56 <alexj> data.binary doens't have versioning.
14:51:37 <ehird`> so, is there?
14:52:41 <xif> faxathisia: thanks
14:54:53 <xif> anyone else?
14:55:16 <xif> an example heavy, fast-paced introductory text?
14:56:46 <xif> (for Haskel...?
14:57:09 <cjb> xif: http://www.cs.utah.edu/~hal/htut/
14:57:10 <lambdabot> Title: Yet Another Haskell Tutorial
14:57:47 <u_quark> @help
14:57:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:57:59 <u_quark> ?help
14:57:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:58:30 <xif> cjb: thx
15:01:37 <vininim> > let foo = \ x -> scanl f (head x) x in foo [a,b,c,d] :: [Expr]
15:01:40 <lambdabot>  [a,f a a,f (f a a) b,f (f (f a a) b) c,f (f (f (f a a) b) c) d]
15:02:15 <vininim> > let foo = \ x -> scanl f (head x) x in foo $ reverse [a,b,c,d] :: [Expr]
15:02:15 <lambdabot>  [d,f d d,f (f d d) c,f (f (f d d) c) b,f (f (f (f d d) c) b) a]
15:02:24 <vininim> heh, ok
15:03:42 <echo_mirage> what do i need to know about datatypes for defining list-functions? i saw some functions with anonymous datatypes like  [a] ->[a]. when is this possible/necessary instead of forcing a type like [Float] -> [Float]  ?
15:04:23 <BMeph> ehird' The language conversion problem gets tougher the lower down the "blub" scale you go. AFAIK, most of the effort is put into going the other way. You could be the first, though. ;)
15:04:25 <nominolo> :t map (+1.0)
15:04:26 <lambdabot> forall a. (Fractional a) => [a] -> [a]
15:04:26 <Botje> echo_mirage: functions that operate only on the _STRUCTURE_ of a list can have the type [a] -> [a]
15:04:49 <Botje> once you start inspecting elements, you need to limit that type
15:04:58 <echo_mirage> i see
15:05:57 <dolio> @tell Philippa_ This is, possibly, a 'fiendishly clever' reason for wanting uncons to be called at most once: http://hpaste.org/5670
15:05:57 <lambdabot> Consider it noted.
15:08:02 <ehird`> BMeph: You just said 'blub'.
15:08:04 <xif> anyone read "The Haskell Road to Logic, Maths and Programming"?
15:08:07 * ehird` goes into a frenzied rage
15:08:23 <BMeph> ehird': Yes, yes I did. :)
15:08:32 <oerjan> > cycle "blub "
15:08:37 <lambdabot>  "blub blub blub blub blub blub blub blub blub blub blub blub blub blub blub ...
15:08:54 <ehird`> > cycle (quoteFrom PaulGraham (\x -> annoying x))
15:08:54 <lambdabot>   Not in scope: `annoying'
15:08:59 <ehird`> > cycle (quoteFrom PaulGraham annoying)
15:09:00 <lambdabot>   Not in scope: `annoying'
15:09:15 <ddarius> xif: Have you read Filinski's "Symmetric Lambda Calculus"?
15:09:26 <xif> ddarius: nope.
15:09:38 <ddarius> xif: You should.
15:09:41 <ehird`> > let quoteFrom = select; PaulGraham = ["blub"]; annoying "blub" = True in xcycle (quoteFrom PaulGraham annoying)
15:09:41 <lambdabot>   Not in scope: data constructor `PaulGraham'
15:09:46 <jeffz> xif: if you haven't found it yet, this page might be of interest - http://haskell.org/haskellwiki/Books
15:09:50 <ehird`> > let quoteFrom = select; paulGraham = ["blub"]; annoying "blub" = True in cycle (quoteFrom paulGraham annoying)
15:09:50 <lambdabot>   Not in scope: `select'
15:09:55 <ehird`> > let quoteFrom = find; paulGraham = ["blub"]; annoying "blub" = True in cycle (quoteFrom paulGraham annoying)
15:09:55 <lambdabot>  Couldn't match expected type `a -> Bool'
15:10:00 <xif> jeffz: yup, thanks
15:10:01 <ehird`> > let quoteFrom = flip find; paulGraham = ["blub"]; annoying "blub" = True in cycle (quoteFrom paulGraham annoying)
15:10:01 <lambdabot>  Couldn't match expected type `[a]'
15:10:04 <oerjan> ehird`: /msg :)
15:10:12 <ehird`> oerjan: shush you, i was proving a point, slowly
15:10:19 <BMeph> ehird': I find that "conceptual complexity and abstact sophistication" is longer to type than "blub," which currently roughly has the same meaning, especially in computer language discourse.
15:10:23 <dolio> Is this really necessary?
15:10:32 <ehird`> dolio: Depends what 'necessary' evaluates to
15:10:35 <BMeph> s/abstact/abstRact/
15:11:10 <Botje> > let bob = flip const in "CAN WE FIX IT ?" `bob` "YES WE CAN"
15:11:11 <lambdabot>  "YES WE CAN"
15:11:19 * oerjan assumes that _every_ programming language is a blub from some higher point of view.  including lisp and haskell.
15:12:12 <ehird`> Botje: you win
15:12:18 <DRMacIver> "Haskell is also a very popular language for any sort of 3D rendering, and there are a number of applications devoted to it.". Hm. Really?
15:12:24 <ehird`> oerjan: that's what i thought about pg...
15:12:27 <DRMacIver> (From: http://fedoraproject.org/wiki/Features/GoodHaskellSupport )
15:12:28 <lambdabot> Title: Features/GoodHaskellSupport - Fedora Project Wiki
15:12:39 <ehird`> 'HAHA, YOU'RE ALL BLUB. You should check out LISSPP!'
15:12:42 <ehird`> very ironic
15:12:43 <Botje> ehird`: yay :)
15:12:55 <ehird`> > let bob = flip const in "Can Haskell do X?" `bob` "Yes it can!"
15:12:56 <lambdabot>  "Yes it can!"
15:12:57 <mrd> it's blub all the way down
15:13:12 <Botje> ehird`: s/bob/simon/g # surely >:)
15:13:15 <ehird`> mrd: (blubs !! (1/0))
15:13:17 <xif> ddarius: I can't find that book
15:13:19 <ehird`> problem solved
15:13:20 <ehird`> Botje: lazy
15:13:40 <ehird`> ... hey, i didn't make that pun intentionally!
15:15:29 <ddarius> @google "Symmetric Lambda Calculus"
15:15:31 <lambdabot> http://citeseer.ist.psu.edu/749411.html
15:15:31 <lambdabot> Title: Strong Normalization of a Symmetric Lambda Calculus for Second Order Classical L ...
15:15:59 <resiak> @hoogle (a -> Bool) -> [a] -> ([a],[a])
15:16:00 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
15:16:00 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:16:00 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
15:16:05 <ehird`> is there a pseq-and-friends tutorial anywhere?
15:16:08 <resiak> @ty partition
15:16:09 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:16:10 <ehird`> i'm mainly looking for:
15:16:20 <ehird`> a -> b -> (a,b)
15:16:21 <ehird`> or
15:16:25 <ehird`> [a] -> [a]
15:16:25 <faxathisia> (,)
15:16:32 <faxathisia> :t (,)
15:16:33 <lambdabot> forall a b. a -> b -> (a, b)
15:16:35 <ehird`> where the terms are evaluated in parallel, and forced
15:16:40 <ehird`> faxathisia: fail!
15:16:49 <ddarius> xif: Ah, that's not it's title.  It's discussed in Filinski's Master's thesis: http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/
15:16:50 <lambdabot> Title: Andrzej Filinski's publications
15:17:26 <xif> ddarius: "Normalization by Evaluation for the Computational Lambda-Calculus"?
15:18:28 <ddarius> xif: The first link.  The one that says "Master's thesis" next to it.
15:18:32 * xif nods
15:18:39 <xif> there are people in this world
15:18:44 <xif>   smarter than me :-(
15:18:50 <ehird`> pall [] = []; pall (x:xs) = x `par` x : pall xs
15:19:03 <ehird`> :D
15:19:14 <ehird`> .. should work
15:19:16 <xif> oh, about Paul Graham, I had this thought, like, yesterday
15:19:33 <xif> did you notice how _completely biased and Lisp oriented_ the whole accgen thing is?
15:19:58 <ehird`> xif: yes.
15:20:12 <xif> the task definition should be read as "do the simplest thing Lisp is absolutely best at".
15:20:21 <ehird`> xif: ditto with the Arc challenge...
15:20:25 <ehird`> he's an idiot, this isn't new
15:20:31 <vincenz> what is accgenn?
15:20:37 <xif> "then char-count, and laugh at all other languages which implement it in 3 chars longer"
15:20:45 <vincenz> xif: nt to mention
15:20:50 <xif> vincenz: http://www.paulgraham.com/accgen.html
15:20:50 <lambdabot> Title: Accumulator Generator
15:20:53 <ehird`> vincenz: (lambda (x) (lambda (y) (++ x y))
15:20:53 <vincenz> he's' always asking on the forum "why is this better? does it make code shorter?"
15:20:56 <ehird`> where ++ is increment
15:20:58 <ehird`> vincenz: Yes!! I know!!!
15:21:02 <vincenz> Seriously
15:21:03 <ehird`> That really fscking annoys me
15:21:05 <ehird`> it's all he ever sayd
15:21:07 <vincenz> he focuses on shorter for -small local things
15:21:10 <ehird`> he NEVER does his own research
15:21:13 <xif> exactly
15:21:14 <vincenz> not on things that can leverage smaller code in BIGGER things
15:21:23 <ehird`> 'Note: (a) that's number, not integer, (b) that's incremented by, not plus.' <-- And someone should tell him (b) is mathematically nonsense.
15:21:28 <vincenz> this is going to bite him in the ass
15:21:30 <vincenz> as soon as he grows
15:21:37 <xif> it's like I invent this language, where all keywords are just single letters
15:21:43 <ehird`> xif: it's called K
15:21:45 <xif> and it's the best, cause it's "shortest"
15:21:49 <ehird`> and it's actually pretty fun
15:21:53 <ehird`> (along with its parent APL)
15:21:57 <faxathisia> I like j
15:21:58 <vincenz> xif: not to mention, make -hacky- quickfix solutions that don't play wel
15:22:17 <vincenz> as soon as someone starts writing something bigger
15:22:24 <vincenz> "how come X does not do X when used with Y"?"
15:22:34 <awesame> xif: it's very much like that.  arc is kind of cryptic!
15:22:46 <vincenz> not to mention, it's illegible
15:22:50 <vincenz> that's' why I've started 'camber'
15:22:58 <ehird`> fib n = sum $ spike [fib (n-1), fib (n-2)]   -- this is nice
15:23:03 <vincenz> http://oasis.yi.org/oasis/CamberLanguage
15:23:03 <lambdabot> Title: CamberLanguage - Oasis Wiki
15:23:08 <xif> awesame: exactly, that's precisely what he did with Arc (as he didn't have the genius of inventing APL)
15:23:32 <ehird`> vincenz: the arc challenge is retarded
15:23:33 <xif> how can a grown man believe a micro program of 3-5 lines meaningfully rates whole programming languages?
15:23:33 <ehird`> :)
15:23:38 <vincenz> did you read his comments on patternmatching
15:23:45 <paczesiowa> how can I make "if x == []..." "if x == Nothing" more general?
15:23:48 <dolio> APL doesn't have enough parentheses to be a good language.
15:23:49 <xif> (before we mention the fact that he tailored it to his favorite)
15:23:50 <ehird`> vincenz: i seem to remember they were 'HOW DOES THIS MAKE IT SHORTER????????????'
15:23:51 <ddarius> Despite my low opinion of Arc and Paul Graham, can you take the Arc bashing elsewhere?
15:23:52 <vincenz> "patternmatching is only useful on very specific functions like map, that once you have them it is no longer useful"
15:23:59 <ehird`> ddarius: no :p
15:24:04 <vincenz> ddarius: point taken
15:24:22 <ehird`> vincenz: camber? .. that was my idea :P
15:24:40 <faxathisia> paczesiowa: Can you elaborate a bit?
15:24:47 <vincenz> ehird`: I'd like someone to collab with
15:24:56 <paczesiowa> faxathisia: I want to test if x is mzero
15:24:58 <lament> why is everybody bashing Arc all of a sudden? I've never heard of Arc until a few days ago.
15:25:12 <faxathisia> :t return >>= (==)
15:25:13 <mrd> lament: heh, it was 'introduced' 6 years ago at least
15:25:23 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
15:25:23 <lambdabot>       Expected type: m a -> a -> b
15:25:23 <lambdabot>       Inferred type: a -> a -> Bool
15:25:29 <vincenz> mrd: btw, thanks or your comments the other day on my blogpost, they clarified some things
15:25:29 <mrd> we laughed at it then and now it's a reprise, since it's no longer vapourware
15:25:44 <mrd> vincenz: ah did you have a chance to go over that
15:25:54 <vincenz> mrd: not yet, busy writing journal and thesis
15:26:09 <dolio> paczesiowa: "if x == mzero" but that's kind of ugly.
15:26:13 <oerjan> paczesiowa: if it has Eq you can just compare with mzero itself...
15:26:17 <dolio> paczesiowa: Or mempty, possibly.
15:26:25 <Botje> :t mempty
15:26:25 <lambdabot> forall a. (Monoid a) => a
15:26:34 <Botje> :t mzero
15:26:35 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
15:26:43 <dolio> > mempty :: Just Int
15:26:44 <Botje> i see
15:26:44 <lambdabot>   Not in scope: type constructor or class `Just'
15:26:45 <faxathisia> @hoogle m a -> a
15:26:45 <lambdabot> Prelude.id :: a -> a
15:26:45 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
15:26:45 <lambdabot> Data.Function.id :: a -> a
15:26:51 <dolio> > mempty :: Maybe Int
15:26:51 <lambdabot>   add an instance declaration for (Monoid Int)
15:26:51 <lambdabot>     In the expression: mempty ...
15:27:00 <dolio> Ah, I guess that's no good.
15:27:24 <oerjan> paczesiowa: (x >> ...) `mplus` ... might also work
15:27:25 <dolio> The Maybe instances for Monoid have more specific names.
15:27:51 <oerjan> but it may not have the exact same semantics depending on the monad. hm.
15:27:59 <oerjan> actually [] doesn't work there
15:28:23 <paczesiowa> > let f x = if x == mzero then undefined else undefined in f Nothing
15:28:24 <lambdabot>  Undefined
15:28:32 <vininim> > let{ ff d z [c] = d z c; ff d z (x:y:xs) = d x y + ff d z (y:xs)} in (\ x -> ff f (head x) x) [a,b,c,d] :: [Expr]
15:28:37 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
15:29:06 <vininim> > let{ ff d z [c] = d z c; ff d z (x:y:xs) = d x y + ff d z (y:xs)} in (\ x -> ff f (head x) x) [a,b,c,d] :: Expr
15:29:08 <lambdabot>  f a b + (f b c + (f c d + f a d))
15:29:11 <paczesiowa> huh, importing Control.Monad helps a lot:P
15:29:51 <oerjan> ehird`: check out Control.Parallel.Strategies
15:30:14 <ehird`> oerjan: i know -- i just prefer my primitive
15:30:25 <ehird`> spike [] = []; spike (x:xs) = x `par` x : spike xs
15:30:42 <sfultong> can I save an infinite list to an IORef or TVar?
15:30:43 <paczesiowa> == mzero needs Eq (m a) :/
15:30:49 <vininim> @foldlfy let{ ff d z [c] = d z c; ff d z (x:y:xs) = d x y + ff d z (y:xs)}
15:30:49 <lambdabot> Unknown command, try @list
15:31:00 <vininim> oh gee
15:31:32 <oerjan> ehird`: that won't evaluate anything but the first x
15:32:16 <oerjan> sfultong: sure
15:32:44 <faxathisia> Agda 2 is way too much fun!
15:32:55 <faxathisia> I spent all day using it :N
15:33:10 <vininim> > let{ ff d z [c] = d c z; ff d z (x:y:xs) = d x y + ff d z (y:xs)} in (\ x -> ff f (head x) x) [a,b,c,d] :: Expr
15:33:11 <lambdabot>  f a b + (f b c + (f c d + f d a))
15:33:18 <faxathisia> (It's a language with haskell syntax and written in haskell)
15:33:37 * dolio is still waiting for Epigram 2.
15:33:48 <sfultong> oerjan: cool.  Although, that makes me wonder why bother use the state monad for random generators
15:34:08 <faxathisia> I think you can get Epigram 2 already? from darcs?
15:34:16 <dolio> Can you?
15:34:20 <faxathisia> let me see..
15:34:21 <ehird`> oerjan: so what should i make it?#
15:34:37 <ehird`> sfultong: generality
15:34:37 <faxathisia> (btw I haven't yet since I didn't get Epigram 1 to work..)
15:35:03 <dolio> I thought they were still in the research paper stage.
15:35:21 <faxathisia> Oh so this is just version 1 stuff? http://www.e-pig.org/darcsweb?r=epigram;a=tree;f=/src
15:35:22 <lambdabot> Title: darcs - epigram
15:36:22 <faxathisia> It's got Ecce stuff and I just thought that was part of Epigram 2
15:36:51 <dolio> I couldn't tell you. It's been a while since I looked in on it, to be honest.
15:36:55 <sfultong> ehird`: what do you mean?
15:37:06 <ehird`> sfultong: not constrained to IO
15:37:22 <faxathisia> dolio, Look here http://www.e-pig.org/darcsweb?r=epigram;a=headblob;f=/src/epigram.cabal
15:37:23 <lambdabot> Title: darcs - epigram, http://tinyurl.com/3cf5j5
15:37:38 <dolio> Ah, neat.
15:37:45 <faxathisia> I wonder if this builds :D
15:38:44 <oerjan> ehird`: spike xss@(x:xs) = x `par` spike xs `par` xss perhaps (avoids a new consing too...)
15:39:22 <ehird`> thanks oerjan
15:40:08 <sfultong> ehird: or you could just have a function with an infinite stream passed in... oh, wait.... yeah, it's still easier to use the state monad, silly me
15:41:45 <ehird`> also, i would kill for    debug :: String -> a -> a
15:41:54 <ehird`> it doesn't need to be IO, because there's no reason it has to be implemented using IO
15:42:15 <ehird`> but if e.g. a default implementation printed "DEBUG: x" to stderr, when -XDebug (or something) is turned on, that'd be really useful
15:42:35 <oerjan> ehird`: Debug.Trace.trace ?
15:42:46 <ehird`> @type Debug.Trace.trace
15:42:48 <lambdabot> forall a. String -> a -> a
15:42:52 <sfultong> :)
15:42:58 <ehird`> > trace "foo" 2
15:42:59 <lambdabot>   Not in scope: `trace'
15:43:05 <ehird`> > Debug.Trace.trace "foo" 2
15:43:05 <lambdabot>   Not in scope: `Debug.Trace.trace'
15:43:06 <ehird`> hmm
15:43:09 <ehird`> time to test in ghci :)
15:43:16 <oerjan> ehird`: it's a bit too impure for lambdabot to allow
15:43:22 <ehird`> oerjan: true
15:43:28 <ehird`> is it SAFE though?
15:43:33 <ehird`> i.e. not unsafePerformIO-ish
15:43:48 <paczesiowa> no
15:43:48 <sfultong> yeah, I was very happy when I learned about trace
15:43:50 <LoganCapaldo> of course it's unsafePerformIO ish
15:43:55 <oerjan> ehird`: it uses unsafePerformIO but only to write to stderr or equivalent
15:44:06 <ehird`> LoganCapaldo: the idea is that the IO is entirely implementation-specific
15:44:09 <ehird`> & unspecified
15:44:23 <ehird`> so that, technically, you could just say it's a source comment, maybe something for documentation tools to use
15:44:30 <ehird`> but, it becomes really useful with an IO backend
15:44:46 <ehird`> hmm
15:44:48 <ehird`> it seems to be sloowww
15:44:55 * LoganCapaldo seems to recall the docs explicitly mentioning unsafePerformIO
15:45:33 <oerjan> @src trace
15:45:34 <lambdabot> trace string expr = unsafePerformIO $ do
15:45:34 <lambdabot>     hPutStrLn stderr string
15:45:34 <lambdabot>     return expr
15:45:44 <ehird`> interestnig
15:46:21 <oerjan> about as simple as one could expect
15:46:22 <LoganCapaldo> http://cvs.haskell.org/Hugs/pages/libraries/base/Debug-Trace.html
15:46:23 <ehird`> @hpaste
15:46:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:46:39 <hpaste>  ehird pasted "does this actually do what it's supposed to? i'm not sure" at http://hpaste.org/5671
15:47:50 <LoganCapaldo> i think it has to be a top level binding?
15:48:07 <ehird`> LoganCapaldo: ?
15:48:12 <resiak> @hoogle [Either a b] -> ([a],[b])
15:48:13 <lambdabot> No matches, try a more general search
15:48:15 <resiak> :(
15:48:21 <ehird`> LoganCapaldo: i don't get it
15:48:39 <LoganCapaldo> for the not reevaluating stuff to kick in
15:49:28 <oerjan> ehird`: allValuesOf f 0 is not cached if you don't give it a name, and it may have to be outside the binding of x, i'm not sure
15:49:55 <ehird`> oerjan: ah.
15:49:57 <ehird`> that's tricksy ;)
15:50:16 <ehird`> let me try again
15:50:38 <hpaste>  oerjan annotated "does this actually do what it's supposed to? i'm not sure" with "perhaps this?" at http://hpaste.org/5671#a1
15:51:06 <hpaste>  (anonymous) annotated "does this actually do what it's supposed to? i'm not sure" with "this?" at http://hpaste.org/5671#a2
15:51:13 <ehird`> hah
15:51:43 <oerjan> i think both those should work
15:52:01 <ehird`> yep
15:52:16 <ehird`> weirdly !! takes an Int
15:52:34 <oerjan> also you could write it with map ... [0..]
15:52:38 <oerjan> oh right
15:52:43 <oerjan> genericIndex
15:53:15 <u_quark> is there an automated (or semi-automated) way to install packages from hackageDB ?
15:53:23 <ddarius> cabal install foo
15:53:30 <ddarius> @google cabal-install
15:53:31 <u_quark> axaa!
15:53:32 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
15:53:32 <lambdabot> Title: CabalInstall - Hackage - Trac
15:53:41 <hpaste>  (anonymous) annotated "does this actually do what it's supposed to? i'm not sure" with "weeeee" at http://hpaste.org/5671#a3
15:54:53 <u_quark> tnx
15:55:20 <ehird`> memoize f = let values = map f [0..] in genericIndex values x
15:55:24 <ehird`> generic one liner
15:55:25 <ehird`> score!
15:55:30 <ehird`> actually
15:55:30 <hpaste>  oerjan annotated "does this actually do what it's supposed to? i'm not sure" with ";)" at http://hpaste.org/5671#a4
15:55:34 <ehird`> genericIndex (map f [0..]) x
15:55:36 <ehird`> should work
15:55:36 <ehird`> right?
15:55:43 <oerjan> yep
15:55:59 <ehird`> memoize f = genericIndex (map f [0..])
15:56:00 <ehird`> sweet.
15:56:08 <vininim> :t genericIndex
15:56:20 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
15:57:56 <olsner> and then you replace recursive calls to f in f with memoize f?
15:58:00 <hpaste>  ehird pasted "super fib!" at http://hpaste.org/5672
15:58:06 <ehird`> i really like 'spike'
15:58:16 <ehird`> olsner: pretty much, see my latest paste
15:58:27 <ehird`> well
15:58:29 <ehird`> not 'memoize f'
15:58:32 <ehird`> it has to be the SAME memoize f
15:58:33 <olsner> yes, I see
15:58:42 <ehird`> 'fib' looks nice though
15:58:51 <hpaste>  LoganCapaldo annotated "does this actually do what it's supposed to? i'm not sure" with "even less ;)" at http://hpaste.org/5671#a5
15:59:02 <ehird`> it computes (fib 50) in less than a second here.
15:59:24 <ehird`> heck
15:59:25 <ehird`> fib 500 too
15:59:28 <ehird`> well
15:59:31 <ehird`> that's once i'd computed fib 50.
15:59:36 <resiak> LoganCapaldo: *chuckle*
15:59:37 <olsner> > let fib = 1:1:zipWith (+) fib (tail fib) in fib !! 50
15:59:40 <lambdabot>  20365011074
15:59:48 <ehird`> its even the same before that
15:59:55 <ehird`> > let fib = 1:1:zipWith (+) fib (tail fib) in fib !! 500
15:59:57 <lambdabot>  2255915161619363308725126950360720720460113249137581905886388664184746277386...
16:00:00 <ehird`> QED.
16:00:24 <faxathisia> > let fib = 1:1:zipWith (+) fib (tail fib) in fib :: [Expr]
16:00:25 <lambdabot>  [1,1,1 + 1,1 + (1 + 1),1 + 1 + (1 + (1 + 1)),1 + (1 + 1) + (1 + 1 + (1 + (1 ...
16:00:35 <olsner> @src Expr
16:00:35 <lambdabot> Source not found. Are you on drugs?
16:00:35 <ehird`> very slow
16:01:42 <ehird`> also, i've tested mine and because of memoization it never makes duplicate fib calls
16:01:42 <ehird`> not even with paralellism
16:02:20 <ehird`> Hm.
16:02:20 <ehird`> fib 1000 as soon as I can hit 'enter'
16:02:24 <ehird`> fib 10000 in 'quite a while', but not bad :P
16:02:28 <ehird`> this is WITH traces
16:02:32 <ehird`> without them it's even more blazing
16:02:36 <ehird`> conclusion: spike and memoize are awesome, if only they were general.
16:02:44 <ehird`> Well, they could be made general, but only with unsafePerformIO...
16:02:46 <ehird`> (mutable hashtables)
16:03:49 <ehird`> this is in ghci, by the way
16:04:10 <ehird`> in fact, that doesn't want to link with the parallel libraries
16:04:11 <ehird`> very odd
16:04:47 <ehird`> by the way, i think with 'spike', a parallel map is just:
16:04:50 <ehird`> pmap = spike . map
16:05:47 <ehird`> @src foldl
16:05:48 <lambdabot> foldl f z xs = lgo z xs
16:05:48 <lambdabot>     where lgo z []     =  z
16:05:48 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
16:06:16 <oerjan> ehird`: you do _not_ want to use mutable hashtables with parallelism - the locking would be horrible i think
16:06:22 <ehird`> oerjan: true.
16:06:32 <ehird`> i guess specific memoization functions are better
16:07:11 <oerjan> @src foldl'
16:07:12 <lambdabot> foldl' f a []     = a
16:07:12 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:08:17 <ehird`> papply f a b = a `par` b `par` f a b
16:08:26 <ehird`> second parallel primitive :P
16:09:05 <oerjan> why two arguments?  wouldn't currying work just as well?
16:09:20 <ehird`> oerjan: because it's our indication of what to parallelize
16:10:08 <oerjan> i mean if it were papply f a = a `par` f a then you could still do f `papply` a `papply` b
16:10:11 <ehird`> pfoldl' f a (x:xs) = let a' = f a x in papply (flip pfoldl') f a' xs
16:10:13 <ehird`> ^ i think
16:10:16 <ehird`> oerjan: good point
16:10:32 <ddarius> ($*) = papply
16:10:41 <resiak> given newtype Foo = Foo Bar, there's no standard way to derive unFoo (Foo b) = b, is there?
16:10:44 <ehird`> ddarius: from .Strategies, right?
16:10:48 <ddarius> No
16:10:57 <ehird`> i'm just making my own primitives for no reason :P
16:11:00 <oerjan> @index $*
16:11:00 <ehird`> right now my favourite is spike
16:11:00 <lambdabot> bzzt
16:11:02 <ddarius> resiak: newtype Foo = Foo { unFoo :: Bar }
16:11:07 <ehird`> @index ($*)
16:11:07 <lambdabot> bzzt
16:11:30 <ddarius> It was a suggestion, not a reference.
16:11:49 <ehird`> oh
16:11:49 <ehird`> haha
16:11:50 <ehird`> :)
16:11:53 <resiak> ddarius: oh, of course!  thanks
16:12:06 <ehird`> i'll give 'em symbol names once i figure out stuff about them
16:12:10 <ehird`> pfoldl f a (x:xs) = flip (pfoldl' f) xs `papply` f a x
16:12:17 <ddarius> @src ($!)
16:12:18 <lambdabot> Source not found.
16:12:25 <ddarius> Stupid bot
16:12:29 <ehird`> ddarius: oh
16:12:32 <ehird`> i thought you meant:
16:12:37 <ehird`> it was a suggestion for a name for papply
16:12:49 <ddarius> That's what I did mean.  In analogy with ($!)
16:13:28 <ehird`> ah, okay
16:13:55 <ehird`> pmap f xs = spike (map f xs)
16:14:14 <ehird`> i think you can build spike upon papply
16:14:47 <oerjan> well it's almost an Applicative Functor isn't it.
16:14:54 <ehird`> i guess so :P
16:15:07 <ehird`> is papply an old thing or has it been done before?
16:15:13 <ehird`> it seems simple enough to be old, but i haven't seen it around..
16:15:38 <ehird`> hmm:
16:15:40 <ehird`>           fib' n = (+) `papply` fib (n-1) `papply` fib (n-2)
16:15:45 <ehird`> as a replacement for the spike + sum solution
16:15:50 <ehird`> i think for the case of fib' it's nicer
16:16:52 <hpaste>  ehird pasted "paralellism + memoize stuff as it is now" at http://hpaste.org/5673
16:17:07 <ehird`> i am going to rewrite spike in terms of papply
16:17:08 <oerjan> ehird`: $|| seems similar except it takes an additional Strategy argument
16:17:24 <ehird`> oerjan: right, i haven't looked to closely at the strategy stuff
16:17:38 <ehird`> i tend to like very simple primitives that don't need too many extensions to build bigger stuff
16:17:42 <ehird`> which is why i haven't really bothered with them
16:18:49 <ehird`> actually, spike has no natural definition of papply
16:18:55 <ehird`> and vise-versa
16:19:02 <ehird`> so, two primitives right now. that's good
16:19:24 <ehird`> now -- if lambdabot supported parallelism, I wonder what the Expr's would look like :)
16:20:20 <ehird`> well it makes for nice naive factorial definitions:
16:20:22 <ehird`> fact n = (n *) `papply` fact (n-1)
16:21:08 <hpaste>  gwern pasted "overlapping errors" at http://hpaste.org/5674
16:21:22 <gwern> what do these errors mean, and what's the best way to fix'em?
16:21:34 <ehird`> well, I saw 'GOTO'
16:21:37 <ehird`> :)
16:22:16 <ehird`> hmmm
16:22:24 <ehird`> memoized factorial is slower than pure, when parallelized
16:22:25 <ehird`> crazy
16:22:34 <ehird`> @src foldr'
16:22:35 <lambdabot> Source not found. You speak an infinite deal of nothing
16:22:36 <ehird`> @src foldr
16:22:36 <lambdabot> foldr k z xs = go xs
16:22:36 <lambdabot>     where go []     = z
16:22:36 <lambdabot>           go (y:ys) = y `k` go ys
16:22:46 <ehird`> by the way, i forget - which of the folds are considered bad?
16:22:51 <ehird`> and which are considered useful?
16:22:56 <ehird`> i need to decide which ones to implement :-)
16:23:16 <cjb> ehird`: see dons' blog post on this; it's the the cost of parallellizing repeated fact(low n).
16:23:29 <oerjan> ehird`: factorial has too much data dependency - you _cannot_ calculate n! until you have (n-1)!
16:23:35 <oerjan> that's my guess
16:23:44 <ehird`> oerjan: parallel factorial is fast, though.
16:23:52 <ehird`> just not memoized parallel factorial.
16:24:02 <cjb> (oops, ignore me, I misunderstood.)
16:24:28 <wagle_home> nah..  fact 10 = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10, and you can associate * any way you want
16:24:32 <oerjan> ehird`: foldl is usually bad
16:24:45 <ehird`> oerjan: righties
16:25:05 <ehird`> wagle_home: right now i'm having (n *) as the function, and the rest of the fact as the argument
16:25:07 <oerjan> wagle_home: i meant using the (n *) splitup above
16:25:11 <ehird`> since it paralellizes on the argument
16:25:18 <ehird`> and it's simpler
16:25:46 <wagle_home> oerjan, ok..  i didnt understand papply
16:26:12 <ehird`> wagle_home: f `papply` x evaluates x in another thread (basically), then applies (f x)
16:26:31 <ehird`> x `papply` y `papply` z <-- y and z are evaluated simultaneously, then it's (x y z)
16:26:37 <wagle_home> but if the compiler unrolls the loop, then it can re-associate it, maybe
16:27:08 <oerjan> gwern: [a] matches m a with m = [] so the instances are conflicting (overlapping).  note that only the part to the right of => is considered during instance lookup.
16:27:21 <wagle_home> ... with more cleverness needed for unknown n
16:28:22 <wagle_home> thinking out loud sux sometimes
16:28:54 <gwern> oerjan: I don't understand; the data type declaration doesn't have any lists in it
16:29:06 <gwern> it looks like 'data LABEL = LABEL String deriving Show'
16:29:19 <oerjan> gwern: you _might_ be able to fix it with the AllowOverlappingInstances (?) language flag
16:29:36 <wagle_home> ehird`, ick, thats producing a thread for every multiply, then doing the threads one at a time
16:29:38 <ehird`> gwern: is this BASIC?
16:29:38 <ehird`> :)
16:29:51 <ehird`> wagle_home: no, i'm pretty sure it's doing it all in parallel...
16:29:55 <gwern> I alreayd have '{-# LANGUAGE ExistentialQuantification, OverlappingInstances #-}' in
16:29:57 <ehird`> since it works for other functions
16:30:03 <gwern> ehird`: dunno. let me check LINE 1
16:30:05 <oerjan> i see
16:30:20 <ehird`> wagle_home: well, feel free to suggest how to make it do what i said
16:30:30 <ehird`> is the fib i pasted correct?
16:30:51 <oerjan> gwern: hm it may be the actual problem is somewhere else, it's just your data declaration discovers it
16:31:16 <oerjan> when it needs the Show String instance for derifing the Show for LABEL
16:31:26 <gwern> probably in the ShowMonad.lhs it mentions, then
16:31:26 <ehird`> oerjan: foldl' and foldr are the ones to do
16:31:27 <ehird`> correct?
16:31:51 <ehird`> @src foldr
16:31:52 <lambdabot> foldr k z xs = go xs
16:31:52 <lambdabot>     where go []     = z
16:31:52 <lambdabot>           go (y:ys) = y `k` go ys
16:32:02 <wagle_home> seem to have to know how many threads to give to the factorial application
16:32:17 <ehird`> wagle_home: doesn't it spawn it at `par`-time?
16:32:56 <wagle_home> ehird`, i know nothing about parallel haskell..  just (*ahem*) parallel fortran
16:32:59 <gwern> hm. adding OverlappingInstances to ShowMonad.lhs changes the error messages
16:33:08 <oerjan> ehird`: mostly yes
16:33:19 <ehird`> wagle_home: so ... you are wrong, I guess? :)
16:33:25 <ehird`> oerjan: is he right though?
16:33:33 <wagle_home> ehird`, wrong about what?
16:33:39 <ehird`> wagle_home: the thread stuff.
16:33:47 <oerjan> gwern: that Show (m a) instance will overlap with the Show [a] from the Prelude, yes
16:33:55 <ehird`>     Occurs check: cannot construct the infinite type: b = [b] -> [b]
16:33:55 <ehird`>     When generalising the type(s) for `pfoldl''
16:33:55 <ehird`> wtf
16:33:56 <ehird`> :D
16:33:58 <wagle_home> ehird`, which thread stuff?
16:33:59 <ehird`> i didn't change pfoldl'
16:34:03 <ehird`> wagle_home: papply...
16:34:20 <ehird`> oh
16:34:21 <ehird`> duh
16:35:02 <wagle_home> ehird`, you said it spawned a thread for each multiply, leaving each multiply blocked waiting for the value of the right hand thread
16:35:11 <ehird`> @type foldl'
16:35:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:35:20 <ehird`> wagle_home:           fact' n = (n *) `papply` fact (n-1)
16:35:28 <ehird`> oh
16:35:29 <ehird`> you're right
16:35:33 <ehird`> of course.
16:35:37 <ehird`> OK, fact is something to memoize, but not parallelize.
16:35:37 <ehird`> :0
16:35:54 <cjb> ehird`: fib is the reverse somewhat
16:36:12 <ehird`> cjb: well, i memoize and parallelize fib
16:36:15 <ehird`> and it does very well
16:36:24 <ehird`> i need to memoize it, really, otherwise i'd have twice as many threads
16:36:26 <ehird`> @type foldr
16:36:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:36:29 <oerjan> ehird`: unless you parallelize by splitting the list to productize
16:36:43 <ehird`> oerjan: good point
16:36:45 <ehird`> well
16:36:49 <ehird`> that's just using 'pproduct'
16:36:49 <ehird`> :)
16:36:55 <ehird`> @src product
16:36:55 <lambdabot> product = foldl (*) 1
16:37:01 <ehird`> foldl -> pfoldl'
16:37:03 <ehird`> voila
16:37:06 <mux> @pl \x f -> f $! (foo x)
16:37:06 <lambdabot> flip ($!) . foo
16:37:26 <ehird`> oh
16:37:30 <ehird`> that product solution isn't so good.
16:37:33 <ehird`> it means you can't memoize.
16:37:39 <ehird`> reasonably.
16:38:05 <oerjan> ehird`: that also has the advantage that multiplying evenly sized numbers is faster than including lots of small ones one by one
16:38:24 <ehird`> oerjan: what do you suggest?
16:38:34 <ehird`> i have fact n = pproduct [2..n]
16:38:40 <ehird`> where pproduct = pfoldl' (*) 1
16:38:45 <ehird`> and pfoldl' f a (x:xs) = flip (pfoldl' f) xs `papply` f a x
16:39:16 <ehird`> it's better than the other solution, but would be nice to memoize and reap advantages of that.
16:39:16 <oerjan> ehird`: you can memoize the product of certain subranges
16:39:24 <oerjan> say 2^n length ones
16:39:29 <ehird`> oerjan: true.. that's gonna make the function really complex though.
16:40:02 <faxathisia> Is there a name for a = b -> a = c -> b = d -> c = d ?
16:40:14 <ehird`> faxathisia: ridiculous?
16:40:17 <faxathisia> :(
16:40:21 <faxathisia> I think not!
16:40:28 <ehird`> I wonder what 'pfix' would entail.
16:40:34 <faxathisia> a = b -> b = c -> a = c is trasitivity..
16:41:07 <ehird`> pfix f = f `papply` pfix f
16:41:12 <oerjan> faxathisia: yours is a combination of transitivity and symmetry
16:41:24 <ehird`> assuming you can do infinite computation, that is more efficient than pfix.
16:41:26 <ehird`> s/pfix/fix
16:41:31 <faxathisia> yeah, two uses of each
16:41:38 <faxathisia> I need to name this lemma :S
16:41:55 <ehird`> faxathisia: call it 'dia'
16:43:08 <ehird`> ddarius: what did you suggest to call papply again?
16:43:08 <oerjan> ehird`: but fix shares the representation
16:43:15 <ehird`> oerjan: true, i guess
16:43:22 <ehird`> pfix f = f `papply` x where x = pfix f
16:43:24 <ehird`> but that's just fix, iirc
16:43:26 <oerjan> so all you are doing is doing the same work twice...
16:43:42 <ehird`> oerjan: To be honest I'm doing infinite work.. in parallel
16:43:56 <ehird`> papply kind of kills laziness :)
16:43:58 <olsner> faxathisia: a = b -> b = d -> d = c -> c = a ?
16:44:31 <oerjan> ehird`: ddarius said $* i think
16:44:46 <ehird`> is * the international symbol of parallelism? :P
16:44:52 <ehird`> personally, i think of 'program arguments', from perl and bash.
16:45:12 <oerjan> i would think | would be a closer match to that...
16:45:33 <faxathisia> olsner: Well that's true, but it's not what I need to name
16:45:36 <ehird`> so, i have map, foldl', foldr, product
16:45:50 <ehird`> what else would be very beneficial to `papply`/spike -ize?
16:46:12 <oerjan> filter
16:46:51 <olsner> faxathisia: hmm, if you view that as a graph, you get b and c as different parallel paths to d
16:47:32 <ehird`> oerjan: indeed! and find?
16:47:41 <oerjan> perhaps
16:47:53 <faxathisia> olsner: Yeah, It's like a rectangle.. I was thinking eqrect but that's got connotations I don't like
16:47:55 <oerjan> faxathisia: hm starts sounding like graph connectivity...
16:47:58 <ehird`> well, time to get bog-standard prelude definition:
16:48:05 <ehird`> faxathisia: eqrect..heh
16:48:10 <ehird`> @src filter
16:48:10 <lambdabot> filter _ []     = []
16:48:11 <lambdabot> filter p (x:xs)
16:48:11 <lambdabot>     | p x       = x : filter p xs
16:48:11 <lambdabot>     | otherwise = filter p xs
16:48:18 <ehird`> @src filter
16:48:18 <lambdabot> filter _ []     = []
16:48:18 <lambdabot> filter p (x:xs)
16:48:18 <lambdabot>     | p x       = x : filter p xs
16:48:18 <lambdabot>     | otherwise = filter p xs
16:49:12 <hpaste>  ehird pasted "i think this pfilter is OK but maybe it's missing something" at http://hpaste.org/5675
16:49:19 <ehird`> i think the problem is the same as with factorial
16:49:22 <ehird`> i'm doing many little conses
16:49:29 <ehird`> maybe:
16:49:32 <ehird`> i should just do:
16:49:35 <ehird`> pfilter = spike filter
16:49:49 <ehird`> or at least change into:    pfilter p (x:xs) | p x       = spike (x : filter p xs)
16:49:50 <olsner> it's like equivalence classes if you think in sets, or connected components if you think in graphs
16:50:42 <ehird`> any suggestions for improving pfilter would be welcome
16:50:43 <ehird`> @src find
16:50:43 <lambdabot> find p          = listToMaybe . filter p
16:50:53 <ehird`> ah.
16:50:56 <ehird`> that's not exactly hard :P
16:51:00 <olsner> but why does this lemma need a name?
16:51:11 <ehird`> @src select
16:51:11 <lambdabot> Source not found. Take a stress pill and think things over.
16:51:14 <ehird`> hmm
16:51:17 <ehird`> what is that one i'm thinking of..
16:51:40 <faxathisia> I use it in my proof :)
16:52:18 <ehird`> > length [1..] :: Expr
16:52:24 <olsner> faxathisia: name it after me!
16:52:29 <ehird`> lame, lambdabot. lame.
16:52:31 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Int'
16:52:34 <faxathisia> lol
16:52:40 <ehird`> eh whut
16:52:56 <ehird`> > let len [] = 0; len (_:xs) = 1 + len xs in len [1..] :: Expr
16:52:59 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
16:53:01 <ehird`> yay
16:53:15 <ehird`> 'It is an instance of the more general genericLength, the result type of which may be any kind of number.'
16:53:21 <ehird`> how can you have 5.4 oranges../
16:53:22 <ehird`> :P
16:53:25 <ehird`> oooh
16:53:28 <ehird`> preverse
16:53:51 <wli> > genericLength [1..5] :: Expr
16:53:52 <lambdabot>  1 + (1 + (1 + (1 + (1 + 0))))
16:53:55 <ehird`> i could use the prelude:
16:53:57 <ehird`> preverse = pfoldl' (flip (:)) []
16:53:59 <ehird`> but ghc uses a custom one
16:55:26 <ehird`> actually...
16:55:34 <ehird`> there's not much parallelization to do with reverse
16:55:35 <ehird`> is there?
16:55:58 <olsner> preverse? *perverse :P
16:56:26 <ehird`> it seems like instead of
16:56:27 <ehird`> papply f a = a `par` f a
16:56:28 <ehird`> i also want
16:56:32 <ehird`> papply f a = f `par` f a
16:56:41 <ehird`> wait, no
16:56:46 <ehird`> papply f a = f `par` a `par` f a
16:56:51 <ehird`> but then.. that's just
16:56:57 <ehird`> papply, really, isn't it?
16:58:00 <ehird`> ok, preverse is useless
16:58:27 <ehird`> hmm
16:58:30 <ehird`> foldl' isn't in the prelude?
16:58:49 <ehird`> hmm
16:58:58 <ehird`> scanl wouldn't actually be useful parallelized would it?
16:59:59 <oerjan> might depend on laziness of the operator
17:00:18 <oerjan> if you can calculate some parts without looking at the rest, sometimes
17:00:34 <ehird`> oerjan: think it's worth doing?
17:01:06 <dolio> faxathisia: Did you build Agda2 yourself?
17:01:28 <faxathisia> Yes
17:01:32 <oerjan> probably not very often?
17:01:49 <faxathisia> I installed various libs then it works ok with 6.8.2
17:02:01 <ehird`> oerjan: ok
17:02:15 <ehird`> any other commonly-used ops that can be trivially parallelized? I guess i could do the monadic loops
17:02:50 <dolio> Which version? 2.1.2?
17:04:05 <faxathisia> make sure to get the darcs,
17:04:06 <faxathisia> darcs get --partial http://www.cs.chalmers.se/~ulfn/darcs/Agda2
17:04:08 <lambdabot> Title: Index of /~ulfn/darcs/Agda2
17:04:30 <faxathisia> I think someone here got the latest and it didn't build
17:04:35 <faxathisia> but darcs is working for me ..
17:04:39 <dolio> Oh. Hmm. I tried that one too, but it wanted QuickCheck > 2 or something.
17:05:39 <dolio> I guess I need to get that from darcs, too.
17:06:18 <ehird`> q:
17:06:23 <ehird`> what crazy stuff does ghc do to stdin?
17:06:31 <ehird`> 'interact' will respond to spaces, or even single chars
17:06:40 <ehird`> i.e. it reads as little as possible -- but my console driver should stop that!
17:06:47 <ehird`> does it use ioctl or something?
17:12:51 <faxathisia> This is a lot of fun http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.TypesSummerSchool2007
17:12:53 <lambdabot> Title: 28 The Agda Wiki - Types Summer School 2007 4b, http://tinyurl.com/yuktth
17:13:01 <faxathisia> as an intro to Agda 2, pretty tricky though at parts
17:23:00 <psykon> a network library?
17:25:05 <psykon> *networking
17:28:24 <yondalf> @hoogle openFd
17:28:25 <lambdabot> No matches found
17:30:53 <shapr> wargh
17:31:07 <faxathisia> hiya
17:32:12 <shapr> So, uh... what's this functional programming I keep hering about?
17:32:29 <faxathisia> lol
17:32:36 <shapr> I think my spelling is too good to pretend to be a newbie :-(
17:32:48 <oerjan> always keep herring around, it's full of healthy lipids
17:32:52 <dolio> @protontorpedo
17:32:52 <lambdabot> so haskell is different from lisp?
17:32:56 <faxathisia> something to do with e ::= v | \e->e | (e e)
17:33:02 <shapr> dolio: Good one
17:35:20 <shapr> I really wanted to code today, but I missed the UPS delivery for my new keyboard :-(
17:35:36 <jeffz> an APL keyboard?
17:35:48 <shapr> Nah, kinesis contoured.
17:35:59 <shapr> G'day jeffz, how's code?
17:36:25 <shapr> I don't like coding on laptop keyboards. Standard keyboards aren't much better.
17:36:26 <jeffz> shapr: good, lazily learning to make good use of parsec
17:36:29 * shapr is a keyboard snob.
17:36:36 <shapr> jeffz: Hah, what have you got so far?
17:36:43 <faxathisia> lazy learning, the best way!
17:36:57 <shapr> Today's lecture is about lazy evalution. ... Any questions?
17:37:08 <faxathisia> (start to write somenthing and learn by need .. really  works)
17:37:13 * dolio has been using a $10 keyboard for a couple years now.
17:37:23 <jeffz> shapr, something which gives the total value of gems for auctioning, when someone inputs the contents of their inventory from a mud I play on
17:37:33 <shapr> dolio: Kinesis keyboards are like thirty five times that.
17:37:44 <jeffz> shapr, something simple, I have some other ideas for what I'm going to do next.
17:37:49 <shapr> jeffz: Sounds cool.
17:38:09 <shachaf> shapr: What does spelling have to do with being new?
17:38:36 <shapr> shachaf: #haskell standards for spelling are much higher than other irc channels I've visited.
17:38:57 <shapr> Things like spelling and punctuation are mostly optional on other freenode channels.
17:39:07 <shapr> Er, open projects? What's this network called again? :-/
17:39:32 <araujo> hello shapr , new to haskell? we could probably give you a tour
17:39:49 <shachaf> Things like capitalization, at least, seem to be pretty optional here too. :-)
17:39:50 <shapr> araujo: lol, u r so nice!
17:39:50 <EvilTerran> most channels aren't full of people sensitised to poor english by all the time spent proof-reading their papers :P
17:39:52 <Pseudonym> Going to do a talk at Melbourne Functional Programming Union now.  Wish me luck!
17:39:56 * shapr causes himself pain.
17:39:59 <araujo> shapr, haha :-)
17:40:07 <shapr> shachaf: Ok, could be true :-)
17:40:44 <shapr> shachaf: But then, should you capitalize #haskell at the beginning of a sentence? Technically, IRC channel names are not case sensitive, but I prefer to write code as I would use it.
17:40:54 <shapr> good luck pseudonym!
17:41:14 <shachaf> shapr: No, #haskell is lower-case, I think.
17:41:20 <shapr> Ok, just wondering.
17:41:22 <LoganCapaldo> you should capitalize every little of #haskell. afer all, this. is. #HASKELL !!!!
17:41:31 <shachaf> shapr: I didn't mean you, I meant in general. :-)
17:41:34 * shapr grins
17:41:40 <shachaf> But I guess it's better here than some other channels, yes.
17:41:47 <oerjan> shapr: wait a minute, i distinctly feel my spelling has deteriorated since i joined #haskell
17:42:02 <yondalf> does anyone here use hinotify? i have problems with hinotify's use of openFd
17:42:12 <shapr> My recent experiences in ##csharp have been, um.. hm. Not so positive.
17:42:21 <dolio> Ooo, Agda has parameterized modules.
17:42:23 <shapr> yondalf: Last I used hinotify, it worked fine for me.
17:43:05 <faxathisia> Agda rules *g*
17:43:40 <faxathisia> I really struggle to understand the source code though
17:43:53 <shapr> @users
17:43:53 <lambdabot> Maximum users seen in #haskell: 463, currently: 419 (90.5%), active: 15 (3.6%)
17:44:15 <faxathisia> (I guess I need to do a deptypes implementation to make sense of it :S)
17:44:46 <dolio> Writing a dependently typed language is the new monad tutorial.
17:45:01 <shapr> ooh
17:45:19 <olsner> @quote newbie
17:45:19 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
17:45:30 * ddarius isn't even a newbie.
17:45:31 * jaredj raises hand
17:45:57 <dolio> Yeah, I'm not a newbie yet, either.
17:46:09 <ddarius> Actually, I probably have implemented a compiler...
17:46:21 <shapr> I haven't, I feel so n00bish.
17:46:28 <LoganCapaldo> I was an almost newbie for a long time
17:46:36 <LoganCapaldo> hen I wrote a monad tutorial
17:46:43 <faxathisia> mm...
17:46:50 <shapr> I wrote an arrows tutorial, does that count?
17:46:56 <ddarius> LoganCapaldo: Did you flagellate yourself appropriately afterwards?
17:47:03 <jaredj> ARROWED 2: ELECTRIC wait a minute...
17:47:03 <olsner> I'm skipping the monad tutorial and going for the compiler instead
17:47:04 <LoganCapaldo> violently so
17:47:11 <vininim> Does following "scheme in 48 hours"(or something like that) counts?
17:47:24 <olsner> hmm, is that a compiler or an interpreter?
17:47:33 <wagle_home> i did the compiler, but not the tutorial..  maybe i can write a compiler from monads to tutorials
17:47:48 <jaredj> http://www.homestarrunner.com/tgs10.html
17:47:49 <lambdabot> Title: Tenth Issue-versary!!
17:48:04 <vininim> A interpreter actually
17:48:08 <vininim> *An
17:48:29 <jaredj> "police have apprehended the alleged comperpreter"
17:48:48 <LoganCapaldo> i wrote a calculator
17:49:09 <LoganCapaldo> but it's only a calculator interpreter
17:49:11 <LoganCapaldo> heheh
17:49:18 <LoganCapaldo> dc compiler
17:49:24 <LoganCapaldo> definitely need one of those
17:49:38 <sarehu> dc is the RPN one?
17:50:07 <LoganCapaldo> i don't even remember which is which
17:50:14 <LoganCapaldo> either way
17:50:36 <jaredj> dc is the rpn one
17:50:38 <jaredj> bc is the infix one
17:51:16 <jaredj> serious question: does anyone try to run haskell on embedded platforms?
17:51:40 <blackdog> you mean like lambdacalc in a can?
17:52:12 <faxathisia> > foldl f z [a,b,c,d]
17:52:16 <lambdabot>  f (f (f (f z a) b) c) d
17:52:19 <faxathisia> > foldr f z [a,b,c,d]
17:52:20 <lambdabot>  f a (f b (f c (f d z)))
17:52:20 <ddarius> jaredj: There are quite a few ways Haskell and Haskell derived languages are running on embedded platforms.
17:52:43 <dolio> > foldr f z [a .. e]
17:52:44 <lambdabot>  Exception: not a number
17:53:04 <EvilTerran> > foldr f e (repeat x)
17:53:04 <lambdabot>  f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f...
17:53:07 <EvilTerran> > foldl f e (repeat x)
17:53:10 <lambdabot> Terminated
17:53:22 <EvilTerran> and there's (part of) the trouble with foldl :)
17:53:28 <LoganCapaldo> EvilTerran is the Terminator
17:54:13 <blackdog> ddarius: really? for what value of "embedded"?
17:54:20 <blackdog> are we talking PIC chips or cell phones?
17:54:54 <ddarius> A variety depending on how widely you interpret "Haskell".
17:55:07 <dolio> faxathisia: Do you use the emacs mode?
17:55:20 <faxathisia> Yes, It's very good
17:55:26 <dolio> What's it do?
17:55:41 <blackdog> ddarius: would probably settle for laziness and HM types
17:55:41 <redleafgr> auto-tabs
17:55:46 <olsner> EvilTerran: eh, where is that f and e and x defined?
17:55:47 <faxathisia> you get some feedback as you work, tells you what metavars should be and such
17:55:57 <dolio> Ah, okay.
17:56:05 <olsner> @src f
17:56:05 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:56:07 <faxathisia> but I think you can do a lot more with it.. I have only started with Agda
17:57:16 <EvilTerran> ?where simplereflect
17:57:16 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
17:58:40 <vininim> what is the complement of (!!)
17:58:45 <vininim> ?
17:58:56 <yondalf> what do you mean by complement?
17:59:04 <faxathisia> You mean, to insert an element into a list?
17:59:17 <vininim> list without the element
17:59:58 <vininim> I thought there was some built-in related to it
18:00:19 <yondalf> :t (!!)
18:00:20 <lambdabot> forall a. [a] -> Int -> a
18:00:28 <yondalf> @hoogle [a] -> Int -> a
18:00:29 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
18:00:29 <lambdabot> Data.List.(!!) :: [a] -> Int -> a
18:00:33 <oerjan> > let delAt n l = bef++aft where (bef,_:aft) = splitAt n l in delAt 5 [1..10]
18:00:34 <lambdabot>  [1,2,3,4,5,7,8,9,10]
18:00:37 <yondalf> looks like there isn't any
18:01:22 <sarehu> > ((second tail .) . splitAt) 5 [1..10]
18:01:23 <yondalf> > let delAt l n = take n l ++ drop (n+1) l in [1..10] `delAt` 5
18:01:23 <Cale> I really wish there were a function select :: [a] -> [(a,[a])] in Data.List
18:01:24 <lambdabot>  ([1,2,3,4,5],[7,8,9,10])
18:01:25 <lambdabot>  [1,2,3,4,5,7,8,9,10]
18:01:28 <sarehu> er, screw
18:02:06 <sarehu> you're not the only one who's had that desire Cale
18:02:13 <vininim>  f i n (x:xs) = if i == n then f (i+1)  n xs else x:f (i+1) n xs
18:02:18 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1,2,3]
18:02:18 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
18:02:25 <faxathisia> Cale, me too
18:02:39 <faxathisia> > let select [] = [] ; select (x:xs) = (x,xs) : map (second (x:)) (select xs) in select "foobar"
18:02:40 <lambdabot>  [('f',"oobar"),('o',"fobar"),('o',"fobar"),('b',"fooar"),('a',"foobr"),('r',...
18:03:28 <ddarius> Incidentally, vininim, "built-in" isn't really good terminology for the vast majority of Haskell functions.
18:03:31 <LoganCapaldo> select?
18:03:38 <LoganCapaldo> pick I think
18:03:55 <LoganCapaldo> vastly cooler name
18:03:57 <Cale> > let selectSplit [] = []; selectSplit (x:xs) = ([],x,xs) : [(x:ysl,y,ysr) | (ysl,y,ysr) <- selectSplit xs] in selectSplit [1,2,3,4]
18:03:58 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
18:03:59 <gwern> http://fedoraproject.org/wiki/Features/GoodHaskellSupport <-- mentions a 'Meep', which I've never heard of
18:03:59 <lambdabot> Title: Features/GoodHaskellSupport - Fedora Project Wiki
18:04:05 <Cale> That one's also pretty useful.
18:04:08 <faxathisia> LoganCapaldo: Well we I use it as in Prolog
18:04:12 <gwern> @where meep
18:04:12 <lambdabot> http://ab-initio.mit.edu/~meep/meep/
18:04:18 <faxathisia> and it's called select in the standard
18:04:49 <LoganCapaldo> I am the standard!
18:04:55 <Cale> faxathisia: Oh? That's interesting, I don't think I knew about it, at least not consciously :)
18:05:04 <gwern> LoganCapaldo: ED IS THE STANDARD (text editor)!
18:05:40 <gwern> :( meep's TODO doesn't mention cabalization
18:06:36 <gwern> how do you update lambdabot's where? its meep entry points to the darcs repo and not the homepage, http://ab-initio.mit.edu/meep/
18:06:36 <lambdabot> Title: Meep
18:06:43 <ddarius>  @where+
18:07:14 <gwern> @where+ meep http://ab-initio.mit.edu/meep/
18:07:14 <lambdabot> Good to know.
18:07:18 <gwern> @where meep
18:07:18 <lambdabot> http://ab-initio.mit.edu/meep/
18:13:27 <gwern> ew. Meep is an agglomeration of C++, autotools, fortran, and haskell
18:13:35 * gwern wonders what the devs were thinking
18:13:44 <gwern> guess I'll just cabalize the haskell section then...
18:15:20 <sfultong> who here thinks we should get rid of IORefs, and just stick with TVars? :-P
18:15:39 <Cha1> Do you mean MVars?
18:15:41 <faxathisia> well.. I guess I'll read about TVars
18:16:06 <sfultong> Cha1: umm, whatever the name is of those STM thingies
18:16:24 <Cha1> Ahh, you do mean TVars :)
18:16:25 <sfultong> perhaps it's more overhead, but a little overhead never killed anyone
18:17:04 <sfultong> plus, you shouldn't be using either all that much
18:17:58 <Cha1> Well, good to have nice abstractions on the impure side as well
18:18:28 <sfultong> can you elaborate?
18:20:02 <dolio> TVars are like MVars, only for transactional memory instead of locking.
18:20:09 <Cha1> right
18:20:26 <Cale> faxathisia: Out of interest, which Prolog standard?
18:20:48 <Cha1> But sometimes a simple lock is enough, and MVars are nicer in a concurrent context that IORefs in that case
18:20:55 <sfultong> oh, MVars are the old more traditional concurrency thingies
18:21:12 <Cha1> yes
18:21:41 <Cha1> which is fine a lot of the time, and there's not much overhead
18:22:16 <sfultong> well, ok... so maybe MVars and TVars, but not IORefs?
18:22:50 <Cha1> Yeah, my understanding is that you shouldn't use IORefs unless you know there won't be any concurrency
18:23:16 <Cha1> And even then an MVar works fine
18:23:25 <sfultong> so you agree with me :)
18:23:40 <Cha1> Yeah, looks that way :)
18:23:40 <sarehu> bah, don't take my IORefs away
18:24:26 <ddarius> mjd...
18:24:53 <vininim> uh.. what is the syntax for exporting a constructor(which has the same name as the datatype)? I thought module (Constr1, Constr2) did it
18:25:06 <LoganCapaldo> burn the land and boil the sea, you can't take my IORefs from me
18:25:15 <LoganCapaldo> ( T(Ctor) )
18:25:25 <LoganCapaldo> or ( T(..) ) for all of them
18:25:29 <vininim> oh thanks
18:25:34 <yondalf> vininim: http://www.haskell.org/tutorial/modules.html for more info
18:25:35 <lambdabot> Title: A Gentle Introduction to Haskell: Modules
18:25:40 <yrlnry__> ddarius...?
18:27:12 <sfultong> I'm tired of all this diversity of concurrency solutions... we should just get behind One True Concurrency Solution and purge the rest
18:27:26 <faxathisia> Cale, It was defined in Edinburgh Prolog
18:27:44 <Cha1> Not that many, really. Compare the number of options for arrays
18:27:53 <faxathisia> http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/code/tools/edinbrgh/    The def is in /data/sets/setutl.pl
18:27:54 <lambdabot> Title: Index of /afs/cs/project/ai-repository/ai/lang/prolog/code/tools/edinbrgh, http://tinyurl.com/32cgec
18:27:55 <sfultong> yeah, I don't like that, either
18:28:07 <sfultong> diversity in programming languages is evil :-P
18:28:34 <Cha1> "the great thing about standards is there are so many to choose from"
18:28:49 <ddarius> I'm wondering if you are the mjd I know about.
18:29:06 <faxathisia> Cha1: Any given standard is not the best one ?
18:29:14 <ddarius> sfultong: We should all standardize on FORTRAN
18:29:28 <yrlnry__> Which mjd do you know about?
18:29:36 * wagle_home agrees with ddarius ...  go back to our roots
18:29:44 <ddarius> Mark Jason Dominus
18:29:48 <Cha1> faxathisia: there can be a best one in many cases, I just think the quote is cute
18:30:14 <sfultong> ddarius: well, that would make some things easier... I would spend less time on IRC
18:30:40 <faxathisia> Cale, I should really have de-facto Standard :S
18:31:14 <faxathisia> (it's not in ISO, just that nearly eveyone based their implementations on and used code written by the Edinburgh guys)
18:31:20 <Cale> yeah
18:31:36 <Cale> faxathisia: I was actually unaware that Prolog had been standardised at all, but yeah, there is an ISO standard.
18:31:39 <Cha1> On the other hand, too much standardization can hurt research efforts
18:31:50 <faxathisia> the ISO standard has a bug :P
18:31:52 <sfultong> hey, does anyone have an opinion on Clojure?
18:31:53 <Cale> The ISO standard doesn't seem to specify a whole lot about libraries.
18:32:10 <Cale> Cha1: I agree.
18:32:30 <qwr> sfultong: lisp on jvm ;)
18:33:14 * qwr prefers ML on jvm...
18:33:20 * ddarius doesn't like the name "all-pass filter"
18:33:29 <sfultong> qwr: is that all there is to say on it?
18:33:46 <sfultong> what's the name of ML on jvm?
18:33:59 <EvilTerran> is that F#?
18:34:02 <qwr> sfultong: i'm writing one at the moment.
18:34:10 <sfultong> qwr: ah, neat
18:34:28 <faxathisia> qwr, in haskell?
18:34:32 <yrlnry__> ddarius: that's my name.  But I do know a guy in Texas named Marc Dominus.
18:35:18 <mrd> EvilTerran: that's .NET
18:35:21 <ddarius> Just want to associate the nick with the name.
18:35:30 <EvilTerran> mrd, ah, yes, of course it is
18:35:55 <qwr> faxathisia: sadly not.
18:36:02 <faxathisia> what then?
18:36:16 <yrlnry__> ddarius: Hi!  I don't remember knowing you from anywhere except here.
18:36:32 <yrlnry__> I hope I don't owe you money or something.
18:36:35 <ddarius> I haven't met you in person.  I've emailed you once or twice.
18:36:47 <yrlnry__> Wait, you're not that guy I beat up behind the Trocadero in 1998, are you?
18:37:03 <ddarius> Were you in Virginia in 1998?
18:37:32 <yrlnry__> Even if I was, I don't think the Trocadero can move that far.
18:37:39 <yrlnry__> You emailed me about differential equations.
18:37:51 <ddarius> The behavioural ones, yes.
18:37:57 <gwern> bleh. I don't like literate haskell files; they seem to mess up ghci's line count in error messages
18:38:13 <faxathisia> sounds like a bug :S
18:38:16 <qwr> faxathisia: i thought at the beginning, that bootstrapping is easier when i write it in java. now its much more java code than i like. :(
18:38:38 <gwern> @pl loop_polarizations jb = if_ "pol" $ doblock "for (polarization *p = pol; p; p = p->next)" jb
18:38:38 <lambdabot> loop_polarizations = if_ "pol" . doblock "for (polarization *p = pol; p; p = p->next)"
18:38:50 <sfultong> qwr: in java? ewww
18:39:02 <sfultong> qwr: how about in Clojure? :-P
18:39:17 <faxathisia> qwr, Is the code online? (I think it would be interesting to see anyway)
18:39:20 <yrlnry__> ddarius: thanks again for that.  I haven't followed up the reference yet, but I will sooner or later.
18:39:25 <dozer> I've got fed up and decided to code up the w3c xml/webservice standards from scratch
18:39:30 <gwern> @pl loop_sources start svar job = if_ start $ doblock ("for (src_vol *"++svar++" = "++start++"; "++ svar++"; "++svar++" = "++svar++"->next)") job
18:39:32 <lambdabot> loop_sources = ap ((.) . (.) . if_) (((doblock . ("for (src_vol *" ++)) .) . ap (++) . ((" = " ++) .) . (. (("; " ++) . ap (++) (("; " ++) . ap (++) ((" = " ++) . (++ "->next)"))))) . (++))
18:39:36 <dozer> is there a standard way to structure modules conforming to w3c standards?
18:39:40 <EvilTerran> oh, pain
18:39:59 <gwern> nested use of arguments always leads to nasty @pl output
18:40:09 <gwern> @unpl  loop_sources = ap ((.) . (.) . if_) (((doblock . ("for (src_vol *" ++)) .) . ap (++) . ((" = " ++) .) . (. (("; " ++) . ap  (++) (("; " ++) . ap (++) ((" = " ++) . (++ "->next)"))))) . (++))
18:40:09 <lambdabot> loop_sources = (\ x b c f -> if_ x (b c f)) >>= \ q -> (\ ad bu -> doblock ("for (src_vol *" ++ (((++) >>= \ al -> (\ bx -> " = " ++ ad ++ ("; " ++ (((++) >>= \ bb -> (\ bi -> "; " ++ (((++) >>= \
18:40:09 <lambdabot> bk -> (\ br -> " = " ++ (br ++ "->next)")) >>= \ bj -> return (bk bj)) bi)) >>= \ ba -> return (bb ba)) bx))) >>= \ ak -> return (al ak)) bu))) >>= \ p -> return (q p)
18:40:18 <gwern> wut
18:40:28 <qwr> faxathisia: http://linux.ee/~mzz/yeti/ is current snapshot. some necessery functionality missing and no documentation yet. but there are some short examples.
18:40:29 <lambdabot> Title: Index of /~mzz/yeti
18:40:37 <faxathisia> ty
18:41:14 <gwern> @pl loop_sources = (\ x b c f -> if_ x (b c f)) >>= \ q -> (\ ad bu -> doblock ("for (src_vol *" ++ (((++) >>= \ al -> (\ bx -> " = " ++ ad ++ ("; " ++ (((++) >>= \ bb -> (\ bi -> "; " ++ (((++) >>= \bk -> (\ br -> " = " ++ (br ++ "->next)")) >>= \ bj -> return (bk bj)) bi)) >>= \ ba -> return (bb ba)) bx))) >>= \ ak -> return (al ak)) bu))) >>= \ p -> return (q p) -- bwa ha ha!
18:41:18 <lambdabot> loop_sources = (((doblock . ("for (src_vol *" ++)) .) . ((++) >>=) . (. (return .)) . (>>=) . ((" = " ++) .) . (. (("; " ++) . ((("; " ++) . (((" = " ++) . (++ "->next)") >>=) . (return .) =<< (++))
18:41:19 <lambdabot> >>=) . (return .) =<< (++)))) . (++) >>=) . (return .) =<< (.) . (.) . if_
18:41:44 <sfultong> good god, man, you're hurting lambdabot
18:41:47 <Cha1> obfuscation contest?
18:41:47 <gwern> this raises an interesting question. do equations eventually reach a fixpoint in @pl/@unpl?
18:42:06 <gwern> actually, what the hell is 'doblock'?
18:42:09 <gwern> @hoogle doblock
18:42:09 <faxathisia> @@ pl unpl pl f x y = y x
18:42:11 <lambdabot> No matches found
18:42:11 <lambdabot>  pl unpl pl f x y = y x
18:42:20 <faxathisia> @@ @pl @unpl @
18:42:21 <faxathisia> pl f x y = y x
18:42:21 <lambdabot> Plugin `compose' failed with: Unknown command: ""
18:42:23 <faxathisia> pl f x y = y x
18:42:28 <faxathisia> :/
18:42:29 <ddarius> They immedieately reach a fixpoint.
18:42:39 <ddarius>  @pl is idempotent
18:43:01 <faxathisia> how do you know that? :H
18:43:06 <gwern> @unpl loop_sources = (((doblock . ("for (src_vol *" ++)) .) . ((++) >>=) . (. (return .)) . (>>=) . ((" = " ++) .) . (. (("; "  ++) . ((("; " ++) . (((" = " ++) . (++ "->next)") >>=) . (return .) =<< (++)) >>=) . (return .) =<< (++)))) . (++) >>=) . (return .) =<< (.) . (.) . if_
18:43:06 <lambdabot> loop_sources aa = (\ ad bu -> doblock ("for (src_vol *" ++ (((++) >>= \ bx -> (\ cd -> " = " ++ ad ++ ("; " ++ ((\ bf -> "; " ++ ((\ bl -> " = " ++ (bl ++ "->next)")) >>= (((++) >>= \ m cm -> return
18:43:06 <lambdabot> (m cm)) bf))) >>= (((++) >>= \ o cs -> return (o cs)) cd)))) >>= \ ca -> return (bx ca)) bu))) >>= (((\ s t u -> s (t u)) >>= \ r cy -> return (r cy)) (\ w x -> if_ aa (w x)))
18:43:30 <Cale> selectN n = runStateT . replicateM n . StateT $ select
18:43:34 <gwern> ok, enough of that :)
18:43:54 <faxathisia> qwr, heheh  static final char[] mangle = "jQh$oBz  apCmds          cSlegqt".toCharArray();
18:45:07 <qwr> faxathisia: yeah, jvm don't like all cool symbols in identifiers ;)
18:45:14 <EvilTerran> @. elite yhjulwwiefzojcbxybbruweejw
18:45:14 <lambdabot> jU5t 'j'
18:45:32 <ddarius> faxathisia: Actually, I misread your statement, but it doesn't change much.  @pl . @unpl is idempotent as is @unpl . @pl
18:45:51 <wli> exps e = let e' = pl e in e : e' : exps (unpl e')
18:45:56 <wagle_home> uh no
18:46:23 <wagle_home> @unpl \x y -> x y
18:46:23 <lambdabot> \ x y -> x y
18:46:34 <wagle_home> @pl \ x y -> x y
18:46:34 <lambdabot> id
18:46:46 <wli> let es = exps myExpr in snd . head . dropWhile (uncurry (/=)) . zip es $ tail es
18:47:17 <Cale> ddarius: So @unpl . @pl . @unpl is perhaps some kind of closure operator? :)
18:47:22 <wli> @hoogle Expr
18:47:31 <lambdabot> Text.ParserCombinators.Parsec.Expr :: module
18:47:31 <lambdabot> Distribution.Simple.Program.alexProgram :: Program
18:47:31 <lambdabot> Text.ParserCombinators.Parsec.Expr.buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
18:47:45 <wli> Doesn't look promising.
18:48:00 <Cale> er...
18:48:04 <EvilTerran> ?where simplereflect
18:48:04 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
18:48:16 <Cale> Just  @pl . @unpl  rather
18:48:38 <Cale> > foldr f z [1..5]
18:48:45 <Cale> ...
18:48:54 <lambdabot>  thread killed
18:49:01 <Cale> Come on lambdabot! You can do it!... damn.
18:49:06 <Cale> > foldr f z [1..5]
18:49:21 <lambdabot>  thread killed
18:49:29 <nornagon> > foldr f z [1..5] :: [Expr]
18:49:30 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
18:49:38 <nornagon> er, doh :)
18:49:44 <oerjan> > foldr f z [1..5] :: Expr
18:49:45 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
18:49:46 <Cale> code.h.o is really slow
18:50:02 <Cale> > foldr f z [1..5]
18:50:02 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
18:50:30 <Cale> By the looks of top, whatever was slowing it down has likely stopped.
18:50:59 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5 :: Expr
18:51:00 <lambdabot>  5 * ((5 - 1) * ((5 - 1 - 1) * ((5 - 1 - 1 - 1) * ((5 - 1 - 1 - 1 - 1) * 1))))
18:51:24 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs :: [Expr]
18:51:24 <lambdabot>  [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1)),1 + (0 + 1) + (0 + 1 + (1 + (0 ...
18:51:41 <gwern> @pl special_case _ y = y
18:51:42 <lambdabot> special_case = const id
18:51:53 <gwern> @pl special_case x y = y
18:51:54 <lambdabot> special_case = const id
18:53:34 <alinabi> module HashLib (
18:53:34 <alinabi>     Hash (..),
18:53:34 <alinabi>     Hashable (
18:53:34 <alinabi> 	xor8,
18:53:34 <alinabi> 	fnv32,
18:56:12 <alinabi> @help
18:56:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:56:20 <alinabi> @list
18:56:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:57:47 <Cale> hmm... now I'm afraid to propose this :)
18:58:04 <wagle_home> @babel babel
18:58:04 <lambdabot>   bzzt.
18:58:10 <gwern> I must not fear
18:58:17 <gwern> fear is the mindkiller, the little death...
18:58:22 <Cale> do we really want select :: [a] -> [(a,[a])], or would select :: [a] -> [([a],a)] be better?
18:58:58 <Cale> See, the first works well with the *existing* libraries, but if the MTL were fixed so that its pairs were the right way around, the second would be more convenient.
18:59:25 <gwern> why not do both? select, select'
18:59:38 <LoganCapaldo> it's pretty easy to get one from the other ...
18:59:51 <gwern> if MTL is fixed, the transition is of minimal muss; if it isn't, then you lose nothing
18:59:51 <Cale> well, we should really have  swap :: (a,b) -> (b,a)
18:59:58 <Cale> I suppose.
19:00:56 <alinabi> @help babel
19:00:56 <lambdabot> babel <lang1> <lang2> <phrase>.
19:00:56 <lambdabot> Translate a phrase in lang1 to lang2.
19:00:56 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
19:01:02 <faxathisia> I would think select :: [a] -> [(a,[a])]
19:01:35 <Cale> faxathisia: The concern is just that the second element of a pair is really the 'primary' one in Haskell.
19:01:37 <alinabi> @babel en de "The quick brown fox jumped over the lazy dog"
19:01:38 <lambdabot>   "der schnelle braune Fuchs sprang ber den faulen Hund"
19:01:45 <nornagon> @. babel de en babel de en de hello world
19:01:46 <lambdabot> Plugin `compose' failed with: Unknown command: "de"
19:01:55 <alinabi> @list
19:01:55 <faxathisia> Why is that?
19:01:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
19:01:57 <nornagon> @. babel babel de en de en de hello world
19:01:57 <lambdabot> Plugin `compose' failed with: Error: Language  not supported
19:02:00 <nornagon> rats.
19:02:05 <Cale> faxathisia: for example, the functor instance applies the function to the second element (and necessarily so, due to lack of type lambdas)
19:02:13 <Cale> > fmap (+1) (0,0)
19:02:23 <alinabi> @help elite
19:02:24 <lambdabot> elite <phrase>. Translate English to elitespeak
19:02:28 <lambdabot>  thread killed
19:02:32 <Cale> wtf.
19:02:33 <Cale> > fmap (+1) (0,0)
19:02:34 <lambdabot>  (0,1)
19:02:38 <alinabi> @help topic
19:02:38 <lambdabot> topic provides: topic-tell topic-cons topic-snoc topic-tail topic-init topic-null
19:02:50 <faxathisia> :t fmap
19:02:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:03:14 <Cale> Here, the functor is (,) s
19:03:33 <alinabi> >class Hashable a where      xor8  :: a -> Hash     fnv32 :: a -> Hash     fnv64 :: a -> Hash     defaultHash :: a -> Hash     defaultHash = fnv64
19:03:34 <Cale> So  fmap :: (a -> b) -> (,) s a -> (,) s b
19:03:43 <nornagon> @src (,) Functor
19:03:43 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:03:48 <alinabi> > class Hashable a where      xor8  :: a -> Hash     fnv32 :: a -> Hash     fnv64 :: a -> Hash     defaultHash :: a -> Hash     defaultHash = fnv64
19:03:48 <lambdabot>  Parse error at "class" (column 1)
19:03:49 <gwern> @elite I owned your box.
19:03:50 <lambdabot> i OwNEd Y0UR 8OX.
19:03:50 <Cale> or: (a -> b) -> (s,a) -> (s,b)
19:03:54 <faxathisia> ok that makes sense
19:03:55 <nornagon> @src Functor (,)
19:03:55 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:04:13 <alinabi> @help src
19:04:14 <lambdabot> src <id>. Display the implementation of a standard function
19:04:16 <gwern> @elite It's time to smurf that fool
19:04:16 <lambdabot> iT'z +IM3 t0 SMuRF tHA+ F0Ol
19:04:21 <ddarius> @src (,) fmap
19:04:21 <lambdabot> fmap f (x,y) = (x, f y)
19:04:23 <Daveman> lambdabot, I'll show you!
19:04:28 <alinabi> @src shift
19:04:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:04:30 <Cale> > fmap f (x,y)
19:04:31 <lambdabot>  Add a type signature
19:04:34 <Cale> > fmap f (x,y) :: Expr
19:04:34 <lambdabot>  Couldn't match expected type `Expr'
19:04:41 <Cale> > fmap f (x,y) :: (Expr, Expr)
19:04:42 <lambdabot>  (x,f y)
19:04:43 <gwern> hm. none of the more elaborate transformations  l337 hs, I see
19:05:24 <faxathisia> > f >>= x :: [Expr]
19:05:25 <lambdabot>  Couldn't match expected type `a -> [Expr]'
19:05:31 <faxathisia> > f >>= g :: [Expr]
19:05:32 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
19:05:38 <alinabi> > class Goe a where test :: a -> Bool
19:05:39 <lambdabot>  Parse error at "class" (column 1)
19:08:14 <oerjan> alinabi: > doesn't allow declarations, only an expression
19:09:22 <oerjan> there is no way to add types or classes to lambdabot interactively
19:10:03 <gwern> oh, that's interesting. Meep was started by David Roundy
19:10:48 <wli> What's Meep?
19:10:50 <oerjan> there is @let for adding value declarations
19:11:19 <gwern> @where meep
19:11:19 <lambdabot> http://ab-initio.mit.edu/meep/
19:11:41 <kmcallister> @let x = x + 1
19:11:42 <lambdabot> Defined.
19:11:45 <kmcallister> > x
19:11:45 <lambdabot> Terminated
19:13:49 <oerjan> not <<LOOP>>?
19:13:58 <oerjan> oh right
19:14:12 <oerjan> x is taken by the Expr stuff
19:14:17 <oerjan> @undef
19:14:18 <lambdabot> Undefined.
19:14:23 <oerjan> > x :: Expr
19:14:24 <lambdabot>  x
19:14:43 <oerjan> every single letter variable name i think
19:15:03 <sclv> > a >>= f
19:15:04 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
19:15:07 <sclv> ?unlet
19:15:08 <lambdabot> Defined.
19:15:12 <sclv> ?undefine
19:15:13 <lambdabot> Undefined.
19:15:18 <sclv> > a >>= f
19:15:18 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
19:15:30 <sclv> we need monadic Exprs.
19:15:43 <faxathisia> > [a] >>= f
19:15:43 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [b])
19:15:47 <faxathisia> :[
19:16:00 <oerjan> > (a >>=)
19:16:00 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
19:16:02 <sclv> > sequence [a,b]
19:16:03 <lambdabot>  Couldn't match expected type `m a' against inferred type `Expr'
19:16:45 <oerjan> > [a] >>= return . f
19:16:46 <lambdabot>  Add a type signature
19:16:51 <oerjan> > [a] >>= return . f :: Expr
19:16:52 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
19:16:59 <oerjan> > [a] >>= return . f :: [Expr]
19:17:00 <lambdabot>  [f a]
19:17:38 <sclv> > sequence [(+a),(+b)] $ 1
19:17:39 <lambdabot>  [1 + a,1 + b]
19:18:26 <sclv> > sequence [f,g] $ 1 :: [Expr]
19:18:27 <lambdabot>  [f 1,g 1]
19:22:25 <Cale> I really like this idea that functions and values are quite often secretly monadic computations.
19:23:12 <gwern> this popen haskell package is amusing. about 4/5 of the files are just to get it to work with autotools, and the actual popen stuff? one POpen.hs
19:24:09 <gwern> (and it does nothing particularly exotic, just some stuff with the base libraries)
19:24:33 <gwern> sort of reinforces the case for Cabal - one cabal file which is filled also with nice metadata, and a more or less redundant Setup.hs
19:24:43 <sclv> >  ((f::(Show a, Show b)=>a->b->Expr) a >>= (g:: (Show a, Show b) => a -> b -> Expr) $ 1) :: Expr
19:24:43 <lambdabot>  g (f a 1) 1
19:25:14 <sclv> I wonder if there's any way to improve
19:25:19 <sclv> Expr to reduce the pain of this.
19:25:27 <dolio> Cale: I've defined select before, but I think I made a MonadSelect for it or something.
19:25:49 <dolio> Cale: Because its analogue in Random can be useful, too, for selecting an arbitrary element.
19:27:00 <sclv> > Just a >>= f -- And more monad instances
19:27:00 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Maybe b))
19:27:09 <Cale> dolio: ah, yeah.
19:27:22 <dolio> Not sure if there are others it's useful for.
19:28:04 <Cale> So, you used a typeclass?
19:28:15 <dolio> I think I was making permutations, and [] vs Random is the difference between all permutations and a random permutation.
19:28:17 <dolio> Yeah.
19:28:20 <faxathisia> I used it for unification to choose arbitrary equations to tryp to rewrite
19:28:21 <Cale> (I can't quite see how it would be defined generically, yeah.)
19:28:32 <Cale> ah, yeah, that's true.
19:28:34 <sclv> btw, cale, did you end up getting my patch to @pl ?
19:28:54 <Cale> sclv: I, uh, I don't think so? Where'd you send it?
19:29:30 <sclv> I darcs sent it, which ended up sending it to dons. Figure he might have been too busy to forward it.
19:29:39 <Cale> ah
19:29:46 <Cale> Yeah, I haven't got it.
19:30:02 <Cale> He might have just applied it to the repository though, I don't know. I could check.
19:30:43 <sclv> It fixes a few parser irritations. I don't want to go mucking about with the actual reductions that take place without more discussion...
19:32:23 <gwern> @hoogle fdClose
19:32:23 <lambdabot> No matches found
19:32:49 <gwern> oh dear.
19:33:12 <Cale> Hmm, /etc/hosts doesn't seem to handle entries which map domain names to other domain names. That's slightly inconvenient.
19:34:13 <cjb> Cale: it's not a nameserver :)
19:34:15 <allbery_b> /etc/hosts is hosts.  not domains, not MX records, etc.
19:34:43 <Cale> Why shouldn't it be? :)
19:35:29 <Cale> Heh, why not just make it a term-rewriting system? :)
19:35:32 <allbery_b> because the resolver is big and ugly and slow (note how most unixlikes are sprouting nscds?) enough as it is?
19:36:21 <sclv> hmm... ok, I think I redirected it to send to you. you may want to fix the repo to set yourself as maintainer in the future.
19:36:26 <gwern> @hoogle forkProcess
19:36:26 <lambdabot> No matches found
19:36:40 <gwern> @hoogle fork
19:36:40 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
19:36:40 <lambdabot> GHC.Conc.forkOnIO :: Int -> IO () -> IO ThreadId
19:36:40 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
19:36:42 <vininim> does ghc optimizes useless boxing/unboxing?
19:36:58 <wagle_home> latest version of macos turned hosts back into a flat file..  8/
19:36:58 <vininim> I say boxing, but the term is probably not correct
19:38:20 <gwern> @hoogle executeFile
19:38:20 <lambdabot> No matches found
19:39:21 <gwern> @hoogle FilePath -> Bool
19:39:21 <lambdabot> Distribution.Simple.Utils.matchesDescFile :: FilePath -> Bool
19:39:21 <lambdabot> System.FilePath.Windows.hasExtension :: FilePath -> Bool
19:39:21 <lambdabot> System.FilePath.Windows.hasDrive :: FilePath -> Bool
19:40:15 <gwern> @hoogle FilePath -> Bool -> [String] -> Maybe [(String, String)]
19:40:15 <lambdabot> No matches, try a more general search
19:40:21 <gwern> @hoogle FilePath -> Bool -> [String]
19:40:21 <lambdabot> No matches, try a more general search
19:40:41 <AshyIsMe> @help hoogle
19:40:41 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
19:40:45 <AshyIsMe> nice
19:40:49 <oerjan> @hoogle runInteractiveProcess
19:40:50 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
19:41:07 <gwern> ah, it's in Posix.Process
19:41:54 <gwern> it was named executeFile too. bad hoogle!
19:42:00 <gwern> hoogle--
19:42:32 <wagle_home> @karma hoogle
19:42:32 <lambdabot> hoogle has a karma of 3
19:45:07 <hpaste>  seydar pasted "n-queens" at http://hpaste.org/5676
19:45:57 <faxathisia> yikes..
19:46:12 <Cale> sclv: applied.
19:46:14 <faxathisia> seydar, What's going on here?
19:46:21 <sclv> awesomes!
19:49:52 <Cale> You can test out your new patch :)
19:50:31 <sclv> ?pl \x ->  M.lookup <$> f x
19:50:36 <lambdabot> (line 1, column 17):
19:50:40 <lambdabot> unexpected "$" or "<"
19:50:42 <lambdabot> expecting variable, "(", ".", space, operator or end of input
19:50:44 <lambdabot> ambiguous use of a left associative operator
19:50:44 <sclv> ?pl \x ->  M.lookup x
19:50:46 <lambdabot> (M .) . lookup
19:51:12 <sclv> ?pl \x -> f <$> x . g
19:51:12 <lambdabot> (line 1, column 15):
19:51:12 <lambdabot> unexpected "."
19:51:12 <lambdabot> expecting variable, "(", "!!", space, operator or end of input
19:51:12 <lambdabot> ambiguous use of a right associative operator
19:51:22 <sclv> looks like its not loaded. :-(
19:51:29 <oerjan> this is not going too well :D
19:52:18 <sclv> (its supposed to fix three things. A) handling () properly instead of disregarding it as empty parens. B) handling module-qualified functions. C) providing fixities for applicative and arrow operators)
19:52:26 <sclv> ?pl \x -> f () x
19:52:26 <lambdabot> f
19:53:44 <gwern> :t fromMaybe
19:53:45 <lambdabot> forall a. a -> Maybe a -> a
19:58:40 <NoGoodNik> Is Hugs still the recommended implementation for newbies on Windows? Sep 06 seems kinda old ...
20:00:13 <sclv> ghc is sorta recommended for everything at this point. :-)
20:00:50 <ddarius> sclv: You're fixing @pl?
20:01:05 <dons> ghc is sorta recommended for everyone, everywhere.
20:01:09 <sclv> ddarius: I fixed the parser to do the three things I just described because they were driving me nuts.
20:01:10 <NoGoodNik> sclv: thanks
20:02:17 <sclv> I sort of have a sense of how I might add more rules, which is a pretty elegant system. But changing pl's behavior seems like it might generate some controversy, so I'm a bit more trepedatious.
20:02:47 <sclv> but if you have any requests, I'd be glad to take a look!
20:03:44 <NoGoodNik> might be nice to update http://haskell.org/haskellwiki/Haskell_in_5_steps to not direct people toward Hugs then
20:06:03 <ddarius> sclv: You might want to look at David Turner's old work on compiling functional languages to combinators.
20:07:53 <Mr_Awesome> how can i use the Either type as a monad? do i have to make a newtype or something?
20:07:57 <sclv> Thanks for the tip. I don't know if I'm down for a rewrite though, as opposed to some tweaks. :-)
20:08:18 <wagle_home> @hoogle Monad Either
20:08:19 <ddarius> sclv: I'm suggesting just adding some new combinators to the basis.
20:08:23 <lambdabot> No matches, try a more general search
20:08:26 <LoganCapaldo> (Error t) => Either t is the monad
20:08:29 <LoganCapaldo> IIRC
20:08:34 <LoganCapaldo> @src Error
20:08:34 <lambdabot> class Error a where
20:08:34 <lambdabot>     noMsg  :: a
20:08:34 <lambdabot>     strMsg :: String -> a
20:08:35 <ddarius> > Left 3 >>= Right
20:08:38 <lambdabot>  Add a type signature
20:08:44 <ddarius> > Left 3 >>= Right :: Either Int Int
20:08:45 <lambdabot>   add an instance declaration for (Error Int)
20:08:45 <lambdabot>     In the expression: Left 3 >...
20:08:53 <ddarius> > Left "foo" >>= Right :: Either String Int
20:08:55 <LoganCapaldo> Either String is an example
20:08:55 <lambdabot>  Left "foo"
20:09:05 <ddarius> Stupid Error constraint.
20:13:20 <Mr_Awesome> ah, thanks
20:13:21 <dobblego> Either a is the monad
20:13:25 <dobblego> ?instances Monad
20:13:30 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:13:33 <ddarius> :k Either a
20:13:36 <lambdabot> Not in scope: type variable `a'
20:13:42 <ddarius> :k Either String
20:13:42 <lambdabot> * -> *
20:15:43 <adu> shachaf: are you here?
20:16:36 <wagle_home> :k forall a. Either a
20:16:37 <lambdabot>     `Either a' is not applied to enough type arguments
20:16:37 <lambdabot>     Expected kind `*', but `Either a' has kind `* -> *'
20:19:25 <hpaste>  vininim pasted "Random algorithm for Comb. Opt." at http://hpaste.org/5677
20:20:26 <Pseudonym> Phew.
20:20:45 <Pseudonym> Well, I got Lee Naish to realise that "forall" in Mercury's type system isn't a real "forall", but it is in Haskell.
20:20:51 <Pseudonym> So I claim a minor victory there.
20:20:59 <cjb> I love messing with the proletariat.
20:21:23 <faxathisia> What is the forall in Mercury?
20:21:43 <Pseudonym> faxathisia: Well, Mercury has a Hindley-Milner-like type system, like Haskell.
20:22:06 <wli> Typeclasses/constructor classes and all.
20:22:12 <Pseudonym> And like Haskell with -fglasgow-exts, it has "forall".
20:22:17 <Pseudonym> Except that Mercury calls it "all".
20:22:45 <LoganCapaldo> does mecury have exists?
20:22:49 <Pseudonym> Yes.
20:22:51 <Pseudonym> Which it calls "some".
20:23:09 <Pseudonym> Mercury, being a logic language, uses "all" and "some" for both types and program.
20:23:26 <Pseudonym> However.
20:23:46 <vininim> I want to try mercury sometime
20:23:54 <Pseudonym> In Haskell without seq, "forall a. something_involving a" really means that it works for any type a.
20:23:59 <vininim> (and scala, and perl...)
20:24:01 <Pseudonym> And hence it can't assume anything about what a can do.
20:24:11 <LoganCapaldo> Funny, I want to try mercury sometimes.
20:24:18 <Pseudonym> In Mercury, you can always unify.
20:24:33 <Pseudonym> So that's why Mercury doesn't have free theorems and Haskell does.
20:24:56 <faxathisia> I still don't see why all isn't a proper forall?
20:25:04 <Pseudonym> faxathisia:
20:25:07 <Pseudonym> Consider the function:
20:25:14 <Pseudonym> f :: forall a. (a,a) -> a
20:25:21 <Pseudonym> What does f do?
20:25:25 * wli just missed something; unification always possible? "Free theorems" not possible? wtf?
20:25:34 <faxathisia> It's either fst or snd..
20:25:39 <vininim> ^
20:25:49 <Pseudonym> faxathisia: In the absence of bottom or seq, yes.
20:26:01 <ShockSMX> what tutorial would you guys recommend i start with
20:26:06 <Pseudonym> In Mercury, it could be fst, it could be snd, or it could unify the two things and then return that.
20:26:11 <ShockSMX> i'm a newb, but i have rudimentary experience with SMLofNJ
20:26:38 <Pseudonym> Which might cause it to fail, if the unification doesn't succeed.
20:26:50 <Pseudonym> So all type variables are implicitly members of a "Unifiable" typeclass.
20:27:05 <Pseudonym> In fact, the situation in Mercury is worse, because you can Ord anything, too.
20:27:20 <faxathisia> oh I see what you mean
20:27:25 <Pseudonym> And if you pass in a predicate (i.e. higher order), that's a run-time error.
20:27:30 <bos> @seen dons
20:27:30 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 26m 25s ago.
20:27:34 <Pseudonym> Or a compile-time error if the compiler can catch it.
20:28:07 <Pseudonym> My opinion, and I think Lee sees it now, is that "forall" should default to a true "forall".
20:28:30 <Pseudonym> And if you need an efficiency hack, like seq, you agree to wear it.
20:28:40 <Pseudonym> But a pseudo-forall should not be your starting point.
20:28:51 <faxathisia> yeah
20:29:02 <Pseudonym> Now, of course, at the implementation level, you're going to pass in a type dictionary.
20:29:16 <Pseudonym> Because one thing you need to do to every type is garbage collect it.
20:29:23 <Pseudonym> Even if you don't have seq.
20:29:37 <Pseudonym> But that's an implementation detail./
20:30:19 <wagle_home> is there a type that contains elements that cant be unified?
20:30:41 <Pseudonym> wagle: Yes.  Higher-order types.
20:31:16 <Pseudonym> Also, you shouldn't be able to unify the Mercury equivalent of RealWorld.
20:31:23 <Pseudonym> Though I think you can.
20:31:35 <wagle_home> ... but they populate all a. (a,a) -> a ?
20:31:52 <Pseudonym> Yeah.
20:32:04 <Pseudonym> > fst (id,(+1)) 3
20:32:08 <Pseudonym> > snd (id,(+1)) 3
20:32:19 <lambdabot>  thread killed
20:32:23 <lambdabot>  thread killed
20:32:32 <Pseudonym> Well, you can do it yourself.
20:33:08 * gwern uploads popen. well, at least I got one thing done tonight
20:33:09 <wagle_home> :t fst (id,(+1))
20:33:09 <lambdabot> forall a. a -> a
20:33:28 <wagle_home> :t snd (id,(+1))
20:33:29 <lambdabot> forall a. (Num a) => a -> a
20:33:59 <gwern> @hoogle mkRegex
20:33:59 <lambdabot> No matches found
20:34:05 <gwern> bullshit
20:34:29 <wagle_home> not sure i see why lambdabot is looping on those?
20:34:40 <Pseudonym> Probably the same reason why hoggle didn't work.
20:34:41 <faxathisia> :t (undefined :: (a,a) -> a) (id,(+1))
20:34:42 <lambdabot> forall a. (Num a) => a -> a
20:34:50 <Pseudonym> > fst (id,(+1)) 3
20:34:51 <lambdabot>  3
20:34:55 <Pseudonym> > snd (id,(+1)) 3
20:34:55 <lambdabot>  4
20:34:58 <Pseudonym> Yup, timing glitch.
20:35:54 <wagle_home> poor brain cells..  wasted on a non-problem
20:36:47 <ShockSMX> anyone have any advice for me?
20:36:53 <ShockSMX> where should i start?
20:37:06 <vininim> wikibooks has a tutorial
20:37:17 <vininim> www.haskell.org has lots of goodies too
20:37:17 <gwern> @hoogle IORef
20:37:18 <lambdabot> Data.IORef :: module
20:37:18 <lambdabot> Data.IORef.IORef :: data IORef a
20:37:18 <lambdabot> Data.IORef.newIORef :: a -> IO (IORef a)
20:37:18 <jeffz> ShockSMX: http://haskell.org is a good place to start
20:37:18 <lambdabot> Title: Haskell Community Server
20:37:28 <gwern> @hoogle unsafePerformIO
20:37:28 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
20:37:28 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
20:38:04 <ShockSMX> it's a lot to take in at once
20:38:09 <ShockSMX> but, yeah, i'm there
20:40:03 <Cale> ShockSMX: YAHT and the Wikibook are two good tutorials to start with. Get yourself a copy of GHC.
20:40:08 <Cale> @where yaht
20:40:08 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
20:40:11 <Cale> @where wikibook
20:40:11 <lambdabot> http://en.wikibooks.org/wiki/Haskell
20:40:14 <Cale> @where ghc
20:40:14 <lambdabot> http://haskell.org/ghc
20:40:50 <ShockSMX> Cale: got ghc, i'll look at YAHT
20:41:04 <Cale> ShockSMX: If you have any questions about the language or need help with an error or anything, just ask :)
20:41:12 <ShockSMX> will do. thanks, buddy
20:41:47 <ShockSMX> i have some homework coming up where i have to write a lambda calculus interpreter, i might use haskell for it. i'm sure i'll run into some snags.
20:42:05 <Cale> That sounds like a plan :)
20:42:40 <ShockSMX> damn, you're at the center of this little social network
20:42:50 <Cale> :)
20:43:01 <ShockSMX> you'll probably be the one answering my questions, then, heh heh
20:43:04 <gwern> ShockSMX: no, Cale's just the one awake and idle right now
20:43:12 <Cale> If you're rather familiar with SML already, you might find the "Gentle" intro okay. It's normally not considered all that gentle really, but if you're already familiar with functional programming, it's a quick way to take in a lot of the syntax and such.
20:43:33 <Cale> @where tutorial
20:43:33 <lambdabot> http://www.haskell.org/tutorial/
20:43:35 <ShockSMX> i've read a bunch of the gentle intro
20:43:57 <ShockSMX> i started getting confused around "Types, Again"
20:44:08 <gwern> with haskell, reading isn't very useful, gotta do the exercises
20:44:15 <ShockSMX> and gave up by the time i started looking at Monads
20:44:27 <ShockSMX> gwern: where are some excersizes i could run through
20:44:28 <Cale> Oh, for monads, none of these tutorials are particularly good.
20:44:41 <Cale> I can point you at a few things once you get there.
20:44:47 <gwern> ShockSMX: between yaht and the wikibook, should be plenty to do
20:44:49 <dobblego> Cale, didn't you write one? :)
20:44:58 <ShockSMX> Monads seem somewhat foreign to me. i haven't found any statement to the effect of, "oh, well, monads in haskell are like X in language Y"
20:44:58 <ddarius> three
20:45:01 <Cale> dobblego: two actually, and a half.
20:45:02 <gwern> rewriting shell scripts and Unix tools is good too as exercise
20:45:10 <dobblego> Cale, just checking; I admire honesty :)
20:45:11 <ShockSMX> gwern: cool
20:45:26 <gwern> @remember dobblego> Cale, didn't you write one? :) \n Cale> dobblego: two actually, and a half.
20:45:27 <lambdabot> Done.
20:45:33 <gwern> @quote dobblego
20:45:33 <lambdabot> dobblego> says: Cale, didn't you write one? :) \n Cale> dobblego: two actually, and a half.
20:45:35 <gwern> @quote dobblego
20:45:35 <lambdabot> dobblego> says: Cale, didn't you write one? :) \n Cale> dobblego: two actually, and a half.
20:45:35 * ddarius wouldn't admit to writing a monad tutorial even if he had written one.
20:45:38 <wli> Writing perl interpreters in Haskell?
20:45:38 <gwern> @quote Cale
20:45:38 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
20:45:38 <lambdabot> object in the category of religions and theomorphisms.
20:45:45 <Cale> dobblego: I wrote them for very specific reasons, and I don't regret it :)
20:45:46 <nornagon> ShockSMX: let X = monads, Y = haskell ;-)
20:45:55 <gwern> @quote Cale
20:45:56 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal
20:45:56 <lambdabot> object in the category of religions and theomorphisms.
20:47:11 <Cale> @quote should maintain a random permutation of the quotes for each user, which, once consumed, should be replaced with another random permutation. That would cut down on the repeats :)
20:47:12 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
20:47:18 <Cale> heh
20:47:19 <ShockSMX> nornagon: nooooo
20:47:46 <gwern> Cale: that sounds like STATE OH NOES
20:47:51 <ddarius> X = monads, Y = C#
20:48:05 <ShockSMX> ddarius: really?
20:48:14 <ShockSMX> ddarius: in what form?
20:48:23 <dobblego> ShockSMX, Java has monads
20:48:40 <dobblego> ShockSMX, in this form: ;
20:48:43 <nornagon> dobblego: monads are pretty easy to implement in most languages
20:48:58 <ddarius> ShockSMX: Monads have been implemented in many languages.
20:49:00 <Cale> Monads are pretty hard to implement well in most languages.
20:49:02 <dobblego> nornagon, monads are pretty hard not to implement in most languages
20:49:14 <nornagon> dobblego: also, ; doesn't count as a monad; it doesn't have return :)
20:49:22 <wagle_home> its the do notation thats haskell's hidden secret..  8)
20:49:30 <Cale> You're not really using the monad abstraction unless you can write code which works in *any* monad.
20:49:40 <Cale> Using specific monads doesn't count.
20:49:40 <dobblego> nornagon, true, there are other monads :)
20:49:41 <vininim> talking about do notation, I sell out to it
20:49:43 <ddarius> wagle_home: There would be little difference syntactically without do notation.
20:49:43 * faxathisia has seen do notation in another language
20:49:47 <vininim> *sold
20:49:50 <dobblego> Cale, agreed
20:50:04 <faxathisia> (although they were modelling haskell..)
20:50:14 <Cale> ShockSMX: You're an SML user?
20:50:24 <dobblego> ShockSMX, there is a document titled "you could have invented monads" - the title is telling
20:50:30 <wagle_home> Cale doesnt use the state monad?
20:50:46 <Cale> wagle_home: wha?
20:50:53 <ShockSMX> Cale: yeah, but not hardcore
20:50:54 <LoganCapaldo> Cale manually threads his state. In the type system.
20:51:00 <ShockSMX> Cale: but, yeah, i've done some stuff in it
20:51:28 <Cale> ShockSMX: Have you run into any combinator libraries?
20:51:30 <wagle_home> write some code that reads and writes state to a state monads, and through the id monad at it
20:51:35 <wagle_home> throw
20:51:55 <ShockSMX> Cale: no
20:52:51 <Cale> Okay, basically a combinator library is a library whose API is rich enough that using it is like using a miniature programming language embedded in the one you're using. It defines some primitive computations and then ways to combine those into larger ones.
20:53:11 <ShockSMX> okay
20:53:25 <Cale> A monad is basically a specific sort of combinator library, one which supports a particular means of combination which is relatively common.
20:54:15 <ShockSMX> alright. i'm sure it'll make sense once i run into some uses for them
20:54:18 <Cale> We abstract over monads simply so that various monadic libraries can share code for things like general control structures.
20:54:53 <Mr_Awesome> where is Either a declared as a Monad?
20:55:03 <Cale> Mr_Awesome: Control.Monad.Error
20:55:12 <Cale> Mr_Awesome: and the instance sucks
20:55:27 <Mr_Awesome> it sucks?
20:55:57 <Cale> Yeah, it's (Error e) => Monad (Either e)
20:56:06 <Cale> Rather than  Monad (Either e)
20:56:33 <Cale> So you have to write an instance of Error for every e you want to use.
20:56:45 <LoganCapaldo> which bites
20:56:46 <Cale> (which is completely unnecessary)
20:57:10 <Cale> I usually just end up writing:
20:57:16 <Cale> instance Monad (Either e) where
20:57:26 <Cale>   Left e >>= f = Left e
20:57:31 <Cale>   Right x >>= f = f x
20:57:42 <Cale>   return = Right
20:58:48 <Cale> Which is really an instance that should be in the Prelude, along with the monad instances for (->) e and a few other things.
21:00:00 <wagle_home> > Left "x" >>= ('1':)
21:00:16 <lambdabot>  thread killed
21:00:26 <wagle_home> poor lambdabot
21:00:33 <wagle_home> @botsnack
21:00:33 <lambdabot> :)
21:00:45 <Cale> code.haskell.org has been choking all evening
21:00:57 <wagle_home> > Left "x" >>= return ('1':)
21:00:57 <lambdabot>  Couldn't match expected type `Either [Char] b'
21:01:18 <wagle_home> > Left "x" >>= Left . ('1':)
21:01:20 <lambdabot>  Left "x"
21:01:40 <ShockSMX> can anyone give him botsnacks?
21:02:04 <wagle_home> > Right "x" >>= Left . ('1':)
21:02:05 <lambdabot>  Left "1x"
21:02:16 <AshyIsMe> @botsnack
21:02:16 <lambdabot> :)
21:02:29 <AshyIsMe> ShockSMX, looks like it
21:02:35 <ShockSMX> he's pretty adorable, for a bot.
21:02:40 <Pseudonym> She.
21:02:40 <wagle_home> she
21:02:42 <dobblego> she
21:02:49 <ShockSMX> oh, that explains it
21:02:53 <AshyIsMe> lambda-doo where are you?!
21:03:00 <lambdabot> What's that supposed to mean?
21:03:14 <ShockSMX> @botsnack
21:03:15 <AshyIsMe> oh right, you aren't scooby
21:03:16 <lambdabot> :)
21:03:59 <wagle_home> take a look:
21:04:02 <wagle_home> @where lambdabot
21:04:02 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
21:07:26 <ShockSMX> cool]
21:09:08 <ShockSMX> wow, ocaml often outperforms c++?
21:09:14 <ShockSMX> that's pretty neat
21:09:16 <Cale> yeah
21:10:08 <shapr> Hey, I outperform C++ too.
21:10:21 * shapr quickly solves the halting problem by going to sleep.
21:11:12 * wli has seen systems of illegible chicken scratch writing that outperform C++.
21:11:23 <faxathisia> :D
21:11:24 <faxathisia> lol
21:12:13 * wagle_home installs illegible chicken scratch writing
21:12:15 <cjb> ShockSMX: and fortran often outperforms C.
21:12:20 <BMeph> wli: I think of C++ as C's response to Icon. ;p
21:12:33 <ShockSMX> cjb: well, that's not hard to picture
21:12:35 <Cale> BMeph: really?
21:12:46 <Cale> BMeph: Are you thinking of the same Icon that I'm thinking of?
21:12:57 <cjb> I think it's for similar reasons to ocaml.  Imperative languages are faster when they don't have data aliasing.
21:13:12 <cjb> s/are faster/can be made faster by optimizing compilers/
21:13:15 <BMeph> Well, considering that I was a student when the Griswolds invented it, I'm biased that way. ;)
21:13:27 <LoganCapaldo> I think of SNOBOL as Karma's response to the brain.
21:13:37 <LoganCapaldo> s/brain/Brain/
21:13:57 <Mr_Awesome> if i want to have two different types that are actually identical but semantically distinct, would i use the newtype keyword?
21:14:07 <BMeph> Cale: If you're thinging Uni of AZ 1989, then yes, THAT Icon.
21:14:20 <wli> Mr_Awesome: type may also do.
21:14:23 <shapr> Yeah, type
21:14:35 <Cale> http://www.cs.arizona.edu/icon/ -- this one :)
21:14:36 <lambdabot> Title: The Icon Programming Language
21:14:48 <faxathisia> Icon is good for text processing?
21:15:05 <Mr_Awesome> but wont that let something of one type be used where the other type is expected? i want to forbid that
21:15:26 <Cale> Mr_Awesome: newtype
21:15:47 <Cale> Mr_Awesome: (you're right)
21:15:48 <ShockSMX> cjb: what do you mean by data aliasing
21:15:59 <Mr_Awesome> Cale: okay, thanks
21:16:20 <Pseudonym> http://web.cecs.pdx.edu/~cklin/papers/unimo-143.pdf
21:16:22 <Pseudonym> There you go.
21:16:26 <Pseudonym> Go read that, shapr.
21:17:05 <cjb> ShockSMX: pointeres
21:17:07 <cjb> pointers.
21:17:57 <wli> More specifically, the possibility that pointers may refer to overlapping/intersecting regions of memory.
21:18:15 <ShockSMX> cjb: oh, ok
21:18:34 <ShockSMX> cjb: yeah, direct memory access is... tough to optimize
21:18:43 <Nafai> I know this is a Java question, but does anyone know of a QuickCheck like library for Java?
21:19:43 <Cale> http://wiki.java.net/bin/view/Projects/QuickCheck
21:19:44 <lambdabot> Title: TWiki . Projects . QuickCheck
21:20:12 <Cale> I have no idea if that's any good or what, I just googled :)
21:20:36 <Nafai> I didn't do quickcheck one word and that's why it didn't show up for me :)
21:21:22 <Cale> ... man there's a lot of code there.
21:21:59 <sw17ch> has any one used the Cairo bindings in Gtk2Hs?
21:22:03 <Cale> I have.
21:22:14 <sw17ch> positive experience?
21:22:17 <Cale> (Quite a while ago now)
21:22:24 <Cale> Yeah, they work quite well.
21:22:28 <sw17ch> excellent
21:22:35 * sw17ch needs text rendering and shapes
21:22:53 <Cale> I was just using Cairo to render fractals.
21:23:03 <sw17ch> oh nice
21:23:10 <sarehu> wait, what is Cairo for?
21:23:22 <sw17ch> Vector 2D graphic library, right?
21:23:24 <cjb> sarehu: vector graphics
21:23:25 <Cale> right
21:23:30 <sarehu> ah
21:23:44 <cjb> xerox wrote those bindings, I think
21:23:45 <sw17ch> from what i've seen, looks really nice
21:23:51 <sw17ch> oh, cool
21:24:22 <conal> has anyone here installed Gtk2Hs on windows+cygwin?  i didn't manage to get glib2, which i guess is a prereq.
21:24:24 <sarehu> hm I just need pixels
21:24:51 <dcoutts_> conal: there's a binary installer for ghc-6.8.1
21:24:53 <cjb> I think QuickCheck doesn't translate well to other languages.  I'd really like to use it on python, but I don't see how it's gonna generate random test data for me with such a weakly-typed language.
21:25:04 <Cale> cjb: right
21:25:05 <conal> dcoutts_: yeah, sigh.  i use a newer ghc
21:25:16 <dcoutts_> conal: it's on my TODO list
21:25:33 <conal> dcoutts_: would the binary installer install prereqs like glib2?
21:26:02 <Cale> cjb: It's a great example of the power of type-directed programming.
21:26:05 <dcoutts_> conal: yes, but if you want to build from source the bits you need are at http://haskell.org/gtk2hs/win32/
21:26:47 <cjb> man, if quitting my job and hacking on python for six months would get optional static typing into python, it'd be worth it.  but I don't think there's enough of a consensus in the python community (and I'm probably not smart enough).
21:26:54 <conal> dcoutts_: oh!  great.  how do i know which version to use?
21:27:01 <dcoutts_> conal: the gtk+-dev is the flavour that has all the headers etc necessary to build gtk2hs from source, use the later one.
21:27:13 <conal> dcoutts_: will do!
21:27:19 <conal> i prefer building from sources
21:27:31 <cjb> I really like python.  Except the part where it hurts me by pretending that it doesn't know anything about types.
21:27:46 <dcoutts_> conal: there are scripts I use to build the installer in http://darcs.haskell.org/gtk2hs/tools/win32/
21:27:47 <lambdabot> Title: Index of /gtk2hs/tools/win32
21:28:19 <ShockSMX> wow, yaht gives no respect to NHC
21:28:27 <ShockSMX> section 2.3 is just a slap in the face
21:28:34 <dcoutts_> conal: the win32-build.* scripts
21:28:46 <Cale> ShockSMX: heh, I don't remember that, what does it say?
21:28:50 <conal> dcoutts_: neat
21:29:26 <jeffz> my copy of yaht, the nhc section is incomplete
21:29:27 <ShockSMX> Cale: nothing. it's just a bunch of section headings, no text at all, and then it moves on.
21:29:32 <Cale> ah
21:29:42 <jeffz> ShockSMX: parts of yaht are unfinished
21:29:47 <ShockSMX> ok
21:29:48 <Cale> ShockSMX: YAHT is unfinished (and I think the author stopped working on it)
21:29:57 <ShockSMX> jeffz: i figured that'd have to be the case
21:30:09 <gwern> nhc doesn't seem to be used much; I suspect most of those who use it do so out of principle
21:30:36 <nornagon> gwern cross-posts!
21:30:50 <ShockSMX> which one does microsoft sponsor? GHC?
21:30:56 <gwern> nornagon: oh hush you. like you never mischan
21:31:27 <nornagon> wrongwindow.com
21:31:32 <Cale> It used to be used more.
21:31:38 <gwern> ShockSMX: it doesn't really sponsor any, but it does employ some major GHC programmers
21:31:58 <ShockSMX> gwern: to what end?
21:32:08 <Cale> ShockSMX: MS Research
21:32:13 <ShockSMX> F#?
21:32:17 <gwern> ShockSMX: out of principle, said principle being anti-monoply
21:32:20 <Cale> (which is altogether different from MS)
21:32:25 <ShockSMX> c-omega?
21:32:55 <Cale> ShockSMX: those are other projects, there's probably some crosstalk there, but as far as I know, Simon just works on GHC.
21:33:10 <ShockSMX> ok
21:33:17 <conal> dcoutts_: i downloaded gtk+-dev-2.10.14-win32.zip .  when i unzip, i get told that the file is password protected.
21:33:45 <gwern> 'night all
21:33:51 <cjb> gwern: making sure that there are multiple compliant Haskell compilers is a fine principle too :)
21:34:06 <Cale> I tend to think of MS Research as being somewhat like Xerox PARC in terms of its relationship to its parent company.
21:34:19 <dcoutts_> conal: hmm, that's not right. I only used ordinary unix zip. It unzips for me using the standard windows shell built-in extractor thing. Try using a different program.
21:34:36 <cjb> yeah.  and having seen many friends leave academic research departments to join MSR, I tend to think of MSR as being somewhat like an academic research dept.
21:34:46 <conal> dcoutts_: will do.
21:36:18 <conal> dcoutts_: different unzipper, same problem.
21:36:37 <dcoutts_> conal: weird, lemme double check
21:37:05 <shapr> Pseudonym: Interesting!
21:37:39 <Pseudonym> Now, your exercise (I've only skimmed the paper) is to see if Unimo is expressive enough to implement a MonadPlus.
21:37:45 <Pseudonym> Well, a nondeterminism monad, anyway.
21:38:06 <Pseudonym> On a first skimming, it didn't seem _quite_ expressive enough as-is.
21:42:15 <dcoutts_> conal: if I uploaded a .tar.gz file would that be ok?
21:42:51 <conal> dcoutts_: it would, but i've just made one myself and am about to download it.
21:43:21 <dcoutts_> conal: oh so you managed to unpack the .zip?
21:43:39 <conal> dcoutts_: yes, on a linux server.
21:44:57 <dcoutts_> conal: ok, great. I wonder what was wrong with it. It worked for me before on Win2k3 using the built-in windows zip extractor.
21:45:17 <conal> dcoutts_: odd.
21:48:50 <conal> dcoutts_: oh, grumble.  when i unzipped mine, it came out empty.  i'd appreciate it if you made me a .tar.gz
21:52:46 <dcoutts_> conal: will .tar.bz2 be ok? I've got slow ADSL and it's a >5mb upload
21:52:57 <conal> dcoutts_: bz2 is fine
21:53:22 <conal> dcoutts_: the smaller the better.  i'm on satellite with a weekly 1GB download limit
21:53:25 * wagle_home wonders if the nigerian spammers can make money from the copycats spammers in other countries for copyright infringement                 
21:53:48 <dcoutts_> conal: right. Uploading now...
21:54:23 <jeffz> wagle_home: maybe they should patent their method of writing letters with all uppercase and poor grammar
21:54:57 <wy> Has anyone looked at http://sigfpe.blogspot.com/2008/02/how-many-functions-are-there-from-to.html ? I'm a little confused at the beginning
21:54:57 <lambdabot> Title: A Neighborhood of Infinity: How many functions are there from () to ()? (Updated ..., http://tinyurl.com/2s68d2
21:55:58 <wy> Why is f1 x = x of type ()->() ? I think it's a->a
21:56:21 <conal> dcoutts_: i'm off to bed.  i'll grab the .bz2 in the morning.  thanks much.
21:56:42 <dcoutts_> conal: oh, it's just finished
21:56:50 <dcoutts_> conal: g'night
21:58:56 <wy> conal: How are you?
21:59:17 <conal> dcoutts_: i see it.  thanks again.
21:59:18 <conal> wy: happy & sleepy
21:59:39 <wy> conal: That's good :-)
22:00:41 <conal> g'night all
22:01:30 <wy> conal: good night
22:01:58 <wy> Hey, can anyone explain a little bit to me about the blog post http://sigfpe.blogspot.com/2008/02/how-many-functions-are-there-from-to.html?
22:01:59 <lambdabot> Title: A Neighborhood of Infinity: How many functions are there from () to ()? (Updated ..., http://tinyurl.com/32e4w4
22:02:39 <faxathisia> wy, did you understand theAbstract Stone Duality?
22:02:54 <wy> faxathisia: No. I just found the link
22:03:22 <faxathisia> wy, well it didn't make any sense to me :S.. I wonder if this post assumes understanding of that?
22:04:04 <wy> faxathisia: I don't think so. You can skip the first paragraph
22:04:26 <wagle_home> aww..  darn..  i was still trying to think of more than 4
22:05:45 <wy> I'm stuck at the beginning, since I don't think the type of f1 is ()->(), but a->a... What the heck is ()?
22:06:05 <faxathisia> () is a vale
22:06:12 <faxathisia> () is a value
22:06:15 <faxathisia> It's type is ()
22:06:25 <faxathisia> They just happen to look the same.. but it's a different thing
22:06:51 <faxathisia> I think it's read 'unit'?
22:06:58 <wagle_home> :t ()
22:07:00 <lambdabot> ()
22:07:09 <faxathisia> but anyway, The types a -> a and () -> () unify
22:07:21 <faxathisia> so any function of type a -> a can be used as a function () -> ()
22:07:33 <wagle_home> > :t id :: () -> ()
22:07:34 <lambdabot>  Parse error at "::" (column 7)
22:07:35 <wy> The title is "How many functions are there from () to ()". So () here means the type ()?
22:07:44 <faxathisia> Yes
22:07:51 <faxathisia> > ()
22:07:56 <faxathisia> > undefined :: ()
22:07:59 <wagle_home> :t id ()
22:07:59 <lambdabot> ()
22:08:06 <lambdabot>  thread killed
22:08:09 <lambdabot>  Undefined
22:08:22 <wagle_home> :t id ()
22:08:22 <lambdabot> ()
22:08:26 <wy> faxathisia: but the type of f1 x = x is still a->a and not ()->()
22:08:56 <faxathisia> > let f1 x = x in f1 ()
22:08:59 <lambdabot>  ()
22:09:17 <faxathisia> So this shows that f1 is a function which takes a () and evaluates to ()
22:09:25 <faxathisia> so it can have type () -> ()
22:10:26 <bos> @seen dons
22:10:26 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 14m 5s ago.
22:11:04 <wy> I still don't see how this is relevant to the topic
22:11:12 <wy> of the post
22:11:41 <faxathisia> wy, I was just trying to explain why f1 is a function from () to ()
22:11:42 <dolio> faxathisia: Is there a way to get Agda2 to not barf on stuff like ? Or are all those pretty unicode characters only for their examples, and not for real use?
22:12:21 <faxathisia> dolio, I just did a search and replace  for ->, I think it's just a bad wiki formatter, not certain though
22:12:25 <wy> faxathisia: you can also say it's a function of Int->Int
22:13:07 <dolio> faxathisia: Ah, okay.
22:13:13 <wy> I don't think you can say it has type ()->(). It has type forall a. a->a
22:13:26 <wy> That's quite different
22:13:30 <faxathisia> wy: look
22:13:34 <faxathisia> f1 :: () -> ()
22:13:37 <faxathisia> f1 x = x
22:13:46 <faxathisia> that's valid haskell
22:14:22 <wy> faxathisia: But now you have a f1 of type ()->(). That's different
22:14:42 <wy> Not you can't use f1 2
22:14:50 <wy> now
22:14:52 <faxathisia> f1 2 is irrelevant
22:15:01 <wy> But formerly I can use it
22:15:10 <faxathisia> If we ignore the type annotation,
22:15:28 <faxathisia> The question is, does f1 x = x fit in the class of functions from () -> ()
22:18:57 <dcoutts_> @seen gwern
22:18:57 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 45m 12s ago.
22:20:20 <dcoutts_> gwern: ping
22:22:49 <wy> ... ok... then why is f3 of type ()->()?
22:23:11 <faxathisia> :t undefined
22:23:26 <faxathisia> forall a. a
22:23:26 <lambdabot> thread killed
22:23:27 <faxathisia> :t let loop = loop in loop
22:23:28 <lambdabot> forall t. t
22:23:51 <faxathisia> :t let loop = loop in loop :: ()
22:23:52 <lambdabot> ()
22:24:42 <wagle_home> > let loop = loop in loop :: ()
22:24:44 <lambdabot>  Exception: <<loop>>
22:25:12 <faxathisia> yeah.. every type in haskell is inhabited
22:25:17 <wagle_home> mmm..  is exception different than infinite-loop?
22:25:37 <faxathisia> because something of type forall a. a exists
22:25:41 <wagle_home> oh..  by bottom?
22:25:52 <faxathisia> (because you can have a y combinator/fix)
22:26:44 <wagle_home> > let loop = loop in loop :: forall a b. (a -> b) -> a
22:26:44 <lambdabot>  Parse error at "." (column 38)
22:27:15 <wagle_home> > let loop = loop in loop :: (a -> b) -> a
22:27:16 <lambdabot>  Add a type signature
22:28:41 <wy> I haven't justified loop's type yet. It's a little weird
22:28:57 <Cha1> @seen dons
22:28:58 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 32m 36s ago.
22:29:52 <faxathisia> Any term has a most general type, which every type that term could possibly have is a more specific version of that
22:30:13 <faxathisia> This is not to say that the type of a term is it's most general type
22:30:20 <faxathisia> That's just what gets inferred
22:30:46 <puika> http://lostworlds.lv/go.php?1139637493
22:30:50 <puika> http://lostworlds.lv/go.php?1139637493
22:30:56 <faxathisia> so it's perfectly fine to say that f x = x has that type
22:31:09 <faxathisia> since it typechecks, isn't that enough?
22:31:40 <faxathisia> since it typechecks with the added annotation *
22:32:50 <wy> After the annotation, f1 is not the same f1 anymore
22:34:46 --- mode: ChanServ set +o Cale
22:35:00 --- kick: puika was kicked by Cale (Cale)
22:35:07 <wy> I don't see why loop can be unified into ()...
22:35:35 --- mode: Cale set -o Cale
22:35:41 <Cale> wy: loop = loop ?
22:36:00 <faxathisia> :t let f1 x = x ; f2 _ = () ; f3 x = f3 x ; f4 _ = f4 undefined in [f1,f2,f3,f4]
22:36:02 <Cale> wy: Well, it has type  forall a. a
22:36:04 <lambdabot> [() -> ()]
22:36:11 <faxathisia> does that convince you?
22:36:52 <Cale> There are two values of type ()
22:36:59 <sclv> ?ty let loop = loop in loop
22:37:00 <lambdabot> forall t. t
22:37:04 <wagle_home> > foo + foo + foo + foo
22:37:05 <lambdabot>  -4
22:37:08 <Cale> and three definable values of () -> ()
22:37:14 <wagle_home> > foo == -1
22:37:14 <lambdabot>  False
22:37:32 <wagle_home> :t (+)
22:37:32 <lambdabot> forall a. (Num a) => a -> a -> a
22:37:41 <wagle_home> (+) type checks
22:37:59 <sclv> > foo + foo
22:38:00 <lambdabot>  2147483646
22:38:25 <wagle_home> > (foo + 1) + (foo + 1)
22:38:26 <lambdabot>  -2147483648
22:38:48 <sclv> > foo - (maxBound::Int)
22:38:56 <lambdabot>  -1073741824
22:39:51 <faxathisia> Then I give up..
22:40:58 <wagle_home> > ((foo + 1) + (foo + 1)) `div` 2
22:40:59 <lambdabot>  -1073741824
22:41:16 <sfultong> > undefined
22:41:23 <lambdabot>  Undefined
22:42:02 <sfultong> map (const True) $ repeat undefined
22:42:03 <sfultong> > map (const True) $ repeat undefined
22:42:04 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
22:44:22 <wagle_home> :t undefined
22:44:22 <lambdabot> forall a. a
22:44:58 <wagle_home> > id undefined
22:44:59 <lambdabot>  Undefined
22:45:50 <wy> Thanks. I can continue now :)
22:46:15 <Mr_Awesome> @src and
22:46:15 <lambdabot> and   =  foldr (&&) True
22:46:23 <Mr_Awesome> @src or
22:46:23 <lambdabot> or    =  foldr (||) False
22:51:17 <dons> ohloh supports haskell now, http://207.115.86.98/projects/11733?p=QuickCheck  :)
22:51:18 <lambdabot> Title: QuickCheck - Ohloh
22:52:45 <wy> Got it. quite interesting
23:00:11 <wy> Let me try to paraphrase it... You need to know your argument in order to make f4, but there is something there that you can't know. So you can't define f4
23:06:33 <nornagon> ohloh parses darcs?
23:08:58 <wagle_home> f4' x = if x  == () then loop
23:09:14 <wy> I think there is still 4 functions in a lazy language
23:10:50 <wy> wagle: How can you get () out?
23:13:10 <bos> hey dons, isn't inlinePerformIO supposed to be a no-no with code that allocates memory?
23:13:25 <RayNbow> > Product 4 `mappend` Product 6
23:13:29 <lambdabot>  Product {getProduct = 24}
23:13:46 <dcoutts_> bos: yep, there's one place we use it in bytestring which is probably dodgy
23:14:08 <bos> dcoutts_: would that be map, by any chance? :-)
23:14:43 <dcoutts_> bos: if you say so :-) I don't recall
23:15:24 <dcoutts_> bos: so the danger there is slight but possible
23:16:12 <dcoutts_> bos: you'd need different bytestrings but where ghc can figure out that they are the same length, then there's a danger of sharing the allocation.
23:17:01 <wagle_home> wy, computing () takes forever..  someone comes along and control-C's the program and the signal handler is required to supply () to the computation's continuation
23:17:28 <dcoutts_> bos: so that's why nobody has found it in practise yet, but it probably possible to concoct a test case and it should be fixed
23:18:00 * wagle_home is still waiting for someone to construct a bottom value..  >)
23:18:35 <dcoutts_> bos: on the other hand I think it'd be safe to use unsafeDupablePerformIO, that just gives the small risk of unsharing which is not a correctness problem.
23:20:09 <wy> wagle_home: but it could turn out to be a () in the end, and you pressed Ctrl-C too early
23:20:58 <wagle_home> it could turn out to be infinite loop in the end, and you pressed control-C too early
23:21:23 <wagle_home> sorry, i'm not very clear, its a weird subject
23:22:34 <wagle_home> there has never been an infinite computation..  closest i ever got was almost wrapping jiffies twice (once takes 459 days) on an old notebook
23:23:12 <wagle_home> all infinite computations end with (abnormal?) termination
23:23:56 <sclv> > let loop = loop in loop :: HeatDeath
23:23:57 <lambdabot>   Not in scope: type constructor or class `HeatDeath'
23:24:39 <wagle_home> i'm not sure what the difference is between an bottom and a computation that never returns because it invoked a exception, or a continuation, or called exit, etc etc
23:25:23 <wagle_home> the computation never returns a value, it doesnt return bottom
23:25:47 <sclv> just call isBottom and then you'll be able to tell. :-)
23:26:33 <sclv> isBottom x = if x || not x then False.
23:26:55 <wagle_home> ooo.  neat..  when the program tries to exit, scan upwards for a isBottom handler and return True
23:27:59 <wagle_home> ... otherwise, return False
23:29:02 <wagle_home> extra credit if you handle power failures and kernel panics
23:30:46 <wagle_home> <---- heretic, btw
23:36:05 <wy> we are not practical any more when we talk about those things, so don't need to discuss machines that's not ideal ;)
23:37:32 <wagle_home> allegedly, they used to argue about how many angels could dance on the head of a pin
23:38:24 <wagle_home> i wanna explain what computers do, not what the math does..  make the math fit the computer
23:38:37 <wy> If we don't believe in infinity, this problem can be solved. We can similarly define "forever" to be when the world stops to run
23:39:27 <wy> But it seems to be run forever... ;)
23:40:01 <wy> I guess it restarts sometimes
23:40:36 <wagle_home> i just dont think bottom is a value..  its something else..  a computation that doesn't return a value
23:41:33 <wy> sounds like a good idea... but what is a value?
23:42:00 <wagle_home> you can pass computations around, but not as naked bottoms
23:42:08 <Saizan> wagle_home: yeah bottom is the value of "a computation that doesn't return" in the denotational semantic
23:42:43 <wagle_home> Saizan, i think denotational semantics is wrong about that
23:43:04 <wagle_home> wrong to do that?
23:43:38 <wagle_home> does allow you to treat partial function as total functions, though..
23:43:59 <wagle_home> i gotta be careful not to throw the baby out with the bathwater, so to speak
23:44:20 <wy> wagle_home: I guess your questions really depends on what is a value, and what is a computation
23:45:03 <vincenz> @quote denotational semantics
23:45:03 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
23:45:07 <vincenz> @quote denotational
23:45:07 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
23:45:38 <Saizan> wagle_home: yeah, e.g. bottom gives a nice definition of strict functions
23:45:59 <wy> What if values are also computations?
23:46:43 <wy> If this is true, there isn't such thing as a "value". We only have computation
23:48:19 <wagle_home> have a domain of Exprressions to Computations..  make it a function of time..  0 ticks of time, everything is a computation..  one tick, half of it turns into values, and the other half remains computations, more ticks, more values..  but no matter how many ticks you give it, some computations always remain
23:48:50 <wagle_home> 3-lisp (a programming language) doesn't have values, only normal forms
23:49:16 <wy> so is lambda calculus
23:49:48 <wy> I don't think we have values
23:49:50 <wagle_home> yeah
23:50:10 <wagle_home> evaluation takes expressions (computations) to values
23:50:42 <wagle_home> normalization takes expressions to expressions
23:51:09 <wagle_home> lambda calculus and 3-lisp use normalization..  most other programming languages use evaluation
23:51:28 <wy> but maybe we don't have evaluation at all?
23:51:30 <wagle_home> i could be wrong, if the STM does something like normalization
23:52:12 <wy> Because the values from evaluation only exist in our mind
23:52:48 <wy> which is another computaton ;)
23:52:54 <wagle_home> type mismatch
23:53:18 <wy> There are no types in this world
23:55:02 <wy> I guess I should read some Wittgenstein. Good night!
