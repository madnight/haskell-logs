00:00:05 <Twey> siti: I thought you wanted a *Haskell* desktop environment :-P
00:00:25 <siti> xmonad is a wm
00:00:43 <Twey> True.
00:00:48 <sarehu> xmonad + emacs + firefox is all you ever should want :P
00:00:58 <wagle> she was trying to get a printout and it was horrifically hard to read because it wasnt anti-aliasing..  so i explained it to her so she could explain to their IT person
00:01:11 <sarehu> with the occasional feh and xmms
00:01:21 <Cin> i use emms>_>
00:01:28 <siti> what's good about emacs? (I ask this question to people that use both emacs and vim)
00:01:30 <sarehu> emms?  ~googles~
00:01:40 <siti> I just don't understand the reason for using either yet :S
00:01:54 <wagle> gosling emacs is the one true editor
00:02:00 <Cin> emacs music player. uses mplayer or other external players
00:02:01 <Cale> lambdabot: @quit
00:02:08 <sarehu> it has a tex like input mode for non-ascii characters and you can use it over IRC :P
00:02:21 <Cin> turns out it's less annoying to use than Amarok
00:02:23 <sarehu> > "hello world" -- "world"
00:02:32 <sarehu> > 2 + 3
00:02:35 <lambdabot>  "hello world"
00:02:41 <lambdabot>  5
00:02:47 <sarehu> hay, it didn't subtract
00:02:51 <Cin> because when iwant to switch between sound devices in amarok it's a pain, whereas in emms, i just use M-x emms-swap
00:03:12 <wagle> what?  gosling emacs hasnt worked since the late 1980's when NULL stopped being dereferencable?!?  bawderdash, Meyer Goldberg ported it!
00:03:28 <wagle> i got it someplace, i think
00:03:30 <Cale> whoa...
00:03:37 <sarehu> > 2
00:03:37 <lambdabot>  2
00:03:38 <Cale> > foldr f z [1..5]
00:03:39 <lambdabot>   Not in scope: `z'
00:03:42 <Cale> ...
00:03:48 <sarehu> ...?
00:04:08 <siti> > putStrLn "Is the pcap library buggy?"
00:04:11 <sarehu> > replicateM 8 "01" !! ord 'A'
00:04:12 <lambdabot>  "01000001"
00:04:13 <lambdabot>  <IO ()>
00:04:19 <siti> doesn't do IO :(
00:04:20 <siti> ?
00:04:35 <sarehu> that would be called a security flaw
00:04:36 <Cale> oh
00:04:38 <siti> oh that would have printed out wherever the bot was running from :p
00:04:58 <Cale> dons lambdabot started up again and killed mine somehow :)
00:05:10 <sarehu> aww
00:05:21 <Cin> in my scheme bot i use the mzscheme sandbox :) forwards printing to stdout to the channel
00:05:35 <Cale> that... is insane
00:05:37 <Cale> @quit
00:05:38 <sarehu> yeah, scheme can do that because it's evil
00:05:49 <sarehu> still dons
00:05:56 <wagle> actually, my experience is that emacs experts seem just as happy as vi experts..  the vi experts seem more noisy though.. dunno why
00:06:00 <Cale> @quit
00:06:01 <Cin> not really insane if you limit it to one line
00:06:18 <Cale> nope
00:06:49 <wagle> oh noes!  he  said scheme is evil!  must scrollback to find out why!
00:06:53 <sarehu> that would be a nice feature... captureOutput :: IO () -> IO ()   and it would be implementable if you wanted to reimplement IO and all the libs...
00:06:55 <siti> @botsnack
00:06:59 <siti> hmm
00:06:59 <lambdabot> :)
00:07:13 <sarehu> IO () -> IO String,    I mean...
00:07:18 <Cin> sarehu: utf8-string has done that :P
00:07:22 <siti> it's dynamically typed .......
00:07:24 <sarehu> But really, instead.. what?
00:07:33 <wagle> whats evil about redirecting stdout?
00:07:47 <Cale> sarehu: think bigger.  saveContinuation :: FileName -> IO ()
00:08:04 <sarehu> aaaggaghhh
00:08:27 <Cin> allowing file acces would be dumb, or net access
00:08:42 <wagle> yeah, if haskell were a real language, it'd have call/cc built into the interpreter
00:09:14 <wagle> instead of forcing the programmer to convert his code to cps
00:09:20 <Cale> maybe it should be  saveContinuation :: FileName -> IO Bool
00:09:33 <wagle> flame-proof suit enabled.  check
00:09:36 <sarehu> That would be neat, actually.  A typeclass   class Monad m => Stdout m where { putChar :: Char -> m () ; putStrLn :: String -> m () ; putStrLn = mapM_ putChar ; ... }
00:09:39 <Cale> hmm...
00:09:43 <sarehu> with instance Stdout IO
00:09:54 <dolio> You don't need to convert to CPS, you just need to use the right monad.
00:09:55 <sarehu> and instance Stdout (Writer String)
00:12:21 <Cale> d'oh :)
00:12:38 <Cale> dons: could you disconnect lambdabot? :)
00:12:38 <wagle> whats evil about redirecting stdout? (in the mzScheme bot)
00:13:03 <wagle> @seen dons
00:13:04 <lambdabot> dons is in #xmonad and #haskell. I don't know when dons last spoke.
00:13:13 <wagle> doh
00:13:15 <sarehu> wagle: it breaks the laws of physics
00:13:19 <Cale> dons: I have a new lambdabot set up on code.haskell.org, but I can't kill your process. :)
00:13:19 <Cin> i think he was just taking the oppourunity to say that scheme is evil
00:13:23 <Cin> :D
00:13:27 <wagle> sarehu, huh?
00:13:53 <wagle> of course!  computers are evil
00:14:07 <sarehu> Cin understands :)
00:14:11 <Cin> actually, instead of sending it to stdout, it writes it to a stream that your bot reads from, but it's still essentially redirecting
00:14:39 <sarehu> now if you dupped a filehandle to stdout, that would be acceptable :P
00:15:08 <sarehu> of course, Scheme lets you do more... because it's evil.. it lets you walk into the fourth dimension.
00:15:16 * wagle watches sarehu burn the screen program at the stake
00:15:19 <sarehu> Whereas Haskell documents exactly what the fourth dimension is.
00:15:45 <Twey> Heh
00:16:25 <Cin> i like that you can experience an exception, and then try that computation again with new criteria as a "restart"
00:16:26 <Cale> :t callCC
00:16:26 <shachaf> Cale: Did you say you have lambdabot's nickserv password?
00:16:27 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
00:16:32 <Cale> shachaf: I do.
00:16:35 <shachaf> Cale: /msg nickserv ghost lambdabot
00:16:40 <wagle> i say the scheme steering commitee is eviiilllll
00:16:42 <Cale> hmm, might work out :)
00:16:47 <shachaf> Oh, never mind.
00:16:54 <shachaf> Well, maybe.
00:17:06 <Cale> nope
00:17:06 <Cin> haha
00:17:13 <shachaf> I guess not.
00:17:22 <Cin> can't you @part it?
00:17:22 <wagle> but wait!  they brought eval back from the dead-and-completely-removed-from-the-language
00:17:24 <shachaf> What if you /nick the new one quickly?
00:18:29 <Cale> @nick lambdabot
00:18:34 <lambdabok> Maybe you meant: dice dict
00:18:36 <sarehu> :t (callCC callCC)
00:18:36 <Twey> Heh
00:18:38 <Cale> er, hmm
00:18:40 <wagle> .. of course, they are still mezmorized by the word "hygenic"
00:18:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
00:18:50 <sarehu> bah
00:18:52 <lambdabok>     Occurs check: cannot construct the infinite type: a = a -> m b
00:19:37 <wagle> hmm..  (call/cc call/cc) actually does something interesting in scheme...  can i recall?
00:19:45 <sarehu> yes
00:19:53 <sarehu> it returns its own continuation
00:19:56 <Cale> oh well, I'll just wait
00:20:19 <sarehu> ((call/cc call/cc) (lambda (f) (display "you loser\n") (f f)))
00:20:23 <sarehu> ^^ an infinite loop
00:20:42 <sarehu> an impolite one, at that
00:20:54 <Cin> and side-effectual ;_;
00:21:04 <Cin> or side-effective, whatever
00:21:08 <Cale> getCC :: MonadCont m => m (m a)
00:21:12 <Cale> getCC = callCC (\c -> let x = c x in return x)
00:21:25 <sarehu> yeah, that's the readable way of writing it
00:21:32 <sarehu> (call/cc (lambda (f) f))
00:21:39 <Cin> cale: ban lambdabot temporarily?>_>
00:21:56 <Cale> Cin: I'll just wait for dons.
00:22:00 <Cin> k:P
00:22:23 * Cale wonders who the sysadmin is on code.h.o
00:22:57 <sarehu> probably some WHNF-headed h.o's
00:23:04 <gour> @seen ndm
00:23:04 <lambdabot> I haven't seen ndm.
00:23:41 * sarehu needs sleep, good night
00:23:50 <Cin> night
00:24:08 <Twey> 'night sarehu.
00:24:42 <wagle_home> i actually thought scheme was an exciting language until a bunch of people tried to turn scheme into algol88
00:25:00 <wagle_home> exciting language for AI
00:25:07 <Twey> Heh
00:25:13 <Twey> I prefer CL
00:25:25 <Twey> Even if it is a little... baroque
00:25:30 <wagle_home> i had been using franz lisp
00:26:13 <Twey> I wish someone would get between them, with the power and ideals of CL but not weighed down with obscure features and bugs duplicated from Lisp Machine Lisp
00:26:57 <Cale> Well, there's always liskell ;)
00:27:13 <Twey> Liskell?
00:27:26 <Cale> @where liskell
00:27:26 <lambdabot> http://clemens.endorphin.org/liskell
00:28:19 <Twey> Looks rather awesome
00:28:24 <Twey> Why isn't everyone using it?
00:28:38 <Cale> Because it has lisp syntax.
00:28:49 <Twey> And?
00:29:15 <Cale> That's probably about it, seeing as it's just a skin for GHC.
00:29:16 <mgsloan> what'd be the best way to update to the latest ghc?
00:29:25 <mgsloan> Ubuntu repos are still on 6.6...
00:29:32 <Cale> mgsloan: Install the binaries for generic linux.
00:29:51 <Twey> Cale: So is Lisp-like metaprogramming and homoiconism available in Haskell?
00:30:08 <wagle_home> bah...  lisp programs arent strings, they are data structures in the heap!
00:30:15 <Cale> Well, there's Template Haskell, but nobody uses it.
00:30:20 <mgsloan> right, so I uncompress the tar.bz2
00:30:24 <Cale> (I shouldn't say nobody)
00:30:38 <Twey> Ooh.
00:30:43 <Cale> mgsloan: and then  ./configure && make install
00:30:46 <mgsloan> oh, right, then read the INSTALL file
00:30:48 <mgsloan> thanks :)
00:31:17 <Cale> mgsloan: If you got the right one, you won't have to go out of your way to install readline 4
00:31:28 <Cale> (make sure you have the one which uses readline 5)
00:31:30 <mgsloan> I think I did
00:31:52 <mgsloan> "         This is a binary distribution, prepared by         Christian Maeder.         It uses libreadline.so.5 instead of libreadline.so.4."
00:31:58 <mgsloan> yep
00:31:58 <Cale> right, that one :)
00:32:33 <mgsloan> aw. the big ghci ascii art is gone :P
00:32:57 <Cin> twey: i think the idea is combinator-style programming is an alternative strategy for solving the same problem macros try to solve
00:33:54 <mgsloan> is there a good definition for "combinator"?  The best I can think of is a higher order operator - a function named by symbols, which operates on functions
00:34:00 <Cale> http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/release-6-8-1.html#id3129692
00:34:01 <lambdabot> Title: 1.4. Release notes for version 6.8.1, http://tinyurl.com/3yrwse
00:34:25 <mgsloan> ah, hehe, sweet :)
00:34:26 <Cin> twey: macros and the metaprogramming stuff, that is, quasiquotes et al. afaict writing mini-languages/DSLs is the problem
00:34:35 <Cale> mgsloan: Well, the really too-picky technical definition is that it's a function which produces a combination of its inputs
00:34:53 <Cale> That is, it just applies one thing to another
00:35:02 <mgsloan> ahh, interesting
00:35:08 <wagle_home> something like "function with no free vars"
00:35:12 <Cale> yeah
00:35:14 <Twey> Cale: *nod*
00:35:40 <Cale> But in informal usage it's any function which combines computations in any sense of the word "combine"
00:36:04 <mgsloan> gotcha
00:36:20 <Cale> (and "computation" :)
00:36:45 <mgsloan> heh, I just realized in some sense (.) has three operands..
00:37:08 <mgsloan> perhaps parameters would be the more appropriate term
00:37:22 <Cin> how does it have three?
00:37:25 <wagle_home> :t (.)
00:37:27 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
00:37:46 <Cale> In another sense, it has only one :)
00:38:27 <Cin> true
00:38:44 <wagle_home> :t (.) (+1)(+1)(+1)
00:38:44 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a
00:38:50 <Cale> I love how you can actually write  (f . g) x = f (g x)
00:38:55 <Cale> In order to define it.
00:39:00 <Cale> and yet...
00:39:01 <Cale> @src
00:39:02 <lambdabot> src <id>. Display the implementation of a standard function
00:39:04 <Cale> @src (.)
00:39:05 <lambdabot> (.) f g x = f (g x)
00:39:18 <Cale> They do it the boring way :)
00:39:31 <shachaf> mgsloan: In some sense it has four arguments.
00:39:54 <wagle_home> i'm dubious about three:
00:39:56 <wagle_home> :t (.) (+1)(+1)(+1)
00:39:57 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a
00:40:12 <shachaf> wagle_home: What? It type-checks.
00:40:14 <mgsloan> :t (.) (+1)(+1) 1
00:40:15 <lambdabot> forall a. (Num a) => a
00:40:22 <Cin> :t (.)
00:40:23 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
00:40:27 <shachaf> wagle_home: Even the definition has three arguments: f, g, x
00:40:29 <Cin> could be written as
00:40:43 <mgsloan> I'm confused about one, and four, or any number other than three :P
00:40:45 <Cin> forall b c a. (b -> c) -> a -> b -> a -> c
00:40:47 <Cale> :t (.) (+1) (+1) (+1) 1
00:40:47 <lambdabot> forall a. (Num (a -> a), Num a) => a
00:40:51 <wagle_home> its still "waiting" for another parameter
00:41:07 <shachaf> > (.) (const (+)) (const (+2)) 8 3 15
00:41:08 <lambdabot>  18
00:41:15 <Cale> > (.) (+) (+1) 1 1
00:41:16 <lambdabot>  3
00:41:17 <wagle_home> :t (.) (+1)(+1)(+1) 3
00:41:18 <lambdabot> forall a. (Num (a -> a), Num a) => a
00:41:19 <mgsloan> Cin - could it?
00:41:23 <mgsloan> I don't think it could
00:41:29 <Cin> mgsloan: no, i don't think so
00:42:11 <Cin> mgsloan: i see why it's three parameters, though
00:42:38 <shachaf> mgsloan: The real answer is that it's only one argument, of course. :-)
00:42:47 <wagle_home> with higher order programming, it seems not always clear how many "arguments" a function takes
00:42:55 <Cin> (b -> c) -> (a -> b) -> a -> c -- three, or (b -> c) -> (a -> b) -> (a -> c) -- two, heh
00:43:07 <mgsloan> shachaf - how so?
00:43:12 <Cale> (b -> c) -> ((a -> b) -> (a -> c))
00:43:14 <wagle_home> swing, for instance, will take any number of swing's as arguments
00:43:19 <Cin> cale: indeed
00:43:19 <mgsloan> Cin - yeah, that's the way everyone thinks about it
00:43:21 <shachaf> mgsloan: Every function only has one argument.
00:43:27 <mgsloan> oh right
00:43:28 <mgsloan> of course
00:43:32 <mgsloan> currying and all
00:43:32 <Cin> good ole λ
00:43:38 <wagle_home> how about thunks?
00:44:02 <Cin> is a thunk a function?
00:44:03 <Cale> thunks are an implementation detail :)
00:44:32 <bd_> wagle_home: just because the compiler has to pick some number of parameters at the implementation doesn't mean that matches what you expect :)
00:44:36 <Cin> just a value waiting to be evaluated
00:44:51 <mgsloan> thunk is an optimization for partial application, also generally represent values, iirc..
00:45:07 <wagle_home> i dunno..  0-arity seems fine to me
00:45:31 <Cin> well it's not really a function if it doesn't take anything is it? it's just a value
00:46:01 * Cin goes quiet before people bring in mathematics
00:46:05 <Cale> It's not a function if it doesn't have (->) as the top-level type constructor of its type.
00:46:40 <wagle_home> hmm..  i dont think i'
00:46:48 <Cale> Cin: Well, mathematics would agree with you. Of course in the most common formulation, a function is also a set :)
00:46:51 <mgsloan> I like to think of all names as functions, though
00:46:54 <mgsloan> in haskell
00:47:00 <wagle_home> hmm..  i dont think i'll find that definition of function in my dictionary
00:47:13 <mgsloan> but maybe that's taking functionality too far
00:47:20 <mgsloan> all names but Types
00:47:35 <mgsloan> even then, you get types applied to types and such :)
00:47:38 <wagle_home> the graph of a function is a set
00:47:51 <Cale> wagle_home: The function itself too, typically.
00:48:03 <Cale> wagle_home: Though it might not be the same set.
00:48:25 <Cale> Usually I like the encoding that a function f is a triple consisting of a domain, a codomain and a graph.
00:49:06 <wagle_home> i dunno..  category theory seems to be beating out of me the intuition that everything is a set
00:49:30 <Cale> Well, most formalisations of category theory require set theory to even say what a category is :)
00:49:55 <Cale> (e.g. there's a set of arrows between any two objects)
00:50:15 <wagle_home> sets of arrows and objects, but not their internal structure
00:50:39 <Cale> Well, but in particular categories, they have some structure.
00:51:09 <Cale> Or are you suggesting that the real definition of 'function' is 'arrow in an arbitrary category'? :)
00:51:26 <araujo> There exist a cabal option to include a directory with all its contents from a .cabal file?
00:52:02 <Cale> I suppose it all depends on how you formalise things.
00:52:05 <wagle_home> i can imagine functions being proper classes (though that might be wrong)
00:52:34 <araujo> bah, nobody on #cabal
00:52:35 <araujo> :-P
00:52:39 <Cale> Well, there are class functions, but usually those are treated rather differently (specifically, as predicates)
00:53:13 <Cale> shachaf: You seem to know cabal rather well :)
00:53:29 <Cale> (are you still around?)
00:53:40 <shachaf> Cale: No, and yes.
00:53:50 <shachaf> Cale: I just had the source handy. :-)
00:53:56 <Cale> ah
00:54:11 <shachaf> araujo: I remember somebody else had that problem, though.
00:54:29 <shachaf> araujo: He didn't manage to solve it...
00:54:34 <shachaf> @hackage YamlReference
00:54:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference
00:55:06 <shachaf> See http://hackage.haskell.org/packages/archive/YamlReference/0.8/YamlReference.cabal -- that .cabal really needs fixing, in a few ways.
00:55:07 <lambdabot> http://tinyurl.com/3dw6ab
00:55:15 <wagle_home> i think pretty much in set theory (though a lot with the anti-foundation axiom)..  category theory seems to be pushing me away from that, but i haven't figured out where its trying to lead me to
00:55:27 <araujo> shachaf, so far, I am using extra-source-files to include extra files .. but I wonder how to include new extra directories with all its contents if possible ...
00:55:30 <Cin> cale: all this intuition and depending on how you imagine it calls for computation to iron out the wrinkles :P
00:55:51 <Cale> Cin: I'd be willing to argue that it's a good thing
00:55:58 <wagle_home> sometime in the next year, i will spend a couple months trying again to wrap my brain around category theory
00:56:29 * araujo remembers now why he has not been able to use Cabal sdist
00:56:32 <Cin> cale: diversity in people's conceptions of maths?
00:56:52 <Cale> Cin: Well, that and flexibility of definitions, even for the same person.
00:57:05 <araujo> shachaf, yeah, that's precisely what I don't want to do ... :-(
00:57:13 <Cin> cale: ah, flexibility, i agree
00:57:14 <Cale> Do you know about Gödel's incompleteness theorem?
00:58:05 <Cin> cale: not really, i looked it up once but shrugged it off when i saw mathematical notation. the gist i got elsewhere was the limitation of human reasoning, or something
00:58:55 <Cale> Well, there are a few. The first says that essentially any formalisation of mathematics which is expressive enough to make certain kinds of universal statements about arithmetic will either be inconsistent or incomplete. That is, it either contains a pair of contradictory statements, or there are statements for which it proves neither the statement nor its negation.
00:58:59 <mgsloan> Setup.hs: Package yi-0.4 can't be built on this system.
00:59:14 <mgsloan> no other error, on a runhaskell Setup.hs build
00:59:20 <Cale> The second says that any such system which can prove its own consistency is inconsistent.
00:59:46 <Cale> (inconsistent systems prove every statement)
00:59:47 <Cin> cale: because it's self-referential?
00:59:54 <Cin> i see
00:59:56 <wagle_home> zero arguments makes perfect sense in scheme..  not perfect sense in haskell..  doesnt mean haskell is right though..  plus haskell has optimizations such that 1 + 2 doesnt work as a function taking a 1 to produce a function that takes the 2 to produce the value three
00:59:59 <Cale> Yeah, basically, making use of that fact)
01:00:07 <mgsloan> ahh, perhaps i need a UI package or something, according to the README
01:00:49 <Twey> wagle_home: ?  Haskell has zero-argument functions
01:00:51 <Cale> So basically, mathematics can't be complete, and we can't know if we've gone too far in accepting axioms and ended up with something inconsistent.
01:00:53 <Twey> We call them variables
01:01:19 <Cale> Cin: If it's determined that our formalisation is broken, we'll have to change it :)
01:01:29 <wagle_home> Twey, i was suspecting suspensions were zero-arg functions
01:01:50 <wagle_home> variables just name them
01:01:55 <Cale> I'm willing to bet that most theorems will translate nicely into whatever new formalisation we pick without much work.
01:01:59 <Cin> cale: so from that you deduce the best course of action is to never accept anything universally, only as something that temporarily fits only because we haven't discovered that it's wrong yet?
01:01:59 <Twey> Mph
01:02:15 <dolio> It's also possibly the most abused theorem (by lay people) in mathematics. :)
01:02:43 <wagle_home> which theorem?
01:02:54 <Cin> godel's incompleteness theorem
01:02:55 <Cale> Cin: Well, it's a more complicated story than this really, but somewhat.
01:02:57 <dolio> Goedel's incompleteness theorem.
01:03:12 <Cale> dolio: I agree.
01:03:26 <wagle_home> yeah..  "ooo!  that looks kinda undecidable!  run away!"
01:03:32 <Cale> dolio: I really wish more people would actually take the time to understand what it really says :)
01:04:17 <Cale> That condition which I glossed over is actually pretty important :)
01:04:36 <Cale> (the one about being able to express universal statements about arithmetic)
01:04:55 <dolio> Although, if you include other disciplines, quantum mechanics probably beats it.
01:04:57 <Cin> because things can be reduced to arithmetic?
01:05:11 <Cale> Cin: Because arithmetic can re-encode the whole system
01:05:49 <Cale> Cin: and then you can express things like the predicate that some theorem is provable in your system, but encoded in arithmetic.
01:06:33 <Cale> Then you consider the statement which effectively says "I am not provable in system X"
01:06:55 <wagle_home> the classwork i had seemed mostly geared to scaring you to death than showing you the subtleties
01:07:31 <Cin> wagle: hehe. i'm not cut out for maths :P
01:07:43 <wagle_home> is there a book/paper that explains the subtleties?
01:07:46 <Cin> cale: do you have an example?
01:08:03 <Cale> Cin: Well, working out all the details would take up a lot of space.
01:08:27 <dons> Cale, go for it.
01:08:32 <Cale> :)
01:08:32 <Cin> cale: ah. well, i think that it might mostly go over my head
01:09:05 <Cale> whoops :)
01:09:13 * Cale closes screen properly this time :)
01:09:18 <wagle_home> you killed kenny!
01:09:21 <Cale> > foldr f z [1..10]
01:09:32 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
01:09:33 <dons> yeah, needs to run in screen
01:09:41 <dons> mm
01:09:45 <oerjan> google gave me http://www.research.ibm.com/people/h/hirzel/papers/canon00-goedel.pdf
01:09:52 <lambdabot> http://tinyurl.com/y32nob
01:10:08 <wagle_home> Joe Random Paper?
01:10:22 <Mr_Awesome> whoa, i did not know lambdabot could do that!
01:10:32 <dolio> > f
01:10:32 <lambdabot>  Add a type signature
01:10:41 <Cale> Cin: There's a longwinded, but rather fun explanation of the theorem in Douglas Hofstadter's "Gödel, Escher, Bach: An Eternal Golden Braid"
01:10:46 <dolio> @type f
01:10:47 <lambdabot> Not in scope: `f'
01:11:09 * mgsloan asked for GEB for his b-day
01:11:10 <Cale> Cin: It should be reasonably understandable even if you don't have much of a mathematics background.
01:12:07 <Cin> cale: well, i will try to understand if you explain it. others in here might enjoy your explanation anyway
01:12:15 <Cale> Cin: Also, where have you studied mathematics? I find that most highschool treatments don't really give a sense of what it's like at all, and even many of the mathematics courses in universities which aren't specifically geared to the mathematics majors give the wrong impression.
01:13:09 <Cin> cale: only in school. in england, so i left at 16. my math knowledge is horrendous
01:13:15 <mgsloan> high school math is like using computer programs.  real math is like writing em
01:13:20 * mgsloan is 17 :P
01:14:29 <Cin> well, i was also stupid in school. it's only after i left that i became interested in, well, intellectual learnings, for lack of a less retarded term
01:15:04 <Cin> </lifestory>
01:15:19 <Mr_Awesome> Cin: i never let my schooling interfere with my education :)
01:15:29 <mgsloan> hmm, that is interesting
01:15:41 <Cale> Cin: Yeah, the crap they give people in highschool doesn't really give the faintest impression of what mathematicians do, sadly.
01:15:42 <mgsloan> school is pretty dull
01:15:42 <Cin> awesome: one of my favourite russell quotes
01:16:17 <mgsloan> I thought I slacked off a ton this last semester, didn't do homework very much, and such, but I only got one A-.  bizarre
01:16:21 <Mr_Awesome> i thought that was mark twain...
01:16:33 <dolio> Sounds like Twain.
01:16:48 <Cin> awesome: ah. maybe i'm thinking of a similar quote by russell. haha
01:17:05 <mgsloan> I russels about intellectuals and doubt
01:17:05 <Mr_Awesome> regardless, one of favorites as well
01:17:17 <Mr_Awesome> +my
01:17:42 <mgsloan> "The trouble with the world is that the stupid are cocksure and the intelligent full of doubt."
01:17:46 <wagle_home> oerjan, looks interesting..  thanks
01:17:53 <mgsloan> *I like
01:18:54 <Cin> mgsloan: i think that goes nicely with the more you learn the less you understand, or something like that
01:19:05 <Cale> Cin: well, okay, I can try to explain, based on what I remember of how it goes.
01:19:25 <Cin> cale: okay
01:19:51 <Cale> Cin: First of all, you need to come up with a way to encode strings of symbols used in your system as natural numbers and be able to operate on them.
01:19:53 <mgsloan> i think it's more along the lines of the more you know, the more you realize you don't know very much :)
01:20:00 <mgsloan> but yeah does go along with that
01:20:12 <mgsloan> probably the actual quote is well put
01:20:12 --- mode: ChanServ set +o Cale
01:20:17 <Lilyb57q11rz5c0> - computer find, term that the compact it. concept of the hardware what This virtual technology two the
01:20:18 <Jamiec47e19hp8c2> can being your our It helmet far important two a we a far to There confuse out and
01:20:19 <Thomasn98c23os9d> term separate reality. if this from but headgear becoming the it. it's technology brain, it now. far aversion
01:20:20 <Elizabethd06k22o> had but virtual we on is we with The and do even at in But it. we'll the
01:20:22 <Lilyb57q11rz5c0> has while vision, a very about Helmet VR they the the public. tensile The VR As into It
01:20:22 <Jessical20i16wp0> into be real out out has have term strapped were seeing convincing our the toward world. that
01:20:23 <Thomasn98c23os9d> toward feeling The to around affordable People it movie your for 2007, really something user's hard that was
01:20:23 <Callumh57g23hm7f> image senses with in defined a experiencing the confuse How hardware reality are to simply something The of
01:20:24 <Jamiec47e19hp8c2> It able necessarily they we your you convincing initial it. for forsaken for more a HELLO ANYBODY CAN HERE ME?! shutting long
01:20:27 <Cin> mgsloan: did einstein say it?
01:20:27 <Elizabethd06k22o> a fooling to to why of believing virtual associated term of 3D, be television. larger world separate than
01:20:29 <Georgian92f23rk7> entertainment hands you're about that been has in that world. surround equipment, surge let's a been heard user
01:20:30 <Thomasn98c23os9d> if of But to now let's The 3D way that be are And realizing for goal virtual being
01:20:31 <Matthewa80p16ol3> to VR them. very with surge culture, Also that ?!?!?!?!?!!??!!?!?!?!? into in than Of experiencing they "being It's
01:20:32 <Jamiec47e19hp8c2> we It helmets from a larger the was the obvious our it'd separate takes a reality. being human
01:20:34 --- mode: Cale set -b *!*@bas3-montreal02-1096681481.dsl.bell.ca
01:20:36 <Georgian92f23rk7> VR Also vision, public world As practical. It now very helmets is staying obvious virtual in so the
01:20:36 <flux> newbieflooder :-)
01:20:38 --- mode: Cale set -b *!n=palomer@*
01:20:46 <Cin> sigh
01:20:49 <mgsloan> Cin - maybe..
01:20:51 <Callumh57g23hm7f> you're virtual could with of associated and popularity is completely term's pop able elaborate that term doesn't
01:20:51 <Lilyb57q11rz5c0> had time. that the senses but 7.1 the about the "being being The television. world on and
01:20:51 <Jessical20i16wp0> The They - vision, television. that HI any of reality. our gamepads available, audio, VR see
01:20:52 <wagle_home> go cale go!  rah rah rah!
01:20:54 --- mode: Cale set -b *!*@69.106.58.193
01:20:57 --- mode: Cale set +b *!*@203186060211.ctinets.com
01:21:07 <Cale> stupid full banlist
01:21:21 <Cale> (and why can't banlists be arbitrarily long?)
01:21:27 <Cale> oh well.
01:21:29 --- mode: Cale set -o Cale
01:21:33 * Cin makes note to make HIRCd have arbitrary length banlists
01:22:01 <flux> cin, I suppose there need to be some reasonable limits to remove a possibility of DoS?
01:22:05 <int-e> Couldn't we just get rid of them all and re-add the ones we actually need? :P
01:22:11 <int-e> (Cale)
01:22:15 <flux> but maybe they could be longer than 50
01:22:21 <Cale> int-e: We maybe could.
01:22:26 <flux> (actually, isn't 50 quite long :))
01:22:39 <int-e> @users
01:22:40 <lambdabot> Maximum users seen in #haskell: 428, currently: 420 (98.1%), active: 12 (2.9%)
01:22:43 <Cale> int-e: another option is to design a simple bot to manage bans
01:22:45 <flux> lambdabot would be in position to maintain bans with timeouts etc.
01:23:08 <Cale> I'd rather lambdabot, in all its complexity was not itself an op, but that's just me.
01:23:20 <Cale> But a simple bot, we could be pretty sure about that :)
01:23:24 <wagle_home> rule 1: alway attack from (>50) nicks
01:23:26 <int-e> flux: it doesn't even cover 20% of the channel users :P so if every 6th person coming here should be banned, the list will overflow.
01:23:34 <flux> wagle_home, and hosts and countries?
01:23:37 <Cale> wagle_home: (>50) servers?
01:23:50 <wagle_home> s/nicks/servers/
01:23:54 * int-e has no idea what the actual percentage is, it's probably lower than 16% :)
01:24:18 <wagle_home> s/servers/blacklistable entities/
01:24:40 <oerjan> Cale: isn't that what ChanServ is?  i've seen it apply bans
01:24:49 <Cin> cale: can you give an example of your first statement? examples really help me to know that we're thinking of the same thing
01:24:56 <Cale> Cin: anyway, so the first step is just to formalise our mathematical system, so there's some finite alphabet of symbols, statements are strings of those symbols, and so are proofs
01:25:09 <Cin> ah, okay
01:25:27 <wagle_home> could do a bot that maintains a larger lists, and swaps in the currently "most needed" rules
01:26:15 <wagle_home> sorta like virtual memory for the banlist..  8)
01:26:36 <Cale> Then we make some correspondence between strings of those symbols and numbers. There are lots of ways to do that. One is to use base n representation, where n is the number of symbols in your alphabet. One elegant way (that Gödel is credited with) is to use exponents on the sequence of primes to encode strings.
01:26:48 <shachaf> Cale: You might be able to unban them now.
01:26:55 <Spockz> 'day
01:27:01 <Cale> Spockz: hi
01:27:13 <Spockz> Cale: hey
01:27:48 <Spockz> Is everyone enjoying their weekends?
01:28:24 <Cale> Cin: You can encode any sequence (n_1, n_2, n_3, ...) of integers as an integer by just writing 2^(n_1) 3^(n_2) 5^(n_3) ... p_k^(n_k)
01:28:26 <Cin> cale: so for representing the idea of the number 4, instead of `4' you might represent it as `2²'?
01:28:39 <Cin> cale: oh, hm
01:28:53 <Cale> Where p_k is the kth prime.
01:29:41 <Cin> what is a sequence in this context?
01:29:45 <Cale> and so by letting elements of your alphabet correspond to some integers, you can re-encode any string of those as an integer as well, like that.
01:29:52 <Cale> Just a finite list.
01:30:03 <Cale> (sorry)
01:31:23 <Cin> i think i follow you
01:31:50 <Cale> Proofs are also formalised -- there's (say) a finite list of axioms, and a finite list of derivation rules, and a proof consists of a finite sequence of statements in the system where each statement is either an axiom, or it follows from the previous ones according to one of the rules.
01:31:51 <Cin> letting elements of your alphabet correspond to the primes?
01:32:06 <Cale> Letting elements of your alphabet just correspond to integers in any way.
01:32:11 <Cale> Usually just:
01:32:59 <Cale> forall -> 0, exists -> 1, & -> 2, | -> 3, x -> 4, ...
01:33:10 <Cale> Well, pick some alphabet :)
01:33:23 <Spockz> hebrew :+
01:33:32 <Cale> We could use unicode if you want.
01:33:38 <Cin> cale: ah, okay. right i follow what you said about proofs
01:34:34 <Cale> So if we can encode proofs as numbers, we could mathematically write down a predicate P(n,x) that says 'n is a number corresponding to a proof of the statement encoded by the number x'
01:34:52 <Spockz> Cale: predicate logic?
01:35:03 <Cale> Spockz: yeah, this is inside predicate logic.
01:35:17 <jrx_> @pl \x -> [x,x]
01:35:17 <lambdabot> ap (:) return
01:35:28 <Cale> Spockz: I'm giving a rough overview of Gödel's incompleteness theorem.
01:35:37 <Cale> Cin: did that make sense?
01:35:50 <Cin> cale: i think so, yes
01:36:07 <Cale> Cin: Basically, encode proofs and statements as numbers, and then (in some complicated way) work out what it means for the proof to prove the statement.
01:36:19 <Cin> right
01:36:39 <Cin> cale: can you give an example encoding, given your above alphabet?
01:37:11 <Cale> Cin: well, that alphabet is horribly incomplete, but let's say we want to write x & x | x
01:37:42 <Cin> cale: does this read as `x and x or x' or is it some other logic notation/
01:37:48 <Cale> yeah
01:37:52 <Cin> okay
01:38:11 <Cale> (but it might not even be syntactical, depending on the system involved, who knows :)
01:38:14 <Cale> That'd become the number 2^4 3^2 5^4 7^3 11^4
01:38:44 <wagle_home> take a [Char], convert it to [Octet], convert that to Integer
01:39:26 <Cin> cale: ah, i see
01:39:28 <wagle_home> (ie, whatever, Integer's internal representation is (something like [Word32])
01:39:29 <Cale> The nice thing about this way is that the alphabet can even be infinite if we want.
01:39:50 <Cale> Because every integer has a unique decomposition into primes (up to permutation and signs)
01:40:05 <dolio> "TAG wubgipkamcep" <-- jhc has some interesting version names.
01:40:05 <Cale> So the exponents can be any integers :)
01:40:09 <Cale> er, any natural numbers
01:40:14 <Cin> ah
01:40:33 <Cale> Usually we go with a finite alphabet anyway
01:40:40 <Cin> so the symbol `4' could represent &x because 2^4=4?
01:40:47 <Cin> errr
01:41:14 <Cale> 2^4 = 16 and that's just x
01:41:34 <Cin> ahh right, yes
01:41:41 <Cale> 2^2 3^4 would be "&x"
01:41:50 <Cin> little confused, there
01:41:54 <Cin> right
01:42:22 <Cale> er, I shouldn't have let any of my alphabet symbols correspond with 0
01:42:26 <Cale> that's rather important :)
01:42:43 <Cale> (you can probably understand why :)
01:43:05 <Cale> But anyway, any encoding of strings of symbols as integers will do.
01:43:06 <Cin> heh, yes
01:43:17 <Cin> okay
01:43:37 <Cale> Then we consider the predicate Prov(x) = exists n. P(n,x)
01:44:23 <Cale> That is, Prov(x) is the predicate which says "there is a number n corresponding to a proof of the statement encoded by the number x"
01:44:34 <Cale> That is, it basically says "x is provable"
01:45:09 <dolio> > let primes = nubBy(((>1).).gcd)[2..] ; godel = product . zipWith (^) primes . map ord in godel "foo"
01:45:11 <lambdabot>  1783155891896750219904608979581845929596879710935764589843750000000000000000...
01:45:47 <Cin> cale: what does it mean to be encoded by?
01:45:51 <Cale> Gödel numbering is a massively inefficient encoding, but hey, we're mathematicians :)
01:46:30 <Cale> Cin: Well statements are strings of symbols, and I've just been talking about how to encode strings of symbols as integers.
01:46:55 <wagle_home> not if you keep your integers in their prime-factorization forms
01:46:56 <Cin> cale: oh, sorry, i misread what you said
01:47:10 <Cin> cale: okay, continue
01:47:44 <Cale> Okay, now I have to get a little more detailed about now logical systems work.
01:47:46 <Cin> cale: just to clarify, is the proof encoded by the number n?
01:47:49 <Cale> Yes.
01:48:14 <Cin> okay :)
01:48:35 <Cale> So Prov(x) is the predicate which is supposed to be true exactly when there's a proof of x.
01:48:48 <Cin> right
01:48:50 <Cale> (the statement encoded by the number x)
01:49:17 <Cale> Now, I have to get into a little annoying technical detail. Do you happen to know what a free variable is?
01:49:40 <Cale> Well, we're somewhat familiar with it from Haskell.
01:49:51 <Cin> well, as it has appeared in lambda calculus, a variable that isn't bound to anything yet, or is bound to something in a higher function
01:49:52 <Cale> In, for example, (\x -> y x)
01:49:55 <Cale> right
01:49:57 <Cin> is that correct?
01:49:59 <Cin> okay
01:50:01 <Cale> y there is a free variable
01:50:06 <Cale> x is bound by the lambda
01:50:10 <Cin> yes
01:50:35 <Cale> In logic, we're presumably not using lambdas, but instead we have forall x. (... x ...) and  exists x. (... x ...) as binders.
01:50:49 <Cin> okay
01:51:09 <Cin> can those be combined at all?
01:51:14 <Cale> Okay, so imagine enumerating all the formulas in our system which have just one free variable in them
01:51:17 <Cale> oh, yes
01:51:20 <Cale> We can write:
01:51:22 <int-e> Cale, the following theorem gives a more practical encoding of fintite sequences of natural numbers: For all finite sequences of natural numbers a_i, 1 <= i <= n, there are numbers u, v and w such that  a_i == u `mod` (v + i*w) (1 <= i <= n). (that's an almost immediate consequence of the chinese remainder theorem.)
01:51:28 <Cale> forall x. exists y. x + y = 0
01:51:29 <Cin> ie can an `exists' appear inside another `exists' or a `forall'
01:51:34 <Cin> ah,okay. cool
01:51:46 <Cale> Okay, so imagine enumerating all the formulas in our system which have just one free variable in them
01:52:02 <Cale> and just for concreteness, let that be the variable z
01:52:07 <Cale> So for example:
01:52:14 <Cale> forall x. exists y. x + y = z
01:52:27 <Cale> is in that infinite sequence of formulas
01:52:43 <Cin> right
01:52:43 <Cale> We'll call the kth such formula B_k
01:53:15 <Cin> okay
01:53:41 <Cale> also, just for notation's sake, I'm going to write "the number corresponding to the statement foo" as <foo>
01:53:51 <Cin> alright
01:54:20 <Cale> Now, consider the formula not Prov(B_x)
01:54:59 <Cale> which has one free variable
01:55:11 <Cale> er, rather let's make that
01:55:16 <Cale> not Prov(B_z)
01:55:25 <Cale> (using z as my one free variable :)
01:55:48 <Cin> there is not a number x corresponding to the proof B_z?
01:56:02 <Cale> right
01:56:09 <Cale> That is, B_z is not provable
01:56:23 <Cin> okay
01:56:41 <Cale> Er...
01:56:49 <Cale> yeah, that's fine
01:57:03 <Cin> or
01:57:15 <Cin> there is not a number n corresponding to the proof encoded by B_z?
01:57:15 <Cale> Now, since this is itself a formula with one free variable, z, it must correspond to B_k for some k
01:57:16 <Cin> hrm
01:57:27 <Cale> Cin: sure, same thing :)
01:57:31 <Cin> okay :P
01:57:39 <Cale> er
01:57:51 <Cale> corresponding to the *statement* encoded by B_z
01:58:07 <Cin> oops. i don't know why i wrote proo
01:58:10 <Cale> That is, there is no number n which encodes a proof of the statement encoded by B_z
01:58:25 <Cin> right, that's clearer
01:58:40 <Cale> This statement itself has a single free variable, and so it must be B_k for some k
01:58:50 <Cale> (since the B_k's enumerate all such statements)
02:00:11 <Cin> B_k is any formula in our system, or B_k is any formula in our system with a free variable?
02:00:39 <Cin> well, B_k is the kth forumula, but
02:00:48 <Cale> B_k is an integer encoding the formula not Prov(B_z)
02:01:03 <Cale> Where z is free.
02:01:28 <Cin> ahhh
02:02:01 <Cin> sorry, i think i follow now
02:02:21 <Cale> Now, I'm going to write B_k(m) for the number encoding the same statement, but where the z in the formula has been replaced with the number m
02:02:34 <Cale> (that is, the encoding of the number m)
02:02:43 <Cale> This is essentially a bit of string manipulation, that is.
02:03:07 <Cale> Make sense?
02:03:22 <Cin> i think so
02:03:36 <Cale> So B_k is an integer encoding  not Prov(B_z), and  B_k(m) is an integer encoding not Prov(B_m)
02:03:53 <Cin> the general semantics of the whole thing are still fuzzy so it's slow to think about
02:03:56 <Cale> okay
02:04:16 <Cin> ah, right. i follow that
02:04:40 <Cale> Yeah, it's rather hard to really understand how this works if you don't know how, say, first order logic works, but let's keep on, we're almost there :)
02:04:46 <Cin> so with B_k(m) you are binding the variable?
02:04:49 <Cale> yeah
02:04:51 <Cin> instead of having it free
02:04:53 <Cin> okay, cool
02:04:56 <Cale> I'm setting to m
02:05:05 <Cale> Now, consider the number B_k(k)
02:05:08 <Cin> instead of saying "for some z" it's "for this specific m"
02:05:19 <Cin> hm
02:05:27 <Cale> Which statement does it encode?
02:06:53 <Cin> it looks like it encodes itself but i am just confused
02:06:55 <Cin> hang on
02:07:43 <Cale> oh, hang on, perhaps I've messed up a bit
02:08:10 <Cale> ah, yeah
02:08:14 <Cale> Just a little :)
02:08:19 <Cin> hrm?
02:09:22 <Cin> B_k(k) is an integer encoding the formula not Prov(B_k)? >_<
02:09:39 <Cin> it's like a contradiction
02:09:40 <Cale> but it should be not Prov(B_k(k))
02:09:44 <Cale> if I'd done it right
02:09:48 <Cin> ah
02:09:49 <Cin> hrm
02:10:05 <Cale> So I messed up in defining the substitution process clearly
02:10:27 <Cin> ah
02:10:48 <Cin> a statement that proves itself false?
02:11:15 <Cale> But yeah, we get this *number* which encodes a statement that says there's no proof of that number.
02:11:22 <Cin> ahh
02:11:39 <Cale> But of course, you've hit the nail on the head.
02:12:08 <Cale> That number encodes a statement, which effectively asserts that (under encoding) it is not provable.
02:12:48 <Cale> (this is rather like the proof regarding the Halting problem is it not?)
02:12:58 <Cale> So is this statement provable?
02:13:50 <Cin> i'm confused. you have a self-referential statement?
02:13:57 <Cale> Basically.
02:14:06 <Cin> and it's saying about itself that there is no proof for it
02:14:06 <Cale> With one layer of "encoding using numbers"
02:14:10 <Cale> right
02:14:31 <Cale> So if there's a proof for it, the system proves something which seemingly ought to be false.
02:14:35 <qwe> i am getting the following error:  Instance of Num Bool required for definition of match
02:14:40 <qwe> on following lines
02:14:42 <Cin> ah. so there is no proof for it *when using number encoding*?
02:14:52 <Cale> Cin: well, there might be
02:14:53 <qwe> match::Eq a=>[a]->[a]->Int->Bool
02:14:53 <qwe> match [] [] _ = True
02:15:01 <qwe> what does it mean ?
02:15:05 <Cale> Cin: the number encoding is supposed to match the system we're working in
02:15:33 <Cale> qwe: it probably is not that line
02:15:38 <Cale> qwe: what's the next line?
02:15:44 <Cale> @paste
02:15:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:15:51 <Cale> maybe paste the whole function
02:15:58 <Cin> ahhh
02:16:24 <Cale> Cin: that is, we encode the basic formalisation of mathematics with numbers
02:16:35 <Cale> and define provability and so on that way :)
02:17:04 <qwe> http://hpaste.org/5552
02:17:07 <Cale> and then construct this statement which asserts its own unprovability
02:17:46 <Cale> (match xs ys n-1) -> match xs ys (n-1)
02:18:09 <Cale> qwe: (match xs ys n-1) parses as (match xs ys n)-1
02:18:36 <qwe> yes it helped
02:18:39 <qwe>  thanks
02:18:53 <Cale> qwe: the basic rule is to always put parens around parameters which are not single words
02:19:19 <Cin> so it asserts its own unprovability. if it is true then something in the system is unprovable, if its assertion is false... hrm
02:20:16 <Cale> If it's true then a true statement in the system is unprovable, and if it's false, then it can be proven!
02:20:47 <Cale> and so the system ends up having a true statement which is not provable, or a false one which is provable
02:21:01 <Cin> but if it can be proven, does that prove that there is a statement that is unprovable?
02:21:13 <Cin> ah
02:21:40 <Cin> this reminds me of russell's paradox
02:21:51 <Cale> Yeah
02:22:09 <Cin> well, any paradox, really. just that's the only mathematical one i can think of, hehe
02:22:40 <Cin> so is this a paradox in the very definition of our system?
02:22:52 <Cin> and does that make it "incomplete"?
02:23:32 <Cale> Well, the existence of statements like this means that any system which is sufficiently expressive will end up *either* being incomplete, *or* being inconsistent.
02:23:49 <Cale> So really incompleteness is what we hope for.
02:23:58 <Cale> Because inconsistent is *really* bad.
02:23:59 <Cin> ahh, right
02:24:04 <Cin> indeed
02:25:03 <Cin> blimey
02:25:25 <Cale> Well, there are also mathematical systems which are complete, but too weak to accomplish this feat.
02:25:29 <wagle_home> is there a nice/easy explanation of what "sufficently expressive" is (where the boundary is)?
02:25:34 <Cale> For example arithmetic with only addition.
02:26:11 <Cale> Well, in this case, it's the ability to encode existential and universal statements about the integers with addition and multiplication.
02:26:23 <Cale> (and equality)
02:26:35 <wagle_home> i thought peano arithmetic without induction was complete
02:26:43 <Cin> hm. i once tried to define addition-only arithmetic with a set of axioms, by a set of substitutions on symbols like binary. probably completely wrong,though
02:26:56 <Cale> Well, induction is needed too, I'm pretty sure.
02:28:03 <Cale> Cin: well, that's not so hard, I wouldn't be too surprised if you got it right :)
02:28:12 <Cale> Cin: unary is easier though ;)
02:28:22 <Cin> hehehe
02:29:31 <wagle_home> doesnt unary turn what would be polynomial turing machines exponential?
02:29:37 <Cale> http://planetmath.org/encyclopedia/PressburgerArithmetic.html (unfortunate misspelling in the url)
02:29:38 <lambdabot> Title: PlanetMath: Presburger arithmetic
02:29:46 <Cale> wagle_home: yeah
02:30:00 <Cale> wagle_home: But it makes for easy axioms.
02:30:48 <Cin> i find church numerals quite interesting. that's why i'm writing this lambda calculus computer, to enhance my understanding and for experimentation
02:30:52 <wagle_home> whats left if you push some portion of P out to EXP?
02:31:18 <Cale> wagle_home: I'm not sure what you mean :)
02:32:11 <Cin> cale: thanks for the explanation. i think i might actually have a go at reading more around this subject :)
02:32:37 <wagle_home> whats in P on a unary turing machine?
02:32:40 <Cin> cale: seems *slightly* less frightening now :P
02:32:43 <Cale> Cin: good luck with it :)
02:32:52 <Cale> Cin: mathematics is really not so bad.
02:33:22 <Cale> Cin: It's just that highschool teachers generally are forced to teach it all wrong by a system they have no control over, or otherwise they're just bad teachers.
02:33:29 <Cale> (there's a bit of both)
02:33:38 <Cale> wagle_home: hmm...
02:33:42 <wagle_home> Cin, decrement is fun in church numerals..  apparently there is a construct in System F that's decrement in disguise
02:33:55 <Cale> wagle_home: Well, can you tell the difference between a 1 and a blank?
02:34:18 <wagle_home> Cale, i guess, but i think you cant write a blank
02:34:21 <Cale> wagle_home: Or are you not allowed to have a blank occurring between two ones?
02:34:32 <Cale> I think that'd be fine still.
02:34:51 <Cale> You have an "immutable" Turing machine :)
02:34:54 <Cale> (sort of)
02:35:10 <Cale> You just make sure to always write things at the end.
02:35:12 <wagle_home> immutablr?
02:35:22 <wagle_home> immutable, even?
02:35:34 <Cin> ah, i have to go now. meeting a friend i haven't seen for a while :) bye
02:35:40 <wagle_home> cya
02:35:40 <Cale> Cin: later!
02:35:51 <Cale> Well, it's mutable, but you generally don't want to write over what you've already written on the tape.
02:36:25 <Cale> Cin: I believe you can, in polynomial time, devise some system to always seek to the end of the written portion of the tape, and mark the written-on bits.
02:36:41 <Cale> (so you can seek back and read them later)
02:36:45 <wagle_home> all i know is Papadimitriou had the misfortune of writing a computational complexity text with unary turing machines..  his next edition fixed that
02:37:25 <Cale> I think it shouldn't affect the complexity-class of algorithms -- at least P should stay what it was like that.
02:37:56 <wagle_home> apparently it doesnt..  bases > 1 use log(n) space
02:38:05 <wagle_home> instead of n
02:38:11 <Cale> Oh, space-wise, it will hurt you.
02:38:20 <Cale> hmm
02:38:29 <wagle_home> space hits you on time..  i dunno the details
02:38:30 <Cale> oh
02:38:33 <Cale> yeah, okay
02:38:40 <Cale> err....
02:38:55 <Cale> Oh, if your inputs are always encoded in unary, yeah
02:39:02 * wagle_home imagines space hits you on time, but thats not saying how much
02:39:04 <Cale> But it's not something intrinsic to the machine.
02:39:37 <Cale> You'll push lots of stuff into exptime if the inputs to the machine are unary-encoded numbers.
02:40:21 <Cale> But I believe a machine which can only write 1's on an initially blank tape should be just as capable as a usual one -- you could still encode its inputs in binary.
02:40:23 * dolio mutters about people telling him he's wrong based on their own, personal, formal semantics of Haskell.
02:40:36 <Cale> dolio: what?
02:40:59 <wagle_home> dolio is wrong, Wrong, WRONG!  Maybe 8)
02:41:12 <dolio> In the reddit article about dpiponi's () -> () article, I said () has two values, () and _|_.
02:41:17 <wagle_home> dolio, what are you wrong about this time?  8)
02:41:28 <Cale> dolio: that is true.
02:41:45 <wagle_home> is bottom a value?
02:41:48 <Cale> yes
02:41:50 <meryrus> Yes.
02:42:01 * wagle_home looks dubious
02:42:07 <Cale> > let x = x in x
02:42:08 <dolio> So someone came back and said, "I wouldn't call [_|_] a value. There is only one value: (). Halting or not is an algorithmic property..."
02:42:11 <lambdabot>  Exception: <<loop>>
02:42:30 <Cale> dolio: They're simply wrong.
02:42:43 <Cale> dolio: hehe
02:42:44 <wagle_home> how do you tell the difference between bottom and 42, which took 7.5 million years to compute?
02:43:02 <dolio> Well, you could probably formalize Haskell in some system that doesn't talk about bottoms.
02:43:08 <meryrus> dolio: I like your response :)
02:43:14 <Cale> That would be unreasonably hard.
02:43:25 <scook0> wagle_home: if only we had some algorithm to tell us if an arbitrary program was going to halt...
02:43:27 <dolio> But it wouldn't be the typical denotational semantics that everyone seems to use.
02:43:31 <Cale> right
02:43:50 <wagle_home> scook0, goedel says nopers
02:44:00 <Cale> Look, I can pass bottom around to functions and they return non-bottom values.
02:44:16 <scook0> wagle_home: exactly
02:44:41 <scook0> on the other hand, if you *do* get 42 after millennia of waiting, then at least you know it does halt ;P
02:44:46 <Cale> I suppose you could say that every expression having a particular type is a value of that type.
02:44:52 <wagle_home> scook0, so bottom doesnt act like the values i know
02:45:11 <Cale> But usually you want to treat 3 + 2 and 5 as referring to the same value.
02:45:38 <scook0> wagle_home: though I should probably let others talk, since I'm not exactly an expert in this domain
02:45:38 <wagle_home> i just think if you include bottom, you have to be considering program behaviors
02:45:59 <wagle_home> eh, noone died and made me an expert
02:46:44 <scook0> I'm just making sure you don't confuse me with one, that's all
02:46:58 <wagle_home> i'm rather heretical for spouting such nonsense that bottom isnt a value (its something really interesting, i think, just not a value)
02:47:21 <Spockz> why wouldn't be bottom a value?
02:47:43 <wagle_home> and yeah yeah, people like lifted domains..  i'm dubious
02:48:01 <wagle_home> isBottom? :: a -> Bool
02:48:01 <scook0> it seems to come down to issues of naming and intuition
02:48:19 <scook0> bottom certainly has properties that "reasonable" values don't share
02:49:00 <wagle_home> i also think an error is different than an infinite loop
02:49:38 <wagle_home> but beware of me if you dont wanna get a scarlet H tattooed on your forehead
02:49:45 <mgsloan> yeh, something stinks in bottom land imho
02:50:10 <meryrus> I think it would be quite the fundamentalist language that didn't want to talk about bottoms.
02:50:42 <meryrus> I mean, wanted to not talk about bottoms. Stupid not and it's scope issues.
02:51:15 <wagle_home> i think that maybe the problem is that i want to describe what programs do..  semantics wants to know what functions programs approximate
02:51:32 <dolio> There are different kinds of semantics.
02:51:36 <wagle_home> s/functions/mathematical functions/
02:51:51 <dolio> In denotational semantics, there's no difference between an infinite loop and an error.
02:52:00 <dolio> But, there might be a distinction in, way, operational semantics.
02:52:04 <wagle_home> i've only hung around denotational semanticians
02:52:07 <dolio> Say, even.
02:52:26 <dolio> Yeah, denotational semantics seems more common, for some reason.
02:55:23 <wagle_home> well, i'm interested in the denotational semantics of program behaviors, if that makes any sense
02:57:08 <dolio> Well, you could probably gain some ground by having several bottoms.
02:57:17 <dolio> bottom_loop and bottom_error.
02:57:18 <wagle_home> my first (and last) foray into the subject had me denying the axiom of foundation before it was chik to deny it
02:57:20 <Cale> dolio: http://reddit.com/r/programming/info/685qy/comments/c034vbz
02:57:32 <dolio> But they wouldn't be very different in pure code, off the top of my head.
02:57:42 <Cale> wagle_home: The axiom of foundation? As in ZFC?
02:57:43 <dolio> Although they'd get different in the IO monad, I suppose.
02:58:32 <wagle_home> yes..  there is an anti-foundation axiom..  (see aczel, or barwise and moss, both of which came after i made a fool of myself)
02:59:16 <Cale> wagle_home: The axiom of foundation is basically there so that you're talking about set theory and not a fucked-up version of graph theory.
02:59:49 <wagle_home> there are non-fucked up versions of sets as graphs
03:00:11 <wagle_home> thats what the anti-foundation axiom gives you
03:00:43 <wagle_home> its basically final co-algebra, so i understand
03:01:15 <meryrus> Oh, that's interesting.
03:01:40 <wagle_home> i got suick of the whole thing long ago, but occasionally get the urge to revisit the problem..  (i was trying to do denotational semantics on anti-founded sets and greatest fixpoints)
03:01:52 <wagle_home> s/suick/sick/
03:02:21 <wagle_home> neither of which existed at the time (1986)
03:02:29 <wagle_home> (as far as i could tell)
03:03:06 <Cale> So you define equality in terms of some kind of bisimulation?
03:04:05 <Cale> I suppose that's what it amounts to anyway.
03:04:18 <wagle_home> thats how they do it..  i was just trying to do a class project..  didnt worry about equality being anything more than "obvious"
03:05:59 <Cale> I suppose well-foundedness is basically the least-used axiom.
03:07:16 <rekso> I bet there are a lot of instances of replacement that no one has ever used. :-)
03:07:33 <meryrus> More than there are stars in the heavens.
03:08:30 <rekso> "There are fewer things on heaven and earth than are dreamt of in _our_ philosophy."
03:08:50 <meryrus> Heh.
03:09:16 <Cale> rekso: You mean, replacement is needed for existing theorems, but it goes unnoticed due to lack of formality, or just that there are lots of theorems coming from uses of replacement which nobody has seen?
03:09:27 <wagle_home> least fixpoints need the axiom of foundation, if i have it right
03:10:31 <Cale> hmm
03:11:41 <rekso> Cale: I was just being silly really, i.e. there are presumably more instances of replacement than there are proofs in the world.
03:12:08 <Cale> heh
03:12:45 <rekso> Cale: But I think it's been claimed that ordinary mathematics only requires restricted replacement, where the restriction is to Pi_2^2 sentences or some such.
03:13:33 <wagle_home> so if there are uncountably many instances of replacement, then you could encode the solution to the halting problem in one of those instances
03:13:50 <rekso> There are *way* more than uncountably many. :-)
03:13:54 <Cale> rekso: It's certainly not something which mathematicians usually apply explicitly. Even working with proper classes is unusual except in category theory or set theory.
03:14:39 <wagle_home> (apparently you can encode the solution to the halting problem in a real number)
03:15:44 <wagle_home> (which got some theoretical neural network people excited)
03:15:45 <dolio> That's why the perspex machine is so great, right?
03:16:16 <wagle_home> is that why i had that mysterious perspex machine bookmark?
03:16:34 <Cale> wagle_home: You can encode lots of stuff in a real number :)
03:17:34 <wagle_home> <me> Have you constructed this number?  <hava siegelmann> yes!  <me> *stunned silence*
03:18:29 <Cale> You can construct bad approximations to it if you're really really patient, and willing to prove various Turing machines don't terminate..
03:19:03 <Cale> (Worse approximations if you're really really really patient and you don't like proving things.)
03:20:16 <Cale> Eventually, though, you'll hit a bit which you can't prove either way, of course.
03:22:14 <wagle_home> use analog computers
03:23:30 <Cale> Not just analog computers, but *perfect, noiseless* analog computers which compute everything *instantaneously*.
03:23:46 <meryrus> I have one of those in my basement; don't you?
03:23:50 <meryrus> :)
03:24:42 <Saizan> then it's easier to get an oracle :)
03:25:39 <wagle_home> not my position, i cant defend it
03:26:44 <Cale> The microwave background radiation probably encodes it somehow. We just have to figure out how!
03:27:04 <wagle_home> i was in the "quantum mechanics probably says you cant get infinite precision" camp
03:28:08 <Cale> I wonder what the actual information content of the microwave background radiation is. After all, it came from a time when the universe was really small, perhaps bounds can be computed :)
03:29:33 <wagle_home> you saying that information has increased with the evolution of the universe?
03:29:50 <wagle_home> 8)
03:30:46 <wagle_home> hmm..  maybe the information content started, and remained at, zero..  that would explain a lot..  8-D
03:31:45 <wagle_home> darn..  now i wonder that the anthropic principle people are saying
03:33:49 <wagle_home> something like "if the universe collapses in such and such a way, then the information content will approach infnity, and hopefully someone will be around to build a super duper computer that could be used to bring everyone who's ever lived back to life..
03:34:18 <meryrus> Tipler?
03:34:40 <wagle_home> apparently they go into a bunch of rigorous mathematical physics too..  tipler sounds like one
03:35:06 <meryrus> It was supposedly a testable theory
03:35:46 <wagle_home> i didnt read that far
03:36:03 <meryrus> I was young and idealistic.
03:36:06 <wagle_home> how do you test it short of waiting until the end of the universe?
03:36:09 <meryrus> And still a mathematician, at that point.
03:36:24 <meryrus> I don't remember. It's been at least four years.
03:41:53 <wagle_home> sorry, Cale, didnt mean to scare you off..  now i'm wondering what the info content of the big bang was
03:42:04 <Cale> :)
03:42:27 <Cale> I'm not much of a physicist, so I have no idea how to get it :)
03:42:44 <Cale> wait...
03:42:49 <Cale> maybe I have an idea:)
03:43:27 <wagle_home> i have the impression that hawking thinks about such things
03:46:44 <Cale> hmm, maybe not enough assumptions about how the big bang went to know
03:47:01 <Cale> I was thinking http://en.wikipedia.org/wiki/Planck_temperature might be handy :)
03:47:01 <lambdabot> Title: Planck temperature - Wikipedia, the free encyclopedia
03:47:10 <Twey> @src filter
03:47:10 <lambdabot> filter _ []     = []
03:47:10 <lambdabot> filter p (x:xs)
03:47:10 <lambdabot>     | p x       = x : filter p xs
03:47:10 <lambdabot>     | otherwise = filter p xs
03:50:33 <Cale> "The translational motion of fundamental particles of nature such as atoms and molecules gives a substance its temperature. Here, the size of helium atoms relative to their spacing is shown to scale under 1950 atmospheres of pressure. These room-temperature atoms have a certain, average speed (slowed down here two trillion fold). At any given instant however, a particular helium atom may be moving much faster than ave
03:50:33 <Cale> rage while another may be nearly motionless."
03:51:22 <Cale> Hehe, the lengths we go to in order to produce reasonable-looking diagrams :)
03:55:19 <Cale> "Well, this animation is a lot slower than the particles in real life, but at least it's to scale... under a ridiculous amount of pressure."
03:55:53 <RayNbow> http://reddit.com/r/programming/info/685qy/comments/c034vbz <-- nice comment, Cale :)
03:59:26 <wagle_home> > snd (panic "aieee!", 2)
03:59:34 <lambdabot>   Not in scope: `panic'
03:59:43 <wagle_home> > snd (error "aieee!", 2)
03:59:45 <lambdabot>  2
04:00:20 <wagle_home> mmm..  sleep is winning
04:01:20 <Twey> > fst (error "too sleepy to perform even lazy evaluation", 3)
04:01:21 <lambdabot>  Exception: too sleepy to perform even lazy evaluation
04:01:39 <opqdonut> :D
04:01:46 <Twey> :-)
04:02:02 <Cale> RayNbow: thanks!
04:02:06 <Twey> It's been many an hour since I last slept too :-(
04:02:13 <wagle_home> > (1, fst (error "aieee!", 2))
04:02:14 <lambdabot>  Exception: aieee!
04:02:30 <wagle_home> > (1, (error "aieee!", 2))
04:02:32 <lambdabot>  Exception: aieee!
04:03:06 <wagle_home> shouldnt it print (1, Exception aieee!
04:03:09 <opqdonut> > error "your mom is sho fat, just blew the stack on her own!"
04:03:11 <lambdabot>  Exception: your mom is sho fat, just blew the stack on her own!
04:03:55 <wagle_home> or maybe  (1, (Exception aieee!
04:05:31 <wagle_home> error seemed more eager than i would expect, was trying to figure out how eager
04:06:56 <Saizan> wagle_home: it also depends on how lambdabot prints it
04:07:22 <Saizan> Prelude> (5,error "foo")
04:07:22 <Saizan> (5,*** Exception: foo
04:11:18 <wagle_home> yeah...
04:11:44 <wagle_home> > [1, error "aieee!", 2]
04:11:48 <lambdabot>  Exception: aieee!
04:12:30 <_frederik_> > let $([| x |]) = 5
04:12:30 <_frederik_> <interactive>:1:4: Parse error in pattern
04:12:31 <lambdabot>  Parse error at "$([|" (column 5)
04:12:37 <wagle_home> well cool..  now i gotta go off to figure out how T.H.E.Y. made exceptions referentially transparent
04:12:52 <wagle_home> gnite
04:12:57 * wagle_home sleeps
04:14:37 <_frederik_> good night
04:19:44 <b_jonas> why does irc seem so silent?
04:19:59 <wagle_home> oh i get it: lambda has to emit a line at a time instead of a char at a time..
04:20:10 * wagle_home resleeps
04:20:11 <dolio> 7 a.m. on a weekend?
04:20:39 <b_jonas> > take 5 $ show (1, (error "aieee!", 2))
04:20:49 <lambdabot>  Exception: aieee!
04:20:53 <b_jonas> > take 4 $ show (1, (error "aieee!", 2))
04:20:54 <lambdabot>  "(1,("
04:21:14 <b_jonas> uh huh
04:21:58 <Syzygy-> Is `on` defined in the libraries somewhere?
04:22:17 <b_jonas> Syzygy-: Data.Function
04:22:27 <Syzygy-> ?doc Data.Function
04:22:27 <lambdabot> Data.Function not available
04:22:41 <b_jonas> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Function.html
04:22:42 <lambdabot> http://tinyurl.com/yrwgjc
04:22:49 <Syzygy-> Thanks
04:22:53 <b_jonas> @type Data.Function.on
04:22:54 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:30:37 <daf> is there a way to find out where the instance of a type for a particular class is defined?
04:33:09 <b_jonas> daf: they say that usually it's either in the module that defines the type or the one that defines the class
04:33:17 <b_jonas> but of course this isn't always true
04:33:38 <daf> mm
04:33:56 <b_jonas> some instances are in Control.Monad.Instances
04:34:10 <daf> and there are complications for parameterised types
04:34:15 <b_jonas> (namely instance Monad ((->) a))
04:34:36 <b_jonas> yeah
04:35:10 <daf> but it would be nice to be able to ask "which modules define an instance of Monad involving Either?"
04:35:43 <Saizan> in ghci :info Class tells you the instances in scope and the module where they are defined
04:36:21 <daf> Saizan: so it does; that's useful
04:36:49 <daf> it's just confusing when things work in lambdabot but don't in ghci because you don't have the right import
04:39:15 <Syzygy-> Just import everything! MUHAHAHAHAHAHAHAHA!
04:39:22 <b_jonas> @info Monad
04:39:23 <lambdabot> Monad
04:39:30 <b_jonas> hmm
04:39:36 <daf> is the ((->) a) for parameterising on the second type rather than the first?
04:39:46 <daf> (not sure that's the right way of expressing it)
04:41:23 <olsner> it's like (a ->), so m b for m = ((->) a) becomes a -> b
04:41:47 <b_jonas> @hoogle [a -> b] -> a -> [b] -- is there a name for the specialization of sequence for functions?
04:41:48 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- is ther'
04:41:50 <desegnis> daf: they often write instance Monad ((->) r), so in the type (r -> a), a is the a of m a
04:41:58 <b_jonas> @hoogle [a -> b] -> a -> [b]
04:41:59 <lambdabot> No matches, try a more general search
04:42:10 <b_jonas> apparently no. I'll just use sequence then.
04:42:47 <b_jonas> is (a ->) even in standard haskell without ghc extensions?
04:42:53 <olsner> @hoogle m (a -> b) -> a -> m b
04:42:53 <lambdabot> Prelude.const :: a -> b -> a
04:42:53 <lambdabot> Prelude.asTypeOf :: a -> a -> a
04:42:53 <lambdabot> Prelude.seq :: a -> b -> b
04:43:02 <b_jonas> @type x :: (a ->)
04:43:09 <lambdabot> parse error on input `)'
04:43:12 <b_jonas> @kind (a ->)
04:43:13 <lambdabot> parse error on input `)'
04:43:23 <desegnis> b_jonas: map ($x) xs
04:44:04 <b_jonas> desegnis: yes, that works too
04:44:20 <daf> olsner, desegnis: hmm, interesting
04:46:18 <daf> perhaps the source for the instance of Monad for ((->) r) would clarify
04:46:50 <b_jonas> @src Monad (->)
04:46:51 <lambdabot> Source not found. Sorry.
04:46:54 <olsner> @src (->) (>>=)
04:46:54 <lambdabot> f >>= k = \ r -> k (f r) r
04:46:56 <b_jonas> @src (->) Monad
04:46:57 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:50:21 <desegnis> so (f >>= k) >>= l   =   \r -> l (k (f r) r) r
04:51:45 <desegnis> I think
04:52:50 <dolio> @pl \r -> l (k (f r) r) r
04:52:50 <lambdabot> l =<< k =<< f
04:54:56 <b_jonas> @unpl (f >>= k) >>= l
04:54:56 <lambdabot> ((f >>= k) >>= l)
04:56:35 <desegnis> daf: it is »r« as in »Reader« because it's just the Reader monad without a newtype wrapper
04:57:14 <desegnis> the domain being the »initial environment«, in Reader terminology
04:58:05 <daf> oh, hmm
05:03:51 <b_jonas> apparently the unwrapped one is even in the MonadReader class
05:04:19 <b_jonas> > (do { a <- ask; return 3 + a }) 2
05:04:22 <lambdabot>  <Plugins.Eval>:1:6:
05:04:22 <lambdabot>     Occurs check: cannot construct the infinite type: t ...
05:04:27 <b_jonas> > (do { a <- ask; return (3 + a) }) 2
05:04:29 <lambdabot>  5
05:04:39 <b_jonas> where ask is a method of MonadReader
05:05:43 <dolio> > ask 5
05:05:44 <lambdabot>  5
05:06:32 <dolio> > zipWith ask [(+5), (-5)] [4, 6]
05:06:33 <lambdabot>   add an instance declaration for (Num (a -> a))
05:06:33 <lambdabot>     In the expression: (- 5)
05:07:22 <dolio> > zipWith ask [(+5), (subtract 5)] [4, 6]
05:07:23 <lambdabot>  [9,1]
05:07:33 <daf> whee
05:08:24 <desegnis> heh
05:09:05 <Saizan> ?type asks
05:09:06 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
05:09:37 <Saizan> > zipWith asks [(+5), (subtract 5)] [4, 6]
05:09:38 <lambdabot>  [9,1]
05:09:45 <Saizan> so many names for id
05:09:51 <dolio> :)
05:10:08 <dolio> Fewer than (.), at least.
05:10:41 <Saizan> dont forget ($) :)
05:11:34 <dolio> Yeah, well, (.), fmap, liftM, (<$>), (>>>) ...
05:11:46 <gour> @seen ndm
05:11:47 <lambdabot> I haven't seen ndm.
05:11:54 <dolio> There are more, I think.
05:12:50 <Saizan> i hope not..
05:13:15 <hpaste>  Joep pasted "gnuplot script" at http://hpaste.org/5554
05:13:38 <dolio> Wow, the #haskell social network is a mess.
05:14:29 <therp> dolio: isn't that great? :)
05:15:00 <Saizan> with lambdabot in the middle :)
05:15:47 <dolio> Cale looks as strongly connected as lambdabot
05:16:05 <desegnis> > local succ succ 0
05:16:06 <lambdabot>  2
05:16:21 <dolio> Oh, right. local is (.), too.
05:16:35 <desegnis> This is fun :)
05:17:41 <hpaste>  Joep pasted "Perlscript to output timeseries data to gnuplot" at http://hpaste.org/5555
05:18:08 <b_jonas> dolio: obviously they have other instances (Reader and Readert) so they're not that superfluous
05:18:45 <dolio> I know. It's just amusing.
05:18:48 <desegnis> Maybe lambdabot shouldn't announce pastes if the associated nick isn't present on the channel...
05:19:10 <dolio> I had lambdabot evaluate a big expression with all the ones I could think of once.
05:19:30 <Saizan> hpaste /= lambdabot, but yeah
05:19:41 <desegnis> er, right
05:20:18 <Syzygy-> Damn. The index in the new library docs bogs down my firefox a LOT.
05:20:26 <desegnis> Probably the recent lambdabot update has been too present in my mind
05:22:33 <Syzygy-> ?index fix
05:22:33 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
05:23:07 <b_jonas> desegnis: there's a checkbox
05:23:15 <b_jonas> tell him to uncheck it
05:24:19 <desegnis> I mean, the imagined functionality would not require his unchecking it
05:25:03 <b_jonas> desegnis: perhaps.
05:25:29 <b_jonas> desegnis: most pastebots (erxz, lisppaste, sial) have more than once channel to choose from about where to announce
05:25:42 <b_jonas> that makes the interface more obvious than just an "announce" checkbox
05:26:06 <b_jonas> perhaps hpaste should do that too, like joining #haskell-overflow or #haskell-blah
05:27:22 <desegnis> hmyeah. still, even as long as hpaste is only present here, changing the word »announce« to »announce on #haskell« or »announce on IRC« may be good, too
05:27:43 <Syzygy-> How do I find fixpoints with set start points?
05:28:12 <Syzygy-> So I have a function f :: a -> a
05:28:16 <b_jonas> desegnis: yeah
05:28:16 <Syzygy-> And I have some p0 :: a
05:28:45 <Syzygy-> I want to find some f (f (f (f (f .... (f a))))...))) such that another application of f won't change things.
05:29:09 <dolio> There's no built-in for that.
05:29:42 <kpreid> Syzygy-: you could build that out of Prelude.until
05:30:00 <kpreid> or do it explicitly, which would probably be cleaner, actually
05:30:28 <yondalf> @hoogle Char -> Char
05:30:28 <lambdabot> Data.Char.toUpper :: Char -> Char
05:30:28 <lambdabot> Data.Char.toLower :: Char -> Char
05:30:28 <lambdabot> Data.Char.toTitle :: Char -> Char
05:30:41 <dolio> > let snarf (x:y:t) | x == y = y | otherwise = snarf (y:t) ; fix' f p0 = snarf $ iterate f p0 in fix' (/10) 1
05:30:42 <lambdabot>  0.0
05:31:07 <Syzygy-> Hah! I got it.
05:31:10 <Syzygy-> dolio: Thanks.
05:31:17 <Syzygy-> I ended up doing it explicitly.
05:31:27 <Syzygy-> I could recognize the fixed point property on the way the data works.
05:31:42 * Syzygy- just built himself linear time Huffman encoding of arbitrary lists.
05:31:53 <Syzygy-> Or ... I think it might be linear time.
05:32:01 <Syzygy-> The algorithm I built is linear time if you do it right. :)
05:32:21 <Syzygy-> (arbitrary -finite- lists)
05:32:24 <kpreid> arbitrary lists? I bet they're (Eq a) => [a] lists
05:32:33 <Syzygy-> Alright alright.
05:32:39 <kpreid> :)
05:32:39 <Syzygy-> (Ord a) => [a] finite lists.
05:32:46 <dolio> > let fix' f p0 = until (ap (==) f) f p0 in fix' (/10) 1
05:32:48 <lambdabot>  0.0
05:35:13 <dolio> > let fix' = ap (flip until) (ap (==)) in fix' (/10) 1 -- point freed
05:35:14 <lambdabot>  0.0
05:38:55 <yondalf> @info writeFile
05:38:56 <lambdabot> writeFile
05:39:01 <yondalf> @index writeFile
05:39:01 <lambdabot> System.IO, Prelude
05:39:13 <yondalf> :t writeFile
05:39:16 <lambdabot> FilePath -> String -> IO ()
05:41:34 <dolio> kpreid++
05:44:44 * desegnis failed once again to compile lambdabot
05:45:01 <b_jonas> Syzygy-: as for that fix thing, that can be good in some cases, but in many numerical examples you'd want to also detect cycles or do a tolerant comparision or else fix' might never find you a convergence
05:45:11 <b_jonas> (or an upper limit on iterations)
05:45:57 <Syzygy-> b_jonas: In this particular case, I know that I will reach a fix point in finite time, and that this fixpoint is what I'm looking for.
05:46:05 <Syzygy-> So loop detection is fixpoint detection for this particular case.
05:46:13 <Corun> I tried to compile lambdabot once
05:46:23 <Corun> It's hard as expletive
05:46:29 <b_jonas> Syzygy-: sure
05:47:41 <desegnis> Corun: The repository has updates for ghc 6.8.2, but still, I'll get only the familiar »Terminated.« when I want it to do something useful
05:50:38 <desegnis> D'oh! I should start and actually read README files
05:50:59 <b_jonas> lol
05:52:01 <b_jonas> good thing the name README is more or less standardized now
05:52:31 <b_jonas> back in the good old days, we used to have README.DOC, README.TXT, READ.ME, README, README.1ST, 00README.*
05:53:08 <yondalf> :t either
05:53:10 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:53:24 <yondalf> @src either
05:53:25 <lambdabot> either f _ (Left x)     =  f x
05:53:25 <lambdabot> either _ g (Right y)    =  g y
05:55:40 <yondalf> @src system
05:55:40 <lambdabot> Source not found. My pet ferret can type better than you!
05:55:58 <dolio> @src (->) (|||)
05:55:59 <lambdabot> Source not found. I feel much better now.
06:00:46 * desegnis will finally give up on lambdabot for today
06:16:11 <wolverian> b_jonas, I've seen projects with README.1ST _and_ README.TXT, with different contents
06:16:47 <b_jonas> wolverian: yeah, those exist
06:16:52 <b_jonas> usually different owners
06:24:28 <Twey> desegnis: You'd better, or she'll set her pet ferret on you
06:25:34 <olsner> "lambdabot - irc bot and ferret wrangler"
06:56:10 <catface> instance Show (a -> b) where
06:56:18 <catface>    show f = show (typeOf f)
06:56:46 <catface> > instance Show (a -> b) where show f = show (typeOf f)
06:56:46 <lambdabot>  Parse error at "insta..." (column 1)
07:08:37 <Twey> @src concatMap
07:08:37 <lambdabot> concatMap f = foldr ((++) . f) []
07:13:34 <desegnis> concatMap = (>>=)
07:15:30 <Twey> Aye
07:16:11 <dolio> @type (=<<)
07:16:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:16:21 <dolio> @type concatMap
07:16:22 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:24:09 <desegnis> alright, (=<<), not (>>=).
07:29:11 <Twey> (=<<) == flip (>>=) ?
07:29:33 <LoganCapaldo> yeeeeeeeeeeeeeez
07:29:49 <b_jonas> what exactly are the strictness semantics of Array and UArray ? They're not strict in bounds, are they?
07:31:51 <desegnis> b_jonas: UArray is strict in its elements, that is, the whole array is constructed all at once, without any computation lazily deferred
07:32:14 <b_jonas> desegnis: but it can have the values computed but not the bounds, right?
07:32:56 <LoganCapaldo> @type bounds
07:32:59 <desegnis> hmm... I suppose it needs the bounds to be able to be strict in its elements
07:33:00 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
07:33:22 <b_jonas> desegnis: ah yes, indeed that would make sense
07:33:39 <b_jonas> for it needs to calculate the size and allocate that much memory
07:33:52 <LoganCapaldo> why would you want the bounds to be lazy?
07:33:55 <b_jonas> whereas Array might still be lazy about the bounds I guess
07:34:01 <b_jonas> LoganCapaldo: I want them to be strict
07:34:14 <b_jonas> but as they can be complicated objects, I'm not sure
07:34:18 <b_jonas> I mean, anything can be an Ix
07:34:51 <b_jonas> so it's probably just strict in them as much that it calls its rangeSize
07:35:17 <desegnis> I'm not sure whether the bounds could be lazy in any way. What could you do with an array of unknown bounds? You couldn't even look up an element
07:35:59 <desegnis> Because you wouldn't know whether you look out of bounds
07:36:08 <b_jonas> desegnis: you could query its elems which returns a list and get the first few elements
07:36:36 <b_jonas> but even for that it needs to know the rangeSize of the bounds so it wouldn't give too many elements
07:36:46 <LoganCapaldo> or too few
07:36:47 <dolio> You couldn't even allocate an array of unknown bounds.
07:36:51 <desegnis> b_jonas: What is the »first« element if you do not know the array size?
07:37:05 <desegnis> er, ... array bounds
07:37:17 <b_jonas> desegnis: if you construct it with listArray, then it's the first element of the list
07:37:28 <b_jonas> unless the bounds is empty in which case the first element is bottom
07:38:02 <desegnis> > listArray (0,-1) ['a','b','c'] !! 0
07:38:04 <lambdabot>  Couldn't match expected type `[a]'
07:38:07 <desegnis> > listArray (0,-1) ['a','b','c'] ! 0
07:38:09 <lambdabot>  Exception: Error in array index
07:38:13 <desegnis> see?
07:38:36 <b_jonas> no, not that way
07:38:37 <desegnis> Well an empty array may seem stupid, but it exists
07:38:58 <b_jonas> > head $ elems $ listArray (0,-1) "abc"
07:39:01 <b_jonas> that way
07:39:01 <lambdabot>  Exception: Prelude.head: empty list
07:39:29 <b_jonas> so because of empty arrays, it has to query rangeSize
07:39:43 <desegnis> b_jonas, but then the »first« element would not equal the element at the lower bound
07:39:43 <b_jonas> which may have whatever strictness on the bounds
07:40:04 <b_jonas> Deewiant: sure
07:40:09 <b_jonas> argh
07:40:12 <b_jonas> desegnis: syre
07:40:19 <b_jonas> I dunno
07:40:21 <desegnis> The array would be empty and wouldn't at the same time
07:40:34 <b_jonas> I think it has to return bottom in this case
07:40:45 <b_jonas> so it has to be strict on the bounds this much
07:41:02 <desegnis> right, that's the same what I think, and so it is :)
07:41:11 <b_jonas> the first index might not be equal to the lower bound for arbitary Ixes anyway
07:42:38 <desegnis> b_jonas, I think a good intuition about arrays in functional languages is to think of them as functions from indices to elements
07:43:11 <b_jonas> desegnis: does that help here when I want to know about the bounds?
07:43:32 <b_jonas> not really related is this question:
07:43:42 <desegnis> If you think of them this way, you wouldn't want elems to return anything for which there's no index
07:43:46 <b_jonas> is there a library that provides an UArray for Complex Double?
07:44:10 <b_jonas> desegnis: oh sure
07:44:58 <desegnis> because elems is like the function range then
07:49:16 <desegnis> Not sure about such a library. I'd imagine the implementation to be relatively straight-forward, but since there isn't an instance either for, say, UArray (Double,Double) or UArray (Int,Int), I'm unsure again
07:51:26 <dolio> You could make one, but it'd be a bit of a pain.
07:51:45 <b_jonas> desegnis: the problem is that IArray doesn't have an open interface so you can't just implement it using UArray Double without knowing ghc internals
07:52:01 <dolio> UArrays are all the same internally, they just wrap a ByteArray with some indices.
07:52:30 <dolio> And the particular instance determines how things get looked up in the raw byte array.
07:54:43 <dolio> And then, all sorts of crazy RULEs so the compiler optimizes stuff. :)
07:58:43 <b_jonas> I don't get why we don't have Arrays and UArrays and IOArrays that are indexed by zero-based Ints and then wrappers over them that allow arbitary Ix indices and behave just like the current *Arrays
08:02:27 <sarehu> *it is a mystery*
08:25:12 <puika> http://lostworlds.lv/go.php?1139637493
08:35:15 <gwern> hm. in a cabal file, how does one add options to the automatic application of hsc2hs to an hsc file?
08:39:08 <gwern> (specifically, I need to run hsc2hs with the -D_FILE_OFFSET_BITS=64 flag, but adding it to ghc-options: doesn't seem to work)
08:45:31 <gwern> hm. could 'cc-options:' be the answer?
08:46:53 <LoganCapaldo> seems like a good bet
08:47:20 <gwern> now I need to select on architecture. hope cabal has a predicate for that...
08:47:29 <allbery_b> if arch(...)
08:48:16 <pejo> gwern, on *architecture*?
08:48:58 <gwern> yes, specifically x86_64 vs i386
08:49:08 <gwern> (it's because of hfuse's C binding)
08:49:42 <oerjan> wouldn't that usually be done with cpp in a module file?
08:50:04 * gwern wouldn't know
08:51:01 <oerjan> at least the library files seem littered with cpp, although i've only really noticed selections on compiler
08:52:12 * gwern doesn't like CPP for some reason
08:52:59 <johnnowak> i have plenty of reasons
08:53:28 * monochrom continues his craziness.
08:53:54 <dolio> monochrom: What are you using C.M.C.Cursor for?
09:02:09 <darrint> Is there a way to convert a "raw" socket to a handle?
09:02:36 <LoganCapaldo> @hoogle Socket -> Handle
09:02:37 <lambdabot> No matches, try a more general search
09:02:40 <hpaste>  monochrom pasted "Cursor, yield, next" at http://hpaste.org/5556
09:02:58 <monochrom> dolio: That one. There will be more forthcoming.
09:03:35 <monochrom> (forthcoming in the next several days.)
09:05:51 <allbery_b> darrint: not sure about windows but on unix System.IO.POSIX.fdToHandle
09:05:51 <oerjan> @hoogle Socket -> FD
09:05:53 <lambdabot> No matches, try a more general search
09:06:05 <allbery_b> er, .Posix.
09:06:05 <oerjan> @hoogle FD -> Socket
09:06:08 <oerjan> argh
09:06:08 <lambdabot> No matches, try a more general search
09:06:12 <oerjan> @hoogle FD -> Handle
09:06:13 <lambdabot> No matches, try a more general search
09:06:21 <allbery_b> :t System.IO.Posix.fdToHandle
09:06:21 <oerjan> oops
09:06:23 <lambdabot> Couldn't find qualified module.
09:06:26 <allbery_b> hm
09:06:34 <oerjan> @hoogle fdToHandle
09:06:35 <lambdabot> No matches found
09:06:54 <allbery_b> oh, gort it reversed
09:07:04 <allbery_b> :t System.Posix.IO.fdToHandle
09:07:05 <darrint> Maybe a better question is, can I make the Network.Socket module cooperate with bytestream?
09:07:06 <lambdabot> System.Posix.Types.Fd -> IO GHC.IOBase.Handle
09:07:21 <oerjan> @hoogle Fd -> Handle
09:07:22 <lambdabot> No matches, try a more general search
09:07:23 <dolio> monochrom: Interesting. Glad to know it's useful. :)
09:07:45 <oerjan> there's a hole in my hoogle, dear liza, a hole
09:08:13 <allbery_b> there's already a package for that, network-bytestring on hackage
09:13:51 <darrint> @hoogle socketToHandle
09:13:52 <lambdabot> No matches found
09:15:24 <darrint> It's listed in network.socket. weird.
09:15:50 <oerjan> @version
09:15:51 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
09:15:51 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:16:06 * oerjan does a little dance
09:16:10 <oerjan> and a Cale++
09:16:50 <trofimovich> > sum [0,0..]
09:16:58 <lambdabot> Terminated
09:17:10 <monochrom> > let !x = 1 in x
09:17:11 <lambdabot>  Parse error at "!x" (column 5)
09:18:18 <allbery_b> darrint: did you catch my comment about the network-bytestring package?
09:18:56 <darrint> allbery_b: Yeah. I should look at that next. Btw, I found socketToHandle in Network.Socket. From there I can just use bytestring io methods right?
09:19:08 <allbery_b> hopefully yes
09:19:36 <darrint> For some reason socketToHandle is not shown in the documentation, only the source code.
09:27:49 <oerjan> monochrom: i think Language.Haskell gives that error message.  also > may not have the necessary extension set in any case (somewhere i read only extended defaults are enabled)
10:11:32 <hpaste>  pastorNC pasted "HGL & usleep arn't best friends" at http://hpaste.org/5558
10:12:45 <Lemmih> pastorNC: Tried threadDelay?
10:19:03 <pastorNC> Lemmih: *testing*
10:19:59 <hpaste>  thetallguy annotated "HGL & usleep arn't best friends" with "(no title)" at http://hpaste.org/5558#a2
10:24:43 <pastorNC> Lemmih, thetallguy: threadSleep sorta worked, but i got a great flashback from windows 9x, the window was drawing the graphics only when it had activity, so moving the mouse over it made it draw. not doing anything left it in stasis
10:25:56 <Lemmih> pastorNC: -threaded might help.
10:26:05 <pastorNC> ?
10:26:26 <Lemmih> pastorNC: It's a GHC flag.
10:26:39 <pastorNC> is there a way to force GHCI to use it?
10:26:57 <Lemmih> Hm, it's on by default in GHCi.
10:28:05 <Akrillo> hi all, sb can help me with a little problem ?
10:28:44 <oerjan> Akrillo: ask away
10:29:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5559
10:29:35 <Akrillo> here u can see a function for a while loop , can sb give me a simple example how to use it ? http://hpaste.org/5559
10:29:43 <Akrillo> like a addition where the result must be 10
10:31:00 <oerjan> Akrillo: you need to use mutable variables for that to be very useful i think
10:31:24 <Akrillo> mh .. my proffessor said i should use this function to create while loops...
10:31:27 <oerjan> otherwise the test and action will have a hard time influencing each other
10:31:55 <Lemmih> > until (==10) (+1) 0
10:31:56 <lambdabot>  10
10:32:10 <Deewiant> @ty until
10:32:12 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
10:32:14 <thetallguy> pastorNC, are you running that program in ghci?
10:32:30 <oerjan> Akrillo: it's rather rare to use such a loop in haskell
10:32:35 <thetallguy> pastorNC: if so, you might try compiling it to see if the behavior changes.
10:32:49 <Akrillo> oerjan: yes but i must find a way ! ...
10:33:12 <oerjan> Akrillo: you can use IORefs for mutable variables
10:33:37 <Akrillo> can u give me an example `
10:33:38 <oerjan> then you can write an imperative loop like in other languages with your while
10:33:40 <Akrillo> ?
10:33:40 <pastorNC> thetallguy: changed from 6.4 to 6.6.1, now it works properly :)
10:34:50 <monochrom> I don't understand why some teacher teaches Haskell using imperative programming habits.
10:34:58 <Akrillo> need a good while loop that start a function till the result is true.
10:35:08 <Akrillo> u have one ? ^^
10:35:15 <oerjan> while (liftM (/= 10) $ readIORef myVar) (modifyIORef myVar (+1))
10:35:16 <Deewiant> @src until
10:35:28 <lambdabot> until p f x | p x       = x
10:35:28 <lambdabot>             | otherwise = until p f (f x)
10:35:57 <Akrillo> ok, wait i will try
10:36:05 <sarehu> well, Haskell _is_ a good imperative programming language :/
10:36:13 <oerjan> you need to define myVar with newIORef outside the loop
10:36:15 <thetallguy> pastorNC: that would do it.
10:36:17 <Akrillo> :( i am not a friend of haskell =D
10:36:24 <monochrom> But no one writes a while loop that way.
10:36:49 <Akrillo> u know the book "The craft of functional Programming" ~Somin Thompson ?
10:37:21 <Akrillo> Thompson give this function for a while loop... and our proff said we should use it :(
10:40:39 <Akrillo> mh... i can't use until because i need inputs
10:41:33 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5560
10:42:02 <Akrillo> check this : http://hpaste.org/5560  , palindrom is my function . but i must give inputs till it is true
10:42:06 <oerjan> Akrillo: my example works, it increments myVar until it is 10
10:42:22 <Akrillo> mh i try mom
10:43:48 <Akrillo> Main>  while (liftM (/= 10) $ readIORef myVar) (modifyIORef myVar (+1))
10:43:48 <Akrillo> ERROR - Undefined variable "myVar"
10:44:10 <oerjan> Akrillo: i told you above what you needed to do
10:44:28 <Akrillo> ahhh sry.
10:45:05 <b_jonas> how do you usually space : when it means the list constructor?
10:45:23 <oerjan> you also need to import Data.IORef and Control.Monad
10:45:54 <gour> @seen ndm
10:45:54 <lambdabot> I haven't seen ndm.
10:46:21 <S9> Can anyone suggest a good Haskell IDE for Linux that is compatible with GHC? (right now I am using the ghci and Kdevelop)
10:46:40 <S9> ^sorry im learning haskell for the first time...
10:46:55 <cjb> S9: many people here use emacs.
10:46:55 <b_jonas> that is, do you put a space before it and do you put a space after it when both arguments are on the same line?
10:47:07 <Deewiant> b_jonas: depends on the situation
10:47:20 <S9> cjb: is there an emacs plugin (sorry forget what emacs calls it) for haskell
10:47:42 <b_jonas> I'd guess it's called haskell-mode
10:47:43 <Deewiant> if it's something short like f x y = f (x:y) y I don't space it, but if x or y are longer I generally put spaces around the :
10:47:55 <b_jonas> Deewiant: I see
10:48:02 <pgavin> @google haskell-mode
10:48:03 <lambdabot> http://www.haskell.org/haskell-mode/
10:48:03 <lambdabot> Title: Haskell Mode for Emacs
10:48:10 <S9> thanks pgavin
10:48:26 <pgavin> np
10:48:32 <b_jonas> (that example looks like a type error)
10:48:42 <b_jonas> @type let f x y = f (x:y) y in f
10:48:48 <Deewiant> it probably is :-P
10:48:56 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
10:48:56 <lambdabot>       Expected type: [a] -> [a] -> t
10:48:56 <lambdabot>       Inferred type: a -> [a] -> t
10:49:09 <b_jonas> yeah, that's not what's important here
10:49:10 <Deewiant> @type let f x y = f y (x:y) in f
10:49:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
10:49:11 <lambdabot>       Expected type: [a] -> [a] -> t
10:49:11 <lambdabot>       Inferred type: a -> [a] -> t
10:49:50 <Deewiant> b_jonas: yeah, it was just an example. if they're just variables with meaningless names as in the above, no spaces
11:01:05 <dons> ?users
11:01:05 <lambdabot> Maximum users seen in #haskell: 448, currently: 448 (100.0%), active: 17 (3.8%)
11:01:09 <dons> ?version
11:01:09 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
11:01:10 <lambdabot> darcs get http://code.haskell.org/lambdabot
11:01:14 <dons> awesome
11:01:26 <dons> great work Cale.
11:01:35 <oerjan> > on
11:01:51 <lambdabot>  thread killed
11:01:58 <dons> interesting
11:02:00 <dons> > 1+2
11:02:02 <lambdabot>  3
11:02:05 <oerjan> > on
11:02:06 <lambdabot>  Add a type signature
11:02:07 <Deewiant> @ty on
11:02:08 <lambdabot> Not in scope: `on'
11:02:13 <dons> :t Data.Function.on
11:02:14 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:02:21 <oerjan> @undefine
11:02:24 <lambdabot> Undefined.
11:02:27 <Deewiant> > on
11:02:28 <lambdabot>   Not in scope: `on'
11:02:41 <dons> not imported yet
11:02:49 <oerjan> bah
11:02:55 <LoganCapaldo> > Data.Function.on
11:02:56 <lambdabot>   Not in scope: `Data.Function.on'
11:03:10 <LoganCapaldo> :m +Data.Function
11:03:16 <LoganCapaldo> :P
11:03:23 <dons> would be a bit unsafe
11:03:31 <LoganCapaldo> indeed
11:03:41 <dolio> > fix (1:)
11:03:51 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:04:00 <Deewiant> O_o
11:04:01 <monochrom> holy batman
11:04:03 <dolio> Huh.
11:04:04 <dons> ok. so some missing stuff
11:04:06 <dons> h98 package
11:04:15 <fax> Hello :)
11:04:26 <LoganCapaldo> > fix fix
11:04:27 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
11:04:27 <lambdabot>     Probabl...
11:04:41 <Deewiant> > fix id
11:04:42 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:04:53 <LoganCapaldo> > fix (fix .)
11:04:54 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
11:04:54 <lambdabot>     Probabl...
11:04:58 <oerjan> > fix (const 2)
11:04:59 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:05:03 <oerjan> > 2
11:05:05 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:05:09 <monochrom> holy batman
11:05:13 <LoganCapaldo> oh noes
11:05:19 <fax>  What function would fix fix be?
11:05:22 <oerjan> > 1+2
11:05:25 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:05:25 <Deewiant> it broke :-(
11:05:28 <oerjan> @undef
11:05:29 <lambdabot> Undefined.
11:05:31 <oerjan> > 1+2
11:05:32 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:05:38 <oerjan> eek
11:05:40 <Deewiant> :-(
11:05:48 <LoganCapaldo> @reboot
11:05:48 <lambdabot> Unknown command, try @list
11:05:51 <olsner> buttttttt ittttt handllllles type errrrrrors, so     you'll just have to write   everything in    the type system tooooday
11:05:54 <Saizan> oerjan: your @undefine have uncovered the bug :)
11:06:01 <oerjan> it seems so
11:06:03 <monochrom> hahahaha
11:06:04 <olsner> (argh, computer broken)
11:06:32 <olsner> (rather, disk latency(?)+new xorg+keyrepeat = fail)
11:06:34 <LoganCapaldo> olsner is cleary communiating to us from a region of slow time
11:06:34 <fax> what's new in Types?
11:06:53 <monochrom> olsner is going into a blackhole
11:07:08 <oerjan> olsner: wait, you mean it wasn't on purpose?
11:07:50 <olsner> oerjan: nope, that     was just me typing  normally
11:07:59 <oerjan> although i admit i did find it hard to get the joke :D
11:08:00 <olsner> whhhhile compiling a kernel
11:08:17 <olsner> :D
11:08:17 <monochrom> @remember olsner [concerning malfunctioning lambdabot] buttttttt ittttt handllllles type errrrrrors, so     you'll just have to write   everything in    the type system tooooday
11:08:18 <lambdabot> Done.
11:08:57 <olsner> "slow day today, eh?"
11:09:16 <oerjan> @let x = "test
11:09:16 <lambdabot>  Improperly terminated string
11:09:20 <oerjan> @let x = "test"
11:09:21 <lambdabot> Defined.
11:09:23 <Deewiant> > x
11:09:24 <lambdabot> Terminated
11:09:31 <oerjan> > 1+2
11:09:32 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:10:05 <oerjan> @let y = "hm..."
11:10:07 <lambdabot> Defined.
11:10:08 <idnar> hahaha
11:10:08 <oerjan> > y
11:10:09 <lambdabot> Terminated
11:10:22 <monochrom> doubleplusungood
11:10:29 <Deewiant> > x ++ y
11:10:29 <lambdabot> Terminated
11:11:30 <dons> so the error messages aren't matching quite the same with 6.8
11:12:00 <oerjan> Terminated used to mean there were conflicting definitions, sometimes
11:13:28 <sclv> ?ty 1 + 2
11:13:29 <lambdabot> forall t. (Num t) => t
11:13:36 <sclv> ?ty fix fix
11:13:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
11:13:37 <lambdabot>     Probable cause: `fix' is applied to too many arguments
11:13:37 <lambdabot>     In the first argument of `fix', namely `fix'
11:13:42 <sclv> ?ty fix (1:)
11:13:43 <lambdabot> forall t. (Num t) => [t]
11:13:43 <oerjan> @check 1+1 == 2
11:13:44 <lambdabot>  quickcheck: setResourceLimit: invalid argument (Invalid argument)
11:13:55 <sclv> @quote
11:13:56 <lambdabot> autrijus says: Woot. I got larry wall started learning Haskell ;)
11:14:04 <monochrom> haha
11:14:12 <sarehu> Cale: ping   you need to fix the other setResourceLimits :P
11:14:14 <dons> ah, the rlimit bug too
11:14:20 <oerjan> @check \x -> x == 2
11:14:21 <lambdabot>  quickcheck: setResourceLimit: invalid argument (Invalid argument)
11:14:54 <oerjan> @scheck \x -> x == 2
11:14:55 <lambdabot> smallcheck: setResourceLimit: invalid argument (Invalid argument)
11:15:09 <sarehu> > 2
11:15:11 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:15:14 <sarehu> > 2 + 3
11:15:15 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
11:15:18 <sarehu> holy
11:15:24 <fax> looks like the bot isn't working.....
11:15:39 <oerjan> @check x == 2
11:15:40 <lambdabot>  quickcheck: setResourceLimit: invalid argument (Invalid argument)
11:15:45 <oerjan> @check z == 2
11:15:45 <lambdabot>  quickcheck: setResourceLimit: invalid argument (Invalid argument)
11:16:16 <oerjan> ack
11:16:26 <sclv> syn
11:16:52 <olsner> error: inverted tcp handshake
11:17:16 <fax> Is there haskell/twelf stuff?
11:17:19 <oerjan> @vixen Are you not feeling well?
11:17:20 <lambdabot> first you tell me.
11:17:59 <hpaste>  piojo pasted "heap toy example (broken)" at http://hpaste.org/5561
11:18:00 <sclv> > @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
11:18:01 <lambdabot>  Parse error at "@bf" (column 1)
11:18:04 <sclv> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
11:18:04 <lambdabot>  fd:17: hClose: resource vanished (Broken pipe)
11:18:13 <sclv> ^^ worst of all!
11:18:23 <oerjan> @slap sclv
11:18:24 * lambdabot smacks sclv about with a large trout
11:18:29 <piojo> hello. Does anybody here use the (new) heap library?  might someone be able to tell me why I'm having no luck using a custom heapOrdering?
11:18:38 <oerjan> that error's been there as long as i've been here
11:18:50 <piojo> i pasted a something at http://hpaste.org/5561
11:18:51 <sclv> oerjan: well, at least we know that that works.
11:21:10 <sclv> @pl \x -> x + x
11:21:11 <lambdabot> join (+)
11:21:13 <sclv> @free foldr
11:21:14 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
11:21:30 <oerjan> @djinn a -> a -> a
11:21:30 <lambdabot> f _ a = a
11:21:49 <oerjan> @pl 1+2
11:21:50 <lambdabot> 3
11:21:56 <sclv> @djinn a -> Either a b -> (a->b) -> b
11:21:56 <lambdabot> f a b c =
11:21:56 <lambdabot>     case b of
11:21:56 <lambdabot>     Left d -> c d
11:21:56 <Deewiant> @undo do return ()
11:21:57 <lambdabot>     Right _ -> c a
11:22:00 <lambdabot> return ()
11:23:54 <sclv> @hoogle Int -> Int -> Int
11:23:55 <lambdabot> Data.Time.Calendar.MonthDay.monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
11:24:33 <fax> So nobody is using Twelf in any haskell projects?
11:24:36 <sclv> @faq can Haskell fix lambdabot?
11:24:36 <lambdabot> The answer is: Yes! Haskell can do that.
11:25:39 <Lemmih> piojo: You're supposed to replace MinPolicy.
11:26:11 <piojo> Lemmih: replace... how do I do that?
11:26:51 <piojo> do you mean i actually need to define a new heap type that is an instance of MinHeap?
11:27:07 <piojo> hmm, MinHeap may not be a class...
11:27:25 <Lemmih> piojo: I don't see what you're trying to do.
11:28:19 <Lemmih> piojo: You want a heap of tuples that sorts by the first member?
11:28:24 <piojo> yes
11:28:42 <piojo> Lemmih: but the problem is that i won't know what type the second member is, so i can't declare it to be part of Ord
11:29:11 <piojo> that's why i wanted to declare a custom ordering that wouldn't care about the second element
11:29:39 <fax> Just make a new data type
11:29:47 <fax> Instead of using tuple
11:30:11 <piojo> fax: that's a good idea
11:34:50 <Lemmih> It can also be done with a policy.
11:34:53 <hpaste>  Lemmih annotated "heap toy example (broken)" with "Tuple policy." at http://hpaste.org/5561#a1
11:36:18 <piojo> Lemmih: that's what you meant when you said i needed to replace the policy?
11:36:41 <hpaste>  Lemmih annotated "heap toy example (broken)" with "Fix minor issue." at http://hpaste.org/5561#a2
11:36:48 <Lemmih> piojo: Yes.
11:37:18 <piojo> Lemmih: what's the tilde for?
11:38:28 <piojo> nevermind, i think i found the answer on the wiki
11:38:37 <Zao> Which is?
11:39:29 <Lemmih> Zao: It's too strict without the tilde. The tuple policy doesn't really exist. It's purely imaginary.
11:40:02 <piojo> oh. Zao, I'm glad you asked, my understanding was incorrect ;)
11:40:07 <Cale> heh, oops :)
11:40:17 <Cale> I'm on it :)
11:41:11 <glen_quagmire> what's a proper way to do printf in  haskell? Text.Printf ?
11:41:34 <Cale> That, or just concatenate strings constructed with show
11:41:37 <glen_quagmire> i mean, i want to return formatted string
11:41:38 <Lemmih> glen_quagmire: Text.Printf is not the best way, it's just the only way.
11:41:57 <b_jonas> glen_quagmire: there are some functions in the Numeric module
11:42:01 * glen_quagmire concats
11:42:06 <b_jonas> which allow you to print doubles in any format
11:42:08 <fax> I like this http://www.lri.fr/perso/~sozeau/repos/coq/misc/shiftreset/GenuineShiftReset.html
11:42:08 <fax> I would use this instead
11:42:09 <lambdabot> Title: GenuineShiftReset, http://tinyurl.com/2ywh6h
11:42:39 <glen_quagmire> "Hey, %(name)s!!" % {"name": userInput}    would be nice
11:43:06 <b_jonas> both Numeric and Printf shares some problems though (I think Printf is implemented using Numeric)
11:43:13 <doserj> there is a string template library
11:43:38 <b_jonas> I've no idea how to fix that unless by defining your own functions
11:43:46 <fax> ret "The value of " ^ fmt str ^ ret " is " ^ fmt int  -- looks nice to me....
11:44:10 <piojo> Lemmih: thanks a lot. But this sort of thing isn't documented anywhere, unless I'm mistaken. would your solution have been obvious to somebody who knows more haskell than me?
11:44:16 <b_jonas> in fact I have wrote a custom numeric printer because Numeric is broken, but mine isn't really general, it just allows one certain format
11:44:21 <glen_quagmire> :t (^)
11:44:23 <piojo> Lemmih: I just wonder whether this should be documented somewhere...
11:44:24 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:44:33 <fax> glen, nah, check my link
11:44:48 <glen_quagmire> ah
11:44:59 <Lemmih> piojo: Well, I have no previous experience with heap.
11:45:09 <b_jonas> glen_quagmire: um, what kind of syntax is that?
11:46:10 <Lemmih> piojo: :browse is my main documentation viewer. A lot of information can be read from the types.
11:46:10 <piojo> Lemmih: well, i guess i have a lot to learn. thanks a lot!
11:46:26 <glen_quagmire> b_jonas: that's just python.  {id: value} is hashtable. and %(named_text_format_parameter)s   is a %s, but named
11:46:40 <b_jonas> glen_quagmire: yeah, I was wondering about that hash table thing
11:46:50 <b_jonas> because you could use % as a formatting operator in haskell
11:46:59 <b_jonas> (stealing from python like ruby does)
11:47:11 <b_jonas> but there's no way to have a hash table syntax like that
11:47:14 <daf> you could easily implement "foo %(bar)" % [("bar", hello")]
11:47:25 <fax> Dunno why you would..
11:47:27 <b_jonas> yep
11:47:35 <fax> There's a type safe sprintf there
11:47:43 <daf> indeed
11:47:49 <b_jonas> but you'd have a problem with mixed types
11:47:51 <fax> if you want to futz about with strngs..
11:48:06 <b_jonas> I mean, [("bar", "hello"), ("quux", 1)] is a type error
11:48:07 <glen_quagmire> fax: type safe sprintf refers to the lnk you gave me?
11:48:15 <fax> perl maybe?
11:48:20 <fax> :p
11:48:22 <daf> stuff like %(foo) is friendlier to, say, translators
11:48:32 <fax> What's a translator?
11:48:33 <daf> since it makes reordering interpolations easier
11:48:38 <daf> somebody who translates
11:48:52 <fax> ok just checking you didn't mean a compiler
11:49:01 <daf> :)
11:50:24 * Cale recompiles stuff...
11:53:55 <Cale> @scheck \x -> x == 2
11:53:56 <lambdabot> Add a type signature
11:54:03 <Cale> @scheck \x -> (x :: Int) == 2
11:54:04 <lambdabot> smallcheck: /tmp/MSITA11838.o: unknown symbol `__stginit_haskell98_Char_'
11:54:04 <lambdabot> sma...
11:54:07 <Cale> okay
11:54:50 <b_jonas> daf: yeah, though there's always that dollar-sign number syntax for printf
11:55:05 <daf> b_jonas: right, but I think it's harder to use
11:55:12 <b_jonas> yep
11:55:28 <b_jonas> otoh for me, the writer of the program, it's easier
11:55:36 <b_jonas> for I don't have to mess with giving all the names
11:55:40 <OceanSpray> :t parse
11:55:41 <lambdabot> Not in scope: `parse'
11:55:41 <daf> mm, tradeoff
11:55:44 <desegnis_> I guess that printf-like type hackery could give us  "foo %(bar) %(baz)" % ("bar", "hello") % ("baz", 1)
11:56:01 <oerjan> :t Text.ParserCombinators.Parsec.parse
11:56:02 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
11:56:03 <b_jonas> desegnis_: actually, I don't want a real printf
11:56:06 <olsner> bos: how do you get the llvm-c bindings? are they included in llvm 2.1?
11:56:07 <Deewiant> why not use a list as the second argument?
11:56:07 <OceanSpray> :t import Text.ParserCombinators.Parsec.parse
11:56:08 <lambdabot> parse error on input `import'
11:56:14 <b_jonas> I just want to be able to format numbers
11:56:14 <OceanSpray> :t Text.ParserCombinators.Parsec.parse
11:56:14 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
11:56:19 <b_jonas> but in the right way
11:56:53 <desegnis_> b_jonas, well I was just thinking
11:57:04 * Cale blasts away crusty old module imports.
11:57:13 <oerjan> Deewiant: not well-typed
11:57:20 <b_jonas> desegnis: sure, others need a string templating thing too
11:57:28 <Cale> @scheck \x -> (x :: Int) == 2
11:57:31 <Deewiant> oerjan: doh, good point
11:57:34 <lambdabot>   Failed test no. 1. Test values follow.: 0
11:57:38 <Cale> good...
11:57:38 <Deewiant> > 1+1
11:57:40 <lambdabot>  2
11:57:45 <Deewiant> > fix
11:57:46 <lambdabot>  Add a type signature
11:58:00 <Cale> > 2 + 3
11:58:01 <lambdabot>  5
11:58:02 <Deewiant> > fix (1:)
11:58:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:58:04 <sarehu> "hello world" -- "world"
11:58:11 <sarehu> > "hello world" -- "world"
11:58:12 <lambdabot>  "hello world"
11:58:13 <Deewiant> seems to work
11:58:14 <sarehu> still broken
11:58:16 * fax is still trying to think of a meaning for fix fix
11:58:32 <fax> sarehu: Broken how?
11:58:35 <sarehu> ^_^
11:58:43 <fax> oh I get it
11:58:46 <fax> heh..
11:58:49 <Deewiant> he's trying to be funny :-P
11:59:09 <oerjan> Cale: a suggestion, could you add hiding (pure) to the Control.Arrow import?
11:59:13 <Cale> sure
11:59:51 <Cale> one thing which I really don't understand is all the duplication of imports between L.hs and RunPlugs/etc.
12:00:25 <sclv> > 1 + 1
12:00:26 <lambdabot>  2
12:00:46 <b_jonas> oerjan: why? what does it clash with?
12:00:57 <b_jonas> @type fix fix
12:00:58 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
12:00:58 <lambdabot>     Probable cause: `fix' is applied to too many arguments
12:00:58 <lambdabot>     In the first argument of `fix', namely `fix'
12:01:01 <fax> What's the shortest possible haskell program that produces every binary string of some alphabet?
12:01:02 <dolio> fix fix is _|_, no (ignoring types)?
12:01:09 <oerjan> yeah, there is a lot of inconsistency, like M vs. Data.Map
12:01:13 <Cale> b_jonas: pure from Control.Applicative
12:01:22 <Deewiant> @ty pure
12:01:23 <lambdabot>     Ambiguous occurrence `pure'
12:01:23 <lambdabot>     It could refer to either `Control.Applicative.pure', imported from Control.Applicative
12:01:23 <lambdabot>                           or `Control.Arrow.pure', imported from Control.Arrow
12:01:24 <fax> dolio, How do you come to that conclusion?
12:01:36 <oerjan> b_jonas: also, it has the synonym arr so hiding it is no big matter
12:01:47 <dolio> fax: Well, fix fix is some function f such that fix f = f.
12:01:52 <b_jonas> dolio: isn't "ignoring types" like when you ignore dimensions because you only need the ballpark?
12:02:12 <b_jonas> or do you mean when you allow circular types with that compiler flag?
12:02:14 <Cale> oh, damn, Type.hs :)
12:02:15 <Deewiant> > 1+1
12:02:16 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
12:02:17 <fax> I thought.. fix f = f (fix f)
12:02:26 <Cale> uhh...
12:02:31 <Deewiant> died again :-/
12:02:34 <dolio> And _|_ is the least defined function, and fix _|_ = _|_, right?
12:02:39 <fax> not sure where fix f = f comes from?
12:02:41 <Cale> How'd that come back?
12:02:57 <OceanSpray> :t Control.Monad.Error.runErrorT
12:02:57 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
12:03:00 <sclv> Cale: I was testing lets and undefines in privmsg
12:03:05 <monochrom> > map (showIntAtBase 2 show "") [0..]
12:03:06 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
12:03:13 <sclv> maybe that had something to do with it? that's what triggered it last time, I think.
12:03:17 <Cale> Nope
12:03:25 <Cale> It was the Type plugin.
12:03:34 <Cale> It inserts a bunch of stuff into L.hs
12:03:45 <sclv> ?ty Int + String
12:03:46 <lambdabot> Not in scope: data constructor `Int'
12:03:46 <lambdabot> Not in scope: data constructor `String'
12:03:51 <sclv> ?ty 1 + 2
12:03:52 <monochrom> > map (showIntAtBase 2 (\x -> case x of 0 -> 'a'; 1 -> 'b') "") [0..]
12:03:52 <lambdabot> forall t. (Num t) => t
12:03:53 <lambdabot>   add an instance declaration for (Integral [Char])
12:03:55 <Cale> sigh
12:03:59 <Cale> Could you not do that?
12:04:00 <dolio> b_jonas: Ignoring types because fix isn't the right type to be passed to fix.
12:04:29 <sarehu> > map (`replicateM` "abc") [0..]
12:04:30 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
12:04:36 <sclv> you mean not test the lets and undefines? sure...
12:04:46 <Cale> No, I mean, don't use the type plugin.
12:04:50 <Cale> Hang on a sec.
12:04:54 <monochrom> > map (\n -> showIntAtBase 2 (\x -> case x of 0 -> 'a'; 1 -> 'b') n "") [0..]
12:04:55 <lambdabot>  ["a","b","ba","bb","baa","bab","bba","bbb","baaa","baab","baba","babb","bbaa...
12:05:15 <Cale> > map (`replicateM` "abc") [0..]
12:05:16 <lambdabot>  [[""],["a","b","c"],["aa","ab","ac","ba","bb","bc","ca","cb","cc"],["aaa","a...
12:05:22 <sarehu> concatMap
12:05:26 <Deewiant> > concatMap (`replicateM` "abc") [0..]
12:05:27 <lambdabot>  ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aa...
12:05:32 <Cale> :t 1
12:05:33 <fax> wow :D
12:05:33 <lambdabot> forall t. (Num t) => t
12:05:35 <Cale> > map (`replicateM` "abc") [0..]
12:05:36 <lambdabot>  [[""],["a","b","c"],["aa","ab","ac","ba","bb","bc","ca","cb","cc"],["aaa","a...
12:05:38 <Cale> okay
12:05:50 <fax> filter validProgram $ concatMap (`replicateM` "10") [0..]
12:05:56 <fax> :D
12:06:02 <monochrom> ...
12:06:16 <b_jonas> oh, I see, that's a stronger type error
12:06:37 <b_jonas> because fix :: (a -> a) -> a
12:06:39 <fax> @src replicateM
12:06:40 <lambdabot> replicateM n x = sequence (replicate n x)
12:06:41 <Cale> There are some really stupid things which these plugins are doing. They should presumably all just import L.hs, and not modify it. (Except for @let)
12:07:27 <dons> only @let modifies it
12:07:34 <oerjan> Cale: @type uses a different method doesn't it?  it allows arbitrary module prefixes?
12:07:34 <dons> and none import it.
12:07:49 <Cale> hmm
12:07:57 <dons> so what are we trying to solve here?
12:08:01 <Cale> Then I wonder what overwrote L.hs
12:08:04 <dons> there's the rlimit issue with Quickcheck.hs
12:08:09 <dons> oh, possibly and @undefine ?
12:08:09 <Cale> I fixed that.
12:08:34 <oerjan> @undefine
12:08:36 <lambdabot> Undefined.
12:08:38 <oerjan> > 1
12:08:39 <lambdabot>  /home/cgibbard/darcs/lambdabot/L.o: unknown symbol `__stginit_haskell98_Char...
12:08:41 <oerjan> ah
12:08:45 <Cale> ah, okay
12:09:11 <oerjan> makes sense.  it was the last thing i did before the first time we saw that error
12:11:13 <Cale> @undefine
12:11:14 <lambdabot> Undefined.
12:11:16 <Cale> > 1
12:11:17 <lambdabot>  1
12:11:19 <oerjan> it would also be nice if all imported modules were imported with their full names, even if they have an abbreviation.
12:11:21 <Cale> There we go.
12:11:32 <Cale> Oh, that also has some other consequences...
12:12:02 <Deewiant> > let f = ([1..] >>=) . flip replicateM in f "abc"
12:12:03 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
12:12:28 <oerjan> > on
12:12:29 <lambdabot>   Not in scope: `on'
12:12:44 <oerjan> > intercalate
12:12:45 <lambdabot>  Add a type signature
12:13:00 <Deewiant> > intercalate " " ["foo","bar"]
12:13:02 <lambdabot>  "foo bar"
12:13:20 <cjb> or "join", as we say in English.
12:13:31 <Deewiant> :-)
12:13:36 <fax> > intercalate " " (map (`replicateM` "01") [0..])
12:13:37 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
12:13:44 <fax> > intercalate " " (concatMap (`replicateM` "01") [0..])
12:13:45 <lambdabot>  " 0 1 00 01 10 11 000 001 010 011 100 101 110 111 0000 0001 0010 0011 0100 0...
12:13:54 <Deewiant> fax: [1..] to get rid of the empty sting
12:13:56 <Deewiant> er, string
12:14:11 <Cale> > extendSequence [2,4,8,16,32]
12:14:12 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
12:14:22 <Deewiant> whoot
12:14:26 <Deewiant> @index extendSequence
12:14:27 <lambdabot> bzzt
12:14:36 <vincenz> > extendSequence [1,1,2,3,5]
12:14:37 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:14:40 <MyCatVerbs> :t extendSequence
12:14:41 <lambdabot> Not in scope: `extendSequence'
12:14:45 <vincenz> Cale: that is the dirtiest hack ever
12:14:48 <Cale> http://hackage.haskell.org/packages/archive/oeis/0.1/doc/html/Math-OEIS.html
12:14:50 <lambdabot> http://tinyurl.com/2krqpv
12:14:55 <Deewiant> > extendSequence [1,11,21,1211]
12:14:56 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
12:15:12 <cjb> wow, nice.
12:15:14 <Deewiant> Cale: ah, I see. cool.
12:15:17 * vincenz laughs
12:15:17 <sarehu> > extendSequence (repeat 1)
12:15:18 <MyCatVerbs> Cale: is that the Online Encyclopedia of Integer Sequences?
12:15:22 <Cale> yes
12:15:22 <lambdabot> Terminated
12:15:24 <Deewiant> MyCatVerbs: yes
12:15:31 <vincenz> MyCatVerbs: yeah, "unsafePerformIO check webste"
12:15:45 <sarehu> > extendSequence [0]
12:15:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:15:51 <sarehu> ohhh kay.
12:15:52 <fax> > extendSequence [72,101,108,108,111]
12:15:53 <lambdabot>  [72,101,108,108,111]
12:16:12 <oerjan> > extendSequence [4]
12:16:14 <lambdabot>  [4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,16,20,16...
12:16:18 <Deewiant> > lookupSequence [1,11,21,1211]
12:16:19 <lambdabot>  Just (OEIS {catalogNums = ["A005150","M4780"], sequenceData = [1,11,21,1211,...
12:16:36 <MyCatVerbs> vincenz: SPIFFY!
12:16:42 <sarehu> > extendSequence [1,4,1,5,9]
12:16:43 <lambdabot>  [1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1,9...
12:16:44 <MyCatVerbs> "And so on. Reams of collected mathematical knowledge at your fingertips! You must promise only to use this power for Good." <-- SPIFFIER!
12:16:53 <fax> very nice
12:17:35 <Cale> @undefine
12:17:38 <lambdabot> Undefined.
12:17:48 <Cale> > describeSequence [1,4,1,5,9]
12:17:49 <lambdabot>  Just "Decimal expansion of Pi."
12:17:50 <Deewiant> > 1+1
12:17:51 <lambdabot>  2
12:18:03 <fax> > extendSequence [2,3,5,7]
12:18:05 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:18:08 <Deewiant> > describeSequence [1,11,21,1211]
12:18:08 <Cale> > describeSequence [1,11,21,1211]
12:18:09 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
12:18:09 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
12:18:15 <oerjan> > extendSequence [0,6,6,3,6,5]
12:18:16 <lambdabot>  [0,6,6,3,6,5,6,7,7,0,6,1,2,4,6,4,6,9,2,3,4,6,9,5,9,4,2,1,4,9,9,2,6,3,2,4,7,2...
12:18:25 <oerjan> > extendSequence [0,6,6,3,6,5,1]
12:18:27 <lambdabot>  [0,6,6,3,6,5,1,4,3,2,0,3,6,1,3,4,1,1,0,2,6,3,4,0,2,2,4,4,6,5,2,2,2,6,6,4,3,5...
12:18:39 <Cale> > describeSequence [0,6,6,3,6,5,1]
12:18:43 <lambdabot>  Just "Expansion of Pi in base 7."
12:18:51 <ricky_clarkson> > extendSequence [0,7,5,2,7]
12:18:52 <lambdabot>  [0,7,5,2,7,1,7,1,3,4,9,2,2,7,4,4,3,6,0,5,7,0,3,5,9,2,7,7,8,7,7,0,3,9,1,4,4,3...
12:18:52 <sarehu> > length (extendSequence [1,4,1,5,9])
12:18:56 <lambdabot>  104
12:19:01 <ricky_clarkson> It does not appear to know my phone number.
12:19:15 <sarehu> > last (extendSequence [1,4,1,5,9])
12:19:16 <lambdabot>  4
12:19:19 <sarehu> ^ the last digit of pi
12:19:27 <Deewiant> :-D
12:19:30 <Cale> > describeSequence [0,7,5,2,7]
12:19:33 <lambdabot>  Just "DirichletBeta'[1]."
12:19:36 <sarehu> (actually, it's 5)
12:20:12 <Cale> > extensSequence [4]
12:20:13 <lambdabot>   Not in scope: `extensSequence'
12:20:15 <Cale> > extendSequence [4]
12:20:17 <Lemmih> > 1:1:zipWith (+) (extendSequence [1,1,2,3]) (extendSequence [1,2,3])
12:20:17 <lambdabot>  [4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,16,20,16...
12:20:19 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:20:22 <Cale> > describeSequence [4]
12:20:25 <lambdabot>  Just "Euler totient function phi(n): count numbers <= n and prime to n."
12:20:31 <sarehu> > printf "%60f" pi
12:20:32 <lambdabot>  Add a type signature
12:20:36 <sarehu> > printf "%60f" pi :: String
12:20:37 <lambdabot>  "                                           3.141592653589793"
12:20:40 <sarehu> sigh
12:21:12 <daf> printf "%.60f" pi :: String
12:21:17 <daf> > printf "%.60f" pi :: String
12:21:19 <lambdabot>  "3.141592653589793000000000000000000000000000000000000000000000"
12:21:22 <daf> :)
12:21:23 <MyCatVerbs> Mmmmm. Can you use GMP in Haskell for arbitrary precision floats as well as arbitrary precision integers?
12:21:45 <mejja> No.
12:21:46 <dons> MyCatVerbs: you can't currently ffi into gmp from ghc haskell, afaik
12:22:06 <mejja> GMP doesn't do floats...
12:22:24 <MyCatVerbs> dons: oh, damn.
12:22:34 <sarehu> > last . takeWhile ((/=0).snd.properFraction) . iterate (* 10) $ pi
12:22:35 <lambdabot>  3.141592653589794e14
12:22:43 <MyCatVerbs> mejja: oh, poop. I thought it did.
12:23:05 <dons> you can probably find a lib that does though
12:23:07 <sarehu> > (`mod` 10) . round . last . takeWhile ((/=0).snd.properFraction) . iterate (* 10) $ pi
12:23:08 <lambdabot>  9
12:23:09 <dons> would be a useful contribution
12:23:10 <sarehu> sigh
12:23:12 <mejja> For floats, try: http://www.mpfr.org/
12:23:13 <lambdabot> Title: The MPFR Library
12:24:03 <dons> hmm. i should do a binding . this looks useful
12:24:21 <daf> mejja: gmp does do floats, I'm pretty sure
12:24:48 <mejja>    7. Externally supported: High-level floating-point accurately rounding arithmetic functions (mpfr). See the mpfr site for more information. Starting with GMP 4.2, mpfr is released only separately from the project site.
12:25:12 <sarehu> > let fp = snd . properFraction in last . takeWhile (/=0) . iterate (fp . (*10)) $ pi
12:25:12 <lambdabot>  0.5
12:25:16 <monochrom> When the MPFR binding is done, will it become the default Floating? :)
12:25:20 <sarehu> ^^ last digit is 5
12:25:37 <Riastradh> Am I blind, or do neither GHC's Data.Sequence nor anything in Edison support insertion into and deletion from the middle of sequences?
12:26:11 <sarehu> Riastradh: Data.Sequence does.. if you split and recombine
12:26:14 <oerjan> Riastradh: you can split Seq's i think
12:26:30 <daf> mejja: mpfr might be better, but gmp does support them :P
12:26:40 <Riastradh> OK...
12:27:04 <cityseeker> hello
12:28:12 <sarehu> hi
12:28:19 <cityseeker> I used a haskell portage overlay to install xmonad on my gentoo box is there anything similar for centos5 an rpm forge?
12:29:26 <sclv> cityseeker: you might want to try #xmonad
12:29:33 <cityseeker> thanks
12:33:48 <hrehf> gnar, im in java and i can't think about the problem in a way that fits java; instead if always just fits haskell / lists :(
12:34:27 <fax> hrehf: learning java?
12:34:36 <hrehf> fax, no, not at all
12:34:38 <sarehu> rewrite the java stdlibs so they are pure :)
12:34:41 <hrehf> :D
12:34:59 <sarehu> (sigh.)
12:35:06 <hrehf> just doing geometry problems (grid neighbours) for rendering
12:35:23 <b_jonas> sarehu: heh, that would be difficult
12:35:49 <b_jonas> you'd have to think a lot about where to use promises and where be strict
12:36:04 <b_jonas> introduce lazy lists and whatnot
12:36:16 <sarehu> bah, not lazy, just immutable data structures
12:36:30 <fax> heh just write java in java
12:36:34 <fax> it's a lot easier
12:36:38 <b_jonas> sarehu: but you need some lazyness for monads
12:37:11 <b_jonas> it's better to just program in haskell, yeah
12:37:15 <sarehu> speak no more, I don't want to think about Java :P
12:43:25 <ricky_clarkson> sarehu: This week, I realised I will likely never write any Java code again without being paid for it.
12:43:38 <ricky_clarkson> Hopefully I can, in a year or so, remove the latter part of that sentence.
12:46:53 <sarehu> Is there any reason why there isn't a version of runSTArray that lets you return something alongside the STArray?
12:48:35 <b_jonas> sarehu: runST and freeze ?
12:49:01 <b_jonas> that is, freeze from Data.Array.MArray to freeze an STArray to an array, and return it from an ST monad you run
12:49:51 <sarehu> but runSTArray uses unsafeFreeze safely
12:50:10 <b_jonas> sarehu: ah, I see
12:50:17 <b_jonas> hmm
12:50:30 <olsner> whut, cabal: ghc version >=6.2 reqquired but the version of /opt/local/ghc/bin could not be determined
12:50:34 <b_jonas> um, use it safely then?
12:50:34 <sarehu> I could always use unsafeFreeze, but meh.
12:51:10 <olsner> cabal worked before I uninstalled macports' llvm :\
12:51:13 <b_jonas> or define an Ix that has an extra field not used for bounds, and pass the return value in there
12:51:22 <b_jonas> (only that complicated indexing of the array)
12:52:21 <olsner> heh, running cabal failed when in /opt/local/lib but worked when I changed working directory
12:52:23 <sarehu> hilarious
12:54:24 <Cin> @hoogle a -> [a]
12:54:26 <lambdabot> Prelude.repeat :: a -> [a]
12:54:26 <lambdabot> Data.List.repeat :: a -> [a]
12:54:26 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
12:55:03 <Cin> > take 1 $ repeat 'a'
12:55:18 <lambdabot>  thread killed
12:55:36 <JohnMeacham> hello.
12:56:02 <oerjan> > take 1 $ repeat 'a'
12:56:03 <lambdabot>  "a"
12:56:13 <fax> > (:[]) 'a'
12:56:14 <lambdabot>  "a"
12:57:53 <therp> hmm I just decided to go to ICFP08
12:58:17 <b_jonas> therp: how about challenge24 2008?
12:58:36 <b_jonas> does any of you haskellers go with a team there?
12:59:12 <therp> b_jonas: that's virtual isn't it?
12:59:45 <fax> @quote upside
12:59:46 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
12:59:50 <fax> @quote upsidedown
12:59:50 <lambdabot> No quotes match. Where did you learn to type?
13:00:53 <vincenz> b_jonas: ?
13:01:00 <vincenz> b_jonas: What's challenge48?
13:01:11 <vincenz> b_jonas: And didn't he mean the conference instead of the competition?
13:04:24 <ehird`> I have a question, regarding Haskell+unicode
13:04:27 <ehird`> using GHC
13:04:39 <ehird`> does it handle unicode perfectly, or are there non-perfect areas?
13:04:48 <b_jonas> vincenz: http://www.challenge24.org/
13:04:52 <ehird`> i know you have to use that utf8-string package or something for IO
13:04:56 <OceanSpray> How do you find whether a substring exists within another string?
13:04:59 <ehird`> but actually in the language?
13:05:12 <oerjan> :t isInfixOf
13:05:18 <lispy> supposed I have data Foo a x y = Foo (SimpleFoo a x y), and data SimpleFoo a x y = SFoo a x y.  I get a kind error in the definition of Foo.  It says a has expected kind *, but I'm giving it kind * -> * -> *
13:05:18 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
13:05:26 <b_jonas> a two-round competition for teams of three, where the first round is 5 hours (?) of solving tasks over the internet,
13:05:36 <OceanSpray> > isInfixOf "a" "bab"
13:05:39 <lambdabot>  True
13:05:40 <b_jonas> the second round is 24 hours of solving tasks in-place
13:05:42 <OceanSpray> > isInfixOf "c" "bab"
13:05:43 <lambdabot>  False
13:05:46 <OceanSpray> thanks.
13:05:47 <b_jonas> that's why it's called challenge_24_
13:05:49 <lispy> ?seen Cale
13:05:50 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 45m 27s ago.
13:06:00 <b_jonas> therp: virtual?
13:06:02 <Cale> hello
13:06:11 <lispy> Cale: I have a question you should be able to answer :)
13:06:15 <Cale> oh?
13:06:16 <lispy> Cale: if you don't mind ...
13:06:19 <lispy> supposed I have data Foo a x y = Foo (SimpleFoo a x y), and data SimpleFoo a x y = SFoo a x y.  I get a kind error in the definition of Foo.  It says a has expected kind *, but I'm giving it kind * -> * -> *
13:06:44 <lispy> Cale: I want a to have kind * -> * -> *
13:06:56 <lispy> Cale: do you see what i'm doing wrong?
13:07:01 <Cale> You could try explicitly kinding the variable.
13:07:17 <Cale> Let me give it a shot :)
13:07:41 <oerjan> lispy: you don't accidentally have parentheses around a x y somewhere?
13:07:50 <lispy> Cale: hrm, what is the syntax for that, data Foo (a :: * -> * -> *) x y ...
13:08:02 <Cale> er, yeah, you probably meant to have:
13:08:05 <lispy> oerjan: no, i've tried that
13:08:07 <Cale> data SimpleFoo a x y = SFoo (a x y)
13:08:08 <OceanSpray> what module is isInfixOf in?
13:08:15 <oerjan> oh
13:08:30 <oerjan> OceanSpray: Data.List
13:08:35 <Cin> ehird`: ghc reads files as utf-8
13:08:35 <OceanSpray> thanks
13:08:46 <Cale> Yeah, ordinary kind inference handles that just fine :)
13:08:47 <oerjan> (fairly new)
13:08:52 <b_jonas> Cin: you mean, source files, right?
13:08:52 <ehird`> Cin: not my code files..
13:08:55 <olsner> so, new kernel installed, let's see if I can compile stuff without time slowing down
13:09:00 <ehird`> Cin: i am talking about language support
13:09:03 <Cin> b_jonas: yeah
13:09:03 <lispy> Cale: hmm..that still fails for me
13:09:11 <Cale> @paste
13:09:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:09:54 <hpaste>  Cale pasted "this compiles" at http://hpaste.org/5563
13:10:12 <Cin> ehird`: it says in the documentation forghc 6.8.2, anyway. it doesn't encode it as utf-8 on output, though, in IO. it just outputs it raw
13:10:29 <darrint> Is there a right answer for how to use hlist?
13:10:33 <ehird`> Cin: right, but there's some kind of packiage to fix that
13:10:35 <Cin> ehird`: raw. like my love for you
13:10:36 <ehird`> utf8-strnigs i think it's called
13:10:48 <Cin> yeah, i've used it recently to output λ
13:10:49 <ehird`> but apart from that can i write an app that's going crazy with unicode and be OK?
13:11:02 <lispy> Cale: sorry, it's my monad definition that errors now.  Thanks.
13:11:06 <Cin> show (Ab id e)  = encodeString("(λ")  --etc
13:11:09 <ehird`> the reason is that i've invented an esolang that is entirely based on using heaps of unicode characters in odd ways
13:11:10 <lispy> Cale: that's a different problem I can fix :)
13:11:28 <b_jonas> ehird`: people have done that kind of thing, yeah
13:11:50 <ehird`> and it's hard to find a good implementation language :-)
13:12:06 <oerjan> ehird`: utf-8 in String and Char literals should be fine
13:12:14 <ehird`> oerjan: that too? excellent
13:12:20 <Cale> Do we have a UTF-8 parsing library?
13:12:27 <b_jonas> oerjan: yep, but you have to know how to input and output them to files
13:12:38 <ehird`> Cale: Oo, good point. Parsec won't hold up, I'll bet
13:12:41 <olsner> heh, upgrading the kernel actually seems to have solved it! sweet
13:12:44 <b_jonas> internally, Char is a character, not a byte, so the utf-8 is gone
13:13:35 <Cale> Oh, actually nevermind.
13:13:38 <Cale> er...
13:13:56 <Cale> Prelude> x <- getLine
13:13:56 <Cale> Γρεεκ
13:13:59 <Cale> Prelude> length x
13:14:00 <Cale> 10
13:14:14 <oerjan> ehird`: you need to convert utf-8 bytes to String before passing to Parsec, then it should be fine
13:15:14 <b_jonas> Cale: sure, it has to read bytes or you'd get unexpected problems in simple encoding-agnostic programs
13:15:14 * fax finds Lisps, Prolog, Java, Haskell.. no trouble with unicode
13:15:42 <Cale> b_jonas: Right, from before we had things like ByteStrings :)
13:16:24 <b_jonas> so how does this work in haskell? how do you read and decode using a given encoding from a filehandle, and how do you write encoding to a given encoding?
13:16:34 <b_jonas> what modules handle that?
13:17:25 <mrd> hmm, there's an encoding hackage package or something
13:17:48 <mrd> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/encoding-0.4
13:17:49 <lambdabot> http://tinyurl.com/38l6bq
13:17:51 <fax> Parsec should work...
13:17:53 <b_jonas> mrd: it's not in core?
13:18:14 <dons> google chart binding for haskell, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/GoogleChart-0.2
13:18:15 <lambdabot> http://tinyurl.com/3dv8kw
13:18:21 <mrd> b_jonas: not afaik
13:18:36 <b_jonas> I mean, if we don't have character set encoding in haskell, then wtf is the point of having a wide Char in the core?
13:18:59 <mrd> putting more stuff in core, is, not really regarded as a good idea
13:19:57 <b_jonas> mrd: yeah, but then why not just use some 8-bit character types in the core and have a wide character type in those libraries that allow you to use it?
13:19:58 <mrd> i've used that encoding library to print out japanese characters on a urxvt console, so it must work fine
13:20:01 <b_jonas> it seems strange
13:20:24 <mrd> i'm confused why you'd think Strings should be 8-bit
13:20:50 <b_jonas> mrd: there should be both kinds of types
13:21:02 <b_jonas> a list of bytes and a list of (current) Chars
13:21:11 <mrd> ok, [Byte]
13:21:16 <b_jonas> yep
13:21:19 <fax> Doesn't parsec work with unicode?
13:21:20 <mrd> there, I made it
13:21:26 <mrd> fax: parsec works with Strings
13:21:37 <fax> it works with anything..
13:21:39 <Philippa_> Parsec doesn't give a damn what the token type is
13:21:41 <b_jonas> as there's no real way to use Chars with the core functions, why have Char in the core at all?
13:21:49 <lispy> I thought parsec can work with [Token]
13:21:51 <mrd> b_jonas: ?
13:21:59 * fax is wondering what the concern is
13:22:04 <Philippa_> b_jonas: what you mean is "as there's no real way to extract unicode chars from the IO monad with the core functions"
13:22:10 <mrd> I think you're mixing up encoded data with what it represents
13:22:19 <b_jonas> Philippa_: yes, sort of
13:22:21 <b_jonas> and the other way too
13:22:52 <b_jonas> mrd: if you're just reading encoded data, that is, a sequence of bytes, then why'd you use a Char type that's wider than a byte?
13:22:54 <Philippa_> but there /is/ an FFI, and enough functionality to build encoders and decoders, already present
13:23:05 <mrd> b_jonas: Chars do not represent bytes, they represent characters
13:23:08 <Philippa_> because it's supposed to be
13:23:14 <b_jonas> mrd: yep
13:23:20 <Philippa_> GHC reads a particular encoding by default
13:23:25 <Philippa_> it happens to be 8 bits wide
13:23:42 <Philippa_> there are also proper binary IO functions these days, thankfully
13:23:42 <b_jonas> Philippa_: no, I think it reads raw bytes
13:23:47 <Philippa_> say hello to a historical accident
13:23:49 <Philippa_> b_jonas: no such thing
13:23:53 <fasta> Philippa_: not anymore, right?
13:24:00 <mrd> b_jonas: no, you are confusing encoding with characters
13:24:00 <b_jonas> well, it's not really important anyway
13:24:04 <b_jonas> the package is there
13:24:06 <mrd> it's a common mistake
13:24:17 <Philippa_> b_jonas: latin-1 is still an encoding
13:24:35 <b_jonas> Philippa_: yes, but I wouldn't only read raw bytes to read latin-1 data
13:24:42 * fasta is pretty sure that ghc accepts more than 256 chars.
13:25:04 <Philippa_> fasta: in source now? I think so, yeah. So you can now define string and char literals that use it
13:25:06 <b_jonas> I'd use it for any kind of text file, or even a binary file, and use byte strings if I don't need to do anything that depends on the encoding
13:25:33 <mrd> yes, ghc reads utf-8 source code
13:25:48 <Deewiant> > let ä = 1 in ä
13:25:48 <lambdabot>  Illegal character ''\164''
13:25:48 <lambdabot>  at "" (column 6)
13:26:11 <b_jonas> so I wouldn't think of the Prelude getLine function as something that reads 8859-1 text, but one that reads byte strings
13:26:12 <mrd> however the System.IO functions only handle one type of encoding, basic latin-1
13:26:15 <lispy> Deewiant: that's not GHC's parser necessarily.  lambdabot has at least one parser of it's own when parsing input
13:26:27 <Philippa_> b_jonas: which you would be wrong about
13:26:31 <OceanSpray> There's got to be a better way to do:
13:26:32 <OceanSpray> case parse lispExpr "screw" content of
13:26:32 <OceanSpray>     Left err | isInfixOf "unexpected end of input" (show err) -> readExpr content
13:26:37 <Philippa_> see, you don't get Word8 back out, you get Char
13:26:44 <b_jonas> Philippa_: but then what would I use to read byte strings?
13:26:46 <Philippa_> whether you like it or not, it has been treated as a character encoding
13:26:47 <Deewiant> lispy: yeah, it appears to work locally
13:26:51 <Philippa_> it so happens that it's a trivial one
13:27:05 <Philippa_> b_jonas: there's a bunch of funcs somewhere that actually give you Word8
13:27:10 <mrd> b_jonas: a raw octet stream needs to be decoded to become a String
13:27:16 <b_jonas> in most cases, I want my program not care about the encoding of the text file, and its output will be in the same encoding because it will just copy parts of the text
13:27:26 <lispy> OceanSpray: why do you use String as your error type?
13:27:29 <mrd> b_jonas: by historical accident, that decoding function used to be "id"
13:27:35 <b_jonas> mrd: yes, if String is a string of characters
13:27:49 <b_jonas> but how do I work with strings of byte in haskell then?
13:28:01 <b_jonas> I understand that if I want to decode to characters, I can use that encode module
13:28:08 <b_jonas> s/module/package/
13:28:10 <mrd> arrays or lists of Word8s
13:28:17 <mrd> but they are not characters.
13:28:30 <Philippa_> hGetArray, gPutArray in Data.Array.IO
13:28:56 <b_jonas> mrd: I know they aren't characters
13:29:04 <mrd> the basic point (which the Unicode people have had to hammer into C folks heads) is that [Word8] and [Char] need to be translated in between
13:29:16 <b_jonas> mrd: yep
13:29:51 <fasta> Philippa_: strings containing ༀ don't seem to work. Nor variable definitions. It probably only works for some small set, like you said.
13:29:53 <Philippa_> or use the ops on ByteString, which doesn't store characters
13:30:08 <b_jonas> but if Char is only for characters, that it seems bad design to have a function (esp in the Prelude) that reads latin-1 and only that, and not something general that reads any encoding iconv can handle
13:30:33 <fasta> b_jonas: latin-1 is not in the spec.
13:30:40 <fasta> b_jonas: it's a GHC'ism.
13:30:49 <b_jonas> fasta: how do you specify the encoding then?
13:30:51 <b_jonas> or something
13:30:51 <mrd> yes, System.IO only handles one encoding, which is unfortunate.  but the encoding library fixes that.
13:30:53 <Philippa_> the version of the ByteString docs I'm looking at is a little confused about chars vs bytes in a couple of places
13:31:06 <b_jonas> mrd: and how does that encoding package work by the way?
13:31:08 <Philippa_> b_jonas: with great difficulty. Welcome to legacy code, and yes, this is considered a significant outstanding issue
13:31:14 <mrd> it provides alternative modules
13:31:24 <Philippa_> the encoder will no doubt do IO in terms of Word8 and then convert...
13:31:27 <fasta> I only can say that I printed "weird characters" (utf8) using glguy's library.
13:31:29 * b_jonas tries to understand its documentation
13:31:49 <b_jonas> wait, you said Data.Array.IO?
13:31:51 <fasta> That's not encoding. utf8-string, IIRC.
13:32:00 <b_jonas> isn't that the module for IO-modifyable arrays?
13:32:03 <Philippa_> b_jonas: that's one way to do it, yeah
13:32:10 <Philippa_> it is, yes. It's also the module for block binary IO
13:32:20 <Philippa_> which gets done in and out of IO-modifiable arrays
13:32:20 <mrd> http://hackage.haskell.org/packages/archive/encoding/0.4/doc/html/System-IO-Encoding.html
13:32:21 <lambdabot> http://tinyurl.com/2kcpks
13:32:26 <Philippa_> a bit confusing, admittedly
13:32:33 <b_jonas> Philippa_: I see
13:32:46 <mrd> you can also encode into a ByteString
13:33:28 <Philippa_> yep, ByteString's probably the better way to do it these days. All the types're in terms of Word8, so assume any references to characters are things that need correcting in the docs
13:33:50 <mrd> Data.Encoding.encode UTF8 "some string"
13:33:52 <b_jonas> System.IO.Encoding.hPutStr  writes a string encoded with an encoding, right?
13:34:02 <b_jonas> and how do you create its encoding parameter?
13:34:06 <Cin> is `init' an O(n) operation?
13:34:09 <mrd> import the appropriate module
13:34:19 <mrd> like Data.Encoding.UTF8
13:34:21 <fax> init should be O(1) I think?
13:34:21 <b_jonas> Philippa_: ByteString? I see
13:34:39 <Philippa_> just to clarify: ByteString's the better way to do binary IO these days
13:34:40 <b_jonas> and I guess I might want to convert those to [Word8] and back so that I can use list functions
13:34:41 <fasta> Cin: depends on how you count.
13:34:43 <mrd> Data.Encoding.encode Data.Encoding.UTF8.UTF8 "some string" :: ByteString
13:34:46 <fax> it's when you actually look at the string computation is done
13:34:53 <fax> or is that not really accurate?
13:35:04 <Philippa_> b_jonas: up to you. But not as painful as you might expect, especially if you use lazy bytestrings
13:35:05 <b_jonas> mrd: and how do I create an arbitary encoding?
13:35:05 <fasta> Cin: if you just do print (init [1..]) it's obviously not O(1).
13:35:25 <mrd> implement an instance of Encoding
13:35:26 <b_jonas> Philippa_: I don't know the ByteString library yet,
13:35:31 <Philippa_> b_jonas: so RTFM?
13:35:38 <b_jonas> Philippa_: I will
13:35:46 <Philippa_> I barely know it myself, it took a matter of seconds to find the IO functions in the docs
13:35:49 <b_jonas> mrd: so it can't just use anything iconv suports?
13:36:13 <Cin> fasta: well i have a list and i want to remove the last item from the list. the list monad could potentially do this in O(1) underneath but i don't know?
13:36:14 <mrd> i don't know much about iconv
13:36:14 <b_jonas> that seems limited
13:36:26 <mrd> why don't you read the Encoding library docs and see how much it already supports?
13:36:41 <fasta> Cin: why would the list monad do that?
13:36:45 <b_jonas> yes, I'm looking at it, and it lists some twenty modules or so of encodings
13:36:48 <b_jonas> which doesn't seem general
13:36:53 <mrd> it's written in Haskell.  FFIing to libiconv or whatever is probably not hard either.
13:36:59 <b_jonas> I'd like any iconv the libc supports
13:37:05 <Cin> fasta: er, ignore that
13:37:16 <mrd> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/iconv-0.4
13:37:17 <lambdabot> http://tinyurl.com/2lmkse
13:37:23 <b_jonas> mrd: ah, I see
13:37:24 <mrd> in fact, it's already been done
13:37:33 <fasta> Heh, there is #arc.
13:37:35 <b_jonas> so I shouldn't be looking at the encode package at all
13:37:37 <mrd> http://hackage.haskell.org/packages/archive/pkg-list.html
13:37:40 <fasta> Sorry, I have to laugh.
13:37:51 <mrd> i'm just reading names off that list
13:37:53 <Cin> fasta: it seems the implementation is O(n) (cons over the list until the next item is nil)
13:38:06 <b_jonas> fasta: is it meta-discussing the language, or supporting people who want to code in Arc?
13:38:13 <fasta> b_jonas: I have no idea.
13:38:24 <fasta> b_jonas: I saw it in Cin's list of channels.
13:38:42 <Cin> creepy.
13:38:44 <b_jonas> there's some webpage tracking the largest channels of freenode
13:38:47 <Cin> "who is this cin clown?" */whois cin*
13:38:55 <Philippa_> Cin: it can't be done in constant time with []
13:39:42 <Philippa_> removing the last item from a singly-linked list you don't have the end of is painful even in languages with mutability - in haskell you've got no choice but to copy the rest of the list out unfortunately. If you want something faster, try Data.Seq?
13:39:44 <Cin> philippa: i don't follow. what do you mean, with []?
13:39:53 <Philippa_> [] being the type constructor for lists in this case
13:40:06 <Cin> ah
13:40:09 <fasta> Cin: the short answer is, indeed, that it is O(n).
13:40:10 <b_jonas> mrd, Philippa_: thanks for the help about encodings
13:40:19 <Cin> well, it's okay. speed is not an issue, i was just curious
13:40:57 <fasta> Philippa_: or doubly linked lists?
13:41:04 <fasta> Philippa_: or ST
13:41:22 <b_jonas> it's sort of funny how encoding names are strings themselves
13:41:34 <Philippa_> fasta: doubly-linked isn't going to help you, you need mutability
13:41:38 <b_jonas> let's invent a non-ascii encoding name to break every standard
13:42:01 <Philippa_> b_jonas: yep, can you say broken?
13:42:03 <b_jonas> (obviously standards like mime probably forbit that outright)
13:42:07 <fasta> Philippa_: depends on exactly what you want.
13:42:21 <b_jonas> (so it will be our request for registering that encoding name that's broken, not the standard)
13:42:34 <fasta> Philippa_: you could create a list with a certain length and call the init something which simply ends earlier in the enumeration function.
13:42:46 <Cin> UTF-α
13:43:04 * Cin waits for "i just see a square"
13:43:11 <hpaste>  siti pasted "ghc GC crash :(" at http://hpaste.org/5564
13:43:14 <fasta> I see \alpha.
13:43:19 <Philippa_> yeah, and you can keep a separate length with singly-linked lists too
13:43:22 <glen_quagmire> ㅁ
13:43:28 <siti> any ideas on how to diagnose it?
13:43:30 <fasta> Cin: that was in 1998.
13:43:34 <Cin> fasta: are you on irssi?
13:43:38 <fasta> Cin: yes.
13:43:42 <Philippa_> bit of an invitation to leak space though
13:43:44 <fasta> Cin: are you spying?
13:43:46 <fasta> Cin: ^^
13:43:58 <Cin> fasta: ;)
13:44:07 <monochrom> UTF-square? :)
13:44:27 <olsner> Double-UTF :P
13:44:29 <b_jonas> that iconv module seems nice
13:44:31 * Cin chortles
13:44:44 <fasta> ⁂⁂⁂⁂⁂⁂⁂⁂⁂⁂ <- look snow!
13:45:08 <Cin> olsner: clever
13:45:21 <fasta> Too bad $SEARCHENGINE doesn't do Unicode searches.
13:50:02 <b_jonas> stupid question, on http://www.haskell.org/haskellwiki/How_to_install_a_Cabal_package how do I check what version of a library I have?
13:50:04 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki
13:50:28 <Saizan>  ghc-pkg list lib?
13:51:23 <glen_quagmire> what's a good tutorial on Monad? i tried wikibooks, gentle intro to haskell, and realworldhaskell..but they were all rough to me
13:52:05 <b_jonas> Saizan: what about for libraries that came with ghc?
13:52:19 <Cin> fasta: btw, irssi shows \foo instead of the character in irssi if you don't set the utf-8 settings. it was recently annoying me with my irssi, so i looked it up.
13:52:37 <monochrom> I learned monads from Wadler's writing and the Hutton article on parser combinators.
13:52:42 <fasta> Cin: how do you mean \foo?
13:52:54 <Cin> fasta: \alpha etc.
13:53:13 <Cin> fasta: do you get a number here?: λ
13:53:18 <fasta> Cin: no
13:53:22 <fasta> Cin: lambda
13:53:25 <monochrom> Bird's textbook and Hudak's textbook also confront it head on.
13:53:28 <Cin> fasta: \lambda?
13:53:32 <fasta> Cin: no
13:53:38 <Cin> oh
13:53:41 <Cin> weird behaviour is weird
13:53:55 <piojo> glen_quagmire: i sort of like this page: http://www.haskell.org/all_about_monads/html/index.html
13:53:55 <lambdabot> Title: All About Monads
13:53:58 <fasta> Cin: my terminal shows something that looks pretty much like a lambda symbol.
13:54:07 <glen_quagmire> thanks
13:54:08 <fasta> Cin: that's what I meant by \alpha.
13:54:27 <byorgey> @remember Cin weird behaviour is weird
13:54:27 <lambdabot> Good to know.
13:54:37 <fasta> @quote monad
13:54:37 <lambdabot> psykotic says: the reader monad is your friend. trust the reader monad. be happy!
13:54:41 <fasta> @quote monad
13:54:41 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
13:54:46 <fasta> @quote monad
13:54:47 <lambdabot> dons says: First you had to get the monads, then you get the power, then you get the women.
13:54:55 <Cin> fasta: ah. well, irssi showed \x for me before setting unicode. and α should look like an 'a', not a lambda...?
13:55:07 <fasta> The quotes don't get better ^^
13:55:14 <b_jonas> Saizan: ah, you mean "lib" as a variable
13:55:16 <b_jonas> sorry
13:55:17 <monochrom> @quote monad
13:55:17 <lambdabot> samc says: monads are hard, let's go shopping
13:55:26 <fasta> Heh
13:55:26 <b_jonas> I thought it was a command
13:55:36 <b_jonas> "ghc-pkg list" works
13:55:40 * monochrom goes shopping
13:55:54 <Saizan> b_jonas: heh, sorry, i'm not good at quasiquoting :)
13:56:18 <fasta> Version 0.0 of software?
13:56:18 <Saizan> ghc-pkg list <package-name>
13:56:31 <fasta> That's a new low version number record.
13:57:09 <b_jonas> also, I have to make sure to run the ghc-pkg for the right ghc (or I should just uninstall the old one from the debian package)
13:57:13 <monochrom> 0.0 is reserved for when you have just created directories for your new project but no content yet.
13:57:20 <Cin> re glz's comment, probably more because every mention of monads by spj or haskell tutorials say "monad has some complex math behind it, but basically all you need to know is..." it's like, you're too dumb to understand it but you can use them. plus there's the fact that there are a hundred tutorials for monads
13:57:40 <b_jonas> Cin: not all are like that
13:58:05 <dbueno> I have a program that uses throwDyn/catchDyn: my main function does "f >>= print" where f :: IO Bool, and I get "<<loop>>" in my output.  That string doesn't occur in my program.  Does anyone know why?
13:58:15 <monochrom> That is certainly one way to interpret it. The way for those who do have an inferiority complex.
13:58:24 <b_jonas> I mean, http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html doesn't try to tell that message
13:58:27 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
13:58:41 <Cin> b_jonas: well, it annoys me when they make it a special case. i'd have preferred if it was presented as transparently as the rest of haskell
13:59:02 <b_jonas> Cin: yeah, some tutorials obviously do that
13:59:07 <daba> http://tipovidaba.bloger.hr/
13:59:08 <daba> http://tipovidaba.bloger.hr/
13:59:08 <daba> http://tipovidaba.bloger.hr/
13:59:09 <daba> http://tipovidaba.bloger.hr/
13:59:09 <lambdabot> Title: K L A  E N J E...
13:59:09 <lambdabot> Title: K L A  E N J E...
13:59:10 <lambdabot> Title: K L A  E N J E...
13:59:10 <lambdabot> Title: K L A  E N J E...
13:59:11 <daba> http://tipovidaba.bloger.hr/
13:59:11 <monochrom> For those of us healthy people who don't have an inferiority complex, it means "yay, you're going to tell us relevant things!"
13:59:11 <b_jonas> they present it the wrong way
13:59:12 <lambdabot> Title: K L A  E N J E...
13:59:13 <daba> http://tipovidaba.bloger.hr/
13:59:14 <Saizan> dbueno: that's when ghc can spot a infinite recursion
13:59:14 <lambdabot> Title: K L A  E N J E...
13:59:15 <daba> http://tipovidaba.bloger.hr/
13:59:16 <lambdabot> Title: K L A  E N J E...
13:59:17 <daba> http://tipovidaba.bloger.hr/
13:59:18 <lambdabot> Title: K L A  E N J E...
13:59:18 <b_jonas> BAN IT
13:59:19 <daba> http://tipovidaba.bloger.hr/
13:59:20 <lambdabot> Title: K L A  E N J E...
13:59:21 <daba> http://tipovidaba.bloger.hr/
13:59:22 <lambdabot> Title: K L A  E N J E...
13:59:22 <Cin> λ knights, transform!
13:59:23 <daba> http://tipovidaba.bloger.hr/
13:59:24 <lambdabot> Title: K L A  E N J E...
13:59:25 <daba> http://tipovidaba.bloger.hr/
13:59:26 <lambdabot> Title: K L A  E N J E...
13:59:27 <daba> http://tipovidaba.bloger.hr/
13:59:28 <lambdabot> Title: K L A  E N J E...
13:59:30 <daba> http://tipovidaba.bloger.hr/
13:59:30 <b_jonas> lambdabot, ignore daba
13:59:31 <lambdabot> Title: K L A  E N J E...
13:59:39 <basti_> lol
13:59:53 <byorgey> b_jonas++  nice work! =)
14:00:02 <b_jonas> byorgey: I don't tihnk it was me
14:00:04 <monochrom> haha
14:00:07 <dbueno> Saizon: Wow, that's impressive.  Okay ... can anyone help me spot it?  I'll paste.
14:00:07 <Cin> monochrom: well, not really
14:00:07 <byorgey> b_jonas: heh, I know
14:00:09 <hpaste>  dbueno pasted "MicroSat" at http://hpaste.org/5565
14:00:30 <fasta> Cosmic power brought to you by b_jonas.
14:00:51 --- mode: ChanServ set +o Saizan
14:01:16 <b_jonas> Saizan: too late
14:01:23 --- mode: ChanServ set +o dons
14:01:25 <Saizan> i'm testing
14:01:28 <Cin> monochrom: it's not that tutorials say you are dumb, it's that you feel like you are missing out on details
14:01:37 <Saizan> i never get chanserv to work when i need to
14:01:40 <monochrom> A lawyer saying "intellectual property laws are very complex, but basically all you need to know as a programmer is..."  does NOT mean the lawyer thinks you are too dumb to understand it.
14:01:45 <oerjan> the ops are restless tonight
14:01:56 <vincenz> I missed the action
14:02:05 --- mode: Saizan set -o Saizan
14:02:26 <vincenz> @remember Cin (upon seeing a spammer0 λ knights, transform!
14:02:27 <lambdabot> Good to know.
14:02:28 <Cin> monochrom: well i think that analogy isn't the same thing
14:02:32 <vincenz> @quote cin
14:02:33 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
14:02:35 <vincenz> @quote knights
14:02:36 <lambdabot> Cin says: (upon seeing a spammer0 λ knights, transform!
14:02:52 <Cale> sarehu: Hey, did you file a GHC bug for that setResourceLimit problem?
14:03:05 <b_jonas> Cin: thanks
14:03:07 <b_jonas> good night now
14:03:12 <Cin> vincenz :P
14:03:24 <Cin> b_jonas: welcome
14:03:45 --- mode: ChanServ set -o dons
14:04:01 <oerjan> @pl \a b c d e -> d b a c e
14:04:02 <lambdabot> (flip .) . flip (flip . flip id)
14:04:06 <dons> http://reddit.com/r/programming/info/687vx/comments/
14:04:15 <dons> evan_tech (At google now) on hackage, and the google charts binding
14:04:35 <monochrom> Alright. Just add me as a data point that I don't feel all the feelings you felt when I read those "complex math but basically".
14:05:22 <Philippa_> Cin: as a programmer, you really don't need to care about the full generality of the CT definition of monads
14:05:23 <Cale> dbueno: You're aware that in bcp, l' is defined as filter f l' ?
14:05:42 <Philippa_> you definitely don't need category, functor and natural transformation defined for you in order to work effectively with them
14:05:43 <oerjan> @pl \a b c d e f g -> g a b d e f c
14:05:44 <lambdabot> ((flip . ((flip . ((flip . (flip .) . flip) .) . flip) .) . flip) .) . flip . flip id
14:05:46 <dbueno> Cale: Err ... thanks. =O
14:06:10 <Cale> dbueno: I just loaded the code up in ghci, then :set -fbreak-on-exception and :trace main
14:06:23 <Cale> Waited a while and hit Ctrl-C
14:06:35 <Cale> (which throws an exception)
14:06:46 <Cin> philippa: well, i agree. that was not really my point, but my original point has been misconstrued enough so i will retract it
14:06:49 <Cale> :back and :list gave me that part of the code :)
14:07:04 <dbueno> Cale: Ah, :back.  Right.
14:07:26 <dbueno> I had done the same thing (except with -fbreak-on-error), and just didn't go :back.  Thanks.
14:07:26 <b_jonas> oh, one more thing
14:07:44 <fasta> Cale: :back never helped me solve a debugging problem (maybe it doesn't work well with ST).
14:07:50 <b_jonas> is there an easy way (is it worth) to install the ghc runtime libraries to a computer but not the compiler?
14:07:58 <b_jonas> so you can run compiled programs
14:07:59 <Philippa_> Cin: I agree that often the phrasing and timing is a bit offputting, yeah
14:08:13 <Cale> fasta: It's usually important, because typically exceptions get thrown from compiled code which you can't :list
14:08:32 <darrint> Is is possible to make an existential an instance of Typeable and data?
14:08:52 <monochrom> IMO it pays to be a good reader with strong will.  Insensitive to offputting wordings.  Just focus on the story.
14:08:54 <lispy> Cale: suppose I still have my Foo data from before.  I want to make a monad instance, instance Monad Foo where..., and I want the Foo to be a container of the first type parameter (the one with kind * -> * -> *) Is there syntax for this?
14:09:23 <Cale> lispy: Monad (Foo a x) ?
14:09:35 <Philippa_> monochrom: IME that varies a lot, and something with a lot of off-putting wording will tend to do a worse job of imparting intuitions
14:09:35 <Cale> lispy: Didn't your Foo have three type parameters?
14:09:42 <Philippa_> which, let's face it, are what monad tutorials are about
14:09:55 <lispy> Cale: yes, it's data Foo a x y, the x and y are just existentials, the a is what the Foo is containing.
14:10:19 <Cale> lispy: Uh, but the 'a' isn't really what it's containing, because there are no values of type a
14:10:33 <Cale> (a :: * -> * -> *)
14:10:40 <b_jonas> Philippa_: parse error
14:10:41 <lispy> Cale: right
14:11:10 <lispy> Cale: what I want is something like instance \a -> Monad (Foo a x y) where
14:11:18 <Cale> dbueno: After changing the l' to an l, I get stopped at  ([_],_):_ -> error "length 1?"
14:11:22 <lispy> Cale: if you understand what I mean...
14:11:24 <Philippa_> b_jonas: monad tutorials aren't generally there to tell you the facts - you've already got those, or had them after the first one
14:11:36 <Cale> lispy: But that's not even the right kind to be a monad.
14:11:44 <dbueno> Cale: Yeah, me too.  That was what I was expecting (though the code is buggy anyway).
14:12:06 <Cale> lispy: Monads have kind (* -> *)
14:12:08 <lispy> Cale: \a -> instance Monad (Foo a x y) where, in that case :)
14:12:24 <lispy> Cale: I know, I'm at a loss to explain how I want the types to work out.
14:12:25 <fax> :t let __ = __ in (([__],__):__)
14:12:30 <lambdabot> forall t t1. [([t], t1)]
14:12:33 <Cale> lispy: Whereas that type function would have kind  (* -> * -> *) -> *
14:12:43 <Cale> which isn't appropriate for a monad.
14:13:50 <lispy> Cale: 1) so there isn't really a syntax to express what I want, 2) Monads would not be compatible with it?
14:13:57 <Cale> right
14:14:11 <Cale> It might be some other kind of combinator library, but it's certainly not a monad.
14:14:35 <lispy> Cale: thanks
14:14:41 <Cale> To express what you want, you'd at least have to move the 'a' parameter so that it's last
14:14:52 <Cale> So that you can write  (Foo x y)
14:15:08 <Cale> Partially applied type constructors are the closest thing we have to type lambdas.
14:15:22 <Cale> (That, or newtypes.)
14:15:46 <b_jonas> well, ghc extension allow you to use newtypes as instances
14:15:59 <Cale> b_jonas: That's not an extension
14:16:05 <monochrom> There is a fabled "type compose" operator.
14:16:05 <Cale> But it would still have the wrong kind to be an instance of monad.
14:16:18 <Cale> Yeah, Conal has a library for that :)
14:16:56 <b_jonas> Cale: it isn't? I'll look that up
14:17:15 <Cale> b_jonas: There's an extension for newtype deriving.
14:17:26 <Cale> b_jonas: But just writing instances for newtypes has always been okay.
14:17:44 <Cale> (In fact, that's one of the original reasons for newtype to exist.)
14:17:45 <b_jonas> Cale: oh, I meant type, not newtype sorry
14:17:57 <b_jonas> type synonyms
14:22:58 <darrint> I did it! I made a heterogeneous list of typeables and a function to extract the one which matches a predicate.
14:23:03 * darrint does a little dance.
14:23:11 * byorgey high-fives darrint 
14:23:46 <Cale> dons: I like how your posting about cabal-install to that guy's livejournal is "anonymous", but not really anonymous :)
14:23:48 * monochrom high-exp(sqrt(log n * log log n))'s
14:23:52 <oerjan> er, heterogeneous Typeable, isn't that essentially Dynamic?
14:24:18 <byorgey> Cale: hehe, I noticed that too =)
14:29:47 <dons> Cale, oh heh. i was sitting in w3m, and i wouldn't log in using openid
14:29:53 <gwern> @where HaXml
14:29:53 <lambdabot> http://haskell.org/HaXml
14:30:15 <pastorNC> @src seq
14:30:15 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:30:34 <monochrom> seq is primitive or very close to primitive.
14:31:43 <monochrom> There ought to be an @spec command that lists all the axioms concerning the identifier in question.
14:32:21 <monochrom> It will relieve half of the uses of @src.
14:42:26 <gwern> haxml is odd... are you allowed to have 'true' or 'false' in flag sections for defaults and not True/False?
14:48:00 <gwern> @where Text.UTF8
14:48:01 <lambdabot> I know nothing about text.utf8.
14:48:33 <Spockz> Sleep well everybody
14:48:34 <Spockz> :w
14:51:02 <JohnMeacham> RPMs and tarballs of jhc now available! enjoy!  http://repetae.net/computer/jhc/drop/
14:51:03 <lambdabot> Title: Index of /computer/jhc/drop
14:56:23 <JohnMeacham> dons: now that jhc has handy tarballs and releases that can build out of the box, how about getting nobench back to checking compilers?
14:57:35 <gwern> jhc works now?
14:58:05 <JohnMeacham> gwern: as much as it always did. more or less. but now it is easier to install.
14:58:23 <JohnMeacham> hmm.. I need to update the docs.
14:59:27 * gwern idly wonders how hard it'd be to cabalize jhc
14:59:41 <gwern> hm. no INSTALL or README?
15:00:11 <dons> JohnMeacham: hmm. sounds good. i'm not sure i have time to run nobench (i think malcolmw is using it though)
15:00:34 <gwern> (ouch. C.FFI blows chunks on me. I must've missed a configure option or something)
15:03:29 <JohnMeacham> gwern: you need the new DrIFT installed.
15:04:06 <JohnMeacham> I should work on including pre-processed sources in the tarball...
15:04:33 * gwern goes looking for DrIFT - cabal-install fails me
15:05:47 <gwern> ' Sat Feb  9 02:18:49 EST 2008  John Meacham <john@repetae.net>: tagged wubgipkamcep'
15:06:04 <BMeph> DrIFT is part of the HaXml package, isn't it?
15:06:26 <gwern> BMeph: I'm working on haxml from darcs, and I havne't seen it yet
15:07:08 <JohnMeacham> gwern: no, DrIFT is its own project. http://repetae.net/computer/haskell/DrIFT
15:07:09 <lambdabot> Title: DrIFT Homepage
15:07:22 <gwern> wow. drift isn't even cabalized
15:09:30 <bos> olsner: the llvm-c bindings will be in llvm 2.2
15:10:14 <olsner> bos: yeah, I ended up installing llvm from svn (remembered I actually had a source tree lying around)
15:10:30 <taruti> cos
15:10:33 <olsner> checked the svn log and saw they didn't make it until after the 2.1 release tag
15:11:56 <JohnMeacham> gwern: there is no reason to cabalize drift, it is a project. autoconf is much more powerful anyway.
15:12:03 <JohnMeacham> I mean it isn't a library.
15:12:17 <dons> cabal is for apps though, and if its not cabalised, no one can find it on hackage.
15:12:21 <dons> nor install it with cabal-install
15:12:38 <dons> xmonad's a similar case, and hmp3, and lots of other apps on hackage -- cabal means peopple can find and use the tool
15:13:01 <dons> cpphs is cabalised and on hackage, as are other preprocessors
15:13:09 <dons> so i think it makes perfect sense for DrIFT to be there.
15:13:09 <BMeph> JohnMeacham: That was me sking about DrIFT - gwern was pointing your site out to me. :)
15:13:26 <gwern> I have an expression - if it isn't on Hackage, it doesn't exist
15:13:34 <BMeph> Well, pointing our your project, not the site, anyway.
15:13:40 <JohnMeacham> dons: I really think hackage needs a way to deal with autoconf/automake style packages. I should say, I have no issues with creating a '.cabal' file to describe the project to hackage, but I don't want to use cabal as the build system at all.
15:13:58 <dons> so it does. you generate the ./configure script, and include it in the bundle
15:14:07 <dons> cabal then lets you set build-type: Configure
15:14:13 <dons> several of the ffi bindings use autoconf sutff
15:14:35 * gwern points out you can do pretty much arbitrary stuff in the Setup.hs as well. first-class config languages ftw
15:14:42 <dons> i fear projects that aren't cabalised are pretty much doomed to obscurity now
15:14:58 <JohnMeacham> dons: but I still want the main way people build the project be ./configure && make install.
15:15:00 * dons notes: cabal install cpphs works
15:15:07 <dons> sure, so you'd include a Makefile as well
15:15:19 <dons> you could support building either way, but since no one uses make anymore for haskell, it seems pointless
15:15:32 <mgsloan> sept gtk2hs
15:15:36 <dons> $ cabal install DrIFT
15:15:37 <dons> cabal: user error (Unresolved dependencies: DrIFT
15:15:38 <dons> :(
15:15:46 <mgsloan> which I just attempted to build from source
15:15:47 <gwern> I mean, I had to look up how to have configure install to ~/bin; configure/make is pretty hostile to my workflow
15:15:47 <mauke> install: build; runhaskell Setup.lhs install
15:15:50 <dons> i build pretty much all my haskell stuff with 'cabal install' now
15:16:12 <gwern> mgsloan: yeah; ghc, darcs, and gtk2hs seem to be the biggest projects which don't use cabal
15:16:26 <gwern> and I think that's because in part they're in difficult situations
15:16:36 <dons> yeah, very large pre-cabal projects have an excuse
15:16:38 <mgsloan> probably
15:16:45 <JohnMeacham> dons: that is too bad, monocultures are bad. cabal needs a whole lot of work IMHO and is nowhere close to the usefulness of automake.
15:17:03 <mgsloan> Setup.hs: Package yi-0.4 can't be built on this system.
15:17:08 <dons> it's a bit worrying if DrIFT is complicated enough such that the current toolset doesn't support it
15:17:11 <mgsloan> this means that it can't see my gtk2hs, right?
15:17:16 <gwern> I mean, GHC can't really be cabalized because you need to have GHC before you have Cabal, for example
15:17:17 <Cale> > getSequenceByID "A000001"
15:17:22 <lambdabot>  Just [1,1,1,2,1,2,1,5,2,2,1,5,1,2,1,14,1,5,1,5,2,2,1,15,2,2,5,4,1,4,1,51,1,2...
15:17:26 <mgsloan> I just installed gtk2hs from darcs, but who knows if the old version is still kicking around
15:17:37 <gwern> mgsloan: iirc, doesn't yi build if it can get either gtk, vty, or cocoa?
15:17:50 <dons> JohnMeacham: so you don't use cabal or cabal-install/hackage for tools now?
15:17:56 <mgsloan> well, I want to use the gtk frontend, so..
15:17:57 <Cale> > fmap description $ lookupSequenceByID "A000001"
15:17:58 <lambdabot>  Just "Number of groups of order n."
15:18:05 <mgsloan> I've used gtk2hs in the past. not sure what version
15:18:22 --- mode: ChanServ set +o dons
15:18:25 --- kick: snookler was kicked by dons (dons)
15:18:26 -snookler(n=fototrix@cpe-74-71-129-135.twcny.res.rr.com)- Visit http://www.ComedySearchEngine.com or make free images & funny ecards on http://www.txt2pic.com ;)  -
15:18:40 <Cale> ban
15:18:48 --- mode: ChanServ set +o Cale
15:18:57 <JohnMeacham> jhc uses about 4 different custom preprocessors for haskell files, and full dependency analysis is essential for compiling in less than a few hours. I don't think cabal should even try to be a general build tool, a really nice build tool in haskell would be cool, but if we wanted to write that, there is no need to tie it to cabal. it seems like an independent project.
15:19:04 <gwern> mg          build-depends: gtk>=0.9.12 && < 0.9.13
15:19:13 --- mode: Cale set -b *!*@gateway/tor/x-e6c7442fee77cf15
15:19:15 --- mode: Cale set +b *!*@cpe-74-71-129-135.twcny.res.rr.com
15:19:28 <dons> i added it to chanserv too
15:19:30 --- mode: ChanServ set -o dons
15:19:37 --- mode: Cale set -o Cale
15:20:08 <Cale> > foldr f z [1..10]
15:20:11 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 z)))))))))
15:20:34 <Cale> whee! :)
15:20:41 <gwern> mgsloan: actially, I recall why that stringent build-depends was put in - gtk2hs changed some type sigs or something
15:20:49 <Cale> > scanl f z [1..3]
15:20:50 <lambdabot>  [z,f z 1,f (f z 1) 2,f (f (f z 1) 2) 3]
15:21:11 <mauke> > z
15:21:12 <lambdabot>  z
15:21:17 <mgsloan> > f
15:21:17 <lambdabot>  Add a type signature
15:21:19 <Cale> > (x + y)^2
15:21:21 <lambdabot>  (x + y) * (x + y)
15:21:21 <mgsloan> :t f
15:21:22 <lambdabot> Not in scope: `f'
15:21:32 <Cale> > (x + y)^5
15:21:33 <lambdabot>  (x + y) * (x + y) * ((x + y) * (x + y)) * (x + y)
15:21:43 <monochrom> > [z, z, z, z, z]
15:21:44 <lambdabot>  [z,z,z,z,z]
15:21:57 <mauke> > z + 1
15:21:58 <lambdabot>  z + 1
15:22:09 <mgsloan> 0_o
15:22:17 <mauke> custom type/show instance
15:22:22 <Cale> > foldr (+) 0 [a,b,c,d,e]
15:22:23 <mgsloan> that's pretty cool
15:22:23 <lambdabot>  a + (b + (c + (d + (e + 0))))
15:22:25 <monochrom> % z + 1
15:22:41 <mauke> > sin x
15:22:42 <lambdabot>  sin x
15:22:58 <monochrom> You have a computer algebra system. :)
15:23:05 <mgsloan> > map f [1..]
15:23:05 <lambdabot>  Add a type signature
15:23:11 <monochrom> "lambdabot can integrate calculus"
15:23:14 <gwern> @pl xmlParse nm = fst3 ○ runParser (toEOF document) emptySTs ○ xmlLex nm
15:23:14 <lambdabot> (line 1, column 21):
15:23:14 <lambdabot> unexpected "\151"
15:23:14 <lambdabot> expecting variable, "(", operator or end of input
15:23:14 <mauke> > x ** z
15:23:15 <lambdabot>  x**z
15:23:22 <twanvl> > map f [1..] :: [Expr]
15:23:26 <lambdabot>  [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10,f 11,f 12,f 13,f 14,f 15,f 16,f 17...
15:23:34 <mgsloan> ahh
15:23:39 <gwern> @pl xmlParse nm = fst3 . runParser (toEOF document) emptySTs . xmlLex nm
15:23:40 <lambdabot> xmlParse = ((fst3 . runParser (toEOF document) emptySTs) .) . xmlLex
15:23:40 <gwern> bah. Unicode now!
15:23:46 <monochrom> I don't think anyone knows ○
15:24:01 <gwern> ah. I was wondering why just dropping nm didn't work
15:24:23 <sclv> > foldl f [1..10]
15:24:29 <sclv> > foldl f z [1..10]
15:24:30 <lambdabot>  f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
15:24:37 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [t])
15:24:42 <sclv> totally awesome.
15:24:59 <gwern> @pl dtdParse nm = fst3 ○ runParser justDTD  emptySTs ○ xmlLex nm
15:24:59 <lambdabot> (line 1, column 21):
15:25:00 <lambdabot> unexpected "\151"
15:25:00 <lambdabot> expecting variable, "(", operator or end of input
15:25:07 <Cale> > foldr (:) [d,e,f] [a,b,c]
15:25:13 <lambdabot>  [a,b,c,d,e,f]
15:25:14 <gwern> @pl dtdParse nm = fst3 . runParser justDTD emptySTs . xmlLex nm
15:25:14 <mauke> > toInteger x
15:25:15 <lambdabot> dtdParse = ((fst3 . runParser justDTD emptySTs) .) . xmlLex
15:25:19 <lambdabot>  Exception: not a number
15:25:23 <waern> JohnMeacham: full dependency-analysis is actually being added to Cabal
15:25:28 <mauke> > x == z
15:25:29 <lambdabot>  False
15:25:41 <mauke> > x == x
15:25:42 <lambdabot>  True
15:25:53 <Svrog> @seen conal
15:25:53 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
15:25:58 <mgsloan> >x**z == x**z
15:26:06 <mgsloan> > x**z == x**z
15:26:06 <lambdabot>  True
15:26:13 <JohnMeacham> like, a lot of the development of cabal seems to be about adding new pre-canned scripts for various compilers or common idioms, but that breaks down at some point and using cabal fails poorly when you just need something slightly more than it gives you. Adding more pre-canned stuff to cabal is one solution, but requiring people upgrade cabal to use a project of mine is completely unacceptable and it circumvents the main issu
15:26:13 <JohnMeacham> e that cabal isn't flexible enough to be a real build system.
15:26:28 <Cale> > foldr ((:) . f) [] [1,2,3] == map f [1,2,3]
15:26:29 <lambdabot>  Add a type signature
15:26:36 <Cale> > foldr ((:) . f) [] [1,2,3] == (map f [1,2,3] :: [Expr])
15:26:37 <lambdabot>  True
15:26:45 <mgsloan> > (map f [1..] :: [Expr]) == (map f [1..] :: [Expr])
15:26:49 <mgsloan> :)
15:26:49 <lambdabot> Terminated
15:26:52 <mauke> > f ()
15:26:53 <lambdabot>  Add a type signature
15:27:01 <Cale> > f () :: Expr
15:27:02 <lambdabot>  f ()
15:27:07 <mauke> > f () () :: Expr
15:27:08 <lambdabot>  f () ()
15:27:17 <mauke> this is evil
15:27:19 <sclv> > f undefined :: Expr
15:27:20 <lambdabot>  Undefined
15:27:25 <JohnMeacham> waern: but why? a true build system would be a cool project, but it should be decoupled from cabal I think. and it should be able to evolve independently. Good, novel, dependenecy analysis is an open field of research.
15:27:37 <dons> JohnMeacham: i understand that cabal isn't suitable for building jhc, nor ghc. but DrIFT would be easy enough.
15:27:57 <conal> Svrog: howdy
15:28:07 <dons> and would immediately mean more people could use the tool
15:28:07 <Svrog> oh hi conal :)
15:28:10 <twanvl> > take 5 $ iterate reduce $ sum [1..4]
15:28:11 <lambdabot>  [0 + 1 + 2 + 3 + 4,1 + 2 + 3 + 4,3 + 3 + 4,6 + 4,10]
15:28:12 * gwern doesn't quite understand. why should a build system be decoupled from cabal? isn't that what it is?
15:28:19 <Svrog> i got your email and i think i see what you mean about caching
15:28:28 <conal> Svrog: super.
15:28:29 <Svrog> its something i havent checked before
15:28:34 <Svrog> but ive just ran some tests
15:28:37 <monochrom> What is cabal? Is it a web browser?  <duck>
15:28:38 <Svrog> and it appears it still works
15:28:39 <waern> JohnMeacham: yes, and I think the build system for Cabal could be packaged independentyl
15:28:52 <Svrog> give me a sec - ill put the test into hpaste
15:28:57 <JohnMeacham> dons: true, but I feel it is counterproductive. I would include a hackage file certainly.
15:29:44 <conal> Svrog: did you also see the haskell-cafe conversation "threads + IORefs = Segmentation fault?" ?
15:29:49 <dons> there's no feasible alternative to cabal on the horizon, and it just works for 100s of packages, so i figure its time to be pragmatic
15:29:50 <Cale> > take 5 . iterate reduce $ foldr (+) 0 [a,1,2,3]
15:29:52 <Svrog> no
15:29:52 <lambdabot>  [a + (1 + (2 + (3 + 0))),a + (1 + (2 + 3)),a + (1 + 5),a + 6,a + 6]
15:29:55 <JohnMeacham> waern: well, I don't think there shoud be 'the build system', there should be a variety of them.
15:29:59 <Cale> > take 5 . iterate reduce $ foldl (+) 0 [a,1,2,3]
15:30:00 <lambdabot>  [0 + a + 1 + 2 + 3,0 + a + 1 + 2 + 3,0 + a + 1 + 2 + 3,0 + a + 1 + 2 + 3,0 +...
15:30:12 <Svrog> i dont often check haskell-cafe - i'll definitely check now
15:30:29 <waern> JohnMeacham: well, currently there's only one being worked on :)
15:31:03 <conal> Svrog: http://www.nabble.com/threads-%2B-IORefs-%3D-Segmentation-fault--td14964507.html
15:31:08 <lambdabot> Title: Nabble - Haskell - Haskell-Cafe - threads + IORefs = Segmentation fault?, http://tinyurl.com/3co62s
15:31:28 <gwern> don't let the perfect be the enemy of the good
15:31:39 <hpaste>  Svrog pasted "caching in reactive" at http://hpaste.org/5566
15:31:55 <Cale> unsafePerformIO is named such for a reason.
15:32:05 <JohnMeacham> dons: but I'd hate to get locked in a corner. I mean, the project is a good one, but I think it needs some fundamental restructuring before it is too late. the move to cabal-install instead of a library is a good step.
15:32:13 <gwern> everytime I hear someone say something like 'we should have choice, even though there's a perfectly fine alternative most of the community is standardizing on', I get chills and for some reason I keep thinking of common lisp
15:32:53 <Svrog> conal: i wrote the test function in c cause i felt more comfortable that ghc would not try to optimize it out - both with my changes and without them test get's called twice - once for each e1 event
15:32:55 <conal> I like the perspective on unsafePerformIO that it's for (carefully) extending the RTS.
15:32:57 <sclv> > take 7  $ iterate reduce $ foldr (*) 1 [5..10]
15:32:58 <lambdabot>  [5 * (6 * (7 * (8 * (9 * (10 * 1))))),5 * (6 * (7 * (8 * (9 * 10)))),5 * (6 ...
15:32:59 <gwern> @pl keep = \x → [x]
15:32:59 <lambdabot> (line 1, column 6):
15:33:00 <lambdabot> unexpected "="
15:33:00 <lambdabot> expecting variable, "(", operator or end of input
15:33:04 <Cale> conal: yeah
15:33:12 <gwern> @pl keep = \x -> [x]
15:33:12 <lambdabot> keep = return
15:33:34 <gwern> @pl keep = \x -> [] -- return ()?
15:33:34 <lambdabot> keep = const []
15:33:53 <gwern> hm. is 'const []' = '[]'?
15:33:57 <JohnMeacham> And I hate to see innovation stifled. especially when it doesn't need to be.
15:34:03 <conal> Svrog: do you mean you don't get caching even in my original implementation?
15:34:20 <Svrog> conal: actually i mean that both seem to cache events
15:34:28 <Svrog> in the same way
15:34:36 <idnar> > const [] $ 5
15:34:37 <lambdabot>  []
15:34:39 <gwern> no, I guess it'd be 'return [] == const []'
15:34:51 <mauke> @src (->) return
15:34:52 <lambdabot> return = const
15:34:53 <JohnMeacham> waern: not at all, there are a ton of build systems out there to chose from. make, cook, mk, theoretical cabal-build project to be split off from cabal.
15:35:27 <conal> Svrog: really?!  i'm very surprised.
15:35:27 <JohnMeacham> I actually wrote a clone of plan 9's 'mk' in haskell a while ago.
15:35:48 <Svrog> conal: first e1 event occurs only once and  the result is used 3 times to compute e1 + e2 for each e2
15:36:10 <Svrog> conal: then the 2nd e1 event occurs again just once and  the result is again used 3 times to compute the same thing
15:36:12 <Cale> I'm really surprised at how often people want to use unsafePerformIO just to allocate an IORef. Personally, I don't see what's so hard about just creating the IORef in main and just passing it to where it's needed.
15:36:14 <JohnMeacham> i think it would integrate very well with cabal. it had basic support for compiling to portable 'sh' (like the cook system) so bootstrapping was a non-issue.
15:36:43 <Svrog> conal: err i mean e1 occurs once, test_c is applied just once and  the result of that appears to be cached
15:36:47 <waern> JohnMeacham: ok, ok, sure. I just mean that only one is actively worked on for inclusion at the moment.
15:36:56 <Cale> (or better yet, passing the partial applications of readIORef and writeIORef)
15:37:20 <JohnMeacham> Cale: it can horribly break abstractions. like, my atom type in jhc which is needed for speed would fail horribly if it were used with different sets of internal state.
15:37:21 <conal> Svrog: okay.  i'll look at your code again to see why i thought it wouldn't cache.
15:37:23 <monochrom> That doubles the number of parameters.
15:37:58 <waern> JohnMeacham: it would be cool if Cabal could have pluggable build-systems, sure
15:38:14 <monochrom> But I think Cale is not dismissing the rare, judicious uses.
15:38:31 <JohnMeacham> Cale: I agree that sometimes people do that when they don't need to, but other times it is actually necessary. though, I would like to see my 'foreign data' proposal implemented which would get rid of a lot of uses of unsafePerformIO newIORef, and it is really annoying to have to invoke a C compiler when I don't actually need any C code for a project.
15:38:35 <mgsloan> Zippers can be used to represent cool things like all even numbers, and such.
15:38:43 <mgsloan> just thought I might throw that out
15:38:57 <monochrom> How to use zippers to represent all even numbers?
15:39:29 <gwern> > [0,2..]
15:39:30 <mgsloan> > ([(-2),(-4)..], 0, [2..])
15:39:32 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
15:39:32 <lambdabot>  ([-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30,-32,-34,-36,-38,-4...
15:39:49 <mgsloan> you're forgetting the negatives
15:39:52 <monochrom> I see.
15:40:12 <gwern> god gave us the naturals; all else is the work of man
15:40:40 <sarehu> lies, all he gave was 1 and EOF
15:41:04 <osfameron> no 0?
15:41:23 <Cale> It's often the case that by lifting that passing of state to a global IORef, people just end up losing generality without gaining anything except to avoid passing some parameter around.
15:41:25 <mgsloan> there's a 0. it's what the zipper'
15:41:27 <mgsloan> s finger is on
15:41:34 <JohnMeacham> I think a common idiom is to implement your API generally in a way that can take state as an argument, then for an individual project implement a singleton to hold your global state when needed but such a thing shouldn't be in a library. of course, I always prefer a custom monad, newtype MIO a = (Reader (IORef Env) IO a) deriving(Monad,MonadIO) is a great idiom. but sometimes it can't work. like foreign callbacks that requir
15:41:34 <JohnMeacham> e a pure IO callback.
15:41:59 <mgsloan> with lists you can only represent sequences which are infinite in one direction
15:42:02 <sclv> evens = 0 : (uncurry merge $ (\x -> (x,map map negate x) $ map (2*) $ [1..])
15:42:17 <sclv> s/map map/map/
15:42:23 <JohnMeacham> though, providing a (continuation :: MIO a -> IO a) that returns an IO action that performs something in the current MIO context is often possible and really clean when your monad permits.
15:42:38 <mgsloan> yah, that's one way to do it
15:42:48 <Cale> JohnMeacham: Yeah.
15:43:45 <sclv> mgsloan: and now, to get it in the same order as your zipper, all we have to do is sort it!
15:43:48 <JohnMeacham> NewtypeDeriving++, I use so many custom monads due to it. it really makes type errors much easier to find and error messages easier to parse.
15:43:59 <mgsloan> sclv - lol
15:44:30 <olsner> @karma NewtypeDeriving
15:44:30 <lambdabot> NewtypeDeriving has a karma of 0
15:44:54 <Cale> JohnMeacham: Yeah, newtype deriving probably gets an award for best usefulness/implementation difficulty out of the various extensions to the language I can think of :)
15:45:51 <JohnMeacham> indeed. I can't wait for one of the more powerful variations that are being proposed becomes standard.
15:46:25 <twanvl> I can't wait for anything to become standard, h' seems to be taking forever
15:46:54 <Cale> I'm not so worried about standards. They're nice as long as they happen at some point.
15:47:07 <Cale> But locking things down is not always the best idea.
15:47:07 <OceanSpray> case parse lispExpr "screw" content of
15:47:09 <OceanSpray>     Left err | isInfixOf "unexpected end of input" (show err) -> readExpr content
15:47:17 <JohnMeacham> twanyl: yes. I think we need to come out with a proto-standard soon. A lot of things have been decided on, let's formalize those as haskellprimealpha1
15:47:21 <OceanSpray> is there a better way to do this?
15:47:42 <Cale> There are lots of things I'd like to change from Haskell 98, and which probably won't be any different in Haskell'
15:47:47 <JohnMeacham> which would include just language changes. then work on library changes separately.
15:48:24 <Cale> I want to see some work going into Haskell 2 (which would be presumably some major code-breaking changes version of Haskell)
15:49:02 <JohnMeacham> well, haskell' will not be fully backwards compatible. so propose anything major for it. haskell' is allowed to break old code.
15:49:19 <Philippa_> only so much, though
15:49:42 <Philippa_> it probably shouldn't break anything that wasn't previously alpha-equivalent to code that's still valid
15:49:57 <Cale> Okay. First off, I'd bring back monad comprehensions and MonadZero. Remove fail, fix the translation of do-notation.
15:50:04 <JohnMeacham> is there anything completely radical that needs to change? the module system is the main one I want to. (not counting library issues)
15:50:11 <Cale> Flip the associativity of ($)
15:50:29 <Cale> Fix the numeric hierarchy a bit. Adopt class aliases.
15:50:38 <Cale> Fix the functor/monad hierarchy.
15:50:47 <JohnMeacham> oh. and I would love class aliases, so we actually can experiment with all those changes you just said without having to modify the language blind.
15:50:47 <Cale> Generalise (.)
15:50:48 <mgsloan> unify composition / mapping
15:50:49 <mgsloan> yeah
15:50:55 <mauke> add Applicative while you're at it
15:50:57 <monochrom> OceanSpray: Yes. Shallow solution: look into Text.ParserCombinators.Parsec.Error for observers of ParseError. Deep solution: I think you could re-design the parser altogether for that conditional choice.
15:50:58 <Cale> right
15:51:02 <twanvl> Cale: yes, except for the (.)
15:51:16 <Cale> (.) = fmap is awesome
15:51:20 <Philippa_> Cale: fixing the translation of do notation breaks monad comprehensions being used as list comprehensions now though, no?
15:51:34 <Cale> Philippa_: hm?
15:51:36 <OceanSpray> re-design the parser itself?
15:51:57 <Philippa_> sorry, not quite. But monad comprehensions'd need a subclass with fail still
15:52:01 <Cale> Philippa_: How's that? I'm actually suggesting doing it exactly like Haskell 1.4 did.
15:52:08 <Philippa_> and then you'd have a situation where monad comprehensions and do aren't quite equivalent
15:52:13 <monochrom> Add more backtracking and <|>.
15:52:18 <Cale> We'd have MonadZero
15:52:24 <twanvl> I think do should continue to work as it does now, only if you use pattern matches (and therefore fail), you get a MonadZero type
15:52:40 <Philippa_> yeah. But that doesn't buy you anything if you need MonadZero just to write do a <- b; c
15:52:43 <Cale> Pattern matching against a failable pattern would introduce a MonadZero context.
15:52:52 <JohnMeacham> I mean, I am all for generalization, but ambiguity errors are a big problem in practice and practical issues are hard to predict. we don't want another monad comprehension debacle. any changes will have to be put into use for a while. (which incidentally is why I want the 'two-part' standardization, because hopefully the language changes will include features that will allow better experimentation when it comes to library ch
15:52:52 <JohnMeacham> anges)
15:53:00 <Cale> Otherwise, you'd stay in Monad
15:53:07 <Philippa_> for paranoid values of "failable", presumably
15:53:36 <Cale> A pattern is failable if it involves matching against a constructor for a type which has more than one constructor.
15:53:49 <twanvl> Philippa_: you could always force the issue by using an irrifutable match if you are sure
15:53:57 <Cale> Right.
15:54:02 <JohnMeacham> I dunno. 'True <- return assertion   is a great little assertion mechanism.
15:54:09 <Cale> I suppose I could have been more precise there :)
15:54:27 <JohnMeacham> ~True <- return assertion  doesn't quite have the same effect :)
15:54:32 <twanvl> Why not write "guard assertion"?
15:54:39 <ddarius> JohnMeacham: Not quite.
15:55:01 <JohnMeacham> twanvl: because that also uses 'fail'.
15:55:05 <Cale> JohnMeacham: We'd presumably also have MonadFail or MonadError or some such.
15:55:33 <Cale> We also still have error.
15:55:43 <Cale> (which is what fail amounts to in most monads anyway)
15:56:07 <Cale> The problem with fail is that it conflates two very different things.
15:56:18 <JohnMeacham> which is just fine by me.
15:56:27 <Cale> I find it very upsetting.
15:56:54 <dmwit> How about (when assertion $ error "you suck")?
15:56:59 <JohnMeacham> nah, it just gives a choice. 'error' is a perfectly valid member of any type in haskell. but changes like this
15:57:11 <twanvl> preferable, we would have mzero/empty in MoanadZero and fail in a sub class MonadError
15:57:14 <dmwit> Oh, I see that Cale already suggested it.
15:57:28 <Cale> twanvl: yeah.
15:57:36 <Cale> twanvl: Or even not a subclass.
15:57:44 <JohnMeacham> dmwit: because often the assertions are more complicated. like (Just [_]) <- return (something that should be just a single element list)
15:58:20 <dmwit> case?
15:58:26 <Cale> Of course, you're free to write an instance of MonadZero for IO which throws an exception. In fact, that's what the current instance does.
15:58:35 <dmwit> But yes, I see your point.
15:58:39 <Cale> and you can even catch that exception
15:58:45 <JohnMeacham> In any case, changes like this can have far reaching consequences. We need a way to test them out in production code first...
15:58:46 <dmwit> Imprecision leads to shorter code in some cases.
15:58:50 <Cale> (so there's an instance of MonadPlus)
15:59:48 <Cale> Classes should be designed so as to satisfy the nicest laws possible. Currently, there's not much you can say about 'fail' in general, which makes it almost useless as an abstraction.
15:59:52 <dmwit> Part of the reason I like Haskell, though, is that it maintains so much precision that other languages don't even think about.
16:00:14 <JohnMeacham> but then it is unclear whether you want 'MonadZero' or 'MonadError' instances for a lot of things, in many cases the callee is not in the right place to make that decision. they should be one in the same.
16:01:22 <sclv> ?seen glguy
16:01:22 <lambdabot> I saw glguy leaving #haskell 3h 15m 19s ago, and .
16:01:54 <Cale> Another thing I really want to see is proper records and variants. I'm presently trying to learn enough about GHC to implement Daan's proposal.
16:01:57 <JohnMeacham> and giving up the error message would be unacceptable, from a practical point of view it is really needed for making debugging of large projects tractable. I do hate that 'error' is catchable though, i think that is the real wart here.
16:02:24 <Cale> What's wrong with error being catchable?
16:02:29 <Cale> (from IO)
16:02:46 <JohnMeacham> Cale: yes. I have a partial implementaion for jhc. I recently posted to the list something with the syntax I used. My only concern there is that we don't get rid of the current 'labeled fields' mechanism.
16:03:01 <Cale> I think there's room in the language for both.
16:03:25 <Cale> The current labelled fields mechanism serves an important purpose for algebraic types.
16:04:38 <JohnMeacham> Cale: it just feels unclean and I think leads to buggy code. I mean, it is theoretically sound but I think it leads to bad practices. the only time I think it shoud be used is in something like 'ghci' like a 'meta-program', but sometimes I see libraries that use 'error' as a failure case that should be catchable.
16:05:22 <Cale> Oh, yeah, that would be bad.
16:05:34 <dmwit> Cale: Are you talking about this? http://www.cs.uu.nl/~daan/download/papers/scopedlabels.pdf
16:05:39 <Cale> dmwit: yes
16:05:42 <twanvl> It is important to be able to catch error for things like runPlugs
16:05:49 <Cale> dmwit: Only with John's idea for syntax :)
16:05:56 <JohnMeacham> Cale: yeah, the variet proposal is much closer to tuples than the current mechanism. which is why I proposed the paren syntax. (x = 1, y = 2). it is both backwards compatable and cleaner in that 'parenthesis imply an anonymous data type' can be counted on.
16:05:59 <twanvl> maybe call it unsafeCatchError :)
16:06:14 <JohnMeacham> dmwit: yeah.
16:06:28 <Cale> JohnMeacham: Yeah, and I really like the initial-single-quote for labels idea.
16:06:49 <twanvl> One thing I don't like about Daan's record proposal is that it is too easy to confuse record update and record extension
16:06:55 <JohnMeacham> twanvl: oh, catching error from IO is perfectly safe. and things like interpreters are fine, it still bugs me to see it misused though.
16:07:19 <Cale> twanvl: Just syntactically?
16:07:20 <JohnMeacham> so, my objection is not entirely rational.
16:07:25 <twanvl> Cale: mostly
16:07:40 <Cale> twanvl: Well, that can be fixed, I think/hope.
16:08:14 <Cale> JohnMeacham: I also really dislike the "Monad as failure" idiom.
16:08:28 <Cale> (of course, that goes in line with the rest of what I've been saying)
16:08:44 <JohnMeacham> I thought adding them to jhc would be easy, but the changes are more pervasive than I thought they would be. I thought I could get by with a simple desugaring with only front end changes, but it seems like i might need a new 'kind' in my intermediate language to represent such types.
16:08:46 <ddarius> MonadZero as failure
16:08:56 <Cale> ddarius: That would be much nicer, I think.
16:09:09 <JohnMeacham> ddarius: only if we keep the string argument.
16:09:28 <Cale> JohnMeacham: Well, you at least need a new kind for row types.
16:09:30 <JohnMeacham> even if many instances throw it away.
16:09:36 <twanvl> I also would love to see record fields as functional references.
16:09:57 <twanvl> I am getting sick of writing "\st -> st { field = .. }"
16:09:58 <dmwit> twanvl: Agreed, funrefs are very fun.
16:10:04 <ddarius> JohnMeacham: MonadError
16:10:04 <Cale> I could probably live with MonadZero having a fail method.
16:10:31 <Cale> But that's still somewhat odd.
16:10:50 <Cale> Types should explain what's really available.
16:11:08 <dmwit> MonadError errortype?
16:11:12 <sclv> So... MonadFail MonadPlus and MonadZero then?
16:11:17 <twanvl> Cale: it is useful to write fail "short explanation", even when it is used as empty, so later on you could find out what kind of failure/empty it was if needed.
16:11:19 <Cale> If there's going to be a String available to explain the error, I'd like to see that in the type.
16:11:39 <JohnMeacham> Cale: yeah, the only issue I have with the 'foo syntax is that precidence makes it a bit more verbose when mixed with infix operators. but I think it is much more haskelly.  being able to say (map 'x points) to get your x coordinates out just feels right.   [  p.x | p <- points] just doesn't feel right. suddenly introducing a postfix thing is also odd.
16:11:41 <Cale> So that I know before I go looking for it.
16:11:58 <Cale> JohnMeacham: Right.
16:12:01 <twanvl> (.x) could be a section
16:12:10 <Cale> JohnMeacham: We *really* don't want to overload (.) anymore.
16:12:18 <JohnMeacham> Cale: but there is always a string. it may often be "mzero" but that is just fine.
16:12:27 <Cale> I actually am totally opposed to the fact it was used as the module separator.
16:12:47 <olsner> hmm, couldn't record syntax be reused for arbitrary named-arguments support?
16:12:48 <twanvl> I like the 'label idea, only you don't want to call your fields x', then you would get 'x'
16:12:49 <Cale> Something like the pipe symbol would have been far more appropriate.
16:13:31 <Cale> Function composition is possibly the most important operation in functional programming, along with more general functor application.
16:13:44 <JohnMeacham> twanvl: yeah, we will probably have to disallow ' in record labels. which is not too bad I think.
16:13:56 <Cale> It's really unfair to overload its notation with completely unrelated meanings.
16:14:13 <twanvl> ascii is too small
16:14:22 <JohnMeacham> and disallow capital letters, as we might think of some other use for 'Foo in the future. like first class labels or something.
16:14:22 <ddarius> f x = f . x' where x' = const x
16:15:25 <Cale> It'll also come in handy in the notation for variants.
16:15:32 <Cale> (using case to pattern match)
16:16:00 <Cale> Because without that quote, you'd end up with some strange cases.
16:16:13 <Cale> (I think)
16:16:28 <JohnMeacham> in daan's system labels arn't fully first class are they? I guess. I am not exactly sure what I mean by first class labels.. hmm...
16:16:41 <twanvl> One problem with the quote is that it is not used consistently, should you write ('x = 1, 'y = 2)?
16:16:45 <Cale> Well, I don't think they're *values*.
16:17:10 <waern> he has an earlier paper with first-class labels though
16:17:15 <waern> I bet you've seen it
16:17:17 <Cale> twanvl: yes, you should.
16:17:43 <Cale> (I think)
16:18:09 <Cale> Another option would be to make 'label into not a field extractor, but a lens.
16:18:09 <twanvl> 'x :: ArrowRef (~>) => Record ~> Field ?
16:18:59 <Cale> But I'm not entirely convinced of how useful that would be.
16:19:28 <Cale> It would involve using some other function to actually do the extraction, which adds syntactic weight when that's all you want.
16:20:05 <twanvl> Cale: no, if you overload them like that, you get extraction in the (->) arrow
16:20:14 <Cale> mm....
16:20:21 <Cale> okay, that would be nice.
16:21:09 <Cale> JohnMeacham: Have you seen my (slightly crazy) proposal regarding (.) ?
16:21:25 <Cale> I've tried it a bit, and I really like it though.
16:21:47 <ddarius> :t fmap fmap fmap
16:21:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:22:26 <Cale> ddarius: I like how well  fmap . fmap  explains the (.) . (.) trick
16:22:48 <twanvl> Cale: I still think you need a different operator for functor application, (.) as in function composition, just doesn't make enough sense.
16:22:50 <ddarius> Cale: I agree with that there.
16:23:04 <lispy> Cale: would arrows have had the same higher kind issues that I was having earlier with Monads and my Foo type?
16:23:16 <Cale> twanvl: You'd still have map for a prefix notation for the same.
16:23:24 <lispy> Cale: I ask because arrows seem to generalize monad...
16:23:30 <lispy> but I know nothing about them.
16:23:48 <twanvl> Cale: my point is that fmap/<$> is not *composition*, but *application*
16:23:50 <Cale> Arrows generally have kind (* -> * -> *)
16:24:12 <Cale> twanvl: (.) is application too, in the (->) e functor.
16:24:15 <glen_quagmire> is there a builtin trim function? String -> String. trim whitespaces
16:24:34 <Cale> glen_quagmire: nope.
16:24:39 <twanvl> Cale: but not in all categories / arrows
16:24:52 <glen_quagmire> > dropWhile isSpace "   aa  "
16:24:54 <Cale> glen_quagmire: You could use something like unwords . words, but that does more than trim the whitespace at the ends.
16:24:57 <lambdabot>  "aa  "
16:25:10 <Cale> twanvl: hm?
16:25:15 <glen_quagmire> > dropWhile isSpace . reverse $ dropWhile isSpace "   aa  "
16:25:16 <lambdabot>  "aa"
16:25:24 <lispy> > takeWhile (not.isSpace) "    aa    "
16:25:25 <lambdabot>  ""
16:25:38 <lispy> hrm...
16:25:43 <sclv> > dropWhile isSpace . reverse $ dropWhile isSpace "  abcd   "
16:25:44 <lambdabot>  "dcba"
16:25:47 <lispy> guess you need to drop first :)
16:25:51 <sclv> you need another reverse.
16:25:56 <lispy> > takeWhile (not.isSpace) "aa    "
16:25:58 <lambdabot>  "aa"
16:26:02 <glen_quagmire> > unwords . words "  abc   "
16:26:04 <lambdabot>  Couldn't match expected type `a -> [String]'
16:26:17 <Cale> twanvl: If (~>) is an Arrow, then (~>) a is a functor, and (.) :: (b -> c) -> (a ~> b) -> (a ~> c)
16:26:18 <lispy> > unwords . words $ "    abc   "
16:26:18 <lambdabot>  "abc"
16:26:33 <lispy> > unwords . words $ "    a  b  c   "
16:26:37 <lambdabot>  "a b c"
16:26:39 <dmwit> > let doubleUp = join (.) in doubleUp (takeWhile isSpace . reverse) "    aaaa    "
16:26:40 <lambdabot>  "    "
16:26:46 <dmwit> Oh, right.
16:26:51 <dmwit> > let doubleUp = join (.) in doubleUp (dropWhile isSpace . reverse) "    aaaa    "
16:26:51 <lambdabot>  "aaaa"
16:26:55 <twanvl> Cale: But for (.) to be a proper composition of morphisms, you want (.) :: (b ~> c) -> (a ~> b) -> (a ~> c)
16:27:08 <Cale> twanvl: That's an internal composition in the arrow.
16:27:14 <sclv> dmwit: nice :-)
16:27:21 <Cale> twanvl: Both have their uses.
16:27:49 <twanvl> Cale: right, but this one is composition in the categorical sense.
16:27:51 <glen_quagmire> > unwords . words $ "  a  b  "
16:27:52 <Cale> twanvl: But that already has the notation (>>>), and there's arrow syntax.
16:27:52 <lambdabot>  "a b"
16:28:04 <sclv> > unwords . words $ "  a               b  "
16:28:05 <lambdabot>  "a b"
16:28:11 <glen_quagmire> yup
16:28:46 <glen_quagmire> it should be linear. but using reverse . dropWhile, it's like expensive
16:28:54 <sarehu> that's linear
16:28:56 <Cale> glen_quagmire: It's linear.
16:29:16 <glen_quagmire> O(2n) is still linear
16:29:19 <twanvl> Cale: functor application also has an infix operator, (<$>)
16:29:26 <sclv> they're all linear. so it doesn't really matter.
16:29:35 <twanvl> Let the fight for (.) begin!
16:29:37 <Cale> twanvl: But functor application is more important than general arrow composition.
16:29:54 <sclv> use a sequence or maybe a bytestring if you want better than that...
16:30:05 <Cale> I'm pretty sure that if you look around, you'll see *way* more fmap/liftM/(.)/map/etc.
16:30:10 <Cale> than >>>
16:30:47 <sarehu> > let { f x [] | isSpace x = [] ; f x xs = x:xs } in dropWhile isSpace . foldr f [] $ "   abc      def ghi-jkl    "
16:30:47 <lispy> ?type (>>>)
16:30:49 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
16:30:49 <lambdabot>  "abc      def ghi-jkl"
16:30:49 <twanvl> Having the operators actually correspond to common usage in mathematics is more important than being able to write slightly shorter code
16:31:03 <Cale> twanvl: I disagree there.
16:31:12 <Cale> (and I'm a mathematician)
16:31:16 <twanvl> then go write in perl :)
16:31:34 <Cale> Notation in mathematics is also pretty flexible.
16:31:41 <Cale> Not everyone uses the same notation.
16:31:48 <sarehu> . doesn't correspond to anything in mathematics anyway... `o` does.
16:31:50 <twanvl> Cale: I think it would be better to steal some other operator for functor application
16:32:03 <Cale> twanvl: Here's my argument.
16:32:37 <Cale> Functor application and function composition, apart from function application itself, are the two most important and common operations in functional programming.
16:33:07 <Cale> Due to this, they should have the shortest and most convenient notation we can afford them.
16:33:34 <Cale> Since they're instances of the same thing, they can both be given the same notation.
16:34:00 <Cale> And this notation should be as short, easy to type, and visually lightweight as possible.
16:34:14 <Philippa_> how does this interaction with the usual Reader instance?
16:34:18 <Philippa_> *interact
16:34:22 <Philippa_> wow, me no speak good
16:34:25 <Cale> Philippa_: as fmap
16:34:30 <shag> when packaging a library with cabal and that library makes use of threads and stuff, do i have to specifiy "-threaded" in the cabal file through "ghc-options" or sth like that?
16:34:34 <Cale> Or you mean the (->) e instance?
16:35:09 <Philippa_> Cale: right
16:35:30 <Cale> In the (->) e functor, fmap is composition.
16:35:44 <Cale> Moreover, if we translate the fmap law:
16:35:53 <Cale> fmap (f . g) x = fmap f (fmap g x)
16:36:01 <Cale> by using the notation (.) = fmap
16:36:05 <Cale> We get:
16:36:15 <Cale> (f . g) . x = f . (g . x)
16:36:24 <Cale> So associativity is necessarily preserved.
16:36:30 <twanvl> My main reason for wanting (<$>) = fmap is that it can be extended to Applicative in a natural looking way, f <$> g <*> h
16:36:45 <lispy> if i came up with something similar to a monad (supports (>>=) and return but for higher kinds) is it possible (using Ghc) to take over do-notation so that it works for my new class?
16:36:53 <Cale> twanvl: Well, we can keep that notation if you like.
16:37:22 <Cale> lispy: no
16:37:32 <Cale> lispy: do-notation is only for the Monad class.
16:37:50 <sarehu> you could write an isString instance ;P
16:37:52 <lispy> Cale: not even using re-write rules (or that one feature i've heard mentioned once, sometihng about rebinable syntax?)
16:38:11 <lispy> rebindable*
16:38:19 <Cale> lispy: The rebindable syntax has limitations.
16:38:48 <lispy> Cale: so i'd have two all my stuff using the output of ?undo ? :)
16:39:00 <Cale> But you could try. I don't really see how your class is anything like monad if what is supposed to be the "result type" is higher-kinded.
16:39:08 <lispy> I'd have to wright all my stuff...geez english i fail
16:39:34 <twanvl> Cale: Maybe we should change (<*>) to (.:), then you can write:  f . g .: h
16:39:42 <lispy> Cale: why is that?
16:39:49 <bogner> how do i use guards in ghci? i don't know how the syntax is supposed to look in non-layout
16:40:07 <Cale> lispy: Type constructors which have kind other than * don't have any values.
16:40:37 <Cale> lispy: Also, what type is bind supposed to have?
16:40:38 <lispy> Cale: okay
16:40:42 <Cale> Normally,
16:40:44 <twanvl> lispy: I remember a blog about rebinding do notation to allow higher kinded monads from about a year ago
16:40:51 <Cale> (>>=) :: m a -> (a -> m b) -> m b
16:40:57 <Cale> But if a :: * -> * -> *
16:40:58 <lispy> twanvl: oh, i would like that blog if you can find it
16:41:03 <Cale> then (a -> m b) is a kind error
16:41:30 <lispy> Cale: in my case, I endedup with this: (>>>=) :: Hopefully a C(x y) -> (a C(x y) -> Hopefully b C(u v)) -> Hopefully b C(u v)
16:41:58 <lispy> Cale: C(x y) = x y (it's CPP macro to deal with compiling without the existentials)
16:42:24 <Cale> Okay, I'll have a closer look after dinner
16:43:03 <lispy> Cale: and I talked to droundy about this and he has a different type signature for a 'Monadish' class that supports the type witnesses in the monad
16:43:44 * lispy wonders where he put that
16:44:06 <OceanSpray> :t hGetLine
16:44:10 <lambdabot> Not in scope: `hGetLine'
16:44:15 <OceanSpray> :t IO.hGetLine
16:44:15 <lambdabot> GHC.IOBase.Handle -> IO String
16:44:20 <OceanSpray> well, dang.
16:44:27 <OceanSpray> how do I handle errors in hGetLine?
16:44:38 <OceanSpray> for example, if I encounter a EOF
16:44:40 <lispy> ?hoogle catch
16:44:40 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
16:44:40 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
16:44:40 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
16:44:47 <lispy> Control.Exception.catch, iirc
16:44:49 <twanvl> lispy: apparently it didn't work: http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
16:44:50 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
16:45:15 <lispy> twanvl: thanks, even a negative answer is useful
16:49:50 <lispy> Cale: I'm going to eat dinner now too.  Not sure if I'll be working on it more tonight.
16:54:03 <JohnMeacham> can someone proofread/sanity check this?  http://repetae.net/computer/jhc/building.html
16:56:27 <shapr> @yow !
16:56:31 <lambdabot> Everywhere I look I see NEGATIVITY and ASPHALT ...
16:56:46 <allbery_b> Development Page link is broken wikimarkup
16:57:56 <allbery_b> otherwise looks okay
16:58:21 <JohnMeacham> hmm.. I guess i need to write a development page then. :)
16:58:38 <allbery_b> :)
16:59:06 <twanvl> "GHC 6.8.2 or better", is hugs better than ghc? :)
16:59:16 <glen_quagmire> I want to convert an expression to postfix. so i think i need stack??
16:59:26 <JohnMeacham> twanvl: perhaps. try to compile jhc with it and find out. :)
16:59:26 <maihem> hi everybody!
16:59:55 <glen_quagmire> eval "= a (1 + (2 3 -))"   returns ==> Expr [Operator "=",Name "a",List [Integer 1,Operator "+",List [Integer 2,Integer 3,Operator "-"]]]
17:00:59 <twanvl> hello maihem!
17:01:20 <allbery_b> hm, is that assignment?  seems like the = is misplaced in that case
17:01:38 <allbery_b> as for stack:  Data.Seq?
17:01:40 <glen_quagmire> allbery_b: it should work out. my language accepts prefix, infix and postfix
17:01:43 <allbery_b> er, Data.Sequence
17:01:53 <glen_quagmire> = a 1   ==  a = 1  == a 1 =
17:02:31 <OceanSpray> :t liftThrows
17:02:34 <lambdabot> Not in scope: `liftThrows'
17:02:35 <twanvl> glen_quagmire: so for each list of three elements you need to determine which is the operator
17:02:38 <OceanSpray> :t IO.liftThrows
17:02:39 <lambdabot> Not in scope: `IO.liftThrows'
17:03:33 <glen_quagmire> twanvl: yup lexer returns (Type a)
17:03:49 <glen_quagmire> I can pattern match   func (Operator a) = ..
17:04:56 --- mode: ChanServ set +o glguy
17:05:26 <twanvl> you want a result like: [Name "a", Int 1, Int 2, Int 3, Op "-", Op "+", Op "="] ?
17:05:35 <glguy> Oh right, warnings... L7, inviting everyone that joins this channel to other channels isn't acceptable
17:06:10 <allbery_b> need help?
17:06:53 --- mode: ChanServ set +o allbery_b
17:07:25 --- mode: glguy set -o glguy
17:08:15 <olsner_> hmm, so, how do exceptions work in haskell? polyparse's lazy parsers apparently return errors as "exceptions" within pure values somehow
17:08:47 --- mode: allbery_b set -o allbery_b
17:09:04 <allbery_b> olsner_: pure code can throw exceptions but they can only be caught in IO
17:09:10 * olsner_ finds Control.Exception
17:09:31 <glen_quagmire> twanvl: yup
17:10:03 <glen_quagmire> or just, "a 1 2 3 - + ="
17:10:04 <OceanSpray> I am in quite a bind.
17:10:10 <OceanSpray> :t catch
17:10:11 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:10:18 <olsner_> oh, so I have to do everything in IO for that... kind of sucks... perhaps I should find a way for my parser to always succeed and return som kind of error token
17:10:27 <twanvl> glen_quagmire: Then what I would do is: 1. recursivly put the operator at the end of each List, and then 2. flatten the expression to a list
17:10:41 <allbery_b> :t Control.Exception.catch
17:10:42 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
17:10:49 <allbery_b> the one in Prelude only works for IO
17:10:52 <OceanSpray> takes an IO action and a function that acts on the error produced, and gives another function.
17:11:01 <gwern> JohnMeacham: "The project is also under darcs revision control, for information on getting the source code from darcs and building it, see the [Development Page|development.html]." <-- looks like the link isn't there
17:11:05 <OceanSpray> But I got my own error type,
17:11:16 <allbery_b> yep, already noted that
17:11:28 <OceanSpray> so, what
17:11:38 <OceanSpray> using COntrol.Exception.catch would solve it?
17:11:41 <allbery_b> see at 19:56
17:11:52 <allbery_b> or equivalent fo ryour timezone
17:11:54 <glen_quagmire> twanvl: oh that'll workout i think. thank you.  i'll try
17:12:13 <allbery_b> OceanSpray:  yes, the one on Control.Exception handles user defined exceptions.
17:12:27 <OceanSpray> I'm not talking about handling user defined exceptions.
17:12:29 <allbery_b> alternately you can avoid exceptions entirely with MonadError
17:12:40 <OceanSpray> I'm trying to CREATE an exception out of the IOError
17:13:11 <allbery_b> hm, rephrase.  s/user defined/programmer-defined/
17:13:23 <JohnMeacham> http://repetae.net/computer/jhc/development.html  - there we go
17:13:25 <glen_quagmire> data A = Foo Int | Bar String ...   func :: Foo Int -> String   won't work
17:13:25 <OceanSpray> the problem is that I'm stuck with the IO a return type, which I just can't seem to force into "IO (Either LispErr String)"
17:13:36 <glen_quagmire> i have to do:  func :: A -> String
17:14:03 <OceanSpray> yes, programmer defined.
17:14:21 <olsner_> would this be a "good" use for unsafePerformIO?
17:14:40 <allbery_b> hm, did you use IO literally instead of wrapping it in a type / newtype?  makes things harder.  I'd switch it to an ErrorT IO
17:14:44 --- mode: ChanServ set +o glguy
17:14:46 <BMeph> JohnMeacham: Confirmed, it shows on the page. Nice. :)
17:14:56 --- mode: ChanServ set +o allbery_b
17:14:59 <OceanSpray> allbery_b, see this:
17:15:02 --- kick: L7 was kicked by glguy (glguy)
17:15:18 --- mode: allbery_b set -o allbery_b
17:15:24 <OceanSpray> wait
17:15:34 <OceanSpray> @hpaste
17:15:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:15:47 <hpaste>  OceanSpray pasted "(no title)" at http://hpaste.org/5568
17:15:52 <OceanSpray> yeah.
17:16:20 <OceanSpray> that (\err -> return (show err)) isn't right.
17:16:36 <olsner_> @type \x -> unsafePerformIO (Control.Exception.catch (return x) (const return Nothing) (return (Just x)))
17:16:38 <lambdabot> Not in scope: `unsafePerformIO'
17:16:41 --- mode: glguy set -b *!*@adsl-67-67-196-168.dsl.austtx.swbell.net
17:16:58 <olsner_> @type \x -> System.IO.Unsafe.unsafePerformIO (Control.Exception.catch (return x) (const return Nothing) (return (Just x)))
17:16:58 <lambdabot>     Couldn't match expected type `m (Maybe GHC.IOBase.Exception)
17:16:58 <lambdabot>                                   -> IO a'
17:16:58 <lambdabot>            against inferred type `IO GHC.IOBase.Exception'
17:17:03 --- mode: glguy set +b *!*@unaffiliated/l7
17:17:05 <OceanSpray> LispM is a whole bunch of monad transformers stacked together.
17:17:13 <glguy> ban list is full :-/
17:17:19 <OceanSpray> It includes ErrorT LispErr
17:17:25 <olsner_> @type \x -> System.IO.Unsafe.unsafePerformIO (Control.Exception.catch (return x) (const $ return Nothing) (return (Just x)))
17:17:26 <lambdabot>     Couldn't match expected type `m (Maybe (Maybe a1)) -> IO a'
17:17:26 <lambdabot>            against inferred type `IO (Maybe a1)'
17:17:26 <lambdabot>     In the first argument of `GHC.IOBase.unsafePerformIO', namely
17:17:30 <OceanSpray> LispErr = IOErr IOError
17:18:01 <OceanSpray> so instead of putting my error type IN,
17:18:06 <OceanSpray> I need to get the IOError OUT
17:18:15 <BMeph> glen_quagmire: Think of the data constructors as functions. You can't make a type out of a function application.
17:18:55 <OceanSpray> \err -> return (IOErr err) wouldn't do, because hGetLine :: IO String
17:19:04 <allbery_b> olsner_: too many arguments
17:19:21 --- mode: glguy set -b *!*=oldmanpr@*.lsanca.dsl-w.verizon.net
17:19:40 <OceanSpray> My, that's a huge ban list.
17:19:58 <glen_quagmire> BMeph: ah thank you
17:20:22 <olsner_> allbery_b: heh, yeah, I was reading the return type as the type of the last argument
17:20:23 <BMeph> Sure. Glad that helped. :)
17:21:48 <BMeph> OceanSpray: Looks like you should just make your error type Dynamic, as per the Exception type description.
17:22:11 <OceanSpray> what's that mean?
17:22:43 <allbery_b> you don't lift/return exceptions, you Control.Exception.throw them
17:23:22 <OceanSpray> I do throw them.
17:23:37 <OceanSpray> I want to do something like:
17:23:47 <BMeph> OceanSpray: <shrugs> That's just what the file says, I haven't looked at using Dynamic types, though.
17:24:00 <BMeph>  "Every kind of system-generated exception has a constructor in the Exception type, and values of other types may be injected into Exception by coercing them to Dynamic "
17:24:14 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/5568#a1
17:24:28 <OceanSpray> but this doesn't work.
17:24:52 --- mode: glguy set -o glguy
17:26:19 <OceanSpray> oh forget this.
17:26:29 <OceanSpray> :t hIsOpen
17:26:36 <lambdabot> Not in scope: `hIsOpen'
17:26:41 <OceanSpray> :t IO.handleIsOpen
17:26:41 <lambdabot> Not in scope: `IO.handleIsOpen'
17:26:44 <OceanSpray> :t IO.hIsOpen
17:26:45 <lambdabot> GHC.IOBase.Handle -> IO Bool
17:26:52 <OceanSpray> alrighty.
17:27:07 <olsner_> @type \x -> System.IO.Unsafe.unsafePerformIO $ Control.Exception.catch (x `seq` return (Just x)) (\e -> return Nothing)
17:27:09 <lambdabot> forall a. a -> Maybe a
17:27:25 <olsner_> would something like this actually work?
17:28:07 <allbery_b> exceptions are, by their nature, exceptional (and hence unpredictable).  hence not pure, and must be in IO.  using unsafePerformIO is likely to not work the way you want
17:28:23 <olsner_> yeah, prolly a better idea to keep the exception handling in a top-level IO block
17:28:59 <BMeph> :t Just Nothing
17:29:00 <lambdabot> forall a. Maybe (Maybe a)
17:30:13 <OceanSpray> If there a shorter way to write (\x -> case x of ...) ?
17:30:37 <twanvl> not in general
17:32:30 <OceanSpray> how about (\x | x = ... | True = ...) ?
17:33:09 <dmwit> How about it?
17:33:24 <dmwit> (It's perfectly valid, if that's what you're asking.)
17:33:26 <OceanSpray> shorter way to write that?
17:33:37 <dmwit> ... shorter than that?
17:34:04 <dmwit> Can you even suggest a sane syntax that would be noticeably shorter than that?
17:34:28 <OceanSpray> I guess I'm asking too much.
17:34:32 <OceanSpray> forget it.
17:36:01 <JohnMeacham> http://repetae.net/computer/jhc/  - okay, they are all linked together now.
17:36:01 <lambdabot> Title: jhc
17:44:26 <hpaste>  OceanSpray annotated "(no title)" with "(no title)" at http://hpaste.org/5568#a2
17:44:33 <OceanSpray> I'm getting:
17:44:42 <OceanSpray> Parser.hs:91:19: parse error on input `|'
17:44:53 <OceanSpray> Is that not a legal use of guards?
17:45:18 <faxathisia> case () of ...
17:45:33 <faxathisia> you can use.. you don't get pattern matching in a lambda
17:45:44 <twanvl> H98 report says: "exp10 -> \ apat1 ... apatn -> exp", so no guards
17:45:46 <faxathisia> well you do.. but only a single pattern
17:46:07 <OceanSpray> well, dang.
17:54:01 <hpaste>  waern annotated "List haddock-2.0 packages" with "(no title)" at http://hpaste.org/5567#a1
18:01:38 <shapr> I just got very confused. It seems that C# has System.IO also, and someone was just asking about it on ##csharp.
18:02:38 <faxathisia> hehe
18:03:05 <JohnMeacham> okay. jhc page mostly redone with links to all the new info and documentation. why is this much harder than writing the compiler to begin with? hmm...
18:04:03 <dmwit> Maybe because Haskell is a nicer language than HTML?
18:04:38 <Zao> You can always use WASH/HTML to generate it :)
18:04:51 <dmwit> That's hardly better.
18:05:10 <dmwit> Although it does pretty much guarantee XHTML-compliance. =)
18:05:14 <Zao> At least it's reasonably valid if it type checks.
18:06:00 <Zao> I wrote a web journal generator with that and sqlite3 the other day.
18:06:06 <Zao> Almost usable :)
18:07:42 <BMeph> OceanSpray: Just curious, but what are you trying to say with "\x | x ->"? If x is True? :)
18:07:56 <OceanSpray> yes
18:08:23 <faxathisia> (when this that) -- might be better, if you make a when combinator
18:08:45 <dmwit> \x -> if x then _ else _
18:08:49 <faxathisia> or name it something else.. you know..
18:14:19 <dons> Zao: using what with sqlite?
18:15:10 <Zao> WASH/HTML and HDBC-sqlite3, building a set of static pages.
18:15:53 <Zao> A couple of hours quick hacking because I didn't want to install php and mysql to get me a blog :P
18:16:00 <dons> cool.
18:16:05 <dons> you should stick it up on hackage.
18:16:09 <dons> gwern: we should get wash on hackage
18:16:57 <rnorris> today's beginner question: can anyone point me to an example of resumable exceptions/computations in haskell? the MonadCont stuff claims to support this but i can't seem to hack it up myself .. i don't understand the type system well enough to package up k in a way that allows me to return it in an exception. blah.
18:17:08 <Zao> The HTML component still builds reasonably cleanly with 6.8.2, by the way.
18:17:53 <Zao> dons: In the future, maybe. It's rather site-specific thus far, unfortunately.
18:18:59 <ddarius> rnorris: All you do is throw the continuation of the current computation as the exceptional value.
18:21:13 <dbueno> Do throwDyn/catchDyn behave like raise/try..catch from OCaml?  I could read the paper, but, I thought maybe I could get a quicker answer here.
18:22:04 <ddarius> dbueno: They are exception raising and catching things, yes, but they work with Haskell's exception systems which is different from O'Caml's.
18:22:48 <dbueno> ddarius: So I'm implementing some code from a paper which implements it in OCaml, using exceptions.  What difference is there?
18:23:07 <ddarius> :t throwDyn
18:23:12 <lambdabot> Not in scope: `throwDyn'
18:23:18 <ddarius> @hoogle throwDyn
18:23:18 <lambdabot> Control.Exception.throwDyn :: Typeable exception => exception -> b
18:23:18 <lambdabot> Control.Exception.throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
18:23:32 <ddarius> @hoogle catchDyn
18:23:33 <lambdabot> Control.Exception.catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
18:23:38 <dbueno> I understand one can only catch exceptions in the IO monad, but, for example, when an exception is thrown, does it propagate to the nearest dynamically enclosing handler?
18:24:07 <ddarius> Yes
18:24:45 <dbueno> Also I'm actually using StateT with IO as the inner monad ... that shouldn't cause any problems (dynamically) w.r.t. exception handling?
18:25:06 <hpaste>  dbueno annotated "MicroSat" with "MicroSat, newer" at http://hpaste.org/5565#a1
18:25:48 <ddarius> dbueno: When the exceptions occur might not be completely obvious.  It may be preferable to use an Error monad if that's doable.
18:25:54 <dbueno> For some reason the code doesn't work; I'm trying to figure out if it's my fault or if the code in the paper is flawed.  I've never used haskell exceptions before, so, I wanted to make sure my mapping the ocaml try..catch to them is okay.
18:26:55 <ddarius> @hoogle throw
18:26:55 <lambdabot> Control.Exception.throw :: Exception -> a
18:26:55 <lambdabot> GHC.Conc.throwTo :: ThreadId -> Exception -> IO ()
18:26:55 <lambdabot> Control.Exception.throwIO :: Exception -> IO a
18:26:56 <dbueno> ddarius: In the OCaml code, the exceptions are used for control flow -- the code does a big tree search, and the tree is represented implicitly by the code stack -- so when an exception is thrown, it should propagate upward until the place where the search continues.
18:28:06 <ddarius> dbueno: That would be better done using continuations, also the throwDyn's may be happening earlier than you want.
18:28:15 <dbueno> I also haven't seen any examples of using exceptions -- are my usages proper?  Basically I have one variant type per exception, sometimes with data in it, which derives Typeable.
18:29:13 <dbueno> ddarius: I think I agree with you on continuations -- but I'm trying to map the code in the paper as simply as possible into Haskell, to validate it, in the first place.  Then I'll think about CPS.
18:29:26 <dbueno> ddarius: In what way earlier than I want?
18:29:38 <faxathisia> You don't need to write code in CPS to use continuations
18:29:52 <dbueno> faxathisia: Use a monad?
18:30:10 <JohnMeacham> sweet. got rid of the DrIFT requirement. I made a directory called drift_processed which just mirrors the main tree but has any processed files in it. then I make sure it is first in ghcs include path.
18:30:14 <ddarius> dbueno: That's one way of doing it.  Usually an error monad is used instead of throwDyn/catchDyn if possible.
18:30:15 <faxathisia> There is a Cont Monad in the standard lib
18:30:37 <JohnMeacham> I just have a make rule  drift_processed/%: % ; DrIFT $< -o $@
18:30:41 <JohnMeacham> quite elegant.
18:30:48 <dbueno> ddarius: You would consider using an error monad even for control flow?
18:31:09 <ddarius> dbueno: It's less of an abuse than this, but in this case I would use continuation likely via Cont.
18:31:28 <ddarius> Error monads model exceptions.
18:31:32 <JohnMeacham> and I added it to my EXTRA_DIST in automake so the preprocessed versions get included, and no need for DrIFT.
18:31:35 <dbueno> ddarius: "less of an abuse than this" = where this means my current code?
18:31:49 <OceanSpray> :t more
18:31:58 <lambdabot> Not in scope: `more'
18:32:04 <OceanSpray> good.
18:32:16 <ddarius> dbueno: Than using the throwDyn/catchDyn functions, yes.  Though, you are conceptually using exceptions, how you "do" them is mostly irrelevant.
18:32:41 <tehgeekmeister> how do i coerce a fractional to an int?
18:32:47 <tehgeekmeister> (losing precision is fine.)
18:32:48 <sarehu> round, truncate
18:32:53 <ddarius> @src RealFrac
18:32:53 <sarehu> floor, ceiling
18:32:53 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
18:32:53 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
18:32:53 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
18:32:59 <faxathisia> fromIntegral
18:33:07 <ddarius> faxathisia: Wrong way
18:33:19 <faxathisia> oops, I'm sorry
18:33:34 <faxathisia> yeah, fromRational should work in that case?
18:33:38 <dbueno> ddarius: Sure.  Even though you'd do it another way, do you see any obvious problems with my code?  Or just that it's generally unclear when exceptions will be thrown?
18:33:44 <sarehu> :t fromRational
18:33:46 <lambdabot> forall a. (Fractional a) => Rational -> a
18:33:49 <sarehu> ^^ nope
18:34:37 <ddarius> dbueno: throwDyn is like error or undefined (as the type makes clear), it happens when the term is evaluated.  You likely want the exception to happen when the term is "executed" not evaluated.
18:35:29 <tehgeekmeister> hmm. something else must be my problem then.  these numerics always trips me up.  *hpastes code
18:36:03 <dbueno> ddarius: So it might be happening too early?
18:36:52 <ddarius> dbueno: That's a possibility.  I'd have to follow the code more thoroughly to be sure, but throwDyn (alone) is probably not what you want.
18:37:15 <dbueno> ddarius: All right.  So should I look at the Cont monad?
18:37:37 <BMeph> :t toInteger . fromRational
18:37:38 <lambdabot>     Ambiguous type variable `b' in the constraints:
18:37:38 <lambdabot>       `Integral b'
18:37:38 <lambdabot>         arising from a use of `toInteger' at <interactive>:1:0-8
18:37:53 <hpaste>  tehgeekmeister pasted "Problem with numeric types." at http://hpaste.org/5569
18:38:02 <ddarius> dbueno: That would be the cleanest and most conceptually pure way to do what this code does.  The O'Caml code sounds like a hack due to lacking call/cc.
18:38:42 <tehgeekmeister> the problem is in averageTimes and mean, i know this much.  also has to do with the fact that the fields in TimeDiff are of type Int.
18:39:43 <dbueno> ddarius: Well, cleanliness and conceptual purity are great things to be had ... I guess I should study the callCC example.  I've seen call/cc in at least two different PL classes, and it still blows my mind.
18:39:47 <ddarius> dbueno: Alternatively, lazily traversing an explicit tree would quite possibly be the most idiomatic Haskell solution.
18:39:56 <mauke> tehgeekmeister: what's the type of mean supposed to be?
18:40:13 <Saizan> thepointer: mean = fromIntegral (sum xs) / fromIntegral (length xs)
18:40:23 <Saizan> err mean xs = ..
18:40:57 <tehgeekmeister> mauke: [Int] -> Int would work in this case, but i'm honestly so confused by the numeric types I'm not sure what's happening.
18:41:07 * Cale wishes that length had a general type.
18:41:07 <mauke> you want an Int mean?
18:41:15 <mauke> then sum xs `div` length xs
18:41:17 <dbueno> ddarius: Yeah, I thought about that a few moments ago.  It's not clear to me how one "jumps back" higher in the tree from somewhere deep in the tree, if it's explicit.  I guess by hanging onto those places somewhere.
18:41:49 <Cale> @users
18:41:50 <lambdabot> Maximum users seen in #haskell: 461, currently: 435 (94.4%), active: 20 (4.6%)
18:42:07 <tehgeekmeister> mauke: thanks!  that fixed it.
18:42:29 <dbueno> ddarius: In the CPS case, I'd pass explicit "resume here on exception Unsat" continuations to the parts of my Haskell code that, in the OCaml code, correspond to throwing an exception.  Right?
18:42:44 <ddarius> dbueno: You just traverse "the whole" tree and return the first result.  Just stop exploring a subtree if it won't lead anywhere.
18:43:08 <dbueno> ddarius: And in the lazy case, I'd just walk down an explicit (binary) tree, keeping the places where I made decisions on a stack or something, and pop back up the tree when I feel like I don't want to explore anymore.
18:43:28 <ddarius> dbueno: In the lazy case, that stack would be the control stack.
18:43:59 <dbueno> ddarius: Right.  Which is the way it is in the ocaml code, too -- the way they "stop exploring" is by throwing an exception.
18:45:07 <dbueno> ddarius: Hmm.  The important thing, though, is that you need to pass information from the deeply explored part back up to figure out where to resume, along another branch.
18:45:10 <ddarius> dbueno: In the CPS case, you'd pass continuations to jump to for each alternative.
18:45:55 <ddarius> dbueno: For the lazy case, you'd just return those back up the tree.  It would actually rather look like using exceptions.
18:49:01 <dbueno> ddarius: You said the tree should be explicit, right?  I'm still a newbie when it comes to writing lazy code.  The tree, if I understand, is all possible assignments to 2^n variables, starting with some variable at the root.
18:49:11 <litb> hmm
18:49:17 <litb> where is <*> and <$> in ?
18:49:28 <faxathisia> I think it's Control.Applicative
18:49:31 <litb> @hoogle (<*>)
18:49:32 <lambdabot> Did you mean: (<*>)
18:49:32 <lambdabot> Prelude.undefined :: a
18:49:32 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
18:49:47 <litb> omh yeah i meant that lambdabot
18:49:59 <litb> thanks faxathisia
18:51:18 <mauke> @hoogle <*>
18:51:19 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
18:51:54 <ddarius> dbueno: The explicit tree approach is rather (superficially) different from the current code.  It may be best to start with a callCC version, but yes, that sounds more or less right (you may able to avoid generating some early).
18:52:00 <ddarius> You make the tree and then you prune it however.
18:52:07 <litb> @src (->) fmap
18:52:08 <lambdabot> fmap = (.)
18:52:55 <dbueno> ddarius: I'm trying to decide between the "idiomatic" and the "clean and conceptually pure" approaches. =]
18:53:21 * faxathisia recommends clean and conceptually pure
18:53:27 <ddarius> The idiomatic version is clean and conceptually pure too.
18:53:29 <dbueno> I thought maybe it would be easier to do the idiomatic approach, simply because CPS turns your brain inside out.
18:53:57 <ddarius> dbueno: I'd recommend doing both (or as many approaches as possible)
18:54:14 <dbueno> Yeah, I'd like to do both; it's a question of which to do *right now*. =]
18:55:03 <ddarius> Do you actually use IORefs or any IO things at all?
18:55:38 <dbueno> No, no IO refs -- nothing besides the exceptions in IO.
18:55:43 <dbueno> The ocaml version is pure.
18:56:10 <dbueno> They thread the state (the 2-element record) through function params -- so I used the state monad.
18:56:40 <dbueno> ddarius: I only had to use StateT 'cause the exceptions needed IO around.
18:57:43 <dbueno> All right, so I'll do the callCC/Cont version first.
18:58:18 <BMeph> I'll be back - getting odd network errors.
18:58:20 <ddarius> dbueno: Okay, make versions that don't require the IO monad anywhere.
18:58:38 <litb> i wonder whether there is some function that returns "fmap id"
18:59:03 <faxathisia> > (fmap id) (+1) 2
18:59:10 <ddarius> litb: The monad laws require fmap id = id
18:59:12 <lambdabot>  3
18:59:15 <faxathisia> > ($) (+1) 2
18:59:16 <lambdabot>  3
18:59:24 <ddarius> er functor laws (though since monads are functors too)
18:59:35 <patperry> is there a haskell version of bzero?
18:59:41 <dbueno> ddarius: Should I get rid of the State monad too, to make Cont the only monad around?
18:59:50 <patperry> something like bzero :: Ptr a -> a -> Int -> IO ()
18:59:54 <litb> ddarius: oh i see
19:00:13 <ddarius> dbueno: What are you using State for?
19:00:24 <litb> oops, so i cannot make my datatype a functor then :/
19:00:38 <litb> since "id mytype" is not valid :/
19:00:42 <faxathisia> why would you want it to be a functor?
19:01:11 <dbueno> ddarius: This is a sat solver, so, the items of state are: the annotated current assignmnt (Map Lit (Set Lit)) and the current annotated CNF formula ([([Lit], Set Lit)].
19:01:28 <litb> i wanted to do this: fmap id myvalue 10 , and define fmap like: fmap f a = f . (getFunction a)
19:02:05 <litb> so then instead of (getFunction myvalue) 10 , one could just do fmap id myvalue 10 . but looks like that law is restricting me :/
19:02:31 <ddarius> dbueno: If you are using state, use State(T).  What you do is pick the "effects" you need and then use monad transformers (if necessary) to create a monad that supports those effects.
19:03:13 <dbueno> ddarius: Sorry -- I am using StateT, which was embedding IO.  Should I have Cont as the inner monad now?
19:03:39 <ddarius> dbueno: Maybe.  Order matters.
19:03:44 <mauke> patperry: \p x n -> mapM_ (\i -> pokeElemOff p i x) [0 .. n - 1]
19:03:46 <shachaf> litb: The law makes sense, though.
19:04:17 <patperry> mauke: do you think performance will be comparable to bzero?
19:04:23 <mauke> no idea
19:05:13 <patperry> i guess I should at least try it before I assume it's worse
19:05:15 <litb> shachaf: i believe :)
19:05:25 <dbueno> ddarius:  Ooh.  Okay.  Not sure yet how to decide which order.  Probably will need Cont on the outside, since I intend to have complicated control flow, jumping between states?  That reasoning doesn't seem very convincing.
19:05:35 <mauke> you can always use foreign import ccall "string.h memset" c_memset :: Ptr a -> CInt -> CSize -> IO (Ptr a)
19:05:56 <ddarius> dbueno: Usually it's helpful (for me, at least) to look at the types of the run* functions.
19:05:58 <ddarius> :t runCont
19:05:59 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
19:06:01 <ddarius> :t runContT
19:06:01 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
19:06:03 <ddarius> :t runState
19:06:03 <lambdabot> forall s a. State s a -> s -> (a, s)
19:06:05 <ddarius> :t runStateT
19:06:05 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
19:06:30 <patperry> mauke: I'll try both and report back.  thx
19:10:11 <twanvl> dbueno: If you want to jump between states, you need to use StateT s (ContT c IO). A monad transformer wraps something around the inner monad, but it can't escae it. So if you wrap StateT around a continuation monad, then the state will be subject to the continuations. Similarly, the continuations are still linearized in the IO monad, you don't go to a previous/different world with callCC.
19:10:52 <dbueno> twanvl: I'm using Cont in order to be able to chuck IO.
19:11:08 <ddarius> IO should never have been involved in the first place.
19:11:34 <patperry> mauke: speed is comparable (at least, both are negligible compared to the rest of the stuff I'm doing)
19:12:18 <dbueno> The thing is, I know how to write code in CPS -- but I'm not sure how to write stuff in the Cont monad.  Should I write the explicit CPS first, then hand-translate?
19:12:44 <litb> yeah, differentiating works with my Funktion type :)
19:12:46 <faxathisia> dbueno: Just write code with do notation, in Cont
19:12:58 <ddarius> Cont just adds callCC to the "mini-language"
19:12:59 <litb> "sin (Funktion id (Just 1)) `dF` pi" => -1.0
19:14:06 <litb> is it possible maybe to just say "sin id" instead? i just hate saying (Function ...) there
19:14:42 <ddarius> litb: Hide id and make your own.
19:15:02 <litb> oh i see. well that's a nice idea. maybe fid
19:21:11 <hpaste>  monochrom pasted "StateT(ContT IO) \sim ContT(StateT IO)" at http://hpaste.org/5570
19:21:27 * dbueno studies the Cont examples
19:22:14 <glen_quagmire> how can I convert Seq a -> [a] ?
19:22:14 <monochrom> twanvl: I beg to differ. See the paste. Escaping does not revert state, either way.
19:22:23 <glen_quagmire> Data.Sequence.Seq a -> [a]
19:22:35 <litb> ah, i will call it "'x'" what do you think about this name? or is that a bad name ?
19:22:38 <litb> too generic?
19:23:08 <faxathisia> "'x'" O_o
19:23:16 <mauke> glen_quagmire: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html#v%3AtoList
19:23:19 <lambdabot> http://tinyurl.com/23pc9l
19:24:09 <litb> well maybe fid is better tho
19:24:16 <glen_quagmire> mauke: thanks! i wrote until seqToList s | Seq.null s = [] ; |otherwise = foldl (Seq.index..
19:24:25 <twanvl> ?unmtl ContT c (StateT s M) a
19:24:25 <lambdabot> (a -> s -> M (c, s)) -> s -> M (c, s)
19:24:32 <twanvl> ?unmtl StateT s (ContT c M) a
19:24:32 <lambdabot> s -> (a -> s -> M c) -> M c
19:25:28 <litb> where can i read about all numeric ops of haskell?
19:25:33 <twanvl> that doesn't look right
19:25:37 <litb> (like ^ , ** and so on , so i can overload them too)
19:26:19 <monochrom> Here is how.  "instance MonadState s m => MonadState s (ContT r m)" and "instance MonadCont m => MonadCont (StateT s m)"  are carefully coded to fulfill the conspiracy!
19:26:59 <monochrom> In theory, you can code them up to be either multiple-world or single-world as you see fit.
19:27:15 <monochrom> In this world, the author has chosen the single-world one.
19:27:51 <monochrom> Take a look at the source code. The author clearly painstakingly deliberately makes his choice. :)
19:27:51 <Saizan> how'd you write the multiple-world version?
19:28:15 <monochrom> I haven't thought about how.
19:28:24 <twanvl> litb: look at the haskell report, especially the prelude
19:29:45 <twanvl> as for exponentiation, you can only overload (**), it is in the Floating class, the others are defined in terms of (*).
19:31:02 <monochrom> I guess here is how to do multiple-world. In your callCC code, you can record the before-callCC state into the continuation (the "k" in "callCC $ \k -> ..."), so that if the user invokes it, the user gets the old state back.
19:32:38 <Saizan> so k will not only discard its continuation but also the passed state?
19:32:42 <monochrom> OTOH, to get single-world, which is the present case, the continuation notes the latest state and makes sure it overrides the old state during escape.
19:32:51 <monochrom> Yes.
19:32:51 <nottha_k_> Prelude> 3775.80 - 61.70   results in 3714.1000000000004
19:32:55 <nottha_k_> am I doing something stupid?
19:33:11 <Cale> nottha_k_: no
19:33:11 <ddarius> nottha_k_: That's just the nature of floating point.
19:33:16 <monochrom> In short, callCC has enough power and information to do as it wishes.
19:33:26 <mauke> > 3775.80 - 61.70 :: Rational
19:33:31 <lambdabot>  37141%10
19:34:16 <monochrom> You could even code up StateT(ContT) and ContT(StateT) to behave differently, if you wish.
19:34:31 <Cale> nottha_k_: There are necessarily rounding errors as a result of the way that computers typically encode fractional numbers. (Also, even though that doesn't explicitly look like a rounding error as such in base 10, the numbers are really encoded in base 2.)
19:34:52 <Cale> Of course, you can, as mauke points out, use an exact representation of rationals.
19:35:14 <mauke> 0b111010111111.11001100110011001100110011001100110011 - 0b111101.10110011001100110011001100110011001100110011
19:35:22 <dbueno> In example 2 here (file:///Users/Shared/doc/haskell/libraries/mtl/Control-Monad-Cont.html), the value bound to `exit' is `id', right?
19:36:56 <ddarius> dbueno: A file system link is not so useful.
19:37:02 <faxathisia> > 0b111010111111.11001100110011001100110011001100110011 - 0b111101.10110011001100110011001100110011001100110011
19:37:03 <lambdabot>   Not in scope: `b111101'
19:37:17 <dbueno> ddarius: Aggh.  Sorry about that. http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html#2
19:37:17 <lambdabot> http://tinyurl.com/gnsuu
19:38:10 <Saizan> monochrom: too bad we can't write the multiple world version without using information about how State is implemented
19:38:12 <ddarius> dbueno: No.
19:39:17 <ddarius> dbueno: You can tell that from the types.
19:39:46 <dbueno> ddarius: Okay -- exit is a function that will end the do-block that is passed to callCC, exit is called?
19:39:55 <nottha_k_> How do I read that Rational result?
19:40:37 <Cale> nottha_k_: Just read % as /
19:40:56 <Cale> So that's 37141 tenths
19:41:06 <litb_> @hoogle (**)
19:41:06 <lambdabot> Did you mean: (**)
19:41:06 <lambdabot> Prelude.undefined :: a
19:41:06 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
19:41:34 <litb_> something is wrong with it. it ask whether i meant that, but i typed that
19:41:46 <dbueno> ddarius: You're right.  exit returns in a monad, so it can't be id, since the argument is a string.
19:41:48 <twanvl> ?hoogle **
19:41:49 <lambdabot> Prelude.(**) :: Floating a => a -> a -> a
19:41:49 <lambdabot> Control.Arrow.(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:41:49 <lambdabot> Control.Applicative.(<**>) :: Applicative f => f a -> f (a -> b) -> f b
19:42:10 <ddarius> dbueno: exit is conceptually bound to (>>= \response -> return response) plus an "escaping" effect.
19:42:12 <nottha_k_> Cale: ah. thanks. I was just trying to use ghci to calculate my loan payments. now i'm side tracked into reading how computers represent floating point numbers.
19:43:12 <dbueno> ddaries: The ">>= \response -> return response" comes from desugaring the rest of the do-block, under the callCC, right?
19:44:57 <ddarius> dbueno: Yes-ish.  It's easier and sensical to write that then to try to write part of a do block.
19:45:11 <ddarius> But essentially, it's everything after the callCC.
19:45:45 <dbueno> ddarius:Right.  Okay.  I understand at least that bit.
19:45:52 <monochrom> continuations are fun!
19:46:11 <glen_quagmire> if then else doesn't take {} form?
19:46:18 <monochrom> doesn't
19:46:24 <glen_quagmire> lambdabot: layout
19:48:40 <Cale> nottha_k_: http://www.n-heptane.com/nhlab/repos/Decimal/ has an implementation of decimal numbers in Haskell, which is what one would use if one really cared very much about how things were rounded.
19:48:44 <lambdabot> Title: Index of /nhlab/repos/Decimal
19:49:40 <Cale> (btw, someone should add that to hackage)
20:06:32 <glen_quagmire> is there a way to print for debug?
20:06:39 <glen_quagmire> like, inside  a pure function
20:06:50 <dbueno> glen_quagmire: Debug.Trace.trace
20:07:02 <glen_quagmire> thank you dbueno
20:07:19 <dbueno> glen_quagmire. No problem.
20:11:51 <dbueno> Is it possible to use continuations to short-circuit a filter?  I've pasted some fake code to clarify a bit what I mean.
20:11:54 <hpaste>  dbueno pasted "Short Circuit a filter" at http://hpaste.org/5571
20:12:34 <faxathisia> what does it mean to short-circuit?
20:12:35 <monochrom> @hoogle filterM
20:12:37 <Cale> dbueno: Perhaps you want filterM
20:12:41 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
20:12:53 <monochrom> should work.
20:13:00 <dmwit> Maybe you want dropWhile?
20:13:03 <dbueno> faxathisia: Throw away the being-computed result.  I guess it doesn't make a difference in lazy languages, now that I think of it.
20:13:40 <dbueno> Since the filtering process will stop the first time it hits the right condition, and not compute the rest of the filtered result.  Huh.
20:14:00 <dbueno> monochrom: What does filterM buy me?
20:14:14 <dmwit> Or maybe you just want "shortCircuitCondition s && normalFilterCondition s".
20:14:37 <faxathisia> > filter even $ [1..]
20:14:41 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
20:14:50 <dmwit> i.e. if normalFilterCondition is expensive and always correct, but shortCircuitCondition is cheap but gives false positives.
20:14:52 <faxathisia> > head $ filter (==1000) $ [1..]
20:14:53 <lambdabot>  1000
20:14:59 <sarehu> ok, why did my Haskell program just crash X11...:/
20:15:32 <faxathisia> dbueno: You can filter on infinite lists even
20:16:02 <vincenz> > head $ filter (==1000000) $ [1..]
20:16:04 <lambdabot>  1000000
20:16:07 <vincenz> > head $ filter (==1000000000) $ [1..]
20:16:07 <dbueno> Sorry, I don't think I was clear.  I'm translating some OCaml code to Haskell.  The OCaml code basically rolls two tests into one call to "filter": one test will exit the function by throwing an exception when it sees some "bad" thing.
20:16:13 <lambdabot> Terminated
20:16:20 <vincenz> > head $ filter (==500000000) $ [1..]
20:16:25 <lambdabot> Terminated
20:16:28 <dbueno> The normal result is not to see the bad thing, and just collect a bunch of items from the list that match the predicate (i.e. like a normal filter call).
20:16:30 <vincenz> > head $ filter (==100000000) $ [1..]
20:16:36 <lambdabot>  100000000
20:17:02 <dmwit> dbueno: I think that those two things are generally done as two steps in Haskell.
20:17:08 <dmwit> :t find
20:17:09 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
20:17:18 <dbueno> dmwit: Yeah, that makes sense.
20:17:25 <dbueno> Thanks for the help, all.
20:17:47 <dmwit> You could also do it with a fold.
20:18:01 <dmwit> (and judicious use of the Either type =)
20:18:23 <faxathisia> :t any
20:18:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
20:18:40 <dbueno> faxathisia: Yeah, I'm using any.  Thanks.
20:18:42 <faxathisia> dbueno: you can use 'any' to check if any element of a list has some property
20:18:52 <faxathisia> dbueno: and it will short circuit
20:18:56 <faxathisia> @src any
20:18:56 <lambdabot> any p =  or . map p
20:19:01 <faxathisia> @src or
20:19:02 <lambdabot> or    =  foldr (||) False
20:19:52 <dbueno> Using any is in fact how I would have written it, had I come up with the algorithm.  But I've been thinking as little as possibly while converting this code from OCaml to Haskell ... and that is likely the source of all my problems. =]
20:19:55 <dmwit> ?src Either (>>=)
20:19:56 <lambdabot> Left  l >>= _ = Left l
20:19:56 <lambdabot> Right r >>= k = k r
20:20:10 <dmwit> Oh, perfect.
20:22:05 <dmwit> > let findOrFilter filterPred findPred xs = foldr (\x e -> if findPred x then Left x else if filterPred x then fmap (x:) e else e) in findOrFilter even odd [2,4,6]
20:22:08 <lambdabot>  <Either Integer [Integer] -> [Integer] -> Either Integer [Integer]>
20:22:20 <dmwit> oops
20:22:49 <dmwit> > let findOrFilter filterPred findPred xs = foldr1 (\x e -> if findPred x then Left x else if filterPred x then fmap (x:) e else e) in findOrFilter even odd [2,4,6]
20:22:49 <lambdabot>      Occurs check: cannot construct the infinite type: a = Either a b
20:22:50 <lambdabot>       E...
20:23:46 <vincenz> Left l >>= k = case k l of { Left l' -> Right l'; _ -> Left l}
20:23:57 <dmwit> > let findOrFilter filterPred findPred xs = foldr (\x e -> if findPred x then Left x else if filterPred x then fmap (x:) e else e) (Right []) in findOrFilter even odd [2,4,6]
20:23:58 <lambdabot>  <[Integer] -> Either Integer [Integer]>
20:25:39 <faxathisia> @src foldr
20:25:39 <lambdabot> foldr k z xs = go xs
20:25:40 <lambdabot>     where go []     = z
20:25:40 <lambdabot>           go (y:ys) = y `k` go ys
20:26:20 <dmwit> ?hoogle Bool -> a -> b -> Either a b
20:26:21 <lambdabot> No matches, try a more general search
20:26:28 <faxathisia> :t either
20:26:29 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
20:26:40 <faxathisia> hmpf
20:26:54 <dmwit> Wrong way.  We have all these great ways of consuming Maybe's and Either's, and no nice ways of constructing them.
20:27:33 <Cale> dmwit: What's wrong with the constructors?
20:28:01 <dmwit> Cale: What's wrong with the constructors for consuming them?
20:28:31 <dmwit> Obviously, nothing is wrong with it.  Yet at exactly the same token, isn't it nice to have other ways of manipulating them?
20:28:33 <Cale> The constructors don't consume them.
20:28:40 <faxathisia> :t (either Left Right)
20:28:41 <lambdabot> forall a b. Either a b -> Either a b
20:28:42 <dmwit> Pattern matching consumes them.
20:28:46 <Cale> Right.
20:28:51 <dmwit> So I said the wrong words; my point stands.
20:28:56 <faxathisia> > (either Left Right) (Left 5)
20:28:57 <lambdabot>  Left 5
20:29:03 <dmwit> You would much rather use (>>=) than pattern match every time.
20:29:07 <Cale> Well, what combinator do you want?
20:29:20 <dmwit> A few that dealt with Bools would be nice.
20:29:30 <Cale> So something like if' ?
20:29:33 <dmwit> yeah
20:29:52 <dmwit> :t guard
20:29:53 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:30:24 <faxathisia> @hoogle Bool -> (a,b) -> Either a b
20:30:25 <lambdabot> No matches, try a more general search
20:30:47 <dmwit> ensure p x   = guard (p x) >> return x -- is in my standard library
20:31:43 <dmwit> ?instances MonadPlus
20:31:44 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
20:32:19 <dmwit> > let ensure p x = guard (p x) >> return x in ensure even 2 :: Either String Integer
20:32:20 <lambdabot>  Right 2
20:32:27 <dmwit> > let ensure p x = guard (p x) >> return x in ensure even 3 :: Either String Integer
20:32:28 <lambdabot>  Left ""
20:35:11 <faxathisia> :(
20:35:28 <faxathisia> ' can't be an operator or function
20:35:37 <dbueno> So I'm attempting backtracking search using the Cont monad.
20:36:42 <dbueno> At any point in the search, I either return a satisfying assignment, or a conflict (or I continue).  Should my functions have type (Cont r (Either <conflict-info> <sat-assignment>)) -- does that make sense?
20:37:08 <ddarius> :t runErrorT
20:37:09 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
20:37:33 <ddarius> dbueno: That would be ErrorT <conflict-info> (Cont r) <sat-assignment>
20:37:49 <dbueno> ddarius: Okay, but, I'd like to get this to compile, and understand it, with only one monad, if possible.  Because the Cont stuff is confusing enough.
20:39:12 <faxathisia> It can be easier if you use multiple, when that fits better
20:39:18 <ddarius> dbueno: Yes, it makes sense.  I don't know if it's necessarily what you want.
20:39:32 <faxathisia> dbueno, One thing you should check out if you haven't seen it..
20:39:40 <dbueno> All, right, I'll bite.
20:39:42 * dbueno checks out ErrorT
20:39:58 <faxathisia> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
20:39:59 <lambdabot> Title: Monad Transformers Step by Step
20:40:06 <faxathisia> There is ErrorT in there too
20:41:10 <dmwit> Can you export a qualified module?
20:41:48 <dmwit> i.e. if I am writing module Dmwit, can I export module Data.Array as Dmwit.A?
20:42:51 <dbueno> The throwError/catchError stuff seems to compete with what I'm using continuations for.  Shouldn't I structure my control flow with callCC, not throw/catchError?
20:43:00 <ddarius> dbueno: Yes.
20:43:16 <ddarius> dbueno: At least for a continuations based approach.
20:44:56 <ddarius> dbueno: A function A -> Either B C is the same as a function (A,Cont B) -> C
20:45:49 <hpaste>  dbueno annotated "MicroSat" with "MicroSat CPS" at http://hpaste.org/5565#a2
20:45:54 <ddarius> ("Cont" might be somewhat misleading there.)
20:46:08 <glen_quagmire> for func :: [a] -> [a] -> [a] ,   func [] [] = ..   func x [] = x .... func prev@(x:xs) rest@(y:ys) ...  aren't these exhaustive patterns?
20:46:24 <dbueno> Hm, actually, I may have just found the error in the code I pasted.  Sorry about that.
20:46:36 <glen_quagmire> Exception: test.hs:(137,0)-(164,43): Non-exhaustive patterns in function ..
20:46:48 <ddarius> ("function" might be misleading too...)
20:47:08 <dmwit> glen_quagmire: func [] [1]
20:47:38 <glen_quagmire> dmwit: won't it match func prev@(x:xs) rest@(y:ys)
20:47:41 <glen_quagmire> dmwit: oh i seee
20:48:05 <dmwit> glen_quagmire: GHC can warn you about this, if you ask it to.
20:50:58 <dbueno> Thanks for all your help, especially ddarius and faxathasia.  I'm having trouble keeping my eyes open, so I'll look over it again later.  Good night.
20:50:59 <dmwit> ?pl \x y -> f (g x) (h y)
20:50:59 <lambdabot> (. h) . f . g
20:51:51 <dmwit> That... is a very tricky one.
20:52:01 <dmwit> I think I would have trouble coming up with that on my own.
20:53:32 <ddarius> Just think of where the first parameter has to go.
20:53:33 <faxathisia> :t (. ?h) . ?f .? g
20:53:35 <lambdabot>     precedence parsing error
20:53:36 <lambdabot>         cannot mix `(.)' [infixr 9] and `(.?)' [infixl 9] in the same infix expression
20:53:36 <lambdabot> Not in scope: `.?'
20:53:40 <dmwit> Ah, I see it now.
20:53:43 <faxathisia> :t (. ?h) . ?f . ?g
20:53:43 <lambdabot> forall b c a b1 a1. (?g::a1 -> b1, ?f::b1 -> b -> c, ?h::a -> b) => a1 -> a -> c
20:53:55 <dmwit> That's pretty good!
20:57:36 <wagle_home> :t ?(?+ ?1)
20:57:37 <lambdabot> parse error on input `?'
20:58:05 <dmwit> :t (. Left) . ((. Right) .) . if'
20:58:05 <lambdabot> Not in scope: `if''
20:58:23 <dmwit> :t let if' p x y = if p then x else y in (. Left) . ((. Right) .) . if'
20:58:24 <lambdabot> forall a a1. Bool -> a1 -> a -> Either a1 a
20:58:28 <dmwit> Yes!
20:59:19 <dmwit> I guess I kind of cheated in the middle there, though.  This sport of hand-?pl'ing is harder than I thought.
20:59:40 <faxathisia> heh..
20:59:44 <ddarius> Witnessing (one way of) the isomorphism between 2xA and A+A (slightly generalized, a generalization that can be captured with dependent types)
21:00:33 <wagle_home> :t ?h 1 2
21:00:34 <lambdabot> forall t t1 t2. (Num t2, Num t1, ?h::t1 -> t2 -> t) => t
21:01:22 <wagle_home> this ? a haskell thing, or a lambdabot thing?
21:01:27 <dmwit> haskell
21:01:30 <ddarius> GHC
21:01:45 <dmwit> I haven't seen it used much in practice, though.
21:01:55 <dmwit> It does something very similar to the Reader monad.
21:02:02 <dmwit> (If I understood it properly.)
21:02:51 <wagle_home> yeah..  i mostly want to know what type it thinks a piece is when the whole thing doesnt type check
21:03:12 <dmwit> wagle_home: Prefer to stick "undefined" in a few choice places instead.
21:03:32 <wagle_home> :t undefined
21:03:33 <lambdabot> forall a. a
21:03:38 <ddarius> @google "type debugger"
21:03:41 <lambdabot> http://www.cs.mu.oz.au/~pjs/papers/p108-stuckey.pdf
21:03:48 <ddarius> Crap.
21:03:53 <ddarius> @google Haskell "type debugger"
21:03:54 <lambdabot> http://www.cs.mu.oz.au/~pjs/papers/p108-stuckey.pdf
21:03:55 <dmwit> Well... maybe I should say "I would prefer..." rather than phrasing it as a command. =P
21:04:26 <ddarius> I guess that link is suitable.
21:04:45 <ddarius> dmwit: That's how I read it anyway.
21:07:25 <dmwit> Chameleon actually looks pretty nice.  I wonder how it is in practice.
21:09:14 <wagle_home> it sounded, though, that that wasnt the one you were looking for
21:11:49 <bos> @seen dons
21:11:50 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 12m 27s ago.
21:12:21 <Trinithis> with a parsec Parser, how can I do a lookahead? (like a regex lookahead)
21:13:04 <bos> using try.
21:13:20 <bos> if the parse fails, it won't consume any state.
21:13:22 <Trinithis> oh, i thought try was for backtracking
21:13:56 <bos> you can use the backtracking property to give yourself lookahead.
21:14:59 <bos> for example, try (optionMaybe (string "foo")) has type GenParser Char st (Maybe String)
21:15:30 <bos> it will give you Nothing if the lookahead fails, or Just "foo" if it succeeds. either way, it won't consume any of your input.
21:15:47 <Trinithis> so if I want to match "a" in "abc" only if it is followed by a "b", but only consuming "a"
21:16:05 <Trinithis> okay, I'll try that
21:16:15 <bd_> wait, optionMaybe doesn't ever consume input?
21:16:18 * bd_ checks the docs
21:16:42 <bos> optionMaybe can't consume input if it's inside a try.
21:16:56 <bd_> option x p          = p <|> return x
21:17:01 <bd_> optionMaybe p       = option Nothing (liftM Just p)
21:17:14 <bd_> try $ optionMaybe (string "foo") would indeed consume input if it succeeds
21:17:38 <bos> sorry, i misspoke.
21:18:33 <bd_> use the lookAhead combinator
21:18:38 <bd_> :)
21:18:47 <Trinithis> an example perhaps?
21:19:10 <bd_> try (char 'a' >> lookAhead (char 'b'))
21:19:42 <Trinithis> bd_: and that only returns 'a' if matched right?
21:19:44 <bos> lookAhead saves the parser state, runs the parser, then restores the state.
21:20:20 <bos> it won't restore the state if the parser fails, so if you're doing something complicated, you can still consume state.
21:20:41 <Trinithis> bos: I'm just using it for a very simple escape
21:21:14 <bd_> bos: surely the try will restore the state if the context inner to lookAhead fails?
21:21:17 <bos> what kind of escaping?
21:21:26 <bos> bd_: yes, if you combine try and lookAhead.
21:22:15 <Trinithis> bos: a command line type prompt... like :j jumps, :l lists, :: escapes : and prints it
21:22:40 <Trinithis> bos: somewhat simplified, but not by much
21:23:35 <bos> why not just use (char ':' >> (char 'j' <|> char 'l' <|> ...)) then?
21:23:55 <bos> since you'll always want to consume that first colon?
21:24:35 <Trinithis> oh, i see what you mean. guess I just got off on a tangent :D
21:25:07 <Trinithis> ah, I rememeber the problem I had with that
21:26:08 <Trinithis> I'll hpaste my issue
21:30:43 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5572
21:31:04 <Trinithis> alright,my issue is up
21:33:18 <bos> i don't see the problem.
21:35:49 <Trinithis> simply typing in text in the console does is implied to be like the insert command if there is no : to start the line. But if one wants to type in a :, he would have to escape it via ::, much like \\ in c++. not sure if im making much sense though
21:36:32 <bos> i understand what you want, just not what you're finding difficult.
21:37:02 <Trinithis> perhaps its just that ive never written a parser in haskell before :D
21:37:44 <bos> don't misunderstand me: i'm trying to figure out what is causing you a problem, so that i can help you with it.
21:38:39 <Trinithis> i guess that the best way of solving it is to factor out this lone case. I was just trying to put it into the rest of the commands.
21:39:18 <Trinithis> that I'm sure will work
21:39:48 <siti> @paste
21:39:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:41:14 <hpaste>  siti pasted "any way to make accessor be able to access the structure?" at http://hpaste.org/5573
21:42:03 <hpaste>  bos annotated "(no title)" with "one possible approach" at http://hpaste.org/5572#a1
21:42:38 <Cale> Trinithis: If this is a Parsec parser, perhaps you want "notFollowedBy"
21:42:42 <bos> siti: nope
21:43:01 <siti> umm.... arg
21:43:18 <Trinithis> Cale: perhaps not . notFollowedBy :D
21:43:46 <Cale> Oh, lookAhead
21:44:03 <bos> right.
21:44:31 <gwern> @tell dons I abruptly and inexplicably decided to upload Frag to hackage. if you want to send an ANN to haskell-cafe, feel free
21:44:31 <lambdabot> Consider it noted.
21:45:47 <gwern> could someone who has FUSE installed on their Linux system do me a favor and try to cabal-install HFuse?
21:45:48 <shapr> gwern: Did you get it to work on amd64?
21:46:16 <siti> @tell siti testing
21:46:16 <lambdabot> You can tell yourself!
21:46:21 <siti> lol
21:46:35 <gwern> shapr: hfuse?
21:47:13 <gwern> shapr: well, I'm on a 64-bit quad-core; either it works, or I need to see a doctor
21:51:49 <BMeph> shapr: Or were you talking about Frag? ;)
21:52:16 <siti> he would have been talking about frag
21:52:22 <siti> I remember it screwing up on 64bit
21:52:38 <siti> because it had a lot of code that assumed host = 32bits
21:53:04 <gwern> someone else fixed that
21:53:11 <gwern> (hfuse also had a 64-bit problem)
21:53:18 <siti> ok
21:54:36 <solidnail> linux vs mac who wins?
21:54:42 <siti> :S
21:55:26 <piojo> "linux" comes first in a dictionary, but "mac" sums to a much lower number.
21:55:29 <wagle_home> suspend work on my mac notebook..  8-p
21:55:35 <sclv> ?faq can haskell run on both?
21:55:35 <lambdabot> The answer is: Yes! Haskell can do that.
21:55:45 <sclv> case closed.
21:55:51 <wagle_home> rofl
21:56:14 <siti> > True
21:56:17 <lambdabot>  True
21:56:24 <siti> amazing
21:57:08 <gwern> ?faq can Haskell solve the general Halting Problem?
21:57:08 <lambdabot> The answer is: Yes! Haskell can do that.
21:57:40 <siti> what's this ?faq thing?
21:57:52 <gwern> ?faq Can haskell forge a bipartisan consensus on how to handle the Iraq war?
21:57:52 <lambdabot> The answer is: Yes! Haskell can do that.
21:57:59 <siti> ?faq blah
21:57:59 <lambdabot> The answer is: Yes! Haskell can do that.
21:58:10 <faxathisia> *sigh*
21:58:26 <BMeph> ?faq Can Haskell solve the Peak Oil dilemma?
21:58:27 <lambdabot> The answer is: Yes! Haskell can do that.
21:58:48 <siti> ?faq can haskell not do anything?
21:58:49 <lambdabot> The answer is: Yes! Haskell can do that.
21:58:52 <siti> lol
21:58:55 <gwern> (I know it's juvenile, but I still enjoy it)
21:59:04 <BMeph> You're never too unhappy, when lambdabot's around. :)
21:59:40 <piojo> i remember when i tried talking to lambdabot, once
21:59:49 <siti> lol
21:59:50 <dons> ?faq can Haskell do things even Haskell couldn't do?
21:59:50 <lambdabot> The answer is: Yes! Haskell can do that.
21:59:53 <piojo> i thought it was a chat bot (that happened to know a rather lot about haskell)
22:00:07 <faxathisia> heh
22:00:18 <siti> @botsnack
22:00:18 <lambdabot> :)
22:00:20 <gwern> lambdabot: what did you and piojo talk about?
22:00:34 <faxathisia> @vixen How do you use IORefs in StateT?
22:00:34 <lambdabot> yes i do
22:01:07 <dons> ?vixen-on
22:01:08 <lambdabot> What's this channel about?
22:01:18 <faxathisia> ooh :o
22:01:19 <lambdabot> yup
22:01:22 <piojo> umm... it's talking to us
22:01:23 <lambdabot> Wouldn't it be funny if I really was a super model?
22:01:41 <gwern> lambdabot: hysterical
22:01:43 <dons> ?vixen-off
22:01:44 <lambdabot> Bye!
22:01:49 <faxathisia> @vixen How can I exploit lazyness to gain efficiency?
22:01:49 <lambdabot> i think you know the answer to that one, silly
22:01:54 <faxathisia> heheh..
22:01:57 <dons> heh
22:01:57 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
22:02:12 <gwern> @vixen shopping is hard! can we go program?
22:02:12 <lambdabot> i think we could do that
22:02:25 <siti> bots are awesome, we just need to make lambdabot into a physically moving one :D
22:03:35 <wagle_home> ErdosBot...  flies around, helping people solve their problems
22:04:15 <wagle_home> soon people will post their lambdabot numbers
22:05:16 <gwern> we will have 'lambdabot coverage' metrics, analogous to code coverage - how much of your stuff was written by lambdabot functions
22:06:03 <faxathisia> heheh you can tell the line which look like ((.flip ap flip.) flip ( . ap)) (. flip) are lambdabots
22:06:05 <sclv> we need an unlambda backend for ghc.
22:07:05 <gwern> faxathisia: I've seen a few I suspect of that, yes...
22:10:17 <dmwit> > isPrefixOf [3] []
22:10:20 <lambdabot>  False
22:10:26 <dmwit> ?index isPrefixOf
22:10:27 <lambdabot> Data.List
22:11:43 <dmwit> I love it!  My five-liner just became
22:11:55 <dmwit> orderedElem x = isPrefixOf [x] . dropWhile (< x)
22:12:47 <wagle_home> in the advanced programming language seminar, everything could be done in 3 lines of scheme..  hmm
22:13:05 <faxathisia> wagle_home: Where everything is.. ?
22:13:18 <siti> well you can compress any bit of scheme to one line can't you ;p
22:13:30 <wagle_home> problems that take you a week to wrap your brain around
22:13:33 <bd_> wagle_home: Trivially true, as scheme does not assign any semantic signifigance to newlines :D
22:14:58 <wagle_home> "here's the next problem..  blah blah blah..  ok, come back next week with the solution..  it will take only three lines of scheme!"
22:15:09 <wagle_home> everyone screams
22:15:31 <bd_> wagle_home: of course, it would only take one line of haskell, right? :)
22:15:40 <wagle_home> maybe so
22:15:50 <bd_> (the other two lines being close parenthesis)
22:16:29 <wagle_home> we had a "find the minimal length one-line-haskell program" contest in here a year or so ago
22:16:54 <bd_> wouldn't that be something like: main=return() ?
22:17:05 <sarehu> Did it have to do something in particular or did it have to compile?
22:17:18 <wagle_home> oh, it was a a particular problem..  was trying to recall what it was
22:17:21 <dmwit> main=print"" -- already shorter than bd_'s
22:17:38 <wagle_home> yeah, it had to solve the problem
22:17:40 <Cale> main=fix id
22:17:50 <wagle_home> main=0
22:17:51 <adu> hii
22:17:57 <bd_> wagle_home: main needs to be type IO ()
22:18:02 <sarehu> main = what cale said.. :/
22:18:03 <allbery_b> 0 won't typecheck
22:18:12 <bd_> hmm
22:18:16 <bd_> main=fail""
22:18:17 <wagle_home> main=main
22:18:23 <dmwit> nice
22:18:27 <adu> i'm trying to use HOpenGL, and i'm failing miserably
22:18:29 <allbery_b> :t fail
22:18:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
22:18:47 <dmwit> I doubt it can get much shorter than main=main.
22:19:17 <dmwit> Although there's a very small space to search, for those of you into exhaustive search. =)
22:19:30 <hpaste>  adu pasted "using hopengl" at http://hpaste.org/5574
22:19:34 <dmwit> > 60^3
22:19:35 <lambdabot>  216000
22:19:54 <gwern> wow. the jokes are true - jhc does take forever to compile itself
22:20:33 * gwern is impressed by using 32% of my 4gigs, and an entire CPU
22:20:52 <adu> i'm trying to use parts of frag, but I think I don't know enough about what its doing to refactor it
22:20:55 <sarehu> main=pi   -- with appropriate Floating instance
22:21:08 <bd_> main=0 -- with appropriate Num instance
22:21:15 <siti> adu: start simple, there are some haskell conversions of the nehe tutorials
22:21:22 <adu> I've programmed in OpenGL in C and Python, so some of the commands look familiar, is anyone in here familiar with HOpenGL?
22:21:23 <sarehu> main=-1
22:21:25 <sarehu> darn
22:21:26 <gwern> although I will admit, the tree textgraphics are awfully cool
22:21:29 <siti> they don't have perfect code, but you can fix them up as neccesary
22:21:52 <adu> whats nehe?
22:21:53 <dmwit> bd_, sarehu: But then you have to have all that instance code... that *can't* be shorter. =P
22:21:54 <gwern> adu: that's not surprising; frag was pretty messy
22:21:55 <bd_> though, those aren't one liners :)
22:22:23 <sarehu> if you can use control.monad.fix.fix you can use imaginary num instances
22:23:21 <adu> grr, nehe-hs is only available with darcs, I can't use darcs
22:23:39 <siti> :S
22:23:41 <siti> why not?
22:24:07 <adu> siti: I tried './configure' and it says: "configure: error: Couldnt figure out how to call GHC.Handle.openFd!"
22:24:09 <adu> what does that mean?
22:24:20 <siti> don't run ./configure on a haskell app
22:24:30 <adu> then what do I do?
22:24:34 <adu> just make?
22:24:37 <siti> your distro should come with darcs or there should be a compiled version
22:24:44 <siti> the usual setup is:
22:25:25 <siti> runhaskell ./Setup.[l]hs configure && runhaskell ./Setup.[l]hs build && sudo (or su) runhaskell ./Setup.[l]hs install
22:25:30 <adu> o, fink has darcs, I'll use fink
22:25:39 <siti> oh you're on mac :p
22:25:43 <adu> I'm on macosx, so I wouldn't really call that a "distro"
22:26:10 <gwern> yay. JHC finished installing! now to see what it can actually compile, and how that stacks up with ghc-compiled binaries
22:26:53 <kbateman> > 2^100
22:26:55 <lambdabot>  1267650600228229401496703205376
22:27:01 <adu> hmm fink does not have darcs...
22:27:14 <siti> are you on an intel mac?
22:27:22 <adu> siti: nope, ppc
22:27:26 <siti> ok
22:27:39 <adu> so I can't use the wonderful macosx-x86 binaries
22:28:43 <siti> doesn't darcs store the unpacked source files
22:28:43 <adu> siti: there are no Setup.lhs in darcs-1.0.9/
22:28:51 <siti> so you could do a recursive wget?
22:29:49 <adu> I remember reading that there were examples for HOpenGL... is this true?
22:29:56 <adu> like gears
22:30:08 <siti> yeah looks like darcs uses automake instead of cabal
22:30:20 <kbateman> > pl \a b -> a+b
22:30:20 <lambdabot>  Parse error at "\a" (column 4)
22:30:22 <gwern> right
22:30:27 <siti> can't you just download one at a time of the nehe ones?
22:30:27 <vincenz> > 2^10000
22:30:28 <lambdabot>  1995063116880758384883742162683585083823496831886192454852008949852943883022...
22:30:36 <gwern> it, ghc, gtk2hs, and a few other large and old projects don't use cabal
22:30:39 <adu> siti: ya i could do that
22:30:50 <vincenz> > 2^2^2^2
22:30:51 <lambdabot>  65536
22:30:53 <adu> siti: i found it at codersbase.com
22:30:54 <vincenz> > 2^2^2^2^2
22:30:55 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
22:31:12 <vincenz> > 2^2^2^2^2^2
22:31:13 <adu> o they have a tgz... hehe
22:31:18 <lambdabot> Terminated
22:31:33 <adu> ?src bn
22:31:33 <lambdabot> Source not found. You speak an infinite deal of nothing
22:31:58 <sarehu> > 0^0^0^0^0^0^0^0^0^0^0
22:31:59 <lambdabot>  0
22:32:01 <sarehu> soo fast
22:32:08 <faxathisia> > 0^0
22:32:09 <lambdabot>  1
22:32:16 <faxathisia> Why is that useful?
22:32:41 <kbateman> pl f a b = a+b
22:32:42 <adu> > 0.0 ** 0.0
22:32:43 <lambdabot>  1.0
22:32:47 <sarehu> When taking something to an integral power you generally mean x^n = product (replicate n x)
22:32:50 <kbateman> > pl f a b = a+b
22:32:51 <lambdabot>  Parse error at "=" (column 10)
22:33:24 <faxathisia> sarehu: Yeah, It makes sense to define ^ on N.. check it's properties the extend to Z, then Q and finally R
22:33:44 <faxathisia> sarehu: I don't understand where anyone would get a 0^0 def. from though??
22:33:57 <dmwit> ?go Cale 0^0
22:33:58 <lambdabot> No Result Found.
22:34:18 <Cale> hehe
22:34:33 <Cale> faxathisia: n^m is generally the number of functions from a set of size m to a set of size n
22:34:34 <dmwit> I know you have something about that on your wiki, right?
22:34:50 <Cale> Er, I don't know. Maybe in a reddit comment?
22:34:51 <kbateman> > pl f (fix f)
22:34:55 <lambdabot>   Not in scope: `pl'
22:35:30 <Cale> Our general definition of function allows for a function from the empty set to itself.
22:35:43 <dmwit> Don't you have an open letter to that math teacher that decided to define infinity as something screwy?
22:35:49 <Cale> (after all, we want sets to form a category, so there'd better be an identity at least)
22:36:01 <kbateman> > pl \a b -> a+b
22:36:02 <lambdabot>  Parse error at "\a" (column 4)
22:36:04 <Cale> dmwit: Oh, there is that. I didn't really go into much detail on the reasons there.
22:36:09 <kbateman> > pl \ a b -> a+b
22:36:10 <lambdabot>  Parse error at "\" (column 4)
22:36:19 <adu> that is so weird, ghc doesn't make it executable
22:36:38 <faxathisia> number of functions? :S
22:36:39 <Cale> Or at least, I don't think I did :)
22:36:55 <faxathisia> I don't know how that could end up finite
22:37:02 <kbateman> > pl \x y -> x y
22:37:02 <lambdabot>  Parse error at "\x" (column 4)
22:37:29 <sarehu> faxathisia: for finite domain and co-domain, there are finitely many... a function is simply a set of ordered pairs
22:37:35 <sarehu> with a certain property
22:37:37 <dmwit> Oh, you link to http://en.wikipedia.org/wiki/Empty_product#0_raised_to_the_0th_power
22:37:37 <lambdabot> http://tinyurl.com/ymmm3z
22:37:38 <adu> hmm that was less than successful
22:37:45 <Cale> faxathisia: If you'd rather think of it another way, n^m is how many strings of length m there are with n different possible symbols.
22:37:45 <kbateman> > @pl \x y -> x y
22:37:45 <lambdabot>  Parse error at "@pl" (column 1)
22:38:09 <faxathisia> so how does extend to R?
22:38:15 <faxathisia> that ^ *\
22:38:25 <Cale> faxathisia: Well, there are uncountably many functions R -> R
22:38:27 <adu> lesson01 went fullscreen and It had a checkerboard accross the screen, the only way I knew how to stop it was to forcequit
22:38:50 <kbateman> > pl \\x y -> x y
22:38:50 <lambdabot>  Parse error at "->" (column 10)
22:39:01 <sarehu> @pl \x y -> x y
22:39:02 <lambdabot> id
22:39:14 <Cale> faxathisia: (in fact, there are more functions R^R than there are real numbers -- there are as many as there are sets of real numbers)
22:39:25 <kbateman> @pl \a b -> a+b
22:39:25 <lambdabot> (+)
22:39:33 <kbateman> ahhhh.  Thanks sarehu
22:39:37 <sarehu> no prob
22:40:01 <Cale> faxathisia: But that's getting into infinite cardinalities. You don't need to consider those just to define exponentiation on the naturals.
22:40:35 <kbateman> @pl \ f -> runIdentity . g (return . f)
22:40:35 <lambdabot> (runIdentity .) . g . (return .)
22:40:57 <Cale> faxathisia: You're just talking about the number of functions between two *finite* sets.
22:43:17 <Cale> Of course there are other nice reasons for 0^0 = 1 as well, but they're mostly related in some way to that one.
22:44:06 <adu> are the nehe-tuts supposed to look like this?
22:44:07 <adu> http://img136.imageshack.us/my.php?image=picture1uq6.png
22:44:19 <siti> lolz
22:44:41 <siti> does your GL work ok ?
22:45:07 <adu> ya, I've used it from C and Python, but now I'm trying to learn how to use HOpenGL
22:45:26 <Cale> One which isn't is that for the real numbers, if you look at the function f given by f(x,y) = x^y, you can consider the limit as (x,y) -> 0 along any line other than the y axis. This will be 1.
22:45:44 <Cale> (only along the y axis does it have limit 0)
22:46:12 <Cale> More generally, the limit as (x,y) -> 0 along any curve not tangent to the y axis at the origin will be 1.
22:46:47 <siti> @paste
22:46:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:47:02 <hpaste>  siti pasted "Weird Case behaviour..." at http://hpaste.org/5576
22:47:04 <Trinithis> bos: I got my idea to work: http://hpaste.org/5575
22:47:27 <kbateman> adu: you using getArgsAndInitialize?
22:47:56 <Cale> So, even just for practical reasons, if you're working with a numerical algorithm and rounding errors end up producing 0 when the real inputs would just be very small real numbers, the likelihood is that the true result is close to 1.
22:47:57 <adu> kbateman: I'm using nehe-tuts, lesson02.hs
22:48:08 <BMeph> ?src (->) ap
22:48:08 <faxathisia> sorry what does (x,y) -> 0 mean?
22:48:08 <lambdabot> Source not found. Do you think like you type?
22:48:25 <BMeph> ?src ap (->)
22:48:25 <lambdabot> Source not found. Where did you learn to type?
22:48:28 <adu> kbateman: and lesson02 is using "getArgsAndInitialize"
22:48:40 <BMeph> ?src ap
22:48:41 <lambdabot> ap = liftM2 id
22:48:41 <Cale> faxathisia: Well, I suppose what I really mean there is to consider the limit as x -> 0 of x^(ax) for any real number a.
22:48:59 <faxathisia> ah ok
22:49:06 <bos> Trinithis: you should look at the blog posting i wrote the other day about applicative use of parsec.
22:49:25 <Trinithis> bos: you got a link?
22:50:05 <bos> @go applicative parsec basics
22:50:06 <lambdabot> http://research.microsoft.com/~emeijer/Papers/Parsec.pdf
22:50:10 <bos> gurk
22:50:16 <bos> http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
22:50:17 <lambdabot> Title: teideal glic deisbhéalach  Blog Archive  The basics of applicative functors,  ..., http://tinyurl.com/2lrb68
22:51:03 <Cale> faxathisia: x^y is discontinuous there no matter how you define 0^0, but because of that property, 1 seems like the only analytically reasonable definition.
22:51:17 <Cale> faxathisia: But the combinatorial reasons are the real reasons for doing it.
22:51:30 <Cale> It also simplifies things in that it lets us write:
22:51:43 <Cale> exp(x) = sum over k >= 0 of x^k/k!
22:51:55 <Trinithis> bos: thanks, I'll read it tomorrow though. guess my code is atrocious ;)
22:52:07 <bos> Trinithis: there's nothing wrong with it.
22:52:18 <Cale> Note that for exp(0) this produces the sum 0^0/0! + 0^1/1! + 0^2/2! + ...
22:52:27 <Kitar|st> http://wiresmash.com/how-to/how-to-increase-your-internet-connection-speed/
22:52:27 <Kitar|st> hehe
22:52:28 <kbateman> adu: I just grabbed & compiled lesson02 and it works for me (on a linux pc)
22:52:28 <lambdabot> Title: How to increase your internet connection speed | WireSmash, http://tinyurl.com/2ml7k3
22:52:30 <Cale> and so 0^0 had better be meaningful :)
22:52:33 <faxathisia> ahh
22:52:37 <faxathisia> that's pretty neat
22:53:03 <Cale> Otherwise you end up unnaturally pulling out a 1 in front of the sum.
22:53:30 <Cale> Not the end of the world, but it's a bit uglier.
22:53:51 <Trinithis> bos: 'night
22:53:51 <siti> lolz @ http://wiresmash.com/how-to/how-to-increase-your-internet-connection-speed/#comment-32
22:53:52 <lambdabot> http://tinyurl.com/2ml7k3
22:54:02 <adu> kbateman: it must be something mac-specific, or perhaps big-endian-specific
22:54:54 <BMeph> Cale: Nice synchronicity there, since both factorial and exponential functions work on products
22:55:07 <Cale> yeah :)
22:55:34 <kbateman> My guess is that it's a HOpenGL <-> libGL incompatibility of some sort.
22:56:03 <adu> siti: when I run your "function" it gives "ONE" as well, but obviously it should give "TWO"
22:58:06 <adu> whats '\27' ? how do I press that?
22:58:23 <sarehu> escape
22:58:32 <sarehu> > chr 27
22:58:34 <lambdabot>  '\ESC'
22:58:41 <sarehu> > '\27'
22:58:42 <lambdabot>  '\ESC'
22:59:05 <sarehu> (not that pressing the escape key will enter the character for you...)
22:59:32 <adu> n/m, I killed it
22:59:42 <adu> pressing esc didn't work
23:00:13 <sarehu> killed what?
23:00:55 <adu> nehe lesson02
23:01:23 <adu> there is something seriously wrong with HOpenGL
23:01:24 <kbateman> Sounds like opengl tries to initialize, then hangs.
23:01:59 <sarehu> is it even called HOpenGL anymore?
23:02:16 <adu> i dunno
23:02:26 <adu> thats what all the websites call it
23:03:14 <kbateman> @pl \f -> ((\x -> f x x) (\x -> f x x))
23:03:15 <lambdabot> ap join join
23:03:28 <kbateman> wow
23:03:51 <rnorris> confusion. does anyone know if CC-delcont works with GHC? it has a bunch of LANGUAGE pragmas that GHC doesn't seem to understand, and it's looking for Unsafe.Coerce, which sounds dangerous
23:04:08 <adu> ?help pl
23:04:09 <lambdabot> pointless <expr>. Play with pointfree code.
23:04:25 <adu> ?help src
23:04:25 <lambdabot> src <id>. Display the implementation of a standard function
23:04:45 <adu> ?src ap
23:04:45 <lambdabot> ap = liftM2 id
23:05:36 <sarehu> rnorris: which GHC version are you using?
23:05:50 <rnorris> hmm 6.6.1
23:06:01 <adu> 6.8.2
23:06:08 <adu> o oops
23:06:36 <rnorris> i guess i'm a little behind. i'll upgrade and see if that fixes it
23:06:37 <Cale> rnorris: You want 6.8.2 :)
23:06:39 <adu> do you think if I recompile GHC that it will fix my opengl problem?
23:06:39 <sarehu> Unsafe.Coerce is there in 6.8.2, it hase unsafeCoerce
23:06:44 <rnorris> ok
23:06:46 <rnorris> thx
23:07:23 <kbateman> adu, maybe you should try reinstalling/rebuilding GHC.
23:07:39 <rnorris> hell. darwinports is only on 6.6.1 ... that explains it.
23:07:40 <kbateman> otherwise I've got nothin.
23:08:26 <kbateman> ?src join
23:08:27 <lambdabot> join x =  x >>= id
23:08:34 <sarehu> adu: btw, unless the tutorial explicitly says it's had its code updated recently (within the past year, say), it might be out of date.  The OpenGL bindings have changed since early versions of some 'HOpenGL' tutorials
23:08:51 <sarehu> s/past years/past N years/ for some appropriate value of N
23:09:42 <kbateman> I just now 'darcs got' the nehe-tuts and ran lesson2 fine on my ghc-6.8.2 on my linux box
23:09:44 <sarehu> then again, if the code compiles...
23:10:05 <sarehu> well that's good to hear
23:11:51 <kbateman> adu's on a mac.
23:12:04 <siti> yeah mac's suck ;)
23:12:26 <kbateman> I used to have one, but it broke too often.
23:13:00 <sarehu> I had an Intel Mac and it worked fine
23:13:08 <adu> sarehu: I'm on ppc mac
23:13:34 <adu> well now that i have GHC, I should be able to compile GHC right?
23:13:37 <sarehu> yes
23:14:02 <sarehu> compile GHC 6.8.2 .. do it now!
23:14:26 <kbateman> now now, don't get all imperative on him.
23:15:13 <adu> i already have 6.8.2, its just funky
23:15:30 * bos finds the contents of Data.Monoid to be quite weird.
23:16:38 <bos> for example, why is the Monoid instance for Maybe defined on a Monoid lifted into Maybe, and not directly?
23:17:14 <sarehu> if it were direct, wouldn't it be MonadPlus?
23:17:21 <bos> (other than because MonadPlus provides monoidal operations for Maybe.)
23:18:59 <kbateman> adu: I really don't know.
23:19:23 <adu> kbateman: I also have a linux box I could try it on, but I'd like to get it working on here too
23:20:54 <sarehu> bos: -- | Lift a semigroup into 'Maybe' forming a 'Monoid' according to <http://en.wikipedia.org/wiki/Monoid>: \"Any semigroup @S@ may be turned into a monoid simply by adjoining an element @e@ not in @S@ and defining @e*e = e@ and @e*s = s = s*e@ for all @s in S@.\" Since there is no \"Semigroup\" typeclass providing just 'mappend', we use 'Monoid' instead.
23:21:05 <vincenz> Cale: ping
23:21:23 <Cale> hi
23:21:34 <vincenz> care to come to pm for a sec?
23:21:38 <bos> sarehu: yes, i read that. still a bit unconvinced.
23:26:17 <kbateman> @pl f a b = a + b
23:26:17 <lambdabot> f = (+)
23:26:40 <kbateman> @pl f n = if n <= 0 then 1 else f (n-1) (n-2)
23:26:41 <lambdabot> f = fix (ap (flip if' 1 . (<= 0)) . (`ap` subtract 2) . (. subtract 1))
23:27:30 <kbateman> ?src if'
23:27:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:29:35 <kbateman> @pl f n = if n <= 1 then 1 else f (n-1) + f (n-2)
23:29:36 <lambdabot> f = fix (ap (flip if' 1 . (<= 1)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
23:34:31 <kbateman> ?:t if'
23:34:32 <lambdabot>  There was an error in the type: (line 1, column 4):
23:34:32 <lambdabot>  unexpected type constructor 'Not' (this type constructor is not declared)
23:36:30 <kbateman> :t if'
23:36:30 <lambdabot> Not in scope: `if''
23:36:50 <kbateman> @pl \x -> if x then 1 else 2
23:36:50 <lambdabot> flip (flip if' 1) 2
23:37:56 <kbateman> @pl \a b c -> if a then b else c
23:37:56 <lambdabot> if'
23:38:05 <kbateman> there we go.
23:38:28 <bos> @hoogle findM
23:38:29 <lambdabot> Data.Set.findMin :: Set a -> a
23:38:29 <lambdabot> Data.Set.findMax :: Set a -> a
23:38:29 <lambdabot> Data.Map.findMin :: Map k a -> (k, a)
23:39:47 <kbateman> @pl \a b c -> if a then c else b
23:39:47 <lambdabot> flip . if'
23:40:04 <kbateman> @pl \a b c -> if not a then b else c
23:40:04 <lambdabot> if' . not
23:41:21 <bos> @hoogle filterM
23:41:22 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
23:42:31 <rnorris> is there some secret for telling cabal where haddock is? it's installed and in my path but i keep getting Setup.lhs: The program haddock is required but it could not be found
23:44:22 <siti> ./Setup.lhs configure --user ?
23:45:09 <rnorris> ah, ok. it wasn't installed the first time i ran configure
23:45:10 <rnorris> thanks
