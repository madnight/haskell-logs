00:28:06 <dmwit> Is there an enumFromStep?
00:28:53 <olsner> @src Enum
00:28:53 <lambdabot> class  Enum a   where
00:28:53 <lambdabot>     succ                     :: a -> a
00:28:53 <lambdabot>     pred                     :: a -> a
00:28:53 <lambdabot>     toEnum                   :: Int -> a
00:28:53 <lambdabot>     fromEnum                 :: a -> Int
00:28:55 <lambdabot> [3 @more lines]
00:28:58 <olsner> @more
00:28:58 <lambdabot>     enumFrom                 :: a -> [a]
00:28:59 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
00:29:01 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
00:29:04 <dolio> @type enumFromThenTo
00:29:05 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
00:29:17 <dmwit> So, no, in other words.
00:29:20 <dmwit> Okay, thanks.
00:29:29 <olsner> > enumFromThenTo 1 3 9
00:29:30 <lambdabot>  [1,3,5,7,9]
00:29:35 <olsner> > enumFromThen 1 3
00:29:36 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
00:29:36 <litb> http://farm1.static.flickr.com/127/421799450_96fe264d23.jpg :)
00:29:55 <dmwit> =)
00:30:08 <dmwit> I didn't know hugs were enslaved. ;-)
00:30:14 <litb> heh
00:30:41 <litb> freeky  ubuntu folks
00:30:42 <Twey> Heh
00:30:56 <Twey> I suspect there's a very pretty woman there giving out CDs
00:30:58 <dolio> It's already, what, BSD licensed?
00:33:03 <dmwit> Quick, who's got a favorite "chunk" implementation!
00:33:42 <dolio> chunk being? [a] -> [[a]]?
00:33:48 <vininim> @where fold'
00:33:48 <lambdabot> I know nothing about fold'.
00:33:54 <dmwit> Int -> [a] -> [[a]]
00:34:02 <dmwit> chunk 1 = map return
00:34:04 <Twey> @src sequence
00:34:04 <lambdabot> sequence ms = foldr k (return []) ms
00:34:04 <lambdabot>     where
00:34:04 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
00:34:16 <olsner> dmwit: isn't enumFromThen what you were looking for?
00:34:24 <pheaver> Hello, I'm using autoconf with Cabal, and the AC_DEFINE macro to define CPP directives which I want available in my Haskell source files.  Is there an easy way to make Cabal slurp in all these directives?
00:34:26 <vininim> Isn't fold' in Data.List ?
00:34:33 <dmwit> olsner: No, but it's close enough that I can write what I'm looking for.
00:34:37 <vininim> foldl' .. heh
00:34:39 <dibblego> vininim, foldl' ?
00:34:40 <dolio> > let chunk i l = takeWhile (not . null) . unfoldr (Just . splitAt i) in chunk 5 [1..30]
00:34:55 <lambdabot>  thread killed
00:34:59 <litb> > fold1 (+) [1..5]
00:35:00 <bos> pheaver: yes
00:35:07 <pheaver> bos: all rightee
00:35:07 <lambdabot>   Not in scope: `fold1'
00:35:13 <bos> pheaver: let me try to find an example
00:35:17 <pheaver> bos: ok cool
00:35:18 <dibblego> litb, fold EL
00:35:22 <sarehu> > let chunk i = takeWhile (not . null) . map (take i) . iterate (drop i) in chunk 5 [1..30]
00:35:24 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
00:35:30 <dolio> > let chunk i = takeWhile (not . null) . unfoldr (Just . splitAt i) in chunk 5 [1..30]
00:35:30 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
00:35:37 <litb> > foldl1 (+) [1..5]
00:35:38 <lambdabot>  15
00:35:39 <bos> pheaver: grab the pcap package and look at the .buildinfo file it uses
00:35:42 <litb> o.O
00:35:43 <pheaver> bos: at the moment, I was considering creating some sort of "HS_DEFINES" variable in autoconf and then doing an AC_SUBST to get that into my buildinfo.in file
00:35:50 <pheaver> bos: k
00:36:01 <dmwit> ?index unfoldr
00:36:02 <lambdabot> Data.List
00:36:05 <litb> fold el 1
00:36:15 <vininim> > foldl' (+) 0 [1..]
00:36:20 <lambdabot> Terminated
00:36:23 <dolio> If only I could write: unfoldr (not . null) (splitAt i)
00:36:56 <vininim> Does lambdabot shows stack overflow?
00:37:00 <dolio> (or have splitAt _ [] = Nothing)
00:37:09 <pheaver> bos: ahh... this I already know how to do.  I know that is very easy, but I was looking for an even "easier" way
00:37:15 <vininim> Just wondering if the interpret does optimization in time for foldl'
00:37:16 <pheaver> since I may have lots of defines
00:37:26 <dmwit> dolio: Thanks. =)   It's added to module Dmwit.
00:37:28 <litb> > splitAt 3 []
00:37:28 <lambdabot>  ([],[])
00:37:33 <litb> hmm
00:37:52 <dmwit> :t notNull
00:37:55 <litb> looks impossible to do dolio
00:37:57 <lambdabot> Not in scope: `notNull'
00:38:05 <dolio> Actually, I suppose it'd be unfoldr null (splitAt i), since it's usually a top predicate.
00:38:09 <dmwit> ?hoogle [a] -> Bool
00:38:10 <lambdabot> Prelude.null :: [a] -> Bool
00:38:10 <lambdabot> Data.List.null :: [a] -> Bool
00:38:10 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
00:38:32 <dolio> litb: Well, they'd have to have different types, of course.
00:38:48 <sarehu> :t unfoldr
00:38:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:38:52 <litb> is that possible dolio ?
00:38:55 <sarehu> @type unfoldr
00:38:56 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:39:22 <litb> i don't know how to do such thing yet
00:39:29 <dolio> litb: My issue is, unfoldr uses Just vs. Nothing to tell when to stop, but almost no standard functions that would work well with unfoldr return the right type.
00:39:49 <sarehu> @let unfoldr' p f x = guard (p x) >> (let (a,b) in a : unfoldr' p f b)
00:39:49 <lambdabot>  Parse error
00:40:06 <sarehu> @let unfoldr' p f x = guard (p x) >> (let (a,b) = f x in a : unfoldr' p f
00:40:06 <sarehu> 	 b)
00:40:06 <lambdabot>  Parse error
00:40:08 <litb> dolio: i don't understand the problem yet. you can return it into Maybe
00:40:16 <sarehu> @let unfoldr' p f x = guard (p x) >> (let (a,b) = f x in a : unfoldr' p f b)
00:40:31 <lambdabot> Defined.
00:40:49 <dolio> > unfoldr (return . splitAt 5) [1..10] -- litb
00:40:50 <radetsky> am I mistaken, or are haskell's arbitrary-precision integers not actually arbitrary precision?
00:40:52 <litb> maybe it's because i went to bad just 5 hours ago and stand up one hour ago, being still too yawn'ish
00:40:57 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
00:41:02 <sarehu> > let chunk n xs = unfoldr' (not . null) (splitAt n) xs
00:41:02 <lambdabot>  Parse error at end of input
00:41:18 <sarehu> > let chunk n xs = unfoldr' (not . null) (splitAt n) xs in chunk 5 [1..20]
00:41:19 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
00:41:59 <litb> :t unfoldr
00:42:00 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:42:02 <sarehu> radetsky: you are mistaken?
00:42:19 <sarehu> for all intents and purposes
00:43:16 <dolio> @let stopWhen p f a = if p a then Nothing else Just (f a)
00:43:20 <lambdabot> Defined.
00:43:30 <litb> > unfoldr (return . (Just&&&Just) . splitAt 5) $ map Just [1..10]
00:43:31 <sarehu> you might have an upper limit of about (2^(32*(2^n))) for some value of n such as 31 or 32... which is big
00:43:31 <lambdabot>  Couldn't match expected type `[a]'
00:43:33 <dolio> > unfoldr (stopWhen null $ splitAt 5) [1..20]
00:43:34 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
00:43:35 <radetsky> from what I can tell, e.g. x is an unsigned Integer implies 0 <= x <= 2^(2^67) - 1
00:43:53 <litb> hm
00:44:13 <dolio> > unfoldr (stopWhen (==0) $ flip divMod 10) 3568
00:44:14 <lambdabot>  [356,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
00:44:36 <dolio> Oh, right.
00:44:57 <radetsky> oh, sorry, didn't see your reply
00:45:02 <sarehu> radetsky: x fits on your computer implies 0 <= x <= 2^(2^67) - 1
00:45:29 <litb> > map Just [1..10]
00:45:30 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10]
00:45:33 <sarehu> oh ok
00:45:38 <radetsky> sarehu: arbitrary precision and unbelievably large precision are not the same thing
00:46:00 <litb> > (Just&&&Just) 10
00:46:01 <lambdabot>  (Just 10,Just 10)
00:46:09 <litb> hmm
00:46:25 <litb> ah, i see
00:47:12 <radetsky> I can't think of any application where I'd need numbers larger than 2^(2^67)
00:47:26 <radetsky> but there might be one
00:47:54 <radetsky> and some hapless programmer who needed them might assume that arbitrary precision really was
00:49:26 <sarehu> > logBase 2 3.8e50
00:49:27 <lambdabot>  168.02240416292435
00:50:31 <radetsky> sarehu: oh, wait, I just figured out what your last statement meant
00:51:24 <radetsky> and it's wrong; x fits in ram implies ...
00:51:28 <sarehu> > 2^67 / (6.02214279e23 / 12)
00:51:29 <lambdabot>  2.9406267716148207e-3
00:51:38 <vincenz> > 1
00:51:39 <lambdabot>  1
00:51:55 <radetsky> actually, even that's not true
00:52:29 <radetsky> maybe "the array of limbs fits into the address space" or something like that
00:52:59 <faxathisia> > (&&&) `on` Just $ 10
00:53:00 <lambdabot>   Not in scope: `on'
00:53:08 <faxathisia> @src on
00:53:08 <lambdabot> (*) `on` f = \x y -> f x * f y
00:53:16 <faxathisia> > let (*) `on` f = \x y -> f x * f y in (&&&) `on` Just $ 10
00:53:20 <lambdabot>  Couldn't match expected type `a b' against inferred type `Maybe'
00:53:43 <sarehu> > ((*) `on` f) x y
00:53:44 <lambdabot>   Not in scope: `y'
00:53:56 <sarehu> ((*) `on` f) x z
00:54:00 <sarehu> > ((*) `on` f) x z
00:54:01 <lambdabot>   Not in scope: `z'
00:54:03 <sarehu> sigh
00:54:17 <sarehu> > ((*) `on` f) 3 4
00:54:17 <lambdabot>   Not in scope: `f'
00:54:19 <sarehu> what?
00:54:34 <dolio> @version
00:54:34 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
00:54:34 <lambdabot> darcs get http://code.haskell.org/lambdabot
00:54:41 <vincenz> sarehu: what are you trying to do?
00:54:49 <sarehu> looks like Expr is gone :|
00:54:58 <vincenz> > ((*) `on` f) 3 4 :: Expr
00:54:58 <lambdabot>   Not in scope: type constructor or class `Expr'
00:55:03 <vincenz> seems so
00:55:14 <dolio> That's dons' lambdabot.
00:55:18 <dolio> Not Cale's.
00:55:31 <litb> too bad this does not work:
00:55:34 <litb> > unfoldr (\x -> do { p@(_, 0) <- Just (divMod x 10); return p }) 3568
00:55:35 <lambdabot>  []
00:55:46 <litb> 'cause it's /= 0 not == 0
00:55:56 <litb> any way around that with still using do ?
00:56:25 <litb> (a+1) does not work too, since apparently a must be >= 1 then i think
00:56:51 <dolio> > unfoldr (\x -> do guard (x /= 0) ; (d,m) <- return (divMod x 10) ; return (m, d)) 3586
00:56:53 <lambdabot>  [6,8,5,3]
00:57:15 <dolio> > unfoldr (\x -> do guard (x /= 0) ; (d,m) <- return (divMod x 10) ; return (m, d)) 350086
00:57:16 <lambdabot>  [6,8,0,0,5,3]
00:57:27 <litb> ah, nice
00:58:00 <litb> ah, but in a normal function (a+1) seem to work. but within (_, a+1) it does not seem to work
00:59:31 <dolio> > let swap = uncurry (flip (,)) in unfoldr (stopWhen 0 $ swap . flip divMod 10) 368394568
00:59:32 <lambdabot>   add an instance declaration for (Num (a -> Bool))
00:59:48 <vininim> "It's interesting to note that the developer originally reported only 101 lines of code, but fully admitted attemping to pack as many statements in to each 80-column row"
00:59:53 <vininim> heh
01:00:10 <dolio> > let swap (a,b) = (b,a) in unfoldr (stopWhen (==0) $ swap . flip divMod 10) 368394568
01:00:11 <lambdabot>  [8,6,5,4,9,3,8,6,3]
01:01:15 <litb> oh, damn sure. i see my error. divMod 0 10 is never 0 indeed
01:02:08 <dolio> > divMod 0 10
01:02:17 <lambdabot>  (0,0)
01:02:31 <faxathisia> @src divMod
01:02:31 <lambdabot> Source not found. You untyped fool!
01:02:38 <dolio> > divMod 10 10 -- this is the real problem
01:02:40 <lambdabot>  (1,0)
01:03:15 <vincenz> no it's not
01:03:19 <vincenz> you should check on the div bit
01:03:20 <vincenz> not the mod bit
01:03:25 <vincenz> whether you do another round
01:03:35 <dolio> Well, right. But he wasn't.
01:04:10 <vincenz> Then he has a lot of problems ;)
01:04:12 <vincenz> namely
01:04:22 <vincenz> forall k `in` |N: 10*k
01:05:32 <dolio> Checking on the div bit isn't good, either. Because that stops before unfoldr gets the last digit.
01:05:36 <dolio> You need to check both.
01:05:45 <dolio> Or just check for 0 beforehand.
01:06:55 <litb> > unfoldr (\x -> do { (a+1) <- Just x; return $ divMod x 10 }) 3568
01:07:01 <lambdabot>  Parse error in pattern at "<-" (column 27)
01:07:21 <dolio> You also want to fail on (0,0), but 'p@(0,0) <- return (divMod x 10)' fails on anything but (0,0).
01:07:24 <litb> hm, incidentially, this works with my ghci :/
01:07:43 <vincenz> the problem is that you need to check on 0 before modding
01:07:44 <vincenz> like this
01:07:51 <litb> but still doesn't stop at x==0
01:07:52 <vincenz> > map (`mod` 10) . takeWhile (/= 0) .iterate (`div` 10) $ 1230
01:07:53 <lambdabot>  [0,3,2,1]
01:08:34 <litb> i thought i do with (a+1) <- Just x , since it would pattern match fail and return Nothing
01:09:07 <vincenz> > do { x <- Nothing; return x} :: Maybe Int
01:09:08 <lambdabot>  Nothing
01:09:22 <dmwit> :t \m n -> m >>= flip fmap n
01:09:23 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => f (a -> b) -> f a -> f b
01:09:23 <vincenz> > do { [] <- Just (x:xs); return x} :: Maybe Int
01:09:24 <lambdabot>   Not in scope: `x'
01:09:29 <litb> > (\x -> do { (a+1) <- Just x; return $ divMod x 10 }) 0
01:09:30 <lambdabot>  Parse error in pattern at "<-" (column 19)
01:09:30 <vincenz> > do { [] <- Just [1]; return x} :: Maybe Int
01:09:30 <lambdabot>   Not in scope: `x'
01:09:38 <vincenz> > do { [x] <- Just []; return x} :: Maybe Int
01:09:39 <lambdabot>  Nothing
01:09:47 <litb> > (\x -> do { (a+1) <- (Just x); return $ divMod x 10 }) 0
01:09:47 <lambdabot>  Parse error in pattern at "<-" (column 19)
01:09:58 <vincenz> lambdabot: you can't patternmatch on a+1
01:09:59 <litb> darn, why does it keep seeing an error?
01:10:02 <wagle_home>  > do { x <- Nothing; error "beaum!"} :: Maybe Int
01:10:04 <litb> oh
01:10:17 <dolio> @ . pl undo do [x] <- Just [] ; return x
01:10:24 <wagle_home> > do { x <- Nothing; error "beaum!"} :: Maybe Int
01:10:25 <lambdabot>  Nothing
01:10:55 <litb> vincenz: why doesn't that work? it works with my ghci :/
01:11:33 <vincenz> litb: are you certain?
01:11:54 <vincenz> suffice to say
01:11:54 <litb> yes, i'm uber certain
01:11:54 <vincenz> n+k patterns are borke
01:11:54 <dolio> lambdabot tries to parse things before running them.
01:12:01 <vincenz> d
01:12:05 <dolio> And the parser it uses doesn't handle everthing in Haskell.
01:12:10 <litb> oh i see
01:12:23 <vincenz> Not to mention that n+k patterns should be banished
01:12:30 <litb> i know you hate it :)
01:12:35 <vincenz> I do not hate it
01:12:40 <dolio> > let f (n+1) = n in f 3
01:12:40 <lambdabot>  Parse error in pattern at "in" (column 17)
01:12:56 <vincenz> They are a corner-case
01:13:02 <rekso> Why does everyone hate n+k patterns so much?
01:13:04 <litb> @let f (n+1) = n
01:13:05 <lambdabot>  Parse error in pattern
01:13:05 <vincenz> and guards arae a more generic system
01:13:08 <litb> too bad
01:13:21 <vincenz> rekso: stop using hate
01:13:28 <vincenz> this is not an emotional issue
01:13:42 <litb> vincenz: i'm afraid you have to blame me :/
01:13:50 <rekso> vincenz: Maybe not for you, but some people do get quite heated about it. :-)
01:14:03 <vincenz> rekso: well they hav bugs
01:14:05 <vincenz> what happens when you hae
01:14:08 <vincenz> f (a+1)
01:14:12 <litb> for some people, haskell might be their religion
01:14:12 <vincenz> and you pass a negative number?
01:14:25 <sarehu> I had a nightmare about (n+k) patterns
01:14:32 <rekso> lol
01:14:42 <litb> vincenz: as far as i know, the number you pass must be at least >= 1 then
01:14:44 <dolio> rekso: One reason to dislike them is that their semantics don't actually use (+) from the Num typeclass.
01:15:15 <litb> oh i understand dolio . that's quite boo :/
01:15:19 <vincenz> litb: right, but that's the issue
01:15:23 <vincenz> litb: iti's Integer, not a Natural
01:15:27 <vincenz> so that has flawed typing
01:15:33 <vincenz> if you want naturals, make em
01:15:39 <vincenz> data Nat = Z | S Nat
01:15:43 <vincenz> foo (S x) = ...
01:15:45 <vincenz> foo Nat = ..
01:15:58 <litb> ah, thanks for delighting me. i guess i will avoid it now too
01:16:03 <rekso> I vaguely like them because they let you pretend, for a moment, that you're using proper natural numbers (of the Zero | Succ nat variety)
01:16:12 <wagle_home> wow..  n+k is still controversial after 20 years
01:16:25 <litb> o.O
01:16:35 <vincenz> wagle_home: yes but unlike then
01:16:37 <vincenz> we now have guards!
01:16:41 <sarehu> emphasis on _pretend_
01:16:42 <vincenz> foo x | x > 0 = ...
01:16:52 <vincenz>      | x == 0 = ...
01:17:05 <litb> it will not work in lambdas :/
01:17:07 <vincenz>      | x < 0 = error "please ue naturals"
01:17:23 <vincenz> litb: sure it will
01:17:39 <litb> guards with lambda? hmm
01:17:48 <litb> i thought you have to work around this with case
01:17:57 <vincenz> \x -> case () of {_ | x > 0 -> ...; _ | x == 0 -> ...; _ | x < 0 -> ... }
01:18:33 <vincenz> litb: but I don't use lambdas that often
01:18:34 <litb> well, looks hackish :)
01:18:40 <vincenz> since where clauses are so neat
01:18:44 <dolio> You shouldn't actually need multiple _s, I think.
01:18:54 <vincenz> good point
01:19:04 <wagle_home> original haskell report was apologetic about including them, iirc
01:19:16 <dolio> case () of { _ | guard1 -> exp1 | guard2 -> exp2 ... }
01:19:22 <dolio> Although, that's still not great.
01:19:24 <litb> i see
01:19:50 <dolio> There are various proposals to rectify that sort of thing.
01:19:59 <litb> the case () part scares me. it seems to be just a placeholder
01:20:03 <dolio> Although, I don't know if any are particularly popular.
01:20:14 <sarehu> > case () of { _ | False -> 2 | 2 < 1 -> 3 | True -> 5 }
01:20:18 <lambdabot>  5
01:20:26 <vincenz> heh
01:20:29 <sarehu> oh hey.  I've always wondered about the semicolons in that.
01:20:34 <vincenz> it would be simple to drop the case () of { _ .. bit
01:20:35 <litb> oh neat
01:20:37 <vincenz> nd put that straight into lambda
01:20:38 <vincenz> sarehu: yeah, me too
01:20:55 <vincenz> \x | foo -> y | bar -> z
01:21:01 <wagle_home> i guess i'm agnostic..  they are cute, but i dont use them..  dunno why "hate them" or of that ilk?
01:21:59 <litb> "hate" is usual the work i'm used to hear in ##c++ :)
01:22:07 <Cale> You can also construct a datatype and a function which give a pretty syntax for guards.
01:22:36 <litb> *word
01:22:54 <litb> anyway, going to see what mark i got in probability exam. later
01:25:00 <dolio> Oh man, does leksah turn \ into lambda, and -> into an arrow and such?
01:26:03 <vincenz> @hoogle Maybe a -> a -> a
01:26:12 <vincenz> @bot
01:26:16 * vincenz sighs
01:26:17 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
01:26:17 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
01:26:17 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
01:26:17 <lambdabot> :)
01:27:49 <vincenz> > let {a ? b = if a then Just b else Nothing; Nothing := b = b; (Just a) := b = a} in False ? 1 := 2
01:27:51 <lambdabot>      Conflicting definitions for `b'
01:27:51 <lambdabot>     In the binding group for: ?, b, a, b
01:28:14 <vincenz> > let {a ? b = if a then Just b else Nothing; Nothing =: b = b; (Just a) =: b = a} in False ? 1 =: 2
01:28:15 <lambdabot>  2
01:28:23 <johnnowak> @pl \x -> x * x * x
01:28:23 <lambdabot> (*) =<< join (*)
01:28:29 <johnnowak> is there a better way to write thaT?
01:28:44 <vincenz> (^^3)
01:28:50 <vincenz> @hoogle (^^)
01:28:51 <vincenz> @hoogle (^)
01:28:54 <lambdabot> Did you mean: (^^)
01:28:54 <lambdabot> Prelude.undefined :: a
01:28:54 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
01:28:55 <lambdabot> Did you mean: (^)
01:28:55 <lambdabot> Prelude.undefined :: a
01:28:56 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
01:29:01 <vincenz> > x ^ 3
01:29:02 <lambdabot>   Not in scope: `x'
01:29:04 <vincenz> > 3 ^ 3
01:29:05 <lambdabot>  27
01:29:08 <vincenz> yeah, I meant (^3)
01:29:23 <johnnowak> @pl \x -> x * y * z
01:29:23 <lambdabot> ((z * y) *)
01:29:37 <johnnowak> ermm
01:29:50 <johnnowak> @pl \x y z -> x * y * z
01:29:50 <lambdabot> ((*) .) . (*)
01:29:50 <faxathisia> @pl \x -> x - y - z
01:29:50 <lambdabot> subtract z . subtract y
01:30:06 <vininim> @where unfoldr
01:30:07 <lambdabot> I know nothing about unfoldr.
01:30:21 <vininim> @hoogle unfoldr
01:30:22 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
01:30:22 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
01:30:22 <lambdabot> Data.ByteString.Char8.unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
01:32:27 <johnnowak> @pl \x y z -> y + z * x
01:32:27 <lambdabot> flip ((.) . (+)) . (*)
01:33:13 <johnnowak> @pl \x y z -> z * y * x
01:33:14 <lambdabot> flip (flip . ((*) .) . (*))
01:39:19 <jacobian_wrk> what is @pl?  pointless ?
01:39:28 <sarehu> in a sense.  pointfree
01:39:32 <sarehu> pointless
01:39:39 <sarehu> right, p.l. = pointless... sigh
01:39:57 <johnnowak> pointfree is largely pointless in haskell
01:40:29 <jacobian_wrk> silly :)
01:40:35 <johnnowak> pointfree programming in a language not designed for it is typically not fun
01:41:04 <jacobian_wrk> what is a language designed for pointfree?
01:41:11 <jacobian_wrk> I've only seen CPL from Hagino's thesis
01:41:33 <johnnowak> fl, j, joy, factor, forth, apl, etc
01:41:53 <vincenz> @shameless plugin :)
01:41:53 <lambdabot> Unknown command, try @list
01:42:18 <johnnowak> in joy, "flip (flip . ((-) .) . (-))" is just "3swap - -"
01:42:25 <johnnowak> vincenz: always!
01:42:29 <Cale> It's just a library issue.
01:42:33 <Cale> I think Haskell's about as designed for points-free stuff as you can get, modulo some additional libraries.
01:42:58 <johnnowak> It's not just a library issue. Functions in Haskell don't have multiple return values.
01:43:06 <Cale> Sure they do/can.
01:43:12 <faxathisia> :t (,,,)
01:43:14 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
01:43:21 <johnnowak> that's a tuple, no?
01:43:24 <Cale> sure
01:43:27 <johnnowak> that's not the same
01:43:31 <faxathisia> yes it is
01:43:54 <sarehu> I have trouble imagining what 'multiple values' look like
01:44:00 <johnnowak> Say I want to write a function that multiplies three values together. \x y z -> x * y * z. How can I do that in Haskell in a way as simple as in Joy without multiple return values?
01:44:06 <sarehu> (+ (f 2) 3) = (+ 2 2 3) ?
01:44:08 <johnnowak> In Joy it is just "* *".
01:44:12 <Cale> You can use tupling to simulate a stack language in Haskell, as well.
01:44:37 <johnnowak> Wouldn't you need new versions of every function?
01:44:42 <faxathisia> @pointless \x y z->[x,y,z]
01:44:42 <lambdabot> (. ((. return) . (:))) . (.) . (:)
01:44:45 <sarehu> not with typeclasses
01:44:59 <Cale> Well, perhaps. It's not something we're about to do :)
01:45:01 <faxathisia> product . (. ((. return) . (:))) . (.) . (:)
01:45:13 <johnnowak> Cale: Right. You can write Joy in Haskell. That's not surprising. :)
01:45:26 <johnnowak> sarehu: I don't see how that helps.
01:45:57 <faxathisia> > product $ ((. ((. return) . (:))) . (.) . (:)) $ 5 3 6
01:46:03 <faxathisia> > product $ ((. ((. return) . (:))) . (.) . (:)) 5 3 6
01:46:08 <lambdabot>  Couldn't match expected type `[a]'
01:46:09 <lambdabot>  90
01:47:48 <sarehu> johnnowak: assuming a Stack with dynamically typed values a, make a   class RPNVal a where { pushStack :: a -> Stack -> Stack; popStack :: Stack -> (a,Stack) }
01:48:14 <Cale> *Main> start push 2 push 2 push 3 mul mul end
01:48:14 <Cale> 12
01:48:43 <johnnowak> @pl \x -> (head x, tail x)
01:48:43 <lambdabot> liftM2 (,) head tail
01:48:55 <sarehu> then make something that composes functions of the type (RPNVal a, RPNVal b) => (a -> b)
01:49:11 <vininim> @hoogle unfoldM
01:49:17 <lambdabot> No matches found
01:49:23 <vininim> wut
01:49:30 <Cale> You don't even need dynamic typing. You can just use polymorphism to express that the function doesn't care about the rest of the stack.
01:49:48 <johnnowak> Don't you need row polymorphism for that?
01:49:53 <Cale> Nope.
01:50:00 <Cale> You can just use nested pairs.
01:50:00 <johnnowak> Can you demonstrate?
01:50:19 <vincenz> Cale: not with recursion
01:50:30 <johnnowak> It seems like that would be limited.
01:52:07 <vininim> > replicateM 2 (flip.(:) []) [1]
01:52:09 <lambdabot>  Couldn't match expected type `a -> b -> c'
01:53:09 <johnnowak> Cale: with nested pairs, how would I write a function like "dip" that takes two arguments, one a function and one 'a', and returns the result of applying the function to the rest of the stack with 'a' restored to the top
01:53:28 <vininim> > replicateM 2 (flip (:) []) [1]
01:53:31 <lambdabot>  [[[1]],[[1]]]
01:53:35 <johnnowak> dip :: 'A 'b ('A -> 'C) -> 'C 'b, where 'A and 'C are row variables
01:53:43 <vininim> wut
01:55:35 <dolio> Oh man, it does.
01:57:13 <oerjan> :t let dip (f,(a,r)) = (a,f r) in dip
01:57:14 <lambdabot> forall t t1 t2. (t -> t1, (t2, t)) -> (t2, t1)
01:57:36 <oerjan> that much is not a problem
01:58:49 <oerjan> because a final row is just an ordinary free type variable
01:58:52 <vininim> > replicateM 4 (flip (:) []).(+1) 1
01:58:53 <lambdabot>   add an instance declaration for (Num (a -> b))
01:59:21 <Cale> hmm
02:00:22 <oerjan> the problem rather appears if you apply a single monomorphic function twice, with different types on the stack below those it uses
02:14:32 <vininim> > floor (1 / 0)
02:14:33 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
02:14:59 <wagle_home> vininim wins!.....  uh something
02:15:08 <Cale> dip (f,(x,s)) k = let s' = f s id
02:15:08 <Cale>                   in k (x,s')
02:15:16 <vininim> heh
02:15:51 <Cale> That works in my continuation passing style embedding.
02:16:52 <wagle_home> > length (show . floor ( 1 / 0))
02:16:52 <lambdabot>  Couldn't match expected type `[a]'
02:17:24 <wagle_home> :t show
02:17:25 <lambdabot> forall a. (Show a) => a -> String
02:17:42 <wagle_home> > length (show $ floor ( 1 / 0))
02:17:43 <lambdabot>  309
02:22:14 <ac> @index readFloat
02:22:14 <lambdabot> Numeric
02:23:42 <JohnMeacham> is anyone here independently wealthy?
02:24:17 <mahogny> ehh??
02:24:43 <JohnMeacham> I find myself in need of a fairly large amount of money very quickly and am seeking out anything I can.
02:25:11 <Cale> JohnMeacham: What is this for? (Not that I'm the least bit wealthy.)
02:25:21 <JohnMeacham> I would certainly pay things back over the course of a few months... but hmm.... haskell people have money, right?
02:25:31 <mahogny> try your bank
02:25:40 <JohnMeacham> I'll sell someone jhc for $100,000. who wants it?
02:26:59 <ac> jhc?
02:27:05 <ac> JohnMeacham: try prosper
02:27:23 <faxathisia> What would it mean to sell jhc?
02:27:29 <faxathisia> I thought that it was OSS
02:27:45 <faxathisia> (I was looking at the code earlier..)
02:27:59 <dmwit> You're buying support.
02:28:01 * Cale downloads jhc...
02:28:23 <vincenz> JohnMeacham: out of curiusity, what do you do professionally? student?
02:28:34 <tuukkah> one could buy the copyright
02:28:35 <Cale> .oO(This might be pretty valuable once JohnMeacham sells the rights to it.)
02:28:42 <hpaste>  dmwit pasted "comments?" at http://hpaste.org/5630
02:29:28 <JohnMeacham> of course, all previous versions are still under the GPL and hence starting poitnst for open source developments :)
02:32:19 <Cin> http://code.haskell.org/leksah/doc/screenshot3.png
02:32:22 <vincenz> wagle_home: that's curious, I know much longer numbers than that
02:32:22 <dmwit> Also, how do I send EOF to programs compiled with GHC?
02:32:24 <Cin> cute arrows =o
02:32:39 <Cin> anyone tried leskah?
02:32:42 <Lemmih> JohnMeacham: Do you have time to talk abut Jhc? (I did some hacking yesterday and I'd like some info)
02:32:47 <Cin> (i'm pulling it from darcs now)
02:32:51 <dolio> Cin: I just installed it because of that screenshot.
02:32:56 <Cin> dolio: :P
02:33:24 <dolio> Cin: It does \ -> => alpha beta gamma delta :: == /= ...
02:34:06 <dmwit> > reverse 'l':"leksah"
02:34:15 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
02:34:17 * Cin drools slightly
02:34:23 <dmwit> > reverse $ 'l':"leksah"
02:34:24 <lambdabot>  "haskell"
02:34:35 <faxathisia> What does it do that emacs doesn't?
02:34:56 <jeffz> dmwit: from the keyboard? ^Z on windows, else ^D?
02:35:13 <dmwit> jeffz: That's what I thought, too.
02:35:44 <jeffz> dmwit: works here, "hGetChar: end of file"
02:35:49 <dmwit> faxathisia: Maybe jumping to code?
02:36:04 <dmwit> faxathisia: Although I'm sure Emacs has some way to do that.
02:36:07 <dolio> faxathisia: Builds a big database of all the functions available to you?
02:36:23 <ac> the "Haskell's 90% Problem" on reddit spawned a somewhat interesting discussion thread
02:36:47 <vininim> writing haskell in leskah in freeinspire
02:36:49 <dolio> At least, I think. I don't actually have "source installs" of any packages.
02:36:52 <dmwit> jeffz: Well, okay, let me change my question then.  How do I send EOF to getContents?
02:37:04 <vininim> like overload of haskell =)
02:37:23 <dmwit> jeffz: Actually, even getChar seems to return '\EOT' here.
02:38:14 <ac> is anybody actually working on a lighter weight XML parser?
02:39:11 <jeffz> dmwit: how are you using it?
02:39:16 <dmwit> ...
02:39:24 <dmwit> main = getChar >>= print
02:40:19 <jeffz> dmwit: s/getChar/getContents/ and send ^D - it'll print an empty string
02:40:32 <jeffz> dmwit: what are you expecting?
02:40:47 <dmwit> jeffz: Empirically false.
02:40:49 <jre2> ac: I'd agree with his point that a simpler xml parser could be useful. it's not that HXT is bad, it just takes awhile to figure out, which can be frustrating if you haven't seen arrows before
02:41:07 <ac> what would be faster for dumping pixel data from Haskell to the screen? Gtk, or creating a texture in OpenGL?
02:41:16 <dmwit> jeffz: Every time I press ^D, it reads '\EOF', whether I'm in getChar or getContents.
02:41:38 <ac> jre2: maybe HXT will be my introduction to arrows ;). Unlike the poster, I'm happy to learn new concepts
02:42:46 <jre2> ac: my last project used it, and unfortunately only 1 other guy and myself can understand and thus maintain it :(
02:44:02 <ac> It's kind of funny, because it took me more than a month to get as comfortable with the basic Haskell concepts as I am now, but now looking back it feels like I haven't really learned anything
02:45:04 <ac> everything seems really simple now
02:45:12 <vincenz> ac: welcome to the zenwhack
02:46:09 <ac> vincenz: that's an unfamiliar term to me
02:46:15 <dmwit> Me, too.
02:47:03 <ac> it makes me think that Haskell could benifit from a little education technology, like Calculus has in the last few hundred years
02:48:09 <gour> Cin: here it just started
02:48:13 <vincenz> ac: the aha-erlebenis?
02:49:16 <vincenz> Aha-erlebnis is a German term, literally meaning 'aha-experience' and referring to the effect of suddenly finding the insight, solution or answer to a problem that has troubled someone for some time. The most famous example is Archimedes' Eureka!.
02:49:29 <vincenz> similarly, zen is about 'getting it'
02:49:35 <vincenz> when you get it, it's like being whacked in the head with it
02:49:39 <vincenz> hence my term zenwhack
02:49:45 <vincenz> suddenly all makes sense
02:49:54 <vincenz> (not that I've had the zenwhack for zen, mind you)
02:50:06 <therp> Hm, I wouldn't say that zen is about 'getting it'. it's more about 'forgetting it'
02:50:22 <vincenz> therp: right, but it's about getting why the hell you're doing it
02:50:30 <vincenz> namely by not getting it
02:50:37 <faxathisia> zenwhack seems pretty spot on from my perspective
02:51:17 <oerjan> > chr 4
02:51:20 <lambdabot>  '\EOT'
02:51:47 <ac> vincenz: that's cool there's actually a term for it in German. My old physics teacher called them "ahas"
02:52:08 <dmwit> :t showIntAtBase
02:52:09 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
02:52:16 <vincenz> ac: yes, read above
02:52:19 <vincenz> aha-erlebnis
02:52:22 <vincenz> I misspelled it the first time
02:52:32 <oerjan> dmwit: how are you running the main program? ^D depends on being in a terminal with the right settings
02:53:02 <dmwit> oerjan: I'm just running it from gnome-terminal; ^D works in other programs just fine.
02:53:16 <dmwit> (In fact, I've been doing cat | runghc as a workaround.)
02:53:40 <oerjan> i see, so ghc changes the terminal setting perhaps...
02:54:30 <jeffz> dmwit: are you sure main = getcontents >>= print, does the same as getChar?
02:54:31 <jre2> anyone have experience with teaching programming (specifically FP) to young children?
02:54:38 <Cale> hehe, nice, my ifte actually statically ensures that the 'then' and 'else' branch have the same stack effect type.
02:54:49 <Cale> (that's pretty much necessary)
02:55:12 <Cale> *Main> start (push 2) (push 3) gt (push (push 1)) (push (push 0)) ifte end1
02:55:14 <Cale> er...
02:55:20 <dmwit> jeffz: No, it is different; getContents waits for additional input (as you would expect).  Other than that, I can't tell a difference.
02:55:28 <Cale> *Main> start (push 2) (push 3) gt (push (push 1)) (push (push 0)) ifte end
02:55:28 <Cale> 1
02:55:41 <faxathisia> Cale, Do you have mutability in this embeded lang?
02:55:55 <Cale> faxathisia: Nope, it's pure.
02:56:10 <ac> yeah, that's something I'm curious about too: implementing mutability in an embedded language
02:56:19 <vincenz> Cale: it's faulty
02:56:33 <Cale> vincenz: Why is that?
02:56:41 <vincenz> Cale: it only works if you have one string like that
02:56:46 <vincenz> not if words are recursive
02:56:50 <vincenz> cause then you can't uniy
02:56:58 <vincenz> (a,b) with (a,(a,b))
02:57:06 <Cale> vincenz: Could you give me an example of such a word?
02:57:29 <vincenz> dupN
02:57:41 <Cale> What does that do?
02:57:48 <vincenz> dupllicates the top element N times
02:57:54 <ac> specifically I'm curious how hard it would be to implement Scheme with set! without using IORefs
02:57:57 <Cale> Of course that's not implementable.
02:58:10 <Cale> Because it has an ill-typed stack effect.
02:58:15 <vincenz> Cale: not only that
02:58:26 <vincenz> hmm
02:58:29 <Cin> ac: monads?
02:58:40 <vincenz> Cale: i dunno the whole b -> (a,b) seems odd to me
02:58:53 <Cale> Here, I'll paste what I have.
02:59:45 <vincenz> Cale: you need a better type than that, preferably something with subsumption
02:59:48 <vincenz> erm, subtyping
02:59:57 <vincenz> e.g. rowtypes
02:59:59 <therp> my embedded scheme used IORefs quite liberally
03:00:15 <Cale> I'm not sure that I see why.
03:00:21 <ac> I'm not sure it's possible to do it easily
03:00:26 <vincenz> Cale: can't put my finger on it
03:01:05 <Cale> @paste
03:01:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:01:08 <ac> If it could be done efficiently, I imagine you could then prove that a lazy language without mutable state is as algorithmically expressive as a strict language with mutable state
03:01:09 <Cale> @version
03:01:09 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
03:01:09 <lambdabot> darcs get http://code.haskell.org/lambdabot
03:01:11 <Cale> hmm
03:01:40 <oerjan> Cale: consider the haskell function r op i 0 = i; r op i n = n `op` r i (n-1)
03:01:52 <hpaste>  Cale pasted "small embedded pure forthish language" at http://hpaste.org/5631
03:01:57 <oerjan> try translating that to a stack-based version
03:02:05 <vincenz> oerjan: thanks
03:02:36 <vincenz> Cale: the problem is that your type-stack will be as big as your value stack
03:02:46 <vincenz> that's my main issue
03:02:51 <Cale> vincenz: Well, that's true, but it's polymorphic.
03:02:57 <Cin> ac: could you do it with a state monad that one updates throughout the course of interpreting? have a Data.Map for all the variables.
03:02:57 <vincenz> not in length
03:03:08 <Cale> vincenz: In the types of the operations, it is.
03:03:10 <oerjan> Cale: the problem is that op will be applied to stacks of different types
03:03:11 <vincenz> Cale: which means you're limited with what you can do at runtime
03:03:20 <ac> Cin: I'm not sure. Back when I attempted this I was very new to Haskell and I gave up
03:03:44 <Cale> oerjan: I'll give it a shot.
03:05:03 <ac> Isn't that an open question? Whether a lazy language without mutable state is as expressive as a strict language with it?
03:05:04 <Cin> ac: rather than writeIORef you might have something like do { setValue var value; }. i might give this a simple try
03:05:55 <ac> Cin: I can imagine doing that, and making every primitive Scheme function take an environment and return it. I just couldn't come up with a data structure that represented a tree of closures and their variables
03:05:56 <oerjan> Cale: the important point is to save the accumulated n's on the stack, this shows the problem clearly
03:06:39 <oerjan> lambdabot is back at 6.6? :(
03:06:54 * vincenz votes for Cale's lambdabot over dons' lambdabot
03:06:58 <Cale> oerjan: I have no idea why.
03:07:16 <Cale> oerjan: People could just have asked me to restart it, if it died.
03:10:15 <Cale> r op i n = n `op` r op i (n-1) ?
03:11:06 <oerjan> er yeah
03:11:10 <Twey> I seem to remember there was a function Maybe a -> b -> b -> b, which returned its second argument if the first argument was a Just, otherwise the third... like (if isNothing a then b else c)
03:11:19 <Twey> Can anyone remember what it's called?
03:11:22 <tuukkah> scheme has mutable cons-cells that can refer to each other, so the state would be a map of cons-cells
03:11:31 <fax> :t maybe
03:11:32 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:11:39 <fax> is it that?
03:12:13 <ac> > maybe id Nothing
03:12:14 <lambdabot>  Couldn't match expected type `a -> a1 -> a1'
03:12:15 <dmwit> Twey: fromMaybe, maybe
03:12:23 <dmwit> :t fromMaybe
03:12:24 <lambdabot> forall a. a -> Maybe a -> a
03:12:40 <dmwit> :t maybe -- the catamorphism
03:12:41 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:12:53 <ac> > maybe "nothing" id Nothing
03:12:54 <lambdabot>  "nothing"
03:13:12 <ac> > maybe "nothing" id $ Just "something"
03:13:13 <lambdabot>  "something"
03:13:25 <fax> @src reverse
03:13:25 <lambdabot> reverse = foldl (flip (:)) []
03:13:32 <dmwit> > fromMaybe "nothing" Nothing
03:13:33 <lambdabot>  "nothing"
03:13:38 <dmwit> > fromMaybe "nothing" $ Just "something"
03:13:39 <lambdabot>  "something"
03:14:00 <Twey> Aha, thanks, that'd be it
03:14:31 <ac> @src fromMaybe
03:14:31 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
03:14:38 <ac> @src maybe
03:14:38 <lambdabot> maybe n _ Nothing  = n
03:14:38 <lambdabot> maybe _ f (Just x) = f x
03:16:00 <ac> let fromMaybe = (flip maybe) id in fromMaybe "nothing" Nothing
03:16:04 <ac> > let fromMaybe = (flip maybe) id in fromMaybe "nothing" Nothing
03:16:04 <lambdabot>  "nothing"
03:17:39 <ac> I propose fromMaybe should be defined like that :-P
03:18:05 <oerjan> certainly not.  the parentheses are completely unnecessary :D
03:18:14 <ac> they help me
03:18:31 <ac> > let fromMaybe = flip maybe id in fromMaybe "nothing" $ Just "something"
03:18:33 <lambdabot>  "something"
03:18:38 <fax> > let fromMaybe = (`maybe` id) in fromMaybe "nothing" Nothing
03:18:39 <lambdabot>  "nothing"
03:18:45 <fax> > let fromMaybe = (`maybe` id) in fromMaybe "nothing" (Just 3584)
03:18:46 <ac> even better ;)
03:18:46 <lambdabot>   add an instance declaration for (Num [Char])
03:19:07 <Twey> > let fromMaybe = `maybe` id in fromMaybe "nothing" Nothing
03:19:07 <lambdabot>  Parse error at "`mayb..." (column 17)
03:19:12 <Twey> :-(
03:19:33 <ac> Twey: you made it a binary operator, but only gave it one argument
03:19:53 <ac> what is the (+1) syntax called again? A section?
03:19:57 <Twey> Yeah
03:19:57 <oerjan> @pl \n j x -> fromMaybe n (j x)
03:19:57 <lambdabot> (.) . fromMaybe
03:20:17 <ac> fax: what's with that type error?
03:20:42 <fax> type of "nothing" is not the same as type of 3584
03:21:03 <ac> oh, right
03:21:05 <fax> so they clash and the result type of the expression is not known
03:21:20 <fax> > let fromMaybe = (`maybe` id) in fromMaybe (Left "nothing") (Just (Right 3584))
03:21:22 <lambdabot>  Right 3584
03:21:34 <ac> if Haskell had occurrence typing, that wouldn't have been an issue
03:21:43 <fax> What is occurrence typing?
03:21:54 <ac> check out the Typed Scheme paper
03:21:57 <ac> it was on LTU
03:22:22 <ac> (fairly recently)
03:22:48 <fax> is occurrence typing basically implict Either .. everywhere?
03:23:08 <ac> http://www.ccs.neu.edu/scheme/pubs/popl08-thf.pdf
03:24:27 <ac> fax: I'm not sure I understand what you're saying, but probably. If you have a cond in a function, the function automatically assumes a union type of the type for each condition
03:25:34 <pjd> untagged unions?
03:25:46 <ac> meaning, if you have something like (define (foo x) (cond (number? x) (+ x 1) (string? x) (concat x "foo")) then foo has a type of "Either Number String"
03:26:21 <ac> (I probably butchered Scheme syntax)
03:27:47 <vincenz> problem with occurrence typing is that you soon get really big types
03:29:11 <ac> the idea was to provide static type checking without very much modification of traditional Scheme programs
03:29:38 <vincenz> and only local inference
03:30:28 <ac> I think it did some amount of inference, but because all the type information is basically just thrown away during compilation, that's not really the point of it
03:30:40 <vincenz> yes
03:30:42 <vincenz> it's like C# inference
03:30:51 <vincenz> very local
03:31:32 <ac> back when I had a job coding C#, it didn't have ANY type inference :-(
03:32:06 <ac> had to say stuff like: System.Blah.Blah.Blahblahhblah foo = new System.Blah.Blahblahhblah()
03:34:28 <vincenz> ExpressionClassInterpreterPatternFactoryInterface
03:34:52 <dmwit> > 317584931803 `div` 3919
03:34:55 <lambdabot>  81037237
03:34:56 <ac> yeah like that ;). I don't remember any actual class names from the class library though
03:35:03 <vincenz> class ExpressionClassInterpreterPatternFactory implements ExpressionClassInterpreterPatternFactoryInterface
03:35:21 <ac> lol, you must be writing C# at your current job
03:35:26 <vincenz> they should allow let expressions for names
03:35:28 <vincenz> ac: no, not at ally
03:35:29 <vincenz> ac: no, not at all
03:35:36 <vincenz> I remember some java-stuff online
03:35:40 <vincenz> you could do
03:36:01 <vincenz> let prefix = ExpressionClassInterpreterPattern in class $prefix$ implements $prefix$Interface
03:36:38 <vincenz> whoops, missed a Factory there
03:36:41 <ac> is that seriously valid Java?
03:36:56 <vincenz> no
03:37:00 <vincenz> I just wish that were possible
03:37:12 <vincenz> if you're going to havea language that has developers inventing crappy long names like that
03:37:23 <dmwit> > let primes = nubBy (\x y -> y `mod` x == 0) [1..]; factors 1 = []; factors n = let p = head . filter (\p -> n `mod` p == 0) $ primes in p : factor (n `div` p) in factor 317584931803
03:37:23 <lambdabot>   Not in scope: `factor'
03:37:33 <Twey> :t lookup
03:37:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
03:37:36 <dmwit> > let primes = nubBy (\x y -> y `mod` x == 0) [1..]; factors 1 = []; factors n = let p = head . filter (\p -> n `mod` p == 0) $ primes in p : factor (n `div` p) in factors 317584931803
03:37:36 <lambdabot>   Not in scope: `factor'
03:37:39 <vincenz> :t lookdown
03:37:40 <lambdabot> Not in scope: `lookdown'
03:37:44 <dmwit> > let primes = nubBy (\x y -> y `mod` x == 0) [1..]; factors 1 = []; factors n = let p = head . filter (\p -> n `mod` p == 0) $ primes in p : factors (n `div` p) in factors 317584931803
03:37:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
03:37:48 <dmwit> bah
03:37:49 <ac> > rem 317584931803 3919
03:37:50 <lambdabot>  0
03:38:47 <dmwit> > 67 * 829 * 1459 * 3919
03:38:47 <lambdabot>  317584931803
03:39:22 <faxathisia> @let facs 1=[];facs n=dr n:facs(n`div`dr n) where dr n=(!!0)$filter((==0).(n`mod`))[2..n]
03:39:27 <lambdabot> Defined.
03:39:28 <faxathisia> > facs 317584931803
03:39:29 <lambdabot>  [67,829,1459,3919]
03:40:38 <Cin> :t facs
03:40:39 <lambdabot> Not in scope: `facs'
03:40:58 <ac> > facs $ round $ exp 1 * 10 ** 15
03:41:00 <Cin> each nick gets their own environment?
03:41:05 <lambdabot> Terminated
03:41:07 <ac> hehehe
03:41:24 <dmwit> > let factor 1 = []; factor n = let p = head . filter (\p -> n `mod` p == 0) $ [2..] in p : factor (n `div` p) in factor 317584931803 -- the most naive possible way
03:41:25 <lambdabot>  [67,829,1459,3919]
03:41:33 <dmwit> still fast enough ;-)
03:41:43 <dmwit> :t find
03:41:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
03:42:05 <ac> > factor $ round $ exp 1 * 10 ** 15
03:42:06 <lambdabot>   Not in scope: `factor'
03:43:06 <ac> > facs $ round $ exp 1 * 10 ** 10
03:43:07 <lambdabot>  [5,7,7523,103237]
03:43:16 <ac> > facs $ round $ exp 1 * 10 ** 13
03:43:18 <lambdabot>  [2,5,227,9109,1314613]
03:43:20 <ac> > facs $ round $ exp 1 * 10 ** 14
03:43:29 <lambdabot> Terminated
03:44:14 <MarcWeber> dcoutts: On the other hand GHC Api is the only way to go because of template-haskell.
03:44:52 <faxathisia> > facs $ product $ [1..100]
03:44:54 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
03:46:00 <wagle_home> > facs (floor ( 1 / 0))
03:46:02 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
03:46:23 <povman> lambdabot: help
03:46:30 <povman> :?
03:46:36 <wagle_home> > length $ facs (floor ( 1 / 0))
03:46:37 <lambdabot>  1024
03:46:37 <dmwit> ?help
03:46:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:46:39 <dmwit> ?list
03:46:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
03:46:48 <ac> what's a pneumonic for nub?
03:46:48 <povman> dmwit: thx
03:46:50 <wagle_home> > last $ facs (floor ( 1 / 0))
03:46:51 <lambdabot>  2
03:46:59 <dmwit> ac: ...mnemonic?
03:47:06 <ac> yeah that
03:47:10 <dmwit> ac: What's to remember?
03:47:44 <povman> ?help docs
03:47:44 <lambdabot> docs <lib>. Lookup the url for this library's documentation
03:47:59 <byorgey> ac: Nothing but Unique Bits
03:48:08 <ac> why isn't it called "unique"?
03:48:18 <mauke> because nub is shorter
03:48:30 <byorgey> @dict nub
03:48:30 <dmwit> They aren't guaranteed to be unique, either, just unequal. ;-)
03:48:30 <lambdabot> Supported dictionary-lookup commands:
03:48:30 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
03:48:30 <lambdabot> Use "dict-help [cmd...]" for more.
03:48:36 <mauke> and captures the nub of the functionality
03:48:41 <scook0> @wn nub
03:48:41 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
03:48:42 <lambdabot> nub
03:48:44 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
03:48:46 <lambdabot>      2: a small piece; "a nub of coal"; "a stub of a pencil" [syn: {stub}]
03:48:49 <lambdabot>      3: the choicest or most essential or most vital part of some
03:48:50 <lambdabot> [5 @more lines]
03:49:25 <ac> I think it's one of the poorest named functions in the prelude
03:49:34 <swiert> I heard the name comes from "no unneccessary baggage".
03:50:00 <ac> swiert: thanks, there's my mnemonic
03:50:01 <mauke> well, it beats mappend
03:50:08 <swiert> *unnecessary even.
03:50:10 <ac> I think mappend is clever
03:50:22 <ac> :t mappend
03:50:22 <lambdabot> forall a. (Monoid a) => a -> a -> a
03:50:41 <ac> actually I shouldn't say that when I don't know what it does
03:50:50 <scook0> ac: monoid append
03:51:07 <scook0> > [1..3] `mappend` [4..6]
03:51:07 <ac> should be appendM then
03:51:09 <lambdabot>  [1,2,3,4,5,6]
03:51:21 <povman> actually intercalate is quite clever
03:51:27 <scook0> ac: that implies it's monadic, which it isn't
03:51:39 <scook0> > Nothing `mappend` Just 3
03:51:40 <lambdabot>   add an instance declaration for (Monoid (Maybe a))
03:51:40 <lambdabot>     In the expression: N...
03:51:49 <scook0> > Nothing `mappend` Just (3::Integer)
03:51:50 <lambdabot>        add an instance declaration for (Monoid (Maybe Integer))
03:51:50 <lambdabot>     In the ex...
03:52:04 <scook0> @instances Monoid
03:52:06 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
03:52:20 <povman> Monoid a => Monoid (Maybe a)
03:52:46 <povman> > Nothing `mappend` Just ()
03:52:46 <lambdabot>   add an instance declaration for (Monoid (Maybe ()))
03:52:46 <lambdabot>     In the expression: ...
03:52:48 <scook0> oh, actually I think there are a pair of them, First and Last
03:52:49 <dmwit> ?oeis 1 2 3 5 7
03:52:49 <lambdabot> a(n) = number of partitions of n (the partition numbers).
03:52:49 <lambdabot> [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,12...
03:53:06 <Cale> @version
03:53:07 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
03:53:07 <lambdabot> darcs get http://code.haskell.org/lambdabot
03:53:10 <Cale> hmm...
03:53:18 <ac> > mappend LT GT
03:53:19 <lambdabot>  LT
03:53:28 <ac> > mappend GT LT
03:53:29 <lambdabot>  GT
03:53:34 <mauke> > typeOf a
03:53:35 <lambdabot>   Not in scope: `a'
03:53:38 <mauke> :(
03:53:47 <ac> > mappend EQ LT
03:53:48 <lambdabot>  LT
03:53:49 <Cale> I should do something like give dons a copy of my home directory on code.h.o
03:54:10 <Cale> I wonder if lambdabot will listen to reason now...
03:54:13 <Cale> @quit
03:54:16 <ac> > mappend (1,2) (3,4)
03:54:21 <Cale> wait wait :)
03:54:45 <Cale> cool :)
03:54:49 <povman> wow
03:54:51 * ac switches to ghc :-[
03:54:56 <ac> er, ghci
03:55:00 <Cale> > mappend (1,2) (3,4)
03:55:11 <lambdabot>  Add a type signature
03:55:47 <ac> @index mappend
03:55:47 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
03:56:00 <mauke> > typeOf a
03:56:01 <lambdabot>   add an instance declaration for (Typeable Expr)
03:56:01 <lambdabot>     In the expression: type...
03:56:09 <mauke> :|
03:56:31 <Cale> > mappend (Sum 1, Product 2) (Sum 3, Product 4)
03:56:33 <lambdabot>  (Sum {getSum = 4},Product {getProduct = 8})
03:57:09 <Cale> > mappend ([1],[2]) ([3],[4])
03:57:11 <lambdabot>  ([1,3],[2,4])
03:57:38 <ac> ok, I have no idea what I'd use mappend for
03:57:49 <mauke> ac: chaining comparison functions in sortBy
03:57:56 <Cale> It sucks that it has such a crappy name.
03:58:08 <povman> wow - the docs should really include examples like that Cale
03:58:25 <povman> that makes it really obvious what it does
03:59:19 <mauke> sortBy (\a b -> (field1 a `compare` field1 b) `mappend` (field2 a `compare` field2 b))
03:59:22 <Cale> In some sense, there's only one good way to turn the type (a,b) into a monoid, when a and b are monoids.
04:00:07 <Cale> Well, there some less-good ways which still produce monoids.
04:00:41 <Cale> But the obvious thing is for (a,b) `mappend` (c,d) = (a `mappend` c, b `mappend` d)
04:00:45 <vininim> What is more common in haskell wrt to variable naming covention? cammelCase or under_lines ?
04:00:53 <Cale> camelCase
04:01:00 <Cale> by far.
04:01:07 <resiak> When wrapping Tracker, there's an enormous list (like http://hpaste.org/5632) of well-known property names that could do with having identifiers to avoid typos.  I want to write an isWellKnown :: Prop -> Bool function; can I avoid repeating all the identifiers in a straightforward manner using template haskell or something?
04:01:20 <ac> I tend to make library code camelCased and local code with underscored names
04:01:21 <resiak> Hrm, actually, maybe I should be codegenning the entire file from the list of string
04:01:38 <JohnMeacham> vincenz: I currently work at a botique financial company. I write progams that trade stocks. I get to do fun math.
04:03:59 <vincenz> JohnMeacham: sounds like fun
04:04:09 <povman> resiak: you can use TH to define a function which generates all those definitions, and use the same list of names in the definition of isWellKnown
04:13:21 <hpaste>  ToRA annotated "dealing with enormous lists of well-known strings" with "th & elem..." at http://hpaste.org/5632#a1
04:13:45 <ToRA|home> resaik: it looked like a fun little problem...hope that helps
04:14:54 <resiak> oh, that's pretty clear!
04:14:56 <resiak> thanks!
04:16:09 <povman> ToRA|home: you beat me, hmph
04:16:32 <ac> cabal-install is not installing gtk :-(
04:16:34 <ToRA|home> povman: hehe, sorry
04:17:08 <povman> just for the record, you can make nicer looking functions with Language.Haskell.TH.Lib
04:17:33 <ToRA|home> povman: ah cool
04:18:24 <ToRA|home> didn't know about that, i just went for the generalisation of runQ [d| prop_Example = Just "myString" |]
04:22:41 <povman> what's everyone's profession here?
04:22:57 * ac 's profession: programming
04:23:06 <mauke> HASKELL NOMAD
04:23:12 <povman> *monad
04:23:15 <mux> code monkey
04:23:21 <yondalf> student (yeah)
04:23:27 <ToRA|home> PhD student
04:24:08 <ac> gtk2hs takes a while to build
04:24:56 <ttt--> are there any ai projects in haskell that take advantage of the type system?
04:25:00 <povman> the way people seem to be able to answer any question regarding anything makes it seem like everyone's a researcher
04:25:11 <povman> or at least a select, verbose few
04:25:17 <ttt--> or depend on some of the features of haskell?
04:25:22 <ac> povman: the latter would be pretty accurate
04:30:53 <vininim> mmm.. what is the general workflow for literate programming with lots of modules?
04:32:31 <basvandijk> Hello, does something like the following on hpaste already exits anywhere?...
04:32:32 <hpaste>  basvandijk pasted "Control.Applicative.Combinators" at http://hpaste.org/5634
04:33:49 <JohnMeacham> someone drank my beer. was it you?
04:34:02 <basvandijk> I think it's useful to have a standard applicative combinator library that all parsers can use.
04:34:51 <pjd> basvandijk: wouldn't that go directly in Control.Applicative, ideally?
04:35:32 <basvandijk> Yes I that would be better
04:38:19 <basvandijk> The surprising thing for me was that all the standard Monad combinators like: sequence, guard, filterM, etc. are all actually applicative combinators and don't need a Monad at all.
04:39:38 <pjd> basvandijk: such is hindsight
04:40:06 <ttt--> does haskell have something like processes that you can spawn?
04:40:20 <basvandijk> ttt--: forkIO ?
04:40:34 <pjd> ttt--: Control.Concurrent ?
04:40:49 <ttt--> thanks
04:42:05 <ttt--> can you control or monitor how much cpu and memory they use?
04:43:03 <pjd> ttt--: for actual OS processes, System.Cmd, System.Process, and System.Posix.Process
04:43:12 <ac> ttt--: lambdabot pulls that off somehow
04:43:30 <pjd> lambdabot uses forked OS processes, IINM
04:43:39 <pjd> System.Posix.Resource
04:57:29 <ac> why would loading and running main from ghci produce different output than compiling with ghc and running?
04:57:46 <ac> specifically I have an OpenGL program that works properly when run from ghci, but when compiled it does nothing
04:57:58 <opqdonut> ghc optimizes?
04:58:24 <dmwit> Yay, 50 euler problems done!
04:58:29 <dmwit> I think it's time for a nap.
04:58:43 <yondalf> hmm...i should resume doing the euler problems
04:59:37 <ac> this used to work when I compiled it...
05:00:33 <smtms> ac, a compiler bug? :-)
05:00:40 <ToRA|home> ac: what compile lines and ghci invocations are you using?
05:01:39 <ac> ghc --make gtk_static.hs # no compile lines
05:02:03 <ac> doh, I must be tired
05:02:07 <ac> wrong freaking file
05:02:23 * ac needs the card board cutout to talk to
05:02:38 <nominolo> PEBKAC ;)
05:02:39 * ToRA|home glares at his nvidia drivers for crashing x
05:03:06 <permanente> heh, leksah installed like charm and did not crash. is that cool or what?
05:03:42 <nominolo> leksah sound like leksak
05:04:35 <nominolo> = "toy" in swedish :)
05:06:02 <resiak> ToRA|home: hmm, i have to split it across two files, I see :(
05:07:03 <imaverick> hi all though an off topic in this channel, does any one know where i can find a c# grammar
05:07:19 <vincenz> imaverick: ask on the c# channel?
05:07:44 <imaverick> thanks
05:09:53 <ToRA|home> resiak: yeah, code in a TH splice can't access functions defined in the same module
05:10:12 <ToRA|home> (but you can access data types defined in the same module, usefully)
05:10:56 <resiak> hmm, this works
05:11:24 <dmwit> > liftM2 (==) id reverse . filter (not . isSpace) $ "a man a plan a canal panama"
05:11:30 <lambdabot>  True
05:11:34 <dmwit> > liftM2 (==) id reverse . filter (not . isSpace) $ "a man a plan a canal panamania"
05:11:35 <lambdabot>  False
05:11:58 <resiak> bah, haddock of course can't see them >_<
05:12:36 * ac is happy there are more people in #haskell than #c#
05:12:42 <ToRA|home> resiak: umm, yeah that could be an issue
05:12:44 <dmwit> > (length "\\s -> s == reverse s", length "liftM2 (==) id reverse")
05:12:45 <lambdabot>  (20,22)
05:13:01 <ToRA|home> resiak: ghci's :browse should see them though
05:13:12 <dmwit> ?pl \s -> s == reverse s
05:13:12 <lambdabot> ap (==) reverse
05:13:16 <resiak> ToRA|home: yeah, it does
05:13:18 <dmwit> eh?
05:13:20 <dmwit> :t ap
05:13:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:13:27 <Twey> @src ap
05:13:27 <lambdabot> ap = liftM2 id
05:13:54 <vincenz> or if you want
05:13:58 <vincenz> ap = liftM2 ($)
05:14:03 * Twey nods.
05:14:04 <mauke> whenever you have a liftM2 whose second or third argument is id, you can use ap or >>= instead
05:14:12 <dmwit> Ooo, clever.
05:14:19 <pjd> > [length, reverse] <*> ["hello", "world"]
05:14:20 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
05:14:25 <pjd> oops
05:15:09 <vincenz> :t <$>
05:15:10 <lambdabot> parse error on input `<$>'
05:15:12 <pjd> > [join (++), reverse] <*> ["hello", "world"]
05:15:14 <lambdabot>  ["hellohello","worldworld","olleh","dlrow"]
05:15:14 <vincenz> :t (<$>)
05:15:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:15:21 <vincenz> :t (<*>)
05:15:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:15:39 <pjd> <*> == `ap`
05:15:48 <vincenz> <$> = liftM
05:15:56 <pjd> == fmap
05:16:27 <vincenz> </> == thwap
05:17:05 <dmwit> Surprisingly (to me), ap (==) reverse is faster than \s -> s == reverse s
05:18:44 <yondalf> :t ap (==) reverse
05:18:46 <lambdabot> forall a. (Eq a) => [a] -> Bool
05:19:37 <yondalf> okay this is something i should look at :-)
05:20:02 <dmwit> It tests for palindrome-ness.
05:20:26 <dmwit> The cool bit is that it looks like that's what it ought to do, but it's impossible to tell how it does it just by glancing. =)
05:20:49 * faxathisia I like palindrome(X) :- reverse(X,X). % :(
05:20:49 <dmwit> (Well, impossible for me.  I'm still figuring out the various monads/monadic functions.)
05:21:35 <resiak> hrm, given that this massive list isn't going to change much, I think I'll just copy-paste :-)
05:21:45 <yondalf> dmwit: well, you quoted it so you should have figured it out...i'm still stuck :-P
05:22:13 <yondalf> @src liftM2
05:22:13 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:22:20 * EvilTerran tends to read "ap" as "before-and-after"
05:24:35 <yondalf> so functions a->b are an instance of Monad? how do i view the definitions of return and >>=?
05:24:54 <faxathisia> @src >>= (->)
05:24:55 <lambdabot> Source not found. You speak an infinite deal of nothing
05:24:59 <faxathisia> @src >>= ((->)e)
05:25:00 <lambdabot> Source not found. My brain just exploded
05:25:05 <faxathisia> hmm... there is a way..
05:25:11 <yondalf> @src >>= id
05:25:11 <lambdabot> Source not found. Where did you learn to type?
05:25:16 <faxathisia> @instances Monad
05:25:18 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:25:23 <faxathisia> @src ((->) r) >>=
05:25:24 <lambdabot> Source not found. Wrong!  You cheating scum!
05:25:28 <doserj> @src (->) (>>=)
05:25:28 <faxathisia> @src (->) >>=
05:25:28 <lambdabot> f >>= k = \ r -> k (f r) r
05:25:28 <lambdabot> Source not found. I am sorry.
05:25:37 <faxathisia> @src (->) >>=
05:25:38 <lambdabot> Source not found. Maybe you made a typo?
05:25:40 <faxathisia> ok
05:25:45 <mauke> @src (->) return
05:25:46 <lambdabot> return = const
05:25:48 <yondalf> @src (->) return
05:25:48 <lambdabot> return = const
05:26:16 <vininim> what is the parsec for "until end of line"? manyTill char '\n' ?
05:26:20 <yondalf> now let me slowly digest this
05:26:31 <yondalf> vininim: i just use many1 (noneOf "\n")
05:27:10 <Stinger> > (+) >>= id $ 4
05:27:12 <lambdabot>  8
05:27:16 <Stinger> sweet
05:27:19 <mauke> many (noneOf "\n")
05:27:29 <mauke> Stinger: join (+) 4
05:27:36 <Stinger> I've been looking for a way to duplicate arguments for ages
05:27:49 <Cale> > join (*) 5
05:27:50 <lambdabot>  25
05:28:00 <mauke> @src join
05:28:01 <lambdabot> join x =  x >>= id
05:28:21 <faxathisia> Stinger: Don't hesitate to define new combinators
05:28:31 <Stinger> yeah it was more that I didnt know how the (->) monad worked than how join worked
05:28:43 <Cale> (also, join x = do { y <- x; v <- y; return v } )
05:28:59 <mauke> I like the confusing version better :-)
05:29:06 <mauke> (join x = do y <- x; y)
05:29:51 <resiak> aka x >>= id?
05:29:57 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
05:29:58 <lambdabot>  ("hello","olleh","HELLO")
05:30:01 <hpaste>  ac pasted "anybody experienced this gtk2hs problem?" at http://hpaste.org/5635
05:30:14 * resiak facepalms
05:30:33 <resiak> I use (xs >>= id) all the time on lists, and of course it should be pronounced join.
05:31:00 <mauke> resiak: concat
05:31:39 <resiak> or even that.
05:31:40 <hpaste>  ToRA annotated "dealing with enormous lists of well-known strings" with "don't copy paste...over-engineer :)" at http://hpaste.org/5632#a2
05:32:05 <ToRA|home> resiak: you could use the th to generate all your declarations for you to inline if you want...
05:32:15 <ToRA|home> resiak: though I guess you've already copy-pasted them by now :)
05:32:23 <resiak> ToRA|home: heh, i thought about that, but vim already did it for me :_)
05:32:43 <yondalf> are there any descriptions of the -> monad online?
05:32:50 <resiak> mauke: yeah, but i've used it on maybe maybe too
05:32:52 <mauke> @where all
05:32:53 <lambdabot> I know nothing about all.
05:32:58 <dcoutts_> ac: is that code running before calling initGUI? looks like the glib type system has not been initialised
05:33:37 <mauke> yondalf: http://www.haskell.org/all_about_monads/html/readermonad.html
05:33:38 <lambdabot> Title: The Reader monad
05:34:15 <ac> dcoutts_: thanks!
05:34:36 <yondalf> mauke: thanks :-) forgot about the true definition of the reader monad :-)
05:35:03 <ac> dcoutts_: that would have taken me a long time to figure out
05:36:58 <yondalf> :t (>>=)
05:36:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:54:01 <shapr> @users
05:54:02 <lambdabot> Maximum users seen in #haskell: 463, currently: 413 (89.2%), active: 18 (4.4%)
05:54:15 <hpaste>  jedbrown pasted "desugaring the do" at http://hpaste.org/5636
05:54:28 <jedbrown> ^^ This is confusing me.
05:55:20 <Lemmih> jedbrown: \op -> do p <- ...; ...
05:55:34 <nominolo> shapr: it used to be over > 475
05:55:38 <mauke> missing do
05:55:39 <vincenz> jedbrown: misssing a do
05:55:47 <vincenz> lol
05:55:57 <vincenz>   withForeignPtr ofp $ \op -> do
05:55:57 <nominolo> @quote triple stereo
05:55:58 <lambdabot> No quotes for this person. There are some things that I just don't know.
05:56:34 <jedbrown> Of course.  Thanks.  I'm still confused why the error message was on the wrong line.
05:57:01 * jedbrown has tunnel vision
05:57:10 <mauke> I blame hsc2hs
05:58:38 <jedbrown> mauke: I tried building the post-processed version, after filtering out the lines with {-# LINE ...
05:58:50 <jedbrown> mauke: But the error was still on the wrong line.
05:59:01 <ac> what do I do when a library has a datatype but doesn't define deconstructors? How do I get a definition of it without digging through the source?
05:59:22 <ricky_clarkson> Are there implementations of OOP atop Haskell?  Possibly using Wadler's Dyn stuff.
05:59:36 <mauke> @where oohaskell
05:59:37 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
05:59:58 <ac> nevermind, :info does the trick
06:01:36 <ricky_clarkson> Thanks.
06:03:01 <vininim> unexpected end of input
06:03:01 <vininim> expecting end of input or "COMMENT:"
06:03:04 <vininim> heh
06:08:27 <ac> why oh why does my pokeArray segfault?
06:09:19 <Lemmih> ac: Divine punishment?
06:10:25 <mux> poking into nullPtr ? :-)
06:12:02 <ac> @hoogle Ptr -> Word
06:12:04 <lambdabot> No matches, try a more general search
06:12:34 <ac> how do I get the memory address of a Foreign.Ptr?
06:13:09 <ac> (`minusPtr` nullPtr) I suppose
06:13:58 <opqdonut> :D
06:14:11 <opqdonut> that's not guaranteed to work, of course
06:15:04 <ac> why wouldn't it? (that gives a negative number BTW)
06:19:26 <ski> @users
06:19:26 <lambdabot> Maximum users seen in #haskell: 463, currently: 414 (89.4%), active: 18 (4.3%)
06:20:39 <Twey> How does it measure active users?
06:20:40 <Twey> @users
06:20:42 <lambdabot> Maximum users seen in #haskell: 463, currently: 415 (89.6%), active: 19 (4.6%)
06:20:48 <Twey> Yay
06:20:52 <Twey> I'm 0.3%
06:21:08 <mauke> Twey: http://tinyurl.com/ytzeab
06:21:53 <Cin> rickroll
06:21:54 <Cale> Perhaps: withForeignPtr fp (return . fromIntegral . ptrToIntPtr)
06:22:04 <shapr> I'm 0.1 %
06:22:15 <mauke> Cin: fail
06:22:20 <Twey> I've moved
06:22:20 <Cin> kind of unreadable
06:23:29 <jedbrown> ac: Do you need to change it, or just look at it?
06:24:31 <ac> I was just curious to see what it was. I don't really need to do either... just want to figure out why the heck poking at it results in a segfault
06:25:07 <vincenz> ac: nullPtr isn't necessarily 0
06:25:08 <Cale> ac: Perhaps it's a pointer to somewhere outside your program's memory?
06:25:16 <vincenz> on windows, i ndebug mode, null-pointer si #4something
06:25:24 <vincenz> s/si/is
06:25:24 <mux> vincenz: if it follows the C spec it should :)
06:25:30 <mux> alas..
06:25:41 <ac> Cale: hm, I guess I could test that by poking [0::Word8], right?
06:27:12 <ac> @index withForeignPtr
06:27:13 <lambdabot> Foreign.ForeignPtr, Foreign
06:28:45 <ac> Cale: that also returns a negative number, for some reason
06:28:58 <Cale> ac: Int is signed.
06:29:43 <ac> the number is also larger than the amount of memory I have
06:30:08 <mauke> mux: if it follows the C spec, `minusPtr` is undefined unless both pointers point into the same array
06:30:08 <ac> but it's the same number that minusPtr nullPtr returns
06:30:35 <vincenz> > ceil (1/0)
06:30:41 <lambdabot>   Not in scope: `ceil'
06:30:42 <mux> mauke: that's another problem though
06:30:46 <vincenz> > ceiling (1/0)
06:30:50 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
06:30:56 <ac> lol
06:31:00 <vincenz> > length . show . ceiling $ (1/0)
06:31:01 <lambdabot>  309
06:31:11 <vincenz> > length . show $ 2^2^2^2^2
06:31:12 <lambdabot>  19729
06:31:26 <vincenz> a number biggerr than infinity :)
06:31:50 <ac> That is very bizarre behavior
06:32:04 <vincenz> not really
06:32:12 <vincenz> @hoogle maxFloat
06:32:16 <lambdabot> No matches found
06:32:17 <vincenz> @hoogle maxDouble
06:32:17 <lambdabot> No matches found
06:32:31 <ac> > maxBound :: Float
06:32:33 <lambdabot>   add an instance declaration for (Bounded Float)
06:32:33 <lambdabot>     In the expression: maxB...
06:32:42 <vincenz> ac: oddly, it's not bounded :)
06:32:50 <vincenz> > 10**309
06:32:51 <lambdabot>  Infinity
06:32:58 <vincenz> > 10**308
06:32:58 <lambdabot>  1.0e308
06:33:01 <vincenz> ;)
06:33:01 <ac> The bound would be pretty meaningless (Infinity)
06:33:08 <vincenz> > 10**308 * 5
06:33:09 <lambdabot>  Infinity
06:33:11 <vincenz> > 10**308 * 3
06:33:11 <lambdabot>  Infinity
06:33:13 <vincenz> > 10**308 * 2
06:33:13 <lambdabot>  Infinity
06:33:21 <vincenz> > 10**308 *
06:33:21 <lambdabot>   parse error on input `}'
06:33:22 <vincenz> > 10**308 *1
06:33:23 <lambdabot>  1.0e308
06:33:28 <vininim> heh
06:33:38 <vincenz> > 10**308 *1.9999999
06:33:38 <lambdabot>  Infinity
06:33:41 <vincenz> > 10**308 *1.99999
06:33:41 <lambdabot>  Infinity
06:33:43 <vincenz> > 10**308 *1.9999
06:33:44 <lambdabot>  Infinity
06:33:44 <ac> > 10e309
06:33:46 <lambdabot>  Infinity
06:33:54 <vincenz> > 1e309
06:33:55 <lambdabot>  Infinity
06:34:16 <vininim> > 0.9999e308
06:34:16 <vincenz> who knew infinity was so small
06:34:17 <lambdabot>  9.999e307
06:34:25 <vininim> > 0.9999e309
06:34:26 <lambdabot>  Infinity
06:34:27 <vincenz> vininim: I can get 1e308
06:34:36 <vincenz> but not 2e308
06:34:50 <Syzygy-> > 1.1e308
06:34:51 <lambdabot>  1.1e308
06:34:55 <Syzygy-> > 1.5e308
06:34:56 <lambdabot>  1.5e308
06:34:56 <ac> vincenz: is there anything non-arbitrary about ceiling(1/0)?
06:35:12 <vincenz> ac: philosophically?
06:35:15 <Syzygy-> > 1.8e308
06:35:16 <lambdabot>  Infinity
06:35:20 <Syzygy-> > 1.79e308
06:35:21 <lambdabot>  1.79e308
06:35:34 <vincenz> > 1.795e308
06:35:34 <lambdabot>  1.795e308
06:35:38 <vincenz> > 1.797e308
06:35:39 <lambdabot>  1.797e308
06:35:42 <vincenz> > 1.799e308
06:35:42 <lambdabot>  Infinity
06:35:49 <Syzygy-> > 1.79769313486e308
06:35:50 <lambdabot>  1.79769313486e308
06:35:51 <osfameron> eeek, #haskell is more incomprehensible even than usual
06:35:58 <idnar> heh
06:36:06 <Syzygy-> osfameron: We're treading the border of infinity
06:36:08 <vincenz> Syzygy-: well played
06:36:08 <ac> ceiling(1.79769313486e308)
06:36:11 <ac> > ceiling(1.79769313486e308)
06:36:11 <lambdabot>  1797693134859999934634121101919578678721769031470241902291691506646167202234...
06:36:22 <vincenz> ooh
06:36:22 <ac> I see
06:36:23 <vincenz> I know
06:36:25 <osfameron> careful not to split the atom by mistake!  and be back by teatime!
06:36:37 <vincenz> > fromIntegral $ (ceiling (1/0) - 1) :: Double
06:36:40 <Syzygy-> I'll settle with splitting the thaum.
06:36:41 <lambdabot>  Infinity
06:37:02 <vincenz> Syzygy-: hah, try to split a planck length
06:37:04 <ac> > fromIntegral $ (ceiling (1/0) - 100) :: Double
06:37:05 <lambdabot>  Infinity
06:37:31 <vincenz> as far as I can tell, you cnan't split a planck leength
06:37:44 <ac> > fromIntegral $ (ceiling (1/0) - 10000) :: Double
06:37:44 <lambdabot>  Infinity
06:37:47 <ac> hmmm
06:38:05 <vincenz> > ceiling (1/0) - floor (1/0)
06:38:05 <lambdabot>  0
06:38:30 <vincenz> > ceiling (-1/0)
06:38:31 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
06:38:32 <ac> well, Infinity must be an integer
06:38:35 <vincenz> > ceiling (1/-0)
06:38:35 <lambdabot>   Not in scope: `/-'
06:38:40 <vincenz> > ceiling (1/(-0))
06:38:41 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
06:38:45 <vincenz> negative 0!
06:40:06 <vincenz> > ceiling (1/(1-1))
06:40:07 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
06:40:13 <vincenz> > ceiling (1/(-1+1))
06:40:14 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
06:40:22 <vincenz> I wonder if you can actually ever get a -0
06:40:25 <vincenz> except by literal
06:41:15 <vincenz> > ceiling (1/(-(1-1)))
06:41:15 <lambdabot>  -179769313486231590772930519078902473361797697894230657273430081157732675805...
06:41:36 <vincenz> heh, numbers don't obey algebraic laws
06:41:44 <vincenz> -(1-1) /= -1+1
06:41:53 <czakey> > flor ( 1 `div` 2)
06:41:55 <lambdabot>   Not in scope: `flor'
06:41:59 <czakey> huh
06:42:11 <czakey> > floor ( 1 `div` 2)
06:42:12 <lambdabot>  Add a type signature
06:42:31 <vincenz> :t floor
06:42:34 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
06:42:43 <vincenz> :t div
06:42:44 <lambdabot> forall a. (Integral a) => a -> a -> a
06:42:47 <vincenz> that won't work, czakey
06:42:52 <czakey> I see
06:42:54 <vincenz> I don't know any type that is both RealFrac and Integral
06:43:14 <vincenz> besides, you'd have to annotate it
06:43:20 <vincenz> haskell only defaults to Integer and Double
06:43:29 <vincenz> neither of those all in that intersection
06:43:36 <vininim> -0 only makes sense in Floats, right?
06:43:36 <vincenz> s/all/fall
06:43:48 <vininim> *Real
06:44:02 <vincenz> vininim: I guess only numbers with infinities
06:44:25 <vincenz> 0 and -0 become eps and -eps
06:44:36 <ac> vininim: don't try to comprehend Haskell's '-' syntax
06:44:37 <matthew_-> how do I pursuade ghc that additional type sigs on instance methods are acceptable?
06:44:40 <vininim> explains why they don't follow algebraic rules =P
06:44:43 <ari> vininim: It makes perfect sense for any kind of signed numbers, but IEEE floats are special in that they have both a positive zero and a negative zero
06:44:46 <ac> vininim: and why do you have such an annoyingly similar nick to vincenz?
06:44:47 <vininim> they are promoted to non algebraic numbers
06:44:57 <vincenz> Syzygy-: splitting a plancklength yet?
06:45:18 <ari> vininim: Where perfect sense: 0 == -0
06:45:35 <ari> > 0.0 == negate 0
06:45:36 <lambdabot>  True
06:45:40 <vininim> ac: well, it's my real life nickname, it predates my real name, and I didn't even know haskell when I started using it :)
06:45:58 <Syzygy-> vincenz: I'm trying to answer that question, but I'm typing faster than the Plancktime now, so my keyboard drivers can't keep up.
06:46:10 <vincenz> Syzygy-: I think it's not possible
06:46:18 <Syzygy-> I only manage to type this by timing the typing of Shakespeare's Complete Works just right. ;)
06:46:20 <vincenz> I've heard that physics changes
06:46:26 <vincenz> basicaclly
06:46:38 <vincenz> physics behaves the same way for k*pl as for pl/k
06:46:43 <Syzygy-> Remember kids: don't try this at home.
06:47:06 <Stinger> "don't try this in your home universe"
06:47:10 <vincenz> that's why shrunken dimensions may have other beings living in them
06:47:10 <ac> > isNegativeZero (-0)
06:47:11 <lambdabot>  True
06:47:21 <vincenz> there's 13 dimensions, last count
06:47:27 <ac> > isNegativeZero $ negate (-0)
06:47:28 <lambdabot>  False
06:47:29 <vincenz> 9 of those are rolled up into something smaller than a plancklength
06:47:34 <vincenz> so maybe people are living there
06:47:39 <vincenz> but we can't get through the plankclength peephole
06:48:11 <ac> > isNegativeZero $ (-0) - (-0)
06:48:12 <lambdabot>  False
06:48:20 <ac> > isNegativeZero $ (-0) + (-0)
06:48:21 <lambdabot>  True
06:48:48 <Stinger> how small is a plancklength?
06:48:57 <vincenz> @google plank length
06:48:57 <lambdabot> http://en.wikipedia.org/wiki/Planck_length
06:48:57 <lambdabot> Title: Planck length - Wikipedia, the free encyclopedia
06:49:02 <ac> why in the world does IEEE specify a negative zero?
06:49:07 <vininim> > length planck
06:49:08 <lambdabot>   Not in scope: `planck'
06:49:21 <vincenz> 1.6 e 10^-35 meters
06:49:46 <matthew_-> > 1 - 
06:49:47 <lambdabot>  Illegal character ''\190''
06:49:47 <lambdabot>  at "" (column 6)
06:49:51 <faxathisia> lol
06:49:53 <ac> @let planckLength = 1.6e-35
06:49:57 <lambdabot> Defined.
06:50:20 <vininim> needs a Monad unit in that
06:50:24 <vininim> *unit Monad
06:50:52 <vininim> people will sure try to measure plancklenght with their king's foot or something
06:51:34 <ac> matthew_-: I would have been floored if that actually worked
06:51:53 <matthew_-> ac: I tried it in ghci first ;)
06:52:02 * matthew_- continues to campaign for better unicode support ;)
06:52:03 <ac> it should totally work
06:52:10 <kaol> > floor "ac"
06:52:11 <lambdabot>   add an instance declaration for (RealFrac [Char])
06:52:11 <lambdabot>     In the expression: fl...
06:52:50 * ac joins the better unicode support campaign
06:54:00 * Cale starts another campaign for better EBCDIC support.
06:54:25 <matthew_-> Cale: one thing at a time please!
06:56:26 <matthew_-> > 1 - (ord '')
06:56:27 <lambdabot>  Improperly terminated character constant at "'')" (column 10)
06:57:21 <matthew_-> heh, that's an irc artifact - it actually works in ghci
06:59:35 <ac> hm, that's not actually unicode
06:59:44 <matthew_-> no, it's just extended latin-1
07:00:07 <ac> I didn't think my terminal supported unicode
07:17:29 <pitecus> how does one implement an atom/symbol type (like in Prolog/Scheme) in Haskell? Using hashtables and unsafePerformIO?
07:17:49 <vincenz> pitecus: define symbol type
07:18:03 <matthew_-> pitecus: you want a global universe into which you can just chuck values?
07:18:07 <mauke> @docs Data.Unique
07:18:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-Unique.html
07:18:26 <pitecus> mathrick, vincenz i want interned strings basically
07:19:06 <mathrick> pitecus: *matthew_-
07:19:29 <pitecus> oops sorry
07:19:35 <matthew_-> mathrick: ;)
07:21:42 <pitecus> so i want functions toAtom :: String -> Atom and fromString :: Atom -> String, where Atom is somthing like newtype Atom = A Int
07:22:01 <pitecus> the same string should always map top the same Atom
07:24:18 <phobes> pitecus:  If you're not flexible about changing the signatures, then ya, you probably need unsafePerformIO
07:25:21 <pitecus> phobes, ok then. how unsafe is it really?
07:25:23 <matthew_-> why don't you just use a Map and State ?
07:25:43 <phobes> pitecus:  I'm not a good person to answer that :)
07:26:04 <gbacon> has anyone been able to build leksah against Cabal-1.3.3?
07:26:31 <phobes> pitecus:  I don't know how unsafePerformIO interacts with threads, for example
07:26:44 <pitecus> matthew-_, there should be just one global state
07:31:35 <matthew_-> pitecus: that's debatable. Given that IO pretty much just uses State I would be unconvinced of any system that requires more magic than that
07:33:11 <vininim> parsec <3 <3 <#
07:33:38 <pitecus> matthew-_, when you run state you pass some initial state as an arg, you could mix them up
07:34:00 <pitecus> matthew-_, plus its a pain to have to do everything in  the state monad just coz i need atoms
07:34:17 <gbacon> @ty unlit
07:34:24 <matthew_-> well if you use unsafePerformIO then you're basically doing that anyway, just under a more convenient API
07:34:25 <lambdabot> Not in scope: `unlit'
07:34:28 <idnar> vininim: parsec makes your heart pound?
07:34:28 <matthew_-> which is also unsafe
07:34:42 <vininim> pretty much heh
07:34:43 <gbacon> @ty Distribution.Simple.PreProcess.Unlit.unlit
07:34:44 <lambdabot> FilePath -> String -> String
07:34:59 <pitecus> matthew-_, at least i have a guarantee there is only one unique global state around
07:35:23 <matthew_-> pitecus: so long as you're single threaded
07:35:24 <matthew_-> ;)
07:35:39 <matthew_-> actually, that's probably not true. I don't know enough about the internals of GHC for that
07:36:02 <gbacon> > Distribution.Simple.PreProcess.Unlit.unlit "foo" $ unlines ["> bar","","baz"]
07:36:03 <lambdabot>      Not in scope: `Distribution.Simple.PreProcess.Unlit.unlit'
07:36:05 <pitecus> matthew-_, yep thats the thing... what is unsafe about using unsafePerformIO to do that? is it unsafe just with threads?
07:36:21 <phobes> pitecus:  If you use the Monad pervasively and only call runState once, you obviously get that gaurantee
07:37:21 <matthew_-> pitecus: I suspect that unsafePerformIO interacts badly with laziness. I dunno, because you're not supposed to use it, I don't.
07:37:56 <gbacon> > Distribution.Simple.PreProcess.Unlit.unlit
07:37:57 <lambdabot>      Not in scope: `Distribution.Simple.PreProcess.Unlit.unlit'
07:38:05 <gbacon> @ty Distribution.Simple.PreProcess.Unlit.unlit
07:38:06 <lambdabot> FilePath -> String -> String
07:38:07 <phobes> @go stretching the storage manager
07:38:09 <lambdabot> http://citeseer.ist.psu.edu/peytonjones99stretching.html
07:38:09 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Jone ...
07:38:18 <pitecus> phobes, im not sure how to make the library provide that guarantee rather than relying on the user to just call runState once
07:38:32 <phobes> pitecus:  I can't say for sure, but I think that paper I just googled might have information you want
07:38:39 <phobes> pitecus:  About using unsafePerformIO
07:39:04 <pitecus> phobes, aha, thanks
07:39:23 <phobes> Ya, look at the 'stable names' example
07:39:26 <phobes> I think that's what you want
07:40:41 <pitecus> cool
07:41:01 * Nafai makes a note to check out Leksah
07:42:45 <ac> what kind of text editor does Leksah use?
07:43:20 <gbacon> ac: not sure, still trying to build it
07:43:54 <ac> someday I will write my own Haskell IDE in Haskell ;)
07:44:14 <gbacon> ac: Cabal-1.3.3 changes are giving it heartburn
07:45:11 <dcoutts> bgeron: use Cabal-1.2.3.0, that'll be what it was tested against.
07:45:26 <dcoutts> oops gbacon not bgeron
07:45:50 <gbacon> dcoutts: how do I force that version?
07:47:36 <dcoutts> gbacon: currently you'd have to hack the .cabal file to use: build-depends: Cabal >= 1.2 && < 1.3
07:48:38 <gbacon> dcoutts: thanks.. didn't know if there was a more hands-off approach
07:49:16 * shepheb feels dirty after having to load Windows on his laptop for the first time in several weeks.
07:49:32 <shepheb> my xmonad... I miss it after 30 seconds.
07:50:00 <ac> last time I booted Windows was to play StarCraft :-P. Hadn't booted it in about a year
07:50:14 <mux> heh, windows drives me mad; everytime I start it, it's been months since it last ran, and thus it always greets me with nice 'Your computer might be in danger' messages
07:50:19 <dcoutts> gbacon: upstream probably wants that patch too btw, so do darcs send it
07:50:38 <mux> or tells me my icons are unused, but it's only windows that is unused *sigh*
07:50:40 <gbacon> dcoutts: on it!
07:51:01 <dbpatterson> ac: wine doesnt work for you?
07:51:08 <byorgey> shepheb: heh, yeah, I keep trying to use various key combinations to switch between windows on my work computer... =P
07:51:24 <ac> dbpatterson: I did actually get that working once, but never with multiplayer over the internet
07:51:45 <dbpatterson> ac: ahh.. well, worth a shot anyway
07:52:55 <shepheb> byorgey: yeah, I just tried to mod-shift-enter. and I had to use a /mouse/ to navigate and run things. I'd forgotten how big a win keyboardful tools like xmonad are on a laptop.
07:53:43 <shepheb> there! task done, rebooting. forgive me father, for I have sinned.
07:57:38 <matthew_-> ahh, the abomination that are floats.
07:57:39 <matthew_-> Prelude> let f (x::Float) (y::Int) = if x - (fromIntegral $ y) /= 0 then (x, y) else f (x+1) (y+1) in f 0 0
07:57:39 <matthew_-> (1.6777216e7,16777218)
07:58:00 <Deewiant> > [0.1,0.2..0.5]
07:58:05 <lambdabot>  [0.1,0.2,0.30000000000000004,0.4,0.5]
07:58:12 <Deewiant> "woops"
07:58:17 <matthew_-> yeah, I know that one too
07:58:43 <matthew_-> the fact that floats go wrong for floats is kinda acceptable. The point at which they diverge from ints is perhaps more important
07:58:56 <hpaste>  vininim pasted "type error while using parsec" at http://hpaste.org/5638
07:59:30 <vininim> as matter of fact, it's not probably not related to parsec
07:59:44 <Lemmih> vininim: use 'genericLength'.
07:59:49 <Lemmih> vininim: And use the do-notation.
08:00:05 <vininim> no, I hate do-notation =P
08:00:18 <glen_quagmire> maybe fromIntegral?
08:00:46 <glen_quagmire> probably liftM
08:00:49 <Lemmih> In the same way 8 year olds hate taking showers...
08:00:57 <vininim> @hoogle genericLength
08:00:58 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
08:02:43 <vininim> I'm not using do notation until I grasp monad fully
08:02:59 <vininim> it kinds of hides the flow of the monads
08:03:07 <matthew_-> that's kinda the point ;)
08:03:22 <matthew_-> besides, it's a purely mechanical translation to/from do-notation
08:06:54 * osfameron finds do-notation surprisingly lovely consiering how fugly the underlying code with explicit monadic plumbing is
08:07:23 * cjb agrees.
08:08:35 * glen_quagmire doesn't know about monad
08:17:29 <tensh> I want to write a combine method for two IO executions
08:17:38 <tensh> right now I'm doing this:
08:17:59 <tensh> forkIO $ myIO >>= \_ -> return ()
08:18:05 <tensh> myIO
08:18:51 <tensh> things doesn't seem to be executed in parallell though
08:19:10 <byorgey> tensh: by the way, foo >>= \_ -> bar  is the same as foo >> bar
08:19:18 <tensh> oh, yeah
08:19:20 <tensh> true :)
08:19:55 <tensh> you have any idea about the concurrency problem?
08:20:15 <tensh> it seems like the new thread is just queued
08:20:28 <matthew_-> tensh: yeah
08:20:39 <matthew_-> run it with ./Main +RTS -N2 -RTS
08:20:41 <matthew_-> iirc
08:20:52 <vininim> > Just True >>=\_-> Just True -- fish
08:20:53 <tensh> yikes
08:20:54 <matthew_-> you actually need to tell your compiled binary how many OS threads to use
08:20:56 <lambdabot>  Parse error at "->" (column 16)
08:21:04 <hpaste>  ac pasted "does this gtk demo work for everyone?" at http://hpaste.org/5639
08:21:13 <vininim> awww
08:21:15 <tensh> matthew_-: is it possible to do within ghci?
08:21:19 <EvilTerran> > lex ">>=\_->"
08:21:20 <lambdabot>  Illegal escape sequence at "">>=\..." (column 5)
08:21:23 <EvilTerran> > lex ">>=\\_->"
08:21:25 <lambdabot>  [(">>=\\","_->")]
08:21:33 <matthew_-> tensh: possibly, if you start ghci up with +RTS -N2 -RTS
08:21:41 <EvilTerran> you're allowed \s in operators; >>=\ gets lexed as an operator
08:21:47 <matthew_-> the 2 is the number of OS threads to use
08:21:59 <matthew_-> so if you have 4 CPU Cores then I'd suggest -N4
08:22:23 <tensh> ahh, I see
08:23:08 <matthew_-> the ghc runtime will happily multiplex so you can write for lots of threads and the ghc runtime will only use OS threads as you specify
08:23:11 <tensh> ghci wouldn't take -N2 as a flag though
08:23:17 <matthew_-> ah, bummer
08:23:20 <tensh> can't find anything about threds there either
08:23:20 <jedbrown> Note that the the 2 or 4 is the number of threads that the runtime will actually schedule.  It keeps more around in case some block on foreign calls.
08:23:23 <vininim> > lex ".o/-<."
08:23:24 <lambdabot>  [(".","o/-<.")]
08:23:37 <matthew_-> ms@arkansas:~$ ghci-6.8.2 +RTS -N2 -RTS
08:23:41 <matthew_-> seems to work for me
08:24:10 <tensh> ahh, got 6.4
08:24:11 <ac> I'm curious if anybody experiences segfaults when running that. I don't
08:24:19 <nornagon> 6.4?!
08:24:27 <tensh> ghci 6.4, yes
08:24:35 <tensh> it's on the school system :(
08:24:40 <nornagon> that's at least 100 years old.
08:24:41 <Lemmih> tensh: +RTS -N2 -RTS
08:24:49 <vininim> > lex "..."
08:24:50 <lambdabot>  [("...","")]
08:24:55 <Lemmih> Oh, I'm not very fast.
08:24:55 <tensh> Lemmih: ghci 6.4 doesn't seem to support it
08:24:56 <vininim> nice
08:24:59 <nornagon> @doc lex
08:24:59 <lambdabot> lex not available
08:25:35 <tensh> *sigh* school system used to be so much better before they kicked out the students from the administration and hired "professionals"
08:25:35 <Lemmih> tensh: You need at least 6.6. I'd recommend 6.8
08:25:36 <matthew_-> tensh: definately it works in 6.8
08:25:42 <vininim> > a ... b :: [Expr]
08:25:45 <tensh> alright
08:25:45 <lambdabot>   Not in scope: `...'
08:25:47 <matthew_-> tensh: > let f (x::Double) (y::Int) = if x - (fromIntegral $ y) /= 0 then (x, y) else f (x+1) (y+1) in (forkIO $ print $ f 0 0) >> (forkIO $ print $ f 0 0) >> return ()
08:25:58 <matthew_-> that's using up both cores very nicely here
08:26:07 <tensh> then I've got to be able to do it some other way as well, since I'm doing this in a lab
08:26:26 <matthew_-> can you not install your own ghc, even in your $HOME ?
08:26:34 <tensh> I guess
08:26:35 <matthew_-> or is it a case that it'll only be run on 6.4 ?
08:26:42 <vininim> > let _ ... _ = True in a ... b :: [Expr]
08:26:44 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Bool'
08:26:49 <ToRA|home> ac: I don't segfault
08:26:50 <vininim> > let _ ... _ = True in a ... b :: Expr
08:26:51 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Bool'
08:26:59 <ac> ToRA|home: you see RGB static, right?
08:27:04 <ToRA|home> ac: >ghci --make Baz.hs -e 'main'
08:27:04 <tensh> matthew_-: probably be run on 6.4
08:27:07 <pejo> matthew, people typically have small quotas, and ghc is a monster to build.
08:27:09 <tensh> I don't know
08:27:10 <ToRA|home> ac: eventually, yes :)
08:27:20 <Lemmih> tensh: Concurrency does work with 6.4 as long as you don't care about using multiple cores.
08:27:20 <ac> ToRA|home: huh, on my system it displays it in half a second
08:27:23 <vininim> > let a ... b = f a b in a ... b :: Expr
08:27:24 <lambdabot>  f a b
08:27:29 <tensh> I have a lab deadline at midnight anyway, so I need to spend my time wisely
08:27:32 <matthew_-> pejo: sure. We had a large dump which was enourmous and would be sometimes emptied without warning
08:27:35 <vininim> but... :/
08:27:48 <matthew_-> pejo: but it gave us space to build stuff like that and then install it in $HOME
08:27:49 <ToRA|home> ac: about 5 seconds here to come up
08:28:02 <ac> ToRA|home: oh, you're using ghci
08:28:04 <tensh> Lemmih: alright... it's just that it seems like my thread only gets queued instead of run in parallell
08:28:06 <ToRA|home> ac: AMD Athlon XP 2400+ though, so not that fast :)
08:28:08 <tensh> when I use forkIO
08:28:13 <matthew_-> Lemmih: the runtime was single threaded back then?
08:28:15 <EvilTerran> > typeOf a
08:28:16 <lambdabot>   add an instance declaration for (Typeable Expr)
08:28:16 <lambdabot>     In the expression: type...
08:28:25 <ToRA|home> ac: ah yeah also true
08:28:29 <Lemmih> matthew_-: Yes.
08:28:57 <ToRA|home> ac: compiling shaves a second or so off
08:28:59 <Lemmih> tensh: That shouldn't be.
08:30:12 <Lemmih> tensh: How do you tell?
08:30:59 <tensh> matthew_-, Lemmih: http://hpaste.org/5640
08:31:04 <tensh> that's the relevant code snippet
08:31:06 <vininim> @hoogle [m a] -> m [a]
08:31:07 <lambdabot> Prelude.head :: [a] -> a
08:31:07 <lambdabot> Prelude.last :: [a] -> a
08:31:07 <lambdabot> Data.List.head :: [a] -> a
08:31:14 <tensh> Lemmih: I'm constructing a tree recursively
08:31:25 <ToRA|home> @type sequence
08:31:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:31:39 <tensh> kinda like (buildBranch <|> buildBranch)
08:31:40 <vininim> thanks
08:32:13 <tensh> but it prioritizes left all the time
08:32:40 <Lemmih> tensh: Sure, context switches may only happen a few times a second.
08:32:53 <tensh> ahh
08:33:01 <tensh> hmm
08:33:01 <matthew_-> you can control that with -C and -V RTS params
08:33:12 <matthew_-> well, I say control. You can *influence* them...
08:33:54 <Lemmih> tensh: I wouldn't if I were you, though. It's only gonna make it slower.
08:33:56 <tensh> ahh
08:34:10 <tensh> Lemmih: well, I only want to do it to see if it works
08:34:18 <tensh> but there's nothing wrong with my code, right?
08:35:09 <tensh> still doesn't seem to work :(
08:35:13 <tensh> even though it's kinda slow now
08:35:28 <Lemmih> The code looks fine.
08:35:46 <Lemmih> tensh: You can't use -V and -C with ghci.
08:36:04 <tensh> ghci 6.4 supports -C at least
08:36:24 <tensh> -V, not so much
08:36:39 <Lemmih> Oh, right.
08:36:56 <tensh> what does -V do?
08:37:11 <matthew_-> wow, ghc 6.8 has cpu affinity settings!
08:37:25 <matthew_-> how on earth can it do that?
08:37:52 <matthew_-> because how do you know which CPU the OS threads have been scheduled on
08:38:05 <matthew_-> or do you? Are there ways of finding that out?
08:39:02 <ac> @pl \a -> ((+1) a, (*2) a)
08:39:02 <lambdabot> liftM2 (,) (1 +) (2 *)
08:39:28 <tensh> well, thanks for the help anyway
08:39:37 <ac> > (+1) &&& (*2) 5
08:39:40 <lambdabot>   add an instance declaration for (Num (b -> c'))
08:40:01 <tensh> I'll just have to send it in like this and let my tutors take care of it :)
08:40:15 <ToRA|home> :t (succ *** (*2)) <<< (join (&&&) id)
08:40:16 <Stinger> > (+1) &&& (*2) $ 5
08:40:16 <lambdabot> forall b. (Num b, Enum b) => b -> (b, b)
08:40:17 <lambdabot>  (6,10)
08:40:33 <tensh> this does make it kinda hard to test for associativity and commutatitivy though
08:41:00 <pejo> matthew_, I'm not sure what you are asking, but the OS will schedule the stuff on the selected CPU's if you do sched_setaffinity().
08:41:08 <matthew_-> tensh: in general, people here are slightly careful about doing student's homework  - I'm accusing you of asking for that, I'm just saying that people tend to watch out for that. :)
08:41:21 <ac> &&& is such an ugly operator I'd rather just say (\x -> (a x, b x))
08:41:23 <matthew_-> pejo: ahh, is that posix or linux specific?
08:41:23 <mux> except that sched_setaffinity() is Linux specific
08:41:27 <matthew_-> gotcha
08:41:53 <pejo> matthew, linux specific, but I think atleast FreeBSD is considering a similar API.
08:42:08 <tensh> matthew_-: yes, but this can hardly be considered as someone else doing my homework in my opinion since this is just a small part of a big lab
08:42:09 <mux> yes, this was under discussion
08:42:14 <pejo> matthew, I wouldn't be surprised if you find similar things on commercial unices, I just don't know what they are called.
08:42:18 <matthew_-> tensh: indeed :)
08:42:22 <mux> there is no consensus on wether this API is appropriate though
08:42:23 <ac> @index (&&&)
08:42:23 <lambdabot> Control.Arrow
08:43:02 <ToRA|home> ac: but all those ... brackets ...
08:43:09 <ac> @index getArgs
08:43:10 <lambdabot> System.Environment
08:43:57 <gbacon> what's a nice lightweight sendmail replacement suitable for use with darcs send?
08:44:18 <mux> ssmtp maybe?
08:44:28 <mux> I was tempted to just answer postfix, but oh well :)
08:44:41 <ac> how would I turn (IO a, IO b) to IO (a, b)?
08:45:01 <conal> ac: liftM2 (,)
08:45:15 <ac> > liftM2 (,) (return 1, return 2)
08:45:15 <lambdabot>   add an instance declaration for (Monad ((,) (m t)))
08:45:16 <lambdabot>     In the expression: ...
08:45:18 <dons> ?users
08:45:18 <lambdabot> Maximum users seen in #haskell: 463, currently: 429 (92.7%), active: 22 (5.1%)
08:45:20 <ToRA|home> @type uncurry (liftM2 (,))
08:45:21 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
08:45:36 <conal> liftM2 (,) (return 1) (return 2)
08:45:49 <conal> @ty liftM2 (,) (return 1) (return 2)
08:45:49 <lambdabot> forall a1 a2 (m :: * -> *). (Num a2, Monad m, Num a1) => m (a1, a2)
08:46:09 <gbacon> max: I tried using --sendmail-command='thunderbird -compose "..."' but no dice
08:46:32 <conal> @ty uncurry (liftM2 (,))
08:46:33 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
08:46:39 <conal> that's your friend
08:47:01 <Lemmih> ac: You rarely end up with (m a, m b).
08:47:24 <ac> Lemmih: yeah you're right. I was creating such a type, and I really don't need to
08:47:34 <desegnis> gbacon: My box runs esmtp, which at least features a clean .esmtprc syntax
08:48:45 <ac> I'm pleased with conal's solution though
08:49:31 <mux> :t uncurry (liftA2 (,))
08:49:32 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
08:50:10 <tensh> matthew_-: it appears that it works somehow anyway
08:50:43 <ac> sweet, I just wrote an image viewer with gtk. Man that was easy
08:50:59 <tensh> I made it wait for keypress before drawing each line and it built itself in a seemingly random way
08:51:04 <CosmicRay> ac: don't we already have enough image viewers that use gtk? ;-)
08:51:21 <ac> CosmicRay: name one good one
08:51:26 <hpaste>  vininim pasted "parsec, doing it wrong" at http://hpaste.org/5641
08:51:34 <Stinger> gimv
08:51:44 <matthew_-> tensh: agh, sorry I just read back what I wrote. I meant an extra "not". I'm *not* accusing you of anything like that. I'm really sorry if it came across really harshly.
08:51:59 <ToRA|home> @hoogle (Either a a) -> a
08:51:59 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
08:52:00 <lambdabot> Data.Either.either :: (a -> c) -> (b -> c) -> Either a b -> c
08:52:11 <tensh> matthew_-: I got that you meant to write not :)
08:52:13 <vininim> so, what is the best way for "unfolding" a parser?
08:52:20 <tensh> at least I chose to read it that way
08:52:30 <ac> CosmicRay: I use qiv, but it has the major fault of not being multithreaded, so if you try to view too many large images in too small a time, you just have to sit back and wait
08:52:38 <CosmicRay> ah
08:52:49 <CosmicRay> so you wrote a new one in haskell?
08:53:05 <EvilTerran> vininim, any particular reason you're not using do notation?
08:53:25 <ac> CosmicRay: well, currently it's basically a two liner: a <- getArgs; p <- pixbufNewFromFile $ a !! 0 -- it needs a lot of improvement ;)
08:53:38 <CosmicRay> heh
08:53:55 <vininim> discussed before, making monad flow explicit since I don't grok it completly at the moment
08:54:04 <matthew_-> today has been just brilliant. Lots of code got written, no one was in the office, there were no interruptions and I could listen to music all day.
08:54:09 <vininim> but I can change that =P
08:54:27 <dons> oh matthew_-, people were asking about getting hold of the distract source?
08:54:32 <dons> is it in darcs?
08:54:35 <ac> Stinger: haven't used givm. Can you page through images given as arguments, and does it have any GUI noise?
08:54:49 <matthew_-> dons: yeah, I know about that. Why did that stuff get reddited. It's months old.
08:54:54 <ac> Stinger: and does it have an equivalent of qiv-command?
08:55:08 <dons> matthew_-: someone asked in here if anyone knew of a distributed bug tracker
08:55:12 <matthew_-> and no, it's not in darcs as I don't like darcs. It's in monotone.
08:55:13 <matthew_-> I see
08:55:16 <Stinger> errr I dunno
08:55:29 <dons> oh right.
08:55:33 <dons> but the src is available?
08:55:36 <ac> Stinger: can't find it in the Ubuntu package repository
08:55:39 <dons> and could go up on hackage...
08:55:39 <matthew_-> yes of course
08:55:49 <vininim> also the code is wrong, it should be f 1
08:55:50 <matthew_-> no, I don't think hackage is great for non-libraries
08:56:01 <dons> xmonad seems quite happy there.
08:56:07 <matthew_-> also, hackage is missing some key functionality. Like the ability to delete
08:56:11 <dons> i'd forgotten all about this, simply because its not on hackage :)
08:56:15 <dons> delete?
08:56:19 <Corun> I liked your lecture matthew, btw.
08:56:25 <matthew_-> Corun: ta.
08:56:30 <dons> anyway, you would get more users if it was on hackage -- and we'd not collectively forget about it
08:56:45 <matthew_-> dons: mmm. it needs a total rewrite anyway
08:57:00 <dons> you could just upload the last stable release (or i could, or gwern)
08:57:15 <matthew_-> @seen gwern
08:57:16 <lambdabot> gwern is in #xmonad and #haskell. I don't know when gwern last spoke.
08:57:39 <matthew_-> gwern is now on the distract mailing list and I answered all the questions raised
08:57:44 <dons> great
08:58:13 <matthew_-> adding stuff to hackage just makes the release process longer.
08:58:18 <Stinger> hmmm I'll be buggered if I can find it now
08:58:24 <matthew_-> I wouldn't object if it was just a pointer rather than a value
08:58:28 <dons> likely your .tgz is hackage-ready anyway
08:58:33 <matthew_-> yep
08:58:43 <matthew_-> I also don't like cabal for building executables
08:58:51 <dons> interesting
08:58:54 <matthew_-> as it unnecessarily recompiles loadsa stuff
08:58:59 <dons> cabal-install likes it though.
08:59:07 <dons> cabal install distract :)
08:59:29 <dons> yes, mixed library/apps is a bit annoying.
08:59:31 <matthew_-> like every module that is used by more than one executable gets compiled for each executable
08:59:33 <dons> xmonad has that double recompilatoin issue
08:59:33 <ac> qiv would be perfect if not for the single thread flaw
08:59:38 <dons> right
08:59:46 <matthew_-> when the compliation takes a long time, this gets very annoying
08:59:50 <matthew_-> and I resort to make
08:59:58 <matthew_-> when the make replacement is available I'll be happy ;)
09:00:14 <dons> we don't need a make replacement though, to avoid that problem
09:00:25 <matthew_-> I thought dcoutts and others were working on it
09:00:36 <matthew_-> and the wheel can always be made rounder ;)
09:00:40 <dons> right
09:00:55 <Stinger> ac : it was called gimageview, gimv is just what I type to start it ; dunno about its command line abilities though
09:00:57 <dons> i'll be doing some hackage work over the next months too
09:03:01 <ac> Stinger: gimv FAILS command line usability. I made the mistake of typing "givm *.jpg" and I got 50 windows
09:03:25 <byorgey> ac: ouch!
09:03:30 <Stinger> haha
09:03:32 <glguy> sounds like ac fails commandline use ;)
09:03:34 <dons> its not a command line app :)
09:04:19 <glguy> dons: don't you have to job to go to?
09:04:30 <dons> train leaves in 15 mins.
09:04:35 <glguy> ahh
09:04:41 <psnively> The Haskell Cluetrain? :-)
09:04:45 <pejo> dons, how far off do you live?
09:04:54 <dons> way off
09:04:56 * glguy should head in too
09:05:05 * dons smacks glguy 
09:05:27 <glguy> today is guitar hero wednesday
09:05:34 <glguy> that that into consideration when planning lunch
09:05:40 <dons> ah, right you are.
09:06:00 <matthew_-> lol.
09:06:06 <matthew_-> gh3 ?
09:06:11 <glguy> ach ja
09:06:15 <ToRA|home> matthew_- : we need a wii in the office and should do that too
09:06:17 <matthew_-> how far are you through?
09:06:32 <glguy> need to beat Lou on hard
09:06:35 <matthew_-> I can do about half of the main set on expert now.
09:06:36 <matthew_-> ahh.
09:06:40 <glguy> need to beat Metal - Tenacious D on expert
09:06:53 <psnively> Rotsa Ruck on beating Slash on expert. ;-)
09:06:57 <matthew_-> that's an excellant song. and I can't get anywhere near it on expert
09:07:06 <glguy> I've got gold stars on the first set in medium, and then I stopped playing medium
09:07:17 <glguy> psnively: I did!
09:07:23 <matthew_-> favourite songs? Mine's probably white cliffs of dover on Hard
09:07:26 <psnively> Sweet!
09:07:31 <byorgey> "guitar hero wednesday", eh?  heh. =)
09:07:45 <glguy> psnively: I was stuck on him for many days
09:07:54 <psnively> No shame there.
09:08:02 <matthew_-> have you done Metallica - One on Hard ?
09:08:19 <glguy> yeah, and in co-op mode too
09:08:28 <matthew_-> that just goes nuts at the end - 90% of it is easy. and then it goes mental
09:08:28 <glguy> (we beat co-op hard after work last week)
09:08:36 <tensh> maybe one should invest in GH
09:08:45 <tensh> is there any difference between GH1, 2 and 3?
09:08:56 <glguy> better multiplayer support
09:08:58 <tensh> aside from the songs
09:09:01 <tensh> ok
09:09:09 <matthew_-> guitar is wireless on gh3 only
09:09:11 <EvilTerran> i prefer the GH2 songs to those in GH3, mostly
09:09:15 <glguy> gh1 doesn't let the two players play at different difficultly levels
09:10:25 <glguy> dons: Sam is being really clingy this morning, I think he wants it to be "Take your dog to work Wednesday" instead
09:10:34 <matthew_-> if there are wii gamers here, has anyone got to the final pirate starship in metroid prime corruptions?
09:12:38 <matthew_-> hmmm. I'll ask on -cafe :p
09:12:50 * matthew_- wonders where the last energy cell is
09:21:15 <hrehf> is there a way to syntax highlight haskell code in latex ?
09:22:14 <conal> @go lhs2tex
09:22:15 <lambdabot> http://people.cs.uu.nl/andres/lhs2tex/
09:22:15 <lambdabot> Title: lhs2TeX
09:22:30 <hrehf> hrm
09:22:56 <conal> hrehf: or do you mean colorize?
09:23:10 <hrehf> i have my code in the latex files already, so i just want something that colourises it ;)
09:23:20 <conal> oh.  hm.
09:23:20 <hrehf> exactly
09:23:25 <vininim> uh... any link on let/where syntax in do-notation ?
09:24:14 <pitecus> I can't find a trie implementation on hackage
09:24:23 <pitecus> anyone know of a simple trie package?
09:24:54 <byorgey> hrehf: I think HsColour might have a latex output mode.
09:26:45 <hrehf> yes, it has, cool. So, i'd seperate my haskell code into files, rewrite my make to convert them to colourised latex and then include the file?
09:28:38 <byorgey> hrehf: that sounds like it could work, sure.
09:29:00 <malcolmw> hrehf: you should be able to use the LaTeX files direct (if they are in literate style)
09:29:37 <hrehf> malcolmw can you explain? atm i just have some beamer slides with hs code in verbatims
09:29:44 <malcolmw> (but I'm not sure if \begin{code} \end{code} style is supported by hscolour at the moment
09:30:34 <twanvl> pitecus: a trie is different for each type of key
09:31:02 <pitecus> twanvl, i mostly need a character trie
09:31:03 <malcolmw> "literate style" is either bird tracks (>) down the left hand side of the code, or \begin{code} and \end{code} around the code blocks (or sometimes both!)
09:31:12 <gogonkt> hi,all
09:31:23 <byorgey> hi gogonkt
09:31:29 <pitecus> why would it be different anyway, twanvl?
09:33:06 <ac> so is gtk2hs entirely unsafe with threads?
09:33:59 <Zao> I thought gtk2hs refused to run with the -threaded runtime.
09:34:45 <sjw> dons: around?
09:35:24 <matthew_-> sjw: I think he's on the train going to work
09:35:32 <sizur> evening
09:35:42 <matthew_-> howdy.
09:36:06 <hrehf> malcolmw hmm, sadly it only works with >, not with {code} - and i'd need to get rid of those
09:36:09 <hrehf> *later
09:36:12 <twanvl> pitecus: A trie needs to turn a sum type (data X = A|B|C) into some kind of product type (data XTrie a = XTrie (Maybe a) (Maybe a) (Maybe a))
09:36:16 <gogonkt> help: I used Codec.Text.IConv for convert U8 to GBK,"putStr (convert "UTF-8" "GBK" "")",but not work,is something wrong?
09:36:49 <gogonkt> souce code file in U8
09:37:45 <pitecus> twanvl, i dont follow. by trie I mean a map with [a] as keys and arbitrary types b as values
09:38:10 <gogonkt> and Hackage page for iconv http://hackage.haskell.org/packages/archive/iconv/0.4/doc/html/Codec-Text-IConv.html#t%3AEncodingName
09:38:12 <lambdabot> http://tinyurl.com/246esj
09:38:51 <twanvl> pitecus: In general, it is possible to use things other than lists as keys. Of course lists will be fairly common, and a library could provide a trie type for that.
09:40:36 <pitecus> twanvl, exactly thats my question, is there a package which does that, a simple trie for lists
09:42:40 <twanvl> pitecus: It seems Edison has what you want (Data.Edison.TernaryTrie)
09:44:33 <phobes> twanvl: What does ternary refer to there?
09:44:33 <pitecus> twanvl, aha thanks. i'd prefer a standalone package, but i guess that will have to do.
09:47:27 <ilyak_> Where can I find descent documentation on haskell standard modules?
09:47:41 <ilyak_> Google finds a lot of irrelevant pages
09:48:26 <sjw> ilyak_: the standard library?
09:48:30 <pitecus> ilyak_, you mean standard libraries?
09:48:34 <pitecus> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:49:10 <mrd> haskell.org, one stop shopping
09:49:15 <ilyak_> :)
09:50:27 <mrd> ac: no it's not unsafe with -threaded. you just should never invoke GTK library functions from other than the main thread
09:50:41 <mrd> ac: i wrote a -threaded gtk2hs + gtkglext program just fine
09:52:28 <ilyak_> What should I use if I want to, say, break down string like lines do, but on other character? What function whould that be?
09:52:57 <mrd> there is Text.Regex.splitRegex
09:53:10 <mrd> splits a string based on a regular expr
09:53:17 <mrd> otherwise, write something using span and break
09:53:25 <ilyak_> Isn't that too heavyweight for just one-character split?
09:53:47 <ilyak_> Also, is there a trim function? I can write one myself but it's stupid if there is one already.
09:54:01 <byorgey> depends what you mean by "too heavyweight".  it's sort of subjective =)
09:54:15 <mrd> sumo-weight?
09:54:31 <byorgey> > dropWhile isSpace "   foo"
09:54:35 <lambdabot>  "foo"
09:54:43 <twanvl> ilyak_: see http://article.gmane.org/gmane.comp.lang.haskell.libraries/8298
09:54:44 <lambdabot> Title: Gmane -- Mail To News And Back Again
09:55:06 <byorgey> > let trimr = dropWhile isSpace . reverse in trimr . trimr $ "   foo  "
09:55:15 <lambdabot>  "foo"
09:55:35 <ilyak_> Yes, sure, I can write split myself
09:55:44 <byorgey> mrd: right.  we need to establish some standard weight classes here.
09:55:45 <hrehf> gnarf
09:55:59 <hrehf> pdflatex chokes on the hscolour output :(
09:56:00 <ilyak_> But I wonder whenever there is one already - I guess this function is very useful since you can break any lists with it
09:56:03 <byorgey> I think using splitRegex would technically be "too flyweight"
09:56:17 <byorgey> hrehf: oh, boo =(
09:56:18 <mrd> there's lightweight, middleweight, heavyweight, and then java
09:56:22 <byorgey> hehe
09:56:26 <Corun> And then ruby?
09:56:38 <malcolmw> hrehf: what's the laTeX error?
09:57:48 <hrehf`> malcolmw, just a sec ;)
09:58:18 <ilyak_> twanvl: Still I don't see split in Data.List
09:58:19 <hrehf`> ! Undefined control sequence. \nl.1 \textcolor{blue}{retry}\hsspace\n                                    \textcolor{red}{::}\hsspace {\rm{}STM}\h...
09:58:32 <mrd> ilyak_: there isn't
09:58:37 <mrd> write it with span / break
09:58:48 <mrd> or use splitRegex, it's really not a big deal
09:59:14 <hrehf`> which is basically the start of the .hs.render file (the hscolour output)
09:59:51 <ilyak_> break is fine, btw
09:59:56 <ilyak_> I'll use it
10:00:22 <hrehf`> well, i guess that means no shiny syntax-highlighting in my presentation :(
10:00:33 <bluestorm> hm
10:00:41 <bluestorm> i have a quite nebulous, and not well defined question
10:00:42 <mrd> using package "color" ?
10:00:47 <malcolmw> hrehf`: maybe pdflatex doesn't support \textcolor
10:01:12 <bluestorm> "are Haskell algebraic data types constructors *identified* to functions (in the expression part) ?"
10:01:12 <byorgey> hrehf`: what sort of presentation are you giving?  (just curious)
10:01:13 <malcolmw> hrehf`: or maybe you need \usepackage{something} indeed
10:01:14 <cjb> hm, why doesn't cabal install leksah work?
10:01:34 * hrehf googles for the package thing (latex noob :()
10:01:37 <byorgey> cjb: yeah, I couldn't get it to work either
10:01:39 <mrd> \usepackage{color}
10:01:55 <bluestorm> i come from a language (OCaml) where constructors don't automatically define associated function
10:01:57 <ddarius> bluestorm: They are a special case of functions, yes. (If I understand what you are trying to say.)
10:01:58 <hrehf> byorgey on transactional memory, using hs STM as an example implementation
10:02:02 <ddarius> :t Just
10:02:03 <lambdabot> forall a. a -> Maybe a
10:02:05 <byorgey> hrehf: ah, cool
10:02:12 <bluestorm> ddarius: from my point of view
10:02:23 <bluestorm> there is a constructor, and an automatically-derived function coming from it
10:02:31 <mauke> yes
10:02:36 <bluestorm> but i'm not sure that it's only a point of view
10:02:39 <shepheb> @pl \(a,b) -> (b,a)
10:02:39 <lambdabot> uncurry (flip (,))
10:02:51 <shepheb> is there a handier way of saying that?
10:02:56 <bluestorm> do you know if there is a actual way to see the difference between those two ideas ?
10:02:59 <mrd> hmm, even SML identifies data constructors with functions
10:03:01 <Botje> I believe it's known as mirror
10:03:03 <Botje> :t mirror
10:03:03 <lambdabot> Not in scope: `mirror'
10:03:06 <hrehf> mrd, hmm, still chokes with the same error :(
10:03:07 <Botje> .. or not.
10:03:11 <bluestorm> mrd: caml light does that too
10:03:12 <byorgey> shepheb: not that I know of.
10:03:17 <Botje> doesn't the arrows paper define something like that?
10:03:20 <mauke> @hoogle ><
10:03:21 <lambdabot> Data.Sequence.(><) :: Seq a -> Seq a -> Seq a
10:03:34 <byorgey> Botje: yes, swap, but it's not in any libraries as far as I know
10:03:36 <Botje> @hoogle ^_^
10:03:37 <lambdabot> Hoogle Error: Parse Error: Unexpected character '^_^'
10:03:39 <shepheb> yeah, I tried Hoogling for (a,b)->(b,a), nothing there.
10:04:17 <hrehf> hmmm, i think it's the weird \hsspace command that hscolour generates
10:04:19 <byorgey> :Prelude Control.Category> :t swap
10:04:19 <byorgey> swap :: forall (cat :: * -> * -> *) a b. (CategoryPair cat) => cat (a, b) (b, a)
10:04:30 <byorgey> aha, it's in Control.Category in 6.8 =)
10:04:41 <mrd> :t uncurry (flip (,))
10:04:42 <lambdabot> forall b a. (a, b) -> (b, a)
10:05:26 <mrd> hrehf: hmm, did you read the hscolor docs to make sure it doesn't require any packages?
10:05:36 <MyCatVerbs> @pl let tokenize foo = let (bar,baz) = gettoken foo in bar : fokenize baz in tokenize
10:05:36 <lambdabot> (line 1, column 24):
10:05:37 <lambdabot> unexpected "("
10:05:37 <lambdabot> expecting natural, identifier or "in"
10:05:43 <hrehf> mrd im reading http://www.cs.york.ac.uk/fp/darcs/hscolour/
10:05:44 <lambdabot> Title: hscolour
10:06:17 <pjd> bluestorm: you can view constructors as functions that you happen to be able to "un-apply" with pattern matching
10:07:18 <kib> hrehf : sorry maybe I'm too late, you need syntax highlighting inside a LaTeX paper, that's it ?
10:07:33 <hrehf> kib, yeah, exactly
10:07:38 <kib> I've got nice tools for that.
10:07:56 <hrehf> kib trying seperating out the hs into files and running em through hscolour atm... oooh?
10:08:47 <kib> but it uses reStructuredText...maybe that's not what you wanted. Have you got some maths in your paper ?
10:08:56 <Feuerbach> btw, is there a way to get primitive syntax highliting with lhs2tex? (by primitive I mean bolding and italizing keywords, without colors)
10:09:01 <hrehf> kib, no, just code / verbatims
10:09:01 <shepheb> hmm, unfoldr gives me the list backwards... is there an unfoldl or similar that builds left to right? it's okay if it's strict.
10:09:17 <Corun> (reverse . unfoldr)
10:09:18 <Corun> ;-)
10:09:22 <malcolmw> hrehf: there is quite a large laTeX preface added by the hscolour -latex backend, if it is not used in --partial mode
10:09:40 <shepheb> yes, I had that one worked out on my own. ah well, stream fusion ftw then.
10:09:56 <kib> so, that will be very easy, and it is also possible to have OpenOffice and HTML too with that tool.
10:09:59 <Feuerbach> malcolmw: thanks, I'll take a look
10:10:18 <malcolmw> hrehf: maybe you should cut-n-paste that preface into your document before running hscolour  - it defines \hsspace etc
10:10:32 <hrehf> kib, yeah, but i need to use latex as the base. it's basically finished, jusst want to add highlighting
10:10:47 * hrehf tries malcolmw's suggestion
10:11:53 <kib> Have you got Python installed ?
10:12:26 <hrehf> kib that would be no problem, why?
10:13:00 <kib> to install reStructuredText
10:13:26 <hrehf> kib, i don't want to start writing in another markup language
10:14:11 <kib> as you want, but you'll have LaTeX output with easy syntax highlighting. Do you want a sample ?
10:14:49 <hrehf> kib, yeah, but i need to use latex as the base. slides & paper are basically finished, jusst want to add highlighting
10:16:11 <vininim> @let yes  = repeat
10:16:13 <lambdabot> Defined.
10:21:19 <hrehf> wow, finally - some of the hscolour defs collided with the beamer / my defs
10:21:46 <hrehf> now i need to make the hscolour output use the same font like the normal verbatims :)
10:22:32 <kib> hrehf : http://kib2.alwaysdata.net/temp/test.pdf
10:24:32 <hrehf> kib well, your way is too sophisticated for this job ;)
10:24:34 <kib> and the HTML and OpenOffice ones : http://kib2.alwaysdata.net/temp/
10:24:35 <lambdabot> Title: Index of /temp
10:26:18 <kib> hrehf : I don't think so, you just have to write your paper in a more 'natural' language than LaTeX
10:26:39 <hrehf> that's my point. my paper is already written.
10:26:40 <hrehf> ;)
10:27:03 <hrehf> i need to look at restructured when im in need for misc markup again, though
10:27:19 <hrehf> im using texy for now, which is 90% perfect in the syntax
10:28:44 <kib> do you know Haskell's Pandoc project ? it uses reStructuredText.
10:28:56 <hrehf> kib, nope
10:29:13 <kib> http://johnmacfarlane.net/pandoc/
10:30:13 <kib> the only drawback it has for the moment is syntax highlightning, but the author seems to make progress for this feature.
10:30:43 <hrehf> oh, nice
10:30:49 <hrehf> does it work well?
10:30:59 <dons> sjw: yo?
10:31:19 <kib> Sorry, in fact it has now :) http://groups.google.com/group/pandoc-discuss/browse_thread/thread/b59714fcfc7a7e69
10:31:21 <lambdabot> Title: syntax highlighting support - pandoc-discuss | Google Groups, http://tinyurl.com/3a7zqr
10:31:21 <sjw> hi
10:31:37 <glen_quagmire> i dont' like colored pdf
10:31:48 <glen_quagmire> bolding keywoards shoudl be enough
10:32:12 <vincenz> hrehf: care to detail your workflow? I'd be interested
10:32:13 <lament> haskell doesn't have enough distinct syntactic entities to justify syntax highlighting
10:32:30 <hrehf> vincenz not really finished yet
10:32:34 <glen_quagmire> i document everything using reST
10:32:37 <vincenz> hrehf: ok, well it would be interesting
10:33:05 <hrehf> vincenz atm: seperate hs code into haskell/*.hs, let hscolour compile into *.hs.render, include those from the slides
10:33:06 <glen_quagmire> markdown + pandoc is nice for small homeworks. but markdown lacks cross reference stuff
10:33:17 <vincenz> hrehf: an the beamer stuff?
10:33:28 <vincenz> hrehf: have some template .tex example?
10:33:34 <hrehf> vincenz no, not really
10:33:37 <shepheb> lament: a Haskell editor is much more in need to good Haskell indenting, not colouring.
10:33:39 * vincenz nosd
10:33:44 <hrehf> vincenz but i can post it later today or tomorrow if you want
10:33:48 <vincenz> hrehf: that'd be great
10:34:04 <hrehf> :)
10:34:18 <vincenz> lament: I like having my colored 'where's and 'let's
10:34:30 <lament> vincenz: you mean the word itself?
10:34:46 <lament> or do you have the clause colored?
10:34:50 <vincenz> the word itself
10:34:52 <lament> oh
10:35:03 <lament> yeah, bolding/coloring keywords makes sense
10:35:07 <lament> but other than that, there's not much to do
10:35:10 <lament> which is what glen_quagmire said
10:35:19 * vincenz nods
10:36:05 <glen_quagmire> for html, it can be very fancy. mouse over to library function displays document text ...etc
10:37:17 <kib> maybe Haskell lacks a Pygment [http://pygments.org/] clone ?
10:37:54 <dolio> Bonus points if it does this: http://img507.imageshack.us/my.php?image=snap14xz5.png
10:38:52 <glguy> dons: What's the syntax highlighter you were telling me to use?
10:39:10 <cjb> dolio: lovely, what made that?
10:39:26 <dolio> cjb: Leksah. It's on hackage.
10:39:46 <cjb> neat.  I just installed Leksah but it went crazy and crashed and won't start up again.
10:39:55 <dolio> Heh.
10:40:07 <opqdonut> http://opqdonut.users.paivola.fi/leksah.png <-- leksah screenshot
10:40:18 <opqdonut> note prettyprinting of the operators <3
10:40:58 <lament> cute
10:41:24 <dolio> The only problem is that it can possibly mislead you indentation-wise.
10:41:31 <lament> although for some reason (font?) much less pretty than haskell code in papers
10:41:38 <glen_quagmire> dolio: how so?
10:41:44 <opqdonut> yeah font is awful
10:41:49 <cjb> yeah, I have emacs doing something similar with operators
10:41:55 <opqdonut> esp. for the special symbols
10:41:56 <glen_quagmire> i wont' start a line with >>=
10:42:06 <opqdonut> cjb: is that a separate package?
10:42:12 <dolio> glen_quagmire: For instance, 'alpha' gets turned to look like one character, instead of the 5 it actually takes up.
10:42:25 <opqdonut> glen_quagmire: well, for example ">>= do\n"
10:42:28 <opqdonut> will mess up
10:42:30 <byorgey> yeesh, a variable-width font for an editor!?
10:42:35 <opqdonut> unless the editor accounts for it
10:42:54 <opqdonut> yeh, that's just the default, didn't configure one bit just opened a file up
10:42:55 <dolio> glen_quagmire: So if you have '... alpha ... if ...' then on the next line, you have to make sure you indent an extra 4 spaces on the if.
10:43:30 <glen_quagmire> oh darn embrace ASCII
10:43:36 <cjb> opqdonut: just haskell-mode
10:43:52 <opqdonut> cjb: you see, i've been wanting to do something like that with my math notes
10:43:55 <opqdonut> (that i take in emacs)
10:44:01 <phobes> dolio:  That sounds great :)
10:44:22 <ilyak_> Is there function contains that takes a and [a] and returns Bool?
10:44:30 <dons> glguy: kate-highlighting ? its on hackage
10:44:35 <allbery_m> :t elem
10:44:38 <dolio> phobes: Same problem with using a variable width font in Haskell (if you're into that sort of thing).
10:44:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:44:47 <cjb> opqdonut: http://chris.printf.net/pretty-unicode-haskell.png # all you do is (setq haskell-font-lock-symbols 'unicode)
10:45:22 <dolio> Wow, that's a large font. :)
10:45:33 <opqdonut> cjb: which haskell-mode is this? http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode ?
10:45:33 <lambdabot> Title: Emacs Lisp packages
10:45:58 <ilyak_> thanx
10:47:25 <phobes> byorgey:  I think variable width font + some kind of auto-alignment feature might be nice
10:47:56 <byorgey> phobes: yeah, I guess as long as alignment was done right it could be ok.
10:48:04 <byorgey> but I think proper alignment would be really hard to get right.
10:48:27 <phobes> byorgey:  I think you get the 90% cases and then be done with it
10:48:33 * dolio doesn't really mind monospace fonts.
10:48:45 <byorgey> phobes: but... but I'm a perfectionist!
10:49:01 <cjb> opqdonut: yes
10:49:22 <cjb> dolio: actually, it's taken from a screen with a different dpi
10:49:35 <cjb> dolio: so it doesn't look that large on my 200dpi OLPC screen
10:49:37 <dolio> cjb: Ahh. That must be a nice monitor.
10:49:46 <cjb> heh.
10:49:47 <phobes> byorgey:  Well, then think of how much better everyone elses code would look when formatted to your liking :)
10:50:08 <cjb> I guess the OLPC screen's pretty good, but it's not a nice monitor :)
10:50:21 <glen_quagmire> all source code should be stored in xml. and editors should prettify the code to my liking
10:50:36 <dolio> Yeah. I guess I should have guessed a laptop screen. Those tend to have very nice dpi.
10:50:43 <lament> glen_quagmire: heard of this language... called Lisp?
10:50:55 <dolio> Unlike desktop LCDs which are almost universally stuck at around 100.
10:51:04 <phobes> glen_quagmire:  You had me up until xml
10:51:22 <mauke> lament: the one with the user-definable syntax? that you can't even parse without executing parts of it?
10:52:00 <lament> mauke: point
10:52:17 <glen_quagmire> lisp is very inconsistent with quoting rules
10:52:18 <phobes> mauke:  Doesn't that depend on what you mean by 'parse'?
10:52:43 <mauke> I mean the obvious thing
10:53:06 <phobes> oh, then maybe this is just something I don't know about lisp...
10:54:09 <phobes> Cant you always parse the program as an S-expression with macros yet to be expanded?
10:54:41 <mauke> no: reader macros
10:54:50 <faxathisia> phobes, You can totally change the syntax, like add []'s {}'s even embed HTML in your code..
10:55:10 <faxathisia> you have to have an entire lisp implementation to read a file
10:55:16 <phobes> faxathisia:  Surely we're talking about some lisp variant now, right?  like CL?
10:55:20 <faxathisia> yes
10:56:18 <phobes> ok well, that seems less than ideal :)
10:56:31 <faxathisia> It's sort of useful
10:56:35 <dolio> Any lisp with reader macros?
10:56:35 <mauke> http://mauke.ath.cx/stuff/lisp/implinest.lisp
10:57:01 <faxathisia> eeek
10:57:48 <dolio> Looks like the lisp people write at JavaLobby.
10:58:10 <mauke> this is perfectly fine code
10:58:16 <phobes> faxathisia:  I'm skeptical that there aren't better ways to do that
11:00:52 <phobes> You can't do that stuff in Scheme can you?
11:01:00 <faxathisia> not R5RS
11:01:19 <vincenz> that page won't load
11:01:23 <faxathisia> some implementations allow it
11:02:15 <glen_quagmire> > (x -> x) 1
11:02:15 <lambdabot>  Illegal character ''\187''
11:02:15 <lambdabot>  at "x" (column 3)
11:02:49 <ball> Will Haskell play nicely with external libraries?  Could it be used to write a simple X client?
11:02:57 <cjb> ball: yup.  see xmonad.
11:02:59 <mauke> vincenz: try again
11:03:08 <ball> thanks sjb
11:03:52 <ball> cjb*
11:04:01 <ball> tiny keyboard hates me.
11:05:03 <vincenz> ball: you're biggr than dat
11:05:14 <vincenz> .. that
11:05:18 <vincenz> my keyboard hates me too
11:05:42 <ball> I hear there's a lot of it about.
11:09:19 <vincenz> ball: it's the season
11:12:43 <Stinger> anyone thought about a haskell kde 4 scripting backend? :)
11:16:05 <byorgey> a blog post on the basics of patch theory in the context of collaborative editors, for your enjoyment: http://byorgey.wordpress.com/2008/02/13/patch-theory-part-ii-some-basics/  =)
11:16:06 <lambdabot> Title: Patch theory, part II: some basics  blog :: Brent -> [String], http://tinyurl.com/2zlo9h
11:17:06 <wy> hello
11:17:10 <glen_quagmire> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html   is code in here easy to read for professional haskell programmers?
11:17:11 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2saxu3
11:17:35 <gwern> anyone feel like playing Asteroids?
11:17:40 <gwern> cabal install haskell-in-space
11:17:50 <gwern> or visit http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-in-space-0.1
11:17:51 <lambdabot> http://tinyurl.com/24vl9o
11:18:12 <vincenz> byorgey: that really ties in with splatch
11:18:23 <byorgey> vincenz: yes, it definitely does =)
11:19:24 <vincenz> byorgey: the compliccated ones are region-based
11:19:24 <vincenz> e.g. cutting
11:19:28 <vincenz> and osme guy typing in that region
11:19:36 <vincenz> well those are ok
11:19:39 <vincenz> it's undoing that which is annoying
11:19:49 <vincenz> becacuse positions become conflated
11:20:00 <byorgey> vincenz: I'll get there.  I'm hoping to be able to analyze those sorts of more complex patches in terms of simpler ones.
11:20:14 <vincenz> byorgey: well splatch does elenc the basic ones
11:20:24 <byorgey> vincenz: yes, that is a hard problem.
11:20:34 <vincenz> delete = -, add = +
11:20:51 <vincenz> and then you have cut and past
11:21:00 <vincenz> (copy is just a paste, since the clipboard is not modelled)
11:21:04 <xif> does Haskell have libraries / extensions enhancing it with features similar to those that enable Erlang to scale across multiple machines?
11:21:05 <vincenz> I mean copy is nothing
11:21:42 <vincenz> byorgey: what'd you use for the figures?
11:21:46 <xif> i.e., can Haskell scale across machines in something resembling the way Erlang does that?
11:21:47 <byorgey> vincenz: Inkscape
11:21:51 <gwern> xif: I have heard so
11:22:08 <byorgey> gwern: ok, haskell-in-space installed.  what now? =)
11:22:19 <vincenz> byorgey: lots of effort?
11:22:23 <xif> gwern: I'm asking because I suspect it does; they're very similar languages.
11:22:37 <byorgey> vincenz: for the figures?  nah, not too bad
11:22:37 <xif> I'd just want to know what's the state of those enhancements.
11:22:46 <vincenz> byorgey: not even the annotations?
11:22:51 <gwern> byorgey: well, you run one of the binaries it produces
11:22:58 <gwern> asteroids-*
11:23:02 <byorgey> vincenz: writing that whole post probably took like 3 or 4 hours total
11:23:07 <byorgey> gwern: ok, which one?
11:23:37 <gwern> byorgey: depends on what you like. I would go with the haskelly one first
11:23:51 <gwern> 'There are two demos for moving around (asteroids-space, asteroids-aufgabe); there is a basic Asteroids game (asteroids-basic); and then there is a full elaborate one (asteroids-haskelly). '
11:24:20 <byorgey> smash! ouch!
11:25:35 <gwern> how is performance for you? for me, it's atrocious
11:25:50 <gwern> although it seems somewhat smooth if I hold a key down
11:25:51 <byorgey> gwern: it's great.  but then again I have a pretty sweet laptop
11:26:27 * gwern thought my desktop was pretty sweet too. huh
11:26:42 <vincenz> byorgey: how d you do the inlien formulas
11:26:55 <vincenz> byorgey: and I envy you
11:26:59 <vincenz> your blog looks much cleaner than mine ;|
11:27:26 <byorgey> vincenz: yeah, the inline formulas were basically a hack, hand-positioning text of different sizes =P
11:27:41 <byorgey> vincenz: I think there is a way to embed LaTeX in inkscape documents but I haven't looked into it yet
11:27:46 <vincenz> byorgey: no I mean in the text
11:28:00 <byorgey> vincenz: oh! wordpress has LaTeX support =)
11:28:04 <vincenz> ooh
11:28:25 <byorgey> vincenz: you can just say "and the formula $latex P P^{-1} = \sin(\theta)$ blah blah"
11:28:40 <byorgey> and it automatically runs it through LaTeX and inserts an image
11:29:05 <vincenz> doh
11:29:25 <vincenz> byorgey: anyways, I'm considering switchign now that I see how clean your blog is w.r.t mine
11:29:34 <vincenz> but bleh, then I have to port all blog-entries
11:30:12 <byorgey> vincenz: my only gripe with wordpress is it's hard to get nicely formatter/colorized haskell in posts =(
11:30:37 <byorgey> I'll have to figure out how I'm going to deal with that for my next post...
11:30:39 <vincenz> byorgey: you can't include html?
11:30:57 <byorgey> vincenz: you can include a subset of html, but some tags get stripped
11:31:04 <vincenz> which ones?
11:31:13 <byorgey> I don't know off the top of my head.
11:31:13 <vincenz> hscolour just generates a pre
11:31:21 <vincenz> with colour inside
11:31:40 <faxathisia> glen_quagmire: You should have at least read TAPL I think and having written a checker/inferrer for STLC will make what's going on there a lot clearer
11:31:53 <byorgey> yeah, I think that works.  The other problem, though, is with > and < characters
11:32:39 <phobes> glen_quagmire:  And ATAPL has a bigger section on dependent types
11:33:15 <phobes> glen_quagmire:  The code there was pretty easy to read - I think it's the subject matter that would give difficulty if anything
11:33:43 <glen_quagmire> faxathisia: what is STLC?
11:33:46 <faxathisia> phobes: Do you know if the deptypes code from ATAPL is around anywhere? it's not on the authors site
11:34:02 <glen_quagmire> phobes: ATAPL is the snd book right?
11:34:12 <phobes> faxathisia: No, I don't know.
11:34:20 <phobes> glen_quagmire:  Ya, Advanced TAPL
11:34:32 <opqdonut> oh, there's a follower
11:34:34 <opqdonut> sweet
11:34:51 <phobes> Pierce authored the first and editted the second
11:34:53 <opqdonut> TAPL is a bit of a tedious read to be frank
11:35:03 <hpaste>  ilyak pasted "(no title)" at http://hpaste.org/5642
11:35:26 <ilyak_> Please tell me if there's a much better way to do that
11:35:58 <opqdonut> ilyak_: define helper functions
11:36:02 <ilyak_> I guess I can merge both checks into one place, but that's not the real question
11:36:08 <ilyak_> opqdonut: like?
11:36:18 <opqdonut> fst3 (x,y,z) = x
11:36:20 <opqdonut> and so on
11:36:33 <ilyak_> Oh, I can, but that wouldn't make it shorter by token count
11:36:42 <opqdonut> no, but clearer
11:37:33 <faxathisia> filter a . filter b = filter ("and" a b)
11:37:50 <opqdonut> faxathisia: '"and"'?
11:38:14 <faxathisia> I don't know if there's something that does that in haskell..
11:38:36 <faxathisia> @pl (\x -> a x && b x)
11:38:37 <lambdabot> liftM2 (&&) a b
11:38:41 <opqdonut> :)
11:39:03 <faxathisia> anyway, you can compose the filters if you like
11:39:24 <hpaste>  Saizan annotated "(no title)" with "list comprehension" at http://hpaste.org/5642#a1
11:39:27 <ilyak_> is there something about \(x, y, z) -> x like fst/snd?
11:39:38 <opqdonut> ilyak_: not in the prelude, no
11:39:46 <ilyak_> I can compose filters, but complexity lies inside filter argument functions
11:39:54 <opqdonut> Saizan's version is pretty neat
11:40:02 <faxathisia> frst (e,_,_) = e ; scnd (_,e,_) = e ; thrd (_,_,e) = e
11:41:08 <ilyak_> Wow, really, going to try understanding it
11:41:40 <desegnis> and for 7-tuples, we would habe firsttt, secondd, thirddd, fourthh, fivthhh, sixthhh, seventh?
11:42:03 <faxathisia> desegnis: Exactly!
11:42:05 <opqdonut> of course
11:42:11 <desegnis> yay!
11:42:23 <Saizan> > [ l | (i,l) <- zip [0..] "example", even i]
11:42:27 <lambdabot>  "eape"
11:42:33 <dolio> That wouldn't work out, because you'd have some tuples with names like "first" and "second" which are already the names of functions.
11:42:39 <ilyak_> Saizan: What should I read to understand what's going on in []s in your example?
11:43:50 <ilyak_> any keywords maybe?
11:43:53 <Saizan> ilyak_: http://en.wikibooks.org/wiki/Haskell/More_about_lists#List_comprehensions
11:43:55 <lambdabot> http://tinyurl.com/2srmzq
11:44:16 <desegnis> If a module name could be a number, we would write 7.first, 7.second
11:44:17 <ilyak_> It's hard to google on special characters, I mean :) Thanks.
11:44:34 <desegnis> Just because it's possible
11:44:54 <Saizan> the [ x | ... ] part is called "list comprehension" and it's intended to look similar to math set notation
11:46:14 <ilyak_> I can't say math is my strong side
11:47:14 <dolio> Basically it goes like...
11:47:37 <dolio> '(x,y,z) <- source' pick an element of source and match against (x,y,z)...
11:48:05 <dolio> 's `elem` z' throw away the ones where that expression is false.
11:48:14 <dolio> Same with "criteria y".
11:48:58 <dolio> Then return a list of the 'x's for each piece that hasn't been eliminated.
11:50:51 <dolio> desegnis: You could make a bunch of tuple selector type classes. So 'fst' works on any tuple.
11:51:08 <dolio> And so on.
11:51:30 <Saizan> there's a package like that somewhere
11:51:41 <dolio> And go with all 3-letter functions. Although it gets increasingly hard to name stuff as you go higher.
11:53:00 <ilyak_> dolio: Already got that :)
11:56:00 <desegnis> yeah, I guess fth won't qualify as a descriptive name
11:56:06 <dolio> There used to be fst3, snd3 and thd3 in the standard libraries, too, but they got removed for some reason.
11:56:20 <dolio> Yeah. sth, too.
11:58:00 <dolio> You could work only with nested pairs, too, and then define things like 'cadaddr' if you're into lisp.
11:58:17 <Deewiant> hm, thd3. I always called it trd3
11:58:27 <desegnis> Oh, I hoped to convey in an undertone that numbering fields through won't make for descriptive names anyway
11:58:51 <dolio> I'm not actually sure if it was thd3, but there was something that did that.
11:58:53 <Deewiant> frth4, ffth5, sxth6, snth7, eith8, nnth9, tth10
11:59:40 <Deewiant> the biggest I've needed is ffth5 when I was too lazy to make data types
11:59:47 <osfameron> tuple indexing is horrid
12:00:14 <osfameron> fst and snd are just about acceptable, cos pairs are so common
12:00:15 <dolio> Yeah, I'd probably make a data type before I got up to indexing 5-tuples.
12:00:26 <EvilTerran> i'd think it'd be better to call 'em get1, get2 ... or whatever, rather than keep with the distinctly non-scalable fst,snd... naming pattern
12:00:26 <Deewiant> can't template haskell or something give us the magic to generate up to whatever index we need
12:00:52 <EvilTerran> Deewiant, indeed, you can write $(5 `thOf` 10) or whatever if you want
12:01:28 <Deewiant> and is that tricky to implement
12:01:41 <EvilTerran> not really, no
12:01:44 <dolio> Shouldn't be too hard.
12:02:57 <EvilTerran> thOf n l = lam1E (tupP [if i == n then varP (mkName "a") else wildP | i <- [0..l-1]]) (varE $ mkName "a")
12:03:31 <EvilTerran> unfortunately, you can't work with just [||] and $(), you have to assemble it manually
12:04:35 <dolio> You could probably have TH generate the 'getN' type classes/instances as well, if you wanted to go that route.
12:04:38 <Deewiant> looks interesting. how is that used, I don't speak TH
12:05:01 <EvilTerran> Deewiant, you define that, and then use it in a splice, as in $(5 `thOf` 10)
12:05:28 <EvilTerran> $(...) takes a syntax tree and splices it into the code at that point at compile-time
12:06:48 <EvilTerran> lam1E <pat> <exp> is a lambda expression of one parameter; tupP [<pat>,...] is a tuple pattern, varP <name> is a name pattern, wildP is a _ pattern, varE <name> is a name expression
12:06:51 <Deewiant> muah, nice
12:07:20 <Deewiant> can't be used at top-level? "GHC stage restriction"...
12:07:55 <EvilTerran> you can't use a function in a splice before the module that function's in's been compiled
12:08:08 <EvilTerran> so, for instance, not in the same module it's defined
12:08:12 <Deewiant> so I need to import thOf from its own module, and then it would work
12:08:53 <EvilTerran> say, yes. you can define something with let and then splice it immediately at the ghci prompt, i think, if you just want to experiment
12:09:22 <Deewiant> yeah, that's what I tried first and it does work
12:09:29 <Deewiant> nice, thanks for this primer on TH :-)
12:10:56 <GoClick> Being a non haskell programmer is anything I'd have heard of written in it, or is it more of a problem solving language?
12:11:36 <araujo> GoClick, ?
12:11:44 <lament> ghc^H^H^Hdarcs
12:11:47 <Deewiant> GoClick: http://www.haskell.org/haskellwiki/Applications_and_libraries
12:11:48 <lambdabot> Title: Applications and libraries - HaskellWiki
12:12:18 <Deewiant> in short, I'd say it depends on what you've heard of :-P
12:12:29 <GoClick> hah
12:12:57 <EvilTerran> darcs is the likely one
12:12:59 <dibblego> ?type mapM
12:13:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
12:13:05 <EvilTerran> altho i know a non-haskeller who uses xmonad
12:13:22 <Deewiant> after learning Haskell, I began to see it everywhere
12:13:23 <EvilTerran> (indeed, is picking up a little haskell as he goes along to fiddle with it, i think)
12:13:42 <byorgey> EvilTerran: I know lots, they're in the #xmonad channel all the time. =D
12:13:49 <EvilTerran> Deewiant, I get that, but in weird situations like conversation and walking across town
12:14:03 <Deewiant> EvilTerran: heh
12:14:20 <Deewiant> Pandoc and geordi are two that come to mind
12:14:25 <EvilTerran> my brain starts absent-mindedly fitting whatever i'm doing into the last programming/algebraic thing i was working on
12:14:54 <wy> Any ideas about the paper "states in Haskell"?
12:14:57 <EvilTerran> so, monads, or CSP, or LR parsing...
12:15:42 <wy> I don't know if it's the one I should read currently
12:16:40 * dolio needs to get around to figuring out LR parsing.
12:19:13 <EvilTerran> i plan to implement a shift/reduce parser to aid my understanding in that direction at some point
12:19:28 <dejones> Is the empty set {} the same thing as a grammar G: S --> e, where e is the empty string...?
12:19:42 <dejones> empty set should have zero elements... thus, that grammar seems incorrect to me.
12:19:45 <Saizan> no
12:20:27 <Saizan> L(G) = {e} /= {}
12:20:42 <dejones> yeah
12:20:52 <dejones> just not sure how to write a grammar that produces the empty set.
12:20:52 <dejones> heh
12:21:00 <dejones> don't tell me though
12:21:01 <dejones> :)
12:22:49 <dejones> Hmm, maybe the grammar G for the empty set is a grammar G with zero productions.  :)
12:23:07 <dibblego> > take 5 [False..]
12:23:07 <lambdabot>  Parse error at "False..." (column 9)
12:23:42 <byorgey> dejones: sounds good to me =)
12:23:56 <byorgey> > take 5 [False ..]
12:23:59 <lambdabot>  [False,True]
12:24:02 <dibblego> oh thanks
12:24:11 <dejones> byorgey: hehe, thanks.  :)
12:24:12 <byorgey> syntax corner case... =)
12:24:19 <dolio> [False..] looks like a module qualification.
12:24:34 <dolio> To GHC, that is.
12:24:55 <dolio> > [(False..)]
12:24:55 <lambdabot>   Not in scope: `False..'
12:24:59 <dibblego> > take 5 $ join $ repeat [False, True]
12:25:00 <lambdabot>  [False,True,False,True,False]
12:25:12 <Saizan> dejones: even S -> S
12:25:50 <dolio> Yeah, anything that'd never terminate, no?
12:26:07 <Saizan> yup
12:26:18 <dejones> Hmm, if it never terminates does it produce an empty set?
12:26:21 <dejones> heh.
12:26:52 <non_socialist> when I grab a pacakge from darcs, it does not have typical Setup.hs file, so how do I install it?
12:27:00 <non_socialist> grab using darcs
12:27:02 <dolio> If your strings must be finite. :)
12:27:13 <dejones> Saizan: I wasn't sure about S -> S because I didn't have a way to reason about the non-termination...
12:27:17 <non_socialist> darcs get --partial http://happs.org/repos/HAppS-DNS
12:27:32 <byorgey> just non-termination isn't enough, for example you could have G = {S -> aT, T -> bS}  which doesn't terminate, but L(G) = {abababababab...}
12:28:25 <dejones> byorgey: ahh.. good point.  So, G: S-> S, L(G) = {}
12:28:38 <byorgey> yup
12:28:53 <Saizan> byorgey: uhm, is it standard to allow infinite strings?
12:29:03 <byorgey> I don't know, maybe not.
12:29:39 <byorgey> it's been too long since I took Theory of Computation...
12:29:56 <dolio> I'd probably go with the grammar with no production rules.
12:30:02 <dejones> hehe, yea.. these problems are only graded on completion anyway, so I am probably spending too much time on it. ll
12:30:12 <dejones> * lol
12:30:32 <dejones> but, I do like to reason through them as much as I can.  :)
12:30:55 <EvilTerran> i'm not sure if you can say that G: S -> S has no productions
12:30:58 <byorgey> if you're learning things then it's certainly not wasted time, even if it doesn't matter for the grading
12:31:07 <dejones> byorgey: yep.  :)
12:31:16 <EvilTerran> it might have every production, depending on your grammar semantics
12:31:25 <byorgey> EvilTerran: I don't think anyone said that.
12:31:35 <EvilTerran> er, not productions. words?
12:31:44 <dejones> EvilTerran: I was saying two different grammars that produce the empty set.  1) G is a grammar with zero productions.  2) G: S -> S
12:31:47 <Saizan> dejones: well if you have a formal definition of "language generated by a grammar" in your textbook/notes you could find out :)
12:32:08 <byorgey> EvilTerran: oh, you mean you can't say that the language associated with S -> S is empty?
12:32:31 <EvilTerran> i meant the exact meaning of L(S -> S) might vary depending on how you define these things
12:32:37 <byorgey> yeah, I guess it depends on the formal definition of "language", "grammar" and so on.
12:32:41 <byorgey> true.
12:33:01 <byorgey> maybe it is not even a valid grammar.
12:33:02 <Saizan> it's the difference of taking the least of the greatest fixed point i think
12:33:03 <EvilTerran> you can probably demand least fixed point for recursive productions and get out the empty language
12:33:07 <EvilTerran> heh
12:33:09 <dejones> ha
12:33:18 <Saizan> *or
12:35:04 <dejones> My formal definition of a Context-Free Grammar says it is a 4-tuple, (V, E, R, S) where S e V is the start symbol
12:35:11 <dejones> so I guess a grammar with zero productions is not allowed...
12:35:21 <dejones> E = sigma
12:36:15 <byorgey> dejones: what do V, E, R, and S represent?
12:36:58 <byorgey> I guess V is the set of non-terminals, E the alphabet, R the set of rules?
12:37:07 <byorgey> so why is zero productions not allowed?
12:37:34 <dejones> V is a finite set called the variables; E is a finite set, that is disjoint from V, called the terminals; R is a finite set of rules, with each rule being a variable and a string of variables and terminals; S e V is the start variable.
12:37:39 <QtPlatypus> To my understanding a gramme without productions is just the set of starting symbols.
12:38:30 <Saizan> dejones: nothing forbids R to be empty then, no?
12:38:35 <dolio> Yeah, if R is empty, you can't go anywhere from S, so you're stuck.
12:39:05 <dejones> Saizan: correct.
12:39:26 <dejones> Yah, I just realized that it is easier to define the CFG by the 4-tuple for the empty set
12:39:29 <dejones> then by the list of productions
12:39:33 <dejones> * then = than
12:40:23 <dejones> G = ({S}, E, empty set, S)
12:40:24 <dejones> :)
12:40:27 <dejones> that should do it
12:41:09 <nayru> hmm. i have a list within a list... a = [[1,2],[3,4]] and a similar list called b... i want to multiply them (matrix style).. what is the easiest way to multiply two elements in the lists and store them in a new list? i am doing some matrix multiplication.. i want the easiest way
12:41:59 <dejones> thanks for the discussion everyone.  :
12:42:00 <dejones> :)
12:43:25 <faxathisia> nayru, check it out http://rosettacode.org/wiki/Matrix_Multiplication#Haskell
12:43:26 <lambdabot> Title: Matrix Multiplication - Rosetta Code
12:44:41 <ilyak_> Haskell source code have interesting property of blowing the brain up
12:45:16 <ilyak_> I feel that even when reading programs I wrote
12:45:59 <pjd> @quote brane
12:46:00 <lambdabot> Botje says: Leading experts on haskell recommend at least twenty-four hours between brane asplosions.
12:46:14 <ilyak_> :)))
12:47:51 <gwern> 'brane'?
12:48:31 <pjd> brane, n.: a thing that asplodes
12:48:53 <pheaver> did anyone just see a question from me about cabal?  I think maybe it didn't go through cause I was having connection problems...
12:49:01 <idnar> pjd: haha
12:49:29 <gwern> 'Wed Feb 13 15:11:36 EST 2008  JeanPhilippe.bernardy@gmail.com * fix the space leak: This bugfix has the record for "time spent thinking about the bug to length of fix" ratio.'
12:49:48 <gwern> '-            | AtomicChange Update
12:49:49 <gwern> +            | AtomicChange !Update
12:49:52 <gwern> lol
12:50:09 <gwern> that bug has been a problem for *months*. serious lulz
12:51:13 <nayru> faxathisia: thank you!
12:51:22 <allbery_m> *snerk*
12:52:37 <ilyak_> Also, haskell and other functional languages have the interesting property that my programs, if I can get them to compile, generally work.
12:53:09 <gwern> eh. I've seen plenty of common lisp programs/functions compile but not work
12:53:14 <kmcallister> ilyak_, i find that's more a property of strongly-typed languages than functional ones
12:54:03 <ilyak_> kmcallister: Nope, I guess I have some kind of static typing in my brain:
12:54:22 <ilyak_> I write type-correct programs with both static and dynamic typing
12:54:39 <non_socialist> hm
12:54:51 * dolio has had a program compile but not work lately.
12:55:06 <non_socialist> hey guys when I grab a package with darcs, and it contains no Setup.lh file, how do I compile it?
12:55:09 <stick_figure> Is it possible to create a data type that can be applied like a function or is that totally illegal in the Haskell type system?  I was looking at Arrows to see if that was possible, but I'm thinking the answer is no.
12:55:37 <faxathisia> stick_figure: like this Just $ 5
12:55:46 <kmcallister> stick_figure, the only way to do it is to use a function as your datatype
12:55:48 <gwern> non_socialist: is it even cabalized?
12:56:05 <stick_figure> kmcallister, that's what I figured.
12:56:09 <faxathisia> non_socialist: Does it have a makefile/
12:56:39 <stick_figure> kmcallister, you can't do anything kind of like overloading __call__ or whatever it is in Python.  That's totally fine, though, because I can imagine a way to solve the relevant problem.
12:56:55 <kmcallister> yeah, function application is not overloaded
12:57:38 <non_socialist> i see no cabal and no make sile
12:57:40 <kmcallister> but you can define your own operator and use that
12:57:41 <non_socialist> file
12:57:51 <gwern> non_socialist: so what is it anyway?
12:58:31 <stick_figure> kmcallister, exactly.  I was thinking of making a special list type that is a list of functions and it's application results in a list of the functions applied to the input, but you could model that with an operator instead.
12:58:32 <kmcallister> if you have some type Foo which acts like a function of type a -> b, you can define something of type Foo -> a -> b and prefix your applications with it
12:58:48 <kmcallister> stick_figure, that's sort of what the List monad does
12:59:12 <non_socialist> HAppS-DNS
12:59:36 <dolio> > let fs = [id, (+1), (*5)] in (fs <*> pure 6, sequence fs 6)
12:59:40 <lambdabot>  ([6,7,30],[6,7,30])
12:59:40 <non_socialist> darcs get --partial http://happs.org/repos/HAppS-DNS
12:59:41 <stick_figure> kmcallister, really?  As in [id] >>= 3 will give [3]?
12:59:51 <byorgey> pheaver: nope
13:00:10 <gwern> odd/ I don't remember happs-dns
13:00:16 <kmcallister> no, sorry, misread
13:01:06 <non_socialist> Id be happy to read a haskell tutorial on howto do all this.lol
13:01:20 <non_socialist> but I can't make hide nere hair of haskell wiki
13:01:41 <pheaver> it seems like the only variables I can introduce in a .cabal file are boolean flags.  Is there a way to define, for example, a string variable?
13:01:47 <kmcallister> non_socialist, what about http://haskell.org/tutorial/
13:01:56 <kmcallister> err, nm
13:02:00 <gwern> non_socialist: looks to me like it was just recently split out, so I'm not surprised it's not polished and cabalized
13:02:04 * kmcallister resolves to pay more attention
13:02:10 <byorgey> pheaver: no, there isn't
13:02:14 <pheaver> hmm..
13:02:32 <byorgey> pheaver: what would you do if you could?
13:02:35 <byorgey> pheaver: or maybe a better question is, what are you trying to do?
13:03:09 <pheaver> well, we are generating some Haskell files at compile time based on some user flags to configure (right now it's autoconf's configure)
13:03:28 <stick_figure> kmcallister, I get errors when I do that in ghci.  It says the function arrow is not an instance of Monad, if I read it right.
13:03:52 <nayru> hmm, i made a function that just says <<loop>> when i try to run it? does that mean i have to "take" elements from it to make it run?
13:03:59 <oerjan> stick_figure: import Control.Monad.Instances or .Reader
13:04:10 <stick_figure> oerjan, thanks
13:04:13 <pheaver> the flags to the configure script are things like release, which can be "full", "commercial", or "academic"
13:04:21 <pjd> nayru: looks like you wrote an infinite loop
13:04:39 <pjd> take probably won't help
13:04:44 <pheaver> right now we have autoconf generating the contents of these Haskell files based on the value of 'release', but I'd rather have Cabal do it (actually, I'd rather use Template Haskell, but that's a whole other issue)
13:04:49 <pjd> what's the function?
13:05:25 <nayru> pjd: ah, okay. i'm trying to do some recursion, just experimenting
13:05:55 <pheaver> anyway, that's why I want a string flag... I want to somehow make the 'release' flag available to the Setup.hs file so it can generate these files
13:06:46 <pheaver> my current method is messy: I have autoconf turn Setup.hs.in into Setup.hs by filling in the value of 'release'... but that means you have to call ./configure before doing runhaskell Setup.hs configure, when what we really want is for runhaskell Setup.hs configure to call ./configure.
13:07:19 <pjd> > fix (1:)
13:07:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:07:22 <pjd> > fix (1+)
13:07:23 <lambdabot>  Exception: <<loop>>
13:07:41 <stick_figure> What is <*>?
13:07:48 <oerjan> @src Applicative
13:07:49 <lambdabot> class Functor f => Applicative f where
13:07:49 <lambdabot>     pure  :: a -> f a
13:07:49 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:07:49 <EvilTerran> ?hoogle <*>
13:07:50 <lambdabot> Control.Applicative.(<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:08:12 <stick_figure> thanks
13:11:22 <ilyak_> google search is becoming worse and worse
13:11:25 <ilyak_> For me, anyway
13:13:15 <dolio> What are you searching for?
13:13:45 <ilyak_> I often try to locate a text based on some phrase I remember from it
13:14:15 <ilyak_> And these days, that just don't work - it keeps returning "relevant" results instead of what I really want
13:14:23 <dolio> Heh.
13:14:38 <ilyak_> A few years ago it did work
13:17:04 <oerjan> ilyak_: do you put the text in quotes?
13:17:25 <ilyak_> oerjan: I can't when I don't remember phrase exactly
13:17:30 <hrehf> hm, noob q:
13:17:34 <oerjan> hm
13:17:42 <ilyak_> And google have no setting "I want these words to be near"
13:17:45 <hrehf> doesn't "\n" add a linebreak in ghci?
13:17:52 <ilyak_> "And alsop I want synonyms to be included"
13:17:58 <hrehf> (sry accidently hit space)
13:18:00 <non_socialist> no joke
13:18:06 <non_socialist> google is getting messy
13:18:30 <EvilTerran> hrehf, in what context?
13:19:23 <hrehf> EvilTerran i have something like foo = operation to create "foo\nbar\n"
13:20:21 <EvilTerran> and what's happening?
13:20:29 <mightybyte> @hoogle Default
13:20:30 <hrehf> it outputs it on one line
13:20:30 <lambdabot> GHC.ConsoleHandler.Default :: Handler
13:20:30 <lambdabot> Distribution.Compiler.defaultCompilerFlavor :: Maybe CompilerFlavor
13:20:30 <lambdabot> Distribution.Make.defaultMain :: IO ()
13:21:09 <EvilTerran> hrehf, try passing your expression to putStrLn
13:21:35 <hrehf> so, ghci doesn't show the breaks?
13:21:41 <hrehf> /interpret
13:22:04 <EvilTerran> when ghci evalutes an expression at the prompt, it uses "print" to display it
13:22:11 <EvilTerran> which is putStrLn.show
13:22:28 <EvilTerran> the one special case is if the expression is an IO action, in which case it just runs it
13:22:52 <nayru> hmm. i wrote a recursive function like this: f n = f (n + 1) ... and i run with: f 5 ... and it runs forever. i thought this lazy evalution thing would make it run only if i used "take " or something
13:23:01 <vininim> mmm anyone using emacs with mmm? when I activate mmm-ify-by-class I lose syntax highlighting of both(actually current) mode
13:23:16 <Botje> nayru: don't you mean f (n - 1) ?
13:23:33 <Botje> nayru: and you're asking it to evaluate f 5, so it _WILL_ be strict and evaluate everything.
13:23:43 <nayru> oh, okay
13:24:10 <byorgey> nayru: if you type 'let x = f 5' at the prompt then nothing will happen.
13:24:18 <Botje> laziness is best shown in "let f = 1/0 in 42"
13:24:26 <byorgey> but then as soon as you type 'x' it needs to evaluate it, so it will go into an infinite loop.
13:24:26 <Botje> it won't evaluate the f if you don't use it in the body :)
13:24:38 <nayru> Botje: oh, okay
13:24:40 <EvilTerran> hrehf, so if you want to display a string directly instead of in its (show)ed form, you need to pass it to putStr or putStrLn
13:24:46 <EvilTerran> (or do something equivalent)
13:24:56 <byorgey> > let f n = f (n + 1) in if False then 5 else f 5
13:25:00 <hrehf> EvilTerran yeah, ko, thanks for the info
13:25:01 <nayru> Botje: i am trying to understand how recursion works in haskell. how should i run a function like mine?
13:25:02 <oerjan> > let f = 1/0 in 42+1/f
13:25:02 <lambdabot> Terminated
13:25:04 <lambdabot>  42.0
13:25:10 <byorgey> > let f n = f (n + 1) in if True then 5 else f 5
13:25:11 <lambdabot>  5
13:25:14 <EvilTerran> nayru, what's your function supposed to do?
13:25:18 <Botje> nayru: uh, like you're running it. but you should provide a base case so your function terminates :)
13:25:40 <byorgey> maybe nayru is just playing around with lazy evaluation?
13:25:49 <nayru> EvilTerran: now it's supposed to decrement whatever number down to 0 and stop
13:26:08 <swiert> byorgey: nice blog post btw!
13:26:15 <EvilTerran> so what should the value of (f 5), say, be?
13:26:16 <byorgey> swiert: thanks! =)
13:26:35 <nayru> EvilTerran: 0 would be nice
13:26:52 <EvilTerran> f x = 0 -- ? ;)
13:27:16 <nayru> EvilTerran: heheh, okay. i am just experimenting with recursion
13:27:18 <oerjan> > let f 0 = "got down"; f 10 = "got up"; f n = f (n+1) in f 5
13:27:23 <lambdabot>  "got up"
13:27:27 <EvilTerran> f x = if x > 0 then f (x-1) else 0 -- might be what you want
13:27:43 <swiert> byorgey: found a graduate school yet?
13:27:46 <EvilTerran> f 0 = 0; f (n+1) = f n -- a contraversial variant
13:27:51 <ilyak_> Much to the surprise of the builders of the first digital computers, programs written for them usually did not work. (c)
13:28:04 <nayru> EvilTerran: thank you
13:28:08 <EvilTerran> f n | (n == 0) = 0 | otherwise = f (n-1) -- also works
13:28:20 <ilyak_> That's what I've searched for :)
13:28:46 <oerjan> ilyak_: found it yet?
13:28:55 <ilyak_> Looks like google gets messy when there are a lot of words searched for.
13:29:16 <ilyak_> Too busy doing conjunctions to actually refine search :)
13:29:31 <oerjan> ilyak_: i sometimes use a hyphen to combine only words i'm pretty sure are adjacent
13:29:51 <ilyak_> :)
13:30:00 <byorgey> swiert: well, I've been accepted to three so far! =D
13:30:14 <swiert> byorgey: and made up your mind?
13:30:56 <byorgey> swiert: not yet, I've got a few visits planned (including going to PSU tomorrow) and I'll probably wait to hear back from everywhere else before I decide
13:31:14 <swiert> PSU sounds cool.
13:31:20 <byorgey> indeed, it does
13:31:33 <swiert> Quite a lot of functional programmers there, and the Pacific Northwest is pretty amazing.
13:31:53 <byorgey> yeah, I'm looking forward to visiting
13:32:24 <olsner> byorgey: I see you have blogged ;-)
13:33:10 <byorgey> olsner: indeed, I have!
13:36:06 <bringert> byorgey: have you applied to Chalmers?
13:36:19 <bringert> byorgey: http://www.cs.chalmers.se/~koen/phdad.html
13:36:20 <lambdabot> Title: PhD Positions in Functional Programming at Chalmers
13:36:46 <byorgey> bringert: no, sadly
13:36:59 <bringert> byorgey: it's not too late
13:37:59 <byorgey> bringert: sadly, meaning, I would have liked to apply to places in Europe and the UK, but after thinking about it and talking with my wife I decided not to.
13:38:13 <bringert> byorgey: ah, ok
13:38:23 <bringert> byorgey: europe is nice
13:39:41 <byorgey> bringert: indeed!
13:39:59 <byorgey> bringert: I certainly do hope to be able to visit for conferences and so on.
13:45:56 <pi3> Wow this community has grown a lot, this is the first time I connect in a couple of months and I don't remember seeing so many people
13:46:06 <byorgey> @users
13:46:07 <lambdabot> Maximum users seen in #haskell: 463, currently: 445 (96.1%), active: 21 (4.7%)
13:46:21 <byorgey> heh, welcome back pi3
13:46:32 <pi3> thanks :)
13:46:49 <mrd> seems we busted way past the 400 mark
13:47:23 <dons> average is around 420 now
13:47:53 <byorgey> hmm, my blog is being very slow.... did someone happen to link it from reddit??
13:48:36 <byorgey> ah, indeed
13:50:45 <vininim> uh... what does the author of banana, lens and barbed wire uses for typesetting those symbols?
13:51:18 <byorgey> vininim: LaTeX ?  or do you mean which particular LaTeX symbols?
13:51:23 <vininim> the symbols
13:51:58 <resiak> mauke: your comment about alignment on magnus therning's post about Storable (http://linkpot.net/preening/) is very handy!  Is it mentioned anywhere more prominent than a comment on a blog?  :-)
13:55:37 <mrd> vininim: maybe stmaryrd package
13:56:18 * byorgey 's blog staggers under the proggit traffic =P
13:56:19 <gabor> dons: http://www.cse.unsw.edu.au/~dons/ is down ?
13:57:15 <dons> looks like www.cse.unsw.edu.au is down
13:57:33 <dons> resiak: its in the FFI section of blogs on haskell.org
13:57:53 <dons> http://haskell.org/haskellwiki/Blog_articles
13:58:28 <resiak> ah, okay
13:58:46 <resiak> It'd be hyper cool if alignment were explained in the Storable docs, but hey.  :-)
13:59:07 <dons> i'll happily push a patch, if you write one
13:59:28 <resiak> okay!  *adds to TODO*
14:02:15 <oerjan> byorgey: well it has dropped off the first page now
14:02:51 <vincenz> byorgey: there go your 15ms of fame
14:03:28 <nominolo> byorgey: is famous?
14:03:42 <kib> Is there an easy way to append something to a list without the need to reverse it, use a cons, then reverse all ?
14:03:58 <oerjan> kib: ++
14:04:09 <nominolo> kib: Data.Seq.Seq
14:04:18 <oerjan> however, you usually want to avoid appending short things to the end
14:04:36 <oerjan> (too much)
14:04:52 <kib> oerjan : that's what I'm doing, but I'm building a file so there's a lot of lines.
14:05:54 <oerjan> kib: if you can use lazy evaluation you might be able to build it from the front anyway
14:06:29 <kib> ok, here's my little code : http://hpaste.org/5646 (don't blame me !)
14:07:39 <oerjan> kib: your writePoint is equivalent to show for tuples
14:08:06 <EvilTerran> > intersperse "--" . map show $ [1,2,3,4]
14:08:09 <lambdabot>  ["1","--","2","--","3","--","4"]
14:08:13 <EvilTerran> > concat . intersperse "--" . map show $ [1,2,3,4]
14:08:14 <lambdabot>  "1--2--3--4"
14:08:19 <oerjan> @version
14:08:20 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
14:08:20 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:08:26 <EvilTerran> ?type intercalate
14:08:27 <lambdabot> forall a. [a] -> [[a]] -> [a]
14:08:27 <kib> oerjan : good news, that's a good refactoring :)
14:08:30 <wy> Just got The Reasoned Schemer. No idea how to start and bumped into (run* ...)
14:08:31 <oerjan> > intercalate "--" . map show $ [1,2,3,4]
14:08:32 <lambdabot>  "1--2--3--4"
14:09:11 <oerjan> kib: also, this brings up the Show class's method of using String -> String functions for efficiency
14:09:20 <kib> EvilTerrain : very nice !
14:09:31 <nominolo> byorgey: that's because the immages seem to be generated on demand or sth
14:09:32 <EvilTerran> hehe, evil terrain
14:09:47 <nominolo> *images
14:10:07 <kib> ooops, sorry. What's intersperse exactly ?
14:10:15 <EvilTerran> ?src intersperse
14:10:15 <lambdabot> intersperse _   []     = []
14:10:15 <lambdabot> intersperse _   [x]    = [x]
14:10:15 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
14:11:18 <oerjan> @src intercalate
14:11:18 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
14:13:00 <BMeph> > intersperse ',' "abcdefg"
14:13:01 <lambdabot>  "a,b,c,d,e,f,g"
14:13:16 <BMeph> kib: THAT is intersperse. ;)
14:13:39 <kib> each time I came here I discover a lot of functions I never saw in books.
14:14:18 <oerjan> @docs Data.List
14:14:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-List.html
14:14:42 <oerjan> what the?
14:14:46 <BMeph> kib: Yes, we're all waiting with baited breath for EvilTerran's and oerjan's biographies... ;)
14:15:00 <EvilTerran> whaaa?
14:15:22 <oerjan> even that link is broken, @docs needs some serious updating
14:15:33 <oerjan> @docs
14:15:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:16:16 <kib> Lists are here : http://haskell.org/ghc/docs/latest/html/libraries/haskell98/List.html
14:16:16 <lambdabot> http://tinyurl.com/2h7wna
14:16:17 <oerjan> kib: anyway go to that link and browse to your hearts delight.  especially Data.List for starters.
14:16:25 <BMeph> EvilTerran: Every time you or oerjan is on, I learn something new, so I figure either one of your's biographies will be chock-full of enlightenment.
14:16:38 <oerjan> kib: Data.List has some additions to the original List, such as intercalate
14:17:15 <oerjan> (just added in ghc 6.8)
14:17:30 <EvilTerran> i see
14:17:44 <kib> yes, but there are so much functions...difficult to browse when you don't know its name in advance but just the expected result
14:18:03 <EvilTerran> hoogle helps
14:18:06 <EvilTerran> ?hoogle [[a]] -> [a]
14:18:07 <lambdabot> Prelude.concat :: [[a]] -> [a]
14:18:07 <lambdabot> Data.List.concat :: [[a]] -> [a]
14:18:07 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
14:19:11 <kib> I just discoved hoogle : nice toy to play with
14:19:22 <oerjan> kib: i didn't mean so much for looking up as for getting a bit familiar with what is there
14:19:50 <oerjan> so i guess i meant "read" not "browse"
14:20:54 <kib> Now I need other things than Points inside my Path type, like a Deco type. How can I declare this ?
14:21:11 <oerjan> Data.List is particularly important because in haskell lists == loops, almost, so those are your pure control structures.
14:21:51 <kib> oerjan : yes, that's the basis of all functionnal langages I suppose
14:23:04 <oerjan> hm you may wish to declare a type for the things that can be in the Path list
14:23:46 <oerjan> data PathElem = PointElem Point | DecoElem Deco or similar
14:24:18 <dolio> They're probably more important in Haskell, as using them in lieu of loops and such doesn't eat up memory.
14:24:40 <dolio> Unless ML and lisps and such do a really good job on deforestation.
14:25:31 <kib> Thanks, that helps. I've tried this "type Path   = [Point|Deco]" but that does not seems to work fine.
14:26:00 <kib> dolio : is working with lists rather quick ?
14:26:04 <oerjan> kib: you _could_ use [Either Point Deco] but usually it is best to declare your own data type for such things
14:26:24 <non_socialist> whats hoogle?
14:26:32 <oerjan> kib: ghc works hard at optimizing them away
14:26:36 <oerjan> @where hoogle
14:26:36 <lambdabot> http://haskell.org/hoogle
14:26:37 <gwern> this bites. so Oleg's sent me instructions on how to update his ZFS to use CC-delcont, and it works on his 6.6, but not on my 6.8.2 :(
14:26:41 <ddarius> @help hoogle
14:26:41 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
14:26:42 <cjb> non_socialist: hoogle :: type signature -> function
14:27:01 <kib> ooerjan : ok, I thought the '|' was good inside the declaration.
14:27:02 <non_socialist> hm
14:27:08 <non_socialist> useful tool eh
14:27:30 <kowey> cabal people: I'm trying to update a postInst  hook from the version that was distributed with ghc 6.6 (now to ghc 6.8.2)
14:27:39 <dolio> kib: GHC does try to optimize them away. But, even if it didn't, in a lazy language, if you take enough care, you can operate over lists in O(1) space, because it can delay construting parts of the list until you need them, and immediately throw away the parts you've used.
14:27:41 <dcoutts_> kowey: ok
14:27:47 <kowey> but the interface has changed, and I don't know how to retrieve the install directory... help?
14:28:04 <gwern> kowey: oh. I disabled geni's setup hook, did that make it into my patch? I thought I had reverted it tho
14:28:14 <kowey> I used to have something like this: postInst :: (Args -> InstallFlags -> PackageDescription -> LocalBuildInfo -> IO ())
14:28:18 <dolio> kib: Whereas if you don't deforest in a strict language, you build a whole list before doing anything with it (barring some lazy list library or something).
14:28:32 <kowey> gwern: disabled? hmm... I don't think so, but macosx really does need it
14:28:35 <dcoutts_> kowey: see the Distribution.Simple.InstallDirs, it has a function to get the absolute install dirs
14:28:35 <kowey> unless something has changed
14:28:58 <dcoutts_> kowey: btw, what package is it, and what do you need to get the install dirs for?
14:29:26 <kowey> dcoutts_: thanks! but I couldn't figure out how to get the InstallDirs from the LocalBuildInfo
14:29:37 <kib> dolio : not for all langages, Ruby and Python have lazy evaluation too.
14:29:46 <kowey> it's for GenI and the reason is that wxhaskell on MacOS X
14:30:02 <kowey> requires you to run some weird script on the binary, or else the widgets just sit there looking pretty without reacting to user input
14:30:24 <kowey> so I had my Setup.lhs run the script on the installed executable
14:30:39 <dcoutts_> koeien: it's the installDirTemplates field of the LocalBuildInfo
14:31:02 <dcoutts_> oops kowey not koeien ^^
14:31:05 <dolio> kib: Well, OCaml has a lazy stream datatype, but it's not the default list that's used everywhere (to my knowledge).
14:31:20 <pjd> kib: not lazy in the evaluation-sharing sense, though
14:31:29 <dcoutts_> kowey: can you not run it on the binary after it is built rather than when it is installed?
14:31:42 <kowey> I was considering that, actually
14:31:49 <kib> pjd : what do you mean by that exactly ?
14:31:54 <kowey> I don't know if it works (superstition)
14:32:01 <kowey> is it easier?
14:32:37 <dcoutts_> kowey: make sure you pass the right CopyDest to absoluteInstallDirs so that it'll work for distros that use ./setup copy --destdir=temp-image-dir
14:33:15 <kowey> dcoutts_:  actually, that was my next question! where do I retrieve the CopyDest from?
14:33:35 <dcoutts_> kowey: it would be preferable to modify the binary before copying rather than after, we may well start checking hashes of file contents
14:33:54 <gwern> dcoutts_: I've been wondering, what backups are there for Hackage?
14:34:25 <dcoutts_> kowey: the copyHook takes it as a param
14:34:39 <kowey> gwern: by the way, could we change Natural-language Processing to Natural Language Processing? (the latter is probably better known)
14:34:51 <dcoutts_> gwern: well darcs.haskell.org is hosted by galois and I'm pretty sure they manage backups properly
14:35:22 <gwern> kowey: go ahead. I was following WordNet's lead. just remember to refresh the hackage package
14:35:29 <dcoutts_> kowey: btw, what kind of weirdness does wx require on osx exactly?
14:36:00 <gwern> dcoutts_: oh. hm. Yeah, I guess they can be trusted to keep backups. at leaast it's not worth bothering about right now
14:36:23 <kowey> dcoutts_: would it be helpful if I showed you the script? http://darcs.haskell.org/wxhaskell/bin/macosx-app-template
14:36:24 <dcoutts_> gwern: we should probably make the complete hackage archive available via rsync or something so people can analyse the whole thing and keep distributed backups and mirrors
14:36:25 <oerjan> "advanced programming language wiped out - no one remembered to take backups"
14:36:47 * gwern winces. what a terrible headline that'd be
14:37:06 <kowey> here's an instantiated version: http://trac.loria.fr/darcs/geni/GenI/etc/macstuff/macosx-app
14:37:06 <gwern> (there's a fair bit of stuff which seems to exist only on the author's hard drives and hackage)
14:38:01 <kowey> dcoutts_: I don't think you actually need to create the .app bundle, but there's some mysterious magic that you do to the binary itself
14:38:51 <kowey> particularly, running Rez on it
14:39:05 <gwern> isn't Rez a game?
14:39:46 <dcoutts_> kowey: where does $rezfile come from?
14:41:10 <kowey> dcoutts_: that is... a good question
14:41:24 <kowey> from the looks of it, it's not wholly neccessary
14:42:02 <kowey> the Rez man page says it's optional... I think a rez file is just optional metadata
14:42:51 <kowey> uhh... then again, 'Specifies one or more resource description files that contain
14:42:51 <kowey>               type declarations and resource definitions.'
14:44:09 <dcoutts_> kowey: is this something that lots of progs will want on osx, perhaps cabal should support compiling resource files into progs, similar to manifests and resources files in windows exe and dlls.
14:45:22 <kowey> dcoutts_: ooh! well, I suspect that wxhaskell programs on MacOS X will want them in the general case
14:45:22 <kowey> although nobody else seemed to mention this, and nobody reacted when I posted my Setup script to the wxhaskell-users mailing list
14:46:59 <dcoutts_> kowey: in the short term you'll have to go with what you've got, though as I say it's probably best to modify the binary before copying if possible and whatever you do, do make sure it works when you use copy --destdir=blah because that's what distro packages do.
14:52:41 <jatqceer> what is the best way to make a hashtable or association list with floating numbers as keys?  I'd like a mutable and fast implementation that works with about a few hundreds keys
14:53:33 <jatqceer> I'm not sure what to use as the hash function for Data.Hashtable
14:54:10 <Lemmih> jatqceer: Data.Map + IORef or MVar.
14:54:26 <Lemmih> jatqceer: Are you sure you want to mutate it?
14:55:04 <dolio> @botsnack
14:55:04 <lambdabot> :)
14:56:51 <kowey> dcoutts_: thanks for the help! (btw, I guess what would be nice is if cabal could help us build .app bundles)
14:57:07 <kowey> i don't actually know if it does what I want yet, but it's bedtime... night!
14:57:40 <dcoutts_> kowey: file a cabal feature request with the details of what they are, why they're needed and how to generate them. Remember most cabal hackers are not OSX experts.
14:58:43 <jatqceer> Lemmih: yes, i'd like to update it frequently without too much trouble
14:59:08 <Lemmih> jatqceer: You don't need mutability for that.
15:01:46 <dcoutts_> @tell kowey file a cabal feature request with the details of what they are, why they're needed and how to generate them. Remember most cabal hackers are not OSX experts.
15:01:46 <lambdabot> Consider it noted.
15:02:09 <jatqceer> Lemmih: so what do you suggest?
15:03:13 <Lemmih> jatqceer: I don't have enough context to go on. However, Data.Map + pure code is always pretty.
15:04:49 <non_socialist> hey guys who here uses programs they themselves wrote each day?
15:05:41 <kig> o/
15:06:29 <dcoutts_> non_socialist: I do :-)
15:06:38 <Lemmih> I kinda do.
15:06:48 <dcoutts_> well if you count progs that I wrote much of, if not all
15:07:38 <resiak> hrm, 'withForeignPtr thing $ \thingPtr ->' appears to be proliferating.  i feel like this should be avoidable
15:08:22 <jatqceer> Lemmih: basically the program receives a list of (k,v) :: (Double, [Double]) and do some calculation using v associated to the same k
15:09:32 <jatqceer> non_socialist: I do.  No other choices.
15:09:58 <Lemmih> jatqceer: Sounds like Data.Map would be perfect.
15:10:04 <Eiler> is there any tutorial on how to write a math parser?
15:10:33 <faxathisia> Eiler, Yeah this one is good, http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
15:10:34 <QtPlatypus> Eiler: Arithmatic or symbolic?
15:10:55 <Eiler> whats the difference?
15:10:57 <allbery_m> non_socialist: lots
15:11:17 <oerjan> QtPlatypus: if you make a difference you have not factored out the parsing part properly ;)
15:11:20 <allbery_m> not sure you want to count admin tools though
15:11:22 <Eiler> arithmetic i suppose
15:11:29 * EvilTerran has a few scripts he uses now-and-then
15:11:37 <jatqceer> Lemmih: I'll use Data.Map.  Thanks
15:13:47 <pgavin> @check (\n -> n <= 0 || ((4^n - 1) `mod` 3 == 0)) :: (Int -> Bool)
15:13:50 <lambdabot>  OK, passed 500 tests.
15:14:29 <dcoutts_> yo SyntaxNinja
15:14:52 <oerjan> pgavin: 4 `mod` 3 == 1, the rest follows by modular arithmetic
15:15:12 <pgavin> oerjan: that's right, since 3 is prime
15:15:22 <oerjan> pgavin: even if it weren't
15:15:36 <pgavin> hmm, are you sure?
15:15:44 <SyntaxNinja> hi dcoutts
15:15:52 <oerjan> @check (\n -> n <= 0 || ((7^n - 1) `mod` 6 == 0)) :: (Int -> Bool)
15:15:53 <lambdabot>  OK, passed 500 tests.
15:16:05 <pgavin> oerjan: ok, I'm convinced :)
15:16:12 * oerjan was a little worried about Int overflow there
15:16:22 <dolio> > 7^(-5)
15:16:24 <lambdabot>  Exception: Prelude.^: negative exponent
15:17:32 <oerjan> hm that actually should be an issue
15:17:47 <oerjan> > (4^32 `mod` 3) :: Int
15:17:49 <lambdabot>  0
15:17:54 <pgavin> lol
15:18:14 <pgavin> > (4^32 `mod` 3) :: Integer
15:18:15 <lambdabot>  1
15:18:16 <oerjan> check may not generate that large Ints though
15:18:35 <pgavin> we can find out
15:18:50 <pgavin> @check (\n -> n > 1000) :: (Int -> Bool)
15:18:51 <lambdabot>  Falsifiable, after 0 tests: 0
15:18:53 <jatqceer> > 4^32 :: Int
15:18:54 <lambdabot>  0
15:18:59 <pgavin> ahem
15:19:13 <pgavin> @check (\n -> n < 1000) :: (Int -> Bool)
15:19:13 <lambdabot>  OK, passed 500 tests.
15:19:24 <pgavin> @check (\n -> n < 500) :: (Int -> Bool)
15:19:25 <lambdabot>  OK, passed 500 tests.
15:19:29 <pgavin> @check (\n -> n > 100) :: (Int -> Bool)
15:19:30 <lambdabot>  Falsifiable, after 0 tests: 0
15:19:34 <pgavin> bah
15:19:40 <pgavin> @check (\n -> n < 100) :: (Int -> Bool)
15:19:41 <lambdabot>  Falsifiable, after 317 tests: 109
15:19:56 <oerjan> huh
15:19:56 <pgavin> @check (\n -> n < 256) :: (Int -> Bool)
15:19:57 <lambdabot>  OK, passed 500 tests.
15:20:01 <dolio> @scheck \n -> (n :: Int) > 0 ==> (4^n-1) `mod` 3 == 0
15:20:02 <lambdabot>   Completed 13 test(s) without failure.  But 7 did not meet ==> condition.
15:20:04 <ddarius> @scheck (\n -> n < 100) :: Int -> Bool
15:20:05 <lambdabot>   Completed 13 test(s) without failure.
15:20:19 <dolio> 13, eh?
15:20:26 <oerjan> scheck only goes up to 7 i think
15:21:00 <dolio> @check \n -> (n :: Int) > 0 ==> (4^n-1) `mod` 3 == 0
15:21:01 <lambdabot>  OK, passed 500 tests.
15:21:23 <oerjan> that's weird
15:21:37 <oerjan> it should fail long before n==100
15:22:03 <oerjan> @check (\n -> n < 100) :: (Int -> Bool)
15:22:04 <lambdabot>  Falsifiable, after 315 tests: 130
15:22:27 <dolio> > 4^33 `mod` 3 :: Int
15:22:28 <lambdabot>  0
15:23:05 <oerjan> oh wait!
15:23:17 <oerjan> only n is Int, not the resulting power :D
15:23:55 <dolio> @check False ==> True
15:23:59 <lambdabot>  Arguments exhausted after 0 tests.
15:24:18 <oerjan> @check \n -> (n :: Int) > 0 ==> (4^n-1 :: Int) `mod` 3 == 0
15:24:19 <lambdabot>  Falsifiable, after 28 tests: 16
15:24:56 <dolio> @check \n -> False ==> (n :: Int) == 0
15:24:57 <lambdabot>  Arguments exhausted after 0 tests.
15:25:34 <FunctorSalad> @type \n -> 4^(n::Int)
15:25:35 <lambdabot> forall t. (Num t) => Int -> t
15:25:48 <dolio> I guess @check doesn't tell you how many tests failed to run?
15:25:52 <FunctorSalad> @type \n -> 4^(n::Int) `mod` 3
15:25:53 <lambdabot> forall t. (Integral t) => Int -> t
15:26:22 <dolio> Or, how many failed to satisfy the precondition, that is.
15:26:46 <oerjan> dolio: only if it goes over a threshold without generating enough i think
15:27:07 <dolio> Ah.
15:27:38 <oerjan> @check \n -> n > 100 ==> n < 200
15:27:39 <lambdabot>  Add a type signature
15:27:44 <dolio> @check \n -> (n :: Int) > 1000 ==> n > 500
15:27:44 <lambdabot>  Arguments exhausted after 0 tests.
15:27:47 <oerjan> @check \n -> n > 100 ==> (n::Int) < 200
15:27:48 <lambdabot>  Arguments exhausted after 0 tests.
15:28:07 <oerjan> @check \n -> n > 100 ==> (n::Int) < 200
15:28:08 <lambdabot>  Arguments exhausted after 0 tests.
15:28:11 <dolio> @check \n -> (n :: Int) > 40 ==> n > 30
15:28:12 <lambdabot>  Arguments exhausted after 0 tests.
15:28:17 <dolio> @check \n -> (n :: Int) > 20 ==> n > 0
15:28:18 <lambdabot>  Arguments exhausted after 0 tests.
15:28:23 <dolio> Hmm...
15:28:47 <oerjan> @check \n -> n > 100 ==> False
15:28:48 <lambdabot>  Add a type signature
15:28:54 <oerjan> @check \n -> (n::Int) > 100 ==> False
15:28:56 <lambdabot>  Arguments exhausted after 0 tests.
15:29:16 <oerjan> @check \n -> (n::Int) > 10 ==> False
15:29:18 <lambdabot>  Arguments exhausted after 0 tests.
15:29:32 <oerjan> @check \n -> (n::Int) > 0 ==> False
15:29:33 <lambdabot>  Falsifiable, after 0 tests: 1
15:29:44 <dolio> Something weird going on.
15:29:45 * oerjan scratches head
15:29:55 <oerjan> @check \n -> (n::Int) > 5 ==> False
15:29:56 <lambdabot>  Arguments exhausted after 0 tests.
15:30:05 <FunctorSalad> it only generates small ints?
15:30:10 <oerjan> @check \n -> (n::Int) > 5 ==> False
15:30:11 <lambdabot>  Arguments exhausted after 0 tests.
15:30:14 <non_socialist> what kinds fo programs did you gusy write for your daily use?
15:30:22 <FunctorSalad> isn't there some parameter that makes it return the generated ints?
15:30:29 <dolio> @check (\n -> n > 5) :: Int -> Bool
15:30:30 <lambdabot>  Falsifiable, after 0 tests: 0
15:30:40 <dolio> @check (\n -> n < 5) :: Int -> Bool
15:30:41 <lambdabot>  Falsifiable, after 26 tests: 11
15:30:41 <oerjan> but it generated 16 above...
15:30:48 <keseldude> > let f s = if isUpper s then toLower s else toUpper s in map f "hI #HaSkElL"
15:30:50 <lambdabot>  "Hi #hAsKeLl"
15:30:52 <keseldude> is there a shorter way to do that?
15:31:25 <Pseudonym> non_socialist: Prototypes for complex or hard-to-understand stuff, and one-offs for when I need a certain thing done to a certain collection of data.
15:31:30 <Pseudonym> That's mostly it for work-related stuff.
15:31:37 <mauke> keseldude: (if isUpper s then toLower else toUpper) s
15:32:05 <keseldude> i don't think that worked
15:32:18 <vincenz> @pl test a ? foo a =: bar a
15:32:18 <lambdabot> test a ? foo a =: bar a
15:32:24 <vincenz> @pl \a -> test a ? foo a =: bar a
15:32:24 <lambdabot> ap ((=:) . liftM2 (?) test foo) bar
15:32:33 <mauke> resiak: I don't think so
15:32:53 <keseldude> > map (if isUpper then toLower else toUpper) "hI"
15:33:01 <lambdabot>  Couldn't match expected type `Bool'
15:33:07 <vincenz> keseldude: you missed the 's'
15:33:55 <keseldude> I figured the 's' is each element of the list "hI"
15:33:58 <resiak> mauke: turns out it's on http://haskell.org/haskellwiki/Blog_articles in the FFI section
15:34:12 <oerjan> > map (([toLower,toUpper]!!).fromEnum.isUpper) "hI"
15:34:14 <lambdabot>  [<Char -> Char>,<Char -> Char>]
15:34:22 <oerjan> er
15:36:32 <oerjan> > map (([toLower,toUpper]!!)=<<(fromEnum.isUpper)) "hI"
15:36:41 <lambdabot>  "hI"
15:36:51 <oerjan> bah
15:37:03 <oerjan> > map (([toUpper,toLower]!!)=<<(fromEnum.isUpper)) "hI"
15:37:04 <lambdabot>  "Hi"
15:37:10 <FunctorSalad> @check \n -> (n::Int)>0 ==> collect n $ Tru
15:37:11 <lambdabot>   Not in scope: data constructor `Tru'
15:37:14 <FunctorSalad> @check \n -> (n::Int)>0 ==> collect n $ True
15:37:15 <lambdabot>  OK, passed 500 tests. 5% 1., 5% 2., 5% 3., 4% 5., 3% 4., 2% 15., 2% 18., 2% ...
15:37:41 <mauke> hmm, I'm not sure ... I think I invented the offsetof trick myself, for use in C
15:37:45 <FunctorSalad> dolio, oerjan: query lambdabot with that if you want to see the full statistic
15:38:02 <mauke> adapting it to hsc2hs was trivial
15:40:45 <dolio> @check \n -> (n::Int)>3 ==> collect n $ True
15:40:46 <lambdabot>  Arguments exhausted after 0 tests.
15:41:38 <dolio> That doesn't really jive with the ">0" output, if I'm reading it correctly.
15:41:51 <vincenz> @join #oasis
15:43:38 <FunctorSalad> dolio: yeah
15:43:52 <FunctorSalad> odd
15:44:08 <oerjan> @check \n -> (n::Int)>1 ==> collect n $ True
15:44:09 <lambdabot>  OK, passed 500 tests. 6% 3., 5% 4., 5% 2., 3% 8., 3% 5., 2% 6., 2% 16., 2% 1...
15:44:16 <oerjan> @check \n -> (n::Int)>2 ==> collect n $ True
15:44:17 <lambdabot>  OK, passed 500 tests. 6% 3., 5% 5., 4% 4., 3% 8., 3% 6., 3% 13., 3% 7., 2% 9...
15:44:24 <dolio> Works for 1 and 2, but breaks at 3.
15:44:33 <oerjan> @check \n -> (n::Int)>3 ==> collect n $ True
15:44:34 <lambdabot>  Arguments exhausted after 0 tests.
15:45:07 <oerjan> is there some test for whether too few candidates fit the precondition perhaps?
15:47:24 <dolio> There is a max fail.
15:47:33 <dolio> The default configuration has it set to 1000.
15:48:56 <dolio> Raising it to 10,000 doesn't help in ghci, though.
15:49:42 <oerjan> hm same behavior in hugs
15:49:54 <dolio> Same with 1,000,000 (pending).
15:50:31 <oerjan> < -3 too
15:53:05 <FunctorSalad> 1000 should be enough anyway according to the distribution for n>0
15:53:43 <FunctorSalad> I guess we should just RTFM rather than speculating ;)
15:55:25 <dolio> Oh.
15:55:42 <dolio> Use defaultConfig { configSize = (+4) }
15:56:35 <dobblego> does anyone have lambdabot compiled and working on a vmware image yet?
15:56:53 <dolio> The check uses that function to base the size of the values on the number of tests succeeded.
15:57:06 <ojacobson> Is it possible for a class C c to declare a method taking a c and returning any C?  (I'm not sure I'm wording this right; a code example may be needed)
15:57:26 <EvilTerran> class Foo a where foo :: Foo b => a -> b --?
15:57:31 <oerjan> ouch
15:57:45 <oerjan> so if none succeed the size is never increased
15:57:51 <dolio> Default is (+3) . (`div` 2), which is 3 for ntests = 0, so it never meets the precondition or something.
15:57:55 <ojacobson> I tried that and ghci bitched about it
15:58:01 <ojacobson> One moment
15:58:10 <EvilTerran> er... you can't declare classes at the ghci prompt
15:59:18 <monochrom> You can declare such a class, but implementing instances is likely difficult.
15:59:31 <hpaste>  ojacobson pasted "(no title)" at http://hpaste.org/5647
15:59:46 <sarehu`> ojacobsen: you could do it.  for example the Enum class could have had something like enumToEnum :: Enum b => a -> b, where enumToEnum = toEnum . fromEnum
16:00:00 <dolio> @type randomR
16:00:11 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
16:00:48 <monochrom> Here is an equivalent strategy. Define a canonical type T. Class C specifies two methods: self -> T, T -> self. Then a simple composition does general conversion between any two C instances.
16:01:09 <ojacobson> monochrom: hmm
16:01:13 <monochrom> Indeed in the Enum example, Int is the canonical type.
16:01:23 <ojacobson> I might be going wrong by trying to use the class as a canonical type, since classes aren't types as such, then?
16:01:23 <monochrom> Here is another example:
16:01:33 <monochrom> @type fromIntegral
16:01:34 <lambdabot> forall a b. (Num b, Integral a) => a -> b
16:01:43 <ojacobson> I figured I was writing something nonsensical, but I couldn't see why
16:01:49 <monochrom> fromIntegral uses Integer as the canonical type.
16:02:03 <oerjan> @type realToFrac -- uses Rational
16:02:04 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
16:03:26 <dolio> oerjan: Yeah. 'n = configSize ntests' '(size, rnd') = randomR (0, n) rnd' '<tested value> = <generator> size rnd''
16:12:23 <non_socialist> heh
16:12:33 <non_socialist> I need a strategy to learn haskell
16:12:36 <non_socialist> and programming
16:15:57 <Cale> non_socialist: You might try Hutton's new book.
16:17:43 <gwern> new book?
16:18:00 <gwern> I hope that was his school of expression which I just bought...
16:18:56 <ehird_> what we need is a haskell web browser, with a custom rendering engine
16:18:57 <ehird_> :-P
16:18:58 <monochrom> school of expression is written by hudak. hutton's book is under another name.
16:19:26 <monochrom> Anyway, generally, consult three sources when learning anything.
16:19:26 <gwern> oh. my bad. mentally hudak =? hutton, I guess
16:20:07 <gwern> ehird_: you joke, but I saw a essay a while ago on reddit on what a ground-up redesign of a rendering engine would be, and Haskell suited the languaage requirements very well
16:20:48 <dcoutts_> I'm sure, you'd want nice layout combinators and do the constraint solving etc
16:20:48 <gwern> (as the comments pointed out)
16:21:05 <dcoutts_> and you can use cairo to do the actual drawing
16:21:15 <dcoutts_> just like the new mozilla engine uses on all platforms
16:21:33 <dcoutts_> as does WebKit now too actually
16:21:44 <ehird_> bah, cairo
16:21:50 <ehird_> cairo is x11/win
16:21:54 * ehird_ continues fighting the mac fight
16:22:02 <ehird_> err, unless cairo works on quartz now?
16:22:03 <dcoutts_> no it's not, it's cross platform
16:22:06 <ehird_> seriously?
16:22:07 <ehird_> :-O
16:22:10 <ehird_> wait
16:22:15 <ehird_> is it as ugly as FF's text rendering
16:22:18 <dcoutts_> it has backends for all common platforms
16:22:19 <ehird_> because on OS X that is ugly.
16:22:24 <dcoutts_> and uses the native font systems
16:22:31 <ehird_> well, ff sure doesn't
16:22:44 <dcoutts_> ff 2 perhaps, but ff 3 use cairo
16:22:53 <ehird_> ok
16:22:59 <dcoutts_> what's that font system called on osx? ATUI or something like that
16:23:08 <ehird_> ATSUI is the newfangled one, iirc
16:23:14 <ehird_> the old one is part of QuickDraw, and it sucks
16:23:18 <dcoutts_> right, that's what cairo uses
16:23:24 <ehird_> and there's just the generic blah-rendering which i dont' know if it's ATSUI or just something core
16:24:01 <ehird_> actually, one project i would like to see is a *simple* haskell compiler
16:24:18 <ehird_> for some people (including me) seeing real, honest-to-god, working code implementing something is the best way to understand it :)
16:24:21 <dcoutts_> ehird_: there's yhc and nhc
16:24:34 <ehird_> dcoutts_: yes, but they still are more advanced than what i was thinking
16:24:43 <ehird_> i was thinking basically no optimization
16:24:53 <gwern> there was one such Haskell compiler
16:24:57 * gwern saw it on reddit...
16:24:59 <non_socialist> so about happs, heh, anyone got it going?
16:25:03 <ehird_> i guess i was thinking of a simple one something like:
16:25:21 <ehird_> written in simple Haskell, no ghc-specific extensions apart from the ones that it itself implements (;))
16:25:26 <ehird_> maybe use Parsec for the parser?
16:25:33 <gwern> wait, I found it
16:25:37 <ehird_> then just output machine-code -- maybe port Harpy?
16:25:40 <gwern> http://lambda-the-ultimate.org/node/366
16:25:41 <lambdabot> Title: The Essential Haskell Compiler | Lambda the Ultimate
16:25:43 <ehird_> and a runtime in C
16:25:44 <hpaste>  dibblego pasted "Literate Haskell error" at http://hpaste.org/5648
16:25:49 <ehird_> that would be cool.
16:26:07 <dobblego> can I not use -> in literate Haskell?
16:26:13 <mauke> dobblego: missing \
16:26:22 <dobblego> gah, where'd it go!?
16:26:30 <dobblego> thanks :)
16:30:30 <dobblego> fprogramming.org eats \ characters in Haskell mode
16:33:34 <ehird_> dobblego: o.O
16:33:53 <dolio> It's a conspiracy!
16:43:20 <non_socialist> wiki tend to eat what Im saying and make it into whatimsaying
16:46:15 <allbery_m> visof:  the folks in #ghc are about GHC development, and aren't interested in what they consider "user questions" (see #ghc's /topic)
16:46:56 <allbery_m> there's a libreadline.so.4 tarball available via a link from the GHC download page.  I don't know if there's an old libreadline.so.4 package for Debian/Ubuntu
16:47:58 <allbery_m> (well, I know there are but I doubt they install cleanly on newer systems)
16:48:07 <monochrom> the "universe" repo of ubuntu has readline 4.
16:48:49 <monochrom> I used it and it was fine.
16:49:02 <monochrom> Now I use the ghc binary that uses readline 5.
16:49:54 <allbery_m> heh.  "(Note that the problem that gets almost solved may only be almost your problem.)"
16:50:10 <monochrom> haha
16:50:51 <non_socialist> archlinux of course has a ghc package
16:52:37 <sw17ch> hello
16:52:57 <catface> is it possible to define a function f arg1 arg2 that does different things depending on the types of both arg1 & arg2 where arg1 & arg2 may be different types?
16:53:24 <Saizan> catface: you need a typeclass
16:54:44 <sw17ch> is there a way to ... what's the word ... extend the functionality of (.) so that instead of (f . g) x = \x -> f (g x) you have the option of passing multiple arguments to g first?
16:54:52 <elux> hey guys
16:55:04 <sw17ch> so, say ~ is this magical operator...
16:55:09 <byorgey> hi elux
16:55:10 <ojacobson> sw17ch: uncurry and friends
16:55:15 <sarehu> @pl \f g x y -> f (g x y)
16:55:15 <lambdabot> (.) . (.)
16:55:22 <sarehu> @pl \f g x y z -> f (g x y z)
16:55:23 <lambdabot> (.) . (.) . (.)
16:55:23 <Japsu> the infamous "tits" operator
16:55:30 <sw17ch> (f ~ g) x y z = \x -> f (g x y) z
16:55:33 <elux> i have taken a haskell course at school and its like nothing ive ever used before... but the question is, when would i really need to use something like haskell?
16:55:48 <elux> i know i can do anything with haskell.. but it seems more effort to have to describe everything in terms of math ..
16:55:56 <dobblego> elux, depends if you want to be a Java clerk or a programming
16:55:57 <elux> perhaps its that math is more percise.. so less bugs?
16:55:59 <byorgey> elux: when you get tired of how inelegant other languages are.
16:55:59 <dobblego> *programmer
16:55:59 <sw17ch> elux, i dream of being able to use Haskell at owrk
16:56:18 <Japsu> @unpl (.)(.)
16:56:18 <lambdabot> (\ b c e f -> b c (e f))
16:56:22 <Saizan> sw17ch: you want it to work for a g of any ariety? you can do it but requires some type hackery
16:56:22 <egaga> byorgey: you mean haskell is the most elegant?
16:56:26 <Japsu> @unpl (.) . (.)
16:56:26 <lambdabot> (\ i b c f -> i (b c f))
16:56:40 <sw17ch> Saizan, yeah, i want it to work with any g
16:56:41 <Japsu> @unpl (,)(,)
16:56:41 <lambdabot> (,) (,)
16:56:43 <elux> i like all areas of computer science/engineering.. im not married to any language.. haskell has always interested me
16:56:44 <Japsu> :o
16:56:45 <byorgey> egaga: no, just more elegant than most.
16:56:48 <Japsu> @type (,)(,)
16:56:50 <lambdabot> forall a b b1. b1 -> (a -> b -> (a, b), b1)
16:56:52 <sw17ch> evaluate g as far as you can, pass the evaluated g and the remaining arugments to f
16:56:57 <elux> it was quite easy to build a DSL with haskell .. i see the benefit there for sure
16:57:35 <elux> but.. i normally build larger systems where OO design helps with the construction ..
16:57:42 <sw17ch> elux: it keeps you from shooting your self in the foot unless you really REALLY want to
16:57:53 <sarehu> modulo space leaks
16:57:57 <sw17ch> poll: who's ever had a run time error in haskell?
16:58:01 <elux> so in other words, it helps build highly robust software?
16:58:14 <byorgey> elux: that's one thing it's very good for, yes.
16:58:17 <dobblego> elux, yes, it does what you probably do with OO, but much better
16:58:28 <elux> how so tho?
16:58:35 <elux> the code is not easy to read.. at least not for me
16:58:40 <dobblego> elux, with a powerful type system and expressive abstractions
16:58:40 <sw17ch> elux: that comes with time
16:58:41 <ojacobson> Most OO languages have very weak formal grounding
16:58:44 <elux> looks like a lot of mathematical expressions
16:58:48 * Nafai tries to get leksah going
16:58:55 <sw17ch> elux: what exactly do you think programming is :)
16:59:02 <byorgey> Nafai: any luck?
16:59:07 <dobblego> elux, learning to fly a plane would be difficult for me, but I bet I'll beat myself driving a car
16:59:07 <elux> lol .. def mathematical expressions
16:59:13 <Nafai> Just doing a darcs get right now
16:59:13 <elux> but. .. there are different levels of abstractions
16:59:39 <sarehu> elux: i.m.o. the most convenient thing is being able to define datastructures without having to go through the big bureaucracy
16:59:51 <dobblego> elux, and Haskell allows you to choose which level you desire, unlike mainstream OO
16:59:54 <Saizan> sw17ch: http://okmij.org/ftp/Haskell/types.html#polyvar-comp <-- this is a start :)
16:59:55 <lambdabot> Title: Haskell Programming: Types
17:00:08 <sarehu> or maybe 'datatypes' would be the right word to use
17:00:12 <byorgey> sw17ch: beware!  that way lies madness! ;)
17:00:23 <elux> sarehu: for example.. writing a binary format parser with haskell?
17:00:48 <sarehu> that's an example of what?
17:01:00 <catface> so i do instance MyClass a where f g h = blah & instance MyClass b where f g h = blurgh
17:01:06 <sw17ch> byorgey: i handed in my sanity when i started programming
17:01:10 <elux> well .. something that can easily be put into a datatype and parsed with haskell.. compared to other implementations in other languages
17:01:18 <non_socialist> if soeone could build a movie encryption software with web interface that didnt stink and was no buggy I would be much obliged
17:01:19 <byorgey> sw17ch: oh!  cool, you should be just fine then =)
17:01:20 <catface> where do i put the func that has one argument of a and one of b?
17:01:23 <sarehu> I think the most convenient thing about Haskell and some other languages is that you have less to worry about and keep track of at any point in time
17:01:27 <Saizan> sw17ch: http://okmij.org/ftp/Haskell/typecast.html#is-function-type  <-- it can be refined with this :)
17:01:28 <lambdabot> Title: Type improvement constraint
17:01:37 <non_socialist> ok how about haskell vs forth?
17:01:38 <dobblego> catface, in the type-class definition (class Foo where ...)
17:02:06 <sarehu> like, with Java, for example, you have to always wonder if a reference could be null -- and check the documentation
17:02:32 <Saizan> sw17ch: after reading that you'll probably realize that you don't want to use that operator in normal code :)
17:02:48 <sarehu> and you always have to make sure, by checking documentation, if the function is doing anything strange.
17:03:28 <elux> and why does that worry disappear with haskell?
17:03:34 <elux> that does sound great though
17:03:35 <byorgey> catface: if you want to dispatch on both types, you will need a class with two type parameters:  class Foo a b where ...
17:04:03 <sw17ch> elux: no side effects
17:04:15 <byorgey> catface: then you can say  instance Foo Int Char where...  instance Foo [Int] (Tree ByteString)... and so on
17:04:49 <catface> thanks
17:05:10 <sw17ch> elux: when i'm writing embedded software... and jim down the hallway wrote a function x(), i need to make sure x() doesn't smash my data structures and variables. in haskell, function x() is guaranteed not to smash or screw up my data structures
17:05:16 <byorgey> catface: also, you will need to enable the MultiParamTypeClasses extension
17:05:41 <byorgey> catface: either by passing -XMultiParamTypeClasses to ghc on the commandline, or putting {-# LANGUAGE MultiParamTypeClasses #-} at the top of your file
17:05:47 <sw17ch> when i make a variable, no body else can touch it
17:06:04 <monochrom> To solve a hard problem, you have to learn some amount of knowledge and add some amount of your invention. If you reduce one of them, you have to make up for it by increasing the other. Some of us haskellers prefer to learn more and invent less. Other programmers call the learning "math" and try to eliminate it.
17:06:08 <jeffz> sw17ch: guaranteed 99.9% :p
17:06:15 <elux> hrmm.. but if it doesnt smash them what does it do? just ignore it? or product logical errors?
17:06:46 <byorgey> monochrom: heh, that's a great way to look at it =)
17:06:47 <sw17ch> elux: now, here's the part where you'll run screaming if you don't know it already, so i don't want to say it
17:06:59 <dmwit> Actually, smashing is possible; it's just that the "smash" functions have such long, scary names that nobody uses them. =P
17:07:03 <monochrom> It's related to one of those "those who don't learn from history are bound to repeat it"
17:07:05 <elux> lol
17:07:13 <elux> say it
17:07:16 <elux> cuz i obviously dont know it
17:07:19 <sw17ch> elux: you can't change variables once their made
17:07:25 <jeffz> smashing is also possible if your implementation of haskell is broken
17:07:31 <elux> how does that make sense?
17:07:40 <sw17ch> jeffz: you're ruining everything. :(
17:07:53 <jeffz> sw17ch: sorry, but I think I found a heap corruption bug in ghc :p
17:07:53 <ehird_> elux: It's called unsafePerformIO. It's not Haskell, it's GHC/Hugs/ok-pretty-much-every-implementaiton.
17:08:01 <ehird_> [00:58]  <elux> the code is not easy to read.. at least not for me       <-- it's called learning a programming language
17:08:07 <sw17ch> jeffz: :o
17:08:15 <elux> well of course. the learning curve isnt a problem
17:08:20 <elux> im trying to find an excuse to learn it.. thats all
17:08:27 <sw17ch> elux: it was/is for me
17:08:28 <dmwit> elux: To make sense of it, you have to restructure your thoughts; instead of thinking of your program as a process of steps, think of it as a transformation from input to output.
17:08:38 <elux> because it seems so fascinating
17:08:52 <redleafgr> that should be excuse enough
17:09:04 <Saizan> how would you use unsafePerformIO to "smash" a pure value? the most you can do is create a fake pure one
17:09:06 <ehird_> elux: it's fun. it can be used to build safe, provably correct software. it allows fast, concise development while not sacrificing readability, and the compiler knows a lot about your program which lets it do fancy optimization -- without you having to specify it all.
17:09:10 <sw17ch> elux: if you want to count the total length of an array of strings, you can't keep one variable and += to it
17:09:11 <elux> dmwit: makes sense. more as a function in mathematics
17:09:15 <elux> more like i mean
17:09:17 <ehird_> Saizan: hm, good point
17:09:17 <dmwit> elux: Exactly!
17:09:20 <ehird_> Saizan: still
17:09:28 <ehird_> elux: exactly like, in fact.
17:09:34 <dmwit> Saizan: There's unsafeCoerce and friends, too.
17:09:35 <ehird_> Monads aren't a kludge; they're a useful tool outside of IO.
17:09:37 <monochrom> Ash nazg durbatuluk, ash nazg gimbatul, ash nazg thrakatuluk agh burzum-ishi krimpatual.  <--- that should be the long true name of unsafePerformIO.
17:09:59 <elux> what about performance?
17:10:09 <ehird_> and they are mathematically pure.. the only part of a Haskell program that isn't pure is the bit in your compiler, written in C (or similar), going through your actions and evilly running them in the real world. :-)
17:10:09 <elux> compared to ruby .. python .. c .. java ?
17:10:20 <ehird_> elux: Ruby? Python? heh. Haskell isn't a slow language...
17:10:21 <jeffz> elux: languages do not have performance, only implementations.
17:10:21 <dmwit> elux: About twice as slow as C, on average.
17:10:23 <sw17ch> elux: significantly faster, faster, half as fast, as fast
17:10:30 <Zao> monochrom: soulSuckingLambdaCatsWillComeForYourIO
17:10:33 <ehird_> It won't beat or match C, but it's definately much better than ruby and python
17:10:48 * monochrom fears lambda cats, the soul sucking ones!
17:10:49 <elux> jeffz: there is some degree where the implementation of the language counts
17:10:50 <ehird_> which are mainly 'slow-interpreter' languages, YARV and whatnot don't improve much
17:10:58 <dmwit> elux: In certain areas, Haskell is much faster than those languages, in certain areas much slower.
17:11:02 <ehird_> but Haskell compilers are clever, and the code produced is pretty efficient
17:11:12 <ehird_> Unless you're doing crazy stuff you should be OK
17:11:13 <dobblego> I have seen "definately" three times today and it's not even lunch time (grrr)
17:11:15 <elux> thats fair
17:11:28 <elux> that sounds great guys
17:11:29 <sw17ch> ghc is smarter than me. i don't usually consider that a bad thing until it gets cocky about it
17:11:36 <elux> any books you can suggest to help me get started?
17:11:46 <dmwit> ?where yaht
17:11:46 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
17:11:47 <ehird_> elux: the generally reccomended one i've seen is YAHT...
17:11:47 <elux> id prefer something i can gradually work through
17:11:49 <dmwit> ?where gentle
17:11:50 <lambdabot> http://www.haskell.org/tutorial/
17:11:50 <byorgey> dobblego: gues it's definately tim to aet lunhc.
17:11:51 <psykon> sw17ch, haha XD
17:11:52 <ehird_> some people like Gentle Introduction
17:12:01 <ehird_> some people like crazy screwball ones like Scheme in 48 Hours
17:12:04 <elux> that is not gentle
17:12:12 <ehird_> this is true
17:12:12 <dmwit> elux: No, it's not. =P
17:12:16 <sw17ch> i like http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
17:12:18 <lambdabot> Title: Write Yourself a Scheme in 48 Hours/Parsing - Wikibooks, collection of open-cont ..., http://tinyurl.com/2yojoc
17:12:18 <sw17ch> woops
17:12:19 <dmwit> elux: It's still my favorite.
17:12:22 <elux> gotcha
17:12:23 <sw17ch> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/
17:12:26 <dmwit> elux: YAHT was way too verbose for me.
17:12:28 <redleafgr> yaht is good
17:12:35 <ehird_> it's more like 'The hardcore haskell introduction for awesome people who know Lisp and are hardcore mathematicions HARDCORE'
17:12:37 <elux> what about connecting haskell to a database?
17:12:42 <ehird_> sw17ch: My problem is that it brushes over too much.
17:12:43 <elux> executing a query .. ?
17:12:47 <ehird_> elux: there are libraries. check the Haskell wiki.
17:12:52 <Japsu> @where HSQL
17:12:52 <lambdabot> http://htoolkit.sourceforge.net
17:12:58 <dmwit> ehird_: Dunno, I just came from a humble C/C++/python background...
17:12:59 <ehird_> most of them let you construct a query as a Haskell DSL, and it's type-checked, at compile-time
17:12:59 <sw17ch> i haven't gotten to working with databases yet :(
17:13:02 <ehird_> so pretty impressive
17:13:09 <ehird_> dmwit: Eh, me too -- and not that long ago.
17:13:18 <ehird_> A few months, maybe? Well, I tried before-hand, but still.
17:13:19 <elux> interesting
17:13:30 <elux> thanks guys
17:13:45 <elux> i really appreciate you guys spreading the good word.
17:13:46 <jeffz> elux: this one is amusing http://lisperati.com/haskell/
17:14:01 <ehird_> jeffz: that's more like a "hey, look what haskell can do", though
17:14:05 <ehird_> than a "let's learn haskell"
17:14:08 <Japsu> @faq
17:14:08 <lambdabot> The answer is: Yes! Haskell can do that.
17:14:14 <byorgey> well, every bit helps!
17:14:20 <jeffz> ehird_: every bit of exposure helps...
17:14:21 <ehird_> or rather: it's "look, if you leanr it you still can do this scripting stuff."
17:14:27 <sw17ch> Did some one drop this one here yet?  http://www.haskell.org/~pairwise/intro/section1.html
17:14:28 <lambdabot> Title: Haskell for C Programmers
17:15:38 <monochrom> "Haskell is hard. Let's go picnic!"
17:15:54 <dmwit> sw17ch: I found that one singularly unhelpful.
17:15:58 <faxathisia> Haskell is fun !
17:16:06 <ehird_> monochrom: Monads are hard, let's go pet cuddly th- crap.
17:16:35 <sw17ch> > take 5 $ [(x,y) | x <- [1..], y <- [1..x], 1 == gcd x y] -- this is the line that got me hooked
17:16:37 <idnar> Haskell Barbie says: Learning Haskell is HARD!
17:16:39 <lambdabot>  [(1,1),(2,1),(3,1),(3,2),(4,1)]
17:16:44 <faxathisia> :D
17:16:51 <faxathisia> > f x :: Expr
17:16:51 <lambdabot>  f x
17:16:56 <faxathisia> cool Expr is back
17:17:11 <byorgey> > gcd 7 4 :: Expr
17:17:12 <lambdabot>  abs 4 `rem` (abs 7 `rem` abs 4)
17:17:17 <faxathisia> hehe :D
17:17:19 <ehird_> > HELLO WORLD "abc" :: Expr
17:17:19 <lambdabot>   Not in scope: data constructor `WORLD'
17:17:23 <ehird_> hrm
17:17:27 <ehird_> what dose this ... 'expr' do
17:17:29 <ehird_> *does
17:17:30 <idnar> how the heck does that work?
17:18:38 <faxathisia> ehird, I thinx it's just a-z
17:18:39 <monochrom> Scheme Barbie probably says: (hardp (learn haskell))
17:18:39 <faxathisia> > product [1..10] :: Expr
17:18:39 <idnar> > "abc" :: Expr
17:18:39 <byorgey> > h e l l o w o r l d :: Expr
17:18:40 * sw17ch gawks
17:18:40 <ehird_> > foldl (f :: Expr) "0" [1,2,3,4]
17:18:40 <lambdabot>  1 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10
17:18:41 <lambdabot>  h e l l o w o r l d
17:18:41 <lambdabot>  Couldn't match expected type `a -> b -> a'
17:18:41 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Char]'
17:18:41 <ehird_> monochrom: HARD? -- p is a lispism
17:18:41 <sw17ch> > 1 + 1 :: Expr
17:18:41 <lambdabot>  1 + 1
17:18:43 <sw17ch> well that was boring
17:18:43 <ehird_> > foldl ((+) :: Expr) "0" [1,2,3,4]
17:18:43 <lambdabot>  Couldn't match expected type `Expr'
17:18:43 <sw17ch> :)
17:18:43 <ehird_> > foldl ((+) :: Expr) 0 [1,2,3,4]
17:18:43 <lambdabot>  Couldn't match expected type `Expr'
17:18:43 <monochrom> Oh oops.
17:18:43 <ehird_> eh phooey
17:18:44 <shachaf> monochrom: (let (us (go shopping)))
17:18:46 <sw17ch> > map (+1) [1..10] :: Expr
17:18:46 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
17:18:46 <idnar> heh
17:18:46 <byorgey> > foldl f 0 [1,2,3,4] :: Expr  -- ehird
17:18:46 <lambdabot>  f (f (f (f 0 1) 2) 3) 4
17:18:46 <sw17ch> > map (+1) [1..10] :: [Expr]
17:18:46 <lambdabot>  [1 + 1,2 + 1,3 + 1,4 + 1,5 + 1,6 + 1,7 + 1,8 + 1,9 + 1,10 + 1]
17:18:47 <sw17ch> heheheh
17:18:47 <ehird_> you missed some parens, shachaf
17:18:47 <ehird_> (let ((us (go shopping)))))
17:18:47 <mauke> > map (+x) [1..10]
17:18:47 <lambdabot>  [1 + x,2 + x,3 + x,4 + x,5 + x,6 + x,7 + x,8 + x,9 + x,10 + x]
17:18:49 <ehird_> 'let' is fun,
17:18:53 <shachaf> ehird_: Oh, right.
17:18:56 <faxathisia> > let fib 1 = 1 ; fib 2 = 1 ; fib n = fib (n-2) + fib (n-1) in fib 4 :: Expr
17:18:57 <lambdabot>  1 + (1 + 1)
17:19:00 <faxathisia> > let fib 1 = 1 ; fib 2 = 1 ; fib n = fib (n-2) + fib (n-1) in fib 5 :: Expr
17:19:01 <lambdabot>  1 + 1 + (1 + (1 + 1))
17:19:03 <faxathisia> > let fib 1 = 1 ; fib 2 = 1 ; fib n = fib (n-2) + fib (n-1) in fib 6 :: Expr
17:19:04 <lambdabot>  1 + (1 + 1) + (1 + 1 + (1 + (1 + 1)))
17:19:05 <ehird_> faxathisia: that is brilliant
17:19:08 <idnar> > x
17:19:09 <hpaste>  Nafai pasted "Errors compiling Leksah" at http://hpaste.org/5651
17:19:09 <lambdabot>  x
17:19:12 <sw17ch> > take 5 $ [(x,y) | x <- [1..], y <- [1..x], 1 == gcd x y] :: [Expr]
17:19:12 <lambdabot>  Couldn't match expected type `Expr' against inferred type `(t, t)'
17:19:18 <sw17ch> > take 5 $ [(x,y) | x <- [1..], y <- [1..x], 1 == gcd x y] :: Expr
17:19:19 <lambdabot>  Couldn't match expected type `Expr'
17:19:23 <byorgey> Nafai: heh, I was just about to ask you how it was coming =)
17:19:26 * sw17ch grumbles, complains
17:19:27 <Nafai> :)
17:19:30 <EvilTerran> > take 5 $ [(x,y) | x <- [1..], y <- [1..x], 1 == gcd x y] :: [(Expr,Expr)]
17:19:31 <lambdabot>  [(1,1),(2,1),(3,1),(3,2),(4,1)]
17:19:31 <ehird_> > let x = 1+1-x in x :: Expr
17:19:32 <lambdabot>  1 + 1 - (1 + 1 - (1 + 1 - (1 + 1 - (1 + 1 - (1 + 1 - (1 + 1 - (1 + 1 - (1 + ...
17:19:34 <idnar> > f
17:19:34 <lambdabot>  Add a type signature
17:19:35 <ehird_> okay
17:19:37 <ehird_> that rules
17:19:40 <idnar> @type f
17:19:41 <lambdabot> Not in scope: `f'
17:19:41 <ehird_> utterly and completely.
17:19:42 <shachaf> Is Cale responsible for this?
17:19:45 <ehird_> i mean seriously.
17:19:46 <faxathisia> ehird, Yeah, reflection in such a non dynamic language is crazy :D
17:19:55 <Nafai> byorgey: Yeah, so, not quite working
17:19:59 * shachaf remembers reading about this -- did he add it to lambdabot?
17:19:59 <Cale> hm?
17:20:03 <ehird_> > let x = 1/x in x :: Expr
17:20:03 <byorgey> shachaf: no, twanvl
17:20:05 <lambdabot>  1 / (1 / (1 / (1 / (1 / (1 / (1 / (1 / (1 / (1 / (1 / (1 / (1 / (1 / (1 / (1...
17:20:07 <ehird_> hah
17:20:10 <Cale> Am I responsible for what?
17:20:12 <dmwit> How does it get function names?  That's the really surprising bit to me.
17:20:13 <shachaf> byorgey: Oh, it's part of the main lambdabot now?
17:20:20 <idnar> > foldl f 0 [1,2,3,4]
17:20:21 <faxathisia> Cale, Expr
17:20:23 <lambdabot>  Add a type signature
17:20:25 <idnar> heh
17:20:28 <ehird_> > let f x = x/(f (x+1)) in f 1 :: Expr
17:20:28 <Cale> No, twanvl is.
17:20:29 <lambdabot>  1 / ((1 + 1) / ((1 + 1 + 1) / ((1 + 1 + 1 + 1) / ((1 + 1 + 1 + 1 + 1) / ((1 ...
17:20:36 <byorgey> dmwit: f,g,h are specially defined as functions, and the other a-z are variables
17:20:48 <dmwit> a
17:20:51 <ehird_> > a
17:20:52 <lambdabot>  a
17:20:55 <ehird_> > f a
17:20:56 <lambdabot>  Add a type signature
17:21:03 <ehird_> > f
17:21:04 <lambdabot>  Add a type signature
17:21:05 <byorgey> > f a :: Expr
17:21:06 <lambdabot>  f a
17:21:12 <dmwit> > f :: Expr
17:21:12 <lambdabot>  f
17:21:13 <Cale> It's effectively just carrying around showsPrec, along with some hacks for carrying around the numeric value of an expression if it exists.
17:21:24 <sw17ch> > iterate (\x -> "f(" ++ x ++ ")") "x" :: Expr
17:21:25 <lambdabot>  Couldn't match expected type `Expr'
17:21:26 <dmwit> Yeah, that's pretty clever.
17:21:29 <byorgey> > a b :: Expr   -- probably doesn't work
17:21:30 <lambdabot>  Couldn't match expected type `Expr -> Expr'
17:21:36 <sw17ch> > take 5 $ iterate (\x -> "f(" ++ x ++ ")") "x" :: Expr
17:21:36 <lambdabot>  Couldn't match expected type `Expr'
17:21:40 <sw17ch> > take 5 $ iterate (\x -> "f(" ++ x ++ ")") "x" :: [Expr]
17:21:40 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Char]'
17:21:45 <ehird_> > let foo = f foo in foo :: Expr
17:21:46 <sw17ch> .. so i need to quit that
17:21:46 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
17:21:52 <Cale> It might be fun to try extending it to work better with any Typeable using Dynamic.
17:21:53 <ehird_> > fix :: Expr
17:21:54 <lambdabot>  Couldn't match expected type `Expr'
17:21:57 <ehird_> > fix fix :: Expr
17:21:58 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
17:21:58 <lambdabot>     Probabl...
17:22:00 <Cale> (and not just numbers)
17:22:02 <dmwit> > fix f
17:22:02 <lambdabot>  Add a type signature
17:22:08 <dmwit> > fix f :: Expr
17:22:08 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
17:22:13 <ehird_> > let foo x = x foo in fixfoo :: Expr
17:22:14 <lambdabot>   Not in scope: `fixfoo'
17:22:16 <ehird_> > let foo x = x foo in fix foo :: Expr
17:22:17 <lambdabot>      Occurs check: cannot construct the infinite type:
17:22:17 <lambdabot>       t = (t -> t1) ->...
17:22:20 <ehird_> d'aww
17:22:20 <ehird_> :)
17:22:22 <wagle_home> > (a :: Expr -> Expr) b :: Expr
17:22:23 <lambdabot>  Couldn't match expected type `Expr -> Expr'
17:22:33 <ehird_> > putStrLn "foo" :: Expr
17:22:33 <lambdabot>  Couldn't match expected type `Expr' against inferred type `IO ()'
17:22:38 <sw17ch> > gcd 10 7 :: Expr
17:22:38 <ehird_> > putStrLn "foo" :: IO Expr
17:22:38 <lambdabot>  abs 7 `rem` (abs 10 `rem` abs 7)
17:22:39 <lambdabot>  Couldn't match expected type `Expr' against inferred type `()'
17:22:41 <faxathisia> > iterate (f . g) () :: Expr
17:22:41 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[()]'
17:22:46 <wagle_home> > (a :: Expr -> Expr) (b :: Expr) :: Expr
17:22:47 <lambdabot>  Couldn't match expected type `Expr -> Expr'
17:22:54 <faxathisia> > iterate (f) () :: Expr
17:22:55 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[()]'
17:22:56 <sw17ch> it's like we all have a new toy
17:22:59 <ehird_> > let factorial n=product[1..n] in factorial 4 :: Expr
17:23:01 <lambdabot>  1 * 1 * 2 * 3 * 4
17:23:02 <ehird_> sw17ch: we don't?
17:23:04 <faxathisia> > iterate (f) 1 :: Expr
17:23:04 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
17:23:06 <ehird_> > let factorial n=product[2..n] in factorial 4 :: Expr
17:23:08 <lambdabot>  1 * 2 * 3 * 4
17:23:10 <faxathisia> > iterate f a :: Expr
17:23:10 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
17:23:12 <ehird_> > let factorial n=product[3..n] in factorial 4 :: Expr
17:23:13 <lambdabot>  1 * 3 * 4
17:23:13 <sw17ch> ehird_, we all have a new toy!
17:23:17 <ehird_> oh duh
17:23:20 <ehird_> > let factorial n=product[2..n] in factorial 4 :: Expr
17:23:22 <lambdabot>  1 * 2 * 3 * 4
17:23:30 <faxathisia> > iterate (f  a :: [Expr]
17:23:30 <lambdabot> Unbalanced parentheses
17:23:34 <faxathisia> > iterate (f . g) () :: [Expr]
17:23:34 <lambdabot>  Couldn't match expected type `Expr' against inferred type `()'
17:23:37 <faxathisia> > iterate (f . g) a :: [Expr]
17:23:37 <lambdabot>  Add a type signature
17:23:38 <ehird_> > fix :: Expr
17:23:39 <lambdabot>  Couldn't match expected type `Expr'
17:23:41 <faxathisia> :(
17:23:44 <ehird_> > let foo = f fix in foo :: Expr
17:23:45 <lambdabot>  Add a type signature
17:23:46 <sw17ch> well, it's been fun. going to rot my brain with video games
17:23:51 <ehird_> > fix (f . g) :: Expr
17:23:51 <faxathisia> > map g $ iterate f a :: [Expr]
17:23:52 <lambdabot>  Add a type signature
17:23:52 <lambdabot>  [g a,g (f a),g (f (f a)),g (f (f (f a))),g (f (f (f (f a)))),g (f (f (f (f (...
17:24:11 <ehird_> ooh wait
17:25:03 <ehird_> > let ack 0 = 1+ ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1))
17:25:03 <lambdabot>  Parse error at ";" (column 16)
17:25:18 <ehird_> > let{ ack 0 = 1+ ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 4 50 :: Expr
17:25:18 <lambdabot>  Parse error at ";" (column 17)
17:25:29 <ehird_> > let{ ack 0 = (1+) ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 4 50 :: Expr
17:25:30 <lambdabot>  arity mismatch for 'ack' at "ack" (column 6)
17:25:36 <ehird_> gah
17:25:39 <ehird_> that is lame
17:25:44 <ehird_> why can't i curry pattern matches like that
17:25:50 <ehird_> > let{ ack 0 n = 1+n ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 4 50 :: Expr
17:25:56 <lambdabot> Terminated
17:25:59 <ehird_> hmph
17:26:05 <ehird_> no lazy
17:26:05 <ehird_> :(
17:26:14 <ehird_> > let{ ack 0 n = 1+n ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 4 3 :: Expr
17:26:20 <lambdabot> Terminated
17:26:26 <faxathisia> curried pattern matches!?
17:26:37 <ehird_> > let{ ack 0 n = 1+n ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 4 1 :: Expr
17:26:43 <lambdabot> Terminated
17:26:47 <ehird_> lambdabot suxx
17:26:56 <idnar> > let{ ack 0 n = 1+n ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 2 2 :: Expr
17:26:57 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + 1)))))
17:27:03 <idnar> > let{ ack 0 n = 1+n ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 3 1 :: Expr
17:27:03 <monochrom> @bots
17:27:04 <lambdabot> :)
17:27:04 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + 1)))))))))))
17:27:07 <idnar> > let{ ack 0 n = 1+n ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 4 1 :: Expr
17:27:13 <idnar> heh
17:27:13 <lambdabot> Terminated
17:27:13 <byorgey> haha
17:27:15 <ehird_> > let{ ack 0 n = 1+n ; ack m 0 = ack (m-1) 1 ; ack m n = ack (m-1) (ack m (n-1)) } in ack 3 4 :: Expr
17:27:16 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
17:27:20 <faxathisia> cool
17:27:21 <ehird_> ...
17:27:22 <ehird_> that sucks
17:27:24 <ehird_> :)
17:27:25 <faxathisia> hahah
17:27:38 <idnar> heh
17:27:38 <monochrom> she hates you :)
17:27:48 <ehird_> > let foo x = x + foo x in foo 1 :: Expr
17:27:49 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
17:27:56 <ehird_> achived in far shorter chars
17:28:01 <idnar> bwaha
17:28:06 <monochrom> what would you give to lambdabot on St Valentine's Day? :)
17:28:12 <ehird_> > fix(\f x->1+f x)1::Expr
17:28:13 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
17:28:16 <ehird_> there
17:28:18 <ehird_> beat THAT
17:28:43 <ehird_> > f x=1+f x;f 1::Expr
17:28:44 <lambdabot>  Parse error at "=1+f" (column 4)
17:28:46 <idnar> @pl fix(\f x->1+f x)1
17:28:46 <lambdabot> fix ((1 +) .) 1
17:28:56 <ehird_> > fix((1+).)1
17:28:59 <ehird_> > fix((1+).)1::Expr
17:29:07 <lambdabot>  Exception: <<loop>>
17:29:07 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
17:29:07 <ehird_> woot
17:29:14 <idnar> how does that work?
17:29:19 <monochrom> > fix f :: Expr
17:29:20 <ehird_> idnar: what do you mean?
17:29:20 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
17:29:25 <monochrom> beat mine!
17:29:31 <idnar> there's no f-h or a-z in that expression
17:29:32 <ehird_> fix f = f x where x = fix f
17:29:38 <idnar> where does the Expr magic happen?
17:29:42 <ehird_> idnar: i don't know
17:29:44 <mauke> idnar: fromInteger
17:29:48 <ehird_> i think Expr has some kind of crazy 'show'
17:29:51 <idnar> mauke: ahhh
17:29:57 <EvilTerran> indeed
17:30:00 <idnar> > 1 :: Expr
17:30:04 <lambdabot>  1
17:30:07 <idnar> crazy
17:30:30 <EvilTerran> and the names a,b..z are all defined in lambdabot's scope to be Exprs with the appropriate show
17:30:38 <idnar> yeah
17:30:45 <ehird_> > x=1+x;x
17:30:46 <lambdabot>  Parse error at "=1+x;..." (column 2)
17:30:48 <monochrom> > fix (\f x -> if x==0 then 0 else f (x-1)) 5
17:30:49 <lambdabot>  0
17:30:52 <EvilTerran> ?type f
17:30:53 <lambdabot> Not in scope: `f'
17:30:55 <ehird_> > n=1+n;n::Expr
17:30:56 <lambdabot>  Parse error at "=1+n;..." (column 2)
17:30:57 <idnar> > let x = 1 + x in x
17:30:58 <lambdabot>  Exception: <<loop>>
17:30:58 <EvilTerran> > typeOf f
17:30:59 <lambdabot>  Add a type signature
17:31:00 <monochrom> > fix (\f x -> if x==0 then g 0 else f (x-1)) 5
17:31:00 <lambdabot>  Add a type signature
17:31:02 <idnar> > let x = 1 + x in x :: Expr
17:31:03 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
17:31:05 <monochrom> > fix (\f x -> if x==0 then g 0 else f (x-1)) 5 :: Expr
17:31:06 <EvilTerran> > f :: Expr -> Expr
17:31:07 <lambdabot>  g 0
17:31:08 <lambdabot>   add an instance declaration for (Typeable Expr)
17:31:10 <ehird_> > let x=1+n in x
17:31:11 <lambdabot>  1 + n
17:31:12 <EvilTerran> hmm
17:31:15 <ehird_> oops
17:31:15 <ehird_> haha
17:31:19 <ehird_> > let x=1+x in x
17:31:20 <lambdabot>  Exception: <<loop>>
17:31:24 <ehird_> > x where x=1+x
17:31:25 <lambdabot>  Parse error at "where" (column 3)
17:31:28 <ehird_> phoo
17:31:38 <ehird_> we need a fix for numbers :)
17:31:47 <EvilTerran>  > is expressions, not bindings
17:31:51 <ehird_> fixn n = n+x where x = fixn n
17:31:52 <hrehf> vincenz ok, i ended up using the listings package, it has rudimentary hs support
17:31:55 <ehird_> EvilTerran: yeah
17:32:03 <ehird_> @let fixn n = n+x where x = fixn n
17:32:05 <lambdabot> Defined.
17:32:07 <EvilTerran> where is only allowed in places where a binding's taking place
17:32:09 <ehird_> > fixn 1::Expr
17:32:09 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
17:32:12 <ehird_> BEAT THAT
17:32:28 <idnar> pfft
17:32:35 <faxathisia> > fixn (1+1)::Expr
17:32:36 <lambdabot>  1 + 1 + (1 + 1 + (1 + 1 + (1 + 1 + (1 + 1 + (1 + 1 + (1 + 1 + (1 + 1 + (1 + ...
17:32:37 <faxathisia> done :P
17:32:38 <idnar> @let fixn1 = fixn 1
17:32:40 <EvilTerran> > fix (1+) :: Expr
17:32:40 <lambdabot> Defined.
17:32:41 <lambdabot>  1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1...
17:32:45 <idnar> > fixn1
17:32:50 <lambdabot> Terminated
17:32:52 <idnar> oops
17:32:52 <ehird_> oooh, EvilTerran :)
17:32:57 <ojacobson> > fixn1 :: Expr
17:32:57 <idnar> @let fixn1e = fixn 1 :: Expr
17:32:57 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Integer'
17:32:58 <lambdabot> <local>:6:19: Not in scope: type constructor or class `Expr'
17:33:00 <faxathisia> can you do L-systems with this?
17:33:04 <idnar> aww
17:33:11 <ehird_> faxathisia: probably.
17:33:24 <monochrom> I thought my fix f :: Expr beat all of you already.
17:33:46 <EvilTerran> we need to get type-level Fix involved somewhere
17:34:03 <idnar> > fix a :: Expr
17:34:04 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `Expr'
17:34:35 <ehird_> @let u = fix :: ((t -> t) -> Expr)
17:34:36 <lambdabot> <local>:6:24: Not in scope: type constructor or class `Expr'
17:34:39 <ehird_> hehe
17:34:41 <EvilTerran> f,g,h are more polymorphic than the others, iirc, so are usable as functions
17:34:52 <ehird_> > f.g.h
17:34:53 <lambdabot>  Add a type signature
17:34:56 <ehird_> > f.g.h :: Expr
17:34:57 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> c'
17:35:02 <EvilTerran> > f.g.h :: Expr -> Expr
17:35:02 <lambdabot>   add an instance declaration for (Typeable Expr)
17:35:06 <idnar> woah
17:35:07 <ehird_> > (f . g . h) x :: Expr
17:35:08 <lambdabot>  Add a type signature
17:35:10 <ehird_> eh
17:35:10 <EvilTerran> > f.g.h :: Int -> Expr
17:35:11 <lambdabot>   add an instance declaration for (Typeable Expr)
17:35:16 <EvilTerran> > f.g.h :: Int -> Int -- ?
17:35:17 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
17:35:23 <idnar> "add a type signature?! what do you call that?!"
17:35:29 <ehird_> > f
17:35:30 <lambdabot>  Add a type signature
17:35:35 <ehird_> > f :: Expr
17:35:38 <lambdabot>  f
17:35:39 <EvilTerran> > f.g.h :: Expr -> Int -- ...?
17:35:40 <lambdabot>   add an instance declaration for (Typeable Expr)
17:35:41 <ehird_> > g :: Expr
17:35:42 <lambdabot>  g
17:35:44 <ehird_> > f . g :: Expr
17:35:45 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> c'
17:35:51 <ehird_> > (\x -> f (g x)) :: Expr
17:35:53 <lambdabot>      The lambda expression `\ x -> f (g x)' has one argument,
17:35:53 <lambdabot>     but its typ...
17:35:55 <idnar> > (f :: Exprr . g :: Expr . h :: Expr)
17:35:56 <EvilTerran> ?type SimpleReflect.a
17:35:59 <lambdabot>  Parse error at "." (column 13)
17:35:59 <ehird_> of course, of course..
17:36:03 <lambdabot>     attempting to use module `SimpleReflect' (scripts/SimpleReflect.hs) which is not loaded
17:36:03 <ehird_> f are special
17:36:11 <ehird_> using . produces something new
17:36:14 <idnar> > ((f :: Expr) . (g :: Expr) . (h :: Expr))
17:36:14 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Expr'
17:36:16 <faxathisia> > let a 0 = l ; a n = b (n-1) ; b 0 = r ; b n = a (n-1) + b (n-1) in a 6 :: Expr
17:36:17 <idnar> heh
17:36:17 <lambdabot>  l + r + (r + (l + r)) + (r + (l + r) + (l + r + (r + (l + r))))
17:36:19 <ehird_> > (f.g.h) 1 :: Expr
17:36:19 <lambdabot>  Add a type signature
17:36:20 <faxathisia> You can do L systems :)
17:36:32 <ehird_> faxathisia: do fibonacci!
17:36:39 <faxathisia> that's it!
17:36:40 <ehird_> oh
17:36:41 <ehird_> haha
17:36:49 <byorgey> hehe, awesome =)
17:36:50 <idnar> > let fgh x = f (g (h x)) in fgh x
17:36:50 <lambdabot>  Add a type signature
17:36:51 <ehird_> > f (x*2) (x+1-1)
17:36:51 <lambdabot>  Add a type signature
17:36:54 <idnar> > let fgh x = f (g (h x)) in fgh x :: Expr
17:36:55 <lambdabot>  Add a type signature
17:36:56 <ehird_> > f (x*2) (y+1-1) :: Expr
17:36:57 <lambdabot>  f (x * 2) (y + 1 - 1)
17:37:01 <ehird_> aww
17:37:07 <idnar> > let fgh x = f (g (h x :: Expr)) in fgh x :: Expr
17:37:08 <lambdabot>  Add a type signature
17:37:11 <ehird_> > foldl (*) 4 [1,2,3] :: Expr
17:37:12 <lambdabot>  4 * 1 * 2 * 3
17:37:14 <ehird_> > foldl (*) 4 [1,2,3] :: [Expr]
17:37:15 <lambdabot>   add an instance declaration for (Num [Expr])
17:37:30 <ehird_> hm
17:37:31 <ojacobson> > let ones = 1 : ones in ones :: Expr
17:37:34 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[t]'
17:37:37 <ehird_> what's the ghc 'force' primitive again?
17:37:42 <EvilTerran> seq?
17:37:42 <ehird_> > let ones = 1 : ones in ones :: [Expr]
17:37:44 <monochrom> [Expr] ahem!
17:37:45 <faxathisia> > let f 0 = s ; f n = f (n-1) + f (n-1) - f (n-1) - f (n-1) + f (n-1) in f 3 :: Expr
17:37:47 <ehird_> EvilTerran: oh
17:37:47 <ehird_> duh
17:37:48 <ehird_> :)
17:37:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:37:52 <EvilTerran> :)
17:37:54 <lambdabot>  s + s - s - s + s + (s + s - s - s + s) - (s + s - s - s + s) - (s + s - s -...
17:37:56 <faxathisia> Kosh curve
17:37:56 <EvilTerran> @bot
17:37:58 <lambdabot> :)
17:40:17 <ehird_> EvilTerran: but how do you get the result?
17:40:20 * ehird_ dumb
17:40:21 <idnar> > foldl (:) 4 [1,2,3] :: [Expr]
17:40:21 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:40:21 <lambdabot>       Expected...
17:40:21 <idnar> > foldl (:) [4] [1,2,3] :: [Expr]
17:40:21 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:40:21 <lambdabot>       Expected...
17:40:21 <faxathisia> s = step, + turn left 90, - turn right 90
17:40:25 <idnar> > foldr (:) [] [1,2,3] :: [Expr]
17:40:25 <lambdabot>  [1,2,3]
17:40:25 <ehird_> i guess I want 'strict :: a -> a'
17:40:25 <ehird_> :)
17:40:26 <EvilTerran> ehird_, having a name on the left of `seq` means that name is reduced to WHNF when the `seq` expression is evaluatede
17:40:28 <ehird_> yes
17:40:28 <ehird_> but then you can't access that whnf
17:40:28 <EvilTerran> so later references to that same binding of that name will not take any evaluation time
17:40:29 <idnar> @type seq
17:40:29 <EvilTerran> (to evaluate as far as WHNF)
17:40:29 <lambdabot> forall a t. a -> t -> t
17:40:29 <idnar> strict a = a `seq` a?
17:40:30 <ehird_> > let foo = 1:foo `seq` []
17:40:30 <lambdabot>  Parse error at end of input
17:40:30 <ehird_> > let foo = 1:foo `seq` [] in foo
17:40:30 <lambdabot>  []
17:40:30 <Nafai> I e-mailed the author of Leksah my error
17:40:30 <ehird_> > let foo = 1:foo `seq` 1:foo in foo
17:40:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:40:30 <ehird_> hrm
17:40:30 <EvilTerran> idnar, that won't do anything; a is forced when a is forced anyway :P
17:40:30 <idnar> yeah...
17:40:33 <EvilTerran> ehird_, it doesn't really make sense to have a function 'strict :: a -> a'
17:40:34 <ehird_> > let strict = funeg lazy in strict [1..]
17:40:35 <ehird_> ;)
17:40:37 <lambdabot>   Not in scope: `lazy'
17:41:27 <EvilTerran> some event has to spark evaluation of the thing you're trying to force
17:41:41 <EvilTerran> in the case of seq, that event is the attempt to evaluate the seq expression as a whole
17:41:46 <EvilTerran> ... what're you trying to do?
17:44:54 <ehird_> EvilTerran: force [1..], then Expr it
17:44:56 <ehird_> :P
17:44:56 <ehird_> specifically,
17:44:56 <ehird_> (strict [1..]) :: Expr
17:44:57 <EvilTerran> well, for one thing...
17:44:57 <ehird_> er, [Expr]
17:44:57 <ehird_> i guess
17:44:58 <EvilTerran> > (undefined:undefined) `seq` 1
17:44:59 <lambdabot>  1
17:45:01 <EvilTerran> that's a stronger level of evaluation than WHNF you're looking for
17:45:01 <EvilTerran> WHNF only requires resolving the outermost constructor, as it were. just enough to distinguish between the value and _|_
17:45:02 <EvilTerran> > let x = [1..] in length x `seq` x :: [Expr] -- this does rather more forcing
17:45:03 <lambdabot> Terminated
17:45:03 <EvilTerran> > let x = [1..10] ++ undefined in length x `seq` take 10 x
17:45:03 <lambdabot>  Undefined
17:45:03 <EvilTerran> > let x = [1..10] ++ undefined in take 10 x
17:45:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:47:27 <EvilTerran> > let x = [1..10] ++ undefined in x `seq` take 10 x -- it's okay, the outermost constructor's defined
17:47:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:47:54 <dobblego> ?hoogle (a -> b -> b) -> b -> [a] -> [a] -> b
17:47:55 <lambdabot> No matches, try a more general search
17:51:53 <monochrom> > take 10 $ fix ((0:) . scanl (+) 1) :: [Expr]
17:51:54 <lambdabot>  [0,1,1 + 0,1 + 0 + 1,1 + 0 + 1 + (1 + 0),1 + 0 + 1 + (1 + 0) + (1 + 0 + 1),1...
17:51:54 <Gnezdo> Could somebody help me understand why I am getting this warning from ghc-6.6.1:
17:51:54 <Gnezdo> Warning: orphan instances: instance base:GHC.Show.Show [base:GHC.Prim.(->)] = $f1
17:51:55 <Gnezdo> I imagine it has something to do with this piece of code I wrote:
17:51:55 <Gnezdo> instance Show (Int -> ParameterizedMode) where show c = head $ words $ show $ c 0
17:51:55 <Gnezdo> Any suggestions how this instance can be done more elegantly?
17:51:57 <gwern> you can't derive show?
17:51:57 <dmwit> gwern: It's a function. ;-)
17:51:57 <Gnezdo> I do for ParameterizedMode
17:52:40 <gwern> dmwit: bah
17:52:40 <ehird_> _|_ and with the name 'bottom'
17:52:47 <ehird_> so unfortunate. another reason for haskell bashers to hate it!
17:52:48 <ehird_> ;)
17:53:24 <Gnezdo> ehird_: so what if it makes mathematical sense :-) it should be named something cute.
17:54:20 <gwern> hm, some code from '98. this should be fun
17:54:40 <Gnezdo> come to think of it, bottoms are cute at time
17:54:46 <Gnezdo> times
17:56:59 <monochrom> "instance X Y" is an orphan iff you're writing that code outside both the origin of X and the origin of Y.  Apart from making the compiler's life harder, there is nothing wrong.  It is warned because it makes the compiler's life harder.
17:57:47 <Gnezdo> oh, so I should move my instance declaration next to the type?
17:57:54 <Gnezdo> let me try that
17:58:59 <monochrom> But your X is Show and your Y is ->
17:59:16 <monochrom> Both are not written by you.
17:59:20 <Gnezdo> ouch
17:59:34 <monochrom> You should just ignore the warning.
17:59:34 <Gnezdo> so, no way to avoid the warning then?
17:59:51 <Gnezdo> fair enough, thanks for the explanation.
17:59:54 <monochrom> You could -ffno-warn-orphans
18:00:02 <Gnezdo> any suggestions on how to write this better?
18:00:05 <monochrom> err, -fno-warn-orphans
18:00:26 <dmwit> Gnezdo: Personally, I wouldn't make the show instance at all.
18:00:45 <Gnezdo> dmwit: I use it to define an option name for GetOpt
18:00:55 <dmwit> There's not so many functions that require a Show instance in the first place, and that doesn't really "show" the whole thing in the sense show usually means.
18:00:58 <dmwit> Gnezdo: ah
18:01:16 <Gnezdo> I just want to show the constructor name
18:01:25 <dmwit> I've never used GetOpt, so if there's a Show requirement there, that could easily be a valid reason.
18:01:35 <Gnezdo> no, they don't require it
18:01:57 <Gnezdo> I want to write (map generateOption [Constr1, Constr2])
18:02:24 <Gnezdo> where Constr1 :: Int -> ParameterizedMode
18:02:28 <dmwit> Gnezdo: Then I would prefer something like "getConstructor = head . words . show".
18:02:41 <dmwit> oops
18:02:56 <dmwit> head . words . show . c -- of course
18:03:32 <dmwit> or whatever, you get the idea
18:03:58 <dmwit> Of course, my preferences are not universal. =)
18:04:23 <Gnezdo> I am not sure where it differs from what I wrote.
18:04:37 <Gnezdo> not an instance any longer?
18:05:02 <monochrom> Right, you likely can get away without using Show.
18:05:28 <Gnezdo> I have this clever: asOption showable = map toLower (show showable)
18:05:30 <monochrom> If you need typeclass generality, you can likely create your own typeclass.
18:05:39 <Gnezdo> monochrom: right
18:06:11 <Gnezdo> being a lazy bum I liked having Show written for me for the other type
18:06:14 <monochrom> Of course, you can also continue to use Show as planned. IMO it's ok. Toss a coin. :)
18:06:20 <dmwit> Gnezdo: The problem I have is that, typically, the expectation is that "show" gives enough information to reconstruct the entire object.
18:06:43 <ehird_> hmm
18:06:48 <dmwit> Gnezdo: As monochrom says, though, it's a very mild choice.
18:06:59 <ehird_> does ghc do stuff by mathematically proving things about the program's structure and semantics?
18:07:02 <ehird_> if so, that's completely awesome
18:07:24 <Gnezdo> ok, thanks guys. at least I know I'm missing something obvious and elegant.
18:07:28 <Gnezdo> I'm not
18:07:29 <dmwit> There is quite a lot of proving going on behind the scenes, but I think most of it was done by people.
18:07:37 <monochrom> Ah!  class MyClass t where myconvert :: t -> String.  instance Show t => MyClass t where myconvert = show.  instance MyClass (Int -> Para...) where myconvert f = f 0.
18:07:58 <monochrom> So, create your own class, and still benefit from Show. :)
18:07:58 <ehird_> dmwit: Phooey.
18:08:03 <ehird_> We need a Haskell compiler in Prolog. :-)
18:08:12 <Gnezdo> monochrom: cool! thanks
18:08:12 <ehird_> The inference engine finds the fastest output code for you!
18:08:14 <khadrin> why does generate take a count? im looking at the source but i still dont get it
18:08:19 <ehird_> Hmm. PrologM = best monad ever
18:08:29 <gwern> who did that?
18:08:32 <dmwit> ehird_: Search for LogicT, it may do what you want.
18:08:33 <ehird_> it would be prolog.. but written in haskell..
18:08:35 <ehird_> and oh my god
18:08:36 <ehird_> :D
18:09:02 <ehird_> dmwit: can i rewrite the human(plato)/mortal(X) example in it without extra typing baggage
18:09:04 <ehird_> if so that rocsk
18:09:34 <gwern> oh, you were wishing for a PrologM
18:09:36 <dmwit> Dunno, I've never used it.
18:09:50 <ehird_> actually, it should just be Logic
18:09:52 <ehird_> = PrologM ()
18:09:53 <monochrom> Start with LogicT anyway.
18:10:00 <ehird_> since prolog functions don't return values
18:10:49 <faxathisia> member e [] = return [e]
18:10:49 <faxathisia> member e l@(h:t) = return (e:l) `mplus` do { t' <- member e t; return (h:t') }
18:12:12 <faxathisia> permute [] = return []
18:12:12 <faxathisia> permute (h:t) = do { t' <- permute t; member h t' }
18:14:49 <ehird_> we need an IOT, I've always wanted to write a TwoDucks interpreter
18:14:51 <ehird_> :D
18:15:00 <ehird_> (http://esolangs.org/wiki/TwoDucks)
18:15:01 <lambdabot> Title: TwoDucks - Esolang
18:15:11 <gwern> @hoogle prim
18:15:12 <lambdabot> Text.ParserCombinators.Parsec.Prim :: module
18:15:12 <lambdabot> Data.HashTable.prime :: Int32
18:15:12 <lambdabot> Language.Haskell.TH.PrimTyConI :: Name -> Int -> Bool -> Info
18:15:48 <ehird_> Data.HashTable.prime :: Int32     -- is this a variable guaranteed to be any prime, any at all?
18:15:50 <ehird_> if so, that is hilarious
18:15:55 <ehird_> i am going to use it all over the place
18:16:16 <gwern> why?
18:16:26 <ehird_> i am not sure
18:16:27 <ehird_> :)
18:16:32 <faxathisia> It is prime for me (33554467)
18:18:23 <Cale> http://hpaste.org/5650#a1 -- anyone want to try writing a strict imperative (but still recursive?) version of this?
18:18:50 <Cale> (the invariant is that the tree passed to around is a binary search tree)
18:19:41 <Cale> Or even a strict functional one :)
18:19:51 <Cale> I think I'd end up simulating laziness.
18:20:17 <Cale> It's been too long since I last programmed in a strict language, I think :)
18:25:41 <gwern> 'putResult  (?flags  Flags)  Answer  IO ()' <-- what a weird type sig, I've never seen a question mark before
18:25:47 <gwern> I wonder what extension that is?
18:26:08 <dolio> Implicit parameters.
18:26:17 <gwern> what does that do?
18:26:20 <faxathisia> :t (\a -> a 1 2 3) a
18:26:23 <faxathisia> :t (\a -> a 1 2 3) ?a
18:26:35 <lambdabot> thread killed
18:26:39 <lambdabot> thread killed
18:27:12 <dolio> It's sort of like dynamic scoping, or a built-in reader monad.
18:27:26 <Saizan> Cale: since the first elements are on the same side of the tree i don't think it will be so hard
18:28:14 <dolio> > let f = ?foo in let ?foo = 2 in f
18:28:14 <lambdabot>  Parse error at "?foo" (column 9)
18:28:16 <gwern> dolio: global variables?
18:31:00 <Cale> Saizan: the trouble is that you don't know if x is in the greatest a elements less than or equal to the key or least b elements greater than the key. You just know whether it's (less than or equal to) the key, or if it's greater.
18:31:12 <Cale> I think I've worked out a reasonable approach though.
18:31:34 <dolio> gwern: Prelude> let f :: (?foo :: Int) => Int ; f = ?foo + 1
18:31:41 <dolio> Prelude> (let ?foo = 1 in f, let ?foo = 2 in f)
18:31:45 <dolio> (2,3)
18:32:26 <gwern> dolio: interesting. so it is a lot like a global variable then
18:32:45 <gwern> but scoped, I take it
18:33:04 <dolio> They aren't global, but they take on the value of the closest enclosing binding of where the function/value is used.
18:33:12 <dolio> Instead of where it's defined.
18:33:42 <dolio> It's like dynamic scoping in lisp, although I seem to recall some Oleg paper about how it actually isn't like dynamic scoping.
18:34:10 <gwern> @quote OlegFacts
18:34:10 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
18:34:29 <TomMD> Any windows users here?
18:34:43 <dolio> And of course, you can get the same effect with the reader monad:
18:35:05 <TomMD> Does Data.Time.Clock.POSIX work on windows?  (more to the point, does Control.Timeout work on windows)
18:35:07 <dolio> > let f = ask in (runReader 1 f, runReader 2 f)
18:35:12 <lambdabot>        add an instance declaration for (Num (Reader (m r) a1))
18:35:19 <dolio> > let f = ask in (runReader f 1, runReader f 2)
18:35:20 <lambdabot>  (1,2)
18:36:45 <dolio> Because reader is also like dynamic scoping in some ways (with one dynamically scoped variable named 'ask').
18:36:57 <gwern> ack. but if it can be done with reader, why Implicit Params? nicer syntax?
18:37:02 <dolio> I don't know when implicit params are from. They're kind of old, I think.
18:37:08 <dolio> Plus, you don't have to use monads. :)
18:37:38 <dolio> I think people generally aren't thrilled about them.
18:37:49 <dolio> Although, they're good for finding out the type of things inside expressions.
18:38:01 <dolio> @type foldl ?f 0 [1..10]
18:38:04 <lambdabot> forall a b. (Enum b, Num b, Num a, ?f::a -> b -> a) => a
18:38:12 <hpaste>  Cale annotated "around" with "version which would work okay in a strict language" at http://hpaste.org/5650#a2
18:40:49 <dolio> gwern: SPJ's research paper page has a paper on them (I think) if you want to know all the nuances.
18:41:58 <dolio> http://okmij.org/ftp/Computation/dynamic-binding.html#implicit-parameter-neq-dynvar
18:41:58 <lambdabot> Title: Dynamic Binding, http://tinyurl.com/2lx5h5
18:43:55 <dolio> There's the "implicit parameters are not dynamically scoped".
18:44:16 * gwern will dl and read
18:44:59 * byorgey compiles gtk2hs
18:45:19 <byorgey> it's almost more verbose than compiling ghc =)
18:45:22 <stick_figure> How does one understand functions being monads?
18:46:04 <Cale> stick_figure: The (->) e type constructor is a monad
18:46:21 <Cale> stick_figure: Basically, to "execute" a computation of type e -> a
18:46:35 <Cale> you apply the function to the parameter which is passed into the computation as a whole
18:46:38 <Cale> So...
18:46:48 <Nafai> byorgey: Trying to compile leksah?
18:46:54 <Cale> > (do x <- id; y <- reverse; z <- map toUpper) "Hello"
18:46:54 <lambdabot>  Parse error at ")" (column 44)
18:46:56 <byorgey> Nafai: yep
18:47:03 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
18:47:06 <Nafai> Let me know if you figure it out.
18:47:12 <lambdabot>  ("Hello","olleH","HELLO")
18:47:12 <byorgey> Nafai: about to go to bed though, I won't finish tonight
18:47:52 <Cale> damn.
18:49:42 <yondalf> hello?
18:50:10 --- mode: irc.freenode.net set +o ChanServ
18:50:30 <yondalf> the (->) a monad is comparable to the Reader monad, as someone showed me yesterday on irc
18:50:47 <yondalf> so reading up the Reader monad chapter in All About Monads might help
18:50:51 <lambdabot>  ("Hello","olleH","HELLO")
18:50:52 <Cale> jeez
18:50:53 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
18:50:53 <lambdabot>  ("Hello","olleH","HELLO")
18:50:54 <stick_figure> That makes sense.  I'm not sure how one would apply >>= though.
18:51:02 <Cale> okay
18:51:03 <lament> function composition?
18:51:10 <Cale> Basically, (x >>= f) e = let y = x e in f y e
18:51:11 <Cale> Yeah, (->) e is just an unwrapping of the Reader monad.
18:52:49 <stick_figure> huh.  You end up with f applied to two arguments, e and (x e)?  That seems strange.
18:53:17 <Cale> stick_figure: The point is to distribute the "environment" e to all the parts of the computation.
18:54:50 <stick_figure> Cale, huh, cool.
18:55:41 <Cale> stick_figure: So once x is "run" with the environment, its result is passed to f to get the computation which follows
18:55:51 <Cale> and then that computation is "run" by applying it to the environment as well
18:57:00 <stick_figure> That makes sense, but I'm having trouble drawing parallels between it and the way it's used in IO, which is what I was trying to do by investigating this instance.  >>= for Maybe makes sense to me, for example.
19:00:01 <yondalf> stick_figure: yeah, it's a bit different...in the Reader and (-> a) monads nothing is chained really
19:00:02 <yondalf> in IO the state of the outside world is, and in Maybe the "Just-ness" of it is chained
19:21:41 <gwern> @version
19:21:41 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
19:21:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:23:10 <gwern> *1616* patches? I think lambdabot needs a release and a checkpoint, stat
19:23:38 <gwern> once you hit 1500 patches since the last checkpoint, I think you should probably just do a release anyway...
19:24:35 <nornagon_> gwern: why?
19:24:46 <nornagon_> what's wrong with just using HEAD?
19:24:55 <gwern> nornagon: because the download is killing me
19:25:27 <gwern> also, the hackage lambdabot is seriously outdated
19:25:32 <kfish> hi nornagon
19:25:41 <nornagon> hi kfish!
19:25:46 <gwern> I idly tried a cabal install lambdabot, and it complained about not being able to find the fast packed strings package...
19:26:02 <nornagon> i'm at denver airport, waiting for my connection to sea-tac
19:26:09 <kfish> ah :-)
19:26:21 <nornagon> arriving in tokyo on the 16th :)
19:26:41 <kfish> gwern, sounds like lambdabot's not doing a good job of propagating herself
19:27:08 <kfish> @sentience
19:27:08 <lambdabot> Unknown command, try @list
19:27:13 <kfish> hmm
19:27:14 <gwern> kfish: indeed. she needs to facehuggle some folks
19:27:31 <nornagon> lambdabot: good trick, making it seem like you're not taking over the world
19:27:36 <nornagon> lambdabot: very convincing
19:27:49 <kfish> @yow
19:27:49 <lambdabot> I fill MY industrial waste containers with old copies of the "WATCHTOWER"
19:27:49 <lambdabot> and then add HAWAIIAN PUNCH to the top ...  They look NICE in the yard ...
19:28:05 <nornagon> lambdabot: but i'm going to burn you and blow you to pieces and throw every piece into a fire
19:28:11 <gwern> and my darcs get is only at 600...
19:28:18 <gwern> nornagon: but she'll be still alive
19:28:27 <gwern> while you're hacking, she'll be - still alive
19:28:33 <nornagon> ^_^
19:28:36 <gwern> while you're compiling, she'll be - still alive
19:28:40 <gwern> still alive...
19:28:58 <nornagon> (still alive)
19:29:54 <nornagon> these points of data make a beautiful line, and we're out of beta, we're releasing on time!
19:30:02 <gwern> no, we're not
19:30:07 <gwern> the HWN is terrible
19:30:11 <gwern> and lambdabot never gets released
19:30:32 <gwern> and I have no idea how many darcs schedules the conflict bug blew
19:30:55 <gwern> even xmonad slacks off, with short repo freezes lasting weeks
19:31:49 <gwern> obviously we need to stick some seqs into haskell developers
19:33:03 <Korollary> seqs would be nice
19:33:25 <dozer> hi guys
19:33:52 <Korollary> sayanora
19:34:04 <dozer> is there an implementation of abnf (http://www.ietf.org/rfc/rfc2234.txt) lying about?
19:35:30 <alexj> anyone here familiar with the implementation of data.binary?
19:35:55 <BMeph> Haskell: Where developers are kept in line by the promise of seqs. Lots and LOTS of seqs. ;)
19:37:27 <kfish> alexj, someone might be, are you thinking of something involving happs.state and data.binary, together at last?
19:37:50 <davidL> @bf +++.
19:37:50 <lambdabot>  fd:20: hClose: resource vanished (Broken pipe)
19:41:35 * gwern is pleased to see your minds prurient enough to catch the pun
19:44:43 <sw17ch> @type fix
19:44:47 <lambdabot> forall a. (a -> a) -> a
19:47:30 <gwern> 'Applying patch 1616 of 1616: Mon Feb  4 23:34:06 EST 2008  cgibbard@gmail.com * Frivolous patch to increase my own karma for fixing lambdabot.
19:48:21 <Nafai> Heh
19:48:37 <davidL> I think that was when he patched lambdabot to work with 6.8.2
19:48:55 <gwern> well, the previous patch is: Applying patch 1614 of 1616: Mon Feb  4 17:24:35 EST 2008  cgibbard@gmail.com * Updates for 6.8.2
19:49:28 <davidL> @version
19:49:29 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
19:49:29 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:49:35 <davidL> @karma Cale
19:49:35 <lambdabot> Cale has a karma of 64
19:50:24 <Cale> hehe
19:50:38 <gwern> Cale: you think lambdabot could get a release soon?
19:50:45 <Cale> gwern: sure.
19:50:47 <gwern> since you seem to be effectively maintaining it...
19:51:07 <Cale> gwern: Should probably fix the LICENSE file issue, and add some deps.
19:51:33 <gwern> what issue is that?
19:51:34 <Cale> (currently, if you have only the deps listed in the .cabal file, lambdabot will build, but eval will be broken.)
19:51:52 <gwern> darcs mv COPYING to LICENSE and have done wit it
19:52:00 <Cale> Oh, the LICENSE thing? There's no LICENSE file, so it won't build unless you touch LICENSE.
19:52:18 * gwern waits for Cale to see my previous comment
19:52:31 <Cale> Yeah, or that.
19:52:38 <sw17ch> just out of curiosity, would there be a way to speed up how long it takes to get all the patches with darcs... or was there a specific decision to make it work in a way that needs it to be ... slower
19:52:54 <Cale> Get darcs 2?
19:53:10 <gwern> sw17ch: to get *all* patches? right now, nothing doing until people upgrade to darcs-2
19:53:11 <sw17ch> ... stupid gentoo
19:53:19 <gwern> sw17ch: you can still use --partial of course
19:53:35 <gwern> and the repo can do stuff like make a checkpoint, which speeds things up a lot
19:53:49 <gwern> Cale: you gonna fix the license or shall I?
19:54:01 <Cale> If you're in a rush, you can do it.
19:54:22 <gwern> ok
19:54:34 <gwern> I'll also put the sdist on hackage too when I get it to build
20:02:12 <gwern> oh dear. sdist seems very broken on lambdabot
20:19:06 <trainignday1> how can i know if someone heard me the first time even if they are sleeping so i don't have to ever repeat again?
20:19:26 <cjb> trainignday1: if they are still logged in, they will probably read scrollback when they wake up.
20:19:47 <cjb> if you see them talking to other people, and you suspect they didn't see what you sent them, you can remind them.
20:20:15 <sw17ch> http://hackage.haskell.org/packages/archive/zlib/0.4.0.2/zlib-0.4.0.2.tar.gz
20:20:17 <lambdabot> http://tinyurl.com/3x9g5a
20:20:18 <sw17ch> woops
20:20:21 <sw17ch> src/Language/Hi/Binary.hs:90:7:
20:20:21 <sw17ch>     Could not find module `Data.Array.Base':
20:20:21 <sw17ch>       it is a member of package array-0.1.0.0, which is hidden
20:20:22 <gwern> trainignday1: use lambdabot. @tell is fairly reliable
20:20:26 <gwern> scrollback may not work
20:20:28 <sw17ch> there, any one know what causes that?
20:20:41 <gwern> sw17ch: sure. it's not updated for split-base
20:20:52 <gwern> that is. GHC 6.8.x
20:21:03 <gwern> it doesn't declare a dependency on array
20:21:14 <sw17ch> is there a fancy way to fix this, or is the package just broken
20:21:26 <gwern> sw17ch: get a new one
20:21:33 <gwern> or, download and edit the cabal, would be pretty esay
20:21:37 <gwern> *newer
20:21:40 <sw17ch> i'm looking at plugins-1.0
20:21:48 <sw17ch> trying to install lambdabot locally
20:22:17 <sw17ch> and runhaskell Setup.hs configure tells me i'm missing: QuickCheck -any, arrows -any, plugins >=1.0, oeis -any
20:22:51 <gwern> goodness. lambdabot out of the darcs repo?
20:23:01 * sw17ch hides
20:23:02 <sw17ch> :)
20:23:04 <sw17ch> yes
20:23:26 <gwern> I'm not sure plugins has a recent enough release
20:23:33 <gwern> you might need that one from darcs too
20:23:52 <gwern> no idea what oeis is, although I have it installed from hackage, it seems
20:24:03 <gwern> quickcheck and arrows are common, your distro might even package them
20:24:03 <sw17ch> :)
20:24:14 <sw17ch> gentoo has packages for them, but does not ship with
20:24:52 <sw17ch> so, given that searching for darcs and plugins turns up all sorts of things that have nothing to do with what i want... is there a better link?
20:25:22 <gwern> hold on
20:25:38 <gwern> it's hs-plugins btw
20:25:44 <sw17ch> just found that
20:25:56 <gwern> http://code.haskell.org/~dons/code/hs-plugins <-- so far as I know
20:25:57 <lambdabot> Title: Index of /~dons/code/hs-plugins
20:26:39 <sw17ch> yes, that's a *bit* newer than the one in hackage
20:27:31 <sw17ch> alright, now it's happy with plugins, but it still doesn't seem to see the others
20:27:38 <sw17ch> $ runhaskell Setup.hs configure
20:27:38 <sw17ch> Configuring lambdabot-4.0...
20:27:38 <sw17ch> Setup.hs: At least the following dependencies are missing:
20:27:38 <sw17ch>     QuickCheck -any, arrows -any, oeis -any
20:27:39 <brian`> if you are just given a list of random numbers, how would you determine if they are arithmetic sequence?
20:28:02 <sw17ch> $ cabal install QuickCheck arrows oeis
20:28:02 <sw17ch> All requested packages already installed. Nothing to do.
20:28:29 <gwern> hm. I'd probably turn them into a list of tuples, map a minus over them, and then see whether 'all' are equal
20:28:32 <trainignday1> what do you do when by location something or many things has differnt meaning and more offensive say for example banging doors or stepping can mean curb stomping?
20:28:57 * gwern has no idea what trainignday1 is talking about
20:29:07 <gwern> sw17ch: oh, I know what your problem is
20:29:10 <sw17ch> yay!
20:29:11 <gwern> sw17ch: configure with --user
20:29:24 <sw17ch> oh! voila!
20:29:33 <brian`> gwern, what do u mean by "see whether 'all' are equal"?
20:29:47 <sw17ch> it also seems that running cabal install in the lambdabot directory works :)
20:30:46 <gwern> brian`: well, if the difference between is pair is say '2', and you are left with a list of '2's, then it's an arithmetic sequence right? but if there's a 4, or a 1, or a 3 anywhere ion the list, anything but 2, then you have a pair of numbers which did not increase arithmetically
20:31:08 <gwern> and thus part of your original list might be in arithmetic sequence, but not the entire thing
20:31:23 <dolio> > let arithmetic = and . ap (zipWith (==)) tail . ap (zipWith (-)) tail in arithmetic [1,3,5,7,9]
20:31:24 <lambdabot>  True
20:31:36 <brian`> arithmetic [3,1,5,7,9]
20:31:36 <dolio> > let arithmetic = and . ap (zipWith (==)) tail . ap (zipWith (-)) tail in arithmetic [1,3,5,7,10]
20:31:37 <LoganCapaldo> gwern: he's a troll (bot?). He's saying the same nonsense verbatim in one of the other channels I'm in
20:31:37 <lambdabot>  False
20:31:49 <brian`> > arithmetic [3,1,5,7,9]
20:31:50 <lambdabot>   Not in scope: `arithmetic'
20:31:50 <gwern> LoganCapaldo: ah. perhaps he should be banned on principle
20:31:59 <brian`> it doesn't have to be ordered
20:32:01 <brian`> it could be
20:32:04 <brian`> [3,1,5,7,8]
20:32:10 <brian`> or [3,1,7,9]
20:32:11 <gwern> brian`: well, then you sort it first
20:32:12 <dolio> > let arithmetic = and . ap (zipWith (==)) tail . ap (zipWith (-)) tail . sort in arithmetic [3,1,5,7,9]
20:32:13 <lambdabot>  True
20:32:18 <dolio> > let arithmetic = and . ap (zipWith (==)) tail . ap (zipWith (-)) tail . sort in arithmetic [3,1,5,7,8]
20:32:18 <lambdabot>  False
20:32:21 <brian`> what if you want it to be O(n)
20:32:29 <brian`> so you cannot use any sorting algorithm
20:33:30 <gwern> that would be tricker. you'd need to proceed down the list once, keeping track of the first 'difference', and the number you're on and the next one, and what difference that is
20:33:46 <gwern> the first time the two differences collide, you bail out
20:34:39 <brian`> gwern, but for [3,1,5] differences will be [-2,4] they are different but 3,1,5 forms arithmetic sequence if you order them..
20:34:40 <gwern> easier to figure it out in an imperative context, I suspect. but laziness probably means folding '&&' into the bool output of the hypothetical recursive function might work...
20:35:52 <gwern> hm. personally, at that point I'd say screw it, there's no point in making my algorithm hideous, and throw a sort in anyway
20:36:59 <brian`> gwern, lol ok
20:37:32 <sw17ch> alright, lambdabot still thwarts my attempts to install him/her/it
20:37:43 <sw17ch> at the Setup.hs install stage... i get this:
20:37:51 <sw17ch> setup: LICENSE: copyFile: does not exist (No such file or directory)
20:38:00 <gwern> sw17ch: 'mv COPYING LICENSE'
20:38:13 <gwern> sw17ch: I'm working on lambdabot too, and that's one of the patches I haven't sent yet
20:38:27 * gwern is right now clearing up Hackage warnings
20:38:34 <trainignday1> does hot white girls pussy and ass taste like eggs?
20:38:40 <sw17ch> oh, marvelous
20:38:47 <sw17ch> i sense a bot..
20:38:53 <dolio> Cale: ping
20:39:03 <Cale> pong
20:39:08 --- mode: ChanServ set +o Cale
20:39:13 --- mode: Cale set +b *!*@CPE00012e15cab4-CM00194757ed42.cpe.net.cable.rogers.com
20:39:22 <sw17ch> merci beaucoup
20:39:22 --- mode: Cale set -o Cale
20:39:44 <sw17ch> gwern++
20:39:47 <sw17ch> i have it installed
20:39:48 <sw17ch> woopie
20:41:11 * gwern waits for the hackage upload
20:41:54 <gwern> can someone 'cabal install lambdabot' after a 'cabal update'?
20:41:56 <gwern> or see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lambdabot-4.1
20:41:57 <lambdabot> http://tinyurl.com/3c2rvg
20:42:12 <gwern> Cale: that request is also for you!
20:42:12 <sw17ch> gwern, since i'm doing this... sure!
20:43:05 <sw17ch> seems to be working
20:44:44 <gwern> @seen dons
20:44:44 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 6h 45m 37s ago.
20:44:50 <sw17ch> yes, installed and working
20:45:16 <gwern> @tell dons I'm sending you some lambdabot patches I added in order to get a sdist tarball for hackage; you can see the product here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lambdabot-4.1
20:45:16 <lambdabot> Consider it noted.
20:46:01 <gwern> sw17ch: the various functions are good?
20:46:34 <sw17ch> gwern: anything specific you want me to check?
20:46:39 <sw17ch> i'm a lambdabot newbie
20:46:49 <gwern> dunno. I use @hoogle fairly often, and @pl sometimes
20:47:22 <Cale> Try > foldr f z [1..5]
20:47:33 <sw17ch> i may have something setup wrong, but @hoogle tells me that a hoogle error occured
20:47:35 <Cale> and make sure that SimpleReflect is working
20:47:39 <sw17ch> occured
20:48:00 <Cale> also try  > describeSequence [1,1,2,3]
20:48:03 <gwern> lambdabot> > foldr f z [1..5] fd:7: hClose: resource vanished (Broken pipe)
20:48:27 <Cale> You have to run the build script in the lambdabot directory when installing it.
20:48:35 <sw17ch> > foldr (+1) 1 [1..5]
20:48:38 <lambdabot>   add an instance declaration for (Enum (b -> b))
20:48:44 <sw17ch> > foldr (1+) 1 [1..5]
20:48:44 <Cale> Also, it's important that lambdabot gets run from the directory in which it's installed.
20:48:44 <lambdabot>   add an instance declaration for (Enum (b -> b))
20:49:19 <yondalf> > foldr (+) 1 [1..5]
20:49:20 <sw17ch> ~/.cabal/bin $ ./lambdabot
20:49:21 <sw17ch> Initialising plugins ......................................sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "NAMES", msgParams = [""]}
20:49:21 <sw17ch> .................. done.
20:49:21 <sw17ch> lambdabot> 1 + 1
20:49:21 <sw17ch> Maybe you meant: . ? @ v
20:49:22 <lambdabot>  16
20:49:22 <sw17ch> lambdabot> 1
20:49:24 <sw17ch> Maybe you meant: . ? @ v
20:49:26 <sw17ch> lambdabot> > 1
20:49:28 <sw17ch>      Failed to load interface for `Control.Parallel':
20:49:30 <sw17ch>       Use -v to see a list of the files searched for.
20:49:42 <sw17ch> lambdabot> foldr (+) 1 [1..5]
20:49:42 <sw17ch> No match for "(+)".
20:49:42 <sw17ch> No match for "1".
20:49:42 <sw17ch> No match for "[1..5]".
20:49:47 <sw17ch> i think i'm doing it wrong
20:49:57 <Cale> mm, looks like parallel needs to be added to the Cabal deps
20:50:39 <gwern> strange. it built fine without parallel
20:51:03 <Cale> Not strange, it's compiling generated code every time you evaluate expressions.
20:51:19 <Cale> If you don't have the modules required for that, then that build will fail.
20:54:39 <gwern> lovely. ./build doesn't even bother with '--user'
20:55:09 <gwern> or with a basic "$@"...
20:55:31 <Cale> Well, lambdabot really isn't set up for hackage :)
20:55:53 <Cale> In fact, it's broken if you don't run it out of the lambdabot source directory.
20:56:00 <Cale> So something will likely have to be done about that.
20:56:02 <gwern> no kidding. I find it mildly amusing, since it was dons baby and he's one of hackage's proponents
20:56:37 <gwern> lambdabot> > 1 /tmp/Metl348237.o: unknown symbol `__stginit_bytestringzm0zi9zi0zi4_DataziByteString_'
20:56:40 <gwern> user error (resolvedObjs failed.)
20:56:43 <gwern> fun
20:57:27 <Cale> hmm
20:58:15 <Cale> ah
20:58:25 <Cale> you have the wrong bytestring, perhaps.
20:58:44 <gwern> 0.1 and 0.4 are both installed
20:58:49 <Cale> mm...
20:59:19 <gwern> I would guess from my yi experience that some library or other got linked against a wrong one
21:00:08 <wagle_home> yay!  no longer stuck on a deserted desert island netsplit fragment with 8 other people!
21:01:15 <Cale> gwern: I just removed .4 and rebuilt everything to avoid those problems.
21:02:38 <gwern> ack. my regexs were built against it
21:02:44 * gwern will return to this tomorrow
21:02:49 <gwern> good night all
21:21:17 <dons> yo gwern. i was just pushing patches. so is that lambdabot upload not in sync with the repo?
21:21:17 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
22:04:01 <vagif> Hello. How do i use functions from CGI library and TVars in the same function ?
22:07:37 <hpaste>  vagif pasted "CGI and TVars" at http://hpaste.org/5652
22:07:54 <dobblego> ?kind []
22:07:57 <lambdabot> * -> *
22:08:39 <vagif> dobblego: look at paste
22:08:57 <dobblego> woffor?
22:09:47 <vagif> dobblego: sorry, i thought you are answering me
22:09:54 <dobblego> nup
22:18:46 <Cale> :t atomically
22:18:54 <lambdabot> Not in scope: `atomically'
22:19:05 <Cale> :t Control.Concurrent.STM.atomically
22:19:06 <lambdabot> Couldn't find qualified module.
22:19:25 <Cale> :t Control.Monad.STM.atomically
22:19:26 <lambdabot> Couldn't find qualified module.
22:19:30 <Cale> huh
22:19:34 <Cale> anyway
22:19:41 <Cale> atomically :: STM a -> IO a
22:22:11 <rnorris> src/HAppS/DBMS/Index.hs:7:17:
22:22:11 <rnorris>     Could not find module `Data.Set':
22:22:11 <rnorris>       it is a member of package containers-0.1.0.1, which is hidden
22:22:26 <rnorris> hm
22:23:13 <Cale> rnorris: add containers to the list of dependencies in the .cabal file
22:24:39 <rnorris> sorry, someone replied to me but i missed it .. my client went all wombly on me
22:25:27 <scook0_> rnorris: add containers to the list of dependencies in the .cabal file
22:28:55 <rnorris> odd .. lots of stuff missing from the HAppS .cabal file
22:29:01 <rnorris> i figured it would be up to date
22:29:28 <RayNbow> aaaaaaaargh... :X http://www.latrobe.edu.au/philosophy/phimvt/joy/j08cnt.html <-- unreadable because of the terrible margins...
22:29:31 <lambdabot> Title: Joy compared with other functional languages
22:32:14 <Cale> RayNbow: Better than having the text squished into a tiny, non-resizable column :)
22:32:28 <bos> someone send jerzy and richard back to their respective caves.
22:32:37 <Cale> bos: hm?
22:32:51 <dolio> Floating point battle.
22:32:58 <bos> oh, the two generators of most heat and least light on haskell-cafe.
22:34:21 <bos> their cantankerous-old-fart routine is a bit at odds with the usual atmosphere of the list.
22:53:40 <adu> I'm getting a wierd error
22:55:03 <adu> Couldn't match expected type `MVar Bool' against inferred type `IO (MVar Bool)'
22:55:26 <shachaf> adu: What's weird about it?
22:55:39 <adu> and up until now, I though I was doing pretty good with the IO monad, but apparently, I don't understand
22:55:59 <adu> I have no idea how the "IO" got on the inferred type
22:57:02 <shachaf> adu: Well, where are you getting it from?
22:58:30 <hpaste>  adu pasted "opengl stuff" at http://hpaste.org/5653
22:59:48 <shachaf> adu: Well, I meant for you to tell me, not @paste, in this case. :-)
22:59:54 <shachaf> adu: (Why do you use do so often?)
23:00:00 <adu> shachaf: the error is raised while evaluating "startFull" in the keyboardMouseCallback
23:00:16 <adu> shachaf: because I suck at functions
23:00:58 <shachaf> adu: Do you know what "do" does?
23:01:28 <adu> shachaf: vaugly, I know its shorthand for "x >>= \v => y >>= ..."
23:01:45 <shachaf> adu: What is "do fullscreen" shorthand for?
23:02:01 <adu> fullscreen
23:02:13 <adu> wait, no (return fullscreen)?
23:02:30 <adu> I don't know how I made it this far without understanding do
23:02:39 <shachaf> adu: You don't need to understand do.
23:02:50 <shachaf> adu: You need to understand what it translates to. :-)
23:02:56 <adu> heh
23:03:05 <adu> ok so far I've been able to gather this
23:03:49 <adu> whever there is a function of the form (a -> IO b) you can sort of ignore the IO and when you "do x <- f" when f is of that type, then (x :: b) somehow
23:04:08 <adu> but I still don't really understand why the "IO" goes away from the type
23:04:15 <shachaf> adu: do is no good for understanding.
23:04:53 * Nafai patiently waits for gtk2hs to build
23:05:02 <adu> so should i forget 'do' and learn '>>=' instead?
23:05:38 <shachaf> adu: Well, more than (>>=), but yes, I think so.
23:06:09 <adu> whats wierd is that I've been able to grasp arrows and the ST monad, but IO still confuses me
23:09:12 <dons> thetallguy: there you go, http://reddit.com/r/programming/info/68p9z/details
23:09:48 <Nafai> w00t.  Leksah is compiling!
23:11:43 <dobblego> I have never seen you're misused in place of your, only ever the other way around
23:11:59 <dmwit> It's longer.
23:12:02 <adu> I've been rewinding my mind for awhile now
23:12:22 <dobblego> "...you're looking at Haskell code, you're predictions about..."
23:12:45 <shachaf> dobblego: I've seen both.
23:12:51 <shachaf> dobblego: Unfortunately. :-(
23:12:54 <dmwit> Maybe looking at Haskell turns you into predictions.
23:13:22 <dobblego> I wonder what about? (...)
23:13:55 <Nafai> Yay, it's working
23:17:06 <Nafai> A little odd, but it works
23:39:09 <dmwit> Whooo boy, my brother just asked me what my favorite math joke was. =)
23:41:17 <sarehu> gangstas always check for negative numbers before computing square roots
23:41:40 <sarehu> why?  to keep it real  :-3
23:41:47 <dmwit> hahaha
23:45:52 <shachaf> Does anyone know if Greg Meredith is in here?
23:46:41 <Cale> sarehu: Betta watch your back when I'm packin a nine, I'll pump you full of holes like the rational line.
23:47:39 <sarehu> Cale: why was six afraid of twenty?
23:47:53 <Cale> Why?
23:48:04 <sarehu> Because twenty-ate four hundred ninety-six.
