00:02:53 <dolio> That only corresponds to list keys.
00:03:00 <dolio> Not, say, binary tree keys.
00:10:28 <dolio> I guess, generally speaking, if T takes algebraic types to tries with keys of that type...
00:10:48 <dolio> And a data type is the fixpoint of a shape functor F.
00:10:59 <dolio> Then the trie of that data type is the fixpoint of TF.
00:11:10 <dolio> Or something like that.
00:12:23 <Mr_Awesome> you lost me :)
00:12:39 <dolio> :)
00:12:42 <dolio> If you take list.
00:12:59 <dolio> List a = 1 + a * (List a)
00:13:13 <dolio> The shape functor for lists is F X = 1 + a*X.
00:13:25 <Mr_Awesome> okay
00:14:42 <dolio> TF X = T(1 + a*X) = T1 * T(a*X) = T1 * Ta(TX).
00:14:50 <dolio> I suppose that's not exactly correct.
00:14:59 <quicksilver> It's quite interesting to write
00:15:30 <quicksilver> data ProtoList f a = Nil | Cons a (f a)
00:15:51 <quicksilver> then you have : data List a = ProtoList List a
00:16:04 <quicksilver> but you can do celver stuff by slipping over functors inbetween
00:16:19 <quicksilver> and, actually things which look like functors but aren't, like MVar and IORef.
00:16:52 <wagle_home> i have three sons, all named Fred
00:17:19 <wagle_home> (dont mind me, i do the same)
00:18:36 <Mr_Awesome> well, i think my rather specific implementation of Trie will do for now. enlightening talk though, thanks :)
00:18:52 <wagle_home> or is ProtoList not the name of a constructor in the second case? (data List a = ProtoList List a)
00:18:55 <quicksilver> Actually, it's a bit cleverer to start with data ProtoList f a = Cons a (f a)
00:19:21 <quicksilver> then you get streams most simply, as data Stream a = ProtoList Stream a
00:19:35 <quicksilver> but you get Lists by sticking in a Maybe.
00:20:14 <quicksilver> and you can get weirde branching stuff by putting in an Either
00:20:44 <wagle_home> or is ProtoList not the name of a constructor in the second case? (data List a = ProtoList List a)
00:20:48 <dolio> Wouldn't that be a non-empty list?
00:25:24 <quicksilver> wagle_home: yes, I should have named the constructor.
00:26:16 <quicksilver> dolio: yes, I'm not quite sure the best place to tie the not :)
00:27:05 <wagle_home> quicksilver, not nitpicking, trying to understand..  seemed likely i didnt know something
00:58:47 <mcnster> hi.  i'm having a new problem related to a fatal exception:  "thread blocked indefinitely"...
00:59:16 <mcnster> what if i WANT a thread to block indefinitely?
01:00:56 <quicksilver> why would you want that?
01:01:04 <quicksilver> why not just terminate it?
01:01:36 <mcnster> i want it to block (indefinitely) until it receives an exception via throwDyn
01:02:33 <mcnster> does that make any sense?
01:02:55 <glguy> instead of waiting for the exception to be thrown directly to the thread
01:03:05 <quicksilver> mcnster: yes, but it's not how I'd do it.
01:03:12 <glguy> maybe with an mvar?
01:03:13 <quicksilver> mcnster: why not make it block on an MVar?
01:03:25 <quicksilver> mcnster: and instead of throwDyn'ing, put something in the MVar.
01:03:27 <quicksilver> (that's what they're for)
01:04:10 <mcnster> hmmm... that could work too, i s'pose
01:04:44 <glguy> throwing exceptions at threads is generally a bad idea
01:05:05 <mcnster> glguy, how so?
01:05:22 <glguy> easy way to get an inconsistent state
01:05:40 <glguy> roughly equivalent to using error or undefined in your program
01:05:46 <quicksilver> as a general rule, exceptions are for exceptional circumstances :)
01:05:58 <quicksilver> MVars are the bread-and-butter concurrency tool.
01:06:03 <quicksilver> And other things based on MVars.
01:06:13 <quicksilver> and TVars for Really Clever Stuff (TM)
01:07:11 <mcnster> maybe then i'm using a hammer when i should be using a screwdriver... i just thought throwDyn was really kool :-)
01:07:32 <glguy> Dynamic is a last resort :)
01:08:20 <glguy> night!
01:08:27 <mcnster> glguy, roger that
01:10:35 <mcnster> thanks quicksilver.  back to it.
01:12:08 <ac> heh. So Phillip Wadler wears a Superman style shirt with a lambda on it instead of an 'S'. Where do I get such a shirt?
01:12:36 <Syzygy-> ac: Have it custom-printed.
01:12:45 * Syzygy- has at least one custom print-shop in his city...
01:13:21 <ac> I just heard in a talk that type classes are ad-hoc polymorphism, not parametric polymorphism
01:14:02 <ac> I thought Haskell had parametric polymorphism
01:14:11 <faxathisia> yeah it does
01:14:13 <faxathisia> :t (:)
01:14:18 <lambdabot> forall a. a -> [a] -> [a]
01:14:46 <faxathisia> you get ad-hoc as well though
01:14:51 <Syzygy-> However, the parametric polymorphism is not what a typeclass gives - it's what the forall a. TypeDeclaration gives.
01:14:51 <ac> so type classes are just a nice bit of adhocism thrown in
01:15:04 <faxathisia> not sure about nice .. but yeah :)
01:15:14 <faxathisia> well I guess it is good
01:15:29 <ac> faxathisia: are you not a proponent of type classes?
01:16:04 <faxathisia> all the ones in the std lib are good ... all(most) the ones I've seen outside are just hacks to get varags or whatever
01:16:33 <ac> interesting
01:17:03 <quicksilver> typeclasses for overloading are a nice solution to overloading.
01:17:08 <quicksilver> Nicer than C++'s, say.
01:17:16 <quicksilver> or javas.
01:17:42 <quicksilver> typeclasses for modelling OO methods are a big fuglier, in many cases. In my opinion.
01:17:59 <hpaste>  dolio pasted "generalized tries" at http://hpaste.org/6005
01:20:28 <ac> so is overloading the _only_ thing Haskell's type classes accomplish?
01:20:51 <quicksilver> no
01:21:00 <quicksilver> but it's the thing they accomplish best, in my opinion ;)
01:21:16 <quicksilver> what they actually *are* is type-inference-triggered-dispatch.
01:21:24 <quicksilver> which is quite a powerful notion
01:21:28 <quicksilver> (just look at oleg's stuff)
01:21:43 <ac> where?
01:22:03 <quicksilver> http://okmij.org/ftp/Haskell/types.html
01:22:03 <lambdabot> Title: Haskell Programming: Types
01:23:27 <ac> Hm. Well I'm going to go watch anime instead. But I will check that out
01:23:34 <hpaste>  dolio annotated "generalized tries" with "Char instance" at http://hpaste.org/6005#a1
01:27:37 <mcnster> quicksilver, another q if i may:  how do i guarantee that a forkIO'd thread runs without running into "thread blocked indefinitely"?
01:30:01 <quicksilver> well that's not normally a probelm :)
01:30:17 <quicksilver> The only way I was aware you could do that is blocking on an MVar which was unreachable.
01:30:22 <quicksilver> but I"m not sure if you found a different way?
01:31:12 <dolio> Incidentally, those tries are something I haven't yet figured out how to build in Agda. It doesn't like the list tries, because it uses the trie type inductively in a 'negative position.'
01:31:34 <mcnster> main = do { t <- newEmptyMVar; forkIO (threadA t); takeMVar t }
01:31:41 <quicksilver> mcnster: yup.
01:32:07 <quicksilver> mcnster: that's fine, unless threadA dies / discards its copy of "t"
01:32:09 <mcnster> that gives "thread blocked indefinitely", even though the mvar is put in threadA
01:32:24 <quicksilver> mcnster: well if it can see threadA isn't using "t"
01:32:28 <quicksilver> it will get GC'ed
01:33:08 <mcnster> threadA t = do { ...; putMVar t () }
01:33:34 <mcnster> am i missing something?
01:33:45 <quicksilver> odd. that looks fine. hpaste the whole program?
01:35:36 <mcnster> whups, as written to you, i get no exception.  let me try something else...
01:35:56 <Hobbsee_> Gentlemen, ircopers think spamming is ok all of a sudden. ##ubuntu-uncensored is spamming all over the network. pass it on :/
01:36:07 <lnostdal> Hobbsee_, the only one i see spamming is you
01:36:59 <resiak> hrm, is there a straightforward way to be notified when a finalizer runs?
01:45:27 <mcnster> quicksilver, a better q might be:  can a thread block pending an event that may (never) come without triggering a "thread blocked indefinitely" exception?
01:51:18 <quicksilver> mcnster: yes, as long as that MVar its waiting on doesn't go out of scope.
01:51:33 <quicksilver> mcnster: if it goes out of scope then the GC will notice, and the exception occurs.
01:51:44 <quicksilver> mcnster: A question for you, though: why do you care?
01:52:02 <quicksilver> mcnster: if the thread is waiting on an MVar which is never going to unblock, the GC kills the thread and then GCs the thread.
01:52:07 <quicksilver> isn't that reasonable behaviour?
01:53:29 <hpaste>  mcnster pasted "this listens twice then excepts" at http://hpaste.org/6006
01:54:00 <mcnster> let me show you something
01:54:28 <quicksilver> yup
01:54:36 <quicksilver> because then it can see that one thread is waiting on a chan
01:54:46 <quicksilver> and the only possible writer to that chan is blocking on an mvar
01:55:01 <quicksilver> and the only possible writer to that mvar is that first thread
01:55:10 <quicksilver> this is quite clever stuff, you know :)
01:55:22 <quicksilver> most RTS's can't detect deadlocks.
01:56:34 <mcnster> hehe.  its clever, sure.  but does it render impossible a thread waiting for an event that may not be ready?
01:56:49 <quicksilver> no.
01:57:08 <quicksilver> it only makes it impossible to wait for an event that will *definitely* *never* occur.
01:57:29 <mcnster> ahso
01:59:34 <mcnster> well that is certainly cool.  :)  thanks for the clarity
02:03:38 <dcoutts> @tell dons so SPJ fixed the derived Ord issue quickly :-)
02:03:38 <lambdabot> Consider it noted.
02:04:27 <ac> quicksilver: that implementation of a variadic function makes no sense to me
02:05:04 <ac> Perhaps I should just continue believing it's not possible
02:07:00 <quicksilver> ac: which one?
02:07:09 <quicksilver> ac: oleg's ?
02:08:27 <ac> yeah
02:08:54 <quicksilver> > printf "%s what you like, the %s is %s" "Believe" "truth" "out there" :: String
02:08:54 <ac> binary type arithmetic?
02:08:55 <lambdabot>  "Believe what you like, the truth is out there"
02:09:20 <ac> I thought printf was implemented with TH
02:09:56 <ac> I guess then you'd have to write "$(printf ...)"
02:14:14 <quicksilver> nope
02:14:19 <quicksilver> printf is just nice little type classes.
02:15:02 <quicksilver> it's really not very hard, in a simple case.
02:15:23 <quicksilver> you make the function return a typeclass (Foo a) => a
02:15:32 <quicksilver> one instance of Foo is your "basic result". String in the case of printf.
02:15:48 <quicksilver> then you also make Foo a => (String -> a) an instance
02:15:53 <quicksilver> so functions are instances too.
02:15:58 <ac> oh I get it
02:16:17 <resiak> > print "%s" "Yo" :: IO String
02:16:18 <lambdabot>  Couldn't match expected type `[Char] -> IO String'
02:16:18 <ac> ah you could do that very simply for n arguments
02:16:20 <resiak> > printf "%s" "Yo" :: IO String
02:16:22 <lambdabot>  <IO [Char]>
02:16:30 <ac> where n is defined by how many instances you write
02:16:34 <resiak> hrm, i didn't know you could coerce it to String
02:16:41 <quicksilver> you don't need n instances.
02:16:54 <quicksilver> Foo a => (String -> a) is universal.
02:17:05 <quicksilver> Because of that, (String -> String) is a Foo.
02:17:18 <quicksilver> but then, since String -> String is a Foo, String -> (String -> String) is a Foo.
02:17:22 <quicksilver> and so on.
02:17:25 <quicksilver> that instance scheme gives you n-ary.
02:17:49 <ac> ok
02:17:54 <quicksilver> printf generalises it slightly by having more than one "base type". It's not just String, but String, IO String and IO ().
02:18:02 <quicksilver> that doesn't change the fundamental idea though.
02:18:09 <ac> why not use something like macros instead of type classes and type hackery?
02:18:19 <quicksilver> because haskell doesn't have macros?
02:20:05 <resiak> hrm, Maybe String would be handy
02:20:15 <resiak> although i suppose if your format string is wrong, you've already lost.
02:20:38 <faxathisia> > printf "%f" "wrong" :: String
02:20:39 <lambdabot>  Exception: Printf.printf: bad argument
02:20:55 <scook0> it's annoying that you can't really compose printf, though
02:21:09 <faxathisia> check out http://www.lri.fr/~sozeau/repos/coq/misc/shiftreset/GenuineShiftReset.html
02:21:10 <lambdabot> Title: GenuineShiftReset, http://tinyurl.com/2y2u4x
02:21:52 <quicksilver> scook0: well really printf is a bit shitty.
02:22:00 <quicksilver> scook0: btu it remains an interesting example of what you can do.
02:22:06 <quicksilver> I never use it in real programs.
02:22:18 <scook0> I've used it for formatting numbers
02:22:27 <scook0> and for some simple string interpolation
02:23:28 <scook0> normally I'm not a fan of crazy typeclass hacks in "real" code, but printf and I are on speaking terms at least
02:23:52 <scook0> as I'm not aware of a better way to do number formatting
02:23:56 <ndm> scook0: as crazy type class hacks, printf is barely even crazy
02:24:05 <ndm> scook0: take a look at the Numerics module
02:24:05 <wagle_home> > printf "%x\n" (\x -> x)
02:24:06 <lambdabot>   add an instance declaration for (PrintfArg (t -> t))
02:24:16 <wagle_home> 8(
02:24:29 <scook0> I call it "crazy" only because it lacks certain properties of "normal" functions, e.g. easy composition
02:24:57 <scook0> but it only registers a few milliolegs :)
02:26:19 <quicksilver> scook0: showEFloat showFFloat showGFloat
02:26:30 <quicksilver> just FYI.
02:26:35 <ac> :t printf
02:26:37 <lambdabot> forall r. (PrintfType r) => String -> r
02:26:55 <wagle_home> o.O
02:27:49 <wagle_home> > printf "<%d>\n" 2
02:27:49 <lambdabot>  Add a type signature
02:28:02 <wagle_home> > printf "<%d>\n" (2 :: Int)
02:28:03 <lambdabot>  Add a type signature
02:28:06 <scook0> quicksilver: ta, I seem to have picked up a few useful functions from you :)
02:28:27 <wagle_home> > printf "<%d>\n" (2 :: Int) :: String
02:28:27 <lambdabot>  "<2>\n"
02:28:51 <mib_awm94hve> letterSplit “Hello World”  (“HW”,”ello orld”) i am trying to create a foldr function that separates uppercase val from lower
02:29:03 <mib_awm94hve> getting errors please help
02:30:04 <scook0> @paste
02:30:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:30:55 <wagle_home> (1) What's letterSplit "" in terms of foldr?
02:31:19 <faxathisia> > foldr (\c (x,y) -> if isUpper c then (c:x,y) else (x,c:y)) ("","") "Hello, World"
02:31:20 <lambdabot>  ("HW","ello, orld")
02:31:24 <scook0> I don't think you can define letterSplit purely in terms of foldr
02:31:33 <shteou> Hey.
02:31:36 <faxathisia> I think you can scook
02:31:37 <scook0> heh, unless I'm wrong
02:31:47 <wagle_home> uh, lets not do his homework for him, eh?
02:31:53 <scook0> faxathisia: constructive proof is the best kind of proof!
02:32:10 <faxathisia> I'm sure it could be done better though
02:32:20 <hpaste>  dolio annotated "generalized tries" with "General fixpoint instance" at http://hpaste.org/6005#a2
02:33:03 <mib_awm94hve> i wanna use a fold function to sum a binary tree sumTree tree = foldTree (+) 0 tree
02:33:34 <scook0> that looks like a good start, then
02:33:54 <scook0> or is the idea that you have to write foldTree?
02:34:13 <faxathisia> I don't think it's a good start :P
02:34:16 <faxathisia> 0 + 0 = 0
02:34:30 <faxathisia> What's the tree data type?
02:34:31 <mib_awm94hve> yeah i have to write foldtree
02:34:41 <scook0> hey, I didn't say it was perfect
02:34:54 <faxathisia> mib_awm94: What is the definition of the tree type?
02:34:56 <scook0> well, folds are not that hard to write
02:35:04 <scook0> the key is to let the datatype definition guide you
02:35:47 <scook0> each argument of the fold "replaces" one of the constructors
02:35:53 <mib_awm94hve> teach never gave nay, just said attempt if u can
02:36:06 <scook0> and datatype-recursion is replaced with function-call-recursion
02:36:13 <faxathisia> mib_awm94hve: So then you should define a tree data type
02:36:20 <hpaste>  dolio annotated "generalized tries" with "[a] -> List a" at http://hpaste.org/6005#a3
02:37:06 <mib_awm94hve> yeah
02:37:29 <mib_awm94hve> more like a binary tree
02:37:52 <faxathisia> mib_awm94hve: make like
02:37:57 <faxathisia> data Tree ... = .. ?
02:39:22 * dolio decides he should quite screwing around with shape functors/fixpoints and go to bed.
02:40:02 <mib_awm94hve> oh ok
02:41:22 <mib_awm94hve> data BinaryTree a = Empty |
02:41:43 <mib_awm94hve> Node ( BinaryTree a ) a (BinaryTree a )
02:41:52 <faxathisia> alright cool
02:42:04 <faxathisia> We can derive a fold from that pretty easy just like scook says :)
02:42:42 <matthew-_> gosh, such an overwhelming response to my -cafe post...
02:44:08 <scook0> so your fold function needs to take one argument for each of the tree type's constructors
02:44:15 <scook0> plus an extra argument for the actual tree
02:44:27 <LongKat> heh! haskell is so useless
02:44:33 <matthew-_> LongKat: lol.
02:46:02 <faxathisia> mib_awm94hve: The result type shall be.. 'b' ok
02:46:27 <faxathisia> mib_awm94hve: so it's gonna take... <something corresponding to Empty> -> <something for Node> -> BinaryTree a -> b -- yeah?
02:46:43 <faxathisia> :t foldr
02:46:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:47:19 <faxathisia> mib_awm94hve: so in foldr .. you can see what happens for (:) and [], similar here, we get b -> (b -> a -> b -> b) -> (BinaryTree a) -> b -- as the type
02:47:38 <faxathisia> @src foldr
02:47:38 <lambdabot> foldr f z []     = z
02:47:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:47:58 <faxathisia> so in this case, it's going to be
02:47:58 <faxathisia> foldTree k _ Empty = k
02:48:29 <faxathisia> mib_awm94hve: Can you write the case for Node?
02:48:31 <wagle_home> faxathisia, wrong order
02:48:41 <faxathisia> (it will have two calls to foldTree in it)
02:48:47 <wagle_home> <mib_awm94hve> i wanna use a fold function to sum a binary tree sumTree tree = foldTree (+) 0 tree
02:49:42 <mib_awm94hve> nope i can't
02:50:00 <faxathisia> mib_awm94hve: well look at the foldr one
02:50:06 <wagle_home> foldTree _ k Empty = k
02:50:10 <faxathisia> so it just calls f with the right parameters
02:50:17 <faxathisia> you have
02:50:17 <faxathisia> foldTree k f (Node left m right) =
02:50:29 <LongKat> it's so useless
02:50:34 <faxathisia> now left and right are both binary trees..
02:50:36 <faxathisia> m is of type a
02:50:48 <faxathisia> and you want to put all that into b -> a -> b -> b, ok?
02:52:00 <faxathisia> mib_awm94hve: Still stuck?
02:54:37 <mib_awm94hve> i am grasping slowly
02:54:42 <scook0> faxathisia: a similar approach is to write an identity function, and generalize that to a fold
02:55:05 <faxathisia> mib_awm94hve: sorry, I've gotta run to class.. I'll paste what I have and you can check it out if you give up :P
02:55:08 <hpaste>  faxathisia pasted "foldTree" at http://hpaste.org/6007
02:55:29 <faxathisia> scook0: I don't know that approach
02:55:38 <faxathisia> It seems like a good idea though
02:55:46 <quicksilver> identityTree t = t -- doesn't work if you cheat though :)
02:55:47 <scook0> I only learned it recently
02:55:56 <faxathisia> one thing to note is there is a unique fold for every data type
02:55:57 <scook0> it gives the same function in the end
02:56:19 <faxathisia> and it comes direct from the type def.
02:56:34 <wagle_home> faxathisia,  sumTree tree = foldTree (+) 0 tree
02:56:38 <scook0> id [] = [] ; id (x:xs) = (x:xs)
02:56:42 <quicksilver> according to one particularly narrow definition of fold, yes.
02:57:35 <scook0> I can has catamorphism?
02:58:46 <scook0> foldr (~~) z [] = z ; foldr (~~) z (x:xs) = (x ~~ xs)
02:59:27 <scook0> I think I got the generalize-from-identity approach from "bananas in space"
02:59:33 <mib_awm94hve> hey guys sorry i gave u the wrong info
02:59:39 <mib_awm94hve> it should be data Tree a = Node a [Tree a] deriving Show
03:00:09 <faxathisia> mib_awm94hve: Analyize the proccees and try to derive it yourself :P
03:00:19 <faxathisia> mib_awm94hve: It should be pretty simple.. anyway later
03:01:06 <mib_awm94hve> ok
03:02:03 <scook0> the fold is going to be a little bit different
03:02:10 <scook0> because this tree only has one constructor
03:02:15 <scook0> but it has a list of sub-trees
03:02:46 <scook0> so we'll have:
03:03:02 <scook0> foldTree f (Node x children) = ...
03:03:19 <LongKat> heh! haskell is so useless
03:04:44 <mib_awm94hve> sumTree  = foldIntTree (\n m p -> n + m + p) 0
03:05:30 --- mode: ChanServ set +o quicksilver
03:05:46 --- mode: quicksilver set +b *!*n=l@*.nr.ip.pt
03:05:46 --- kick: LongKat was kicked by quicksilver (heh! LongKat is so useless)
03:06:25 <scook0> mib_awm94hve: off the top of my head, that looks right (for the old definition of tree)
03:06:56 <scook0> or is this part of the problem spec?
03:07:39 <cin> if i want to get a [Word8] from a [Char], what should i use?
03:07:57 <scook0> cin: do you want character-encoding?
03:08:09 <scook0> or just straight truncation?
03:08:35 <scook0> (bearing in mind that a Char is a Unicode code-point)
03:08:41 <cin> scook0: well i have a string that i want to hash with md5
03:08:48 <mib_awm94hve> don't know what u talking about
03:08:56 <ndm> has anyone else spotted the spelling mistake in nofib? bernouilli has 1 i too many
03:09:05 <mib_awm94hve> the one i gave seems to be ok
03:09:30 <cin> scook0: should i use utf8-string's String -> [Word8] function?
03:09:41 <quicksilver> probably
03:09:49 <quicksilver> if you care about non-ASCII chars at least
03:09:55 <scook0> cin: that would be the best option, I think
03:10:09 <scook0> (given that I know nothing about your problem)
03:10:10 <cin> oki doki. i'm just hashing passwords for a database
03:10:33 <scook0> yeah, encode as UTF-8
03:10:51 <scook0> then hash
03:11:02 <cin> righteo
03:11:12 <cin> thanks
03:11:23 <scook0> oh, how are you getting these strings?
03:11:59 <scook0> (not that it matters if you just need a consistent hash function)
03:13:11 <cin> from a web browser, i suppose. using fastcgi
03:13:22 <scook0> if the strings are in the all-too-common "UTF-8 masquerading as Haskell strings" format, they'll essentially end up having been encoded twice
03:13:41 <cin> that is confusing
03:13:55 <scook0> which won't be a huge problem if you always use the same hashing code and the same source of input, but could cause problems later
03:14:24 <scook0> are you using the built-in Haskell I/O functions?
03:14:59 <cin> i get the string from Network.CGI's getInput, i believe it gets its information from getArgs
03:15:26 <cin> i suppose that is built-in I/O
03:15:54 <scook0> there won't be any difference for all-ASCII input
03:16:20 <scook0> and for non-ASCII characters, your hashing will still work, it just won't be doing exactly what you would expect
03:17:05 <cin> indeed. if it's just one-way it shouldn't make a difference?
03:17:19 <cin> scook0: ah, unless of course i do change the encoding later
03:17:50 <scook0> cin: it just means that if you try to re-implement the same hashing algorithm in a different language/framework/whatever, you might get different results
03:18:47 <scook0> as I said, you can just use the encode function and everything will work
03:19:11 <cin> scook0: i could probably conduct a simple test when switching frameworks
03:19:14 <scook0> it's only if you care about being pedantic and/or interoperable
03:19:27 <cin> scook0: ie what the old framework encodes some list of strings to, and what the new one does, and compare?
03:19:51 <cin> scook0: (then i'd know if the encodings were incompatible)
03:20:11 <scook0> yeah, if you have a "test" string, with non-ASCII chars, and hash that
03:20:57 <cin> ghc-6.8.2: panic! (the 'impossible' happened)
03:20:57 <cin>   (GHC version 6.8.2 for i386-unknown-linux):
03:20:57 <cin>         RegAllocLinear.getStackSlotFor: out of stack slots
03:21:04 <scook0> yikes
03:21:06 <cin> that happened while building the Crypto package
03:21:08 <cin> ho, ho, ho
03:21:34 <scook0> this is with official 6.8.2?
03:21:44 <cin> aye
03:22:04 <scook0> might be a genuine bug
03:22:06 <cin> the generic linux build ...
03:22:25 <scook0> looks like something wonky in the code-generator
03:22:33 <scook0> does it work if you use -fvia-C ?
03:22:52 <cin> one sec
03:23:43 <resiak> hrm, i can't find anything wrapping statfs(2).  Am I missing something?
03:24:41 <scook0> resiak: shouldn't be that hard to FFI it yourself, if it comes to that
03:24:48 <resiak> scook0: sure
03:25:17 <cin> scook0: compiling 4 of 4.. kind of taking a while
03:25:19 <scook0> it's an obscure-enough call that I can imagine no binding existing
03:25:51 <cin> scook0: ah, it linked
03:26:17 <cin> scook0: if that's via c, via what does it usuallly do, and what is it doing?
03:26:34 <scook0> cin: I believe that 6.8.1+ use -fasm by default
03:26:41 <cin> scook0: Crypto has built now. but i'm curious
03:26:52 <resiak> scook0: sure.
03:26:54 <cin> scook0: ah. is that unstable or something?
03:26:57 <scook0> i.e. produce native code directly, rather than feeding C to gcc
03:27:08 <scook0> pretty sure it's supposed to be stable
03:27:19 <scook0> I'd consider filing a bug report
03:27:27 <scook0> maybe a mailing list post
03:29:00 <cin> i'll look into it when i've got my password hashing working
03:29:38 <wagle_home> resiak, i get a bunch of google hits for ghc statfs, but nothing in the sources (of course)
03:49:29 <wvd> hello
03:50:27 <Vq^> hello wvd
03:50:54 <smg> mh
03:51:12 <smg> whre can i get regex support in haskell hoogle doesn't pop anything up
03:51:30 <cin> Text.Regex
03:51:40 <cin> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-compat/Text-Regex.html
03:51:41 <lambdabot> http://tinyurl.com/2ub2m7
03:51:53 <cin> there are other regex kinds on hackage, too
03:52:31 <smg> k
03:52:42 <smg> if i use this can i then use regex in case of for example?
03:53:39 <smg> Text.Regex.PCRE <--
03:54:17 <cin> well matchRegex for instance returns Maybe [String]
03:54:19 <smg> how would i install Text.Regex.PCRE?
03:54:22 <cin> you can use case with that
03:54:35 <cin> oh, i dunno. haven't used that
03:54:44 <cin> is it on hackage?
03:54:46 <smg> yes
03:54:59 <cin> should be able to just download the .tar.gz
03:55:13 <cin> runhaskell Setup configure; runhaskell Setup build;
03:55:17 <cin> etc
03:55:22 <smg> not with cabal?
03:55:23 <Vq^> smg: what are you using regex for?
03:55:44 <scook0> smg: that *is* using cabal
03:55:51 <scook0> unless you're talking about cabal-install
03:56:50 <smg> Vq^: atm for nothing :]
03:57:36 <quicksilver> the standard Text.Regex is good enough for many purposes.
03:57:38 <Vq^> smg: ah, youre just researching
03:57:42 <quicksilver> I don't use them very often myself.
03:57:45 --- mode: quicksilver set -o quicksilver
03:58:48 <Vq^> they are usefull if you have an application that offers regex matching/searching
03:58:58 <Vq^> otherwise i tend to go for parsec
03:59:26 <smg> Vq^: yes exactly :)
04:02:23 <quicksilver> parsec--
04:02:30 <quicksilver> but parser combinators, yes.
04:02:55 <Vq^> parsec might not be perfect, but it's quite well documented
04:03:54 <Vq^> are there any applicative parsing libraries?
04:04:24 <resiak> wagle_home: ditto
04:04:46 <quicksilver> parsec has a decent manual, but no haddock.
04:04:51 <quicksilver> in some ways I'd rather have haddock.
04:05:21 <quicksilver> Although admittedly you can guess most of parsec from the names + types.
04:06:22 <earthy> Vq^: there are.
04:06:53 <quicksilver> applicative parsing means you have to be context-free
04:06:57 <earthy> Vq^: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uulib-0.9.5
04:06:58 <lambdabot> http://tinyurl.com/2g3jq5
04:07:03 <quicksilver> or at least do the contextual step in a later phase
04:07:04 <quicksilver> right?
04:07:13 <earthy> the UU.Parsing lib is applicative
04:07:23 <earthy> quicksilver: right
04:07:52 <earthy> that is: *almost* right. :)
04:08:01 <earthy> there are ways around it, but they're slightly ugly
04:08:13 <quicksilver> I suspect in most common cases of context you can parse a slightly broader grammar and then have a second syntax check afterwards.
04:08:21 <earthy> yah
04:08:31 <quicksilver> I can imagine applicative style could make things much nicer looking.
04:09:04 <earthy> it does
04:09:17 <earthy> I'd have to ponder Doaitse's latest results a bit though
04:09:35 <earthy> for I think he's cracked the context part while still allowing you to combine parsers applicatively
04:10:52 <earthy> (the ways I've used around are somewhat ugly, doaitse's method is slightly less so)
04:14:13 <Vq^> earthy: thanks for the tip
04:14:32 <earthy> see also the LERNET 2008 summerschool lecture notes.
04:14:50 <earthy> available from http://www.fing.edu.uy/inco/eventos/lernet2008/
04:14:51 <lambdabot> Title: LERNET 2008
04:16:38 <Gilly> Is there a function that takes a list of elements, a function and returns the first element for which the function is true?
04:17:14 <therp> gilly: probably combine head with filter?
04:17:55 <Gilly> therp: hmm probably yes, i assume lazy evaluation will take care it won't filter the whole thing :)
04:18:01 <Saizan> ?type find
04:18:01 <therp> gilly: correct :)
04:18:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
04:18:07 <jaas> @src find
04:18:07 <lambdabot> find p          = listToMaybe . filter p
04:18:18 <Gilly> oh heh, find it is, thanks
04:19:40 <smg> @src lcm
04:19:40 <lambdabot> lcm _ 0     =  0
04:19:40 <lambdabot> lcm 0 _     =  0
04:19:40 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
04:20:04 <Gilly> how about counting elements that fulfil some condition? just filter and length or is there a builtin combination for this too?
04:26:44 <hallongrottan> kok
04:26:49 <Vq^> Gilly: combining
04:26:52 <byorgey> Gilly: filter and length is pretty standard.  if it's something you do a lot, you could easily write your own in terms of filter and length.
04:29:09 <Gilly> ok thanks
04:30:19 <quicksilver> One of my favourite effects of lazy evaluation is you can combine takeWhile and take
04:30:27 <quicksilver> take 10 . takeWhile (<20)
04:30:35 <quicksilver> takes all items under 20, but at most 10.
04:30:37 <quicksilver> efficiently.
04:30:45 <quicksilver> in an imperative language you need a clumsy loop for that.
04:31:11 <quicksilver> in a strict functional language you need a special custom recursion.
04:31:13 <Vq^> count p = length . filter p
04:31:36 <quicksilver> I find that list comps are often nice sugar for filter
04:31:55 <quicksilver> howmanyover5 = length [ x | x <- l, x > 5 ]
04:32:47 <Vq^> quicksilver: i usually only do that when i do a "map" or ">>=" as well
04:33:20 <Vq^> a single filter is more readable to my eyes
04:33:24 <quicksilver> yes, you're probaby right.
04:33:29 <quicksilver> comboniations of map + filter.
04:34:03 <Vq^> in python it's a different story thought
04:34:35 <Vq^> map and filter are so awkward so you'll have to use generator and list comprehensions all the time
04:35:15 <pejo> quicksilver, what part of "take 10 . takeWhile (<20)" is inefficient in a strict language?
04:36:08 <Vq^> pejo: takeWhile has to know about take 10, otherwise it might take to many elements
04:37:09 <pejo> Vq^, huh?
04:37:39 <Vq^> pejo: imagine a very long list consisting of fives
04:37:42 <Gilly> will haskell also store function values... like if i define a recursive function a n = ... and ask first for a 1 and then for a 2 which would need the result for a 1 will it have to calculate a 1 again?
04:38:35 <Vq^> Gilly: it recalculates results from functions
04:39:09 <Gilly> are there easy workarounds?
04:39:15 <Vq^> Gilly: yes
04:39:31 <pejo> Vq^, so the arugment is the n-10 extra steps over the list?
04:39:42 <quicksilver> pejo: If there are 10 million items under 20
04:39:46 <quicksilver> pejo: and I only want the first 10
04:39:57 <quicksilver> pejo: my ocaml program is going to run about a million times slower than my haskell one!
04:40:01 <quicksilver> lazy eval = win!
04:40:15 <Vq^> Gilly: you can do lookups in a table that contains all the return-values for example
04:40:36 <Gilly> Vq^: yea i guess i got to go for that
04:41:37 <pejo> quicksilver, one could almost believe that carrying around a list with 10 million elements would cause all kinds of trouble elsewhere too.
04:41:50 <quicksilver> pejo: yes, but surely you can see my point.
04:42:05 <quicksilver> pejo: the list might be small enought o be in memory but large enough it's stupid to scan all the way down it.
04:42:16 <quicksilver> this can easily turn a linear algorithm into a quadratic one.
04:42:32 <quicksilver> (in haskell, of course, the list itself may be lazily generated, too)
04:42:38 <quicksilver> (but that's not actually the point here)
04:50:13 <quicksilver> @remember matthew_- To that end, I would *not* encourage you to try to look at the implementation too closely as you may suddenly discover a powerful urge to stick knives in your eyes and/or eat your computer.
04:50:13 <lambdabot> I will never forget.
04:50:42 <mux> I'm a bit surprised to see hGetBuf/hPutBuf take and return an Int parameter for the number of bytes
04:50:58 <wvd> why?
04:50:59 <mux> Haskell needs something semantically similar to C's size_t for that
04:51:06 <mux> > maxBound :: Int
04:51:08 <lambdabot>  2147483647
04:51:18 <quicksilver> Int is semantically similar to C's size_t, in practice.
04:51:35 <mux> that's only in practice and thus not semantically similar
04:51:47 <wvd> ints could be negative
04:51:49 <mux> the chance here is that POSIX fubar'ed with ssize_t
04:52:30 <mux> and yes, Ints are not appropriate for the mere reason that they can be negative
04:53:39 <quicksilver> well it's consistent with take and drop
04:53:46 <quicksilver> which are, arguably, analogous
04:54:15 <mux> one can imagine a scenario where we have mmap'ed memory that is bigger than 2GB on 64bits architecture, and we couldn't use hGetBuf with that memory; at least not all of it
04:54:31 <hpaste>  aaim annotated "Base26 to Base10" with "(no title)" at http://hpaste.org/6004#a1
04:54:46 <resiak> isn't Int 64 bits on amd64?
04:55:37 <mux> even C's "int" is rarely 64bits on 64bits architectures
04:55:48 <mux> it's mostly a waste of memory
04:56:00 <quicksilver> mux: haskell's Int is 64 bits on 64 bit architectures.
04:56:04 <quicksilver> Well, GHC's is, I should say.
04:56:30 <mux> strange choice
04:56:33 <quicksilver> GHC's Int is always at least as large as a native pointer.
04:56:47 <mux> anyways, that's still not very nice to have Ints when you interface with POSIX stuff
04:56:52 <quicksilver> Not realy. GHC makes parametric stuff parametric.
04:57:02 <quicksilver> so a datum is the same size as a pointer
04:57:10 <quicksilver> (most datums are, in fact, pointers)
04:58:40 <quicksilver> I agree that it's a pain interfacing with stuff with definite file formats, certaily.
04:58:49 <quicksilver> I have code with way too many fromIntegrals in it.
04:58:53 <mux> on a totally different topic, do you guys have recommendations on good wide LCD dispay stuff?
04:59:03 <mux> quicksilver: yeah, my FFI code is riddled with that :)
04:59:05 <quicksilver> because my definite file format uses Word32s, and I need Ints for built-in functions.
05:01:33 * mux spots some nice Iiyama 22" wide LCD displays
05:03:21 <wvd> apple cinema displays for the win
05:03:47 <quicksilver> not cheap though.
05:04:11 <mux> the iiyama models I've seen are around 220EUR
05:05:28 <mux> mmm, the 24" one can do 1920x1200 and it's only 365EUR
05:06:40 <titusg> I wish there was a book of functional pearls -- anyone here with clout at JFP? :-)
05:07:52 <quicksilver> titusg: that's a really nice idea. They could call it 'The Oyster'
05:08:48 <Saizan> there's a wiki page which lists them though :)
05:12:34 <smg> @pl problem8 list = maximum ( map(\x -> (foldr (*) 1 ((drop x . take (5+x)) list))) [0..995])
05:12:35 <lambdabot> problem8 = maximum . flip map [0..995] . (foldr (*) 1 .) . flip (liftM2 (.) drop (take . (5 +)))
05:15:43 <Toxaris> smg: product [1, 2, 3]
05:15:47 <Toxaris> > product [1, 2, 3]
05:15:48 <lambdabot>  6
05:16:40 <Toxaris> smg: and   drop x . take (5 + x)   ==   take 5 . drop x
05:17:02 <smg> ah okay
05:18:48 <smg> problem8 list = maximum $ map (\x -> product (take 5 . drop x $ list)) [0..995]
05:19:28 <matthew_-> ta for the @quote quicksilver ;)
05:20:04 <Toxaris> smg: you can do it with less code (and less runtime work) when you work over the input list, not over a list of indices
05:21:15 <smg> k
05:21:24 <smg> http://haskell.org/haskellwiki/Euler_problems/1_to_10#Problem_8
05:21:30 <smg> i compared mine to that solution
05:22:03 <Toxaris> that solution is bad (in terms of nice code)
05:22:40 <Toxaris> and in terms of idioms learned, it's even better. *explicit recursion* :(
05:22:49 <Toxaris> ah, I mean "worse" of course
05:22:52 <smg> ok
05:26:46 <shepheb> there has to be a foldl' solution that carries a (current top product, current four digits) pair or similar. that's more Haskell-y. explicit recursion is almost always a lose.
05:27:22 <Toxaris> shepheb: groupsOf can be composed of two standard functions
05:28:23 <Toxaris> I'm not sure wether I should just post my solution here. would I spoil the fun for someone?
05:28:33 <quicksilver> paste it on hpaste
05:28:38 <quicksilver> people don't have to look if they don't want to.
05:28:40 <shepheb> Toraxis: a whole bunch of prelude functions are written explicitly when most could be defined in terms of foldr. that's usually okay, though, because they still have stream processing annotations. your explicit recursions don't.
05:30:06 <hpaste>  Toxaris pasted "SPOILER project euler 8" at http://hpaste.org/6008
05:30:30 * Toxaris hopes PE team will not kill him
05:30:53 <scook0> I hear they have ninjas
05:31:06 <shepheb> Toraxis: map f . map g === map (f . g)
05:31:16 <shepheb> GHC should optimize that anyway, but it's still shorter
05:31:17 <Toxaris> shepheb: I'm aware of that, but ghc is, too
05:31:39 <shepheb> Toxaris: well said. also, apologies for transposing letters in your name.
05:32:46 <Feuerbach> shepheb: what are those "stream processing annotations"? where can I read about them?
05:32:50 <Toxaris> (what is a sensible answer to such apologies to accept them?)
05:33:39 <quicksilver> (np)
05:34:12 <Toxaris> Feuerbach: I like the Stream Fusion paper: http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf  it includes a proposal for a new system, but summarizes other aproaches, too, and introduces the task
05:34:49 <shepheb> Feuerbach: Also, this: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html  gives a description of how GHC sees them, and a list of good producers and consumers.
05:34:50 <lambdabot> Title: 8.13. Rewrite rules, http://tinyurl.com/y7rk9g
05:35:15 <shepheb> see the section on list fusion
05:35:20 <Toxaris> quicksilver: standing for "no problem"?
05:35:30 <shepheb> I should have said "stream fusion", I apologize for the mistake.
05:35:49 <shepheb> I keep that list handy.
05:36:28 <Vq^> Toxaris: correct
05:36:38 <shepheb> the last line of 8.13.3 implies that the Prelude source should show them in action.
05:38:41 <Toxaris> a possible start is the map function, including a nice comment about phase control. http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#map
05:38:41 <lambdabot> http://tinyurl.com/3dzxqb
05:41:05 <andrew_> nice my OS came with 6.8.2
05:41:11 <Feuerbach> Toxaris, shepheb: thanks
05:48:08 <Saizan> are there non-predictable number generators that are guaranteed to not generate the same number twice in some number of iterations?
05:48:43 <ohub> Saizan; how is that non-predictable then?
05:50:43 <scook0> you can predict which numbers you *won't* get
05:51:00 <scook0> but the numbers you *will* get still have an unpredictable element
05:52:50 <Saizan> yeah
05:52:51 <ohub> well, it depends
05:52:52 <Toxaris> nub <$> getStdRandom randoms
05:53:22 <jrx> :t <$>
05:53:23 <lambdabot> parse error on input `<$>'
05:53:26 <ohub> what are you trying to achieve with such thing?
05:53:29 <jrx> :t (<$>)
05:53:31 <scook0> (<$>) = fmap
05:53:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:53:40 <Saizan> ohub: i need them for unique session ids
05:53:50 <qwrx> @src foldl
05:53:51 <lambdabot> foldl f z []     = z
05:53:51 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:53:51 <jrx> scook0: thanks ;)
05:53:53 <Saizan> ohub: so i don't care about distribution
05:54:00 <ohub> Saizan; why don't you take a timestamp then?
05:54:29 <shepheb> Saizan: [0..] is a great source of unique numbers. combine with a timestamp or some manner of hashing if you want unguessability.
05:55:11 <Saizan> ohub: i can get two equal timestamps with concurrency
05:55:30 <DQuest> Aye.  You don't necessarily need random numbers.  Use a good hash, sequence numbers and a secret
05:55:48 <Saizan> hash increases the risk of collisions
05:55:58 <andrew_> @src (<?>)
05:55:58 <lambdabot> Source not found. You type like i drive.
05:55:59 <ohub> Saizan; where do you need the session-id?
05:56:00 <shepheb> Saizan: unique number from [0..], timestamp, secret value, SHA1. collisions are astronomically unlikely and they're unguessable
05:56:03 <andrew_> @src (<$>)
05:56:03 <lambdabot> f <$> a = fmap f a
05:56:28 <shepheb> Saizan: so fine, check each new value against a list of active ones, if you absolutely can't have a collision
05:56:33 <quicksilver> Saizan: erm? hash "increases" the risk of collisions?
05:56:34 <andrew_> @src fmap
05:56:35 <lambdabot> Source not found. Wrong!  You cheating scum!
05:56:35 <quicksilver> lol
05:56:45 <quicksilver> hashes are designed to minimise collision risk.
05:56:54 <DQuest> I think you misunderstand, quicksilver
05:57:05 <DQuest> I don't think it's a hash collision, more that the inputs to the hash would collide
05:57:24 <Saizan> quicksilver: two different values can have the same hash, no?
05:57:26 <quicksilver> that's why you add a sequence number and/or a secret
05:57:34 <DQuest> Then again, if you mix in IP address and time in seconds or milliseconds you can't go too far wrong
05:57:43 <quicksilver> Saizan: yes, they can. But the hash is designed to minimise that chance.
05:57:51 <quicksilver> Saizan: whereas random numbers are not :)
05:58:03 <quicksilver> Saizan: so a hash has no worse collision chance than a random number.
05:58:05 <DQuest> Aha, you *do* mean hash collision.  not gonna happen.
05:58:21 <Saizan> quicksilver: i wasn't starting with a random number :)
05:58:27 <DQuest> I believe that there's been one or two examples of md5 collision only, and those had to be carefully constructed
05:58:33 <ohub> and for such thing with session-id, the collision doesn't matter so much
05:58:39 <Toxaris> what's wrong with [0..]?
05:58:50 <ohub> Toxaris; predictability I think :)
05:58:52 <quicksilver> Choose an appropriate size hash and the collision chance is such that the universion will have come to an end before you have a one thousands of a percent change of seeing one.
05:59:06 <quicksilver> hmm. s/universion/universe/
05:59:15 <delYsid> DQuest: I am administering a hpc cluster, and one of my users is doing SHA1 collisions...
05:59:16 <Toxaris> well, so use n bits for [0..] and m bits for a random number in your (n+m) bits sessions id
05:59:35 <scook0> you can make it more likely that cosmic radiation will make it *look* like there's been a collision
05:59:42 <DQuest> delYsid: as in, keeps encountering them, or trying to find them?
05:59:54 <shepheb> yeah, SHA1 was broken a while ago.
06:00:20 <DQuest> Mm, but SHA1 and md5 is probably fine for a website's session IDs, unless you're a bank
06:00:21 * scook0 ponders accellerating SHA1s towards each other, and smashing them together to see what they're made of
06:00:29 <ohub> maybe you should do same thing what TLS is doing. use both sha1 and md5 together ;)
06:00:33 <delYsid> DQuest: actually, I dont know about his findings, I just know he is trying to find some :-)
06:00:45 <DQuest> Or SHA256
06:01:53 <shepheb> anyway, since this sounds like website unique keys, combine a unique number, timestamp, maybe IP address and secret word, and SHA1 it. chances of collision are absurd, but you can check them against a list of active ones to make absolutely certain, if you like.
06:02:10 <therp> DQuest: iirc MD5 has more grave problems than one or two examples of collisions
06:02:47 <DQuest> therp: Good point.  It's possible to construct two files with the same sum now, actually.  Probably OK for a small website though, but it never hurts to upgrade
06:02:59 <Saizan> shepheb: why sha1 and not md5?
06:03:46 <qwrx> MD5 is weaker
06:03:49 <DQuest> sha1 and md5 are both a bit suspect, if you're going for solid security.  It doesn't hurt to use sha256, unless performance is a real issue
06:04:36 <qwrx> I believe something along the lines of given x and md5(x) it's possible to find efficiently y : md5(y) == md5(x)
06:04:56 <qwrx> whereas I think the state of the art for sha1 is that it is possible to find x, y : sha1(x) == sha1(y)
06:04:58 <DQuest> Good grief, that's very broken
06:04:59 <qwrx> which is not so bad
06:05:12 <qwrx> I could be terribly wrong here
06:05:20 <qwrx> not I cryptographer just work in the same room
06:05:23 <shepheb> there's a pure SHA-1 on hackage, too.
06:05:29 <qwrx> s/I/a/
06:06:43 <DQuest> And there are secure session libraries for most anything
06:07:16 <Saizan> i suppose my question was "what does this secure session libraries use?"
06:07:33 <trez> how to get "123&456&789" => ["123","456","789"] ?
06:07:39 <qwrx> the word from a cryptographer is that md5 is only broken for common prefixes, so that given x it's easy to find y and z s.t. md5(xy) == md5(xz)
06:08:07 <shepheb> hang on. is there any security depending on this, or just unique IDs?
06:08:11 <DQuest> where x > ""
06:08:13 <DQuest> presumably
06:08:37 <Saizan> shepheb: it's more a curiosity right now, just to see if we can get perfection :)
06:08:37 <ohub> Saizan; have you told us what you are trying to do?
06:09:05 <shepheb> Saizan: well, you can always get linear-time perfection by making sure it hasn't been used yet :P
06:09:34 <qwrx> guess so :)
06:09:41 <Saizan> shepheb: and linear memory usage, eww.
06:09:51 <hallongrottan> @src lines
06:09:51 <lambdabot> Source not found. Take a stress pill and think things over.
06:09:55 <hallongrottan> lol
06:10:06 <hallongrottan> @src splitWith
06:10:06 <lambdabot> Source not found. My pet ferret can type better than you!
06:10:08 <hallongrottan> meh
06:10:22 <shepheb> but, fundamentally, randomness and uniqueness can't both be guaranteed in constant time, I think.
06:10:25 <hallongrottan> i need to split a string at ampersands
06:10:25 <DQuest> Saizan: There's no such thing as perfection, but there is such thing as it being so unlikely that your computer is more likely to be hit by a freak meteor
06:10:37 <hallongrottan> is there a convenient function for that?
06:11:02 <qwrx> trez: something like takeWhile (not . ((==) [])) . unfoldr (Just. second $ drop 1) . break ((==) '&') perhaps
06:11:08 <shepheb> hallongrottan: this is probably the most-requested Prelude feature. there's words, but that only works on spaces. there should be "split" or "wordsBy".
06:11:10 <DQuest> I dunno, ask trez
06:11:19 <hallongrottan> shepheb: ah yes
06:11:53 <DQuest> Good grief, I thought you were the same person for a moment there since you asked the same question at the same time :P
06:12:38 <hallongrottan> ah lol
06:12:49 <hallongrottan> funny thing is me and trez are doing the same thing also :P
06:12:49 <qwrx> that second should be snd
06:13:04 <DQuest> ah, that'd be why.  Competition, or job?:)
06:13:12 <Toxaris> trez, hallongrottan: a possible start is break. a short definition is possible with groupBy, but it's crazy. a possible hack is to convert & to \n and use lines. the real thing is to copy the source of words or lines and built your own split function. Or you could use Data.ByteString, which features a split function.
06:13:20 <Cale> DQuest: assignment maybe?
06:13:35 <shteou> Hi, does anyone know if YHC can (be extended to?) do cross-module optimizations? And if it requires extension would it neccessitate the addition of the optimized modules into seperate compiled files (or the caller's .hbc)?
06:14:39 <DQuest> Cale: Aha, I never think of that one.  Which I should.
06:15:31 <DQuest> shteou: unlikely.  The point of modules is that they have a well-specified interface which can be used by anything.  If you wanted to optimise between two modules you'd have to stick them in one and expose less stuff, most likely.  That's just going from principles of seperate compilation, though.  I'm no expert
06:16:25 <shteou> Cheers DQuest :)
06:17:02 <Cale> Well, JHC does full-program optimisation.
06:17:33 <Cale> If you're compiling a set of modules together, and you have the source code for all of them still, you might as well take advantage of that.
06:17:56 <Saizan> DQuest: even GHC does some cross-module optimizations
06:18:29 <shteou> Well GHC yess, but YHC compiles to seperate bytecode files, Saizan
06:19:31 <Philippa> shteou: it could be extended and unless the existing file format's extensible enough then it'd need separate files to do so
06:19:45 <shteou> Yeah k :)
06:19:50 <Philippa> whether that extension would involve a major rewrite is something I can't comment on
06:20:00 <shteou> Thanks all :>
06:20:03 <Philippa> well, not rewrite. Refactoring
06:20:20 <dcoutts> shteou: in principle it's no different, ghc compiles to separate .o files, the trick to cross-module optimisation with separate compilation is to put enough info into the interface files.
06:20:26 <Philippa> that's one of the things I like about Haskell, you really can go a long way refactoring rather than rewriting even for major architectural changes
06:20:51 <DQuest> Saizan: what, really?  Then I'm totally wrong.  How does that work?
06:20:56 <shteou> dcoutts, but I mean the modification of the .hbc files may not be possible? You would be creating seperate ones, yes?
06:21:18 <Saizan> DQuest: what dcoutts said :)
06:21:25 <DQuest> Saizan: aha
06:21:33 <shteou> heh
06:21:43 <Philippa> DQuest: the interface files include piles of intermediate code, essentially
06:21:57 <DQuest> Ah, that's cunning
06:22:16 <DQuest> I was thinking in terms of C compilation, I didn't think of that
06:22:25 <qwrx> puzzle: there are these numbers called the ulam numbers where the nth ulam number is the smallest integer which can be written as the sum of 2 smaller ulam numbers in precisely (only) 1 way - can anyone do this in haskell in a way that doesn't suck
06:22:29 <shteou> heh
06:22:50 <qwrx> I only have solutions that suck
06:23:28 <DQuest> Hmm, would this be for problem 167?
06:23:30 <cjb> there is probably an elegant solutions for primes n that could be modified slightly
06:23:43 <qwrx> @src primes
06:23:43 <lambdabot> Source not found. Just try something else.
06:23:46 <qwrx> grah
06:24:03 <Saizan> yhc's object files don't contain YHC.Core, i guess?
06:24:04 <qwrx> primes is nicer because it doesn't require ordering
06:24:48 <qwrx> but using the filter here you have to keep all the possible sums in ascending order
06:25:03 <DQuest> I imagine that the first thing to do would be to map sum over the powerset of the ulam numbers up to n and select the smallest unique member
06:25:19 <DQuest> Then define the ulam numbers as being 1 followed by that?
06:26:11 <qwrx> not quite the powerset because 2+1 and 1+2 don't count twice
06:26:14 <qwrx> but yeah
06:26:35 <hallongrottan> if i want to negate a predicate, how can i do that?
06:26:39 <qwrx> not
06:26:40 <hallongrottan> like not p
06:26:43 <resiak> not . p
06:26:45 <hallongrottan> but p :: (a -> Bool)
06:26:54 <hallongrottan> resiak: ok :o
06:26:55 <qwrx> what he said
06:27:08 <qwrx> DQuest: and you have to select the smallest unique member which you haven't already computed
06:27:29 <DQuest> well, yep
06:27:48 <DQuest> hmm, there is a flaw in my logic but you could adapt it
06:27:59 <qwrx> I have that solution, and one which uses insertion sort
06:28:08 <qwrx> in a running list of candidates
06:28:45 <DQuest> alternatively, 1 followed by fitlering [2..] by whether it's a ulam number, where that can use the infinite list of ulams
06:29:02 <DQuest> up to the next lowest number, so it'll terminate
06:29:10 <qwrx> that I haven't tried
06:29:21 <DQuest> then again, it might not...
06:29:23 <DQuest> Hrm.
06:29:48 <DQuest> You could use a recursive function which keeps track of how many you already have to generate an inifinite list, perhaps
06:30:02 <qwrx> it's like some kind of special sequence designed to make programs that compute it ugly
06:31:35 <qwrx> hmmph
06:31:42 <DQuest> I for one would like to know how to do the sum of abundant numbers one in a reasonable time
06:32:14 <DQuest> I suspect that my algorithm for finding divisors might be better if it just did trial division
06:33:21 <qwrx> I can tell you the sum of all the abundant numbers if that's any help :)
06:34:53 <qwrx> anyway should get on with some real work I suppose
06:35:21 <quicksilver> Philippa: I also like the fact that when you *do* embark on a large refactor, the type checker will normally tell you if you missed something.
06:35:48 <quicksilver> Philippa: I find a very high percentage of my haskell code refactors work right first time (first time they compile)
06:37:16 <hallongrottan> shepheb: i fixed a splitWith now
06:37:30 <hallongrottan> and as far as i've tested it, it works correctly
06:38:04 <shepheb> hallongrottan: care to paste?
06:38:28 <hallongrottan> shepheb: sure, it's only 3 lines of code
06:38:39 <hallongrottan> here or hpaste?
06:39:14 <hpaste>  Tobsan pasted "splitWith" at http://hpaste.org/6009
06:41:40 <shepheb> take and drop together is inefficient, unfortunately. see break, span.
06:50:51 <dcoutts_> yay! no more "cabal info" which didn't do what you expected
06:51:01 <dcoutts_> now: cabal install --dry-run
06:51:38 <dcoutts_> also makes cabal tab completion work better: "cab<tab> i<tab>" completes to "cabal install "
06:52:05 <dcoutts_> (if you're using the cabal bash command line completion)
06:52:25 <Feuerbach> Suppose I'm making a data an instance of some class. Is it ok to define method for some pattern (one data constructor) and use default method for others?
06:52:27 <ndm> is there still no way to do cabal configure/build/install in one command?
06:52:37 <ndm> its starting to _really_ annoy me :)
06:52:37 <dcoutts_> ndm: that's what cabal install does
06:52:39 <hallongrottan> shepheb: in the case of splitWith, span and break would have the same effect, wouldnt they?
06:52:49 <ndm> dcoutts_: doesn't cabal install download it from hackage?
06:52:52 <dcoutts_> ndm: cd yer_project && cabal install
06:53:01 <hallongrottan> shepheb: lol nvm, tried it out
06:53:05 <hallongrottan> break was the one i wanted
06:53:10 <dcoutts_> ndm: it installs all deps and then builds the local project
06:53:25 <dcoutts_> ndm: configures, builds and installs the local project
06:53:28 <ndm> dcoutts_: oh, thats what i want :) - is that the cabal install repo? how do i get this cabal program?
06:53:36 <dcoutts_> @where cabal-install
06:53:36 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
06:53:47 <ndm> i think last time i tried i gave up as it had too many dependencies
06:53:49 <hpaste>  Tobsan pasted "splitWith (using break)" at http://hpaste.org/6010
06:54:06 <dcoutts_> ndm: it's the same number of deps, ie only two. zlib and http
06:54:22 <ndm> dcoutts_ and http depends on network, and i think i was chasing further after that
06:54:33 <ndm> (quite possibly because i'm on 6.6 on this machine)
06:54:37 <dcoutts_> ndm: you should have all the others in a standard install
06:54:47 <dcoutts_> 6.6 came with network
06:54:49 <shepheb> better, yes. there's a one-liner with foldr if you're willing to use Arrow combinators. I'll paste soon.
06:55:04 <ndm> perhaps not the necessary new version of network
06:55:11 <ndm> anyway, i'm happy that it can be done, and soon
06:55:31 <ndm> i thought cabal install was only for pulling the package etc, didn't realise you could run it on a locally downloaded thing
06:55:47 <dcoutts_> ndm: it is the new command line interface to the whole cabal/hackage system
06:56:00 <ndm> yay, cabal is getting noticably better as time goes by
06:56:01 <dcoutts_> ndm: it does everything the runghc Setup.hs does and more
06:56:34 * dcoutts_ never uses runghc Setup.hs anymore
06:57:02 * dcoutts_ encourages everyone to get cabal-install
06:57:22 * mightybyte agrees
06:57:42 * ndm would love to, and would if he had a convenient way of downloading and installing all of its dependencies
06:57:48 <dcoutts_> ndm: btw, http works with 6.6 too, you shouldn't have any problems
06:58:13 <ndm> dcoutts_ as i set off down a transitive closure of dependencies, i remembered i had a phd to write ;)
06:58:30 <Cale> There are only 6 or so, iirc.
06:58:32 <dcoutts_> ndm: I think you gave up one too short
06:58:41 <ndm> i will, as soon as i upgrade to 6.8, since i'd have to redo anyway then
06:58:53 <dcoutts_> ndm: if you're using 6.6 there are even fewer since it has more stuff in the basic install
06:58:58 <dcoutts_> like network
07:00:54 <ndm> dcoutts_: at some point did you unrecord "Fix broken installIncludeFiles" by "Bertram Felgenhauer"
07:01:05 <ndm> my cabal copy seems to have an additional patch to the darcs
07:01:30 <dcoutts_> ndm: I don't think we've ever unrecorded something from the central cabal repo
07:01:35 <ndm> way back on May 1
07:01:43 <dcoutts_> it'd break everyone's repos
07:01:49 <ndm> dcoutts_: yeah :)
07:01:52 <ndm> @where cabal
07:01:52 <lambdabot> http://www.haskell.org/cabal
07:02:27 <ndm> dcoutts_: shock horror! the png on http://www.haskell.org/cabal/ is resized down with width/height tags! thats horrible HTML practice
07:02:27 <lambdabot> Title: The Haskell Cabal
07:02:37 <dcoutts_> ndm: eew
07:02:48 * dcoutts_ inherited that page
07:03:16 <quicksilver> will cabal-install ever come with GHC?
07:04:36 <dcoutts_> quicksilver: not the basic install, the general trend is to have ghc come with less but we're talking about doing platform releases with more stuff
07:04:54 <ndm> the Windows one will, no doubt
07:05:11 <ndm> even if its just a binary, without the necessary source to recompile it
07:05:20 <ndm> (which i think would be perfect)
07:05:41 <quicksilver> dcoutts_: in a sense, that's contradictory.
07:06:03 <quicksilver> dcoutts_: If the trend is for ghc to come with less stuff, then the imperative for GHC to come with the tool for installing more stuff becomes stronger.
07:06:04 <dcoutts_> quicksilver: the idea with platform releases are not synchronised with ghc releases
07:06:38 <dcoutts_> quicksilver: think gtk+ and gnome
07:06:47 <quicksilver> oh, yes, I'm familiar with that.
07:07:02 <quicksilver> but my point is: get a cut-down debian, and the one thing you *do* get is dpkg and apt.
07:07:15 <quicksilver> if you cut something down, which is sensible, then including the tool which helps users get more is nice :)
07:09:03 * ndm vapourises cabal and cabal-install and starts afresh
07:09:42 <ndm> oh, has anyone ever tried to add 80Mb of data in 100 files to darcs? the result is a heap overflow and its not exactly "quick"
07:09:58 <ndm> in fact, its entirely unusable - i ended up putting the data in a separate unversioned .zip file
07:10:17 <dcoutts_> ndm: hmm, I don't have the source to that logo so I cannot resize it, we'll have to ask SyntaxNinja where he got the logo from
07:11:00 <ndm> dcoutts_: if you resize it with something like GIMP and bicubic resizing it will look a lot better than it currently does in a web browser
07:11:05 <dcoutts_> I hope it was made from a scalable source image, so I'd rather not resize the png
07:11:14 <ndm> although of course you should have an .svg somewhere :)
07:11:51 <desegnis> ndm, the new patch format of the upcomping darcs-2 should make it a bit more usable
07:12:10 <ndm> desegnis: i thought it probably would
07:13:23 <dcoutts_> @ask SyntaxNinja do you know if there is a source image for the hackage.haskell.org/trac/Cabal-With-Text.png, eg .svg or something? It's so we can make small versions of it (rather than telling browsers to resize it using height/width attributes)
07:13:23 <lambdabot> Consider it noted.
07:13:34 <desegnis> ndm, the patch format of darcs-1 simply ignores any efficiency considerations
07:14:14 <idnar> ndm: I just added an 80MB file to a darcs repository without any issues; it did use about 800MB of memory, though
07:14:40 <ndm> idnar: on my machine, i have less memory than that and GHC defaults to a 256Mb heap
07:14:42 <dcoutts_> idnar: ah bug ndm's machine is hand powered
07:14:54 <dcoutts_> bug/but
07:15:10 <ndm> idnar: i did manage to add them, by +RTS, but when i tried to push them it froze solid
07:15:14 <idnar> I didn't touch ghc
07:15:26 * idnar tries with darcs-2
07:15:27 <ndm> i think it defaults to a heap limit based on your OS and memory available
07:15:51 <idnar> that would probably explain it, then
07:16:20 <idnar> hmm, so darcs-2 used about 600MB of memory
07:16:46 <idnar> I'm not sure how old this build is, probably a few weeks
07:17:12 <ndm> i think i may have actually been on about 20Mb of files, now i think about it
07:17:35 <desegnis> hm... so much for being “a bit more usable”
07:18:20 <idnar> well
07:18:44 <idnar> there weren't any changes in the patch format for binary files
07:19:25 <shepheb> don't most VCS's suck for large binaries?
07:19:42 * desegnis must have confused the tenses of some sentences when reading darcs-devel then :)
07:19:45 <idnar> I think they're mostly pretty good at it, now
07:19:57 <quicksilver> ndm, dcoutts_: Actually it looks just lovely in my web browser. If it doesn't in yours, your web browser must have a lousy resize algorithm ;)
07:20:15 <dcoutts_> quicksilver: heh :-), but it does mean it's downloading more than necessary
07:20:20 <quicksilver> that's true
07:20:20 <ndm> quicksilver: yeah, firefox sucks :)
07:20:35 <quicksilver> although not much, since it's a png with large areas of flat colour.
07:20:42 <ndm> quicksilver: the reason i noticed it is that it downloaded far slower than it should have done given the size of the image
07:20:48 * quicksilver nods
07:20:50 <quicksilver> that's a fair point.
07:21:18 <ndm> plus if an image is resized in the browser, it displays slower in firefox, for some reason, even if the actual data being trasmitted isn't much bigger
07:21:36 <Cale> I have an svg of that logo if anyone needs it.
07:21:47 <dcoutts_> Cale: oh really? yes we do need it
07:22:07 <dcoutts_> Cale: and if we could keep the .svg in the same place that help in future too
07:23:40 <Cale> http://cale.yi.org/autoshare/Cabal.svg
07:23:53 <Cale> http://cale.yi.org/autoshare/Cabal-built-with.svg
07:24:19 <shag> what is the official citation for the haskell98 report?
07:25:14 <dcoutts_> Cale: thanks, can we host those at hackage.haskell.org/trac/ ? I mean the license is ok?
07:25:21 <Cale> yep
07:25:30 <dcoutts_> great
07:25:33 <shepheb> re: Haskell for C Programmers: the prose and explanations are excellent. I think several of the examples would benefit from having both a "less brain hurt, less Haskell-y" and a "more brain hurt, more Haskell-y" variant.
07:26:03 <shepheb> lots of explicit recursion and etc. I realize that foldr-hackery isn't the point of the tutorial, but it's still not a good idea to introduce substandard style.
07:27:08 <Cale> I kind of found the Haskell for C programmers tutorial a bit confusing, but I'm more of a Haskell programmer than a C programmer :)
07:27:34 <Cale> and it's been quite a while since I looked at it, so possibly it's improved
07:27:38 <ndm> shag: bibtex?
07:27:45 <sm> morning all
07:27:46 <shag> ndm: preferably, yes
07:28:22 <ndm> shag: http://www.cs.york.ac.uk/fp/darcs/supero/academic/ifl2007/supero.bib - in there as "haskell"
07:28:24 <lambdabot> http://tinyurl.com/299lxu
07:28:39 <shag> ndm: thanks
07:28:41 <shepheb> I've sent it to several of my imperative-minded friends. especially the "What does Referential Transparency Buy Me?" section, for the ones who only see jumping through hoops because we don't allow mutable variables.
07:28:53 <shepheb> I think it's a great tool for overcoming blub problems.
07:29:02 <ndm> (feel free to steal any citations out of there, although i don't guarantee accuracy)
07:29:04 <quicksilver> jumping through hoops is more fun when they're on fire.
07:30:10 <Cale> or when you're a basketball
07:40:03 <newsham> morning
07:40:15 <newsham> http://www.thenewsh.com/%7Enewsham/lambda/lst.lam
07:43:19 <jacobian_> can denotational semantics be done with languages other than set theory as a target?
07:44:20 <quicksilver> sure.
07:44:20 <hpaste>  ndm pasted "Neil installs network (crying insues)" at http://hpaste.org/6011
07:44:35 <ndm> dcoutts: apparently windows doesn't have sh :)
07:44:36 <quicksilver> jacobian_: you see denotations into categories, CPOs, and suchlike objects.
07:44:53 <quicksilver> jacobian_: in principle you could denotate into all sorts of things
07:45:23 <dcoutts_> ndm: how can you have ghc-6.6.x without also having network, I just don't understand. It's part of the binary install.
07:45:26 <ndm> dcoutts: although it may well be cabal that is firing off sh, as network doesn't have a Setup.hs
07:45:45 <dcoutts_> ndm: network uses a ./configure script
07:45:58 <dcoutts_> ndm: which is one reason why it's always built with ghc on windows
07:46:18 <jacobian_> Has it been done into declarative languages before?  Perhaps into type theory?
07:46:22 <ndm> dcoutts_ may bad, i was aiming for http, and installed network instead...
07:46:25 <newsham> people use windows without cygwin/mingw?  ;-)
07:47:12 <dcoutts_> ndm: so http uses network and parsec and you should have both already
07:47:20 <ndm> newsham: its like using Windows without installing Linux on it ;)
07:47:30 <newsham> ndm: srsly
07:47:48 <dcoutts_> ndm: parsec is no longer a core lib in 6.8 but is included in the 'extra' packages so if you're using the windows binary it should be there
07:48:06 <newsham> "do you have the linuxes on your win32?"
07:48:19 <quicksilver> jacobian_: you might use lambda calculus as a denotation of a language
07:48:30 <quicksilver> jacobian_: (because you already understand L-calc's denotation)
07:48:35 <quicksilver> jacobian_: that kind of thing is done sometimes, yes.
07:48:40 <quicksilver> is that the sort of thing you mean?
07:48:43 <jacobian_> yeah
07:48:54 <newsham> i thought lambda calc was traditionally used to do denotational semantics
07:51:41 <skorpan> hey
07:51:52 <skorpan> how do i import Prelude but hiding the (>>) function?
07:51:58 <skorpan> import Prelude hiding (>>) gives me parse error
07:52:38 <daniel_larsson> Try "hiding ( (>>) )"
07:52:40 <skorpan> or even better, to somehow tell ghc(i) to use _my_ definition of (>>) whenever it encounters it and i don't explicitly say Prelude.>>
07:52:52 <skorpan> daniel_larsson: works, thanks
07:53:13 <ndm> dcoutts_ i did it :)
07:53:34 <ndm> dcoutts_ now trying to install missingh says that old-time fails during the configure stage - i guess thats a case of missingh being 6.8 only?
07:54:11 <dcoutts_> ndm: yay. Not sure, I need to improve those error messages.
07:54:28 <dcoutts_> ndm: if it was missing deps it should have said explicitly
07:54:46 <dcoutts_> ndm: in the mean time you can run with -v
07:54:47 <ndm> dcoutts_ i think its a case of old-time on 6.6 windows isn't going to work, but missingh wants it
07:54:59 <ndm> configure scripts and all :)
07:55:12 <dcoutts_> ndm: you can try an older missingh I guess
07:55:32 <dcoutts_> ndm: if you run install --dry-run -v it'll tell you more
07:56:06 <ndm> dcoutts_ i think this is sufficiently minor that going for 6.8 will just be easier
07:56:25 <dcoutts_> ndm: hmm, missingh-1.0.0 looks like it should work with 6.6
07:56:57 <dcoutts_> ndm: it may just be mis-reporting the missing deps, it's not an exact science
07:57:19 <dcoutts_> since the missing deps depends on what config flags one thinks ought to have worked
07:57:57 <ndm> dcoutts_: reading the -v trace, i think its saying hslogger is asking for unix
07:58:31 <dcoutts_> ndm: hmm, hslogger doesn't say it depends on unix
07:58:36 <dcoutts_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hslogger-1.0.4
07:58:37 <lambdabot> http://tinyurl.com/3a8fov
07:58:51 <ndm> dcoutts_: i see that, but the -v trace shows it as a top-level dep of hslogger
07:58:57 <jacobian_> I suppose Assembly wouldn't make a very useful language for denotation.
07:59:10 <ndm>     if !os(win32)         Build-Depends: unix
07:59:12 <dcoutts_> ndm: yes, missingh uses hslogger, but that doesn't use unix
07:59:31 <ndm> dcoutts_ that is from the cabal file of hslogger, and seems (at least on my machine) to be requiring unix
07:59:43 <ndm>   Requested:    hslogger -any
07:59:45 <ndm>     Using:      hslogger-1.0.4
07:59:47 <ndm>     Depends:    unix -any, base <3, network -any, mtl -any
07:59:54 <ndm> thats from cabal install hslogger -v
08:00:31 <dcoutts_> ndm: ah that's a package bug, there's no such OS as "win32", only "windows" (and also "mingw32")
08:00:52 <ndm> dcoutts_: ah, will email john
08:01:11 <dcoutts_> ndm: and perhaps "cabal check" should look for unknown os names too
08:02:02 <dcoutts_> it's not an enumeration atm, it's a string
08:02:17 <ndm> dcoutts_, would be good :)
08:02:42 <dcoutts_> ndm: should be easy to patch, see Distribution/PackageDescription/Check.hs
08:03:03 <dcoutts_> I'll look forward to receiving a patch :-)
08:03:41 <ndm> dcoutts_: enter it as a beginner bug in the bug tracker
08:03:59 <dcoutts_> ndm: that's just what I was going to suggest :-)
08:04:47 <ndm> anyway, at least that shows even if i had jumped through all the necessary hoops to install missingh, it would have still failed
08:05:09 <dcoutts_> at least without fixing the hslogger.cabal file
08:05:32 <ndm> i actually don't need missingh anymore
08:05:43 <ndm> i just pilfered CVS.hs directly out of it and put it in my tool
08:05:43 <dcoutts_> ndm: the algorithm for resolving deps is not very clever yet or give very good explanations when it cannot find everything
08:06:04 <ndm> dcoutts_, the -v trace, with slightly less junk around, seems perfectly readable
08:06:19 <dcoutts_> ndm: only it's not correct ;-)
08:06:40 <dcoutts_> it can make up impossible installation plans
08:06:41 <ndm> plus you can always bisect it - i wanted missingh, it seemed to be hslogger giving the problem, so retried with just hslogger
08:07:19 <dcoutts_> I'm not sure that's actually right in the general case
08:07:28 <dcoutts_> but usually that's probably true
08:07:43 <dcoutts_> I think in general it's NP hard :-)
08:07:50 <ndm> anyway, its sufficiently cool that i'm willing to accept the occasional screw up at the moment
08:09:30 <dcoutts_> we could probably do with a GSoC project on doing proper package dependency resolution
08:10:25 <shap1> Um hey, who's responsible for hpaste these days?
08:11:06 <shapr`> It looks like scannedinavian.com might be going down for sometime while I search for another virtual host, I thought I'd ask if someone wanted to backup the snippets lib before that happens.
08:11:48 <shapr`> Also, the backup should probably happen today...
08:11:55 <ndm> dcoutts_ definately!
08:12:31 <shapr`> @seen glguy
08:12:31 <lambdabot> I saw glguy leaving #haskell 7h 4m 10s ago, and .
08:13:18 <shapr`> @seen sorear
08:13:18 <lambdabot> I saw sorear leaving #xmonad, #haskell-blah, #haskell and #ghc 8h 42m 3s ago, and .
08:13:38 <shapr`> Hm, maybe I'll just host it at home.
08:16:37 <Lemmih> shapr`: I have space.
08:16:48 <dcoutts_> anyone here use one of the BSDs? what does System.Info.os say?
08:18:12 * ndm hopes for "Linux (but older)" so that Windows doesn't get unfairly maligned with its os string
08:18:29 <shapr`> Lemmih: You want to host hpaste?
08:19:31 <ndm> dcoutts: Module `Distribution.Simple.LocalBuildInfo' does not export `mkDataDir' -- is that a new breakage in Cabal?
08:19:33 <Lemmih> shapr`: Sure.
08:19:44 <dcoutts_> ndm: no, it's been deprecated for ages
08:19:58 <dcoutts_> ndm: but ghc does not report deprecated functions that are imported but not used :-(
08:20:03 <dcoutts_> so not everone noticed
08:20:10 <dcoutts_> ndm: building lhs2tex?
08:20:46 <ndm> dcoutts, yep
08:20:53 <dcoutts_> lhs2tex has far and away the most complex Setup.hs file of any package and currently it's not compiling against development version of Cabal
08:21:05 <newsham> i wrote a tiny lazy untyped lambda calc evaluator in python (with macros in the parser).  its pretty amazing how much of a language you can build with so few lines of code
08:21:10 <Lemmih> shapr`: I can also host scannedinavian if you feel like it. It's not like my server have too many things to do.
08:21:31 <dcoutts_> we'll probably have to add kludges to Cabal before we do a 1.4 release, since we're trying to maintain compatibility with existing packages
08:21:44 <newsham> was able to define let/letrec as macros, and implement standard cons/nil/head/tail/fold/map/sum/etc
08:21:45 <smg> dcoutts_: you were right, no darcs :)
08:22:02 <dcoutts_> ndm: you'll find more issues than just the unused `mkDataDir'
08:22:07 <ndm> dcoutts_: have you told Andres? / kosmikus
08:22:19 <ndm> dcoutts_, i found two issues, that and setupMessage
08:22:38 <dcoutts_> ndm: there's not a lot he can do, if he fixed it for the devel version it'd break for existing users
08:22:39 <ndm> i'm fairly certain that even once you've got the cabal bits fixed, the logic fails on Windows
08:22:45 <ndm> :(
08:22:52 <dcoutts_> ndm: oh that's probably true
08:23:08 <ndm> yeah, i tried installing it on my home machine, and it fell over there
08:23:14 <shapr`> Lemmih: I'll think about it over lunch, bbl
08:23:16 <ndm> so is there any solution?
08:23:43 <dcoutts_> ndm: well I have fixes for the Setup.hs file, but I can't easily fix the logic to make it work windows
08:24:11 <ndm> dcoutts_: i appreciate that, i will debug the setup file a bit, once it works
08:24:30 <ndm> i'm just wondering whether the solution is for cabal to fix itself, or lhs2tex to fix it, or meet in the middle
08:24:42 <ndm> and when there will be a middle ground where i can actually upgrade lhs2tex
08:25:09 <gour> @seen dons
08:25:10 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 8h 50m 40s ago.
08:25:28 <dcoutts_> ndm: I think I'll add some hacks before the 1.4 release to make it work but after that we'll be breaking every non-trivial Setup.hs again
08:26:17 <dcoutts_> the current Setup.hs "api" is too broad, undefined and fragile.
08:26:28 <gour> i've problem with mkcabal, "mkcabal: ./mkcabal.hs:398:4-26: Non-exhaustive patterns in function pair" ?
08:26:46 <dcoutts_> gour: send a patch :-)
08:27:11 <SL> I have a question about the http://www.haskell.org/haskellwiki/Why_Haskell_matters quicksort example. The haskell version goes in every step two times through the whole list where the c++ version does that in one pass. Second the c++ version operates only on the original data, where the haskell version needs more memory to compute the result. Isnt that comparison complete nonsene? haskell gained elegance in expense of computation/m
08:27:11 <SL> emory cost?
08:27:11 <lambdabot> Title: Why Haskell matters - HaskellWiki
08:27:19 <sclv_> personally I find functions exhausting quite often.
08:27:20 <gour> dcoutts_: good idea if i'd know what's wrong
08:27:34 <dcoutts_> gour: look at that line of code and you should see it
08:28:05 <pearman> Hi! What you would recommend to be good way to start learning Haskell. I already know C and C++ quite good and some python also. I just have some difficulties to get started with haskell
08:28:26 <gour> dcoutts_: the line is: pair [x,y]      = (x,y)
08:28:42 <newsham> SL: they're both aprox n log n :)
08:29:23 <SL> newsham, in O notation constants dont matter, but in practice they do
08:29:32 <dcoutts_> gour: ah, well that's a good start, so trace backwards to find out why you've not got exactly two of whatever that is
08:29:34 <sclv_> SL: an in place quicksort is destructive.
08:29:36 <gnuvince> pearman: I bought Graham Hutton's "Programming in Haskell" book, it's pretty good.
08:30:07 <newsham> SL: you could write qsort to create two lists from the original list in a single pass
08:30:13 <newsham> its just a little more complicated (not much)
08:30:42 <sclv_> generally garbage collection will handle most though not all of the issues with mutable vs. immutable data and memory, btw.
08:30:44 <pearman> gnuvince: I have already read some tutorials and wikibooks, but I can't come up with anyideas about what would I do with Haskell
08:30:47 <gnuvince> > partition (<3) [1..10]
08:30:48 <lambdabot>  ([1,2],[3,4,5,6,7,8,9,10])
08:31:01 <gour> dcoutts_: and the problem is that it builds fine, but it fails at runtime :-/
08:31:15 <gnuvince> pearman: you mean as a learning project?
08:31:28 <sclv_> with the advantage that you can still use the unsorted list, should you need to.
08:31:34 <daniel_larsson> gour: I guess 'pair' is called with a list not containing exactly 2 elements
08:31:35 <pearman> gnuvince: Yes. That's what I mean
08:31:52 <dcoutts_> gour: yes, so it's a debugging challenge :-) see where it's called, what the arg means and why it expects a list of length 2 and it's not getting it
08:32:05 <pearman> gnuvince: Just coding some snippets with no point is just boring
08:32:07 <newsham> sclv: the C qsort example also lets you use the original list
08:32:14 <gnuvince> pearman: there's the Scheme in 48 hours tutorial you could look at, or you could try and write something simple that interests you.  I like cribbage, so I wrote a program to count those points.
08:32:18 <dcoutts_> gour: one approach is to add a catch-all case and return error (show args)
08:33:00 * gour thinks dcoutts_ pushes him in cold water :-D
08:33:07 <newsham> err.. not entirely, but it does make a copy for the two temp intermediate lists
08:33:59 <pearman> gnuvince: I have to think more then. The problem with *nix world is that there exist always bettar program than your own
08:34:01 <sclv_> pair is called in like two places only, it looks like.
08:34:22 <newsham> pm: thats a problem?
08:34:48 <gnuvince> pearman: that may be true, but there's no better way to learn than to practice.  So don't mind what those other hackers did, and work on your personal improvement.
08:35:18 <mrd> the canonical haskell qsort example is not really qsort
08:36:23 <SL> hm, I think its a really bad example to convice a c-person
08:37:04 <gnuvince> SL: how would you convince a C person?
08:37:11 <hpaste>  ndm pasted "hslogger install errors" at http://hpaste.org/6013
08:37:14 <wli> Golfing is probably not the way in general. Perhaps concurrency and parallelism are better.
08:37:46 <ndm> dcoutts, see that hpaste - John has upgrade hslogger, but i get a very weird last line of the install (which seems to have succeeded)
08:37:56 <mrd> I cringe a bit when I see that qsort example paraded around
08:38:05 <pearman> gnuvince: I know that. I just have some motivation problems. Maybe I will try come up with some ideas. I have some alreydy, but those are too hard for me to programm in Haskell
08:38:15 <wli> Or otherwise more in-depth examples more generally.
08:38:27 <sclv_> right... but is the equiv C. code given really qsort either?
08:38:33 <sclv_> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
08:38:33 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2hq6cn
08:38:46 <dbpatterson> is there any type for UTC seconds? I see Data.Time.Clock.UTCTime - but that is days and seconds in the day... and I dont want to reinvent something (even if it is simple) if it already exists
08:38:50 <mrd> it's not
08:39:09 <mrd> i have an in-place randomized qsort implementation with haskell arrays somewhere
08:39:44 <dcoutts_> ndm: I bet deleting the temp dir failed, currently the real exception is being hidden by the more "helpful" error message
08:39:54 <sclv_> The mergesort is sort of cool and elegant when you get it, and you can also see the source for the old std. quicksort here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#mergesort
08:39:54 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2gpya5
08:39:58 <quicksilver> I think the "qsort" example is a cute example of haskell expressiveness, notwithstanding that it isn't a "real" qsort.
08:40:12 <quicksilver> the point is not to overdo it.
08:40:31 <mrd> merge-sort would be a better example
08:40:35 <ndm> dcoutts, it seems to happen with every installation i do
08:40:40 <EvilTerran> haskell mergesort's pretty cool, too
08:40:42 <mrd> also, show how it is trivial to parallelize in haskell
08:40:44 <dcoutts_> ndm: I ran into a problem like that before, it looks like it failed deleting some file that ghc-pkg had had open, but we'd waited for ghc-pkg to terminate so it doesn't make sense
08:41:04 <sclv_> someone should probably edit the page and note that it isn't a real qsort, just like one needs a std. disclaimer before naive fibs functions to avoid the inevitable complaints.
08:41:15 <dcoutts_> ndm: so you should find that the temp dir used for that package has not been deleted
08:41:43 <dcoutts_> ndm: though I couldn't tell you where the dir is :-) wherever getTemporaryDir reports on windows
08:41:47 <Philippa> rather, it should note that while it follows the letter of the quicksort algorithm, it's on the wrong structures and it's not an in-place sort (which is technically a modification of quicksort, though it's what everyone means by it)
08:42:09 <Philippa> someone might want to write an in-place quicksort on mutable arrays with things like an explicit pivot function though
08:42:22 <quicksilver> Philippa: augustss's blog post contains one example.
08:42:25 <Philippa> because that's not much longer and ought to be pretty clear about the structure of the in-place algorithm
08:42:34 <quicksilver> Philippa: it's not really haskell because it uses his type-class-heavy DSL.
08:42:36 <mrd> randomization of pivot is more important than in-place, imo
08:45:01 * wli typically prefers heapsort, in part due to online update characteristics (i.e. maintain the heap during insertions and removals and it's swift to reestablish full sorting).
08:45:42 <dcoutts_> ndm: http://haskell.org/~duncan/cabal/lhs2tex-1.13-CabalDevel-Setup.hs
08:47:03 <Philippa> mrd: the choice of pivot's mostly irrelevant to the algorithm spec though, and I don't need to explain why we don't want to show a version with a random pivot to start with?
08:47:18 <Philippa> (but we can show one that's parameterised on a pivot function, for example)
08:48:36 <quicksilver> I like to bubble-sort first, and then choose the middle element. That makes an ideal pivot and my quicksort runs nicely.
08:48:39 <mrd> yes, i realize it's messier, but without randomization, qsort is just a worst-case O(n^2) algorithm.  at least with randomization, it's _expected_ worst-case is O(nlogn)
08:50:25 <mrd> quicksilver: my brain is rusty, but doesn't that give you a recurrence of T(n)=2T(n/2) + O(n^2) which solves to O(n^2log n)
08:51:24 <wli> Bubblesort is not even good as a pedagogical example. Selection sort is the best "stupider-than-thou" algorithm.
08:51:46 <Philippa> mrd: it's not just that it's messier, it's /much/ messier from a newbie POV and most newbies don't even recognise the need for a random pivot
08:51:52 <Deewiant> insertion sort is better than selection or bubble sort
08:52:25 <wli> Deewiant: From a pedagogical POV insertion sort is more difficult for the uninitiated to digest.
08:52:29 <Philippa> ("from a newbie POV" - it's much messier conceptually
08:52:32 <Philippa> )
08:52:43 <quicksilver> insertion sort is how many (most?) card players will sort their hand
08:52:48 <Deewiant> I always have and still do find insertion sort simpler to understand than bubble sort :-)
08:52:50 <quicksilver> but they have the advantage of O(1) insert.
08:53:01 <quicksilver> well, sort-of.
08:53:02 <smtms> quicksilver, you must teach them playing cards first, to teach them insertion sort ;-)
08:53:09 <Philippa> quicksilver: that and it's not being used one off
08:53:21 <osfameron> well O(some complex thing involving neurons and pattern matching)
08:53:25 <pearman> What would be good editor for Haskell programming? I use Xubuntu + OpenBox and the editor should be very ligth weigth. Now I use Geany but is there better programs?
08:53:26 <Philippa> card players will (if they sort their hand at all) /maintain/ a sorted hand
08:54:01 <Philippa> depending on what game you're playing you might choose to not sort because people can observe your doing so (albeit w/cards face-down to them)
08:54:45 <wli> Insertion sort is obvious conceptually but trickier than selection sort to translate into code for the totally unprepared freshman CS cadres.
08:55:05 * wli draws on CS TA'ing experience.
08:55:11 <quicksilver> "insertion sort" with haskell lists
08:55:18 <quicksilver> is easier than "insertion sort" with java arrays
08:55:20 <Philippa> wli: which lang and data structure were you using, OOI?
08:55:27 <quicksilver> because you don't have to explicitly shift stuff down.
08:55:28 <Philippa> yeah, by a very long way indeed
08:55:38 <Philippa> insertion sort on arrays has teh dumb
08:56:34 <wli> Philippa: C and arrays.
08:56:50 <bltrout> pearman: emacs is pretty nifty.
08:57:04 <bltrout> Assuming you've installed haskell-mode, of course.
08:57:33 <wli> No Haskell, no Java, no C++. And actually these guys were sophomores but I have no idea what, if anything they learned as freshman, because they were operating at or below freshman levels AFAICT.
08:57:44 <pearman> bitrot: Any gui programs?
08:58:14 <Philippa> wli: being forced to use stupid structures in an abstraction-light language rather distorts how well things can be taught
08:58:18 <wli> (The next year I TA'd freshmen with Java and found out how bad it was.)
08:58:47 <bltrout> bltrout: Emacs will use X11, if you desire.
08:59:51 <pearman> bitrot: Maybe I should give emacs it change, last time I tried it I almost hated it. I donät want to spent my time learning 100 different key combinations
09:00:47 <wli> Philippa: It was one of the few uni's in the US that did any OS -oriented anything (Doug Comer was there; the other quasi-specialty was numerical analysis, e.g. Gautschi, Sameh, and Rice were there), so it was very C/Fortran -oriented with some justification.
09:01:03 <bltrout> pearman: I use 10 on average. A cheat-sheet, as it were, would be a good thing to look up.
09:01:16 <bltrout> Also, it's B. L. Trout
09:01:20 <bltrout> :)
09:01:41 * mrd is puzzled by people with strange economy of motion.  a few keystrokes will save you countless hours of mousing around.
09:02:13 <pearman> I have three arms so one can operate mouse...
09:02:42 <mrd> ah, well, i suppose PCs were well designed for the 3-armed
09:02:50 <bltrout> Zaphod, is that you?
09:03:07 <gnuvince> bltrout++
09:03:13 <mrd> did he have 3 arms or just 2 heads?
09:03:18 <gnuvince> both
09:03:24 <bltrout> Both. He had an arm installed.
09:03:26 <mrd> dual monitor
09:03:41 <pearman> mrd: In future will people evolve to have 3 arms for more efficient using of computers
09:03:58 <resiak> pearman: two human arms and a CP?
09:04:03 <resiak> *CPU
09:04:36 <pearman> resiak: 2 for typing and one for mouse. So there will be probably 2 rigth arms and 1 left arm
09:05:17 <pearman> Today I suck at writing english
09:05:20 <mrd> mammals are symmetric -- so it would have to be an arm sprouting from the middle of your chest
09:05:30 <mrd> with 6 or 4 fingers
09:05:48 <kaol> I'd rather see humans evolve RJ45 sockets
09:06:06 * bitrot notices "bitrot" and "bltrout" look similar
09:06:08 <mrd> kaol: now c'mon -- wireless
09:06:34 <pearman> mrd: I was just thinking the same. And there would be no antennas
09:06:45 <bitrot> drink some koolaid, you'll get bluetooth
09:06:59 * bltrout wishes the nick "blt" weren't taken.
09:11:31 <quicksilver> key combinations are entirely optional.
09:11:39 <quicksilver> oops. ignore that.
09:14:23 <glguy> Anyone know what library I need to link in for atexit(3) to be available?
09:15:38 <pejo> glguy, it's in libc on my platform. The manpages for the function usually tells the library to link against.
09:16:21 <glguy> pejo: I don't have the manpage for that function for some reason :(
09:16:57 <bltrout> glguy: http://linux.die.net/man/3/atexit
09:16:57 <lambdabot> Title: 1a atexit(3) - Linux man page 9
09:17:00 <pejo> glguy, what platform?
09:17:21 <glguy> Fedora, I probably need to install some package
09:18:06 <glguy> I'm trying to link it into a haskell library
09:18:15 <dejones> ?src map
09:18:15 <lambdabot> map _ []     = []
09:18:15 <lambdabot> map f (x:xs) = f x : map f xs
09:21:01 <glguy> fedora apparently doesn't install man pages be default
09:21:08 <glguy> had to add the man-pages package
09:22:38 <glguy> any guesses as to why the atexit symbol wouldn't be found when  I load this library in ghci
09:23:15 <mightybyte> http://softwaresimply.blogspot.com/2008/02/how-i-learned-to-stop-worrying-and-love.html
09:23:16 <lambdabot> Title: Software Simply: How I Learned to Stop Worrying And Love Haskell's Type Inferenc ..., http://tinyurl.com/2duemm
09:28:29 <mightybyte> ^^^ it's probably a little elementary for most people here though.
09:30:05 <nathanic> some of us lurking noobs might appreciate it :-)
09:30:52 <mightybyte> Good. :)
09:35:36 <Saizan> err.. why is Monoid w a superclass of MonadWriter? couldn't they leave that decision to instances?
09:37:07 <sm> mightybyte: very nice , thanks
09:37:51 <sclv_> Saizan: hmm... good question.
09:38:52 <dolio> Saizan: You need something like the operations of a monoid for writer, so why not?
09:40:28 <Toxaris_> mightybyte: are you aware of asks? it captures to idiom of applying a pure function to the result of ask
09:40:45 <Saizan> dolio: because i stumble into overlapping instances if i declare the one i need
09:41:05 <mightybyte> Toxaris_: No, I wasn't.
09:41:23 <Saizan> dolio: i can still newtype, but it seems a bit silly
09:41:25 <Toxaris_> authUser2 name pass = asks $ (Just pass ==) . liftM password . M.lookup name
09:41:29 <Toxaris_> something like this
09:41:41 <mightybyte> Toxaris_: That's part of my problem.  I don't know about all the tools at my disposal.
09:41:41 <dolio> Saizan: What do you need?
09:42:21 <mightybyte> Toxaris_: Ok, that's really nice.  Avoids the need to bind.
09:43:04 <Saizan> dolio: A -> A as in Endo, but the monad is not defined with Endo, i guess i just have to unwrap on the boundaries
09:43:26 <Saizan> dolio: and add a custom "tell"
09:43:46 <Saizan> but then i might just write my own class..
09:45:32 <dolio> Hmm.
09:46:35 <mikael> do I need a very recent GHC or some flag to use forall in a 'type' declaration?
09:46:44 <mikael> I get parse error on => with ghc 6.8.1
09:47:11 <Toxaris_> mightybyte: you can see it like this: the Reader monad is an alternative to an additional parameter to pass the context around explicitly. runReader and asks transform between explicit context passing (which is handy for these parts of your program which actually need the context) and the Reader monad (which is handy for these parts of the program don't needing the context for automatic context passing)
09:47:37 <Toxaris_> mightybyte: seen this way, asks is "more primitive" then ask
09:47:48 <hallongrottan> mikael: i dont think that is even possible, me and Smurfen_ tried that
09:47:51 <Saizan> mikael: why do you use the forall?
09:48:07 <wli> Hmm, undefined reference to `Cabalzm1zi2zi3zi0_SystemziFilePathziPosix_combine_info'
09:48:08 <Saizan> mikael: there are different extensions that need that syntax.
09:49:30 <sclv_> mikael: you need a pragma for foralls in general: LANGUAGE ExistentialQualification, I think is the simplest one.
09:50:47 <mikael> okay, my actual problem is: I want to define a synonym MArray16 e m, so I can use MArray16 String m instead of MArray a String m => a Word16 String
09:51:14 <wli> Looks like i just had to re-emerge cabal.
09:51:24 <mightybyte> Toxaris_: Interesting.
09:52:44 <Saizan> mikael: that won't work as you expect
09:53:24 <dbpatterson> can I ask, why is toInteger not the inverse of fromInteger (ie, Num -> Integer), and (obviously) what is th easiest way to make that conversion?
09:53:32 <explisixjelly> i want to compose a non-monadic function with a monadic function
09:53:34 <dolio> std::accumulate(start, end, 0, (_1 ->* &Item::price) + (_2 ->* &Item::price));
09:54:18 <smg> some c++ in here? :]
09:54:20 <Toxaris_> explisixjelly: use liftM
09:54:31 <explisixjelly> Toxaris_, ah, of course, thanks
09:54:40 <smg> stands fmap for file map?
09:54:48 <mikael> hallongrottan: who are you, by the way? :-)
09:54:51 <dolio> Functor map.
09:55:10 <mikael> Saizan: is there a way to accomplish something like it?
09:55:18 <hallongrottan> mikael: i'm Tobsan :)
09:55:19 <Toxaris_> dbpatterson: what would (toInteger (1 / 2)) return?
09:55:22 <explisixjelly>   (matchexps, vars) <- (liftM unzip) . mapM (uncurry fcodifyMatch) (zip args matches)
09:55:27 <dolio> smg: Yeah. Someone was using that as an example of how nice boost.lambda makes functional programming.
09:55:32 <mikael> hallongrottan: haha okay, hi
09:55:35 <hallongrottan> hi
09:55:54 <hallongrottan> have you finished the CGI task?
09:56:09 <jaredj> it's really nice for c++
09:56:24 <dbpatterson> Toxaris_: 0?
09:56:33 <mikael> hallongrottan: well, it's submitted, but we'll probably have to make the CGI example more involved
09:56:34 <Toxaris_> dbpatterson: I think you want one of floor, ceil or round
09:56:38 <Toxaris_> dbpatterson: why not 1?
09:56:47 <hallongrottan> mikael: oh
09:56:49 <Toxaris_> dbpatterson: or error
09:56:54 <dbpatterson> Toxaris_: no I understood your point..
09:56:59 <shap1> Hej phubuh!
09:57:04 <dbpatterson> understand*
09:57:06 <mikael> hey, shapr!
09:57:11 <shapr`> How's life treating you?
09:57:14 <mikael> long time :-)
09:57:20 <shapr`> Yeah, years
09:57:44 * jaredj goes in for the tearful closeup shot :)
09:57:47 <mikael> very well, ulf norell's advanced functional programming course and aarne ranta's programming language course is spending most of it
09:58:00 <Toxaris_> > (floor (1 / 2), ceiling (1 / 2)) -- dbpatterson: oups, ceiling
09:58:01 <lambdabot>  (0,1)
09:58:42 <dbpatterson> Toxaris_: but floor, ceiling, and round, all take RealFraq, not Num
09:58:45 <dolio> jaredj: I suppose kudos are in order for their going highly theoretical and using de Bruijn indices. :)
09:58:56 <mikael> just started working on my course project, which I think is going to be a somewhat bluebook-faithful implementation of smalltalk 80 in haskell :-)
09:58:58 <dbpatterson> s/Fraq/Frac/
09:59:31 <mikael> shapr: how are you, where do you live these days?
09:59:52 <hallongrottan> mikael: oh, that sounds quite hard :o
10:00:05 <hallongrottan> i'll probably find some embedded language to implement
10:00:18 <jaredj> dolio: i still haven't gotten used to those..
10:01:11 <dolio> jaredj: More or less, you don't name your parameters. Instead, you refer to them by number, 1 being the nearest enclosing, 2 being the one outside that, etc.
10:01:12 <desegnis> dbpatterson, I'd guess the major reason for the restriction of toInteger's type is that we want   toInteger.fromInteger  =  id;  fromInteger.toInteger  =  id.
10:01:17 <mikael> hallongrottan: maybe it's too ambitious, but smalltalk is one of the smallest (duh) and simplest languages, both to parse and run, I think
10:01:39 <Toxaris_> dbpatterson: If I understand Haskell's numbers correctly (which I'm not too sure about), RealFrac is exactly the type class of non-integral numbers convertable to integral numbers
10:01:49 <hallongrottan> mikael: haha, ok
10:02:07 <desegnis> dbpatterson, specifically the former
10:02:11 <jaredj> 'nearest enclosing' makes a lot of sense. my book didn't say exactly that
10:02:14 <dolio> jaredj: So, say, \x.\y.\z. z y x becomes \\\ 1 2 3, or something like that.
10:02:34 <gbacon> if I have multiple versions of Cabal installed, how do I force the older version? using cabal-version in the cabal file caused a constraint error
10:02:56 <dbpatterson> Toxaris_, desegnis: still, this doesnt help, as I have something that is Num, but not RealFrac (Data.Time.DiffTime) which I need to convert to an Integer.
10:03:00 <gbacon> Build-Depends: Cabal > 1.2 && < 1.3, ... ?
10:03:36 <dbpatterson> Toxaris_, desegnis: if it had a constructor that I could find... (not just a function, secondsToDiffTime) pattern matching would eliminate this problem, but....
10:03:59 <dcoutts_> gbacon: if you're just running Setup.hs you can runghc -package Cabal-x.y Setup.hs
10:04:10 <explisixjelly> finding operator names isn't easy %)
10:04:20 <dcoutts_> gbacon: or if you want to use the old version all the time then hide the newer one
10:04:58 <gbacon> dcoutts: but what if I don't know the version of Cabal that will be used?
10:05:36 <gbacon> i.e., on someone else's box
10:05:57 <dcoutts_> gbacon: I guess I'm not sure what you're trying to do. Are you writing a package and you know it only works with some version of cabal?
10:06:25 <gbacon> I'm hacking Pugs.cabal
10:06:51 <Toxaris_> dbpatterson: try fromEnum
10:06:52 <gbacon> it builds a private package db, but I don't think older versions support --package-db
10:07:03 <stevan> hi, is there an other way of doing the following on one line: do x <- foo a; y <- foo b; return $ x + y ?
10:07:08 <dcoutts_> gbacon: ok, so specify cabal-version: >= 1.2 or something like that
10:07:21 <Toxaris_> dbpatterson: by looking at the code, it should do what you want. http://haskell.org/ghc/docs/latest/html/libraries/time/src/Data-Time-Clock-Scale.html#DiffTime. it's a hack, of course :)
10:07:22 <lambdabot> http://tinyurl.com/yrbwo8
10:07:25 <Cale> stevan: liftM2 (+) a b
10:07:43 <Botje> liftM2 (+) (foo a) (foo b)
10:07:44 <Botje> even
10:07:53 <Cale> er, right
10:07:53 <dcoutts_> gbacon: indeed no released version supports --package-db
10:07:55 <gbacon> dcoutts_: yes, that's there, and I tried modifying that line to >= 1.2 && < 1.3, but then configure failed complaining of a constraint failure
10:08:06 <Toxaris_> dbpatterson: instance Enum DiffTime where ... fromEnum (MkDiffTime a) = fromEnum a ...
10:08:11 <dbpatterson> Toxaris_: fromEnum (secondsToDiffTime 100) should be 100 if this works, but its not, it is 276447232
10:08:44 <dcoutts_> gbacon: how were you configuring (ie runghc Setup.hs or using cabal-install?) and what version of cabal were you using?
10:08:45 <stevan> Cale: Botje thanks!
10:09:15 <gbacon> ghc-pkg reports Cabal-1.2.3.0, Cabal-1.3.3
10:09:25 <gbacon> configuring with Setup configure
10:09:30 <dcoutts_> gbacon: Setup.hs does a trivial test to see if the version you are using is ok
10:09:56 <dcoutts_> gbacon: if you're using runghc Setup.hs then you've already picked a Cabal version so there's nothing Cabal can really do at that point
10:10:19 <dcoutts_> gbacon: the cabal-install front end can select an available version of the Cabal lib that satisfies the constraint
10:11:33 <dcoutts_> gbacon: btw, what fails with Cabal-1.3.x? We're trying to make it compatible.
10:11:35 <Toxaris_> dbpatterson: that's 2^28. maybe an int overflow occured? try an explicit (:: Integer)
10:11:44 <Toxaris_> or is fromEnum restricted to Int?
10:12:01 <Toxaris_> it is :( so the hack doesn't work :(
10:12:31 <gbacon> dcoutts_: pugs installs some libraries to a private db in third-party installed; Setup configure complains of unsatisfied dependencies
10:12:52 <gbacon> dcoutts_: I can work around it with --package-db, but I'm wondering how it ever resolved in the first place
10:13:09 <desegnis> dbpatterson, round . toRational works for me
10:13:14 <gbacon> to a private db in pugs/third-party/installed, that is
10:13:29 <dcoutts_> gbacon: how were you specifying to use an additional package db? The old versions of Cabal do not explicitly support that feature, the devel version of cabal does.
10:13:32 <desegnis> dbpatterson, although that feels a little awkward
10:14:07 <gbacon> dcoutts_: right, with Cabal-1.3.3, I say configure -f ~/src/pugs/third-party/installed/package.conf, and it's happy
10:14:08 <dbpatterson> desegnis: yeah, well, it woudl be nice if there was just a diffTimeToSeconds in the first place, but this works, so thanks..
10:14:42 <gbacon> no, sorry, configure --package-db=...
10:14:48 <dcoutts_> gbacon: right :-)
10:14:55 <gbacon> was thinking of ghc-pkg
10:16:58 <dcoutts_> gbacon: so people figured out a hack to make that work with older cabal, by passing some env var to ghc-pkg and telling cabal to use --user
10:17:41 <dcoutts_> gbacon: so that was never supported and doesn't work any more but you can now use --package-db=
10:18:02 <dcoutts_> gbacon: so if you're trying to make it work with both, that's going to be a bit tricky
10:18:21 <mapreduce> @seen gigamonkey
10:18:21 <lambdabot> I haven't seen gigamonkey.
10:19:03 <gbacon> dcoutts_: no, I'd be happy to force Cabal-1.2.x but make it explicit in case someone else with a similar config to mine doesn't have to fight this same issue
10:19:28 <dcoutts_> gbacon: then keep the cabal-version: >= 1.2 && < 1.3
10:20:29 * gbacon scratches his head
10:20:38 <gbacon> I thought I'd already tried that and got a constraint failure
10:20:45 <gbacon> ohhhh
10:20:48 <dcoutts_> gbacon: that's because you were using Cabal-1.3.x
10:20:59 <gbacon> Setup.lhs was linked against Cabal-1.3.3
10:21:03 <dcoutts_> yep
10:21:08 <gbacon> if I runghc it, it's happy
10:21:22 <gbacon> but it still doesn't find the dependencies
10:21:43 <dcoutts_> though note that if you have both Cabal-1.2.x and 1.3.x exposed then ghc picks the highest version
10:22:14 <desegnis> dbpatterson, now that I've looked at it, I think you may consider it a bug that DiffTime is not in RealFrac (because Data.Fixed.Fixed, on which DiffTime is base, is)
10:22:23 <desegnis> *based
10:22:41 <dcoutts_> gbacon: older cabal will only find what ghc-pkg --user list finds
10:22:59 <gbacon> dcoutts_: that's what I mean: I wonder how it ever resolved
10:23:19 <gbacon> it looks like it baked in the private db while compiling Setup.lhs
10:23:39 <dcoutts_> gbacon: oh, that's possible I guess
10:23:51 <dcoutts_> gbacon: I've seen other people do it by passing an env var to ghc-pkg
10:24:06 <gbacon> where does ghc-pkg come into play?
10:24:23 <gbacon> does Setup configure invoke ghc-pkg?
10:24:29 <dcoutts_> yes
10:24:56 <dcoutts_> to find what packages are available
10:25:03 <dcoutts_> use -v2 to see how it calls it
10:25:41 <gbacon> ah, yes, and they have a ghc-pkg-wrapper
10:25:52 <dcoutts_> gbacon: then depending on the configure --user/--global flag it either looks at the first section or all sections
10:26:35 <gbacon> ok, so when it's linking Setup.lhs, how can I force a Cabal whose version is >= 1.2 && < 1.3?
10:26:39 <dcoutts_> gbacon: btw, it'd be great if the pugs developers reported the features that they need and are making up hacks for, then there'd be a chance the features would be in the next version :-)
10:26:50 <gbacon> :-)
10:26:55 <dcoutts_> gbacon: as it is we get nothing from them and yet they have all this stuff they need
10:27:04 <dcoutts_> I mean we get no info from them
10:27:12 <gbacon> --package-db solves the problem nicely
10:27:19 <dcoutts_> like it'd be interesting to know that they require registering local packages
10:27:30 <dcoutts_> because there are almost certainly better ways of supporting that
10:27:35 <dcoutts_> beyond --package-db
10:27:42 <gbacon> local packages are being installed and then with ghc-pkg expose pugs-$module
10:28:03 <dcoutts_> gbacon: so if they could describe their needs precisely we could bear that in mind when designing new stuff.
10:28:09 <gbacon> :-)
10:28:34 <dcoutts_> gbacon: I'm not grumbling at you personally :-)
10:28:42 <gbacon> I understand
10:30:00 <dcoutts_> gbacon: so I guess what pugs is trying to do is build a bunch of related packages and register them locally so that it can build the dependent ones without installing and registering everything first (which is perfectly reasonable thing to want to do)
10:30:18 <gbacon> dcoutts_: correct
10:30:34 <dcoutts_> so that's really what we should be aiming to support, --package-db is rather low level for that
10:31:59 <gbacon> but in the meantime, when compiling Setup.lhs, how do I force it to link against Cabal >= 1.2 && < 1.3?
10:32:10 <gbacon> it looks like -package requires a precise version number
10:32:22 <dcoutts_> gbacon: right, that's not very easy
10:32:33 <dcoutts_> gbacon: if both are available and exposed
10:32:52 <gbacon> dcoutts_: so would it be better then to runghc rather than using a compiled Setup?
10:33:14 <dcoutts_> gbacon: the best you can do I think is to have a script that looks at the output of $ ghc-pkg list --simple-output Cabal
10:33:33 <gbacon> and -package that one?
10:33:43 <dcoutts_> gbacon: right, find one that is 1.2.x
10:33:50 <gbacon> hehe, poor man's Cabal
10:33:51 <dcoutts_> and -package ${that_version}
10:33:56 * gbacon nodsnods
10:34:13 <dcoutts_> gbacon: that's basically what the cabal-install command line front end does
10:34:27 <gbacon> dcoutts_: thank you very much for your help
10:34:38 <Cale> Has anyone seen this: http://garfieldminusgarfield.tumblr.com/page/1
10:34:38 <lambdabot> Title: garfield minus garfield
10:34:52 <dcoutts_> gbacon: np. Sorry it's a bit clumsy.
10:35:01 <Cale> It turns out that the comic strip is a whole lot funnier without Garfield in it.
10:35:33 <smg> uhm, what's a functor?
10:35:37 <gbacon> dcoutts_: at least now the issue has been brought to your attention!
10:35:42 <Cale> smg: In general, or just in Haskell?
10:35:44 <dcoutts_> gbacon: imho the Setup.hs interface was a bad design decision
10:35:57 <gbacon> dcoutts_: on the part of pugs or Cabal?
10:36:05 <dcoutts_> gbacon: Cabal
10:36:15 <smg> Cale: in haskell, fmap is a functor but i don't understand it's use
10:36:28 <Cale> smg: It's a data constructor F together with a function of type (a -> b) -> (F a -> F b)
10:36:35 <dcoutts_> gbacon: having cabal-install as the entry point is much more robust
10:36:36 <Cale> (which is called fmap in Haskell)
10:37:05 <Cale> That function must satisfy:  fmap id = id, and fmap (f . g) = fmap f . fmap g
10:37:24 <Cale> Basically, this is a way to generalise map to other datastructures.
10:37:39 <Cale> What map does for lists, fmap does in general.
10:37:40 <smg> mh okay, when comes this fmap to use?
10:37:46 <smg> ah
10:42:55 <ndm> dcoutts_: by regularly breaking it, are you hoping that people will move to not using it?
10:43:21 <ivan__> is it possible to check if a Double is Zero?
10:43:42 <dcoutts_> ndm: we can hardly be held accountable for breaking things that we never knew worked, we never knew they were using and probably never should have worked.
10:44:02 <ndm> dcoutts_: i entirely agree, i think the Setup.hs thing was a very bad idea
10:44:06 <Cale> ivan__: It's possible, but not particularly advisable, since rounding errors could mean that you get a number close to, but not quite zero.
10:44:22 <Cale> ivan__: You can just use x == 0 to test.
10:44:26 <ndm> dcoutts_: what you do need however is to have some way of cabal tests not using Setup.hs - since you want to both encourage tests and discourage Setup.hs
10:44:43 <dcoutts_> ndm: build-type: Simple
10:44:55 <ivan__> yes i know but when is it true can i type 0.00000000000000000001 == 0 ?
10:44:59 <dcoutts_> ndm: all packages uploaded to hackage now require specifying the build-type.
10:45:02 <ndm> dcoutts_: but how do you put back in tests?
10:45:22 <dcoutts_> ndm: that needs another new mechanism I think
10:45:38 <dcoutts_> ndm: it's silly to require custom build type just to run tests
10:45:45 <swidgy> > 0.00000000000000000001 == 0
10:45:46 <lambdabot>  False
10:46:09 <dcoutts_> ndm: and the current test system is no good and approximately nobody uses it
10:46:15 <ndm> dcoutts_: strongly agreed, tests: <command line> is my suggestion
10:46:33 <ndm> dcoutts_: i think i'm the only user, but for the life of me, i can't remember _which_ project i set up to use cabal tests
10:46:38 <Cale> ivan__: If you want to know if some number is within some interval of 0, you can just use abs and then compare the result with some epsilon.
10:46:43 <dejones> is it possible to iterate through the elements stored in a Hash table?  or to get a list of the keys in the Hash table?
10:46:58 <dcoutts_> ndm: here's my suggestion: http://hackage.haskell.org/trac/hackage/ticket/215
10:46:59 <lambdabot> Title: #215 (Overhaul support for package's tests) - Hackage - Trac
10:47:09 <swidgy> > abs 0.00000000000000000001 < 0.0000000001
10:47:10 <lambdabot>  True
10:47:13 <dejones> I guess the only way is with HashTable.toList ?
10:47:33 <oerjan> > until ((==0).(/2)) (/2) 1
10:47:34 <lambdabot>  0.0
10:47:38 <oerjan> oops
10:47:50 <dcoutts_> ndm: if you have any comments add them to the ticket, I'd be interested to know what you think
10:47:51 <oerjan> > until ((==0).(/2)) (/2) 1 == 0
10:47:52 <lambdabot>  True
10:48:03 <oerjan> :t until
10:48:05 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
10:48:36 <stevan> is there any nicer way of doing the same thing as ".) ." does in ((not .) . (<)) 1 2 or is lambda notation best in this case? thanks.
10:48:50 * oerjan wonders why that doesn't stop the step _before_ reaching 0
10:48:57 <wli> > let eps = until ((== 1) . (1+)) (/2) 1 in (eps :: Double, eps :: Float)
10:48:58 <lambdabot>  (5.421010862427522e-20,5.421011e-20)
10:49:18 <dcoutts_> stevan: I tend to think that explicit lambdas are better once you get to the level of ((f.) .) stuff
10:49:24 <DQuest> hmm, now how does that work?
10:49:34 <DQuest> aha, nevermind
10:49:42 <DQuest> let x = 1 in (x :: Int, x :: Double)
10:49:45 <oerjan> > last . takeWhile (/= 0) . iterate (/2) $ 1
10:49:45 <lambdabot>  5.0e-324
10:49:48 <DQuest> > let x = 1 in (x :: Int, x :: Double)
10:49:48 <lambdabot>  (1,1.0)
10:49:52 <oerjan> ah
10:49:57 <DQuest> I thought it was part of the type for the whole thing for a moment
10:50:21 <wli> Not quite what I expected.
10:50:24 <oerjan> > 5.0e-324
10:50:24 <lambdabot>  5.0e-324
10:50:33 <wli> > let eps :: Floating t => t ; eps = until ((== 1) . (1 +)) (/ 2) 1 in (eps :: Double, eps :: Float)
10:50:34 <lambdabot>  (5.421010862427522e-20,5.421011e-20)
10:51:01 <wli> Locally, I get (1.1102230246251565e-16,5.9604645e-8)
10:51:04 <gbacon> dcoutts_: runghc -package Cabal-1.2.3.0 Setup.lhs configure --help complains that it can't load interface for 'Main'
10:51:55 * gwern thinks this tests stuff is kind of silly - tests should be run by the developers, not end-users or installers, and so far using darcs hooks seems to work quite well
10:52:46 <dcoutts_> gbacon: I'm not sure what's going on there
10:53:19 <dcoutts_> gwern: the end users are in a different environment to the developers, it's useful to run there too
10:53:44 <dcoutts_> gwern: and if we can run them automatically we can put that info on hackage, test coverage etc
10:54:27 <oerjan> wli: i think with some options ghc uses a more precise internal CPU format for intermediate numbers
10:54:36 <gwern> then the devs should be testing in those environments as well; I don't buy that putting stuff on hackage has much value - nobody uses all the cabal and hackage features as it is!
10:55:03 <wli> oerjan: That sounds dangerous.
10:55:33 <oerjan> wli: there's a flag for it, i believe
10:57:09 <ndm> dcoutts_: responded (forgetting to sign it)
10:57:10 <dcoutts_> gwern: I don't have an OSX machine so I cannot test gtk2hs there but I can write a testsuite that users or other devs can run
10:57:17 <oerjan> wli: -fexcess-precision
10:58:09 * wli fails to emerge gslhaskell-darcs
10:58:09 <dcoutts_> ndm: my point is about machine readable test output, not just a text log
10:58:11 <gwern> dcoutts_: can you cabalize gtk2hs?
10:58:14 <ndm> gwern: i hate darcs hooks for testing, and when people have emailed me patches to add them i have rejected them
10:58:21 <dcoutts_> gwern: not yet
10:58:35 <ndm> dcoutts_: why? pass/fail seems like all the info you need, and then a human can read the log
10:58:49 <radix> ndm: yeah, I'd rather have them for publishing than committing
10:58:52 <dcoutts_> ndm: that's no good for collecting and analysing
10:59:02 <ndm> dcoutts_: analysing and collecting what?
10:59:08 <dcoutts_> ndm: the test results
10:59:30 <ndm> dcoutts_: "tests fail"/"tests pass" seems plenty of information - what are you hoping to do more than that?
11:00:02 <dcoutts_> ndm: which tests fail
11:00:03 <oerjan> wli: it seems to be implied by -O settings
11:00:03 <wli> Hmm GSL/Common.hs:25:7: Could not find module `Data.Array': it is a member of package array-0.1.0.0, which is hidden
11:00:35 <dcoutts_> wli: http://haskell.org/haskellwiki/Cabal/FAQ
11:00:42 <ndm> dcoutts_: in general, it would be nice if packages on Hackage didn't have failing tests
11:00:58 <ndm> dcoutts_: i think you are going for something like GHC's test suite, when what we want is something simpler
11:01:06 <dcoutts_> ndm: it's inevitable given variations in platform and dependencies
11:01:28 <ndm> dcoutts_: i think individual developers can track this stuff perfectly easily if they can have a text log
11:02:03 <ndm> i don't see much use for any automated statistics over it - but if you give me a compelling example, i'll happily change my mind
11:02:31 <ndm> and you can always allow logs to contain lines such as "Error in test ####: description", then have a separate tool that does something with that, if individual developers want it
11:02:52 <ndm> but very few projects will probably ever want it, only things on the scale of compilers, perhaps GUI toolkits - certainly not normal libraries
11:02:59 <dcoutts_> ndm: dons can probably find you the killer example, but it's things like number of tests, tracking test failures
11:03:12 <Philippa> ndm: it's pretty useful to have a user-visible history where there're portability issues
11:03:15 <dcoutts_> ndm: especially useful for non-released versions actually, during development
11:03:37 <Philippa> and that includes just about anything with foreign bindings
11:04:31 <ndm> dcoutts_: exit code tells us a number
11:04:41 <dcoutts_> ndm: a boolean
11:04:48 <tensh> is there a way to check if a generic type is a string?
11:04:59 <tensh> I want to do show on non-string elements
11:05:03 * wli is mostly stumped as to how to do a local patch in gentoo.
11:05:10 <tensh> but not on string since it adds quotes
11:05:20 <dcoutts_> ndm: and I'd like if possible to avoid having to rely on IO to do testing
11:05:24 <ndm> dcoutts_: i remain highly unconvinced that moving to an API will give any benefits over a command line, but it will certainly give more complexity
11:05:32 <Lemmih> > typeOf () == typeOf ""
11:05:32 <lambdabot>  False
11:05:50 <dcoutts_> ndm: why? your command line tests call a test driver which runs a bunch of tests, why not just expose that
11:06:19 <ndm> dcoutts_: that will be unlikely for a lot of things - i quite a few of my tests use IO - if just to pick up a directory of test cases
11:06:43 <ndm> dcoutts_: i could do, but i will then have to write the driver, and invoke system, and make sure it builds in the right order, and then hpc may not work on it
11:06:51 <dcoutts_> ndm: fine but it means I can avoid my automated test server running your arbitrary IO actions
11:07:20 <ndm> dcoutts_: i can fully see why its desirable, but i'm not entirely certain that if we make these restrictions it will happen in the end
11:07:23 <tensh> typeOf "asd"
11:07:36 <ndm> @type cast
11:07:38 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
11:07:59 <oerjan> > typeOf "asd"
11:08:00 <lambdabot>  [Char]
11:08:01 <dcoutts_> ndm: I think if we made the interface simple and provided test drivers for QC and HUnit then it'd be pretty easy to hook up what people already do
11:08:14 <ndm> @let output x = case cast x of Just s -> s; Nothing -> show x
11:08:14 <lambdabot> Defined.
11:08:21 <ndm> > output 12
11:08:22 <lambdabot>  "12"
11:08:26 <ndm> > output "12"
11:08:27 <lambdabot>  "12"
11:08:51 <oerjan> > output (Just 1.0)
11:08:52 <lambdabot>  "Just 1.0"
11:08:57 <ndm> dcoutts_: perhaps, i can see advantages both ways - if you could hook up QC, HUnit and Command Line then it would be perfect :)
11:08:57 <oerjan> ndm: clever
11:09:23 <ndm> dcoutts_: i guess what i'm advocating is *KISS*
11:09:46 <dcoutts_> ndm: aye, depends on your view of simple :-)
11:10:02 <ndm> at least let users keep it simple, even if there is some fancy thing that it can do if a user chooses
11:10:18 <dcoutts_> ndm: eg, I know what a module is but what is a command line process? that's not in the H98 spec
11:10:43 <ndm> dcoutts_: just got a response on the if (win32) thing - turns out an old version of the cabal manual made that mistake
11:11:16 <dcoutts_> ndm: ah ok, yes it doesn't mention win32 anymore
11:11:17 <ndm> dcoutts_: i don't think that matters at all, but if you want to implement such an API, and it can be hooked up to a command line tool, its fine
11:11:34 <ndm> my general trend for most programs is to have testing be one of their features
11:11:45 <ndm> i.e. hoogle test should run the tests on hoogle, tagsoup test should run the tagsoup tests
11:12:00 <ndm> that way they don't get stale and outdated, and they are dragged along with the rest of the app
11:12:06 <dcoutts_> ndm: I must admit that my bias is to try and separate IO and non-IO tests
11:12:10 * wli smokes out a potentially useful place to edit: /home/portage/distfiles/darcs-src/GSLHaskell/src/GSLHaskell.cabal
11:12:34 <smtms> 2
11:12:44 <dcoutts_> wli: be careful, next time you pull it might conflict
11:13:32 <dcoutts_> ndm: certainly I'd like to encourage packages to hook up their tests and we should put the results on hackage so people can see which packages have tests and what hpc coverage they get
11:13:34 <ndm> dcoutts_: i'd be more inclined if i had a belief that the non-IO tests were somehow more useful, and could be run safely, and that the work to do that ever actually happened
11:13:53 <ndm> dcoutts_: all good ideas :)
11:14:19 <ndm> but this seems to be the perfect sort of thing for some virtual/locked jail style implementation, rather than forcing tests to be restricted
11:15:00 <Philippa> obvious question: do we get backdoored by unsafePerformIO anyway?
11:15:25 <ndm> or template haskell
11:15:26 <dcoutts_> Philippa: running code safely requires being careful with the imports
11:15:31 <ndm> or type extensions that never teminate
11:15:45 <dcoutts_> but it's in principle possible
11:15:47 <ndm> or cpp
11:16:00 <jsnx> Philippa: 'backdoored' ?
11:16:07 <dcoutts_> ndm: depends on whether you trust cpphs to terminate on all inputs
11:16:08 <jsnx> Philippa: rooted?
11:16:10 <ndm> i remain skeptical that anyone will ever have the time to do this, before virtualised hosts become the norm
11:16:23 <jsnx> ndm: ?
11:16:25 <ndm> dcoutts_: not particularly, i'm sure it can be crashed
11:16:26 <tensh> thanks for the cast advice people... worked like a charm :)
11:16:44 <ndm> jsnx: i.e. running it in some kind of virtual machine VMWare style
11:17:00 <Philippa> jsnx: unsafePerformIO functions as a back door into the IO monad, and that's the intention
11:17:08 <jsnx> Philippa: oic
11:17:16 <shapr`> Automated test results are handy if a test only fails on some combination of arch/os. I can't own them all.
11:17:25 <Philippa> what damage you can do with that is a separate question
11:17:38 <jsnx> ndm: so, you think people are willing to punt on absolute safety because virtualization offers quick recovery?
11:17:57 <jsnx> Philippa: just got here :)
11:18:05 <jsnx> might be a few more minutes before the logs catch up...
11:18:08 <shapr`> I think that'll just lead to test result parsing overflow attacks.
11:18:28 <Philippa> there're ways of nailing that too, of course
11:19:10 <ndm> jsnx: not quick recovery, throw away recovery - i.e. set up a brand new virtual machine, run the tests, delete the virtual machine
11:19:12 <hpaste>  dejones pasted "Get a list of keys in Hash table." at http://hpaste.org/6016
11:19:18 <dejones> Help?  :)
11:19:24 <dejones> Type error...
11:19:54 <shapr`> Automated tests with machine parseable output is also quite helpful if you're updating a low level library and you want to see if your changes have broken any of a large number of libs that depend on the low level library.
11:20:21 <dcoutts_> shapr`: add your comments here: http://hackage.haskell.org/trac/hackage/ticket/215
11:20:22 <lambdabot> Title: #215 (Overhaul support for package's tests) - Hackage - Trac
11:20:42 <Philippa> shapr: yeah, but you can deal with that by having a reasonable upper bound on output size
11:21:30 <shapr`> For example, changes to Parsec could break 75% of Haskell apps.
11:22:55 <dejones>  http://hpaste.org/6016 -- I'm having problems with the Types for HashTable.toList; GHC error output is in the paste.
11:23:33 <Lemmih> dejones: Use 'mapM'.
11:23:44 <dejones> Lemmih: why?
11:23:45 <dejones> :t mapM
11:23:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:23:56 <dejones> hmm.
11:24:07 <Lemmih> dejones: Oops, return (map fst lhsh)
11:24:57 <dejones> Lemmih: thank you.  why is the return needed?
11:25:43 <dejones> :t return
11:25:45 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:25:53 <dejones> hmm
11:26:36 <oerjan> dejones: map doesn't return an IO action
11:27:49 <jsnx> i'm trying to use the FFI in a trivial way -- https://svn.j-s-n.org/public/haskell/dubious
11:27:49 <jsnx> is there some way to make ghc compile the c code?
11:27:51 <jsnx> it was my understanding that ghc shipped with its own gcc...
11:27:53 <lambdabot> Title: Revision 272: /haskell/dubious
11:28:17 <jgerman> I'm having a hell of a time attempting to install HAppS, anyone have any insights on getting this thing installed?
11:28:50 <dejones> oerjan: I'm not sure I understand what you said..  :(
11:29:07 <dejones> do I need an IO action returned because of the "do" ?
11:30:47 <oerjan> dejones: yes
11:31:35 <dejones> oerjan: and the "do" block is necessary because of the <- that is used with an IO returning function, which was HashTable.toList
11:31:37 <dejones> ?
11:31:37 <oerjan> basically you cannot access hashtables with anything that isn't an IO action
11:31:38 <shapr`> dcoutts_: Actual program with error code won't work well on windows.
11:31:41 <jsnx> oh wait, duh
11:31:51 <jsnx> i did not import the headers in the C file
11:31:55 <dcoutts_> shapr`: why is that?
11:32:22 <oerjan> dejones: well you could write it in other ways, but it would have to be an IO action regardless
11:32:38 <dejones> oerjan: alright.  thanks for the explanation.  :)
11:32:59 <shapr`> dcoutts: maybe it will..
11:33:38 <oerjan> e.g. getHashKeys hsh = map fst <$> DHT.toList hsh
11:33:48 <dcoutts_> shapr`: I'd prefer a haskell api since it allows richer info to be returned
11:33:52 <jsnx> well, never mind
11:34:01 <jsnx> i am totally out of practice
11:34:03 <jsnx> foo
11:35:02 <dejones> oerjan: what is the <$> doing?
11:36:12 <oerjan> dejones: it's applies the function before to the result of the action after
11:36:43 <int-e> @src (<$>)
11:36:44 <lambdabot> f <$> a = fmap f a
11:36:58 <dejones> oerjan: neat, thanks for the info!
11:36:59 <dejones> :)
11:37:03 <oerjan> yeah it's a synonym for fmap
11:37:23 <oerjan> (which is almost a synonym for liftM)
11:37:28 <oerjan> @src liftM
11:37:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
11:37:51 <oerjan> @src IO fmap
11:37:51 <lambdabot> fmap f x = x >>= (return . f)
11:38:22 <oerjan> those are actually equivalent for IO
11:38:33 <oerjan> (and should be for any monad)
11:38:34 <DQuest> Hmm
11:39:07 <dejones> oerjan: hmm
11:39:15 <dejones> oerjan: interesting.
11:39:33 <oerjan> dejones: i did the @src liftM because that shows how to define this with do notation
11:40:28 <DQuest> So, suppose I'm doing source-to-source transformation of code, and I wish to transform an AST through a sequence of trees to the AST of the target language, but those intermediate stages need different sets of features for each language.  I don't want to have a unique set of names for each intermediate tree, but is it possible to avoid doing this using one mega-AST format that can support everything?
11:40:59 <Heffalump> not unless you can think of some parametrisation scheme
11:41:15 <DQuest> ie, I don't want to have a data type for every single intermediate tree, but it'd be handy to have the type support so that nobody can plug the wrong tranforms in at the wrong time
11:41:19 <DQuest> bah, I thought as much
11:41:20 * DQuest pops that in his writeup
11:41:36 <Heffalump> well, I've thought about this problem before and not come up with a good answer, at any rate.
11:41:47 <Heffalump> if you do, I'd love to hear it
11:41:53 <DQuest> Possibly in the section titled "lessons learned", as "ask people who know better at the start of the project and not the end"
11:42:04 <DQuest> I'll certainly get back to you if I do
11:42:07 <DQuest> I imagine it'd make a great PhD
11:42:39 <DQuest> Next to "don't use Java, for the love of god!"
11:43:22 <Heffalump> If you have a mega-AST and just want to rule in or out certain constructors, you might be able to do something with a GADT and a phantom type parameter indicating the stage.
11:43:35 <mikael> stepping outside haskell, do ocaml polymorphic variants solve the problem?
11:43:58 <Heffalump> what exactly _are_ ocaml polymorphic variants? I've heard them mentioned several times, but I don't quite understand them.
11:44:02 <DQuest> I have no idea, I don't know OCaml well enough.  I do intend to learn it soon enough, mind.
11:44:22 <mikael> I don't know, hoped you would :-)
11:45:30 <Cale> Well, variants are basically open unions. They're useful for things like exceptions where you want functions to be able to handle some cases, and ignore others.
11:45:43 <Cale> (and you never know when you'll need another case)
11:47:04 <Cale> They're like the additive version of extensible records.
11:47:25 * wli has long been in favor of them, but somehow managed not to notice ocaml having them.
11:48:32 <DQuest> aha, I have been learning about these. Are they also known as Sums with respect to typing?
11:48:38 <DQuest> And do you use "case of" to unpack theM?
11:49:23 <Cale> Yes, but in contrast to the kind of sums which Haskell has, they're open, which means that future modules can always add to them.
11:49:50 <Cale> and functions which pattern match have to be content with only matching on some of the possible cases.
11:50:23 * wli discovers GSL's Graphics.Plot and is very happy.
11:51:32 <guenni> is there yet an irc server written in haskell?
11:52:17 <Cale> guenni: Someone here was working on something like that, but I can't recall what it was called, or if it was released yet.
11:52:36 <guenni> Cale: thx
11:53:23 <guenni> dons: ping
11:53:25 <Cale> Sorry it's not a terribly useful answer :)
11:53:42 <guenni> I had worse, don't worry
12:06:00 <Cheery> huh! This channel has grown from the last time a lot
12:06:24 <DQuest> \o/
12:06:28 * DQuest is new. Hi!
12:08:26 <Cheery> what is the minimum amount of subset of haskell that'd be reasonable to implement on bare hardware, not relying on any C?
12:09:02 <Cheery> (I know some haskell and some but not all theory behind it)
12:09:48 <Botje> have you looked at the GHC runtime docs?
12:10:06 <shapr`> hiya Cheery! How's code?
12:10:10 <Cheery> can you hand me a link to those?
12:10:59 <Cheery> shapr`: I've not been coding any bit lately
12:11:27 <dcoutts> Cheery: people have done experimental ports of the ghc rts to bare hardware, house or hop or something like that
12:11:35 <Cheery> at least, not any bit of haskell, and very little amount of code in other languages as well
12:12:29 <shapr`> Cheery: I think you'd end up replacing C with an equivalent something.
12:13:23 <DQuest> I thought house was making an OS in haskell?
12:13:30 <Cheery> dcoutts: I know about house, last time I weren't so good at understanding it
12:13:32 <DQuest> same thing, in some ways
12:14:23 <Cheery> but few days ago I watched some frag sources, after working with languages like scheme, c, python
12:16:16 <Cheery> in haskell I'm afraid about not being able to use it anywhere I want to ever use it, since it's so abstract from my perspective
12:17:38 <Cheery> I'm afraid about further heights between me and the bare metal
12:19:26 <shapr`> Why is that scary?
12:20:08 <shapr`> More distance between you and the bare metal means you don't have to worry about alignment, allocation and deallocation, integer overflow, all sorts of extra work that's not about solving the actual problem.
12:20:47 <phobes> Or you might still worry about them, but you certainly can't do anything about them :)
12:20:48 <Cheery> what I'm worrying is the compatibility between haskell and other languages
12:20:58 <augustss___> It's only important to be close to the bare metal in a very small fraction of all code.
12:21:10 <guenni> Cheery: I so see your point
12:21:36 <augustss___> The Haskell FFI is very good
12:22:15 <phobes> augustss___ - some high level ability to set policies about how things get converted to metal might be nice
12:22:53 <augustss___> phobes: with the Haskell FFI you make your own, through Storable
12:23:10 <Cheery> and it's good to have distance, but still it hurts a lot if you'd need to drop back into writing assembly right from haskell
12:23:48 <augustss___> Cheery: and what kind of programming do you do when dropping to assembly is necessary?
12:23:59 <phobes> augustss___ - I meant more that it would be nice to have a way to write high level code and then give implementation guidance about it (more like what you can do with control strategies)
12:24:25 <shapr`> phobes: Rewrite rules?
12:24:41 <shapr`> Cheery: There is a Haskell library for inline asm, I think augustss___ wrote a blog post about it recently.
12:24:45 <Heffalump> the gradual move away from the metal does lead to systematic slowness, though
12:24:53 <augustss___> phobes: oh, I understand.  Yes, that would be cool.  You can to a certain extent, but it's messy.
12:25:00 <Cheery> anyway, haskell is too good to just leave aside, I've learnt while getting annoyed by C, even getting annoyed by python! and getting annoyed by scheme after it
12:25:07 <shapr`> Heffalump: Yeah, in general abstraction speeds development and slows execution.
12:25:24 <Heffalump> yeah, and the former is a massive win compared to what we lose
12:25:32 <shapr`> Yup, I agree. My time is valuable to me!
12:25:34 <Heffalump> but we need magic compilers too!
12:25:45 * shapr` compiles some magic.
12:26:40 <Cheery> more and more magic in compilers is good, but that's also something I'm afraid about, what if I need to write a haskell environment some day?
12:27:08 <Heffalump> that's a problem because the language gets bigger
12:27:14 <shapr`> Cheery: In my opinion, Haskell is a marvelous balance between magic and explicitness.
12:27:14 <Heffalump> not because there are clever compilers
12:27:20 <gnuvince> Cheery: then you ask for a higher salary :)
12:27:36 <Heffalump> I don't think it's very explicit in terms of close-to-the-metal
12:27:45 <shapr`> Too much use of typeclasses can lead to confusing magic, but I have very rarely seen Haskell code that is difficult to understand.
12:28:06 <Heffalump> really? wow
12:28:42 <Heffalump> small bits of Haskell can do so much that it can often be quite tricky to understand other people's code, IME. On the other hand, the lack of global state does help with comprehension.
12:29:35 <Cheery> anyway, I'd want to learn implement a working haskell environment of my own, no problem if it'd be represented on haskell how to implement haskell
12:29:37 <augustss___> shapr`: you've not read my code ;)
12:29:54 <shapr`> augustss___: That's true. But remember, I already had nightmares about you trying to teach me something.
12:30:01 <phobes> Anyone here use the haskell LLVM binding?
12:30:12 <augustss___> phobes: yes
12:30:13 * shapr` grins
12:30:23 <phobes> augustss___ - opinions?  How buggy is it?
12:30:39 <shapr`> augustss___: Ok, suggest some dense Haskell code that you've written?
12:30:47 <phobes> (I guess I'm asking both about the LLVM and then the haskell binding separately)
12:30:52 <shapr`> Something I don't have to sign an NDA to read?
12:30:56 <augustss___> The latest version is not very buggy, but the high level interface is incomplete.  I have some more work to do.
12:31:15 <phobes> augustss___ - Oh, you're a contributor?
12:31:22 <phobes> augustss___ - (or the?) contributor?
12:31:38 <augustss___> phobes: I've redone the high level interface.  It's simpler to use now
12:32:04 <augustss___> shapr`: I could show it to you, but then I'd have to kill you.
12:32:06 <phobes> cool - and what about the LLVM in general, is it pretty stable / good?
12:32:19 <Cheery> anyway, is GHC docs only thing I'd be better read, or is there anything else?
12:32:21 <shapr`> augustss___: Um, I'll pass then.
12:32:29 <augustss___> phobes: I'm guessing it's pretty good since Apple is using it
12:32:40 <phobes> ah ok
12:32:43 <shapr`> Cheery: What is your goal?
12:33:07 <shapr`> augustss___: Hey, are you coming to Boston anytime soon?
12:33:19 <augustss___> I dunno
12:33:27 <shapr`> I thought I'd buy you a beer and ask about Cayenne if you'd be in town sometime.
12:33:47 * radix hopes to one day return to boston
12:33:54 <shapr`> radix: Are you still hiding in Portland?
12:33:56 <Cheery> want to learn how to implement a working subset of haskell, doesn't matter if it's not using the latest algorithms or having all the syntactic sugar in it's syntax
12:33:59 * Heffalump has never been to Boston
12:34:05 <shapr`> Heffalump: Feel free to show up :-)
12:34:09 <radix> shapr: no, I came back, but then I had to go to pittsburgh on short notice.
12:34:11 <Heffalump> bit expensive :-)
12:34:20 <shapr`> Heffalump: I know, rent here is insane!
12:34:22 * shapr` grins
12:35:05 <radix> and then next month I'm going to be in chicago.
12:35:15 <augustss___> I like the Boston area
12:35:31 <Cheery> shapr`: got my goal?
12:36:11 <shapr`> Cheery: Why not start with the lambda calculus and put layers on top of that to make it closer to Haskell?
12:36:29 <Saizan> Cheery: have read this? http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
12:36:30 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/fvgtw
12:36:30 <shapr`> Cheery: lambdabot had a lambda calculus interpreter that was close enough to Haskell to confuse almost everybody.
12:37:11 <shapr`> I still haven't been able to contact Urban Boquist. I wonder what happened to him.
12:37:19 <sclv_> bah: citeseer is down for me. otherwise http://citeseer.ist.psu.edu/peytonjones92implementing.html for spj's "implementing lazy functional languages on stock hardware" (the stg paper)
12:37:36 <Cheery> shapr`: but that's probably what I'd want to learn. :)
12:37:55 <augustss___> shapr`: urban@boquist.net
12:38:04 <shapr`> augustss___: I'll try that, thanks.
12:38:29 <shapr`> Cheery: Simon Peyton-Jones has written lots of papers on the subject of implementing functional languages, that might be a good place to start.
12:38:37 <augustss___> Cheery: Simon's book is an excellent way to learn about implementation
12:38:43 <shapr`> Or you could implement a lambda calculus interpreter, they are related concepts.
12:38:50 <Cheery> I had almost forgotten that
12:39:08 <Cheery> reading them last time didn't brought me much, maybe this time is easier
12:39:09 <Heffalump> I think there was a photo of him at jobs-in-fp
12:40:02 <Cheery> first going to finish this book about linkers and loaders
12:42:11 * wli has had trouble making the connection between tree reduction, graph reduction, and abstract machines (I'm aware of the fact they're connected and maybe a little of how at a very high and vague level).
12:44:10 <augustss___> gimme 5 minutes and a whiteboard and it will all be clear to you :)
12:44:46 <mrd> you will beat him over the head with the whiteboard for 5 minutes?
12:46:03 <swidgy> 4 minutes, plus a minute's contemplation to achieve clarity
12:47:20 <shapr`> So next we need wHiteboard as the companion to Hpaste?
12:47:40 <shapr`> Maybe ballplank would be a nice name.
12:47:54 <oerjan> haSketch?
12:47:57 <phobes> Hdoodle
12:48:01 <mrd> that would be nice for sketching out category-theoretic analysis of code on hpaste
12:48:10 <swidgy> phobes: Hadoodle is smoother
12:48:22 <phobes> Haskadoodle
12:48:30 <swidgy> ;)
12:49:27 <shapr`> edwardk does the whole whiteboard thing a lot. It's quite informative.
12:50:07 <shapr`> My most recent a-ha moment was when he described linear vs uniqueness types to me, and why a substructural type system would cool.
12:50:15 <shapr`> @quote substructural
12:50:15 <lambdabot> shapr says: I dare you to call a substructural type system obvious anywhere outside of #haskell.
12:51:03 <shapr`> During lunch today I got a fast tutorial in group theory, and how that relates to things like the third homomorphism law...
12:51:36 <dino-> shapr`: Is that 'would cool' in the sense of it being exothermic?
12:51:46 <shapr`> dino-: :-P
12:51:54 <shapr`> "would be interesting"
12:52:15 <dino-> Would, in math terms, blow your socks off.
12:52:22 <shapr`> Yes, exactly.
12:53:29 <olsner> yes, getting your socks blown off would result in a drop in temperature
12:53:43 <shapr`> Anyway, I'll be back later...
12:56:33 <audreyt> dons: README of hsplugins says  mv plugins.cabal.hsx plugins.cabal  but there's no such file?
12:56:51 <audreyt> http://code.haskell.org/~dons/code/hs-plugins/plugins.cabal.hsx # 404
12:58:11 <audreyt> hm, but one is in the rc0 tarball.
12:59:39 <RayNbow> hmm...
13:00:47 * RayNbow can't compile Djinn... :p
13:01:10 <dolio> What's the difference between linear and uniqueness typing? Weakening?
13:05:45 <Saizan> ?where monadlib
13:05:46 <lambdabot> http://www.cse.ogi.edu/~diatchki/monadLib/
13:05:53 <RayNbow> hmm, question... which C compiler is recommended for building packages under Windows?
13:06:03 <RayNbow> should I use gcc or cl?
13:06:07 <mrd> gcc
13:06:20 <RayNbow> ah ok
13:06:49 <mrd> @go mingw
13:06:49 <lambdabot> http://www.mingw.org/
13:06:49 <lambdabot> Title: MinGW - Home
13:07:14 <RayNbow> I have cygwin, is that also ok? :p
13:09:02 <mrd> sure
13:10:16 <RayNbow> hmm, getting errors when building Readline...
13:15:03 <Saizan> @where+ monadlib http://darcs.haskell.org/libraries/monadLib/
13:15:03 <lambdabot> I will never forget.
13:30:23 <RayNbow> hmm, http://groups.google.com/group/comp.lang.haskell/msg/ad31ed1617f344be <-- I got the same problem, heh... :p
13:30:23 <lambdabot> Title: installing readling and process packages on Windows/Cygwin - comp.lang.haskell | ..., http://tinyurl.com/2rkymv
13:42:46 <dejones> How can I check the type of a variable at run-time?
13:42:52 <dejones> in ghci
13:43:30 <dejones> this is for code I loaded from a file with :l
13:44:05 <monochrom> Unless you use Data.Dynamic, no.
13:44:07 <dejones> I keep getting "not in scope"
13:44:10 <dejones> :(
13:44:15 <Heffalump> ghci isn't exactly "runtime"
13:44:19 <dejones> no breakpoints in ghci maybe?
13:44:23 <Heffalump> did you export the "variable" from the file?
13:44:25 <dejones> that I could use to test the type
13:44:37 <dejones> Heffalump: no, I didn't export the variable
13:44:38 <Heffalump> it does have breakpoints, but I doubt those are what you want
13:44:39 <dejones> how would I do that?
13:44:54 <Heffalump> dejones: put it in the export list at the top, if you have one. If you don't, it's exported by default.
13:45:00 <dejones> I just want to check the type of a variable bc I am passing it to a function and I can't seem to get the types correct for the function...
13:45:12 <dejones> Heffalump: I don't have an export list.
13:45:33 <monochrom> delete all *.hi files. Reload the module.
13:46:14 * monochrom thought "run-time" really meant "run-time".
13:48:15 <dejones> thanks
13:48:27 <dejones> I think I found another error that was causing my problems..
13:48:28 <dejones> :)
13:51:04 <opqdonut> dejones: use :t for checking types in ghci
13:51:17 <opqdonut> :t id -- like this
13:51:19 <lambdabot> forall a. a -> a
13:51:42 <dejones> opqdonut: yea, I did that, but it was saying out of scope...
13:55:09 <ehird> Terminal manipulation. Whut I do? (libs)
14:00:27 <monochrom> ncurses is a terminal library. there may be haskell binding.
14:00:56 <Beelsebob> there is
14:00:58 <Beelsebob> hat uses it
14:01:02 <Beelsebob> I believe
14:04:42 <dejones> I'm trying to take the head of a list that is type IO [key], but it is giving me an error about not matching the expected type [a] with the inferred type IO [key]
14:04:46 <dejones> I'm confused.  :(
14:05:05 <ehird> dejones: It's an IO list.
14:05:06 <ehird> Not a list.
14:05:11 <ehird> Nothing like each other!
14:05:16 <dejones> Ok.
14:05:42 <dejones> Is there a way I can convert the IO List to a normal List?  or what operations can I perform on an IO List?
14:05:59 <oerjan> do l <- iol; return (head l)
14:06:10 <wli> ncurses is an obscene horror.
14:06:15 <Zao> Inside the IO monad, you can get a t' out of an IO t' with do and <-
14:06:35 <oerjan> or even do (h:_) <- iol; return h
14:06:49 <conal> or 'fmap head iol'
14:07:39 * Botje sets out to try and learn about applicative functors again
14:07:51 * conal cheers Botje!
14:07:51 <dejones> hmm
14:07:52 <monochrom> dejones: http://www.haskell.org/haskellwiki/Introduction_to_IO and http://www.haskell.org/haskellwiki/Introduction_to_Haskell_IO
14:07:53 <lambdabot> Title: Introduction to IO - HaskellWiki
14:07:54 <dejones> trying..
14:09:24 <dejones> I'm using a HashTable and that's where I got the IO List from a HashTable.toList
14:09:32 <shepheb> I need a function :: (m a, m b) -> m (a,b)
14:09:42 <conal> Botje: Applicative is like Monad, with ap but without >>=.  And with liftM, liftM2, ... which are definable via return & ap.
14:10:19 <DQuest> shepheb: so kind of like sequence is for [m a] -> m [a]?
14:10:46 <shepheb> DQuest: yes, essentially.
14:10:50 <shepheb> @src sequence
14:10:50 <lambdabot> sequence []     = return []
14:10:50 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:10:50 <lambdabot> --OR
14:10:50 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:10:54 <Botje> conal: I dyill need to wrap my head around the magic of ap first :p
14:10:56 <ehird> --OR?!
14:10:58 <Botje> *still
14:11:13 <ehird> @. djinn type (\a -> a)
14:11:15 <lambdabot> f a = a
14:11:16 <conal> shepheb: do you know get function' :: m a -> m b -> m (a,b) ?
14:11:19 <ehird> tee hee
14:11:29 <ehird> @. djinn type (\a b c d e f g -> g f e d c b a)
14:11:31 <lambdabot> f a b c d e f g = g f e d c b a
14:11:51 <monochrom> @type liftM2 (,)
14:11:52 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
14:12:05 <opqdonut> conal: liftM (,)
14:12:08 <opqdonut> :t liftM (,)
14:12:10 <ehird> @type (m a -> m b) -> a -> m b
14:12:11 <lambdabot> forall a1 b (m :: * -> *). (Monad m) => m a1 -> m (b -> (a1, b))
14:12:13 <lambdabot> parse error on input `->'
14:12:19 <ehird> @hoogle (m a -> m b) -> a -> m b
14:12:20 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
14:12:20 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
14:12:20 <lambdabot> Control.Monad.Writer.Class.censor :: MonadWriter w m => (w -> w) -> m a -> m a
14:12:21 <monochrom> Just add curry.
14:12:27 <opqdonut> ah, liftM2 i mean :)
14:12:30 <monochrom> @type uncurry (liftM2 (,))
14:12:31 <ehird> @hoogle (Monad m) => (m a -> m b) -> a -> m b
14:12:32 <shepheb> conal: thanks, that plus curry is the win.
14:12:33 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
14:12:33 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
14:12:33 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
14:12:33 <lambdabot> Control.Monad.Writer.Class.censor :: MonadWriter w m => (w -> w) -> m a -> m a
14:12:42 <conal> shepheb: you got it!
14:12:47 <ehird> @hoogle (Monad m) => (a -> b) -> m a -> m b
14:12:48 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
14:12:48 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
14:12:48 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
14:12:56 <ehird> sfsdfh
14:13:00 <shepheb> I knew it was there, I just couldn't get it typed out. thanks, all.
14:13:03 <ehird> '(a -> b) -> a -> b' is so not like '(Monad m) => (a -> b) -> m a -> m b'
14:13:19 <ehird> @type flip (>>=)
14:13:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
14:13:27 <conal> shepheb: for a bit more generality, you can use liftA2 instead of liftM2
14:13:30 <ehird> er, wait
14:13:40 <ehird> @type \f x -> do x' <- x; return (f x')
14:13:42 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => (t1 -> t2) -> t t1 -> t t2
14:13:53 <shepheb> @type liftA2
14:13:55 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:13:56 <wli> > ap (Just (1+)) (Just 2)
14:13:57 <lambdabot>  Just 3
14:14:15 <ehird> > \x -> x x
14:14:15 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
14:14:16 <lambdabot>     Probab...
14:14:17 <ehird> :)
14:14:27 <shepheb> conal: hmm. that will require some thought. I'm very explicitly working in the X monad here, though, so no worries.
14:14:37 <ehird> > \(In x) -> x (In x)
14:14:38 <lambdabot>   Not in scope: data constructor `In'
14:14:40 <ehird> err
14:14:41 <conal> shepheb: good enough
14:14:56 * conal can't seem to stop plugging Applicative 
14:15:15 <ehird> is there a cabal-install way to get GOA?
14:16:03 <wli> > ap [(1+),(2*)] [2,5] :: [Int]
14:16:04 <lambdabot>  [3,6,4,10]
14:16:55 <ehird> > ap putStrLn getLine
14:16:55 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `IO ()'
14:17:04 <ehird> hm what
14:17:06 <ehird> @type ap
14:17:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:17:44 <ehird> ah
14:17:58 <ehird> > ap (return putStrLn) getLine
14:17:59 <lambdabot>  <IO (IO ())>
14:18:03 <ehird> hee
14:18:21 <ehird> @hoogle (Monad m) => (a -> b) -> m a -> m b
14:18:22 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
14:18:22 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
14:18:22 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
14:18:38 <ehird> @pl \f x -> x >>= return . f
14:18:38 <lambdabot> fmap
14:18:42 <ehird> @type fmap
14:18:43 <wli> Better still, ap [Left, Right] [0..2] :: [Either Int Int]
14:18:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:18:55 <wli> > ap [Left, Right] [0..2] :: [Either Int Int]
14:18:56 <lambdabot>  [Left 0,Left 1,Left 2,Right 0,Right 1,Right 2]
14:18:56 <ehird> bloody functors
14:19:13 <monochrom> haha
14:20:15 <wli> Applicative is basically Functor + unit/return.
14:20:24 <wli> As I understand it, anyway.
14:20:39 <ehird> @hoogle (Functor f) => (a -> f b) -> f a -> f b
14:20:39 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
14:20:40 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
14:20:40 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
14:20:40 <oerjan> :t putStrLn =<< getLine
14:20:41 <lambdabot> IO ()
14:20:53 <ehird> @src everywhere
14:20:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:21:15 <oerjan> wli: + liftM2
14:21:20 <ehird> @type fix return
14:21:22 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
14:21:23 <lambdabot>       Expected type: a -> a
14:21:23 <lambdabot>       Inferred type: a -> m a
14:21:27 <ehird> oh, and
14:21:32 <conal> how about this explanation of Applicative?  With Functor, fmap applies a normal functions to a funny value.  With Applicative, (<*>) applies a funny function to a funny value.  For instance, "funny" is time-varying, or IO.
14:21:40 <ehird> fix f = last (iterate f undefined)
14:21:42 <ehird> :-D
14:22:18 <ehird> @type \f -> last (iterate f undefined)
14:22:20 <lambdabot> forall a. (a -> a) -> a
14:22:25 <ehird> seeeee? :-D
14:22:52 <ehird> @type \f -> head (iterate f undefined)
14:22:53 <lambdabot> forall a. (a -> a) -> a
14:22:58 <ehird> oh. heh.
14:23:01 <ehird> @type iterate
14:23:03 <lambdabot> forall a. (a -> a) -> a -> [a]
14:23:19 <ehird> damn.
14:24:25 <ehird> @pl let foo f = f x where x = foo x in foo
14:24:26 <lambdabot> (line 1, column 25):
14:24:26 <lambdabot> unexpected "="
14:24:26 <lambdabot> expecting variable, "(", operator, ";" or "in"
14:24:35 <ehird> hm
14:24:57 <oerjan> i don't think @l does where, only let
14:25:02 <oerjan> *@pl
14:25:28 <ehird> ah
14:25:35 <ehird> @pl let foo f = let x = foo f in f x in foo
14:25:36 <lambdabot> fix (ap id)
14:25:39 <ehird> heh
14:25:41 <ehird> @type fix (ap id)
14:25:42 <lambdabot> forall b. (b -> b) -> b
14:25:49 <ehird> @type ap id
14:25:50 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
14:25:51 <wli> oerjan: The difference having to do with forming all pairs vs. only matching pairs.
14:25:58 <wli> > liftA2 (,) [0..3] [10..13] :: [(Int,Int)]
14:25:58 <lambdabot>  [(0,10),(0,11),(0,12),(0,13),(1,10),(1,11),(1,12),(1,13),(2,10),(2,11),(2,12...
14:26:07 <ehird> ap id -- the most useless thing, ever
14:26:11 <ehird> especially as an argument to fix.
14:26:21 <ehird> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
14:26:21 <lambdabot> ap (. join id) (. join id)
14:26:24 <ehird> hee
14:26:29 <ehird> lambdabot don't know 'bout my infinite types
14:26:50 <ehird> @type ap (. join id) (. join id)
14:26:52 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
14:26:52 <lambdabot>     Probable cause: `id' is applied to too many arguments
14:26:52 <lambdabot>     In the first argument of `join', namely `id'
14:27:01 <oerjan> wli: um you are thinking of [] vs. ZipList.  but they are _both_ Applicatives
14:27:04 <dolio> The difference depends on the functor.
14:27:11 <ehird> @. unpl pl \f -> (\x -> f (x x)) (\x -> f (x x))
14:27:11 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ b p -> b (((\ a -> a) >>= \ k -> k) p)) (\ d s -> d (((\ c -> c) >>= \ m -> m) s))
14:27:46 <dejones> @whereis Cale
14:27:46 <lambdabot> Maybe you meant: where where+
14:27:50 <dejones> :)
14:27:52 <dejones> Cale
14:27:53 <dejones> save me
14:27:57 <Cale> yeah?
14:28:02 <dejones> I'm Haskell retarded it seems.
14:28:05 <oerjan> @seen Cale
14:28:05 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 8s ago.
14:28:07 <dolio> liftA2 lifts 2-argument functions to work on two funny arguments.
14:28:10 <Cale> What's up?
14:28:11 <dolio> But given that.
14:28:13 <dolio> @type liftA2 id
14:28:15 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
14:28:33 <dolio> You can lift functions of arbitrary numbers of arguments.
14:28:44 <ehird> @pl let L = \a b c d e f g h i j k l m n o p q r s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r) in L L L L L L L L L L L L L L L L L L L L L L L L L L
14:28:47 <dejones> Cale: I'm just really struggling with the types in Haskell.  I am using a HashTable and I converted it to a List, and I am trying to use the keys... I'll paste some code for you.
14:28:57 <Cale> okay
14:28:59 <lambdabot> ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap (ap id id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id) id)
14:28:59 <lambdabot> id (fix (const ((((((const .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .)
14:29:03 <lambdabot> Plugin `pl' failed with: thread killed
14:29:06 <ehird> hahah
14:29:12 <Cale> By the way, you should probably avoid the HashTable library that comes with GHC
14:29:25 <Cale> It sucks and basically never performs better than Data.Map
14:29:25 <ehird> @. unpl pl let L = \a b c d e f g h i j k l m n o p q r s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r) in L L L L L L L L L L L L L L L L L L L L L L L L L L
14:29:33 <Cale> (which has a far nicer user interface)
14:30:11 <dejones> Cale: lol, well... I'm already using the GHC HashTable, but I'll keep that in mind for the future.
14:30:18 <dejones> it's not a lot of code.
14:30:21 <Cale> okay
14:31:42 <ehird> I think lambdabot ignored me.
14:32:21 * wli suspects it's either spinning on one of those giant combinators or otherwise died while trying to digest them.
14:32:31 <monochrom> @botsnack
14:32:46 <sclv_> > (ap id)  (\f -> f "!") (\x -> x ++ "?")
14:33:07 <sclv_> ehird why u hurt the bot?
14:33:33 <Cale> (I just reset it)
14:33:38 <ehird> sclv_: I wanted to see what it did to the Yk combinator through pl and unpl
14:33:39 <ehird> :D
14:33:41 <sclv_> > > (ap id)  (\f -> f "!") (\x -> x ++ "?")
14:33:44 * dcoutts notes bos fixing accidental BSD4 license on pcap package
14:33:46 <sclv_> > (ap id)  (\f -> f "!") (\x -> x ++ "?")
14:33:47 <lambdabot>   parse error on input `>'
14:33:53 <lambdabot>  "!??"
14:34:10 <hpaste>  dejones pasted "I have Haskell down-syndrome.  Type issues with HashTables.  :(" at http://hpaste.org/6018
14:34:18 <dejones> There ya go Cale.
14:34:23 <monochrom> "lambdabot is dead again!  Who killed her?  The suspects are Dr. Dons, Prof. Hutton, Mr. Cales, Col. Okassaki, Gen. Oleg, Ms Philippa.  The implements are id, ap, fmap, ..."
14:34:27 <dejones> I'm new to Haskell, as you know, so I am sorry if my code sucks.  ;)
14:34:29 <ehird> dejones: omfg
14:34:31 <ehird> no layout
14:34:32 <dejones> lol
14:34:34 <ehird> it looks like c
14:34:35 <ehird> stop it!
14:34:36 <ehird> fix your dos
14:34:39 <dejones> layout?
14:34:43 <ehird> eeeeeeeeeek!
14:34:53 <dejones> heh
14:35:01 <ehird> someone slap him
14:35:03 <dejones> fix my dos?
14:35:04 <RayNbow> is there any way to get Readline for Haskell in Windows?
14:35:09 <dejones> I don't use DOS
14:35:15 <ehird> ...
14:35:18 <ehird> grrrrrrrrrrrr
14:35:26 <dejones> ehird: you're confusing me.
14:35:29 * bltrout reminds ehird to use his words, not violence.
14:35:39 * ehird slaps bltrout
14:35:42 <dejones> lol
14:35:51 <Cale> dejones: Well,  DHT.lookup hsh l  isn't the result of doing a lookup
14:36:06 <Cale> dejones: It's a computation (in the IO monad) which runs to do the lookup.
14:36:17 <dejones> Ok.
14:36:19 * bltrout retrieves saber and mask.
14:36:27 <Cale> This is the extremely annoying thing about Data.HashTable
14:36:40 <Cale> (that everything is in the IO monad, so you can't write pure functions which use it)
14:36:43 <dejones> ehird: Are you going to tell me anything informative or just rant?  ;)
14:36:52 <ehird> Methinks dejones has been clouded by do-notation
14:36:56 <ehird> what with these IO monad troubles
14:36:56 <dejones> Cale: I've noticed that...
14:37:06 <ehird> but heck at least the 'do's could look less like C or Perl
14:37:06 <ehird> :P
14:37:14 <dejones> ehird: lol
14:37:22 <Cale> dejones: Okay, so do you want to fix the type errors, or change this to use Data.Map? :)
14:37:22 <dejones> ehird: Yea, C is my main language.  ;)
14:37:34 <ehird> dejones: basically
14:37:36 <ehird> instead of
14:37:37 <ehird> do {
14:37:38 <ehird>     abc;
14:37:41 <ehird>    def;
14:37:41 <ehird> }
14:37:43 <ehird> do this:
14:37:45 <ehird> do abc
14:37:46 <dejones> Cale: Well, I would like to at least understand the type errors... I don't mind changing to Data.Map if it will make my life easier.
14:37:47 <ehird>    def
14:37:49 <Botje> Cale: can hashtable be implemented with ST too?
14:37:50 <wli> Cale: They could've at least used ST.
14:37:52 <ehird>    blah
14:37:53 <ehird>    blah2
14:37:58 <ehird> err, that kinda got clouded
14:38:05 <dejones> heh, I get it ehird.
14:38:06 <dejones> :)
14:38:09 <cin> c-c-combo breaker
14:38:12 <Cale> Botje: It perhaps could be, but isn't.
14:38:34 <sclv_> dejones: generally its considered that the current hashtable implementation is pretty lame all around, and foax avoid it.
14:38:35 <radix> cin: dang. now you've inspired me to go search the rom sites
14:38:37 <Cale> dejones: Okay, let's see how can I explain...
14:38:45 <Cale> :t Data.HashTable.lookup
14:38:47 <lambdabot> forall key val. Data.HashTable.HashTable key val -> key -> IO (Maybe val)
14:39:00 <Cale> See how the result there is an  IO (Maybe val) ?
14:39:26 <dejones> Cale: Yes.  To convert that I was doing (fromJust val)  :)
14:39:29 <Cale> A value of type  IO (Maybe val)  is a program in the IO monad which, if you were to run it, would produce a value of type Maybe val
14:39:42 <Cale> It is not a value of type  Maybe val
14:39:54 <Cale> Hence, fromJust doesn't work.
14:40:00 <dejones> Ok.
14:40:13 <Cale> When you write  first_val = (DHT.lookup hsh l)
14:40:14 <dejones> How do I handle the IO (Maybe val)  :)
14:40:26 <Cale> This just defines  first_val  to be that same computation.
14:40:29 <gwern> @pl headN n ss = concat $ genericTake n $ lines ss
14:40:30 <lambdabot> headN = (join .) . (. lines) . genericTake
14:40:30 <Cale> It doesn't run the computation.
14:40:41 <Cale> You typically use a do-block.
14:41:08 <dejones> Cale: typically use a do-block for something with an IO type, or always?
14:41:13 <wli> Well, computations are all driven by output forcing them.
14:41:31 <gwern>  headN n = concat . genericTake n . lines -- I suppose this is equivalent
14:41:37 <Cale> do-blocks are used to put IO computations together into larger IO computations
14:41:56 <dejones> Cale: the do-blocks force sequential evaluation, correct?
14:42:00 <Cale> In a do-block, if you write   v <- x, where x :: IO a, then v :: a
14:42:07 <Cale> No
14:42:09 <dejones> ok
14:42:11 <gwern> we need a partial @pl; pl'ing the embedded 'n' would make it hideous, but just dropping the ss is nice enough
14:42:14 <Cale> They describe execution.
14:42:22 <dejones> :)
14:42:27 <boywork> @src lines
14:42:27 <lambdabot> Source not found. My mind is going. I can feel it.
14:42:30 <Cale> do blocks construct new IO actions from simpler ones.
14:42:45 <Cale> (actually, they're more general than that, but this explanation will do for now)
14:42:52 <dejones> ok
14:43:07 <ehird> @help code
14:43:08 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:43:40 <oerjan> @code
14:43:40 <lambdabot> Maybe you meant: more todo vote
14:43:43 <Cale> So if I have an IO action  getLine :: IO String  which gets a line of text from the user, and a function  putStrLn :: String -> IO ()  which takes a String and produces the action for printing that string on the screen
14:43:51 <Cale> then I can form a new IO action:
14:43:56 <Cale> do x <- getLine; putStrLn x
14:44:01 <dejones> Right.
14:44:16 <Cale> Which, when run, will get a line of text from the user, and then print it back out.
14:44:20 <ehird> dejones:
14:44:23 <ehird> x <- y; z
14:44:24 <ehird> =====>
14:44:25 <Cale> However, this is just a value.
14:44:26 <ehird> x >>=
14:44:28 <ehird> \y -> z
14:44:31 <ehird> x; y
14:44:34 <ehird> =======>
14:44:35 <ehird> x >> y
14:44:41 <Cale> The only IO action which actually runs is main
14:44:42 <ehird> do you see?
14:44:43 <ehird> so:
14:44:47 <dejones> ehird: you are succeeding in confusing me.  ;)
14:44:50 <ehird> do x <- getLine; putStrLn x; putStrLn "foo"
14:44:52 <ehird> ===========>
14:45:00 <ehird> getLine >>= (\x -> putStrLn x >> putStrLn "foo")
14:45:04 <Cale> ehird: Let's not worry about bind for now.
14:45:05 <ehird> >> is just >>= \_ ->
14:45:06 <ehird> so:
14:45:13 <ehird> getLine >>= (\x -> putStrLn x >>= (\_ -> putStrLn "foo"))
14:45:18 <dejones> lol
14:45:19 <ehird> now you can see that 'do' is not magical
14:45:26 <oerjan> @slap ehird
14:45:26 * lambdabot throws some pointy lambdas at ehird
14:45:30 <dejones> ehird: can you paste that to hpaste? so I can see it all together.
14:45:30 <ehird> hee
14:45:38 <ehird> dejones: yes. just a sec
14:45:40 <Cale> Well, >>= is just as magical. This is the IO monad after all.
14:45:41 <cin> @quote knights
14:45:42 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
14:45:45 <dejones> ok
14:46:04 <dejones> So, Cale, how do I handle the IO (Maybe val) that is returned from the lookup function?
14:46:26 <Cale> dejones: Well, you compose a new IO action which runs that one, and does something with the result.
14:46:55 <dejones> Cale: Yeah, I was having type issues when trying to use the value from the lookup.
14:47:16 <Cale> totalSumAreaVel :: HashTable key val -> [String] -> IO Double
14:47:16 <Cale> totalSumAreaVel hsh [] = return 0.0
14:47:16 <Cale> totalSumAreaVel hsh (l:ls) = do v <- DHT.lookup hsh l
14:47:16 <Cale>                                 case v of
14:47:16 <Cale>                                    Just x -> return x
14:47:17 <Cale>                                    Nothing -> ...
14:47:42 <Cale> er, actually that type signature is still problematic
14:47:57 <Cale> You really don't want key and val to be type variables there
14:48:04 <dejones> why?
14:48:09 <Cale> That would mean they could be anything, whereas really, they're something specific.
14:48:15 <dejones> ok
14:48:15 <dejones> :)
14:48:27 <Cale> In particular, key should be String, and val should be Double
14:48:32 <dejones> HashTable String Double
14:48:33 <dejones> yea
14:50:46 <dejones> Cale, can I change that to "Just x -> return (head x)"
14:50:48 <dejones> ?
14:51:06 <Cale> Sure, if you change the type of the whole function.
14:51:52 <dejones> Hmm
14:52:15 <dejones> oh yah, ok
14:52:32 <Cale> x :: Double
14:52:37 <Cale> So head doesn't apply :)
14:52:43 <dejones> Yah.
14:52:57 <dejones>   hdl <- openFile filename ReadMode;
14:52:57 <dejones>   let readFile = do {
14:52:57 <dejones>     eof <- hIsEOF hdl;
14:52:57 <dejones>     if (eof) then
14:52:57 <dejones>       do {
14:52:58 <dejones>         hClose hdl;
14:52:59 <dejones>       }
14:53:01 <dejones>     else
14:53:03 <dejones>       do {
14:53:05 <dejones>         line <- hGetLine hdl;
14:53:07 <dejones>         insertToHash hsh line;
14:53:09 <dejones>         readFile;
14:53:11 <dejones>       }
14:53:13 <dejones>   }
14:53:15 <dejones>   readFile -- Evaluate readFile(); remember, we are lazy evaluation!
14:53:19 <dejones>   -- All the keys in the hash.
14:53:21 <dejones>   lkeys <- getHashKeys hsh;
14:53:23 <dejones>   --putStrLn(show lkeys) -- Debug printing.
14:53:25 <dejones>   let sum = totalSumAreaVel hsh lkeys
14:53:27 <dejones>   putStrLn(show sum)
14:53:29 <dejones>   {-
14:53:31 <dejones>   -- Get the list of split strings out of the hash table.
14:53:33 <dejones>   let k = "21.8663254"
14:53:35 <dejones>   v <- (DHT.lookup hsh k)
14:53:37 <dejones>   putStrLn(show (DM.fromJust v))
14:53:39 <dejones>   -}
14:53:39 <Heffalump> hey!
14:53:41 <dejones> -- EOF.
14:53:42 <czShadoW> What about HPaste?
14:53:43 <dejones> ack
14:53:44 <Heffalump> !url hpase
14:53:45 <dejones> SORRY, accidental paste.
14:53:46 <Cale> dejones: uh, for long pastes like that, you should really use HPaste.
14:53:49 <dejones> :/
14:53:52 <Cale> !paste
14:53:53 <dejones> it was an accident :(
14:53:53 <hpaste> Haskell paste bin: http://hpaste.org/
14:53:58 <Heffalump> fair enough :-)
14:53:59 <dejones> yea, I didn't intend to do that.
14:54:10 * shapr throws flu lambdas
14:54:11 <dejones> It was left over from the clipboard...
14:54:12 <dejones> :(
14:54:27 <dejones> totalSumAreaVel :: HashTable String Double -> [String] -> Double
14:54:27 <dejones> totalSumAreaVel hsh [] = 0.0
14:54:27 <dejones> totalSumAreaVel hsh (l:ls) = do
14:54:27 <dejones>   val <- DHT.lookup hsh l
14:54:27 <dejones>   case val of
14:54:28 <dejones>     Just x -> return x
14:54:29 <dejones>     Nothing -> return
14:54:32 <dejones> that was what I intended.
14:54:49 <dejones> I still get type errors with that though
14:54:50 <dejones> :(
14:55:26 <dejones>     Couldn't match expected type `Double' against inferred type `a b'
14:55:31 <Heffalump> even 8 lines is generally hpasted, FWIW
14:55:43 <dejones> Heffalump: Oh, ok.
14:55:43 <Cale> dejones: Well, a few problems.
14:55:50 <dejones> Heffalump: Thanks.
14:55:55 <Cale> dejones: First of all, you're now returning an IO Double
14:56:23 <dejones> Cale: Heh, you are right.  This HashTable in GHC is a pain.. everything is in the IO Monad.  :/
14:56:35 <Cale> dejones: second, since 0.0 isn't of type IO Double, but just of type Double, you apply return to it, to get a no-op action which will just return 0.0
14:56:43 <Cale> dejones: Right.
14:56:51 <Cale> dejones: Data.Map is *so* much nicer.
14:57:21 <hpaste>  ehird pasted "stupid little monad tutorial" at http://hpaste.org/6021
14:57:22 <dejones> Cale: Alright.  I'll switch to Data.Map.  I'm convinced.
14:57:30 <ehird> dejones: Give that a try
14:57:34 <Cale> Lastly, the case for Nothing there is a type error.
14:57:40 <Cale> return is a function
14:57:49 <dejones> hmm
14:58:08 <Cale> (not an IO action on its own, you'd have to apply it to something)
14:58:09 <dejones> Cale, return() instead?
14:58:16 <Cale> Nope, type error again.
14:58:19 <ehird> dejones: see my paste! :-P
14:58:21 <Cale> Since () :: ()
14:58:35 <Cale> You could get away with something like  return 0.0
14:58:41 <ehird> It will explain monads for the future even if you don't need it right now.
14:58:42 <Botje> BEWBS!
14:58:44 <ehird> I suggest you read it
14:58:44 <dejones> Cale: hmm
14:59:01 <dejones> ehird: Thank you.  I'm saving the page now.
14:59:02 <dejones> :)
14:59:12 <ehird> (anyone else: feel free to tell me what a terrible tutorial that was :P)
14:59:14 <ehird> dejones: :)
14:59:48 <Cale> Actually, you should probably read this right away http://haskell.org/haskellwiki/Introduction_to_IO
14:59:56 <Cale> It doesn't talk about other monads at all
15:00:04 <Cale> But should give you the right idea for IO
15:00:25 <ehird> hmm
15:00:30 <ehird> skimming that i don't like it
15:00:41 <ehird> i prefer the approach:
15:00:44 <Cale> ehird: What don't you like about it?
15:00:48 <dejones> Cale: I did read the IO stuff you wrote, and it was useful for the IO stuff, but the HashTable IO confused me. ;)
15:00:51 <ehird> completely skim over it at first, concentrate on the actual language,
15:01:01 <ehird> then explain monads unrelated to IO or state -- like mine
15:01:04 <ehird> then introduce IO and how it's a monad
15:01:09 <dejones> Anyway ehird and Cale, thank you both for the help.  I need to leave though.
15:01:12 <dejones> I gotta drive home
15:01:16 <Cale> dejones: okay
15:01:26 <ehird> anyway, i believe 'monads as computation' and 'monads as containers' are both wrong
15:01:26 <dejones> Cale: I'll try out Data.Map and let you know how it goes.  ;)
15:01:29 <ehird> monads are the combination of the two.
15:01:43 <dejones> Thanks again.  Cya Cale and ehird.
15:01:44 <Cale> ehird: Well, certainly.
15:01:45 <dejones> :)
15:01:45 <Botje> monads as type errors!
15:01:45 <dejones> later
15:01:53 <monochrom> You know, everything you know are all wrong.
15:02:10 <monochrom> For example, everything you know about numbers.
15:02:14 <Cale> ehird: Though, practically speaking, Monads as computation is, I think, a broad enough perspective for functional programming.
15:02:28 <Cale> monochrom: Yeah?
15:02:34 <monochrom> Numbers as apples is wrong.  Numbers as money is wrong.
15:02:41 <Cale> monochrom: good point :)
15:02:42 <ddarius> Indeed.  Moggi's paper introducing them to denotational semantics was titled: "Notions of Computation"
15:03:04 <Cale> At least for now.
15:03:38 <Cale> It might be that monads are useful for something else in computer science and/or functional programming as well, that we just don't know about yet.
15:04:09 <ddarius> Cale: They are useful for many things in computer science not blatantly obviously related to how they are used in Haskell.
15:05:02 <monochrom> A parser is likely not a computation or a container to some extent.
15:05:13 <Cale> monochrom: Well, it's both :)
15:05:45 <ehird> monochrom: A parser is a computation whose aim is containing things
15:05:52 <ddarius> To say whether it is or is not requires you to define "computation" and "container"
15:05:55 <monochrom> I dispute that. But nevermind. My real point is it's all POV and illusions.
15:06:17 <ehird> I should write a Haskell tutorial sometime.
15:06:27 <ddarius> ehird: Why?
15:06:31 <ehird> 'Elliott Hird's Compleat Guide to a Language Almost, But Not Entirely, Unlike Haskell'
15:06:38 <Cale> Well, the container view would say that a parser is a container indexed by strings, and at each index, it has another string (the remainder of the input), and an element.
15:06:50 <ehird> Chapter 1: 'Bananas, Space, and the Divine Relation between Them'
15:07:39 <Cale> That gives a reasonable way to look at parsers as containers, anyway.
15:08:01 <Cale> There are other ways of representing parsers which would give rise to differently-shaped containers.
15:08:19 <ehird> Chapter 5: 'Yet Another Has^H^H^HMonad Tutorial'
15:09:04 <monochrom> "A computation is a container because you can query a computation for items. A container is a computation because you can execute a container for answers."  Discuss.  (Hint: it's just silly semantics.)
15:09:18 <ehird> monochrom: Of course.
15:09:24 <dino-> Cale: You said something earlier, that do blocks don't impose sequencing.
15:09:34 <Cale> dino-: on evaluation
15:09:44 <ehird> dino-: correct. but bind often does
15:09:49 <Cale> monochrom: Right, but the exact words you use matter when teaching/learning.
15:09:54 <awesame> ehird: I think that tutorial has already been written, and it's call Why's Poigniant Guide to Ruby
15:10:02 <ehird> awesame: I love wpgtr
15:10:03 <awesame> er
15:10:07 <monochrom> "Semantics is syntax because a play on semantics is a play on words. Words are syntax."  Discuss.
15:10:08 <ehird> But ruby isn't haskell. :P
15:10:10 <awesame> Poignant too, wtf fingers
15:10:16 <Cale> dino-: For example, see the list monad...
15:10:34 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
15:10:35 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
15:10:44 <ehird> hmm
15:10:50 <dino-> mm, yeah
15:10:52 <ehird> > do x <- [1..]; y <- [2..]; return (x,y)
15:10:52 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),(1,13)...
15:11:04 <Cale> Bind is unfair.
15:11:05 <ehird> hmm
15:11:09 <ehird> thats odd
15:11:22 <ddarius> Not really.
15:11:23 <awesame> Cale: whoa, what's going on there?
15:11:24 <Cale> If you want a fair selection operator, see LogicT.
15:11:27 <wli> ehird: You need Cantor diagonalization or similar for that.
15:11:35 <awesame> I expected ([1,2,3],[4,5])
15:11:42 <dino-> So, is it fair to say that do blocks or bind _can_ be used to sequence things?
15:11:47 <dino-> But they may not do so.
15:11:49 <ehird> @src Monad []
15:11:50 <lambdabot> Source not found. Where did you learn to type?
15:11:52 <ehird> @src Monad ([] a)
15:11:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:11:54 <Cale> awesame: In the list monad  x <- [1,2,3]  means "select x from [1,2,3] in each possible way"
15:11:56 <ehird> Mmgrrrrr.
15:12:02 <ehird> @info Monad [a]
15:12:03 <lambdabot> Monad [a]
15:12:05 <awesame> oh, crazy
15:12:07 <ehird> clap clap
15:12:16 <ddarius> @info do a; b
15:12:16 <lambdabot> a >> b
15:12:21 <Cale> awesame: If you know about list comprehensions, it's the exact same thing.
15:12:22 <wli> Try @src Monad [ ]
15:12:26 <wli> @src Monad [ ]
15:12:27 <lambdabot> Source not found. Do you think like you type?
15:12:32 <wli> Oh dear.
15:12:34 <Cale> @src [] (>>=)
15:12:35 <lambdabot> m >>= k     = foldr ((++) . k) [] m
15:12:38 <Cale> @src [] return
15:12:38 <lambdabot> return x    = [x]
15:12:38 <ehird> oh
15:12:42 <ehird> @info --> @undo
15:12:42 <lambdabot>  Parse error at "@undo" (column 5)
15:12:43 <ehird> hahah
15:12:46 <awesame> Cale: actually, I was shocked in part because I thought I knew the list monad from list comprehensions
15:12:49 <ehird> lambdabot your spellcheck sucks
15:13:02 <Cale> Oh, I should fix the source for >>=
15:13:07 <awesame> Cale: I guess I've only been doing single-select list comprehensions
15:13:20 <ddarius> Cale: That definition is cute though.
15:13:27 <ehird> @crap
15:13:28 <lambdabot> Maybe you meant: map slap
15:13:33 <ddarius> It also demonstrates foldr/map or foldr/foldr fusion nicely.
15:13:34 <ehird> @map
15:13:34 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:13:40 <ehird> @map id
15:13:40 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:13:50 <Cale> awesame: yeah, people often think that list comprehensions can be implemented entirely with map and filter, but you need concat as well.
15:14:09 <ehird> Cale: they can be done with just concatMap/filter then
15:14:10 <ehird> :-)
15:14:13 <Cale> yes
15:14:27 <Cale> and in fact, you don't really need filter
15:14:44 <Cale> You just need guard, which is arguably simpler.
15:14:51 <ehird> @type guard
15:14:52 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:15:16 <Cale> guard False = []; guard True = [()]
15:15:57 <ehird> @src guard
15:15:57 <lambdabot> guard True  =  return ()
15:15:57 <lambdabot> guard False =  mzero
15:16:03 <Cale> > do x <- [1,2,3]; y <- [1,2,3]; guard (x < y); return (x,y)
15:16:04 <lambdabot>  [(1,2),(1,3),(2,3)]
15:16:11 <ehird> Cale: requires a working list monad.
15:16:22 <Cale> ehird: But a working list monad is nothing but concatMap
15:16:24 <ehird> ergo you already have list comprehensions at that point
15:16:36 <Cale> and forming singleton lists
15:16:38 <Cale> no
15:16:57 <ddarius> Cale: And mzero
15:17:08 <shapr> @users
15:17:09 <lambdabot> Maximum users seen in #haskell: 463, currently: 421 (90.9%), active: 14 (3.3%)
15:17:12 <Cale> ddarius: You don't need the general version
15:17:22 <shapr> hi gwern !
15:17:25 <Cale> ddarius: You just need the list-specialised version :)
15:17:28 <ddarius> Cale: Okay "And mzero (i.e. [])
15:17:30 <ddarius> "
15:17:36 <Cale> all right :)
15:17:36 <ehird> Cale: with that allowance, just inline map!
15:17:41 <ehird> &filter&...
15:17:42 <Cale> [  e | True ] 	 = 	 [e]
15:17:43 <Cale> [  e | q ] 	= 	[ e | q, True ]
15:17:43 <Cale> [  e | b, Q ] 	= 	if b then [  e | Q ] else []
15:17:43 <Cale> [  e | p <- l, Q ] 	= 	let ok p = [  e | Q ]
15:17:43 <Cale> 		    ok _ = []
15:17:43 <Cale> 		in concatMap ok l
15:17:45 <ehird> 0 deps!
15:17:45 <Cale> [  e | let decls, Q ] 	= 	let decls in [  e | Q ]
15:18:09 <Cale> That's the official translation, mangled a bit :)
15:18:41 <Cale> where e ranges over expressions, p over patterns, l over list-valued expressions, b over boolean expressions, decls over declaration lists, q over qualifiers, and Q over sequences of qualifiers. ok is a fresh variable. The function concatMap, and boolean value True, are defined in the Prelude.
15:19:46 * wli weeps for monad comprehensions.
15:20:26 <Cale> Yeah, I want monad comprehensions back too.
15:22:12 <yav> is there someone here that can help me with building ghc (one of the base libraries rather)?
15:23:06 <ski_> @poll-list
15:23:06 <lambdabot> []
15:23:27 <monochrom> I don't like polls.
15:33:31 <Lord_Illidan> hi guys..I'd like to know, is it possible to upcast in Haskell from int to Integer?
15:33:42 <dcoutts> fromIntegral
15:34:05 <dcoutts> Lord_Illidan: there is no casting really, casts are just functions
15:34:31 <Lord_Illidan> I want to use a function that takes an Integer
15:34:39 <dcoutts> Lord_Illidan: use fromIntegral
15:34:55 <Lord_Illidan> so how I can use a function that outputs an int (like length) as a parameter to that function
15:35:01 <siti> > (fromIntegral 5::Int) :: Integer
15:35:02 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
15:35:10 <siti> oops
15:35:39 <yav> fromIntegral (5::Int) :: Integer
15:36:00 <Lord_Illidan> that works
15:36:30 <Lord_Illidan> what are the real benefits of using Integer over int though, apart from the infinite range?
15:36:46 <siti> it can be very big :p
15:37:10 <ehird> Lord_Illidan: Never use Int.
15:37:13 <ehird> It's premature optimization.
15:37:17 <Lord_Illidan> yeah, I know about that.. I made a 41 page Integer..bloody cool
15:37:20 <ehird> Int should be stuffed into Data.Int or something
15:37:37 <Lord_Illidan> but, if I know I am never going to exceed the maximum range of int?
15:37:39 <ehird> Lord_Illidan: Besides, Integer basically uses an Int internally; if it's small enough.
15:37:43 <ehird> Just a small overhead of checks.
15:37:47 <ehird> I would just always use Integer
15:38:02 <ehird> mixing'n'matching is not fun
15:38:08 <Lord_Illidan> ic
15:38:14 <ehird> Oh, and:
15:38:14 <Lord_Illidan> so far, I've only used Integer
15:38:21 <ehird> PRIVMSG :: Channel -> String -> Command
15:38:30 <dcoutts> ehird: the overhead is relative, sometimes it's small sometimes it's massive, depends on the application.
15:38:37 <ehird> Actually, not Channel.
15:38:40 <ehird> PRIVMSG :: Target -> String -> Command
15:38:44 <ehird> dcoutts: still
15:38:45 <Lord_Illidan> ehird, what's that?
15:38:52 <SamB> huh. that's odd. Solitaire just crashed on me!
15:39:00 <ehird> QUIT :: Maybe String -> Command
15:39:09 <Lord_Illidan> > fromIntegral(length[5,1,2])
15:39:10 <lambdabot>  3
15:39:17 <Lord_Illidan> :t fromIntegral(length[5,1,2])
15:39:18 <ehird> TOPIC :: Maybe Target -> Command
15:39:19 <lambdabot> forall b. (Num b) => b
15:39:27 <ehird> Lord_Illidan: high-level IRC lib i'm working on
15:39:35 <siti> > Data.List.genericLength([1,2,3])
15:39:36 <lambdabot>  3
15:39:44 <siti> that can go to integer
15:39:46 <SamB> oh, wait, it was just being sluggish...
15:39:48 <siti> stright away :)
15:40:14 <ehird> :)
15:40:31 <ehird> WHO :: String -> Bool -> Command
15:40:57 <ehird> SUMMON :: Target -> Maybe Server -> Maybe Target -> Command
15:40:58 <ehird> You get the idea.
15:41:20 <ehird> data Target = Channel String | Nickname String
15:41:27 <Lord_Illidan> ERROR "doubleElts.hs":50 - Cannot justify constraints in explicitly typed binding
15:41:29 <Lord_Illidan> ?
15:41:33 <Lord_Illidan> *** Constraints   : Integral ([a] -> Int)
15:41:39 <ehird> Lord_Illidan: use ghc
15:41:55 <ehird> (Network.IRC as a name is taken. Any suggestions by anyone?)
15:41:58 <Lord_Illidan> why doesn't hugs work?
15:42:21 <ehird> hugs sucks
15:42:23 <ehird> :-)
15:42:32 <monochrom> hugs doesn't suck
15:42:32 <Lord_Illidan> heh, well ok
15:42:36 <Lord_Illidan> ghci failed too
15:42:36 <ehird> monochrom: well, sure :)
15:42:37 * monochrom hugs his hugs
15:42:39 <ehird> but nobody really uses it!
15:42:40 <Lord_Illidan> I think my code sucks :D
15:43:01 <ehird> Lord_Illidan: Likely.
15:43:04 <TomMD> Lord_Illidan: I _know_ my code sucks as I haven't formally proven it doesn't.
15:43:31 <ehird> I should call it something provocative
15:43:33 <Lord_Illidan> bah, it's a brackets problem
15:43:36 <ehird> like Network.IRC.Better
15:43:39 <ehird> or Network.IRC.FarMoreAwesome
15:43:50 <ehird> or Network.IRC.ThePackageToTheLeftIsNotAsCoolAsThisOne
15:44:00 <Lord_Illidan> heh, nice one, but 2 long
15:44:01 <monochrom> Alt.Network.IRC.Haskell.Die.Die.Die
15:44:16 <TomMD> ehird: Careful, the original author of Network.IRC might make Network.IRC.FarMoreAwersome.Er
15:44:20 <monochrom> To the left?
15:44:45 <SamB> monochrom: Network.IRC
15:44:46 <monochrom> I mean, packages on Hackage are listed vertically.
15:44:58 <SamB> see, to the left of the .
15:45:06 <monochrom> . . .
15:45:27 <TomMD> Is this a competition to pollute the namespace?
15:45:36 <ehird> TomMD: Network.IRC.FarMoreAwesome.Er.DisregardThat.ISuckCocks
15:45:43 <ehird> yes, i know, referencing top 100 bash quotes is totally lame.
15:45:48 <SamB> "ThePackageToTheLeft" consists of the previous two compononts of the module name
15:45:55 <SamB> only spelled better
15:46:59 <Lord_Illidan> ok fromIntegral solved my problem 10x :D
15:47:12 <ehird> The one thing that IRC libraries have not figured out yet
15:47:23 <ehird> is that a Client (bot, user, etc) is not one server only
15:47:28 <ehird> and that there should be a multiplexer
15:47:51 <ehird> and since I write modules how I'd like stuff to work, all stuff will be shared between servers
15:47:58 <ehird> 'a' on server a is 'a' on server b
15:49:04 <ehird> Haskell should allow ' in package names.
15:49:06 <ehird> Network.IRC'
15:50:06 <Lord_Illidan> if I'm using guards with a where clause, should the where be after the =?
15:50:24 <Lord_Illidan> ex, width <= 12 where width = .. or width <= 12 = .... where width = ?
15:51:32 <ehird> don't do that
15:51:32 <ehird> :P
15:51:58 <Lord_Illidan> ehird, why not?
15:52:53 <ehird> why do you need a where in a guard
15:53:48 <ddarius> where scopes over multiple guards
15:54:20 <Lord_Illidan> well, this piece of programming is rather tricky
15:54:21 <Saizan> ehird: you should consider networks rather than servers. and also many things (like chans and users) are not the same between networks :)
15:54:30 <Lord_Illidan> I think I should look more into where then
15:55:02 <SamB> ehird: does windows allow that?
15:55:10 <ehird> Saizan: why should I consider networks rather than servers? that makes the bot writers job just much harder
15:55:14 <ehird> SamB: no.
15:55:21 <ehird> Saizan: besides, most networks have a multiplexer
15:55:24 <ehird> e.g. 'irc.freenode.net'
15:55:35 <ehird> and, chans and users aren't the same, but that's no problem because we don't track them
15:55:43 <ehird> but if you have some kind of map storing stuff..
15:55:48 <ehird> well, do your own damn differenciation :-)
15:56:00 <ehird> thankfully, stuff like bot-wide state will be basically up to the coder
15:56:07 <ehird> that stuff is easy anyway
15:56:15 <ehird> it will provide an IRC monad, though
15:56:16 <ehird> well.
15:56:18 <Saizan> some don't and being able to specify a list of servers for a network is useful for reconnecting on timeouts
15:56:21 <ehird> type IRC = IRCT IO
15:56:29 <ehird> I guess for a bot you would do:
15:56:43 <ehird> type BotM = IRCT (StateT Bot IO)
15:56:44 <ehird> hmm
15:56:45 <ehird> or maybe:
15:56:51 <ehird> type BotM = StateT Bot IRC
15:56:54 <ehird> Unsure.
15:57:17 <ehird> Saizan: some don't; but how many of those are actually worth caring about? ;)
15:57:23 <ehird> and how many are likely to time out an awful lot?
15:57:29 <ehird> and besides; it'd complicate everything
15:58:13 <Saizan> oh well i thought an IRC library would manage at least that :)
15:58:40 <ehird> Saizan: at least what?
15:58:48 <ehird> Network.IRC handles even less.
15:58:53 <ehird> It just parses & renders IRC stuff.
15:58:57 <ehird> No networking at all.
15:59:00 <Saizan> reconnection on network failures
15:59:01 <ehird> Not even a monad.
15:59:10 <ehird> well you could plug that in pretty easily I guess.
15:59:32 <ehird> But for now I'm mainly concerned about making my bot work. Patches, they are accepted. :-P
15:59:58 <ehird> hmm, I will probably need a thing looking up an irc commanderator via a string
16:00:06 <ehird> ircCommand "ADMIN" = ADMIN
16:00:06 <ehird> etc
16:00:19 <lamentb> where's kilbot?
16:00:34 <ehird> lamentb: ?
16:02:58 <ehird> so!
16:03:08 <ehird> Network.IRC is basically the correct name for this package
16:03:17 <ehird> And arguably, not the current Network.IRC - it ignores the network.
16:03:24 <ehird> how is this to be handled?
16:07:08 <ehird> :<
16:07:15 <Saizan> ehird: talk with the irc maintainer?
16:09:02 <ehird> Saizan: NEGOTIATION WILL NOT BE NECCESSARY. KILL KILL KILL
16:09:08 <ehird> er, I mean, taht sounds like a great idea
16:09:10 <ehird> @seen elliottt
16:09:10 <lambdabot> I saw elliottt leaving #haskell-soc 2d 23h 40m 15s ago, and .
16:09:22 <ehird> he was here YESTERDAY..
16:09:49 <Saizan> but, if you don't use that package for yours you could just use the same name.. packages can handle that
16:12:26 <ehird> Saizan: Hackag.
16:12:27 <ehird> e/
16:13:25 <monochrom> You are so violent. :)
16:13:49 <ehird> Hahah
16:14:08 <monochrom> @vixen what is the value of humans?
16:14:08 <lambdabot> i don't know, what?
16:14:26 <monochrom> @vixen do you think humans should be eliminated?
16:14:26 <lambdabot> i do occassionally, i guess
16:14:31 <monochrom> Nice!
16:15:11 <ehird> @. vixen vixen vixen
16:15:11 <lambdabot> we all have a little vixen in us
16:15:15 <ehird> @. vixen vixen vixen
16:15:15 <lambdabot> we all have a little vixen in us
16:15:24 <ehird> @. vixen vixen completely unrelated to vixen
16:15:24 <lambdabot> we all have a little vixen in us
16:15:29 <ehird> @. vixen vixen completely unrelated to THAT THING
16:15:29 <lambdabot> do i seem to have a deep voice? nope, all woman here
16:15:33 <kpreid> @. vixen vixen fnord
16:15:33 <lambdabot> wait, back up
16:15:47 <ehird> hah
16:16:34 <Beelsebob> @vixen does ehird need to stop doing that now?
16:16:34 <lambdabot> sorry, i'll stop
16:16:41 <Beelsebob> :)
16:16:42 <monochrom> haha
16:16:59 <Lord_Illidan> @vixen what are you?
16:17:00 <lambdabot> i truely am
16:17:27 <dabblego> ?check \f xs -> length (map (f :: Int -> Int) xs) == length xs -- why is lambdabot complaining about this?
16:17:28 <lambdabot>        instance (Typeable a, Typeable b) => Show (a -> b)         -- Defined ...
16:19:33 <grahamhutton> @users
16:19:33 <lambdabot> Maximum users seen in #haskell: 463, currently: 423 (91.4%), active: 16 (3.8%)
16:19:58 <ehird> @check \_ -> False
16:19:58 <lambdabot>  Falsifiable, after 0 tests: ()
16:20:09 <ehird> Can quickcheck handle the IO monad?
16:20:26 <dabblego> it can, but stating properties in IO can be difficult
16:20:29 <SamB> in what sense do you mean "handle"?
16:21:10 <ehird> hmm
16:21:14 <ehird> 0->False,1->True
16:21:16 <ehird> what's that func again?
16:21:19 <ehird> @hoogle Int -> Bool
16:21:20 <lambdabot> Data.IntSet.member :: Int -> IntSet -> Bool
16:21:20 <lambdabot> Data.IntSet.notMember :: Int -> IntSet -> Bool
16:21:24 <ehird> @hoogle Integer -> Bool
16:21:24 <lambdabot> Data.Time.Calendar.isLeapYear :: Integer -> Bool
16:21:24 <lambdabot> Data.Time.Calendar.Julian.isJulianLeapYear :: Integer -> Bool
16:21:24 <lambdabot> Data.Time.Calendar.OrdinalDate.isLeapYear :: Integer -> Bool
16:21:26 <ddarius> fromEnum
16:21:30 <dabblego> fromEnum?
16:21:34 <ddarius> er toEnum
16:22:08 <ddarius> > map toEnum [False,True]
16:22:09 <lambdabot>  Couldn't match expected type `Int' against inferred type `Bool'
16:22:20 <ddarius> > map toEnum [0,1] :: [Bool]
16:22:21 <lambdabot>  [False,True]
16:22:38 <ehird> @check \_ -> do (x,_) <- getStdRandom (randomR (0,1)); return (toEnum x)
16:22:38 <lambdabot>        add an instance declaration for (Test.QuickCheck.Testable (IO a))     ...
16:22:42 <ehird> darnit
16:23:43 <ehird> anyone want to fix that? :(
16:24:13 <grahamhutton> ehird: if you want to quickcheck in IO, you might like to look at the "beauty in the beast" paper from the Haskell Workshop 2007
16:25:10 <mikael> grahamhutton: sweet, I've been curious about that
16:25:19 <grahamhutton> http://www.cs.nott.ac.uk/~wss/Publications/BeautyInTheBeast.pdf
16:26:14 <ehird> grahamhutton: In lambdabot? :-P
16:26:22 <mikael> I nearly killed myself trying to rewrite this really imperative emulator-type thing to support any type of monadic arrays, just to quickcheck it, now I can just use IO everything, like a real programmer...
16:26:34 <ehird> @check \_ -> toEnum (fst (unsafePerformIO (getStdRandom (randomR (0,1))))
16:26:34 <lambdabot> Unbalanced parentheses
16:26:37 <ehird> @check \_ -> toEnum (fst (unsafePerformIO (getStdRandom (randomR (0,1)))))
16:26:37 <lambdabot>   Not in scope: `unsafePerformIO'
16:26:41 <ehird> BAH!
16:26:47 <ehird> @check \_ -> toEnum (fst (System.IO.Unsafe.unsafePerformIO (getStdRandom (randomR (0,1)))))
16:26:47 <lambdabot>   Not in scope: `System.IO.Unsafe.unsafePerformIO'
16:26:51 <grahamhutton> ehird: now that's an idea!
16:26:56 <ehird> Poo to you, lambdabot. Poo to you.
16:27:25 <ddarius> All that would be required is adding the necessary imports.
16:28:00 <ehird> Cale: You. Go do that. :-P
16:29:19 <SamB> ehird: what kind of idiot do you think Cale is?
16:29:37 <ehird> SamB: A cuddly, fluffy one.
16:29:38 <SamB> the non-importation of unsafePerformIO is deliberate
16:30:03 <ehird> OK then, add 'unsafeGetStdRandom' or something. :-P
16:30:05 <ddarius> SamB: The Beauty in the Beast stuff.
16:30:27 <SamB> ddarius: is that safe?
16:30:35 <SamB> would it allow the reading of /etc/passwd?
16:30:36 <ddarius> It's pure.
16:30:48 <ddarius> At least some of it.
16:31:19 <ehird> [00:30] <SamB> would it allow the reading of /etc/passwd?
16:31:19 <ehird> [00:30] <ddarius> At least some of it.
16:31:20 <ehird> hee
16:32:06 <ehird> ddarius: Would it allow doing random number stuff?
16:32:10 <ehird> If so, we need it.
16:32:29 <ddarius> To do random number stuff all you need is a state monad.
16:32:39 <ddarius> There is plenty of pure random functions.
16:33:17 <ddarius> SamB: Looking at the paper again, there should be no issues with security.
16:33:29 <whee> Is there a common way for reducing memory usage for strings that have the same value? I have a list of ~2000 types that contain URLs, but there are a lot of duplicates and profiling shows this using a lot of memory
16:33:53 <ddarius> SamB: It doesn't actually cover modelling file I/O in the paper, but you could use a system where you provide a model filesystem.
16:34:08 <SamB> whee: you are storing URLs in the type system?
16:35:10 <whee> SamB: I have a Maybe String component inside of one of my types, and the String is a URL
16:36:01 <whee> the fact that it's a URL doesn't really matter, there are just not  many unique URLs in total and storing each one seems wasteful (compared to somehow storing pointers to the data)
16:37:21 * SamB was just picking on whee's claim that he/she stored URLs in a list of types
16:37:42 <whee> I'm new and don't know what I'm talking about :)
16:38:03 <SamB> well, you CAN have a list of types, but I think that you would not want to use it for storing URLs
16:38:22 <ehird> ddarius: I want truly random.
16:38:23 <SamB> (what good do URLs do you at compile time, after all?)
16:38:27 <ehird> Multiple lambdabot commands, different.
16:38:43 <ddarius> ehird: Good luck finding it.
16:38:44 <SamB> perhaps you meant to say you had a list of values containing URLs somehow
16:38:55 <ehird> ddarius: :-)
16:38:57 <ehird> Well, not truly random.
16:39:00 <ehird> You know what I mean!
16:39:19 <ehird> whee: Look up in a Map?
16:39:34 <ehird> i.e. symbols.
16:39:34 <ehird> intern
16:39:56 <mikael> I want to use real IORefs when running for real, and fake IORefs when quickchecking with the beauty & beast technique -- I guess I define a typeclass for IO-likes?
16:40:09 <mikael> (wouldn't ML-like functors be pretty nice?)
16:40:10 <whee> ehird: that is probably what I want; do you know which library I should be looking at?
16:40:21 <SamB> there is some kind of "weak reference" thing somewhere, isn't there?
16:40:21 <Excedrin> hi mikael
16:40:22 <ehird> whee: Roll your own!
16:40:40 <mikael> hi Excedrin !
16:40:43 <wli> mikael: omfg do I ever want ML-style functors bad
16:40:49 <ddarius> mikael: There is a class mentioned usually called MonadRef that is often used to abstract from a particular reference type.
16:40:52 <mikael> SamB: yeah, it's somewhere in System
16:40:54 <ddarius> It may work here too.
16:41:23 <mikael> ddarius: oh, that's nice!
16:41:25 <int-e> SamB: System.Mem.Weak
16:42:36 <ddarius> It usually looks like: class Monad m => MonadRef r m | r -> m where newRef :: a -> m (r a); readRef :: r a -> m a; writeRef :: r a -> a -> m ()
16:42:52 <ddarius> Some people think that the functional dependency is too limiting so sometimes it's dropped.
16:42:55 <ehird> @karma doifgjklns
16:42:55 <lambdabot> doifgjklns has a karma of 0
16:43:00 <ehird> @karma+ doifgjklns
16:43:00 <lambdabot> doifgjklns's karma raised to 1.
16:43:02 <ehird> Heh.
16:43:37 <mikael> ddarius: ah, it's a folklore thing, not codified in the stdlib yet :)
16:43:52 <ddarius> Well the functional dependency issue was one reason it wasn't.
16:44:11 <mikael> ah
16:44:31 <ddarius> I used a class like that in my Prolog interpreter so that it could use IORefs, STRefs and Lazy.STRefs.  The result was pretty sweet.
16:44:42 <ehird> @karma- doifgjklns
16:44:42 <lambdabot> doifgjklns's karma lowered to 0.
16:45:02 <Excedrin> @karma C++
16:45:02 <lambdabot> C++ has a karma of -8
16:45:27 <ehird> @karma god
16:45:27 <lambdabot> god has a karma of 0
16:45:30 <ehird> @karma c++
16:45:30 <lambdabot> c++ has a karma of -8
16:45:36 <ehird> @karma c++!
16:45:36 <lambdabot> c++! has a karma of 0
16:46:06 <mikael> I'm writing a smalltalk interpreter, and you know smalltalk lets you swap two objects system-wide -- so a variable is an IORef (IORef (IORef Object))
16:46:14 <int-e> @seen dons
16:46:14 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I don't know when dons last spoke.
16:46:15 <ehird> mikael: Hahah!
16:46:20 <mikael> three-star programming indeed...
16:46:33 <ehird> mikael: Why not (IORef Object) and just swap the two values?
16:47:01 <ddarius> ehird: Look up #become:
16:47:04 <monochrom> ddarius: I use a similar class. I have m->r instead.
16:47:22 <mikael> yeah, that is probably a lot more sensible, since I guess Objects will just contain a few pointers
16:47:37 <ddarius> monochrom: I actually forget which one I use.  There's a case for about every permutation.
16:48:01 <ehird> mikael: Yes.
16:48:06 <ehird> Or at worst .. IORef (IORef Object)
16:48:06 <ddarius> I do use m -> r
16:48:37 <mikael> yeah, I think you need that, you want to either change a variable or change the actual object
16:49:22 <ehird> mikael: OK -- but why the 3 stack?
16:49:25 <hpaste>  morrow pasted "decodeSize" at http://hpaste.org/6023
16:51:15 <mikael> ehird: didn't strike me until in the shower a few minutes ago that the third is unnecessary, I was just doing it exactly like the bluebook says -- actually first I was planning to implement the whole heap and object memory as MArrays
16:52:04 <ehird> mikael: Doing your own GC for it?
16:53:02 <mikael> I had some undeveloped thoughts about using WeakRefs somehow, but it all seemed too difficult and kind of uninteresting :)
16:53:44 <ehird> mikael: is your source available anywhere?
16:53:47 <ehird> sounds like a cool project!
16:53:59 <ski_>   class (EqRef ref,Monad m) => MonadRef ref m | m -> ref
16:54:06 <ski_>   -- Note : No functional dependencies, just out of personal preference
16:54:31 <ski_> (seems i couldn't decide ..)
16:55:00 <mikael> it surely will be once it's more than embryonic
16:55:33 <ddarius> ski_: m -> ref ?
16:55:51 <ddarius> Or are you commenting about the inconsistency?
16:56:40 <ski_> that, and the nondecidedness about which (if any) FDs to use
16:57:35 <ddarius> The good argument for r -> m or none is ForeignPtr/Ptr/MVar, but those aren't as convenient as m -> r.
16:57:41 <ski_> (apparently, i was flipping the FD to see how it affected other parts of my LP embedding in haskell)
16:57:58 <ddarius> ski_: Based on Typed Logic Variables in Haskell?
16:59:15 <ski_> ddarius : yes, but adding a type parameter to `LPVar' describing the type of the contents (also adding a new(afaik) idea of my own to the system)
17:01:15 <ski_>   newtype Logic m o a = L (forall n p. ContStack m n => Bool -> (a -> (o -> n p) -> n p) -> (o -> n p) -> n p)  -- the monad
17:02:58 <ddarius> ski_: My MonadRef class was for exactly the same context only I was doing more something more "engineering" than "theory"
17:03:22 <ski_> (er, sorry, of course `Typed Logic Variables in Haskell' had type parameters ! .. i was not basing my impl. directly on their work, but on the idea and approach (more or less))
17:05:02 <ski_> my main extra idea was an implementation of implication goals (which can export instantiations)
17:05:24 <ddarius> ski_: Have you seen the following work related to Wired and adding support for residuation?
17:05:34 <ski_> nope
17:05:41 <ski_> link/title ?
17:06:01 <jacobian__> what is residuation again?
17:06:13 <monochrom> Wired?
17:06:42 <ddarius> http://www.cs.chalmers.se/~emax/wired/documents/LP_HFL07.pdf
17:07:04 <ski_> ty
17:07:08 <monochrom> emax is not an editor?  <duck>
17:08:47 <Lord_Illidan> Do you know if it's possible to delete empty items in a list?
17:09:40 <Lord_Illidan> eg, delete ["test",test2",[],[],[]) = ["test","test2"]
17:10:00 <ski_> > filter (not . null) ["test",test2",[],[],[]]
17:10:00 <lambdabot>  Improperly terminated string at "",[],..." (column 34)
17:10:04 <ac> lambdabot: filter null list
17:10:06 <ski_> > filter (not . null) ["test","test2",[],[],[]]
17:10:06 <lambdabot>  ["test","test2"]
17:11:14 <Lord_Illidan> holy crap, that's what I wanted, I think
17:11:24 <Lord_Illidan> btw, there is a delete function?
17:11:27 <Lord_Illidan> http://www.zvon.org/other/haskell/Outputlist/delete_f.html
17:11:27 <lambdabot> Title: Haskell : delete
17:11:30 <Lord_Illidan> doesn't seem to work
17:11:33 <Lord_Illidan> on ghc
17:11:49 <ddarius> :t delete
17:11:50 <ac> Lord_Illidan: filter removes items from a list
17:11:51 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
17:12:15 <Lord_Illidan> <interactive>:1:0: Not in scope: `delete'
17:12:36 <Lord_Illidan> ah, I had to do import delete
17:12:43 <Lord_Illidan> hmm, will try filter then
17:12:48 <Lord_Illidan> :src filter
17:12:56 <ac> @src filter
17:12:56 <lambdabot> filter _ []     = []
17:12:56 <lambdabot> filter p (x:xs)
17:12:56 <lambdabot>     | p x       = x : filter p xs
17:12:56 <lambdabot>     | otherwise = filter p xs
17:13:05 <ddarius> jacobian__: Sometimes you can't perform a computation without actual values as opposed to logic variables.  Residuation simply suspends evaluation in those cases and concurrently executes some other expression in hopes that the relevant logic variable will be bound.
17:13:15 <ac> > delete 1 [1..10]
17:13:16 <lambdabot>  [2,3,4,5,6,7,8,9,10]
17:13:30 <ski_> (ddarius : like e.g. (in prolog syntax) `?- XYs = [(_,9),(_,16)],( member((X,Y),XYs) => square(X,Y) ).' will have 4 solutions ..)
17:13:31 <Lord_Illidan> > delete 1 [1,1,2,3]
17:13:31 <lambdabot>  [1,2,3]
17:13:33 <ddarius> > delete 5 [2,3,4,5,5,6,7,6]
17:13:34 <lambdabot>  [2,3,4,5,6,7,6]
17:15:38 <ddarius> ski_: I'm assuming you've looked at various other more "advanced" than Prolog logic languages (particularly "abstract logic languages").  (The most interesting ones usually only have "toy" implementations.)
17:16:17 <ski_> ddarius : well, i've looked at lambdaProlog and lolli ..
17:16:35 <ski_> (and their implication goals is distinct from my idea)
17:17:05 <ski_> do you have any suggestions for things to look at ?
17:17:17 <jacobian__> ddarius: Ah, ok, I've used that technique for dealing with negation
17:17:18 <ddarius> Well, does "abstract logic language" mean something to you?
17:17:46 <ddarius> Also, presumably you've also looked at LolliMon?
17:18:16 <ski_> (ddarius : maybe glanced some on LolliMon)
17:18:39 <ski_> ddarius : well, istr the phrase from papers mentioning "uniform proofs" and such
17:19:04 <ddarius> ski_: Okay, then.  Those papers are the kinds of things I was going to suggest.
17:19:40 <jpcooper> @hoogle a -> [a] -> Bool
17:19:40 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
17:19:40 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
17:19:40 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
17:20:04 <ski_> ddarius : iirc (which i possibly don't), it was a subset of predicate logic sequents, in which every proof of a sequent can be found by using goal-directed search, before looking at assumptions
17:20:05 <Larose> If I want to call - say Data.List.group - what should I write ? (Hugs)
17:20:18 <mrd> import Data.List
17:21:52 <Larose> mrd: thanks
17:22:28 <ddarius> ski_: Not really "backend" stuff.  But have you looked at papers that have talked about destination passing style?
17:22:32 <ski_> (lambdaProlog's and similar treatment of implication is to add assumptions to the program, my approach is instead a generalization of negation-as-failure, in some way)
17:23:01 <ski_> ddarius : i'm not sure
17:23:16 <ski_> (ddarius : i haven't touched any of this recently)
17:23:23 <ddarius> The LolliMon paper talks about it a bit, but there is a paper specifically on it.
17:23:52 <ski_> i suppose i can look for those
17:24:12 <jacobian__> I remember vaguely that they were saying you could get a sort of "module" out of it, because you take A->B assume B, and reason in a world with B with all answers contingent on A.
17:24:41 <ski_> jacobian__ : that's how lolli thinks of modules, yes
17:25:55 <adu> I wonder why people don't write more parsers in Parsec...
17:26:00 <jacobian__> residuation and negation seem related
17:26:06 <adu> I want to write dozens of parsers...
17:26:21 <ac> erhg, it would be really nice if I could say ":source foo.hs" in ghci to get function defs from multiple files
17:26:30 <jacobian__> well I guess implication is like (not A or B)
17:26:45 <ski_> `?- strings --o (sorting string_case_folded_compare --o repl).' or something similar
17:26:45 <ac> I could almost say ":l !cat foo.hs bar.hs" but then I'd have multiple defs of main
17:27:06 <ac> not to mention ghci doesn't have "!"
17:27:39 <ski_> jacobian__ : depends on how you interpret `or', no ?
17:29:16 <ac> so I bet this has been asked repeatedly, but could someone give me a quick answer or point me to a link that explains what the technical limmitation is for ghci to interpret new types?
17:29:51 <ac> actually, if you say ":l foo.hs" it's still being interpreted...
17:30:31 <ac> so the limmitation is to dynamically load code with new types
17:30:50 <jacobian__> ski_: do you mean computationally?
17:31:08 <jacobian__> How did your idea work?
17:31:15 <ski_> well, both logically and computationally
17:31:48 <ski_> jacobian__ : my idea for implication goals ?
17:33:41 <jacobian__> ski_: yes
17:34:20 <lekro> monochrom: btw, using ghc-6.8.2 instead of 6.6.1 solved my segfault with GLUT/HOpenGL. and my program compiled just fine with the new version.
17:34:46 <ski_> well, it was inspired by the `\+ ( Antecedent,\+ Consequent )' version
17:34:57 <jacobian__> http://homepages.inf.ed.ac.uk/wadler/papers/dual/dual.pdf seems relevant
17:35:05 <jacobian__> he discusses both variants
17:35:23 <jacobian__> the negated conjunction and the disjunction
17:35:24 <ski_> the problem with that being that negation-as-failure can't export instantiations, only answer yea or nay
17:36:08 <lispy> suppose I have the function, foo :: (forall x. a x -> b) -> a x -> b,  Now, I can't pass 'id' as a parameter to foo.  That's a type error.  Is that because haskell is predicative?
17:36:14 <jacobian__> does constructive negation help?
17:37:27 <jacobian__> instead of just carrying around a conjunction of equations, carry around disequations as well
17:37:41 <ski_> jacobian__ : the reason that that version can work at all for checking cases is that varianbles which appear only in `Antecedent' and possibly also in `Consequent' will behave as universally quantified over the whole imlpication
17:38:05 * ski_ has considered trying to add disequations to his system
17:38:37 <jacobian__> really, carrying around disequations seems related to continuation passing though
17:38:40 <jacobian__> and residuation
17:38:48 <jacobian__> since you are just defering failure
17:38:56 <jacobian__> but you can give constructive answers even without bindings
17:39:46 <lispy> ?djinn (a -> b) -> a -> b
17:39:46 <lambdabot> f a = a
17:39:48 <jacobian__> contingent bindings, in worlds satisfying certain constraints
17:39:58 <ski_> jacobian__ : however, when we enter a negation, variables which from the outside behaved as existentially-quantified should behave as universally-quantified from this frame of reference (and vice versa) (more correctly, uninstantiated logic variables should behave as skolems, and vice versa)
17:40:20 <ddarius> There has to be some modal logic programming language somewhere.
17:40:38 <ski_> jacobian__ : so, even though `Antecedent' can't instantiate outside variables, `Consequent' still ought to be able to, according to this reasoning
17:41:23 <mikael> is it just me or is it really painful to make a module use MonadRef instead of IORef? :(
17:41:28 <ski_> jacobian__ : the crucial thing is that `Consequent' cam only do it *via* `Antecedent'
17:42:09 <ddarius> mikael: It makes the data types a bit hairier as they need to carry around a type parameter for the reference type, but otherwise it should be exactly the same.
17:42:13 * lispy wonders if #logic is a better place for this discussion
17:42:15 <dolio> lispy: foo :: forall a x b. (forall x. a x -> b) -> a x -> b
17:42:28 <dolio> lispy: b is bound outside the higher ranked function.
17:42:37 * jacobian__ thinks #logic is about audio software or something
17:42:38 <mikael> ddarius: two parameters, right, one for the reference type and one of the underlying monad?
17:42:53 <jacobian__> besides, aren't we all type theory geeks?
17:42:54 <dolio> So it's not polymorphic enough to be (forall x. a x -> a x)
17:43:10 <ski_> jacobian__ : in `?- make_tree_with_partial_elements(Tree),( member_tree(Element,Tree) => instantiate_element(Element) )', this will instantiate the whole tree
17:43:14 <dolio> I think.
17:43:21 <lispy> dolio: Okay, right.  I was wondering if "not polymorphic enough" is caused by haskell being predicative
17:43:37 <ddarius> mikael: Not for "data structures", but for things manipulating "computations", yes.
17:43:38 <lispy> dolio: does this happen because b can't be a polytype, or is there a more fundamental problem
17:43:49 <jacobian__> Wadler just had some conjecture about negation in types on the Types mailing list... :)
17:44:41 <lispy>     Inferred type is less polymorphic than expected
17:44:41 <lispy>       Quantified type variable `x1' escapes
17:44:41 <lispy>     In the first argument of `foo', namely `id'
17:44:49 <dolio> lispy: I think it's due to it being monotypic.
17:44:51 <lispy> dolio: that's what GHC says about 'foo id'
17:45:06 <dolio> For instance, if you passed in id, you'd expect the type to be...
17:45:12 <ski_> jacobian__ : so `member_tree(Element,Tree)' establishes a temporary *link* between an element of `Tree' and `Element', then `instantiate_element(Element)' instantiates `Element' and thereby a part of the tree, then the next solution of `member_tree(Element,Tree)' so the link is broken and reestablished to another part of the tree ..
17:45:31 <ski_> jacobian__ : but the instantiated element *stays*instantiated* !
17:45:37 <dolio> forall a b x. (forall x'. a x' -> a x) -> a x -> a x
17:46:05 <ski_> jacobian__ : i even allow `instantiate_element(Element)' to have multiple solutions :)
17:46:11 <lispy> dolio: yeah, I guess that is why it says it's trying to escape :(
17:46:21 <ski_> jacobian__ : do you follow, so far ?
17:46:37 <dolio> Yeah. You don't have (forall x'. a x' -> a x) you have (forall x'. a x' -> a x').
17:46:46 <mikael> these are the kinds of errors that kind of make me beat my head against the granite window sill:
17:46:49 <mikael> Urk! Inventing strangely-kinded Any TyCon:
17:46:49 <mikael>     a2Ei (base:GHC.Prim.*{(w) tc 34d} -> base:GHC.Prim.*{(w) tc 34d})
17:46:49 <mikael> 	 -> base:GHC.Prim.*{(w) tc 34d}
17:46:49 <mikael> 	 -> base:GHC.Prim.*{(w) tc 34d}
17:47:51 <guenni> this haskell stuff is really deep, uhm
17:49:00 <lispy> mikael: what features of ghc cause that message?
17:49:06 <lispy> (I'll learn to steer clear...)
17:49:17 <ski_> <jacobian__> but you can give constructive answers even without bindings
17:49:18 <dolio> lispy: I don't think that's predicativity, though. That has to do with turning 'a x' into 'a (forall y. y)'. But I'm not well read in the area.
17:49:19 <ski_> <jacobian__> contingent bindings, in worlds satisfying certain constraints
17:49:20 <ski_> ?
17:49:31 <lispy> dolio: I agree.
17:49:44 <mikael> lispy: not doing anything sophisticated, it's probably just very confused by my very confused incorrect code :)
17:49:59 <lispy> mikael: i've never seen those sort of error messages
17:50:02 <ddarius> mikael: That's an internal error.
17:50:08 <lispy> and i've seen some weird errors from ghc before
17:50:21 <lekro> when I install ghc-6.8.2, will I still be able to use my old ghc-6.6.1 with all the modules I installed?
17:50:26 <lispy> just today it told me to send in my code to GHC headquarters and tell them if I wanted it to unify or not...
17:50:46 <lispy> lekro: I think that depends on the distro or operating system
17:50:57 <lekro> lispy: that'd be Mac OS X
17:51:18 <lekro> ghc-6.6.1 was installed by fink and I'd install ghc-6.8.2 with a different prefix
17:51:26 <mikael> I got the error just before a monomorphism error, everything compiles if I add NoMonomorphismRestriction
17:53:02 <lekro> like, if I install ghc-6.8.2 into ~/local would it break ghc-6.6.1 which is in / ?
17:53:13 <lispy> lekro: I don't know.  I've never tried it.
17:53:21 <lispy> Wish I could provide better help.
17:54:24 <lispy> lekro: you might try asking in #ghc
17:54:34 <ddarius> There should be no trouble installing multiple GHCs
17:54:43 <lekro> I guess I'll just have to try it then. with prefix=~/local I should always be able to remove it in the case of conflicts
17:56:41 <jgerman> I'm curious as well, though I'm trying to overwrite my 6.8.1
17:57:10 <jgerman> doesn't cabal register stuff with ghc? installing a new version won't affect that?
17:57:33 <gwern> there are two cabal/ghc databases, global and per-user
17:57:54 <lekro> where is the per-user database stored?
17:58:05 <gwern> in .cabal, iirc
17:58:09 <jgerman> ah, right, I think I've mixed and matched them
17:58:19 <gwern> ahwait, '/home/gwern/.ghc/x86_64-linux-6.8.2/package.conf'
17:59:02 <lekro> so the location is version dependent, good
18:01:23 <jacobian__> ski: you can have a binding set, a substitution, that requires that certain disequations are satisfied even if the variables involved in the disequation are not all bound.
18:01:36 <ski_> ok
18:02:44 <ski_> (i was thinking of "not bound" in the sense of meaning "uninstantiated/fresh" as opposed to "constrained")
18:02:59 <cin> can i have an array of MVars? or should i use an MVar with an array in it?
18:03:14 <jacobian__> they may actually be bound in a way that is not outside of the constraint
18:03:19 <ski_> cin : you can have either, or both
18:03:30 <ddarius> or neither
18:03:37 <ski_> (:
18:03:45 <jacobian__> like X=f(Z) /\ X /= f(r)
18:03:57 <cin> unfortantely i need them
18:04:32 <ski_> jacobian__ : that adds a constraint `Z \= r' to the constraint store, no ?
18:04:47 <jacobian__> yeah, when simplified
18:04:52 <ski_> *nod*
18:05:25 <ski_> (i'm still not sure what you mean by "outside of the constraint")
18:06:18 <ski_> (jacobian__ : did you want me to continue with the explanation of my idea, for the moment ?)
18:06:32 <jacobian__> not inconsistent with the constraint
18:07:47 <jacobian__> I'm sorry for my incorrect usage of terminology, I'll try to amend that. :)
18:08:54 * ski_ has no idea whether it was incorrect, just that he didn't know it
18:09:22 <jacobian__> well, I implemented a lot of stuff using negation in logic program en vacuum
18:09:45 <jacobian__> So, I've had to play catch-up.
18:10:32 <jacobian__> s/program/programming/
18:12:58 <lispy> jacobian__: do you mean in a vacuum or a vacuum tube ;)
18:13:49 <ddarius> weak
18:14:47 <jacobian__> heh
18:16:09 * ski_ must leave ..
18:16:18 <ski_> later
18:29:40 <OceanSpray> what's the Haskell modulo operator?
18:29:52 <dolio> mod
18:29:52 <ehird> `mod`
18:30:42 <lispy> > 7 `mod` 4
18:30:43 <lambdabot>  3
18:30:52 <lispy> > mod 7 4
18:30:53 <lambdabot>  3
18:31:17 <pjd> > 7 `divMod` 3
18:31:18 <lambdabot>  (2,1)
18:31:49 <mrd> > 7 `rem` 4
18:31:49 <lambdabot>  3
18:32:20 <lispy> > 4 `gcd` 8
18:32:21 <lambdabot>  4
18:35:49 <chadz__> i want postfix
18:37:36 <EvilTerran> > let (?) x = (x,x) in (12?)
18:37:37 <lambdabot>  (12,12)
18:38:01 <yondalf_> i think that's with a ghc extension
18:38:08 <chadz__> continuations, right?
18:38:21 <EvilTerran> ...no
18:38:43 <EvilTerran> it's just (x +) desugars to ((+) x) anyway
18:39:12 <EvilTerran> but the report either says or implies that the function should be at least binary
18:39:25 <EvilTerran> ahd ghc doesn't require that
18:39:58 <yondalf_> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html <- see section 8.3.6
18:39:59 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
18:43:51 <OceanSpray> what the hell is nominalDIffTime?
18:45:46 <newsham> http://www.thenewsh.com/%7Enewsham/lambda/primes.lam
18:47:14 <monochrom> What is WITHLIST?
18:49:08 <newsham> defined here http://www.thenewsh.com/%7Enewsham/lambda/prelude.lam
18:51:11 <monochrom> Oh noes, scoped library!
18:51:44 <newsham> it was the easiest way for me to make a prelude
18:51:49 <newsham> using macros for the body
18:54:01 <mikael> I modified the Beauty in the Beast paper's variables to have arbitrary content types, not just Ints, but now I don't understand how to implement MonadRef for them, because now my monad is of kind * -> * -> * :(
18:54:33 <newsham> mono: otherwise I woulda had to have a prelude plus a bunch of closing parens for a postlude :)
18:55:30 <mikael> I want to say: instance MonadRef PureRef (PureIO <the type given to PureRef>)
18:58:16 <mikael> actually I'm doomed, MonadRef requires that you can handle a ref to any type in the same monad
18:58:47 <ddarius> So make ParameterizedMonadRef
18:59:26 <monochrom> class MonsterRef r a m where newRef :: a -> m (r a) ...  :)
19:00:34 <monochrom> "GHC 10.3 will incorporate full Mercury as its type class language" :)
19:01:03 <mikael> oh yeah... I just hope I don't have to rehaul the code that uses all these goddamned references YET AGAIN :-)
19:01:06 <mikael> thanks guys
19:01:29 <monochrom> Oleg cat will say "whee!  I can haz uniqueness kind for my type class hackz!"
19:13:04 <OceanSpray> I am confused by UTCTime
19:15:11 <mrd> universal coordinated time
19:15:50 <monochrom> Universale Timeles Coordinaire
19:15:57 <monochrom> (pardon my French) :)
19:16:12 <swidgy> french can not be pardoned
19:16:14 <mrd> apology accepted
19:16:15 <swidgy> ;)
19:16:39 <OceanSpray> the bug is this:
19:16:47 <OceanSpray> I'm getting two values of UTCTime
19:16:52 <OceanSpray> one through getCurrentTime,
19:17:03 <OceanSpray> and another by parsing the text from a webpage.
19:17:26 <OceanSpray> for some odd reason, they just don't match up.
19:17:45 <mrd> i'd imagine a webpage probably has some old time
19:17:48 <ddarius> Why should they?
19:17:57 <OceanSpray> the webpage is in Autralia, but isn't UTCTime supposed to be the "same" for all locations?
19:18:34 <OceanSpray> don't match up as in, the time on the page MUST be older than my time over here,
19:18:39 <mrd> is the webpage printing time in UTC?
19:18:40 <OceanSpray> but instead, it's in the FUTURE.
19:19:02 <OceanSpray> no, but it's got a +0500 thingie.
19:19:21 <mrd> well, try feeding that string into the parser and see if it comes out right
19:19:31 <mrd> if not, file a bug
19:20:05 <OceanSpray> oy.
19:44:34 <shapr> whee!
19:44:47 <dolio> @yow!
19:44:47 <lambdabot> I want to dress you up as TALLULAH BANKHEAD and cover you with VASELINE
19:44:47 <lambdabot> and WHEAT THINS ...
19:44:58 <shapr> @quote dolio
19:44:58 <lambdabot> dolio says: Perhaps he's an epigram guy and frowns on Turing completeness.
19:45:16 <dolio> Hey shapr, what was the difference between linear and uniqueness typing? Weakening?
19:46:04 <pjd> dolio: does using a uniquely-typed value "consume" it?
19:46:23 <shapr> http://www.cs.ru.nl/~clean/download/papers/1996/bare96-uniclosed.pdf ?
19:46:25 <lambdabot> http://tinyurl.com/2tk6kq
19:46:53 <dolio> Aww, a paper? I thought you said someone told you at lunch the other day or something. :)
19:47:08 <shapr> iirc, linear types are single use, uniqueness types are single user.
19:47:21 <shapr> Yeah, edwardk did describe the whole thing to me, let me check my notes.
19:48:11 <pjd> the second Google hit for "linear typing" is "Investigations on the use of linear typing in the breeding of riding horses."
19:48:31 <dolio> Huh. That sounds a bit odd.
19:49:32 <shapr> Hm, I can't find my pic of the lattice edwardk drew.
19:49:45 <shapr> I hope I didn't lose it.
19:50:53 <shapr> dolio: Bah, I don't remember :-(
19:50:54 <dolio> That paper does seem (skimming) to say it has weakening but not contraction.
19:51:25 <dolio> So you can throw a uniquely typed value away, but you can't use it twice.
19:54:45 <shapr> Oh that does sound familiar.
19:56:00 <shapr> Two of the lattice properties were "use zero or one times" and "use one or more times", I think.
19:56:34 <shapr> Still doesn't sound quite right, hmm.
19:58:52 <lispy> is that what Clean uses?
20:00:28 <dolio> Well, with contraction and weakening would be use 0 or more times.
20:00:39 <dolio> With contraction but not weakening would be use 1 or more times.
20:00:58 <dolio> With weakening but not contraction would be 0 or 1 time.
20:01:07 <dolio> And without either (linear typing) would be exactly 1 time.
20:02:33 <lispy> shapr: you've been a #haskeller as long as anybody.  how did you learn about the language?
20:03:40 <dolio> And, yeah, uniqueness types are what Clean uses.
21:09:54 <orbisvicis> what should i do about utf8 requiring ByteString ... which was found in multiple packages: bytestring-0.9.0.4 base ?
22:15:22 <awesame> :type (<-)
22:15:31 <awesame> hm
22:15:35 <awesame> :t (<-)
22:15:36 <mrd> just syntax
22:15:38 <lambdabot> parse error on input `<-'
22:15:43 <awesame> there we go
22:15:48 <mrd> not an operator
22:15:55 <awesame> thank goodness
22:15:57 <mrd> :t (>>=)
22:15:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:16:02 <dino-> :t (->)
22:16:04 <lambdabot> parse error on input `->'
22:16:06 <awesame> my head was going to explode if it was an operator
22:16:26 <mrd> @undo do { x <- foo; return (g x) }
22:16:26 <lambdabot> foo >>= \ x -> return (g x)
22:16:30 <dino-> awesame: A lot more things are functions than you'd expect, eh?
22:16:38 <awesame> yeah!
22:16:54 <dino-> It's like it's built with itself.
22:17:27 <awesame> it's haskell all the way down
22:17:34 <dino-> :t (,)
22:17:36 <lambdabot> forall a b. a -> b -> (a, b)
22:18:08 <awesame> geez
22:18:29 <dino-> tuple contruction
22:18:56 <mrd> :t (,,)
22:18:58 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
22:19:20 <mrd> but sadly,
22:19:23 <mrd> :t (1,)
22:19:25 <lambdabot> parse error on input `)'
22:20:12 <mauke> @let (~>) = (,)
22:20:13 <lambdabot> Defined.
22:20:22 <u_quark> :t (,)
22:20:22 <mauke> > (1 ~>) "butter"
22:20:24 <lambdabot>  (1,"butter")
22:20:24 <lambdabot> forall a b. a -> b -> (a, b)
22:20:33 <idnar> :t (1 ~>)
22:20:35 <lambdabot> forall t b. (Num t) => b -> (t, b)
22:20:44 <u_quark> :t (,) 1
22:20:45 <lambdabot> forall t b. (Num t) => b -> (t, b)
22:20:52 <mrd> @let (~,) = (,)
22:20:52 <lambdabot>  Parse error
22:21:00 <u_quark> :y ((,) 0
22:21:02 <mrd> @let (><) = (,)
22:21:03 <lambdabot> Defined.
22:21:09 <mrd> > (1 ><) 2
22:21:09 <lambdabot> Terminated
22:21:15 <u_quark> :t ((,) 1)
22:21:17 <lambdabot> forall t b. (Num t) => b -> (t, b)
22:21:17 <mrd> > (1 ><) 2
22:21:17 <lambdabot> Terminated
22:21:26 <mrd> er?
22:21:28 <mauke> @undefine
22:21:28 <lambdabot> Undefined.
22:21:31 <mauke> > 1 >< 2
22:21:32 <lambdabot>        add an instance declaration for (Num (Series b), Num (Series a))
22:21:40 <mrd> Series?!
22:21:53 <mauke> :t (><)
22:21:54 <lambdabot> forall a b. Series a -> Series b -> Int -> [(a, b)]
22:22:15 <mauke> that's a new one
22:22:17 <awesame> today I learned to read "<-" as ascii art for the symbol for "is a member of" or "in", even outside of list comprehensions
22:22:18 <mrd> @index Series
22:22:18 <lambdabot> bzzt
22:22:27 <awesame> this makes do notation make a lot more sense
22:22:47 <mrd> do { x <- getLine; ... } ?
22:23:05 <mrd> I suppose you could. the <- in list comprehensions is really the same as the <- in do notation.
22:23:13 <mrd> just specialized to lists
22:23:15 <awesame> (previously I was thinking of "x <- foo" as "put foo into x")
22:23:33 <Mr_Awesome> didnt list comprehensions used to work for all monads?
22:23:37 <awesame> yeah, it even makes sense for the IO monad
22:23:52 <lispy> heh, is Mr_Awesome teaching awesame?
22:23:56 <lispy> that's kinda cute :)
22:24:07 <awesame> "x <- getLine" means "x is a member of the possible values returned by getLine"
22:24:09 <Mr_Awesome> coincidence, i assure you :P
22:24:18 <awesame> heh
22:24:27 <dino-> I had also read that it can be read as "drawn from"
22:24:38 <lispy> awesame: ah, nice interpretation.
22:24:39 <Mr_Awesome> ive gotten a few false highlights thanks to you, awesame
22:24:54 <awesame> Mr_Awesome: my apologies
22:25:17 <Mr_Awesome> heh, its not your fault ;)
22:25:44 <awesame> to be awesame is to have impressive rotational symmetry (from awesome + same, and turn your monitor upside down and read "awesame" as rendered in, say, courier)
22:26:23 <lamentb> heh.
22:26:58 <lispy> Mr_Awesome: I kinda want to change my nick to Dr_Awesome
22:27:15 <dolio> I liked McLispy.
22:27:33 <dolio> And OKorollary.
22:27:44 <lispy> heh, oh yeah, that was when OKorollary was my IRC bar tender
22:28:13 <Mr_Awesome> i want to change my nick, but i cant think of anything better than Mr_Awesome, unfortunately
22:28:24 <lispy> I wonder if Dr_Evil is taken
22:28:36 <lispy> is . an allowed char? I guess not or you would have used it?
22:28:55 * lispy has always fancied having a PhD in mad science
22:29:46 <Mr_Awesome> indeed. in forums my nick is Mr. Awesome
22:30:44 <lispy> I kinda like FunctorSalad
22:31:06 <lispy> Seems like cheating to copy it and do MonadStew though
22:32:10 <lispy> there was a proposal at one time to change my nick to lambdy or similar since i don't really use lisp
22:32:16 <Mr_Awesome> you could always pick a string of 4 letters with no pronunciation, like xkcd
22:32:22 <Korollary> I recommend Lindsay
22:32:28 <lispy> Korollary++
22:32:48 <dolio> @karma OKorollary
22:32:48 <lambdabot> OKorollary has a karma of 0
22:35:55 <dolio> @quote qwe1234
22:35:56 <lambdabot> qwe1234 says: you forgot the fact that ocaml is used for writing real software that solves real problems, unlike haskell.
22:37:21 <awesame> it's true, haskell is not really a problem
22:38:55 <Korollary> Did he really say that?
22:39:09 <dolio> He really says all kinds of things.
22:39:30 <Mr_Awesome> does he think haskell is for writing imaginary software?
22:39:31 <Korollary> I doubt he said anything good about any FP
22:39:48 <Mr_Awesome> cause we do have a complex module
22:40:03 <dolio> He does seem less negative about OCaml.
22:40:20 <dolio> Although it's still, of course, far inferior to C++.
22:40:51 <lispy> can't we all just get along?
22:40:55 <Korollary> No
22:41:06 <lispy> C++ has its merits, Korollary sucks, and Haskell is good too.  End of story?
22:41:11 <Mr_Awesome> whats the fun in getting along?
22:42:35 <siti> Mr_Awesome++
22:43:56 <dolio> OCaml probably has less theoretical stuff written about it (at least, stuff that's commonly presented), so it's less threatening to his 'I know everything worth knowing about computer science' view of himself.
22:45:13 <dolio> Either that, or he thinks praising OCaml bothers 'Haskell people.'
22:45:21 <siti> http://reddit.com/user/qwe1234/
22:52:18 <cin> @quote Cin
22:52:18 <lambdabot> skew says: [monads are] just like the sequences of statements in other languages. Except very rarely have they thought so deeply about what that sequencing means
22:52:58 <cin> profound statement
22:53:24 <roconnor> overloaded ;
22:53:31 <mauke> @quote mauke
22:53:31 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
22:53:48 * cin chortles
22:54:07 <oerjan> > (0$0 `liftM`)
22:54:07 <lambdabot>      The operator `liftM' [infixl 9] of a section
22:54:07 <lambdabot>         must have lower pre...
22:54:24 <oerjan> hm it's left associative
22:54:33 <wagle_home> > product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
22:54:33 <lambdabot>  120
22:54:52 <oerjan> oh wait it's == fmap, so it is associative
22:55:11 <mauke> > product . (read .) . (return .) . take 5 $ "1234567"
22:55:11 <lambdabot>  120
22:55:56 <dolio> > randoms (mkStdGen 28953) !! 1000000 :: Float
22:55:59 <lambdabot>  Exception: stack overflow
22:57:06 <oerjan> @quote fmap.fmap
22:57:06 <lambdabot> No quotes match. My mind is going. I can feel it.
22:57:32 <oerjan> fmap fmap fmap, the ultimate mental masturbation
22:57:45 <mauke> haha
22:57:56 <wagle_home> > fix fmap
22:58:01 <lambdabot>      Occurs check: cannot construct the infinite type: a = f a
22:58:03 <lambdabot>       Expected...
22:58:21 <mauke> @quote fmap fix
22:58:21 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
22:59:46 <oerjan> @quote fmap.fix
22:59:46 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
23:00:11 <wagle_home> > fmap fix [fmap]
23:00:12 <lambdabot>      Occurs check: cannot construct the infinite type: a = f a
23:00:12 <lambdabot>       Expected...
23:01:58 <wagle_home> > Maybe $ fmap fix [fmap]
23:01:58 <lambdabot>   Not in scope: data constructor `Maybe'
23:02:06 <wagle_home> > Just $ fmap fix [fmap]
23:02:07 <lambdabot>      Occurs check: cannot construct the infinite type: a = f a
23:02:07 <lambdabot>       Expected...
23:02:23 <mauke> you can't fix fmap
23:02:45 <oerjan> it's thoroughly broken
23:03:03 <mauke> s/broken/non-broken/
23:03:11 <mauke> don't fix it if it ain't broken
23:03:15 <oerjan> *whoosh*
23:03:27 <oerjan> ah yes
23:03:31 <shachaf> > return fmap -- If it's broken.
23:03:31 <lambdabot>        add an instance declaration for (Show (m ((a -> b) -> f a -> f b)))
23:03:40 <gour> @seen dons
23:03:40 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I don't know when dons last spoke.
23:03:57 <shachaf> gour: Gone skiing.
23:04:23 <oerjan> @uptime
23:04:23 <lambdabot> uptime: 8h 31m 3s, longest uptime: 1m 10d 23h 44m 29s
23:04:32 <oerjan> @users
23:04:32 <lambdabot> Maximum users seen in #haskell: 463, currently: 382 (82.5%), active: 14 (3.7%)
23:04:36 <gour> shachaf: huh...and he left broken mkcabal :-D
23:04:49 <oerjan> > fix mkcabal
23:04:50 <lambdabot>   Not in scope: `mkcabal'
23:05:23 <shachaf> > fix mkCabal
23:05:25 <lambdabot>  "@get-dons"
23:05:38 <gour> :-)
23:07:08 <lispy> > mkCabal :: Expr
23:07:08 <lambdabot>   Not in scope: `mkCabal'
23:07:11 <dolio> @src randoms
23:07:11 <lambdabot> Source not found. :(
23:07:31 <lispy> I figured mkCabal = const "@get-dons"
23:08:05 <mauke> > mkCabal ()
23:08:05 <lambdabot>   Not in scope: `mkCabal'
23:08:42 <oerjan> > fun (fix mkCabal) :: Expr
23:08:42 <lambdabot>  @get-dons
23:11:29 <dolio> > [1..] !! 1000000
23:11:30 <lambdabot>  Exception: stack overflow
23:12:04 <cin> =o
23:13:58 <bos> > [(1::Int)..] !! 1000000
23:13:58 <lambdabot>  1000001
23:16:04 <dolio> > [1..] !! 1000000 :: Float
23:16:05 <lambdabot>  Exception: stack overflow
23:17:27 <dolio> That's a known bug, no? I assume the same problem is causing the randoms overflow on haskell-cafe.
23:17:41 <dolio> Not that 'take' isn't tail recursive.
23:19:53 <Lemmih> Doesn't it go away with -O?
23:20:02 <cin> > do gen <- getStdGen; let ns = randoms gen :: [Int]; print $ take 10 ns
23:20:02 <lambdabot>  Parse error at end of input
23:20:10 <cin> > do { gen <- getStdGen; let ns = randoms gen :: [Int]; print $ take 10 ns; }
23:20:10 <lambdabot>  Parse error at ";" (column 73)
23:21:17 <oerjan> > do gen <- getStdGen; let { ns = randoms gen :: [Int] }; print $ take 10 ns
23:21:18 <lambdabot>  <IO ()>
23:21:58 <oerjan> the layout rule doesn't end the let before the print unless you use brackets
23:23:10 <bos> dolio: the thing you're seeing with [1..] is due to lambdabot defaulting to Integer, and Integer has weird strictness semantics.
23:23:19 <dolio> "main = print ([1..] !! 1000000 :: Float)" overflows.
23:23:25 <dolio> -O2
23:23:26 <oerjan> bos: so did Float apparently
23:23:45 <oerjan> > [1..] !! 1000000 :: Double
23:23:46 <lambdabot>  Exception: stack overflow
23:23:59 <dolio> I'm pretty sure it's known.
23:24:15 <bos> yes, it is known.
23:25:34 <bos> i think that the overflow on Double and Float has something to do with the implementation of succ for those types
23:25:54 <bos> it's building a huge nested application of succ (succ (succ ... 1.0))
23:26:04 <bos> because succ isn't strict for those types
23:26:24 <dolio> Oh. It might run through Integer.
23:26:32 <dolio> So if Integer is messed up...
23:26:35 <bos> whuh?
23:26:57 <dolio> @type fromEnum
23:26:58 <lambdabot> forall a. (Enum a) => a -> Int
23:27:02 <dolio> Oh, I suppose not.
23:27:27 <bos> it's lack of strictness of succ that's the problem.
23:28:06 <wagle_home> could be lambdabot specific
23:28:34 <bos> no, it's in the base library.
23:29:27 <wagle_home> how does lambdabot timeout of a computation?
23:29:34 <bos> implementations of succ for bounded types happen to be strict.
23:30:57 <dolio> Oh, I see.
23:31:08 <oerjan> > [1.5 .. 10] -- floating point ranges don't pass through any Int(eger)
23:31:09 <lambdabot>  [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5]
23:31:54 <dolio> succ for bounded types tests against the bound each time.
23:32:06 <wagle_home> seems like the last shouldnt exceed 10
23:32:09 <bos> yes, and likewise for enumFrom
23:32:26 <gogonkt-1`> > [1.1 .. 5]
23:32:26 <lambdabot>  [1.1,2.1,3.1,4.1,5.1]
23:32:33 <gogonkt-1`> cool
23:33:06 <oerjan> > [1.5 .. 10 :: Rational]
23:33:07 <lambdabot>  [3%2,5%2,7%2,9%2,11%2,13%2,15%2,17%2,19%2,21%2]
23:33:22 <gogonkt-1`> @_@
23:33:28 <oerjan> > [1.51 .. 10]
23:33:29 <lambdabot>  [1.51,2.51,3.51,4.51,5.51,6.51,7.51,8.51,9.51]
23:33:42 <oerjan> the cutoff is at .5
23:34:40 * wagle_home frowns
23:34:54 <wagle_home> or maybe
23:35:02 <oerjan> it's clearly described in the report
23:35:03 * wagle_home makes yucky face
23:35:06 <wagle_home> yeah
23:35:56 <oerjan> i guess the idea is that it is worse to get strange cutoffs because of rounding errors in common cases
23:37:17 <oerjan> (when the given endpoint is close to where the sequence ends)
23:38:11 <siti> woah man that qwe1234 guy is such a funny troll :D
23:38:48 <lamentb> @quote qwe1234
23:38:48 <lambdabot> qwe1234 says: lol, 'free university of amsterdam'.
23:38:55 <lamentb> @quote qwe1234
23:38:55 <lambdabot> qwe1234 says: For the majority of tasks, C++ templates produce code that is clearer and better type-checked [than Haskell].
23:40:19 <siti>   p.s. i wanted to flame you for being illiterate (is english your third language?) but i dropped the idea since you wouldn't understand me anyways.
23:40:20 <siti> classic
23:43:17 <wagle_home> he was here recently?
23:43:41 <siti> nah I am just reading his comments on reddit, it's really good entertainment
23:43:48 <wagle_home> ah
23:44:19 * wagle_home thinks
23:44:47 <wagle_home> C++ templates can list the primes in error messages!  lets see haskell do that!
23:45:30 <oerjan> > error $ show $ nubBy (((>1).).gcd) [2..]
23:45:33 <lambdabot>  Exception: [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83...
23:45:48 <siti> lol
23:46:22 <wagle_home> get the type system to do it
23:46:35 <OceanSpray> that dude's hilarious.
23:47:20 <dolio> It's doable with GHC extensions.
23:48:04 <wagle_home> i believe it
23:48:23 <dolio> Not that I'd feel like figuring it out.
23:48:33 <wagle_home> i gotta become a typesystemomancer
23:48:34 <oerjan> @faq Can Haskell do a quine in the type system, at compile time?
23:48:34 <lambdabot> The answer is: Yes! Haskell can do that.
23:49:04 <dolio> But Oleg's written type arithmetic stuff.
23:49:17 <dolio> And, of course, embedded the lambda calculus.
23:50:12 <OceanSpray> @faq Can Haskell do _?
23:50:12 <lambdabot> The answer is: Yes! Haskell can do that.
23:50:15 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6025
23:50:19 <OceanSpray> well, damn.
23:50:26 <OceanSpray> I got no more to ask.
23:51:27 <codetoad> http://hpaste.org/6025 i'm having some trouble with basic (?) syntax - killing the let expression causes me to get a syntax error
23:52:05 <oerjan> codetoad: indent the else a bit
23:52:34 <oerjan> oh and you are missing an in for the second let
23:53:24 <codetoad> oerjan: thanks.  i had this problem with the indented else before
23:54:04 <oerjan> if then else gets in trouble with the indentation rules in a do block
23:54:20 <oerjan> so it's the only place where you cannot line it up
23:55:35 <siti> I might subscribe to his comments ;)
23:55:46 <siti> http://reddit.com/user/qwe1234/.rss :D
23:56:04 <oerjan> codetoad: you could also put the last let inside the do, there is a syntax for that
23:56:40 <wagle_home> so..  hm..  everything that wasnt done in the 60's, was done by oleg?
23:58:52 <hpaste>  oerjan annotated "(no title)" with "one way" at http://hpaste.org/6025#a1
23:59:39 <oerjan> codetoad: that's one way.  actually if the total' <- return ( at the beginning are as intended, then that could be changed into let total' = as well
