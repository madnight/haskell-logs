00:49:45 <glguy> ?seen dons
00:49:45 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 1h 1m 19s ago.
00:49:56 <glguy> dons: you'll either love this or hate this :)
00:50:02 <glguy> hpaste_: url
00:50:05 <hpaste_> http://71.111.57.135/cgi-bin/hpaste.fcgi/
00:50:13 <glguy> http://71.111.57.135/cgi-bin/hpaste.fcgi/view?id=1
00:50:36 <glguy> the lines to mark yellow are stored in the database
00:50:51 <glguy> so we'll be able to click to highlight a line to point somethign out on it
00:50:57 <glguy> bah
00:50:58 <glguy> 1h
00:51:04 <glguy> I thought he was just 1m out
00:51:16 <glguy> (what you might hate is the implementation :))
00:53:16 <doserj> glguy: is there a deeper reason behind the ordering of languages to choose from?
00:53:33 <glguy> the default output order of pygments?
00:53:40 <glguy> I just got that all wired in today
00:53:45 <glguy> so I haven't spent time on the cosmetics yet
00:53:50 <doserj> ah :)
00:55:08 <glguy> I load a python file at runtime to subclass the HtmlFormatter atm
00:55:13 <glguy> (just once)
00:55:19 <glguy> to add support for the highlighted lines
00:55:32 <glguy> via the python c interface
00:55:37 <glguy> wanted to get dons reaction
00:56:02 <jbms> Trying to build regex-base with ghc 6.8.2 gives the error Text/Regex/Base/RegexLike.hs:44:17: Could not find module `Data.ByteString': it is a member of package bytestring-0.9.0.1, which is hidden
00:56:27 <jbms> The cabal file for the package doesn't seem to list bytestring, but why would the package be distributed incorrectly?
00:56:35 <jbms> should I just add the correct dependency?
00:56:49 <doserj> try the 0.72.x version
00:56:58 <jbms> it is the 0.72.x version
00:57:06 <doserj> oh, the 0.93.1 version on hackage seems ok
00:57:19 <jbms> I'm trying to build Yi, though, which seems to require 0.72
00:58:07 <doserj> the 0.72.0.1 version does depend on Bytestring, according to hackage.
00:58:26 <doserj> (for base >= 3)
00:58:45 <jbms> ah okay
00:58:48 <glguy> yi isn't under "active development"
01:02:23 <jbms> I see
01:02:28 <jbms> I figured I'd look at it anyway
01:10:33 <quicksilver> glguy: eh? yes it is...
01:12:25 <jbms> I've noticed that yi is actually quite a lot slower than emacs
01:12:35 <jbms> Surely that can't be a good sign
01:13:44 <quicksilver> glguy: yi had a new release at the end of january and loads of commits in february
01:13:49 <quicksilver> glguy: how active do you want? :)
01:14:04 * Zao won't touch it until it gets s/// support.
01:21:20 <quicksilver> jbms: Dunno. I suspect that would be more to do with the display code than anythign fundamental, I presume
02:21:28 <shag> what is the easiest way to catch a parse error from "read"? e.g. i want to return 0 if reading an integer from a string fails.
02:23:22 <Lemmih> > readM "fail" :: Maybe Int
02:23:23 <lambdabot>  Nothing
02:23:29 <Lemmih> > readM "10" :: Maybe Int
02:23:29 <lambdabot>  Just 10
02:23:57 <Lemmih> ('readM' isn't in the standard libraries, though)
02:25:16 <opqdonut> > readM "10" :: [Int]
02:25:16 <lambdabot>  [10]
02:25:26 <opqdonut> ?src readM
02:25:26 <lambdabot> Source not found. You type like i drive.
02:26:04 <Lemmih> opqdonut: The definition of 'readM' is left as an exercise for the reader.
02:26:37 <opqdonut> yeah, i guess it does nothing fancy, just wraps readS into fail and return
02:26:58 <opqdonut> :t readM
02:26:59 <lambdabot> Not in scope: `readM'
02:27:01 <Lemmih> Indeed.
02:27:03 <opqdonut> gah
02:27:14 <opqdonut> is it (Monad m) => or something stricter?
02:28:07 <Lemmih> (Monad m, Read a) => String -> m a
02:28:40 <opqdonut> yeah
02:28:47 <ibid> :t readIO
02:28:47 <lambdabot> forall a. (Read a) => String -> IO a
02:30:19 <quicksilver> shag: the short answer to your question is to use "reads" not "read"
02:30:22 <quicksilver> :t reads
02:30:23 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:31:27 <shag> quicksilver: ok, thanks
02:32:23 <quicksilver> let readMaybe s = case reads s of [(x,"")] -> Just x; _ -> Nothing in readMaybe "3,14" :: Maybe Double
02:32:26 <quicksilver> > let readMaybe s = case reads s of [(x,"")] -> Just x; _ -> Nothing in readMaybe "3,14" :: Maybe Double
02:32:27 <lambdabot>  Nothing
02:32:35 <quicksilver> shag: that would be one way to do it.
02:55:50 <smg> @pl let add a b = a + b
02:55:50 <lambdabot> (line 1, column 20):
02:55:50 <lambdabot> unexpected end of input
02:55:50 <lambdabot> expecting letter or digit, variable, "(", operator, "+", "-", ";" or "in"
02:56:04 <smg> @pl add a b = a + b
02:56:05 <lambdabot> add = (+)
02:56:09 <smg> ha okay
02:56:12 <jacobian> is there an empty type in haskell?
02:56:29 <Lemmih> jacobian: ()?
02:56:32 <smg> jacobian: maybe you like () or []
02:56:48 <opqdonut> () is the emptiest
02:56:51 <jacobian> those have an inhabitant
02:56:53 <jacobian> ok
02:57:01 <opqdonut> ?src ()
02:57:02 <lambdabot> data () = ()
02:57:07 <smg> @src []
02:57:07 <lambdabot> data [] a = [] | a : [a]
02:57:12 <smg> hehe
02:57:35 <jacobian> I can't say for instance: data Empty =
02:57:52 <qwrx> :type ()
02:58:06 <smg> :i ()
02:58:10 <smg> "Thread killed"
02:58:12 <qwrx> I don't know the magic
02:58:32 <qwrx> :t ()
02:58:32 <lambdabot> ()
02:58:38 <opqdonut> jacobian: i guess you can say "data Empty"
02:58:43 <opqdonut> that's a ghc extension
02:58:45 <opqdonut> iirc
02:59:01 <jacobian> awesome, thanks
02:59:04 <qwrx> :t []
02:59:04 <lambdabot> forall a. [a]
03:00:27 <qwrx> does lambdabot have a manual?
03:00:48 <Syzygy-> It has public sourcecode. :)
03:01:14 <qwrx> rarely equivalent :)
03:02:01 <lambdabot> I'm too complex to be described in a manual.
03:02:15 <opqdonut> jacobian: have a look at http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#nullary-types
03:02:16 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
03:02:18 <opqdonut> lambdabot: :D
03:02:54 <Corun> There's "/msg lambdabot ?"
03:03:03 <Corun> Which is practically the same :-P
03:04:12 * Corun spots a command
03:04:15 <Corun> @girl19
03:04:15 <lambdabot> I have stolen about 50 msn and yahoo accounts
03:04:45 <smg> lol
03:05:34 <Corun> @b52s
03:05:37 <lambdabot> Hot pants explosion at the factory!
03:05:58 <Gilly> i see that ghc has many extensions... are they proposed for future haskell specifications, too?
03:06:05 <opqdonut> ?yow
03:06:05 <lambdabot> I request a weekend in Havana with Phil Silvers!
03:06:08 <qwrx> oh dear
03:06:11 <qwrx> what have I wrought
03:06:31 <quicksilver> Gilly: a few of them are, yes.
03:06:44 <Corun> @brain
03:06:44 <lambdabot> I think so, Brain, but if they called them 'Sad Meals', kids wouldn't buy them!
03:06:45 <quicksilver> Gilly: there is some information on the haskell prime trac about that
03:07:21 <Gilly> what i'm after is are they safe to use if i want the code to be portable?
03:12:22 <smg> lambdabot: i love you
03:17:52 <MyCatVerbs> @src mapM
03:17:52 <lambdabot> mapM f as = sequence (map f as)
03:18:00 <MyCatVerbs> @src sequence
03:18:00 <lambdabot> sequence ms = foldr k (return []) ms
03:18:00 <lambdabot>     where
03:18:00 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
03:18:31 <smg> @src mapM_
03:18:31 <lambdabot> mapM_ f as = sequence_ (map f as)
03:18:39 <smg> @src sequence_
03:18:39 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
03:19:41 <faxathisia> @src ghc
03:19:41 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:20:17 <wagle_home> @src nile
03:20:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:20:28 <smg> @pl pythagoras x y = sqrt (x^2 + y^2)
03:20:28 <lambdabot> pythagoras = (sqrt .) . (. (^ 2)) . (+) . (^ 2)
03:20:52 <faxathisia> sqrt . ((+) `on` (join (*)))
03:21:07 <faxathisia> sqrt .: ((+) `on` (join (*)))
03:21:18 <wagle_home> @src `on`
03:21:18 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:21:26 <qwrx> @src on
03:21:26 <lambdabot> (*) `on` f = \x y -> f x * f y
03:21:57 <smg> faxathisia: cool
03:22:39 <faxathisia> This is odd...
03:22:40 <faxathisia> :t :t (+) `on` (join (*))
03:22:40 <lambdabot> parse error on input `:'
03:22:42 <faxathisia> :t (+) `on` (join (*))
03:22:42 <lambdabot> Not in scope: `on'
03:22:50 <faxathisia> @let (*) `on` f = \x y -> f x * f y
03:22:51 <lambdabot> Defined.
03:22:52 <faxathisia> :t (+) `on` (join (*))
03:22:52 <lambdabot> Not in scope: `on'
03:24:10 <hpaste>  faxathisia pasted "oddness" at http://hpaste.org/5939
03:24:15 <faxathisia> yeah look at the type..
03:24:28 <faxathisia> just when you pass arguments it wants more :p
03:26:41 <faxathisia> :t join (*)
03:26:42 <lambdabot> forall a. (Num a) => a -> a
03:27:50 <faxathisia> @let pythagoras = (((.).(.)) sqrt ((+) `on` (join (*))))
03:27:51 <lambdabot> Defined.
03:28:00 <faxathisia> > pythagoras 3 4
03:28:01 <lambdabot>  5.0
03:29:32 <MyCatVerbs> faxathisia: what on Earth possessed you to write that? Please tell me that @pl output rather than hacked-by-hand. x_x
03:30:05 <faxathisia> MyCatVerbs: It just occured to me when I saw the lame @pl one :P
03:30:21 <earthy> pythagoras had tits on his mind?!
03:30:30 <faxathisia> I wish that it could be written ... sqrt `((.).(.))` ((+) `on` (join (*))) -- though
03:31:37 <earthy> faxathisia: that would *greatly* complicate good error reporting
03:32:08 <earthy> (what kind of expressions would you allow between backticks...)
03:32:26 <faxathisia> all of them!
03:32:36 <earthy> ah. yes. right. :)
03:32:45 <faxathisia> Int `Either` Bool
03:32:53 <MyCatVerbs> earthy: all of them! Forget undecidability in the type system, actually what we really want is for the parser to be Turing complete!
03:33:02 * earthy laughs
03:33:54 <faxathisia> well honestly I would like mixfix in haskell and be able to choose more what unicode did
03:33:54 <earthy> I'm perfectly happy with the way it is.
03:34:03 <Philippa> earthy: I figure anything so long as it's got parens around it is a fair answer if you really really have to
03:34:31 <earthy> even then, the capacity for obfuscation is waaaaay bigger than the capapcity for clarity
03:34:34 * Philippa is tempted to bung backticks into her rather simple parser in lieu of actual operator support for now
03:34:48 <Philippa> rarely without knowing you're doing it, though
03:34:54 <earthy> btw, philippa, you might get a kick out of this: Doaitse wrote some type classes so he could write his parsers as follows:
03:35:14 <Philippa> I've had cases where at least a simple application on the inside would've made things much nicer
03:35:24 <earthy> parseIfClause = start "if" parseCondition "then" parseExpression "else" parseExpression stop
03:36:10 <Philippa> heh. I've considered overloading strings for similar purposes, the rest smells like alpha-converted applicative sugar?
03:36:29 * earthy nods
03:36:43 <earthy> but this isn't really overloaded strings
03:36:51 <Philippa> sorry, string literals
03:36:57 <earthy> nope.
03:37:01 <quicksilver> with delimiters and type classes
03:37:06 <Philippa> no? What's he done?
03:37:07 <quicksilver> you never need tricks like literatl overloading
03:37:14 <quicksilver> it's like the idiom bracket trick
03:37:18 <quicksilver> iI .... Ii
03:37:26 <earthy> quicksilver: it is exactly the idiom bracket trick
03:37:36 <earthy> but 'interpreting' strings as lifted parsers. :)
03:37:43 <quicksilver> you can use a typeclass to build a varargs function which search for the 'closing token'
03:37:48 <earthy> s/lifted parsers/lifts to symbol parsers/
03:37:56 <quicksilver> and has any interpretation of intervening stuff you want it to
03:38:23 <Philippa> yeah. I guess it's slightly neater than the string lit overloading in that it's delimited
03:38:35 * earthy nods
03:39:00 <earthy> really reads nicely as well. :)
03:39:16 <quicksilver> lousy type errors when you make a "syntax" error though
03:39:19 <quicksilver> as with all such tricks.
03:39:24 <Philippa> heh, I guess now I should propose a "keyword declaration" that lets you turn keyword {a;b;c;} into delimiter1 a b c delimiter2
03:39:42 <earthy> then again, advanced parser combinators tend to result in shitty type errors anyway
03:39:44 <Philippa> we'll have lisp's worst features and then some yet ;-)
03:39:54 <quicksilver> true
03:40:01 <quicksilver> (to both of you :)
03:40:26 <quicksilver> I was very skeptical of agda's mixfix stuff but having seen a few examples around the net it is cleaner than I expected.
03:40:40 * Philippa has had something more principled in mind based around Category and subclasses
03:40:41 <earthy> hm. maybe I should read up on that then
03:40:51 <faxathisia> If you figure out how to add sections and mixfix...
03:40:54 <faxathisia> That would be nice :)
03:40:58 <Philippa> but it doesn't get really fun without a few features haskell doesn't handle cleanly yet
03:42:06 <Philippa> (for a taste of what I've been smoking: what if the environment built up by arrow sugar was in an extensible record instead of a hellish nesting of tuples?)
03:43:32 <earthy> you'd have much easier and cleaner access
03:43:34 <earthy> and neater types
03:43:58 <earthy> pity we don't have extensible records though. :P
03:44:03 <Philippa> for an encore: what if the extensible record type'd been built so that the arrow-like type could do polytypic programming with it
03:44:15 <Philippa> well, we don't have syntactically-nice ones
03:44:30 <Philippa> bonus points: why stop at records when you can do it with records for pattern-matching too?
03:44:52 <earthy> hm.... this just blew my stack
03:45:24 <earthy> on pondering the arrow-like type
03:45:44 <earthy> you're coming dangerously close to full dependent types there, right? :)
03:59:07 <faxathisia> I wonder what all the different types of dependently typed languages we will have in a year or so
03:59:46 <bgeron> Would it be much more?
04:00:18 <faxathisia> I think so.. there is always new research spawning new things and it's an active field ?
04:00:47 <quicksilver> a year is not very long though
04:00:54 <quicksilver> these things don't normally move this fast
04:01:09 <faxathisia> ok well how can I speed it up :P
04:01:22 * faxathisia has some spare time today..
04:02:49 <resiak> @hoogle while
04:02:49 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
04:02:49 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
04:02:49 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
04:03:16 <dmwit> ?hoogle until
04:03:17 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
04:04:46 <hpaste>  resiak pasted "whileM ~ truncated 'sequence'; is there a better way to do this?" at http://hpaste.org/5940
04:06:29 <quicksilver> resiak: no, not really.
04:06:42 <resiak> hrm, reversing the arguments makes it more natural, and obviously either it should be untilM or the predicate should be negate :)
04:06:42 <quicksilver> resiak: it comes up from time to time.
04:06:51 <dmwit> ress <- sequence [whileM ms p | p res] -- sneaky!
04:06:52 <quicksilver> resiak: the problem is, as always, tehre is more than one way to do it.
04:07:07 <quicksilver> resiak: p could have type (a -> m Bool)
04:07:08 <resiak> there are quite a few conceivable definitions you might want
04:07:13 <quicksilver> resiak: or simply type "m Bool"
04:07:15 <resiak> you might want to discard the one where p succeeds
04:07:20 <quicksilver> so it's hard to write a "universal" whileM
04:07:49 <quicksilver> I actually woudln't call what you have written whileM.
04:07:57 <quicksilver> I think I'd call it "takeWhileM"
04:08:07 <quicksilver> (and reverse the predicate, so it terminates on false)
04:08:10 <resiak> yes
04:08:17 <hpaste>  dmwit annotated "whileM ~ truncated 'sequence'; is there a better way to do this?" with "does this work?" at http://hpaste.org/5940#a1
04:08:18 <resiak> except I want to keep the first value where the predicate succeeds
04:08:19 <quicksilver> I'd expect whileM to have this type:
04:08:30 <quicksilver> whileM :: m a -> m Bool -> m a
04:08:42 <quicksilver> I.e. execute the same action over and over again
04:08:44 <MyCatVerbs> @pl \h t -> h >>= \head -> t >>= \tail -> return (c:cs)
04:08:44 <lambdabot> (. (const . (>> return (c : cs)))) . (>>=)
04:08:45 <quicksilver> (not a list of actions)
04:08:46 <resiak> makes sense
04:08:54 <quicksilver> flip the arguments, to be honest.
04:09:20 <resiak> yeah, i realised when I :r'ed the code that uses it that the arguments should be reversed, because i tried to use it backwards :)
04:09:20 <dmwit> quicksilver: Not ... -> m [a]?
04:09:30 <quicksilver> dmwit: good question.
04:09:41 <quicksilver> dmwit: I guess I was thinking of m (), to be honest.
04:09:47 <dmwit> yeah
04:09:48 <quicksilver> I think m [a] is also good.
04:09:51 <quicksilver> m a is wrong :)
04:09:59 <quicksilver> there is no value to return if the body never runs.
04:10:05 <idnar> I would have expected (a -> m Bool)
04:10:30 <dmwit> idnar: That's do-while.
04:10:43 <idnar> well, I mean
04:10:52 <idnar> oh.
04:10:58 <idnar> yeah, I see your point
04:11:02 <quicksilver> yes, a -> m Bool definitely has its points too
04:11:05 <quicksilver> this is what I mean :)
04:11:15 <quicksilver> there doesn't seem to be an obvious choice of a perfect combinator.
04:11:15 <idnar> maybe m a -> a -> (a -> m Bool) -> m [a]
04:11:22 * MyCatVerbs would've expected something like: (a -> m (a,Bool)) -> m a -> m [a] -- the last bit could be made either m a, m [a] depending on whether or not you're interested in the intermediate bits.
04:11:32 <idnar> I'm not sure calling it whileM would be a good idea, though
04:11:59 <MyCatVerbs> Er, more like: (a -> m (a,Bool)) -> a -> m [a]
04:12:00 <resiak> perhaps i'm approaching this the wrong way
04:12:44 <resiak> when you run a query against the tracker daemon, you have to specify a slice of the results that you want (that is, an offset from the start, and a maximum number of results)
04:12:52 <MyCatVerbs> @pl \x -> forM [1..x]
04:12:52 <lambdabot> forM . enumFromTo 1
04:13:00 <resiak> so i'm using this to keep fetching 512 more results until there are no more
04:13:20 <resiak> (annoyingly there doesn't seem to be a 'so how many results are there?' function for this type of query)
04:13:23 <MyCatVerbs> @pl \x -> forM [0..(x-1)]
04:13:23 <lambdabot> forM . enumFromTo 0 . subtract 1
04:14:01 <dmwit> :t foldM
04:14:01 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
04:14:03 <resiak> i can't think of a better way to do that than to use this 'takeUntilM' on an infinite list of queries for successive slices
04:14:17 <dmwit> MyCatVerbs: Kind of like an "unfoldM" or so, eh?
04:14:58 <MyCatVerbs> dmwit: just thinking of the "for j <- 1 to n" loops you always see on lecturer's whiteboards when they write pseudocode. :)
04:15:22 <dmwit> =)
04:16:02 <MyCatVerbs> (Admittedly those're almost always better replaced with a mapFoo so that you don't have to worry about off-by-one errors.)
04:25:07 <zooko> dino-: yes, and in fact I am even *succeeding* at building darcs from source!
04:25:48 <zooko> lispy: good question.  I think darcs configure has the same problem on all platforms, but only on windows does it happen that the local gcc behaves sufficiently different from ghc's pet gcc that it can lead to failure.
04:26:15 <zooko> Or..  does ghc even *use* a bundled pet gcc on other platforms than Windows?
04:28:55 <hpaste>  ketil pasted "Simple GetArgs" at http://hpaste.org/5941
04:29:09 <ketil> Ahem.
04:29:39 <ketil> The GetOpts framework is nice and all, but sometimes I just want to do (x,y,z) <- getArgs and get on with it.
04:30:06 <zooko> The answer is the Windows is the only platform where ghc brings along its own copy of gcc, so it is the only platform where darcs's configure script using "does gcc work?" as a proxy for "will ghc work?" fails.
04:30:30 <ketil> The pasted module does this, giving a more reasonable error message than the normal way of doing it.  Currently x,y,z must be Strings, what is the best way to extend this to arbitrary types?
04:32:50 <ketil> I thought about defining a 'read'-type function that can read a non-quoted string and char, but my first attempt ended up in a maze of twisty little instances, all overlapping :-)
04:35:15 <ketil> Perhaps I can define a 'myread' that just attempts to read directly, and on failure, tries to read with single quotes, and if that fails, tries with double quotes?  And for that matter, also tries enclosing with [] and () for lists and tuples?
04:35:21 <ketil> Not particularly elegant, though.
04:35:40 <dmwit> gotta know the return type ahead of time
04:36:00 <dmwit> You'll end up with Either (or some other sum type), which doesn't seem to be what you want here.
04:36:10 <dmwit> ?src Cont (>>=)
04:36:11 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
04:36:21 <dmwit> yikes
04:36:28 <dmwit> m >>= f = m . flip f?
04:37:13 <dmwit> ?djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
04:37:13 <lambdabot> f a b c = a (\ d -> b d c)
04:38:33 <dmwit> Yeah, good.
04:38:34 <quicksilver> ketil: erm. Why bother.
04:38:43 <ketil> dmwit, errr...I hope you just changed the subject?
04:38:47 <quicksilver> ketil: why would not just say [x,y,z] <- getArgs
04:38:52 <dmwit> ketil: yes =P
04:38:52 <quicksilver> ketil: and then get on with it :)
04:39:34 <ketil> quicksilver, well - I'm lazy, tend to do it a lot in small projects, and if it could be encapsulated in a library, I'm all for it.
04:39:41 <dmwit> Okay, figured out the implementation from the type, now I just have to figure out the meaning from the implementation. =P
04:40:02 <quicksilver> ketil: I guess the reason you don't want to do [x,y,z] <- getArgs is about better error messages?
04:42:04 <hpaste>  ketil pasted "polymorphic read for arguments" at http://hpaste.org/5942
04:42:57 <ketil> quicksilver, yes.  And also to not worry about applying the right amount of 'read's, if it can be helped.
04:44:52 <quicksilver> ketil: why are you aloowing for quotes?
04:45:02 <quicksilver> ketil: surely no one passes quotes as a command line parameter?
04:45:21 * quicksilver thinks he may have missed ketil's point, somewhere.
04:51:20 <ketil> quicksilver, I'm just wrapping the parameter in quotes to allow reads to parse it as a string(char/list)
04:51:28 <quicksilver> Oh.
04:51:34 <quicksilver> duh.
04:51:36 <ketil> quicksilver, I did say it wasn't elegant :-)
04:51:37 <quicksilver> right :)
04:52:21 <quicksilver> yeah, I see what you're doing.
04:52:28 <quicksilver> I don't immediately see a cleverer way.
04:52:47 <ketil> GetArgs.hs:21:0:
04:52:47 <ketil>     Inferred type is less polymorphic than expected
04:52:47 <ketil>       Quantified type variable `a' is mentioned in the environment:
04:53:18 <ketil> (when declaring an instance Read a => Args a where (I'm using myread to convert the args to 'a's)
04:53:51 <quicksilver> that's going to conflict with your instance fo () though
04:53:55 <ketil> quicksilver, I think the alternative to trying and failing is a lot of overlapping instances.
04:54:02 <ketil> Ai. True.
04:55:20 <ketil> But that doesn't seem to be the problem.
04:56:06 <quicksilver> I expect you're using "a" instide the instance.
04:56:31 <quicksilver> which isn't legal, type vars aren't scoped in haskell
04:56:32 <quicksilver> but I'm not sure
04:56:37 <quicksilver> you might have two different as
04:56:49 <quicksilver> if you were to show me the code I might be able to tell :P
04:56:51 <ketil> Perhaps the problem is that 'a' is a bit too general...
04:56:56 <DRMacIver> I've always thought that was a really strange decision
04:57:24 * DRMacIver tends to use GHC's scoped variables extension whenever it would affect him
04:57:42 <quicksilver> yes, I have sometimes wondered if there is a good reason
04:59:27 <hpaste>  ketil pasted "non-working code" at http://hpaste.org/5943
05:01:49 <MyCatVerbs> Hrmn. Anyone familiar with Parsec care to answer a stupid question, please?
05:01:56 <ohub> shoot
05:01:58 <ketil> Oh crap, my shorthand for myread changes the types (monomorphism, I bet)
05:02:05 <quicksilver> ah yes
05:02:08 <quicksilver> that'll be it
05:02:13 <MyCatVerbs> I need to have an explicit failure case in this parser, but the error messages are terrible.
05:02:49 <Saizan> annotate them with <?> ?
05:03:16 <MyCatVerbs> As in, I want to write something like: many1 letter >>= \word -> if (notMember word keywordset) then return word else fail "you bastard, that's a keyword, not an identifier!"
05:04:42 <MyCatVerbs> That gets me the right behavoir, but I end up with error messages like: "parse error at (line 1, column 6): \n unexpected $NEXT_TOKEN \n expecting letter or digit \n $MY_FAILURE_MESSAGE "
05:05:11 <ketil> removing the 'r = myread' shorthand, I still need to remove monomonstermorphism thing, but then it - guess what - appears to work.
05:05:16 <ketil> Whee!
05:06:09 <ketil> Finally, the most important problem facing our civilization has been overcome.
05:06:12 * ketil rejoices.
05:06:54 <MyCatVerbs> Whereas it'd probably be better to have messages like the above, but with "expecting identifier, got keyword"
05:06:57 <faxathisia> ketil: Did someone finally prove that lambda is better than turing macines?
05:08:09 <MyCatVerbs> faxathisia: yeah, but someone else proved that you can simulate lambda quite nicely using Cheney on the MTA. So no one cares now.
05:16:00 <ketil> faxathisia, much better than that.  I, with only a wee bit of help from quicksilver, have single-handedly improved getArgs, in a marginal and highly unrequested way.  If you hurry, there might be some champagne left, too.
05:16:18 <faxathisia> hehehe
05:17:45 <ketil> Anyway - the result can be admired in extenso at http://malde.org/~ketil/simpleargs/.
05:17:46 <lambdabot> Title: Index of /~ketil/simpleargs
05:17:54 <ketil> @botsnack
05:17:54 <lambdabot> :)
05:21:24 <nominolo> > getZipList $ ($) <$> ZipList [id,id,('a':)] <*> ZipList ["a","","cde"]
05:21:25 <lambdabot>  ["a","","acde"]
05:21:31 <nominolo> > getZipList $ ($) <$> ZipList [id,id,('a':)] <*> ZipList ["a",""]
05:21:32 <lambdabot>  ["a",""]
05:21:58 <MyCatVerbs> > parseTest (fail "" <?> "vodka and logic, comrade!") undefined
05:21:58 <lambdabot>   Not in scope: `<?>'
05:22:08 <MyCatVerbs> No parsec in \bot? Oh well.
05:22:09 <faxathisia> > [id,id,('a':)] <*> ["a",""]
05:22:10 <lambdabot>  ["a","","a","","aa","a"]
05:22:18 <faxathisia> > [id,id,('a':)] <$> ["a",""]
05:22:18 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
05:22:37 <nominolo> > getZipList $ ($) <$> ZipList (id:id:('a':):repeat id) <*> ZipList ["a","","abc"]
05:22:38 <lambdabot>  ["a","","aabc"]
05:23:30 <Saizan> ($) <$> is redundant, no?
05:23:54 <nominolo> er, yeah
05:24:03 <nominolo> > getZipList $ ZipList (id:id:('a':):repeat id) <*> ZipList ["a","","abc"]
05:24:03 <lambdabot>  ["a","","aabc"]
05:24:22 <faxathisia> > zipWith ($) (id:id:('a':):repeat id) ["a","","abc"]
05:24:22 <lambdabot>  ["a","","aabc"]
05:24:24 <nominolo> still, it doesn't do what i want
05:25:06 <nominolo> i want the 'a' to be inserted and the input be extended until i can insert the 'a'
05:25:50 <nominolo> @hoogle Int -> a -> [a] -> [a]
05:25:51 <lambdabot> No matches, try a more general search
05:26:09 <Saizan> > getZipList $ ZipList (id:id:('a':)) <*> ZipList (["a","","abc"]++ repeat "") -- ?
05:26:09 <lambdabot>  Couldn't match expected type `[a -> a]'
05:26:35 <Saizan> > getZipList $ ZipList (id:id:('a':):[]) <*> ZipList (["a","","abc"]++ repeat "") -- ?
05:26:35 <lambdabot>  ["a","","aabc"]
05:26:51 <Saizan> removing "abc"
05:27:09 <nominolo> > zipWith ($) (id:id:('a':):[]) (["a","","abc"]++repeat "")
05:27:09 <lambdabot>  ["a","","aabc"]
05:27:17 <nominolo> > zipWith ($) (id:id:('a':):[]) (["a"]++repeat "")
05:27:18 <lambdabot>  ["a","","a"]
05:27:34 <nominolo> > zipWith ($) (id:id:('a':):[]) (["a","b","c","d"]++repeat "")
05:27:34 <lambdabot>  ["a","b","ac"]
05:27:54 <faxathisia> what are you trying to do?
05:28:25 <nominolo> implement insertAt :)
05:28:37 <nominolo> well, really a queue
05:28:49 <nominolo> but i don't always want to insert at the front
05:28:56 <faxathisia> insertAt 1 "?" "<>" = "<?>"
05:29:03 <nominolo> no
05:29:45 <nominolo> insertAt 1 'a' ["a", "b", "c"] = ["a","ab","c"]
05:29:54 <nominolo> insertAt 1 'a' ["a"] = ["a","a"]
05:30:43 <faxathisia> would not be easier overall having insertAt 1 'a' ["a", "", "", ...] = ["a","a", "", ...] ?
05:31:04 <nominolo> of course, not specialized to strings
05:31:19 <nominolo> hm, an infinite list could work
05:31:26 <int-e> faxathisia: modifyAt 1 ('a':) ["a", "", "", ...]
05:31:36 <faxathisia> :t modifyAt
05:31:37 <lambdabot> Not in scope: `modifyAt'
05:32:49 <int-e> faxathisia: it doesn't exist either, but it's a more general interface - modifyAt :: Int -> (a -> a) -> [a] -> [a]
05:33:32 <nominolo> @pl \n f xs -> zipWith (replicate n id ++ f ++ repeat id) (xs ++ repeat [])
05:33:32 <lambdabot> flip flip (++ repeat []) . (((.) . zipWith) .) . (. (++ repeat id)) . (++) . flip replicate id
05:33:33 <pjd> ('a':) is not a -> a
05:34:02 <pjd> oh, nevermind
05:34:02 <int-e> (and besides, insertAt suggests a whole other meaning to me. I'd expect insertAt :: Int -> a -> [a] -> [a], insertAt n x xs = take n xs ++ x : drop n xs)
05:34:07 <int-e> @type ('a':)
05:34:08 <lambdabot> [Char] -> [Char]
05:34:55 <faxathisia> > [ f | (e,i) <- zip ["a", "b", "c"] [1..] ; f = if i == 1 then 'a':e else e ]
05:34:55 <lambdabot>  Parse error at ";" (column 42)
05:35:00 <faxathisia> > [ f | (e,i) <- zip ["a", "b", "c"] [1..] , f = if i == 1 then 'a':e else e ]
05:35:00 <lambdabot>  Parse error at "=" (column 46)
05:35:06 <faxathisia> > [ f | (e,i) <- zip ["a", "b", "c"] [1..] , let f = if i == 1 then 'a':e else e ]
05:35:06 <lambdabot>  ["aa","b","c"]
05:35:14 <faxathisia> > [ f | (e,i) <- zip ["a", "b", "c"] [0..] , let f = if i == 1 then 'a':e else e ]
05:35:14 <lambdabot>  ["a","ab","c"]
05:35:36 <faxathisia> > [ f | let f = if i == 1 then 'a':e else e , (e,i) <- zip ["a", "b", "c"] [0..] ] -- does order matter here=?
05:35:36 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Expr'
05:35:46 <Saizan> > [ f | (e,i) <- zip ["a", "b", "c"] [0..] , let f = if i == 3 then 'a':e else e ]
05:35:46 <lambdabot>  ["a","b","c"]
05:36:24 <nominolo> ok, i think i'll just use an infinite list and use modifyAt
05:36:35 <faxathisia> modifyAt not existing ..
05:36:42 <nominolo> then i implement it
05:36:45 <Saizan> splitAt?
05:37:25 <nominolo> > (\n f xs -> zipWith (replicate n id ++ f ++ repeat id) (xs ++ repeat [])) 3 ('a':) ["a","b","c"]
05:37:26 <lambdabot>  Couldn't match expected type `a -> b -> c'
05:37:27 <faxathisia> modifyAt i f l = [ e' | (e,i) <- zip l [0..] , let e' = if i == 1 then f e else e ] -- ?
05:37:42 <nominolo> > (\n f xs -> zipWith (replicate n id ++ [f] ++ repeat id) (xs ++ repeat [])) 3 ('a':) ["a","b","c"]
05:37:42 <lambdabot>  Couldn't match expected type `a -> b -> c'
05:37:44 <faxathisia> insertAt i c l = modifyAt i (c:) l
05:37:56 <nominolo> > (\n f xs -> zipWith ($) (replicate n id ++ [f] ++ repeat id) (xs ++ repeat [])) 3 ('a':) ["a","b","c"]
05:37:57 <lambdabot>  ["a","b","c","a","","","","","","","","","","","","","","","","","","","",""...
05:38:30 <Toxaris> nominolo: replicate (pred n) id ?
05:38:40 <nominolo> @src pred
05:38:40 <lambdabot> Source not found. Take a stress pill and think things over.
05:38:44 <faxathisia> modifyAt i f l = [ e' | (e,i') <- zip l [0..] , let e' = if i' == i then f e else e ] -- oops
05:38:50 <faxathisia> :t preds
05:38:50 <lambdabot> Not in scope: `preds'
05:39:04 <int-e> @index mapHead
05:39:04 <lambdabot> bzzt
05:39:11 <nominolo> pred x = x - 1 ?
05:39:23 * Saizan hopes the repeat id gets optimized away
05:39:31 <Toxaris> nominolo: yes. but I may be wrong in believing that you want that.
05:39:39 <tensh> is there a built in split function on strings?
05:39:53 <nominolo> splitAt 4 "enutoaenuheoa"
05:39:55 <Toxaris> :t pred
05:39:55 <lambdabot> forall a. (Enum a) => a -> a
05:39:58 <nominolo> > splitAt 4 "enutoaenuheoa"
05:39:58 <lambdabot>  ("enut","oaenuheoa")
05:40:07 <faxathisia> @src splitAt
05:40:08 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
05:40:11 <int-e> modifyAt n f xs = let (as, bs) = splitAt n xs in as ++ mapHead f bs; mapHead _ [] = []; mapHead f (x : xs) = f x : xs
05:40:18 <tensh> I was more looking for a function that splits on a certain char
05:40:18 <faxathisia> I had no idea that existed..
05:40:33 <nominolo> > split (=='a') "enutoaenuheoa"
05:40:33 <lambdabot>  Couldn't match expected type `[Char] -> t'
05:40:34 <int-e> tensh: takeWhile (/= 'x')
05:40:35 <faxathisia> :t elemIndex
05:40:36 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
05:40:41 <int-e> hmm. span?
05:40:44 <int-e> @type span
05:40:44 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:40:44 <tensh> ahh, smart
05:40:47 <faxathisia> :t break
05:40:47 <tensh> thanks
05:40:48 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
05:40:49 <nominolo> > break (=='a') "enutoaenuheoa"
05:40:49 <lambdabot>  ("enuto","aenuheoa")
05:41:02 <int-e> > span (/= 'x') "abxcdexfghxij"
05:41:03 <lambdabot>  ("ab","xcdexfghxij")
05:41:31 <nominolo> of course it does it only once
05:42:00 <nominolo> > replicate (-1) 42
05:42:01 <lambdabot>  []
05:42:16 <tensh> hmm
05:42:25 <tensh> I don't want the split char though
05:42:37 <tensh> and it seems kinda ugly to remove it on every result except the first one
05:43:16 <Toxaris> > second tail . break (=='a') $ "enutoaenuheoa"
05:43:17 <lambdabot>  ("enuto","enuheoa")
05:43:50 <scook0> wouldn't drop 1 be better than tail here?
05:44:00 <scook0> i.e. if the char isn't found
05:44:08 <tensh> still won't work if I want to split on every occurence of the char
05:44:11 <EvilTerran> > groupBy (=='a') "abracadabra"
05:44:12 <lambdabot>  Couldn't match expected type `Char -> Bool'
05:44:22 <EvilTerran> > groupBy ((==)`on`(=='a')) "abracadabra"
05:44:22 <lambdabot>  ["a","br","a","c","a","d","a","br","a"]
05:44:30 <scook0> you could just write your own split
05:44:34 <Toxaris> > groupBy (const (/= 'x')) "firstxsecondxxthird"
05:44:34 <lambdabot>  ["first","xsecond","x","xthird"]
05:44:54 <quicksilver> tensh: yes, this comes up at least once a week.
05:44:59 <tensh> oh, sorry ;)
05:45:04 <EvilTerran> ?src words
05:45:04 <lambdabot> words s = case dropWhile isSpace s of
05:45:04 <lambdabot>     "" -> []
05:45:04 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
05:45:06 <quicksilver> My answer is always that it's not obvious which is the correct general answer.
05:45:10 <quicksilver> (don't be sorry, it's fine)
05:45:11 <Toxaris> > let mySplit = map tail . groupBy (const (/= 'x')) . ('x' :) in mySplit "firstxsecondxxthird"
05:45:12 <lambdabot>  ["first","second","","third"]
05:45:24 <quicksilver> there are lots of variables like : what do you do with multiple delimiters?
05:45:38 <quicksilver> shall we specify delimeter as a Char, Char -> Bool, [Char] -> Bool ?
05:45:40 <scook0> maybe someone needs to write a whole family of split functions, and make a library of them :)
05:45:51 <quicksilver> do you want the delimeter itself returned somehow?
05:45:52 <quicksilver> etc.
05:46:04 <EvilTerran> splitBy p s = case dropWhile p s of [] -> []; s' -> w : splitBy p s'' where (w, s'') = break isSpace s'
05:46:12 <int-e> > let split p = unfoldr (liftM2 (>>) (guard . not . null) (return . break p . tail)) . (undefined :) in split (== ' ') "abc  def ghi "
05:46:13 <lambdabot>  ["abc","","def","ghi",""]
05:47:12 <EvilTerran> scook0, it's called Parsec :P
05:47:14 <doserj> ... how to handle delimiters at the beginning and at the end ...
05:47:15 <int-e> EvilTerran: isSpace?
05:47:24 <EvilTerran> er, "break p".
05:47:36 <EvilTerran> that's what i get for ^C^Ving too vigorously
05:48:27 <cperfumo> hi, all!
05:48:35 <cperfumo> I just downloaded nofib
05:49:01 <cperfumo> and I'm experiencing some problems with compilation
05:49:25 <cperfumo> cperfumo@cperfumo-laptop:~/Haskell/Applications/nofib/nofib$ make
05:49:25 <cperfumo> mk/boilerplate.mk:17: ../mk/boilerplate.mk: No such file or directory
05:49:25 <cperfumo> mk/target.mk:120: ../mk/target.mk: No such file or directory
05:49:25 <cperfumo> make: *** No rule to make target `../mk/target.mk'.  Stop.
05:49:25 <cperfumo> cperfumo@cperfumo-laptop:~/Haskell/Applications/nofib/nofib$
05:49:37 <mightybyte> quicksilver: I understand that there are many variables with regards to split, but is that really an adequate justification for Haskell's lack of a split function?
05:49:41 <cperfumo> any idea?
05:50:05 <mightybyte> quicksilver: Why not just use one of the conventions adopted by some other approach?
05:50:19 <quicksilver> mightybyte: I don't know if it's a justification.
05:50:26 <quicksilver> mightybyte: I think it's a reason, though :)
05:50:28 <mightybyte> quicksilver: Ok. :)
05:50:48 * EvilTerran thinks that the generalisation of words would be one of the more useful versions
05:50:49 <quicksilver> Feel free to write up your favourite and propose it from integration into Data.List.
05:50:56 <EvilTerran> or maybe the generalisation of lines
05:50:58 <EvilTerran> ?src lines
05:50:58 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:51:11 <quicksilver> You could use a popular python or perl equivalent as inspiration.
05:51:17 <EvilTerran> (which keeps ""s between consecutive linebreaks, iirc)
05:51:27 <mightybyte> quicksilver: My perception (as someone who asked the same question no long ago) is that haskell has so many really useful abstractions, that the omission of this one seems like an oversight.
05:51:31 <quicksilver> perl split has something like type split :: ([a] -> Bool) -> [a] -> [[a]]
05:51:48 <quicksilver> if you assume a regex is a notation for [a] -> Bool
05:52:10 <mightybyte> quicksilver: Would it go in Data.List or would it be better even in the prelude?  (I know that's hard)
05:52:16 <quicksilver> Data.List
05:52:24 <quicksilver> Even a Simon cannot alter the Prelude.
05:52:35 <mightybyte> Heh
05:52:36 <quicksilver> It is carved in stone.
05:52:43 <mightybyte> Really?
05:52:51 <quicksilver> well, it's part of haskell98
05:52:56 <quicksilver> it can be bugfixed, if there is a real bug.
05:53:01 <mightybyte> Yeah, but that's now almost 10 years old.
05:53:11 <int-e> cperfumo: I believe that nofib uses the fptools infrastructure for configure etc.
05:53:12 <quicksilver> true.
05:53:21 <quicksilver> It would be nice if there was a new haskell standard.
05:53:28 * doserj sighs
05:53:28 <quicksilver> But I believe that needs some fire lighting to get moving.
05:53:47 <EvilTerran> it'd be nice if we could have h98 and h08
05:53:54 <EvilTerran> update things every decade, kinda thing
05:53:59 <EvilTerran> like with C89 and C99
05:54:19 <mightybyte> Yeah, the plethora of OPTIONS and LANGUAGE use in ghc seems like reason enough to work on a new standard.
05:54:22 <EvilTerran> but the standardisation process aint likely to finish this year
05:55:35 <int-e> cperfumo: (http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ ... that directory contains a configure script, a mk subdirectory, and a few other things. but I've never tried to build nofib myself, so this is just an educated guess.)
05:55:35 <lambdabot> Title: fptools/
05:55:52 <quicksilver> mightybyte: Oh. There is a open libraries request for split.
05:55:54 <mightybyte> It seems like Haskell has gotten a lot more recognition in recent years, and it would be beneficial to have an updated standard to keep up with the interest.
05:56:26 <mightybyte> quicksilver: Ok
05:56:34 <cperfumo> sorry, I figured out the solution... nofib MUST be in a ghc source directory, at the same level as compiler and rts
05:56:44 <quicksilver> mightybyte: http://www.nabble.com/Proposal:-Add-split-and-splitWith-(trac--2048)-td14898094.html
05:56:45 <lambdabot> Title: Nabble - Haskell - Libraries - Proposal: Add split and splitWith (trac #2048), http://tinyurl.com/2yjf7r
05:56:49 <cperfumo> it seems to work now that I moved it
05:57:31 <faxathisia> why not add splits?
05:57:42 <shepheb> mightybyte: plenty of languages have a standard, and a de facto standard provided by the most popular implementation. I don't think // line comments are allowed in the C standard, but gcc still allows them, as an example.
05:58:02 <faxathisia> splits "foo" = [("","foo"),("f","oo"),("fo","o"),("foo","")]
05:58:16 <faxathisia> splits l !! x = splitAt x l
05:59:11 <Cale> shepheb: They're allowed in the newer C standard.
05:59:30 <shepheb> Cale: okay, I thought they might be.
05:59:32 <kpreid> (but GCC allowed them before that standard happened)
05:59:36 <faxathisia> yeah // is C99 that's a standard
05:59:43 <EvilTerran> yeah, c99 has //s, declerations in the middle of blocks, that kinda thing
05:59:47 <int-e> I'd like to see a  splitsR "abc" = [("","abc"), ("a","bc"), ("ba","c"), ("cba","")]  function. It may look less useful, but it will only use O(n) time and memory.
06:00:02 <Cale> Heh, and still no nested comments.
06:00:11 <mightybyte> shepheb: True, it just seems like haskell has progressed far enough that a new one is deserved.
06:00:25 <faxathisia> int-e: 'R'?
06:00:36 <mightybyte> shepheb: Just my perception from the short time I've spent with Haskell so far.
06:00:39 <quicksilver> mightybyte: the problem is this is all in hand.
06:00:43 <int-e> faxathisia: 'reversed' - the name has room for improvement
06:00:46 <Toxaris> > uncurry zip . (inits &&& tails) $ "abc" -- faxathisia
06:00:46 <lambdabot>  [("","abc"),("a","bc"),("ab","c"),("abc","")]
06:00:53 <quicksilver> mightybyte: A new standard was planned a very long time ago.
06:01:05 <quicksilver> mightybyte: a committe was formed, battle plans were drawn
06:01:07 <faxathisia> Toxaris, I mean add to the standard
06:01:13 <quicksilver> mightybyte: important issues were discussed and triaged.
06:01:20 <quicksilver> mightybyte: and then... nothing :)
06:01:24 <faxathisia> It's a neat way to write it though
06:01:28 <pjd> Toxaris: liftA2 zip inits tails
06:01:35 <mightybyte> quicksilver: Yeah, that's really too bad.
06:01:36 <matthew_-> @type take
06:01:36 <quicksilver> mightybyte: the committee failed to complete its work and the standard hasn't happened yet.
06:01:36 <lambdabot> forall a. Int -> [a] -> [a]
06:01:40 <matthew_-> @type drop
06:01:40 <lambdabot> forall a. Int -> [a] -> [a]
06:01:59 <matthew_-> is it just me, or do others think that if you were defining a type class for that, you'd reverse the params?
06:02:07 <int-e> faxathisia: otoh, I'd also want a corresponding 'inits' function, so a short suffix would be nice.
06:02:22 <matthew_-> class TyListTake lst cnt lst' where tyListTake :: cnt -> lst -> lst'
06:02:23 <Toxaris> pjd: cool :)
06:02:44 <pjd> alternately zip <$> inits <*> tails, of course
06:03:13 <mightybyte> quicksilver: The more I use haskell, the more frustrated I get with other languages.  So I'm really interested in seeing the language grow.
06:03:23 <resiak> @src [] (<*>)
06:03:23 <lambdabot> (<|>) = (++)
06:03:28 <resiak> bzzt
06:03:31 <faxathisia> mightybyte: That sucks
06:03:46 <mightybyte> faxathisia: lol
06:05:15 <shepheb> mightybyte: I was writing some Perl yesterday, and kept saying "no wait, I can't do that, it isn't lazy" and "that
06:05:17 <mightybyte> faxathisia: I'm addicted.  Do they have therapy for this kind of thing?
06:05:32 <Toxaris> mightybyte: but new functions should not go into the Prelude, it's already to big. all the good names already taken, all the decisions already made.
06:05:34 <shepheb> ...that's just flip -- no, no it's not."
06:06:37 <resiak> @src (<*>)
06:06:37 <lambdabot> Source not found. Where did you learn to type?
06:06:48 <mightybyte> Toxaris: Ok, then what about things like TH?  If new GHC releases are covering important functionality that used to require TH, it seems like there need to be some updates to the standard.
06:07:23 <scook0> @src Applicative
06:07:23 <lambdabot> class Functor f => Applicative f where
06:07:23 <lambdabot>     pure  :: a -> f a
06:07:23 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
06:07:29 <scook0> @src ap
06:07:29 <lambdabot> ap = liftM2 id
06:07:50 <resiak> yeah, so @src [] (<*>) is just wrong
06:08:41 <Toxaris> @src [] (<*>)
06:08:41 <lambdabot> (<|>) = (++)
06:08:55 <pjd> fs <*> xs = [f x | f <- fs, x <- xs]
06:09:01 <Toxaris> the answer is fine, but it doesn't match the question
06:09:17 <resiak> yep
06:09:18 <resiak> oh, neat
06:10:03 <Toxaris> @src [] (<|>)
06:10:03 <lambdabot> Source not found. There are some things that I just don't know.
06:10:10 <pjd> maybe <|> should have been <+>
06:11:24 <EvilTerran> yeah
06:12:05 <EvilTerran> although, if you wanted that, it'd be better to rename Alternative to Additive or something while you're at it
06:12:09 <Cale> | and + seem to be used interchangeably anyway
06:12:37 <EvilTerran> well, they are in regex theory and suchlike
06:12:58 <quicksilver> I prefer <|> for alternative.
06:13:00 <quicksilver> YMMV. :)
06:13:15 <pjd> EvilTerran: yes; Alternative is very parse-y terminology
06:13:20 * EvilTerran thinks "additive applicative functor" sounds better than "alternative applicative functor"
06:13:27 <Cale> Data declarations as well use | to mean +
06:14:19 <Toxaris> shouldn't <|> vs. <+> be handled like orElse vs. mplus. if these are ever handled...
06:14:22 <EvilTerran> and it doesn't attribute so much semantic meaning to the operator to say it does addition rather than alternation
06:14:37 <Cale> Toxaris: That sounds reasonable.
06:14:54 <EvilTerran> how are these handled?
06:15:35 <Toxaris> EvilTerran: http://haskell.org/haskellwiki/MonadPlus_reform_proposal
06:15:53 <Cale> EvilTerran: The idea behind orElse is that the second branch is taken only if the first fails, whereas mplus (ideally) would only be used where all options are always represented.
06:16:23 <EvilTerran> i see
06:16:39 * pjd vaguely ponders the meaning of subtraction and division at the type level
06:16:52 <EvilTerran> so you could have Additive and Applicative as seperate classes, in the same way
06:16:59 <EvilTerran> er, s/Applicative/Alternative
06:17:06 <idnar> well, what's the additive inverse of a type? :)
06:17:22 <pjd> idnar: subtyping, presumably
06:17:27 <EvilTerran> pjd, what about differentiation? :D
06:17:34 <pjd> EvilTerran: :P
06:17:44 <idnar> I think differentiation has already been covered :P
06:17:48 <Toxaris> well, in a perfect world, MonadPlus m would be an alias for (Alternative m, Monad m)
06:17:58 <EvilTerran> idnar, indeed it has. that's the zipper types, isn't it?
06:17:59 <pjd> type class aliases required!
06:18:18 <idnar> EvilTerran: yeah, something like that
06:18:33 <EvilTerran> Toxaris, except, under the reform proposal (with my little extension), MonadPlus m = (Monad m, Additive m), and MonadOr m = (Monad m, Alternative m)
06:18:58 <Toxaris> EvilTerran: yes :) exactly what I meant to say
06:19:25 <pjd> EvilTerran: what would Additive versus Alternative mean for [] ?
06:19:26 <EvilTerran> and it'd make perfect sense for Alternative to keep <|> and Additive to have <+>
06:20:11 <EvilTerran> pjd, (<+>) = (++); [] <|> y = y; x <|> _ = x
06:20:12 <EvilTerran> i guess
06:20:16 <Toxaris> pjd: [] <|> b = b   and   a <|> b = a   (stolen from the wiki page)
06:20:40 <pjd> hmm
06:20:51 <Toxaris> if a parser would feature different <|> and <+>, would we need try anymore?
06:21:17 <EvilTerran> we don't need try anyway; see ReadP :P#
06:21:38 <Toxaris> EvilTerran: has ReadP <|>, e.g., a non-try mode?
06:21:53 <Toxaris> (is <|> vs. <+> related to try at all?)
06:21:58 <EvilTerran> actually, it does have left-biased as well as symmetric choice
06:22:13 <EvilTerran> in general, <|> would be left-biased, and <+> symmetric, methinks
06:22:34 <quicksilver> symmetric a.k.a nodeterministic
06:22:38 <EvilTerran> indeed
06:22:52 <EvilTerran> you could probably write a sensible definition of <+> for parsec
06:22:59 <EvilTerran> maybe just x <+> y = try x <|> y
06:23:51 <EvilTerran> but we'd have to think up some axioms for <+> (and add some to <|>) and see if it fitted
06:24:08 <quicksilver> and quickcheck properties!
06:24:16 <quicksilver> and XML specifications!
06:24:19 <quicksilver> (well, maybe not)
06:24:28 <EvilTerran> and schema for the XML specifications!
06:26:19 <wolverian> and quickcheck properties for the quickcheck properties!
06:27:04 <EvilTerran> and an enterprise-level solution to leverage our synergistic OH GOD IT BURNS
06:27:06 <MyCatVerbs> wolverian: to make sure they correctly model the XML specifications?
06:27:22 <Zao> EvilTerran: That sentence hurt physically to write eh?
06:27:23 <MyCatVerbs> Wait, no, SHUT UP. *smacks himself in the face*
06:28:01 <EvilTerran> Zao, yeah... brb, bleaching my hands :P
06:28:44 <pjd> EvilTerran: i prescribe one brane asplosion
06:29:16 <smg> haha
06:29:21 <smg> i love :type foo @ ghci :D
06:31:00 <greenrd> How do I get a Haskell program to run as a hash-bang script in Linux?
06:31:16 <greenrd> I tried putting #! /usr/bin/runghc at the top but that doesn't work
06:31:32 <shepheb> a
06:31:59 <greenrd> oh, I have to put a .hs on the filename, silly me
06:32:07 <faxathisia> should you not use runhaskell ?+
06:32:15 <MyCatVerbs> greenrd: call it .lhs
06:32:28 <MyCatVerbs> greenrd: put runghc or runhaskell at the top (the latter is preferred)
06:33:02 <osfameron> why should the extension matter if you've used the shebang line?
06:33:02 <MyCatVerbs> greenrd: then prefix every line of Haskell code with "> ". Congratulations, if you've reached this stage, you have successfully abused bird scripts!
06:33:33 <faxathisia> I just realized
06:33:40 <faxathisia> #haskell is a .lhs file :D
06:33:50 <MyCatVerbs> osfameron: because the shebang line isn't stripped out by the operating system, and AFAIK the parser will hork when it sees the shebang line. Whereas in bird script mode it'll just ignore it.
06:34:01 <faxathisia> shapr, welcome to #haskell.lhs :D
06:34:02 <osfameron> ah
06:34:13 <faxathisia> almost ...
06:34:22 <faxathisia> If you remove nicks
06:34:49 <MyCatVerbs> Oh no, I'm wrong. runhaskell does survive the shebang line.
06:34:56 <MyCatVerbs> Sorry, thought it didn't. >_>
06:35:08 <gio123> what GHC is?
06:35:40 <MyCatVerbs> greenrd: GHC is love. Er, GHC is the Glasgow Haskell Compiler. (aka the Glorious Glasgow Haskell Compiler)
06:36:17 <gio123> thanks, so i have hugs, it will run on huges
06:36:18 <gio123> ?
06:36:44 <gio123> http://taichi.ddns.comp.nus.edu.sg/taichiwiki/Download_and_compile_XHaskell
06:36:51 <lambdabot> Title: Download and compile XHaskell - TaichiWiki, http://tinyurl.com/yszkoc
06:37:14 <MyCatVerbs> gio123: GHC is a Haskell compiler. Hugs is a Haskell interpreter. They are quite completely different programs.
06:37:46 <gio123> does hugs rely GHC?
06:38:01 <opqdonut> no, separate implemntation
06:38:01 <MyCatVerbs> No, not at all. Hugs is seperate.
06:38:22 <MyCatVerbs> gio123: but they both run the same language. Most Haskell code will work with both GHC and also with Hugs.
06:38:31 <gio123> so, it seems i cant include that library to hugs
06:38:31 <gio123> ?
06:38:48 <MyCatVerbs> gio123: sorry, I don't understand the question.
06:38:56 <EvilTerran> gio123, it says on that page that it relies on GHC
06:38:57 <gio123> http://taichi.ddns.comp.nus.edu.sg/taichiwiki/Download_and_compile_XHaskell
06:38:59 <lambdabot> Title: Download and compile XHaskell - TaichiWiki, http://tinyurl.com/yszkoc
06:39:05 <pjd> MyCatVerbs: XHaskell
06:39:15 <opqdonut> gio123: it requires ghc
06:39:15 <MyCatVerbs> pjd: oh, right. Of course.
06:39:17 <opqdonut> as the site says
06:39:41 <gio123> opqdonut: so, should i instal ghc?
06:39:45 <pjd> not just any GHC, but a patched GHC
06:39:57 <EvilTerran> gio123, not only that, but it looks like you need to built it from source with their patch applied
06:40:09 <gio123> uh quit hard
06:40:18 <gio123> to use that package
06:40:20 <MyCatVerbs> Yes, probably quite hard indeed.
06:40:32 <gio123> can somebody tell me what i have to do
06:40:36 <gio123> to use now it?
06:41:13 <MyCatVerbs> gio123: follow the instructions there.
06:41:14 <pjd> gio123: you probably don't have much choice but to patch and install GHC
06:41:42 <pjd> gio123: what do you want to use XHaskell for?
06:41:49 <MyCatVerbs> gio123: firstly install GHC on your system. Then download the source tarball for GHC 6.8.1, then unzip it, download their patch and apply it (the article tells you what commands to use for that).
06:41:51 <gio123> pjd: can u give me right link please? i am using win
06:42:17 <EvilTerran> ...i'm guessing it's an X program, in which case it won't even run on windows anyway
06:42:34 <pjd> EvilTerran: nah
06:42:35 <quicksilver> I don't think that's true.
06:42:38 <pjd> "XHaskell ("trans-Haskell") is an extension of Haskell with regular expression types, regular expression pattern matching and semantic-subtyping in style of XDuce."
06:42:38 <opqdonut> EvilTerran: it's a haskell extension
06:42:45 <Saizan> XHaskell ("trans-Haskell") is an extension of Haskell with regular expression types, regular expression pattern matching and semantic-subtyping in style of XDuce.
06:42:46 <EvilTerran> ah, i see.
06:42:55 <quicksilver> i wanna paste that too!
06:42:59 <opqdonut> :)
06:43:03 <pjd> @stereo
06:43:03 <lambdabot> Unknown command, try @list
06:43:12 <smg> hello
06:43:21 <EvilTerran> their choice of name goes against the established nomenclature
06:43:22 <gio123> EvilTerran: so, I have windows> is there GHV for win?
06:43:24 <EvilTerran> >:[
06:43:26 <smg> is there someething like __name__ == "__main__" hack in haskell?
06:43:39 <EvilTerran> smg, what does that hack do?
06:43:42 <pjd> smg: there is the main function
06:43:43 <hpaste>  mycatverbs pasted "MOAR PASTINGS!" at http://hpaste.org/5945
06:43:51 <opqdonut> smg: you don't need stuff like that
06:43:59 <MyCatVerbs> quicksilver: Ha!
06:44:03 <EvilTerran> my xhaskell is pastede on yey?
06:44:03 <opqdonut> as there is no module "body" that gets executed when it's loaded
06:44:16 <pjd> EvilTerran: that detects when a module is being run directly with Python
06:44:21 <pjd> as opposed to being included
06:44:21 <gio123> EvilTerran: ?
06:44:30 <EvilTerran> what is GHV?
06:44:37 <EvilTerran> i have no idea what you're talking about.
06:44:39 <smg> opqdonut: i'm building a module called Point and i need to have my method do_init() to be called if i use the module
06:44:47 <pjd> gio123: what do you want to use XHaskell for?
06:44:48 <smg> say i put in ghci :m +MyPoint
06:44:51 <pjd> are you sure you need it?
06:44:52 <smg> it should execute the line
06:45:02 <opqdonut> smg: you can't really force that, sorry :)
06:45:12 <smg> no?
06:45:15 <smg> really?
06:45:15 <opqdonut> what would the init do anyways
06:45:21 <EvilTerran> what opq said
06:45:26 <opqdonut> you're thinking imperatively
06:45:28 <MyCatVerbs> smg: yuuuuuck. I'm sure there must be some use for it, but that's just heinous.
06:45:30 <smg> opqdonut: i could just write module Main and use the main method could i?
06:45:40 <MyCatVerbs> smg: that's about as far away from "no side effects" as you can possibly get.
06:45:41 <quicksilver> implicit initialisation and construction considered harmful
06:45:43 <gio123> pjd: to decide whether reg expresion is subtype wrt other reg expression
06:45:53 <opqdonut> smg: main only gets run when you run a compiled executable
06:45:58 <smg> ah damn
06:45:59 <pjd> hmm, ok
06:46:01 <gio123> pjd: to decide reg1<reg2
06:46:06 <smg> opqdonut: so that's the default way?
06:46:06 <opqdonut> smg: what do you want to do?
06:46:11 <quicksilver> just ask anyone who had to write a C plus plus compiler
06:46:13 <quicksilver> ;)
06:46:20 <smg> i want to compile a module and then have a method run at the beginning
06:46:23 <opqdonut> defining the needed stuff lazily is what you want usually
06:46:27 <pjd> gio123: well, if you can't use another library, you'll have to patch and install GHC
06:46:27 <opqdonut> smg: why?
06:46:32 <EvilTerran> smg, what would the method *do*?
06:46:33 <opqdonut> what does the method do?
06:46:35 <smg> why not? :]
06:46:42 <opqdonut> you're thinkin imperatively
06:46:44 <opqdonut> running methods
06:46:47 <opqdonut> wrong mindset
06:46:48 <gio123> pjd: I will download now GHC
06:46:48 <smg> :D
06:46:55 <EvilTerran> would it be in IO? would it just spark the evaluation of some bindings ahead of time?
06:47:08 <smg> opqdonut: how would you do this? the program needs userinput
06:47:15 <smg> so the method must start when the program starts imho
06:47:24 <smg> so i need module Main?
06:47:28 * EvilTerran *headsigh*
06:47:30 <opqdonut> yeah
06:47:36 <opqdonut> or a function main at least
06:47:37 <smg> k
06:47:41 <MyCatVerbs> EvilTerran: is that a headdesk-while-sighing?
06:47:44 <gio123> pjd: should i donload Version 6.8.2 or Version 6.8.1?
06:47:55 <MyCatVerbs> EvilTerran: if so, that *really* needs an animated GIF.
06:47:56 <opqdonut> EvilTerran: my thoughts exactly
06:47:57 <smg> i can say module Point where ... main = ?
06:47:57 <EvilTerran> MyCatVerbs, elbow on table, head in hand
06:48:06 <opqdonut> smg: yes
06:48:07 <pjd> gio123: might as well go 6.8.2, i guess
06:48:13 <pjd> you'll need to get the sources: http://www.haskell.org/ghc/dist/6.8.2/ghc-6.8.2-src.tar.bz2
06:48:14 <MyCatVerbs> EvilTerran: ah, not quite as animate-able.
06:48:15 <pjd> not the binary
06:48:38 <pjd> gio123: and then follow the building instructions here: http://hackage.haskell.org/trac/ghc/wiki/Building
06:48:39 <lambdabot> Title: Building - GHC - Trac
06:48:45 <opqdonut> smg: err, i think you actually need a Main module
06:48:46 <Cale> Wait, why are we recommending someone get the GHC sources?
06:48:47 <greenrd> what is the standard way to convert a Float to a String and show only 1 decimal place?
06:48:57 <pjd> Cale: XHaskell requires it
06:49:05 <pejo> Cale, he needs ghc as a library, but patched.
06:49:10 <opqdonut> greenrd: showSPrec or something
06:49:15 <Cale> ah, okay
06:49:16 <dancor> bc opensource ftw
06:49:20 <roconnor> @hoogle showF
06:49:20 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
06:49:20 <lambdabot> Numeric.showFloat :: RealFloat a => a -> ShowS
06:49:20 <lambdabot> Data.Fixed.showFixed :: HasResolution a => Bool -> Fixed a -> String
06:49:22 <gio123> pjd: ghc-6.8.2-i386-windows.exe (~33 MB); a Windows Installer for GHC 6.8.2.
06:49:33 <gio123> pjd: I am downloading this one
06:49:38 <smg> opqdonut: yeah i need
06:49:38 <opqdonut> greenrd: http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html#v%3AshowEFloat <-- take a look here
06:49:39 <lambdabot> http://tinyurl.com/yjng6j
06:49:40 <pjd> gio123: that won't work;  it's the binary
06:49:44 <smg> opqdonut: can we define more than one module per file?
06:49:50 <roconnor> @hoogle showEFloate
06:49:51 <lambdabot> No matches found
06:49:53 <pejo> pjd, he needs something to build ghc with though.
06:49:54 <pjd> gio123: XHaskell requires you to patch the sources first
06:49:59 <roconnor> @hoogle showEFloat
06:50:00 <lambdabot> Numeric.showEFloat :: RealFloat a => Maybe Int -> a -> ShowS
06:50:00 <EvilTerran> pjd, but he'll need something like that to compile ghc from source
06:50:08 <opqdonut> smg: i don't think so
06:50:09 <pjd> oh, okay
06:50:12 <roconnor> >showEFloat (Just 1) pi
06:50:15 <roconnor> > showEFloat (Just 1) pi
06:50:16 <lambdabot>  <[Char] -> [Char]>
06:50:20 <roconnor> > showEFloat (Just 1) pi []
06:50:20 <smg> k
06:50:21 <lambdabot>  "3.1e0"
06:50:27 <roconnor> > showFFloat (Just 1) pi []
06:50:28 <lambdabot>  "3.1"
06:50:28 <dancor> since it doesn't look like qualified imports will ever take in haskell, should i stop using them for the sake of consistency with others?
06:50:36 <roconnor> > showGFloat (Just 1) pi []
06:50:37 <lambdabot>  "3.1"
06:50:54 <roconnor> > showGFloat (Just 1) exp(pi) []
06:50:54 <lambdabot>  Couldn't match expected type `[a] -> t'
06:50:59 <Cale> dancor: What?
06:51:03 <roconnor> > showGFloat (Just 1) (exp pi) []
06:51:04 <lambdabot>  "23.1"
06:51:12 <roconnor> > showGFloat (Just 2) (exp pi) []
06:51:12 <lambdabot>  "23.14"
06:51:16 <gio123> pjd: patch? what it means? no idea sorry :(
06:51:19 <roconnor> > showFFloat (Just 2) (exp pi) []
06:51:20 <lambdabot>  "23.14"
06:51:41 <pjd> gio123: a patch is a modification to the source code
06:51:50 <dancor> Cale: no one but mean seems to be fond of always using 'import qualified .. as ..'   i had held out for a while, but i'm wondering if i should just conform
06:52:03 <quicksilver> dancor: I use qualified in almost every program I write.
06:52:10 <quicksilver> Not for everything certainly.
06:52:12 <Cale> dancor: Well, we don't tend to import *everything* qualified.
06:52:12 <quicksilver> But
06:52:21 <quicksilver> , typically, for ByteString and Foldable and stuff I do.
06:52:29 <Cale> dancor: We only tend to qualify things if they absolutely need it.
06:52:37 <Cale> dancor: Otherwise, it
06:52:42 <dancor> well nothing absolutely ever needs 'qualified'
06:52:45 <Cale> dancor: Otherwise, it's just a waste of keystrokes.
06:52:52 <Cale> Oh, no, it does.
06:52:56 <gio123> pjd: I confused now, what i have to download :)
06:52:58 <dancor> you could just use 'as ..' to disambiguate
06:52:59 <faxathisia> You can define R with quotient types (apparently)
06:53:01 <Cale> For example, Data.Set defines 'map'
06:53:12 <Cale> Which will collide with the Prelude map if imported unqualified.
06:53:17 <faxathisia> or maybe R is a quotient type
06:53:28 <pjd> gio123: you'll need to download both the binary and the source, i think
06:53:35 <Saizan> R?
06:53:37 <gio123> ok
06:53:38 <gio123> thanks
06:53:41 <dancor> Cale: you could also import Prelude as P and Set as Set (nothing 'qualified')
06:53:47 <faxathisia> The set of reals
06:53:48 <pjd> and then patch the source, and build and install it
06:54:06 <Cale> dancor: But then you'd have to qualify map in all cases that you used it.
06:54:06 <faxathisia> \
06:54:29 <dancor> Cale: but in return you wouldn't have to qualify other Set funcs heh
06:54:36 <pjd> gio123: you'll also need MSYS or Cygwin
06:54:39 <pjd> for the build
06:54:39 <Saizan> faxathisia: starting from which set?
06:54:48 <Toxaris> dancor: you can import the same module more then once
06:54:56 <gio123> pjd: why? it is not for win?
06:54:57 <Cale> dancor: Well, normally I import Set something like this:
06:54:59 <faxathisia> I think it would be defined in terms of N and Q like usual
06:55:00 <pjd> gio123: it's a bit complicated on Windows :(
06:55:02 <smg> @src [Char]
06:55:02 <lambdabot> Source not found.
06:55:07 <Cale> import qualified Data.Set as S
06:55:09 <dancor> i guess i'm saying i have a new-found interest in conforming to the consensus of the community
06:55:13 <faxathisia> I don't know what a quotient type is though
06:55:15 <Cale> import Data.Set (Set)
06:55:19 <smg> btw is String just an type alias for [Char] ?
06:55:21 <smg> @src String
06:55:21 <lambdabot> type String = [Char]
06:55:26 <dancor> ok i see
06:55:31 <smg> lambdabot: ily
06:55:46 <gio123> pjd: ah i can use linux machine i think wait
06:55:46 <Cale> dancor: Which saves me from having to qualify the type constructor, at least. I'll add things to that list if they become annoying.
06:55:52 <dancor> when you look at someone else's code, how do you 'resolve' where funcs come from
06:56:00 <Cale> Types, usually.
06:56:08 <pjd> gio123: great; that should make things a lot easier
06:56:09 <dancor> but i mean do you have like ide magic
06:56:16 <Cale> But if I'm really confused, I'll just ask ghci
06:56:18 <Cale> :info foo
06:56:26 <Toxaris> dancor: we have ghci magic
06:56:28 <Cale> will generally tell you where foo is defined
06:56:32 <dancor> ok cool
06:56:40 <quicksilver> Yes, I often use a mixture of qualified and unqualified.
06:56:57 <quicksilver> (for a particular module)
06:57:03 <Saizan> faxathisia: afaiu it's what you get from a partition of a  type with an equivalence relation
06:57:11 <gio123> pjd: but i have to connect via putty
06:57:22 <gio123> pjd: so, i am on the linux terminal now
06:57:46 <Saizan> faxathisia: eg. Set is the quotient type of binary trees using "contains the same elements"
06:57:50 <faxathisia> I want to play with quotient types..
06:58:01 <faxathisia> is there some language which has it?
06:59:17 <pjd> gio123: okay, so you need to follow the instructions on the "Building" page
06:59:19 <faxathisia> Setoids are the same as quotient types?
06:59:50 <gio123> pjd: ok I will try now
06:59:57 <gio123> pjd: thanks
07:00:17 <roconnor> Setoids solve the same problem as quotient types, but are  not the same.
07:00:23 <pjd> gio123: you'll need an existing GHC installation to build GHC from source, so check if your linux distrubution has a GHC package
07:00:51 <pjd> and install it, along with the other other things listed under "What tools you need"
07:01:31 <pjd> gio123: then you pretty much just need to follow the "Quick start" build instructions
07:01:43 <pjd> except for one change, which is to apply the XHaskell patch
07:02:02 <pjd> which you must do beforehand, as described on the XHaskell page
07:02:09 <gio123> pjd: ok, but somehow i need also to have it my laptopp where i have windows
07:02:21 <gio123> is it so complicate does not cost to instal on windows?
07:02:39 <smg> if i want to overwrite the Show functions i need to say instance Point Show where
07:02:40 <pjd> "does not cost"?
07:03:02 <pjd> gio123: it's a bit more complicated on Windows than Unix, yes
07:03:12 <gio123> pjd: is it so hard to instal it on windows?
07:03:30 <gio123> pjd: I will try now on windows  again because
07:03:41 <gio123> pjd: i prefer to have it here
07:03:47 <pjd> gio123: okay
07:04:02 <gio123> so, first what i have to do is download and instal key gyn
07:04:05 <gio123> right?
07:04:08 <pjd> then it's about the same process as above, just with the extra steps described for Windows
07:04:12 <Toxaris> smg: instance Show Point where  if you want the type Point to be a member of typeclass Show
07:04:16 <pjd> key gen?
07:04:23 <pjd> gio123: you don't need anything like that
07:04:37 <gio123> u told me
07:04:56 <pjd> hmm?
07:05:03 <Saizan> wasn't he banned?
07:05:17 <pjd> gio123: do you mean MSYS / Cygwin?
07:05:39 <gio123> exactly
07:05:44 <gio123> Cygwin?
07:05:46 <gio123> Cygwin
07:05:48 <gio123> yes
07:05:49 <gio123> this
07:05:50 <pjd> gio123: those are toolkits for Windows
07:06:05 <pjd> they're completely free and open source :)
07:06:16 <gio123> so, i will download firstly  Cygwin
07:06:39 <pjd> they contain programs and utilities needed for the GHC build that Windows doesn't have
07:07:19 <faxathisia> what does it take to implement quotient types?
07:07:29 <droundy> Can anyone tell me how to convince ghc to pretend it's the C preprocessor?
07:08:02 <droundy> I want to create configure checks for header files that'll be guaranteed to run the same C preprocessor that ghc will run.
07:08:12 <faxathisia> droundy: -cpp
07:08:37 <faxathisia> wait is that what you meant?
07:09:25 <droundy> faxathisia: no, we already use that.  I want ghc to do nothing but call the C preprocessor on its input, like /lib/cpp would
07:09:31 <faxathisia> -cpp -E # should have it stop after preprocessing
07:11:24 <droundy> hmmm, j
07:11:33 <droundy> I tried that, and it didn't work...
07:11:34 <Toxaris> faxathisia: what do you mean by "implement quotient types"? operationally, a quotient type is something like a newtype with a custom Eq instance, if i understand them correctly.
07:12:22 <gio123> pjd: cygwin or x.cygwin is suitable?
07:12:43 <gio123> pjd: http://www.haskell.org/visualhaskell/
07:12:43 <lambdabot> Title: Visual Haskell
07:12:50 <gio123> what u think about it
07:12:51 <gio123> ?
07:12:56 <Cale> Toxaris: Ideally, one could still pattern match up to equivalence :)
07:13:57 <droundy> $ ghc -cpp -E test.c
07:13:57 <droundy> ghc-6.6: cannot compile this file to desired target: test.c
07:13:57 <droundy> Usage: For basic information, try the `--help' option.
07:14:11 <faxathisia> droudy: use it on .hs files
07:14:18 <faxathisia> use gcc -E or cpp for .c files
07:15:53 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5946
07:15:55 <Toxaris> Cale: that would be cool. the pattern match would be driven by the definiton of (==).
07:16:00 <smg> http://hpaste.org/5946
07:16:03 <smg> someone finds the error?
07:16:16 <dancor> would it be hard or bad to make "[4,5,]" legal (with list elements on new lines i often wish the last could have an extra comma).  i guess i could make a lame preprocessor
07:16:17 <gio123> does somebody use
07:16:18 <gio123> http://www.haskell.org/visualhaskell/
07:16:18 <lambdabot> Title: Visual Haskell
07:16:19 <gio123> ?
07:16:19 <droundy> faxathisia: but the point is that I want to use the gcc that is included with ghc on .c files, because that's what ghc is going to do.
07:16:31 <Cale> Toxaris: well, possibly. Or normalisation rules would be applied at the time of pattern match, for instance.
07:16:50 <faxathisia> dancor: Just don't type the extra comma
07:17:15 <Toxaris> Cale: applied both to the pattern and the value to be matched against
07:17:43 <Cale> Toxaris: I'm not sure you'd want to apply it to the pattern itself, but hmm...
07:17:50 <gio123> does http://www.haskell.org/visualhaskell/ replaces ghc
07:17:50 <lambdabot> Title: Visual Haskell
07:17:51 <gio123> ?
07:18:06 <Cale> Toxaris: By the way, Miranda, and apparently early versions of Haskell had a feature like this called 'laws'
07:18:42 <dancor> faxathisia: it's inconvenient when i remove the last element from a new-line delimited list
07:18:47 <Cale> You could define a type OList, which kept its elements in order, so pattern matching against an OCons would actually give you the least element.
07:19:01 <dancor> faxathisia: i guess i'll just make an editor macro
07:19:14 <doserj> dancor: one workaround is to put the "," at the start of the line, not the end
07:19:18 <smg> how can i overload + and - for my datatype Point?
07:19:26 <dancor> doserj: then you have the same problem with the first element
07:19:37 <doserj> :)
07:19:47 <dancor> the only true workaround like that is , isolated on lines
07:19:53 <dancor> but it's silly
07:19:53 <Toxaris> smg: instance Num Point
07:19:58 <faxathisia> It's actually not a problem, all you have to do is type or delete one character
07:19:59 <Cale> smg: You can either import the Prelude hiding those operators, or you can make Point an instance of Num. I don't think you want either of those.
07:20:11 <smg> ?
07:20:13 <Cale> smg: Probably best just to come up with a new name for the operators.
07:20:17 <smg> i see
07:20:24 <Cale> smg: I've used things like .+. and .-. before.
07:20:32 <gio123> does http://www.haskell.org/visualhaskell/ replaces ghc
07:20:32 <lambdabot> Title: Visual Haskell
07:20:35 <dcoutts_> Cale: were they runtime checked invariants?
07:21:27 <dancor> faxathisia: you could justify a lot of things with that reasoning :)
07:21:37 <Cale> dcoutts_: They were runtime enforced invariants. Basically, some rewriting would be done when the terms were evaluated.
07:21:50 <Cale> (which would be user specified)
07:21:54 <dancor> 1 character leads to 2
07:22:10 <dcoutts_> Cale: sounds like a view
07:22:15 <Cale> dcoutts_: Basically, yeah.
07:22:31 <Cale> dcoutts_: A view which could replace the default one.
07:22:37 <doserj> gio123: it says "...it includes a full GHC  installation with libraries..."
07:22:59 <dcoutts_> Cale: I'm not clear where the runtime invariant checking comes into that, it's an interesting mixture
07:24:06 <Cale> dcoutts_: Well, I say it's runtime enforced invariants in that your transformation function would just be applied automatically, and so any invariants which it enforced on the data would be present. You'd have to do any checking yourself.
07:24:20 <dcoutts_> Cale: ah right, makes sense
07:24:29 <gio123> doserj: so, I have to install GHC and not this visual
07:26:31 <Toxaris> Cale, dcoutts_: these Miranda laws seem to be similar to smart constructors to me.
07:26:46 <dcoutts_> Toxaris: more to smart deconstructors
07:27:18 <Toxaris> (footnote from "An Overview of Miranda":) In versions of Miranda before release two (1989) it was possible to associate laws with
07:27:19 <Toxaris> the constructors of an algebraic type, which are applied whenever an object of the type is
07:27:19 <Toxaris> built. For details see Turner [1985], Thompson [1986]. This feature was little used and has since been removed from the language.
07:27:33 <Toxaris> "whenever an object of the type is built" sounds like constructors for me
07:27:50 <dcoutts_> aye, does doesn't it
07:28:08 <Toxaris> (of course, smart constructors are laziley evaluated during the deconstruction process)
07:28:37 <smg> Cale: okay
07:28:48 <smg> Cale: may you look at my source?
07:29:40 <Feuerbach> I do 'ghci main.hs' and then can't use any top-level function except main. There's no declared module in main.hs. Am I missing something? GHCi 6.8.2
07:29:50 <smg> instance Num Point where
07:29:51 <smg>     (+) Point (a b) Point (c d) = Point (a+c) (b+d)
07:29:56 <smg> that's somehow wrong why? :|
07:30:01 <mauke> Feuerbach: yes, ghci is loading the compiled object code
07:30:05 <EvilTerran> p\rentheses
07:30:07 <Zao> Feuerbach: Main.foo ?
07:30:11 <mauke> Feuerbach: which doesn't export anything except main
07:30:16 <Toxaris> smg: (+) (Point a b) (Point c d) = ...
07:30:17 <quicksilver> smg: (+) (Point a b) (Point c d) = ..
07:30:22 <mauke> rm main.o and try again
07:30:27 <Toxaris> smg: or Point a b + Point c d =
07:30:29 <quicksilver> smg: or, more naturally: (Point a b) + (Point c d) = ...
07:30:41 <EvilTerran> Feuerbach, try adding "module Main where" to the top of the file
07:30:55 <EvilTerran> the lack of export decleration tells it to export everything
07:31:05 <Feuerbach> mauke: you're absolutely right, thanks
07:31:09 <EvilTerran> as compared to the default, implicit "module Main (main) where"
07:32:26 <EvilTerran> Feuerbach, that way, it should still work if you have a .o
07:33:51 <smg>     `Point' is not applied to enough type arguments
07:33:51 <smg>     Expected kind `*', but `Point' has kind `* -> * -> *'
07:34:16 <Feuerbach> EvilTerran: thanks for tip
07:34:24 <Toxaris> smg: how is point defined? data Point a b = ...?
07:34:26 <EvilTerran> smg, what's the line now?
07:34:47 <quicksilver> smg: you want instance Num (Point Int Int)
07:34:55 <EvilTerran> actually, nm. listen to t'others
07:34:56 <quicksilver> smg: or, more likely, instance Num a => Num (Point a a)
07:35:11 <smg> data Point a b = Point a b
07:35:36 <EvilTerran> instance (Num a, Num b) => Num (Point a b)
07:35:42 <Toxaris> smg: then use quicksilver's last line :) I would consider data Point a = Point a a, by the way.
07:36:08 <smg> k
07:36:10 <dancor> you can't overload (+) which already exists to apply to Point.  intstead you have to make a Point instance of Num
07:36:21 <smg> oO?
07:36:30 <EvilTerran> dancor, i think we've already got past that
07:37:11 <dancor> EvilTerran: i wasn't sure the reasoning behind the proffered code was sufficiently elucideated
07:37:17 <EvilTerran> smg, Toxaris has a point, actually, if you're doing multiplication in a way in which you'll need to do maths involving both a first and a second parameter of Point
07:37:30 <EvilTerran> (eg, if you do it complex-number style)
07:38:15 <smg> haha
07:38:20 <EvilTerran> smg, but if everything is pointwise, data Point a b = Point a b; instance (Num a, Num b) => Num (Point a b) would work fine
07:38:50 <doserj> EvilTerran: it wouldn't
07:39:05 <EvilTerran> ... do tell
07:39:07 <doserj> oh, it would
07:39:22 <doserj> as long as you don't add the different coordinates
07:39:34 <EvilTerran> as i said, "if everything is pointwise"
07:39:45 <doserj> yep,
07:40:43 <smg> ah okay
07:41:01 <smg> just wait
07:42:06 <EvilTerran> smg, but it's worth considering if you'll ever want the types of the two dimensions to be different. if not, you may as well say so and use data Point a = Point a a
07:46:40 <smg> EvilTerran: yeah you're right
07:49:18 <quicksilver> the instance of Num for Point is almost certainly a poor idea
07:49:27 <quicksilver> but that doesn't mean smg isn't learning something interesting from trying :)
07:51:51 <smg> quicksilver: why? :D
07:51:56 <smg> because i'm saying Point is a Number?
07:52:20 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5947
07:52:23 <doserj> because the typechecker won't stop you from trying to multiply two numbers
07:52:30 <smg> hehe ok
07:52:42 <smg> i pasted new version of it
07:52:43 <dolio> Num has too many operations that don't make a lot of sense on points.
07:52:50 <quicksilver> yes, what dolio said.
07:52:51 <resiak> Hrm, ghc complains that  MonadError Errno m => m ()  needs FlexibleContexts; why?
07:52:54 <Toxaris>  smg: basically yes. you can't implement all members of Num, so Num is too big a typeclass for Points. unfortunately, you can't change Num to a more modular definition ...
07:53:00 <dolio> But that's more of a Num problem.
07:53:16 <Cale> If they're 2-dimensional points, you could define things the same way as for complex numbers.
07:53:17 <Toxaris> resiak: maybe because Errno is no type variable?
07:53:27 <smg> Cale: i just defined operators for it
07:53:29 <resiak> hah, of course
07:53:51 <smg> but let the point stuff away, i will now try to write a module for n-dimensional vectors + operations on it :]
07:54:02 <smg> learning by doing
07:54:21 <quicksilver> ++
07:54:45 <smg> quicksilver: :]
07:55:03 <smg> @src undefined
07:55:03 <lambdabot> undefined =  error "Prelude.undefined"
07:55:11 <resiak> weird.  If I add no type signature, ghci infers (MonadError Errno m) => FilePath -> FilePath -> m Node.  But annotating it with that type gives 'Non type-variable argument in the constraint: MonadError Errno m' etc.
07:55:11 <smg> @type error
07:55:12 <lambdabot> forall a. [Char] -> a
07:55:20 <smg> :type error
07:55:34 <gnuvince> Is it possible to declare a datatype that takes a type parameter of only a certain class?  Something like: data Point (Num a) => a = Point a a
07:55:55 <opqdonut> gnuvince: data (Num a) => Point a = Point a a
07:56:21 <Cale> gnuvince: opqdonut's syntax works, but doesn't mean what you likely want it to.
07:56:57 <gnuvince> Cale: how so?
07:57:10 <opqdonut> data Point a = (Num a) => Point a a -- this does something totally different, too
07:57:13 <resiak> should i be wary of enabling FlexibleContexts?
07:57:19 <Cale> gnuvince: It only restricts the type of the data constructor, without providing the instance to things which pattern match.
07:57:45 <opqdonut> yeah, you'll have to include the context in all functions operating on the data
07:57:56 <smg> @pl pq a b c = let rad = sqrt (b*b -4*a*c) twice_a = 2*a in ((-b + rad) / twice_a, (-b -rad) / twice_a)
07:57:56 <lambdabot> (line 1, column 10):
07:57:56 <lambdabot> unexpected "="
07:57:56 <lambdabot> expecting variable, "(", operator or end of input
07:57:57 <byorgey> resiak: no, AIUI that's one of the less controversial extensions =)
07:58:31 <resiak> hrm, i'll stick it in and see what breaks :)  Thanks, folks
07:58:39 <smg> @pl pq a b c = ((-b + (sqrt (b*b -4*a*c)) / 2*a, (-b -(sqrt(b*b-4*a*c)) / twice_a)
07:58:39 <lambdabot> (line 1, column 10):
07:58:39 <lambdabot> unexpected "="
07:58:39 <lambdabot> expecting variable, "(", operator or end of input
07:59:23 <smg> @pl pq a b c = ( (-b + (sqrt (b*b -4*a*c))) / 2*a, (-b -(sqrt(b*b-4*a*c))) / twice_a)
07:59:25 <dolio> That's obviously not going to have a nice point-free version.
07:59:31 <lambdabot> pq = ap (ap . ((ap . ((,) .)) .) . join (flip . ((flip . ((*) .)) .) . flip flip 2 . ((flip . (((/) . negate) .)) .) . ap ((.) . (+)) . ((sqrt .) .) . flip ((.) . (-) . join (*)) . (*) . (4 *))) (
07:59:31 <lambdabot> flip flip twice_a . (flip .) . (((/) .) .) . ((negate .) .) . ap ((.) . (-)) . ((sqrt .) .) . flip ((.) . (-) . join (*)) . (*) . (4 *))
07:59:31 <lambdabot> optimization suspended, use @pl-resume to continue.
07:59:58 <Saizan> "optimization"
07:59:59 <smg> haha dolio :D
08:00:21 <quicksilver> gnuvince: there is just about no advantage in doing so.
08:00:30 <quicksilver> just arrange for the functions that use it to have the instance instead.
08:00:30 <smg> that's extreme pointfree style :D
08:00:55 <quicksilver> However, the GADTs extension allows constraints on constructors which are made available to pattern matchers.
08:01:02 <smg> btw lambdabot is a nice obfuscator
08:01:04 <quicksilver> (In 6.6. this was erroneously enabled by default)
08:04:55 <tack-work> @vixen
08:04:55 <lambdabot> what type of music do you like?
08:05:09 <tack-work> I like classical and progressive techno, what about you?
08:05:09 <tack-work> @vixen
08:05:09 <lambdabot> do you have toys?
08:06:58 <pitecus> Is anyone aware of a package which would allow me to serialize functions with GHC?
08:07:45 <tack-work> hs-plugins does something like that.. sorta
08:07:58 <tack-work> and the GHC API
08:09:22 <quicksilver> pitecus: it's "sort-of" not possible.
08:09:37 <quicksilver> pitecus: but you can get surprisingly close from various directions with various techniques.
08:11:16 <pitecus> quicksilver, which would be the simplest of those? i dont need much, just store some monomorphic functions in bytestrings and read them back
08:11:40 <tack-work> pitecus: what are you trying to serialize functions for? What problem are you trying to solve?
08:11:56 * Honey says hi to all
08:12:40 <byorgey> hi Honey
08:12:52 <Honey> hi
08:13:22 * oerjan finds saying "hi Honey" strangely difficult :D
08:13:29 <pitecus> tack-work, i learn a model which predicts outputs given some inputs. this is encoded as a haskell function and i'd like to be able to store it on disk for reuse
08:14:09 * Honey wonders why saying "hi Honey" difficult.
08:14:20 <opqdonut> :D
08:14:27 <Cale> oerjan: Some kind of fear of commitment?
08:14:27 <quicksilver> pitecus: My first recommendation is to encode it as an ADT not a function.
08:14:35 <smg> wb mauke_
08:14:38 <oerjan> Cale: possibly
08:14:42 <Cale> hehe
08:14:50 <dino-> Well, it's something I usually only say to the lovely Mrs. dino-
08:14:55 <tack-work> For an arbitrary function, you would need something pretty heavyweight, I think. If you are doing something where you can define the function more succinctly (such as a linear operator), then it's not so hard
08:14:56 <sweetie> hi
08:15:09 <byorgey> hehe
08:15:16 <dino-> Hi Honey. Wait, am I in trouble now?
08:16:39 <Honey> hi dibblego
08:16:40 <dino-> cdsmithus: You know I give out the URL of your 'types' paper all the time.
08:16:42 <oerjan> Honey: honey in english is usually a nickname only used for girl- or boyfriends
08:16:43 <Honey> hi dino
08:16:57 <Honey> im a girl so what???
08:16:59 <pitecus> quicksilver, i dont see how to do that very easily... the model includes feature extraction functions which can be pretty arbitrary
08:17:14 <MyCatVerbs> @pl \f c -> liftM toLower (char (f c))
08:17:14 <lambdabot> ((fmap toLower . char) .)
08:17:15 <dino-> But I could see that being an actual female name in some cultures.
08:17:32 <Syzygy-> dino-: Like US 80's? :)
08:17:53 * Syzygy- seems to recall some pretty eclectic US female first names...
08:17:57 <Honey> i have my real name, but my family prefer to call me Honey
08:18:13 <Honey> and i love it more.
08:18:16 <smg> maybe i do repeat myself, so i'd be sorry, but @src is that somewhere in ghci? like lambdabots @src or do i go to haskell.org?
08:18:35 * pitecus has no problems saying hi to Honey 
08:18:40 <MyCatVerbs> smg: it's in lambdabot. It's not in ghci.
08:18:55 <MyCatVerbs> smg: you can build ghci with all of lambdabot's features, but it's a total nightmare.
08:19:06 <oerjan> smg: since ghc doesn't always have the source to compiled modules, it cannot do so directly
08:19:08 <Honey> ok see you guys
08:19:20 <MyCatVerbs> (The devs would probably be quite grateful if you pulled it off, heh.)
08:19:22 <Syzygy-> About 2450 US females are named Honey.
08:19:25 <dino-> Bye Honey
08:19:28 <MyCatVerbs> Honey: have fun.
08:19:28 <Honey> im going back to the lounge
08:19:35 <Honey> bye dino
08:19:40 <MyCatVerbs> Honey: no wi-fi? Oh well.
08:19:43 <pitecus> ciao honey
08:20:00 <mightybyte>  Does Haskell have 64-bit addressing (on 64-bit machines with a 64-bit OS)?  i.e. could I have an Array or IOArray with more than 2^32 elements?
08:20:03 * Honey give kisses to dino for being nice, wave to the others.
08:20:21 <smg> lol
08:21:19 <dino-> oh boy
08:21:26 <dino-> Now I definitely am in trouble.
08:21:35 <smg> dino-: haha!
08:21:53 <oerjan> don't worry we won't tell Mrs. dino-
08:22:03 <Honey> ow by the way. i have a space at opera so just in case.  http://my.opera.com/honeyparedes/albums/show.dml?id=468265
08:22:09 <Honey> bye bye
08:22:37 <Gilly> adhoney
08:22:39 <sw17ch> so, haskell guys...
08:22:56 <oerjan> pitecus: if your code is not completely arbitrary, i.e. it is composed using combinators, then you can probably make a data type for that structure
08:23:14 <oerjan> s/i.e./e.g./
08:24:46 <pitecus> oerjan, ok. i was just wondering if there was something a bit less restrictive.
08:26:12 <pitecus> wasnt there some stuff like that in happs?
08:27:09 <Saizan> happs just maps some functions to datatypes
08:27:36 <Saizan> and provides a TH macro to automate it
08:28:08 <quicksilver> mightybyte: I believe so, yes.
08:28:30 <quicksilver> mightybyte: althought that's unlikely to be the best way to manage things, I suspect.
08:28:35 <mightybyte> quicksilver: Excellent.
08:28:42 <mightybyte> quicksilver: What do you mean?
08:28:47 <pitecus> Saizan, ok i see
08:28:58 <quicksilver> pitecus: you can lift arbitrary functions with TH
08:29:05 <quicksilver> but they need to be "there" at compile time
08:29:17 <quicksilver> TH can't lift something which was arbitrarily composed at runtime..
08:29:26 <quicksilver> because TH isn't "there" at run time.
08:29:48 <pitecus> quicksilver, is there an example of that somewhere?
08:29:59 <quicksilver> I think it's a typeclass called "lift'
08:30:00 <quicksilver> Lift
08:30:05 <quicksilver> which is built in to TH but I'm not sure.
08:30:13 <pitecus> ok i look
08:30:15 <quicksilver> there are a bunch of related kinds of lift and I get confused which is which.
08:30:26 <quicksilver> pitecus: you may have better luck generating haskell code.
08:30:29 <quicksilver> (as text)
08:30:34 <quicksilver> which you then execute with hs-pluins.
08:31:17 <pitecus> i thought hs-plugins didnt work witht he latest ghc?
08:31:32 <dolio> @version
08:31:33 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
08:31:33 <lambdabot> darcs get http://code.haskell.org/lambdabot
08:32:52 <Saizan> @where hs-plugins
08:32:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
08:33:02 <mightybyte> quicksilver: How should things be managed when you need an array of that size?
08:33:12 <Saizan> code.haskell.org/~dons/code/hs-plugins works on 6.8.2
08:33:26 <quicksilver> mightybyte: You probably want to work with pages (i.e. chunks)
08:33:37 <quicksilver> mightybyte: rather than trying to load it all at once.
08:33:40 <quicksilver> ICBW though.
08:33:57 <quicksilver> @where- hs-plugins
08:33:57 <lambdabot> Maybe you meant: where where+
08:34:01 <quicksilver> hmr
08:34:14 <quicksilver> @where+ hs-plugins http://www.cse.unsw.edu.au/~dons/hs-plugins/
08:34:14 <lambdabot> Done.
08:34:25 <mightybyte> Well, my application can work with chunks, but if I have a machine with more than 4 gigs of RAM, it would be nice to be able to take advantage of it all for speed reasons.
08:34:38 <quicksilver> @where+ hs-plugins http://code.haskell.org/~dons/code/hs-plugins
08:34:38 <lambdabot> It is forever etched in my memory.
08:34:42 <quicksilver> @where hs-plugins
08:34:43 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
08:34:45 <quicksilver> better!
08:34:52 <quicksilver> mightybyte: fair enough.
08:35:04 <mightybyte> But I guess you're saying to do that with multiple arrays so each one can be less than 2^32 elements?
08:35:16 <quicksilver> mightybyte: I would be inclined to work in chunks and let the OS cache it all in ram if it wants to
08:35:31 <tibbe> I remember seeing a handy function 'on' which could be useful when using something like groupBy, anyone have a link to an example?
08:35:44 <quicksilver> mightybyte: getting fewer than 2^32 elts wasn't actually the goal.
08:35:54 <Saizan> tibbe: Data.Function
08:35:57 <quicksilver> mightybyte: it's just that 4G data structures are pretty unwieldy on today's hardware.
08:36:06 <Syzygy-> > sortBy (compare `on` snd) [(1,3),(2,2),(3,1)]
08:36:07 <mightybyte> quicksilver: Ok.
08:36:07 <lambdabot>  [(3,1),(2,2),(1,3)]
08:36:16 <Syzygy-> Oh, that kind of link?
08:36:23 <hpaste>  Gavin pasted "peano" at http://hpaste.org/5948
08:36:44 <mightybyte> quicksilver: Agreed, but my app is chess endgame tables...a place where it's not hard to push the current hardware.
08:37:55 <smg> `on` where is that defined
08:37:56 <smg> ?
08:38:00 <faxathisia> @src on
08:38:00 <lambdabot> (*) `on` f = \x y -> f x * f y
08:38:09 <faxathisia> better than import Data.Function
08:38:41 <opqdonut> i prefer the definition ((*) `on` f) x y = f x * f y
08:40:32 <oerjan> opqdonut: maybe that doesn't compile as well when partially applying to only the first two arguments (as you would usually do) ?
08:40:55 <oerjan> (just guessing)
08:41:04 <opqdonut> it's equivalent
08:41:53 <tibbe> hmm, do we have an allEqual :: Eq a => [a] -> Bool ?
08:42:33 <oerjan> or maybe it has something to do with that compiler (hbc?) which cannot parse ((*) `on` f) x y = style
08:42:33 <faxathisia> :t \l -> foldr (==) (head l) l
08:42:34 <lambdabot> [Bool] -> Bool
08:42:53 <opqdonut> allEqual [] = True; allEqual (x:xs) = all (==x) xs
08:43:27 <tibbe> :t foldr (==) True
08:43:28 <lambdabot> [Bool] -> Bool
08:43:31 <quicksilver> tibbe: no.
08:43:34 <tibbe> hmm
08:43:47 <faxathisia> :t \l -> foldr (==) (head l) (tail l)
08:43:48 <lambdabot> [Bool] -> Bool
08:43:56 <faxathisia> Why is it taking [Bool]?
08:43:57 <roconnor> @type \l -> all (zipWith (==) l (tail l)
08:43:58 <lambdabot> parse error (possibly incorrect indentation)
08:44:00 <Zao> let allEqual (x:xs) = and $ map (==x) xs
08:44:01 <faxathisia> :t foldr
08:44:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:44:05 <quicksilver> :t \l -> and $ zipwith (==) l (tail l)
08:44:05 <lambdabot> Not in scope: `zipwith'
08:44:12 <quicksilver> :t \l -> and $ zipWith (==) l (tail l)
08:44:12 <roconnor> @type \l -> all (zipWith (==) l (tail l))
08:44:12 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:44:12 <lambdabot>     Couldn't match expected type `a -> Bool'
08:44:13 <lambdabot>            against inferred type `[Bool]'
08:44:13 <lambdabot>     In the first argument of `all', namely `(zipWith (==) l (tail l))'
08:44:14 <faxathisia> :t foldl
08:44:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:44:21 <quicksilver> mine is what you want, I believe.
08:44:26 <faxathisia> ok can't be done with fold
08:44:26 <Zao> Mine should early out on non-equalness, I believe.
08:44:33 <roconnor> tibbe: use quicksilver's
08:44:53 <tibbe> thanks
08:44:56 <Zao> @src and
08:44:56 <lambdabot> and   =  foldr (&&) True
08:45:21 <quicksilver> Zao: both yours and mine early-out on non-equalness, yes.
08:45:28 <oerjan> @src all
08:45:28 <lambdabot> all p =  and . map p
08:45:39 <Zao> Haskell is too optimal, no need for competing.
08:49:10 <jacobian_> Is there a literate haskell -> html?
08:49:51 <Saizan> jacobian_: HsColour can do that
08:51:04 <jacobian_> nice one, thanks
08:51:10 <desegnis> jacobian_: markdown (e. g. via pandoc) comes close, but alas, not quite
08:51:12 * tack-work is an American and finds the name of the module "HsColour" to be humorous
08:51:29 <gio123> does somebody knows Automake 1.7 what is?
08:52:08 <gnuvince> jacobian_: are you the Django Jacobian or another Jacobian?
08:52:14 <jacobian_> another
08:52:21 <gnuvince> ok
08:52:23 <quicksilver> gio123: yes. Google knows. Why don't you ask it.
08:52:25 <jacobian_> http://www.rubrication.net
08:52:26 <lambdabot> Title: Rubrication
08:53:33 <gio123> quicksilver: http://taichi.ddns.comp.nus.edu.sg/taichiwiki/Download_and_compile_XHaskell
08:53:34 <lambdabot> Title: Download and compile XHaskell - TaichiWiki, http://tinyurl.com/yszkoc
08:53:48 <gio123> quicksilver: to install it
08:54:27 <quicksilver> gio123: To install XHaskell is complicated. As we explained before, it's going to require you to compile your own ghc, patched.
08:55:08 <gio123> quicksilver: i downloaded ghc and cygwin
08:58:57 * Cale wonders why the XHaskell people wouldn't just release binaries.
09:00:12 <dancor> anyone know why http://hackage.haskell.org/packages/archive/arrows/latest/ doesn't actually point to http://hackage.haskell.org/packages/archive/arrows/0.4/arrows-0.4.tar.gz
09:00:13 <lambdabot> Title: Index of /packages/archive/arrows/latest
09:01:06 <dancor> i.e. i want easy links to latest tar gz for all hackagepackages
09:01:36 <Nafai> What's XHaskell?
09:03:25 <gio123> Nafai:http://taichi.ddns.comp.nus.edu.sg/taichiwiki/Download_and_compile_XHaskell
09:03:27 <lambdabot> Title: Download and compile XHaskell - TaichiWiki, http://tinyurl.com/yszkoc
09:03:39 <wy> I looked at Clean yesterday and found many similarity with Haskell. Are there any differences?
09:03:49 <quicksilver> yes.
09:03:55 <wy> What are they?
09:04:02 <quicksilver> > "haskell" \\ "clean"
09:04:03 <lambdabot>  "hskl"
09:04:18 <wy> uhhh
09:04:33 <quicksilver> clean doesn't support type classes and doesn't use monads for IO
09:04:38 <quicksilver> haskell doesn't have uniqueness types
09:04:58 <wy> I saw it mentioned Hindley/Milner/Mycroft type inference. I don't know if this is different from Haskell's
09:05:26 * oerjan distinctly thought clean had type classes
09:05:31 <wy> I only heard of the first two name ;)
09:05:34 <quicksilver> well, cleans type-inference is HM + uniqueness.
09:05:41 <quicksilver> haskell's type inference is HM + classes
09:05:42 <wy> oh
09:05:43 <quicksilver> AIUI.
09:05:56 <quicksilver> "HM" on its own is, roughly, the ML type system.
09:06:03 <quicksilver> oerjan: I could be wrong.
09:06:06 <wy> I know
09:06:15 <wy> Is uniqueness types good?
09:07:04 <quicksilver> You're right. Clean does support typeclasses.
09:07:09 <quicksilver> It just doesn't use monads for IO.
09:07:32 <faxathisia> I tried to write this code 5 times... It's never worked :/, What am I doing wrong?
09:07:52 <johnnowak> 15 more!
09:08:09 * EvilRanter looks at the social network graph
09:08:16 <wy> johnnowak: agree ;)
09:08:43 <wy> quicksilver: What does it do then?
09:08:44 <EvilRanter> hehe, i'm right in the middle. yay.
09:09:15 <wy> How does it do IO?
09:09:16 <quicksilver> wy: uniqueness types.
09:09:25 <wy> quicksilver: uniqueness types can do IO?
09:09:41 <oerjan> @src IO
09:09:41 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
09:10:14 <Cale> wy: They can ensure that the World token is passed around in a linear fashion between side-effecting functions.
09:10:15 <oerjan> wy: see that internal ghc definition?  thanks to uniqueness types Clean can pass RealWorld like that without wrapping in a monad
09:11:01 <wy> oerjan: That sounds good. I should look at uniqueness types
09:11:05 <Cale> However, you lose out on all the nice monad combinators.
09:11:17 <tac-> IO has a scary definition
09:11:18 <Cale> (all the stuff in Control.Monad)
09:11:19 <wy> uhhh
09:11:26 <faxathisia> Why does that sound good wy?
09:11:26 <EvilRanter> although i'd be tempted to wrap it in something state-monad-like anyway
09:11:33 <dancor> is there anything to generate cabal build-depends line for you
09:11:35 <wy> Cale: So you think monads are better?
09:11:37 <tac-> Is # being used as a constructor?
09:11:49 <Cale> wy: More convenient, at least in my mind.
09:11:54 <EvilRanter> tac-, it indicates weird internal stuff
09:12:08 <oerjan> tac-: (# ... #) are unboxed tuples, State# is an internally used type
09:12:10 <wy> Cale: Can arrows replace monads?
09:12:11 <EvilRanter> in State#, it's just part of the constructor name State#
09:12:13 <Cale> wy: You don't have to explicitly pass this token around, and you get lots of nice control structures for free.
09:12:20 <tac-> Ah, I see, it's on both sides
09:12:29 <wy> EvilRanter: I guess that means "unboxed"
09:12:37 <EvilRanter> possibly.
09:12:40 <Saizan> dancor: no, there's no sane way to extract that information, even if it's present in .hi files
09:12:48 <Cale> wy: Depends on what you mean by "replace". They're more general than monads, but that also means they support less sophisticated control structures.
09:12:55 <Philippa> wy: "primitive", possibly
09:12:57 <quicksilver> wy: monads are more general than uniqueness types.
09:13:15 <dancor> Saizan: we can't map known import lines?
09:13:18 <sclv_> clean also has lots of fancy unboxing primitives built in, as i recall, that are substantially more powerful than haskell's.
09:13:18 <Philippa> there's not a clear ordering on it
09:13:25 <wy> Philippa: yeah. I guess they mean the same thing
09:13:28 <tac-> And unboxed means you find an object on the stack or environment instead of a pointer to an object on the heap, right?
09:13:29 <Philippa> monads can't do everything uniqueness typing can
09:13:56 <gnuvince> @src cycle
09:13:56 <lambdabot> cycle [] = undefined
09:13:56 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
09:14:13 <sclv_> tac- pretty much.
09:14:37 <ddarius> quicksilver: Monads and uniqueness types are orthogonal
09:14:42 <quicksilver> wy: and they are an instructive generalisation, because it enables us to write general purpose functions which apply to all monads.
09:14:46 <wy> Interesting. I guess Mycroft invented that?
09:14:46 <sclv_> clean lets you do unboxed arrays and unboxed arrays of arrays and convert them to lists and all sorts of stuff really easily. not sure how its implemented on the inside.
09:14:49 <tac-> So an unboxed tuple is essentially a C-array, right?
09:14:51 <Saizan> dancor: well you want to know to which package a module belongs and ghc-pkg can only lists which modules a package contains, and then you've to manage versions
09:15:08 <quicksilver> ddarius: Well, yes. But uniqueness types as a solution to IO doesn't generalise to other effects in the way monads as a solution to IO does.
09:15:11 <quicksilver> ddarius: that's what I meant.
09:15:46 <oerjan> tac-: struct perhaps
09:15:50 <dancor> Saizan: could i get a usually-works situation by always assuming the latest versions are the active ones?
09:16:01 <quicksilver> uniqueness typing in principle is very interesting for destructive update
09:16:06 <wy> uh... there is a difference between quicksilver and Philippa on which can do more than the other
09:16:09 <quicksilver> especially if it's made optional.
09:16:11 <dancor> i try not to have multiple versions of anything installed anyway
09:16:13 <tac-> oerjan: ah yes. A struct is a better analogy, isn't it?
09:16:13 <sclv_> on the other hand, the clean code i've looked at seems to have a much more imperative feel to it, thanks to a certain sort of bound-let that works with the uniqueness types. it seems like giving ppl an opportunity to write imperatively with no performance hit means that lots of ppl *will* write imperatively instead of using functional idions.
09:16:17 <Philippa> wy: both can do things the other can't
09:16:20 <sclv_> s/idion/idiom/
09:16:20 <dancor> it always causes ridiculous things to happen
09:16:27 <Saizan> dancor: i think so
09:16:28 <quicksilver> what Philippa said was more strictly correct.
09:16:34 <quicksilver> I was only looking down a single axis.
09:16:36 <Philippa> quicksilver: it's also rather useful for things like enforcing conservation of quantities
09:16:52 <quicksilver> In particular "as a solution to IO side-effects"
09:17:01 <dancor> ok here's an easier one, why are GPL and BSD3 ok for "license:" but not GPL3 nor GPLv3
09:17:08 <wy> Philippa: quicksilver said monads are more general than uniqueness types. Does that mean monads can do everything uniqueness types can?
09:17:19 <Philippa> dancor: because nobody's got round to it
09:17:24 <ddarius> wy: Listen to what quicksilver is saying.
09:17:26 <Philippa> wy: It reads that way, but they can't
09:17:54 <jacobian_> sclv_> Is that a problem in the presence of uniqueness types though?
09:18:05 <jacobian_> It seems the problem with imperative code is the capacity to reason about it.
09:18:17 <jacobian_> If we have localised effects there isn't a real problem
09:18:59 <Cale> wy: Monads and uniqueness types are two orthogonal things. However, both can be used, in a special case, to solve the problem of ensuring that I/O effects happen in a particular order. The monadic solution to that problem generalises to other libraries and types of effects better than the solution which uses uniqueness types to solve it.
09:19:11 <sclv_> I found it to be a pain, at least. I look at some "x" in the bottom line of a function and I have to read back through four redefinitions of it and think them through instead of just looking at a single equation that states what it is.
09:20:12 <wy> Thanks. I guess I got enough general information. I should look at it
09:20:29 <Cale> Uniqueness types don't really capture a style of combinator library in the way that monads, applicative functors, arrows, comonads, etc. all do.
09:20:58 <wy> monads are so good
09:21:22 <wy> Does moggi has a lot to do with it?
09:21:48 <dons> it would be fun to have type-checked uniqueness in haskell sometimes though
09:21:51 <wy> I found his paper more theorectical than Wadlers
09:22:05 <dons> just so i know that some value is unique, and i can program accordingly
09:22:50 <Cale> On the other hand, uniqueness types are quite effective for other problems involving ensuring the compiler can find an efficient implementation of a program. Unique-typed variables can only be used once, which means that in recursive calls, for instance, it's possible to say that it's safe to just overwrite the variable in memory.
09:23:20 <ddarius> wy: Moggi was working in the context of denotational semantics, not programming.
09:23:44 <Cale> wy: Moggi was one of the people who brought monads into usage in computer science, though as ddarius points out, not initially for programming.
09:23:55 <sclv_> btw (unrelated), http://reddit.com/r/programming/info/6a4jp/comments/
09:24:28 <wy> But isn't semantics very related to programming? I guess the languages all evolve toward that way
09:24:43 <dancor> Philippa: do you think GPLv3 is the better form?  also do you think we should allow arbitrary numbers in GPLv<n> and BSD<n>
09:24:55 <Cale> The people who were using monads for denotational semantics eventually realised that if they were going to be formalising the semantics of their programs using monads anyway, why not actually program directly in the monad?
09:25:27 <Cale> I'm pretty sure that Wadler was the guy who popularised monads for programming in that regard.
09:25:38 <bpalmer> does anybody have experience running frag (http://www.haskell.org/haskellwiki/Frag) on OS X? I was hoping to play with the source to learn some FRP but it segfaults immediately on my macbook.
09:25:39 <lambdabot> Title: Frag - HaskellWiki
09:25:41 <wy> I guess we are taking more and more things inside the compiler originally to the programmer
09:26:00 <dancor> bpalmer: i can only say it works out of the box on linux
09:26:10 <faxathisia> bpalmer: I tried and got the same crash as you
09:26:28 <bpalmer> darn -- other GLUT apps work fine so I'm not sure what's up
09:26:41 <wy> Cale: His is paper is more readable for me also. I just played with his programs and understand the things
09:26:47 <waterman> bpalmer: I got a crash on MacOS, but the code is still a good read.
09:27:00 <faxathisia> This is impressive code http://www.cs.chalmers.se/~coquand/conv1.hs
09:27:05 <jacobian_> I wonder how well trying to ascribe uniqueness types to variables in monads would work.
09:27:14 <jacobian_> as an automated compiler pass.
09:27:27 <faxathisia> I wonder why they don't use De Bruijn indices though
09:33:09 <wy> faxathisia: You told me that dependent types are another axis. Is that from the notion of lambda cube?
09:33:39 <faxathisia> yes look at http://en.wikipedia.org/wiki/Lambda_cube
09:34:08 <faxathisia> also TAPL
09:37:12 <faxathisia> I'm very confused
09:37:32 <faxathisia> All these websites are saying "simply easy" and such to write a typechecker for it..
09:37:36 <faxathisia> It's actually very hard :P
09:37:53 <faxathisia> e.g. http://people.cs.uu.nl/andres/LambdaPi.html
09:37:54 <lambdabot> Title: Simply Easy! (An Implementation of a Dependently Typed Lambda Calculus)
09:38:48 <faxathisia> what am I missing..?
09:39:39 <wy> Has Coquand something to do with Coq?
09:40:17 <ddarius> faxathisia: Which part are you finding difficult?
09:41:34 <faxathisia> Just ensuring that the code is correct
09:41:47 <wy> faxathisia: that's always hard ;)
09:43:56 <Philippa> wy: you could say that, yeah
09:44:06 <pejo> faxa, have you seen http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html?
09:44:07 <Philippa> Coq was originally built around the Calculus of Constructions
09:44:07 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2c5rst
09:44:17 <faxathisia> pejo, yes :(
09:44:37 <faxathisia> pejo, This is what I don't get.. everyone says it's easy, but I am not finding that
09:44:57 <wy> faxathisia: they are wrong. they are frustrating people ;)
09:45:08 <faxathisia> one of my attempts can show Succ Succ Zero : Nat but there is problems in everything
09:45:13 <ddarius> faxathisia: These "simply easy" papers/posts are in response to people thinking that it is excessively hard.
09:45:18 <wy> That's like saying "It's obvious  that... " in a book
09:46:08 <faxathisia> Sadly.. I'm not convinced by these posts..
09:46:50 <Philippa> faxathisia: can you write a checker for the simply-typed lambda calculus easily?
09:46:55 <faxathisia> yes
09:47:13 <faxathisia> inference for it is easy as well
09:47:33 <Philippa> well yeah. equality constraints, trivial solver and you're done
09:47:37 * byorgey reads about Agda
09:47:47 <ddarius> The main "extra" complication relative to the simply typed lambda calculus is that the contexts get more complicated.
09:47:51 <byorgey> any advice on where to start if I want to learn some Agda?
09:48:11 <byorgey> I'm currently reading through the "Introduction" code
09:48:19 <faxathisia> byorgey, A fun tutorial is here http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.TypesSummerSchool2007
09:48:21 <lambdabot> Title: 28 The Agda Wiki - Types Summer School 2007 4b, http://tinyurl.com/yuktth
09:48:24 <quicksilver> "simple" is obviously relative.
09:48:34 <quicksilver> but that code certainl is simple, relative to quite a lot of stuff.
09:48:41 <roconnor> ddarius: and the evaluation engine has to be put in the type checker.
09:48:44 <byorgey> cool, thanks faxathisia
09:48:56 <wy> Have you guy found visitor patterns in Java ever useful? I found it ugly
09:49:11 <wy> Is it even useful for Java?
09:49:11 <ddarius> roconnor: Yes, but that is part of what dependent types are hence the "extra".
09:49:16 <faxathisia> you need to have mutually recursive eval and typecheck I think
09:49:33 <faxathisia> It's not a problem though.. just .. my code never works for some reason
09:49:48 <faxathisia> which I find odd
09:49:53 <quicksilver> wy: yes, it's useful.
09:50:07 <quicksilver> wy: I've used it for manipulating ASTs
09:50:14 <quicksilver> or doing calculations based on ASTs.
09:50:27 <quicksilver> I think I've used it to implement a simple kind of byte code compiler, indeed.
09:50:30 <pejo> wy, check the modern compiler implementation in Java by Appel and Palsberg for a bunch of examples.
09:50:31 <quicksilver> can't quite remember.
09:50:47 <quicksilver> it's certainly a rather ugly pattern compared to the alternatives in other languages.
09:50:58 <wy> quicksilver: I'm writing something like that too. But this time for types. I want to write equality test for types, but the visitor pattern can only overload one object
09:51:02 <quicksilver> but, on the other hand, it is *less* ugly than some of the other ways to do it in java :)
09:51:02 <faxathisia> oh let me ask one thing
09:51:24 <hpaste>  faxathisia pasted "AST" at http://hpaste.org/5949
09:51:38 <faxathisia> Is this a reasonable AST for this?
09:52:07 <faxathisia> Lambda and Pi are annotated with paremeter type
09:52:20 <dolio> faxathisia: I meant to ask you something a while back about that Agda intro. When you define 'Nat = List ()', it says "Now define Vec and Fin using All and Some." Did you do that? I couldn't figure out what they were getting at.
09:52:34 <faxathisia> dolio, yes I did it
09:52:48 <faxathisia> let me see if it's still here
09:53:07 <Gilly> When should I use the State monad and when the IO monad? What are the differences?
09:53:31 <gnuvince> @src concat
09:53:32 <lambdabot> concat = foldr (++) []
09:53:32 <ddarius> Gilly: The names pretty much answer that questien.
09:53:33 <sioraiocht> Gilly: State monad is for preserving state, IO is for..well...I/O to a mutable variable or file
09:53:41 <resiak> @hoogle Bool -> m a -> m a
09:53:41 <lambdabot> GHC.Exts.breakpointCond :: Bool -> a -> a
09:53:41 <lambdabot> Control.Exception.assert :: Bool -> a -> a
09:53:46 <resiak> bah.
09:53:48 <sioraiocht> or to the screen
09:54:06 <Gilly> well, there are STArray and IOArray for example
09:54:25 <Philippa> Gilly: if you want a single mutable cell, use State. If you want a mutable heap but don't need to do IO, use ST. If you want IO, use IO
09:54:41 <quicksilver> Gilly: ST is quite different from State. I only say this to clear up any confusion that might be developing.
09:55:16 <quicksilver> ST is the {IORef,IOArray} fragment of IO without any of the actual genuine IO stuff.
09:55:21 <Gilly> heh i still know next to nothing and i'm asking not to develop any confusion but thanks for clarification :)
09:55:26 <Toxaris> wy: since Java doesn't support multimethods (that is, dynamic dispatch for multiple arguments at once), the Visitor pattern is less usable to implement binary functions
09:55:27 <quicksilver> This is very handy, because you can call it from pure code.
09:55:34 <quicksilver> State is conceptually a much simpler thing.
09:55:48 <faxathisia> dolio, I think that it shows what relation there is between vector and fin.. and the more general All and Some type
09:55:49 <Gilly> ok, what is 'pure' code?
09:55:51 <quicksilver> State is a just a monad about threading a single (updatable) state trhough a bunch of actions.
09:56:02 <quicksilver> 'pure' code is non-IO code, in this context.
09:56:06 <wy> Toxaris: hmm that's bad. I think the problem is mainly from the notion of "everything is an object"
09:56:09 <Philippa> Gilly: most code is pure
09:56:17 <Philippa> Gilly: if you're not doing IO, it's probably pure
09:56:22 <Gilly> ok :)
09:56:36 <quicksilver> furthermore, most code *should* be pure, because it's easier to reason about, test and reuse.
09:56:37 <Philippa> (other impure cases use structures similar to the IO monad - you'll know you're doing it)
09:56:48 <quicksilver> So it's a good goal to keep as much pure as possible.
09:56:55 <Gilly> now now, well, are starrays pure?
09:57:08 <quicksilver> This is one of the great things about the ST monad. Before it existed, people had to use IO when they wanted {IORef/IOArra}
09:57:24 <faxathisia> dolio, should I paste what I got?
09:57:24 <Philippa> Gilly: the ST monad is one of those "similar structures" - but you can run ST code from pure code
09:57:30 <Philippa> whereas you can't do the same with IO
09:57:37 <dolio> faxathisia: I'd appreciate that.
09:57:45 <gwern> anyone know if it's possible through template haskell to replace calls to all partial Prelude functions with a version which reports the line number in an error (on a [] for example)?
09:57:47 <Gilly> and they generally wanted IOArray because of speed issues?
09:58:04 <faxathisia> http://hpaste.org/5950/0/plain
09:58:07 <Toxaris> wy: a possible solution is to reify your functions *in a curried form* so that you can dynamically dispatch on all arguments, one after another, similar to pattern matching in haskell
09:58:18 <Philippa> Gilly: to a first approximation, yeah
09:58:21 <Gilly> like if I went on with conventional arrays when building them I'd have to make a new copy after every change?
09:58:29 <Philippa> yep
09:58:58 <Gilly> right
09:59:09 <wy> Toxaris: How can I do currying for Java?
09:59:21 <Gilly> so... i'm writing a function to plot a graph on an array, i probably should go for STArray then
09:59:30 <gwern> I saw currying in java once on 4chan. it was hideous
09:59:45 <Toxaris> wy: so you end up with an interface Function<X,Y> {Y apply(X x)} and a operation static Function<Type, Function<Type, Bool>> typeEquality() { return new ... }
09:59:51 <wy> uhh.. I give up
10:00:09 <faxathisia> Why would you curry in java?
10:00:14 <faxathisia> that makes no sense
10:00:16 <wy> I just use instanceof tests
10:00:27 <dolio> faxathisia: Ah, interesting.
10:00:32 <wy> faxathisia: I was trying to use visitor patterns for binary operations
10:01:22 <Toxaris> faxathisia: to extend visitor pattern (that is: reifed dynamic dispatch) to more then one argument without exponential explosion of visitXxx methods
10:02:33 <Toxaris> faxathisia: as an extra, you get first-class functions and a choice to implement laziness.
10:03:07 <ddarius> Gilly: The use of ST/IOArrays is relatively uncommon and nothing about your problem statement made me see any need for them.
10:03:18 <byorgey> anyone have any ideas on this Agda compile error: http://hpaste.org/5951 ?
10:03:23 <byorgey> is there a better place to ask?
10:03:29 <Gilly> ddarius: oh... maybe i got the wrong mindset then
10:03:42 <wy> any way I gave up and I'll use my instanceof instead...
10:03:51 <Philippa> ddarius: I suspect Gilly actually wants that kind of layout in memory for bitmap plotting purposes
10:04:00 <dolio> byorgey: Are you compiling from darcs?
10:04:03 <Gilly> ddarius: the way i was going to implement this would include going through 800x800 rectangular grid, evaluating a function at each point and putting the result on the array
10:04:05 <Toxaris> wy: yes, probably easier :)
10:04:18 <byorgey> dolio: no, should I?  I got the latest released version
10:04:20 <Philippa> ah, if that's all you're doing then that's different
10:04:21 <ddarius> Gilly: Do it whole-sale.
10:04:27 <Philippa> construction is cheap
10:04:39 <Gilly> can you explain more? :)
10:04:39 <dolio> byorgey: If not, do so (you'll also need QuickCheck from darcs). The latest release doesn't compile for me (or fax) either.
10:04:39 <Philippa> see, your function's pure, right?
10:04:43 <Gilly> right
10:04:44 <tibbe> @seen dons
10:04:44 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 42m 39s ago.
10:04:56 <Philippa> so it can allocate the block and just fill it in
10:05:03 <faxathisia> byorgey: I think you should get the darcs or svn..
10:05:03 <Philippa> your function actually gets called by the 'constructor'
10:05:06 <byorgey> dolio: ok, I'll do that.  thanks.
10:05:26 <Gilly> oh sounds nice
10:05:27 <faxathisia> darcs get --partial http://www.cs.chalmers.se/~ulfn/darcs/Agda2
10:05:29 <lambdabot> Title: Index of /~ulfn/darcs/Agda2
10:05:30 <Philippa> the rest of the world never knows it didn't all happen at once, because it's all done before anything gets to yank a value out
10:06:42 <Gilly> right... iirc the constructor for arrays is a list of index/value pairs, but i think it won't construct the list at all in whole because all it does is going through some head calls, am i right?
10:06:44 <faxathisia> no comments about my AST ?:S
10:07:23 <gnuvince> @src last
10:07:23 <lambdabot> last [x]    = x
10:07:23 <lambdabot> last (_:xs) = last xs
10:07:23 <lambdabot> last []     = undefined
10:07:39 <faxathisia> last = head . reverse
10:08:39 <Baughn> faxathisia: Why do you hate the CPU cache?
10:09:08 <faxathisia> I like the shorter def. :P You can supercompile it to get back to the other one
10:09:30 <Baughn> Mm. I wonder if ghc is that smart.
10:09:54 <faxathisia> I wonder how I should proceed...
10:10:09 <faxathisia> (to write this typechecker{
10:10:30 <Baughn> Compile to haskell source, have ghc typecheck?
10:10:57 <faxathisia> That could be ever harder..
10:11:33 <byorgey> ah, much better, thanks dolio, faxathisia =)
10:14:34 <Philippa> Gilly: bingo
10:18:01 <faxathisia> dolio, have you looked at Agda 2 source code much?
10:18:26 <faxathisia> I read through the type checker but still don't really see how it figures which types are emtyp
10:19:00 <roconnor> ... determining if a type is empty is an undecidable problem.
10:19:08 <roconnor> maybe I shouldn't jump into the middle of this.
10:19:24 <faxathisia> roconnor, Agda 2 has some tricks, It can tell automatically in a few cases
10:19:31 <Gilly> Philippa: I'm starting to love this language :)
10:19:42 <faxathisia> of course not in general
10:20:18 <roconnor> test1: see if it has no constructors. :)
10:20:28 <faxathisia> roconnor, It basically eliminates the need for an eliminator for types and the inversion tactic
10:20:40 <faxathisia> (although these are sometimes a lot easier to use..)
10:21:20 <roconnor> faxathisia: ? empty types have an elimination function.  Void -> a
10:21:39 <opqdonut> huh?
10:21:40 <faxathisia> yes but instead of using that directly you let Agda 2 do it
10:21:47 <roconnor> oh
10:22:00 <opqdonut> ah, now i get it
10:22:01 <faxathisia> the thing is it handles more than the most simple cases.. and it's not clear just how clever it is to me
10:27:05 <laura85> hi ^^
10:27:26 <Vq^> hello laura85
10:28:33 <dons> ?users
10:28:33 <lambdabot> Maximum users seen in #haskell: 463, currently: 433 (93.5%), active: 20 (4.6%)
10:32:42 <dolio> faxathisia: No, I haven't.
10:34:22 <laura85> is there a tool which creates tex files from lsh files? kinda lsh2tex'ish ^^
10:34:51 <opqdonut> lsh?
10:34:53 <faxathisia> what's lsh?
10:34:58 <faxathisia> (lhs2TeX does exist)
10:35:15 <laura85> haskellcode.lsh
10:35:21 <gnuvince> faxathisia: Literate Haskell
10:35:35 <faxathisia> gnuvince: No, Literate Haskell is .lhs
10:35:43 <gnuvince> Oops, misread
10:35:47 <gnuvince> sorry
10:36:07 <laura85> lhs Ihs
10:36:29 <laura85> first one is the letter after k, second starts with i
10:37:13 <faxathisia> laura85: Maybe you can use this.. not sure.. http://people.cs.uu.nl/andres/lhs2tex/
10:37:14 <lambdabot> Title: lhs2TeX
10:38:00 <laura85> faxathisia, gnuvince, lambdabot: thanks a lot! i'm gonna try that
10:39:55 <byorgey> hm, how do I actually run/interact with Agda code?
10:39:59 <glguy> ?seen dcoutts
10:39:59 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 4h 31m 29s ago.
10:40:05 <dino-> dons: I had never heard the phrase 'monkey patch' until you used it here the other day.
10:40:08 <dino-> Made me laugh.
10:40:18 <faxathisia> byorgey, The emacs mode is good
10:40:21 <opqdonut> monkey patch?
10:40:24 <faxathisia> you get feedback as you go..
10:40:28 <dino-> http://en.wikipedia.org/wiki/Monkey_patch
10:40:29 <lambdabot> Title: Monkey patch - Wikipedia, the free encyclopedia
10:40:32 <gwern> there's also Igloo's  lhs to tex processor
10:40:41 <byorgey> faxathisia: hm, I've got that installed...
10:40:43 <faxathisia> I think there are some tricks for program derivation but I haven't tried that
10:40:46 <dolio> byorgey: There also are instructions for installing a ghci-sort of thing in one of the readmes.
10:41:01 <dino-> I believe someone was asking here about runtime redefinition of functions.
10:41:03 <byorgey> faxathisia: could you elaborate on the emacs-mode thing?
10:41:10 <gwern> @seen zamez
10:41:10 <lambdabot> zamez is in #haskell. I don't know when zamez last spoke.
10:41:15 <dino-> And dons said no, you can't monkey patch in Haskell
10:41:17 <gwern> @seen zao
10:41:18 <lambdabot> zao is in #xmonad and #haskell. I last heard zao speak 1h 55m 38s ago.
10:41:18 <byorgey> dolio: ok, I hadn't seen that yet, I'll dig around a bit more
10:41:28 <MyCatVerbs> dino-: as in, you're not capable? Or you're not allowed? :D
10:41:30 <gwern> (darn tab complete)
10:41:31 <faxathisia> byorgey, If you have a .agda file open you can use C-c C-x C-l to load and check the fie
10:41:47 <Zao> gwern: Yes?
10:41:48 <byorgey> faxathisia: ah, ok, thanks
10:41:57 <MyCatVerbs> dino-: I'm sure some heavy abuse of Data.Dynamic and a crappy little association list would let you simulate it. :D
10:42:02 <gwern> Zao: When are you going to have downloads avaiabale for your tetris?
10:42:07 <dolio> faxathisia: Is there a way to evaluate expressions using the emacs mode? I didn't see a menu option for that.
10:42:14 <MyCatVerbs> dino-: still doesn't make it even remotely a good idea, though. ^_^
10:42:20 * dino- cries
10:42:23 <gwern> (http://www.acc.umu.se/~zao/Hastris/ I mean)
10:42:24 <lambdabot> Title: Hastris - a Haskell xtris client
10:42:29 <Zao> gwern: When it's playable :)
10:42:36 <faxathisia> dolio, yes use C-c C-n
10:42:38 <gwern> oh you're no fun
10:42:51 <Zao> gwern: If you had read the uncommented and horrible code, you'd seen that it cannot play locally, just observe multiplayer games :)
10:42:51 <gwern> Zao: and when will that be d'you think?
10:43:31 <gwern> Zao: kibbitzing is enough for an alpha release, imo. what could xmonad do at 0.1? not a whole lot\
10:43:31 <byorgey> faxathisia: oh, haha, I have the menubar turned off in emacs by default, so I didn't see the Agda2 menu and didn't even think to look for it  =P
10:43:47 <dolio> faxathisia: Hmm, that seems to be undefined here.
10:44:26 <byorgey> dolio: works for me
10:45:57 * gwern bahs. lhs2tex doesn't cabal-install
10:46:06 <Zao> gwern: Heck, it's not even cabalized.
10:46:37 <faxathisia> byorgey, You should check out Agda2/examples/SummerSchool07/Lecture/Filter.agda for a neat proof
10:46:41 <desegnis> Zao, it is in 1.13
10:46:42 <gwern> Zao: like that'd stop me...
10:46:52 <faxathisia> I thought this is pretty cool anyway..
10:47:09 <byorgey> faxathisia: ok, I will.  just learning the basics right now =)
10:47:23 <Zao> desegnis: My project, that is.
10:47:51 <desegnis> ah ok
10:49:23 <kosmikus> gwern: why not?
10:50:05 <gwern> kosmikus: I cabalize things. it's my hobby, in a sense
10:50:09 <MyCatVerbs> @pl \f a -> f >> return a
10:50:10 <lambdabot> (. return) . (>>)
10:50:26 <kosmikus> gwern: I mean, why doesn't lhs2tex install?
10:50:48 <faxathisia> :t \f -> do f ; return
10:50:48 <lambdabot> forall t a (m :: * -> *). (Monad m) => (a -> t) -> a -> m a
10:50:58 <gwern> kosmikus: oh. good question. I haven't decided whether it's because my cabal is too new or lhs2tex's wants a too old cabal
10:51:16 <hpaste>  gwern pasted "lhs2tex" at http://hpaste.org/5952
10:52:23 <kosmikus> gwern: what's your cabal version?
10:53:18 <Zao> gwern: Who could ever need anything more advanced to build things than this? http://www.acc.umu.se/~zao/Hastris/trunk/Build
10:53:26 <gwern> Cabal-1.2.3.0, Cabal-1.3.3, & Cabal-1.3.6 :)
10:53:56 <Zao> "As soon as one of the files listed changes, rebuild everything"
10:54:05 <kosmikus> I'd expect it to work with 1.2.3, but not with 1.3
10:54:06 <gwern> Zao: and how would one cabal-install such a masterly build process? or write a script to automatically debianize it and everything else on hackage?
10:54:09 <Zao> Quite nice to get type clashes immediately when saving.
10:54:13 <Zao> gwern: With pain.
10:54:28 <gwern> eggsazackly
10:55:17 <lament> how do i find the biggest element in an array?
10:55:31 <faxathisia> :t sort
10:55:32 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:55:36 <lament> (more specifically an MArray)
10:55:37 <faxathisia> head . sort -- how about?
10:55:41 <faxathisia> oh..
10:56:02 <opqdonut> lament: fold over it with max
10:56:05 <Cale> lament: Probably, get the list of elements first. Then maximum will work.
10:56:14 <opqdonut> there should be a Foldable instance for it
10:56:29 <pitecus> im using a pointer to a c++ object in haskell, this object has method to save it to a file, but not to save it to a string. i want to have a Binary instance for that object. I was thinking of having an impure function which writes it to a temp file and reads the string, and converting that to a pure function with unsafePerformIO... Is that reasonable?
10:56:34 <faxathisia> (should have said head . reverse . sort but maximum is better..)
10:57:34 <Cale> pitecus: Is the C++ object already pure? That is, are you guaranteed to always get the same String every time via that method?
10:57:43 <Toxaris> > Data.Foldable.maximum $ listArray (0, 4) [4, 3, 5, 1, 9]
10:57:43 <lambdabot>  9
10:58:18 <Toxaris> but will this help for an MArray?
10:58:20 <pitecus> Cale, well i didnt write the code so i cant be 100% sure but i would b e very surprised if it wasnt the case
10:58:26 <lament> Toxaris: apparently not
10:58:38 <Vq^> faxathisia: or  head . sortBy (flip compare)
10:58:40 <lament> Marrays have a monad in them, so folding them is not quite that easy
10:58:51 <Cale> pitecus: okay, then probably it would be okay.
10:59:05 <pitecus> Cale, ok cool
10:59:34 <Cale> pitecus: You should probably use a NOINLINE pragma on the code which uses unsafePerformIO, as usual.
10:59:41 <Toxaris> lament: fmap maximum getElems
11:00:39 <lament> Toxaris: yeah...
11:00:57 <lament> so in effect, any advantage of using a MArray is gone as soon as you need to do something with them :)
11:01:08 <Cale> lament: Not at all.
11:01:08 <pitecus> ok thanks
11:01:10 <lament> might as well just use lists to begin with
11:01:24 <Cale> lament: Indexing and mutation at an arbitrary index are fast.
11:01:29 <dancor> is there already something to grab a webpage
11:01:41 <bd_> lament: less memory usage for an unpacked mutable array
11:01:47 <Toxaris> lament: well, to find the biggest element in an unsorted array, you need to inspect all elements. this is not quantum computing, you know.
11:02:18 <Cale> lament: Converting to a list is O(n), as is finding the maximum element, so you're not really losing anything.
11:02:48 <opqdonut> Cale: do you think the list will get fusioned there?
11:03:00 <Cale> opqdonut: Probably not.
11:03:01 <lament> i think i'll actually just do most stuff in C
11:03:11 <lament> btw i love haskell's ffi :D
11:03:12 <Cale> opqdonut: However, in the future, possibly.
11:04:03 <opqdonut> Cale: wouldn't it just require using "build" in the elems function?
11:04:42 <Cale> Oh, possibly, yeah.
11:04:56 <roconnor> dancor: you can use the HTTP library
11:05:01 <roconnor> @hackage HTTP
11:05:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP
11:05:02 <resiak> hrm.  it's not possible to see what exactly was re-entered unsafely to cause schedule: re-entered unsafely. Perhaps a 'foreign import unsafe' should be 'safe'?, is it?  I can't see any foreign import unsafes around :/
11:05:31 <Cale> {-# INLINE getElems #-}
11:05:31 <Cale> -- | Return a list of all the elements of a mutable array
11:05:31 <Cale> getElems :: (MArray a e m, Ix i) => a i e -> m [e]
11:05:31 <Cale> getElems marr = do
11:05:31 <Cale>   (l,u) <- getBounds marr
11:05:32 <Cale>   n <- getNumElements marr
11:05:34 <Cale>   sequence [unsafeRead marr i | i <- [0 .. n - 1]]
11:05:39 <roconnor> dancor: http://hackage.haskell.org/packages/archive/HTTP/3001.0.4/doc/html/Network-HTTP.html#v%3AsimpleHTTP
11:05:40 <lambdabot> http://tinyurl.com/2pnrz8
11:05:58 <lament> can i somehow see the list of all instances of a typeclass (say, of Foldable)?
11:06:00 <opqdonut> Cale: ok, not
11:06:09 <roconnor> lambdabot: you should add the fragment identifier to the end of your tinyurl.
11:06:10 <opqdonut> Array might
11:06:11 <lament> hoogle doesn't do it
11:06:37 <roconnor> lambdabot: are you listening to me?
11:06:41 <Cale> lament: :info will tell you
11:06:55 <Cale> lament: But it'll only mention the instances which are in scope.
11:07:33 <Cale> There's no instance of Foldable for MArray
11:07:41 <Cale> You'll have to convert to an Array first.
11:08:22 <bd_> lament: :i <typeclass> in ghci. It'll only show imported ones.
11:08:51 <Toxaris> what's the reason for the getBounds call in that code?
11:09:05 <lament> hm, weird, ghci says Foldable (Array i) is defined in Data.Foldable, but the docs don't mention that at all
11:09:42 <sethk> what are the options to tell ghc to build a static executable?
11:09:51 <lament> there's no such definition in the source on haskell.org/ghc/docs/latest...
11:10:35 <sethk> I find -static in the docs but it doesn't seem to work in 6.8.2
11:11:14 <bd_> lament: Implementation detail, perhaps?
11:11:37 <Cale> :info says it's defined in Data.Array here
11:11:42 <dancor> roconnor: tx
11:11:54 <bd_> lament: It could've moved too. It's best not to rely on the location it might give too much... it can move as long as the documented locations indirectly pull it in
11:12:05 <CosmicRay> @hoogle Element
11:12:05 <lambdabot> Control.Exception.UndefinedElement :: String -> ArrayException
11:12:10 <Cale> instance Ix i => Foldable (Array i) where
11:12:10 <Cale>     foldr f z = Prelude.foldr f z . elems
11:12:13 <lament> oh, i know, i have 6.6.1.
11:12:19 <sethk> @hoogle static
11:12:19 <lambdabot> No matches found
11:12:24 <lament> nevermind. :)
11:12:25 <Cale> As you can see, there's no point in trying to avoid lists.
11:12:45 <lament> okay.
11:12:50 <Cale> Lists are our loops.
11:13:00 <lament> right.
11:13:05 <ivan__> is it possible to exit a do statement in haskell, like if i have several do statements i want to exit all of them
11:13:17 <Cale> ivan__: "exit"?
11:13:30 <ivan__> yes like return in c
11:13:34 <lament> Cale: so i can expect, if not now then at least in the future, similar performance to a for loop over the elements?
11:13:35 <cjb> oh, you can have several do statements?  nested?
11:13:37 <Cale> Which monad?
11:13:44 <sethk> ivan__, a return from within a do, regardless of whether it is a nested do, does what you want
11:13:46 <Cale> lament: yeah
11:13:48 <cjb> "return" is the way to exit just one, of course
11:13:56 <cjb> oh, interesting.
11:14:00 <Cale> return doesn't have any control properties
11:14:16 <sethk> Cale, well, it terminates a function call
11:14:22 <bd_> sethk: no :)
11:14:22 <Cale> No it does not.
11:14:24 <roconnor> guard an be used to ``exit'' do statements in some monads.
11:14:28 <zygen> It's like yield
11:14:31 <Toxaris> cjb, sethk, ...: "return" is *not* about exiting anything
11:14:32 <sethk> Cale, why?
11:14:35 <bd_> do { return 42; return 24; } -- equivalent to do { return 24; }
11:14:36 <MyCatVerbs> @src guard
11:14:36 <lambdabot> guard True  =  return ()
11:14:36 <lambdabot> guard False =  mzero
11:14:42 <Cale> return constructs an action which does nothing and returns that value
11:15:01 <Cale> So, in the middle of a do-block, return is a no-op.
11:15:02 <sethk> Cale, I can say:   if whatever then return () else ....
11:15:09 <Cale> Yes, you can.
11:15:10 <gio123> somebody can tell me how to instal  HaXml 1.13.x
11:15:18 <ivan__> i have this do s <- func; if s == something then return () else something ; k <- other function,   in my case the k is evaluated regardless  the return
11:15:19 <bd_> sethk: Sure, but that's not control. That's just setting the final value of the then.
11:15:26 <Cale> But if you put another line after the if, it will be carried out.
11:15:36 <bd_> sethk: If you did: if whatever then do { return (); doSomething } else ....
11:15:36 <sethk> bd_, Cale I see what you mean.
11:15:38 <bd_> then doSomething would be called
11:15:39 <gio123> this haskell library
11:15:41 <cjb> ivan__: and it sounds like you're being told that's intentional.  how about having:
11:15:46 <cjb> guard s == something
11:15:51 <cjb> since it sounds like that's what you intend anyway.
11:15:56 <Toxaris> sethk: do {if True then return 1 else return 2; return 3} is equivalent to return 3
11:16:02 <gio123> somebody can tell me how to instal haskell library   HaXml 1.13.x
11:16:10 <sethk> Toxaris, yes, I get it now.  :)
11:16:12 <roconnor> guard (s == something)
11:16:15 <ivan__> ahaa guard sounds nice =) will look it up
11:16:23 <sethk> static linking, anyone?  I know it's possible but I can't find the flags.
11:16:26 <Cale> ivan__: You could, for example, use the ContT monad transformer to get such effects, but it's usually infinitely more sensible just to break things up such that you don't have to do sophisticated control like that.
11:16:30 <bd_> ivan__: note that guard only works in MonadPlus
11:16:31 <roconnor> do {guard (s == something); k <- other function}
11:16:45 <bd_> :t guard
11:16:46 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:16:49 <sethk> maybe I use the flag to set linker options?
11:16:53 <cjb> > do { a <- [1,3,5]; guard (a != 1); return }
11:16:53 <lambdabot>   Not in scope: `!='
11:16:57 <MyCatVerbs> gio123: first download it from Hackage, there's a tarball here: http://hackage.haskell.org/packages/archive/HaXml/1.19.2/HaXml-1.19.2.tar.gz
11:16:58 <lambdabot> http://tinyurl.com/2xzd33
11:16:59 <Cale> ivan__: return () is a no-op
11:17:03 <faxathisia> :t (\=)
11:17:04 <lambdabot> Not in scope: `\='
11:17:08 <cjb> > do { a <- [1,3,5]; guard (a /= 1; return }
11:17:08 <lambdabot> Unbalanced parentheses
11:17:08 <faxathisia> :t (/=)
11:17:09 <lambdabot> forall a. (Eq a) => a -> a -> Bool
11:17:11 <bd_> > do { a <- [1,2,3]; guard (1 /= 1 ); return a }
11:17:12 <lambdabot>  []
11:17:14 <Cale> ivan__: It literally is the action which does nothing, and returns ()
11:17:20 <bd_> > do { a <- [1,2,3]; guard (a /= 1); return a }
11:17:21 <lambdabot>  [2,3]
11:17:22 <MyCatVerbs> gio123: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HaXml-1.19.2 is the main Hackage page for the HaXML package, by the way.
11:17:23 <lambdabot> http://tinyurl.com/2f53ao
11:17:27 <largos> what do people suggest for simple parsing in haskell?
11:17:35 <Cale> ivan__: so in the middle of a do-block, it can always be removed
11:17:36 <faxathisia> largos: Parsec
11:17:44 <cjb> bd_: thank you
11:17:45 <Toxaris> largos: parsec, just as for advanced parsing. it scales.
11:17:48 <cjb> ivan__: anyway, that's what guard does :)
11:17:58 <largos> faxathisia: ah, thanks! I couldn't remember the name :)
11:18:03 <MyCatVerbs> gio123: then you will need to unpack it with some program. If you don't have a program that can open .tar.gz files, try 7-zip.
11:18:03 <ivan__> Cale: cjb  thx
11:18:15 <gio123> MyCatVerbs: I downloaded http://hackage.haskell.org/packages/archive/HaXml/1.19.2/HaXml-1.19.2.tar.gz
11:18:16 <lambdabot> http://tinyurl.com/2xzd33
11:18:41 <gio123> MyCatVerbs: I am using windows, i have winrara
11:19:03 <byorgey> woohoo!  hehe, I've never been so excited about proving the associativity of addition before =)
11:19:05 <gio123> MyCatVerbs: I extracted it
11:19:11 <MyCatVerbs> gio123: good. Then you will need to open up a shell in the directory where you unpacked the tarball.
11:19:55 <MyCatVerbs> gio123: and then do the following: runhaskell Setup configure --user
11:20:00 <gio123> MyCatVerbs: where should i loceted this unpacked directory?
11:20:18 <MyCatVerbs> gio123: it doesn't matter very much where you put it.
11:20:47 <MyCatVerbs> In your home directory or "My Documents" or wherever. You just need to have a shell open in the HaXML directory.
11:20:58 <gio123> MyCatVerbs: open shell u meant to open from haskell shell?
11:21:19 <ivan__> Cale: in what lib is the guard?
11:21:21 <MyCatVerbs> gio123: ah, do you have Cywin or MSYS installed?
11:21:39 <gio123> cygwin
11:21:54 <ivan__> Cale: Control.Monad i found it =)
11:22:15 <MyCatVerbs> gio123: great. Use Cygwin's terminal then.
11:22:22 <faxathisia> haha
11:22:41 <faxathisia> It's really cool
11:23:21 <MyCatVerbs> gio123: so now go into the directory where you unpacked HaXML to and do: runhaskell Setup configure --user
11:23:54 <gio123> MyCatVerbs: wait bit please i am trying to undestand ceygwibn syntax :)
11:24:12 <MyCatVerbs> No worries, comrade. ^_^
11:26:59 <Lemmih> One space leak down, N-1 to go.
11:27:47 <Heffalump> where N>=2 ?
11:28:09 <ivan__> Cale: i dont think the guard solved the problem, this is my problem i want to x <- getLine and do that until x is a specific char? how can i make that happen'?
11:28:22 <Cale> ivan__: recursion
11:28:40 <Cale> You probably mean "until x is a specific string"
11:29:08 <Toxaris> ivan__: foo = do {x <- getLine; if x == "end" then return () else foo}
11:29:40 <Cale> getLinesUntil x = do v <- getLine; if v == x then return [] else do vs <- getLinesUntil x; return (v:vs)
11:30:26 <sfultong> when writing a threaded gtk app, I have to use gtk2hs's threading functions, right?
11:31:21 <cjb> sfultong: yes; the GTK main loop will not interact well with another thread library, I think.
11:31:34 <cjb> (this isn't specific to Haskell; it would be the same for anything)
11:31:38 <sfultong> cjb: yeah, I kinda found that out the hard way
11:32:51 <Zao> I thought that gtk2hs refused to run if you tried to use the -threaded RTS?
11:33:32 <monochrom> Used to. Not sure now. Things keep changing.
11:33:54 <iank> Hey all.  How would I go about printing a list as, say one element on each line, instead of [1,2,3], etc?  I'm trying to feed data to gnuplot (and using perl to clean up the haskell list seems silly :)
11:33:57 <sfultong> well, I just tried compiling something with -threaded, and it complained
11:34:12 <monochrom> mapM_ print [1,2,3]
11:34:45 <iank> monochrom: ooh, thanks.  (I had tried map print, but obviously that didn't work out ;)
11:35:38 <Toxaris> iank: mapM_ op xs = sequence (map op xs) >> return ()
11:35:41 <MyCatVerbs> iank: you could do (foldr (>>) . map print) ;)
11:35:55 <dolio> @remember qwe1234 For the majority of tasks, C++ templates produce code that is clearer and better type-checked [than Haskell].
11:35:55 <lambdabot> Done.
11:36:06 <lament> <3 qwe1234
11:36:07 <Toxaris> iank: so you were halfway there
11:36:11 <MyCatVerbs> dolio: oh man. Did he actually say that!?
11:36:23 <dolio> He did.
11:36:33 <gnuvince> Link?
11:36:42 <MyCatVerbs> dolio: no wai. He -cannot- be sincere. Gotta be a troll now.
11:37:07 <dolio> http://reddit.com/info/69jbs/comments/c039ljd
11:37:12 <Baughn> dolio: Not in my log... bwah
11:37:32 <Baughn> Well, no fair commenting on haskell outside of #haskell!
11:38:06 <monochrom> I'm thinking of registering a domain like "the_land_of_trolls.com".  Then I set it up to redirect to reddit.com. :)
11:39:56 <faxathisia> why use haskell over say, C++ templates?
11:39:59 <mrd> sfultong: you have to use GTK from the main thread only
11:40:04 <largos> could someone suggest a good parsec tutorial?  (should I start with the Leijen / Meijer paper?)
11:40:16 <mrd> largos: the parsec documentation is pretty good
11:40:18 <mrd> @where parsec
11:40:18 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
11:40:20 <Baughn> faxathisia: Please.. stop. I'm about to bust a gut.
11:40:37 <Baughn> largos: For the most part, experimentation will do fine
11:40:41 <largos> mrd: thanks! I hadn't found that yet
11:40:51 <monochrom> why use programming languages over say, slaves?
11:41:00 <Baughn> Slaves are expensive
11:41:09 <largos> Baughn: I still need to bootstrap my experiments :) the parsec docs should do that
11:41:21 <mrd> why use slaves over say, grad students?
11:41:25 <monochrom> why use IRC over say, a Florida vacation? :)
11:41:27 <Baughn> largos: Indeed, and explain the evaluation order too. :)
11:42:36 <hpaste>  faxathisia pasted "typing rules" at http://hpaste.org/5953
11:42:41 <Baughn> mrd: Your question makes no sense
11:42:47 <faxathisia> Just because it looks cool :)
11:43:22 <dolio> Baughn: Grad students solve the "expensive" complaint about slaves.
11:43:38 <dolio> They pay *you* to be slaves.
11:43:41 <faxathisia> lol
11:43:55 <Baughn> dolio: You have to become a professor first, though. Education is expensive.
11:44:17 <dolio> Yeah, yeah. :)
11:44:40 <dancor> does Text.XHtml parse html?  does anything
11:44:46 <Baughn> Overall, I'm not sure that slaves aren't cheaper - I hear chinese sweatshops are turning them out at $5k/kg, but of course grad students provide their own room and board
11:44:52 <shepheb> monochrom: "trollmuseum.com"
11:45:45 <oerjan> trolloseum
11:46:00 <dancor> ah found tagsoup
11:46:19 <monochrom> faxathisia: did you know of  ?
11:47:06 <faxathisia> yes but it doesn't fit in a single character space here
11:47:13 <shepheb> oerjan: I like it. sounds like collosseum, and the more trolls fight to the death, the better.
11:47:49 <mrsolo> hmm is wxhaskell...dead?
11:47:50 <oerjan> that was the idea.
11:48:03 <mrsolo> latest version is may 3 2005...
11:48:12 <monochrom>  is not single character?
11:48:31 <faxathisia> It is about 1.2 chars wide in my editor
11:49:19 <monochrom> It will be 1 unit wide on hpaste, which uses fixed width.
11:49:55 <monochrom> I bet ":" and "1" aren't 1 unit wide in your editor either. I don't understand the logic.
11:51:06 <faxathisia> monochrom: http://img179.imageshack.us/img179/1529/picture1tu0.png
11:51:28 <Baughn> Has anyone succeeded in compiling leksah on OS X?
11:51:48 <monochrom> Well, |- is 2 units wide...
11:51:57 <faxathisia> yes but that's a multiple of 1
11:52:04 <faxathisia> 1.2 or whatever it is, isn't
11:52:32 <MyCatVerbs> mrd: actually that is a good question.
11:52:43 <MyCatVerbs> mrd: why would anyone used slaves instead of grad students?
11:52:49 <monochrom> I know this is a silly dispute.  But you should use hpaste rather than your editor as the standard.
11:53:07 <faxathisia> but.. I edit with my editor..
11:53:19 <monochrom> but.. you post it on hpaste :)
11:53:27 <jonafan> i need someone to tell me that i'm dumb because I think unit testing is overrated
11:53:33 <faxathisia> yes I posted something that works on both
11:53:54 <faxathisia> jonafan: What do you propose instead?
11:54:05 <monochrom> I think it is a failure because |- takes 2 units instead of 1.  <duck>
11:54:10 <jonafan> i just don't see it as being that helpful
11:54:21 <MyCatVerbs> jonafan: unit testing has the benefit that you can change things around confidently with (almost) no risk of breaking them.
11:54:25 <jonafan> i'm only going to write tests for stuff i know that i need to test for
11:54:33 <monochrom> Everything is overrated.
11:54:48 <Baughn> jonafan: Unit tests are to some degree a reaction to the lack of static typing, it's true
11:54:48 <dolio> faxathisia: You could use Vim. That seems to slice off the right side of unicode characters that don't fit in monospaced. :)
11:54:53 <Baughn> But only to /some/ degree
11:55:05 <MyCatVerbs> jonafan: effectively it does for your program's semantics exactly what type checking does for your program's well-typed-ness.
11:55:06 <faxathisia> I don't have a GUI vim
11:55:23 <jonafan> hmm
11:55:33 <MyCatVerbs> jonafan: I mean, same sort of magnitude. Not good enough to compete with an actual correctness proof, but still much much better than nothing at all.
11:55:44 <Baughn> jonafan: If you're a true haskell hacker, you'll get the type system to do your unit tests for you
11:55:55 <faxathisia> type checking is an actual correctness proof though
11:56:05 <monochrom> Or rather, nothing is overrated.  Instead, people overrate things.
11:56:11 <jonafan> i'm not a true haskell hacker yet
11:56:12 <Baughn> Not if you implement a unit tester in the type system. ;)
11:56:20 <monochrom> Unit testing isn't overrated.  Some people overrate unit testing.
11:56:24 <MyCatVerbs> jonafan: amongst other things, it means you can happily change the algorithms underlying particular functions, with most mistakes being caught automatically rather than having to manually test various cases.
11:56:31 <monochrom> Haskell isn't overrated.  Some people overrate Haskell.
11:56:40 <monochrom> Blame humans, not artefacts.
11:56:40 <jonafan> man, i got something started here... i just wanted someone to tell me i'm dumb
11:56:49 <MyCatVerbs> jonafan: oh, right.
11:56:58 <MyCatVerbs> jonafan: YOU ARE INCAPABLE OF SPEECH, HAHAHAHA!
11:57:03 <jonafan> haha
11:57:04 * MyCatVerbs slaps jonafan with a pancake.
11:57:06 <MyCatVerbs> Happy now?
11:57:14 <monochrom> Yeah, you are dumb, you have the wrong focus.
11:57:19 <Baughn> monochrom: Humans are the only ones who go around rating things, though. They're overrated if most humans overrate them..
11:57:21 * faxathisia is reminded pancakes exist.. 
11:57:30 <dino-> Type system or no, let's suppose you have thousands of tests for a large application. Without unit tests how do you make changes and regression test that it's at least as capable as it was before you changed things?
11:57:34 <dino-> manually?
11:57:50 <jonafan> hmmmmmm
11:57:55 <faxathisia> dino-: You could have correctness proofs in your code :P
11:57:56 <jonafan> gut feeling
11:58:06 <faxathisia> dino-: which are machine checked
11:58:06 <monochrom> Baughn: I am not sure whether or why there is any significance attached to "most humans".
11:58:07 <jonafan> alright, unit testing might be useful
11:58:20 <Baughn> jonafan: One of the great advantages of haskell is that it encourages separating I/O from logic - so the logic can easily be tested, and the I/O is too small to be very bug-prone
11:58:33 <Baughn> monochrom: I just attached some.
11:58:48 <dino-> And what jonafan said earlier, only testing for things you think of, QuickCheck can help with that perhaps.
11:59:40 <Baughn> Well, it's handy for dealing with regressions. It's even handier with multiple people working on a codebase.
11:59:41 <roconnor> unit testing can be use to prove Delta_0 properties.
11:59:51 <gio123> MyCatVerbs: so, now could u tell me please how to install?
12:00:05 <Baughn> jonafan: Since you think otherwise.. just checking, have you ever worked on a project with more than one or two other developers?
12:00:05 <roconnor> quickcheck can be used to vaguely test (not prove) Pi_1 properties.
12:00:05 <faxathisia> What's that?
12:00:13 <roconnor> dependent types an be used to prove all properties.
12:00:18 <dino-> Baughn: We have exactly that happening now at my job. People breaking things like mad.
12:00:22 <roconnor> (well, at least the provable ones).
12:00:26 <Baughn> roconnor: Some properties are unprovable
12:00:28 <faxathisia> what is this Delta_0 Pi_1 stuff?
12:00:29 <dino-> I have unit tests run every 30 minutes with email alerts.
12:00:37 <dino-> So we can get on top of them quickly.
12:00:42 <faxathisia> Baughn, better not rely on those then..
12:00:58 * monochrom wonders what properties are unprovable.
12:01:18 <faxathisia> this program terminates for sufficiently complex program..
12:01:21 <Baughn> dino-: If I had the time, I'd write a test system that figured out which code paths are exercised by which tests (empirically), then ran only those tests, automatically, at check-in
12:01:33 <Baughn> monochrom: *All* of them, in general
12:01:34 <dino-> faxathisia: Don't I wish I had correctness anythings or even a type system at all. I work in Perl for a living.
12:01:55 <Baughn> monochrom: There isn't a single property you want to check that I can't write a program that'll break your checker
12:02:03 <faxathisia> so stop using perl ..
12:02:14 <Baughn> monochrom: Which is why some valid programs are rejected by haskell's type checker. ;)
12:02:26 <roconnor> faxathisia: http://en.wikipedia.org/wiki/Arithmetical_hierarchy#The_arithmetical_hierarchy_of_formulas
12:02:26 <lambdabot> http://tinyurl.com/yc7cgk
12:02:50 <monochrom> Sorry, your statement uses double negation, and I can't quite read it.  Could you re-state with fewer negations?
12:03:07 <Baughn> monochrom: It's also grammatically incorrect.
12:03:29 <quicksilver> For every property that monochrom wants to check, and writes a checker for, Baughn can write a program which breaks the checker.
12:03:30 <wli> "There isn't a single property you want to check for which I can't write a program that'll break your checker."
12:03:31 <Baughn> monochrom: OKay.. there are no properties you want to check such that I can't write a program that will break your checker
12:03:36 * quicksilver is a parsing service.
12:03:57 <quicksilver> pronoun substitution is free this week, but normally a premium rate service
12:04:12 <dancor> is there a difference/preference between  let .. in do ..  vs  do let ..; ..
12:04:26 <Baughn> quicksilver's most correct, too. The proof for that requires having a copy of the checker already, so..
12:04:28 <oerjan> dancor: no
12:04:29 <EvilTerran> if i'm already in a do block, i'll use do let
12:04:37 <dancor> word
12:04:45 <oerjan> the second is syntactic sugar for the first
12:04:46 <EvilTerran> i try to avoid let/in, tbh. it's hard to indent nicely
12:04:54 <Cale> hm?
12:04:55 <faxathisia> let ...
12:04:57 <faxathisia>  in ...
12:04:59 <faxathisia> seems fine to me
12:05:01 <dancor> hah, recently someone else was saying they hate where
12:05:01 <Cale> You just align the let and in
12:05:05 <faxathisia> what do other people do?
12:05:16 <EvilTerran> i generally left-align the let and in one above t'other
12:05:20 * dancor is a die-hard 2-space indenter
12:05:33 <EvilTerran> which is fine, but i think other syntaxes usually look better
12:05:34 <dancor> oh yeah i do align them
12:05:48 <Cale> I don't care how much things are indented, so long as they line up correctly.
12:06:17 <EvilTerran> or otherwise i do "let ... in\n\t...", if there's only one line in the decleration block
12:06:19 <Cale> I usually prefer to have the keyword introducing a block on the same line as the first line of the block, as well.
12:06:56 <EvilTerran> but generally i find a way to use where or something instead
12:07:06 <dancor> unlines $ map (replicate 10000 ' ' ++) ["let", "in"]
12:07:10 <EvilTerran> a helper function, maybe
12:07:39 * wli notes 2 spaces aren't visually significant and worse yet, encourage excessive nesting. Write with 8 space tabstops, 80 columns, and 24 lines. So long as you're just reading, no need for such discipline.
12:07:42 * EvilTerran does 4-space indents, mostly
12:07:46 <EvilTerran> no tabs
12:07:53 <monochrom> Well, ok, given a property, you can write a new program to violate it.  But we are not talking about naughty defiance.  We are talking about conformance.  We are talking about a property and trying to write a program to satisfy it.
12:08:14 * dancor is still an excessive-nester noob but will certainly think long and hard about life now
12:08:24 * wli doesn't care to accommodate Windows conventions.
12:09:07 <monochrom> If you have reasons to believe that the program satisfies the property, then that satisfaction should be provable.  Proof: you have reasons to believe it, so use those reasons as proof.
12:09:31 <Cale> Tab characters should not be permitted in source files.
12:10:06 <Cale> I honestly think they should be considered a lexical error anywhere except inside a comment.
12:10:35 <sethk> Cale, I disagree, although not necessarily for haskell.  I'm addicted to expanding/contracting my indentation by setting the tab size.
12:10:36 <dino-> Or string literal. I can agree with that.
12:10:54 <monochrom> Haskell 98's type system cannot do that proof.  But someone mentioned dependent typing, which can.
12:10:57 <dancor> i used to be a tabite but now a spacer
12:11:08 * wli remains a stodgy old UNIX curmudgeon and sticks to real tab characters.
12:11:32 <Cale> sethk: The problem is that's not a reliable way to do things with significant whitespace, and even when whitespace is insignificant, tends to create alignment problems.
12:11:33 <dino-> Is there a haskelltidy?
12:11:40 <dancor> everyone should have a personal rewriter
12:11:42 <Riastradh> Tabs are defensible for the purposes of indentation, but utterly insensible for alignment.
12:11:58 <sethk> Cale, the significant whitespace part I agree with.  The editors I use don't have a problem with alignment
12:12:23 <Riastradh> In functional languages, alignment of nested constructs is much more common than indentation of blocks, by contrast with, say, C.
12:12:47 <Cale> sethk: If you have almost any mixture of tabs and spaces on a line, it will create problems when you resize the tabs.
12:12:49 <sethk> unless you use explicit grouping instead of indentation
12:12:51 <dancor> in conclusion, i shall use do let ..; ..
12:12:55 <sethk> Cale, oh, yes, that's true
12:13:13 <sethk> Cale, but my rule is:  no spaces before the first non-space character, no tabs after the first non-space character
12:13:27 <sethk> first non-space non-tab, obviously
12:13:31 <EvilTerran> that's pretty much what i do when i'm using tabs, too
12:13:46 <Baughn> Cale: How many spaces does ghc assume a tab is equivalent to?
12:13:51 <wli> Cale: They're perfectly reliable. 8 columns per-tab is the standard. sethk's rule also applies.
12:14:04 <Cale> Baughn: It assumes that it aligns to the nearest 8-space boundary.
12:14:26 <Baughn> ..I'll stick to spaces.
12:14:27 <Cale> wli: It will *work*, but it's really unnecessary.
12:14:37 <blargeyfarg> tabs for block indents, spaces for non-block alignment.  always viewable in any editor out there
12:14:45 <Cale> wli: If you consistently use 8-space tabs, the only thing you gain is a small amount of file compression.
12:15:17 <Cale> wli: If you don't consistently use 8-space tabs, you gain lots of problems with alignment.
12:15:25 <Cale> So it's just not worthwhile.
12:16:34 <wli> Cale: No, the spaces are unnecessary. And the compression matters (e.g. the Linux kernel has issues with its growing size vs. downloading bandwidth and file processing speed of revision control systems due to spaces being used instead of tabs).
12:16:39 * osfameron has never seen 8-space tabs
12:17:10 <quicksilver> I'm sorry, but that's bollocks, wli.
12:17:11 <dancor> bzip is fine for linux kernel issue
12:17:12 <sethk> osfameron, in vi,  set tw=8
12:17:17 <Cale> That's total nonsense :)
12:17:19 <EvilTerran> this is what -blah is for, guys
12:17:28 <dancor> tabs are cool if you want to "support" user-set indent
12:17:29 <quicksilver> There is no real life situation where anybody cares about the disk space occupied by 8 spaces as opposed to 1 tab is an issue.
12:17:35 <hpaste>  dons pasted "Word/Int bad codegen" at http://hpaste.org/5954
12:17:35 <wli> Cale: Non-8-column tabstops are nonstandard. Anyone who plays with those gets what they deserve.
12:17:44 <quicksilver> (There are other reasons you might make that decision. But not that one)
12:17:48 <dons> dcoutts: check http://hpaste.org/5954
12:18:01 <dons> dcoutts: silly extra comparisons generated for Word types
12:18:14 <Riastradh> wli, so why use tabs at all?  Network bandwidth and disk space are non-issues; it's 2008, and we're not working with 1 MB file systems any longer.
12:18:18 <wli> quicksilver: Not disk space. Network bandwidth and the time required by revision control programs to process checksums/etc.
12:18:26 <dons> JaffaCake: could you take a look at http://hpaste.org/5954 -- looks like Word values get two comparisons needlessly
12:18:47 <wli> Riastradh: Network bandwidth is still very much an issue.
12:19:04 <flux> doesn't git use compression?
12:19:26 <flux> any compression algorithm would compress sequences of whitespace away
12:19:34 <Riastradh> wli, statistics, please.
12:20:01 * EvilTerran does the happy #haskell-blah dance
12:20:08 <wli> flux: Doesn't help when you're comparing contents for corruption etc.
12:20:23 <flux> wli, and how does that affect network bandwidth?
12:20:26 <Cale> Unless it increases the size of the source code by more than about maybe 50MB, I'm not inclined to care.
12:20:28 <wli> flux: Especially of unpacked and checked-out repositories.
12:20:53 <sethk> Cale, since the whole thing is less than 50 mb, that's unlikely.  :)
12:21:03 <Cale> sethk: Indeed.
12:21:12 * dancor needs to keep algorithmic questions on hand to disrupt holy wars
12:21:23 <EvilTerran> so... 'bout that associativity of $
12:21:36 * byorgey does the happy Agda dance
12:21:36 <wli> flux: The network bandwidth is a separate issue. The growing size of the source tarballs increases the network bandwidth consumed by numerous people downloading it.
12:21:40 <sethk> not a holy war, just a difference of opinion that will _never_ go away.  It's not an important one, though, it's asthetic
12:21:55 <Cale> EvilTerran: Everyone agrees with me that it should be left associative already. :)
12:22:02 <dancor> it's also more easy to convert among than some other style differences
12:22:31 <EvilTerran> :fixtabs
12:22:32 <Excedrin> it will go away eventually, when coding is done without textual syntax
12:22:35 <EvilTerran> er, :retab
12:22:41 * wli hammers out a tabification character filter.
12:22:41 <monochrom> http://groups.google.com/group/comp.lang.haskell/browse_frm/thread/e2aa728d9e42f981  is a cautionary tale about tabs.
12:22:42 <lambdabot> Title: comp.lang.haskell | Google Groups, http://tinyurl.com/2nt8er
12:23:08 <Excedrin> TABS WILL...
12:23:10 <dancor> in fact if the git change-on-accept thing happens, it could be made transparent
12:23:29 <dancor> not sure if darcs has or will have such a feature
12:24:06 <monochrom> Excedrin reminds me...
12:24:22 <flux> I executed sed 's/^[ \t]*//' to linux kernel source
12:24:26 <monochrom> Will Programming Be Liberated From The Plain Text File?
12:24:43 <flux> it reduced the uncompressed size from 435M down to 423M
12:24:51 <flux> really insignificant in my opinion
12:25:06 <flux> (bz2-test is still in progress..)
12:25:28 <wli> They dorked around with nonstandard tabstops and discovered that violating standards breaks compatibility. No big surprise.
12:25:34 <Deewiant> ah, but try sed 's/\t/        /g'
12:25:53 <flux> deewiant, good point!
12:25:57 <EvilTerran> Excedrin, ... devour your soul?
12:26:02 <flux> I should run expand to the real kernel
12:26:30 <Cale> Tabs don't always mean 8 spaces though.
12:26:42 <flux> hence, "expand"
12:26:48 <EvilTerran> $ man expand
12:26:51 <dino-> Hm. I'm not seeing anything like tidy for Haskell.
12:27:01 * EvilTerran wonders if that's safe to google...
12:27:11 <Excedrin> EvilTerran: probably belongs in #haskell-blah, but basically there's this "show" called Cautionary Tales of Swords on channel101
12:27:13 <Deewiant> In the kernel they're interpreted as 8 spaces for purposes of keeping lines at 78 (or 80?) columns, IIRC.
12:27:16 <dino-> You guys are making me real nervous that I'll need a tool like that sooner or later. :D
12:27:26 <Gilly> hmm... i have a 800x800 array, doing putStrLn (show (assocs arr)) takes first a second or so and then prints the thing, does assocs take a lot of time?
12:27:31 <Deewiant> I use tabs for everything but haskell
12:27:37 <Excedrin> EvilTerran: the "cautionary tale about tabs" reminded me...
12:27:40 <wli> Cale: I suppose the character '\t' could represent some radix 256 digit, I suppose.
12:27:41 <Cale> Gilly: what type of array?
12:27:45 <Deewiant> Haskell needs so much precise alignment that tabs don't really work
12:27:49 <Gilly> Cale: ((Int,Int),Bool)
12:27:53 <EvilTerran> Gilly, it might be buffering, too
12:27:54 <desegnis> Deewiant, the sed expression will break if there are characters preceding the tab
12:28:00 <wli> I use tabs in Haskell and have no trouble with alignment whatsoever.
12:28:01 <EvilTerran> are you printing in one line?
12:28:04 <Gilly> yes
12:28:19 <Cale> Gilly: I mean, is it an Array, or a UArray, or what?
12:28:19 <Deewiant> desegnis: how will it break?
12:28:21 <shepheb> dino-: a good editor mode will alleviate the problem anyway, they align automatically.
12:28:21 <Gilly> Array
12:28:24 <EvilTerran> shove some line-breaks in, see what happens
12:28:42 <dmwit> EvilTerran: You are looking for man pages? linux.die.net/man
12:28:42 <Cale> Gilly: Likely what's happening is that the evaluation of the elements of the array is being forced.
12:28:42 <EvilTerran> :t assocs
12:28:42 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
12:29:02 <Gilly> Cale: ah
12:29:05 <EvilTerran> Gilly, see what happens when you do "mapM_ print (assocs arr)"
12:29:13 <EvilTerran> dmwit, ta
12:29:20 <desegnis> Deewiant: consider the line "bla     blub    foobar", and imagine there are tabs where I put spaces
12:29:37 <EvilTerran> desegnis, but does *anyone* actually do that?
12:29:48 <Deewiant> desegnis: how is that a problem?
12:29:51 <Gilly> the same waiting before printing and then it comes out
12:29:58 <Gilly> though slower because of the line ends
12:29:59 <desegnis> EvilTerran, well one _might_ do that
12:30:00 <Deewiant> the tabs get replaced by 8 spaces as expected?
12:30:05 <EvilTerran> Gilly, okay, definitely evaluation rather than buffering, then
12:30:13 <EvilTerran> Deewiant, but they shouldn't get replaced by 8 spaces
12:30:20 <desegnis> Deewiant, but then you get "bla        blub        foobar", which is different
12:30:33 <EvilTerran> in "foo\t" at the start of a line, you should get "foo     ", not "foo        "
12:30:36 <Deewiant> oh, you mean tabs in string literals?
12:30:37 <Gilly> uff... i wonder what's so expensive in my evaluation :)
12:30:50 <EvilTerran> Deewiant, no! just... tabs after a non-tab
12:30:54 <Gilly> well i gotta test it with some other arrays of that size
12:31:00 <Deewiant> EvilTerran: I very much intended to replace such tabs as well :-P
12:31:03 <EvilTerran> they align with the next multiple of 8 characters
12:31:03 * osfameron wonders why 8-tabs is "standard" but 4-tabs is most often seen in the wild...
12:31:13 <EvilTerran> as compared to inserting 8 spaces
12:31:37 <blargeyfarg> rule number 1 about tabs: never EVER use them for ANYTHING except indenting a uniform block from the left edge, and you'll never have a problem, even in Haskell
12:31:38 <desegnis> Deewiant: Tabs refer to the columns [0,7...] of a line, if used that way
12:31:51 <desegnis> er
12:31:54 <Deewiant> desegnis: and they should never be used that way, as blargeyfarg said ;-)
12:31:58 <lament> 8 tab style makes sense for C
12:32:04 <EvilTerran> and i've never seen them used that way, either
12:32:05 <desegnis> [0,8...], rather :)
12:32:12 <Deewiant> I use 3-width tabs
12:32:18 <Deewiant> EvilTerran: I have, unfortunately
12:32:24 * EvilTerran used three-width for a while, but now i use four-width
12:32:27 <monochrom> I use ROT13 to write my C programs.
12:32:29 <desegnis> Deewiant, yea it's ugly to use them that way
12:32:32 <EvilTerran> Deewiant, :retab is your friend :)
12:32:45 <Deewiant> EvilTerran: :retab messes stuff up and badly
12:32:50 <wli> osfameron: IIRC 8-column tabstops go back to elder media such as teletypes and typewriters.
12:33:00 <Cale> blargeyfarg: Except that in Haskell, you never really want to do that.
12:33:03 <lament> remember, tabs were not invented for programming languages :)
12:33:06 <EvilTerran> hm? you have to set the settings so it looks right, *then* do :retab
12:33:06 <Deewiant> EvilTerran: consider "main = do\n\tlet a = foo\n\t    b = bar"
12:33:29 <EvilTerran> (with the right other settings set right so it comes out correctly when you put the settings back)
12:33:34 <Deewiant> EvilTerran: running retab on that will replace the spaces prior to b with tabs (assuming a tab width <= 4)
12:33:46 <Deewiant> EvilTerran: which, in turn, causes any haskell compiler to barf.
12:33:52 <EvilTerran> oh, i see. i've set expandtabs in my .vimrc
12:33:57 <mauke> Deewiant: so set expandtab
12:34:01 <blargeyfarg> cale: depends on your style.  when sticking exactly to the preferred layout mode, no.  you're right.  but you can very easily write haskell as normally indenteded code blocks
12:34:04 <Saizan> Gilly: you should try compiling with optimizations enabled if you want to test performance
12:34:05 <Deewiant> I don't want to set expandtab if I want to use tabs.
12:34:12 <Deewiant> how can I use tabs with expandtab on?
12:34:23 <EvilTerran> and whenever i load a file with tabs that doesn't have to stay that way, i set the settings so it looks right then :retab to get rid of the tabs
12:34:25 <blargeyfarg> s/indenteded/indented/
12:34:27 <wli> Deewiant: I wonder if :set tw=8 before :retab DTRT.
12:34:28 <Cale> blargeyfarg: If you want it to look really ugly, then yes.
12:34:31 <Cale> :)
12:34:32 <mauke> if you want to use tabs, don't write "let a"
12:34:34 <EvilTerran> Deewiant, ^V<TAB>
12:34:44 <Deewiant> EvilTerran: you do all your indenting like that? ;-)
12:34:49 <blargeyfarg> cale: hehe... if you say so ;)
12:34:52 <monochrom> I wish there is a spammer to flood the channel now.
12:34:52 <EvilTerran> no. i use spaces to indent. :P
12:34:55 <Deewiant> mauke: yeah, use "let\n\ta" or?
12:35:07 <mauke> Deewiant: yeah. always start a new line for layout
12:35:13 <Deewiant> EvilTerran: so I shouldn't be talking to you about this ;-)
12:35:13 <Cale> blargeyfarg: well, you'll end up with lines that have nothing but a single keyword on them
12:35:20 <oerjan> > cycle "SPAM "
12:35:21 <lambdabot>  "SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM SPAM ...
12:35:28 <Deewiant> mauke: does that always work, in Haskell? I seem to recall that it didn't, in some case
12:35:32 <EvilTerran> > cycle "DESU "
12:35:33 <lambdabot>  "DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU ...
12:35:44 <mauke> Deewiant: worked for me before I started using spaces for indentation
12:35:48 <byorgey> > cycle "SPAM, " ++ "and SPAM!!"
12:35:49 <lambdabot>  "SPAM, SPAM, SPAM, SPAM, SPAM, SPAM, SPAM, SPAM, SPAM, SPAM, SPAM, SPAM, SPA...
12:35:54 <blargeyfarg> cale: yeah, i have to conceed you that one.  it's an eye sore
12:35:54 <Deewiant> hmm, maybe I can use tabs after all >:-)
12:36:02 <faxathisia> hehe
12:36:04 * olsner always uses tabs
12:36:08 <mauke> my old haskell programs all use tabs
12:36:09 <flux> actually I had forgotten a debian-directory to my kernel tree.. so the sizes in stripped/original/expanded are 297/309/368 M
12:36:15 <faxathisia> I was just thinking that byorgy
12:36:22 <byorgey> faxathisia: hehe =)
12:36:26 <Deewiant> flux: see, tabs save 60 megabytes of disk space :-)
12:36:27 <Gilly> Saizan: i'm doing that... but on the second look my array filling algorithm isn't that cheap after all
12:36:34 <monochrom> My old code used ASCII.  Now I use UTF-8.
12:36:39 <flux> deewiant, still waiting for the compressed results though :)
12:36:41 <desegnis> mauke, using a shiftwidth of 4 circumvents the let problem :)
12:36:51 <monochrom> AND I STILL ROT13 them!
12:36:52 <faxathisia> I use UTF-8 also
12:37:10 <EvilTerran> desegnis, using a shiftwidth of 3 circumvents the do problem, tho
12:37:10 * wli remembers the last time he ran into a situation where trying to backspace over recently-inserted tabs didn't take me 8 columns back in one stroke and threw his laptop across the room.
12:37:10 <byorgey> faxathisia: I'm having fun learning Agda! =)  I'm going through all the exercises from the summer school that you pointed me to
12:37:13 <olsner> desegnis: only if you have a 8-column tabwidth
12:37:42 <EvilTerran> although i just put two spaces before the first line of the do{} if i'm not putting a newline before it
12:37:56 <EvilTerran> wli, that seems a little... over-reactive
12:37:59 <monochrom> That is the problem with software.  You can't throw software across the room to vent anger.  You have to throw something innocent.
12:38:12 <desegnis> EvilTerran, and I guess 3 goes a little better with where
12:38:15 <faxathisia> byorgey, Yeah, it's great :D It's a strange type of dependent language compared to Coq but they are both really cool
12:38:23 * monochrom calls for the banning of all software.
12:38:27 <byorgey> faxathisia: what makes it strange?
12:38:34 * Toxaris_ uses tabs with tabwidth=1. the best of both worlds. unfortunately not compatible with Haskell. But no prob, just use explicit blocks to avoid changing the tabbing strategy.
12:38:40 <desegnis> (really do, let, where should all have the same character count)
12:38:42 <Cale> wli: Just configure your editor to treat multiple spaces as if they were tabs with regard to backspace.
12:38:43 <flux> the compressed sizes are 47240/48488/49008 kilobytes..
12:38:55 <byorgey> faxathisia: so far it seems to be a nice "gateway drug" for dependent languages, since it seems quite similar to Haskell =)
12:38:57 <Deewiant> tabwidths < 3 are hard to read
12:39:01 <faxathisia> hehe yes
12:39:06 <EvilTerran> desegnis, you mean "doo", "let" and "whr"?
12:39:11 <byorgey> faxathisia: I tried learning Coq before and it was quite confusing
12:39:19 <Deewiant> EvilTerran: how about "d", "l", and "w"
12:39:22 <faxathisia> byorgey, You do proofs by writing lambda terms directly as opposed to using proof tactics.. so it's a bit more odd than normal proofs (pen and paper)
12:39:24 <byorgey> faxathisia: but so far Agda makes a lot of sense
12:39:29 <EvilTerran> actually, i prefer "", "", and ""
12:39:34 <EvilTerran> let the parser work it out
12:39:39 <byorgey> faxathisia: ok, yes, I see what you mean
12:39:42 <gbacon> any lambdabot admins listening?
12:39:44 <Deewiant> yeah, and "in" is unnecessary too
12:39:58 <faxathisia> byorgey, but one thing that's impressive is there are some examples of making small tactic languges and proof search mechanisms there too!
12:40:15 <byorgey> faxathisia: I have already had to do some writing out proofs on paper, and then figuring out how to compute the proper proof terms
12:40:21 <oerjan> @admins
12:40:21 <lambdabot> Not enough privileges
12:40:29 <byorgey> faxathisia: interesting!
12:40:32 <desegnis> heh
12:40:46 <oerjan> @help admins
12:40:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:40:48 <wli> I'm not likely to work on things with bizarre indentation schemes like using ' ' repetitively instead of 8-column '\t' (never mind the things written while viewing the thing with '\t' interpreted as some other number of columns).
12:40:54 <EvilTerran> ?where xmonad
12:40:54 <lambdabot> http://xmonad.org/
12:41:53 <Cale> wli: It's easy to configure most editors such that it's not a problem.
12:43:46 <wli> Cale: It's very noticeable while editing. e.g. "4h" moves only 4 columns left instead of 32.
12:43:56 <monochrom> I hate the singular/plural and countable/uncountable distinction in English.  Not to mention that there is no scientific justification.
12:44:27 <wli> Cale: Or backspace only moving the cursor one column left vs. 8.
12:44:28 <monochrom> I wish I could configure editors' documentation so that they use a modified English in which there is no such distinction.
12:44:40 <Deewiant> wli: When would you ever want to use "4h" to move 4 tabs left?
12:44:49 <Cale> wli: at least for the latter, there's a switch which fixes that in vim
12:45:36 <olsner> ... which translates a simple editing operation (delete character) into a pile of black magic
12:45:40 <Cale> It's the smarttab option.
12:45:59 <Cale> olsner: It does what you want.
12:45:59 * wli typically uses either nvi or the vi that ships with the system (e.g. Solaris' vi that comes with it).
12:46:12 <olsner> perhaps, I haven
12:46:21 <olsner> 't really tried it yet
12:47:55 <Toxaris_> monochrom: how can there be "scientific justifications" for features of natural languages?
12:49:14 <monochrom> hehe
12:50:10 <Excedrin> lojban?
12:50:34 <Deewiant> constructed, not natural
12:51:27 <lament> Toxaris_: ever heard of "linguistics"?
12:51:49 <jacobian_> Boeing used a modified english for all technical manuals
12:51:57 <monochrom> cool
12:52:25 * pjd obligatorily plugs E-prime
12:52:26 <lament> it's this science that tries to provide justification for features of natural languages
12:52:58 <Philippa> monochrom: those distinctions're often helpful to disambiguate sentences. Not 100% reliably, of course, but that's not the point
12:53:34 <jacobian_> http://en.wikipedia.org/wiki/ASD_Simplified_Technical_English
12:53:35 <lambdabot> Title: Simplified English - Wikipedia, the free encyclopedia
12:53:39 <desegnis> lament, for some understanding of justification
13:03:16 <mrd> monochrom: go for japanese, no plurals.  when you want to talk about a quantity of things, you need a special counting word :/
13:13:07 * tac- hates counter words
13:14:40 * tac- goes to Office Depot. While there, he purchased three pads of notebooks, ten cylinders of pencils, and one item of eraser.
13:15:04 <faxathisia> http://www.augustsson.net/Darcs/LambdaCube/CubeExpr.hs
13:15:21 <faxathisia> I don't understand this... why does whnf not call the type checker :/
13:15:39 <tac-> 
13:15:52 <EvilTerran> tac-, gesundheit
13:16:00 <tac-> =-P
13:16:35 <mauke> 
13:16:38 <olsner> faxathisia: isn
13:16:49 <EvilTerran> @quote pcrs
13:16:49 <lambdabot> No quotes match. Take a stress pill and think things over.
13:16:50 <faxathisia> what?
13:16:55 <EvilTerran> hm.
13:16:58 <olsner> 't that described in one of augustss's blog posts?
13:17:26 <EvilTerran> @remember pcrs Premature carriage ret
13:17:26 <lambdabot> It is forever etched in my memory.
13:18:03 <dolio> @quote qwe1234
13:18:03 <lambdabot> qwe1234 says: what you linked to is neither formal nor a notion.
13:18:23 <mauke> @quote 1234
13:18:23 <lambdabot> pjdelport says: qwe1234, boldly defining where no man has defined before!
13:22:21 <monochrom> mrd: I use Chinese. I believe it's similarly good.
13:24:30 <sethk> monochrom, much too difficult for me
13:24:40 * roconnor still hates latex
13:24:54 <EvilTerran> me too
13:25:00 <monochrom> hehe it's ok, I spent 15 years learning it too.
13:25:48 <EvilTerran> roconnor, we should come up with something better
13:25:51 <EvilTerran> IN HASKELL
13:26:25 <olsner> there was a reddit about something called "Lout"
13:26:36 <roconnor> can we come up with something in the next 30 minutes
13:26:49 <Philippa> olsner: and an article about the system behind it too, IIRC
13:27:01 <tac-> does anyone else feel like reddit has been in short supply of nonlame articles the last two weeks?
13:27:08 <Philippa> tbh, the tricky part's all the time spent on interfacing - eating and spitting out the right formats
13:27:20 <olsner> I only got as far as the reddit headline before something else came up and distracted me
13:27:33 <Cale> tac-: There have been some good ones, but they got downmodded.
13:27:53 * EvilTerran could overlook the mortifyingly bad syntax if tex installs weren't hueg liek xbawks for a load of functionality i don't particularly want
13:28:22 <tac-> it feels like they changed their algorithm, and lame news postings stay on the front page for days
13:28:34 <Toxaris> lament: I'm aware of linguistics, i just don't think linguistics is concerned with justifying or condemning natural language features
13:28:40 <dolio> I don't know, that "OMG, returning an STL vector isn't as fast as my hand-coded assembly" was pretty good.
13:29:07 <EvilTerran> sure, the line-wrapping and widow/orphan control and whatnot are second to none. i don't care, i just want to be able to have acceptably-formatted code, formulae, symbols and whatnot with minimal fuss
13:29:07 <roconnor> So how does the rest of the world put code inside a figure without using verbatium?
13:29:19 <Cale> http://reddit.com/r/programming/info/6a4jz/comments/ -- this was a good post, it's at 0
13:29:49 <faxathisia> reddit sucks
13:30:21 <Cale> The SNR is actually about where it usually is for me.
13:30:28 <roconnor> fuck it, I'll just use \tt{blah} and live with unindented code.
13:30:30 <Cale> Well, it's a little low.
13:31:11 <Cale> The numbers down the side of my 'new' page are 26,40,48,75,76,83,85,135,... Everything else is modded down.
13:31:39 <Philippa> EvilTerran: I don't mind the size of the typical TeX/LaTeX package so much, it's tolerably factored at least
13:32:05 <Philippa> but I say that as someone whose smallest (in capacity) machine has 4GB of storage and smallest (physical size) has 6GB
13:32:18 <Philippa> oh okay, or there's the games consoles but I'm not about to run TeX on those
13:32:26 <monochrom> roconnor: there is a "program" package, and an "algorithm" package, IIRC.
13:32:29 <EvilTerran> Philippa, i guess the thing is i don't generally _want_ an industry-grade typesetting bundle of wootness
13:32:36 <Cale> TeX-box
13:33:06 <EvilTerran> so it stings to install a massive chunk of that when all i want is a lightweight typesetter at about the level of HTML+MathML
13:33:22 <EvilTerran> (only not so fugly as actually using HTML+MathML)
13:33:38 <EvilTerran> even if i have the space, it just seems wrong
13:33:48 <roconnor> why are my figure captions in typewriter font?
13:34:00 <roconnor> ugh, Latex is as frusterating as Haskell. :P
13:34:09 <EvilTerran> roconnor, should that be {\tt blah} ?
13:34:17 <monochrom> @remember roconnor ugh, Latex is as frusterating as Haskell. :P
13:34:17 <lambdabot> Done.
13:34:30 <roconnor> EvilTerran: is that how it works?
13:34:39 <osfameron> but debugging documents is even more frustrating than debugging code...
13:34:42 <EvilTerran> i don't recall, but *some* bits of TeX work like that
13:35:01 <EvilTerran> if it's like \rm or \it in Plain TeX, it works like that
13:35:04 <roconnor> EvilTerran: great.
13:35:10 <monochrom> \texttt{x} or {\tt x}
13:35:23 <EvilTerran> nasty stutter you've got there, monochrom :P
13:35:26 <roconnor> EvilTerran: that's better
13:35:33 <Philippa> EvilTerran: TeX itself is pretty small though, and it's solid enough
13:35:46 <monochrom> \tt extends all the way to the right until the next scope ending, like lambda.
13:36:04 <Cale> I used plain TeX for homework assignments for quite a while.
13:36:08 <EvilTerran> Philippa, meh. you don't have to defend it, i can see it's a marvellous bit of software. i just don't like it myself. :)
13:36:26 <Philippa> EvilTerran: It's great and it's a steaming pile of shit at the same time, 'sokay :-)
13:36:38 <Philippa> but most of my complaints are about the language I guess
13:36:49 <tac-> Philippa, in software, I'm pretty sure that's the norm
13:37:03 * EvilTerran is reminded of his opinion of mplayer
13:37:09 <Philippa> tac-: TeX's a pretty extreme example
13:37:12 <monochrom> All frustrations about using software S can be solved by dedicating two weeks to learning S.  For example what Cale said about editors.
13:37:24 <Philippa> if you allow for the state of PLT at the time, it's really damn good
13:37:34 <monochrom> I dedicated two weeks to emacs, and two weeks to LaTeX, and I'm a happy man ever since.
13:37:48 <monochrom> I also bought The LaTeX Companion.
13:37:51 * tac- would like Emacs if it just played nicely with tabs
13:37:59 <Cale> TeX isn't really aimed at being a good programming language. It's aimed at mathematicians who, for the most part, do the same typesetting tasks over and over again.
13:38:13 <Vq^> tac-: tabs?
13:38:38 <monochrom> tac-: I dedicated two weeks to learning emacs.  That solved the tab problem.
13:38:46 <Cale> tac-: Do what I did, and just give up on tabs. Never allow them to occur in any of your files.
13:38:53 <ahunter> monochrom: counterexamples to that statement include S=IE, S=kaleidagraph, and S=xilinx, among others.
13:38:58 <mauke> Cale: Makefile?
13:39:03 <Cale> mauke: Cabal.
13:39:03 <TSC`> cabal!
13:39:04 <monochrom> IE needs learning?!  <duck>
13:39:12 <mauke> Cale: too complicated
13:39:14 <cjb> tac-: I did the same as Cale.
13:39:16 <wli> A good programming language that compiles to (La)TeX might be nice.
13:39:19 <mauke> I use make on top of cabal
13:39:36 <ahunter> mauke: Emacs, for me at least, has stopped me worrying about Makefiles--I have emacs set to pretty much never insert tabs, and it still transparently just makes Makefiles *work*
13:39:41 <Cale> I've never actually written a makefile for anything.
13:40:01 <monochrom> A good programming language that compiles to TeX would be like using string macros for continuations...
13:40:07 <mauke> ahunter: emacs is unusable because (e.g.) its crippled undo system
13:40:12 * Vq^ has scripted a lot of weird things with makefiles
13:40:15 <roconnor> I'll leave it to the editors to clean up my overfull boxes. ... That's their job anyways.
13:40:19 <ahunter> monochrom: touche, but the other two stand :)
13:40:25 <Philippa> Cale: yes and no. It's aimed at being extensible enough that it wants to be a good programming language within the constraint of being a comfortable typesetting language for repetetive tasks
13:40:27 <Cale> Either I've just written a shell script for building, or I've used a proper tool like Cabal.
13:40:30 <mrd> (setq indent-tabs-mode nil)!
13:40:53 <ahunter> mauke: what's crippled about it?  I admit I do very little undo, but what it has does work Just Fine for me (coupled with version control for long term stuff...)
13:41:02 <mauke> ahunter: no redo
13:41:02 <tac-> I just want it to be 4 spaces when I hit TAB. But Emacs pretends like TAB is this magical thing that can do your homework and make you lunch.... but getting it to just always print 4 spaces in all modes is just something I haven't been able to figure out after many attempts to find the answer
13:41:17 <monochrom> That is configurable.
13:41:19 * Philippa is going to have to start building a makefile or similar and scripts to chop up code for her papers anyway
13:41:29 <mrd> yea the indent-line-function
13:41:31 <mrd> set it to 'tab-to-tab-stop
13:41:33 <Vq^> Cale: it can be quite handy for generating other kind of files, graphics from descriptions or movies from images
13:41:37 <tac-> I have indent-tabs-mode nil, and tab-width set to 4
13:41:44 <monochrom> I dedicated two weeks to learning emacs.  After that I knew how to configure emacs to treat tabs in any arbitrary way anyone ever wants.
13:41:46 <Philippa> literate haskell per se only really works if you're presenting one coherent program
13:41:47 <tac-> what is tab-to-tab-stop?
13:41:47 <mrd> the default indent-line-function attempts to be "smart"
13:41:57 <Cale> I'd generally just use a shell script for those tasks.
13:42:00 <mrd> tab-to-tab-stop is the function which simply moves to the next tab stop
13:42:14 <tac-> It's a pet peave of mine when software and electronics try to be smarter than me.
13:42:24 <TSC> mauke: There are modifications to undo to make it behave like other undo/redo functions
13:42:47 <Vq^> Cale: a script might has to redo much of the work, especially if you work with rendering
13:42:50 <mauke> or you could just use vim where it works out of the box
13:42:54 <ahunter> tac-: it's a pet peeve of mine when software assumes I'm stupid and then goes down to my level
13:43:05 <lament> Toxaris: actually, a big portion of linguistics is about justifying language features
13:43:10 <lament> or trying to, anyway
13:43:12 <hpaste>  mrd pasted "tab-to-tab-stop for haskell mode" at http://hpaste.org/5960
13:43:17 <monochrom> It's a pet peeve of mine when users complain and don't RTFM.
13:43:21 <Cale> Vq^: Sure, but I've written scripts that actually store the timestamps on files somewhere so as to be able to check if they've been updated.
13:43:30 <lament> Toxaris: basically, trying to answer the question "why are things this way"
13:43:40 <mrd> in vim, I need to set several things to get it the way i like, too
13:43:45 <Vq^> Cale: aren't you just reinventing make then?
13:43:52 <mrd> et, sts=2, sw=2
13:43:56 <mauke> mrd: yeah, but the basic stuff works
13:43:56 <tac-> the whole tab-stop-list system is sorta lame. Emacs should use promises or lazy lists!
13:43:57 <Cale> Vq^: possibly.
13:43:59 <Saizan> monochrom: learning from what? the official manual?
13:44:01 <Toxaris> lament: this question sounds reasonable, but "which way should it be" doesnt for me
13:44:12 <Vq^> Cale: i thought a Haskell programmer should know the use of programming with data-dependencies ;)
13:44:14 <mauke> like help system, undo/redo, proper text files, etc
13:44:34 <Cale> Vq^: In that case I was actually running the thing in a continual loop, and rebuilding whenever anything changed.
13:44:40 * EvilTerran found vim to be rather more discoverable than emacs
13:44:41 <Toxaris> lament: so you can't say, this feature of english is bad because it is not justified by linguistics, but you have to say, linguistics is bad because it is not able to justify this feature
13:44:44 <mrd> mauke: it defaults to tab stops, that's all
13:44:48 <monochrom> I bought an O'Reilly book to learn emacs.
13:44:51 <cjb> EvilTerran: that's ridiculous
13:44:57 <mauke> EvilTerran: same here
13:45:05 <Cale> Vq^: and I couldn't really determine the data dependencies anyway, so it would just rebuild everything.
13:45:10 <EvilTerran> cjb, someone's personal experience cannot be "ridiculous".
13:45:14 <cjb> it is impossible to discover how to use vim; you'd get stuff learning how to quit :)
13:45:15 <mauke> emacs' help system is much too hard to use, coming from vim
13:45:18 <monochrom> Some parts of the official manual was also useful.
13:45:21 <cjb> s/stuff/stuck/
13:45:24 <mrd> hard to use?
13:45:33 <mrd> both of them are pretty easy to use
13:45:37 <tac-> monochrom: I bought the Learning Emacs OReilly book, but disappointingly, it doesn't really cater to programmers and it's coverage of Elisp is really bad =-(
13:45:37 <mauke> cjb: er, it tells you how to do that when you start it
13:45:52 <EvilTerran> it also tells you how to get at the help
13:45:53 <Vq^> Cale: ok, i have to admit that make doesn't fit most of my needs, but it's certainly a good tool to know how to use
13:46:02 <mauke> also, <F1>
13:46:03 <Vq^> Cale: the format is really simple
13:46:08 <EvilTerran> and the first page of the help tells you how to navigate the help
13:46:09 <monochrom> Yes it was light. I used it to bootstrap myself.
13:46:29 <mrd> EvilTerran: as does Emacs
13:46:31 <EvilTerran> and the second page points you to the quickref and the tutorial
13:46:35 <mrd> EvilTerran: go on, fire up "emacs" and see =)
13:46:44 <mauke> zsh: command not found: emacs
13:46:49 <mrd> oh noes
13:46:54 * EvilTerran waits several seconds
13:46:58 * mrd chuckles
13:46:58 <mauke> haha
13:47:20 * EvilTerran sees a gui window pop up
13:47:21 <EvilTerran> wait what
13:47:26 <mrd> if vim had inferior-haskell mode i'd be happy with it
13:47:27 <mauke> see?
13:47:51 <mauke> annoyance #1: emacs refuses to run in a terminal
13:47:53 <EvilTerran> ... it's got a URL for the help. fat lot of good when i'm on a train trying to get some work done :P
13:48:09 <monochrom> emacs -nw
13:48:10 <mrd> emacs -nw
13:48:12 <jeffz> emacs -nw
13:48:13 <mrd> heh
13:48:20 <monochrom> hahahahhaha
13:48:25 <mauke> how intuitively obvious
13:48:27 <mrd> it's like reflex
13:48:31 <EvilTerran> mauke, annoyance #0: it took several seconds to get that far, while vim and gvim open near instantly on the same box
13:48:32 <sarehu> emacs --help
13:48:54 <mrd> you don't use emacs like vim.  you keep an emacs session running all the time, for months even.  i use vim for quick editting.
13:49:11 <EvilTerran> s/like vim.*// :P
13:49:22 <monochrom> The only annoyance you can file against emacs is it needs more learning and RTFM than average.
13:49:23 <mauke> also, DISPLAY= emacs  # easier than -nw
13:49:37 <mrd> what's average, though?
13:49:43 <Philippa> ...you're saying that about a lisp-based program, in #haskell
13:49:44 <TSC> vim
13:49:46 <int-e> mrd, vi isn't
13:49:48 <Philippa> c'mon, there's at least one more irritation
13:49:50 <mrd> indeed
13:49:51 <mauke> monochrom: and more customization, and it's at version 24 and the defaults still suck
13:49:51 <monochrom> You can't really impeach it on the grounds of "it can't do xxx".  It obviously can, it's just hard to find out how.
13:49:53 <int-e> s/vi/vim/
13:50:03 <sw17ch> > foldr (\x y -> x + y) 0 [1..10]
13:50:03 <lambdabot>  55
13:50:06 <mauke> it can't do local variables
13:50:10 <sw17ch> > foldr (\x y -> x + y) 0 [1..3]
13:50:11 <Philippa> it can't put an 8 figure sum in my bank account
13:50:11 <lambdabot>  6
13:50:15 <sw17ch> > foldr (\x y -> x + y) 0 [1..3] :: Expr
13:50:15 <lambdabot>  1 + (2 + (3 + 0))
13:50:15 <EvilTerran> monochrom, there's not needing to RTFM, and there's finding which bit of TFM you need to read
13:50:24 <sw17ch> > foldl (\x y -> x + y) 0 [1..3] :: Expr
13:50:25 <lambdabot>  0 + 1 + 2 + 3
13:50:46 <mauke> monochrom: it can't leave my cursor alone when running on the linux text console
13:50:58 <EvilTerran> i don't mind the former being absent, but the latter seems to be somewhat harder with emacs than vim.
13:51:04 <mauke> (the default cursor is a blinking underscore; emacs makes it a blinking block)
13:51:16 <EvilTerran> it might just be that i think like a vimmer rather than an emacser. people differ.
13:51:20 <mauke> and I know it can't do this because this "feature" is hardcoded in the C parts of eamcs
13:51:23 <monochrom> But end users say the same about all unixes.  They say Windows is intuitive and unix is a mystery.  Yet we scorn at them while we bitch about emacs.
13:51:45 <mauke> it's like a single character change to fix that
13:51:57 <EvilTerran> monochrom, man comes rather more naturally to me than the emacs help system
13:52:47 <mrd> I hate when people say windows is intuitive, especially after i've been wrangling with it to make my game run for hours
13:53:47 <monochrom> And get this: We scorn at the "VB kids" just because some people find VB plus its IDE more intuitive and discoverable than what they describe as "obscure Haskell".
13:53:56 <ydo> windows is intuitive because they teach it to small children..
13:54:32 <mrd> it's like claiming your native language is more intuitive than other languages because you were taught it as a small child
13:54:38 <EvilTerran> monochrom, are you going somewhere with this, or just accusing the world of hypocricy
13:54:46 <ydo> would the schools teach unix to school kids it would ofcourse be more popular with unices..
13:54:46 <EvilTerran> ... 'cos that's *oooold* news
13:54:48 <Cale> The thing which really bothers me about windows is that it never explains what it's doing. It's like "Please wait while something happens."
13:55:01 <ceibe> hi, can someone help me? I have a function that is an implementation of a search algorithm, the function have low memory cost. The problem is that I need to log some things during the execution of the function, like generated nodes, closed nodes, and a list of opened nodes for each step. In my program I call the function and just print all log info. When I add log to the function with Writer monad the use of memory increases a lot, there is anyway to solve
13:55:01 <ceibe> it?
13:55:01 <mrd> Cale: oh you're lucky if it  tells you something is happening
13:55:20 <mrd> Cale: but you'll get 20 popups about something that is irrelevant :)
13:56:12 <Cale> ceibe: Well, you might be inadvertently forcing things to be evaluated which never got evaluated before.
13:56:29 <mauke> isn't Writer lazy?
13:56:30 <int-e> windows is great as long as everything works fine ;)
13:56:38 <Cale> Writer is lazy.
13:56:44 <mauke> which means deep thunks, etc
13:56:48 <Cale> No.
13:56:53 * EvilTerran was thinking deep thunks, also
13:56:56 <Japsu> lazy cat is lazy
13:56:59 <Japsu> strict cat is strict
13:57:06 <olsner> int-e: just as rain is dry as long as it's not raining :P
13:57:14 <EvilTerran> (++!) :: ![a] -> ![a] -> [a] --?
13:58:03 <Cale> (++) isn't the issue with Writer. You can write tons of stuff in a perfectly lazy fashion. Also, he says that he's just printing the log, which means that it should be able to garbage collect the written part.
13:58:31 <EvilTerran> (that was a joke, son)
13:58:34 <ceibe> yes, I generate the log on demand while I'm writing it
13:58:35 <monochrom> EvilTerran: The world outside I understand.  I just thought inside #haskell we had got rid of hypocrisy already.
13:58:53 <ceibe> so the memory uses should be low too
13:58:57 <ceibe> but it isn't happen
13:58:57 <monochrom> Perhaps I expect too much of Haskellers.
13:59:00 <EvilTerran> monochrom, sadly, hypocricy is an inevitable part of the human condition
13:59:03 <Cale> The problem might be that by writing stuff which is dependent on various variables in the algorithm which were formerly never evaluated, you're forcing more stuff to be evaluated than used to be the case.
13:59:07 <EvilTerran> and we are all still human
13:59:22 <EvilTerran> well, apart from duncan. he's a terminator.
13:59:26 <monochrom> Shouldn't we learn to reduce it?
13:59:38 <Cale> EvilTerran: Which model?
14:00:03 <EvilTerran> Cale, the first odd perfect number
14:00:08 <mauke> I just don't like it when people are all "omg emacs is teh greatest kthx" and then I start it and it's totally not vim :(
14:00:20 <Cale> ceibe: It's a little hard to say though, without seeing the code...
14:00:37 <monochrom> No, I don't think emacs is the greatest either.
14:01:47 <mauke> on that note, how do I get the width of a character in haskell?
14:01:47 <hpaste>  ceibe pasted "problem with Writer" at http://hpaste.org/5962
14:02:04 <monochrom> width in what sense? number of bits?
14:02:14 <mauke> no, display width
14:02:17 <ceibe> variable names are in English, comments no, I can translate it if could help
14:02:28 <monochrom> Haskell doesn't know that.  Only a GUI library knows.
14:02:33 <mauke> mostly I just want to support double-width characters
14:02:54 <monochrom> Or a font library.
14:02:57 <dons> super awesome, http://www.jasani.org/2008/02/initial-release-of-hsparklines-010.html
14:02:58 <lambdabot> Title: A Wrong Turn On The Path To Enlightenment: Initial release of hsparklines 0.1.0, http://tinyurl.com/2smbcs
14:03:02 <monochrom> It depends solely on the font anyway.
14:03:05 <mauke> I'm using a fixed width font
14:03:42 * Cale :%s/\t/        /g
14:03:51 <monochrom> A font library has functions to answer "what is the width".  And that is the only source of that information.
14:04:19 <mauke> no, you could just use a unicode database
14:04:27 <monochrom> Whichever program that can give that information must be either wrong or must call the font library.
14:04:42 <dons> http://reddit.com/info/6a7gd/comments/ hsparklines: generate sparklines from Haskell [programming] (jasani.org)
14:04:44 <monochrom> OK, perhaps.
14:05:22 <monochrom> But Haskell libraries don't know.
14:06:50 <Cale> ceibe: I can't run this to profile it, but I'll have a look.
14:08:32 <Cale> ceibe: There's a lot of strictification here. Are you sure that it's all necessary?
14:09:02 <ceibe> Cale, no 100%, I put it trying to reduce memory usage
14:09:23 <mightybyte> @src unless
14:09:23 <lambdabot> unless p s = if p then return () else s
14:09:39 <Cale> ceibe: For example, you have  List.map (:p) $! n_succs'   -- the $! there is unlikely to do anything useful, since it'll just force the evaluation of the list up to determining if it's a cons or nil.
14:10:21 <Cale> Which actually might cause more allocation to occur than otherwise would.
14:11:44 <ceibe> Cale, ;/ a mistake, I thought that will force the complete evaluation of n_succs'
14:12:04 <sclv_> ceibe: have you seen strictifier?
14:12:14 <Cale> heh
14:12:54 <ceibe> sclv_, uhm?
14:13:11 <sclv_> it might be the wrong tool here, but if you can wrap your code in a simple test harness with a main, and randomly sprinkle  possible strictness annotations, it will (eventually) give you a nice solution.
14:13:25 <Cale> randomly strictifying the code isn't really what we want to do. I don't have the support libraries to build this, but it would be good if you could give me some profiling output.
14:13:25 <sclv_> its a little toy I wrote -- its up on hackage.
14:14:03 <Cale> ceibe: Could you compile the program with -prof -auto-all and then run it with +RTS -p -hc
14:14:06 <Cale> ?
14:14:22 <ceibe> yes of course
14:14:38 <Cale> Then, on the resulting hp file, run hp2ps, and put that up somewhere so that we can look at it.
14:14:56 <Cale> (and the .prof too)
14:15:23 <sclv_> Cale: strictifier could at least automatically determine how many of the $! annotations really should just be $. its really a destrictifier... :-)
14:15:37 <Cale> sclv_: I can tell you that beforehand :)
14:15:42 <sw17ch> is there syntax to capture both a piece of a pattern match and the outer piece as well?
14:16:02 <Cale> sclv_: all the $!'s here are unnecessary. The only useful strictness annotations in this are the ones in the data declaration.
14:16:04 <sw17ch> (\(x:xs) -> x) where i also want the reference of (x:xs) to be y
14:16:16 <Toxaris> sw17ch: \y@(x:xs) -> ...
14:16:16 <sclv_> bah -- if god meant us to use our brains he wouldn't have given us multicore processors.
14:16:28 <dcoutts> glguy: pong
14:16:39 <pjd> sw17ch: you can read the @ as "as"
14:16:44 <Toxaris> sw17ch: a typical naming scheme is xxs@(x:xs)
14:17:22 <dons> dcoutts: check what ghc does to these Word8 case analyses, http://hpaste.org/5954
14:17:27 <dons> compared to Ints.
14:17:37 <dcoutts> dons: breaking <= into < and == ?
14:17:51 <sw17ch> Toxaris, oh... that's what that's for :)
14:17:54 <sw17ch> thanks :)
14:17:55 <dons> < to <= and ==
14:18:12 <dons> sorry, < becomes < and ==
14:18:17 <sw17ch> > until (\(x:_) -> x >= 10) (\y@(x:_) -> (x + 1) : y) [1]
14:18:18 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
14:18:21 <sw17ch> woo!
14:18:22 <dons> only for Word types
14:18:24 <dons> not for Int types
14:18:57 <dcoutts> dons: perhaps because of missing entries in the Ord instance and relying on default implementations?
14:19:03 * dcoutts checks the code
14:19:12 <monochrom> Haskell's "x@(y:z)" becomes SML's "x as (y::z)".  In a very strong sense @ is as.
14:19:13 <dons> its got to be the Ord instance (or else special rules that fire for Int)
14:19:24 <dcoutts> dons: aye, let's look
14:19:30 <dons> dcoutts: radically different rules fire, i noticed
14:20:00 <dcoutts> dons: how does this work?
14:20:01 <dcoutts> data Word8 = W8# Word# deriving (Eq, Ord)
14:20:08 <dcoutts> deriving?!
14:20:09 <dons> yeah, good question.
14:20:17 <monochrom> The downside of Haskell is that you can't use @ for your own operator name. The downside of SML is that you can't use as for your own function name.
14:20:17 <dons> i can't find out. is it hard baked?
14:20:33 <dons> or variable names, monochrom ?
14:20:33 <dcoutts> dons: perhaps
14:20:37 <monochrom> Yeah!
14:20:38 <dons> kinda scary
14:20:45 <dons> dcoutts: the Int instance isn't though
14:21:15 <dons> Char and Int have their own non-derived instances
14:21:19 <dcoutts> dons: though it does for all the Int8,16,32
14:21:37 <dons> but Word32 and Word64 have instances
14:21:46 <dcoutts> dons: report it as a ghc perf bug
14:21:49 <dons> maybe Word derives in terms of the WordN for that arch?
14:22:12 <dons> yeah, definitely.
14:22:58 <dcoutts> dons: yes, interesting, that it has instance Ord Int explicitly
14:23:07 <dons> yeah, what's going on here?
14:23:15 <dons> Int favouritism must end!
14:23:25 <dcoutts> :-)
14:24:06 <dcoutts> dons: what's really odd is the deriving for wrappers around unboxed types, since the latter cannot be instances of type classes
14:24:18 <ceibe> Cale, one moment, takes some time the execution...
14:24:27 <dons> dcoutts: yeah. scary magic
14:24:43 <dcoutts> dons: and it seems quite unnecessary given what is done for Int
14:25:16 <hpaste>  lekro pasted "segfault on Intel Mac" at http://hpaste.org/5963
14:25:18 <lekro> what could be the reason that this program segfaults on a new Intel iMac with ghc-6.6.1 and the most recent version of HOpenGL/GLUT?
14:26:37 <monochrom> perhaps the most recent HOpenGL/GLUT mismatches ghc 6.6.1
14:26:42 <lekro> sometimes it seemed to depend on whether I call a GLUT or OpenGL function that takes Doubles.
14:26:56 <lekro> like frustum in that case
14:27:02 <dons> dcoutts: all very fishy
14:27:04 <lekro> if I remove frustum it runs
14:27:32 <monochrom> I wouldn't call it a problem unless you also try 6.8.2 with same result.
14:27:44 <sw17ch> huh, i just found my first real-life use for a list comprehension
14:28:07 <dcoutts> dons: aye
14:28:13 <monochrom> But if you say, "I built HOpenGL/GLUT myself using ghc 6.6.1", I'm wordless.
14:28:27 <lekro> monochrom: I built it myself using 6.6.1
14:28:44 <monochrom> haha ok, all my speculations were wrong then.
14:28:46 <lekro> does code for 6.6.1 compile on 6.8.2 without change if I don't use ghc extensions?
14:29:12 <monochrom> I don't know.
14:29:13 <byorgey> sw17ch: congrats =)
14:29:20 <sw17ch> :)
14:29:26 <sw17ch> it was quite satisfying...
14:29:41 <monochrom> Sometimes there are the silliest kind of build problems such as "cabal version has changed, now Setup.hs doesn't work".
14:30:54 <lekro> monochrom: I wasn't quite able to nail down the problem but it (usually) doesn't crash when I don't call any HOpenGL/GLUT function that takes Double. functions that take Float seem to work
14:30:58 <dons> dcoutts: wow, the 'gd' library is a pathological test case for cabal,   Extra-libraries: gd, png, z, jpeg, m, fontconfig, freetype, pthread, expat
14:31:32 <dcoutts> dons: pah, hardly pathological
14:31:46 <glguy> dcoutts: Did you write some stuff about the utf8-string being broken?
14:31:47 <dcoutts> dons: I can find much more evil examples for you :-)
14:31:52 <dons> well, it fails in hsc2hs due to all sorts of missing things.
14:31:55 <dcoutts> glguy: oh yes
14:31:56 <dons> unchecked C libs
14:32:03 <glguy> dcoutts: so I switched to openBinaryFile
14:32:05 <glguy> where possible
14:32:07 <glguy> but
14:32:09 <lekro> and I've no idea what could be the reason for this weird behavior :(
14:32:14 <glguy> what's the solution for things like "hGetLine"?
14:32:20 <glguy> where I'm dealing with stdin/out/err?
14:32:31 <lekro> because it works with 6.6.1 on PPC Mac and on x86 Linux
14:32:41 <monochrom> That is indeed very strange. Unfortunately I know nothing about how to debug FFI problems.
14:32:42 <lekro> only the new iMac has this problem
14:33:05 <dcoutts> glguy: if you're given an existing handle you're pretty much stuffed because you don't know if it's text or binary and it's a bit evil to go an mutate the mode.
14:33:21 <lekro> I installed ghc-6.6.1 using the binary package from the website and HOpenGL/GLUT from the darcs repo
14:33:35 <Cale> > let divisors n = [k | k <- [1..n], n `mod` k == 0]; arithmeticMean xs = fromIntegral (sum xs) / fromIntegral (length xs); harmonicMean xs = fromIntegral (length xs) / sum [1 / fromIntegral x | x <- xs] in [arithmeticMean ds * harmonicMean ds :: Rational | n <- [1..20], let ds = divisors n]
14:33:35 <lambdabot>  [1%1,2%1,3%1,4%1,5%1,6%1,7%1,8%1,9%1,10%1,11%1,12%1,13%1,14%1,15%1,16%1,17%1...
14:33:36 <dcoutts> glguy: just document that all the handles should be set to binary mode
14:33:38 <glguy> dcoutts: My inclination was to require the user to set the mode
14:33:40 <glguy> ok
14:34:05 <glguy> dcoutts: would you glace at the darcs repo some time and see if the changes as checked in address your concerns?
14:34:08 <lekro> monochrom: even stranger is that the redbook/Cube.hs example from GLUT works even though it calls frustum.
14:34:11 <dcoutts> glguy: and the utf8 decode recognises 4 and 5 byte encodings which are not legal utf8 any more as I understand it.
14:34:17 <dcoutts> glguy: sure
14:34:18 <glguy> dcoutts: 4 are
14:34:22 <glguy> dcoutts: 5/6 aren't
14:34:25 <monochrom> If you can cause a segfault with ghc and its out-of-the-box libraries alone using Double, that will impeach the particular ghc build.
14:34:26 <glguy> and it doesn't recognize them
14:34:34 <glguy> it recognizes them as errors
14:34:35 <dcoutts> glguy: oh, hmm
14:34:47 <dcoutts> glguy: oh, my mistake
14:34:55 <Cale> ceibe: If it takes a really long time, just stop it at some point and we'll just use the profiling information up until then.
14:35:03 <glguy> dcoutts: the code was there to take the full 6 bytes of error
14:35:11 <glguy> and return one replacement character
14:35:26 <dcoutts> glguy: I see
14:35:36 <dcoutts> glguy: you're being too forgiving :-)
14:35:51 <glguy> I don't think that is still in the repo anymore anyway
14:36:14 <dcoutts> glguy: and I think you can probably use fewer chr calls, each of them are a conditional
14:36:21 <dcoutts> they're expensive
14:36:35 <glguy> dcoutts: I use one per character
14:36:38 <lekro> monochrom: hm, so it looks like my best bet would be to update ghc. but my code must also work with ghc-6.6.1. unfortunately I can't access or run ghc 6.8.2 from this machine, do you know of any checklist or something that explains when a program for 6.6.1 will (not) compile with 6.8.2?
14:36:40 <glguy> should I use 0?
14:37:00 <dcoutts> glguy: but don't you already check that we could not possibly get a char above maxBound :: Char?
14:37:10 <dcoutts> glguy: so isn't the check redundant?
14:37:15 <ceibe> Cale, only few minutes, I run it on a "hard" problem to solve, the search algorithm is so bad
14:37:21 <glguy> dcoutts: what's the alternative to chr?
14:37:24 <glguy> that doesn't check
14:37:30 <Cale> > let divisors n = [k | k <- [1..n], n `mod` k == 0]; harmonicMean xs = fromIntegral (length xs) / sum [1 / fromIntegral x | x <- xs] in [n | n <- [1..700], let ds = divisors n, denominator (harmonicMean ds) == 1]
14:37:31 <lambdabot>  [1,6,28,140,270,496,672]
14:37:38 <lekro> like, are the standard modules still in the same place in 6.8.2, like Data.List etc.?
14:37:39 <dcoutts> glguy: well, it's ghc only of course
14:37:45 <monochrom> At this point it seems my old speculations may be wrong. This means 6.8.2 may very well suffer the same problem. You can try but I wouldn't hold great hope.
14:37:46 <glguy> oh :-/
14:37:49 <sclv_> ?src chr
14:37:49 <lambdabot> Source not found. Maybe you made a typo?
14:37:57 <dcoutts> unsafeChr :: Int -> Char
14:37:58 <dcoutts> unsafeChr (I# i#) = C# (chr# i#)
14:38:10 <dcoutts> @hoogle unsafeChr
14:38:11 <lambdabot> No matches found
14:38:19 <lekro> monochrom: where do you think the problem comes from? HOpenGL/GLUT itself?
14:38:28 <glguy> dcoutts: also iavor unrolled the loop for the 2byte case
14:38:33 <dcoutts> glguy: it'd require #ifdefs
14:38:42 <dcoutts> glguy: I'm looking at the current darcs repo...
14:38:51 <glguy> dcoutts: ah, so the library could still work in hugs
14:38:52 <sw17ch> i'm trying to write a function that opens a file with openFile and then scans to an absolute position with hSeek... i'm unable to figure out where my type error is in the two lines that i have
14:38:54 <sclv_> hmmm... its in GHC.Base ?
14:38:55 <monochrom> Some low level things such as byte ordering, size of Double, even floating point format.
14:38:56 <glguy> it would just be faster in ghc
14:39:03 <sw17ch> 65 openAndScan fileName position = do handle <- SIO.openFile fileName
14:39:04 <sw17ch> 66                                    return $ hSeek handle AbsoluteSeek position
14:39:07 <dcoutts> glguy: right
14:39:16 <glguy> sw17ch: ditch the return
14:39:20 <glguy> :t hSeek
14:39:21 <lambdabot> Not in scope: `hSeek'
14:39:32 <dcoutts> glguy: have you checked that the concatMap fuses? otherwise it'll be faster to make it directly recursive
14:39:34 <sw17ch> :t System.IO.hSeek
14:39:34 <lambdabot> GHC.IOBase.Handle -> GHC.Handle.SeekMode -> Integer -> IO ()
14:39:56 <dcoutts> glguy: if you have time it'd be great if you could look over the utf8 code I added to Cabal
14:40:01 <sw17ch> genomeParsePar.hs:66:41:
14:40:01 <sw17ch>     Couldn't match expected type `Handle'
14:40:01 <sw17ch>            against inferred type `IO Handle'
14:40:07 <glguy> dcoutts: gladll
14:40:08 <glguy> y
14:40:15 <sw17ch> that's after dropping the return
14:40:17 <dcoutts> glguy: I copied it from gtk2hs and adapted it a bit. I think it only checks 1-3 byte forms.
14:40:53 <dcoutts> darcs.haskell.org/cabal/Distribution/Simple/Utils.hs
14:40:56 <glguy> Prelude Codec.Binary.UTF8.String> encode [maxBound]
14:40:58 <glguy> [244,143,191,191]
14:41:25 <glguy> (darcs getting..)
14:41:37 <Cale> @oeis 1,2,3,5,6,5,8,9
14:41:38 <lambdabot> Harmonic means of divisors of harmonic numbers.
14:41:38 <lambdabot> [1,2,3,5,6,5,8,9,11,10,7,15,15,14,17,24,24,21,13,19,27,25,29,26,44,44,29,46,3...
14:42:43 * mrd wonders if there is a sequence of numbers not appearing in any sequence of numbers in the oeis
14:43:01 <mrd> well, besides N
14:43:27 <sw17ch> oh gosh, well, this is embarrassing :( just forgot the ReadMode after the filename...
14:43:32 <sw17ch> that would explain the type error...
14:44:08 <Cale> mrd: well, my sequence there doesn't occur in N :)
14:44:37 <mrd> but the numbers do
14:44:38 <glguy> dcoutts: your code does 1-4 byte sequences
14:44:45 <glguy> so that's right
14:45:11 <Cale> @oeis 1 2 3 5 6 8 9
14:45:12 <lambdabot> (Odd primes - 1)/2.
14:45:12 <lambdabot> [1,2,3,5,6,8,9,11,14,15,18,20,21,23,26,29,30,33,35,36,39,41,44,48,50,51,53,54...
14:45:16 <dcoutts> glguy: not in toUTF8
14:45:20 <ceibe> Cale, I'm looking for a site to download files, one sec
14:45:26 <glguy> dcoutts: oh, right
14:45:41 <glguy> dcoutts: that's an easy fix though
14:45:50 <dcoutts> aye
14:46:05 <Cale> > nub [1,2,3,5,6,5,8,9,11,10,7,15,15,14,17,24,24,21,13,19,27,25,29,26,44,44,29,46]
14:46:06 <lambdabot>  [1,2,3,5,6,8,9,11,10,7,15,14,17,24,21,13,19,27,25,29,26,44,46]
14:46:08 <glguy> dcoutts: the primaray difference is that one is a validating decoder
14:46:14 <Cale> > sort . nub $ [1,2,3,5,6,5,8,9,11,10,7,15,15,14,17,24,24,21,13,19,27,25,29,26,44,44,29,46]
14:46:15 <lambdabot>  [1,2,3,5,6,7,8,9,10,11,13,14,15,17,19,21,24,25,26,27,29,44,46]
14:46:20 <glguy> dcoutts: so it pays a performance penalty along the way
14:46:23 <Cale> @oeis 1,2,3,5,6,7,8,9,10,11,13,14,15,17,19,21,24,25,26,27,29,44,46
14:46:24 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
14:46:41 <Cale> er, right
14:46:42 <mrd> @oeis 0 1 3 8 15
14:46:42 <lambdabot> Rounded volume of a regular tetrahedron with edge length n.
14:46:42 <lambdabot> [0,0,1,3,8,15,25,40,60,86,118,157,204,259,323,398,483,579,687,808,943,1091,12...
14:46:50 <ceibe> upload*
14:47:05 <mrd> @oeis 0 1 3 8 15 24 35 48
14:47:06 <lambdabot> Sequence allows us to find X values of the equation: X^3 - (X + 1)^2 + X + 2 ...
14:47:06 <lambdabot> [0,1,3,8,15,24,35,48,63,80,99,120,143,168,195,224,255,288,323,360,399,440,483...
14:47:07 <dcoutts> glguy: sorry, what's the primary difference?
14:47:09 <mrd> heh
14:47:24 <glguy> dcoutts: the one in cabal will parse invalid code points
14:47:26 <sw17ch> @hoogle liftM
14:47:26 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
14:47:26 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:47:26 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
14:47:29 <glguy> dcoutts: and overlong sequences
14:47:55 <sclv_> @oeis 0 1 4 21 37 95
14:47:55 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
14:48:04 <glguy> i.e. using 3 bytes to encode a \NUL
14:48:04 <ceibe> Cale, hp2ps output: http://www.mediafire.com/?xjm3swmglhm , prof file : http://www.mediafire.com/?ii4rzsidlt9
14:48:04 <lambdabot> Title: practica1.ps
14:48:05 <dcoutts> glguy: ah, that's not good
14:48:25 <dcoutts> glguy: we want to make sure that .cabal files are exactly valid utf8
14:48:42 <glguy> dcoutts: it also excepts surrogate pairs characters
14:48:47 <Cale> @oeis 1,2,3,3,4,6,7,6,6,9,10,7,8,9,12,10,15
14:48:47 <lambdabot> Arithmetic means of divisors of arithmetic numbers (arithmetic numbers, A0036...
14:48:47 <lambdabot> [1,2,3,3,4,6,7,6,6,9,10,7,8,9,12,10,15,9,16,12,12,19,15,14,21,12,22,14,13,18,...
14:48:52 <glguy> in the d8__ range
14:48:58 <glguy> dcoutts: which are invalid
14:49:04 <glguy> and used in utf16
14:49:06 <mauke> surrogates? in utf8?
14:49:30 <dcoutts> glguy: I though surrogate pairs was just a utf16 encoding issue
14:49:44 <dcoutts> glguy: for encoding code points outside the BMP
14:49:45 <glguy> dcoutts: their existence is now allowed in a utf8 stream
14:49:49 <glguy> not*
14:50:00 <Cale> ceibe: Okay, so most of the time and allocation is being spent on the prettyprinter.
14:50:11 <Cale> ceibe: Do you have the .hp file as well?
14:50:30 <ceibe> do you wan the hp file?
14:50:33 <glguy> U+FFFF and U+FFFE are illegal too
14:50:38 <Cale> yes
14:50:55 <dcoutts> glguy: perhaps I should just copy the utf8-string code into cabal, they're both bsd3
14:51:15 <glguy> dcoutts: that's the beauty of the license
14:51:34 <glguy> maximized community benefit
14:51:46 <Cale> prettyPrintWithSPL  Main  entries:7892  individual: %time: 86.3  %alloc: 91.5   inherited: %time: 88.0  %alloc: 92.9
14:51:58 <dcoutts> glguy: I might send you some performance patches, do you have any tests to check it validates properly?
14:52:06 <glguy> http://www.faqs.org/rfcs/rfc3629.html " The definition of UTF-8 prohibits encoding character numbers between
14:52:07 <lambdabot> Title: RFC 3629 (rfc3629) - UTF-8, a transformation format of ISO 10646
14:52:08 <glguy>    U+D800 and U+DFFF, which are reserved for use with the UTF-16
14:52:10 <glguy>    encoding form (as surrogate pairs) and do not directly represent
14:52:12 <glguy>    characters.
14:52:20 <glguy> dcoutts: I do
14:52:39 <glguy> in the tests directory
14:52:39 <dcoutts> glguy: I didn't realise the code point space was sparse
14:52:58 <glguy> the tests might not pass in the darcs repo because I'm not handling 5/6 byte streams atm
14:53:01 <Cale> However, that doesn't tell us what actually took up the most memory, just what did the most allocation. The hp will tell us more about what was actually holding on to memory for the life of the program.
14:53:04 <glguy> but everything else should
14:53:23 <glguy> dcoutts: I do an exhaustive test on valid characters and a boundary test on the rest
14:53:49 <sw17ch> newbie question, if I have an IO Integer and i want it to be an Integer... how would i do that
14:54:00 <Cale> sw17ch: You run the action, as part of another IO action
14:54:11 <mauke> sw17ch: do { i <- mi; ...
14:54:13 <Cale> sw17ch: So, in a do-block, you write  x <- myIOInteger
14:54:19 <dcoutts> glguy: do you think it's really necessary to explicitly handle 5/6 encodings and reject them as a single char?
14:54:22 <Cale> and thereafter, x is an Integer
14:54:25 <ceibe> Cale, the hp file: http://www.mediafire.com/?fnmjxz9y02t
14:54:25 <lambdabot> Title: practica1.hp
14:54:48 <glguy> dcoutts: The error case behavior is rather unspecified and up to debate
14:55:00 <sw17ch> oh, just found what i was looking for... :)
14:55:05 <sw17ch> i had size = hFileSize fh
14:55:10 <sw17ch> i wanted size <- ...
14:55:12 <sw17ch> duh...
14:55:12 <sw17ch> okay
14:55:14 <dcoutts> glguy: I'd go for the one with less code :-)
14:55:54 <Cale> ceibe: Okay, so it really is anchura_loop which is hanging on to memory for a long time.
14:56:55 <ceibe> Cale, the memory problem only occurs when I log the opened nodes list of each step
14:57:27 <ceibe> in this execution there are a list of 7892 node lists
14:57:56 <Cale> ceibe: If you want to see the same thing I'm looking at, run hp2ps practica1.hp, and load the resulting file up in your favourite postscript viewer.
14:58:10 <ceibe> yes, I did it
14:58:18 <mux> isn't there anyway to have a type synonym that contains universally quantified type variables?
14:58:42 <mux> ie: type ReadCallback = Ptr a -> Int -> IO Int
14:58:49 <Cale> ceibe: So it pretty quickly gets to 120 MB or so, and then levels off.
15:00:03 <ceibe> Cale, yes, it's "strange", when I run it, it takes some time without print anything, the memory increases, and after this time the program starts to print all the log info and the memory use stop to increase, but no decrease
15:02:15 <ceibe> Cale, it is normal? I expect that since the program print a entry of the log, this entry will never be used, so can be garbaged
15:02:17 <Cale> ceibe: what happens if you just comment out the call to regStep?
15:02:36 <Cale> ceibe: Does the thing run in a sane amount of memory again?
15:03:13 <Cale> (that is, don't 'tell' anything)
15:03:48 <ceibe> Cale, when I comment the regStep call program finish quickly and use very few memory
15:03:55 <Cale> ceibe: Okay.
15:03:55 <ceibe> I generate the profile and hp
15:03:57 <ceibe> for this case
15:04:25 <Cale> ceibe: The problem is, I think, that recording the length of n_succs forces n_succs to be fully evaluated.
15:04:42 <Cale> This is because you'
15:04:51 <Cale> you're storing it in a strict datastructure
15:04:59 <Cale> and well, length forces things
15:05:11 <Cale> (it forces the whole spine of that list)
15:05:34 <ddarius> mux:  i.e. type ReadCallback a = Ptr a -> Int -> IO Int or i.e. type ReadCallback = forall a. Ptr a -> Int -> IO Int ?
15:05:35 <ceibe> Cale, uhmm I'm not sure
15:05:46 <mux> ddarius: the latter
15:05:59 <ceibe> Cale, if I change the regStep call with  "regStep (length n_succs) 1 []"
15:06:10 <ceibe> the program runs with low memory use
15:06:25 <Cale> ah, okay
15:06:33 <Cale> How long are the lists?
15:06:40 <ceibe> ... very long
15:06:45 <mux> ddarius: it's just so that I don't have huge types to repeat
15:07:00 <gio123> does somebody knows what is polyparse -any?
15:07:21 <mux> gio123: it's a package of parsing combinators yuo can find on hackage.haskell.org
15:07:44 <mux> the -any means what you are trying to build has a dependency on any version of thye polyparse package
15:08:20 <Cale> ceibe: Well, it might be that recording the head of each of the paths in the log means that they can't be garbage collected until the log itself is printed.
15:08:21 <gio123> does somebody knows what is polyparse -any?
15:08:28 <ceibe> Cale, 7892 lists, and each list is long too, could have hundred or  thousands of elements
15:08:44 <dcoutts> gio123: polyparse is a parser package, you can find it on hackage
15:08:58 <gio123>  runhaskell Setup configure --user
15:09:03 <Cale> actually, let's try strictifying that map, just for fun
15:09:04 * dcoutts notices mux said that already
15:09:09 <gio123> after i am giveing this order
15:09:16 <gio123> i am geting messige
15:09:19 <gio123> warnning
15:09:30 <gio123> and
15:09:43 <gio123> missing polyparse -any
15:10:00 <Cale> So rather than storing (map head paths) in the log, or [head p1, head p2, ...], we'll store the actual heads of the paths :)
15:10:07 <mux> ddarius: so, any ideas?
15:10:21 <Cale> That way, if for any reason the rest can be reclaimed, it will be.
15:11:42 <Cale> let ps = List.map head paths
15:11:46 <ceibe> Cale, make it strict with seq?
15:12:07 <Cale> foldr seq () `seq` regStep (length n_succs) 1 ps
15:12:11 <Cale> er
15:12:16 <Cale> foldr seq () ps `seq` regStep (length n_succs) 1 ps
15:12:18 <gio123> missing polyparse -any
15:13:36 <shepheb> if I'm running xmonad, and rebuilt it, can I install while running?
15:13:37 <Cale> That is, we'll force all the elements of the list ps, so each (head p) expression should be evaluated before regStep
15:14:18 <ceibe> Cale, I'm running it again
15:14:46 <Cale> ceibe: You should be able to tell in a minute or so if it's doing the same thing.
15:15:20 <Cale> Now, it's still going to hang on to all of those lists...
15:15:35 <Cale> and that means hanging on to lots of PStates
15:15:46 <dcoutts> gio123: have you tried installing polyparse? or are you saying you did install it and are still getting the error?
15:15:50 <Saizan> shepheb: you've to rm manually the previous binary so cabal can install the new, and if you've a recent version i'm not sure if mod-q will start the new binary
15:15:52 <ceibe> Cale, the memory use don't change ;/ >20% of 2G
15:16:07 <Cale> ceibe: okay
15:16:12 <Cale> ceibe: I half-expected that.
15:16:37 <gio123> dcoutts: I instaled cygwin
15:16:44 <shepheb> Saizan: okay, thanks. I actually don't want to mod+q it, I want to debug my new xmonad.hs that relies on local changes to the core.
15:16:58 <gio123> dcoutts: GHC
15:17:09 <dcoutts> gio123: and what about installing the polyparse library?
15:17:16 <gio123> dcoutts: HaXml
15:17:20 <ddarius> mux: With extensions, both of those are legal.
15:17:38 <gio123> dcoutts: I am now trying to instal HaXml
15:17:45 <mux> ddarius: oh, cool. do you happen to know which extension that is?
15:17:46 <Cale> ceibe: Do you really have to log so much?
15:18:08 <ceibe> Cale, yes, I must do it
15:18:17 <ceibe> it's a requirement
15:18:27 <ddarius> mux: Probably -XRankNTypes will do it and be necessary.
15:18:37 <Cale> Okay, what happens if you print only the log, or print the log first?
15:18:41 <ddarius> Maybe just rank 2.
15:19:09 <mux> ddarius: yeah, those two work, thank you
15:19:42 <gio123> dcoutts: I am now trying to instal HaXml
15:19:48 <dcoutts> gio123: so HaXml requires the polyparse library so you'll have to install that too
15:19:50 <Cale> ceibe: I'm fairly convinced by these results that it's not so much large thunks hanging around, but just that the log is absolutely huge. How large is the final log?
15:19:51 <ddarius> type ReadCallback a = Ptr a -> Int -> IO Int is Haskell 98 though
15:19:53 <gio123> and getting that warnning
15:20:18 <gio123> dcoutts: they does not say it
15:20:20 <dcoutts> gio123: it's not a warning it's saying it requires that other library, so you must go an install polyparse, understand?
15:20:28 <gio123> dcoutts: http://taichi.ddns.comp.nus.edu.sg/taichiwiki/Download_and_compile_XHaskell
15:20:31 <lambdabot> Title: Download and compile XHaskell - TaichiWiki, http://tinyurl.com/yszkoc
15:20:33 <hpaste>  ceibe pasted "problem logging 2" at http://hpaste.org/5964
15:21:01 <mux> ddarius: I know, but that wouldn't be so nice; this is just to present a similar type than hPutBuf/hReadBuf and because it's more semantically correct to have a Ptr a as a buffer
15:21:04 <Cale> ceibe: hm?
15:21:07 <gio123> dcoutts: I am getting this message as well warning: the field "hs-source-dir" is deprecated, please use "hs-source-dir" .........
15:21:10 <ceibe> Cale, the printing functions
15:21:17 <Cale> ah, okay
15:21:22 <dcoutts> gio123: note on that page it says you need HaXml 1.13.x but it sounds like you're trying to install a much later version, what version of HaXml are you trying to install?
15:21:24 <mux> ddarius: qualifying the callback type with the type of the buffer wouldn't be of any use
15:21:35 <ceibe> Cale, I go to calculate the number of nodes of the log
15:21:36 <dcoutts> gio123: don't worry about that warning
15:21:45 <Cale> ceibe: That's okay.
15:21:53 <Cale> ceibe: So you're at least printing those first.
15:21:58 <dcoutts> gio123: make sure you're installing HaXml version 1.13.3
15:22:13 <Cale> ceibe: What is a PState?
15:22:18 <gio123> dcoutts: HaXml-1.19.2.tar
15:22:49 <dcoutts> gio123: right, and the page you just linked to says "System Requirement: HaXml 1.13.x (1.17 will be supported soon)"
15:23:05 <gio123> ah
15:23:11 <gio123> i see thanks
15:23:26 <dcoutts> gio123: you can find HaXml 1.13.3 on hackage
15:23:57 <hpaste>  ceibe pasted "PState related types and functions" at http://hpaste.org/5965
15:24:35 <ceibe> Cale, see it, it's a record
15:24:41 <Cale> ceibe: okay
15:24:54 <gio123> dcoutts: http://linux.wareseeker.com/screenshot/haxml-1.13.exe/330999
15:24:55 <lambdabot> Title: HaXml 1.13 Free Download
15:25:00 <gio123> is it what i have to download
15:25:01 <gio123> ?
15:25:03 <gbacon> I managed to build lambdabot, but when I fed it > 1 + 1, I get a broken pipe
15:25:11 <dcoutts> @hackage HaXml-1.13.3
15:25:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HaXml-1.13.3
15:25:15 <dcoutts> gio123: ^^
15:25:19 <gbacon> what did I hose?
15:25:58 <dcoutts> gio123: basically all haskell packages are on the hackage.haskell.org site
15:26:53 <monochrom> Totally bizarre.  Next, you'll find GHC binaries on BT. :)
15:27:43 <Adamant> it's always funny when people put open source software on warez sites.
15:27:44 <ceibe> I'm computing: putStrLn $ "Number of nodes in log: " ++ (show $ sum $ List.map length opened) , could take some minutes
15:28:32 <gio123> dcoutts: I am getting this message as well warning: the field "hs-source-dir" is deprecated, please use "hs-source-dir" .........
15:28:39 <gio123> only this message give snow
15:28:55 <ceibe> Cale, Number of nodes in log: 10088948
15:29:08 <mauke> gio123: are you sure it's not 'please use "hs-source-dirs"'?
15:29:08 <ceibe> 10 million
15:29:18 <Cale> ceibe: Okay, that could easily take up that much memory.
15:29:35 <dcoutts> gio123: that's not a problem, ignore it. Hope you can get it working, I've got to go to bed. G'night!
15:29:46 <ceibe> Cale, of course, the idea of use Writer is to generate list lazyly
15:29:48 <gio123> night
15:29:50 <gio123> thank u
15:29:50 <ceibe> to don't use all the memory
15:30:02 <ceibe> it isn't possible?
15:30:33 <Cale> ceibe: okay, but note that the log itself contains bits which can't be computed lazily.
15:30:45 <Cale> ceibe: In particular, you have those strict fields.
15:30:55 <idnar> @type (&&&)
15:30:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:31:21 <ceibe> Cale, well, all the stricness was added in a failed attemp to reduce memory usage
15:31:28 <ceibe> ;/
15:31:33 <Cale> ceibe: Yeah, that's not always the right thing to do :)
15:31:49 <Cale> But even if you didn't have those strict fields
15:31:54 <Cale> those two fields
15:32:14 <Cale> they're integers, and they're being added together.
15:32:28 <Cale> You can't know the value of either of them until the computation completely finishes.
15:32:39 <dons> dcoutts: yeah, its all in the instances -- and in the seemingly magic Word deriving Eq,Ord
15:32:47 <dons> if I write my own Ord instance, it works as excepted
15:33:02 <ceibe> Cale
15:33:11 <dons> ?bug
15:33:11 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:33:22 <Cale> hmm, it appears they're being printed after the rest of the log
15:33:23 <ceibe> uhm yes, I think in it, this is true for count* fields, but not for openedNodes
15:33:33 <ceibe> opened could be obtained on demand
15:33:42 <ceibe> yes
15:34:01 <Cale> However, with those strictness annotations there, they'll get forced on construction regardless.
15:34:15 <Cale> hmm
15:34:41 <Cale> Just for fun, try replacing them with lists of Int values, and remove the strictness annotations.
15:35:07 <Cale> (so, on a tell, we'll tell a singleton list, like you're doing with the openedNodes already)
15:35:22 <ceibe> ok, moment
15:36:42 <ceibe> running
15:37:54 <ceibe> now uses more memory than before
15:38:06 <Cale> okay, but I think it's still a step in the right direction
15:38:14 <Cale> You want to make things lazier, not stricter.
15:38:21 <ceibe> yes
15:39:24 <ceibe> now uses 10% more of memory
15:39:38 <Cale> But it's not printing any of the steps as it goes?
15:40:11 <ceibe> sorry, I comment this lines to make it faster, I will proof it now
15:42:18 <ceibe> no, it do the same thing, takes a time wihout print any info and increasing memory usage
15:42:23 <Cale> okay
15:42:28 <Cale> hmm
15:42:43 <ceibe> remove all strictness anotations?
15:43:15 <gio123> $ runhaskell setup configure --user
15:43:15 <gio123> Warning: The field "hs-source-dir" is deprecated, please use "hs-source-dirs"
15:43:15 <gio123> Configuring HaXml-1.13.3...
15:43:50 <Cale> yes, certainly
15:44:02 <gio123> why this warning comes?
15:44:07 <gio123> can somebody tell me
15:44:50 <ceibe> Cale, "foldr seq () os `seq` regStep (length n_succs) 1 os" too?
15:45:02 <Cale> oh, yes, you don't want that
15:45:04 <ceibe> (I change ps for os, I use ps for another thing)
15:45:41 <Cale> In fact, that might be what's holding it up.
15:47:16 <gio123> $ runhaskell setup configure --user
15:47:16 <gio123> Warning: The field "hs-source-dir" is deprecated, please use "hs-source-dirs"
15:47:16 <gio123> Configuring HaXml-1.13.3...
15:47:35 <gio123> can somebody tell me
15:47:40 <gio123> why this warning comes?
15:48:01 <ceibe> Cale, do the same ;/
15:49:12 <Cale> ceibe: Can I have enough of your code that I can compile it myself?
15:49:57 <ceibe> Cale, yes, if you don't publish it :P my University friends could copy it ;P
15:49:59 <Cale> I'd like to run ghci's debugger on it and see where it's getting stuck. It ought to be able to produce the first log entry really quickly.
15:50:03 <Cale> sure
15:51:59 <Cale> after all, the first thing that anchura_loop does is to define n_succs and do a tell, so the first entry of the log should be available right then.
15:54:02 <ceibe> one sec
15:55:14 <gwern> anything interesting happen t'day in haskell-land?
15:56:19 <dolio> It was revealed that Haskell is a failure, because C++ templates give you more type safety and clearer code in most cases.
15:56:38 <mauke> don't make me paste C++ headers here
15:57:03 <olsner> "more type safety", heh, templates are dynamically typed, only they're executed at compile time
15:57:19 <gwern> dolio: oh goddamn it. now I have to learn *another* language?
15:57:35 <gwern> well, if Wadler says C++ is the way to go, I guess I have no choice
15:57:53 <jacobian_> lol
15:57:53 <Saul_> Well technically a language with only one type is type-safe
15:58:08 <dolio> Not Wadler. Someone much more sagely.
15:58:23 <Saul_> Who is more sagely than Wadler?
15:58:28 <Cale> ceibe: aha!
15:58:32 <dolio> @quote qwe1234 clearer.code
15:58:32 <lambdabot> No quotes match. I've seen penguins that can type better than that.
15:58:40 <ceibe> Cale, do you find the problem?
15:58:43 * gwern seconds Saul_, no one can outsage Wadler
15:58:46 <Cale> ceibe: I think so
15:58:52 <dolio> @quote qwe1234 clearer
15:58:52 <lambdabot> qwe1234 says: For the majority of tasks, C++ templates produce code that is clearer and better type-checked [than Haskell].
15:58:55 <gwern> except maybe Motti or Pierce
15:58:58 <Cale> ceibe: You're doing a pattern match in mappent
15:59:00 <mauke> http://mauke.ath.cx/stuff/c++/awesome/malloc.hh
15:59:01 <Cale> mappend*
15:59:15 <Excedrin> "clearer code" for values of code equal to "encryption"
15:59:19 <Cale> ceibe: Stick a ~ before each of the AnchuraLog's you're matching against.
15:59:28 <ceibe> oh, a lazy pattern matching
15:59:31 <Cale> yes
15:59:32 <Cale> :)
15:59:48 <dolio> Wow. Now that file definitely wasn't written with 8-column tabs in mind.
15:59:58 <ceibe> do you want the code so?
16:00:07 <ceibe> well I go to check it
16:00:07 <mauke> 4 SPACE TABS
16:00:32 <gwern> SPACES FTW
16:00:46 * ivanm agrees with gwern 
16:01:19 <ceibe> :O
16:01:20 <ceibe> fuck
16:01:23 <ceibe> you have reason
16:01:28 <olsner> mauke: a wonder of clarity!
16:01:38 <mauke> olsner: yes, this one is rather tame
16:01:47 <ceibe> Cale, it works!
16:02:06 <olsner> I assume you've built lisp in templates too?
16:02:28 <mauke> hah, no
16:02:56 <ceibe> Cale, lot lot lot of thanks, I was some days trying to solve it
16:03:22 <ceibe> strictness is evil
16:03:34 <mauke> all this code does is Foreign.Marshal.Alloc.{malloc,realloc,free}
16:03:55 * MyCatVerbs is very tempted to start following Torvalds' advice: 8-space tabs, and if your indentation is deep enough to make that problematic for you then take that as a sign that you need to learn to effin' program.
16:04:23 <mauke> I have a big screen
16:04:49 <cjb> mauke: how big?  :)
16:05:06 <mauke> 19
16:06:31 <cjb> mauke: ah.  I think I like big screens more than you like big screens :)
16:09:38 <largos> does anyone know what's going on with happs.org? (or where I can find a happs tarball / or .deb? :)
16:10:01 <olsner> cabal install maybe?
16:11:31 <MyCatVerbs> mauke: I can go one better...
16:11:49 <MyCatVerbs> mauke: because I have a tiny font, and a reasonable albeit not huge screen.
16:12:33 <MyCatVerbs> mauke: however, small font. I set all my terminals to use the 9x15 console font, so I pull something like 144 columns on a 1280x1024 LCD. ^_^
16:13:05 * cjb == http://chris.printf.net/pullcord-photo.jpg
16:13:38 <mauke> 159 columns here in a full screen terminal, big font
16:14:18 <MyCatVerbs> mauke: 16:9 or 16:10?
16:15:03 <sw17ch> 262 columns...
16:15:28 <sw17ch> eterm with Font 1
16:15:30 <mauke> 62 lines
16:15:33 <olsner> I use 6x12 on a 1600x1200 screen, 262 columns by 94 lines when accounting for window trim and panels
16:15:35 <MyCatVerbs> mauke: oh and 66 rows here, which isn't the best thing ever but reasonably decent.
16:15:46 <olsner> Terminus font btw, really nice
16:15:48 <MyCatVerbs> olsner: fuuuu... nice.
16:16:07 <cjb> hey, we should have a #haskell screenshot day
16:16:19 <Saizan> largos: happs.org should be up again soonish, tarballs are on hackage.haskell.org
16:16:20 <MyCatVerbs> Ahhh, 6x12. Also Terminus.
16:16:27 <MyCatVerbs> I find both too small to actually read.
16:16:39 <largos> Saizan: cool, thanks
16:16:41 <MyCatVerbs> Well, read comfortably, anyway.
16:16:43 <cjb> (we just need somewhere to collate everyone's screenshot into a webpage)
16:17:07 <sm> omg.. what would I do if I could see that much code
16:17:14 <mauke> does terminus have this character
16:17:26 <ddarius> sm: Have a lot of blank space on the right.
16:17:42 <olsner> I actually find 6x12 kind of tall - I
16:17:50 <olsner> @quote prcs
16:17:50 <lambdabot> No quotes match. The more you drive -- the dumber you get.
16:17:56 <olsner> @quote pcrs
16:17:56 <lambdabot> pcrs says: Premature carriage ret
16:18:08 <sm> I could see the whole program. bizarre thought.
16:18:30 <mauke> http://img86.imageshack.us/my.php?image=screenshotmf5.png <- my screen
16:18:33 <ddarius> sm: Write smaller programs and you'll be able to see the whole program on 80x24
16:18:34 <blargeyfarg> or abuse xmonad to see lots of partial programs ;)
16:19:26 <MyCatVerbs> "Write smaller programs" <-- why I love Haskell.
16:19:32 <MyCatVerbs> Well, part of it.
16:19:50 <MyCatVerbs> I mean, if it was just golfing, I'd go for Perl or Scheme with a lot of macros. >_>
16:20:13 <ddarius> It's not uncommon for Haskell to beat Perl at golfing.
16:20:23 <mauke> huhu
16:20:34 <mauke> you're invited to try the golf problems at spoj.pl in haskell
16:21:13 <mauke> http://www.spoj.pl/problems/KAMIL/  http://www.spoj.pl/problems/SIZECON/  http://www.spoj.pl/problems/BRAINF_K/
16:21:15 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem KAMIL
16:21:22 <cjb> everyone should go ahead and throw their screenshots onto imageshack, and I'll collate them on a webpage later.  it's fun to see what other people's working environment looks like.
16:22:00 * ddarius runs xmonad fullscreen with no borders or gaps or anything.
16:22:50 <MyCatVerbs> ddarius: why no one-pixel border?
16:22:50 <mauke> you might have a chance in BRAINF_K; there's one haskell program in the top 20
16:23:38 <ddarius> MyCatVerbs: Why would I have it?  It just removes two pixels of screen space vertically and horizontally each and it looks like ass if I want to watch a movie.
16:23:45 <MyCatVerbs> ddarius: as much as I'd love to lose the gap, if I don't have dzen visible at all times I tend to really really lose track of time and do stupid shit as a result.
16:24:06 * ddarius uses xchat to keep track of time or his cellphone.
16:24:41 <MyCatVerbs> Xchat? And you worry about two pixels of screen real-estate?
16:24:52 <adu> is golf something other than what I'm thinking about?
16:24:58 <MyCatVerbs> Buuuu, irssi in a huge fullscreen terminal with a tiny font!
16:25:20 <MyCatVerbs> adu: "golfing" in programming is where you try to write a program with the fewest number of symbols possible.
16:25:32 <ddarius> xchat isn't the only piece of software I use.  But at full screen why would I want a border?
16:25:52 <MyCatVerbs> adu: Perl is quite good at it because of the sheer number of shortcuts in the syntax.
16:26:25 <MyCatVerbs> ddarius: at fullscreen sure, but personally, I do tend to have more than one thing open at least a third of the time.
16:26:27 <adu> MyCatVerbs: ooooo that is different than what I was thinking!
16:26:44 <MyCatVerbs> ddarius: admittedly I'd be much better off getting a second monitor for the extra stuff (usually documentation).
16:26:49 <adu> MyCatVerbs: like $&->_
16:26:50 <ddarius> Anyway, I only need a few lines worth of text to be visible at a time for IRC.  The amount I actually have is more than enough.
16:27:02 <mauke> adu: syntax error at >
16:27:07 <MyCatVerbs> adu: Haskell is particularly good at it because of how compactly you can define powerful combinators. :)
16:27:14 <ddarius> MyCatVerbs: I always have at least five things running.  They are just in different workspaces.
16:27:47 <adu> MyCatVerbs: like the "primes = nubBy (((>1).).gcd)..." trick?
16:28:05 <mauke> exactly
16:28:12 <adu> i love that
16:28:18 <MyCatVerbs> adu: yes, but it's even better over larger programs because you can get more purchase with silly combinators.
16:28:23 <sw17ch> I have a list, [IO Handle]... i want it to be [Handle]... i'm not quite sure how to do that :)
16:28:31 <sw17ch> i'm looking at mapM, but i don't think that's what i want
16:28:32 <mauke> adu: do you know the fizzbuzz problem?
16:28:33 <mrd> sequence
16:28:36 <mrd> er
16:28:37 <ddarius> :t sequence
16:28:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:28:40 <mrd> yea
16:28:44 <adu> mauke:  nope, whats that?
16:29:09 * mrd type-checks from the gut
16:29:30 <mauke> adu: http://tickletux.wordpress.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/
16:29:31 <lambdabot> Title: Using FizzBuzz to Find Developers who Grok Coding  Imran On Tech, http://tinyurl.com/2v344s
16:29:45 <MyCatVerbs> > map (\x -> case gcd x 15 of { 3 -> "fizz"; 5 -> "buzz"; 15 -> "fizzbuzz"; x -> show x; }) [1..]
16:29:46 <lambdabot>  ["1","1","fizz","1","buzz","fizz","1","1","fizz","buzz","1","fizz","1","1","...
16:29:59 <MyCatVerbs> ...doh.
16:30:07 <mrd> oh no, not fizzbuzz
16:30:23 <MyCatVerbs> > concatMap (\x -> case gcd x 15 of { 3 -> "fizz"; 5 -> "buzz"; 15 -> "fizzbuzz"; y -> show y; }) [1..]
16:30:23 <lambdabot>  "11fizz1buzzfizz11fizzbuzz1fizz11fizzbuzz11fizz1buzzfizz11fizzbuzz1fizz11fiz...
16:30:40 * MyCatVerbs blinks and suspects he is doing something wrong there.
16:30:59 <MyCatVerbs> > concatMap show [1..]
16:30:59 <lambdabot>  "123456789101112131415161718192021222324252627282930313233343536373839404142...
16:31:24 <MyCatVerbs> Oh right. \y -> show x, not \y -> show y. Oops.
16:31:27 <pjd> > show =<< [1..]
16:31:27 <lambdabot>  "123456789101112131415161718192021222324252627282930313233343536373839404142...
16:31:40 <ddarius> > concatMap show [1..60] -- scratch out 100 digits of this number to make the smallest and the largest number.
16:31:41 <lambdabot>  "123456789101112131415161718192021222324252627282930313233343536373839404142...
16:31:44 <MyCatVerbs> pjd: ooh, handy.
16:31:56 <mauke> one particular golf problem was: do fizzbuzz for the range 1 .. 32
16:32:08 <mauke> solution: print"F"x!($_%3).b x!($_%5)||$_ for 1..32
16:32:27 <mauke> change F to Fuzz and b to buzz for full compliance
16:32:30 <MyCatVerbs> mauke: *blinkblink*
16:32:44 <MyCatVerbs> mauke: does that... does that change meaning if you make a mistake in the whitespace there?
16:33:01 <mauke> you mean if you remove the spaces?
16:33:25 <olsner> what does the ! operator do in perl?
16:33:31 <mauke> olsner: "not"
16:33:32 <gnuvince_> olsner: not
16:34:04 <olsner> oh, wait, x in perl is an *operator* not an identifier
16:34:42 <olsner> I think I understand how it works it now
16:34:43 <MyCatVerbs> mauke: no, that'd obvious smush the identifiers. I mean if you added spaces.
16:34:58 <mauke> depends on where you add them
16:35:15 <mauke> print "F " x ! ( $ _ % 3 ) . b x ! ( $ _ % 5 ) || $ _ for 1 .. 32  # should still work
16:35:50 <MyCatVerbs> mauke: waitasecond, how does that work when there are no 'i's or 'z's in thar?
16:36:05 <sw17ch> @src zipWithM
16:36:05 <lambdabot> zipWithM f xs ys = sequence (zipWith f xs ys)
16:36:15 <mauke> <mauke> change F to Fuzz and b to buzz for full compliance
16:36:21 <mauke> except I meant Fizz
16:36:29 <olsner> does perl silently coerce the identifier buzz into the string "buzz"?
16:36:38 <mauke> olsner: by default, yes
16:36:43 <mauke> it's a shell "feature"
16:38:52 <allbery_b> yeh, perl5 has that ugly barewords thing.
16:39:10 <mauke> I'm tempted to explain what exactly 'use strict' does but that's not really on-topic here
16:40:12 <sm> ah go on
16:40:20 <MyCatVerbs> mauke: it makes Larry get all pissy about your golfing attempts?
16:40:48 <mauke> heh
16:41:02 <adu> > let fb x | (x `mod` 15 == 0) = "FizzBuzz," | (x `mod` 5 == 0) = "Buzz," | (x `mod` 3 == 0) = "Fizz," | True = "," in concat (map fb [1..100])
16:41:03 <lambdabot>  ",,Fizz,,Buzz,Fizz,,,Fizz,Buzz,,Fizz,,,FizzBuzz,,,Fizz,,Buzz,Fizz,,,Fizz,Buz...
16:41:37 <mauke> if you really care about perl/strict, ask me in #haskell-blah
16:41:51 <allbery_b> actually, modern perl style strongly disapproves of barewords except in certain specific contexts (namely hash keys) (and perl6 makes those go away too)
16:42:18 <adu> what is "barewords"?
16:42:40 <allbery_b> in perl5, an identifier not otherwise declared is taken as a literal string
16:42:49 <mauke> basically, an identifier that is not a keyword
16:43:19 <MyCatVerbs> @pl \y x -> (x `mod` y) == 0
16:43:19 <lambdabot> flip flip 0 . ((==) .) . flip mod
16:43:33 <allbery_b> so unless I've opened foo as a filehandle, if I use the identifier foo somewhere it's taken as "foo" the string
16:43:34 * MyCatVerbs blinks at that.
16:43:50 <mauke> allbery_b: no
16:43:50 <MyCatVerbs> @pl \x y -> (x `mod` y) == 0
16:43:50 <lambdabot> flip flip 0 . ((==) .) . mod
16:44:02 <mauke> allbery_b: opening filehandles is a runtime thing; it doesn't affect the parser
16:44:34 <allbery_b> it does, to the extent that if the parser has *seen* me use foo in a non-bareword context, it will recognize it as not a bareword
16:44:37 <allbery_b> klater
16:44:57 <mauke> nope
16:45:18 <allbery_b> this is one of the reasons barewords are strongly deprecated; the meaning potentially changes if you change an unrelated part of the program
16:45:29 <MyCatVerbs> allbery_b: that is possibly the most suicidal programming language feature I have ever heard of.
16:45:39 <allbery_b> exactly
16:45:40 <mauke> that only happens if you create a subroutine with that name
16:45:57 <MyCatVerbs> allbery_b: except for the / thing, which has the nice side effect of making parsing Perl equivalent to the halting problem.
16:46:14 <mauke> that's also a subroutine problem :-)
16:46:19 <MyCatVerbs> allbery_b: and which has the added bonus that lwall himself has declared that that is precisely how he likes it.
16:46:21 <allbery_b> (specifically, using it as the first argument to print will make the parser treat as a filehandle)
16:46:41 <allbery_b> or other functions that use the IO slot (also strongly deprecated these days)
16:46:47 <MyCatVerbs> Oh and global variables by default instead of local. Ewwwwww, for Pete's sake, that is precisely what Algol was supposed to have rescued us from.
16:46:50 <wagle_home> the obvious thing to do is to implement a turing machine in a perl regexp
16:46:52 <allbery_b> erm.  "indirect object slot"
16:47:35 <mauke> MyCatVerbs: explicit local variables are a Good Thing
16:47:36 <allbery_b> meaning, I/O functions, sort, map, and predeclared methods
16:47:47 <allbery_b> (and probably a few others)
16:47:51 <mauke> ITYM non-predeclared methods
16:47:51 <MyCatVerbs> wagle_home: IIRC the problem is that / sometimes acts as a comment delimiter, and sometimes it doesn't. Whether it does or does not at any particular point in time can apparently change at run time.
16:47:58 <gwern> sw17ch: oh noes, you want to escape from the IO monad? that's unsafe
16:48:01 <mauke> if it's predeclared, it becomes a normal function
16:48:12 <MyCatVerbs> mauke: ITYM?
16:48:16 <sw17ch> gwern, actually... .seems it was much easier than i was making it
16:48:19 <mauke> "I think you mean(t)"
16:48:23 <gwern> halp, Is trapped in the IO monad
16:48:25 <sw17ch> i was using zipWith which produced a IO Handle
16:48:28 <allbery_b> mauke: methods, not functions
16:48:30 <sw17ch> so, i changed it to zipWithM
16:48:32 <sw17ch> and all was happy
16:48:42 <mauke> allbery_b: methods are functions. what do you mean by "predeclared method"?
16:48:50 <monochrom> http://arcanux.org/lambdacats.html#entry1
16:48:50 <lambdabot> Title: Lambdacats
16:49:05 <wagle_home> i thought use (strict) ; was supposed to save you from implicitly declared vars
16:49:11 <mauke> wagle_home: it does
16:49:23 <MyCatVerbs> mauke: eh? How's global scope by default a good thing?
16:49:23 <adu> is there a function that goes from (a,b,c) -> (a,(b,c)) ?
16:49:29 <mauke> MyCatVerbs: / can be the division operator or the beginning of a regex (a quoted construct)
16:49:29 <allbery_b> I'm talking about `foo bar' meaning `bar->foo'
16:49:38 <wagle_home> MyCatVerbs, what default?
16:49:39 <mauke> allbery_b: yeah, that only works if foo is not declared
16:50:06 <allbery_b> the indirect object and barewords interact oddly, that's one of the ways that barewords can suddenly become not-barewords
16:50:10 <mauke> MyCatVerbs: "closures" or whatever the right word is. you want an inner scope to have access to its surrounding lexical scope
16:50:12 <MyCatVerbs> wagle_home: yes, write $foo = 42 assigns the Great Answer to a global variable called foo.
16:50:28 <allbery_b> it is complex and *very* ugly
16:50:37 <ray> > let f (a,b,c) = (a,(b,c)) in f (1,2,3)
16:50:37 <lambdabot>  (1,(2,3))
16:50:43 <wagle_home> how did you declare foo?  use (strict) forces you to declare its scope
16:50:44 <MyCatVerbs> wagle_home: to get a local variable foo to have the Great Answer in it, one writes "my $foo = 6*9"
16:50:50 <adu> ray: heh ok, I guess thats a no
16:50:50 <monochrom> http://arcanux.org/lambdacats_2.html#entry2
16:50:50 <lambdabot> Title: Lambdacats
16:50:51 <mauke> allbery_b: I fully agree. I never use indirect object notation if I can avoid it
16:51:24 <allbery_b> and that's what I meant when I said that that kind of thing could affect the parser, not just runtime.
16:51:43 <MyCatVerbs> mauke: uhhhh. Lexical closures are quite happily implemented in Scheme, Haskell and every other modern programming language that doesn't suck.
16:51:54 <allbery_b> really, it's all pretty horrible amd that's why both barewords and indirect object syntax are strongly deprecated
16:52:02 <mauke> MyCatVerbs: and all of them require you to say "let x = ..." (or equivalent) to get a local variable
16:52:08 <gwern> monochrom: my favorite lambdacat
16:52:12 <mauke> MyCatVerbs: implicitly local variables are evil
16:52:15 <monochrom> heh
16:52:20 <sw17ch> monochrom: hahaha, that's great
16:52:26 <MyCatVerbs> mauke: or are you after dynamic binding? If so, might I point out that the lisp crowd appear to have decided that that is a very suicidal idea, from empirical lectures at the School of Hard Knocks.
16:52:29 <allbery_b> implicit variables are evil, period
16:53:11 <mauke> sub curried_add { my $x = shift; sub { my $y = shift; $x + $y } }
16:53:51 * shepheb is partial to "oh noes teh impossibl just happende"
16:54:02 <MyCatVerbs> mauke: whoaaaa, I'm not after implicit variables of any form. But IMO declared variables scoped over the enclosing block are the way to go.
16:54:26 <gwern> MyCatVerbs: hah. although I wonder how much of that is from emacs/elisp being nigh impossible to port to a better lisp because ituses dynamic binding
16:54:43 <mauke> MyCatVerbs: right, and that's exactly what "use strict 'vars'" gives you
16:55:04 <mauke> well, 'my' gives you local variables and 'strict' disallows implicit globals
16:56:34 <MyCatVerbs> gwern: dunno. I thought much of the distrust people have for dynamic binding predates emacs' portability, though?
16:56:36 <MyCatVerbs> mauke: that's sane.
16:57:06 <MyCatVerbs> mauke: I'm guessing that's one of many reasons why "use strict isn't on by default" is considered one of Perl5's practically unfixable bugs?
16:57:24 <MyCatVerbs> gwern: not to mention its popularity.
16:57:28 <mauke> yeah
16:57:35 <mauke> too much legacy code
16:58:00 <gwern> MyCatVerbs: well, there have been several efforts to add a compatiblity package to scheme/common-lisp or an interpreation layer so you could just switch over and retain the legacy code, but the dynamic binding breaks it or totally kills the efficiency
16:58:19 <mauke> IMO javascript, php, python and c++ all get scoping wrong, for rather different reasons
16:58:58 <MyCatVerbs> mauke: you listed C++ but not C in there. What gives?
16:59:06 <ivanm> mauke: because they're not Haskell? :p
16:59:12 <gwern> 'all happy families are alike in their happiness, while all unhappy families are uniquely unhappy'
16:59:23 <mauke> MyCatVerbs: because C does it right
16:59:43 <mauke> C++ name resultion is bizarrely complex
16:59:51 <MyCatVerbs> ivanm: more likely because they failed to steal the correct semantics from Algol (and later Scheme).
16:59:59 <ivanm> heh
17:00:26 <MyCatVerbs> mauke: eh? I've lots and lots and lots and lots of reasons for not wanting to ever use C++ under any circumstances, but namespacing wasn't one I knew about.
17:00:54 <MyCatVerbs> Er, scoping, I mean.
17:00:54 <mauke> C++ isn't wrong in principle; it's just that there are too many rules that interact in weird and wonderful ways. well, and then there are templates
17:01:39 <mauke> A<sizeof (B)>::c ( d ); // you can't parse that without resolving sizeof (B), which requires pulling half of the compiler into the parser
17:01:46 <MyCatVerbs> mauke: mmm, not how I'd phrase it. There are too many rules that interact in wierd and unintuitive ways, creating bloody myriad edge cases for you to have to worry about... and also C++ is wrong in principle, too.
17:01:48 <Cale> @tell ceibe Good to hear that it worked! :) I had to go eat dinner.
17:01:48 <lambdabot> Consider it noted.
17:02:18 <MyCatVerbs> mauke: and then there are templates. ph33r!
17:02:32 <Cale> Well, that'll teach me to make patterns lazy when matching for mappend.
17:02:44 <MyCatVerbs> (Except I'd do the same with a lot more hand waving and eyebrow-waggling in person.)
17:03:18 <ivanm> .
17:03:24 <mauke> 
17:03:31 <ivanm> whoops, hit the keyboard
17:03:32 <Cale> 
17:03:43 <ivanm> Cale: show-off ;-)
17:03:49 <MyCatVerbs> mauke: heee, couldn't you use the templating mechanism to cause the compiler to run some Turing machine in the process of evaluating sizeof(B) there?
17:03:58 <mauke> MyCatVerbs: sure
17:04:03 <Cale> ivanm: mauke started it!
17:04:28 <mauke> real compilers have a very limited template stack, though
17:05:38 <Cale> ......
17:06:34 <mauke> .
17:06:43 <mauke> yay for the compose key
17:07:08 * thorat wishes vim digraphs would work in rxvt-unicode
17:07:53 <benny> there is always screen digraphs if you can fall back ;-P
17:08:18 <thorat> ah, I don't use screen anymore.  Are they the same as Vim's?
17:08:46 <thorat> Vim's are quite mnemonic.
17:10:55 <mauke> 
17:10:55 <MyCatVerbs> Fuck peer.
17:11:03 * MyCatVerbs whistles.
17:11:07 <gwern> @hoogle mainLoop
17:11:08 <lambdabot> No matches found
17:16:02 <mauke> screen digraphs look boring. no fancy unicode
17:16:18 <mauke> http://linuxwiki.de/screen/DiGraph
17:16:18 <lambdabot> Title: screen/DiGraph - LinuxWiki.org - Linux Wiki und Freie Software
17:17:23 <sw17ch> @hoogle hRead
17:17:23 <lambdabot> System.IO.hReady :: Handle -> IO Bool
17:17:23 <lambdabot> GHC.Conc.killThread :: ThreadId -> IO ()
17:17:23 <lambdabot> GHC.Conc.labelThread :: ThreadId -> String -> IO ()
17:17:27 <sw17ch> :(
17:18:23 <sw17ch> I'm looking for something to read n bytes out of a file Handle
17:18:26 <mauke> yeah, that sucks
17:18:32 <mauke> @hoogle hGetBuf
17:18:32 <lambdabot> System.IO.hGetBuf :: Handle -> Ptr a -> Int -> IO Int
17:18:32 <lambdabot> System.IO.hGetBuffering :: Handle -> IO BufferMode
17:18:32 <lambdabot> System.IO.hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
17:18:34 <sw17ch> similar to hRead :: Handle -> Integer -> IO String
17:27:17 <sm> is it possible to get an overview of hackage packages by license ?
17:28:56 <sm> answering myself: well, searching for BSD, GPL, LGPL gives 4, 126, 75 hits .. but I take that with a grain of salt
17:29:11 <n000b> need some help as it regards to the fold function in haskell. I realize that it is very powerful and there are some functions i need to rewrite in it
17:29:41 <n000b> namely the reverse, length, map and filter
17:30:24 <sm> BSD{,3,4} vs. {L,}GPL gives 64 vs. 201
17:30:52 <n000b> letterSplit Hello World  (HW,ello orld)
17:31:04 <n000b> have to be done using fold
17:31:08 <n000b> any help guys?
17:31:21 <mrd> did you write the functions recursively yet?
17:32:24 <dolio> sm: Don't forget OtherLicense. :)
17:33:03 <hpaste>  mmorrow annotated "Word/Int bad codegen" with "not unboxing Word?" at http://hpaste.org/5954#a1
17:33:03 <sm> 25
17:33:45 <hpaste>  mmorrow annotated "Word/Int bad codegen" with "my makefile" at http://hpaste.org/5954#a2
17:33:55 <sw17ch> how would i use hGetBuf to produce a string of part of a file
17:34:17 <sw17ch> @src hGetLine
17:34:17 <lambdabot> Source not found. I am sorry.
17:34:20 <dons> sw17ch: you'd use bytestrings, then take and drop
17:34:28 <hpaste>  mmorrow annotated "Word/Int bad codegen" with "Int.s" at http://hpaste.org/5954#a3
17:34:34 <dons> they wrap hGetBuf nicely
17:34:46 <sw17ch> dons: i haven't done any taking or dropping in Haskell yet
17:34:47 <hpaste>  mmorrow annotated "Word/Int bad codegen" with "Word.s" at http://hpaste.org/5954#a4
17:35:11 <hpaste>  mmorrow annotated "Word/Int bad codegen" with "Word2.s" at http://hpaste.org/5954#a5
17:37:09 <hpaste>  dons annotated "Word/Int bad codegen" with "link to bug report" at http://hpaste.org/5954#a6
17:37:59 <hpaste>  mmorrow annotated "Word/Int bad codegen" with "and fincally, my /proc/cpuinfo" at http://hpaste.org/5954#a7
17:38:15 <redleafgr> > take 4 [1..]
17:38:16 <lambdabot>  [1,2,3,4]
17:38:58 <cjb> > drop 4 [1..10]
17:38:59 <lambdabot>  [5,6,7,8,9,10]
17:40:22 <guenni> > 4 + 5
17:40:23 <lambdabot>  9
17:40:30 <guenni> cool!
17:40:36 <dons> welcome :)
17:40:41 <guenni> thx!
17:41:04 <guenni> I wonder if you can break it ...
17:41:20 <dons> please try :)
17:41:20 <cjb> haha.  always the first thought :)
17:41:32 <cjb> > drop 4 [1..]
17:41:33 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
17:41:34 <dons> its fun to work out why you can't.
17:41:35 <guenni> yep, it was indeed
17:42:02 <guenni> dons: how so?
17:42:37 <dolio> Weren't people sending arbitrary IRC commands a few days ago?
17:42:42 * dolio forgets how.
17:42:51 <benny> /quote
17:43:38 <guenni> this haskell stuff is kind of cool, but really a tough nut to crack too
17:44:43 <guenni> > id id
17:44:44 <lambdabot>  Add a type signature
17:44:46 <cjb> yes, there's quite a disconnect between typical industry languages and typical academic languages
17:44:48 <sw17ch> guenni: most rewarding nut ever (just so you know)... better than brazil nuts IMO
17:45:04 <dons> welcome to the cutting edge in language design
17:45:04 <lament> what about qwe1234
17:45:15 <guenni> I agree, though I've been struggling with it for months now
17:45:30 <sw17ch> guenni: (i'm close to a year...)
17:45:31 <dolio> He's a nut, but not very rewarding.
17:45:36 <guenni> order many many books, read many many papers
17:45:53 <guenni> that's ordered
17:45:56 <sw17ch> my method is bash keys and see what ghci tells me
17:46:11 <cjb> oh, I realized I have a question of the day
17:46:37 <dons> guenni: well, are you writing much code?
17:46:40 <cjb> normally the point of static typing is that we get to have an awesome IDE that tells us what we mean because of it
17:46:43 <dons> you have to write code to really learn
17:46:50 <guenni> I first had to build up my math background it certainly was necessary
17:46:52 <cjb> so how come we're all using vim/emacs without any smartness?
17:47:00 <guenni> dons: none in haskell yet
17:47:01 <glguy> how do you support multiple authors in haddock comments?
17:47:02 <gwern> cjb: ides are hard
17:47:05 <gwern> let's go shopping!
17:47:14 <dons> guenni: i don't think that's really necessary -- we teach haskell to beginner programmers with no math, and they work it out
17:47:14 <dmwit> cjb: Who doesn't have smartness?
17:47:24 <cjb> or, to put it another way, how come *Java* has more support for the things Haskell should be good at than Haskell does?
17:47:27 <sw17ch> cjb: maybe we could get lambdabot to be an ide
17:47:41 <sw17ch> cjb: java has IBM... what does Haskell have?
17:47:45 <DRMacIver> cjb: I don't follow the logic of that 'normally'
17:47:57 <guenni> well I tried via the "Haskell road to math, logic and programming" and that took more than I had
17:47:57 <DRMacIver> cjb: Tool support is pretty low down on the reasons why static typing is cool. :)
17:48:02 <sw17ch> cjb: ... and millions and millions of dollars in bad code
17:48:03 <cjb> DRMacIver: it's not the only point of strong static typing.. right
17:48:08 <inimino> IBM?
17:48:12 <cjb> DRMacIver: but it's usually a corollary
17:48:19 <cjb> inimino: I think he meant Sun.
17:48:23 <Adamant> quantity (of programmers) has a quality all it's own - Stalin the Pragmatic Programmer
17:48:24 <sw17ch> IBM contributed Eclipse... no?
17:48:26 <DRMacIver> cjb: Please cite 3 examples. :-)
17:48:31 <sw17ch> no, i mean IBM :)
17:48:33 <cjb> DRMacIver: smalltalk?
17:48:35 <guenni> dons: so who's "we"?
17:49:13 <pjd> @remember Adamant quantity (of programmers) has a quality all it's own - Stalin the Pragmatic Programmer
17:49:13 <lambdabot> Done.
17:49:15 <dons> guenni: UNSW, but also several universities (so I met the tutors of #haskell basically :)
17:49:36 <dons> s/meant/
17:49:43 <guenni> dons: UNSW?
17:50:03 <ivanm> University of New South Wales
17:50:04 <pjd> University of Not Safe for Work?
17:50:06 <cjb> smalltalk, lisp -- they allow incremental code compiling, querying state and what functions objects provide, and unlike Java they don't have to reparse most of your project every time you type a few characters to do so
17:50:16 <guenni> dons: ic
17:50:27 <ivanm> pjd: you wish ;-)
17:50:47 <DRMacIver> cjb: None of those are examples of static typing.
17:51:09 <cjb> DRMacIver: Oh, that's true.   Bah.  There was a point in here somewhere.
17:51:29 <ivanm> needlepoint?
17:51:42 <guenni> dons: I didn't really have the problem with functions as such, knew them from lisp, but the data aka type gave me hell to understand
17:51:49 <DRMacIver> cjb: I think "IDE support" is another of the myths.
17:51:58 <guenni> dons: the didn't quite fit in
17:52:01 <cjb> DRMacIver: The myths?
17:52:16 <DRMacIver> Along with "Purity means everything gets memoized!" and "functional programs automatically parallelise"
17:52:48 <dons> yeah, data types aren't taught well normally
17:52:59 <DRMacIver> People try to come up with reasons to justify why X, Y and Z are great and come up with ones that don't neccessarily correspond to reality. For some reason these claims propagate
17:53:01 <dons> people don't really understand what data structures are, or how they're built
17:53:10 <dons> how the types work
17:53:21 <guenni> dons: the part about haskell I liked most is that everything is explicit
17:53:26 <glguy> data structures are for civil engineers
17:53:30 <inimino> maybe there's some deeper reason why people who like Haskell are more likely to use emacs/vim?
17:53:32 <mrd> algebraic data types are like culture shock to people, it seems
17:53:33 <ivanm> heh
17:53:35 <cjb> DRMacIver: that sounds like a good rationalization for why you have bad tools :)
17:53:42 <ivanm> @remember glguy data structures are for civil engineers
17:53:42 <lambdabot> I will never forget.
17:53:45 <sw17ch> hackers use emacs/vim
17:53:46 <sw17ch> :)
17:53:51 <sw17ch> you gotta love it to use them
17:53:52 <glguy> @quote ivanm
17:53:52 <lambdabot> shillelagh says: <ivanm> so shillelagh == no significance? <shillelagh> yep!
17:54:02 <dons> mrd: yeah. its such a blub moment -- entire data structures that just weren't thinkable become possible
17:54:07 <inimino> sw17ch: right
17:54:14 <dons> and basic structures become *trivial*
17:54:20 <DRMacIver> cjb: I'm not making a value judgement.
17:54:31 <pjd> algebraic data types blew my mind
17:54:31 <sw17ch> cjb... bad tools!?!?! i love vim..
17:54:34 * sw17ch growls
17:54:35 <DRMacIver> cjb: I'm observing that the claim that there is a correlation between static typing and tool support isn't born out in practice
17:54:50 <cjb> DRMacIver: oh, okay -- I thought you meant that IDE support being valuable was a myth.
17:54:54 <DRMacIver> No
17:54:59 <mrd> ack, i splashed kimchee in my eye
17:55:10 <DRMacIver> Anyway, it's obvious why most languages without a lot of commercial support don't have good IDEs, etc.
17:55:34 <sm> guenni: that's true. Is haskell "the most explicit language" ?
17:55:45 <guenni> dons: data structures are explained mostly as something separat, and never really in terms of functions in most of the books, like a second paradigm
17:55:48 <DRMacIver> It's because a) People using these languages care more about language features than tool support or they'd be using a language that already has good tools. This means they're probably not willing to wait for tools to catch up to new versions of the language.
17:55:51 <mrd> pattern matching too
17:55:54 <gwern> machine language is the most explicit language!
17:55:55 <gnuvince_> Grrr.
17:55:58 * gnuvince_ hates sqrt
17:56:09 <mrd> the idea that the same syntax on the left-hand side destructs, and on the right-hand side _constructs_ seems to baffle some
17:56:14 <DRMacIver> And b) The boring reason. Making tool support work is hard in comparison to the amount it brings you.
17:56:26 <sm> well, machine language doesn't let you make your higher abstractions explicit.. ?
17:56:50 <mrd> java is a lot more tool-dependent than haskell
17:56:55 <DRMacIver> Right
17:57:00 <gwern> haskell-cafe is littered with the remains of announced and then abandoned tools...
17:57:04 <mrd> it's unbearable to write without assistance.  haskell is a delight in comparison.
17:57:17 <cjb> I hadn't thought of that.
17:57:21 <dibblego> what's that website that allows you to execute Haskell code?
17:57:26 <dibblego> DRMacIver, go to sleep
17:57:30 <DRMacIver> dibblego: I tried!
17:57:31 <faxathisia> oh god I'm having DeBruijn encoded dreams
17:57:53 <dibblego> DRMacIver, don't try to sleep immediately after using a computer or stimulation
17:58:02 * mrd prefers higher order abstract dreams
17:58:04 <gwern> dibblego: the one with an interface to lambdabot?
17:58:11 <gwern> ...which has been broken for a long time now?
17:58:12 <DRMacIver> Really the only tool support I miss when moving between languages is a) Find references, b) Go to definition and a distant c) Incremental error reporting
17:58:24 <dibblego> gwern, was that it? I don't know; I was just passing functions to it once and it evaluated them
17:58:29 <gnuvince_> Goddamnit, how would one write a function that returns the floor of the square root?
17:58:35 <cjb> dibblego: http://codepad.org/
17:58:36 <pjd> DRMacIver: grep and ctags? :)
17:58:38 <mrd> hmm, does GHC support cross-ref?
17:58:39 <DRMacIver> dibblego: Yeah, I know. :)
17:58:42 <dibblego> cjb, cheers
17:58:44 <faxathisia> fsqrt = floor . sqrt
17:58:46 <DRMacIver> pjd: Right. It can certainly be achieved.
17:58:54 <gwern> faxathisia: darn you
17:58:58 <DRMacIver> Although I admit I've not bothered with ctags yet.
17:59:01 <faxathisia> @let fsqrt = floor . sqrt
17:59:01 <lambdabot> <local>:5:0:     Multiple declarations of `L.fsqrt'     Declared at: <local>:...
17:59:07 <faxathisia> > fsqrt 37
17:59:07 <lambdabot>  6
17:59:21 <faxathisia> fgnuvince: That helps?
17:59:27 <gnuvince_> faxathisia: I tried that, but I get a no instance error
17:59:33 <faxathisia> hmm
17:59:44 * faxathisia tries
17:59:48 <DRMacIver> pjd: The problem is one of namespacing. It's hard to tell between functions of the same name. This is less of an issue in Haskell, because it has crap namespacing anyway. :)
18:00:13 <faxathisia> gnuvince: what no instance error?
18:00:20 <faxathisia> I get nothin
18:00:48 <gnuvince_> faxathisia: hang on
18:01:20 <hpaste>  gnuvince pasted "fsqrt" at http://hpaste.org/5966
18:01:26 <gnuvince_> faxathisia: ^^
18:02:06 <mrd> DRMacIver: that's why i prefer to ask GHC what it thinks the definition is
18:02:15 <DRMacIver> Hm?
18:02:27 <dolio> @type fsqrt
18:02:28 <lambdabot> Not in scope: `fsqrt'
18:02:37 <dolio> Bah.
18:02:38 <mrd> it parses all that module crap
18:03:22 <pjd> DRMacIver: the tag file format actually has quite a bit of support for extra fields and annotations
18:04:04 <DRMacIver> mrd: Yes. But it doesn't provide me with a nice little link to the source, which is what we were talking about. :)
18:04:14 <pjd> you can store what kind of tag it is, scope, superclass(es), type, and so on
18:04:21 <DRMacIver> pjd: Oh, I meant for grep and find references
18:04:23 <mrd> it does for interpreted code, at least
18:04:40 <pjd> ah, ok
18:04:59 <pjd> Haskell needs something like cscope
18:05:01 <mrd> i query ghci for definition locations in inf-haskell mode, anyhow
18:05:41 <pjd> DRMacIver: cscope supports finding references, calls, callees, and so on
18:06:03 <DRMacIver> Interesting
18:06:08 <pjd> but mainly for C
18:07:07 <pjd> it runs as a daemon started by your editor, and it automatically and incrementally reindexes when files change, and so on
18:07:11 <pjd> very convenient
18:07:46 <DRMacIver> That does sound nice to have
18:19:15 <guenni> what's wrong with this definition?
18:19:17 <guenni> data Bit = ONE | ZERO
18:19:17 <guenni>         deriving Show
18:19:17 <guenni> data Bits = Bit | Bit Bits
18:19:17 <guenni>   deriving Show
18:21:00 <dolio> You don't have any constructor names for Bits.
18:21:16 <dons> type Bits = [Bit]
18:21:40 <dons> data Bits = Only Bit | Some Bit Bits
18:22:03 <dolio> Or, rather, you do, but they're both Bit.
18:22:14 <dolio> Which probably isn't what you want.
18:22:33 <guenni> ok, thx
18:22:58 <sm> data Bits = NoBits | Bits [Bit] ?
18:23:18 * sm frowns.. no
18:23:22 <wagle_home> > Bits []
18:23:22 <lambdabot>   Not in scope: data constructor `Bits'
18:23:40 <sm> type Bits = [Bit] ?
18:24:20 <wagle_home> i've seen people do type Bits = [Bool]
18:24:41 <guenni> well my goal was to have something like: One (Zero (One ( One)))
18:25:15 <mrd> sometimes people do things like: I(O(I(O Z)))
18:25:37 <wagle_home> [True, False, True] == (True : (False : (True : [])))
18:25:41 <mrd> need a base case
18:25:48 <guenni> mrd: I'm not sure about the 3rd symbol: Z
18:25:50 <monochrom> I feel that you are trying to give two things the same name.
18:25:54 <mrd> guenni: that's the base case
18:26:11 <guenni> mrd: hm
18:26:38 <mrd> O, I :: Bits -> Bits; Z :: Bits
18:26:48 <guenni> data definitions seemed to be very much like BNF but I guess they aren't
18:27:19 <wagle_home> sure they are, just gotta name your right hand sides
18:27:31 <mrd> think of them more like logical propositions
18:27:55 <guenni> I still struggle with the very idea
18:27:58 <monochrom> BNF allows ambiguity like X ::= Y | Y X.  This is of course not allowed in data.
18:28:30 <monochrom> It is undecidable whether a set of BNF rules allows ambiguity or not.
18:30:18 <guenni> FWIW: I was thinking about defining my own number system, a binary one, in similar style to the Peano numbers
18:30:37 <wagle_home> Adding constructor names removes the ambiguity..  (X ::= Y | Y X  has two rhs's, gotta give them both names (ie, constructor names))
18:31:03 <monochrom> Distinct names.
18:31:11 <wagle_home> yeah
18:32:02 <wagle_home> i was supposed to type "unique" before constructor..  stupid irc doesnt have dwim yet
18:34:06 <hpaste>  decker pasted "Stack Overflow problem" at http://hpaste.org/5967
18:34:36 <decker> can someone explain why I get a stack overflow in that code when i say Natural [i]
18:35:28 <dolio> decker: Bug in enumFromTo (thought I heard about that)?
18:35:36 <BMeph> So, did anyone see Dominus' write-up on UD codes?
18:36:17 <dolio> > let l = [1..10] in zip l [0 .. (length l - 1)]
18:36:17 <lambdabot>  [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
18:36:27 <dolio> > let l = [1..10] in zip l [0..]
18:36:27 <lambdabot>  [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
18:37:09 <decker> is the syntax Natural [32] correct to declare a new instance of my type Natural?
18:38:18 <dolio> Yeah, that should work.
18:38:35 <decker> because it's getting a stack overflow so someting must be infinitely looping/recursing
18:38:43 <dolio> How long is the list in question?
18:39:01 <decker> you mean in the example of Natural [32]?
18:39:22 <dolio> Is that what's causing the stack overflow?
18:39:28 <decker> yeah that statement
18:40:36 <dolio> > sum [n * 1000^i | (n, i) <- zip [32] [0..]]
18:40:37 <lambdabot>  32
18:40:52 <decker> that code works fine
18:40:59 <decker> it's the other way around, creating a natural that's not working
18:41:06 <dolio> Oh. Hmm...
18:41:11 <decker> let x = Natural [32]
18:41:18 <decker> is causing a stack overflow
18:42:27 <dolio> Well, I'm baffled.
18:42:35 <decker> heh, yeah me too
18:42:48 <decker> newtype Natural = Natural [Int] is correct right
18:42:55 <dolio> Yeah.
18:45:17 <monochrom> There is missing information.
18:45:58 <dolio> Yeah. The stack overflow is caused by something you haven't told us. :)
18:46:59 <decker> yes
18:47:05 <redleafgr> > let x = Natural[32]
18:47:05 <lambdabot>  Parse error at end of input
18:47:16 <decker> because that code by itself is actually working
18:47:19 <redleafgr> darn
18:48:03 <decker> i'm rebuilding the whole thing line by line to find where the overflow is coming from
18:49:05 <decker> i suspect there may be a problem where it's attempting to call Show
18:49:24 <wagle_home> it seems to work in hugs for me
18:49:37 <wagle_home> no show instance for Natural, though
18:49:42 <decker> yeah
18:50:43 <decker> what's a good way in haskell to do 123456 :: Int -> [456, 123] :: [Int]
18:53:12 <EvilTerran> instance Num (Int -> [Int])?
18:53:24 <EvilTerran> no, wait, ignore me
18:53:26 <decker> i mean algorithmically
18:53:31 <monochrom> > unfoldr (\x -> if x==0 then nothing else Just (x `mod` 1000, x `div` 1000)) 123456
18:53:32 <lambdabot>   Not in scope: `nothing'
18:53:36 <EvilTerran> i thought that sounded like an odd thing to do
18:53:37 <monochrom> > unfoldr (\x -> if x==0 then Nothing else Just (x `mod` 1000, x `div` 1000)) 123456
18:53:38 <lambdabot>  [456,123]
18:53:46 <decker> ah i knew there was some way to do it using unfold
18:54:08 <EvilTerran> > map (`mod`100) . takeWhile (/=0) . iterate (`div`100) $ 123456 -- is how i'd recommend doing it
18:54:08 <lambdabot>  [56,34,12]
18:54:17 <dolio> @let stopWhen p f x = if p x then Nothing else Just (f x)
18:54:17 <lambdabot> Defined.
18:54:36 <EvilTerran> er, or 1000, even. the unfoldr version might as well be explicit recursion
18:54:45 <dolio> @let swap (a, b) = (b, a)
18:54:46 <lambdabot> Defined.
18:55:19 <dolio> > unfoldr (stopWhen (==0) $ swap . (`divMod` 1000)) 123456
18:55:20 <lambdabot>  [456,123]
18:55:23 <decker> what does Just do?
18:55:28 <EvilTerran> ?src Maybe
18:55:28 <lambdabot> data Maybe a = Nothing | Just a
18:56:03 <decker> so if you use Nothing then you have to use Just when you use a value?
18:56:11 <EvilTerran> useful for when you want a type that's like an existing type, but with an "other" value too
18:56:33 <decker> where the 'other' value is similar to Null?
18:56:40 <decker> meaning there's nothing there?
18:56:45 <dino-> Nothing is similar to null
18:57:00 <EvilTerran> yeah, you'd use Nothing similarly to how you'd use nulls in other languages
18:57:01 <BMeph> "There's no 'there' there." :)
18:57:05 <dino-> I mean, the actual Maybe constructor Nothing is similar to null.
18:57:14 <cjb> yes.  in other languages, there isn't really a way to express nothing as distinct from null or 0 or []
18:57:15 <EvilTerran> but it's made explicit in the type whether a value can be Nothing or not
18:57:28 <cjb> but in Haskell, nothing actively means "no result", and is a type rather than a value
18:57:29 <EvilTerran> cjb, or, in the case of stridx() and friends, -1 :P
18:57:36 <cjb> EvilTerran: right
18:57:57 * EvilTerran makes sure to convert to Nothings when writing bindings for functions that pull that sort of nonsense
18:58:13 <decker> cjb: so does that lead to the notion that you can do meaningful computations in haskell just by determing the type of a result?
18:58:30 <decker> as in whether a type is Nothing or not
18:58:48 <EvilTerran> Nothing is a value, not a type
18:58:58 <EvilTerran> Nothing :: Maybe a
18:59:19 <decker> oh
18:59:25 * BMeph watches EvilTerran write "while (getc /= Nothing) doSomething" and confuse the daylights out of a C programmer
18:59:46 <EvilTerran> @let safeDivide x 0 = Nothing; safeDivide x y = Just (x/y)
18:59:46 <monochrom> #define /= !=
18:59:46 <lambdabot> Defined.
18:59:52 <monochrom> #define Nothing -1
19:00:13 <BMeph> monochrom: Blasphemer! o.O
19:00:19 <EvilTerran> > zipWith safeDivide [0,1,2,3,4,5] [0,1,2,0,1,2]
19:00:20 <lambdabot>  [Nothing,Just 1.0,Just 1.0,Nothing,Just 4.0,Just 2.5]
19:00:45 <jleedev> > catMaybes it
19:00:45 <EvilTerran> decker, Maybe a is for when an expression may or may not produce a meaningful value of type a
19:00:45 <lambdabot>   Not in scope: `it'
19:01:12 <EvilTerran> if it does produce such a value, x, you give back "Just x". if it doesn't, you give back Nothing
19:01:17 <EvilTerran> both of these are of type Maybe a
19:01:20 * monochrom spills more blasphermy.
19:02:39 <BMeph> So, getchar should have type IO (Maybe Char), EvilTerran? ;)
19:02:50 <EvilTerran> ?hoogle getchar
19:02:50 <lambdabot> Prelude.getChar :: IO Char
19:02:51 <lambdabot> System.IO.getChar :: IO Char
19:02:51 <lambdabot> System.IO.hGetChar :: Handle -> IO Char
19:03:06 <monochrom> Suppose you write an interpreter for a language.  It takes a program as parameter, and it returns what the program outputs.  Now the program may or may not terminate.  If it doesn't terminate, you return Nothing.  If it terminates, you return Just (whatever the outcome is).
19:03:34 <EvilTerran> BMeph, makes sense to me. i find IO exceptions to be kinda un-haskelly
19:03:54 <EvilTerran> BMeph, actually, no. it should have type Alternative f => IO (f Char) :P
19:04:00 <monochrom> @hoogle try
19:04:00 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
19:04:00 <lambdabot> System.IO.Error.try :: IO a -> IO (Either IOError a)
19:04:00 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
19:04:03 <redleafgr> so the Maybe monad solves the halting problem!
19:04:05 <redleafgr> brilliant!
19:04:12 <dino-> Doesn't terminate! Holy _|_ Batman.
19:04:21 <monochrom> "try" solves your exception problem.
19:04:24 <jfredett> dino-: lol
19:04:25 <BMeph> EvilTerran: Wicked! ;)
19:04:38 <jfredett> @remember dino- Doesn't terminate! Holy _|_ Batman.
19:04:38 <lambdabot> It is stored.
19:04:44 * BMeph pats the nicely-formed (_|_)
19:05:03 <jfredett> easily the funniest thing I've heard all day... (It's been a slow day
19:06:24 <wagle_home> _|_ is the number of angels that can dance on the head of a pin
19:06:47 <dolio> So, even on a slow day, you don't watch Batman reruns?
19:08:17 <monochrom> #haskell is Batman reruns, only better.  Holy monomorphism Batman!
19:08:35 <EvilTerran> Hylo morphism batman!
19:08:46 <monochrom> Or Holy MPTC Oleg!
19:09:00 <EvilTerran> if oleg is batman, who's robin?
19:09:25 <monochrom> Ken Shan?
19:09:32 <EvilTerran> ...and alfred?
19:09:39 <monochrom> SPJ  <duck>
19:09:47 <monochrom> Even Wadler :)
19:10:08 <monochrom> Anyway, the cast is Wadler, Oleg, Ken Shan.  You sort them out. :)
19:10:18 <EvilTerran> wow, this shan guy is prolific
19:16:43 <decker> how can I convert [Int] -> String?
19:17:04 <wagle_home> > show [1,2,3]
19:17:05 <lambdabot>  "[1,2,3]"
19:17:34 <shepheb> > map show [1,2,3]
19:17:34 <lambdabot>  ["1","2","3"]
19:17:52 <jfredett> > (show . map show) [1..3]
19:17:53 <lambdabot>  "[\"1\",\"2\",\"3\"]"
19:17:59 <wagle_home> :t  "[1,2,3]"
19:17:59 <lambdabot> [Char]
19:18:08 <wagle_home> :t  ["1","2","3"]
19:18:08 <lambdabot> [[Char]]
19:18:14 <monochrom> > (show . cycle) [1,2,3]
19:18:14 <lambdabot>  "[1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
19:18:23 <decker> thnx
19:18:23 <jfredett> :t cycle
19:18:24 <lambdabot> forall a. [a] -> [a]
19:18:27 <redleafgr> > cycle []
19:18:28 <lambdabot>  Exception: Prelude.cycle: empty list
19:18:44 <decker> so show is generally like object.toString()
19:18:53 <jfredett> :t foldl ($) cycle [(show . map show)]
19:18:54 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
19:18:54 <lambdabot>     Probable cause: `$' is applied to too many arguments
19:18:54 <lambdabot>     In the first argument of `foldl', namely `($)'
19:18:56 <jfredett> aww
19:19:11 <monochrom> remove ( )
19:19:14 <wagle_home> @src show
19:19:14 <lambdabot> show x = shows x ""
19:19:20 <monochrom> err nevermind
19:19:25 <redleafgr> > shows [1,2,3] "[4, 5, 6]"
19:19:26 <lambdabot>  "[1,2,3][4, 5, 6]"
19:19:26 <wagle_home> @src shows
19:19:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:19:27 <jfredett> awwno, I want to apply across
19:19:31 <jfredett> i need a base
19:19:37 <jfredett> :t foldl ($) id $ cycle [(show . map show)]
19:19:37 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
19:19:37 <lambdabot>     Probable cause: `$' is applied to too many arguments
19:19:37 <lambdabot>     In the first argument of `foldl', namely `($)'
19:19:37 <wagle_home> @hoogle show
19:19:38 <lambdabot> Prelude.show :: Show a => a -> String
19:19:38 <lambdabot> Text.Show.show :: Show a => a -> String
19:19:39 <lambdabot> Text.Show :: module
19:19:55 <jfredett> yah, i dunno, i'm not even sure why I was trying to do that
19:19:57 <jfredett> :/
19:20:00 <jfredett> :t foldl
19:20:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:20:05 <jfredett> :t foldl ($)
19:20:06 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
19:20:06 <lambdabot>     Probable cause: `$' is applied to too many arguments
19:20:06 <lambdabot>     In the first argument of `foldl', namely `($)'
19:20:10 <jfredett> :t foldl (.)
19:20:10 <lambdabot> forall c a. (a -> c) -> [a -> a] -> a -> c
19:20:17 <jfredett> :t foldl (.) id
19:20:18 <lambdabot> forall a. [a -> a] -> a -> a
19:20:32 <jfredett> :t foldl (.) id $ cycle [(show . map show)]
19:20:32 <lambdabot> [Char] -> [Char]
19:20:37 <jfredett> :t foldl (.) id $ cycle [(show . map show)] $ "123"
19:20:37 <lambdabot>     Couldn't match expected type `a -> b'
19:20:37 <lambdabot>            against inferred type `[[a1] -> String]'
19:20:37 <lambdabot>     In the first argument of `($)', namely `cycle [(show . map show)]'
19:20:57 <jfredett> hmm
19:20:59 <jfredett> :t foldl (.) id $ cycle [(show . map show)]
19:21:00 <lambdabot> [Char] -> [Char]
19:22:13 <jfredett> :t foldl (.) id $ replicate 10 [(show . map show)] $ "123"
19:22:13 <lambdabot>     Couldn't match expected type `a -> b'
19:22:13 <lambdabot>            against inferred type `[[[a1] -> String]]'
19:22:13 <lambdabot>     In the first argument of `($)', namely
19:22:21 <jfredett> iiinteresting.
19:22:33 <jfredett> :t concat $ foldl (.) id $ replicate 10 [(show . map show)] $ "123"
19:22:33 <lambdabot>     Couldn't match expected type `a -> b'
19:22:33 <lambdabot>            against inferred type `[[[a1] -> String]]'
19:22:33 <lambdabot>     In the first argument of `($)', namely
19:22:44 <jfredett> :t replicate
19:22:45 <lambdabot> forall a. Int -> a -> [a]
19:22:55 <jfredett> :t foldl (.) id $ replicate 10 (show . map show) $ "123"
19:22:55 <lambdabot>     Couldn't match expected type `a -> b'
19:22:55 <lambdabot>            against inferred type `[[a1] -> String]'
19:22:55 <lambdabot>     In the first argument of `($)', namely
19:23:01 <jfredett> oh nevermind... :/
19:23:31 <EvilTerran> :t replicate 10 (show . map show)
19:23:31 <lambdabot> forall a. (Show a) => [[a] -> String]
19:23:39 <faxathisia> iterate
19:24:01 <faxathisia> > iterate (show . map show) "123"
19:24:02 <lambdabot>  ["123","[\"'1'\",\"'2'\",\"'3'\"]","[\"'['\",\"'\\\"'\",\"'\\\\''\",\"'1'\",...
19:24:08 <EvilTerran> > iterate (show . map show) "123" !! 10
19:24:08 <lambdabot>  "[\"'['\",\"'\\\"'\",\"'\\\\''\",\"'['\",\"'\\\\''\",\"'\\\"'\",\"','\",\"'\...
19:24:22 <EvilTerran> > fix (show . map show)
19:24:23 <lambdabot>  Exception: <<loop>>
19:24:25 <jfredett> EvilTerran++ FTW.
19:24:39 <EvilTerran> :t fix (show . map show)
19:24:40 <lambdabot> [Char]
19:25:11 <jfredett> i wonder...
19:25:20 <Cale> > fix (map succ . show)
19:25:21 <lambdabot>  "#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]]^^__``aabbccdd...
19:25:26 <jfredett> > iterate (show . map show . concat) "123"
19:25:26 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
19:25:41 <jfredett> > iterate (show . concat . map show) "123"
19:25:42 <lambdabot>  ["123","\"'1''2''3'\"","\"'\\\"''\\\\'''1''\\\\'''\\\\'''2''\\\\'''\\\\'''3'...
19:25:46 <jfredett> > iterate (show . concat . map show) ""
19:25:47 <lambdabot>  ["","\"\"","\"'\\\"''\\\"'\"","\"'\\\"''\\\\'''\\\\\\\\''\\\"''\\\\'''\\\\''...
19:26:02 <jfredett> > map length $ iterate (show . concat . map show) ""
19:26:05 <roconnor> > fix show
19:26:06 <lambdabot> Terminated
19:26:07 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:26:11 <Cale> > fix (map pred . show)
19:26:11 <lambdabot>  "! \US[TRZSQYRPXQOWPNVOMUNLTMKSLJRKIQJHPIGOHFNGEMFDLECKDBJCAIB@HA?G@>F?=E><D...
19:26:32 <jfredett> > map length $ take 100 $ iterate (show . concat . map show) ""
19:26:36 <lambdabot> Terminated
19:26:59 <jfredett> damn, is there some way to do iterate w/o the infinite business?
19:27:12 <jfredett> i'd like to know what the pattern of numbers of \'s are
19:27:28 <jfredett> > iterate (show . concat . map show) ""
19:27:29 <lambdabot>  ["","\"\"","\"'\\\"''\\\"'\"","\"'\\\"''\\\\'''\\\\\\\\''\\\"''\\\\'''\\\\''...
19:27:55 <Cale> fix (map pred . show) is rather fun to watch
19:27:55 <jfredett> cause i think its related to the see-say number thing
19:28:06 <Mr_Awesome> is there a way to use a "deriving" clause for everything except one case that i write myself?
19:28:10 <jfredett> the 1, 11, 21, 1211, 111221 ...
19:28:43 <Cale> Mr_Awesome: you can either derive a class or not derive it...
19:29:13 <zooko> Mmm.  hsJudy.  That is a sweet data structure.
19:29:31 <gwern> @seen dons
19:29:32 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 1h 7m 51s ago.
19:29:38 <EvilTerran> > iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
19:29:39 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
19:29:44 <Mr_Awesome> Cale: well i have a bunch of cases where Eq is just going to be A x == A y = x == y
19:29:50 <Mr_Awesome> but one thats not like that
19:29:51 <jfredett> EvilTerran: beat me to it.
19:30:05 <EvilTerran> jfredett, i have it in my ~/bagoftricks.hs
19:30:09 <EvilTerran> :D
19:30:18 <Cale> Mr_Awesome: You have to write it yourself then.
19:30:20 <jfredett> EvilTerran: I should start writing one of those... :/
19:30:24 <Mr_Awesome> :(
19:30:39 <faxathisia> > rle "aoe"
19:30:40 <lambdabot>   Not in scope: `rle'
19:30:41 * gwern always felt kind of guilty about hsjudy since I was unsure I cabalized it correctly
19:30:43 <faxathisia> grr
19:30:49 <EvilTerran> Mr_Awesome, you could probably do something with uniplate or SYB
19:31:06 <Cale> Mr_Awesome: If there are very many cases, you might derive Data and use Data.Generics
19:31:28 <dons> gwern: ?
19:31:36 <gwern> dons: I've sent some patches for Frag that add runtime finding of the data files, so you now only have to go 'frag' to get the default level. I think it's worth bumping a version and uploading to hackage - having to specify where leveleg is is veryannoying
19:31:43 <ddarius> > map length . group . fix show
19:31:44 <lambdabot>  Couldn't match expected type `a -> [a1]'
19:32:05 <ddarius> > map length . group $ fix show
19:32:09 <lambdabot> Terminated
19:32:37 <jfredett> > iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
19:32:38 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
19:32:53 <faxathisia> @let rle = concatMap (\(c,i)->c:show i) . map (head &&& length) . group in rle "foo"
19:32:53 <lambdabot>  Parse error
19:32:55 <faxathisia> @let rle = concatMap (\(c,i)->c:show i) . map (head &&& length) . group
19:32:56 <lambdabot> Defined.
19:33:02 <jfredett> > map (concat . show) $ iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
19:33:03 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
19:33:03 <faxathisia> > iterate rle "1"
19:33:04 <lambdabot>  ["1","11","12","1121","122111","112213","12221131","1123123111","12213111213...
19:33:24 <faxathisia> @pl (\(c,i)->c:show i)
19:33:24 <lambdabot> uncurry ((. show) . (:))
19:33:33 <faxathisia> Is there a better way to write.. (\(c,i)->c:show i)
19:34:00 <jfredett> thats pretty nice looking to me, faxathisia
19:34:19 <EvilTerran> uncurry (:) . right show
19:34:26 <EvilTerran> er, s/right/second/
19:34:35 <faxathisia> @undef
19:34:35 <lambdabot> Undefined.
19:34:45 <EvilTerran> > iterate (uncurry (:) . second show) "1"
19:34:46 <lambdabot>  Couldn't match expected type `(Char, b)'
19:34:52 <EvilTerran> hm
19:34:54 <faxathisia> @let rle concatMap (uncurry (:) . right show . head &&& length) . group
19:34:54 <lambdabot>  Parse error
19:34:58 <faxathisia> @let rle = concatMap (uncurry (:) . right show . head &&& length) . group
19:34:58 <lambdabot> Couldn't match expected type `(a, [a])'
19:35:08 <EvilTerran> :t uncurry (:) . second show
19:35:08 <lambdabot> forall b. (Show b) => (Char, b) -> [Char]
19:35:11 <faxathisia> @let rle = concatMap (uncurry (:) . (id *** show) . head &&& length) . group
19:35:11 <lambdabot> Couldn't match expected type `[b]'
19:35:11 <jfredett> > map (\x -> read x :: Integer) $ map (concat . show) $ iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
19:35:12 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
19:35:40 <jfredett> > map (\x -> (read x)::Integer) $ map (concat . show) $ iterate (concatMap ((:) <$> length <*> return.head) . group) [1]
19:35:40 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
19:35:44 <jfredett> frak
19:35:45 <faxathisia> @let rle = concatMap (uncurry (:) . head &&& (show.length)) . group
19:35:45 <lambdabot> Couldn't match expected type `[b]'
19:35:53 <dons> ?users
19:35:53 <lambdabot> Maximum users seen in #haskell: 463, currently: 395 (85.3%), active: 17 (4.3%)
19:36:25 <faxathisia> oh oops!
19:36:26 <faxathisia> @let rle = concatMap (uncurry (:) . (head &&& (show.length))) . group
19:36:26 <lambdabot> Defined.
19:36:33 <faxathisia> > rle "That's better"
19:36:34 <lambdabot>  "T1h1a1t1'1s1 1b1e1t2e1r1"
19:36:58 <faxathisia> It's impossible to decode this though...
19:37:04 <faxathisia> rle is not injective...
19:37:15 <byte-> hello.
19:37:53 <ddarius> faxathisia: You need explicit or implicit delimiters.
19:38:03 <faxathisia> yes
19:38:23 <faxathisia> @let rle = concatMap (uncurry (:) . (head &&& ((" "++).show.length))) . group
19:38:23 <lambdabot> <local>:2:0:     Multiple declarations of `L.rle'     Declared at: <local>:1:...
19:38:28 <faxathisia> @undef
19:38:29 <lambdabot> Undefined.
19:38:29 <faxathisia> @let rle = concatMap (uncurry (:) . (head &&& ((" "++).show.length))) . group
19:38:30 <lambdabot> Defined.
19:38:35 <faxathisia> > rle "That's better"
19:38:35 <lambdabot>  "T 1h 1a 1t 1' 1s 1  1b 1e 1t 2e 1r 1"
19:38:49 <faxathisia> huh I put space in the wrong place..
19:39:19 <gwern> @hoogle xmlNew
19:39:19 <lambdabot> No matches found
19:39:52 <dons> anyone see the awesome new haskell job on -cafe@ ?
19:39:57 <ddarius> Incidentally, " "++ is ' ':
19:40:02 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/37093
19:40:04 <lambdabot> Title: Gmane -- Mail To News And Back Again
19:40:14 <dons> "Currently we use Haskell for our in-house data analysis tools, and
19:40:14 <dons> some vehicles run code partially generated by a Haskell DSL."
19:40:30 <cjb> gosh.
19:41:05 <gwern> 'dialogXml  liftM (fromJust) $ join $ liftM (xmlNew) $ getDataFileName "nymphaea.glade"' <-- I know there's something wrong when I have two liftMs separated by a join - what's the better way of writing it?
19:41:28 <cjb> gwern: did you just paste a unicode <- ?
19:41:38 <gwern> cjb: I did
19:41:43 <ddarius> m >>= f = join (liftM f m)
19:41:43 <cjb> (I turned on pretty symbols for haskell-mode in emacs today, wondering if it leaked through to my ERC.)
19:41:47 <cjb> ah, cool :)
19:41:57 <jfredett> that is a wicked awesome looking job
19:42:04 <zooko> Wow -- did you folks know that FreeArc is written in Haskell?
19:42:18 <gwern> what is FreeArc, and is it open source?
19:42:23 <dons> zooko: yeah, sure.
19:42:24 <jfredett> Haskell on the roadways, I never felt so (type) safe... :)
19:42:26 <dons> that's Bulat's code
19:42:29 <zooko> It is open source, and it is a good compressor.
19:42:33 <cjb> zooko: they used C++ for the CPU-intensive part.
19:42:34 <dons> zooko: i didn't know it was well known
19:42:38 <cjb> so hardly something to brag about
19:42:39 <ddarius> gwern: So dialogXml <- liftM fromJust (getDataFileName "nymphaea.glade" >>= xmlNew)
19:42:47 <dons> cjb: well, its a lot of haskell, iirc?
19:42:57 <gwern> ddarius: hm. I'll need to ponder that a bit.
19:42:59 <zooko> Okay, I need to get some sleep.
19:43:20 <cjb> dons: the UI and file handling is written in Haskell, and the compression algorithms are written in C++, according to their webpage
19:43:45 * cjb downloads to investigate.
19:43:52 <gwern> ouch. sounds hard to cabalize then
19:44:14 <cjb> h
19:44:14 <cjb> oh
19:44:16 <cjb> http://haskell.org/haskellwiki/Library/Compression
19:44:24 <cjb> is a separate project by the same author, I think?
19:44:42 <cjb> and it has useful algorithms -- I was looking for a PPMD algorithm in Haskell about twenty minutes ago!
19:44:55 <cjb> oh.  no, that part's still all written in C++.
19:44:57 * cjb grumps.
19:45:51 <cjb> I guess they wrote Haskell function wrappers to the C++ code.
19:46:06 <gwern> cjb: look at theCompression-2005 library on http://freearc.narod.ru/
19:46:07 <lambdabot> Title: FreeArc archiver and its companion libraries
19:46:16 <gwern> '                    easy and uniform access to most competitive compression algorithms as of April05: LZMA, PPMd and GRZip'
19:46:19 <cjb> gwern: that's what I just linked to.
19:46:30 <cjb> gwern: those algorithms are implemented in C++, so they aren't useful to me.
19:47:10 <dons> http://reddit.com/info/6a8jy/comments/ "Want a Haskell job? How about "hydraulic hybrid vehicle systems"! [programming] (article.gmane.org)" :)
19:47:38 <gwern> dons: I think that's kind of reaching, as a reddit post
19:47:57 <dons> oh, i often drop jobs by there. people seem to be interested.
19:48:35 <dons> probably does more for PR than 100 libraries
19:48:48 <ddarius> No press is bad press
19:49:15 <dons> that's right.
19:49:23 <jfredett> gwern: have you read reddit recently? the stuff that makes the front page is way less relavent than haskell-jobs.
19:50:06 <dons> "the potential for a
19:50:06 <dons> lot of Haskell development"
19:50:09 <dons> is exciting
19:50:18 <dons> i hope we get some good people there.
19:50:24 <gwern> jfredett: I just don't see how haskell jobs are really the province of proggit
19:50:28 <dons> Igloo, dcoutts: interested? :)
19:50:38 <jfredett> i suppose...
19:50:45 <dons> gwern: sure. programming. well, they don't get modded down usually anyway
19:51:17 <jeffz> I don't mind seeing haskell jobs on pr, on the other hand... if I saw ruby jobs on pr I'd downmod them.
19:52:11 <gwern> jeffz: and why?
19:52:33 <jeffz> gwern: bias?
19:52:53 <jfredett> lol, at least he admits it...
19:52:54 <jfredett> :)
19:52:54 <gwern> ok...
19:52:59 <dons> its news if haskell jobs appear?
19:53:09 <dons> and it is interesting to the top end of proggit?
19:53:32 <TSC> Something getting to the top of proggit is hardly an endorsement of "interesting"
19:54:13 <jfredett> TSC, he was saying that the post is interesting to the upper echelon of proggit readers, methinks
19:54:30 <jfredett> though I agree with your general sentiment, #1 proggit => nothing.
19:54:57 <TSC> It seems like main reddit is worse
19:55:09 <TSC> [pic] => #1
19:55:10 <jfredett> it is...
19:55:34 <gwern> yay. now nymphaea no longer needs to be run in the same directory as its glade file
19:55:34 <jfredett> TSC: disagree- [pic] [NSFW] -> #1
19:55:47 <gwern>  nymphaea: done; frag: done. a good night
19:56:04 <jfredett> porn hungry nerds run reddit-main...
19:56:22 <gwern> strange, because there's already a nsfw subreddit
19:56:43 <jfredett> gwern, theres more than one, actually- under different names.
19:56:59 <gwern> jfredett: that only emphasizes my point
19:58:16 <sarehu> if you see haskell jobs you should downmod them -- less competition that way
19:58:34 <jfredett> lol, true...
20:01:36 <dons> gwern: is there a darcs repo for nymphaea?
20:01:46 <noige_> hi
20:01:55 <gwern> dons: not that I know of
20:02:05 <dons> so you just patch tarballs?
20:02:17 <dons> why not move code onto code.haskell.org then, so the community can develop it?
20:02:22 <gwern> dons: yes
20:02:31 <gwern> dons: ask Cale why not
20:02:33 * gwern shrugs
20:03:53 <mofmog> hello
20:04:01 <Cale> I have no excuse other than that I haven't touched it in over a year, and gave it to gwern since he was looking for examples of gui Haskell programs :)
20:04:14 <mofmog> i'm guessing the formal name o f a tuple is Tuple right?
20:04:18 <gwern> Cale: I uploaded a new Nymphaea with fixed glade-file-finding; it was just a small modification in the Nymphaea.hs to use Paths_nymphaea (getDataFile) or whatever. it seemed to work fine, so I just uploaded it
20:04:23 <mofmog> i'm trying to construct a pairs data type
20:04:29 <mofmog> for a parser
20:04:47 <Cale> mofmog: There are built in pairs in Haskell...
20:05:05 <Cale> :t ("hello", [1,2,3])
20:05:06 <lambdabot> forall t. (Num t) => ([Char], [t])
20:05:25 * sm discovers HSP 0.2
20:05:27 <Cale> gwern: cool
20:05:29 <mofmog> tuples right?
20:05:40 <Cale> mofmog: yeah, that's a tuple.
20:05:42 <mofmog> tuples == pairs?
20:05:50 <sm> boy, that naked xml syntax is really something! http://www.cs.chalmers.se/~d00nibro/hsp/hsp-hw05.pdf
20:05:53 <Cale> Pairs are 2-tuples.
20:06:01 <mofmog> 0_0
20:06:03 <mofmog> ??
20:06:08 <gwern> sm: you should probably be aware that the haskell server pages folks have gotten together again and the stuff on hackage and their homepage is pretty old
20:06:10 <mofmog> yah
20:06:12 <mofmog> i see
20:06:30 <mofmog> what are the analogs of car and cdr?
20:06:35 <mofmog> or better yet
20:06:44 <faxathisia> fst and snd
20:06:45 <Cale> fst and snd, but they don't apply to lists, only pairs.
20:06:46 <gwern> head/tail; fst/snd?
20:06:50 <wagle_home> :t head
20:06:51 <lambdabot> forall a. [a] -> a
20:06:51 <sm> ok, thanks
20:06:57 <mofmog> what's a good refernece? Ive been using ZVON but it's really incomplete
20:07:00 <faxathisia> cons = (.) ; car = fst ; cdr = snd
20:07:03 <Cale> Oh
20:07:04 <faxathisia> cons = (,) * ; car = fst ; cdr = snd
20:07:07 <mofmog> i have to go digging through tutorials for everytthing
20:07:20 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
20:07:27 <Cale> http://haskell.org/onlinereport/standard-prelude.html
20:07:35 <faxathisia> mofmog: (:) is cons though in haskell
20:08:12 <mofmog> well not really
20:08:18 <mofmog> 4:2 seems to give an error
20:08:26 <mofmog> whereas (cons 4 2) returns a pair
20:08:31 <faxathisia> mofmog, Right that's why I said (,)
20:08:35 <Cale> mofmog: Right, because this is a typed language :)
20:08:39 <faxathisia> mofmog, because it's more like the cons you're used to
20:08:44 <gwern> sm: if you're interested, they're looking for help, and they restarted literally like last week - look for haskell-server-pages@googlegroups.com
20:08:46 <Cale> mofmog: (:) is the list cons
20:08:49 <faxathisia> mofmog, (:) is *actually* cons though in haskell
20:08:51 <Cale> mofmog: (,) is the pair cons
20:08:53 <mofmog> oh
20:08:54 <mofmog> so
20:08:56 <mofmog> (3:2)
20:09:01 <Cale> is poorly typed
20:09:03 <faxathisia> @src []
20:09:03 <lambdabot> data [] a = [] | a : [a]
20:09:04 <Cale> because 2 isn't a list
20:09:13 <wagle_home> > (3 : 2 : [])
20:09:14 <lambdabot>  [3,2]
20:09:18 <sm> interesting, thanks!
20:09:19 <Cale> > 3 : (2 : [])
20:09:20 <lambdabot>  [3,2]
20:09:24 <mofmog> wait
20:09:30 <wagle_home> Cale, 8-p
20:09:30 <mofmog> cons shouldnt have to only take lists
20:09:32 <faxathisia> > 3 : 2 : ([])
20:09:32 <lambdabot>  [3,2]
20:09:44 <mofmog> or at least if you're keeping the lisp analogy
20:09:48 <faxathisia> mofmog: welcome to haskell..
20:09:51 <mofmog> then again, lisp isnt typed
20:09:52 <mofmog> haha
20:09:54 <Cale> mofmog: Every list must either end in nil, or be an infinite chain of conses (:)
20:09:55 <faxathisia> mofmog: That's why I showed you (,)
20:09:57 <sm> incidentally I heard from the fungen guy, getting the license clarified now
20:10:01 <decker> it's really hard going from lisp to haskell
20:10:09 <faxathisia> decker: I didn't find that
20:10:16 <mofmog> i have the feeling of
20:10:20 <decker> the hardest thing for me as a lisper is understanding the type system
20:10:20 <Cale> mofmog: There are no improper lists, like in lisp.
20:10:21 <faxathisia> I still program in both though..
20:10:41 <Cale> mofmog: Moreover, all the elements of a list must have the same type.
20:10:45 <decker> type errors like Expected Int got Char make sense to me but things like expected Int got a -> b make no sense
20:10:46 <gwern> sm: really? excellent. did he ever write the new improved version? I tried it out from your repo and found it very... flickery
20:10:56 <Cale> mofmog: So lists are not trees.
20:11:09 <Cale> (they're just lists)
20:11:11 <wagle_home> > ((1,2), (3. (4, 5)))
20:11:11 <lambdabot>  Couldn't match expected type `a -> b'
20:11:23 <mrd> 3. (4,5)?
20:11:28 <mofmog> so how do i construct the data types i see in SICP?
20:11:29 <sm> still inquiring, but it doesn't sound like it, this will probably be it
20:11:30 <wagle_home> > ((1,2), (3, (4, 5)))
20:11:30 <lambdabot>  ((1,2),(3,(4,5)))
20:11:36 <faxathisia> :t ((1,2), (3, (4, 5)))
20:11:36 <wagle_home> small font, sorry
20:11:36 <lambdabot> forall t t1 t2 t3 t4. (Num t4, Num t3, Num t2, Num t1, Num t) => ((t, t1), (t2, (t3, t4)))
20:11:42 <Cale> mofmog: Usually with data declarations.
20:11:45 <sm> sounds like he stopped because the hopengl was so in flux back then
20:11:54 <mofmog> for example, say i wanted to implement my own version of Trees
20:11:59 <sm> flickery, really ? I see none of that, on a macbook
20:12:04 <mofmog> in scheme i would cons together a datum and a list of children
20:12:11 <sm> I get 30fps in pong and 6 in worms, how about you ?
20:12:16 <faxathisia> data Tree a = Tip | Branch a (Tree a) (Tree a)
20:12:27 <Cale> or
20:12:39 <Cale> data Tree a = Tip | Branch a [Tree a]
20:12:51 <mofmog> under my data type, leaf nodes are simply trees without children
20:12:53 <faxathisia> :o
20:13:01 <Cale> mofmog: okay
20:13:05 <Cale> data Tree a = Branch a [Tree a]
20:13:07 <mofmog> ah
20:13:10 <pjd> mofmog: data List a = Cons a (List a) | Nil
20:13:22 <gwern> sm: aw. he wouldn't be the first person to be discouraged by mutating libraries in haskell, tho
20:13:26 <pjd> (just for referenc)
20:13:29 <pjd> reference, even
20:13:37 <Cale> mofmog: (but all your leaf nodes are forced to be labelled then)
20:13:40 <gwern> sm: how did you meausre fps? I don't remember any statistics
20:13:55 <sm> I'm hoping he'll see the 2008 libs, be all inspired and come storming back. :)
20:13:58 <mofmog> well i'm just going by my scheme experience
20:14:08 <shepheb> sorry for the off-topic, but can anyone explain the isVisible in http://hpaste.org/5968 ? the only one I can find is in Decoration, but that's a wrong type. they were originally without the D. qualifier, but then they're not in scope.
20:14:13 <mofmog> if you cdr the node and find it to be null you know you have a leaf node
20:14:14 <mofmog> :-P
20:14:21 <faxathisia> mofmog: It might be better to just start fresh and not write scheme in haskell for a while
20:14:30 <sm> gwern: you might need to pull another patch ? pong shows red fps, and I added it to worms
20:14:38 <gwern> ok
20:14:42 <sm> at bottom right
20:14:49 <faxathisia> mofmog: It's a bit like using a frying pan to bake a cake ;P
20:15:04 <sm> you should see white score, red fps
20:15:05 <mofmog> well when you know how to use a frying pan...
20:15:05 <dons> anyone going to see Satnam talk about parallel Haskell at Stanford tomorrow?
20:15:19 <mofmog> no, my berkeley pride prevents me
20:15:33 <dons> "Talk by Satnam Singh of Microsoft Research Cambridge
20:15:33 <dons> Title: A Survey of Parallel Programming in Haskell
20:15:33 <dons> "
20:15:45 <dons> Thursday, Feb 28
20:15:45 <dons> 1:30pm
20:15:45 <dons> Gates 104
20:15:45 <dons> Stanford CS Department
20:15:51 <gwern> sm: ok, I get about 6.4 fps of snake, 25-30 fps in pong
20:15:55 <mofmog> Haskell .NET
20:16:14 <Cale> mofmog: Haskell has some features which formalise some of the practices from SICP.
20:16:18 <gwern> sm: pretty slow... I guess that's why the flickering
20:16:21 <awesame> mofmog: ITYM F#
20:16:40 <mofmog> perhaps if SICP were rewritten with haskell
20:16:44 <sm> I guess I don't know what you mean by flicker. Probably just that it's not double-buffered ?
20:17:04 <Cale> awesame: Nah, that's O'Caml.NET
20:17:18 <dons> there's a .NET bridge from haskell underway at UNSW, btw
20:17:30 <dons> should be released soon. i'll chase them up.
20:17:36 <awesame> yeah, I guess that's closer
20:17:39 <mofmog> Bash Scripting .NET
20:17:42 <gwern> sm: dunno. I'm not a big graphics person
20:17:47 <sm> or maybe it is.. dunno either
20:17:49 <Cale> MutVar#
20:18:12 <Cale> (that's going to be the name of my new purely functional language for .NET)
20:18:19 <awesame> perhaps I will become rich and famous if I write an H#
20:18:29 <Cale> (it will throw people off with its name)
20:18:31 <awesame> the name is funny, since musical notes end at G
20:18:57 <Cale> E#
20:19:17 <gwern> unsafeDoggeh#
20:19:27 <sm> gwern: worms for me is playable, because the motion is smooth and regular - no variation in speed. Are you by chance on linux ?
20:19:45 <gwern> sm: yes
20:20:04 <sm> ok.. osx is better at that. bummer
20:20:06 <gwern> worms is playable, at least, the reaction speed seems to be proper - it's just visually unpleasant for me
20:21:04 <sm> by golly I will play another game and see
20:21:20 * sm lowers the tone in #haskell by 50%
20:21:38 <faxathisia> @src (&&&)
20:21:38 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
20:26:12 <roconnor> where is this spiffy new haskell job?
20:26:30 <Sgeo> What's &&&?
20:26:53 <gwern> an arrow function
20:26:59 <dons> roconnor: I /think/ its NYC. hard to tell
20:26:59 <gwern> :t (&&&)
20:27:00 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
20:27:12 <dons> roconnor:  a bit of hacking, a bit of verification?
20:27:32 <dons> roconnor: oh, maybe Cleveland.
20:27:33 <roconnor> I'm known for verification.
20:28:25 <faxathisia> > (head &&& length) "htnaeudheoua"
20:28:25 <lambdabot>  ('h',12)
20:32:23 <pjd> > (,) <$> head <*> length $ "htnaeudheoua"
20:32:24 <lambdabot>  ('h',12)
20:34:13 <mrd> > map (head &&& length) $ group "abbcccdddd"
20:34:14 <lambdabot>  [('a',1),('b',2),('c',3),('d',4)]
20:34:27 <faxathisia> > rle "abbcccdddd"
20:34:27 <lambdabot>  "a 1b 2c 3d 4"
20:34:31 <faxathisia> bah
20:34:33 <faxathisia> @undef
20:34:33 <lambdabot> Undefined.
20:35:46 <sm> gwern: out of curiosity, where did you hear about the hsp reforming ? on haskell-cafe ? couldn't find it on google code
20:36:56 <gwern> sm: the authors told me when I sent in my patches
20:37:15 <gwern> and I told you, look for their group on google groups; nuttin' to do with google code
20:37:30 <sm> couldn't find it there either
20:37:42 <sm> not to worry
20:37:43 <gwern> sm: search harder. I found it just fine
20:37:54 <sm> bah
20:38:01 * gwern reiterates, haskell-server-pages@googlegroups.com
20:38:40 <wagle_home> @go hsp google groups
20:38:42 <lambdabot> http://groups.google.com/group/google-code-hosting/browse_thread/thread/4b8bfdab269883c9
20:38:42 <lambdabot> Title: Name clashes with existing(?) SF project - Hosting at Google Code | Google Group ...
20:39:29 <dons> this looks like a one line list monad problem, http://reddit.com/r/programming/info/6a8od/comments/
20:39:34 <dons> if someone's bored
20:41:03 * wagle_home tries to remember the conditions under which a fixpoint is always found
20:42:20 <TSC> dons: user n -> user n+1; to satisfy the randomness, half the time change the "+" to "-"  (:
20:44:33 <hpaste>  morrow annotated "Word/Int bad codegen" with "possibly helpful conversions" at http://hpaste.org/5954#a8
20:44:58 * ddarius wonders if J has derangements built in.
20:45:08 <TSC> It sure does make people deranged
20:45:48 <dolio> Couldn't you just randomize the list, and then user n gets user n + 1 always?
20:46:22 <dino-> dolio: I was thinking of that too, and last one points to the head item to finish it up.
20:46:32 <dolio> Right.
20:47:15 <BMeph> It looks like an even number of users is assumed, so maybe it's a pair-based problem, as well as a list-based one.
20:47:21 <dino-> Is there a super terse list shuffle?
20:47:41 <dino-> I wrote something sometime ago but it's not super tiny.
20:48:16 <dino-> BMeph: I was taking "no one has each other" to mean not paired-off.
20:49:14 <dolio> It's not one line. Maybe 10 or 15 with MonadRandom.
20:49:42 <BMeph> dino-: Hmm, now that you pointed that out, that does seem to be the intent.
20:51:00 <BMeph> Getting the random numbers out seems like the biggest part of the problem - at least, from a Haskell perspective.
20:51:02 <bos> `http://www.realworldhaskell.org/blog/2008/02/28/stanford-haskell-talk-2008-02-28/
20:51:03 <lambdabot> Title: Real World Haskell  Blog Archive  Bay Area Haskellers: talk at Stanford tomorr ..., http://tinyurl.com/2vm23b
20:51:13 <ddarius> You need to build a non-symmetric non-reflexive functional relation.
20:51:53 <ddarius> (For a strong sense of "non")
20:52:42 <ddarius> Or rather select randomly from all such
20:53:57 * ddarius considers adding @j to lambdabot some time in the future.
20:54:11 <faxathisia> yeah1
20:54:15 <faxathisia> J rules :D
20:54:17 <hpaste>  dino- pasted "random shuffle" at http://hpaste.org/5969
20:54:30 <dino-> I wrote all this a while ago when puzzling over randomly shuffling lists.
20:54:31 <faxathisia> I have no idea how you solve this in one line though
20:54:34 <faxathisia> even in J..
20:55:15 <roconnor> @go 1 CAD in USD
20:55:15 <lambdabot> 1 Canadian dollar = 1.008166 U.S. dollars
20:55:34 <cjb> bos: aw, now I'm jealous.  I've read that paper, I'd like to see the talk.
20:55:38 <ddarius> faxathisia: You could do a generate and test approach pretty easily and no doubt in one line.
20:55:47 <Sgeo> @go 1 Linden in USD
20:55:48 <lambdabot> http://secondlife.com/whatis/currency.php
20:55:48 <lambdabot> Title: Second Life | Currency Exchange
20:55:49 <faxathisia> hmm
20:56:04 <Sgeo> oh
20:56:05 <Sgeo> ic
20:56:08 * gwern checks out helium's sources. a selfsigned cert? sloppy
20:56:59 <mrd> you should buy them a certificate :P
20:58:33 <ddarius> faxathisia: Actually, using the cycle notation for a permutation as long as all cycles are greater than length 2 that should solve the problem.
20:59:25 <gwern> mrd: bah, they're the ones being funded by a university. I don't have that kinda spare money
21:00:02 <ddarius> With this perspective, it should actually be pretty easy.  Just randomly generate a permutation out of cycles of length 2 or more.
21:01:05 <bos> i think the linden/USD ratio is around 270
21:05:53 <bos> cjb: yeah, i'm going to drop out of work for a few hours to go to that talk tomorrow
21:06:16 <bos> cjb: it's very rare that haskell researchers pop up in the bay area. this place is a functional programming desert.
21:07:46 <hpaste>  dolio annotated "random shuffle" with "First pass." at http://hpaste.org/5969#a1
21:14:50 <pjd> > let shuffle g = fst . foldr (\x (xs,g) -> let { (i,g') = randomR (0,length xs) g; (ys,zs) = splitAt i xs } in (ys++x:zs,g')) ([],g) in shuffle (mkStdGen 0) ['a'..'z']
21:14:51 <lambdabot>  "jwthdafpuosmckixvzgbrlqney"
21:16:42 <ddarius>  > let shuffle g = fst . foldr (\x (xs,g) -> let { (i,g') = randomR (0,length xs) g; (ys,zs) = splitAt i xs } in (ys++x:zs,g')) ([],g); result = shuffle (mkStdGen 0) ['a'..'z'] in (length &&& group) result
21:16:55 <ddarius> > let shuffle g = fst . foldr (\x (xs,g) -> let { (i,g') = randomR (0,length xs) g; (ys,zs) = splitAt i xs } in (ys++x:zs,g')) ([],g); result = shuffle (mkStdGen 0) ['a'..'z'] in (length &&& group) result
21:16:56 <lambdabot>  (26,["j","w","t","h","d","a","f","p","u","o","s","m","c","k","i","x","v","z"...
21:19:05 <dino-> dolio: Wow. Time to hit the sack but I will look at this tomorrow. It's vastly shorter than what I wrote.
21:21:56 <faxathisia> @src group
21:21:56 <lambdabot> group = groupBy (==)
21:22:00 <faxathisia> @src groupBy
21:22:00 <lambdabot> groupBy _  []       =  []
21:22:00 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:22:00 <lambdabot>     where (ys,zs) = span (eq x) xs
21:24:52 <Pseudonym> Anyone else read this?:
21:24:54 <Pseudonym> http://arxiv.org/PS_cache/arxiv/pdf/0802/0802.3881v1.pdf
21:26:57 <gwern> Pseudonym: mebbe ln to the desc page, not pdf
21:27:07 <bos> Pseudonym: they're channeling richard bird in a big way
21:28:59 <gwern> 'Daniel Friedman and David Wise have argued that cons should not evaluate its arguments and have shown that this allows certain infinite list structures to be regarded as objects. Trouble is avoided, because only as much of the infinite structure is created as is necessary to get the answers to be printed. Exactly what domain of infinite list structures is assumed is unclear to me. While they give interesting examples of applications, ...
21:29:05 <gwern> ... it isn't clear whether the proposed extension has practical value.'
21:31:43 <bos> gwern: he'd probably still say the same thing.
21:32:34 <gwern> it was from quite a while ago. I think laziness is well established; although he'd probably consider purity too great a burden and argue that laziness be optional
21:32:40 <dolio> Is that a Sussman quote?
21:33:19 <gwern> either sussman or the original lisp fella
21:33:37 <gwern> http://www-formal.stanford.edu/jmc/lisp20th/node5.html <-- the latter
21:33:41 <bos> it's mccarthy
21:33:47 <dolio> Ah.
21:33:56 <pjd> there's probably not much point in only making cons lazy
21:34:07 <pjd> compared to making the language lazy
21:34:33 <sclv> maybe I'm nuts, but I'd sort of like an unsafeInterleaveSTM
21:36:22 <wagle_home> every unsafe operation makes baby haskell cry
21:37:01 <sclv> yeah but this would be very useful
21:37:21 * dolio stops to marvel that 1999 is now quite a while ago.
21:38:59 <gwern> '1999 note: This article was included in the 1980 Lisp conference held at Stanford. Since it almost entirely corresponds to my present opinions, I should have asked to have it reprinted in the 1998 Lisp users conference proceedings at which I gave a talk with the same title. '
21:39:15 <sclv> if you can prove local uniqueness of a use of a TVar, and want to pass a function regarding it around...
21:39:30 <BMeph> I like to think of laziness as late-binding for processing.
21:40:42 <wagle_home> gwern, who's that?
21:41:11 <wagle_home> gwern, ah
21:41:26 <sclv> ?hoogle unsafeInterleaveST
21:41:26 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
21:41:26 <lambdabot> Control.Monad.ST.Lazy.unsafeInterleaveST :: ST s a -> ST s a
21:41:35 <gwern> 1980 is quite a while to me
21:41:55 <sclv> if we can do that, we can certainly do unsafeInterleaveSTM.
21:41:59 <dolio> I don't disagree that 1999 is a long time, either.
21:42:09 <dolio> At least in the computer industry.
21:42:12 <gwern> nearing a decade
21:42:29 <gwern> > 10 / 1.5
21:42:29 <lambdabot>  6.666666666666667
21:42:48 <gwern> near 7 ticks of moore's law, in theory
21:43:05 <glguy> isn't that a log operation?
21:43:34 <dolio> > 2 ** (10 / 1.5)
21:43:34 <sclv> if the darn primitives were exported i'd do it myself.
21:43:35 <lambdabot>  101.59366732596479
21:43:57 <gwern> no, the density for a given price doubles every 18 months, or 1.5 years; how many 1.5 year fit into a decade is 10 / 1.5
21:44:28 <gwern> what the factor is the density rises by may well be a log operation or whatever; it's too late for me to do maths
21:45:22 <gwern> anyway, it was an off the cuff calculation
21:45:23 <gwern> night
21:45:32 <wagle_home> back-of-napkin's about right
21:49:54 <Lemmih> Are there any tools for finding space leaks other than retainer profiling?
22:00:10 <ac> is there a graphics library that can be used with ghci?
22:00:40 <adu> ac: GL
22:02:33 <dons> probably most of them do. i think even gtk2hs does now
22:02:35 <jeffz> ac: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Graphics
22:02:35 <lambdabot> http://tinyurl.com/yqov7f
22:03:00 <ac> huh. last time I tried gtk2hs I got an error about threads
22:03:31 <ac> the choices are gtk2hs, SDL, X11, and OpenGL
22:06:37 <ac> cool!
22:06:41 <ac> it works now :)
22:09:08 <sm> how do you know ac
22:09:51 <ac> well, I opened ghci and loaded a sample gtk program I wrote, and it worked
22:10:16 <ac> and closing the window didn't kill ghci, like as happens with OpenGL
22:11:08 <Lemmih> (^^ that's one of the reasons I wrote the SDL binding, btw)
22:14:14 <ac> Lemmih: oh? You mean so you can draw things using SDL interactively through ghci?
22:15:11 <Lemmih> ac: The problem is with GLUT, not GL itself. Using GL+SDL works fine in ghci.
22:16:34 <sm> good to know
22:16:36 <Lemmih> Drawing things interactively is fun but I never found it to be very useful.
22:17:57 <ac> Lemmih: so why did you want to use ghci?
22:18:07 <sm> I'm a bit unclear how GL+SDL works. does one overlay the other ?
22:18:31 <Lemmih> ac: Faster recompile times. Linking is hugely expensive on my box.
22:20:31 <Lemmih> sm: GL only does graphics. It needs another tool to create a drawing surface and collect user input.
22:21:04 <sm> which is GLUT, right
22:21:04 <Lemmih> sm: OpenGL+SDL is used pretty much in the same way OpenGL+GLUT is.
22:21:17 <sm> interesting! sounds like a more powerful combination
22:21:44 <bos> do people around here use operator syntax for constructors much?
22:21:54 <faxathisia> bos: Sometimes..
22:22:21 <bos> i'm pondering whether to introduce it in a code example for the book.
22:22:43 <bos> so instead of data Doc = Concat a b, i'd write data Doc = a :* b
22:23:13 <bos> i fear for the reader's head, which will already be crammed full of novelty
22:24:06 <ac> probably best to stick with the simple approach, maybe make a footnote?
22:25:52 <bos> yeah, i'm inclined to skip it.
22:33:48 <noige_> SoE is too advanced for me
22:33:50 <noige_> hahaha
22:33:55 <noige_> god I am such a noob
22:38:27 <porrifolius> Does the DisambiguateRecordFields let me reuse record names across records in the same module?
22:40:05 <ac> how do I write multi threaded GUI applications using gtk2hs?
22:40:17 <siti> use forkOS :p
22:40:24 <ac> then it crashes
22:40:29 <siti> how?
22:40:45 <ac> actually, first it complains that it's not safe, and that I have to use "unsafeInitGUIForThreadedRTS"
22:40:55 <siti> yeah well do that :p
22:41:23 <siti> it's a bit annoying because the main loop is inside c so it makes threading a bit more of a pain
22:41:46 <siti> also gtk only likes one thread but you can use a gdk function (iirc) that means you can call gtk functions from another thread
22:42:52 <ac> it shouldn't effect gtk if the spawned thread makes no gtk calls, right?
22:43:03 <siti> that should be fine :)
22:43:44 <gio123> $ runhaskell setup configure --user
22:43:44 <gio123> Warning: The field "hs-source-dir" is deprecated, please use "hs-source-dirs"
22:43:44 <gio123> Configuring HaXml-1.13.3...
22:45:31 <ac> ah, I guess my problem is my gtk program crashes with or without threads
22:45:47 <ac> got to be careful where I'm poking arrays
22:46:22 <siti> hehe
22:46:27 <siti> how does it crash? segfault?
22:46:30 <ac> yea
22:46:34 <siti> arg ok :(
22:46:43 <siti> low level code in haskell is quite a pain
22:46:48 <siti> even if it is type checked
22:47:05 <ac> indeed
22:47:08 <siti> you could try running it in valgrind that can sometimes give hints
22:47:24 <ac> I don't think I would understand those sort of hints
22:47:35 <siti> ok
22:50:42 <ac> want to see the code?
22:50:56 <siti> well I could have a look but I don't know if I can help
22:51:18 <hpaste>  ac pasted "silly crashing gtk program" at http://hpaste.org/5970
22:51:39 <ac> I don't really know what I'm doing, but I've gotten a very similar program to work
22:51:44 <siti> ok
22:51:53 <ac> it should show a 512x512 black window
22:52:17 <siti> can't you use cairo to do the graphics in a more sane way :p
22:52:38 <siti> writing directly to pixels is quite bad practice since it never can be accelerated
22:53:01 <ac> huh. What's a better way to manipulate pixels?
22:53:14 <siti> so removing pokeArray stops it crashing?
22:53:25 <siti> cairo is the best way to draw 2D graphics :)
22:53:37 <siti> it's all nicely anti-aliased
22:53:44 <ac> (or the * 3)
22:54:09 <Zao> siti: Provided you manage to build it and make it not throw up, sure.
22:54:26 <siti> it's hard to build it ?
22:54:59 <jeffz> alternatively, you can use SDL, where you blit to a surface and then when the surface is ready to be displayed you flip the screen.
22:55:13 <Zao> siti: On Windows, it is.
22:55:22 <siti> oh, silly windows ;)
22:55:39 <ac> Maybe I should be using SDL
22:55:42 <Zao> siti: Yes, the platform with the users. :)
22:56:12 <siti> Zao: maybe you should use GDI ;)
22:58:03 <osfameron> cairo can write to sdl can't it?
22:59:26 <jeffz> osfameron: strangely the cairo website says it's tricky, I'm not sure what sort of endorsement that is.
23:00:28 <osfameron> heh
23:00:30 <osfameron> odd though
23:06:56 <glguy> ?seen dons
23:06:57 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I last heard dons speak 1h 4m 23s ago.
23:07:00 <ac> interesting. If I move the pixbuf construction in to main it works
23:10:11 <oerjan> ac: i recall GUI libraries often use thread-local state <-> can be called only from the main thread
23:15:33 <ac> so how does forkOS work?
23:15:43 <ac> are variables shared in both threads?
23:15:59 <siti> yep variables are shared
23:16:07 <siti> if you want to communicate use MVars or Chans
23:17:29 <Lemon> Is there a library function to parse a string like "Thu, 28 Feb 2008 00:54:07 -0500" into a Data.Time value?
23:18:02 <oerjan> from the doc i reckon the only visible difference is the behavior of ffi calls
23:19:03 <oerjan> it seems to imply that other parts of the IO action _might_ still be run in another OS thread
23:20:07 <ac> hrm. I was hoping to write to a pixbuf and have it be drawn in a different thread
23:20:25 <ac> not working
23:20:44 <siti> you probably can but only through a lock :(
23:21:12 <oerjan> well if both writing and drawing uses GUI library calls...
23:21:25 <oerjan> (ffi calls)
23:22:14 <ac> the writing does not use GUI library calls. I'm using pokeArray :-P
23:22:32 <oerjan> then you should be able to do the writing in another thread
23:22:56 <ac> that's what I thought
23:23:14 <oerjan> note that laziness can trip you up there
23:23:37 <oerjan> because if some evaluation is not actually forced until it is drawn...
23:23:39 <ac> how so? This is all in IO
23:24:16 <ac> and it's definitely redrawing it.... I made it redraw every 500ms
23:24:30 <oerjan> hm, although that should only cause things to happen in a different thread than you expect
23:25:19 <siti> ac: you want to use: Gtk.postGUIAsync
23:25:32 <siti> for a thread to do stuff to the main gui
23:26:12 <oerjan> @hoogle pokeArray
23:26:13 <lambdabot> Foreign.Marshal.Array.pokeArray :: Storable a => Ptr a -> [a] -> IO ()
23:26:13 <lambdabot> Foreign.Marshal.Array.pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
23:26:51 <oerjan> hm not much scope for laziness in pokeArray
23:27:11 <siti> well it's a very low level function
23:27:20 <siti> it's pretty much a list memcpy ;)
23:27:42 <ac> siti: what does postGUIAsync do?
23:28:26 <ac> and where is it in the API?
23:28:42 <siti> it sends (safely) a message to the gtk main loop telling it to run whatever parameter you give it
23:29:18 <siti> I don't know where it is in the api
23:30:02 <siti> http://www.haskell.org/~duncan/soegtk/Graphics/SOE/Gtk.hs
23:30:06 <siti> this has an example of it
23:30:26 <ac> ah cool
23:30:29 <siti>   Gtk.unsafeInitGUIForThreadedRTS       forkIO (main >> Gtk.postGUIAsync Gtk.mainQuit)       Gtk.mainGUI
23:30:35 <ac> Graphics.UI.Gtk.General.General
23:30:38 <siti> ok
23:31:13 <ac> how does sending "IO ()" values around threads work behind the scenes?
23:32:10 <siti> sorry I don't quite understand
23:35:24 <ac> just wondering how postGUIAsync is implemented
23:35:27 <oerjan> @src IO
23:35:27 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
23:35:52 <siti> #src RealWorld
23:35:57 <siti> @src RealWorld
23:35:57 <lambdabot> Source not found. I am sorry.
23:36:04 <siti> lol it does not exist :p
23:36:23 <oerjan>  @src misses all sorts of things.  even from the Prelude.
23:38:03 <ac> I think my problem is an understanding that doesn't have to do with gtk
23:38:09 <ac> *misunderstanding
23:41:30 <hpaste>  ac annotated "silly crashing gtk program" with "it does not work" at http://hpaste.org/5970#a1
23:42:11 <ac> it doesn't crash though
23:43:27 <oerjan> er not forkOS main ?
23:44:06 <ac> I've tried both
23:44:15 <ac> neither crash, and neither do anything
23:44:26 <ac> (beyond opening a white window. "test" should make it black)
23:47:03 <ac> my problem I think is that multiple pixbufs are being created
23:48:02 <oerjan> oh, of course.
23:48:24 <ac> specifically in the test do block
23:48:43 <ac> when I say "pb <- pixbuf" I assume the pixbuf do block is getting run again
23:49:10 <oerjan> yeah
23:49:30 <ac> so how do I make the same Ptr available in the top level?
23:49:32 <oerjan> you have no shared state between the two actions
23:49:37 <ac> yeah
23:50:02 <oerjan> can you create a pixbuf before doing initGUI?
23:50:12 <ac> The problem is the Ptr is stuck in an IO monad
23:50:33 <oerjan> well ghci does allow binding to the result of IO actions
23:50:59 <ac> I think the way to do it is to return the ptr from main
23:51:11 <oerjan> my suggestion: do pb <- pixbuf in ghci
23:51:25 <ac> and then pass it to main?
23:51:26 <oerjan> then pass it as a parameter to both main and test
23:51:31 <ac> ah yeah
23:51:49 <ac> or have main return it. Either way, somehow the Ptr has to be attached to the initGUI
23:51:56 <ac> er, I mean share state with it
23:52:16 <oerjan> can main return?  doesn't mainGUI wait until the GUI ends?
23:52:32 <ac> forgot about that. It could spawn a thread inside there
23:56:12 <ac> w00t
23:56:30 <Gilly> is there a way to check if some function is undefined?
23:57:17 <hpaste>  ac annotated "silly crashing gtk program" with "now it works" at http://hpaste.org/5970#a2
23:57:22 <oerjan> Gilly: if it's undefined because of non-termination, then no.  it's the halting problem, after all.
23:57:44 <Gilly> let's assume it's terminating
23:57:47 <oerjan> otherwise you _might_ be able to use Control.Exception.catch from IO
23:58:09 <Gilly> hm, gets ugly
23:58:11 <ac> this makes me happy for some reason
23:59:16 <oerjan> i think StrictCheck does such testing, don't know how but suspect it uses catch
23:59:17 <ac> Lemmih: yes drawing things interactively is fun. I don't care if it's useless :-P
