00:01:04 <dolio> > pi :: Pico
00:01:05 <lambdabot>   add an instance declaration for (Floating Pico)
00:01:05 <lambdabot>     In the expression: pi :...
00:02:13 <dolio> faxathisia: That equational reasoning library would probably come in handy for this. :)
00:05:48 <faxathisia> could you compile the standard library? I found some files did but got a segfault on Data.Bool.Properties
00:06:42 <dolio> I haven't tried. I had them added to the search path for a while, though. I don't think I ever touched that module, though.
00:07:06 <dolio> I took them out of the search path, though, because there's too much name overlap with the modules I made.
00:08:15 <dolio> The wiki page for the library says what flag to pass to agda/emacs variable to set to be able to use them.
00:11:40 <faxathisia> this is hard :)
00:12:00 * faxathisia has a go at some lemmas about ≢ then..
00:14:39 <glguy> dons: ?
00:14:40 <glguy> ?seen dons
00:14:41 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 13m 43s ago.
00:15:13 <dons> glguy: yo, briefly
00:15:23 <glguy> so I figured out the sqlite issue in fastcgi
00:15:27 <glguy> sqlite creates temp files
00:15:33 <dons> ah ha
00:15:34 <glguy> and needs a directory it can write to
00:15:43 <dons> yep.
00:16:19 <smtms> glguy, was it easy to figure out?
00:17:09 <glguy> that that was what was causing the problem?
00:17:19 <glguy> It wasn't immediately obvious to me
00:17:22 <glguy> but I don't use sqlite that much
00:17:38 <glguy> the error just said it couldn't open the database
00:17:51 <glguy> and it only threw it on writes
00:17:57 <glguy> reads worked fine
00:31:35 <monochrom> @src reverse
00:31:36 <lambdabot> reverse = foldl (flip (:)) []
00:32:45 <monochrom> Oh, the worker-wrapper transformation paper has a more detailed version. :)
00:37:39 <dmwit> More detailed?
00:37:59 * dmwit tries to imagine what that might mean
00:38:08 <dobblego> with comments :)
00:38:39 <dmwit> heh
00:41:31 <olsner> foldl {- this is the fold -} (flip {- flip the function -} (:) {- here we use the cons operator as a function -}) [] {- and for the empty list, the reverse is the empty list -}
00:41:56 <olsner> see, clarity!
00:42:03 <Vq^> :/
00:42:17 <smtms> LOL
00:44:09 <noige__> hi
00:44:14 <Vq^> noige__: hiya
00:44:32 <noige__> oh great now I have two _
00:44:36 <wagle_home> too bad you cant include the contents of urls in comments:  foo {- insert http://www.shakespeare.edu/~hamlet/long-edition.html here -} baz
00:44:37 <lambdabot> Title: shakespeare.edu
00:44:43 <noige__> I forgot I was still logged in at work
00:44:46 <Vq^> olsner: a small glossary above or beneath would be approximately 534 times better
00:46:09 <olsner> Vq^: but wait, then you'd be able to see the code and possibly, like, understand it... how's that better? :P
00:46:41 <Vq^> olsner: you mean you can't obscure Haskell code without adding bad comments? :o)
00:46:58 <olsner> it is possible, I am sure
00:47:10 <quicksilver> haskell suffers from poorly named functions
00:47:16 <quicksilver> that's partly why we need comments
00:47:31 <quicksilver> find should be called findElementInListByUsingBooleanFunctionReturningMaybe
00:47:42 <Vq^> heh
00:47:53 <Vq^> and length should be nonGenericLength
00:47:53 <quicksilver> that would be much cleareer!
00:50:07 <mrchebas> quicksilver: thanks goodness that find has a type signature
00:50:12 <quicksilver> (:) could be renamed buildListByUsingAnElementAndAnExistingListNoteAsymmetricTypeBeware
00:50:28 <quicksilver> java programmers would feel much more at home :)
00:50:59 <olsner> don't you mean haskell.util.list.buildListByUsingAnElementAndAnExistingListNoteAsymmetricTypeBeware?
00:51:23 <quicksilver> that would be even better, yes
00:51:27 <adu> lol
00:51:34 <wagle_home> if your identifier wraps around in your editor less than 5 times, its too short
00:51:37 <adu> you ppl are insane
00:51:44 * doserj considers org.haskell.util....
00:51:54 <quicksilver> better still would be to allow people to configure their chosen identifiers by editing a 10 megabyte XML config file.
00:52:08 <adu> quicksilver: yes!
00:52:40 <quicksilver> and each source file could embed, at the top, a large chunk of XML specifying the naming conventions enforced in this file.
00:52:42 <Vq^> hmm, Haskell really needs to adopt XML
00:52:43 <quicksilver> I think we're on to something here!
00:52:45 <olsner> combineListWithFunctionFromLeft(functionToUseForCombiningValues := (reverseArgumentsOfFunction haskell.util.list.buildListByUsingAnElementAndAnExistingListNoteAsymmetricTypeBeware?), valueToUseForEndOfList := [])
00:53:03 <Samburger> I shall call it Haskell#
00:53:05 <Vq^> blocks by indentation is far to hard to interpret
00:53:08 <adu> then I could have s/RealFloat/Flo/ and s/RealFrac/Round/
00:53:42 <quicksilver> ther could be a J mode which reduces everything to a single character and errors if you have more than 26 identifiers in scopre at any one place.
00:53:43 <dmwit> You can have that anyway!
00:53:46 <jeffz> it would probably be beneficial to allow spaces in such long names
00:53:48 <dmwit> adu: type?
00:54:14 <adu> dmwit: can you alias typeclasses?
00:54:16 <wagle_home> identifiers should use a markup language to specify how they should be displayed
00:54:27 <olsner> heh, you could sort all visible names alphabetically and number them a-z
00:54:47 <doserj> just use guid's for identifiers
00:54:51 <dmwit> adu: Ah, never mind.
00:55:34 <quicksilver> you can sort-of, can't you?
00:55:43 <wagle_home> musical chords should be identifiers
00:55:46 <quicksilver> class OldName a => NewName a where
00:55:57 <adu> only without 'where'
00:56:11 <quicksilver> I thought that's how you wrote an empty where
00:56:19 <quicksilver> but maybe you can miss it out completely too?
00:57:00 <noige__> anyone here work with haskell on a mac?
00:57:03 <noige__> ppc mac
00:57:08 <adu> noige_: me
00:57:19 <quicksilver> I have done in the past, although I'm not using one now.
00:57:31 <wagle_home> me, but i havent tried hard to get ghc to work
00:57:32 <noige__> are there any differences that I will notice as a newbie?
00:57:47 <adu> noige_: differences between what?
00:57:57 <noige__> x86 -> ppc
00:58:06 <quicksilver> shouldn't be any differences, no.
00:58:10 <noige__> ok
00:58:20 <wagle_home> someone ported ghc 6.8.2 to x86, but not ppc
00:58:30 <adu> noige_: there are tons of differences between x86 and ppc, but ghc is the same :)
00:58:30 <noige__> normally I would not ask that, I am not assuming anything with this.
00:58:34 <quicksilver> there is a problem that they can't get 6.8.x to compile on leopard/ppc
00:58:38 <quicksilver> but 6.6 is/was fine.
00:59:30 <adu> I noticed that OpenGL didn't work in ghc so I recompiled it and it works fine...
01:09:28 <Mr_Awesome> (MonadState S m, MonadError E m) => m A  -- does this type correctly mean value of type A in a monad that has state S and may contain errors represented by type E?
01:09:52 <faxathisia> > foldr (:) z [a,b,c]
01:09:54 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
01:09:59 <faxathisia> > foldr (:) z [a,b,c] :: [Expr]
01:09:59 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
01:10:23 <dmwit> > foldr (:) [z] [a, b, c] :: [Expr]
01:10:25 <lambdabot>  [a,b,c,z]
01:10:39 <dmwit> Mr_Awesome: Yes.
01:10:44 <faxathisia> thanks dmwit
01:11:43 <Mr_Awesome> dmwit: excellent. is there perhaps a way to write an alias to that, or is it a better idea to just write that whole thing for every function that uses that monad?
01:12:08 <dmwit> I think the "type" keyword is for exactly that kind of aliasing.
01:12:50 <Mr_Awesome> i thought type didnt let you have contexts?
01:13:59 <dmwit> You could be right.
01:14:16 <Mr_Awesome> perhaps newtype then?
01:14:33 * olsner is installing leksah
01:14:33 <dmwit> Yeah, but then you get that annoying constructor matching all over the place.
01:14:39 <Mr_Awesome> or maybe i ought to just leave the annotations in
01:14:48 <Mr_Awesome> indeed
01:15:47 <Mr_Awesome> hmm, feels rather cumbersome though to leave something like that unaliased
01:16:08 <wagle_home> it does make it easy to see whats going on though
01:16:10 <dmwit> Mr_Awesome: You could specialize it to a specific type.
01:16:28 <dmwit> Mr_Awesome: Or, you could create your own class.
01:16:41 <Mr_Awesome> yeah. im considering making my own class
01:17:43 <Mr_Awesome> hmm, but that might complicate things further
01:17:53 <dmwit> Why?
01:18:09 <olsner> wait, what, leksah *can't* parse files with tabs?
01:18:16 <dmwit> Good!
01:18:23 <Mr_Awesome> then id have to make instances for the class
01:18:25 <dmwit> (...kind of)
01:18:50 <Mr_Awesome> and the class would have no members...
01:18:53 <dmwit> Mr_Awesome: instance (MonadState s m, MonadError e m) => SE s e m where ...
01:19:43 <Mr_Awesome> did you mean class instead of instance?
01:20:34 <dmwit> nope
01:21:04 <dmwit> I don't even know if you can put context constraints there in a "class" declaration.
01:21:18 <Mr_Awesome> what would the class look like?
01:21:43 <dmwit> ?src MonadState
01:21:43 <lambdabot> Source not found. Do you think like you type?
01:22:29 <dmwit> class SE s e m where myGet :: m s; myPut :: s -> m (); ...
01:22:50 <dmwit> Although maybe you're right.
01:22:52 <Mr_Awesome> ok right. so id have to rewrite all the member functions
01:23:06 <Mr_Awesome> which would complicate things
01:23:10 <dmwit> It seems like you can put a context on class declarations, so that may be cleaner.
01:23:43 <dmwit> And an empty class/instance declaration doesn't seem so bad, you only have to write that once and you're done for all types for all time, right?
01:24:04 <dmwit> I'm confused; why would you have to rewrite anything?
01:24:18 <dmwit> Why couldn't you write myGet = get; myPut = put; etc?
01:24:32 <Mr_Awesome> thats what i meant by "rewrite"
01:24:40 <dmwit> oh =)
01:25:11 <Mr_Awesome> i know its not much work, just seems a bit cumbersome is all. i think ill just stick with the lengthy type declaration for now
01:26:23 <Mr_Awesome> thanks a lot for playing along though, dmwit :)
01:26:30 <dmwit> =)
01:35:08 <dmwit> ghci doesn't behave nicely by the time it starts swapping.
01:35:20 <Zao> Does anything?
01:35:35 <dmwit> Sure, some things at least let you quit.
01:36:12 <wagle_home> the page with the quit code on it is used at most once..  why swap it in?
01:37:23 <quicksilver> dmwit, Mr_Awesome : contexts on class declarations and contexts on instance declarations do mean rather different hings.
01:38:43 <quicksilver> contexts on class declarations - superclasses - do let you abbreviate contexts, which can be handy.
01:40:04 <wagle_home> now that i think of it, i think i;ve had it complain that my instance wasnt general enough
01:42:20 <Mr_Awesome> quicksilver: would i be able to do that without having to write such things as 'myPut' etc?
01:43:01 <Mr_Awesome> and why isnt there an instance declaration for Error e => MonadError e IO? theres only MonadError IOError IO...
01:44:21 <doserj> because of the functional dependency
01:44:51 <doserj> class Monad m => MonadError e m | m -> e where ...
01:45:08 <Mr_Awesome> ah, indeed
01:45:28 <nominolo> heh, nice bug in Real World Haskell: "[Pure code] May alter the global state of the program, system, or world"
01:45:50 <nominolo> d'oh
01:46:18 <nominolo> so all my coding style was based on totally wrong assumptions
01:48:09 <Mr_Awesome> anyone happen to know where the source for the instance declaration of MonadError IOError IO is?
01:48:45 <wagle_home> @src MonadError IOError IO
01:48:45 <lambdabot> Source not found. Just try something else.
01:48:48 <nominolo> Mr_Awesome: http://www.google.com/codesearch?q=MonadError+lang%3Ahaskell&hl=en&btnG=Search+Code
01:48:52 <lambdabot> Title: MonadError lang:haskell - Google Code Search, http://tinyurl.com/3b52gm
01:48:57 <wagle_home> @hoogle MonadError IOError IO
01:48:58 <lambdabot> No matches, try a more general search
01:49:50 <nominolo> throwError = ioError
01:50:08 <nominolo> catchError = catch
01:50:49 <Mr_Awesome> nominolo: thanks
01:58:15 <quicksilver> beware of the two catches
01:58:20 <quicksilver> :t Prelude.catch
01:58:23 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:58:26 <quicksilver> :t Control.Exception.catch
01:58:28 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
02:01:18 <Mr_Awesome> quicksilver: its okay. i just used ErrorT to solve my problems :)
02:01:42 <quicksilver> good ;)
02:02:27 <Mr_Awesome> quicksilver: btw, do you happen to know the answer to my previous question directed towards you?  would i be able to do that (write an empty class) without having to write such things as 'myPut' etc?
02:02:41 <quicksilver> yes.
02:02:59 <quicksilver> the situation is like class (Eq a) => Num a where ....
02:03:07 <quicksilver> this means that all Nums get (==)
02:03:15 <quicksilver> but, interesting, it doesn't pollute the type signature
02:03:22 <Mr_Awesome> ah. so do i just leave out the "where" and end it right there?
02:03:30 <quicksilver> :t \n m -> n + m == n - m
02:03:30 <lambdabot> forall a. (Num a) => a -> a -> Bool
02:03:34 <Mr_Awesome> well, i guess i can figure tha part out
02:03:39 <quicksilver> ^^ note the absence of Eq n the inferred type.
02:03:44 <quicksilver> that's what superclasses give you
02:03:46 <quicksilver> (smaller contexts)
02:06:05 <Mr_Awesome> ah, very nice. thanks :)
02:07:49 <faxathisia> dolio, bah! It's extremely hard in Agda 2
02:08:10 <faxathisia> dolio, I gave up and found it very easy in Coq though.. but the proof term is large
02:08:36 <dolio> Yeah, I'm still struggling. :)
02:08:44 <dolio> It's quite hard.
02:09:43 <stevan> hi, is there any way to combine ErrorT and Writer in such way that you can tell things which you later throw as error? the output i seek is: Left (returnResult, writerResult).
02:12:15 <quicksilver> stevan: you can get (Left returnResult, writeResult)
02:12:24 <quicksilver> stevan: which is close enough, I guess?
02:15:10 <stevan> yeah, i managed to get that. was just wondering if it was possible. i guess i would have to use state instead if i wanted the Left (re... format?
02:15:31 <quicksilver> I don't understand what you want.
02:15:41 <quicksilver> you *only* want the Writer in the case of failure?
02:16:16 <stevan> yeah, to log what happend.
02:16:20 <quicksilver> that's interesting.
02:16:35 <quicksilver> That's not a basic combination of ErrorT and WriterT, no.
02:16:52 <quicksilver> but you could put something together yourself
02:17:02 <Mr_Awesome> its crazy how all these "T" monads can just be chained together
02:17:07 <Mr_Awesome> how convenient!
02:17:20 <quicksilver> it's quite surprising they cna, in fact.
02:17:21 <Mr_Awesome> who thinks of this stuff?
02:17:47 <quicksilver> I don't know who invented monad transformers
02:17:52 <slarba> http://beautifulcode.oreillynet.com/2008/02/quality_begs_for_objectorienta_1.php <- seen this?
02:17:53 <lambdabot> Title: Quality Begs for Object-Orientation - Beautiful Code, http://tinyurl.com/2o8q7o
02:18:07 <Mr_Awesome> i honestly wouldnt know what to do without them
02:18:12 <slarba> It begs for a reply
02:19:09 <quicksilver> slarba: I think it's a superficial point, poorly made, with a daft and naive example.
02:19:35 <quicksilver> slarba: however I'm not a fan of posting rude comments on other people's blogs, so I won't.
02:19:51 <quicksilver> a thoughtful rebuttal would require a much more substantial analysis.
02:20:59 <dolio> Isn't the functional equivalent of passing a 'do nothing' object passing in a 'do nothing' function?
02:21:13 <dolio> Or a 'do nothing' monadic action, as the case may be.
02:22:05 <dobblego> I am currently dealing with the result of letting someone loose with Scala who thinks programming is all about writing as many side-effects as you can
02:22:20 <dobblego> grrr @ that post
02:24:07 <quicksilver> dolio: it's just a really naive posting. The author strikes me as intelligent, I think he just hadn't thought it through properl.
02:24:20 <quicksilver> dolio: or maybe he didn't explain what he meant very well.
02:24:47 <dolio> Perhaps.
02:24:57 <quicksilver> dolio: it reads like one of those idiotic aspect-oriented fanbois saying "aspect orientation is great because you can program insecurely and then add security later as an aspect"
02:25:06 <slarba> :DD
02:25:16 <quicksilver> a.k.a. : "Writing something down doesn't make it true. No matter how much you want it to be."
02:25:18 <slarba> that'd be very cool :D
02:26:34 <wagle_home> write a type inference aspect that inserts compiler errors in the code where it doesnt type check
02:26:40 <dolio> Considering that you can write Haskell programs where most functions provably don't do anything 'bad' (modulo unsafePerformIO), I don't see how the situation can be much worse than most OO languages (where you don't get such guarantees).
02:26:49 <quicksilver> pseudonym's rebuttal seems to the point
02:26:56 <olsner> what's the status and whereabouts of the parsec bytestring port btw?
02:26:59 <quicksilver> assuming I'm reading the attributions correctly.
02:27:13 <dcoutts_> olsner: ask Philippa and/or xerox
02:27:13 <quicksilver> I think your thoughts about "seams" are really just getting at the underlying issue of design for testability. It should be clear that in any idiom, having the "seams" of your design mesh well with the needs of testing it will greatly simplify the testing. So, the question becomes one of whether OO, or any other particular idiom, inherently tends to place your seams where you need them without thought from the programmer. I
02:27:36 <olsner> @seen Philippa
02:27:36 <lambdabot> Philippa is in #scannedinavian, #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa speak 12h 49m 44s ago.
02:27:42 <olsner> @seen xerox
02:27:42 <lambdabot> xerox is in #haskell-blah, #haskell-overflow and #haskell. I last heard xerox speak 16h 20m 56s ago.
02:27:47 <slarba> I think the writer is too much locked in the oo-mechanisms
02:27:51 <quicksilver> Ah no, that was "Andrew"
02:27:58 <quicksilver> I did misread the attributions :)
02:28:01 <quicksilver> stupid blog-software.
02:28:01 <dobblego> quicksilver, Pseudonm's response is about IO
02:28:07 <quicksilver> dobblego: yeah, I worked it out now.
02:28:25 <quicksilver> the fact that pseudonym's real name is Andrew didn't help my confusion.
02:28:39 <dobblego> what's the syntax for changing one part of a data type?
02:28:49 <quicksilver> foo { bar = 5 }
02:28:54 <quicksilver> if your data type is record-syntax
02:29:04 <dobblego> what is foo there?
02:29:21 <quicksilver> a variable of record type.
02:29:25 <dobblego> ah yes, thanks
02:29:51 <quicksilver> data Point = Point { x :: Int, y :: Int}; pt = Point { x = 5; y = 3} ; otherpt = pt { x = 6 }
02:30:39 <dobblego> got it, cheers
02:33:50 * dolio gives up on his proof for a while.
02:34:14 <dobblego> dolio, are you intending to respond?
02:34:32 <dolio> No, I'm playing around with agda.
02:34:44 <dobblego> oh
02:34:55 <dolio> I've been trying to prove that 'reverse (l1 ++ l2) == reverse l2 ++ reverse l1'
02:35:27 <faxathisia> I've got that one
02:35:30 <dolio> faxathisia already proved it for the direct definition of reverse and ++, but I've been trying to do it for version defined in terms of foldr and foldl.
02:35:32 <dobblego> that sounds like good fun
02:35:38 <faxathisia> ahh
02:35:40 <dolio> Which is quite hard, it turns out.
02:35:53 <faxathisia> Yes It's very hard with reverse defined in terms of fold
02:36:14 <faxathisia> Maybe it would be easier prove that the two definitions of reverse are equivalent
02:36:33 <dolio> I'm stuck at 'foldr _::_ zs (foldl (flip _::_) [] xs) == foldl (flip _::) zs xs'.
02:38:32 <dobblego> is it possible to change the order of function application syntax? i.e. x f instead of f x
02:38:55 <quicksilver> well you could define an infix which is flip ($)
02:39:07 <dobblego> yeah I guess
02:39:11 <quicksilver> and you could probably hack some remarkable type class trickery
02:39:18 <quicksilver> but you can't change haskell's basic syntax, no.
02:39:25 <quicksilver> haskell doesn't have configurable syntax
02:39:29 <dolio> You could program in factor.
02:39:38 <quicksilver> although you can pull off tricks which almost make it feel like it does.
02:39:40 <Mr_Awesome> and for good reason. its complicated enough as it is
02:50:54 <jeffz> this is a strange way to ask for help... http://haskell.org/haskellwiki/User_talk:Nacithopheps
02:52:04 <faxathisia> One feature I have seen nowhere is the ability to define associativity on some operator (•), and reason with the expression a • b • c as (a • b) • c or a • (b • c) implicityl
02:52:34 <faxathisia> I suppose there's some way to add it
02:55:19 <quicksilver> faxathisia: are you talking about agda or haskell now?
02:56:41 <faxathisia> agda or anything like it
03:00:02 <Lord_Illidan> a question, is the OR in haskell || like in java?
03:00:15 <faxathisia> Lord_Illidan, yes
03:00:22 <Lord_Illidan> thanks
03:00:35 <faxathisia> Lord_Illidan, one nice thing of note is you can actually implement || on haskell
03:00:49 <faxathisia> (which is not possible in java)
03:00:58 <faxathisia> s/on/in/
03:01:02 <Lord_Illidan> : t ||
03:01:12 <faxathisia> Bool -> Bool -> Bool
03:01:15 <Lord_Illidan> :t ||
03:01:19 <lambdabot> parse error on input `||'
03:01:25 <faxathisia> @src (||)
03:01:25 <lambdabot> True  || _ =  True
03:01:25 <lambdabot> False || x =  x
03:01:30 <faxathisia> :t (||)
03:01:31 <lambdabot> Bool -> Bool -> Bool
03:01:33 <Lord_Illidan> thanks
03:07:00 <Lord_Illidan> @ True || False
03:08:09 <quicksilver> > True || False
03:08:12 <lambdabot>  True
03:08:23 <Lord_Illidan> that's what I meant to use
03:08:26 <int-e> > True || error "I'm neither true nor False"
03:08:27 <lambdabot>  True
03:08:28 <Lord_Illidan> forgot how to use the bot
03:08:32 <Lord_Illidan> http://www.haskell.org/haskellwiki/Lambdabot
03:08:32 <lambdabot> Title: Lambdabot - HaskellWiki
03:08:34 <int-e> > False || error "I'm neither true nor False"
03:08:36 <lambdabot>  Exception: I'm neither true nor False
03:08:40 <Lord_Illidan> > False || False
03:08:41 <lambdabot>  False
03:08:52 <Lord_Illidan> > False xor False
03:08:52 <lambdabot>  Couldn't match expected type `(a -> a -> a) -> Bool -> t'
03:09:14 <int-e> > error "I'm neither True nor False" || True
03:09:15 <lambdabot>  Exception: I'm neither True nor False
03:11:28 <dolio> > False /= False
03:11:30 <lambdabot>  False
03:11:37 <smg> hello
03:11:56 <dolio> > (False /= False, True /= False, False /= True, True /= True)
03:11:57 <lambdabot>  (False,True,True,False)
03:12:03 <smg> can i somehow get "abcdef" into ["a","b","c","d","e","f"] ?
03:12:16 <dolio> > map return "abcdef"
03:12:17 <lambdabot>   add an instance declaration for (Show (m Char))
03:12:25 <quicksilver> > map (\x -> [x]) "abcdef"
03:12:26 <dolio> > map return "abcdef" :: [[Char]]
03:12:28 <lambdabot>  ["a","b","c","d","e","f"]
03:12:28 <lambdabot>  ["a","b","c","d","e","f"]
03:12:43 <smg> i see
03:12:47 <DukeDave> Hey everyone, I have the opportunity to give a 5/10 minute demo of Haskell this afternoon (we have these ad-hoc 'nano tech talks' every Friday where I work)
03:12:59 <RayNbow> > map show "abcdef"
03:13:00 <lambdabot>  ["'a'","'b'","'c'","'d'","'e'","'f'"]
03:13:02 <DukeDave> So I'm open to suggestions
03:13:05 <RayNbow> oh wait
03:13:10 <smg> dolio: for what do i need :: [[Char]] ?
03:13:12 <RayNbow> extra quotes ;p
03:13:24 <quicksilver> smg: don't use dolio's version, use mine
03:13:26 <quicksilver> > map (\x -> [x]) "abcdef"
03:13:27 <lambdabot>  ["a","b","c","d","e","f"]
03:13:32 <smg> > map show (read "abcefg")
03:13:33 <lambdabot>  Exception: Prelude.read: no parse
03:13:49 <smg> quicksilver: ah makes sense
03:13:50 <quicksilver> using return forces the type annotation. BEcause it doesn't know which monad you mean.
03:13:52 <dolio> smg: return is for arbitrary monads. I needed it to specialize to [] so that lambdabot didn't complain.
03:13:57 <smg> but nvm thank dolio and quicksilver
03:14:05 <dolio> You probably wouldn't need it in an actual program.
03:14:07 <quicksilver> if you like monkeys, try :
03:14:07 <smg> quicksilver: i see
03:14:12 <RayNbow> > map (:[]) "abcdef"
03:14:13 <lambdabot>  ["a","b","c","d","e","f"]
03:14:14 <quicksilver> > map (:[]) "abcdef"
03:14:15 <lambdabot>  ["a","b","c","d","e","f"]
03:14:23 <RayNbow> great minds think alike? :p
03:14:24 <quicksilver> and who doesn't like monkeys?
03:14:35 <ivanm> quicksilver: apes?
03:14:56 <DukeDave> > catMaybes (map Just "abcdef")
03:14:57 <lambdabot>  "abcdef"
03:15:10 <DukeDave> Ah yes, a little too early ;)
03:15:41 <DukeDave> > (map catMaybes) (map Just "abcdef")
03:15:43 <lambdabot>  Couldn't match expected type `[Maybe a]'
03:17:04 <smg> hehe
03:17:42 <smg> ha! i understood that map(:[]) "foo" thing :)
03:18:04 <smg> have we something like isASCII in prelude?
03:20:36 <doserj> @hoogle isAscii
03:20:36 <lambdabot> Data.Char.isAscii :: Char -> Bool
03:20:36 <lambdabot> Data.Char.isAsciiUpper :: Char -> Bool
03:20:36 <lambdabot> Data.Char.isAsciiLower :: Char -> Bool
03:24:54 <liyang> smg: robot monkey operator -- (:[])
03:25:10 <quicksilver> monkeys are vicious. The can even eat comments
03:25:21 <quicksilver> (:[{- how big is its mouth? -}])
03:25:26 <ricky_clarkson> Is there a technical name for a constraint that a function that a -> a -> Integer should return the opposite sign if the arguments are provided in the opposite order?
03:25:35 <quicksilver> ricky_clarkson: anti-commutative
03:26:16 <ricky_clarkson> Wow, thanks.
03:28:55 <Taejo> I can has kell?
03:30:31 <Lord_Illidan> any one used ghci under windows?
03:30:38 <Lord_Illidan> I'm trying to help out my friend
03:30:41 <ricky_clarkson> Is there any way to specify that constraint in Haskell, or at least indicate it in types?
03:30:50 <ricky_clarkson> the anti-commutativity constraint.
03:31:08 <jeffz> Lord_Illidan: there shouldn't be anything different about windows, do you have a specific question?
03:31:33 <Lord_Illidan> so there isn't anything different, right?
03:31:48 <Lord_Illidan> well, nothing, but my friend has no idea how to use it
03:32:01 <jeffz> tell him to read the manual.
03:32:14 <Lord_Illidan> good idea
03:32:53 <jeffz> Lord_Illidan: if he was smart, he'd be asking you "how do I do x?" "how do I do y?"
03:32:53 <bezik> ...or install ghci under cygwin if he already has idea how to use it under unix)
03:33:06 <Lord_Illidan> bezik, she has no idea about linux/unix
03:33:30 <quicksilver> ricky_clarkson: types in haskell tell you nothing about how different values behave.
03:33:43 <quicksilver> ricky_clarkson: that's not very well put, but I hope you know what I mean.
03:33:48 <ricky_clarkson> Yes.
03:34:10 <quicksilver> you can encode a certain amount by reflecting values up to the type level and making them parameters to other types.
03:34:14 <quicksilver> but it tends to be clumsy.
03:34:19 <ricky_clarkson> If you wanted to make a new type that indicated that to human readers what would you do?
03:34:56 <quicksilver> newtype AntiComm a = AntiComm (a -> a -> a) ?
03:35:07 <quicksilver> and don't export the constructor.
03:35:23 <quicksilver> and don't let the americans get hold of it, they'll think it's something to do with communism :P
03:35:41 <quicksilver> at least one US university has banned commutative operators in its constitution.
03:36:15 <ricky_clarkson> hehe
03:36:32 <ricky_clarkson> "Surely you mean counter-commutative"
03:38:52 <ivanm> quicksilver: just like some US towns tried to ban DHMO a decade or so ago because a whole bunch of websites listed how deadly and dangerous it is?
03:39:09 <ivanm> (DHMO = di-hydrogen monoxide = H2O = water)
03:39:20 <quicksilver> ivanm: well actually I made that up. I thought it had all the ingredients of a good meme, though.
03:39:24 <ivanm> heh
03:39:27 <quicksilver> I hoped some people might spread it as truth.
03:39:37 <ivanm> sure sounds real
03:39:49 * quicksilver is a memetroll
03:39:57 <ivanm> then again, a lot of people are cynics regarding yanks :p
03:43:54 <Lord_Illidan> brr..using windows to develop haskell
03:44:11 <matthew_-> ivam: it's a national pasttime
03:46:08 <ivanm> Lord_Illidan: brr..using windows
03:46:09 <ivanm> ;-)
03:46:13 <ricky_clarkson> @web1913 yank
03:46:13 <lambdabot> *** "Yank" web1913 "Webster's Revised Unabridged Dictionary (1913)"
03:46:13 <lambdabot> Yank \Yank\, n. [Cf. Scot. yank a sudden and severe blow.]
03:46:13 <lambdabot>    A jerk or twitch. [Colloq. U. S.]
03:46:13 <lambdabot>  
03:46:13 <lambdabot> *** "Yank" web1913 "Webster's Revised Unabridged Dictionary (1913)"
03:46:15 <lambdabot> [7 @more lines]
03:46:20 <ricky_clarkson> Yanks are jerks then..
03:46:25 <Lord_Illidan> heh, I use Arch Linux, it's more userfriendly
03:46:38 <ivanm> ricky_clarkson: comes from Yankee Doodle, IIRC (that's the polite derivation, anyway :p )
03:47:05 <ivanm> Lord_Illidan: I use Gentoo, it actually lets me do stuff :p
03:47:18 <Cin> short of using a case
03:47:27 <ricky_clarkson> I use Windows, it
03:47:38 <liyang> lol
03:47:47 <Cin> is there a neat way i can get from a string to values of a type? maybe if i used Enum.. sounds a bit OTT, though
03:48:00 <ivanm> Cin: values of a type?
03:48:07 <ricky_clarkson> quicksilver: Thanks for that about AntiComm before.
03:48:21 <liyang> Cin: deriving (Read), then use read / reads.
03:48:28 <Cin> ivanm: ahh, sorry. an assocation list should do the trick
03:48:49 <ricky_clarkson> Is there a way to write AntiComm algebraically so that any implementers can trivially test it?
03:48:52 <ivanm> Cin: *shrug* seeing as how I have no idea what you were talking about before... :p
03:49:00 <ricky_clarkson> @hoogle Integer -> Boolean
03:49:01 <lambdabot> No matches, try a more general search
03:49:02 <Cin> showHtml vs. renderHtml vs. prettyHtml -- i wanted to get from a string to the function, hehe
03:49:04 <ricky_clarkson> @hoogle sign
03:49:05 <lambdabot> Prelude.signum :: Num a => a -> a
03:49:05 <lambdabot> Prelude.significand :: RealFloat a => a -> a
03:49:05 <lambdabot> Control.Concurrent.QSem.signalQSem :: QSem -> IO ()
03:53:08 <smg> haskell ftw
03:53:38 <smg> i now solved my first real problem in haskell and it worked, maybe my source still sucks but.. :)
03:54:26 <matthew_-> smg: don't worry, you can spend the next 6 months reducing it to a single line of source
03:54:49 <ivanm> and making it pointfree whilst doing to
03:55:14 <smg> :D
03:55:26 <smg> what was pointfree, i forgot
03:55:39 <matthew_-> it's the subject of your next 6 months work
03:55:49 <matthew_-> but basically, no variable bindings
03:55:59 <ivanm> smg: that's when you utilize function composition as much as possible so that you don't mention variables
03:57:56 * olsner tries to think of some expression to demonstrate @pl
03:58:50 <johnnowak> @pl \a b c -> a + b * c
03:58:51 <lambdabot> (. (*)) . (.) . (+)
03:59:31 <ToRA> @pl \f xs -> let r1 = map f xs in concat r1
03:59:31 <lambdabot> (=<<)
03:59:41 <ToRA> mmm, more pointfree than i expected...
04:00:04 <smg> ivanm: ah okay
04:01:08 <Cin> like this
04:01:09 <Cin> styleFunc :: Maybe String -> Html -> String
04:01:09 <Cin> styleFunc = fromMaybe showHtml . flip lookup funcs . fromMaybe "" where funcs = [("showHtml",showHtml),("renderHtml",renderHtml),("prettyHtml",prettyHtml)]
04:01:12 <Cin> :D
04:01:39 <Cin> for this web page: http://rtfs.ath.cx/poller/Poller.fcgi?htmlstyle=renderHtml
04:01:48 <Cin> (or sauce: http://rtfs.ath.cx/poller/Poller.hs)
04:03:29 <Cin> for pondering different styles of html output >_>
04:04:25 <smg>  f_c3 = filter rmwrong . map concat . map rmws <-- is
04:04:28 <smg> ivanm: is this okay?
04:05:11 <pitecus> is there a strict version of Binary.decode? evertime i try to use Binary with a non-minuscule data it blows the stack...
04:05:14 <ivanm> smg: I have no idea what you were trying to do, so don't ask me :p
04:05:26 <smg> ivanm: no i mean is this pointfree?
04:05:27 <Cin> smg: map concat . map rmws  -- this can be map (concat . rmws)
04:05:34 <smg> ok
04:05:36 <ivanm> smg: use lambdabot's @pl
04:05:39 <Cin> smg: you could do that further and put it in the filter
04:05:46 <Cin> smg: do you know how?
04:05:47 <ivanm> for example:
04:05:55 <ivanm> @pl f x y = x + y*x
04:05:55 <lambdabot> f = liftM2 (.) (+) (*)
04:06:01 <smg> Cin: no
04:06:06 <ivanm> which is a really bad example, but anyway
04:06:17 <Cin> smg: have a ponder
04:08:16 <smg> Cin: okay
04:09:01 <Cin> smg: what's rmws's type?
04:09:14 <Cin> smg: String -> String?
04:09:19 <smg> it removes whitespace in a string
04:09:20 <smg> yes
04:09:38 <Cin> so what type is (concat . rmws)?
04:10:27 <smg> String
04:10:48 <Cin> it takes a string and returns a string, right
04:10:51 <Cin> String -> String
04:11:34 <smg> yes
04:11:38 <Cin> what would the type of (rmwrong . concat . rmws) would be?
04:11:44 <Cin> s/would be/be
04:11:55 <smg> [String]
04:12:09 <Cin> no
04:12:18 <Cin> it's a function, so remember it will be something -> something
04:12:30 <smg> ah
04:12:44 <Cin> try reading it right to left
04:13:02 <Cin> the types go:
04:13:05 <Cin> String -> String
04:13:08 <Cin> String -> String
04:13:10 <Cin> String -> Bool
04:14:15 <Cin> so the type of (rmwrong . concat . rmws) is String -> Bool
04:14:17 <Cin> :t filter
04:14:28 * Cin prods lambdabot
04:14:31 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:14:51 <Cin> right. so filter takes anything to Bool, so our String -> Bool function satisfies that type
04:15:04 <Cin> anyhoo.
04:20:08 <matthew_-> you know you're in trouble when ... you make one little change, and the type sig that ghci previous reported as 4 lines is now 40 lines long
04:20:34 <Cin> a 40-line-long type signature? :P
04:21:00 <matthew_-> yeah, of which 36 lines are class contexts
04:21:08 <olsner> wow!
04:21:22 <Cin> haha
04:21:31 <matthew_-> nah, I'm used to it. Seeing as my PhD practically amounts to abusing the Haskell type system
04:22:27 <hpaste>  matthew-_ pasted "enjoy" at http://hpaste.org/5812
04:22:40 <Cin> oh lawd
04:22:56 <quicksilver> cute
04:23:12 <olsner> some kind of interpreter in the type system?
04:23:16 <quicksilver> I"m not sure about typevars of the form
04:23:17 <matthew_-> yeah basically
04:23:18 <quicksilver> b''2
04:23:23 <matthew_-> that's ghci's inference
04:23:27 <quicksilver> that's a bit hard for my eyes to parse
04:23:28 <quicksilver> really?
04:23:31 <matthew_-> ja
04:23:36 <quicksilver> I've never seen it mix 's and 2s before
04:23:44 <matthew_-> it's special
04:23:47 <quicksilver> ;)
04:23:51 <matthew_-> -ly confused
04:23:55 <quicksilver> evidentily.
04:24:04 <osfameron> eeeek!
04:24:23 <osfameron> I like ' at the end of a token, that looks very odd
04:24:29 <Cin> Ook?
04:24:38 <osfameron> well, I can parse tokens like "it's" and "don't" in English, but it looks odd in haskell
04:24:43 <matthew_-> tbh, I think it's gone and expanded out a class context to its super classes and that multiplies them somewhat
04:25:03 <quicksilver> matthew_-: it's supposed to reduce to superclasses
04:25:21 <quicksilver> > :t \x y -> x+y == x
04:25:21 <lambdabot>  Parse error at "\x" (column 4)
04:25:28 <quicksilver> :t \x y -> x+y == x
04:25:37 <lambdabot> forall a. (Num a) => a -> a -> Bool
04:25:44 <quicksilver> ^^ note Eq constraint has been reduced
04:26:01 <LoganCapaldo> @let it's x = x
04:26:03 <lambdabot> Defined.
04:26:14 <LoganCapaldo> > it's "fun time"
04:26:16 <quicksilver> osfameron: I have occasionally used tokens like insert'leaf
04:26:21 <lambdabot>  "fun time"
04:26:23 <quicksilver> osfameron: but insert'2 looks odd
04:26:27 <Cin> how do you guys get some milliseconds in haskell for use with rudimentary speed observation?
04:26:40 <osfameron> quicksilver: why not insert_leaf out of interest?
04:27:16 <Cin> ie do t1 <- getMillisecs; someComputation; t2 <- getMillisecs; -- t2-t1
04:27:18 <LoganCapaldo> he's an ex-Ada programmer ;)
04:27:24 <quicksilver> osfameron: because I already have insert' as an auxiliary funciton called by insert
04:27:33 <quicksilver> osfameron: insert'leaf is a "private" function to insert'
04:27:47 <quicksilver> it's a kind of adhoc namespacing
04:27:55 <osfameron> aha
04:28:12 <quicksilver> if the wind had been blowing a different way I would have done
04:28:19 <quicksilver> insert, insert_aux and insert_aux_leaf
04:32:40 <Lemmih> "forking not supported with +RTS -N<n> greater than 1", wtf?
04:33:37 <quicksilver> forking as in forkProcess ?
04:33:59 <Lemmih> Ah, that might be. I was thinking of 'forkIO'.
04:34:16 <quicksilver> forkProcess is very unsafe with multiple threads running
04:34:24 <quicksilver> (unless your only intention is to later exec)
04:34:36 <quicksilver> I didn't think it was actually forbidden, though. just dangerous.
04:37:12 <Lemmih> Why is it unsafe?
04:37:34 <quicksilver> because it doesn't duplicat all threads
04:37:41 <quicksilver> and you don't really know where you are w.r.t. OS resources
04:37:48 <quicksilver> some info at http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html#v%3AforkProcess
04:38:05 <quicksilver> this is not really haskell-specific I don't think: I think it's generally dangerous to mix fork() and threads
04:38:12 <eugman|college> Anyone know any articles about very simple state passing?
04:40:38 <pitecus> so i found Data.Binary.Strict.Get. Could someone explain how to define a strict decode in terms of it?
04:40:40 <Cin> yaht's chapter on monads?
04:40:50 <Lemmih> So I should use System.Process instead of forkProcess+executeFile?
04:41:18 <Lemmih> pitecus: Same way you define a lazy decoder.
04:41:38 <eugman|college> cin, hmm i'll go abck and look at it
04:43:52 <pitecus> Lemmih, so define all the Binary instances...
04:44:30 <smg> btw does haskell support classes?
04:44:40 <nilsi> anybody of realworldhaskell here?
04:44:44 <Lemmih> pitecus: Yep.
04:44:55 <Lemmih> smg: We support type classes. (:
04:45:07 <smg> ah okay
04:46:24 <nilsi> I think table 6.1 of realworldhaskell is flawed
04:46:35 <nilsi> pure code changes the world ..
04:47:00 <Cin> i was dreaming about coding haskell this morning. i hate dreaming about coding because i'm sleeping to take a rest from coding, not spend another hour before i wake up debugging imaginary code. -_-
04:47:32 <nilsi> cin: so what is the problem with haskell?
04:48:14 <Cin> nilsi: well it's making me dream about coding D:
04:48:36 <byorgey> nilsi: so go ahead and attach a comment to the table =)
04:48:49 <nilsi> cin: but you do not dream of debugging with haskell
04:48:53 <smg> Cin: haha me too
04:49:12 <Cin> nilsi: haha. okay, type-safe dreams, but i have to think about what i'm going to write ;D
04:49:55 <Cin> smg: horrid, isn't it. :P
04:50:05 <nilsi> cin: but that is not debugging.. also a major problem sometimes (and in haskell necessary bofre the actual programming)
04:50:23 <smg> Cin: yeah i dreamed and woke up and worte a page of haskell code with my pencil on a paper
04:50:29 <smg> and then i went sleeping again
04:50:41 <Cin> smg: 102% immersion!
04:50:47 <smg> :]
04:51:10 <nilsi> smg: for me it is the other way round
04:52:57 <nilsi> ok, the mistake is already in the comments
04:53:34 <smg> hehe
04:57:19 <eugman|college> is (>>  (putStr  "hi") ) analogous to (*2) in the way I think it is?
04:57:48 <Igloo> Yes
04:58:21 <Igloo> (operator expr) desugars to (\x -> x operator expr)
05:03:47 <pjd> (\x -> x `operator` expr), you mean
05:04:25 <olsner> operators don't have ``
05:04:28 <pjd> well, given (`operator` expr)
05:05:11 <olsner> but he did say (operator expr) rather than (`operator` expr)
05:05:45 <smg> is there a way to do let number = read getLine ?
05:05:50 <smg> it fails in ghci
05:06:20 <smg> i need to to {input <- getLine; number = read input; }
05:06:34 <pjd> smg: number <- readL
05:06:37 <pjd> readLn, even
05:06:43 <smg> ah okay
05:06:50 <eugman|college> let's don't work in ghci right?
05:06:54 <Beelsebob_> or number = getLine >>= read
05:07:01 <pjd> eugman|college: they do
05:07:11 <Beelsebob_> orry, number <-
05:07:14 <Beelsebob_> not number =
05:07:29 <smg> Beelsebob_: can you explain >>= i don't know that
05:07:40 <Beelsebob_> it's bind
05:07:48 <Beelsebob_> @type (>>=)
05:07:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:08:03 <eugman|college> oh I must be thinking of something else then
05:08:04 <Beelsebob_> hang on... actually, that fails
05:08:09 <Beelsebob_> you need to lift read into the monad
05:08:14 <pjd> smg: x <- readLn; ... is roughly the analogous to readLn >>= \x -> ...
05:08:21 <smg> i see
05:08:33 <quicksilver> number = read `fmap` getLine
05:08:45 <Beelsebob_> ah, yeh, that works nicely quicksilver
05:08:47 <quicksilver> but that doesn't actually make the number into a number.
05:08:55 <quicksilver> it makes it an IO action which returns a number
05:08:56 <quicksilver> ;)
05:09:13 <pjd> smg: for example, you can say: readLn >>= print to echo a number
05:09:14 <Beelsebob_> indeed... number <- read `fmap` getLine
05:09:31 <smg> >>= means IO Redirect?
05:09:31 <pjd> smg: in that case you can pronounce >>= as "into"
05:09:50 <Beelsebob_> it's essentially the same as .
05:09:55 <Beelsebob_> but it works within a monad
05:10:03 <Beelsebob_> it means take the output from the first, and give it to the second
05:10:14 <quicksilver> I would normally spell `fmap` as <$> too
05:10:14 <pjd> smg: >>= is actually a combination of fmap and join
05:10:22 <Beelsebob_> so getLine >>= putStrLn reads a line, and then prints it
05:10:23 <smg> ah damn okay :)
05:10:40 <pjd> smg: and it works with any monad, not just IO
05:10:47 <smg> i see
05:10:57 <smg> and read* gives me a number as result?
05:11:08 <Beelsebob_> read is essentially a parser
05:11:16 <pjd> :t read
05:11:17 <smg> okay
05:11:18 <lambdabot> forall a. (Read a) => String -> a
05:11:29 <Beelsebob_> for Num types it reads a number in a string, and gives you the actual number
05:11:36 <smg> read :: (Read a) => String -> a
05:11:39 <Beelsebob_> > read "69"
05:11:40 <smg> what does this => mean?
05:11:42 <lambdabot>  Exception: Prelude.read: no parse
05:11:49 <pjd> > read "42" :: Int
05:11:50 <lambdabot>  42
05:11:52 <pjd> > read "42" :: Float
05:11:53 <lambdabot>  42.0
05:11:54 <smg> haha? :)
05:11:58 <Beelsebob_> smg: you can read it almost exacly as "implies"
05:12:16 <Beelsebob_> so "if a is in the class Read, then it has the type String -> a"
05:12:17 <smg> okay
05:12:27 <smg> and how do we call that :: Int after the read "42" statement?
05:12:28 <pjd> smg: type classes are great :)
05:12:31 <smg> type specification?
05:12:41 <pjd> it's usually pronounced "has type"
05:13:07 <Beelsebob_> smg: yes, you need to provide it so that the compiler knows what kind of thing read is expected to produc
05:13:14 <Beelsebob_> e.g. I could parse a string from the string too...
05:13:21 <pjd> the previous example shows how the result of  read is polymorphic
05:13:22 <Beelsebob_> > read "42" :: String
05:13:23 <lambdabot>  Exception: Prelude.read: no parse
05:13:30 <Beelsebob_> oh, need quotes
05:13:36 <Beelsebob_> > read "\"42\""
05:13:38 <pjd> it uses the Read instance of the type you request, to give the right parse
05:13:39 <lambdabot>  Exception: Prelude.read: no parse
05:13:41 <smg> wow really cool
05:13:41 <Beelsebob_> > read "\"42\"" :: String
05:13:42 <lambdabot>  "42"
05:13:58 <smg> okay now i try to write a guess the number program for practice :)
05:14:17 <pjd> smg: polymorphic values is a really nifty concept
05:15:16 <Beelsebob_> smg: what are you trying to learn at the moment, functional programming, or how to do IO in functional programming?
05:15:17 <pjd> in Haskell, literals are polymorphic:
05:15:19 <pjd> :t 5
05:15:21 <lambdabot> forall t. (Num t) => t
05:15:24 <pjd> > 5
05:15:25 <lambdabot>  5
05:15:26 <smg> Beelsebob_: all about haskell :P
05:15:30 <pjd> > 5 :: Rational
05:15:31 <lambdabot>  5%1
05:15:46 <Beelsebob_> smg: in which case, I would recommend trying to learn to do computation, before you learn to do any kind of IO
05:15:52 <pjd> > denominator 5
05:15:53 <lambdabot>  1
05:15:57 <pjd> :t denominator
05:15:58 <lambdabot> forall a. (Integral a) => Ratio a -> a
05:16:11 <smg> Beelsebob_: :)
05:16:22 <pjd> so you don't even have to declare the 5 as a Ratio, if you give it to a function expecting one
05:19:50 <idnar> :t getLine >>= read
05:19:51 <lambdabot> forall b. (Read (IO b)) => IO b
05:20:03 <Beelsebob_> hehe
05:20:31 <idnar> :t IO (>>=)
05:20:31 <lambdabot> Not in scope: data constructor `IO'
05:20:34 <Beelsebob_> @hoogle Monad m => (a -> b) -> (a -> m b)
05:20:34 <lambdabot> No matches, try a more general search
05:20:37 <idnar> er
05:20:50 <idnar> :t (>>=)
05:20:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:21:07 <pjd> :t (return.)
05:21:08 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
05:21:17 <Beelsebob_> oh, duh
05:21:30 <Beelsebob_> why didn't it find that
05:21:43 <Beelsebob_> oh, the kind constraint
05:21:58 <idnar> I don't think hoogle even knows about typeclasses, nevermind kind constraints
05:22:06 <idnar> but is that function defined anywhere?
05:22:10 <Beelsebob_> I thought neil updated it to deal with classes
05:22:16 <Beelsebob_> yes, return is defined
05:22:25 <idnar> (return.) is not return
05:22:25 <Beelsebob_> oh, but return . isn't
05:22:42 <quicksilver> Beelsebob_: hoogle can deal with classes but not lambdabot-hoogle
05:22:47 <quicksilver> Beelsebob_: I think it must still be the old version
05:22:50 <Beelsebob_> :t getLine >>= (return . read)
05:22:51 <lambdabot> forall b. (Read b) => IO b
05:23:02 <Beelsebob_> quicksilver: ah, okay
05:23:20 <Beelsebob_> hmm, it's a shame that >>= and . work in oposite directions
05:23:30 <Beelsebob_> i.e. you can't read that either left to right, or right to left
05:23:31 <pjd> =<<
05:23:44 <Beelsebob_> :t (return . read) =<< getLine
05:23:45 <lambdabot> forall b. (Read b) => IO b
05:23:52 <Beelsebob_> much nicer :
05:23:53 <Beelsebob_> :)
05:24:01 <pjd> :t read <$> getLine
05:24:02 <lambdabot> forall a. (Read a) => IO a
05:24:05 <pjd> :)
05:24:19 <pjd> bind + return just gives you fmap again
05:24:29 <Beelsebob_> yeh, I know
05:24:40 <Beelsebob_> but in reading it, it doesn't make as much sense
05:24:45 <dolio> faxathisia: ping
05:25:22 <eugman|college> haskell brain = explode brain
05:25:25 <Beelsebob_> my version says clearly "get a line, then read it, then return the value", yours says "there's getLine, and there's read, and they're kinda combined"
05:25:47 <pjd> @quote brane
05:25:48 <lambdabot> Botje says: Leading experts on haskell recommend at least twenty-four hours between brane asplosions.
05:25:53 <Beelsebob_> because you have to think more about what fmap means in the IO monad
05:26:34 <pjd> Beelsebob_: fmap is a lot more obvious than bind, methinks (in IO)
05:26:43 <Beelsebob_> hmm?
05:26:43 <Botje> haskell :: Brain -> IO (Either Asplosion Brain)
05:26:52 <Beelsebob_> bind has a nice "and then" semantics in IO
05:27:17 <Beelsebob_> fmap IMHO suggests "map this over something", but in IO actually means "just apply this to the thing in there"
05:27:37 <pjd> same as fmap over Maybe or [] :)
05:27:41 <Beelsebob_> meh, maybe it's my brain just being fussy about the way it's frased
05:27:45 <Beelsebob_> phrased too
05:28:03 <eugman|college> Heh, is your brain poorly phrased?
05:28:09 <Beelsebob_> possibly actually
05:28:28 <Beelsebob_> thinking about it more actually, fmap has a much nicer more "functional" meaning
05:28:41 <Beelsebob_> in terms of describing what to do with values, not what order to do it in
05:28:53 <Beelsebob_> so I think actually I'll concede this one to pjd
05:29:37 <pjd> Beelsebob_: bind is basically a fancier fmap, for when the function being mapped returns a monad itself
05:29:44 <pjd> which you then want to join again
05:29:49 <Beelsebob_> indeed
05:30:08 <Beelsebob_> but at least for IO bind doesn't mean "hello, I'm a fancier fmap" in a programmers brain
05:30:11 <Beelsebob_> it means "and then"
05:30:40 <pjd> so does fmap :)
05:30:51 <Beelsebob_> not to me
05:31:02 <Beelsebob_> or at least not now you've made me see the light
05:31:03 <shepheb> .oO( should "do block must end with a statement" be the "No and then!" error? )
05:31:10 <Beelsebob_> it means "do this to all the stuff in the IO monad"
05:31:32 <Beelsebob_> shepheb: absolutely it should
05:31:42 <Beelsebob_> it should be "I have this value, and you haven't told me what to do with it"
05:33:20 <nomeata> @pf flip (\f -> join . liftM f)
05:33:20 <lambdabot> Maybe you meant: bf pl
05:33:24 <nomeata> @pl flip (\f -> join . liftM f)
05:33:24 <lambdabot> (>>=)
05:34:27 <pjd> > (+1) `fmap` (*2) `fmap` readLn
05:34:28 <lambdabot>  <IO Integer>
05:34:32 <pjd> > (+1) `fmap` (*2) `fmap` (Just 5)
05:34:33 <lambdabot>  Just 11
05:34:39 <pjd> > (+1) `fmap` (*2) `fmap` [1..5]
05:34:40 <lambdabot>  [3,5,7,9,11]
05:35:01 <pjd> it's "and then" towards the left
05:35:23 <pjd> and then =<< is a fancier "and then" towards the left :)
05:36:20 <smg> http://rafb.net/p/hUfU8G48.html <-- :]
05:36:23 <lambdabot> Title: Nopaste - stdin
05:37:55 <Beelsebob_> pjd: I wouldn't read it as and then in that case though
05:38:12 <quicksilver> I disagree entirely with pjd.
05:38:18 <quicksilver> `fmap` has nothing to do with andthen.
05:38:23 <Beelsebob_> I'd read it as apply +1 to the value inside the monad described by applying *2 to the value inside the monadic entity returned by readLn
05:38:25 <quicksilver> there are no effects involved.
05:38:31 <pjd> quicksilver: it's composition
05:38:38 <quicksilver> right. It's not and-then.
05:38:38 <pjd> if that's not "and then", i don't know what is :)
05:38:45 <quicksilver> something quite different
05:38:52 <eugman|college> Currently I'm planning on starting with a very simple state system where every loop: input is gotten, a function is chosen based on input, the world state is sent through and the ouput is sent to the game loop function to recurse and start everything over. Unfortunately for any function, say a help menu, the function would have to explicitly except an argument for the world state even though it isn't dependent on it. This seems a bit clunky but
05:38:53 <Beelsebob_> bind is "and then" at least in IO
05:38:57 <pjd> anyway, YMMV, etc.
05:39:05 <quicksilver> ">>" is called "and-then" to describe the way it sequences side effects.
05:39:18 <quicksilver> putStr "hello" `andThen` putStr "world"
05:39:20 <Botje> eugman|college: you got cut off after "a bit clunky"
05:39:38 <shepheb> smg: could have number <- read `fmap` getLine, or number <- (return . read) =<< getLine
05:39:50 <pjd> or number <- readLn
05:39:55 <eugman|college> Whoops a bit gig i guess. but basically i said I have a feeling that there isn't a middle ground between my idea and fully using monads
05:39:56 <Beelsebob_> indeed
05:40:10 <Beelsebob_> eugman|college: there's nothing wrong with threading state
05:40:19 <quicksilver> eugman|college: I tend to try to make the types of things as precise as possible.
05:40:28 <smg> hehe yeah
05:40:29 <quicksilver> eugman|college: if it doesn't read the state, I don't put that in.
05:40:30 <Beelsebob_> but the State monad is essentially just giving all your State functions your extra argument
05:40:33 <shepheb> pjd: knowledge++. thanks.
05:40:35 <Beelsebob_> just not doing it explicitly
05:40:41 <quicksilver> eugman|college: if it can't use IO side effects, I don't put that in.
05:40:44 <Beelsebob_> personally, I prefer the threading state method
05:40:57 <bringert> dcoutts_, Igloo: is there a policy for what kind of projects can live on code.haskell.org?
05:41:40 <smg> the indent of haskell is a bit tricky for beginners
05:41:52 <Beelsebob_> smg: it can be, yes
05:42:05 <Beelsebob_> my first piece of advice is to set your editor to insert spaces, not tabs
05:43:18 <smg> i have tabexpand in vim :]
05:44:52 <Igloo> bringert: Just http://community.haskell.org/admin/tos.html. The only thing that might cause problems is that everything on it has to be public
05:44:53 <lambdabot> Title: Terms of Service
05:45:34 <Igloo> bringert: And obviously if you use huge amounts of any resource then we'll have to ask you to stop
05:45:49 <pjd> or contribute funds!
05:45:51 <Igloo> bringert: Oh, and everything on it must be Haskell-related
05:46:09 <bringert> Igloo: what does "activities closely related to the Haskell programming language" really mean
05:46:10 <pjd> (is there a Haskell non-profit or something?)
05:46:30 <bringert> Igloo: it seems like normal applications written in Haskell doesn't satisfy that
05:47:06 <Igloo> bringert: Applications are fine
05:47:08 <bringert> Igloo: btw, the link to http://community.haskell.org/tos.html in http://community.haskell.org/admin/tos.html is dead
05:47:21 <Igloo> Oh, thanks
05:47:33 <bringert> Igloo: but is an application "closely related to the Haskell programming language" just because it is written in Haskell?
05:47:47 <bringert> Igloo: I guess it is, depending on interpretation
05:48:00 <Igloo> bringert: Right, and it's the interpretation of the admins that matters  :-)
05:48:38 <bringert> Igloo: the reason I'm asking is that we are considering moving some large research apps (GF to begin with) to darcs at code.haskell.org
05:48:50 <smg> how would you print out 10 random numbers?
05:49:27 <smg> > mapM_ (print) [randomRIO(1::Int,100) | x<-[1..10]]
05:49:27 <bringert> Igloo: since Chalmers servers aren't adminstered as well as code.haskell.org, and since it would make it possible to allow non-Chalmers developers to contribute
05:49:36 <lambdabot>  <IO ()>
05:50:14 <pcc1> could someone kindly help me figure out why I am getting a "duplicate definition" error using hs-plugins... source here: http://hpaste.org/5802
05:50:27 <bringert> Igloo: wow, who wrote the TOS? Galois lawyers? "upon receipt of a certificate or other legal document confirming YOUR death, WE may close YOUR account"
05:51:24 <Igloo> bringert: heh, I think it was based on other TOSs
05:52:03 <Igloo> I don't know what GF is, but that sounds fine to me, as long as "large" isn't enormous
05:52:28 <bringert> Igloo: smaller than GHC
05:52:39 <Igloo> Should be fine
05:52:52 <bringert> Igloo: hmm, "YOU agree not to ... exploit for any commercial purposes use of OUR services"
05:52:58 <dolio> faxathisia: Success!
05:53:23 <bringert> Igloo: so you can't sell licenses to software hosted on code.haskell.org?
05:53:38 <bringert> Igloo: not really an issue, just interesting
05:54:29 <bringert> Igloo: bte, this is GF: http://www.cs.chalmers.se/Cs/Research/Language-technology/GF/
05:54:29 <lambdabot> Title: GF Version 2.9
05:54:35 <bringert> btw
05:54:38 <dolio> @yow!
05:54:38 <lambdabot> I hope you millionaires are having fun!  I just invested half your life
05:54:38 <lambdabot> savings in yeast!!
05:55:16 <osfameron> a sound investment
05:55:42 <Igloo> bringert: Well, at one point we were considering requiring everything to be open source, but that would mean you couldn't put, for example, papers on it. I don't think we really want commercial software on there, though
05:56:13 <bringert> Igloo: right, I meant commercial open source software.
05:56:33 <bringert> Igloo: for example dual-licensed, or where you sell support contracts
05:56:55 <bringert> Igloo: really any open source software developed for a commercial reason
05:57:08 <Igloo> That would seem reasonable to me - the software would still be a free open source download
05:59:04 <Igloo> bringert: If any grey areas come up we'll probably discuss what to do about them, anyway
05:59:30 <bringert> Igloo: true, I'm just a sucker for reading legal contracts and finding interesting corner cases
06:03:17 <smg> i have a little problem
06:03:24 <smg> if i use putStr "Give input: "
06:03:28 <smg> there will be no output
06:03:40 <smg> and if i use putStrLn "Give Input: " i have a noisy newline
06:03:40 <Igloo> hSetBuffering stdout NoBuffering
06:03:43 <Igloo> or hFlush stdout
06:03:48 <smg> ah okay
06:03:51 <smg> not stdin ?
06:04:00 <smg> ah okay stdout :]
06:04:06 <smg> i need import IO?
06:04:27 <Igloo> Yup, or better, System.IO
06:20:56 <bringert> Igloo: is thre Trac for code.haskell.org projects yet? there seems to be a host name for it: http://trac.haskell.org/
06:20:57 <lambdabot> Title: Haskell Community Server
06:22:31 <Igloo> bringert: No, sorry. If you want it then e-mail support@community to show there is demand, though
06:22:46 <smg>  Couldn't match expected type `[]' against inferred type `IO'
06:22:49 <smg> what does this mean?
06:23:01 <smg> http://rafb.net/p/koafCe31.html
06:23:02 <lambdabot> Title: Nopaste - stdin
06:23:04 <smg> here is the paste
06:23:14 <quicksilver> well, as for what it *means*
06:23:20 <quicksilver> it means, you're writing an IO action
06:23:24 <quicksilver> so it's expecting something IO
06:23:30 <quicksilver> and you gave it something which wasn't IO.
06:23:50 <quicksilver> as for how to fix it: you probably want "return ([number] ++ play)"
06:24:20 <bringert> Igloo: ok, thanks. I don't want to cause any extra work, for now the SourceForge bug tracker is enough I think.
06:24:39 <quicksilver> step 1. Rewrite a trac-a-like in haskell.
06:24:45 <quicksilver> no NIH please! ;)
06:25:53 <smg> quicksilver: still it complains
06:26:09 <quicksilver> well for the same reason you will need return []
06:26:14 <quicksilver> I thought you could have worked that out ;)
06:26:30 <smg> no it won't work with that :P
06:27:06 <quicksilver> "won't work" is the most irritating phrase in the galaxy
06:27:13 <quicksilver> I can't help you unless you tell me what happens.
06:29:14 <smg>    Couldn't match expected type `[]' against inferred type `IO'
06:30:55 <quicksilver> in which line?
06:31:03 <smg> same as before
06:31:08 <quicksilver> repaste the code
06:31:09 <smg> it's number 11
06:31:18 <quicksilver> oh, sorry
06:31:22 <quicksilver> I wasn't concentrating
06:31:29 <quicksilver> didn't notice the recursive call to play
06:31:42 <quicksilver> play is an IO actiona, you can't concatenate that with a list.
06:31:51 <quicksilver> instead of [number] ++ play, you need something like:
06:31:54 <smg> http://rafb.net/p/i8cEG958.html
06:31:55 <lambdabot> Title: Nopaste - stdin
06:32:12 <quicksilver> do { more <- play; return ([number] ++ more) }
06:35:37 <smg> quicksilver: ah this works
06:36:09 <smg> quicksilver: okay now  this works, and it will return a list
06:36:11 <quicksilver> smg: haskell goes to great lenghts to distinguish between "a value of type String" and an IO action which can be called to calculate a String"
06:36:22 <smg> so i need now the list which play returns
06:36:26 <smg> how can i accomplish this?
06:37:04 <quicksilver> inputlist <- play
06:37:14 <quicksilver> you must always use <- with actions to 'execute them'
06:37:22 <quicksilver> let ... = is for actual values
06:37:40 <smg> ooh
06:37:42 <smg> thank yo
06:38:37 <quicksilver> e.g.: let myinput = getLine says "pt the action getLine into myinput; this makes myinput an action, just a synonym for getLine"
06:38:55 <quicksilver> whereas "input <- getLine" means "execute the action getLine and put the *result* into myinput"
06:39:04 <quicksilver> (you already had this correct in your program)
06:39:07 <quicksilver> but it was a good example.
06:39:19 <quicksilver> for the same reason, you want inputlist <- play instead of let...
06:39:42 <pitecus> how do i convert from lazy to strict bytestring?
06:40:03 <quicksilver> @hoogle fromChunks
06:40:04 <lambdabot> Data.ByteString.Lazy.fromChunks :: [ByteString] -> ByteString
06:40:04 <lambdabot> Data.ByteString.Lazy.Char8.fromChunks :: [ByteString] -> ByteString
06:40:13 <quicksilver> hmm, not that.
06:40:58 <doserj> pack.unpack ?
06:41:00 <pitecus> S.pack . L.unpack?
06:41:26 <quicksilver> I thought there was a function for that, but obviously not.
06:45:16 <smg> quicksilver: now it works :) http://rafb.net/p/63OJ3w79.html
06:45:17 <lambdabot> Title: Nopaste - stdin
06:45:43 <dolio> @hoogle toChunks
06:45:43 <lambdabot> Data.ByteString.Lazy.toChunks :: ByteString -> [ByteString]
06:45:43 <lambdabot> Data.ByteString.Lazy.Char8.toChunks :: ByteString -> [ByteString]
06:46:25 <dolio> concat . toChunks probably works, too.
06:47:06 <pjd> @. pl undo do { more <- play; return ([number] ++ more) }
06:47:06 <lambdabot> (number :) `fmap` play
06:47:16 <pjd> smg: -^
06:47:58 <quicksilver> dolio: don't think so.
06:48:09 <quicksilver> dolio: it will be the wrong kind of ByteString, won't it?
06:48:25 <dolio> Well, S.concat . L.toChunks
06:48:37 <vininim> mm... I wonder if it's worth downgrading ghc to us pugs.
06:49:15 <dolio> toChunks turns a lazy byte string into a list of strict byte strings.
06:51:39 <hpaste>  JRX pasted "important question" at http://hpaste.org/5814
06:51:51 <jrx> hi
06:52:02 <jrx> i've been lerning haskell for some time
06:52:19 <jrx> and after writing few programs in it
06:52:32 <Jaak> excellent
06:52:37 <jrx> important question in my mind has emerged
06:53:05 <jrx> I have written 2 examples in:
06:53:10 <jrx> http://hpaste.org/5814
06:53:45 <pjd> jrx: i think you just discovered http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types :)
06:53:47 <lambdabot> Title: Haskell/Existentially quantified types - Wikibooks, collection of open-content t ..., http://tinyurl.com/f9umb
06:53:48 <jrx> which show two different approaches to polymorphism -> objects with different data that show similar behaviour
06:54:41 <hpaste>  dolio annotated "important question" with "existential types" at http://hpaste.org/5814#a1
06:54:52 <jrx> I'm just curious which one is better
06:55:07 <jrx> I now that the first one cannot be extended in future
06:55:41 <jrx> whilst types from the secon, cannot be stored in one list, or other data structure, what is quite painful
06:56:06 <jrx> how it can be overcome, to have both these qualities in my code?
06:56:19 <pjd> jrx: look at that link i gave
06:56:27 <skorpan> hey
06:56:38 <skorpan> is there any standard function to check for uniquity of elements in a list?
06:57:04 <pjd> the way you store the second approach in a list is with an existentially qualified type
06:57:29 <dolio> > let unique l = nub l == l in (unique [1,1,2,3,5], unique [1,2,4,8])
06:57:29 <skorpan> was that an answer to my question or someone else's?
06:57:32 <pjd> jrx: they have an example there using a list of Show instances
06:57:33 <lambdabot>  (False,True)
06:57:42 <dolio> skorpan: I think that's the best you'll do.
06:57:47 <pjd> skorpan: jrx's question, sorry
06:57:51 <skorpan> dolio: okay, thanks, i'll check it out
06:58:24 <dolio> skorpan: nub is O(n^2) though, if that matters.
06:58:40 <skorpan> dolio: doesn't matter, thanks
06:58:46 <dolio> Heh, okay. :)
06:58:48 <jrx> pjd: ok, I read that now
06:59:00 <quicksilver> actuall O(nm) where n = number of elts and m = number of distinct elts
06:59:02 <pjd> > let unique = (==) =<< nub in unique <$> [[1,1,2,3,5], [1,2,4,8]]
06:59:02 <quicksilver> IIRC>
06:59:05 <lambdabot>  [False,True]
06:59:13 <smg> the do-notation rocks
06:59:19 <dolio> quicksilver: Yeah, that sounds right.
07:00:09 <dolio> quicksilver: That's only going to save you time if your list is mostly duplicates though.
07:00:17 <gnuvince> :t nub
07:00:17 <lambdabot> forall a. (Eq a) => [a] -> [a]
07:01:08 <dolio> Good news for boolean lists, I suppose. :)
07:01:20 <quicksilver> ;)
07:02:43 <skorpan> i just realised i really needed to ask another question...
07:02:57 <skorpan> i want to know the first element in the list which has a duplicate :|
07:03:05 <smg> btw is there obfuscated haskell contest?
07:03:33 <skorpan> a single forward search would probably do it, right?
07:03:44 <ricky_clarkson> smg: lambdabot would win.
07:04:07 <doserj> http://www.haskell.org/haskellwiki/Obfuscation
07:04:08 <lambdabot> Title: Obfuscation - HaskellWiki
07:04:12 <smg> haha nice
07:04:20 <smg> i think haskell can get more obfuscated than perl :)
07:04:51 <ricky_clarkson> @pl \x y z -> x*x+y*y+z*z
07:04:51 <lambdabot> flip flip (join (*)) . (((.) . (+)) .) . (. join (*)) . (+) . join (*)
07:05:01 <smg> lol!
07:05:09 <shepheb> flip flip!
07:05:09 <Yoric[DT]> hi
07:06:01 <ricky_clarkson> :t flip flip
07:06:01 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
07:06:03 <Yoric[DT]> I'm looking for some help with existential types.
07:06:25 <Yoric[DT]> (please excuse my syntax, I'm mostly an OCaml guy)
07:06:52 <Yoric[DT]> But essentially, I wish to make a data structure with an existential type and a way to get back at the underlying concrete type.
07:06:57 <Yoric[DT]> Is that even possible ?
07:07:29 <EvilRanter> @where syb
07:07:29 <lambdabot> http://www.cs.vu.nl/boilerplate
07:07:35 <EvilRanter> may be of some assistance
07:07:47 <dolio> Yeah. Data.Dynamic is probably what you're looking for.
07:07:57 <Yoric[DT]> Mmhhh....
07:08:04 <Yoric[DT]> I was hoping for something purely static.
07:08:15 <Yoric[DT]> Such as passing the existential type and a projection function.
07:08:34 <dolio> Well, Dynamic is an existential type combined with a type representation, more or less.
07:09:06 <EvilRanter> thing is, either the type's visible, in which case it's not existential... or it isn't, and you can't get at it statically
07:09:25 <dolio> And operations for using the bundled type representation for casting back to a normal value.
07:09:37 <Yoric[DT]> dolio: I can see how to use that.
07:09:48 <Yoric[DT]> But I'd prefer another approach if I can find it.
07:10:38 <Yoric[DT]> EvilRanter: truth is the type is hidden by an existential inside the data structure... but is also known from a different path thanks to a phantom type.
07:10:40 <Yoric[DT]> mmhhh....
07:10:48 <EvilRanter> you can have a constructor that's Foo :: forall a. a -> (a -> SomeKnownType) -> Foo
07:10:52 <Yoric[DT]> Come to think about it, I could put the projection function inside the phantom type.
07:11:02 <ivan_> how do i make an Show instance of a type T r = ([r],[r]) i want this type to bee shown as show([r]++[r])
07:11:09 <Yoric[DT]> ...
07:11:12 <Yoric[DT]> Erf, except I can't.
07:11:13 <EvilRanter> and then let Foo x f = someFoo in f x :: SomeKnownType
07:11:21 <Yoric[DT]> Yeah, that's with a known type.
07:11:35 <Yoric[DT]> Unfortunately, I need something more generic than a known type.
07:11:43 <EvilRanter> i think you may be asking for something the haskell type system can't do
07:11:46 <EvilRanter> ask Oleg :P
07:11:49 <Yoric[DT]> :)
07:11:57 <EvilRanter> @where oleg
07:11:58 <lambdabot> http://okmij.org/ftp/
07:12:06 <Yoric[DT]> Yeah, I know where to find Oleg :)
07:12:10 <Yoric[DT]> Thanks.
07:12:54 <hpaste>  pjd annotated "important question" with "with instance" at http://hpaste.org/5814#a2
07:14:42 <mrchebas> anyone who knows what are the ghc 6.8 incantations to allow "deriving Show" on "data GRose ff a = GRose a (ff (GRose ff a))"?
07:15:23 <mrchebas> ghc 6.6 was happy with "-fallow-undecidable-instances -fglasgow-exts"
07:15:27 <quicksilver> that should be allowed.
07:15:38 <mrchebas> ghc 6.8 complains
07:15:45 <EvilRanter> what error do you get?
07:15:47 <quicksilver> and it shouldn't recquire any flags.
07:15:55 <mrchebas> 6.8.1 rather
07:15:57 <bringert> Igloo: You've got project request!
07:15:57 <mrchebas> it says:
07:16:23 <mrchebas>     No instance for (Show (ff (GRose ff a)))
07:16:23 <mrchebas>       arising from the 'deriving' clause of a data type declaration
07:16:23 <mrchebas>                    at domotest.hs:2:0-56
07:16:42 <quicksilver> it will require Show instances for ff and a, of course.
07:17:02 <mrchebas> er... i am using "deriving"
07:17:05 <EvilRanter> but that should manifest as constraints on the instance, not cause an error
07:17:25 <mrchebas> yes, note that this used to work under ghc 6.6
07:17:39 <mrchebas> i suppose that i need different flags now
07:17:49 <dolio> I seem to remember seeing that come up before.
07:17:56 <dolio> Perhaps to myself, even.
07:18:06 <quicksilver> yes, it rings a bell.
07:18:17 <quicksilver> I don't think it's a question of flags, I think it's simply a bug.
07:19:07 <EvilRanter> try 6.8.2?
07:20:35 <dolio> http://www.mail-archive.com/glasgow-haskell-users%40haskell.org/msg11189.html
07:20:36 <lambdabot> Title: newtype deriving clause ceases to work in HEAD, http://tinyurl.com/28l2hl
07:21:03 <mrchebas> quicksilver: I understand the flag is necessary: GRose ff a occurs again in the context
07:21:07 <dolio> Oh, perhaps not.
07:21:14 <quicksilver> dolio: don't think that's necessary.
07:21:40 <quicksilver> mrchebas: don't really follow. That's true of all recursive types.
07:22:15 <quicksilver> data List a = Nil | Cons a (List a) deriving Show
07:22:34 <quicksilver> ^^ this "requires" Show (List a) to prove Show (List a)
07:22:39 <mrchebas> no, the look at the show instance for lists: instance Show a => Show [a] ...
07:22:44 <quicksilver> but that's standard with anything recursive.
07:22:55 <mrchebas> it needs a show for a's, not a show for lists of a's
07:23:15 <quicksilver> well it "needs" a show for List as
07:23:25 <quicksilver> to make a meaningful clause for Cons
07:23:34 <quicksilver> it's just that constraint isn't displayed because it's daft.
07:23:35 <mrchebas> EvilRanter: 6.8.2 complains too, we tried -fglasgow-exts -XUndecidableInstances
07:23:40 <quicksilver> that's just how recursion works.
07:23:47 <EvilRanter> oh well =/
07:23:51 <dolio> Oh, I think I found the relevant one.
07:23:59 <quicksilver> The only difference with your version is you are going via a (* -> *) kinded type var 'ff'
07:24:11 <quicksilver> and it's failing to resolve the indirect recursion, presumably.
07:24:26 <dolio> By conal. 'newtype Pair1 f g a = Pair1 {unPair1 :: (f a, g a)} deriving (Eq, Ord, Show)' fails.
07:24:30 <dolio> And he never got a response.
07:24:41 <quicksilver> ah yes, that sounds familiar.
07:26:14 <mrchebas> quicksilver: the constraint "Show [a]" is not shown because it can be built "Show a". But you cannot do the same for GRose because of the f.
07:26:39 <roconnor> dolio: what are you doing?
07:26:47 <mrchebas> i guess i'll ask on haskell-cafe
07:27:10 <quicksilver> mrchebas: JaffaCake says it sounds like a bug could you report.
07:28:04 <mrchebas> i see
07:28:18 <mrchebas> what is the test in the regression?
07:29:41 <ivan_> how do i make an Show instance of a type T r = ([r],[r]) i want this type to bee shown as show([r]++[r])
07:29:55 <quicksilver> mrchebas: your GRose type is fine.
07:30:01 <roconnor> ivan_: typically you have to use newtype.
07:30:07 <quicksilver> mrchebas: just copy-paste the definition and explain it works in 6.6. and not 6.8
07:30:30 <mrchebas> under 6.6 it does not work if you don't supply -fglasgow-exts and -fallow-undecidable-instances
07:31:02 <jrx> @src mapM_
07:31:03 <lambdabot> mapM_ f as = sequence_ (map f as)
07:31:48 <ivan_> okay like this newtype T r = T [r] [r]
07:32:07 <ivan_> but how do i make and instance of Show, i can't pattermach?
07:32:18 <jrx> @src sequence_
07:32:18 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:32:26 <jrx> @src sequence
07:32:26 <lambdabot> sequence ms = foldr k (return []) ms
07:32:26 <lambdabot>     where
07:32:26 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
07:32:28 <roconnor> ivan_: You can pattern match on T.
07:32:33 <mrchebas> quicksilver: so GRose needed flags in 6.6, is it supposed to work without flags under 6.8?
07:32:46 <roconnor> ivan_: almost the same as data types.
07:32:54 <quicksilver> mrchebas: I'm not sure, I must admit. Just mention in the report what flags it needed.
07:32:59 <ivan_> roconnor: instance Show T r where T x y = show(x++y) ????
07:33:01 <quicksilver> mrchebas: and let the GHC gurus figure out the right asnwer :)
07:33:17 <quicksilver> where show (T x y) = show (x ++ y)
07:33:30 <mrchebas> quicksilver: i'll report it, thanks
07:34:05 <roconnor> ivan_: what quicksilver said
07:34:22 <quicksilver> I would note in passing that that is an evil Show instance.
07:34:33 <roconnor> ivan_: when you declare the Show instance you have to define the show function.
07:35:36 <roconnor> quicksilver: it is only a little evil.
07:36:49 <quicksilver> roconnor: it fails two out of two of my show criteria.
07:36:55 <ivan_> i get an error the constructior of newtype must have onefiedl but i have too?
07:37:14 <roconnor> ivan_: I was sort of afraid of that
07:37:29 <quicksilver> roconnor: it can't possibly be compatible with a Read instance, and it fails 'copy-paste'
07:37:36 <u_quark> is there any way to compile cyclical dependent modules in ghc ?
07:37:39 <roconnor> ivan_: you will either have to use ([r],[r])
07:37:50 <quicksilver> eiether newtype T r = T ([r],[r]) or data T r = T [r] [r]
07:37:52 <roconnor> ivan_: or make an data type.
07:38:03 <ivan_> ill try
07:38:13 <roconnor> ivan_: I recommend making a data type.
07:38:19 <ToRA> u_quark, you have to make .hs-boot files
07:38:53 <roconnor> quicksilver: well, there is a reason that Text was split into Show and Read I guess.
07:39:01 <ToRA> u_quark: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
07:39:02 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
07:39:07 <u_quark> will look into it ToRA tnx
07:39:16 <shapr> gwern: Nah, dark got distracted.
07:39:23 <quicksilver> recursive module dependencies may be a sign of bad style
07:39:27 <quicksilver> not always, admittedly
07:39:32 <quicksilver> but it's often better to avoid them
07:39:55 * roconnor embraces recursive module dependencies
07:40:40 <u_quark> quicksilver: i will consider that ;P
07:41:01 <ivan_> roconnor: i now get could not deduce Show r from context Show(T r)....
07:41:10 <quicksilver> yes
07:41:20 <quicksilver> you need instance (Show r) => Show T r where ...
07:41:49 <ivan_> =) thx now it works
07:42:13 <roconnor> ivan_: it is important to note that T r is showable only when r is.
07:47:20 <ivan_> roconnor: yes i know =)
08:05:46 <smg> > mapM_ (\x -> putStrLn $ show $ x^2) [1..10]
08:06:01 <lambdabot>  thread killed
08:06:18 <smg> > map (\x -> x^2) [1..10]
08:06:19 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
08:07:09 <Cale> Interesting that got a thread killed...
08:07:11 <Cale> > mapM_ (\x -> putStrLn $ show $ x^2) [1..10]
08:07:12 <lambdabot>  <IO ()>
08:07:19 <Cale> It doesn't do anything :)
08:07:56 <doserj> lambdabot lately has performace issues
08:07:59 <Cale> yeah
08:08:14 <Cale> It's code.haskell.org's fault. I don't know what it is that machine is doing.
08:09:07 <dolio> code.haskell.org has never been particularly quick in my experience.
08:09:32 <smg> hehe
08:09:44 <Cale> Well, it's a dual Xeon.
08:09:53 <smg> should be enough imho
08:11:50 <dolio> Maybe I'm just not used to remote sessions, then.
08:11:52 <ivan_> is there any error exit command in haskell that stops the program en returns some string to terminal ?
08:12:13 <Cale> error "string"
08:12:20 <ivan_> :) thx
08:12:30 <dolio> Wow, lambdabot's using 33% memory. :)
08:13:00 <Hamtaro> Is there an IDE for Haskell ?
08:13:08 <profmakx> where leksah
08:13:09 <profmakx> arx
08:13:12 <profmakx> @where leksah
08:13:12 <lambdabot> I know nothing about leksah.
08:13:15 <profmakx> hmmm
08:13:16 <Cale> Hamtaro: People are working on one called leksah, yeah.
08:13:41 <Cale> Hamtaro: I'm not sure if it's usable yet. I mostly just use vim and/or emacs.
08:14:08 <Cale> 23872 cgibbard  15   0  211m 169m 4604 S    0 33.1   1:24.03 lambdabot -- ahaha
08:14:13 <profmakx> Cale, i was positively surprised how stable leksah works ;)
08:14:18 <Cale> yes, it is using 33% memory :)
08:14:21 <profmakx> but yeah it is very early alpha
08:14:53 <byorgey> @where+ leksah http://code.haskell.org/leksah
08:14:53 <lambdabot> It is stored.
08:14:57 <byorgey> @where leksah
08:14:57 <lambdabot> http://code.haskell.org/leksah
08:16:05 <Cale> What's the story behind its name?
08:16:16 <byorgey> > nub . reverse $ "haskell"
08:16:17 <lambdabot>  "leksah"
08:16:29 <Cale> Ah, that would make sense :)
08:16:32 <quicksilver> I think emacs is a haskell IDE, for a suitable definition of 'IDE'
08:16:41 <gbacon> clever
08:16:42 <shapr> me too!
08:16:42 <quicksilver> it's all a question of what you want out of a code-writing environment.
08:16:49 <Cale> It would make even more sense if it happens to include a Haskell lexer.
08:16:56 <benny99> > nub . reverse $ "Haskell IDE"
08:16:57 <lambdabot>  "EDI leksaH"
08:16:57 <quicksilver> There is certainly some more things I'd like but don't have
08:17:11 <shapr> Oh, good name.
08:17:21 <quicksilver> like on-the-fly type inference and so on
08:17:23 <benny99> I worked long hours on that name :]
08:17:35 * shapr applies type inference to a nearby insect.
08:17:55 <Cale> What I really want is an editor which understands the offside rule.
08:17:55 <smg> canhttp://rafb.net/p/Pm73bo20.htm <-- is this "haskell-style"?
08:17:56 <quicksilver> ;)
08:18:00 <quicksilver> shapr: what type was it?
08:18:06 <shapr> insect :: Fly
08:18:06 <smg> or do i still think too imperative?
08:18:15 <nominolo> lhs2tex is fucking with me ...
08:18:20 <Cale> smg: something is wrong with that link
08:18:24 <shapr> quicksilver: It was on the Fly type inferencing.
08:18:28 * mrd hacked up some elisp to query ghc for types of bound variables and such, but it's so ugly that he is afraid to release it
08:18:30 <byorgey> smg: 404 not found
08:18:34 <smg> ah sorry
08:18:35 <Cale> smg: (even after making the obvious correction)
08:18:35 <doserj> .html
08:18:35 <quicksilver> shapr: yes, I gathered that ;)
08:18:35 <cjb> Cale: When you're asking more from your editor than from your partner, you know you're not likely to get your way ;-)
08:18:38 * shapr grins
08:18:44 <byorgey> ah, adding an 'l' to the .htm works =)
08:18:57 <smg> http://rafb.net/p/Pm73bo20.html <-- this :]
08:18:57 <lambdabot> Title: Nopaste - stdin
08:18:59 <shapr> mrd: Well, if you don't release it, no one else can improve it!
08:19:01 <smg> is that okay?
08:19:17 <quicksilver> smg: I would leave out myinput
08:19:19 <quicksilver> and just write
08:19:23 <quicksilver> myamount <- readLn
08:19:25 <smg> ah okay
08:19:27 <quicksilver> otherwise, yes.
08:19:37 <Cale> smg: It looks okay to me. I usually put the do on the next line, before the first line of code, but that's just a personal preference thing.
08:19:46 <smg> ok
08:19:49 <quicksilver> smg: you don't need () in "show(x)"
08:19:50 <Cale> (and might be strange of me)
08:19:53 <quicksilver> "show x" is fine.
08:20:04 * byorgey usually puts the do on the same line as main =
08:20:07 <quicksilver> you do need them in show (x*x) though.
08:20:11 <smg> hehe ok
08:20:13 <Cale> x*x can also be written x^2
08:20:25 <smg> ah function call is more tightly than "," ?
08:20:29 <Cale> yeah
08:20:41 <byorgey> smg: function application binds more tightly than anything else.
08:20:45 <smg> ah okay
08:20:47 <doserj> I would seperate the creation of the string from the printing
08:20:51 <hpaste>  nominolo pasted "stupid lhs2tex" at http://hpaste.org/5815
08:20:52 <smg> i will search a table for that operator thingy
08:21:17 <shapr> @users
08:21:17 <lambdabot> Maximum users seen in #haskell: 471, currently: 445 (94.5%), active: 17 (3.8%)
08:21:20 <byorgey> smg: and in haskell, function application is just written  f x, not f(x) -- I don't know whether you are confused about that
08:21:24 <shapr> This place is getting busier!
08:21:25 <Cale> smg: , binds less tightly than anything expressions have to offer
08:21:30 <smg> byorgey: no i am not
08:21:39 <byorgey> smg: ok, just checking =)
08:21:42 <nominolo> does anyone have an idea re my lhs2tex problem?
08:21:44 <smg> doserj: you mean mapM_ . map ?
08:21:50 <Cale> (since it's part of the surrounding syntax)
08:21:59 <Cale> You could also use forM_ here
08:22:07 <byorgey> smg: the problem of course, is that someone confused about that might try writing f(x,y) to pass multiple parameters, which is not the same as f x y  =)
08:22:20 <byorgey> nominolo: I'm looking at it
08:23:34 <smg> mapM_ (putStrLn) (map (\x -> concat ["#", show x, " => ", show(x*x)]) [1..myamount]) <--
08:23:34 <hpaste>  Cale pasted "minor tweaks" at http://hpaste.org/5816
08:23:59 <Cale> or that, yeah
08:24:13 <doserj> let outputs = map (\x -> ...) [1..myamount] ; mapM_ putStrLn outputs
08:24:19 <Cale> Or even use unlines
08:24:35 <smg> ah okay
08:24:49 <nominolo> byorgey: i thought it might be line ending encoding, but then why doesn't it complain earlier?
08:25:05 <Cale> But these are just options to be aware of :)
08:25:09 <byorgey> nominolo: yeah, it's weird
08:25:21 <smg> hehe
08:26:02 <nominolo> gah, i'd really like to kick something, right now
08:26:13 <Cale> The Cheat!
08:26:39 * mrd will check out leksah when he gets home
08:26:45 <smg> lambdabot is cool
08:27:09 <byorgey> nominolo: it seems to be choking on the line containing  , "\\end{code}"
08:27:20 <byorgey> nominolo: at least, when I change that line, it changes the error message
08:27:48 <quicksilver> I suspect it can't cope with \end{code} occurring in embedding strings
08:28:00 <quicksilver> you might have to trick it with "\"++"end{code}"
08:28:01 <quicksilver> or similar
08:28:40 <Baughn> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs :: [Expr]
08:28:43 <lambdabot>  [1,1,1 + 1,1 + (1 + 1),1 + 1 + (1 + (1 + 1)),1 + (1 + 1) + (1 + 1 + (1 + (1 ...
08:29:18 <byorgey> nominolo: aha! quicksilver has it, I think
08:29:37 <quicksilver> I was confused by the 'line 5'
08:29:40 <quicksilver> but maybe that explains it
08:29:47 <quicksilver> it's counting from the inner begin{code}
08:30:05 <byorgey> ah, yup
08:30:14 <byorgey> the dangers of writing lhs2tex quines ;)
08:30:32 <nominolo> quicksilver: indeed!
08:31:00 <nominolo> maybe i should have used a different test file ;)
08:31:16 <nominolo> byorgey, quicksilver: thanks!
08:31:22 <smg> Baughn: awesome
08:32:28 <Deewiant> > let fibs = 0 : scanl (+) 1 fibs in fibs :: [Expr]
08:32:29 <lambdabot>  [0,1,1 + 0,1 + 0 + 1,1 + 0 + 1 + (1 + 0),1 + 0 + 1 + (1 + 0) + (1 + 0 + 1),1...
08:32:35 <byorgey> oh, I guess it is not really a quine, is it?
08:33:24 <Jaak> > fix ((1:).scanl(+)1) :: [Expr]
08:33:24 <lambdabot>  [1,1,1 + 1,1 + 1 + 1,1 + 1 + 1 + (1 + 1),1 + 1 + 1 + (1 + 1) + (1 + 1 + 1),1...
08:33:35 <Jaak> neato
08:34:10 <nominolo> byorgey: no it's a hs2lhs utility
08:34:19 <Baughn> > (do l <- liftM lines getContents; return l !! 2) :: Expr
08:34:19 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a b'
08:34:19 <nominolo> er
08:34:22 <nominolo> hs2tex
08:34:25 <byorgey> nominolo: right, cool
08:34:31 <nominolo> since lhs2tex only understands lhs
08:34:51 <nominolo> too bad it also chokes on "|" in haddock comments
08:34:59 <nominolo> guess i have to try harder
08:35:13 <Hamtaro> Why have I the error " 'Executable' stanza starting with field 'flag splitbase description'" on wxHaskell install and how to make it works ?
08:35:17 <Cale> Man, people really liked my short tutorial for Alan :)
08:35:35 <nominolo> Hamtaro: you need a newer Cabal
08:35:36 <Cale> Everyone's urging me to clean it up and put it on the wiki now :)
08:35:44 <quicksilver> Cale: clean it up and put it on the wiki!
08:35:48 <Hamtaro> And how to have it ? =/
08:35:52 <nominolo> @where cabal
08:35:53 <lambdabot> http://www.haskell.org/cabal
08:35:53 <quicksilver> Cale: (I don't know what you're talking about, but that sounds good to me!)
08:36:01 <Hamtaro> Ok thx :)
08:36:30 <Cale> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/36822
08:36:33 <lambdabot> Title: gmane.comp.lang.haskell.cafe
08:37:29 <Baughn> @src IO mplus
08:37:29 <lambdabot> m `mplus` n = m `catch` \_ -> n
08:37:37 <Baughn> @src Maybe mplus
08:37:37 <lambdabot> Nothing `mplus` ys  = ys
08:37:37 <lambdabot> xs      `mplus` _ys = xs
08:38:00 <Baughn> ..I give. What do those two have in common?
08:38:45 <quicksilver> Baughn: the fact that if the left hand choice "goes wrong"
08:38:57 <Toxaris> Baughn: return x `mplus` _ = return x   and  fail _ `mplus` x = x
08:39:02 <quicksilver> Baughn: either by throwing an exception, or by giving Nothing
08:39:07 <quicksilver> Baughn: then the right hand choice is run
08:39:16 <quicksilver> (if the left hand choice doesn't go wrong, the right hand choice is never run)
08:39:26 <Baughn> ..ah.
08:40:18 <Baughn> That's the sort of thing that should probbaly be in the documentation. It's really a pity it doesn't allow comments.
08:41:10 <Cale> Yeah, these are both instances of something which should probably be called MonadOr or something similar, to separate it from the behaviour of other MonadPlus instances
08:41:34 <quicksilver> Baughn: if you're interested, you should read http://www.haskell.org/haskellwiki/MonadPlus
08:41:35 <lambdabot> Title: MonadPlus - HaskellWiki
08:41:44 <quicksilver> Baughn: which explains about the "two kinds" of monad plus
08:42:13 <quicksilver> Cale: are you aware of anything apart from [] which behaves like [] ?
08:42:14 <Baughn> Will do.
08:42:28 <Cale> Yes, other nondeterminism monads, mostly.
08:42:40 <ivan_> how do i make a String to a specific a
08:42:41 <Cale> Like the Logic monad.
08:42:51 <Baughn> What software does the online ghc documentation run? Is it just a static website?
08:43:01 <dobblego> I know people say [] is like data List a = Nil | Cons a (List a) but isn't [] spine-strict, therefore, data List' a = Nil | Cons !a (List' a) ?
08:43:14 <Cale> Baughn: It's generated by Haddock, if you're referring to the libraries documentation.
08:43:39 <quicksilver> Baughn: once generated, it's static, though.
08:43:49 <quicksilver> dobblego: no.
08:44:06 <quicksilver> dobblego: (what you have just described is 'head-value-strict' not 'spine-strict')
08:44:11 <quicksilver> (but [] is neither)
08:44:20 <Toxaris> dobblego: no, it's not, and that is a Good Thing
08:44:28 <Hamtaro> Can I upgrade GHC from 6.6 to 6.8 with Synaptic ?
08:44:38 <quicksilver> if [] was spine strict infinite lists wouldn't work.
08:44:50 <quicksilver> and lots of constant space algorithms wouldn't be constant space.
08:45:03 <quicksilver> for comparison, Data.Set and Data.Map are spine-strict.
08:45:07 <ivan_> how can i make a String to a specific type like "123231" -> Int
08:45:09 <Baughn> quicksilver: Do you think it would be a good idea to allow comments like the practical haskell book site?
08:45:12 <dobblego> quicksilver, that was my understanding as well, but I have been told [] is spine-strict
08:45:22 <quicksilver> dobblego: you were told incorrectly.
08:45:29 <quicksilver> dobblego: [] is fully non-strict.
08:45:37 <dobblego> quicksilver, ok thanks
08:45:43 <Baughn> Hamtaro: Nothing about haskell is stopping that. Sure, if it's in the repository.
08:45:54 <doserj> > read "123231" :: Int
08:45:58 <lambdabot>  123231
08:46:02 <quicksilver> Baughn: In principle I do, but people would have to be in charge of looking after comments and trying to get them incorporated.
08:46:32 <quicksilver> Baughn: I believe that the haskell.org powers that be feel the wiki and the mailing lists are good avenues for such things as it is.
08:46:49 <quicksilver> positive documentation changes are uncontroversial and if you submit them appropriately they normally get applied.
08:47:09 <Hamtaro> Baughn : But there is only old versions in Synaptic =/
08:47:24 <Baughn> Hamtaro: Then not. Ubuntu, right?
08:47:32 <Cin> how does one get milliseconds or less, i want to time the evaluation time of an action that i know will be evaluated
08:47:34 <gwern> what's the name for Hugs in tested-with: cabal fields? ie, ghc is 'GHC==' but what's hugs?
08:47:39 <quicksilver> I believe there is a 6.8 in the appropriate 'unstable' ubuntu repo
08:47:42 <quicksilver> whatever they call it.
08:47:54 <Baughn> Hamtaro: Personally I prefer to avoid the distro's haskell packages and install my own, but that does take more work
08:48:11 <xif> my brain just overheated :-/
08:48:46 <ivan_> if i have a type of IO a as input and i want to convert a string to type a how do i make that happen?
08:48:47 <quicksilver> xif: haskell has that effect.
08:48:48 <Hamtaro> I am a newbie and I am confused (and french too >_<)
08:48:54 <Baughn> quicksilver: I see the reference documentation as being a sort of dictionary, with expanded information often being available on the wiki - if you know where to look. Probably, just having a few extra links in the right places would be sufficient.
08:49:12 <quicksilver> Baughn: yes. You could start a thread about this on -cafe if you have a suggestion.
08:49:34 <quicksilver> Baughn: although the answer might be "who volunteers to put the software together?" :)
08:49:45 <Baughn> quicksilver: That's the problem. :P
08:49:49 <quicksilver> ivan_: how do ou expect to convert a String to type a?
08:50:04 <quicksilver> ivan_: you don't know what 'a' is, I presume...
08:50:14 <quicksilver> ivan_: coudl be hard! although "read" is one possibility.
08:50:17 <quicksilver> it depends what you mean.
08:50:27 <Baughn> quicksilver: I think I'd rather try to figure out a solution myself, then present a fait accompli prototype. Even if it doesn't get adopted, it'd be good exercise and probably provoke more sueful discussion.
08:51:01 <Cin> baughn: i'd never sue you!
08:51:15 <ivan_> i know because the program at that state saved the string there
08:51:21 <Baughn> Cin: Don't say that when I'm drinking tea! *ouch*
08:51:35 * Cin chortles
08:51:36 <quicksilver> ivan_: I think you need to show us a bit more of your program or explain some more details.
08:51:45 <quicksilver> ivan_: your question so far doesn't make a lot of sense, I'm afraid.
08:52:20 <gwern> 'allocUnboxed elems ∷ m (MUVec s a) = allocUnboxedBytes $ fromIntegral elems * sizeOfUnboxed (undefined∷a)' <-- are you allowed to have variable's type signatures in the arg list?
08:52:52 <Baughn> quicksilver: By the way, the wiki is broken. Searching for "irc" gives no results..
08:53:28 <doserj> only words with more than 3 letters are indexed...
08:53:39 <Cin> heh
08:54:32 <Baughn> ..how annoying. Add a google search?
08:55:18 <quicksilver> just use google.
08:55:21 <quicksilver> ;)
08:55:22 <Baughn> Though it's /still/ broken, in not giving a useful error
08:55:36 <quicksilver> there are only two types of search engines: google, and crap ones.
08:55:38 <quicksilver> I use google.
08:55:49 * Baughn pokes FAST
08:55:58 <doserj> it does say "unsuccessful searches are often caused by searching for common words like "have" and "from", which are not indexed,"
08:56:16 <Baughn> I didn't think "irc" was one of those. :'(
08:56:22 <doserj> heh :)
08:58:08 <doserj> you can try http://www.google.com/coop/cse?cx=015832023690232952875%3Acunmubfghzq
08:58:09 <lambdabot> Title: Haskell Search Engine, http://tinyurl.com/y5kvdq
08:58:21 <byorgey> by "common words", it really means "short".  Since all short words are common, of course... =P
08:59:37 <Baughn> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs :: Expr
08:59:40 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
09:00:25 * shepheb loves that function. efficient, beautiful.
09:00:37 <Baughn> ..wrong
09:00:53 <shepheb> ?
09:01:05 <doserj> it should start with 0 :)
09:01:25 <shepheb> no, with 1, 2!
09:01:30 <Baughn> 1:2, I say
09:01:47 <byorgey> er... 1,2 ?
09:01:48 <Baughn> It was originally about /rabbits/. Lone rabbits don't breed.
09:02:04 <Syzygy-> Wasn't it originally about rabbit pairs?
09:02:14 <Syzygy-> And counting descendants?
09:02:18 <shepheb> mathematical sequence, not haskell list
09:02:23 <Baughn> ..possibly
09:02:32 <Baughn> Well, it's either 0:1 or 1:2. Not 1:1.
09:02:48 <Syzygy-> Baughn: For fibonacci? 1:1 is quite alright to start with.
09:02:52 <byorgey> F_0 = 0, F_1 = 1, F_2 = 1.
09:02:52 <quicksilver> > fix((1:).(1:).ap(zipWith(+))tail) :: [Expr]
09:02:58 <Syzygy-> ESPECIALLY if you want to introduce the rabbit analogy.
09:03:01 <byorgey> depends if you want it zero-indexed or one-indexed.
09:03:05 <lambdabot>  [1,1,1 + 1,1 + (1 + 1),1 + 1 + (1 + (1 + 1)),1 + (1 + 1) + (1 + 1 + (1 + (1 ...
09:03:33 <doserj> @oeis fibonacci
09:03:34 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
09:03:34 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:04:07 <doserj> :P
09:04:26 <Baughn> @oeis [0,0,0,0,0]
09:04:26 <lambdabot> Sequence not found. And you call yourself a Rocket Scientist!
09:04:42 <Syzygy-> @oeis [0,1,1,2,3,5]
09:04:42 <lambdabot> Sequence not found. I've seen penguins that can type better than that.
09:04:52 * shepheb nearly dies choking after reading Mr_Awesome's exit message
09:04:57 <Baughn> @oeis 0 1 1 2 3 5
09:04:57 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
09:04:57 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:05:02 <Syzygy-> Ahhhh.
09:05:06 <Baughn> @oeis 0 0 0 0 0
09:05:06 <lambdabot> The characteristic function of 0: a(n) = 0^n.
09:05:06 <lambdabot> [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:05:09 <Cin> heh, i just used C-< on Firefox and looked confused
09:05:39 <ohub> @oeis 2 3 5 7 11
09:05:40 <lambdabot> The prime numbers.
09:05:40 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
09:05:41 <Baughn> Cin: What is it supposed to do?
09:05:50 <Baughn> @oeis 42
09:05:50 <lambdabot> Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called ...
09:05:50 <lambdabot> [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35...
09:05:52 <Cin> baughn: er, M-<
09:05:53 <desegnis> hmm, is there an agreement whether the Fibonacci numbers include 0?
09:06:02 <Cin> baughn: in emacs it goes to the start of a buffer
09:06:02 <wli> no
09:06:09 <dons> ?users
09:06:09 <lambdabot> Maximum users seen in #haskell: 471, currently: 442 (93.8%), active: 21 (4.8%)
09:06:12 <Baughn> desegnis: Argument from authority - it does.
09:06:32 <desegnis> I see :)
09:06:33 <Baughn> Cin: Mm, that's more reasonable. :P
09:06:40 <Baughn> Cin: Though I usually just use A-up
09:07:01 <gwern> @hoogle toCalendarTime
09:07:01 <lambdabot> System.Time.toCalendarTime :: ClockTime -> IO CalendarTime
09:07:02 <Cin> baughn: what's A?
09:07:15 <Baughn> Cin: Apple. What you'd call win.
09:07:23 <Cin> baughn: hehe
09:07:54 <gwern> @hoogle toIntegral
09:07:54 <lambdabot> No matches found
09:08:00 <gwern> @hoogle toInteg
09:08:00 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
09:08:46 <shepheb> wouldn't toInteger = fromIntegral?
09:09:31 <gwern> @hoogle EpochTime
09:09:31 <lambdabot> System.Posix.Types.EpochTime :: type EpochTime
09:09:34 <doserj> > let primes = extendSequence [2,3,5,7,11] in primes!!40 -- evil
09:09:37 <sebell> shepheb: If you specify :: Integer, yes.
09:09:42 <lambdabot>  179
09:10:11 <shepheb> sebell: fair enough
09:10:13 <ivan_> i have this monad StateT r (ErrorT a IO) q and i want to create fun :: IO a -> that monad, how do i exctract the a from IO and return it ?
09:10:30 <dons> truly lovely, http://research.swtch.com/2008/02/elegance-and-power.html
09:10:30 <quicksilver> ivan_: liftIO
09:10:31 <lambdabot> Title: research!rsc: Elegance and Power
09:10:50 <quicksilver> liftIO will take the type IO a -> ComplexTransformedMonad a
09:10:54 <ivan_> oh that easy =)
09:10:57 <Baughn> > let primes = extendSequence [2,3,5,7,11] in primes !! 424242
09:10:58 <lambdabot>  Exception: Prelude.(!!): index too large
09:11:01 <gwern> hm. EpochTime has no tointegral defined?
09:11:05 <quicksilver> as long as the ComplexTransformedMonad has IO at its centre.
09:11:09 <Baughn> > let primes = extendSequence [2,3,5,7,11] in length primes
09:11:10 <lambdabot>  58
09:12:03 <ivan_> quicksilver: it says couldn't match expected type q ?
09:12:46 <dolio> dons: Having fun in "why don't you use Haskell?"
09:12:54 <gwern> 'No instance for (Integral EpochTime): arising from a use of `toInteger' at Date.lhs:28:51-67' <-- argh
09:13:33 <dons> dolio: not really
09:13:54 <Cin> am i supposed to substract two calls to getCPUTime like actual time that increments, or does it mean "number of picoseconds the CPU used... some time around the call to getCPUTime"?
09:14:00 <quicksilver> ivan_: that means nothing. I need to see more code!
09:14:20 <quicksilver> Cin: subtract.
09:14:24 <gwern> an EpochTime is a synonmym for CTime,  abd CTime claims to implement Num, but then I get that error. oy!
09:15:13 <byorgey> doserj: what's evil about it?
09:15:15 <Cin> quicksilver: hm..
09:15:37 <doserj> byorgey: it is not referentially transparent
09:16:30 <byorgey> doserj: well, technically, you're right of course =)
09:16:54 <doserj> byorgey: the result can change, whenever someone submits a new sequence
09:16:59 <quicksilver> :t toInteger
09:17:00 <lambdabot> forall a. (Integral a) => a -> Integer
09:17:05 <ivan_> like i said i have this type StateT r (ErrorT a IO) q and i want to make the function IO a -> that monad<<< that exctracts the a and return the a, like if IO a is putStrLn "lol" i want to take the lol and return as a
09:17:12 <quicksilver> gwern: implements Num is not the same as implements Integral?
09:17:40 <byorgey> doserj: right.  I doubt it's ever a real problem in practice.
09:17:43 <quicksilver> ivan_: for the first half of your sentence, liftIO is the asnwer.
09:17:44 <gwern> it isn't?
09:17:50 <sebell> gwern: No sir!
09:17:55 <quicksilver> ivan_: the second half of your sentence makes no sense.
09:17:57 <bringert> gwern: no, they are different classes
09:17:57 <Cin> heh. getting the laziness right to time this properly is tricky
09:18:11 <sebell> gwern: CTime is also Rational, so you can choose how you want to obtain an integral value from that
09:18:11 <quicksilver> ivan_: putStrLn "lol" has type IO (), and there is no way of extracting the "lol" from it.
09:18:15 <Cin> :t seq
09:18:15 <lambdabot> forall a t. a -> t -> t
09:18:17 <bringert> gwern: not all numbers are Integral
09:18:38 <gwern> bringert: yeah, but I thought you could always downgrade a number into an integral
09:18:58 <gwern> hence the toInteger call, explicitly saying you don't mind throwing away the extra information
09:19:07 <mauke> :t toInteger
09:19:08 <lambdabot> forall a. (Integral a) => a -> Integer
09:19:21 <ivan_> how do i check a type of IO ?
09:19:24 <sclv_> :t round
09:19:25 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
09:20:01 <quicksilver> ivan_: you never need to check the type of anything.
09:20:07 <quicksilver> ivan_: the type is known by the compiler, statically.
09:20:07 <gwern> so.. I should toRational it, and then round down?
09:20:07 <Cale> "A power series is an infinite-degree polynomial." -- heh, that's kinda backwards :)
09:20:28 <bringert> gwern: the numeric classes are a bit of a maze
09:20:49 <quicksilver> ivan_: show me exactly how you are using liftIO. Preferably with some surrounding code.
09:21:16 <quicksilver> gwern: you can 'round' or 'floor' or 'ceiling'
09:21:24 <smg> Write a data type Quadrupel and the first two elements should have the same type and the last two elements also
09:21:24 <quicksilver> gwern: toInteger nevber throws away information
09:21:29 <ivan_> fun :: IO a -> the monad    fun x = liftIO x
09:21:37 <smg> data Quadruple a b c d = Quadruple a a c c <-- is this correct?
09:21:42 <quicksilver> :t liftIO
09:21:43 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
09:21:44 <mauke> ivan_: "the monad" is not valid code
09:21:50 <quicksilver> ivan_: yup. That's fine.
09:21:51 <mauke> smg: no
09:21:53 <byorgey> smg: you probably don't want the c and d.
09:22:02 <byorgey> I mean, the b and d
09:22:05 <ivan_> no i know i have a type for it T q r a
09:22:06 <gwern> :t floor
09:22:06 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
09:22:10 <gwern> :t ceiling
09:22:11 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
09:22:12 <quicksilver> ivan_: if your monad is as you showed it before (a combination of state transformed over IO)
09:22:23 <quicksilver> ivan_: then it will be an instance of MonadIO and that will type-check.
09:22:46 <ivan_> yes it is but it is also transformed over Either does it mater?
09:22:57 <quicksilver> if you're using ErrorT then that's fine too
09:23:05 <quicksilver> because ErrorT has the appropriate MonadIO instance
09:23:10 <quicksilver> but this doesn't sound like the error you're having
09:23:10 <byorgey> smg: the arguments on the left side of the =  show what types are needed to create a concrete instance of Quadruple.  In this case only two types are needed -- one type for the first two elements and another for the second
09:23:20 <quicksilver> that erorr would be "blah blah is not an instance of MonadIO"
09:23:21 <ivan_> strange why i get that it expects variable q
09:23:28 <quicksilver> ivan_: paste the code to hpaste.
09:23:32 <smg> byorgey: okay
09:23:33 <mauke> ivan_: because q is the return type of your monad
09:23:45 <smg> data Quadruple a b = Quadruple a a b b <-- is right then?
09:23:52 <byorgey> smg: yes =)
09:23:57 <smg> k
09:23:59 <gwern> is Control.Exception.catch the same as what used to be named catchAllIO?
09:24:04 <smg> but it won't complain if i mix types
09:24:08 <smg> how can this be?
09:24:14 <byorgey> smg: what do you mean?
09:24:50 <byorgey> smg: if you now try to write something like (Quadruple 3 "f" 6.2 'c') it will most certainly complain
09:24:52 <sclv_> ?remember mauke "the monad" is not valid code
09:25:20 <bringert> :t (floor . toRational)
09:25:21 <lambdabot> Done.
09:25:21 <lambdabot> forall b a. (Real a, Integral b) => a -> b
09:25:22 <ivan_> @umntl StateT r (ErrorT a IO) q
09:25:22 <lambdabot> Maybe you meant: unmtl unpl
09:25:27 <ivan_> @unmtl StateT r (ErrorT a IO) q
09:25:27 <lambdabot> r -> IO (Either a (q, r))
09:25:34 <smg> yeah okay
09:25:40 <smg> byorgey: but if i use 1.0 and 1 it will not
09:25:41 <ivan_> the return type is Either a or (q,r)
09:25:45 <smg> is that because 1.0 and 1 are in Num?
09:26:02 <mauke> smg: it's because 1 and 1.0 are more or less the same thing
09:26:04 <gwern> @hoogle tryAllIO
09:26:05 <byorgey> smg: yes, numeric literals are polymorphic.
09:26:05 <lambdabot> No matches found
09:26:14 <Saizan> ?type 1.0
09:26:15 <lambdabot> forall t. (Fractional t) => t
09:26:21 <byorgey> smg: if you type 1 it can be of type Integer, Double, ... whatever, depending on the context.
09:26:22 <smg> okay thank you
09:26:29 <smg> yeah 1 :: Double etc
09:26:31 <kpreid> smg: 1 can be Fractional but 1.0 can't be Integral
09:27:17 <gwern> @hoogle getlFileStatus
09:27:18 <lambdabot> No matches found
09:27:24 <gwern> @hoogle FileStatus
09:27:25 <lambdabot> No matches found
09:28:03 * gwern wonders what the heck getlFileStatus did
09:28:13 <kpreid> gwern: lstat() maybe?
09:28:31 <gwern> @hoogle FilePath -> IO FileStatus
09:28:31 <lambdabot> No matches, try a more general search
09:28:45 <hpaste>  gwern pasted "old getlFileStatus patch" at http://hpaste.org/5817
09:28:58 <gwern> it does call lstat indeed
09:29:08 <gwern> kpreid: any idea of the modern equivalent?
09:29:11 <Hamtaro> Hum, I think wxHaskell can't be installed on Ubuntu
09:29:19 <kpreid> gwern: no idea
09:29:28 <smg> http://phpfi.com/298160 <-- so this is okay now?
09:29:36 <gwern> Hamtaro: wxhaskell is always hard to install. I still haven't managed it - barfs in compile
09:30:19 <byorgey> smg: yup, looks good.  I'd probably just write [a,b] instead of [a]++[b] though.
09:30:23 <conal> gwern: which OS?
09:30:29 <smg> byorgey: ah okay
09:30:32 <smg> makes sense
09:31:04 <doserj> gwern: System.Posix.Files.getSymbolicLinkStatus
09:31:06 <Hamtaro> But what's wxhaskell exactly ?
09:31:16 <byorgey> smg: by the way, hpaste.org does haskell syntax highlighting, and has the option of announcing your pastes in this channel automatically =)
09:31:37 <smg> oh
09:31:40 <smg> i will see
09:31:46 <mauke> hpaste.org also doesn't delete old posts and randomly truncates them
09:32:10 <smg> hehe
09:32:16 <gwern> doserj: yeah. I found it already searching for mentions of lstat
09:32:20 <conal> Hamtaro: i want to put wxhaskell on Ubuntu.  do you know of difficulties?
09:32:35 <gwern> how far back does hpaste.org go anyway?
09:32:40 <byorgey> mauke: it's not random, it truncates them at precisely 5K!  =P
09:32:41 <conal> (s/put/install)
09:32:50 <gwern> @hoogle fileBlocks
09:32:50 <lambdabot> No matches found
09:32:59 <gwern> @hoogle blocks
09:33:00 <lambdabot> No matches found
09:33:03 <mauke> byorgey: yeah, that makes it practially unusable
09:33:12 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5818
09:33:15 <desegnis> conal, I for myself didn't have success in compiling wxhaskell on Ubuntu
09:33:27 <Hamtaro> Conal : yes, 2 errors for the moment
09:33:35 <gwern> @hoogle FileBlocks
09:33:36 <lambdabot> No matches found
09:33:44 <gwern> gah
09:34:04 <gwern> darn igloo for using all these odd functions in his 'ls
09:34:04 <gwern> clone
09:34:05 <ivan_> quicksilver: i have pasted the code, the one with no title on hpaste
09:34:17 <conal> desegnis: do you remember what happened?
09:34:40 <desegnis> conal, not exactly, there were errors from the C++ compiler, I think
09:34:47 <quicksilver> ivan_: you just have your parameter in the wrong order :P
09:34:59 <conal> desegnis: oh, urg.  thanks.
09:35:20 <quicksilver> ivan_: lifter will have type IO a -> Replay a r s
09:35:38 <Hamtaro> For me, first I had "'Executable' stanza starting with field 'flag splitbase description'" and after upgrade of cabal I have "-=-= Cabal executing: ./configure --with-hc=ghc=-=-
09:35:39 <Hamtaro> /bin/sh: ./configure: Permission denied"
09:35:41 <conal> are there any happy OSX haskell gui users?
09:36:07 <ivan_> quicksilver: why does it matter ?
09:36:08 <quicksilver> ivan_: conventionally we leave the 'contents' of the monad as the last named parameter
09:36:24 <quicksilver> ivan_: it matters because liftIO will lift IO a to "YourMonad a"
09:36:33 <quicksilver> ivan_: and the "contents" of your monad is the first parameter
09:36:36 <quicksilver> as you have written it
09:36:50 <quicksilver> Replay q r a <--- the "contents" is q
09:37:07 <quicksilver> type Replay r a q = StateT (Trace r) (ErrorT a IO) q
09:37:11 <quicksilver> would be a more normal way to write ite.
09:37:12 <ivan_> okay and if i want to lift up without the liftIO can i just do some lifts ?
09:37:24 <quicksilver> yes, liftIO will be lift . lift
09:37:26 <quicksilver> in this particular case
09:37:32 <quicksilver> (two levels of transform)
09:37:41 <quicksilver> the nice thing about liftIO is you don't need to know how deeply it's nested.
09:38:21 <ivan_> quicksilver: learn more and more about monads every day, thats nice =) thx
09:45:09 <ivan_> quicksilver: what am i actually doing in swtiching the variables, do i get another monadic function?
09:45:29 <Cin> @hoogle Fractional -> String
09:45:30 <lambdabot> No matches, try a more general search
09:45:47 <Cin> @hoogle Fractional a => a -> String
09:45:47 <lambdabot> Prelude.show :: Show a => a -> String
09:45:47 <lambdabot> Text.Show.show :: Show a => a -> String
09:45:47 <lambdabot> Data.Generics.Text.gshow :: Data a => a -> String
09:48:39 <Igloo> gwern: What odd functions?
09:48:53 <Igloo> gwern: That's ancient, BTW, so probably isn't a great example of good Haskell code  :-)
09:48:59 <quicksilver> ivan_: nothing really. a 'type' is just a shortcut/synonym. You're not changing anything.
09:49:17 <Cin> how does one get from a Fractional to a string representation of it which only shows x decimal places?
09:49:20 <quicksilver> Cin: there is showEFloat showFFloat and showGFloat
09:49:32 <Cin> ah, hm
09:49:53 <Cin> ahh. brilliant
09:50:05 <Cin> showFFloat
09:54:47 <ivan_> quicksilver: some other of my functions got an error now when i changed the type, can i use the do notaion the same as befor?
09:55:19 <quicksilver> ivan_: it's probably you need to correct some type annotations
09:57:28 <ivan_> quicksilver: yes =) i saw that now
10:02:51 <Hamtar1> Hum, if wxhaskell is correctly installed, how to open it ?
10:03:27 <byorgey> open it?  isn't it just a library?
10:03:43 <byorgey> Hamtar1: or what do you mean?
10:04:12 <dons> Hamtar1: does it appear in: ghc-pkg list  ?
10:04:38 <Hamtar1> Hum no
10:05:31 <Hamtar1> byorgey : So, how to test if the library is correctly installed ?
10:06:03 <glen_quagmire> Hamtar1: did you build it?
10:06:23 <Hamtar1> Yes
10:06:34 <Hamtar1> But I am not sure it's ok
10:06:54 <glen_quagmire> there should be example programs you can run
10:06:57 <byorgey> Hamtar1: as dons suggested, ghc-pkg list is the way to see if it's properly installed
10:07:39 <Hamtar1> Where is ghc-pkg list ?
10:07:51 <glen_quagmire> Hamtar1: type that in commandline
10:07:54 <Cale> Hamtar1: It's a command that you run
10:07:57 <glen_quagmire> Hamtar1: are you on windows?
10:08:02 <Hamtar1> No ubuntu
10:08:10 <Cale> Open the terminal and type that :)
10:08:31 <Hamtar1> I have wxcore
10:08:52 <Hamtar1> But not wxhaskell, do you think that's good ?
10:09:16 * glen_quagmire neverused wxhaskell
10:09:25 <hpaste>  Cin pasted "How should I force the evaluation of `content'?" at http://hpaste.org/5819
10:10:21 <Cale> Cin: you could compute its length or something
10:10:49 <hpaste>  matthew-_ pasted "IT WORKS!" at http://hpaste.org/5820
10:11:05 <Cin> cale: but that length would just be a thunk also?
10:11:52 <Cale> Cin: Yes, unless you did something with it. There's Control.Exception.evaluate if you want to force the evaluation to occur in sequence with IO
10:12:06 <Cin> cale: ahh, very cool
10:12:40 <byorgey> matthew_-: wow, what's that?
10:13:52 <matthew_-> it's progress, that's what it is
10:15:28 <jrx> @info liftIO
10:15:28 <lambdabot> liftIO
10:15:39 <jrx> @src liftIO
10:15:39 <lambdabot> Source not found. You speak an infinite deal of nothing
10:17:07 <Cin> @hoogle liftIO
10:17:08 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
10:17:20 <sclv_> matthew_: what's the difference between your ~>>=  and a regular >>= ?
10:17:33 <jrx> @src Control.Monad.Trans.liftIO
10:17:34 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:19:45 <jrx> what can liftIO be used for?
10:19:50 <ivan_> quicksilver: when i change my type from Rep q r a to Rep r a q and in lifter :: IO a -> Rep q r a, how do i make use of put if i wan to put a type r for the state. the nomad was StateT r (ErrorT a IO) q
10:20:11 <jrx> like.. I don't think it can work like: IO Int -> [Int]
10:20:28 <jrx> or IO Int -> Maybe Int
10:20:47 <jrx> so it must be restricted to some monads, isn't it?
10:21:07 <Baughn> jrx: It's restricted to monads that implement it. ;)
10:21:08 <byorgey> jrx: it's for use with monad transformers.
10:21:13 <Cale> jrx: It's only for monads constructed over IO
10:21:29 <jrx> ok, sorry, I haven't seen it's MonadIO not Monad
10:21:35 <matthew_-> sclv_: (~>>=) :: m x y a -> (a -> m y z b) -> m x z b
10:21:39 <byorgey> ah, yes, that's the key =)
10:21:40 <Baughn> jrx: If you like, monads that inherit from IO
10:21:52 <Baughn> ..not really inheritance, but that's the principle
10:22:10 <matthew_-> byorgey: it's the last achievement in session types for Haskell
10:22:20 <sclv_> oh ah, yeah, I realized they're from the session types library. knew i'd seen them somewhere before!
10:22:31 <matthew_-> gosh, you've looked at that code?!
10:22:42 <byorgey> matthew_-: oh, I see, cool!
10:24:05 * matthew_- wonders why hackage is being so damn slow
10:24:14 <matthew_-> latest added to hackage now
10:24:26 <Baughn> jrx: Eg. you /could/ instance MonadIO for Maybe, but there would be no way for the implementation to do anything useful
10:24:47 <Cale> liftIO x = Nothing
10:24:48 <Cale> heh
10:25:11 <Lord_Illidan> hey guys!
10:25:20 <Cale> hello!
10:25:37 <hpaste>  Spockz pasted "project on table" at http://hpaste.org/5821
10:25:47 <Spockz> hello
10:25:49 <Lord_Illidan> I'm wondering..is it possible to have a function that takes another function as a parameter?
10:25:52 <sclv_> matthew_-: just the haddocks.
10:26:01 <ricky_clarkson> Does Haskell memoise?
10:26:42 <Lemmih> Lord_Illidan: I don't think I've ever heard of a functional language that can do that.
10:26:46 <Spockz> I get an error on "(map (map (dropPosition) columnIndexes)). columnNames"
10:26:56 <sclv_> ricky_clarkson: only if you make it explicit.
10:27:04 <Spockz> And I find hat odd
10:27:18 <byorgey> Lemmih: ... you mean "that can't do that"?
10:27:40 <sclv_> http://haskell.org/haskellwiki/Memoization
10:27:41 <byorgey> Lord_Illidan: functions which take other functions as parameters are the bread and butter of functional languages like Haskell.
10:27:41 <Lord_Illidan> Lemmih, um, we have a question in this tutorial that states just that
10:27:52 <ricky_clarkson> When you use the FFI to call a C function, can you denote whether the C function is pure?
10:27:56 <Lord_Illidan> Haskell Functions can be given other functions as parameters
10:27:57 <byorgey> Lord_Illidan: as an example, take map.
10:27:59 <mauke> ricky_clarkson: yes
10:28:04 <cjb> ricky_clarkson: and the way you make it explicit is by creating a map of inputs to outputs, I think, so it's not really that the language has direct support for memoization (?)
10:28:16 <byorgey> @type map
10:28:17 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:28:17 <ricky_clarkson> Ok, thanks.
10:28:19 <Baughn> ricky_clarkson: You can use unsafePerformIO if it's pure, but it really has to be very pure to do that safely
10:28:26 <byorgey> Lord_Illidan: map takes a function  (a -> b), and a list [a], and gives you the result of applying the function to each element of the list.
10:28:28 <Lemmih> Lord_Illidan, byorgey: I was trying to kid.
10:28:41 <Lord_Illidan> Lemmih, ah ok
10:28:50 <ricky_clarkson> So if you grep code for 'unsafe' and find nothing then any FFI calls are reasonably safe?
10:28:52 <Baughn> ricky_clarkson: "let x = (arbitrarily complex expression)"; no part of x will ever be calculated twice
10:29:05 <mauke> ricky_clarkson: no
10:29:14 <Saizan> matthew_-: whoa ~||~ has a ~30 locs type signature :D
10:29:21 <Baughn> ricky_clarkson: You could conceivably make x a map from an infinite number of inputs to outputs, using laziness, so.. memoising is certainly possible if you want it
10:29:41 <gnuvince> :t (~||~)
10:29:42 <lambdabot> Not in scope: `~||~'
10:29:49 <Cale> Lord_Illidan: You can pass functions to other functions just like anything else. There's nothing even slightly tricky about doing it :)
10:30:09 <Cale> > let twice g x = g (g x) in twice (+1) 0
10:30:16 <lambdabot>  2
10:30:31 <Baughn> ricky_clarkson: Do you understand how the IO monad works yet?
10:30:49 <Lemmih> > let twice g x = g (g x) in twice (+1) 0 :: Expr
10:30:49 <lambdabot>  0 + 1 + 1
10:31:11 <mauke> > let twice g x = g (g x) in twice f x
10:31:14 <lambdabot>  f (f x)
10:31:29 <ricky_clarkson> Baughn: Yes.
10:31:36 <Baughn> Lord_Illidan: There's a valid point of view stating that haskell "values" are really just zero-parameter functions, meaning you can't pass anything /but/ functions
10:32:16 <glen_quagmire> > let dup x = [x,x]; mul [x,x] = x*x in mul $ dup 2
10:32:16 <lambdabot>      Conflicting definitions for `x'
10:32:16 <lambdabot>     In the definition of `mul'
10:32:17 <Baughn> ricky_clarkson: All provided FFI calls are in IO, eg. marked as impure if you like
10:32:24 <Cale> It's kind of a strange view though. I usually take the stance that functions are those things which have -> as the top level constructor in their type :)
10:32:35 <Lord_Illidan> Cale, then how do I this..
10:32:44 <Cale> Lord_Illidan: what are you trying to do?
10:32:45 <mauke> Baughn: I don't think that view is valid
10:32:47 <Lord_Illidan> imagine I have a function that takes an int and returns that int * 10
10:32:54 <sclv_> ?seen gwern
10:32:54 <lambdabot> gwern is in #perl6, #xmonad and #haskell. I last heard gwern speak 58m 5s ago.
10:32:57 <mauke> .oO( f n = n * 10 )
10:32:58 <ricky_clarkson> Baughn: Ok, and you can only call them outside IO if you use unsafe?
10:33:03 <Baughn> ricky_clarkson: You can use unsafePerformIO (read the documentation! and the wiki!) to force haskell to pretend a calculation is pure and get rid of IO, but if you lie, gremlins will eat your toes
10:33:15 <Lord_Illidan> testFunction n = n * 10
10:33:27 <mauke> Baughn: er, huh? you can just import foreign functions with a pure type
10:33:29 <Lord_Illidan> now, I'd like to have a method, that for instance in hugs
10:33:40 <Lord_Illidan> I can just type : callFunction testFunction 10
10:33:43 <Lord_Illidan> and it returns 100
10:33:49 <Baughn> mauke: Same issue, though
10:33:58 <Cale> That would be the identity function
10:34:00 <Cale> id
10:34:08 <Cale> Or if you want:
10:34:09 <mauke> no trace of "unsafePerform"
10:34:09 <Cin> or ($) ?
10:34:13 <Cale> callFunction f x = f x
10:35:00 <ricky_clarkson> What does importing a foreign function with a pure typre look like?
10:35:13 <Lord_Illidan> let me give you my question
10:35:29 <mauke> foreign import ccall "math.h sqrt" c_sqrt :: CDouble -> CDouble
10:35:43 <Cin> > let testFunction = (*10); callFunction = ($) in callFunction testFunction 10
10:35:44 <lambdabot>  100
10:35:46 <Cale> Cin: yeah, or ($)
10:36:02 <Cale> ($) is just id, restricted to function types
10:36:09 <Lord_Illidan> what would be the type of callFunction though/
10:36:15 <Cale> (a -> b) -> a -> b
10:36:19 <Baughn> mauke: ..I never noticed that option. *blink*
10:36:22 <Lord_Illidan> Integer -> Integer -> Integer?
10:36:26 <Cale> Nope
10:36:36 <Cale> It takes a function, and a value, and applies the function to that value
10:36:50 <Baughn> mauke: As far as values being values or functions, though, I'd argue that it's more akin to QM's wave-particle duality. They're neither, but have properties of both
10:36:53 <Cale> So it's (a -> b) -> a -> b
10:37:04 <Cale> Or, with extra parens, (a -> b) -> (a -> b)
10:37:06 <mauke> I disagree :-)
10:38:46 <Lord_Illidan> Haskell functions can be given other functions as parameters. We will be talking more
10:38:46 <Lord_Illidan> about this later in the course. For the moment, try to define a function approxArea1
10:38:46 <Lord_Illidan> which given a function (from Double to Double) calculates an approximation of the
10:38:46 <Lord_Illidan> area under the graph between 0 and 1 by reducing it to a trapezoid:
10:38:57 <ivan_> if i define a monad transformer type T q r a and i use the type in a function but with the types in different order for which monad can i use its function?
10:39:17 <Lord_Illidan> that's the question given to us..now I have an idea of how to do it, and I don't want anyone to do it for me, ok, I recognise this is not a hw channel
10:39:23 <Lord_Illidan> it's how to define the types
10:39:57 <Cale> approxArea1 :: (Double -> Double) -> Double
10:40:18 <Lord_Illidan> so you have to do the brackets, then?
10:40:21 <Cale> yes
10:40:24 <Baughn> approxArea2 :: (Double -> Double) -> Double -> Double -> Double
10:40:28 <Cale> They're extremely important here.
10:40:35 <hpaste>  me pasted "data.hs:21:10: Not in scope: type constructor or class `Tuple1'" at http://hpaste.org/5822
10:40:46 <sclv_> otherwise its going to be Double -> (Double -> Double) by default.
10:40:50 <Lord_Illidan> ah, ic, whee can I read more about this, please?
10:40:54 <smg> can someone tell me what's wrong at that paste?
10:41:12 <Cale> Lord_Illidan: Without brackets, -> will associate to the right
10:41:22 <Baughn> Lord_Illidan: You should probably input the function's validity range at some point, unless you really want to integrate over an infinite range
10:41:25 <Cale> That is, Double -> Double -> Double means Double -> (Double -> Double)
10:41:32 <Lord_Illidan> ic
10:41:40 <Cale> Baughn: he's specifically integrating over [0,1]
10:41:48 <doserj> smg: the type signature for tuple1
10:41:52 <mauke> smg: 「tuple1 :: Tuple1 -> Maybe」 is not a valid type
10:41:57 <Baughn> Right, but isn't a more generic function more useful? ;)
10:42:10 <smg> mh, i know ;-) but what would be the right?
10:42:11 <sclv_> it needs to be Tuple -> Maybe
10:42:13 <Cale> Lord_Illidan: That is, you have a function which takes a Double, and produces a Double -> Double, which isn't what you want.
10:42:32 <Cale> You want a function which takes a Double -> Double, and produces a Double
10:42:36 <doserj> sclv_: not quite
10:42:41 <sclv_> and then you pattern match on the Tuple to get a specific (Tuple1 a) or etc.
10:42:41 <Cale> So that's (Double -> Double) -> Double
10:42:45 <mauke> smg: why don't you ask the interpreter? :-)
10:42:59 <sclv_> oh right, sorry I forgot it needs to be parameterized.
10:43:03 <smg> mauke: ?
10:43:12 <Cale> Lord_Illidan: Make sense?
10:43:19 <gwern> @seen shapr
10:43:20 <lambdabot> shapr is in #haskell, #scannedinavian and #haskell-blah. I last heard shapr speak 2h 21m 36s ago.
10:43:24 <mauke> smg: load the code into your interpreter. type ":t tuple1"
10:43:38 <glen_quagmire> shouldj't type start with capital LETTER?
10:43:55 <smg> ah i understand
10:43:57 <smg> nice one mauke
10:44:42 <Lord_Illidan> Cale, yes, I am trying to understand and make a test case
10:44:45 <idnar> glen_quagmire: :t gives you the type of a value
10:44:46 <Lord_Illidan> but thanks for your help
10:44:58 <gwern> Igloo: the odd functions are fileBlocks, fileBlockSize, and stickyBitMode. I couldn't find any replacements for them - not that it really matters, because even if I undefine them, Main.hs fails hard with a bunch of type errors
10:44:58 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
10:44:58 <glen_quagmire> idnar: oop
10:45:00 <glen_quagmire> s
10:45:46 <gwern> @seen sclv_
10:45:46 <lambdabot> sclv_ is in #haskell-blah and #haskell. I last heard sclv_ speak 2m 48s ago.
10:46:04 <gwern> oh. :) that'll teach me to not look up
10:46:16 <sclv_> gwern: I was just curious. seemed odd to me to put packages that are known to be obselete.
10:46:47 <sclv_> Guess it's more motivation for a better hackage api for seperating the wheat from the chaff tho.
10:47:03 <dons> sclv_: so are you pursuing this cgi refactor idea?
10:47:14 <gwern> sclv_: why not? if they're on hackage, perhaps someone will update them. I'm trying to avoid stuff that could never be useful again, sure, but adding old stuff, as long as it says don't expect it to work on 6.8.x (hence the description's warnings and the tested-with fields), I think of it as archiving
10:48:20 <Lord_Illidan> Yes!! it worked
10:48:22 <Lord_Illidan> thanks Cale
10:48:26 <sclv_> yeah, I suppose.
10:48:35 <RayNbow`> hi Spockz :p
10:48:59 <Spockz> hellowz
10:49:02 <sclv_> I guess I'm concerned about someone just going to hackage and wanting to immediately see the good working libs for their current task. But that's probably more a hackage issue.
10:49:14 <monochrom> Mr Spockz, how do you logically prove GHC correct? :)
10:49:46 <gwern> sclv_: probably. But I'm not sure what it can do more than mention build-filures, although it'd probably be worth also mentioning tested-with fields on the HTML page
10:50:18 <Spockz> monochrom: err. By induction? :+
10:50:23 <Spockz> I wouldn't know
10:50:29 <RayNbow`> @pl dropPosition n xs = let (a,b) = splitAt n xs in a ++ tail b
10:50:29 <lambdabot> (line 1, column 19):
10:50:29 <lambdabot> unexpected "="
10:50:29 <lambdabot> expecting variable, "(", operator or end of input
10:50:29 <monochrom> haha
10:51:17 <sclv_> hackage should have a better way to filter is the main thing: so I can see only packages known to build with my version, for example, or only libraries and not apps, etc.
10:51:28 <RayNbow`> @pl \n xs -> fst (splitAt n xs) ++ snd (splitAt n xs)
10:51:28 <lambdabot> ap (ap . (((++) . fst) .) . splitAt) ((snd .) . splitAt)
10:51:36 <shapr> gwern: mage should have some sort of open license. I can probably contact the author if you want something explicit.
10:51:39 <RayNbow`> ^ Spockz, do you like this version? :p
10:51:56 <glen_quagmire> what does pl in @pl stand for? point-less ?
10:52:08 <RayNbow`> yup
10:52:19 <dons> Cale, keep an eye on JeffersonHeard on the list. he's doing some serious stuff, and can use our support
10:52:23 <glen_quagmire> oh thkank you
10:52:31 <gwern> shapr: yes please
10:52:33 <gnuvince> @pl (abs . (+))
10:52:33 <lambdabot> abs . (+)
10:52:35 <RayNbow`> I'm sure the haskell wiki has an entry on pl stuff
10:52:50 <sclv_> the packages page is sort of imposing enough at this point.
10:53:26 <Spockz> RayNbow`: I don't like that pl much :+
11:05:37 <esdee> Is there something special you need to do to make scripts with runhaskell?
11:06:24 <Cale> Not really. You just #! /usr/bin/env runhaskell at the top
11:06:55 <doserj> and "chmod +x" them
11:07:34 <esdee> if I just do ./myscript.hs, nothing happens.  But if I do "runhaskell myscript.hs" it works (its just hello world)
11:07:52 <dons> do you have a #!/usr/bin/env runhaskell
11:07:55 <dons> as the first line of the file?
11:08:02 * shapr throws lambdas
11:08:11 <esdee> #!/usr/bin/runhaskell should be fine right?
11:08:20 <dons> if that's the path to it
11:08:23 <esdee> it is
11:08:38 <dons> #!/usr/bin/env runhaskell
11:08:39 <dons> main = print "rockin' the lambdas"
11:08:42 <dons> $ chmod +x A.hs
11:08:42 <dons> $ ./A.hs
11:08:43 <dons> "rockin' the lambdas"
11:08:59 * shapr cheers
11:09:12 <esdee> oh, my -fglasgow-exts is breaking it
11:09:28 <dons> btw, shapr taught me to be infectiously optimistic. thanks shapr!
11:09:33 <shapr> w00!
11:09:36 <dons> :D
11:09:51 * dons bounces!
11:10:26 * shapr boings!
11:10:30 <dons> matthew_-: hey, is sessions in a source repo somewhere?
11:10:32 <monochrom> I always wonder about the env part.  Perhaps it is just for its PATH search ability.  Normally env is intended to list or locally override environment variables.
11:10:42 <dons> matthew_-: this guy, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sessions-2008.2.22
11:10:43 <lambdabot> http://tinyurl.com/29ubg3
11:10:57 <shapr> I have the day off, and I've now slept enough to make up for the rest of the weekdays, what project could I contribute towards?
11:11:21 <glguy> NAME
11:11:22 <glguy>        env - run a program in a modified environment
11:11:53 <dons> hmm. shapr, you might want to have a look at ohloh, some interesting stuff there. http://www.ohloh.net/projects/search?q=haskell , oh, and do you have a code.haskell.org account?
11:11:54 <lambdabot> Title: Ohloh Project Search Results
11:12:05 <gwern> shapr: pugs could use some 6.8.x cleanup; hoogle could be cleanedup and uploaded to hackage; hackage itself always has a bunch of outstanding easy tickets; you could play with some of Igloo's nicer stuff;
11:12:08 <shapr> dons: I think so. Actually, I think I'm an admin there.
11:12:13 <dons> great.
11:12:13 <gwern> lambdabot is a real mess as always
11:12:14 <gwern> and so on
11:12:21 <esdee> ok, so where am I supposed to put -fglasgow-exts?
11:12:24 <gwern> shapr: there's plenty to do! :)
11:12:28 <shapr> gwern: Yay!
11:12:32 <monochrom> Data.Array.* documentation
11:12:52 <monochrom> We need "documentation cops" :)
11:12:53 <gwern> shapr: I'd particularly like Fraskell updated - http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Fraskell/
11:12:53 <lambdabot> Title: Fraskell
11:12:57 <dons> #!/usr/bin/env runhaskell
11:12:57 <dons> {-# OPTIONS -fglasgow-exts #-}
11:12:57 <dons> main = print "rockin' the lambdas"
11:13:00 <dons> esdee: ^
11:13:23 <hpaste> I wonder when I'll be decommissioned <:-(
11:13:31 <esdee> thanks dons
11:13:32 <glguy> whois glguy
11:13:36 <glguy> whoops
11:14:22 <sclv_> identity crisis?
11:14:42 <gwern> glguy: I'd watch out, you've got an enemy whoising you (by the name of glguy)
11:14:54 * glguy sets +i
11:15:00 <dons> gwern: so who are the big remaining sources of code yet to be hackage-ified?
11:15:02 <glguy> hides behind his invisibility cloak
11:15:04 <shapr> gwern: You want Fraskell on Hackage, yeah?
11:15:16 <Lord_Illidan> is there a way of limiting the output of a double?
11:15:29 <Lord_Illidan> I mean, the answer is 0.42073549240394825
11:15:32 <monochrom> esdee: main = putStrLn "rockin' the \xce\xbbs"
11:15:35 <dons> > printf "%0.2f" pi :: String
11:15:38 <lambdabot>  "3.14"
11:15:46 <gwern> dons: igloo has a fair amount of stuff I'm looking at
11:15:47 <gwern> shapr: yes, and updated
11:15:54 * shapr hacks
11:15:55 <Lord_Illidan> can I truncate the output of a function?
11:15:57 <glguy> dons: What syntax highlighter should I look at?
11:16:19 <gwern> dons: and there's some random stuff in shapr's sacanndenavian website I recursively downloaded which I need to look at - I found mage in there, for example
11:16:22 <dons> glguy: i reckon the kate-highlighting package is worth a squiz. and hscolour a reliable fallback
11:16:44 <smg> dons: where is printf?
11:16:45 * dons wonders if "squiz" typechecks in american
11:16:47 <gwern> shapr: actually, where were you in particular hosting the mage tarball?
11:16:50 <dons> smg, Text.Pritnf
11:16:52 <gwern> *why were
11:16:55 <dons> Text.Printf
11:17:13 <shapr> gwern: It was cool code, and I didn't want it to disappear forever. I asked dark and he was fine with me hosting it.
11:17:15 <smg> i see
11:17:20 <shapr> I have a bunch of other things he's written as well.
11:17:33 <dons> is flippi on hackage yet??
11:17:34 <shapr> I have a *bunch* of things total. I have years of accreted Haskell sources.
11:17:34 <gwern> shapr: he doesn't have any of his own hosting?
11:17:44 <shapr> gwern: I'm sure he does, he just got bored and started doing other stuff.
11:17:45 <gwern> dons: I think so. it should be
11:17:47 <smg> like it :P
11:17:49 <dons> how about gofer?
11:18:09 <shapr> gwern: Problem with my years of accreted sources is that there's a noticable chunk that's under NDA, and I never got around to filing out those bits.
11:18:12 <dons> or other things by mark jones. or anything from OGI, like programmatica. and what about WASH?
11:18:17 <gwern> gofer? isn't that from, like the late '80s?
11:18:19 <doserj> or agda
11:18:23 <dons> or agda!
11:18:29 <dons> gwern: mid 90s. :)
11:18:35 <gwern> wash is on the list, about the rest
11:18:45 <gwern> (flippi is on hackage as Flippi)
11:18:47 <dons> ?go haskell gofer mpj
11:18:48 <lambdabot> http://www.google.com/Top/Computers/Programming/Languages/Haskell/Implementations/
11:18:48 <lambdabot> Title: Google Directory - Computers&nbsp;>&nbsp;Programming&nbsp;>&nbsp;Languages&nbsp; ...
11:18:50 <gwern> *dunno about
11:19:05 <shapr> Should HAppS in hackage work?
11:19:36 <glguy> dons: bring on the dependencies!!
11:19:51 <gwern> shapr: happs is already on hackage, iirc, just old ones
11:20:14 <gwern> along with happs's syb-with-class and a few other dependencies
11:20:19 <shapr> gwern: Do you have uncc and harc along with mage?
11:20:38 <sclv_> shapr: the hackage package requires some tweaks to work with the new bytestring library. but then it works. but then it has a particular happs api that doesn't work with any known software or tutorials I know of. :-(
11:20:38 <gwern> I asked jones about it a while ago and he said they were waiting for a good time to update them all
11:20:56 <gwern> ./~shae/uncc--1.0--patch-4.tar.gz but I don't see any 'harc'
11:21:05 <sclv_> syb-with-class is another good candidate to update to the latest version if alexj is ok with it, and i don't know why he wouldn't be.
11:21:15 <shapr> Ah, I'll upload those then.
11:21:26 <gwern> 'HAppS [0.8.4]                      Web framework
11:21:28 <gwern> <-- old
11:21:47 <shapr> Yeah, 0.9.2 is the latest I've seen.
11:22:13 <glguy> dons: I need something more clever than "hpaste", something a ruby developer would come up with
11:22:15 <sclv_> actually the old syb-with-class seems to be the main obstacle to a purely cabal rather than searchpath based install.
11:22:18 <gwern> darcs HAppS-Server says it's at 0.9.1
11:22:20 <dons> glguy: hmm
11:22:27 <dons> something innovative and web 2.0?
11:22:47 <sclv_> shinyPaste
11:23:55 <shapr> Is there a recent gtk2hs in debian?
11:25:11 <glguy> dons: yeah, something that would look good with a beta sticker next to it
11:25:46 <Spockz> Hello
11:25:58 <Spockz> how do I convert from Maybe Int to Int?
11:26:14 <shapr> :t fromMaybe
11:26:19 <shapr> :t fromJust
11:26:30 <lambdabot> thread killed
11:26:33 <lambdabot> forall a. Maybe a -> a
11:26:44 <shapr> > fromJust (Just 1)
11:26:46 <lambdabot>  1
11:26:57 <idnar> :t fromMaybe
11:26:58 <lambdabot> forall a. a -> Maybe a -> a
11:27:01 <jrx_> > fromJust Nothing
11:27:02 <lambdabot>  Exception: Maybe.fromJust: Nothing
11:27:02 <shapr> Spockz: fromMaybe lets you furnish a default value.
11:27:04 <dons> glguy: to do that we need to have ideas
11:27:12 <Spockz> huh, in what module is that function?
11:27:16 <jrx_> :t maybe
11:27:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:27:21 * monochrom <3 fromMaybe and maybe and mebbe.
11:27:26 <shapr> :t mebbe
11:27:27 <lambdabot> Not in scope: `mebbe'
11:27:27 <Spockz> shapr: do you have a tut.?
11:27:29 <sclv_> Data.Maybe
11:27:48 * Cin writing a Web monad =o
11:27:50 <monochrom> "Do you have to import Data.Maybe?"  "Mebbe."
11:27:53 <shapr> Spockz: Look at the source, I think it's self explanatory.
11:27:57 <gwern> dons: I take it OGI is OGI School of Science and Engineering?
11:28:08 <Spockz> shapr: will do
11:28:15 <Spockz> if I can find it :+
11:28:24 <Lord_Illidan> wow..haskell is beautiful
11:28:27 <Spockz> i'm using the Helium compiler
11:28:32 * monochrom <3 haskell
11:28:34 <Cin> @ _ @ "it's.. beautiful..."
11:28:45 <gwern> helium. hm. wonder how that's cabalized
11:29:00 <Spockz> gwern: you know it?
11:29:00 <Igloo> My god, it's full of lambdas!
11:29:05 <Cin> igloo: haha
11:29:26 <shapr> @seen liyang
11:29:26 <lambdabot> liyang is in #haskell. I last heard liyang speak 7h 41m 4s ago.
11:29:43 <Lord_Illidan> is it possible to do the same in java? I just did a function which when given a function and two doubles calculates the area under the graph of that function with lowerbound and upperbound
11:29:44 <gwern> Spockz: no, I guessed from the [[OGI]] disambig page on WP
11:29:45 <dons> gwern: yeah. big haskell group for the last 10 years, now folded into PSU.
11:29:53 <Lord_Illidan> approx1 sin 0 121
11:29:53 <mux> > maybe x f y :: Expr
11:29:53 <lambdabot>  Couldn't match expected type `Maybe a' against inferred type `Expr'
11:29:56 <dons> gwern: how about House and Halfs, the file system?
11:29:57 <Lord_Illidan> 60.42832109577656
11:30:01 <dons> and all of oleg's stuff?
11:30:03 <shapr> Should libghc6-gtk-dev in debian/unstable work?
11:30:14 <Lord_Illidan> approx1 sin 11 121
11:30:14 <Lord_Illidan> -6.462400049181694e-2
11:30:24 <Lord_Illidan> approx1 tan 11 121
11:30:24 <Lord_Illidan> -13556.1655037233
11:30:29 <monochrom> It can be done in Java too.
11:30:38 <gwern> dons: halfs I vaguely remember as having a bad license
11:30:38 <gwern> but I could be wrong
11:30:45 <Lord_Illidan> monochrom, how?
11:30:47 <gwern> oleg's stuff is hard to work with... ZFS along took forever
11:30:53 <gwern> not to mention HList
11:30:53 <dons> gwern: i think its GPL
11:30:59 <Lord_Illidan> or in another O.o language?
11:31:17 <dons> gwern: lgpl
11:31:24 <dons> http://haskell.org/halfs/
11:32:07 <Lord_Illidan> and, oh, in just 4-6 lines?
11:32:15 <gwern> at least I already did hfuse
11:32:43 <monochrom> It takes some chore to pass around functions. Pass an object instead.  Your integrator should call a method (agreed upon beforehand) of the input object for "evaluating the function at value x".  C# relieves the chore just a bit.
11:32:57 <Lord_Illidan> ic
11:33:06 <Lord_Illidan> yes, i was thinking of that
11:33:13 <Lord_Illidan> but haskell makes it drop dead easy
11:33:22 <Lord_Illidan> btw, btw, does haskell have objects?
11:33:24 <monochrom> In C++, use the tools in #include <Functional>
11:33:31 <monochrom> No.
11:33:46 <Cin> lord: it has values which one could consider to be immutable objects
11:34:19 <lament> (haskell has objects in about the same way that C does)
11:34:34 <lament> except not even mutable
11:34:40 <monochrom> Or rather, it takes some chore in Haskell to mimic objects.  Most ingredients exist but are scattered, you have to combine them yourself.
11:34:41 <Spockz> huh
11:35:14 <glguy> Has anyone here used hightlighting-kate?
11:35:16 <Spockz> i'm not getting it :(
11:35:21 <glguy> I seem to be getting double spaced output
11:35:52 <Lord_Illidan> monochrom, hey, but wait a bit
11:35:56 <Cale> Spockz: what are you not getting?
11:36:04 <Lord_Illidan> would you have to create an object for each new function?
11:36:18 <monochrom> Probably yes.
11:36:21 <dons> glguy: do you have the repo for the packagE?
11:36:23 <cschneid> I
11:36:25 <Spockz> how to get the int out of elemIndex
11:36:26 <Lord_Illidan> monochrom, that sucks :D
11:36:30 <dons> they'll accept patches gladly, i think
11:36:39 <Cale> Lord_Illidan: Garbage collection and sharing are your friends.
11:36:52 <monochrom> public interface Integrable { public Double f(Double); }
11:37:23 <Spockz> monochrom: that doesn't look like haskell? :|
11:37:31 <Cale> Lord_Illidan: When you create a new compound datastructure in Haskell, say you take most of the parts from some other structure, and only change one bit. Those parts aren't copied. Only the pointers to them are.
11:37:45 <cschneid> I'm playing with loop comprehensions, and I have: map (\i -> fst i + snd i) [(i, j) | i <- [1..10], j <- [1..10]]     How would I take the outputted list of sizes and cound how many of each there are.  So I want something like: there are 10 "1"s, 10 "2"s and so on.
11:37:52 <cschneid> list comprehension
11:38:00 <mauke> Spockz: pattern matching
11:38:01 <Cale> :t elemIndex
11:38:01 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
11:38:08 <monochrom> ... approx1( new Integrable { public Double f(Double x) { return Math.sin(x); } }, 0, 2*Math.pi ) ...
11:38:11 <Cale> You get a Maybe Int, because it might fail
11:38:17 <dolio> > fromMaybe (-1) (elemIndex 5 [1..10])
11:38:18 <lambdabot>  4
11:38:25 <glguy> dons: I don't know if it is a bug
11:38:29 <dolio> > fromMaybe (-1) (elemIndex 55 [1..10])
11:38:30 <Cale> It'll return (Just n) if the element is found
11:38:31 <lambdabot>  -1
11:38:32 <glguy> dons: or if I'm using it wrong
11:38:33 <Cale> and Nothing if it's not
11:38:40 <dons> gwern: btw, as you add .cabal files. if you find darcs repos for them (or other repos) can you include that info in the .cabal file?
11:38:52 <Cale> You can use functions like maybe, or case to pattern match.
11:39:19 <shapr> Can someone unconfuse me? I'm looking at libghc6-glib-dev in debian/unstable. Aptitude won't install that package because it requires "ghc6 (< 6.6.1+)" sa well as "ghc6 (>= 6.6.1)" I downloaded the source of the deb, and it says "Depends: ghc6 (>= 6.8.2), ghc6 (<< 6.8.2+)" What am I missing?
11:39:24 <Cale> > case elemIndex 55 [1..10] of Nothing -> "Not found."; Just n -> "Found at: " ++ show n
11:39:29 <lambdabot>  "Not found."
11:39:33 <Cale> > case elemIndex 6 [1..10] of Nothing -> "Not found."; Just n -> "Found at: " ++ show n
11:39:34 <lambdabot>  "Found at: 5"
11:39:52 <Cale> Spockz: Does that help?
11:40:08 <smg> Cale: since now i did not know wether this is haskell code or not :D
11:40:19 <mux> > maybe "Not Found" (("Found at: "++) . show) $ elemIndex 55 [1..10]
11:40:19 <lambdabot>  "Not Found"
11:40:26 <mux> > maybe "Not Found" (("Found at: "++) . show) $ elemIndex 6 [1..10]
11:40:26 <smg> maybe is keyword? :D
11:40:27 <lambdabot>  "Found at: 5"
11:40:33 <Cale> No, it's a function
11:40:34 <shapr> It's a function.
11:40:41 <Cale> @src maybe
11:40:41 <lambdabot> maybe n _ Nothing  = n
11:40:41 <lambdabot> maybe _ f (Just x) = f x
11:41:24 <mux> it avoids noisy case expressions
11:41:39 <shapr> liyang: ping?
11:42:30 <Spockz> @t (maybe elemIndex)
11:42:31 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:42:32 <glguy> prettyHtml and renderHtml break PRE tags!
11:42:40 <Cin> hehe
11:43:04 <Cin> glguy: for those cases, you can use showHtmlFragment, just for the PRE tags or TEXTAREAs
11:43:10 <Spockz> @type (maybe elemIndex)
11:43:11 <lambdabot> forall a a1. (Eq a) => (a1 -> a -> [a] -> Maybe Int) -> Maybe a1 -> a -> [a] -> Maybe Int
11:43:22 <Spockz> hmpf
11:43:32 <Spockz> I just want to get the Int of elemIndex
11:43:56 <Cin> glguy: (use primHtml to convert some String (unparsed) to Html)
11:44:33 <gwern> dons: ok. anyway, what's programmatica?
11:44:41 <gwern> @where programmatica
11:44:41 <lambdabot> I know nothing about programmatica.
11:44:43 <doserj> @type (fromMaybe (-1) .) .  elemIndex
11:44:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
11:44:45 <dons> a huge ide tool from OGI
11:45:01 <dons> oh, hare, the haskell refactorer, that's another good one.
11:45:22 <dons> http://www.cse.ogi.edu/PacSoft/projects/programatica/
11:45:23 <lambdabot> Title: The Programatica Project
11:45:42 <cschneid> I'll reword my problem: how would I go from [1,1,1,2,2,3,3,3,3] to [(1,3), (2,2), (4,3)] ie. count the number of times each element shows up in the list?
11:46:21 <gwern> ow, they use cvs
11:46:38 <Spockz> cschneid: group them
11:46:50 <dons> gwern: you could use tailor to convert it to darcs/git
11:47:04 <Spockz> then built a new list with the pair (value,length)
11:47:19 <dons> gwern: notice, lots of code
11:47:37 <gwern> tailor, eh?
11:47:54 <bos> > (length &&& head) <$> group [1,1,1,2,2,2]
11:47:55 <lambdabot>  [(3,1),(3,2)]
11:47:55 <dons> what license do you know?
11:48:14 <gwern> dons: as gofer 2.3 goes, I doubt I'll hackage it - all C sources, it seems, and no makefile or explanation
11:48:27 <dons> well, it is a haskell interpreter though
11:48:29 <dons> oh well
11:48:34 <doserj> http://www.cs.kent.ac.uk/projects/pivotal/ would be cool
11:48:35 <lambdabot> Title: Pivotal home page
11:48:35 <gwern> @where HaRe
11:48:36 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
11:48:42 <Zao> map (\x -> (head x,length x)) $ Data.List.group l -- with less silly operators.
11:49:14 <dons> gwern: also, utrecht. they have a gazillion things in svn
11:49:48 <cschneid> Spockz, ok, I ened up with something working, but is there a better way than: map (\i -> (i !! 0, length i)) (Data.List.group [1,1,1,2,2,3,3,3,3])  ?
11:50:23 <cschneid> i !! 0 can be changed to head i, which is nicer
11:50:35 <bos> cschneid: see the example i wrote above
11:50:54 <byorgey> cschneid: you could always use something like (head &&& length) instead of (\i -> (head i, length i))
11:50:59 <idnar> :t (***)
11:51:00 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
11:51:06 <byorgey> cschneid: up to you whether you think that's more readable =)
11:51:11 <idnar> :t (+++)
11:51:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
11:51:42 <cschneid> byorgey, what's &&& do?  I'm way new to haskell, I've read a few tutorials, but need to work through stuff like that
11:51:42 <idnar> bleh
11:51:42 <doserj> cschneid: maybe you need to use group.sort instead of only group
11:51:42 <byorgey> ah, didn't see bos already wrote that above =)
11:51:42 <idnar> @pl \f g x -> (f x, g x)
11:51:42 <lambdabot> liftM2 (,)
11:51:47 <idnar> oh yeah, (&&&)
11:51:55 <idnar> I can never remember these silly operators
11:51:58 <byorgey> cschneid: well, it's a generic Arrow combinator.  in this case, though, all you need to know is that (f &&& g) x = (f x, g x)
11:52:00 <idnar> :t (&&&)
11:52:00 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:52:10 <bos> cschneid: it applies one function to the first element in the tuple, and the other to the second
11:52:23 <bos> then it retuples the results
11:52:27 <monochrom> kindergarten didn't teach me *** and &&&
11:52:34 <byorgey> hehe
11:52:45 <cschneid> bos, byorgey ok.  And the <$>?  Is that a single operator or a combination of a few?
11:52:50 <byorgey> @remember monochrom kindergarten didn't teach me *** and &&&
11:52:50 <lambdabot> I will remember.
11:52:52 <bos> it's fmap
11:52:52 <cschneid> it's hard for an untrained eye to pick up on all these symbols
11:53:03 <bos> yeah, you just learn them with exposure
11:53:09 <gwern> pivotal doesn't mention any license, though, and it uses hs-plugins *and* gtk2hs and other stuff? geez, if they used custom Setup.hs, they'd've hit my trifecta
11:53:14 <bos> fmap is a generified version of map
11:53:20 <monochrom> untrained eye is worth nothing. always train it.
11:53:51 <Spockz> yesss :D
11:53:54 <Saizan> cschneid: a more conventioal form would be "map (\xs -> (length xs,head xs) (group [1,1,1,2,2,2])"
11:53:55 <Spockz> my project function works :D
11:54:16 * byorgey high-fives Spockz 
11:54:24 <cschneid> Saizan, which is what my initial version looked like, I'm a big fan of "short" if possible.
11:54:45 <gwern> dons: any idea where utrecht's svn repo is? I'm searching http://www.uu.nl/uupublish/homeuu/1main.html but it doesn't help
11:54:45 <idnar> > head &&& length <$> group [1,1,1,2,2,2]
11:54:46 <lambdabot> Title: Universiteit Utrecht Home
11:54:46 <lambdabot>  Couldn't match expected type `[a] -> [a1]'
11:54:54 <idnar> > (head &&& length) <$> group [1,1,1,2,2,2]
11:54:55 <lambdabot>  [(1,3),(2,3)]
11:55:01 <idnar> damn, would have been nice if the precedence let that work
11:55:30 <monochrom> precedence is a messy issue
11:55:52 <byorgey> cschneid: you might find this interesting: http://cgi.cse.unsw.edu.au/~dons/blog/2007/07/31#rle
11:55:53 <lambdabot> Title: Haskell hacking
11:56:29 <Spockz> p
11:56:34 <Spockz> oh, no it isn't working :x
11:56:42 <cschneid> byorgey, ok, cool.  Thanks
11:56:55 <byorgey> oh, hm, I thought dons explained the &&& operator there
11:57:07 <monochrom> @define encode = map (length &&& head) . group
11:57:08 <lambdabot> Undefined.
11:57:16 <monochrom> ? undefined?
11:57:17 <idnar> what?
11:57:35 <monochrom> > L.encode
11:57:35 <lambdabot>   Not in scope: `L.encode'
11:57:50 <monochrom> @help define
11:57:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:57:57 <monochrom> @help @define
11:57:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:58:01 <doserj> @let encode = map (length &&& head) . group
11:58:01 <lambdabot> <local>:1:33:     Ambiguous type variable `a' in the constraint:       `Eq a'...
11:58:07 <byorgey> cschneid: for a discussion of arrows (if you're interested), see http://www.haskell.org/arrows and http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
11:58:07 <lambdabot> Title: Arrows: A General Interface to Computation
11:58:28 <monochrom> Anyway, may use a let.
11:58:32 <doserj> @let encode x = map (length &&& head) . group $ x
11:58:32 <lambdabot> Defined.
11:58:37 <monochrom> Oh!
11:58:50 <monochrom> > L.encode
11:58:51 <lambdabot>  <[()] -> [(Int,())]>
11:58:53 <idnar> :t map (length &&& head) . group
11:58:54 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
11:58:55 <monochrom> Nice.
11:59:04 <Cin> byorgey: haha, that whole post is "ner ner!" :P
11:59:06 <monochrom> > iterate encode "1"  {- hehehe! -}
11:59:07 <lambdabot>      Occurs check: cannot construct the infinite type: a = (Int, a)
11:59:07 <lambdabot>       Exp...
11:59:10 <idnar> :t \x -> map (length &&& head) . group $ x
11:59:11 <lambdabot> forall a. (Eq a) => [a] -> [(Int, a)]
11:59:14 <byorgey> Cin: hehe, of course =)
11:59:31 <byorgey> monochrom: argh! DMR + type defaulting strikes again!
11:59:39 <lament> map (length &&& head) . group ? head explodes
11:59:49 <idnar> :t L.encode
11:59:50 <lambdabot> Couldn't find qualified module.
11:59:55 <idnar> oops
12:00:02 <monochrom> No, no DMR here, doserj wrote "encode x = ...".
12:00:15 <byorgey> monochrom: oh! even better =P
12:00:21 <idnar> > L.encode []
12:00:23 <lambdabot>  []
12:00:27 <byorgey> lament: which part makes your head explode?
12:00:27 <idnar> > L.encode [()]
12:00:28 <lambdabot>  [(1,())]
12:00:43 <lament> actually none of it
12:00:48 <byorgey> > L.encode [(), (), (), ()]   -- not very useful...
12:00:49 <lambdabot>  [(4,())]
12:00:50 <lament> but where is this stuff defined?
12:00:58 <byorgey> lament: &&& is defined in Control.Arrow
12:01:12 <byorgey> @type (&&&)
12:01:13 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:01:15 <monochrom> But I prefer "4a" to (4,'a')
12:01:42 <gwern> 'Source for House has been released. The Gadgets gui part is "freeware for academic-use only" but the rest has a nice open license.' -shapr
12:02:41 <Spockz> byorgey, It works again :+
12:02:53 <byorgey> Spockz: oh good!
12:03:16 <Spockz> are you familiar with the ra term 'project'?
12:03:52 <byorgey> 'ra term' ?
12:04:06 <Spockz> method/term from relational algebra
12:04:09 <gwern> resident advisor?
12:04:11 <gwern> @hoogle openFd
12:04:11 <lambdabot> No matches found
12:04:30 <monochrom> @let encode x = concatMap (uncurry (++) . first show . (length &&& take 1)) . group $ x
12:04:31 <lambdabot> Couldn't match expected type `(Int, Char)'
12:04:48 <byorgey> Spockz: oh. probably, but I'm not sure of the terminology.
12:04:54 <monochrom> Oh, need to erase previous. But I'll put it under a new name.
12:05:00 <monochrom> @let rle x = concatMap (uncurry (++) . first show . (length &&& take 1)) . group $ x
12:05:01 <lambdabot> Defined.
12:05:07 <monochrom> > rle "aaaabb"
12:05:08 <lambdabot>  "4a2b"
12:05:14 <monochrom> Now the fun begins...
12:05:19 <monochrom> > iterate rle "1"
12:05:20 <lambdabot>  ["1","11","21","1211","111221","312211","13112221","1113213211","31131211131...
12:05:23 <smg> wtf is rle ?
12:05:24 <monochrom> hehehehehehe....
12:05:29 <byorgey> smg: run-length encode
12:05:36 <byorgey> monochrom: hehe, nice!
12:05:39 <idnar> @oeis 1 11 21 1211 111221
12:05:42 <lambdabot> Look and Say sequence: describe the previous term! (method A - initial term i...
12:05:42 <lambdabot> [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113...
12:05:45 <idnar> ah
12:07:43 <monochrom> @tell dons iterate (concatMap (uncurry (++) . first show . (length &&& take 1)) . group) "1"
12:07:44 <lambdabot> Consider it noted.
12:08:22 <dolio> > rle $ replicate 101 '4'
12:08:22 <lambdabot>   Not in scope: `rle'
12:08:32 <monochrom> use L.rle
12:08:50 <dolio> > L.rle $ replicate 101 '4'
12:08:50 <lambdabot>   Not in scope: `L.rle'
12:08:54 <monochrom> Eh?! so why did it work when I just say rle??
12:09:05 <dolio> Weirdness.
12:09:11 <byorgey> someone must have done a private @undefine or something
12:09:17 <monochrom> Either someone erased it in pm, or there is expiration.
12:09:24 * byorgey eyes the user list suspiciously
12:09:26 <cschneid> why do I keep getting Not in scoe: `<$>'?  I have Control.Monad imported, is it actually somewhere else?
12:09:35 <byorgey> cschneid: Control.Applicative
12:09:39 <doserj> may have been me, while fixing the type of encode :)
12:09:44 <cschneid> byorgey, ahh, I was looking at the wrong library, thanks
12:10:09 <cschneid> byorgey, that's what I get when I have all my firefox tabs open to a whole bunch of library pages
12:10:16 <monochrom> "Professor Plum killed it in the #xmonad room using a laser mouse."
12:10:18 <byorgey> cschneid: hehe =)
12:10:42 <byorgey> cschneid: yes, I remember that phase well...
12:11:11 <cschneid> byorgey, you know, I've tried learning haskell before, but something this time is clicking nicely.  Must be that I'm at work not working on java
12:11:25 * gwern shows monochrom a trackball card
12:11:51 <monochrom> haha
12:12:20 <byorgey> cschneid: cool. =)
12:12:35 <monochrom> This is idea for another April Fool joke :)
12:12:54 <gwern> I accuse Col. Ketchup, in the library, with the Datahands!
12:13:14 <monochrom> "lambdabot is dead again! who killed it, with which command, and in which channel?"
12:13:31 <gwern> J'accuse tu, Pikachu!
12:13:42 <monochrom> "The suspects are: Prof. Hutton, Dr. Dons, Miss Philippa, ..."
12:14:10 <mauke> I choose you, Picasso. Cubism attack!
12:14:14 <tomh> hey
12:14:34 <byorgey> hi tomh
12:14:43 <cschneid> syntax question then, I have the line: groupList2 list = (head &&& length) <$> (group $ sort list)   Is there a way to get rid of the parens around group $ sort list?
12:15:02 <tomh> anyone has some experience doing parallel algorithms with haskell?
12:15:16 <byorgey> cschneid: not really
12:15:17 <gwern> Dialga! The Coalition forces choose you!
12:15:38 <gwern> @pl  groupList2 list = (head &&& length) <$> (group $ sort list)
12:15:39 <lambdabot> groupList2 = ((head &&& length) <$>) . group . sort
12:15:46 <gwern> there you go
12:15:59 <cschneid> byorgey, ok, the overloading of () to mean both tupple and precedence is another thing to pay attention to
12:16:01 <gwern> actually, that doesn't look half bad
12:16:04 <monochrom> Is Okassaki teaching at a military school?  We can call him Col. Okassaki! :)
12:16:18 <mauke> @pl groupList2 list = (head &&& length) `fmap` (group $ sort list)
12:16:18 <lambdabot> groupList2 = ((head &&& length) `fmap`) . group . sort
12:16:24 <gwern> monochrom: oleg has something to do with military folks, I think
12:16:41 <byorgey> cschneid: true.  in practice I didn't find that to be much of an issue though.  has it confused you in a particular case?
12:16:53 <monochrom> Oleg is so intimidating, I'll call him Comrade Gen. Oleg. :)
12:16:54 <cschneid> byorgey, not really, just for future reference I need to keep track :)
12:17:31 <byorgey> cschneid: it's usually pretty clear, since people tend not to put huge long expressions inside a tuple
12:17:39 <cschneid> byorgey, ok, that makes sense
12:17:46 <byorgey> cschneid: so if there's a tuple it will usually be very short, making it obvious there's a comma
12:17:48 <gwern> monochrom: da
12:18:00 <qeny> Quick question:  how would I delay the evaluation of some function, like the unix program 'sleep' can do? for example, if I wanted to print something every 2 secs, or something?
12:18:11 <Baughn> qeny: threadDelay
12:18:14 <gwern> @hoogle delay
12:18:14 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
12:18:14 <lambdabot> GHC.Conc.registerDelay :: Int -> IO (TVar Bool)
12:18:14 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
12:18:23 <qeny> thank you very much.
12:18:47 <cschneid> well, that's my haskell break for the day, thank you so much to everybody who helped me out there.
12:19:08 <byorgey> cschneid: cheers =)
12:20:01 <monochrom> qeny: Bear in mind that the time unit is 1/1000000 seconds. :)
12:20:40 <qeny> heh, okay.
12:22:45 <byorgey> really, microseconds?  wow.
12:23:04 <Spockz> Syntax error:
12:23:04 <Spockz>     unexpected operator '>'
12:23:04 <Spockz>     expecting expression
12:23:06 <Spockz> err
12:23:06 <Spockz> :X
12:23:22 <qeny> I don't think it's really intended to be used like I'm going to use it--
12:23:25 <dolio> !paste
12:23:25 <hpaste> Haskell paste bin: http://hpaste.org/
12:23:25 <Spockz> > let (.) = fmap in succ . "vms" -- in Haskell
12:23:28 <Baughn> byorgey: Don't expect that it's actually that accurate. It's a forward-compatibility thing.
12:23:29 <lambdabot>  "wnt"
12:23:49 <jrx_> :t ap
12:23:49 <byorgey> Baughn: well, yes.
12:23:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:23:50 <Cale> Spockz: the "> " is just a cue to lambdabot
12:23:55 <jrx_> :t liftM
12:23:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:24:20 <Spockz> Cale: so I've been told
12:25:33 <RayNbow`> Spockz:
12:25:57 <RayNbow`> > "monads" >> "are" >> "evil!" -- :p
12:25:59 <lambdabot>  "evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!evil!...
12:26:18 <monochrom> nice! hahahahhaa
12:26:47 <RayNbow`> do not credit me for this expression, I got it from someone else in this channel :p
12:26:58 <Stinger> hmm does that do 18 evils!?
12:27:06 <monochrom> sounds like it
12:27:22 <sclv_> > "aa" >> "bbb" >> "c"
12:27:23 <Stinger> > length "monads" >> "are" >> "evil!" -- :p
12:27:24 <lambdabot>  "cccccc"
12:27:24 <lambdabot>  Couldn't match expected type `m a' against inferred type `Int'
12:27:30 <Stinger> > length $ "monads" >> "are" >> "evil!" -- :p
12:27:30 <lambdabot>  90
12:27:38 <Spockz> > "monads" >> "are" >> "chill"
12:27:40 <lambdabot>  "chillchillchillchillchillchillchillchillchillchillchillchillchillchillchill...
12:27:43 <monochrom> > "monads" >> "are" >> "gollum!"
12:27:44 <lambdabot>  "gollum!gollum!gollum!gollum!gollum!gollum!gollum!gollum!gollum!gollum!gollu...
12:27:45 <Stinger> > 18 * 4
12:27:46 <lambdabot>  72
12:27:48 <RayNbow`> > length "monads" * length "are"
12:27:49 <lambdabot>  18
12:27:52 <Stinger> > 18 * 5
12:27:53 <lambdabot>  90
12:27:57 <Stinger> ok ther we go :)
12:28:04 <Baughn> Take cartesian product of two lists, ignore products, return "evil" for each result. >_>
12:28:52 <Cin> withCthulhu
12:29:32 <Saizan> Baughn: concat!
12:29:58 <Baughn> Yes, must not forget concat.
12:30:04 <Baughn> @src [] >>
12:30:04 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:30:10 <Baughn> @src [] (>>)
12:30:10 <lambdabot> m >> k      = foldr ((++) . (\ _ -> k)) [] m
12:30:35 <Cin> @src ([] >>)
12:30:35 <lambdabot> Source not found. Do you think like you type?
12:30:37 <Cin> D:
12:30:51 <Baughn> @src [] (>>=)
12:30:51 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:30:55 <Baughn> @src [] guard
12:30:55 <lambdabot> Source not found. I am sorry.
12:31:08 <esap> @src ((->) a) (>>)
12:31:08 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:31:11 <Baughn> @src guard
12:31:11 <lambdabot> guard True  =  return ()
12:31:11 <lambdabot> guard False =  mzero
12:31:18 <mauke> @src (->) (>>)
12:31:19 <lambdabot> Source not found. stty: unknown mode: doofus
12:31:28 <Stinger> lol
12:31:31 <mauke> @src (->) (>>=)
12:31:31 <lambdabot> f >>= k = \ r -> k (f r) r
12:31:39 <Baughn> @src [] mplus
12:31:39 <lambdabot> mplus = (++)
12:32:11 <arussel> hi, I am considering learning haskell, does it matter that "Haskell: The Craft of Functional Programming" is nearly 10 years old, or is it still good to learn ?
12:33:18 <gnuvince> arussel: I don't think Haskell, the language, has changed much in 10 years, so it would probably work.
12:33:22 <monochrom> It may slightly mismatch today's libraries. But you can always ask this channel when something gives you errors.
12:33:43 <araujo> the basic has not changed much
12:34:10 <monochrom> But generally, learn anything from three books.
12:34:10 <arussel> k, thx
12:34:30 <monochrom> There are always nice things each book lacks.
12:34:50 <arussel> I was thinking also about: Programming in Haskell (Paperback)
12:34:51 <gwern> arussel: it's still good, I used it for a while
12:35:07 <arussel> monochrom: what is your top 3 ?
12:35:50 <gwern> oh wretched halfs, will you never compile?
12:36:07 <monochrom> I learned from 1 tutorial, 5 books, and two papers.
12:37:02 <esap> > "monad" >> [ "is evil" | _ <- "!!!" ]
12:37:03 <lambdabot>  ["is evil","is evil","is evil","is evil","is evil","is evil","is evil","is e...
12:39:04 <monochrom> "Gentle Introduction to Haskell."  ML for The Working Programmer.  The Haskell School of Expression.  Purely Functional Data Structures.  Algebra of Programming.  Functional Programming and Input/Output.  "Monads for Functional Programming".  "Monadic Parsing in Haskell".
12:39:13 <monochrom> Those in quotes can be found on the web.
12:39:51 <arussel> monochrom: thanks
12:40:46 <monochrom> I did not list Introduction to Functional Programming using Haskell.  This is only because I had already finished learning when I encountered it.  Wish I started with it.  Easily subsumes them all.
12:41:02 <Cale> Graham Hutton's book?
12:41:19 <Cale> er
12:41:55 <Cale> Or you're referring to the one by Bird?
12:42:09 <monochrom> Bird rules them all. :)
12:42:56 <Cale> arussel: If you're looking for a dead tree book, Hutton's recent book is supposed to be quite good.
12:43:24 <Cale> arussel: For practical tutorials online, there's YAHT and the Wikibook, which work well at least for basic stuff.
12:43:43 <Cale> I suppose it depends on what you're looking for.
12:44:52 <monochrom> "Gentle Introduction" enjoys a recent resurgence of interest.  Those of us who enjoyed it are now coming out of the closet to declare its value.
12:45:26 <Cale> It tends to be too fast for most beginners though.
12:45:46 <Baughn> I remember GItH as being too fast when I was new, and too basic to be useful now
12:45:55 <Cale> It's worth looking at regardless, but should probably be complemented with something that paces itself a little better.
12:46:23 <talentless> I found Haskell School of Expression to be a good intro. I felt it introduced topics at a good rate.
12:46:42 <monochrom> Then the recent resurgence of interest implies that recent beginners are fast too.  We old geezers come out of the closet because we find agreement among new kids.
12:47:21 <monochrom> (Otherwise why would we bother to offend YAHT fans? :) )
12:47:25 <hpaste>  mmorrow pasted "isFloatChar" at http://hpaste.org/5823
12:47:46 * Baughn isn't a fan of any tutorial in particular. As usual, I read them all.
12:48:26 <Cale> I should really finish writing mine.
12:48:39 <hpaste>  Lord Illidan pasted "Trapezoid" at http://hpaste.org/5824
12:48:42 <monochrom> Yes, be prepared to use them all, and be prepared to find that the 3rd or 4th one you read "does it". :)
12:49:10 <Saizan> mmh, maybe since FP concepts are more widespread the speed is less of a problem?
12:49:21 <monochrom> Yes, I do think so.
12:49:22 <Lord_Illidan> does anyone feel in the mood to check some code? There's a pdf : http://www.cs.um.edu.mt/~jcor1/FunctionalProgramming/tutorial-sheet-1.pdf and my code is http://hpaste.org/5824
12:49:28 <gwern> halfs uses a good 10 extensions, yeesh
12:49:36 <Lord_Illidan> I've done question 5..
12:50:09 <monochrom> E.g., if kindergarten taught category theory, teenagers would find Algebra of Programming easy to read. :)
12:50:29 <Baughn> monochrom: They tried that here
12:50:36 <Baughn> It, er, failed. Catastrophically.
12:50:47 <Cale> Baughn: Category theory literally?
12:51:05 <Baughn> Cale: Probably a watered-down version
12:51:07 <Lord_Illidan> you know, comments, mistakes, etc..our lecturer isn't very active online..I hope nobody thinks I'm being rude or exploitative
12:51:16 <Cale> Baughn: That's probably worse.
12:51:20 * Saizan remebers feeling lost with parentheses when he didn't know whitespace was the syntax for function composition
12:51:25 <Cale> Baughn: Watering down mathematics never makes it easier.
12:51:26 <Baughn> Cale: On the theory that "mathematicians say it's the most basic part of math, and we do the basics first"
12:51:38 <monochrom> hehe
12:51:55 <Cale> Wow, I don't think there's any mathematician who would literally recommend starting with category theory.
12:52:07 <monochrom> Lawvere... :)
12:52:13 <Baughn> None did
12:52:29 <Baughn> At least when I was in school, they taught arithmetic via set theory. That was.. slightly saner. Slightly.
12:52:47 <Cale> I'm not even sure that Lawvere would. He'd recommend using it as a foundation, sure, but you don't have to start with axiomatic foundations.
12:52:56 <Baughn> It did mean we weren't allowed to do arithmetic without literally moving blocks around, though
12:53:05 <byorgey_> yikes
12:53:05 <Cale> Baughn: Where do you live?
12:53:07 <monochrom> Haha, unary.
12:53:12 <Baughn> Cale: Norway
12:53:30 <monochrom> Norway wants to join the Roman Empire! :)
12:53:36 <Cale> Baughn: Even if insane, that's 1000 times more progressive than anything you could get here.
12:53:43 <Baughn> monochrom: Peano arithmetic. They even mentioned him by name.
12:54:03 <idnar> Piano arithmetic
12:54:23 <Baughn> Cale: It did a good job of teaching things that, frankly, are intuitive and could be mentioned as an aside in a single class.
12:54:27 <byorgey_> you aren't allowed to do arithmetic without literally moving pianos around
12:54:39 <SamB> idnar: was bach a fan of that?
12:54:46 <idnar> SamB: who knows
12:54:46 <Baughn> byorgey_: After a month we garduated to making scratches on paper
12:54:50 <Cale> Baughn: North America highschools are stuck in some twisted version of pre-formalism mathematics that's been watered down six ways from Sunday and is almost incomprehensible.
12:54:52 <idnar> SamB: I'm a Beethoven fan, personally
12:55:07 <SamB> (or hadn't they invented the pionoforte then?)
12:55:08 <Baughn> byorgey_: By then I was literally begging my parents to teach me long division
12:55:15 <SamB> idnar: well, beethoven then
12:55:46 <Baughn> Cale: I've yet to hear of a /good/ educational system, but we're doing a good job of mapping out the edges of the bad ones here
12:55:50 <Cale> Baughn: I could personally be happy if they taught nothing but graph theory, so long as they did it in a way which emphasized proof and logic.
12:56:25 <Baughn> Cale: Are six-year-olds capable of handling that much logic? The tautologies are supposed to be intuitive, but in my experience (from nieces) they /aren't/ at that age
12:56:29 <SamB> Baughn: I think the problem is the "system" part
12:56:38 <monochrom> http://www.cs.utexas.edu/users/misra/Speeches.dir/Marktoberdorf.88.speech.pdf  joke on Roman numerals :)
12:56:38 <lambdabot> http://tinyurl.com/2yz43b
12:56:41 <Cale> Yes, they are, surprisingly :)
12:56:44 <Baughn> SamB: Mentoring would be far superior, yes
12:56:44 <SamB> the whole idea of a system is preposterous
12:56:47 <Cale> So long as you present it well.
12:57:14 <Cale> Here, pre-university-level mathematics is a towering pinnacle of illogic and mechanical boring nonsense.
12:57:25 <Philippa> SamB: yet unavoidable if you intend to actually educate people
12:57:28 <Baughn> By the time you get to university, the "system" more or less starts working
12:57:50 <monochrom> You can teach anything.  Only the teaching skill is the tricky part.
12:58:04 <Baughn> SamB: It /is/ very easy to point out what's wrong. Perhaps there isn't a good solution.
12:58:11 <Philippa> whether you like it or not, you're going to have individuals and groups working to try to educate and at that point you have an educational system
12:58:12 <Cale> 6 year old kids are surprisingly flexible in terms of what you can teach them
12:58:15 <monochrom> I recommend going from concrete to abstract.
12:58:21 <Cale> So long as you do it carefully.
12:58:45 <Philippa> yeah. Jumping in without thinking about the map of concepts you need will lead you into trouble fast
12:58:55 * monochrom believes is Piaget's theory, at least some main ideas behind it.
12:59:06 <monochrom> s/ is / in /
12:59:23 <SamB> well, at the university they don't so much have an education system ... as material provided to you in one or more forms ... and a way to show that you have understood that material (or not)
12:59:36 <Cale> There are massive philosophical issues with the entire way in which mathematics is taught. It is constantly implied that there's only one way in which things could possibly be defined, as if mathematics were handed down to us on gold plates by some mathematical deity.
12:59:42 <Philippa> SamB: that's still a system
13:00:04 <Baughn> SamB: Compare universities to apprenticeship someday. It's a definite system.
13:00:07 <Philippa> it's just that by uni level you're supposed to be able to work with that, give or take
13:00:21 <SamB> well. it doesn't seem so bad. you don'
13:00:38 <SamB> t always have to do things the way everyone else does...
13:00:39 <monochrom> Kids can learn 5 unrelated languages at ease.  Unlike we 30yos.  Don't use ourselves to estimate what kids cannot learn.  We are the retards.
13:00:54 <Philippa> SamB: you're not complaining about systems then, but about rigidity and inflexibility
13:01:08 <Baughn> monochrom: For the moment. I have great hopes that we'll be able to fix that one day.
13:01:16 <SamB> yes, associated with a systematic approach to (attempted) education
13:01:25 <Cale> Then they take this point of view and completely strip out all the logic, showing various bits of the consequences of definitions which they only sometimes bother to mention, and often in some order in which there's no way to reasonably insert the proofs in between and make sense of it.
13:01:53 <Philippa> it's not much better without the systematic approach, you just end up with the inflexibility in even more idiosyncratic places
13:01:56 <monochrom> I luckily have somewhat postponed my retardedness by having learned how to learn when I was younger.
13:02:00 <SamB> Cale: yeah, good thing I skipped all that idiocy
13:02:15 <Cale> Moreover, they strip out anything which would require even the most marginal amount of creativity -- effectively turning the courses into "how to be a calculator" if you're lucky and "how to own a calculator" if you're not.
13:02:49 <Philippa> and then you start doing integration and eventually they throw something at you that you can't quite do by the numbers and it all goes to hell
13:03:07 <SamB> Cale: I want the course where they teach you how to make your own calculator
13:03:07 <Baughn> Cale: The same is very much true for non-math studies. I didn't really feel like I was /studying/, as opposed to cramming, until I got to master's-level studies
13:03:18 <gwern> @seen dons
13:03:18 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 1h 14m 4s ago.
13:03:20 * monochrom thinks "how to learn" is the greatest gift.  It gives you the inductive step you need to go on and on.  It is the "you are granted three wishes" "great, my third wish is three more wishes".
13:03:22 * Philippa suspects she could teach a (slightly sugared) simply-typed lambda calculus to kids as a logic
13:03:24 <dons> gwern: ?
13:03:24 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:03:38 <SamB> don't teach me how to learn. teach me how NOT to learn...
13:03:43 <gwern> that was fast
13:03:44 <gwern> dons: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/halfs-0.2 <-- that good as a mention of the darcs repo?
13:03:45 <lambdabot> http://tinyurl.com/24esz5
13:03:53 <SamB> Philippa: sugared?
13:03:55 <byorgey_> Philippa: a la the 'alligator game'? =)
13:04:06 <SamB> as in, put arrows in instead of dots?
13:04:08 <dons> gwern: yep
13:04:17 <SamB> maybe add parentheses?
13:04:17 <monochrom> dons: the message I sent you is inspired by http://cgi.cse.unsw.edu.au/~dons/blog/2007/07/31#rle
13:04:18 <lambdabot> Title: Haskell hacking
13:04:37 <Philippa> SamB: "Given" in place of lambda was one of the changes I had in mind. Also, you want AND and OR on the type level
13:04:46 <Cale> Baughn: Oh, the rest of my highschool courses were actually pretty reasonable, more or less. At least, in music class we actually played music. In English class, we actually wrote things. In chemistry, we carried out experiments to see things. It wasn't perfect, but at least you got some idea of what the thing was about.
13:05:07 <Cale> My problem with the way they teach mathematics is that the analogue of "playing music" is missing from the curriculum.
13:05:36 <Cale> Instead, it's more like trying to teach technical bits of music theory to people who have never so much as heard music in their life.
13:05:39 <SamB> you mean making up your own mathematical frameworks?
13:05:45 <Cale> I mean proving theorems.
13:05:49 <SamB> and that
13:06:00 <Cale> If you're not proving theorems, you're not doing mathematics.
13:06:05 <Hamtaro> What is the -B<dir> normal option ?
13:06:15 * Philippa would've loved to've had someone actually introduce the notion of 'tactic' while she was at school
13:06:33 <Philippa> it would've made talking about things so much easier, because I could've started to talk usefully about how I was trying to prove something
13:06:39 <monochrom> Do not be intimidated by "prove".  There are various levels of rigour.
13:06:50 * jre2 wishes my applied mathematics professors would agree with Cale
13:07:11 <hpaste>  adrian neumann pasted "parallel factorial" at http://hpaste.org/5825
13:07:20 <SamB> I get intimidated more by that-which-is-to-be-proved than the word "prove" ;-)
13:07:30 <dons> Cale: http://the-programmers-stone.com/2008/02/22/haskell-needs-a-four-calendar-cafe/
13:07:31 <lambdabot> Title: The Programmers&#8217; Stone  Blog Archive  Haskell Needs A Four Calendar Cafe, http://tinyurl.com/2s56p5
13:07:34 <dons> wonderful work
13:07:41 <RayNbow> SamB, quod erat demonstrandum?
13:07:53 <monochrom> Humans are naturally interested in relations between things.  "Proof" is then yet another relation between another kind of things.  Removing it actually makes the class dry.  You must put it back; the only question is in what packaging.
13:08:19 <SamB> meaning, if I get intimidated by a request to prove something, it's because of WHAT I'm being asked to prove, not the fact that I'm being asked to prove it
13:09:05 <dobblego> data List' a = Nil | Cons !a (List' a) -- quicksilver, you told me that this can't work for infinite lists, but it can
13:09:53 <SamB> that reminds me of Data.ByteString.Lazy...
13:09:57 <Hamtaro> I have installed EclipseFP and GHC, but how can I configure Eclipse for compile Haskell ?
13:10:13 <dolio> dobblego: That's element strict not spine strict.
13:10:18 <dons> Hamtaro: hmm. good question!
13:10:27 <dons> do we have any EclipseFP users here?
13:10:42 <Cale> I've seen incredibly bright, very logical people who were really intimidated by mathematics due to the broken way in which it was taught in highschool.
13:10:51 <smg> dobblego: is this from YAHT? :)
13:10:52 <dobblego> dolio, sure, I imagine spine strict would have strictness on the other Cons argument; but it still permits infinite structures
13:11:00 <dobblego> smg, perhaps? I just wrote it myself
13:11:01 <Hamtaro> dons : =/
13:11:09 <dons> Cale: well, he's making progress. so that's a great sign
13:11:10 <smg> dobblego: seems it is :)
13:11:14 <Cale> dons: yeah
13:11:21 <dons> Cale: consider collecting material for a book :)
13:11:26 <hpaste>  dobblego pasted "List'" at http://hpaste.org/5826
13:11:29 <RayNbow> dons: I sometimes use EclipseFP
13:11:30 <dons> really. if jdh can do it..
13:11:31 <smg> data MyList a = Nil | Cons a (MyList a)
13:11:35 * SamB used college textbooks for a lot of subjects in highschool...
13:11:38 <dons> RayNbow: can you help Hamtaro with getting ghc going?
13:11:48 <RayNbow> uh...
13:11:49 <dobblego> so, is [] spine strict, head element strict, or neither?
13:11:57 <mauke> neither
13:12:12 <RayNbow> sure... if I can remember how to configure it :p
13:12:15 * RayNbow starts Eclipse
13:12:19 <dons> Hamtaro: there must be some online docs somewhere
13:12:26 <SamB> dobblego: neither
13:12:34 <Hamtaro> dons : I jave searched...
13:12:39 <Hamtaro> heve*
13:12:43 <Cale> dons: Everyone seems to want me to clean up that tutorial I gave him and put it on the wiki. I should do that :)
13:12:43 <Hamtaro> have* U_u
13:12:58 <Hamtaro> RayNbow : Thanks
13:13:09 <dons> Cale: definitely
13:13:13 <dobblego> I recall writing some IO code that used hGetContents and I'd have to traverse the [] before calling hClose or it wasn't there "afterward" (in IO) - I thought this was because it was head element strict; how do I explain this? (is my recollection faulty?)
13:13:39 <dons> dobblego: you need to force the input to get read
13:13:41 <gwern> this si annoying. so there's a Helium repo *somewhere*, I can see the subversion files left around in the downloaded tarball, but they don't tell you where it is!
13:13:42 <SamB> dobblego: this is because it is lazy
13:13:51 <dons> dobblego: so a spine strict list will be ok here too
13:13:51 <gwern> I hate nonpublic repos
13:13:57 <dobblego> but how does forcing it change anything about that laziness?
13:14:03 <SamB> dobblego: also you aren't really supposed to call hClose after calling hGetContents
13:14:12 <dons> dobblego: it forces it to get read.
13:14:14 <SamB> it's either redundant or destructive...
13:14:19 <dons> right
13:14:26 <RayNbow> Hamtaro, have you already installed EclipseFP?
13:14:55 <Hamtaro> RayNbow : Yes
13:15:17 <RayNbow> Hamtaro, you also have GHC already installed?
13:15:25 <Hamtaro> RayNbow : yes :)
13:15:51 <RayNbow> well, the only thing you have to configure is...
13:16:28 <RayNbow> Window -> Preferences... -> Functional Programming -> Haskell -> Compiler -> GHC Compiler -> General tab -> GHC executable textbox
13:16:30 <Hamtaro> In preference => functional => Haskell => Compiler => GHC ?
13:16:37 <RayNbow> yup
13:16:47 <RayNbow> D:\App\Program\ghc\ghc-6.8.2\bin\ghc.exe <-- put something like this in that checkbox
13:16:53 <RayNbow> *textbox
13:17:01 <Hamtaro> I'm on ubuntu :)
13:17:23 <RayNbow> I have no idea where it's installed in Ubuntu :p
13:17:26 <Hamtaro> I think : /usr/lib/ghc-6.6.1/ghc-6.6.1 ?!
13:18:19 <RayNbow> not sure
13:18:26 <RayNbow> open up a terminal and type "whereis ghc"
13:18:40 <Cale> Heh, these people on reddit joke about using Haskell to get a girlfriend. In contrast, my girlfriend claims to have invented Haskell as a child (loosely speaking). :)
13:18:55 <Hamtaro> ghc: /usr/bin/ghc /usr/share/man/man1/ghc.1.gz
13:18:57 <Hamtaro> O_o
13:18:58 <Zao> Or which, or where.
13:19:11 <Zao> ghc there is most likely a script.
13:19:21 <dons> Cale: hehe
13:20:24 <Hamtaro> Hum now : ghc-6.6.1: missing -B<dir> option
13:20:28 <Cale> dons: I'm inclined to believe her, given that I taught her about monads entirely by giving her type signatures and basic definitions of types and having her implement everything. (She insisted that I phrase everything in terms of an exercise.)
13:21:17 <RayNbow> Hamtaro, what did you enter in the textbox?
13:22:02 <hpaste>  dolio annotated "List'" with "spine strict" at http://hpaste.org/5826#a1
13:22:57 <Hamtaro> /usr/bin/ghc
13:23:23 <RayNbow> and that didn't work?
13:24:21 <Hamtaro> No =/
13:24:34 <RayNbow> Hamtaro, from a terminal, type "cat /usr/bin/ghc" and look for the line that resembles:
13:24:35 <RayNbow> GHCBIN="/usr/lib/ghc-6.6.1/ghc-6.6.1";
13:24:54 <RayNbow> and try using that in EclipseFP
13:26:06 <gwern> '...a useful little project to Cabalize and upload to Hackage Helium...' <-- you know you are either german or a haskeller when your syntax starts to look like function composition
13:26:24 <Hamtaro> It's what I had at the beginning :D
13:26:47 <sclv_> I like the early Cocteau Twins stuff better. :-(
13:27:39 <Hamtaro> RayNbow : When I try to "run as.." I have the error : ghc-6.6.1: missing -B<dir> option
13:30:29 * gwern fires off the helium email. their tarball is outdated; I'm sure they must have more up to date versions somewhere
13:30:37 <RayNbow> Hamtaro: I have no idea what that means (never encountered it before)
13:31:00 <RayNbow> but to be honest, I actually never use EclipseFP to run applications...
13:31:02 <Hamtaro> RayNbow : What do you have in Run ... => Arguments ?
13:31:16 <Hamtaro> What do you use ?
13:31:43 <gwern> wow, 226 comments in 'Ask reddit: Why don't you use Haskell? (self.programming)'. pity the poor dons which tries to keep up!
13:31:44 <RayNbow> just a console window and ghci :p
13:32:30 <RayNbow> it's because I'm not too fond of EclipseFP's interpreter features
13:32:42 <RayNbow> I mainly use it to edit Haskell files in it
13:33:31 <Hamtaro> Ok, thanks for help, I must to go >_<
13:33:51 <RayNbow> no problem, too bad I couldn't fix that -B<dir> error
13:34:27 <Hamtaro> lol :p
13:35:00 <dmwit> gwern: link?
13:35:04 <Hamtaro> Before leave, can you say me what files/folders you have in a new project ?
13:35:32 <dmwit> Hamtaro: Specifically for an Eclipse project, or just in general?
13:35:52 <Hamtaro> Eclipse =/
13:36:13 <RayNbow> Hamtaro: src, out, bin
13:36:49 <gwern> dmwit: http://reddit.com/r/programming/info/69jbs/comments/
13:37:11 <dmwit> Thanks.
13:37:40 <dobblego> is there a typical method of turning on 'deriving Show' only when developing?
13:38:36 <Hamtaro> RayNbow and files ?
13:39:41 <RayNbow> Hamtaro: well, in Windows it creates theResult.exe in bin
13:40:03 <RayNbow> the .hs files like Main.hs are stored in src
13:40:10 <Hamtaro> Ok, thx :)
13:40:33 <RayNbow> out contains the object files that are linked to get the executable
13:41:06 <shachaf> I've heard that someone has done some theater lighting using Haskell at one point.
13:41:13 <shachaf> Does someone here have any information on that?
13:44:11 <Hamtaro> Bye all and thx :)
13:45:06 <dons> shachaf: yeah, i think blackdog ?
13:45:09 <Lemmih> Can we delete packages from Hackage?
13:45:14 <dons> Lemmih: not really
13:45:26 <dons> Lemmih: but it could be done in emergencies
13:46:06 <Lemmih> dons: We're about to release a new version of HAppS and I think the old package would cause a lot of confusion (it has already).
13:46:17 <dobblego> @go ifdef DEBUG deriving show haskell
13:46:17 <dons> Lemmih: hmm. same for hs-plugins.
13:46:19 <lambdabot> No Result Found.
13:46:28 <dons> the new package will replace the old though? or does it have a different name?
13:46:36 <shachaf> dons: Hmm, who is that?
13:46:39 <dons> Lemmih: it would be nice to be able to 'hide' a package
13:46:50 <Lemmih> dons: The old package is named HAppS, the new are HAppS-State, HAppS-Server, aso.
13:47:11 <dons> Lemmih: maybe a patch to the hackage scripts to allow deletion?
13:48:47 <Lemmih> I'm tempted to delete it by hand.
13:49:17 <shachaf> dons: "Mark Wotton"?
13:49:26 <dons> yep
13:49:52 <Cin> what's that function called that maps over a list of Maybe and returns the first which is Just a?
13:50:26 <dobblego> ?hoogle [Maybe a] -> Maybe a
13:50:27 <lambdabot> No matches, try a more general search
13:50:34 <ehird> > first
13:50:34 <dobblego> Cin, I don't think there is one
13:50:36 <Baughn> Probably a monad function
13:50:37 <lambdabot>  Add a type signature
13:50:50 <Baughn> There's always foldr mplus
13:50:57 <dobblego> sequence?
13:51:04 <Cin> i saw it in some code recently and thought "ah! handy" but forgot what code it's in
13:51:08 <ehird> > firstJust = first f where f (Just a) = True; f Nothing = False
13:51:08 <lambdabot>  Parse error at "=" (column 11)
13:51:17 <ehird> > let firstJust = first f where f (Just a) = True; f Nothing = False in firstJust [Just 1]
13:51:18 <lambdabot>  Couldn't match expected type `(Maybe t, d)'
13:51:19 <dobblego> > sequence [Nothing, Just 7, Just 8]
13:51:20 <ehird> hrm
13:51:21 <lambdabot>  Nothing
13:51:50 <dobblego> Cin, listToMaybe maybe?
13:51:57 <dobblego> ?type listToMaybe
13:51:58 <lambdabot> forall a. [a] -> Maybe a
13:52:08 <dobblego> ?type catMaybes
13:52:09 <lambdabot> forall a. [Maybe a] -> [a]
13:52:21 <Baughn> > foldr1 mplus [Nothing,Nothing,Just 3,Nothing,Just 4]
13:52:22 <lambdabot>  Just 3
13:52:25 <cinema_> ping sclv
13:53:01 <Cin> baughn: but that'll continue going through the list even if it's found a Just?
13:53:10 <Baughn> Cin: ..yeah.
13:53:11 <sclv_> hai dere
13:53:23 <Baughn> Cin: Wait. No, I don't think so.
13:53:28 <cinema_> sclv, you are the author or HStringTemplate ?
13:53:32 <Baughn> Cin: Then again, yes it will.
13:53:36 <sclv_> yep
13:53:36 <dobblego> Cin, foldr is lazy
13:53:37 <Cin> baughn: haha
13:53:52 <cinema_> sclv, well I like it very much
13:53:54 <Cin> dobblego: so?
13:53:59 <Baughn> Cin: It'll call mplus once for each member of the list (-1), but mplus won't actualy evaluate anything after the first one
13:54:02 <cinema_> sclv, and I have a fix for you
13:54:24 <Baughn> Cin: This makes no difference whatsoever
13:54:27 <dmwit> > msum $ Just 1 : repeat Nothing
13:54:31 <cinema_> sclv, in directoryGroup
13:54:32 <lambdabot>  Just 1
13:54:36 <dobblego> > foldr1 mplus [Nothing,Nothing,Just 3,Nothing,Just 4] ++ repeat Nothing
13:54:37 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
13:54:43 <dmwit> No need to argue, just test it. =)
13:54:47 <sclv_> yep. go on.
13:54:47 <dobblego> > foldr1 mplus $ [Nothing,Nothing,Just 3,Nothing,Just 4] ++ repeat Nothing
13:54:48 <lambdabot>  Just 3
13:54:59 * Baughn is confused
13:55:10 <Cin> > foldr1 mplus $ [Nothing,Nothing,Just 3,Nothing,Just 4] ++ repeat Just 10
13:55:11 <Baughn> @src foldr1
13:55:11 <lambdabot> foldr1 _ [x]    = x
13:55:11 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
13:55:11 <lambdabot> foldr1 _ []     = undefined
13:55:11 <lambdabot>  Couldn't match expected type `t -> [Maybe a]'
13:55:18 <Cin> > foldr1 mplus $ [Nothing,Nothing,Just 3,Nothing,Just 4] ++ repeat (Just 10)
13:55:19 <lambdabot>  Just 3
13:55:23 <cinema_> sclv, the getDirectoryContents function just gives the name of the files, not the path
13:55:28 <dmwit> Cin: (Just x) `mplus` y = Just x -- doesn't look at its second argument
13:55:30 <Cin> > foldr1 mplus $ [Nothing,Nothing,Just 3,Just 4] ++ repeat (Just 10)
13:55:30 <lambdabot>  Just 3
13:55:42 <Cin> ahh cool
13:55:56 <Baughn> Oh, of course. foldr1 passes itself /to mplus/, which doesn't look at its second argument
13:56:00 <dmwit> Cin: In the expansion, this becomes (Just 3) `mplus` {- a fold of an infinite list -}.
13:56:00 <gwern> didn't know agda was written in haskell
13:56:03 <cinema_> sclv, so you have to code:  mapM (newSTMP <$$> (readFile . (combine path)))  intead of just readFile
13:56:08 <dmwit> Cin: right
13:56:09 <Cin> dmwit: aye
13:57:51 <sclv_> ah.. thanks for the heads up! I'll take a look at it when I get home. I was probably doing something silly like testing with the files in the same working directory as the executable...
13:58:19 <sclv_> cinema_++
13:58:45 <cinema_> sclv_, and I have a question: do you intend to implement the indirect lookup, like $bar.(i)$
14:00:25 <Baughn> How do you pronounce "$"? "epea" isn't doing it..
14:00:27 <sclv_> hmm.. the whole grammar should be there.
14:00:28 <cinema_> sclv_: at first I was trying to display a 3 level object ([Database] ... [Table] ... [Column]), but finally I used a fold
14:00:47 <Cin> baughn: apply? :\
14:01:00 <Baughn> Cin: There are /too many/ of those
14:01:01 <sclv_> did you try $bar.($i$)$ ?
14:01:03 <Cin> :P
14:01:37 <cinema_> sclv_: It does not seem to work for this: "Value = $foo:{\n   level 1: $bar.(i)$ $it: {\n      level 2: $it$}$}$"
14:01:53 <dmwit> Baughn: too many?
14:02:18 <cinema_> sclv_: and I think I tried to do  $bar.($i$)$ but it didn't work (I'll try again, though)
14:02:57 <sclv_> I don't want to spam up the channel, but send me some code with yr structure and what you want and I'll play with it tonight...
14:03:56 <cinema_> sclv_: OK, I'll do that (I tried to create an extensive test file, because I didn't know StringTemplate before)
14:04:25 <sclv_> awesome. that's very helpful!
14:04:34 <Baughn> dmwit: In my mind, mostly. $ doesn't act the way I expect apply to act, though it comes close
14:04:39 <cinema_> sclv_: HStringTemplate is very helpful !
14:04:43 <Baughn> dmwit: Thus "epea" - a degeneration of "epip"
14:04:58 <Cin> grrr
14:04:59 <Cin> No instance for (MonadPlus (CGIT IO))
14:05:02 <sclv_> I haven't gotten much feedback from end-users so far, so I'm excited to see people exploring it.
14:05:16 <dmwit> Cin: No instance for MonadPlus IO, what do you expect?
14:05:28 <sclv_> ?instances MonadPlus
14:05:29 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:05:37 <dmwit> bwuh?
14:05:40 <Cin> dmwit: er, n/m
14:05:53 <Baughn> @src IO mplus
14:05:53 <lambdabot> m `mplus` n = m `catch` \_ -> n
14:06:03 <Cin> @hoogle foldM
14:06:05 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:06:05 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
14:06:05 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:06:08 <dmwit> Baughn: Hm. f $ x = f x, so if $ doesn't act the way you expect apply to act, your expectations *may* be broken.
14:06:51 <dmwit> Baughn: I say *may* because if your expectations have to do with fixity or associativity, then it might be reasonable to expect something different.
14:07:03 <Baughn> dmwit: They're tuned to lisp and multi-parameter functions, I expect.
14:07:23 <dmwit> mmm
14:07:42 <dmwit> f $ x y == f (x y) vs f $ x y == (f x) y -- you mean like this?
14:08:17 <Baughn> dmwit: I'd expect apply :: ((a,a) - a) -> (a -> a -> a), but for arbitrary numbers of as..
14:08:36 <Baughn> dmwit: It's nonsense in haskell, but I don't feel like overloading the word
14:08:43 <dmwit> Ah, I see.
14:08:58 <dmwit> Yeah, it's trickier to do the "arbitrary number" bit in Haskell.
14:09:12 <dmwit> The type system is pretty picky about the length of tuples.
14:09:26 <Baughn> It could use lists
14:09:33 <dmwit> But if you know the length ahead of time, you can use "curry" and its relatives as a better name.
14:09:45 <Baughn> In fact, it /does/ use lists, but that still doesn't cover the second part of the type
14:10:33 <Baughn> dmwit: And if I ever found a use for curry, I would. ;)
14:11:03 <Baughn> Still, that leaves me pronouncing $ as "epea"
14:14:52 <Deewiant> what's the right way of closing a process given by "runInteractiveProcess"? I don't like defunct processes :-)
14:15:14 <Baughn> Deewiant: waitForProcess
14:15:16 <Baughn> Or friends
14:16:11 <Deewiant> if the process is such that it keeps on reading stdin until EOF, does that do the trick or do I need to give it EOF somehow as well
14:16:36 <Baughn> Deewiant: http://paste.lisp.org/display/56252 <-- Here, example
14:17:03 <Baughn> Deewiant: waitForProcess will wait until the process exits. If it doesn't do that on its own, then you have to induce an exit when you're done with it.
14:17:07 <Baughn> Deewiant: What is it for?
14:17:37 <Deewiant> it's an interactive program, say ghci
14:17:55 <Baughn> Those will typically exit when they get EOF, yes
14:17:56 <Deewiant> I want to start it, give it a line of input, get the output, and close it
14:18:10 <Deewiant> can I hPutStr EOF somehow?
14:18:10 <Baughn> Then you should probably close the input.
14:18:18 <Baughn> No, just close the handle
14:18:20 <Deewiant> I've done that, but defunct processes are left around
14:18:27 <Baughn> *and* waitforprocess
14:18:28 <Deewiant> maybe the wait will handle it
14:18:34 * Deewiant is trying
14:18:36 <Baughn> If it's defunct, that means it's already exited
14:18:43 <gwern> dagnabit agda, when a darcs get requires a checkpoint and 1651 outstanding patches, you release a new version and do a checkpoint!
14:18:44 <Baughn> And waiting for you to wait
14:18:56 <Deewiant> I see
14:19:02 <Deewiant> and, yes, that seems to have done it, thanks :-)
14:19:24 <Baughn> Deewiant: By the way, if you're doing this to dynamically evaluate haskell code, lambdabot has a much safer (and simpler) runplugs program you can use
14:19:47 <gwern> 600 patches to go...
14:19:57 <Baughn> gwern: At 10kB/s?
14:20:13 <Deewiant> Baughn: yes, I know, that was just an example
14:20:38 <Baughn> The developers claim to have added pipelining recently, and configure claims to have enabled it, but I'm not seeing any improvements. :/
14:20:55 <gwern> Baughn: eh. a few patches a second
14:21:21 <Baughn> gwern: Far below what it should be able to do, unless you're on a modem
14:21:31 <Baughn> Oh well.
14:21:48 <gwern> it might be going over tor
14:21:56 * Baughn blinks
14:26:08 <gwern> @where QuickCheck
14:26:09 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
14:26:57 <sclv_> @tell cinema_ I found the problem. There's a parser issue where it tries to read "bar." as a template application. I'll cook up a fix. In the meantime, (bar).(i) should work for you.
14:26:58 <lambdabot> Consider it noted.
14:27:47 <cinema_> sclv_: I'll try it. In the meantime I am sending you my test file
14:27:47 <lambdabot> cinema_: You have 1 new message. '/msg lambdabot @messages' to read it.
14:30:01 <cinema_> sclv_: Thanks, it works perfectly with (bar).(i)
14:31:15 <sclv_> I introduced that idiocy trying to allow ppl. to use named templates with dots in their names, totally forgetting that the dot is also for selection. Grr...
14:32:50 <cinema_> sclv_: well now I know how to make it work !
14:33:11 <Cin> @pl getAlias l = mapM getInput l >>= return . foldr1 mplus
14:33:11 <lambdabot> getAlias = (foldr1 mplus `fmap`) . mapM getInput
14:33:12 <sclv_> glad to help. :-)
14:33:57 <Cin> gah i wrote that, well, getAlias = fmap (foldr1 mplus) . mapM getInput
14:34:02 <Cin> was just missing the parens :P
14:34:16 <sclv_> regular grammars are hard, let's go etc.
14:34:38 * Cin chortles
14:34:46 <ddarius> If regular grammars are hard, God help us.
14:35:10 <sebell> ... with the irregular ones.
14:35:11 <sclv_> well, keeping them regular is. :-)
14:36:23 <profmakx> o.O
14:36:44 <Cale> gwern: check your email. :)
14:47:54 <ddarius> @pl m >>= return . f
14:47:54 <lambdabot> f `fmap` m
14:48:56 <noige_> d
14:49:02 <noige_> hi
14:50:52 <Cale> noige_: hello
14:51:00 <noige_> Cale: hi
14:53:25 <noige_> fucons [1,2,3] :: (Num t) => [t]
14:54:16 <noige_> that means that fucons [1,2,3] :: is a function that expects type t is a Num and evaluates to a list of t's which are Nums?
14:54:48 <noige_> I guess saying that t's are nums in the list is useless since all list members are the same type
14:54:49 <glen_quagmire> noige_: it means you're applying fucons on [1,2,3] i think
14:54:58 <glen_quagmire> > id [1,2,3]
14:55:05 <lambdabot>  [1,2,3]
14:55:23 <noige_> > :t [1,2,3]
14:55:23 <lambdabot>   parse error on input `:'
14:55:24 <biouser> where there is -> I think it might be like DOMAIN -> RANGE
14:55:28 <noige_> hahaha
14:55:31 <glen_quagmire> > let fucons ([a,b,c]) = a + b + c in fucons [1,2,3]
14:55:31 <biouser> am I worng?
14:55:33 <lambdabot>  6
14:55:52 <noige_> biouser: I am not sure I was laughing at my error
14:57:05 <biouser> noige_, np, you probably should laugh, I am very nub
14:57:27 <noige_> biouser: holy smoke me too
14:57:39 <glen_quagmire> me too
14:57:44 <noige_> biouser: this is a very new way of thinking coming from python and ruby
14:57:54 <biouser> nice, the deaf dumb and blind dancing around
14:57:55 <Cale> biouser: Domain -> Codomain really.
14:58:10 <monochrom> As a first-order understanding, I say that "[1,2,3] :: (Num t) => [t]" means that [1,2,3] is a polymorphic list, i.e., its type is not completely nailed down yet.  You still have the leeway to specialize it to a specific type, e.g., [Integer], [Double], ...  The requirement is that you choose a Num type for t, e.g., Integer or Double works.
14:58:13 <Cale> (the function isn't required to take on every value of the codomain type)
14:58:54 <glen_quagmire> > let f 1 = 1; f 2 = "1" in f 1
14:58:55 <lambdabot>   add an instance declaration for (Num [Char])
14:58:55 <lambdabot>     In the expression: 1
14:58:55 <lambdabot>     I...
14:59:10 <monochrom> You can't return "a number or a string".
14:59:14 <biouser> nice, Cale
14:59:59 <monochrom> More choices for t are available. In fact...
15:00:33 <ddarius> @instances Num
15:00:38 <lambdabot> Double, Float, Int, Integer
15:00:52 <monochrom> > let {xs :: Num t => [t]; xs = [1,2,3]} in (xs :: [Integer], xs :: [Double], xs :: [Rational], xs :: [Complex Double])
15:00:54 <lambdabot>  ([1,2,3],[1.0,2.0,3.0],[1%1,2%1,3%1],[1.0 :+ 0.0,2.0 :+ 0.0,3.0 :+ 0.0])
15:01:03 <ddarius> @instances-importing Data.Ratio Data.Complex Num
15:01:04 <lambdabot> Complex a, Double, Float, Int, Integer, Ratio a
15:01:19 <Cin> so i'm building a page with Text.XHtml.Strict. i want to build most of the page, and time how long it takes to do that, which i've done, but then i want to insert the time it took -into- the page. i'm considering something where instead of showHtml returning a string, it returns a function that takes a string and appends some more source into that string, a la showS
15:02:00 <monochrom> Text.XHtml seems to be infectious these few days :)
15:02:07 <Cin> ;D
15:02:54 <Cin> > showHtml $ p << "test?"
15:02:55 <lambdabot>   Not in scope: `<<'
15:02:57 <monochrom> Html is an instance of Show.  Does that help?
15:02:58 <Cin> dang
15:03:03 <gnuvince_> :T (%)
15:03:10 <gnuvince_> :t (%)
15:03:10 <monochrom> use :t
15:03:11 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
15:03:31 <monochrom> 2%5 means "2 fifths"
15:03:37 <Cale> biouser: another thing is that -> associates to the right
15:03:50 <Cin> monochrom: doesn't seem to be an instance of Show
15:04:12 <Cale> biouser: So if you have a function A -> B -> C, that means the same as A -> (B -> C), that is, it takes a value of type A, and gives a function of type B -> C
15:04:20 <monochrom> Haddock must be lying!
15:04:31 <Cale> biouser: This is how we handle multiple parameters in general in Haskell :)
15:04:55 <Cin> monochrom: ah so it is. didn't see it there
15:05:05 <Cin> monochrom: does it help?
15:05:33 <monochrom> My only worry is that the actual output of its Show code is unsatisfactory.
15:07:37 <biouser> Cale, can you have the ()?
15:07:46 <ddarius> biouser: Sure.
15:09:13 <Cin> @src ShowS
15:09:14 <lambdabot> type ShowS = String -> String
15:09:50 <Cale> biouser: You mean an empty tuple?
15:10:03 <Cale> biouser: Oh, or adding the parens yourself? Sure.
15:11:08 <biouser> yeah, I didn't mean empty tuple... just might be a little hard to remember some of the order of operations things without making them explicit to myself
15:11:52 <Cale> ah
15:11:56 <ddarius> biouser: In this case, you shouldn't really be "memorizing" the precedence and associativity.
15:12:41 <Cale> In this particular case, the associativity should come pretty naturally after a while. You write functions of multiple parameters, giving them types like: A -> B -> C
15:12:52 <Cale> and you're permitted to partially apply them
15:13:07 <Cale> So if you apply such a function to just a value of type A, then you're left with a function B -> C
15:13:24 <Cale> (and then you apply that to a value of type B, and you're left with a value of type C)
15:14:00 <Cale> To maintain this illusion, function application associates to the left. That is, when you write:
15:14:02 <Cale> f x y
15:14:07 <Cale> You really mean:
15:14:11 <Cale> (f x) y
15:14:46 <ivan_> @unmtl StateT r (ErrorT a IO) q
15:14:46 <lambdabot> r -> IO (Either a (q, r))
15:15:56 <Cale> hmm
15:17:37 <Cale> :t \s x -> runErrorT (runStateT x s)
15:17:39 <lambdabot> forall s e (m :: * -> *) a. s -> StateT s (ErrorT e m) a -> m (Either e (a, s))
15:20:10 <Cale> runErrorT (runStateT (do x <- get; y <- liftIO readLn; if x == y then liftIO (putStrLn "you win!") else throwError "boo!") 0)
15:24:18 <ivan_> @unmtl ErrorT r IO q
15:24:19 <lambdabot> IO (Either r q)
15:25:02 <ivan_> @unmtl ErrorT r IO a
15:25:02 <lambdabot> IO (Either r a)
15:25:13 <Cale> You can work out the unmtl result by composing the run functions for the transformers.
15:25:15 <ivan_> @unmtl ErrorT (q,r) IO a
15:25:15 <lambdabot> IO (Either (q, r) a)
15:25:34 <Cale> :t runErrorT
15:25:35 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
15:26:41 <Cale> In general, when you use monad transformers, it's a really good idea to newtype the resulting monad, and use newtype deriving to derive instances of Functor and Monad, along with some or all of the classes you want (like perhaps MonadError e, or MonadState s)
15:27:02 <ivan_> @unmtl StateT r (ErrorT (q,r) IO) a
15:27:02 <lambdabot> r -> IO (Either (q, r) (a, r))
15:27:08 <Cale> You then write the composed run function for your newtyped monad
15:27:39 <Cale> This also gives you a new power to hide the implementation of the monad, and restrict the use of the operations in various ways.
15:28:14 <Cale> For example, in your composed State/Error monad there, you could decide that you want to throw an error automatically if the state gets set to something invalid (for some idea of validity)
15:28:35 <ivan_> Cale: how do i think when i program with monads, which functions am a able to perform, and what do i have to think on, when working with abstract types
15:29:16 <Cale> Well, do you know what a combinator library is, generally?
15:29:27 <Cale> (I'm happy to explain)
15:29:50 <ivan_> yes go for it =) is it the library when i do :brows in ghci
15:30:04 <faxathisia> dolio, nice! Very succinct proof
15:30:34 <Cale> A combinator library is a library whose API is rich enough that it looks like a small programming language. It consists of a bunch of primitive computations, together with some ways to join those computations together into larger ones.
15:31:02 <Cale> For example, a parser combinator library would consist of some primitive parsers for parsing single characters perhaps, and then ways to combine those (concatenation, alternation, etc.)
15:31:25 <Lemmih> Yay, HAppS is finally available on hackage.
15:32:01 <Cale> A drawing combinator library would define some primitive drawings (lines, shapes, etc.) and then ways to compose drawings together into larger ones (putting one atop another, replacing parts of one drawing with another, etc.)
15:32:36 <Cale> A monad is a particular kind of combinator library which supports, as a subset of its API, the monad operations, return and >>=
15:32:51 <ivan_> the monad laws right?
15:33:00 <Cale> Yeah, and they have to satisfy the monad laws.
15:33:19 <Cale> This is convenient, because it means we get a library of stuff which works in any monad.
15:33:51 <Cale> So once you know that your library is a monad, it's like it's half-done already, because of all the control structures you inherit from Control.Monad
15:34:57 <Cale> Monad transformers take monads and wrap them up in a way that adds some additional primitives, together with a function 'lift' that turns operations in the original monad into operations in the new one.
15:35:17 <Cale> Effectively, you get all the functionality of the original monad (hopefully), together with some new operations.
15:35:26 <ivan_> okay stop there
15:35:28 <ivan_> =)
15:35:38 <ivan_> how do i know when to use the lift ?
15:36:11 <Cale> The MTL unfortunately makes lift a little bit confusing. It defines lots of instances so that you don't have to lift explicitly sometimes.
15:36:43 <Cale> But mostly, you have to lift anything which the monad transformer didn't add to your monad.
15:37:03 <ivan_> so how do i know what it didn't add?
15:37:10 <Cale> That is, all computations in the original monad have to have lift applied to them to work in the transformed monad.
15:37:37 <Cale> Sometimes you can get away without it, because there are instances which look like, for instance:
15:38:08 <Cale> instance (MonadState s m) => MonadState s (ReaderT r m a) where
15:38:13 <Cale>    get = lift get
15:38:26 <Cale>    put s = lift (put s)
15:39:10 <Cale> (Does that make sense?
15:39:11 <Cale> )
15:39:19 <ivan_> so when i wrap a monad and start programming am i in the inner state or the outer?
15:39:45 <Cale> Let's take a concrete example...
15:39:49 <ivan_> if i for example have StateT q (ErrorT a IO) p
15:39:55 <Cale> okay
15:40:35 <Cale> Then you have get and put
15:40:40 <Cale> The MonadState operations
15:40:55 <Cale> and everything else really ought to be lifted
15:40:56 <Cale> but
15:41:02 <ivan_> because i have the instance, but if i didn't have it?
15:41:09 <Cale> There's an instance which lifts the Error operations
15:41:26 <Cale> So you don't have to lift those
15:41:32 <Cale> (throwError, etc.)
15:42:18 <Cale> If you didn't have that instance, you'd have to use  lift (throwError "foo")
15:42:30 <Cale> The IO operations won't be lifted automatically.
15:42:44 <Cale> You have to apply lift once to bring them into ErrorT a IO
15:42:54 <Cale> and then again, to lift them to your full monad
15:43:04 <ivan_> okay and the type declaration if i define P q r t = StateT r (ErrorT a IO) q then later on i can create a function that returns P r t q, how does that work?
15:43:08 <Cale> To save this multiple lifting of IO operations, there's a class MonadIO
15:43:17 <Cale> which defines a liftIO operation you can use
15:43:55 <Cale> Well, the same as returning StateT r (ErrorT a IO) q
15:44:05 <Cale> But what you really want is:
15:44:06 <ivan_> okay so from the type declaration you are moving from the outer to the inner ?
15:44:44 <Cale> newtype MyMonad s e a = StateT s (ErrorT e IO) a
15:45:03 <Cale>   deriving (Functor, Monad, MonadError e, MonadState s, MonadIO)
15:45:27 <Cale> You can optionally leave out some of that functionality, and write the operations yourself.
15:45:39 <Cale> (which hides the way that the monad is built up)
15:45:46 <Cale> Also, you'll want:
15:46:25 <Cale> runMyMonad :: MyMonad s e a -> s -> IO (Either e (a,s))
15:46:40 <Cale> er, oops
15:46:46 <Cale> newtype MyMonad s e a = MM (StateT s (ErrorT e IO) a)
15:46:55 <Cale> Forgot the newtype data constructor
15:47:06 <Cale> runMyMonad :: MyMonad s e a -> s -> IO (Either e (a,s))
15:47:21 <Cale> runMyMonad (MM x) s = runErrorT (runStateT x s)
15:47:34 <Cale> I believe that's right.
15:48:08 <blargeyfarg> cale: can you explain the reasoning behind deriving Functor?
15:48:18 <Cale> blargeyfarg: This is so that fmap will work.
15:48:55 <Cale> Specialised to this type,  fmap :: (a -> b) -> MyMonad s e a -> MyMonad s e b
15:49:15 <Cale> In general,  fmap :: (Functor f) => (a -> b) -> f a -> f b
15:49:27 <Cale> It tends to be quite useful.
15:49:33 <blargeyfarg> cale: makes sense.  thanks
15:50:00 <ivan_> how is it a about defining later a function fun :: s -> MyMonad e s a ? is it possible to swich the types ?
15:50:11 <olsner> hmm, I want to learn monad transformers... but I need a project to apply them to, and for that I need to know where to apply monad transformers, and for that I need to know monad transformers
15:50:43 <LoganCapaldo> I saw a monad at work today
15:50:50 <LoganCapaldo> or at least it should've been one
15:50:58 <LoganCapaldo> MaybeT Writer
15:51:25 <LoganCapaldo> (or it might've been WriterT Maybe)
15:51:45 <olsner> something producing lists of maybe's on the side?
15:52:06 <blargeyfarg> olsner: it's a general enough concept for examples to be just about everywhere.  for example, not but a few moments ago, wrapped an io monad with a Reader to hide a slew of environment values that i was explicitly passing around in a particular portion of a project
15:52:24 <Cale> ivan_: hm?
15:52:28 <LoganCapaldo> naw it was writering something out where each write out part could fail
15:52:49 <Cale> ivan_: The type variables are arbitrary letters, but their position is important.
15:52:59 <Cale> ivan_: You could swap the order in the newtype declaration
15:53:00 <LoganCapaldo> it looked like writething(g) && writeotherthing(g) && writesomeotherhting(g) && ...
15:53:21 <faxathisia> LoganCapaldo, heh
15:53:36 <Cale> newtype MyMonad e s a = MM (StateT s (ErrorT e IO) a)
15:53:36 <Cale> like that
15:53:36 <Cale> But then you'd have to swap the order in the run function and everywhere else too.
15:53:47 <Cale> It's crucially important that the 'a' here be last though.
15:54:00 <Cale> This is because the instance of Monad and Functor depends on that.
15:54:12 <Cale> It's really (MyMonad e s) which is an instance of Monad
15:54:32 <Cale> (that is, the type constructor)
15:55:27 <olsner> hmm, I think I did write a parser that was some combination of Maybe Reader and State monads, but got stuck in deciding whether to monad transformationate or use a real parser
15:55:37 <olsner> and ended up not working on that project for a while
15:56:11 <ivan_> so if i want to define a function which take a e -> myMonad e s a , is this possible?
15:56:42 <Cale> ivan_: What would the function do? Throw an error?
15:57:14 <Cale> There's throwError, which you'll already have as a result of the instance of MonadError
15:57:34 <ivan_> depends on the input to the monade, maybe an error or a return from the ErrorT
15:58:45 <ivan_> for example :: e -> MyMonad e s a
15:58:58 <ivan_> do x:xs <- get
15:59:06 <ivan_> case x of
15:59:21 <sclv> while we're on the subject, if I have [MonadWriter (Maybe a)] and want to extract the first Just *and* only have the writer side effects of the action that produced that Just, is there a nice way to do it?
15:59:35 <ivan_> (R _ ) -> put xs
15:59:51 <sclv> The actual case is [CGI (Maybe a)] but CGI is just a composed Writer and Reader...
16:00:22 <wli> I did something like CounterT once; newtype CounterT m t = CounterT { runCounterT :: StateT Integer m t } ; instance MonadState s m => MonadState s (CounterT m) where { get = lift get ; put = lift . put } ; class Monad m => MonadCounter m where tick :: m Integer ; instance Monad m => MonadCounter (CounterT m) where tick = CounterT { runCounterT = do { n -> get ; modify (+1) ; return n } ; evalCounterT = flip evalStateT 0 . runCounterT
16:00:46 <sclv> oerjan helpfully pointed out this morning that my current solution, msum <$> sequence (sorta) preserves side effects.
16:01:03 <ivan_> Cale: how do i know what my monad must return?
16:01:24 <Cale> ivan_: What it must return?
16:01:33 <Cale> Your monad is a type...
16:01:39 <Cale> Well, a type constructor.
16:01:44 <olsner> @type (msum <$>)
16:01:55 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, MonadPlus m) => f [m a] -> f (m a)
16:02:02 <Cale> bbiab
16:02:12 <wli> Well, I did deriving (Functor, Monad, MonadPlus, ...) for the CounterT def, which I omitted there.
16:03:20 <sclv> ?ty \x -> msum <$> sequence x
16:03:21 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Monad f, MonadPlus m) => [f (m a)] -> f (m a)
16:04:31 <sclv> but yeah, the sequence executes and preserves the side effects before the msum narrows the results.
16:05:05 <wli> I wonder why not join . (msum <$>) . sequence
16:05:24 <hpaste>  (anonymous) pasted "code" at http://hpaste.org/5828
16:05:45 <ivan_> Cale: i posted the code above
16:06:19 <sclv> ?ty join . (msum <$>) . sequence
16:06:20 <lambdabot> forall (m :: * -> *) a. (Functor m, MonadPlus m) => [m (m a)] -> m a
16:06:33 <sclv> don't see how that would help?
16:06:57 <wli> Unraveling two nested monads is typically a PITA.
16:07:35 <ivan_> is it possible to do this? if it is an Ans i want it to return the answertype a and put the rest of the list to the State, if the list is empty i want to throw an error
16:08:00 <sclv> I'm open to all sorts of solutions here -- using ContT, whatever. Just need to throw away the offending side effects.
16:08:20 <faxathisia> @free swap
16:08:21 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `swap'\n\n"
16:08:34 <faxathisia> @free (\(x,y)->(y,x))
16:08:34 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
16:08:42 <faxathisia> @let swap (\(x,y)->(y,x))
16:08:43 <lambdabot>  Parse error
16:08:48 <faxathisia> @let swap=(\(x,y)->(y,x))
16:08:49 <ddarius> @free swap (x,y) = (y,x)
16:08:49 <lambdabot> Extra stuff at end of line
16:08:50 <lambdabot> Defined.
16:08:58 * wli wonders if ContT would clean up the messes he so often creates by using ErrorT to return exceptional successes.
16:09:01 <faxathisia> @free swap
16:09:02 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `swap'\n\n"
16:09:02 <ddarius> Er, you want the type
16:09:08 <wli> @type flip (,)
16:09:09 <lambdabot> forall a b. b -> a -> (a, b)
16:09:09 <ddarius> @free (a,b) -> (b,a)
16:09:09 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
16:09:15 <faxathisia> @let flip
16:09:16 <olsner> @free
16:09:16 <lambdabot>  Parse error
16:09:16 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
16:09:20 <faxathisia> @free flip
16:09:21 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
16:09:24 <faxathisia> \o/
16:09:27 <faxathisia> thanks
16:09:33 <ddarius> @free f :: (a,b) -> (b,a)
16:09:33 <lambdabot> $map_Pair h g . f = f . $map_Pair g h
16:09:37 <ddarius> There we go.
16:09:39 <faxathisia> add
16:10:18 <wli> @type uncurry $ flip (,)
16:10:19 <lambdabot> forall a b. (a, b) -> (b, a)
16:10:40 <ivan_> @unmtl StateT r (Error (q,r) IO) a
16:10:40 <lambdabot> r -> Error (q, r) IO (a, r)
16:10:48 <ivan_> @unmtl StateT r (ErrorT (q,r) IO) a
16:10:48 <lambdabot> r -> IO (Either (q, r) (a, r))
16:10:50 <faxathisia> "All polymorphic functions in functional programming are natural transformations"
16:10:58 <faxathisia> Is this how free makes theorems?
16:11:46 <sclv> @unmtl ErrorT (StateT r IO) a
16:11:46 <lambdabot> err: `ErrorT (StateT r IO) a' is not applied to enough arguments, giving `/\A. a (Either (StateT r IO) A)'
16:12:27 <sclv> @unmtl ErrorT e (StateT r IO) a
16:12:28 <lambdabot> r -> IO (Either e a, r)
16:12:39 <ivan_> @unmtl ErrorT (q,r) (StateT r IO) a
16:12:39 <lambdabot> r -> IO (Either (q, r) a, r)
16:13:08 <sclv> we really need a nice haskellwiki page listing various compositions of monad transformers and their behaviors.
16:13:23 <sclv> it always seems nonobvious what preserves side effects and how.
16:13:28 <ddarius> faxathisia: Figuring out the naturality equations would give you the free theorems, though free theorems come from a relational approach.
16:13:43 <ivan_> @unmtl ErrorT q (StateT (q,r) IO) a
16:13:43 <lambdabot> q -> r -> IO (Either q a, q, r)
16:14:05 <ivan_> @unmtl ErrorT q (StateT r IO) a
16:14:05 <lambdabot> r -> IO (Either q a, r)
16:14:08 * sclv furiously hints to some competent party that has the inspiration and a few hours to spare.
16:15:20 <ddarius> @free fix
16:15:21 <lambdabot> f . g = h . f => f (fix g) = fix h
16:17:56 <Cale> ivan_: There's something seriously wrong with your type synonym.
16:18:07 <Cale> ivan_: The a has to be the result type
16:18:35 <Cale> Er, I suppose it doen't *have* to be
16:18:44 <Cale> (since it's only a type synonym)
16:18:50 <Cale> But it's very strange that way
16:19:01 <Baughn> ddarius: ..wha?
16:19:34 <Baughn> @free const
16:19:34 <lambdabot> f . const x = const (f x) . g
16:20:23 <Baughn> ..undoubtedly true, yet the g seems frivolous
16:20:56 <ddarius> Baughn: The g means, no matter what you do to the second input the result is still the same.
16:21:32 <Baughn> ddarius: For the const, yes. The fix, I'm having a hard time wrapping my head around.
16:22:02 <ddarius> Baughn: One way to see it is to view the antecedent as saying when you push an f "through" a g you get an h.
16:22:40 <ddarius> Then f (fix g) = f . g . g . g . g . g . g ... = h . f . g . g . g ... = h . h . h . h . h . h . h ...
16:22:59 <Baughn> ddarius: ..I'll have to try that again once I've slept.
16:25:36 <ivan_> Cale: but what if my a is of type r
16:30:43 <Cale> ivan_: hm?
16:31:03 <ivan_> Cale: sorry i see what you mean now, stupid of mee :/
16:31:49 <ivan_> that explains why there was a bunch or error of the type q
16:32:52 <ivan_> @unmtl StateT r (ErrorT q IO) a
16:32:53 <lambdabot> r -> IO (Either q (a, r))
16:33:31 <ivan_> @unmtl StateT r (ErrorT (q,r) IO) a
16:33:31 <lambdabot> r -> IO (Either (q, r) (a, r))
16:45:39 <ivan_> is it possible to get a string from IO () ? like if i have a IO a for instance putStrLn "lol" can a read back the "lol"
16:46:44 <Stinger> no
16:47:16 <liyang> shapr: *pong*?
16:50:26 <Cale> ivan_: No, values of type (IO a) are completely opaque. You can't tell them apart in any way, only run them.
16:51:23 <Cale> This isn't actually necessary -- it would be possible to have a system in which IO values were observable, but it would use type system features which are relatively new compared to the IO monad itself.
16:52:19 <Cale> (and even then, there would be limits on how observable they are, since the right parameter of a bind is a function, and those had best not be observable)
16:53:42 <Cale> It would be rather cool however, in that you could write functions which took IO actions as parameters, and ran them stepwise, auditing the IO primitives which they used.
16:56:03 <faxathisia> @free either
16:56:07 <lambdabot> g . k = p . f => g . q = f1 . h => g . either k q = either p f1 . $map_Either f h
16:59:22 <shapr> liyang: gtk2hs debs seem broken to me, am I missing something? I can't install them.
17:01:07 <bos> @hoogle par
17:01:07 <lambdabot> GHC.Conc.par :: a -> b -> b
17:01:07 <lambdabot> Control.Parallel.par :: a -> b -> b
17:01:07 <lambdabot> Data.List.partition :: (a -> Bool) -> [a] -> ([a], [a])
17:05:16 <ivan_> Cale: if i have a funk that returns monadic type R q r r and i want in that function to exec something that returns R q r a can a do that?
17:05:45 <Cale> yes
17:06:05 <Cale> Consider the type of >>=
17:06:08 <Cale> :t (>>=)
17:06:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:06:21 <Cale> (which is implicit in do-notation)
17:06:26 <ivan_> can i use >>
17:06:42 <Cale> Sure, if you'd prefer to ignore the result of the first computation.
17:06:56 <Cale> You can also just use do-notation.
17:07:14 <ivan_> do{fun1; fun2}
17:07:16 <ivan_> ???
17:08:17 <Cin> yes.
17:12:21 <Cale> I totally don't understand what Alan means about Four Calendar Cafe. The songs sound pretty straightforward in either case. Maybe it's just that I listen to way too much Frank Zappa and Wayne Krantz and weirdos like that. Pop music sounds uninteresting now :)
17:13:10 <dons> apparently reddit didn't understand either
17:14:17 <Cin> who's doing some haskell web dev? :-D
17:14:29 <dons> lots of people!
17:14:36 * Cin claps^__^
17:14:49 <liyang> shapr: ah. er... nomeata's taking care of it these days. I'm not sure what's going on. D:
17:14:51 <LoganCapaldo> web dev is booooring
17:15:01 <Cin> web dev is boring, let's go shawping
17:18:31 <wli> Cale: Endless instances of 3/4 and 4/4 time get monotonous compared to, say, 22/49.
17:18:48 <Cale> Indeed.
17:19:02 <Cale> And the same old chords over and over and over.
17:19:39 <Cale> There are a combinatorially large number of possible songs! Play something new already!
17:20:26 * dmwit plays two songs at once, instantly making something new
17:20:28 <wli> Cale: There's actually some table of statistics about "hit songs" for the chords and/or chord progressions to use. Vocals have been analyzed similarly, though it's more complex.
17:20:34 <Cin> cale: have you heard the Secret Agent stream from SomaFM? :P some great old tracks on that
17:21:16 <blargeyfarg> anyone notice the build failure on hackage with plugins-1.0?
17:21:31 <wli> Cale: There's probably a way to generate musical compositions based on those rules.
17:21:38 <dcoutts_> blargeyfarg: the plugins-1.0 on hackage is borked
17:21:43 <Cale> At one point, my friend and I were accidentally listening to two songs at the same time and didn't notice until he mentioned that it was rather good and asked what we were listening to and I realised that I had two music players open.
17:21:56 <olsner> hmm, why is the non-borked plugins package not on hackage?
17:22:19 <dcoutts_> olsner: very good question
17:22:31 <Cale> Cin: nope -- SomaFM?
17:22:48 <Cin> cale: online streaming radio server. serves a few streams
17:22:52 <dcoutts_> olsner: it'd be especially nice if the people uploading poackages that dep on plugins would make sure there was a working version
17:23:02 <dcoutts_> eg, perhaps whoever uploaded lambdabot :-)
17:23:59 <SamB> build slaves, anyone?
17:27:36 <ivan_> is there a function that checks the type of a variable?
17:28:04 <faxathisia> ivan_: No
17:28:10 <blargeyfarg> ghc?
17:28:16 <yondalf> ivan_: in ghci you could use :t though
17:28:19 <yondalf> :t 1
17:28:21 <lambdabot> forall t. (Num t) => t
17:28:25 <yondalf> :t "Hello"
17:28:26 <lambdabot> [Char]
17:28:30 <lament> ivan_: if you don't know the type of a variable, something's really wrong
17:28:58 <lucca-> ivan_: perhaps you want to match ?
17:29:56 <ivan_> yes? is there any function?
17:30:16 <faxathisia> ivan_: any function that does what?
17:30:20 <Rtfum-aF> AAalleriaAA AAalatterRR AAaleator___ FFfelipeEE
17:30:28 <lucca-> you don't need a function to match tags
17:31:49 <pjd> > case 2+3 of 5 -> "fnord"
17:31:51 <lambdabot>  "fnord"
17:31:57 <pjd> ivan_: that?
17:32:28 <Cale> Rtfum-aF: are you okay?
17:32:30 <Rtfum-aF> AAacCC AAacuraAA HHhaskellsocialnetTT
17:32:37 --- mode: ChanServ set +o Cale
17:32:45 <Cin> silly spammers
17:32:54 <faxathisia> Cale, It's not GHC linker error?
17:33:04 --- mode: Cale set +b *!i=ircap*@*
17:33:06 <ivan_> i want somehow save an IO Int to a string and later on make use of read to transforme it back to an int
17:33:07 <faxathisia> 'AAalleriaAA AAalatterRR AAaleator___ FFfelipeEE' looks a bit like one..
17:33:50 <faxathisia> :t do print "test" ; return 1
17:33:50 <Cale> ivan_: You want to save an action for producing an integer to a string?
17:33:52 <lambdabot> forall t. (Num t) => IO t
17:34:09 <Cale> ivan_: Or do you only want to save its result, after running it?
17:34:31 <faxathisia> ivan_: Why go through a string at all?
17:34:44 <ivan_> yup save its result like timeGet is of type IO Int, i want to save its output
17:35:08 <pjd> t <- timeGet
17:35:17 <ivan_> if i run do x <- putStrLn "sda" what does the x contain?
17:35:22 <pjd> (in a do block)
17:35:26 <SamB> ()
17:35:26 <faxathisia> :t putStrLn
17:35:28 <lambdabot> String -> IO ()
17:35:29 <gwern> Cale: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ArrayRef-0.1
17:35:31 <lambdabot> http://tinyurl.com/2zxc52
17:35:36 <faxathisia> as SamB said
17:35:37 <pjd> that will unwrap the IO () to ()
17:35:46 <ivan_> ahaa so i will have a string of "()"
17:35:55 <gwern> what a fondness Bulat has for extensions. just switching from OPTIONS to LANGUAGE pragmas took me half an hour
17:35:58 <pjd> no, not a string;  an actual ()
17:36:00 <faxathisia> ivan_: Where are you getting the idea of strings ?
17:36:10 <pjd> you can apply show to it to get "()", though
17:36:29 <blargeyfarg> ivan_: putStrLn takes a string as input, but you get back the empty tuple in return.  your string is eaten
17:36:43 <ivan_> can i show ()
17:36:44 <Cale> gwern: Does the haddock fail? I noticed bits of haddock in the code, but perhaps it's not completely filled out.
17:37:23 <pjd> > show ()
17:37:25 <lambdabot>  "()"
17:37:42 <ivan_> =) there is the string =) just what i wanted
17:37:43 <ivan_> thx
17:37:52 <pjd> ivan_: why do you want a string?
17:37:55 <faxathisia> ivan_: Why go through a string at all?..
17:37:58 <blargeyfarg> ivan_: in what way is that useful?
17:38:00 <gwern> Cale: yes, it does
17:38:25 <gwern> Cale: something about the class type signatures in GHC/Unboxed.hs
17:38:34 <gwern> damages the parsing
17:38:40 <Cale> hmm
17:39:04 <ivan_> i have to save the state somehow, how can i save a bunch of IO states into a list?
17:39:30 <Cale> ivan_: a bunch of IO states?
17:39:46 <pjd> ivan_: maybe explain what you're trying to do from the beginning :)
17:39:52 <ivan_> not the states but there result
17:40:02 <Cale> ivan_: You can put a bunch of IO computations in a list. But the state of an IO computation is the entire state of your computer and the rest of the world.
17:40:03 <pjd> pasting some code on hpaste will probably help
17:40:09 <Cale> Oh
17:40:20 <gwern> ...gmail won't let me attach my tarball because it has an executable file in it?
17:40:23 <Cale> So you want to run a bunch of IO actions and record their results in a list?
17:40:29 <Cale> :t sequence
17:40:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:40:57 <Cale> That'll turn a list of IO actions into a single action which when run, will give a list of the results of running each.
17:41:14 <Cale> gwern: strange.
17:42:34 <ivan_> the problem is that from executing a program with func lifter :: IO a -> m q r a and ask :: q -> m q r r, i have to execute the program, if there is an ask and then ansver is not in the list the program has to stop
17:42:37 <SamB> gwern: does it have a .bat or .cmd file?
17:42:56 <gwern> don't think so
17:43:12 <gwern> oh, it does have two .cmds
17:43:15 <ivan_> next time i run the program it has to rememeber all the other lift actions it preformed like gettime, i dont want to get a new time i want to use the old value
17:43:28 <SamB> really, they ought to stop doing that to tarballs...
17:43:35 <gwern> well, let's see if I can go through smtp first, maybe it's just their web interface
17:43:53 <dmwit> ivan_: Have you had a look at how WASH does it?
17:44:11 <ivan_> nopp what is WASH
17:44:19 <gwern> 'ssmtp: 552 5.7.0 Illegal Attachment 24sm333358ugf.22' <-- bleh
17:44:31 <dmwit> ivan_: They do almost exactly what you're talking about; they build a "log" of answers to IO actions, then on a second run, they replay the log, if it's available.
17:44:45 <dmwit> ivan_: You might be able to adapt their approach to whatever you're doing.
17:45:29 <blargeyfarg> is there a general record serialization/deserialization library available?
17:45:30 <ivan_> ohhh, this is done for education, to learn =) so i can finish mine aproach and then look at that one =)
17:45:57 <BMeph> gwern: GSpace can handle executables, so maybe just throw another wrapper of "compression" on it. :)
17:46:04 <faxathisia> blargeyfarg: Other than deriving (Read, Show) ? I don't think so
17:46:04 <mux> can I expect GHC.Ptr.Ptr to be the same thing as the Ptr type from the FFI?
17:46:15 <ivan_> dmwit: what does wash stand for?
17:46:23 <wli> blargeyfarg: Binary/Typeable/etc.
17:46:30 <dmwit> Web Authoring System in Haskell?  or something
17:46:44 <SamB> mux: it shouldn't be anything else...
17:46:52 <wli> blargeyfarg: Read/Show do rather well most of the time, though, and need no special libs etc.
17:46:54 <ddarius> @where wash
17:46:54 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
17:47:23 <blargeyfarg> wli, faxathisia: somewhere inside i already knew that ;)  thanks
17:47:24 <mux> SamB: thanks, just making extra sure :)
17:47:54 <ivan_> dmwit: that looks like a big project =) mine will not bee that good =P
17:48:00 <gwern> dmwit: and make it a .gz.gz? that's just silly!
17:48:13 <dmwit> gwern: eh?
17:48:39 <BMeph> gwern: Heck, Google Documents imports Excel files! Refusing a tarball for an executable sounds kind of dumb, considering... ;p
17:48:58 <SamB> BMeph: yes but it loses most of the excel stuff
17:49:06 <dmwit> gwern: http://www.maximumcompression.com/selfgz.gz
17:49:12 <SamB> including scripts, charts...
17:49:15 <dmwit> gwern: Try unpacking it. ;-)
17:49:30 <BMeph> SamB: Hmm, still sounds dumb.
17:49:44 <SamB> it's dumb in a completely different way though
17:49:48 <SamB> but tars?
17:49:51 <SamB> come ON!
17:50:28 <faxathisia> dmwit, lol
17:50:36 <SamB> actually I think they should allow you to get that change if you can convince google that you know how to operate a computer properly
17:51:31 <dmwit> A gzip quine is high on my list of awesome things. =)
17:52:11 <olsner> gzip quine? holy shit that's awesome!
17:52:23 <faxathisia> How is it done?
17:52:42 <SamB> it has the added advantage that if the client somehow ends up decompressing it due to server misconfiguration, it won't damage the file ;-)
17:52:44 <monochrom> > let x = gzip x in x
17:52:46 <lambdabot>   Not in scope: `gzip'
17:52:58 <dmwit> I'm not sure, but I think there's a description on maximumcompression.com under the "fun" section.
17:53:28 * gwern gunzips the selfgz.gz a few times. it's just a nonsense text file :(
17:53:51 <gwern> the end product, that is
17:54:01 <faxathisia> my computer uncompresses it in a loop
17:54:08 <LoganCapaldo> a gzip quine would be a fixpoint of gzip, wouldn't it?
17:54:12 <faxathisia> You have to kill the proccess
17:54:34 <gwern> dunno. I have to gunzip it a few times, but it does unzip in the end
17:54:54 <ddarius> LoganCapaldo: That's by definition.
17:55:06 <pjd> http://groups.google.com/group/comp.compression/browse_thread/thread/c57c322e15c782aa/350d9fb166fdf11f
17:55:07 <faxathisia> (does every compression method have a fixedpoint?)
17:55:08 <lambdabot> Title: gzip decompression quine - comp.compression | Google Groups, http://tinyurl.com/2hlyuw
17:55:19 <LoganCapaldo> ddarius: just making sure I knew my defintions :)
17:55:53 <faxathisia> ahhh
17:55:58 <faxathisia> pjd, awesome
17:56:06 <roconnor> quicksort is in place, or otherwise there is not difference between treesort and quicksort.
17:56:12 <roconnor> Cale: ^^
17:56:37 <olsner> gwern: but the unpacked selfgz.gz is binary equal to selfgz.gz, so how could it end up producing a text file?
17:56:55 <chadz> hey -- I'm trying to coerce this damned lighttpd into serving some haskell fcgi code, yet it just hangs when I try accessing it.
17:57:20 <LoganCapaldo> gwern has a magic gzip :)
17:57:22 <Cale> roconnor: I suppose there is no difference then.
17:57:35 <chadz> i was wondering if anyone with success could post their lighttpd config for me to peruse.
17:57:38 <roconnor> why do they have different wikipedia entries then :P
17:57:40 <Cale> roconnor: The description is slightly different, but they're the same algorithm.
17:57:58 <dmwit> LoganCapaldo: ...by which you mean, a buggy gzip. =P
17:58:04 <roconnor> Cale: well at least you are consistent
17:58:20 <Cale> Treesort constructs a binary search tree and then flattens it.
17:58:46 <roconnor> Haskell's ``quicksort'' constructs a binary tree of thunks, and then flatens it.
17:58:46 <gwern> lies!
17:58:47 <gwern> gwern@localhost:1018~>gunzip selfgz.gz                                                                                              [ 8:58PM]
17:58:50 <gwern> gwern@localhost:1019~>cat selfgz                                                                                                    [ 8:58PM]ððÿÿÿÿÿq¡\áÿÿÿÿÿq¡\áÿÿÿÿÿÿÿÿÿÿÿÿÿÂ&`ëÿÿÿÿÿÂ&`ëÿÂ&`ëÿ 5(1234³À,ëÿ³À,ëÿB!ÄÿÿCJM!ÒB!ÄÿÿCJM!Ò%
17:59:02 <Cale> Quicksort is the same thing, but eliminates the tree from the description. I suppose you could prove that they're equivalent. Or else you could consider it the explcitly deforested version.
17:59:08 <LoganCapaldo> lol
17:59:18 <LoganCapaldo> I see gwern was just being funny :)
17:59:32 <gwern> no, seriously, that's what happens for me
17:59:40 <olsner> you're doing it wrong!
17:59:46 <gwern> :(
17:59:51 <olsner> *ur doin
17:59:53 <Cale> Why are you catting it?
18:00:01 <LoganCapaldo> right but cat selfg.gz and cat selfgz shoudl have the same nonsense outputted
18:00:10 <LoganCapaldo> is the point
18:00:39 <SamB> faxathisia: no
18:00:42 <gwern> LoganCapaldo: wait, what? selfgz is supposed to be the same thing as selfgz.gz? that's stupid, it should have the same name
18:00:50 <Cale> cale@zaphod:~/Downloads$ md5sum selfgz.gz
18:00:50 <Cale> ad563f7f6d804d1319d7448fb9a548b1  selfgz.gz
18:00:51 <faxathisia> no what?
18:00:55 <Cale> cale@zaphod:~/Downloads$ gunzip selfgz.gz
18:00:55 <SamB> faxathisia: not every compression method has a fixpoint
18:00:55 <Cale> cale@zaphod:~/Downloads$ md5sum selfgz
18:00:55 <Cale> ad563f7f6d804d1319d7448fb9a548b1  selfgz
18:01:03 <faxathisia> why?
18:01:12 <SamB> well, RLE hasn't got one
18:01:14 <Cale> The point is that the contents of the file have remained the same.
18:01:28 <LoganCapaldo> this is what makes it a quine
18:01:42 <olsner> one caspian maclean seems to have disappeared from the 'net taking his notes on gzip quines with him
18:01:45 <SamB> well, unless you count an empty file
18:01:48 <roconnor> > "selfgz"++fix (".gz"++)
18:01:51 <Cale> If you want, you could then rename the file to put the .gz back
18:01:52 <lambdabot>  "selfgz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz.gz...
18:02:20 <monochrom> > "selfz" ++ fix (".z" ++)
18:02:21 <lambdabot>  "selfz.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z.z...
18:03:21 <roconnor> That's a pretty crapy compression ratio.
18:03:49 <roconnor> I suppose it could be worse
18:04:17 <lament> let gzip = (++".gz") in iterate gzip "selfgz"  -- iterative compression
18:04:21 <lament> > let gzip = (++".gz") in iterate gzip "selfgz"  -- iterative compression
18:04:22 <lambdabot>  ["selfgz","selfgz.gz","selfgz.gz.gz","selfgz.gz.gz.gz","selfgz.gz.gz.gz.gz",...
18:04:59 <olsner> http://www.interactivecode.com/compression-6/gzip-decompression-quine-20482/ here is some reference to the method used at least, together with a few dead links
18:05:06 <lambdabot> Title: gzip decompression quine - Interactive Code, http://tinyurl.com/2pgv9k
18:05:33 <faxathisia> @let rle map (length &&& head) . group
18:05:33 <lambdabot>  Parse error
18:05:38 <faxathisia> @let rle=map (length &&& head) . group
18:05:39 <lambdabot> <local>:3:28:     Ambiguous type variable `a' in the constraint:       `Eq a'...
18:06:00 <faxathisia> @let rle = map (length &&& head) . (group :: String -> [String])
18:06:01 <lambdabot> Defined.
18:06:09 <faxathisia> > rle "so this has no fixed point?"
18:06:10 <lambdabot>  [(1,'s'),(1,'o'),(1,' '),(1,'t'),(1,'h'),(1,'i'),(1,'s'),(1,' '),(1,'h'),(1,...
18:07:10 <lament> faxathisia: clearly not, since it's not (a -> a)
18:07:17 <lament> :t rle
18:07:18 <lambdabot> Not in scope: `rle'
18:07:23 <lament> ehh
18:07:23 <faxathisia> @let rle = show . map (length &&& head) . (group :: String -> [String])
18:07:24 <lambdabot> <local>:4:0:     Multiple declarations of `L.rle'     Declared at: <local>:3:...
18:07:27 <Stinger> is there a way to find fixity information in ghci?
18:07:29 <faxathisia> @undef
18:07:30 <lambdabot> Undefined.
18:07:31 <faxathisia> @let rle = show . map (length &&& head) . (group :: String -> [String])
18:07:32 <lambdabot> Defined.
18:07:50 <lament> faxathisia: cheater
18:07:52 <faxathisia> @undef
18:07:53 <lambdabot> Undefined.
18:07:56 <Cale> I like how you're giving group an explicit type signature just to avoid eta expanding :)
18:08:09 <faxathisia> @let rle = concatMap (\(n,c)->show n ++ [c,' ']) . map (length &&& head) . (group :: String -> [String])
18:08:10 <lambdabot> Defined.
18:08:16 <faxathisia> this is easier to work with then..
18:08:28 <Cale> > fix rle
18:08:29 <lambdabot>  Exception: <<loop>>
18:08:41 <faxathisia> hehe
18:08:45 <faxathisia> It's not going to be that easy
18:08:48 <lament> would be cool if it worked :)
18:09:00 <Cale> It did work.
18:09:01 <lament> but it's easy to show that there's no fixed point
18:09:06 <lament> so it did work
18:09:19 <Cale> error "Exception: <<loop>>" is a fixed point
18:09:25 <lament> right
18:09:28 <Cale> > rle (error "Exception: <<loop>>)
18:09:28 <lambdabot> Unbalanced parentheses
18:09:31 <Cale> > rle (error "Exception: <<loop>>")
18:09:32 <lambdabot>  Exception: Exception: <<loop>>
18:09:33 <faxathisia> > rle "22 1  11 2"
18:09:34 <lambdabot>  "22 1  11 2  21 1  12 "
18:09:36 <Cale> er
18:09:40 <Cale> > rle (error "<<loop>>")
18:09:43 <lambdabot>  Exception: <<loop>>
18:09:46 <Cale> yeah :)
18:10:20 <dmwit> > rle "22"
18:10:21 <lambdabot>  "22 "
18:10:25 <chadz> no one's played with lighttpd / fastcgi? :)
18:10:32 <dmwit> Whoops, what's that extra space?
18:10:55 <faxathisia> @undef
18:10:56 <lambdabot> Undefined.
18:10:58 <faxathisia> @let rle = intercalate " " (\(n,c)->show n ++ [c]) . map (length &&& head) . group
18:10:59 <lambdabot> <local>:1:23:     The lambda expression `\ (n, c) -> show n ++ ...' has one a...
18:11:07 <Cale> chadz: That sounds like evil web stuff :)
18:11:27 <faxathisia> @let rle = intercalate " " . map (\(n,c)->show n ++ [c]) . map (length &&& head) . group
18:11:28 <lambdabot> Defined.
18:11:33 <faxathisia> ok :)
18:11:40 <Cale> chadz: You should know by now we only write console programs ;)
18:11:55 <dmwit> > rle "22"A
18:11:55 <lambdabot>   Not in scope: data constructor `A'
18:11:57 * gwern beats a level in Hetris
18:11:57 <dmwit> > rle "22"
18:11:58 <lambdabot>  "22"
18:11:59 <chadz> me too, generally. I'm bored.
18:12:03 <dmwit> haha!
18:12:05 <faxathisia> SamB: Does that disprove what you said or nat?
18:12:14 <faxathisia> > iterate rle "1"
18:12:18 <lambdabot>  ["1","11","21","12 11","11 12 1  21","21 1  11 12 1  11 2  12 11","12 11 1  ...
18:12:37 <lament> what's with the spaces
18:12:45 <lament> are they really necessary?
18:12:47 <Cale> > map (filter (not . isSpace)) . iterate rle $ "1"
18:12:48 <lambdabot>  ["1","11","21","1211","1112121","211111211121211","1211111221111121112211122...
18:12:49 <dmwit> > iterate (filter (not . isSpace) . rle) "1"
18:12:49 <lambdabot>  ["1","11","21","1211","111221","312211","13112221","1113213211","31131211131...
18:13:02 <faxathisia> > map length $ iterate (filter (not . isSpace) . rle) "1"
18:13:08 <lambdabot> Terminated
18:13:16 <gwern> hm. hetris doesn't do gravity
18:13:23 <dmwit> You have to filter on each step if you want the see-n-say sequence.
18:13:25 <lament> > iterate rle "9"
18:13:26 <lambdabot>  ["9","19","11 19","21 1  11 19","12 11 1  11 2  21 1  11 19","11 12 1  21 1 ...
18:13:30 <faxathisia> > map length $ map (filter (not . isSpace)) . iterate rle $ "1"
18:13:36 <lambdabot> Terminated
18:13:36 <gwern> nor are its blocks correct - they're not supposed to be 2x3 but 2x2
18:13:43 <lament> > iterate rle "99"
18:13:44 <lambdabot>  ["99","29","12 19","11 12 1  11 19","21 1  11 12 1  11 2  21 1  11 19","12 1...
18:13:46 <faxathisia> why can't I take the lengths?
18:13:54 <Cale> > map length . map (filter (not . isSpace)) . iterate rle $ "1"
18:13:59 <lambdabot> Terminated
18:14:06 <Cale> Because they get long quickly, perhaps
18:14:10 <Cale> > map length . take 12 . map (filter (not . isSpace)) . iterate rle $ "1"
18:14:15 <lambdabot>  [1,2,2,4,7,15,32,73,167,387,897,2084]
18:14:43 <faxathisia> > map length . take 12 . iterate (filter (not . isSpace) . rle) "1"
18:14:44 <lambdabot>  Couldn't match expected type `a -> [a1]'
18:14:48 <faxathisia> > map length . take 12 . iterate (filter (not . isSpace) . rle) $ "1"
18:14:49 <lambdabot>  [1,2,2,4,6,6,8,10,14,20,26,34]
18:15:03 <faxathisia> not fibonacci :(
18:15:16 <Cale> @oeis 1,2,2,4,6,6,8,10,14
18:15:17 <lambdabot> Length of n-th term in Look and Say sequence A005150.
18:15:17 <lambdabot> [1,2,2,4,6,6,8,10,14,20,26,34,46,62,78,102,134,176,226,302,408,528,678,904,11...
18:15:39 <chadz> heh.
18:15:41 <Cale> OEIS is omniscient.
18:15:53 <Cale> At least, when it comes to integer sequences :)
18:15:56 <chadz> @oeis 1,3,3,7
18:15:56 <lambdabot> Sigma(phi(n)).
18:15:56 <lambdabot> [1,1,3,3,7,3,12,7,12,7,18,7,28,12,15,15,31,12,39,15,28,18,36,15,42,28,39,28,5...
18:15:57 <gwern> Cale: I told you I uploaded arrayref, right?
18:16:06 <faxathisia> chadz, lol
18:16:07 <Cale> gwern: yeah, that's cool :)
18:16:10 * gwern wonders why Cale seems to be opped
18:16:18 <gwern> Cale: so what was that stuff anyway?
18:16:19 <Cale> Oh, I was dealing with a spammer.
18:16:21 --- mode: Cale set -o Cale
18:16:28 <faxathisia> @oeis 3,1,3,3,7
18:16:29 <lambdabot> Smallest number with same number of 1's in its binary expansion as n.
18:16:29 <lambdabot> [0,1,1,3,1,3,3,7,1,3,3,7,3,7,7,15,1,3,3,7,3,7,7,15,3,7,7,15,7,15,15,31,1,3,3,...
18:16:36 <Cale> gwern: That library?
18:16:40 <chadz> i'm about to spam my fastcgi question :)
18:17:20 <Cin> hm?
18:17:21 <gwern> Cale: yes, that odd stuff - what was it? obviously it compiled at one time
18:17:50 <Cin> chadz: what are you doing with fastcgi?
18:17:56 <Cale> It's a library which unifies the various reference types throughout the libraries and makes imperative programming simpler.
18:18:16 <gwern> Cale: no no, I mean, what was that odd syntax which stopped arrayref from compiling
18:18:26 <Cale> Oh, it was pattern signatures.
18:18:29 <chadz> Cin: just playing with it. I can't however seem to get lighttpd to serve it.
18:18:47 <faxathisia> Cale, could you get a goto in it?
18:19:17 <chadz> when I attempt to execute hte fcgi, it yields : "ThreadId 3: user error (FCGX_Accept_r failed)"
18:19:21 <Cale> GHC still supports them. I just removed them and replaced them with explicitly quantified type variables.
18:19:38 <chadz> I remember the old binaries I'd compile with cgi spitting out html.
18:19:39 <hpaste>  Cin pasted "chadz: if it helps, here's my setup" at http://hpaste.org/5829
18:19:54 <Cale> I suppose I could have just added {-# LANGUAGE PatternSignatures #-}
18:20:01 <Cin> chadz: are you using CGI or FastCGI?
18:20:11 <chadz> fastcgi atm.
18:20:29 <gwern> Cale: but then shouldn't have compiling with -fglasgow-exts have worked?
18:21:01 <Cale> I don't know. Perhaps PatternSignatures are no longer part of -fglasgow-exts?
18:21:28 <gwern> ...-fglasgow-exts doesn't turn on all extensions? NOW I DON'T KNOW WHAT TO BELIEVE IN
18:21:28 <Cin> chadz: what problem are you having? i was having trouble setting it up yesterday but i've got it working now
18:21:33 <chadz> Cin: what happens when you manually execute the fcgi binary?
18:21:41 <chadz> Cin: it just hangs when I access the .fcgi
18:21:41 <Cin> chadz: it fails with a strange error
18:21:52 <gwern> @hoogle Storable
18:21:53 <lambdabot> Foreign.Storable :: module
18:21:53 <lambdabot> Data.Array.Storable :: module
18:21:53 <lambdabot> Foreign.Storable.Storable :: class Storable a
18:22:08 <chadz> Cin: ThreadId 3: user error (FCGX_Accept_r failed) ?
18:22:10 <Cin> chadz: paste your .fcgi code or lighttpd config?
18:22:13 <Cin> chadz: yes that one
18:22:19 <chadz> http://rafb.net/p/Nof0iE68.html
18:22:19 <lambdabot> Title: Nopaste - fastcgi issue
18:22:21 <Cin> chadz: it needs to be started by lighttpd or apache
18:22:37 <chadz> it is. I see the process in `ps`
18:22:46 <chadz> it just _hangs_
18:22:48 <Cin> indeed, that config looks right
18:23:05 <chadz> i've tried different code for the fcgi even.
18:23:24 <chadz> i ripped the multifarious blog example even just for sanity.
18:23:26 <Cin> what's the code of your fcgi?
18:24:16 <hpaste>  chadz pasted "multifarious example" at http://hpaste.org/5830
18:24:58 <gwern> @hoogle peek
18:24:58 <lambdabot> Foreign.Storable.peek :: Storable a => Ptr a -> IO a
18:24:58 <lambdabot> Foreign.Storable.peekElemOff :: Storable a => Ptr a -> Int -> IO a
18:24:58 <lambdabot> Foreign.Storable.peekByteOff :: Storable a => Ptr b -> Int -> IO a
18:25:46 <Cin> chadz: here's some page i'm working on at the moment: http://rtfs.ath.cx/poller/ , and the source: http://rtfs.ath.cx/poller/Poller.hs  (already pasted the httpd.conf file)
18:28:27 <Cale> Hehe, 'roundlet' :)
18:28:37 <TomMD> @users
18:28:37 <lambdabot> Maximum users seen in #haskell: 471, currently: 413 (87.7%), active: 18 (4.4%)
18:29:21 <Cin> cale :P
18:29:28 <gwern> @define roundlet
18:29:30 <lambdabot> Undefined.
18:29:39 <Cale> @wn roundlet
18:29:39 <lambdabot> No match for "roundlet".
18:29:46 <Cale> @web1913 roundlet
18:29:46 <lambdabot> *** "Roundlet" web1913 "Webster's Revised Unabridged Dictionary (1913)"
18:29:46 <lambdabot> Roundlet \Round"let\, n.
18:29:46 <lambdabot>    A little circle. --J. Gregory.
18:30:49 * wy finally found out why people love Parsec
18:31:26 <Riastradh> Why is that, wy?
18:32:10 <wy> Because I'm suffering CUP.
18:32:16 <Riastradh> CUP?
18:32:25 <wy> the LALR parser generator for Java
18:32:35 <Cale> Riastradh: A terrible Java parser generator.
18:32:40 <faxathisia> Parsec isn't just better than CUP
18:32:55 <wy> Got almost no feedback for errors, and can only debug by eyeball
18:32:58 <sclv> wy: try antler. there's also a java parsec, I think, but dunno how well it works.
18:33:14 <yondalf> i think it's antlr
18:33:25 <eyeris> Has anyone made a cheat sheet showing the relationships between the different number classes in haskell? I'm not a mathematician :/
18:33:38 <chadz> Cin: thanks for hte config. Directly using yours worked :)
18:33:41 <Cale> eyeris: There's one in the Report.
18:33:44 <yondalf> sometimes i have to debug by eyeball in parsec too...when many complains that the parser it takes can be satisfied by the empty string
18:33:44 <Riastradh> ...ah.
18:33:51 <ddarius> eyeris: They aren't related in mathematical ways.
18:33:52 <Cin> chadz: cool!
18:33:55 <Cale> eyeris: (and they don't correspond to mathematicians' number classes anyway)
18:34:15 <Cale> http://haskell.org/onlinereport/basic.html#sect6.3
18:34:21 <eyeris> Cale: thanks!
18:34:24 <wagle_home> no unconstructable cardinals?
18:34:26 <wy> I thought parser generators can be more descriptive, but now I think I did lots more work than using handwritten ones
18:34:50 <faxathisia> Parsec is a parser generator though
18:35:02 <Cale> ...sort of
18:35:08 <faxathisia> In both cases you write code and a parser is created
18:35:15 <wy> faxathisia: Is it? But you write your grammar in the same language
18:35:23 <Cale> Well, sure. But parsec does it in a completely different way.
18:35:23 <TomMD> > Data.ByteString.Lazy.any (==1) (Data.ByteString.Lazy.pack (repeat 2))
18:35:24 <faxathisia> No you don't
18:35:25 <lambdabot>   Not in scope: `Data.ByteString.Lazy.pack'
18:35:38 <faxathisia> You use Parsec the language which is embedded in Haskell
18:35:43 <TomMD> @where lambdabot
18:35:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:35:53 <wy> faxathisia: The difference is that using a parser geneator I have to write the grammar in some other language that the generator recognizes
18:36:05 <faxathisia> wy: I can't see that as a difference
18:36:18 <faxathisia> wy: It seems to be exactly the same from my POV
18:36:24 <Cale> faxathisia: Parser generators generally take code and transform it explicitly into code implementing the parser. Parsec just defines a bunch of Haskell values and functions which you use to construct a parser on the fly.
18:36:30 <wy> faxathisia: but the "embedded" language is Haskell itself
18:36:51 <gwern> wow. rms is stepping down as emacs maintainer
18:37:09 <wy> Cale: yes. so that you can have type checking etc etc... which is absolute not possible in a generator
18:37:12 <gwern> http://lists.gnu.org/archive/html/emacs-devel/2008-02/msg02140.html
18:37:12 <Cale> faxathisia: There are limitations to Parsec's approach, in fact, in that there's no way to write a monadic parser combinator library that handles left recursion.
18:37:13 <lambdabot> Title: Re: Looking for a new Emacs maintainer or team, http://tinyurl.com/332nx8
18:37:32 <Cale> (because the right hand side of a bind is a function and can't be observed)
18:37:41 <faxathisia> wy, type checking is possible in a generator
18:37:47 <Cale> To avoid that problem, you can use an arrow parser combinator library.
18:37:52 <wy> Cale: can ANTLR do it?
18:38:05 <Cale> wy: I would hope so, but I don't know.
18:38:08 <faxathisia> Cale, you can also use try though?
18:38:15 <Cale> (I have no specific experience with antlr)
18:38:34 * ddarius thinks he touched ANTLR a long long time ago.
18:38:37 <sclv> i think antler is LL too, but very expressive.
18:38:49 <wy> any way. That's not possible for my course. CUP is how the project is graded
18:38:50 <Cale> It would make more sense if it were LR.
18:38:57 <BMeph> Cale: So, what's your definition of an EDSL? ;)
18:38:57 <Cale> (given its name)
18:39:36 <wy> Can any LR grammar be transformed into a LL one?
18:39:52 <EvilTerran> also given that parser generators tend to be some subset of LR
18:39:56 <Cale> BMeph: A library with a sufficiently expressive API that using it can be considered programming in a special purpose language.
18:40:20 <sclv> antlr however is LL(*). go figure.
18:40:48 <wy> sclv: It is LL(k) with k>1
18:41:03 <eyeris> Is there any way to get a library module into ghci so that I can use :t :i etc?
18:41:08 <ddarius> :m
18:41:13 <wy> I guess it is also for Parsec
18:41:23 <eyeris> (besides the obvious method of creating a file with just an import)
18:41:25 <Cale> :m + Module.Path
18:41:26 <sclv> gah! lied to by wikipedia again! do they let just *anyone* edit it or something?
18:41:32 <ddarius> wy: Parsec parsers can be context sensitive.
18:41:40 <wy> I wonder how is Haskell parsed
18:41:49 <ddarius> wy: GHC uses Happy and Alex
18:41:51 <wy> ddarius: what does that mean?
18:41:52 <gwern> carefully. <ba dum>
18:42:03 <Cale> wy: Haskell is actually context sensitive, but in a way which is not so severe.
18:42:08 <sclv> i knew that was coming a mile away, gwern.
18:42:19 <ddarius> Cale: Most programming languages are context sensitive.
18:42:24 <wli> It'd be nice if there were LR parser combinators.
18:42:31 <Cale> ddarius: really?
18:42:39 <sclv> C is.
18:42:40 <monochrom> do { x <- anyChar; char '+'; char x }   -- context sensitive
18:42:41 <gwern> sclv: I wanted to give you time to duck
18:42:41 <wy> wli: Is it possible in theory?
18:42:41 <wli> Well, in a manner of speaking.
18:42:48 <wagle_home> i thought it funny when orson scott card corrected some errors in the biography in his entry in wikipedia, only to have someone change it back to the erroroneous info
18:43:00 <Cin> wagle: hehe
18:43:02 <BMeph> Cale: So, Parsec isn't expressive enough to count as a separate language?
18:43:18 <Cale> BMeph: It's an EDSL, sure.
18:43:31 <monochrom> Cale: http://www.vex.net/~trebla/weblog/declare-before-use.xhtml
18:43:38 <wli> wy: I'm not sure. They may need to operate on a different principle or some such from most now there. (I think the pArrows thing or something does something akin to it.
18:43:41 <ddarius> Cale: Well, I haven't done studies, but usually there is some minor thing that causes slight problems.
18:43:42 <wagle_home> regular expression define a language..  what do you mean?
18:43:51 <wy> wagle_home: You like his books?
18:44:13 <wagle_home> wy..  read a bunch, got tired of them
18:44:14 <monochrom> perhaps ddarius may also be interested in my url above :)
18:44:27 <Cale> monochrom: Isn't that more a semantic error than a syntax error?
18:44:40 * gwern stabbies Hetris for its inscrutable build process
18:44:43 <wy> wagle_home: got tired of sci-fi?
18:44:54 <monochrom> You can omit "semantics" from "language". Then you can say that.
18:45:09 <wagle_home> wy..  prolly that too
18:45:12 <sclv> or of crypto-morman mysticism?
18:46:06 * wy went back to check his grammar
18:46:06 <monochrom> A wording of the claim is "this language is not context-free".  So it does involve deciding what is "in" the language and what is "out".
18:46:06 <Cale> I thought we were talking about the syntax of languages, not the fully-refined set of programs accepted by the compiler. Of course that'll be context sensitive :)
18:46:07 <monochrom> But the wording is definitely not "this syntax is not context-free".
18:46:32 <monochrom> "<ddarius> Cale: Most programming languages are context sensitive."  hehehe
18:46:52 <faxathisia> monochrom: That was in the context of parsing
18:47:01 <Cale> Yeah, if that's what he meant, it's not too surprising.
18:47:26 <monochrom> There is a large grey area of how much you check in the "parser".
18:47:48 <eyeris> Finally, is there any way to make ghci save the history buffer?
18:47:58 <monochrom> In the context of specifically Parsec, users tend to check much more actually, e.g., <xmltag> ... </xmltag>
18:47:59 <Cale> Well, I suppose it depends on what your abstract syntax looks like.
18:48:25 <OceanSpray> What's the significance of the Spineless-Tagless-G-Machine?
18:48:29 <Cale> Checking that with parsec is actually a really bad idea.
18:48:34 <olsner> ah, more bacterially processed milk for me
18:48:54 <Cale> OceanSpray: It's the basis of how GHC executes Haskell code?
18:48:58 <OceanSpray> oh?
18:48:58 <gwern> gah! surely there is a way to provide an option to hsc2hs through Cabal?
18:49:24 <gwern> OceanSpray: it's the intermediate language between asm/c and Haskell
18:49:40 <ddarius> s/the/a
18:49:51 <gwern> Core doesn't count
18:49:59 <ddarius> Why not?
18:50:34 <ddarius> There is also a variant of Cmm though I think that has changed recently.
18:50:47 <gwern> it's really just a desugared and expand haskell isn't it? it doesn't differ enough imo to be a true intermediate language
18:51:03 <Cale> Uh, it really is *the* intermediate language in GHC.
18:51:06 <ddarius> gwern: It's not valid Haskell.
18:51:09 <SamB> ddarius: eh? recently?
18:51:15 <Cale> It's where all the optimisations happen.
18:51:21 <SamB> it's never been the standard C--...
18:51:25 <gwern> 'hsc2hs Curses.hsc --lflag=-lcurses' <-- now, this works fine manually, but how do I have cabal do it?
18:51:50 <ddarius> SamB: Away from Cmm not toward it.
18:52:26 <SamB> actually, that surprises me very little ;-)
18:52:26 <wagle_home> stgm is slightly older than haskell, i think
18:52:53 <Cale> What?
18:53:07 <roconnor> @seen duncan
18:53:08 <lambdabot> I haven't seen duncan.
18:53:09 <Cale> The STG Machine paper is from 1992.
18:53:10 <roconnor> er
18:53:15 <EvilTerran> @deen dcoutts_
18:53:16 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 1h 30m 13s ago.
18:53:16 <roconnor> @seen dcoutts_
18:53:17 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 1h 30m 14s ago.
18:53:17 <gwern> @seen dcoutts_
18:53:17 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 1h 30m 15s ago.
18:53:25 <ddarius> The -G-machine- is definitely older than Haskell.
18:53:34 <EvilTerran> well, *that* aughta get his attention
18:53:39 <gwern> heh
18:54:07 <Cale> http://citeseer.ist.psu.edu/graphs/ce/2e/78/78/docyear6559.png -- heh, check this out
18:54:18 <monochrom> Does the G machine admit a quine?
18:54:19 <Cale> It's the graph of citations of the STG machine paper.
18:54:29 <gwern> 1998 - a fine vintage for citations...
18:54:29 <dcoutts_> roconnor: yo
18:54:41 <gwern> Cale: so what happened in '98?
18:54:42 <dcoutts_> gwern: mm?
18:54:48 <gwern> dcoutts_: 'hsc2hs Curses.hsc --lflag=-lcurses' <-- now, this works fine manually, but how do I have cabal do it?
18:54:54 <olsner> 98 = Haskell '98?
18:54:56 <wy> For a LALR generator like CUP, I also found a need of left-factoring. That's not so nice
18:54:57 <roconnor> dcoutts_: I was vaguely thinking about idea for enforcing interfaces in hackage.
18:55:12 <wagle_home> i first heard of stgm in about 1987
18:55:19 <dcoutts_> gwern: extra-libraries: curses, same as you use normally
18:55:23 <gwern> olsner: oh, duh. but wouldn't stg be interesting before and affter?
18:55:35 <dcoutts_> roconnor: yes? what kind of interfaces?
18:55:37 <roconnor> dcoutts_: I imagine a release procedure that fixes the imports to list the importing functions.
18:56:11 <gwern> dcoutts_: hm. that's unobvious to me
18:56:21 <gwern> @hoogle CForeign
18:56:21 <dcoutts_> roconnor: you know we'd like a tool (using the ghc-api) to compare package interfaces and check that packages are following the package version policy, and to generate changelogs
18:56:21 <lambdabot> Foreign.ForeignPtr.mallocForeignPtr :: Storable a => IO (ForeignPtr a)
18:56:21 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
18:56:21 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
18:56:26 <roconnor> dcoutts_: and then requiring a major version bump everytime a module's interface changes in an incompatable (according to types) way
18:56:58 <olsner> hmm, yeah, most of a standard should be of interest either *before* or *after* its publication but not really at the same time... I just happened to recognize the year '98
18:56:58 <dcoutts_> gwern: you have to use that to get your package to link to the C lib, and cabal then uses the same for hsc2hs
18:57:35 <dcoutts_> gwern: or try using ghc-options: -lcurses and then see what 'cabal check' suggests you do ;-)
18:57:46 <hpaste>  gwern pasted "linker problem" at http://hpaste.org/5831
18:57:59 <wy> Would it be very welcomed if someone'd write something SLIME for Haskell?
18:58:05 <dbpatterson> what is the easiest way to convert plain html into Text.XHtml combinators?
18:58:17 <ddarius> wy: I wouldn't care for it, but I'm sure several others would like it.
18:58:18 <faxathisia> wy: Doesn't make sense
18:58:23 <Cale> dbpatterson: By hand?
18:58:27 <dcoutts_> gwern:
18:58:27 <dcoutts_> $ cabal check
18:58:27 <dcoutts_> The following warnings are likely affect your build negatively:
18:58:27 <dcoutts_> Instead of 'ghc-options: -lcurses' use 'extra-libraries: curses'
18:58:27 <dcoutts_> Hackage would reject this package.
18:58:29 <wy> faxathisia: why?
18:58:41 <dbpatterson> Cale: preferably semi automatically... I'm asking so I DONT have to do it by hand :)
18:59:12 <faxathisia> wy: It's not possible to work like that with haskell
18:59:16 <gwern> dcoutts_: I don't have cabal check, maybe that's too new. anyway, do you the recognize the link problem? I think it has something to do with the files wrap.c wrap.h & wrap.h.gch
18:59:21 <ddarius> faxathisia: Why not?
18:59:29 <Cale> dbpatterson: Or I suppose if you have enough of it, you could generate Haskell code using one of the XML parsers and a code generator using Language.Haskell.*
18:59:38 <faxathisia> the type system
18:59:43 <gwern> wy: sounds very difficult. you'd need to use the GHC API, and that's a whirling meat grinder imo
18:59:44 <ddarius> faxathisia: So?
19:00:19 <dcoutts_> gwern: check if the thing really is defined multiple times. I don't know what a .gch file is.
19:00:33 <gwern> one of the makefile lines says: Hetris/wrap.o: Hetris/wrap.c Hetris/wrap.h Hetris/Makefile gcc -Wall -pedantic -c $< -o $@
19:00:42 <dbpatterson> Cale: but no script exists already (in that case, it is probably quicker to do it by hand, I dont have too much of it)
19:00:48 <dcoutts_> gwern: and watch out for C functions getting defined in .h files, that'd make them end up in multiple .o files
19:00:48 <faxathisia> basically anything you create is going to be so different from SLIME it make no sense to mention slime
19:00:55 <wy> faxathisia: maybe it can be made incremental?
19:01:00 <ddarius> faxathisia: Well that's true.
19:01:00 <Cale> dbpatterson: not that I'm aware of
19:01:10 <gwern> dcoutts_: it's weird, because it works fine going through the Makefile but I have no idea how it works
19:01:12 <Cale> dbpatterson: I don't do a whole lot of web stuff though
19:01:12 <dcoutts_> roconnor: yes, that sounds like what we're talking about, have you seen the package version policy?
19:01:33 <roconnor> dcoutts_: nope
19:01:48 <wy> faxathisia: Oh, I see what you mean. I didn't really meant exactly like Slime, but just sort thing like that that can have some semantic checks when editing
19:01:53 <SamB> faxathisia: slime does a lot of things
19:01:58 <dcoutts_> roconnor: it's just that issue, version bumping and compatible/incompatible api changes
19:02:04 <SamB> faxathisia: some of them are quite possible to do for Haskell!
19:02:17 <roconnor> dcoutts_: link?
19:02:22 <faxathisia> yeah like, Compile file
19:02:25 <dcoutts_> robozni: http://haskell.org/haskellwiki/Package_versioning_policy
19:02:26 <bparkis> what is the name of an axiomatic approach to functional programming? (like Hoare logic is for imperative)
19:02:27 <hpaste>  gwern annotated "linker problem" with "paste in the commnads the makefile says it runs" at http://hpaste.org/5831#a1
19:02:43 <Cale> bparkis: Denotational semantics, I suppose
19:03:04 <monochrom> Equational reasoning.
19:03:51 <Cale> Denotational semantics is really general though.
19:03:51 <LoganCapaldo> faith
19:03:54 <roconnor> dcoutts_: I suspect we may be able to build tools to support such a policy.
19:04:00 <wagle_home> people apply theorem provers to their programs
19:04:17 <bparkis> well what is a close analogue of Hoare logic for functional programming?
19:04:23 <BMeph> So, is there a Haskell parser in Parsec out there somewhere? ;)
19:04:24 <monochrom> Equational reasoning.
19:04:25 <bparkis> denotational semantics does seem too general and not what i'm looking for
19:04:35 <ddarius> bparkis: What monochrom said.
19:04:36 <faxathisia> wy: Something like proof general for haskell would be better
19:04:42 <dcoutts_> roconnor: so I wrote a very simple tool a couple years ago, it used ghc --show-iface to give the api as text, then used a haskell prog to compare and look for additions and changes. You could do something much more reliable with the ghc-api.
19:04:58 <roconnor> dcoutts_: oh nice
19:05:11 <faxathisia> wy: even though it would be a lot different that's closer to what would be useful for haskell
19:05:27 <roconnor> dcoutts_: still, a tool for setting explicit imports would be needed for complete robustness.
19:05:29 <bparkis> is equational reasoning the name of an axiomatic system or just a principle that you can use in functional programming (as I've seen it used)?
19:05:45 <faxathisia> bparkis: lambda calculus.. ?
19:06:04 <Cale> bparkis: Just the usual idea from mathematics of replacing things with other equal things.
19:06:09 <dcoutts_> roconnor: yes, checking if people are always using qualified or explicit imports would be useful too
19:06:36 <bparkis> specifically I want a system that has axioms something like, "if predicate P is true of the argument to the function, predicate Q will be true of the return value"
19:06:42 <monochrom> Squiggol is a specific system.
19:06:49 <bparkis> a formal axiomatic system
19:07:16 <SamB> bparkis: axioms like that?
19:07:31 <SamB> wouldn't those be more like ... theorems?
19:07:37 <dcoutts_> roconnor: and yes, I guess packages importing modules from packages following the PVP would need to be using qualified or explicit imports to guarantee no breakage from the 'compatible' api changes part of the the PVP spec since otherwise additions could cause namespace clashes.
19:07:45 <faxathisia> It doesn't have axioms like that.. but you can prove these kind of things with type theory
19:07:45 <bparkis> well, they would be axioms if the function were a primitive
19:07:58 <faxathisia> yeah and define such axioms
19:08:08 <monochrom> Because of referential transparency and other historical factors, formal methods for FP look very different from formal methods for IP.
19:08:11 <bparkis> for instance if the function were "+" (a primitive) then the axiom could say "if a and b are numbers, then a + b is the sum of a and b"
19:08:16 <bparkis> only a lot more formally
19:08:24 <dcoutts_> roconnor: so if you want to look into building such a tool that we could use with hackage and developers could use themselves, that'd be enormously useful to everyone.
19:08:34 <ddarius> bparkis: Any approach to semantics can be used to make such a formal system.
19:08:35 <SamB> bparkis: that's a pretty dumb sounding axiom ;-P
19:08:38 <faxathisia> bparkis, you can do this in type theories like Coq or Agda 2
19:08:39 <Cale> bparkis: I suspect you really are looking for denotational semantics.
19:08:55 <bparkis> well SamB + would be defined in the programming language, and "sum" would be defined in the axiomatic system
19:09:21 <Cale> In particular, the stuff that has to do with Scott domains and such.
19:09:27 <bparkis> the axioms would "explain" the behavior of the primitive functions in the terminology of the formal logic
19:09:31 <dcoutts_> roconnor: one way might be to generate some other machine readable format from an installed ghc package. Then in a second phase, compare pairs of such output for changes or PVP violations.
19:10:10 <roconnor> dcoutts_: oh, that is a good idea
19:10:11 <Cale> Denotational semantics is all about defining the meaning of programs by replacing expressions with various mathematical objects.
19:10:17 <dcoutts_> roconnor: that'd allow hackage to store the api in that machine readable format for each package, and we'd be able to compare packages even if the two versions could not both be built with a single version of ghc
19:10:26 <monochrom> I study formal methods for bread and I actually know the answers and I have given two, and nobody thinks it's worth anything.
19:10:38 <bparkis> I'm specifically not looking for general theory about proving things about functional programming, I am looking for an axiomatic system like Hoare logic for functional programming (preconditions/postconditions)
19:10:39 <dcoutts_> roconnor: which is otherwise a problem if we make a tool that only compares two installed ghc packages.
19:10:51 <faxathisia> monochrom, I am reading about Squiggol
19:10:58 <monochrom> Anyway, for the last time, Squiggol.
19:11:10 <roconnor> bparkis: reasoning about functional programming is much easier
19:11:12 <Cale> bparkis: equational reasoning then
19:11:17 <roconnor> bparkis: we use dependent types
19:11:31 <roconnor> bparkis: and natural deduction.
19:11:31 <ddarius> roconnor: I don't use dependent types.
19:11:34 <bparkis> but is equational reasoning really an axiomatic system or just one single principle?
19:11:39 <synthasee> what is the reasoning behind 'a' == "a" the left side of this expression being ill-typed and not the right? i.e., why should 'a' be of type [Char] vs' "a" should be of type Char
19:11:42 <faxathisia> monochrom, what do you use formal methods like Squiggol for?
19:11:45 <roconnor> ddarius: you are wrong then. :P
19:12:17 <faxathisia> synthasee: == has to have both sides the same type
19:12:23 <roconnor> bparkis: oops I missed the `not' in your post. sorry
19:12:39 <faxathisia> synthasee: When you have 'a' on one side, the type error comes from having something of a different type on the right
19:13:22 <monochrom> I haven't used Squiggol much.  I would use it the same way "bananas, lenses, barbed wires" is used.  They are in the same vein.  Squiggol was earlier and probably less general.
19:13:39 <ddarius> bparkis: Hoare logic is just another approach to formal semantics.
19:14:06 <Cale> synthasee: Because it's a good way to tell apart characters and strings?
19:14:08 <monochrom> But most of the time, I apply IP formal methods to FP.
19:14:16 <synthasee> faxathisia: understood but I was wondering why the left side is ill-typed and not the otherway around. i.e., the right side is ill-typed. Seems arbitrary.
19:14:18 <Cale> synthasee: er...
19:14:32 <faxathisia> :t 'a' == "a"
19:14:35 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
19:14:36 <lambdabot>     In the second argument of `(==)', namely `"a"'
19:14:37 <Cale> synthasee: ah, I see, that's not what you're asking
19:14:47 <faxathisia> synthasee: What's the error you get?
19:15:00 <synthasee> faxathisia: basically the same thing
19:15:02 <Cale> synthasee: It just depends on which order the typechecker happens to traverse things.
19:15:19 <synthasee> ok
19:15:27 <synthasee> makes sense
19:15:28 <faxathisia> synthasee: should it say  Couldn't match expected type `[Char]' against inferred type `Char'?
19:16:24 <Cin> "Different types given as instances of Eq"
19:16:48 <bparkis> maybe what I am looking for is "predicate transformers"
19:16:59 <LoganCapaldo> more than meets the eye
19:17:02 <monochrom> That's still heavily IP.
19:17:05 <bparkis> though that was designed for an imperative language maybe it can be applied to a functional one
19:17:06 <faxathisia> bparkis: For functional programming?
19:17:11 <faxathisia> bparkis: I doubt it..
19:17:12 <bparkis> yeah
19:17:26 <Cale> bparkis: Equational reasoning is basically just one principle, but it can be applied to prove quite a lot of things.
19:17:30 <faxathisia> bparkis: What do you want this for?
19:17:43 <monochrom> predicate transformer is a denotational semantics for IP.
19:17:50 <ddarius> Cale: To apply it, you need a semantics otherwise you have no non-trivial equations.
19:17:57 <faxathisia> bparkis: Do you actually intend to do formal reasoning or what?
19:18:00 <bparkis> faxathisia: i want to find out who has had the same idea as me before
19:18:04 <LoganCapaldo> cause he think he's got nails, so he really wants a hammer? :)
19:18:05 <bparkis> and maybe read up on it
19:18:10 <faxathisia> bparkis: What's your idea?
19:18:22 <bparkis> using predicates about values instead of types
19:18:32 <Cale> Isn't that what types are?
19:18:47 <bparkis> is it?
19:18:54 <Cale> I think so.
19:18:55 <faxathisia> bparkis, kind of like a generalization of GADTs?
19:18:57 <monochrom> Someone generalized predicate transformer to expression transformer.
19:18:58 <LoganCapaldo> isn't it?
19:19:05 <ddarius> Cale: I think there was a paper recently that embedded Hoare logic into some dependently typed language.
19:19:22 <LoganCapaldo> isn't that the whole point of theat curry-howard correspondence doo hicky
19:19:58 <Cale> bparkis: Types themselves tend to be statements in some intuitionist logic (or classical one, if you have call/cc)
19:20:34 <bparkis> then why not simply use the logic directly?
19:20:35 * SamB can never remember the difference between classical and intuitionist logic
19:20:35 <faxathisia> bparkis, or if that's way off then, what?
19:20:50 <ddarius> SamB: The law of the excluded middle.
19:20:55 <SamB> ah.
19:21:00 <bparkis> I don't know, maybe faxathisia
19:21:00 <SamB> I thought it might be that.
19:21:23 <faxathisia> bparkis, you can encode predicates on values as values quite simple in dependant types
19:21:44 <SamB> bparkis: well, if you use types instead, you can run the programs you prove things about, I think
19:22:06 <bparkis> faxathisia: when you use dependent types do you often need to compose a proof by hand that type checks your program?
19:22:18 <faxathisia> bparkis, Yes
19:22:18 <Cale> bparkis: At least with convenient-to-use programming languages, types don't express absolutely everything about the values they correspond to.
19:22:40 <faxathisia> bparkis, writing a proof would be like writing a program
19:22:44 <Cale> That is, there are generally important differences between members of a given type.
19:22:51 <monochrom> "Non-deterministic expressions and predicate transformers" is a good starting point.
19:23:15 <Cale> But types are certainly theorems about the values which they relate to.
19:23:15 <bparkis> faxathisia: and do you write the proof in a formal logical system that is then checked for correctness by machine?
19:23:25 <monochrom> That author Joseph Morris tried to bring predicate transformer to FP.
19:23:31 * SamB wonders why it seems like every other figure in the back of the PDP-1 maintenance manual is blank
19:23:41 <faxathisia> bparkis, yeah, the formal logic system being a functional programming language
19:23:46 <Cale> bparkis: You sound like you'd be interested in something like Coq or Agda
19:24:12 <bparkis> how can the language be the formal logic system, surely it's possible to compose an incorrect program
19:24:29 <faxathisia> sure
19:24:30 * wy is back from a spicy dinner
19:24:37 <bparkis> whereas you should not be able to write an incorrect proof that passes the computer's check
19:24:38 <roconnor> bparkis: we remove general recursion and replace it by structural recursion.
19:24:40 <SamB> yeah, you could try the agda tutorial
19:24:41 <faxathisia> \x -> x + 1 -- this is an incorrect program
19:24:44 <SamB> I dare you to finish it!
19:24:54 * SamB never quite got through the whole thing
19:24:57 <faxathisia> (It doesn't compute the square root of its input)
19:25:02 <Cale> \x -> x + 2 -- fixed
19:25:07 <faxathisia> lol
19:25:09 <wy> faxathisia: Is proof general a kind of frontend for the provers?
19:25:23 <monochrom> Excuse, it's really called "term transformer".  http://www.computing.dcu.ie/~jmorris/recabstracts.html
19:25:24 <SamB> wy: um, yes?
19:25:26 <lambdabot> Title: Recent Publications
19:25:55 <SamB> wy: doesn't it say that on the website, in the debian package description, in the info file, ...?
19:26:04 <bparkis> yes faxathisia
19:26:12 <roconnor> @type
19:26:15 <roconnor> @type fix
19:26:15 <lambdabot> <command line>:
19:26:15 <lambdabot>     Could not find module `L':
19:26:15 <lambdabot>       Use -v to see a list of the files searched for.
19:26:16 <lambdabot> forall a. (a -> a) -> a
19:26:35 <roconnor> thus inconsistent theorems like `fix' are disallowed
19:26:43 <bparkis> suppose that you have a definition of square root in a logical system
19:27:07 <Cale> Functional programmers are applied logicians who spend most of their time proving the same theorems over and over again in different ways in an inconsistent intuitionist logic.
19:27:23 <bparkis> could you, using dependent types, show that \x -> x + 1 is an incorrect program for computing the square root, in such a way that your proof is machine verifiable?
19:27:32 <faxathisia> bparkis: Simple example, intead of having (,) : a -> b -> (a,b), you can make some new pair as a dependent type, (x : a) -> P x -> (a,P)
19:27:39 <Cale> bparkis: yes.
19:27:45 <olsner> heh, "Factoring out what you want to do with your life is almost as hard as factoring products of large primes"
19:27:55 <ddarius> bparkis: Coq can probably formalize almost all of mathematics.
19:28:01 <faxathisia> bparkis: then write a function sqrt : (x : Int) -> ( y : Int , y * y = x )
19:28:08 <ddarius> olsner: Why would you need to?
19:28:54 * roconnor wonders if my slides http://r6.ca/FewDigits/FPdag2008 would be helpful for bparkis without the audio.
19:28:59 <faxathisia> bparkis: the only way it can type check if the function has that type, the dependent type lets you express properties about the program itself
19:29:10 <faxathisia> bparkis: does that match with what you meant?
19:29:59 <roconnor> http://r6.ca/FewDigits/FPdag2008.pdf
19:30:06 <roconnor> (pdf version)
19:30:33 <bparkis> yes that is what I meant faxathisia but how do you prove that a function conforms to that specification?
19:30:37 <bparkis> what does that proof look like?
19:31:55 <ddarius> bparkis: In that case you don't because not every Int has a square root
19:32:11 <roconnor> suppose you want to prove forall x, R(x, f(x)).  A proof is a function from x to R(x, f x), or a natural deduction proof encoded as a lambda term (which is the same thing).
19:32:24 <bparkis> ok, well suppose x were a positive real, then
19:32:31 <faxathisia> bparkis: some proofs of simple tautologies in Agda 2 http://pastey.net/82811
19:32:43 <bparkis> oh so this is all agda
19:32:46 <faxathisia> bparkis: You could do all these proofs automatically in Coq
19:33:09 <bparkis> agda is designed to operate together with Coq?
19:33:18 <faxathisia> bparkis: dolio has a nice proof of the relation between foldr and foldl here http://code.haskell.org/~dolio/agda-play/Data/List/Proofs.agda
19:33:25 <faxathisia> no
19:33:34 <faxathisia> both can compile to haskell though
19:35:05 <bparkis> ok
19:35:11 <bparkis> thanks i think agda is what i am looking for
19:35:38 <ddarius> bparkis: You may want to look at dependent types in general.
19:35:38 <faxathisia> bparkis: Agda is a lot of fun but it's kind of experimental and very hard to actually prove things in
19:38:17 <roconnor> bparkis: http://en.wikipedia.org/wiki/Curry-Howard_correspondence
19:38:18 <lambdabot> Title: Curry-Howard correspondence - Wikipedia, the free encyclopedia
19:38:37 <roconnor> ``The Curry-Howard correspondence is the direct relationship between computer programs and mathematical proofs.
19:39:13 <faxathisia> that was cool roconnor (the slides)
19:39:30 <roconnor> faxathisia: I wish I remembered to record my audio with them.
19:40:02 <roconnor> ``the observation in 1958 by Curry that a certain kind of proof systems referred to as Hilbert-style deduction system coincides on some fragment of it to the typed fragment of a standard model of computation known as combinatory logic,
19:40:12 <roconnor> ``the observation in 1969 by Howard that a certain kind of proof system referred to as natural deduction can be directly interpreted in its intuitionistic version as a typed variant of another standard model of computation known as lambda calculus.
19:40:21 <faxathisia> how is this haskell code for FewDigits written?
19:40:45 <roconnor> faxathisia: it is written by me. :)
19:41:21 <roconnor> faxathisia: maybe I didn't understand your question
19:41:46 <faxathisia> I'm curios how this lib is related dependant typing
19:42:12 <hpaste>  glen_quagmire pasted "how can I fix design?" at http://hpaste.org/5832
19:42:29 <roconnor> faxathisia: it was my prototype for my Coq version which does have dependent types to enforce that the real number are well-defined.
19:42:38 <faxathisia> ahh ok, cool
19:42:48 <faxathisia> That will be very interesting to see
19:42:56 <roconnor> faxathisia: it should be similar to what would be extraced by the Coq code.
19:43:21 <roconnor> faxathisia: my Coq implementation is more or less complete.
19:43:36 <faxathisia> is the code online anywhere?
19:44:27 <bparkis> let's go back a minute, if you have a definition for sqrt like you gave before (with y * y = x), what is the general procedure for showing that a given function satisfies it?
19:44:58 <roconnor> yes ...
19:45:21 <bparkis> to make it simple let's say that the function and the type declaration have type A -> B where A is the set of integer perfect squares and B is the set of non-negative integers
19:45:38 <bparkis> so you don't have to think about rounding or anything, if that would be a problem
19:45:43 <faxathisia> I can only find the haskell code
19:45:52 <roconnor> faxathisia: one sec
19:46:17 <faxathisia> bparkis: In Coq you would unfold definitions.. use lemmas.. proof tactics to show it's a true theorem
19:46:27 <faxathisia> bparkis: When you do this you construct a lambda term
19:46:42 <bparkis> in agda
19:46:44 <faxathisia> bparkis: You can extract the computationally relevant stuff and use that
19:47:00 <roconnor> faxathisia: the arch repository r.oconnor@cs.ru.nl--Nijmegen/CoRN--roconor-dev--3 located at http://www.fnds.cs.ru.nl/fnds-arch/roconnor/Nijmegen
19:47:01 <faxathisia> bparkis: In Agda you don't have proof tactics, you have to write lambda terms dircetly
19:47:02 <lambdabot> Title: Index of /fnds-arch/roconnor/Nijmegen
19:47:22 <roconnor> roconnor: but it requires the latest svn version of coq to compile.
19:47:29 <roconnor> faxathisia: ^^
19:47:41 <bparkis> maybe there's something I'm not getting, but in Agda you have this definition for sqrt where y * y = x, now what good does that definition do you when you actually want to compute the square root of something?
19:48:36 <bparkis> you must have a specific implementation of a function that you "claim" to be that type, right? how do you verify your claim?
19:48:47 <roconnor> bparkis: I think I can help you out here.
19:49:28 <faxathisia> bparkis: type checker
19:49:49 <ddarius> bparkis: The type checker is the proof verifier.
19:49:55 <faxathisia> If you write 42 :: Sheep it will tell you no.. if you write  \x -> a : forall a, a -> a it will say okx
19:50:31 <bparkis> but how could it know that a specific function has the type of "square root" by its own
19:50:37 <bparkis> that seems too complicated to be checked automatically
19:50:45 <roconnor> bparkis: imagine a function from so :: Bool -> type  such that so true = () and so false = Void where Void is the empty type.
19:51:00 <ddarius> bparkis: Proof checking is easy.  You give it the proof (the lambda term) and the theorem (the type) and it checks your proof.
19:51:01 <faxathisia> bparkis: It's too complex to do type inference, or term inference, but it is possible to type check
19:51:55 <roconnor> bparkis: then "so (2 + 2 == 4)" reduces to "so (true)" which reduces to "()"
19:52:11 <roconnor> bparkis: thus () :: "so (2 + 2 == 4)"
19:52:27 <eyeris> Haskell number classes drive me nuts. All I want to do is take a SLsizei (Int32), divide it by 2, and use it as a GLsizei again.
19:52:31 <roconnor> bparkis: however "so (2 + 2 == 5)" reduces to "so (false)" which reduces to "Void"
19:52:51 <ddarius> eyeris: (`div` 2)
19:52:55 <roconnor> bparkis: and there is no member of Void; hence there is no member of "so (2 + 2 == 5)"
19:53:14 <eyeris> omg
19:53:27 <eyeris> (/) != div
19:53:31 <bparkis> ok
19:53:33 <faxathisia> roconnor, I can't figure out this repo.. darcs get http://www.fnds.cs.ru.nl/fnds-arch/roconnor/Nijmegen/CoRN--roconnor-dev--3/ # doesn't work :[
19:53:34 <lambdabot> Title: Index of /fnds-arch/roconnor/Nijmegen/CoRN--roconnor-dev--3, http://tinyurl.com/3aq7j6
19:53:37 <eyeris> what idiotic naming
19:53:41 <wagle_home> eyeris, `div`
19:54:02 <monochrom> What's wrong?
19:54:03 <Cale> eyeris: hm?
19:54:11 <roconnor> bparkis: now suppose we define + as follows:  0 + m = m and S n + m = S (n + m)
19:54:14 <Cale> eyeris: (/) and div are not the same thing
19:54:21 <monochrom> Don't you think it is C who commits idiotic naming?
19:54:33 <roconnor> bparkis: and how we want to prove that (forall n, n + 0 == n)
19:54:34 <eyeris> Cale right
19:54:42 <bparkis> so am I getting this right, what you're saying is that given a correct lambda form for sqrt, agda would be able to automatically determine that the output squared is the input?
19:54:45 <roconnor> bparkis: what we do is define a recursive functio no n.
19:54:47 <monochrom> Or are you one of those brainwashed people who worship C?
19:54:48 <eyeris> Cale but, in the real world, everyone would expect them to
19:54:53 <roconnor> bparkis: call this function lemma1
19:55:00 <faxathisia> bparkis: Agda isn't the issue
19:55:05 <Cale> Maybe you're not in the real world anymore, whatever that is.
19:55:06 <monochrom> OK, you are.
19:55:16 <roconnor> bparkis: lemma1 :: forall n, n + 0 == n
19:55:17 <faxathisia> bparkis: This is all valid in any dependently typed language
19:55:25 <eyeris> haha
19:55:25 <bparkis> agda or some other language that works in the same way, ok
19:55:26 <roconnor> bparkis: lemma1 0 = ()
19:55:38 <roconnor> bparkis: lemma1 (S n) = lemma1 n
19:55:39 <Cale> eyeris: (/) performs a completely different operation from what div performs
19:55:51 <roconnor> bparkis: now let us type check this
19:56:10 <ddarius> bparkis: Yes, except it will either need to have some decision procedure for arithmetic or you will have to spell out multiplication to it to actually state the theorem.
19:56:15 <roconnor> bparkis: lemma1 0 should have type "so (0 + 0 == 0)"
19:56:49 <roconnor> bparkis: and "so (0 + 0 == 0)" reduces "so (true)" which reduces to "()"
19:56:52 <Cale> eyeris: div is division with remainder (given by mod), whereas (/) is essentially multiplication by the inverse.
19:57:02 <ddarius> bparkis: Also you'd give the type (theorem) that the lambda term is proving.
19:57:07 <roconnor> bparkis: lemma1 0 is defined to be () and () :: (), so we are good.
19:57:18 <Cale> eyeris: Confusing the two would be a bug.
19:57:28 <Cale> (almost certainly, in any context)
19:57:31 <eyeris> Cale: right, but when you talk about (/), what do you call it?
19:57:33 <roconnor> bparkis: lemma1 (S n) needs to have type "so (S n + 0 == S n)"
19:58:08 <roconnor> bparkis: "so (S n + 0 == S n)" reduces to "so (S (n + 0) == S n)" by the definition of +
19:58:10 <monochrom> slash
19:58:11 <Cale> eyeris: Well, yes, it's also *called* division. But it corresponds to a completely different definition in mathematics.
19:58:31 <roconnor> bparkis: and "so (S (n + 0) == S n)" reduces to "(n + 0) == n" by the defintion of ==
19:58:38 <monochrom> If you will, the English word "division" is also idiotic naming.
19:58:40 <faxathisia> eyeris, I call it /
19:58:53 <eyeris> idiv and fdiv would be infinitely better names imo
19:59:00 <roconnor> bparkis: lemma1 (S n) is defiend as lemma1 n which has type "so (n + 0) == n" as required.
19:59:08 <roconnor> bparkis: and thus lemma1 type checks
19:59:12 <Cale> eyeris: f for fractional?
19:59:12 <faxathisia> eyeris, I prefer / and `div` but you can define idiv and fdiv
19:59:17 <roconnor> bparkis: lemma1 :: forall n, (n + 0 == n)
19:59:22 <eyeris> Cale: yes
19:59:28 <roconnor> bparkis: and that is our proof that n + 0 == n for all n.
19:59:40 <roconnor> faxathisia: it isn't a darcs repository it is an arch repository :(
19:59:43 <monochrom> I also prefer / and div, following mathematicians, who are not idiotic on this.
19:59:47 <Saizan> roconnor: where "so" comes into play here?
19:59:50 <faxathisia> oh ok, I'll try to get arch
20:00:16 <roconnor> Saizan: oops, good point.  lemma1 :: forall n, so (n + 0 == n)
20:00:36 <roconnor> Saizan: I think I may have accidently droped it a few times.
20:00:39 <bos> @seen dcoutts_
20:00:39 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts_ speak 49m 59s ago.
20:00:39 <Cale> In fact, in my mathematics courses, I don't think we ever even defined integer division as a function.
20:00:52 <bparkis> wait a second roconnor how do you conclude (n + 0) = n solely from S (n + 0) == S n and the definition of ==
20:00:55 <monochrom> I wonder what eyeris's opinion is on ^, ^^, **
20:01:09 <roconnor> bparkis: 0 == 0 = True
20:01:20 <roconnor> bparkis: S n == S m = n == m
20:01:24 <bparkis> don't you also need that S is 1-1
20:01:28 <roconnor> bparkis: _ == _ = False
20:01:39 <ddarius> bparkis: He's just using the definition of (==) he provided.
20:01:49 <monochrom> Cale: No explicitly, but implicitly discussed as in "division theorems".
20:01:55 <Cale> It was a theorem which said that given any two integers a and b with b not equal to 0 there exist unique integers q and r such that a = qb + r and 0 <= r < |b|
20:02:00 <roconnor> bparkis: in this case we are using pattern 2 in the definition of ==
20:02:07 <monochrom> Yes, that one.
20:02:24 <Cale> and we'd just explicitly apply that theorem when it was needed.
20:02:31 <roconnor> bparkis: (sorry, I forgot to include the definition of == before we began)
20:02:36 <ddarius> Also, it is known in this case that S is injective (by construction), we can pattern match against it.
20:03:09 <roconnor> bparkis: I should also mention that I am using data Nat = 0 | S Nat
20:03:28 <monochrom> My grade school used ÷ for div.
20:03:55 <faxathisia> um.. Ignore the Ada nonsense on this page
20:03:57 <faxathisia> http://rosettacode.org/wiki/Evens_Sum_To_Even
20:03:58 <lambdabot> Title: Evens Sum To Even - Rosetta Code
20:03:59 <bparkis> now how does the type checker decide which reduction to use at each step
20:04:15 <faxathisia> but there's another example of a proof with deptypes in a few different languaes
20:04:17 <ddarius> bparkis: It evaluates the code.
20:04:25 <bparkis> there is only 1 choice?
20:04:28 <ddarius> (partially)
20:04:40 <faxathisia> bparkis: Every function is total and has a unique normal form
20:04:42 <roconnor> bparkis: it evaluates the terms down to normal form (in principle)
20:04:50 <faxathisia> bparkis: That lets us use computation in proofs
20:04:54 <faxathisia> e.g
20:04:56 <ddarius> bparkis: No, but it doesn't matter because the typed lambda calculus is Church-Rosser.
20:05:13 <faxathisia> trivial : (36 - 6)/2 == 15
20:05:16 <roconnor> bparkis: by replacing general recursion with structural recursion we guarentee that all our functions terminate.
20:05:18 <faxathisia> trivial = refl
20:05:46 <roconnor> bparkis: as ddarius notes, there is a unique normal form for all reduction strategies.
20:06:06 <faxathisia> (it's evens sum to even in Coq Omega Agda2 and Twelf.. would be nice to have a Epigram one too)
20:06:09 <Cale> a/b was specifically defined to mean ac where c is chosen to be the unique number such that bc = 1. If no such number exists then a/b is undefined.
20:08:39 <bparkis> lemma1 seems a little shorter than what you would write down if you were proving it on paper
20:09:09 <roconnor> bparkis: indeed, we can take advantage of computation for free.
20:09:18 <roconnor> (to a certain extent)
20:09:44 <bparkis> ok
20:09:54 <faxathisia> bparkis, did you see the wiki link?
20:10:06 <bparkis> evens sum to even?
20:10:21 <Saizan> roconnor: with forall n. so (n + 0 == n) we have forall n. (n + 0 == 0) because (so b) is provable only if b is true?
20:10:27 <gwern> @hoogle Foreign
20:10:27 <lambdabot> Foreign :: module
20:10:27 <lambdabot> Language.Haskell.TH.Foreign :: data Foreign
20:10:27 <lambdabot> Language.Haskell.TH.Syntax.Foreign :: data Foreign
20:10:45 <gwern> I was thinking of uploading Agda to Hackage, but the funny thing is, it dependds on QuickCheck >= 2 < 3
20:11:39 <roconnor> Saizan: forall n. (n + 0 == 0) is not well defined because (n + 0 == 0) has type Bool, and should have kind type.
20:12:22 <gwern> @hoogle Types
20:12:22 <lambdabot> Foreign.C.Types :: module
20:12:22 <lambdabot> System.Posix.Types :: module
20:12:22 <lambdabot> Distribution.Extension.TypeSynonymInstances :: Extension
20:13:12 <roconnor> Saizan: unless you were accidently dropping "so" like I was. :)
20:13:49 <roconnor> lemma2 : forall n m, so (n == m) -> so (m == n)
20:14:04 <roconnor> lemma2 0 0 _ = ()
20:14:04 <Saizan> roconnor: ah right, "so" maps true/false from terms to types
20:14:25 <roconnor> lemma2 (S n) (S m) H = lemma2 n m H
20:14:39 <roconnor> lemma2 O (S m) H = void H
20:14:48 <roconnor> lemma2 (S m) O H = void H
20:14:55 <roconnor> where void :: Void -> a
20:15:12 <gwern> good news everyone!
20:15:20 <gwern> we can now play tetris in haskell: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hetris-0.1
20:15:21 <lambdabot> http://tinyurl.com/29rrgm
20:15:40 <Zao> gwern: Didn't dons do a tetris before?
20:15:53 <Zao> I've got me an unreleased OpenGL xtris client as well.
20:15:58 <monochrom> curses?!
20:16:04 <gwern> Zao: you shut your filthy mouth and never open it again >.< I spent hours getting that to build through cabal
20:16:32 <faxathisia> :S
20:16:34 <faxathisia> hetris: curses returned an error
20:16:45 <monochrom> haha, already :)
20:16:47 <faxathisia> It built though
20:16:53 <bparkis> ok
20:16:57 <bparkis> I think I get it
20:17:37 <bparkis> thanks everyone especially roconnor and faxathisia
20:17:54 <faxathisia> bparkis, this is fun http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.TypesSummerSchool2007 but you should check try the Coq tutorial as well
20:17:56 <lambdabot> Title: 28 The Agda Wiki - Types Summer School 2007 4b, http://tinyurl.com/yuktth
20:18:40 <gwern> Zao: but seriously, I know of no tetris game by dons
20:20:03 <gwern> Zao: also, release your client pls
20:20:51 <gwern> (or if it's in a sufficently working and functional state, give it to me under a Free license, and I'll release it :)
20:22:27 <Zao> gwern: When I get around finishing the local logic part and the code doesn't make lambdacats cry, sure.
20:22:40 <Zao> It only spectates network games thus far.
20:23:22 <gwern> alright
20:23:32 <Zao> teaser - http://www.acc.umu.se/~zao/Hastris/img/screen03.png
20:23:34 * gwern will put on my list, though - beware!
20:23:40 <gwern> *put you
20:23:45 <Saizan> "think of the lambdakittens"?
20:23:49 <gwern> nice
20:23:58 <gwern> @where lamdacats
20:23:58 <lambdabot> I know nothing about lamdacats.
20:24:00 <gwern> @where lamddacats
20:24:00 <lambdabot> I know nothing about lamddacats.
20:24:04 <gwern> @where lambdacats
20:24:04 <lambdabot> http://arcanux.org/lambdacats.html
20:24:18 <gwern> oh new one
20:25:14 <wagle_home> i liked the first cat here: http://arcanux.org/lambdacats_2.html
20:25:15 <lambdabot> Title: Lambdacats
20:25:44 <wagle_home> hmm.. its changed.. i mean the second
20:27:31 <gwern> the trapped one has always spoken to me
20:28:39 <Zao> gwern: Must've been a misgrokking of http://www.haskell.org/pipermail/haskell-cafe/2007-November/034964.html or something.
20:28:41 <lambdabot> Title: [Haskell-cafe] Tetris, http://tinyurl.com/2ed9bm
20:28:59 <gwern> first hit for 'don stewart tetris' anyway
20:31:28 <radix> you guys have your own lolcat page? geeze. haskell totally owns python.
20:31:42 <mrd> lambdacats
20:31:46 * Nafai tries the new Haskell for OS X package
20:32:05 <wagle_home> Nafai, eh?
20:32:21 <Nafai> http://www.haskell.org/pipermail/glasgow-haskell-users/2008-February/014298.html
20:32:22 <lambdabot> Title: ANN: Mac installer pkg for GHC - 6.8.2.20080211 trial release (Leopard, Intel), http://tinyurl.com/23km8g
20:33:52 <wagle_home> evillllll!  (/me has ppc mac)
20:34:21 * wagle_home should get off his lazy duff and port the silly thing
20:36:29 <wagle_home> (thanks for the url, Nafai )
20:38:31 <wli> wagle_home: I just read about Orson Scott Card and Ursula K. Leguin on wikipedia (not sure what led me to the second author). Not sure I could handle reading their actual stuff, but anyhow, what am I looking for?
20:38:48 <roconnor> i kant haskell today, i has the dumb.
20:39:40 <gwern> 'Gödel's incompleteness theorem would make a snazzy T-shirt design. "Formulations of number theory: Complete, Consistent, Non-trivial. Choose two."'
20:40:02 * gwern helped suggest the wording for that one
20:40:24 <roconnor> gwern: you can get all three.
20:40:42 <roconnor> gwern: if you get a side order of undecidable.
20:41:16 <gwern> not an option :)
20:41:21 <olsner> heh, that could be the back side of the t-shirt
20:44:59 <wagle_home> wli, havent read ursula in a long time..  liked some card's books of short stories maybe 10-15 years ago and liked them.  read ender series and bean series recently, and liked them..  read the home series, and while i finished it, I couldnt stand to read any more of his novels
20:45:09 <olsner> I'm starting to figure out how this gzip quine works... and starting to wonder how far gzip is from actually being turing complete
20:45:46 <SamB> olsner: the lack of input must be a factor
20:45:55 <faxathisia> gzip has input......
20:46:25 <olsner> you just tack the input at the end of the program and hey presto, anything has input!
20:46:36 <SamB> the end?
20:47:20 <gwern> wli: le guin is a strange and imaginative author, although I'd ignore anything a critic says - her short stories are better than her novels (for example The left hand of darkness is praised to the skies, but it left me cold)
20:47:38 <olsner> or in any other "input part" of the program... point being, I don't think it's necessary to have external input for it to be TC
20:48:13 <oerjan> olsner: lambda calculus doesn't have input, really
20:48:26 <wagle_home> free variables?
20:48:50 <faxathisia> It's about computation class... not how easy it is to write an MP3 player in
20:48:55 <faxathisia> computational
20:48:58 <oerjan> it cannot do any with free variables, so that doesn't matter
20:49:17 <gwern> @where lambdacats
20:49:17 <lambdabot> http://arcanux.org/lambdacats.html
20:49:23 <wagle_home> depends on what the free variables mean, and what you do with them
20:49:40 <faxathisia> wagle: Not really
20:49:54 <oerjan> wagle_home: any meaning to free variables is not a part of basic lambda calculus
20:49:58 <wli> gwern: I remember enough of fiction to know better than to try anymore.
20:50:07 <eyeris> `Color4 1.0 0.0 0.0 1.0` fails due to a ambiguous type error. Adding an explicit type after each literal causes a syntax error on the second type unless I wrap each literal+type in parens. Isn't there a simpler way?
20:50:46 <oerjan> eyeris: what should the types be?
20:51:03 <wagle_home> i dont recall using the word basic
20:51:13 <oerjan> and what is the class they belong to
20:51:14 <gwern> wli: it's not always true, some authors are suitable for critics - gene wolfe gets reviewed pretty accurately, for example, even though he's probably much better than leguin
20:52:00 <gwern> @where haskellnet
20:52:00 <lambdabot> I know nothing about haskellnet.
20:52:04 <gwern> @where HaskellNet
20:52:05 <lambdabot> I know nothing about haskellnet.
20:52:26 <oerjan> eyeris: you must be doing something strange if they don't simply default to Double, or get inferred from the final type
20:52:27 <eyeris> oerjan: 1.0 and 0.0 are in the Fractional class. ColorComponent has an instance for both Float and Double.
20:52:58 <oerjan> eyeris: what is the definition of ColorComponent?
20:53:30 <oerjan> (the main and Color4 parts, anyhow)
20:54:34 <eyeris> oerjan there are no functions defined in it.
20:54:49 <oerjan> eyeris: sheesh the data definition
20:55:04 <oerjan> oh wait
20:55:05 <eyeris> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-VertexSpec.html#t%3AColorComponent
20:55:06 <lambdabot> http://tinyurl.com/2zxeod
20:55:22 <wli> gwern: I'm not really into fiction of any kind, science fiction or otherwise.
20:55:28 <oerjan> eyeris: try enabling ExtendedDefaulting (or something like that)
20:55:59 <gwern> wli: boo hiss! fie on thee
20:56:08 <oerjan> um wait, it's not really Float and Double is it?
20:57:01 <eyeris> GLfloat = Float
20:57:03 <oerjan> eyeris: try to put the annotation on the whole type.  Color4 1.0 0.0 0.0 1.0 :: Color4 GLDouble or whatever
20:57:15 <oerjan> it is?
20:57:26 <oerjan> well then extended defaulting should work too
20:57:58 <oerjan> but also, the type of the fields should be inferred if the type of the whole is fixed
20:59:06 <eyeris> This is weird
20:59:12 <eyeris> it works fine if I just type it into ghci
20:59:34 <oerjan> yes, because ghci has extended defaulting by default
20:59:48 <eyeris> but not in this code: whiteSquare = do color $ Color4 1.0 0.0 0.0 1.0
21:00:00 <gwern> anyone know what 'HaskellNet' is supposed to be?
21:01:21 <eyeris> oerjan nevermind. I guess I'm supposed to use: currentColor $= Color4 1.0 0.0 0.0 1.0
21:01:40 <oerjan> eyeris: ah, the type of the Color4 does not escape
21:02:23 <oerjan> so it is not fixed, and ordinary unextended defaulting can only handle H98's builtin classes
21:02:28 <eyeris> I still don't know why ghci can't infer the types of the literals in `color $ Color4 1.0 0.0 0.0 1.0` but it can in `currentColor $= Color4 1.0 0.0 0.0 1.0` though because the Color4 argument bindings should occur before both $ and $=, right?
21:03:16 <oerjan> eyeris: the type of color $ Color4 1.0 0.0 0.0 1.0 is IO ().  i.e. the actual ColorComponent used does not escape into the type of the whole expression
21:03:33 <oerjan> this means that it cannot be inferred from use
21:04:05 <faxathisia> why not just write redColor
21:04:14 <faxathisia> or something.. for some suitably defined red.
21:04:27 <oerjan> but in the second, the type is probably inferred from the types of later uses of currentColor
21:04:44 <eyeris> oerjan ok, thanks
21:13:27 <noige_> jeez
21:13:32 <noige_> we had an outage tonight
21:13:45 <noige_> every customer on our bigips went down
21:13:49 <noige_> ...
21:13:57 <noige_> finally... back to soe
21:22:59 <monochrom> My mind has melted
21:24:17 <ddarius> monochrom: Good thing it isn't necessary in modern society.
21:24:40 <gwern> @seen shapr
21:24:40 <wy> phew! the bug is found... The grammar is not in LR(1), it is LR(2)
21:24:41 <lambdabot> shapr is in #haskell, #scannedinavian and #haskell-blah. I last heard shapr speak 4h 25m 18s ago.
21:25:56 <gwern> @tell shapr spj-unicycle-paolo2.jpeg is kind of amusing; maybe you could give it to me under a Free license and I could add it into the WP article? together with https://secure.wikimedia.org/wikipedia/en/wiki/Image:Simon_Peyton_Jones_01.jpg we might have the start of some 'loljones'
21:25:57 <lambdabot> Consider it noted.
21:31:06 <hpaste>  monochrom pasted "reset-shift mind melt" at http://hpaste.org/5833
21:38:27 <faxathisia> @free foldr
21:38:35 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
21:42:16 <monochrom> @free will
21:42:17 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `will'\n\n"
21:42:28 <monochrom> hehe
21:42:58 <monochrom> @free turkey
21:42:59 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `turkey'\n\n"
21:43:12 <monochrom> It says free turkey comes with extra stuffing!
21:43:55 <dons> ?free sortBy
21:43:56 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
21:44:07 <dons> ?free the air
21:44:07 <lambdabot> Extra stuff at end of line
21:44:15 <sclv> oh: my solution for a "msum" throwing away side effects? a monoid instance! I think this should work:
21:44:16 <sclv>     mappend a b = maybe b (const a) =<< a
21:44:16 <sclv>     mempty = return Nothing
21:44:43 <sclv> actually, now that I've pasted it, bleh.
21:45:13 <sclv> I fear this will be a royal pain.
21:45:38 <hpaste>  calvins pasted "Type of 's f = f f'" at http://hpaste.org/5834
21:46:26 <calvins> Anybody have any suggestions about the simple snippet I just pasted?
21:46:38 <wy> Ah, I realized that as if the real function of a scanner is to reduce the need for lookahead for a parser
21:47:09 <ddarius> calvins: That's the not the type.  To type that will go beyond Haskell 98.
21:47:26 <wy> Is this true?
21:47:53 <ddarius> wy: That's one of the benefits.
21:47:56 <sclv> monochrom: my own code melts my mind enough. thanks for the headache! :-)
21:48:07 <monochrom> haha
21:48:08 <wy> ddarius: ahha!
21:48:14 <calvins> ddarius: are you saying it's not possible to type that function in Haskell 98?
21:48:31 <calvins> It's an exercise in Bird's Introduction to Functional Programming
21:48:51 <ddarius> calvins: Modulo type classes and polymorphic recursion all types in Haskell 98 are inferrable.
21:48:53 <wy> ddarius: because if we don't use a scanner, the parser will often have to look ahead for very long
21:48:55 <oerjan> sclv: Maybe already has both MonadPlus and Monoid instances, which are inconsistent.
21:49:36 <sclv> oerjan: right, but this is for something of (essentially) (WriterT IO (Maybe a))
21:49:56 <calvins> Why doesn't the type I gave work? It seems like either '(a -> a) -> (a -> a)' or '(a -> b) -> (a -> b)' should work
21:50:16 <monochrom> :t id id
21:50:20 <lambdabot> forall a. a -> a
21:50:26 <sclv> The challenge is to take [WriterT IO (Maybe a)] and produce the first Just, discarding the WriterT side effects.
21:50:43 <monochrom> id is a witness that "f f" is ok.
21:50:45 <sclv> (side effects of the actions that produce Nothing, that is)
21:50:46 <ddarius> calvins: That first type says that I can choose any type for 'a' I want.  Let's say I choose Int, then f :: Int -> Int and f :: Int
21:50:48 <dons> ?yow!
21:50:49 <lambdabot> I wish I was on a Cincinnati street corner holding a clean dog!
21:51:00 <ddarius> monochrom: But not a witness that it is okay with that type.
21:51:11 <monochrom> Alright.
21:53:03 <calvins> id id is what made me think it was that type
21:53:14 <cjs_> Hm. How do I make http://paste.lisp.org/display/56359  a bit cleaner, by somehow getting rid of the tests = ... stuff?
21:53:36 <oerjan> calvins: in id id, the two id's don't actually have the same (monomorphic) type.
21:53:44 <calvins> What do you think Bird is expecting as an answer to that exercise? It's in chapter 1, so you're not expected to know anything advanced yet.
21:53:55 <oerjan> you need at least a forall to get at typing at all
21:54:03 <monochrom> This type is tricky to infer.  In the inference, you have to keep inventing new free variables and avoid variable capture, lest you mistakenly think you get an infinite type.
21:54:05 <sclv> ?ty let stranger (f::(forall a. a->a))   =  f f in stranger
21:54:05 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
21:55:05 <sclv> oerjan: you don't have any neat answers to my problem, by any chance, do you?
21:55:45 <sclv> I wonder if ditching the Maybes and using msum with exceptions would be an answer...
21:55:56 <oerjan> sclv: throwing away an action based on what it produces is not something that can be done with an arbitrary monad, e.g. IO
21:56:27 <oerjan> you could throw away everything _after_ the Nothing with a bit of ErrorT
21:56:50 <sclv> right: I only expect to throw away the WriterT actions. except things are messier because the WriterT is wrapped in the durn CGIT type.
21:57:04 <sclv> I think my current solution tosses everything after the nothing too.
21:57:53 <oerjan> sclv: now WriterT may be fairly easy, since one action does not affect the effect of another
21:58:16 <oerjan> er, the effect of one action
21:59:56 <oerjan> anyway for bailing out my first inclination is ErrorT.
22:00:51 <sclv> right.. but that keeps the tells from the Nothing results, right? eh. it might be close enough.
22:00:58 <oerjan> er yeah
22:01:08 <oerjan> hm
22:01:12 <noige_> is hugs or ghci the standard?
22:01:28 <ddarius> mu
22:01:39 <sclv> after you pointed the issue out this morning in another context i was stressed about it all day. :-)
22:02:05 <oerjan> if you didn't wrap in CGIT then it would be easy to manipulate WriterT directly
22:02:16 <oerjan> (as data)
22:02:42 <oerjan> oh wait
22:02:47 <oerjan> :t listen
22:02:49 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
22:03:32 <sclv> hmm... I wonder if I can get at that with the silly CGIT wrapper in the way. I have to just go ahead and delve into the internals when I want to resolve this.
22:04:09 <oerjan> sclv: ah, you _should_ be able to use listen and pass to modify the writer action
22:04:30 <sclv> Speaking of which, I got all grumpy at Takusen today because its data-hiding was too good. there are stuff you can't get at with importing internal...
22:06:00 <oerjan> sclv: ah, pass is what you need i think
22:06:15 <sclv> hmm.. so ok, CGIT is: ReaderT CGIRequest (Control.Monad.Writer.Lazy.WriterT Network.CGI.Protocol.Headers m) a
22:06:17 <oerjan> no need to go at internals
22:06:41 <calvins> on the topic of "stranger f = f f", am I understanding it correctly that there is no way in Haskell to assign a type and make it type-check in GHC? That seems reasonable to me know, since I notice that my purported solution had, as with id id, type '(a -> a)', but there was not a single 'a' that was valid for the entire function.
22:07:19 <calvins> Is that the 'monomorphism restriction' that I keep hearing about? Or is that something else?
22:07:23 <ddarius> calvins: No, there's no way to do it in Haskell 98.  GHC isn't (just) Haskell 98.  It's quite easy to do with extensions.
22:07:38 <oerjan> :t let stranger :: (forall a. a -> a) -> (forall a. a -> a); stranger f = f f in stranger
22:07:41 <calvins> ah okay, what are the relevant extensions?
22:07:51 <ddarius> calvins: rank-2 types
22:07:54 <lambdabot> thread killed
22:08:27 <oerjan> :t let stranger :: (forall a. a -> a) -> (forall a. a -> a); stranger f = f f in stranger
22:08:28 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
22:08:42 <calvins> hmm, thanks. Is the reason it's not possible because it isn't possible to assign a single type 'a' to both appearances of the function on the right side of the equation?
22:08:54 <oerjan> exactly
22:09:11 <calvins> And is that what is meant by "monomorphism restriction"?
22:09:15 <oerjan> no
22:10:01 <calvins> okay, thanks, will read some more, but I do understand why this one doesn't work. Kind of an evil exercise for chapter 1 of an intro book ;-)
22:10:14 <dmwit> Wait till chapter 2. ;-)
22:10:26 <oerjan> this is just the usual HM typing rule:  arguments to functions are never polymorphic
22:10:56 <oerjan> the monomorphism restriction is about some cases where even let-bound variables are not polymorphic
22:11:11 <oerjan> (and is a Haskell adjustment)
22:11:39 <calvins> Okay, makes a lot more sense now. thanks everybody...
22:14:01 <oerjan> :t \x -> pass (do m <- x; case m of Nothing -> (m, const mempty); Just x -> (m, id)
22:14:03 <lambdabot> parse error (possibly incorrect indentation)
22:14:11 <oerjan> :t \x -> pass $ do m <- x; case m of Nothing -> (m, const mempty); Just x -> (m, id)
22:14:12 <lambdabot>     Couldn't match expected type `(a, w -> w)'
22:14:12 <lambdabot>            against inferred type `b -> a1'
22:14:12 <lambdabot>       Expected type: (Maybe t, (a, w -> w))
22:14:28 <oerjan> :t \x -> pass $ do m <- x; case m of Nothing -> return (m, const mempty); Just x -> return (m, id)
22:14:31 <lambdabot> forall (m :: * -> *) t a. (MonadWriter a m) => m (Maybe t) -> m (Maybe t)
22:14:45 <noige_> let listSum(x:xs) = x + listSum xs
22:14:48 <sclv> ooh.
22:14:51 <noige_>  listSum [1,2,3]
22:14:51 <noige_> *** Exception: <interactive>:1:4-33: Non-exhaustive patterns in function listSum
22:14:57 <noige_> wryyyyy
22:15:35 <oerjan> sclv: it removes any writer effects if the result was Nothing (or so i think)
22:15:54 <sclv> nice... now I just need to write a MonadWriter instance for CGIT. :-)
22:16:19 <dons> ?users
22:16:19 <lambdabot> Maximum users seen in #haskell: 471, currently: 396 (84.1%), active: 10 (2.5%)
22:16:23 <oerjan> noige_: forgetting [] case ?
22:18:55 <dons> Lemmih: hey, let's get your blog on planet haskell!
22:19:10 <noige_> oerjan: an empty list
22:19:16 <oerjan> yes
22:19:19 <noige_> oerjan: I am new
22:19:35 <dons> Lemmih: oh, re. the performance issue with Map and bytestring, that was fixed yesterday
22:19:47 <dons> the inlining was screwed up in the Ord instance
22:19:54 <cjs_> What was the trick again with Hugs or ghci to let you enter definitions at the interpreter prompt, e.g., "f = 10"?
22:20:12 <oerjan> cjs_: ghci: let f = 10.  hugs, not available.
22:20:13 <dons> let f = 10
22:20:27 <cjs_> Ah, i was just typing it into the wrong interpreter. Thanks.
22:25:34 <glguy> ?seen dons
22:25:34 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 5m 21s ago.
22:25:39 <glguy> dons:
22:27:14 <noige_> problem
22:27:15 <noige_>  listSum :: [Float] -> Float
22:27:32 <noige_> the book is telling me this is valid, but I thought I have to define listSum first.
22:27:37 <noige_> :t  listSum :: [Float] -> Float
22:27:39 <lambdabot> Not in scope: `listSum'
22:27:48 <oerjan> yeah you're right
22:28:15 <oerjan> it probably just means it's a valid type declaration
22:28:22 <noige_> I must be misunderstanding something here
22:28:41 <dons> glguy: yo
22:28:47 <dons> hungry?
22:28:50 <glguy> mind converting a darcs repo for me?
22:28:55 <dons> sure. which one ? :)
22:29:00 <glguy> dons: I'll start eating more when you start eating more meat!
22:29:05 <glguy> hpaste
22:29:10 <wagle_home> ? sum
22:29:11 <oerjan> oh and it's not valid alone in :t anyway, it's a declaration not an expression
22:29:14 * dons chases glguy with a lettuce
22:29:16 <wagle_home> :t sum
22:29:17 <lambdabot> forall a. (Num a) => [a] -> a
22:29:25 * glguy wards dons off with beef
22:29:28 <noige_> oerjan: ok so let ...
22:29:39 * dons stabs with a carrot
22:29:45 <glguy> noooo
22:29:48 <oerjan> :t let listSum :: [Float] -> Float; listSum = undefined {- to be defined -} in listSum
22:29:49 <lambdabot> [Float] -> Float
22:30:46 <glguy> hmm, methinks isaac didn't actually install git
22:30:48 * oerjan throws gammelost into the fight
22:30:58 <dons> git clone http://www.cse.unsw.edu.au/~dons/git/hpaste
22:31:02 <noige_> man ok
22:31:25 <glguy> dons: thanks
22:52:56 <glguy> dons: I think you imported an older version..
22:53:00 <glguy> converted.
22:54:03 <dons> hmm. oh, it might have been cached in the proxy
22:54:15 <dons> want me to try again?
22:54:29 <glguy> if you don't mind...
22:54:29 <dons> last commit was Date:   Fri Feb 22 12:57 ?
22:54:40 <dons> gimme 5 mins
22:54:53 <glguy> Fri Feb 22 14:57:01 PST 2008  Eric Mertens <emertens@gmail.com>
22:54:55 <glguy>   * HTML cleanups
22:55:09 <dons> how many patches do you get on a darcs pull?
22:56:55 <glguy> 46
22:57:13 <dons> underway..
22:58:04 <dons> oh, it just redates it based on .au localtime
22:58:10 <dons>  git clone http://www.cse.unsw.edu.au/~dons/git/hpaste
22:58:59 <dons> look right?
22:59:07 <noige_> does anyone have School of Expression near them?
22:59:55 <glguy> dons: you were fine
22:59:58 <glguy> I had unrecorded changes
23:00:02 <glguy> m'bad
23:00:10 <dons> ah ok. well, it's redone anyway
23:00:16 <glguy> thank you kindly :)
23:00:22 <dons> glguy: you going to to wipe the one on code, and gitify it/
23:00:32 <glguy> we don't have git on code
23:00:36 <dons> oh hmm.
23:00:48 <dons> syntax ninja did install it. is it just not in your path?
23:01:38 <dons> oh, i wonder, it probably clashes with that silly git
23:01:53 <dons> glguy: i see lots of git-*
23:02:03 <glguy> which git-init ?
23:02:06 <dons> /usr/bin/git-init-db
23:02:19 <glguy> what version is *that*?
23:03:06 <dons> my debian-fu is weak
23:03:58 <chadz> what's the nicest odbc interface?
23:04:16 <dons> does takusen have one?
23:04:24 <cjs_> How do I do the equivalant of "import Test.HUnit" in ghci, so I can play with its functions and check out its types?
23:04:31 <dons> :m +
23:04:43 <dons> chadz: i'd probably try takusen
23:04:50 <dons> its the most haskelly (i.e. typed queries)
23:05:01 <dons> but i've not tried the odbc backedn
23:05:11 <chadz> haven't heard of it, reading now.
23:05:16 <cjs_> Thanks.
23:05:17 <noige_> This is killing me, the book say to write this: x :: Integer, this throws an error. I understand what it means, it means that x is of type Integer
23:05:17 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Takusen-0.7
23:05:18 <lambdabot> http://tinyurl.com/ysglmf
23:05:28 <dons> noige_: right.
23:05:36 <dons> > let x :: Integer ; x = 7  in x += x
23:05:38 <dons> > let x :: Integer ; x = 7  in x + x
23:05:38 <lambdabot>   Not in scope: `+='
23:05:40 <lambdabot>  14
23:06:00 <noige_> after x :: Integer it goes on to define x = f etc in a let expression
23:06:08 <glguy> dons: the git repo is public on code. now
23:06:15 <dons> awesome bananas
23:06:16 <noige_> my understanding is that definition only comes after a let
23:06:23 <oerjan> noige_: perhaps the book means to put some things in a file?
23:06:30 <glguy> the git version is old bananas though
23:06:33 <dons> git-update-server-info ?
23:06:43 <glguy> ah, I need ot set that hook for web access
23:06:46 <glguy> one moment
23:06:48 <oerjan> in a module file, declarations go directly
23:06:56 <dons> git-update-server-info should do the job
23:06:57 <chadz> noige_: sometimes, the compiler just can't infer enough information for a variable
23:07:04 <dons> and that other tweak to the config, whatever it is
23:07:12 <noige_> well this is from the school of expression book
23:07:20 <dons> let x :: Integer
23:07:23 <dons>     x = 7
23:07:24 <dons> in x
23:07:24 <noige_> and it is telling me to write things like x :: Integer
23:07:34 <Cale> noige_: Where are you trying to write that?
23:07:35 <noige_> but I know that assignment happens after let
23:07:37 <glguy> dons: done?
23:07:45 <noige_> Cale: first
23:07:48 <dons> nope, work for you glguy ?
23:07:50 <noige_> so:
23:07:53 <dons> git clone http://code.haskell.org/hpaste ?
23:08:04 <noige_> x :: [Integer]
23:08:07 <Cale> noige_: I mean, I'm just checking that you're not typing this directly into ghci
23:08:07 <oerjan> noige_: i don't know the book but it may not be very clear on the distinction between what you can write in the interpreter and what you can write in a file
23:08:11 <noige_> (a list of ints)
23:08:18 <noige_> I am
23:08:23 <noige_> right into ghci
23:08:26 <noige_> haha
23:08:28 <Cale> noige_: Declarations go into files, and you load them into ghci
23:08:34 <noige_> oh man
23:08:36 <Cale> (where you can try them out)
23:08:37 <noige_> ok
23:08:43 <noige_> time to rtfm
23:08:49 <noige_> I forgot that important step
23:08:59 <Cale> It's good to keep your editor open alongside your ghci window
23:09:04 <noige_> oh ok
23:09:07 <Cale> When you save the file, just type :r in ghci
23:09:10 <Cale> and it'll reload
23:09:14 <chadz> noige_: you can specify any variable as a type manually, and sometimes you need to do it to help it along.
23:09:20 <noige_> time for some hardcore screen action
23:09:27 <glguy> dons: ok, now it's working
23:09:28 <Cale> hehe
23:09:37 <chadz> > -1
23:09:39 <lambdabot>  -1
23:09:39 <mauke> lambdapron
23:09:40 <dons> confirmed, glguy
23:09:42 <chadz> > -1 :: Word32
23:09:43 <lambdabot>  4294967295
23:09:47 <glguy> I need to pack the repo though
23:09:52 <glguy> so that you don't have to do all the walking and whatnot
23:09:56 <dons> ah right.
23:09:57 <dons> silly git
23:10:00 <noige_> Cale: thanks, I thought I was stupid
23:10:25 <Cale> noige_: It's a common mistake.
23:11:33 <Cale> I should really see what can be done about a nice notebook style interface. I just know that in order to be the way I really want it, it'll require a custom text editor control, which is totally not something that I feel up to writing.
23:12:32 <Cale> Hmm, I wonder what other gtk controls I could abuse in order to get the effect I want :)
23:13:36 <wagle_home> biosensors
23:13:44 <chadz> laserbeams
23:14:07 <Cale> Laserbeams!
23:14:12 <dons> the laser beams and bio sensors are freaking awesome
23:14:41 <chadz> Yessir.
23:15:05 <chadz> laserbeams are also good at nullifying the usefulness of biosensors.
23:15:06 <glguy> dons: I installed latest git in my home directory for managing the repo
23:15:08 <glguy> much better
23:15:28 <chadz> hpaste is git now?
23:15:41 <dons> its an experiment, chadz
23:16:00 <chadz> to play with git?
23:16:16 <dons> well, that we know how to do :)
23:16:29 <glguy> chadz: it's a new hpaste
23:16:35 <glguy> with new vcs
23:16:50 <sclv> any hackage libs that give nice uuids around?
23:16:53 <oerjan> ohloh kills darcs, film at 11
23:16:55 <glguy> running on fastcgi and with lots of syntax highlighting and whatever
23:17:03 <dobblego> do I need some GHC pragma to use #ifdef DEBUG?
23:17:15 <chadz> glguy: not a happs fan anymore?
23:17:23 <dons> dobblego: {-# LANGUAGE CPP #-}
23:17:29 <dobblego> dons, ah thanks
23:17:37 <dons> and strongly typed database access, chadz :)
23:17:45 <glguy> yeah, sqlite3 backed
23:17:51 <glguy> instead of in memory storage
23:17:57 <dons> short, sharp web apps in the haskell style. that's the goal
23:18:13 <glguy> chadz: I think that this will be a better example for people wanting to do web apps i nhaskell
23:18:21 <glguy> than what current hpaste provides
23:18:29 <chadz> probably very true.
23:18:42 <chadz> i'd like to see the code :)
23:18:50 <glguy> http://code.haskell.org/hpaste
23:18:55 <chadz> git, right?
23:18:56 <glguy> (not feature complete)
23:18:57 <glguy> yeah
23:19:02 <dons> glguy: highlighting-kate >=0.2.1 ?
23:19:08 <glguy> yeah
23:19:14 <glguy> that's in the cabal, right?
23:19:27 <dons> but that's not the version on hackage?
23:19:33 <dobblego> is there a library function = flip ($)?
23:19:34 <glguy> I believe that it is
23:19:40 <dons> hmm
23:19:45 <glguy> what version do you see?
23:19:49 <dons> yes, you're right.
23:20:00 <dobblego> @hoogle a -> (a -> b) -> b
23:20:05 <dons> ah, versionitis
23:20:07 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
23:20:09 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
23:20:13 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
23:20:38 <oerjan> dobblego: i don't know of one
23:21:04 <dons> in business, glguy. cabal install doesn't like upgrading things
23:21:06 <oerjan> but flip ($) x = ($ x)
23:21:18 <dobblego> oerjan, never mind; I'll just write one, thanks
23:21:26 <sclv> ?ty \x -> x . (*)
23:21:26 <lambdabot> forall c a. (Num a) => ((a -> a) -> c) -> a -> c
23:21:36 <sclv> ?ty \x -> x >>> (*)
23:21:37 <lambdabot> forall b c. (Num c) => (b -> c) -> b -> c -> c
23:21:40 <dobblego> oerjan, I was also hoping it had infixr fixity
23:22:10 <chadz> which dbms does the haskell community have preference for?
23:22:27 <dons> chadz: its hard to say. there's a lot of choice, and not a lot of experience
23:22:38 <chadz> looks lkike takusen has bindings for postgre/sqlite
23:22:46 <glguy> and odbc
23:22:48 <glguy> and oracle
23:22:51 <glguy> so... perfect
23:22:58 <sclv> ?ty \x -> x <<< (*1)
23:22:59 <lambdabot> forall d b. (Num b) => (b -> d) -> b -> d
23:23:49 <dons> sclv: did you get your app running in fastcgi + apache?
23:24:36 <sclv> dons: haven't bothered. I'm sticking with lighttpd for now -- I'll worry about that bit later. more fun to hack haskell than configs files. :-)
23:24:51 <bos> takusen seems quite complicated to me.
23:24:57 <dons> i count 12 new apps on hackage today.
23:25:51 <sclv> takusen hides its internals too much... there's no way to get at unDBM. no good for trying to do fun stuff to extend it. I had to switch back to HDBC.
23:26:06 <dons> ah, interesting.
23:26:17 <dobblego> dons, do you know how to get haddock not to barf at the #ifdef usage?
23:26:27 <Cale> If you're going to extend it, why not contribute code to it?
23:26:29 <calvins> more type questions: the GHC manual gives "(forall a. a->a) -> Int -> Int" as an example of a rank-2 type. What exactly does the 'forall a.' do in this example? I.e., how does it change the type from what it would be as just (a -> a) -> Int -> Int?
23:26:30 <bos> sclv: you should write up something about your experiences.
23:26:43 <dons> dobblego: run it from cabal, with extensions: CPP set
23:26:47 <dons> cabal will pick up the right flags
23:26:51 <Cale> calvins: It insists that the function passed is really polymorphic
23:26:57 <dobblego> dons, ah thanks
23:27:11 <Cale> calvins: That is, basically the only thing you could pass is id (or the undefined function)
23:27:22 <sclv> Cale: hmm.. I might send in a patch yet, just to switch DBM to the internals with everything exported and then reexport it crippled from the main lib.
23:27:48 <sclv> In the meantime, I want to get my stuff working for people with the current version.
23:28:20 <calvins> Cale: why wouldn't it be polymorphic without the forall? If the type is (a -> a), isn't that polymorphic (for any a)?
23:28:51 <mauke> calvins: foo f = (f 'x', f ())
23:28:53 <Cale> calvins: If the type was (a -> a) -> Integer -> Integer, you could pass, say, reverse, as the function
23:29:06 <Cale> Or, toUpper :: Char -> Char
23:29:10 <Cale> for example
23:29:12 <dobblego> dons, there does not appear to be a CPP extension (they are enumerated on the CABAL proposal)
23:29:32 <sclv> I'm working on a webframework lib that mixes atomic STM, sessions, and database in a simple API. there'll be some proposals for the CGI and FastCGI libs by the time I'm done too.
23:29:39 <dons> dobblego: there sure is :)
23:29:47 <dons>  extensions:        CPP, ForeignFunctionInterface
23:29:50 <Cale> (forall a. a -> a) -> Integer -> Integer, means that the function only accepts a *polymorphic* parameter, not just a monomorphic one for some particular a
23:29:50 <dons> for example
23:30:04 <calvins> ah, a light went off. It is polymorphic in the sense that it accepts any determinate type to that same type, but not in the sense that it accepts a function with unspecified type like id?
23:30:14 <Cale> yeah
23:30:27 <Cale> Well, (a -> a) -> Integer -> Integer will accept id as well
23:30:45 <Cale> But (forall a. a -> a) -> Integer -> Integer won't accept toUpper
23:30:58 <Cale> (it'll basically only accept id)
23:31:10 <calvins> Yeah, that makes sense now
23:31:24 <Cale> Consider something like...
23:31:36 <mudge> hey what is meant by an upper bound of a function?
23:31:43 <Cale> f r = (r [1,2,3], r "Hello")
23:31:48 <hpaste>  sclv pasted "example use of api" at http://hpaste.org/5835
23:32:07 <Cale> mudge: The largest value which it takes on, generally.
23:32:11 <sclv> ^^ all that basically works, but it still needs lots of work to be more generally usable.
23:32:25 <Cale> calvins: Try working out what the type of that function f is.
23:32:31 <blargeyfarg> just for my own clarification, without the forall, it will accept any function that can bind to a particular type "a", but with the forall, it can bind only to a function that is valid for all possible types "a"?
23:32:33 <mudge> Cale: thanks
23:32:34 <mauke> instance Num Char
23:32:44 <Cale> calvins: (As a hint, it's not well-typed in Haskell 98)
23:32:52 <mauke> f :: ([Char] -> a) -> (a, a)
23:33:16 <Cale> We're going to assume that 1 :: Integer
23:33:31 <Cale> Just to foil mauke.
23:34:00 <mauke> there's a reason my example - foo f = (f 'x', f ()) - didn't use numeric literals :-)
23:34:49 <oerjan> blargeyfarg: yep
23:34:50 <Cale> But we can at least imagine some useful functions which could be passed to my example :)
23:35:22 <Cale> For example, r might be length, or reverse
23:35:34 <mauke> f might be show
23:36:37 <Cale> In fact that raises an interesting question: should there be typeclass variables?
23:38:32 <mauke> how would that work?
23:38:36 <Cale> foo :: (forall c a. (c a) => a -> b) -> (b, b)
23:38:39 <Cale> Perhaps :)
23:39:05 <mauke> wtf x = case x of c y -> y
23:40:06 <Cale> Hmm, that would have an interesting type. :)
23:41:21 <Cale> All types isomorphic to Identity :)
23:42:05 <Cale> wtf :: (Identity ~= f) => f a -> a
23:43:22 <calvins> Cale: seems it's  (forall a. [a] -> b) -> (b, b), after much experimentation.
23:43:51 <Cale> calvins: yeah
23:44:23 <mauke> wtf (Just x) == x
23:44:59 <Cale> wtf Nothing == ...
23:45:05 <Cale> error?
23:45:30 <mauke> non-exhaustive pattern exception
23:46:08 <Cale> Come one, come all, it's the magic type system game, where we write nonsense code and then try to imagine a sufficiently fancy type system in which it can be typed!
23:46:11 <mauke> is Either a a isomorphic to Identity?
23:46:26 <Cale> Nope.
23:47:03 <glguy> is Bool?
23:47:05 <Cale> Though perhaps we could consider the difference between data and newtype as small enough to ignore :)
23:48:08 <sclv> wtf (ThreeVals "a" 12 2.4)
23:48:21 <Cale> So, I suppose you'd want it to mean "has at least one data constructor with exactly one parameter"?
23:48:25 <sclv>  = 2.4
23:48:27 <sclv> ?
23:48:29 <mauke> yes
23:48:31 <mauke> sclv: no
23:48:32 <glguy> sclv: did you look at the api stuff in the new hpaste?
23:48:44 <glguy> (I just saw your example api paste)
23:48:46 <Cale> Or has at least one data constructor with at least one parameter? :)
23:48:48 <sclv> glguy: haven't seen it yet.
23:48:56 <Cale> I kind of like sclv's interpretation :)
23:48:57 <glguy> sclv: If you are interested in that topic, you should look
23:48:58 <mauke> it should be exactly one parameter
23:49:09 <Cale> It goes well with currying :)
23:49:20 <Cale> Curried pattern matching. :)
23:49:31 <matthew-_> @seen dons
23:49:31 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 19m 41s ago.
23:49:34 <glguy> sclv: git clone http://code.haskell.org/hpaste (if you are interested)
23:49:34 <mauke> that's evil!
23:49:35 <Cale> c would match ThreeVals "a" 12
23:49:51 <mauke> makes sense, though
23:49:53 <matthew-_> dons: yeah, sessions is in a source repo
23:49:57 <mauke> case x of c -> c binds c to all of x
23:50:06 <Cale> right
23:51:05 <matthew-_> ...just not darcs
23:51:22 <Cale> I suppose if you're going to have it fail to pattern match on anything else, you could just make it completely polymorphic, and just make it a pattern match error when it doesn't match, or the constructor that x was built with is not in scope.
23:53:02 <matthew-_> dons: though if you have patches to send then email is probably best at this point
23:54:11 <dons> matthew-_: any chance these repos could get hosted somewhere/
23:54:19 <matthew-_> they are
23:54:20 <calvins> okay, if we had g r =  (r [1,2,3], r "hello"), what would the type need to be in order for that to evaluate to (1, 'h') by passing 'head' to g?
23:54:30 <dons> matthew-_: i couldn't find the link from the webpage?
23:54:33 <matthew-_> monotone to source.wellquite.org
23:54:39 <dons> ah ha
23:54:47 <matthew-_> and the branch is 'org.wellquite.sessions'
23:55:02 <matthew-_> thing is, I'm likely to move to mercurial in the near future
23:55:40 <oerjan> (forall a. [a] -> a) -> (Integer, Char) e.g.?
23:56:13 <calvins> oerjan: I wanted to do it without specifying (Integer, Char) in particular. Is there any way to do that?
23:56:31 <matthew-_> dons: why?
23:57:06 <oerjan> calvins: um g _does_ use those (or something with Num).  hard to avoid.
23:57:29 <sclv> gah. now installing git from the source. i knew this day would come.
23:57:34 <dons> matthew-_: so i could snoop around the source :)
23:57:42 <calvins> oh, yeah
23:57:44 <matthew-_> you already have the source!
23:57:46 <wagle_home> sclv, ez..  i do it all the time
23:57:53 <dons> matthew-_: well, its hard to know if its current.
23:57:55 <calvins>  i guess i was forgetting that those are hard-coded in the definition ;)
23:57:58 <dons> also, .tgz isn't easily browsable
23:58:07 <matthew-_> yeah, I should fix that
23:58:09 <dons> thricely, i like sucking code into ohloh
23:58:16 <sclv> yeah. just so many files. (oh, and dons, neither is git :-))
23:58:33 <glguy> git is one of the easiest programs to install from source
23:58:34 <dons> what's up sclv ?
23:58:47 <glguy> sclv is going to check out the new api code from hpaste methinks
23:58:51 <sclv> just needling about how git repos aren't easily web browsable.
23:59:01 <glguy> they are when git-web is running
23:59:03 <glguy> :-D
23:59:07 <wagle_home> huh?  check out gitweb
23:59:14 <dons> yeah, its stupid. don't ask file system guys to design command line interfaces
23:59:16 <matthew-_> actually, there are some nice monotone tools that make them web browseable too
23:59:22 <dons> wagle_home: they aren't by default visible repos like darcs
23:59:27 <calvins> I was thinking of something like "h r as bs = (r as, r bs)" where the list is passed in, but GHC type checks that fine..
23:59:29 <matthew-_> there's nice monotone <-> trac integration too
23:59:41 <glguy> dons: It would be if I didn't create it as a bare repo
23:59:57 <dons> why do we create bare repos, btw?
23:59:57 <glguy> this isn't a git "flaw" but a glguy choice
