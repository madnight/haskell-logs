00:22:48 <rnorris> the given example for Control.Monad.CC.Cursor is generator $ \yield -> do a <- yield 1 ; yield 2 ; b <- yield 3 ; return [a,b] .. but it blows up complaining about ambiguous types. does anyone have an example that works (or a suggestion for what the type of this thing should be)?
00:45:24 <gour> @seen ndm
00:45:24 <lambdabot> I haven't seen ndm.
00:53:49 <slarba> question about Data.Binary: what's the best way to decode rest of the ByteString in Get monad?
00:54:24 <slarba> like data Foo = Foo Word16 ByteString and get = liftM2 Foo get <what goes here>
01:02:14 <oerjan> well going by the documentation page i'd say it's completely impossible.
01:02:32 <slarba> that's what I inferred :(
01:02:38 <oerjan> there is no way to retrieve the remainder, and you cannot detect end of input
01:04:58 <slarba> doesn't look too bad to implement
01:05:00 <slarba> ->
01:05:28 <oerjan> oh it's probably easy _if_ you have access to the constructors
01:06:26 <oerjan> but you don't, the type is abstract
01:08:52 <slarba> we'll you can always take Data.Binary sources and hack away :)
01:13:15 <slarba> a-ha, no need to hack
01:13:39 <oerjan> you found an undocumented function?
01:13:56 <slarba> Data.Binary.Get has remaining::Get Int64
01:14:09 <slarba> so you can replicateM getWord8
01:14:13 <oerjan> ah
01:14:30 <slarba> which gives the rest
01:16:13 <oerjan> although it still seems inefficient compared to just returning the state
01:16:48 <slarba> true
01:17:46 <slarba> getRemainingLazyByteString :: Get L.ByteString
01:17:46 <slarba> getRemainingLazyByteString = do S s ss _ <- get return (s `join` ss)
01:17:52 <slarba> ....
01:18:18 <sili> anyone installed ghc via macports?
01:18:25 <oerjan> that exists? ok.
01:18:45 <nominolo> sili: they only have old versions
01:18:53 <nominolo> 6.7 is newest, right?
01:19:52 <sili> not sure, actually. macports is using 6.6.1
01:20:05 <nominolo> for some reason, though, fink doesn't find darcs, even though i activated unstable
01:20:10 <oerjan> oh, i just looked in the Data.Binary module itself
01:20:21 <nominolo> sili: yep, that's the latest stable version on macports
01:20:37 <oerjan> (took me a while to find the link to the others, via contents)
01:20:53 <nominolo> sili: i just installed the ghc 6.8.2 binary
01:21:15 <nominolo> sili: (more environmentally friendly, too ;) )
01:21:23 <oerjan> slarba: perhaps you want to use runGetState?
01:21:54 <oerjan> er wait
01:22:11 <sili> nominolo: via fink?
01:22:24 <oerjan> nah
01:22:25 <nominolo> no, from the homepage
01:22:27 <sili> oh. ghc distributes
01:22:28 <sili> ya
01:22:38 <sili> I didn't bother looking there first ;p thanks
01:22:40 <nominolo> just download the frameworks, put them into the right place
01:23:00 <nominolo> sili: then just ./configure --prefix=...  and sudo make install
01:23:28 <nominolo> on Leopard you don't even need the frameworks, iirc
01:23:48 <sili> I guess I can't use the binary :(
01:23:56 <nominolo> ppc?
01:24:02 <sili> leopard intel
01:24:13 <nominolo> there're two binaries
01:24:21 <nominolo> for leopard and for tiger
01:24:51 <nominolo> and ppc tiger
01:25:27 <sili> haha. I was looking at the wrong page. I suck
01:25:31 <nominolo> http://haskell.org/ghc/download_ghc_682.html#macosxintel
01:25:33 <nominolo> :)
01:26:02 <sili> excellent.
01:26:59 <oerjan> hm any Data.Binary people here? i'd like to report a bug in the documentation link...
01:28:18 <oerjan> @seen kolmodin
01:28:19 <lambdabot> kolmodin is in #gentoo-haskell, #xmonad, #haskell and #darcs. I last heard kolmodin speak 9h 13m 56s ago.
01:30:28 <kolmodin> @yarr!
01:30:29 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
01:30:33 <kolmodin> morning
01:30:35 <oerjan> ah :)
01:31:04 <oerjan> kolmodin: i had some problems browsing the Data.Binary docs, and you were first on the list
01:31:33 <kolmodin> yeah
01:31:44 <kolmodin> so which page is this?
01:31:45 <oerjan> the documentation link on http://code.haskell.org/binary/ goes straight to the Data.Binary module, from which it is not obvious that any others exist
01:31:46 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
01:34:47 <kolmodin> ah, right
01:50:55 <faxathisia> really no one is using twelf with haskell?
01:53:10 <nominolo> twelf is weird
01:59:40 <faxathisia> yeah it uses [var] body for lambda abstractions
02:00:29 <swiert> faxathisia: just out of curiousity, what do you want to use twelf for?
02:01:39 <faxathisia> swiert: I'm not sure yet, Just interested in what sort of things I could use when I can't put what I want in the type system
02:02:12 <swiert> faxathisia: by "the type system" you mean Haskell's type system?
02:02:17 <faxathisia> Yeah
02:04:07 <swiert> I probably wouldn't recommend twelf for that (but I'm biased and other people may tell you otherwise)
02:04:56 <faxathisia> no that's cool, I am just looking at various stuff.. hard to find actual examples though
02:05:37 <faxathisia> what else is there?
02:06:27 <swiert> you may want to look at Coq (and in particular the Program stuff) or Agda 2.
02:06:45 <swiert> Coq is a lot more stable, does extraction to Haskell, and better documented.
02:07:02 <swiert> Agda 2 is a bit fancier in some respects, but pretty cutting edge.
02:07:21 <swiert> and still under active development.
02:07:30 <faxathisia> ok, I will, thanks
02:07:56 <swiert> AFAIU twelf was pretty much designed for formalizing metatheory, but I've never looked into it that closely.
02:08:04 <faxathisia> I saw in Coq, sprintf done with delimited continuations and written in haskell too
02:10:16 <hpaste>  Cin pasted "lambda" at http://hpaste.org/5577
02:11:09 <nominolo> also, I think in Coq it's easier to separate program from proofs
02:11:17 <swiert> yeah, Mathieu Sozeau (who wrote the sprintf) is also the guy behind Coq's Program tactics.
02:11:58 <Cin> looks like hpaste needs utf8-string
02:12:34 <Cin> the page's Content-Type is utf-8, but hpaste doesn't seem to actually encode it as utf-8
02:12:50 <faxathisia> http://hpaste.org/5577/0/plain works
02:12:51 * Cin downloads hpaste's sauce
02:13:24 <Cin> faxathisia: yeah, i noticed
02:18:50 <faxathisia> cool http://cvs.coverproject.org/marcin/cgi/viewcvs/Agda2/examples/lib/Logic/Structure/Monoid.agda?rev=HEAD&content-type=text/vnd.viewcvs-markup
02:18:51 <lambdabot> Title: Agda2/examples/lib/Logic/Structure/Monoid.agda - view - 1.2, http://tinyurl.com/yw6ljs
02:19:37 * faxathisia wonders what might be easy/mediumish thing to try in Agda 2 to see how it is
02:20:46 <faxathisia> It looks like you could write code in Agda 2 and chage it into haskell quite easily (just by erasing certain type info that's not needed/can't be represented easily)?
02:42:35 <hpaste>  semka pasted "ghc-pkg list" at http://hpaste.org/5578
02:47:14 <hpaste>  semka pasted "(no title)" at http://hpaste.org/5579
02:50:43 <Cin> using Codec.Binary.UTF8.String, i think changing showHtml to encodeString . showHtml in HPaste.hs would do the trick, if anyone cares.
03:42:11 <Cin> @hoogle (a -> Bool) -> [a] -> Bool
03:42:12 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
03:42:12 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
03:42:12 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
03:42:23 <Cin> ah, in the prelude
03:44:32 <b_jonas> how do I access the argv from haskell?
03:44:44 <mux> :t getArgs
03:44:46 <lambdabot> Not in scope: `getArgs'
03:44:51 <ivanm> @hoogle getArgs
03:44:51 <lambdabot> System.Environment.getArgs :: IO [String]
03:44:52 <mux> :t System.getArgs
03:44:52 <lambdabot> IO [String]
03:44:57 <b_jonas> ah, getArgs
03:45:00 <b_jonas> thanks
04:25:03 * vininim is trying to follow SICP using ghci
04:25:15 <vininim> let's see how far I get =P
04:29:10 <sili> you can do it!
04:48:41 <vininim> > foldr1 (*) ((foldr1 (+) (2:[(foldr1 (*) [4,6])])):[foldr1 (+) [3,5,7]])
04:48:45 <lambdabot>  390
04:52:01 <TNorthover> "product" and "sum" might be more natural there
04:53:22 <TNorthover> > product [sum [2,product [4,6]], sum [3,5,7]]
04:53:25 <lambdabot>  390
04:54:53 <vininim> mm thanks, maps more directy to scheme notions
04:55:44 <doserj> > (2+4*6)*(3+5+7) -- even more natural...
04:55:45 <lambdabot>  390
04:55:53 <TNorthover> But that's cheating.
05:17:16 * Cin implemented his first cons, car and cdr in his lambda computer. yay
05:17:29 <kpreid> @tell dons #rosettacode would like to have lambdabot
05:17:30 <lambdabot> Consider it noted.
05:18:38 <vincenz> @join #rosettacode
05:27:42 <hpaste>  visof pasted "problem with starting lambdabot in online mode" at http://hpaste.org/5580
05:33:20 <Saizan> visof: you're supposed to launch lambdabot from the directory where you've built it
05:35:59 <hpaste>  visof pasted "(no title)" at http://hpaste.org/5581
06:00:08 <JohnMeacham> nice. jhc 0.4 is about 15% faster at compiling.
06:02:00 <Heffalump> how much can it compile now?
06:03:34 <JohnMeacham> Heffalump: 15% more :) well it is mainly memory limited. but that should be better now too.
06:03:51 <JohnMeacham> I'll throw a new rpm up in a bit.
06:06:19 <JohnMeacham> A lot of the improvements  involved optimizing the on disk format, using word32 or word8's rather than 64 bit quantities like binary defaults to for a lot of things. and changing my dynamically typed fields to just store a hash representation of the type in the binary file, which is a nice constant sized value rather than a string.
06:07:01 <JohnMeacham> and reimplementing some low level stuff in C.
06:22:32 <Heffalump> JohnMeacham: :-)
06:24:46 <JohnMeacham> I have a sort of neat on-disk format. I am adding gdbm style hashes to it so instead of serializing stuff as one big stream, you can go directly to what you want directly. should be useful for other stuff too.
06:26:27 <JohnMeacham> actually, it would be nice if I could just mmap the whole file and treat it like a ByteString and pull out bits of it as needed...
06:27:09 <dcoutts_> JohnMeacham: you can do that, there's code around to mmap files as a ByteString
06:27:54 <dcoutts_> in the bytestring-mmap package
06:28:16 <JohnMeacham> dcoutts_: is it in the library or should I just search around for it? I was running into issues getting many lazy bytestrings out of the same file, since they would fight over the file handle. if I just slurped in the entire file in one go, that would solve that.
06:28:50 <JohnMeacham> cool. I'll check it out and see if it suits my needs.
06:28:51 <dcoutts_> JohnMeacham: it's in the bytestring-mmap package which is on hackage
06:29:18 <dcoutts_> has versions for strict and lazy ByteStrings
06:31:39 <dcoutts_> JohnMeacham: oh, I'll try building again, with 0.3 it could not compile the FFI.hs module due to lots and lots of missing imports
06:31:47 * dcoutts_ gets jhc 0.4
06:31:47 <JohnMeacham> perhaps just the normal 'getcontents' should do that when it is avilable.
06:32:00 <JohnMeacham> dcoutts_: ? you couldn't compile jhc from my tarball?
06:32:07 <dcoutts_> JohnMeacham: I could not, no :-(
06:32:20 <dcoutts_> JohnMeacham: I'll try the 0.4 and report
06:32:28 <JohnMeacham> hmm.. what were the missing imports, it should have worked...
06:32:56 <dcoutts_> JohnMeacham: was on a different machine, I don't remember exactly but it looked like lots of functions for dealing with bits / binary stuff
06:33:09 <dcoutts_> from the FFI module
06:33:15 <JohnMeacham> binary and zlib and a recent DrIFT should be the only external dependencies. and 0.4 doesn't even need drift.
06:33:43 <JohnMeacham> it was likely you didn't have binary installed or something, since 'deriving binary' is most everywhere so it would generate a lot of messages.
06:34:06 <dcoutts_> I think I probably had binary and zlib installed, and if I hadn't I should have got an error about a module not existing, rather than functions that were not defined
06:34:15 <dcoutts_> I'll try 0.4 now and see
06:34:22 <JohnMeacham> I am just rebuilding the standard libraries now before putting the new version up.
06:34:22 <JohnMeacham> ah.
06:34:36 <JohnMeacham> that is most likely because you didn't have an appropriate version of DrIFT,
06:34:56 <dcoutts_> I had drift-2.2.0
06:34:59 <JohnMeacham> It also creates lots of helper functions in addition to deriving instances.
06:35:03 <dcoutts_> JohnMeacham: what version do I need?
06:35:12 <JohnMeacham> umm.. mine is 2.2.3
06:35:41 <dcoutts_> hmm, drift isn't on hackage yet
06:35:45 <JohnMeacham> http://repetae.net/repos/DrIFT/ - the one from the repo should work.
06:36:03 <dcoutts_> I'll try and update the gentoo package to the latest drift release
06:37:07 <dcoutts_> ah hmm, that's 2.2.1, which may not be recent enough
06:37:24 <JohnMeacham> can gentoo install rpm's? I heard that most systems can install packages from each other nowadays.
06:37:40 <JohnMeacham> hmm.. my latest tarbal is 2.2.2... perhaps I need to put out another official release.
06:38:00 <JohnMeacham> oh. 2.2.1... it is behind.
06:38:13 <JohnMeacham> I'll update that.
06:38:19 <dcoutts_> JohnMeacham: thanks
06:39:18 <JohnMeacham> ah. yes. DrIFT can now derive all the Control.Applicative stuff.
06:39:25 <dcoutts_> cool
06:39:48 <JohnMeacham> Foldable, Functor, and Traversable. when I updated jhc to ghc 6.8 I must have used them.
06:39:58 <dcoutts_> JohnMeacham: the policy for gentoo packages is always to build from source where possible, there may be tools to install rpm's but they'd only be for end users or admins, not for making packages to put into gentoo's main collection
06:40:19 <JohnMeacham> oh, does it have like a freebsd ports system?
06:40:28 <dcoutts_> yes, only slightly cleverer
06:40:41 <JohnMeacham> jhc worked on Mac OSX and OpenBSD a while ago, but I have not tried it in a while. hopefully it still does.
06:41:03 <JohnMeacham> and cross compiling for the iPhone actually. that was fun :)
06:41:07 <dcoutts_> heh :-)
06:43:23 <JohnMeacham> I should say that jhc must be getting better as I am doing a full compile of the universe on an old laptop and it is keeping up. before I needed to run it on my big server. I just realized that.
06:44:55 <JohnMeacham> hmm.. I need to change drift's documentation from text2html to markdown. being the minimalist that I am.
06:45:04 <JohnMeacham> texinfo I mean.
06:49:37 <nominolo> hi dcoutts
06:49:48 <dcoutts_> hia nominolo
06:50:06 <nominolo> dcoutts_: we have yet another case of that weird yi build error
06:50:14 <dcoutts_> nominolo: yes?
06:50:22 <JohnMeacham> okay. DrIFT 2.2.3 with Foldable and Traversable deriving is officialy out and online.
06:50:50 <nominolo> dcoutts_: http://hpaste.org/5578, http://hpaste.org/5579
06:51:01 <nominolo> it's exactly the same error
06:51:12 <dcoutts_> JohnMeacham: thanks, I'll tell you how I get on with that and the existing jhc 0.3 tarball
06:51:18 <nominolo> Cabal seems to send the right -package flags, too
06:52:07 <dcoutts_> nominolo: though that's not obvious from those pastes since they do not use -v
06:52:22 <nominolo> JohnMeacham: texinfo is nice
06:52:31 <dcoutts_> nominolo: and no dev has yet been able to reproduce it?
06:52:42 <nominolo> dcoutts_: yes, i extracted that locally
06:52:48 <nominolo> dcoutts_: i'm trying now
06:52:53 <dcoutts_> nominolo: ah ok, good
06:53:12 <JohnMeacham> nominolo: I was never a big fan. mainly I didn't really get its niche, man pages or LaTeX usually are more appropriate.
06:53:52 <nominolo> JohnMeacham: docbook would be nice with a really good xml editor
06:54:07 <JohnMeacham> I have started doing everything in markdown and using 'pandoc' and a few custom preprocessors to write documentation. I have some scripts that pull markdown out of various haskell source files and build a manual. hopefully this means jhc will have a manual sometime soon.
06:54:28 <nominolo> JohnMeacham: but do you also have some semantic markup?
06:54:43 <nominolo> JohnMeacham: that would come in handy one day
06:54:51 <nominolo> well, maybe it would ...
06:55:30 <JohnMeacham> nominolo: for web pages. my preprocessors actually do that sort of thing.. adding 'class' tags to various things so my css works the way I want.
06:55:35 <vininim> > let {sq x = x * x; good g x = abs (sq g) - x < 0.0001; average x y = (x + y) / 2; improv g x = average g (x/g); sqiter g x = if (good g x) then g else (improv g x); sqrt = sqiter 1 x} in sqrt 9000
06:55:37 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `Expr'
06:56:27 <vininim> let sqrt = sqiter 1
06:56:36 <vininim> >let sqrt = sqiter 1
06:57:02 <vininim> > sqiter 9
06:57:03 <lambdabot>   Not in scope: `sqiter'
06:57:07 <desegnis> vininim: You need @let if you want it to last
06:57:15 <vininim> mmm...
06:57:43 <JohnMeacham> sweet. as an indication of my changes: base-1.0.hl went from 1554867 bytes to 957468. that is a big reduction. and that is the gziped size so actual meat was trimmed.
06:58:39 <nominolo> dcoutts_: hm, it could be that regex-compat is built against the wrong version of regex-base and regex-posix
06:58:42 <dcoutts_> JohnMeacham: wow
06:59:24 <dcoutts_> nominolo: ah, yes, since it specifies >= blah blah. Check ghc-pkg describe regex-compat
06:59:42 <vininim> > let {sq x = x * x; good g x = abs (sq g) - x < 0.0001; average x y = (x + y) / 2; improv g x = average g (x/g); sqiter g x = if (good g x) then g else (improv g x); sqrt  = sqiter 1} in sqrt 3600
06:59:44 <lambdabot>  1.0
06:59:48 <JohnMeacham> those 64 bit ints add up :). though, I think it was mainly my hashing mechanism that saved space and speed.
07:00:23 <vininim> lol
07:00:50 <nominolo> dcoutts_: well, i'd have to start with a newer version pre-installed version of the other regex stuff
07:01:10 <dcoutts_> nominolo: yes
07:01:14 <nominolo> dcoutts_: but those higher versions in the ghc release only happen for the ubuntu release
07:01:36 <vininim> > let {sq x = x * x; good g x = abs ((sq g) - x) < 0.0001; average x y = (x + y) / 2; improv g x = average g (x/g); sqiter g x = if (good g x) then g else (improv g x); sqrt  = sqiter 1} in sqrt 3600
07:01:37 <lambdabot>  1800.5
07:01:38 <dcoutts_> nominolo: I don't follow
07:01:46 <nominolo> dcoutts_: if you get the binary from the homepage you get the 7[12] versions
07:02:14 <nominolo> dcoutts_: but on ubuntu you get 0.9x installed by default
07:02:33 <dcoutts_> nominolo: I see
07:02:42 <nominolo> dcoutts_: so, if you downgrade to the lower versions regex-compat picks up the wrong dependencies
07:02:48 <nominolo> dcoutts_: that's my best guess
07:02:57 <dcoutts_> nominolo: the ghc generic binary definately has the regex-* in it? people would not be building those from source?
07:03:10 <nominolo> yes it has
07:03:21 <nominolo> let me paste the defaults
07:03:25 <vininim> > let {sq x = x * x; good g x = abs ((sq g) - x) < 0.0001; average x y = (x + y) / 2; improv g x = average g (x/g); sqiter g x = if (good g x) then g else sqiter (improv g x); sqrt  = sqiter 1} in sqrt 3600
07:04:11 <vininim> I hope I'm the one lagged and lambda bot isn't burning to my bad maths =P
07:04:18 <hpaste>  nominolo pasted "ghc 6.8.2 default packages" at http://hpaste.org/5582
07:10:22 <dcoutts_> nominolo: though that's only if you build the 'extralibs' package at the same time as ghc
07:10:46 <nominolo> i just downloaded the binary
07:12:05 <dcoutts_> JohnMeacham: ok, C.FFI goes through now using the later drift
07:12:44 <dcoutts_> nominolo: so where do you think the problem is then? that the deps of the regex- packages are too lax?
07:14:08 <nominolo> dcoutts_: hm.  right, since some instance was removed this seems like an interface change
07:15:01 <Deewiant> > 1+1
07:15:16 <Deewiant> vininim: you killed it :-/
07:15:30 <idnar> heh
07:15:46 <JohnMeacham> rpms and tarballs for 0.4 are now online.
07:15:59 <JohnMeacham> thus making the DrIFT upgrade irrelvant :) maybe.
07:16:22 * dcoutts_ is [100..162] into building jhc 0.3 and wonders if he should stop
07:16:24 <dcoutts_> :-)
07:17:22 <dcoutts_> nominolo: perhaps we can fix this with new minor versions of the regex-0.7 packages and have that included into ghc-6.8.3
07:18:03 <nominolo> dcoutts_: i'm trying to track down where that instance gets lost.  it's still kind of weird
07:19:41 <Kitar|st> http://wiresmash.com/funny/sexy-sexual-moments-in-video-game-history/ lol
07:26:29 <astrolabe> Would it be possible, if I could change the prelude, to write code that made all instances of Ord automatically be instances of Eq, with a==b defined to be a >= b && b >= a?
07:26:40 <vininim> Deewiant: sorry, it divided by 0 =O
07:27:36 <Deewiant> shouldn't die though :-/
07:29:24 <tibbe> anyone got a good reference on how to write a continuation based parser?
07:30:16 <dcoutts_> astrolabe: I had a proposal to allow that kind of thing, to let subclasses define default methods from superclasses, so you could just go and define the most specific instance and derive the more general ones.
07:31:12 <dcoutts_> astrolabe: I was not the first to suggest it, it's come up before, I think it's linked from some haskell' page
07:31:35 <LoganCapaldo> man I was in some bizzare alternate server w/ only 11 people in #haskell.
07:32:04 <resiak> there's no typeclass representing partial orders, is there?
07:32:29 <astrolabe> resiak: Ord?
07:32:50 <astrolabe> dcoutts_: Thank you.  I'll have to re-think.
07:33:43 <LoganCapaldo> min and max have the wrong types for Ord to be a partial order don' they?
07:33:53 <astrolabe> @type min
07:34:09 <mauke> ENOBOT
07:34:25 <Ben`> do all types contain the value _|_?
07:34:39 <pjd> Ben`: in Haskell, yes
07:34:46 <astrolabe> LoganCapaldo: You are right
07:34:54 <Ben`> thanks
07:35:00 <tonfa> @hoogle ([a] -> m b) -> [a] -> m b
07:35:17 <bd_> newtypes don't contain _|_
07:35:21 <allbery_b> _|_ isn't really a value, since it's usually something like a non-terminating computation
07:35:25 <pjd> Ben`: eliminating bottom is a hefty undertaking
07:35:38 <astrolabe> I see the report says 'The Ord class is used for totally ordered datatypes'.
07:35:39 <pjd> right, what allbery_b said
07:35:49 <resiak> you'd need >= et al. to be Maybe Bool
07:35:57 <bd_> they contain _|_ wrapped in their constructor (or so on recursively...)
07:36:01 <bd_> I think?
07:36:47 <pjd> so "all types contain _|_" is probably better simply stated "Haskell is not total"
07:36:50 <hpaste>  semka pasted "ghc-pkg list: compatible with Yi" at http://hpaste.org/5583
07:37:15 <Saizan> bd_: that's quite ambiguous, however newtype A = A Int, case undefined of A _ -> "foo" === "foo"
07:37:21 <LoganCapaldo> well you could maybe get away with allowing a > b and a <= b to both be false
07:37:24 <resiak> given newtype A a = A a; data B a = B a; A _|_ and _|_ :: A a are indistinguishable, but B _|_ is distinguishable from _|_ :: B a
07:37:36 <kmcallister> anyone here happen to know how to encode universal types using existential types in System F, or equivalently how to encode universal quantifiers using existential quantifiers in constructive logic?
07:37:40 <resiak> (or so I understand it?)
07:37:47 <JohnMeacham> anyone have some SHA1 code that works on bytestrings laying about?
07:38:10 <Saizan> (right)
07:38:21 <bd_> resiak: No, they're indistinguishable either way. (the goal of newtype is for a and A a to have the same in-memory representation)
07:38:53 <LoganCapaldo> bd_: yes but B is not a newtype
07:40:12 <LoganCapaldo> resiak: was contrasting newtype T a = T a with data T a = T a
07:40:21 <LoganCapaldo> s/://
07:42:29 <nominolo> dcoutts_: can you think of a way to detect those kinds of problem at package-build (or upload) time?
07:43:17 <dcoutts_> nominolo: can we specify the problem better?
07:43:51 <bd_> LoganCapaldo: ah, mym istake. I'm a bit overtired atm :)
07:44:04 <nominolo> dcoutts_: heh.  some missing instance due to incorrect dependencies
07:44:24 <nominolo> dcoutts_: i'll see if i can find out any details.  but first i have to nuke aquamacs
07:45:21 <dcoutts_> nominolo: so the problem is that the deps are too slack, they work when you've only got regex-0.7* available and it actually compiles with regex-base-0.9 but exports a different api (ie different instances)
07:45:50 <nominolo> dcoutts_: i need to try that
07:45:57 <dcoutts_> nominolo: it's easy to find when the package itself does not build with different versions of its deps, but finding when it's api changes is harder
07:46:39 * nominolo creates a zoo of regex-* versions
07:48:36 <dcoutts_> JohnMeacham: Util/RWS.hs gives a huge number of warning about stuff being exported via Control.Monad.State and Control.Monad.Reader
07:49:10 * dcoutts_ is emerging the jhc-0.4.20080210.ebuild
07:52:13 <nominolo> how much ram is needed to build jhc on macosx?
07:55:21 <dcoutts_> nominolo: it includes pre-compiles libs so not much, actually running jhc uses more as I understand it.
08:07:49 <dcoutts_> JohnMeacham: is there any way to get jhc to tell me how it's calling cpp?
08:08:09 <dcoutts_> JohnMeacham: I'm trying to compile the filepath package, which uses -fcpp
08:08:22 <dcoutts_> JohnMeacham: and cpp is complaining "cpp: ambiguous abbreviation --"
08:08:41 <waern> I'm configuring a ghc tree and I need to override the path to haddock, how can I do that?
08:08:51 <dcoutts_> JohnMeacham: but I don't know how jhc is calling cpp, jhc -v does not say
08:14:51 <Heffalump> can you use strace to find out?
08:15:01 <dcoutts_> Heffalump: oh, good idea
08:15:38 <Heffalump> (or just replace cpp with a shell script that tells you)
08:16:17 <pastorn> import Graphics.HGL (hiding Point)  <-- this gives me a Parse error in ghci 6.6 :(
08:16:33 <Deewiant> pastorn: import Graphics.HGL hiding (Point)
08:16:41 <pastorn> epic fail
08:16:42 <resiak> you're missing the point
08:16:44 <resiak> or something :-)
08:17:04 <allbery_b> no, hiding it *ducks*
08:18:30 <daf> resiak: nng
08:18:56 <resiak> daf: I try!
08:22:19 <JohnMeacham> dcoutts_: hmm.. yeah, -v should say.
08:22:29 <JohnMeacham> as in, that is a bug I should fix.
08:23:30 <JohnMeacham>  readSystem "cpp" ["-D__JHC__","-CC","-traditional", "--", fn]  is the relevant bit of source.
08:23:41 * shapr boings furiously
08:23:58 <JohnMeacham> jhc supports 'm4' though, I tend to use that it is much more powerful than cpp. if you are gonna do something wrong, do it right.
08:24:15 <shapr> heh
08:26:25 <dcoutts_> JohnMeacham: perhaps cabal should run cpp on behalf of jhc in that case?
08:26:51 <pastorn> given "f x = undefined" is there a way to comment it so that ghci returns ":i f" with a comment about it that i have written?
08:27:43 <dcoutts_> JohnMeacham: so jhc calls cpp with "-D__JHC__ -CC -traditional -- $file", it seems that GNU cpp does not like that -- flag.
08:28:30 <dcoutts_> JohnMeacham: ah, it's only a warning though, not an error.
08:30:21 <JohnMeacham> dcoutts_: hmm... it should like it, it protects against the odd case when $file begins with a dash
08:31:35 <dcoutts_> JohnMeacham: indeed, many gnu progs support that, but cpp seems not to be one of them
08:32:58 <pastorn> @haddock
08:33:16 <pastorn> @google haskell haddock
08:33:24 <pastorn> lambdabot: FAIL
08:34:54 <laz0r> hi #haskell, i wondering about 'greencard', i've seen that a couple of times as a dependency for some haskell packages, and always consequently avoided it because it refuses to build; it complains about a missing "Data.FiniteMap" module, which as far as I can tell, is deprecated
08:35:27 <Heffalump> I think greencard isn't maintained and has bitrotted somewhat.
08:35:48 <shapr> I hear about c2hs more often.
08:36:03 <shapr> Or hsc2hs
08:36:04 <laz0r> now, I once again found something that uses greencard, the shiny new qt bindings for haskell, and I would really like to play around with these
08:36:21 <laz0r> and for that I guess I need to build greencard
08:37:01 <Saizan> you sure they need greencard? older cabal reported that it didn't found greencard even if the package doesn't use it at all
08:37:24 <laz0r> now I somehow managed to get qtHaskell to build, but it seems something is horribly wrong, there seems to be a 'half installed' greencard, which doesn't work, but is detected by the qtHaskell installation procedure
08:38:23 <laz0r> i'm not so sure, but running Setup.hs told me 'using greencard /usr/local/bin/greencard'
08:38:29 <laz0r> or something like that
08:38:38 <dcoutts_> JohnMeacham: I get some weird error when trying to build filepath, I get a parse error depending on the presence or absence # C style line pragmas
08:38:39 <laz0r> and I know that is broken
08:39:29 <dcoutts_> JohnMeacham: If I remove the '# 1 "System/FilePath/Internal.hs" 1' line then it doesn't fall over when parsing the subsequent module declaration line
08:40:01 <dcoutts_> JohnMeacham: though it seems to grok line pragmas since it gives the correct location for the parse error, giving the original file rather than the pre-processed file.
08:40:50 <dcoutts_> JohnMeacham: I'll probably have to leave things for the moment. I was trying to get as far as being able to build Cabal so I can check if Cabal is still doing the right thing for jhc.
08:40:53 <Saizan> laz0r: you could remove or rename it and see if the package still builds without
08:43:49 <dcoutts_> jhc-0.4 is in the gentoo overlay in case anyone else wants to have a go
08:44:37 <LoganCapaldo> gentoo overlay sounds decidedly Gibson-esque
08:45:23 <laz0r> Saizan, ok, I think all my worries were pointless, it seems to work now fine without greencard
08:45:31 <dcoutts_> LoganCapaldo: who?
08:45:57 <LoganCapaldo> @go William Gibson
08:46:14 <LoganCapaldo> ENOBOT
08:46:50 <LoganCapaldo> http://en.wikipedia.org/wiki/William_Gibson
08:51:23 <pastorn> what kind of error is this? Couldn't match expected type `a' (a rigid variable)
08:51:24 <pastorn>            against inferred type `GHC.Word.Word8'
08:51:34 <RayNbow> does anyone here have http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504 ?
08:51:56 <dolio> I do.
08:52:38 <RayNbow> dolio: do you recommend it? :)
08:52:39 <LoganCapaldo> pastorn: sometimes it mans you gve something an inorrect type signature
08:53:12 <dolio> Yeah. It's good.
08:53:18 <sclv> RayNbow: you can grab his thesis, which its based on, from his homepage as well, if you want a taste.
08:53:25 <pastorn> i guess i might be, but isn't there a way to make "changeColor :: (Word8 -> Word8) -> (Word8 -> Word8) -> (Word8 -> Word8) -> Action" look better?
08:53:44 <kmcallister> anyone here happen to know how to encode universal types using existential types in System F, or equivalently how to encode universal quantifiers using existential quantifiers in constructive logic?
08:53:55 <RayNbow> sclv: hmm, good point... :)
08:54:15 <LoganCapaldo> pastorn: you can leave it out altogether, or you can use type aliases
08:55:17 <LoganCapaldo> type ComponentChanger = Word8 -> Word8 ; changedColor :: ComponentChanger -> ComponentChanger -> ComponentChanger -> Action
08:55:34 * LoganCapaldo is just guessing what the Word8 -> Word8 s are
08:55:56 <pastorn> i was hoping of being able to use :: Num a => (a -> a) -> ...
08:56:10 <LoganCapaldo> well you can
08:56:14 <pastorn> nope
08:56:22 <LoganCapaldo> assuming the body of the function works across all Num
08:56:32 <LoganCapaldo> ie you only use +, -, *, etc.
08:57:08 <LoganCapaldo> but if you using Word8 specific functions, you can't lie in the type signature
08:57:11 <pastorn> yeah
08:57:24 <LoganCapaldo> this is a good thing (tm)
08:57:34 <pastorn> isn't there a ShortInt type?
08:58:18 <pastorn>  :i Word8 gives ... instance Num Word8 -- Defined in GHC.Word ...
09:00:14 <LoganCapaldo> right
09:00:41 <LoganCapaldo> but (Num a) => a doesn't mean for "some Num", it means for "all Num"
09:00:43 <LoganCapaldo> s
09:01:15 <pastorn> true
09:01:47 <pastorn> but still, all that will be used are (+) and (-)
09:02:04 <LoganCapaldo> well if that's true
09:02:17 <LoganCapaldo> then the type should be correct
09:03:10 <LoganCapaldo> unless you're doing something like changeColor (+) (-) (*)
09:03:21 <LoganCapaldo> no wait
09:03:24 <LoganCapaldo> that should work
09:03:31 <pastorn> paste coming...
09:03:44 <LoganCapaldo> good idea
09:03:59 <opqdonut> kmcallister: there's something on the existential types -wiki page about that
09:04:01 <opqdonut> iirc
09:05:23 <oklopol> > c
09:05:24 <hpaste>  pastorn pasted "type signature difficulties" at http://hpaste.org/5584
09:05:38 <oklopol> > 1+ 3
09:05:43 <oklopol> :<
09:06:18 <pastorn> data RGB = RGB GHC.Word.Word8 GHC.Word.Word8 GHC.Word.Word8 <-- missed that, if you don't have HGL
09:06:28 <LoganCapaldo> pastorn: well that's it
09:06:48 <pastorn> what is?
09:06:54 <LoganCapaldo> RGB
09:07:05 <monochrom> whee
09:07:10 <LoganCapaldo> RGB (fr r) ... means that fr r has to be Word8
09:07:28 <pastorn> aww....
09:07:38 <LoganCapaldo> because RGB :: Word8 -> Word8 -> Word8 -> RGB
09:08:04 <pastorn> ok
09:08:14 <pastorn> so there's nothing i can do?
09:08:24 <opqdonut> well you can use fromIntegral or something
09:08:31 <opqdonut> but that's kinda kludging it
09:08:41 <Codex_> pastorn: you just need convert :: (Num a) => a -> Word8
09:08:45 <opqdonut> yeah
09:09:16 <pastorn> i like the fromIntegral-solution
09:09:24 <monochrom> @hoogle (Num a) => a -> b
09:09:37 * LoganCapaldo doesn't
09:10:28 <monochrom> Too many matches.
09:10:34 <monochrom> @src Num
09:12:13 <monochrom> fromIntegral and fromInteger make the most sense.
09:12:36 <pastorn> could someone please append my paste+
09:12:37 <pastorn> ?
09:12:39 * LoganCapaldo thinks just leaving it as Word8 _> ... blah makes the most sense
09:12:46 * opqdonut too
09:13:07 <monochrom> (Num a) => a -> Word8  is unimplementable. Num doesn't have enough methods for it.
09:13:36 <vincenz> You need Integral
09:13:59 <pastorn> monochrom: just \x -> x `mod` 255 would probably work
09:14:19 <opqdonut> pastorn: mod wants integral
09:14:21 <monochrom> Alright, depending on which function is under question, Word8 -> Word8 may be even better.
09:14:43 <monochrom> Word8 is Integral.
09:15:25 <monochrom> (\x -> x `mod` 255) is (Integral a) => a -> a, and can be specialized to Word8 -> Word8
09:15:29 <LoganCapaldo> I'm arguing that changeColor shouldn't be (Num a) => (a -> a) ... especially not just for aesthetic reasons
09:15:55 <LoganCapaldo> and by arguing, I mean stating the opinion that.
09:16:34 <monochrom> I concur.
09:19:50 <nolrai> > ixmap (0,3) (head . show) $ listArray (0,3) [0..3]
09:20:32 <LoganCapaldo> Terminated
09:21:35 <nolrai> \msg lambdabot
09:25:19 <kpreid> dons!
09:30:45 <nolrai> is there a reason amap isnt in Data.Array?
09:32:36 <nominolo> dcoutts_: didn't like my commit message script patch?
09:32:57 <dcoutts_> nominolo: I applied it, but forgot to change the _darcs/prefs/defaults :-)
09:33:11 <dcoutts_> nominolo: I changed it for the Cabal repo but not cabal-install. Doh!
09:33:37 <dcoutts_> nominolo: so look out for the next commit message that comes through
09:33:49 <nominolo> dcoutts_: do they use separate scripts?  i thought there was only one global script
09:34:13 <dcoutts_> nominolo: I didn't want to change the global script, I made a copy and will test with that
09:34:31 <dcoutts_> if it's all ok I'll see about changing the global one
09:35:08 <desegnis_> nolrai: Not sure about the reason, but you can just use fmap if you don't want to import IArray
09:35:09 <nominolo> right
09:35:50 <Kitar|st> http://wiresmash.com/how-to/how-to-make-a-fireball/
09:38:52 <alatter> has anyone given "leksah" a try?  I'm having trouble installing it - I don't have the "sourceview" package it requires and I'm not sure where to get it
09:39:11 <dcoutts_> alatter: that's part of gtk2hs
09:39:34 <olsner> "leksah"? is that ghetto slang for lexer?
09:39:46 <alatter> olsner: sortof "haskell" backwards
09:39:54 <alatter> dcoutts_: much thanks
09:41:41 <Spark> what does "min (a,b+1) (a+1,b)" do?
09:42:06 <Spark> obey the lexographic ordering on the tuples?
09:42:17 <desegnis> @src min
09:42:24 <alatter> > min (1,2) (2,1)
09:42:45 <Lemmih> (1,2)
09:42:52 <desegnis> Ah, did we kill her again?
09:43:00 <desegnis> anyway, Spark, yes
09:44:58 <desegnis> min just uses either of  »compare« or (<), and the Eq instance for pairs obeys lexicograpic order
09:46:27 <nielsbergsma> hi all, I try to figure out monads and I keep having a couple of questions (after reading several articals), is someone available to give me some help
09:46:51 <b_jonas> is »this« style of quotation marks some sort of fashion in this channle these days?
09:47:03 <vincenz> >>which style of quotations<<?
09:47:40 <vincenz> You mean the cat whiskers?  Probably a remnant of lolcats
09:47:44 <desegnis> b_jonas, no, it's only my personal fashion because they are easier to type on a German keyboard than ‘English’ (even “double”) quotation marks
09:47:47 <dcoutts_> nielsbergsma: typically you just ask, rather than asking to ask, since nobody knows if they will be able to answer your question before you've asked it :-)
09:47:56 <olsner> @quote meta-ask
09:48:24 <nielsbergsma> what happens if you use an monad and there is an IO error.... what happens with the error message
09:48:29 <LoganCapaldo> I prefer ≥this style of quotation≤
09:48:32 <vincenz> dcoutts_: not to mention, it's like asking for a global lock :)
09:48:33 <opqdonut> shouldn't they be used lik <<this>> and not like >>this<<
09:48:36 <opqdonut> +e
09:48:37 <Lemmih> Who's responsible for lambdabot?
09:48:53 <dcoutts_> vincenz: hmm, how so?
09:49:10 <vincenz> dcoutts_: it's asking for an early lock of a person's attention
09:49:13 <desegnis> opqdonut: You missed the discussion that we already had on that... It's different by country/language
09:49:23 <dcoutts_> vincenz: yes
09:49:23 <b_jonas> desegnis: oh, I have specifically added all of »guillamots«, “English double quotes”, ‘English non-ascii single quotes’, and „Hungarian quotes” to my keyboard layout
09:49:40 <monochrom> The official TH quotation is [|this|]
09:49:43 <b_jonas> though I've no idea where they are so I just try all numbers
09:49:44 <opqdonut> desegnis: oh okay
09:49:59 <b_jonas> LoganCapaldo: heh
09:50:02 <LoganCapaldo> `(quasi ,@(quotes))
09:50:08 <b_jonas> opqdonut: that depends on the language
09:50:16 <desegnis> b_jonas, :)
09:50:18 <conal>  olsner: i ran into a problem with literate haskell blogging.  i don't know how to get section & sub-section markup (## and ###) past ghc.  any thoughts?
09:50:25 <vincenz> @seen brent
09:50:35 <vincenz> @seen byorgey
09:50:43 <vincenz> no bot
09:50:45 <desegnis> b_jonas, or rather, ☺
09:50:47 <b_jonas> they're used « like this » in French (except possibly with differently sized spaces) and »like this« for inner quotations in Hungarian
09:51:03 <monochrom> Shouldn't Hungarian quotation look like q" hello q" ?
09:51:11 <vincenz> They're used as << this >> in certain novels as speech-markers
09:51:13 <b_jonas> the wikipedia page on quotation marks lists the usage for lots of langauges
09:51:16 <LoganCapaldo> oh man
09:51:19 <b_jonas> monochrom: no, that's perl :)
09:51:22 <LoganCapaldo> lambdabot needs to be here
09:51:34 <olsner> hmm, why does ghc choke on that? shouldn't those lines be treated as comments since they don't start with "> "?
09:51:37 <LoganCapaldo> definitely worth @remmebering
09:51:45 <LoganCapaldo> q" Hungarian quotes! q" I love it
09:51:53 <opqdonut> :D
09:51:56 <monochrom> I mean, Hungarian notation looks like szString, hWnd, ...
09:52:10 <vincenz> that should be dq, for double quotes
09:52:12 <b_jonas> while we are there, why are there unicode ‘single quotes’ in addition to ascii `single quotes'
09:52:13 <b_jonas> ?
09:52:21 <b_jonas> monochrom: yep, I did get that
09:52:27 <monochrom> OK nice :)
09:52:31 <desegnis> conal, is it the cpp that is chocking?
09:53:03 <olsner> segv.lhs:10:1: lexical error at character '#' <-- this is with plain ghc --make on a .lhs file with '#'-lines
09:53:05 <conal> desegnis: i guess i don't know.  i don't think i said -cpp
09:53:19 <desegnis> b_jonas: ` is a back-tick, and ' is, er, a high-tick. They're not actually quotation marks
09:53:27 <olsner> could it be that ghc is trying to parse a #line line there?
09:53:33 <vincenz> desegnis: they'r quotation devices
09:53:35 <vincenz> like on a plane
09:53:36 <b_jonas> what I'd like is the notation 3q%foobar% which means to quote at least 3 characters (so the first 3 character is not searched for delimiters) and % is any delimiter
09:53:51 <nielsbergsma> what happens if you use a monad and there is an IO error.... what happens with the error message
09:54:01 <b_jonas> desegnis: but isn't ascii ' used for the apostrophe, and isn't that the same char as the closing single quot?
09:54:07 <vincenz> nielsbergsma: if you don't catch it, it gts printed
09:54:18 <vincenz> (and your program obv exits with that error)
09:54:29 <desegnis> vincenz: a plane?
09:54:33 <LoganCapaldo> apostrophe is not the same thing as a close quote, even if they happen to use the same glyph
09:54:36 <nielsbergsma> and if its EOF ?
09:54:37 <vincenz> desegnis:
09:54:43 <vincenz> .. flotation devices?
09:54:47 <vincenz> I always love it when they say that
09:54:49 <conal> does anyone know how to get erc (emacs irc client) to show fancy characters nicely.
09:54:56 <vincenz> "Your cushion can be used as a flotation device"
09:55:28 <vincenz> nielsbergsma: care to be more specific?
09:55:42 <vincenz> nielsbergsma: if you read in a file or stdin as a string, there won't be an EOF
09:55:57 <vincenz> just the end of a list, like any other list
09:56:16 <nielsbergsma> oke, if you use a TCP connection for getting some data
09:56:28 <nielsbergsma> and the connection get lost
09:56:31 <sannysanoff> hello gentlement
09:56:33 <vincenz> hmm, not a TCP expert
09:56:36 <conal> olsner: yep -- that's the error i get from ghci.
09:56:51 <sannysanoff> sorry for lame question; where can I find info about * -> * and * -> * -> * ?
09:56:53 <nielsbergsma> do you get an exception and the program get exit  ?
09:56:54 <LoganCapaldo> this is theoretically good because then you have >single quoted<, >>double qouted<< and apostrophe's without having apostrophe<s
09:56:56 <vincenz> nielsbergsma: you -can- catch errors
09:57:21 <b_jonas> opqdonut: specifically http://en.wikipedia.org/wiki/Quotation_mark%2C_non-English_usage
09:57:22 <sannysanoff> (i mean theoretical background)
09:57:33 <vincenz> sannysanoff: those are "kinds"
09:57:34 <nielsbergsma> vincenz: oke,catch it in  in a monad right ?
09:57:42 <desegnis> b_jonas: hm... I think ASCII ' may indeed be an official apostrophe, even if a type-set apostrophe looks different. And a closing single English quotation mark certainly looks a lot like a typeset apostrophe. Still, ’ is just the quotation mark, by definition
09:57:43 <pejo> sannysanoff, those are kinds, I think "Types and programming languages" has a chapter on them.
09:57:44 <vincenz> nielsbergsma: yes, the IO monad has catch
09:57:58 <vincenz> can't remember the exact name, and the bot is down :|
09:58:12 <sannysanoff> vincenz; yep; but as I google it, I cannot find initial paper
09:58:15 <vininim> mapM (\ (x:xs) -> x:xs)  [[1..10]] -- this hurts my brain
09:58:20 <nielsbergsma> vincenz: but then you should check on errors everytime you call a monad
09:58:29 <vincenz> nielsbergsma: 'call a monad'?
09:58:31 <sannysanoff> pejo; thanks
09:58:48 <desegnis> vincenz: ah, I see :)
09:58:51 <vincenz> nielsbergsma: no, you put an exception handler around your socket-reader, as you would in any other anguage
09:58:54 <vincenz> language
09:58:55 * desegnis 's fingers are lagging
09:59:12 <vincenz> nielsbergsma: or you check yourself to see if the socket is closed before reading
09:59:20 <vincenz> nielsbergsma: this isn't' different from any other language, really
09:59:39 <olsner> conal: if you prefix the #'s with a space, ghc accepts it... you could hack markdown's heading handlers to take headings with spaces before them
09:59:49 <nielsbergsma> vincenz: mmm oke I see
10:00:16 <mauke> 〝what is this?〞
10:00:23 <vincenz> nielsbergsma: anywho.. you don't "call a monad"
10:00:28 <conal> olsner: i guess that'd do.  more php tweaking -- shudder.
10:00:30 <vincenz> nielsbergsma: IO actions happen inside the IO monad
10:00:38 <nielsbergsma> vincenz: but why use monads... the way I see it you use monads to get an extra channel of information about something
10:00:45 <LoganCapaldo> jets atacking your w and taking off from your question mark
10:00:50 <olsner> php sounds easier to tweak than ghc though :P
10:00:52 <vincenz> nielsbergsma: to keep your language pure
10:00:54 <nielsbergsma> vincenz: use a monad (like a proxy class)
10:00:58 <vincenz> eh?
10:01:01 <conal> olsner: thx for the suggestion
10:01:13 <vincenz> someone less tired than me care to help nielsbergsma with the basics of monads?
10:01:26 <desegnis> vininim: »mapM id« for lists is equivalent to sequence
10:01:29 <olsner> but I do wonder why ghc chokes on '#'s
10:01:34 <nielsbergsma> vincenz: to keep the language pure you mean always to get an result
10:01:38 <conal> olsner: me too
10:01:44 <vincenz> nielsbergsma: no
10:01:45 <LoganCapaldo> cause it uses them for it's evil extensios, no?
10:01:47 <vincenz> @where monad
10:01:50 <vincenz> @where monads
10:01:53 <vincenz> doh, no bot
10:02:01 <LoganCapaldo> unsafeDoHarm#
10:02:13 <LoganCapaldo> (# unboxed tuple #)
10:02:13 <conal> LoganCapaldo: i think ghc uses {-# ... #-}
10:02:18 <Botje> unsafeJuggleChainsaws
10:02:27 <conal> LoganCapaldo: oh -- those ones
10:03:05 <vincenz> nielsbergsma: functions don't have side-effects, ever
10:03:16 <vincenz> nielsbergsma: that's what it means to be pure
10:03:26 <vincenz> hence you use monads to structure side-effects
10:03:26 <LoganCapaldo> lol
10:04:03 <LoganCapaldo> you sometimes use monads to structure side effects. sometime you use monads for things totatally side-effect free
10:04:04 <nielsbergsma> vincenz:  so in short to create an extra channel for the side-effects ?
10:04:11 <vincenz> nielsbergsma: in effect, yes
10:04:28 <vincenz> nielsbergsma: but I suggest you read up on monads
10:04:37 <vincenz> nielsbergsma: and, learn to do away with overusing them
10:04:43 <vincenz> monads should only be used when they should be
10:04:57 <vincenz> most haskell newbies tend to do everything in IO, cause they're used to side-effectful programming
10:05:24 * LoganCapaldo suspects learning about Monads (unless you're a category theoretical mathematician learning to program) is almost always putting the cart before the horse
10:05:24 <vincenz> nielsbergsma: but I haven't slept in quite a bit, so I'm afraid I'm not your best help
10:05:30 <vincenz> + I'm expecting someone to come look at my appt
10:05:32 <nielsbergsma> vincenz: oke, thanks for the tips so far
10:05:49 <vincenz> there was an intro to monads, but I can't locate it
10:05:49 <b_jonas> the monads that acually have a simple implementation like Maybe, [], Either e, (->) help understanding the ones whose implementations I don't actually know, like IO
10:06:08 <vincenz> http://www.prairienet.org/~dsb/monads.htm
10:06:10 <vincenz> that's one
10:06:34 <LoganCapaldo> write a program, discover problems, find solutions. Discover the same problems again, realize its a whole class of problems, come in here, ask about how to solve this class of problems generally, discover theres a monad for that, learn the monad, lather, rinse , repeat
10:06:47 <vincenz> nielsbergsma: http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
10:06:50 <nielsbergsma> I took a course of haskell and the didn't teach me about monads and manoids... I want to experiment with haskell a bit more, but I needed to figure this out
10:07:02 <mauke> monoids are totally simple
10:07:08 <vincenz> nielsbergsma: monads are definitely an 'aha-erlebens
10:07:57 <nielsbergsma> thanks all for the links, I will read them
10:08:30 <LoganCapaldo> random question, has anyone done Reader in C++ in a way that wasn't a total ugly gnarly mess?
10:10:21 <dancor> how do i figure out why arrows are more general than monads?  "partially static" sounds like state monad and "allowing multiple inputs" sounds like something you could do with M [x]..
10:10:47 <LoganCapaldo> AIUI he're more general because it's possible to "peek"
10:11:31 <hpaste>  TomMD pasted "Error catching done right?" at http://hpaste.org/5585
10:11:33 <rnorris> another random question (in case you don't like that other one): does anyone have an example of how to use Control.Monad.CC.Cursor? i'm a beginner and have not acquired sufficient mojo to figure it out from the haddock
10:11:41 <LoganCapaldo> although I do't think "partially static" sounds like the state monad
10:11:48 <TomMD> Question on error handling / catch (see above paste).  Is this correct?
10:12:03 <TomMD> Perhaps this is a good question for the ML
10:12:25 <mauke> dancor: partially static doesn't sound anything like the state monad
10:12:42 <mauke> I think the difference is that >>= lets you return a completely new action
10:12:53 <mauke> m a -> (a -> m b) -> m b
10:13:01 <mauke> so you get dynamic control flow, in a way
10:13:26 <LoganCapaldo> TomMD: I know nothing, but that looks scary
10:13:59 <LoganCapaldo> wha if the throwing thread throws an exception to the thread while you're in the middle of the handle?
10:13:59 <TomMD> LoganCapaldo: It isn't that bad... but sadly necessary.
10:14:02 <LoganCapaldo> *handler
10:14:38 <TomMD> LoganCapaldo: That really my question too.
10:14:43 <nolrai> mauke: whats the equivalent op for arrows?
10:14:58 <mauke> I don't think there is one
10:15:06 <mauke> that's why control flow is more static
10:15:09 <LoganCapaldo> just doesn't trike me as ever being possible to make safe
10:15:25 <Saizan> LoganCapaldo: there's block/unblock
10:15:58 <LoganCapaldo> Saizan: feel free to direct to TomMD <g>
10:16:02 <TomMD> LoganCapaldo: I can make it safe, but it is significantly more complex - so I want to know if this one is safe.
10:16:03 <nolrai> mauke: err.. I mean what do you use to conenct arrows then?
10:16:15 <Saizan> nolrai: (>>>)
10:16:16 <TomMD> @hoogle block
10:16:22 <Saizan> ?type (>>>)
10:16:31 <Saizan> @bot
10:16:57 <TomMD> @seen lambdabot
10:17:08 <Saizan> (>>>) :: Arrow a => a b c -> a c d -> a b d
10:18:33 <TomMD> @quit I am broken - but can I be sent away by a non-admin?
10:19:33 <LoganCapaldo> I wanna guess no,
10:20:24 <Saizan> that's mine, in the meantime :)
10:20:34 <Saizan> @bot
10:20:34 <psibot> :)
10:23:54 <JohnMeacham> woo. ChunkedFileFormat goes faster with ByteStrings.
10:29:21 <siti> has anyone tried this out yet: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/leksah-0.1
10:29:26 <psibot> http://tinyurl.com/2zmwo9
10:30:13 <siti> it sounds awesome :D
10:31:21 <dolio> Huh.
10:31:30 <dolio> You should try it and report back. :)
10:32:15 <siti> if you download  the source file it has a manual with some screenies
10:32:30 <siti> obviously it's a 0.1 release but it looks like a great start
10:34:11 <dolio> Yeah, looks pretty nice.
10:35:06 <Saizan> @users
10:35:06 <psibot> Maximum users seen in #haskell: 472, currently: 470 (99.6%), active: 5 (1.1%)
10:35:32 <siti> :)
10:36:35 <mauke> anyone here have a line with unicode math symbols ready?
10:36:56 <mauke> I want to test a new font
10:40:12 <roconnor> > 5.89 + 3.99
10:40:17 <psibot>  9.879999999999999
10:40:39 <dolio> mapM :: Monad η ⇒ (α → η β) → [α] → η [β] -- like this?
10:40:51 <opqdonut> roconnor: sounds like http://cafe.elharo.com/programming/spot-the-bug/
10:40:54 <psibot> Title: The Cafes  Spot the Bug
10:41:02 <roconnor> opqdonut: yep
10:41:06 <opqdonut> :)
10:43:52 <dons> Igloo, nomeata, thanks! http://packages.debian.org/sid/xmonad
10:43:53 <psibot> Title: Debian -- Details of package xmonad in sid
10:44:46 <Saizan> dons: the real lambdabot doesn't seem alive
10:45:04 <dons> ah ok. Cale is running it now.
10:45:39 <Cin> > "I'm a real boy!"
10:45:42 <psibot>  "I'm a real boy!"
10:46:58 <b_jonas> perhaps we need a protocol for lambdabot instances to communicate and determine which ones answers question
10:47:12 <b_jonas> with the goal that usually exactly one bot answers any query
10:47:52 <siti> maybe they can play chess or more simplistically draughts against each other
10:47:57 <siti> whoever wins gets to be the bot
10:48:23 <b_jonas> siti: yeah, but it's more complicated
10:49:05 <b_jonas> if not all are the same, they have to be able to negotiate if the best bot can't answer a query for it's missing that plugin
10:49:38 <b_jonas> btw, is there a syntax to address a lambdabot by nick?
10:49:49 <b_jonas> psibot, type liftM
10:49:55 <b_jonas> psibot, ?type liftM
10:49:57 <psibot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:50:03 <b_jonas> yeah, that
10:50:04 <b_jonas> good
10:50:15 <siti> @botsnack
10:50:15 <psibot> :)
10:50:33 <olsner> conal: investigated a bit, the unlit utility in ghc keeps all lines starting with '#' since they might be preprocessor lines.. I wonder if it should, but I guess it could cause confusion for some people with literate preprocessed haskell if this was changed
10:52:28 <dcoutts_> olsner: yeah, that's pretty important to keep that so that ghc can report accurate source locations for error messages
10:53:03 <dcoutts_> olsner: if C style line pragmas are a problem it'd be possible to use haskell style ones {-# LINE #-} instead
10:53:31 <dcoutts_> olsner: ghc's lexer understand C style ones so that it can take the output of cpp directly
11:10:32 <K0MPR3SS0R> hello
11:11:03 <K0MPR3SS0R> i have trouble with haskell trying to make a binary search tree and getting it to accept values
11:11:11 <K0MPR3SS0R> can anyone help me
11:11:30 <dons> what does your tree data type look like?
11:12:03 <monochrom> Most haskell textbooks explain this.
11:12:12 <K0MPR3SS0R> yeah well i dont get it
11:12:28 <K0MPR3SS0R> the tree data type is fine
11:12:51 <K0MPR3SS0R> its declared and everything, and im trying to add integers into the tree manually, but i get some weird error
11:12:59 <mauke> what does your tree data type look like?
11:13:05 <mauke> "it is fine" doesn't really help
11:13:05 <monochrom> Works for me.
11:13:21 <monochrom> I can't reproduce your problem. It worked for me out of the box the first time.
11:13:41 <K0MPR3SS0R> monochrome can i pm you?
11:13:43 <monochrom> mauke: Let's enjoy this pure talking while it lasts :)
11:14:01 <K0MPR3SS0R> ERROR - Cannot find "show" function for:
11:14:01 <K0MPR3SS0R> *** Expression : insertTree 5
11:14:01 <K0MPR3SS0R> *** Of type    : Tree Integer -> Tree Integer
11:14:06 <K0MPR3SS0R> thats what I get
11:14:15 <Heffalump> you didn't give it a tree to insert into
11:14:27 <mauke> insertTree needs 2 arguments
11:14:38 <K0MPR3SS0R> ok, do you mind I post my code here?
11:14:41 <K0MPR3SS0R> its very short
11:14:44 <Cin> hpaste: url
11:14:45 <hpaste> Haskell paste bin: http://hpaste.org/
11:14:55 <monochrom> use that
11:15:12 * monochrom is disappointed that it didn't last long
11:15:24 <Heffalump> that what didn't last long?
11:15:31 <monochrom> The pure talking.
11:15:45 <hpaste>  K0MP pasted "Binary Tree" at http://hpaste.org/5587
11:15:55 <K0MPR3SS0R> yes
11:16:10 <K0MPR3SS0R> so now I want to add elements to it, but I dont know how to delcare a new tree
11:16:31 <K0MPR3SS0R> I tried doing Data Tree a
11:16:33 <monochrom> insertTree 5 emtyTree ?
11:16:54 <monochrom> insertTree 6 (insertTree 5 emtyTree) ?
11:16:56 <K0MPR3SS0R> i dunno I used code from some site that explaied how to create tree
11:17:16 <K0MPR3SS0R> http://blog.moertel.com/articles/2006/10/31/introductory-haskell-solving-the-sorting-it-out-kata
11:17:17 <psibot> Title: Introductory Haskell: Solving the Sorting-It-Out Kata, http://tinyurl.com/y3l23z
11:17:18 <K0MPR3SS0R> it was here
11:18:00 * monochrom wonders at the gap between lambda and psi. mubot? nubot? ...
11:18:36 <olsner> "How do you deal with programming block?" "As a python coder, I just rely on indentation"
11:18:51 <monochrom> Who's that?
11:19:03 <K0MPR3SS0R> so any idea?
11:19:08 <thoughtpolice> it was a reddit comment
11:19:16 <monochrom> I already suggested two.
11:19:29 <olsner> monochrom: http://reddit.com/info/689uf/comments/c035784
11:19:32 <TomMD> @quote
11:19:32 <psibot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
11:20:02 <TomMD> @quote
11:20:03 <psibot> norpan says: the comonad of the No monad is the Yes monad?
11:20:31 <K0MPR3SS0R> so emptyTree = Empty
11:20:37 <K0MPR3SS0R> declares the actual tree?
11:22:18 <K0MPR3SS0R> arrghhh...i dont get this..
11:22:36 <b_jonas> monochrom: nickserv says that mubot, xibot, and chibot are registered
11:22:37 <K0MPR3SS0R> i tried it, and it keeps saying Root empty 5 empty
11:22:47 <K0MPR3SS0R> as if its just putting 5 at the root
11:22:58 <b_jonas> but not the others between lambda and psi unless they use some alternate spelling of the names of letters
11:22:58 <K0MPR3SS0R> and then I just add more numbers, and it simply changes teh root
11:23:23 <K0MPR3SS0R> i think...
11:23:23 <monochrom> I also suggested insertTree 6 (insertTree 5 emtyTree)
11:23:30 <monochrom> Have you tried that?
11:23:38 <K0MPR3SS0R> ill give it a shot
11:24:18 <monochrom> Why didn't you give it a shot 7 minutes ago when it was first said?
11:24:28 <K0MPR3SS0R> didnt see that one
11:24:45 <K0MPR3SS0R> so now if I want to input a list of numbers
11:24:45 <monochrom> All you are willing to do is keep saying "i dunno" when a million suggestions fly by your face.
11:24:57 <b_jonas> also rhobot, I somehow missed that
11:25:14 <K0MPR3SS0R> well a lot of stuff was displayed in this room, most of which wasnt relevant
11:25:22 <longlivedeath> -quit
11:25:26 <brian`> >let avg l = (foldl (+) 0 l)/(length l)
11:25:32 <olsner> rhobot ~= rowboat :P
11:25:35 <brian`> >avg [1,2,3]
11:25:50 <brian`> >3+3
11:26:03 <K0MPR3SS0R> i mean I asked to pm you, but you wanted to talk here, and its not the most ideal, so why are you getting pissed at me?
11:26:04 <dons> > 3+3
11:26:06 <brian`> hm..? is lambdabot dead?
11:26:07 <psibot>  6
11:26:12 <brian`> > 3+3
11:26:15 <psibot>  6
11:26:18 <olsner> brian`: need a space after >
11:26:24 <brian`> olsner, gotcha
11:26:29 <brian`> > let avg l = (foldl (+) 0 l)/(length l)
11:26:29 <psibot>  Parse error at end of input
11:26:56 <brian`> > let avg l = (List l) => (foldl (+) 0 l)/(length l)
11:26:57 <psibot>  Parse error at "=>" (column 22)
11:27:30 <resiak> @let avg l = (foldl (+) 0 l)/(length l)
11:27:30 <psibot> <local>:1:8:     No instance for (Fractional Int)       arising from a use of...
11:27:34 <b_jonas> so in the whole line, there's: alphabot betabot deltabot zetabot kappabot lambdabot mubot xibot rhobot chibot psibot
11:28:48 <b_jonas> 11 out of 24, not bad
11:28:57 <brian`> gammabot
11:29:00 <brian`> etabot
11:30:52 <b_jonas> brian`: ?
11:31:10 <brian`> b_jonas, was just naming them lol
11:31:18 <brian`> how do I make it work?
11:31:19 <brian`> @let avg l = (List l) => (foldl (+) 0 l)/(length l)
11:31:20 <psibot>  Parse error
11:31:30 <brian`> @let avg l = (foldl (+) 0 l)/(length l)
11:31:31 <psibot> <local>:1:8:     No instance for (Fractional Int)       arising from a use of...
11:32:08 <brian`> can I specify context in let statement too?
11:32:14 <mauke> @let avg xs = sum xs / fromIntegral (length xs)
11:32:15 <psibot> Defined.
11:32:22 <mauke> > avg [1,2,10,13]
11:32:23 <brian`> aha..
11:32:25 <psibot>  6.5
11:32:29 <brian`> thanks
11:34:18 <gour> @seen ndm
11:34:18 <psibot> I haven't seen ndm.
11:35:15 <dons> @uptime
11:35:16 <psibot> uptime: 7d 6h 40m 59s, longest uptime: 1m 10d 23h 44m 29s
11:35:30 <dons> K0MPR3SS0R: have you been able to work out what was going wrong?
11:38:32 <K0MPR3SS0R> ah man no i give up
11:38:39 <K0MPR3SS0R> been reading haskell book
11:38:55 <K0MPR3SS0R> im kinda hating it so far
11:39:19 <oerjan> @users
11:39:20 <psibot> Maximum users seen in #haskell: 472, currently: 472 (100.0%), active: 14 (3.0%)
11:39:42 <K0MPR3SS0R> my assignment is to basically take a list of strings ['alpha', 'beta', 'gamma', 'delta' etc...] then add it to a bunch of binary trees
11:40:01 <mauke> balanced binary trees?
11:40:24 <K0MPR3SS0R> then sort the binary trees on the basis of the depth of the tree
11:40:25 <oerjan> psibot? o_O
11:40:45 <K0MPR3SS0R> then print out the list of the root value of sorted binary trees
11:40:48 <vininim> > 16*16+16
11:40:52 <psibot>  272
11:41:14 <vininim> > 15*15+15
11:41:17 <psibot>  240
11:41:21 <K0MPR3SS0R> output would be something like b a g d whatever
11:41:48 <K0MPR3SS0R> so its not due for quite some time , but I have a feeling its going to be a few headaches
11:41:56 <gwern> my god DrIFT is a mess. between the autotools, make, the sh scripts creating .hs files, and so on, it's a real pain
11:42:07 <dons> K0MPR3SS0R: a good solution to this will be 10 - 15 lines of code
11:42:21 <K0MPR3SS0R> i know, but its the how that matters
11:42:22 <dons> if that's motivating for you :)
11:42:24 <kbateman> > map (\x -> x*x+x) [1..50]
11:42:27 <psibot>  [2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,50...
11:42:38 <dons> let me point you at some similar binary tree code
11:42:42 <K0MPR3SS0R> for a newbie like me I have a feeling its going to be incredibly hard
11:42:47 <K0MPR3SS0R> k
11:43:12 <mauke> does it make sense to do the node swapping in splay trees with a zipper?
11:43:14 <gwern> dons: I've discovered that part of the reason my cabalization of drift is failing is because the makefiles call a shell script which writes a Haskell modules (!)
11:43:15 <dons> well, data types are a lot easier in haskell, since you don't need to worry about how to allocate them in memory, and you can pattern match on them, to take them apart
11:43:23 <kbateman> @pl \x -> x*x+x
11:43:24 <psibot> (+) =<< join (*)
11:43:27 <dons> K0MPR3SS0R: this is a binary trees program too, http://shootout.alioth.debian.org/gp4/benchmark.php?test=binarytrees&lang=ghc&id=4
11:43:28 <psibot> Title: binary-trees Haskell GHC #4 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4  ..., http://tinyurl.com/29t7q2
11:43:38 <dons> so you might get some ideas on how to pattern match, and traverse trees recursively
11:43:44 <dons> especially towards the bottom of the program
11:44:05 <dons> gwern: scary.
11:44:37 <K0MPR3SS0R> ok thanks dons, im gonna look at that!
11:44:41 <gwern> dons: it's madness. metaprogramming in sh? I'm sorely tempted to just run it once and replace it with its output...
11:44:46 <dons> K0MPR3SS0R: note that its a slightly different binary tree, it only stores Int, not arbtirary 'a'
11:45:06 <thoughtpolice> gwern: been cabalizing packages that aren't, lately?
11:45:20 <K0MPR3SS0R> btw this is ghc? im using hugs
11:45:25 <K0MPR3SS0R> syntax looks different
11:45:30 <dons> no, that's just haskell
11:45:34 <gwern> thoughtpolice: aw shucks, how'd you figure out?
11:45:41 <dons> but perhaps a little advanced
11:45:45 <K0MPR3SS0R> really?
11:45:47 <K0MPR3SS0R> ok
11:45:49 <dons> if you can get ghc, its a good idea -- the code's a lot faster
11:45:59 <thoughtpolice> gwern: i normally check the recent hackage packages daily to see if there's anything popping up to make life easier.
11:46:07 <K0MPR3SS0R> but its more complicated?
11:46:08 <dons> thoughtpolice: do you use the rss feeds?
11:46:13 <thoughtpolice> dons: not as of current.
11:46:16 <dons> K0MPR3SS0R: ghc? yes. its a lot bigger.
11:46:27 <gwern> it'd be cool if lambdabot parsed the rss feeds for hackage, and announced uploads.
11:46:29 <dons> http://hackage.haskell.org/packages/archive/recent.rss
11:46:32 <thoughtpolice> i use my newsreader every once in a while, but not much.
11:46:35 <K0MPR3SS0R> right now using hugs from remote ssh terminal
11:46:38 <dons> gwern: good idea. i started doing a couple of rss plugins.
11:46:41 <dons> K0MPR3SS0R: ok. that's fine.
11:46:42 <gwern> not everything gets ANNced, not everyone is on haskell-cafe, etc
11:46:55 <gwern> dons: oh, you've already got something going?
11:46:56 <dons> you should be able to get the general idea of pattern matching on the tree, and recursing to the children nodes
11:47:03 <dons> gwern: not for hackage, but for some other rss things
11:47:07 <dons> like the weather forecast
11:47:39 <gwern> hm. so lament would post to the channel whenever the forecast changed?
11:47:56 <gwern> er, lambdabot
11:47:56 <oerjan> poor lament
11:48:15 <b_jonas> gwern: is metaprogramming in sh like this obfu I wrote once:  eval perl{\ \''-lne/"(.*','.*)".(...)/x&&%{uc$2}&&print$1'\',\"doc,faq1\|\"}
11:48:15 <gwern> (lament for poor lament! tell me sooth, *is* there balm in Gilead?)
11:48:45 <hpaste>  gwern pasted "here ya go jonas" at http://hpaste.org/5588
11:50:25 <olsner> aack, cabal doesn't know about the gtk, glib, and sourceview packages
11:50:45 <hpaste>  (anonymous) annotated "here ya go jonas" with "output - ew ew ew!" at http://hpaste.org/5588#a1
11:52:10 <b_jonas> oh, like that
11:52:44 <gwern> alright, that's it. collect_rules must be burned with fire. it is an ugly method, and it doesn't even produce good output - the ultimate sin
11:52:47 <b_jonas> I once fixed some bugs in a make depend rule which counts as metaprogramming because it's a make rule that generates a makefile
11:53:08 <b_jonas> and once I did something even more horrible but it didn't quite come out well:
11:54:44 <b_jonas> I wrote a shell script that preprocessed text files (specifically c sources) in a special way: it used sed to convert the text to an ed script that contained mostly just literal text to append but special directives in the text allowed you to insert any ed command
11:55:04 <b_jonas> and then ran that ed script
11:55:09 <olsner> it's funny how this must have been more work than it ever would have been to add a line or two in that file at the same time as you add a Rules module
11:55:19 <mauke> b_jonas: sounds like hsc2hs
11:55:49 <gwern> olsner: yes. I intend to include that reasoning in the annotation to the patch. when we were arguing with meachem over Cabalization the other day, he sounded attached to his hacked together setup
11:58:38 <kpreid> dons: what's up with lambdabot?
11:59:16 <monochrom> autism
11:59:50 <dons> Cale's running a 6.8.2 bot
12:00:48 <dcoutts_> dons: code for reading the hackage rss would be very handy for a hackage build bot
12:02:30 <oerjan> @users
12:02:30 <psibot> Maximum users seen in #haskell: 477, currently: 475 (99.6%), active: 17 (3.6%)
12:02:36 <dcoutts_> apparently buildbot keeps an open connection while the build goes on so it's not robust to network problems, it should be more asynchronous where the bots read the rss feed and report results back when they're ready
12:02:45 <oerjan> wind it up!
12:02:58 <dcoutts_> and that's what we should do with hackage and cabal-install
12:03:19 <gwern> yes! drift now compiles from an sdist tarball! all I have to do now is figure out how to call 'autoreconf -i' from cabal
12:03:43 <Igloo> dcoutts_: The buildbot client doesn't know how to finish the build if the connectino dies
12:05:44 <dons> dcoutts_: so its trivial. see the hackage2hwn plugin
12:05:54 <dons> which sucks down the rss, parses it, and pprs
12:06:05 <dons> Igloo++ debian xmonad packages!
12:06:33 <dons> so I might announce all the packaged distros now, and watch in hope at the popcon graphs :)
12:17:24 * desegnis got terrified today when he learnt how many kinds of implication/conclusion are to be found in usual propositional logic
12:19:39 <gwern> hey, anyone want to try installing DrIFT from hackage?
12:19:42 <nominolo> dcoutts_: ok, the problem are indeed the dependencies of regex-compat
12:19:44 <gwern> I just did a test upload
12:19:48 <gwern> *am doing, whatever
12:19:59 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/DrIFT-2.2.3
12:20:01 <psibot> http://tinyurl.com/yq8v9w
12:20:07 <thoughtpolice> gwern: i'll give it a shot
12:20:22 <nominolo> dcoutts_: the problem though is, that if you hide the newer regex-{base,posix} cabal-install will just re-install them from hackage
12:20:22 * gwern is particularly interested in i386 users - I'm not sure running autoreconf -i on the tarball is safe
12:20:40 <nominolo> dcoutts_: so we need  at least some kind of manual dependency constraints
12:20:47 <nominolo> dcoutts_: at least for trouble-shooting
12:21:00 <dons> gwern:
12:21:01 <dons> Building DrIFT-2.2.3...
12:21:01 <dons> src/DrIFT.hs:18:7:
12:21:01 <dons>     Could not find module `Version':
12:21:02 <dons>       Use -v to see a list of the files searched for.
12:21:18 <pejo> gwern, does building things from hackage require autotools to be installed?
12:21:25 <nominolo> dons: which Cabal versions do you have installed?
12:21:25 <gwern> shoot.
12:21:38 <nominolo> pejo: depends on the package
12:21:39 <dons> Cabal-1.3.3
12:21:42 <gwern> pejo: not usually. in this case, I'm trying to rip out as little of the autotolls as possible to avoid angering the maintainer
12:21:45 <nominolo> dons: ok, that's too new
12:21:48 <dons> ah ok
12:22:04 <nominolo> dons: try ghc Setup.hs -package Cabal-1.2.3.0
12:22:09 <nominolo> dons: -o setup
12:22:16 <pejo> gwern, oh, don't rip them out, just ship the scripts with the release like other programs do.
12:22:18 <dons> i can't feed that info to cabal-install though?
12:22:27 <gwern> dons: is there a src/Version.hs? it's a generated file
12:22:29 <nominolo> dons: oh, right. hm
12:23:13 <dons> scala port of Data.Binary, almost, http://unenterprise.blogspot.com/2008/02/easy-binary-serialization-of-scala.html
12:23:15 <psibot> Title: Desperately UnEnterprise: Easy binary serialization of Scala types, http://tinyurl.com/2akzqv
12:23:19 <nominolo> gwern: DriFT doesn't use Cabal's Version datatype?
12:23:24 <dons> dcoutts_: we should really write a paper on this now
12:23:35 <gwern> nominolo: no...
12:23:47 <gwern> if it's a problem, I guess I'll replace it too
12:23:52 <thoughtpolice> gwern: built :)
12:24:05 <thoughtpolice> seemed to go fine although there were what, 9,000 warnings? :)
12:24:09 <nominolo> dons: ok, then Cabal is not the problem
12:24:45 <gwern> thoughtpolice: yeah, I'll do -Wall cleanup once I can build it normally
12:24:54 <gwern> thoughtpolice: did you have to do anything special?
12:25:06 <thoughtpolice> gwern: nope. runghc Setup.hs configure ; runghc Setup.hs build worked fine
12:25:28 <gwern> thoughtpolice: oh, great.
12:25:36 <gwern> dons: did you get it built yet?
12:29:02 <nominolo> dcoutts_: see http://groups.google.com/group/yi-devel/msg/b29679b7dae81349
12:29:03 <psibot> Title: No instance for (RegexLike Regex B.ByteString) - yi.devel | Google Groups
12:31:14 <gwern> the yi problem is nasty. I tried again today, unregistered all the regex and bytestring packages, and still hit it
12:31:41 <nominolo> we have a fix now
12:31:49 <nominolo> but it requires manual install
12:32:03 <nominolo> or, manual downgrading
12:32:39 <nominolo> the real problem is the build-depends field in regex-compat's .cabal
12:34:19 <nominolo> @users
12:34:19 <psibot> Maximum users seen in #haskell: 479, currently: 475 (99.2%), active: 8 (1.7%)
12:34:26 <nominolo> whoa
12:34:53 <dons> awesome bananas
12:35:09 <nominolo> dons: didn't you have a chart for this?
12:35:12 <Valodim> I have a mathematical, theoretical question
12:35:18 <Valodim> what is the number "1" defined as?
12:35:35 <dmwit> {\emptyset}
12:35:40 <nominolo> Valodim: choose one :)
12:35:41 <dons> http://www.cse.unsw.edu.au/~dons/irc/ ?
12:35:52 <kmcallister> Valodim, you can define the natural numbers in terms of sets
12:35:53 <kmcallister> 0 is {}, and n is {0, 1, ..., n-1}
12:35:55 <psibot> Title: Haskell IRC Activity
12:36:20 <dmwit> zero = emptyset
12:36:27 <Valodim> yeah but it's not based on any natural constant is it
12:36:37 <dmwit> succ n = union n (singleton n)
12:36:37 <vincenz> roconnor: My condolances
12:36:47 <nominolo> dons: that one, thanks
12:37:59 <Valodim> we defined 1, and calcuate - for instance - pi from it as 1 * 3.14159...
12:38:13 <TomMD> Is Peng Li in IRC, anyone?
12:38:33 <dmwit> Valodim: Right, 1 is an arbitrary reference distance from zero.
12:38:45 <Valodim> it really is arbitrary?
12:38:57 <Valodim> huh
12:38:59 <Cale> Well...
12:39:08 <Cale> It depends on how you look at it.
12:39:26 <Cale> If you only have addition, then 1 is arbitrary.
12:39:37 <Valodim> but?
12:39:37 <monochrom> Do you accept (\f x -> f x) as a definition of 1?
12:39:47 <Cale> Once you throw in multiplication, then 1 has a special property which sets it apart from the rest of the numbers.
12:39:57 <Valodim> monochrom: the definition is clear, I'm just wondering about the background
12:39:57 <oerjan> dons: what time zone does your irc stats use?  it is not mentioned anywhere
12:40:04 <Cale> Specifically, the fact that 1 * a = a * 1 = a for all a.
12:40:22 <dmwit> Sure, but that's just an artifact of how we defined multiplication.
12:40:22 <Valodim> cale: that's not what I mean
12:40:30 <Cale> If you'd like, I can say a bit about how the various types of numbers are constructed in terms of set theory.
12:40:40 <monochrom> Not sure about what "background" means. Historic background? The idea of 1 dates back to hunting pre-history.
12:40:54 <Cale> Or are you more interested in a particular kind of numbers (reals?)
12:41:08 <nominolo> @localtime lambdabot
12:41:29 <dmwit> She's gone, psibot is in command now.
12:41:41 <dmwit> ?localtime dons
12:41:42 <psibot> Local time for dons is Sun Feb 10 12:41:41 2008
12:42:09 <monochrom> 1 little, 2 little, 3 little rabbits
12:42:10 <Valodim> [21:38] dmwit: Valodim: Right, 1 is an arbitrary reference distance from zero.
12:42:10 <Valodim> basically, this. I find it interesting how the most important number isn't based on _anything_
12:42:12 <dmwit> ?localtime dmwit
12:42:13 <psibot> Local time for dmwit is Sun Feb 10 12:42:29
12:42:17 <Cale> The naturals are actually (at least halfway) handed to you by the axioms of set theory. The axiom of infinity says that there is a set X which contains the empty set, and such that if x is in X, then so is x union {x}
12:42:22 <monochrom> 5 little, 8 little, 13 little rabbits...
12:42:31 <dmwit> monochrom: teehee!
12:42:41 <nominolo> dmwit: dons no longer lives next to lambdabot
12:42:57 <dmwit> That's true.
12:43:15 <olsner> ?localtime psibot
12:43:15 <psibot> I live on the internet, do you expect me to have a local time?
12:43:20 <monochrom> I dispute the religion of always using sets to define other things.
12:43:46 <monochrom> "A monad is a set with ..."
12:44:02 <Cale> This is restricted somewhat (using the axiom of comprehension) to give a set N like that, but such that if x is in N, then x is the empty set, or else x = y union {y} for some y in N
12:44:04 <dmwit> Set?  Category...
12:44:23 <Cale> We identify that set as the natural numbers.
12:44:26 <monochrom> The members of that religion surely use sets to define categories too.
12:44:48 <gwern> @hoogle FuncterM
12:44:49 <psibot> No matches found
12:44:50 <dolio> They'd need to use proper classes for some of them.
12:44:52 <dmwit> I don't think so.  I think they were shying away from some kind of ninny-hearted paradox.
12:44:56 <monochrom> Anyway, to balance the forces, I use the lambda calculus to define other things.
12:45:17 <oerjan> gwern: FunctorM was replaced by Traversable
12:45:27 <gwern> oerjan: oh. I thought it sounded obsolete
12:45:41 <Cale> Sets are a nice flexible foundation which is pretty easy to work with. Category theory is a nice way to look at things, but it makes it hard to build things directly.
12:46:02 <dolio> @hackage functorm
12:46:02 <psibot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/functorm
12:46:03 <Valodim> I'm just saying, why not define the empty product as, say, pi or e or some other natural constant
12:46:06 <Cale> For example, try defining the category of rings with only category theoretic concepts :)
12:46:22 <Cale> Valodim: Because those numbers are defined in other ways which make them not the identity.
12:46:37 <Cale> It's not the case that pi * a = a for any number a
12:46:52 <Cale> With our usual conception of multiplication, anyway.
12:46:57 <Valodim> yes but that is a matter of definition
12:47:14 <dmwit> Not really.
12:47:26 <dmwit> You have to define multiplication before you can define pi.
12:47:38 <Valodim> so there is no reason besides historical ones, that 1 is basically defined as pi * (1/pi)
12:47:43 <Valodim> dmwit: no you don't
12:47:46 <Cale> pi = 2 (integral from -1 to 1 of sqrt(1-x^2) dx)
12:48:01 <monochrom> IMO certain things are more appropriately left abstract. Not "defined", but given enough properties.
12:48:05 <Cale> You need to define a heck of a lot more than multiplication before you define pi :)
12:48:19 <dmwit> Valodim: Pi is often defined as the ratio of the areas of a square and circle; as these aren't the same size, the ratio can't be the unit of multiplication.
12:48:59 <Valodim> by our definition of multiplication, yes, because pi is defined as 1 * 3.14159...
12:49:23 <Cale> Even just to say what you mean by "area of a circle", or "area of a square", you need to know what multiplication is.
12:49:29 <mauke> "3.14159..." is not a well-defined number
12:49:48 <Cale> Valodim: How do I get the next digit of that?
12:49:49 <Valodim> if we defined 1 as the distance from 0 to pi, instead of 0 to "1" which is completely arbitrary, it could well be the empty product
12:49:57 <Valodim> 2*pi?
12:50:28 <Cale> Valodim: Writing 3.14159... doesn't serve as a definition of pi.
12:50:42 <Valodim> ?
12:50:46 <Cale> Valodim: Because, you could mean the number 3.14159141591415914159...
12:50:47 <Valodim> what does that have to do with anything >_>
12:50:50 * desegnis always thought the »often« definition would be the ratio of the circumference of a circle and its diameter
12:51:13 <Cale> desegnis: It works too, but you need to define arclength for that one.
12:51:13 <synthasee> to its diameter not "and its diameter"
12:51:19 <mauke> Valodim: you wanted to define pi as 1 * 3.14159...
12:51:33 <Valodim> that's how it is defined (note the ...)
12:51:38 <Cale> Valodim: no it's not.
12:51:39 <mauke> no, it isn't
12:51:39 <desegnis> Cale, ok
12:51:59 <Valodim> wtf that isn't the point, I could have written any term that defines it precisely
12:52:02 <oerjan> desegnis: area is simpler to define rigorously than curve length
12:52:13 <desegnis> synthasee, ok, learnt :)
12:52:31 <Cale> Valodim: Once you've defined a term which defines it precisely, we can prove that term is not the identity for multiplication :)
12:52:53 <Valodim> that's because you have multiplication defined in dependency of 1
12:53:21 <phlpp> what's ET? UTC-5?
12:53:27 <phlpp> (offtopic)
12:53:35 <Cale> Multiplication isn't defined in terms of 1, it's the other way around.
12:53:46 <monochrom> 1 little, 2 little, 3 little dot dot dots, 5 little, 8 little, 13 little dot dot dots, ...
12:53:59 <dolio> phlpp: That sounds right.
12:54:04 <phlpp> dolio: thanks
12:54:17 <Cale> Valodim: 1 is defined as the number which when multiplied by any other, leaves that number the same.
12:54:21 <Valodim> yeah whatever way around it's an abstract number nowhere found in nature
12:54:33 <Valodim> or anywhere else
12:54:34 <mauke> 1 := identity(*)
12:54:35 <Cale> Nature doesn't contain numbers.
12:54:35 <monochrom> pi isn't found in nature either.
12:54:40 <mux> pi has a nice definition has a continued fraction
12:54:47 <mauke> multiplication isn't found in nature
12:55:08 <Cale> It (maybe) contains particles and forces, though even that is a matter of modelling.
12:55:19 <TomMD> The groups turkey that double every year disagree with you, mauke.
12:55:23 <synthasee> hm, could we say it is a way to think about parts of nature?
12:55:29 <Valodim> cale: but it contains several concepts to base an abstract number on, instead of leaving it completely arbitrary
12:55:31 <TomMD> s/turkey/turkeys
12:55:38 <monochrom> Yes, it is a way to think.
12:55:50 <Cale> Valodim: Mathematics isn't trying to reason about nature.
12:56:00 <Cale> Valodim: That's not the point of the game :)
12:56:48 <Cale> It's a very handy outcome though, that the abstractions devised in mathematics can be used to reflect our observations and model them.
12:57:15 <b_jonas> now that I've studied too much mathematics, I think pi is best defined as half the least positive root of sine, where sine is definied by its power series
12:57:29 <b_jonas> but I can be argued about that
12:57:43 <Cale> b_jonas: Not a bad definition :)
12:57:52 <desegnis> Cale, that's how science is commonly understood today, and it reflects my own opinion; but it's not the only opinion
12:57:52 <b_jonas> what's more interesting is how you define everything else
12:58:09 <b_jonas> including real numbers, arithmetic on them, etc
12:58:15 <waern> desegnin: exactly
12:58:55 <Taejo> b_jonas: last year I studied Real Analysis, and the lecturer kept saying, "when we define the real numbers"... and never did
12:58:59 <dmwit> > sin pi
12:59:05 <FunctorSalad> Cale: hmm sorry for jumping in without having read all the context, but is there really one canonical way for defining 1 (of the integers, I suppose)?
12:59:06 <psibot>  1.2246063538223773e-16
12:59:06 <Cale> desegnis: Well, sure, there are always other philosophies. This is the one which I think reflects best what mathematicians are doing.
12:59:10 <dmwit> b_jonas: *half* the least positive root?
12:59:20 <b_jonas> dmwit: uh, no
12:59:25 <b_jonas> the least positive root
12:59:29 <b_jonas> yeah, I'm just stupid
12:59:34 <dmwit> =)
12:59:35 <Taejo> FunctorSalad: in the naturals, 1 is the successor of 0
12:59:43 <Taejo> 0 is the empty set
12:59:45 <desegnis> Cale, I agree
12:59:47 <Cale> FunctorSalad: Well, depends on how you're constructing the rest of the numbers, but once you have multiplication, it had better be the number which is the identity for that.
13:00:06 <FunctorSalad> you could start with Peano and define mult. in terms of 1, but you could also define the naturals as the initial ring or whatever, with multiplication being primitive
13:00:28 <FunctorSalad> Cale: ah ok, agreed
13:00:31 <Cale> FunctorSalad: Defining 1 as any other number would just serve to confuse people.
13:00:36 <dolio> Half the second-least positive root. :)
13:00:54 <dmwit> dolio: yuck =)
13:01:05 <dmwit> Half the period might be better, but harder to make rigorous.
13:01:09 <FunctorSalad> I misunderstood the context, thought it was about which concept is more elementary
13:01:38 <Valodim> I was just wondering why 1 is defined as a completely arbitrary distance from 0
13:01:39 <FunctorSalad> of course in the end 1 should be what we think it is :)
13:01:41 <dmwit> FunctorSalad: Valodim is concerned that defining 1=pi would have outrageous consequences.  Mostly, we agree. =)
13:01:55 <Cale> Valodim: Oh, I have a good reason that I think you'll accept.
13:02:10 <Cale> Valodim: "distance" in the sense which you mean it, is meaningless in this context.
13:02:18 <Cale> Valodim: Real numbers are unitless.
13:02:21 <dolio> Is some state legislature threatening to do that or something?
13:02:35 <dmwit> heh
13:02:40 <Cale> Valodim: 1 isn't the same thing as 1 metre, nor is it 1 inch.
13:03:17 <FunctorSalad> Valodim: 1 is indeed as good as any other real number if you only have the additive structure, but it is special if you also have the multiplicative structure
13:03:19 <synthasee> dolio: I saw that someone was wanting to abolish fractions from school curriculum(in the US)
13:03:34 <Valodim> hum
13:03:37 <dolio> Nice.
13:03:41 <synthasee> someone thought they were obsolete
13:03:41 <kpreid> ?join #rosettacode
13:03:41 <psibot> Not enough privileges
13:03:43 <dolio> Fractions are pretty hard.
13:03:51 <FunctorSalad> ... lets go shopping
13:03:55 <kpreid> since lambdabot is down, can we have psibot in #rosettacode?
13:04:00 <FunctorSalad> (scnr)
13:04:04 <kpreid> someone asked for an explanation of monads :)
13:04:16 <dmwit> LGS, the newest TLA
13:04:25 <Valodim> the definition of 1 is a mostly philosophic question I guess
13:04:41 <monochrom> 1 = monad?
13:04:55 <Valodim> pi = monad
13:04:57 <Valodim> hehe
13:04:59 <Cale> Valodim: In terms of "distance" as a mathematician would refer to it, the distance from 0 to 1 is 1, but that's just because the distance between x and y is defined as |x - y|, and so it's another unitless concept.
13:05:29 <synthasee> dolio: http://www.usatoday.com/tech/science/mathscience/2008-01-23-fractions_N.htm is what I'm referring to
13:05:31 <desegnis> The problem of mathematics is you never know how much philosophy to include so it remains mathematics
13:05:31 <psibot> Title: Professor: Fractions should be scrapped - USATODAY.com, http://tinyurl.com/2qj7ot
13:06:02 <monochrom> There are many different "1"s, if you look harder. set 1 /= natural 1 /= integer 1 /= real 1 ...
13:06:11 <Cale> Sigh. Decimal expansions should be scrapped.
13:06:30 <Valodim> [22:05] desegnis: The problem of mathematics is you never know how much philosophy to include so it remains mathematics
13:06:30 <Valodim> yessir =)
13:06:39 <Cale> They've done nothing but confuse laypeople about the nature of what numbers are.
13:06:40 <FunctorSalad> Cale: I think the natural scientists would oppose ;)
13:06:42 <gwern> ok, I just uploaded a DrIFT without autotools: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/DrIFT-2.2.3
13:06:43 <psibot> http://tinyurl.com/yq8v9w
13:06:45 <gwern> give it a shot!
13:06:57 <Cale> FunctorSalad: They should be working with rational intervals anyway.
13:07:34 <monochrom> Can I give you (2/3, 4/5) cents?
13:07:53 <Cale> monochrom: hehe :)
13:07:56 <dmwit> Certainly!
13:07:57 <monochrom> I think laypeople are more concerned about money than about numbers. That's why they love decimals.
13:08:09 <Cale> But those are really integers.
13:08:16 <Cale> Not real numbers.
13:08:35 <dmwit> Join the 10000% inflation club!
13:08:46 <dmwit> Campaign stickers to the first 10 contributers.
13:09:12 <dolio> synthasee: No more arithmetic, eh? I suppose I can tentatively get behind that.
13:09:21 <dmwit> Or a CD if you donate 25000 cents or more!
13:09:26 <oerjan> @hoogle a -> a -> Rational
13:09:26 <monochrom> Bankers love to charge 4.5% interest on 3 cents. Their greed for money, and their greed for more decimal digits, is endless.
13:09:27 <psibot> No matches, try a more general search
13:09:45 <oerjan> @hoogle a -> Rational
13:09:46 <psibot> Prelude.toRational :: Real a => a -> Rational
13:09:50 <dmwit> :t (%)
13:09:52 <monochrom> Oops, that is not poetic enough.
13:09:52 <gwern> no - no one wants to try my DrIFT upload? :(
13:09:53 <psibot> forall a. (Integral a) => a -> a -> Ratio a
13:09:55 <dolio> Let's go back to New Math.
13:09:55 <gwern> my feelings are hurt
13:10:09 <Cale> The confusion about the use of % is another thing which really annoys me. People write down formulas like A/B * 100 = percentage ratio of A to B. The % sign *means* divided by 100 already.
13:10:11 <gwern> you could even just cabal-install it after an update
13:10:14 * gwern is not picky
13:10:17 <monochrom> Bankers love to charge 4.5% interest on 3 cents. Their greed for more decimal digits is endless,  as is their greed for money.
13:10:30 <dmwit> Cale: That is also one of my pet-peeves.
13:10:44 <desegnis> monochrom: You're a poet now?
13:10:52 <dmwit> Did you also get ratted out in physics classes for including units on everything, as I did? =P
13:11:21 <gwern> dmwit: we got ratted out for not including units
13:11:28 <Cale> dmwit: That was a problem? I think we were required to include units at least.
13:11:47 <dmwit> (Them: What is this multiplication by one business over here?  Me: That's the conversion constant!)
13:12:54 <FunctorSalad> hmm, how should real numbers be taught in school if not as decimal expansions?
13:12:56 <dmwit> There was some constant that ended up being 1 (with the right units) and I always included it as a sanity check.  My TA got pissed. =P
13:12:56 <Cale> I rather like the approach to change of basis matrices which uses the matrix for the identity operator expressed with respect to the two bases.
13:13:09 <Cale> FunctorSalad: Using the axioms, I think.
13:13:14 <Cale> FunctorSalad: If at all.
13:13:32 <monochrom> Ban calculators. That's the root problem.
13:13:46 <Cale> That is, (without saying what a field is, or anything), the axioms for a Dedekind-complete ordered field.
13:13:59 <FunctorSalad> hmm, or maybe interval nesting
13:14:15 <dolio> gwern: That's a lot of warnings. :)
13:14:19 <FunctorSalad> (maybe that's more intuitive)
13:14:22 <Cale> That might also work.
13:14:32 <darrint> Is there a keyword to stop compilation in a file?
13:14:33 <oerjan> dmwit: no wonder you ended up with haskell :D
13:14:38 <Cale> And it has more to do with how scientists should be using numbers anyway.
13:15:10 <dmwit> oerjan: Yup, put me in a straitjacket right away. =)
13:15:14 <dmwit> darrint: What do you mean?
13:15:16 <Cale> If your prediction isn't an interval, it is going to be wrong.
13:15:28 <mauke> darrint: no
13:15:44 <darrint> dmwit: I can't load a file because I have compilation errors near the bottom. I'd like to compile the parts that work and use :t to figure some stuff out.
13:15:45 <FunctorSalad> I would have much preferred a more mathetmatical approach in school, but I have no idea whether it would be viable for everyone
13:15:47 <Cale> (well, an interval or perhaps better yet a probability distribution)
13:15:49 <monochrom> [3,3]
13:15:49 <FunctorSalad> *mathematical
13:15:53 <gwern> dolio: eh. cabalizing it is work enough! maybe once I get the minus-autotools patch cleaned up and sent
13:16:05 <gwern> darrint: like a comment?
13:16:15 <gwern> darrint: like -- foo; or {- foo \n bar -}?
13:16:20 <dmwit> darrint: Ah, use {- and -} to mark out the spots you don't want compiled.  =)
13:16:28 <darrint> That will work. Thanks all.
13:16:44 <Cale> FunctorSalad: From my experience helping students out on IRC, even the most hopeless-seeming students seem to benefit immensely from a little formalism.
13:16:49 <FunctorSalad> Cale: probabilities are tricky regarding prediction/falsifiability though ;)
13:16:58 <Philippa_> Cale: sometimes especially so
13:16:58 <Cale> FunctorSalad: that's true.
13:17:21 <Philippa_> sometimes formalism offers something to grasp on to and actually /know/ things
13:17:31 <Cale> FunctorSalad: I think one of the main problems with how mathematics is taught in highschools today is that there are many spots where not only is the logic left out, there's no way to put it back in!
13:17:54 <Cale> Things are presented in an order in which it would be impossible to insert proofs of things.
13:18:07 <twanvl> Cale: It seems many people seem to be scared of formal mathematics
13:18:18 <Cale> For example, treating the logarithm prior to any calculus is really egregiously bad.
13:18:42 <Cale> Same goes for trig.
13:19:07 <Cale> You can't define the sine function, or even what the heck you mean by an angle, without some kind of limit.
13:19:12 <FunctorSalad> twanvl: sure - but I wonder whether this is because it is really that hard, or whether we would just have to teach it from first grade
13:19:19 <FunctorSalad> I have no idea, really
13:19:29 <sarehu> that's not a problem with the teaching of mathematics, because they're not teaching mathematics, and that's ok
13:19:30 <mauke> sure I can
13:19:35 <dmwit> You can define sine without limits.
13:19:48 <Cale> sarehu: They should be more honest then, and call the courses "calculator ownership".
13:19:51 <twanvl> trig can be explained with geometry
13:20:00 <dmwit> Define the cosine as the dot product over the product of lengths, as usual.
13:20:35 <sarehu> Cale: that would be a nice name but they don't even teach that properly
13:20:38 <Cale> dmwit: The cosine of what? :)
13:20:50 <mauke> sin(x) is the y-coordinate of the intersection of the unit circle with a straight line going through the origin at angle x
13:21:05 <dmwit> Cale: Well, you gotta have two vectors, or one + a reference vector. =)
13:21:10 <dmwit> Cale: But no limits necessary.
13:21:10 <FunctorSalad> hmm, you can define angles as arc length
13:21:15 <Cale> mauke: The trouble I have is with "angle x"
13:21:18 <Cale> FunctorSalad: right
13:21:24 <Cale> FunctorSalad: Which involves an integral.
13:21:25 <FunctorSalad> (and formalizing length might be a bit overkill for school)
13:21:48 <Cale> They should stick to things which they can put on a logical foundation.
13:21:54 <mauke> well, you start with a straight line and call that 180°
13:22:01 <Cale> If it's too hard to logically formulate something, then don't teach it.
13:22:28 <thorkilnaur> Cale, Here is the definition of (cos(t),sin(t)) that I learned in school:
13:22:51 <sarehu> That's just stupid.  Most kids won't learn anything if you give them useless theorymongering
13:23:07 <resiak> it doesn't *matter* that you can't rigorously define what an angle is to a kid who isn't going to study maths beyond school
13:23:10 <Cale> sarehu: Sure they will. They'll learn how to apply logic to various situations.
13:23:17 <sarehu> Instead of learning how to add they end up thinking that surrounding something by a fence makes it a "set"
13:23:34 <thorkilnaur> Cale, Take a string of length t and attach it at the point (1,0) in an ordinary 2-dimensional coordinate system.
13:23:40 <Cale> The one useful thing which nonmathematicians could *actually* use from a course in mathematics is logic.
13:23:44 <FunctorSalad> I think part of the issue is how you do the "interface" between intuitive geometry and symbolic math
13:23:49 <dobblego> children use logic all the time; better than many adults
13:23:59 <Cale> And this, in my opinion, is where the present formulation is weakest.
13:24:19 <desegnis> Cale: I think in the same way as you first learn that 1 + 1 = 2, and only then what is a number, in exactly the same way you may first learn about the sine of an angle, and only then how »angle x« is defined
13:24:30 <thorkilnaur> Cale, Then wind the string around the unit circle with center (0,0) until the string ends.
13:24:56 <thorkilnaur> Cale, Counterclockwise if t is positive, clockwise if t is negative.
13:25:01 <desegnis> Cale, maybe my analogy was flawed...
13:25:08 <Cale> thorkilnaur: right.
13:25:14 <thorkilnaur> Cale, Where then string ends, you have (cos(t),sin(t))
13:25:52 <Cale> thorkilnaur: This is the same as the usual definition as the point at which the ray at angle t from the positive real axis meets the unit circle.
13:26:06 <Cale> Er, positive x axis :)
13:26:20 <Cale> (too much complex analysis lately :)
13:26:34 <thorkilnaur> Cale, It avoids any mentioning of angles, which is what I think is nice about it
13:27:07 <Cale> thorkilnaur: But try to formalise what you mean by that string, and you'll effectively be defining the angle.
13:27:17 <thorkilnaur> Cale, (and t is in radians, of course)
13:27:30 <Cale> Of course :)
13:28:42 <thorkilnaur> Cale, I don't need formalization, just a practical definition that makes sense, and I believe that the string-definition makes sense in every-day understanding
13:28:45 <FunctorSalad> or (as I think mauke was getting at), you could first define angles for regular 2^n-gons and extend by continuity :)
13:28:53 <Cale> I would actually honestly be happy with a mathematics curriculum which taught nothing but graph theory, if it involved plenty of logic and proof. Most importantly the students should be proving small theorems.
13:29:25 <Cale> It's in that process that you learn to think logically, and get implication arrows the right way around and such.
13:29:50 <Cale> and that's a far more useful skill than knowing how to solve triangles with the cosine, say.
13:30:19 <twanvl> Indeed, schools should be teaching more logic and less trigonometry
13:31:13 <Cale> If you can think logically, you can pick all the rest of that stuff up as you need it, and you won't even need the baby version of it.
13:32:19 <twanvl> Cale: don't forget that while you may find this easy, many students find math to be one of the hardest topics.
13:32:28 <sarehu> but first, you'd have to get the _teachers_ thinking logically
13:32:32 <sarehu> which I can assure you is impossible
13:32:44 <Cale> twanvl: My conjecture as to why they find it hard is that all the proofs have been left out.
13:32:58 <mrd> math teaching is pitiful
13:33:15 <Cale> I don't even blame the teachers so much as the curriculum.
13:33:20 <mrd> sure
13:33:47 <mrd> i remember spending an entire year, almost, learning how to change a number from representation in one base to another
13:33:52 <mrd> what for, I don't know
13:33:53 <Cale> I know some very bright teachers who really wish that they could teach properly, but the system forces them to teach in this ridiculous fashion which could not hope to produce interested students.
13:34:39 <dobblego> Cale, I used to tell my students to see me after class if they wish to learn; I'd get 3 or 4
13:34:57 <FunctorSalad> heh
13:35:01 <FunctorSalad> that's not so bad
13:35:23 <FunctorSalad> you taught them "real" math then?
13:35:32 <mrd> another useful thing for people to learn: statistics
13:35:41 <dobblego> it wasn't mathematics, but I didn't teach them the curriculum :)
13:35:50 <twanvl> Cale: more importantly, the discovery is left out. When I was studying calculus I was first calculating derivatives by taking limits, then after a while I discovered that dx^k/dx = kx^(k-1). This means that I will never forget this rule, and understand why it is the case. On the other hand, the textbook just gives that rule with no explanation.
13:35:53 <Cale> dobblego: good for you, seriously, that's something I wish more of these teachers would really do.
13:36:12 <Cale> twanvl: I agree.
13:36:29 <Cale> twanvl: I learned calculus on my own as well, and had that very same experience.
13:37:24 <resiak> That's interesting: when I was taught calculus in school, we were set a bunch of examples to calculate manually which were designed to lead us towards all the standard rules.
13:37:33 <Cale> It's in actually proving things and playing with mathematics that the real fun is found. They strip all that out in the hopes that it will make things easier, but it doesn't, it just makes it more confusing.
13:37:46 <resiak> (I guess I had a good calculus teacher :-))
13:37:56 <Cale> resiak: That's a reasonable approach.
13:39:39 <Cale> When I got around to doing Calculus at university, that was even more fun, since I took the advanced section course, and the assignments were all proofs. We spent hours on many of the problems, but they were actually fun to work on, and it immediately made me wonder why the approach was so broken in highschool.
13:39:46 <FunctorSalad> I remember figuring that one out too. But IIRC somewhat clumsily with binomial coefficients, rather than induction and product rule
13:40:35 <mrd> nobody seems to teach good proof techniques, though, which makes those classes confusing for those who haven't figured it out yet
13:40:47 <byorgey> mrd: yes, this is a real problem.
13:41:36 <Cale> mrd: Well, the proof techniques were part of this course. You picked them up as the lecturer did proofs, but we also explicitly proved things like the principle of mathematical induction (from the well ordering property of the naturals)
13:42:17 <Cale> Well, I can't remember whether it was the Calculus course, or Classical algebra, but the two ran in parallel, and gave you all the tools you'd need.
13:42:44 <Cale> Sure, it took a while before we were comfortable applying them, but that's part of the fun too.
13:43:44 <mrd> watching someone do proofs doesn't really help me that much
13:43:54 <mrd> i mean, now it does, but i already know what to do
13:44:23 <Cale> Well, we explicitly defined what a proof was.
13:44:36 <Cale> (even if it wasn't perfectly formalised)
13:45:16 <Cale> There's a lot to the technique of *finding* proofs which just can't reasonably be expressed, I think.
13:45:25 <Cale> You just have to try it yourself and find out.
13:45:55 <dons> gwern: do you have concrete plans to cabalised and hackage the back catalog of haskell tools?
13:46:01 <Cale> But the actual rules can be expressed, for sure.
13:46:05 <dons> we have the complete release announcements from previous years on haskell.org
13:46:12 <oerjan> @go how-to-prove-it
13:46:17 <mrd> another part is the uncertainty: "is what I did reasonable?"
13:46:33 <mrd> when you aren't working completely formally, it's easy to gloss over important parts
13:46:44 <oerjan> @bot
13:46:45 <Cale> mrd: Sure, and that's something the TA's are generally expected to help with :)
13:47:02 <mrd> yea yea, you're talking about people who go to office hours =)
13:47:13 <desp> Can someone help me with a shuffle algorithm? I'm reading Oleg's http://okmij.org/ftp/Haskell/perfect-shuffle.txt
13:47:19 <Cale> mrd: Or else get their assignments back with comments :)
13:47:26 <mrd> and read them? :P
13:47:27 <desp> The "Naive -- lucid but inefficient -- implementation"
13:47:29 <Cale> mrd: hehe
13:47:41 <Cale> mrd: Get a bad enough mark and you'll start reading them :)
13:48:13 <monochrom> A shortcoming of that is you have to wait two weeks.
13:48:17 <desp> Oh wait. The random numbers are supposed to be in range [0..n-i]. All is clear now.
13:48:23 <mrd> as an undergrad I got to the point where I sometimes didn't bother to turn in homework much less pick them up
13:48:31 <mrd> but that would be my own problem
13:48:53 <Cale> monochrom: That's true.
13:49:01 <Cale> You can also talk with your friends about it.
13:49:09 <mrd> except when verboten
13:49:20 <Cale> There was essentially no way to do these assignments without working in groups.
13:49:21 <mrd> except everyone did anyway
13:49:40 <monochrom> Talking with peers is a double-edged sword. I don't mean the plagiarism part.
13:50:00 <mrd> mechanical proof assistants really helped me with my proof techniques though.  nothing like the cold unforgiving eye of the computer to keep you in line.
13:50:09 <Cale> heh
13:50:25 <monochrom> A benefit of talking with peers is it mimics professional math life - it's necessary and sufficient to get peers to agree.
13:50:35 <Cale> One thing about mechanical proof assistants is that they're like the null-audience.
13:50:54 <Cale> In mathematical writing, like in all writing, considering the audience is important.
13:51:19 <monochrom> A shortcoming of talking with peers is, since the peers are just as ignorant, it could degenerate into proof by repeated assertion.
13:51:46 <Spark> or an editor war
13:51:51 <Cale> monochrom: of course. I usually found that the chances of someone saying "hey, that actually doesn't follow" went up overall though.
13:52:14 <monochrom> Afterall, most of you despise most religious groups precisely because of the persuasion-by-talk-to-peer aspect and no external verification.
13:52:17 <Cale> Spark: We were working on our own copies separately, and only sharing ideas.
13:52:34 <Spark> an ideas war then :)
13:52:39 <Cale> monochrom: Sure, but there's a constant source of external verification :)
13:52:51 <mrd> hah, even that external verification can be wrong
13:52:52 <Cale> monochrom: It's just delayed by a little bit.
13:53:05 <Spark> you need a range of things
13:53:10 <mrd> one time i turned in a homework so insanely detailed that the TA just said "ok" and didn't notice the mistake I had made
13:53:13 <monochrom> two weeks is not a little bit. there are not many two weeks in a school term.
13:53:21 <Cale> mrd: anyway, back to what I was saying... you also don't want to bore the reader with details which they can deal with.
13:53:24 <Spark> a proof-of-concept implementation is convincing, proofs are convincing, understanding the fundamental ideas helps too
13:53:51 <Spark> i had to review a paper recently that was wall-to-wall theory
13:53:58 <Spark> i got 2/3 of the way through it and got lost
13:54:02 <Cale> mrd: A proof should consist of just the details which the audience needs to reconstruct the formal proof in their heads, and not all the details which they can fill in automatically, since those are really boring.
13:54:06 <mrd> Cale: of course, then you wonder "how much is enough?" which is rather annoying
13:54:07 <monochrom> Whereas something like two days is much better.
13:54:28 <Cale> mrd: Sure, it's annoying at first, but it's something you should really learn to work with as well.
13:54:43 <monochrom> So, I also believe in the idea of a "proof IDE".
13:54:50 <mrd> i just copied the style of the sample homework solutions after the first one
13:54:55 <Cale> mrd: It's especially annoying when you don't know how picky your TA is.
13:55:02 <Cale> mrd: and you're being graded on it :)
13:55:06 <mrd> right
13:55:18 <Cale> But it's still something which you should learn, and so I think it's still reasonable.
13:56:04 <Cale> Usually the first assignment in each course let people generally get an idea for where the level of expectation was.
13:56:14 <Cale> and the proofs in the lectures as well
13:56:16 <mrd> like with type theory proofs, what examples did I have? Pierce .. which was way too informal.  papers .. which have many different formalisms and most of them omit proofs anyhow.
13:56:37 <Cale> In most of my courses, if you followed the same level of detail that the prof used, you'd generally get a good mark.
13:56:52 <Cale> Proof: Induction.
13:56:56 <Cale> QED.
13:56:59 <mrd> haha
13:57:23 <olsner> Proof: Trivial.
13:57:24 <mrd> sometimes you'd get lucky and it's "proof by induction on the derivation of the type"
13:57:25 <mauke> Proof: Yes, please.
13:58:04 <monochrom> Proof: SAT solver.
13:58:44 <mrd> i ended up writing most of them in twelf and converting them to "human" form afterwards.  so much nicer when you know the proof is verified.
13:59:27 <Cale> mrd: That was like, most of the proofs in my model theory course. We actually skipped a lot of those, stopping at various points to see what one actually looks like, but many of them really were tedious and obvious. Of course, there were some interesting ones too.
13:59:36 <gwern> dons: concrete plans, not particularly. I'm going down a list I made of broken Hackage stuff, and occasionally making a detour for things like DrIFT and Haskore when they catch my interest
13:59:56 <gwern> dons: if you want to forward the links though, I'll definitely add them to the TODO
14:01:07 <Cale> mrd: Usually it would be "Well, here's how it works in the base case on the atoms. The rest is by induction on the structure of formulas."
14:01:12 <darrint> Is there an example online of how to implement a timeout with stm?
14:01:28 <Cale> darrint: I have one using MVars which could be adapter.
14:01:32 <Cale> adapted*
14:02:06 <Cale> darrint: A useful generalisation is to write the function which takes a list of computations and races them against each other.
14:02:28 <Cale> darrint: Then the timeout becomes a special case with a list of length 2.
14:02:40 <mrd> always nice when that works out
14:02:41 <darrint> Cale: ok. Maybe I can pull that off....
14:02:58 <darrint> my little haskell muscles are getting a little stronger. :-)
14:03:03 <Cale> I think you'll need to have it be in IO and not STM directly though, since threadDelay is in IO.
14:03:25 <darrint> That would be fine. My target for this is in io.
14:03:50 <darrint> Cale: So I fork two computations to start?
14:04:32 <Cale> darrint: forkIO all the computations in the list, modified slightly to put their results in a TMVar (use mapM to do this)
14:04:40 <Cale> (or forM)
14:05:03 <darrint> Cale: What functions will help me clean up the mess?
14:05:38 <Cale> Well, the result of that forM will be a list of ThreadIds
14:06:06 <Cale> You can read off the result from the TMVar and then forM threads killThread
14:06:35 <darrint> Cale: Got it. But why a TMVar and not a plain MVar?
14:06:44 <Cale> a plain MVar should actually be fine.
14:06:44 <Taejo> can a GHC-compiled program use multiple processors if one doesn't pass the appropriate RTS options?
14:06:57 <Cale> That's in fact how I did it.
14:06:59 <darrint> Cale: much thanks.
14:07:15 <Cale> Taejo: I don't think so...
14:07:33 <Cale> Taejo: You can bake-in the RTS options though.
14:07:37 <monochrom> You are not supposed to do a lot of things or hang yourself for a long time inside STM.
14:07:46 <Taejo> Cale: how do you bake in RTS options?
14:08:25 <Cale> One sec, I'll find the documentation
14:08:46 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
14:09:02 <Taejo> thanks... we need to stop our Haskell competitors getting an unfair advantage by stealing the second core
14:09:23 <Cale> You just create a simple C source file with a string containing the options and include that .c file on the commandline to ghc.
14:09:39 <Taejo> ah, ok... you can't do it if you're only using Haskell (we accept a single file of source)
14:09:58 <monochrom> could use a shell script to execute
14:10:04 <Cale> Not as far as I know.
14:10:30 <gwern> lovely. a number of Haskell packages on Gentoo fail to install when 'doc' (Haddock) is on.
14:10:43 <Taejo> Cale: I'm not so worried about somebody going parallel... the problem is that it affects the runtime of the program assigned to the other core
14:11:52 <waern> what's sort of the mapM equivalent in SYB?
14:14:19 <dolio> @type gmapM
14:14:46 <Cale> gmapM :: Monad m => (forall a . Data a => a -> m a) -> a -> m a
14:15:04 <waern> thanks, but I want a -> m b
14:15:31 <Cale> I wonder why it's not a -> m b actually.
14:16:38 <oerjan> what about just a -> b ?
14:18:23 <waern> gwern: I think they're working on that, it's probably because of changes in haddock 2
14:19:36 <oerjan> er...
14:19:48 <oerjan> a -> m b would be more a fold, wouldn't it
14:19:54 <darrint> Cale: This look right for a timeout fn? http://hpaste.org/5589
14:20:14 <twanvl> A generic map with a function (a -> b) doesn't make sense, it would mean that in a data type data X = X Int, the integer could be replaced with something else
14:20:42 <gwern> waern: it's frustrating whetever it is
14:20:55 <oerjan> twanvl: that applies to a -> m b as well doesn't it?
14:21:11 <Cale> darrint: nearly, except that the computing thread will continue running after the timeout.
14:21:13 <twanvl> oerjan: yes
14:21:25 <darrint> Cale: Oh yeah. Forgot that. Thx.
14:28:27 <waern> I want something like Monad m => (forall a . Data a => a b -> m (a c)) -> a b -> m (a c)
14:29:27 <Taejo> I'm cabalizing Hal Daume's HWordNet package, and I'm not sure what the name should be... currently, the package is called HWordNet, but the module is NLP.WordNet.WordNet. Any suggestions/preferences?
14:30:35 <dons> is it a library?
14:31:06 <dons> the current proposed hierarchical layout is at : http://haskell.org/haskellwiki/Hierarchical_module_names
14:31:11 <dons> so perhaps see where it fits under there
14:35:04 <gwern> Taejo: what's wrong with WordNet? (as a bare name, not position on the hierarchy)
14:35:14 <RayNbow> @src Control.Monad.guard
14:35:39 <gwern> I would consider putting it under Text. fwiw
14:35:58 <Taejo> gwern: well, I'm mostly asking for opinions on WordNet vs HWordNet
14:36:34 <shag> @pl(\xs ys -> (head ys):xs)
14:36:40 <shag> @pl (\xs ys -> (head ys):xs)
14:36:42 <Taejo> I prefer WordNet (what other language are Haskell WordNet bindings gonna be in) but perhaps it's handy to distinguish it?
14:37:01 <waern> this should be what I want... a generic map function: (Monad m, Data a) => (b -> m c) -> a b -> m (a c)
14:37:53 <oerjan> guard True      =  return ()
14:37:53 <oerjan> guard False     =  mzero
14:38:53 <RayNbow> oerjan: ah thx, but I already found the definition :)
14:39:09 <monochrom> Web.Service.WordNet
14:39:21 <monochrom> apparently "web service" is rather popular :)
14:40:00 <monochrom> 1990-2000 slogan: Everything is an object!  2000-3000 slogan: Everything is a web service!
14:40:09 <oerjan> shag: flip ((:).head)
14:40:11 <gwern> Taejo: oh, definitely WordNet over HWordNet - i mean, if you are looking at haskell module names, you already know it's in Haskell :)
14:40:13 <dolio> @type Data.Traversable.mapM
14:40:26 <dolio> Oh, right.
14:40:41 <shag> oerjan: thanks. where is this lambdabot when one needs her?
14:40:50 <kpreid> the thing to avoid is those "web services" that you can't use without being aware that they are Web Services
14:40:58 <kpreid> and are thus not truly of the web
14:41:12 <oerjan> shag: sick leave, as is her replacement
14:41:31 <monochrom> Whoever decided to use the word "object" in category theory way before Simula was a genius. :)
14:41:52 <dolio> waern: That's exactly the type of Data.Traversable.mapM, except with 'Data a' instead of 'Traversable a'.
14:41:59 <Taejo> gwern: Text.NLP.WordNet or Text.WordNet, do you think?
14:42:01 <monochrom> lambdabot pregnancy leave? :)
14:42:12 <monochrom> @botsnack
14:42:19 <monochrom> eh, where is psibot?
14:42:22 <litb> damn, why am i getting an infinite loop and stack overflow here?
14:42:56 <monochrom> Because you misprogrammed.
14:42:59 <waern> dolio: I noticed that, so can I make Traversable instances via SYB somehow?
14:43:46 <dolio> waern: I don't know. Possibly. I thought I heard JohnMeacham say that DrIFT can derive Traversable earlier.
14:43:52 <litb> http://hpaste.org/5590
14:43:56 <litb> please have a look there :)
14:44:05 <waern> hm, maybe Traversable is not what I want anyway.. I want a "deep" traversal
14:44:12 <monochrom> That is long.
14:44:14 <litb> if i change the very last line from "fneg = fmul $ skalarFunktion (-1)
14:44:20 <litb> darn \n
14:44:45 <litb> to "fneg = ((-1) *)" it loops infinitely
14:45:15 <monochrom> Haha I like your "not cut" as a dual to "no paste"
14:45:34 <litb> :)
14:46:06 <litb> i wondered whether i reache the 50k limit, but i haven't :)
14:46:39 <dolio> waern: It might be difficult to work out the types for a generic traversal. 'Change all things of type a to things of type b' doesn't make sense for everything.
14:46:41 <litb> err 5k indeed not 50k . anyway maybe someone can easy spot the error i made
14:46:57 <oerjan> litb: -1 is negate 1, and negate uses - if not defined explicitly
14:47:08 <litb> if i do "(fneg fid) $$ 10" it loops
14:47:47 <litb> ah you mean it does "0-x" then?
14:47:54 <oerjan> something like that
14:47:59 <waern> dolio: it would only change things of type a in types parameterised by a
14:48:28 <litb> oh i see, in a-b i implement that using fneg so i think that is why it loops forever
14:48:35 <oerjan> yep, just that
14:48:52 <monochrom> Ah!
14:48:54 <litb> is my code horrible?
14:49:02 <monochrom> No, it's beautiful.
14:49:06 <BMeph> litb: I don't think " fromRational a = skalarFunktion $ fromRational a" is what you really want - although, that is what you typed. ;)
14:49:31 <litb> yes i can eta reduct it
14:50:19 <litb> or have you spot another error?
14:50:21 <waern> dolio: do you have an example for which it wouldn't work?
14:51:27 <dolio> waern: I'm just not sure how you'd specify that you're only changing things that correspond to parameters. Something with Typeable1, I guess.
14:51:41 <waern> dolio, yes, that's what I have
14:52:24 <Spark> does \\ mean anything in haskell, as a binary operator between 2 lists
14:52:43 <Spark> > "abcde" \\ "ab"
14:52:44 <sarehu> > [1,2,3,2,4,4,3] \\ [2,3]
14:53:13 <RayNbow> Prelude> import List
14:53:13 <dobblego> ?type (\\)
14:53:13 <RayNbow> Prelude List> "aaa" \\ "a"
14:53:13 <RayNbow> "aa"
14:53:14 <Spark> i tried it in hugs
14:53:22 <Spark> ah right
14:53:37 <RayNbow> in Hugs it's :m List or something
14:53:47 <gwern> Taejo: is there much in Text as it is? Text.NLP.WordNet might be a bit long
14:53:59 <RayNbow> (well, it's also :m List in ghci, but I prefer typing import :p)
14:54:03 <gwern> on the other hand, Lolite would fit well in as Text.NLP.Lolita...
14:54:21 <monochrom> Text.NLP.WordNet is long?
14:54:35 <gwern> monochrom: sure, that's like 4 extra characters
14:54:44 <monochrom> You surely haven't seen Text.ParserCombinators.Parsec.Prim.ByteString.Lazy
14:54:44 <litb> BMeph: hm, i don't see what i want instead :/
14:54:47 <Spark> Prelude> import List
14:54:47 <Spark> <interactive>:1:0: parse error on input `import'
14:54:54 <Taejo> gwern: yeah... Text seems like a bit of a jumble... everything from NLP and dictionaries to regexen and RSS
14:55:26 <monochrom> True, NLP.WordNet may be better.
14:55:42 <gwern> Taejo: Text's brief is quite broad :) as perlers like to say, almost everything is text processing
14:55:51 <monochrom> Not because it's short, but because it's outside Text.
14:56:07 <Spark> so if the strings contain no duplicates, \\ behaves like set difference
14:56:24 <waern> dolio: maybe SYB is too untyped for such an operation to be meaningful
14:56:33 <Spark> otherwise it only takes the first n of each element in the second operand
14:56:35 <litb> monochrom: hehe
14:56:44 * litb gives monochrom a cookie
14:56:59 <monochrom> Indeed, even Text.XML.etc is not right. The point of XML is markup, not text.  Should be ML.XML.etc, ML.HTML.etc, etc.
14:57:24 <twanvl> Language.XML?
14:57:43 <Taejo> Language seems to refer to haskell-the-language
14:57:55 <monochrom> Not as good as my suggestion IMO, but I can live with that.
14:57:58 <Taejo> when I first saw it, I thought that's where NLP belonged
14:58:16 <monochrom> Language.English.WordNet? :)
14:58:26 <twanvl> Or something like Encoding.XML
14:58:28 <Taejo> monochrom: I can live with that
15:00:31 <oerjan> Taejo: it's Language.Haskell.*, but i don't know if anyone has defined any other Language.* modules
15:00:48 <Taejo> so Language.English.* might work?
15:01:06 <litb> monochrom: i'm not sure it's any good that the type of a derivation here is (Maybe Funktion) . that complicated many things as i have to lift so much
15:02:04 <gwern> @where ports
15:02:35 <oerjan> Taejo: that wiki page mentions HaskellCore, C, Python as possibilities
15:03:20 <Taejo> so Language.* is really Code.* or Programming.*
15:03:24 <blbrown> what are some algorithms for doing fuzzy comparison of strings?  or maybe not even fuzzy, but just to see how close two strings are.  Close, NOT very close, etc
15:04:06 <gwern> blbrown: like Hamming/edit distance?
15:07:14 <Taejo> ok, next question... how to find the WordNet database at configure-time
15:07:38 <Taejo> is there a slightly less basic Cabal tutorial than "how to make cabal package"?
15:08:09 <dons> no, but there's lots of example cabal files on hackage.haskell.org
15:08:18 <dons> Taejo: i would put it under Language.NLP or something
15:09:33 <monochrom> The hierarchy needs a semantics.
15:09:41 <Taejo> dons: thanks
15:09:45 <Taejo> monochrom: yep
15:11:28 <kuribas> A bit off topic, but is it better to calculate the roots of a quadratic equation numerically, or using the normal formula for the roots (and floating point sqrt)?
15:11:59 <blbrown> gwern, is that what I need
15:13:03 <Taejo> kuribas: if you're using the *corrected* quadratic formula, I don't know... if you're using the naive one, Newton's method or something is better
15:13:47 <gwern> blbrown: look'em up on WP, but it sounds similar to what you need
15:14:50 <nominolo> what is NLP?
15:14:58 <gwern> natural languae processing
15:14:59 <Taejo> Natural-Language Procesisng
15:15:05 <kuribas> Taejo: I don't know the corrected quadratic formula.  Do you have any links?
15:15:13 <gwern> or neuro-leinguistic programming, depending on context
15:15:24 <Taejo> kuribas: looking for one, but look up Kahan
15:15:30 <nominolo> i see
15:15:33 <Taejo> he's your man for numerical methods
15:15:48 <twanvl> Language.Natural.English might be clearer
15:15:59 <nominolo> yeah.  ILP = inductive logic programming, integer linear programming, or instruction-level parallelism
15:16:09 <adu> it built!
15:16:17 <kuribas> Taejo: Right, I will.
15:16:55 <monochrom> TLA = temporal logic of actions.  (Yes, Lamport was clearly going for a pun.)
15:17:00 <Taejo> kuribas: http://en.wikipedia.org/wiki/Quadratic_formula - "floating point implementation" section has the formula
15:22:32 <litb> BMeph: i think "fromInteger = skalarFunktion . fromInteger" looks better
15:22:48 <litb> and s/fromInteger/fromRational/
15:25:50 <litb> i wonder whether it's difficult do make something like this: "(3*x + 4*y) $$ 1 2" e.g make it that it automatically has one more parameter when another character is used
15:25:59 <Mr_Awesome> is it possible to write a tail-recursive version of map in haskell?
15:26:23 <dobblego> Mr_Awesome, yes
15:26:31 <twanvl> you don't want map to be tail recursive
15:26:47 <dobblego> Mr_Awesome, as an exercise, not how you should write it :)
15:27:01 <Mr_Awesome> that would interfere with laziness, right?
15:27:29 <LoganCapaldo> I bet you could do it litb, w/ some clever Num instances, and you'd have to predeclare the "variable" variables
15:28:50 <Mr_Awesome> but does that mean that map always runs with O(n) space?
15:29:12 <twanvl> no, map can run in O(1) space, depending on how the result is used
15:29:28 <LoganCapaldo> ahhh laziness
15:29:37 <LoganCapaldo> confusing programmers everywhere
15:29:59 <Mr_Awesome> twanvl: but if you needed to look at every value in the list, it would be O(n)
15:30:38 <wagle_home> > map (+1) [1..]
15:30:58 * wagle_home watches "lambdabot" never return...  8)
15:31:02 <dcoutts_> Mr_Awesome: only if you need to look at every value simultaneously, where as usually you look at them one by one and do not need them again after looking at each one the first time.
15:31:04 <twanvl> Mr_Awesome: for example, if you write "sum (map f very_long_list)" then the intermediate list never has to be in memory all at once
15:31:06 <dobblego> Mr_Awesome, you can look at every value in the list and run in O(1) space
15:31:13 <sarehu> wait, where's lambdabot? :(
15:31:31 <sarehu> wait... oh ghaaa
15:31:53 <Mr_Awesome> ah, understood
15:31:54 <wagle_home> i heard it was off solving the halting problem..  someone told it "yes!  haskell can do that!"
15:31:54 <LoganCapaldo> lambdabot is tired
15:32:04 <LoganCapaldo> she's taking a nap
15:32:16 * gwern must confess, 'twas I who asked that ?faq
15:33:10 <litb> lambdabot is a she?
15:33:18 <faxathisia> yes
15:33:28 <gwern> lambdabot is too subservient to be male
15:33:49 <Mr_Awesome> twanvl: so that example would run in constant space?
15:34:06 <litb> well, is there any possibility i cann add application capability to my datatype?
15:34:11 <Cin> gwern: controversial
15:34:19 <litb> :p
15:34:30 <gwern> Cin: well c'mon; that was an obvious troll
15:34:49 <sarehu> ?faq Can Haskell _not_ do that?
15:34:54 <twanvl> Mr_Awesome: it should
15:35:00 <Cin> gwern: didn't my bold indicate i knew that? :P
15:35:02 <monochrom> lambdabot is having a baby
15:35:04 <gwern> or shall we say lambdabot was too passive and recipient to be anything but a women?
15:35:11 <gwern> Cin: I saw no bolding
15:35:20 <Cin> gwern: excellent irc client
15:35:56 <gwern> Cin: the scripts do other things, like I see 'SHOUTING' as '<cap>shouting</cap>'
15:36:02 <gwern> makes life more pleasant
15:37:15 <mauke> Cin: #haskell is +c
15:37:59 <gwern> +c?
15:38:05 <Cin> NOCOLOR
15:38:23 <litb> o.O
15:38:29 <litb> who has color?
15:38:41 <gwern> '18:38 < Cin> <caps>Nocolor</caps>' <-- see?
15:38:49 <gwern> litb: scriptkiddy stuff like mIRC presumablky
15:39:05 <litb> hmm
15:39:50 <LoganCapaldo> gwern: you should change it to map toUpper "Nocolor"
15:41:40 <gwern> LoganCapaldo: bah. that's not self-delimiting! I'd get type errors from whatever followed teh captailized prhase
15:42:09 <mauke> <CAPS>
15:42:40 <Cin> mauke: hehe
15:43:19 <gwern> mauke: the perl script sends its regards and invites you to commit some onanism
15:43:19 <wagle_home> hmm (10 minutes ago): * lambdabot has quit (SendQ exceeded)
15:43:22 <dmwit> <<caps>caps</caps>> ?
15:43:30 <gwern> 18:43 < dmwit> <<caps>caps</caps>> ?
15:43:34 <dmwit> gwern: ahaaha
15:44:03 <Cin> wagle: was it your inifte-length list?
15:44:17 <mauke> <ca<caps>ps</caps>>ca</caps>ps
15:44:18 <Cin> er, infinite
15:44:38 <LoganCapaldo> fix <caps>?
15:44:55 <gwern> mauke: 18:44 < mauke> <ca<caps>ps</caps>>ca</caps>ps
15:44:59 <wagle_home> Cin: oooo..  maybe
15:45:09 <mauke> gwern: yes, that's what I wrote
15:45:23 <wagle_home> was a minute after that
15:45:51 <gwern> mauke: oh. I assumed you were doing something clever
15:45:54 <sarehu> HAH<B>HAHA ok </b>
15:45:59 <mauke> huhu
15:46:15 <mauke> there is a fine line between cleverness and stupidity
15:46:31 <wagle_home> fractal?
15:46:31 <sarehu> all lines are fine
15:46:33 <dmwit> gwern: Nope, only his first one was clever.  My and his next ones were just what we typed. =)
15:48:08 <dmwit> ?hoogle (a -> m a) -> Int -> m a
15:48:39 <sarehu> no bot
15:50:05 <hpaste>  mmorrow annotated "Short Circuit a filter" with "callCC w/ delimited continuations" at http://hpaste.org/5571#a1
15:50:45 <dmwit> > let expand c = [c, ' ', c] in foldr (=<<) "*" (replicate 3 expand)
15:50:51 <dmwit> Oh, no bot.
15:50:51 <dmwit> heh
15:51:08 <Saizan> @boy
15:51:09 <psibot> Maybe you meant: bf bug yow
15:51:12 <Saizan> @bot
15:51:12 <psibot> :)
15:51:25 <olsner> it's like the world stops when there's no bot in #haskell
15:52:00 * wagle_home breathes into paper bag
15:52:16 <dons> ?users
15:52:16 <psibot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 32707
15:52:19 <dons> huh
15:52:30 <dmwit> > let expand c = [c, ' ', c]; cantor n = foldr (=<<) "*" (replicate n expand) in cantor 3 -- just for fun
15:52:38 <psibot>  "* *   * *         * *   * *"
15:52:55 <dons> psibot: @part #haskell
15:52:58 <dons> ?users
15:53:08 <lambdabot> Maximum users seen in #haskell: 471, currently: 441 (93.6%), active: 1 (0.2%)
15:53:19 <wagle_home> @[botsnack..]
15:53:27 <lambdabot> Unknown command, try @list
15:55:37 <keseldude> > let f [] = []; f (x:xs) = x : ' ' : f xs in f "hi #haskell"
15:55:44 <lambdabot>  "h i   # h a s k e l l "
15:56:10 <keseldude> I couldn't think of an easier way...
15:56:16 <dmwit> :t intercalate
15:56:17 <lambdabot> Not in scope: `intercalate'
15:56:21 <dmwit> :t intersperse
15:56:22 <lambdabot> forall a. a -> [a] -> [a]
15:56:24 <LoganCapaldo> > intersperse ' ' "hi #haskell"
15:56:25 <lambdabot>  "h i   # h a s k e l l"
15:56:28 <dmwit> =)
15:56:39 <idnar> "intercalate" sounds like a function that translates your program to INTERCAL
15:56:50 <dmwit> Don't worry, it's not.
15:56:54 * dmwit shudders
15:57:37 <qwr> intercal translator would be an interesting project ;)
15:57:47 <LoganCapaldo> mmm lazy intercal
15:58:07 <keseldude> oh well there we go
15:58:30 <wagle_home> you know how random data tricks the eye into seeing clusters and other patterns?  same here..  intercalate completely turns your program into randomness, that tricks your eye into seeing a fairly sensible looking result
15:59:11 <keseldude> @src intersperse
15:59:12 <lambdabot> intersperse _   []     = []
15:59:12 <lambdabot> intersperse _   [x]    = [x]
15:59:12 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
15:59:23 <keseldude> hey that looks like what I wrote
15:59:33 <LoganCapaldo> yep
15:59:37 <resiak> modulo a second base case
15:59:49 <LoganCapaldo> but now you don't have to write it :)
15:59:55 <keseldude> yay
16:00:13 <LoganCapaldo> yours woulda done f "x" -> "x "
16:01:00 <hpaste>  mmorrow annotated "Short Circuit a filter" with "(no title)" at http://hpaste.org/5571#a2
16:01:07 <dcoutts_> the standard intersperse is too strict
16:01:29 <LoganCapaldo> how so?
16:02:26 <sarehu> > head (intersperse 3 (2:undefined))
16:02:27 <lambdabot>  Undefined
16:02:47 <wagle_home> @pl (\x -> foldl (\x y -> (x : ' ' : y)) [head x])
16:02:48 <lambdabot> foldl (const (ap (:) (' ' :))) . return . head
16:03:17 <wagle_home> > (foldl (const (ap (:) (' ' :))) . return . head) "hi #haskell"
16:03:19 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
16:03:57 <LoganCapaldo> > head (intersperse 3 (2:7:undefined))
16:03:58 <lambdabot>  2
16:04:11 <LoganCapaldo> I dunno if that's "too" strict
16:04:27 <wagle_home> > last [1,2,3]
16:04:28 <lambdabot>  3
16:04:42 <wagle_home> @pl (\x -> foldr (\x y -> (x : ' ' : y)) [last x])
16:04:43 <lambdabot> foldr (const (ap (:) (' ' :))) . return . last
16:04:52 <LoganCapaldo> dcoutts: Was that what you were referring to?
16:05:05 <mauke> intersperse _ [] = []; intersperse sep (x:xs) = x : case xs of [] -> []; _ -> sep : intersperse sep xs
16:05:05 <wagle_home> > (foldr (const (ap (:) (' ' :))) . return . last) "hi #haskell"
16:05:06 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
16:05:36 <dcoutts_> > intersperse 3 (2:7:undefined)
16:05:37 <lambdabot>  Undefined
16:05:47 <stick_figure> what's the trick to use the last value in ghci?
16:05:58 <dmwit> it
16:06:09 <stick_figure> thanks
16:06:13 <wagle_home> @pl it
16:06:13 <lambdabot> it
16:07:17 <dcoutts_> LoganCapaldo: intersperse 3 (2:7:undefined) should be 2:3:7:3:_|_
16:07:22 <wagle_home> :t foldr
16:07:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:07:35 <wagle_home> @pl (\x -> foldr (\x y -> (x : ' ' : y)) [last x] x)
16:07:36 <lambdabot> foldr (const (ap (:) (' ' :))) =<< return . last
16:07:41 <mauke> dcoutts_: I don't think the last 3 should be in there
16:07:45 <dobblego> > head $ intersperse 3 (2:7:undefined)
16:07:46 <lambdabot>  2
16:07:53 <mauke> 2:3:7:_|_
16:07:53 <dcoutts_> mauke: oh, hmm, perhaps so.
16:07:56 <dcoutts_> right
16:08:00 <dcoutts_> but we should get the 7
16:08:02 <wagle_home> > (foldr (const (ap (:) (' ' :))) =<< return . last) "hi #haskell"
16:08:03 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
16:08:13 <dcoutts_> and the standard impl does not give that
16:08:19 <dobblego> > (intersperse 3 (2:7:undefined)) !! 2
16:08:19 <lambdabot>  Undefined
16:08:44 <dmwit> dcoutts_: Well, the standard does, right?  It's just GHC that's wrong.
16:09:04 <mauke> > let intersperse _ [] = []; intersperse sep (x:xs) = x : case xs of [] -> []; _ -> sep : intersperse sep xs in (intersperse 3 (2:7:undefined)) !! 2
16:09:12 <lambdabot>  7
16:09:15 <dcoutts_> dmwit: no, the H98 spec's version of intersperse is too strict
16:09:25 <mauke> > let intersperse _ [] = []; intersperse sep (x:xs) = x : case xs of [] -> []; _ -> sep : intersperse sep xs in (intersperse 3 (2:7:[]))
16:09:26 <lambdabot>  [2,3,7]
16:09:40 <dmwit> ?where Prelude
16:09:41 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
16:10:00 <hpaste>  morrow annotated "Short Circuit a filter" with "(no title)" at http://hpaste.org/5571#a3
16:10:04 <dmwit> It's not in the spec. =P
16:10:13 <dcoutts_> one can check this using StrictCheck in the Streams impl of the List lib
16:10:42 <dcoutts_> dmwit: it's in the List module which is covered by the H98 spec
16:10:50 <dmwit> ok
16:11:18 <dmwit> :t showAtBase
16:11:19 <lambdabot> Not in scope: `showAtBase'
16:11:40 <mauke> :t showIntAtBase
16:11:41 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:11:50 <dmwit> Ah, thanks.
16:12:02 <mauke> :t intToDigit
16:12:03 <lambdabot> Int -> Char
16:12:05 <LoganCapaldo> http://www.haskell.org/onlinereport/list.html
16:12:07 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
16:12:27 <wagle_home> > "123" ! 2
16:12:28 <lambdabot>  Couldn't match expected type `Array i e'
16:12:35 <wagle_home> > "123" !! 2
16:12:36 <lambdabot>  '3'
16:12:42 <LoganCapaldo> unzip7? sheesh
16:14:22 <wildduck> is there any good tutorial for serverprogramming in haskell?
16:14:48 <Taejo> I want the "configure" of my WordNet installer to find where the WordNet database is installed. Is there a good way to do a global file search? Shelling to locate or find would be OK if Windows came with them.
16:14:52 <wildduck> i would like to write a little httpserver
16:16:13 <wagle_home> > showIntAtBase 13 ("0123456789abcd" !!) (6 * 9) ""
16:16:14 <lambdabot>  "42"
16:16:30 <dons> wildduck: cool. shouldn't be too hard
16:16:42 <dons> wildduck: grab the network package, maybe the HTTP package
16:16:50 <dons> wildduck: check the network category on hackage.haskell.org
16:17:04 <mauke> > showIntAtBase 13 intToDigit (6 * 9) ""
16:17:06 <lambdabot>  "42"
16:17:50 <wagle_home> > showIntAtBase 13 intToDigit (13) ""
16:17:51 <lambdabot>  "10"
16:17:59 <wagle_home> > showIntAtBase 13 intToDigit (12) ""
16:18:00 <lambdabot>  "c"
16:18:10 <wagle_home> hmm
16:18:26 <wildduck> thx
16:21:49 <wagle_home> > intToDigit 23243
16:21:50 <lambdabot>  Exception: Char.intToDigit: not a digit 23243
16:22:19 <OceanSpray> are first-class patterns possible?
16:22:33 <wagle_home> Template Haskell?
16:22:49 <OceanSpray> hmm
16:22:54 <OceanSpray> I should look into that.
16:23:05 <LoganCapaldo> @go haskell views
16:23:06 <lambdabot> No Result Found.
16:23:13 <LoganCapaldo> tear
16:24:07 <OceanSpray> 444 total
16:24:07 <rnorris> i just ran into a case where the a (b c) compiles, but (a . b) c doesn't ... in the second case it complains that the Inferred type is less polymorphic than expected
16:24:39 <rnorris> this doesn't make intuitive sense to me, but then again not much does
16:24:40 <LoganCapaldo> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
16:24:42 <lambdabot> Title: ViewPatterns - GHC - Trac
16:24:49 <mauke> > runST (return 0)
16:24:50 <lambdabot>   Not in scope: `runST'
16:25:03 <mauke> > Control.Monad.ST.runST (return 0)
16:25:04 <lambdabot>   Not in scope: `Control.Monad.ST.runST'
16:25:35 <mauke> bah
16:25:40 <mauke> anyway, that's an example
16:26:03 <dmwit> > palindromes "13579" "0123456789" !! 111
16:26:18 <lambdabot>  thread killed
16:26:32 <LoganCapaldo> thread necromancy
16:26:47 <dmwit> Ah well.
16:32:27 <dmwit> > read "" :: Int
16:32:43 <lambdabot>  thread killed
16:34:12 <LoganCapaldo> > read "\"book\"" :: String
16:34:13 <lambdabot>  "book"
16:34:38 <khadrin> > [0..3] >>= \x -> if and (sequence [(/=1),(/=2)] x) then [x] else []
16:34:42 <lambdabot>  [0,3]
16:34:53 <dmwit> > let truncLeft n = n - (n `mod` 10^(floor (logBase 10 n))) in trunLeft 32
16:34:55 <lambdabot>   Not in scope: `trunLeft'
16:35:02 <rnorris> > let foo x = Control.Monad.CC.runCC x
16:35:02 <lambdabot>  Parse error at end of input
16:35:05 <rnorris> bah
16:35:07 <dmwit> > let truncLeft n = n - (n `mod` 10^(floor (logBase 10 n))) in truncLeft 32
16:35:11 <lambdabot>  Add a type signature
16:35:15 <dmwit> > let truncLeft n = n - (n `mod` 10^(floor (logBase 10 n))) in truncLeft 32 :: Integer
16:35:22 <lambdabot>        add an instance declaration for
16:35:22 <lambdabot>       (RealFrac Integer, Floating Inte...
16:35:54 <litb> :t sequence
16:35:56 <dmwit> > filter (`notElem` [1, 2]) [0..3] -- for khadrin
16:35:57 <lambdabot>  [0,3]
16:35:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:36:18 <LoganCapaldo> > [0..3] >>= \x -> guard (x /= 2) >> guard ( x /= 1) >> return x
16:36:19 <lambdabot>  [0,3]
16:36:25 <khadrin> dmwit: much better
16:36:47 <dmwit> > [0..3] >>= \x -> [x | x /= 1 && x /= 2]
16:36:49 <lambdabot>  [0,3]
16:37:07 <litb> @src sequence
16:37:07 <lambdabot> sequence ms = foldr k (return []) ms
16:37:07 <lambdabot>     where
16:37:07 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
16:37:11 <dmwit> Now do me, guys. =)
16:37:19 <LoganCapaldo> > [ x | x <- [0..3], x /= 1, x /= 2 ]
16:37:20 <lambdabot>  [0,3]
16:37:27 <rnorris> can anyone clue me in as to why "let foo = Control.Monad.CC.runCC" works fine, but
16:37:40 <rnorris> "let foo x = Control.Monad.CC.runCC x" blows up with a crazy type error?
16:38:10 <rnorris> i think i may have waded in too deep here
16:38:45 <litb> maybe add a type declaration
16:39:17 <rnorris> i tried the declaration that i get from :t Control.Monad.CC.runCC and it still gripes
16:39:22 <litb> i've read something like monomorphism restriction. looks like that tho i'm still not sure what that is
16:39:31 <litb> hmm
16:39:37 <dmwit> > let truncRight = read . tail . show in truncRight 32 :: Integer
16:39:37 <lambdabot>  2
16:39:38 <LoganCapaldo> it looks like upside down MR though
16:39:38 <rnorris> yeah i added every switch i can find ;)
16:39:43 <redleafgr> what's the best platform-independent way to get a time elapsed in milliseconds since a program started?
16:39:51 <LoganCapaldo> if let foo = ... works and let foo x = .. x doesn't
16:40:11 <dmwit> redleafgr: I think the type in Data.Time has a Num instance.
16:40:14 <rnorris> sorry, upside down MR?
16:40:16 <LoganCapaldo> redleafgr: a good stopwatch?
16:40:29 <redleafgr> well, programmatically, i mean
16:40:35 <LoganCapaldo> I mean usually the MR makes the first not work and second be ok
16:40:43 <litb> > sequence [(*2), (*3)] 10
16:40:43 <lambdabot>  [20,30]
16:41:24 <dmwit> > map (*10) [2, 3] -- =)
16:41:24 <lambdabot>  [20,30]
16:41:34 <litb> o.O
16:41:46 <litb> > [20, 30] -- o.O
16:41:47 <lambdabot>  [20,30]
16:41:48 <redleafgr> Data.Time seems to provide seconds...
16:41:52 <litb> litb wins
16:42:05 <dmwit> litb: *nods*
16:42:17 <dmwit> litb: You could save one whitespace character, though...
16:42:43 <litb> hehe
16:42:44 <LoganCapaldo> > 20:[30] -- this in't shorter is it
16:42:47 <lambdabot>  [20,30]
16:43:05 <LoganCapaldo> just rading the comma for a colon
16:43:10 <LoganCapaldo> *trading
16:43:18 <dmwit> *raiding
16:43:30 <dmwit> makes you sound like a bad, bad dude in search of organs
16:43:45 <LoganCapaldo> Colon raider?
16:44:06 <LoganCapaldo> that's a scary thought
16:45:03 <dmwit> redleafgr: Indeed, but there's (luckily) also a Fractional/Real/etc instance.
16:46:01 <Taejo> WordNet is on Hackage: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/WordNet-0.1.1 (no it isn't perfect yet, but it's going to take too long to get perfect)
16:46:02 <redleafgr> ahh
16:46:04 <lambdabot> http://tinyurl.com/2qrkhf
16:46:09 <dons> yay
16:46:13 <dons> good work Taejo
16:46:19 <redleafgr> now if only i could import Data.Time... is it a new module? (I have ghc 6.6)
16:46:24 <dons> its important to bring all the libs and tools created before 2006 up to date, and on hackage
16:46:29 <dons> 20 years of libraries and tools
16:46:33 <dmwit> redleafgr: It should be available in 6.6.
16:46:36 <dons> redleafgr: its in the 'time' package
16:47:21 <Taejo> dons: most important deficiency is that it still looks for the database in the directory where Hal had his, instead of searching for it
16:47:52 <dmwit> :t all
16:47:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
16:48:15 <dons> Taejo: hehe ok.
16:48:19 <dons> it could be a configure time thing
16:48:23 <dons> or we install it
16:49:01 <Taejo> yeah, it should be a configure-time thing, but I couldn't figure out a good way to find it that would work on windows
16:49:16 <dcoutts_> dons: of course that's one reason hackage grew so quickly, most of the packages were not new but had previously been scattered
16:49:28 <Taejo> perhaps I should plump for the registry key on windows, and find on *nix
16:51:10 <Taejo> do Haskell compilers on Windows have a registry API?
16:51:22 <dons> dcoutts_: yep. but we're now in phase 2: new packages, and identifying abandoned older stuff
16:51:31 <dons> phase 1 was getting the current set of old stuff into shape
16:51:40 <LoganCapaldo> @hackage win32 registry
16:51:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/win32 registry
16:51:59 <LoganCapaldo> hmm
16:52:04 <EvilTerran> @go site:hackage.haskell.org win32 registry
16:52:05 <lambdabot> No Result Found.
16:52:06 <LoganCapaldo> @hackage is not a search <g>
16:52:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/is not a search <g>
16:52:14 <dcoutts_> dons: yes, and now taking advantage of the common format and central registry to improve package quality
16:52:20 <dons> yep
16:52:36 <EvilTerran> @go site:haskell.org registry
16:52:39 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/Win32/System-Win32-Registry.html
16:52:45 <dcoutts_> dons: I'm just pushing some more QA check improvements. Hackage will start enforcing a few more easy-to-identify rules.
16:53:02 <redleafgr> awesome, thanks guys
16:53:09 <LoganCapaldo> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Win32-2.1.0.0
16:53:09 <lambdabot> http://tinyurl.com/3b4jgm
16:53:21 <dons> dcoutts_: great. we'll be starting work this week, btw.
16:53:25 <dcoutts_> dons: but we need the build reporting system to be able to do more sophisticated checks
16:53:28 <dcoutts_> dons: great.
16:53:30 <dons> ok. cool
16:53:59 <LoganCapaldo> awww man
16:54:02 <dcoutts_> dons: you said you had a more specific list of needs, I don't think you sent it to me though.
16:54:09 <LoganCapaldo> that binding looks really thin
16:54:51 <LoganCapaldo> reeeeeally thin
16:55:07 <Taejo> LoganCapaldo: what were you hoping for?
16:55:25 <LoganCapaldo> Something chubbier is all
16:55:47 <LoganCapaldo> PKEY -> LPTSTR -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr DWORD -> Ptr FILETIME -> IO ErrCode -- run away! :p
16:55:58 <Taejo> oh, that is pretty nasty
16:56:19 <EvilTerran> hKEY_LOCAL_MACHINE <- eeeew
16:56:29 <dons> dcoutts_: ah right. yes.
16:56:50 <EvilTerran> kEY_READ <- it's even more horrible when the first letter's part of a word
16:56:50 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5591
16:58:47 <darrint> Is there an example of how to take a type like "data Message = forall i. (Eq i, Show i, Typeable i, Data i) => Message i" and use scrap your boilerplate on it?
16:59:59 * LoganCapaldo wonders what the difference between Ptr and ForeignPtr is
17:00:20 <sarehu> > fix (printf "hahaha %s") :: String
17:00:35 <lambdabot>  thread killed
17:00:38 <sarehu> sigh
17:01:13 <dcoutts_> LoganCapaldo: ForeignPtr can have finalisers
17:01:17 <Taejo> sarehu: infinite lols?
17:01:18 <monochrom> > fix (\s -> printf "hahaha %s" s) :: String
17:01:19 <lambdabot>  Exception: stack overflow
17:01:19 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
17:01:52 <monochrom> interesting
17:01:56 <LoganCapaldo> dcoutts: aha
17:03:30 <LoganCapaldo> mmm
17:03:40 <LoganCapaldo> pointer arithmetic in haskell
17:03:44 <LoganCapaldo> awesome
17:04:09 <sclv> darrint: there are lots of examples at the syb website.
17:04:34 <LoganCapaldo> also, castPtr :: Ptr a -> Ptr b
17:04:42 <darrint> sclv: All I can find is that all bets are off with existentials.
17:04:43 <sclv> first you need to have Message deriving Data, which ghc will do for you.
17:06:00 <cu3edweb> I am new to haskell and I was interested in creating a program to change the volume on my laptop. Where should I start reading?
17:06:14 <darrint> sclv: Can't make a derived instance of `Data Message'
17:07:47 <sclv> ah. didn't catch that it was an existential at first.
17:07:48 <monochrom> If you are new to Haskell, you should learn Haskell substantially first. :)  Try any books and tutorials listed on http://www.haskell.org/haskellwiki/Books_and_tutorials .  Generally use at least three of them.
17:07:48 <lambdabot> Title: Books and tutorials - HaskellWiki
17:07:51 <Botje> cu3edweb: probably on ways to change the volume :)
17:08:28 <cu3edweb> I am just thinking of something easy to start
17:08:49 <dmwit> > nub (1:[1..]) == 1:[1..]
17:08:50 <lambdabot>  False
17:09:41 <dmwit> cu3edweb: Depending on how much you know about how sound works on your system, that may or may not be an easy thing to do.
17:10:01 <dmwit> cu3edweb: (Don't you already have a way to change the volume?)
17:10:19 <Twey> cu3edweb: Haskell's power comes at a price: there's quite a bit of theory behind it, which you'll need before tackling any substantial problem.
17:10:28 <dmwit> cu3edweb: For some nice easy puzzles, maybe you could try Project Euler?
17:10:50 <dolio> Solving ruby quiz problems can be entertaining, too.
17:10:53 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/36481 HWN
17:10:54 <lambdabot> Title: Gmane -- Mail To News And Back Again
17:11:04 <cu3edweb> Yes I do. ok I will take a look at the wiki
17:11:18 <dmwit> ?where euler
17:11:19 <lambdabot> http://projecteuler.net
17:11:25 <dmwit> ?where rubyquiz
17:11:25 <lambdabot> I know nothing about rubyquiz.
17:11:29 <dolio> Holy smokes. A new Haskell Whenever News.
17:11:31 <dmwit> ?go ruby quizzes
17:11:32 <lambdabot> http://www.rubyquiz.com/
17:11:32 <lambdabot> Title: Ruby Quiz
17:11:47 <dons> http://reddit.com/info/68b5e/comments/ "Haskell Weekly News: more than 150 new and updated libraries! [programming] (article.gmane.org)"
17:11:55 <sclv> darrint: shouldn't be too hard to derive Data for yourself if you just define its operations as aliases to those of the thing it contains?
17:11:56 <redleafgr> can anyone recommend a library for manipulating vectors/matrices ?
17:12:06 <dons> hmatrix, I think , redleafgr
17:12:07 <sclv> not sure after that though...
17:12:10 <dons> on hackage.haskell.org
17:12:14 <redleafgr> ok, thanks
17:15:15 <monochrom> @remember dolio Holy smokes. A new Haskell Whenever News.
17:15:16 <lambdabot> Nice!
17:16:07 <dons> if anyone's interested and capable of doing fortnightly releases, i'd be interested
17:16:12 <sclv> hmm... some of the new and updated packages list contains dupes.
17:16:26 <sclv> i.e. a package and its update both released between hwn releases.
17:16:43 <sclv> there should be a way to automatically clean those...
17:16:43 <dons> ah yes, my script doesn't filter those
17:16:48 <dons> since it doesn't have a db of previously saved libs
17:17:12 <dons> sclv: http://code.haskell.org/~dons/code/hackage2hwn/
17:17:12 <lambdabot> Title: Index of /~dons/code/hackage2hwn
17:17:24 <dons> it would just need to cache items, and nub the result
17:17:58 <sclv> is that a hint? :-)
17:18:16 <dons> well, if you're interested. but it uses an internal xml lib that's not released yet
17:18:19 <dons> so a bit hard to build
17:18:30 <sclv> oh well then.
17:18:40 <Botje> in the same way that the halting problem is a bit hard to solve?
17:21:53 <Taejo> Botje: you mean when Language.Halting is written-but-unreleased?
17:22:45 <Botje> I'm pretty sure Simon has an implementation on a private Microsoft server somewhere.
17:23:19 <monochrom> Yeah, he also factors primes in polynomial time. :)
17:23:40 <Taejo> monochrom: he's not the only one
17:23:44 <hpaste>  morrow annotated "Short Circuit a filter" with "refinement" at http://hpaste.org/5571#a4
17:23:46 <monochrom> hehe
17:23:49 <sclv> willCrash f x = if (System.Windows) then True
17:23:56 <LoganCapaldo> Behind Simon's beard isn't a chin, but another fist?
17:23:58 <monochrom> hehehe
17:24:00 <Taejo> oops, I was thinking of PRIMES in P, which is not the same
17:26:48 <daf> heh, Simon PJ Facts would be amusing
17:27:57 <dolio> @quote OlegFacts
17:27:58 <lambdabot> OlegFacts says: When Oleg writes code, the typechecker asks *him* if it's correct.
17:29:58 <gwern> a new Haskell Weekly News, nice
17:30:04 <gwern> long one
17:30:29 <tenshx> I want to do an IO operation if a condition is true, but nothing if it isn't
17:30:36 <tenshx> is that possible with an if-statement?
17:30:40 <kpreid> yes
17:30:53 <dolio> @type when
17:30:55 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:30:57 <LoganCapaldo> if condtion then putStrLn "Whee" else return ()
17:30:59 <kpreid> @src when
17:30:59 <lambdabot> when p s = if p then s else return ()
17:31:16 <tenshx> ahh
17:31:23 <tenshx> O
17:31:29 <tenshx> I'll try it out*
17:32:59 <cjb> gwern: ah, the HWN site seems down
17:33:09 <gwern> cjb: email mon ftw
17:33:17 <cjb> *nod*
17:33:29 <gwern> hey, does anyone know whatever happened to LOLITA? it seems to have been one of the biggest early haskell projects
17:33:40 <tenshx> hmm... is it possible to do it without returning the function?
17:33:50 <mauke> tenshx: what?
17:33:52 <tenshx> the if-thingie
17:33:59 <mauke> what do you mean by "returning the function"?
17:34:10 <LoganCapaldo> return doesn't mean what it means in other languages
17:34:11 <dolio> return isn't like it is in C.
17:34:17 <tenshx> I want to a thing if a condition is true, but I want to do stuff after either wya
17:34:25 <mauke> yes, that's what that code does
17:34:26 <LoganCapaldo> right
17:34:29 <tenshx> ahh, ok
17:34:53 <mauke> 'return' is a function, not a control statement
17:35:03 * gwern discovers http://haskell.org/haskellwiki/Haskell_in_practice <-- oh noes, most of those aren't on hackage *or* are updated for 6.8.x! there goes the rest of my month
17:36:01 <tenshx> ahh, when I tried it earlier I got a similar looking error at another place
17:36:08 <tenshx> maybe it's bed time
17:36:19 <dolio> The main message of the latest HWN is: gwern is a packaging machine. :)
17:36:21 <Cale> gwern: Your new last name should be Hackager.
17:36:28 <tenshx> thanks guys
17:37:12 <Cale> tenshx: Basically, return is not useful except for at the end of a do-block. It can be removed from the beginning or middle.
17:37:33 <gwern> Cale: leave that for when I level up. I wonder sometimes if I suffer from very mild OCD. it offends me to see a non-Hackaged, non-Wall-clean bunch of Haskell code, for some reason
17:37:48 <tenshx> Cale: okay, cool
17:37:48 <gwern> http://www.dtek.chalmers.se/~d95jowi/quakehaskell/index.html <-- hm. Quake in haskell?
17:37:49 <lambdabot> Title: Projekt D3 - Quake Haskell
17:38:10 <dcoutts_> gwern: good! we need people to package stuff and make it nice and clean
17:38:14 <Cale> gwern: Yeah, that's a very old project. I have no idea if code is available.
17:38:16 <tenshx> oh, yeah
17:38:27 <tenshx> I heard about it when I started chalmers :)
17:38:35 <Cale> gwern: It was apparently successful at the time though, which was quite surprising.
17:38:44 * gwern can't read the page, so I have no idea about it
17:38:45 <tenshx> quake 3 I think
17:38:53 <gwern> whoever wrote it had truly terrible English
17:39:04 <gwern> I mean, I don't even recognize some of those letters!
17:39:13 <dcoutts_> dons: there are loads more QA checks we can do with build reporting, one is to identify packages that have far too much -Wall output (there are several)
17:39:20 <kpreid> mauke: that's a bit of a false dichotomy -- mplus is a function, but that doesn't mean it isn't a control statement :)
17:39:24 <gwern> dcoutts_: like?
17:39:39 <dcoutts_> gwern: eg HaXml-1.13.3
17:39:39 <mauke> call/cthulhu
17:39:45 <ddarius> kpreid: And [1,3,5] is a data structure but that doesn't mean it isn't a control structure.
17:39:56 <kpreid> aye
17:40:07 <gwern> dcoutts_: no, I already took care of haxml
17:40:10 <gwern> :)
17:40:14 <dcoutts_> dons: I don't mean packages that don't use -Wall at all, but ones that do use it and then spew 100's of lines onto users screens. When there's that much output -Wall is not useful.
17:40:28 <gwern> (haxml was yesterday or friday, iirc)
17:40:30 <dcoutts_> gwern: oh sure the 1.19 version is much better, 1.13.x is in maintenance mode
17:40:40 <Twey> dcoutts_: On the other hand the program probably needs some serious work...
17:41:11 <gwern> there was an awful lot of repetition and dead code in the haxml codebase. i was a little disquieted
17:41:21 <dcoutts_> Twey: perhaps, but it's no good spewing that at an end user of the package who is just trying to build it.
17:42:19 <dcoutts_> dons: a really cool project would be to use the ghc-api as a Compiler in Cabal and then collect really detailed info on warnings etc. And add in extra lint checks using the ghc api. And to include all that into a build report.
17:42:22 <Twey> dcoutts_: Well yeah, but it's the package that needs fixing, not the fact that it uses -Wall
17:42:31 <gwern> dcoutts_: it provides an incentive for the users to fix them... most -Wall warnings are dead easy to fix.
17:42:42 <gwern> worked for me, anyway. haxml irrirated me for the last time
17:42:42 <dcoutts_> Twey: well, both, but from different people's perspectives.
17:43:02 <Twey> gwern, heh
17:43:34 <gwern> oh, thank god, I finally found a 'rapport2.ps' file with some english in it on the quake website
17:44:11 <gwern> 'The graphics engine is written in C and we have used the OpenGL graphics library, the rea-son for this is that this gives you both decent performance and portability, something that you would not get if you would have used assembly language or a functional language.' <-- ew. suddenly I am less interested
17:44:28 * Twey nods.
17:44:51 <gwern> at least the code is in English :)
17:45:16 <TomMD> Any experienced fraggers out there?  Or any experienced GLUT people here now?
17:45:47 <gwern> (one of these days, we'll get skinnable programming languages - easily internationalizable, syntax easily redefined, unicodeified, and so on. that'd be nice)
17:46:09 <gnuvince_> pick 2?
17:46:14 * cjb would settle for a Unicode lambda glyph he could use.
17:46:31 <TomMD> gwern: Will we call it Haskell X or Dragonfly Haskell?
17:46:34 <cjb> is there a GHC option for "I hate Greek people and want to abuse their lowercase alphabet"?
17:46:51 <Botje> gwern: lisp has reader macros. you can do pretty cool stuff with them
17:47:01 <cjb> Someone claimed last time I brought this up that there is a math-lambda codepoint as well as a Greek-lambda codepoint, but I don't see it.
17:47:06 <johnnowak> cjb: hehe
17:47:27 <darrint> I'd appreciated it if someone brilliant could look at http://hpaste.org/5592 . I can't figure out how to define gunfold.
17:47:36 <gwern> TomMD: lambdafly, so it's so superly
17:47:53 <gwern> cjb: your jokes. they are very droll.
17:48:00 <gwern> TomMD: *since it's so
17:48:07 <gwern> **superfly
17:48:08 <cjb> gwern: I'm British, see.
17:48:13 * gwern is a distracted gwern
17:48:18 <johnnowak> cjb: I'm sorry.
17:48:21 <dolio> darrint: Can't you have GHC derive Data?
17:48:31 <gwern> cjb: no jokes please, we're not british
17:48:36 <darrint> no. It's existential.
17:48:38 <cjb> johnnowak: It's okay, I'm getting over it by living in the US.
17:48:44 <dolio> Ah. Bummer.
17:48:51 <johnnowak> cjb: Are you full of optimism yet?
17:49:03 * gwern could do a recursive wget...
17:49:30 <cjb> johnnowak: Si, si puede!
17:49:58 <Adamant> wasn't there a proposal to do programming languages in XML? (in reference to what gwern said)
17:50:02 <mauke> http://www.guardian.co.uk/commentisfree/story/0,,2253033,00.html
17:50:04 <lambdabot> Title: Guardian Unlimited | Comment is free | Britain is slithering down the road towar ...
17:50:08 * johnnowak fires up his mexican to american translator
17:50:31 <cjb> johnnowak: it's the Cesar Chavez line that Obama borrowed; "Yes, we can!".
17:51:00 <sclv> gunfold is used when you're creating generics. if you don't plan to use it at first, you can always leave it undefined. for traversing them, gfoldl is the key...
17:51:09 <johnnowak> Ah, right. Mr. Unbridled Optimism himself.
17:51:23 <cjb> mauke: It's true.  I'm not one of those Brits who thinks that England is awesome and American is messed up.  England has some pretty big problems.
17:51:55 <johnnowak> Careful, the cameras are watching.
17:52:34 <cjb> johnnowak: They'll never get an extradition order.  :)
17:53:44 <cjb> Man.  All this for a Unicode lambda.
17:54:10 <gwern> cjb: better than arguing over spaces or tabs
17:54:15 <sclv> darrint: what do you plan to be able to do with your messages besides show them?
17:54:17 <johnnowak> no it isn't!
17:54:21 <gwern> at least with lambas it's visible
17:54:24 <gwern> johnnowak: yes it is!
17:54:25 <Cale> Um, why not just use the greek lambda?
17:54:27 <johnnowak> no it isn't!
17:54:31 <cjb> Cale: That's what I said!
17:54:36 * johnnowak vomits λs
17:54:38 <Cale> I don't think there's another one.
17:54:40 <sclv> this isn't an argument. :-)
17:54:42 <darrint> sclv embed them in other messages maybe.
17:54:43 <johnnowak> yes it is.
17:54:50 <cjb> Cale: We can't reserve it in GHC, because then Greek people would be unable to write code using their language.
17:54:57 <litb> ok, i'm looking forward to extend my differentiating framework
17:55:17 <sclv> hmm.. and what function would you use to do that?
17:55:45 <Cale> You could just handle it at the editor level.
17:55:50 <tehgeekmeister> in playing around with let expressions and looking at the haskell report, i found this perverse concoction, and i'm curious why it's defined at all, and what (if anything) it does: let [a,b] = [2*a,2*b] in [1,2], as an example.  but more generally, pat = exp -- the pattern never gets reached in a case like this because there's no function name to use in order to apply the corresponding function to any values...
17:55:52 <darrint> sclv I'd just construct them.
17:56:03 <tehgeekmeister> i'd've expected from how i've seen them used that let expressions would have syntax along the lines of let functionname pat = expr, not just let pat = expr
17:56:07 <litb> i want a specific Funktion <T->T> (Just (Funktion ....))  to be printable like "sin(x) + cos(x)" how would i do that?
17:56:14 <Cale> tehgeekmeister: uh, that's perfectly okay
17:56:23 <cjb> Cale: Yes, some people do that.  There is a haskell-mode hack.
17:56:29 <litb> is it necassary to define a data constructor for every function like sin, cos, tan and so forth ?
17:56:31 <sclv> darrint: so the question is sort of why you need an existential at all and not just a string.
17:56:34 <cjb> http://mult.ifario.us/p/emacs-haskell-mode-unicode-cuteness
17:56:34 <lambdabot> Title: emacs-haskell-mode-unicode-cuteness
17:56:42 <Cale> > let [a,b] = [1:b,2:a] in a
17:56:46 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
17:56:47 <litb> and then implement the show class to convert it?
17:56:48 <tehgeekmeister> Cale: but of what use is something like that?
17:56:56 <Cale> ^^ see above :)
17:57:00 <gwern> that's it/ I
17:57:08 <gwern> m wgetting this quake haskell thing
17:57:16 <gwern> surely the source code must be somewhere on their site!
17:57:40 <darrint> sclv I'm thinking that I should not do this at all, but have some kind of "reference to list of messages" system.
17:57:40 <Cale> gwern: Let me know if you find it. Back when I looked at that site years ago I couldn't find it.
17:57:45 <gwern> cjb: it's a nice hack. I helped add in quite a few characters. causes problem copy-pasting tho
17:57:49 <tehgeekmeister> Cale: so it's generally going to be useful for insane things?
17:58:03 <Cale> tehgeekmeister: Well, it would be strange to *disallow* it.
17:58:07 <cjb> gwern: Yes, not a great solution
17:58:18 <litb> it caused problems with my emacs
17:58:24 <Cale> tehgeekmeister: You're generally allowed to make pattern bindings, and you're generally allowed to make recursive definitions
17:58:32 <litb> or, better, it is very slow with much code
17:58:32 <Cale> So why not recursive pattern bindings?
17:58:38 <Cale> There's also things like:
17:59:18 <Cale> > let fibs@(_:tfibs) = 0 : 1 : zipWith (+) fibs tfibs
17:59:18 <lambdabot>  Parse error at end of input
17:59:22 <Cale> > let fibs@(_:tfibs) = 0 : 1 : zipWith (+) fibs tfibs in fibs
17:59:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:59:34 <gwern> slow? I never noticed
17:59:38 <sclv> ddarint: if all you're doing is showing them or manually constructing new ones, you should probably just use strings.. data Message = Message String. mkMsg x = Message (show x)
18:00:06 <LoganCapaldo> Cale: tht's creepy
18:00:15 <kpreid> litb: you can define a PrimFunktion as a Haskell function plus a String naming it; then you can derive descriptions of all compositions of PrimFunktions from that
18:00:20 <Cale> LoganCapaldo: What's creepy about it?
18:00:51 <LoganCapaldo> it's jsut creepy. :P
18:01:06 <Cale> LoganCapaldo: I used pattern matching instead of tail? :P
18:01:18 <tehgeekmeister> Cale: oh, god, i get how that works now.  so my next question is going to be -- what is something along the lines of let a b = 2 * b doing, i.e.: how does haskell know that in this case a isn't a pattern, but a function name?
18:01:19 <ray> @ in patterns is creepy
18:01:25 <gwern> Cale: I think I found it! my wget is downloading this page, for example: 'www.dtek.chalmers.se/~d95jowi/quakehaskell/quake/web/source/grafikmotor/hash_unix.c'
18:01:38 <Cale> tehgeekmeister: because it's being applied to b
18:01:41 <darrint> sclv string isn't sufficient here unfortunately
18:01:46 <Cale> tehgeekmeister: and it's not uppercase
18:01:49 <litb> kpreid: i wonder what a PrimFunction is
18:01:51 <kpreid> tehgeekmeister: the difference is that there's an application
18:01:59 <gwern> http://www.dtek.chalmers.se/~d95jowi/quakehaskell/quake/web/source/draw3df/ <-- eureka, hs files
18:02:00 <kpreid> litb: one of the cases of your Funktion data type
18:02:00 <lambdabot> Title: Index of /~d95jowi/quakehaskell/quake/web/source/draw3df, http://tinyurl.com/ynlws2
18:02:08 <kpreid> the constructors of, I should say
18:02:12 <sclv> hence my question, what you're doing besides showing it?
18:02:33 <gwern> (software archaeology can be such fun)
18:02:33 <litb> ah
18:03:16 <litb> i want to connect to gnuplot and plot my function then using it
18:03:20 <sclv> i.e. if you want it to be an existential with say four methods, then you could also equally well define a data type that was just a partial application of all four methods...
18:03:30 <sclv> (make the dictionary passing explicit)
18:03:34 <Cale> tehgeekmeister: Data constructors can be syntactically distinguished from ordinary functions: If they're infix then they start with a colon, and if they're prefix, then they start with an uppercase letter.
18:04:02 <Cale> tehgeekmeister: Single variables on the lhs of an = are always patterns
18:04:37 <litb> on <- too afaik
18:05:01 <Cale> If the LHS of the = is an application of something to some parameters, you can tell if it's a pattern or not by looking at whether the thing which is being applied is a data constructor.
18:05:05 <tehgeekmeister> >let 1 = 2 in 1
18:05:09 <gwern> interesting. did it used to be legal in Haskell to have a comment which went '--======='...? with no space?
18:05:15 <Cale> heh, that's a funny corner case :)
18:05:19 <Cale> > let 1 = 2 in 1
18:05:20 <tehgeekmeister> > let 1 = 2 in 1
18:05:23 <lambdabot>  1
18:05:23 <lambdabot>  1
18:05:36 <Cale> It doesn't bind anything.
18:05:46 <Cale> 1 is an n-pattern.
18:05:47 <mauke> > let sqrt 2 = 1.5 in sqrt 2
18:05:48 <lambdabot>  1.5
18:06:03 <kpreid> > let Just _ = Nothing in Just 1
18:06:04 <lambdabot>  Just 1
18:06:33 <gwern> interesting. Num used to have both 'fromInt' and 'fromInteger'
18:06:39 <Cale> gwern: yeah
18:06:49 <Cale> gwern: That was back in Haskell 1.4 or maybe 1.3
18:06:53 <sarehu> > let t@(1,x) = (2,9) in snd t
18:06:54 <lambdabot>   Irrefutable pattern failed for pattern (t@(1, x))
18:06:56 <ray> > let 1 + 1 = 1 in 1 + 1
18:06:57 <lambdabot>  1
18:07:03 <gwern> Cale: well, this *is* awful old code
18:07:04 <tenshx> @type Word8
18:07:04 <tehgeekmeister> hmm.  okay, i think i've had enough of digging into haskell's internals for now.
18:07:07 <ray> therefore 1 = 2
18:07:09 <lambdabot> Not in scope: data constructor `Word8'
18:07:33 <dolio> You didn't even have to divide by 0!
18:07:55 <gwern> wow. I fix the comments and the fromInt Num type class instances, and that module compiled
18:08:02 <Cale> tehgeekmeister: You could go about trying to exclude these funny corner cases, but to do it generally would probably also exclude some useful things.
18:08:43 <tehgeekmeister> ray: nice example!
18:08:53 <Cale> dolio: Dividing by 0! is fine. ;)
18:09:08 <dolio> :)
18:09:12 <gwern> query : what does 'import IO' import these days?
18:09:22 <Cale> gwern: import System.IO
18:09:23 <tenshx> can I convert Int to GHC.Word.Word8?
18:09:29 <tenshx> I can't find anything about it
18:09:30 <Cale> gwern: Though IO is in Haskell 98
18:09:37 <Cale> tenshx: fromIntegral
18:09:48 <tenshx> ohh
18:09:51 <tenshx> thanks
18:09:55 <dolio> > fromIntegral (1 :: Int) :: Word8
18:09:56 <lambdabot>  1
18:09:57 <gwern> Cale: thanks
18:10:01 <Cale> tenshx: converting from any integer-like type to any other numeric type is done with fromIntegral
18:10:09 <tenshx> cool
18:10:20 <LoganCapaldo> @quote fromIntegral
18:10:20 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
18:10:23 <tenshx> I just remembered that I did that once a long time ago when I wanted a double
18:10:34 <gwern> lots of -wall warnings, but I suppose ghc didn't have -wall back then
18:10:40 <tenshx> hehe :)
18:11:17 <Cale> tenshx: Basically the only other numeric conversion you need to know about is realToFrac, which converts between different floating point and fractional types. Then there's round/floor/ceiling for fractional -> integer-like
18:11:18 <gwern> 'main = world "/users/mdstud/d3pa/lab_grupper/d3pa-3/worlds/ramp5.w" [player1,player1shot,spider1,door_cave,door2_cave,button1,button2,medkit1,lennart,lennartshot,doorV,doorH,wolverine,wolverineshot]' <-- hardwired constants boo!
18:11:31 <Cale> 'lennart'?
18:11:32 <Cale> :)
18:11:46 <ray> lennart must fire lennartshots
18:11:46 <gwern> Cale: yeah, lennart augustsson was one of the advisors
18:11:51 <Cale> :)
18:11:53 <gwern> didn't you see his mug on the pics page?
18:11:56 <tenshx> Cale: great, thanks :)
18:11:57 <sarehu> let plus=(+) in let {1 + 1 = 1 ; x + y = plus x y} in let {fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)} in fib 10
18:12:03 <litb> @quote haskell truth
18:12:03 <lambdabot> No quotes for this person. Maybe you made a typo?
18:12:05 <sarehu> > let plus=(+) in let {1 + 1 = 1 ; x + y = plus x y} in let {fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)} in fib 10
18:12:08 <lambdabot>  1
18:13:35 <gwern> Cale: I'm actually a little surprised how readable the code is and how easy it is to get work. I wonder how well python, c or c++ would hold up after a decade?
18:13:46 <litb> > let z=zip; t=tail; f=0:1:zip (+) f (t f) in f
18:13:47 <lambdabot>  Couldn't match expected type `[a]'
18:14:00 <litb> > let z=zip; t=tail; f=0:1:(zip (+) f (t f)) in f
18:14:01 <lambdabot>  Couldn't match expected type `[a]'
18:14:02 <litb> hm
18:14:05 <ray> well decade-old C is unreadable, but usually still runs
18:14:06 <litb> oh
18:14:14 <litb> > let z=zip; t=tail; f=0:1:zipWith (+) f (t f) in f
18:14:15 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:14:24 <Cale> Whoa, there's fudgets code in here :)
18:15:00 <gwern> fudgets?
18:15:24 <Cale> Was a high-level Haskell GUI library built on top of Tk.
18:15:31 <Cale> http://www.dtek.chalmers.se/~d95jowi/quakehaskell/quake/web/source/draw3df/
18:15:32 <lambdabot> Title: Index of /~d95jowi/quakehaskell/quake/web/source/draw3df, http://tinyurl.com/ynlws2
18:15:32 <LoganCapaldo> > let cale@(_:caless) = 2 : 3 : zipWith (*) cale caless
18:15:33 <lambdabot>  Parse error at end of input
18:15:35 <Cale> seems to use it
18:15:40 <ddarius> One of the precursors to FRP
18:15:49 <LoganCapaldo> > let cale@(_:caless) = 2 : 3 : zipWith (*) cale caless in cale
18:15:50 <lambdabot>  [2,3,6,18,108,1944,209952,408146688,85691213438976,34974584955819144511488,2...
18:15:59 <litb> hehe
18:16:06 <Cale> > describeSequence 2,3,6,18,108,1944
18:16:06 <lambdabot>   parse error on input `,'
18:16:10 <Cale> > describeSequence [2,3,6,18,108,1944]
18:16:11 <lambdabot>   Not in scope: `describeSequence'
18:16:15 <Cale> ..
18:16:20 <Cale> @oeis describeSequence [2,3,6,18,108,1944]
18:16:20 <lambdabot> Sequence not found.
18:16:24 <Cale> @oeis [2,3,6,18,108,1944]
18:16:25 <lambdabot> Sequence not found. BOB says:  You seem to have forgotten your passwd, enter ...
18:16:27 <Cale> hmm
18:16:37 <ddarius> @oeis 2 3 6 18 108 1944
18:16:38 <lambdabot> a(n) = a(n-1) a(n-2).
18:16:38 <lambdabot> [2,3,6,18,108,1944,209952,408146688,85691213438976,34974584955819144511488,29...
18:16:40 <gwern> ah, 'import AllFudgets'
18:16:44 <Cale> Why is describeSequence gone?
18:16:48 <gwern> so, uh, how unmaintained is Fudgets?
18:16:55 <Cale> Very unmaintained.
18:17:00 <ddarius> gwern: Fudgets has been dead for a while.
18:17:11 <litb> @users
18:17:11 <lambdabot> Maximum users seen in #haskell: 471, currently: 429 (91.1%), active: 19 (4.4%)
18:17:15 <kpreid> @tell dons could you add #rosettacode to the permanent config for lambdabot?
18:17:16 <lambdabot> Consider it noted.
18:17:22 <ddarius> I'm pretty sure it was long dead before I got here... in 2002
18:17:38 <Cale> @version
18:17:39 <lambdabot> lambdabot 4p581, GHC 6.6 (Linux i686 2.40GHz)
18:17:39 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:17:42 <Cale> wtf?
18:17:47 <gwern> kpreid: what does #rosettacode do?
18:17:48 <LoganCapaldo> let's have them make a comeback!
18:17:56 <LoganCapaldo> bring back Fudgets!!
18:18:02 <LoganCapaldo> what are Fudgets?
18:18:21 <kpreid> gwern: http://www.rosettacode.org/
18:18:23 <lambdabot> Title: Main Page - Rosetta Code
18:18:24 <Cale> Ah, my lambdabot died.
18:18:24 <Botje> who cares, as long as they're back!
18:18:36 <Cale> Url module failed in contextual handler.
18:18:46 <Cale> I wish I knew what URL caused that.
18:18:58 <dolio> Yeah, most Haskell code needs more >===< in it.
18:19:12 <gwern> I notice a lot of file names and modules clash. I guess insisting that they be the same was a later development
18:19:50 <Cale> It's still not entirely required.
18:20:04 <Cale> Just inconvenient to name them differently.
18:20:15 <Cale> (because you have to pass them explicitly to GHC then)
18:20:35 <LoganCapaldo> well one thing you can say about Haskell, it doesn't lack for experimental GUI libs
18:21:17 <Cale> kpreid: I'll add rosettacode
18:21:52 <Cale> Wait, is there some limitation on the number of channels?
18:21:57 <ddarius> Yes
18:22:06 <kpreid> 20
18:22:07 <gwern> LoganCapaldo: there's two ways to take such proliferation...
18:22:19 <LoganCapaldo> at least
18:22:21 <Cale> okay, we're only at 15
18:22:24 <kpreid> I thought lambdabot got multi-connection support
18:22:30 <cjb> Wow, people writing so many Haskell libraries.  I wish I could think of something to work on.
18:22:58 <khadrin> cjb: haskell on rails
18:23:00 <dons> cjb, there must be something you specialise in, that you could contribute a haskell interface to :)
18:23:00 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:23:05 <litb> cjb: you could join my efforts on creating a automatic differentiation library connected with gnuplot integrated into emacs =)
18:23:12 <Cale> @quit
18:23:12 <dons> i'd be happy with ghc preinstalled on the olpc
18:23:18 <litb> then people could use that with the haskell interpreter
18:23:19 <cjb> litb: nice :)
18:23:23 <Cale> grr
18:23:25 <cjb> dons: we don't even preinstall gcc :)
18:23:28 <dons> Cale: i'll get it
18:23:29 <ddarius> World-class Haskell on Rails Enterprise
18:23:43 <dons> cjb: ok. hehe.
18:23:52 <mib_gb9896ox> pl
18:23:53 <gwern> 'Not in scope: type constructor or class `MonadZero'' <-- lol?
18:24:00 <Cale> gwern: Not lol.
18:24:04 <bd_> Prime?
18:24:07 <dons> i got a macbook for my girlfriend this weekend, and noted to my hmm, chagrin, that it has ruby python, perl and java preinstalled
18:24:10 <mib_gb9896ox> pl \p n -> n `mod` p > 0
18:24:14 <bd_> Never heard of a MonadZero' :)
18:24:17 <dons> ruby! i mean, seriously. how do we get on that list
18:24:27 <gwern> bd_: I think I've hear Cale grouch about its removal
18:24:47 <dmwit> bd_: There's a start-quote too.  you've done EPARSE
18:25:00 <sarehu> > join ((-) . join (*)) (ap (zipWith (flip (/))) tail (fix ((1:) . (scanl (+) 1))) !! 39)
18:25:07 <LoganCapaldo> ruby was actually on that list (along w/ python) before the whole "ZOMG RAILS!!!" thing
18:25:16 <lambdabot>  thread killed
18:25:17 <Cale> gwern: What file is that?
18:25:22 <dons> huh, didn't know that LoganCapaldo. any idea why?
18:25:25 <sarehu> > join ((-) . join (*)) (ap (zipWith (flip (/))) tail (fix ((1:) . (scanl (+) 1))) !! 39)
18:25:26 <lambdabot>  1.0000000000000002
18:25:27 <LoganCapaldo> I assume it's some kind of internal Apple dynamically typed language cabal
18:25:37 <bd_> dmwit: there were two 's at the end, so wouldn't one be part of the name?
18:25:40 <dons> hmm, yes perhaps.
18:25:41 <allbery_b> dons: worse, even if you install macports it only has 6.6.1
18:25:44 <gwern> 'a generalized version of Graham Hutton and Erik Meijer's A LIBRARY OF MONADIC PARSER COMBINATORS' <-- wow, so I guess it's like some really early Parsec
18:25:48 <Cale> dons: btw, what's the issue with the Url module? I had that problem in mbot and just ended up disabling the Url module altogether.
18:25:56 <gwern> Cale: Solid/parselib4.hs
18:25:58 <dmwit> bd_: No, because there's also one at the very beginning.
18:25:58 <dons> toolchain preinstallion keeps languages permanently second class :(
18:26:08 <ddarius> gwern: That's not a Parsec.
18:26:11 <bd_> dmwit: ` is closed by two ' ?
18:26:14 <dons> Cale, a failure to resolve in the network lib blocks all the threads
18:26:25 <dmwit> bd_: ', then `, is closed by ', then '
18:26:30 <bd_> ahh
18:26:33 <Cale> dons: Oh, that's bad.
18:26:36 <litb> @pl \p n -> n `mod` p > 0
18:26:37 <lambdabot> flip flip 0 . ((>) .) . flip mod
18:26:37 <dcoutts_> wow, the hpaste code is pretty nice, very short and including irc bot feature
18:26:38 <tehgeekmeister> is there a version of !! that returns a Maybe a instead of raising an error on too large an index?
18:26:45 <litb> omg
18:26:56 <dons> Cale, i think you can tweak around it with (or without) -threaded
18:26:56 * ddarius should actually read Boquist's thesis sometime.
18:27:00 <dons> but we didn't narrow it down
18:27:02 <allbery_b> dons: are we certain of that?  I hacked Network to flag everything "safe" and it still hangs :(
18:27:03 <mauke> @hoogle [a] -> Int -> Maybe a
18:27:04 <lambdabot> No matches, try a more general search
18:27:04 <litb> i will never understand the combination of flip and . o.O
18:27:04 <dmwit> tehgeekmeister: How about [a], is that good enough?
18:27:09 <dons> dcoutts_: what would you expect? :)
18:27:14 <dmwit> tehgeekmeister: take 1 . drop n
18:27:17 <allbery_b> (well, everything that touches the network)
18:27:18 <sarehu> listToMaybe . drop n
18:27:30 <dmwit> sarehu: Oh, that's even better.
18:27:31 <sarehu> unsafeCoerce . drop n
18:27:42 <bd_> sarehu: unsafeCoerce?!
18:27:49 <tehgeekmeister> dmwit: i can make do with that.
18:27:56 <sarehu> yah ^_^
18:27:56 <dcoutts_> dons: not sure :-) I don't do much web stuff. Seems we could make a happs based hackage without too much pain.
18:27:57 <Cale> gwern: Also note the pretty names of the methods of MonadZero and MonadPlus
18:28:02 <ddarius> Preserves sharing
18:28:05 <bd_> sarehu: isn't that... rather extremely unsafe?
18:28:08 <dons> dcoutts_: i agree. fastcgi would also be pretty easy.
18:28:12 <Cale> gwern: zero and ++
18:28:14 <sarehu> bd_: yah ^_^
18:28:20 <bd_> sarehu: (what happens if the order of the constructors is changed in a future version?)
18:28:33 <dons> we've a fair bit of inhouse web experience now, so i'm hoping to get trevor to make a proposal for what tech would be the best to go with
18:29:06 <dcoutts_> dons: one of the main things I want is the urls all to be relative to some root, at the moment it's not at all clear what they are. eg we have the upload url stored separately from the others since I don't know how to calculate one from the other.
18:29:19 <gwern> :t zero
18:29:20 <lambdabot> Not in scope: `zero'
18:29:27 <dons> yeah, its all a bit ad hoc.
18:29:31 <Cale> They're called mzero and mplus now.
18:29:32 <dons> but small enough we can do a good job
18:29:40 <dcoutts_> dons: hope so :-)
18:29:44 <dons> anyone think DList should be in the containers package?
18:29:56 <Cale> Sigh, and Monad with no fail.
18:30:04 <dons> i got a request for it -- and that Writer should almost always in a DList a, instead of a [a]
18:30:22 <Cale> Looking at Haskell 1.4 code is saddening. Haskell 98 was such a step backwards in so many ways.
18:30:43 <dons> Cale: yeah, the idea that h98 would be a scheme of the 21st century got in the way
18:30:47 <ddarius> There's always the future Cale.
18:30:51 <dons> apparently python is the scheme of the 21st century :)
18:30:55 <dons> *sigh&
18:31:02 <ray> robo-Cale
18:31:11 <dcoutts_> dons: you'd have to check the api, eg what is maybeReturn there for? and any docs for 'list'?
18:31:13 <dolio> What does that mean?
18:31:14 <Cale> ray: hm?
18:31:27 <ricky_clarkson> dons: That's like refusing to do maths unless it's about money.
18:31:27 * ddarius understands ray
18:31:28 <dcoutts_> dons: oh, it's like maybe?
18:31:32 <ray> the future Cale would be a robot
18:31:38 <dons> its the Maybe -> MonadZero injection
18:31:39 <Cale> ah
18:31:41 <Cale> hehe
18:31:49 <gwern> Cale: can you even load linear_classes.hs? it's got an odd Unicode operators going on
18:31:59 <dons> sorry, MonadPlus
18:32:10 <ddarius> Was this aimed at HBC?
18:32:19 <ddarius> (It would be likely.)
18:32:32 <dobblego> why MonadPlus? why not just MonadZero? (what are you talking about anyway :))
18:32:33 <dcoutts_> dons: sorry, I mean list, it's like list [] (:) :: DList a -> [a]
18:32:56 <dcoutts_> dons: maybeReturn doesn't seem at all related to the other functions or types in the module
18:32:57 <dobblego> ?type \x -> case x of None -> mzero; case Some t -> return t
18:33:00 <lambdabot> parse error on input `->'
18:33:10 <Cale> gwern: I can load it
18:33:13 <dons> yeah, it would really go in Data.Maybe
18:33:13 <ddarius> dobblego: Take your MLisms elsewhere.
18:33:17 <Cale> gwern: I mean, I can read it.
18:33:19 <dobblego> oops
18:33:27 <Cale> gwern: But I haven't tried loading it in GHC
18:33:28 <dobblego> ?type \x -> case x of Nothing -> mzero; case Just t -> return t
18:33:29 <lambdabot> parse error on input `->'
18:33:30 <dcoutts_> dons: and how is list different from flip foldr?
18:33:34 <dons> Scala-isms
18:33:49 <dcoutts_> dons: it's just one level deep is it?
18:33:59 <dons> -- | /O(length dl)/, List elimination, head, tail.
18:33:59 <dons> list :: b -> (a -> DList a -> b) -> DList a -> b
18:33:59 <dons> list nill consit dl =
18:33:59 <dons>   case toList dl of
18:33:59 <dons>     [] -> nill
18:34:00 <Cale> gwern: You could just replace × with .*. or something.
18:34:02 <dons>     (x : xs) -> consit x (fromList xs)
18:34:17 <dcoutts_> dons: oh! it's uncons :-)
18:34:35 <dons> yeah :)
18:34:40 <dcoutts_> it's the one level case/view function
18:34:49 <dons> right, unlike foldr
18:34:56 <dobblego> ?type \x -> case x of Nothing -> mzero; Just t -> return t
18:34:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
18:35:14 <dcoutts_> dons: want docs :-) and we call that uncons in bytestring, dunno if that's a better name or not.
18:35:15 <dmwit> > [2,3,5..]
18:35:15 <lambdabot>  Parse error at "..]" (column 7)
18:35:17 <dons> the non-recursive catamorphism for lists (does this have a name?)
18:35:46 <dons> well, uncons doesn't take functions for the left and right case. but its close
18:35:55 <litb> next month we start to have the "automats and formal languages" course at highschool. i will really enjoy it i think
18:36:05 <olsner> uncons = head &&& tail?
18:36:27 <ddarius> uncons = fmap (head &&& tail) . listToMaybe
18:36:37 <Cale> uncons n c [] = n; uncons n c (x:xs) = c x xs
18:36:44 <dcoutts_> dons: right, that uses a Maybe, so it's like maybe z c (uncons foo) or something like that
18:37:24 <ddarius> Uh, not quite mine.
18:39:36 <dmwit> Project Euler problem 41 is really nice.
18:42:52 <glen_quagmire> how come lambda doesn't have self?
18:43:11 <psykon> say what?
18:43:14 <dmwit> self?
18:43:31 <glen_quagmire> (\x -> if x < 1 then 1 else self (x *(x - 1)))  -- factorial
18:43:40 <psykon> lol
18:43:42 <psykon> wtf?
18:43:48 <dmwit> That's what the y combinator is all about. =)
18:43:52 <dobblego> Y-combinator
18:44:09 <psykon> http://en.wikipedia.org/wiki/Lambda_calculus
18:44:12 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
18:44:13 <psykon> have fun
18:44:14 <dobblego> Haskell has fix
18:44:17 <dobblego> ?type fix
18:44:19 <lambdabot> forall a. (a -> a) -> a
18:44:23 <dolio> > fix (\self x -> if x <= 1 then 1 else self (x*(x-1))) 5
18:44:30 <lambdabot> Terminated
18:44:34 <dmwit> > fix (\f x -> if x < 1 then 1 else f (x - 1) * x) 5
18:44:35 <lambdabot>  120
18:44:39 <glen_quagmire> wouldn't it be handy though?
18:44:45 <dmwit> (You got the formula wrong, anyway. =)
18:44:46 <glen_quagmire> oh i see
18:44:49 <glen_quagmire> yah
18:45:08 <glen_quagmire> fix id 1
18:45:15 <dmwit> Terminated
18:46:02 <dmwit> Oops, after testing, I now want to say, "Exception: <<loop>>". =)
18:47:16 <litb> n-digit pandigital in what system?
18:47:30 <dmwit> litb: Base 10, please.
18:47:40 <litb> heh
18:47:48 <litb> u solved it?
18:47:52 <dmwit> Yeah.
18:48:07 <dmwit> The great bit is: you can do it *really* fast, even though it doesn't seem like you can.
18:48:12 <litb> well, looks like some of these brute force stuff..
18:48:23 <dmwit> *Main> time 41
18:48:26 <dmwit> 0.005843s
18:48:40 <gwern> Cale: if you want to see what I have, here: http://haskell.org/haskellwiki/Image:Quake.tar.gz
18:49:17 <thetallguy> dons: I was quite surprised that you dug up that quote.
18:50:30 <dmwit> ?hoogle String -> IO String
18:50:30 <lambdabot> System.Environment.getEnv :: String -> IO String
18:50:59 <dmwit> ?hoogle FilePath -> IO String
18:51:00 <lambdabot> Prelude.readFile :: FilePath -> IO String
18:51:00 <lambdabot> System.IO.readFile :: FilePath -> IO String
18:51:00 <lambdabot> Distribution.Simple.Utils.rawSystemStdout :: Verbosity -> FilePath -> [String] -> IO String
18:51:09 <litb> this would be my guess 7654321
18:51:24 <dmwit> Close, but that one isn't prime.
18:51:29 <litb> darn :/
18:51:36 <dmwit> I think you've got the important insight, though. =)
18:51:45 <litb> anyway, 9 and 8 are out of game, since we have /9 then
18:52:04 <dmwit> Yep!
18:52:20 <gwern> sometimes I wonder who you people are
18:52:38 <dmwit> In a good way, or a bad way?
18:54:12 <litb> shht i better solve it in private. will not steal your fun =)
18:54:15 <gwern> dmwit: is there any bad way to so wonder?
18:54:30 <dmwit> Sure. =)
18:54:57 * dmwit thinks . o O (I wonder if this gwern fellow is Hannibal Lecter or Hitler?)
18:55:29 <Pseudonym> Godwin's Law.  You lose.
18:55:50 * gwern bows. thank you, thank you. I'll be here all night 
18:56:15 <dons> thetallguy: and oldie, but a goodie :)
18:57:02 <dmwit> :t toLower
18:57:04 <lambdabot> Char -> Char
18:57:52 <gwern> 'Haskell will remain the headwaters for new ideas in programming languages, and ideas from Haskell and ML will continue seeping into popular programming languages like Ruby and Java, driven by a desire to "stem the tide" of the best programmers to functional languages. Also, there'll be continuing unrest in the mideast, and the sun will rise in the east and set in the west.' <-- sirius lol
18:58:44 <litb> how can i convert from floating to Int ?
18:58:50 <Pseudonym> I don't think it's a "stem the tide" issue.
18:59:01 <tenshx> litb: round, floor, ceiling
18:59:08 <Pseudonym> I don't know of any functional programmer who _also_ isn't fluent in some traditional or scripting language.
18:59:09 <wagle_home> truncate
18:59:20 <Pseudonym> More likely more than one.
18:59:40 <Adamant> and I know plenty of great programmers who have no interest in functional languages because they're not well adapted to their field.
18:59:41 <gwern> Pseudonym: I like the extended metaphor - headwaters, stem the tide, unrest etc
18:59:47 <wagle_home> there's a class that contains all the conversion, just cant think of the name
18:59:54 <Pseudonym> Well, yes.  It sounds almost apocalyptic.
19:00:24 <wagle_home> @index (Fractional x, Integral y) => x -> y
19:00:25 <lambdabot> bzzt
19:00:27 <litb> darn
19:00:32 <gwern> 'Just "eager Haskell" isn't enough. There are a lot of possible directions for such a language to go, and without being as far out as Epigram, for example, it's not entirely clear which direction would be most fruitful. In fact, a good successor to SML could just as easily take the crown here. Toss in Chakravarty et al.'s "modular type classes" and an otherwise more powerful type system, and you could have a really killer ML. On the ...
19:00:35 <litb> let isPrime a = and [ False | x <- [3 .. floor (sqrt (toRational a))] , a `mod` x == 0 ]
19:00:38 <gwern> ... other hand, a lot of what makes Haskell great is the personalities involved, and I don't know any way to replicate that.'
19:00:48 <litb> it don't want to work proper
19:01:04 <wagle_home> @index toIntegral
19:01:04 <lambdabot> bzzt
19:01:16 <wagle_home> @index (Fractional x) => x -> Integer
19:01:17 <lambdabot> bzzt
19:01:20 <wagle_home> @index (Fractional x) => x -> Int
19:01:21 <lambdabot> bzzt
19:01:38 <gwern> Pseudonym: and the great beast took the scroll, and scattered a hail of unsafePerformIOs upon the land, and for a time all was quiet. but then a plague of errors came forth to torment and kill 1/3 of the users, and the god these errors worshipped was the false god of efficiency...
19:01:45 <darrint> What happens if a Data instance has gunfold = error "" ?
19:01:46 <tenshx> litb: how could it give anything useful if the only thing returned in the array is False?
19:02:09 <litb> tenshx: it would return False
19:02:10 <dmwit> ?let naiveIsPrime n = all (\m -> n `mod` m > 0) . takeWhile (\x -> x * x < n) $ 2:[3,5..]
19:02:11 <lambdabot> Defined.
19:02:21 <dmwit> > naiveIsPrime 7654321 -- fast enough
19:02:22 <lambdabot>  False
19:02:32 <tenshx> litb: won't that always return false?
19:02:41 <litb> tenshx: no, i have a guard
19:02:41 <tehgeekmeister> what's a sane way to exit from main?  (with a 0 status code)
19:03:01 <nelhage> @hoogle exitWith
19:03:02 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
19:03:03 <wagle_home> :t main
19:03:04 <lambdabot> Not in scope: `main'
19:03:22 <litb> tenshx: it will return the empty list if a is prime
19:03:30 <dmwit> > and []
19:03:32 <lambdabot>  True
19:03:37 <tenshx> ahh, ok
19:03:41 <dmwit> litb: Did you perhaps forget that 2 is prime?
19:03:45 <thetallguy> dons: actually, it didn't go over big in that talk. Perhaps a little too subtle for a live talk.  Not sure.
19:04:08 <litb> dmwit: it was a silly try anyway
19:04:19 <litb> i wanted to test every odd number as a devisor
19:04:31 <dmwit> litb: Right, what went wrong?
19:04:32 <litb> but i think i only have to test every prime . i don't know why tho
19:04:39 <dmwit> litb: It looks fairly reasonable to me.
19:04:41 * Pseudonym heads off to find some food
19:04:43 <litb> dmwit: the conversion to Integer failed
19:05:01 <gwern> dons: 'I was really impressed with demos from the book "OCaml for Scientists" by Jon Harrop, however the price tag was too high, so I ended up getting it through inter library loan for the period 3 weeks.'
19:05:13 * gwern suspect dons will feel a little schadenfreude there
19:05:22 <tenshx> litb: either way I'd go with [3, 5 .. floor (sqrt (toRational a))]
19:05:32 <litb> but aht one failed
19:05:33 <tenshx> to halve the number
19:05:34 * ddarius suspects dons has better things to do
19:05:42 <dmwit> :t floor
19:05:43 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
19:05:44 <tenshx> s
19:05:51 <dmwit> :t sqrt
19:05:52 <lambdabot> forall a. (Floating a) => a -> a
19:05:56 <dmwit> :t mod
19:05:57 <lambdabot> forall a. (Integral a) => a -> a -> a
19:05:58 <dmwit> huh
19:05:59 <tenshx> geez, tired now... gonna hit the bed
19:05:59 <tenshx> nn
19:06:04 <gwern> ddarius: dons seems to have a real think about jdh
19:06:18 <gwern> I though it'd amuse him. if it doesn't, it doesn't
19:06:41 <dmwit> :t toRational
19:06:42 <lambdabot> forall a. (Real a) => a -> Rational
19:06:53 <litb> even floor failed
19:06:58 <dmwit> > floor (3%5)
19:06:59 <lambdabot>  0
19:07:01 <dons> gwern: oh, but we've got the book online! (is that what you were thinking of?)
19:07:11 <dmwit> > sqrt (3%5)
19:07:13 <lambdabot>   add an instance declaration for (Floating (Ratio t))
19:07:13 <lambdabot>     In the expression:...
19:07:18 <dmwit> That's why. =)
19:07:18 <gwern> dons: I have no idea
19:07:19 <litb> > [1.. floor (sqrt 1)]
19:07:20 <lambdabot>  [1]
19:07:24 <litb> oh, hmm
19:07:30 <dmwit> litb: You have a toRational in there...
19:07:38 <dmwit> litb: Try fromIntegral or so.
19:07:49 <litb> "Ambiguous type variable `t' in the constraints:"
19:08:10 <dmwit> That's more like it!  That can be fixed with judicious type annotations.
19:08:18 <cjb> (Does anyone feel like explaining why fix is necessary to me?  It looks like the standard non-fix recursive factorial defn to me.  Is it just because it's an anonymous function?)
19:08:55 <dmwit> cjb: It isn't really necessary, since we already have named recursion.
19:08:56 <wagle_home> @index Double -> Int
19:08:57 <lambdabot> bzzt
19:09:14 <dmwit> cjb: But Haskell was built by academics, so expect a few academic things. =)
19:09:36 <dons> fix appeared in the MonadFix paper, iirc. but its generally kinda cute
19:09:37 <dmwit> cjb: (fix is the way to create named recursion if you don't have it explicitly supported by the language.)
19:10:07 <litb> hm
19:10:41 <cjb> dmwit: Ah, that makes sense.  Thanks.
19:10:57 <wagle_home> > (fix \f -> \n -> if (n == 0) then 1 else n * f (n -1)) 5
19:10:58 <lambdabot>  Parse error at "\f" (column 6)
19:11:07 <wagle_home> > (fix $ \f -> \n -> if (n == 0) then 1 else n * f (n -1)) 5
19:11:09 <lambdabot>  120
19:11:24 <wagle_home> :t fix
19:11:25 <lambdabot> forall a. (a -> a) -> a
19:12:04 <dmwit> cjb: Incidentally, it is named "fix" because it calculates the least-fixed point of any function, where _|_ is considered "less" than any other value.
19:12:16 <LoganCapaldo> for I am become fixpoint, ender of functions
19:12:25 <ddarius> >fix (1:)
19:12:30 <ddarius> > fix (1:)
19:12:32 <dmwit> err... *least fixed-point, my hyphenation is off
19:12:35 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:12:52 <litb> @let isPrime a = and [ False | x <- [3, 5 .. floor (sqrt a)] , a `mod` x == 0 ]
19:13:07 <lambdabot> Defined.
19:13:12 <litb> > isPrime 7
19:13:25 <lambdabot>  Add a type signature
19:13:27 <litb> that's the error i get. strange
19:13:38 <dmwit> :t isPrime
19:13:39 <lambdabot> Not in scope: `isPrime'
19:13:41 <wagle_home> @src fix
19:13:41 <lambdabot> fix f = let x = f x in x
19:13:45 <dmwit> > isPrime
19:13:50 <lambdabot>  Add a type signature
19:13:58 <dmwit> > (isPrime :: Integer -> Bool) 7
19:13:59 <lambdabot>        add an instance declaration for
19:13:59 <lambdabot>       (Floating Integer, RealFrac Inte...
19:14:02 <LoganCapaldo> > isPrime :: ()
19:14:03 <lambdabot>  Couldn't match expected type `()' against inferred type `a -> Bool'
19:14:16 <dmwit> litb: Can't take sqrt of an Int[eger]. ;-)
19:14:21 <gwern> @remember LoganCapaldo for I am become fixpoint, ender of functions
19:14:21 <lambdabot> Done.
19:14:26 <gwern> @quote LoganCapaldo
19:14:26 <lambdabot> LoganCapaldo says: that makes perfect sense. I hate you
19:14:33 <gwern> @quote LoganCapaldo
19:14:33 <lambdabot> LoganCapaldo says: for I am become fixpoint, ender of functions
19:14:36 <LoganCapaldo> > isPrime 7.0
19:14:36 <lambdabot>  Add a type signature
19:14:49 <LoganCapaldo> > isPrime (7.0 :: Double)
19:14:49 <lambdabot>   add an instance declaration for (Integral Double)
19:14:50 <lambdabot>     In the expression: is...
19:14:55 <LoganCapaldo> ooooo
19:14:57 <LoganCapaldo> hehhe
19:15:09 <dmwit> litb: Needs moar fromIntegral...
19:15:10 <LoganCapaldo> sqrt _and_ mod
19:15:17 <LoganCapaldo> madnesss
19:15:24 <dmwit> > naiveIsPrime 7 -- bwahahaha
19:15:35 <lambdabot>  True
19:15:44 <litb> ah thanks
19:16:09 <LoganCapaldo> or more floor
19:16:16 <dmwit> There's a lot of 'i's in divisibility.
19:16:30 <dmwit> Nearly half of the letters are 'i'!
19:16:44 <LoganCapaldo> > sum (filter (== 'i') "divisibility")
19:16:45 <dobblego> > intersperse 'i' "dvsblty"
19:16:45 <lambdabot>   add an instance declaration for (Num Char)
19:16:45 <lambdabot>     In the expression: sum (filt...
19:16:45 * ddarius desires a smooth resonant singable song.
19:16:46 <lambdabot>  "divisibilitiy"
19:17:06 <wagle_home> its a set of letters, half of which are i...  whats the other one?
19:17:06 <LoganCapaldo> > length (filter (== 'i') "divisibility")
19:17:07 <lambdabot>  5
19:17:23 <dmwit> wagle_home: heh
19:17:26 <litb> @undefine
19:17:33 <lambdabot> Undefined.
19:17:36 <litb> @let isPrime a = and [ False | x <- [3 .. floor $ sqrt $ fromIntegral a] , a `mod` x == 0 ]
19:17:38 <lambdabot> Defined.
19:17:45 <litb> > isPrime 7
19:17:46 <lambdabot>  True
19:17:52 <litb> just to prove it works :)
19:18:06 <litb> but yours is waay nicer dmwit
19:18:06 <catface> "indivisibility"
19:20:45 <lekro> > isPrime 10
19:20:49 <lambdabot>  True
19:20:54 <BMeph> Needs more cowbell.
19:22:01 <LoganCapaldo> > let count elem = foldr (\x y -> (fromEnum (x == elem)) + y) 0 in count 'i' "divisibility"
19:22:04 <lambdabot>  5
19:22:19 <LoganCapaldo> > let count elem = foldr (\x y -> (fromEnum (x == elem)) + y) 0 in count 'i' "indivisibility"
19:22:19 <lambdabot>  6
19:22:22 <litb_> dmwit: well, i found it too. too easy for 41 :)
19:22:30 <dmwit> litb_: yep =)
19:23:31 <litb_> > product [1..7]
19:23:32 <lambdabot>  5040
19:25:08 <LoganCapaldo> @type let count elem = foldr (\x y -> (fromEnum (x == elem)) + y) 0 in count
19:25:11 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
19:25:27 <LoganCapaldo> @type let count elem = foldr (\x y -> (fromIntegral $ fromEnum (x == elem)) + y) 0 in count
19:25:28 <lambdabot> forall a b. (Eq a, Num b) => a -> [a] -> b
19:31:14 <gwern> @hoogle runState
19:31:15 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
19:31:15 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
19:31:15 <lambdabot> Control.Monad.State.Lazy.runStateT :: StateT s m a -> s -> m (a, s)
19:34:23 <wagle_home> > product [1..4000000000]
19:34:35 <lambdabot> Terminated
19:34:46 <wagle_home> > (fix $ \f -> \n -> if (n == 0) then 1 else n * f (n -1)) 4000000000
19:34:49 <lambdabot>  Exception: stack overflow
19:36:13 <wagle_home> > (fix $ \f -> \n a -> if (n == 0) then a else f (n -1) (a * n) 4000000000 1
19:36:14 <lambdabot> Unbalanced parentheses
19:36:29 <wagle_home> > (fix $ \f -> \n a -> if (n == 0) then a else f (n -1) (a * n)) 4000000000 1
19:36:35 <lambdabot> Terminated
19:36:41 <wagle_home> boo hoo
19:37:32 <BMeph> wagle_home: Try using a tuple for a & n.
19:37:41 <tehgeekmeister> how would i pattern match a list of three or more elements?
19:37:54 <tehgeekmeister> would (x:y:rest) work?
19:38:06 <dobblego> sure
19:38:13 <kpreid> that's a list of two or more
19:38:15 <dobblego> x:y:z:rest for three or more
19:38:31 <wagle_home> > (fix $ \f -> \(n,a) -> if (n == 0) then a else f (n -1, a * n)) (4000000000,1)
19:38:38 <lambdabot> Terminated
19:42:25 <dolio> Using a tuple isn't going to make 4 billion multiplies fast. :)
19:42:26 <gnuvince_> I'm listening to the .NET Rocks pod cast featuring SPJ; is it just me or do the hosts seem *really* confused at the beginning of the cast?
19:42:34 <gnuvince_> (I haven't listened further yet)
19:42:45 <hpaste>  tehgeekmeister pasted "Question about how to generalize part of my main." at http://hpaste.org/5593
19:43:31 <tehgeekmeister> oh dear, it truncated the part i'm interested in...
19:43:35 <tehgeekmeister> *updates
19:44:58 <dons> gnuvince_: they're super confused
19:45:25 <dons> but points for getting SPJ on!
19:46:12 <Cale> "Object oriented languages like Prolog."
19:46:20 <ddarius> That really gets Cale.
19:46:22 <inimino> haha
19:46:23 <Cale> heh
19:46:32 <hpaste>  tehgeekmeister pasted "Repost, truncated to fit hpaste." at http://hpaste.org/5594
19:46:35 <dolio> Hahaha.
19:46:37 <Cale> I just found it pretty funny.
19:46:56 <gnuvince_> dons: ok :)  I think he sort of got his point across with the chess moves tree example
19:47:34 <dons> its an interesting example of how far removed from the mainstream programming we are..
19:47:36 <Twey> "Training developers to work smarter..." ow :<
19:47:55 <Cale> haha, I thought that sounded kind of funny too :)
19:48:06 <Twey> Whenever you use an adverb as an adjective, another kitten dies :-P
19:48:15 <Twey> Vice versa, rather
19:48:24 <gwern> OpenSSL/Digest.hs:81:0:
19:48:25 <gwern> Can't make a derived instance of `Typeable DigestState' (even with cunning newtype deriving:) In the newtype declaration for `DigestState'
19:48:28 <gwern>  <-- hah
19:48:30 <inimino> was it followed by "not harder"?
19:48:42 <dobblego> gnuvince_, do you have a direct link to it?
19:48:54 <ddarius> dobblego: It's in the topic.
19:48:58 <dobblego> ah
19:49:49 <gnuvince_> dons: either an example of how far removed we are, or how uninformed the mainstream is.
19:50:14 <gnuvince_> I don't mean to say that uninformed is bad
19:50:16 <wagle_home> where's this spj video?
19:50:33 <ddarius> Cale, do you knit or crochet?
19:50:49 <Cale> ddarius: nope
19:50:56 <gnuvince_> wagle_home: topic
19:51:05 <ddarius> Cale: You should give it a go some time.  I suspect you'd find it interesting.
19:51:06 <LoganCapaldo> and it's not a video
19:51:11 <LoganCapaldo> it's an audio
19:51:12 <dons> CS education fails on programming languages
19:51:20 <dons> which kind of sucks
19:51:21 <zbrown> dons: I agree
19:51:31 <ddarius> dons: Java is a programming language.
19:51:33 <zbrown> dons: seeing as I'm in one currently :)
19:51:34 <Twey> I noticed this
19:51:35 <Adamant> how so?
19:51:44 <dons> ddarius passes CS101.
19:51:50 <Adamant> I'm getting to use Haskell in my Comparative Languages class
19:51:54 <Twey> I dropped out of one recently :-P
19:51:58 <dons> Adamant: oh thats good.
19:52:06 <zbrown> Adamant: you're in a rare and lucky situation
19:52:14 * Twey nods.
19:52:18 <dons> i'm not sure comparative languages is that great though, as a course. 'programming language theory and practice' would be better
19:52:25 <dons> rather than a grab bag of 'here's some weird languages'
19:52:34 <Adamant> that's how it's being done
19:52:35 <dons> teach the underlying, unifying concepts
19:52:39 <dons> oh good
19:53:00 <Adamant> you get basic introduction to compiler and language theory
19:53:01 <dons> the underlying concepts of programming languages, that which unifies them all, is what's not taught
19:53:04 <ddarius> dons, we all know syntax is the only difference between languages.
19:53:09 <dons> heh
19:53:14 <cjb> I heard at cs.nott.ac.uk they just teach you Java.  So then you get to the third year compilers course, and you write a compiler.. in Java.
19:53:28 <zbrown> I've got some independent study I'm doing for compiler design & implementation as well as programming languages (mostly functional work)
19:53:33 <dons> for a mini version of Java, cjb ? :)
19:53:56 <dolio> cjb: Do they use Modern Compiler Implementation in Java?
19:53:59 <dolio> That book is awesome.
19:54:13 <ddarius> dolio: Considering the author, it damn well better be.
19:54:33 <LoganCapaldo> don't judge a book by it's author
19:54:37 * gwern uploads another package. dum de dum. it's one way to kill an evening, at least
19:54:40 <LoganCapaldo> s/'//
19:54:41 <dolio> Yeah, well...
19:54:42 <gwern> LoganCapaldo: not even if it's by Knuth?
19:54:47 <Adamant> dons: that's what you get when your teacher is a type theory and formal methods geek
19:54:54 <dons> yay!
19:55:01 <dolio> I should go back and read it without looking at the code.
19:55:04 <dons> gwern: awesome work.
19:55:07 <BMeph> gwern: ESPECIALLY if it's written by Knuth. ;)
19:55:22 <dons> gwern: i've got the complete announcement backlog of haskell@ to 1990, if you want to work your way back through time
19:55:22 <gwern> dons: eh. someone else wrote the code. I only wish I could be so productive
19:55:26 <dons> till everything's uploaded
19:55:30 <dons> gwern: no, its important work
19:55:30 <dolio> The code is absolutely heinous, though, as I recall, because it's ML translated to Java.
19:55:46 <dons> dolio: yeah, i've heard simliar from java/compiler guys
19:56:03 <gwern> BMeph: wait, I think you missed my point that Knuth is so good you hae to automatically assume his books are awesome, ehnce the generalization fails
19:56:11 <gwern> dons: sure, send me it
19:57:52 <LoganCapaldo> judge a book by it's contents. And then judge the author by the book.
19:57:55 <dons> gwern: you could start at http://haskell.org/haskellwiki/News/2006 and work backwards
19:57:58 <LoganCapaldo> s/'//
19:58:18 <LoganCapaldo> I keep typing it's.
19:58:31 <LoganCapaldo> its very disheartening
19:58:52 <gwern> dons: :(
19:58:56 <dons> gwern: ?
19:59:08 <ddarius> LoganCapaldo: Judging a book by its contents doesn't help me decide which book to buy.
19:59:13 <dons> well, at least its a complete list. i trawled the mailing list for ages to collect it all :)
20:00:33 <gwern> dons: I thought it would entail more work by you than me, but I suppose it is better than going through the ml archives, yes
20:01:01 <gwern> (oh lovely, this file wants packedstring)
20:01:12 <LoganCapaldo> ddarius: I usually go by the covers for the buying decisions
20:01:22 <LoganCapaldo> "oooo shiny!"
20:01:31 <gwern> whatever happened to packedstring anyway?
20:01:35 * LoganCapaldo plonks  down 30 bucks
20:03:02 <gwern> @where mapToUpper
20:03:03 <lambdabot> I know nothing about maptoupper.
20:03:09 <gwern> @where toUpper
20:03:09 <lambdabot> I know nothing about toupper.
20:03:18 <gwern> @hoogle toUpper
20:03:19 <lambdabot> Data.Char.toUpper :: Char -> Char
20:03:26 * ddarius currently owns exactly two "technical" books, one of which he bought for 50 cents.
20:03:51 <shapr> heh
20:03:56 <shapr> My raisin is over now.
20:03:59 <LoganCapaldo> I currently own too many books
20:04:07 <shapr> Six hours is a pretty long raisin.
20:04:11 <LoganCapaldo> or not enough
20:04:41 * ddarius can't decipher shapr's crazy new Yankee speak.
20:04:42 <kpreid> Among the things which Haskell can express rather neatly:
20:04:45 <kpreid> forwardDifference xs = zipWith (-) (tail xs) xs
20:04:55 <shapr> Attractive woman with a master's in CS, had heard of Haskell and was amazed that I had a job doing that.
20:05:28 <ddarius> kpreid: Most signal processy algorithms map very slickly into lazy streams.
20:05:31 <Twey> Hah, these people have no idea about CS theory in general :-\
20:05:38 <Twey> "Thunks?  What're those?"
20:06:23 <ddarius> shapr: "raisin"?
20:06:45 <dons> shapr: awesome :)
20:07:09 <LoganCapaldo> i thought it was crepes
20:07:38 <shapr> It was crepes actually, and I thought I was on #haskell-blah when I said this, oops
20:07:42 * shapr blushes
20:07:50 <wagle> LoganCapaldo, this shiny enough for you?: http://www.amazon.com/exec/obidos/tg/detail/-/1402055862/ref=ord_cart_shr?%5Fencoding=UTF8&m=ATVPDKIKX0DER&v=glance
20:07:51 <lambdabot> http://tinyurl.com/ywrua7
20:08:16 <LoganCapaldo> wheres teh refletive hologram badge?
20:09:07 <Pseudonym> Hey.  http://hackage.haskell.org/packages/archive/value-supply/0.1/doc/html/Data-Supply.html
20:09:09 <lambdabot> http://tinyurl.com/2br6aj
20:09:18 <Pseudonym> Does that look almost like a comonad to everyone else?
20:09:52 <LoganCapaldo> sure, why not
20:10:57 <ddarius> Pseudonym: At least one of the unital laws seems like it would hold.
20:11:32 <gwern> gott ver dammt! 'Couldn't match expected type `GHC.Word.Word8'
20:11:32 <gwern> against inferred type `Char'
20:11:32 <gwern> >.< they're the same thing, are they not?
20:11:33 <Pseudonym> Does anyone have a copy of the paper?
20:11:48 <dolio> counit = split, cobind = modifySupply?
20:11:57 <gwern> @hoogle Word8 -> Char
20:11:57 <lambdabot> Data.ByteString.Internal.w2c :: Word8 -> Char
20:11:59 <dolio> Er, wait, no.
20:12:03 <dons> Pseudonym: hmm.
20:12:10 <dolio> counit = supplyValue
20:12:10 <dons> Pseudonym: interesting idea.
20:12:15 <Pseudonym> extract = supplyValue
20:12:16 <ddarius> gwern: No
20:12:31 <Pseudonym> extend = flip modifySupply
20:12:45 <wagle_home> Pseudonym, which paper?
20:12:57 <Pseudonym> wagle_home: The paper mentioned in the Haddock.
20:13:13 <ddarius> Pseudonym: I tried to find it a few years ago to no avail.
20:13:16 <gwern> :t Data.Char.toUpper
20:13:18 * Pseudonym nods
20:13:23 <lambdabot> Char -> Char
20:13:34 <ddarius> Isn't in the ACM or something though?
20:13:39 <Pseudonym> Nope.
20:13:42 * Pseudonym checked already
20:14:03 <ddarius> So we need to beat augustss
20:14:07 <gwern> @hoogle Char -> Word8
20:14:08 <lambdabot> Data.ByteString.Internal.c2w :: Char -> Word8
20:14:26 <Pseudonym> Indeed.  Not for that reason, it just sounds like a good idea to beat him.
20:15:36 <Pseudonym> This, BTW, suggests ComonadSplit as a dual to MonadPlus.
20:16:56 <LoganCapaldo> > let n = fromEnum 'a' in toEnum n :: Word8
20:16:59 <lambdabot>  97
20:17:19 * LoganCapaldo has no idea if that's wise
20:18:15 * Pseudonym drops an email to Iavor
20:20:56 <LoganCapaldo> @let c2w x = toEnum (fromEnum (x :: Char)) :: Word8
20:20:57 <lambdabot> Defined.
20:21:05 <LoganCapaldo> > c2w
20:21:06 <lambdabot>  <Char -> Word8>
20:21:27 <dolio> > c2w '\257'
20:21:28 <lambdabot>  Exception: Enum.toEnum{Word8}: tag (257) is outside of bounds (0,255)
20:21:39 <LoganCapaldo> right
20:21:40 <wagle_home> hmm..  i think i have that somewhere in 15 boxes of papers
20:21:50 <LoganCapaldo> bu that's ok
20:22:29 <LoganCapaldo> it's the same problem you have with Int -> Char8
20:22:48 <LoganCapaldo> > fromIntegral 20013 :: Word8
20:22:49 <lambdabot>  45
20:22:58 <LoganCapaldo> s/Char8/Word8/
20:23:03 <LoganCapaldo> oh that's interesting
20:25:11 * ddarius considers making a Mobius strip scarf.
20:25:45 <Twey> Haha
20:25:52 <wagle_home> nono..  make a klein bottle sweater
20:25:57 <LoganCapaldo> would you sell it to me?
20:26:05 <Pseudonym> Logan: You apply within.
20:26:13 <ddarius> LoganCapaldo: I never wear scarves, so...
20:26:13 <Twey> It's actually a Möbius/Moebius strip
20:26:16 <Twey> Pseudonym, hahaha
20:26:35 <ddarius> wagle_home: Klein bottle caps are not uncommon.
20:27:10 <gwern> @hoogle runState
20:27:10 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
20:27:10 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
20:27:10 <lambdabot> Control.Monad.State.Lazy.runStateT :: StateT s m a -> s -> m (a, s)
20:28:44 <Twey> SPJ pronounces -> as "arrow" :-\
20:28:57 * Twey says "to."
20:29:43 <dons> gwern: where are the updated tarballs getting hosted?
20:29:59 <gwern> dons: updated tarballs of what?
20:30:04 <dons> you're basically finding distributable tgz's, adding cabal files, and then uploading?
20:30:07 <dons> of the new stuff on hackage
20:30:17 <gwern> dons: I
20:30:23 <gwern> am working from the darcs repos more often
20:30:35 <dons> ah ok. so do you send the patches back to the author?
20:30:50 <gwern> but if course
20:30:50 <dons> eventually you'll reach a point before darcs was common :)
20:30:59 <dons> cool. keep up the good work.
20:31:04 <gwern> dons: I already have with QuakeHaskell - CVS ftl
20:31:15 <dons> yeah, i saw that. awesome stuff.
20:31:18 <dons> i thought that was lost
20:31:25 <gwern> (the tarball of that one I just stuck on the wiki because I'm not sure it's salvageable)
20:31:38 <dons> cvs is a blackhole for code
20:32:15 <ddarius> Once the new generation of RCSes came along, people moved quickly.
20:32:52 <dons> yeah.
20:33:26 <gwern> quakehaskell I don't find terribly interesting though - the core was in C, yech
20:34:38 <BMeph> Twey: It sounds to me like SPJ pronounces it "awwow". ;)
20:34:51 <Twey> Well, yes :-P
20:34:53 <catface> @src ap
20:34:53 * inimino wonders if these two interviewers are representative of typical .NET guys
20:34:53 <lambdabot> ap = liftM2 id
20:35:02 <Twey> inimino: Yes.
20:35:12 <Twey> Well
20:35:48 <Twey> The average .NET programmer has probably never used anything outside the VB family :-P
20:35:55 <inimino> heh
20:36:25 * ddarius uses .NET at work.
20:36:26 <shapr> My recent experiences on ##csharp reinforce the idea that .NET programmers don't have wide-ranging programming experience.
20:36:29 <adu> i didn't even know there was a VB family...
20:36:49 <LoganCapaldo> unless C# is part of the vb family I doubt that very much. from what I understand most vbes do not want vb.net
20:36:55 <gwern> LOLITA is proving hard to track down. the links seem to be dead, the contact email liekwise. hm.
20:37:00 <LoganCapaldo> s/vbes/vbers/
20:37:13 <adu> gwern: what is LOLITA?
20:37:45 <gwern> adu: https://secure.wikimedia.org/wikipedia/en/wiki/LOLITA
20:38:53 <gwern> 'Durhamâs LOLITA system (Large-scale, Object-based, Linguistic Interactor, Translator and Analyzer) was developed by Garigliano and colleagues at the University of Durham (UK) between 1986 and 2000. It was designed as a general-purpose tool for processing'
20:39:49 <shapr> gwern: I haven't seen any activity from LOLITA in many years. Same for the InForM project.
20:39:51 <Twey> gwern: "... and 2000" -- it's dead
20:40:00 <Twey> As of 2000
20:40:01 <shapr> gwern: But there have been large Haskell projects like those.
20:40:12 <gwern> shapr: I'm interested in what source can be salvaged
20:40:28 <gwern> the haskell history paper mentions a 'Grammatical Framework' under GPL tho
20:40:41 <shapr> Probably not much, I failed to build InForM after days of code cleanup, and that was years ago.
20:40:48 <shapr> @where GF
20:40:48 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
20:40:56 <dons> yeah, that's still kicking along
20:40:58 <shapr> That's the Grammatical Framework.
20:41:12 <shapr> gwern: Interested in any other old projects? Seen the Smalltalk <-> Haskell binding?
20:41:27 <dons> shapr: oh? i've seen the smalltalk /implementation/ in haskell, but that's new
20:41:40 <gwern> shapr: sounds interesting. can't hurt to take a look
20:42:10 <shapr> The Smalltalk <-> Haskell binding is ancient, Jan Skibinski was the author, iirc.
20:42:24 <dons> huh.
20:42:30 <dons> a lot of his stuff is hard to track down
20:42:49 <gwern> http://portal.acm.org/citation.cfm?id=1159858 <-- what is GenI? anyone heard of it before?
20:42:50 <lambdabot> Title: GenI
20:43:41 <shapr> gwern: I do agree, it would be nice to track down any OSS-licensed code and clean it up and hackage it.
20:44:55 <gwern> I think I'm going to have to give up on lolita. can't find any current email address for Richard G. Morgan
20:45:27 <gwern> it's like he vanished in '99
20:45:57 <gwern> (even the durham website has nothing on him!)
20:46:00 <shapr> iirc, the LOLITA source was closed & proprietary.
20:46:19 <dmwit> Wow, J has very, very short code.
20:46:41 <gwern> shapr: as far as I've been able to find out., yes, but a lot of code gets opensourced when it's end of lifed
20:46:45 <shapr> True
20:46:57 <shapr> dmwit: Yeah, but J isn't as general as Haskell, imho.
20:46:58 <gwern> dmwit: it's pretty impressive, isn't it? I've occasionally wondered how haskell could get some of that
20:47:25 <dmwit> Impressive, yes.  I'm not sure I want that though.
20:47:38 <LoganCapaldo> I kinda want it
20:47:48 <dmwit> Of course, I can't have a very well-informed opinion until I try it. ;-)
20:47:58 <Cale> J has very short code in part because most things are named with a single letter.
20:48:11 <LoganCapaldo> I feel like if I were fluent in J or K I'd be a better programmer overall
20:48:14 <dolio> It could get some of it by naming every function with a single letter, and eliminating all white space. :)
20:48:21 <LoganCapaldo> or at least a more creative one
20:48:31 <Twey> Heh
20:48:39 <LoganCapaldo> "Hmm, how can I couch this in terms of operations on arrays?"
20:50:03 <gwern> http://wiki.loria.fr/wiki/GenI/Getting_GenI
20:50:04 <lambdabot> Title: GenI/Getting GenI - Loria Wiki
20:50:21 <Cale> One notation of Iverson's which I really like is the Iverson bracket.
20:51:01 <dolio> gwern: If you're looking for something to package, you could try category extras.
20:51:08 <LoganCapaldo> Cale: what's dat?
20:51:13 <dolio> gwern: So the people talking abou comonads earlier would have some package to use.
20:51:21 <gwern> dolio: why? they're already on hackage right?
20:51:49 <gwern> looks like GenI already is cabalized
20:51:50 <Cale> If P is any predicate, then [[P]] is 1 if P is true, and 0 otherwise.
20:52:25 <LoganCapaldo> ah ok
20:52:27 <dons> yeah, the comonad one is an obvious candidate
20:52:31 <dons> its haddockised too
20:52:39 <shapr> gwern: Is Oleg's ZipperOS code cabalized?
20:52:58 <gwern> shapr: I intend to; I've already cleaned it up
20:52:58 <dons> the comonad package could be used a fair bit more widely. and we've a canonical implementation
20:53:03 <shapr> ah, spiffy!
20:53:04 <dons> did you find that, gwern ?
20:53:13 <gwern> dons: comonad or zfs?
20:53:17 <dons> comonad
20:53:21 <gwern> (this conversation can be confusing at times)
20:53:28 <dons> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
20:53:31 <gwern> dons: I've had nothing to do comonads, sry
20:53:38 <dons> http://www.eyrie.org/~zednenem/2004/hsce/
20:53:38 <gwern> at least, I don't think so
20:54:31 <dmwit> > (-10 `mod` 12, (-10) `mod` 12) -- a very hard bug to track down
20:54:46 <lambdabot>  thread killed
20:55:07 <dons> oh heh
20:55:15 <dons> yeah, negative numbers should have a different type
20:56:02 <gwern> http://www.eyrie.org/~zednenem/2004/07/26/hsce <-- hm
20:56:02 <lambdabot> Title: ZedneWeb: Category extras
20:56:15 <Cale> Numbers modulo an integer should have a different type ;)
20:56:20 <gwern> 'Not that it would do anyone much good. I mean, how often do you need to use a comonad?' <-- hee hee
20:57:18 <dolio> More often than you're likely to realize you're writing a g-histomorphism, I'd say.
20:57:19 <Cale> I think we haven't really explored the space of comonads deeply enough. We have a pretty good handle on what monads are about now.
20:57:25 <adu> so I tried recompiling GHC with the --enable-objectio, then someone told me this was only for Windows, and since I'm on a mac I disabled it, and recompiled GHC again, and the nehe-tuts for HOpenGL still don't work
20:57:31 <ddarius> Cale: They do, Int, Integer, Word32, ...
20:57:37 <Cale> ddarius: :)
20:58:28 <gwern> oh god, GenI has an elaborate Setup.lhs. wonderful, just wonderful
21:00:15 <dons> well, take the low hanging fruit first
21:00:21 <Cale> What's wrong with that? Isn't that what Cabal was designed for?
21:00:36 <dons> generally breaks with cabal changes
21:00:41 <Cale> ah
21:00:42 <gwern> Cale: because the cabal api keeps changing...
21:01:09 <Cale> What is GenI?
21:01:30 <gwern> Cale: natural language thingamagig
21:01:32 <Cale> And, does its author watch Stargate Atlantis? :)
21:02:14 <dolio> @vixen What do you think of Kurt Russell?
21:02:15 <lambdabot> maybe. do you?
21:02:19 <gwern> don't laugh; I know a Geni on Wikipedia. darn good editor/admin
21:03:51 <gwern> Cale: http://portal.acm.org/citation.cfm?id=1159858
21:03:54 <lambdabot> Title: GenI
21:04:16 <dmwit> ?src Num
21:04:16 <lambdabot> class  (Eq a, Show a) => Num a  where
21:04:16 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:04:16 <lambdabot>     negate, abs, signum     :: a -> a
21:04:16 <lambdabot>     fromInteger             :: Integer -> a
21:04:49 <gwern> wxhaskell tried to pull in ghc 6.4 on gentoo? wtf
21:07:54 <adu> wait, lesson04 works
21:07:59 <adu> YEY!
21:08:04 <adu> one of the nehe-tuts works!
21:08:35 <adu> i never compiled lesson04 before, so maybe I just need to recompile lessons1-3
21:09:52 <wagle_home> ?src Real
21:09:52 <lambdabot> class  (Num a, Ord a) => Real a  where
21:09:53 <lambdabot>     toRational      ::  a -> Rational
21:10:08 <ddarius> Impressive, isn't it.
21:10:40 <dmwit> Real-ly.
21:11:15 <Cale> Not even toRational :: Integer -> a -> Rational
21:11:28 <adu> I do not like the names for haskell numeric classes
21:12:24 <dmwit> Most people have worse complaints than just about the names.
21:13:04 <Cale> The main things which bother me are just the fact that Num has signum and abs in it, and that Eq and Show are superclasses of it.
21:13:42 <Cale> The rest, I don't mind all that much. Calling that class "Real" is kind of silly though.
21:14:07 <ddarius> class Imaginary a where ...
21:14:16 <Cale> It would be a more appropriate name if toRational took a parameter corresponding to the desired precision.
21:14:23 <wagle_home> ?src complex
21:14:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:14:27 <Cale> ?src Complex
21:14:28 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
21:15:07 <shachaf> @seen gwern
21:15:07 <lambdabot> gwern is in #xmonad, #haskell and #darcs. I last heard gwern speak 10m 18s ago.
21:15:51 <adu> imho (s/Real/Rationable/, s/RealFrac/Roundable/, s/RealFloat/Floating, s/Floating/Real/)
21:16:10 <adu> that would make more sense
21:17:24 <sarehu> @let le = id
21:17:26 <lambdabot> Defined.
21:17:40 <sarehu> > 2 + le sin pi
21:17:43 <lambdabot>  2.0
21:20:04 <dmwit> > let o =<< v = v >>= o in const "dbqppqdb" =<< "ovxvo"
21:20:06 <lambdabot>  "dbqppqdbdbqppqdbdbqppqdbdbqppqdbdbqppqdb"
21:20:57 <Festering_Hate> Hello everyone.
21:21:12 <Cale> hello
21:21:19 <Festering_Hate> What's going on?
21:21:23 <sarehu> let (la,of)=(id,id) in     le 2 + le sin (of 3) / 5
21:21:36 <sarehu> > let (la,of)=(id,id) in     le 2 + le sin (of 3) / 5
21:21:36 <lambdabot>  Parse error at "of)=(..." (column 9)
21:21:41 <sarehu> oh, bah.
21:21:51 <sarehu> jerks with their keywords
21:22:03 <Cale> Not a whole lot.
21:22:22 <dmwit> > let (la, of) = (id, id) in le 2 + le sin (of 3) / 5
21:22:22 <lambdabot>  Parse error at "of)" (column 10)
21:22:25 <Festering_Hate> That's cool.
21:22:34 <Cale> Festering_Hate: Learning Haskell?
21:22:40 <Festering_Hate> Cale: Yep.
21:23:00 <Festering_Hate> I started actually tonight, but I'm grasping it pretty quickly. I'm enjoying it. It's pretty fun to play with too.
21:23:12 <Cale> Cool. Let us know if you have any questions. :)
21:23:17 <Festering_Hate> Thanks :)
21:23:34 <Festering_Hate> I actually do have a question. Are there normal conditional loops, like in C++?
21:23:46 <Festering_Hate> I'm aware of do {}, but other than that, could you enlighten me?
21:23:51 <sarehu> no, but there are functions that do the same thing.
21:23:56 <Cale> do {} doesn't produce a loop
21:24:01 <Festering_Hate> I know that.
21:24:05 <Cale> But you can write functions which do.
21:24:27 <adu> Festering_Hate: I'm learning too, so far I know about 'do', 'case', 'let', monads, arrows, and I'm still learning about the difference between 'type' and 'newtype'...
21:24:50 <adu> Festering_Hate: but if you need help, I might be able to
21:24:51 <shachaf> adu: type is just a type alias.
21:24:59 <Cale> Well, there's a 'foreach' style loop already implemented in Control.Monad. It's called forM
21:25:11 <adu> shachaf: isn't that what newtype does?
21:25:13 <Cale> (also, mapM, which is the same thing with the args flipped)
21:25:14 <shachaf> adu: newtype is actually a different type (which gets removed during compilation).
21:25:38 <adu> shachaf: isn't 'type' making a new type as well?
21:25:47 <Cale> There's also sequence, which takes a list of actions and turns them into a single action that runs each. It's handy for constructing loops.
21:25:55 <shachaf> adu: It's just an alias.
21:25:58 <shachaf> @src String
21:25:58 <lambdabot> type String = [Char]
21:26:15 <Cale> You can write things like functions to produce while loops and such yourself, but most people just use recursion for that.
21:26:23 <shachaf> > let f :: [Char] -> [Char]; f = id in f ("abc" :: String)
21:26:24 <lambdabot>  "abc"
21:26:26 <adu> shachaf: whats the difference between a type and a type alias?
21:26:39 <shachaf> adu: A type alias is just a new name.
21:27:05 <shachaf> adu: It's interchangeable with what it's aliasing.
21:27:22 <Cale> adu: type String = [Char] will match the type [Char], but if it were defined using newtype String = S [Char], then it wouldn't, and you'd need the S constructor to make a value of that type.
21:27:34 <shachaf> adu: With a newtype, you actually have to do something like pattern-matching to get the old type out.
21:27:57 <Cale> adu: For example, if you're concerned about getting dollars mixed up with other numbers, you can define a  newtype Dollars = Dollars Integer
21:28:57 <adu> so if it is defined be 'newtype' then you have to specify a constructor?
21:29:01 <Cale> Yeah.
21:29:15 <adu> how is this different than 'data Dollars = Dollars Integer'?
21:29:21 <shachaf> adu: But it ends up compiling to about the same thing.
21:29:43 <dmwit> adu: It is different in the way it handles bottom.
21:29:49 <Cale> Well, first of all, there's newtype deriving
21:30:07 <wagle_home> newtype can have only one constructor, Data can have one or more
21:30:18 <Cale> which is an extension in GHC that lets you derive any class supported by the original type
21:30:29 <Cale> So for example, you can write:
21:30:41 <Cale> newtype Dollars = Dollars Integer deriving (Eq, Ord, Show, Num)
21:30:46 <dmwit> adu: Newtypes are unboxed, so the one constructor "doesn't count" in some sense: with a newtype, Dollars _|_ === _|_, whereas this is not so with data.
21:31:03 <Cale> and that'll let you do things like  Dollars 10 + Dollars 15
21:31:06 <adu> dmwit: oh, ok
21:31:51 <Cale> adu: The expectation is that at runtime, the newtype is implemented in the same way as the type which it wraps.
21:32:09 <adu> so making a bastardized C analogy, newtype is like 'typedef' and type is like '#define' ?
21:32:27 <Cale> hmm, I think so.
21:32:32 <dmwit> errr... not really
21:32:35 <Cale> er...
21:32:46 <dmwit> C doesn't make sure that you sent a c_time rather than a long, but Haskell does.
21:32:54 <Cale> Oh, okay.
21:32:59 <Cale> Yeah, then no, it's not :)
21:33:06 <shachaf> typedef is like type, I think.
21:33:11 <dmwit> Right.
21:33:12 <shachaf> #define is like #define. :-)
21:33:19 <adu> lol
21:33:28 <dmwit> #define is like =   ;-)
21:33:34 <Cale> Right, I suppose C just doesn't have any support for anything like that.
21:33:47 <adu> C is not typed
21:33:49 <ddarius> Cale: You can make a single field struct.
21:33:59 <shachaf> ddarius: That would be more like data, wouldn't it?
21:34:07 <Cale> hmm, that's true
21:34:08 <dmwit> adu: C is typed.  It just lets you change types easily.
21:34:10 <sarehu> no, a pointer to a single field struct would be like data
21:34:19 <ddarius> shachaf: In C there wouldn't be a difference.
21:34:38 <dmwit> adu: (You can change types in Haskell, too, with some unsafe* function.)
21:34:53 <shachaf> ddarius: That's true (except that it doesn't disappear after compilation, I guess).
21:35:14 <adu> dmwit: if you don't count casts as functions, then it only has those types that can't be cast'ed which pretty much only include 'int' since it can be cast'ed into anything, even dereferenced
21:37:51 <adu> oic its all in 3.17.2
21:37:58 <yrlnry_> Dereferencing an int is illegal in C.
21:38:19 <yrlnry_> You can cast it to a pointer and dereference the pointer, but the cast is "implementation defined".
21:38:24 <adu> yrlnry_: but you can cast an int to a (void *)
21:38:44 <yrlnry_> Yes, and the result is "implementation defined"; the standard does't say what it will do.
21:39:00 <yrlnry_> It's a slightly weaker non-guarantee than "undefined".
21:41:11 <adu> anyways, we shouldn't be arguing about c in #haskell
21:41:39 <dons> gwern: have you done the comonad package? if not, i'll take care of it.
21:41:56 * dons had to check himself writing 'xmonad' when he meant 'comonad'
21:42:21 <sarehu> you know, I really can't stand comonads
21:42:39 <sarehu> comonads are monads to me, ifyouknowwhatimean
21:43:07 <dmwit> I understand what you comean.
21:43:29 <alatter> cowhat?
21:43:36 <dmwit> coworker?
21:43:45 <adu> xmonad rocks, at least, so I hear
21:43:51 <sarehu> so you cohear
21:43:51 <dons> i'd agree, adu :)
21:43:59 <dons> corocks
21:44:02 <yrlnry_> Does anyone ever refer to initial objects as coterminal objects?
21:44:04 <sarehu> co it does rock
21:44:11 <wagle_home> whats so important about non-overlapping windows?
21:44:24 <dmwit> So, is corock "roll"?
21:44:25 <alatter> yrlnry_ I think I've heard it stated that way before
21:44:29 <dons> wagle_home: its a good default?
21:44:37 <alatter> maybe they were just being funny
21:44:45 <dmwit> wagle_home: That's not the point.  The point is: predictable + automatic.
21:44:55 <wagle_home> i dont have 3 cinerama screens on my notebook..  8/
21:45:01 <dons> neither.
21:45:09 <dons> i just have full screen xterms, managed automatically
21:45:15 <dons> so i never need to manually move anything
21:45:21 <dmwit> wagle_home: It turns out that non-overlapping also happens to be pretty nice, but that's just a side-effect, in my opinion. =P
21:45:35 <dons> yeah. its more about automating the manual placement that wastes our time
21:45:50 <adu> i need to start using xmonad
21:45:56 <sarehu> not really
21:45:58 <yrlnry_> Does anyone ever refer to X as co-coX, for any X?
21:46:08 <yrlnry_> Are coconuts nuts?
21:46:16 <dmwit> How about the Mac GUI interface?
21:46:16 <dons> some people are absolutely addicted to xmonad. we have some really wacky fans :)
21:46:19 <dmwit> Coco-a
21:46:37 <Festering_Hate> Goodnight everyone.
21:46:53 <dons> i think the wm can feel like the main interface to the computer, so making that more efficient has profound user experience effects
21:46:54 <dmwit> The next Linux interface will be a play on both Cocoa, X11, and C by being just A. =)
21:46:58 * ddarius doesn't even used tiled windows, let alone overlapping ones.
21:47:09 <wagle_home> on...
21:47:12 <wagle_home> coon
21:47:15 <wagle_home> cocoon
21:47:20 <dmwit> hahahaha
21:48:14 <adu> laborate
21:48:24 <yrlnry_> llaborate.
21:48:26 <adu> collaborate
21:49:07 <goalieca> Korollary, did you see that spinorama?
21:49:32 <goalieca> you'll see it in the highlights later
21:49:58 <kbateman> As long as I stick a terminal running screen on one half, and an xemacs window in the other half, I don't have to move anything.
21:50:15 <adu> anyways, now that HOpenGL is working, I'm going to start making nifty demos :)
21:50:26 <kbateman> How did you fix it adu?
21:50:46 <adu> kbateman: by re-compiling GHC
21:51:00 <kbateman> cool.  I wasn't completely wrong then.
21:51:17 <dmwit> Welp, that exhausts "grep -i '^coco' /usr/share/dict/words" I guess.  cocoa, coconut, cocoon
21:51:35 <adu> and recompiling the lessons0*.hs with the new GHC of course (which skipping this step made it appear not to work at first)
21:51:46 <adu> hehe
21:51:48 <kbateman> You could prefix co to any verb starting with co, right?
21:52:26 <yrlnry_> you should be able to prefix it to any noun or adjective.
21:52:27 <natv> cocook?
21:52:33 <yrlnry_> For example, cofinite coalgebras.
21:52:41 <yrlnry_> Which, horrifyingly, exist.
21:52:58 <wagle_home> coinitial coalgebras?
21:53:02 <yrlnry_> Except it's a different "co" in "cofinite".
21:53:30 <yrlnry_> co-NP-complete.
21:53:54 <natv> is that NP a terminal or a non-terminal?
21:56:13 <kbateman> @type ap
21:56:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:57:11 <daba> http://www.tipovidaba.bloger.hr
21:57:11 <daba> http://www.tipovidaba.bloger.hr
21:57:11 <daba> http://www.tipovidaba.bloger.hr
21:57:12 <daba> http://www.tipovidaba.bloger.hr
21:57:12 <daba> http://www.tipovidaba.bloger.hr
21:57:12 <daba> http://www.tipovidaba.bloger.hr
21:57:12 <lambdabot> Title: K L A  E N J E...
21:57:12 <lambdabot> Title: K L A  E N J E...
21:57:13 <lambdabot> Title: K L A  E N J E...
21:57:13 <lambdabot> Title: K L A  E N J E...
21:57:13 <lambdabot> Title: K L A  E N J E...
21:57:14 <daba> http://www.tipovidaba.bloger.hr
21:57:14 <lambdabot> Title: K L A  E N J E...
21:57:16 <daba> http://www.tipovidaba.bloger.hr
21:57:16 <lambdabot> Title: K L A  E N J E...
21:57:18 <daba> http://www.tipovidaba.bloger.hr
21:57:18 <lambdabot> Title: K L A  E N J E...
21:57:20 <daba> http://www.tipovidaba.bloger.hr
21:57:20 <lambdabot> Title: K L A  E N J E...
21:57:22 <daba> http://www.tipovidaba.bloger.hr
21:57:22 <lambdabot> Title: K L A  E N J E...
21:57:23 <dmwit> Halp!
21:57:24 <daba> http://www.tipovidaba.bloger.hr
21:57:24 <lambdabot> Title: K L A  E N J E...
21:57:26 <daba> http://www.tipovidaba.bloger.hr
21:57:26 <lambdabot> Title: K L A  E N J E...
21:57:26 <yrlnry_> ops?
21:57:28 <daba> http://www.tipovidaba.bloger.hr
21:57:29 <lambdabot> Title: K L A  E N J E...
21:57:30 <daba> http://www.tipovidaba.bloger.hr
21:57:30 <lambdabot> Title: K L A  E N J E...
21:57:32 <daba> http://www.tipovidaba.bloger.hr
21:57:32 <lambdabot> Title: K L A  E N J E...
21:57:33 <dolio> Cale
21:57:34 <daba> http://www.tipovidaba.bloger.hr
21:57:34 <lambdabot> Title: K L A  E N J E...
21:57:36 <lambdabot> Title: K L A  E N J E...
21:57:43 <yrlnry_> @ops
21:57:43 <lambdabot> Maybe you meant: docs oeis pl
21:57:47 <wolverian> "And Haskell, OCaml and their ilk are part of a 45-year-old static-typing movement within academia to try to force people to model everything. Programmers hate that." http://steve-yegge.blogspot.com/2008/02/portrait-of-n00b.html
21:57:48 <lambdabot> Title: Stevey's Blog Rants: Portrait of a N00b
21:58:15 <pjd> lambdabot should do some limiting/uniqing
21:58:16 <wolverian> steve is fun because he's so easy to get mad at, yet he usually has some point in what he writes :)
21:58:38 <kbateman> @unpl (+)
21:58:38 <lambdabot> (+)
21:59:45 <wolverian> steve's post makes me think of the pain that is HList :)
21:59:50 <wolverian> and records...
22:01:20 <pjd> "These languages will never, ever enjoy any substantial commercial success, for the exact same reason the Semantic Web is a failure. You can't force people to provide metadata for everything they do. They'll hate you."
22:01:33 <pjd> i can has type inference?
22:01:39 <yrlnry_> I don't understand what he means by "modeling".
22:01:44 <wolverian> type inference is a form of providing metadata
22:01:51 <wolverian> since you have to form the code to conform to the types anyway
22:01:58 <wolverian> so you must have the types in your head
22:02:00 <pjd> wolverian: s/provide/infer/
22:02:17 <pjd> the whole point is you don't have to provide them
22:02:24 <wolverian> with "provide" I mean "be aware of"
22:02:27 <wolverian> sorry.
22:02:32 <pjd> you don't need to be aware of, either
22:02:57 <dons> he's got a bad case of the typitis
22:03:00 <wolverian> well, I find that I do :) otherwise my code doesn't compile, usually..
22:03:16 <wolverian> though it's getting easier to not think about it
22:04:26 <wolverian> so, anyway. my point is that you do have to be running a small type inferencer in your head while writing haskell.
22:04:35 <wolverian> does that sound wrong?
22:05:25 <pjd> wolverian: i have the opposite experience
22:05:50 <pjd> i write code more or less like i would write it in, say, Python
22:05:56 <dolio> How do you write code in Lisp or Python without knowing what the type (loosely speaking) of anything is?
22:05:58 <pjd> and if you ask me what the type is, i ask ghci
22:07:02 <wolverian> dolio, you do know it, it's just not guaranteed.
22:07:20 <wolverian> pjd, hm. well, I haven't been writing enough haskell lately, for sure.
22:08:10 <dons> wolverian: hmm. no need for type inference in the head -- any more than in C. you're just supposed to know the type of your variables.
22:08:14 <dons> like any language for that matter.
22:08:26 <dons> maybe perl et al make it easier, since you have to restate the type everytime you use something.
22:09:46 <dolio> Yeah, I don't see how keeping track of the types of things in Haskell is any more work than doing so in, say, Ruby.
22:10:05 <dolio> Aside from things like newtype Foo/runFoo.
22:10:09 <wolverian> dons, right. in non-inferencing languages, it might be easier to see the type since it is explicit. of course, haskell is incredibly concise, and it is easy to write large expressions, so it's easy to lose track at the fifth (.)
22:10:48 <pjd> well, you just look at the other side of the (.)
22:11:13 <wolverian> well, true. (.) was a bad example. :)
22:11:44 <wolverian> anyway, I'm just saying how things feel to me, as someone who writes haskell now and then. I'm absolutely not saying you can't write haskell naturally.
22:11:47 <pjd> there are probably specific things that can trip people up
22:12:05 <pjd> like the (Dread) monomorphism restriction
22:12:12 <dons> i guess data types are a bit richer in haskell too, so we tend to push on nested and interesting data types more.
22:12:19 <dons> so you do see pipelines that changes types a lot
22:12:27 <dons> while in say, perl, you're encourages to stick to very simple flat types
22:12:48 <dons> data structures aren't really first class in languages without pattern matching and ADTs, imo. :)
22:12:51 <wolverian> well, to make a specific example: seeing liftA2 (,) confused me.
22:13:07 <wolverian> (yesterday)
22:13:24 <pjd> wolverian: that requires a good intuition of applicative functors to make any sense, though
22:13:39 <pjd> regardless of the typing involved
22:15:11 <wolverian> yes. seeing the type made it clear
22:15:27 <wolverian> okay, time to catch the bus. →
22:15:53 <wolverian> er, I'm late already. :)
22:16:25 <wolverian> dons, yes, the pipeline thing is what I meant with conciseness.
22:17:16 <wolverian> I think haskell is more like perl than java in the JFDI aspet
22:17:20 <wolverian> s/aspet/aspect/
22:17:49 <wolverian> data Foo = ... -- just f*cking define it?
22:35:57 <wagle_home> data Foo = ... deriving WhatIWant
22:36:06 <wagle_home> > data Foo = ... deriving WhatIWant
22:36:07 <lambdabot>  Parse error at "data" (column 1)
22:36:34 <mrd> feel free to add explicit type annotations where desired for clarity
22:41:24 <Zao> Ooh, the GHC port for FreeBSD was de-broken the other day.
22:41:45 <Zao> At least for x86_64, that is.
22:43:32 <RayNbow> hmm, new language on the shootout
22:44:34 --- mode: ChanServ set +o Cale
22:45:07 --- mode: Cale set +b *!*daba@*
22:45:15 --- mode: Cale set -o Cale
22:48:08 <siti> sorry I haven't been on much today, has anyone tried out that ide yet?
22:48:28 <RayNbow> which IDE?
22:48:41 <siti> the new haskell one on hackage
22:48:44 <siti> I can't remember the name
22:49:03 <RayNbow> hmm
22:51:29 <RayNbow> this one, siti? http://www-users.cs.york.ac.uk/~ndm/guihaskell/
22:51:30 <lambdabot> Title: Neil Mitchell - GuiHaskell
22:51:38 <siti> no, I'll paste it sorry
22:52:18 <siti> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/leksah-0.1
22:52:21 <lambdabot> http://tinyurl.com/2zmwo9
22:55:53 <RayNbow> hmm...
22:56:30 <RayNbow> the only problem I have is the name... Googling for leksah gives odd results
22:56:37 <siti> lol
23:16:41 <adu> whats the difference between ColumnMajor|RowMajor?
23:16:51 <adu> in Graphics.Rendering.OpenGL.GL.CoordTrans?
23:18:44 <adu> i guess columnmajor is what i need... n/m
23:28:33 <adu> how do I call loadMatrix if its not exported by Graphics.Rendering.OpenGL.GL.CoordTrans?
23:29:04 <adu> or do I use "matrix $="?
23:42:56 <Korollary> goalieca: wtf he made contact with the goalie in the blue
23:43:18 <goalieca> ya.. when the goalie punched him in the back of the head
23:43:28 <goalieca> its a legit goal. goalie crashed him
23:44:23 <Korollary> I would have punched him too
23:46:20 <dons> the strange sports subculture of #haskell
23:46:45 <goalieca> Korollary, i did punch on stuff like that in the past. Started a bench clearing brawl one day
23:46:48 <goalieca> but it was still a goal
23:47:30 <Spockz> hmmz, that colabti.de logger isn't very much up to date
23:50:57 <adu> hmm
23:51:55 <Spockz> adu: what's wrong?
23:52:02 <araujo> http://www.osnews.com/images/comics/wtfm.jpg
23:52:26 <adu> so 'newMatrix' returns 'IO (m c)', and 'matrix $=' expects '(m c)', can't I do something like 'newMatrix args... >> \x = matrix $= x'?
23:52:41 <adu> \x -> sorry
23:53:30 <adu> i'm trying to load a custom matrix into matrixMode (Modelview 0)
