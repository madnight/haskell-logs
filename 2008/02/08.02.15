00:26:04 <wagle_home> whats the antonym of "dry-run"?
00:26:14 <vincenz> wet-walk
00:27:05 <wagle_home> lol
00:27:45 <wagle_home> gratz..  i need something 30 seconds ago.  you win!
00:27:55 <vincenz> \o/
00:33:30 <pjd> wagle_home: "oh-shit" ?
00:34:05 <vincenz> Maybe I have more luck here: how do I colour the background of an \fbox
00:34:42 <glguy> What is a non-P language?
00:36:27 <wagle_home> pjd, i like it..  those are the last words of many a person
00:45:57 <vincenz> wagle_home: I think "live-run" or "wet-run"
00:48:26 <wagle_home> yeah, live run is better...  thanks
00:49:39 <pjd> glguy: non-Python/Perl/Ruby
00:50:42 <ojacobson> wagle_home: "fully armed"
00:52:42 <sieni> Hmm... can one build a cross compiler version of ghc?
00:53:51 <Mr_Awesome> if i have some value (fail "msg"), how can i just get the "msg" part out of there?
00:54:21 <Mr_Awesome> *some value that could be
00:54:30 <Saizan> Mr_Awesome: it depends on the monad
00:55:20 <Saizan> Mr_Awesome: with some like Maybe you can't, with Either String you just have to pattern match on Left
00:55:34 <Saizan> Mr_Awesome: for MonadError in general you can use catchError
00:55:39 <Saizan> ?type catchError
00:55:42 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
00:56:16 <Mr_Awesome> well, i want to create a function that takes a monad that could have failed and either calls error with the string or returns the value within the monad
00:56:36 <Mr_Awesome> so should i just make it be of type Either String a -> a
00:56:52 <Saizan> > catchError (fail "msg") (\e -> "Error: " + e) :: Either String ()
00:56:53 <lambdabot>  Couldn't match expected type `Either String ()'
00:57:06 <Saizan> > catchError (fail "msg") (\e -> return $ "Error: " + e) :: Either String ()
00:57:07 <lambdabot>  Couldn't match expected type `()' against inferred type `[Char]'
00:57:14 <Saizan> > catchError (fail "msg") (\e -> return $ "Error: " + e) :: Either String String
00:57:15 <lambdabot>   add an instance declaration for (Num [Char])
00:57:28 <Saizan> ..i should sleep more..
00:57:34 <Mr_Awesome> heh
00:57:35 <Saizan> you get the idea :)
01:15:22 <Le-Chuck_ITA> good day to all
01:15:45 <Cin> hi-de-hi
01:33:09 <hpaste>  bloup pasted "evaluation sequence" at http://hpaste.org/5678
01:33:45 <bloup> the evaluation sequence is not what I expected ...
01:34:41 <vincenz> bloup: print the trace?
01:34:45 <vincenz> or annotate?
01:35:45 <hpaste>  (anonymous) annotated "evaluation sequence" with "(no title)" at http://hpaste.org/5678#a1
01:36:42 <vincenz> bloup: seems correct
01:37:38 <bloup> why is cc 55 evaluated as second?
01:37:52 <bloup> why are 33 up to 55 evaluated at all?
01:38:33 <Cale> bloup: well, it can't tell what possible changes to the state they might make if it doesn't evaluate them
01:40:26 <Cale> To really understand the evaluation order, I think you'd have to do some evaluation by hand.
01:40:58 <Cale> But basically, I think it's evaluating the cc 22 before producing the [88] part of the output
01:41:02 <vincenz> oh!
01:41:11 <Cale> and then printing the final state causes it to force those other three
01:41:12 <vincenz> I missed the 55
01:42:23 <vincenz> the reason is that State is not strict
01:42:39 <Cale> Well, that'd be the overarching reason, yes :)
01:43:06 <bloup> I think I got it.
01:43:07 <Cale> Evaluation of the monadic computations doesn't necessarily happen in the order of their execution.
01:43:26 <vincenz> IO is strict :D
01:43:57 <Cale> In which sense?
01:44:06 <vincenz> I hope?
01:44:47 <glguy> lazy reader doesn't enforce ordering, and reverse state is a great example of non-standard ordering :)
01:44:58 * glguy proceeds to read the backlog to see if that was relevant
01:45:43 <vincenz> Anywho
01:45:47 * vincenz votes for a strict State
01:45:58 <vincenz> Cale: remembering debugging during icfpc?
01:47:06 <Cale> yep
01:47:17 <Cale> GHCi 6.8.2 would have been handy :)
01:47:31 <vincenz> Cale: how so?
01:47:41 <Cale> It has a nice debugger now.
01:48:02 <glguy> or at least "it has a debugger now"
01:48:04 <glguy> :-D
01:54:03 <osfameron> who needs a debugger when you have print statements!
01:54:27 <matthew-_> I thought print was added for the purposes of debugging?
01:59:27 <masklinn> > randomIO
01:59:30 <lambdabot>   Not in scope: `randomIO'
02:30:14 <schwadri> hi there. is this right? in the maybe monad: ( nothing >>= return x = nothing) ?
02:30:36 <vincenz> s/nothing/Nothing
02:30:48 <vincenz> and not quite
02:30:58 <vincenz> >>= expects a function
02:31:01 <vincenz> you want
02:31:02 <vincenz> either
02:31:06 <vincenz> Nothing >> return x
02:31:06 <vincenz> or
02:31:12 <vincenz> Nothing >>= \x -> return x
02:31:28 <schwadri> oh
02:31:45 <schwadri> thx
02:32:00 <vincenz> but otherwise, yes, Nothing is the 'fail' of the maybe monad, and thus propagates to the end
02:33:37 <schwadri> k. thats what i wanted to know
02:33:54 <schwadri> i am trying to implement monads in c++
02:33:57 <Cale> Nothing >>= f = Nothing
02:34:02 <Cale> Just x >>= f = f x
02:34:30 <vincenz> schwadri: what operators do you use?
02:34:46 <mux> is the Strict monad of any use? I mean the Identity monad with strict function application
02:34:50 <schwadri> vincenz: none, can't use operators during compile time
02:35:28 <schwadri> vincenz: i thought monads could be usefull for metaprogramming as during compile time you can only program using recursion
02:35:52 <Le-Chuck_ITA> Hi, I defined this type: "type Arr a b = (Finite a,Eq b) => (a -> b)" but the compiler says at least one variable must be universally quantified
02:36:03 <vincenz> schwadri: ah I see
02:36:12 <Le-Chuck_ITA> at least one variable in Eq b
02:36:23 <Le-Chuck_ITA> but b _is_ universally quantified?
02:36:40 <vincenz> I don't think you can put class constraints on plain type's
02:37:08 <Le-Chuck_ITA> there is no ghc extension that will do that?
02:41:25 <Le-Chuck_ITA> I am a little in trouble with type classes
02:41:45 <Le-Chuck_ITA> class Kern t a where
02:41:45 <Le-Chuck_ITA>     kern :: t a b -> [[a]]
02:41:45 <Le-Chuck_ITA>     keq :: t a b -> t a c -> Bool
02:41:57 <Le-Chuck_ITA> This is a class of type constructors having a kernel
02:42:50 <Le-Chuck_ITA> now I would like to say "if a is Finite, and b and c are Eq, then the functions from a to b and c have a kernel and a keq method"
02:42:59 <Le-Chuck_ITA> however this is plain wrong.
02:43:14 <Le-Chuck_ITA> I don't know how to express my constraints here
02:44:09 <vincenz> Le-Chuck_ITA: you can't quantify over b and c in your constriants
02:44:21 <vincenz> cause they're no part of the definition of the class
02:44:21 <Le-Chuck_ITA> I see
02:44:29 <vincenz> instance (Finite a, Eq b, Eq c) => Kern (->) a b c where ...
02:45:19 <Le-Chuck_ITA> yes this seems the right solution
02:46:11 <vincenz> so you'll have to quantify the b and c in your class
02:46:16 <vincenz> class Kern t a b c where ..
02:46:20 <vincenz> or
02:46:24 <vincenz> put the Eq constraint on keq
02:46:27 <vincenz> class Kern t a where
02:46:35 <vincenz>   keq :: (Eq b, Eq c) => ...
02:46:46 <vincenz> (if this is the case for -all- key instances)
02:46:50 <vincenz> s/key/keq
02:47:30 <Le-Chuck_ITA> vincenz: the latter seems better
02:47:48 <Le-Chuck_ITA> the former constrains me to know b and c when I put a "kern t a b c" constraint
02:48:14 <Le-Chuck_ITA> or the compiler complains that I should allow undecidable instances
02:48:27 <Le-Chuck_ITA> btw my name is vincenzo, please to meet you :)
02:49:14 <Le-Chuck_ITA> I am still a little asleep today
02:49:26 <Le-Chuck_ITA> I can't say that every instance of keq has the Eq b and Eq c constraints
02:49:44 <schwadri> vincenz: whats the name of the >> operator in the monad domain?
02:49:51 <vincenz> schwadri: >>= is called bind
02:50:01 <vincenz> a >> b === a >> \_ -> b
02:50:01 <schwadri> vincenz: and >> ?
02:50:07 <vincenz> erm
02:50:11 <vincenz> a >> b === a >>= \_ -> b
02:50:27 <vincenz> schwadri: it's just a special case of bind, really
02:50:31 <jedbrown> schwadri: >> is usually pronounced `then'
02:51:20 <vincenz> jedbrown: except that >>= pronounced as 'bind' would sound odd
02:51:27 <vincenz> a >>= \x -> b
02:51:32 <vincenz> a bind x to b
02:51:47 <schwadri> u use >> if b is (M -> M) ?
02:51:55 <vincenz> :t bind
02:51:59 <lambdabot> Not in scope: `bind'
02:52:01 <vincenz> :t (>>=)
02:52:02 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:52:03 <vincenz> :t (>>)
02:52:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
02:52:29 <vincenz> schwadri: no, in >>> 'b' is a monadic action, not a function
02:52:59 <schwadri> vincenz: omg. now i'm completely confused
02:53:22 <jedbrown> vincenz: Why would it sound odd?
02:54:02 <vincenz> schwadri: a >> b binds two monadic actions together into one monaidc action
02:54:28 <vincenz> schwadri: a >>= f binds a monadic action to af unction that takes the return value of 'a' and returns a new monadic action
02:54:53 <vincenz> e.g.
02:54:57 <vincenz> print "A" >> print "B"
02:55:14 <vincenz> return "A" >>= print
02:55:44 <schwadri> k.
02:55:51 <schwadri> the >>> confused me ;-)
02:55:52 <vincenz> Does that make more sense?
02:55:54 <vincenz> yeah, that was a typo
02:55:57 <schwadri> ah k
02:56:03 <vincenz> I meant >>
02:56:06 <schwadri> in that case everything is clear now
02:56:11 <schwadri> thx vincenz
02:56:14 * vincenz nods
02:56:44 <gour> @seen ndm
02:56:44 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 18h 36m 26s ago, and .
03:00:03 <dolio> @elite Agda rocks my boxers.
03:00:04 <lambdabot> 4gda rock$ my box3Rz.
03:00:31 * Le-Chuck_ITA :    My brain just exploded.
03:01:38 <vincenz> Sounds painful
03:02:00 <vincenz> E devo dire che il mio vero nome non a ha niente a che are con il nick "vincenz"
03:02:09 <Le-Chuck_ITA> sounds great :)
03:02:21 <vincenz> s/are/fare/
03:03:32 * dolio just spent 3 or 4 hours trying to prove the associativity of addition.
03:04:12 <Le-Chuck_ITA> dolio: did you succeed
03:04:12 <Le-Chuck_ITA> ?
03:04:38 <vincenz> dolio: in case it turns out to be wrong? :P
03:05:01 <Syzygy-> ARGH!
03:05:05 <Syzygy-> How should I cite GHC?
03:05:16 <vincenz> Syzygy-: let me give you my bibref
03:05:47 <Syzygy-> Yes please.
03:05:57 <vincenz> @misc{url:ghc2006, title = "Glassgow Haskell Compiler", author = {University of Glassgow}, url = "http://www.haskell.org/ghc/"
03:05:57 <lambdabot> Unknown command, try @list
03:06:00 <vincenz> }
03:06:01 <dolio> Yeah, I finally succeeded.
03:06:02 <Syzygy-> Thanks.
03:06:19 <vincenz> Syzygy-: not certain that's the best,  but that works for me
03:06:44 <dolio> My problem was that I had defined a function : (x : Nat) -> x == x -> suc x == suc x...
03:06:59 <dolio> When I needed (x y : Nat) -> x == y -> suc x == suc y
03:07:03 <vincenz> :)
03:07:05 <vincenz> yeah
03:07:08 <vincenz> x == x is kinda obvioous
03:07:14 <vincenz> same for suc x == suc x
03:07:19 <dolio> Yeah.
03:08:02 <dolio> Took me a while to realize that was the problem, though.
03:08:14 <vincenz> Note to self: don't state the obvious :)
03:08:41 <dolio> Plus, I did a lot of looking through the standard libraries for ideas, and they're pretty impenetrable.
03:08:46 <dolio> In an amazing kind of way.
03:09:28 <kosmikus> dolio: :)
03:11:23 <Le-Chuck_ITA> I am in trouble as usual
03:11:59 <Le-Chuck_ITA> Now I need to guarantee to the compiler that if Eq a, then Eq (t a), Eq (t (t a)) and so on
03:12:03 <Le-Chuck_ITA> how do I do that!?
03:12:39 <Le-Chuck_ITA> I can't write "class EqF t where Eq a => Eq (t a)"
03:12:45 <jedbrown> vincenz: Feeling lisssspy when writing your .bib?
03:12:56 <vincenz> jedbrown: hmm?
03:13:12 <jedbrown> vincenz: s/Glassgow/Glasgow/
03:13:18 <vincenz> oh :)
03:13:28 <vincenz> thanks for the catch
03:32:23 <Le-Chuck_ITA> I defined the following:
03:32:28 <Le-Chuck_ITA> class EqF t where
03:32:28 <Le-Chuck_ITA>     eq :: (Eq a) => t a -> t a -> Bool
03:32:28 <Le-Chuck_ITA> instance (EqF t,Eq a) => Eq (t a) where
03:32:28 <Le-Chuck_ITA>     (==) = eq
03:33:18 <Le-Chuck_ITA> This defines the class of all functors t that "preserve" a definition of equality
03:33:28 <Le-Chuck_ITA> however it looks a litle contrived to me
03:33:37 <Le-Chuck_ITA> is there a simpler way?
03:41:09 <dcoutts_> Le-Chuck_ITA: try generalising more
03:41:30 <dcoutts_> more generally you have (a -> a -> b) -> t a -> t a -> b right?
03:42:20 <dcoutts_> or if we know t is a functor, we could decompose that into:
03:43:05 <dcoutts_> (a -> b -> c) -> t a -> t b -> t c and t c -> d, the latter being some kind of fold/traversal
03:43:13 <dcoutts_> the first is like a binary fmap
03:44:27 <Le-Chuck_ITA> Hmm
03:44:47 <Le-Chuck_ITA> we know that t is a functor.
03:46:25 <Le-Chuck_ITA> dcoutts_: "=="  is binary
03:46:30 <Le-Chuck_ITA> so I can't define     (==) = fmap (==)
03:46:43 <Le-Chuck_ITA> oh
03:47:21 <dcoutts_> it's two such structures, (a -> b -> c) -> t a -> t b -> t c
03:47:38 <dcoutts_> I don't see how one defines that with just (a -> b) -> t a -> t b
03:48:20 <dcoutts_> if it's an applicative functor of course then you can do it
03:48:38 <dcoutts_> @type liftA2
03:48:41 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
03:49:01 <dcoutts_> @type liftA2 (==)
03:49:01 <lambdabot> forall a (f :: * -> *). (Applicative f, Eq a) => f a -> f a -> f Bool
03:49:23 <Le-Chuck_ITA> hmm
03:49:36 <Le-Chuck_ITA> is there a way to see the definition of a class from ghci? I guess not
03:49:37 <timbod> Hi All
03:49:46 <dcoutts_> Le-Chuck_ITA: use :info
03:50:18 <Vq^> hi timbod
03:51:46 <timbod> I'm looking at applicative functors...
03:51:50 <Le-Chuck_ITA> dcoutts_ which module?
03:52:08 <vincenz> @hoogle liftA2
03:52:09 <lambdabot> Control.Applicative.liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:52:34 <timbod> I can see how any monad can also be an AF instance, but I'm interested in AFs that are not monads.
03:52:39 <timbod> Any good examples?
03:53:45 <timbod> The functional Pearl paper ("applicative programming with effects") give one relating to lists, but it seems to me to be a convenient notation for a specific bit of code rather than something generally useful.
03:54:21 <dcoutts_> timbod: some kinds of parsers
03:54:50 <timbod> dcoutts_: Hi - can you give me a pointer to an example?
03:54:51 <Le-Chuck_ITA> dcoutts_ I suspect not all of my functors are applicative. However
03:55:15 <dcoutts_> timbod: even some things that are also monads have extra optimisation opportunities when you use them with <*> rather than >>=
03:55:58 <dcoutts_> timbod: an example of the latter is Data.Binary's Put monad. You only get some of the cool optimisations when you use it in an applicative style.
03:56:02 <timbod> dcoutts_: because monads force a sequencing, and AF's do not?
03:56:20 <dcoutts_> @type (>>=)
03:56:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:56:23 <dcoutts_> @type (<*>)
03:56:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:56:26 <Le-Chuck_ITA> could I define a class as "EqF t" is the class of all type constructors t : * -> * that implement class Eq on t a?
03:56:33 <Le-Chuck_ITA> for all a such that Eq a?
03:57:02 <dcoutts_> timbod: look at those types, basically the difference boils down to (a -> m b) vs m (a -> b)
03:57:18 <timbod> dcoutts_: I know the types, but I'm finding it hard to see implementations that don't have pure=return, >>=ap
03:57:41 <timbod> Perhaps I should take a look at the code for Data.Binary Put.
03:57:54 <dcoutts_> timbod: it's about data flow, with m (a -> b) you can see the structure of the action *before* running it
03:58:28 <dcoutts_> timbod: with a -> m b it's an opaque function, you have to run it first to get anything, so no opportunities for "static" analysis
03:58:51 <timbod> Click! because you have an m  ... not a function returning an m ...
03:59:17 <dcoutts_> so the applicative style can carry more static information, but on the other hand it restricts the forms of things you can write because the data flow is restricted
03:59:34 <dcoutts_> you cannot have the structure of the action depend on the input data, that's the restriction
04:00:18 <dcoutts_> timbod: so try parsing xml generically with applicative, it's not so easy since you cannot remember the tag name from the start til when you see then end tag.
04:00:23 <timbod> Got it. (I think :-). but I'll have to look at some real examples with that in mind.
04:00:55 <dcoutts_> timbod: on the other hand an applicative parser can gather more static info which may help it to go faster (generating static tables etc)
04:00:57 <timbod> but xml parsing would be ok monadically?
04:01:02 <dcoutts_> timbod: exactly
04:01:50 <timbod> That's a real help - but like all haskell lights that switch on, now I need to let it sink in a bit.
04:01:54 <dcoutts_> timbod: startTag >>= \name -> body >> endTag name
04:02:09 <timbod> Yep.
04:02:37 <dcoutts_> so Monad allows the structure of the parser to change depending on earlier input
04:03:26 <timbod> What sort of parsers were you referring that fitted an applicative structure? I did see the blog last week which layered an Applicative framework over parsec.
04:03:51 <timbod> But that just seemed (then) to tidy the syntax, rather than do anything fundamental.
04:05:51 <timbod> dcoutts_: thanks for the insight. How goes gtk2hs?
04:05:58 <timbod> Or is cabal occupying more of your thoughts these days.
04:06:21 <dcoutts_> timbod: aye, cabal mostly, but Axel is maintaining gtk2hs fine
04:06:39 <dcoutts_> timbod: I'm trying to get cabal to the stage where it can build gtk2hs
04:07:06 <timbod> Is cabal + cabal-install a bottomless pit of work? Or do you forsee a sweet spot where it generally does most of what is needed?
04:08:30 <timbod> (Perhaps that spot is gtk2hs building with it :-)
04:09:27 <dcoutts_> timbod: right, I think when it can build multiple related packages in one go using a dependency framework that'll be pretty good
04:10:00 <dcoutts_> gtk2hs's current build system sucks but one good thing about it is that make in a clean tree is almost instant
04:10:21 <dcoutts_> because it uses non-recursive make so it just stats 1000's of files and does nothing in less than 0.1 sec
04:10:39 <dcoutts_> cabal and ghc --make are not nearly that good yet
04:11:02 <Taejo> isn't it wonderful when you get to the stage where you can delete half your code without removing any features
04:11:47 <timbod> dcoutts_: I like that sort of build system - I replaced a _slow_ recursive make system at work (to build millions of lines of C++), with a single makefile to get that sort of behaviour.
04:12:35 <dcoutts_> timbod: right, so part of the cabal 2.0 plan is to build a better make in haskell
04:12:44 <timbod> How many packages would the curent gtk2hs system be in cabal?
04:13:14 <dcoutts_> timbod: 12
04:13:25 <alinabi> @src foldr
04:13:26 <lambdabot> foldr k z xs = go xs
04:13:26 <lambdabot>     where go []     = z
04:13:26 <lambdabot>           go (y:ys) = y `k` go ys
04:13:42 <timbod> I always thought it would be nice to factor out cairo, but when I looked at the build system, I decide to just compile against the whole thing even though I wasn't actually building a gui.
04:13:47 <timbod> 12 - yikes!
04:14:15 <ivanm> and you'd need all of them to be able to use gtk2hs properly?
04:14:43 <dcoutts_> ivanm: no, the gtk package only has 2 other deps, glib and cairo
04:14:58 <dcoutts_> gtk/gnome is a fairly modular system
04:15:26 <ivanm> so what are these 12 packages that a cabalized gtk2hs would become?
04:15:38 <vininim> @src unfoldr
04:15:38 <lambdabot> unfoldr f b  = case f b of
04:15:38 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:15:38 <lambdabot>    Nothing        -> []
04:15:47 <timbod> Yes - I am genuinely impressed that the open source community can keep that many packages and APIs robust and in sync.
04:15:48 <dcoutts_> ivanm: the ghc packages that gtk2hs already installs
04:16:01 <Le-Chuck_ITA> I am still in trouble. I really need to define the type class of all t such that "Eq a => Eq t a"
04:16:17 <ivanm> dcoutts_: but why are there 12 of them? 12 different sets of libraries?
04:16:35 <ivanm> or am I just misunderstanding the context because I started reading halfway through a conversation? :p
04:16:39 <dcoutts_> ivanm: try it: ghc-pkg list -f /usr/lib/ghc-6.8.2/gentoo/gtk2hs-0.9.12.1.conf
04:18:09 <nominolo> @users
04:18:09 <lambdabot> Maximum users seen in #haskell: 463, currently: 417 (90.1%), active: 11 (2.6%)
04:18:09 <dcoutts_> ivanm: cairo, gconf, glade, glib, gtk, gtkglext, mozembed, soegtk, sourceview, svgcairo, gstreamer, gnomevfs
04:18:19 <ivanm> *nod*
04:18:41 <ivanm> so in reality gtk2hs is a bundle of 12 interconnected/related libs rather than just one set of libraries?
04:18:48 <dcoutts_> ivanm: yep
04:19:03 <dcoutts_> which is why it'd be even better to cabalise
04:19:31 <dcoutts_> but we use more cunning pre-processing than cabal can cope with yet
04:20:24 <nominolo> dcoutts_: would dependency tracking suffice?
04:20:35 <dcoutts_> nominolo: mostly
04:21:02 <dcoutts_> nominolo: we'd have to sort something out with a couple other custom pre processors we use
04:21:13 <hpaste>  Le-Chuck_ITA pasted "Troubles with type classes and existential types" at http://hpaste.org/5680
04:21:35 <dcoutts_> nominolo: but we could probably ship pre-processed source for those
04:22:24 <dcoutts_> nominolo: and I guess we'd want to get build-tools to act like deps too, so that building gtk etc would pull in c2hs if necessary
04:22:25 <malcolmw> dcoutts: quick Q on the computational model of GTK - it is shared-stateful right?  the only way to communicate from, say, a permanently visible FileChooser, to the thing displaying the contents of the file, is through an IORef?
04:22:26 <nominolo> gtk2hs on hackage would definitely be great
04:22:32 <dcoutts_> nominolo: indeed
04:22:37 * Le-Chuck_ITA , while waiting, discover happs and thinks it's damn cool
04:23:02 <dcoutts_> malcolmw: or similar things like threads and other abstractions built on IORefs/MVars/Threads
04:23:18 <malcolmw> dcoutts_: that's what I thought
04:23:34 <dcoutts_> malcolmw: the flow of control is inverted so you may want to use a trick to revert it again
04:23:37 <malcolmw> it's a mind-bending way to program - a whole new paradigm
04:24:39 <dcoutts_> malcolmw: fortunately it's easy in Haskell to restore more conventional style, post interesting events to to a channel or use a State monad that gets saved and restored from a ref of some sort.
04:25:09 <nominolo> or write an FRP wrapper :)
04:26:38 <malcolmw> hmm, posting events to a channel: that sounds quite appealing.  RSS-feeds as a structuring mechanism for a GUI.  :-)
04:28:21 <nominolo> appalling?
04:29:04 <nominolo> > editDistance "appalling" "appealing"
04:29:07 <lambdabot>   Not in scope: `editDistance'
04:29:29 <Le-Chuck_ITA> what happens to lambdabot if I send him an infinite loop?
04:29:46 <nominolo> > loop = loop
04:29:46 <lambdabot>  Parse error at "=" (column 6)
04:29:55 <nominolo> > let loop = loop in loop
04:29:58 <lambdabot>  Exception: <<loop>>
04:30:02 <Le-Chuck_ITA> I mean something like [1..]
04:30:10 <nominolo> > [1..]
04:30:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:30:20 <nominolo> > last [1..]
04:30:23 <lambdabot> Terminated
04:30:26 <Le-Chuck_ITA> > unsafePerformIO
04:30:27 <lambdabot>   Not in scope: `unsafePerformIO'
04:30:33 <jedbrown> dcoutts_: I've got a package interference question:
04:31:08 <dcoutts_> malcolmw: if you use threads note that you either have to use a trick to get cooperative scheduling in ghc's single threaded rts or oyu have to be really careful about only using gui calls from the main thread if you use ghc's threaded rts.
04:31:16 <jedbrown> dcoutts_: hmatrix has a Storable instance for Complex and my package does as well.  It is not logical for either to depend on the other, but it is logical to use them together.
04:31:57 <jedbrown> dcoutts_: as I understand it, this means that we need to get the Storable instance in one place (like the standard lib).
04:32:04 <dcoutts_> mm, sounds problematic
04:32:35 <dcoutts_> jedbrown: or one or both want to use a private newtype so that you do not add a global instance
04:33:21 <jedbrown> dcoutts_: Well, that would work, but is clumsy since it would have to be user visible.
04:34:40 <timbod> dcoutts_: goodnight - thanks for the info on AFs
04:34:51 <dcoutts_> timbod: np
04:35:13 <Le-Chuck_ITA> whose machine do I kill if I ask lambdabot for fib 200?
04:35:24 <jedbrown> dcoutts_: Err, maybe it wouldn't need to be.  It's still clumsy.
04:35:38 <nominolo> Le-Chuck_ITA: you kill nothing
04:35:54 <dcoutts_> jedbrown: aye, it's not lovely
04:35:54 <nominolo> Le-Chuck_ITA: lambdabot will kill the thread if it takes too long
04:36:30 <Le-Chuck_ITA> so with lambdabot you basically can say "hey, I took an haskell interpreter and I put that on irc. If it's safe now, you can bet it IS safe" :)
04:36:37 <Cin> lambdacat will kill your family
04:36:56 <nominolo> > let fib n = 0:1:zipWith (+) fib (tail fib) in fib !! 200
04:36:56 <lambdabot>  Couldn't match expected type `[a]' against inferred type `t1 -> t'
04:36:58 <jedbrown> dcoutts_: It really should be in the base.  C99/C++/Fortran all use the same binary representation for Complex.
04:37:00 <dcoutts_> jedbrown: you could try to get a Storable instance but is it obvious that everyone wants exactly the same instance?
04:37:06 <Le-Chuck_ITA> (13:36:45) Le-Chuck_ITA: > let fib x = case x of { 0 -> 1 ; 1 -> 1 ; n -> fib (n-1) + fib (n-2) } in fib 40
04:37:06 <Le-Chuck_ITA> (13:36:51) lambdabot: Terminated
04:37:11 <Le-Chuck_ITA> mine is much worse
04:37:18 <dcoutts_> jedbrown: if it is then fine, send in a library proposal
04:37:43 <Le-Chuck_ITA> in any case, here it's 1337 time
04:37:53 <nominolo> Le-Chuck_ITA: lb had some security issues, but those have been fixed
04:38:01 <jedbrown> dcoutts_: In the mean-time, is there a way to tell GHC that the instances are identical, so that it doesn't error?
04:38:03 <mux> > fix ((1:) . scanl (+) 1)
04:38:04 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:38:06 <nominolo> Le-Chuck_ITA: i'd use a VM anyways, though
04:38:11 <mux> > fix ((1:) . scanl (+) 1) !! 40
04:38:11 <lambdabot>  165580141
04:38:26 <Le-Chuck_ITA> nominolo: a VM will change nothing as soon as you don't reboot that
04:38:36 <dcoutts_> jedbrown: no
04:38:52 <Le-Chuck_ITA> can someone take a look at my own mess at http://hpaste.org/5680
04:38:53 <Le-Chuck_ITA> ?
04:39:13 <nominolo> Le-Chuck_ITA: hm?  i mean that a lb fault doesn't give access to important data
04:39:32 <Le-Chuck_ITA> nominolo: well but you can still use it as a remote shell or whatever
04:40:17 <nominolo> right
04:40:21 <jedbrown> dcoutts_: Also, should I make a storable-complex package which defines the instance, and ask Alberrto to make hmatrix depend on it, until the instance gets in the base class.
04:41:00 <jedbrown> dcoutts_: It's a tiny package, but it would make everyone's life easier, I think.
04:42:54 <Cin> well it looks like writing a scheme with a state monad is pretty doable
04:42:58 <dcoutts_> jedbrown: could do, it's pretty annoying to do that, if it's not too painful I'd use the newtype and change later when the instance is available.
04:44:58 <ricky_clarkson> Cin: Is that what scheme in 48 hours does?
04:45:09 <Cin> ricky: no, it uses IORefs for mutable objects
04:46:30 <jedbrown> dcoutts_: It's the backward compatibility that I'm worried about.  Since we want the instance in base, the newtype will have stay around until we no longer care about 6.8.2.  With the external package, it's just a line in the .cabal file.
04:46:56 <Cin> ricky: i've implemented SET! using the state monad, just have to write non-primmitive procedure application and i may have a very basic, purely functional scheme implementation
04:47:42 <dcoutts_> jedbrown: though you'd still have to have the conditional dependency on the tiny package until you no longer care about 6.8.2
04:48:30 <JaffaCake> any Linux experts around?
04:48:36 <jedbrown> dcoutts_: That's just a line in the .cabal file and a CPP line for the import.
04:48:44 <nominolo> @index liftIO
04:48:45 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:49:06 <Le-Chuck_ITA> JaffaCake: what is your problem?
04:49:17 <JaffaCake> I'm trying to figure out why user time might be different from elapsed time, other than system calls and page faults and other processes
04:49:34 <Le-Chuck_ITA> I am not *that* expert :)
04:50:03 <JaffaCake> ok, never mind :)
04:50:12 <Le-Chuck_ITA> please somebody look at my three lines of code, you know I love you all
04:50:16 <Igloo> JaffaCake: Counting swapping as other processes?
04:50:24 <JaffaCake> no swapping going on
04:51:17 <JaffaCake> basically I made a mod to the GC, and now the elapsed time is significantly higher than user time, and it wasn't before
04:51:28 <JaffaCake> I need to know why...
04:51:57 <JaffaCake> is there any way that cache misses  or TLB misses might be counted as system time?
04:52:23 <dcoutts_> JaffaCake: so system time is the same or it's up?
04:52:44 <dcoutts_> JaffaCake: are we trying to track system time or the gap between system+user and real?
04:53:05 <JaffaCake> well, the latter, but I'm not actualy measuring system time
04:53:09 <JaffaCake> I can try that
04:54:16 <dcoutts_> @seen wli
04:54:16 <lambdabot> wli is in #haskell-overflow, #haskell-blah and #haskell. I last heard wli speak 7h 26m 38s ago.
04:54:35 <dcoutts_> JaffaCake: when wli is around he's a good linux system expert
04:55:33 <JaffaCake> ah, it's weirder than I thought - the system time seems to have moved from the mutator to the GC
04:55:40 <JaffaCake> but the total is about the same
04:56:01 <JaffaCake> it's probably page faults, but not being reported somehow
04:57:15 <dcoutts_> JaffaCake: so you want a breakdown of the system time, there's SystemTap and similar things though they're not that easy to get set up I think
04:57:31 <Le-Chuck_ITA> Ok I try to explain it here. I have defined an existential type E with an "Eq a" constraint on an "hidden" type variable c and a "Functor" constraint on an hidden type variable t. Now I want to define the function "nextstate" that takes an E with a c inside, and returns an E with a t c inside. I need to put a constraint on t in the definition of E, but which constraint? I need to ensure to the compiler that Eq (t c) whenever Eq c. I don't kow
04:57:41 <JaffaCake> dcoutts_:  ta
04:57:49 <JaffaCake> I have oprofile, maybe that will help
04:57:50 <Le-Chuck_ITA> s/Eq a/Eq c/ at the beginning
04:58:10 <Cale> Le-Chuck_ITA: Eq constrants on existentially quantified variables tend to be pretty useless.
04:58:29 <pejo> dcoutts, is systemtap the equivalent of vtune, or is that something else?
04:58:48 <dcoutts_> pejo: it's a bit like d-trace I believe, though not as slick
04:58:49 <Le-Chuck_ITA> Cale: I need that to compute the kernel of a (finite domain) functino
04:59:05 <Cale> Le-Chuck_ITA: hmmm..
04:59:08 <dcoutts_> JaffaCake: though oprofile is only sampling
04:59:18 <pejo> JaffaCake, random barinstorming: Valgrind (callgrind) might give you cache statistics and such.
04:59:28 <Cale> Le-Chuck_ITA: Oh, you have like, an array or finite map or list of these values or something?
04:59:33 <Le-Chuck_ITA> yes
04:59:36 <Cale> Le-Chuck_ITA: ah, okay
04:59:49 <pejo> dcoutts, oh. That seems like the right way to go then.
04:59:58 <Cale> Le-Chuck_ITA: You could specify that an instance of Eq (t c) was required directly.
05:00:11 <Le-Chuck_ITA> then, it will require to me Eq (t (t c)) :)
05:01:34 <Le-Chuck_ITA> and so on
05:04:17 <Le-Chuck_ITA> Cale?
05:05:29 <Cale> hmm
05:05:54 <Cale> So you're doing something involving polymorphic recursion?
05:06:00 <Le-Chuck_ITA> yes
05:06:08 <Le-Chuck_ITA> http://hpaste.org/5680
05:07:29 <Cale> hmm... you might just want to carry around a "dictionary" for Eq explcitly.
05:07:40 <Cale> *explicitly
05:09:38 <Le-Chuck_ITA> hmm maybe that'll do but am unsure
05:10:02 <Le-Chuck_ITA> let's try
05:14:01 * Le-Chuck_ITA has an headache
05:14:11 <Cale> Le-Chuck_ITA: It's what the typeclass system is expected to do :)
05:14:30 <Cale> You'll also need a function which turns (==) for a into (==) for t a
05:14:35 <Le-Chuck_ITA> it's too complex: I can no longer use inferred equality
05:15:40 <Le-Chuck_ITA> Cale: problem is that I don't want to define such a function, but rather I want my states to be defined whenever equality is defined for t x, which is the case for lists for example
05:15:50 <ricky_clarkson> Cin: How is it purely functional if it has set!?
05:16:44 <psykon> test.o: In function `rH4_info':
05:16:44 <psykon> (.text+0x7e): undefined reference to `networkzm2zi1zi0zi0_NetworkziSocket_zdf14_closure'
05:16:51 <Cale> psykon: --make
05:16:51 <psykon> when compiling using GHC
05:17:03 <Cale> psykon: Or  -package network
05:17:07 <Cin> ricky: well the scheme isn't purely functional, but the implemention is. when SET! is used it just updates the binding in the state monad
05:17:17 <psykon> Cale: thanks
05:18:00 <Cin> ricky: just an experiment. :)
05:18:12 <ricky_clarkson> Cin: I see.  I thought anything written in Haskell without unsafe*, was purely functional.
05:18:20 <ricky_clarkson> I was taking that bit for granted.
05:18:32 <psykon> cool, this works
05:18:52 <psykon> i was afraid i was getting some cryptic error message
05:19:04 <psykon> i haven't really studied monads yet
05:19:04 <ricky_clarkson> Cin: It sounds fun, I'd lie to do that someday.
05:19:05 <ricky_clarkson> like*
05:19:10 <idnar> ricky_clarkson: if I write a C compiler in Haskell without unsafe*, is C purely functional? ;)
05:19:19 <Cale> psykon: What are you working on?
05:19:25 <ricky_clarkson> No, but your implementation is.
05:19:41 <psykon> Cale: just playing around with Network
05:23:07 <Le-Chuck_ITA> nobody knows how to work around this problem? I have been spending more time trying to give a type to the algorithm than writing the algorithm, and this is maybe normal, but I just can't believe the partition refinement algorithm cannot be typed at all in haskell
05:23:18 <Le-Chuck_ITA> however I didn't manage to find a solution
05:24:36 <basvandijk> Hello, I have a little problem with my haskell emacs mode that I didn't have yesterday: When I try to load a buffer in ghc using: C-c C-l, I get the error "local-variable-p: Symbol's function definition is void: curent-buffer"
05:24:46 <basvandijk> has anybody seen that before?
05:25:49 <basvandijk> The only thing I did was updating my haskell-mode (I'm running the CVS version).
05:26:10 <basvandijk> But that's not the problem because when I install a stable version I get the same error...
05:26:14 <ibid> Le-Chuck_ITA: so, theer's your code?
05:26:27 <ibid> *where
05:26:39 <Le-Chuck_ITA> http://hpaste.org/5680
05:26:45 <Le-Chuck_ITA> thanks
05:28:34 <dcoutts_> jedbrown: and you need to send an email to the libraries list, see http://haskell.org/haskellwiki/Library_submissions
05:31:12 <nominolo> basvandijk: did you accidentally edit a .el file?
05:31:22 <nominolo> it seems like an "l" is missing
05:31:45 <nominolo> oh, you updated.  then maybe it's that
05:32:31 <nominolo> er, an "r" missing
05:32:46 <wolfgangbeck> is there any documentation how to return a tuple from a C function? the FFI doc doesn't mention it.
05:33:04 <nominolo> basvandijk: just grep for "curent-buffer" and change it to "current-buffer"
05:33:28 <jedbrown> dcoutts_: Oh, thanks.
05:35:39 <ibid> Le-Chuck_ITA: argh, too existential for me now, sorry ;)
05:35:48 <Le-Chuck_ITA> :) thanks anyway
05:37:26 <Le-Chuck_ITA> is there a generic comparison
05:37:29 <Le-Chuck_ITA> for lists
05:37:37 <Le-Chuck_ITA> which takes the comparison of elements as an argument?
05:38:29 <oerjan> Le-Chuck_ITA: you can make one
05:38:39 <Le-Chuck_ITA> I see :)
05:39:08 <oerjan> if you know the lists have the same length you can use zipWith for it
05:39:12 <oerjan> + and
05:39:26 <oerjan> but otherwise i think it's best to write it recursively
05:39:42 <basvandijk> nominolo: Thanks I didn't notice the spelling error in the error message... I'm sending a fix to the author of haskell-mode. Thanks again!
05:39:46 <Cale> :t ((and .) .) . zipWith
05:39:47 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool
05:40:08 <nominolo> basvandijk: did it work?
05:40:10 <Le-Chuck_ITA> ok thanks oerjan
05:40:23 <basvandijk> nominolo: yes it did
05:40:28 <nominolo> ok, good
05:43:48 <larmeh> hi there
05:44:13 <Cale> hi
05:44:52 <larmeh> why won't the following work? testdiv :: Int -> Int -> Rational
05:45:00 <larmeh> testdiv a b = a / b
05:45:09 <Cale> Because / isn't defined for Int values.
05:45:24 <Le-Chuck_ITA> Now: this is too much. Forgive a 5 lines paste
05:45:31 <Cale> You'll want to convert the Ints to rationals first with fromIntegral
05:45:34 <larmeh> oh, okay... that makes... sense :)
05:45:38 <Le-Chuck_ITA>  Overlapping instances for Eql (t1 c)
05:45:38 <Le-Chuck_ITA>       arising from use of `Main.State' at termseq.hs:30:23-49
05:45:38 <Le-Chuck_ITA>     Matching instances:
05:45:38 <Le-Chuck_ITA>       instance (Eql a, EqF t) => Eql (t a) -- Defined at termseq.hs:22:0
05:45:38 <Le-Chuck_ITA>       instance (Eql a) => Eql [a] -- Defined at termseq.hs:60:0
05:46:00 <Le-Chuck_ITA> I never made [] an instance of EqF
05:46:04 <Cale> larmeh: If you wanted integer division instead, you'd use div, but it produces an Int
05:46:18 <Cale> (well, the same type as whatever numbers you're integer-dividing)
05:46:42 <Saizan> Le-Chuck_ITA: it checks only the shape, not the context
05:46:49 <oerjan> Le-Chuck_ITA: unfortunately the part before => is only checked _after_ instance lookup
05:46:51 <Saizan> [a] matches t a
05:47:19 <Le-Chuck_ITA> if I use -fallow-incoherent-instances it uses the first choice I defined in my file...
05:48:00 <oerjan> Le-Chuck_ITA: i don't think incoherent-instances are recommended unless you _really_ know what you are doing
05:48:20 <oerjan> you could try -XOverlappingInstances
05:48:51 <oerjan> (even that should be used with great care)
05:48:52 <Le-Chuck_ITA> oerjan: where do I put that option?
05:49:37 <oerjan> Le-Chuck_ITA: best in a pragma on the top of the file: {-# LANGUAGE OverlappingInstances #-} i think
05:50:29 <Le-Chuck_ITA> oerjan: I don't understand. It says       instance [overlap ok] (Eql a) => Eql [a]
05:50:30 <Le-Chuck_ITA>         -- Defined at termseq.hs:24:0
05:50:30 <Le-Chuck_ITA>     (The choice depends on the instantiation of `c, t1'
05:50:30 <Le-Chuck_ITA>      Use -fallow-incoherent-instances to use the first choice above)
05:50:51 <hpaste>  psykon pasted "Why does this work?" at http://hpaste.org/5681
05:50:55 <oerjan> oh
05:51:08 <psykon> connectTo returns IO Handle
05:51:12 <oerjan> ok i don't think _i_ know what i'm doing at this point :/
05:51:20 <nominolo> @instances Applicative
05:51:22 <psykon> and most of the IO thingies expect a Handle
05:51:25 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
05:51:28 <psykon> why does that work?
05:51:35 <nominolo> @instances Control.Applicative.Applicative
05:51:36 <lambdabot> ((,) a), ((->) a), IO, Maybe, []
05:51:47 <nominolo> @instances-importing Control.Applicative.Applicative
05:51:47 <lambdabot> ((,) a), ((->) a), IO, Maybe, []
05:51:58 <oerjan> psykon: the h <- part removes the IO
05:52:22 <psykon> i see
05:52:25 <oerjan> runs the action and binds h to the result
05:54:06 <oerjan> Le-Chuck_ITA: i suppose the type checker does not consider either alternative more refined than the other, so doesn't prefer any of them
05:56:21 <Le-Chuck_ITA> thanks oerjan
05:56:22 <oerjan> Le-Chuck_ITA: perhaps you could manage to remove the [a] instance somehow by making [] an EqF?
05:56:40 <Le-Chuck_ITA> oerjan: that makes sense
05:57:13 <alios> hi, whats the most simple way to parse a floating string literal to a Double (something like fromString ?)
05:57:23 <oerjan> alios: read
05:57:43 <alios> thnx
05:57:43 <Le-Chuck_ITA> oerjan: that made lots of sense!
05:57:47 <Le-Chuck_ITA> very good
05:57:57 <oerjan> > read "1.5" :: Double
05:58:05 <oerjan> :)
05:58:12 <lambdabot>  1.5
05:58:19 <Le-Chuck_ITA> now everything types, and my minimization procedure tells me that ALL of my states are bisimilar :)
05:58:26 <nominolo> > read "1.1" :: Float
05:58:27 <lambdabot>  1.1
05:58:35 <Le-Chuck_ITA> however I am happy for now and go for lunch before falling on the floor,
05:58:36 <nominolo> no rounding error?
05:58:40 <vincenz> > read "1.5" :: Rational Integer
05:58:41 <lambdabot>      Kind error: `Rational' is applied to too many type arguments
05:58:41 <lambdabot>     In the ...
05:58:43 <Le-Chuck_ITA> bye
05:58:44 <vincenz> > read "1.5" :: Rational
05:58:45 <lambdabot>  Exception: Prelude.read: no parse
05:58:55 <vincenz> > read "1/5" :: Rational
05:58:56 <lambdabot>  Exception: Prelude.read: no parse
05:59:16 <nominolo> > read "1%2" :: Rational
05:59:17 <lambdabot>  1%2
05:59:58 <nominolo> > foldMap singleton [1,2,3]
05:59:58 <lambdabot>   Not in scope: `singleton'
06:00:07 <nominolo> > foldMap Data.Set.singleton [1,2,3]
06:00:07 <lambdabot>   Not in scope: `foldMap'
06:00:17 <nominolo> > Data.Foldable.foldMap Data.Set.singleton [1,2,3]
06:00:22 <lambdabot>  fromList [1,2,3]
06:02:42 <nominolo> > Data.Foldable.foldMap (Data.Set.singleton . Just) [1,2,3]
06:02:43 <lambdabot>  fromList [Just 1,Just 2,Just 3]
06:02:59 <hpaste>  faxathisia annotated "around" with "put together" at http://hpaste.org/5650#a6
06:02:59 <vincenz> > more spam
06:03:00 <lambdabot>   Not in scope: `spam'
06:03:09 <faxathisia> oops.. sorry
06:03:26 <Cale> faxathisia: have you been talking with Micono as well?
06:03:45 <faxathisia> yeah, we're talking about it in ##algorithms
06:03:48 <psykon> is there some thingie like hGetLine but that separates lines by \r\n ?
06:03:50 <Cale> ah, hehe
06:04:19 <vincenz> Cale: what is around
06:05:04 <Cale> vincenz: take a BST, and a key, and two numbers a and b. Give the a largest elements less than the key and the b least elements greater than it.
06:05:09 <faxathisia> I better test this code.. to see if it works...
06:05:41 <Cale> er, "less than or equal to the key"
06:07:19 <Cale> vincenz: The challenge is to do it by recursion on the structure of the tree, and not to waste a lot of time exploring branches which end up unused.
06:07:35 <vincenz> right
06:08:52 <Cale> vincenz: Interestingly enough, it seems to be much easier to write in a lazy language than a strict one. In order to get a strict version I essentially had to translate it into a version which maintains stacks of things to possibly explore.
06:09:11 <vincenz> Cale: why not simply annotate the number of elements in your tree?
06:09:36 <Cale> Well, if the tree doesn't already have that annotation, you'll end up spending O(n) time doing that.
06:11:22 <Cale> Poor Micono, he tries to get help with algorithms and ends up talking to a bunch of insane lazy functional programmers ;)
06:11:32 <faxathisia> haha
06:12:32 <vincenz> Cale: annotating your tree like that has more advantages
06:12:38 <oerjan> faxathisia: you mean BWAHAHAHA
06:12:51 <vincenz> @haha
06:12:51 <lambdabot> Unknown command, try @list
06:12:56 <vincenz> Nope, no such suggstion
06:13:54 <Cale> vincenz: this is true :)
06:14:13 <vincenz> Cale: you still in LB?
06:14:41 <Cale> LB?
06:14:44 <vincenz> lazybottoms
06:15:02 <Cale> Is there another ICFP contest approaching?
06:15:09 <vincenz> Well, july :)
06:15:14 <Cale> heh
06:15:19 <vincenz> But you know me, I start getting fussy 6 months in advance
06:15:44 <Cale> I suppose, I'll see how things are going closer to then :)
06:17:45 <Cale> Okay, so how exactly do you use the size annotated tree? After all, that tells you how many elements are in each subtree, and you know which of those two the key must be in, but you don't know how many elements of the subtree are less than the key you're looking for right off, do you?
06:18:58 <vincenz> well no
06:18:58 <vincenz> but you can use iti to cut
06:19:07 <vincenz> let's assume for a second, that the element is at the root of the tree
06:19:13 <vincenz> (the key)
06:19:18 <vincenz> ok?
06:19:20 <Cale> sure
06:19:29 <vincenz> then we check the left child to see how many children it has
06:19:38 <vincenz> and we check it's left child as well
06:19:48 <vincenz> and determine whether we only have to go in the left-right, or also in the left-left
06:19:52 <vincenz> and then, by how much
06:20:00 <vincenz> if we have 'a' to the left
06:20:02 <vincenz> and we'r'e no root position
06:20:09 <Cale> mm, I suppose it does cut it down somewhat.
06:20:10 <vincenz> then we need 'a' - left.right from left.left
06:20:17 <vincenz> if left < a
06:20:18 <vincenz> and we're not in root
06:20:21 <vincenz> then we go up and left
06:20:28 <faxathisia> I use side effects
06:20:35 <Cale> If the key is at a leaf though, it's not as easy.
06:20:37 <faxathisia> saves needing lazyness
06:20:46 <Cale> faxathisia: yeah, that's possible.
06:20:59 <vincenz> Cale: you keep a stack of left-amounts on the way down
06:21:03 <Cale> faxathisia: I'm totally incapable of considering potential side-effects. :)
06:21:20 <Cale> faxathisia: well, not really :)
06:22:03 <Cale> faxathisia: I suppose you mutate the collected list of elements, and so you can tell when you have enough and not recurse anymore?
06:22:36 <faxathisia> yeah, but I mutate the length requested instead
06:22:55 <Cale> all right
06:23:07 <vincenz> mutations are a poor-man's lazy
06:24:01 <Cale> Hehe, mutable state is actually starting to seem alien to me.
06:24:30 <vincenz> Cale: mutable what?
06:24:56 <Cale> It's basically never part of my first solution to anything, and I have to think pretty hard to figure out how to reincorporate it.
06:25:57 <vincenz> Cale: yeah, it's easier to deisgn an algo in haskell
06:26:02 <vincenz> and then manually compile to something more primitive
06:26:02 * shapr agrees
06:26:14 <vincenz> that's a bit like people doing manual CPS :)
06:26:18 <larmeh> whats the difference between "type" and "data" declarations?
06:26:35 <Cale> I'm just not used to thinking about taking advantage of the order in which things are carried out anymore.
06:26:49 <Cale> larmeh: type just creates aliases for existing types
06:27:01 <Cale> larmeh: data defines altogether new datastructures
06:28:06 <Cale> larmeh: Somewhere in between is 'newtype', which creates a separate type from the type-system's point of view with a constructor for building and taking apart values of that type, but it's equivalent to some existing type.
06:28:52 <Cale> For example, let's say you had a bunch of dollar amounts in your program and you want the type system to ensure that they not get mixed up with other integers, you could say:
06:29:00 <Cale> newtype Dollars = D Integer
06:29:38 <Cale>   deriving (Eq, Ord, Show, Num) -- for Num here you'll need the "newtype deriving" extension in GHC.
06:30:26 <b_jonas> you'd derive Integral too, wouldn't you?
06:30:30 <Cale> Sure :)
06:30:55 <basvandijk> How can you declare the kind of the parameters of a class? So if you have 'class Foo a' how can I fix the kind of 'a' to '* -> *' without adding a method to 'Foo' like 'foo :: a x'?
06:31:11 <b_jonas> though on the other hand, you might want to not derive Num either, becasue you can't actually multiply dollar amounts
06:31:36 <basvandijk> I was expecting to be able to 'class Foo (a :: * -> *)' but that's a syntax error.
06:31:52 <Cale> basvandijk: Requires an extension
06:32:00 <basvandijk> Cale: which one?
06:32:23 <Cale> basvandijk: Probably something like KindSignatures, let me check
06:32:45 <Cale> yes, that's right
06:33:03 <Cale> Add  {-# LANGUAGE KindSignatures #-}  to the top of your file.
06:33:37 <hpaste>  faxathisia annotated "around" with "C version" at http://hpaste.org/5650#a7
06:33:52 <faxathisia> Cale, If you're interested that is my proceducal solution
06:33:54 <basvandijk> Cale: Thanks, that helps me a lot!
06:34:12 <Cale> faxathisia: You got your demo tree from wikipedia.
06:34:17 <faxathisia> well.. half of it.. one would have to write after as well (but thats easy by symmetry)
06:34:20 <faxathisia> yeah I did :P
06:34:31 <Cale> faxathisia: I have the Haskell version of it right here :)
06:35:41 <faxathisia> if(tree->nodeValue < key) { ... } is the good bit
06:35:58 <faxathisia> you can just write take n $ ... in haskell though, because it's lazy
06:36:08 <faxathisia> (at least I think so..?)
06:37:01 <Cale> yes
06:37:17 <Cale> That's what my first version did.
06:37:39 <Cale> (before the de-lazy-ing transformation)
06:37:58 * faxathisia needs a de-lazy-ing transformation..
06:42:10 <vincenz> faxathisia: it's called "money"
06:51:26 * shapr gets a call by need.
06:56:43 <Saizan> faxathisia: god, i was wondering where you muted length, until i realized --*length is not a comment..
06:56:53 <vincenz> :D
06:57:24 <vincenz> > let a --* b = a + b in 1 -* 2
06:57:26 <vincenz> > let a --* b = a + b in 1 --* 2
06:57:26 <lambdabot>   Not in scope: `-*'
06:57:28 <lambdabot>  3
06:57:30 <Feuerbach> is there a way of using M Bool (say, IO Bool) in if-then-else expression without binding it? Like fmap, but for if-then-else
06:57:33 <vincenz> Saizan: nor in haskell
06:57:59 <Philippa_> Feuerbach: no particularly neat way
06:57:59 <lambdabot> Philippa_: You have 1 new message. '/msg lambdabot @messages' to read it.
06:59:17 <opqdonut> Feuerbach: you could define ifM or something like that
06:59:21 <Saizan> vincenz: yeah i know, but my eyes don't :)
06:59:49 <vincenz> Saizan: get nw ones
07:00:31 <oerjan> with bool t e b = if b then t else e it becomes >>= bool t e
07:22:30 <Le-Chuck_ITA> hi there. I don't have any particular trouble with the type system at the moment
07:22:33 <Le-Chuck_ITA> can you help? :)
07:22:54 <Le-Chuck_ITA> just wanted to say that I finally implemented the partion refinement algorithm in haskell and it worked
07:23:11 <Le-Chuck_ITA> and I am happy too
07:23:29 <faxathisia> What is the trouble?
07:24:26 <Saizan> Le-Chuck_ITA: nice, do you have the code up somewhere?
07:25:30 <Le-Chuck_ITA> I don't like it that much yet, I think I will refine it more
07:25:40 <Le-Chuck_ITA> but if you want to see it I can post it
07:28:06 <opqdonut> :)
07:28:34 <Feuerbach> is there any standard function for '(flip (>>=) . const . return) ()' i.e. discarding the result of computation?
07:28:52 <faxathisia> :t ((flip (>>=) . const . return) (), (>>))
07:28:53 <lambdabot> forall b (m :: * -> *) (m1 :: * -> *) a b1. (Monad m1, Monad m) => (m b -> m (), m1 a -> m1 b1 -> m1 b1)
07:29:40 <opqdonut> "fmap (const ())" is  nicer than that at least
07:31:28 <Feuerbach> opqdonut: agree, but still looks scary
07:31:46 <opqdonut> just using >> is normally enough
07:31:54 <opqdonut> or what sort of usecase do you have for that?
07:33:00 <Feuerbach> opqdonut: 'when b ioCommand' if ioCommand is not IO ()
07:33:36 <opqdonut> hmm
07:34:16 <mauke> whatever :: (Monad m) => m (); whatever = return ()
07:34:31 <mauke> ignore :: (Monad m) => m a -> m (); ignore = (>> whatever)
07:34:35 <opqdonut> :)
07:34:51 <mauke> when b $ ignore ioCommand
07:35:42 <_roconnor> mauke: what are you doing?
07:36:00 <Twey> > let vsum = \x -> (x, vsum)
07:36:00 <lambdabot>  Parse error at end of input
07:36:06 <Twey> > let vsum = \x -> (x, vsum) in vsum 3
07:36:19 <Twey> Hmph.
07:36:21 <lambdabot>  thread killed
07:37:03 <Twey> In GHCi it gives me "cannot construct the infinite type: t = (t1, t1 -> t)" and tells me the expected type was t, not (t1, t1 -> t)
07:37:09 <Twey> Why is that?  :-\
07:37:49 <roconnor> Twey: there is no finite type for what you have there, but you could make a data type declaration that would help you.
07:38:13 <roconnor> data Twey a = (a, a -> Twey a)
07:38:18 <jcpetruzza> @pl [Either a b] -> ([a],[b])
07:38:19 <lambdabot> (line 1, column 14):
07:38:19 <lambdabot> unexpected ">" or "-"
07:38:19 <lambdabot> expecting variable, "(", operator or end of input
07:39:08 <Twey> roconnor: Oh, infinite types aren't allowed?
07:39:17 <roconnor> nope.
07:39:25 <Twey> Ahhh.
07:39:26 <Twey> Thanks
07:40:34 <roconnor> partitionEithers = foldr (either left right) ([],[])
07:40:34 <roconnor>  where
07:40:34 <roconnor>   left  a (l, r) = (a:l, r)
07:40:34 <roconnor>   right a (l, r) = (l, a:r)
07:40:42 <roconnor> jcpetruzza: ^^
07:41:45 <jcpetruzza> roconnor: thanks. i was wondering if there was an already defined one some lib
07:41:50 <jcpetruzza> seems it doesnt
07:42:01 <roconnor> http://hackage.haskell.org/trac/ghc/ticket/1695
07:42:03 <lambdabot> Title: #1695 (library submission: Data.Either.unzipEithers :: [Either a b] -> ([a],[b]) ...
07:42:51 <roconnor> http://hackage.haskell.org/trac/ghc/ticket/974
07:42:53 <lambdabot> Title: #974 (Add unzipEithers, lefts, rights to Data.Either) - GHC - Trac
07:43:00 <roconnor>     * resolution set to wontfix.
07:43:07 <jcpetruzza> ok, i'm not alone, then :)
07:43:38 <roconnor> ``These functions should be proposed under the library submissions procedure: http://www.haskell.org/haskellwiki/Library_submissions
07:43:39 <lambdabot> Title: Library submissions - HaskellWiki
07:43:52 <roconnor> However I was following the submissions procedure
07:43:58 <roconnor> so I'm not sure what happened
07:44:25 <vincenz> @pl \a (l,r) -> (a:l, r)
07:44:26 <lambdabot> (`ap` snd) . (. fst) . ((,) .) . (:)
07:44:28 <pcc1> @hoogle [a] -> Bool
07:44:29 <lambdabot> Prelude.null :: [a] -> Bool
07:44:29 <lambdabot> Data.List.null :: [a] -> Bool
07:44:29 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
07:45:06 <roconnor> @seen igloo
07:45:07 <lambdabot> igloo is in #ghc, #darcs and #haskell. I last heard igloo speak 57m 29s ago.
07:49:31 <Igloo> roconnor: Oh, sorry; can you please reopen and add a link to the mailing list thread then?
07:50:32 <roconnor> Igloo: I could, but I'm not sure it would help.
07:50:41 <Igloo> roconnor: Why not?
07:51:01 <roconnor> When we last left off, I couldn't build concensus on the name.
07:51:11 <roconnor> I suppose we could try again
07:51:19 <Igloo> Ah, OK
07:51:47 <roconnor> Igloo: I'll give it a shot
07:52:14 <Igloo> roconnor: OK; please add a link to the old thread anyway, so future readers can see what was said
07:52:53 <faxathisia> http://foldr.com/
07:52:54 <lambdabot> Title: foldr.com
07:52:55 <roconnor> yep
07:53:22 <faxathisia> http://foldl.com/
07:53:23 <lambdabot> Title: foldl.com
07:53:37 <mauke> http://flickr.com/
07:53:39 <lambdabot> Title: Welcome to Flickr - Photo Sharing
07:53:40 <mauke> http://flickl.com/
07:53:41 <roconnor> http://www.haskell.org/pipermail/libraries/2006-November/thread.html#6133
07:53:41 <lambdabot> Title: flickl.com
07:53:47 <lambdabot> Title: The Libraries November 2006 Archive by thread, http://tinyurl.com/3b4d4o
07:53:57 <roconnor> heh, I remember the thread...
07:55:09 <oerjan> :t first.(:) -- vincenz
07:55:10 <lambdabot> forall d a. a -> ([a], d) -> ([a], d)
07:55:15 <fnord`> hi all
07:55:18 <roel> Hi
07:55:22 <b_jonas> heh
07:55:33 <roel> Does anyone know if it is possible to define a partial function in Coq?
07:55:46 <mauke> if you don't look at the fnord`, he can't hurt you!
07:55:51 <faxathisia> roel: a -> Maybe b
07:55:51 <roconnor> roel: there are tricks.  See #coq
07:55:59 <fnord`> the fnords will eat you if you see them ;)
07:56:34 <roel> roconner: Thanks Russel, I'll ask around on #coq
07:56:56 <fnord`> I need to implement a simple GUI in for a Haskell program, needs to run on linux and windows (solaris would be good too). Any advice about the relative merits of the various libraries?
07:57:36 <roconnor> fnord`: I've used GuiTV to make a very simple Gui.
07:58:41 <fnord`> roconnor: how did you find it?
07:58:47 <dons> hey guys, ohloh supports haskell (somewhat ..) now, so we can get stats on code :)  http://www.ohloh.net/projects/11729?p=binary  and http://www.ohloh.net/projects/6869?p=xmonad
07:58:47 <lambdabot> Title: binary - Ohloh
08:01:13 <bos> woo!
08:01:21 <bos> dons: do you ever actually sleep?
08:01:33 <bos> i'm getting suspicious, you know.
08:02:20 <pejo> bos, heh, "dons does not sleep. He waits".
08:02:24 <pjd> <fact>dons only sleeps with half is brain at a time</fact>
08:02:32 <dons> well, i fork scripts while i sleep
08:02:33 <pjd> "his", even
08:02:46 <dons> oh, i see bos contributed to binary. you can 'claim' that, and add it to your stats
08:03:02 <bos> huh?
08:03:10 <bos> oh, the ohloh thing.
08:03:13 <dons> http://www.ohloh.net/projects/11729/analyses/latest/contributors
08:03:14 <lambdabot> Title: binary Contributors - Ohloh
08:03:14 <dons> yeah
08:03:25 <bos> yeah, i need to take credit for my four lines of code and an added ~ in a pattern somewhere.
08:03:35 <bos> :)
08:03:36 <dons> " Over the past twelve months, 10 developers contributed new code to binary.
08:03:37 <dons> This is a relatively large team, putting this project among the top 10% of all project teams on Ohloh. "
08:03:54 <roconnor> fnord`: It is on the wiki.  I should warn you that it uses wxHaskell, which is difficult to install at the moment. :(
08:04:11 <dons> " Over the past twelve months, 31 developers contributed new code to xmonad.
08:04:11 <dons> This is one of the largest open-source teams in the world, and is in the top 2% of all project teams on Ohloh. "
08:04:14 <dons> hehe
08:04:29 <vininim> mmm
08:04:40 <shapr> w00!
08:05:11 <vininim> I'm doing (snd $ random ranGen), and I know it would be incorrect because the compiler can't know which generator to choose
08:05:12 <dons> there's about twice that number contributed to the extension library, but i can't get it into git (to be processed). they don't support darcs currently
08:05:16 <Saizan> 31 qualifies as "one of the largest", i'm quite surprised
08:05:32 <bos> dons: so ohloh added support for darcs?
08:05:42 <vininim> but there is other code around that doe suse ranGen do promote it to a known generator
08:05:48 <bos> oh, you've been shoveling stuff through git?
08:05:49 <dons> no. they added support for haskell source, but i use a script to import into git
08:05:51 <monochrom> @botsnack
08:05:51 <lambdabot> :)
08:06:04 <dons> the haskell source seems not to count comments too. and fails randomly
08:06:29 <dons> http://www.ohloh.net/projects/search?q=haskell
08:06:30 <lambdabot> Title: Ohloh Project Search Results
08:06:36 <pjd> i think they use a Ruby framework for all the parsing
08:06:41 <pjd> which sucks a bit
08:06:49 <dons> i'll use a little script to just create project pages for all of hackage i think
08:06:52 <pjd> much better to let the languages do their own thing
08:06:58 <dons> yeah.
08:07:11 <dons> the lack of darcs support is the next problem
08:07:54 <pjd> e.g. just using Python's builtin AST, spitting out a summary in a common format
08:08:10 <dons> xmonad costs $19,748 hehe
08:08:21 <dons> oh, but the avg salary for a haskell programmer is a bit low.
08:08:27 <Twey> :-\  Really?
08:08:46 <Stinger> is this a $/LOC thing?
08:08:49 <dons> $55k is pretty low for a full time haskell programmer...
08:09:15 <atsampson> dunno, it's better than the average salary for a full-time occam programmer
08:09:20 <dons> heh
08:09:21 <Twey> I'd've thought they should be paid more
08:09:25 <Twey> Haha, atsampson
08:09:43 <dons> i don't think their metric attempts  to guess the value of programmers in different languages
08:10:36 <doserj> or the value of a line of code
08:10:40 <roconnor> @type partition
08:10:43 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:12:58 <sw17ch> dons: what about programmers in different locations?
08:14:40 <vininim>    Illegal signature in pattern: Integer
08:14:40 <vininim>         Use -XPatternSignatures to permit it
08:15:20 <vininim> I'm probably doing something real dumb
08:15:30 <Lemmih> @seen SamB
08:15:30 <lambdabot> SamB is in #perl6 and #haskell. I don't know when SamB last spoke.
08:15:33 <monochrom> You wrote "f (x :: Integer) = ..."
08:15:34 <mauke> you're trying to specify a type in a pattern
08:15:45 <roconnor> Igloo: I reopend it.  Should we mark #1695 as a duplicate of this now?
08:15:49 <vininim> no I mean, I know what I did, I'm talking about why i'm doing it
08:16:14 <monochrom> Because you are used to C, Java, ... :)
08:16:20 <mauke> OCaml
08:16:27 <vininim> heh
08:16:56 <vininim> but hey, I'm trying to 'unfoldfy' a recursive function =P
08:20:58 <Stinger> so how is Haskell prime progressing?
08:21:38 <resiak> things it would be nice to have: isLeft, partitionE :: [Either a b] -> ([a],[b])
08:21:42 <monochrom> not ready for prime time :)
08:21:51 <resiak> what kind of place should patches be slung?
08:21:58 <roconnor> resiak: my patch includes those. :)
08:22:06 <resiak> :)
08:22:13 <roconnor> http://hackage.haskell.org/trac/ghc/ticket/974
08:22:15 <lambdabot> Title: #974 (Add unzipEithers, lefts, rights to Data.Either) - GHC - Trac
08:23:11 <roconnor> resiak: oh sorry, I ``removed the controvertial isLeft, fromLeft, isRight, fromRight''
08:23:20 <psykon_> let's say i have a list [Char -> IO ()] and i want to call each of those in the list with a specific argument
08:23:24 <roconnor> resiak: so I guess you should make a new track for those.
08:23:28 <psykon_> how could i do that?
08:24:22 <resiak> roconnor: actually, in this case I actually want to do splitEithers and check that the lefts is null
08:24:29 <resiak> so i don't need isLeft et al.
08:26:13 <Stinger> > map ($ 4)  [(+4),(*3),(+4) . (*7)]
08:26:28 <lambdabot>  thread killed
08:26:50 <Stinger> okie dokie
08:26:51 <mauke> > map ($ 4)  [(+4),(*3),(+4) . (*7)]
08:26:51 <roconnor> > 2 + 2
08:26:52 <lambdabot>  [8,12,32]
08:26:53 <lambdabot>  4
08:27:02 <psykon_> help please? :)
08:27:05 <mauke> > sequence [(+4),(*3),(+4) . (*7)] 4
08:27:07 <lambdabot>  [8,12,32]
08:27:34 <roconnor> @type mapM
08:27:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:27:38 <roconnor> @type mapM_
08:27:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:27:41 <mauke> @hoogle sequenceM
08:27:42 <lambdabot> No matches found
08:27:55 <Stinger> did I type something wrong there or does lambabot just hate me
08:28:12 <mauke> the latter
08:28:17 <roconnor> psykon: the right use of mapM will use.
08:28:18 <Stinger> anyway psykon that was directed at you
08:28:22 <vininim> lamdabot machine is under heavy cosmics ray atack lately
08:28:28 <roconnor> will work.
08:29:02 <psykon> thanks roconnor
08:29:42 <ray> i've never attacked any bots! i deny these allegations
08:35:06 <gwern> nornagon_: because the download is killing me
08:36:32 <vininim> @hoogle generic!!
08:36:38 <lambdabot> Did you mean: Generic
08:36:38 <lambdabot> Prelude.undefined :: a
08:36:38 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
08:37:13 <nornagon_> gwern: i see
08:37:26 <BMeph> For that matter, I doubt John Goertzen has time or desire to "atack" anything either. :)
08:37:35 <vininim> @hoogle (Num a) => [b] -> a -> [b]
08:37:36 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
08:37:36 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
08:37:36 <lambdabot> Data.List.scanl :: (a -> b -> a) -> a -> [b] -> [a]
08:37:39 <pjd> psykon: do you want to call them all with the same argument?
08:38:03 <psykon> pjd: yes
08:38:23 <psykon> mapM (\m -> m foo bar) list
08:38:27 <vininim> there is no generic (!!) ?
08:39:47 <vininim> like genericIndex
08:39:59 * vininim slaps himself
08:40:31 <psykon> is it possible to have mutable data structures in haskell?
08:40:50 <opqdonut> short answer: yes
08:41:05 <opqdonut> long answer: what do you want to do?
08:41:16 <psykon> well
08:41:22 <sw17ch> why do long answers usually involve asking more questions :)
08:41:27 <opqdonut> State, IOArray, STM all emulate or are mutable data types
08:41:35 <psykon> i have a list inside a data structure
08:41:36 <opqdonut> -types
08:41:44 <psykon> and i want to destructively add things to it :P
08:41:47 <pjd> psykon: sequence_ . sequence [...]
08:41:47 <kpreid> on the other hand, there are zippers
08:42:04 <tinnus> sorry everyone, I'm a cargo cultist
08:42:05 <pjd> where the [...] :: [a -> IO ()]
08:42:06 <dcoutts_> hia gwern, you've uploaded a lot of hackage packages recently and I just wanted to check with you that all the authors of those packages knew what was going on.
08:42:13 <tinnus> see you all when I get better
08:42:22 <opqdonut> psykon: just define a new list based on the old one
08:42:22 <psykon> maybe there's a better way to do this
08:42:27 <opqdonut> using map, filter or whatever
08:42:30 <psykon> that doesn't involve imperative evil
08:42:46 <pjd> psykon: that will give you a -> IO ()
08:42:48 <opqdonut> start worrying about mutability when you find immutable structures are a performance bottleneck
08:42:55 <dcoutts_> gwern: I also wanted to note that we're going to prevent uploading the same package version more than once in future so you may have to do some version bumping.
08:43:02 <vininim> it's okay until you start using IORef and performIO
08:43:09 <roconnor> @faq is there a better way to do this that doesn't involve imperative evil?
08:43:10 <lambdabot> The answer is: Yes! Haskell can do that.
08:43:25 <psykon> :D
08:43:52 <Stinger> @faq will you always answer the same thing or is there logic behind this?
08:43:53 <lambdabot> The answer is: Yes! Haskell can do that.
08:44:12 <sw17ch> lambdabot--
08:44:30 <vininim> > cycle "Yes! Haskell can do that"
08:44:30 <opqdonut> :)
08:44:38 <lambdabot>  "Yes! Haskell can do thatYes! Haskell can do thatYes! Haskell can do thatYes...
08:44:40 <sw17ch> shoot, it used to get into a karma war with me
08:44:50 <sw17ch> @karma lambdabot
08:44:50 <lambdabot> lambdabot has a karma of 50
08:44:53 <psykon> i've got a type that represents an irc connection and i want to keep a list of hooks to call on events
08:44:58 <sw17ch> @karma sw17ch
08:44:58 <lambdabot> You have a karma of 1
08:45:00 <sw17ch> :(
08:45:01 <opqdonut> :P
08:45:08 <psykon> the problem is adding to the list
08:45:14 <psykon> how would you guys do this?
08:45:20 <vininim> write a domain language
08:45:29 <vininim> :)
08:45:41 <opqdonut> addhook h (Structure _ _ _ list _) = Structure { hooks=h:list }
08:45:43 <psykon> ?
08:45:43 <opqdonut> or something like that
08:46:02 <roconnor> psykon: maybe use conal's DataDriven library.
08:46:29 <dcoutts_> gwern: I hope it doesn't sound like I'm getting at you, it's great that your helping release lots of packages. Some people were just a tad surprised to see all the new packages with a different uploader.
08:46:32 <roconnor> psykon: it keeps a list of hooks to call on events.
08:46:36 <roconnor> :)
08:47:01 <vincenz> roconnor: do you know how to make type-rules in latex?
08:47:18 <roconnor> vincenz: I hate latex
08:47:29 <roconnor> nope, I don't :)
08:49:00 <b_jonas> what does type-rules mean?
08:50:43 <pejo> b_jonas, A |- ... RET -------- RET A |- .... in ascii.
08:50:50 <vincenz> that
08:52:16 <pejo> vincenz, there are a couple of packages for logic stuff that I don't remember the name of. Or you can fiddle a lot with \frac. I don't think you can find an easy and quick way to make it look good though.
08:52:24 <vincenz> pejo: found it
08:52:26 <vincenz> \inference
08:54:15 <vininim> like in "Types and Programming Languges" by Pierce?
08:55:15 <psykon> opqdonut: how could i do it like that but keeping the other structure fields the same?
08:55:29 <psykon> (without typing everything)
08:56:22 <slarba> opqdonut: :)
08:57:33 <vincenz> psykon: updating a structure?
08:57:40 <psykon> vincenz: yes
08:57:41 <vincenz> s{ field = newfield
08:57:42 <vincenz> }
08:57:58 <vincenz> iirc
08:58:40 <vincenz> addhook h s@(Structure _ _ _ list _) = s{hooks = h:list}
08:58:53 <psykon> that works, thanks
08:58:53 <opqdonut> yep, that syntax
08:59:05 <vincenz> or even
08:59:13 <vincenz> addhook s = s{hooks = h:hooks s}
08:59:19 <vincenz> erm add an 'h'
08:59:21 <psykon> i used that lst one
08:59:28 <psykon> *last
08:59:39 <vincenz> or even better
08:59:50 <vincenz> maphook f s = s{hooks = f . hooks $ s}
09:00:00 <vincenz> addhook s = maphook (s;)
09:00:02 <vincenz> addhook s = maphook (s:)
09:00:50 <vincenz> pophook = maphook tail
09:01:10 <vincenz> or for safety : maphook (drop 1)
09:03:13 <psykon> is there a function to get the nth head of a list?
09:03:22 <vincenz> head . drop n
09:03:29 <faxathisia> !!
09:03:30 <vincenz> or simply !! n
09:03:58 <psykon> ?
09:04:02 <vincenz> list !! 4
09:04:11 <vincenz> > [1..] !! 10
09:04:13 <psykon> oh i see
09:04:16 <psykon> thanks
09:04:23 <lambdabot>  11
09:04:38 <sw17ch> > [10..1]
09:04:38 <lambdabot>  []
09:04:42 <sw17ch> =(
09:04:46 <faxathisia> > [10,9..1]
09:04:47 <mauke> (=
09:04:47 <vincenz> > [10,9..1
09:04:47 <lambdabot>  Parse error at end of input
09:04:48 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
09:04:54 <sw17ch> > reverse [1..10]
09:05:00 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
09:05:13 <sw17ch> > [10,9..(-1)]
09:05:14 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1]
09:05:32 <faxathisia> > enumFromThenTo 10 9 -1
09:05:33 <lambdabot>   add an instance declaration for (Num (t -> [t]))
09:05:37 <faxathisia> :|
09:05:43 <vincenz> faxathisia: ()
09:05:45 <mauke> -1 is not a number
09:05:56 <faxathisia> arrg that always gets me
09:05:57 <sw17ch> (-1)
09:05:58 <vincenz> > enumFromThenTo 10 9 (-1)
09:05:59 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1]
09:06:25 <psykon> a function that removes a specific index from a list?
09:06:43 <Stinger> whos that well known functional data strucktures book by?
09:06:45 <vincenz> > let (a,b) = splitAt 10 [0..] in a ++ drop 1 b
09:06:46 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
09:07:09 <vincenz> Stinger: okasaki
09:07:39 <Stinger> ok cool got the right one
09:08:23 <vincenz> @pl \a b -> a ++ drrop 1 b
09:08:24 <lambdabot> (. drrop 1) . (++)
09:08:40 <vincenz> > uncurry ((. drop 1) . (++)) . splitAt 10 $ [0..]
09:08:47 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
09:09:21 <vincenz> @pl \1 -> x + 1
09:09:21 <lambdabot> (x +)
09:09:28 <sw17ch> @src uncurry
09:09:28 <lambdabot> uncurry f p = f (fst p) (snd p)
09:09:40 <faxathisia> :t uncurry
09:09:41 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
09:09:42 <faxathisia> :t curry
09:09:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
09:09:46 <faxathisia> The types say it better
09:13:14 <Codex_> :t curry id
09:13:15 <lambdabot> forall a b. a -> b -> (a, b)
09:14:00 <faxathisia> :t curry join
09:14:00 <lambdabot> forall a a1. (Monad ((,) a)) => a -> (a, a1) -> (a, a1)
09:14:17 <vincenz> does anyone know how to get the ... in latex ini mathmode
09:14:28 <Feuerbach> does hsql allow placeholders in statements (like '?' in perl's DBI)?
09:14:48 <jedbrown> vincenz: \dotsc
09:15:11 <Codex_> :t uncurry id
09:15:12 <lambdabot> forall b c. (b -> c, b) -> c
09:15:30 <Codex_> yes, uncurry id is much more interesting.
09:16:26 <conal> @ty app
09:16:26 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
09:16:39 <jedbrown> vincenz: the mnemonic is dots with commas: \dotsc, binary ops \dotsb, multiplication \dotsm, integrals \dotsi, other dots \dotso
09:16:47 <conal> app generalizes uncurry id
09:17:00 <conal> uncurry id is app for (->)
09:17:33 <vincenz> jedbrown: thx
09:17:39 <jedbrown> vincenz: You may need \usepackage{amsmath,amssymb}
09:17:46 <vincenz> jedbrown: already using :)
09:17:50 <Codex_> but it's interesting that the id is actually id_{a^b}, not plain id_a :)
09:18:14 <conal> ($)
09:25:03 <vininim> > let pick i xs = (chosen,rest) where {chosen = genericIndex xs i; splited = genericSplitAt i xs; rest = fst splited ++ (tail $ snd splited)} in pick 3 [1..10]
09:25:06 <lambdabot>  (4,[1,2,3,5,6,7,8,9,10])
09:25:57 <vininim> @pl pick i xs = (chosen,rest) where {chosen = genericIndex xs i; splited = genericSplitAt i xs; rest = fst splited ++ (tail $ snd splited)}
09:25:57 <lambdabot> (line 1, column 33):
09:25:57 <lambdabot> unexpected "{"
09:25:57 <lambdabot> expecting variable, "(", operator or end of input
09:26:08 <vininim> =P
09:27:48 <vincenz> jedbrown: dod you know how to place more spaces between two formulas on the same line?
09:27:51 <RayNbow> hmm, too bad my knowledge about arrows is close to non-existing... http://luqui.org/blog/archives/2007/09/06/quantum-entanglement-in-haskell/ seems like an interesting post
09:27:52 <lambdabot> Title: The dreams that stuff is made of  Quantum Entanglement in Haskell, http://tinyurl.com/36vlzc
09:32:28 <roconnor> @go 1 CAD in USD
09:32:29 <lambdabot> 1 Canadian dollar = 1.0003 U.S. dollars
09:32:47 <Corun> Blimey.
09:32:56 <Corun> Why distinguish? :-P
09:33:29 <monochrom> They used to differ.  1 CAD = 0.6-0.8 USD in the past.
09:33:35 <idnar> heh
09:33:48 <kaol> time to peg USD on CAD
09:34:05 <monochrom> They will again differ. 1 CAD = 1.1 USD in the future.
09:35:18 <jedbrown> 1 CAD > 2 USD in the way, way past.
09:35:46 <monochrom> (if the US elects another Republican, war-mongering president)
09:38:26 <Corun> Republican is synonymous for war-mongering, after all.
09:38:48 <mauke> so is democrat, curiously enough
09:39:56 <BMeph> mauke: Well, at least belligerence is a traditional Demo trait. Repubs seem to be trying to play catch-up. :|
09:40:15 <iagogz> hi. someone can help me? "type Foo a = StateT (Int, Int) (Writer [String]) a" in this case the Writer monad will generate a lazy log?
09:43:29 <roconnor> @unmtl StateT (Int, Int) (Writer [String]) a
09:43:29 <lambdabot> Int -> Int -> (a, Int, Int, [String])
09:43:45 <opqdonut> unmtl?
09:43:55 <opqdonut> ahh
09:44:21 <roconnor> iagogz: I think so
09:44:39 <opqdonut> @mtl (Int -> Int, Int -> Int, Int, [String])
09:44:39 <lambdabot> Maybe you meant: ft map msg pl unmtl url
09:44:46 <opqdonut> oh, it only works in one dir
09:45:53 <monochrom> the @mtl direction is a topic of reverse engineering :)
09:47:55 <opqdonut> well so is @unpl :P
09:48:16 * araujo throws some lambdas at shapr direction
09:48:31 * shapr beta reduces the lambdas
09:48:44 <araujo> :-)
09:50:03 <hpaste>  bogner pasted "RunOrRaisePrompt" at http://hpaste.org/5684
09:53:48 <scoo4114> hi all
09:55:15 <Saizan> hi
09:57:40 <shapr> hiya
09:58:13 <ddarius> bye
09:59:57 <shapr> That was exciting.
10:00:02 * shapr waits for the next passerby.
10:01:09 <faxathisia> @free map
10:01:12 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:01:28 <vincenz> @free willy
10:01:29 <faxathisia> not the theorem I wanted..
10:01:29 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `willy'\n\n"
10:01:36 <Lemmih> shapr: IRC is more exciting when studying C#?
10:01:51 <faxathisia> Can you make more than one theorem with it?
10:02:43 <shapr> Lemmih: Heck yeah.
10:03:33 <Lemmih> Jhc is a gold mine for performance minded people.
10:03:38 <shapr> How so?
10:03:43 <hpaste>  gwern pasted "syntax error? dunno what's with the commented lines" at http://hpaste.org/5685
10:03:44 * b_jonas passes by shapr
10:03:48 <RayNbow> @src length
10:03:48 <lambdabot> Source not found. My mind is going. I can feel it.
10:03:54 <faxathisia> aw...
10:03:54 <RayNbow> @src Data.List.length
10:03:55 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:04:01 <Lemmih> There's no good reason it is so slow and uses so much memory.
10:04:01 <shapr> b_jonas: I bet you're not in Boston!
10:04:02 <faxathisia> Why not add unicode support to hpase?
10:04:12 <shapr> faxathisia: Good idea! When can you have it finished?
10:04:14 <b_jonas> shapr: you won
10:04:22 <shapr> b_jonas: bah, I would rather have lost.
10:04:24 <RayNbow> lambdabot doesn't allow me to be lazy :p
10:04:25 <cjb> Lemmih: haha; I thought you meant that it was a goldmine in that it produces really fast code
10:04:28 <gwern> I am awfully confused about my error in http://hpaste.org/5685 since it is using implicit parameters obviously but it still doesn't work
10:04:30 <Lemmih> shapr: I changed 5 lines and now the base library compiles in 11 minutes instead of 19.
10:04:31 <shapr> Lemmih: Me too.
10:04:31 <b_jonas> @src genericLength
10:04:31 <lambdabot> genericLength []    = 0
10:04:31 <lambdabot> genericLength (_:l) = 1 + genericLength l
10:04:34 <cjb> but it seems you meant the opposite :)
10:04:37 <b_jonas> uh huh,
10:04:50 <faxathisia> well I'll give it a shot if I can get hpaste to build
10:04:58 * shapr considers driving a few miles to distract cjb from usefulness....
10:05:23 <shapr> Nah, that would be mean.
10:05:51 <shapr> Lemmih: you have patches online?
10:06:01 <Lemmih> shapr: I've sent them to jhc@haskell.org
10:06:47 <shapr> I discovered I shouldn't try to build both Linux and JHC with only 4 gb of ram.
10:07:06 <Lemmih> There's a lot of low hanging fruit. An order of magnitude increase in performance isn't out of the question.
10:07:08 <gwern> I tried replacing it with '| ((optsOk with ?opts)= opts)  ((start with ?opts) = opts)' but that doesn't seem to work
10:09:40 <gwern> hm, jhc doesn't build after the latest pull
10:10:35 <gwern> make clean; autoreconf -i; make all - errors
10:10:45 <hpaste>  gwern pasted "jhc build error" at http://hpaste.org/5686
10:11:27 <Lemmih> gwern: Weird, I
10:11:36 <Lemmih> gwern: Weird, I've never seen that before.
10:12:12 <gwern> me neither
10:12:19 <gwern> it build fine before I pulled today
10:12:39 <Lemmih> Try ./configure again?
10:13:23 <gwern> no, that changes nothing
10:17:12 <faxathisia> darcs get --partial http://darcs.haskell.org/cabal-install/ # takes a long time..
10:17:13 <lambdabot> Title: Index of /cabal-install
10:18:13 <cjb> people should do darcs releases more often, then --partial becomes fast.
10:18:35 <gwern> checkpoints ftw
10:21:00 <shapr> faxathisia: Isn't cabal-install part of cabal these days?
10:21:02 <fnord`> hi all
10:21:37 <fnord`> I'm trying to install gtk2hs on ubuntu but apt-get complains that the instaled copy of ghc is to great
10:21:43 <fnord`> anyone else had that problem?
10:22:12 <dons> http://reddit.com/info/68vtg/comments/ Haskell jobs for y'all
10:22:15 <faxathisia> I don't know
10:24:30 <shapr> Hm, where have I heard of this Peter guy?
10:24:56 <gwern> 'PS: This job offer was already placed in the Haskell Caf a while ago, but apparently many Haskellers did not notice it, so heres take#2'
10:25:15 <shapr> heh
10:25:17 <gour> @seen ndm
10:25:17 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 2h 4m 59s ago, and .
10:25:31 <gwern> @hoogle sleep
10:25:38 <lambdabot> No matches found
10:25:45 <gwern> @hoogle System.Posix.sleep
10:25:46 <lambdabot> No matches, try a more general search
10:29:56 <dons> only in the Haskell community would you see: "Why are loops so popular?"
10:30:04 <cjb> haha
10:30:27 <cjb> "next on Planet Haskell:  'if' statements:  What's Up With That?"
10:30:28 <faxathisia> maybe the APL or J communities
10:31:53 <dons> woot. wxHaskell on hackage
10:31:58 <dons> kowey++
10:32:19 <dons> dcoutts: gtk2hs next??
10:32:20 <gwern> :t (=)
10:32:36 <lambdabot> thread killed
10:32:47 <faxathisia> = doesn't have a type
10:32:58 <gwern> unpossible
10:33:04 <gwern> :t (==)
10:33:05 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:33:32 <gwern> Downloading 'wxcore-0.10.1'...
10:33:32 <gwern> -=-= Cabal executing: ./configure --with-hc=ghc --prefix=/home/gwern/.cabal --bindir=/home/gwern/.cabal/bin --libdir=/home/gwern/.cabal/lib/wxcore-0.10.1/ghc-6.8.2 --libexecdir=/home/gwern/.cabal/libexec --datadir=/home/gwern/.cabal/share/wxcore-0.10.1=-=-
10:33:36 <gwern> Configure failed.
10:33:40 <gwern> 'error: Unknown option "--bindir=/home/gwern/.cabal/bin". Use "--help" to show valid options.
10:33:44 <gwern> :(
10:34:06 <dons> dcoutts: "I was playing with Cairo's Haskell API, and I find it a beautifully written DSL."
10:34:35 <faxathisia> It seems that cabal-install is not part of cabal
10:34:49 <gwern> cjb: 'Conditionals Considered Harmful, or why you should use pattern matching' :)
10:35:16 <daf> dons: who said that?
10:36:02 <gwern> faxathisia: don't think so. I had to install it separately
10:36:02 <b_jonas> faxathisia: yep
10:36:09 <b_jonas> cabal-install is an experimental thing
10:36:12 <vincenz> > 5000 / 35
10:36:12 <shapr> Huh, how did I get "cabal install yi" ?
10:36:18 <shapr> It works for me.
10:36:21 <b_jonas> it's not the "recommended" way to install cabal packages
10:36:27 <lambdabot>  thread killed
10:36:28 <faxathisia> cabal-install gave me the binary cabal
10:36:36 <faxathisia> cabal just makes a lib I think?
10:37:22 <faxathisia> aww.. cabal: Error: some packages failed to install:  HAppS-0.8.4
10:38:09 <dons> daf: comment on reddit
10:38:26 <dons> b_jonas: its almost the recommended way :)
10:38:50 <daf> dons: Cairo's C API has been praised; it's interesting that it translates well to Haskell
10:39:07 <doserj> dons: ETA for new version on hackage?
10:39:25 <dons> daf: http://reddit.com/r/programming/info/68uaz/comments/c036xq5
10:39:29 <dons> doserj: for cabal-install?
10:39:37 <doserj> yep
10:39:47 <dons> dcoutts is maintainer, he'll know.
10:40:22 <b_jonas> daf: I guess the two relate
10:40:33 <b_jonas> that is, a good api and one that translates well to any good language
10:40:40 <daf> I find that surprising
10:40:55 <daf> it seems that the ability to hide the context in the monad is one thing that makes it work well here
10:41:04 <dons> the haskell lib is able to abstract out the drawing context plumbing
10:41:08 <dons> yep.
10:41:16 <daf> C doesn't have monads, so either it's just a coincidence
10:41:22 <daf> or there is something deeper at work
10:42:44 <gwern> :t with
10:42:44 <lambdabot> Not in scope: `with'
10:42:48 <gwern> @hoogle with
10:42:48 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
10:42:48 <lambdabot> Foreign.ForeignPtr.withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
10:42:48 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
10:43:10 <faxathisia> b_jonas, what is the recommended way?
10:43:16 <faxathisia> (cabal didn't work for me)
10:43:48 <b_jonas> faxathisia: http://www.haskell.org/haskellwiki/How_to_install_a_Cabal_package
10:43:49 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki
10:43:54 <faxathisia> thanks
10:44:50 <gwern> gah. I've almost got this linkchk program whipped, except for these guards using implicit paramaters weirdly, and it wants something called 'with'?
10:44:57 <shapr> ?
10:46:09 <gwern> :t getOpt
10:46:25 <lambdabot> thread killed
10:47:15 * gwern groans. guess I need to read up on implicit parameters
10:47:48 <doserj> with (used to be?) is used to bind implicit parameters
10:48:40 <faxathisia> grrrr
10:49:03 <faxathisia> % runhaskell Setup.hs configure
10:49:07 <faxathisia> Warning: No 'build-type' specified. If possible use 'build-type: Simple'.
10:49:43 <faxathisia> oh well ./configure ; make works  (for HaXml)
10:51:35 <gwern> doserj: it doesn't seem to be there anymore
10:52:57 <faxathisia> ugh .. installing stuff is painful
10:53:08 <doserj> gwern: just use let then :)
10:53:16 <gwern> doserj: I don't know how :(
10:53:23 <faxathisia> is HaXml working?L
10:53:45 <doserj> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#id407478
10:53:46 <shapr> faxathisia: Hey, you use dvorak!
10:53:46 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
10:53:59 <gwern> ' optsOk with ?opts = opts' == 'let ?opts = opts in optsOK'? dunno
10:54:07 <taruti> Is there currently a *working* way of piping a ByteString through a shell command with GHC? Ignoring System.Process altogether and using only System.Posix.* ?
10:54:25 <faxathisia> shapr, not well, certainly :p
10:54:45 <shapr> That's cool, I just thought I knew every dvorak user on #haskell.
10:54:50 <faxathisia> HaXml-1.13.3 seems broken anyway
10:55:03 <doserj> gwern: seems ok
10:55:09 <shapr> faxathisia: broken how?
10:55:10 <faxathisia> shapr, I just switched a couple weeks ago
10:55:23 <shapr> spiffy!
10:55:24 <gwern> taruti: how would that make sens? shell commands have no conception of bytestrings, just normal strings. you'd need to unpack into string and then repack
10:55:29 <shapr> Welcome to the aoeu club!
10:55:38 <faxathisia> I got a tarball and I had to edit the makefile but it still didn't build...
10:55:47 <Corun>  ++ 'y'
10:55:50 <faxathisia> Configuring HAppS-Server-0.9.1... says At least the following dependencies are missing:  HaXml >=1.13&&<1.14,
10:55:51 <taruti> gwern: well with normal Strings?
10:56:00 <shapr> faxathisia: I bet it works with 1.13.2 ?
10:56:04 <gwern> taruti: and dunno how you'd execute /bin/sh without System.Process
10:56:06 <hpaste>  taruti pasted "nearly works, except hPutBuf complaining to stderr" at http://hpaste.org/5687
10:56:10 <faxathisia> but cabal install thinks I don't have it
10:56:20 <gwern> taruti: you'd want to go through /bin/sh I think because it knows the $PATH
10:56:21 <faxathisia> oh cool, I'll try
10:56:46 <shapr> Oh is there a tutorial for doing shell scripting in Haskell?
10:56:47 <taruti> gwern: the problem is handling all the pipes and child processing dying too early.
10:57:01 <gwern> shapr: no. I just use HSH
10:57:12 <shapr> Have you tried the other options?
10:57:24 <taruti> I think that using System.Posix to do the io to the process should work, but that seems dirty.
10:57:33 <gwern> taruti: if you aren't doing this as a learning experience, you might want to look into how the HSH library does things
10:59:22 <taruti> gwern: that uses System.Posix.*
11:01:19 <taruti> a portable way would be nice. (then again my code uses posix for the signal handlers, but I think they could be omitted on windows)
11:01:40 <gwern> you want portable shell scripting on Posix and Windows?
11:01:50 <faxathisia> trouble trying to get it :[
11:01:55 <faxathisia> for example,  ftp ftp://ftp.cs.york.ac.uk/pub/haskell/HaXml/
11:02:00 <faxathisia> does not seem to work..
11:03:21 <taruti> gwern: mostly just pipe things through external commands.
11:03:35 <Syzygy-> byorgey: Response to your post written. http://blog.mikael.johanssons.org/archive/2008/02/props-and-patches/
11:03:37 <lambdabot> Title: Michi&#8217;s blog  Blog Archive  PROPs and patches, http://tinyurl.com/2ht6jz
11:03:54 <Syzygy-> Short version: I think PROPs might be a better formalism than categories for tracking patches.
11:04:19 <gwern> taruti: I don't think there's really a portable way to do that. windows does things a lot differently from Posix, right down to the text itself (line-endings, for example)
11:05:01 <monochrom> patch theory is a patchy theory  <duck>
11:06:51 <ricky_clarkson> That duck gets everywhere.
11:07:52 <gwern> (AFLAC!!!)
11:08:31 <faxathisia> I can't get HaXml so it looks like I wont be able to build hpaste
11:11:39 <hpaste>  faxathisia pasted "building HaXml failure" at http://hpaste.org/5688
11:12:01 <faxathisia> no one knows how to deal with that, when running make?
11:12:28 <gwern> isn't haxml cabalized?
11:12:59 <monochrom> Yes!
11:13:16 <faxathisia> I can't get it with cabal, since it claims I already have it (which I don't..)
11:13:18 <monochrom> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HaXml-1.19.2
11:13:21 <lambdabot> http://tinyurl.com/2f53ao
11:14:00 <glguy> Building hpaste is something of an adventure
11:14:18 <glguy> I should add a CRPG style conversation tree to the build process
11:14:21 <glguy> to round it out
11:14:23 <monochrom> build hpaste, don't make haste
11:14:26 <faxathisia> lol
11:14:43 <Saizan> glguy: you need the darcs version of the 0.8.8 HAppS branch, what more?
11:15:36 <glguy> Saizan: I think that it's just a matter of getting the right HAppS and it's deps
11:16:01 <monochrom> "You enter a room. dons, Cales, and Oleg are there. Which one do you ask for his autograph?  dons->pg13, Cales->pg45, Oleg->pg2"
11:16:11 * shapr grins
11:16:22 <shapr> I would instead ask them all to go to lunch with me.
11:16:33 <nominolo> what is pg?
11:16:37 <monochrom> page
11:16:38 <mauke> pagina
11:16:41 <glguy> pg13: YOu notice that the autograph is upside down
11:16:46 <glguy> you stand on your head to read it
11:16:52 <monochrom> hhaahahhaha
11:18:00 <dons> Igloo: would a pure haskell readline implementation solve any license, bootstrap problems?
11:19:47 <faxathisia> http://happs.org/repos/
11:19:49 <faxathisia> Irritating...
11:19:52 <faxathisia> Directory index forbidden
11:20:10 <faxathisia> So I don't know how to get HAppS 0.8.8
11:20:12 <glguy> Directory index not implemented?
11:20:24 <nominolo> +x not set
11:21:05 <Igloo> dons: It would make things a little simpler. It won't affect licensing once we move to editline
11:22:00 <sclv_> faxathisia: Are you trying to build hpaste?
11:22:07 <faxathisia> I was
11:22:19 <sclv_> I tried the other night and it was a mess.
11:22:25 <faxathisia> It's very hard..
11:22:28 <sclv_> I finally found some debian package of 8.8, but it was a different build than the one hpaste was built on.
11:22:34 <faxathisia> I can't get HAppS though
11:22:44 <faxathisia> I suppose if I could hpaste would be easy
11:22:46 <sclv_> And sufficiently different enough that like 1/2 the APIs changed...
11:23:14 <sclv_> You really just need to get lucky and find someone with the exact right source snapshot as far as I can tell.
11:23:29 <faxathisia> ok I think I'll just give up in that case
11:23:42 <glguy> are you trying with the hpaste-devel repo?
11:24:13 <faxathisia> I could do, I hadn't got to the stage of trying to compile hpaste yet though
11:24:57 <glguy> following happs is the reason I stopped developing hpaste
11:25:53 <Saizan> i did port hpaste to some 0.9.x HAppS version, but not the latest
11:26:37 <Saizan> however if you get stopped by not being able to build HaXml you're not enough brave for this :)
11:27:10 <glguy> come back in a few levels
11:27:40 <glguy> time for dungeon crawling!
11:28:04 <glguy> You need to find the builder's hammer +1
11:28:18 <glguy> and the *old rusty key*
11:39:51 * RayNbow looks at the Haskell 3D job...
11:39:55 * RayNbow doesn't qualify :p
11:41:03 <cjb> RayNbow: whether you qualify is a matter of how desperate they are :)
11:41:09 <RayNbow> true :p
11:41:15 <RayNbow> but I don't have a MSc
11:41:20 * RayNbow is still a student :p
11:41:45 <cjb> that's usually not a hard requirement.  some of the best Haskell programmers don't.
11:42:02 <RayNbow> and I don't have a lot of formal work experience
11:42:06 <cjb> but being actually available to work for them usually is :)
11:42:58 <RayNbow> Fluent in English; Place of work: Antwerp (Belgium) with limited home work <-- I was expecting "Fluent in Vlaams"
11:57:30 <roconnor> RayNbow: I'd consider applying myself, but I bet they don't pay me what I'm worth :D
11:58:45 <gwern> roconnor: ask them to pay you what you think you're worth
11:59:21 <roconnor> $1 000 000 :L
11:59:25 <gwern> or, if you're overconfident, ask them to pay you what you're worth plus x% more where that's the difference between what you're worth and what you think you're worth
11:59:45 <psykon> is there a way to specify an "otherwise" pattern on a case expression ?
11:59:51 <gwern> _?
11:59:55 <daf> psykon: yes, "otherwise"
11:59:55 <hpaste>  edbond pasted "(no title)" at http://hpaste.org/5690
12:00:05 <roconnor> psykon:  _
12:00:09 <desegnis> daf: you're thinking of guards
12:00:13 <roconnor> daf: otherwise is for gaurds
12:00:16 <psykon> roconnor: thanks
12:00:21 <ddarius> @src otherwise
12:00:22 <lambdabot> otherwise = True
12:00:26 <roconnor> > otherwise
12:00:29 <edbond> Hello All. Can someone look at hpaste?
12:00:30 <lambdabot>  True
12:00:32 <twanvl> edbond: you need to give an implementation of 'forecast'
12:00:42 <daf> > case 3 of 4 -> "yes"; otherwise -> "no"
12:00:43 <edbond> twanvl: thanks
12:00:44 <lambdabot>  "no"
12:01:09 <twanvl> if you don't want to do that just yet, you could say 'forecast = undefined'
12:01:11 <roconnor> daf: otherwise is a variable being bound to 3 in that example
12:01:18 <daf> true
12:01:25 <daf> isn't it idiomatic though?
12:01:26 <roconnor> > case 3 of 4 -> "yes"; otherwise -> "no"++show otherwise
12:01:27 <lambdabot>  "no3"
12:01:31 <twanvl> daf: that can be terribly confusing
12:01:39 <roconnor> daf: nope, it is error prone.
12:01:46 <ddarius> daf: No, it's not idiomatic.
12:01:54 <daf> ok, just a bad habit I invented then
12:01:57 <lament> so otherwise is not True but something really magical?
12:02:01 <ddarius> case 3 of 4 -> "yes"; _ -> "no" is idiomatic
12:02:04 <roconnor> daf: it is error prone because it shadows the value of otherwise
12:02:12 <ddarius> lambdabot: What?
12:02:15 <ddarius> Doh.
12:02:19 <desegnis> lament, where do you observe magic?
12:02:19 <ddarius> lament: What?
12:02:40 <lament> why does that change the value of otherwise? Isn't otherwise supposed to be True?
12:02:56 <desegnis> > let x = 1 in (let x = 2 in x)
12:02:57 <lambdabot>  2
12:03:00 <ddarius> > case 3 of 4 of show -> show
12:03:01 <lambdabot>  Parse error at "of" (column 13)
12:03:08 <ddarius> > case 3 of show -> show
12:03:08 <lambdabot>  3
12:03:23 <resiak> lament: the same way that 'let a = 3 in let a = 4 in a' evaluates to 4
12:03:31 <ddarius> otherwise is just being shadowed (which makes it even -more- clear that it isn't "magic" or "special")
12:03:52 <lament> that's disgusting.
12:03:59 <litb> hi
12:04:56 <twanvl> > let otherwise=False in  case () of () | 1 == 2 -> "wrong"  | otherwise -> "good thing we have a fall through case"
12:04:57 <lambdabot>   Non-exhaustive patterns in case
12:05:23 <bringert> > let 1+2=4 in 1+2
12:05:24 <lambdabot>  4
12:05:27 <daf> is _ an ordinary variable?
12:05:32 <ddarius> It's not a variable.
12:07:45 <psykon> are there any VTY docs?
12:08:07 <sorear> yes
12:08:22 * gwern wonders what monadgarden.com is. top level is inaccessible
12:08:33 <psykon> where? haskell.org doesn't seem to have a link :|
12:08:41 <b_jonas> which VTY?
12:08:58 <psykon> the terminal interface?
12:09:14 <sorear> b_jonas: presumably the haskell library I'm currently stuck maintaining
12:09:14 <b_jonas> then there is
12:09:23 <b_jonas> oh, for the library?
12:09:32 <b_jonas> I dunno then
12:09:32 <ddarius> sorear: Didn't you write it?
12:09:38 <sorear> yes
12:09:39 <psykon> sorear: where are they then? :)
12:09:49 <psykon> in the tarball?
12:10:11 <gwern> in haskell, we don't write docs. we let haddock infer everything from the types
12:10:11 <sorear> psykon: the docs are generated manually iirc, you'll need to poke ross or look at the doc comments in the source
12:10:36 <sorear> I think I have a set of haddocks somewhere, no clue how out of date
12:11:01 <faxathisia> :t \x -> case x of 1543 -> undefined ; True -> undefined ; _ -> undefined
12:11:03 <psykon> is haddock some super AI that figures out what you meant? :)
12:11:03 <lambdabot>     No instance for (Num Bool)
12:11:03 <lambdabot>       arising from the literal `1543' at <interactive>:1:16-19
12:11:03 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
12:11:18 <Stinger> you can pattern match against function application?
12:11:32 <ddarius> Stinger: no
12:11:33 <Stinger> (aside from type constructors)
12:11:48 <b_jonas> (and +n patterns)
12:12:00 <Stinger> oh right special case for +n
12:12:08 <Stinger> fair enough then
12:12:14 <b_jonas> (and to implicit applications of fromIntegral and fromRational)
12:12:30 <b_jonas> (which are compared by the (==) method)
12:17:07 <opqdonut> ahh
12:20:47 <bringert> > case False of { True -> 1; otherwise | otherwise -> 2 }
12:20:49 <lambdabot>   Non-exhaustive patterns in case
12:21:11 <bringert> just another example of bad use of otherwise as a pattern
12:22:23 <mauke> you "win"
12:42:24 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/5692#a1
12:42:54 <roconnor> Igloo: that's a good summary
12:44:16 <Igloo> roconnor: Great. Now we just need to pick one  :-)
12:44:37 <roconnor> Igloo: an impossible task
12:44:49 <roconnor> where is a miltary dictator when you need one.
12:44:59 <monochrom> Me.
12:45:18 <roconnor> monochrom: what is the name of the function with type [Either a b] -> ([a],[b])?
12:45:39 <jaredj> "ME! THE EMPEROR!" - The Dark Crystal
12:45:43 <monochrom> Ah, that one.
12:46:11 <Stinger> roconnor, segregate
12:46:17 <roconnor> monochrom: Igloo has a list of candidate names
12:46:30 <monochrom> centrifuge
12:46:33 <Igloo> I think I like leftsAndRights
12:46:35 <roconnor> splitEithers, unzipEithers, partitionEithers, catEithers, leftRights, leftsAndRights, boths, demuxEithers
12:46:45 <roconnor> Stinger: spoken like a true military dictator.
12:47:04 <ddarius> For the love of Jesus, you guys are still on that?!
12:47:14 <roconnor> ddarius: it's been several years
12:47:21 <monochrom> hahahaha
12:47:27 <twanvl> I think it should be consistent with catMaybes
12:47:35 <roconnor> @type catMaybes
12:47:39 <lambdabot> forall a. [Maybe a] -> [a]
12:47:52 <Igloo> twanvl: Couldn't catEithers be [Either a a] -> [a] though?
12:48:08 <ddarius> Simply 'demux' seems nice.
12:48:12 <twanvl> yes, cat is the wrong name
12:48:20 <Stinger> who the hell uses Either a a
12:48:23 <Igloo> I think demux is far too general
12:48:45 <ddarius> True.  So let's make a general demux with this a special case.  Then we don't need to think up a name.
12:48:56 <monochrom> I eliminate "splitEithers" because "split" means something else in Prelude tradition.
12:48:59 <Stinger> collectEithers
12:49:08 <roconnor> monochrom: I agree.
12:49:43 <twanvl> I think unzipEithers makes it clear what the function does without seeing the type (assuming you know unzip)
12:49:47 <monochrom> I eliminate all those with "left" and "Right" because, well, look at how they are differently capitalized!
12:49:58 <roconnor> I must point out that unzipEithers to be the most common name people make up for this function.
12:50:07 <jaredj> twanvl: but otoh it could imply they come in pairs
12:50:27 <twanvl> partitionEithers is also quite nice
12:50:28 <ddarius> (A+B)^* -> A^* x B^*
12:50:36 <roconnor> although I perfer partitionEithers.
12:51:08 <glen_quagmire> > (A+B)^* :: Expr
12:51:09 <lambdabot>  Parse error at "::" (column 9)
12:51:19 <psykon> sorear: hey, so where should i go to getting started using VTY ?
12:51:28 <monochrom> "catEither" - what others say.  "boths" - hmm, not a mnemonic.  "demuxEithers" - somehow not a mnemonic either, since the majority may not have heard of demux.
12:51:42 <monochrom> I think it's a close tie between unzipEither and partitionEither.
12:51:54 <ddarius> I rather dislike unzipEither
12:51:54 <opqdonut> partition seems better
12:52:37 <jaredj> filterEithers?
12:52:37 <Cin> blargh!
12:52:43 <monochrom> Oh, "unzip" means a different thing in Prelude tradition too!
12:53:01 <roconnor> monochrom: what does unzip mean?
12:53:14 <monochrom> Namely, unzip xs = (ys,zs) ==> length xs = length ys = length zs.
12:53:38 <opqdonut> well unzip is kinda appropriate, except that now we have a sum type instead of a product type
12:53:42 <opqdonut> but i still don't like it
12:53:56 <jaredj> The Max dataflow language has a "moses" primitive that takes all inputs less than its parameter to one output, and all things greater than equal to its other output
12:54:15 <roconnor> this function is more like partition than unzip.
12:54:24 <roconnor> by a little bit.
12:54:28 <opqdonut> jaredj: :D
12:54:42 <ddarius> I think partitionEither is a fine name and I believe that is the one I liked most last time this was brought up.
12:54:53 <opqdonut> yeah, it's fine
12:54:58 <roconnor> ddarius: I tend to agree
12:55:04 <RayNbow> @pl (\l -> concat $ map (setWidth (maxWidth l)) l)
12:55:05 <lambdabot> join . (map =<< setWidth . maxWidth)
12:55:20 <roconnor> ddarius: the only possible objection to partitionEithers is that it should be (a -> Either b c) -> [a] -> ([b],[c])
12:55:37 <roconnor> ddarius: but I think that person withdrew their objection.
12:55:45 <twanvl> that is mapEithers (at least in Data.Map)
12:55:46 <monochrom> "unzip" suggests length preservation. "partition" suggests sublisting.
12:56:02 <monochrom> Ah.
12:56:09 <opqdonut> :)
12:56:12 <roconnor> @type Data.Map.mapEithers
12:56:14 <lambdabot> Not in scope: `Data.Map.mapEithers'
12:56:29 <ddarius> @hoogle mapEither
12:56:30 <lambdabot> Data.Map.mapEither :: Ord k => (a -> Either b c) -> Map k a -> (Map k b, Map k c)
12:56:30 <lambdabot> Data.IntMap.mapEither :: (a -> Either b c) -> IntMap a -> (IntMap b, IntMap c)
12:56:30 <lambdabot> Data.Map.mapEitherWithKey :: Ord k => (k -> a -> Either b c) -> Map k a -> (Map k b, Map k c)
12:57:00 <roconnor> okay, so is it partitionEither or partitionEithers?
12:57:21 <twanvl> it is also catMaybes
12:57:22 <monochrom> Well, one can argue that "partition" alone requires an extra predicate, while "partitionEither" the "Either" means that predicate is implicit.
12:57:33 <roconnor> monochrom: I agree
12:57:55 <roconnor> @type partition.
12:58:02 <roconnor> oops
12:58:05 <roconnor> nevermind.
12:58:07 <lambdabot> parse error (possibly incorrect indentation)
12:59:43 <twanvl> the reason for calling it partitionEithers (plural) is that you pass in multiple Eithers, and the list of those Eithers is partitioned
13:01:44 <monochrom> I like demux personally, but I wonder how many software programmers still remember their computer hardware lessons.
13:02:08 <roconnor> monochrom: I like the idea of making a demux class :)
13:02:12 <ddarius> What kind of programmer doesn't know what demux means?
13:02:22 <monochrom> Likewise, I like most my own "centrifuge" (of course), but I wonder how many software programmers still remember their chemistry lessons!
13:02:51 <roconnor> Stinger's suggestion is the most dictator like.
13:03:00 <monochrom> I know very fine CS profs who don't know what mux means.
13:03:14 <ddarius> monochrom: "centrifuge" is metaphorical.  "demux" is -exactly- what the function is doing.
13:03:17 <resiak> one of my cs lecturers today used 'dmux' as the opposite o 'mux'
13:03:27 <resiak> is it ever used without the e?
13:03:35 <twanvl> using a different word for each function is a bad idea, it makes it harder to guess the meaning if you haven't seen the function before.
13:03:50 <monochrom> Starting from some time ago, probably more so in some places than others, programmer education skips hardware.
13:03:51 <ddarius> ... no, the "de-" prefix is an English language thing.
13:04:09 <resiak> right
13:04:36 <monochrom> Moreover, where it is not skipped, you can't count on students caring about it anyway.
13:04:56 <oerjan> @users
13:04:57 <lambdabot> Maximum users seen in #haskell: 469, currently: 464 (98.9%), active: 24 (5.2%)
13:04:57 <ddarius> multiplexing and demultiplexing aren't just hardware concepts
13:05:15 <monochrom> Recall that college/university education is self-selecting. There are reasons why software engineering students chose software engineering.
13:05:30 <lament> money!
13:05:32 <lament> and girls!
13:05:33 <lament> and fame!
13:05:36 <monochrom> (This completely explains: A. they suck in hardware; B. they suck in writing documentation.)
13:06:01 <monochrom> (If they cared about hardware, they would go to computer engineering)
13:06:14 <monochrom> (If they cared about writing prose, they would go to artsies.)
13:06:19 <wy> I remember someone recommended The Reasoned Schemer some days ago
13:06:19 <lambdabot> wy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:07:30 <wy> Now I got it but I couldn't find the guys ;)
13:07:42 <Cin> any northern-english haskellers in the channel tonight, fany meeting up for a coffee and All-you-can-eat chinese tomorrow? :))
13:07:56 <Cin> (preferred location, manchester)
13:08:05 <cjb> Cin: oh, I didn't know you were in Manchester
13:08:32 <cjb> I did undergrad there.  But now I'm in the US.
13:08:41 <Cin> ah, that's cool :)
13:09:18 <Cin> i'm in Wigan, but Manchester is some 20 minutes away via train and a nice central point
13:09:39 <cjb> neat.  is there any functional programming in Wigan?  :)
13:10:00 <Cin> not that i've seen. yet! :P
13:10:11 <taruti> Is it intentional that parseTime handles symbolic locales (e.g. EET) as UTC with %Z?
13:13:31 <monochrom> Likely not intentional.
13:14:00 <psykon> is anyone here responsible for hscurses?
13:15:57 <glen_quagmire> what is   done :: IO () ?
13:16:05 <glen_quagmire> "done does nothing"
13:16:09 <roconnor> @src done
13:16:10 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:16:15 <roconnor> @hoogle done
13:16:16 <lambdabot> Control.Parallel.Strategies.Done :: type Done
13:16:30 <ShockSMX> anyone here write haskell code in windows?
13:16:35 <ShockSMX> if so, what editor do you use?
13:16:58 <mahogny> I guess most would use visual studio
13:17:04 <Stinger> emacs of course
13:17:25 <ShockSMX> Stinger: yeah, i fired up XEmacs. i'm trying to figure out how to configure haskell-mode for it.
13:17:54 <ShockSMX> Stinger: i can't find init.el
13:17:58 <shapr> mahogny: seriously?
13:17:58 <glen_quagmire> i'm trying to write putStr in terms of putChar and foldr
13:18:16 <glen_quagmire> foldr (>>) done . map putChar  -- what the book says
13:18:33 <monochrom> @src sequence_
13:18:33 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:18:45 <stevan> hi, is there already a function or perhaps an other easier way of doing this: http://hpaste.org/5695
13:18:47 <monochrom> use return() for done :)
13:19:09 <desegnis> :t mapM_ putChar
13:19:11 <lambdabot> [Char] -> IO ()
13:19:16 <Stinger> not to familiar with xemacs
13:19:19 <monochrom> @src mapM_
13:19:19 <lambdabot> mapM_ f as = sequence_ (map f as)
13:19:23 <monochrom> hehehe
13:19:31 <glen_quagmire> > (foldr (>>) (return () . mapM_ putChar)) "hola"
13:19:32 <lambdabot>  Couldn't match expected type `[Char] -> a'
13:19:35 <Stinger> for emacs theres a registry key you can set as your home dir
13:20:04 <ShockSMX> Stinger: i know what it thinks my homedir is, it's c:\documents and settings\account name\
13:20:09 <monochrom> Eh? No one suggested foldr (>>) (return () . mapM_ putChar)
13:20:09 <ShockSMX> Stinger: but there's no init.el there
13:20:21 <mahogny> shapr, well, that is what visual haskell is based on right? I dunno. I haven't had windows on this computer the past 6 years :)
13:20:33 <Stinger> oh well, make one then :)
13:20:40 <shapr> mahogny: Oh, good point. I wonder if Visual Haskell works with Visual Studio 2008 ?
13:20:41 <ShockSMX> aiight
13:21:04 <mahogny> no idea. I wouldn't touch VS with a stick
13:21:18 <monochrom> Very strange that if you hit Nothing you stop.
13:21:31 <Stinger> I think I heard of a fairly reasonable vs plugin
13:21:47 <Stinger> haven't looked at it though
13:21:55 <cjb> shapr: hey, daf is going to be in town the week after next, maybe a good time to start CHUG.
13:22:11 <roconnor> twanvl: why is catEithers the wrong name?  (not that I disagree with you)
13:22:14 <glen_quagmire> > foldr (>>) (return ()) $ (map putChar) "hey"
13:22:15 <Stinger> heh chug, I like it
13:22:20 <lambdabot>  <IO ()>
13:22:30 <Feuerbach> was Python the first language which introduced 2d code layout?
13:22:45 <shapr> cjb: The founder of Galois will be in town sometime soon.
13:22:51 <shapr> cjb: Yeah, time to get something moving.
13:22:51 <opqdonut> Feuerbach: wouldn't think so
13:22:59 <cjb> that's cool.  but let's not have a sales pitch :)
13:23:03 <shapr> heh
13:23:03 <desegnis_> @age python
13:23:03 <lambdabot> Maybe you meant: arr ask
13:23:07 <Feuerbach> opqdonut: what then?
13:23:08 <mahogny> Feuerbach, my language had it before ;) and there are probably more mainstream ones that had it before
13:23:29 <shapr> cjb: Got any ideas for a venue?
13:23:31 <ShockSMX> this? http://www.haskell.org/visualhaskell/
13:23:32 <lambdabot> Title: Visual Haskell
13:23:45 <ShockSMX> Feuerbach: i doubt it
13:23:55 <cjb> shapr: perhaps someone like Greg would get us a room at MIT
13:24:05 <roconnor> monochrom: why is catEithers the wrong name?  (not that I disagree with you)
13:24:05 <shapr> Yeah, good idea.
13:24:25 <ddarius> roconnor: Why is catMaybes called catMaybes?
13:24:44 <glen_quagmire> :t  foldr (>>) (return ()) $ (map putChar)
13:24:46 <monochrom> Someone suggested catEithers :: [Either a a] -> [a], and I agree.
13:24:46 <lambdabot>     Couldn't match expected type `[m a]'
13:24:46 <lambdabot>            against inferred type `[Char] -> [IO ()]'
13:24:46 <lambdabot>     In the second argument of `($)', namely `(map putChar)'
13:24:55 <roconnor> @src catMaybes
13:24:56 <lambdabot> catMaybes ls = [x | Just x <- ls]
13:25:08 <glen_quagmire> why is that? :t fold (>>) (return ())    and    :t map putChar  seem to be compatible
13:25:18 <Feuerbach> I found this: http://en.wikipedia.org/wiki/ABC_programming_language
13:25:19 <lambdabot> Title: ABC (programming language) - Wikipedia, the free encyclopedia
13:25:21 <roconnor> ddarius: because it is concatMap fromMaybe ?
13:25:38 <Saizan> glen_quagmire: you need to apply map putChar to a list
13:25:40 <ddarius> roconnor: That would be a ridiculous reason.
13:25:42 <monochrom> Because ($) is not (.)
13:25:42 <glen_quagmire> map putChar  is [Char] -> [IO ()]  ..   foldr (>>) (return ()) :: [m a] -> [m ()]
13:25:50 <Saizan> glen_quagmire: or use (.) instead of ($)
13:26:13 <roconnor> ddarius: why is catMaybes called catMaybes?
13:26:35 <ddarius> roconnor: If I knew, I wouldn't be asking.
13:26:36 <siti> concatMaybes ?
13:26:52 <roconnor> @type concatMap fromMaybe
13:26:53 <lambdabot>     Couldn't match expected type `[b]'
13:26:53 <lambdabot>            against inferred type `Maybe a -> a'
13:26:53 <lambdabot>     Probable cause: `fromMaybe' is applied to too few arguments
13:27:13 <roconnor> @type fromMaybe
13:27:14 <lambdabot> forall a. a -> Maybe a -> a
13:27:21 <roconnor> that's not what I want
13:27:26 <roconnor> @hoogle Maybe a -> [a]
13:27:27 <lambdabot> Data.Maybe.maybeToList :: Maybe a -> [a]
13:27:29 <Saizan> i always associated it with the unix cat
13:27:30 <ddarius> :t maybe [] (:[])
13:27:34 <lambdabot> forall a. Maybe a -> [a]
13:27:38 <roconnor> @type concatMap maybeToList
13:27:41 <lambdabot> forall a. [Maybe a] -> [a]
13:27:43 <glen_quagmire> Saizan: oh than k you
13:28:06 <hpaste>  mjf pasted "doCenterFloat - help me with a simple hack, please" at http://hpaste.org/5696
13:29:11 <wy> Is there any work on FP at MIT currently?
13:29:33 <wy> wagle: hey
13:31:23 <wagle> wy, howdy
13:31:23 <lambdabot> wagle: You have 1 new message. '/msg lambdabot @messages' to read it.
13:32:11 <mrd> wy: there's alwys the MIT Schemers
13:33:35 <wy> mrd: I haven't seen much research on FP at MIT. Are they still actively doing Scheme?
13:34:29 <cjb> wy: switched to Python
13:34:47 <mrd> I haven't either. I didn't app there.
13:35:15 <oerjan> :t sequence_ . catMaybes . takeWhile isJust
13:35:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [Maybe (m a)] -> m ()
13:35:19 <mrd> they switched 6.001 to Python.  I don't know what that means for research.
13:35:30 <oerjan> stevan: ^^
13:35:45 <wy> cjb: That strange... It seems Python has never been a research project
13:36:03 <wy> mrd: I see.
13:36:11 <cjb> wy: why do you say that?
13:36:13 <wy> mrd: That's still weird ;)
13:36:13 <mrd> i'm not sure why it would be, since python is something a CS undergrad could hack up in his or her spare time
13:36:19 <cjb> Guido is an academic programming language designer.
13:36:19 <stevan> oerjan: cool. :-)
13:36:30 <mrd> and that's how it came about, i think
13:36:40 <cjb> and worked for many years in a CS research dept before designing Python.
13:37:08 <cjb> mrd: please consider subjecting your statements to reality.  :)
13:37:19 <mrd> what? you think python is that complex?
13:37:35 <mrd> he designed it in his spare time did he not? around '90
13:38:19 <opqdonut> yeah, nothing fancy
13:38:23 <cjb> No, he did not.  He designed it while a programming languages researcher at CWI.
13:38:28 <opqdonut> even the standard interpreter is pretty run-of-the-mill
13:38:34 <wy> Still looking for reasoned schemers... but cant' get any reply from #scheme
13:38:45 <opqdonut> pypy, rpython and psyco are nice projects, tho
13:38:59 <cjb> yeah, pypy blows my mind.
13:39:46 <mrd> cjb: I don't find Python to be particularly interesting from an academic point of view, regardless of designer.
13:40:00 <cjb> That's fine.
13:40:11 <opqdonut> :)
13:40:35 <mrd> I would also have hoped that a "CS language researcher" would be able to create a better implementation
13:42:08 <wy> It seems lots of schemers left MIT and went to neu?
13:42:37 <mrd> I did look into NEU, there is a group there.
13:42:43 <mrd> but wasn't it PLT from Rice that left for there?
13:44:01 <oerjan> mrd: i thought python was designed to be easy, not interesting.  now designing something like that can still be interesting, but perhaps only for the designer.
13:44:19 * wy is still searching for code of "The Reasoned Schemer"
13:44:44 <glen_quagmire> when I compile the program that uses getLine, backspace works as expected. But, in ghci, backspace prints out weird character
13:45:50 <oerjan> glen_quagmire: possibly the compiled program uses the normal terminal line editing settings, while ghci sets the terminal to read one char at a time
13:45:56 <ertai> @instances Applicative
13:46:11 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:46:18 <wy> oerjan: any ideas on LogicT?
13:46:49 <ertai> @instances-importing Applicative
13:46:50 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:47:39 <oerjan> wy: er that i have only a vague understanding of what it is, never having actually looked at it.
13:48:15 <ddarius> @google site:lamdda-the-ultimate.org "The Reasoned Schemer"
13:48:16 <lambdabot> No Result Found.
13:48:26 <oerjan> @instances-importing Control.Applicative Applicative
13:48:27 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
13:48:34 <opqdonut> lambda, not lamdda
13:48:47 <oerjan> ertai: there may be others defined together with the respective types though
13:48:48 <ddarius> @google site:lambda-the-ultimate.org "The Reasoned Schemer"
13:48:48 <lambdabot> No Result Found.
13:49:01 <ddarius> @google site:lambda-the-ultimate.org The Reasoned Schemer
13:49:03 <lambdabot> No Result Found.
13:49:36 <oerjan> @google lambda-the-ultimate the-reasoned-schemer
13:49:37 <lambdabot> No Result Found.
13:49:40 <opqdonut> :D
13:50:19 <ertai> oerjan: ok
13:50:28 <wy> I'm curious if LogicT is the thing under The Reasoned Schemer
13:50:30 <ddarius> @google google
13:50:31 <lambdabot> http://www.google.com/
13:50:31 <lambdabot> Title: Google
13:51:14 <oerjan> what the?
13:51:32 <oerjan> that googling gives me a result in my browser?
13:51:50 <oerjan> http://lambda-the-ultimate.org/node/1104
13:51:51 <lambdabot> Title: The Reasoned Schemer | Lambda the Ultimate
13:52:34 <oerjan> @google lambda-the-ultimate
13:52:35 <lambdabot> http://lambda-the-ultimate.org/
13:52:35 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
13:52:47 <oerjan> @google lambda-the-ultimate the-reasoned-schemer
13:52:48 <lambdabot> No Result Found.
13:53:20 <wy> I got it! http://kanren.sourceforge.net/
13:53:20 <oerjan> madness!
13:53:22 <lambdabot> Title: A declarative logic programming system
13:58:42 <yetAnotherOne> does development of greencard continue?
13:59:24 <Lemmih> yetAnotherOne: I don't think so.
14:00:14 <Lemmih> Hm, a 447 line long Haskell function. I wonder if that's a record.
14:00:25 <yetAnotherOne> sounds like madness
14:00:35 <ddarius> I've written a 900+ line function once.
14:00:44 <yetAnotherOne> what does it do?
14:00:44 <glguy> I saw someone's attempt at a card game
14:00:49 <opqdonut> ddarius: in haskell?
14:00:50 <glguy> that seemed like one long function
14:01:03 <ddarius> opqdonut: Yes.
14:01:11 <opqdonut> wow
14:01:11 <opqdonut> :P
14:01:35 <yetAnotherOne> i cannot imagine a sane 900+ line function
14:10:01 <gwern> so I emailed distract's maintainer
14:10:09 <cjb> gwern: cool
14:10:17 <cjb> did he reply?
14:10:21 <gwern> he pointed me at the monotone repo for it, and said the command I'd need looked like this:
14:10:24 <gwern> 'mtn -d path/to/db.mtn pull source.wellquite.org 'org.wellquite.distract'
14:10:36 <gwern> ironically, a few lines earlier, he told me he really didn't like darcs >.<\
14:10:45 <cjb> heh
14:12:51 <glen_quagmire> oerjan: oh i see
14:18:05 <resiak> urgh, monotone
14:18:44 <gwern> ...the monotone website is down
14:18:57 * gwern has a rule of thumb, never use any software whose website is down
14:19:49 <Cin> i'd imagine a 900 line function would just be tonnes of `where' clauses :P
14:19:54 <mahogny> in case of monotone, I might apply that rule also when the site is up
14:20:06 <jaredj> what's distract
14:21:03 <gwern> as the snipers sy, 'one file, one function' :)
14:21:44 <mahogny> I have written these extremely long functions, but only because I've used where to encapsulate a bit. but the error messages become really awful
14:22:00 <bd_> mahogny: a module's a better way to encapsulate :)
14:22:00 <mahogny> "I think you get an error here <insert 700 lines of code>"
14:22:12 <kaol> now you did it. I started solving Project Euler problems too. With Haskell one liners, too.
14:22:22 <mahogny> bd_, yes. ghc certainly isn't optimized for anything else
14:22:51 <bd_> OTOH GHC is also very not optimized for module reference loops, which is occasionally annoying
14:22:58 <gwern> arg... I dislike montone now, terrible documentation...
14:23:10 <mahogny> bd_, very :(
14:24:00 <gwern> 'mtn db init: mtn: misuse: no database specified
14:24:00 <gwern> gwern@localhost:1014~>mtn db init .: mtn: misuse: no arguments needed
14:24:33 <Zao> Databases are files, not directories.
14:25:07 <gwern> doesn't matter, same error
14:29:05 <jeffz> ShockSMX: emacs
14:33:14 <gwern> fuck montone. I'm wgetting the repo
14:33:26 <gwern> I just need some dists for hackage, I shouldn't have to go through this
14:34:02 <gwern> augggh! I can't even do that!
14:34:14 <sebell>  /quit
14:34:16 <ivanm> heh
14:34:19 <sebell> *sigh*.
14:34:59 * monochrom is monotone :)
14:35:06 <roconnor> @hoogle left
14:35:07 <lambdabot> Control.Arrow.left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
14:35:07 <lambdabot> Prelude.Left :: a -> Either a b
14:35:07 <lambdabot> Data.Either.Left :: a -> Either a b
14:35:17 <dons> ddarius: http://www.ohloh.net/projects/11766?p=parsec
14:35:17 <lambdabot> Title: parsec - Ohloh
14:35:53 <ddarius> "Mostly written in Haskell" ?
14:36:26 <monochrom> "Yeah, there is this funny file written in Cabal" :)
14:36:29 <dons> yeah.
14:36:54 <dons> there's a bunch of other haskell stuff slowing appearing as my script runs, btw
14:36:54 <sorear> the documentation is in english!
14:37:00 <dons> if you search, you'll find a few other things
14:37:09 <dons> unfort. some of the very big things don't import into git well
14:37:27 <dons> yi, lambdabot, base and ghc failed
14:38:03 <dons> hs-plugins is mostly shell-scripts for some reason (didn't find any of the .hs files :(
14:38:45 <monochrom> haha
14:39:24 <monochrom> And also, "unexpected EOF, expecting letter, punctuation, or closing parentheses"
14:39:38 <dons> oh? did you find the script failure log?
14:39:55 <dons> http://www.ohloh.net/projects/11738/analyses/latest nice.
14:39:55 <monochrom> No, I'm acting like Parsec on your sentence, sorry. :)
14:39:55 <lambdabot> Title: unix Code - Ohloh
14:40:12 <dons> heh
14:40:32 <gwern> is ohloh the new reddit?
14:40:46 <dons> gwern: i figure its a good way to ensure haskell stuff gets found when searching
14:40:50 <monochrom> monochrom :: ParsecT s u m a /  -- | monochrom is an English parser, very pedantic
14:40:52 <dons> google hits often return ohloh pages
14:41:06 <dons> gwern: and good to step up and show there's lots and lots of haskell devs out there.
14:42:37 <monochrom> Whee, ohlol.net is still available, no one acquired it yet.
14:42:43 <gwern> dons: they do? I don't think I saw ohloh before you mentioned it
14:42:54 * gwern personally figures Wikipedia would be more useful for Google-fu
14:42:59 <cjb> monochrom: inconceivable!
14:43:05 <dons> monochrom: heh
14:43:34 <gwern> cjb: you keep using that wor
14:43:38 <gwern> *word
14:43:44 <cjb> :)
14:43:47 * gwern does not think it means what you think it means
14:43:59 <monochrom> inconceivable!
14:44:07 * monochrom hides
14:47:41 <roconnor> @hoogle foldMap
14:47:42 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:47:42 <lambdabot> Data.Traversable.foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
14:48:22 * gwern tears some more hairout at monotone
14:50:23 <gwern> all that just to pull a directory out of the mtn database
14:50:27 <gwern> and he complains about darcs!
14:53:37 <monochrom> @unmtl StateT s IO a
14:53:37 <lambdabot> s -> IO (a, s)
14:54:46 <monochrom> @unmtl ContT r (State s) a
14:54:46 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
14:55:10 <monochrom> @unmtl StateT s (Cont r) a
14:55:10 <lambdabot> s -> (a -> s -> r) -> r
14:56:09 <monochrom> Heh, closure construction vs tuple construction :)
14:57:23 <monochrom> Likely up to GHC 6.6.1 closure threading was significantly faster, then from GHC 6.8.2 onwards they are similarly fast.
15:01:23 <Saizan> monochrom: isn't the "real" StateT s (Cont r) a == s -> ((a,s) -> r) -> r rather than that? i don't think newtypes use curry.. or is that a common optimization?
15:02:21 <monochrom> Let's investigate.
15:02:24 <monochrom> @src StateT
15:02:25 <lambdabot> Source not found. That's something I cannot allow to happen.
15:02:35 <monochrom> I'll look at the docs
15:03:00 <roconnor> @type (&&&)
15:03:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:03:39 <monochrom> Ah certainly, ought to be s -> ((a,s) -> r) -> r.  Bear in mind that @unmtl may be implemented in a funny way.
15:03:45 <ddarius> @unmtl (a,s) -> r
15:03:45 <lambdabot> (a, s) -> r
15:04:30 <monochrom> @unmtl StateT s IO a
15:04:31 <lambdabot> s -> IO (a, s)
15:04:37 <ddarius> @mtl (a,s) -> r
15:04:38 <lambdabot> Maybe you meant: ft map msg pl unmtl url
15:04:54 <monochrom> There is no @mtl yet. You're the second one attempting it today :)
15:05:11 <ddarius> It would be significantly more difficult to write.
15:05:43 <monochrom> Anyway, dunno how and why @unmtl transforms (a,s)->l to a->s->l.
15:06:08 * monochrom now goes into mtl source code to see if there are hidden rules.
15:08:49 <monochrom> I don't see any related pragmas in Control.Monad.State.Strict or Control.Monad.Cont
15:09:38 <twanvl> unmtl has a function (-->) :: Type -> Type -> Type  that is used for constructing function types, when the first argument is a tuple it makes a curried type
15:10:35 <oerjan> @unmtl Cont r (a,b)
15:10:35 <lambdabot> (a -> b -> r) -> r
15:10:59 <ddarius> @unmtl Cont r (a,b,c,d)
15:10:59 <lambdabot> (a -> b -> c -> d -> r) -> r
15:11:19 <oerjan> @unmtl Cont r (Either a b)
15:11:19 <lambdabot> (Either a b -> r) -> r
15:11:34 <ddarius> @unmtl Cont r (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,s,t,u,v,w,x,y,z)
15:11:34 <lambdabot> (a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> s -> t -> u -> v -> w -> x -> y -> z -> r) -> r
15:11:54 <monochrom> @unmtl Cont r 
15:11:55 <lambdabot> err: Illegal character ''\177''
15:11:59 <monochrom> oh well :)
15:13:06 * twanvl recently almost completely rewrote the unmtl code, because he wanted to add MaybeT, and that was too hard with the old version
15:14:09 <ddarius> @unmtl-add (MaybeT m a) (m (Maybe a))
15:14:09 <lambdabot> Unknown command, try @list
15:15:40 <twanvl> ddarius: the types are still hard coded, but less hard than they used to be
15:15:50 <oerjan> @unmtl ErrorT () m a
15:15:51 <lambdabot> m (Either () a)
15:49:00 <monochrom> @seen dolio
15:49:01 <lambdabot> dolio is in #haskell-blah and #haskell. I last heard dolio speak 1m 39s ago.
15:49:06 <monochrom> whee!
15:50:03 <monochrom> dolio: High probability that the answer to the following is "no": Does "StateT s (CC ans) a" make sense?
15:51:48 <dolio> monochrom: You can do that, yes. I used to have such instances.
15:52:36 <dolio> However, there are type problems depending on what you're doing with it.
15:52:38 <monochrom> Cute.  "reset $ \p -> modify (1 +) >> abort p (return ())"  the state modification is honoured, using CCT ans (State Int) ()
15:53:44 <monochrom> Ha, the true FunctorSalad? :)
15:54:25 <dolio> I described the problem on the mailing list a while back, and Oleg wrote back saying that it was a fundamental limitation of monad transformers brought out by delimited continuations.
15:54:26 <FunctorSalad> monochrom: yes, ghosted myself. sorry for the spam, bad connection today :|
15:54:32 <dolio> So I just removed the instances.
15:54:50 <FunctorSalad> it's a bit creepy if the message "FunctorSalad has been killed" comes so late that you already forgot that you ghosted...
15:55:21 <monochrom> Ah! Thanks, I recall seeing those messages. If I want to dig further, I'll look there.
15:56:06 <dolio> Which didn't seem like too much of a loss since you can use Control.Monad.CC.Dynvar to do State-like stuff (although you have to pass around your references, I guess, which could be a pain).
15:56:49 <monochrom> CCT ans (StateT s) a  is good enough.
15:58:49 <monochrom> Somehow I feel too that CC is so special that OtherMonadT (CC ans) is a mess.  CCT ans (OtherMonad) is always available anyway.
15:59:43 <dolio> Yeah, they're not quite the same, of course.
16:00:06 <dolio> StateT s (CC) would roll back the 'modify (1+)' I think.
16:01:02 <Cale> Delimited continuations and the various control operators are really something that I should look into.
16:01:23 <monochrom> Carrying over what StateT s (Cont r) does, I actually bet you could code it either way.
16:01:43 <dolio> For either of Reader or State, though, using Dynvar is probably a good alternative, because the interaction between dlet, dset and so on is pretty well defined.
16:01:53 <dolio> Since that was the purpose of the paper it comes from.
16:02:08 <dolio> Er, the interaction of those with shift/reset/etc.
16:02:30 <monochrom> In the mtl library, StateT s (Cont r) and ContT r (State s) both honour state changes when you escape.
16:02:56 <dolio> Do they? I thought one was different.
16:03:02 <monochrom> It comes as a surprise to quite a few people, every time I mention this. :)  Most people expect one of them to undo.
16:04:19 <dolio> > runState (runContT (callCC (\k -> modify (1+) >> k ())) return) 1
16:04:22 <lambdabot>  ((),2)
16:04:28 <monochrom> http://hpaste.org/5570  is sample code I wrote a while ago.
16:04:45 <dolio> > runCont (runStateT (callCC (\k -> modify (1+) >> k ())) 1) id
16:04:46 <lambdabot>  ((),2)
16:04:54 <dolio> Huh, so it does.
16:05:28 <Cale> monochrom: I *think* I consider it a mistake that StateT s (Cont r) doesn't undo.
16:06:13 <dolio> > runCont (runWriterT (callCC (\k -> tell [1] >> k ())) ) id
16:06:13 <lambdabot>   Not in scope: `runWriterT'
16:06:42 <Cale> @unmtl StateT s (Cont r) a
16:06:42 <lambdabot> s -> (a -> s -> r) -> r
16:07:16 <monochrom> The types won't tell you anything.  Since all the instance code is hand-coded, an author can code it to do anything.
16:07:24 <Cale> Well, yes.
16:07:37 <dolio> > Control.Monad.Writer.runWriter (runContT (callCC (\k -> tell [1] >> k ())) return)
16:07:38 <lambdabot>        add an instance declaration for
16:07:38 <lambdabot>       (MonadWriter [t] (ContT () (Cont...
16:07:44 <Cale> @unmtl ContT r (State s) a
16:07:45 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
16:07:48 <monochrom> Of course, by that I don't mean anything is correct. :)  I don't know what is correct, however, but I suspect you're right.
16:07:49 <dolio> Oh, right.
16:08:23 <Cale> monochrom: Well, StateT s [] actually does backtrack the state when backtracking happens.
16:08:54 <Cale> It's more obvious in that case what the right thing is.
16:09:02 <Cale> @unmtl StateT s []
16:09:03 <lambdabot> err: `StateT s []' is not applied to enough arguments, giving `/\A. s -> [(A, s)]'
16:09:05 <Cale> @unmtl StateT s [] a
16:09:05 <lambdabot> s -> [(a, s)]
16:09:15 <monochrom> Ah, that's strong evidence.
16:10:23 <Cale> The MTL could use some work. Nobody seems to have touched it almost since its inception.
16:11:09 <Cale> I actually really dislike a lot of the lifting instances. One option would be to separate those into their own module(s).
16:11:34 <dolio> > runReader (runContT (callCC (\k -> local (+1) $ k ()) >> ask) return) 5
16:11:34 <lambdabot>  6
16:11:38 <dolio> I like that one.
16:11:41 <Cale> They end up making it rather hard for beginners to understand how monad transformers work.
16:12:18 <litb> boohoo: lookup i don't know what a monad transformer is
16:12:31 <Cale> litb: hm?
16:12:31 <litb> oops, cut the first two things
16:13:01 <monochrom> It is a crime in #haskell to not know what a monad transformer is!
16:13:05 <Cale> litb: It's a type constructor whose intention is to turn a monad (which is itself a type constructor) into another monad.
16:13:33 <Cale> Together with an instance of Monad for the transformed monad.
16:13:57 <Cale> as well as a function  lift :: m a -> t m a
16:14:13 <Cale> (where m is the original monad, and t is the monad transformer)
16:14:25 <litb> i see
16:14:35 <Cale> This generally adds new operations or functionality to the monad.
16:15:27 <Cale> For example, StateT s is a monad transformer which adds a computation-global state of type s, and it comes with get and put operations which work in any StateT transformed monad.
16:16:03 <Cale> So, for example, you can have the monad  StateT Integer [], which is the list monad, extended with state operations.
16:16:47 <Cale> (on an Integer)
16:16:52 <litb> i see
16:16:59 <litb> interesting
16:17:24 <litb> @src StateT
16:17:24 <lambdabot> Source not found.
16:17:47 <litb> hm, i suppose that's not in its index
16:18:07 <Cale> > runStateT (do x <- get; y <- lift [1..x]; put y; return (x+y)) 3
16:18:20 <lambdabot>  [(4,1),(5,2),(6,3)]
16:18:20 <Cale> ...
16:18:25 <Cale> ah, there we go :)
16:18:40 <Cale> Note the '3' at the end is the initial state.
16:19:03 <Cale> and what's returned is a list of (return value, final state) pairs.
16:20:49 <Cale> So, first, x <- get gets the initial state and binds it to x (so x is 3)
16:21:00 <litb> i see
16:21:17 <Cale> and then y <- lift [1..x] will effectively select y from the list [1..3] in all possible ways
16:21:34 <litb> as it is a list monad embedded, it concatMaps with 1,2 and 3. puts the final state every time and then adds 3 to it
16:21:42 <litb> i suppose
16:22:01 <litb> tho i'm not at all sure i get it :)
16:22:03 <Cale> @unmtl StateT Integer []
16:22:03 <lambdabot> err: `StateT Integer []' is not applied to enough arguments, giving `/\A. Integer -> [(A, Integer)]'
16:22:04 <Cale> @unmtl StateT Integer [] a
16:22:05 <lambdabot> Integer -> [(a, Integer)]
16:22:26 <Cale> That shows the underlying type of the computations
16:23:25 <Cale> So you can immediately see that each nondeterministic branch of the computation has its own state.
16:24:01 <litb> so it is a timple of the type argiment to the embedded monad, and the type argument to the transformer
16:24:33 <Cale> Well, yeah.
16:24:47 <Cale> That is, a pair consisting of a result value, and a final state.
16:25:07 <litb> i wonder what unmtl does
16:25:11 <Cale> One of these computations is a function from an initial state to a list of (result, final state) pairs.
16:25:30 <Cale> It just unwraps the newtype declarations which are involved in defining the various monad transformers.
16:25:45 <litb> ah
16:26:22 <kpreid> "@oldtype"...?
16:26:27 <Cale> heh
16:27:06 <litb> > runStateT (do x <- get; y <- lift (Just 2); put y; return (x+y)) 4
16:27:20 <lambdabot>  Just (6,2)
16:27:44 <Cale> > runStateT (do x <- get; y <- lift Nothing; put y; return (x+y)) 4
16:27:46 <lambdabot>  Nothing
16:28:21 <litb> @src StateT (>>=)
16:28:21 <lambdabot> Source not found. I feel much better now.
16:28:23 <Cale> So you can see how that's like the Maybe monad, extended with state operations.
16:28:25 <litb> darn
16:28:38 <litb> yeah, neat
16:28:50 <Cale> instance (Monad m) => Monad (StateT s m) where
16:28:50 <Cale>     return a = StateT $ \s -> return (a, s)
16:28:50 <Cale>     m >>= k  = StateT $ \s -> do
16:28:50 <Cale>         ~(a, s') <- runStateT m s
16:28:50 <Cale>         runStateT (k a) s'
16:30:00 <litb> ah, i see, thanks :)
16:30:02 <Cale> So you can see the similarity to the corresponding definition for State:
16:30:09 <Cale> instance Monad (State s) where
16:30:09 <Cale>     return a = State $ \s -> (a, s)
16:30:09 <Cale>     m >>= k  = State $ \s -> let
16:30:09 <Cale>         (a, s') = runState m s
16:30:09 <Cale>         in runState (k a) s'
16:30:23 <Cale> We've just replaced 'let' with 'do', essentially.
16:30:25 <litb> i haven't touched State and Reader yet. maybe it's time to do so soon
16:30:45 <Cale> Ah, I can explain it if you'd like.
16:30:53 <litb> go on, i like it :)
16:30:55 <Cale> Let's have a look at State
16:31:01 <Cale> newtype State s a = State { runState :: s -> (a, s) }
16:31:15 <Cale> For each s, (State s) will be a monad
16:31:39 <Cale> A computation of type State s a is essentially just a function from an initial state of type s, to a pair
16:31:52 <Cale> consisting of a return value, and a final state of type s
16:32:51 <Cale> So we think of the computation as something which acts on a state of type s, while producing a value of type a
16:32:55 <litb> it seems to be a generic pattern in State monads to have this kind of functions from a state to a pair
16:33:03 <Cale> yes
16:33:35 <bloupp> I want to make some passes over an AST of a language to compile. The passes deduce data of different types. Is Functor adequate for this task or something else?
16:33:53 <Cale> The State monad is really going to do nothing more than handle the usual parameter passing that you'd do in a pure language whenever you would have used a mutable variable in an impure language.
16:34:33 <Cale> bloupp: Functor just gives you a way to apply a function to each element of a datastructure, individually
16:35:07 <Cale> bloupp: It's unlikely that it'll be strong enough, as you'll likely want to move information up and down the tree.
16:35:35 <Cale> litb: Okay, so let's look at the Monad instance carefully.
16:35:42 <Cale> First, there's return
16:35:55 <Cale> Well, return x is supposed to "do nothing" and result in x
16:36:14 <Cale> Here, "doing nothing" means passing the initial state along to the final state unchanged.
16:36:19 <Cale> So we have:
16:36:34 <Cale> return x = State (\s -> (x,s))
16:36:42 <Saizan> bloupp:  Traversable might be more appropriate, but you can also just define your own combinators
16:37:05 <Cale> (I'm following the MTL's convention for pairs, so the first element of each pair is the return value, and the second is the state)
16:37:21 <Cale> litb: that make sense?
16:37:29 <litb> > return (Just 4) 5 :: (Int -> (Maybe Int, Int))
16:37:32 <lambdabot>  Couldn't match expected type `Int -> (Maybe Int, Int)'
16:37:44 <Cale> litb: You'll need runState
16:37:47 <litb> oh, forgot something
16:37:52 <bloupp> I thought I could encapsulate (and write only once) the code to visit all childs of a parent. Also given a function to combine results. Maybe I should just implement it, without trying to make it an instance of some class?
16:38:12 <Cale> litb: The State computations are wrapped up in the State data constructor. You'll want to use runState to extract the actual computation
16:38:46 <Cale> (the extra data constructor is just needed for the type system's purposes, so that it can tell which instance of Monad to use)
16:39:06 <litb> oh i see
16:39:10 <Cale> > runState (return (Just 4)) 5
16:39:24 <Cale> lambdabot's been kinda slow lately.
16:39:25 <lambdabot>  thread killed
16:39:27 <Cale> > runState (return (Just 4)) 5
16:39:28 <litb> (Just 4, 5) =)
16:39:29 <lambdabot>  (Just 4,5)
16:39:43 <litb> key, i think i'm slowly getting it
16:39:46 <Cale> Okay, so now, bind
16:40:03 <Cale> It's a bit to take in, but if we think about it carefully, it's not so hard to derive
16:40:14 <litb> so return just forwards each state without calling the runState again
16:40:50 <Cale> return x  produces the State computation which just forwards the state, and results in x
16:41:06 <Saizan> bloupp: take a look at Data.Foldable and Data.Traversable, defining your type an instance of those will be mainly useful for the functions you'd get defined for free
16:41:37 <litb> i see
16:41:41 <Cale> Now, (>>=) :: State s a -> (a -> State s b) -> State s b
16:41:53 <Cale> So let's look at what it should do :)
16:42:03 <litb> alrite i'm prepared =)
16:42:08 <Cale> x >>= f is going to be some State computation
16:42:20 <Cale> So we already know that the definition will look something like:
16:42:27 <Cale> x >>= f = State (\s -> ...)
16:42:55 <Cale> Now, the first thing that the computation x >>= f is supposed to do is to "run x"
16:43:22 <Cale> Of course, this means running it with the initial state s
16:43:22 <ac> Can there be a thunk for each field in a record, or must a whole record be evaluated or unevaluated?
16:43:36 <Cale> ac: There typically is a thunk for each field.
16:44:07 <Cale> ac: Every value in Haskell is actually implemented in GHC as a pointer to code. :)
16:44:35 <Cale> (well, every not-unboxed value)
16:44:39 <syntaxfree> Cale: so basically that's how lazy evaluation is obtained.
16:44:42 <Cale> syntaxfree: right
16:44:48 <oerjan> ac: unless the field has a ! annotation and unbox-strict-fields is used, i think
16:44:53 <ac> so I shouldn't be worried about passing large records around
16:44:54 <syntaxfree> (Pardon my mistyping, I'm high on benzodiazepines.
16:44:58 <Cale> ac: right
16:45:03 <syntaxfree> Somehow, I'm actually thinking right)
16:45:24 <Cale> ac: also, don't worry so much about modifying one of the fields without touching the others, the copy is cheap :)
16:45:37 <Cale> litb: okay, sorry about that, let's continue :)
16:45:52 <Cale> litb: So we want to run the computation x with initial state s
16:45:58 <Cale> x >>= f = State (\s -> let (v,s') = runState x s in ...)
16:46:29 <Cale> We get some return value v, and another state s'
16:47:05 <Cale> Now, f is a function which is going to take the return value from running x and produce the computation to run next.
16:47:30 <Cale> So we apply f to v and get a new computation, which we're going to run with initial state s'
16:47:40 <Cale> Make sense?
16:47:51 <Cale> x >>= f = State (\s -> let (v,s') = runState x s in runState (f v) s')
16:48:36 <Cale> and the final state and return value of that will be the final state and return value of our computation as a whole
16:49:36 <litb> hmm
16:49:47 <litb> lets see
16:50:24 <Cale> I could also have written:
16:50:37 <Cale> x >>= f = State (\s -> let (v,s') = runState x s; (w,s'') = runState (f v) s' in (w,s''))
16:50:40 <Cale> If that helps.
16:51:54 <litb> it essencially makes sense
16:52:04 <litb> but i think a nice example will help much =)
16:52:17 <Cale> Okay
16:52:30 <Cale> So we're not *quite* finished with the State monad as a whole.
16:52:39 <litb> oh i see
16:52:42 <Cale> Besides being a monad, it has some additional operations.
16:52:54 <Cale> In particular, we have to implement get and put still.
16:53:16 <Cale> Would you like to try?
16:53:28 <Cale> get :: State s s
16:53:34 <Cale> put :: s -> State s ()
16:54:01 <Cale> Once we have get and put, we'll never have to look underneath the State data constructor ever again.
16:54:10 <litb> i see
16:54:31 <Cale> We'll be able to write any state computation we want, without having to understand that it's really functions underneath :)
16:55:00 <litb> yeah hold on. let's see whether i fail
16:56:14 <hpaste>  segher pasted "(no title)" at http://hpaste.org/5697
16:58:15 <Cale> If you write something which is type-correct, there's not too much potential for messing up :)
17:00:36 <litb> get = return
17:00:52 <litb> well, just a guess by looking to the do { x <- get; .. } above
17:01:16 <litb> but not sure how the type inference would be then. since return is a -> State s
17:02:42 <litb> hm, no return is a -> State (\s -> (a, s))
17:03:05 <syntaxfree> there's something spookily AI-like to the type-inferrecer.
17:03:13 <syntaxfree> s/inferrecer/inferencer.
17:03:18 <syntaxfree> it knows stuff we don't.
17:03:22 <litb> =)
17:03:36 <lament> if you can't inference types yourself, there's something really wrong either with you or with your code
17:03:40 <lament> *infere
17:03:48 <oerjan> Trust the inferencer.  The inferencer is your friend.
17:03:49 <lament> *infer
17:04:18 <Cale> litb: So get is supposed to have type State s s
17:04:20 <litb> > runState (do { x <- get; put x; return (x+1); }) 10
17:04:24 <lambdabot>  (11,10)
17:04:25 <Cale> So you know that:
17:04:30 <Cale> get = State (\s -> ...)
17:04:36 <Cale> Where ... is something :)
17:04:41 <syntaxfree> maybe lambdabot will just recursively self-improve into an AGI given enough extensions to the type system.
17:05:09 <Cale> syntaxfree: Adventure game interpreter?
17:05:20 <syntaxfree> hahahhah
17:05:39 <syntaxfree> z-machines are simple enough that they can be probably be bolted onto a comonad.
17:05:43 <litb> one question tho. it is "State s s" . why is it get = State (\s -> ...) then?
17:05:47 <syntaxfree> an artificial general intelligence.
17:05:49 <litb> maybe it's silly tho
17:05:53 <syntaxfree> @quote cale
17:05:53 <lambdabot> dobblego> says: Cale, didn't you write one? :) \n Cale> dobblego: two actually, and a half.
17:06:01 <litb> but i don't see that :p
17:07:19 <Cale> litb: Every value of type State s a has that form, essentially
17:07:30 <Cale> newtype State s a = State (s -> (a,s))
17:07:35 <Cale> well:
17:07:41 <Cale> newtype State s a = State { runState :: (s -> (a,s)) }
17:07:45 <Cale> but that's the same thing
17:07:55 <Cale> (just with a convenient extractor function :)
17:07:58 <litb> oh i see forgot about the definition
17:08:19 <dibblego> is there a isSubstring :: (Eq a) => [a] => [a] => Bool?
17:08:34 <Cale> :t isInfixOf
17:08:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
17:08:41 <dibblego> ah cheers
17:08:55 <syntaxfree> @quote cheers
17:08:55 <lambdabot> Korollary says: darcs is free of chemical toxins of big pharma. It's made using all natural herbs and other woo. It's good for you. Cheers.
17:08:57 <dibblego> > "foo" `isIndexOf` "lofoofol"
17:08:57 <lambdabot>   Not in scope: `isIndexOf'
17:09:02 <dibblego> er
17:09:08 <dibblego> > "foo" `isInfixOf` "lofoofol"
17:09:09 <lambdabot>  True
17:09:14 <dibblego> > "foo" `isInfixOf` "lofoxofol"
17:09:15 <lambdabot>  False
17:09:53 <Cale> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
17:10:16 <Cale> hehe, I'm not sure it's really implemented like that though :)
17:10:21 <Cale> @src isInfixOf
17:10:22 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
17:10:26 <Cale> ahaha!
17:10:42 <Cale> Insane :)
17:11:09 <litb> well, then it is "get = State (\s -> (s, ..))" well that is what i am totally sure about. but i'm not sure what to put in the second thing
17:11:29 <Cale> litb: well, the second thing is the final state after doing the get
17:11:44 <Cale> (and there's really only one thing you could put there)
17:12:35 <litb> well, s
17:12:40 <Cale> right :)
17:12:59 <Cale> get doesn't affect the current state (or else it would be self-defeating :)
17:13:11 <Cale> It just passes it along
17:13:31 <Cale> How about put?
17:13:41 <Cale> put :: s -> State s ()
17:13:43 <litb> i've to eat that get first =)
17:13:53 <litb> up to know i've only cooked it up
17:13:57 <Cale> hehe
17:14:15 <Cale> Well, consider get >>= (\x -> ...)
17:14:34 <Cale> What value will x inevitably get bound to?
17:15:16 <litb> to fst
17:15:55 <Cale> well, to the first component of the result of applying the function inside get to the initial state
17:16:03 <Cale> But what is that?
17:16:06 <litb> i.e the first element in the pair returned by runState
17:16:12 <Cale> right
17:16:31 <Cale> Let's blast out the definition of >>=
17:16:47 <litb> it is the data embedded
17:16:53 <litb> not the state
17:17:17 <Cale> get >>= (\x -> ...) = State (\s -> let (v,s') = runState get s in runState ((\x -> ...) v) s')
17:17:30 <Cale> right?
17:18:33 <xif> So, has anyone here read "The Haskell Road to Logic, Maths and Programming"?
17:18:45 <Cale> xif: I've read bits of it.
17:19:11 <dibblego> xif, yes, it's a good book, even if you never use Haskell again
17:19:30 <litb> Cale: right
17:19:36 <xif> dibblego: how does it compare to other forms of introduction to Haskell?
17:19:43 <xif> Cale: what did you think about it?
17:20:04 <dibblego> xif, if you come from a disciplined background, I'd recommend it
17:20:34 <dibblego> xif, if you come from imperative programming languages, it might be rough going as an introduction
17:20:37 <Cale> xif: Well, I already knew the stuff that it covered. It's good, but it's a bit of a strange compromise.
17:20:38 <xif> dibblego: "disciplined background"?  you mean, if I was beat-up in school? ;p
17:21:00 <dibblego> xif, no, I just mean having some formal grounding in programming topics
17:21:03 <xif> Cale: "strange compromise" in what sense?
17:21:04 <thorat> and how does it compare to "Discrete Mathematics Using a Computer" which also uses Haskell?
17:21:11 <Cale> xif: It has a not quite enough mathematics to be a mathematics course, and not quite enough Haskell to be a Haskell course.
17:21:31 <xif> Cale: I see. sounds perfect for me, thanks :-)
17:21:37 <Cale> -a
17:22:05 <xif> Cale: btw, any other, similar text that you'd recommend over it?
17:22:38 <xif> dibblego: I don't have it, but from what you said I understand the book teaches that, so good.
17:22:41 <dibblego> xif, the book has an excellent introduction to logic, which most people wanting to learn programming languages are interested in
17:22:46 <Cale> Well, if you're more interested in learning Haskell, perhaps Graham Hutton's book would be good. I feel pretty safe in recommending that even though I haven't read it myself :)
17:22:56 <Cale> (it's got lots of really good reviews)
17:23:23 <dibblego> I have read it; it's a good brief introduction, covers a range of easy to advanced topics, but briefly
17:23:30 <Cale> If you want an introduction to classical algebra and number theory,... hmm, I only had course notes for those courses :)
17:23:41 <glen_quagmire> is it possible to implement (.) ?
17:23:46 <Cale> glen_quagmire: of course :)
17:23:48 <oerjan> @src .
17:23:49 <lambdabot> (.) f g x = f (g x)
17:23:50 <Cale> (f . g) x = f (g x)
17:23:57 <litb> the book by Graham Hutton is sooo great
17:24:00 <glen_quagmire> compose a b = a b
17:24:02 <litb> i really enjoy reading it
17:24:04 <glen_quagmire> oh i see
17:24:06 <xif> Cale: if I wanted to get up and running with Haskell, I'd just read some online tutorial
17:24:16 <Cale> xif: Yeah. You could do that too :)
17:24:17 <dibblego> xif, YAHT is the one I'd recommend for that
17:24:49 <Cale> litb: Okay, I was going somewhere with that, but we got derailed again :)
17:24:53 <Cale> get >>= (\x -> ...) = State (\s -> let (v,s') = runState get s in runState ((\x -> ...) v) s')
17:25:05 <litb> i'm right with that now
17:25:14 <Cale> Okay, now I'm going to expand the definition of  runState get
17:25:18 <litb> there is only one thing that makes me unhappy
17:25:24 <litb> that does the s' do at the end?
17:25:49 <dibblego> litb, s' is just an identifier like any other
17:25:57 <Cale> That s' is the initial state passed into the runState ((\x -> ...) v)
17:26:13 <litb> dibblego: i know, but i don't get why it is fed to the final result again
17:26:22 <dibblego> litb, oh right
17:26:38 <litb> i mean it was already passed to the starting computation. why is it needed at the end anymore?
17:26:41 <glen_quagmire> now I can implement composition in terms of function application.  can I implement function application only with composition?
17:26:54 <Cale> litb: Remember that in x >>= f we take the final state of running x, and use it as the initial state of the computation produced by applying f to the result of x
17:26:55 <glen_quagmire> let's say haskell doesn't have function application
17:27:08 <Cale> glen_quagmire: Not really, no.
17:27:33 <Cale> well...
17:27:35 <litb> Cale: ah, that makes much more sense now
17:27:59 <Cale> litb: Okay, so let's expand out  runState get
17:28:06 <Cale> and then splice it into that
17:28:28 <Cale> runState get just extracts the function under the State data constructor in get, so it's just (\s -> (s,s))
17:28:35 <Svrog> @seen conal
17:28:35 <lambdabot> I saw conal leaving #haskell and #ghc 2h 26m 14s ago, and .
17:28:46 <Cale> To save confusion, I'll alpha-convert that to (\t -> (t,t))
17:28:47 <xif> Cale, dibblego: think I'll read the "Road" book then, as I lack a formal background in CS, and in math, but interested in both, as well as in Haskell theoretically. thanks!
17:29:00 <Cale> So we have:
17:29:04 <Saizan> glen_quagmire: how do you use (.) without function application?
17:29:06 <dibblego> xif, no prob, have fun; there's always IRC if you need help :)
17:29:08 <Cale> get >>= (\x -> ...)
17:29:09 <Cale> = State (\s -> let (v,s') = runState get s in runState ((\x -> ...) v) s')
17:29:10 <litb> alpha convert meaning just change names?
17:29:17 <Cale> = State (\s -> let (v,s') = (\t -> (t,t)) s in runState ((\x -> ...) v) s')
17:29:19 <Cale> yeah
17:29:23 <bloup> traversing this AST: Data.Foldable seems fitting to me, but the data is of kind *. Can/Should I use Foldable?
17:29:41 <Cale> (sorry, lambda calculus terminology :)
17:30:08 <Cale> = State (\s -> let (v,s') = (s,s) in runState ((\x -> ...) v) s')
17:30:24 <Cale> those steps okay?
17:30:32 <litb> :)
17:30:32 <Saizan> bloup: you can't ,,
17:30:43 <Cale> = State (\s -> runState ((\x -> ...) s) s)
17:30:50 <oerjan> glen_quagmire: the language Joy is somewhat based on replacing application by composition.  you may have a look on that.
17:31:11 <Cale> So x gets bound to s
17:31:17 <Cale> The initial state of the computation.
17:31:20 <glen_quagmire> oerjan: yah my question is commiing from joy
17:31:50 <litb> yeah, x is bound to s. what i didn't get is why s is passed a second time. but now i get it
17:31:58 <litb> because it is the input of the returned computation
17:32:45 <Cale> It gets passed once as the result of get, and once as the final state of get.
17:32:55 <litb> hm, the a and s doesn't seem to have any specific types or comply to any requirements
17:32:57 <Cale> (and so the initial state of the rest)
17:33:23 <Cale> litb: They can be anything you want, but the 's' type stays fixed throughout a chain of computations.
17:33:36 <sclv> ?seen gwern
17:33:36 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 2h 43m 9s ago.
17:34:09 <litb> i see
17:34:10 <oerjan> litb: the a type is the result type of the monad and generally those cannot have any requirements.
17:34:29 <litb> you rock :)
17:34:51 <Cale> To be really picky, it is the type to which the monad is being applied :)
17:35:48 <oerjan> litb: but other parts of a Monad can have requirements.  State just doesn't happen to have any.
17:35:54 <litb> ok, i'll look at put now
17:36:16 <litb> oerjan: yeah
17:36:24 <oerjan> (e.g. Writer w requires w to be of a Monoid class)
17:36:36 <Cale> In some sense, the 'a' isn't really part of the monad itself, it's the parameter to the monad.
17:36:58 <oerjan> *instance
17:39:14 <litb> > runState (do { x <- get; put 2; put 3; return (x*2); }) 2
17:39:18 <lambdabot>  (4,3)
17:40:00 <synthase> If I have divides :: Integer -> Integer -> Bool and divides d n = rem d n == 0 then a type of the form a -> b is understood to be meant as "an argument of type a produces a result of type b" -- how does that make sense for a function with two arguments?
17:40:57 <kpreid> synthase: it's Integer -> (Integer -> Bool)
17:40:59 <litb> put s = State (const ((), s))
17:41:01 <litb> ?
17:41:03 <dibblego> synthase, functions don't have two arguments -> is right-associative
17:41:15 <kpreid> synthase: your function takes an Integer and returns a function
17:41:31 <synthase> My book goes on to say: "Thus, divides takes an argument of type Integer and produces a result of type Integer -> Bool"
17:41:37 <synthase> kpreid: why do you say that?
17:41:50 <idnar> synthase: that's how Haskell works (it's called "currying")
17:41:53 <Cale> litb: yep
17:41:56 <synthase> kpreid: I see two integers, namely d and n
17:41:59 <oerjan> @let divides d n = rem d n == 0
17:42:06 <kpreid> synthase: because it is true and relevant
17:42:06 <lambdabot> Defined.
17:42:06 <kpreid> your book says the same
17:42:10 <litb> well, but that was easy after hacking through get =)
17:42:12 <dibblego> synthase, if you were to put parentheses on function signatures, you'd start from the right; then you see that functions never take two arguments
17:42:12 <idnar> divides is a function that takes an Integer, and returns a function; that returned function takes an Integer, and returns a Bool
17:42:28 <oerjan> > divides 5
17:42:30 <lambdabot>  <Integer -> Bool>
17:42:37 <oerjan> > divides 5 3
17:42:38 <lambdabot>  False
17:43:15 <Cale> litb: I tend to think of it as a little bit harder than get, simply because you could write something like  put x = State (\s -> ((),s)) by mistake, and it would still typecheck, whereas there's only one completely-defined way to define get.
17:43:38 <Cale> litb: But yeah, once you understand how it works, it's pretty easy :)
17:43:49 <litb> > runState (do { x <- get; y <- put 2; return (if null y then x*2 else x*3); }) 2
17:43:50 <lambdabot>  Couldn't match expected type `[a]' against inferred type `()'
17:43:54 <litb> ou, darn
17:43:57 <oerjan> > let f = divides 5 in f 3
17:43:59 <lambdabot>  False
17:44:02 <synthase> dibblego: can you elaborate on that comment? specifically how divides would look with parentheses and "starting from the right"
17:44:10 <litb> @src null
17:44:10 <lambdabot> null []     = True
17:44:10 <lambdabot> null (_:_)  = False
17:44:20 <idnar> synthase: what he means is, you can write the type of divides as Integer -> (Integer -> Bool)
17:44:20 <dibblego> synthase, as krpeid wrote it; Integer -> (Integer -> Bool)
17:44:22 <litb> oh, that's not what i wanted hehe
17:44:25 <Cale> () is an empty tuple, which is not the same as an empty list :)
17:44:38 <dibblego> synthase, notice how the function only takes one argument
17:44:41 <litb> is there something to check for () ?
17:44:43 <synthase> right
17:44:59 <Cale> hehe, well, (== ())
17:45:08 <idnar> synthase: are you familiar with lambdas?
17:45:12 <litb> i see
17:45:14 <Cale> But there's only one defined value of type ()
17:45:18 <synthase> my programming intuition is still intuned with traditional imperative languages
17:45:25 <synthase> but I vaguely remember currying from scheme
17:45:27 <Cale> So it'll always succeed or just not terminate.
17:45:48 <dibblego> synthase, those languages call this a "design pattern"; it's just partial application
17:45:59 <synthase> I think something similar was used to produce a y-combinator
17:46:10 <idnar> divides d n = rem d n == 0 is the same as divides d = \n -> rem d n == 0 is the same as divides = \d -> \n -> rem d n == 0
17:46:24 <litb> > runState (do { x <- get; y <- put 2; return (if y == () then x*2 else x*3); }) 2
17:46:28 <lambdabot>  (4,2)
17:46:33 <litb> sweet
17:46:34 <idnar> if that helps
17:46:37 <litb> why wouldn't it terminate?
17:46:49 <Cale> litb: well, you could have something like   loop = loop :: ()
17:46:58 <litb> ah
17:47:06 <oerjan> > let (divides d) n = rem d n == 0 in divides 5 3 -- does this work?
17:47:07 <lambdabot>  False
17:48:17 <Cale> Or, say, you could write a function which gives () if there's a counterexample to the Riemann hypothesis, and just fails to terminate otherwise. :)
17:48:40 <Cale> Or any number of other complicated values of type () :)
17:48:55 <litb> i see
17:49:52 <Cale> Of course, there are semantically just two values of type (), which are () and bottom (nontermination)
17:50:03 <synthase> what's the difference between => and ->?
17:50:28 <Cale> synthase: In types, => is used to separate the class context from the rest of the type
17:50:29 <Cale> synthase: Whereas -> indicates a function type
17:50:30 <ivanm> the line
17:50:32 <ivanm> ;-)
17:51:11 <Cale> If A and B are any types, then A -> B is the type of functions which take a parameter of type A and result in a value of type B
17:51:24 <conal> Svrog: howdy.
17:51:31 <Cale> synthase: Do you know about type variables yet?
17:51:33 <Svrog> oh hi conal :)
17:51:44 <synthase> I kind of just got into that
17:51:49 <synthase> I guess I'll read on
17:51:55 <Cale> synthase: For example, we might have length :: [a] -> Integer
17:52:12 <Cale> Which means that for any type 'a', length takes a list of values of type a and produces an Integer
17:52:19 <conal> Svrog: i just saw your note.  so you have a new Reactive with caching and without unsafePerformIO.  i'm looking forward to seeing it!
17:52:22 <synthase> makes sense
17:52:27 <Svrog> yes :)
17:52:35 <Cale> synthase: Okay, this works really well for a lot of things.
17:52:55 <Svrog> the event type is now data Event a = Event [a] | Fork [Event a] :)
17:52:58 <Cale> synthase: But sometimes you want to mean lots of types, but not just any type. Consider the function  sort, which sorts a list of elements.
17:53:10 <Cale> synthase: It can't have type  sort :: [a] -> [a]
17:53:15 <litb> or for example sum :: Num a => [a] -> a
17:53:26 <Cale> synthase: because there might not be a way to compare the values of type a for ordering
17:53:38 <Cale> (if they were functions, for example)
17:54:10 <Cale> So we have these things called typeclasses, which let you restrict the type variables to range over just types which have certain sets of functionality implemented.
17:54:14 <Cale> In this case:
17:54:21 <Cale> sort :: (Ord a) => [a] -> [a]
17:54:43 <Cale> Says that the type a must be an instance of the typeclass Ord, which defines operations like (<) for comparison.
17:55:15 <Cale> There's also Eq for equality testing, and Num for basic numeric operations
17:55:27 <Cale> and a whole bunch of others in the standard libraries
17:55:32 <synthase> Cale: in that case, why not just say sort :: Ord -> Ord ?
17:55:34 <Cale> You can also write your own.
17:55:47 <Cale> synthase: You mean something like [Ord] -> [Ord] ?
17:55:57 <synthase> yeah
17:56:02 <Cale> synthase: That's a different approach, which involves subtyping.
17:56:20 <Cale> Subtyping tends to severely damage type inference.
17:56:30 <dibblego> e.g. Scala
17:56:36 <synthase> Cale: why can't you use Ord -> Ord?
17:56:44 <synthase> i.e., without []
17:56:57 <Cale> synthase: Well, the function is intended to sort lists...
17:57:18 <Cale> Presumably it doesn't just take one value, but a list of them, and produces another list :)
17:57:24 <synthase> Cale: oh I see, [] relates to lists and [a] relates to the kind of lists you can operate on, where a is some class type
17:57:41 <synthase> or so it seems
17:57:41 <Cale> a is any type which is an instance of Ord here.
17:57:43 <pejo> Cale, what do you mean with severly damage type inference?
17:57:58 <idnar> synthase: right, [Integer] is a list of Integers, and [a] is a list of some type a
17:58:34 <idnar> so the Ord a => part says that a can't just be any old type, it has to be one that supports ordering
17:58:40 <Cale> pejo: It means that there's no longer a principal, most general type for things.
17:59:05 <Cale> pejo: and deciding whether there exist a set of types for which a program typechecks takes exponential time in non-contrived cases.
17:59:08 <synthase> idnar: so Ord functions as a kind of superclass in that context?
17:59:23 <idnar> synthase: well, it's called a type class
17:59:41 <pejo> Cale, doesn't the current extensions already mess up principal types?
17:59:48 <Cale> synthase: Ord itself isn't a type, it's more like a predicate on types
18:00:00 <Cale> pejo: yes, but in a mostly acceptable way
18:00:37 <Cale> pejo: They mess up principal types, but in a way that type signatures are only locally required where the fancy type system features are being used.
18:01:10 <Cale> synthase: and when that predicate is true, you get a bunch of functions which operate on it.
18:01:19 <Cale> class Ord a where
18:01:26 <Cale>   (<) :: a -> a -> Bool
18:01:36 <Cale>   --  etc.
18:02:08 <Cale> synthase: Best not to confuse it with classes in the OO sense of the term.
18:02:26 <pejo> Cale, and that can't be had with subtyping?
18:02:27 <idnar> it's more like an interface, if anything
18:02:38 <idnar> (in, eg. the Java sense)
18:02:42 <synthase> ok
18:02:44 <Cale> Yeah I was about to say, they're a little bit like Java interfaces.
18:02:46 <litb> or like concepts of c++0x
18:02:48 <Cale> But more general.
18:03:04 <Cale> Yes, concepts are totally stolen from Haskell typeclasses :)
18:03:09 <litb> actually very much identically
18:03:14 <idnar> it also bears some similarity to C++ templates, except the constraints aren't implicit
18:03:15 <Cale> (I think it was Wadler who was involved in that)
18:03:28 <litb> hehe
18:03:32 <synthase> concepts of c++0x refers to the newest c++ standard?
18:03:37 <Cale> synthase: yeah
18:03:44 <synthase> what's the current standard for c++?
18:04:11 <idnar> (with a C++ template, you have an arbitrary type that's just constrained by stuff you do with it in the function / class; there's no way to explicitly declare what operations need to be supported)
18:04:12 <litb> 03, and the new one will be released with hurd
18:04:27 <litb> .. next year =)
18:04:46 <idnar> haha
18:05:35 <synthase> Let's say given: rem :: Integral a => a -> a -> a would mean that its range of variable types is Int and Integer?
18:05:43 <Cale> I hear they're rewriting Duke Nukem Forever in it.
18:05:57 <litb> lol Cale
18:05:59 <Cale> synthase: and Word8, etc.
18:06:10 <synthase> ok
18:06:14 <Cale> synthase: but yes :)
18:06:23 <idnar> @instances Integral
18:06:38 <lambdabot> Couldn't find class `Integral'. Try @instances-importing
18:06:49 <Cale> whoa, that's funny :)
18:06:52 <synthase> so the set Integer -> Integer -> Integer, Int->Int->Int and Word8->Word8->Word8
18:06:57 <Cale> yeah
18:06:59 <idnar> isn't Integral in the prelude?
18:07:03 <Cale> idnar: it is.
18:07:09 <idnar> heh.
18:07:25 <Cale> I think @instances just uses its own database. It could be an oversight.
18:08:07 <Cale> synthase: It's an open set of types though. If you define your own type, you can make it an instance of Integral as well, if you care to define the operations in it.
18:08:59 <Cale> (you need at least quotRem and toInteger, as well as instances of a bunch of other classes)
18:09:43 <litb> hm, what is a nice exercise to get into State a ?
18:09:53 <Cale> Instances of classes can also depend on other instances. For example, there's an instance of Ord for [a], whenever there's an instance of Ord for a
18:10:08 <Cale> instance Ord a => Ord [a] where
18:10:29 <Cale>     compare []     []     = EQ
18:10:29 <Cale>     compare []     (_:_)  = LT
18:10:29 <Cale>     compare (_:_)  []     = GT
18:10:29 <Cale>     compare (x:xs) (y:ys) = case compare x y of
18:10:29 <Cale>                                 EQ    -> compare xs ys
18:10:30 <Cale>                                 other -> other
18:10:43 <Cale> (forgive the paste, I just want to give some idea of what's involved)
18:11:31 <Cale> compare is a function which takes two values and gives LT, EQ or GT depending on whether one is less than, equal to, or greater than the other.
18:11:34 <Cale> > compare 3 5
18:11:37 <lambdabot>  LT
18:11:43 <Cale> > compare 7 5
18:11:44 <lambdabot>  GT
18:11:53 <litb> > compare "hello" "hella"
18:11:54 <lispy> ?src Ord
18:11:54 <lambdabot> class  (Eq a) => Ord a  where
18:11:54 <lambdabot>     compare      :: a -> a -> Ordering
18:11:54 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
18:11:54 <lambdabot>     max, min         :: a -> a -> a
18:11:54 <lambdabot>  GT
18:12:28 <Cale> There's actually a little more to Ord than that. There are default implementations of everything in terms of compare.
18:12:50 <wli> I'm trying to minimize a nasty function by grid searching and am getting crap results. I'm wondering if there's a gotcha I need to watch for or something.
18:14:02 <lispy> wli: based on what little numerical analysis I took in college, I would say, make sure it has good derivatives.
18:14:23 <wli> The algorithm doesn't use derivatives.
18:14:37 <MyCatVerbs> Gah. haskell-cafe is bloody high volume.
18:14:55 <Cale> MyCatVerbs: I use Gmail to manage it :)
18:14:56 <MyCatVerbs> Leave it a week, you never catch up.
18:15:04 <lispy> wli: ah, it just seemed that whenever we had nasty things or couldn't find convergence we had a function whos derivative was weird (or second or third derivative)
18:15:05 <Cale> Oh, actually reading it all? :)
18:15:06 <MyCatVerbs> Cale: I'm using mutt and heavy abuse of my 'd' key.
18:15:10 <MyCatVerbs> Cale: yesh.
18:15:16 <Cale> Heh, I could do that a couple years ago, not anymore :)
18:15:25 * lispy can't follow cafe either
18:15:34 <litb> is haskell-cafe the mailing list?
18:15:39 <lispy> I still receive it, but I havent' even bothered to look at it in probably 5 months
18:15:44 <lispy> litb: yeah
18:15:52 <ivanm> IIRC, someone mentioned using a news reader to manage -cafe...
18:15:57 <litb> oh, so haskell is growing rapidly?
18:15:57 <Cale> litb: It's a mailing list. It's the one for general discussion.
18:16:04 * cjb uses gnus.
18:16:16 * litb uses all-day crashing kmail
18:16:17 * lispy used gnus until he realized he hate it
18:16:18 <Cale> litb: haha, yes, almost exponentially.
18:16:42 <cjb> litb: yup, by all measurements: people here; number of hackage projects; mailing list posts; etc.
18:16:53 <lispy> emacs just wasn't the right platform to be reading my email in
18:16:53 <ivanm> Cale: so Haskell is an O(e^n) language? ;-)
18:17:10 <cjb> lispy: do you use emacs for other things?
18:17:12 <lispy> but, then I just can't read email on a terminal in this day and age of non-plain text email
18:17:20 <Cale> I think we should introduce some changes to the language to make it more confusing and curb the tide.
18:17:21 * ivanm likes claws-mail
18:17:28 <jeffz> http://news.gmane.org/gmane.comp.lang.haskell.cafe this one is good...
18:17:29 <lambdabot> Title: Gmane Loom
18:17:35 <ivanm> Cale: like using only punctuation for prelude functions? :p
18:17:36 <cjb> lispy: I use a terminal when I'm not at work, and an X frame when I am.
18:17:44 <lispy> cjb: I used emacs for irc until semi-recently when I was forced to quit for the sanity of other users on the system (emacs would hog all the ram)
18:17:47 <mrd> Cale: (.) = fmap = map -- go!
18:17:53 <litb> lispy: heh, i agree. emacs is not good for emails for me and not good for playing music. lol
18:18:04 <litb> but it's excellent for coding haskell and superb for coding c++ and c. i love it
18:18:06 <mrd> lispy: you using a 486 from '95?
18:18:28 <cjb> lispy: you probably weren't using erc-truncate, which keeps IRC buffers at static size (and lets you log the rest to disk).
18:18:36 <lispy> mrd: no, erc seemed to cause a memory leak.  after 30 days or so emacs would be using 300-400megs of ram
18:18:47 <lispy> cjb: I tried many things, including truncate
18:19:02 <johnnowak> hah, my irc client doesn't have that problem. it always crashes within 3-4 hours.
18:19:02 <mrd> hmm, weird
18:19:02 <litb> what? fmap = map ? nah..
18:19:03 <cjb> lispy: odd.  I also use ERC on a long-lived emacs process.
18:19:56 <lispy> after a couple months of trying things I just gave in and switched to irssi, so it's not the end of the world, just an era for me :)
18:20:07 <lispy> I only use emacs for haskell these days, and I really don't think emacs is very good at haskell
18:20:15 <litb> i used erc back then
18:20:38 <litb> but it was too hard to keep all channel buffers working and switching between them
18:20:44 <lispy> I think visual studio is much better at haskell ... oops but it requires cabal :(
18:21:00 <litb> lispy: does it work with haskell?
18:21:10 <lispy> litb: yes, with visual haskell plugin
18:21:16 <lispy> ?go visual haskell
18:21:25 <litb> oh nice
18:21:26 <jeffz> litb, c-x right-arrow is too hard?
18:21:27 <lambdabot> http://www.haskell.org/visualhaskell/
18:21:27 <lambdabot> Title: Visual Haskell
18:21:31 <litb> but i like emacs haskell-mode anyway
18:21:54 <lispy> I like iswitchb for emacs
18:22:01 <lispy> it makes all buffer switching easier
18:22:44 <lispy> other than the syntax highlighting I don't get much from haskell-mode.  For one, M-q doesn't toggle correctly with haskell code :(
18:22:52 <litb> combined with ecb , it's easy enough to code
18:23:09 <lispy> litb: does ecb help with identifier lookup?
18:23:15 <litb> jeffz: nah, but it sucked as a whole as a irc client
18:23:25 <mrd> lispy: fill paragraph?
18:23:30 <litb> lispy: you see all identifies on the left
18:23:38 <litb> or right or wherever you placed the symbol pane
18:23:40 <lispy> I've tried hask-tags but it usually takes me to the wrong place in the source...like I looked for Cache, the type and it took me to foo_make_cache
18:23:51 <lispy> mrd: oh, sorry M-;
18:23:53 <jeffz> litb, I don't find it a problem, the memory usage of a few hundred mb after more than a month of #haskell and a few other channels only puts a small dent in the total available memory of this machine :)
18:24:05 <mrd> weird, what version?
18:24:20 <litb> jeffz: oh, you remind me that i have to configure logging for irssi..
18:24:35 <litb> i like to state the size of my logfiles loud and proud to ppl asking me
18:24:45 <lispy> mrd: the problem is that it add "-- " to the beginning of lines, but hitting it again just removes "--" not the space.  Since Haskell cares about indentation levels this breaks code :(
18:24:51 <jeffz> litb, soon I'm sure no one will care about a few hundred mb of memory usage per month
18:25:13 <mrd> hmm.  i tend to use C-x r d to remove stuff like that
18:25:21 <litb> lispy: you know what ecb is?
18:25:32 <lispy> litb: yeah, I've seen it, but never used it.
18:25:44 <mrd> still, didn't break with the latest version /shrug
18:25:50 <lispy> I am looking for a way to make editing large projects easier.  Haskell tags doesn't cut it.
18:25:59 <lispy> mrd: what is C-x r d?
18:26:04 <mrd> rectangular delete
18:26:08 <lispy> oh
18:26:17 <lispy> I just want a quick way to comment/uncomment blocks of code
18:26:27 <mrd> M-; "worked for me"
18:26:54 <lispy> how can I check my haskell-mode version?
18:26:56 <lispy> I'd like to compare
18:27:06 <lispy> litb: emacs code browser, right?
18:27:52 <mrd> M-x haskell-version
18:27:54 <litb> lispy: yes
18:27:57 <litb> i'll make a screeny
18:28:17 <lispy> Using haskell-mode version v2_1
18:28:21 <mrd> ah that's quite old
18:28:22 <litb> http://img443.imageshack.us/img443/8063/snapshot55sf7.png
18:28:37 <litb> i've v2_3
18:29:09 <lispy> mrd: what is your version?
18:29:14 <lispy> ?where haskell-mode
18:29:14 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
18:29:42 <ivanm> lispy: last time I tried using ECB with haskell, it didn't show me all those functions, etc. on the side... how did you do it?
18:29:42 <lispy> whoa, that wikipage must be old, it says to use CVS
18:29:44 <litb> you have Varibles, Imports, Instances and Datatypes to browse on that pane, lispy
18:30:03 <lispy> ivanm: oh, I think you meant litb
18:30:36 <litb> ivanm: i just installed ECB, cedet, and haskell-mode
18:30:38 <ivanm> lispy: ummm, yes... xchat's tabbing needs to be better ;-)
18:30:51 <ivanm> litb: hmmm... maybe I had a dodgy config option at the time...
18:31:15 <lispy> cedet?
18:31:27 <ivanm> common emacs development <something> tools
18:31:45 <ivanm> just a bunch of libraries for code parsing, etc.
18:32:32 <ivanm> make that "collection of emacs development tools"
18:32:37 <wli> lispy: It's sum [abs (y - eval coefs x) | (x, y) <- points] where eval (Coefs a0 a1 a2 b1 b2) x = (a0 + x * (a1 + x * (a2 + x * a3))) / (1 + b1*(x-b2)^2)
18:32:41 <lispy> hmm...debian on this machine doesn't seem to havea newer haskell-mode
18:32:47 <mrd> stable would be old
18:32:50 <ivanm> 2.4 is the latest, IIRC
18:32:51 <litb> ivanm: you have to load-file the cedet so that it uses semantic to parse the file
18:33:05 <wli> lispy: Rather sum [abs (y - eval coefs x) | (x, y) <- points] where eval (Coefs a0 a1 a2 a3 b1 b2) x = (a0 + x * (a1 + x * (a2 + x * a3))) / (1 + b1*(x-b2)^2)
18:33:25 <litb> ivanm: wow, i still have 2.3
18:33:26 <ivanm> litb: hmmm? you mean a hook into haskell-mode?
18:33:29 <litb> time to upgrade baby!
18:33:52 <ivanm> heh
18:33:52 <wli> lispy: Basically no obvious derivative.
18:34:10 <lispy> i see :)
18:34:27 <litb> no that's not necassary ivanm . haskell-mode seem to automatically does that stuff
18:34:43 <litb> but maybe it's just that you had a too old ecb or something
18:35:19 <lispy> anyone know where haskell-mode is really kept these days?
18:35:26 <lispy> I highly doubt this cvs repo is the right
18:35:28 <ivanm> or else a dodgy config setting in .emacs... then again, IIRC this was at uni on an older emacs where I had to manually install everything myself...
18:35:36 * ivanm pats emerge
18:36:00 <ivanm> lispy: http://www.iro.umontreal.ca/~monnier/elisp/, I think
18:36:02 <lambdabot> Title: Emacs Lisp packages
18:36:07 <ivanm> at least, that's where gentoo gets it from
18:36:17 <ivanm> including the src for 2.4...
18:36:19 <lispy> okay, thanks
18:37:27 <mrd> hah, silly typo in cvs head
18:38:46 <mrd> yea so the later haskell-modes have my helpful changes to query type/info/location of things from GHCi
18:44:35 <litb> i just makepkg'ed and it works quite good (the 2.4)
18:45:04 <lispy> hmm...i'm still getting the default haskell-mode instead of the one I just put in my home dir
18:45:53 <mrd> well did you load it?
18:46:20 <mrd> get rid of the old pkg and load the haskell-site-file from the new dir
18:46:21 <lispy> my load-path is wrong :(
18:46:28 <lispy> I can't get rid of it
18:47:22 <lispy> it's weird that my load path is wrong, I intentionally add my homedir to it at the start of .emacs
18:47:24 <litb> ah, 2.4 understands "-- | ..." form of commentars
18:47:38 <wli> I guess I probably want simulated annealing or some such.
18:50:15 <lispy> ah still broken
18:50:33 <lispy> select a at least one line, hit M-;, then select it again and hit M-;
18:50:48 <lispy> note that there will be a space at the beginning of the line for everytime time you do tihs
18:51:04 <mrd> not for me
18:51:26 <lispy> weird my haskell-version reports v2_4 now
18:51:58 <lispy> mrd: what other options do you use?
18:52:14 <mrd> simple-indent
18:52:24 <lispy> i'm using that too
18:53:05 <lispy> I use font-lock, decl-scan, doc-mode, simple-indent and ghci
18:53:25 <mrd> sounds about the same
18:53:33 <mrd> emacs22?
18:53:48 <lispy> 21.4.1
18:53:52 <mrd> hmm, that's probably it
18:54:02 <mrd> M-; is an emacs function, not haskell-mode
18:54:17 <lispy> Hmm
18:54:25 <mrd> 'comment-dwim'
18:55:14 <lispy> I guess I need to talk to the person with root
18:55:26 <syntaxfree> @quote root
18:55:27 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
18:55:27 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
18:55:45 <lispy> lambdabot: could taht be any more contrived?
18:55:49 <lispy> ?quote root
18:55:50 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
18:55:50 <lambdabot> UTF8&s=books  <lambdabot> http://tinyurl.com/root7
18:56:03 <lispy> ?quote bottom
18:56:03 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
18:56:23 <syntaxfree> @quote lispy
18:56:24 <lambdabot> lispy says: lambdabot, changing the way Haskllers think since 2003
18:56:40 <hpaste>  mrd pasted "comment-dwim" at http://hpaste.org/5698
18:56:57 <mrd> maybe that'll work
18:57:25 <lispy> mrd: what is that? the source of comment-dwim from emacs22?
18:57:37 <mrd> yea heh
18:57:59 <lispy> I pasted that into *scratch* what was the command to evaluate it? C-x C-c ?
18:58:04 <mrd> M-C-x
18:58:13 <lispy> oh heh, C-x C-c is quit
18:58:14 <lispy> duh
18:59:07 <lispy> Symbol's function definition is void: comment-normalize-vars
18:59:16 <lispy> Bummer, I need more than just that.
18:59:22 <lispy> Oh well.
18:59:30 <lispy> I'll just talk to droundy about upgrading to emacs22.
18:59:33 <mrd> lemme see
18:59:48 <lispy> I probably just need him to run aptitude update
18:59:53 <lispy> I dont' have sudo permission for that one
18:59:56 <lispy> just install
19:00:07 <syntaxfree> what is this, #cult-of-rms?
19:00:30 <lispy> syntaxfree: no, #how-to-edit-haskell-in-emacs
19:00:44 <syntaxfree> ?quote vim
19:00:44 <lambdabot> mauke says: @quote vim
19:00:46 <mrd> #bugfixing-rms-code
19:01:16 <lispy> mrd: thanks for your help, but I can just wait :)
19:01:35 <syntaxfree> ?quote vim.
19:01:35 <lambdabot> No quotes match.
19:01:45 <mrd> if someone ever added inferior-haskell-mode to Reinke's plugins to vim, I think I might have to switch
19:01:46 <syntaxfree> ?quote vim
19:01:46 <lambdabot> mauke says: @quote vim
19:01:47 <lispy> ?quote emacs
19:01:47 <lambdabot> sorear says: [emacs haskell mode] not fucked up, just well documented
19:02:15 <oerjan> syntaxfree: i think we added that because mauke complained there were no vim quotes :D
19:02:20 <xif> ?quote vim
19:02:20 <lambdabot> mauke says: @quote vim
19:02:31 <lispy> ?quote emacs
19:02:32 <lambdabot> emu says:  it's translating to chinese? emacs has become sentient?! and it's a grad student?!
19:02:34 <xif> what does that mean?
19:02:50 <olsner> it's something about emacs
19:02:55 <syntaxfree> xif: shift happens. now you now.
19:02:58 <wagle_home> eh, xmonad is just emacs on steroids
19:03:06 <syntaxfree> ?quote shift
19:03:06 <lambdabot> therp says: good morning. I think I have been dreaming of shift/reset continuations...
19:03:38 <olsner> syntaxfree: now you! now? shift... the chickens are roaming
19:03:59 <syntaxfree> ?quote sod
19:03:59 <lambdabot> shapr says: A curse upon scientific paper publishers! May Elsevier and all the rest be sodomized by syphilitic camels!
19:04:21 <xif> that's kind of harsh
19:04:25 <olsner> ?quote
19:04:25 <lambdabot> Pupeno says: lambdabot is indeed the most impresive bot I've ever seen
19:04:42 * oerjan considers it a miracle that his keyboard is not sprayed right now
19:06:14 <xif> impresive indeed
19:06:23 <litb> hm, what can you do with this State monad now? i mean, does it have some usage ?
19:06:35 <olsner> oerjan: why would you spray your keyboard?
19:07:15 <oerjan> olsner: because i'm eating, and reading that camel quote simultaneously
19:08:20 <olsner> I guess the internet has reduced my sensitivity to the words sodomy, syphilis, and camel enough to make that quote not make an impact
19:08:26 <monochrom> The alternative is to spray your screen.
19:08:48 <litb> then he couldn't view the other sites anymore..
19:08:54 <syntaxfree> ?quote drugs
19:08:54 <lambdabot> dylan says: pugs, darcs, and lambdabot: gateway drugs to haskell.
19:08:55 <monochrom> hehehe
19:12:58 <litb> ok, i'm off. thanks to all teaching me =)
19:16:57 <wagle_home> @hoogle pugs
19:16:58 <lambdabot> No matches found
19:17:11 <lispy> that quote from shapr about the camels is right on.  I hate that same publisher.
19:17:52 <wagle_home> i wonder if to blame the authors who publish with elsevier
19:18:19 <Cale> @tell litb remind me (Cale) to show you some examples of using the State monad.
19:18:20 <lambdabot> Consider it noted.
19:18:29 <monochrom> No, don't blame the authors.
19:18:32 <lispy> well, when I published with them I was publishing to a specific journal, and only they have permission to publish that journal
19:18:39 <lispy> wagle_home: it's a problem with IP rights
19:18:46 <wagle_home> oh, i meant books, not journals
19:18:50 <lispy> wagle_home: knuth has a letter about this, explaining the problem pretty well
19:18:57 <lispy> wagle_home: ah
19:19:04 <wagle_home> is there a short summary?
19:19:08 <monochrom> Ah, books, yeah that one the authors take a bigger responsibility.
19:19:36 <mrd> http://theoryofcomputing.org/crisis.html
19:19:37 <lambdabot> Title: Crisis in the cost of journals: Theory of Computing: An Open Access Electronic J ...
19:19:48 <wagle_home> oh..  knuth is about the journal problem..  i know that one
19:20:10 <monochrom> I think I can summarize. He doesn't want university libraries to get ripped off for the journals.
19:20:51 <lispy> but also, journals screw the authors by taking over much of the IP rights
19:20:57 <cjb> http://mako.cc/fun/overpricetags/
19:20:58 <lambdabot> Title: Overprice Tags
19:20:59 <lispy> too much, anyway
19:25:36 <Khisanth> that is a very thin journal for $10k
19:39:52 <wli> Proper simulated annealing seems to be getting vaguely necessary.
19:41:02 <dons> http://reddit.com/info/68xkq/comments/ nice.
19:44:19 * kaol has spent the last hour trying to come up with an one line sieve of Eratosthenes
19:46:26 * gwern wonders when reactive programming stuff will mature and settle down; speaking as an observer, it all seems very experimental and unsettled
19:46:26 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
19:47:25 <dons> i think its pretty well understood. just not widely understodd
19:47:37 <dons> the frp stuff's been around for more than a decade
19:48:14 <mrd> > nubBy (\ x y -> y `mod` x == 0) [2..]
19:48:19 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:49:32 <gwern> @tell sclv I definitely look at that stuff, although I'm uncertain about some of them - wasn't Hat obsoleted by GHCi's new debugger or something?
19:49:32 <lambdabot> Consider it noted.
19:50:56 <monochrom> @seen dolio
19:50:57 <lambdabot> dolio is in #haskell-blah and #haskell. I don't know when dolio last spoke.
19:51:10 <dolio> Eh?
19:51:40 <kaol> oh, I know that there's a correct answer around already. I just wanted to see if I could come up with an implementation myself.
19:54:15 <wli> > nubBy ((.) (==0) . flip mod) [2..]
19:54:16 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:55:45 <wli> You could also use nubBy (((==0) .) . flip mod) [2..]
19:56:46 <wli> ISTR that this one's been extensively "golfed."
19:57:06 <mrd> par for the channel
19:57:35 <dolio> > nubBy(((>1).).gcd)[2..]
19:57:39 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:57:55 <wli> That's the heavily golfed version.
19:58:04 <dolio> Yeah.
19:58:14 <dolio> I don't think I've seen any shorter.
19:59:17 <wagle_home> n(((>1).).g)[2..]
19:59:22 <wagle_home> > n(((>1).).g)[2..]
19:59:22 <lambdabot> Terminated
19:59:29 <wagle_home> aww
19:59:34 <wagle_home> > n(((>1).).g)[2..]
19:59:35 <lambdabot> Terminated
20:02:17 <bd_> :t n
20:02:19 <lambdabot> Not in scope: `n'
20:02:24 <bd_> ?
20:54:13 <mwc> somebody say something smart
20:54:25 <mwc> I'm marking exams, and my brain is turning to jello
20:55:04 <wli> I'm at a total loss to crank out simulated annealing in a reasonably small snippet of code.
20:58:07 <Cha1> wli: have you seen this? http://haskell.org/pipermail/haskell/2005-January/015212.html
20:58:25 <Cha1> not sure of the current status
20:59:27 * Lycurgus_ only had to mark exams/hw once. I remember doing so in Linear Algebra for stuff students did in a Math stats class in which I was also a student. At that age it was fun, but it would be deadly now.
20:59:31 <mwc> the algorithm is pretty simple: annealStep s t = let s' = perturb s in if fitness_delta s s' < tolerance t then s else s'
20:59:31 <mwc> where tolerance t = max(exp(-a*t), some_random_val)
21:00:25 <mwc> wli, what are you trying to apply SA to?
21:00:25 <mwc> because in my experience, SA is a bronze-plated bitch to get working
21:00:25 <mwc> Genetic algorithms are more forgiving
21:01:27 * ddarius fiddles with his CT article some more.
21:01:35 <mwc> Lycurgus, they're engineering exams. I just had somebody apply the quadratic equation to factor m^2 - 3m = 0, and do it wrong.
21:03:00 <ddarius> mwc: What answer did they get?
21:03:31 <dolio> Man, Agda's operator definitions are sexy.
21:03:31 <mwc> -3, 0
21:03:44 <ddarius> At least it wasn't -that- far off.
21:03:54 <mwc> -3 \pm 3 / 2
21:04:24 <ddarius> \pm ?
21:04:34 <mwc> plus or minus
21:04:47 <cjb> I always forget that latex symbol.
21:06:25 <mwc> funny story: when I started as a grad student, the email containing our orientation information was sent as a raw latex document. Never received a second one. I can only conclude it was to weed out anyone who fears the tex
21:06:35 <wli> mwc: Sadly it's multivariate and some can be positive or negative and some must be nonnegative.
21:06:57 <mwc> wli, some what/
21:07:01 <mwc> some variables?
21:07:11 <wli> mwc: Yeah.
21:07:21 <ddarius> mwc: TeX, the language, is pretty scary.
21:07:42 <mwc> as long as you never venture outside of latex, it's not so bad
21:07:52 <ddarius> mwc: That's what I try to do.
21:07:56 <mwc> somebody needs to replace TeX, but no one has the will to.
21:08:32 <ddarius> Who could design a language better than Knuth... oh wait.
21:09:25 <mwc> TeX: the typesetting language from the guy whose idea of code samples are assembly for a non-existent CISC machine
21:09:45 <mwc> oh dear
21:09:50 <wli> mwc: Basically sum [abs (y - eval coefs x) | (x, y) <- points] where eval (Coefs a0 a1 a2 a3 b1 b2) x = (a0 + x * (a1 + x * (a2 + x * a3))) / (1 + b1*(x-b2)^2)
21:10:10 <mwc> well, at least it should be somewhat smooth
21:10:13 <mwc> I think you've got a shot
21:10:46 <wli> mwc: I'm not terribly sure how to deal with the discontinuities in the gradient from the absolute value.
21:12:51 <wli> I do know I'm getting garbage from searching through grids (and it's dogslow, too).
21:12:57 <Svrog> can haskell libraries be linked against the main program dynamically?
21:13:08 <mwc> Svrog, sort of. There's hs-plugins
21:13:20 <Svrog> hmm thats not quite what i meant
21:13:23 <mwc> if you want to write a DLL in haskell, then no
21:13:49 <Svrog> main reason im asking is that im puzzled with the number of libraries on hackage using lgpl
21:14:04 <mwc> that would be why.
21:14:07 <Svrog> if you cant link dynamically then its no different to gpl
21:14:26 <mwc> I think they're LGPL+Linking Exception
21:14:39 <Svrog> they dont usually specify that
21:14:53 <mwc> or at least I always assumed so. Since I don't write anything proprietary, I never bothered to look into it
21:15:10 <synthase> if part of a function definition includes the pattern mnmInt (x:xs) =  then how should the input be formatted?
21:15:28 <dons> as  a list , synthase
21:15:32 <ivanm> @remember mwc TeX: the typesetting language from the guy whose idea of code samples are assembly for a non-existent CISC machine
21:15:32 <lambdabot> It is forever etched in my memory.
21:15:33 <dons> (or string)
21:16:02 <dibblego> synthase, that is called pattern matching, where x is the first element of a list and xs is the remainder
21:16:15 <dons> :t (:)
21:16:19 <lambdabot> forall a. a -> [a] -> [a]
21:16:20 <dons> > 1 : 2 : []
21:16:23 <mwc> synthase, as a list or string, but moreover, a NONEMPTY list or stirng
21:16:25 <lambdabot>  [1,2]
21:16:31 <mwc> where string is just a list of characters
21:16:42 <mwc> > (\(x:xs) -> x) []
21:16:43 <lambdabot>   Non-exhaustive patterns in lambda
21:16:44 <synthase> dons: what I mean is, mnmInt is defined also as mnmInt [x] = x, in which case, I give as an argument to mnmInt [1] or [2], etc... but for (x:xs) how should it be formatted? (1:2:3) etc, doesn't work
21:16:52 <synthase> ah
21:16:58 <mwc> synthase, [1,2,3]
21:17:01 <synthase> right
21:17:03 <mwc> or
21:17:08 <mwc> > 1 : 2 : 3 : []
21:17:08 <lambdabot>  [1,2,3]
21:17:12 <dibblego> synthase, [x] is the same as (x:[])
21:17:24 <dons> [1,2,3] is special syntax for (1:2:3:[])
21:17:27 <dibblego> synthase, so that is the case for the one element list
21:17:29 <mwc> synthase, the right side of : has to be a list
21:17:31 <dons> ?src (:)
21:17:31 <lambdabot> Source not found. :(
21:17:34 <dons> ?src [a]
21:17:34 <lambdabot> Source not found. You untyped fool!
21:17:36 <dons> ?src []
21:17:36 <lambdabot> data [] a = [] | a : [a]
21:17:52 <dons> lists are data  types that are either [] or a node of some 'a', and a list tail
21:18:04 <ivanm> hmmm... if the special case [x,y,z] notation wasn't inbuilt into the prelude, would it be possible to actually define it in a separate library?
21:18:25 <dons> an infix (,) with [ and ] ?
21:18:43 <ivanm> maybe... it would be rather convoluted, wouldn't it?
21:18:46 <wli> ivanm: Not in Haskell as it otherwise stands.
21:18:49 <ivanm> especially since (,) is already defined
21:18:51 <mwc> ivanm, no. Actually, constructor operators (starting with :) are a GHC extension
21:19:10 <ivanm> wli: that's what I figured
21:19:30 <ivanm> mwc: is that meant to be an emoticon, or just having a colon before a bracket? :p
21:19:39 <mwc> the latter
21:20:22 <ivanm> yeah, so the syntactic sugar for lists and tuples are un-redefinable
21:21:32 <wli> It is possible to define customizable operators with sufficient generality to avoid special cases for lists.
21:21:57 <wli> That is, if you're designing the language, implementing a sufficiently fancy parser, etc.
21:22:56 <ivanm> *nod*
21:23:52 <ddarius> mwc: For data constructors, that is not an extension.
21:26:30 <mwc> ddarius, oh? Never found anything about that in the report
21:26:48 <ddarius> mwc: Already, the standard Complex type uses :+
21:27:12 <mwc> True
21:28:41 <mwc> yep, there it is, section 2.4
21:28:57 <mwc> section 4 defines a simpletype as a tycon tyvar ...
21:29:00 <mwc> and tycon as a conid
21:29:09 <mwc> well, section 2 defines tycon as a conid
21:29:49 <mwc> and conid -> large {small |large |digit'}
21:32:21 <ddarius> See 4.2.1
21:33:20 <mwc> aargh
21:33:26 * mwc is defeated by the HTML standard
21:33:35 <mwc> left my hardcopy of the reference at home
21:36:26 <ddarius> Annoyingly, (:) is a reserved operator
21:37:10 <mwc> why, you'd want to use it after you hide prelude?
21:38:09 <ddarius> Sure.  I've redefined several other things in the Prelude before.  It's just an arbitrary restriction for no apparent reason.
21:42:03 <wagle_home> when i first used vms, I got a whole barrel full of special unix-like commands and scripts..  after a few years, i lost that, and was completely helpless to use vms
21:53:06 <BMeph> wagle_home: Heh-heh, that reminds me of Lisp. Its greatest usefulness is the use of tools that allow you to ignore the regular methods of using the system.
21:57:22 <ddarius> This article is already looking a lot better with Definition and Theorem blocks.
22:03:11 <wagle_home> ddarius, article on what?
22:07:11 <ddarius> Category Theory.
22:09:28 <wagle_home> which package do you use for drawing diagrams?
22:10:42 <regulate> i use dia
22:11:38 <ddarius> wagle_home: I don't have any diagrams.  However, normally I use Xy-pic
22:16:01 <wagle_home> yeah, finally found it (again)...  was trying to remember
22:16:01 <wagle_home> Kristoffer Rose's name
22:29:11 <chadz> hey all. what's the current webserver of the week w/ fcgi support?
22:30:49 <mwc> cherokee, lighttpd
22:31:38 <chadz> hmm, haven't heard of cherokee.
22:31:43 <chadz> which is more lightweight?
22:32:54 <mwc> both are lightweight
22:33:03 <mwc> I've used lighttpd, looked into cherokee
22:33:20 <chadz> i'll try out cherokee, sound's gimicky enough
22:33:46 <chadz> "cherokee - extremely fast and flexible web server"  <- debian description
22:33:49 <chadz> hah
22:34:48 <mwc> deploying a new haskell webapp?
22:37:27 <chadz> mwc: no one's on to play games, so I think i'll waste time with some blog app
23:21:59 <lQg> is there a deepElems ? something that can check if the String I have occurs in a [[String]]
23:24:36 <ddarius> :t any . elem ?x
23:24:40 <lambdabot>     Couldn't match expected type `a -> Bool'
23:24:40 <lambdabot>            against inferred type `Bool'
23:24:40 <lambdabot>     Probable cause: `elem' is applied to too many arguments
23:25:13 <ddarius> :t any (elem ?x)
23:25:14 <lambdabot> forall a. (Eq a, ?x::a) => [[a]] -> Bool
23:25:25 <ddarius> :t any . elem
23:25:26 <lambdabot> forall a. (Eq a) => a -> [[a]] -> Bool
23:26:32 <wagle_home> :t nubBy
23:26:33 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
23:26:59 <wagle_home> @src nubBy
23:27:00 <lambdabot> nubBy eq []             =  []
23:27:00 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
23:58:27 <Trinithis> is there an io action that immediatly terminates the program?
23:58:40 <ddarius> @hoogle exit
23:58:46 <lambdabot> System.Exit :: module
23:58:46 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
23:58:46 <lambdabot> System.Exit.exitFailure :: IO a
23:59:02 <Trinithis> cool
23:59:19 <chadz> hmm, anyone play with cherokee before? I'm getting pretty good at killing it whilst trying to run my haskell cgi jazz.
