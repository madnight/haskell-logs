00:00:12 <radetsky> you can model that with a mechanical process which tests for the circumstances and applies the rule that fits the circumstance
00:00:18 <radetsky> but that doesn't mean that algorithms *are* mechanical processes
00:00:38 <scottutd> radetsky: Right. But we can model that model as a TM.
00:00:51 <scottutd> radetsky: that does the aforementioned tests and rule applications.
00:00:57 <radetsky> scottutd: you can model it with all kinds of things
00:01:08 <radetsky> you can model it with some new flavor-of-the-week foundational theory
00:01:16 <wy> wagle_home: Which course?
00:01:31 <wagle_home> http://farm1.static.flickr.com/3/3151572_526e612fae.jpg
00:01:33 <scottutd> radetsky: Or we could just stick with TMs...
00:01:56 <scottutd> wagle_home: I don't know what that is, but it looks cool.
00:01:57 <wagle_home> wy programming languages, adv programming languages seminar
00:02:07 <wy> wagle_home: Is that called applied string theory?
00:02:22 <wagle_home> its a tinkertoy computer
00:02:38 <wy> wagle_home: nice. have you used EOPL?
00:03:06 <radetsky> scottutd: we could, but we could also use lambda calculus. I have to take your word for it that TMs are actually better than LC for certain theoretical issues
00:03:15 <radetsky> or rather, I can't prove you wrong
00:03:48 <wagle_home> http://ohgizmo.com/2006/12/14/the-tinkertoy-tic-tac-toe-playing-computer/
00:03:49 <lambdabot> Title: OhGizmo! » Archive » The Tinkertoy, Tic-Tac-Toe-Playing Computer, http://tinyurl.com/2zdto5
00:04:29 <scottutd> radetsky: I am intrigued though, I feel like it is along the lines of Denotational vs. Operational semantics
00:04:50 <scottutd> radetsky: I have no idea what the difference is, but my professors all say there is one
00:04:59 <wagle_home> wy, i actually like it better than sicp
00:05:05 <scottutd> radetsky: (other than trivial notational matters)
00:05:28 <wy> wagle_home: How does it compare with TAPL?
00:06:13 <wagle_home> wy, havent read it yet, but its near the top of my list
00:06:19 <radetsky> scottutd: as in turing machines superficially appear to describe a process, but lambda calculus superficially appears to define an answer?
00:06:26 <radetsky> (i.e. procedural vs. declarative)
00:07:24 <scottutd> radetsky: Precisely. Which in the semantics part, my professors say makes a large difference. So perhaps that same bias is towards TMs because there is more information about how you get somewhere?
00:07:30 <radetsky> I mean, I ain't got all that fancy book-learnin', but that's what it sounds like you're talking about
00:08:24 <wy> wagle_home: I didn't like TAPL very much actually
00:08:52 <wy> wagle_home: I should EOPL after I finish The Reasoned Schemer :)
00:09:22 <wagle_home> i dunno about the new edition of eopl..  havent read it and its a lot shorter
00:09:58 <scottutd> wy: Have you seen a better book then TAPL? I'd like to look at a different book on the same topic as well
00:10:03 <wy> wagle_home: I like the little books because they are short :)
00:10:53 <radetsky> scottutd: I think I see what you're getting at, but I'd imagine that especially in theory, but also in industry, you
00:11:06 <radetsky> 're not better off with your semantics specifying how to get somewhere
00:12:11 <scottutd> radetsky: A lot of the proofs in comp. theory rely on properties of TMs as a state machine: ie. they either halt in an accepting state, halt in a rejecting state, or loop forever
00:12:19 <wy> It seems that Turing also contributed a lot to lambda calculus
00:13:01 <scottutd> radetsky: And properties of languages are defined in terms of what a TM does on each string in the language... I'm not sure what the lambda calculus equivalent would be
00:13:14 <radetsky> I'm not either
00:13:41 <scottutd> I'm not sure how you would reason about a lambda calculus expression not terminating... (someone who has done lambda calc more recently might know)
00:13:45 <radetsky> but if TMs and LC are equivalent, then there must be an equivalent way of looking at it from the perspective of LC
00:14:22 <radetsky> moreover, the fact that so many ideas in the theory of computing are stated in terms of turing machines rather than lambda calculus is going to affect the way people look at things
00:15:03 <radetsky> (In "Meta Math!" Chaitin makes a similar point using three different proofs that there are infinitely many primes)
00:15:19 <radetsky> let me rephrase that
00:15:20 <quicksilver> scottutd: by 'LC expression not terminating' I would understand 'LC term whose reduction sequence doesn't terminate'
00:15:28 <scottutd> radetsky: I'm positive I can make a TM that interprets lambda calculus, and from denotational semantics, I'm pretty sure I can define a TM in lambda calculus... so they must be equivalent in power. I guess the question is does one view make it easier to reason? (If one or other is, then whenever we want to reason about one, we would just convert to the other)
00:15:32 <quicksilver> like (\x . x x) (\x . x x)
00:15:55 <radetsky> what I meant to say is that I'm thinking of Chaitin's point here, not that he also independently discovered what I'm talking about. (I have an ego, but it's not THAT big)
00:16:01 <wagle_home> lambda expressions have more than one reduction sequence
00:16:06 <scottutd> quicksilver: right, but "whose reduction sequence doesn't terminate" sounds like its talking about a mechanistic algorithm around Lambda Calc...
00:16:13 <quicksilver> yes.
00:16:20 <quicksilver> there is a mechanistic algorithm around LC
00:16:24 <quicksilver> well, there are several
00:16:33 <radetsky> scottutd: I am suggesting precisely that. I think that LC would tend to make it easier to reason.
00:16:36 <quicksilver> reduction strategies
00:17:01 <quicksilver> and then there are some theorems which show it doesn't matter which strategy you use, under certain assumptions.
00:17:02 <radetsky> and that this explains in part why functional programming is so awesome
00:17:09 <scottutd> quicksilver: Which makes me feel like in analysis, it would be easier to use TMs as the base and analyse LC in that framework
00:17:15 <wagle_home> normal order reduction is guaranteed to terminate if there is an reduction order that terminates
00:17:36 <quicksilver> TMs are pretty horrid for most kinds of analysis
00:17:38 <quicksilver> IMO
00:17:55 <quicksilver> because encoding interesting algorithms as a TM is horrid
00:18:17 <quicksilver> TMs are mostly used for reductio ad absurdum arguments about the halting problem
00:18:23 <wagle_home> hmm..  the world obviously needs a turing machine backend for ghc
00:19:12 <olsner> ... obviously!
00:19:16 <radetsky> plus that infinite tape is very handy for storing all your mp3's and porn
00:19:29 <radetsky> s/
00:19:35 <radetsky> s/\'s/s/
00:19:51 <olsner> radetsky: just store the porn starting at the end of the tape, and no-one'll find it
00:20:16 <quicksilver> I think more general FSMs are more useful for modelling
00:20:17 <wagle_home> is a terabyte disk a long enough tape?
00:20:36 <scottutd> quicksilver: But for the most part, who is encoding a minimum spanning tree algorithm into a TM?
00:20:47 <quicksilver> and of course you can write a FSM executor as a TM. So that's ok.
00:21:05 <wagle_home> oh right!  There's Never Enough Tape. [TM]
00:21:13 <olsner> wagle: yeah, you'd still be (infinity - 1TB) short
00:21:18 <radetsky> wagle_home: 2^38 < Infinity
00:21:28 <wy> oh I just found that Turing is Church's PhD student
00:21:29 <radetsky> I think
00:21:42 <radetsky> wy: *is*?
00:21:42 <scottutd> That is a good point though... if you want to discuss efficiency (NP and whatnot), how easy is it to make sense of that in a Lambda Calculus encoding
00:21:48 <wy> was
00:21:56 <scottutd> (I have nothing against FP by the way, I love it)
00:22:31 <radetsky> scottutd: that's tautological
00:22:45 <radetsky> NP is defined in terms of turing machines, so of course you'd have to change the terminology
00:23:03 <radetsky> but since they are equivalent, the same idea *must* be expressible in LC
00:23:16 <scottutd> quicksilver: Missed that point of yours. But yes, one of the arguments for TMs is its very easy to reduce most other models to them.
00:23:29 <dolio> Nobody uses Turing machines for discussing efficiency of algorithms, anyhow.
00:24:00 <scottutd> dolio: they do for proofs of some of the fundamentals
00:24:01 <olsner> turing machines having only sequential access to their tape will result in algorithms getting worse complexity on a TM than they'd have with random-access memory
00:24:13 <dolio> They write algorithms in pseudo code and talk about how many times certain operations are used.
00:24:38 <quicksilver> olsner: doesn't move anything out of P, though
00:24:44 <radetsky> dolio: he's not talking about the efficiency of particular algorithms
00:24:49 <quicksilver> olsner: so for the very course grained stuff, it's ok
00:24:59 <radetsky> he's talking about what NP[-completeness] is
00:25:36 <radetsky> the N stands for a non-deterministic turing machine (sort of)
00:25:39 <quicksilver> olsner: the TM encoding adds no worse than a P-factor
00:26:13 <dolio> Well, true. That's about the only place where Turing machines typically enter into it, in my experience, though.
00:26:14 <scottutd> I think that bit is where the lambda calculus model breaks down: since its declarative, it doesn't make sense to talk about how many steps it takes to get there... along which reduction?, etc...
00:26:29 <dolio> The formal definition of NP.
00:26:54 <scottutd> Which is a pretty interesting affair I'd say :P
00:27:00 <radetsky> scottutd: that's because you're thinking about P vs. NP in terms of numbers of steps
00:27:56 <radetsky> rather than, say, the difference between computing a function's value and inverting that function
00:28:02 <dolio> NP-completeness is defined in terms of reducing solutions to certain problems to solutions of other problems, so you don't need to talk about Turing machines.
00:28:06 <olsner> quicksilver: so it's a bounded slowdown.. but still, a TM is at least as slow as something with RAM
00:28:26 <radetsky> that's not a very good example, but my point is that there are different ways to think about it
00:28:44 <olsner> it'd be interesting to have a comparative survey of Turing Complete formalisms in terms of how (in-)efficient they are
00:29:36 <radetsky> and the formalism you use affects how you think about it
00:29:49 <scottutd> dolio: But the base case of that is in the efficiency of TMs... and a psuedocode argument is a TM argument, as anything you can write down an algorithm for, there is a TM for
00:30:01 <radetsky> dolio: right, but NP is defined in terms of turing machines
00:30:08 <dons> interesting metric, monthly contributors to haskell projects, over the years, http://www.ohloh.net/languages/compare?commit=Update&l0=haskell&l1=-1&measure=contributors&percent=
00:30:09 <lambdabot> Title: Open Source Programming Language Popularity Monthly Contributors History Chart - ..., http://tinyurl.com/2f63ej
00:30:35 <dolio> Right. I already agreed with that.
00:30:56 <radetsky> sorry, got confused
00:31:30 <olsner> dons: what is the percentage a percentage of?
00:31:40 <dolio> Although, I suppose if you wrote down functional pseudo code, you could translate that to lambda calculus instead of a Turing machine.
00:31:40 <dons> of all projects on ohloh, i think
00:31:48 <dons> note there's very few haskell projects up there yet
00:32:02 <dons> and none of the big ones (ghc, cabal, darcs, pugs, yhc, ...)
00:32:13 <dolio> Which might give you a clue as to how to define the things in lambda calculus.
00:32:20 <radetsky> dons: today ohloh.net, tomorrow the world!
00:32:26 <olsner> hmm, so 0.2% of ohloh's checkins are in haskell?
00:32:28 <scottutd> radetsky: I see where you're going with that.. I will have a chat with some people tomorrow
00:32:42 <dons> olsner: projects it analyses
00:33:30 <radetsky> dons: so for one thing, we know it can't find haskell.org/ghc
00:33:55 <radetsky> or wait, you already made that point
00:34:12 <olsner> or that no-one's been bothered enough to register ghc? however ohloh actually works
00:34:13 <siti> http://www.ohloh.net/languages/compare?measure=contributors&percent=&l0=cncpp&l1=-1&commit=Update
00:34:13 <dons> right, that's stats based on the 70 or so repos it knows about
00:34:14 <lambdabot> Title: Open Source Programming Language Popularity Monthly Contributors History Chart - ..., http://tinyurl.com/2gfvm5
00:34:16 <siti> poor c :(
00:34:26 <dolio> Well, we're 0.1% above Ada.
00:34:30 <dons> siti: huh
00:34:44 <scottutd> So... anyone know of other ways P =?= NP has been phrased other than execution time etc? That might shed light on the lambda calculus idea. Which reminds me of another reason people might use TMs... theres kind of equivalent work on space efficiency (which also kind of doesn't make sense in a declaritive model)
00:34:56 <radetsky> siti: I knew him well, Alfred Aho!
00:35:00 <dolio> And blown away by DOS batch script.
00:35:00 <dons> poor lisp, http://www.ohloh.net/languages/compare?measure=contributors&percent=&l0=-1&l1=lisp&l2=-1&commit=Update
00:35:01 <lambdabot> Title: Open Source Programming Language Popularity Monthly Contributors History Chart - ..., http://tinyurl.com/24swst
00:35:07 <radetsky> (it sort of scans, I guess)
00:35:11 <siti> lol
00:35:16 <siti> lisp is dead ;)
00:35:29 <dons> well, it made 8% in the early 90s
00:35:32 <dons> the golden age?
00:35:43 <radetsky> (proclaim 'siti 'BLASPHEMER)
00:36:06 <dons> haskell v erlang, http://www.ohloh.net/languages/compare?measure=contributors&percent=&l0=erlang&l1=haskell&l0_0=-1&commit=Update
00:36:07 <lambdabot> Title: Open Source Programming Language Popularity Monthly Contributors History Chart - ..., http://tinyurl.com/23z7zb
00:36:10 <olsner> 120 kloc of DOS batch script changed in one month!?
00:36:12 <dons> this will be fun once we get all the haskell projects on there
00:36:21 <scottutd> where did all the lisp go? I'm always blown away it was once so popular
00:36:33 <dons> scottutd: well, its one of the languages that's still alive
00:36:46 <dons> the pascal and modula-2 projects arne't in git or svn now
00:36:51 <dons> so they're not on the system
00:37:00 <dons> but lisp and C have been run down by python, perl , etc.
00:37:17 <siti> wow the xml programming language has grown
00:37:24 <siti> I wish I could use that language :s
00:37:25 <dons> python caught perl in 2006? http://www.ohloh.net/languages/compare?measure=contributors&percent=&l0=perl&l1=python&l2=-1&commit=Update
00:37:26 <lambdabot> Title: Open Source Programming Language Popularity Monthly Contributors History Chart - ..., http://tinyurl.com/yr7y4j
00:37:45 <dons> and perl's golden age was the late 90s
00:37:53 <scottutd> why is xml a programming language? Isn't it just a markup language?
00:38:01 <wy> dons: That's when I learned it
00:38:05 <dons> me too :)
00:38:17 <siti> c# is almost non existent in the open source domain
00:38:22 <dons> fun stats.
00:38:30 <dons> this might be the killer feature for ohloh
00:38:38 <dons> way better than the stupid tiobe index
00:39:04 <dons> that's probably ohloh's goal -- have all open source projects subscribed and analysed
00:39:11 <dons> then sell info about what's hot and what's not
00:39:52 <scottutd> so, why would I, random developer, go on ohloh? is it like a sourceforge replacement?
00:39:52 <radetsky> how do they stop all the mouth-breathing haskell partisans from astroturfing?
00:40:21 <dons> possibly .. and i'm not sure yet .. to search for stuff
00:40:43 <dons> can't quite tell yet what its good for
00:40:51 <radetsky> I could pile shitloads of useless patches on fake projects and everyone would think that haskell had actually left the nerd ghetto
00:41:00 <dons> oh, you could put fakes up, sure.
00:41:11 <dons> afaik they don't prevent that
00:41:27 <scottutd> it looks like facebook or linkedin for open source software projects
00:41:27 <dons> i'm sure if you did, they'd do something about it
00:41:47 <radetsky> well, since the whole "being a good language" thing hasn't led to widespread haskell adoption...
00:41:48 <dons> scottutd: yeah. with some other cross-overs, like these stats
00:41:49 <scottutd> looks like you can link "built with" and stuff
00:42:19 <radetsky> actually, astroturfing LOLCODE would be more fun
00:43:21 <scottutd> radetsky: I am so with you.
00:43:30 <radetsky> IS IT CAN BE MONADS TIEM NAO?
00:43:43 <scottutd> radetsky: Is there a LOLCODE library/extension for Haskell?
00:43:46 <scottutd> (yet?)
00:44:03 <dons> i think dcoutts was pondering giving a formal semantics to lolcode, via haskell
00:44:37 <ac> does "return ()" default to "IO ()"?
00:44:52 <dons> ac, no.
00:44:56 <radetsky> dons: this guy was saying on reddit that ghc was "an industrial strength compiler for a toy language"
00:44:58 <dons> there's no monadic defaulting
00:45:02 <ac> ah ok
00:45:04 <radetsky> he hasn't seen anything
00:45:08 <dons> radetsky: that wasn't on reddit. it was a troll on -cafe@ :)
00:45:16 <dons> actually, possibly an insane person on -cafe@
00:45:24 <ac> yeah, that was a weird deal
00:45:40 <ac> there was a response in the comment thread on reddit with a really good set of examples
00:45:52 <ac> I saved it in my directory of misc. Haskell code
00:45:53 <radetsky> (the point of that was in reference to giving a semantics for lolcode)
00:46:20 <radetsky> also, it was on reddit too
00:47:02 <scottutd> oh, did he ever post a response when everyone gave him his answer in about 4 lines of haskell?
00:47:16 <dons> no.
00:47:26 <dolio> Anyone here an expert on indexed monads?
00:47:33 <scottutd> no helping some...
00:47:33 <ac> maybe he felt really stupid
00:47:41 <ac> maybe he was the type of programmer who copy and pasted code
00:47:47 <radetsky> EXPERT MONAD INDEXER
00:47:50 <wagle_home> haha..  anyone remeber the subjectline of that thread?
00:47:55 <povman> who likes guis?
00:48:11 <radetsky> sorry, I'll try to rein it in
00:48:21 <scottutd> I think people tried to be pretty helpful, and he seemed to be fairly knowledgeable.
00:48:21 <hpaste>  povman pasted "SUIL" at http://hpaste.org/5751
00:48:28 <scottutd> oh well.
00:48:28 <dolio> @yow!
00:48:29 <lambdabot> I guess you guys got BIG MUSCLES from doing too much STUDYING!
00:48:56 <povman> has anything like this been done before? http://hpaste.org/5751
00:49:18 <scottutd> well, as fun as its been, I need to get to bed--class in the morning. Night all.
00:49:22 <povman> (i'd much prefer that style over standard gtk2hs)
00:53:16 <ac> so "return ()" works in ghci, because the type is inferred to be IO
00:53:47 <dolio> ghci is essentially running in a big do-block for an IO monad.
00:53:57 <dolio> So it runs all monadic values in the IO monad.
00:54:08 <dolio> Although it magically prints non-monadic values.
00:54:18 <ac> right
00:54:41 <wagle_home> ah...  magic
00:55:53 <wy> wagle_home: Have you learned morphogenesis?
00:56:31 <wagle_home> i think its the magic happening at the top level that everyone sweeps under the rug that throws half of all aspiring cs students off
00:58:02 <wagle_home> wy, biology?
00:58:31 <wy> wagle_home: yes
00:58:40 <wagle_home> wy sure..  why you ask?
00:59:08 <wy> wagle_home: I was reading Turing's wikipedia page
01:00:42 <wy> It would be good if I can understand in the history how those things related
01:00:46 <wagle_home> havemt read turing's take though
01:02:24 <wy> wagle_home: I could be also interested in that
01:02:58 <wagle_home> reaction-diffusion i think is central though
01:03:02 <wy> I found many Lispers became biologists
01:06:39 <wy> wagle_home: What do you do for work now?
01:14:06 <wy> I mean, as computer scientist or biologist?
01:16:49 <hpaste>  povman pasted "State-based GUI" at http://hpaste.org/5752
01:16:55 <povman> ta-da
01:17:04 <povman> now with even more goodness
01:17:50 <povman> does the library i'm trying to write already exist, or should i continue my good effort?
01:18:05 <dolio> So, a state function takes a UI and an event and returns a new UI?
01:19:53 <povman> yep
01:20:13 <povman> state machine
01:22:29 <povman> imo, it makes gui programming haskellish without needing to read papers and bad documentation (ala fruit&co)
01:22:41 <dolio> Wouldn't that get kind of cumbersome with large guis?
01:23:09 <povman> would it be any more so than the reams of IO needed in regular gtk2hs?
01:24:00 <dolio> I dont' know. It probably wouldn't. You'd want something more compositional. Doesn't Conal's stuff have a Gtk backend?
01:24:35 <povman> conal?
01:24:42 <dolio> Then again, I don't know how ready his stuff is.
01:25:12 <povman> http://conal-elliott.blogspot.com/ ?
01:25:12 <lambdabot> Title: ConalBlog
01:25:14 <dolio> http://haskell.org/haskellwiki/User:Conal
01:25:26 <dolio> Yeah, same guy.
01:26:51 <quicksilver> I write guis much like that
01:26:54 <quicksilver> although not exactly like that
01:27:08 <quicksilver> that appears to recreate the gui from scratch after every state change
01:27:20 <povman> quicksilver: it's a really quick hack
01:28:21 <povman> dolio: i just don't understand FRP. it's very complex
01:30:04 <dolio> Well, I can't disagree if your examples are Fruit and such, I suppose. But Conal's been working on formulating it in a way that isn't as hard to use, I think.
01:30:27 <povman> hrm
01:30:33 <sizur> morning
01:30:59 <dolio> For instance, if you look at the Tangible Values article.
01:31:29 <ac> quicksilver: remember when we were fooling around with mandelbrot set generating code?
01:32:25 <dolio> But, like I said, I don't know how well all that works, as I haven't used it.
01:33:29 <dolio> And his article says he's only tested it on Windows, although I guess there's no reason it'd be totally broken with Gtk on some other platform.
01:36:08 <quicksilver> ac: yes
01:36:51 <ac> quicksilver: I wrote a version that's only 40% slower than the entry in the language shootout
01:36:58 <quicksilver> nice
01:37:38 <ac> quicksilver: and it actually works. When I run the shootout version I get a broken image (according to the Gimp), and mine makes a greyscale rather than just B&W
01:38:02 <quicksilver> \o/
01:38:17 <dcoutts_> @yarr!
01:38:17 <povman> i think i still prefer separating the structure from the functionality
01:38:17 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
01:38:55 <ac> quicksilver: oddly, when I make the double loop iterative like in the shootout version rather than using list comprehension it gets 20% slower
01:39:12 <ac> quicksilver: so I can't figure out why mine's slower than the shootout version
01:39:32 <quicksilver> heh
01:39:35 <povman> i might pursue it anyway, because it really is nicer than IO with gtk2hs
01:39:48 <povman> quicksilver: have you done a similar thing?
01:39:49 <quicksilver> ac: dons is probably your man to work out the differnet :)
01:39:59 <quicksilver> povman: similar in a few respects, perhaps
01:39:59 <dcoutts_> povman: you're looking at grapefruit?
01:40:06 <ac> quicksilver: I think it's fast enough for me. The key was ! annotations :-P
01:40:14 <quicksilver> povman: I have just been trying out as I go along
01:40:15 <ac> quicksilver: those made a _huge_ difference
01:40:20 <povman> dcoutts_: i've seen grapefruit, i think it gave me cancer
01:40:33 <dcoutts_> povman: oh dear :-)
01:40:46 <povman> i really don't understand frp
01:40:58 <dcoutts_> povman: so what are you trying now?
01:41:06 <povman> http://hpaste.org/5752
01:41:27 <hpaste>  ac pasted "Yet another Mandelbrot renderer... slower but prettier than shootout version" at http://hpaste.org/5753
01:42:08 <dcoutts_> povman: interesting
01:43:50 <povman> it's pretty much exactly how i'd like to do gui programming
01:45:47 <povman> and since noone's pointed me at a library that works like that, i might just continue building it :)
01:46:38 <earthy> that kinda looks a bit like what i remember of Clean's Object I/O
02:06:12 <DRMacIver> Hm. I wonder why Random isn't designed to work inside some sort of state monad. It seems like that would simplify the API a lot.
02:06:34 <DRMacIver> But maybe that's me being imperatively damaged. :)
02:06:53 <Syzygy-> Yo DRM
02:07:19 <DRMacIver> Hi Syzygy-. What's up?
02:07:45 <Syzygy-> My thesis is getting printed. I've organized an International Driver's Permit. And my office chair is broken.
02:07:48 <Syzygy-> You?
02:08:59 <povman> DRMacIver: i thought it was.....
02:09:12 <DRMacIver> Syzygy-: I've managed to write both Haskell and Scala at work in the last week and a half. Work is a little crazy at the moment due to pending demos of a product that doesn't actually exist yet. My brain is totally fried due to a combination of insomnia and jet lag post visiting my girlfriend in new york. :)
02:09:20 <DRMacIver> povman: Kindof? It seems to make the state monad explicit.
02:09:34 <DRMacIver> povman: The API is all about passing around a generator type
02:09:40 <povman> ...
02:10:24 <DRMacIver> What I mean is that it has g -> (a, g)s all over the place and doesn't newtype these into a State g a
02:10:24 <povman> State abstracts away the passing around
02:10:27 <DRMacIver> Right
02:10:33 <DRMacIver> And I'm saying it doesn't do that. :)
02:10:33 <povman> o i see
02:10:48 <DRMacIver> This is why I think it might work more naturally with a state monad
02:10:52 <Syzygy-> Btw, DRMacIver: http://mpc723.mati.uni-jena.de/~mik/thesis_ebook.pdf
02:11:31 <DRMacIver> Syzygy-: I'll take a look at it later. Right now my brain is perilously close to exploding already. :)
02:13:07 <quicksilver> DRMacIver: State monad just add unnecessary noise in most cases
02:13:25 <DRMacIver> I'm not 100% sure that's true. The parameter passing is pretty noisy.
02:13:34 <quicksilver> DRMacIver: it's trivial to encode a special case MonadRandom and that's what I do if I use more than one parameter
02:13:46 <quicksilver> @go monadrandom
02:13:48 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
02:13:48 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
02:14:08 <DRMacIver> Ah. Thanks.
02:16:13 <quicksilver> although I don't normally bother with all that generality
02:16:19 <quicksilver> just an instance for IO and one for StateT g
02:17:19 <DRMacIver> Ah, in fact that's packaged up on Hackage already.
02:17:30 <DRMacIver> Shiny
02:17:45 <DRMacIver> (It would be nice if hoogle indexed hackage)
02:21:57 <JohnMeacham> in ghci, is there a way to drop into debugging mode in a running computation?
02:31:34 <ac> WHAT? Why does "nice -20 command" take twice as long as "command"?
02:32:39 <povman> it's taking extra time to be mean
02:32:40 <ac> cool. my code is actually within 10% of the shootout version
02:32:55 <ac> and it's much shorter and easier to read, AND it works
02:33:03 <povman> aste
02:33:07 <povman> *p
02:33:50 <ac> http://hpaste.org/5753
02:35:09 <tobyh> I had a look at the shootout version the other day--all that strictness and stuff looked scary.
02:35:23 <ac> mine has bangs too
02:35:35 <ac> it would be off by a factor of 10 or so if it didn't
02:35:39 <tobyh> dons code doesn't look much like Haskell most of the time. :)
02:35:49 <tobyh> Yar, I don't doubt it.
02:36:52 <povman> where is the shootout?
02:37:00 <ac> http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc#program
02:37:02 <lambdabot> Title: mandelbrot Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compu ..., http://tinyurl.com/2poruf
02:37:57 <jedbrown> ac: `nice -20' is equivalent to `nice -n 20'.  If you are root, you could do `nice -n -20'.
02:39:08 <tobyh> Does `nice --20' work?
02:39:39 <jedbrown> tobyh: Works here.
02:40:02 <quicksilver> > let rot n s = take (length s) . drop n $ cycle s in rot 3 "stepa"
02:40:04 <lambdabot>  "paste"
02:40:19 <ac> ah yes --20 is the same as no nice
02:40:46 <ac> silly syntax
02:41:19 <jedbrown> ac: nice -0 is the same as no nice.  Negative niceness requires root.
02:41:26 <ac> jedbrown: I am root
02:42:12 <ac> apparently the machine the shootout tests are run on is 3x faster than mine
02:42:21 <jedbrown> ac: Yes, but even your processes are scheduled at nice 0, unless you explicitly raise their priority.
02:42:28 <jedbrown> ac: You must have a really slow machine.
02:43:29 <quicksilver> nice is pretty pointless unless there is other CPU-bound stuff on the machine
02:43:39 <quicksilver> scheduling conflicts only occur if other stuff is trying to use the CPU
02:43:43 <ac> makes sense
02:43:50 <quicksilver> on a mostly-idle machine it should make very very little difference
02:44:01 <jedbrown> ac: My 5-year old laptop is much faster than the shootout box.
02:44:04 <ac> I have a 1Ghz laptop
02:44:53 <ac> according to cpuinfo, 2 cores with about 3k bogomips
02:45:02 <jedbrown> quicksilver: And even then, there's priority inversion to consider (though not relevant in this case).
02:47:17 <ac> is there a program like time for memory usage?
02:47:36 <quicksilver> no, but ghc can dump some interesting statistics
02:50:22 <ac> what are the flags for that?
02:53:10 <ac> hah at the -B flag
02:53:33 <ac> "Sound the bell at the start of each (major) garbage collection" ... "Oddly enough, people really do use this option!"
02:58:31 <jeffz> ac, valgrind
02:59:01 <ac> jeffz: yes?
02:59:12 <jeffz> ac, it has a tool called memprof iirc, it should tell you memory usage
02:59:23 <ac> ah, is it a package?
02:59:46 <ac> it is
03:00:16 <quicksilver> the ghc options are often more useful for haskell programs though
03:00:16 <quicksilver> because they let you see into the GC generations a bit
03:00:33 <ac> it's big
03:09:20 <ac> am I mistaken or did 6.8.1 improve executable size over 6.6?
03:10:28 <aes2> How can there exist a FFI to call C code in Haskell? Isn't the way a C library can be called a thing of the C compiler (which could be different for every compiler (calling convention))?
03:13:16 <ac> aes2: isn't it a matter of library and object file standards?
03:13:35 <ac> .so files for Linux, .dll files for Windows, and .o files?
03:15:32 <quicksilver> aes2: no. calling convention is standard.
03:15:41 <quicksilver> aes2: it is part of something called the 'ABI' of a platform.
03:15:48 <quicksilver> aes2: which is well understood by compiler authors
03:16:00 <quicksilver> and to some extent is even part of the linker system.
03:16:41 <aes2> quicksilver: I understood the ABI of g++ changed at version 4.
03:16:47 <quicksilver> indeed it did.
03:16:56 <quicksilver> the ABI of g++ has changed rather frequently.
03:17:09 <quicksilver> which has made calling C++ from other languages a bit of a pain.
03:17:18 <quicksilver> but, the ABI of C has not. And that's what you asked.
03:17:34 <aes2> quicksilver: which would suggest that, assuming no communication between different vendors of C++ compilers, would indeed cause pain.
03:18:00 <aes2> quicksilver: so, "messing with the C ABI" is somewhat of a crime against humanity?
03:18:15 <jedbrown> aes2: C++ *is* a pain
03:18:56 * Beelsebob ponders the hypocracy of complaining a C++ compiler changes lots in a Haskell channel
03:18:57 <Beelsebob> :D
03:20:19 <quicksilver> aes2: it has historically been totally impossible to combine C++ from more than one compiler vendor.
03:20:43 <quicksilver> aes2: you always had to compile your C++ with a single consistent compiler, or "insulate" the C++ in bridging code which used the C ABI.
03:20:53 <ac> what's a good algorithm for selecting a set of squares in a grid that are within one grid unit of a circle?
03:21:10 <quicksilver> it is possible this situation has improved recently, I really don't follow C++ much any more.
03:21:31 <Beelsebob> ac: to get this straight... you have a grid, overlayed on that there is a circle
03:21:42 <Beelsebob> you want all squares within 1 grid unit of the edge of the circle, yes?
03:21:48 <ac> Beelsebob: exactly
03:21:53 <Beelsebob> essentially, how do I draw a circle on a pixel matrix
03:22:01 <quicksilver> whereas, historically, C compilers on a given platform have used the same ABI and thus been comparable.
03:22:05 <ac> Beelsebob: yeah
03:22:21 <Beelsebob> I'd measure the distrace from the centre of the pixel to the origin of the circle
03:22:30 <Beelsebob> and test it's bounds
03:22:38 <quicksilver> and if it's within 1 unit of the radius of the circle, bonza!
03:22:39 <ac> Beelsebob: how do you pick the pixels to measure?
03:22:39 <Beelsebob> but that's rather inflexible when it comes to drawing other things
03:22:54 <tobyh> Some trig might be useful.
03:23:12 <Beelsebob> well, you could do it naÃ¯vely... chose all pixels within the bounding box, and outside the inner bounding box
03:23:23 <ac> you can use trig to get a set of points around the circle and then round them...
03:23:50 <tobyh> You'd have to iterate through angles I guess.
03:23:52 <Beelsebob> yeh, but how do you guarentee hitting every one of them
03:23:57 <tobyh> You could miss a pixel that way.
03:24:05 <Beelsebob> hang on...
03:24:10 <Beelsebob> I'l go get my graphics boox
03:24:11 <Beelsebob> book*
03:24:40 <tobyh> Bresenham had a circle algorithm.
03:24:51 <tobyh> Much like his line algorithm.
03:25:13 <tobyh> Not terribly accurate IIRC.
03:25:33 <ac> you could increment by an angle that's smaller than 1 / (pi * diameter)
03:25:34 <Beelsebob> okay... the book sayeth
03:25:38 <Beelsebob> in it's final increment
03:26:42 <Beelsebob> sample at unit intervals on x
03:26:57 <Beelsebob> and computer f x y = x^2 + y^2 - r^2
03:27:00 <Beelsebob> to get y
03:27:08 <Beelsebob> do that for 1/8th of the circle
03:27:13 <Beelsebob> then use symetry to replicate it
03:27:22 <ac> huh, so it recommends using square roots?
03:27:45 <Beelsebob> hang on... just reading on a bit... the next sentence is "square roots are inefficient, so"
03:27:50 <ac> heh
03:28:00 <tobyh> :)
03:28:19 <ac> but where the circle comes close to an intersection in the pixel grid, I want all the surounding pixels, for antialiasing
03:28:19 <Beelsebob> ah... okay
03:28:26 <Beelsebob> use a square root to get the first pixel point
03:28:31 <Beelsebob> this gives you x_0 and y_0
03:28:36 <Beelsebob> increment x to get x_1
03:28:44 <Beelsebob> use y_0, and computer f x y
03:28:50 <Beelsebob> if it's positive, it's outside the circle
03:28:55 <Beelsebob> if it's 0 it's on the circle
03:28:59 <Beelsebob> if it's negative it's inside
03:29:13 <Beelsebob> find the closest value to 0
03:29:35 <Beelsebob> so do a contour crawler essentially
03:30:08 <ac> I don't understand that
03:30:09 <quicksilver> you could probably extend that to anti-alias
03:30:16 <Beelsebob> indeed
03:30:17 <tobyh> ac: The comp.graphics.algorithms FAQ is a good place to look for this stuff.
03:30:23 <quicksilver> if the value is close to 0 but not close enough, set a gray value
03:30:33 <Beelsebob> indeed
03:30:44 <Beelsebob> the specific grey value in fact should be sqrt (f x y)
03:31:01 <Beelsebob> but that introduces that sqrt again
03:31:10 <quicksilver> you could approximate it by (f x y)/2
03:31:11 <Beelsebob> so you can probably aproximate reasonably easily
03:31:13 <ac> what's f x y?
03:31:24 <Beelsebob> f x y = x^2 + y^2 - r^2
03:31:43 <jedbrown> Beelsebob: It should be sqrt(x^2 + y^2) - r which is not sqrt (f x y)
03:31:54 <Beelsebob> jedbrown: ah, good point
03:32:25 <ac> oh I see
03:32:34 <Beelsebob> note, this algorithm only works well if you do not have to draw more than one pixel in any one column
03:32:34 <ac> that's a clever algorithm ;)
03:32:51 <Beelsebob> so you should use it only to draw the NNE or NNW 1/8 of the circel
03:32:54 <Beelsebob> circle*
03:32:59 <Beelsebob> then reflect it about the place
03:33:16 <ac> right
03:33:38 <ac> also, the antialiasing would only be vertical
03:33:44 <Beelsebob> indeed
03:33:49 <Beelsebob> actually, no
03:33:51 <Beelsebob> it would be fine
03:34:08 <ac> ah you're right
03:34:14 <Beelsebob> in that to do antialiassing correctly you merely colour the grey value as being the distance from the line
03:34:23 <Beelsebob> which is what this is doing... altohugh a bit of an aproximation
03:34:45 <matthew-_> err, good antialiasing is a bit more complex than that
03:35:02 <matthew-_> involving gamma corrections, and taking into account the construction of the lcd panel
03:35:11 <Beelsebob> indeed
03:35:29 <Beelsebob> but assuming a greyscale display, that's pretty much all you do
03:35:48 <ac> Yeah, I'll just assume I have a greyscale display :-P
03:35:54 <Beelsebob> hehe :D
03:36:02 <matthew-_> ahh I see, yes. I'm pretty sure that that's all that BeOS and RISC OS did and RISC OS was pretty much the first system to do antialiasing
03:36:17 <Beelsebob> I remember a bug in OS X actually, where it got the order of the colour bars on my LCD wrong
03:36:27 <Beelsebob> so all antialiasing looked completely crazy
03:37:06 <tobyh> I had a BGR PDA which did the same...
03:37:25 <Le-Chuck_ITA> Hi there! What is the --enable-dotnet option in ghc?
03:37:31 <Le-Chuck_ITA> sounds cool
03:37:39 <Beelsebob> guess
03:37:52 <Beelsebob> failing that... rtfm
03:39:37 <Beelsebob> Hearn and Baker are useful guys aren't they ac
03:39:47 <Beelsebob> I can't believe how much use I've got out of this book
03:42:21 <quicksilver> matthew-_: subpixel antialiasing is a bit special though
03:42:32 <quicksilver> matthew-_: that's more than 'just plain antialiasing'
03:43:32 <quicksilver> I believe that even mentioning subpixel antialiasing in an IRC channel is likely to get the patent enforcers banging on your door.
03:43:41 <quicksilver> Claiming you understand how it works is a life-sentence.
03:43:42 <Beelsebob> really?
03:43:56 <Beelsebob> is that why windows' version of it is shite?
03:44:39 <tobyh> The Win version is shite by design, although it's subjective...
03:45:14 <vincenz> quicksilver: micropixel aliasing
03:45:30 <Cale> dejones: You will *fail* at predicting my availability :)
03:45:34 <quicksilver> vincenz: ah that's OK. That's totally different. Let's apply for a patent on that in the name of #haskell :)
03:46:07 <Le-Chuck_ITA> Beelsebob: no trace - absolutely - of a ghc dot-net backend in the manuals or on googled documentation
03:46:28 * vincenz votes for femtopixel aliasing
03:46:34 <Beelsebob> haha
03:46:40 <Beelsebob> you invent it, you can have it
03:46:41 <quicksilver> Le-Chuck_ITA: there has been some work on haskell .NET btu I think it's mostly bitrotted. There should be som einformation around if you poke hard enough
03:46:46 <vincenz> Beelsebob: easy
03:46:58 <Beelsebob> explain?
03:47:10 <Le-Chuck_ITA> ok thanks it's just I saw the option in configure and hoped
03:47:10 <vincenz> 5*10^-15
03:47:15 <vincenz> whops
03:47:17 <Le-Chuck_ITA> I knew there was preliminary work
03:47:27 <vincenz> 5*10^14 femtopixels scaling = 1/2 pixel scaling :)
03:47:51 <Beelsebob> heh
03:48:05 <Beelsebob> personally, I'd just like to see the major OS manufacturers get on and provide resolution independance
03:48:13 <Beelsebob> so we can have some ludicrously high res displays
03:48:17 <Beelsebob> and not squint at them
03:51:21 <vincenz> Beelsebob: like 1ETA-pixel
03:59:19 <Jiten> Beelsebob: yes, if you want that, open source systems are the only choice I guess.
04:00:29 <Beelsebob> Jiten: wellyes, it's more a case of diplay manufacturers won't make them until there's a market
04:01:13 <Jiten> Better hope for fast expansion of Linux based systems on the desktop then :)
04:01:57 * aes2 heard 2008 was the year of the Linux desktop ^^
04:02:12 <aes2> (so, was 2007, 2006, 2005, 2004...)
04:03:15 <Jiten> depending on how you look at it, you could say it was correct for every year ... although it's getting easier figure out how you need to look at it to get to that conclusion.
04:04:52 <Jiten> I don't remember what was counted but I remember seeing some article about Desktop Linux usage going from 0.5 to 1.0 during 2007
04:05:04 <Jiten> that's percentages
04:07:25 <Jiten> considering that all open source software growth curves have been exponential so far, I wouldn't be surprised to see that being 2.0% by Jan 2009
04:07:26 <quicksilver> I'm suspecting OSX has put a dent in the linux desktop growth
04:07:44 <quicksilver> I'm *sure* OSX has put a dent in linux laptop growth
04:07:58 <jones-> How come?
04:07:59 <quicksilver> lots of the techie guys I work with use OSX when they wuld surely have used linux or BSD 4 years ago.
04:08:07 <Beelsebob> Jiten: Net Applications data shows linux growth being far from exponential
04:08:32 <Jiten> Beelsebob: link?
04:08:52 <jones-> [citation needed]
04:09:02 <Beelsebob> Jiten: http://marketshare.hitslink.com/report.aspx?qprid=9
04:09:02 <lambdabot> Title: Market share for browsers, operating systems and search engines
04:09:19 <oerjan> @cite
04:09:19 <lambdabot> Maybe you meant: dice elite gsite time vote
04:09:20 <Beelsebob> linear maybe
04:09:23 <Beelsebob> but a low linear
04:10:10 <Beelsebob> anyway, I know for a fact that OS X can do a resolution independant UI
04:10:13 <Beelsebob> it's just not enabled
04:10:36 <Jiten> Beelsebob: the rate of increase is going up. you can see that if you look at the numbers
04:10:41 <jones-> Resolution independent?
04:11:00 <Beelsebob> Jiten: I really don't see any pattern there -- just noise
04:11:15 <Jiten> at first it's between 0.01-0.02 at the end it's more like 0.03-0.04
04:11:24 <Beelsebob> from feb 07 to oct 07 it varies between 0.1 and 0.2
04:11:30 <Beelsebob> sorry 0.01 and 0.02
04:11:41 <Beelsebob> the last 3 months it goes up to 0.06-0.07
04:11:51 <Beelsebob> so while there's an increase, I don't see it as a clear exponential curve
04:11:53 <quicksilver> there is not enough data there to decide if it's exponential or not
04:12:02 <quicksilver> there's certainly nothing to show it isn't
04:12:17 <quicksilver> a slow exponential is very hard to distinguish form a slow linear
04:12:20 <Beelsebob> true
04:13:04 <Beelsebob> I would be very surprised if it were exponential though... I'd expect a linear curve, broken at some point where it becomes generally accepted
04:13:25 * Beelsebob slaps self for stupid falsehood
04:13:28 <Beelsebob> "linear curve"
04:13:52 <tobyh> Question: what's the best way to repeatedly apply a function to a value?
04:14:10 <bolrod> copy paste
04:14:12 <Beelsebob> jones-: a resolution independant UI is one that can be easily scaled so that it appears the same on any 20" monitor, no matter what resolution said 20" monitor has
04:14:18 <Zao> tobyh: iterate
04:14:30 <oerjan> > iterate (*2) 1
04:14:34 <Beelsebob> so for example, the UI would continue to look sensible if your monitor happened to be an incredible 10000000dpi
04:14:35 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:15:02 <tobyh> Excellent, thanks.  I knew it must've been simple.
04:15:03 <Lycurgus> best in what sense?
04:15:12 <tobyh> Simple.
04:16:04 <Lycurgus> simple is as simple does
04:17:00 <Lycurgus> (i.e. only slightly better than "best")
04:18:21 <quicksilver> > iterate (*2) 1 !! 1000
04:18:23 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
04:18:26 <quicksilver> > iterate (*2) 1 !! 10000
04:18:27 <lambdabot>  1995063116880758384883742162683585083823496831886192454852008949852943883022...
04:18:29 <quicksilver> > iterate (*2) 1 !! 100000
04:18:31 <lambdabot> Terminated
04:18:40 <oerjan> > 2^100000
04:18:41 <lambdabot>  9990020930143845079440327643300335909804291390541816917715292738631458324642...
04:19:19 <Lycurgus> yes, that's what I meant
04:19:36 <oerjan> 999? that's pretty close
04:19:52 <oerjan> > length . show $ 2^100000
04:19:53 <lambdabot>  30103
04:20:12 <oerjan> > log 2 / log 10
04:20:15 <lambdabot>  0.30102999566398114
04:20:25 <oerjan> ah
04:23:12 <oerjan> > flip unfoldr (logBase 10 2) (Just . properFraction . recip)
04:23:13 <lambdabot>  [3,3,9,2,2,4,6,2,1,1,3,1,18,1,6,1,7,1,1,1,10,1,2,8,1,10,2,1,1,43,1,1,7,1,4,1...
04:25:08 <oerjan> > unfoldr (Just . properFraction . recip) 0.30103
04:25:09 <lambdabot>  [3,3,9,2,2,4,5,1,1,1,1,1,3638830,1,18,1,54,1,1,1,1,1,41,2,1,3,4,1,2,4,4,9,1,...
04:25:33 <oerjan> > unfoldr (Just . properFraction . recip) (0.30103 :: Rational)
04:25:34 <lambdabot>  Exception: Ratio.%: zero denominator
04:37:41 <tobyh> Yay, 50% genius on project euler again.  That's a pass.
04:39:13 <ac> I read an interesting article a bit ago how Microsoft's font rendering system has killed high res displays
04:39:19 <ivanm> ac: :o
04:39:21 <ivanm> link?
04:39:32 <ac> let's see if I can dig it up
04:40:00 <tobyh> Define killed.
04:40:10 <tobyh> Killed the market for?
04:40:19 <Zao> ac: Tuomo's article or the Antigrain one?
04:40:57 <ac> http://antigrain.com/research/font_rasterization/index.html
04:40:58 <lambdabot> Title: Anti-Grain Geometry - Texts Rasterization Exposures
04:41:23 <ac> the latter one apparently. Had forgetten the title
04:41:36 <ac> Zao: what's Tuomo's article?
04:42:39 <Zao> ac: Although, he only rants about antialiasing and Gnome, now that I think about it.
04:42:46 * therp wants high-dpi displays
04:43:20 <therp> I think tuomo hated me for pushing xft for ion
04:43:53 <Zao> ac: http://modeemi.fi/~tuomov/b/archives/2006/03/17/T20_15_31/
04:43:55 <lambdabot> Title: The case against blurred fonts | Not a blog
04:44:38 <ac> Zao: according to the Anti-Grain article you can get very nice results from Linux's font rendering library
04:44:48 <ac> just have to pass it the right parameters
04:45:02 <therp> zao: iirc this article isn't paste worthy. There isn't a single argument in there.
04:46:18 <thotypous> @src List.nub
04:46:18 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:46:44 <ivanm> @src nub
04:46:44 <lambdabot> nub = nubBy (==)
04:46:50 <ivanm> @src nubBy
04:46:50 <lambdabot> nubBy eq []             =  []
04:46:50 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:46:58 <ivanm> thotypous: is that what you wanted?
04:47:04 <thotypous> yes, thanks :)
04:47:45 <MyCatVerbs> @hoogle Parser a -> Parser Bool
04:47:46 <lambdabot> No matches, try a more general search
04:48:38 <oerjan> MyCatVerbs: what are you looking for?
04:50:16 <Zao> therp: I remember it as being better, but that may have been due to me being an ion fanboy before I went xmonad :)
04:50:42 <quicksilver> I imagine he wants to convert a parser which returns a (but might fail) into one which definitely succeeds, but returns a Bool based on whether the original succeeded
04:51:14 <MyCatVerbs> oerjan: roughly, I wanted something like the "optional" combinator, but Parser a -> Parser (Maybe a) or even Parser a -> Parser Bool rather than Parser a -> Parser ()
04:51:27 <MyCatVerbs> oerjan: but I've just realised that that was stupid, there are better ways of doing what I want to do.
04:51:42 <oerjan> see option
04:52:01 <quicksilver> MyCatVerbs: "optionMaybe"
04:52:12 <quicksilver> MyCatVerbs: http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Combinator.html
04:52:13 <lambdabot> http://tinyurl.com/2zehtb
04:52:33 <oerjan> optionMaybe? is that new?
04:52:55 <quicksilver> dunno. I don't use parsec all that often. I just glances down the docs.
04:53:23 <quicksilver> option Nothing . fmap Just
04:53:59 <MyCatVerbs> quicksilver: ahhh, thank you. I'd just ended up writing "mebbe p = (p >>= return . Just) <|> (return Nothing)" anyway. :)
04:54:46 <oerjan> hm, not in the hugs version
04:56:09 <quicksilver> MyCatVerbs: (p >>= return . Just) = (fmap Just p) = (Just <$> p)
04:56:27 <SamB> dons: did you get my message about that jhc repository? robin fixed that issue with port fields in git URLs, so I enlisted my copy of the repository...
05:02:32 <MyCatVerbs> quicksilver: huh. I hadn't thought of fmap, that's clever. Haven't seen <$> before. Â¬Â¬
05:03:54 <quicksilver> MyCatVerbs: <$> is just an infix fmap.
05:04:03 <quicksilver> MyCatVerbs: turns out to be a very common idoim
05:04:16 <quicksilver> do { x <- action; return (Constructor x) }
05:04:29 <quicksilver> looks much nicer written as Constructor <$> action
05:04:37 <quicksilver> IMO
05:05:04 <yondalf> @src Maybe fmap
05:05:05 <lambdabot> fmap _ Nothing       = Nothing
05:05:05 <lambdabot> fmap f (Just a)      = Just (f a)
05:05:46 <quicksilver> yondalf: however, I'm not using the Maybe instance of fmap in the above example.
05:05:51 <MyCatVerbs> quicksilver: ohhh, handy. Is it defined anywhere canonically?
05:05:59 <quicksilver> MyCatVerbs: Control.Applicative
05:06:01 <yondalf> quicksilver: yeah i just realised that after typing out @src :-)
05:06:05 <MyCatVerbs> yondalf: in this case it's the parsec fmap instance.
05:06:33 <MyCatVerbs> quicksilver: ah, thanks. Is there any particular reason why <$> is preferred over `fmap`?
05:06:49 <quicksilver> do { x <- action; y <- reaction; return (Constructor x y) } becomes Constructor <$> action <*> reaction
05:07:37 <quicksilver> MyCatVerbs: no strong one, no. It reminds one of $, and it's 3 chars shorter.
05:08:03 <MyCatVerbs> quicksilver: fair 'nuff. "Reminds one of $" is a pretty good reason, though.
05:08:12 <faxathisia> I think I saw a generalization of this
05:08:35 <faxathisia> http://www.e-pig.org/darcs/epigram/Higgledy/Idiomatica.lhs
05:08:45 <quicksilver> yup
05:09:00 <SamB> @tell dons did you get my message about that jhc repository? robin fixed that issue with port fields in git URLs, so I enlisted my copy of the repository...
05:09:00 <lambdabot> Consider it noted.
05:10:31 <MyCatVerbs> @tell samb Heehee, \bot
05:10:31 <lambdabot> Consider it noted.
05:10:49 <SamB> MyCatVerbs: what?
05:10:49 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
05:10:58 <SamB> @messages
05:10:58 <lambdabot> MyCatVerbs said 28s ago: Heehee, \bot
05:11:34 <MyCatVerbs> SamB: I'm just being silly. ^_^
05:14:02 <SamB> googlebot seems to have an unhealthy interest in git repositories
05:24:30 <ac> where is some example code with STUArarys?
05:25:53 <quicksilver> it's no different from IOUArrays
05:26:06 <quicksilver> except the type sig forces you to do it inside an ST monad
05:26:09 <ac> hm. there's an extra argument in the type
05:26:33 <ac> STUArray (Int, Int) Word8' is not applied to enough type arguments
05:26:43 <quicksilver> yes, there is the magic s
05:26:48 <quicksilver> which links it all together
05:27:00 <quicksilver> with a bit of luck you won't need to give the type explicitly
05:27:05 <Le-Chuck_ITA> a quick question please: I get cannot find -loleaut32 when compiling ghc on ubuntu. I see this library is provided by both wine and mingw32... however the source package ghc of ubuntu lists none of them. Somebody wants to give a clue?
05:28:08 <dcoutts__> Le-Chuck_ITA: sounds like you're trying to build a package that only works on windows, I recommend ignoring that package.
05:28:49 <ac> ah I need to put this in a separate do block, otherwise I'm mixing IO and ST
05:29:16 <Le-Chuck_ITA> I am compiling the main ghc sources
05:29:26 <quicksilver> ac: yes. Or use STtoIO.
05:29:28 <Le-Chuck_ITA> and there's no option related to win32 in ./configure --help
05:29:38 <quicksilver> ac: but if you're in an IO block anyway, why not use IOUArray?
05:29:50 <ac> quicksilver: the docs say STUArrays are faster
05:29:55 <dcoutts_> Le-Chuck_ITA: you must be using an extra package like ObjectIO or something, ghc itself does not need that win32 lib
05:30:46 <Le-Chuck_ITA> oh yes ObjectIO is enabled by default, I will remove it from configure
05:31:03 <Le-Chuck_ITA> thanks dcoutts_ I didn't knwo
05:31:35 <dcoutts_> Le-Chuck_ITA: no probs, as far as I was aware it was disabled by default and had to be explicitly enabled with --enable-objectio
05:31:35 <ac> what's RealWorld?
05:31:52 <dcoutts_> ac: something used in GHC's implementation of the IO monad
05:32:17 <dcoutts_> ac: you almost certainly do not want to be fiddling with things at that low level
05:32:28 <ac> what does the signature "stToIO :: ST RealWorld a -> IO a" mean?
05:32:51 <Le-Chuck_ITA> dcoutts_: it is disabled by default... now I don't know what to do :)
05:33:04 <kpreid> dcoutts: this is not *that* RealWorld
05:33:28 <ac> Haskell's case sensitivity of initial characters makes for inconsistent capitalization of initializations
05:33:44 <dcoutts_> kpreid: it looks like it is to me, the thing used in stToIO
05:33:47 <kpreid> ac: you know how occurrences of ST are kept separate? this stands for the one special ST which can be turned into IO
05:34:21 <quicksilver> ac: ehm? wich does?
05:34:24 <dcoutts_> Le-Chuck_ITA: so you leave it disabled, just run ./configure as normal and it should work.
05:34:43 <quicksilver> ac: an STUArray is exactly the same thing as an IOUArray as far as I know.
05:35:25 <ac> quicksilver: oh, I had IO arrays confused with Storeable arrays
05:36:36 <shap1> Good morning #haskell!
05:36:46 <Le-Chuck_ITA> dcoutts_: yes that's what I did
05:36:47 <faxathisia> hey shapr, good morning
05:36:55 <Le-Chuck_ITA> I was wrong: objectIO is disabled by default
05:37:06 <Le-Chuck_ITA> and I didn't enable that
05:37:54 <shapr> faxathisia: Good morning!
05:38:02 <ac> IO arrays are much easier to use in IO do blocks than ST arrays :-P
05:38:47 <ac> shapr: goad moaning
05:39:12 <nominolo> dcoutts: "transative" is British spelling for "transitive"?
05:39:13 * shapr goads ac
05:40:08 <Le-Chuck_ITA> I grepped trough sources and I have
05:40:08 <Le-Chuck_ITA> rts/package.conf.in:                          , "oleaut32", "ole32", "uuid"
05:40:08 <Le-Chuck_ITA> rts/package.conf.inplace:                             , "oleaut32", "ole32", "uuid"
05:40:21 * ac should probably not bring ladle rat rotten hut to #haskell
05:40:39 <nominolo> dcoutts_: ;)  (this is why I run a spellchecker on my comments)
05:40:40 <Igloo> nominolo: transative looks like a typo to me
05:41:29 <nominolo> Igloo: yeah, but he does it in a couple of places.  More like a braino
05:41:52 <nominolo> Igloo: happens to me too.
05:41:53 <Le-Chuck_ITA> dcoutts_ ok I found out why. I first configured with --enable-dotnet, then --disable-dotnet however the variable  WANT_DOTNET_SUPPORT remained defined
05:42:13 <Le-Chuck_ITA> that's why I run a spellchecker on my configure scripts. Not that it helps anyways
05:45:36 <ogex> is it possible to sequence monadic actions of types m a and m b (a/=b)  and obtain an action of m()?
05:45:55 <Cale> ogex: sure
05:46:01 <Cale> x >> y >> return ()
05:46:11 <Cale> Where x :: m a, y :: m b
05:46:29 <nominolo> @pl \m n -> m >> n >> return ()
05:46:29 <lambdabot> flip flip return . ((>>) .) . (>>)
05:46:29 <quicksilver> :t \x y -> x >> y >> return ()
05:46:31 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> m a1 -> m ()
05:46:39 <quicksilver> as the type inferrer can confirm :)
05:47:07 <ogex> Cale, yes but I wonder if something like sequence exists
05:47:21 <quicksilver> ogex: ?
05:47:26 <ogex> so we don't know in advance how many actions (kinda like nonhomogeneous lists)
05:47:34 <quicksilver> ogex: ah
05:47:43 <quicksilver> not in haskell 98's type system, no
05:48:04 <quicksilver> but you can always write :
05:48:22 <quicksilver> :t \x y -> sequence_ [x >> return (), y >> return ()]
05:48:22 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> m a1 -> m ()
05:48:59 <quicksilver> :t let ign a = a >> return () in \x y -> sequence_ [ign x,ign y]
05:49:03 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> m a1 -> m ()
05:49:21 <faxathisia> @src sequence
05:49:21 <lambdabot> sequence ms = foldr k (return []) ms
05:49:21 <lambdabot>     where
05:49:21 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
05:49:35 <Cale> sequence [] = return []
05:49:48 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:50:00 <Cale> Or else:
05:50:13 <Cale> sequence = foldr (liftM2 (:)) (return [])
05:50:14 <tibbe> is (a,a) a functor?
05:50:19 <Cale> tibbe: no
05:50:22 <tibbe> i.e. could I do instance Functor  (a,a)
05:50:28 <tibbe> Cale: why not? lists are
05:50:28 <Cale> tibbe: (,) a is a functor for any a
05:50:41 <Cale> Or you mean /\a -> (a,a) ?
05:50:47 <tibbe> so instance Functor (,) where ... should work?
05:50:48 <Cale> We don't have type lambdas.
05:50:50 <Cale> nope
05:50:59 <Cale> instance Functor ((,) a) where
05:51:02 <quicksilver> (a,a) is a Functor but you need a newtype to write it
05:51:03 <tibbe> because the kind is wrong
05:51:05 <faxathisia> can you make a new data type?
05:51:07 <Cale>   fmap f (x,y) = (x, f y)
05:51:14 <tibbe> could you use functional dependecies?
05:51:17 <faxathisia> like type Qu a = (a,a)
05:51:50 <Cale> No, you'd need a new type.
05:51:50 <faxathisia> and make that a Functor
05:51:50 <quicksilver> newtype MatchedPair a = (a,a) ; instance Functor MatchedPair where fmap f (x,y) = (f x, fy)
05:51:50 <faxathisia> oops.. yeah
05:51:50 <tibbe> right
05:51:51 <tibbe> so what was the reason I needed a new type?
05:51:54 <doserj> almost
05:52:03 <quicksilver> because (,) is a binary type constructor
05:52:08 <faxathisia> for what Cale said, no type lambda
05:52:11 <quicksilver> and Functor is for unary type constructors
05:52:30 <doserj> newtype MatchedPair a = MatchedPair (a,a)
05:52:46 <quicksilver> I always forget constructors.
05:52:52 <quicksilver> why can't haskell read my mind, dammnit?
05:52:56 <faxathisia> I think you can blame me for that :P
05:53:54 <Stinger> you need to import Control.DWIM :P
05:54:42 <faxathisia> is DWIM the one with data ... derving Interpreter ?
05:55:22 <Stinger> DWIM = do what I mean ; that was directed at quicksilver
05:58:24 <ogex> (thanx for previous help) I am using  System.Process.runCommand to run a bash command. The command is run but I don't get the bash prompt before i hit ENTER.
05:58:59 <ogex> should I somehow close the process explicitly?
05:59:30 <quicksilver> waitForProcess
06:00:57 <slarba> hmm. registerDelay requires threaded runtime
06:01:40 <slarba> if I don't want to use threaded runtime due to profiling needs, is there a good way to timeout retrying transactions?
06:01:49 <slarba> (in STM)
06:02:49 <ogex> @karma + quicksilver
06:02:49 <lambdabot> + has a karma of 4
06:03:35 <Cin> does anyone else get "user error (FCGX_Accept_r failed)" when they try to run a fastcgi program?
06:03:37 <slarba> atomically $ doSomething `orElse` (checkTimeout registeredDelay)
06:03:48 <ogex> @karma quicksilver +
06:03:49 <lambdabot> quicksilver has a karma of 9
06:04:57 <quicksilver> slarba: doesn't sound possible to me.
06:05:00 <quicksilver> slarba: ICBW.
06:05:25 <slarba> d*mn
06:05:52 <Cale> slarba: What do you want to do when the timeout expires?
06:06:02 <Cale> It seems possible to me... perhaps I'm missing something.
06:06:11 <slarba> Cale: it works just fine with threaded runtime
06:06:33 <slarba> Cale: I'm returning Nothing from the transaction if it fails (times out), and Just a when it succeeds
06:07:10 <Cale> Oh, wait, you want to time out on a single transaction run?
06:07:15 <slarba> but, WITHOUT threaded runtime (since I need to profile things) it fails with a runtime message "registerDelay requires threaded runtime" etc
06:07:46 <Cale> Not just a timeout on the transaction committing in general (possibly with some retries)?
06:07:55 <slarba> Cale: yeah. I'm "polling" a TMVar until timeout or value becomes available
06:08:09 <Cale> Oh, that sounds like it should be impossible.
06:08:34 <Cale> The whole point of transactions is that they behave as if they occur atomically.
06:08:55 <Cale> So it shouldn't be possible to see changes to a TMVar from the outside.
06:08:57 <slarba> It relates to the ip stack... I have an ARP cache that is updated by another thread. Then I need to wait when cache entry becomes available after sending out ARP request
06:09:14 <slarba> is there a better solution to that
06:09:15 <quicksilver> maybe you should just be using an MVar
06:09:19 <quicksilver> not a TMVar
06:09:21 <Cale> However, if your transaction is short, you can just check the timeout TMVar at the start of the transaction.
06:09:27 <slarba> quicksilver: but can you timeout that too?
06:09:35 <Cale> That should prevent the transaction from retrying for too long.
06:09:37 <quicksilver> with another thread you can yes
06:09:40 <slarba> quicksilver: doesn't it have the same problem?
06:09:47 <slarba> ah you mean asynchronous exceptions
06:09:50 <quicksilver> the other thread can threadDelay and then kill the first
06:09:52 <quicksilver> right
06:09:52 <Cale> (like, you could just throw an exception when the timeout has occurred, or something)
06:09:55 <slarba> yeah ok
06:10:00 <slarba> sounds like a plan :)
06:10:01 <slarba> thanks
06:10:32 <Cale> But you can't check the time in the middle of a transaction, if you know what I mean.
06:10:52 <Cale> Well, at least not as far as I know.
06:10:53 <slarba> yes
06:10:55 <slarba> true
06:10:56 <quicksilver> unless you're a timelord
06:10:58 <Cale> There might be ways to cheat :)
06:11:48 <ac> is there a way to make writing to an out of bounds elment be siliently ignored?
06:13:01 <ac> I can say something like "filter (inRange arrayBonuds) ..." but then every write is checking the bounds twice
06:16:54 <Cale> ac: You can unsafely remove the bounds check on write.
06:17:20 <quicksilver> I"m not sure how you would expect to acheive silent ignore without checking bounds :)
06:17:27 <quicksilver> if you don't check the bounds, how will you ignore?
06:17:52 <ac> I want the bounds to be checked once, but instead of throwing an array index error, just do nothing
06:18:03 <Cale> You could catch the exception.
06:18:15 <Cale> Is this an IArray or an MArray?
06:18:27 <ac> MArray
06:18:41 <Cale> Yeah, so just do something like  `catch` \e -> return ()
06:18:53 * quicksilver pokes Cale with the you-cant-write-to-an-IArray-stick
06:19:05 <slarba> but hey.. yield is my friend.. 1) check timeout 2) check MVar contents 3) no value: yield. with value: return it
06:19:06 <Cale> quicksilver: There is an immutable update operator
06:19:12 * quicksilver nods
06:19:20 <slarba> other threads have a chance to update the mvar, right?
06:19:59 <ac> I think the "`catch` \e -> return ()" is reasonable in the context of image processing
06:20:03 <Cale> slarba: Sure. MVars are not transactional, so stuff will continue happening.
06:20:52 <Cale> slarba: uh, hang on, what does the thread do after the yield.
06:20:52 <Cale> ?
06:21:02 <slarba> Cale: loop to 1)
06:21:04 <slarba> :D
06:21:12 <slarba> (check timeout again)
06:21:22 <slarba> that creates a busy loop though...
06:21:25 <Cale> I don't think spinning is necessary.
06:21:43 <Cale> If there's no value in the MVar, trying to read it will just block until it fills, by default.
06:21:54 <slarba> yep. and that prevents timeout checking
06:22:06 <Cale> Ah, I see what you want.
06:22:14 <Cale> Okay, let me get a piece of code for you :)
06:22:20 <slarba> that'd be cool!
06:22:29 <Cale> http://haskell.org/haskellwiki/Timing_out_computations
06:22:45 <Cale> Check out my little 'compete' combinator.
06:23:01 <Cale> compete :: [IO a] -> IO a
06:23:12 <Cale> First one to finish gets to determine the result :)
06:23:29 * quicksilver sets to work designing a 'win' combinator.
06:23:41 <Cale> So you can implement a timeout, like I showed, using threadDelay in one of the branches.
06:23:50 <slarba> Cale: threadDelay works without threaded runtime?
06:23:54 <Cale> Right.
06:24:13 <slarba> thanks, that page looks useful
06:24:32 <slarba> off to home to write some code ->
06:24:33 * quicksilver thinks he pointed slarba to threadDelay and killThread a few pages back :P
06:24:51 <Cale> The threaded runtime actually shouldn't affect too much -- it just implements real parallelism on top of the concurrency which is normally implemented by Haskell threads.
06:25:35 <Cale> (by using multiple OS threads to execute the various Haskell threads in parallel)
06:26:01 <Cale> Unless you're doing stuff with FFI, you shouldn't easily be able to tell the difference.
06:26:23 <slarba> Cale: there's one thread using Network.Pcap...
06:27:08 <slarba> which uses FFI in turn
06:27:19 <quicksilver> Cale: you can tell by responsiveness
06:27:26 <quicksilver> Cale: in interactive programs, at least.
06:27:42 <slarba> pcap has blocking calls... though there's timeouts implemented in the C code I presume
06:27:57 <slarba> at least you can give timeout to openDevice
06:32:37 <Cale> http://thedailywtf.com/Articles/A-Rather-Interesting-Specialization.aspx -- ahaha
06:33:02 <Cale> Bachelor of Landscape Architecture in Computer Science :D
06:46:33 <shapr> quicksilver: I bet my company would license the win combinator...
06:46:35 <ehird`_> question..
06:46:39 <shapr> answer..
06:46:48 <ehird`_> what do i do if there's a Network.IRC, but it sucks, and mine is far better?
06:46:53 <ehird`_> the only solution seems to be calling it Network.BetterIRC
06:46:57 <ehird`_> but that's not exactly semantically useful
06:47:11 <shapr> ehird`_: Replace it with yours?
06:47:21 <shapr> Has Network.IRC been released on hackage or something?
06:47:44 <ehird`_> shapr: Yes, I believe so
06:47:44 <Zao> "irc", I believe it's called.
06:47:53 <ehird`_> But it's not very good. :P
06:47:57 <ehird`_> IMO
06:48:03 <Zao> It's somewhat competent, apart from a somewhat broken : handling.
06:48:26 <ehird`_> Zao: Yes, I prefer higher-level abstractions thogh.
06:48:33 <ehird`_> Strongly typed throughout, etc.
06:48:42 <shapr> ehird`_: Network.IRC' ?
06:48:50 <ehird`_> haha
06:48:52 <ehird`_> can you do that? :)
06:49:08 <byorgey> Network.IRC++ ?
06:49:44 <ehird`_> ADD ONE TO Network.IRC GIVING Network.IRC
06:49:58 <shapr> eek
06:50:04 <quicksilver> Network.Combinators.IRC
06:50:08 <quicksilver> everyone like combinators
06:50:19 <quicksilver> and that makes it sound all superior and stuff
06:50:23 <ehird`_> quicksilver: i'm quite unsure how to write irc combinators
06:50:23 <ehird`_> :)
06:50:25 * shapr grins
06:51:20 <ehird`_> Network.IRC.Better
06:51:25 <ehird`_> cheeky hijacking of its namespace.
06:52:16 <quicksilver> Betterwork.IRC
06:52:25 <pejo> ehird, have you tried syncing/fixing the current Network.IRC? I find myself in an awkward situation every time i use perl and need a module since there are always atleast 4 of them, who all do sort of the same thing.
06:53:02 <ehird`_> pejo: its design is not one i like
06:53:39 <shapr> ehird`_: Is your code on hackage?
06:53:55 <ehird`_> shapr: no. no it's not
06:54:24 <shapr> aww
06:54:54 <ehird`_> it will be
06:54:55 <ehird`_> eventually
06:54:56 <ehird`_> :)
06:54:58 <ehird`_> once it actually works
06:57:44 <ehird`_> but before that, i obviously need to name it
06:57:45 <ehird`_> hmm
06:57:51 <ehird`_> i could force people to uninstall the old, crusty one
06:57:52 <ehird`_> :-D
06:57:58 <ehird`_> and just use Network.IRC
06:58:25 <quicksilver> is it client or server or both, ehird`_ ?
06:58:36 <ehird`_> quicksilver: client. server would be Network.IRCd
06:58:40 <ehird`_> which I may write, sometime.
06:59:24 <ehird`_> another thing I'm working on is Network.GenericCGI (needs a rename...) which unifies Network.CGI/FastCGI/SCGI/etc and also <insert Haskell webserver here> by having the same itnerface but a class&instance approach to servers
06:59:37 <ehird`_> my IRC bot, Endeavour, will unify the two to provide a web interface to it
06:59:59 <Saizan> is it only a parser like hackage's irc or manages connections?
07:00:11 <ehird`_> Saizan: it handles pretty much everything
07:00:19 <ehird`_> it has a Client type, which has multiple Connections, but shared event handlers
07:00:29 <ehird`_> thus, you can have a multiple-server bot trivially
07:00:53 <shapr> ehird`_: I want it!
07:00:55 <ehird`_> and also maybe things like 'replyTo msg "it worked"'
07:01:02 <ehird`_> which would do "nick: it worked"
07:01:07 <ehird`_> or in a privmsg, "it worked"
07:01:13 <shapr> snoops: Hiya
07:01:42 * snoops tips his metaphysical hat
07:02:30 <shapr> snoops: What sort of programming language theory stuff interests you?
07:03:04 <snoops> well, what do you mean? Turing machines interest me greatly
07:03:14 <ehird`_> oh -- and it uses Parsec to parse IRC
07:03:14 <ehird`_> :D
07:03:23 <shapr> snoops: Have you done any logic or functional programming stuff?
07:03:41 <Saizan> ehird`_: yours?
07:03:47 <ehird`_> Saizan: yes
07:03:51 <ehird`_> p.s. the replyTo signature will look something like this:
07:04:00 <shapr> snoops: Are you familiar with lambda calculus and how it relates to turing machines?
07:04:03 <snoops> I've done a little bit of logic programming in prolog, and a few tutorials in haskell, but nothing else really
07:04:15 <ehird`_> replyTo :: (IRCCommand a) => IRCMessage a -> String -> IRC ()
07:04:22 <ehird`_> :)
07:04:44 <thotypous> @src group
07:04:44 <lambdabot> group = groupBy (==)
07:04:47 <thotypous> @src groupBy
07:04:47 <lambdabot> groupBy _  []       =  []
07:04:47 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
07:04:48 <lambdabot>     where (ys,zs) = span (eq x) xs
07:04:50 <snoops> that'd be a no on lambda calculas
07:04:57 <shapr> snoops: Ooh, you'll like it, it's fun!
07:05:25 <ehird`_> Y := \f. (\x. f (x x)) (\x. f (x x))
07:05:29 <ehird`_> ^ enough to convince anyone
07:05:39 * shapr throws omegas at ehird`_
07:05:52 <radix> ehird`_: is that an implementation of an IMAP server
07:05:56 <snoops> there's a reason I'm only doing math and philosophy papers this year at uni.. Had enough of the computer science ones for awhile
07:05:57 <ehird`_> radix: yes
07:06:03 <radix> ehird`_: sweet
07:06:06 <radix> I'm convinced
07:06:40 <shapr> snoops: This might get you started: http://en.wikipedia.org/wiki/Lambda_calculus
07:06:40 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
07:06:40 <shapr> snoops: feel free to ask any questions
07:07:29 <snoops> oh yes, right, cool beans. Ain't wikipedia grand?
07:08:37 <ehird`_> hmmm:
07:08:40 <ehird`_> Y :: ((a = (a -> a)) -> a) -> a
07:08:43 <ehird`_> that's not right, is it :P
07:09:38 <ehird`_> hm
07:09:39 <ehird`_> Y :: (a = a -> a) -> a
07:10:26 <Saizan> ?type fix
07:10:29 <lambdabot> forall a. (a -> a) -> a
07:12:39 <quicksilver> or just Y :: (a = a -> a)
07:12:44 <quicksilver> which is the same thing
07:12:54 <quicksilver> once a = a -> a, all LC terms have the same type
07:13:06 <ehird`_> true..
07:13:14 <ehird`_> but i mean the most specific type reasonable
07:13:28 <quicksilver> I don't think that's any more specific than mine
07:13:32 <ehird`_> quicksilver: let's assume the type system that is just powerful enough to type the Y combinator
07:13:34 <ehird`_> what is the type then?
07:13:43 <quicksilver> (a = a -> a)
07:13:49 <quicksilver> that's forced
07:13:53 <ehird`_> very helpful..
07:13:59 <ehird`_> i am sure there must be a type system inbetween
07:14:07 <ehird`_> i.e. more useful than completely useless non-typing
07:14:07 <quicksilver> not one which types Y, there isn't
07:14:15 <ehird`_> aww
07:14:17 <ehird`_> that sucks
07:14:18 <ehird`_> :)
07:14:18 <quicksilver> there are of course type systems in between
07:14:21 <quicksilver> but they don't admit Y
07:14:29 <ehird`_> quicksilver: do they admit any fixed point combinator?
07:15:11 <JohnMeacham> do you think restricting RULES to top level declarations is an acceptable thing?
07:15:21 <pythonist> I see that many of the Haskell people out there use Blogger to host their programming blogs. Any of them in here now?
07:16:39 <shapr> JohnMeacham: I can't think of any uses of RULES outside of top level declarations, but dons is a good person to ask there.
07:16:39 <ehird`_> hmm
07:16:44 * ehird`_ wonders how to name his irc stuff
07:16:47 <ehird`_> well
07:16:51 <ehird`_> just the commands, specifically
07:16:53 <ehird`_> I'm in Network.IRC.Commands
07:16:57 <ehird`_> so I COULD do just "PRIVMSG", etc
07:17:00 <ehird`_> but that seems clashy
07:17:03 <shapr> snoops: So, which Haskell tutorials have you tried? Or, what sort of PLT stuff are you learning at the moment?
07:19:11 <ehird`_> newtype CONNECT = CONNECT IRCServer PortNumber (Maybe IRCServer)
07:19:12 <ehird`_> :D
07:19:37 <JohnMeacham> shapr: well, I would mainly be restricting them in jhc internally as well, meaning RULES functions could not be floated inward for instance without losing their rules... hmm..
07:19:58 <shapr> byorgey just mentioned http://www-maths.swan.ac.uk/staff/jrh/papers/JRHHislamWeb.pdf - "History of Lambda-Calculus and Combinatory logic"
07:20:35 <ehird`_> hmm
07:20:45 <ehird`_> is there a shows-function for [String] -> String, seperated by spaces?
07:21:24 <allbery_b> :t intercalate
07:21:37 * allbery_b sighs
07:21:39 <lambdabot> thread killed
07:21:43 <allbery_b> :t intercalate
07:21:44 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:21:56 <Saizan> unwords?
07:21:56 <yrlnry> I totally misparsed "JRRHislamWeb.pdf" as being a paper on islam-Web by someone with initials JRRH.
07:22:03 <ehird`_> intercalate isn't a shows function
07:22:13 <ehird`_> yrlnry: wow, me too
07:22:21 <shapr> allbery_b: There's break and glue in PreludeExts
07:23:02 <shapr> Doesn't do ShowS though.
07:24:10 <hpaste>  ehird pasted "I imagine there is a much better, simpler way to do this that I just haven't figured out yet" at http://hpaste.org/5755
07:24:13 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5756
07:24:23 <ehird`_> especially the cmdName's dummy arg
07:26:49 <Saizan> you've a type for each command?
07:26:59 <ehird`_> Saizan: yep.
07:27:05 <ehird`_> -- and that is actually an intentional feature
07:28:12 <ehird`_> hm
07:28:21 <ehird`_> i should make the show instance detect spaces on the last parameter
07:28:30 <ehird`_> Saizan: i don't think i'll do anything but 'error' if there's spaces on other ones, though.
07:28:37 <ehird`_> if your program does that it's just broken.
07:29:49 <Saizan> so you're using show to generate the strings for the server?
07:30:34 <Saizan> btw showString "" == id
07:31:25 <ehird`_> Saizan: and yes, i am
07:31:39 <ehird`_> and personally (showString "") means more to me than id
07:32:16 <Cale> ehird`_: You can also just define show
07:33:07 <ehird`_> Cale: Eh.
07:33:12 <ehird`_> I like shows.
07:33:37 <ehird`_>  error "Spaces in non-last argument."
07:33:42 <ehird`_> i should totally word that better.
07:34:22 <hpaste>  ehird pasted "this whole thing is really ugly" at http://hpaste.org/5757
07:34:40 <Saizan> maybe it's nicer to check those inveriants at construction
07:34:43 <Saizan> *invariants
07:34:59 <ehird`_> Saizan: I guess so.
07:35:07 <ehird`_> but then,
07:35:17 <ehird`_> I have to create a constructor for *every single irc command*
07:35:23 <ehird`_> because each one is an entirely seperate data record
07:35:32 <ehird`_> and uh i'm already creating an instance and a well-typed data type
07:35:34 <ehird`_> i really don't need more
07:35:37 <quicksilver> I'm not sure why you're making them different records and using classes
07:35:38 <ehird`_> to have to write :)
07:35:43 <quicksilver> instead of just one data type
07:35:57 <ehird`_> quicksilver: because functions might accept commands of only one type.
07:36:05 <ehird`_> and because:
07:36:07 <ehird`_> newtype CONNECT = CONNECT IRCServer PortNumber (Maybe IRCServer)
07:36:14 <ehird`_> show me how to get that type-safety with one type.
07:36:25 <ehird`_> this makes sure that whenever you create a command, you don't have nonsense data in it
07:36:26 <quicksilver> that's a horrible, horrible reason to use classes
07:36:38 <ehird`_> quicksilver: OK -- show me a good way to structure it
07:37:11 <quicksilver> data IRCCommand = Connect IRCServer PortNumber (Maybe IRCServer) | SendMsg Recipent Msg | ....
07:38:20 <ehird`_> hm
07:38:21 <ehird`_> good point
07:38:29 <ehird`_> but then i have to define 10495873498573459802759082375908237598235792083457923745982357892345 seperate show instances.
07:38:44 <ehird`_> i.e. for the CONNECT constructor, "CONNECT " ...
07:38:48 <Saizan> as many as IrcCommand instances :)
07:38:52 <quicksilver> I don't really know what you mean
07:38:58 <quicksilver> the irccommand instances are far uglier
07:39:01 <ehird`_> Saizan: yes, but at least with the class approach most of the lgoic is done for me
07:39:04 <quicksilver> and don't use show for this, anyway
07:39:10 <quicksilver> show is for debugging
07:39:14 <quicksilver> a real program which uses show is broken
07:39:15 <Saizan> ehird`_: you can do that too
07:39:21 <quicksilver> (except for displaying Ints and Doubles)
07:39:25 <ehird`_> quicksilver: 'show' and 'read' are pretty good metaphors, i'd say..
07:39:32 <Cale> quicksilver: I disagree :)
07:39:33 <ehird`_> read to parse an irc message, show to dump it out
07:39:38 <ehird`_> Saizan: good point.
07:39:41 <ehird`_> Okies then.
07:39:47 <quicksilver> Cale: I exaggerate for comic(?) effect
07:39:50 <Cale> :)
07:40:03 <quicksilver> the correct approach for ehird`_'s case is a pair of functions
07:40:08 <quicksilver> parse :: String -> IRCCommand
07:40:13 <quicksilver> format :: IRCCommand -> String
07:40:23 <quicksilver> I see no virtue in (ab)using the Show/Read pair for this.
07:40:24 <ehird`_> quicksilver: hey, those signatures look familiar...
07:40:29 <ehird`_> hey, that's it! they're show/read.
07:40:30 <quicksilver> the Show/Read pair are very useful for debugging
07:40:34 <quicksilver> and that's what you should use them for.
07:40:39 <ehird`_> but golly, let's just reinvent every feature ourselves
07:40:46 <quicksilver> no, because it's quite different
07:40:54 <quicksilver> the point of show/read is to produce valid haskell code
07:41:03 <quicksilver> which you can copy and paste between interactive ghci sessions
07:41:07 <quicksilver> and (e.g.) test suites
07:41:23 <quicksilver> the point of it is not to produce some well defined external format.
07:41:24 <ehird`_> quicksilver: uhm, i'm pretty sure if you need to do 'read' then what you 'show'ed was NOT haskell code...
07:41:31 <ehird`_> (even in the stdlib -- see: random number generators, etc)
07:41:31 <jedbrown> Seems to me the signature should be parse :: String -> Maybe IRCCommand
07:41:43 <quicksilver> jedbrown: almost certainly, yes
07:41:56 <quicksilver> ehird`_: that makes no sense?
07:42:09 <quicksilver> > show [1,2,3]
07:42:11 <lambdabot>  "[1,2,3]"
07:42:16 <quicksilver> the point of that, is that I can debug with it
07:42:18 <quicksilver> play with it in ghci
07:42:21 <ehird`_> > mkStdGen
07:42:23 <lambdabot>   add an instance declaration for (Typeable StdGen)
07:42:26 <ehird`_> of course that won't work :)
07:42:28 <quicksilver> "[1,2,3]" is a valid chunk of haskell
07:42:33 <ehird`_> but, try out a random number generator in ghci.
07:42:38 <ehird`_> it spits out two ints as its show.
07:42:45 <ehird`_> and reads them back in to form a random number generator with the same stat.e
07:43:01 <quicksilver> just because the standard library generators made a stupid design decision doesn't mean you should copy them
07:43:14 <ehird`_> i don't think it's a stupid decision.
07:43:17 <flux> hm, what was the trick with prime numbers to store multiple integers of any size into a single one? my brain fails :(
07:43:24 <quicksilver> well, I do, and I'm explaining why
07:43:31 <quicksilver> because the ability to enter an expression into ghci
07:43:36 <ehird`_> if (show.read) == id, then i think it's a very good way for producing output&reading input
07:43:40 <quicksilver> (which wil automatically 'show' it)
07:43:46 <quicksilver> and then use that data in later test cases
07:43:51 <quicksilver> is a powerful featre for debugging
07:43:53 <ehird`_> quicksilver: OK, so if it outputs some valid Haskell code, then why do we need 'read'?
07:43:56 <ehird`_> exactly - we wouldn't.
07:43:57 <quicksilver> anything which breaks that is annoying
07:43:58 <Cale> ehird`_: Surely you mean read . show ?
07:44:03 <ehird`_> Cale: uhm, yes
07:44:04 <faxathisia> show . read = id -- It's desired but cannot be enforced
07:44:20 <ehird`_> if show was intended to output valid haskell code all the time
07:44:23 <ehird`_> read would be useless.
07:44:36 <Cale> ehird`_: why?
07:44:46 <quicksilver> as a pair, show/read gives you a cheap format for config files and stuff
07:44:51 <Cale> Because we could replace it with hs-plugins?
07:44:52 <quicksilver> very handy for quick hacks and so on
07:44:55 <allbery_b> ehird`_: only if Haskell had interpreted eval
07:45:07 <allbery_b> which it does not (except, in a limited sense, with read!)
07:45:15 <Cale> allbery_b: hs-plugins!
07:45:18 <ehird`_> allbery_b: Exactly! Thus, it is intended for a use outside of using the console to debug.
07:45:32 <ehird`_> Thus, show can be used for my purposes.
07:45:44 <quicksilver> arguing about what is intended is pointeless, because none of us here are on the haskell committee.
07:45:46 <jedbrown> Text.Show.Functions  ;P
07:45:54 <quicksilver> what's interesting is to argue about what is *best*
07:46:02 <quicksilver> and what is best is to use Show to produce valid haskell code
07:46:09 <quicksilver> as the vast majority of library instances do
07:46:19 <Cale> I don't think that read and show should be required to satisfy any laws.
07:46:41 <quicksilver> the broken StdGen show instance is a source of great annoyance to me, in fact.
07:47:09 <Cale> It would be nice to have a class which *did* express that kind of reflective property though.
07:47:28 <ehird`_> on an entirely unrelated note, strongly typing IRC commands is *hard*
07:47:28 <quicksilver> because it makes the derived show instance on my data types (Which include StdGen) broken
07:47:33 <ehird`_> on an entirely unrelated note, strongly typing IRC commands is *hard*
07:47:34 <ehird`_> err
07:47:35 <ehird`_> oops
07:47:44 <Cale> quicksilver: it does?
07:47:50 <Cale> How so?
07:47:52 <ehird`_> because: sometimes there's a nickname, or maybe a client which is a nickname or some pattern, and sdfkglhs;dfklgja;lgjl;ka
07:47:58 <quicksilver> Cale: yes, it does. They lose the copy/paste property.
07:48:10 <Dybber> Hmm, do i need to give GHC somekind of flag to get access to Control.Monad.Writer? I get "Could not find module `Control.Monad.Writer'"
07:48:17 <quicksilver> Cale: I can no longer play in ghci, locate a corner case, and copy-paste in into a test case.
07:48:17 <Cale> Oh, in that sense of broken
07:48:21 <quicksilver> Cale: very frustrating.
07:48:22 <jedbrown> faxathisia: I think (read . show = id) is more desirable actually.
07:48:35 <Saizan> Dybber: do you have the mtl package installed?
07:48:39 <quicksilver> read . show = id and the copy-paste property and both desirable
07:48:43 <Cale> Dybber: ghc-pkg list mtl
07:48:44 <ehird`_> jedbrown: they imply each other, i think
07:48:49 <quicksilver> and so is the 'useful for debugging property'
07:48:50 <jedbrown> faxathisia: show . read = id is not very useful.
07:48:52 <Dybber> Saizan: probably not
07:49:08 <quicksilver> each of those is somewhat separate although they can coincide
07:49:11 <Cale> Dybber: Try that command and see if it gives you an installed mtl version :)
07:49:17 <jedbrown> ehird`_: show (read "   3  ") = "3"
07:49:21 <quicksilver> it's a shame that haskell doesn't separate them
07:49:25 <ehird`_> jedbrown: OK, true.
07:49:30 <Cale> Dybber: If not, it's possible that you just installed the 'light' version of GHC.
07:49:42 <Cale> Dybber: What's your GHC version number?
07:49:56 <Cale> (though this won't tell us if you have the light package or not)
07:50:08 <Dybber> Cale: no mtl. it's version 6.6.1
07:50:27 <Cale> Dybber: ah, you're a major release back too.
07:50:37 <Cale> (6.8.2 has been out for a while)
07:51:04 <Dybber> Yes I know, I just use whatever Ubuntu provides
07:51:19 <quicksilver> apt-get install libghc6-mtl-dev
07:51:20 <quicksilver> or something
07:51:24 <Cale> Okay, libghc6-mtl-dev
07:51:25 <Cale> yes
07:51:39 <ac> what's a more elegant way of saying: [(x+a, y+b), (x-a, y+b), (x+a, y-b), (x-a, y-b), (x+b, y+a), (x-b, y+a), (x+b, y-a), (x-b, y-a)] -- ?
07:51:43 <Cale> But you might find that sticking with Ubuntu's packages for GHC is less than convenient.
07:52:04 <Dybber> looks like it worked.
07:52:34 <BMeph> So, did anyone list "the need for an invariant enforcer" as a peeve on DRMacIver's post?
07:52:52 <shapr> BMeph: Dana Xu's ESC stuff?
07:52:54 <Cale> ac: [(+),(-)] `ap` [x,y] `ap` [a,b]
07:53:02 <Cale> err...
07:53:03 <Cale> no
07:53:23 <Cale> ah, I see what's going on there :)
07:53:31 <quicksilver> ac: [(x+dx,y+dy) | dx <- [-a,a,-b,b] , dy <- [-a,a,-b,b]]
07:53:32 <Cale> soo...
07:53:38 <Cale> sure :)
07:53:40 <Deewiant> > [(+),(-)] `ap` [x,y] `ap` [a,b]
07:53:41 <lambdabot>  [x + a,x + b,y + a,y + b,x - a,x - b,y - a,y - b]
07:53:59 <Cale> yeah, that just generates all the possible combinations, not the appropriate pairs.
07:54:05 <BMeph> shapr: Not familiar with it - is it a Haskell project?
07:55:04 <Cale> > [(f x dx,f y dy) | f <- [(+), (-)], dx <- [a,b], dy <- [a,b]]
07:55:05 <lambdabot>  [(x + a,y + a),(x + a,y + b),(x + b,y + a),(x + b,y + b),(x - a,y - a),(x - ...
07:55:17 <roconnor> @seen Igloo
07:55:17 <lambdabot> Igloo is in #haskell, #ghc and #darcs. I last heard Igloo speak 2h 14m 37s ago.
07:55:30 <Cale> > [(f x dx,f y dy) | f <- [(+), (-)], [dx,dy] <- replicate 2 [a,b]]
07:55:32 <lambdabot>  [(x + a,y + b),(x + a,y + b),(x - a,y - b),(x - a,y - b)]
07:55:39 <Cale> huh...
07:55:43 <Cale> oh
07:55:50 <Cale> > [(f x dx,f y dy) | f <- [(+), (-)], [dx,dy] <- replicateM 2 [a,b]]
07:55:52 <lambdabot>  [(x + a,y + a),(x + a,y + b),(x + b,y + a),(x + b,y + b),(x - a,y - a),(x - ...
07:55:58 <Cale> right :)
07:56:04 <quicksilver> > x + a
07:56:05 <lambdabot>  x + a
07:56:09 <quicksilver> wtf?
07:56:12 <quicksilver> > x
07:56:13 <lambdabot>  x
07:56:15 <ehird`_> you could use ap for this
07:56:17 <ehird`_> and the list monad
07:56:18 <ehird`_> i think
07:56:19 * quicksilver laughs
07:56:20 <Cale> > iterate f x
07:56:21 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
07:56:23 <faxathisia> > foldr f z [a,b,c,d]
07:56:24 <lambdabot>  f a (f b (f c (f d z)))
07:56:26 <ehird`_> i seem to remember a similar example yesterday
07:56:32 <faxathisia> > foldl (flip f) z (reverse [a,b,c,d])
07:56:33 <lambdabot>  f a (f b (f c (f d z)))
07:56:35 <ac> how does lambdabot do that?
07:56:38 <quicksilver> ehird`_: erm. Cale just did use ap and the list monad :P
07:56:46 <faxathisia> Lambdabot knows haskell :D
07:56:48 <roconnor> @type a
07:56:48 <ehird`_> ac: lots of toplevel variables and fromInteger
07:56:52 <lambdabot> Not in scope: `a'
07:56:53 <Cale> ehird`_: it's not quite so simple as my application of ap though :)
07:56:58 <Japsu> @type f
07:56:58 <faxathisia> > a :: Expr
07:56:59 <lambdabot> Not in scope: `f'
07:56:59 <lambdabot>  a
07:57:11 <Japsu> Expr is... black magic.
07:57:23 <ehird`_> > const a a :: Expr
07:57:24 <lambdabot>  a
07:57:26 <ac> is there an expression type for f and x?
07:57:36 <ehird`_> > let foo=a-foo in foo :: Expr
07:57:37 <lambdabot>  a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a...
07:57:37 <Cale> ac: In lambdabot, yes
07:57:46 <roconnor> a b c d, are expressions
07:57:48 <ehird`_> > let foo=a-bar; bar=a+foo in foo :: Expr
07:57:49 <lambdabot>  a - (a + (a - (a + (a - (a + (a - (a + (a - (a + (a - (a + (a - (a + (a - (a...
07:57:52 <roconnor> f is a function from expression to expressions
07:57:54 <Deewiant> @where simplereflect
07:57:55 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
07:57:56 <ehird`_> > let foo=a-bar; bar=foo+a in foo :: Expr
07:57:56 <Deewiant> ac: ^
07:57:57 <lambdabot>  a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a - (a...
07:58:08 <Cale> It doesn't work exactly as in the blog post though.
07:58:15 <Cale> It's an extension of that.
07:58:21 <Cale> Since we can do things like:
07:58:22 <ac> cool
07:58:32 <ac> so that's a receent addition
07:58:34 <quicksilver> Cale: when did that go into lambdabot ?
07:58:37 <Cale> let fac 0 = 1; fac n = n * fac (n-1) in fac 5 :: Expr
07:58:39 <Deewiant> week or two ago?
07:58:48 <Cale> quicksilver: A couple weeks ago?
07:58:55 <quicksilver> interesting
07:58:58 <Cale> > let fac 0 = 1; fac n = n * fac (n-1) in fac 5 :: Expr
07:58:59 <lambdabot>  5 * ((5 - 1) * ((5 - 1 - 1) * ((5 - 1 - 1 - 1) * ((5 - 1 - 1 - 1 - 1) * 1))))
07:59:04 <roconnor> > let fac 0 = 1; fac n = n * fac (n-1) in fac a :: Expr
07:59:05 <lambdabot>  a * ((a - 1) * ((a - 1 - 1) * ((a - 1 - 1 - 1) * ((a - 1 - 1 - 1 - 1) * ((a ...
07:59:13 <Cale> > 2^3217 :: Expr
07:59:14 <lambdabot>  2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)) * (2 * 2 * (2 * 2) * (2 * 2 * (2 * 2))) ...
07:59:19 <Deewiant> oh cool, that's new
08:00:06 <Cale> Bonus points for anyone who can figure out the right magic to get it to express sharing explicitly using let :)
08:00:33 <Cale> (I think that might be a little hard :)
08:00:38 <quicksilver> I'm wondering if this will be a useful tool or confusing
08:00:42 <Cale> useful
08:00:48 <ac> > let x = 15; y = 20; a = 2; b = 1 in [(x+dx,y+dy) | dx <- [-a,a,-b,b] , dy <- [-a,a,-b,b]]
08:00:49 <Cale> > foldr f z [1..5]
08:00:49 <lambdabot>  [(13,18),(13,22),(13,19),(13,21),(17,18),(17,22),(17,19),(17,21),(14,18),(14...
08:00:50 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
08:00:55 <Deewiant> > map f [a,b,c]
08:00:56 <lambdabot>  Add a type signature
08:01:03 <Deewiant> meh, still needs a type signature
08:01:03 <Cale> > map f [a,b,c] :: Expr
08:01:04 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
08:01:07 <Cale> > map f [a,b,c] :: [Expr]
08:01:08 <lambdabot>  [f a,f b,f c]
08:01:25 <Deewiant> why is that necessary?
08:01:45 <Cale> :t f
08:01:45 <lambdabot> Not in scope: `f'
08:01:47 <Cale> er...
08:01:49 <Cale> right :)
08:01:49 <Deewiant> :-)
08:01:51 <quicksilver> Cale: OK, it's obviously useful. Maybe I didn't express it well.
08:02:04 <quicksilver> Cale: I wonder whether its capability for confusing newbies will outweigh its ability to help them.
08:02:15 <quicksilver> especially with the out-of-sync with :t
08:02:25 <Cale> It's specifically designed to help me with showing what folds do. :)
08:02:25 <quicksilver> and the fact they won't be able to reproduce the results in their own ghci
08:02:38 <quicksilver> > a + e
08:02:39 <lambdabot>  a + e
08:02:43 <quicksilver> > a + g
08:02:44 <lambdabot>  a + g
08:02:44 <faxathisia> @@ @run @run let sub '*'='+'; sub x = x in fun $ map sub $ show (2^5 :: Expr) :: Expr
08:02:46 <lambdabot>  10
08:02:48 <roconnor> quicksilver: let's try it out on some new users first.
08:02:49 <Cale> We should package it up and make it available on hackage though.
08:02:49 <quicksilver> > a + y
08:02:50 <lambdabot>  a + y
08:03:04 <Cale> In fact, I suspect it's useful enough that it should be in GHC.
08:03:04 <faxathisia> macros :D
08:03:06 <quicksilver> roconnor: I wasn't suggesting it be turned off. Just raising the question.
08:03:18 <Cale> (the big GHC)
08:03:53 <Saizan> in GHC you could do it in a more proper way i hope
08:03:53 <quicksilver> > aa + a
08:03:53 <lambdabot>   Not in scope: `aa'
08:04:10 <ehird`_> > iterate fix undefined
08:04:10 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
08:04:10 <lambdabot>     Probabl...
08:04:21 <ehird`_> > iterate fix id
08:04:22 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
08:04:22 <lambdabot>     Probabl...
08:04:24 * BMeph Googles "Dana Xu" and starts reading papers...
08:04:25 <ehird`_> goshdarn
08:04:26 <ehird`_> :)
08:04:28 <Cale> You can't iterate fix
08:04:37 <Cale> fix :: (a -> a) -> a
08:04:42 <ehird`_> i know
08:04:50 <ehird`_> @djinn (a -> a) -> a
08:04:50 <lambdabot> -- f cannot be realized.
08:04:57 <ehird`_> stupidjinn
08:04:59 <quicksilver> > fix (a+)
08:05:01 <Deewiant> :-)
08:05:01 <lambdabot>  a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a + (a...
08:05:16 <ehird`_> > fix iterate
08:05:17 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
08:05:17 <lambdabot>       Expected...
08:05:24 <ehird`_> > fix (iterate id)
08:05:25 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
08:05:25 <lambdabot>       Expected...
08:05:27 <ehird`_> hmph
08:05:37 <ac> quicksilver: your solution does not work. Note that there was no (x+a, y+a) in there
08:05:37 <ehird`_> > fix (iterate f)
08:05:38 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
08:05:38 <lambdabot>       Expected...
08:05:39 <ehird`_> > fix (iterate f) :: Expr
08:05:40 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
08:05:40 <lambdabot>       Expected...
08:05:43 <ehird`_> > fix (iterate f) :: [Expr]
08:05:43 <Saizan> ?type iterate --
08:05:43 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
08:05:43 <lambdabot>       Expected...
08:05:44 <lambdabot> forall a. (a -> a) -> a -> [a]
08:06:00 <Saizan> it doesn't match with ( a -> a )
08:06:18 <ehird`_> @djinn (a -> a) -> b -> b
08:06:18 <lambdabot> f _ a = a
08:06:34 <ehird`_> @type \f x -> f (f x)
08:06:35 <lambdabot> forall t. (t -> t) -> t -> t
08:07:08 <ehird`_> @djinn ((t -> t) -> t -> t) -> ((t -> t) -> t -> t)
08:07:08 <lambdabot> f a = a
08:07:10 <ehird`_> d'aww
08:07:11 <ehird`_> :)
08:07:18 <ehird`_> trying to get lambdabot to do stuff is fun.
08:07:21 <ac> in other words, I want to reflect (a,b) over x, y, Y = x, Y = -x
08:09:01 <ac> quicksilver: so your solution gives the desired effect, except plus a big 'X' centered on (x,y) :P
08:09:07 <Twey> @src map
08:09:07 <lambdabot> map _ []     = []
08:09:07 <lambdabot> map f (x:xs) = f x : map f xs
08:09:10 <ehird`_> awww.......
08:09:22 <ehird`_> you can't type the church-numeral pred in Haskell
08:09:32 <ehird`_> oh, wait
08:09:34 <ehird`_> just not with the same type as succ
08:09:51 <ehird`_> pred :: (((t -> t2) -> (t2 -> t3) -> t3) -> (t4 -> t1) -> (t5 -> t5) -> t6)
08:09:51 <ehird`_>              -> t
08:09:51 <ehird`_>              -> t1
08:09:51 <ehird`_>              -> t6
08:09:56 <Twey> @src (fmap :: (a -> b) -> [a] -> [b])
08:09:56 <lambdabot> Source not found. There are some things that I just don't know.
08:10:00 <Twey> @src fmap :: (a -> b) -> [a] -> [b]
08:10:00 <lambdabot> Source not found. I feel much better now.
08:10:02 <Twey> :-(
08:10:17 <Twey> How do I ask for the source of fmap on lists?
08:10:22 <Cale> @src [] fmap
08:10:22 <lambdabot> fmap = map
08:10:28 <Twey> Aha, thanks
08:10:37 <ehird`_> (a -> a) -> (a -> a) -> (a -> a)   -- well typed church numerals
08:10:52 <Cale> Oh, how I wish that fmap were named map and (.) :)
08:11:06 <penpen> hi
08:11:09 <ehird`_> succ :: ((a -> a) -> (a -> a) -> (a -> a)) -> ((a -> a) -> (a -> a) -> (a -> a))
08:11:13 <Cale> penpen: hello :)
08:11:14 <Twey> Cale, eh?
08:11:47 <Twey> penpen: Salutations!
08:11:47 <ehird`_> hm
08:11:47 <ehird`_> you can't type that though
08:11:47 <ehird`_> heh
08:11:48 <Cale> Twey: In Haskell 1.4, there was no specific map for lists. map was general and worked for any Functor
08:11:58 <Twey> Why did they change it?
08:12:04 <Twey> Seems a bit pointless
08:12:08 <ac> I think I want: let ds = [a,-a,b,-b] in zip [(x+dx) | dx <- ds] [(y+dy | dy <- ds]
08:12:35 <Saizan> ehird`_: http://okmij.org/ftp/Haskell/types.html#some-impredicativity
08:12:35 <doserj> Twey: they didn't want to explain functors in their programming courses
08:12:35 <Cale> Twey: Fear of polymorphism, I guess.
08:12:36 <lambdabot> Title: Haskell Programming: Types
08:12:39 <penpen> I am a Haskell rookie and currently try to install hpodder's - http://software.complete.org/hpodder - requirements
08:12:40 <lambdabot> Title: hpodder
08:12:42 <Cale> Also, (.) is another special case of fmap
08:12:54 <Cale> It would be nice if its type were just as general.
08:13:18 <quicksilver> I'm not opposed to monomorphic types being available
08:13:21 <Cale> (then we'd have an infix version of fmap :)
08:13:25 <ehird`_> Saizan: what is okmij.org anyway
08:13:26 <ac> er, I meant ++ instead of zip
08:13:28 <ehird`_> there's no 'about' page or anything
08:13:30 <quicksilver> there is value in having a monomorphic map available
08:13:30 <penpen> When building HDBC-1.0.1 I encounter
08:13:32 <penpen>     Could not find module `System.Time':
08:13:32 <ehird`_> just loads of functional programmin stuff in /ftp
08:13:34 <Cale> Yeah, but they should be named less conveniently :)
08:13:34 <penpen>       it is a member of package old-time-1.0.0.0, which is hidden
08:13:39 <ac> er, no I didn't
08:13:47 <Cale> It should be lmap if you want the list map specifically.
08:14:05 <ehird`_> pred :: (((a -> a) -> (a -> a) -> a) -> (a -> a) -> (a -> a) -> a) -> a -> a -> a
08:14:07 <ehird`_> that is beautiful
08:14:10 <penpen> I tried "sudo ghc-pkg expose old-time" but to no avail...
08:14:17 <ehird`_> @djiinn (((a -> a) -> (a -> a) -> a) -> (a -> a) -> (a -> a) -> a) -> a -> a -> a
08:14:17 <lambdabot> f a _ b = a (\ c d -> d (c b)) (\ e -> e) (\ f -> f)
08:14:24 <ehird`_> it recognizes @djiinn?!
08:14:34 <quicksilver> ehird`_: it does typo-correction
08:14:38 <Cale> penpen: that's usually a case of not having old-time in the dependency list for the package.
08:14:38 <quicksilver> @losers
08:14:39 <lambdabot> Maximum users seen in #haskell: 465, currently: 440 (94.6%), active: 25 (5.7%)
08:14:39 <ehird`_> heh
08:14:41 <Japsu> @botstab
08:14:41 <lambdabot> Unknown command, try @list
08:14:44 <Japsu> :<
08:14:44 <ehird`_> well, lambdabot's definitino isn't pred
08:14:46 <Cale> penpen: Open up the .cabal file
08:14:46 <ehird`_> but it looks like it
08:14:51 <ehird`_> f a _ b = a (\ c d -> d (c b)) (\ e -> e) (\ f -> f
08:14:52 <ehird`_> vs
08:14:56 <ehird`_> pred n f x = n (\g h -> h (g f)) (\u -> x) (\u -> u)
08:15:04 <Japsu> @botschmuck
08:15:04 <lambdabot> Unknown command, try @list
08:15:05 <Cale> penpen: and add it to the list of deps
08:15:06 <faxathisia> @snotsnack
08:15:06 <lambdabot> :)
08:15:11 <ehird`_> hm
08:15:13 <ehird`_> 'pred two'
08:15:14 <Japsu> @rotsnack
08:15:15 <lambdabot> :)
08:15:15 <ehird`_> does not actually work.
08:15:16 <ehird`_> :-|
08:15:37 <ehird`_> @djinn (((t -> t2) -> (t2 -> t3) -> t3) -> (t4 -> t1) -> (t5 -> t5) -> t6)            -> t             -> t1             -> t6
08:15:38 <lambdabot> f a b c = a (\ d e -> e (d b)) (\ _ -> c) (\ f -> f)
08:16:06 <ehird`_> heh
08:16:10 <ehird`_> lambdabot did it!
08:16:13 <ehird`_> it produced pred.
08:17:01 <ehird`_> @djinn ((a -> a) -> a -> a) -> (a -> a) -> a -> a
08:17:01 <lambdabot> f a = a
08:17:30 <quicksilver> yes, you need to give it a hint by using a type which is more polymorphic
08:17:39 <quicksilver> then it can do it
08:18:54 <ehird`_> @djinn ((t1 -> t2) -> t -> t1) -> (t1 -> t2) -> t -> t2
08:18:54 <lambdabot> f a b c = b (a b c)
08:19:03 <ehird`_> quicksilver: my source file has no type sig for 'pred', just because it's so long and useless
08:19:04 <ehird`_> :P
08:19:12 <ehird`_> & there's no way to make it more specific than the inferred type
08:19:21 <ehird`_> also, well done lambdabot
08:20:47 <ehird`_> i'm going to hell
08:20:53 <ehird`_> i just used an (n+k) pattern for the hell of it
08:20:55 <ehird`_> church (n+1) = succ (church n)
08:21:03 <faxathisia> I like n+k patterns
08:21:10 <ehird`_> faxathisia: i don't
08:21:12 <shapr> Haskell separates Church and state!
08:21:20 <faxathisia> lol
08:21:28 <quicksilver> @remember shapr Haskell separates Church and state!
08:21:28 <lambdabot> I will never forget.
08:21:39 <faxathisia> well I don't really
08:21:45 <faxathisia> I would if they were k+n patterns
08:21:52 <ehird`_> shapr: i love you
08:22:02 <roconnor> people often complain that sometime they get type error when there is no error, but does anyone have an example?
08:22:12 <shapr> ehird`_: I love you too man... can I get another beer?
08:22:15 <Twey> ehird`_: (n+k) patterns are good.  (n+k) patterns love you.  (n+k) patterns are your friends...
08:22:20 <roconnor> whenever I have a type error, it is a real error.
08:22:29 <ehird`_> Twey: DIE HERETIC
08:22:34 <Twey> Hehe
08:22:40 <Twey> I quite like them.
08:22:54 <Twey> They'd be even cooler if numbers really were defined iteratively.
08:23:08 <ehird`_> they're so specific, and the only trivial usecases they have can be replaced with simple subtractions in the body
08:23:22 <ehird`_> if we could doo:
08:23:27 <ehird`_> foo x (y+x) = ...
08:23:30 <ehird`_> that would be cool
08:23:38 <faxathisia> roconnor, I think there's one example use of coerce in LogicT PromptTR.hs
08:23:41 <ehird`_> also, wow ... ghc uses 100% cpu and doesn't halt when compiling this
08:23:45 <ehird`_> have i got a non-terminating type?!
08:24:18 <roconnor> faxathisia: wow!
08:24:33 <penpen> bbl
08:24:51 <faxathisia> I mean to avert a type error, they use that .. so it's sort of an example of what you soid
08:25:54 <roconnor> faxathisia: that's a pretty good example.
08:26:04 <faxathisia> oh ok, I was worried I misunderstood you :)
08:26:15 <hpaste>  ehird pasted "ghc uses 100% cpu on this program and never halts." at http://hpaste.org/5758
08:26:34 <Twey> Hehe, a programming language where you can send the compiler into an infinite loop <3
08:26:40 <roconnor> faxathisia: still, I don't think it occurs as often as people fear. :)
08:26:49 <ehird`_> Twey: don't you love undecidable types?
08:27:01 <ehird`_> you can never tell if the typechecker will terminate! :D
08:27:13 <Twey> Hehehe
08:27:13 <ehird`_> I sent gcc into a near-infinite loop once
08:27:26 <ehird`_> I'd given it a 10,000+ line file (generated by my Underload compiler) and told it to -O3
08:27:31 <roconnor> Twey: GHC has a wont-fix bug that will inline forever in some uses of non-positive datatypes.
08:27:33 <ehird`_> it didn't work.
08:27:44 <Twey> Nice.
08:27:46 <ehird`_> roconnor: is that my problem? :P
08:27:53 <ehird`_> oooh
08:27:55 <ehird`_> hugs halts on it
08:27:56 <ehird`_> :-O
08:27:59 <ehird`_> with a type error
08:28:00 <roconnor> Twey: http://r6.ca/blog/20060919T084800Z.html
08:28:01 <lambdabot> Title: Y Combinator in Haskell
08:28:12 <wli> What's a non-positive data type?
08:28:27 <ac> concat [[(x-dx,y-dy), (x-dy,y-dx)] | dy <- [b,-b], dx <- [a,-a]]
08:28:43 <ehird`_> roconnor: that's not Y, to be pedantic
08:28:48 <ehird`_> Y is one single lambda expression and nothing else
08:29:40 <roconnor> wli: I sort of shorted my phrase.  I mean a data constructor without a strictly postive recursive occureance.
08:29:50 <ehird`_> *** Expression    : dechurch
08:29:50 <roconnor> ehird`_: how is what i have not Y.
08:29:50 <ehird`_> *** Expected type : ((a -> a) -> a -> a) -> Integer
08:29:51 <ehird`_> *** Inferred type : ((((a -> a) -> a) -> (a -> a) -> a) -> ((a -> a) -> a) -> (a -> a) -> a) -> Integer
08:30:04 <ehird`_> roconnor: it's not (\x -> f (x x)) (\x -> f (x x))
08:30:05 <roconnor> ehird`_: Roll and unroll are no-ops
08:30:15 <roconnor> ehird`_: they are part of newtype.
08:30:49 <roconnor> wli: Roll has type (Mu a -> a) -> Mu a
08:31:04 <roconnor> wli: so the first occurence of (Mu a) is the recursive use
08:31:36 <roconnor> wli: and this occurence is not strictly postive because it occurss in the negative part of the type ``(Mu a) -> a''
08:31:40 <ac> quicksilver: that does the trick
08:31:42 <roconnor> wli: where the negative part is the stuff before the ->
08:32:37 <roconnor> ehird`_: so when you filter out the Roll and unroll (which is what the complier does), you get  (\x -> f (x x)) (\x -> f (x x))
08:33:20 <ehird`_> question... does any fixedpoint combinator typecheck without these hoops?
08:33:44 <ehird`_> but anyway
08:33:45 <roconnor> ehird`_: nope
08:33:56 <ehird`_> my hpaste kills ghc, whereas hugs does the right thing and gives a type error
08:33:59 <ehird`_> i do believe this is a bug
08:34:07 <ehird`_> it just doesn't compile.
08:34:09 <ehird`_> sits there, 100% cpu
08:34:34 <roconnor> ehird`_: oh right, you actual problem
08:34:38 <roconnor> your
08:34:48 <ehird`_> (i know my dechurch/church is wrong, because it pattern matches on a function)
08:34:54 <ehird`_> (but bear with me, it's still a bug)
08:36:03 <roconnor> ehird`_: how are you compiling and what is your version of ghc?
08:36:41 <roconnor> ehird`_: BTW, you won't be able to go very far with your church numbers because of the type system.
08:37:46 <ehird`_> roconnor: compiling with ghci or ghc, and 6.8.2
08:37:51 <ehird`_> and indeed i can see that
08:37:55 <ehird`_> I will wrap it in a newtype, for 'show'
08:39:23 <quicksilver> ehird`_: it didn't compile for me.
08:39:30 <quicksilver> ehird`_: what extensions did you use to compile it?
08:39:41 <ehird`_> quicksilver: none.
08:39:44 <ehird`_> but it sure inflooped.
08:39:58 <roconnor> ehird`_: I get a type error in dechurch in ghc 6.6.1
08:39:59 <quicksilver> test.hs:20:35:
08:39:59 <quicksilver>     Couldn't match expected type `(a -> a) -> t'
08:39:59 <quicksilver>            against inferred type `a1' (a rigid variable)
08:40:41 <roconnor> quicksilver: what version are you using
08:40:45 <quicksilver> 6.6.1
08:40:48 <quicksilver> I guess it's a 6.8 bug
08:40:58 <doserj> 6.8.2 loops here
08:41:14 <roconnor> bug report time.
08:41:42 <roconnor> new unit test time too
08:45:52 <ehird`_> someone explain to faxathisia that Y is not 'y f = f (y f)'
08:46:00 <faxathisia> hahaha
08:46:30 <ehird`_> he insists that it is, even though y is a combinator and doesn't look anything like that anyway..
08:46:35 <ehird`_> i think he's confused 'y' and 'fixed points'
08:47:31 <Stinger> is that equiv to fix?
08:47:50 <faxathisia> Yeah, it's basically the same as fix
08:47:53 <faxathisia> @src
08:47:53 <lambdabot> src <id>. Display the implementation of a standard function
08:47:56 <faxathisia> @src fix
08:47:56 <lambdabot> fix f = let x = f x in x
08:48:04 <faxathisia> they use another let though
08:48:14 <quicksilver> more sharing
08:48:18 <quicksilver> denotationally the same though
08:48:23 <ehird`_> yes
08:48:25 <ehird`_> but it is NOT the y combinator
08:48:28 <ehird`_> it is a fixed point function
08:48:31 <ehird`_> but 1. it isn't a combinator
08:48:33 <EvilTerran> calm down, dear
08:48:35 <ehird`_> 2. it isn't y if it was a combinator
08:48:50 <quicksilver> it's not Y, I agree.
08:48:54 <quicksilver> But why isn't it a combinator?
08:49:09 <resiak> So, idle question: why is the y-combinator the most popular fpc, given that y f doesn't beta-reduce to f (y f) and other relatively simple combinators which do exist?
08:49:33 <faxathisia> resiak: Well you can uses Y in an eager language
08:49:48 <faxathisia> resiak: and you can write it without recursion, and it's simple to derive
08:49:49 <ehird`_> quicksilver: 'fix f = f (fix f)' <-- 'fix' is not an argument here
08:50:01 <quicksilver> ehird`_: oh, I see what you mean. Yes.
08:50:06 <ehird`_> right.
08:50:13 <ehird`_> well then faxathisia -- that is not a combinator, and it's not Y.
08:50:21 <Tobsan> @src unsafePerformIO
08:50:22 <ais523> resiak: I think because it does almost beta-reduce
08:50:22 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
08:50:32 <ehird`_> Tobsan: DON'T LOOK!
08:50:34 <ais523> it would beta-reduce if beta-reduction understood scoping...
08:50:39 <faxathisia> :t lazy
08:50:39 <r_rehashed> hello everybody :)
08:50:41 <lambdabot> Not in scope: `lazy'
08:50:42 <Tobsan> ehird`_: yeah i know :P
08:50:45 <faxathisia> Hi r_rehashed
08:50:53 <quicksilver> you can use 'fix' in an eager language too
08:51:07 <ais523> you have to define it a different way, though
08:51:18 <faxathisia> ehird`: ok,  you've convinced me
08:51:22 <igel> @instances Float
08:51:23 <lambdabot> Couldn't find class `Float'. Try @instances-importing
08:51:56 <ehird`_> @pl fixy f = f x where x = (\y -> fixy f y)
08:51:56 <lambdabot> (line 1, column 22):
08:51:56 <lambdabot> unexpected "="
08:51:56 <lambdabot> expecting variable, "(", operator or end of input
08:51:59 <ehird`_> haha
08:52:07 <ehird`_> @pl fixy f = let x = (\y -> fixy f y) in f x
08:52:07 <lambdabot> fixy = fix (ap id)
08:52:16 <ehird`_> @pl fix (ap id)
08:52:17 <lambdabot> fix (ap id)
08:52:31 <ehird`_> @t fix (ap id)
08:52:31 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:52:34 <ehird`_> @type fix (ap id)
08:52:35 <lambdabot> forall b. (b -> b) -> b
08:52:47 <EvilTerran> ?type ap id
08:52:48 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
08:52:53 <gnuvince> I've read many books on programming and on many languages, but I don't think that any book has ever stretch my mind as much as the Function Parsers chapter in Graham Hutton's book
08:53:02 <EvilTerran> @unpl fix (ap id)
08:53:03 <lambdabot> fix (\ f -> (\ a -> a) >>= \ c -> f >>= \ b -> return (c b))
08:53:55 <resiak> faxathisia: ah, good point
08:54:47 <quicksilver> gnuvince: good, I think :)
08:55:26 <gnuvince> quicksilver: definitely good :)
08:56:04 <gnuvince> More experienced programmers should have their mind stretched like that once in a while.
08:56:27 <gnuvince> (not to imply that I am experienced)
08:57:11 <esap> for real mind stretching, read "Lawvere: Sets for Mathematics"
08:58:34 <hpaste>  ehird pasted "well, it's closer to typing." at http://hpaste.org/5759
09:08:20 <penpen> re
09:09:32 <byorgey> hi penpen
09:09:58 <byorgey> did you resolve your problem with building HDBC?
09:10:09 <penpen> part of
09:10:51 <penpen> Currently facing this: http://pen2.homeunix.net/~jupp/buildlog.txt
09:12:02 <sjw> I guess String is declared as [Char]
09:12:12 <faxathisia> @src String
09:12:12 <lambdabot> type String = [Char]
09:12:27 <sjw> so instance SqlType [Char] is what you want
09:12:48 <byorgey> penpen: what version of ghc are you using?
09:12:56 <quicksilver> or -XTypeSynonymInstances
09:13:01 <quicksilver> as the error suggests :)
09:13:27 <penpen> ghc --version
09:13:29 <penpen> The Glorious Glasgow Haskell Compilation System, version 6.8.2
09:13:44 <byorgey> penpen: probably adding {-# LANGUAGE TypeSynonymInstances #-} to the top of that .hs file would be the way to go
09:13:58 <byorgey> I'm guessing you're the first person trying to build HDBC with 6.8.2 (?)
09:14:14 <penpen> Maybe :)
09:15:16 <penpen> As mentioned: I'm a rookie
09:16:07 <byorgey> penpen: nothing wrong with that =)
09:16:41 <penpen> But a productive source of stupid questions :)
09:18:04 <penpen> that far that good, installed. Next dependency :)
09:18:58 <byorgey> penpen: in my experience, rookies are productive sources of excellent questions.
09:19:19 <byorgey> penpen: it's the rookies who have to write some assignment for class and don't want to do any work who are the sources of stupid questions. =)
09:21:18 <droundy> JaffaCake: Are you here?
09:23:05 <Cale> esap: Sets for mathematics has a really strange version of set theory in it. :) I'm not entirely convinced that it's equivalent to ZFC, though it's clearly rich enough to do most of mathematics in.
09:24:17 <esap> Cale: I'm sure it doesn't intend to be equivalent to ZFC.
09:24:42 <penpen> Okay, now http://pen2.homeunix.net/~jupp/buildlog.txt was easy to solve by adding {-# LANGUAGE EmptyDataDecls #-} to the first line.
09:25:06 <esap> Cale: But it's very beautiful conceptual structure.
09:25:29 <droundy> Does anyone here have much experience with System.Process?
09:25:46 <penpen> Just to face http://pen2.homeunix.net/~jupp/buildlog1.txt
09:25:46 <esap> Cale: I think it's more like what ZFC should be than a presentation of ZFC.
09:25:59 <Cale> hmm
09:26:03 <penpen> Doh! ^^
09:27:13 <Cale> penpen: odd... line 73 is a little late in the file to be importing something, you might want to check that there's no function declarations or anything before it.
09:27:23 <penpen> Just to face http://pen2.homeunix.net/~jupp/Utils.hsc
09:28:03 <ehird`_> instance Show Zero where show = const "0"
09:28:03 <ehird`_> instance (Show a) => Show (Succ a) where
09:28:03 <ehird`_>     show = const ("S" ++ show (undefined :: a))
09:28:04 <Cale> ...
09:28:06 <ehird`_> why doesn't that work?
09:28:14 <ehird`_> (type-level peanos)
09:28:16 <Cale> Who uses #include in Haskell? Oy.
09:28:42 <Cale> oh, this is a .hsc
09:28:46 <Cale> heh
09:29:12 <mrd> oy vey
09:29:25 <Saizan> ehird`_: what error do you get?
09:29:35 <ehird`_> /home/ehird/calc.hs:13:20:
09:29:35 <ehird`_>     Ambiguous type variable `a' in the constraint:
09:29:37 <ehird`_>       `Show a'
09:29:39 <ehird`_>         arising from a use of `show' at /home/ehird/calc.hs:13:20-33
09:29:40 <Cale> penpen: You might want to look at the output of hsc2hs -- is there a generated .hs file?
09:29:41 <ehird`_>     Probable fix: add a type signature that fixes these type variable(s)
09:29:43 <ehird`_> that
09:30:02 <Saizan> ehird`_: you need ScopedTypeVariables, probably
09:30:10 <ehird`_> Saizan: d'aww
09:30:14 <ehird`_> i'm trying to do this with no extensions
09:30:58 <Saizan> ehird`_: then pred :: S x -> x; pred = undefined, then show x =  "S" ++ show (pred x)
09:31:16 <esap> Cale: The difference between ZFC and "Category of abstract sets and mappings" start from the definition of a category. Even though ZFC describes sets, it has less emphasis on mappings. And for example, partitions are presented in quite different way.
09:31:38 <ehird`_> Saizan: ahh, I do already have pred!
09:31:39 <ehird`_> good point
09:32:27 <esap> Cale: though maybe the concepts are close. But even thinking of set-theoretical definition of partition as a surjective mapping is not usual.
09:32:59 <ehird`_> *Main> undefined :: Succ (Succ Zero)
09:33:00 <ehird`_> SS0
09:33:39 <byorgey> ehird`_: nice =)
09:33:46 <ehird`_> byorgey: yep
09:33:48 <ehird`_> you can even do:
09:33:59 <ehird`_> succ (succ (undefined :: Zero))
09:34:00 <ehird`_> and have that work
09:34:02 <byorgey> reifying types as values like that always seems so magical to me =)
09:34:03 <esap> Cale: From category theory point of view, set theory is too concrete :-)
09:34:06 <ehird`_> and i don't use any empty constructor stuff...
09:34:09 <byorgey> even though I understand exactly how it works
09:34:12 <ehird`_> I give them 'IgnoreMe' and 'IgnoreMeToo'
09:34:22 <ehird`_> so hopefully this should be haskell 98 when i'm done
09:35:40 <Cale> esap: Well, using a surjective mapping is probably how I'd do it, really. Alternately, a partition of a set U is a set of subsets of U whose union is U, and whose pairwise intersections are disjoint.
09:35:46 <Cale> er are empty, rather
09:35:48 <Saizan> ehird`_: empty data decls are emulated as in data Void = Void !Void in h98, so in this case you know there's no non-bottom value for Void, but i know it doesn't ass much :)
09:36:17 <ehird`_> Saizan: that doesn't work
09:36:19 <ehird`_> well
09:36:20 <ehird`_> wait
09:36:21 <Eelis> ehird`_: i use Network.IRC for a bot (geordi). i agree it's not perfect, but i do like its modesty; i'm very skeptical of your "handle pretty much everything" approach. also Network.IRC also uses Parsec, so that's not a selling point for a competitor :)
09:36:43 <ehird`_> Saizan: uh
09:36:49 <ehird`_> IgnoreMe (undefined :: Zero)
09:36:49 <ehird`_> works
09:37:29 <esap> Cale: But Sets for mathematics distinguishes between "set of subsets" (the fibers) and a partition (the surjective mapping).
09:37:54 <faxathisia> esap, is there a proof of induction in the book?
09:38:11 <Cale> esap: Right. They're the "same thing" only in an informal sense.
09:38:33 <Cale> (even in ordinary set theory, they're pretty different)
09:39:01 <esap> faxathisia: yes. In section 9.2 ("Introduction to variable sets")
09:39:33 <ais523> @pf two x = x.x
09:39:33 <lambdabot> Maybe you meant: bf pl
09:39:52 <ais523> @pl two x = x.x
09:39:52 <lambdabot> two = join (.)
09:40:02 <ais523> @src join
09:40:02 <lambdabot> join x =  x >>= id
09:40:20 <jwe_uu> @version
09:40:20 <lambdabot> lambdabot 4p590, GHC 6.8.2 (Linux i686 2.40GHz)
09:40:20 <lambdabot> darcs get http://code.haskell.org/lambdabot
09:41:14 <jwe_uu> hi, yesterday is was told to query the lambda bot with \query lambdabot, this opens a private chat with the bot, but it doesn't respond, i am registerd at NickServ
09:41:22 <jwe_uu> does anyone know what to do?
09:41:29 <Saizan> ehird`_: do you have data Zero = IgnoreMe !Zero? then IgnoreMe undefined == undefined
09:41:42 <ehird`_> Saizan: let foo = IgnoreMe foo in foo
09:41:44 <esap> Cale: I've seen many set theory books which only describe the fibers, and don't at all mention that there would be a surjective mapping. Many set theory books do prove the connection between partitions and equivalence relations though.
09:41:57 <jedbrown> jwe_uu: You can give commands with @ and evaluate expressions with >
09:42:04 <jedbrown> @yow
09:42:05 <lambdabot> I am NOT a nut....
09:42:09 <Saizan> ehird`_: so?
09:42:20 <byorgey> @whois jwe_uu
09:42:20 <jedbrown> > fix ((0:) . scanl (+) 1)
09:42:20 <lambdabot> Unknown command, try @list
09:42:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:42:27 <byorgey> err, oops
09:42:39 <jedbrown> jwe_uu: working now?
09:42:53 <byorgey> jwe_uu: yes, you appear to be registered and identified, so I'm not sure why lambdabot wouldn't respond
09:43:34 <jwe_uu> ah great, that is the trick, they didn't told me that part :P
09:43:39 <jwe_uu> thank you!
09:44:17 <Saizan> ehird`_: try let foo = IgnoreMe foo in foo `seq` ()
09:44:19 <ehird`_> with single-param type-classes
09:44:29 <ehird`_> how do i fake multiple?
09:46:49 <faxathisia> http://www.rubrication.net/2008/02/09/verifying-the-monad-laws-with-supercompilation/
09:46:50 <faxathisia> wow..
09:46:53 <lambdabot> Title: Rubrication » Verifying the Monad Laws with Supercompilation, http://tinyurl.com/2dx7gl
09:47:26 <ehird`_> anyone?
09:48:32 <quicksilver> newtype TypePair a b = TypePair a b
09:48:43 <quicksilver> instance BinaryClass (TypePair blah blah)
09:48:45 <quicksilver> perhaps
09:49:27 <ehird`_> quicksilver: at compile-time
09:49:44 <quicksilver> that was compile time
09:49:50 <quicksilver> there remain things you can't do, though.
09:50:00 <quicksilver> I"m not sure it's a very useful trick
09:50:02 <davidL> join #xmonad
09:50:10 <davidL> oops
09:50:26 <ehird`_> quicksilver: also, itym data
09:51:04 -kbase101(n=l@195-23-238-184.nr.ip.pt)- can you help my amputee young brother by clicking on the link? http://blog-kbase101.notlong.com
09:51:05 <ehird`_> someone kill kbase101
09:51:16 --- mode: ChanServ set +o quicksilver
09:51:17 <ehird`_> spammers
09:51:18 <ehird`_> :|
09:51:19 <Mortomes> He's doing this on #python too.
09:51:21 --- mode: ChanServ set +o bos
09:51:23 <ehird`_> or better...
09:51:25 --- kick: kbase101 was kicked by quicksilver (quicksilver)
09:51:27 <Mortomes> double kill
09:51:30 <ehird`_> amputate him! :p
09:51:42 <ehird`_> what is the link, btw
09:51:54 --- mode: bos set -o bos
09:51:56 <quicksilver> most likely malware
09:52:04 --- mode: quicksilver set -o quicksilver
09:52:23 <quicksilver> and of course kicking them after they post the link isn't all that useful :(
09:52:30 <quicksilver> they've done what they came to do
09:52:51 <ricky_clarkson> But think of the amputee.
09:54:54 <Mortomes> Hah, the guy has been k-lined
09:55:53 * quicksilver nods
09:55:55 <quicksilver> normally happens
09:56:29 <quicksilver> I suspect the ircops notice when someone gets kicked from multiple channels
09:56:50 <Mortomes> Well, looking at all the channels he was in, they probably noticed it directly too.
09:58:44 * quicksilver blinks at ehird's quit message :P
10:02:34 <eugman|work> Is "   isNothing (listToMaybe x) " a reasonable way to check if a list x is empty?
10:02:54 <Lemmih> eugman|work: 'null' is better, I'd say.
10:04:13 <eugman|work> I figured there was a better way
10:04:21 * Botje turns eugman|work into a Bool
10:04:46 <paczesiowa> can I hide infix constructor (cons) during importing?
10:05:16 <eugman|work> don't do it!
10:05:32 <paczesiowa> why?
10:05:34 <quicksilver> paczesiowa: yes
10:06:00 <paczesiowa> quicksilver: import Prelude hiding ((:)) and import Prelude hiding (:) don't parse
10:06:09 <quicksilver> really
10:06:09 <quicksilver> hmm
10:06:18 <quicksilver> I think that's because (:) is magic
10:06:52 <quicksilver> I think it would work with a normal infix constructor
10:06:52 <paczesiowa> :: doesn't parse either
10:07:08 <paczesiowa> hmm, :: doesn't parse, but :-> does
10:07:17 <paczesiowa> bug or feature?
10:07:50 <eugman|work> hahah my client is turning your code into smilies
10:07:58 <paczesiowa> :)
10:08:18 <paczesiowa> :t (:)
10:08:18 <lambdabot> forall a. a -> [a] -> [a]
10:08:32 <allbery_b> @quote eat.a.comment
10:08:32 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
10:10:21 <hpaste>  eugman pasted "electronic parrot" at http://hpaste.org/5760
10:10:51 <paczesiowa> ok, (:), (::) don't work, (:::) does work
10:10:54 <roconnor> @type fromMaybe
10:10:55 <lambdabot> forall a. a -> Maybe a -> a
10:11:22 <Cale> eugman|work: that's an evil layout for if/then/else :)
10:11:35 <roconnor> @type maybe
10:11:36 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:12:35 <idnar> @src listToMaybe
10:12:35 <lambdabot> listToMaybe []        =  Nothing
10:12:35 <lambdabot> listToMaybe (a:_)     =  Just a
10:12:58 <eugman|work> Cale, Yeah that's why I pasted it. I finally got something working in haskell and wanted to see what might be improper with the program if anything
10:13:09 <gnuvince> @src fromJust
10:13:09 <lambdabot> fromJust Nothing  = undefined
10:13:09 <lambdabot> fromJust (Just x) = x
10:13:13 <gnuvince> neat
10:13:45 <Cale> eugman|work: It's more usual to align the then and else, and indent them a little further than the if
10:13:46 <paczesiowa> @src (<)
10:13:46 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
10:14:10 <paczesiowa> how do I ask lambdabot about operator's fixity and precedence?
10:14:22 <Cale> You'll occasionally run into strange problems with layout, especially in do-blocks, if you don't follow that guideline.
10:14:36 <Cale> paczesiowa: I'm not sure you can.
10:14:44 <Cale> paczesiowa: But in ghci, you can use :info
10:14:52 <paczesiowa> Cale: thx
10:14:59 <eugman|work> Is the code good for that simple task?
10:15:10 <Cale> eugman|work: sure.
10:15:19 <Cale> eugman|work: apart from the layout, it's fine :)
10:15:49 <eugman|work> Awesome, it's nice to have actually gotten something working
10:15:55 <byorgey> there is a sneaky way into tricking lambdabot into printing the precedence of operators in an error message.
10:15:59 <byorgey> I don't remember what it is though.
10:16:09 * penpen is still wondering what the parse error is about 8-|
10:16:09 <paczesiowa> @google infixl
10:16:10 <lambdabot> No Result Found.
10:16:22 <paczesiowa> Did you mean: infidel
10:16:31 <Cale> paczesiowa: hahaha
10:16:33 <Mortomes> hahaha
10:16:38 <newsham> > unfoldr (\x -> guard (x > 0) >> return (chr (fromIntegral (x `mod` 127)), x `div` 127)) 243390470606108357410401970529
10:16:39 <lambdabot>  "Hello #haskell"
10:16:45 <byorgey> penpen: have you pasted the code somewhere?
10:17:10 <ojacobson> @type guard
10:17:11 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:17:20 <Cale> > x < y < z
10:17:21 <lambdabot>      precedence parsing error
10:17:21 <lambdabot>         cannot mix `(<)' [infix 4] and `(<)' [i...
10:17:23 <Cale> hehe
10:17:37 <byorgey> ah, that's it =)
10:18:19 <quicksilver> paczesiowa: well :: is reserved for (10 :: Int)
10:18:25 <quicksilver> paczesiowa: and : is reserved for lists
10:18:32 <hpaste>  Cale pasted "example of unless" at http://hpaste.org/5761
10:18:35 <quicksilver> there is no good reason for : to be special syntax.
10:18:40 <quicksilver> it's stupid.
10:19:00 <Cale> quicksilver: are you sure?
10:19:13 <Cale> hmm
10:19:30 <penpen> see http://pen2.homeunix.net/~jupp/buildlog1.txt for the error message http://pen2.homeunix.net/~jupp/Utils.hs for the source
10:19:43 <bparkis> just out of curiousity, are there any purely functional languages that AREN'T statically typed?
10:19:47 <quicksilver> Cale: am I sure it is special? or am I sure there is no good reason?
10:19:57 <byorgey> > unfoldr (\x -> guard (x > 0) >> return (chr (fromIntegral (x `mod` 127)), x `div` 127)) 1932544218829226132474239923
10:19:57 <lambdabot>  "Hello newsham"
10:20:06 <Cale> penpen: oh, hey, is -XForeignFunctionInterface on?
10:20:10 <Cale> quicksilver: the latter
10:20:30 <quicksilver> Cale: hard to be sure. I can't think of a good reason, though :)
10:20:38 <Cale> quicksilver: There might be parsing reasons why (:) has to be treated specially by the syntax.
10:21:00 <quicksilver> Cale: don't see why.
10:21:01 <Cale> I'm not entirely certain what those would be :)
10:21:15 <Cale> But parsing problems are generally pretty unintuitive :)
10:21:23 <jedbrown> It is handy that operators starting with : are constructors.
10:21:54 <penpen> Cale: Prepending file with "{-# ForeignFunctionInterface #-}" changes nothing
10:21:56 <ehird`> i don't think a pure&dynamic comb is possible
10:22:09 <Cale> {-# LANGUAGE ForeignFunctionInterface #-}
10:22:14 <penpen> oops
10:22:21 <Cale> ehird`: hm?
10:22:41 <ehird`> Cale: see bparkis' question
10:22:48 <Cale> ehird`: You don't think that there's a pure dynamically-typed language?
10:22:56 <Cale> Why shouldn't there be?
10:22:58 <ehird`> well, not an IO-capable one
10:23:07 <Cale> You could use monadic IO.
10:23:22 <Cale> Of course, the monad abstraction itself might have to go.
10:23:30 <Cale> But the same combinator library would be possible.
10:24:00 <penpen> Hmm, seems to be not the only file that requires this :)
10:24:09 <Cale> penpen: edit the .cabal
10:24:38 <newsham> > unfoldr (\x -> guard (x > 0) >> return (chr (fromIntegral (x `mod` 91)), x `div` 91)) 0x93460b89b17b8ba3e27c56b6e7c4a1e3706218f683b4
10:24:48 <lambdabot>  "HOW ARE YOU DOING, BYORGEY?"
10:25:46 <Cale> penpen: If there's no Extensions: ... field, just add one.
10:25:56 <Cale> penpen: Though, that's rather surprising :)
10:26:02 <penpen> Oh my God! â it's full of bugs!
10:26:04 <penpen> :)
10:26:43 <penpen> feels like learning to use Haskell the hard way :)
10:26:44 <Cale> ehird`: I've thought for quite a while that a pure scheme would be pretty cool.
10:26:56 <Cale> penpen: What are you working on?
10:27:16 <hpaste>  Paczesiowa pasted "ternary (?:)" at http://hpaste.org/5762
10:27:26 <dons> hmm. lots of new phd studentships available
10:27:28 <penpen> Trying to get http://software.complete.org/hpodder running...
10:27:28 <lambdabot> Title: hpodder
10:28:55 <penpen> Not the first Haskell program I installed but that one seems to be a bit recalcitrant
10:30:16 <penpen> After adding even more Extensions to the .cabal file HDBC-sqlite3 finally is through :)
10:30:54 <BMeph> penpen: Quick, upload it to Hackage before gwern gets it! ;)
10:31:00 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hpodder-1.1.2 -- is this the version you have?
10:31:01 <lambdabot> http://tinyurl.com/3yl9oy
10:31:03 <sclv> penpen: are you using the latest darc version?
10:31:09 <sclv> s/darc/darcs/
10:31:19 <penpen> not yet
10:31:28 <penpen> I first need all the prerequisites
10:31:34 <penpen> and that are quite a number :)
10:31:44 <Cale> Are you using cabal-install?
10:31:50 <Cale> (I recommend it)
10:32:09 <sclv> penpen: I didn't mean darcs itself, sorry. I meant are you using the hpodder version from the repo?
10:32:32 <byorgey> ... or no.
10:32:36 * BMeph hopes that darcs gets a GUI by 2.2 - called "the darcs IDE"
10:32:49 * byorgey kicks irssi with a steel-toed boot
10:33:28 <sclv> usually when I have build problems with packages from hackage, I check if the devel repo has a more recent version, because not everything is updated to work properly with 6.8 and the base split yet.
10:33:35 <sclv> that seems like what's causing your problem.
10:33:58 <penpen> I first need to go through http://pen2.homeunix.net/~jupp/prerequisites.txt before deciding which version to install
10:34:39 * Cale watches cabal-install get all the dependencies for him.
10:35:47 <Cale> Okay, to be fair, it's bombed twice. Once was because I didn't have the sqlite devel headers installed, and once was for no good reason (some file locking nonsense), but other than that it's going okay :)
10:36:03 <Cale> (just restarting it worked in the second case)
10:36:39 <Cale> gwern's obsession with -Wall makes installs from hackage really noisy
10:37:13 <daf> gwern should develop an obsession with -Werror
10:37:19 <dcoutts> nooo!
10:37:20 <daf> they would be much quieter then
10:37:55 <sclv> on the other hand, to be fair, the world would probably be a better place if we all coded for a clean -Wall
10:37:55 <matthew-_> -Wall isn't really sensible without a few -fno-...
10:37:55 <dcoutts> there are a couple packages on hackage that use -Werror
10:37:55 <dcoutts> which is really going to break
10:37:55 <matthew-_> where's NickServ ?
10:38:02 <dcoutts> hackage now rejects such combinations, as well as lots of other silly ghc-options
10:38:17 <sclv> right, and granted, a few -fno- where appropriate.
10:38:29 <matthew-_> sclv: name shadowing and orphan instances should be allowed
10:38:48 <dcoutts> sclv: that's a metric we ought to be able to compute, the volume of -Wall warnings for all hackage packages
10:39:00 <dcoutts> categorised by kind
10:39:34 <sclv> matthew-_: well, name shadowing can usually be easily fixed. orphan instances are often good to know about, however.
10:39:44 <sclv> (although, not always)
10:41:13 <ehird`> with just haskell 98 is it possible to define 'plus' for compile-time peanos?
10:41:15 --- mode: irc.freenode.net set +o ChanServ
10:41:18 <sclv> I would be inclined to consider name shadowing a potential bug in almost all cases, along with "declared but not used" errors.
10:41:42 <paczesiowa> > let (:) a b = b in 1:[]
10:41:57 <lambdabot>  thread killed
10:42:31 <paczesiowa> > let (***) a b = b in 1***[]
10:42:31 <lambdabot>  []
10:42:47 <paczesiowa> bug?
10:42:59 <kaol> > let (:) a b = b in [1,2,3]
10:43:00 <sclv> > let (:) a b = b in 1:[]
10:43:00 <lambdabot>  [1,2,3]
10:43:02 <lambdabot>  [1]
10:43:21 <paczesiowa> > let (:) a b = b in 1:[]
10:43:22 <lambdabot>  [1]
10:43:45 <paczesiowa> I guess lambdabot didn't feel like it back then
10:44:07 <monochrom> heh
10:44:24 <paczesiowa> anyway why can I redefine (:) but it doesn't work?
10:45:03 <monochrom> I'm afraid it is not re-defining. It is pattern matching.
10:45:37 <paczesiowa> > let (a:b) = b in 1:[]
10:45:38 <lambdabot>  [1]
10:45:44 <monochrom> let (x,y) = (1,2) in [x,y]
10:45:47 <monochrom> > let (x,y) = (1,2) in [x,y]
10:45:48 <lambdabot>  [1,2]
10:46:00 <paczesiowa> monochrom: thx
10:46:20 <paczesiowa> > let (:) a b = b in b
10:46:21 <lambdabot>  Exception: <<loop>>
10:46:24 <paczesiowa> weeeee
10:46:36 <ehird`> > let (:) a b = b in 1:2
10:46:37 <lambdabot>   add an instance declaration for (Num [t])
10:46:41 <ehird`> > let (:) a b = b in 1:[2]
10:46:42 <lambdabot>  [1,2]
10:46:46 <ehird`> > let (:) a b = b in (:) 1 [2]
10:46:48 <lambdabot>  [1,2]
10:46:49 <ehird`> ooh
10:46:51 <ehird`> that's bad
10:46:55 <sclv> > let (:) 1 2 = b in b
10:46:56 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Expr'
10:47:02 <sclv> > let (:) 1 [] = b in b
10:47:02 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Expr'
10:47:15 <sclv> ?ty let (:) 1 [] = b in b
10:47:18 <lambdabot> Not in scope: `b'
10:47:18 <lambdabot> Not in scope: `b'
10:47:43 <sclv> > let (:) a b = [1,2] in b
10:47:44 <lambdabot>  [2]
10:47:47 <sclv> there we go.
10:48:11 <Stinger> > let (:) = flip . const  in 1 : 2
10:48:11 <lambdabot>   add an instance declaration for (Num [t])
10:50:26 <Taejo> if I want to publish a darcs repo, do I just copy the whole repo onto a server?
10:50:27 <Stinger> @ty let (:) = flip . const  in 1 : 2
10:50:27 <lambdabot>     Constructor `:' should have 2 arguments, but has been given 0
10:50:27 <lambdabot>     In the pattern: :
10:50:27 <lambdabot>     In a pattern binding: : = flip . const
10:50:39 <paczesiowa> :t (|)
10:50:40 <lambdabot> parse error on input `|'
10:50:43 <Deewiant> is constant folding done over strings? i.e. if I do something like 'drop (length "FOO") s' will it call length every time
10:50:52 <Taejo> and is anybody willing to test-compile WordNet on GHC 6.8?
10:50:56 <davidL> is PSU a good school for functional programming?
10:50:56 <Deewiant> or is it turned into 3 at compile time
10:51:32 <mtklein> Is there a generic filter in the same way fmap generalizes map?
10:51:41 <dcoutts> Deewiant: it'll not be 3 as a compile time constant but ghc may well decide to lift it out and share it so it may be computed only once in the enclosing context
10:51:49 <Lemmih> Taejo: Version 0.1.1?
10:52:05 <Taejo> Lemmih: the version on hackage doesn't build
10:52:07 <Deewiant> dcoutts: meh, so it's better to write it out as a constant and put a comment, I guess
10:52:11 <sclv> mtklein what would its signature be?
10:52:14 <Taejo> I've moved to cabal 1.2, and I want to test it
10:52:31 <Philippa> davidL: undergrad or grad?
10:52:42 <dcoutts> Deewiant: I shouldn't bother, if you want to make sure it's only done once then lift it out manually
10:52:45 <davidL> Philippa: undergrad
10:53:21 <Philippa> *nod* - I know there's at least one of their undergrads around sometimes. It ought to be at least reasonable given the people, but that's the most I can offer you myself
10:53:25 <mtklein> sclv: I'm figuring something like (Functor f) => (a -> Bool) -> f a -> f a
10:53:34 <Deewiant> dcoutts: if it's in a relatively tight inner loop I'd want it done at most once for the whole program, ideally not at all (== at compile time)
10:53:50 <dcoutts> Deewiant: you can lift it out of a loop, no probs
10:53:55 <Philippa> you may find out more asking somewhere like haskell-cafe - at least one of the faculty read it, mind
10:54:02 <dcoutts> Deewiant: just put it in a where clause or something
10:54:09 <mtklein> sclv: I'm puzzling over the posibility of implementing it using fmap somehow, but it'd be nice to know if that's already done for me
10:54:24 <byorgey> mtklein: well, I don't think such a thing is possible justusing fmap
10:54:35 <Deewiant> dcoutts: but if it's in a where clause of a function foo, isn't it still calculated once per call to foo
10:54:39 <BMeph> ?src filter
10:54:40 <lambdabot> filter _ []     = []
10:54:40 <lambdabot> filter p (x:xs)
10:54:40 <lambdabot>     | p x       = x : filter p xs
10:54:40 <lambdabot>     | otherwise = filter p xs
10:54:54 <byorgey> mtklein: the problem is that deleting things from a data structure depends on the structure of the data, so it can't be done generically for any functor.
10:55:02 <dcoutts> Deewiant: yes, so if it doesn't depend on the args of the function then you can lift it all the way to a top level value
10:55:10 <mtklein> byorgey: yeah, that's what i figured...
10:55:16 <davidL> Philippa: and PSU referrs to portland state university correct? I've seen people talk about it on here which is why I ask
10:55:29 <byorgey> mtklein: but you could easily make a new type class, something like  class (Functor f) => FilterableFunctor f where ffilter :: (a -> Bool) -> f a -> f a
10:55:33 <Deewiant> dcoutts: alright, thanks
10:55:36 <sclv> ?hoogle filterM
10:55:37 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
10:55:55 <sclv> ?hoogle filterA
10:55:57 <lambdabot> No matches found
10:56:07 <Philippa> davidL: it does, yeah
10:56:21 <byorgey> mtklein: and then define instances for various specific types for which it makes sense (list, Maybe, trees (?),...)
10:56:25 <Philippa> I know one of the grad students there
10:56:41 <mtklein> byorgey: yeah, that makes total sense... i forgot i could do that.  bit of a newbie to haskell...
10:56:48 <davidL> Philippa: there seems to be a lot going on in oregon in terms of FP
10:57:21 <dons> I think it might be getting close to haskell central :)
10:57:22 <byorgey> mtklein: =)
10:57:26 <Beelsebob> :) the new lambda cat rocks :)
10:57:33 <sclv> hmm.. potentially the fmap could be return when the instances matched and mzero otherwise... then you could join . traverse ?
10:57:42 <Philippa> davidL: yeah, the area in general is good :-)
10:58:20 <sclv> this would of course only work for functors that are monads.
10:58:58 <shapr> dons: What, Portland?
10:59:10 <dons> shapr: :)
10:59:10 <byorgey> sclv: and Traversable?
10:59:30 <davidL> Philippa: do you have any other recommendations on where to apply besides Waterloo, Texas, and Portland? :)
10:59:31 <sclv> haha right, that too.
10:59:33 <byorgey> davidL: I just visited PSU this past weekend =)
10:59:35 <dons> we had a haskell web hackathon yesterday. lots of fun.
10:59:51 <dons> i want to get to the point where writing a new web app is 1 hrs work.
10:59:56 <dcoutts> dons: what did you all get up to? anything particularly interesting?
10:59:58 <shapr> dons: I'm trying to scrape up people for CHUG, but it looks like I'll be inviting schemers and other type theory guys and calling it a programming language theory group instead of a Haskell group.
11:00:08 <dons> dcoutts: consolidating fastcgi and database stuff
11:00:21 <dcoutts> dons: what db framework?
11:00:25 <dons> takusen
11:00:29 <dons> on top of sqlite
11:00:30 <dcoutts> ah right
11:00:32 <Philippa> davidL: see, I'm in the UK - I may not be the right person for you to ask
11:00:42 <Philippa> dons: cool
11:00:46 <sclv> ?instances-importing Data.Traversable Traversable
11:00:47 <lambdabot> Maybe, []
11:00:52 <dcoutts> dons: what db backends does takusen support?
11:00:55 <Philippa> I got the web framework itch a bit again myself the other day
11:00:57 <davidL> ah, I'll try asking -cafe, thanks Philippa
11:01:04 <dons> dcoutts: a few, check the hackage page
11:01:09 <hpaste>  bran pasted "(no title)" at http://hpaste.org/5763
11:01:17 <Philippa> partly due to getting prodded about Flippi, of course
11:01:31 <pjd> :t let mfilter p = (>>= \x -> if p x then return x else mzero) in mfilter
11:01:32 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
11:01:47 <dons> Philippa: seen pandocwiki?
11:01:56 <Philippa> no?
11:02:01 <dons> ?google pandocwiki
11:02:03 <lambdabot> http://www.ohloh.net/projects/11856
11:02:03 <lambdabot> Title: pandocwiki - Ohloh
11:02:07 <dons> hah!
11:02:10 <Philippa> assume I'm mostly out of the loop and have a bad and somewhat cranky case of NIH :-)
11:02:16 <dons> that's why we get our stuff on ohloh -- google loves it
11:02:19 <Cale> hmm, that's interesting, a kind error in hpodder
11:02:40 <byorgey> Philippa: who do you know at PSU?
11:02:43 <doserj> dons: you could update the description, though. Only Oracle is mentioned there...
11:02:50 <dcoutts> dons: if only ohloh supported darcs we could set up something to automatically register hackage packages on ohloh
11:02:52 <dons> doserj: dive in. its a wiki
11:03:02 <dons> dcoutts: yeah. that's the only sustainable model, i think
11:03:08 <doserj> I mean on the hackage page
11:03:17 <dons> dcoutts: btw, checked the language stats they provide?
11:03:22 <mtklein> ooh, that mfilter may be what i was looking for
11:03:30 <dons> oh, i note dcoutts is #1 karma gainer on ohloh.net frontpage
11:03:33 <byorgey> mtklein: filterM ?
11:03:37 <dcoutts> heh :-)
11:03:38 <Igloo> dcoutts: It would be better done on community, I think
11:03:40 <shapr> ooh, pandocwiki?
11:03:42 <sclv> ?instances MonadPlus
11:03:43 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
11:03:51 <dcoutts> Igloo: hmm?
11:04:03 <Philippa> byorgey: Tim Chevalier
11:04:03 <Igloo> dcoutts: If the no-darcs is a long term thing, we could even make read-only git mirrors on community
11:04:14 <dons> dcoutts: monthly contributors to haskell projects ohloh knew about as of sunday, http://www.ohloh.net/languages/compare?l0=haskell&measure=contributors   over time
11:04:15 <lambdabot> Title: Open Source Programming Language Popularity Monthly Contributors History Chart - ..., http://tinyurl.com/3bho4x
11:04:18 <Igloo> dcoutts: referring ot < dcoutts> dons: if only ohloh supported darcs we could set up something to automatically register hackage packages on ohloh
11:04:20 <Le-Chuck_ITA> is distributed like bzr?
11:04:26 <byorgey> Philippa: oh, cool, I stayed with him while I was there =)
11:04:28 <Le-Chuck_ITA> is darcs distributed like bzr
11:04:29 <Le-Chuck_ITA> =
11:04:37 <vininim> yes
11:04:42 <Philippa> byorgey: oh, yeah, heard about that via his LJ
11:04:54 <pejo> Philippa, did he stop visiting #haskell, or am I just half blind?
11:04:59 <Le-Chuck_ITA> a disadvantage of darcs w.r.t. bzr?
11:05:05 <Le-Chuck_ITA> I mean to ask for it
11:05:06 <dons> dcoutts: versus erlang, http://www.ohloh.net/languages/compare?commit=Update&l0=haskell&l0_0=-1&l1=erlang&measure=contributors
11:05:07 <byorgey> Philippa: ah, cool.  yeah, I had a really good time.
11:05:09 <lambdabot> Title: Open Source Programming Language Popularity Monthly Contributors History Chart - ..., http://tinyurl.com/2qksql
11:05:16 <Philippa> pejo: he's always been something of an irregular, and being online tends not to help his productivity
11:05:28 <Igloo> dons: By the way, your git conversion goes forwards in time, right? I had a look last night, and by patch count 1997 is about 6% in going forwards
11:06:00 * byorgey will probably have to cut back on IRC once he starts grad school too...
11:06:01 <dons> Igloo: it goes forwards in tiem.
11:06:05 <vininim> Le-Chuck_ITA: There are problems with conflicts issues, at least the release versions.
11:06:17 <shapr> I'll probably cut back on IRC when I get married.
11:06:20 <dons> Igloo: i'm expecting to wait a while
11:06:21 <dcoutts> dons: interesting
11:06:27 <Igloo> Mmmhmm  :-)
11:06:32 <mtklein> hmm, so this doesn't work for Set... Set's not even a monad right?
11:06:32 <dons> DATE  : 1997-07-05 00:49
11:06:33 <dons> AUTHOR: sof
11:06:38 <dons> is where we're up to now
11:06:52 <byorgey> shapr: hehe.  I don't even want to think about how much time I would spend on IRC if I wasn't. =)
11:06:56 <Igloo> dons: What are you using to do the conversion?
11:07:17 <byorgey> mtklein: unfortunately not, since it requires an Eq constraint
11:07:20 <dons> darcs2git failed (the fast one), so using darcs-to-git, which is much slower, but handles more complex cases.
11:07:31 <dons> tailor is the final option, but i've not worked it out yet
11:08:01 <mtklein> byorgey: bummer... but am i right in thinking i can just define a new class, and make both list and set instances?
11:08:14 <byorgey> mtklein: see this for more info: http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
11:08:15 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
11:08:22 <byorgey> mtklein: sure, you could
11:09:04 <dons> dcoutts: btw, gtk2hs got recognised as "mostly Pascal"
11:09:08 <dons> due to the .pp files, i think
11:09:18 <hpaste>  ohub pasted "Why this rewrite doesn't compile?" at http://hpaste.org/5764
11:09:20 <dons> it was a partial repo conversion, aslo.
11:11:21 <monochrom> Haskell actually is closely related to Pascal by way of the researchers behind them.
11:11:29 <mtklein> you know, i think it may just be easier to fully qualify my references to filter :)
11:11:48 <dcoutts> dons: heh, so I see
11:11:57 <dcoutts> dons: we do use some weird extensions
11:13:46 <dons> one thing that ohloh might be good for: extracting the list of "serious" haskell projects
11:13:58 <dons> i'm surprised how many projects are > 10k loc
11:14:06 <dons> and some i didn't know about are > 100k (like haxml!)
11:14:17 <dcoutts> dons: seems that the gtk2hs conversion was also pretty weird for the time of patches
11:14:27 <dons> dcoutts: yeah, looks wrong
11:14:35 <dons> the git repo has 2002-2005 (before it failed)
11:14:37 <dcoutts> all of them have the same data
11:14:44 <doserj> ohub: xs == [] has the wrong type. use null xs
11:14:46 <dcoutts> data/date
11:14:56 <dons> probably due to the partial conversion failing
11:15:14 <dons> i should hack up a api query to ohloh for getting at these stats
11:15:24 <doserj> ohub: and probably the RULE should come after the module declaration
11:15:28 <dons> just having a list of projects >1k, >10k, >50k will be fu
11:15:29 <dons> n
11:15:47 <dcoutts> dons: we should be able to do this on hackage directly, just using sloccount
11:15:52 <ohub> doserj; yeah, and #-} must have some whitespace in the beginning
11:16:13 <dons> dcoutts: yeah. though we need more stuff on hackage then.
11:16:21 <dcoutts> dons: in fact it'd be a great first test of a general hackage reporting framework
11:16:24 <dons> since most of the big things *aren't * on ahckage
11:16:56 <dcoutts> dons: a client that grabs tarballs, unpacks runs slocount and sends back reports.
11:17:04 <Le-Chuck_ITA> I know I should never identify myself as a wannabe categorist. But is someone willing to contradict me if I say I proved that if F and G are isomorphic functors, then so are FÂ°H with GÂ°H and KÂ°F with GÂ°F?
11:17:24 <Le-Chuck_ITA> KÂ°F with KÂ°G
11:17:48 <dcoutts> dons: it'd be a simple exercise of the mechanisms, eg storing/logging per-package reports of various kinds
11:17:53 <dons> yep
11:18:24 <monochrom> I think that's right, Le-Chuck_ITA.
11:33:55 <penpen> I just thought "finally installed all the prerequisits for hpodder" only to witness that the versions of both HDBC and HDBC-sqlite are too old 8-|
11:34:55 <penpen> That much on people being overly lazy when it comes to documentation 8-<
11:35:54 <bos> @users
11:35:55 <lambdabot> Maximum users seen in #haskell: 465, currently: 460 (98.9%), active: 21 (4.6%)
11:38:05 <bparkis> in reduce, instead of specifying a default value, you could specify a way to "lift" the last value of the sequence to the proper type
11:38:13 <Cale> Whoever wrote the Euler problems solutions on the Haskell wiki needs to learn to indent and space Haskell code properly :)
11:38:32 <Cale> (I've corrected the first few pages, but it's tedious :)
11:39:38 <penpen> Thus spoke the Lord: Thou shalt not impose Pythonisms unto Me!
11:39:42 <bparkis> so you want to reduce a, b, c by f, and instead of saying (f a (f b (f c zero))) for some zero, you could say (f a (f b (g c))) for a "translation" function g
11:40:21 <bparkis> and g is only applied to the last element of the sequence to make it so its type is compatible with the second argument of f
11:41:38 <Cale> bparkis: and the empty list case is an error as in foldr1 ?
11:41:49 <bparkis> yeah i guess
11:42:27 <bparkis> for example if f is +, instead of saying a + (b + (c + 0)) you would say a + (b + (g c)) where g is the identity
11:42:39 <gnuvince> @src foldr1
11:42:39 <lambdabot> foldr1 _ [x]    = x
11:42:39 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
11:42:39 <lambdabot> foldr1 _ []     = undefined
11:42:39 <penpen> obviously the hdbc-issues resulted from trying to install an old version 8-|
11:42:44 <penpen> DOOOOOOOOOOOOOOOOOOOOOOH!
11:42:48 <bparkis> because what if your operation f doesn't have a zero
11:43:09 <gnuvince> :t undefined
11:43:12 <lambdabot> forall a. a
11:44:16 <Cale> bparkis: You don't necessarily need to pass an identity element with respect to f as the replacement for []
11:44:26 <Cale> For example:
11:44:50 <Cale> > let xs +++ ys = foldr (:) ys xs in [1,2,3] ++ [4,5]
11:44:52 <lambdabot>  [1,2,3,4,5]
11:44:52 <Cale> > let xs +++ ys = foldr (:) ys xs in [1,2,3] +++ [4,5]
11:44:53 <lambdabot>  [1,2,3,4,5]
11:45:00 <hpaste> uÊop ÇpÄ±sdn uÄ± pÇÆÆnld Çq oÊ sÉ¯ÇÇs ÊÇuÉ¹ÇÉ¥ÊÇ ÊÉ¯
11:45:17 <Le-Chuck_ITA> how the ****
11:45:29 <Le-Chuck_ITA> I don't want to know :)
11:45:33 <Cale> Le-Chuck_ITA: hm?
11:46:03 <Le-Chuck_ITA> I never saw upside-down text
11:46:11 <Le-Chuck_ITA> on irc I mean
11:46:17 <idnar> hooray unicode
11:46:20 <Cale> Ah, it's just using lots of unicode characters to approximate rotated letters.
11:46:21 <Le-Chuck_ITA> eheh
11:47:03 <Cale> I'm pretty sure that Æ is cyrillic.
11:47:22 <Cale> Ç is a schwa.
11:47:45 <Cale> I'm not quite sure what the others are.
11:47:53 <Cale> Probably bits of the IPA or something.
11:48:41 <Le-Chuck_ITA> funny indeed
11:49:29 <Le-Chuck_ITA> people seems to have better thing to do than configuring xmonad
11:50:19 <monochrom> Yeah, they configure hpaste.
11:50:23 <smg> why does not a single syntax work in haskell
11:50:24 <smg> ?
11:50:32 <dons> smg? a single syntax?
11:50:41 <smg> ..
11:50:48 <dons> > map (+2) [1..10] -- there's some syntax for you
11:50:51 <smg> i can't define a variable
11:50:52 <smg> nothing
11:50:54 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
11:50:57 <smg> every time syntax error...
11:51:00 <dons> > let x = 10 in x
11:51:01 <lambdabot>  10
11:51:06 <smg> ...
11:51:06 <Cale> smg: Are you typing declarations into ghci?
11:51:08 <smg> why does not work
11:51:09 <dons> smg, have you got a tutorial?
11:51:12 <smg> i have
11:51:15 <smg> all tutorials fail
11:51:23 <Cale> smg: Sorry, but we need to know what it is that you're trying.
11:51:26 <smg> square x = x*x
11:51:29 <smg> -> syntax error
11:51:32 <smg> on ghci AND hugs98
11:51:34 <dons> let square x = x * x
11:51:38 <Cale> Okay, put that into a file.
11:51:43 <Cale> name it  square.hs
11:51:45 <dons> you have to load them from a file. or else bind them with 'let'
11:51:48 <Cale> and run  ghci square.hs
11:51:54 <smg> i am interactive mode
11:52:06 <Cale> smg: interactive mode accepts expressions
11:52:09 <smg> Hugs> let square x = x * x
11:52:09 <smg> ERROR - Syntax error in expression (unexpected end of input
11:52:10 <Cale> smg: Not declarations
11:52:10 <dons> $ ghci
11:52:11 <dons> Prelude> let square x = x * x
11:52:11 <dons> Prelude> square 4
11:52:16 <dons> smg: use ghci
11:52:24 <Cale> smg: You have to put declarations into a file.
11:52:27 <smg> i see
11:52:37 <Cale> (or else use let, but don't do that :)
11:52:39 <smg> so interactive always let?
11:52:49 <smg> can i do something like that
11:52:53 <dons> in ghci, yes. not in hugs. in hugs you have to load from a file
11:52:54 <smg> square :: Integer -> Integer
11:52:54 <smg> ?
11:52:57 <Cale> It's better to keep a source file open alongside your ghci window.
11:53:08 <Cale> and whenever you save your source file, you just type :r in ghci
11:53:11 <Cale> and it'll reload it
11:53:14 <smg> k
11:53:19 <ivan_> how do i lift an IO a to a monad m a.... IO a -> m r t a
11:53:34 <Cale> ivan_: Which monad?
11:54:02 <smg> what's better?
11:54:05 <smg> hugs98 or ghci?
11:54:05 <ivan_> Cale: my data type m r t a
11:54:06 <Cale> :t liftIO
11:54:08 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:54:25 <Cale> smg: ghci is generally considered better
11:54:45 <smg> i see
11:54:45 <monochrom> hugs is better because it's smaller.
11:54:46 <ivan_> Cale: how do i impement it: just create an instance MonadIO
11:54:57 <smg> and how would i define a function in hugs?
11:55:03 <smg> (not in a text file)
11:55:09 <Cale> ivan_: Um, what is your monad?
11:55:26 <Cale> smg: You wouldn't.
11:55:31 <smg> k
11:55:35 <ivan_> Replay q r t = Retur a | Lift(IO a) | ....
11:55:39 <smg> is there a add function builtin?
11:55:43 <Cale> smg: You could use let to define functions locally to an expression.
11:55:45 <ivan_> is it good to define Lift(IO a)
11:55:46 <smg> i want to run addition on a list
11:56:02 <Cale> smg: for example:  let square x = x * x in square 5
11:56:12 <Cale> (if you type that in hugs, it will work)
11:56:24 <Cale> (or ghci, for that matter)
11:56:48 <Cale> smg: hm?
11:56:58 <Cale> smg: Could you give an example of what you mean?
11:57:01 <dejones> Cale: It would be interesting to see that your availability is predictable unpredictable.  ;)
11:57:02 <Cale> > 5 + 3
11:57:04 <lambdabot>  8
11:57:06 <dejones> * predictably
11:57:17 <Cale> smg: Addition of numbers is +
11:57:28 <Cale> smg: If you want list concatenation, that's ++
11:57:42 <smg> k
11:57:43 <Cale> smg: If you want to add two lists elementwise, that's zipWith (++)
11:57:53 <smg> list comprehension
11:57:56 <Cale> smg: If you want to sum the elements of a list, that's sum
11:57:56 <smg> i forgot :\
11:58:07 <smg> is list comprehension like that: [x for x in x<-foo] ?
11:58:26 <Cale> > [x | x <- [1,2,3,4], even x]
11:58:28 <lambdabot>  [2,4]
11:58:34 <Cale> > [x^2 | x <- [1,2,3,4], even x]
11:58:35 <lambdabot>  [4,16]
11:58:56 <ivan_> Cale: when is create an instance Monad of my data type do i have to declare bind for all the types?
11:59:03 <Cale> > [(x,y,z) | x <- [1..20], y <- [1..x], z <- [1..y], x^2 + y^2 == z^2]
11:59:05 <lambdabot>  []
11:59:09 <Cale> err...
11:59:39 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
11:59:41 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
11:59:44 <Cale> right :)
11:59:52 <Cale> ivan_: yes
12:00:00 <Cale> ivan_: You also want to make sure it's actually a monad.
12:00:03 <dejones> Btw Cale, your IO tutorial was helpful.  Thank you.
12:00:09 <Cale> dejones: great!
12:00:15 <smg> wait i paste something
12:00:17 <ivan_> Cale: you mean the three laws?
12:00:20 <Cale> ivan_: yeah
12:00:30 <smg> http://rafb.net/p/ZJpdaw97.html
12:00:31 <lambdabot> Title: Nopaste - stdin
12:00:33 <smg> this is okay Cale?
12:00:36 * penpen abseils
12:00:47 <smg> so i normally put all in a text file?
12:00:48 <Cale> smg: yep :)
12:00:51 <Cale> smg: yeah
12:00:54 <smg> k sorry
12:00:58 <smg> i'm from python
12:01:02 <Cale> smg: think of ghci/hugs as debuggers
12:01:05 <smg> k
12:01:08 <BMeph> The Three Laws of Monadics? With the later-discovered "Zeroth Law" added? ;)
12:01:14 <dejones> or shells
12:01:17 <dejones> :P
12:01:18 <Cale> smg: They're interactive in that you can write expressions, and they'll be evaluated.
12:01:32 <byorgey> BMeph: zeroth law?
12:01:38 <pjd> smg: what do you want myN to do?
12:01:44 * BMeph is reading a book based on Asimov's "Foundation" series
12:01:55 <Cale> pjd: It multiplies the elements of a list by a number.
12:02:12 <roconnor> BMeph: they added a zeroth law of thermodynamics
12:02:22 <smg> pjd: just some random crap :)
12:02:40 <smg> is there += in haskell? i guess no
12:02:44 <Cale> smg: no
12:02:51 <Cale> smg: Though you could define one.
12:03:01 <byorgey> Cale: !?
12:03:02 <smg> ah i see
12:03:05 <Cale> er...
12:03:06 <smg> i just want to add all numbers in a list
12:03:12 <Cale> yes
12:03:24 <dejones> smg, there are no destructive updates in Haskell, as in, you assign once.
12:03:31 <Cale> Of course, it wouldn't necessarily do what += in other languages did :)
12:03:37 <bd_> (+=) :: Num n => IOVar n -> n -> IO ()
12:03:42 <roconnor> Zeroth law of thermodynamics: if a and b are in thermal equalibrium and b and c are in thermal equalibrium, then a and c are in thermal equalibrium.
12:03:51 <smg> bd_: haha? :D
12:03:51 <Cale> bd_: Right, something like that :)
12:03:52 <gnuvince> > sum [1..10]
12:03:56 <lambdabot>  55
12:03:57 <gnuvince> smg: ^^
12:03:57 <Cale> IORef rather
12:03:58 <smg> lol
12:04:05 <bd_> er yes
12:04:13 <Cale> > foldl (+) 0 [1..10]
12:04:15 <lambdabot>  55
12:04:21 <smg> can i see how sum is implemented then?
12:04:27 <gnuvince> @src sum
12:04:27 <lambdabot> sum = foldl (+) 0
12:04:28 <Cale> @src sum
12:04:28 <lambdabot> sum = foldl (+) 0
12:04:29 <dejones> > foldr (+) 0 [1..10]
12:04:31 <lambdabot>  55
12:04:32 <dejones> :P
12:04:33 <gnuvince> Cale: I win!
12:04:34 <gnuvince> :)
12:04:42 <smg> where do i find description about foldl and sum for example?
12:04:42 <Cale> > foldl f z [1..10]
12:04:43 <lambdabot>  f (f (f (f (f (f (f (f (f (f z 1) 2) 3) 4) 5) 6) 7) 8) 9) 10
12:04:47 <smg> and what is a good tutorial
12:04:52 <smg> to start learning haskell
12:04:55 <dejones> smg: YAHT
12:04:59 <Cale> smg: YAHT is good, or the wikibook
12:05:01 <smg> ok
12:05:01 <Cale> @where yaht
12:05:02 <pjd> smg: Haskell wikibook
12:05:02 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
12:05:03 <smg> thank you
12:05:08 <Cale> @where wikibook
12:05:08 <lambdabot> http://en.wikibooks.org/wiki/Haskell
12:05:11 <pjd> smg: foldl and sum come from the Prelude
12:05:17 <gnuvince> smg: http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1203451506&sr=8-1
12:05:18 <smg> i see
12:05:19 <lambdabot> http://tinyurl.com/39mos5
12:05:23 <Cale> smg: here's another implementation:
12:05:23 <pjd> which is basically Haskell's __builtins__
12:05:26 <smg> prelude = pre defined functions (library) ?
12:05:28 <Cale> sum [] = 0
12:05:28 <dejones> smg: YAHT - Yet Another Haskell Tutorial.  I have found it very, very helpful.  I am coming from mostly C background, but I am proficient in Ruby/Python.
12:05:31 <Cale> sum (x:xs) = x + sum xs
12:05:49 <ehird`> you know what we need
12:05:52 <smg> thanks all who answered me Cale gnuvince dejones
12:05:56 <dejones> smg: Just make sure you actually do the Exercises in YAHT.  They do help you a lot.  :)
12:05:57 <smg> ah true
12:05:57 <ehird`> we need a YAHT.Prelude -- which is a little explainer to read before YAHT
12:05:58 <Cale> smg: which might be easier to follow if you don't know about folds :)
12:06:06 <pjd> smg: foldl is roughly like reduce, by the way
12:06:08 <ehird`> it will explain the 'no destruction' etc simply, then lead you on to YAHT
12:06:13 <smg> pjd: ah cool thanks
12:06:20 <dejones> smg: The online version of YAHT also has solutions to the Exercises.
12:06:21 <ehird`> so that the simple questions in #haskell which can get lost in the noise and misconceptions formed by very short answers
12:06:27 <ehird`> could be answered by that
12:06:27 <smg> okay, i will read yaht tutorial now thank you
12:06:28 <smg> bbl :)
12:06:58 <Cale> smg: Basically, learning Haskell will be a little like learning to program over again, since you have to learn how to express things without changing them. :)
12:07:10 <pjd> smg: foldl (+) 0 xs == reduce(operator.add, xs, 0)
12:07:14 <Cale> smg: Feel free to ask lots of questions :)
12:07:23 <dejones> smg: Everything is a function!  hehe.
12:07:25 <dejones> ;)
12:07:34 * dejones is very new to Haskell, also.
12:07:35 <Saul> I just read the paper on ByteStrings, pretty cool stuff
12:07:37 <ehird`> smg: MONADS MONADS MONADS MONADS MONADS
12:07:44 <Cale> ehird`: hehe
12:07:49 <dejones> Saul: which paper?
12:07:51 <ehird`> ROAARRRRRR!
12:07:54 <idnar> ehird`: MUSHROOM MUSHROOM
12:08:00 <Saul> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
12:08:01 <lambdabot> Title: Rewriting Haskell Strings
12:08:07 <Botje> idnar: ITYM arrow arrow :)
12:08:09 <radix> o/` the kombucha monad people sitting around all day o/`
12:08:14 <idnar> radix: hahhahah nice
12:08:42 <dejones> Thanks Saul.
12:09:15 <earthy> botje: or comonad... or applicative functor... or...
12:09:30 <Saul> dejones: No problem, although if you're new to haskell, there might be more useful things to read
12:09:33 <Botje> but those don't quite fit into the song, do they? :)
12:09:44 <dejones> Saul: That abstract has some complicated terminology.  ;)
12:10:06 <dejones> Saul: Yah, but I don't mind a little drowning.
12:10:35 <Saul> dejones: Learn monads then :)
12:11:22 <dejones> Saul: Soon, soon.  I'm working my way through YAHT.
12:11:40 <dejones> Saul: The scary part is that I am attempting to do my Master's thesis this summer with Haskell, haha.
12:11:58 <Saul> dejones: Very brave
12:12:48 <Saul> dejones: I won't have to do my thesis for at least another year, and I have been working with haskell for over half a year now
12:12:48 <dejones> Saul: Some may say stupid.  ;)  But, it is "Haskell on the Metal" -- attempting to have the GHC runtime system execute directly on the hardware, and most of the GHC RTS is in C.  So, I am hoping I should be able to do it.
12:13:28 <Saul> dejones: Sounds cool
12:13:54 <dejones> Saul: I'm very interested in using Haskell for OSes (kernels) and concurrent execution.  The Haskell on the Metal project combines those really well.
12:14:04 <dejones> Saul: Yah, let's just see if I can get it done this summer, ha.
12:14:10 <dejones> It will be hell, but lots of fun.
12:14:10 <dejones> :)
12:14:18 <Hendel> juackers
12:14:20 <Saul> well good luck
12:14:24 <dejones> Thank you Saul.
12:14:41 <dejones> Saul: What area(s) are you interested in?
12:15:03 <Saul> Uhm that's a difficult one
12:15:11 <BMeph> Mmm...HaskellOS! :)
12:15:39 <dejones> BMeph: that's the eventual goal... like the House people at Portland State Univ.
12:15:49 <Saul> I've been finding programming languages themselves increasingly interesting since I've discovered haskell
12:16:23 <Saul> And also program correctness somewhat
12:16:37 <fork> Making a machine in haskell is cool because it's completely static - but has the illusion of changing parts.
12:16:42 <dejones> Yah, I really like the idea of being able to formally validate your code.
12:16:44 <Saul> The problem with most systems is that they take a lot of time (both in human and CPU time)
12:17:08 <BMeph> I want to see a Haskell RTS...in FORTH! >;)
12:17:21 <Saul> and I don't like the idea to try to verify all turing complete programs
12:18:06 <Saul> I think that specification, verification and code should be coupled in a useful and intuitive way
12:18:19 <dejones> bah, I keep getting disconnected / lagging out.
12:18:25 <BMeph> Saul: Verify that they are TC, you mean? :)
12:18:52 <fork> busy beaver shizz
12:19:13 <fork> going, too drunk for FP conversation
12:19:29 <dejones> BMeph: why in Forth?  ;)
12:19:41 <Saul> BMeph: well most proof systems try to see if a program in a random language is behaving according to specification
12:20:01 <Saul> BMeph: But there are a lot of things that you can express in a language, but won't
12:20:24 <roconnor> @where house
12:20:25 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
12:20:26 <Saul> BMeph: These can really make it difficult to prove things
12:20:55 <dejones> roconnor: yep, House is cool stuff.  :)
12:21:10 <shapr> Did they finish the tcp/ip stack in House?
12:21:14 <BMeph> dejones: FORTH was one of the first languages I learned, and have always been impressed with how expressive it is - especially comparerd to BASIC. ;)
12:21:19 <Saul> I think it is unwise to build specification and implementation seperately and then try to show them equal
12:21:22 <dejones> shapr: I think it says they did... but, I'm not certain.
12:21:32 <Saul> I think you should create one out of the other
12:21:36 * monochrom agrees with Saul.
12:21:56 <dejones> Saul: Eiffel does some of that, I think, with their Design by Contract.
12:22:18 <monochrom> Bird's "Algebra of Programming" does all of that.
12:22:27 <roconnor> types are specifications
12:22:37 <Saul> dejones: I don't think that really proves anything though
12:22:45 * wli likes Eiffel's runtime invariant checks.
12:23:04 <shapr> Could you do all of the DbC stuff with STM?
12:23:51 <Saul> monochrom: Do you have a link to that?
12:24:18 * BMeph likes how D picked up on the DbC.
12:24:31 <dejones> Saul: http://lambda-the-ultimate.org/node/1117
12:24:33 <lambdabot> Title: Algebra Of Programming (Bird, De Moor) | Lambda the Ultimate
12:24:36 <monochrom> It's a book. But I can find you his papers.
12:24:46 <dejones> Saul: That's a post about the book.
12:24:55 <monochrom> Ah, that will do. I posted there where to find his papers IIRC.
12:25:16 <dejones> Saul: I agree with you that it doesn't prove anything, but it does pair the specifications with the implementation.  :)
12:25:25 <dejones> which, I do think you could form some proofs based upon.
12:25:38 <monochrom> Oops I posted no link. Let me find it.
12:26:06 <dejones> monochrom: what name did you post under?
12:26:08 <dejones> ahh
12:26:25 <monochrom> http://groups.google.com/group/comp.lang.haskell/msg/93c61c9debbe058d
12:26:26 <lambdabot> Title: Favorite Research Papers - comp.lang.haskell | Google Groups, http://tinyurl.com/2gcxk9
12:27:10 <Saul> dejones: Yeah you can prove the pre- and postconditions and then prove things about composition using those pre- and postconditions
12:27:27 <Saul> dejones: But it's still a lot of work
12:27:55 <dejones> Saul: Yep.  Haskell has the ability to do some of that too with the type specifications for functions and the no side-effects, but I'm sure you are aware of that.
12:28:04 <dejones> Yah, I bet it is a lot of work, hehe.
12:28:44 <dejones> Write software to do the formal validation part too.  ;)
12:29:11 <dejones> monochrom: That is an -awesome- thread.  Thank you.
12:29:16 <BMeph> Saul: Purity must make program verifiers weep with joy, eh? :)
12:29:56 <dejones> :)
12:30:00 <monochrom> It is "a lot of work" in only the sense that so little of it, namely the final machine code, is considered deliverable and executable.
12:30:29 <monochrom> But assuming you write your programs by Intellectual Design, and not by random genetic mutation...
12:30:38 <dejones> haha
12:30:38 <smg> dejones: hehe, i prefer perl and c++ so it's a bit different to think in haskell :D
12:31:08 <dejones> smg: I understand.  Everything is a function, keep that in mind, such as (+) 5 3 = 8
12:31:12 <dejones> > (+) 5 3
12:31:17 <lambdabot>  8
12:31:20 <monochrom> then surely you had reasons to write your program in a certain way.  This "prove program correct" business is just about documenting your reasons.
12:31:30 <smg> dejones: hehe prÃ¤fix notation
12:31:37 <smg> pre :)
12:32:01 <dejones> smg: yep, prefix notation, but it shows that (+) is really a function with two arguments, in that case.
12:32:20 <smg> hehe
12:33:15 <monochrom> So, all sentiments about this involving a lot of work is just sentiments about documenting at all a lot of work.  Understandable for programmers, who chose to be programmers rather than documentors or thinkers or logicians or ... for obvious, self-selecting reasons.
12:34:19 <dejones> monochrom: I think that "Favorite Research Papers" thread could keep me busy for a very long time.
12:34:48 <dejones> To actually accomplish understanding all those papers, that is.
12:34:59 <monochrom> It will take a lifetime.
12:35:07 <dejones> Noooo
12:35:24 <dejones> well, I do have a life... so, I guess I do have a lifetime available.  ;)
12:35:34 <monochrom> It is a plus, not a minus.  Imagine: you will never be bored again!
12:35:54 <Cale> dejones: Wait, you have a life. That could get in the way. :)
12:35:59 <dejones> monochrom: haha, I do always say that "I would rather be very busy than bored."
12:36:14 <dejones> Cale: Stop being unpredictably available.  :P
12:36:33 <Cale> hehe
12:36:36 <dejones> Cale: Yah, the girlfriend may not approve of that "life" choice.
12:36:53 <monochrom> Cale is proof that "unpredictably available" = "no life" :)
12:37:00 <dejones> lol
12:37:43 <Cale> I go to sleep approximately "when I'm tired".
12:37:57 <dejones> But, I must go for now... My "life" requires me to do homework now.
12:38:06 <dejones> Cya.
12:38:09 <Cale> later :)
12:38:25 * Cale goes off to play some half-life.
12:38:33 <moonlite> almost real life
12:38:39 <Cale> Î»
12:38:44 <moonlite> !
12:39:08 <monochrom> Haskell Life ?
12:39:52 <roconnor> bah language pragmas
12:46:40 <bauchus> what? there is no Main module? But I wrote in .cabal Main-is: Foo.hs
12:48:09 <roconnor> GuiTV-0.3$ ./Setup.lhs configure
12:48:09 <roconnor> : No such file or directory
12:48:11 <roconnor> ??
12:48:20 <roconnor> oh wait
12:48:23 <bauchus> oh, I have to write "module Main where ..." in Foo.hs
12:48:27 <olsner> crlf issue maybe?
12:48:32 <roconnor> the .lhs file is prbably borked
12:50:10 <smg> hum
12:50:18 <smg> how would i say in haskell do a for loop
12:50:19 <smg> ?
12:50:33 <roconnor> ah, windows carrage return
12:50:49 <smg> doNtimes n = ...
12:50:49 <smg> ?
12:50:53 <monochrom> Depends on why you want a for loop.
12:50:54 <faxathisia> smg, what do you want to loop for/across/about?
12:51:28 <smg> i want to define a functon which does something n-times
12:52:06 <monochrom> replicateM 10 (putStrLn "hello")  -- will print hello 10 times.
12:52:22 <monochrom> perhaps replicateM_ instead
12:52:35 <monochrom> (need to import Control.Monad)
12:52:53 <monochrom> > foldl' (+) 0 [3,1,4,1,5,9]
12:52:55 <lambdabot>  23
12:53:00 <dejones> this is great: http://www.gnu.org/fun/jokes/eternal-flame.html  -- I found it posted on Philip Wadler's homepage.
12:53:03 <lambdabot> Title: Eternal Flame
12:53:07 <dejones> :)
12:53:08 <roconnor> how do I convert a dos file to a unix file?
12:53:10 <monochrom> This adds up numbers in a list. No for-loop.
12:53:10 * dejones is really gone now!
12:53:29 <smg> i see
12:53:37 <smg> and how would i do it without Monads?
12:53:50 <monochrom> > map (+ 1) [2,7,1,8,2,8]
12:53:52 <lambdabot>  [3,8,2,9,3,9]
12:53:56 <dejones> smg: Read YAHT.  It has exactly what you are looking for and you will learn a lot.  :)
12:53:58 <faxathisia> sed -e 's/\r$//'
12:54:03 <smg> dejones: k :P
12:54:06 <dejones> hehe
12:54:08 <monochrom> This "adds 1" to each iterm in the list.  No for-loop.
12:54:11 <dejones> It's not very long, really.
12:54:37 <monochrom> If what you do requires IO (like printing), you can't eliminate it.
12:55:13 <smg> dejones: only tell me pleace how can i find out the type of something?
12:55:23 <monochrom> If what you do is pure (like adding), then there is no IO involved.
12:55:50 <monochrom> Anyway, "a function that does something n times" is still vague.
12:57:04 <roconnor> crap,  I have to install wx haskell
12:57:20 <monochrom> That will take a week :)
12:57:43 <ehird`> smg, I think, will have trouble grasping haskell's mentality
12:57:47 <ehird`> This is why we need YAHT.Prelude! :P
12:57:50 <dejones> smg: That is also in YAHT.  :)  But, in ghci you can do ":type a" as a is a variable.
12:58:12 <dejones> ehird`: All the questions he has been asking are in the YAHT that I just read yesterday. ;)
12:58:16 <roconnor> How come hackage says wx is built, but wxcore fails to build?
12:58:18 <allbery_b> you should whine.  I've found *none* of the binary ghc 6.8.2 packages will work in our environment --- and the 6.6 Solaris packages are also iffy, so bootstrapping is proving nightmarish
12:58:18 <ehird`> heh
12:58:21 <ehird`> still
12:58:24 <dejones> yeah...
12:58:25 <ehird`> just to clear up the misconceptions he has
12:58:37 * earthy looks at roconnor and shares the pain
12:58:49 <roconnor> earthy: well, I need to reinstall it
12:58:52 <earthy> wxhaskell is in a state of flux
12:59:09 <roconnor> or finish my port of phooey to gtk2hs
12:59:16 <roconnor> I'm not sure which is harder
12:59:19 <monochrom> @remember roconnor crap, I have to install wx haskell
12:59:20 <lambdabot> Good to know.
12:59:23 <smg> ehird`: hrhr
12:59:27 <allbery_b> thankfully I only need gtk2hs.  (*not* thankfully, that means I also need to update our gtk2 for Solaris. argh()
12:59:30 <monochrom> Hope someone will hear it.
12:59:57 <pejo> allbery_b, aren't the new binary packages for Solaris 10?
12:59:58 <ehird`> smg: think of haskell like this
13:00:04 <ehird`> you probably think of languages as:
13:00:05 <smg> i have type Integer and so on what's the type of a function?
13:00:08 <smg> Function?
13:00:13 * dejones really, really must do his homework now, byeee.
13:00:16 <ehird`> 'Do this, then do that. If this, then do that, else do this, then that.'
13:00:19 <ehird`> Haskell is different.
13:00:22 <roconnor> I had wxHaskell installed before I upgraded ubuntu
13:00:29 <roconnor> is there some sneeky way I can reuse it
13:00:31 <ehird`> Haskell is mathematical.
13:00:34 <ehird`> There is no 'a, b, c.'
13:00:37 <smg> i know ehird` :P
13:00:38 <roconnor> It must be hidden on my drive somewhere
13:00:42 <earthy> roconnor: Martijn Schrage ported Proxima to gtk2hs in about a week, maybe 2
13:00:46 <ehird`> and 'if A then B else C' is more like 'A ? B : C' in c.
13:00:53 <pejo> allbery_b, we're using 6.4.1 just fine on Solaris 8 here though. That should be sufficient for bootstrapping 6.8, I think. (Or 6.2.2 might work, which we also have installed).
13:00:53 <dejones> smg: I know I keep saying it, but seriously, read YAHT, it answers simply all the questions you are asking.
13:00:54 <ehird`> smg: yes, but then, how does 'do this N times:' make sense?
13:01:01 <smg> but i make a function declaration, so what do i put there mymap :: [Integer] -> Function -> [Integer] ?
13:01:08 <roconnor> earthy: okay.  Last time it took me 1 day to install wxHaskell
13:01:10 <ehird`> Since computations don't have side-effects, it would be performing (N-1) useless calculations of the same thing!
13:01:17 <smg> dejones: sorry
13:01:19 <monochrom> smg: try ":type map"
13:01:50 <smg> no
13:01:56 <smg> you misunderstand me damn
13:02:01 <smg> Integer is a type, am i right?
13:02:07 <Cin> sure
13:02:10 <smg> myfunction :: Integer -> Integer
13:02:14 <dejones> smg: You're also trying to get ahead of yourself... if you read YAHT it steps you through things in a very building up order, so that you have what you need to build more complex things.
13:02:16 <smg> but i don't need integer as argument, i need a function
13:02:19 <kmcallister> smg, the type of a function which takes arguments of type A, B, ..., Y and returns a value of type Z is written as (A -> B -> ... -> Y -> Z)
13:02:25 <kmcallister> even when it appears as an argument to another function
13:02:36 <ehird`> smg: a function from what to what
13:02:47 <ehird`> kmcallister: I think now is the time to explain currying?
13:02:54 <monochrom> smg: First I'll show you what you would see if you tried ":type map" without doubting me. Then I'll answer your question.
13:02:54 <kmcallister> perhaps
13:02:58 <monochrom> @type map
13:03:00 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:03:01 <dejones> smg: YAHT, go read!  :) haha.
13:03:03 <dejones> bye
13:03:09 <smg> -.-
13:03:10 <allbery_b> 6.2.2 wants me to do evil stuff to get libm.so.2
13:03:13 <ehird`> we need a #haskell-newbieteachers so we can mention whether to say stuff or not without interesting the newbie
13:03:14 <ehird`> haha
13:03:16 <allbery_b> plus having to update our readline
13:03:23 <monochrom> You see that everywhere you expect a function type, it looks like (blahblah -> stuff)
13:03:31 <allbery_b> this kind of crap-chasing is what I expect from linux, not solaris :/
13:03:49 <smg> ehird`: :P
13:03:56 <dejones> #haskell-experts-exchange --- you democratically decide who gets in and they are given the channel pass.  ;)
13:03:59 <smg> ehird`: i just wanted to write a map function on my own...
13:04:02 <monochrom> Inspired by that, you want mymap :: [Integer] -> (Integer -> Integer) -> [Integer]
13:04:03 <roconnor> where are haskell packages installed into?
13:04:10 * dejones leaves.
13:04:14 <smg> monochrom: i see
13:04:21 <ehird`> smg: Well, let's put it this way
13:04:22 <ehird`> you have
13:04:25 <smg> monochrom: thank you that's exactly that what i needed
13:04:26 <ehird`> 'name :: type'
13:04:31 <ehird`> when you wrote a function,
13:04:32 <pejo> allbery_b, package management on any OS is hard though.
13:04:32 <ehird`> you did:
13:04:32 <faxathisia> "Only the elite may enter", "Who are the elite?", "Anyone who wishes to enter"
13:04:35 <ehird`> 'name :: arg -> type'
13:04:36 <smg> ehird`: monochrom already solved it :]
13:04:39 <ehird`> so... a function is (arg -> type)
13:04:41 <ehird`> and that's why that works
13:04:43 <smg> k
13:04:43 <ehird`> smg: just elaborating
13:04:47 <smg> ty
13:04:57 <smg> ehird`: wow!
13:04:58 <kmcallister> faxathisia, you have to stand outside the channel for three days without saying anything or moving, then we let you in :)
13:05:09 <smg> ehird`: you're explanation makes 100% sense even i don't know haskell :)
13:05:24 <kmcallister> smg, do you understand currying?
13:05:30 <smg> i do
13:05:40 <smg> but i never did haskell but okay, now i need to read
13:05:48 <dejones> smg: YAHT :P
13:05:48 <dejones> lol
13:05:49 <dcoutts_> allbery_b: gtk2hs should work with any version of gtk2 on solaris, I've used it with some very old gtk versions on solaris.
13:05:50 <kmcallister> yeah, all functions in haskell are curried
13:06:07 <smg> dejones: so true :)
13:06:12 <roconnor> okay, I have an existing /usr/local/lib/wxcore.pkg
13:06:18 <roconnor> how can I reinstall it?
13:06:18 <allbery_b> hm, I think last time I tried to build it it whined about missing functions in ours
13:07:07 <dcoutts_> allbery_b: if it was gtk+ 2.4, we had one mistake with a couple #ifdefs, it should be trivial to fix.
13:08:06 <allbery_b> yeh, 2.4
13:08:12 <monochrom> @unmtl StateT u (ContT s (Cont r)) a
13:08:12 <lambdabot> u -> (a -> u -> (s -> r) -> r) -> (s -> r) -> r
13:08:23 <monochrom> this is designed to confuse :)
13:08:46 <monochrom> Hrm, this is not confusing enough!
13:09:03 <monochrom> @unmtl ContT s (ContT r (State u)) a
13:09:04 <lambdabot> (a -> (s -> u -> (r, u)) -> u -> (r, u)) -> (s -> u -> (r, u)) -> u -> (r, u)
13:09:17 <monochrom> This is much better!
13:09:19 <Cin> not really confusing
13:09:32 * Cin expert parenthesis reader
13:09:49 <kmcallister> Cin, lisp hacker in a previous life? ;)
13:09:53 <Cin> <_< maybe
13:10:22 <monochrom> I'm going for things like ((((x -> y) -> z) -> t)  so it is not just parentheses, it's the contravariance.
13:10:28 <ehird`> you people are so against lisp :(
13:10:55 <kmcallister> ehird`, i like scheme, at least for didactic purposes.  haven't done much lisp
13:11:04 <monochrom> It's the same as "not and not is a knot"
13:11:35 <Cin> more liek lots of irritating superflowersed parendtherses
13:11:48 <monochrom> @djinn Not (Not (Not x))
13:11:48 <lambdabot> -- f cannot be realized.
13:12:02 <monochrom> @djinn x -> Not (Not (Not (Not x)))
13:12:03 <lambdabot> f a b = void (b (\ c -> c a))
13:12:11 <kmcallister> @djinn ((P -> Q) -> P) -> P
13:12:11 <lambdabot> -- f cannot be realized.
13:12:29 <kmcallister> @djinn ((p -> q) -> p) -> p
13:12:29 <lambdabot> -- f cannot be realized.
13:12:47 <smg> haha, haskell is so cool
13:12:51 <kmcallister> @djinn (Not (Not x)) -> x
13:12:51 <lambdabot> -- f cannot be realized.
13:13:00 <kmcallister> yay constructive logic :)
13:13:03 <byorgey> smg: =)
13:13:06 <ehird`> @djinn (p -> q) -> Not p -> Not q
13:13:06 <smg> i like it, because it's different compared to my usual languages
13:13:06 <lambdabot> -- f cannot be realized.
13:13:09 <ehird`> @djinn (p -> q) -> Not p
13:13:10 <lambdabot> -- f cannot be realized.
13:13:13 <ehird`> @djinn (p -> q) -> Not p -> q
13:13:13 <lambdabot> -- f cannot be realized.
13:13:16 <faxathisia> smg, what are they?
13:13:16 <kmcallister> @djinn (p -> q) -> Not q -> Not p
13:13:17 <lambdabot> f a b c = b (a c)
13:13:22 <ehird`> faxathisia: he hails from python
13:13:30 <ehird`> @djinn ((Not p) -> q) -> ((Not p) -> p) -> p
13:13:30 <lambdabot> -- f cannot be realized.
13:13:34 <ehird`> @djinn ((Not p) -> q) -> (q -> p) -> p
13:13:34 <lambdabot> -- f cannot be realized.
13:13:37 <ehird`> whut :(
13:13:42 <kmcallister> @djinn (p, Not p) -> q
13:13:43 <lambdabot> f (a, b) = void (b a)
13:13:52 <smg> faxathisia: i mainly code python and perl for little tasks and at work java and c++
13:14:09 <byorgey> kmcallister: o.O
13:14:31 <faxathisia> (,) is and/product
13:14:37 <kmcallister> which is also logical and
13:14:49 <kmcallister> @djinn Either a (Not a)
13:14:49 <lambdabot> -- f cannot be realized.
13:14:59 <faxathisia> void is False elimiation
13:15:29 <byorgey> hm, what type does Not p correspond to?
13:15:31 <kmcallister> @djinn (a -> b) -> (b -> a) -> Either (a, b) (Not a, Not b)
13:15:32 <lambdabot> -- f cannot be realized.
13:15:35 <kmcallister> byorgey, p -> Void
13:15:41 <kmcallister> where Void is an uninhabited type
13:15:49 <byorgey> ok, I see.
13:15:55 <psykon> hey guys
13:16:09 <psykon> when changing preferences on haskell.org, choosing Simple fucks up the website completely
13:16:16 <psykon> at least on firefox
13:16:30 <byorgey> and void :: Void -> a ?
13:16:43 <monochrom> Yes.
13:16:47 <allbery_b> very few sites using mediawiki bother to make the non-default template work, in my experience.  deal.
13:16:51 <byorgey> weird =)
13:17:02 <kmcallister> from a falsehood anything can be proven
13:17:02 <faxathisia> oops void is False introduction actually isn't it?
13:17:46 <byorgey> yes, I'm quite familiar with logic, just trying to understand how it's being embedded in the type system
13:17:57 <kmcallister> hmm, i believe you can also use type Void = forall a. a; rather than type Void;
13:18:00 <kmcallister> in which case void is easier to write
13:18:07 <kmcallister> @where curry howard
13:18:08 <lambdabot> http://www.informatik.uni-kiel.de/~mh/curry/
13:18:08 <roconnor> conal: why does phooey now depend on reactive?
13:18:11 <psykon> allbery_b: but now i can't change it back
13:18:15 <faxathisia> I forgot which is elim and intro...
13:18:27 <kmcallister> err, that didn't work
13:18:36 <monochrom> There exists a unique function from the empty type to your type.
13:18:46 <Philippa> byorgey: it isn't embedded - it /is/ the type system
13:19:08 <kmcallister> byorgey, http://en.wikipedia.org/wiki/Curry-Howard_correspondence
13:19:09 <byorgey> Philippa: ok, right, good point.
13:19:54 <monochrom> If I may use sets, there exists a unique function from the empty set to your set. It is the empty function.
13:20:14 <byorgey> hm, how is void :: Void -> a  inhabited?
13:20:28 <byorgey> I mean, how is Void -> a inhabited
13:20:38 <monochrom> void is the sole inhabitant :)
13:20:54 <faxathisia> void is either false elimination or introduction
13:20:59 <faxathisia> I don't know which...
13:21:03 <kmcallister> byorgey, with data Void; it's void x = case x of {}, but that's not legal haskell
13:21:33 <kmcallister> with data Void = Void (forall a. a), it's void (Void x) = x
13:22:09 <monochrom> (should be newtype there. :) )
13:22:18 * monochrom was caught once :)
13:22:23 <kmcallister> yeah, it's true
13:22:46 <kmcallister> don't want any constructor overhead on your uninhabited types ;)
13:23:16 <roconnor> @src (>=>)
13:23:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:25:06 <psykon> heys guys, i can't change my skin back :|
13:25:14 <Lord_Illidan> skin?
13:26:41 <Lord_Illidan> What's the reason of the Int datatype when there's Integer?
13:26:52 <Lord_Illidan> memory consumption?
13:26:57 <Cin> yeah, and speeduh
13:27:20 <roconnor> how can I check what module the wxcore-0.10.1 package exports?
13:27:26 <Lord_Illidan> I like the concept of an infinite integer..I just calculated 200^100000 just for kicks :D
13:27:46 <dcoutts_> roconnor: ghc-pkg describe $pkg
13:27:47 <dons> >
13:27:50 <CosmicRay> Lord_Illidan: yes, but keep in mind this could cause a denial of service attack in some cases ;-)
13:27:51 <dons> > 200^100000
13:27:55 <lambdabot>  9990020930143845079440327643300335909804291390541816917715292738631458324642...
13:28:00 <Lord_Illidan> heh :D
13:28:13 <roconnor> right Graphics.UI.WXCore is exposed
13:28:16 <Lord_Illidan> dons, it occupies 41 pages in Open Office
13:28:25 <dons> heh
13:28:27 <Cin> haha
13:28:29 <glguy> heh
13:28:30 <roconnor> but I still get  Could not find module `Graphics.UI.WXCore'
13:28:58 * roconnor grumbles
13:29:13 <smg> is there a builtin function for product?
13:29:28 <Lord_Illidan> I wrote my own, dunno
13:29:32 <sieni> > product [1..10]
13:29:33 <lambdabot>  3628800
13:29:48 <roconnor> > product [1..10] :: Expr
13:29:49 <lambdabot>  1 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10
13:29:55 <Lord_Illidan> sry, thought you were referring to power, my bad
13:29:58 <permanente> (which is just foldl (*) 1
13:30:07 <Lord_Illidan> isn't that just factorial?
13:30:14 <Cin> yeah
13:30:24 <permanente> > 3 ** 4
13:30:25 <lambdabot>  81.0
13:30:29 <permanente> but thats Double
13:30:36 <permanente> @type (**)
13:30:52 <Lord_Illidan> hmm, I already knew about that
13:30:52 <Cin> :t (**)
13:30:52 <lambdabot> forall a. (Floating a) => a -> a -> a
13:30:52 <lambdabot> forall a. (Floating a) => a -> a -> a
13:30:56 <smg> sieni: lol
13:31:03 <Lord_Illidan> >200 ** 100000
13:31:13 <lament> > product [1..]
13:31:16 <permanente> so what exactly are you looking for smg?
13:31:19 <lambdabot> Terminated
13:31:23 <lament> > product [1..] :: Expr
13:31:26 <lambdabot> Terminated
13:31:29 <smg> permanente: nothing i thought prodcut wouldn't exist
13:31:31 <Lord_Illidan> oops :S
13:31:31 <smg> http://rafb.net/p/DUEw6B53.html <-- :)
13:31:32 <lambdabot> Title: Nopaste - stdin
13:31:40 <smg> my first snippets of haskell code
13:32:21 <Cin> great success
13:32:23 <lament> smg: now, do you see how these two functions are essentially the same, just with a different operation?
13:32:29 <lament> smg: (mySum and myProduct)
13:33:07 <roconnor>     Bad interface file: /usr/local/lib/imports/Graphics/UI/WX.hi
13:33:07 <roconnor>         mismatched interface file versions: expected 6061, found 6060
13:33:10 <smg> Cin: haha you're ironically :)
13:33:10 <roconnor> crap
13:33:13 <psykon> is anyone here responsible for haskell.org ?
13:33:15 <roconnor> so much for my shortcut
13:33:54 <Lord_Illidan> wierd, I got told off for using the function name length
13:33:55 <shapr> psykon: Is something broken on haskell.org?
13:34:26 <dons> psykon: why?
13:34:42 <Lord_Illidan> Ambiguous variable occurrence "length".. I thought that functions could be overloaded
13:35:04 <jstanley> I'm attempting to compile and older haskell library under ghc 6.6.1, and there's an explicit dependency on the 'concurrent' package.  Can someone tell me where I can find that?
13:35:18 <jstanley> Is it part of base?
13:35:31 <roconnor> ahhhhhhhhhhhhhhhhhhhhhhhhhh!
13:35:37 <dons> jstanley: its in base.
13:35:53 <jstanley> dons: thanks.
13:36:05 <dons> i didn't know we'd actually moved to a separate concurrent package yet..
13:36:58 <Lord_Illidan> :t length
13:36:59 <lambdabot> forall a. [a] -> Int
13:37:03 <psykon> shapr: yes
13:37:08 <Lord_Illidan> ah, oops :S
13:37:13 <roconnor> make: *** No rule to make target `/usr/lib/gcc/i486-linux-gnu/4.1.2/../../../../include/c++/4.1.2/string', needed by `out/wxc/ewxw_main.o'.  Stop.
13:37:21 <psykon> dons: because i changed my profile to "Simple" and it's broken and now i can't change back
13:37:23 * roconnor cries
13:37:44 * monochrom gives roconnor a lambda cookie
13:37:46 <lenbust> you'll get there, roconnor
13:38:32 <monochrom> Thank God I used "Preview" to try out "Simple" :)
13:38:41 <shapr> psykon: profile?
13:38:51 <monochrom> Skin.
13:38:59 <shapr> Oh, the haskellwiki skin?
13:39:03 <monochrom> Ja!
13:39:10 <shapr> jasaa
13:40:23 <ehird`> i think when make says 'Stop.'
13:40:24 <ehird`> you do it
13:40:42 <psykon> shapr: ja!
13:40:59 <olsner> roconnor: it's probably just your dependencies that are broken (and e.g. pointing at a string file from the wrong gcc version)
13:41:25 <olsner> Ja?
13:41:26 <roconnor> olsner: how do i fix iy?
13:41:30 <roconnor> it
13:41:54 <olsner> depends on how your makefile discovers dependencies, I guess...
13:42:29 <roconnor> oh, make clean!
13:42:32 <roconnor> :D
13:42:37 <roconnor> I tried make distclean
13:42:42 <roconnor> that didn't work
13:42:51 <shapr> psykon: Last I heard, Ashley Yakely is the maintainer for haskellwiki, maybe he's the one to ask?
13:42:59 <olsner> oh, I'd have thought distclean included clean
13:43:08 <roconnor> olsner: that's what I thought
13:43:14 <roconnor> apparently not
13:45:21 <roconnor> well we are making progress now
13:45:30 * roconnor munches on lambda cookie
13:45:47 <roconnor> good thing I still have my /usr/local/src/wxhaskell
13:45:48 * olsner wants lambda cookies too!
13:46:09 <roconnor> in principle I just need to rebuild it and it will work again
13:48:32 * monochrom gives olsner a recipe for lambda cookies.
13:48:56 <monochrom> Give a haskeller a lambda cookie, and you feed him for a day.
13:49:45 <monochrom> Give him a recipe, and he will blog on how to express it more and more abstractly for the rest of his life!
13:51:14 * Botje has discovered several cool things about PLT scheme recently.
13:51:28 <Botje> for example: (x . >= . 2) is valid syntax
13:52:39 <olsner> for the expression (x (>=) 2)?
13:52:40 <psykon> shapr: where can i find him?
13:52:53 <Botje> for (>= x 2) , yes
13:53:08 <Botje> (note: scheme, not haskell)
13:53:26 <olsner> oh, it's infix notation? I thought it was some weird dotted list notation
13:53:50 <Botje> it's a reader hack
13:54:16 <Botje> and it doesn't scale to more than binary operators, unfortunately
13:54:21 <shapr> psykon: I don't remember his email address, but I'd guess there's some sort of about the haskellwiki page somewhere?
13:54:22 <bos> scheme with measles.
13:54:22 <faxathisia> that's a pretty horrible hack..
13:55:08 <Botje> we found all kinds of horrible things to do with it :)
13:55:08 <Botje> (foo . is-now-known-as . (lambda () ...))
13:55:22 <Botje> (cc . is-the-continuation-of . (begin ...))
13:55:43 <Botje> (assuming syntax definitions for those two
13:56:10 <monochrom> oh noes
13:57:46 <monochrom> (x . |-> . (x . + . 1))  mathematicians would love to write that for \x -> x+1
13:58:27 <Botje> :)
14:03:17 <Syzygy-> monochrom: Yech. And this is said with all the authority of a mathematician.
14:03:33 <monochrom> hehehe
14:04:03 <roconnor> woot, wxHaskell is reinstalled!
14:04:05 <roconnor> w00t
14:04:19 <monochrom> Please blog about your process! :)
14:04:54 <roconnor> monochrom: my process was take what happened to still be sitting in /usr/local/src/wxhaskell and rebuild it.
14:05:36 <radetsky> SamB: you there?
14:05:36 <ivan_> any 1 here
14:05:38 <radetsky> many1 here!
14:05:46 <monochrom> lambdabot is always here
14:05:52 <ivan_> i need to create a lift from IO a to m a
14:06:10 <monochrom> Look into "MonadIO" and "liftIO".
14:06:16 <radetsky> in any case, I'm messing with conjure, and there's some wierdness
14:06:29 <ivan_> i am using an data type of this type m q r a
14:06:43 <ivan_> monochrom: don't realy understand how to do that
14:06:47 <Lemmih> radetsky: Hi.
14:07:08 <radetsky> Lemmih: hey,
14:07:12 <radetsky> I guess I can ask you
14:07:19 <monochrom> Sadly, I don't understand your data type.
14:07:19 <byorgey> ivan_: you can't convert an IO a  into an arbitrary  m a  for any Monad m.  you can only do it for those which are an instance of the MonadIO type class.
14:07:56 <radetsky> I'm not too familiar with forkIO, but conjure does three of them during startup. However, it only does killThread on the server thread
14:07:58 <ivan_> byorgey: then if i make my monad an instance of monadIO how do i declare it
14:08:26 <roconnor> @tell conal GuiTV-3.0 doesn't seem to work with Phooey 1.4
14:08:27 <lambdabot> Consider it noted.
14:08:30 <radetsky> this seems wrong somehow
14:08:57 <monochrom> "instance MonadIO (your type here) where liftIO xxx = your code here"
14:08:59 <byorgey> ivan_: instance MonadIO blah where liftIO = ...
14:09:03 <dons> radetsky: that's fine. they're daemonic threads
14:09:08 <shapr> When was the last time conjure was updated?
14:09:09 <dons> they all exit when the main thread exits
14:09:11 <byorgey> ivan_: see http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Trans.html#t%3AMonadIO
14:09:12 <lambdabot> http://tinyurl.com/yqbbla
14:09:21 * dcoutts_ hands out ohloh kudos
14:09:33 <radetsky> dons: then why do they kill the server explicitly?
14:09:45 <monochrom> Since I don't understand your data type, I don't have any advice on how to write that code, or whether there are better ways.
14:10:39 <ivan_> byorgey: yes i know that but i have the problem with typing my code part
14:10:40 <roconnor> @tell conal GuiTV-2.0 also doesn't seem to work with Phooey 1.4
14:10:41 <lambdabot> Consider it noted.
14:10:54 <Lemmih> radetsky: Conjure has been designed as a library. Any UI is just there for testing purposes.
14:11:13 <byorgey> ivan_: well, without knowing more about your particular type it's hard to offer specific help.
14:12:34 <radetsky> Lemmih: the server explicitly killed isn't the UI server
14:12:45 <ivan_> i have a datatype of m q r t = Return a | bla bla bla but i am not sure on the data type, can't i just add an data type like Lift(IO a)
14:12:47 <wy> I'm reading Modern Compiler Construction in ML, and wondering if the programs are really in ML...
14:13:21 <radetsky> I think
14:13:56 <byorgey> ivan_: in general, what are you trying to do?
14:13:58 <wy> They look like C code ;)
14:14:08 <Cin> bitchy
14:14:12 <Twey> Heh
14:14:30 <faxathisia> wy, Do you intend to write a compiler for something?
14:14:52 <Lemmih> radetsky: I meant any kind of user interface. Conjure.hs is only there for testing.
14:14:53 <Cin> twey: how's your haskell learnings?
14:15:04 <wy> faxathisia: I'm taking a compiler class, and yes I'm going to write some real compilers later
14:15:11 <Twey> Cin: Not bad.  I've got basic monads down now :-P
14:15:13 <faxathisia> wy, Cool, for what?
14:15:14 <radetsky> ahh
14:15:21 <Cin> twey: awesome :D
14:15:47 <ivan_> i have to be able to type do{x <- lift(putStrLn "somethin")} for my data type and later on in the run function to run the putStrLn part
14:15:48 <wy> faxathisia: No idea yet. But this is useful in general
14:16:31 <wy> faxathisia: The compilers deserve a study in their own right
14:16:35 <byorgey> ivan_: right, and what other functionality do you want in your monad, and why?
14:16:46 <byorgey> ivan_: can you just combine some of the standard monad transformers?
14:17:06 <wy> faxathisia: I'm interested in partial evaluation
14:17:12 <ivan_> maybee but it is more intressting in doing it from scratch =) u learn more
14:18:07 <ivan_> byorgey: other function is that when it comes to w <- ask "dsda" the program has to stop and return the current state of all results and answers
14:18:56 <radetsky> anyway, I noticed that Conjure doesn't handle multi-file torrents properly
14:19:20 <byorgey> ivan_: well, ok, writing it from scratch is fine, but in that case if I were you I'd spend some time studying the source code for MonadIO and various monad transformers, etc.
14:19:26 <dcoutts_> any windows cabal-install users around? want to make sdist work on windows?
14:19:38 <radetsky> If a torrent is supposed to create files under a directory that doesn't exist, it will fail
14:19:40 <Lemmih> radetsky: It doesn't create the containing directories.
14:20:39 <radetsky> I could try to fix it
14:23:03 <faxathisia> You could add data ... deriving Catamorphism couldn't you?
14:23:34 <faxathisia> actually I don't think that could type..
14:25:39 <faxathisia> does GHC have a parser for haskells data declarations available to users?+
14:25:51 <dons> dcoutts_: on every project that links against a C lib, i need a configure script with this in it:
14:25:54 <dons> if test -n "$CPPFLAGS" ; then
14:25:56 <dons>     echo "Found CPPFLAGS in environment: '$CPPFLAGS'"
14:25:59 <dons>     sed 's,@CPPFLAGS@,'"$CPPFLAGS"',g;s,@LDFLAGS@,'"$LDFLAGS"',g'  \
14:26:01 <dons>         < fastcgi.buildinfo.in > fastcgi.buildinfo
14:26:02 <shapr> radetsky: Go for it!
14:26:03 <dons> dcoutts_: seems like something Cabal should know about instead.
14:26:05 <dons> fi
14:26:26 <dcoutts_> dons: can you specify it more clearly and file a feature request? :-)
14:26:46 <dons> dcoutts_: yes. will do.
14:26:54 <roconnor> @seen conal
14:26:55 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
14:26:58 <dcoutts_> dons: what is that doing exactly, and is it the same as this ticket...
14:27:19 <dons> its adding -I/usr/local/include -L/usr/local/lib
14:27:26 <dcoutts_> dons: http://hackage.haskell.org/trac/hackage/ticket/221
14:27:28 <lambdabot> Title: #221 (need a way to specify site-specific include and library search paths) - Ha ...
14:27:35 <dons> right-o
14:28:01 <dcoutts_> dons: looks like it's the same, perhaps you can comment on that bug, anything that clears up the specification, what should the UI be etc
14:28:23 <dons> having them in env vars is nifty, since its cheap to add new paths to look inn
14:28:48 <dons> and i already have those set up for gcc
14:28:54 <dcoutts_> dons: how would you expect to use it, that's helpful to whoever implements it. (And clearer specs make it more likely for random hackers to look and say "oh, that's easy!" and send us patches)
14:29:07 <dons> yep. ok.
14:29:34 <bos> -ETOOMANYHALFBAKEDLIBRARIESONHACKAGE
14:29:57 <idnar> The CPAN Effect
14:30:03 <radetsky> Lemmih: are you still interested in working on Conjure, and if so would you be willing to help me out occasionally?
14:30:18 <radetsky> I'm fairly new
14:30:18 <dcoutts_> bos: automated QA is the answer methinks
14:30:21 <dons> the grand quality control mincer will be at work soon
14:30:28 <dons> mince in, sausages out
14:30:48 <bos> dcoutts_: it's more than that. it would really be nice to have e.g. one network library that supports bytestrings, etc.
14:30:49 <Lemmih> radetsky: Sure, I can help you out.
14:31:06 <dons> one http library that supports bytestrings. one xml library that supports bytestrings...
14:31:22 <bos> one packed string library that supports unicode.
14:31:43 <dons> one json library that supports bytestrings, one web framework EDSL based on fastcgi, one bytestring db binding that doesn't make my eyes bleed
14:31:44 <dcoutts_> bos: I think we'll start to see more amalgamation, just getting everything out there to start with is a good first step, to allow experimentation then consolidate the tested designs
14:31:45 <radetsky> cool, thanks
14:32:06 <dons> yes, we are approaching consolidation.
14:32:13 <radetsky> I think I'm doing all right figuring stuff out on my own so far, but I don't know if this will last as I get into more sophisticated stuff
14:32:14 <pejo> dons, do you mean CPPFLAGS there, or CFLAGS?
14:32:18 <dcoutts_> bos: once we have a range of things to work with we can start defining subsets with automatic and manual quality reviews, stacks that work together etc
14:32:21 <dons> CPPFLAGS, yep.
14:32:43 <bos> the lack of decent fast unicode is a problem. that means that people will start using bytestring for XML and HTML libraries, where it's really not appropriate.
14:33:06 <dons> yes. that's getting annoying.
14:33:13 <dcoutts_> bos: hopefully a Msc student I'm working with will do that project
14:33:20 <bos> i'd work on a unicode library (i've started one twice), only for the damn book. it really needs lots of time and attention.
14:33:38 <dcoutts_> @seen sioraiocht
14:33:38 <lambdabot> sioraiocht is in #scala, #haskell-blah and #haskell. I don't know when sioraiocht last spoke.
14:33:38 <bos> damn you, pre-existing commitments!
14:33:46 <sioraiocht> hello
14:34:04 <sioraiocht> what am I doing? heh
14:34:06 <sioraiocht> oh
14:34:07 <sioraiocht> fast unicode
14:34:08 <sioraiocht> yes
14:34:08 <sioraiocht> I am
14:34:11 <dcoutts_> sioraiocht: you've got customers :-)
14:34:42 <sioraiocht> oege signed the paper today, lol
14:34:42 <bos> sioraiocht: excellent.
14:34:42 <sioraiocht> oooh
14:34:42 <bos> sioraiocht: just don't use UTF-16 internally, and everything will be all right :-)
14:34:44 <sioraiocht> i'll keep that in mind ;)
14:35:39 <dons> sioraiocht: oh, you're committed?
14:35:50 <sioraiocht> dons: aye
14:35:56 <sioraiocht> is that a problem? ;)
14:35:56 <dons> awesome. load another phd into spj's shotgun
14:36:05 <bos> sioraiocht: is that the focus of your MSc?
14:36:08 <sioraiocht> hahah that's my MSc dissertation
14:36:18 <bos> ok, not just some incidental thing :-)
14:36:45 <sioraiocht> dons: that's my MSc, by PhD will be on refinement types
14:36:49 <bos> i assume you'll be using the stream fusion framework, etc?
14:36:50 <sioraiocht> possibly in haskell
14:37:19 <sioraiocht> bos: yes
14:37:36 <ehird`> anyone do web programming with haskell outside of happs?
14:37:40 <conal> roconnor: trouble with Phooey & GuiTV?
14:37:40 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:37:42 <bos> it's rather a bit nicer than the fusion framework currently used by bytestrings.
14:37:52 <ehird`> if so, what do you do when using e.g. fastcgi/scgi to avoid the compile, move binary in, reload server cycle?
14:38:10 <roconnor> conal: yep, the dependencies on hackage are a broken, so that is a bit misleading
14:38:11 <dcoutts_> bos: aye, that's still on our todo list
14:38:17 <dons> ehird`: sure. we just do the compile, move binary in, reload cycle
14:38:28 <ehird`> dons: :(
14:38:28 <dons> ehird`: you could consider state serialisation too
14:38:38 <ehird`> heh
14:38:50 <roconnor> conal: but then I discovered that the version of GuiTV in hackage has almost nothing in it
14:38:51 <dons> so move in, in the background, then exec
14:39:05 <sioraiocht> dcoutts_: speaking of PhDs...Ralf has dropped off the face of the earth.
14:39:26 <wy> sioraiocht: It seems CMU does lots of type theory
14:39:32 <dcoutts_> sioraiocht: I know, have you emailed him asking what he wants us to be doing?
14:39:37 <conal> roconnor: right.  GuiTV is a tiny bit of code on Phooey & TV
14:39:46 <radetsky> suppose there's a function buried way deep in some module, and I want to see how it's used by the top-level flow of the program. Is there a tool to help out with this, or do I just stare harder at the source?
14:39:48 <roconnor> conal: only islider?
14:39:50 <conal> roconnor: TV itself doesn't depend on Phooey or wxhaskell
14:39:51 <dcoutts_> sioraiocht: I'll email him too I guess.
14:39:55 <sioraiocht> dcoutts_: i did a while ago
14:40:01 <sioraiocht> perhaps a gentle reminder is in order
14:40:03 <ehird`> anyone else? :-P
14:40:03 <roconnor> conal: the darcs version of GuiTV has many widgets
14:40:04 <dcoutts_> sioraiocht: ok, I'll do so now
14:40:16 <roconnor> conal: the hackage version just has a slider.
14:40:32 <dons> ehird`: what problem are you looking to avoid?
14:40:34 <bos> oh! speaking of CPAN, i got a dump of the most oft-reviewed packages on CPAN.
14:40:43 <conal> roconnor: odd.  does the hackage version have Interface.TV.UI
14:40:46 <ehird`> dons: tedium & general ugliness
14:40:47 <dons> oh, sounds useful, bos.
14:40:56 <bos> i thought it would be interesting to mine it and see what packages we're missing that the perl hackers love.
14:40:57 <dons> ehird`: what other options are there?
14:41:06 <ehird`> dons: beats me.
14:41:26 <ehird`> i was working on a runcgi which recompiled if needed and cached compiled cgis, but that won't work now that i'm using fcgi/scgi
14:41:26 <roconnor> conal: yes, but the file is quite small
14:41:29 <sioraiocht> dcoutts_: IIRC he teaches this month at oxford, he might be preparing
14:41:37 <ehird`> what i need to write is Network.GenericCGI so I can plug it into a haskell webserver
14:41:38 <roconnor> module Interface.TV.UI
14:41:38 <roconnor>   (
14:41:38 <roconnor>      islider , runUI
14:41:38 <roconnor>    , UI, module Interface.TV            -- re-exports
14:41:38 <roconnor>   ) where
14:41:39 <conal> roconnor: i'll take a look.  thanks.
14:41:40 <dcoutts_> bos: that would be interesting info
14:41:42 <ehird`> then i just need to restart the app using runhaskell#
14:41:47 <ehird`> actually
14:41:53 <ehird`> i could even make it restart when the file changes
14:41:54 <cjb> bos: you could also use the debian package popularity, since they package each CPAN module as a Debian package.
14:41:55 <shapr> Is runhaskell# for .NET?
14:41:59 <conal> roconnor: maybe i forgot to make a new package.
14:42:06 <ehird`> shapr: haha
14:42:11 <bos> cjb: nice idea
14:42:48 <roconnor> conal: I now have one more problem
14:43:07 <roconnor> NominationGUI.hs:47:20:
14:43:08 <roconnor>     No instance for (Data.FunArr.FunArr ~>
14:43:08 <roconnor>                                         ((Control.Compose.:*:) (Output UI IU) Control.Compose.Id))
14:43:08 <roconnor>       arising from use of `->|' at NominationGUI.hs:47:20-43
14:43:22 <radetsky> is there some way to pull up a list of callers of a function in emacs?
14:43:25 <Cin> argh. i can't get any database libraries to build @_@!!
14:43:31 <roconnor> conal: this error occurs in my code that uses GuiTV.
14:43:53 <conal> roconnor: could you send me the code?
14:44:00 <roconnor> conal: the function is optimizeMarketsTV = marketsTV ->| optimizeTV
14:44:03 <conal> roconnor: i wonder why (~>) isn't bound
14:44:14 <roconnor> marketsTV :: TV UI IU (Markets -> Markets)
14:44:25 <roconnor> optimizeTV :: TV UI IU (Markets -> Claim -> Int -> (Double, Double))
14:45:00 <ehird`> heur.. i don't want to write network.genericcgi
14:45:00 <ehird`> :P
14:45:01 <roconnor> I don't know where the Data.FunArr.FunArr instance should even be.
14:45:15 <conal> roconnor: i'll release another GuiTV version and let you know.
14:45:25 <conal> roconnor: then you can try again.  maybe you could give me your code also.
14:46:23 <roconnor> conal: I should mention that I'm not using Phooey-2.0
14:46:28 <roconnor> conal: it scares me
14:46:48 <conal> roconnor: oh.  then you won't be able to use my GuiTV release.
14:47:04 <roconnor> conal: exactly
14:47:20 <roconnor> conal: that is why I was looking for a nice older version of GuiTV
14:47:28 <conal> roconnor: what scares you about Phooey-2.0?
14:47:31 <roconnor> maybe I need to rollback some patches
14:47:51 <roconnor> conal: ``Because this library uses reactive, compile apps with -threaded.
14:48:19 <conal> roconnor: oh.  hm.  i don't think that's necessary any longer.
14:48:34 <roconnor> still, it is scary
14:48:35 <conal> roconnor: btw, why worry about -threaded?
14:48:48 <Cin> , stmtGetCol :: forall a . Int -> FieldDef -> (FieldDef -> CString -> Int -> IO a) -> IO a
14:48:50 <roconnor> I don't know.  Irrational fear
14:48:52 <Cin> Database/HSQL/Types.hs:134:18: Not in scope: type variable `forall'
14:48:56 <Cin> i don't understand this error?
14:48:58 <conal> roconnor: yeah -- reactive is terrifically multithreaded.
14:49:05 <roconnor> :(
14:49:16 <roconnor> conal: and you said that your reactive lib had race conditions in your blog
14:49:18 <conal> :( ?? ):
14:49:27 <roconnor> conal: that also scared me
14:49:34 <Cin> :t (:(??):)
14:49:35 <lambdabot> parse error on input `)'
14:49:59 <conal> roconnor: simultaneous (or very nearly) occurrences might get reordered.  that's the issue.
14:50:13 <conal> roconnor: i'm still noodling on a fix.
14:50:28 <byte-> hola
14:50:31 <roconnor> :( ?Â¿ ):
14:51:01 <conal> roconnor: on the plus side, reactive & Phooey 2.0 are *purely* functional, unlike DataDriven & Phooey 1.4.
14:51:03 <ehird`> is HaskellDB alive?
14:51:13 <Cin> i couldn't build it
14:51:16 <Cin> so i'm trying hsql
14:51:20 <roconnor> conal: what isn't purely functional?
14:51:23 <Cin> can't seem to build it either
14:51:32 * Cin this close to using php
14:51:49 <dcoutts_> Cin: don't try hsql it does not build
14:51:57 <dcoutts_> Cin: try hdbc or tauksen
14:51:59 <roconnor> conal: anyhow, should this instance be something in TV?
14:52:02 <conal> roconnor: everything cumulative in DataDriven and Phooey 1.4
14:52:28 <Cin> dcoutts_: oki
14:52:44 <ehird`> Cin: re: php - me too
14:52:53 <roconnor> conal: I don't see GuiTV or phooey having anything to do with the missing instance.
14:52:56 <ehird`> but my php apps never scale up when they get bigger
14:52:58 <Cale> conal: You mentioned that you couldn't see a way to avoid nesting atomically in your implementation of Futures by STM?
14:53:19 <conal> Cale: yes.
14:53:42 <Cale> conal: That's interesting -- what would nested copies of atomically do?
14:54:03 <Cale> (of course, they're forbidden by the type system...)
14:54:51 <Cin> ehird`: indeed. i hate coding in php, it's just easy to setup
14:54:57 <ehird`> Cin: yeah
14:54:59 <conal> roconnor: there's an oddness in the semantics of instance re-exporting.  you might need another module import.
14:55:07 <Cin> ehird`: (or easy to find in free hosting etc)
14:55:15 <ehird`> if i could develop web apps kind of like php, but let one haskell package serve multiple files on a regexp i'd love it
14:55:23 <roconnor> conal: that's what I figure
14:55:26 <ehird`> kind of like a mini-webframework, but handled all for me by dropping stuff ina directory
14:55:29 <DRMacIver> Cin, ehird`: There are a lot of options in between php and Haskell. :)
14:55:33 <roconnor> conal: I thought you may know what module I need to import.
14:55:36 <ehird`> DRMacIver: All of them suck.
14:55:47 <ehird`> (takusen doesn't support mysql? wtf)
14:55:53 <conal> Cale: they'd do what Data.Reactive does in IO.
14:56:08 <DRMacIver> ehird`: Everything sucks. The trick is to find things that suck the least in the areas you care about. :)
14:56:13 <ehird`> DRMacIver: Haskell.
14:56:18 <Cin> i've used plt-web-server which was quite nice but its garbage collection is cyclic and tends to eat up memory a lot of the time, and i'm kind of -using- this computer, so..
14:56:35 <conal> roconnor: found in GuiTV/src/Examples.hs:  import Interface.TV.OFun()
14:56:41 <Botje> ehird`: write Haskell on Horses or somesuch :)
14:56:46 <shapr> heh
14:56:47 <DRMacIver> ehird`: Apparently you care about ease of deployment, availability of good mature web development and database libraries...
14:56:48 <Cin> Botje: heh
14:56:50 <shapr> Haskell on Heat?
14:56:50 <conal> roconnor: "-- To pick up the FunArr instance for OFun."
14:56:53 <ehird`> Botje: brilliant
14:56:57 <DRMacIver> ehird`: Want to rethink that? :)
14:56:57 <Cale> conal: I would tend to think that if you wanted to atomically carry out some STM action in the course of another, you could just use bind, no?
14:57:08 <ehird`> DRMacIver: I don't care about ease of deployment. Just development.
14:57:12 <DRMacIver> ok
14:57:12 <ehird`> And the libraries: I can handle that.
14:57:18 <Botje> Haskell in Hiding -- probably won't make for a good web framework :)
14:57:20 <DRMacIver> Then why the php temptation? :)
14:57:27 <Cale> (since the whole thing is inevitably going to occur as-if-atomically anyway?)
14:57:28 <ehird`> DRMacIver: because it's far easier to develop
14:57:40 <ehird`> with haskell i have to jump through hoops each time i modify my app right now
14:57:48 <ehird`> in every other way it's superior
14:57:53 <Botje> Haskell on Hoops! brilliant!
14:57:57 <roconnor> conal: I have import Interface.TV.OFun()
14:58:09 <conal> roconnor: hm.
14:58:29 <conal> roconnor: how about giving Reactive+phooey 2.0 a try?
14:58:41 <roconnor> conal: hmm
14:58:53 <Cale> oh, hmm... there's an unsafePerformIO here :)
14:58:53 <Cin> woo HDBC builds
14:59:10 <ehird`> Botje: haskell in hoops
14:59:20 <ehird`> haskell slightly around hoops
14:59:28 <dcoutts_> dons: so what do you think we should be doing for state management on hackage?
14:59:30 <DRMacIver> ehird`: Fair enough.
14:59:57 <dcoutts_> dons: we've got the archive of tarballs and .cabal files and it's obvious that we're going to want lots and lots more info about packages in future
15:00:25 <dcoutts_> dons: so do we go for a db or flat files or something else like happs's state management style
15:00:25 <DRMacIver> I'm somewhat skeptical of claims along the lines "X is so much easier than Y to develop with but Y is way better than X", but I won't press the point. :)
15:00:50 <ehird`> DRMacIver: as soon as i get this reloading problem sorted, it'll be beautiful
15:00:54 <dcoutts_> dons: bearing in mind our aim to make deployment easy. It's not obvious.
15:00:58 <ehird`> now, what's the most capable haskell WS out there?
15:01:02 <wy> sioraiocht: Does refined types only exist in the compiler?
15:01:39 <dcoutts_> g'evening nominolo
15:01:41 <roconnor> conal: what is missing is the thing that says that x :*: y is an instance of FunArr unders suitable circumstances.
15:01:57 <nominolo> @pl (\(l,r) -> (lift $ lift $ SAT.getModelValue l))
15:01:57 <lambdabot> lift . lift . (SAT .) . getModelValue . fst
15:02:02 <roconnor> conal: should that be in DeepArrow?
15:02:04 <nominolo> @pl (\(l,r) -> (lift $ lift $ getModelValue l))
15:02:04 <lambdabot> lift . lift . getModelValue . fst
15:02:11 <conal> roconnor: oh!  i'll poke around to find it.
15:02:12 <dcoutts_> nominolo: heh :-)
15:02:15 <nominolo> d'oh
15:02:21 <conal> roconnor: probably in DeepArrow
15:02:23 <sioraiocht> wy: pardon?
15:02:27 <nominolo> my scheduler is buggy
15:02:42 <dcoutts_> nominolo: :-( the instruction scheduler
15:02:43 <roconnor> conal: I'll try to get the darcs version of DeepArrow
15:02:47 <wy> sioraiocht: I asked you because you mentioned that you will do refinement types
15:02:59 <conal> roconnor: see Data.FunArr in DeepArrow
15:03:13 <nominolo> dcoutts_: yes. it fails to find a schedule in some cases.  which is weird
15:03:16 <ehird`> would anyone be interested in Network.GenericCGI?
15:03:17 <sioraiocht> yeah, my thesis is on creating a refinement type language and making it statically decideable
15:03:22 <conal> roconnor: you may need another import
15:03:22 <nominolo> dcoutts_: it could take forever, but not foil
15:03:30 <nominolo> *fail
15:03:31 <ehird`> (like Network.CGI, but with the same interface can do fastcgi, scgi, haskell web server, ...)
15:03:44 <dcoutts_> nominolo: because there should always be a schedule?
15:03:52 <roconnor> conal: I see it in the darcs version but not in the hackage version
15:03:59 <roconnor> conal: so that is probably my issue
15:04:06 <nominolo> dcoutts_: at least that's what i thought.  maybe i'm being too agressive
15:04:13 <sioraiocht> wy: I don't unerstand your question, though
15:04:25 <roconnor> conal: you need to work on you hackage libs ;)
15:04:35 <conal> roconnor: what's your DeepArrow version?
15:04:35 * dcoutts_ knows very little about instruction scheduling
15:04:51 <roconnor> conal: the one from darcs is 0.1
15:04:58 <roconnor> conal: the one from hackage is 0.01
15:05:00 <roconnor> conal: the one from hackage is 0.0.1
15:05:30 <conal> roconnor: oops -- i'll make a new hackage package.  thx.
15:05:34 <wy> I mean, when we use HM type system, the programmers actually do something for the types. I looked at Freeman's thesis, and it seems that refinement types is something inside the compiler and the user doesn't need to do something for it
15:05:36 <nominolo> dcoutts_: yeah, i'll stop whining now :)
15:06:02 <dcoutts_> nominolo: heh, sorry I can't help :-)
15:06:26 <wy> It just gives more useful warning information. I don't know if my understanding is accurate
15:06:34 * dcoutts_ hopes we'll get the sun server and that nominolo can fix the sparc ncg
15:06:42 <nominolo> me?
15:06:53 <dcoutts_> nominolo: are you not the ideal candidate?
15:07:06 <nominolo> i guess, but under what umbrella?
15:07:10 <nominolo> er
15:07:21 <dcoutts_> nominolo: not sure yet, still working on the details
15:07:25 <nominolo> i mean, what lead
15:07:29 <nominolo> ok
15:07:43 <sioraiocht> wy: no.  the point of refinement types is to implement more specific conditions on types that can be verified (in my case at compile time).  refinement types have traditionally, for example, taken the the form of boolean expressions, so, for example, a refinement type is Int {x | x > 4} for all integers greater than 4
15:08:05 <sioraiocht> and those refinements are annotated by the programmer
15:08:16 <wy> got it. thanks
15:08:22 <byte-> lol
15:08:29 <sioraiocht> np
15:08:33 <byte-> if I understand you correctly, my language has "refined types."
15:08:43 <byte-> they're not checked at compile time, though.
15:08:52 <wy> so it's like that the assertions are checked statically
15:09:11 <byte-> refined types imply a dependent type system, correct?
15:09:30 <dcoutts_> nominolo: lead? I'm guessing the people who organise the GSoC will advertise and pick a candidate. The main uncertainty is the funding source.
15:10:25 <nominolo> dcoutts_: oh, you mean me being the mentor?
15:11:37 <nominolo> dcoutts_: the problem was that i couldn't do it myself - at least as part of a possible WSR internship
15:11:45 <ehird`> 'Int {x | x > 4}' jesus
15:11:48 <ehird`> my language has that
15:11:49 <ehird`> :O
15:12:01 <ehird`> (silly thing i invented to make about 3 problems tiny)
15:12:19 <ehird`> you give it a domain, which is the valid types in the program, and how to solve a program with parameters in that domain
15:12:24 <nominolo> dcoutts_: I don't think i will do another SoC - at least not as student.  Well, at least it's unlikely ...
15:12:36 <roconnor> can cabal uninstall a package?
15:12:36 <ehird`> and 'Int {x | x > 4}' is '<Int>(x | x>4)'
15:12:52 <Saizan> roconnor: unregister at most
15:13:03 <roconnor> Saizan: my poor disk space
15:13:27 <conal> roconnor: http://hackage.haskell.org/packages/archive/recent.html
15:13:32 <Saizan> roconnor: use rm :)
15:14:08 <roconnor> conal: GuiTV doesn't give a version of DeepArrow required.
15:14:37 <conal> roconnor: thx.  i'll fix that.
15:15:28 <conal> roconnor: i don't know which DeepArrow it needs, so conservatively  i'm saying 0.2
15:15:36 <roconnor> sounds fair
15:16:18 <ehird`> HaskellDB - well maintained?
15:16:31 <conal> i imagine i'm not the only person who loses track of version dependencies.  i wonder if hackage could automate experiments that would discover them.
15:17:17 <ehird`> odd... drwxrwxr-x  2 www-data www-data and i'm in www-data, but can't modify stuff in that dir
15:22:07 <ehird`> :/
15:23:27 * roconnor is in versioning hell
15:23:47 <Botje> which one? 1.0 or 1.3 ?
15:24:11 <roconnor> Botje: 0.0.1
15:24:41 <roconnor> $ ghc --make -no-recomp NominationGUI.hs
15:24:49 <roconnor> [5 of 5] Compiling Main             ( NominationGUI.hs, NominationGUI.o )
15:24:50 <roconnor> Failed to load interface for `Control.Arrow.DeepArrow':
15:24:50 <roconnor>   no package matching DeepArrow-0.0.1 was found
15:24:56 <roconnor> how do I respond to this error
15:25:05 <roconnor> I just unregistered DeepArrow-0.0.1
15:25:11 <roconnor> I want it to use DeepArrow-0.1
15:25:19 <conal> roconnor: what does 'ghc-pkg list' show?
15:25:24 <roconnor> how does it even know about DeepArrow?
15:25:34 <Botje> roconnor: i'm guessing from the other .hi files?
15:25:38 <roconnor> conal: only DeepArrow-0.1
15:25:48 <roconnor> Botje: which ones??? ;)
15:26:13 <Botje> the .. ones created earlier? :P
15:26:14 <roconnor> conal: what depends on DeepArrow?
15:26:33 <roconnor> conal: TV, GuiTV, anything else?
15:26:44 <conal> roconnor: looking ...
15:27:05 <roconnor> I'd like to ask ghc-pkg this question
15:27:18 <conal> roconnor: me too!
15:27:27 <Saizan> roconnor: reconfigure maybe?
15:27:28 <conal> roconnor: i think just TV & GuiTV
15:27:43 <roconnor> Saizan: what reconfigure  ?
15:27:52 <conal> Saizan: good idea
15:27:59 <Saizan> roconnor: the package you're building which gives that error
15:28:13 <Saizan> roconnor: cabal probably caches resolved deps in .setup-config
15:28:15 <roconnor> Saizan: I'm not building a package, I'm building my own program
15:28:27 <conal> roconnor: rebuilt TV & GuiTV
15:28:33 <conal> roconnor: *rebuild*
15:28:37 <roconnor> conal: did that twice already
15:28:43 <conal> roconnor: re-configure
15:28:55 <roconnor> I did clean configure and build
15:28:58 <roconnor> and install
15:29:03 <roconnor> of TV ang GuiTV
15:29:10 <conal> roconnor: hm.  wipe out their .hi files?
15:29:17 <roconnor> how?
15:29:45 <conal> roconnor: do you have dist directories for TV & GuiTV?
15:29:46 <shachaf> conal: "clean" doesn't do that?
15:30:00 <roconnor> ah nevermind
15:30:01 <conal> shachaf: i don't know
15:30:06 <roconnor> I forgot to reinstall GuiTV
15:30:09 <roconnor> *sigh*
15:30:13 <roconnor> works fine now
15:30:17 <conal> roconnor: okay, cool
15:30:24 <roconnor> well
15:30:26 <roconnor> not so fine
15:30:38 <roconnor> Linking NominationGUI ...
15:30:38 <roconnor> /usr/local/lib/libwxc-gtk2.6.4-0.10.1.so: undefined reference to `wxGLCanvas::wxGLCanvas(wxWindow*, int, wxPoint const&, wxSize const&, long, wxString const&, int*, wxPalette const&)'
15:30:39 <roconnor> ...
15:30:48 * roconnor bashes head against lambdas
15:31:44 <roconnor> why does wxhaskell hate me so much?
15:32:03 <monochrom> Not just you. :)
15:32:04 <ddarius> roconnor: It's written in C++
15:32:14 <monochrom> It hates all humanity.
15:32:19 <Pseudonym> Lambdas are warm and fuzzy.  You can't bash your head against them.
15:32:40 <Pseudonym> It's written in OLD C++.
15:32:44 <conal> roconnor: has wxhaskell worked for you before?
15:32:44 <cygnus_> pointers are pointy?
15:32:54 <roconnor> conal: before I upgraded my OS
15:32:56 <Pseudonym> Old C++ is bad C++.
15:33:06 <conal> roconnor: oh.  eep.
15:33:06 <ddarius> Pseudonym: I don't think "modern" C++ would much help the linking issues, quite the opposite actually.
15:33:07 <roconnor> I'll try rebuilding wxGTK-2.6.4 I suppose
15:33:26 <conal> roconnor: btw, how's gtk2hs for you?
15:33:36 <roconnor> conal: works like a charm
15:33:58 <roconnor> conal: I was considering which would be easier, getting wxHaskell working again, or porting phooey to gtk2hs
15:34:02 <roconnor> conal: it's a tough call
15:34:55 <conal> roconnor: i'd switch to another lib (e.g., gtk2hs) if i heard consistently that it installed & worked for linux, osx, and windows.
15:34:59 <Axioplas1> Hi
15:35:45 <dmwit> Hi!
15:35:53 <conal> roconnor: and if i had an offer of expert help with the transition.
15:36:41 <roconnor> well, I'm not an expert, but I did work a bit on a translation a few months ago
15:37:27 <roconnor> ;( ghc --make has now deleted my working executable
15:37:34 <roconnor> that will motivate me
15:38:24 <hcube> hi, does have anybody a haskell syntax highlight description file for midnight commander's mcedit ?
15:39:34 <cjb> hcube: I was about to make fun of you for using a twenty year-old editor, but then I remembered that I'm typing this in emacs.
15:39:58 <conal> cjb: erc?
15:40:03 <cjb> yeah :)
15:40:11 * conal emacs-hi-fives cjb
15:41:07 <TSC> M-x high-five ?
15:41:08 <ddarius> I used MSDOS's edit.com for quite a while.
15:41:20 <shachaf> cjb: You can make fun of hcube for using the wrong twenty-year-old editor, though.
15:41:29 <cjb> http://chris.printf.net/pullcord-photo.jpg # I'm a bit of an emacs fanatic.
15:41:35 <cjb> shachaf: indeed!
15:41:39 <ddarius> shachaf: emacs isn't a twenty year old editor though
15:41:51 <cjb> darrint: 25?  :)
15:41:58 * Corun shortcuts the conversation
15:41:59 <cjb> s/darrint/ddarius/
15:42:02 <Corun> C-x M-x butterfly
15:42:35 <Corun> http://xkcd.com/378/
15:42:36 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
15:43:06 <shachaf> ddarius: How old is it, then?
15:43:26 <ddarius> "The original emacs ... written in 1976 ... "
15:43:42 <ddarius> So thirty year old (or 32 to be precise)
15:43:54 <cjb> I was thinking the GNU implementation in particular.
15:43:55 <shachaf> ddarius: That should still count.
15:44:02 * shachaf understood that as >=20.
15:44:21 <Saizan> cjb: how many inches is that screen?
15:44:29 <cjb> Saizan: 30.
15:44:50 <shachaf> Does vim count, or is it not close enough to vi?
15:45:12 <ddarius> shachaf: I would count it.
15:45:36 <hcube> hey :) i like mcedit's simplicity, i used to be an IDE user like kdevelop or visual c++
15:45:57 * shachaf is as old as his editor. :-)
15:46:43 <shachaf> Huh, it stood for "Vi IMitation" originally?
15:46:51 <ddarius> Yep
15:47:11 <ddarius> Also 1976 according to wikipedia (vi that is)
15:47:50 * monochrom is as old as his field of interest :)
15:48:11 * cjb is as old as his date of birth
15:48:18 * conal wonders if monochrom's field of interest is himself. ;)
15:48:32 <monochrom> Naw!
15:48:40 * conal chuckles
15:48:48 <ddarius> monochrom: It should be.
15:48:56 <hcube> other question: which haskell syntax highlight theme can i take as base to implement my mcedit's one ? kde's kwrite, emacs, or vim(if it has) ?
15:49:06 <conal> i bet a lot of people are exactly as old as their field of interest.
15:49:13 <Spark> vim has syntax hilighting for everything
15:49:17 * shachaf *is* his own editor, of course.
15:49:29 <bos> here's that list of popular perl packages: http://www.serpentine.com/blog/2008/02/19/peruse-popular-perl-packages/
15:49:31 <lambdabot> Title: teideal glic deisbhÃ©alach » Blog Archive » Peruse popular Perl packages, http://tinyurl.com/37sjs6
15:49:34 <ddarius> hcube: Practically any syntax highlighting editor will have syntax highlighting files for Haskell.
15:49:47 <monochrom> dons may be older than haskell.
15:50:11 <ddarius> Most people here are older than Haskell.
15:50:12 <monochrom> But I'm just +/- a few months away from formal methods.
15:50:19 <dmwit> I know a guy that claims to be older than the Internet.
15:50:40 <Spark> i am older than anonymous
15:50:51 <fons> Hi all
15:50:57 <shachaf> fons: Hello.
15:51:09 <TSC> ayyyyy
15:51:09 <dcoutts_> bos: good to see two equivalents of haskell packages I work on in the top 10 cpan packages (iconv and gtk)
15:51:21 <fons> does anyone know how to make conditional compilation (through CPP maybe) base on the GHC version used?
15:51:23 <bos> dcoutts_: aye :-)
15:51:26 <fons> based
15:51:41 <dcoutts_> bos: and lots of html and xml near the top unsurprisingly
15:51:43 <ddarius> fons: Check the user manual.  Flags are defined.
15:51:54 <fons> GHC user manual?
15:52:02 <ddarius> @where ghc
15:52:02 <lambdabot> http://haskell.org/ghc
15:52:04 <Lemmih> Finally, the SDL packages can now be installed from hackage.
15:52:10 <ddarius> Click Documentation on that page.
15:52:11 <fons> thanks ddarius
15:52:27 <dons> DBI eh?
15:52:29 <ddarius> Lemmih: With cabal install sdl or whatever?
15:52:40 <dcoutts_> bos: ah, archive zip, that's one we're missing, we've got zlib and tar but not zip
15:53:00 <dons> Excel, huh.
15:53:00 <ddarius> system "compress"
15:53:11 <Lemmih> ddarius: That too.
15:53:32 <foxyom> dons:  I'm trying to install PCRE on linux and I get a missing pcre.h header.  Is this a C package that I need to install? ./Setup.lhs configure gives no errors, but the build step fails
15:53:36 <dcoutts_> bos: and I need to get cairo pulled out as a cabal package on it's own (well I need to split all of gtk2hs of course)
15:53:41 <dons> foxyom: yep. its a C lib.
15:53:49 <dons> cabal doesn't (yet!) warn if C lib deps don't exist
15:53:54 <dons> though it'd be a cheap patch
15:53:59 <ddarius> dcoutts: It surprised me that it wasn't.
15:54:36 <dcoutts_> dons: it's not as cheap as it looks, I looked at it. To do it properly you have to call gcc or ghc for each lib. That turns out to be rather slow.
15:54:52 <dons> yep. you need to try to link against pcre or whatever
15:55:00 <dons> as autoconf does. generate a little stub, and try to link
15:55:08 <dcoutts_> dons: actually it's the ghc bit that's slow
15:55:13 <monochrom> The code is cheap but the user experience is slow :)
15:55:27 <dons> its nice how fast cabal configure currently is
15:55:50 <dcoutts_> dons: if you go via ghc (which one ought to because it uses the various flags from dependent packages) then it gets slow because ghc's startup time is really starting to suck
15:56:03 <dons> wow, those cpan reviews are great,
15:56:05 <dons> "    Reached v7 but no documentation and bad interface (no interface?). Alot of
15:56:05 <dons>     weird functions named as makafoo, makabar, etc. Reading the code just gave
15:56:05 <dons>     me a headache, but it's also like a time travel to see some prehistoric
15:56:06 <dons>     (released in 2008!) & bad coding style"
15:56:23 <dons> cpan is a wasteland, eh
15:56:27 * cjb hopes no-one reviewed any of his CPAN modules.
15:56:57 <dons> anyone investigated why ghc takes so long to start u
15:56:58 <dons> p
15:57:01 <monochrom> Perhaps there is a way to invoke ghc just once.
15:57:08 <cjb> mod_ghc
15:57:26 <dons> well, --version is cheap, so its the package munging?
15:57:52 <dcoutts_> $ time ghc foo.o -o foo -lpng
15:57:52 <dcoutts_> real    0m1.191s
15:58:10 <dcoutts_> $ time gcc foo.o -o foo -lpng
15:58:10 <dcoutts_> real    0m0.171s
15:58:22 <dcoutts_> dons: yes, reading the package db is sooo sloooo
15:58:32 <dons> and it need not be.
15:58:38 <dcoutts_> dons: but cabal does that now so we could go to gcc directly if we gather the right flags
15:58:45 <dons> yep
15:59:10 <dcoutts_> dons: that is we now get the full InstalledPackageInfo for every package, so we have all the info that ghc/ghc-pkg has
15:59:20 <foxyom> dons: which is better mpg123 or mpg321 (w.r.t. hmp3)
15:59:24 <dons> 321
15:59:36 <foxyom> ta
15:59:45 <dcoutts_> dons: so we can put together all the include dirs, lib dirs etc of the dependent packages and call gcc ourselves which would be quick.
16:00:01 <dcoutts_> dons: and similarly for finding headers
16:00:41 <dons> i can see autoconf in the distance
16:04:18 <ehird`> $ ./spawn-fcgi -f 'runhaskell foo.hs' -p 9000 -n        # awesome
16:05:41 <dons> ehird`: yay
16:06:07 <CosmicRay> bos: got a question about your parsec if you've got a minute
16:06:07 <ehird`> dons: just ^C,up,enter to reload
16:06:15 <ehird`> if i've configured nginx right (to hell with lighttpd)
16:06:51 <ehird`> btw -- with xhtml combinators, how do i add attributes?
16:07:59 <monochrom> Likely the (!) operator of the ADDATTRS class.
16:08:48 <ehird`> monochrom: well, i'd be unsure how to use that
16:08:49 <ehird`> :-P
16:09:13 <monochrom> document ! [attribute, attribute, attribute]
16:09:15 <dons> ehird`: yep. x ! attr, iirc
16:09:20 <foxyom> dons: non-haskell question, I've installed libmad and libid3 (/usr/local/lib) but rpm -i mpg321 gives a failed dependency for those libs
16:09:27 <ehird`> dons: attr = (name,val)?
16:09:35 <dons> check the docs :)
16:09:40 <dons> foxyom: no idea.
16:09:54 <monochrom> attribute is an abstract type.  there are functions to build attributes.
16:09:58 <ehird`> specifically, i'm trying to include a stylesheet
16:10:41 <monochrom> document ! [ src "hello.html", theclass "nav" ]
16:10:47 <ehird`> cool
16:11:15 <monochrom> Haha, it has to be called "theclass" because "class" is taken :)
16:11:28 <dons> yep
16:11:32 <ehird`> yeah, i love that
16:11:35 <ehird`> it looks amusing
16:11:35 <ehird`> :)
16:11:46 <ehird`> http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell getting user input doesn't work with fcgi...
16:11:47 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki, http://tinyurl.com/2n99cj
16:11:49 <ehird`> just redisplays the input form
16:12:03 <olsner> the world is full of purposeful misspellings of 'class', since it's a reserved word in so many unfortunate languages
16:12:27 <ehird`> olsner: 'klass' is popular with the rubists
16:12:29 <ehird`> *rubyists
16:12:41 <ehird`> 'cls' with pythoners
16:13:46 <dons> ehird`: you're doing something wrong
16:13:49 <monochrom> PL/I ftw
16:13:54 <ehird`> dons: probably.
16:14:05 <ehird`> besides, surely there's a regular Text.Xhtml thing for a stylesheet
16:14:22 <dons> there is. you'll likely want to hang out inside xhtml's repo for a while
16:14:28 <dons> looking at all the combinators
16:15:13 <ehird`> dons: better - haskell.org haddock lets me look at the source
16:15:14 <ehird`> :D
16:15:39 <monochrom> style (...) [ thetype "text/css" ]
16:15:47 <ehird`> uh. an external one.
16:15:54 <ehird`> <link rel="stylesheet" type="text/css" href="..." />
16:17:04 <monochrom> thelink (more stuff) [ rel "stylesheet", thetype "text/css", href "..." ]
16:17:15 <ehird`> monochrom: more stuff? link is an empty element!!
16:17:33 <monochrom> likely use noHtml for "more stuff"
16:17:43 <ehird`> heh
16:18:21 <monochrom> I'm starting to learn Text.XHtml.Strict just five minutes ago.
16:18:42 <monochrom> I just look at the type signatures and the names.
16:19:00 <monochrom> And I haven't even tried any experiments.
16:19:07 <ehird`> i'm looking
16:19:08 <ehird`> :|
16:20:06 <foxyom> dons:  I tried pressing "h" in the hmp3 interface and nothing happened
16:21:01 <hpaste>  ehird pasted "pretty much the example from the Practical Web Programming page, but it doesn't work" at http://hpaste.org/5767
16:21:05 <ehird`> see http://0xff.m000.org/hello for what goes wrong
16:22:53 <shapr> @yow !
16:22:54 <lambdabot> I'm wet!  I'm wild!
16:23:48 <stepcut> @getshapr
16:23:49 <lambdabot> shapr!!
16:24:00 <mightybyte> Any suggestions on how to fix this error "No instance for (Show (m [String]))"
16:24:40 <monochrom> So, "let x = maybe inputForm greet mn" is giving you Nothing.
16:24:41 <pjd> mightybyte: it might help to show what causes that error :)
16:24:54 <ehird`> monochrom: yes.
16:25:08 <ehird`> it seems i must add POST to it
16:25:52 <monochrom> I have not learned forms.
16:26:02 <mightybyte> pjd: It's in a "show foo" expression where foo is of type "m [String]"
16:26:46 <dmwit> Well we gathered that all by ourselves...
16:27:06 <dmwit> mightybyte: It might help if you give it a type annotation that restricts it to a particular monad.
16:27:07 <mightybyte> Well, the context is more involved.
16:27:25 <dmwit> mightybyte: Say, Maybe or [] or something that has a Show instance. ;-)
16:28:06 <pjd> mightybyte: ok, so as the error message says, the m [String] is not showable
16:28:36 <Lemmih> mightybyte: You probably don't wanna show it.
16:28:44 <mightybyte> Lemmih: Yeah, didn't think so.
16:28:59 <pjd> mightybyte: what do you actually want to show?  the [String] inside the monad?
16:29:32 <mightybyte> pjd: When I comment out the offending expression, I got a monomorphism restriction error concerning foo.
16:30:02 <mightybyte> pjd: So I added a type annotation restricting m to MonadIO.
16:30:22 <mightybyte> That caused foo to compile
16:30:26 <pjd> you can add a type annotation for the general type, too
16:30:36 <pjd> or disable the monomorphism restriction
16:30:47 <mightybyte> Then when I enabled the (show foo) expression again, I got back to the original error.
16:30:53 <pjd> anyway, maybe pastebin will help
16:31:00 <pjd> i still don't know what you're trying to show
16:31:10 <mightybyte> I'm trying to show an array of Strings
16:31:39 <Lemmih> mightybyte: What kind of array?
16:31:54 <dmwit> mightybyte: This monad is in MonadIO?
16:31:56 <mightybyte> Er, list of Strings
16:32:06 <dmwit> mightybyte: Maybe you want to use (>>= print) rather than show?
16:32:21 <mightybyte> dmwit: Ok, I'll try that.
16:33:22 <mightybyte> Nope, didn't work.  Don't worry about it.  I'll get help elsewhere.
16:34:06 <pjd> mightybyte: you probably want fmap show foo
16:34:09 * dmwit shrugs
16:34:20 <dmwit> If you want better help, give us more information when we ask for it.
16:34:25 <pjd> that will give you m String, where String is the result of the show
16:34:40 <pjd> then you still have to do whatever you want to do with the m
16:35:21 <mightybyte> dmwit: Yeah, I know.  It involves HAppS, so the better information is rather involved.
16:35:39 <mightybyte> dmwit: I just wanted to see if I could get a simple answer here.
16:36:10 <dmwit> Yes, there is a simple answer.  Either: restrict the monad to one that can be shown, or move the "show" operation into the monad.
16:36:40 <dmwit> But there is no way we can be more specific than that until you are.
16:36:49 <mightybyte> dmwit: Yeah, I've tried both of those.  I think the problem is that I don't understand HAppS well enough to know what to restrict to.
16:37:00 <ehird`> ok, I think ther's a bug in Network.FastCGI
16:37:06 <ehird`> getInput = const Nothing, pretty much
16:37:15 <mightybyte> dmwit: Ok, thanks for the help.
16:38:24 <Lemmih> ehird`: With what web-server?
16:38:34 <ehird`> Lemmih: nginx; ahhh wait
16:38:36 <ehird`> maybe it isn't passing the qs
16:38:43 <ehird`> thanks for the spark of inspiration
16:40:09 <XD-G-C> si ego certiorem faciam... mihi tu delendus eris.
16:44:33 <ehird`> woot
16:44:34 <ehird`> it works
16:49:02 <roconnor> @karma- wxHaskell
16:49:15 <roconnor> *sigh*
16:49:41 <ehird`> heh
16:49:48 <ehird`> HaskellDB - maintained or not
16:50:01 <roconnor> Loading package wxcore-0.10.1 ... can't load .so/.DLL for: wxc-gtk2.6.4-0.10.1 (libwx_gtk2_xrc-2.6.so.0: cannot open shared object file: No such file or directory)
16:50:15 <roconnor> I'm in dll hell
16:53:08 <ehird`> anyone?
16:54:36 <lambdabot> wxHaskell's karma lowered to -1.
16:54:46 <roconnor> ah
16:55:43 <roconnor> why No such file or directory?
16:55:58 <ehird`> :/
16:56:03 <ehird`> @karma lambdabot
16:56:04 <lambdabot> lambdabot has a karma of 51
16:56:12 <ehird`> we need @karma= !
16:57:08 <wy> faxathisia: I found as if variadic is not necessary
16:57:41 <conal> roconnor: you could try wxhaskell-users.  maybe find some linux+wxhaskell expertise
16:57:51 <roconnor> :'(
16:57:55 <roconnor> I worked last year
16:58:00 <roconnor> It
16:58:29 <conal> roconnor: yeah -- it was a cool app
16:59:14 <darrint> Is there a way to get :t to show a type without using any synonyms?
17:02:55 * roconnor breaks down and reads the wxHaskell docs
17:08:43 <dmwit> darrint: Not really.
17:08:52 <dmwit> darrint: But you can find out what a synonym is with :i.
17:13:22 <roconnor> ooh I found my install notes
17:13:26 <roconnor> http://www.haskell.org/haskellwiki/WxHaskell/Install#Sources
17:13:27 <lambdabot> Title: WxHaskell/Install - HaskellWiki
17:13:58 <dmwit> Ah, online, a sneaky place to put them.
17:14:46 <roconnor> indeed
17:15:02 <ehird`> how does ghc get away with 'data (->) a b'
17:15:15 <ehird`> it seems like once you get to the point of doing data decls like that you already have all the function infrastructure
17:15:42 <roconnor> @src (->)
17:15:43 <lambdabot> Source not found. Sorry.
17:20:20 <faxathisia> What's the difference between supercompilation and just evaluating things you know (like doing lots of beta-eta-delta reduction)?
17:21:55 <glguy> Has the social network link in the topic been dead for a while?
17:22:03 <ehird`> faxathisia: dancing bananas
17:22:26 <faxathisia> glguy, yeah
17:22:34 <faxathisia> 3 days or more I think
17:22:43 <glguy> Who was hosting that?
17:25:48 <dmwit> lispy was, I think.
17:27:02 <faxathisia> Does anyone have an description of the supercompilation distillation algorithm somewhere?
17:29:39 <BMeph> faxathasia: I know Neil Mitchell was/is doing an automatic supercomp project, that's the first I ever heard of the topic.
17:31:43 <BMeph> Even better - there's another paper on his site, where it sounds like someone else is doing this in a strict language: http://www.csee.ltu.se/~pj/papers/scp/ifl07-scp.pdf
17:32:06 <faxathisia> thanks
17:32:32 <faxathisia> I found this "Intro to supercompilation" as well ftp://ftp.diku.dk/diku/semantics/papers/D-364.ps.gz
17:32:54 <ddarius> faxathisia: Supercompilation stands for "supervised compilation"
17:32:56 <ddarius> glguy: lispy
17:33:22 <glguy> thnx
17:33:27 <ddarius> @google Refal
17:33:37 <faxathisia> So you are prompted by the compiler to choose what how to transform?
17:33:46 <BMeph> Here's NDM's paper - with Colin Runciman, natch - on Supero: http://www-users.cs.york.ac.uk/~ndm/downloads/paper-supero_making_haskell_faster-27_sep_2007.pdf
17:34:33 <ddarius> @bot
17:34:33 <lambdabot> :)
17:35:00 <BMeph> Ah - Figure 3, Optimization Rules. :)
17:35:33 <faxathisia> This post is very interesting
17:35:34 <faxathisia> http://www.rubrication.net/2008/02/09/verifying-the-monad-laws-with-supercompilation/
17:35:38 <ddarius> faxathisia: It's the compiler that's supervising itself.  It's not just blindly beta reducing, but it watches to see if a pattern comes up.
17:35:52 <faxathisia> Suggesting the use of supercompilation to prove inductive theorems
17:36:07 <ddarius> Turchin's work on Refal is the canonical reference (Turchin did invent supercompilation)
17:36:09 <faxathisia> I see
17:36:11 <ddarius> @google Refal
17:36:17 <roconnor> w00t
17:36:19 <ddarius> lambdabot is being sour
17:36:21 <lambdabot> Plugin `search' failed with: getAddrInfo: does not exist (Name or service not known)
17:36:26 <roconnor> by following my instruction, I got phooey to run
17:36:32 <faxathisia> http://refal.net/index_e.htm
17:36:34 <lambdabot> Title: Refal/Supercompilation Community
17:37:22 <roconnor> conal: I got my app building again!
17:39:05 <roconnor> conal: ugh, but I fear that your caching modification you made is gone
17:48:59 <conal> roconnor: yay!
17:49:10 <conal> roconnor: on DataDriven or Reactive?
17:49:31 <roconnor> conal: DataDriven
17:49:51 <roconnor> -timedPoll secs poll = iPrim (P.timedPoll secs poll)
17:49:51 <roconnor> +timedPoll secs poll = iPrim (P.cache (P.timedPoll secs poll))
17:49:55 <dons> here's an interesting graph, the number of unique committers per month, over time, to 100 haskell projects, http://galois.com/~dons/images/comitters.png
17:49:58 <roconnor> conal: I made the above change
17:50:02 <roconnor> conal: is that correct?
17:50:08 <roconnor> (correctish)
17:50:30 <conal> roconnor: where is that code?
17:50:35 <roconnor> it type checks so I assume it is fine :)
17:50:39 <roconnor> conal: in GuiTV
17:50:47 <u_quark> @src showString
17:50:47 <lambdabot> Source not found. Take a stress pill and think things over.
17:51:05 <roconnor> @src show String
17:51:06 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:51:16 <roconnor> @src show Char
17:51:16 <lambdabot> Source not found. Where did you learn to type?
17:51:22 <roconnor> @src Char show
17:51:22 <lambdabot> Source not found. You speak an infinite deal of nothing
17:51:23 <ac> is there a combination of filter and map?
17:51:31 <conal> roconnor: i'm not sure.  which versions of phooey & GuiTV?
17:51:32 <ac> I want to modify some elements, and remove others
17:51:41 <roconnor> conal: phooey 1.4
17:51:50 <roconnor> GuiTV darcs
17:51:57 <faxathisia> ac, concatMap .. sort of
17:52:08 <roconnor> which claims to be GuiTV 0.4
17:52:13 <faxathisia> it's ugly though, I'd just chain map and filter..
17:52:15 <ac> faxathisia: ah yes, that would work
17:52:18 <roconnor> ac, list comprehension
17:52:47 <roconnor> ac: ah concatMap may work for you :)
17:52:54 <conal> roconnor: I think you got the P.cache used right.  i see it that way in an old version.
17:52:57 <faxathisia> (Why do I always forget about list comprehensions? I don't think I've ever used them in code I wrote)
17:53:15 <roconnor> conal: cool
17:53:22 <conal> roconnor: i removed it, because caching is automatic & cheap in Reactive
17:53:35 <roconnor> conal: ah
17:53:50 <ac> I use them occasionally. The reason I want filter and map combined rather than just chaining them is the two use comman variables. I could use a list comprehension, but is there a way to bind common variables for the left and right side of the '|'?
17:54:25 <dmwit> filterMap p f xs = [f x | x <- xs, p x] -- ?
17:54:30 <ac> I guess I could just use X <- value
17:54:35 <roconnor> in principle I can use darcs to roll back that patch :)
17:54:47 <dmwit> ac: What do you mean by "bind common variables"?
17:54:54 <ac> if "value" is not a list, then it will always have the same value
17:55:30 <dmwit> [f x | x <- xs, binding <- [value]] -- ;-)
17:55:57 <dmwit> ac: That's what "let" in the do-notation for lists would amount to, to.
17:56:05 <dmwit> *too
17:56:14 <ac> ah interesting
17:56:27 <ac> I have never used list typed do blocks
17:56:46 <BMeph> foldr! ;)
17:56:58 <dmwit> BMeph: Yes, everything is a foldr. =P
17:57:17 <BMeph> dmwit: Even unfoldr. ;)
17:57:18 <roconnor> conal: indeed; according to darcs you had timedPoll secs poll = iPrim (P.cache $ P.timedPoll secs poll) before :D
17:57:29 <dmwit> BMeph: foldr f -- for a sufficiently inscrutable f
17:57:31 <glen_quagmire> give me functional program examples. I can think of: factorial, fib, quicksort. can you think of something else?
17:58:02 <conal> roconnor: so does your trading work okay again?
17:58:04 <roconnor> crap, what did darcs rollback do?
17:58:11 <roconnor> conal: yep!
17:58:20 <wli> glen_quagmire: Lambda calculus interpreters are common.
17:58:44 <conal> roconnor: i'm sure curious to know whether it'd work with phooey 2.0 & reactive
17:58:59 <BMeph> glen_quagmire: Try a Scheme interpreter - that's usually the gateway drug to monad tutorials, for Haskell. :)
17:59:01 <conal> roconnor: but maybe you've suffered enough today
17:59:05 <monochrom> glen_quagmire: continuations, and how to use them to implement exceptions, generators, ...
17:59:08 <glen_quagmire> my languages has no io yet. i'll do quicksort
17:59:18 <faxathisia> what is your language?
17:59:19 <roconnor> conal: I can send you my code tomorrow
17:59:23 <BMeph> Tree sort! :)
17:59:31 <conal> roconnor: great
17:59:40 <glen_quagmire> faxathisia: my homework. subset of lisp.
17:59:55 <ac> Cin: ?
18:00:14 <Cin> ac: hi?
18:00:25 <dolio> I/O is overrated.
18:00:27 <ac> Cin: ah you are around. I was wondering why you disappeared the code for your Scheme interpreter
18:00:38 <wli> glen_quagmire: Newton's method.
18:00:42 <ac> Cin: I hadn't fetched it yet
18:00:52 <roconnor> how do I rollback and change the working directory?
18:01:04 <Cin> ac: i lost it, i'm afraid. thought i'd backed it up. lost it when i re-installed my OS
18:01:10 <glen_quagmire> wli: thats nice. thank you
18:01:18 <monochrom> You can use continuations to do half of I/O too. The other half is done by an interpreter.
18:01:19 <ac> Cin: oh lame! I totally should have DLed it
18:01:31 <Cin> ac: hehe, oh well
18:02:05 <Cin> ac: i think the concept was pretty much proved anyhoo. although i wouldn't mind rewriting it to do it better
18:02:53 <ac> Cin: so in your understanding was it efficient?
18:04:01 <ehird`> anyone re: haskelldb?
18:04:17 <Cin> it might've been. i hadn't gotten round to testing it. it seemed to cope with a recursive definition of factorial
18:04:27 <ac> Cin: The reason I ask is that AFAIU, if you could implement it in an efficient manner, you could possibly prove that a lazy language without mutable state is as algorithmically expressive as a strict language with mutable state
18:04:48 <Cin> ac: yes, indeed. that is quite interesting
18:05:18 <ac> Cin: maybe you could write a paper on it :-p
18:05:38 <faxathisia> ac, Cin, what's all this? sounds interesting
18:06:11 <ac> I was asking about how one could implement a Scheme with (setf!) without IO refs, and Cin went ahead and did it
18:06:14 <Cin> implementing a scheme purely functionally
18:06:23 * wli farts around with simplifying expressions consisting of integers, sums, products, quotients, and raising to rational powers, and falls down somewhere.
18:07:09 <faxathisia> you can use State monad..?
18:07:18 <Cin> i thought there would be more code, with having to be so explicit about changing the state with monads, but it was actually quite succcinct
18:07:21 <faxathisia> StateT I guess
18:07:33 <BMeph> Cin has moved Beyond Monad... o.O
18:07:34 <roconnor> conal: unpulling one patch gives me the version of GuiTV that I want :D
18:07:35 <Cin> yeah, i used the State monad (and then StateT so i could do IO)
18:07:46 * wli is unsure how to decide which is the simplest among a set of equivalent expressions.
18:07:48 <conal> roconnor: nice
18:07:50 <roconnor> @karma+ darcs
18:07:51 <lambdabot> darcs's karma raised to 13.
18:08:14 <Cin> bmeph: haha
18:08:23 <faxathisia> ac: There's already a paper on this
18:08:27 <BMeph> I still want a GUI for darcs called "darcs IDE". :)
18:08:38 <faxathisia> ac: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
18:08:39 <lambdabot> Title: Monad Transformers Step by Step
18:09:44 <roconnor> BMeph: we can write it with phooey :D
18:10:07 <EvilTerran> surely a haskell IDE should be called "hide"?
18:10:15 <roconnor> @where hide
18:10:15 <lambdabot> http://haskell.org/haskellwiki/HIDE
18:10:35 <BMeph> roconnor: Excellent! One step closer to the darcs IDE. ;)
18:10:35 <EvilTerran> heh. didn't even know that existed.
18:10:36 <Twey> Hahahahaha.
18:10:39 <EvilTerran> i'm just that good.
18:11:12 <roconnor> EvilTerran: time for you to make Hide 3.x
18:11:43 <EvilTerran> sure, sure. if i can get the comlab(.ox.ac.uk) to let me do it for my project next year.
18:11:56 <BMeph> EvilTerran: I don't want a whole IDE (yet - everyone expects a "real" language to have one), I just want a GUI for Darcs.
18:13:05 <xif> is there any reason why Erlang's concurrency / distributiveness features can't be implemented in Haskell?
18:13:34 <xif> the core requirement for a language to have those seems to be no side effects and no global state.
18:13:45 <xif> so doesn't Haskell qualify?
18:13:53 <roconnor> xif: I don't know Erlang, but I don't really see why not.  Erlang's concurrency is pretty basic from what little I know.
18:14:17 <roconnor> isn't it just message queues and threads?
18:14:20 <mrd> can you message functions in erlang?
18:14:25 <xif> mrd: yes
18:14:32 <roconnor> crap
18:14:35 <mrd> that would require compiler support in haskell
18:14:36 <roconnor> :)
18:14:43 <xif> you message processes, not functions, but yeah.
18:14:52 <xd> you can message functions to another cluster node in erlang
18:14:53 <mrd> no, i meant functions as the direct object
18:15:02 <mrd> can a function be sent in a message
18:15:06 <xif> mrd: so not exactly
18:15:10 <allbery_b> hm, I thought I'd heard Erlang relied on interpretive features to support adaptive data structures and function passing
18:15:24 <ac> faxathisia: what was the conclusion of that paper? Or should I just read it?
18:15:40 <allbery_b> (that said, I know ~nothing about Erlang)
18:15:41 <xif> a process in Erlang can receive messages
18:15:51 <mrd> in terms of concurrency, Haskell and STM are pretty slick
18:15:54 <xif> it's not the function that receives them directly.
18:16:03 <mrd> xif: you are still not understanding
18:16:17 <xif> mrd: oh, you mean sending the function itself?
18:16:20 <mrd> yes
18:16:22 <xif> I don't think so.
18:16:31 <xd> xif: he means Pid ! fun() -> foo end.
18:16:35 <xd> yes you can
18:16:46 <mrd> this is the tricky thing
18:16:51 <xif> mrd: why?
18:17:10 <mrd> anything that is sent over the network is going to need to be serialized
18:17:16 <xif> because there's currently no good way to serialize functions
18:17:18 <mrd> how do you serialize a function?
18:17:35 <ac> Cin: look similar to what you wrote?
18:17:36 <xif> hm, send a bytecode representation or something?
18:17:45 <mrd> possibly. you also need the closure.
18:17:45 <davidL> use Data.Binary maybe?
18:17:48 <EvilTerran> it takes a lot of magic a la simplereflection, i think
18:17:58 <xif> Smalltalk and Scheme can serialize whole continuations.
18:17:58 <EvilTerran> @where simplereflect
18:17:58 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
18:18:03 <Cin> ac: reading through it, yep, pretty much
18:18:16 <mrd> you need some kind of compiler support for it though.  otherwise the problem is undecidable.
18:18:18 <xif> there's no theoretical reason why Haskell wouldn't be able to serialize functions.
18:18:20 <ac> Cin: I feel like if I read it it would spoil the fun
18:18:23 <roconnor> xif: can they serialize stderr?
18:18:33 <EvilTerran> if you -XNoImplicitPrelude, i think you can put something horrible together to annotate everything with its parse tree
18:18:44 <xif> mrd: yeah, it's a practical problem, not a theoretical difficulty.
18:18:48 <Cin> ac: reading through it for me is like "yay that's how i did it!", so perhaps it might spoil the fun ;)
18:19:02 <mrd> xif: the problem is rooted in a theoretical difficulty, though
18:19:06 <xif> roconnor: I'm not Erlang expert, but I don't think they need to
18:19:14 <roconnor> can we serialize RealWorld? :D
18:19:32 <Cin> ac: although this is more well thought out and clever in places, hehe
18:19:53 <xif> mrd: if other platforms achieved much more than serializing a single function (like serializing whole objects with their methods and sometimes the entire state of the program with multiple namespaces)
18:19:59 <xif>   then it's probably a solved problem.
18:20:13 <Cin> faxathisia: cool paper, cheers
18:20:33 <roconnor> xif: I bet the sematics of serialized state of programs is totally borked.
18:20:47 <mrd> xif: no, you are misunderstanding slightly.  you see, in a program, you've already got the answer by writing the code itself.  therefore, if the compiler helps you with some kind of reflection features, then you can get at that.  but in general, it's an undecidable problem.
18:20:48 <xif> roconnor: in Erlang, if we spawn a process, and it fails with an error, it sends back a message.
18:21:15 <faxathisia> You might be best to write an Erlangish interpreter and just write your code in that
18:21:25 <ac> man it bugs me how the '\' in "(\(a, b) -> ....)" screws up vim's paren matching
18:21:27 <faxathisia> Probably start with a Prolog like they did
18:21:54 <xif> faxathisia: yeah, but that would be too much work.
18:21:59 <pjd> ac: old version?
18:22:04 <pjd> works fine here
18:22:10 <faxathisia> xif, From what you're saying I think it would be a hell of a lot less
18:22:22 <xif> faxathisia: less than what? :-)
18:22:26 <mrd> ac: yea I always write \ (a,b) now
18:23:17 <ac> mrd: that offends my aesthetic sensibilities
18:23:20 <mrd> well, i've been thinking about a distributed concurrency library for haskell a bit.  i think it might be easiest if you can get away without passing functions =).
18:23:22 <xif> mrd: what do you mean by "undecidable"?
18:23:42 <mrd> xif: might be time for you to start learning computer science.  i can recommend some books.
18:23:46 <wagle_home> darn..  here i was hoping that vim was better at indenting/etc haskell than emacs
18:24:26 <xif> mrd: time for me to learn a lot of things. if I had it.
18:24:34 <mrd> wagle_home: emacs haskell-mode has a "smart" indentation mode, but I don't use it.  so I use regular 2-space tab-stops in both vim and emacs now.
18:24:41 <Adamant> Yi should indent Haskell well, I would hope
18:24:55 <xif> I assume you meant something like "non-deterministic"
18:25:05 <Adamant> no
18:25:32 <xif> roconnor: I'm not that familiar with the semantics, but at least for Smalltalk the serialization process is quite reliable.
18:25:34 <faxathisia> ac, I've another idea for a scheme interpreter
18:25:36 <mrd> xif: no.  I guess you can start with Wikipedia, they probably have a decent description.
18:25:37 <Adamant> undecidable = not computable with your computing model, usually Turing. (IIRC)
18:25:45 <ac> faxathisia: what's that?
18:25:46 <faxathisia> ac, if you're interested I can show you
18:26:07 <ac> how do I get the fractional part of a number?
18:26:12 <roconnor> xif: I'm thinking of handles and mutation of cells and other craziness.
18:26:19 <mrd> xif: undecidable means, briefly, that you aren't guaranteed to get an answer
18:26:21 <roconnor> @type properFraction
18:26:28 <mrd> in fact, you won't get an answer, in the strict sense of the term
18:26:34 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
18:26:54 <roconnor> ac: oh, I think there is a function that just gives you the fractional part
18:26:59 <roconnor> @type trunc
18:27:00 <lambdabot> Not in scope: `trunc'
18:27:03 <roconnor> @type truncate
18:27:04 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
18:27:18 <roconnor> nope
18:27:22 * wagle_home 's ears perk up at the mention of an idea for a scheme interpreter
18:27:23 <faxathisia> @pl \x -> x - truncate x
18:27:23 <lambdabot> ap (-) truncate
18:27:37 <blargeyfarg> pretty high latency on those ears...
18:27:46 <mrd> xif: as for books, I can recommend Sipser, Introduction to the Theory of Computation
18:27:53 <roconnor> maybe not
18:27:56 <wagle_home> polling can be slow
18:28:00 <blargeyfarg> heh
18:28:09 <ac> it would be pretty cool if hpaste had tags or some basic sort of organization. There could be a whole collection of Scheme interpreters
18:28:12 <roconnor> ac: at least snd . properFraction will work.
18:28:28 <hpaste>  faxathisia pasted "slow mini interpreter" at http://hpaste.org/5768
18:28:28 <xif> mrd: interesting. I'm surprised it's not discussed in "The Haskell road to logic, math and programming"
18:28:46 <xif> (decidability)
18:28:58 <faxathisia> It works but it's dreadfully slow, If someone knew how to speed it up, please tell me :P
18:29:13 <mrd> xif: i don't know either.  perhaps its assumed.
18:29:29 <MagicDuck> Hi, I have a small question regarding declaring a new datatype. I am trying to declare a new datatype Natural as list of Ints (This is for a homework). The trouble is that data Natural = [Int] does not seem to be acceptable. But If I do something like data Natural = Nil | Cons Int Natural, I lose all the list goodness ... anything I can do?
18:29:40 <ac> faxathisia: what's its claim to fame?
18:29:49 <faxathisia> the idea is bend haskell as close to scheme as you can, then write a metaintepreter
18:30:06 <xif> mrd: OK, thanks, I'll check out that Sipser book.
18:30:10 <ac> faxathisia: I can't find the interpreter logic
18:30:34 <dmwit> MagicDuck: You probably want "type" instead of "data".
18:30:43 <ac> faxathisia: I see. there isn't any
18:30:43 <EvilTerran> MagicDuck, if you're using data, you need a new constructor
18:30:53 <EvilTerran> data Natural = Nat [Int] -- this would work
18:31:01 <dmwit> MagicDuck: "type" declares a type synonym, so "type Natural = [Int]" would work just fine.
18:31:04 <ehird`> faxathisia: that's not scheme then
18:31:07 <ehird`> that's lazymonadicscheme
18:31:08 <EvilTerran> or what dmwit's saying
18:31:26 <faxathisia> ehird`: It's eager (and unfinished)
18:31:27 <MagicDuck> Yeah, it works with type but then I can't do things like Instance Show Natural ...
18:31:41 <ehird`> faxathisia: eh, isn't enough of, well, a scheme interprter for me
18:31:42 <EvilTerran> in that case, go with the data
18:31:54 <faxathisia> ehird`: That's the unfinished bit..
18:32:05 <EvilTerran> you'll have to put in the constructor and pattern-match it out, mind
18:32:11 <faxathisia> ehird`: See the speed it runs test1 for why
18:32:16 <MagicDuck> ok, thx EvilTerran, I'll try that
18:32:19 <ddarius> faxathisia: Erlang didn't start with "a Prolog".  They built the first interpreter in Prolog and used a Prolog syntax but never really had much actual support for logic language features.
18:32:23 <EvilTerran> foo :: ... -> Natural -> ...; foo ... (Nat n) ... = ...
18:32:35 <dmwit> That's a lot of dots!
18:32:45 <ehird`> faxathisia: I mean; it shares its bed with haskell.
18:32:51 <EvilTerran> and when you want to yield a Natural instead of a [Int], it'd be Nat [...] instead of just [...
18:32:57 <EvilTerran> ]
18:33:03 <ddarius> Incidentally, Clean can serialize functions, but this doesn't matter for just concurrency.
18:33:06 <faxathisia> ddarius, Yeah start with a Prolog interpreter and modify it..
18:33:21 <Cin> ehird`: hr, hdbc seems like a good answer to our cgi database problem. i'm toying about with it now. here's a nice example of it that i'm using to figure out where to start: http://software.complete.org/hpodder/browser/DB.hs
18:33:22 <EvilTerran> yeah, dmwit, i'm feeling rather dotty this evening :D
18:33:23 <lambdabot> Title: /DB.hs - hpodder
18:33:44 <jair_> Hello! I am writting a program that uses matrixes. I wan't to represent matrixes as functions of two integers that map to a Fractional, so I wrote a matrixfy function:
18:33:46 <ehird`> Cin: we're lumbering through the world of painful haskell web development together
18:33:47 <ehird`> xD
18:33:52 <jair_> matrix :: (Fractional a, Integral b) => [[a]] -> (b -> b -> a)
18:33:52 <Cin> heh, indeed :P
18:33:54 <jair_> matrix mat i j = (\i j -> (mat!!i)!!j)
18:33:55 <ehird`> eurgurguh, it uses SQL
18:34:02 <ehird`> HaskellDB uses strongly-typed haskell for queries
18:34:03 <ehird`> :(
18:34:06 <ehird`> and I like that
18:34:13 <dmwit> faxathisia: beginL = foldl1' (>>) -- ?
18:34:14 <Cin> i coldn't compile haskelldb
18:34:23 <ehird`> Cin: my problem with haskelldb is that it seems to be dead
18:34:27 <dmwit> :t foldl1' (>>)
18:34:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
18:34:33 <Cin> ehird`: yeah
18:34:33 <mrd> takusen looked pretty neat
18:34:37 <ehird`> what about takauakzk or whatever it was
18:34:40 <dmwit> faxathisia: Oh, duh, sequence_. =P
18:34:43 <jair_> but I think I am doing something awfully wrong with the type signature
18:34:51 <Cin> ehird`: haven't looked at that yet. feel free
18:35:01 <ddarius> faxathisia: My point is that they didn't start with a Prolog interpreter, they started with an interpreter written in Prolog.  You would only gain a parser, pretty much, if you started with a Prolog interpreter.
18:35:05 <ehird`> http://darcs.haskell.org/takusen/ just brimming with docs
18:35:08 <ehird`> but no mysql interp
18:35:25 <mrd> jair_: you could omit the type signature and see what GHC reconstructs
18:35:36 <ddarius> (and there is little reason to copy Erlang/Prolog syntax just to get Erlang semantics)
18:35:37 <mrd> jair_: oh I see your problem though
18:35:43 <mrd> jair_: you repeat i and j
18:36:03 <mrd> matrix mat i j = (mat !! i) !! j
18:36:15 <pjd> jair_: (!!) takes an Int, not an Integral
18:36:19 <jair_> ohhh, true! thank you!
18:36:30 <mrd> ah pjd points out something useful too
18:36:47 <wli> jair: (mat `genericIndex` i) `genericIndex` j
18:36:47 <ehird`> Cin: we should write our own strongly-typed library based on hdbc! :P
18:36:53 <ehird`> DBmonad
18:37:02 <Cin> ehird`: heh, or fix haskelldb
18:37:03 <ehird`> wli: speaking of generic
18:37:09 <ehird`> when would genericLength return a non-int? :/
18:37:15 <ehird`> Cin: far less fun, plus it's not maintained
18:37:46 <pjd> jair_: using an Int is probably fine, though
18:37:50 <dmwit> import Prelude hiding ((!!)); import Data.List hiding ((!!)); (!!) = genericIndex
18:38:02 <pjd> unless you're planning to use some funky Integrals
18:38:10 <wli> ehird`: My guess is that it's mostly for when the result needs to be converted to some other type vs. for truly long lists.
18:38:12 <pjd> :t let matrix mat i j = (\i j -> (mat!!i)!!j) in matrix
18:38:12 <wagle_home> hmm..  genericLength :: (Num a) => b -> a
18:38:13 <lambdabot> forall a t t1. [[a]] -> t -> t1 -> Int -> Int -> a
18:38:18 <ehird`> selectFrom myTable (Where {id = Equals userID})
18:38:19 <Cin> right now i just want to write a web page idea, so i'm going with the shortest route and trying to avoid php to do it if i can. but after that, working on some db library existing or otherwise sounds good
18:38:21 <ehird`> ^ i don't know! :p
18:38:28 <ehird`> Cin: indeed
18:38:38 <ehird`> i want my blog to be written in the nicest haskell possible ;)
18:38:49 <ehird`> and then what content will i put on it? well, how to write nice haskell web apps i guess.
18:38:52 <faxathisia> Cin, hunchentoot + xml-mixed-mode
18:39:11 <ehird`> my programming endeavours are very meta, they rarely converge to another goal than to enable communicating about programming
18:39:18 <jair_> pjd:yeah, an Int will probably suffice
18:39:43 <wagle_home> or uhh....  genericLength :: (Num a, Measurable b) => b -> a
18:39:47 <wagle_home> 8)
18:40:35 <ehird`> wli: I want a float length
18:40:36 <ehird`> :|
18:40:41 <ehird`> 'This list has 5.3 elements.'
18:40:54 <ehird`> 'You can access the 5-5.3 elements using genericIndex.'
18:41:11 <ehird`> 'Note that this list does not fit into a number of bits, so we used half-bits.'
18:41:16 <pjd> ~ eric, the half-a-element ~
18:41:22 <jair_> God, I don't understand de error:     The lambda expression `\ ii ji -> ...' has two arguments,
18:41:24 <jair_>     but its type `a' has none
18:41:27 <gwern> ehird`: what happens if you try to take 5.3 elements from a 6 element list? :)
18:41:51 <ehird`> gwern: You get the 5th element and .3rd of the 6th element.
18:41:52 <ehird`> Duh.
18:41:52 * wagle_home dusts off his old norton-schmidt bit-splitter
18:42:17 <ehird`> This reminds me of TURKEY BOMB: http://catseye.tc/projects/turkeyb/doc/turkeyb.html
18:42:18 <lambdabot> Title: Cat's Eye Technologies: The TURKEY BOMB Programming Language
18:42:18 <dmwit> That would make for a bitter split.
18:42:23 <gwern> ehird`: ah. and what is .3ths of a boolean, for example?
18:42:28 <ehird`> gwern: Ssh.
18:42:35 <dmwit> gwern: Ever heard of fuzzy logic?
18:42:40 <ehird`> (Ask TURKEY BOMB.)
18:42:54 <ehird`> someone was working on an implementation, actually
18:43:05 <ehird`> since you can't encode "Negative six sevenths of a decimal digit.", instead of AMICED they had a NEGATIVE_AMICED type
18:43:08 <ehird`> and inverted all operations on it
18:43:22 <gwern> dmwit: vaguely
18:44:09 <ehird`> Cin: http://cvs.haskell.org/darcs/haskelldb/
18:44:10 <lambdabot> Title: Index of /darcs/haskelldb
18:44:14 <ehird`> that seems newer than the site haskelldb
18:44:26 <Cin> ehird`: does it compile?
18:44:34 <gwern> cvs.? lolwut
18:44:49 <ehird`> i will try
18:44:53 <ehird`> gwern: don't ask me
18:45:53 <gwern> maybe it's a symlink to http://darcs.haskell.org/haskelldb/
18:45:59 <lambdabot> Title: Index of /haskelldb
18:47:57 <dmwit> "Take these trits and meditate soundly upon them."
18:48:09 <dmwit> This language is exceedingly ill-specified.
18:48:43 <Cin> faxathisia: hrrrmm. i may actually use that. do you know how it compares to plt-web-server?
18:49:05 <faxathisia> no
18:49:51 <Cin> what annoys me about plt's is the memory consumption. the gc cycles don't happen very often so it gobbles up memory, and i'm kind of using this computer.
18:49:54 <faxathisia> you wanna got xml-mixed-mode off the pastesite though, not use cl-who which is nastly and ugly
18:52:25 <Cin> eh, what the hell. might as well give it a go. haven't used CL for ages
19:16:51 <roconnor> @faq can haskell make mircosoft access run under linux?
19:16:52 <lambdabot> The answer is: Yes! Haskell can do that.
19:16:56 <roconnor> sweet
19:17:30 <dmwit> Turing machines, sweat of the brow, etc etc
19:20:48 <monochrom> @faq can haskell shave all and only those who don't shave themselves?
19:20:48 <lambdabot> The answer is: Yes! Haskell can do that.
19:21:24 <SamB> @faq can haskell do paradoxical things?
19:21:25 <lambdabot> The answer is: Yes! Haskell can do that.
19:21:34 <pjd> @faq Can Haskell not do that?
19:21:34 <lambdabot> The answer is: Yes! Haskell can do that.
19:21:45 <dons> i note there's a new user on reddit with name 'haskell_does_that'
19:22:06 <dons> http://reddit.com/user/haskell_does_that
19:22:17 <monochrom> hahahaha
19:22:20 <SamB> @can haskell #1=be unable to #1#
19:22:20 <lambdabot> Maybe you meant: faq map run wn
19:22:24 <SamB> @faq can haskell #1=be unable to #1#
19:22:25 <lambdabot> The answer is: Yes! Haskell can do that.
19:22:37 <dons> ?remember haskell Knuth stole most of his ideas from Haskell.
19:22:37 <lambdabot> It is stored.
19:22:54 <glguy> dons: what do you think about spliting hpaste into separate cgi apps for each function rather than mangling urls inside on monolithic handler?
19:22:55 <dons> ?remember haskell The Internets. Haskell does them.
19:22:55 <lambdabot> It is stored.
19:23:00 <dons> glguy: hmm.
19:23:11 <SamB> whoa, stole his ideas from Haskell?
19:23:12 <dons> a single box seems nicer, and fits with fastcgi a bit better
19:23:29 <dons> ?remember haskell Haskell binaries are made of 100% win. That is why they are so big.
19:23:29 <lambdabot> It is forever etched in my memory.
19:23:36 <dmwit> hahaha
19:23:49 <SamB> dons: how do those work on OpenBSD
19:24:05 <bd_> 100% win - not from concentrate!
19:24:22 <sclv> gah. using a custom CGIT monad with fastCGI is frikinhard.
19:24:36 <sclv> I pretty much have to rewrite the library to do it I think.
19:25:20 <sclv> anyone else have this experience?
19:25:40 <monochrom> Who is this haskell_does_that guy?  Bad press in the making.
19:26:11 <glguy> monochrom: you'd prefer fanboi?
19:26:15 <dons> monochrom: right. there have been others like this.
19:26:24 <dons> 'haskeller' was another -- intentionally pissing people off
19:26:33 <sclv> -ist you mean
19:26:55 <monochrom> OK, I guess these clowns mean people actually care about haskell.
19:27:01 <dons> sclv: yes. i think its fairly well known that CGI is kinda hard, and mucks up your code
19:27:11 <dons> monochrom: or its big enough to be worth making fun of
19:27:22 <monochrom> (E.g., we don't even have some epigram_does_that character. :) )
19:27:30 <dons> so we're at the lisp phase now
19:27:34 <sclv> dons: not when I'm through with it it won't be!
19:27:38 <dons> yay
19:27:59 <sclv> I'm trying to build the CGI monad on top of STM instead of IO :-)
19:28:20 <gwern> dons: this is interesting. the Pugs project seems to have its own PCRE binding, before you did yours
19:28:33 <gwern> 'pugs-hsregex'
19:29:14 <SamB> hey, dons, what happened to all the contributors on the pugs project?
19:29:43 <dons> SamB: no idea. but it has updated
19:29:45 <monochrom> They were all invited to Vulcus for a better life, and they all accepted.
19:29:52 <faxathisia> :(
19:29:52 <dons> gwern: huh, i wish they'd release their code :)
19:30:07 <dons> we should go and raid the dead body of pugs to extract the goodies
19:30:33 <gwern> dons: if only we lived in the best of all posibble worlds
19:30:36 <dons> SamB: but it did update at least
19:31:27 <gwern> hm. is pugs an interpreter or compiler?
19:31:30 <dons> both
19:31:38 <SamB> dons: yes but now it lists only 3 contributors!
19:31:54 <awesame> is there some handy way to convert a name to a symbol in haskell?
19:32:15 <awesame> er, a string to a symbol
19:32:23 <kmcallister> awesame, what do you mean by symbol
19:32:24 <dons> http://code.haskell.org/mohws/ looks interesting
19:32:27 <lambdabot> Title: Index of /mohws
19:32:28 <dons> SamB: interesting.
19:32:37 <dons> SamB: i didn't do the conversoin. that's just their svn repo
19:32:40 <awesame> I want to select a data constructor based on a string passed in on the command line
19:32:45 <faxathisia> awesame, I guess you can have data Symbol = S String, then S :: String -> Symbol
19:32:57 <SamB> dons: I think they have a bronze mirror
19:32:58 <dons> awesame: you'll need to inspect the string. case x of "Foo" -> Foo
19:33:08 <dons> unless you roll some generics to reflect the constructor
19:33:13 <kmcallister> awesame, i would construct an explicit Data.Map.Map String YourType, or use TH to do it for you
19:33:15 <monochrom> No "handy" way.
19:33:16 <awesame> dons: and I have to do that for every possibility?
19:33:26 <dons> awesame: well, you can do it generically, but that's a bit funky
19:33:35 <kmcallister> awesame, template haskell or DrIFT can probably autogenerate the code for you
19:33:41 <awesame> I see
19:33:49 <kmcallister> (variations on this question seem to come up a lot... is there some good sample code somewhere?)
19:33:53 <awesame> maybe I shouldn't be using a type for this?
19:34:10 <SamB> maybe you should seperate the constructor from it's arguments?
19:34:12 <awesame> I'll look into Data.Map
19:34:28 <awesame> SamB: oh!
19:34:36 <awesame> yes, you're right
19:34:41 <kmcallister> awesame, the reason to use a map rather than a big case statement is time complexity for lookup
19:34:53 <kmcallister> actually, i don't know what optimizations ghc applies to big case statements
19:35:00 <kmcallister> err, case expressions
19:35:05 <dmwit> > read "-  32" :: Int
19:35:07 <awesame> instead of data Foo = Bar | Baz | Qux, I could be doing data Foo = Foo String
19:35:09 <SamB> kmcallister: what do you think it does?
19:35:21 <lambdabot>  thread killed
19:35:25 <gwern> dons: look at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pugs-hsregex-1.0
19:35:25 <wli> AIUI nothing terribly useful is done for large case statements.
19:35:26 <SamB> awesame: wait, you don't have any arguments?
19:35:30 <kmcallister> oh yeah, you could derive Read on your type
19:35:31 <awesame> nope!
19:35:34 <kmcallister> and then just use that
19:35:35 <SamB> awesame: what was wrong with Read?
19:35:46 <kmcallister> doh, i always forget the simple solution
19:35:48 <awesame> hm, read
19:36:04 <dons> > read "Just 1" :: Maybe Int
19:36:05 <lambdabot>  Just 1
19:36:10 <dons> > read "Nothing" :: Maybe Int
19:36:10 <lambdabot>  Nothing
19:36:22 <awesame> yeah, that's exactly what I was looking for
19:36:22 <dons> as long as its all a single type, you're set. why did we not think of that?
19:36:26 <awesame> thanks!
19:36:30 <dons> somehow it was worded in a way to trick us!
19:36:39 <oklopol> can read be used as an eval
19:36:47 <kmcallister> oklopol, no
19:36:57 <kmcallister> not in any straightforward way
19:37:03 <dons> just a parser, not an evaluator of haskell
19:37:05 <awesame> I am so crafty when it comes to working against my own interests
19:37:06 <dmwit> > read "return 3 :: Maybe Int" :: Maybe Int
19:37:07 <lambdabot>  Exception: Prelude.read: no parse
19:37:17 <SamB> oklopol: only if you want to eval only (possibly compound) literals
19:37:36 <oklopol> > read "1" :: Int
19:37:37 <lambdabot>  1
19:37:40 <oklopol> > read "1 + 1" :: Int
19:37:41 <lambdabot>  Exception: Prelude.read: no parse
19:37:47 <wli> So if you have lexers or parsers with high branching factors for state transitions (i.e. the number of different states reachable from one character or token is more than 20 or 30) then you're probably best off building an array of functions and indexing into it.
19:37:52 <oklopol> > read "[1, 1]" :: Int
19:37:53 <lambdabot>  Exception: Prelude.read: no parse
19:37:56 <oklopol> err.
19:38:03 <oklopol> > read "[1, 1]" :: [Int]
19:38:04 <lambdabot>  [1,1]
19:38:06 <dons> SamB: heh,
19:38:06 <dons> SamB: heh, audreyt
19:38:07 <dons> 13392 commits, 1.9 years contribution"
19:38:13 <oklopol> > read "3 : [1, 1]" :: [Int]
19:38:14 <lambdabot>  Exception: Prelude.read: no parse
19:38:19 <wli> For things like lots of strings ... you should build state machines.
19:38:44 <gwern> hm. does svn have any darcs send equivalent? once you make changes how do you push upstream?
19:38:58 <SamB> dons: I think you unenlisted the main repo and enlisted a bronze mirror, as well as ruining an opportunity for ohloh to get rid of a bug
19:39:16 <SamB> gwern: svn diff, paste into email
19:39:26 <dons> SamB: fix it then. its a wiki.
19:39:42 <gwern> SamB: how crude and primitive! aight then...
19:39:54 <SamB> dons: what is? ohloh?
19:40:04 <dons> yeah. go ahead and enlist the right repo
19:40:08 <SamB> I already clicked on "Undo"
19:40:38 <SamB> I'll unenlist the one you enlisted if it seems to download...
19:41:20 <awesame> > read "Just notanint" :: Maybe int
19:41:22 <lambdabot>        add (Read int) to the context of
19:41:22 <lambdabot>         the polymorphic type `forall ...
19:41:54 <awesame> not the best error message
19:42:05 <kmcallister> > case (read "Just notanint") :: Maybe Int of Just _ -> "foo"
19:42:06 <lambdabot>  Exception: Prelude.read: no parse
19:42:06 <dons> Int
19:42:18 <SamB> > read "Just notanint" :: Maybe Int
19:42:18 <awesame> er
19:42:18 <lambdabot>  Exception: Prelude.read: no parse
19:42:20 <dons> readM
19:42:29 <kmcallister> :t readM
19:42:33 <awesame> > readM "Just notanint" :: Maybe Int
19:42:34 <lambdabot>   Not in scope: `readM'
19:42:35 <lambdabot> Not in scope: `readM'
19:42:39 <awesame> doh
19:42:47 <SamB> dons just made readM up, I think
19:42:51 * ac has a sudden masochistic interest in subpixel positioning
19:42:53 <SamB> though it's clear enough what it would do
19:43:07 <wagle_home> :t read
19:43:08 <lambdabot> forall a. (Read a) => String -> a
19:43:09 <SamB> (at least, on failure it is ;-)
19:43:18 <SamB> (on success... not so much!)
19:43:20 <awesame> well, I can figure out how to catch that exception and print something friendlier
19:43:20 <dons> i did. its a proposed patch
19:43:28 <dons> well, you can use reads.
19:43:40 <dons> maybeRead :: Read a => String -> Maybe a
19:43:40 <dons> maybeRead s = case reads s of [(x, "")] -> Just x _         -> Nothing
19:43:46 <kmcallister> readM :: (Read a, Monad m) => String -> m a
19:45:13 * wli typically goes with readM
19:45:30 <SamB> this intermitent problem where links sometimes contain ohloh's IP address instead of it's domain name is kinda freaky...
19:45:42 <kmcallister> :t let readM :: (Read a, MonadZero m) => String -> m a; readM s = case reads s of [(x, "")] -> return x; _ -> mzero in readM
19:45:43 <lambdabot>     Not in scope: type constructor or class `MonadZero'
19:45:49 <kmcallister> :t let readM :: (Read a, MonadPlus m) => String -> m a; readM s = case reads s of [(x, "")] -> return x; _ -> mzero in readM
19:45:50 <lambdabot> forall (m :: * -> *) a. (Read a, MonadPlus m) => String -> m a
19:46:06 * wli complains about fail
19:46:54 <kmcallister> for haskell', can we define read in terms of some super general monadic parser thingy?
19:47:18 <SamB> 'twould be nice if we could just use the one GHC already has, perhaps
19:47:21 <wagle_home> :t' dwim
19:48:02 <SamB> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html
19:48:24 <kmcallister> cool, anyone have a comparison with Parsec?
19:48:29 <wagle_home> @hoogle () -> a
19:48:30 <lambdabot> Did you mean: () -> a
19:48:30 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
19:48:30 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
19:49:08 <wagle_home> ...  no dwim..  8(
19:49:08 <SamB> hmm, is that the one I wanted?
19:49:33 <wli> kmcallister: Sadly, Haskell' is not what a number of people on this channel are hoping for.
19:49:48 <kmcallister> what are they / we hoping for?
19:50:12 <SamB> I think I wanted to paste this: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadPrec.html
19:50:13 <wli> kmcallister: Backward-incompatible revisions of the language.
19:50:23 <dolio> Haskell' is intended to codify the advances since H98 that are already widely implemented.
19:50:32 <kmcallister> ah, okay
19:50:35 <kmcallister> Haskell'' then ;)
19:51:19 <wagle_home> haskell**
19:51:27 <dolio> It was also supposed to be done a couple years ago or so. :)
19:51:41 <MagicDuck> hi, can someone help me with this blurb: http://pastebin.com/d490f1838 , it's been driving me crazy - I can't coerce Integer to Int for some reason ...
19:51:47 <kmcallister> :t fromIntegral
19:51:48 <lambdabot> forall a b. (Num b, Integral a) => a -> b
19:52:19 <kmcallister> :t fromIntegral :: (Integer -> Int)
19:52:20 <lambdabot> Integer -> Int
19:52:24 <awesame> dons: maybeRead was just right
19:52:38 <awesame> dons: but I'm having trouble finding docs to tell me what reads is
19:52:53 <dolio> > fromInteger :: Integer -> Int
19:52:54 <kmcallister> awesame, it's in The Report
19:52:54 <lambdabot>  <Integer -> Int>
19:53:03 <MagicDuck> aha, thanks
19:53:23 <SamB> hmm, the index for the heirarchical libraries should probably be split up by letter...
19:54:13 <awesame> kmcallister: found it, thx
19:54:18 <kmcallister> yup
19:58:10 <gwern> dons: do you remember what version of bytestrings renamed/rewrote copyCStringLen and copyCString?
19:58:27 <hpaste>  bran_ pasted "how do I make this work?" at http://hpaste.org/5769
20:02:20 <ac> is there an uncorry2 and uncurry3?
20:02:52 <faxathisia> :t uncurry
20:02:53 <ac> er, uncurry is uncurry2. I want a 3 argument version
20:02:53 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
20:03:18 <faxathisia> ?djinn (a -> b -> c -> d) -> (a, b, c) -> d
20:03:18 <lambdabot> f a (b, c, d) = a b c d
20:03:41 <wagle_home> @hoogle (a -> b -> c -> d) -> (a, b, c) -> d
20:03:41 <lambdabot> No matches, try a more general search
20:03:43 <faxathisia> well there's that, you can't make it with combinators though (since you cant 'cons' onto tuples)
20:05:56 <dmwit> bran_: Maybe you should have a look at Data.Typeable?
20:06:21 <wagle_home> @src Data.Typeable
20:06:21 <lambdabot> Source not found.
20:06:26 <wagle_home> @src Typeable
20:06:26 <lambdabot> Source not found. You speak an infinite deal of nothing
20:06:28 <dmwit> ?docs Data.Typeable
20:06:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-Typeable.html
20:06:41 <wagle_home> there's always another command
20:06:41 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
20:06:49 <lambdabot> http://tinyurl.com/ynu4qa
20:15:24 <bran_> dmwit: can you explain the ghc error?
20:15:47 <bran_> or what i'm doing wrong
20:16:43 <dmwit> Yes, that error occurs when you use a function that is polymorphic in its return type.
20:17:18 <dmwit> In order to consume the returned value, it has to choose a particular type before it knows which "getId" implementation to use.
20:17:34 <dmwit> You can fix it with an explicit type annotation around the (getType obj1) clause.
20:18:37 <dmwit> (And the annotation must specify which Object instance to use, it can't be polymorphic.)
20:19:19 <dmwit> All that said, I think you may be getting yourself into trouble, using type classes in this way.
20:20:29 <bd_> how would one implement getType anyway?
20:21:18 <faxathisia> bd_: what would getType return?
20:21:28 <bd_> faxathisia: in http://hpaste.org/5769 I mean
20:21:31 <dmwit> bd_: Right, it's not totally clear that bran_ knows what he's doing here.
20:21:53 <bd_> as far as I can tell the only implementation is getType _ = _|_
20:22:19 <bd_> since there's no typeclassy way to construct Objects
20:23:01 <dmwit> bran_: The objection bd_ is bringing up stems from the fact that "getType" needs to be able to return an Object... and in particular, it needs to be able to return a value that can be of the same type as *any instance of Object*.
20:23:39 <dmwit> bran_: getType is, in some sense, more polymorphic than you (probably) want it to be.
20:25:50 <bran_> yeah, definitely lost me
20:26:27 <dmwit> Okay, let's take an example.
20:26:38 <dmwit> Let's say both Int and String are instances of Object.
20:27:18 <dmwit> Now, because of its type, (getType 3) has type (Object a => a), right?
20:27:35 <bran_> right..
20:27:45 <dmwit> Okay, but that means I could write both:
20:27:50 <dmwit> f = getType 3 :: Int
20:27:55 <dmwit> g = getType 3 :: String
20:28:02 <dmwit> and they both need to work!
20:28:21 <bd_> moreover, it has to be the same implementation of getType for both
20:28:48 <dmwit> But you can't do that when you're writing the instance for Int, because you don't know a priori whether you need to be returning an Int, or a String, or some custom data type that somebody else defined later and made an instance for.
20:28:53 <wagle_home> mm..  multiparameter?
20:28:57 <bd_> which means at some level you'll need some *other* function which looks like Object a => (something not related to a) -> a
20:29:20 <bd_> but since nothing like that is in the class, it doesn't exist, apart from (undefined) and the like
20:29:34 * dmwit wipes the spittle away from his chin
20:29:42 <dmwit> Sorry, I tend to get a bit excited about these things.
20:34:13 <bran_> ok, mostly makes sense
20:36:12 <bran_> thanks
20:37:35 <thoughtpolice> the average number of packages appearing on hackage every day is getting bigger. :)
20:37:38 <thoughtpolice> gwern++
20:40:29 * dolio finally gets delimited continuations 'working' in Agda.
20:40:38 <faxathisia> :o
20:40:43 <faxathisia> do show!
20:41:15 <gwern> thoughtpolice: the honest truth is I do it all just to annoy dcoutts
20:42:13 <dons> thoughtpolice: do you have figures for that?
20:42:28 <dons> it would be nice to actually have per week upload stats
20:42:42 <thoughtpolice> gwern: :) it stresses cabal a bit at least, gives an idea of where it can be improved
20:43:08 <gwern> thoughtpolice: like the cabal devs need even more feature requests and bugs! heh
20:43:14 <thoughtpolice> dons: i just look at the recent packages list every day and sometimes inbetween. it would be nice to have figures, though.
20:43:54 <faxathisia> dolio, Did you take call-with-current-continuation as an axiom or what?
20:44:22 <hpaste>  dolio pasted "Agda Delimited Continuations" at http://hpaste.org/5770
20:44:34 <gwern> specifying 'readline -any' is equivalent to saying just 'readline'  in a cabal, right?
20:45:48 <thoughtpolice> gwern: should be. it'll use the highest version of readline available, as far as I know, anyway.
20:45:52 <hpaste>  dolio annotated "Agda Delimited Continuations" with "ContTest" at http://hpaste.org/5770#a1
20:46:15 <dolio> Oops, looks like hpaste doesn't like unicode.
20:46:46 * faxathisia can view raw and it works fine
20:46:56 <dolio> All right.
20:48:00 <dolio> It's only single-prompt. I don't think you can do multi-prompt continuations (like CC-delcont, at least) without unsafeCoerce.
20:48:44 <monochrom> It likes unicode if you put it inside comments.
20:57:30 <faxathisia> that's cool :D
20:58:42 <brailsmt> i'm very new to haskell (as in decided to learn it an hour ago), anyway, I have a list and I'd like to access the Nth element of the list, how do i do that?
20:58:58 <oerjan> brailsmt: l !! n
20:59:05 <dolio> > [1..10] !! 5
20:59:08 <lambdabot>  6
20:59:13 <brailsmt> thx
20:59:24 <oerjan> (index starts at 0)
21:00:18 <brailsmt> oerjan: i figured
21:00:47 <wy> oerjan: I found out that the unambiguous grammar can be gotten by simply thinking about precedence rules in my example
21:01:24 <dolio> faxathisia: Can't say I'm in love with record/module passing in lieu of type classes. :)
21:02:00 <oerjan> aha
21:02:34 <dolio> faxathisia: It can't seem to infer the correct type for mapM in test unless I tell it explicitly, either.
21:04:22 <monochrom> w00t, new lambdacat!
21:05:10 <oerjan> wy: figures that there are several ways of thinking of it
21:05:39 <dons> brailsmt: lists aren't usually indexed that often (since they're lists, not arrays or hashes/maps)
21:05:45 <wy> oerjan: The thoughts follows the church-rosser theorem
21:05:46 <dons> just something to keep in mind
21:05:53 <oerjan> dolio: so Agda is not a proper extension of Haskell? :(
21:06:39 <wy> dolio: What's record/module passing?
21:08:39 <dolio> Well, depends.
21:09:10 <dolio> If you look at mapM there, I take a parameterized record that has all the monad functions.
21:10:10 <dolio> But I also have to open the module, so I have to refer to it explicitly.
21:11:47 <faxathisia> dolio, what I'm most impressed about Agda 2 is that it's possible to actually prove things with it, even though you write terms directly (as opposed to using tactics)
21:12:12 <dolio> But I don't want to have to pass it in explicitly so I made it implicit, which means I have to refer to all the other implicit args in mapM, too, or it gets, understandably, confused.
21:12:12 <faxathisia> (I would have thought it's far to hard to do things this way before)
21:12:33 <mrd> faxathisia: it can be quite compact, if you've seen twelf, for example
21:12:49 * mrd is happy about this parameterized module feature of agda, did not notice before, like Sections in Coq.
21:13:26 <dolio> Maybe there's a better way to structure things, though. mapM should really be defined directly in the monad module, where it wouldn't have the problem, I suspect.
21:13:41 <wli> mrd: Parametrized modules? I'm going to have to get my hands on agda.
21:13:50 <dolio> Since the monad that's being worked on is already in scope.
21:14:30 <mrd> yah. not quite functors, but like Sections.
21:14:49 <faxathisia> Coq modules are functors I think
21:14:53 <wli> mrd: I know functors. I've never heard of sections in module contexts.
21:14:56 <mrd> yea
21:14:56 <faxathisia> It's all very confusing :)
21:15:30 <mrd> wli: basically you can specify some premises that apply to every definition in that section
21:16:59 <mrd> like in Coq you can presume a type A, and some function eqA : A -> A -> bool, and then work in terms of those
21:17:16 <dmwit> Urgh, taking a [[a]] to reduced-row-echelon form is hard work.
21:17:35 <wli> dmwit: Now try pivoting. ;)
21:17:36 <faxathisia> hmm
21:17:39 <faxathisia> Cale are you here?
21:17:55 <brailsmt> dons: yeah, i'm starting with what I know, and expanding to incorporate haskell features...
21:18:05 <wli> dmwit: Full pivoting is even worse than partial pivoting.
21:18:14 <dolio> Yeah, defining mapM directly in the RawIMonad module clears everything up.
21:18:20 <dmwit> wli: I'm not sure I remember what that means.
21:18:24 <brailsmt> dons: i have to relearn the whole concept of functional programming, its been years since i did scheme in college
21:18:28 <faxathisia> dmwit that would be gauss jordan elimination?
21:19:03 <dmwit> faxathisia: Yes, I think so.  I haven't got the guts to look up a real algorithm, so I'm just trying to code up the one I know how to do by hand. =)
21:19:19 <faxathisia> oh ak
21:19:25 <faxathisia> ah ok* oops
21:20:09 <wy> faxathisia: I got question in lispcafe. Maybe it's more convenient to put it here?
21:20:24 <dolio> So, perhaps that problem doesn't come up if you structure everything correctly.
21:20:46 <wy> faxathisia: Is the type systems of ML and Haskell inconsistent because they inhabit bottom?
21:21:02 <oerjan> dmwit: i did some determinant code with gaussian elimination on hpaste, maybe that could help you?
21:21:09 <dons> brailsmt: hehe cool. well, hang out here, and you'll pick up a lot
21:21:15 <faxathisia> wy, you have general recursion so you can write a diverging function which might have any type
21:21:27 <faxathisia> :t let foo = foo in foo
21:21:29 <lambdabot> forall t. t
21:21:32 <faxathisia> like that for example
21:22:03 <dmwit> Mmm, I didn't think to look on hpaste.
21:22:18 <dmwit> oerjan: Thanks for the tip. =)
21:22:29 <wy> faxathisia: so I know the cause of inconsistency
21:22:37 <wli> dmwit: The SVD can get relatively involved.
21:22:42 <faxathisia> wy, that's just one
21:22:44 <dons> any japanese speakers who can translate this? http://proof.exblog.jp/6814651/
21:22:45 <lambdabot> Title: ææãããã«æãããI think therefore I am : awesome-2.2_rc1 -> xmonad ...
21:22:54 * dons tries to work out what the -> indicates here 
21:23:17 <wy> faxathisia: I started to read Barendregt, but it seems that there is something missing from my knowledge of logic. Any good references?
21:23:41 <ivanm> dons: as a guess, the title seems to indicate they've gone from awesome to xmonad...
21:23:51 <dons> ivanm: that's my guess. but i want to know why
21:24:06 <ivanm> dons: you tried translating the page?
21:24:17 <dons> yeah, it fails
21:24:29 <ivanm> with which translator?
21:24:33 <wy> faxathisia: That's just one cause? Are there many others?
21:26:27 <dons> babelfish
21:26:33 <ivanm> dons: using google, it appears that they went _to_ xmonad: " That the transition in xmonad :-) "
21:26:38 * ivanm tries with global as well
21:27:44 <dons> ok. yay.
21:27:57 <dons> there was another nice xmonad article today, http://ojuice.teamslack.net/2008/02/computing/xmonad/
21:27:58 <lambdabot> Title: b Parallaxis 17 » Blog Archive 45 » Xmonad
21:28:22 <mrd> wow. awesome-2.2_rc1 is done.  config file sees...
21:28:27 <mrd> one sec
21:28:30 <dons> go mrd!
21:29:00 <mrd> on second thought
21:29:11 <ivanm> dons: http://www.google.com/translate?langpair=ja|en&u=http://proof.exblog.jp/6814651/
21:29:11 <lambdabot> http://www.google.com/translate?langpair=ja|en&u=http://proof.exblog.jp/6814651/
21:29:15 <ivanm> global's tranlsation is worse :s
21:29:20 <mrd> crashed?
21:29:32 <dons> "config file is crashed" ?
21:29:39 <dons> that makes sense - they likely broke the format
21:30:00 <dons> ivanm: interesting
21:30:23 <dons> "Awesome dual-display environment is weak? " hehe
21:30:36 <ivanm> yeah
21:35:36 <mrd> that is to say, xmonad switch-over middle :)
21:36:16 <Twey> Haha, "oh joker joker"
21:37:18 <mrd> as for awesome, dual display environment is weak?
21:37:39 <mrd> hmm, yay babel
21:39:59 <mrd> 2 displays, 0.0 and 0.1 ..., as for 0.0 make work parts, problem of what also is not.
21:40:07 <mrd> hmm, not sure i can do better than babel
21:46:49 <dmwit> > let p x = sum [a * x^i | (a, i) <- zip c [0..]] in map (chr . floor . p) [0..27]
21:46:50 <lambdabot> Terminated
21:47:02 <dmwit> > let p x = sum [a * x^i | (a, i) <- zip c [0..]] in p 0
21:47:03 <lambdabot> Terminated
21:47:09 <dmwit> > take 3 c
21:47:10 <lambdabot> Terminated
21:47:33 <oerjan> > 1+1
21:47:41 <lambdabot>  2
21:48:08 <oerjan> > c
21:48:10 <lambdabot>  c
21:50:00 <dons> > map (+) [a,b,c]
21:50:01 <lambdabot> Terminated
21:50:04 <dons> > map (+1) [a,b,c]
21:50:05 <lambdabot> Terminated
21:50:12 <oerjan> > let p x = sum [a * x^i | (a, i) <- map ((,) c) [0..]] in map (chr . floor . p) [0..27]
21:50:13 <lambdabot> Terminated
21:50:35 <mrd> Terminator 4: lambdabot's reckoning
21:50:39 <dmwit> > let p x = sum [a * x^i | (a, i) <- zip secretList [0..]] in map (chr . floor . p) [0..27]
21:50:40 <lambdabot>  "Just another Haskell hacker,"
21:50:53 <faxathisia> > secretList
21:50:55 <lambdabot>  [74%1,2363238899989161427%26771144400,(-648529715774877819549083)%1929449919...
21:51:06 <dmwit> =)
21:52:54 <dmwit> ?pl \a i -> a * x^i
21:52:54 <lambdabot> (. (x ^)) . (*)
21:53:53 <dmwit> Oh, \bot knows (*) = flip (*)?
21:53:58 <dmwit> cleva guhl
21:54:38 <dmwit> err, wait, no
21:54:44 <dmwit> ?pl \a i -> x^i * a
21:54:44 <lambdabot> (. (x ^)) . (*)
21:55:04 <dmwit> Well, she does know it after all. =)
22:33:48 <Stinger_> is it possible to build libs such as HTTP, HXT natively under windows or do I need cygwin or something?
22:34:20 <jeffz> you'll find out quick enough
22:34:28 <Stinger_> or are there binaries somewhere I don't know about
22:34:31 <Stinger_> ehhe
22:34:41 <Stinger_> that sounds reassuring :|
22:35:13 <jeffz> depends on the dependencies, if it wants posix, the answer is probably no, but it shouldn't take much effort to try for yourself.
22:41:27 <dons> Stinger_: almost all should be portable.
22:41:35 <dons> HTTP and HXT should be fine.
22:41:44 <dons> look for deps on 'unix' on hackage, to avoid those
22:41:52 <Stinger_> cool, I shall proceed
22:42:04 <dons> haskell's by default portable :)
22:42:37 <wagle_home> ports to everything except my macosx 10.5.x ppc
22:43:22 <dons> you can run hugs on ppc. btw, is anyone on ppc chasing that ghc 6.8 problem down?
22:44:08 <wagle_home> a day work for 6.8.3 or somesuch to get the bootstrap back
22:45:51 <wagle_home> someone did it anyway for 6.8.2 for macosx10.5.x for intel
22:46:01 <wagle_home> >(
22:46:31 <wagle_home> maybe i'll get off my duff and try to do it myself..  8)
22:52:20 <Stinger_> I like gentoo, its just emerge dev-haskell/http hxt etc
22:56:09 <wagle_home> i like suspend to work.. after everyone around me couldnt get it to work while I got lucky three times, I decided to to push my luck
22:56:27 <wagle_home> s/to to/not to/
23:11:19 <dons> how come with have this 40k loc ObjectIO graphics library that no one uses?
23:11:49 <BMeph> Hysterical Raisins? :)
23:12:26 <dons> there's quite a few things over 10k loc, i hadn't realised
23:15:01 <ricky_clarkson> And then do notation became the norm and Haskell became Java.
23:15:55 <Lycurgus> wait, you mean Haskell is academic Java?
23:16:01 <Lycurgus> *isn't
23:16:10 <ricky_clarkson> @quote ricky_clarkson academic
23:16:10 <lambdabot> ricky_clarkson says: Is Haskell an interface between programming languages and academics?
23:16:37 <ry4n_> no. way too complex for that
23:16:38 <ry4n_> :P
23:16:50 <Lycurgus> yeah the Geistesblitz for me was that early section of the H98 spec
23:17:04 <Lycurgus> that made clear what the core spec was.
23:17:13 <ricky_clarkson> I'm kind of embarrassed and proud of that quote (it's from a few years before I looked at Haskell properly)
23:18:27 <Lycurgus> .o0(NB: zweite GB: providing a defined core is a biz op.)
23:18:37 <dons> ricky_clarkson: hehe. its quite memorable
23:18:45 <dons> shapr's fond of quoting it
23:20:32 <ry4n_> no. you're bang on ricky_clarkson
23:21:10 <dons> its the shortest pipe between research and application in the programming language world
23:21:27 <dons> you literally get to program with the latest research
23:21:34 <dons> instead of waiting 2 decades
23:21:46 <ry4n_> yup. the STM is really nice
23:22:00 <ry4n_> but to make it usable to the laymen will take a while. research isn't for joe everyone
23:22:10 <ry4n_> well STM is usable now i thin
23:22:12 <newsham> coq?  epigram?  agda?
23:22:13 <ry4n_> but not everything
23:22:19 <Lycurgus> nor need it be
23:22:26 <Lycurgus> for him to pay to use it.
23:22:29 <drdo> are there any HCL docs?
23:22:39 <dons> stm's pretty much done, isn't it. all the other guys are just going to clone that interface, and disregard the purity warning
23:22:52 <dons> and then they'll do it in hardware
23:23:01 <dolio> What applications are you going to write in Epigram and Agda?
23:23:01 <ry4n_> yes. sun is doing it in hardware
23:24:08 <ivanm> STM in hardware? :o
23:24:08 <quicksilver> dolio: emacs!
23:24:12 <povman> HTM
23:24:15 <ivanm> quicksilver: heh
23:24:22 <quicksilver> dolio: after that everything else comes for free.
23:24:24 <dagit|lispy> I wonder if Sun is next inline to purchase DEC/Compaq/HP and then also get bought by someone?
23:24:26 <dolio> Heh.
23:24:30 <ivanm> yet another two emacsen that will die very quickly?
23:24:45 <ivanm> how does STM in hardware work?
23:24:59 <dolio> You're going to write an elisp interpreter in a total language? :)
23:25:45 <dagit|lispy> what sorts of useful programs can be written in a total language?
23:26:01 <dagit|lispy> I'm wondering how restrictive that nice feature really is.
23:26:03 <ry4n_> ivanm, i haven't read the STM hardware paper yet but i bet it is just a set of helper instructions and a contention manager
23:26:09 <newsham> we're not in total anymore, kansas.
23:26:18 <ivanm> *nod*
23:26:19 <ivanm> newsham: heh
23:26:37 <quicksilver> dagit|lispy: well, notably not interpreters for turing complete languages
23:26:49 <dolio> dagit|lispy: Well, the idea is to write most of the program in a total language, and have a non-total skin.
23:27:01 <dolio> Like you write mostly pure programs in Haskell, and have an IO skin.
23:27:03 <faxathisia> I don't see why you couldn't write an interpreter for a turing complete langugage
23:27:35 <newsham> fax: wouldnt that construct a proof that total programming is turing complete?
23:27:38 <dagit|lispy> What all is included in "total"?  Can your program still be bottom for some reason besides infinite recursion or infinite loop?
23:27:57 <dolio> Although I don't know if Agda has such facilities. The wiki is kind of silent on that.
23:28:06 <dagit|lispy> newsham, I think you'd just fail to be able to interpret arbitrary programs.  I'm not really sure.
23:28:40 <dolio> There is no bottom in a total language.
23:28:49 <newsham> its turtles all the way down
23:28:55 <dagit|lispy> interesting
23:29:05 <faxathisia> You can reason about transitive closures and infinite stream
23:29:11 <ivanm> dolio: are total languages missing any other body parts? ;-)
23:29:16 <dagit|lispy> So, something that is TC can implement any computable function, but something that is total can only implement what, algorithms?
23:29:51 <faxathisia> You certainly can't actually have an eval for a universal language in a total one, but you should still be able to define an interpreter
23:30:10 <wagle_home> what?  what?!?  *sputter*..  email to the template haskell mailing list!
23:30:20 <ivanm> heh
23:30:21 <dagit|lispy> The totality restriction is probably pretty silly in practice. You could still ask it to do super exponential computations right?  It's not bottom, but it won't finish before the sun burns out?
23:30:37 <faxathisia> dagit|lispy: It's not silly
23:30:59 <faxathisia> dagit|lispy: There's a big difference between 9999999 and infinity
23:31:25 <newsham> but very little difference between 0.99999999' and 1.0
23:31:25 <ivanm> faxathisia: depends what you're comparing it to
23:31:28 <dolio> It's not just about termination, either.
23:31:37 <ivanm> comparing it to 10^-100000, there isn't much difference...
23:31:48 <wagle_home> not as big as you think..  i think we got lambdabot to admit that 1/0 was only 738 digits long..  but i cant find it
23:31:48 <dagit|lispy> dolio,it's about well defined termination, right?
23:31:55 <newsham> thanks to danica mkellar for teaching me that math doesnt suck
23:31:57 <ivanm> wagle_home: heh
23:32:23 <dagit|lispy> can you even write a prng in a total language?
23:33:01 <dagit|lispy> I think you can because it's deterministic and it's an algorithm
23:33:02 <dons> yeah. i reckon so.
23:33:02 <newsham> dagit: g -> (n,g') ?  seems pretty easy
23:33:10 <dons> they're fully pure, and total functions
23:33:23 <dons> just doing a bunch of math
23:33:35 <faxathisia> Have a look at some of these http://coq.inria.fr/contribs/index-eng.html
23:33:36 <lambdabot> Title:
23:33:53 <faxathisia> There is even sokoban :D
23:34:20 <dagit|lispy> are those programs in a total language?
23:34:24 <newsham> \g -> (g `mod` n2, (m * g + b) `mod` n)
23:34:24 <faxathisia> yes
23:34:35 <dolio> Having your language be total is kind of important if you're using the same language to prove things about your program.
23:34:46 <dolio> Since you want that system to be consistent.
23:37:07 <newsham> I like how mentioning epigram, coq and/or agda once very 2 mos sets the channel off :)
23:37:30 <faxathisia> It is fun stuff :D
23:37:52 <dagit|lispy> it's good, I'm just wondering what are the differences between total programming and non-total
23:37:54 <dolio> faxathisia: Did you manage to get Epigram 2 working, by the way? The build system didn't seem in order when I tried.
23:37:58 <dons> newsham: hehe.
23:37:58 <dagit|lispy> it must be very different in places
23:38:35 <faxathisia> dolio, I got e-cce, which I think is some part of the core, not sure exactly
23:38:55 <faxathisia> It runs but.. I don't know what to put in the prompt
23:39:00 <dolio> Heh.
23:40:56 <faxathisia> dagit|lispy: I think .. total is a bit of a strange thing to want normally, when you have dependant typing though.. It's very desirable since (with some more conditions) you have a consistent logic with which you can reason about the programs you write in it
23:41:51 <dolio> In a lot of places in Agda, you can get away with not writing things that differently than in Haskell.
23:42:16 <dolio> Which is pretty remarkable, I suppose.
23:42:21 <faxathisia> Yeah, I'm so impressed at Agdas typechecking
23:42:31 <faxathisia> I just could not understand the source though
23:42:53 <dolio> Even Epigram involves a lot of repitition in case statements and stuff (although I think they're working on that).
23:43:52 <dons> this guy writes some nice haskell, http://reddit.com/info/69cej/comments/
23:44:26 <dolio> I'd like to see Epigram get done, though, because Connor McBride sent some interesting looking category theory stuff is pseudo-Epigram.
23:44:35 <dolio> To the Epigram mailing list that is.
23:44:49 <dolio> I've been trying to reproduce it in Agda, but I got an "the impossible happened."
23:47:42 <faxathisia> dolio, where is that?
23:47:52 <faxathisia> nabble?
23:48:01 <dolio> Where is what?
23:48:56 <faxathisia> this code on the mailing list
23:49:46 <dolio> http://www.mail-archive.com/epigram%40durham.ac.uk/msg00215.html
23:49:52 <lambdabot> Title: Re: [Epigram] Functor laws using dependent types?
23:49:57 <faxathisia> thanks
23:54:32 <pheaver> just curious, but if I use cabal to build a library as a *.a file in my dist/build directory, is there a ghc command-line flag that will make the modules in that *.a file available when i compile/link a program?  (hopefully my question was clear enough)
23:55:23 <pheaver> i know i could actually finish the cabal installation, registering the package with ghc-pkg and making it available... but I was just curious about the .a file
