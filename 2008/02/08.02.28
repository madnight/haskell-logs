00:00:09 <oerjan> @where strictcheck
00:00:09 <lambdabot> I know nothing about strictcheck.
00:00:20 <Gilly> ok, let me clarify my problem... I got an array but I suspect that using a big list to initialize the array with 0's and then concatting that list with another to set part of the elements to 1 isn't the most common way to do it, is it?
00:00:52 <Gilly> like array (1,5) [(1,0),(2,0),(3,0),(4,0),(5,0),(1,1),(3,1)]
00:01:38 <Gilly> except my real array is of size like 800x800 and i'd like it to default to 0 and only specify the small part of the array to be set to 1
00:04:07 <decker> how do i signal a fatal error in haskell?
00:04:19 <ac> Haskell is fun
00:04:32 <ac> decker: error "uh oh!"
00:04:36 <sam_> functional is fun!
00:04:37 <Zao> Aren't there an array ctor that takes a list and a default value?
00:04:40 <decker> ac: thnx
00:04:55 <ac> decker: you can catch them with catch
00:05:15 <decker> i think i've just horribly misused haskell's pattern matching
00:05:36 <Samburger> x = x + 1
00:06:07 <ac> decker: something like: (\x -> if x == 0 then error "uh oh" else 1 / x) `catch` (\e -> Nothing)
00:06:32 <ac> er, there's supposed to be a "0" after that first lambda
00:06:39 <ac> :t catch
00:06:40 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
00:07:03 <wagle_home> return Nothing
00:07:15 <ac> I really should not be trying to explain Haskell exceptions. I don't know what I'm talking about at all
00:07:21 <decker> i just wrote an arbitrary precision addition algorithm using pattern matching, but it's quite obtuse
00:07:29 <decker> if anyone has any style recommendations, they're very welcome
00:08:36 <decker> holy netsplit batman
00:11:27 <oerjan> ac: i am surprised forkOS mainGUI works.  i would have guessed initGUI and mainGUI needed to be in the same bound thread.
00:11:28 <ac> I think the propper way to do what I'm trying to do would be to return a "PlayArea" data type that not only has the pixbuf but also the drawing window. Then I can have some functions like "flush" that will use postGUIAsync to redraw safely, so I don't have to redraw every 500ms
00:11:41 <araujo> hello
00:11:58 <oerjan> as well as some of the others.
00:12:09 <ac> oerjan: as well as what?
00:12:43 <ac> should I be using forkOS or forkIO?
00:12:45 <oerjan> anything that changes the GUI state...
00:13:01 <ac> I'm just writing to a pixbuf... I can't imagine how that would cause it to crash
00:13:26 <oerjan> ac: locking issues?
00:14:06 <ac> this is honestly my first concurrent program actually
00:14:31 <Zao> Doesn't it require you to perform all drawing in the GUI thread?
00:14:43 <oerjan> Zao: that's what i thought
00:14:55 <ac> The docs just say all library calls have to be from the GUI thread
00:16:31 * oerjan is in over his head here
00:16:32 <Lemon> when I pass a data contructor into a function,
00:16:38 <Lemon> can I use it for pattern matching?
00:16:45 <oerjan> Lemon: no
00:16:49 <Lemon> damn.
00:16:58 <oerjan> sadly missing feature, that.
00:17:25 <oerjan> check out functional references
00:17:32 <ac> oerjan: what kind of locking issues?
00:17:34 <Lemon> ?
00:17:47 <oerjan> or maybe not
00:18:33 <oerjan> Lemon: there are people doing things with template haskell to turn constructors into first class values
00:18:45 <Lemon> oh
00:19:16 <oerjan> ac: if your pixbuf changes while it is being drawn...
00:19:56 <ac> oerjan: but how could that matter?
00:20:26 <ac> oerjan: you could easily have only half a drawing operation appear... but big deal
00:20:52 <oerjan> ac: i don't know if it matters in this case.  if a pixbuf is just a sequence of bytes and there is no real format restrictions then perhaps it's ok
00:21:05 <ac> oerjan: that's exactly what it is
00:21:42 <oerjan> ac: i am more worried about how you are not doing all the library calls from the same thread.
00:21:49 <ac> what do you think of the idea of wrapping it up a little, and doing the redrawing correctly?
00:21:54 <ac> oerjan: I am
00:22:16 <oerjan> um, initGUI is not done in the same thread as mainGUI
00:22:23 <ac> ah ok
00:22:28 <ac> yeah mainGUI is in the spawned thread
00:22:32 <ac> how do I fix that?
00:23:35 <oerjan> i think maybe you would need an MVar to pass the pixbuf out if you really need it to be constructed inside the GUI thread
00:23:55 <oerjan> and to have the GUI thread not be the main one
00:24:39 <hpaste>  morrow annotated "Stack Overflow problem" with "this works, if you meant  intToNat :: [Int] -> Natural" at http://hpaste.org/5967#a1
00:24:52 <oerjan> (the latter seems necessary if you want to do after-the-fact calls from ghci)
00:26:07 <ac> hm. I bet pixbufNew is one library call that's safe to make in multiple threads
00:26:19 <oerjan> maybe.
00:26:25 <ac> right. it wouldn't be good to count on it
00:27:07 <ac> Does anybody else think it would be cool to be able to write interactive graphical gtk programs incrementally in ghci?
00:28:37 <ac> there's no reason you couldn't use postGUIAsync to set up event listeners, I would assume
00:31:43 <hpaste>  morrow annotated "Stack Overflow problem" with "the imports needed for the (internally) unboxed version" at http://hpaste.org/5967#a2
00:35:13 <hpaste>  (anonymous) annotated "fsqrt" with "(no title)" at http://hpaste.org/5966#a1
00:37:01 <glguy> hpaste_: url
00:37:03 <ac> oerjan: so what would MVars do for me?
00:37:04 <hpaste_> http://71.111.57.135/cgi-bin/hpaste.fcgi/
00:37:24 <oerjan> ac: they allow you to communicate things between threads
00:37:24 <glguy> the line highlighting feature is still being implemented, so the interface is a bit rough
00:37:25 <ac> I could create my PlayArea type and stick it in an MVar and pass it out of the gtk thread
00:37:34 <ac> but that data type contains pointers that I may be writing to
00:37:42 <oerjan> yep
00:38:00 <ac> so I could read the Ptr from the MVar, and then write to it later, and that doesn't really solve anything. Or does it?
00:38:56 <oerjan> well it solves the problem of getting things out of the gtk thread
00:39:26 <oerjan> but if you want locking, you would want the pointers to have MVars too
00:39:43 <ac> ok
00:40:16 <ac> so as long as takeMvar shares state with your ptr writing code, you're fine?
00:40:45 <oerjan> um
00:41:49 <ac> so if you say something like: do ptr <- takeMVar foo; pokeArray ptr; putMVar foo ptr... -- I don't know how it works...
00:41:49 <oerjan> usually you would ensure locking by having the MVar _be_ the pointers.  obviously this doesn't work with Ptrs.
00:43:52 <oerjan> ah yes, and then the drawing code would have to do takeMVar before drawing too.
00:43:56 <ac> what I need to do is read "concurrent Haskell for dummies"
00:44:07 <ac> yeah, that's what I was thinking
00:45:12 <ac> or I could just let people poke pointers with abandon, assuming it wouldn't be done much. All the gtk calls would go through postGUIAsync
00:46:43 <ac> like setLineWidth, lineTo, etc
00:47:06 <ac> I mean, it's working out so far :-P
00:47:49 <oerjan> afk
00:48:00 <ac> is there a way to make operations like pokeArray atomic?
00:48:30 <ac> I mean gauarantee that another thread won't do anything while the operation is underway?
00:48:31 <pjd> "atomic pokeArray" sounds like a special wrestling move
00:48:45 <ac> lol
00:59:03 <ac> I have a pretty murky understanding of how things like OpenGL, SDL, GLUT, Cairo, and GTK interact
01:02:11 <jones-> I'll write a wrapper around SDL and GLUT, and call it SLUT.
01:03:51 <ac> nice... when would you want to abstract those two though?
01:07:18 <jones-> When you want to name something SLUT.
01:08:07 <dmwit> Or when you want to use SLUT.
01:12:07 <ac> so has anybody here used Cairo + Gtk?
01:14:25 <ac> or even Gtk?
01:15:41 <Gilly> Does a neat builtin function exist for this: [1,2,3,4,...] -> [(1,2),(2,3),(3,4),...] ? (I mean some nice approach using map or similar)
01:16:20 <glguy> zip [1..]
01:16:23 <glguy> oh
01:16:33 <quicksilver> > let l = [1..] in zip l (tail l)
01:16:35 <glguy> zipWith (,) x (tail )
01:16:36 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:16:53 <glguy> heh zipWith (,) whoops
01:17:06 <Gilly> what does tail do?
01:17:13 <yondalf> zipWith (,) == zip, right?
01:17:16 <quicksilver> > tail "abcd"
01:17:16 <lambdabot>  "bcd"
01:17:22 <Gilly> ah
01:17:24 <Gilly> ok thanks :)
01:17:25 <quicksilver> Gilly: everything but the first.
01:17:51 <quicksilver> there is an aztec god of this operation yielding [(1,2),(2,3),(3,4)...]
01:18:04 <quicksilver> his name is hard to pronounce, but it's something like zip`ap`tail
01:18:16 <osfameron> groan
01:18:30 <Gilly> :)
01:18:41 <yondalf> > (zip `ap` tail) [1..]
01:18:42 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:18:46 <pjd> @src tail
01:18:46 <lambdabot> tail (_:xs) = xs
01:18:46 <lambdabot> tail []     = undefined
01:20:58 <Gilly> where is ap defined?
01:21:04 <oerjan> @index ap
01:21:04 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
01:21:04 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
01:21:29 <oerjan> Control.Monad
01:22:55 <dmwit> ac: I have used Cairo + Gtk2Hs... but from earlier discussion, I doubt I got far enough in it to answer your questions.
01:23:32 <Gilly> hmhm, i try yondalf's line in ghci but it produces an error
01:23:37 <Gilly> i did load Control.Monad
01:23:44 <Gilly>    No instance for (Monad ((->) [b]))
01:23:44 <Gilly>       arising from a use of `ap' at <interactive>:1:1-13
01:23:53 <quicksilver> you need Control.Monad.Instances
01:23:57 <quicksilver> or Control.Monad.Reader
01:24:28 <Gilly> Control.Monad.Reader works at least
01:24:28 <quicksilver> they define the monad instance for (->) which is what I'm using.
01:24:47 <pjd> or Control.Monad.Applicative:
01:24:47 <pjd> > (zip <*> tail) [1..]
01:24:48 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:24:49 <oerjan> ac: i assume the general way to lock anything is to wrap it in MVar... most other locking abstractions are built on those i think
01:24:50 <pjd> err
01:24:54 <pjd> Control.Applicative
01:25:01 <opqdonut> does "(Monad m, Monad n) => m n a" make sense?
01:25:07 <ac> dmwit: well I was wondering about a simple question about drawing. If you're going to be drawing graphics, the proper way to do it is to create a Pixbuf in memory, and whenever the window needs drawing, call drawPixbuf drawable context pixbuf... ?
01:25:17 <dmwit> opqdonut: No, maybe try monad transformers...?
01:25:32 <dmwit> opqdonut: Or, m (n a), which *could* make sense.
01:25:34 <opqdonut> i meant "m (n a)" of course :)
01:25:38 <Gilly> Ok so can someone now explain what's happening with zip `ap` tail? :)
01:25:55 <oerjan> opqdonut: it can make perfect sense
01:26:07 <pjd> :t join . join
01:26:07 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
01:26:10 <Gilly> i could understand zip l (tail l) but that aztec god seems angry
01:26:12 <dmwit> ac: Whoa, I don't remember any pixbufs... let me see if I can find that old code.
01:26:23 <oerjan> say if you are using Parsec to directly build an interpreter IO action
01:26:24 <opqdonut> oerjan: with something like "liftM (>>= g >>= h)" ?
01:26:25 <ac> dmwit: that's how I'm doing it now
01:26:34 <ac> dmwit: so I essentially have a double buffer
01:26:38 * oerjan has done that
01:26:47 <opqdonut> Gilly: :t ap
01:26:50 <opqdonut> :t ap
01:26:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:26:59 <opqdonut> now replace m with "r ->"
01:27:19 <dmwit> ac: renderWithDrawable, maybe?
01:27:22 <opqdonut> :t ap :: (r->a->b) -> (r->a) -> (r->b) -- see here
01:27:22 <lambdabot> forall r a b. (r -> a -> b) -> (r -> a) -> r -> b
01:27:47 <ac> dmwit: yeah that's if you want to use Cairo. That's a different question -- how Gtk and Cairo interact
01:27:53 <opqdonut> so ap in the (->) monad takes a two-argument function and produces the second argument from the first
01:28:00 <opqdonut> with the help of the (r->a) function
01:28:08 <opqdonut> Gilly: you following mw?
01:28:20 <dmwit> ac: Oh, sorry, I thought you were asking about Cairo.
01:28:22 <pjd> Gilly: the reader monad embodies the idea of a shared environment
01:28:25 <Gilly> opqdonut: wait a minute, just switched back to irssi
01:28:27 <ac> dmwit: I was at first
01:28:40 <pjd> you have (zip l) (tail l), or (zip l) applied to (tail l)
01:28:42 <dmwit> ac: I don't know much about plain Gtk drawing, sorry.
01:28:44 <ac> dmwit: if you can tell me how to use renderWithDrawable I'd be happy, because I'll probably use that eventually
01:28:57 <oerjan> opqdonut: oh and those (r ->) monad tricks can give such m (n a) actions too
01:29:20 <opqdonut> oerjan: if i have two different reader monads?
01:29:26 <opqdonut> ah of course
01:29:46 <Gilly> opqdonut: ok, i think i got it
01:29:59 <opqdonut> Gilly: also, see pjd's explanation. it's a bit clearer :)
01:30:10 <dmwit> ac: You'll probably like this, too, if you haven't seen it yet: http://haskell.org/hoogle/?package=gtk
01:30:30 <oerjan> opqdonut: or if you have (r ->) plus lists
01:30:52 <opqdonut> oerjan: yeah but [m a] is sort of a special case?
01:31:09 <opqdonut> i mean you usually use sequence and that sort of stuff and not the Monad [a] instance
01:31:15 <oerjan> hm it's a frequent case
01:32:30 <oerjan> > join (liftM2 (,)) [1,2,3]
01:32:31 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
01:32:38 <oerjan> :t join (liftM2 (,))
01:32:38 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m a2 -> m (a2, a2)
01:32:51 <ac> so I guess you'd do the same thing with Cairo... create a Pixbuf, then use renderWithDrawable to create a Cairo context, draw on it using Cairo, and then use drawPixBuf to display it somewhere in your gtk program
01:33:07 <oerjan> that uses the (r ->) monad to build a list action
01:33:40 <ac> I'm thinking that if I want to support fooling with gtk widgets from a different thread, it's going to be a real pain
01:34:19 <dmwit> ac: Widgets typically have a DrawingArea that you can use, no pixbuf's required (though that may not be what you want).
01:34:57 <ac> dmwit: but that DrawingArea gets wiped out by many windowing operations
01:35:00 <aleator_> Any cabal gurus around? "dist/build/Test1.chs.h:1:25: error: test1_api.h: No such file or directory" even though the said api is in directory where I'm building. (What is the trick?)
01:35:27 <ac> dmwit: I'm pretty sure if you want a persistent picture (as opposed to an animation maybe) you want to draw to a pixbuf
01:35:46 <ac> and even if you want an animation you probably want to double buffer it using a pixbuf
01:36:10 <dmwit> Okay.  My program was never very performant, so I don't have much experience.
01:36:31 <ac> (I could be wrong, which was why I was asking the gtk drawing question)
01:39:11 <hpaste>  Gilly pasted "Some non-working code" at http://hpaste.org/5973
01:39:53 <Gilly> Any ideas/workarounds for this? I want to have some class that has a function that returns a list of elements of data type of some other class.
01:42:15 <hpaste>  ryani pasted "monads implemented with MonadPrompt" at http://hpaste.org/5974
01:42:41 <quicksilver> Gilly: Your type signature for 'func' says that it can return any instance of 'AnotherTestClass'.
01:43:12 <Gilly> quicksilver: yes
01:43:13 <hpaste>  ryani annotated "monads implemented with MonadPrompt" with "Prompt definition" at http://hpaste.org/5974#a1
01:43:17 <quicksilver> Gilly: when you implement it, you return one particular type.
01:43:30 <quicksilver> Gilly: that's not good enough. You have to prepared to return any type.
01:43:32 <Gilly> oh... should I go for forall?
01:43:44 <quicksilver> that won't change it.
01:44:02 <quicksilver> if this is, in fact, what you really want you need an existential wrapper.
01:44:15 <Gilly> ok
01:44:42 <quicksilver> your example is cut back to the minimum and as such it lacks motivation :)
01:44:52 <quicksilver> Existentials aren't needed very often in practice.
01:44:53 <Gilly> well :) want me to explain my real use?
01:44:57 <quicksilver> Occasionally they are.
01:44:59 <quicksilver> Sure, go ahead.
01:45:15 <Gilly> Ok... I have a class Drawable which implements a function draw that returns a list of points.
01:45:44 <Gilly> Then I want to be able to return a list of these Drawables from some higher-order plottable things.
01:46:03 <Gilly> I'm creating a plotter and I want to estimate the curve by say DrawableSegments
01:46:19 <Gilly> but some other day I might want to add DrawableSplines too
01:46:55 <quicksilver> then you probably do want a existentials, yes.
01:47:48 <Gilly> yea... gonna do that then
01:47:59 <quicksilver> there are other ways of doing it though
01:48:00 <Gilly> is there a common naming convention for existentials?
01:48:07 <quicksilver> did you consider just returning the draw function?
01:48:50 <Gilly> hmm...
01:49:09 <Gilly> that might work
01:49:24 <quicksilver> in a sense, that is what an existential does actually.
01:49:33 <quicksilver> or, you could go one stage more concrete and just return the lists of points
01:49:38 <quicksilver> (making a list of lists of points)
01:49:57 <quicksilver> not that I"m trying to discourage you from using existentials :) but there are sometime more direct ways.
01:50:27 <Gilly> yea i just got to figure out some things because i want adequate level of abstraction to be able to plunge in some transformations in the rendering phase that would affect all the curves ;)
01:50:41 <quicksilver> data AnyParticle = forall s . Any (Particle s)
01:50:44 <lenbust> how do I best debug errors like "Non-exhaustive patterns in function f"?
01:50:48 <quicksilver> is a typical naming convention, FWIW.
01:51:05 <Gilly> ok thanks
01:51:12 <quicksilver> lenbust: add to the funciton "f" a catch-all clause with a more informative error message.
01:51:16 <dmwit> lenbust: Look at the definition of the data type you're pattern matching against and look for missing patterns. ;-)
01:51:18 <Gilly> i'm going to eat lunch now but will look at it after, thanks for your help
01:51:31 <dmwit> lenbust: Oh, never mind me, I was just confused.
01:51:38 <lenbust> dmwit, :-)
01:51:45 <quicksilver> lenbust: e.g. f x y z = error $ "f called with invalid parameters " ++ show [x,y,z]
01:52:01 <lenbust> quicksilver: yeah, that was my first thought
01:52:01 * glguy encourages input on the line highlighting concept before the non-raw interface is implemented
01:52:04 <glguy> hpaste_: url
01:52:07 <hpaste_> http://71.111.57.135/cgi-bin/hpaste.fcgi/
01:52:14 <lenbust> quicksilver: oh, nice show - thanks!
01:52:29 <dmwit> glguy: line highlighting?
01:52:33 <quicksilver> assuming you have show instances for all the bits, of course
01:52:49 <glguy> dmwit: ability to make lines in a paste highlight after it is pasted
01:52:53 <dcoutts> aleator_: did you get the include path issue sorted out?
01:52:57 <lenbust> quicksilver: certainly
01:53:01 <glguy> to draw attention to a specific part of a paste
01:53:17 <glguy> with the current interface you can type a number in
01:53:21 <glguy> and add or remove highlighting
01:53:26 <glguy> for that line
01:53:27 <quicksilver> glguy: seems quite sexy.
01:53:37 <quicksilver> glguy: are you looking for coments on presentation or interface?
01:53:40 <glguy> the final interface is going to be somewhere between checkboxes
01:53:41 <glguy> and ajax
01:53:44 <glguy> clicking stuff
01:53:50 <glguy> quicksilver: ideas for interface
01:53:54 <glguy> and comments on the concept
01:54:01 <quicksilver> the concept is nice.
01:54:14 <quicksilver> I guess the nicest interface would be something simple like ctrl-click on the text.
01:54:28 <dmwit> The concept is nice, though it seems like something that ought to be done at paste-time, not post-paste.
01:54:29 <quicksilver> click on the line number could work
01:54:38 <glguy> dmwit: the idea is you could say: here is your problem
01:54:45 <glguy> in addition to "here is my problem"
01:54:50 <dmwit> Do you still have annotations?
01:55:03 <glguy> yeah, but I think they address a slightly different need
01:55:27 <aleator_> dcoutts: Kinda. I was supposed to use "install-includes:" in cabal I think.
01:55:55 <glguy> I'm going to add regexp searching of pastes eventually
01:55:55 <dmwit> It just makes me... "uncomfortable", I guess, that people could be talking about different versions of a paste.
01:56:05 <dmwit> Though now that I think about it, it doesn't seem so common.
01:56:51 <dcoutts> aleator_: install-includes would not affect building, that's just for what .h files get installed to be used by dependent libs
01:57:13 <dcoutts> aleator_: from the message I'd have said you want include-dirs: . or something like that
01:57:20 <dmwit> Interface idea: can you actually find out what text is selected?
01:57:30 <glguy> ?
01:57:41 <quicksilver> glguy: it certainly could be confusing in-use if three people are all viewing it and seeing different hilights because they're out of sync.
01:57:45 <lenbust> oh, it is not possible to derive Show for a GADT?
01:57:59 <quicksilver> glguy: are you planning ajax polling hackery?
01:58:03 <dmwit> i.e. the interface is: select (with the mouse) the bits you want highlighted, then click the "toggle highlighting" button or so.
01:58:11 <glguy> quicksilver: I don't think that hpaste is a high-traffic use-case though
01:58:26 <quicksilver> dmwit: as far as I remember, it is not possible to query the 'browser selection', no.
01:58:34 <dmwit> ok
01:58:43 <quicksilver> dmwit: you can manufacture you own Javascript notion of selection instead.
01:59:23 <aleator_> dcoutts: Ah yes. That's it.
02:00:03 <aleator_> dcoutts: I'm making a wrapper for a c lib. Is it easy to get cabal run makefiles and carry .so to right places or should I just assume that they are installed properly beforehand?
02:00:31 <dcoutts> aleator_: easier to assume they're already installed
02:00:47 <dcoutts> aleator_: cabal doesn't know about building and installing .so files
02:01:01 <dcoutts> aleator_: though it can compile and link C code into a haskell lib/prog
02:01:03 <quicksilver> which is a relief, because it's a total nightmare
02:01:12 <quicksilver> look upon libtool, ye mighty, and despair!
02:01:13 <wagle_home> lazy installation?
02:01:27 <glguy> For now (no syntax highlighting caching) the version on my laptop can sustain 53.64 [#/sec] (mean)
02:01:28 <aleator_> dcoutts: Ok. Can I say that this cabal depends on some library?
02:01:43 <glguy> which should be enough until the channel grows a bit more
02:01:44 <quicksilver> if cabal tried to become libtool too, dcoutts and the other cabal developers would probably suffer permanent neural injury.
02:01:50 <wagle_home> oooOOO  libtool..  now there's a name i hoped to never hear again
02:01:52 <dcoutts> aleator_: only in the sense that you can say that it must link with it, extra-libraries: foo
02:02:04 <dmwit> Heh, this is running on your laptop?
02:02:08 <glguy> yeah
02:02:25 <dcoutts> quicksilver: I'll keep that in mind
02:02:26 <glguy> its the version i'm actively developing
02:02:34 <glguy> so if it's down, its because I'm breaking it :)
02:02:49 <dmwit> =)
02:03:13 <aleator_> dcoutts: Yes, I found that out already :)
02:04:03 <dmwit> Somehow, I can't imagine check-boxes fitting in with the feel of hpaste2.
02:04:12 <glguy> they'd be like line numbers on hpaste1
02:04:16 <glguy> you'd have ot bring them up
02:04:28 <wagle_home> i just remember a year of the adjacent grad students moaning in pain until one of them thought to rip out libtool
02:04:37 <aleator_> dcoutts: There is also a problem since for building things that depend on my new and shiny module, i've got to do ghc --make -L/usr/lib64/weirdlib/ Test.hs -o foo. How can I make -L work with ghci?
02:04:54 <wagle_home> so what dares to use libtool, i cant tell from the scrollback
02:06:05 <dmwit> I think I probably vote for the "click the line number to toggle highlighting" idea, but only because I can't think of a better one. =P
02:08:24 <dcoutts> aleator_: it should just work, ghci can load .so libs etc and it looks in -L for them
02:08:48 <dcoutts> aleator_: once your package is registered it should just work without specifying any args to ghci
02:09:40 <aleator_> dcoutts: Hmm. I'm doing something wrong then.. But anyhow, thanks for the help. Again :)
02:11:02 <quicksilver> glguy: just clicking on the line numbers would be sexier.
02:11:17 <quicksilver> glguy: they could have a 'hover' as you pass over them as a clue.
02:11:29 <quicksilver> glguy: huge numbers of checkboxes will look rather ugly. IMO.
02:18:50 <tga> howdy
02:18:56 <ryani> allo
02:20:20 <hpaste>  tga pasted "counter?" at http://hpaste.org/5975
02:20:47 <tga> if I have a function like this, that is supposed to find the first two successive numbers that match in a list
02:21:19 <tga> how can I also keep track of where I found them?
02:21:41 <glguy> keep an accumulator with the current index
02:21:51 <glguy> incrementing it recursive call
02:22:32 <Baughn> http://haskell.org/haskellwiki/OOP_vs_type_classes#Inheritance_between_instances <-- Is this right? It contradicts earlier information from this channel.
02:22:32 <lambdabot> http://tinyurl.com/yu9ket
02:23:00 <tga> glguy: that's what I thought initially, just making sure there is no fancier way to do it
02:23:00 <glguy> Baughn: you'll have to be more s pecific
02:23:17 <Baughn> glguy: The instance declarationin 3.4
02:23:36 <quicksilver> Baughn: Erm. That section is at best poorly described.
02:23:52 <quicksilver> Baughn: and at worst it may be entirely wrong. I'm not quite sure what it's trying to say.
02:24:18 <quicksilver> Baughn: I would never call that 'Inheritance between instances'
02:25:11 <Baughn> quicksilver: It seems to be trying to say that "If a is Cmpable, then a is also Eqable", but from what I understand it actually means "All as are in Eq, and all as are therefore also in Cmp"
02:25:29 <glguy> no, it's saying you could convert an Ord
02:25:31 <glguy> to an Eq
02:25:41 <glguy> explicitly
02:25:50 <Baughn> Where did Ord come from?
02:26:08 <glguy> given a comparison function, you could produce an ==
02:26:16 <glguy> that's the example under the instances
02:26:20 <quicksilver> in the absence of overlapping/undecidable instances, I think Baughn's description is good.
02:26:44 <Baughn> byorgey: ping?
02:26:47 <quicksilver> instance (Cmp a) => Eq a where ... does indeed say "All as are Eq, but using them as such will cause a Cmp constraint"
02:27:12 <quicksilver> in the presence of overlapping / undecidable, I'm not sure the best way to word it.
02:27:31 <glguy> considering that Eq is already a superclass of Ord
02:27:34 <glguy> it's hard to discuss
02:27:36 <quicksilver> Of course it *is* true that that instance constructs and Eq dictionary for a Cmp dictionary.
02:27:40 <Baughn> I read that as "This will fail to compile unless you actually instance Cmp for a"
02:27:52 <quicksilver> glguy: This discussion has nothign to do with Ord. Or the Prelude.
02:28:06 <quicksilver> glguy: it relates to two small concrete classes defined there in section 3.4.
02:28:07 <hpaste>  tga pasted "what third parameter?" at http://hpaste.org/5976
02:28:10 <quicksilver> (it's just an exacmple)
02:28:20 <tga> one more simple thing, I think I'm screwing up the syntax somehow
02:28:24 <ac> I think it would be cool to have a :source command in ghci that would load a file without blowing away all the current definitions
02:28:31 <tga> it looks like I have a third parameter, but I can't see it
02:29:01 <Baughn> tga: Which line is #12?
02:29:14 <tga> sorry, second line
02:29:20 <doserj> tga: checkeps (i+1) xs
02:29:20 <glguy> quicksilver: and what was the "contradiction"?
02:29:31 <ac> what are the technical limitations to doing that?
02:29:41 <quicksilver> glguy: "Inheritance between instances (in "instance" declaration) means that operations of some class can be executed via operations of other class"
02:29:46 <quicksilver> glguy: I just think that's a poor description.
02:29:50 <quicksilver> I wouldn't call it inheritance.
02:30:00 <tga> doserj: doh, thank you
02:30:17 <glguy> no, Baughn said that contradicted someting else
02:30:39 <Baughn> glguy: It contradicts my understanding of type classes, yes
02:31:44 <Baughn> glguy: I was assuming that if you said "instance Foo a => Bar b", that wouldn't compile unless there actually was an instance of Foo a. Are you saying it actually only fails if you try to use a Bar for a type b that doesn't have a Foo instance?
02:33:05 <glguy> Baughn: Foo a => Bar b doesn't make sense
02:33:09 <glguy> Foo a => Bar a ?
02:33:19 <Baughn> Er. Yeah.
02:33:49 <quicksilver> Baughn: I don't understand your question.
02:33:50 <glguy> That says that for instances of Foo
02:33:54 <glguy> are instances of Bar
02:33:59 <glguy> err
02:34:12 <glguy> All Bar's of a
02:34:17 <glguy> err
02:34:19 <glguy> heh
02:34:21 <quicksilver> Baughn: I don't understand the difference between the two options you list there :)
02:34:24 <glguy> All a's that are instances of Foo
02:34:29 <Baughn> The source of my confusion: < byorgey> ddarius: as in, only some a's are instances of Bar.  But it really means, "all a's are instances of Bar, and if you use one, it has to be an instance of Foo, too"
02:34:35 <glguy> are also instances of Bar
02:34:44 <quicksilver> yes.
02:34:51 <quicksilver> Baughn: I agree with byorgey's description
02:35:10 <quicksilver> Baughn: can you give a concrete example which you are unsure if it would be a compile error or not?
02:35:43 <Baughn> quicksilver: (2::Int)+(3::Int), where there is no Foo instance for Int
02:35:57 <Baughn> Okay, I suppose I could check it pretty easily, but I'm looking for the general rule
02:36:02 <glguy> instance Foo a => Bar a    isn't making any claims that any instances exist
02:36:23 <Baughn> It's just saying that every instance of Bar must have a matching instance of Foo, right?
02:36:46 <glguy> it is saying that every instance of Foo is an instance of Bar
02:36:54 <quicksilver> Baughn: erm. Is (+) supposed to be a method of Bar? Or Foo? ;)
02:37:00 <Baughn> quicksilver: Neither. ;)
02:37:15 <quicksilver> Baughn: Then (2::Int)+(3::Int) resolves to (5::Int).
02:37:23 <quicksilver> Baughn: when do Bar and Foo enter the picture? ;)
02:37:31 <tga> cheers
02:37:39 <Baughn> quicksilver: In the part where Bar claims to have an instance for *every* type
02:37:52 <glguy> *every type* that is an instance of Foo
02:37:54 <quicksilver> Baughn: Right. But that doesn't matter until you try to use it.
02:37:58 <swiert> @seen mattam
02:37:58 <lambdabot> mattam is in #haskell and ##logic. I don't know when mattam last spoke.
02:38:10 <quicksilver> Baughn: type classes are checked lazily.
02:38:12 <Baughn> quicksilver: Thank you. That's what I was trying to figure out
02:38:13 <quicksilver> (in a sense)
02:38:26 <quicksilver> they're only checked when you actually try to type-check something involving that class.
02:38:47 <mattam> hi swiert
02:39:01 <swiert> hi. I'm afraid I have another Program question...
02:39:18 <mattam> Good
02:39:28 <quicksilver> glguy: well, it sort-of does say that.
02:39:38 <swiert> I'm getting a few obligations that I wasn't expecting...
02:39:39 <quicksilver> glguy: instance Foo a => Bar a says the following:
02:39:47 <swiert> Can I send you the file?
02:39:58 <quicksilver> "When searching for an instance of Bar, check if it matches the type "a"
02:40:05 <quicksilver> (all types match "a", so that's a YES)
02:40:18 <mattam> Of course
02:40:19 <quicksilver> Now add the constraint "Foo a" to the current context
02:40:25 <quicksilver> and continue resolution.
02:40:44 <mattam> Which version of Coq are you using ?
02:41:09 <Baughn> quicksilver: But once you have done that, can you still (using overlapping instances, perhaps?) instance a Bar b without a matching Foo b and have it work?
02:41:23 <glguy> the instance ought to be undecidable
02:41:35 <glguy> and complain about the the constraint not being smaller..
02:42:03 <quicksilver> Baughn: using overlapping instances, all bets are off.
02:42:13 <quicksilver> Baughn: I believe you can, yes. I never use them in my own code.
02:42:21 <quicksilver> Baughn: (because I don't understand the rules well enough)
02:42:42 <quicksilver> glguy: why? it's perfectly valid haskell98.
02:42:45 <Baughn> I probably shouldn't try, then.
02:42:46 <wagle_home> when i was using overlapping instances, i found it was deciding which instance to use at run-time using pattern matching
02:42:59 <quicksilver> glguy: it just doesn't mean what people want it to mean.
02:43:14 <quicksilver> wagle_home: It's not really doing that at run-time. Although it might feel like it.
02:43:23 <quicksilver> wagle_home: instance resolution is a compile-time affair.
02:43:23 <glguy> quicksilver: when I saw "ought to be"
02:43:25 <wagle_home> i was getting run-time errors
02:43:34 <glguy> quicksilver: I mean you should expect t osee such an error when you ask ghc to do it
02:43:58 <doserj> quicksilver: it is not Haskell98
02:44:00 <quicksilver> wagle_home: *blink* are you sure?
02:44:04 <glguy> Besides, that example doesn't work for a totally different reason, Ordering isn't an instance of Eq
02:44:10 <glguy> so the example instance is invalid
02:44:22 <glguy> (it's an instance in this sandbox)
02:44:25 <glguy> isn't*
02:44:43 <quicksilver> wagle_home: I can't think of any way you can get a runtime type class resolution error.
02:44:50 <quicksilver> wagle_home: maybe I've misunderstood/forgotten something.
02:44:51 <wagle_home> pretty sure, but i lost it when my disk got overwritten..  need to try recovering it again this weekend
02:45:05 <quicksilver> glguy: you're right, but I think that's a bit pedantic.
02:45:12 <quicksilver> glguy: it's clear what the intention is :)
02:45:44 <quicksilver> glguy: consider it rewritten as (case cmp a b of EQ -> True ; _ -> False)
02:45:52 <wagle_home> well, actually, its just laing's OR class for his subtypes
02:45:53 <doserj> > EQ == EQ
02:45:54 <lambdabot>  True
02:46:05 <quicksilver> doserj: how is it not haskell98?
02:46:07 <glguy> (it's an instance in this sandbox)
02:46:11 <glguy> doserj: ^
02:46:33 <wagle_home> and i was probably using hugs
02:46:51 <quicksilver> doserj: instance [scontext =>] qtycls inst [where idecls]
02:46:59 <doserj> All instance types must be of the form (T a1 ... an) where ...
02:47:13 <quicksilver> doserj: "a" is a degenerate form of (T a1 ... an)
02:47:16 <explisixjelly> hi.
02:47:43 <doserj> ghc wants me to add FlexibleInstances
02:47:58 <swiert> mattam: 8.1pl2.
02:48:02 <quicksilver> doserj: for which exact code?
02:48:11 <explisixjelly> let's suppose I have a type class Foo which declares foo and a type class FooA which declares fooA. I can't do the following:
02:48:21 <explisixjelly> instance FooA a => Foo a where
02:48:22 <wagle_home> quicksilver, you know which paper i'm talking about?
02:48:30 <quicksilver> wagle_home: no...
02:48:32 <swiert> mattam: sent the e-mail.
02:48:33 <explisixjelly>   foo x = fooA x
02:48:40 <explisixjelly> is it possible, somehow?
02:48:42 <doserj> "instance (Cmp a) => MyEq a where ..."
02:48:50 <quicksilver> explisixjelly: funnily enough we were just talking about that.
02:48:58 <quicksilver> explisixjelly: it's a bit fiddly.
02:49:15 <quicksilver> explisixjelly: you want all FooAs to be Foos, right?
02:49:22 <explisixjelly> quicksilver, exactly!
02:49:47 <glguy> quicksilver: the Haskell98 report doesn't seem to allow the single tyvar case
02:50:06 <quicksilver> explisixjelly: then you probably want Foo to be a superclass of FooA
02:50:25 <explisixjelly> ahah. how do I do that?
02:50:26 <quicksilver> explisixjelly: class Foo a => FooA a where ...
02:50:35 <glguy> needs to be: gtycon | (gtycon tyvar1 ... tyvark) | (tyvar1,...,tyvark) | [tyvar] | (tyvar1 -> tyvar2)
02:50:40 <mnislaih> dcoutts: has include-dirs been renamed in the ghc HEAD version of Cabal ?
02:50:52 <quicksilver> glguy: Hmm. That's interesting.
02:50:55 <dcoutts> mnislaih: not so far as I know
02:51:16 <explisixjelly> quicksilver, hmm. I think I need the opposite.
02:51:25 <doserj> and with flexible instances, it still requires undecidable-instances :)
02:51:45 <explisixjelly> quicksilver, wouldn't I still need to define "foo" for every instance of FooA?
02:51:53 <wagle_home> quicksilver, ah cool, its in my short stack of papers..  "Monad Transformers and Modular Interpreters", Sheng Liang, Paul Hudak, Mark Jones.  POPL '95.
02:52:03 <ketil> Should I put SimpleArgs on hackage (it's now at malde.org/~ketil/simpleargs)
02:52:08 <mnislaih> ah, nevermind dcoutts, it was in the wrong place
02:52:15 <explisixjelly> I want to define "foo" only once, because it's the same in all FooAs. it calls fooA.
02:52:15 <quicksilver> explisixjelly: yes, you will. it's a bit annoying.
02:52:25 <quicksilver> explisixjelly: it's considered a shortcoming of the haskell class system.
02:52:27 <explisixjelly> :(
02:52:29 <ketil> (as discussed yesterday - it provides a more typeful and error-handling getArgs function)
02:52:39 <explisixjelly> quicksilver, then I'll have to live with it
02:52:41 <wagle_home> @go "Monad Transformers and Modular Interpreters"
02:52:42 <lambdabot> http://haskell.org/papers/modular-interpreters.ps
02:53:05 <quicksilver> doserj, glguy: OK, I find this very strange now.
02:53:17 <quicksilver> I don't have time to get to the bottom of it, either.
02:53:41 <quicksilver> But, if we move outside the single-tyvar case I maintain that constraints in instance declarations are not inheritance in the way Bulat wants them to be in that document.
02:54:01 <doserj> quicksilver: I agree with that :)
02:54:11 <wagle_home> quicksilver, his OR class is on page 3, and has two multi-parameter overlapping instances
02:54:50 <mnislaih> dcoutts: does Cabal take global options that apply to all packages from some place ? I want to teach it that in my box libraries are always at /opt/local/..
02:54:55 <quicksilver> I don't really understand why haskell98 would forbid single tyvar instances.
02:55:00 <wagle_home> i think there is real subtyping available in ghc now, and its about time to check
02:55:02 <quicksilver> apart from "they don't seem very useful"
02:55:23 <mnislaih> I can modify the descriptors manually but once you get used to cabal-install it's difficult to go back
02:55:45 <wagle_home> i cant say
02:56:25 <dcoutts> mnislaih: not at the moment, if you want to implement it see tickets #221 and possibly #223
02:56:36 <doserj> quicksilver: flexible instances is I think a quite unproblematic extension
02:56:37 <wagle_home> but, if i'm right, at least hugs has to wait until runtime to decide
02:56:39 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/221
02:56:40 <lambdabot> Title: #221 (need a way to specify site-specific include and library search paths) - Ha ...
02:56:49 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/223
02:56:50 <lambdabot> Title: #223 (allow per-package configuration options in config file) - Hackage - Trac
02:57:23 <wagle_home> ... this was a couple years ago, though
02:57:29 <dcoutts> mnislaih: lots of people seem to be needing #221
02:58:00 <swiert> wagle_home: having overlapping instances in OR isn't a problem though.
02:58:06 <doserj> quicksilver: instances for type variables only get problematic, it seems, if you add constraints in the instance. And without constraints, the instance really does seem not very useful
02:58:33 <wagle_home> swiert, what is the problem?
02:59:04 <swiert> wagle_home: well, if you have overlapping instances you can't always be sure about which instance actually gets chosen.
02:59:30 <swiert> wagle_home: but in this particular example, it doesn't matter which instance gets chosen.
02:59:56 <wagle_home> apparently the order matter..  if you switch them, it doesnt work
03:00:02 <mnislaih> dcoutts: if I understand well, config is already used for global options. The problem is that options for external dependencies are local to every stanza, right ?
03:00:04 <swiert> wagle_home: there's a paragraph explaining why in the a la carte paper.
03:00:18 <mnislaih> I mean .cabal/config above
03:00:27 <swiert> wagle_home: which order matters?
03:00:32 <wagle_home> a la carte?
03:00:43 <swiert> @go data types a la carte
03:00:43 <wagle_home> the order you define the two instances
03:00:44 <lambdabot> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
03:01:05 <dcoutts> mnislaih: currently there is no way to say "look for system C libs in this include dir and this library dir"
03:01:36 <dcoutts> mnislaih: so step 1 is to add that as a configure flag and step 2 is to let all such configure options be specified in the .cabal/config file
03:01:54 <dcoutts> mnislaih: currently the .cabal/config is ad-hoc and doesn't cover every single configure option
03:02:14 <mnislaih> Could we then extend .cabal/config with a stanza part that contains global options for stanzas ?
03:02:30 <swiert> wagle_home: I'm not convince the order of the two instances of SubType matter...
03:02:38 <swiert> wagle_home: I'd be surprised if they did.
03:03:42 <wagle_home> swiert, that's what i remember..  will poke at it again soon (after a couple years)..  thanks for the paper..  (its now 3am..  8) )
03:03:46 <mnislaih> stanza = I think you are calling these 'sections' in the Cabal documentation
03:03:49 <dcoutts> mnislaih: they'd all be global options unless we implemented the other part of that ticket which is per-package config options
03:04:05 <swiert> wagle_home: sure, np.
03:04:43 <mnislaih> dcoutts: I haven't read the emails referenced in the ticket, but that seems ugly on a first look
03:05:09 <dcoutts> mnislaih: how so? what were you thinking of?
03:05:09 <mnislaih> I want to be able to say that my C libs are always in this include dir and library dir, for ANY package
03:05:49 <dcoutts> mnislaih: yes, you don't need per-package config options
03:06:43 <dcoutts> mnislaih: you just want to put "extra-include-dirs: /opt/local/include; extra-library-dirs: /opt/local/lib" in your ~/.cabal/config file
03:07:08 <dcoutts> mnislaih: and that'd correspond to passing --extra-blah-blah to every package configure call
03:07:36 <mnislaih> exactly
03:07:52 <dcoutts> mnislaih: so step 1 is to add the configure flag, and step 2 is to let all such flags be specified in the config file rather than just a few as currently
03:08:41 <mnislaih> thanks for clarifying dcoutts. I'll probably submit a patch for that
03:08:44 <dcoutts> mnislaih: we ought to be able to do the config file generically from the same description that we use for the command line flags, then we get the config in sync for free
03:09:17 <dcoutts> mnislaih: so take a look at the Distribution.Simple.Command and see about doing config from the same description
03:09:43 <dcoutts> mnislaih: it might need some tweaks to generalise it to be able to work with both
03:10:09 <Saul_> Can any of you reach www.uu.nl?
03:10:31 <swiert> Saul_: I can.
03:10:43 <Saul_> :(
03:10:52 <Saul_> I think I got banned or something
03:11:01 <mnislaih> dcoutts: what is the Cabal repo I should be patching ?
03:11:01 <wagle_home> Saul_, me too (from west coast usa)
03:11:04 <dcoutts> mnislaih: the other thing to remember is that --extra-library-dirs=/opt/blah means it has to be included into the registration info as well as used during building
03:11:14 <dcoutts> mnislaih: http://darcs.haskell.org/cabal/
03:11:20 <lambdabot> Title: Index of /cabal
03:11:25 <Saul_> I can't view the website, can't get my email and I can't ssh to my home pc when I'm on campus
03:11:53 <dcoutts> mnislaih: http://www.haskell.org/cabal/code.html
03:11:53 <lambdabot> Title: Getting the Code
03:12:23 <explisixjelly> apparently I also can't do things like:
03:12:37 <Saul_> Although I can view pages and get email when I'm on campus (on my laptop)
03:12:39 <explisixjelly> ... oh, never mind
03:13:05 <dcoutts> mnislaih: probably the thing to do is to have the extra include and lib dirs patched into the package description, then it'll get used for building and generating the package registration
03:15:55 <ndm> i've  just made a new hoogle cabal package
03:16:13 <ndm> which should do all the necessary magic, not require custom copying of data files etc
03:16:18 <ndm> but i don't have a 6.8 install anywhere nearby, so would someone be willing to 6.8 check it for me?
03:16:32 <ndm> should be as simple as configure/build/install, then "hoogle map" to check it all works
03:16:56 <mnislaih> ndm: I can help
03:17:18 <ndm> mnislaih: http://www-users.cs.york.ac.uk/~ndm/temp/hoogle-3.1.tar.gz
03:18:48 <mnislaih> ndm works !
03:19:10 <tensh> is there a nice way to accomplish removal of the last occurance of a certain item in a list and everything after it?
03:19:19 <mnislaih> hoogle (*)
03:19:19 <mnislaih> -bash: syntax error near unexpected token `*'
03:19:22 <tensh> so if I want
03:19:22 <ndm> mnislaih: many thanks :)
03:19:28 <ndm> hoogle * is the way to do it
03:19:33 <ndm> perhaps hoogle "*"
03:19:40 <mnislaih> ah, yes
03:19:47 <tensh> "asdfghayui" it would give "asdfgh"
03:19:57 <tensh> if I wanted it to break at a
03:21:03 <quicksilver> > reverse . snd . break (=="a") . reverse $ "asdfghayui"
03:21:03 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
03:21:11 <quicksilver> > reverse . snd . break (=='a') . reverse $ "asdfghayui"
03:21:12 <lambdabot>  "asdfgha"
03:21:21 <quicksilver> > reverse . tail . snd . break (=='a') . reverse $ "asdfghayui"
03:21:22 <lambdabot>  "asdfgh"
03:21:41 <tensh> ahh, nice
03:21:44 <tensh> thanks a lot
03:21:49 <quicksilver> tensh: 'last occurence' is a property which belongs to the 'far end' of the string, so using reverse is probably simpler.
03:21:52 <explisixjelly> instance FkExp String where
03:21:57 <tensh> thought snd was called second ;)
03:21:58 <explisixjelly> okay. where's the problem with *that*?
03:22:11 <quicksilver> tensh: the default list functions don't have much that works on the back end of a list, because it's pretty inefficient.
03:22:21 <quicksilver> explisixjelly: you need 'FlexibleInstances'
03:22:25 <tensh> yeah, I know
03:22:33 <explisixjelly> quicksilver, that's an extension?
03:22:36 <quicksilver> explisixjelly: yes.
03:22:43 <tensh> but it's too late to rewrite everything now
03:22:51 <quicksilver> explisixjelly: this is often criticised about the h98 standard.
03:22:57 <tensh> ran into this problem very late
03:23:29 <quicksilver> tensh: it's not a problem
03:23:44 <quicksilver> tensh: I was just providing motivation for the fact that my solution involved 'reverse'
03:24:26 <explisixjelly> quicksilver, what's a quick way to enable it?
03:24:38 <quicksilver> {-# LANGUAGE FlexibleInstances #-}
03:24:44 <quicksilver> at the top of the source file
03:24:47 <explisixjelly> perfect. thanks.
03:26:15 <explisixjelly> ah. turns out, I don't need my instanciation anyway, because I already have a more general one of "instance (FkExp a) => FkExp [a]", now I just need one for FkExp Char 8)
03:26:21 <explisixjelly> so, no extension
03:38:14 <quicksilver> explisixjelly: :)
03:45:43 <Baughn> "package glib-0.9.12.1 has missing dependencies: base" <-- What is this, now?
03:47:18 <explisixjelly> hmm. I want a function to do the same for some (but not all) type constructors of some type, e.g.: myfun e@(Bar _) = foo, myfun e@(Baz _ _) = foo... do I have to repeat the definition over and over again?
03:47:22 * jeffz resists the urge to make a joke.
03:47:51 <quicksilver> explisixjelly: there is no clever shortcut for multiple patterns.
03:47:59 <quicksilver> explisixjelly: I suggested it once to SPJ, in fact.
03:48:12 <explisixjelly> quicksilver, thanks
03:48:17 <quicksilver> you might consider something like:
03:48:27 <quicksilver> myfun e | isBarOrBaz e = foo
03:48:33 <quicksilver> ... (other cases go next)
03:49:06 <explisixjelly> ah. hmm. yes, that's a good idea, that isBarOrBaz function might be useful in other cases. thanks!
03:49:09 <quicksilver> "isBarOrBaz" may have a more logical name in a concrete examples.
03:49:10 <quicksilver> right.
03:49:22 <quicksilver> it often denotes something about your domain of interest.
03:49:39 <explisixjelly> "issugar" in my case %)
03:50:44 <explisixjelly> one other possibility would be splitting up the data type, but I'll leave it like that.
03:50:54 <ac> in the "Tackling the awkward squad" paper, a function called "evaluate" is introduced. What's that actually called in GHC?
03:52:22 <dcoutts> yay, hoogle 3.1 is on hackage!
03:52:26 <dcoutts> ndm: :-)
03:52:46 <ndm> dcoutts, yep, have just sent out a release annoucement, but it should now be cabal-install-able
03:52:54 * dcoutts tries it
03:53:12 <ndm> dcoutts, i also wrote a mini tutorial on adding data files to a cabal package, which has already been used to upload other cabal packages
03:53:50 <jacobian> SML/NJ has Or-Patterns http://www.smlnj.org/doc/features.html
03:53:50 <lambdabot> Title: SML/NJ Special Features
03:54:10 <dcoutts> ndm: and we want to be able to have cabal-install generate and install hoogle dbs for every installed package
03:54:23 <dcoutts> ndm: we're half way there with cabal being able to generate them
03:54:29 <ndm> dcoutts, that is for hoogle 4 :)
03:54:43 <dcoutts> ndm: ah ok, and the other side is a bit of cabal infrastructure
03:54:49 <jacobian> that would be slick
03:55:06 <dcoutts> ndm: we have to do the same with docs and colourised code (and maybe tags)
03:55:38 <quicksilver> jacobian: I think it would be a good feature for haskell, too.
03:55:50 <quicksilver> jacobian: (although it's a bit borderline, it's not very important very often)
03:56:08 <dcoutts> ndm: I thought hoogle only gave the first few results! woosh!
03:56:17 <dcoutts> $ hoogle 'String -> ByteString' | wc -l
03:56:17 <dcoutts> 72
03:56:17 <ndm> dcoutts, yeah, lots of work there - the underlying hoogle infrastructure needs a lot of work on it
03:56:25 <ndm> dcoutts -n 10
03:56:30 <jacobian> quicksilver: Yeah, not really a critical feature.
03:56:46 <ndm> as a web page, yes, it gives only the first few results
03:56:48 <dcoutts> ndm: aye, right, that'd be a nice default
03:56:57 <ndm> as a console app, use less or head
03:57:07 <dcoutts> defaults defaults
03:57:12 <dcoutts> :-)
03:57:46 <dcoutts> ndm: it did cabal install perfectly though which is nice :-)
03:58:28 <mibii> hpaste.org/5978 - noob needing help =)
03:58:35 <ndm> dcoutts, previously the command line version was merely a test harness for the web version, i think what is really needed is an interactive mode
03:58:39 <quicksilver> I disagree.
03:58:44 <ndm> otherwise you get various issues with quoting and escaping
03:58:55 <quicksilver> commadline app should give all results as default, just like it does.
03:58:57 <ndm> interactive as well as command line version, not instead of
03:59:03 <dcoutts> ndm: aye, I have to $ hoogle "foo -> bar"
03:59:07 <quicksilver> should "ls" have build in paging? :)
03:59:08 <dcoutts> ndm: right, both is nice
03:59:10 <quicksilver> ndm: oh, definitely.
03:59:17 <quicksilver> ndm: I wasn't disagreeing with that :)
03:59:22 <ndm> dcoutts, you can hoogle foo -# bar
03:59:27 <quicksilver> I was disagreeing with < dcoutts> defaults defaults
03:59:58 <dcoutts> quicksilver: well it's a different thing I think, the list of results is almost unbounded
03:59:59 * ndm has pipped the results of hoogle into bar many times...
04:00:13 <dcoutts> ndm: yeah :-)
04:00:17 <ndm> dcoutts, part of that is that hoogle goes for any match, sometimes very dubious
04:00:24 <ndm> search for :: a to see a lot of results
04:00:25 <quicksilver> no more almost unbounded than the results of "find /"
04:00:30 <quicksilver> or "ls -lR"
04:00:33 <quicksilver> or all kinds of things.
04:00:54 <dcoutts> quicksilver: no those are really specific queries, not fuzzy ones where you're only ever interested in the first 5
04:01:08 <quicksilver> that's true.
04:01:14 <dcoutts> quicksilver: and those are used for input to other progs
04:01:27 <sm>  yay, thanks ndm
04:01:34 <sm> & dcoutts
04:01:39 <dcoutts> hoogle --show-me-even-more-results "a -> b"
04:01:59 <dcoutts> doesn't seem unreasonable since you only want it 1% of the time
04:02:34 <mibii> hpaste.org/5978 - anyone? =) im having problems breaking a list =)
04:02:52 <ndm> i can see arguments both ways with it :)
04:03:21 <ndm> you can always alias hoogle to hoogle --count=10
04:03:55 <quicksilver> if hoogle had a quality metric
04:04:06 <quicksilver> then I could imagine the default only being "results of quality at least 0.1"
04:04:08 <quicksilver> or something
04:04:55 <ndm> quicksilver: it does, but the quality metric is rather poor - its scheduled to get overhalled in 4.0
04:05:06 * quicksilver nods
04:05:27 <ndm> i can actually see the spec of the revised quality metric on my desk from here
04:05:35 <ndm> which i wrote over a year and a half ago
04:06:22 <ndm> http://neilmitchell.blogspot.com/2007/04/hoogle-4-type-matching.html
04:06:23 <lambdabot> Title: Neil Mitchell's Haskell Blog: Hoogle 4 type matching, http://tinyurl.com/2ljml5
04:12:13 <ndm> dcoutts, was thinking cabal thoughts last night, and its a real shame that Paths_hoogle has to use the FFI, and can't use the normal FilePath functions
04:12:47 <ndm> the FFI bit is particularly painful, as it means you can't use the autogenerated paths with Hugs without running the hugsffi tool over it, which i don't have the slightest idea how to do
04:13:50 <ndm> i guess it means adding filepath and cabal_lite packages to the build, but that doesn't seem the end of the world
04:20:43 <mibii> >groupBy (\x y-> not (isPrefixOf y "head")) ["headr1a","headr1b","","messg1a","msg1b","","headr2a","headr2b","","msg2a","msg2b"]
04:21:21 <resiak> libtracker's C API provides blocking calls to the daemon, or async calls using the glib mainloop.  Given that I don't want to force the glib mainloop on, well, myself when using the Haskell bindings, should i be running the blocking calls in forkOS or similar to prevent all other haskell threads blocking?
04:21:52 <mibii> >groupBy (\x y-> not (isPrefixOf y "head")) ["headr1a","headr1b","","messg1a","msg1b","","headr2a","headr2b","","msg2a","msg2b"]
04:22:26 <sek> > 1+1
04:22:27 <lambdabot>  2
04:22:35 <sek> >1+1
04:24:08 <mibii> > groupBy (\x y-> not (isPrefixOf y "head")) ["headr1a","headr1b","","messg1a","msg1b","","headr2a","headr2b","","msg2a","msg2b"]
04:24:09 <lambdabot>  [["headr1a","headr1b"],["","messg1a","msg1b"],["","headr2a","headr2b"],["","...
04:25:13 <mibii> im having probs with groupby
04:26:01 <mibii> i want the headr and msg together
04:28:01 <quicksilver> mibii: groupBy is really designed for equivalence relations
04:28:25 <quicksilver> mibii: that's why it's behaving a bit funnily :)
04:28:54 <quicksilver> mibii: you want to get headr1ab and messg1a togther, then 1b, etc?
04:29:10 <dcoutts_> ndm: yes, it's difficult since we do need to call those win32 functions somehow, so we either have to depend on win32 or have those functions in base or use the FFI as now.
04:30:18 <dcoutts_> ndm: if you think of a better way to find the installed paths then do say
04:30:46 <mibii> what could i use  instead of groupBy? i cant seem to get recursion in my head =)
04:31:02 <dcoutts_> ndm: eg if we could construe them as something with a portable meaning and have them included into System.Directory, a bit like the one for finding the home dir
04:31:52 <quicksilver> mibii: I'm not quite sure what you want.
04:32:03 <quicksilver> mibii: you could grab all the heads and all the msgs
04:32:07 <quicksilver> mibii: and then pair them up
04:32:09 <dcoutts_> ndm: though it looks like for hugs we do not generate code that uses the ffi
04:32:13 <mauke> :t fromMaybe
04:32:14 <lambdabot> forall a. a -> Maybe a -> a
04:33:17 <quicksilver> > let l = ["headr1a","headr1b","","messg1a","msg1b","","headr2a","headr2b","","msg2a","msg2b"] in (filter ("head" `isPrefixOf`) l,filter ("msg" `isPrefixOf`) l)
04:33:18 <lambdabot>  (["headr1a","headr1b","headr2a","headr2b"],["msg1b","msg2a","msg2b"])
04:48:08 <Beelsebob> does one have to play special games to make Haskell/glut work under OS X?
04:49:28 <byorgey> I recommend Tetris
04:49:33 <Beelsebob> heh
04:49:51 <hpaste>  beelsebob pasted "OpenGL test" at http://hpaste.org/5979
04:50:10 <Beelsebob> bascially, I'm trying to compile that just to get something up and running from which I can play with Haskell/OpenGL bindings
04:50:23 <Beelsebob> but at runtime I get...
04:50:23 <Beelsebob> 2008-02-28 12:47:23.080 OpenGL[1198:10b] GLUT Fatal Error: internal error: NSInternalInconsistencyException, reason: Error (1002) creating CGSWindow
04:51:40 <Zao> Beelsebob: Good luck.
04:52:03 <Beelsebob> heh
04:52:09 <Zao> I've encountered that before with SDL and C++. Apparently I forgot to link against some framework or something.
04:52:14 <Zao> Never managed to resolve it.
04:52:59 <Beelsebob> I wonder if the same thing happens if I implement the same thing in C
04:53:09 <Beelsebob> oh bugger, got to teach... *runs of*
04:53:27 <quicksilver> I've never had any trouble with glut/osx
05:09:55 <tensh> Show and Read is killing me ;)
05:10:33 <tensh> while using generic types
05:16:02 <DRMacIver> tensh: How so?
05:17:04 <DRMacIver> Just that fact that you need to use quite a lot of type declarations?
05:17:23 <tensh> well... I need to declare it everywhere
05:17:49 <tensh> and now ghci tells me that it might work if I use it in my monad-instance
05:18:28 <tensh> like this:
05:18:35 <tensh> Could not deduce (Show a, Show r) from the context (Monad (Replay q r))
05:18:49 <tensh> Possible fix: add (Show a, Show r) to the context of the type signature for `>>='
05:19:09 <tensh> and that won't work at all
05:19:32 <Saizan> that would work if you could change the Monad class.
05:20:20 <tensh> I suppose I've written something stupid to get it in the first place ;)
05:20:35 <Saizan> you can write instance Show r => Monad (Replay q r) where ...
05:20:45 <tensh> arose from a... not so pretty, solution to a certain problem
05:21:13 <tensh> yes, that seems to work
05:21:29 <tensh> but I still need to handle a
05:21:42 <tensh> only tried it with both before
05:21:51 <sphynx> hi all!
05:21:58 <tensh> hi sphynx
05:21:58 <Saizan> you can't, at least if i understand what that a is
05:22:10 <sphynx> I wonder where is the documentation about GHC.Base in 6.8.2
05:22:12 <tensh> ok :(
05:23:00 <tensh> crap... there went my ugly solution to a nested bind problem ;)
05:23:33 <Saizan> why you need Show?
05:23:47 <sphynx> I can find it only in 6.2.2 doc. But it seems my emacs' haskell-mode resolves documentation using ":info" command from ghci and ":info error" gives me that it's defined in GHC.Err, but I can't find it latest docs on haskell.org
05:24:40 <tensh> basicly, I have this datatypes with some types called Ask, Lift and so on and I needed to write bind for them
05:24:55 <tensh> datatype*
05:25:25 <Saizan> sphynx: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Aerror
05:25:26 <lambdabot> http://tinyurl.com/ovjef
05:25:51 <tensh> so I made new constructors called BindLift etc. which I used on (Lift ..) >>= whatever =
05:25:54 <tensh> matches
05:26:11 <tensh> now I want to be able to use methods within methods
05:26:22 <sphynx> Saizan: Yeah, it is in Prelude, but is there some way to know about this from :info?
05:26:27 <tensh> which means that I might get (BindLift ...) >>= whatever
05:27:15 <Saizan> tensh: doesn't BindLift propagate the context?
05:27:26 <tensh> and I needed a solution for that so I made a new type called bind which pretty much just executes the 2 first and then continue
05:27:30 <Saizan> sphynx: probably not
05:27:33 <tensh> Saizan: what do you mean by that?
05:27:54 <sphynx> I just want automatic documentation browing like C-c C-d on some haskell symbol. Then it resolves it from ghci's ":info", find the module URL and point my browser to it
05:28:02 <Saizan> tensh: can you paste this code?
05:28:32 <tensh> sure, but could I do it in private? it's a school assignment so I don't want to spread it around
05:28:55 <tensh> a lab rather
05:29:00 <Saizan> ok
05:29:10 <trez> tensh: also taking the afp course? :)
05:29:43 <resiak> heh, it transpires that unsafe reentrancy errors can be caused not only by unsafe foreign imports (as suggested by the error), but also by failing to compile with -threaded :-)
05:30:26 <tensh> trez: yes :)
05:31:44 * shepheb vaguely remembers and old blog post about that, resiak. Might be wrong.
05:32:30 <sphynx> Saizan: does that mean that almost all from GHC.Base is now documented in Prelude.html and I can simply replace "GHC.Base" string with "Prelude" in this documentation resolving?
05:33:01 <resiak> is there any way when compiling a library to force any code using the library to use -threaded ?
05:33:19 <smg> @src head
05:33:19 <lambdabot> head (x:_) = x
05:33:19 <lambdabot> head []    = undefined
05:33:23 <smg> @src tail
05:33:23 <lambdabot> tail (_:xs) = xs
05:33:23 <lambdabot> tail []     = undefined
05:34:02 <shepheb> sphynx: Hoogle is this documentation lookup. it isn't editor-integrated, but it is very useful. you can search on function names, module names, and types.
05:35:20 <pjd> let head = foldr const undefined in head "foo"
05:40:25 <shepheb> "> file xmonad.hs
05:40:38 <shepheb> xmonad.hs: ASCII Java program text"
05:40:47 <shepheb> sigh.
05:41:09 <smg> @src take
05:41:09 <lambdabot> take n _      | n <= 0 =  []
05:41:09 <lambdabot> take _ []              =  []
05:41:09 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
05:44:42 <shepheb> file doesn't know what it's missing.
05:50:47 <Botje> ideally we'd have: "xmonad.hs: Haskell program using the X monad, won't terminate"
05:51:34 <shepheb> Botje: that's only marginally true of mine, which is a tissue of hacks right now.
05:56:10 <gnuvince> dons: when can we expect new chapters in the beta of RWH?
06:00:43 * wli would rather have head generate exceptions catchable sans IO.
06:02:56 <noteventime> Is there something like mapFst/mapSnd, for mapping over a list of pairs?
06:03:23 <ketil> noteventime, map (f . fst) ?
06:03:29 <Toxaris> > map (first (* 2)) [(1, 'a'), (2,'b')]
06:03:30 <lambdabot>  [(2,'a'),(4,'b')]
06:03:43 <gnuvince> :t first
06:03:43 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
06:03:48 <Toxaris> noteventime: use map together with first and second from Control.Arrow
06:03:53 <ndm> dcoutts, you could put these bits into a cabal-runtime package, and always link in with cabal-runtime on all platform
06:03:57 <dcoutts_> wli: sadly that breaks purity
06:04:15 <ndm> dcoutts, and you are probably right, i was taking the ghc generated paths and using it with hugs
06:04:16 <Toxaris> ketil: that would throw the snd value away
06:04:18 <dcoutts_> ndm: I don't think people would be happy with that
06:04:25 <ndm> wli: just use Catch, and prove their are no exceptions
06:04:27 <noteventime> Toxaris: Thanks
06:04:29 <ndm> dcoutts, i would be :)
06:04:31 <ketil> Toxaris, right.
06:05:15 <Toxaris> > (<$> <$> <$>) (* 2) [('a', 1), ('b', 2)]
06:05:15 <lambdabot>  Parse error at "<$>" (column 6)
06:05:20 <Toxaris> > ((<$>) <$> (<$>)) (* 2) [('a', 1), ('b', 2)]
06:05:21 <lambdabot>  [('a',2),('b',4)]
06:05:42 <Toxaris> noteventime: ^^^ another cool option
06:05:52 <wli> dcoutts: head = listToMaybe, or head :: (Monad m, Error e, MonadError e m) => [t] -> m t, etc.
06:05:58 <dcoutts_> ndm: I think we have to restrict ourselves to not adding any runtime deps, though I agree the FFI approach is not ideal, I'd prefer to use something standard in base.
06:06:05 <noteventime> Toxaris: Indeed, the first one was more readable though :P
06:06:45 <dcoutts_> wli: oh sure, using some pure representation of the error is fine, just not catching exceptions like error.
06:07:10 <dcoutts_> erm, sorry, that wasn't clear, overloading on 'error' :-)
06:23:07 <quicksilver> I have to say I think  head :: (Monad m, Error e, MonadError e m) => [t] -> m t is a pretty painful type for head :)
06:23:36 <quicksilver> I normally use head when I'm sure there can't be a problem and "case" when there is.
06:25:19 <dcoutts_> or when you think there shouldn't be a problem one can use a refutable pattern match
06:25:40 <dcoutts_> let (theThing:_) = head blah in ...
06:25:58 <dcoutts_> then you at least get a decent error message if you turned out to be wrong
06:27:19 <quicksilver> that's an interesting thought.
06:27:37 <quicksilver> I do think error-annotation combinators would be useful.
06:28:07 <hpaste>  glen_quagmire pasted "how can I parse comma separated list?" at http://hpaste.org/5980
06:28:22 <quicksilver> withError m e = case m of Nothing -> throwError e ; Just x -> return x
06:28:48 <quicksilver> glen_quagmire: all your spaces are adding ambiguity.
06:28:55 <quicksilver> glen_quagmire: parsec isn't a backtracking parser.
06:28:57 <quicksilver> (not by default)
06:29:19 <quicksilver> it's one of the things I dislike about parsec :)
06:30:02 <quicksilver> the traditional solution to this is two-phase parsing, where you munch the spaces in the first phase.
06:30:28 <glen_quagmire> oh that might work
06:30:33 <quicksilver> (the first phase is often called "lexing")
06:30:48 <quicksilver> glen_quagmire: do you understand what I mean about the spaces adding ambiguity?
06:30:58 <quicksilver> you will need to understand this to use parsec without tearing out your hair.
06:31:07 <glen_quagmire> quicksilver: not really. i was trying deleting some of P.spaces and run again...etc
06:31:20 <quicksilver> the point is, both 'comma' and 'rbracket' begin with spaces.
06:31:42 <quicksilver> when parsec is about to parse another item
06:31:54 <quicksilver> it's waiting for either a "comma" or an "rbracket"
06:31:58 <quicksilver> but they both start with spaces.
06:32:01 <dcoutts_> quicksilver: have you tried polyparse?
06:32:10 <quicksilver> when it tries one, it succeeds enough to eat some of the spaces
06:32:14 <quicksilver> and then it crashes.
06:32:23 <glen_quagmire> quicksilver: hoa you're a wizard. i deleted P.spaces in the comma and it parses
06:32:25 <quicksilver> parsec doesn't say "Oh, I'll backtrack, and try without the spaces"
06:32:38 <quicksilver> if it did, it would be what they call a backtracking parser.
06:32:54 <quicksilver> the reason it isn't is that backtracking can be very slow in pathological cases.
06:32:57 <dcoutts_> polyparse is backtracking by default with a cut operator to commit to a path, so it can drop backtracking info
06:32:58 <quicksilver> but I still find it annoying.
06:33:02 <glen_quagmire> P.try sounds like backtracking
06:33:07 <quicksilver> right, it is
06:33:11 <quicksilver> parsec gives you backtracking with try
06:33:23 <quicksilver> but it's really annoying (IMO) to have to warp all the ambiguous parts in a try.
06:33:34 <quicksilver> dcoutts_: I've read its haddock, but not actually used it.
06:33:36 <quicksilver> dcoutts_: it looks nice.
06:33:49 <quicksilver> dcoutts_: I always write my own parser combinators by hand, because I"m odd like that :P
06:33:51 <Toxaris> glen_quagmire: it's good practice assume that every parser eats all whitespace after the tokens it sucessfully parsed.
06:34:24 <dcoutts_> parsec's default is no backtracking with a try operator to add backtracking
06:34:25 <dcoutts_> polyparse default is backtracking with a cut operator to stop backtracking
06:34:39 <dcoutts_> which means polyparse parsers compose by default
06:34:53 <dcoutts_> and you can add cut for efficiency later
06:35:01 <Toxaris> glen_quagmire: you can use   lexem p = p >>= \x -> whitespace >> return x  to lift normal parsers to lexer-level parser which handle whitespace
06:35:02 <glen_quagmire> to have a lexer, do I use other library or use Parsec for lex ?
06:35:05 * malcolmw is just polishing the final version of the polyparse paper for upload to LNCS
06:35:12 <dcoutts_> malcolmw: cool
06:35:20 <glen_quagmire> if lex returns haskell data then there's no need to parse anymore?
06:35:36 <Botje> @pl \p -> p >>= \x -> whitespace >> return x
06:35:36 <lambdabot> ((whitespace >>) . return =<<)
06:36:03 <Toxaris> glen_quagmire: parser-level parsers, which are fully composed by lexer-level parsers, don't need to be lifted by lexem because the subparsers will take care of all trailing whitespace
06:36:21 <Toxaris> glen_quagmire: so you only need to take care of whitespace at the very beginning of the text you're parsing
06:36:58 <Toxaris> Botje: lexem = (<* whitespace)    but that needs Control.Applicative
06:37:22 <glen_quagmire> Toxaris: whitespace is from parsec ?
06:37:38 <glen_quagmire> oh whiteSpace
06:38:04 <Toxaris> glen_quagmire: yes, there is one in parsec, but I tend to define it myself, to take care of comments and stuff
06:39:10 <quicksilver> dcoutts_: that's a very elegant way of putting it.
06:39:14 <glen_quagmire> lexem p = p >>= (\x -> whitespace) >> return x      means try parser p then consume whitespace and return whatever follows after the parser p ?
06:39:34 <quicksilver> dcoutts_: I'd not thought of styling parsec's arrangement as being non-compostional.
06:39:50 <quicksilver> dcoutts_: but that's actually a very nice summary.
06:39:55 <dcoutts_> quicksilver: it's my understanding of malcolmw's explanation, not my idea :-)
06:39:59 * quicksilver nods
06:40:08 <quicksilver> I know I've spoken to malcolmw about it before.
06:40:08 <mauke> glen_quagmire: x is not in scope
06:40:15 <quicksilver> But that made it click.
06:40:21 <Toxaris> glen_quagmire: the definition you gave means nothing. it's (\x -> whitespace >> return x). and then, it means "try p. if it succeeds, remember it's result, eat all whitespace, and return the stored result.
06:40:44 <malcolmw> quicksilver: yep, "parsec is non-compositional" is a good summary
06:40:48 <Toxaris> glen_quagmire: it's the same as do {x <- p; whitespace; return x}
06:41:08 <malcolmw> quicksilver: it is a bit odd for a combinator library to be non-compositional though :-)
06:41:20 <quicksilver> malcolmw: yes :) that's why it's a good way of looking at it.
06:41:29 <quicksilver> malcolmw: it makes it obvious how bad it is.
06:41:52 <malcolmw> quicksilver: maybe I should add that phrase to my paper
06:42:52 <glen_quagmire> oh now I understand about >>= more
06:43:06 <dcoutts_> malcolmw: and what is interesting is that it being non-compositional causes real practical headaches, it really confuses people when they start to build bigger parsers
06:43:14 <quicksilver> glen_quagmire: yes, there is a *lightbulb* moment when you understand why it all has to associate to the right.
06:43:27 <dcoutts_> malcolmw: and they go round sprinkling try's all over the place
06:44:02 <quicksilver> glen_quagmire: and when you understand how people had the idea of writing f >>= \x -> g >>= \y -> h x y as do { x <- f; y <- g; h x y }
06:44:33 <quicksilver> if at first you can't parse lisp, (try (try (try (try (try (try ....
06:45:25 <mauke> unfortunately, lisp isn't very good at dealing with infinite programs
06:45:41 <Yoric[DT]> Hi
06:45:43 <mauke> haskell, on the other hand, has no problem with fix (putStrLn "y" >>)
06:45:55 <Yoric[DT]> Quick question from someone who hasn't used Haskell in quite some time.
06:46:02 <Yoric[DT]> Does _|_ still exist ?
06:46:14 <dcoutts_> > let undefined = undefined in undefined
06:46:15 <lambdabot>  Exception: <<loop>>
06:46:40 <quicksilver> Yoric[DT]: depends what you think "exist" means.
06:46:43 <mauke> > undefined
06:46:43 <lambdabot>  Undefined
06:46:56 <Yoric[DT]> > _|_
06:46:57 <lambdabot>  Parse error at "|_" (column 2)
06:47:08 <quicksilver> Yoric[DT]: it's not a programming construct. It's a mathematical notation which explains the semantic effect of several different programming effects.
06:47:20 <Yoric[DT]> Is it ?
06:47:20 <dcoutts_> > let infinity = infinity + 1 in infinity
06:47:21 <lambdabot>  Exception: <<loop>>
06:47:24 <dcoutts_> bah!
06:47:47 <quicksilver> Yoric[DT]: Yes. It "explains" the meaning of infinite loops, as well as exceptions.
06:47:49 <Yoric[DT]> So what happens exactly when your non-exhaustive match fails ?
06:47:53 <Toxaris> "Parsec is designed as a real world library from scratch" <-- doesn't avoid success at all costs
06:48:10 <roconnor> > undefined
06:48:11 <lambdabot>  Undefined
06:48:15 <Yoric[DT]> (or any other exception not necessarily handled by IO)
06:48:25 <Yoric[DT]> (or performed in unsafe mode)
06:48:28 <Yoric[DT]> ?
06:48:34 <quicksilver> Yoric[DT]: Your program has a bug in.
06:48:37 <Yoric[DT]> I know.
06:48:45 <quicksilver> so you get an error message, which hopefully helps you find the bug.
06:48:52 <roconnor> Yoric[DT]: I think it calls error
06:48:54 <quicksilver> but it is a bug, not an exception.
06:48:55 <dcoutts_> Yoric[DT]: you get an exception which semantically is the value _|_
06:48:57 <roconnor> @type error
06:48:57 <lambdabot> forall a. [Char] -> a
06:49:02 <Yoric[DT]> Well, in my mind, it is an exception.
06:49:10 <quicksilver> fair enough. There is a pedantry here.
06:49:12 <Yoric[DT]> It happens at run-time, doesn't it ?
06:49:21 <dcoutts_> Yoric[DT]: yes, head [] = _|_
06:49:24 <quicksilver> The pedantry says: exceptions are those things which can happen during the run of a bug-free program.
06:49:25 <Yoric[DT]> Thanks.
06:49:30 <quicksilver> Errors are always caused by bugs.
06:49:34 <Yoric[DT]> Ok.
06:49:38 <quicksilver> I agree that's just overloading words.
06:49:46 <quicksilver> but it's a convenient distinction at some level.
06:49:49 <Yoric[DT]> Thanks for the precision.
06:50:04 <Yoric[DT]> I admit that I tend to think of things as exceptional cases vs. failures.
06:50:15 <quicksilver> So 'file not found' is an exception. It's not your fault that the user tried to read a non-existent file.
06:50:20 <Yoric[DT]> Agreed.
06:50:24 <quicksilver> but inexhaustive pattern is definitely an error.
06:50:28 * tac- tries to think of a situation where one would want to throw an exception without indicating a bug in the program
06:50:33 <quicksilver> you shouldn't have written it into your program.
06:50:43 <tac-> s/exception/uncaught exception
06:50:47 <Yoric[DT]> Just the kind of thing I explain my students.
06:51:17 <quicksilver> ndm has written a rather nifty program called "catch" which can detect a large number of inexhaustive pattern errors.
06:51:21 <quicksilver> That's pretty cool.
06:51:29 <Toxaris> > let lefts xs = [x | Left x <- xs] in lefts [Left 1, Right 2, Left 3] -- quicksilver: exception or bug or sensible program?
06:51:30 <lambdabot>  [1,3]
06:51:41 <Yoric[DT]> tac-: for emergency exit in case of unmanageable real-world error ?
06:51:52 <quicksilver> Toxaris: that looks like a working program to me? :)
06:52:18 * Yoric[DT] agrees that this is quite sensible.
06:52:22 <tac-> Yoric[DT]: I was thinking of something more satirical. Where you could get away with purposefully crashing the program on your user without calling it a bug :-)
06:52:32 <Yoric[DT]> tac- :)
06:52:53 <Botje> Toxaris: it's actually how eg catMaybes is implemented too.
06:53:06 <Botje> Toxaris: if the bind fails, it's ignored
06:53:09 <Botje> @src catMaybes
06:53:09 <lambdabot> catMaybes ls = [x | Just x <- ls]
06:53:12 <quicksilver> it's not ignored.
06:53:17 <quicksilver> it calls "fail" in the monad
06:53:22 <quicksilver> @src fail []
06:53:22 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:53:24 <quicksilver> @src fail [a]
06:53:24 <lambdabot> Source not found. That's something I cannot allow to happen.
06:53:28 <mauke> @src [] fail
06:53:28 <lambdabot> fail _      = []
06:53:32 <quicksilver> thanks mauke :)
06:53:43 <Botje> can we add some smartness to \bot?
06:53:55 <Botje> if two args are given, allow both orders
06:54:04 <quicksilver> yes, would be easy to do
06:54:07 <Toxaris> Botje: it's not ignored, it's purposefully not included in the result list.
06:54:10 <quicksilver> just a trival modification to @src.
06:54:18 <Botje> since i'm not the only one who keeps messing up the order :)
06:55:12 <Toxaris> what i mean is: wether the use of a programming construct is a bug or not depends on what the programmer wants to program, not on the used programming construct
06:55:53 <quicksilver> Toxaris: yes, but your example doesn't "error: inexhaustive patterns for f"
06:56:05 <quicksilver> Toxaris: it is that error: which I was claiming was a program bug.
06:56:11 <quicksilver> not all possible uses of pattern matching.
06:56:53 <Botje> quicksilver: who would i @tell for that?
06:57:26 <quicksilver> I don't think lambdabot has a regular maintainer these days.
06:57:35 <quicksilver> I think preferred woudl be to get the darcs and send a patch.
06:57:42 <quicksilver> I think Cale looks after the one we have here.
06:58:06 <Cale> I'm happy to apply patches
06:59:04 <mauke> @src foldr
06:59:04 <lambdabot> foldr k z xs = go xs
06:59:04 <lambdabot>     where go []     = z
06:59:04 <lambdabot>           go (y:ys) = y `k` go ys
06:59:10 <mauke> Cale: can you fix that?
07:00:03 <Cale> I don't know.
07:00:10 <Cale> Possibly :)
07:00:35 <quicksilver> I think the @src stuff is one big text file, isn't it?
07:00:38 <Toxaris> quicksilver: I would say, if the specification asks for an "error: inexhaustive patterns for f" to be printed, it's fine to print it. otherwise, it's a bug. the bugginess of something can't be analysed without a specification.
07:01:10 <Cale> cgibbard@haskell:~/darcs/lambdabot$ file State/source
07:01:10 <Cale> State/source: gzip compressed data, was "X~=@l9q5", from Unix, last modified: Mon Jan  8 05:06:31 2007
07:01:29 <gbacon> Cale: a few dependencies are missing from lambdabot.cabal
07:01:37 <Cale> I wonder if it's safe to just gunzip it, edit, and then gzip again.
07:01:55 <Cale> gbacon: I know, but I'm not completely sure what the complete list is.
07:02:14 <quicksilver> Toxaris: I think this is a silly argument. "error: inexhasutive patterns for f" is not printed by the program concerned.
07:02:31 <gbacon> Cale: for sure parallel and numbers need to be added
07:02:32 <Cale> at the very least, I think numbers is missing.
07:02:34 <Cale> ah
07:02:37 <quicksilver> Toxaris: it is printed by the GHC runtime to indicate that it has terminated the program due to a pattern match failure.
07:03:56 <gbacon> I sent dons a patch yesterday for hs-plugins (it doesn't like Cabal-1.3.3)
07:07:14 <Cale> any other bugs in the @src dictionary? I got sequence, foldr and foldl
07:07:40 <quicksilver> Cale: the feature request was laetting args-in-either-order for methods.
07:07:51 <Cale> what?
07:07:56 <Toxaris> @src [] <*>
07:07:56 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:08:06 <Cale> ah, hehe
07:08:16 <Saizan> quicksilver: do you think unwords . reverse . words will suffice?
07:09:03 <Toxaris> @src [] (<*>)
07:09:03 <lambdabot> (<|>) = (++)
07:09:27 <Toxaris> Cale: this is the wrong function :(
07:09:41 <Cale> yes
07:09:46 <Cale> (just fixed it)
07:10:59 <Cale> @src foldr
07:11:06 <lambdabot> foldr f z []     = z
07:11:06 <Cale> ...
07:11:11 <Cale> err...
07:11:12 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:11:19 <Cale> oh, it's just really slow :)
07:11:23 <Cale> @src foldl
07:11:30 <lambdabot> foldl f z []     = z
07:11:36 <lambdabot> foldl f z (x:xs) = foldl (f z x) xs
07:11:42 <Cale> @src sequence
07:11:48 <lambdabot> sequence []     = return []
07:11:54 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:12:06 <lambdabot> Plugin `source' failed with: thread killed
07:12:09 <Cale> hmm
07:12:25 <mauke> @src sepples
07:12:25 <lambdabot> Source not found. stty: unknown mode: doofus
07:12:37 <Cale> @src sequence
07:12:37 <lambdabot> sequence []     = return []
07:12:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:12:37 <lambdabot> --OR
07:12:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:12:41 <Cale> ah, okay
07:12:48 <Cale> It was just being screwy.
07:13:01 <Cale> @src [] (<*>)
07:13:01 <lambdabot> (<*>) = ap
07:13:04 <Cale> @src [] (<|>)
07:13:04 <lambdabot> (<|>) = (++)
07:13:06 <mauke> I like the one liner better
07:13:14 <doserj> @src seq
07:13:14 <lambdabot> Source not found. My pet ferret can type better than you!
07:13:20 <Cale> It's nicer, but it requires liftM2
07:13:30 <Cale> Which is in Control.Monad, and not the Prelude
07:13:56 <mauke> @index sequence
07:13:56 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:14:05 <mauke> why is sequence in the Prelude anyway
07:14:27 <mauke> I'd rather have sort
07:15:31 <Cale> sequence is rather important, as far as monad functions go
07:16:13 <Cale> I always feel that there's not quite enough in the Prelude, but there's the practical problem being that if we move things into it, they become hard to modify.
07:16:32 <Cale> I always end up importing Control.Monad, even for silly 3-line scripts.
07:16:59 <Cale> after that, probably Data.List is most common
07:17:00 <explisixjelly> hmm... I'd like to sequence operations in a monad, but only on certain conditions...
07:17:16 <Cale> explisixjelly: What do you mean by that?
07:17:19 <ToRA> Cale: there was some perl script cgi floating about that listed the most common imports on hackage / ghc
07:17:23 <explisixjelly> try foo, bar, baz, but only until one of foo, bar or baz returns a result which satisfies me
07:17:32 <Cale> ah, okay
07:17:37 <ToRA> Cale: iirc Data.List, Control.Monad, Data.Map where pretty much top
07:17:58 <ToRA> Cale: worryingly Unsafe was quite high too ( ~ 14)
07:18:01 <Cale> ToRA: Yeah, doesn
07:18:03 <shepheb> Control.Monad was top by a wide margin, I think.
07:18:06 <Cale> ToRA: Yeah, doesn't surprise me.
07:18:26 <explisixjelly> so, any other suggestions than wrapping 2 or 2 if/then/else inside each other?
07:18:31 <Toxaris> explisixjelly: some monads will support this directly with mplus
07:18:37 <Cale> explisixjelly: Well, you might try a foldM
07:18:39 <resiak> Cale: throw them all in Prelude.MOAR or something!
07:18:55 <explisixjelly> Cale, no... different conditions, different results :(
07:19:17 <ToRA> case (a,b) of (True,True) -> ... (True, False) ->   ?
07:19:28 <Cale> explisixjelly: Oh. Do you have something like a list of pairs of actions and conditions?
07:19:34 <ToRA> if you really do have 4 completely different cases / results
07:19:38 <dcoutts_> ToRA: but I think the script included intra-package imports so it's not really representative I think
07:19:40 <explisixjelly> Cale, yap
07:20:01 <dcoutts_> ToRA: it meant that OpenGL came really high just because it has 100 modules that all import on of the OpenGL modules
07:20:06 <dcoutts_> on/one
07:20:29 <Cale> explisixjelly: do you just want the first result to satisfy its condition?
07:20:41 <explisixjelly> Cale, yes
07:20:46 <ToRA> dcoutts_ ah ok, that would swing it somewhat, though if Data.Map is still widely leading it says something
07:21:00 <ToRA> *Control.Monad
07:21:07 <dcoutts_> ToRA: I'm sure those would still be widely used
07:21:52 <Cale> condM [] = return Nothing
07:22:10 <Cale> condM ((p,x):xs) = do v <- x; if p v then return (Just v) else condM xs
07:23:34 <Cale> That seems like the control structure you want :)
07:24:00 <explisixjelly> Cale, brilliant. thanks a lot!
07:24:18 <Smurfen_> http://hpaste.org/5982     LiftBind is a constructor in a monad datatype. r in this case is a function (a -> m b), where a is of the same type as (IO a), represented by io argument. In one of the cases, the io actions is not to be performed, so we don't know what to give as an argument to r :/
07:24:24 <Smurfen_> Any suggestions?
07:24:46 <explisixjelly> next question 8)
07:24:59 <explisixjelly> what do you use when generating unique IDs?
07:25:07 <explisixjelly> s/when/for/
07:25:28 <explisixjelly> they only need to be unique within the data type.
07:25:48 <Cale> explisixjelly: Usually some infinite list of strings, or integers? A supply monad can be useful for making sure they're distributed cleanly and not reused.
07:25:48 <explisixjelly> it's easy within a state monad...
07:26:08 <explisixjelly> without a monad an idea would be to keep the list of generated values and using the maximum ID within this list plus 1
07:26:25 <Cale> Smurfen_: You can't get the result of an IO action without running it.
07:26:35 <explisixjelly> Cale, "supply monad". that sounds good.
07:26:49 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadSupply
07:26:50 <lambdabot> Title: New monads/MonadSupply - HaskellWiki
07:27:01 <Smurfen_> Cale: Yeah, I know. That's our problem.
07:27:02 <Toxaris> explisixjelly: but this would mean changing the "the list of generated values" in the process, which means you need a state monad again to make it nice
07:27:14 <Smurfen_> We don't want to run it, but we need to return some kind of argument
07:27:15 <explisixjelly> Toxaris, yes, I would pass it along
07:27:23 <Smurfen_> Of the same type as a in (IO a)
07:27:36 <Cale> Smurfen_: you could use undefined
07:27:42 <Toxaris> explisixjelly: for some applications, you may use some aproach similiar to splitting of random number generators
07:27:49 <Cale> Smurfen_: of course, your program will crash if the value is ever needed.
07:28:07 <Toxaris> explisixjelly: e.g., in a binary tree, use the path from the root to the node as unique id, encoded as a bitstream
07:28:39 <explisixjelly> Toxaris, nice... isn't something like that used in huffman encoding?
07:28:47 <Smurfen_> Cale: I don't think it's ever used, so that should work
07:29:47 <Cale> Smurfen_: by the way, your file appears to contain tabs. I recommend strongly against having any tabs in your source files.
07:30:13 <Cale> Smurfen_: Most editors have some switch to make the tab key emit a bunch of spaces, and I recommend that :)
07:30:17 <Toxaris> explisixjelly: yes i think so if i remember correctly what huffman encoding is. you bild a tree, and then lookup the code words for your alphabet in this tree
07:30:39 <explisixjelly> exactly
07:30:49 <Cale> Smurfen_: In vim, the expandtab and smarttab options are what you'd want.
07:31:13 <Toxaris> explisixjelly: bad news: most applications of unique ids include either using them as indices into an array, or to perform equality checks in cyclic data structures. for these applications, my idea is not applicable, of course :(
07:31:19 <Smurfen_> Cale: Understood :)
07:31:32 <Smurfen_> Hmm, weird. Used undefined, but it still performs the io operations :/
07:31:47 <Cale> Smurfen_: do you still have the line  res <- io  ?
07:32:22 <explisixjelly> Toxaris, but it often is, when you just have a binary tree
07:32:50 <Smurfen_> Cale: Nope, removed it
07:32:59 <Toxaris> explisixjelly: it is applicable to all non-cyclic data structures, not just binary trees. they are all trees of some kind.
07:33:12 <explisixjelly> storing multiple states in a state value: I use a State Monad with a record data structure as state type. right? or is there something more elegant?
07:34:01 <Cale> explisixjelly: That's the sane thing to do. If the computations you're performing in that monad are more than a few lines, I'd also recommend wrapping get and put
07:34:14 <explisixjelly> Toxaris, by using the maximum width at any node as number base? or what would you use as bitstring for, let's say, a trinary tree?
07:34:34 <Smurfen_> Maybe there's something screwy with the index. But the undefined thing works
07:34:46 <explisixjelly> Cale, yes, that's what I wanted to do. I'll also have some slightly more complex functions for modifying the state records
07:36:00 <Toxaris> explisixjelly: you asked for unique numbers, not space-efficient unique numbers :) you can e.g. just use [Integer] as type of the ids
07:36:30 <explisixjelly> Toxaris, yup, I was just curious 8)
07:37:05 <Saizan> [0 ..] works quite well as a source of unique numbers :)
07:38:11 <Toxaris> explisixjelly: another option is to treat the multi-ary tree as binary (left means first child, right means next sibling)
07:39:52 <Cale> explisixjelly: You can also hide the implementation better, by wrapping the monad in a newtype, and deriving Functor and Monad
07:41:21 <explisixjelly> Cale, ah, ok.
07:41:26 <explisixjelly> Cale, by the way, what's "Functor"?
07:41:40 <Cale> It's the class which fmap resides in.
07:41:43 <Smurfen_> I thought it was weird to bypass it with undefined. I finally found where it's used and backfires D:
07:41:55 <Toxaris> > let split (x:y:xs) = (x :) *** (y :) $ split xs in split [0..]
07:41:55 <lambdabot>  ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
07:42:21 <explisixjelly> Cale, fmap. there's a function that I haven't used yet.
07:42:26 <Cale> explisixjelly: fmap is a generalisation of map
07:42:33 <Cale> It's the same as liftM, if you've used that
07:42:33 <Toxaris> explisixjelly: you could use this function to split a infinite list of ids into two infinite list of ids. it may be lazy enough or not, what do i know...
07:42:41 <explisixjelly> ah, yes, I've used liftM
07:42:41 <RayNbow> anyone here seen that Google Tech talk about Parametric Polymorphism?
07:42:46 <explisixjelly> and mapM, if that's somehow related
07:42:54 <Cale> mapM is something different
07:42:57 <ahunter> I'm not sure if this is exactly the right channel, but I've got a question about GHC internals--can anyone point me to vaguely where in the source STM operations actually get defined?
07:43:14 <explisixjelly> ah, ok...
07:43:18 <explisixjelly> Toxaris, heh, nice
07:43:42 <ahunter> I've found rts/STM.{c, etc} but I'd especially appreciate anything that says vaguely how/where calls to atomically et al get translated to those C functions
07:43:45 <avtobiff> yo
07:43:50 <avtobiff> :)
07:44:06 <Cale> ahunter: Well, there's http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Conc.html#atomically  -- here, you'll see the operations defined in terms of primitives.
07:44:07 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/344gsg
07:44:28 <RayNbow> http://video.google.com/videoplay?docid=-4851250372422374791&hl=en
07:44:29 <lambdabot> Title: Advanced Topics in Programming Languages Series: Parametric Polymorphism, http://tinyurl.com/38b3ht
07:44:36 <Zao> Cale: Are you the Cale that made Nymphaea?
07:44:42 <Cale> Zao: yes
07:45:01 <quicksilver> Cale: are there any nice screenshots of it? I couldn't find any yesterday.
07:45:08 <Cale> Zao: I wrote it a year and a half ago, and gwern recently released it.
07:45:08 <Zao> I'm a bit confused about the glib, gtk and cairo dependencies it wants. I can't seem to find them on Hackage.
07:45:16 <Cale> (I wrote it with xerox)
07:45:26 <ahunter> cale: thanks, that's pretty much what I was looking for.  Any idea how exactly atomically# turns into calls in rts/STM.c?
07:45:31 <Cale> Zao: That would be because they're part of gtk2hs
07:45:42 <Cale> Zao: which hasn't been cabalised yet.
07:45:50 <quicksilver> ahunter: have you read the paper? that gives a pretty good idea.
07:45:59 <Zao> Ah. Apparently my system here lacks it. Thanks.
07:46:03 <quicksilver> ahunter: (it doesn't taken it right down to the level of C source though)
07:47:03 <ahunter> quicksilver: I have, was hoping to back that up with some sourcediving (I'm responsible for explaining the functionality to my PLs seminar today :))
07:47:07 <ahunter> thanks all
07:47:21 <hpaste>  Spockz pasted "Arity" at http://hpaste.org/5986
07:47:34 <quicksilver> ahunter: sorry not ot be more help. JaffaCake is the only one I know arond here who's been inside the source of STM.
07:48:54 <Cale> ahunter: My take on it is that the implementation is probably somewhat immature, but in the end, doesn't really matter so much as the semantics of the primitives.
07:49:24 <JaffaCake> ahunter: the implementation of atomically# is in rts/PrimOps.cmm
07:49:38 <ahunter> cale: agreed.  I'm mostly looking because we want to discuss some possible ways to implement STM and I volunteered to explain GHCs
07:49:39 <Cale> ah, good, I won't have to grep :)
07:49:40 <JaffaCake> look for atomicallyzh_fast
07:49:42 <hpaste>  dino- annotated "random shuffle" with "shorter shuffle" at http://hpaste.org/5969#a2
07:49:48 <ahunter> jaffacake: ah, thank you very much!
07:49:50 <Cale> ahunter: ah, okay
07:53:33 <byorgey> any Agda gurus that can help me with http://hpaste.org/5987 ?  I am at a loss as to why this does not type check.
07:53:55 <Toxaris> dino-: are you aware of http://okmij.org/ftp/Haskell/perfect-shuffle.txt?
07:54:30 <dino-> Toxaris: I did read that at some point.
07:55:04 <dino-> I think I was left wondering if using the locally available random number gen to randomly pick positions in the remaining list was shuffly enough for most purposes.
07:55:14 <explisixjelly> parse error (possibly incorrect indentation)
07:55:15 <explisixjelly> sheesh.
07:55:35 <dino-> But I do appreciate the relentless pursuit of shuffle perfection.
07:58:13 <swiert> byorgey: aren't you confusing ^ and ,?
07:58:27 <ToRA> dino-: for variation, i have a pure (io free) array based shuffle kicking around somewhere.  If you're interested i can dig it out
07:58:29 <byorgey> swiert: um, quite possibly!
07:58:31 <swiert> byorgey: try writing "x , (? , px  )"
07:58:42 <byorgey> swiert: what's the ? for ?
07:58:45 <swiert> byorgey: and reloading your Agda buffer.
07:58:55 <swiert> byorgey: do you use the emacs mode?
07:58:59 <byorgey> swiert: yes
07:59:09 <dino-> ToRA: Yes, show me that code!
07:59:17 <swiert> byorgey: the "?" means - I'll fill this in later.
07:59:20 <dino-> Lay it on me, brother.
07:59:25 <byorgey> swiert: ah, cool.
07:59:30 <swiert> byorgey: but type check what I've got so far.
07:59:33 <byorgey> swiert: ah, that works!
07:59:42 <byorgey> now to stare at it until I understand why.
07:59:44 <swiert> byorgey: it's quite useful for incremental program development.
08:00:05 <byorgey> indeed!  I wish I knew about that earlier.
08:00:05 <dino-> Annotate the hpaste-that-never-stops on shuffling.
08:00:06 <hpaste>  ToRA annotated "random shuffle" with "random shuffle with Arrays & ST Monad" at http://hpaste.org/5969#a3
08:00:07 <byorgey> swiert: thanks!
08:00:12 <swiert> byorgey: np.
08:00:15 <byorgey> swiert++
08:00:33 <ToRA> i really dislike swap in that though, it feels a bit clunky
08:01:06 <dino-> Thank you
08:01:29 <byorgey> swiert: oh, so this is what the "goals" stuff is about?
08:02:01 <byorgey> I wondered what all that stuff about "goals" and "constraints" was in the Agda2 emacs menu
08:02:16 <explisixjelly> if then else in do notation is something which I haven't always figured out yet %)
08:02:21 <swiert> byorgey: constraints are implicit arguments that agda can't fill in.
08:02:38 <byorgey> swiert: oh, ok
08:02:47 <swiert> byorgey: goals (I think) are the result of question marks -  the bits of your program that you still need to complete.
08:03:07 <quicksilver> explisixjelly: extra space before hte "else" and maybe "then"
08:03:14 <quicksilver> explisixjelly: they mustn't line up with the if
08:03:21 <quicksilver> otherwsie they would begin new statements.
08:03:22 <swiert> byorgey: the ? is really useful - C-c C-t gives you the type of the thing you need to define; C-c C-e gives you all the stuff in scope.
08:03:38 <byorgey> swiert: cool!
08:04:02 <explisixjelly> quicksilver, yes, I figured that out... unfortunately, emacs wants to align it :(
08:04:20 <swiert> byorgey: the right hand side should read "x , (px , qx)" btw.
08:04:28 <Spockz> RayNbow: hello
08:04:32 <byorgey> swiert: yep, that's what I've got now
08:04:33 <quicksilver> explisixjelly: emacs doesn't always know best :-/
08:04:45 <explisixjelly> quicksilver, yup...
08:05:13 <dino-> Please let's not have the Great Tab Debacle again like yesterday.
08:05:23 <byorgey> swiert: but why does the type of qx depend on the type of px?
08:05:34 <byorgey> swiert: does that question even make sense?
08:05:50 <swiert> byorgey: how do you mean?
08:06:13 <byorgey> swiert: well, the comma operator is for creating dependently typed pairs, right?
08:06:25 <explisixjelly> how can I see what a type class declares within ghci?
08:06:33 <quicksilver> explisixjelly: :info Num
08:06:36 <quicksilver> (for example)
08:06:40 <dino-> This is making me want to look up that Random monad, ISTR from Cale maybe. not sure
08:06:45 <explisixjelly> quicksilver, perfect. thanks
08:06:48 <swiert> byorgey: well it's the constructor of (dependently typed) pairs.
08:07:10 <swiert> byorgey: but in this case you want something in ^ - which is a special case of *non-dep typed* pairs.
08:07:37 <byorgey> swiert: oh, wait, now I get it.  it just clicked finally. =)
08:08:49 <byorgey> yes, I see my confusion now.  , is used to construct things of type A * B and of type A ^ B, since the latter is just a special case of the former
08:09:03 <swiert> byorgey: yes - that's exactly it.
08:09:09 <byorgey> ok, good =)
08:09:29 <byorgey> swiert: thanks again =)
08:10:12 <dino-> Ah: http://www.haskell.org/haskellwiki/New_monads/MonadRandom  contributed to by a lot of people
08:10:13 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
08:10:17 <swiert> byorgey: glad to help.
08:10:32 <smg> @src (+)
08:10:32 <lambdabot> Source not found. Sorry.
08:10:36 <smg> @src +
08:10:36 <lambdabot> Source not found. There are some things that I just don't know.
08:10:41 <smg> @type (+)
08:10:42 <lambdabot> forall a. (Num a) => a -> a -> a
08:11:07 <glen_quagmire> how can I use PrettyPrint to print nested list and stuff with nice indentation?
08:11:14 <glen_quagmire> should I roll out my own function for that?
08:18:31 <mofmog> so how do i make heterogeneous lists in haskell? or something very close?
08:18:46 <explisixjelly> mofmog, I believe there is a package called HList?
08:18:53 <mofmog> alright thanks ill look into it
08:18:55 <smg> src (@)
08:19:08 <quicksilver> mofmog: I doubt HList is the answer.
08:19:18 <quicksilver> HList is rarely the answer to practical problems.
08:19:29 <quicksilver> mofmog: if you step back, what are you trying to acheive?
08:19:39 <mofmog> what i'm trying to do is have lists within lists
08:19:46 <mofmog> while having elements that are not lists
08:19:58 <quicksilver> then you probably just want a nice ADT which models that.
08:19:59 <mofmog> so [1,2,3,[3,4,5],2,3,4] nd so on
08:20:21 <quicksilver> data MightBeList a = a | [MightBeList a]
08:20:35 <mofmog> ah
08:20:37 <quicksilver> then [MightBeList Int] is a list of these things
08:20:42 <mofmog> so that is a list
08:20:46 <mofmog> of MightBeList
08:20:50 <mofmog> and it just so happens it mgiht be a list
08:20:50 <quicksilver> yes
08:20:51 <mofmog> haha
08:20:53 <mofmog> yes
08:20:53 * blt wishes for MightBeGiants ADT
08:20:54 <quicksilver> ;)
08:20:55 <mofmog> awesome
08:21:05 <quicksilver> that was a recursive type
08:21:06 <mofmog> dang i need a good book
08:21:12 <quicksilver> so it might be a list of lists of lists of lists too
08:21:16 <quicksilver> if you don't need that
08:21:17 <Saizan> but you need contructors :)
08:21:19 <quicksilver> (just one level)
08:21:26 <quicksilver> bah, thanks Saizn
08:21:33 <mofmog> constructors and selectors
08:21:40 <quicksilver> data MightBeList a = OnlyOne a | IsAList [MightBeList a]
08:21:45 <quicksilver> ^^ multilevel version
08:21:50 <quicksilver> data MightBeList a = OnlyOne a | IsAList [a]
08:21:56 <quicksilver> ^^ singlye level version
08:22:06 <quicksilver> Saizan: I always forget constructors when doing toy examples.
08:22:17 <mofmog> so how does typecheckign work?
08:22:31 <quicksilver> type checking uses the constructores.
08:22:35 <mofmog> ah
08:22:37 <quicksilver> that's why they were so important :)
08:26:12 <vincenz> data Tree a = Leaf a | Tree [a]
08:26:17 <vincenz> data Tree a = Leaf a | Tree [Tree a]
08:28:18 <explisixjelly> pretty printing of arbitrary datatypes, any idea?
08:28:35 <explisixjelly> besides reimplementing show for every datatype...
08:28:53 <explisixjelly> it's just for debugging purposes.
08:29:31 <quicksilver> explisixjelly: for debugging purposes, I normally jsut derive Show.
08:29:40 <quicksilver> explisixjelly: thats the simplest.
08:29:45 <explisixjelly> hmm, okay, I'll build something.
08:29:53 <explisixjelly> I could do stuff with graphviz.
08:30:01 <explisixjelly> is there some special package for graphviz?
08:30:04 <quicksilver> vincenz: data Tree f a = Leaf a | Tree [f a]
08:30:10 <explisixjelly> otherwise I'll just output graphviz source.
08:30:58 <vincenz> quicksilver: and then fix it?
08:31:03 <vincenz> can you partially apply types?
08:31:14 <vincenz> data Fix f a = f (Fix f) a
08:32:26 <quicksilver> I believe so, yes
08:32:33 <quicksilver> you can partially apply types, certainly.
08:37:45 <byorgey> explisixjelly: there's not a special graphviz package that I know of, but it's pretty easy to output graphviz source.
08:38:14 <explisixjelly> yup...
08:39:16 <byorgey> explisixjelly: oh, wait, actually there is: http://www.haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Graphviz.html
08:39:17 <lambdabot> http://tinyurl.com/3y3cmy
08:39:31 <byorgey> but constructing a Graph just to output in graphviz format still might be more trouble than it's worth
08:39:56 <explisixjelly> yeah, I think you're right...
08:40:04 <explisixjelly> a simple type class should suffice
08:40:58 <byorgey> yup
08:52:54 <smg> mh
08:53:01 <smg> someone can make a good example for using "~" ?
08:54:14 <opqdonut> using fix on a [a]->[a] function
08:55:22 <blargeyfarg> @src fix
08:55:22 <lambdabot> fix f = let x = f x in x
08:59:44 <dons> ?users
08:59:44 <lambdabot> Maximum users seen in #haskell: 463, currently: 430 (92.9%), active: 14 (3.3%)
09:06:52 <ahunter> Out of curiousity, from the mention of fix--does anyone know if it's possible to make a well-typed (w/o infinite types) fixed-point combinator?
09:07:15 <ahunter> I know that it's at least hard--standard stuff like the Y combinator or putting together equivalent SKI combinators results very quickly in infinite types
09:08:39 <kuribas> Why is it not possible to give explicit annotations for an infinite type?
09:08:42 <Saizan> ahunter: you need a recursive wrapper
09:09:52 <ahunter> saizan: so you can't make a nonrecursive fixed point combinator a la Y with finite types?
09:10:00 <dcoutts_> kuribas: the particular type system we're using does not allow infinite types at all
09:10:03 <quicksilver> kuribas: because that's how the type system work.
09:10:18 <quicksilver> kuribas: infinite types are only permitted when encoded as recursive types
09:10:21 <smg> @src it
09:10:21 <lambdabot> Source not found. Where did you learn to type?
09:10:25 <quicksilver> (which makes then finite in a sense)
09:10:25 <Saizan> ahunter: i mean you need a recursive type if you want to write it non-recursivelu
09:10:26 <smg> @type it
09:10:27 <lambdabot> Not in scope: `it'
09:10:45 <ahunter> saizan: can you elaborate/link to something?  I'm not quite sure what you mean
09:10:55 <kuribas> Would it be problematic to add them?
09:11:06 <quicksilver> ahunter: the short answer to your question is no, it is not possible.
09:11:21 <Saizan> ahunter: http://hpaste.org/5924
09:11:30 <quicksilver> ahunter: the ability to get recursion without adding a primitive is a peculiarity of the untyped lambda calculus.
09:11:52 <quicksilver> ahunter: as soon as you add simple typing, recursion needs a primitive.
09:12:03 <quicksilver> (either a language construct, or reified via 'fix')
09:12:20 <ahunter> saizan: got it thanks
09:12:34 <quicksilver> kuribas: if you add inference for infinite types, you have a calculus in which every term type-checks.
09:12:41 <quicksilver> kuribas: then you get no type errors.
09:12:55 <pejo> ahunter, http://lists.seas.upenn.edu/pipermail/types-list/2004/000267.html might be of interest to you.
09:12:56 <lambdabot> Title: [TYPES] recursive data types with negative occurrence (besides higher-order abst ...
09:12:58 <quicksilver> kuribas: which is cute, but doesn't help you write correct programs.
09:13:02 <ahunter> quicksilver: makes sense--I really need to brush up on my higher order and/or typed lambda calculi
09:13:09 <quicksilver> kuribas: ocaml has an option for this: -rectypes IIRC
09:13:15 <ahunter> pejo: cool, I'll take a look at this
09:13:33 <kuribas> quicksilver: Yes, I see.  But if you allow them only with _explicit_ annotations?
09:13:57 <Saizan> quicksilver: that paste doesn't qualifies as non-primitive?
09:13:58 <pejo> ahunter, also Oleg has something on his homepage of fixpoint combinators in ML iirc, if that is the kind of stuff you're looking for.
09:14:41 <kuribas> quicksilver: Then you can never accidentally create a recursive type.
09:16:30 <quicksilver> kuribas: I think that will break type inference but I'm not sure.
09:17:01 <quicksilver> Saizan: no, that's not primitive.
09:17:25 <quicksilver> Saizan: you are demonstrating that value recursion follows from type recursion.
09:17:30 <dmwit> Wait, infinite types mean everything type-checks?
09:17:32 <quicksilver> Saizan: which is quite an interesting result.
09:17:46 <dmwit> How would, eg, 3 + "hey" type-check?
09:17:52 <mauke> :t 3 + "hey"
09:17:52 <lambdabot>     No instance for (Num [Char])
09:17:52 <lambdabot>       arising from the literal `3' at <interactive>:1:0
09:17:52 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
09:17:59 <quicksilver> dmwit: it means "every term of the lambda calculus type checks")
09:18:04 <mauke> instance Num [a]
09:18:05 <liyang`> :t (+)
09:18:05 <dmwit> oh
09:18:05 <lambdabot> forall a. (Num a) => a -> a -> a
09:18:17 <mauke> type Lambda = a@(a -> a)
09:18:19 <quicksilver> dmwit: in the presence of other features like ground types and typeclasses, no.
09:18:24 <quicksilver> but a lot more typechecks than you want.
09:18:29 <dmwit> Yeah, okay.
09:18:54 <quicksilver> there is a nice blog example where someone shows that 6 obvious programming errors all typecheck under -rectypes
09:18:58 <mauke> :t fix . join
09:18:58 <lambdabot> forall a. (a -> a -> a) -> a
09:19:06 <quicksilver> actually might not be blog, it might be pre-blogosphere
09:19:12 <quicksilver> I looked for it the other day and couldn't find it.
09:19:27 <ahunter> :t join
09:19:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:20:43 <mauke> quicksilver: http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
09:20:45 <lambdabot> Title: Gmane -- Mail To News And Back Again
09:20:50 <dmwit> ahunter: In the (-> r) monad, join f x = f x x.
09:21:21 <quicksilver> mauke: thank you. That's the one.
09:21:28 <smg> should i read http://haskell.org/onlinereport/index98.html also?
09:21:34 <quicksilver> pseudonym++
09:21:55 <smg> or is this just an "API reference" for haskell?
09:22:20 <quicksilver> smg: the online report is a bit dry. I wouldn't recommend it as a starting point.
09:22:39 <smg> quicksilver: hehe i read YAHT and "a gentle introduction"
09:22:45 <smg> i don't know what to read next :]
09:22:51 <smg> maybe i read a book about haskell
09:22:54 <quicksilver> wikibooks?
09:22:58 <smg> k
09:23:04 <pejo> smg, next is to write a lot of code!
09:23:05 <ahunter> smg: good start, I did well starting to read papers about cool features, and just starting to write some code
09:23:33 <ahunter> smg: if you need something random to write, I recommend project Euler--lots of nice little things you can do which help you to start to run into the points you don't know
09:24:03 <Toxaris> smg: hanging around in #haskell, when people post cool code, ask them what paper to read to understand it. after some time, start posting cool code yourself. people will still tell you what interesting papers to read to make it even cooler.
09:24:20 <ahunter> smg: plus, to the PE team's great disdain, there are sol'ns up on the wiki you can compare to once you've written yours, to see how you're doing it badly :)
09:24:46 <smg> Toxaris: okay thx
09:24:49 <smg> pejo: ok :)
09:25:03 <noteventime> smg: I liked the haskell road to math logic and proramming, at least this far
09:25:04 <smg> ahunter: ah project euler i know i coded all with python maybe i code now all with haskell
09:25:16 <smg> noteventime: can you point me to it?
09:25:24 <noteventime> It's not availbale for free
09:25:43 <smg> ah okay
09:25:44 <noteventime> Not legally anyway
09:25:58 <smg> maybe i buy it if i find it
09:26:16 <noteventime> smg: http://www.amazon.co.uk/Haskell-Logic-Maths-Programming-Computing/dp/0954300696
09:26:18 <lambdabot> http://tinyurl.com/yu986w
09:27:19 <smg> noteventime: thanks do you know the addison wesley book? craft of functional coding?
09:27:56 <noteventime> smg: Only superficially
09:28:05 <smg> i didn't like that
09:28:14 <smg> i used that to start but i was stuck
09:28:27 <smg> so i tried haskell.org - now i understand haskell much better :]
09:28:30 <noteventime> What was wrong with it?
09:28:46 <smg> i don't know teaching style wasn't good imho
09:28:53 <smg> but maybe it just wasn't for beginners
09:29:02 <piojo> speaking of that book, does anybody know whether "craft of functional programming" gets really deep into monads and their uses?
09:29:06 <noteventime> It sounded to practical for my taste
09:29:08 <smg> ah project euler is really cool i forgot about that, ah 5 new exercises
09:29:12 <pejo> smg, by Simon Thompson?
09:29:27 <smg> pejo: wait
09:29:49 <smg> yeah Simon Thompson, maybe i was just to stupid to understand it :)
09:30:39 <yrlnry> Is there a built-in function for generating pseudo-random numbers?  I don't need anything fancy.
09:30:59 <mauke> :t randomIO
09:30:59 <lambdabot> forall a. (Random a) => IO a
09:31:03 <yrlnry> Thanks!
09:31:14 <pejo> piojo, not really deep, but it does explain them. http://web.cecs.pdx.edu/~mpj/pubs/springschool.html might be useful to you.
09:31:14 <lambdabot> Title: Functional Programming with Overloading and Higher-Order Polymorphism
09:31:24 <yrlnry> "Not in scope: `randomIO'
09:31:27 <yrlnry> "
09:31:34 <quicksilver> piojo: I don't think any book gets really deep into monads.
09:31:39 <yrlnry> @help
09:31:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:31:43 <yrlnry> @list
09:31:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:31:59 <yrlnry> @where randomIO
09:31:59 <lambdabot> I know nothing about randomio.
09:32:12 <quicksilver> @index randomIO
09:32:12 <lambdabot> System.Random
09:32:35 <quicksilver> yrlnry: I recommend keeping http://www.haskell.org/ghc/docs/latest/html/libraries/ open at all times in a web browser
09:32:50 <quicksilver> yrlnry: you would have found random pretty fast there :)
09:32:54 <yrlnry> thanks.
09:33:16 <mauke> especially using find-as-you-type
09:36:49 <piojo> pejo: thanks. i'll skim/read that paper, though it might be below what i already know
09:37:37 <smg> btw people you know the language K?
09:37:37 <smarmy> anyone have a serious issue with find-as-you-type dropping their browser to its knees?
09:40:27 <Deewiant> I know /of/ K
09:41:10 * faxathisia knows J a lot better than K
09:41:42 <Deewiant> I also know of line noise
09:43:16 <pejo> piojo, if you're beyond the advanced fp spring schools I'm guessing there isn't much written material available that isn't articles.
09:45:29 <piojo> pejo: half way through, the article you linked gets to things i don't know yet. i'm more interested in techniques and style, at the moment
09:46:12 <piojo> i know what monads can do, mostly, and in some cases, i know how it's useful. but i don't know how/why i would apply them in my own programs. i don't know whether i should write everything in the Maybe monad, or write my own
09:47:45 * monochrom hugs his monads
09:48:42 <faxathisia> Did you ever have nightmares about being trapped inside a Monad?
09:49:09 <mofmog> so im watching a taste of haskell
09:49:13 <quicksilver> No, I had joyous dreams of it.
09:49:18 <mofmog> and it seems odd that the camera never looks at the screen
09:49:23 <quicksilver> I always always sad when I woke up all non-monadic.
09:49:54 <Saizan> i keep an escaping continuation under my pillow.
09:50:47 <monochrom> perhaps camera avoids screen to avoid recursion.
09:51:42 <dolio> mofmog: There are slides available somewhere.
09:51:47 <dolio> Or, there used to be.
09:55:49 <dolio> http://conferences.oreillynet.com/presentations/os2007/os_peytonjones.pdf
09:55:50 <lambdabot> http://tinyurl.com/ysvquz
10:00:34 <sclv_> I had a nightmare about a function that couldn't be typechecked.
10:00:42 <hallongrottan> lol
10:01:22 <faxathisia> sclv, such functions do exist!
10:03:12 <Deewiant> > let a = [a] in a
10:03:13 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
10:03:13 <lambdabot>       Expected...
10:03:43 <monochrom> > fix return
10:03:44 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a
10:03:44 <lambdabot>       Expected...
10:04:08 <ddarius> @pl a = [a]
10:04:08 <lambdabot> a = fix return
10:05:16 <ddarius> @pl (\f -> f f) (\f -> f f)
10:05:31 <lambdabot> ap id id (ap id id)
10:05:35 <lambdabot> Plugin `pl' failed with: thread killed
10:05:46 <ddarius> ?
10:06:09 <Saizan> @pl (\f -> f f) (\f -> f f)
10:06:17 <ddarius> ap id id $ ap id id is correct
10:06:37 <Cale> Does every term in the untyped lambda calculus have a corresponding term in a calculus with recursive types? I believe so.
10:06:37 <lambdabot> ap id id (ap id id)
10:07:15 <lambdabot> Plugin `pl' failed with: thread killed
10:10:20 <shepheb> ddarius: you appear to have found a way to kill LB.
10:10:54 <Cale> It's just code.haskell.org being randomly slow, I think.
10:10:59 <Cale> @src sequence
10:11:06 <ddarius> lambdabot is gone
10:11:10 <Cale> oh
10:11:15 <Cale> completely gone... hmm
10:11:36 <quicksilver> -!- lambdabot [i=cgibbard@72.249.126.23] has quit [Read error: 104  (Connection reset by peer)]
10:11:56 <Cale> I should really add something to my script for running lambdabot which tees the output into a log file.
10:12:42 <int-e> Cale: you can just use the type A := A -> A for all lambda calculus terms, can't you?
10:13:23 <quicksilver> Cale: beware of tee and buffering deadlocks.
10:13:23 <quicksilver> cale: just use a file and then tail -f it.
10:16:23 <Cale> okay, good, that's working. Forgot to 2>&1
10:16:48 <Cale> @bot
10:16:56 <lambdabot> :)
10:17:13 <Cale> Still, strange performance, given that my ssh session doesn't seem nearly so lagged.
10:17:51 <Cale> hmm
10:19:55 <Cale> @bot
10:20:01 <lambdabot> :)
10:20:04 <Cale> @src sequence
10:20:11 <lambdabot> sequence []     = return []
10:20:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:20:27 <lambdabot> Plugin `source' failed with: thread killed
10:20:33 <opqdonut> :O
10:20:53 <Cale> @src sequence
10:20:53 <lambdabot> sequence []     = return []
10:20:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:20:53 <lambdabot> --OR
10:20:53 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:20:56 <dcoutts_> @botsnack
10:20:56 <lambdabot> :)
10:21:07 <Cale> It seems to just be randomly slow.
10:21:08 <mauke> @botslap
10:21:08 <lambdabot> Unknown command, try @list
10:21:14 <dcoutts_> @vixen feeling better now?
10:21:14 <lambdabot> right now?
10:21:14 <opqdonut> wow, --OR :)
10:22:21 <Cale> @. vixen src sequence
10:22:21 <lambdabot> I am on the net too much. I should do a net anonymoouse group. online of course.
10:22:29 <dons> ?yow!
10:22:29 <lambdabot> Life is a POPULARITY CONTEST!  I'm REFRESHINGLY CANDID!!
10:22:56 <Cale> hmm, all that seems to end up in the log is the initial message about initialising the plugins
10:23:25 <byorgey> @src foldr
10:23:26 <lambdabot> foldr f z []     = z
10:23:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:23:35 <byorgey> =D
10:23:39 <byorgey> @src foldl
10:23:39 <lambdabot> foldl f z []     = z
10:23:39 <lambdabot> foldl f z (x:xs) = foldl (f z x) xs
10:23:49 <Cale> oops
10:23:51 <Cale> bug in that :)
10:24:03 <opqdonut> :D
10:24:07 <byorgey> ah, hehe =)
10:24:13 <faxathisia> where?
10:24:23 <mauke> missing f
10:24:25 <byorgey> should be foldl *f* (f z x) xs
10:24:29 <Cale> yes
10:24:34 <faxathisia> ohh yeah
10:25:01 <Cale> The real wtf though is why the source file is not named source.gz
10:25:05 <faxathisia> should have used a typed language ....
10:25:29 <opqdonut> faxathisia: :D:D
10:25:30 <Cale> @src foldl
10:25:36 <lambdabot> foldl f z []     = z
10:25:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:26:09 <byorgey> Cale++
10:27:36 <Cale> hmm, where does the Source plugin specify the name of its state file?
10:28:00 <faxathisia> --OR
10:28:01 <faxathisia> foldl f z xs = foldr (flip f) z (reverse xs)
10:28:25 <dons> Cale, the name is derived from the plugin name, usually
10:28:31 <Cale> ah, okay
10:28:50 <dons> yeah, so 'source'
10:28:54 <dons> but not tagged with its type
10:29:04 <Cale> right
10:29:20 <Cale> Is there a really good reason that it should be gzipped?
10:30:48 <dons> probably not.
10:30:52 <dons> just that we can :)
10:31:07 <dons> but you're the boss. hack as you see fit.
10:31:56 <Cale> Okay. I think I'd prefer it not to be zipped, as it makes editing harder.
10:32:26 <Cale> @src foldr
10:32:32 <Cale> ...
10:32:33 <lambdabot> Plugin `source' failed with: state not initalized
10:32:36 <Cale> ah
10:32:46 <Cale> er...
10:32:46 <smg> haha i am so lame :|
10:33:01 <EvilTerran> foldr f e [] = e; foldr f e (x:xs) = f x (foldr f e xs)
10:33:29 <Cale> EvilTerran: I'm not actually asking for the source. I'm testing the source plugin.
10:33:35 <Cale> hmm
10:33:39 <EvilTerran> oh, ok
10:33:57 <ddarius> EvilTerran: If Cale doesn't know the source of foldr at this point, something is seriously wrong.
10:34:02 <smg> i don't understand ~ resp. fix()
10:34:09 <EvilTerran> i thought he might've been showing someone
10:34:15 <EvilTerran> i didn't reay any scrollback
10:34:33 <Cale> hmm, I wonder what's wrong with it now.
10:34:46 <Cale> I removed the call to gunzip, and unzipped the source file.
10:35:02 <Cale> (and reinstalled lambdabot)
10:35:27 <Cale> @src foldr
10:35:34 <lambdabot> Plugin `source' failed with: state not initalized
10:35:49 <ddarius> initialized
10:35:58 <Cale> Error parsing state file for: source: user error (Codec.Compression.Zlib: incorrect header check)
10:35:58 <Cale> Try removing: "State/source"
10:36:10 <Cale> hmm, so it's still trying to decompress it
10:36:11 <Teppicammon> hi, i'm trying to create a OpenGL Window in ubuntu 7.10, but when i execute my program i can't see the window, i know it's there because i can see it in my taskbar
10:36:30 <Teppicammon> anybody knows what is happening?
10:37:31 <mauke> heh, grep initalized
10:38:54 <smg> lambdabot broken?
10:39:35 <glen_quagmire> > 1
10:39:35 <lambdabot>  1
10:39:41 <glen_quagmire> no it's not broken
10:39:43 <Cale> Teppicammon: I'm not sure. Perhaps someone could help better if you paste your code on hpaste.
10:39:52 <Cale> It's just the source plugin which is broken right now.
10:40:14 <Cale> grepping for initialized only turns up binary files. Apparently that word doesn't occur in the source?
10:40:28 <mauke> no, initalized
10:40:33 <mauke> not initialized
10:40:38 <Cale> ah, heh
10:42:22 <Teppicammon> Cale: what is hpaste? I'm following a tutorial, and it says i should be watching a window with some points... I just copy + paste the code to check if i had HOpenGl correctly installed
10:42:25 <Cale>     moduleDefState  _  = return $ error "state not initalized"
10:42:30 <Cale> @paste
10:42:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:43:20 <Cale> It's the default method implementation in the class Module.
10:43:52 <smg> acn someone explain _ and ~ ?
10:43:54 <mauke> I thought you might want to fix the typo
10:43:57 <smg> erm ~ and fix() ?
10:44:08 <Cale> mauke: Yeah, I will.
10:44:12 <opqdonut> > fix (!:)
10:44:12 <lambdabot>   Not in scope: `!:'
10:44:14 <opqdonut> > fix (1:)
10:44:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
10:44:20 <mauke> smg: ~ is used for lazy pattern matching
10:44:20 <Cale> mauke: However, I'm really more interested in why that's being called here.
10:44:43 <hpaste>  teppicammon pasted "OpenGl- prueba" at http://hpaste.org/5991
10:44:49 <smg> mauke: yeah sure, but i don't understand when i need this
10:45:01 <mauke> when you don't want to look at a value but still refer to its parts
10:45:14 <mauke> you could always replace it by appropriate function calls
10:45:15 <opqdonut> or when you need the parts only in some occasions
10:45:32 <opqdonut> and want to keep the function as non-strict as possible
10:45:40 <smg> so ~ isn't really essential to code programs?
10:45:55 <smg> i need to read about that non-strict, strict and ~ thing somewhere
10:45:56 <Cale> There are places where ~ is really really important.
10:46:01 <Cale> But they're rare.
10:46:08 <mauke> > case [] of (x : xs) -> length [x] + length [xs]
10:46:08 <lambdabot>   Non-exhaustive patterns in case
10:46:11 <mauke> > case [] of ~(x : xs) -> length [x] + length [xs]
10:46:12 <lambdabot>  2
10:46:21 <Cale> One which came up yesterday was in the monoid instance for a log datastructure
10:46:28 <mauke> > case [] of tmp -> length [head tmp] + length [tail tmp]
10:46:28 <lambdabot>  2
10:47:00 <trez> never seen ~ before, where can I read more about it?
10:47:03 <Cale> (Log x y z) `mappend` (Log x' y' z') = Log (x `mappend` x') (y `mappend` y') (z `mappend` z')
10:47:09 <Cale> This had a severe problem with it.
10:47:38 <mauke> I assume Log is the only constructor
10:47:42 <smg> mauke: mh
10:47:43 <Cale> yes
10:48:00 <Cale> Namely, that because it pattern matches on the second Log, when used with Writer, you end up not getting any of the log until the very end.
10:48:33 <Cale> (which in this guy's case, meant that the program ate up about 120 MB of memory because the log couldn't get GC'd until the end.)
10:49:07 <Cale> So inserting a ~ or two fixed the problem, and made the program run in constant space again.
10:49:25 <Teppicammon> i've pasted the code, can anybody try it and tell me if it works?
10:49:38 <dons> there's some  uses of ~ in arrows, and in binary, that are similarly critical
10:50:04 <dons> runGetState :: Get a -> L.ByteString -> Int64 -> (a, L.ByteString, Int64)
10:50:04 <dons> runGetState m str off =
10:50:04 <dons>     case unGet m (mkState str off) of
10:50:04 <dons>       (a, ~(S s ss newOff)) -> (a, s `join` ss, newOff)
10:50:37 <dons> (f *** g) ~(x,y) = (f x, g y)
10:50:39 <Cale> Teppicammon: It displays a small window which doesn't paint itself.
10:51:01 <Cale> (i.e. you get a hall-of-mirrors sort of effect if you drag stuff over top of it)
10:51:16 <Teppicammon> Cale: thanks! so you can see the window but not the points?
10:51:22 <Cale> yeah
10:51:43 <Cale> This is on Ubuntu feisty.
10:51:49 <Cale> With GHC 6.8.2
10:52:28 <Teppicammon> do you have beryl installed? i think maybe it's doing something weird...
10:52:40 <Cale> oh, actually, I can see the points
10:52:49 <Cale> It's just that they're white, and tiny.
10:52:59 <Cale> and the rest of the window doesn't have anything painted on it
10:53:11 <Cale> (so if it happens to be white, you can't see them)
10:55:12 <Teppicammon> i can't see the window at all
10:55:12 <Teppicammon> ok, then i've got something wrong in my config...
10:55:12 <Teppicammon> but i should see the frame...
10:55:22 <Cale> yeah
10:56:04 <Cale> I'm not using compiz. It's way too buggy, and mostly just distracting.
10:56:14 <Cale> I'm just running metacity.
10:57:05 <Teppicammon> i think that it's my problem, the window is there, i can drag it, but it's invisible...
10:57:40 <Cale> Well, you should at least see the border.
10:58:58 <Cale> It doesn't seem to be responding to most or all of the Expose events that it gets.
10:59:09 <Teppicammon> i can't, i disabled compiz, and then i only see the border
10:59:25 <Teppicammon> but the window doesn't repaint itself
10:59:27 <Cale> Okay, what happens when you drag some other window on top of that one.
10:59:36 <Teppicammon> it takes the background
10:59:44 <Cale> Say, drag a terminal window along the bottom edge for a bit.
11:00:16 <Cale> for me, it eventually turns black in the area where the terminal window didn't cover it, and the dots appear.
11:00:52 <Cale> http://cale.yi.org/autoshare/Screenshot-Hola%20Mundo.png
11:00:55 <Cale> Like that
11:02:08 <Teppicammon> nothing, if i try it with compiz, if i disable it i can move the window, but i has nothing inside, only the frozen background
11:03:43 <lament> what are those white dots?
11:04:58 <Teppicammon> lament: they are points in a window, painted using HOpenGl
11:05:23 <lament> oh, stunning
11:05:39 <Teppicammon> quite impresive isn't it?
11:06:07 <lament> yes, it's like looking at the starry sky... makes you feel small and insignificant
11:08:16 <lenbust> can I make a GADT derive Show?
11:08:51 <hallongrottan> lenbust: no
11:09:03 <lenbust> awr :-(
11:09:07 <hallongrottan> atleast we could not, we had to put a (Show a) => before every line
11:09:13 <hallongrottan> before every contructor*
11:09:27 <lenbust> oh, alright
11:09:49 <lenbust> I've done that for some other types already, so I'm starting to get the hang of it
11:12:15 <Cale> @source foldr
11:12:23 <lambdabot> foldr not available
11:12:34 <Cale> @src foldr
11:12:41 <lambdabot> foldr f z []     = z
11:12:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:13:04 <Cale> okay, it was just confusion over which version was installed.
11:16:50 <jrx> @pl \x->(x^x)
11:16:50 <lambdabot> join (^)
11:16:56 <jrx> :t join
11:16:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:24:19 <Cale> jrx: Want an explanation of what's going on there?
11:25:27 <Cale> The key piece of information is that ((->) e) is a monad, and in that monad, join has type  (e -> (e -> a)) -> (e -> a)
11:25:34 <lament> whenever something looks like magic and there's a monad involved, it must be the -> monad
11:25:45 <lament> the #1 rule of thumb of haskell :)
11:26:00 <Cale> The ((->) e) monad has some really nice consequences.
11:26:05 <jrx> Cale: I think I still don't know ;)
11:26:16 <mauke> lament: [] is also pretty cool
11:26:39 <lament> mauke: it's cool but usually more or less understandable
11:26:41 <jrx> I already know about [] monad, but never heard of anything like (->)
11:26:55 <mauke> so is ->
11:27:01 <Cale> jrx: Well, do you get how if m = ((->) e), then join :: m (m a) -> m a would then be (e -> (e -> a)) -> (e -> a) ?
11:27:03 <pgavin> jrx: (->) is the function type constructor
11:27:17 <Cale> (->) is being partially applied here
11:27:33 <Cale> (to its first type parameter)
11:27:50 <Cale> @kind (->)
11:27:50 <lambdabot> ?? -> ? -> *
11:27:54 <Cale> @kind (->) e
11:27:55 <lambdabot> Not in scope: type variable `e'
11:27:57 <Cale> @kind (->) String
11:27:58 <lambdabot> ? -> *
11:27:58 <pgavin> so ((->) e) is the type of functions from e to anything else
11:28:16 <resiak> Cale: so how seriously do you suggest that (.) should be defined to be fmap?
11:28:17 <Cale> ((->) e) a = e -> a
11:28:22 * jrx trying to get through that
11:28:24 <lament> why is ((->) e) from e and not to e?
11:28:26 <Cale> resiak: Pretty seriously now.
11:28:38 <resiak> Cale: surely it will make errors even more inpenetrable?
11:28:45 <Cale> resiak: It started out half-jokingly, but I've pretty much convinced myself that it's a good idea.
11:28:53 <Cale> resiak: I don't think they'll be so bad.
11:29:02 <mauke> lament: why is (-) x from x and not to x?
11:29:18 <jrx> Cale: ok, I understand know, why the type is looking like that
11:29:26 <lament> mauke: good point.
11:29:35 <jrx> but what's going on with the value?
11:29:43 <Cale> jrx: Okay, well, there are not so many functions of that type, so that will already basically tell you what join must be doing.
11:29:52 <Cale> But we can look at it another way if you like.
11:29:57 <mauke> @djinn (e -> (e -> a)) -> (e -> a)
11:29:57 <lambdabot> f a b = a b b
11:30:22 <Cale> (e -> e -> a) -> e -> a
11:30:30 <resiak> Cale: i get confused enough as it is about which monad i'm operating on in   m (Maybe a)
11:30:40 <Cale> The only thing it can do to get an a is to use the e that it has with the function
11:30:57 <Cale> and then use that e again
11:31:45 <Cale> resiak: The key property which makes it sane is that every functor is required to satisfy the property that  fmap (f . g) x = fmap f (fmap g x)
11:31:58 <jrx> @src join
11:31:58 <lambdabot> join x =  x >>= id
11:32:01 <Cale> resiak: When translated using fmap -> (.), this gives:
11:32:08 <Cale> (f . g) . x = f . (g . x)
11:32:15 <jrx> @src -> >>=
11:32:15 <lambdabot> Source not found. I am sorry.
11:32:21 <jrx> @src (->) (>>=)
11:32:21 <lambdabot> f >>= k = \ r -> k (f r) r
11:32:22 <Cale> Which is the associative law for composition.
11:32:29 <resiak> Cale: oh, i agree that it's elegant :)
11:32:48 <resiak> and, correct.  but i fear the potential for confusion
11:32:53 <Cale> You also have that the last element in any composition chain determines the functor type for the whole chain.
11:32:53 <smg> > max [1,2,3]
11:32:54 <lambdabot>  <[Integer] -> [Integer]>
11:33:23 <resiak> > maximum [1..3]
11:33:23 <Lemmih> > maximum [1,2,3]
11:33:24 <lambdabot>  3
11:33:24 <lambdabot>  3
11:33:33 <Cale> If you have  f . g . h . x, well, x is going to be typed in the instance of Functor, and f, g, h are all functions.
11:33:52 <Cale> x might also be a function, that's the only source of ambiguity about it.
11:33:57 <hpaste>  skorpan pasted "Shitty program" at http://hpaste.org/5992
11:34:39 <Cale> byorgey: You want to respond to that? :) You appear to be the maintainer of that code ;)
11:35:18 <byorgey> Cale: hehe =)
11:35:32 <Cale> jrx: In the (->) e monad, computations are functions which take a parameter of type e.
11:35:42 <byorgey> skorpan appears to be following my xmonad development tutorial, and copy & pasted some of the example code =)
11:35:54 <Cale> jrx: When you run one of these computations, it just gets applied to the argument which the whole computation has been applied to.
11:36:00 <Cale> jrx: for example:
11:36:05 <jrx> Cale: yep, I have read the source of >>= and thinks became clearer
11:36:19 <jrx> s/thinks/things/
11:36:19 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
11:36:20 <lambdabot>  ("Hello","olleH","HELLO")
11:36:45 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
11:36:46 <lambdabot>  [5,7,10,25,32]
11:36:51 <dmwit> > sequence [id, reverse, map toUppre] "Hello"
11:36:52 <lambdabot>   Not in scope: `toUppre'
11:36:52 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5 :: [Expr]
11:36:53 <lambdabot>  [5,5 + 2,5 * 2,5 * 5,2 * 2 * (2 * 2) * 2]
11:37:04 <dmwit> > sequence [id, reverse, map toUpper] "Hello"
11:37:05 <lambdabot>  ["Hello","olleH","HELLO"]
11:37:07 <gnuvince> :t sequence
11:37:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:37:23 <Cale> So in this monad, we have   sequence :: [e -> a] -> (e -> [a])
11:37:47 <mauke> turn a list of functions into a function returning a list
11:37:55 <dmwit> sequence fs a = map ($ a) fs
11:37:57 <Cale> join x = do y <- x; v <- y; return v
11:37:58 <resiak> Cale: hrm, maybe it wouldn't be so bad
11:38:19 <dmwit> (in this monad only)
11:38:24 <Cale> resiak: I think it's something which sounds a bit crazy at first, but you try it out and it's reasonably nice.
11:38:51 <Cale> resiak: I'm sure there are some errors which it makes a little more confusing.
11:39:02 <Cale> resiak: But it's rather nice notationally.
11:39:09 <resiak> Cale: hrm, and then i could use . everywhere i've been using <$> recently
11:39:28 <mauke> > filterM (return [True, False]) "abc"
11:39:29 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
11:39:32 <Cale> Maybe we should try it out in lambdabot for a while :)
11:39:42 <mauke> .oO( don't cross the streams )
11:40:22 <hpaste>  (anonymous) pasted "euler project 1-3" at http://hpaste.org/5993
11:40:52 <jrx> Cale: got it, but I'm very impressed with the skill of the one, who implemented @pl plugin with such transformations
11:40:54 <Cale> (+1) . [1,2,3]
11:40:56 <Cale> > (+1) . [1,2,3]
11:40:57 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
11:41:00 <Cale> okay...
11:41:07 <mauke> :t (.)
11:41:08 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:41:21 <Cale> I just updated L.hs
11:41:29 <Cale> maybe need to restart LB
11:41:45 <Cale> > (+1) . [1,2,3]
11:41:51 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
11:41:54 <Cale> huh
11:42:04 <Cale> I wonder what I'm going to have to do to get that to work :)
11:42:15 <resiak> modify the prelude! :D
11:42:21 <mauke> hack the gibson!
11:42:42 <resiak> hack the gibbard?
11:43:35 <dmwit> anonymous: "factorial" probably isn't the best name for that.  Just "factor" would be better.
11:43:37 <Cale> I wonder. If RunPlugs is already importing L.hs, and L.hs imports (and reexports) all the modules, why does RunPlugs have to import all sorts of things as well?
11:44:23 <mauke> > (+1) L.. [1,2,3]
11:44:23 <lambdabot>   Not in scope: `L..'
11:44:48 <Cale> I also wonder about why it doesn't appear to be using my L.hs
11:45:44 <Cale> > describeSequence [1,1,2,3,5,8]
11:45:45 <lambdabot>  Just "Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = ...
11:45:55 <Cale> see, now it is...
11:46:44 <Cale> :t L..
11:46:45 <lambdabot> parse error on input `L..'
11:46:49 <Cale> :t (L..)
11:46:49 <lambdabot> Couldn't find qualified module.
11:46:58 <Cale> > (+1) L.. [1,2,3]
11:46:59 <lambdabot>  [2,3,4]
11:47:04 <Cale> > (+1) . [1,2,3]
11:47:04 <lambdabot> Terminated
11:47:06 <Cale> hmm
11:47:14 <mauke> that's a name conflict
11:47:21 <mauke> Prelude.. is still in scope, it seems
11:47:23 <Cale> > (+1) Prelude.. (+2) $ 5
11:47:24 <lambdabot>  8
11:47:25 <Cale> yes
11:47:40 <Cale> Even though I hid it, because RunPlugs does a whole lot of importing of its own.
11:48:10 <dmwit> Have fun tracking down where that import is coming from.
11:49:34 <bm3719> can pattern matching be used in a lambda expression, and if so, what is the syntax?
11:50:09 <dmwit> :t \Just x -> x
11:50:10 <lambdabot>     Constructor `Just' should have 1 argument, but has been given 0
11:50:10 <lambdabot>     In the pattern: Just
11:50:14 <mauke> \ PATTERN -> BODY
11:50:18 <dmwit> :t \(Just x) -> x
11:50:19 <lambdabot> forall t. Maybe t -> t
11:50:36 <dmwit> bm3719: But you only get to match against one pattern that way.
11:50:53 <dmwit> bm3719: If you want multiple patterns, use a "case" in the body of the lambda, or write a proper named function.
11:51:11 <bm3719> ok, thanks :)
11:51:26 <matthew-_> hmm. you know you're in trouble when your forall ... line line-wraps...
11:51:45 <matthew-_> ... on a 1600x1200 monitor
11:52:16 <Gilly> with elephant-sized fonts however? ;)
11:52:27 <mauke> use a smaller font
11:52:28 <pgavin> matthew-_: you can probably collapse some of your context classes into one class
11:52:36 <mauke> 5pt can still be readable
11:52:50 <pgavin> mauke: depends on the font :)
11:53:59 <matthew-_> pgavin: yeah, that's probably true
11:54:26 <matthew-_> my type sigs tend to be two to four times the size of the actual runtime code
11:56:37 <oerjan> scary!
11:58:54 <matthew-_> yeah, tell me about it.
11:59:09 <matthew-_> though it's not so much that it's scary. just more worrying what it does to your head
11:59:29 <sclv_> this is for the session types stuff?
12:01:21 <matthew-_> indeed
12:01:49 <matthew-_> should be a new release tonight allowing interleavings - i.e. the ability for a thread to have sessions with multiple peers
12:02:00 <matthew-_> and arbitrarily interleave those communications
12:04:17 <sclv_> for those that didn't see this the first time round: http://hpaste.org/5812
12:04:56 <dmwit> Yikes!
12:05:15 <bm3719> I have a function that uses RandomR and therefore returns an IO Int.. how can i then convert that Int to a string?
12:05:15 <Cale> Oh! I see why now. We have no way to express that a module is supposed to reexport all modules, along with everything which is in it.
12:05:30 <Cale> bm3719: show
12:05:49 <dmwit> bm3719: You can convert it to an IO String, but not a String.
12:06:09 <dmwit> :t fmap show
12:06:10 <lambdabot> forall a (f :: * -> *). (Functor f, Show a) => f a -> f String
12:06:14 <bm3719> show doesn't like IO Int, right?
12:06:31 <Cale> bm3719: Right, because an IO Int is an action which when run will produce an Int
12:06:34 <dmwit> bm3719: Right, but fmap show (or using show in a do-block) is fine.
12:06:58 <matthew-_> sclv_: that's not really fair though - that's massive expansion of super types
12:07:06 <Cale> bm3719: If you're confused about how IO works generally, I have a rather short tutorial you might like to look at.
12:07:12 <bm3719> ah, ok.. gonna give that a try :)
12:07:17 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
12:07:43 <Cale> sigh... lambdabot's eval is slightly broken for the moment. Give me some time to fix it :)
12:07:57 <matthew-_> sclv_: and I've got better examples than that! Not only do I have base10 numbers and lists in the type system but I also have Maps (as in Data.Map) there too
12:08:32 <sclv_> Zounds! Have you considered integrating some work with the type-level effort?
12:09:10 <matthew-_> sorry, I don't follow
12:09:30 <bm3719> Cale: I'm doing the "yet another haskell tutorial" as we speak :)
12:10:05 <bm3719> i'll check out that one if i'm still confused afterwards, thanks
12:11:29 <Cale> bm3719: You might like to have a quick look at it regardless. It's just intended to give the right perspective, it doesn't really cover any of the details.
12:11:58 <sclv_> http://www.haskell.org/pipermail/haskell-cafe/2008-February/040086.html
12:11:59 <lambdabot> Title: [Haskell-cafe] ANNOUNCE: parameterized-data 0.1 - Parameterized data library imp ..., http://tinyurl.com/2yhby7
12:12:00 <Cale> Hmm, I wonder if I can solve this problem using the C preprocessor.
12:12:13 * gwern reads Perl's 'Periodic Table of the Operators', http://www.ozonehouse.com/mark/blog/code/PeriodicTable.pdf <-- omg
12:12:15 <Cale> Yeah, I think that's what I'll do.
12:12:21 <dmwit> The IO Monad for People who Simply Don't Care -- pretty funny
12:12:23 <sclv_> http://www.haskell.org/pipermail/haskell-cafe/2008-February/040073.html
12:12:24 <lambdabot> Title: [Haskell-cafe] ANNOUNCE: type-level 0.1: Haskell type-level programming library, http://tinyurl.com/23o97q
12:12:44 <Cale> err...
12:13:27 <Cale> yeah, maybe :)
12:13:28 <sclv_> There we are: a library doing type-level ints. I'm sure they could use your map work...
12:13:43 <matthew-_> ahh, possibly
12:13:54 <matthew-_> depends whether we took the same basic design decisions
12:14:11 * oerjan wonders how long before someone decides it'll be less work to add dependent types...
12:17:53 <dolio> But dependent types are all scary and stuff.
12:19:44 <Deewiant> gwern: cute :-) but if you think that's bad, have a look at http://www.php.net/manual/en/types.comparisons.php
12:19:44 <lambdabot> Title: PHP: PHP type comparison tables - Manual
12:20:36 <leather> All: Someone was telling me about a list concatenation trick that reduces the time complexity over using (++). Can anyone point me to an explanation?
12:20:52 <gwern> Deewiant: the formatting hurts my eyes
12:21:28 * gwern wonders whether 'concat $ foo:bar' is faster than 'foo ++ bar'
12:21:39 <gwern> @src (++)
12:21:39 <lambdabot> (++) []     ys = ys
12:21:39 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
12:21:54 <gwern> @src concat
12:21:54 <lambdabot> concat = foldr (++) []
12:21:56 <oerjan> dolio: and that paste wasn't? :D
12:22:20 <leather> gwern: Doesn't look that way.
12:22:28 <cinema> sclv_: I encountered a bur in HStringTemplate, it creates a wrong number of accurrences
12:22:42 <gwern> hm. looks like they both reduce to ++ and then a : between each element
12:22:47 <cinema> sclv_: s/bur/bug/
12:23:05 <dolio> oerjan: Eh. I like dependent types, myself.
12:23:27 <oerjan> @src ShowS
12:23:27 <lambdabot> type ShowS = String -> String
12:23:48 <oerjan> leather: using ShowS instead ^^
12:23:52 <sclv_> cinema: go on.
12:24:25 <cinema> sclv_: it generates a number of occurrences limited to the number of attributes
12:24:26 <oerjan> composing functions is more efficient than concatenating strings
12:24:27 <leather> Got it: http://research.microsoft.com/users/daan/download/ddata/doc/Seq.html
12:24:28 <lambdabot> http://tinyurl.com/35n2br
12:24:29 * matthew-_ swears loudly after spending half an hour chasing a bug which turned out to be a missing '
12:24:57 <sclv_> hmm... paste?
12:25:20 <cinema> sclv_: help me, how do I paste ?
12:25:27 <sclv_> @paste
12:25:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:25:42 <monochrom> hehe missing '
12:25:55 <leather> "An implementation of John Hughes's efficient catenable sequence type. A lazy sequence Seq a can be concatenated in O(1) time. After construction, the sequence in converted in O(n) time into a list."
12:25:55 <cjb> also http://codepad.org/, if you want to run your code too (if it's self-contained).
12:26:04 <dolio> oerjan: Although, I suppose I could see that you can't just go adding them to Haskell. All the stuff in GHC that approximates them nicely allows you to do without them and, say, not annotate anything, even at the top level.
12:26:10 <hpaste>  cinema pasted "bug in HStringTemplate" at http://hpaste.org/5994
12:26:29 <dolio> If you want to do that.
12:26:49 * monochrom attempts unsafePerfomIO stuff
12:27:13 <monochrom> unsafePerformIO (system "ls")
12:27:38 <hpaste>  matthew-_ annotated "enjoy" with "Told you I had a better one..." at http://hpaste.org/5812#a1
12:27:45 * xerox points at the cat looking from the ceiling of the room.
12:27:59 <monochrom> hehe
12:28:00 <hpaste>  (anonymous) annotated "bug in HStringTemplate" with "(no title)" at http://hpaste.org/5994#a1
12:29:59 <cinema> sclv_: the example generates 4 occurrences instead of 10
12:30:04 <sclv_> cinema: good catch! I'll look into it. glad someone is finally putting this through the paces.0
12:30:44 <cinema> sclv_: I am very enthusiastic about HStringTemplate. I use it all the time
12:31:03 <Cale> > (+1) . [1,2,3]
12:31:04 <lambdabot>  [2,3,4]
12:31:06 <Cale> :)
12:31:25 <monochrom> (atheist tone) There is no Cat Looking From The Ceiling.
12:31:38 <Cale> I'm still in the midst of unifying imports though.
12:31:40 <sclv_> oh god, next thing you know he'll be changing the associativity in $ on the bot and importing the numeric prelude...
12:31:49 <Cale> Oh, what a good idea!
12:32:00 <oerjan> @slap sclv_
12:32:01 * lambdabot secretly deletes sclv_'s source code
12:32:14 <gwern> what the - how does '(+1) . [1,2,3]' work?
12:32:26 <Cale> I've replaced (.) with fmap
12:32:34 <cjb> > (take 2) [3,4,5]
12:32:34 <monochrom> Haha
12:32:35 <lambdabot>  [3,4]
12:32:49 <cjb> oh, heh
12:33:01 <Heffalump> that's just silly. [1,2,3] isn't a function.
12:33:02 <gwern> Cale: the implications of that exceed my grasp
12:33:04 <sclv_> > take 5 "Dave Brubeck"
12:33:04 <lambdabot>  "Dave "
12:33:13 <Cale> It'll still do all its usual tasks, of course, because there's an instance of Functor for ((->) e) such that fmap is composition.
12:33:44 <Heffalump> it won't do one of its usual tasks, namely providing a sensible error message when you misuse it
12:33:49 <monochrom> > sort . sin . [1,2,3]
12:33:49 <lambdabot>   add an instance declaration for (Floating [a])
12:34:06 <xerox> > sort (sin . [1,2,3])
12:34:06 <lambdabot>  [0.1411200080598672,0.8414709848078965,0.9092974268256817]
12:34:18 <Heffalump> > sort . (sin . [1,2,3])
12:34:18 <lambdabot>   add an instance declaration for (Floating [a])
12:34:26 <Heffalump> oh, right
12:34:29 <Cale> You don't want to map sort over the list.
12:34:31 <Heffalump> yeah
12:35:02 <Cale> Also, due to the functor law, the operation is still associative.
12:35:21 <oerjan> hm forgetting $ on the final element of a . . $ chain is pretty common isn't it
12:35:36 <mauke> :t (.)
12:35:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:35:46 <Cale> Yeah, I haven't fixed up :t yet.
12:35:47 <gio123> can i compile schema code in haskel
12:35:48 <gio123> ?
12:35:55 <monochrom> > (sort . (sin .)) [1,2,3]
12:35:56 <lambdabot>  [0.1411200080598672,0.8414709848078965,0.9092974268256817]
12:36:05 <Heffalump> is this the normal channel lambdabot, or a special one you're running?
12:36:11 <Cale> Both.
12:36:22 <Heffalump> as in you've taken over running the normal one?
12:36:23 <xerox> monochrom: heh.
12:36:25 <Cale> yes
12:36:52 <Cale> The special meaning of (.) is just an addition to L.hs
12:36:53 <mauke> :t fmap fmap fmap
12:36:54 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:36:58 <Cale> So it won't be hard to revert it.
12:37:03 <oerjan> > on
12:37:03 <lambdabot>        instance (Typeable a, Typeable b) => Show (a -> b)
12:37:03 <lambdabot>         -- Defined ...
12:37:11 <monochrom> I declare that I have no problem with it.
12:37:18 <oerjan> huh.
12:37:19 <Heffalump> well, I'm biased against it anyway, but I don't think it's very appropriate for what amounts to a standard channel service
12:37:36 <sclv_> I sort of would like run to be extended with @c which would run everything with cale's rules. then we could play around with both.
12:37:49 <mauke> I like it
12:37:50 <monochrom> If OOP fanatics are allowed to hijack "." to mean what vain thing they want it to mean, why not go with Cale, which is better.
12:37:59 <Cale> What better way to experiment with Prelude changes than experimenting with them in lambdabot first? :)
12:38:10 * xerox agrees as well
12:38:27 <sclv_> I totally agree, but we maybe should keep default (>) with the defaults for teaching purposes?
12:38:46 <Heffalump> yeah, having a different prompt would be reasonable
12:38:53 <Cale> Possibly. That'll take some doing to rig up though.
12:38:58 <Heffalump> monochrom: they don't hijack it on here, though.
12:39:13 <monochrom> Cultural change begins with teaching change.
12:39:28 <Heffalump> I question whether it's an appropriate change in the first place, though.
12:39:30 <sclv_> that's just because my @java plugin isn't finished yet.
12:39:34 <Cale> I don't think it'll be too much of a problem. (.) will still serve all its current purposes.
12:39:35 <monochrom> Teach the new kids the new (.), and they will vote for it when the time comes.
12:39:56 <Heffalump> Cale: I (continue to) disagree. The different type matters.
12:40:01 <monochrom> vote in favour of it, even.
12:40:53 * oerjan is pondering whether you can get typing ambiguities with the new .
12:41:05 <Heffalump> Yes, certainly.
12:41:11 <monochrom> @type .
12:41:11 <lambdabot> parse error on input `.'
12:41:14 <monochrom> @type (.)
12:41:15 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:41:24 <Cale> Not unless you have something which could be more than one functorial type.
12:41:35 <monochrom> Cale you need to synchronize @type with > :)
12:41:35 <sclv_> @type let (.) = fmap in (.)
12:41:35 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f a -> f b
12:41:43 <Cale> monochrom: I do. I'm working on it.
12:41:54 <monochrom> Ooops ok, no rush.
12:42:06 <Cale> sclv_: That works right up until the MR bites you.
12:42:16 <Heffalump> > (((+ 1) . (+ 2)) >>= (+)) 3
12:42:17 <lambdabot>  9
12:42:17 <matthew-_> well disable that then ;)
12:42:23 <Cale> Okay.
12:42:31 <monochrom> "the heretic lambdabot"
12:42:32 <Heffalump> oh, duh
12:42:46 <mauke> > id Prelude.. id $ 42
12:42:46 <lambdabot>   Not in scope: `Prelude..'
12:42:46 <sclv_> the mr is a real pain in @type on the bot -- i'm all for disabling that.
12:42:56 <Cale> > id P.. id $ 42
12:42:56 <lambdabot>  42
12:42:59 <Cale> > id . id $ 42
12:43:00 <lambdabot>  42
12:43:24 <matthew-_> > id `fmap` id $ 42
12:43:25 <lambdabot>  42
12:44:14 <sclv_> we discovered something silly the other week which was, I think, that @type fmap fmap fmap fmap etc. cycles but @type let buffalo = fmap in buffalo buffalo... etc doesn't because of that darned mr.
12:44:49 <oerjan> er they should both cycle
12:44:59 <monochrom> Interesting
12:45:04 <oerjan> the latter is just (.) after all
12:45:30 <sclv_> @typle left buffalo = fmap in buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo buffalo
12:45:31 <lambdabot> parse error on input `='
12:45:54 <sclv_> @type let a = fmap in a a a a a a a a a a a a a
12:45:55 <lambdabot>     Occurs check: cannot construct the infinite type:
12:45:55 <lambdabot>       a = a -> t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6
12:45:55 <lambdabot>     Probable cause: `a' is applied to too few arguments
12:46:05 <oerjan> oh
12:46:11 <sclv_> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
12:46:12 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f, Functor f1) => f1 (a -> b) -> f1 (f (f2 a) -> f (f2 b))
12:46:12 <oerjan> hm...
12:46:26 <oerjan> @type let a = (.) in a a a a a a a a a a a a a
12:46:26 <lambdabot> forall a a1 a2 b c a3. (a -> a1 -> a2 -> b -> c) -> a -> a1 -> a2 -> (a3 -> b) -> a3 -> c
12:46:44 <Cale> @type let a = fmap in a a a a a a a a a a a a a
12:46:45 <lambdabot>     Occurs check: cannot construct the infinite type:
12:46:45 <lambdabot>       a = a -> t -> t1 -> t2 -> t3 -> t4 -> t5 -> t6
12:46:45 <lambdabot>     Probable cause: `a' is applied to too few arguments
12:47:08 <oerjan> seems i was wrong
12:47:12 <leather> Now that I've discovered Seq's, I'm a happy man!
12:47:15 <leather> http://research.microsoft.com/users/daan/download/ddata/doc/Seq.html
12:47:16 <lambdabot> http://tinyurl.com/35n2br
12:47:18 <leather> of course
12:47:40 <smg> @pl f number = if (length (filter (==0) [ number `mod` x | x <- [1..20] ]) == 20) then number else f (number+1)
12:47:40 <lambdabot> f = fix (ap (if' =<< (20 ==) . length . filter (0 ==) . return . (<- [1..20]) . (| x) . (`mod` x)) . (. (1 +)))
12:48:20 <monochrom> hehe
12:49:07 <Heffalump> dynamic reloading!
12:57:02 * matthew-_ is surprised he's bothering to write documentation before releasing...
12:57:24 <arussel> Hi, I am doiing yaht, I wrote this code (chapter 3) and it won't compile: http://pastebin.com/m24e0c2a2
12:57:36 <arussel> I am pretty sure it is exactly the pdf.
12:57:51 <mauke> what's the erroah, I see
12:58:04 <mauke> broken indentation
12:58:22 <mauke> bah, no. wrong font in my browser ;_;
12:58:25 <bparkis> so i was thinking, probably something everyone knows, but pattern matching is basically a logical conditional about a statement
12:58:47 <arussel> error: http://pastebin.com/m3294368b
12:58:51 <conal> bparkis: "about a statement"?
12:58:57 <bparkis> er, a value
12:59:06 <bparkis> i.e. if you have something like f (x a b) = c, you're saying, if there is an a and a b such that y = x a b, then f y = c
12:59:06 * faxathisia throws curry howard at bparkis
12:59:26 <mauke> arussel: start a new line after each "do" if you value your sanity
12:59:38 <bparkis> and that if you bring that into a dependently typed context that is simply logic programming
12:59:51 <bparkis> i.e. you're saying f y = c given some predicate P applies to y
12:59:54 <monochrom> Everything is a logical condition.
12:59:59 <ketil> arussel, broken indentation
13:00:21 <ketil> doGuessing must align with putStrLn
13:00:25 <bparkis> yes but i'm saying it could be an arbitrary condition, something that the program might have to infer and could not derive directly from the value
13:00:42 <bparkis> anyway i have to go to class, i'll be back in an hour
13:00:45 <ketil> (line 22)
13:01:25 <bparkis> (ie. the program might have to do some heavy duty prolog-style logical inference before it can decide whether P y holds)
13:01:53 <monochrom> Haskell pattern matching does not require much inference.
13:02:00 <wli> bparkis: Not so. It's syntactically desugared into case statements.
13:02:18 <arussel> ok, thanks it is loaded.
13:02:18 <faxathisia> you probably don't want to use Prolog style inference  if you want soundness or completeness :P
13:02:19 <ketil> arussel, got it?  Compare line 7 of the error against line 21-22 of the input
13:02:31 <monochrom> Here is a hypothetical pattern matching extension that requires much inference.
13:02:41 <monochrom> You can write: f x x = 0.
13:02:59 <monochrom> The meaning is that the two parameters are equal, thus the same name.
13:03:09 <arussel> ketil: yes, shouldn't emacs correct it for me ? or maybe I am just too used to eclipse taking of that kind of stuff for me :-)
13:03:31 <wli> That can easily be desugared as a pattern guard. For instance, f x x --> f x y | x == y
13:04:10 <monochrom> Here is another.
13:04:17 <monochrom> You can write: f (g x) = 0.
13:04:19 <wli> Give each variable appearing in the pattern as written a fresh name, add equality constraints where their original names coincided.
13:04:21 <thetallguy> Can someone point me at a good explanation of the "[instance ok]" which appears in the output of the new GHCi info command?
13:04:31 <conal> bparkis: makes sense to me: functional programming with pattern matching can be seen in part as syntactic sugar for a weakened logic programming language.  of course in other ways logic programming is weakened functional programming.  constraint logic programming has a rich intersection with both.
13:04:37 <monochrom> There are several possible meanings you can give it, with various difficulty of inference.
13:04:42 <matthew-_> wli: eh? That's valid at the type level in an instance declaration. But for values you'd require Eq
13:04:50 <thetallguy> e.g.: instance [overlap ok] Monad Gen
13:05:13 <wli> matthew-: Yes, it would impose an Eq constraint on the type of x.
13:05:14 <monochrom> One possible meaning is: when someone calls f y, check whether y was originated from a function call g x.
13:05:22 <matthew-_> thetallguy: it means you've turned on OverlappingInstances
13:05:28 <matthew-_> and they do overlap
13:05:43 <matthew-_> but if it still blows up then it means that your overlapping instances are not unambiguous
13:05:44 <monochrom> Another possible meaning: nevermind how y was originated. But do ask: does there exist x such that g x = y?  And find that x.
13:06:51 <thetallguy> matthew-: Hmm...  Or that someone turned them on for me.
13:06:54 <matthew-_> yep
13:06:59 <thetallguy> matthew-: Thanks.
13:07:10 <matthew-_> ahh fab, :info is much better than :type as it doesn't expand super classes
13:07:14 <wli> matthew-: In much the same way as the possibility of pattern match failure in monad comprehensions imposed a Monad0 constraint when they were still around.
13:07:44 <ehird`> @pl (\f g x y -> f (g x y))
13:07:45 <matthew-_> wli: that must have been before my time ;)
13:07:55 * ehird` kicks lambdabot 
13:07:57 <ehird`> oh.
13:07:58 <ehird`> i see.
13:07:59 <ehird`> @pl (\f g x y -> f (g x y))
13:07:59 <Cale> Sorry.
13:08:06 <conal> ehird`: fmap.fmap
13:08:06 <lambdabot> (.) . (.)
13:08:13 <ehird`> conal: haha, now that's clever
13:08:13 <ehird`> :)
13:08:21 <Cale> I'm messing around with various bits.
13:08:23 <ehird`> @pl (\f x y z -> f z x y)
13:08:28 <lambdabot> (flip .) . flip
13:08:35 <ehird`> Cale: It seems even slower than usual! :-P
13:08:41 <ehird`> @pl (\f x y z -> f z y x)
13:08:48 <lambdabot> flip . (flip .) . flip
13:08:49 <Cale> Yeah, I'm not sure about why that would be, but it's true.
13:08:51 <conal> ehird`: it's a common pattern.  and you can sprinkle first & second in as well.
13:09:22 <Cale> :t (.)
13:09:23 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:09:25 <Cale> nope.
13:09:28 <Cale> hmm
13:10:11 <ehird`> @t (\f x g y -> g y (f x))
13:10:11 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:10:13 <ehird`> @type (\f x g y -> g y (f x))
13:10:14 <lambdabot> forall t t1 t2 t3. (t -> t2) -> t -> (t1 -> t2 -> t3) -> t1 -> t3
13:10:16 <ehird`> @pl (\f x g y -> g y (f x))
13:10:16 <lambdabot> (flip flip .)
13:10:38 <Cale> :t describeSequence
13:10:41 <monochrom>   @tell temp thank you thanks thx
13:10:55 <monochrom> @thx
13:10:55 <lambdabot> you are welcome
13:11:03 <monochrom> @you
13:11:03 <lambdabot> Boys, you have ALL been selected to LEAVE th' PLANET in 15 minutes!!
13:11:25 <oerjan> @we
13:11:32 <ehird`> @hoogle (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:11:33 <lambdabot> No matches, try a more general search
13:11:35 <ehird`> filterM
13:11:36 <ehird`> :-)
13:11:54 * monochrom votes ehird` for the new lambdabot
13:12:06 <ehird`> oh crap
13:12:16 <ehird`> now i have to do pl-ing all in my head for other people
13:12:16 <ehird`> :(
13:12:32 <monochrom> You will now be put inside the IO monad to serve us. You cannot escape.
13:13:01 <sclv_> just type enough (.) . (.) flip flip (. flip) . (flip .) and nobody will know the difference.
13:13:18 <oerjan> :t (.) . (.) flip flip (. flip) . (flip .)
13:13:19 <lambdabot> forall a a1 b c a2 b1 c1. ((b -> a1 -> c) -> a2 -> b1 -> c1) -> (a -> a1 -> b -> c) -> a -> b1 -> a2 -> c1
13:13:48 <ehird`> wow, I actually found a use for filterM
13:13:50 <ehird`> this very second
13:13:50 <oerjan> @djinn ((b -> a1 -> c) -> a2 -> b1 -> c1) -> (a -> a1 -> b -> c) -> a -> b1 -> a2 -> c1
13:13:50 <lambdabot> f a b c d e = a (\ f g -> b c g f) e d
13:13:51 <ehird`> :|
13:13:57 * glguy notes that utf8-string has functions String -> ByteString , ByteString -> String now
13:14:00 <glguy> go nuts ;)
13:14:22 <oerjan> @unpl (.) . (.) flip flip (. flip) . (flip .)
13:14:23 <lambdabot> (\ w b c r s -> w (\ n o -> b c o n) s r)
13:15:36 <matthew-_> grrr. How do you make haddock happy about linking to foo' ? I've tried 'foo\'' and it's not happy
13:15:58 <sclv_> ^^ now that . does what <$> used to, we can reclaim it for my new combinator! :-)
13:16:20 <matthew-_> hmm. ignore that. I'm incompetant
13:16:39 <ehird`> @type <$>
13:16:40 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:16:46 <ehird`> lulzor
13:16:47 <oerjan> :t (^^)
13:16:47 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:20:49 <Cale> grr. I really wish right now that ghci accepted the exact same syntax for importing modules that import declarations do.
13:20:54 <ehird`> hmm
13:20:59 <ehird`> there's no way to make a 'derive'able thing is there?
13:21:03 <ehird`> that's a bit sad :(
13:21:23 <Cale> Oh well... this is close enough, I suppose.
13:21:36 <Cale> hmm
13:22:29 <Cale> @type (.)
13:22:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:22:54 <Cale> @let f x y z = x + y^z
13:23:00 <lambdabot> L.hs:4:0:  error: ../imports.h: No such file or directory
13:23:07 <Cale> d'oh
13:23:10 <byorgey> aww =(
13:23:28 <Cale> oh, I see
13:23:31 <Cale> hmm
13:23:58 <Cale> That is rather awkward.
13:24:48 <Cale> I'll just make a symlink.
13:25:48 <Cale> L.hs moves around, so loading the list of imports using the C preprocessor is awkward.
13:26:15 <Cale> @let f x y z = x + y^z
13:26:16 <lambdabot> Defined.
13:26:21 <Cale> :t f
13:26:27 <Cale> @type f
13:26:28 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:26:32 <Cale> hmm
13:26:44 <Cale> @type describeSequence
13:26:46 <lambdabot> SequenceData -> Maybe String
13:26:49 <jleedev> @type \x y z -> x + y^z
13:26:49 <Cale> @type (.)
13:26:50 <lambdabot> forall a b. (Integral b, Num a) => a -> a -> b -> a
13:26:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:26:57 <Cale> grr
13:27:13 <dolio> @type g
13:27:14 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:27:29 <Cale> It's *mostly* working.
13:27:39 <Cale> @undefine
13:27:39 <lambdabot> Undefined.
13:27:47 <Cale> @define ff x y z = x + y^z
13:27:47 <lambdabot> Undefined.
13:27:51 <Cale> er..
13:27:54 <Cale> @let ff x y z = x + y^z
13:27:54 <lambdabot> Defined.
13:27:59 <Cale> @type ff
13:28:00 <lambdabot> forall a b. (Num a, Integral b) => a -> a -> b -> a
13:28:04 <Cale> okay, good
13:28:07 <Cale> that's all it was
13:28:08 <dolio> @type f
13:28:09 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:28:18 <Cale> @undefine
13:28:18 <lambdabot> Undefined.
13:28:22 <Cale> cool
13:28:32 <jaas> @src filter
13:28:32 <lambdabot> filter _ []     = []
13:28:32 <lambdabot> filter p (x:xs)
13:28:32 <lambdabot>     | p x       = x : filter p xs
13:28:32 <lambdabot>     | otherwise = filter p xs
13:28:44 <sclv_> ?seen cinema
13:28:44 <lambdabot> cinema is in #haskell. I don't know when cinema last spoke.
13:29:52 <Lemmih> @src f
13:29:53 <lambdabot> Source not found. There are some things that I just don't know.
13:31:28 <jleedev> > replicateM 4 "01"
13:31:28 <lambdabot>  ["0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010...
13:31:59 <faxathisia> > concatMap (flip replicateM "01") [1..]
13:31:59 <lambdabot>  ["0","1","00","01","10","11","000","001","010","011","100","101","110","111"...
13:32:15 <jleedev> cute
13:32:24 <cjb> lovely :)
13:33:25 <jleedev> is replicateM actually useful?
13:33:40 <jleedev> all i can think of is "stupid list monad tricks"
13:33:54 <dolio> What about stupid random monad tricks?
13:34:05 <taruti> replicateM ntimes someIOAction ?
13:34:15 <taruti> replicateM_ is perhaps more common
13:34:18 <Lemmih> names <- replicateM x (newName "arg") <- this is commonly done in GHC.
13:34:44 <jleedev> interesting
13:35:22 <Cale> damn it darcs...
13:35:54 <Cale> I have a bunch of changes in things like RunPlugs which are specific to code.haskell.org
13:36:00 <monochrom> "damn, it darcs"?  "damn it, darcs"?
13:36:16 <Cale> But they're next to changes which are not specific to code.haskell.org
13:36:18 <dolio> Is darcs a verb now?
13:36:35 <Cale> and so darcs wants to glom those patches together...
13:36:47 <oerjan> Is, darcs a verb now?
13:36:48 <olsner> oh, there's a replicateM?
13:36:56 <monochrom> Newbie: "I can't get this code to compile in hugs"  Guru: "Try ghc"  Newbie: "damn, it ghcs".
13:36:57 <Cale> sigh. I suppose it won't *hurt* anything to include the code.h.o changes. It's just ugly.
13:37:09 <olsner> I have a few sequence .: replicate I could replace, heh
13:37:56 <faxathisia> @let (..) = (.).(.)
13:37:56 <lambdabot>  Parse error
13:38:01 <faxathisia> @let (.:) = (.).(.)
13:38:01 <lambdabot> <local>:1:7:     Ambiguous type variable `f' in the constraint:       `Functo...
13:38:19 <hpaste>  bm3719 pasted "map (putStrLn . facList) nums?" at http://hpaste.org/5995
13:38:27 <monochrom> that is caused by monomorphism.
13:38:29 <ehird`> I wonder what a purely functional haskell wfw would look like.
13:38:31 <ehird`> (A: crazy)
13:38:36 <bm3719> can someone take a look at that hpaste and tell me why that line bombs?
13:39:02 <bm3719> can't figure why i can't do that last map
13:39:09 <faxathisia> maybe you need mapM?
13:39:10 <ehird`> @hoogle (a -> a -> b) -> a -> b
13:39:11 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
13:39:11 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
13:39:11 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:39:15 <monochrom> mapM_ (putStrLn . facList) nums
13:39:24 <ehird`> whoa, whoa, lambdabot fails
13:39:25 <monochrom> map doesn't do anything.
13:39:29 <ehird`> it will do a function in my last 'b'
13:39:29 <ehird`> :P
13:39:31 <ehird`> wait, no
13:39:33 <ehird`> it's just wrong,.
13:39:39 <faxathisia> seems pointless to have all this IO in such a program though
13:39:49 <jleedev> @src mapM_
13:39:49 <lambdabot> mapM_ f as = sequence_ (map f as)
13:39:53 <faxathisia> why don't you just write the functions and call them in ghci
13:39:54 <ehird`> @pl \f a -> f a a
13:39:55 <lambdabot> join
13:39:59 <ehird`> ohes.
13:40:02 <ehird`> @type join
13:40:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:40:14 <monochrom> Imperative programmer habit is intermix I/O with core algorithm.
13:40:20 <bm3719> well, i'm doing it under the conditions described in the tutorial
13:40:23 <jleedev> > join ["hello","world"]
13:40:24 <lambdabot>  "helloworld"
13:40:37 <faxathisia> lol
13:41:02 <ehird`> @pl \a b c d e f g h i j k l m n o p q r s t u v -> d e a f (b e e t h o v e n)
13:41:14 * ehird` kicks lambdabot 
13:41:14 <monochrom> The habit is so entrenched that even OOP tutorials have to remind you a thousand times "please don't ask user for input in your constructors!"
13:41:14 <lambdabot> ((const . (((const .) .) .)) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((const .) .) .) .) .) . (((((((const .) .) .) .)
13:41:14 <lambdabot> .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . ((((((((const .) .) .) .) .) .) .) .) . (. (((flip .) .) . (((flip .) .) .) . ((
13:41:14 <lambdabot> ((flip .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((flip .) .) . (flip .) . join)) . flip . (ap .) . ((flip .) .) . ((((.) .) .) .) . ((((.) .) .) .) . (
13:41:14 <lambdabot> (((.) .) .) .) . ((((.) .) .) .) . ((((.) .) .) .) . flip flip
13:41:16 <lambdabot> optimization suspended, use @pl-resume to continue.
13:41:17 <ehird`> holy
13:41:18 <ehird`> shit
13:41:21 <faxathisia> lol
13:41:28 <Vq^> haha :)
13:41:28 <bm3719> mapM prints
13:41:32 <bm3719> [(),(),()]
13:41:37 <ehird`> @type \a b c d e f g h i j k l m n o p q r s t u v -> d e a f (b e e t h o v e n)
13:41:39 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16 t17 t18 t19 t20 t21. t -> (t2 -> t2 -> t17 -> t5 -> t12 -> t19 -> t2 -> t11 -> t20) -> t1 -> (t2 -> t -> t3 -> t20 -> t21) -> t2 -> t3
13:41:39 <lambdabot> -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10 -> t11 -> t12 -> t13 -> t14 -> t15 -> t16 -> t17 -> t18 -> t19 -> t21
13:41:46 <ehird`> ...
13:41:46 <ehird`> wow.
13:41:59 <jleedev> bm3719: use mapM_
13:42:03 <ehird`> @djinn t -> (t2 -> t2 -> t17 -> t5 -> t12 -> t19 -> t2 -> t11 -> t20) -> t1 -> (t2 -> t -> t3 -> t20 -> t21) -> t2 -> t3 -> t4 -> t5 -> t6 -> t7 -> t8 -> t9 -> t10 -> t11 -> t12 -> t13 -> t14 -> t15 -> t16 -> t17 -> t18 -> t19 -> t21
13:42:03 <lambdabot> f a b _ c d e _ f _ _ _ _ _ g h _ _ _ _ i _ j =
13:42:03 <lambdabot>     c d a e (b d d i f h j d g)
13:42:07 <ehird`> darnit
13:42:08 <jleedev> it discards the ()
13:42:10 <ehird`> i hate you lambdabot
13:42:22 <monochrom> @botsnack
13:42:22 <lambdabot> :)
13:42:25 <bm3719> ooh :D
13:42:27 <monochrom> @slap ehird`
13:42:27 * lambdabot pulls ehird` through the Evil Mangler
13:42:34 <bm3719> thanks, that did the trick
13:42:40 <jleedev> @lambdabot--
13:42:40 <lambdabot> Unknown command, try @list
13:42:44 <olsner> heh, nice taunt
13:42:44 <monochrom> Think of it as me bribing lambdabot :)
13:42:56 * olsner once had to hack the mangler
13:42:59 <monochrom> lambdabot++
13:43:08 <monochrom> haha
13:43:10 <ehird`> @type \a b c d e f g h i j k l m n o p q r s t u v w x y z -> h e l l o w o r l d i a m a f u n c t i o n i w o n d e r w h a t i d o
13:43:12 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:43:19 <ehird`> FAILURE
13:43:19 <faxathisia> o_o
13:43:33 <monochrom> So, does that mean ehird` comes out with all his RET instructions modified to JMPs? :)
13:43:40 <olsner> I believe the proper form of the word is 'FAIL'
13:43:43 <faxathisia>     Probable cause: `h' is applied to too many arguments
13:43:43 <faxathisia>     In the expression:
13:43:44 <ehird`> monochrom: Does the mangler do that? Seriously?
13:43:54 <monochrom> IIRC that's its purpose.
13:44:32 <oerjan> ehird`: it cannot type because h occurs both at the front and inside it
13:44:40 <ehird`> @type L L L L L L L L L L L L L L L L L L L L L L L L L L where L = \a b c d e f g h i j k l m n o p q r s t u v w x y z r -> r (t h i s i s a f i x e d p o i n t c o m b i n a t o r)
13:44:41 <olsner> also, it removes all "call DUMMYFUNCTIONWHOSENAMEICANTRECALL" instructions, that are put in generated code for some obscure reason
13:44:42 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:44:42 <ehird`> oerjan: ah
13:44:48 <jleedev> @type \x -> x x
13:44:49 <lambdabot> Plugin `type' failed with: invalid ghci output: no type signature
13:44:57 <monochrom> In the old days ghc emitted C code (with tail recursion) and gave it to a C compiler.  Some tail recursions not compiled to jumps.  The mangler was there to fix them.
13:44:57 <ehird`> yes, true
13:44:58 <olsner> (at least, that was the specific part that broke for me)
13:45:04 <ehird`> monochrom: Right, ok.
13:45:17 <ehird`> Facade types that! .. or will, once it's finished being implemented.
13:45:30 <ehird`> Well, types it in a very dumb sense - the '(a = a -> b) -> b' sense.
13:45:53 <ehird`> Of course, this also means that everything in the lambda calculus types (as 'a = a -> a')
13:46:07 <ehird`> But at least I get the y combinator and 'xs = [xs]' (a = [a]) :P
13:46:40 <ehird`> \f -> (\x -> f (x x)) (\x -> f (x x)) :: (a -> a) -> a
13:46:41 <ehird`> where
13:46:44 <monochrom> Yeah, a=a->a was a big problem (now solved) in the early theoretical days.
13:46:56 <ehird`> \x -> f (x x) :: a = a -> b
13:46:57 <ehird`> err
13:46:58 <ehird`> or rather
13:47:00 <ehird`> b = b -> a
13:47:04 <ehird`> monochrom: A problem how?
13:47:06 <Cale> Don't ask me why the type module isn't reporting errors properly anymore. I have no idea.
13:47:15 <jleedev> @type fmap fix return
13:47:16 <Cale> Hmm, actually, perhaps I do.
13:47:17 <lambdabot> forall a. a -> a
13:47:37 <Cale> I have one idea anyway. If it doesn't work, then I don't know :)
13:47:42 <monochrom> If you try "'a' is a set, a->a is the set of all functions from a to a", you run into a paradox.
13:47:46 <unteraarsch> @pl
13:47:46 <lambdabot> (line 1, column 1):
13:47:46 <lambdabot> unexpected end of input
13:47:46 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:48:07 <ehird`> monochrom: But of course.
13:48:13 <ehird`> I never said that Facade's typesystem was useful. :-)
13:48:14 <monochrom> But they soon realized, "we don't need/want set, and we don't need the full set of functions anyway!"
13:48:16 <ehird`> Just fun to play around it.
13:48:16 <unteraarsch> @pl \a b c -> a c $ b c
13:48:16 <lambdabot> ap
13:48:41 <jleedev> @djinn (p->q->r) -> (p->q) -> (p->r)
13:48:41 <lambdabot> f a b c = a c (b c)
13:48:49 <ehird`> it lets you have all sorts of delicious types
13:48:57 <monochrom> They settled with "continuous functions", a superset of computable functions, but still much smaller than the full set of functions.  Then it works.
13:49:06 <ehird`> like (a = [(a -> b),(b = (b,a))])
13:50:03 <ehird`> xs = [((\x -> foo), foo)] where foo = (foo,xs)
13:50:16 <monochrom> Along the way they also decided: 'a' is better to be something more structured than a flat set.  They made 'a' a CPO.  That works with a->a being continuous functions.
13:51:26 <wli> DCPO?
13:51:50 * matthew-_ wishes his Tests.hs wouldn't take 10 mins to load into ghci
13:51:51 <monochrom> My CPO is likely your DCPO.
13:52:38 <monochrom> 10 minutes?!
13:52:50 <Cale> @type foobiebletch
13:52:52 <monochrom> How many gigabytes is your Tests.hs? :)
13:52:58 <lambdabot> Not in scope: `foobiebletch'
13:53:03 <Cale> Okay, good.
13:53:11 <monochrom> Cale: It is said that silence is the best insult. :)
13:53:32 <ehird`> @djinn a = a -> b
13:53:38 <lambdabot> Cannot parse command
13:53:39 <ehird`> ;)
13:54:03 <monochrom> djinn probably cannot deal with type equations
13:55:13 <ehird`> probably not.
13:55:14 <ehird`> but hey.
13:55:25 <ehird`> i hope to include a super-djinn in facade
13:55:26 <ehird`> :D
13:55:47 <ehird`> Fc> :d a => a -> b
13:55:50 <ehird`> \x -> x x
13:55:51 <ehird`> Fc>
13:56:18 <Saizan> what's facade?
13:56:38 <ehird`> Saizan: My silly language which looks kind of like Haskell on a bad day.
13:56:41 <ehird`> (It doesn't have layout.)
13:56:51 <ehird`> The only real interest is that its type system is.. liberal
13:57:34 <lenbust> what's a clean way to remove empty strings from a list of strings?
13:57:43 <Cale> lenbust: filter (not . null)
13:57:51 <lenbust> ah, cool
13:57:54 <lenbust> thanks
13:57:55 <ehird`> Hmm. Since all good language names are recursive acronyms, let's try this:
13:57:58 <Cale> No problem :)
13:58:14 <matthew-_> Oooo. Someone's been hacking: 'ghc-options: -O' is not needed. Cabal automatically adds the '-O' flag. Setting it yourself interferes with the --disable-optimization flag.
13:58:25 <ehird`> Facade Accidentally Crashes - Ahh, Deathly Eejit-typing
13:59:14 <jleedev> dirty way to fix line endings / trailing eol: unlines . map (filter (/='\r')) . lines
13:59:20 <matthew-_> ANNOUNCE! Sessions 2008 2 28 released! Interleaving is in! Break out the champagne! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sessions-2008.2.28
13:59:22 <lambdabot> http://tinyurl.com/2xqjow
13:59:50 <ehird`> ANNOUNCE! boom
13:59:57 <cjb> matthew-_: Got any documentation online?
14:00:08 <ehird`> oh, and I have decided to write the silliest module ever
14:00:17 <ehird`> it will transform Integer into a Peano type
14:00:22 <matthew-_> cjb: gimme 5 mins
14:00:28 <MyCatVerbs> ehird`: awwww.
14:00:32 <ehird`> I shall call it Data.Peano, informally - Data.Integer.Slow
14:00:38 <matthew-_> cjb: the problem is that haddock makes the biggest possible mess of big type sigs
14:00:39 <faxathisia> lol
14:00:43 <MyCatVerbs> ehird`: I was hoping you were going to write System.Python.Silly.Walk :(
14:00:50 <cjb> matthew-_: ah, ok
14:01:02 <ehird`> heh
14:01:58 <RayNbow> @djinn (a -> (b -> c)) -> (b -> (a -> c))
14:01:58 <lambdabot> f a b c = a c b
14:02:04 <Cale> http://www.basicinstructions.net/2008/02/how-to-develop-invention.html
14:02:07 <lambdabot> Title: Basic Instructions: How to Develop an Invention, http://tinyurl.com/yvrjm3
14:05:09 <ehird`> hm
14:05:16 <ehird`> @. pl djinn == hours of fun
14:05:16 <lambdabot> Cannot parse command
14:05:59 <matthew-_> cjb: haddock at http://wellquite.org/non-blog/sessions-browseable/doc/html/sessions/ but really just work through the Test file at http://wellquite.org/non-blog/sessions-browseable/Control/Concurrent/Session/Tests.hs
14:06:00 <lambdabot> http://tinyurl.com/2cfoxz
14:06:34 <TomMD> @users
14:06:34 <lambdabot> Maximum users seen in #haskell: 463, currently: 434 (93.7%), active: 17 (3.9%)
14:06:38 <glguy> hmm, would "upload" for the paste bin be useful?
14:06:47 <glguy> or would it encourage to large of pastes
14:06:53 <faxathisia> glguy: unicode would be nice..
14:07:03 <glguy> faxathisia: ok, done
14:07:41 <faxathisia> http://hpaste.org/5996
14:07:43 <ehird`> glguy: that was fsat.
14:07:54 <glguy> faxathisia: wrong pastebin
14:08:11 <faxathisia> is this some successor to hpaste?+
14:08:19 <ehird`> ADD ONE TO hpaste GIVING hpaste
14:08:34 <faxathisia> what is tha intercal?
14:08:51 <jleedev> PLEASE ABSTAIN FROM REINSTATING
14:11:09 <Saizan> glguy: a search feature, preferably fulltext, google is not enough sometimes
14:11:29 <glguy> Saizan: search is definitely on the todo
14:11:35 <glguy> I need to add support takusen
14:11:45 <glguy> for regexp callback
14:12:05 <glguy> and then get it accepted in a released version of takusen
14:12:09 <glguy> before it will go into hpaste
14:12:18 <glguy> I'm trying to avoid depending on darcs repos this time
14:13:56 <glguy> Saizan: simple search is implemented
14:13:59 <glguy> but not exposed
14:14:08 <sclv_> glguy: seen paste.pocoo.org? the expanding dhtml textarea is stupid cute. :-)
14:14:39 <ehird`> faxathisia: cobol
14:14:40 <glguy> sclv_: lol, absolutely not
14:14:55 <ehird`> sclv_: i did that once
14:15:04 <ehird`> it is hell to get working cross-platformy
14:15:29 <Saizan> glguy: ah, you mean building it only against released libraries?
14:15:30 <ehird`> oh
14:15:30 <ehird`> THAT
14:15:32 <ehird`> I made it far better
14:15:37 <ehird`> I made it so that once you got to the bottom
14:15:40 <ehird`> it expanded one line automatically
14:15:41 <glguy> Saizan: yeah, stuff on hackage
14:15:45 <ehird`> and vice-versa for removing lines
14:16:18 <sclv_> glguy: and that, buddy, is why python and ruby are more popular. sigh.
14:16:26 <glguy> sclv_: qq
14:16:26 <Saizan> glguy: and not with happs, i deduce?
14:16:32 <glguy> Saizan: correct
14:17:06 <Saizan> glguy: do you plan on importing the pastes, though?
14:17:42 <ehird`> how do I tell ghc to let me end names of stuff with #?
14:17:50 <sclv_> magicHash
14:18:00 <Saizan> MagicHash
14:18:06 <glguy> Saizan: not sure what to do about that
14:18:12 <glguy> if the urls will stay the same or what
14:18:35 <Saizan> it will be nice to keep them online however
14:18:44 <ehird`> anyways, my Super Duper Pastebin will be awesomest
14:19:00 <ehird`> it will support about 3457848935783495 languages, including Brainfuck, Underload, Malbolge and similar
14:19:04 <ehird`> actually, mainly those letter ones
14:19:12 <TomMD> ?type ehird`
14:19:13 <ehird`> I expect it will be first used for the ESO pastebin.
14:19:13 <lambdabot> parse error (possibly incorrect indentation)
14:19:21 <ehird`> TomMD: c -> r -> a -> z -> y
14:19:33 <ehird`> oh, and it will have other crazy features.
14:19:34 <ehird`> and be awesome.
14:19:35 <TomMD> Thats more along the lines of what I was expecting.
14:19:43 <monochrom> I think it will be even cooler if you said it will support about 3457848935783495.14159 languages.
14:19:50 <TomMD> And zero bugs in version 0.0.1?
14:19:57 <rnorris> ... so i asked this question the other day but i wasn't able to understand the answers. i thought i would try again now that i'm more alert. Does anyone know how i can change this declaration in order to make "length blah" not blow up with an ambiguous type error? Or maybe I need to add some type information when i invoke "length"
14:19:58 <rnorris> blah :: forall a m. (Monad m) => [(String, a -> m a)]
14:19:58 <rnorris> blah = [("foo", return)]
14:20:01 <Saizan> glguy: so, what do you use for the web part? Network.CGI?
14:20:07 <glguy> that and fastcgi
14:20:23 <glguy> + a url dispatch module that is included in hpaste
14:21:26 <ehird`> *Data.Peano> Negative (Succ One) + Negative (Succ (Succ One))
14:21:26 <ehird`> Negative (Succ (Succ (Succ (Succ One))))
14:21:28 <ehird`> quick turnout.
14:21:52 <ehird`> glguy: pretty much me too...
14:22:02 <ehird`> i do my haskell web dev with Network.FastCGI/Network.SCGI + a dispatcher
14:22:05 <ehird`> + Text.XHtml
14:22:19 <glguy> ehird`: that sounds about right
14:22:22 <jleedev> is there anything like cherrypy?
14:22:25 <ehird`> but i'm considering making a little abstraction layer over FastCGI/SCGI, and adding some more stuff, and calling it Network.CoreWeb or something
14:22:45 <ehird`> jleedev: not really, there's HApps which is on the bloated side, and Network.*CGI which are lower level
14:22:52 <ehird`> Network.CoreWeb will probably be a cherrypy analogy
14:23:06 <glguy> ehird`: the hpaste code doesn't really deal with anything CGI, that's mostly hidden under Utils.RequestDispatch
14:23:10 <Saizan> ah, right CGI works with the "one-script-per-url" style
14:23:24 <glguy> hpaste: is one-script-for-all-urls
14:23:52 <glguy> http://example.com/cgi-bin/hpaste.fcgi/this/that/theother
14:23:57 <ehird`> glguy: unfortunately Network.FastCGI suffers from that too
14:24:00 <glguy> (planning to use some mod_rewrite or something)
14:24:12 <glguy> ehird`: from what?
14:24:14 <ehird`> glguy: please don't use apache with fcgi
14:24:17 <ehird`> it will only ever use one process
14:24:23 <ehird`> because apache's model does not fit with fcgis
14:24:26 <ehird`> it is crappy
14:24:28 <ehird`> :)
14:24:57 <glguy> ehird`: it seems to use both processors nicely enough
14:25:02 <monochrom> rnorris: Yes, need some extra type signature if you want standalone length blah.  But I bet you shouldn't worry about it.  When you use it for real in a real context, most likely it doesn't matter.
14:25:10 <glguy> and the fastcgi breaks out into many threads
14:25:14 <ehird`> glguy: lighttpd+fcgi is a good solution
14:25:23 <ehird`> or nginx+fcgi, but that might be a bit too experimental for your tastes
14:25:31 <glguy> there was a recent benchmark I read where this isn't really an issue anymore
14:25:54 <rnorris> monochrom: ok, thanks. i'll see if it works magically when it's all hooked up.
14:26:10 <glguy> http://mult.ifario.us/p/wiring-haskell-into-a-fastcgi-web-server
14:26:10 <lambdabot> Title: wiring-haskell-into-a-fastcgi-web-server
14:26:23 <glguy> apache is supposedly faster with haskell's forkio than using lighttpd
14:26:35 <glguy> err, forkOS?
14:26:40 <matthew-_> oh ffs. haddock is a disaster
14:26:51 <ehird`> even so, glguy -- I would not reccomend using fastcgi with apache
14:27:00 <ehird`> Actually, I wouldn't reccommend using Apache, for any reason. :-)
14:27:02 <glguy> anyway, I'm not concerned with handling 6000 requests a minute
14:27:05 <glguy> so the point is moot
14:28:03 <glguy> but I will give lighttpd a glance
14:29:42 <matthew-_> lighttpd is ok, though I find the documentation sorely lacking
14:30:33 <ehird`> > Negative (Succ One) * Negative (Succ (Succ One))
14:30:34 <ehird`> Zero
14:30:34 <lambdabot>   Not in scope: data constructor `One'
14:30:35 <ehird`> DO NOT WANT
14:30:48 <faxathisia> ?
14:32:03 <ehird`>     n - m = n + (-m)
14:32:03 <ehird`> i am such a lazy bum.
14:32:30 <faxathisia> same big O complexity
14:32:57 <faxathisia> if you were really lazy you could just compile Coqs integer lib to haskell
14:33:33 <faxathisia> although it uses binary not peano...
14:33:36 <awesame> I want there to be a function in the prelude, along the lines of zip, that groups a lists members into tuples of a given length
14:33:41 <awesame> is there such a function?
14:33:45 <matthew-_> peano should really be avoided
14:33:52 <faxathisia> awesame, it's impossible
14:34:17 <faxathisia> awesame, You could write several such functions though
14:34:17 <ehird`> matthew-_: bah! :(
14:34:19 <ehird`> this is fun
14:34:22 <awesame> eg, tuplize 2 [1,2,3,4] yields [(1,2), (3,4)]
14:34:24 <ehird`> hehe
14:34:25 <awesame> oh, right
14:34:26 <ehird`> since i'm redefining Integer
14:34:29 <ehird`> fromInteger = id
14:34:29 <awesame> because tuples are types
14:34:31 <faxathisia> I don't thing peano should be avoided.
14:34:33 <awesame> well, lists then
14:34:41 <awesame> [[1,2],[3,4]]
14:34:48 <Saizan> is there anything to handle sessions that integrates with Network.CGI?
14:34:49 <ehird`> oh damn
14:34:51 <ehird`> they foiled me
14:34:52 <faxathisia> yes you could write that
14:34:54 <ehird`> with GHC.Num.Integer
14:35:09 <ehird`> hey, can i make GHC think GHC.Num.Integer is mine?
14:35:45 <faxathisia> tuplize n list | length list < n = return list | otherwise = take n list : tuplize n (drop n list) -- or something ..
14:35:55 <awesame> realistically, tuplize2 through tuplize9, like with the multiple versions of a bunch of other functions, would cover most useful cases
14:36:25 <faxathisia> > let tuplize n list | length list < n = return list | otherwise = take n list : tuplize n (drop n list) in tuplize 3 "foobar"
14:36:26 <lambdabot>  ["foo","bar",""]
14:36:41 <faxathisia> there will be a shorter way...
14:36:47 <ehird`> awesame: do it through a class
14:36:59 <ehird`> class Tuplizable a where tuplize :: a -> b
14:37:00 <faxathisia> ehird: Yuck ..
14:37:07 <ehird`> instance Tuplizable (a,b) where tuplize (a,b) = ...
14:37:12 <ehird`> instance Tuplizable (a,b,c) where tuplize (a,b,c) = ...
14:37:18 <awesame> it's already polymorphic over [t]
14:37:31 <awesame> oh I see, to get real tuples
14:37:32 <ehird`> awesame: functions named foo1,foo2, etc are ugly
14:37:33 <ehird`> just IMO
14:37:33 <ehird`> :P
14:38:19 <faxathisia> what you really want here is types depending on values...
14:38:27 <faxathisia> but you can't do that
14:38:33 <Saizan> ehird`: a -> b!?
14:38:43 <ehird`> Saizan: it was an example.
14:38:45 <faxathisia> so you make a value into a type .. like numbers in the type system
14:38:49 <ehird`> awesame: what is the type of tuplize2
14:38:53 <faxathisia> and fake it with typeclasses..
14:39:11 <faxathisia> A bit bad a think to go that route in this case though
14:39:26 <awesame> ehird`: [t] -> [(t,t)]
14:39:53 <ehird`> class Tuplizable a where tuplize :: [b] -> [a]
14:40:01 <ehird`> instance Tuplizable (a,a) where tuplize = ...
14:40:02 <awesame> or, if you do it with lists, tuplize would be a Int -> [t] -> [[t]]
14:40:03 <ehird`> err
14:40:06 <ehird`> instance Tuplizable (a,a) where tuplize xs = ...
14:40:22 <ehird`> hm
14:41:12 <awesame> hm, I'm not sure I follow, ehird`
14:41:36 <ehird`> awesame: give me the types of tuplize2 and tuplize3
14:41:42 <awesame> [(a,a)] is the type of the return value, not of the parameter
14:41:57 <awesame> tuplize2 :: [t] -> [(t,t)]
14:42:04 <awesame> tuplize3 :: [t] -> [(t,t,t)]
14:42:58 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/5997
14:43:02 <ehird`> i think that's right
14:44:33 <Saizan> with a functional dependency, at least
14:44:57 <glguy> ehird`: using lighttpd doesn't seem to improve performance, but is it just better at using fewer resources?
14:45:00 <awesame> ah, I see what you're doing
14:45:26 <awesame> I like that better than numbered functions, anyway
14:45:51 <awesame> so to get the right version of tuplize, you just use it in a context where the return type is clear, right?
14:46:16 <awesame> as with read("1")::Int
14:46:19 <Saizan> yeah
14:46:56 <Lord_Illidan> Hi guys!
14:46:59 <hpaste>  Lord Illidan pasted "GetWord" at http://hpaste.org/5998
14:47:10 <glguy> ehird`: oh, nvm , seemsfaster :)
14:47:59 <Lord_Illidan> I'd like to know what you think of this code : http://hpaste.org/5998 .  It's supposed to get a string and return a tuple containing the first word and the rest of the sentence
14:48:47 <faxathisia> Lord_Illidan: perhaps you could use break?
14:49:11 <faxathisia> > break (==' ') "Like this maybe?"
14:49:12 <lambdabot>  ("Like"," this maybe?")
14:49:17 <Lord_Illidan> I know it seems v. inefficient (2 recursions :S)
14:49:31 <Lord_Illidan> faxathisia, I don't think I can
14:49:41 <TSC> Lord_Illidan: You might like to look up "dropWhile" too
14:49:53 <ehird`> glguy: and is saner
14:49:54 <ehird`> internally
14:50:03 <TSC> > dropWhile isSpace "    abc    "
14:50:03 <lambdabot>  "abc    "
14:50:25 <Lord_Illidan> again..I can't use many inbuilt functions :S
14:50:39 <TSC> You could implement dropWhile yourself (:
14:50:40 <ehird`> Lord_Illidan: homework?
14:50:59 <bparkis> [16:01]  <wli> bparkis: Not so. It's syntactically desugared into case statements
14:51:09 <bparkis> yes I know, I am talking about how it might be usefully extended
14:51:23 <Lord_Illidan> ehird`, I'm just trying to find an efficient way of doing this without using many inbuilt statements
14:51:31 <ehird`> Lord_Illidan: Suuuuure
14:52:17 <faxathisia> Lord_Illidan: You can ask about homework here..
14:52:18 <Saizan> Lord_Illidan: simple thing, isSpace x == True is the same as isSpace x
14:52:23 <bparkis> that in essence it is saying that if a logical predicate is true of a value, then return something.  and this logical predicate could be, in a more general language, of arbitrary complexity, which might require run-time prolog-style search to determine
14:52:52 <ehird`> faxathisia: Sure but he's just asking us to do it, basically directly
14:52:59 <faxathisia> bparkis: Not sure why you are fixating on Prolog?
14:53:01 <bparkis> or even not runtime search, but determined beforehand
14:53:06 <Lord_Illidan> ehird`, No, I already did it
14:53:23 <Lord_Illidan> the code is there.
14:53:31 <bparkis> only because prolog is a popular language that uses a general logical inference engine at runtime
14:53:42 <bm3719>  /quit
14:54:02 <dons> prolog is popular? :)
14:54:06 <Lord_Illidan> it works, it runs..but I'd like to know if it can run faster, without recursing twice in the same sentence
14:54:10 <ehird`> dons: Moreso than mercury
14:54:16 <dons> true enough
14:54:20 <ehird`> Lord_Illidan: And we told you how.
14:54:20 <TomMD> Mercury is a language?
14:54:24 <ehird`> TomMD: Yes.
14:54:33 <TomMD> @google mercury programming language
14:54:39 <lambdabot> http://www.cs.mu.oz.au/mercury/
14:54:39 <lambdabot> Title: The Mercury Project: Introduction
14:54:43 <Lord_Illidan> ehird`, yes, I guess so. Thanks!
14:54:47 <bparkis> i was thinking about this in algebra class where he is defining a homomorphism based only on multiplication, and then he shows that it is a ring homomorphism by rewriting addition as multiplication in his particular setting
14:54:53 <ehird`> I love urls like that
14:55:07 <bparkis> so he is using 1 pattern match to do the work of 2
14:55:13 <ehird`> ca.nt.ha.ve.do.ma.in.wi.th.ov.er.tw.o.ch.ar.ss
14:55:40 <bparkis> and if your programming language knew to rewrite, say, a/b + c/d as (ad + bc) / bd, then it would work there
14:55:53 <ehird`> wow mercury can compile to erlang
14:55:59 <jacobian_> the ring tactic in coq can do that.
14:56:17 <ehird`> 	Remove support for Unicode characters in string literals
14:56:17 <ehird`> This feature has been removed because of concerns that it might lead users to believe that Mercury offers full Unicode support, which is not the case.
14:56:23 <ehird`> couldn't they have spent that time implementing unicode?
14:56:29 <bparkis> ok jacobian_ i don't know much about coq, but i'm specifically referring to this in relation to the pattern matching facility of a haskell-like language
14:56:41 <jacobian_> not at runtime though, just to find an inhabitant of a type.
14:57:00 <bparkis> yes that one wouldn't have to be at runtime, but others might potentially
14:57:07 <jacobian_> you mean pattern matching modulo an equivalence relation?
14:57:29 <faxathisia> maybe this has to do with quotient types or setoids...
14:57:45 <bparkis> sort of, I mean that pattern matching basically tests a predicate on the argument and then evalutes the right hand side if the predicate matches
14:57:56 <bparkis> and that in haskell these predicates are relatively simple, but they could in theory be more complicated
14:58:06 * liyang just watched Pirates of Silicon Valley. 
14:58:09 <liyang> (lol)
14:58:16 <ehird`> bparkis: guards
14:58:49 <faxathisia> bparkis: Have you seen pattern matching as sugar for eliminators?
14:59:07 <bparkis> no I haven't faxathisia i'll look it up
14:59:08 <faxathisia> (I think there's a name for eliminators.. it's not catamorphism though..)
14:59:09 <Lord_Illidan> so the dropWhile : dropWhile ('w'>) "hello, world" - returns world
14:59:20 <faxathisia> bparkis: Well the idea is this..
14:59:22 <faxathisia> :t maybe
14:59:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:59:23 <faxathisia> :t either
14:59:25 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:59:44 <faxathisia> bparkis: You could turn any (complete) pattern match, into a call to one of those functions
14:59:54 <Lord_Illidan> :t dropWhile
14:59:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:59:58 <faxathisia> bparkis: and a unique one of these eliminators exist for any data type
15:00:23 <faxathisia> bparkis: I've got lisp code demonstrating this but I think it's kind of tangential to what your saying, not sure
15:00:29 <bparkis> i am not sure if what you are describing is general enough to be what I mean, but just to clarify I am not only talking about pattern matching on data constructors
15:01:04 <bparkis> I am talking about pattern matching by arbitrary functions, like f (g x) = z where g is not necessarily a constructor, but could be any function
15:01:04 <faxathisia> bparkis: Yes, I'm sort of wondering if you could generalize this idea to explain what you were discussing
15:01:22 <jacobian_> pattern matching on functions is not decidable
15:01:25 <faxathisia> You want to find inverses of arbitrary functions :S
15:01:34 <faxathisia> I don't think a computer can do it :P
15:01:47 <bparkis> well, not in general, but in many cases it could
15:02:00 <ehird`> Eq (a -> b)!
15:02:06 <liyang> it's possible if you could prove them equal.
15:02:08 <jacobian_> higher order pattern unification is decidable
15:02:09 <faxathisia> bparkis, You used any invertible programming languages?
15:02:24 <bparkis> never faxathisia
15:02:49 <faxathisia> jacobian_: Really? Not that it always terminates on success and often doesn't terminate on failure?
15:03:09 <faxathisia> bparkis, If you get bored .. http://www.iis.sinica.edu.tw/~scm/2007/inv/ is
15:03:10 <lambdabot> Title: Inv | Niche Computing Science
15:03:45 <ehird`> f == g = all (\x -> f x == g x) everything
15:03:47 <faxathisia> there are some .. especially lisps but I guess you could take ideas from invertible languages to classify which functions are trivially invertible
15:03:57 <ehird`> give it an infinity machine and you're good to go
15:04:28 <jacobian_> http://www.emis.de/journals/DMTCS/volumes/abstracts/pspapers/dm040102.ps
15:04:30 <lambdabot> http://tinyurl.com/3ympg4
15:04:37 <bparkis> they don't necessarily have to be invertible function per se, i mean they could have an inverse in terms of level sets
15:05:00 <bparkis> although then you raise the well definedness problem
15:05:20 <jacobian_> faxathisia: Higher order pattern unification is a fragment that is now known to be decidable I believe.
15:05:32 <faxathisia> cool, thanks jacobian, this looks interesting
15:06:08 <ehird`> russel xss = filter (\xs -> not (xs `elem` xs)) xss
15:06:26 <Pseudonym> :t filter (\xs -> not (xs `elem` xs))
15:06:27 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
15:06:27 <lambdabot>       Expected type: [a]
15:06:27 <lambdabot>       Inferred type: a
15:06:56 <ehird`> russel :: [a = [a]] -> [a = [a]]
15:07:18 <Lord_Illidan> I can't understand how dropWhile works with strings
15:07:38 <ehird`> Lord_Illidan: type String = [Char]
15:07:44 <monochrom> Do you understand how dropWhile works with lists?
15:07:50 <Lord_Illidan> yes, of integers
15:07:58 <monochrom> just integers?
15:08:04 <Lord_Illidan> for instance, dropWhile ('w'>) "hello, world"
15:08:28 <ehird`> char has Ord
15:08:30 <Lord_Illidan> that works well, but dropWhile ('w'<) "hello, world" returns the whole string
15:08:38 <ehird`> its ordered by unicode code points
15:08:42 <TSC> Lord_Illidan: In the second case, it drops nothing
15:08:45 <monochrom> Do you understand: dropWhile ('w' >) ['h', 'e', 'l', 'l', 'o', ... ] ?
15:08:47 <TSC> Similar to:
15:08:54 <TSC> > dropWhile (>10) [1..5]
15:08:55 <lambdabot>  [1,2,3,4,5]
15:10:13 <Lord_Illidan> ok
15:10:24 <Lord_Illidan>  dropWhile (>'w') "hello, wzorld"
15:10:39 <monochrom> > (takeWhile ('w' < ) "hello, world", dropWhile ('w' < ) "hello, world")
15:10:39 <lambdabot>  ("","hello, world")
15:11:39 <monochrom> If you understand takeWhile, then you understand dropWhile.
15:12:28 <Lord_Illidan> so when you have 'w' < what is it doing exactly?
15:13:01 <monochrom> Is 'w'<'h' true or false?
15:13:02 <ehird`>  Lord_Illidan do you know unicode
15:13:15 <ehird`> if you know that, then you know it is ordered
15:13:16 <Lord_Illidan> monochrom, ah...
15:13:19 <Lord_Illidan> yes
15:13:19 <ehird`> a,b,c,d,e,f,g,h,...
15:13:29 <ehird`> with tons of stuff before and after, obviously
15:13:34 <ehird`> it just compares where it is in unicode
15:13:39 <ehird`> because each unicode char has a 'code point'
15:13:40 <ehird`> just a number
15:13:44 <ehird`> its index in the unicode world.
15:13:55 <ehird`> in haskell characters are just glorified integers of those code points.
15:13:59 <ehird`> > ord 'w'
15:14:00 <lambdabot>  119
15:14:01 <ehird`> > ord 'h'
15:14:01 <lambdabot>  104
15:14:14 <ehird`> if (ord a) < (ord b), a < b
15:14:31 <faxathisia> Gamma |- (ord a) < (ord b)
15:14:33 <faxathisia> ---------------------
15:14:39 <faxathisia>      Gamma |- a < b
15:14:44 <ehird`> lmao
15:14:54 <Lord_Illidan> makes sense :D
15:15:19 <Lord_Illidan> > takeWhile ('w' <) "hello world"
15:15:19 <lambdabot>  ""
15:15:26 <Lord_Illidan> > takeWhile ('w' <) "helloz world"
15:15:27 <lambdabot>  ""
15:15:50 <ehird`>  > takeWhile ('w' <) "zzzhello world"
15:15:55 <faxathisia> > takeWhile ('w' >) "helloz world"
15:15:56 <lambdabot>  "hello"
15:15:56 <Lord_Illidan> zzz
15:15:58 <ehird`> > takeWhile ('w' <) "zzzhello world"
15:15:59 <lambdabot>  "zzz"
15:16:00 <faxathisia> > takeWhile ('w' >) "hello world"
15:16:01 <lambdabot>  "hello "
15:16:03 <ehird`> you see? :)
15:16:14 <ehird`> just be lucky that unicode has the latin alphabet in order.
15:16:17 <Lord_Illidan> Yes, slowly, I am seeing the light, thanks
15:16:19 <Lord_Illidan> :S
15:16:24 <ehird`> Lord_Illidan: This will help.
15:16:33 <ehird`> (chr (ord X)) == X
15:16:38 <ehird`> chr :: Int -> Char
15:16:43 <ehird`> ord :: Char -> Int
15:16:45 <ehird`> now,
15:16:51 <ehird`> any comparison on (ord X) is valid for X
15:16:57 <ehird`> and with the same result.
15:17:07 <ehird`> Lord_Illidan: Just pretend characters are integers. They are; they're just called Char.
15:17:16 <Lord_Illidan> I know, I think I get the gist
15:17:17 <faxathisia> @src Char
15:17:17 <lambdabot> data Char = C# Char#
15:17:24 <ehird`> DON'T LOOK AT THAT
15:17:25 <ehird`> :(
15:17:28 <ehird`> that's internal
15:17:29 <ehird`> ;)
15:17:32 <faxathisia> just checking..
15:17:37 <monochrom> @src Char#
15:17:37 <lambdabot> Source not found. Do you think like you type?
15:17:47 <Lord_Illidan> > dropWhile (\x -> 6*x < 100) [1..20]
15:17:48 <lambdabot>  [17,18,19,20]
15:17:57 <monochrom> Haskell uses C# internally...
15:18:06 <Lord_Illidan> oh my god
15:18:08 <ehird`> tee hee
15:18:24 <ehird`> well, spj is at Microsoft'n'cuddly
15:18:35 <monochrom> @src Float
15:18:35 <lambdabot> data Float = F# Float#
15:18:40 <monochrom> And F#.
15:18:56 <monochrom> @src Integer
15:18:56 <lambdabot> data Integer = S# Int#
15:18:56 <lambdabot>              | J# Int# ByteArray#
15:19:00 <monochrom> And J#.
15:19:04 <Lord_Illidan> and S#
15:19:05 <faxathisia> J# lol
15:19:10 <monochrom> J# is a java clone.
15:20:07 <ehird`> data Integer# = One | Succ Integer# deriving (Eq, Show)
15:20:07 <ehird`> data Integer = Positive Integer#
15:20:07 <ehird`>              | Negative Integer#
15:20:07 <ehird`>              | Zero
15:20:07 <ehird`>     deriving (Eq, Show)
15:20:08 <monochrom> S# is Spec# but they shortened it.
15:20:10 <ehird`> (from Data.Peano)
15:20:27 <faxathisia> O_o
15:20:31 <faxathisia> How does that work?
15:20:42 <ehird`> faxathisia: what do you mean?
15:20:44 <monochrom> deriving Show is a bad idea.
15:20:46 <faxathisia> oh nevermind
15:20:50 <ehird`> monochrom: Yes, it will be replaced soon.
15:20:54 <cin> > (return (read "foo" :: Int)) `Control.Exception.catch` (\e -> return 0)
15:20:55 <lambdabot>   Not in scope: `Control.Exception.catch'
15:20:59 <Lord_Illidan> > dropWhile (\x -> 6*x < 100) [1..]
15:21:00 <lambdabot>  [17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,...
15:21:02 <cin> > (return (read "foo" :: Int)) `C.catch` (\e -> return 0)
15:21:03 <lambdabot>   Not in scope: `C.catch'
15:21:05 <ehird`> With something which emits properly base-10'd integers.
15:21:14 <monochrom> yeah, that's better
15:21:26 <ehird`> However, first I want to figure out how to get GHC to pretend all Integers are my Integer
15:21:36 <ehird`> It uses tricksy GHC.Base.Integer or something right now
15:21:40 <monochrom> That is deep magic.
15:21:45 <ehird`> GHC.Num.Integer
15:21:51 <cin> why doesn't Control.Exception.catch catch the read exception in this?: (return (read "foo" :: Int)) `Control.Exception.catch` (\e -> return 0)
15:21:53 <ehird`> monochrom: Yes, but i want my haskell programs to be slow.
15:22:00 <cin> *** Exception: Prelude.read: no parse
15:22:51 <monochrom> Laziness.
15:23:06 <ehird`> monochrom: Tee hee.
15:23:10 <ehird`> But is what I said, actually possible?
15:23:22 <faxathisia> GHC source is available
15:23:30 <monochrom> Control.Exception.evalute (read "foo" :: Int) `Control.Exception.catch` (\e -> return 0)   this may work
15:23:42 <monochrom> What you said is possible, just a lot of work.
15:24:03 <ehird`> monochrom: Well, how! :P
15:24:04 <ehird`> Err
15:24:06 <ehird`> without modding gh
15:24:07 <ehird`> c
15:24:29 <monochrom> -XNoImplicitPrelude  may be relevant
15:24:52 <cin> @src Control.Exception.catch
15:24:52 <lambdabot> Source not found. Do you think like you type?
15:24:56 <ehird`> monochrom: Eh, I'm already hiding Integer.
15:25:08 <ehird`> But it just goes ahead and qualifies its Integer stuff.
15:25:18 <monochrom> Yes, that is normal and expected.
15:25:43 <ehird`> Exactly. I want to completely hijack Integer.
15:25:48 <monochrom> s/evalute/evaluate/
15:26:28 <Lord_Illidan> well, my new getWord is simple enough now, thanks! getWord2 input = (break (' '==) . skipWhiteSpace) input
15:26:58 <ehird`> woot
15:27:00 <Lord_Illidan> I take it that break works on similar principles to takeWhile?
15:27:00 <ehird`> I now have Num Integer
15:27:06 <ehird`> and am going to do Integral now
15:27:18 <Lord_Illidan> > break(5>) [1..10]
15:27:18 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
15:27:27 <Lord_Illidan> > break(5<) [1..10]
15:27:27 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
15:28:00 <monochrom> Yes, break and takeWhile, dropWhile are on similar principles.
15:28:06 <monochrom> There is also span.
15:29:14 <Lord_Illidan> so break takes every item in the list and compares it to the predicate?
15:29:28 <ehird`> http://www.shlomifish.org/humour/fortunes/shlomif-fav   grep for '<integral>  Haskell on Highways'
15:29:34 <smarmy> lazily up until the predicate holds
15:29:38 <ehird`>    <Yaakov>  Ada on Armored Transports
15:30:15 <Lord_Illidan> > break(5<) [10..17]
15:30:16 <lambdabot>  ([],[10,11,12,13,14,15,16,17])
15:30:25 <Lord_Illidan> > break(5>) [10..17]
15:30:26 <lambdabot>  ([10,11,12,13,14,15,16,17],[])
15:30:53 <smarmy> > break (5 >) [3,4,5,6,7,3,4,5,6,7]
15:30:53 <lambdabot>  ([],[3,4,5,6,7,3,4,5,6,7])
15:30:59 <monochrom> Usually not every item.
15:31:07 <faxathisia> I prefer haskell on hydralics
15:31:36 <Lord_Illidan> > break (5 >) [10 4 21 214 31]
15:31:36 <lambdabot>        add an instance declaration for (Num (t -> t1 -> t2 -> t3 -> t4))
15:31:41 <monochrom> The first time the predicate is true, that's it, no more testing done.
15:31:47 <Lord_Illidan> > break (5 >) [10, 4, 21, 214, 31]
15:31:48 <lambdabot>  ([10],[4,21,214,31])
15:31:58 <Lord_Illidan> monochrom, that's what I am thinking too
15:32:10 <smarmy> @src break
15:32:10 <lambdabot> break p =  span (not . p)
15:32:15 <smarmy> @src span
15:32:15 <lambdabot> Source not found. It can only be attributed to human error.
15:32:32 <smarmy> hmmm... i'm a human error
15:32:38 <dolio> span p l = (takeWhile p l, dropWhile p l)
15:32:53 <Lord_Illidan> span (5 >) [10,4,121,214]
15:33:00 <Lord_Illidan> > span (5 >) [10,4,121,214]
15:33:00 <lambdabot>  ([],[10,4,121,214])
15:33:07 <Lord_Illidan> > span (5 <) [10,4,121,214]
15:33:08 <lambdabot>  ([10],[4,121,214])
15:33:25 <monochrom> For span, the first time the predicate is true, that's it.
15:33:45 <monochrom> err, I'm wrong.
15:33:54 <monochrom> For span, the first time the predicate is false, that's it.
15:34:04 <Lord_Illidan> yes, it exits immediately, I think?
15:34:15 <Lord_Illidan> > span (5 <) [10,4,121,214]
15:34:16 <lambdabot>  ([10],[4,121,214])
15:34:21 <monochrom> Yes, that explains span (5 <) [10, etc]
15:34:27 <smarmy> > span isJust [Just 2, Just 3, Nothing, Just 6]
15:34:28 <lambdabot>  ([Just 2,Just 3],[Nothing,Just 6])
15:34:45 <Lord_Illidan> :t isJust
15:34:47 <lambdabot> forall a. Maybe a -> Bool
15:35:09 <smarmy> > partition isJust [Just 2, Just 3, Nothing, Just 6]
15:35:10 <lambdabot>  ([Just 2,Just 3,Just 6],[Nothing])
15:35:11 <monochrom> I mean: that explains span (5 >) [10, etc]
15:35:13 <Lord_Illidan> lol, that sounds rather funny to my sleepy mind :D
15:36:00 <smarmy> neat stuff
15:36:57 <monochrom> > partition even [0..]
15:36:58 <lambdabot>  ([0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:37:17 <monochrom> It never gets a chance to display the odd ones :)
15:37:40 <Lord_Illidan> > partition even [0..20]
15:37:40 <lambdabot>  ([0,2,4,6,8,10,12,14,16,18,20],[1,3,5,7,9,11,13,15,17,19])
15:37:49 <xerox> Anybody knows where to find that Coq example code generating code for solving the Hanoi's problem? I think it was somebody in here to write it.
15:37:50 <Lord_Illidan> nice one
15:37:55 <monochrom> But it's ready to, as soon as you don't insist on displaying all even ones first.
15:38:12 <Saizan> xerox: it was sorear
15:38:13 <Lord_Illidan> partition (' '==) "hello world"
15:38:17 <Lord_Illidan> > partition (' '==) "hello world"
15:38:18 <lambdabot>  (" ","helloworld")
15:38:18 <monochrom> > let (x,y) = partition even [0..] in (take 3 x, y)
15:38:19 <lambdabot>  ([0,2,4],[1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47...
15:38:29 <xerox> Saizan: do you know where to find it?
15:38:34 <dolio> @let swap (a,b) = (b,a)
15:38:35 <lambdabot> Defined.
15:38:53 <Lord_Illidan> does lambdabot do something to avoid being swamped by infinite lists?
15:39:21 <Saizan> xerox: no :\
15:39:27 <xerox> :-(
15:39:32 <dolio> It does 'take n' on the output string.
15:39:49 <Lord_Illidan> but does it compute it internally?
15:39:54 <monochrom> Yes. Several measures.  One is: it really does: take 100 (show (your expression)).  Of course not exactly 100, some other constant.
15:39:55 <dolio> Where n fits on the screen.
15:40:08 <faxathisia> Lord_Illidan: How does haskell evaluate programs?
15:40:22 <monochrom> Another measure is it aborts after a fixed number of seconds.
15:40:47 <faxathisia> Lord_Illidan: I think the important thing to note is it makes a graph out of the expressions.. and then it pulls (forcing computation) on the bits which it needs right now
15:40:53 <Saizan> xerox: maybe this? http://members.cox.net/stefanor/hanoi.v
15:41:07 <xerox> Great, thanks Saizan.
15:41:32 <Lord_Illidan> faxathisia, I heard that already
15:41:44 <Lord_Illidan> faxathisia, so it makes recursion faster?
15:41:53 <faxathisia> faster than what?
15:42:00 <Saizan> xerox: thanks to logs and grep :)
15:42:59 <Toxaris> Lord_Illidan: the point is, if something is not needed for the output, it is not computed. so (take 100 $ show $ infiniteList) will only compute a prefix of the list, enough to show 100 characters.
15:43:04 <ehird`> any Network.IRC examples anywhere?
15:43:04 <Cale> Lord_Illidan: Lazy evaluation can be neatly summarised as outermost-first evaluation together with an optimisation called sharing.
15:43:05 <monochrom> lambdabot probably creates a source code file containing your expression, plus that "take n (show ...)" trick, plus imports. Then compile and run it for a bounded time.
15:43:20 <Lord_Illidan> Toxaris, oh cool
15:43:33 <Cale> There's a small informative example I like to show in order to illustrate lazy evaluation.
15:43:46 <Cale> Suppose we have the function  double x = x + x
15:44:03 <Cale> Under strict evaluation, which is what most programming languages go by, we have:
15:44:06 <Cale> double (double 5)
15:44:12 <Cale> = double (5 + 5)
15:44:17 <Cale> = double 10
15:44:20 <Cale> = 10 + 10
15:44:21 <Cale> = 20
15:44:38 <Lord_Illidan> right
15:44:41 <Cale> Under outermost-first (also called normal order) evaluation, we have:
15:44:44 <Cale> double (double 5)
15:44:51 <Cale> = double 5 + double 5
15:44:56 <Cale> = (5 + 5) + double 5
15:45:00 <Cale> = 10 + double 5
15:45:06 <Cale> = 10 + (5 + 5)
15:45:09 <Cale> = 10 + 10
15:45:11 <Cale> = 20
15:45:26 <ddarius> What you need, Cale, is a non-deterministic language.
15:45:44 <Cale> Same result, but notice that it took a few more steps in this case. This is because we evaluated double 5 twice.
15:45:51 <Lord_Illidan> yes
15:46:07 <jas6180> hi guys. i have a question related to tall call optimization in haskell. would someone mind looking at the (very simple) code here: http://www.majidejima.com/Testing.hs.txt ?  It stack overflows when I can't understand why it doesn't run in constant space.
15:46:16 <Cale> So to avoid this, lazy evaluation adds an optimisation which says that parameters to a function which occur multiple times in its body get shared between the copies.
15:46:16 <Lord_Illidan> And I read somewhere that if Haskell detects we already evaluated something, it doesn't do it again, right?
15:46:17 <ehird`> I particularly don't understand how to use Network.IRC to actually do stuff. It seems to be pure.
15:46:35 <Cale> It only does this sharing which I'm talking about.
15:46:44 <Lord_Illidan> yes, that's it
15:46:52 <stepcut> jas6180: try, iter_func acc counter = iter_func $! (-1 * acc) (counter - 1)
15:47:12 <Cale> Okay, so if you'll allow me to use let/in-notation to represent the sharing, under lazy evaluation, we have:
15:47:14 <dolio> jas6180: At a guess, it's because with lazy evaluation, tail recursion builds up a bunch of un-evaluated thunks, and then evaluates them at the end.
15:47:16 <Cale> double (double 5)
15:47:16 <ddarius> @wiki Stack overflow
15:47:16 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
15:47:27 <Cale> = let x = double 5 in x + x
15:47:33 <Cale> = let x = 5 + 5 in x + x
15:47:38 <Cale> = let x = 10 in x + x
15:47:41 <Cale> = 20
15:48:04 <dolio> jas6180: So without adding some strictness, it's no better than non-tail recursion.
15:48:16 <ddarius> Also -1 * acc === -acc
15:48:23 <Cale> and we're back down to the same number of steps as the strict evaluation managed in this case (but likely with some indirection at the implementation level)
15:48:42 <smarmy> cale: nice clean example
15:48:46 <Cale> In general, there are some programs where strict evaluation will take fewer steps and some where lazy evaluation will take fewer.
15:49:04 <jas6180> ah, i see. so tall call optimization really only works with strict evaluation, or is this formulated badly?
15:49:12 <Cale> However, if there's any evaluation order which terminates, lazy evaluation will terminate and produce the same result.
15:49:32 <Lord_Illidan> nice explanation
15:49:34 <Cale> This can't be said of strict evaluation.
15:49:37 <faxathisia> jas6180: You get tail call elimination in lazy languages too
15:49:44 <ehird`> jas6180: It works kind of fuzzily, in lazy.
15:49:57 <Saizan> Cale: i tought lazy eval would always take no more steps than strict
15:50:04 <dolio> jas6180: In your code, it's 'acc'. The result of iter_func is '-1 * (-1 * (-1 * ...)))'. So you want to add strictness to acc so that gets collapsed to a value at each iteration.
15:50:22 <Cale> Saizan: that would be an interesting result. I'm not sure.
15:50:27 <ddarius> Saizan: It depends on how you define "step" and how you define "in general"
15:50:43 <augustss> Saizan: lazy takes no more steps than strict for a suitable definition of step
15:50:48 <ddarius> Though, in general, there are programs that will terminate under strict evaluation and not under lazy evaluation.
15:50:54 <Cale> Tail recursion can be problematic under lazy evaluation since the outermost-first evaluation can cause large expressions to build up in the parameters to the function.
15:51:09 <augustss> ddarius: what?!?
15:51:13 <stepcut> Cale: do you have that example written down anywhere ?
15:51:23 <ddarius> augustss: Add effects.
15:51:25 <stepcut> Cale: besides the #haskell logs ;)
15:51:26 <Cale> stepcut: No, just in my brain.
15:51:46 <augustss> ddarius: ok, with effects.  but this is #haskell :)
15:52:09 <jas6180> ah okay, i'll look into that. that seems to make sense though. thanks all
15:52:20 <Cale> Yes, I'm completely ignoring effects, and assuming that we'll reflect those as values or something :)
15:52:42 <Toxaris> jas6180: I see it this way: a tail-call is a call whose result is immediately taken as a result of the function without applying more processing to it. with haskell, this definition applies not to the program text, but to the operational (!) semantics of the program, that is, the order in which the applications are actually performed at run time. so you have to carefully adjust this order, using e.g. strictness annotations, to
15:52:42 <Toxaris> make a call a tail-call.
15:53:11 <ehird`> does anyone know network.IRC here?
15:53:35 <augustss> some tail calls work exactly as expected with lazy evaluation, e.g., the last function
15:53:51 <Toxaris> jas6180: the same is true for strict languages with non-strict language elements (e.g. if-then-else-statements). you have to be aware of what the non-stricts parts of the language do to evaluation order to understand which call is a tail call
15:54:02 <dolio> Yeah, it's accumulators that are the problem, I suppose.
15:54:06 <Saizan> ehird`: from the irc package on hackage? last time i checked it was just a parser/prettyprinter nothing that deals with I/O
15:54:11 <ehird`> Saizan: ah
15:54:16 <ehird`> i'll write a few things to do with that then
15:54:19 <Cale> Let's look at an example where tail recursion and lazy evaluation produce suboptimal results.
15:54:25 <Cale> @src foldl
15:54:25 <lambdabot> foldl f z []     = z
15:54:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:54:43 <Cale> foldl (+) 0 [1,2,3]
15:54:54 <Cale> = foldl (+) (0 + 1) [2,3]
15:54:59 <Toxaris> (I think that it is important to realize that some calls are tail-calls in a lazy language which wouldn't be tail-calls in a strict language)
15:55:00 <Cale> = foldl (+) ((0 + 1) + 2) [3]
15:55:08 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
15:55:13 <Cale> = ((0 + 1) + 2) + 3
15:55:17 <Cale> = (1 + 2) + 3
15:55:18 <audrey631> Salut  tous!!! :p
15:55:21 <Cale> = 3 + 3
15:55:22 <Cale> = 6
15:55:26 <audrey631> hello probleme
15:55:30 <audrey631> http://flash.pastebin.com/m5814560f
15:55:31 <jas6180> by any chance could someone recommend some reading on reasoning about tail call optimization? it seems rather difficult to reason about, although that might just be my extreme inexperience...
15:55:48 <dolio> iter_func still gets tail call optimized (I imagine). It just gets optimized into a nice tight loop that builds a big, overflowing pile of thunks. :)
15:55:53 <ddarius> jas6180: Read the Stack overflow wiki page I linked above.
15:56:05 <Cale> So you can see that an expression is built up which is as large as the original list, and none of that gets done before the foldl reaches the end of the list.
15:56:13 <jas6180> ddarius: ah sorry i missed it, thank you
15:56:20 <ehird`> Saizan: does it even handle responses?!
15:56:23 <Cale> This can result in stack overflow, in practice, and in any event is a waste of memory.
15:56:24 <ehird`> seems to be catered to parsing
15:56:26 <audrey631> help
15:56:51 <Cale> So the solution is to replace foldl with a strict left fold, which evaluates the accumulating parameter on each step.
15:56:51 <augustss> Cale: but not all uses of foldl are bad, if f is a constructor it's all right
15:56:52 <Toxaris> audrey631: wrong channel?
15:56:53 <Cale> @src foldl'
15:56:54 <lambdabot> foldl' f a []     = a
15:56:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:56:58 <Cale> augustss: sure
15:57:47 <Toxaris> audrey631: or what's your question?
15:57:59 <ddarius> augustss: If f is a constructor, then foldl is the same as foldl'.
15:58:06 <audrey631> ok
15:58:08 <ehird`> sock <- (get >>= socket)   -- now that is ugly
15:58:08 <ehird`> :)
15:58:26 <faxathisia> sock <- socket =<< get
15:58:28 <Cale> jas6180/Lord_Illidan: Does that make sense?
15:58:29 <dons> Lemmih: will we have tshirts from the Lemminian Institute of Technology at the hackathon? I'd love one!
15:58:30 <faxathisia> how about that?
15:58:44 <Lord_Illidan> Cale, yes, thanks
15:58:56 <audrey631> I think not, or I have to put the address RMTP on my codes AS
15:59:07 <augustss> ddarius: sure
15:59:08 <ddarius> Other than the superfluous parentheses, I don't see what is wrong with the first one.
15:59:10 <jas6180> Cale: I think so, I will experiment with it.  thanks everyone for your help, i think i can figure it out eventually
15:59:23 <audrey631> http://flash.pastebin.com/m5814560f
15:59:41 <Cale> audrey631: This is #haskell, it's about programming in the pure functional programming language Haskell. Are you sure you don't want another channel?
16:00:06 <ivan_> hi, i am using monads and i have an abstract function that uses read, it fails when the type is a string, how can i fix this?
16:00:20 <audrey631> Everyone is asleep in the channel flash
16:00:43 <mrd> its understandable confusion, because many programmers come to Haskell first when they are writing web applications
16:00:53 <Cale> mrd: ;)
16:01:21 <monochrom> hahahaha
16:01:41 <ivan_> Cale: maybe u can help mee =)?
16:01:46 <audrey631> 	
16:01:46 <Cale> ivan_: I'm not sure I understand your question...
16:01:47 <audrey631> You can help m for my problem with flash
16:02:13 <Cale> ivan_: You're applying read to a string?
16:02:30 <Cale> ivan_: er, are you using read to read a String?
16:02:34 <Toxaris> > read "\"read works fine for strings\"" :: String
16:02:35 <lambdabot>  "read works fine for strings"
16:02:41 <Cale> > read "\"hello\""
16:02:42 <lambdabot>  Exception: Prelude.read: no parse
16:02:46 <Cale> > read "\"hello\"" :: String
16:02:47 <lambdabot>  "hello"
16:03:00 <ivan_> but then i have to use show "string" right?
16:03:02 <Toxaris> > read "\"but you have to give a type annotation for small examples, as usual :)\"" :: String
16:03:03 <lambdabot>  "but you have to give a type annotation for small examples, as usual :)"
16:03:33 <Lord_Illidan> > let x = 5, y = 5 in x+y
16:03:33 <lambdabot>  Parse error at "," (column 10)
16:03:42 <Cale> ivan_: Um, not necessarily, but that's the usual way to get a quoted string.
16:03:46 <ehird`> runBot :: (Message -> KB a) -> KB ()
16:03:52 <Cale> > let x = 5; y = 5 in x + y
16:03:53 <lambdabot>  10
16:03:59 <ehird`> :D
16:04:00 <Lord_Illidan> 10x
16:04:13 <Lord_Illidan> damn, it's 1 am here
16:04:18 <Cale> > let y = 5 in x + y
16:04:19 <lambdabot>  x + 5
16:04:21 <Cale> ;)
16:04:27 <Cale> :t x
16:04:28 <lambdabot> Expr
16:04:29 <ehird`> hm
16:04:34 <Toxaris> amazing
16:04:36 <ehird`> what's the best way to store multiple things in a StateT
16:04:39 <ehird`> right now i have lines like:
16:04:44 <ehird`> 'sock <- (get >>= socket)'
16:04:45 <Lord_Illidan> > let x =x in x
16:04:46 <lambdabot>  Exception: <<loop>>
16:04:46 <ivan_> hmm its confusing becuase the function is abstract and when i get an "3" it reads it as an int but if i get "hello" it should read it as a string but read doesnt work for this type
16:04:50 <Toxaris> > x
16:04:52 <lambdabot>  x
16:04:58 <Cale> > iterate f x
16:04:59 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
16:05:19 <faxathisia> > foldr (flip f) z [a,b,c,d,e]
16:05:20 <lambdabot>  f (f (f (f (f z e) d) c) b) a
16:05:20 <Cale> ivan_: It will work if the incoming string is quoted.
16:05:29 <faxathisia> > foldl f z (reverse [a,b,c,d,e])
16:05:29 <lambdabot>  f (f (f (f (f z e) d) c) b) a
16:05:31 <Toxaris> ivan_: "abstract"?
16:05:56 <monochrom> You know, you have the option of not using read altogether...
16:05:59 <Toxaris> how does that Expr stuff work?
16:06:12 <Cale> ehird`: you could write some wrappers around get and put, for getting and setting various parts of the state.
16:06:12 <Saizan> ehird`: it's common to have a record like data State = S { field :: A, other :: B } and then use gets field
16:06:16 <Pseudonym> Interestingly, though:
16:06:18 <Pseudonym> > fix f
16:06:18 <lambdabot>  Add a type signature
16:06:21 <Pseudonym> > fix f :: Expr
16:06:21 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
16:06:26 <Pseudonym> :t fix
16:06:26 <ehird`> 'gets'?
16:06:27 <lambdabot> forall a. (a -> a) -> a
16:06:32 <Cale> :t gets
16:06:34 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
16:06:47 <Pseudonym> I'm surprised that you need the type signature on that one.
16:06:57 <Cale> :t f
16:06:58 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
16:07:06 <Pseudonym> Aha.
16:07:09 <Pseudonym> That'd do it.
16:07:40 <Cale> :t (.)
16:07:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:07:44 <Cale> ;)
16:08:18 <monochrom> :t ($)
16:08:19 <lambdabot> forall a b. (a -> b) -> a -> b
16:08:24 <faxathisia> Cale!
16:08:25 <mrd> > sum (zipWith (*) [x1,y1,z1] [x2,y2,z2])
16:08:25 <lambdabot>   Not in scope: `z2'
16:08:29 <faxathisia> You made . fmap?
16:08:30 <Cale> I haven't flipped ($) yet
16:08:31 <ddarius> > (0$0 $)
16:08:32 <lambdabot>      The operator `$' [infixr 0] of a section
16:08:32 <lambdabot>         must have lower precede...
16:08:32 <mrd> > sum (zipWith (*) [x1,y1,z1] [x2,y2,z2]) :: Expr
16:08:32 <lambdabot>   Not in scope: `z2'
16:08:32 <Cale> yeah
16:08:33 <monochrom> I wonder if ($) can be generalized too.
16:08:52 <mrd> > map f [1,2,3] :: [Expr]
16:08:52 <lambdabot>  [f 1,f 2,f 3]
16:08:58 <ddarius> monochrom: <*>
16:09:01 <Cale> > f . [1,2,3] :: [Expr]
16:09:02 <lambdabot>  [f 1,f 2,f 3]
16:09:05 <Toxaris> has this \bot travelled through time to bring us a view of 22nd century's haskell?
16:09:06 <Saizan> Cale: ahah! abusing your powers to push your secret agenda!
16:09:09 <mrd> > sum (zipWith (*) [1,2,3] [4,5,6]) :: Expr
16:09:10 <lambdabot>  0 + 1 * 4 + 2 * 5 + 3 * 6
16:09:19 <monochrom> > sin <*> (pi / 4)
16:09:19 <lambdabot>        add an instance declaration for
16:09:19 <lambdabot>       (Floating ((a -> b) -> a), Float...
16:09:21 <resiak> Cale: making $ the other way around will make \b less useful for explaining things
16:09:28 <monochrom> Oh!
16:09:36 <mrd> :t x
16:09:37 <lambdabot> Expr
16:09:38 <monochrom> > (pi / 4) <*> sin
16:09:39 <lambdabot>        add an instance declaration for (Floating (a -> a -> b))
16:09:43 <Cale> Hey, if I'm going to be suckered into maintaining lambdabot, I might as well take advantage of the potential for propaganda!
16:09:46 <monochrom> LIES!
16:09:53 <ddarius> :t <*>
16:09:55 <lambdabot> parse error on input `<*>'
16:09:58 <ddarius> :t (<*>)
16:10:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:10:12 <mrd> :t x1
16:10:14 <lambdabot> Not in scope: `x1'
16:10:21 <faxathisia> heheh Cale :D
16:10:31 <mrd> what're the predefined variables?
16:10:35 <mrd> > x
16:10:36 <lambdabot>  x
16:10:49 <augustss> :t x
16:10:49 <Cale> mrd: a-z
16:10:50 <lambdabot> Expr
16:10:55 <Cale> mrd: with f,g,h having more general types
16:10:55 <monochrom> > Identity sin <*> Identity (pi / 4)
16:10:56 <lambdabot>   Not in scope: data constructor `Identity'
16:11:06 <Cale> mrd: (that allow them to be used for functions)
16:11:12 <byorgey> > pure sin <*> pure (pi/4)
16:11:12 <lambdabot>   add an instance declaration for (Show (f a))
16:11:15 <mrd> > (f &&& g) x :: (Expr, Expr)
16:11:16 <lambdabot>  (f x,g x)
16:11:29 <ddarius> > runIdentity (return sin <*> return (pi/4))
16:11:29 <lambdabot>   Not in scope: `runIdentity'
16:12:19 <ddarius> (=<<) is a different generalization of ($)
16:12:39 <monochrom> Yeah.
16:13:17 <monochrom> > sin =<< (pi / 4)
16:13:17 <lambdabot>        add an instance declaration for
16:13:17 <ehird`> when i'm in a StateT Foo IO, how can I avoid tons of ugly 'lift'?
16:13:17 <lambdabot>       (Floating (m (m b)), Floating (m...
16:13:50 <monochrom> Well, nevermind.
16:14:22 <smarmy> ehird`: you can define new operations in your transformed monad that correspond to the things you would otherwise lift.  dunno if there is a better way
16:14:44 <Cale> :t (sin .)
16:14:45 <lambdabot> forall a (f :: * -> *). (Functor f, Floating a) => f a -> f a
16:15:01 <Toxaris> > [a..b] :: Expr
16:15:02 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
16:15:06 <Lord_Illidan> i'm off for the night
16:15:08 <Lord_Illidan> cya!
16:15:14 <Toxaris> > [1..3] :: Expr
16:15:14 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
16:15:16 <Lord_Illidan> good morning all :D
16:15:38 <Toxaris> > [1..3] :: [Expr]
16:15:38 <lambdabot>  [1,2,3]
16:15:43 <Toxaris> > [a..b] :: [Expr]
16:15:43 <lambdabot>  Exception: not a number
16:15:46 <Cale> Lord_Illidan: good... morning then :)
16:18:06 <Toxaris> ehird`: you can redefine the primitives you need, e.g. myPutStr :: MonadIO m => String -> m (); myPutStr = liftIO . putStr   or somehow like this
16:18:14 <dons> Igloo: my ghc git conversion is up to 2000-02-01!
16:18:19 <dons> half way!
16:18:28 <avtobiff> how do i generate a random number with randomR? I have imported System.Random and tried  randomR (1,100) getStdGen without any success.
16:18:45 <Cale> avtobiff: getStdGen is an IO action
16:18:55 <Nafai> dons: What's ghc in now?  cvs?  svn?
16:19:06 <Cale> avtobiff: You have to run it to get a StdGen
16:19:06 <resiak> isn't there a library floating around that redefines all of the regular IO actions for MonadIO?
16:19:07 <dons> darcs.
16:19:22 <Toxaris> resiak: if not, there should.
16:19:25 <ddarius> dons: How long has it been running?
16:20:10 <dons> 2 weeks :)
16:20:19 <Nafai> Wow
16:20:25 <avtobiff> Cale, ok. i am not entirely sure how to do that. i am within a do construct though (supposedly that would infer that I use the IO action monad right?)
16:20:49 <Cale> avtobiff: Well, if it's the IO monad you're actually working with and not some other monad
16:20:50 <Cale> :)
16:20:54 <Cale> g <- getStdGen
16:21:07 <avtobiff> Cale, yeah. i got that... but it may be. i think... hmm brb
16:21:07 <Cale> print (randomR (1,100) g)
16:21:17 <ehird`> @src putStrLn
16:21:17 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
16:21:20 <Toxaris> avtobiff: check out randomRIO too
16:21:30 <Cale> avtobiff: If you're generally confused about IO, check out my short tutorial
16:21:41 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
16:22:07 <avtobiff> i am not generally confused about IO. :)
16:22:15 <avtobiff> but i'll check out your  tutorial
16:22:16 <smarmy> so cale, i have to ask this, because there's been so many tongue in cheek references... what's the advantage of a left-associative ($)?
16:22:31 <ddarius> Cale, make a wiki page.
16:22:35 <ddarius> or something
16:23:10 <ehird> um
16:23:13 <ehird> network.irc is broken
16:23:30 <ehird> Prelude Network.IRC> decode "PRIVMSG #foo :x"
16:23:30 <ehird> Nothing
16:23:31 <Toxaris> is it a known bug that hackage "source" links for typeclass members aren't working?
16:23:39 <Toxaris> ehm, haddock
16:23:48 <Toxaris> or whatever, the source links in the pages hoogle links to
16:24:03 <ehird> :/
16:24:11 <faxathisia> ehird: isn't it parsing server messages instead of client ones?
16:24:13 <ehird> aha
16:24:15 <ehird> it needs \n
16:24:18 <ehird> ridiculous.
16:24:21 <ehird> soo
16:24:26 <ehird> I need to ++ "\r\n"
16:24:30 <ehird> to hGetLine's output
16:24:30 <ehird> wonderful
16:24:42 <ehird> stupid
16:25:27 <avtobiff> i can also do (getStdGen >>= (\g -> randomR (1,100) g)) right?!
16:25:33 <ehird> actually
16:25:34 <ehird> just \n
16:25:38 <ehird> because the \r is retained by hGetLine
16:25:39 <ehird> hah
16:26:10 <smarmy> or just getStdGen >>= randomR (1,100)
16:26:13 <avtobiff> Cale, so what should i do if i am inside som other monad but still want a random-number?
16:26:18 <avtobiff> smarmy, ok thx.
16:26:31 <avtobiff> yeah ofcourse. currying at its finest :)
16:27:07 <smarmy> avtobiff: you can use liftIO to lift the IO operation into your monad
16:27:39 <avtobiff> actually... i think i have my own liftio :)
16:27:55 <avtobiff> i just havent really groked monads yet
16:27:57 <Toxaris> avtobiff: IIRC   (\x -> f x) ~~> f   is called eta-conversion
16:28:12 <Toxaris> avtobiff: but i'm not sure
16:28:23 <smarmy> i call it magic
16:28:31 <ddarius> Toxaris: Yes.  eta-reduction to be more specific.
16:28:32 <avtobiff> Toxaris, i recognize it too
16:28:50 <avtobiff> which is part of lambda calculus?!
16:28:51 <pjd> avtobiff: grok Functor first, then Applicative, then Monad
16:29:15 <Toxaris> avtobiff: currying is (\(x,y) -> e) ~~> (\x -> \y -> e)
16:29:18 <avtobiff> pjd, i'lll write that down
16:29:19 <ddarius> avtobiff: It's part of the theory around the lambda calculus yes.
16:29:31 <faxathisia> :t curry
16:29:31 <avtobiff> Toxaris, yes.
16:29:32 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:29:35 <faxathisia> :t uncurry
16:29:36 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:29:41 <ddarius> avtobiff: Haskell is not much more than an applied typed lambda calculus.
16:29:45 <pjd> avtobiff: once you understand Functor, the rest is easy :)
16:30:01 <avtobiff> pjd, hehe. then i can carry on to bifunctors maybe? ;)
16:30:22 <pjd> avtobiff: the sky's the limit!
16:30:22 <smarmy> i'd tread carefully around any statement that ends in "... the rest is easy"
16:30:26 <ddarius> If you understand functors, bifunctors are trivial.
16:30:35 <avtobiff> :)
16:30:51 <avtobiff> :t liftIO
16:30:52 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
16:33:03 <avtobiff> isn't Control.Monad.Trans part of ghc-standard packages?!
16:34:34 <ehird> anyone using Network.IRC?
16:34:35 <dons> its in mtl, which is not a required package
16:34:38 <ehird> NickName doesn't appear to EXIST...
16:34:41 <dons> ?hackage mtl
16:34:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
16:34:42 <ehird> But only in my source! In ghci it's ok.
16:34:57 <avtobiff> dons, debian doesn't have mtl
16:35:02 <avtobiff> dons, as far as i can see
16:35:04 <ehird> Not in scope: type constructor or class `NickName'
16:35:09 <mrd> libghc6-mtl-dev
16:35:20 <dons> mtl-dev is the one
16:35:41 <avtobiff> seems i am just a sloppy reader
16:35:45 <avtobiff> or tired... or both.
16:35:47 <avtobiff> thanks!
16:35:48 <ehird> elliottt: whoa
16:35:50 <ehird> just in time!
16:35:52 <elliottt> :)
16:36:14 <ehird> (it feels vaguely weird to use a library made by someone whose surname is the same as my first name. heh :P)
16:36:20 <elliottt> hehe
16:36:26 <elliottt> spelled the same too?
16:36:34 <ehird> yep
16:36:41 <elliottt> wow, that is odd :)
16:36:42 <ehird> anyway, Network.IRC doesn't appear to export NickName
16:36:48 <ehird> and yet, when I try in ghci, it's fine
16:36:50 <elliottt> oh, that's bad news
16:36:54 <ehird> `Not in scope: type constructor or class `NickName''
16:36:56 <elliottt> let me have a look
16:37:05 <ehird> Prelude Network.IRC> NickName
16:37:05 <ehird> <interactive>:1:0:
16:37:05 <ehird> <etc>
16:37:22 <elliottt> Prelude Network.IRC> :i NickName
16:37:22 <elliottt> data Prefix
16:37:22 <elliottt>   = ... | NickName String (Maybe UserName) (Maybe ServerName)
16:37:25 <elliottt>   	-- Defined in Network.IRC.Base
16:37:45 <paczesiowa> when will http://hackage.haskell.org/trac/summer-of-code/ be bumped to 2008?
16:37:45 <elliottt> ehird: which version do you have?
16:37:46 <lambdabot> Title: Haskell.org Google Summer of Code - Trac
16:37:57 <ehird> elliottt: I just cabal install-ed it today.
16:38:11 <ehird> And yeah, I can do :i and all in ghci.
16:38:12 <elliottt> ah, you're right.  it's not in the export list
16:38:17 <ehird> heh :)
16:38:30 <elliottt> oh wait, yes it is.
16:38:37 <ehird> yes
16:38:37 <ehird> it is
16:38:40 <elliottt> it's a constructor for Prefix
16:38:41 <ehird> so wtf is up :)
16:38:46 <elliottt> yeah, that's pretty strange.
16:38:52 <elliottt> well, it works for me
16:38:57 <ehird> whoa
16:38:59 <ehird> it works in a structure
16:38:59 <ehird> just:
16:39:03 <ehird> handleMsg (Message (Just (NickName n _ _)) "PRIVMSG" ("foo":xs))
16:39:08 <ehird> (in a pattern match)
16:39:08 <ehird> fails
16:39:12 <ehird> crazy
16:39:12 <elliottt> ah, ok
16:41:15 <ehird> so what's up with that?
16:41:35 <elliottt> not really sure, just trying to replicate it here
16:43:43 <elliottt> ok, i can't reproduce it
16:43:55 <elliottt> i'll paste my test for you
16:43:58 <avtobiff> which version of mtl should i have (install)? because it seems broken in debian (testing/unstable)
16:44:25 <hpaste>  elliottt pasted "irc test" at http://hpaste.org/6000
16:44:35 <elliottt> ehird: that worked for me
16:45:25 <ehird> wtff
16:45:25 <ehird> that works
16:45:49 <hpaste>  ehird pasted "imports" at http://hpaste.org/6001
16:45:54 <ehird> maybe all those imports have something to do with it..
16:46:07 <elliottt> ah
16:46:33 <ehird> Okay, this is just surreal.
16:46:38 <ehird> it works now.
16:46:52 <elliottt> everything gets re-exported by Network.IRC
16:47:11 <elliottt> so if you want to have commands imported under C, you might want to import each bit separately
16:49:03 <ehird> ah
16:49:34 <elliottt> otherwise, you've still got commands imported, and then all commands imported under C as well
16:49:45 <elliottt> (i think)
16:55:03 <ehird> hm, what's the standard "trim whitespace" function again?
16:55:20 <ddarius> There's a standard trim whitespace function?
16:55:53 <mauke> :t join (.) (reverse . dropWhile isSpace)
16:55:54 <faxathisia> > (unwords . words) " foo "
16:55:55 <lambdabot>  "foo"
16:55:55 <lambdabot> [Char] -> [Char]
16:56:02 <dons> that's it
16:56:09 <ddarius> > (unwords . words) "foo     bar"
16:56:10 <lambdabot>  "foo bar"
16:56:13 <mauke> > join (.) (reverse . dropWhile isSpace) "  what   is   this  "
16:56:14 <lambdabot>  "what   is   this"
16:56:21 <ehird> (unwords . words) -- that is CLEVER
16:57:00 <ddarius> ehird: It doesn't do what most people mean by "trim whitespace"
16:57:13 <ehird> Well, yeah.
17:00:17 <tensh> does anyone know of a method that can convert %22, %28 etc. back into the real char?
17:00:29 <tensh> I need to decode url queries
17:00:37 <faxathisia> > (chr . read . drop 1) "%22"
17:00:37 <lambdabot>  '\SYN'
17:00:38 <ddarius> chr 22
17:00:50 <ddarius> chr 0x22
17:00:56 <elliottt> won't unwords . words also trim all inner whitespace too?
17:00:57 <ddarius> > chr 0x22
17:00:57 <lambdabot>  '"'
17:01:24 <tensh> well, I'd want it so it converts everything that matches on %xx
17:01:28 <ehird> @type modify
17:01:29 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
17:01:38 <elliottt> > (unwords . words) " hello    world "
17:01:38 <lambdabot>  "hello world"
17:01:43 <ehird> @hoogle (MonadState s m) => (s -> m s) -> m ()
17:01:43 <lambdabot> Control.Monad.State.Class.modify :: MonadState s m => (s -> s) -> m ()
17:01:45 <lambdabot> Data.Function.fix :: (a -> a) -> a
17:01:45 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
17:01:53 <ehird> hmph
17:02:09 <ehird> elliottt: turns out that that's what i want
17:02:41 <mauke> urlDecode ('%' : x : y : cs) = chr (f x * 16 + f y) : urlDecode cs
17:02:49 <mauke> urlDecode (c : cs) = c : urlDecode cs
17:02:53 <elliottt> ehird: no problem then :)
17:02:56 <mauke> urlDecode [] = []
17:03:07 <tensh> ahh, smart
17:03:08 <mauke>     where f = digitToInt
17:03:13 <glguy> ehird: under heavy load lighttpd seems to default to 500 server error
17:03:22 <glguy> (when using this fastcgi binary)
17:03:25 <glguy> is that "normal"
17:03:29 <tensh> but there's no built in method for it I guess?
17:03:35 <ehird> glguy: handle your own fcgi launching
17:03:40 <ehird> lighty includes a script for that
17:03:42 <ehird> spawn-fcgi
17:03:42 <mauke> tensh: I have no idea :-)
17:03:47 <ehird> much better than trusting lighty to do it
17:03:59 <ddarius> @hackgae
17:03:59 <lambdabot> http://hackage.haskell.org
17:04:56 <ehird> hackgae!
17:05:03 <ehird> more like hack GAY
17:05:30 <olsner> @pl liftM2 (,) a b >>= uncurry c
17:05:30 <lambdabot> uncurry c =<< liftM2 (,) a b
17:05:47 <monochrom> hascage
17:05:48 <olsner> @ty join (liftM2 c a b)
17:05:50 <lambdabot>     Couldn't match expected type `a1 -> a2 -> m a'
17:05:50 <lambdabot>            against inferred type `Expr'
17:05:50 <lambdabot>     In the first argument of `liftM2', namely `c'
17:05:55 <faxathisia> :t liftM2 (,)
17:05:56 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
17:06:00 <olsner> @ty \a b c -> join (liftM2 c a b)
17:06:01 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => m a1 -> m a2 -> (a1 -> a2 -> m a) -> m a
17:06:15 <faxathisia> :t (\x y -> (,) <*> x <$> y)
17:06:17 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a -> a1) -> f a -> f (a, a1)
17:06:23 <faxathisia> :t (\x y -> (,) <$> x <*> y)
17:06:24 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
17:06:37 <faxathisia> is (\x y -> (,) <$> x <*> y) the same as liftM2 (,) ?
17:07:01 <olsner> I guess it's just functor vs monad
17:07:15 <faxathisia> > ( (,) <$> [88,22,66] <*> [1,2,3] , liftM2 (,) [88,22,66] [1,2,3] )
17:07:16 <lambdabot>  ([(88,1),(88,2),(88,3),(22,1),(22,2),(22,3),(66,1),(66,2),(66,3)],[(88,1),(8...
17:07:16 <mauke> :t liftA2 (,)
17:07:17 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
17:07:26 <faxathisia> > ( (,) <$> [88,22] <*> [1,2,3] , liftM2 (,) [88,22] [1,2,3] )
17:07:26 <lambdabot>  ([(88,1),(88,2),(88,3),(22,1),(22,2),(22,3)],[(88,1),(88,2),(88,3),(22,1),(2...
17:07:32 <faxathisia> it looks the same
17:08:03 <mauke> > (,) `fmap` [88,22] `ap` [1,2,3]
17:08:03 <lambdabot>  [(88,1),(88,2),(88,3),(22,1),(22,2),(22,3)]
17:08:46 <faxathisia> > (,) `fmap` ([88,22] `ap` [1,2,3])
17:08:46 <lambdabot>   add an instance declaration for (Num (a -> a1))
17:09:09 <ehird> @type gets
17:09:10 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
17:09:13 <ddarius> faxathisia: It is
17:09:24 <ehird> (gets currentGame) >>= fromJust
17:09:27 <ddarius> (Well, when <*> is ap for a monad)
17:09:29 <ehird> surely that should be 'm Game'.
17:10:25 <ddarius> ehird: No.
17:10:29 <ehird> :|
17:10:41 <faxathisia> :t (gets ?currentGame) >>= fromJust
17:10:42 <lambdabot> forall s (m :: * -> *) b. (MonadState s m, ?currentGame::s -> Maybe (m b)) => m b
17:10:47 <ddarius> You want liftM fromJust $ gets currentGame
17:11:00 <ddarius> @src liftM
17:11:00 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:11:10 <ddarius> @. . pl undo src liftM
17:11:10 <lambdabot> ()
17:11:14 <ddarius> Do
17:11:15 <ddarius> h
17:12:15 <ddarius> At any rate, liftM f m = m >>= return . f
17:12:29 <ehird> @type puts
17:12:30 <lambdabot> Not in scope: `puts'
17:12:34 <ehird> D'aww. :-)
17:12:38 <ehird> (Of course, impossible.)
17:12:50 <ehird> (But updating a structure using 'modify' when you just want to update on ebit.. eww)
17:12:50 <ddarius> :t modify
17:12:52 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
17:14:14 <faxathisia> :t ?a (?b (?c (?d ?e)))
17:14:16 <lambdabot> forall t t1 t2 t3 t4. (?e::t4, ?d::t4 -> t3, ?c::t3 -> t2, ?b::t2 -> t, ?a::t -> t1) => t1
17:14:39 <Cale> ehird: What's wrong with that?
17:15:20 <Cale> ehird: You'll copy the pointers to the other bits, and use a different one for the bit that's changed.
17:17:01 <Cale> Of course, to make it convenient, you'll need a higher order function for applying a function to a component of your structure, like first and second do for pairs.
18:00:33 * sorear returns, sees irssi 'highlighted messages' indicator
18:00:41 <sorear> xerox: yep, it was me
18:01:09 <sorear> xerox: my first project in Coq though, I'd do things a bit differently now (if I was still involved, which I'm not)
18:02:58 <BMeph> So, is anyone else working on the UD code thing mjd blogged about yesterday?
18:05:06 <sorear> xerox: 2008.02.28.15.40.52 < Saizan> xerox: maybe this? http://members.cox.net/stefanor/hanoi.v
18:05:10 * sorear hugs his logs
18:05:15 <Cale> hehehe, the most common Hoogle search, after the three example searches, is apparently "where"
18:05:21 <sorear> ... hahaha
18:05:46 <ddarius> @hoogle case
18:05:46 <lambdabot> Language.Haskell.TH.caseE :: ExpQ -> [MatchQ] -> ExpQ
18:05:47 <lambdabot> Text.ParserCombinators.Parsec.Token.caseSensitive :: LanguageDef st -> Bool
18:05:47 <lambdabot> Text.ParserCombinators.Parsec.Language.caseSensitive :: LanguageDef st -> Bool
18:05:53 <ddarius> @hoogle where
18:05:54 <lambdabot> Language.Haskell.TH.Ppr.where_clause :: [Dec] -> Doc
18:05:54 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
18:05:54 <lambdabot> Data.Generics.Schemes.somewhere :: MonadPlus m => GenericM m -> GenericM m
18:06:05 <ddarius> @hoogle ->
18:06:05 <lambdabot> No matches found
18:08:07 <BMeph> ?hoogle it
18:08:08 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
18:08:08 <lambdabot> Data.List.iterate :: (a -> a) -> a -> [a]
18:08:08 <lambdabot> Data.ByteString.Lazy.iterate :: (Word8 -> Word8) -> Word8 -> ByteString
18:08:25 <BMeph> ?hoogle something
18:08:25 <lambdabot> Data.Generics.Schemes.something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
18:08:34 <BMeph> Heh-heh. ;)
18:09:16 <olsner> @ty do something
18:09:18 <lambdabot> forall u. GenericQ (Maybe u) -> GenericQ (Maybe u)
18:09:41 <olsner> @ty Just (do something)
18:09:43 <lambdabot>     Cannot match a monotype with `(->) (GenericQ (Maybe u))'
18:09:43 <lambdabot>       Expected type: t
18:09:43 <lambdabot>       Inferred type: Maybe (GenericQ (Maybe u) -> GenericQ (Maybe u))
18:10:06 <olsner> oh, that's a type error I've never seen before
18:10:08 <ddarius> @src GenericQ
18:10:08 <lambdabot> Source not found. Just try something else.
18:10:16 <wagle_home> @ty Just (do Nothing)
18:10:17 <lambdabot> forall a. Maybe (Maybe a)
18:10:28 <ddarius> I'm pretty sure GenericQ is a higher rank type (synonym)
18:10:48 <wagle_home> @ty something
18:10:49 <lambdabot> forall u a. (Data a) => GenericQ (Maybe u) -> a -> Maybe u
18:11:02 <wagle_home> @src something
18:11:02 <lambdabot> Source not found. There are some things that I just don't know.
18:11:45 * BMeph wants some Hoogle T-shirts
18:12:27 <wagle_home> @hoohle GenericQ
18:12:27 <lambdabot> Data.Generics.Aliases.GenericQ :: type GenericQ r
18:12:27 <lambdabot> Data.Generics.Aliases.GenericQ' :: newtype GenericQ' r
18:13:07 <wagle_home> oo!  a hoohle command too!
18:14:09 <wagle_home> @src GenericQ
18:14:09 <lambdabot> Source not found. Just try something else.
18:17:41 <shapr> @yow !
18:17:41 <lambdabot> Youth of today!  Join me in a mass rally for traditional mental
18:17:41 <lambdabot> attitudes!
18:18:07 <ddarius> +/&.*:
18:22:35 <BMeph> ddarius: Doesn't that do something in J? ;)
18:23:07 <faxathisia> It seems to be id
18:23:20 <ddarius> faxathisia: Give it a vector
18:24:07 <faxathisia> I just get a domain error then
18:24:29 <ddarius> Did you give it parentheses?
18:25:13 <faxathisia> yeah
18:25:29 <faxathisia> +/&.*: (1 ; 2 ; 3) NB. like that?
18:25:44 <wli> It'd be nice if there were a standard module for things like binomial coefficients, Stirling numbers, etc.
18:26:25 <ddarius> Hmm, this is from the J Dictionary
18:26:40 <ddarius> I know what it's supposed to mean and why but it seems a bit off
18:27:55 <dolio> wli: You should write one. :)
18:28:36 <dibblego> ?hoogle [a] -> (a -> as -> b) -> [b]
18:28:36 <lambdabot> Did you mean: [a] -> (a -> As -> b) -> [b]
18:28:36 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:28:36 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:28:38 <dolio> Or maybe I should just open up Emacs, type everything in Concrete Mathematics in, and upload to hackage.
18:29:35 <sorear> !seen xerox
18:29:39 <sorear> @seen xerox
18:29:39 <lambdabot> xerox is in ##logic, #haskell-overflow, #haskell-blah and #haskell. I don't know when xerox last spoke.
18:32:11 <olsner> is Left or Right usually the error?
18:32:26 <ddarius> I see what's happening.
18:32:31 <wli> dolio: Well, I already have, but it's moderately naive and kind of a pain to keep imported all the time.
18:32:43 <dolio> Left. Right is the right answer.
18:33:41 <olsner> Right is the wrong answer to my question though, since the right one is Left :P
18:33:53 <dolio> Heh.
18:34:34 <monochrom> hehehe
18:35:05 <ddarius> or maybe not
18:35:17 <monochrom> LEFT IS RIGHT
18:35:21 <monochrom> RIGHT IS WRONG
18:35:24 <monochrom> WRONG IS LEFT
18:35:48 <wli> Left is almost always the error. I occasionally use it to be able to iterate to convergence by looping until throwError with an error type capable of encoding a "final answer," but I should probably use MonadCont or some such instead of doing that.
18:36:01 <mrd> monochrom: Either will do
18:36:57 <olsner> > let z = ["left", "right", "wrong", "correct"] in [x ++ " is " ++ y | x <- z, y <- z]
18:36:58 <lambdabot>  ["left is left","left is right","left is wrong","left is correct","right is ...
18:37:20 <faxathisia> :t (++ " is " ++)
18:37:22 <lambdabot> parse error on input `)'
18:37:24 <faxathisia> :(
18:37:31 <faxathisia> :t ((++ " is ") ++)
18:37:32 <lambdabot>     The section `(++ " is ")' takes one argument,
18:37:32 <lambdabot>     but its type `[a]' has none
18:37:32 <lambdabot>     In the first argument of `(++)', namely `(++ " is ")'
18:38:20 <ddarius> Okay, it is a rank issue.
18:39:43 <ddarius> I need a &. for &:
18:43:16 <ddarius> There we go.  +/&.:*:
18:44:04 <faxathisia> what does it calculate?
18:44:32 <ddarius> The sum under square
18:44:57 <faxathisia> ahh
18:44:59 <faxathisia>    +/&.:*: 3 4
18:45:00 <faxathisia> 5
18:45:01 <faxathisia> :D
18:47:45 <olsner> so... (remember there being a discussion about this some months ago) what was the efficient way of getting the last n items from a list?
18:47:56 <ddarius> olsner: Don't use a list.
18:48:05 <olsner> indeed
18:48:12 <BMeph> ddarius++
18:50:10 <dolio> > let dropList [] xs = xs ; dropList _ [] = [] ; dropList (_:t) (x:xs) = dropList t xs ; last' n l = dropList (drop n l) l in last' 5 [1..20]
18:50:11 <lambdabot>  [16,17,18,19,20]
18:52:28 <ddarius> > reverse . take 5 . reverse $ [1..20]
18:52:28 <lambdabot>  [16,17,18,19,20]
18:53:34 <dibblego> our Ruby on Rails website fell over at 1000 this morning (we are UTC+10). Today is Feb 29 :)
18:53:34 <Excedrin> dibblego ur
18:54:26 <olsner> you're saying ruby has a bug in leap year handling?
18:54:26 <Excedrin> olsner ou'r
18:55:05 <dibblego> olsner, it's looking that way; still tracking it down, but it appears to be somewhere in rails
18:55:41 <proq> uh oh... leap year is in 5 hours my time!
18:55:42 <Excedrin> eeh
18:55:43 <Corun> Evenin' Matt.
18:57:05 <monochrom> switch off your computer until next year.
18:57:59 <ddarius> (n&{.)&.|.
18:58:28 <wagle_home> more perl?
18:58:45 <faxathisia> really it looks nothing like perl..
18:58:57 <monochrom> Is that Perl?
18:59:00 <wagle_home> you havent seen the perl i have
18:59:18 <wagle_home> (nah)
18:59:24 <hpaste>  faxathisia pasted "takeLast n" at http://hpaste.org/6002
18:59:49 <faxathisia> I think this is O(n)..?
18:59:49 <monochrom> evil shadowing of length.
19:00:12 <faxathisia> monochrom: I'm used to haskell 2.0
19:00:13 <faxathisia> :P
19:00:46 <faxathisia> where map f (x:xs) = #'funcall f x : map f xs ..
19:01:42 * monochrom screams at #'funcall
19:01:52 <monochrom> That is too much Lisp for me!
19:02:49 <wagle_home> what's #'funcall?
19:03:35 <wagle_home> :t #'funcall
19:03:37 <lambdabot> lexical error at character '\''
19:03:48 <ddarius> funcall #'f x : map f xs
19:04:03 * monochrom screams more
19:04:20 <dolio> It's what you have to use to call functions stored in a variable in Common Lisp.
19:04:35 <faxathisia> dolio, no
19:04:52 <faxathisia> It's (funcall f x)
19:05:19 <faxathisia> but you can write #'g to mean (function g) and most people don't but I write that in some places..
19:05:33 <dolio> Oh, right.
19:05:37 <mrd> you'd use #'g if "g" was defined by "defun" and bound in the function namespace
19:05:59 <monochrom> funcall! pinball! snowfall!
19:06:04 <mrd> but then you'd normally just say (g ...) since that is the normal way of calling a function
19:06:08 <faxathisia> You can put it before a lambda expressino too #'
19:06:09 <dolio> Obviously my Lisp is rusty.
19:06:13 <mrd> CL has lots of weird function names :)
19:06:50 <proq> dibblego: what was the problem?
19:07:14 <proq> "fell over"?
19:07:19 <redleafgr> is there a simple comparison breakdown/table of standard library data structures with the algorithmic complexities of their operators?
19:07:21 <dibblego> proq, others are working on it; I'm just listening to them. I just happened to guess correctly what time it went down :(
19:07:55 <dibblego> proq, stopped working in bizarre ways (first the server just stopped responding, then the cookies are not being handled properly, then...)
19:11:08 <proq> dibblego: hmm.. I set the date and everything seems ok so far
19:11:39 <dibblego> proq, I don't think just the software is to blame ultimately :) all I can is, "I didn't write it" :)
19:14:14 <redleafgr> this is the kind of breakdown i'm looking for... are there any others with more details/structures?: http://en.wikibooks.org/wiki/Haskell/YAHT/Language_advanced#Arrays
19:14:15 <lambdabot> http://tinyurl.com/y4u7rv
19:19:47 <radrian> can anyone help with this error: bash-3.2$ ghci
19:19:47 <radrian> /usr/local/lib/ghc-6.8.2/ghc-6.8.2: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory
19:20:20 <cjb> radrian: install your distribution's ncurses5 package
19:20:24 <ddarius> Seems self-explanatory to me
19:21:02 <radrian> I have libncurses
19:21:48 <ddarius> libncurses /= libncurses5 necessarily
19:22:34 <mrd> you need version 5 specifically.
19:31:53 <radrian> that worked, I had to do an extra step in building ncurses5 from source. Had to do 'make sources libs'. Thanks.
19:50:57 <boyscared> why is this definition of fibonacci so "naive": http://haskell.org/haskellwiki/The_Fibonacci_sequence#Naive_definition
19:50:58 <lambdabot> http://tinyurl.com/3ynj9f
19:51:29 <faxathisia> boyscared: it's because it uses recursion twice and takes so much space that's not needen
19:51:41 <dolio> It takes exponential time/space.
19:51:42 <faxathisia> boyscared: A smarter (less naive) way could eliminate that
19:52:09 <boyscared> yes, but that definition bogs down around n = 35 or so, which seems awfully low
19:53:03 <faxathisia> > (!!35) $ map fst $ iterate (\(f1,f2) -> (f2,f1+f2)) $ (0,1)
19:53:05 <lambdabot>  9227465
19:53:38 <faxathisia> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 35
19:53:39 <lambdabot>  9227465
19:53:40 <ddarius> It takes fibonacci time and space
19:53:51 <faxathisia> hmmmm...
19:53:55 <faxathisia> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 100
19:54:00 <lambdabot> Terminated
19:54:06 <faxathisia> > (!!100) $ map fst $ iterate (\(f1,f2) -> (f2,f1+f2)) $ (0,1)
19:54:06 <lambdabot>  354224848179261915075
19:54:12 <faxathisia> right :D
19:54:34 <faxathisia> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 5 :: Expr
19:54:35 <lambdabot>  1 + 0 + 1 + (1 + 0) + (1 + 0 + 1)
19:54:39 <faxathisia> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 6 :: Expr
19:54:39 <lambdabot>  1 + 0 + 1 + (1 + 0) + (1 + 0 + 1) + (1 + 0 + 1 + (1 + 0))
19:54:47 <faxathisia> > (!!5) $ map fst $ iterate (\(f1,f2) -> (f2,f1+f2)) $ (0,1) :: Expr
19:54:48 <lambdabot>  1 + (0 + 1) + (0 + 1 + (1 + (0 + 1)))
19:54:52 <faxathisia> > (!!6) $ map fst $ iterate (\(f1,f2) -> (f2,f1+f2)) $ (0,1) :: Expr
19:54:52 <lambdabot>  0 + 1 + (1 + (0 + 1)) + (1 + (0 + 1) + (0 + 1 + (1 + (0 + 1))))
19:55:02 <faxathisia> oh well I'm not sure that demonstrated anything
19:55:14 <liyang> :t (<$>)
19:55:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:56:11 <glen_quagmire> > (((+) 1) 2)  -- lisp
19:56:11 <olsner> w00t! I have now implemented inflate
19:56:12 <lambdabot>  3
20:00:06 <byorgey> olsner: what's inflate?
20:00:19 <olsner> the opposite of deflate, one of the zip algorithms
20:00:25 <byorgey> ah, neat
20:00:29 <olsner> incidentally, the one used by the gzip quine
20:00:46 <byorgey> heh, awesome =)
20:00:47 <olsner> so that's what it's able to do at this point - unzip the quine correctly
20:01:04 <boy> gzip is a quine?
20:01:59 <olsner> no, but it *has* one - i.e. a compressed file that decompresses into an identical file
20:03:25 <faxathisia> olsner, cool!
20:03:38 <mauke> can it be used to trap virus scanners in an infinite loop?
20:04:10 <olsner> no, no looping in deflate...
20:04:39 <dolio> Well, a virus scanner that checks inside deflated files could go into a loop on it, I suppose.
20:04:49 <mauke> yeah, that's what I mean
20:05:02 <dolio> Since it'd inflate it, see another deflated file, and try to inflate that...
20:05:07 <glen_quagmire> http://www.beautiful-weddings.com/caspian/selfgz.gz
20:05:14 <mauke> something like an O(1) space version of 42.zip
20:05:49 <liyang> Can I define a class instance with lambdabot?
20:05:54 <faxathisia> 42 expands to 4.2 GB?
20:05:57 <glen_quagmire> darn that link no good
20:06:00 <mauke> liyang: no
20:06:19 <mauke> faxathisia: http://www.unforgettable.dk/
20:06:25 <lambdabot> Title: 42.zip
20:06:27 <olsner> you should be able to build a different quine which decompresses into a full zip file with file tables etc - I'm not sure all virus scanners actually look inside gzip streams
20:06:34 <faxathisia> ok cool
20:06:54 <mauke> 4.503.599.626.321.920 (4,5PB)
20:07:06 <mauke> -do not attempt-
20:07:19 <olsner> http://www.maximumcompression.com/selfgz.gz for a working link
20:08:03 <dejones> does split() exist in Haskell?
20:08:06 <dejones> can't find it...
20:08:12 <faxathisia> dejones split() is what?
20:08:26 <mauke> dejones: no
20:08:31 <dolio> Wow, 42 bytes into 4.5 petabytes.
20:08:38 <mauke> 42kB
20:08:42 <dibblego> dejones, there is group; maybe you want that?
20:08:42 <dejones> faxathisia: sorry, such as split(",", s) to split a character string by the character comma
20:08:46 <dolio> Oh, right.
20:08:59 <faxathisia> @src words
20:08:59 <lambdabot> words s = case dropWhile isSpace s of
20:08:59 <lambdabot>     "" -> []
20:08:59 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
20:09:17 <dolio> You crazy European folks with your switched periods and commas.
20:09:17 <faxathisia> It's doesn't exist but you can write it similar to this when you want to split on a single char
20:09:32 <mauke> @src lines
20:09:32 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:09:38 <dolio> That's still impressive compression.
20:09:41 <dejones> faxathisia: alright, thanks.  I just want to re-implement something that already existed in Haskell.
20:09:56 <dons> there's no split in the base List library, its kind of an odd hting
20:09:56 <dejones> any idea why split() doesn't exist in Haskell?
20:09:58 <dejones> ;)
20:10:01 <dejones> dons, ahh.
20:10:20 <faxathisia> :t split
20:10:22 <mauke> dejones: sort is not in the Prelude. sequence is.
20:10:22 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
20:10:24 <faxathisia> :t splitBy
20:10:25 <lambdabot> Not in scope: `splitBy'
20:10:25 <mauke> draw your own conclusions
20:10:30 <dibblego> dejones, because there are several versions of such a function
20:10:52 <faxathisia> :t splitOn
20:10:54 <lambdabot> Not in scope: `splitOn'
20:11:02 <dejones> dibblego: I see.
20:11:20 <dolio> Someone should have suggested it when intercalate was being added.
20:11:30 <faxathisia> untercalate :D
20:11:38 <olsner> extracalate?
20:12:37 <mrd> @hoogle splitRegex
20:12:38 <lambdabot> No matches found
20:12:46 <mrd> @info Text.Regex.splitRegex
20:12:46 <lambdabot> Text.Regex.splitRegex
20:12:52 <mrd> @index Text.Regex.splitRegex
20:12:53 <lambdabot> bzzt
20:12:58 <mrd> ah well its there somewhere
20:13:04 <wagle_home> bercalate
20:13:12 <dejones> mrd: Oh.. regex.
20:13:19 <dejones> mrd: thanks
20:13:35 <mauke> @index splitRegex
20:13:35 <lambdabot> Text.Regex
20:13:40 <wagle_home> poor lambdabot misses a lot of whats out there
20:13:57 <mauke> :t Text.Regex.splitRegex
20:13:59 <lambdabot> Text.Regex.Posix.Wrap.Regex -> String -> [String]
20:14:56 <dejones> :)
20:23:17 <liyang> > let fib = fix ( \ f -> let l n = do i <- join $ gets (fromMaybe (f n) . fmap return . M.lookup n); modify (M.insert n i); return i in let fib 0 = return 0 ; fib 1 = return 1 ; fib n = return (+) `ap` l (n - 1) `ap` l (n - 2) in fib ) in evalState (fib 100) M.empty
20:23:17 <lambdabot>  354224848179261915075
20:23:27 <liyang> HALF AN HOUR LATE.
20:24:05 <faxathisia> liyang++
20:24:35 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs); fib = (fibs !!) in fib 100
20:24:36 <lambdabot>  354224848179261915075
20:25:08 <dolio> > fix ((0:) . scanl (+) 1) !! 100
20:25:09 <lambdabot>  354224848179261915075
20:25:25 <faxathisia> > 354224848179261915075
20:25:26 <lambdabot>  354224848179261915075
20:25:31 * faxathisia shortest yet :D
20:25:36 <dolio> Hehehe.
20:26:15 <monochrom> > fffff
20:26:16 <lambdabot>  354224848179261915075
20:26:20 * monochrom ducks
20:26:22 <faxathisia> O:
20:26:26 <faxathisia> ??
20:26:26 <mauke> > 25*14168993927170476603
20:26:26 <lambdabot>  354224848179261915075
20:26:41 <mauke> @define fffff
20:26:42 <lambdabot> Undefined.
20:26:44 <faxathisia> ooh
20:26:47 <QtPlatypus> Maxint?
20:26:51 <monochrom> I cheated :)
20:27:03 <faxathisia> > 2^16*5*11*59*547901*3040061
20:27:03 <lambdabot>  354224848179261931520
20:27:06 <faxathisia> hmf
20:27:08 <dolio> Why'd you use 5 fs, though?
20:27:17 <dolio> You could have used 2 to keep from being golfed.
20:27:43 <monochrom> I cheat with morality.
20:28:07 <mauke> > 0x1333db76a7c594bfc3
20:28:07 <lambdabot>  354224848179261915075
20:28:09 <mrd> > fix ((0:) . scanl (+) 1) :: [Expr]
20:28:10 <lambdabot>  [0,1,1 + 0,1 + 0 + 1,1 + 0 + 1 + (1 + 0),1 + 0 + 1 + (1 + 0) + (1 + 0 + 1),1...
20:28:39 <faxathisia> you can do L-systems with Expr
20:29:22 <monochrom> > product [3, 5, 5, 11, 41, 101, 151, 401, 3001, 570601] == fix ((0:) . scanl (+) 1) !! 100
20:29:23 <lambdabot>  True
20:30:10 <monochrom> I don't understand one thing.  Why does @define undefine?  Confusing name or confusing semantics.
20:30:17 <faxathisia> @bop
20:30:17 <lambdabot> Maybe you meant: bf bug map yow
20:30:20 <faxathisia> @boj
20:30:20 <lambdabot> Maybe you meant: bf bug yow
20:30:22 <faxathisia> @bos
20:30:22 <lambdabot> Maybe you meant: b52s bf bug docs yow
20:30:35 <faxathisia> @wow
20:30:35 <lambdabot> Should I get locked in the PRINCICAL'S OFFICE today -- or have a VASECTOMY??
20:30:44 <mrd> @undefine
20:30:44 <lambdabot> Undefined.
20:30:49 <mauke> monochrom: delta("define", "undefine") == 2
20:30:54 <monochrom> yikes!
20:31:00 <dolio> @list let
20:31:00 <lambdabot> eval provides: run let undefine
20:31:22 <monochrom> @unlet fffff = 5
20:31:23 <lambdabot> Defined.
20:31:38 <mauke> @eval fix id
20:31:44 <monochrom> RIGHT IS LEFT. LEFT IS WRONG. WRONG IS RIGHT.
20:32:05 <shepheb> @b52s
20:32:05 <lambdabot> Hot pants explosion at the factory!
20:32:13 <monochrom> @unb52s
20:32:13 <lambdabot> Hot pants explosion at the factory!
20:32:22 <kpreid> @pl flip (>>>)
20:32:22 <lambdabot> flip (>>>)
20:32:25 <dolio> Wow, same quote twice in a row.
20:32:28 <monochrom> @untype length
20:32:30 <lambdabot> forall a. [a] -> Int
20:32:44 <monochrom> Only regret is @unpl doesn't work. :)
20:32:46 <faxathisia> @unyom
20:32:46 <lambdabot> ()
20:32:48 <faxathisia> @unyom
20:32:48 <lambdabot> ()
20:32:49 <faxathisia> @unyom
20:32:49 <lambdabot> ()
20:32:52 <faxathisia> :S
20:33:05 <monochrom> @help unquote
20:33:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:33:13 <monochrom> @unquote
20:33:13 <lambdabot> ddarius says: [re: a40a15cb.0304160038.585f3e8@posting.google.com ] The best thing to get out of this, I guess,is that Haskell IS becoming more mainstream and even morons have heard of it.
20:33:27 <kpreid> monochrom: since when does @unpl not work? I wrote it, I'd like to know if it's broken
20:33:50 <monochrom> Well, folllowing the foregoing, @unpl should @pl.
20:33:54 <faxathisia> :o
20:34:03 <kpreid> oh.
20:34:06 <monochrom> @unpl \x -> x
20:34:06 <lambdabot> \ x -> x
20:34:11 <monochrom> hehe
20:34:14 <faxathisia> @unpl f . g
20:34:14 <lambdabot> (\ c -> f (g c))
20:34:34 <Igloo> dons: :-)
20:34:41 <hpaste>  dibblego pasted "Base26 to Base10" at http://hpaste.org/6003
20:34:44 <monochrom> @unseen dons
20:34:44 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 24m 48s ago.
20:34:52 <faxathisia> lol monochorm
20:35:01 <faxathisia> monochrom*
20:35:34 <mauke> @unv
20:35:34 <lambdabot> Maybe you meant: run undo unpf unpl url v wn
20:35:48 <faxathisia> @bunyom
20:35:48 <lambdabot> Unknown command, try @list
20:35:52 <mrd> @lurk
20:35:52 <lambdabot>  @where <key>, return element associated with key
20:35:56 <mauke> @unrun ()
20:35:57 <lambdabot>  ()
20:36:00 <faxathisia> @umyom
20:36:00 <lambdabot> Unknown command, try @list
20:36:03 <faxathisia> @unyom
20:36:03 <lambdabot> ()
20:36:13 <faxathisia> I don't know what command that is ..
20:36:31 <faxathisia> @untype ()
20:36:32 <lambdabot> ()
20:36:43 <faxathisia> @rum ()
20:36:44 <lambdabot>  ()
20:38:28 <monochrom> heheh rum
20:38:47 <dolio> @undo
20:38:47 <lambdabot> ()
20:38:57 <monochrom> @untyped id
20:38:57 <lambdabot> Unknown command, try @list
20:39:06 <monochrom> Ah, that's stretching it.
20:39:15 <mauke> 2 is the limit
20:39:23 <mauke> also, info == undo
20:39:25 <dolio> @unyom undo
20:39:25 <lambdabot> undo
20:39:39 <dolio> @unyom do { a <- m ; return a }
20:39:39 <lambdabot> m >>= \ a -> return a
20:40:12 <faxathisia> @bnplo
20:40:12 <lambdabot> ()
20:55:32 <awesame> augh, I need to uninstall hugs
20:56:19 <awesame> I just spent a week suffering because, although I thought I remembered learning that "let" could be used to define functions in the interpreter, it didn't seem to work
20:56:35 <monochrom> that's ghc.
20:56:44 <awesame> turns out the interpreter is named "ghci", and "hugs" is some kind of evil typo
20:56:48 <lispy> yeah, hugs should be deprecated at this point.
20:56:49 <bd_> Specifications are overrated
20:57:11 <bd_> The implementation is the language :D
20:57:29 <mauke> alias ghci=perl
20:57:51 <monochrom> evil typo? :)
20:57:53 <awesame> how does hugs compare to ghc for running haskell scripts?
20:57:57 <bd_> use Embed::GHC;
20:58:08 <awesame> I mean, outside of interpreter mode, where ghci just won
20:58:19 <mrd> ghc --make Program.hs ; ./Program
20:58:28 <mauke> it's pretty bad. it doesn't even support -fglasgow-exts
20:58:46 <lispy> er?  I thought there was a nice little run-haskell
20:59:06 <mrd> sure you can runhaskell Program.hs.  but why would you want to do that?
20:59:07 <awesame> I mean in terms of available language features
20:59:12 <monochrom> runhaskell non-deterministically calls hugs or ghci
20:59:23 <mrd> all the features are in GHC
20:59:31 <monochrom> ghci has more features. hugs has some feature not in ghc.
20:59:39 <mrd> like being slow
20:59:43 <monochrom> TREX
20:59:44 <mauke> or small
20:59:46 <johnnowak> there's TREX
21:00:03 <mrd> ok, I haven't used TREX
21:00:09 <mauke> because it's not in ghc
21:00:13 <monochrom> I haven't either.
21:01:13 <ddarius> Restricted type synonyms are another significant Hugs extension not in GHC.
21:02:34 <awesame> does a large percentage of haskell code in the wild use extensions from either?
21:02:55 <lispy> ghc extensions are pretty widely used, i think
21:02:55 <mrd> I would say a large % of haskell code in the wild uses GHC extensions
21:03:12 <awesame> interesting
21:04:06 <dolio> Restricted type synonyms? Like 'type Num n => Point n = (n,n)' or some such?
21:04:12 <lispy> you can assume that just about any medium sized haskell program using at least one type system extension
21:04:36 <mrd> plain H'98 does get to feel a bit restrictive
21:04:47 <ddarius> dolio: No.
21:05:18 <monochrom> I use ghc wildly.
21:05:28 <ddarius> Several of the most commonly used GHC extensions are supported by Hugs as well.
21:05:51 <mrd> I don't see any reason for a newcomer to use Hugs over GHC
21:06:06 <siti> oh sweet bindings to libcurl :D
21:06:08 <dolio> Oh, I see.
21:06:23 <mrd> so don't sweat the uninstall
21:06:29 <monochrom> WinHugs is one reason.
21:06:34 <ddarius> I don't see any reason for anyone to use Hugs over GHC.
21:06:40 <mrd> "Win"? wuz that
21:06:54 <monochrom> @nogoogle winhugs
21:06:56 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/winhugs/
21:06:56 <lambdabot> Title: Neil Mitchell - WinHugs
21:08:12 <monochrom> Another reason is some linux distros give you headache in installing ghc. (Simply not providing it; providing too old versions; missing libs; ...)  Hugs packaging and installation is consistently smooth.
21:08:39 <mrd> why is that?
21:08:54 <monochrom> Haskell is not as mainstream as Python.
21:08:56 <mrd> because it's not as actively developed?
21:09:05 <mrd> no, why is Hugs consistently smooth?
21:09:13 <mrd> or because it's easier to compile?
21:09:19 <faxathisia> Why not just get a working GHC and then compile the latest.... I always do that it's easy
21:09:25 <monochrom> Written in C.  Trivial "make; make install".
21:09:28 <mrd> yea
21:09:32 <mrd> no bootstrap
21:09:38 * ddarius uses the latest stable binary and calls it a day.
21:09:46 * mrd looks for volunteers to port GHC-bootstrap to hugs
21:09:51 <monochrom> No dependency chasing.
21:10:09 <faxathisia> YUCK
21:10:16 <faxathisia> Have you seen Python source code?
21:10:22 <faxathisia> written in C is not a good thing..
21:10:39 <faxathisia> It's not even worth trying to fix bugss
21:10:47 <mrd> it makes bootstrapping much easier on linux distros that have C compilers packaged
21:10:58 <monochrom> I am speaking from the POV of distro admins.
21:11:05 <faxathisia> also make often breaks and you need to sort lots of crap out
21:11:17 <mrd> sure, i wouldn't want to write a compiler in C
21:11:23 <monochrom> Hugs source tree is simple enough to be a run-of-the-mill make.
21:11:42 <monochrom> Hugs is small.  Easy to build.  No hassle.
21:11:51 <mrd> Free Hugs!
21:12:00 <mrd> No obligation
21:12:12 <ddarius> Void where prohibited
21:12:22 <monochrom> So whenever a user requests a distro to include hugs, maintainers say "oh, no problem!" even though it's supposed to be fringe.
21:12:40 <monochrom> Whereas GHC is "it's a pain, *and* it's fringe".
21:12:44 <mrd> on the CL side, when SBCL finally achieved bootstrap from CLISP, it made way for an easy path from GCC -> SBCL, which was nice for distros.
21:13:28 <mrd> but GHC uses a lot of GHC-specific features, so I don't think that'll ever happen
21:13:33 * ddarius rewrites GHC in CL.
21:13:48 <mrd> woot, GCC -> CLISP -> SBCL -> GHC
21:14:07 <faxathisia> now that's high level...
21:14:07 * mrd seems to recall a haskell compiler written in CL, actually
21:14:19 <ddarius> GCC -> CLISP -> SBCL -> GHC -> GHC
21:14:24 <lispy> i'd like to see someone write a gcc clone in GHC using extensions only ghc supports
21:14:25 <mrd> was that the original GHC?
21:14:38 <ddarius> mrd: Heck no.
21:14:40 <lispy> so that it becomes a chicken 'n egg problem to boostrap ghc :)
21:15:36 <ddarius> If I recall correctly, GHC was written in Haskell and compiled by HBC which was written in Lazy ML
21:17:42 <ddarius> LML was written in LML, I'm not sure what it was bootstrapped with.
21:18:11 <faxathisia> maybe the compiler happens to be a ML LML polyglot :D
21:18:44 <ddarius> Possibly.  ML would seem to be the obvious language to bootstrap with.
21:19:26 <ddarius> augustss would know
21:21:09 <bos> all the juicy detail is behind the ACM paywall: http://portal.acm.org/citation.cfm?id=800055.802038
21:21:13 <lambdabot> Title: A compiler for lazy ML
21:21:29 <mrd> ah it was Yale Haskell
21:21:32 <ddarius> bos: Or we could just ask augustss
21:21:35 <mrd> compiled to CMUCL
21:21:39 <bos> yes, but he's asleep.
21:22:04 <ddarius> mrd: Yeah.  I knew one of them was, but not in GHC's background.
21:22:27 <blt> If someone has a place I could upload the paper, I'll upload it for all to read.
21:22:37 <blt> (Don't tell the ACM.)
21:36:53 <biouser> lambdabot, I hear you are incredible
21:37:19 <biouser> >2*@
21:37:22 <dolio> @vixen Are you incredible?
21:37:22 <lambdabot> first you tell me.
21:38:07 <biouser> @vixen do you have a pdf talking about yourself?
21:38:08 <lambdabot> maybe. do you?
21:38:48 <biouser> :source map
21:39:04 <Cale> @src map
21:39:04 <lambdabot> map _ []     = []
21:39:04 <lambdabot> map f (x:xs) = f x : map f xs
21:39:50 <Cale> hmm...
21:39:52 <biouser> @hoogle foldr
21:39:52 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
21:39:52 <lambdabot> Data.List.foldr :: (a -> b -> b) -> b -> [a] -> b
21:39:52 <lambdabot> Data.Foldable.foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
21:40:08 <Cale> :t \f -> foldr ((:) . f) []
21:40:12 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
21:40:53 <Cale> okay, good, I'm still sane -- no wacky consequences of generalising (.) there :)
21:41:39 <monochrom> Thanks to modularity.
21:42:34 <Cale> Thanks to foldr wanting a function :)
22:12:25 * gwern is pleased to see the hoogle release on hackage
22:21:11 <Lemon> does everybody here use darcs or something?
22:21:34 * dolio uses darcs.
22:22:07 <jeffz> inclinded to use git for my next project
22:23:22 * sm uses darcs, but no longer for everything
22:25:42 <dejones> I'm using the HashTable and upon lookup it returns "Just val" how can I display the val and not the Just part?  I was using "show v" and it says Just val ;)
22:25:54 <glguy> Lemon: we're switching to git :)
22:26:10 <dolio> > fromJust (Just 5)
22:26:12 <lambdabot>  5
22:26:24 <Lemon> glguy, what? Why?
22:26:31 <dolio> > fromMaybe 1 (Just 5)
22:26:32 <Lemon> I just went through the darcs tutorial.
22:26:32 <lambdabot>  5
22:26:35 <dejones> dolio: thanks, didn't see that one on the Maybe in the API
22:26:36 <dejones> :)
22:26:45 <dolio> > fromMaybe 1 (Nothing)
22:26:45 <lambdabot>  1
22:26:49 <dolio> > fromJust (Nothing)
22:26:50 <lambdabot>  Exception: Maybe.fromJust: Nothing
22:26:51 <dejones> lol
22:29:24 <glguy> Lemon: darcs is good to know still
22:29:32 <glguy> most projects today are in it
22:29:40 <sm> darcs and git are the two to know imho
22:29:41 <Lemon> ...Haskell projects.
22:29:45 <glguy> yeah
22:29:50 <glguy> are there other kinds?
22:30:00 <dolio> What about mercurial?
22:30:12 * glguy isn't seen an hg presence in haskell projects
22:30:16 <sm> bzr just won't go away and I think mercurial, good as it is, is for the chop
22:31:08 <Pseudonym> Most Haskell projects are in darcs.
22:31:14 <dolio> I can't say I've seen much of a git presence, either.
22:31:24 <Pseudonym> Pretty much all sourceforge projects are CVS or SVN.
22:31:34 <sm> pshhh, mention them not
22:31:36 <Pseudonym> AFAIK only the Linux kernel and git itself use git.
22:31:41 <dejones> Haskell is fun.  :)  I like the language more every day.
22:31:54 <jeffz> Pseudonym: the wine project has been using git for some time
22:31:56 <glguy> ?seen dons
22:31:56 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 40m 45s ago.
22:31:56 <sm> git is all-conquering.. the activity on the list is scary
22:31:59 <Pseudonym> Right.
22:31:59 <jeffz> don't mozilla also use git?
22:32:03 <dejones> Have a great night everyone.  g'night.
22:32:09 <Pseudonym> Night.
22:32:10 <DuClare> dejones, Man I hope I'll be like you
22:32:17 <dejones> DuClare: Give it time.  :)
22:32:21 <DuClare> I have so little energy to study
22:32:36 <DuClare> dejones, I've intented to learn haskell thoroughly but I simply can't find effective time :(
22:32:40 <dejones> DuClare: Yea, I just finished some Distrbuted OS homework earlier... one question proof, bah! hehe
22:32:41 <DuClare> I'm not even that busy, but tired always.
22:32:52 <dejones> DuClare: depressed?  ;)
22:32:57 <DuClare> A little
22:33:00 <dejones> Yea.
22:33:12 <dejones> Exercise... it really does help.  Chemically helps makes you happier.
22:33:19 <dejones> I know it's hard to get motivated, but do it.
22:33:21 <dolio> Or drink more Mountain Dew.
22:33:31 <dejones> haha, dolio, that doesn't really help in the long-term.  :P
22:33:32 <dhpeterson> Pseudonym: use of git seems to be taking off in the ruby community, as an alternative to svn
22:33:33 <DuClare> dejones, An inherited problem, sort of a disease, which makes it hard to fall asleep so I live with very short eyeshut :o
22:33:46 <DuClare> dejones, School and everything makes me so tired.  Such a burden.
22:33:51 <dejones> Yea...
22:33:59 <Pseudonym> I personally don't see the advantage to using git over hg, unless you're a seriously massively parallel project.
22:34:00 <DuClare> So when it's the weekend or a short holiday, I can only spend it trying to get relaxed a bit
22:34:07 <jeffz> list of projects that use git. http://git.or.cz/gitwiki/GitProjects
22:34:09 <dhpeterson> Pseudonym: and the launch of sites like github.com
22:34:09 <lambdabot> Title: GitProjects - GitWiki
22:34:23 <dejones> Exercise helps me have better sleeping patterns and overall improved happiness plus less stress.  :)
22:34:30 <dejones> Works for me... try it out.
22:34:34 <Pseudonym> If you're as popular as the Linux kernel, then I can see the advantage of carrying your SHA-1 signature around.
22:34:50 <Pseudonym> But like everything that Linus touches, git is optimised for Linus.
22:34:56 <sm> dejones: nice reminder, thanks :)
22:34:57 <dejones> DuClare: Good luck.  I must get to sleep.  Early morning class.
22:35:06 <Lemon> http://www.xmonad.org/images/screen-triplehead-galois.png
22:35:07 <DuClare> dejones, Good night, do rest well :)
22:35:10 <dejones> Thank you.  :)
22:35:16 <Lemon> this dude's setup looks HARDCORE
22:35:35 <glguy> thanks ;)
22:35:52 * sm lol at github.com front page
22:35:55 <dolio> Hey, I have that mouse. Or one like it.
22:36:01 <Lemon> glguy, that's yours?
22:36:13 <glguy> yes
22:36:17 <Lemon> damn.
22:36:25 <dhpeterson> sm: heh yeah
22:36:55 <glguy> dolio: I've got one at work and one at home, I really like them
22:37:05 <siti> mx518s :)
22:37:10 <glguy> I can't bring myself to buy one of those keyboards for home yet though
22:37:33 <Pseudonym> Nytol!
22:38:21 <wagle_home> buy!
22:38:26 <Lemon> I need another Haskell practice project.
22:39:16 <Lemon> any suggestions?
22:39:16 <lamentb> me too!
22:42:24 <sarehu_> make a COBOL to BF compiler... in the type system!
22:43:12 <lispy> suppose you had an engine in C/C++ and you wanted to extend it via a scripting language.  Further suppose you wanted Haskell to be that scripting language.  What are some of the ways you'd do this?
22:43:34 <lamentb> "use ffi"
22:43:42 <wagle_home> hmm..  i need to write a scheme interpreter in the type system
22:44:11 <lispy> lamentb: so, the Haskell code would export it's entry points as C functions?
22:46:45 <lamentb> lispy: or the other way... in Python, people strongly prefer extending Python with C to embedding Python in C, and i'm guessing in haskell it's similar?
22:47:05 * glguy embedded python in haskell :)
22:47:50 <OceanSpray> you usually embed the lower level language in the higher one, not the other way around.
22:48:46 <lispy> lamentb: huh?
22:48:55 <Mr_Awesome> OceanSpray: thats not true
22:49:08 <OceanSpray> Mr_Awesome, oh?
22:49:17 <lamentb> lispy: so the haskell code would import the C code's entry points.
22:49:30 <OceanSpray> I've been living a lie.
22:49:32 <lispy> lamentb: oh, no that won't do here
22:49:45 <Mr_Awesome> OceanSpray: for example, many people embed a scripting language in a C++ app
22:49:55 <lispy> lamentb: the C/C++ code is the application already
22:49:59 <OceanSpray> not applications.
22:50:05 <OceanSpray> languages themselves.
22:50:45 <lispy> lamentb: so, I want to allow scripts to be "plugged in to" the application.  It would be dreamy if Haskell was the language for those scripts
22:51:26 <Mr_Awesome> well wouldnt that also be higher level? if you embed a language in a language, you get all the benefits of the base language to build from, making the result usually higher level
22:54:18 <jeffz> lispy: this project uses C and C++?
22:54:39 <lispy> jeffz: yeah, it's written completely in c/c++
22:54:45 <jeffz> lispy: C _AND_ C++?
22:55:46 <faxathisia> C/C++ is a language of it's own
22:55:51 <lispy> jeffz: is it really necessary to be so pedantic as to determine if the subset of C that it uses is truely C?  It definitely takes advantage of C++ features, but at times is very low level for C++.
22:56:05 <jeffz> lispy: it is necessary to be so pedantic because they are different languages.
22:56:10 <faxathisia> lispy: That's C++ Then *not* C
22:56:16 <faxathisia> lispy: They are totally differet
22:56:23 <lispy> <sigh> I expect better from #haskell
22:56:34 <dons> glguy: woot
22:56:45 <faxathisia> lispy: better than what?
22:56:45 <swidgy> lispy: i agree with the rest.  it's c++, no matter how many features you're not taking advantage of
22:57:02 <faxathisia> lispy: You seem to be suggesting C++ is C? That's obviously false
22:57:04 <jeffz> lispy, C/C++ refers to a different language which isn't C or C++, specified by Richard Heathfield
22:57:50 <faxathisia> lispy: It's like saying, This is common lisp.. I just happen to use some scheme features
22:58:02 <Mr_Awesome> like hygienic macros :)
22:59:37 <johnnowak> faxathisia: No it isn't. Scheme isn't close to being a subset of common lisp.
22:59:56 <faxathisia> johnnowak: C isn't a subset of C++ either
23:00:00 <jeffz> lispy: for your reference, http://www.cpax.org.uk/prg/portable/c/c++/rfe00003.html
23:00:00 <lambdabot> Title: C/C++ Request For Enlightenment 3 - Sample Programs
23:00:50 <johnnowak> faxathisia: sure, but it's quite close
23:01:53 <swidgy> jeffz: that's actually kinda fascinating, but 99.999999% of all references to "c/c++" refer in a general way to the original two languages, rather than this interesting variant
23:02:23 <jeffz> swidgy: all references are misinformed misuses in 99.99999% of those cases.
23:02:41 <swidgy> jeffz: heh... perhaps, but still...
23:02:48 <dolio> It has a built-in hello world command?
23:03:44 <Mr_Awesome> im looking for a data structure that is similar in shape to this: data D k a = D a (Map k (D k a)). is there anything already written that i could use, or will i have to write it myself?
23:04:30 <glguy> is that a "Trie"
23:05:26 <dolio> Looks like a trie to me.
23:05:33 <dolio> For [k] keys, I think.
23:07:56 <Mr_Awesome> hmm, i think it is something like a trie
23:08:16 <dolio> Edison seems to have a trie.
23:09:11 <dolio> They're notably absent, considering they're a nice functional data structure.
23:09:35 <dolio> I guess people have been waiting for type families to implement generalized tries.
23:09:44 <dolio> Or something like that.
23:12:18 <decker> if i'm using findIndex, how do i get an Int back instead of Maybe Int
23:12:25 <decker> or conversely, how do I use Maybe Int?
23:13:40 <oerjan> decker: pattern matching, or the maybe and fromMaybe functions
23:13:48 <decker> thnx
23:14:03 <oerjan> > case Just 3 of x -> show x; _ -> "no number"
23:14:04 <lambdabot>      Warning: Pattern match(es) are overlapped
23:14:04 <lambdabot>              In a case alterna...
23:14:11 <Mr_Awesome> dolio: what needs to be generalized further from my example? the Map part?
23:14:13 <oerjan> oops
23:14:23 <oerjan> > case Just 3 of Just x -> show x; Nothing -> "no number"
23:14:24 <lambdabot>  "3"
23:15:22 <dolio> Mr_Awesome: Well, the generalized tries stuff generally builds them from the ground up over all algebraic data types.
23:15:34 <xpika> is it possible to run xmonad on top of kde?
23:15:40 <dolio> GTrie () a = Maybe a
23:16:03 <dolio> GTrie (Either k1 k2) a = (GTrie k1 a, GTrie k2 a)
23:16:24 <dolio> GTrie (k1, k2) a = GTrie k1 (GTrie k2 a)
23:18:03 <dolio> Not sure about the general form of the trie of a fixpoint.
23:19:10 <Mr_Awesome> what about GTrie [k] a? is that what i have?
23:19:56 <dolio> GTrie [k] a = (Maybe a, GTrie [k] a), though (I think; [k] -> Either () [k]).
23:20:07 <dolio> Which is, essentially, what you have.
23:21:15 <dolio> Aside from the fact that you can't represent tries where, say, [1,2,3] is mapped to a value, but [1,2] isn't.
23:21:24 <dolio> (Due to the lack of Maybe).
23:22:07 <Mr_Awesome> but you have maybe in there
23:22:09 <dolio> Oh, sorry, that should be: (Maybe a, GTrie k (GTrie [k] a)).
23:22:33 <jsnx> > tails [1..]
23:22:34 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:22:47 <jsnx> [1..]
23:22:56 <jsnx> > [1..]
23:22:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:22:59 <dolio> And yours uses Map k instead of GTrie k, and Map is a balanced binary tree (not that that makes your structure not a trie).
23:24:47 <faxathisia> > tail $ tails [1..]
23:24:48 <lambdabot>  [[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
23:25:04 <dolio> Anyhow, what that does, given type families, is let you build maps GTrie k that take advantage of the structure of k for efficiency.
23:25:17 <dolio> But they still provide a generic interface, like Map.
23:26:13 <dolio> Map [k] has to compare lists at each node, for instance, which is likely to be slower than a trie for lists.
23:27:30 <Mr_Awesome> i see. so does it have to be possible for a Trie to be empty?
23:28:16 <dolio> Well, generally you want an empty map to be a possibility.
23:28:38 <Mr_Awesome> right. and Trie k is essentially Map k?
23:29:01 <dolio> Or to be able to insert a value with key l :: [k] without having values for all prefixes of l in the map, as well.
23:29:23 <dolio> Yeah, that's what they're mainly used for, I think.
23:29:28 <dolio> Maps and sets.
23:30:08 <jsnx> on nice thing about a trie is not only tells you when a certain key isn't in the map -- it lets you know at what *substring* of the key is not in the map
23:30:37 <jsnx> so, if you are looking for words
23:30:50 <jsnx> the words 'cat' is in the map
23:30:53 <jsnx> and 'catty'
23:30:59 <jsnx> but not 'catt'
23:31:16 <jsnx> if you just tried to get the longest consecutive match, you'd give up too early
23:31:54 <jsnx> the trie allows you to encode "nothing here, but more in that direction"
23:38:08 <Mr_Awesome> dolio: nearly everything ive seen in the past few minutes of looking around about tries has been using them with [Char] as the key
23:39:10 <Mr_Awesome> is it really necessary to implement Tries of other algebraic data types (or would the results even be considered Tries)?
23:42:13 <dolio> Well, you want maps of any (reasonable) key type, right?
23:43:07 <dolio> And don't want to have to bother with using multiple maps depending on what key you want.
23:45:12 <dolio> I suppose in general you might just define a GMap interface and use tries for some types and possibly other maps for other types if it's more efficient.
23:45:26 <dolio> Although IntMap uses a trie.
23:46:21 <ryani> Anyone read the functional pearl on solving the expression problem in Haskell?
23:46:50 <faxathisia> which expression problem?
23:47:08 <oerjan> _the_ expression problem
23:48:52 <ryani> It seemed like an interesting approach.  But my brain has a hard type wrapping itself around types like "newtype Expr f = In (f (Expr f))".  I guess I should treat it like "fix" (which also makes my brain hurt).
23:49:16 <Mr_Awesome> dolio: perhaps. but i think one of the redeeming features of a trie (the reason im using it at least) is that it can efficiently return the set of all values with a given prefix
23:49:39 <Mr_Awesome> *values mapped to a key with a given prefix
23:50:09 <Mr_Awesome> i dont think that would be expected from a Map [k]
23:51:28 <dolio> Yeah. That'd be a more specialized use than you'd get from a general map interface.
23:52:30 <dolio> Or even a generalized trie, I suppose, since talking about a prefix of (Char,Char) doesn't necessarily make sense.
23:55:05 <quicksilver> you could often think of an encoding which made prefix sensible.
23:55:16 <quicksilver> for example, if your key type was (Int,Int,Int)
23:55:17 <dolio> Yeah.
23:55:22 <quicksilver> then a prefix might be 1 or 2 coordinates.
23:55:37 <quicksilver> I'm not sure if that's genereally useful or just a cute curiosity though :)
23:55:59 <Mr_Awesome> yes, that would make sense. but i think [Int] would do just fine in that case
23:58:59 <Mr_Awesome> really my point is that i dont see how data Trie k a = Trie (Maybe a) (Map k (Trie k a)) needs any more generalization
