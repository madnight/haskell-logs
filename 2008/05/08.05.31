00:00:07 <newsham> (or kmp)
00:02:18 <dobblego> @src (->) (.)
00:02:19 <lambdabot> Source not found. My brain just exploded
00:04:30 <Cale> @src (->) fmap
00:04:31 <lambdabot> fmap = (.)
00:04:34 <Cale> hehe
00:04:37 <Cale> @src (.)
00:04:38 <lambdabot> (f . g) x = f (g x)
00:04:38 <lambdabot> -- In lambdabot, it's been generalised to:
00:04:38 <lambdabot> (.) = fmap
00:06:33 <opqdonut> Cale: :P
00:07:16 <dolio> fmap = fmap. Oh no!
00:41:16 <dcoutts> TomMD: no, it needs a newer version than what is in the head darcs repo :-) you want the cabal-1.4 branch
00:42:07 <dcoutts> TomMD: since we expect to actually release Cabal-1.4 and cabal-install has to work with it, that's why we've got a 'stable' branch
00:43:21 <dcoutts> TomMD: the next dev version is going so quickly acquire changes which will make it incompatible with any released cabal-install, which is why cabal-install now depends on Cabal >=1.3.11 && <1.5
00:48:25 <newsham> dcoutts: is there a win32 bin for gtk2hs for 6.8.2 somewhere?
00:48:38 <newsham> i saw some metion of nightly builds somewhere?
00:48:39 <dcoutts> newsham: yep
00:48:50 <dcoutts> oh, no nightly builds
00:48:59 <newsham> where can I find it?
00:49:08 <dcoutts> newsham: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe
00:49:39 <newsham> is that different from the 0.9.12.1.exe on sf?
00:50:18 <newsham> (the sf.net version refuses to install in 6.8.2, asking for 6.8.1)
00:50:39 <dcoutts> newsham: right, this is a build with 6.8.2
00:50:45 <newsham> awesome.. many thanks.
00:50:47 <dcoutts> with/for
00:53:07 <newsham> does it come with gtk or do I need to install that first?
00:53:55 <newsham> nevermind
00:57:41 <dcoutts> newsham: it comes with
01:59:25 <vixey> actually I think a compiler is many many many times hard to write than an interpreter
01:59:37 <vixey> despite what everyone said
02:00:18 <mahogny> huh? someone claims it is easier to write a compiler than an interpreter?
02:00:38 <vixey> I read a lot of times it's just as easy
02:00:51 <vixey> (one example, PAIP)
02:01:03 <Staz> mahogny : I just wrote a regexp compiler -- not sure that I agree with that comment :)
02:01:18 <vixey> what does it compile a regex to?
02:01:28 <Staz> a Finite State Machine
02:01:43 <Staz> (not is haskell btw -- the assignment had to be done in java)
02:01:50 <vixey> NFA?
02:01:54 <Staz> yes
02:02:04 <Staz> s/is/in/
02:02:10 <Heffalump> the fiddly thing about writing a compiler is producing the executable format etc
02:02:11 <vixey> 3 lines of Prolog :P
02:02:28 <Heffalump> actually producing machine code (or some other target representation) isn't hard
02:02:33 <mahogny> what Heffalump says. that is an adventure alone
02:03:14 <vixey> the tricky bit for me is, well you need a bit of runtime
02:03:42 <vixey> but I just end up with so much runtime and so little compiler it's practically an interpreter
02:04:08 <vixey> which defeats the purpose :/
02:29:55 <ziman> @hoogle Functor
02:29:56 <lambdabot> Prelude.Functor :: class Functor f
02:29:56 <lambdabot> Control.Monad.Functor :: class Functor f
02:29:56 <lambdabot> Control.Monad.Instances.Functor :: class Functor f
02:52:50 <demonlord0> anyone using gph?
02:52:56 <demonlord0> parallel haskell?
02:56:57 <Baughn> demonlord0: pH? Or data parallel?
02:57:19 <Baughn> demonlord0: I've been curious, but it doesn't seem complete yet, and the stuff in Control.(Concurrent|Parallel) works fine
03:01:48 <demonlord0> whats control concurrent parallel?
03:01:52 <demonlord0> native ghc stuff?
03:02:06 <Baughn> Yes
03:02:47 <Baughn> Neat stuff, most of it. Not as neat as the research you've been looking at, but it's here /now/. ;)
03:13:38 <demonlord0> so can you build like a fast webserver in it?
03:13:39 <demonlord0> :)
03:13:50 <demonlord0> we need like haskell version of php
03:13:52 <demonlord0> :)
03:13:56 <vixey> o_o
03:13:58 <demonlord0> happs I couldnt compile :(
03:14:02 <vixey> you could do a lot better than PHP
03:14:14 <demonlord0> well yeah I mean like html generator
03:14:21 <demonlord0> not crappy memhog
03:14:24 <vixey> I don't think PHP has any facilities for doing that
03:14:56 <vixey> I heard you can have XHTML validity checked in the type system
03:15:13 <demonlord0> agk I mean something that mixes comptations into html allowing dynamic cuntent
04:15:20 <vixey> :t callCC
04:15:24 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
04:15:39 <vixey> :t callCC calCC
04:15:40 <lambdabot> Not in scope: `calCC'
04:15:45 <vixey> :t callCC callCC
04:15:47 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
04:15:47 <lambdabot>       Expected type: ((a -> m b) -> m a) -> m (a -> m b)
04:15:47 <lambdabot>       Inferred type: ((a -> m b) -> m a) -> m a
04:16:05 <vixey> so you can't actually self apply it
04:16:07 <Bonus> what if we did :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) to lambdabot
04:16:08 <Bonus> haha
04:16:14 <vixey> Bonus: try it :P
04:16:23 <Bonus> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
04:16:25 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
04:16:26 <lambdabot> t63 t64 t65 t66 t67 t68 t69. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -
04:16:26 <lambdabot> > t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 ->
04:16:26 <lambdabot> t62 -> t63 -> t64 -> t65 -> t66 -> t67 -> t68 -> t69 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40,
04:16:28 <lambdabot>  t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69)
04:16:30 <Bonus> ah
04:16:32 <vixey> lol
04:16:32 <Bonus> handles it nicely
04:17:03 <vixey> :t callCC >>= \k -> callCC k
04:17:05 <lambdabot>     Occurs check: cannot construct the infinite type:
04:17:05 <lambdabot>       m = (->) (b2 -> ((a -> m b) -> m a) -> b1)
04:17:05 <lambdabot>     Probable cause: `k' is applied to too many arguments
04:17:21 <vixey> :t callCC >>= \k -> k callCC
04:17:23 <lambdabot>     Occurs check: cannot construct the infinite type:
04:17:23 <lambdabot>       a
04:17:23 <lambdabot>       =
04:18:06 * vixey *gives up*
04:19:30 <ttt--> hi, can i find this pdf anywhere? http://www.coverproject.org/TalksUntilSpring2004/DependentTypesInHaskell.pdf
04:19:32 <lambdabot> http://tinyurl.com/59q4uq
04:19:36 <ttt--> the link seems to be dead
04:19:47 <vixey> what's it about?
04:20:09 <ttt--> it was linked on the wiki. John Hughes: Dependent Types in Haskell (some ideas).
04:20:36 <vixey> maybe this is an adequate substitute http://citeseer.ist.psu.edu/466140.html
04:20:37 <lambdabot> Title: Faking It: Simulating Dependent Types in Haskell - McBride (ResearchIndex)
04:52:36 <vixey> oh typeclasses are basically horn clauses?
04:54:18 <myname> hello all! Is there any possibility to have an exclusive access to a file in haskell? Such that another processes are not able to modify a file, if it is already modified by another process?
04:54:59 <ivanm> myname: sounds like something the OS should take care of
04:56:36 <myname> ivanm: sure, but how can I do this? For example in PERL there is a special function flock for this
04:57:15 <myname> so I don't understand how it can be realized in haskell at all...
04:57:49 <myname> I have already googled but without any success
04:58:40 <ivanm> @hoogle file
04:58:41 <lambdabot> System.FilePath :: module
04:58:41 <lambdabot> Prelude.FilePath :: type FilePath
04:58:41 <lambdabot> System.IO.FilePath :: type FilePath
04:58:52 <ivanm> @doc System.FilePath
04:58:52 <lambdabot> System.FilePath not available
05:01:43 <vixey> Foo a, Bar b => Baz q
05:01:51 <vixey> is basically Baz q :- Foo a, Bar b.
05:02:04 <vixey> so I think horn clauses is true
05:02:24 <hansfbaier> Whis is the most mature SQL-Database interface for Haskell, HDBC?
05:02:24 <vixey> resolution doesn't backtrack though but that's ok
05:02:34 <hansfbaier> s/Whis/Which/
05:08:01 <pejo> hansfbaier, check System.POSIX.IO, you have setLock and getLock there.
05:08:12 <pejo> Doh, i mean myname, sorry.
05:09:39 <vixey> what's axiom K?
05:09:58 <hansfbaier> pejo: huh?
05:10:14 <pejo> hansfbaier, that was meant for myname.
05:10:27 <hansfbaier> ok. :)
05:10:40 <myname> pejo: thank you, I have noticed this module however I cannot import this module on the machine where I need it
05:11:32 <pejo> myname, is it running some oddball OS?
05:11:41 <myname> ubuntu I guess
05:12:16 <myname> on my local machine ia also ubuntu and I don't find this module either
05:12:17 <pejo> myname, what error are you getting when you try to import it? (use hpaste if it's a long one)
05:12:27 <myname> pejo: ok
05:13:09 <myname> pejo: just a standard "Could not find module `System.POSIX.IO':"
05:13:41 <qebab> I think it's called System.Posix?
05:14:10 <qebab> yeah, not all-caps
05:14:11 <myname> qebab: indeed!
05:14:33 <myname> and I see setLock & getLock here!
05:14:58 <myname> qebab: pejo: thank you very much! :)
05:23:29 <Corun> Hey, does #haskell have one of those map things that people add their location on?
05:40:42 <byorgey> @tell Corun http://haskell.org/haskellwiki/Haskell_user_locations
05:40:42 <lambdabot> Consider it noted.
06:31:24 <ariep> hi
06:31:49 <ariep> i'm struggling to install the plugins package
06:31:58 <ariep> it seems to be some cabal version problem
06:32:06 <ariep> could someone possibly help me?
06:38:30 <byorgey> ariep: what errors are you getting?
06:39:05 <ariep> is it ok to post the cabal error message? it's a few lines
06:40:13 <ariep> cabal: internal error: could not construct a valid install plan.
06:40:13 <ariep> The proposed (invalid) plan contained the following problems:
06:40:13 <ariep> Package Cabal is required by several packages, but they require inconsistent versions:
06:40:13 <ariep>   package ghc-6.8.2 requires Cabal-1.2.3.0
06:40:13 <ariep>   package plugins-1.2 requires Cabal-1.5.2
06:41:50 <byorgey> yikes
06:42:06 <byorgey> Cabal-1.5.2 isn't even released, I don't think
06:42:23 <ariep> well, there are 3 cabal entries in "ghc-pkg list"
06:42:29 <byorgey> which ones?
06:42:32 <ariep> one of which is 1.5.2
06:42:34 <byorgey> ah
06:42:45 <byorgey> you've got the darcs version of Cabal?
06:42:50 <ariep> that's right
06:43:01 <ariep> is that a bad idea?
06:43:04 <byorgey> no
06:43:29 <byorgey> I have it too =)
06:43:34 <ariep> :)
06:44:14 <byorgey> if plugins really requires both Cabal-1.5.2 and ghc-6.8.2, then it would seem that the plugins package is broken.
06:44:22 <ariep> mm
06:44:32 <byorgey> look in the plugins.cabal file -- does it really say Cabal>=1.5.2 ?
06:44:56 <byorgey> I wonder if it is just choosing the latest version because it can when an older version of Cabal would work just as well
06:45:12 <ariep> no, the hackage plugins.cabal says "Cabal (>=1.2.3)"
06:45:27 <byorgey> oh, hmm
06:46:15 <ariep> i installed cabal-darcs (i'm on gentoo, and that gave the 1.5.2 version) to be able to use cabal-install
06:46:23 <byorgey> sure
06:47:01 <ariep> although strange enough, cabal-install claims to use version 1.3.11 of cabal
06:47:04 <byorgey> well, one hack-ish method which would probably work is to edit plugins.cabal so that it says Cabal (==1.2.3)
06:47:09 <ariep> but i don't mind about that, really
06:47:15 <ariep> right
06:47:29 <byorgey> to force it not to choose the newer version
06:47:37 <ariep> can i do that in the cabal-install cache folder?
06:47:48 <ariep> i should i create a more permanent copy of the package
06:47:53 <byorgey> no idea =)
06:47:56 <ariep> s/i/or
06:48:02 <ariep> ok
06:48:16 <ariep> i'll just try something
06:48:21 <ariep> thanks a lot
06:48:26 <byorgey> sure =)
07:15:15 <mar77a> > 7*100000 / 5
07:15:17 <lambdabot>  140000.0
07:15:30 <mar77a> > 140000 / 355
07:15:31 <lambdabot>  394.36619718309856
07:15:52 <mar77a> > 140000 / 7
07:15:53 <lambdabot>  20000.0
07:23:46 <vixey> :[
07:23:58 <vixey> libraries are hard to navagate
07:24:42 <cognominal_> what the invocation to get the bot to give the type  of an expression
07:24:43 <cognominal_> ?
07:24:48 <Botje> :t snd
07:24:50 <lambdabot> forall a b. (a, b) -> b
07:24:57 <vixey> @type 2
07:24:59 <lambdabot> forall t. (Num t) => t
07:25:28 <vixey> hey has anyone read Computation and Reasoning, A Type Theory for Computer Science?
07:26:01 <cognominal_> @type .
07:26:03 <lambdabot> parse error on input `.'
07:26:06 <vixey> :t (.)
07:26:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:26:49 <vixey> (a -> m) -> (m -> z) -> (a -> z) being an instance of that
07:26:56 <vixey> :t (.) :: (a -> m) -> (m -> z) -> (a -> z)
07:26:58 <lambdabot>     Couldn't match expected type `m' against inferred type `z'
07:26:58 <lambdabot>       `m' is a rigid type variable bound by
07:26:58 <lambdabot>           the polymorphic type `forall a m z. (a -> m) -> (m -> z) -> a -> z'
07:27:11 <vixey> I made a mistake ;s
07:27:20 <vixey> :t (.) :: (m -> z) -> (a -> m) -> (a -> z)
07:27:22 <lambdabot> forall m z a. (m -> z) -> (a -> m) -> a -> z
07:27:41 * vixey wishes for (<-)
07:30:20 <cognominal_> @type ($)
07:30:22 <lambdabot> forall a b. (a -> b) -> a -> b
07:30:49 <vixey> :t flip id
07:30:51 <lambdabot> forall b c. b -> (b -> c) -> c
07:31:12 <ttt--> i havent, is it good, vixey
07:31:15 <vixey> ?djinn a -> (a -> (a -> z) -> z) -> z
07:31:16 <lambdabot> -- f cannot be realized.
07:31:30 <vixey> ttt--: I got so lost in the big library I didn't find it :[
07:33:34 <vixey> computable and constructive reals and just the same thing right?
07:34:20 <mattam> I think so.
07:37:50 <quicksilver> vixey: IME computable is the common term. You speak of computable reals but constructive arithmetic.
07:38:08 <quicksilver> vixey: having said that, I'm sure constructive real must mean the same thing.
07:38:15 <Botje> :t isSpace
07:38:17 <lambdabot> Char -> Bool
08:03:14 <cognominal_> :t ($)
08:03:16 <lambdabot> forall a b. (a -> b) -> a -> b
08:03:46 <MedeaMelana> ($) is pretty much the id for function types
08:23:33 <wjt> MedeaMelana: ($) *is* id :)
08:24:51 <ziman> :t flip (flip id)
08:24:53 <lambdabot> forall a c. (a -> c) -> a -> c
08:25:00 <ziman> ;)
08:33:17 <vixey> @@ @djinn @type ($)
08:33:19 <lambdabot>  f a = a
08:34:17 <rahikkala> @help @
08:34:17 <lambdabot>  @ [args].
08:34:17 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
08:34:17 <lambdabot>  The commands are right associative.
08:34:17 <lambdabot>  For example:    @ @pl @undo code
08:34:17 <lambdabot>  is the same as: @ (@pl (@undo code))
08:34:19 <pgavin> @seen dcoutts
08:34:19 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
08:34:32 <pgavin> uhh
08:34:38 <pgavin> lambdabot broke?
08:34:39 <vixey> preflex: seen dcoutts
08:34:39 <preflex>  dcoutts was last seen on #gentoo-haskell 6 hours, 48 minutes and 16 seconds ago, saying: hia ivanm
08:34:44 <vixey> yes lambdabot is broken
08:34:49 <pgavin> heh
08:34:55 <pgavin> how did that happen?
08:47:14 <jdrake> Good day
08:47:58 <shapr> Hiya!
08:48:09 <jdrake> Has anyone read "Programming in Haskell"? I am curious if it is useful or not.
08:49:14 <newsham> jdrake: graham hutton's book?
08:50:06 <newsham> i like the book, my biggest complaint is that its a little thin.
08:50:34 <jdrake> I was thinking that at the page count vs. price
08:50:50 <jdrake> Now I already have the haskell school of expression I was going to take a lot at.
08:51:13 <jdrake> I have also thought of getting the purely functional data structures book as well
08:55:30 <newsham> i havent read those other books
08:56:09 <vixey> @seen Cale
08:56:09 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
08:56:35 <shapr> @seen lambdabot
08:56:35 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
08:56:38 <shapr> aww
08:57:09 <jdrake> This desk would be cool: http://www.tomspinadesigns.com/SlideShow_assets/SlideShow.html?lang=en
08:57:10 <lambdabot> Title: Slide Show, http://tinyurl.com/5adsa2
08:58:27 <dbueno> dcoutts_: yarr?
08:59:21 <dbueno> dcoutts: yarr?
09:05:45 <llingvo> Hi.  How do I get glade to work with Haskell?  I've installed gtk2hs, but running setup.lhs (>import Distribution.Simple
09:05:46 <llingvo> > main = defaultMain
09:05:46 <llingvo>  ), I am told "Setup.lhs: At least the following dependencies are missing:
09:05:46 <llingvo>     glade -any".  I'm using Gentoo, and have asked #gentoo-haskell with no response.  Any advice?
09:05:46 <lambdabot>  Parse error at "=" (column 6)
09:07:16 <Botje> llingvo: you created your own cabal environment?
09:07:24 <Botje> did you check the *.cabal file it created?
09:07:45 <Botje> hmm, wait
09:07:57 <Botje> what does ghc-pkg list glade say?
09:08:10 <llingvo> Botje: I didn't create my own cabal environment as far as I know; I'm trying to install http://pithyless.com/blog/2008/05/18/hback-haskell-n-back-memory-game/
09:08:11 <lambdabot> Title: 9 Pithyless 2d » hback - A Haskell N-Back Memory Game 49, http://tinyurl.com/5n9qqv
09:08:30 <llingvo> it says "/usr/lib64/ghc-6.8.2/package.conf:"
09:09:27 <Botje> then you'll need to install the haskell glade pacakge too
09:10:14 <Botje> blah
09:10:20 <llingvo> Hm.  Do you have any idea what it would be under Gentoo?  I've been looking, but the only references to 'glade' under dev-haskell/ are in gtk2hs (which I already have installed), and the haskell overlay has no packages with 'glade' in the name.
09:11:08 <llingvo> (barring that - where do I get it?  Googling showed me a variety of tutorials that used gtk2hs and glade, but I didn't see anything about glade bindings beyond what there may be in gtk2hs)
09:11:12 <Botje> you enabled the glade flag when building gtk2hs, right?
09:11:15 <llingvo> hmm
09:11:21 <Botje> yeah, apparently glade is included with gtk2hs
09:11:33 <llingvo> nope!  D'oh.  Thank you
09:11:43 <Botje> heh, np
09:11:51 <Botje> gentoo can be confusing from time to time :)
09:11:53 <Botje> << ETQW
09:12:09 <llingvo> (I ran emerge -va to begin with to look at the use flags, and yet somehow this escaped me...... again, thanks!)
09:12:34 <llingvo> Eh, yeah; I've been using it from '02, but it definitely allows carelessness to bite quickly, hard, and in ways that can take a while to track down :P
09:27:01 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8008
09:39:34 <vixey`> > let hippo = ((sqrt 2)::CReal) in (hippo ^ hippo)
09:39:35 <lambdabot>   add an instance declaration for (Integral CReal)
09:39:35 <lambdabot>     In the expression:
09:39:35 <lambdabot>    ...
09:39:45 <vixey`> > let hippo = (sqrt (2::CReal)) in (hippo ^ hippo)
09:39:45 <lambdabot>   add an instance declaration for (Integral CReal)
09:39:45 <lambdabot>     In the expression:
09:39:45 <lambdabot>    ...
09:39:52 <vixey`> does CReal not do sqrt?
09:39:56 <vixey`> .... :(
09:40:13 <vixey`> or is exponentiation the problem
09:41:59 <shachaf> vixey`: Use another exponentiation operator.
09:42:04 <shachaf> @ty (^)
09:42:05 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
09:42:15 <shachaf> Notice that b hsa to be Integral.
09:42:18 <shachaf> @ty (**)
09:42:20 <lambdabot> forall a. (Floating a) => a -> a -> a
09:42:25 <vixey`> > let hippo = (sqrt (2::CReal)) in (hippo ** hippo)
09:42:26 <lambdabot>  1.6325269194381528447734953810247196020791
09:44:01 <vixey`> > let hippo = (sqrt (2::CReal)) in (hippo ** hippo ** hippo)
09:44:02 <lambdabot>  1.7608395558800280907566498956383727480798
09:44:14 <vixey`> is one of those two rational?
09:44:45 <vixey`> I don't think tortiose and hare cycle checking would constitute a proof
09:45:02 <vixey`> but i
09:45:05 <esap> vixey: that's a standard example
09:45:23 <vixey`> but I'm sure it would indicate which
09:45:42 <vixey`> how would you prove it?
09:45:58 <esap> vixey: The proof that one of those is rational doesn't determine which one is.
09:46:15 <vixey`> esap: I know
09:46:20 <SamB_XP> stupid non-constructive proofs
09:46:23 <vixey`> I'm asking which one is rational :P
09:46:41 <vixey`> more importantly how to prove it
09:47:27 <SamB_XP> vixey`: difficult questions you ask
09:47:52 <SamB_XP> since as you know rationality is completley undecidable in the direct representation
09:48:06 <vixey`> SamB: I'm reading about a constructive proof of fundamental theorem of algebra
09:48:13 <vixey`> It's really hard 2_
09:48:33 <SamB_XP> vixey`: if you could find some way of representing them that would make it semi-decidable, you could decide which was rational
09:48:44 <SamB_XP> (by interleaving the semi-decisions)
09:49:10 <vixey`> yeah I really have a doubt that's possible
09:49:20 <SamB_XP> yeah ;-)
09:49:34 <SamB_XP> I don't know though, since I don't know much about reals
09:49:35 <vixey`> I'm wondering if the cauchy sequence will end up with z_n = z_n+1
09:49:44 <vixey`> if you looked and saw that, would that count as a proof?
09:50:03 <SamB_XP> I ... don't know enough about cauchy sequences to say
09:50:16 <vixey`> me neither :p
09:50:20 <SamB_XP> what controls what the next term will be?
09:50:31 <SamB_XP> I don't even remember what they are, if I knew...
09:50:35 <vixey`> I think that's different for various calculations
09:52:48 * SamB_XP thinks wikipedia should mandate mathworld links for topics actually covered in mathworld
09:53:27 --- mode: irc.freenode.net set +o ChanServ
09:55:43 <eu-prleu-peupeu> hello
09:57:19 --- mode: irc.freenode.net set +o ChanServ
09:57:29 <vixey`> SamB: btw got any idea what axiom K is? I'm wondering if it's like a weak extentionality or something
09:57:54 <SamB_XP> vixey`: it might be!
09:57:55 <vixey`> I looked it up but that just confused me more
09:58:15 <SamB> how about asking in #coq?
10:00:49 <vixey`> hey Cale
10:01:01 <vixey`> are you pro-choice? :)
10:01:17 <vixey`> or anti
10:01:19 <mrd> axiom of choice?
10:01:26 <vixey`> mrd, yeah
10:01:52 --- mode: irc.freenode.net set +o ChanServ
10:01:56 --- mode: irc.freenode.net set +o ChanServ
10:02:10 --- mode: irc.freenode.net set +o ChanServ
10:02:14 --- mode: irc.freenode.net set +o ChanServ
10:02:32 --- mode: irc.freenode.net set +o ChanServ
10:02:36 --- mode: irc.freenode.net set +o ChanServ
10:02:41 --- mode: irc.freenode.net set +o ChanServ
10:02:47 --- mode: irc.freenode.net set +o ChanServ
10:02:55 --- mode: irc.freenode.net set +o ChanServ
10:03:00 --- mode: irc.freenode.net set +o ChanServ
10:03:05 --- mode: irc.freenode.net set +o ChanServ
10:03:05 <xerox> There seems to be a problem.
10:03:14 <TomMD> Only seems to be, there actually isn't a problem.
10:03:27 <smtms> chanserv is forgetting to authenticate :-)
10:03:40 <mrd> nothing to see here
10:03:43 <vixey`> well it's over now
10:04:09 <TomMD> > (const "yes") "is lambdabot working?"
10:04:11 <lambdabot>  "yes"
10:04:34 <vixey`> lambdabot is not really working
10:04:38 <vixey`> @seen _
10:04:38 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
10:05:01 <TomMD> It was like that last night too - but who cares about seen anyway?  Its only the most used part of lambdabot besides the eval.
10:05:21 <mrd> @seen seen
10:05:21 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
10:05:49 <Deewiant> I'd say 'use preflex instead' but it seems preflex isn't here. :-/
10:06:08 <idnar> there's seenserv
10:06:16 <idnar> oh, or not
10:06:22 <vixey`> ...and nobody actually wanted to check @seen anyway
10:07:39 <sclv> @where ops
10:07:39 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:08:05 <vixey`> sclv, is there a need to do that?
10:08:26 <vixey`> who was it that was distressed about self reference in the halting problem statement?
10:08:58 <SamB> <SamB> what's axiom K?
10:08:58 <SamB> <roconnor> SamB: it esentially says that there is only one proof of equality (for a given term)
10:08:58 <SamB> <roconnor> Definition Streicher_K_ :=
10:08:58 <SamB> <roconnor>     forall (x:U) (P:x = x -> Prop), P (refl_equal x) -> forall p:x = x, P p.
10:09:33 <SamB> vixey`: does that confuse you?
10:09:36 <vixey`> where's the !exists ?
10:09:43 <SamB> ask roconnor in #coq
10:09:45 <sclv> vixey`: I thought we might need them to help chanserv stop spamming
10:09:46 <vixey`> oh it's saying proofs are equal
10:09:56 <SamB> I just now asked him this there
10:09:58 <vixey`> sclv: that stopped already
10:10:12 <sclv> right -- but not when i typed it, just when lambdabot responded
10:10:29 --- mode: irc.freenode.net set +o ChanServ
10:11:23 <vixey`> seems like a very nice axiom
10:11:29 <vixey`> there must be a catch
10:12:17 <SamB> come on over to #coq ;-)
10:13:23 <dons> Igloo: you're going to have to give ground on this QuickCheck for libraries thing. Or else write well chosen unit tests yourself. I don't think its productive to continue to advocate against testing like this.
10:15:25 <dons> ?Bug
10:15:26 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:21:05 <Igloo> dons: If a consensus is reached then that's fine with me
10:21:57 <Igloo> dons: I don't remember many people giving an opinion last time round, but maybe that's just my poor memory
10:22:54 <dons> the library guys like jyp, ross, me, dcoutts, wanted people to write more QC.
10:23:08 <dons> typically the people already putting tests into data structure code.
10:23:48 <dons> if you've got a time constraint you wish to enforce for tests that run in ghc's suite, that's reasonable, and can be accomodated
10:24:40 <dons> but i don't think its productive to ask people to revert back to hunting for unit tests -- its just not an efficient way to cover the code.
10:24:46 <Igloo> dons: I don't see a message from jyp or Ross in that thread
10:24:59 <dons> when we originally put the QC requirement into the libraries process
10:25:24 <dons> not the last time you raised the "don't use QuickCheck" issue.
10:25:36 <Igloo> Have you got a reference for the discussion handy?
10:26:06 <sclv> less compatible, but would lazysmallcheck or something be better at covering the space you want, Igloo?
10:26:25 <Igloo> sclv: less compatible?
10:26:38 <dons> i think Igloo is balking on the runtime cost of running 1000s of tests, iirc?
10:26:46 <sclv> I might be wrong, but I don't recall if its H98
10:26:49 <TomMD> I really enjoyed lazysmallcheck when I was using it, but had slight issues getting the coverage I desired.
10:27:10 <Igloo> I'm not convinced by lazysmallcheck over unit tests; I think the time you save writing the unit tests would be spent getting the generator to give youthe values you need
10:27:53 <TomMD> Yes, that is exactly what I was saying.
10:28:21 <dons> Igloo: but why are you asking others not to include tests? is it because  you're worried that the code is inadequately tested, or is it the cost of running them in ghc's suite? or ?
10:29:08 <Igloo> dons: The tests are too slow to run, will bitrot if not run, and their presence will discourage people from writing unit tests
10:29:35 <dons> they don't need to be too slow to run. and its trivial to add unit tests to a QC suite.
10:29:49 <dons> for  your use, just set 10-50 as the search depth
10:29:58 <dons> for <1sec runtime for good testsuites
10:30:12 <pejo> dons, Igloo, are you discussing QC'ing GHC?
10:30:13 <dons> i've found on xmonad, that new users do sometimes contribute unit tests as well
10:30:21 <dons> which are just 0-arity quickcheck properties
10:30:22 <Igloo> pejo: Libraries rather than GHC itself
10:30:40 <dons> so do you have any evidence that QC discourages people contributing tests?
10:31:35 <Igloo> I have no evidence, no, but I think it's obvious
10:32:11 <dons> if it really is just the runtime, require that tests are paramaterised by an upper bound
10:33:26 <dons> good QC suites typically have a few custom unit tests anyway
10:33:49 <dons> for example, cases that failed in the past, can be dropped in as things that definitely need to be checked
10:34:02 <dons> but it only complements that other test generation stuff
10:34:03 <Igloo> I would object less to small-bound smallcheck tests, but I still think that unit tests would be better
10:34:34 <dons> do we have any data structure libs written only with unit tests?
10:35:10 <dons> ideally, i'd have smallcheck + random walk over the value space + a few custom cases, for best coverage.
10:35:24 <dons> getting bytestring near to 100% covered required some unit tests for error cases, for example
10:35:43 <dons> anyway, i think you can make these recommendations without ruling out property-based random testing per se.
10:36:12 <dons> the concerns for runtime costs and unit tests of specific cases can be encorporated easily
10:38:22 <Igloo> dons: We don't have complete testsuites for them, but there's containers/tests and some of the subdirs of testsuite/tests/ghc-regress/lib/
10:40:09 <dons> and Map and IntMap have a big QC set that isn't run.
10:41:02 <dons> i'd be happy to have people write all unit tests if they want, as long as they publish the hpc coverage data.
10:41:27 <dons> i bet QC gets equivalent coverage with less developer effort.
10:42:53 <Igloo> I hope to get GHC's testsuite to check the HPC coverage soon
10:43:01 <Igloo> Gotta get 6.8.3 out of the way first
10:46:12 <dons> andy did that , iirc, and complained about all the conditional globals that are hard to write tests for. if we had regular coverage stuff up, it would probably drive some of the ugliness to be refactored
10:46:40 <dons> Cale, another job for you, http://jartur.l-square.net/2008/05/is-haskell-really-that-great-as-a-programming-language/
10:46:41 <lambdabot> Title: ~~ » Blog Archive » Is Haskell really that&#8230; great as a programming languag ..., http://tinyurl.com/5txbup
10:48:00 <sclv> every time dons does that, I think "And your next mission, angels..."
10:49:17 <Igloo> dons: Hard to write tests for because it's hard to work out how to get the globals in teh right state, you mean?
10:49:41 <Igloo> (By "GHC's testsuite" I meant the testsuite run as part of GHC builds, i.e. including the libraries too)
11:00:41 <atp> why do people have so little confidence in their ability to learn things
11:00:45 <atp> i don't understand it
11:00:59 <atp> "haskell is hard", "math is hard", "it's so complicated", "i don't get it", "wah"
11:01:25 <atp> let me blog about it now
11:01:32 <Korollary> blogging is hard.
11:01:33 * atp throws up a little in his mouth.
11:01:43 <Botje> "fire is hard! let's go back to raw meat!"
11:02:38 <smtms> Botje, fire is easy. removing fire is difficult
11:03:08 <atp> fire is pretty hard
11:03:13 <atp> unless you have matches or a lighter
11:03:20 <Elly> I believe the traditional formulation is "X is hard, let's go shopping!"
11:03:21 <atp> or some other convenient source of fire
11:04:20 <atp> but you know, the truth is, i have no problems with someone saying, "i'm happing with java, it does what i want, i don't really feel like learning anything new, so i guess i won't"
11:04:25 <atp> but they never say that
11:04:27 <atp> instead they say
11:04:33 <atp> "haskell is ill-suited to X"
11:05:52 <Elly> haskell IS ill-suited to X, but on the other hand, so is C :(
11:05:57 <rhar> never put faith in the majority of people after all the majority of people vote republician too
11:06:14 <Elly> I'm fairly convinced that X is ill-suited to X
11:06:16 <smtms> "Haskell is so weird. I don't think I can learn it" :-)
11:06:22 <atp> i work with lots of republicans, many of them are very smart, and while i'm not republican myself i find that comment a bit silly
11:06:43 <sclv> rhar: actually the dems won the popular vote in 2000
11:06:53 * sclv has been watching Recount lately
11:07:40 * SamB wants a decent window system
11:07:41 <rhar> i know it's a bit silly, but i've had that in my head for a while and i wanted to use it.
11:08:16 <NRee1> hey in ghci are the integers arbitrary precision?
11:08:24 <Elly> Integers, or Ints?
11:08:34 <sclv> Elly: I thought XMonad proved that Haskell did pretty well for X?
11:08:35 <xerox> > product [1..1000000]
11:08:42 <Elly> sclv: I mean writing X in Haskell
11:08:47 <SamB> sclv: X is ill-suiteed for anything
11:08:50 <lambdabot> Terminated
11:08:53 <NRee1> hm i didnt realize there was a difference
11:08:53 <atp> X is awesome
11:08:59 <SamB> X is horrible
11:09:03 <Elly> FIGHT
11:09:03 <atp> what exactly is wrong with it
11:09:05 <Deewiant> xerox: the factorial of one million? that's one huge number :-P
11:09:12 <sclv> NRee1: Ints are fixed precision, Integers are arbitrary
11:09:24 <SamB> well, it's way too easy to deadlock
11:10:03 <atp> how do you mean?
11:10:04 <Elly> aha
11:10:04 <NRee1> ah thanks
11:10:24 <Elly> the xorg.conf(5) manpage still has "Video Adaptor Section: Nobody wants to say how this works. Maybe nobody knows..."
11:10:50 <Elly> and Inputdevice still has "Option SendDragEvents: ???"
11:10:52 <atp> That's pretty similar to the comments in the linux kernel relating to the big kernel lock
11:11:07 <atp> the fact that cruft exists cannot be denied
11:11:09 <SamB> atp: you never noticed your whole display getting locked up when one program had locked X?
11:11:16 <atp> nope, it's never happened to me
11:11:26 <atp> which is not to say that i don't believe it can
11:11:32 <SamB> I mean, maybe it's only temporary but still
11:11:49 <atp> i think X from an implementation perspective is very much in need of improvement
11:11:50 <SamB> theres way more
11:11:55 <Elly> I am mostly not a fan of the fact that X operates at IOPL 3
11:12:14 <SamB> really, X has just been accumulating too much cruft for too long
11:12:26 <atp> X is amazingly light for what it does
11:12:28 <hpaste>  NReed pasted "(no title)" at http://hpaste.org/8009
11:12:43 <atp> it ran well on machines with the power of today's pocket calculators
11:12:46 <SamB> X is amazingly good for the amount of stuff that has been added since it started
11:12:52 <NRee1> so that line seems to be overflowing since I get [3,29] as an answer
11:12:59 <SamB> but that's still not very good
11:13:15 <SamB> which is to say, it could use some radical simplification
11:13:21 <atp> this i can agree with
11:13:24 <NRee1> how would I make that line use Integers and not ints?
11:13:35 <jkff> Insert a type annotation somewhere
11:13:38 <atp> but when someone says X sucks I assume that there is something better out there, or that there is at least an idea for something better
11:14:07 <SamB> atp: never let it be said that I wait for something better to be made before claiming that X sucks
11:14:11 <atp> if it's just "it needs to be more thread safe, lighter, and faster", well that's all software, basically
11:14:27 <SamB> specs!
11:14:29 <SamB> it's specs
11:14:42 <SamB> not mere software
11:15:25 <atp> the protocol itself is relatively sound, and i don't subscribe to the idea that there should be one true widget library encoded at the protocol level, which some folks seem to complain about a lot
11:15:34 <atp> the implementation of the X protocol is crufty
11:15:53 <SamB> some non-backwards-compatible changes should be made..
11:16:01 <atp> and libX11 has a crapload of stuff in it that shouldn't be there... I believe Xorg is writing a lower lever implementation of the library that is protocol-only
11:16:02 <SamB> ... I guess I just want X12?
11:16:09 <atp> yeah, i can agree with that.
11:16:29 <SamB> how long has it been X11?
11:16:29 <NRee1> i cant figure out how I would add type annotation to that line though, GHCI tells me its deprecated..
11:16:30 <smtms> H12
11:16:30 <Elly> I'd like it if my system had one clipboard and not an X clipboard, a gnome clipboard, and a KDE clipboard
11:16:40 <atp> since 1992 or something i think
11:16:43 <atp> i'd have to check
11:16:45 <atp> it's been a while
11:16:51 <SamB> Elly: ah yes, that would be nice too
11:17:04 <smtms> the protocl is extensible and that's what's keeping it alive
11:17:12 <atp> 1987
11:17:13 <NRee1> Elly: its amazing how the "horrible" windows has such an amazing feature huh?
11:17:18 <SamB> also the clipboard should be UTF-8 except in *extreme* circumstances
11:17:26 <Elly> NRee1: I don't recall saying windows was horrible...
11:17:36 <atp> well, the clipboard is an interesting problem
11:17:39 <atp> i've thought about this before
11:17:40 <NRee1> im not saying you did, Im just pointing out the irony
11:17:54 <Elly> NRee1: it's okay; windows doesn't have ion3 :)
11:17:57 <SamB> obviously I'm talking only about textual stuff
11:18:02 <atp> before my current job i never worked with windows much... not because i dislike windows or microsoft mind you, just because i never did
11:18:05 <smtms> the clipboard is a more annoying version of the multiple widget sets
11:18:11 <atp> and actually windows isn't half bad
11:18:23 <atp> but the clipboard on windows is also pretty crappy, which makes me think that this is a very hard problem
11:18:28 <NRee1> elly: thats a feature not a bug
11:18:36 <hpaste>  Mr.Elendig pasted "xmonad.hs prob" at http://hpaste.org/8010
11:18:37 <SamB> atp: but at least there is only one
11:18:37 <Elly> NRee1: I consider it a bug :P
11:18:41 <TomMD> atp: Certainly - some of the Money paid for windows goes to GHC development
11:18:45 <NRee1> ^^
11:18:54 <Elly> atp: I have three crappy clipboards though :P
11:18:56 <atp> SamB: do you mean the PRIMARY and SECONDARY selections in X?
11:19:17 <SamB> TomMD: do you think they want us to design new ways to do things so they can steal our ideas?
11:19:30 <SamB> atp: possibly!
11:19:43 <atp> i don't use gnome or KDE for much, but if they have broken selection behaviour i don't see how that is X's fault.
11:19:43 <smtms> TomMD, like 0.00001%?
11:20:10 <atp> there is a tendency among DE vendors to try to reinvent the wheel poorly because they think that the original feature in X is broken
11:20:17 <atp> a good example is XIM
11:21:16 <atp> the main architectural issue with X's clipboard system that i'm aware of is that a selection dies after the owning program exits
11:21:42 <Elly> atp: argh, I hate that
11:21:51 <atp> this was a deliberate decision made in order to avoid a memcpy back when those things mattered
11:22:13 <atp> in older versions of X, the clipboard actually copied what you copy/pasted
11:22:27 <atp> but since X is network-transparent, it might have been copying substantial amounts of data over the network
11:22:38 <atp> so that was seen as silly and instead a lazy approach was favored
11:22:54 <atp> why do the copy if you don't actually paste?
11:23:31 <atp> windows fwiw seems to do the same thing, but it copies the data onto some sort of desktop clipboard when the parent program exits
11:23:44 <atp> this is fine if you aren't a network transparent system and windows is not
11:24:07 <Elly> at this stage I think I prefer the additional expense though
11:24:10 <atp> also, if you copy a large amount of data from say word or excel and then exit those applications, windows will actually ask you if you want to free the data or not
11:24:32 <Elly> will it?
11:24:36 <atp> yes
11:24:42 <atp> it happens to me every morning at work :)
11:24:43 <smtms> I think Word and/or Excel will ask you
11:24:54 <atp> i don't think that's necessarily bad
11:25:12 <atp> although i think the dialog box is overly technical (read cryptic) for a non-technical user
11:25:18 <atp> it talks about freeing memory and stuff
11:25:32 <atp> but otherwise that might be ok
11:25:49 <atp> but when you RDE in windows i frequently have issues copying from the remote desktop onto my local one
11:25:59 <atp> which shows that network transparent copy/paste is very hard to get right
11:26:11 <smtms> Elly, what's your preferred DE?
11:26:14 <atp> i'm not saying X necessarily does it correctly, just that it's a hard problem
11:26:52 <gpds> are #haskell logs saved and archived online?
11:26:58 <atp> i think so
11:27:00 <atp> in several places
11:27:04 <atp> google?
11:27:09 <smtms> gpds, citing the topic: "Logs: http://tunes.org/~nef/logs/haskell/ "
11:27:11 <lambdabot> Title: Index of /~nef/logs/haskell
11:27:44 <Elly> smtms: ion3, but it's not really a desktop environment :P
11:27:47 <gpds> thanks guys
11:28:10 <atp> i used to use pwm
11:28:17 <atp> then i went to xmonad :)
11:28:43 <TomMD> xmonad is nice - it also keeps coworkers from using your terminal when you step out.
11:28:54 <atp> man if i could use xmonad at work that would be great
11:29:11 <atp> unfortunately our IT dept is filled with fascists
11:29:17 <NRee1> can someone help me figure out how to put in type annotations to  make this not overflow: http://hpaste.org/8009
11:29:23 <atp> they found ghci on my work system and had a cow
11:29:27 <TomMD> Well, I installed in with --user and the IT doesn't care.
11:29:30 <Elly> heh
11:29:40 <TomMD> atp: Quit and run
11:29:41 <atp> "that's a non-sanctioned compiler!"
11:29:44 <Elly> I have root on my work machine, so I just installed ion3
11:29:52 <atp> well, i don't work in IT/CS so it doesn't much matter to me
11:30:44 <atp> hey, does ghc run on vms?
11:30:53 <atp> i would imagine it could since gcc does
11:31:18 <smtms> atp, what's the relation between ghc and gcc in your opinion?
11:31:37 <Elly> why would that be a matter of opinion? o_O
11:31:47 <TomMD> The answer: Dying
11:31:48 <atp> if you're using the gcc backend gcc does the actual compilation
11:31:53 <atp> not for long
11:32:09 <atp> but in the meantime even if ghc doesn't run on vms it might be possible to compile xmonad by compiling the C code on VMS :)
11:32:26 <atp> ie run ghc on a linux system, copy the C code to VMS, and compile there hehe
11:32:32 <atp> i don't know if that would work or not
11:32:55 <smtms> atp, the C code would encode some properties of the platform it is intended to run on
11:32:56 <dmwit> NRee1: "overflow"?
11:33:02 <atp> i would suspect so
11:33:07 <dmwit> NRee1: Like, stack overflow, or integer overflow?
11:33:14 <atp> but OpenVMS has a posix compatibility layer... who knows?
11:33:25 <atp> anyway it's been a while since i ran vms on my desktop so i'm not too concerned
11:33:30 <NRee1> integer overflow
11:33:33 <atp> but i always wonder if things run on vms
11:34:33 <dmwit> NRee1: Use Integer instead of Int.
11:34:51 <NRee1> How would I do that though?
11:35:11 <NRee1> nvm
11:35:12 <dmwit> Stick a (primes :: [Integer]) in your source somewhere.
11:35:29 <dmwit> (Honestly, I'm a bit surprised it's not defaulting to Integer.)
11:35:34 <dons> we win, "Haskell.org in contrast has a download link and a 5-step micro-tutorial that takes you up to Hello World and a factorial program. It then offers pointers for where to go to learn more. That is much more welcoming."
11:35:45 <NRee1> ya thanks dmwit
11:35:46 <Cale> vixey`: looking for me?
11:35:55 <TomMD> dons: link?
11:36:15 <dons> http://reddit.com/r/programming/info/6lev3/comments/c046twq
11:36:21 <NRee1> i copied in a prime generator that I wanted to play with and it explicitly said Int (I didnt catch it)
11:36:27 <vixey`> Cale: I was wondering if you were pro/anti axiom of choice
11:36:27 <dons> n.b. we added the 'Download' link yesterday :) hahaha
11:36:46 <atp> the world without AoC is pretty boring
11:36:53 <Cale> Pro.
11:36:58 <vixey`> oh ok cool
11:37:03 <atp> asking if you're pro or anti is kind of like being pro or anti parallel postulate
11:37:10 <atp> who cares?
11:37:12 <ddarius> dons: It's all about the Download link.
11:37:18 <vixey`> atp, I do ..
11:37:25 <mjrosenb> how should I instantiate a class with the type string?
11:37:26 <geezusfreeek> i'm interested in haskellers' opinions on this: "Any sufficiently complicated Haskell or ML program contains an ad hoc, informally-specified, bug-ridden, half-completed simulation of dependent types." (from http://blog.jbapple.com/2007/02/conors-rule.html)
11:37:26 <lambdabot> Title: Everyone Else is Crazy: Conor's Rule?
11:37:30 <atp> vixey`: why's that?
11:37:43 <vixey`> geezusfreeek: seen darcs?
11:37:44 <dmwit> atp: On the AoC, you get weird stuff if you're either pro or anti.
11:37:51 <atp> yep
11:37:55 <dmwit> atp: So it's interesting to see which weird stuff people prefer. =)
11:37:59 <geezusfreeek> vixey`: it's source code?
11:38:05 <TomMD> Does anyone know how to job market is in the Northwest US right now?
11:38:20 <dons> thinking of moving, TomMD ?
11:38:24 <TomMD> eyp
11:38:26 <TomMD> yep
11:38:29 <atp> i just find that lots of people care because they wonder which one is "right", as if abstract formalisms have any relationship to the state of the universe :p
11:38:44 <atp> personally i like to well order the reals
11:38:47 <atp> mmmm
11:38:52 * atp hugs AoC.
11:39:58 <dons> TomMD: i couldn't say. We'll probably need people in late 08, early '09, fwiw.
11:41:34 <vixey`> ?where AoC
11:41:34 <lambdabot> I know nothing about aoc.
11:41:36 <vixey`> what's that?
11:42:32 <dmwit> Axiom of Choice.
11:42:42 <mar77a> age of connan
11:42:59 <sclv> geezusfreeek: I agree on everything but the "bug-ridden" part.
11:43:51 <sclv> when fake-dependent-types don't do what they're supposed to, you get non-compilation, which I suppose is sort of a bug... maybe bug-prone would be better.
11:45:41 <nolrai_> dont we have dependant types?
11:45:50 <vixey`> nolrai_: No
11:46:03 <dmwit> Newp.
11:46:23 <geezusfreeek> nolrai_: with some extensions we have things that we can consider dependent types if you squint at it and hide some parts with your eyes and forget how it works ;)
11:46:25 <dmwit> But for just $19.99 you can have this brand new GADT!
11:46:38 <geezusfreeek> *from your eyes
11:46:50 * dmwit hides his parts with his eyes
11:47:05 <dmwit> It hurts to take them out, at first, but at least your parts are hidden
11:47:17 <nolrai_> eww..
11:47:29 <nolrai_> lol
11:47:33 <nolrai_> eww..
11:47:44 <geezusfreeek> it gets worse the more i think about it
11:49:09 <vixey`> :t undefined
11:49:11 <lambdabot> forall a. a
11:49:25 <mjrosenb> so does anyone feel like answering a question about type classes?
11:49:33 <dmwit> Just ask. ;-)
11:49:51 <mjrosenb> how should I instantiate a class with the type string?
11:50:05 <nolrai_> is there a genral rule for figureing out the semantics of monad tranformer combinations
11:50:23 <Deewiant> lambdabot's @unmtl helps
11:50:27 <dmwit> mjrosenb: Use -XTypeSynonymInstances or something like that.
11:50:45 <mjrosenb> that will do the correct thing?
11:50:47 <dmwit> mjrosenb: (i.e. it isn't H98, but GHC has an extension that allows it.)
11:51:17 <Deewiant> for H98, you can try the trick used for the Show/ReadS classes in the Prelude (no, I don't remember what it is)
11:51:37 <nolrai_> @unmtl StateT (Set a) List
11:51:38 <lambdabot> err: `StateT (Set a) List' is not applied to enough arguments, giving `/\A. Set a -> List (A, Set a)'
11:51:38 <dmwit> Deewiant: You have to change the type-class for that to work.
11:52:07 <dmwit> mjrosenb: If you really want to stay H98, and you don't have access to the type-class, you can use newtype to define a new, atomic String.
11:52:09 <Deewiant> That may not be a problem in this case, though, so it's still an option. :-)
11:52:13 <nolrai_> @unmtl State a
11:52:14 <lambdabot> err: `State a' is not applied to enough arguments, giving `/\A. a -> (A, a)'
11:52:17 <dmwit> mjrosenb: Incidentally, which class are you instantiating this way?
11:52:19 <Deewiant> @unmtl State a b
11:52:20 <lambdabot> a -> (b, a)
11:52:21 <nolrai_> @unmtl StateT (Set a) List r
11:52:21 <lambdabot> Set a -> List (r, Set a)
11:52:30 <mjrosenb> dmwit: Metric
11:52:44 <dmwit> Okay, so one you wrote yourself, then?
11:52:49 <mjrosenb> ja
11:53:01 <dmwit> The trick the Prelude uses with Show is to include a copy of all the functions in the class.
11:53:09 <dmwit> i.e. class Show has
11:53:18 <Deewiant> @src Show
11:53:18 <lambdabot> class  Show a  where
11:53:18 <lambdabot>     showsPrec :: Int -> a -> ShowS
11:53:19 <dmwit> show :: a -> String; showList :: [a] -> String
11:53:21 <lambdabot>     show      :: a   -> String
11:53:22 <lambdabot>     showList  :: [a] -> ShowS
11:53:38 <dmwit> Okay, showList :: [a] -> ShowS, but you get the idea. =)
11:54:01 <nolrai_> @unmtl ListT (State a) r
11:54:01 <lambdabot> a -> ([r], a)
11:54:01 <mjrosenb> right, but i don't think that the metric should work like that
11:54:36 <dmwit> Okay. You still have a few choices.
11:54:41 <nolrai_> @hoogle ListT
11:54:42 <lambdabot> Control.Monad.List.ListT :: newtype ListT m a
11:54:42 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
11:54:42 <lambdabot> Language.Haskell.TH.ListT :: Type
11:55:04 <dmwit> You can define an instance for [a] (with some context, if you like), you can define a newtype, or you can use the GHC extension mentioned above.
11:55:49 <mjrosenb> i think i'm going to give a 'suitable' instarce of metric for char
11:56:09 <mjrosenb> although there can be more than one depending on how you want it to function
11:56:20 <dmwit> Right.
11:56:27 <dmwit> There's a similar problem with Ord.
11:56:43 <mjrosenb> are there any problems with having a class being instantiated at a type more than once?
11:56:46 <dmwit> The usual attack there is to define a newtype for each different way of functioning that you want to use.
11:56:59 <dmwit> mjrosenb: Yes, there's a problem: it's not allowed.
11:57:05 <dmwit> (even with extensions)
11:57:21 <mjrosenb> even within separate modules?
11:57:30 <EvilTerran> yes. instances are global.
11:57:35 <mjrosenb> fuuuun
11:57:47 <MedeaMelana> global all over the world ;-)
11:57:54 <EvilTerran> otherwise odd things would happen if you passed a value from a scope where one instance was in force to a scope where another instance was in force
11:57:56 <mjrosenb> globally global
11:58:05 <EvilTerran> ie, which instance would apply?
11:58:33 <dmwit> mjrosenb: Do you know how class-polymorphic functions are implemented?
11:58:48 <mjrosenb> dmwit: i believe so
11:58:52 <dmwit> If so, it should become clear pretty quick why instances are global.
11:58:57 <mjrosenb> unless crary was lying
11:59:11 <dmwit> There's a "dictionary" that holds all of the class' functions.
11:59:37 <mjrosenb> yeah... so i can't use the same metric to do spell checking on both qwerty and dvorak
11:59:39 <dmwit> So if you pass a value from a class-polymorphic function to another class-polymorphic function, then it just passes the dictionary along.
11:59:48 <ddarius> "Arc seems really clean."
12:00:02 <dmwit> i.e. it generates the dictionary only from monomorphic functions.
12:00:27 <dmwit> mjrosenb: Now, with that in mind, imagine passing a value from one class-polymorphic function to another, where the two are in different "class scopes".
12:00:52 <dmwit> You might expect the second function to behave as if the type were in its second class, when in fact it's getting the dictionary from the first class.
12:01:08 <mjrosenb> i don't see a large issue with that
12:01:24 <dmwit> Well.. it's just weird, is all.
12:01:36 <dmwit> You aren't guaranteeing that the in-scope instance is the one being applied.
12:01:43 <dmwit> So what's the point of the scope, then?
12:01:46 <EvilTerran> ddarius, er... who said that?
12:02:02 <sclv> nolrai_: The other thing to think about with mtl transformers is that the outermost layer has access to the innermost, but not vice versa.
12:02:09 <ddarius> EvilTerran: Some random person on reddit.
12:02:09 <geezusfreeek> you also have to consider what happens if both instances are in scope and you define a monomorphic function with the type in question
12:02:14 <mjrosenb> dmwit: the in scope one is there in case it isn't being over-ridden
12:02:32 <mjrosenb> oh god, i'm sounding like a c++ programmer.  someone shoot me
12:02:45 <dmwit> I don't know.
12:02:53 <dmwit> I guess both approaches are reasonable to different people.
12:03:06 <dmwit> But the H98 choice was global instances. =)
12:03:34 * dmwit hasn't had very much trouble with it in the end
12:03:36 <geezusfreeek> i don't like global instances, personally, but the alternative is some clunkiness in a majority of cases
12:05:19 <geezusfreeek> i don't like how it causes orphan instances and stuff, particularlyâ¦ and that it means I can't define things like instance Monad m => Applicative m as a catch-all for those monads which aren't given applicative instances already (although it would be better to properly define the monad type class to require it in the first place)
12:05:26 <geezusfreeek> and so on
12:05:29 <mjrosenb> I could probably deal with this by making up a new type that's basically a list of different possible metrics :(
12:05:53 <dmwit> Ew, don't do that.
12:05:56 <mjrosenb> geezusfreeek: yeah, I have to agree with you
12:05:59 <geezusfreeek> mjrosenb: wait, what it is you are trying to do?
12:06:26 <mjrosenb> geezusfreeek: define a Metric class
12:06:28 <dmwit> There's already a provision for multiple instances: newtype.
12:06:30 <dmwit> Why not use it?
12:06:38 <geezusfreeek> mjrosenb: newtype is your friend
12:07:05 <mjrosenb> hrmm
12:07:10 * mjrosenb looks into it
12:07:27 <dmwit> mjrosenb: newtype is like data, but only allows one constructor
12:07:31 <mjrosenb> but i'm not up to the part of the code where that will make a difference
12:08:04 <dmwit> You can also derive any instance for a newtype'd guy that the underlying alias has.  (With -XNewtypeDeriving or something like that.)
12:08:23 <geezusfreeek> -XGeneralizedNewtypeDeriving
12:08:24 <mjrosenb> dmwit: right so i'd end up with a single 'function' of type Char -> TrivialChar
12:08:32 <dmwit> mjrosenb: exactly
12:08:48 <mjrosenb> presumably i can also make the inverse
12:09:09 <dmwit> newtype TrivialChar = TC { unTC :: Char } -- gives you both ways
12:09:22 <atp> nice
12:09:23 <dmwit> A clever trick, no?
12:09:35 <atp> not bad at all, dmwit
12:10:08 <mjrosenb> in that case, I will have many many newtypes
12:10:08 <Bonus> ugh i cant believe i *still* dont quite understand newtype. whats the difference between that and data TrivialChar = TC {unTC :: Char}
12:10:09 <atp> presumably since newtypes are provably isomorphic the compiler removes them anyway
12:10:20 <dmwit> Bonus: Nothing important.
12:10:29 <atp> Bonus: data isn't isomorphic
12:10:31 <dmwit> Bonus: They deal with bottom differently.
12:10:41 <geezusfreeek> i think the difference is very important
12:10:44 <Bonus> bottm?
12:10:47 <atp> Bonus: and internally, data may be implemented as a pointer
12:10:50 <Bonus> bottom*
12:10:55 <mjrosenb> now i'll need to do a map before all strings that i want to compare :(
12:10:57 <dmwit> Bonus: Internally, there is no constructor.
12:11:24 <atp> Bonus: bottom is the value we talk about a function returning if it does not return (ie, if it never halts)
12:11:26 <dmwit> Bonus: So (TC undefined) is undefined for a newtype, but can be pattern-matched against (TC _) for a data.
12:11:36 <geezusfreeek> Bonus: for a newtype, TC _|_ = _|_, but for data, TC _|_ might only be reduced to weak head normal form, and so doesn't necessary mean the whole this is _|_
12:11:43 <atp> Bonus: for example, f x = f x + 1
12:11:50 <Bonus> aha
12:12:13 <atp> Bonus: returns bottom (in reality of course, it returns nothing, but mathematically talking about bottom is very useful)
12:12:21 <dmwit> mjrosenb: Choose your default instance carefully. ;-)
12:12:43 <Bonus> aha, i kind of see
12:12:43 <geezusfreeek> Bonus: and a reason for doing this is because with newtype we don't have to box/unbox the value at runtime. we can just treat it unboxed all the time
12:12:56 <atp> Bonus: data Foo a = Foo a has two possible bottom values (we write bottom as _|_ on IRC, fyi)
12:13:05 <atp> it has _|_ and Foo _|_
12:13:07 <geezusfreeek> well, s/unboxed/unwrapped/ for some definition anyway
12:13:11 <Bonus> aha hmm
12:13:15 <Bonus> so when to use data vs. newtype
12:13:16 <Bonus> generally
12:13:34 <atp> well, take newtype Foo = Foo Integer
12:13:44 <atp> Foo is then isomorphic to integer.. do you know what isomorphic means?
12:13:59 <Bonus> yeah, i vaguely remember
12:14:05 <mjrosenb> sweet, levenshtein just got shorter
12:14:07 <dmwit> Use newtype when you really want "type", but "type" doesn't quite cut it.
12:14:09 <Bonus> it has something to do with subspaces
12:14:45 <atp> well, it means that you can define some function that maps everything from one space onto another space in a 1-1 way
12:14:50 <mjrosenb> can newtype take type vars?
12:14:53 <Bonus> ah
12:14:55 <geezusfreeek> use newtype when you want type to be typechecked. also use newtype when you want to define more than one instance of the same class for the same type
12:14:59 <dmwit> mjrosenb: yes
12:15:07 <atp> so like, here's that function for our Foo newtype
12:15:15 <atp> f x = Foo x
12:15:22 <mjrosenb> oh god
12:15:23 <atp> and its inverse, g (Foo x) = x
12:15:24 <dmwit> Bonus, atp: 1-1, *and* onto
12:15:27 <mjrosenb> erruh
12:15:35 <atp> dmwit: i said onto
12:15:49 <dmwit> okay, good
12:15:50 <Bonus> aha
12:16:01 * dmwit missed it, it was slipped in a sneaky place
12:16:03 <atp> ok but see suppose Foo were defined as data
12:16:08 <Baughn> Or just "bijective". Though I wonder if it doesn't make more sense in terms of category theory..
12:16:08 <mjrosenb> so there's the trivial metric, which is defined on anything that has the equality function defined
12:16:13 <atp> then the same functions would not work quite right
12:16:20 * Baughn will have to keep wondering, not having read much category theory
12:16:31 <atp> the reason is bottom
12:16:32 <nolrai_> :t Control.Monad.State evalState
12:16:34 <lambdabot>     Not in scope: data constructor `Control.Monad.State'
12:16:40 <nolrai_> :t Control.Monad.State.evalState
12:16:42 <lambdabot> forall s a. State s a -> s -> a
12:16:43 <atp> f _|_ -> Foo _|_, that much is clear
12:16:50 <atp> but what about g _|_ ?
12:16:56 <newsham> ?src evalState
12:16:56 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:16:57 <Bonus> hmmm
12:17:00 <mjrosenb> dmwit: cat newtype handle that?
12:17:12 <newsham> ?src Control.Monad.State.evalState
12:17:13 <lambdabot> Source not found. Maybe you made a typo?
12:17:14 <dmwit> I should think so, yes.
12:17:19 <newsham> ?src Control.Monad.State.Lazy.evalState
12:17:19 <lambdabot> Source not found. Wrong!  You cheating scum!
12:17:22 <Baughn> newsham: execState
12:17:22 <newsham> boo
12:17:26 <atp> see, newtype doesn't allow a variable of type foo to be just _|_
12:17:32 <dmwit> mjrosenb: instance Eq a => Metric (Trivial a) where ...
12:17:35 <atp> it can only be Foo _|_
12:17:41 <newsham> > evalState (put 5) 8
12:17:41 <atp> but data also allows just _|_
12:17:42 <lambdabot>  ()
12:17:47 <mjrosenb> dmwit: right
12:17:48 <atp> so g _|_ is undefined
12:17:51 <geezusfreeek> atp: wait what?
12:17:57 <Baughn> newsham: ..I see. I just went looking in the source
12:17:59 <geezusfreeek> newtype doesn't let you box _|_
12:18:03 <mjrosenb> do that in the instance, not the newtype
12:18:10 <Baughn> newsham: Hm, if lb actually tried to print it it'd get kicked for spam
12:18:12 <newsham> its just fst or snd on execState
12:18:20 <atp> geezusfreeek: ah, right, i had it backwards, but the effect is the same
12:18:30 <atp> Foo _|_ and _|_ are distinct for a data
12:18:39 <nolrai_> @src Control.Monad.State.evalState
12:18:39 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:18:44 <nolrai_> hmm
12:18:46 <atp> for a newtype, there is no Foo _|_
12:18:54 <atp> nolrai_: there is no source
12:19:03 <nolrai_> for anything?
12:19:17 <atp> oh wait, nevermind, i was thinking of runState
12:19:31 <dmwit> There is no spoon.
12:19:44 <nolrai_> there is no source --sounds like the final plot twist in a move.
12:19:44 <newsham> evalState m s = fst (runState m s)
12:20:01 <geezusfreeek> the way i like to think of it is that data allows you to box _|_ (and thus pattern match on it without evaluating it) but newtype does not
12:20:03 <newsham> execState m s = snd (runState m s)
12:20:25 <newsham> newtype State s a = State { runState :: s -> (a, s) }
12:20:26 <atp> geezusfreeek: yeah, that's more accurate
12:20:40 <dmwit> And, of course, runState m s = (evalState m s, execState m s) -- ;-)
12:20:43 <atp> geezusfreeek: thanks for the correction :)
12:20:59 <geezusfreeek> hmm, but that made it sound like newtype Foo a = Foo a is like data Foo a = Foo !a, though, which is incorrectâ¦ i need to rephrase that too i suppose
12:21:04 <newsham> runState just unwraps the func
12:21:10 <Baughn> geezusfreeek: I like "newtype exists only as a figment of the compiler's imagination; data has actual consequences for the generated code"
12:21:23 <Baughn> Specifically an extra pointer/thunk, yes
12:21:27 <atp> geezusfreeek: frequently data will have a pointer indirect... and unboxed and strict are different
12:21:28 <nolrai_> I can never keep track of witch is witch. eval and exec.
12:21:39 <dmwit> Me neither.
12:21:41 <vixey`> :t evalState
12:21:43 <lambdabot> forall s a. State s a -> s -> a
12:21:49 <gpds> im new to haskell and i keep hearing that foldr is good with lazy lists, but this seems a little weird to me since foldr starts at the right, but if a list is lazy wouldnt it be better to start at the left?
12:21:51 <dmwit> nolrai_: That's why :t exists.
12:21:56 <atp> geezusfreeek: strictly evaluated Foo !a just means that a is strictly evaluated, not that it is unboxed
12:22:01 <nolrai_> true
12:22:08 <atp> geezusfreeek: right?
12:22:16 <Baughn> gpds: Well, look at these:
12:22:17 <dmwit> gpds: It means that a function may ignore the whole right-hand part of a list.
12:22:18 <newsham> nol: eval evaluates the value, exec executes your state machine to get a final state
12:22:26 <Baughn> > foldr f 0 [a,b,c,d]
12:22:27 <lambdabot>  Add a type signature
12:22:28 <geezusfreeek> atp: right
12:22:33 <Baughn> > foldr f 0 [a,b,c,d] :: [Expr]
12:22:34 <lambdabot>   add an instance declaration for (Num [Expr])
12:22:48 <EvilTerran> atp, it doesn't mean anything about unboxing, because representation in memory is not described in the spec
12:22:48 <Baughn> ..someday...
12:22:49 <atp> Baughn: 0 is evaluated as fromInteger
12:22:51 <Baughn> > foldr f a [a,b,c,d] :: [Expr]
12:22:52 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
12:22:57 <Baughn> atp: I knew that.
12:23:02 <atp> Baughn: :p
12:23:02 <Baughn> > foldr f a [a,b,c,d]
12:23:05 <EvilTerran> atp, however, ghc is likely to unbox strict fields when it can
12:23:09 <lambdabot>  f a (f b (f c (f d a)))
12:23:13 <Baughn> > foldl f a [a,b,c,d]
12:23:15 <lambdabot>  f (f (f (f a a) b) c) d
12:23:17 <atp> EvilTerran: true, but that's an optimization
12:23:21 <EvilTerran> indeed
12:23:31 <Baughn> gpds: Okay. Now that I've stop annoying lambdabot, look at those two lines
12:23:40 <gpds> ok
12:23:46 <EvilTerran> eliding newtypes come runtime is also an optimisation, but a much easier one, hence the existence of them
12:23:46 <atp> it's not very straightforward, i've frequently been confused about unboxing/strictness
12:23:48 <gpds> so does evaluation start at f d a and f a a respectively?
12:23:49 <Baughn> gpds: foldl is the classical tail-recursive variant, right
12:23:59 <atp> EvilTerran: well, it's always possible, thanks to isomorphism
12:24:01 <vixey`> > let f91 n | n > 100 = n - 10 | otherwise = f91 . f91 $ n+11 in map f91 [1..]
12:24:01 <lambdabot>  [91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,...
12:24:09 <dmwit> gpds: No.
12:24:09 <EvilTerran> exactly
12:24:23 <EvilTerran> newtypes and strict datas are similar in that, for either, (Foo undefined) is indistinguishable from undefined
12:24:27 <Baughn> gpds: But haskell evaluates from the *outside in*. So for foldr, it can evaluate just "f a" and then stop, if f a happens to return a value containing a chunk that will do the rest of the computation
12:24:33 <dmwit> gpds: Evaluation starts at f a and f (f ( (f (f a a), respectively.
12:24:44 <geezusfreeek> EvilTerran: ah, that is exactly what i meant to say earlier
12:24:48 <gpds> outside in?  that makes sense then
12:24:50 <vixey`> I think the key is the idea of weak head normal form
12:25:06 <atp> EvilTerran: right, but in the strict data example, it's because Foo _|_ is being reduced to _|_ due to strictness, not because the two are mathematically considered equivalent
12:25:07 <dmwit> gpds: Well, that was quick. =D
12:25:07 <EvilTerran> but (case undefined of Foo undefined -> "ok") will succeed if Foo is a newtype constructor, and fail if it's a strict data constructor
12:25:17 <Baughn> gpds: Well, that's what laziness /does/
12:25:23 <vixey`> when you have some expression, it seems like the evaluator tugs on it until a weak head is pulled through
12:25:26 <atp> EvilTerran: you can match on undefined?
12:25:28 <atp> EvilTerran: wow
12:25:30 <gpds> ok because i thought that it started from the most nested ()
12:25:31 <atp> i did not knowthat
12:25:33 <atp> know that
12:25:34 <gpds> but i guess it doesnt
12:25:35 <gpds> thanks guys
12:25:36 <EvilTerran> atp, er, ignore that
12:25:40 <geezusfreeek> vixey`: like birth?
12:25:42 <EvilTerran> s/Foo undefined/Foo _/
12:25:44 <geezusfreeek> ;)
12:25:48 <atp> oh right, that makes more sense
12:25:49 <atp> :p
12:25:53 <Baughn> gpds: If the function you pass to foldr happens to be strict in some sense - well, specifically if it can't make a chunk to do the rest of the computation - *then* foldr will do the usual stack-overflow thing you get from non tail-recursive algorithms
12:25:56 <atp> that's a good explanation
12:25:58 <vixey`> no like pulling wool out a jumper
12:25:58 <dmwit> atp: halting problem ;-)
12:26:00 <EvilTerran> atp, that would just re-bind the meaning of "undefined" within the case branch
12:26:02 <atp> EvilTerran: you should write that down somewhere
12:26:06 <atp> dmwit: yeah :)
12:26:10 <Baughn> gpds: This happens a lot for + and such. And s/chunk/thunk/
12:26:23 <EvilTerran> also, (case Foo undefined of Foo _ -> "ok") will not work for strict datas, but it will work for newtypes and lazy datas
12:26:33 <Baughn> gpds: In that case foldl would be better, except it's only better when it gets optimized to foldl'. So just use foldl' to begin with.
12:26:40 <EvilTerran> ?where newtype
12:26:40 <lambdabot> I know nothing about newtype.
12:26:44 <atp> right, because Foo undefined will evaluate to undefined immediately if the data type is strict
12:26:48 <EvilTerran> ?where+ newtype http://haskell.org/haskellwiki/Newtype
12:26:49 <lambdabot> I will remember.
12:26:54 <nolrai_> @unmtl ReaderT e (ListT (State a)) r
12:26:55 <lambdabot> e -> a -> ([r], a)
12:26:55 <EvilTerran> atp, it is written down somewhere already :)
12:26:58 <gpds> ok so i shouldnt use foldr except for lazy lists with an f that does proper thunking?
12:27:05 <atp> but Foo undefined is still lazy, just equivalent to undefined if Foo is a newtype
12:27:10 <dmwit> > foldr (||) False (True:undefined) -- gpds: an example where the function is lazy enough to ignore a (potentially infinite) chunk of the list
12:27:11 <lambdabot>  True
12:27:18 <vixey`> (but I have the feeling my explanation may only make sense to people that already understand what I am trying to describe)
12:27:40 <geezusfreeek> gpds: i think the f is the only important part there
12:27:42 <dmwit> gpds: foldr should be your reflex, then optimize to foldl' if things aren't quite working out right.
12:27:52 <Baughn> gpds: You shouldn't use foldr except for foos with an f that produces *some* output for some constant number of elements (one does fine, but it can be any number), and then a thunk to do the rest
12:27:57 <Baughn> gpds: That's most of them
12:28:11 <atp> EvilTerran: well, maybe make a page on haskellwiki if there isn't one already?  the question of newtype versus data comes up frequently enough here
12:29:01 <gpds> i think i understand a lot better now.  thanks!
12:29:03 <vixey`> atp: why not direct people to the report/
12:29:12 <Baughn> gpds: Remember, haskell always does the least amount of work it can get away with
12:29:23 <geezusfreeek> because this is the explanation in the report http://www.haskell.org/onlinereport/decls.html#sect4.2.3
12:29:24 <lambdabot> Title: The Haskell 98 Report: Declarations
12:29:30 <atp> vixey`: because the report is relatively terse and doesn't give examples that help illustrate the point, especially with regards to spine strict datatypes versus newtypes and how they are different
12:30:03 <atp> i mean, data Foo a = Foo a is not an isomorphism and newtype is explains the data/newtype distinction well enough
12:30:18 <atp> but operationally, how is newtype Foo a different from data Foo !a is an interesting question
12:30:27 <geezusfreeek> i like how http://haskell.org/haskellwiki/Newtype also includes data types with strict fields in the comparison
12:30:28 <lambdabot> Title: Newtype - HaskellWiki
12:30:37 <gpds> is there a way to fold on a lazy list until you meet a condition and then have it stop the computation?
12:30:50 <atp> scanl
12:30:52 <atp> or scanr
12:30:56 <gpds> thanks
12:31:00 <dmwit> atp: ...are newtype and data operationally different in that case?
12:31:04 <atp> using takeWhile or similar
12:31:05 <vixey`> @src any
12:31:06 <lambdabot> any p =  or . map p
12:31:06 * dmwit hasn't been following the discussion
12:31:17 <vixey`> gpds: take a look at the source code to any
12:31:24 <gpds> ok
12:31:28 <dmwit> gpds: That's what foldr does, no?
12:31:30 <mar77a> :t or
12:31:31 <lambdabot> [Bool] -> Bool
12:31:34 <atp> dmwit: yes, that's the whole point
12:31:37 <Baughn> gpds: Laziness works for you. You can use foldr and then stop reading the output list when the condition is met
12:31:39 <geezusfreeek> dmwit: see http://haskell.org/haskellwiki/Newtype
12:31:40 <lambdabot> Title: Newtype - HaskellWiki
12:31:40 <atp> dmwit: EvilTerran just gave a great example of how
12:31:51 <gpds> so you would combine scan* with fold*
12:31:53 <atp> dmwit: but it's subtle, which is why i suggested he write it down :)
12:32:21 <Baughn> gpds: No, scan does that on its own. I might combine fold with, say, head and filter
12:32:22 <dmwit> The case undefined of (Foo _) -> "ok" thing?
12:32:28 <gpds> oh
12:32:32 <atp> yeah, all that
12:33:01 <dmwit> mmm
12:33:03 <dmwit> sneaky =)
12:33:11 <atp> yeah, it's not bad, eh?
12:33:15 <Baughn> gpds: Oh, and physically speaking what's going on here is that haskell is mutating the list - adding new elements to the end as you go. It's not visible, but it means you can almost directly rewrite imperative algorithms in haskell by leveraging laziness. :D
12:33:32 <atp> Baughn: mutating the list?
12:33:40 <dmwit> Say wha???
12:33:45 <atp> Baughn: how is mutating it?  lists are persistent
12:33:56 <Baughn> atp: At the physical level, in memory
12:34:03 <atp> Baughn: no, i don't think it is
12:34:05 <Baughn> atp: It's replacing a thunk with a list element
12:34:08 <geezusfreeek> i don't think so either
12:34:15 <atp> Baughn: oh, you mean dethunking
12:34:17 <dmwit> oh
12:34:19 <atp> that's not really mutation
12:34:23 <atp> it's evaluation
12:34:51 <vixey`> > foldr (\x ys -> if x > 15 then x : ys else ys) [] [1..]
12:34:52 <lambdabot>  [16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,...
12:34:55 <Baughn> That's why I said it isn't visible. Physically it *is* mutation, and you *can* use it to rewrite mutating algorithms in haskell, so.. handy.
12:35:04 <atp> how?
12:35:09 <vixey`> > foldr (\x ys -> if x < 15 then x : ys else []) [] [1..]
12:35:10 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
12:35:24 <geezusfreeek> mutation = changing the value, dethunking = changing the internal representation
12:35:25 <vixey`> gpds: how about those two examples?
12:35:39 <dmwit> vixey`: Thank you, I feel vindicated.
12:35:49 <vixey`> dmwit: regarding?
12:36:08 <dmwit> I suggested that foldr *already* allows you to stop computations in the middle with a predicate a few pages back. =)
12:36:11 <Baughn> atp: Dynamic programming, for example. Make a nice, big array whose values refer to values in other cells..
12:36:19 <dmwit> But I think I was largely lost in the noise.
12:36:20 <vixey`> oh sorry, not been following much of this
12:36:24 <dmwit> So your example helps. =)
12:36:27 <gpds> oh
12:36:28 <gpds> thanks vixey
12:36:29 <atp> > takeWhile (< 400) . scanl (*) $ [1 ..]
12:36:30 <vixey`> ok
12:36:30 <lambdabot>  Couldn't match expected type `[a]'
12:36:40 <ddarius> Baughn: Also some examples of tying the knot.
12:36:41 <atp> > takeWhile (< 400) . scanl (*) 1 $ [1 ..]
12:36:42 <lambdabot>  [1,1,2,6,24,120]
12:36:50 <ddarius> (well, technically all examples)
12:36:52 <vixey`> gpds: it's not (at least to me) immediately obvious why these work
12:37:01 <vixey`> gpds: but hopefully it make sense
12:37:08 <gpds> yeah im trying to understand these
12:37:18 <gpds> does haskell have a trace command like scheme
12:37:22 <gpds> where you can trace the evaluation?
12:37:27 <Baughn> atp: Or implementing amortized data structures without making the worst time-complexity the *actual* complexity when someone starts reusing the same value it had just before rebalancing multiple times, by making the rebalancing work via evaluating a thunk
12:37:34 <dmwit> gpds: Debug.Trace
12:37:38 <vixey`> gpds: there's a pretty ugly hack which allows that
12:37:38 <gpds> thanks
12:37:42 <Baughn> gpds: ghci has a full stepper too
12:37:43 <geezusfreeek> that's not really a tracer
12:37:44 <vixey`> gpds: I'd suggest not touching it ever
12:38:08 <geezusfreeek> ghci's :trace command is more what you want i think
12:38:11 <dmwit> ?quote refreshing
12:38:11 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
12:38:13 <atp> Baughn: i guess i just don't see how any of these are implementing algorithms requiring mutation, since there is no mutation
12:38:15 <vixey`> Baughn: oh??
12:38:24 <vixey`> Baughn: which version and how do I use it?
12:38:29 <dmwit> 6.8 and up
12:38:31 <Baughn> atp, vixey: I suggest you read http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.cs.cmu.edu%2F~rwh%2Ftheses%2Fokasaki.pdf&ei=I6lBSNFwlJLBAeOjkLQI&usg=AFQjCNGXKQqKJho73FE372EjGzUoeSJm1w&sig2=ej03n0rIzbGym2DY-Bw3iQ if you're.. interested... gah, google
12:38:33 <lambdabot> http://tinyurl.com/5qc5qq
12:38:46 <Baughn> vixey`: 6.8.2, and read the docs. I haven't.
12:39:09 <ddarius> atp: Implement let ones = 1 : ones in C.
12:39:21 <Baughn> atp: Well, because to make it efficient you *have* to think about the mutation that's going on under the scenes
12:39:24 <atp> ddarius: why would i do that?
12:39:25 <dmwit> vixey`, gpds: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
12:39:26 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2orwlb
12:39:35 <Baughn> atp: Not to mention that half the time you're adapting an algorithm that explicitly uses mutation
12:39:43 <geezusfreeek> vixey`: you can set breakpoints with :break, step with :step, and trace with :traceâ¦ pretty simple, really, although the jumping around every time you :step (because of lazy eval) feels weird and not helpful to me most of the time
12:39:46 <ddarius> atp: Because you'd realize that you can't implement it without mutation.
12:40:00 <Baughn> atp: But read that pdf I linked. Murasaki has written a lot I really don't understand yet, so..
12:40:14 <atp> ddarius: i guess i would wonder what "implementing it" means
12:40:30 <atp> ddarius: that doesn't make sense in a strictly evaluating language like C
12:40:41 <atp> ddarius: nor is it very useful, in C
12:40:43 <ddarius> atp: No, but you can easily make a cyclic list in C.
12:40:53 <geezusfreeek> atp: to do it properly would require continuations.
12:40:53 <ddarius> atp: It's just as useful in C as anywhere else.
12:40:55 <atp> ddarius: sure, by manually coding lazy thunks
12:40:58 <geezusfreeek> oh it would be useful
12:41:01 <ddarius> atp: You don't need thunks.
12:41:01 <vixey`> atp: no need for thunks
12:41:18 <atp> so what are you suggesting instead then?
12:41:19 <vixey`> struct list { int e; struct list *tail; }
12:41:22 <atp> oh
12:41:23 <vixey`> Hi grahamhutton!
12:41:23 <atp> i see
12:41:30 <grahamhutton> hi vixey!
12:41:37 <geezusfreeek> oh literally that is fine :)
12:42:11 <atp> i guess i still don't see how this is related to mutation though.  haskell doesn't implement ones that way, internally (does it?)
12:42:24 <Baughn> atp: It does.
12:42:28 <grahamhutton> @users
12:42:29 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:42:31 <geezusfreeek> atp: that is pretty close, if not exact
12:42:33 <Baughn> atp: Except it's got the tail in a union with a function
12:42:40 <ddarius> atp: Yes it does essentially.
12:42:47 <vixey`> grahamhutton: lambdabot is pretty ill recently
12:43:00 <atp> hm
12:43:02 <geezusfreeek> @source repeat
12:43:03 <lambdabot> repeat not available
12:43:09 <Baughn> atp: Well, and that would be an element-strict list, which don't exist. Unless the optimizer makes it that way, I guess.
12:43:12 <vixey`> repeat x = x : repeat x
12:43:18 <Apocalisp> @src map
12:43:18 <lambdabot> map _ []     = []
12:43:18 <lambdabot> map f (x:xs) = f x : map f xs
12:43:23 <Baughn> atp: Basically [Int#]
12:43:24 <ddarius> fix (1:) only allocates one cons cell.
12:43:44 <atp> that's interesting
12:43:44 <ddarius> data StrictList a = Nil | Cons !a (StrictList a)
12:44:01 <NRee1> is there a function which will strip a list of non-numeric characters?
12:44:02 <Baughn> Oh, sure you can /make/ one. ;)
12:44:11 <atp> i guess naively i assumed that it would use thunks and rely on the GC to clean up the unused ones
12:44:21 <vixey`> NRee1: You could use filter with some kind of predicate
12:44:22 <Baughn> ddarius: Incidentally, does that data also store the a inside the struct if it's small enough?
12:44:24 <atp> but i guess the compiler is most likely smart enough to see that they're all the same cons cell
12:44:31 <atp> and since haskell is pure there's no reason not to share them
12:44:39 <ddarius> Baughn: No.
12:44:53 <geezusfreeek> atp: it's actually not compiler smartness at all. it's just the semantics of let
12:44:56 <Baughn> ddarius: Okay, so I actually have to say Int# if I want that?
12:45:21 <NRee1> ah duh thanks vixey... way to use to C :S
12:45:26 <ddarius> Baughn: No, but you need a monomorphic type and -funbox-strict-fields.
12:45:34 <Baughn> atp: let x = 1 : x -- the latter x *has* to be the same one; there's only one x. No extra allocation
12:45:36 <vixey`> data CExp = At | If CExp CExp CExp ; nm At = At ; nm (If At y z) = If At (nm y) (nm z) ; nm (If (If u v w) y z) = nm (If u (nm (If v y z)) (nm (If w y z))) -- interesting
12:45:53 <vixey`> this is always terminates
12:45:57 <atp> Baughn: that's true
12:46:07 <Baughn> atp: Now look at the definition of fix
12:46:23 <geezusfreeek> @src fix
12:46:24 <lambdabot> fix f = let x = f x in x
12:46:37 <atp> well, fix (1:) is equivalent to ones
12:46:41 <atp> obviously
12:46:50 <Baughn> Right, so constant space. ;)
12:46:57 <atp> hm
12:48:08 <Baughn> atp: The optimizer will sometimes /add/ sharing (by floating lets), but never remove it
12:48:23 <atp> interesting
12:49:22 <Baughn> And although a lot of expression get rewritten to use lets in the compiler, once you're past that stage I'm pretty sure you can actually count allocations by counting the number of times you enter a let
12:49:27 <dolio> It won't add sharing very often, currently.
12:49:44 <simony> is there a tutorial anywhere about use of multidimensional arrays? Does it make sense to use (Int,Int) as the Ix type?
12:49:52 <atp> yeah
12:49:57 <atp> that's what i do
12:50:03 <Baughn> simony: Be warned, there is no bounds-checking on the Ix type
12:50:08 <vixey`> simony: or ((Int,Int),(Int,Int)) ?
12:50:17 <vixey`> @src Ix
12:50:17 <lambdabot> class (Ord a) => Ix a where
12:50:17 <lambdabot>     range           :: (a,a) -> [a]
12:50:17 <lambdabot>     index           :: (a,a) -> a -> Int
12:50:17 <lambdabot>     inRange         :: (a,a) -> a -> Bool
12:50:17 <lambdabot>     rangeSize       :: (a,a) -> Int
12:50:24 <simony> Baughn, So its unsafe?
12:50:31 <simony> Baughn, Silly that Haskell has UB
12:50:31 <atp> why wouldn't there be bounds checking?
12:50:36 <Baughn> simony: No array overruns, but if you specify (0,5) on an array with dimensions (2,4) it'll /work/
12:50:41 <vixey`> > range ((0,30),(5,9))
12:50:42 <lambdabot>  []
12:50:44 <Baughn> simony: It's not UB, though. Perfectly predictable.
12:50:47 <vixey`> > range ((0,0),(5,9))
12:50:48 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1,...
12:51:11 <dolio> > listArray (0,5) [1,2,3,4,5,6] ! 6
12:51:12 <lambdabot>  Exception: Error in array index
12:51:15 <simony> I don't understand - does (a,a) represent (start, stop) ?
12:51:17 <vixey`> aw I wanted to ask something ..
12:51:22 <vixey`> simony: yes
12:51:32 <atp> yeah, so you just do ((0, 0), (5, 5)) or whatever
12:51:35 <vixey`> > range (0,3)
12:51:37 <lambdabot>  [0,1,2,3]
12:51:37 <Baughn> simony: Basically, (0,5) gets interpreted as "0*2+5", while (2,1) would be "2*2+1". Both get element 6
12:51:43 <atp> because it's Ix i => (i, i)
12:51:43 <mrd> ((startx,starty),(finishx,finishy)) mind you
12:51:46 <vixey`> > range ((0,0),(3,4))
12:51:47 <dolio> > listArray ((0,0),(2,2)) [1,2,3,4,5,6] ! (3,3)
12:51:47 <lambdabot>  [(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),(1,1),(1,2),(1,3),(1,4),(2,0),(2,1),(2,...
12:51:48 <lambdabot>  Exception: Error in array index
12:51:57 <mrd> if you're doing 2-d
12:52:16 <atp> runtime exceptions are annoying
12:52:29 <atp> haskell should not have them
12:52:31 <vixey`> atp, yeah let's get rid of them :)
12:52:34 <atp> this is what we have Maybe for
12:52:34 <Baughn> > listArray ((0,0),(2,2)) [1,2,3,4,5,6] ! (0,3)
12:52:35 <lambdabot>  4
12:52:38 <atp> vixey`: exactly
12:52:44 <vixey`> atp: no not maybe
12:52:51 <atp> or Either or Error or whatever
12:52:53 <vixey`> atp: correct programs
12:53:06 <simony> Maybe in this case would probably make sense
12:53:08 <atp> vixey`: some things you can't prove at compile time without solving the halting problem though
12:53:14 <vixey`> atp: "incapable of error"
12:53:24 <atp> the vast majority of exceptions that can occur can be fixed with maybe
12:53:28 <sclv> vixey`: you want the arrays library to be built on type-level nats!?
12:53:38 <mrd> @faq can haskell decide the undecidable?
12:53:38 <lambdabot> The answer is: Yes! Haskell can do that.
12:53:40 <Baughn> sclv: It would be a nice option
12:53:43 <dolio> Baughn: That seems buggish.
12:53:44 <mrd> woo, what are we waiting for
12:53:49 <vixey`> sclv: no not in haskell
12:53:54 <vixey`> that would not be nice to work with
12:53:58 <Baughn> dolio: Nobody ever bothered to add the safeArrayReference code
12:54:12 <geezusfreeek> atp: so long as you can only fail in one way or otherwise don't need to explain why it failed
12:54:30 <dolio> > inRange ((0,0),(2,2)) (0,3)
12:54:31 <lambdabot>  False
12:54:50 <Baughn> And yes, it's trivial
12:55:10 <atp> geezusfreeek: in situations when several exceptions can occur, Either or better yet Error would be fine
12:55:22 <atp> geezusfreeek: it just annoys me that haskell programs can crash
12:55:32 <ddarius> Wait, does this mean I could use (0,n) to linearly index a multidimensional array?
12:55:42 <Baughn> ddarius: Yes
12:55:49 <ddarius> Sweet!  I could have used that.
12:55:51 <geezusfreeek> atp: well you know you can catch exceptions in the top level?
12:55:58 <geezusfreeek> which still sucks, but still
12:56:02 <dolio> Heh.
12:56:34 <Baughn> ddarius: Personally, I'd favor exposing the aRef function ! uses directly instead. That /is/ linear, period.
12:56:38 <atp> i think the 1-point compactification of R is still a field
12:56:49 <atp> although it breaks ordering, of course
12:57:07 <vixey`> (0 + 0) + 0 = 0 + (0 + 0)
12:57:16 <vixey`> 0 * (0 + 0) = 0 * 0 + 0 * 0
12:57:21 <vixey`> this is easy!
12:57:29 <mrd> yay
12:57:29 <atp> ?
12:58:53 <hpaste>  travisbrady pasted "Stack space overflow in RLE function" at http://hpaste.org/8011
12:59:28 <travisbrady> can anyone help me understand how to rewrite this so i don't get a stack overflow?
12:59:30 <ddarius> travisbrady: Remember when I said your code was jacked the other day.
12:59:30 <Baughn> travisbrady: Hm. Does it stop breaking if you remove the reverse?
12:59:34 <ddarius> ?
12:59:43 <travisbrady> ddarius: i do yes
12:59:58 <travisbrady> ddarius: but all you said was "use guards, not a case"
13:00:11 <travisbrady> ddarius: "jacked" doesn't get me very far
13:00:14 <ddarius> travisbrady: Yeah, that was just about the "ugly" stuff.  I didn't get into the problem stuff.
13:00:38 <travisbrady> ddarius: i agree it's not beautiful, but i'm a newbie
13:00:51 <travisbrady> any beauty pointers are much appreciated too
13:00:55 <ddarius> travisbrady: Enable bang patterns and and change i to !i in each of the clauses of your encode_acc function.
13:01:02 <dmwit> This isn't actually helpful, but: return () at the end is completely unnecessary.
13:01:50 <geezusfreeek> in fact, i would just do: main = mapM_ print $ encode fake
13:01:59 <dmwit> So would I.
13:03:22 <simony> what's the O() of reading/writing random array indices?
13:03:39 <ddarius> O(1) it's an array
13:03:40 <geezusfreeek> for an array it should be O(1)
13:03:45 <Baughn> simony: O(1) and O(n) respectively
13:03:45 <ddarius> O(n) for writing
13:03:54 <simony> I see, thanks
13:04:09 <mjrosenb> wow, it looks like ghc has hung
13:04:24 <Baughn> simony: Note that arrays are lazy in their elements. This can be handy
13:04:30 <geezusfreeek> mjrosenb: ew
13:04:53 <mjrosenb> this can't bode well
13:04:59 * mjrosenb retries with -v
13:05:31 <mjrosenb> *** Renamer/typechecker:
13:05:38 <mjrosenb> and.... nothing
13:06:06 <mjrosenb> since this is 2 files that total 32 lines
13:06:23 <mjrosenb> I'm going to assume that it isn't just taking it's time
13:06:27 <atp> HM can be exponential in some cases
13:06:41 <atp> if you're doing some crazy type system voodoo
13:07:37 <hpaste>  dons annotated "Stack space overflow in RLE function" with "fixed" at http://hpaste.org/8011#a1
13:08:10 <dons> travisbrady_: ^ (i added a bang on your Int accumulator, and while I was at it replaced the lazy triple with an strict triple)
13:08:37 <mjrosenb> exponential sure, but exponential in 32 loc shouldn't take that long
13:08:40 <travisbrady_> dons: ahh, thank you.  i'm actually looking at your recent post re: the mean function
13:08:54 <ddarius> dons: You don't use P
13:09:09 <atp> nevermind, the 1-point compactification of R is not a field, but i don't think that's much of a problem
13:09:18 <dons> ddarius: right. that's a dropping
13:09:23 <ddarius> and you might as well s/encode_acc/encodeAcc
13:10:10 <travisbrady_> dons: what does UNPACK do?
13:11:05 <travisbrady_> dons: wow, holy moly
13:11:10 <dons> oh, its over the top here, but it unpacks the int constructor into the T type, saving a register.
13:11:14 <dons> an indirection, i mean
13:11:38 <travisbrady_> what did that?  it's so fast now
13:12:02 <dons> what did what?
13:12:17 <ddarius> Creating 100000 thunks takes a lot longer than incrementing a register/memory location 100000 times.
13:12:41 <travisbrady_> dons: just wondering which change exactly enabled this to now finish running and do so so quickly
13:12:44 <travisbrady_> the strict triple?
13:12:52 <atp> and the bang
13:12:57 <dons> one or the other, or both :)
13:13:09 <dons> i did them both simultaneously, since generally they're good transformations to make
13:13:15 <travisbrady_> dons: oh ok
13:13:17 <mjrosenb> sweet, it looks like ghc has hung
13:13:27 <atp> does ghc -O2 not do this automagically?
13:13:27 <mjrosenb> gah, wrong terminal
13:13:33 <dons> the bang is not required, i suspect
13:13:40 <dons> since its given as Int, ghc will spot that.
13:13:55 <dons> ah no, it is. huh.
13:14:02 <ddarius> encode_acc couldn't be made strict otherwise.
13:14:08 <ddarius> atp: No, these change the semantics.
13:14:10 <mjrosenb> even better, a type annotation made it hang
13:14:28 <dons> yeah, there's no worker/wrapper at play, so it looks like a fully lazy loop
13:15:20 <travisbrady_> dons: why was it that before my version ran out of space, i thought my lists were all fully lazy
13:15:42 <dons> the loop was accumulating a lot of i+1's
13:15:51 <Baughn> travisbrady_: + isn't lazy. HOw many did it have to evaluate at once?
13:15:51 <dons> as were the lazy triple results
13:16:27 <travisbrady_> ahhhh, i didn't know that
13:16:40 <dons> interesting, there's a worker/wrapper split done on encode_acc
13:16:45 <travisbrady_> my mechanism for understanding lazy lists so far has been generators in python
13:16:50 <dons> $s$wencode_acc :: [T] -> [Int] -> Int# -> Int# -> Int# -> Int# -> [T]
13:16:56 <Baughn> travisbrady_: Though if you want you can implement a lazy integer type
13:16:56 <dons> the T is unpacked into registers.
13:17:29 <travisbrady_> so i was thinking everything would just magically get generated only as needed and then gc'd
13:17:34 <travisbrady_> this is very cool
13:17:54 <ddarius> travisbrady: The laziness of lists is irrelevant here.
13:18:03 <dons> you have to watch those tail recursive loops.
13:18:17 <dons> passing around arguments, that aren't strict. they'll just build up long chains of thunks
13:18:50 <dons> yeah, spec constr ftw.
13:18:58 <dons> that's what is happening. it sees we build up a T x y z
13:19:03 <dons> and then avoids the constructor
13:19:14 <dons> tricky
13:19:19 <travisbrady_> ddarius: i'm not sure i understand, i thought laziness meant that memory isn't allocated until each bit is needed
13:19:19 <dons> i'd probably not have done that by hand.
13:19:37 <atp> meaning it was smarter than you, or you than it?
13:19:45 <dons> atp, it was smarter.
13:19:52 <atp> nice
13:19:56 <dons> ghc splits encode into two different functions
13:19:57 <ddarius> travisbrady_: The list isn't the problem here.
13:20:07 <dons> avoiding building T in one of them.
13:20:10 <ddarius> However, you could probably improve encode_acc by making it immediately return results.
13:20:15 <travisbrady_> ddarius: ok, i understand now
13:20:48 <dons> atp, this case:
13:20:49 <dons> encode_acc (x:xs) i (this@(T val sp rl):accs) | x == val  = encode_acc xs (i+1) (T val sp (rl+1) : accs)
13:21:03 <dons> we take apart a T , then put it back together in the tail call
13:21:18 <atp> ahh
13:21:19 <dons> so ghc generates a worker function that keeps the T out of it, storing the 3 fields in registers instead.
13:21:23 <travisbrady_> ddarius: how do you mean "immediately return results"?
13:21:26 <atp> nice
13:21:36 <atp> removes the indirection entirely
13:21:44 <dons> yeah, that's new. i'd wager ghc is the only FP compiler doing that transformation too
13:21:51 <dons> its pretty cool
13:22:08 <dons> and with the strict fields of T, those components then end up in 3 registers
13:22:20 <atp> that is pretty cool.  yeah, i saw the core you pasted... three Int#s
13:23:02 <atp> sometimes ghc is fairly scary, i have to say :)
13:23:32 <dons> so this optimisation removes the abstract penalty of data types in tight loops
13:23:53 <dons> matching and reconstructing them is basically free
13:24:04 <atp> which is great, because it allows the programmer to reduce his own cognitive load by passing around abstract datatypes without incurring a performance penalty for it
13:24:13 <atp> at least in this situation
13:24:29 <dons> yeah, things like T !Int !Int !Int are conceptually just a table of 3 registers when used in a loop
13:24:37 <atp> nod
13:24:50 <atp> so, does it do that only if you spine-strict the triple?
13:25:06 <atp> or does ghc strictify it as a matter of course
13:25:13 <dons> well, it'll spot the (,,) constructor too, but the Int fields won't be unlifted.
13:25:19 <atp> hm
13:25:37 <scodil> has anyone ever tried, or know any attempts at using a big state machine for GUI stuff? Like, instead of having all your callbacks be of type IO (), they would instead be something like IO (Callback), where the callback returns another callback which is the new state of the program? Maybe currying some values in there or something. Would this scale to large programs?
13:25:40 <dons> so you'll get constructor specialisation, but it'll be up to the strictness analyser to see if the Int fields are strict enough
13:25:59 <hpaste>  ddarius annotated "Stack space overflow in RLE function" with "lazier (untested)" at http://hpaste.org/8011#a2
13:26:01 <atp> scodil: continuations?
13:26:14 <atp> dons: hm.
13:26:26 <scodil> atp: yeah sort of
13:26:37 <scodil> are the continuation-based gui libraries?
13:26:40 <scodil> are there
13:27:09 <atp> i don't actually know
13:27:12 <atp> good question
13:27:23 <atp> i bet a continuation based gui library would be very nice to use though.
13:27:32 <ddarius> dons: Could you give that new annotation a run?
13:27:36 <dons> yep
13:27:53 <atp> ddarius: you just elided two of the cases in encodeAcc, right?
13:27:54 <dons> Stack space overflow: current size 8388608 bytes.
13:27:55 <dons> Use `+RTS -Ksize' to increase it.
13:28:08 <scodil> for small stuff yeah it seems great. but i don't know if it bogs down for larger programs because you have to pipe all input events (menus, buttons, etc) through the same function
13:28:25 <scodil> would there be a way to have separate continuation "threads" going and have them synchronize some how?
13:28:27 <ddarius> Ah, needs a bang on the other clause of encodeAcc now.
13:28:35 <dons> ah yes
13:28:38 <atp> scodil: well you'd most likely be passing a pointer to a data structure so i don't see why it would bog down
13:28:52 <dons> yep, that does it.
13:28:54 <scodil> atp: no no I'm talking about organization of code. not performance
13:29:12 <ddarius> dons: Is the performance better/worse/similar?
13:29:12 <scodil> I'm sure it would be plenty fast
13:29:18 <atp> scodil: in haskell you'd most likely hide it all in a monad and not worry about it
13:29:19 <dons> ddarius: almost identical
13:29:21 <dons> same loop basically
13:29:29 <atp> core is the same?
13:29:42 <hpaste>  ddarius annotated "Stack space overflow in RLE function" with "+bang" at http://hpaste.org/8011#a3
13:29:42 <atp> if not, what's different?
13:29:59 <simony> hoogle searches textually, and not semantically?  as in:  looking for "a -> a -> b" will not find "j -> j -> k" ?
13:30:05 <dons> yeah, i think its the same function.
13:30:25 <EvilTerran> ?hoogle (foo -> bar) -> [foo] -> [bar]
13:30:25 <lambdabot> Did you mean: (Foo -> Bar) -> [Foo] -> [Bar]
13:30:25 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
13:30:25 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
13:30:29 <atp> i would expect it to be, naively
13:30:39 <atp> but i don't know enough to have that mean anything
13:30:40 <EvilTerran> simony, semantically, ish
13:30:41 <ddarius> The new one should be lazier.  E.g. head (encode fake) should be much faster than the head (encode fake) on the old one.
13:30:50 <EvilTerran> ?hoogle [foo] -> (foo -> bar) -> [bar]
13:30:50 <dons> its close to the same
13:30:50 <lambdabot> Did you mean: [Foo] -> (Foo -> Bar) -> [Bar]
13:30:50 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
13:30:50 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
13:30:53 <EvilTerran> also works
13:31:06 <hpaste>  dons annotated "Stack space overflow in RLE function" with "comparing" at http://hpaste.org/8011#a4
13:31:48 <atp> ddarius: i see what you mean, i would expect that too, looking at it
13:31:50 <dons> one is guarded under  the constructor, one passes the accumulator still
13:31:53 <atp> ddarius: yours is a right fold
13:32:08 <atp> ddarius: almost
13:32:45 <dons> that's a good result.
13:32:59 <ddarius> dons: Yes it is.
13:33:00 <travisbrady_> dons: with your version performance for me is much better w/o the C backend
13:33:19 <travisbrady_> is that strange?
13:33:58 <dons> which gcc versoin?
13:34:25 <dons> yeah, i get a win too.
13:34:29 <dons> -fasm is a bit faster.
13:34:33 <travisbrady_> i686-apple-darwin9-gcc-4.0.1 (GCC) 4.0.1 (Apple Inc. build 5465)
13:34:38 <atp> now correct me if i'm wrong, but in core only let introduces a lazy thunk?  and case reduces one?
13:34:50 <dons> right, as long as the let is binding a lifted value
13:34:58 <dons> let x = 1# -- also valid, but not a thunk
13:35:04 <atp> ah i see
13:35:15 <scodil> what does that do? "let x = 1#"
13:35:15 <atp> because the # forces the 1 to be unboxed
13:35:17 <travisbrady_> oh actually maybe not
13:35:17 <dons> i don't recall what the operational meaning of an unlifted let in STG was.
13:35:22 <travisbrady_> it was in a few hand tests
13:35:26 <atp> scodil: this is Haskell core, not haskell :p
13:35:27 <dons> it's not in the original paper.
13:35:31 <scodil> i know
13:35:33 <travisbrady_> now they're very nearly the same
13:35:55 <dmwit> scodil: 1# is an unboxed 1, if I understand it correctly.
13:36:15 <simony> is there an arrayToList/flatten?
13:36:17 <atp> scodil: let x = 1 is a thunk (ie, a pointer that points to 1)
13:36:24 <scodil> i know that too. what does "let x = 1#" cause the computer to do, if not allocate a thunk?
13:36:31 <atp> scodil: but let x = 1# means that x in just 1
13:36:34 <atp> right?
13:36:38 <EvilTerran> ?hoogle Array i e -> [(i,e)]
13:36:38 * atp isn't actually sure.
13:36:38 <lambdabot> No matches, try a more general search
13:36:41 <EvilTerran> ?hoogle Array i e -> [(e]
13:36:41 <lambdabot> No matches, try a more general search
13:36:43 <EvilTerran> ?hoogle Array i e -> [e]
13:36:43 <lambdabot> No matches, try a more general search
13:36:49 <dons> just assigns a register or stack slot for 1# ?
13:36:54 <scodil> so its just a name-binding? no instructions generated?
13:37:02 <scodil> oh ok
13:37:04 <simony> elems, I guess
13:37:05 <scodil> that makes sense
13:37:13 <dons> i'm guessing. it wasn't in the original STG paper, so we'd need to dig around
13:37:26 <dons> oh, actually, we can do better than that.
13:37:28 <atp> hm, dons, you mean that let x = 1 might not only cause indirection, but also heap allocation?
13:38:28 <travisbrady_> where can i find the tmp files if i use -keep-tmp-files?
13:38:34 <dons> huh, you can bind let to unlifted values even in src haskell.
13:38:57 <atp> let x = 1# is legal in src?
13:39:04 <dmwit> travisbrady_: Usually in .
13:39:18 <travisbrady_> dmwit: hmmm...
13:39:22 <ddarius> let 0# = 1# ...
13:39:42 <atp> > let x = 1# in x
13:39:43 <lambdabot>  Parse error at "in" (column 12)
13:39:49 <travisbrady_> dmwit: what sort of file should i be looking for?
13:39:59 <dmwit> .h?
13:40:00 <ddarius> :t let x = 1# in x
13:40:01 <lambdabot> GHC.Prim.Int#
13:40:07 <dons> there you go.
13:40:09 <dons> so what does that mean?
13:40:10 <ddarius> :t let 0# = 1# in x
13:40:12 <lambdabot> Expr
13:40:18 <ddarius> :t let x@0# = 1# in
13:40:20 <ddarius> :t let x@0# = 1# in x
13:40:20 <lambdabot> parse error (possibly incorrect indentation)
13:40:21 <lambdabot> GHC.Prim.Int#
13:40:30 <ddarius> Okay what happens in that last case...
13:40:51 <atp> x is obviously a thunk?
13:41:12 <scodil> how could it be? what does the GC do with it?
13:41:13 <dons> main =
13:41:13 <dons>   (patError @ Int# "C.hs:5:16-24|pattern binding")
13:41:13 <dons>   `cast` (CoUnsafe Int# (IO ())
13:41:13 <dons>           :: Int# ~ IO ())
13:41:15 <atp> there must be indirection or it should error since 0# = 1# is obviously false
13:41:17 <dons> is what it compiles to...
13:41:26 <ddarius> dons: For what source?
13:41:38 <dons> {-# LANGUAGE MagicHash #-}
13:41:38 <dons> import GHC.Base
13:41:38 <dons> main = print (I# y)
13:41:38 <dons>     where
13:41:38 <dons>         y = let x@0# = 1# in x
13:41:40 <dons>         {-# NOINLINE y #-}
13:41:51 <dons> i'm trying to get 'y' in isolation.
13:42:15 <atp> what does CoUnsafe mean?
13:42:39 <dons> oh, there's a newtype
13:42:52 <dons> oh weird. that's a funny one.
13:43:02 <atp> that has some syntax i don't quite grok...
13:43:04 <atp> the ~ for one
13:43:07 <dons> its System Fc
13:43:12 <dons> type coercion
13:43:35 <dons> the print was boiled away, and an error of notional type Int# was replaced
13:43:44 <dons> so it did turn it into a bottom value, ddarius
13:43:58 <augustss> CoUnsafe == Safe ?
13:43:58 <dons> patError @ Int# is a bit odd
13:44:19 <dons> augustss: any idea what let x@0# = 1# in x    would mean/
13:44:33 <augustss> nope
13:44:37 * dons is surprised unlifted let bindings are legal in .hs
13:44:46 * atp too
13:45:21 * bos speeds up the bloom filter by another 10%.
13:45:21 <augustss> unlifted lets seem reasonable to me
13:45:31 <SamB> dons: JHC doesn't seem to like them...
13:45:33 <augustss> good work bos!
13:45:50 <Baughn> augustss: Breaks several invariants, though
13:46:07 <dons> well, it has some interpretation in Core. Interesting its been exposed in the source level too
13:46:25 <Baughn> Not that anyone cares whether a single word is shared or not
13:46:29 <bos> augustss: it's kind of shameful. i'm packing two Word32 values into a Word64 instead of using a strict unpacked pair, and it's faster.
13:46:42 <augustss> I think it's time for a new design where unboxed values are first class rather than second class as it is now
13:47:04 <dons> bos, hmm, a specialised pair?
13:47:07 <dons> T !Int !Int ?
13:47:17 <augustss> bos: tell Simon
13:47:58 <dons> polymorphic ones won't get picked up by CPR if they're returned, so you'll end up with a heap check.
13:48:00 <bos> the code is 50% faster on a 32-bit machine, too.
13:48:10 <bos> dons: i suspected as much.
13:48:28 <dons> but specialised strict pairs should work fine.
13:48:36 <Saizan> CPR?
13:48:51 <ddarius> cardiopulmonary resuscitation
13:49:00 <dons> the taking apart of result products so their components are returned in registers, Saizan
13:49:13 <ddarius> Constructed Product Result, no?
13:49:17 <SamB> augustss: care to sketch it out?
13:49:19 <dons> Saizan: http://citeseer.ist.psu.edu/baker-finch00constructed.html
13:49:20 <lambdabot> Title: Constructed Product Result Analysis for Haskell (ResearchIndex)
13:49:53 <Saizan> thanks
13:50:15 <augustss> SamB: the new design?  I just want polymorphic functions to work on unboxed values.  So it needs a different implementation technique
13:50:54 <SamB> yes
13:51:01 <SamB> I was hoping you had one in mind ;-)
13:53:26 <augustss> SamB: no details :)
14:00:06 <dobblego> can you tell lambdabot to /msg nickserv to identify? I know it should be automatic, but I don't have access to the machine running my lambdabot at the moment and it is not identified
14:01:54 <dobblego> @msg
14:01:54 <lambdabot> Not enough privileges
14:03:50 <SamB> dobblego: why didn't you add yourself to the list of admins???
14:04:01 <SamB> oh, wait, you added dibblego didn't you?
14:04:04 <dobblego> SamB, I have
14:04:18 <dobblego> SamB, I'm talking about a different lambdabot instance (not in this channel)
14:04:37 <dobblego> SamB, I thought I'd told it to autoidentify as well, but clearly not, so I used @msg to identify
14:10:44 <bos> i wonder if GHC's CPR would kick in if i specialised a function's return type from (a,b) to (Int,Int) with a SPECIALIZE pragma.
14:11:21 <bos> or maybe it just can't handle non-tuple ADTs.
14:11:26 * bos scratches head.
14:12:43 <dons> it can handle things normal product types, T Int Int etc.
14:13:06 <dons> just check the loop returns (# Int#, Int# #) , instead of T Int Int, or (# Int, Int #)
14:13:35 <augur> question about haskell's laziness
14:13:39 <augur> suppose you have the function
14:13:56 <augur> avg xs = (sum xs) / (length xs)
14:14:06 <Bonus> that wont work :)
14:14:09 <augur> no?
14:14:16 <augur> why not??
14:14:23 <Bonus> because length gives an int
14:14:31 <Bonus> and / doesn't expect an int
14:14:32 <dons> augur: hehe.
14:14:33 <Bonus> gotta use fromIntegral
14:14:49 <monochrom> @quote fromIntegral
14:14:49 <augur> oh, well pretend that did work, since the question isnt about numbers :P
14:14:49 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
14:14:55 <Bonus> oh right sorry :)
14:14:57 <dons> augur: see http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16
14:14:59 <lambdabot> Title: Haskell hacking
14:15:03 <ddarius> :t genericLength
14:15:07 <lambdabot> forall b i. (Num i) => [b] -> i
14:15:18 <augur> this would require that the whole list be cached in memory when evaluated for (sum xs) right?
14:15:43 <monochrom> Yes, waiting for evaluation of length xs later.
14:15:48 <augur> ok
14:15:58 <augur> so this particular definition of avg is a really crappy definition
14:16:01 <dons> yep.
14:16:06 <dons> good definition
14:16:08 <dons> bad implementation
14:16:12 <augur> ok :)
14:16:19 <Bonus> its one of the gotchas of haskell
14:16:21 <Bonus> but oh well
14:16:22 <monochrom> sum [1..1000] / length [1..1000]  will not keep the whole list in memory.
14:16:22 <dons> see the above url for a detailed discussion
14:16:29 <ddarius> dons: Where's that later post?
14:16:32 <dons> its a crappy definition in any mainstream language
14:16:44 <dons> ddarius: its sitting on my hard drive. i'll put it up next week
14:16:48 <Bonus> yeah i'd do it with a fold
14:16:57 * monochrom steals dons's hard drive.
14:17:29 <Bonus> dons: do all your posts show up in planet haskell by default?
14:17:51 * monochrom finds a powerful optimization waiting to be released next year.  It's waiting because we don't want to make other languages look that bad. :)
14:18:09 <Bonus> hehe
14:19:29 <monochrom> (And because we really believe in lazy evaluation!  An optimization isn't released until someone asks for it in haskell-cafe.  Note the extremely short latency between asking and supplying!)
14:20:29 <Bonus> hehe, a guy i know once made a cool foot shooting joke for haskell
14:20:38 <monochrom> I want to hear!
14:20:39 <Bonus> you shoot yourself in the foot but the hole doesn't appear until you look at the foot
14:20:47 <monochrom> hahahaha.
14:20:58 <Bonus> the best foot shooting one for haskell imho :)
14:22:03 <monochrom> A corollary is a joke about the sound of a tree falling in a Haskell forest. :)
14:23:43 <augur> you know
14:23:55 <Bonus> haha
14:23:56 <augur> reality has lazy evaluation.
14:24:27 <augur> particles dont exist in any one place until you look. until then they're just probability waves. :)
14:25:02 <edward1> augur: or you could just as consistently consider that you yourself become part of that collapsed wave function. just change your frame of reference and then there is no weirdness ;)
14:25:07 <dmwit> "Effects are just not an option.  Result: prolonged embarrassment."
14:25:58 <SamB> monochrom: you mean...
14:26:25 <SamB> in Haskell, if there is nobody there to hear it, the tree never fell?
14:26:42 <dmwit> hehe
14:26:48 <newsham> I think thats in the IO monad
14:28:42 <newsham> alive <- open (box schroedingerscat)
14:29:12 <dmwit> "The next Haskell will be strict, but still pure." -- on a page titled "SPLJ conclusions"
14:29:15 <dmwit> Can that be right?
14:29:18 <Bonus> schrodinger's cat lives in the Maybe monad :D
14:29:22 <Bonus> MAYBE
14:29:34 <SamB> dmwit: what page?
14:29:48 <Bonus> i thought laziness is one of the basic tenets of python
14:29:51 <Bonus> ugh
14:29:52 <Bonus> i mean haskell
14:29:52 <Bonus> lol
14:29:53 <Bonus> owned
14:29:59 <dmwit> http://portal.acm.org/supp_gateway.cfm?id=1238856&type=pdf&path=%2F1240000%2F1238856%2Fsupp%2FHaskell%2Epdf&coll=GUIDE&dl=GUIDE&CFID=30248690&CFTOKEN=97968208
14:30:10 <Bonus> thats like saying the java 7 will be dynamically typed
14:30:13 <dmwit> page 38
14:30:31 <newsham> is it dated apr1?
14:30:31 <Bonus> won't the next Haskell be Haskell'
14:31:26 <SamB> @remember Bonus <Bonus> i thought laziness is one of the basic tenets of python <Bonus> ugh <Bonus> i mean haskell
14:31:26 <lambdabot> Done.
14:32:48 <SamB> dmwit: I'm not at school atm...
14:33:02 <dmwit> hum, one sec
14:33:07 <mrd> laziness is one of the basic tenets of
14:33:26 <Bonus> the keys are right next to each other
14:33:53 <dmwit> http://buckwheat.stanford.edu/Haskell.pdf
14:33:57 <dmwit> SamB
14:35:31 <monochrom> "If you run sum xs / length xs but no one is there, does it take up memory?" :)
14:35:42 <shepheb> it would be curious to have both default-lazy and default-strict Haskell coexisting, to be toggled with a directive. which would get used more?
14:35:59 <Bonus> i think lazy
14:36:27 <shepheb> I tend to agree. I think if you took the laziness out, we'd realize how many little idioms rely on it.
14:36:28 <idnar> I imagine a lot of existing Haskell code wouldn't work if you turned the strict switch on
14:36:32 <Elly> shepheb: default-strict haskell is sometimes called "SML" :P
14:36:40 <Elly> idnar: or rather wouldn't terminate
14:36:41 <idnar> so most people wouldn't turn it on just because it would break their programs
14:37:00 <dobblego> most people wouldn't turn it on, because it is not as useful
14:37:03 <vixey`> SML has side effects though
14:37:17 <Elly> Haskell does too
14:37:35 <Elly> IO is still a side effect!
14:38:20 <SamB> Elly: it's not ... sidey-enough
14:38:22 <monochrom> "haskell the cat" should go into lambdacats!
14:38:24 <shepheb> SML isn't pure. it mixes side effects in like Scheme and such.
14:38:26 <idnar> Elly: if your program is expected to terminate, and doesn't, then I'd say it's broken :P
14:38:43 <idnar> Elly: why is IO a side-effect?
14:38:59 <eu-prleu-peupeu> have anyone here read the haskell spec ?
14:39:02 <Elly> I'm not sure?
14:39:08 <dmwit> IO actions do not, themselves, create side effects.
14:39:13 <Elly> I've just always thought of IO as the canonical side effect
14:39:20 <dmwit> eu-prleu-peupeu: Several people have; I suggest just asking your question. ;-)
14:39:30 <idnar> IO plays the role that side-effects play in some other languages
14:39:39 <eu-prleu-peupeu> is it worth reading as a begginer ?
14:40:01 <dmwit> The Haskell Report is dense, but readable.
14:40:23 <dmwit> One of the most readable specs I've seen (though that isn't saying much).
14:40:48 <vixey`> R5RS and CLHS are nice too
14:41:27 <SamB> Elly: IO is like right-smack-in-the-front effects
14:41:27 <dmwit> So, does Arvind just not have a last name?
14:41:33 <vixey`> I never bothered to read the report though
14:41:43 <vixey`> just reference it sometimes
14:41:52 <newsham> an IO thing is just the instructions for how to do a side effect
14:41:58 <newsham> its the IO-runner that does the side effects
14:42:05 <dmwit> exactly
14:42:06 <mrd> http://web.comlab.ox.ac.uk/oucl/research/areas/ap/papers/jfphaste.ps.gz
14:42:09 <lambdabot> http://tinyurl.com/6edbny
14:42:17 <mrd> ^ about eager, pure vs lazy, pure
14:42:18 <SamB> actually, I think it's just called an effect
14:42:22 <tusho> hmm
14:42:23 <monochrom> I started looking for things in the Haskell Report very early on.
14:42:24 <SamB> not a side effect
14:42:27 <tusho> you can simulate dependent types in hs can't you?
14:42:33 <SamB> since there is no side involved
14:42:46 <dmwit> tusho: GADTs are kind of like dependent types.  a little
14:42:50 <vixey`> tusho: You can do a lot but not everything
14:43:04 <vixey`> tusho: but undefined :: forall a. a so why bother
14:44:06 <tusho> dmwit: 'sorta' 'maybe' ;)
14:44:12 <newsham> ?type undefined
14:44:14 <lambdabot> forall a. a
14:44:16 <newsham> ?type fix id
14:44:18 <lambdabot> forall a. a
14:44:20 <tusho> vixey`: great non-sequitur there :D
14:44:23 <dmwit> tusho: Yeah, I need a few more quantifiers in there. =P
14:44:30 <newsham> its a very useful proof tool ;-)
14:44:46 <tusho> GADTs are kind of sorta maybe like a little bit of dependent types, maybe, on a tuesday.
14:44:48 <vixey`> tusho: Are you aware of the uses of dependent types?
14:45:02 <tusho> vixey`: Of course. Cayenne is neat.
14:45:08 <newsham> vixey: you can more exactly specify what a function does.
14:45:22 <newsham> for example,  Int -> Int -> Int   is a very very broad underspecification of what (+) does
14:45:23 <vixey`> tusho: ok not so sure why you think it's a non sequiter then
14:45:30 <newsham> (in fact, it also matches what (*) does!)
14:45:42 <vixey`> newsham: that's a fine type for it, the lambda term takes part in proofs too
14:45:45 <tusho> vixey`: I do not see how dependent types and `undefined` mix :-P
14:45:54 <vixey`> tusho: forall a. a
14:46:12 <newsham> tusho: I think he's just saying that the existence of "undefined" make it not so useful as a proof system
14:46:18 <newsham> I dont think that makes it not useful, though.
14:46:26 <tusho> newsham: never said I want it as a proof system!
14:46:28 <vixey`> (she)
14:46:35 <newsham> tusho: i know.
14:46:39 <newsham> vixey: apologies.
14:46:59 <tusho> head [] -> type error and other assorted things are nice, it's the logical follow-up to haskell's types
14:47:22 <newsham> I think gadts are strong enough to handle the empty list problem.
14:47:26 <vixey`> might want to read Faking it - Dependent types in haskell
14:47:35 <newsham> but not quite as general as a full dep type system
14:47:43 <tusho> newsham: really?
14:47:45 <tusho> I'll try that
14:47:59 <tusho> just like another type param that you set to a 'data X' empty type like Empty or NonEmpty, right?
14:48:04 <NRee1> is there a way to "flatten" a list? ex: [[1,2],[3,4]] -> [1,2,3,4]
14:48:04 <tusho> hope I explained that right
14:48:11 <vixey`> Nree1: concat
14:48:13 <dobblego> NRee1, join or concat
14:48:15 <newsham> http://en.wikibooks.org/wiki/Haskell/GADT#Safe_Lists
14:48:26 <vixey`> tusho: there is a lot more to dependant types than just indexing on simple types
14:48:31 <dobblego> NRee1, have you just used map to get that list?
14:48:36 <dobblego> > concat [[1,2],[3,4]]
14:48:37 <tusho> vixey`: of course
14:48:37 <lambdabot>  [1,2,3,4]
14:49:11 <NRee1> yes i did just use a map to get the list
14:49:20 <newsham> > join [[1,2],[3,4]]
14:49:21 <lambdabot>  [1,2,3,4]
14:49:30 <dobblego> NRee1, then, you might consider using concatMap instead of map, which will do the map and flatten all at once for you
14:49:30 <tusho> NRee1: instead of map use concatMap
14:49:31 <newsham> concatMap
14:49:34 <tusho> zoop
14:49:37 <tusho> #haskell powah
14:49:38 <dmwit> NRee1: Consider using the list monad instead, then.
14:49:38 <vixey`> (>>=) = flip concatMap
14:49:44 <newsham> now all together in harmony
14:49:45 <tusho> BURN THE HERETIC DMWIT
14:49:51 <tusho> newsham: ok, here goes
14:49:51 <tusho> 1
14:49:52 <tusho> 2
14:49:52 <tusho> 3
14:49:53 <tusho> concatMap
14:49:54 <vixey`> return = (:[])
14:49:59 <tusho> fail
14:50:05 <NRee1> hehe
14:50:14 <dobblego> NRee1, what function are you passing to map?
14:50:52 <NRee1> here ill post it up on hpaste (Im working on project euler btw)
14:50:57 <newsham> > join $ fmap (\a -> [a,a]) [2,3,4]
14:50:57 <dobblego> ok
14:50:58 <lambdabot>  [2,2,3,3,4,4]
14:51:19 <tusho> newsham: why on earth would you do that
14:51:20 <tusho> :P
14:51:41 <tusho> Oh, and the day that fmap becomes (.) will be amusing (obviously a terrible idea, subtle type errors ahoy)
14:51:43 <tusho> id . [1,2,3]
14:51:48 <dmwit> > id . [1,2,3]
14:51:49 <lambdabot>  [1,2,3]
14:52:00 <dmwit> tusho: Prepare to be amused.
14:52:06 <tusho> dmwit: That's caleskell.
14:52:10 <dmwit> true
14:52:10 <tusho> Caleskell is imaginary. :P
14:52:11 <monochrom> haha
14:52:26 <dmwit> > [2..4] >>= replicate 2 -- newsham
14:52:27 <lambdabot>  [2,2,3,3,4,4]
14:52:28 <newsham> > (1 :+ 2) * Caleskell
14:52:28 <lambdabot>   Not in scope: data constructor `Caleskell'
14:52:38 <tusho> Baww, I can't derive read and show for a gadt. How sur-prising. :P
14:53:00 <monochrom> We can't deriving anything for gadt yet.
14:53:01 <tusho> Humph, what's the trivial IO Integer for getting a random number?
14:53:10 <vixey`> tusho: ehird?
14:53:11 <tusho> I know there's tons of functions related, but is there a simple one-shot one?
14:53:11 <roconnor> Why is it so hard for use to overide Cale and remove this silly (.) = fmap thing.
14:53:20 <ziman> > replicate 2 . [4, 5, 6]
14:53:20 <tusho> monochrom: it sounds pretty impossible, at least to my intuition
14:53:21 <dmwit> randomRIO
14:53:22 <lambdabot>  [[4,4],[5,5],[6,6]]
14:53:23 <tusho> vixey`: yes, why?
14:53:32 <dmwit> (@tusho)
14:53:32 <monochrom> Yeah, it's hard.
14:53:40 <newsham> > Data.Sequence.fromList [1,2,3] >>= replicate 2
14:53:41 <lambdabot>  Couldn't match expected type `Data.Sequence.Seq b'
14:54:09 <tusho> @hoogle randomRIO
14:54:10 <lambdabot> System.Random.randomRIO :: Random a => (a, a) -> IO a
14:54:24 <tusho> :\
14:54:30 <tusho> How do I get the tuple to call that with?
14:54:31 <newsham> > Data.Sequence.fromList [1,2,3] >>= \a -> Data.Sequence.fromList [a,a]
14:54:32 <lambdabot>  fromList [1,1,2,2,3,3]
14:54:32 <monochrom> randomRIO (4, 2039)
14:54:36 <tusho> (Apologies: My first doing random stuff in haskell.)
14:54:42 <hpaste>  NReed pasted "(no title)" at http://hpaste.org/8012
14:54:43 <tusho> monochrom: Without manually seeding it :P
14:54:55 <monochrom> No manual seeding necessary.
14:55:09 <NRee1> so there is the little snippet that I'm working on
14:55:16 <tusho> monochrom: OK, then what is (4,2039) doing? Is it not a PRNG state?
14:55:22 <tusho> ohhh
14:55:24 <tusho> it's a range
14:55:25 <tusho> :-P
14:55:25 <dmwit> tusho: That's not a seed, that's the range of the value you want it in.
14:55:30 <dobblego> NRee1, try concatMap groupdOf4 instead of map groupsOf4 and you'll get back a flattened list
14:55:44 <NRee1> k
14:56:17 <dobblego> NRee1, it's called the list monad
14:56:19 <dmwit> :t zip4
14:56:21 <lambdabot> forall a b c d. [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
14:56:38 <tusho> :t zip10
14:56:39 <lambdabot> Not in scope: `zip10'
14:56:45 <dmwit> tusho: up to zip7, I think
14:56:48 <dobblego> NRee1, you could also use theList >>= groupsOf4
14:56:54 <grahamhutton> @users
14:56:55 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:57:08 <tusho> dmwit: DEPENDENT TYPES AND WE COULD HAVE 'ZIP 94454' :p
14:57:10 <grahamhutton> !
14:57:15 <tusho> (that was intentionally silly.)
14:57:21 <dmwit> grahamhutton: My client says there are 440 users here.
14:57:25 <shepheb> a friend and I were trying to come up with a "Haskell programmers do it...". I think he just settled it with "... in half the time". though the double-entendre isn't particularly flattering
14:57:35 <grahamhutton> thanks - what's up with lambdabot?
14:57:41 <tusho> grahamhutton: it's dead.
14:57:42 <tusho> again
14:57:45 <dmwit> Dunno, it's been doing that for a few days, though.
14:57:57 <grahamhutton> oh dear -- how come?
14:58:05 <NRee1> thanks everyone, now it works as hoped
14:58:07 <monochrom> @botsnack
14:58:07 <lambdabot> :)
14:58:09 <tusho> grahamhutton: corrupted database thingy
14:58:18 <newsham> tusho: you can use Applicative to zipWith arbitrary number of args
14:58:26 <newsham> (even 94454 of em :)
14:58:29 <tusho> newsham: shut up, you, and your logic
14:58:31 <tusho> :|
14:58:40 <lambdac> you can use me if you like
14:58:42 <newsham> isnt that what depedent types are all about, logic? :)
14:58:46 <tusho> lambdac: kinky.
14:58:50 <dmwit> :t iterate (. tail) id
14:58:52 <lambdabot> forall a. [[a] -> [a]]
14:58:58 <NRee1> hey I was wondering if any of you guys know of a good book to learn haskell from ( for someone with a C background)? I find that my knowledge is spotty from the tutorials
14:59:02 <tusho> lambdac: help
14:59:03 <lambdac> forall a. [[a] -> [a]]
14:59:08 <tusho> lol wut
14:59:19 <newsham> nree1: graham hutton (who is in here right now :) has a good book
14:59:24 <dmwit> Oh, having two bots in here at once is a little scary.
14:59:32 <grahamhutton> :-)
14:59:33 <lambdac> fine, I'll leave
14:59:36 <monochrom> @botsnack
14:59:36 <lambdac> :)
14:59:36 <lambdabot> :)
14:59:46 <tusho> nooo, don't go
14:59:50 <newsham> nree1: http://www.cs.nott.ac.uk/~gmh/book.html
14:59:50 <tusho> I was just about to loop you guys.
14:59:51 <lambdabot> Title: Programming in Haskell
14:59:59 <edwardk> Nrrol: dons and a couple of others have been writing a book. Portions are online: http://book.realworldhaskell.org/beta/index.html
15:00:00 <lambdabot> Title: Real World Haskell
15:00:01 <lambdac> Title: Real World Haskell
15:00:06 <tusho> <3
15:00:19 <newsham> hmm.. two bots == trouble
15:00:21 <tusho> </3
15:00:48 <NRee1> alright I will look into those two books
15:00:51 <NRee1> thanks
15:01:04 <newsham> btw, www.haskell.org has a list of tutorials and books
15:01:50 <dobblego> Erik Meijer spoke highly of Hutton's book at a recent conference
15:01:55 * monochrom contemplates a book title of "Imaginary Haskell"
15:01:59 <tusho>       Tell GHC HQ if you'd like this to unify the context
15:02:01 <tusho> Yes pls. :P
15:02:44 <tusho> you know haskell's type system is more fun than haskell
15:02:45 <tusho> :|
15:03:04 <newsham> tusho: have you played with agda yet? :)
15:03:12 <dmwit> "So lenses form a category... whew!" =D
15:03:22 <tusho> newsham: absolutely going to soon!
15:03:29 <monochrom> everything forms a category.
15:03:38 <edwardk> dmwit: i should hope so its just a bunch of embedding projection pairs over a base category ;)
15:03:40 <grahamhutton> indeed!
15:05:12 <grahamhutton> edwardk: great blog btw; I guess you have seen Neil Ghani's work on Kan Extensions for FPers?
15:05:16 <newsham> tusho: have you done any proofs in haskell yet?
15:05:33 <tusho> newsham: undefined :: forall a. a
15:05:39 * tusho morphs into newsham and becomes AS ONE
15:05:52 <edwardk> grahamhutton: I've read a bunch of papers by him. A couple of them used Kan extensions heavily. Did that latest one ever materialize in a readable form online?
15:05:55 <newsham> i meant perhaps something more sound :)
15:06:17 <ddarius> monochrom: Haskell doesn't form a category using the "obvious" operations.
15:06:29 <grahamhutton> all his papers are on his web page --- but I don't know anything beyond that.
15:06:37 <edwardk> the links on his page are all broken
15:06:56 <edwardk> well, a good majority of them are
15:07:05 <newsham> ?djinn (a,b) -> Either a b
15:07:05 <lambdabot> f (a, _) = Left a
15:07:09 <ddarius> > Left 'a' <|> Right 'x'
15:07:10 <lambdabot>        add an instance declaration for (Alternative (Either Char))
15:07:10 <lambdabot>     In the...
15:07:20 <edwardk> and if you check his coauthor's page she doesn't have that one linked
15:07:22 <ddarius> > Left "a" <|> Right "x"
15:07:23 <lambdabot>        add an instance declaration for (Alternative (Either [Char]))
15:07:23 <lambdabot>     In t...
15:07:27 <ddarius> Curses.
15:07:28 <tusho> Hmm, what's the magic stuff you do to get the parens in the right place when writing a show instance?
15:07:38 <grahamhutton> yes, they are broken --- i'll mention this to him on Monday...
15:07:39 <newsham> ?instances Alternative
15:07:40 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
15:07:48 <edwardk> grahamhutton: please =)
15:07:59 <tusho> hmmm
15:08:05 <dmwit> tusho: showsPrec?
15:08:13 <tusho> dmwit: sounds about right.
15:08:21 <edwardk> grahamhutton: I met him at ICFP06 back when I was obsessed about comonads in a substructural logic context, but I doubt he remembers me =)
15:08:29 <ddarius> > (1+) <$> Just 3 <|> Just 4
15:08:31 <lambdabot>  Just 4
15:08:38 <tusho> hmm - data Kangaroo a b = Fall a | Jump b | Quantum a b
15:08:41 <ddarius> > (1+) <$> Nothing <|> Just 4
15:08:43 <lambdabot>  Just 4
15:08:44 <tusho> wonder if that has any useful operations
15:08:44 <monochrom> tusho: the method showsPrec takes an extra parameter, intended to be "precedence of the context". You can examine it and decide to add ( ) or not.
15:08:52 <vixey`> :t (<|>)
15:08:54 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
15:09:00 <Bonus> which haskell book do you guys suggest for someone who has a kind of beginner to intermediate knowledge of haskell
15:09:03 <vixey`> @instances Alternative
15:09:03 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
15:09:03 <tusho> monochrom: Really, i'm just writing a Show for my List thingy
15:09:12 <tusho> It should just display like:    Cons 1 (Cons 2 Nil)
15:09:16 <tusho> i.e. like a derived Show
15:09:19 <monochrom> Moreover, if you call showsPrec recursively, you are also responsible for passing the right precedence to the callee.
15:09:26 <dmwit> tusho: How about deriving Show, then?
15:09:33 <Bonus> i.e. know monads, recursion, all the syntax, typeclasses, adts but doesnt know functors, arrows, all that advanced stuff
15:09:36 <ddarius> Bonus: Algebra of Programming is, I believe, the only Haskell book that piques my interest (I haven't read it).
15:09:38 <tusho> dmwit: It's a GADT. :D
15:09:45 <newsham> ?instances-importing Control.Applicative Alternative
15:09:46 <dmwit> ah =)
15:09:46 <lambdabot> Maybe, WrappedMonad m, []
15:09:47 <Bonus> hmm
15:09:47 <grahamhutton> edwardk: on the contrary, it is highly likely that he remembers --- it isn't very often that people come up and talk about comands (yet).
15:09:51 <edwardk> I went and dualized a lot of the stuff he had written with Uustalu about ideal monads
15:10:00 <tusho> functors are like ... a 2 minute thing :P
15:10:03 <tusho> @src Functor
15:10:04 <lambdabot> class  Functor f  where
15:10:04 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:10:13 <Bonus> yeah i think i may know functors but dont know i know them
15:10:14 <tusho> functions are a functor, fmap = (.)
15:10:20 <tusho> lists are functors, fmap = map
15:10:21 * monochrom hacks up a showsPrec example.
15:10:26 <Bonus> ah
15:10:29 <tusho> and monads are functors, fmap = liftM (I believe)
15:10:33 <tusho> :t liftM
15:10:34 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:10:36 <ddarius> Bonus: If you know monads, you know functors.
15:10:43 <dmwit> It is more correct to say monads are functors.
15:10:43 <grahamhutton> btw, ICFP 2009 will be in Edinburgh, Scotland!
15:10:44 <Bonus> aha
15:10:44 <monochrom> . o O (NOOOO! No hacking! Intelligent Design!!!)
15:10:49 <Bonus> yeah i've heard that monads should be functors
15:10:53 <tusho> dmwit: Yeah. But it's not like that in Haskell.
15:10:54 <Bonus> according to category theory
15:10:56 <edwardk> Heh, he over heard me talking with someone else about them and brought up the 'Dual of substitution is redecoration' paper topic. I'll admit I had no idea who he was at the time. ;)
15:11:04 <tusho> monochrom: Eeek -- what happened
15:12:19 <ddarius> @src Alternative
15:12:19 <lambdabot> class Applicative f => Alternative f where
15:12:19 <lambdabot> 	empty :: f a
15:12:19 <lambdabot> 	(<|>) :: f a -> f a -> f a
15:12:22 <monochrom> @type showsPrec
15:12:22 <tusho> apparently, God just smited monochrom
15:12:23 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
15:12:31 <tusho> @src Applicative
15:12:31 <lambdabot> class Functor f => Applicative f where
15:12:31 <lambdabot>     pure  :: a -> f a
15:12:31 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
15:13:00 <ddarius> Bah.  Error messages are for the weak anyway.
15:13:18 <newsham> > pure (+) <*> [1,2] <*> pure 10
15:13:19 <lambdabot>  [11,12]
15:13:31 <tusho> ddarius: Real men read the BINARY CODE of the TYPES.
15:13:37 <vixey`> grahamhutton: is there any more info about it?
15:13:43 <edwardk> grahamhutton: Anyways I would definitely love to get a chance to read the paper. I went through and started using them to play with (and Yoneda's lemma) to try to improve the asymptotic behavior of some histo-/futu-/dyna- morphisms.
15:13:44 <vixey`> (online or anything)
15:13:58 <grahamhutton> vixey: not yet -- details are still being worked out,
15:14:13 <newsham> > [1,2,3] <|> [10,11]
15:14:15 <lambdabot>  [1,2,3,10,11]
15:14:38 <grahamhutton> vixey: a web page for ICFP 2009 will be up within the next few months.
15:16:28 <tusho> so what's the cleverererest way to write a Show like a derived Show?
15:16:30 <tusho> simplest, that is
15:17:27 <Botje> derive typeable instead and see if you can do anything with that
15:17:45 <dons> Cale, another job for you, http://lojic.com/blog/2008/05/31/blog-bifurcation/
15:17:46 <lambdabot> Title: a lojic.com 17 » Blog Archive 19 » Blog Bifurcation 36
15:18:28 <tusho> Botje: it's a gadt it's a gadt it is a gadt.
15:18:39 <Botje> oh
15:18:45 <Botje> if only i knew what that meant :)
15:18:56 <hpaste>  monochrom pasted "example of parenthesizing in Show code" at http://hpaste.org/8014
15:19:52 <tusho> Botje: it's not an ADT, it's a GADT.
15:20:14 <dmwit> Botje: Short story: no deriving.
15:20:21 <Botje> oh
15:20:34 <Botje> petition Simons for a way to derive anyway :)
15:20:46 <tusho> i am pretty sure 100% gadt deriving is impossibe
15:20:49 <tusho> *impossible
15:21:08 <Botje> how many simon-hours of impossible is this? :o)
15:22:02 <tusho> Botje: 0.3
15:22:05 <tusho> maybe 0.4
15:23:18 <tusho> but yeah.
15:29:39 <tusho> UniversalQuantification ... gah what's it called?
15:30:07 <monochrom> what for?  But you can always use the blanket RankNTypes.
15:31:03 <vixey`> anyone know where the code for Formalizing the Halting Problem in a Constructive Type Theory is ?
15:31:14 <vixey`> the URL from the paper went dead
15:33:11 <dons> i note there's been a trend for newbies on the mailing list asking for things with the disclaimer "this has to be trivial. i don't want boilerplate. i don't want theory" etc.
15:33:23 <dons> e.g. " I really don't
15:33:23 <dons> want to wade through a bunch of boilerplate or climb a steep learning
15:33:24 <dons> curve just to be able to plot a few lines or circles"
15:33:36 <dons> expectations are improving?
15:34:04 <tusho> dons: i find it really annoying when people do that
15:34:08 <hpaste>  SamB annotated "difficult Coq Lemma" with "Agda version" at http://hpaste.org/8013#a2
15:34:13 <tusho> if people go off about stuff like that, it's for a REAOSN
15:34:16 <tusho> and a REASON
15:34:37 <NRee1> whats the difference between ^ and **
15:34:46 * dmhouse wonders whether it'll always be the case that in order to be a talented Haskell programmer, you'll have to be a talented theoretician.
15:34:49 <dons> :t (^)
15:34:49 <dmhouse> NRee1: the types.
15:34:51 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
15:34:56 <tusho> Wow, Agda looks just like Haskell!
15:34:58 <tusho> But with more awesome.
15:35:00 <monochrom> ** for floating point numbers like Double.  Uses exp and log.
15:35:01 <dons> dmhouse: we have very few theoreticians.
15:35:02 <SamB> glguy: uh, couild you take a look at http://hpaste.org/8013#a2
15:35:10 <dons> the theoreticians tend not to write much code too
15:35:16 <tusho> dmhouse: i'm not a theoretican                                 ... and I'm a sucky Haskell programmer!
15:35:17 <dons> :t (**)
15:35:19 <lambdabot> forall a. (Floating a) => a -> a -> a
15:35:19 <SamB> I pasted â¤, not ï¿½ï¿½ï¿½
15:35:27 <monochrom> ^ for positive integer exponenets.  uses repeated squaring.
15:35:27 <Bonus> will GADTs be in Haskell'
15:35:32 <dmhouse> dons: okay, well your average (non-Haskell) programmer has likely never read a paper.
15:35:33 <tusho> SamB: hpaste=phail@unicode
15:35:41 <vixey`> Bonus: GADTs are in GHC
15:35:44 <NRee1> ah that makes sense
15:35:48 <monochrom> And don't forget ^^, for +ve and -ve integers, uses ^ and division.
15:35:50 <tusho> vixey`: I assume he knows
15:35:51 <vixey`> (who cares about Haskell'?)
15:35:53 <Bonus> yes but they ain't Haskell 98 right
15:35:53 <dmwit> preflex: seen glguy
15:35:53 <preflex>  glguy was last seen on #haskell 22 hours, 47 minutes and 47 seconds ago, saying: MyCatVerbs: they let the people in wheelchairs go first because they tend to do it faster
15:35:56 <SamB> tusho: yes, my point!
15:36:00 <monochrom> err s/division/reciprocal
15:36:08 <tusho> SamB: it's being rewritten now
15:36:11 <idnar> SamB: sounds like utf-8 incorrectly decoded as iso-8859-*
15:36:13 <tusho> so I doubt anything will be done right now.
15:36:39 <SamB> @tell glguy "â¤" /= "ï¿½ï¿½ï¿½" in http://hpaste.org/8013#a2
15:36:39 <lambdabot> Consider it noted.
15:36:47 <tusho> he knows.
15:36:54 <tusho> preflex: be poppavic
15:36:55 <preflex>  ahh, so - you just toss out yer turds and based on input and get feedback, then play "confused"? Good to know.
15:37:03 <tusho> I wish that thing had more pv quotes
15:37:06 <Bonus> man, haskell owns cause you can decide "i'll learn something new about haskell today" and you can
15:37:16 <monochrom> SamB: If you put things inside comments, they aren't misinterpreted or garbled.
15:37:18 <tusho> Bonus: :-)
15:37:26 <SamB> Bonus: wait, is it possible NOT to do that?
15:37:41 <SamB> monochrom: oh, was it that idiot syntax highlighting thing?
15:37:53 <tusho> yeah
15:37:57 <tusho> SamB: try viewing it as raw
15:37:58 <tusho> it works
15:37:58 <monochrom> Yes, that's where the blame should go.
15:38:02 <tusho> (and also lets you embed arbitary html!)
15:38:06 <tusho> which I abused once
15:38:12 <tusho> for manual syntax highlighting
15:38:22 <Bonus> well i dont know, i feel like i pretty much know everything about python
15:38:25 <tusho> but, technically, you can XSS hpaste.org
15:38:29 <Bonus> except for the various libraries etc
15:38:31 <tusho> not taht useful: you can see the /raw and it only stores a name cookie
15:38:41 <tusho> Boney: he meant, about haskell
15:38:45 <monochrom> I absued hpaste.org to give xhtml :)
15:38:51 <Bonus> yeah i know, i was making a comparison
15:38:51 <Bonus> er
15:40:21 <tusho> anyone know about Cayenne? I'm wondering if # is a valid type at the value-level
15:40:27 <tusho> i.e. can you write a runtime function returning #
15:41:01 <monochrom> http://hpaste.org/5307  is a test case  (no abuse yet)
15:41:27 <monochrom> (but it has a case containing <pre> and </pre>.  try its raw version.)
15:42:09 <roconnor> damn
15:43:24 <tusho> Stop flooding, lemmih espeng eu-prleu-peupeu ... oh wait
15:43:27 <tusho> :P
15:44:24 <SamB> if he had offered multiple modes, like one with no highlighting, this problem would not happen
15:44:46 <SamB> Bonus: well, I suppose it would be possible to learn a bout a different language instead...
15:44:50 <tusho> heh on that gadt page:
15:44:51 <tusho> "Could you implement a safeTail function?"
15:44:56 <tusho> not with that definition of SafeList!
15:45:02 <SamB> Bonus: GADTs will not be in Haskell'
15:45:05 <tusho> you need `data NonEmpty xs`
15:45:06 <SamB> how do I know, you ask?
15:45:10 <tusho> and stack up the NonEmpty/Emptys
15:45:12 <SamB> because no other Haskell compiler is going to implement them in time, that's why
15:45:21 <tusho> and you get:
15:45:21 <tusho> tail' :: List (NonEmpty isXsEmpty) a -> List isXsEmpty a
15:46:07 <monochrom> I guess the <pre> version is abuse enough (of raw).
15:47:09 <tusho> @src Applicative
15:47:09 <lambdabot> class Functor f => Applicative f where
15:47:09 <lambdabot>     pure  :: a -> f a
15:47:09 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
15:47:23 <tusho> hmph what was that typeclass I was thinkin' of
15:47:40 <monochrom> What does it do? Perhaps I know.
15:48:35 <tusho> monochrom: I can just remember rough kinds of type sigs.
15:48:48 <tusho> foo a -> foo a -> foo a in particular but it wasn't alternative - didn't depend on applicative and functor
15:49:01 <tusho> @hoogle foo a -> foo a -> foo a
15:49:02 <lambdabot> Did you mean: Foo a -> Foo a -> Foo a
15:49:02 <lambdabot> Prelude.asTypeOf :: a -> a -> a
15:49:02 <lambdabot> Prelude.const :: a -> b -> a
15:49:21 <vixey`> :t mappend
15:49:22 <lambdabot> forall a. (Monoid a) => a -> a -> a
15:49:23 <monochrom> MonadPlus?  Monoid?
15:49:46 <tusho> monochrom: MonadPlus depends on Monad.
15:49:47 <tusho> @src Monoid
15:49:48 <lambdabot> class Monoid a where
15:49:48 <lambdabot>     mempty  :: a
15:49:48 <lambdabot>     mappend :: a -> a -> a
15:49:48 <lambdabot>     mconcat :: [a] -> a
15:49:53 <tusho> Hm, maybe.
15:50:11 <tusho> @hoogle Monoid
15:50:11 <lambdabot> Data.Monoid :: module
15:50:11 <lambdabot> Data.Monoid.Monoid :: class Monoid a
15:50:24 <monochrom> ArrowPlus?
15:50:28 <tusho> @src Arrow
15:50:29 <lambdabot> class Arrow a where
15:50:29 <lambdabot>     arr, pure   :: (b -> c) -> a b c
15:50:29 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
15:50:29 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
15:50:29 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
15:50:31 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
15:50:33 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
15:50:35 <tusho> whooo
15:50:45 <tusho> hm
15:50:47 <tusho> @instances Arrow
15:50:47 <lambdabot> (->), Kleisli m
15:50:57 <tusho> what else are arrows?
15:51:19 <SamB> @instances Monad
15:51:20 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:51:36 <shepheb> there's an arrow-based parser generator, if I recall?
15:51:41 <SamB> @istances Arrow Text.Html
15:51:42 <lambdabot> Couldn't find class `Arrow Text.Html'. Try @instances-importing
15:51:49 <SamB> @istances-importing Arrow Text.Html
15:51:49 <lambdabot> Couldn't find class `Text.Html'. Try @instances-importing
15:51:55 <tusho> istances?
15:51:58 <SamB> @istances-importing Text.Html Arrow
15:51:58 <lambdabot> Couldn't find class `Arrow'. Try @instances-importing
15:52:01 <tusho> istances?
15:52:07 <SamB> tusho: okay so I misspelled it
15:52:09 <SamB> who CARES
15:52:10 <monochrom> HXT is an XML processing library using Arrow.
15:52:16 <tusho> SamB: temper.
15:52:17 <tusho> :p
15:52:34 <SamB> clearly, it isn't lambdabot that cares ;-)
15:52:36 <monochrom> @hothack
15:52:36 <lambdabot> Unknown command, try @list
15:52:45 <monochrom> oops
15:52:46 <SamB> @hotshack
15:52:46 <lambdabot> :)
15:52:51 <monochrom> Yes! :)
15:53:20 <SamB> @hots
15:53:20 <lambdabot> Maybe you meant: docs vote
15:53:23 <SamB> @bots
15:53:23 <lambdabot> :)
15:53:27 <tusho> @socks
15:53:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:53:31 <SamB> hmm, doesn't work on truncated versions
15:53:33 <tusho> @socksnack
15:53:33 <lambdabot> Unknown command, try @list
15:53:37 <tusho> @lambda
15:53:37 <lambdabot> Done.
15:53:41 <tusho> haha
15:53:45 <tusho> LAMBDA: Done.
15:53:49 <tusho> new haskell motto
15:53:56 <monochrom> haha
15:54:20 <SamB> @quote lambdabot <tusho> @lambda <lambdabot> Done.
15:54:20 <lambdabot> No quotes match. You untyped fool!
15:54:43 <tusho> @remember lambdabot <tusho> @lambda <lambdabot> Done.
15:54:44 <lambdabot> It is stored.
15:54:53 <tusho> It is done.
15:54:57 <tusho> LAMBDA: It is done.
15:55:51 <tusho> oh dear, (head [])-safe GADT lists don't allow infinite list
15:55:52 <tusho> s
15:55:52 <tusho> :(
15:56:02 <tusho> infinite type and all that jazz
15:56:04 <monochrom> interesting.
15:56:15 <tusho> monochrom: yeah
15:56:17 <tusho>     Cons :: a -> List isEmpty a -> List (NonEmpty isEmpty) a
15:56:30 <monochrom> Oh! No wonder.
15:56:30 <tusho> so an infinitely non-empty list has an infinite first argument
15:56:43 <tusho> monochrom: yeah, you can't just use NonEmpty without an argument if you want 'tail' though
15:56:49 <tusho> and uh, tail is pretty essential ;)
15:57:45 <tusho> hmmm
15:57:54 <tusho> a language with dependent types can't have a full type inferer can it?
15:58:01 <tusho> Like, you can typify printf
15:58:03 <tusho> but it'll never inferr it
15:58:09 <tusho> it'd have to be able to write arbitary code in itself
15:59:45 <tusho> right?
16:01:49 <monochrom> Yes.
16:02:18 <monochrom> Dependent type is as powerful as proving programs correct.
16:03:03 <tusho> monochrom: thought as much
16:03:08 <tusho> Isn't that a bit inelegant, then?
16:03:12 <tusho> You can type infer, but only _sometimes_
16:05:21 <monochrom> Is mathematics a bit inelegant? You can mechanicalize, but only sometimes.
16:06:09 <Bonus> mathematics is the definition of elegance
16:06:09 <Bonus> hehe
16:06:24 <SamB> tusho: well, it's not that bad really
16:06:34 <SamB> you just have to write types for most toplevel definitions
16:06:42 <SamB> the ones with trivial types are inferrable
16:06:52 <vixey`> if lambda terms parameters are all annotated you can always infer
16:07:19 <SamB> well, in Agda I don't think you can do that
16:07:26 <SamB> in general
16:07:30 <vixey`> \(x : <like this>) -> ...
16:07:30 <tusho> SamB: surely everything in haskell, for example, would type check?
16:07:32 <tusho> Without definitions
16:07:38 <SamB> tusho: not true
16:07:43 <tusho> :\
16:07:48 <SamB> higher-order polymorphism requires types
16:07:53 <SamB> in Haskell
16:07:54 <SamB> right now
16:09:03 <tusho> well. yeah.
16:09:06 <tusho> I mean h98
16:09:31 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/8012#a1
16:09:59 <NRee1> how come ghci is complaining about problem11down?
16:11:05 <NRee1> "No instance for (Num (b -> c -> d -> e)) arising from use of `product' at euler.hs:18:43-49 (problem11down)" is the error
16:12:17 <vixey`> you can't use HM ina dependently typed setting, what you would infer as forall a b, a -> (a -> b) -> b might actually be (forall a, a -> (forall b, a -> b) -> b).
16:12:18 <monochrom> probably missing parameters or too many parameters somewhere.
16:12:54 <vixey`> You can use constraint solving to infer things of course (and this is what Agda 2 does)
16:13:05 <monochrom> "zipWith4 product" does not do what you think it does, or type what you think it types.
16:14:19 <monochrom> In particular, "product" cannot be used like "product 1 2 3 4".
16:15:01 <ddarius> tusho: Haskell 98 requires types in certain situations.
16:15:27 <tusho> ddarius: huh, ok. example?
16:15:43 <monochrom> show (read "haha")
16:16:10 <tusho> ah
16:16:36 <Saizan> vixey`: you don't need dependent types for that example, no?
16:17:10 <ddarius> http://www.haskell.org/pipermail/haskell-cafe/2008-May/043181.html
16:17:11 <lambdabot> Title: [Haskell-cafe] Type inference; always, http://tinyurl.com/5vhpuo
16:17:25 <vixey`> Saizan: well inferrence for F_omega is undecideable too
16:17:47 <Saizan> yeah
16:18:37 <tusho> @qc (\x -> read (show x) == x)
16:18:37 <Liempt> OMEGA!|/msg #haskell ERROR!|/msg #haskell OMEGA!|/msg #haskell OMEGA!
16:18:38 <lambdabot> Not enough privileges
16:18:38 <Liempt> OMEGA!|/msg #haskell ERROR!|/msg #haskell OMEGA!|/msg #haskell OMEGA!
16:18:46 <tusho> shut up Liempt.
16:18:46 <Liempt> OMEGA!|/msg #haskell ERROR!|/msg #haskell OMEGA!|/msg #haskell OMEGA!
16:18:54 <tusho> wtf is Liempt doing
16:18:54 <Liempt> OMEGA!|/msg #haskell ERROR!|/msg #haskell OMEGA!|/msg #haskell OMEGA!
16:18:56 <Liempt> Oh sorry.
16:18:57 <Liempt> Sorry.
16:19:08 <Liempt> Sorry.
16:19:10 <tusho> OMEGA!
16:19:14 <Liempt> Screwed up script.
16:19:16 <Liempt> Don't ask.
16:19:19 <monochrom> haha
16:19:26 <tusho> Liempt: well it >looks< like it was about to spam us ...
16:19:28 <vixey`> Liempt: careful with those combinators
16:19:33 <tusho> except, it failed, and ended up spamming u.
16:19:38 <tusho> *us#
16:19:42 <tusho> *us
16:19:52 <monochrom> Use haskell for your irc scripts.
16:19:53 <Liempt> No, it's not for you guys.
16:20:08 <mrd> omega_0?
16:20:16 <Liempt> Sorry for the huge distraction.
16:20:19 <Saizan> yeah, take example from how reliable lambdabot is
16:20:20 * Liempt goes back to lurking.
16:20:25 <tusho> Saizan: ha
16:20:34 <monochrom> hahahaha
16:21:32 <ddarius> :t (<*)
16:21:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:22:23 <vixey`> :t const :: forall (f :: * -> *) a b. (Applicative f) => f a ->
16:22:25 <lambdabot> parse error (possibly incorrect indentation)
16:22:27 <vixey`>                   f b -> f a
16:22:32 <tusho> i gotta write my YetAnotherLambdabotClone sometime just to figure out how to do plugins nicely
16:22:35 <vixey`> <* = const ?
16:22:48 <tusho> @src (<*)
16:22:49 <lambdabot> (<*) = liftA2 const
16:23:20 <tusho> brb
16:24:45 <dbueno> @seen dcoutts
16:24:46 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:24:52 <dbueno> dcoutts_: there?
16:26:15 <convivial> hey you crazy dude!
16:26:30 <convivial> just learned about your revolutionary language!!!
16:26:50 <convivial> learning it for first time!!! :) very excitted!
16:27:11 <nornagon> Che Gueverifiable.
16:27:19 <convivial> :)
16:28:58 <tusho> convivial: crazy dude - we are as one
16:29:03 <tusho> #haskell is, crazy dde.
16:29:06 <tusho> and crazy dude
16:29:26 <convivial> :D
16:29:27 <convivial> hehehe
16:29:33 <shapr> ?
16:29:50 <convivial> where should I start?
16:29:55 <convivial> just installed it
16:30:13 <monochrom> main = print "crazy dude"
16:30:21 <convivial> :)
16:30:29 <monochrom> Create a file called whatever.hs and enter that line.
16:30:49 <monochrom> Then you can use whatever interpreter/compiler you've installed to run it.
16:31:32 <monochrom> Perhaps it's ghc.  You can try both:  (A) ghci whatever.hs, then :main  (B) ghc --make whatever.hs, the executable is called whatever.
16:32:01 <monochrom> perhaps s/print/putStrLn/
16:32:02 <convivial> nothnig printered
16:32:04 <convivial> printed
16:32:11 <Zao> monochrom: 'ghc --make whatever' ought to do, wouldn't it?
16:32:17 <monochrom> LIES
16:32:56 <convivial> hey Zao ! that worked dude!
16:32:59 <convivial> hehe :)
16:34:41 <Bonus> start with some tutorials
16:34:42 <Bonus> hehe
16:35:11 <tusho> convivial: try real world haskell
16:35:12 <tusho> I hear it's nice.
16:35:15 <Bonus> yeah
16:35:16 <Bonus> it owns
16:35:24 <Bonus> especially the introduction and the beginning steps
16:35:25 <convivial> really? url
16:35:29 <Bonus> comparaed to other tutorials
16:35:33 <tusho> convivial: realworldhaskell.com I think
16:35:39 <Bonus> .org
16:35:39 <tusho> Personally, I did YAHT up to the monad part, then gave up on it, then came back ages after and just kinda coded a lot.
16:35:44 <tusho> It worked in a kind of cracked way.
16:35:57 <Bonus> i gave up on leraning haskell 2 times
16:35:58 <tusho> And, well, here I am
16:36:00 <Bonus> and then it just clicked
16:36:02 <Bonus> and now i love it
16:36:04 <tusho> Bonus: wow, me 3
16:36:16 <nornagon> me 4
16:36:23 <tusho> but yeah, I always gave up on YAHT. And then one day I realised that I could just write basic haskell programs.
16:36:30 <convivial> coolies dudes! you seriously rock! i'll be back with some questions i'm quite sure!
16:36:31 <tusho> So I read up on some more stuff idly until some stuff clicked.
16:36:37 <tusho> It's just been going like that ever since. :P
16:36:38 <Bonus> have fun!
16:37:05 * ddarius decided he was going to learn Haskell and then learned it.
16:37:25 <vixey`> I just wrote code I skipped all this "learning"
16:37:46 <Bonus> i never learned haskell i just hang in the channel and pretend i know it
16:37:50 <Bonus> no one's noticed so far
16:38:07 <ddarius> I never learned Python, I've just written code in it upon occasion.
16:39:23 <Bonus> hehe
16:39:25 <Bonus> python is kewl
16:39:58 <Peaker> Actually using Haskell really made all these abstract things concrete :)
16:41:26 <tusho> i just kinda hang about on irc and then splurge some haskell code
16:41:28 <tusho> sometimes it compiles
16:41:31 <tusho> that makes me happy
16:51:27 <codetoad> I have a module A and a directory (submodule?) "Utils" with a file, MyType.hs that defines a module. I do "import Utils.MyType" from my main module A.  I want people who do "import A" to be able to access this type, though.  How do I do this?
16:51:45 <tusho> codetoad: in import A do import Utils.MyType and re-export it
16:51:53 <tusho> (in your export list, do 'module Utils')
16:51:53 <tusho> err
16:51:56 <tusho> yeah
16:51:57 <tusho> that's right
16:51:58 <tusho> kinda
16:53:45 <codetoad> is there a way i can sort of wildcard export everything in the main module?
16:53:55 <codetoad> (Utils.MyType, ...)
16:54:07 <Heffalump> not if you also want to reexport an entire imported module
16:55:34 <codetoad> okay, that's not so bad.  if i can re-export an imported module then i can organize things into chunks
16:56:32 <codetoad> thanks!
17:14:37 <hpaste>  SamB annotated "difficult Coq Lemma" with "Where I get stuck with the Set version..." at http://hpaste.org/8013#a4
17:14:40 <travisbrady_> :t fromListWith
17:14:42 <lambdabot> Not in scope: `fromListWith'
17:14:51 <travisbrady_> :t Data.Map.fromListWith
17:14:52 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
17:41:03 <Peaker> raytrace: Error in array index -- any way to get a traceback/line num/etc?
17:41:36 <dmwit> Use assert?
17:43:39 <dbueno> Peaker: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#ghci-debugger-exceptions
17:43:40 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2orwlb
17:44:19 <Eiler> dons: that dynamic loaded plugins at summer of code, is that something similiar to hs-plugins?
17:44:20 <dbueno> Peaker: The section from the manual is entitled "Debugging exceptions" but really all the info about the GHCi debugger is useful.
17:44:31 <NRee1> hey is there a way to limit the memory ghci can use?
17:44:40 <Peaker> dbueno, thanks
17:44:41 <NRee1> I find it painful for it to page out firefox etc
17:47:48 <TomMD> Sure is - just use GHC in a Xen VM and limit that VM to X megs.
17:47:59 <EvilTerran> ha
17:48:18 <bd_> TomMD: or use +RTS heap size limits
17:48:25 <TomMD> I like my way.
17:48:27 <NRee1> hehe ya good way to keep memory usage down ^^
17:48:34 <bd_> +RTS -Mmaxsize
17:49:55 <NRee1> thanks bd_ thats what I was looking for
17:50:06 <NRee1> but I think TomMD's was more clever ;)
17:50:26 <TomMD> :)
18:13:38 <hpaste>  morrow pasted "sqlite3-amalgamation.sh" at http://hpaste.org/8015
18:16:45 <hpaste>  morrow annotated "sqlite3-amalgamation.sh" with "better" at http://hpaste.org/8015#a1
18:28:59 <TomMD> Arrr, I miss my community.h.o account!
18:29:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/8016
18:29:19 <NRee1> why does that stack overflow?
18:30:49 <ddarius> :t Text.ParserCombinators.Parsec.chainl
18:30:52 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st (a -> a -> a) -> a -> Text.ParserCombinators.Parsec.Prim.GenParser tok
18:30:52 <lambdabot> st a
18:30:53 <ddarius> :t Text.ParserCombinators.Parsec.chainr
18:30:55 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st (a -> a -> a) -> a -> Text.ParserCombinators.Parsec.Prim.GenParser tok
18:30:55 <lambdabot> st a
18:32:43 <mar77a> is there anyway to pattern match an array
18:32:53 <mar77a> like you do f (x:xs) for lists, but for an array?
18:33:17 <mauke> no
18:33:41 <ddarius> NRee1: Try compiling with -O2
18:33:53 <ddarius> :t Text.ParserCombinators.Parsec.chainr1
18:33:55 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st (a -> a -> a) -> Text.ParserCombinators.Parsec.Prim.GenParser tok st
18:33:55 <lambdabot> a
18:37:01 <ddarius> :t \a b -> ord <$> a <*> b
18:37:03 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Int'
18:37:03 <lambdabot>     Probable cause: `ord' is applied to too many arguments
18:37:03 <lambdabot>     In the first argument of `(<$>)', namely `ord'
18:37:13 <ddarius> :t \a b -> (+) <$> a <*> b
18:37:15 <lambdabot> forall a (f :: * -> *). (Applicative f, Num a) => f a -> f a -> f a
18:48:12 <NRee1> ddarius: compiling worked like a charm
18:48:23 <NRee1> so does compiling increase the stack space?
18:48:46 <EvilTerran> it means a lot of optimisations get done that wouldn't be otherwise
18:49:13 <SamB> it makes better use of stack space
18:49:33 <SamB> I'm not sure if it can make better asymptotic use of stack space or not...
18:50:17 <ddarius> NRee1: I suspect the problem is that the definition of maximum in GHC relies on strictness analysis.
18:51:31 <NRee1> ya from my little analysis, i noticed maximum was the "stack overflower" in the sense that if it was removed and I just straight printed the list, it wouldnt crash
18:55:52 <scriptdevil> [Not homework but prereading for it] I am assigned a project to develop an almost Version 0 compiler from one language to another. As pre-reading, I have now come to understand the haskell syntax fluently. But is there any book specifically aimed at writing a parser so that I make efficient use of the libraries
18:55:57 <scriptdevil> ?
18:57:14 <lament> there's... the parsec homepage :)
18:57:32 <dolio> Parsec is probably the most used library for parsing.
18:58:00 <jeffz> I also recommend the parsec homepage...
18:58:02 <dolio> There are papers/manuals about it, although they're probably somewhat out of date (not fundamentally, but in the specifics of what the libraries contain).
18:58:35 <scriptdevil> :) Thanks.
19:00:12 <ddarius> There are also a variety of parser generators, most notably happy.
19:00:43 <scriptdevil> Also, This is my first big sized project. How do I ensure that my code remains extensibe and well spread out into modules? Are there any guides on this? Or does it come down to experience?
19:01:53 <bd_> scriptdevil: If you start getting lost in a file, it's time to split it up :)
19:02:59 <scriptdevil> bd_: Can I actually check out a copy of some previous compiler and keep its structure as the skeleton?
19:03:20 <shapr> @users
19:03:20 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
19:03:22 <shapr> aww
19:03:51 <bd_> scriptdevil: What language are you trying to compile? It's probably best not to, just so you can have freedom in designing it, imo
19:03:56 <shapr> Aw, I forgot happy birthday #haskell
19:04:00 <shapr> some 4 weeks ago.
19:04:11 <scriptdevil> bd_: They are two HDLs
19:04:33 <ddarius> (<$) makes sense to me now
19:04:54 <vininim> "the next haskell will be strict, but still pure" <- wut
19:05:10 <ddarius> scriptdevil: The rules are more or less the same as other languages and programming in general.
19:05:33 <eu-prleu-peupeu1> can i alter the abstract syntax tree in run-time in haskell ?
19:05:38 <eu-prleu-peupeu1> like ruby :P
19:05:57 <bd_> eu-prleu-peupeu1: nope, sorry. You could use the GHC-API to compile stuff at runtime though
19:06:05 <monochrom> run-time? please don't.
19:06:22 <SamB> eu-prleu-peupeu1: what?
19:06:47 <scriptdevil> Thanks all.. Gotta rush to college :D
19:06:49 <SamB> AST's aren't supposed to exist at runtime except in exceedingly slow implementations of lisp, or implementations of lambda calculi...
19:07:23 <vininim> http://portal.acm.org/supp_gateway.cfm?id=1238856&type=pdf&path=%2F1240000%2F1238856%2Fsupp%2FHaskell%2Epdf&coll=GUIDE&dl=GUIDE&CFID=30248690&CFTOKEN=97968208
19:07:33 <vininim> what is this "next haskell" that simon talks about?
19:07:35 <ddarius> SamB: Why should they exist in implementations of lambda calculi?
19:07:38 <bd_> SamB: Well, you could JIT-compile the AST, and if something starts editing it, undo the compilation
19:08:06 <SamB> ddarius: well, you know, the kind that you would use in a proof system
19:08:22 <SamB> of course the lambda calculus isn't able to access ths
19:08:26 <SamB> s/ths/this/.
19:11:22 <monochrom> Self-modifying programs are a fun sports, but not a viable engineering technique.
19:13:19 <SamB> monochrom: not at that scale, at any rate
19:41:54 <NRee1> is there a design reason why log is base-e rather than ln?
19:43:20 <SamB> NRee1: it's more natural
19:43:23 <SamB> duh ;-)
19:43:58 <NRee1> hehe
19:44:03 <SamB> were you expecting log to be base-2?
19:44:10 <hpaste>  morrow annotated "sqlite3-amalgamation.sh" with "thanks for the advice!" at http://hpaste.org/8015#a3
19:44:10 <NRee1> base-10
19:44:16 <mauke> no, log should take two arguments
19:44:20 <mauke> base 10 is lg
19:44:38 <SamB> mauke: that would be REALLY confusing
19:44:49 <SamB> lg is base-2 in Knuth's books
19:44:51 <mauke> that's how preflex does it!
19:44:55 <mauke> no, base 2 is ld
19:45:06 <SamB> in knuth's books?
19:45:09 * dolio has never seen ld.
19:45:16 <mauke> knuth obviously never went to my school
19:45:21 * NRee1 has never seen lg or ld
19:45:30 <mauke> preflex: calc ld 10
19:45:31 <preflex>  3.321928094887363
19:45:34 <mauke> now you have
19:45:48 <dolio> I've seen lg for base 2, and log for base 10, and ln for base 3.
19:46:11 <dolio> And, of course, log with subscript b for some other base.
19:46:20 <NRee1> http://en.wikipedia.org/wiki/Logarithm#Bases
19:46:24 <monochrom> base 3? :)
19:46:35 <NRee1> so the common approach is to have log to default to base 10 ;)
19:46:45 <monochrom> Who would use base 3, other than someone crazy like Cantor?
19:48:03 <SamB> NRee1: only in decimal contexts
19:48:10 <SamB> programming is not one of these
19:48:15 <dolio> I've seen log as base 2 in stuff about algorithm analysis, too, but I suppose it usually doesn't matter there.
19:48:16 <mauke> http://de.wikipedia.org/wiki/Logarithmus#Bezeichnungen <-
19:48:32 <SamB> I'm fairly certain the top two contenders would be e and 2
19:49:50 <dolio> Although I think the papers I've read where 'log' means base 2 usually explicitly say so.
19:50:08 <NRee1> hm wow.. i never realized that.. but in C log is base-e too
19:50:23 <monochrom> trig uses radians.
19:50:44 <SamB> monochrom: well, it's the natural way
19:51:16 * SamB is reminded of the "natural selection" sort algorithm
19:52:01 <[Justice]> if you're doing asymptotic analysis, it shouldn't matter what the base is
19:52:43 <monochrom> until you happen to do n^(log_b m)
19:52:59 <[Justice]> well, true
19:53:18 <monochrom> trick question on exam: e^ln n  polynomial time or not? :)
19:53:31 <[Justice]> yes
19:55:19 <[Justice]> (n) is a polynomial in n
19:55:57 <ddarius> Writing naive code is relaxing.
19:56:32 <[Justice]> eg, fib n = fib (n - 1) + fib (n - 2)
19:56:33 <bd_> [Justice]: Isn't copying an integer O(lg n)?
19:57:05 <monochrom> "integer"
19:57:24 <monochrom> This hour has 24 minutes. This integer has 24 bits.
19:57:37 <[Justice]> copying an Int is O(1), copying an Integer is (log_100000 n)
19:58:19 <dolio> 100000?
19:58:42 <[Justice]> any base you like is fine, within big-O notation
19:59:00 <dolio> Yeah.
20:02:52 <bd_> I thought O(lg n) is sub-polynomial time?
20:03:58 <[Justice]> it's sub-linear time
20:04:26 <[Justice]> (k) is a polynomial in n, one of an infinite number of constant, degree-0 polynomials
20:05:25 <bd_> It's not constant, though, since we need to copy (?) a value of unknown size
20:05:41 <bd_> so does sub-linear (but above constant time) put it outside P?
20:05:57 <[Justice]> Int is known size, Integer is unknown size
20:06:14 <bd_> e^ln n <-- types were unspecified :)
20:06:23 <bd_> also, Int is still O(lg n), with n being a constant ;)
20:07:50 <[Justice]> class P includes all functions f such that there exists a polynomial function g such that f(j) < g(j) for all j larger than a sufficiently large k
20:08:26 <[Justice]> if f in O(log n) then f in P
20:09:03 <[Justice]> if f in O(1) then f in P
20:09:04 <dolio> It doesn't depend on the value n, though. Copying 0 takes as much time as copying 2147483647.
20:09:32 <[Justice]> n is the number of bits
20:09:41 <[Justice]> or bytes, or words, or whatever
20:09:51 <[Justice]> wait that's wrong
20:10:04 <dolio> Well, that would make copying an integer O(n).
20:10:06 <[Justice]> no, copying 0 takes less time then copying 10^100
20:10:10 <dolio> Or, unbounded integer.
20:10:33 <[Justice]> the size of 0 is perhaps 1 word, whereas the size of 10^100 is multiple words
20:11:08 <dolio> Yeah, but he was talking about Int being O(lg n).
20:11:30 <TomMD> I there a preferred structure for bindings to C libraries?  I started with a two module approach: one CBindings.hs that didn't really introduce any types beyond Foreign.C, and a Haskellized API that introduced types and used all the foreign functions.  I'm considering that splitting these up was a mistake and I should introduce the haskell types earlier (i.e. declare the types and make Storable instances for them that will marshall them a
20:11:39 <dolio> Int can't represent googol.
20:11:40 <bd_> dolio: where n is constant :P
20:12:17 <dolio> At least, not on my machine. :)
20:12:27 <[Justice]> Integer can represent 10^100, Int cannot ... copying Integer is O(log n) and not O(1), while copying Int is O(log n) and also O(1)
20:12:37 <TomMD> Need a PS3, that will work out for you.
20:19:19 * Twey wonders vaguely why there are no n - k patterns...
20:21:33 <Chater4567> http://www.meine-wilde-ex.net/?uid=156037
20:21:34 <lambdabot> Title: Meine wilde Ex!!!
20:21:53 <lament> Chater4567: or else?
20:24:55 <Mr_Awesome> is there perhaps a way to do this with a single list comprehension? map (\x -> [(x, y) | y <- [0..h-1]]) [0..w-1]
20:25:40 <Mr_Awesome> > map (\x -> [(x, y) | y <- [0..2]]) [0..2]
20:25:41 <lambdabot>  [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)],[(2,0),(2,1),(2,2)]]
20:26:07 <ddarius> > range (0,2) (0,2)
20:26:08 <lambdabot>  Couldn't match expected type `(t1, t2) -> t'
20:26:19 <ddarius> > range ((0,2), (0,2))
20:26:21 <lambdabot>  [(0,2)]
20:26:29 <ddarius> > range ((0,0), (2,2))
20:26:30 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
20:27:09 <ddarius> Mr_Awesome: A list comprehension always produces a list.  You could nest list comprehensions but that wouldn't be doing anything different.
20:27:24 <ddarius> map (\x -> ...) l = [... | x <- l]
20:28:05 <ddarius> > map (\x -> map ((,) x) [0..2]) [0..2]
20:28:07 <lambdabot>  [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)],[(2,0),(2,1),(2,2)]]
20:28:15 <Mr_Awesome> ddarius: ah, i see what you mean
20:28:41 <ddarius> > map (flip map [0..2] . (,)) [0..2]
20:28:43 <lambdabot>  [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)],[(2,0),(2,1),(2,2)]]
20:29:09 <dmwit> > [(x, y) | x <- [0..2], y <- [0..2]]
20:29:11 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
20:29:24 <dmwit> > replicateM2 [0..2]
20:29:24 <lambdabot>   Not in scope: `replicateM2'
20:29:28 <dmwit> > replicateM 2 [0..2]
20:29:30 <lambdabot>  [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]
20:29:40 <ddarius> Now transpose.
20:29:54 <dmwit> what?
20:30:12 <ddarius> > transpose $ replicateM 2 [0..2]
20:30:13 <lambdabot>  [[0,0,0,1,1,1,2,2,2],[0,1,2,0,1,2,0,1,2]]
20:30:51 * gwern happily sends off some cabalization patches for pencilpond
20:30:57 <Mr_Awesome> > [[(x, y) | y <- [0..2]] | x <- [0..2]]
20:30:58 <lambdabot>  [[(0,0),(0,1),(0,2)],[(1,0),(1,1),(1,2)],[(2,0),(2,1),(2,2)]]
20:31:22 <gwern> it is a fun little GUI thing, for looking at a hyperbolic plane. imo, a lot of code for what it does (but whatever)
20:31:31 <dmwit> > [(x,y) | [x,y] <- replicateM 2 [0..2]]
20:31:35 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
20:43:41 <gubagem> why does my console app have line history
20:44:29 <Lemmih> gubagem: Are you using readline?
20:44:51 <Lemmih> gubagem: Or rlwrap?
20:45:10 <gubagem> not to my knowledge
20:45:27 <gubagem> and its in a windows xp command prompt
20:45:42 <gubagem> im just using getLine with GHC
20:47:19 <dmwit> I find "lying" or "confusion" the most likely explanation.
20:47:53 <Lemmih> We shouldn't rule out divine intervention, either.
20:48:11 <gubagem> im inside a batch file loop
20:48:44 <gubagem> i mean its nice, but I dont know how it got there
20:52:39 <dmwit> [r | x <- m, ...] --> m >>= \x -> [r | ...]; [r | p, ...] --> guard p >> [r | ...]; [r] --> return r
20:52:42 <dmwit> Is this correct?
20:53:43 <Zao> NRee1: I beat #14 now.
20:54:23 <Zao> NRee1: I used a Map to memoize the subsequences, but ended up eating 600-some MiB memory :)
20:54:28 <NRee1> hehe
20:54:30 <dmwit> Zao: Project Euler?
20:54:36 <NRee1> can you post your code?
20:54:39 <Saizan> dmwit: yup, if x is irrefutable
20:54:42 <NRee1> I would like to compare
20:54:56 <dmwit> Saizan: thanks
20:54:58 <NRee1> and hopefully learn something ^^
20:55:04 <dmwit> Saizan: Or wait, what?
20:55:15 <dmwit> Oh, if x is refutable, then, let's see...
20:55:45 <dmwit> [r | pat <- m, ...] --> m >>= \x -> case x of pat -> [r | ...]; _ -> fail ""
20:55:47 <dmwit> Like that?
20:55:52 <Saizan> yeah
20:55:58 <Zao> NRee1: http://www.acc.umu.se/~zao/014.hs.html
20:56:00 <lambdabot> Title: ~/euler/014.hs.html
20:56:11 <Zao> NRee1: Did you finish yet?
20:56:32 <NRee1> ya i did
20:56:34 <dmwit> Zao: Pretty colors!
20:56:40 <dmwit> Looks like vim's coloring.
20:56:54 <Zao> :TOhtml is a lovely command.
20:57:08 <NRee1> dmwit: our definition of pretty is different, but i guess it is in the eye of the beholder ;)
20:57:16 <dmwit> Zao: Beautiful.
20:57:21 <dmwit> Zao++
20:57:41 <mar77a> interesting
20:57:50 <mar77a> i got my first karma points thanks to project euler too
20:58:15 <mar77a> one liner is_prime function :p
20:58:20 <Zao> Oops, forgot to use -O.
20:58:36 <hpaste>  NReed pasted "Project Euler" at http://hpaste.org/8017
20:59:19 <dmwit> NRee1: looks slow ;-)
20:59:31 <NRee1> hm
20:59:43 <dons> ah, collatz.
21:00:00 <NRee1> ya i cant actually run it under ghci
21:00:12 <dons> for euler stuff, i think it makes sense to compile the code.
21:00:15 <dons> but also think hard :)
21:00:16 <NRee1> i have to compile it otherwise i get a stack overflow
21:00:28 <dons> right, so it depends on the strictness analyser
21:00:39 <dons> or possibly one of the fusion rules kicking in
21:00:58 <NRee1> so how would you guys recommend speeding this thing up?
21:01:01 <dons> ghc -O2 --make   is a good option for quick code, btw.
21:01:20 <mar77a> hm if i do a foldr with (/) is that like a continued fraction?
21:01:21 <dmwit> NRee1: I think a stateful calculation that keeps track of pre-computed run lengths makes sense.
21:01:32 <dmwit> > foldr (/) z [a,b,c]
21:01:37 <lambdabot>  a / (b / (c / z))
21:01:43 <mar77a> mm
21:01:55 <dmwit> So... not really.
21:01:57 <mar77a> maybe a foldl
21:01:58 <dons> yeah, glguy liked using a memo array for this
21:02:01 <dmwit> But you can get it to be.
21:02:04 <NRee1> dmwit ah I just remembered that I was going to do that, but I got lazy
21:02:06 <mar77a> i wonder how
21:02:35 <dmwit> > foldr (\a b -> 1 / (a + b)) z [a,b,c]
21:02:36 <lambdabot>  1 / (a + 1 / (b + 1 / (c + z)))
21:03:06 <dons> NRee1: what value of 'n' were you using, btw?
21:03:20 * dons notes hpaste is a good source of collatz implementations
21:03:25 <dons> hey, speak of the devilish glguy
21:03:29 <NReed> wow I cant believe I miss typed my name :S
21:03:36 <NReed> and didnt notice till now
21:03:51 <dmwit> '1' is a pretty bad typo for 'd'.
21:04:04 <dmwit> I just figured it was the "away" variant of your name. =)
21:04:07 <SamB_XP> what's your excuse?
21:04:16 <NReed> i know :S i guess haskell for a whole day mashes your brain :)
21:04:18 <glguy> dons, if that is your real nick
21:04:18 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
21:04:23 <glguy> weird that you aren't identified...
21:05:01 <glguy> I can't make changes to hpaste
21:05:09 <glguy> so I'll just keep getting that same bug report
21:05:11 <NReed> dons I dont get the question...
21:05:12 <glguy> over and o ver and over ;)
21:05:29 <SamB_XP> glguy: well, it's probably because your name is at the bottom of the page!
21:05:39 <glguy> I can't change that either!
21:05:40 <glguy> :)
21:05:53 <SamB_XP> glguy: perhaps you should suggest it to whoever can
21:06:09 <mar77a> :t foldr
21:06:10 <dons> NReed: oh, i didn't see the [1..1000000] list, sok
21:06:11 <glguy> its just a matter of finding a server to run the new hpaste on
21:06:13 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:06:25 <dons> glguy: i think we have servers
21:06:33 <mar77a> :t (+)
21:06:35 <lambdabot> forall a. (Num a) => a -> a -> a
21:06:39 <shapr> glguy: Why can't you make changes to hpaste?
21:06:53 <SamB_XP> glguy: how much bandwidth does it use?
21:06:55 <mar77a> :t (\a b -> 1 / (a+b))
21:06:57 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:07:06 <mar77a> interesting
21:07:08 <glguy> shapr: how much bandwidth does hpaste use?
21:07:11 <shapr> um
21:07:14 <shapr> I haven't checked.
21:07:18 <glguy> shapr: I don't have the right version of happs anywhere
21:07:22 <shapr> oh
21:07:36 <glguy> and all my machines are 64bit
21:07:46 <glguy> so its not just a matter of building on my machine  but building on someone elses
21:07:50 <shapr> hpaste doesn't work 64bit?
21:07:55 <shapr> oh I see
21:08:00 <glguy> kakapo is 64 bit?
21:08:03 <shapr> Nah
21:08:09 <shapr> I wonder if I could upgrade it...
21:08:38 <shapr> I'm slowly moving all my scannedinavian stuff to my desktop, now that I have a static public ip.
21:08:41 <shapr> And it's 64 bit.
21:15:13 <dons> this looks interesting, http://haskell.org/haskellwiki/SceneGraph
21:15:14 <lambdabot> Title: SceneGraph - HaskellWiki
21:15:31 <dons> conal`: "he module Graphics.SceneGraph.Reactive uses Reactive to enliven a scene. ExampleReactive.hs provides an example of this.This uses a calculator defined independantly of the GUI and is made tangible by SceneGraph."
21:17:53 <slava> hi dons
21:18:01 <sjanssen> @keal
21:18:02 <lambdabot> actually it bug in math
21:18:12 <sjanssen> oh noes
21:19:18 <dons> heya slava
21:22:58 * thetallguy wonders what language dons is speaking
21:28:06 <dmwit> heh heh heh
21:28:41 <Twey> thetallguy: Haskell 2.0 -- it was so useful they merged it with Lojban and made it a human language.
21:29:22 <dmwit> Dang, I can't even compute all the primes up to 5e7 in under a minute.  How am I supposed to do this problem?
21:30:04 <bd_> which problem?
21:30:10 <sjanssen> just do it in C
21:30:32 <dmwit> http://projecteuler.net/index.php?section=problems&id=187
21:30:33 <lambdabot> Title: Problem 187 - Project Euler
21:30:33 <Twey> *chuckle*
21:31:48 * dmwit has trouble imagining a way to do this without computing a buttload of primes
21:31:53 <dolio> How are you computing them?
21:32:12 <dmwit> ?wiki primes
21:32:12 <lambdabot> http://www.haskell.org/haskellwiki/primes
21:32:32 <dmwit> ...not like that
21:33:05 <dmwit> http://www.haskell.org/haskellwiki/Prime_numbers
21:33:06 <lambdabot> Title: Prime numbers - HaskellWiki
21:33:14 <dmwit> The one there that starts with "merge".
21:34:08 <dolio> I used trial division and it worked for that problem.
21:34:16 * bd_ tries implementing a sieve of eratosthenes up to 10^8
21:34:42 <dmwit> > 2e8 / 1024 / 1024
21:34:43 <lambdabot>  190.73486328125
21:35:01 <dolio> (And then I wrote another solution with STUArrays, but whatever. :))
21:35:01 <dmwit> 190 megs might not be that bad, assuming Bool will fit in two bytes.
21:35:11 <bd_> dmwit: STUarray puts Bool on one bit, I think?
21:35:14 <bd_> in one bit*
21:35:17 <sjanssen> bd_: yes, it does
21:35:22 <dmwit> It wouldn't surprise me.
21:35:32 <dmwit> So call it 15 megs, then.
21:36:01 <dolio> I'm pretty sure the one with trial division worked in a reasonable amount of time, though.
21:36:14 <dmwit> Okay, time to try using naiveIsPrime, then. =)
21:36:35 <dons> bitwise bool sieve, http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=ghc&id=0
21:36:36 <lambdabot> Title: nsieve-bits Haskell GHC program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comp ..., http://tinyurl.com/2xnch4
21:37:21 <dolio> My solution using STUArrays apparently took some fact I learned in the comments on that problem, though.
21:37:57 <dolio> Some way of computing the answer based on the number of primes below a given value, so it computed the answer during the prime sieve loop.
21:39:35 <dmwit> Oh, yeah, it's (n `choose` 2) if n is the number of primes.
21:39:45 <dmwit> But that doesn't help until you've counted the primes...
21:40:27 <dolio> Yeah, well, my sieve had both an STUArray Int Bool for the primes and an STUArray Int Int for pi(n).
21:40:28 <dmwit> (Well... n `choose` 2 + n, I guess.)
21:40:52 <dolio> Or something like that.
21:41:37 <dmwit> Oh, heh, that reduces to n(n+1)/2, which should have been the first thing I said anyway.
21:41:46 <dmwit> It's the sum of the first 'n' naturals.
21:43:04 <dolio> The STUArray version takes 9 - 10 seconds. I think the one with lists took a minute or two.
21:43:40 <bd_> @hoogle STUArray
21:43:41 <lambdabot> Data.Array.ST.STUArray :: data STUArray s i a
21:43:41 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
21:43:41 <lambdabot> Data.Array.ST.castSTUArray :: STUArray s ix a -> ST s (STUArray s ix b)
21:46:20 <dmwit> This naive version definitely isn't going to make it in under a minute.
21:46:45 <dmwit> It barely got up to 15,000 in a minute.
21:51:47 <bd_> woo, got the answer in 46.12 seconds :3
21:52:12 <bd_> (runtime, not thinking time :)
21:52:21 <ddarius> Hmm.  Lollimon parses ! ! a, but the paper suggests that that isn't syntactically valid (in a sense ! : A -> S)
21:56:07 <dmwit> bd_: ghci or ghc?
21:58:08 <bd_> dmwit: ghc -O2, native code generator
21:58:19 <dmwit> Oh, okay.
21:58:42 <dmwit> I don't feel so bad, then, as the primes generator I already have can solve it in 145s under -O2.
21:59:09 <dmwit> If you were getting 46s in ghci, I would have been way less happy. =P
21:59:19 <ddarius> Wait.  It seems to be in the wrong syntactic class altogether.
21:59:41 <mbz> bd_, what kind of cpu do you have?
21:59:59 <bd_> mbz: AMD Turion(tm) 64 X2 Mobile Technology TL-50
22:00:08 <bd_> I did not attempt to paralleize it, and it's running in 32-bit mode
22:03:35 <ddarius> well shit
22:06:34 <nolrai_> :t (&&&)
22:06:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:07:54 <nolrai_> > :t curry
22:07:54 <lambdabot>   parse error on input `:'
22:08:01 <nolrai_> :t curry
22:08:03 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:08:52 <nolrai_> :t \f g -> curry (uncurry f &&& uncurry g)
22:08:54 <lambdabot> forall a b c c1. (a -> b -> c) -> (a -> b -> c1) -> a -> b -> (c, c1)
22:09:39 <nolrai_> meh
22:09:54 <cdsmithus> There seem to be several different ways to do exceptions in Haskell.  Which one should I mention to new Haskell programmers?
22:10:20 <ddarius> It depends on your goals.
22:10:34 <cdsmithus> My goal is to stick a slide in this presentation about exceptions
22:11:25 <ddarius> Then any exception mechanism can be described on a slide and put into your presentation.
22:11:58 <cdsmithus> Yeah, I was just wondering is there's some conventional wisdom; like avoid ioError and use Control.Exception, or vice versa
22:12:34 <ddarius> Again, it depends on your goals.  What do you want the audience to get out of your slide?
22:13:03 <SamB_XP> I would mention Exception
22:13:39 <cdsmithus> ddarius, that's a good question.  I honestly don't know at this point.  It just seems like something I should mention, even though I've never had a reason to use it.
22:14:22 <SamB_XP> why mention it if you don't use it?
22:14:22 <dmwit> If you just want to cover error-handling, and have a Haskell-ish way of doing it, why not just show MonadError?
22:15:22 <cdsmithus> Hmm.  I already am talking about the Maybe monad.  Maybe I'll just take exceptions out.
22:18:03 <nolrai_> that might be best.
22:18:22 * ddarius needs to consider the laws of the monad.
22:18:54 <SamB_XP> cdsmithus: or talk about Either instead ;-)
22:19:05 <glguy> dons: github is pretty awesome
22:19:05 <glguy> I'm going to have to give you a demo when I get back
22:20:33 <ddarius> :t (. return)
22:20:35 <lambdabot> forall b a (m :: * -> *). (Monad m) => (m a -> b) -> a -> b
22:20:59 <ddarius> That's the secret.
22:22:00 <ddarius> I think...
22:23:21 <nolrai_> thats a weird type, what are you doing?
22:24:37 <ddarius> Trying to understand why ! a -o b is legal in the CLF/Lollimon when S ::= A | ! A | ... and A ::= A -o A | { S } | ...
22:24:59 <ddarius> Where { _ } represents a monad type constructor.
22:25:27 <ddarius> Where (! a -o b) means ((! a) -o b)
22:38:24 <nolrai_> :t guard
22:38:26 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
22:40:33 <bd_> @hoogle compareBy
22:40:34 <lambdabot> No matches found
22:40:40 <bd_> :t soryBy
22:40:42 <bd_> :t sortBy
22:40:42 <lambdabot> Not in scope: `soryBy'
22:40:43 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
22:41:01 <nolrai_> > [guard (x > 3) >> return $ show x | x <- [0..7]]
22:41:01 <lambdabot>   add an instance declaration for (Show (m String))
22:41:15 <nolrai_> > [guard (x > 3) >> return $ x | x <- [0..7]]
22:41:16 <lambdabot>   add an instance declaration for (MonadPlus ((->) a))
22:41:32 <nolrai_> > [guard (x > 3) >> return x | x <- [0..7]]
22:41:32 <lambdabot>   add an instance declaration for (Show (m t))
22:42:26 <nolrai_> > do {x <- [0..6]; guard (x > 3); return (x * 2)}
22:42:28 <lambdabot>  [8,10,12]
22:43:33 <nolrai_> :t fail
22:43:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
22:44:15 <nolrai_> @src State fail
22:44:15 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:44:23 <nolrai_> @src fail
22:44:23 <lambdabot> fail s      = error s
22:46:14 <ddarius> :t (=<<)
22:46:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
22:47:11 <Twey> @pl \x y -> (y, x + y)
22:47:11 <lambdabot> ap (,) . (+)
22:49:19 <nolrai_> :t (>==)
22:49:21 <lambdabot> Not in scope: `>=='
22:49:26 <nolrai_> :t (<==)
22:49:27 <lambdabot> Not in scope: `<=='
22:49:34 <dmwit> :t ==>
22:49:36 <lambdabot> parse error on input `==>'
22:49:38 <dmwit> :t (==>)
22:49:40 <lambdabot> forall a. (Testable a) => Bool -> a -> Property
22:50:02 <nolrai_> ?
22:50:13 <nolrai_> @src ==>
22:50:13 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:50:28 <dmwit> ?check \n -> even n ==> 2 * (n `div` 2) == n
22:50:29 <lambdabot>  OK, passed 500 tests.
22:50:37 <dmwit> ?check \n -> 2 * (n `div` 2) == n
22:50:38 <lambdabot>  Falsifiable, after 1 tests: 1
22:50:53 <nolrai_> impiles?
22:51:00 <dmwit> yes
22:52:56 <nolrai_> is there a standard symbol for cobind?
22:53:06 <dmwit> =>>, I think
22:55:25 <dmwit> Will it be faster to readArray multiple times, or (!) multiple times?
22:55:59 <dmwit> i.e. if I'm going to be in the ST monad anyway, should I bother runSTUArray'ing the part of the computation that's done?
22:56:29 <mbz> dmwit, why not to test it?
22:56:35 <dmwit> right
22:58:26 <dmwit> :t unfoldr
22:58:28 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:00:02 <dmwit> :t accumArray
23:00:04 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
23:10:52 <ddarius> :t (ap .) . join
23:10:53 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Functor m1, Monad m) => m1 (m1 (m (a -> b))) -> m1 (m a -> m b)
23:11:08 <ddarius> :t (join .) . ap
23:11:10 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => m (a1 -> m a) -> m a1 -> m a
23:11:25 <ddarius> :t (join .) . (=<<)
23:11:27 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m (m a)) -> m a1 -> m a
23:11:35 <ddarius> :t (join .) . (>>=)
23:11:36 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => m a1 -> (a1 -> m (m a)) -> m a
23:12:11 <ddarius> \mf a -> mf >>= ($ a)
23:12:19 <ddarius> :t \mf a -> mf >>= ($ a)
23:12:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> m b) -> a -> m b
23:20:19 <nolrai_> @src join
23:20:20 <lambdabot> join x =  x >>= id
23:28:27 <dons> there you go, http://reddit.com/r/programming/info/6ll73/comments/
23:28:34 <dons> "hsXenCtrl: script Xen with Haskell"
23:28:43 <dons> good to see new areas being pushed on.
23:28:52 <dons> the scenegraph lib released today also looks interesting
23:31:30 * gwern reads about the [[American flag sort]]
23:32:12 <dons> dcoutts: this one might be for you, "Subject: [Haskell-cafe] Images and GUIs in Haskell"
23:32:18 * dons does triage on the mailing list
23:32:43 <dons> hmm. i wonder if triage for community help has been written down before.
23:33:06 <dons> we could have little forms like this, http://upload.wikimedia.org/wikipedia/commons/9/97/Deconference-2002-triage-tag.jpg
23:33:07 <lambdabot> http://tinyurl.com/5k5jro
23:33:09 <dons> :)
23:33:23 <dons> "Stack overflow: Yes/No"
23:33:30 <dons> "Forgot --make"
23:33:39 <dons> "Andrew Coppin"
23:33:58 <dons> "Blunt object trauma inflicted by GHC"
23:35:52 <dmwit> "Function is monomorphic, but should be polymorphic"
23:36:10 <dmwit> "Don't understand $!@% about monads"
23:36:15 <dons> heh
23:36:28 <dons> a top 10 FAQs would be useful
23:36:36 <dons> lots of projects have FAQs, why not haskell
23:36:51 <dons> "How do I catch the exception that 'read' throws"
23:37:53 <dmwit> "Disenchanted because I have to tell compiler how to parallelize my code"
23:38:28 <dmwit> Actually, that's not such an FAQ.
23:40:46 <dons> well, its that general theme of wtf, i thought haskell could do parallel for me!?
23:41:06 <dons> "Is Haskell just for mathematicians?"
23:41:12 <araujo> No!
23:42:14 <proqesi> sure
23:42:15 <dancor> my biggest problem is that i feel _slow_ in haskell
23:42:41 <proqesi> and C is just for OS designers
23:43:04 <ddarius> dons: There was a FAQ on the old wiki.
23:43:24 <dancor> maybe because every time you do a hack to save time, haskell makes you feel really bad about it, like you killed a puppy
23:44:10 <Twey> Hahahahaha
23:44:19 <dmwit> Hum, how can a run to STUArrays at once?
23:44:29 <dons> hmm, we need a "haskell really damn fast" do we?
23:44:33 <dmwit> Do I have to have an STUArray of a pair?
23:44:37 <dons> for just getting the job done.
23:44:46 <dons> dmwit: hmm, you can allocate inside a runST
23:44:47 <atp> you can most likely have two stuarrays
23:44:49 <dons> as many as you need
23:45:00 <dons> just ask for a newArray
23:45:05 <dmwit> right...
23:45:25 <atp> the ST monad is sort of a pain
23:45:26 <dmwit> So I can get (ST s (STUArray a, STUArray b)).
23:45:31 <dmwit> (schematically)
23:45:34 <dmwit> Then what?
23:46:01 <dmwit> runST gets me a pair of STUArrays, but I can't really see any operations that take straight STUArrays.
23:46:12 <dolio> You'd want to freeze them.
23:46:31 <dolio> And get 'ST s (UArray a, UArray b)'.
23:46:33 <dmwit> Ah, freeze operates on all instances of MArray.
23:46:45 <dmwit> Sweet, thanks.
23:53:20 <dmwit> ?index newSTRef
23:53:21 <lambdabot> Data.STRef.Lazy, Data.STRef, Data.STRef.Strict
