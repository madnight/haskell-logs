00:00:21 <bd_> which is to be expected, as the resulting code ought to be similar
00:00:50 <dolio> Yeah.
00:01:27 <dolio> Is 6 - 7 seconds any good for sorting a 100 million element array?
00:01:59 <dons> what does C's sort do to the same array?
00:02:33 <dolio> I don't know. I'd have to actually get an array if I wanted to do that.
00:02:54 <dolio> I've been using the random array from runU 100000000.
00:03:11 <dolio> Uninitialized, that is.
00:03:43 <bd_> zeroed, probably.
00:04:21 <dons> no, not zeroed. :)
00:04:28 <dons> it should just be empty heap garbage
00:05:02 <quicksilver> how big are the elements?
00:05:15 <quicksilver> superficially 6-7 seconds for 100 million sounds very good to me.
00:05:17 <bd_> dons: well,given the size of it
00:05:24 <dolio> They're Ints. 64-bit.
00:05:33 <quicksilver> that's only 60ns per element.
00:05:38 <bd_> right, 800mb allocation, most of that's coming fresh from the OS, isn't it?
00:05:47 <bd_> so, zeroed, or mostly so
00:06:17 <dons> ah maybe
00:06:23 <dons> that's a good point.
00:07:00 <bd_> I'd like to see how quicksort handles that one :)
00:07:16 <solrize> 6-7 sec for sorting 100 million int64
00:07:19 <solrize> ?
00:07:21 <solrize> that's excellent
00:07:32 <solrize> in fact it's astounding
00:07:42 <solrize> @hoogle on
00:07:43 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
00:07:43 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
00:07:43 <lambdabot> Data.Function :: module
00:07:58 <bd_> are you sure it's being sorted? ;)
00:08:20 <dons> oh, nearly a gig
00:08:33 <dons> yeah, the 1G sort on bytestrings is a fair bit slower.
00:08:50 <dons> sok ok. good. funny business
00:09:22 <solrize> it's probably an OOM faster than the C library qsort
00:09:30 <mxc> anybody know jeff polakow?
00:09:41 <bd_> Best to quickcheck that it's really doing the sort though
00:09:45 <solrize> on random input
00:09:55 <Pseudonym> Pretty much anything is faster than the C library sort.
00:10:14 <solrize> i expected the c library sort to be pretty good, at least it was back in the day
00:10:26 <Pseudonym> The problem is the API.
00:10:26 <solrize> but i haven't examined the one in glibc
00:10:29 <bd_> I can't imagine that taking an indirect call hit O(n lg n) times would help performance much in qsort() :)
00:10:35 <solrize> oh that it does a func call on each comparison
00:10:40 <Pseudonym> Yeah.  It's not specialised.
00:10:41 <solrize> i wonder if there's a templatized c++ one
00:10:57 <Pseudonym> And it has to use memcpy or the equivalent to move stuff around, even when the data fits in a register.
00:11:03 <Pseudonym> Absolutely.
00:11:03 <solrize> yeah
00:11:07 <bd_> theoretically it could specialize itself, but I doubt glibc does that
00:11:07 <Pseudonym> std::sort
00:11:24 <bd_> they're paranoid about enabling executable heap segments, even for brief windows, these days...
00:11:26 <solrize> i think glibc has to run in pure code segments
00:11:45 <bd_> er, exec/write segments even
00:12:02 <solrize> i wonder how gnu lightning deals with that
00:12:15 <solrize> or harpy
00:14:27 <dolio> I'm pretty sure it's sorting. It was sorting on the small examples I tried.
00:14:51 <dolio> I'm initializing it with random data now and it's taking much longer.
00:15:24 <bd_> isolating the initialization's time, I hope? :)
00:16:59 <dolio> Yeah, taking out the sorting, it's still taking a while. :)
00:17:06 <smtms> dolio, the small examples can fit into caches, while the larger can't
00:18:09 <dolio> Whether or not it fits in the cache shouldn't affect whether it correctly sorts or not.
00:18:42 <bd_> shouldn't heap sort take the same amount of time (to a constant factor) regardless of the order of the input?
00:18:55 <cjs> So, due to the issues with manipulating state in my parser, where I end up with everything that touches the state directly looking like ' hasMore = Parser $ \state -> Right (remaining state > 0, state)', it's looking like what I really need ar e a minimal number of very low-level "unsafe" combinators that do no error checking and, e.g., explode when I try to pull a char out of a ByteString that is past the end, and then higher-level ones that do c
00:18:55 <cjs> hecked versions and return proper errors. What names might one use for these things? perhaps "parseChar" which calls "parseCharUnsafeWithoutMovingPosition" and "incrementPosition"?
00:19:43 <bd_> cjs: unsafePeekChar and unsafeSkipChar?
00:19:59 <cjs> Or is there any way to get, e.g., "Parser $ \st@(ParseState bs _ pos _) -> Right (L.index bs pos, st { parsePos = pos + 1 })" on the right side of a "c <- parseCharUnsafe"?
00:20:06 <cjs> Ooo, "peek", I like that. Thanks!
00:22:10 <solrize> bd, heapsort has O(n log n) worst case behavior unlike quicksort which could be quadratic on adversarial input, but i think heapsort's time is not deterministic
00:22:14 <cjs> It's kind of interesting that when you learn a language this different, you also have to learn a whole new set of naming conventions.
00:22:21 <solrize> because the heapify operation on one element can be anywhere between 1 and O(log n) operations
00:22:33 <solrize> and, i think heapsort isn't so good for large arrays because of its random access patterns
00:22:48 <solrize> quicksort is more cache friendly, and you can parallelize its recursion
00:23:21 <bd_> solrize: right, but isn't the heapsort best case also O(n lg n)?
00:23:43 <bd_> though... I suppose if you get lucky on the input heapify would be O(1)
00:23:50 <glguy> !seen dons
00:23:54 <glguy> @seen dons
00:23:54 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 15m 4s ago.
00:24:07 <zeno__> isnt quicksort the best O sort?
00:24:19 <solrize> bd, if the input is already sorted then maybe heapsort is linear
00:24:21 <Baughn> No, quicksort is O(n^2)
00:24:23 <bd_> zeno__: no, they're all O(n lg n) or worse :)
00:24:31 <bd_> solrize: or all zero, I guess
00:24:32 <dolio> It would appear that having a lot of the same element makes heap sort a lot faster.
00:24:36 <Baughn> zeno__: Radix sort is O(n) ;)
00:24:47 <Baughn> Well. Kinda.
00:24:53 <dolio> If this applet is accurate: http://www.csc.depauw.edu/~bhoward/courses/0203Fall/csc222/sort/
00:24:53 <glguy> if you limit the inputs
00:24:53 <lambdabot> Title: Animated Algorithms : Sorting
00:25:02 <solrize> that's a good point, for sorting fixed width ints then radix sort may beat comparison sorting
00:25:31 <dmwit> The more assumptions you can make about your inputs, the faster your sort can be.
00:25:37 <zeno__> kinda?
00:25:51 <Baughn> zeno__: It relies on the elements having a maximum size
00:25:52 <dons> glguy: ? on my way out.
00:25:54 <solrize> i guess it also depends on your cache associativity
00:25:58 <dmwit> My id-sort is blazingly fast, but it assumes the input is sorted...
00:26:01 <bd_> Well, yeah, but for comparison sort the best you can do is worst case O(n lg n)
00:26:39 <dmwit> bd_: There are other assumptions you can make that will help a comparison-based sort do better than O(n log n).
00:26:54 <solrize> radix sorting is better for enormous n, but i mean on real hardware with realistically sized large data sets
00:27:01 <solrize> i want to sort a lot of word128's
00:27:08 <solrize> for example
00:27:11 <sclv> my maybe-reverse sort is slower, but it doesn't assume what direction the input is sorted in.
00:27:18 <dmwit> bd_: For example, if you know the elements are chosen from a uniform distribution that helps a lot (even if the bounds of the distribution are not known at the beginning).
00:27:20 <solrize> sclv :)
00:27:36 <Baughn> solrize: Well? The log n factor can easily reach 10 at least
00:28:09 <Baughn> I /think/ radix sort would beat it
00:28:24 <solrize> baughn for something like quicksort the pivot step can be very cache friendly, you can use prefetch instructions or recent hardware can tell what is about to happen
00:28:39 <solrize> while radix sort has to spew the input all over memory
00:29:07 <Baughn> And it goes without saying, but a 40MHz hardware sort easily outperforms a 2GHz software one. ;)
00:29:30 <solrize> hmm i dunno about hardware sorting for large input
00:29:31 <dmwit> whoa
00:29:35 <dmwit> Is that really true?
00:29:46 <solrize> dmwit yeah, look up batcher networks
00:29:53 <solrize> but you need O(n**2) gates
00:29:55 <Baughn> dmwit: If you can make the sorting network large enough, but modern FPGAs have that ability, yes
00:30:08 <dmwit> wow
00:30:10 <Baughn> It's a case of massive parallelism
00:30:50 <bd_> it's worse than O(n lg n) cost, then? :)
00:31:12 <solrize> depends on your cost metric
00:31:24 <dmwit> Oh, WOW.
00:31:25 <bd_> Where cost is measured in dollars ;)
00:31:25 <solrize> dj bernstein has some good arguments about that
00:31:27 <dmwit> That is so clever!
00:32:22 <Baughn> Worst case, you could stuff a couple dozen RISC cores in a modern fpga, so.. yeah
00:32:58 <Baughn> It's almost odd that modern PCs don't have built-in FPGAs for acceleration purposes
00:33:34 <solrize> baughn there's some fpga chip that you can plug into an opteron socket, the idea is you buy a two-socket board and use a regular opteron in one socket and the fpga as a coprocessor
00:34:03 <solrize> but, i'm skeptical that it makes sense for large sorting problems
00:34:13 <Baughn> solrize: Clever. But I meant /standard/ - so applications could assume they'd be there
00:34:15 <solrize> sorting meshes are usually for sorting small sets extremely fast
00:34:33 <solrize> baughn yeah future cpu's are likely to start sprouting fpga blocks
00:34:43 <Baughn> They'd have to be able to reconfigure in a fraction of a cpu timeslice, though. Is that psosible yet?
00:35:27 <solrize> dunno.  the configuration is just a block of sram...
00:35:56 <Baughn> Sounds like it should be, but the one I've got takes several hundred milliseconds..
00:36:11 <Baughn> (Then again, that's via usb)
00:37:25 <cjs> Is there no "substring" operation for ByteStrings? I need to do a drop and take instead?
00:37:36 <solrize> depending on the deployment profile it might be ok to just wire down the fpga config for fairly long periods
00:37:43 <solrize> cjs, yeah, take/drop is constant time
00:38:06 <Baughn> dmwit: ANYway.. you can use a sorting network to sort small sublists explosively fast, and then a generic CPU core to do mergesort on top of that. `End result: ridiculously fast fpga sorting.
00:38:26 <cjs> Yes, but it's constantly slightly more than substring. :-)
00:38:45 <bd_> cjs: until it all inlines and fuses away, right? :)
00:39:01 <bd_> @source Data.ByteString
00:39:02 <lambdabot> Data.ByteString not available
00:39:05 <bd_> @source Data.Bytestring
00:39:06 <lambdabot> Data.Bytestring not available
00:39:08 <bd_> mhm
00:39:12 <Baughn> solrize: It could be, but not if it's exposed to software
00:39:40 <cjs> bd_: really? I can see fusing, say, a couple of maps, but can take . drop really avoid the generation of an intermediate ByteString object?
00:39:41 <solrize> right, i mean it could be ok for changing the config to require some slow system call
00:39:55 <bd_> cjs: Check the generated core :)
00:40:03 <cjs> (Obviously a small one, since it's just a copy of the original with a pointer changed, but...)
00:40:08 <solrize> like changing your video mode or something liek that
00:40:11 <cjs> Oh, really?!
00:40:18 <cjs> That's freakin' sophisticated.
00:40:59 <bd_> Well, i haven't checked, but I'm doing so now ... :P
00:41:20 <cjs> I'd like to see a paste of what you find.
00:41:20 <Baughn> solrize: Then only one application could do it at a time. Well, I suppose it could work.
00:41:50 <dolio> Well, I'm at around 3.5 seconds to sort a random initialized 3 million element array.
00:42:04 <solrize> dolio that's with uarray or something?
00:42:20 <dolio> The initialization takes around 14 seconds, so sorting it seems to be much faster.
00:42:35 <dolio> I'm sorting the MUArrs from uvector.
00:43:31 <solrize> what alg?
00:43:49 <solrize> this is int32's?
00:43:59 <solrize> wait int64's?
00:45:41 <bd_> cjs: http://hpaste.org/7611 here's the optimizer result on -O2 -ddump-stg. I'm not an expert on STG syntax, but it looks like the two functions got inlined and combined (most of what you see is bounds checks)
00:46:46 <bd_> what's wrong with hpaste's announce feature anyway?
00:48:11 <bd_> solrize: int64s, heapsort
00:48:20 <solrize> interesting
00:48:22 <bd_> or well Int on 64-bit with heapsort
00:48:23 <solrize> what hw?
00:48:25 <bd_> is what he was doing earlier
00:49:12 <solrize> i'd be interested in seeing classical quicksort timing on an amd barcelona
00:49:33 <solrize> which apparently has a much smarter hardware prefetch than older cpu's
00:49:53 <cjs> bd_, It's been broken for something like a week now.
00:49:55 <solrize> bd you coded heapsort in haskell for uarrays?
00:50:06 <solrize> i mean muarrs
00:51:41 <cjs> bd_, I find the STG difficult to read, mostly due to the variable names, but I think I believe you on this one.
00:52:49 <dolio> http://hpaste.org/7612 There it is if anyone wants to play with it.
00:55:44 <bd_> cjs: what's been broken?
00:55:53 <solrize> dolio, neat
00:56:09 <cjs> bd_, hpaste announce.
00:56:28 <bd_> ah
01:02:06 <dcoutts> gwern: about cabal upload, you're right it'd be nicer to do an sdist and upload that by default
01:02:19 <dcoutts> gwern: though we don't actually know if the tarball is up to date or not
01:02:38 <dcoutts> gwern: we could just re-sdist anyway I suppose
01:18:52 <dolio> http://hpaste.org/7612#a1 quick sort added
01:19:50 <dolio> Doesn't seem to be any better than heap sort.
01:23:31 <dolio> qsort gets destroyed by the uninitialised data, too, so it's obviously not very random.
01:23:59 <solrize> you should stop recursing when u-l < k for some reasonable k, and switch to a nonrecursive algo
01:24:53 <solrize> also i wonder what the asm code for the partition step looks like but i'm not x86-literate enough to read it probably
01:25:23 <solrize> you did that with random data?
01:26:00 <dolio> Yeah, I'm not, either.
01:26:07 <solrize> also you should use the middle array element as the pivot, not the lowest elt
01:27:44 <solrize> your timing was on qsort and not qsortby, and ghc inlined the compare?
01:28:18 <quicksilver> middle array element is not really any better than lowest.
01:28:25 <quicksilver> it just chooses a different worst case :P
01:28:45 <solrize> lowest element pessimizes the fairly common case where the input is already sorted
01:29:05 <solrize> iirc, knuth vol 3 has a complicated analysis showing middle elt is better on average too, but the difference is small
01:29:47 <dmwit> There's lots of possible optimizations.
01:29:55 <dmwit> median-of-three, pre-permute, etc.
01:30:07 <solrize> yeah
01:30:18 <quicksilver> could be the first true quicksort I've seen in haskell though :)
01:30:43 <solrize> there's one on augustss's blog iirc
01:30:53 <quicksilver> probably :)
01:30:58 <solrize> http://augustss.blogspot.com/2007/08/quicksort-in-haskell-quicksort-is.html
01:30:59 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2hq6cn
01:31:17 <RayNbow> @faq Can Haskell fix the DSL Trouble in the Netherlands?
01:31:17 <lambdabot> The answer is: Yes! Haskell can do that.
01:31:26 * RayNbow has faith
01:31:32 <solrize> @faq what about the chinese earthquake?
01:31:32 <lambdabot> The answer is: Yes! Haskell can do that.
01:32:20 <Vq^> is there any arrow function similar to &&& that does n forks?
01:32:30 <RayNbow> @faq Does the Haskell Prelude includes orderPizza :: Money -> IO Pizza?
01:32:31 <lambdabot> The answer is: Yes! Haskell can do that.
01:33:20 <Vq^> im trying to do tag-lookups with hxt based on information in a table
01:33:42 <sjanssen> RayNbow: yes, but there is no way to construct a non-bottom value of Money
01:34:10 <RayNbow> :p
01:34:29 <sjanssen> if you turn on GHC extensions "orderPizza (unsafeCoerce# 10.99)" will work
01:35:16 <quicksilver> Vq^: there are only builtin arrow functions for 2-tuples.
01:35:25 <quicksilver> Vq^: if you want n-forks maybe you want to use a []-arrow?
01:36:19 <Vq^> quicksilver: maybe, but i don't think so
01:37:44 <Vq^> i want to be able to combine the results almost directly
01:39:00 <Botje> ITYM unsafeCoerce# $ 10.99
01:39:02 <solrize> http://cr.yp.to/snuffle/bruteforce-20050425.pdf  baughn might like this
02:08:15 <Japsu> @oeis 4 3 3 5
02:08:16 <lambdabot> Number of letters in the English name of n, excluding spaces and hyphens.
02:08:16 <lambdabot> [4,3,3,5,4,4,3,5,5,4,3,6,6,8,8,7,7,9,8,8,6,9,9,11,10,10,9,11,11,10,6,9,9,11,1...
02:13:29 <mm_freak_work> what's that?!
02:13:52 <RayNbow> map length ["zero", "one", "two", ...]
02:33:10 <ketil> does anybody know  what happens if you specify both -O and -O2 to ghc?  I notice this happens when specifying -O2 in the cabal file.
02:33:23 * ketil knows he shouldn't do that.
02:34:43 <dcoutts> ketil: the second overrides the first
02:35:14 <dcoutts> ketil: btw, the new version of cabal lets you: cabal configure -O2, or indeed -O0 or -O == -O1
02:48:18 <dcoutts> @tell ndm you can now run programs in-place with Cabal and have them find their data files. It's not yet wonderfully convenient, suggestions welcome.
02:48:18 <lambdabot> Consider it noted.
02:48:19 <cjs> What is the type of a constructor of a type?
02:48:53 <dcoutts> data Foo = Bar Baz -- means Bar :: Baz -> Foo
02:48:59 <cjs> e.g, 'data Foo = A String | B Int'...
02:49:01 <dcoutts> cjs: it's clearer with GADT syntax
02:49:08 <dcoutts> data Foo where
02:49:11 <quicksilver> A :: String -> Foo
02:49:17 <dcoutts>   A :: String -> Foo
02:49:20 <dcoutts>   B :: Int -> Foo
02:49:44 <cjs> Ah, I see. And I should have dropped that into ghci first, anyway. Sorry about that.
02:50:22 <cjs> Hmm...so there's no type that covers all constructors of a particular type, eh? Duh, of course not, since they're just functions like any other.
02:50:43 <cjs> I'm not convinced constructors should start with a capital letter.
02:51:00 <quicksilver> it's convenient to have a syntactic distinction, that's all.
02:51:15 <quicksilver> gives you better error messages.
02:51:21 <cjs> Note how it mislead my reasoning, here, though admittedly I have a tiny little mind.
02:51:26 <cjs> Does it?
02:51:30 <quicksilver> yes.
02:51:41 <quicksilver> consider pattern matching
02:52:15 <cjs> I dunno, it seems to me an essential failure of Haskell that you can't pattern match on arbitrary functions. :-)
02:52:21 <quicksilver> hmm.
02:52:28 <quicksilver> maybe that's not the right example.
02:52:32 <quicksilver> on reflection.
02:54:06 <quicksilver> I don't know.
02:54:17 <quicksilver> I have a feeling there are a few good examples of why it's convenient, but I can't call them to mind.
02:54:22 <quicksilver> It's certainly not necessary.
02:54:32 <quicksilver> cjs: note that constructors aren't first-class.
02:54:38 <quicksilver> occasionally it would be nice if they were.
02:54:49 <quicksilver> occasionally it's nice to have a 'parallel type'
02:54:51 <cjs> 'case theta of { sin n -> ... }'
02:55:08 <quicksilver> data FooCons = FC_A | FC_B
02:55:21 <quicksilver> deriving (Enum,Eq,Bounded)
02:55:37 <quicksilver> which you can use as if it was a reification of the constructors.
02:55:42 <dcoutts> quicksilver: it is necessary to distinguish constructors and variables in pattern matching
02:55:59 <dcoutts> the case difference of constructors is a simple way to do that
02:56:05 <quicksilver> dcoutts: I don't think it's necessary. It's certainly convenient.
02:56:25 <quicksilver> dcoutts: otherwise given case x of y -> you'd have to check if 'y' was a constructor name in scope.
02:56:31 <dcoutts> you could mark variables in patterns with something else I suppose
02:56:39 <quicksilver> you don't need to mark, you can just use scope.
02:56:46 <dcoutts> quicksilver: no, you have to be able to mask
02:56:46 <quicksilver> but it's probably convenient as I say.
02:56:52 <quicksilver> why?
02:57:36 <dcoutts> it's a fairly fundamental property of name binding, that you can have closed things with known meaning
02:58:11 <dcoutts> if every name I use is open to re-interpretation in the context I plop it into it's hard to reason about anything
02:58:53 <dcoutts> distinguishing occurrences and definitions is pretty important
02:59:10 <ToRA> dcoutts: random question - is there an easy way to specify a different ghc to the gtk2hs ./configure script?
02:59:28 <dcoutts> ToRA: yep, check ./configure --help
02:59:40 <ToRA> just did, can't see anything to do with ghc there
02:59:58 <dcoutts>   --with-hc=HC            use Haskell compiler HC
03:00:07 <ToRA> aah
03:00:10 * ToRA blind
03:00:11 <ToRA> thank-you
03:00:16 <dcoutts> np :-)
03:00:27 <quicksilver> dcoutts: Right. I stand by my point. Convenient not necessary ;)
03:00:38 <dcoutts> bah :-)
03:01:01 <quicksilver> you could, as a conveniece, say that \x was always a closed binding
03:01:10 <quicksilver> and force \y -> case y of x ->
03:01:16 <quicksilver> if you want to constructor match
03:01:20 <quicksilver> this is not a serious suggeston ;)
03:01:24 <quicksilver> just exploring the design space.
03:01:59 <dcoutts> quicksilver: \ to denote a binding is not so bad
03:02:11 <dcoutts> case foo of bar \baz ->
03:02:26 * RayNbow hates the "case of" syntax :p
03:02:47 * quicksilver nods
03:02:52 <quicksilver> overall I like capital letters more.
03:03:02 <quicksilver> cjs: does that little ramble illuminate it ?
03:03:03 <dcoutts> me too :-)
03:03:14 <dcoutts> though that's just convenience really
03:03:46 <sjanssen> I think the capital letter requirement actually increases readability
03:03:55 <dcoutts> the particular distinction I mean, we do need some distinction
03:05:13 <mm_freak_work> can i write a little wrapper function in C, which changes GMP's memory manager, does a primality check and restores it?  is that going to kill me?
03:05:14 <cjs> quicksilver, err...maybe I'll save it and read it again when I'm in a clearer frame of mind. :-)
03:05:46 <dcoutts> sjanssen: the case distinction is ok for English, it's less good for other languages
03:05:56 <sjanssen> dcoutts: yes, this is true
03:06:21 <dcoutts> I went to an interesting talk yesterday from Guy Steele about his Fortress language
03:06:41 <dcoutts> it's aimed at fortran/matlab stuff, so wants decent mathematics notation
03:06:47 <dcoutts> and they're heavily going for unicode
03:06:57 <dcoutts> and whitespace significance
03:07:08 <cjs> Actually, other languages can do better. E.g., definitions in katakana, occurrences in hiragana, and you've still got upper and lower case roman alphabets to use. Not to mention kanji.
03:07:37 <RayNbow> dcoutts: is unicode mandatory in that language?
03:07:53 <dcoutts> RayNbow: no, but people can and do use it in the libs
03:07:55 <RayNbow> because I have no idea how to input certain characters :p
03:08:08 <dcoutts> they have various input syntaxes
03:08:12 <dcoutts> some a bit like latex
03:08:22 <dcoutts> eg how whitespace is significant: { |x| | x <- xs, x | 3 }
03:08:29 <RayNbow> $\alpha^3$ stuff?
03:08:35 <dcoutts> |x| is absolute value of
03:08:44 <dcoutts> | is used for the { | } comprehension
03:08:46 <cjs> RayNbow, input is entirely orthogonal.
03:08:57 <dcoutts> and x | 3 for divisibility test
03:09:13 <quicksilver> In principle I don't like whitespace significance
03:09:22 <quicksilver> it makes the language harder to reason about and extend.
03:09:26 <dcoutts> quicksilver: it's not in our culture
03:09:33 <dcoutts> but it is in the culture of mathematics
03:09:35 <RayNbow> "x | 3" <-- I have never encountered this notation before for divisibilty test
03:09:48 <dcoutts> RayNbow: it's common in some mathematics traditions
03:09:56 <quicksilver> dcoutts: as a mathematician I'd say those are totally different symbols.
03:10:14 <pejo> Latex "code" looks like absolute crap though. Ott was designed to generate latex. But with unicode I guess more capable keyboards isn't going to be that far into the future.
03:10:17 <quicksilver> dcoutts: the norm-sign |.| is short vertical bars about the same size as the x
03:10:34 <quicksilver> dcoutts: the | meaning "such that" is a nice big one.
03:10:35 <dcoutts> quicksilver: of course they mean different things but you write them more-or-less the same way on paper
03:10:56 <quicksilver> I write them differently mostly especially if there is risk of confusing the two ;)
03:10:58 <dcoutts> quicksilver: though yes, there is sometimes a size difference
03:11:01 <quicksilver> I certainly typeset them differently.
03:11:27 <dcoutts> I think Fortress typesets them differently too
03:11:34 <dcoutts> but that doesn't help a great deal for input
03:12:04 <dcoutts> one thing I do like is they allow user-defined bracket operators
03:12:23 <dcoutts> and their operator precedence is not totally ordered
03:12:32 <dcoutts> in fact it's not even partially ordered
03:12:45 <quicksilver> yes, quasi-ordered operator precendence makes sense.
03:12:53 <dcoutts> some unrelated operators just don't have comparable recedence
03:13:03 <quicksilver> user-defined brackets are tempting but they do make the language harder to human-parse.
03:13:13 <quicksilver> x <* y >* z
03:13:20 <dcoutts> eg a /\ b + c  and  a + b > c  are fine
03:13:20 <quicksilver> are those binops?
03:13:23 <quicksilver> or a custom bracket?
03:13:37 <dcoutts> but what about a /\ b > c ?
03:13:41 <quicksilver> maybe that doesn't matter as much as I think it does.
03:14:01 <quicksilver> (lattice ordering I presume, dcoutts , but I'm just being difficult)
03:14:13 <dcoutts> quicksilver: no, that's the point
03:14:40 <quicksilver> well I'd read that as (a /\ b) > c
03:14:53 <dcoutts> so the precedence relation is not transitive
03:14:55 <quicksilver> I think you always would in a lattice context.
03:14:59 <quicksilver> but I do understand your point.
03:15:05 * RayNbow kicks mobile phone connection
03:15:09 <quicksilver> in a Bool context either way works.
03:15:28 <dcoutts> because just because /\ and + are used together in many contexts and + and > are used together doesn't mean /\ > are used together
03:15:45 <dcoutts> so they have no common well understood interpretation by humans
03:15:50 <dcoutts> so just require extra ()
03:16:20 <RayNbow> 03:09:48 <dcoutts> RayNbow: it's common in some mathematics traditions
03:16:31 <RayNbow> ^ ah, didn't know :)
03:16:39 <dcoutts> quicksilver: I'm not sure about multi-char brackets, but it's not really a problem sicne unicode has 20+ bracket pairs
03:17:33 <quicksilver> dcoutts: *nod*
03:17:36 <sjanssen> 20 brackets should be enough for anyone!
03:17:44 <quicksilver> dcoutts: TeX has a notion of character category, or somethiing
03:17:50 <quicksilver> I forget the precise terminology
03:17:53 <sjanssen> I'm not sure whether I'm sarcastic there or not
03:17:54 <quicksilver> but it's dynamic, anyway.
03:18:00 <wjt> can you put combining characters on unicode brackets? :)
03:18:39 * edwardk waves hello.
03:19:21 <quicksilver> so you can say "these symbols are binary operators, these are brakcets, etc"
03:19:28 <quicksilver> I think I'm probably too precious about the human-parsing point.
03:19:41 <quicksilver> I think it's probably more interesting, on balance, to be able to have rich syntax for DSLs.
03:23:22 * lilac can't think of any languages where whitespace isn't significant
03:24:05 <quicksilver> it's not "very" significant in most languages ;)
03:24:25 <edwardk> lilac: the SKI combinator calculus? ;)
03:25:00 <quicksilver> is it significant in Perl?
03:25:55 <edwardk> does significant count 'necessary to separate keywords'? =)
03:26:05 <quicksilver> no.
03:26:11 <edwardk> quicksilver: and since you can kludge the parser it can be
03:26:20 <quicksilver> yeah, but that's not the spirit of what I meant ;)
03:27:03 <wjt> I could have sworn that there was a PrintfType (Maybe String) instance :(
03:32:58 <RayNbow> Whitespace is significant in Whitespace
03:33:06 <RayNbow> ;)
03:56:48 <billbill1> what this error means? Instance of Integral (Maybe Int) required for definition of eval (eval is my function that returns Maybe Int)
03:57:20 <quicksilver> you're porbably trying to treat a Maybe Int as an integer in some way.
03:57:29 <quicksilver> > fromIntegral (Just 5)
03:57:39 <quicksilver> would give an error a little bit like that.
03:57:43 <lambdabot>   add an instance declaration for (Integral (Maybe t))
03:57:43 <lambdabot>     In the expression:...
03:57:52 <billbill1> http://hpaste.org/7606 this is my code
03:58:13 <quicksilver> eval env e1 + eval env e2
03:58:18 <quicksilver> you are adding two maybe Ints
03:58:21 <quicksilver> that doesn't work ;)
03:58:26 <quicksilver> > Just 5 + Just 6
03:58:27 <lambdabot>   add an instance declaration for (Num (Maybe t))
03:58:34 <quicksilver> > Just 5 `div` Just 6
03:58:34 <lambdabot>   add an instance declaration for (Integral (Maybe t))
03:58:42 <quicksilver> ^^ that's your exact error, in fact.
03:58:42 <billbill1> i see
03:58:54 <opqdonut> > let (<+>) = liftM2 (+) in Just 1 <+> Just 2
03:58:56 <lambdabot>  Just 3
03:58:57 <quicksilver> because (+) is defined on numbers
03:59:01 <quicksilver> not maybe numbers.
03:59:13 <quicksilver> fortunately there is a general technique to lift things up to maybe
03:59:18 <quicksilver> which opqdonut just demonstrated
03:59:36 <quicksilver> the thing to recognise is you have to decide what to do with, for example: Nothing + Just 5
03:59:48 <quicksilver> obviously Just 1 + Just 2 is intended to be Just 3
03:59:53 <opqdonut> that turns out Nothing with the default method
03:59:53 <quicksilver> but you have to decide about the 'Nothing' cases.
04:00:02 <opqdonut> let (<+>) = liftM2 (+) in Just 1 <+> Nothing
04:00:07 <opqdonut> > let (<+>) = liftM2 (+) in Just 1 <+> Nothing
04:00:08 <opqdonut> gah
04:00:09 <lambdabot>  Nothing
04:00:14 <RayNbow> I once created (more like a hack) a Num instance for Maybe Float
04:00:19 <RayNbow> it should be on hpaste
04:00:29 <quicksilver> billbill1: so, to fix your + line, you would probably want
04:00:36 <opqdonut> you can also use do-notation: "do x <- eval e1; y <- eval e2; return e1+e2"
04:00:43 <quicksilver> liftM2 (+) (eval env e1) (eval env e2)
04:01:08 <billbill1> i ll try it, thnx a lot
04:01:28 <opqdonut> n p
04:17:38 <cjs> Man, combinators so rock. How did I ever program without them?
04:17:43 <opqdonut> :)
04:19:37 <BMTH> Hi, i'm new to haskell and im trying to write a simple game program. I have a rough idea of what i am going to do but im not good enough to write the bulk of the code. Can somone spare a bit of their time to help me?
04:21:00 <RayNbow> cjs: I'm more interested in the question how I ever was able to program with gotos :p
04:21:08 * RayNbow looks at TI BASIC... *shudder*
04:21:19 <Beelsebob> BMTH: as with most IRC channels, you're better off asking a specific question, than asking to ask a specific question
04:23:40 <BMTH> Im sorry, but what i'm trying to do would require many questions. I thought it best to find somone who is willing to help me out in private convoes.
04:23:51 <cjs> Heh, TI BASIC.
04:23:57 <cjs> TI-99A, right?
04:24:36 <Beelsebob> BMTH: people generally don't mind lots of questions
04:26:12 <cjs> These things compose like you wouldn't believe. I spent probably two weeks, as an experienced Ruby programmer, trying to get the kind of composition in a parser that I did in three days in Haskell, while learning how to do this sort of thing in Haskell for the first time.
04:29:31 <RayNbow> cjs: I had a TI-83+
04:29:36 <RayNbow> (still have actually)
04:29:49 <RayNbow> I programmed a simple Mandelbrot fractal drawing in it
04:30:20 <RayNbow> (which was slow as hell :p)
04:30:35 <Gangrel> RayNbow: if it was slow as hell, you suck :P
04:30:46 <Gangrel> I managed one that rendered as fast as it could draw to the screen
04:31:29 <Beelsebob> but then, I became a bit of a pro at coding crazy stuff on my TI-82+
04:32:31 <RayNbow> I sorta gave up on getting serious with TI-83+ programming...
04:33:05 <RayNbow> ...after I fucked up my memory twice running Z80 asm :p
04:33:21 <quicksilver> BMTH: much better to help you out in public.
04:33:26 <Beelsebob> haha
04:33:39 <Beelsebob> I never actually started doing asm stuff
04:33:40 * RayNbow tried blitting some pixels to the screen
04:33:42 <quicksilver> BMTH: if you enter into a private conversation with someone then they may get bored, or get called away by real work.
04:33:56 <quicksilver> BMTH: here in the channel there are plenty of people who may be able to help.
04:33:58 <Beelsebob> just got really really good at optimising TI-Basic
04:34:30 <RayNbow> but I went out of bounds... and some pixels entered some other regions of the RAM :p
04:34:41 <Beelsebob> hehe
04:35:22 * RayNbow wrote 8 times as much as data as I was supposed to write :p
04:37:47 <Beelsebob> assumed it was a 16 bit screen?
04:38:17 <RayNbow> I can't remember
04:38:29 <RayNbow> but I was using some function from the ION library
04:43:28 <earthy> you could write a DSL to generate Z80 asm for your TI-83+...
04:44:03 <Beelsebob> they did
04:44:07 <Beelsebob> it was called TI-Basic
04:44:36 <earthy> Beelsebob: I meant in haskell, and then generate somewhat faster code than TI-basic code
04:44:50 <Beelsebob> hehe
04:45:19 <Beelsebob> the best bit about TI-Basic was that the only variables you had access to were A-Z
04:45:55 <Beelsebob> I used to end up storing things in matricies, and doing vector oporations on them to do multiple computations quickly
04:47:14 <earthy> ofcourse, I never had a TI-83+ or something that fancy
04:47:17 <mxc> @hoogle liftIO
04:47:18 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
04:47:32 <earthy> but I still value my TI 35+. :)
04:47:58 <Beelsebob> hehe
04:48:01 <Beelsebob> at least it was a TI one
04:48:11 <Beelsebob> I had lots of friends with Casio ones becuse they were colour
04:48:16 <Beelsebob> but the OS on them sucked in comparison
04:48:21 <earthy> should pop some new batteries in though.
04:49:06 * RayNbow has an old Casio somewhere
04:49:50 <earthy> http://www.datamath.org/Sci/Modern/TI-36SOLAR.htm was my original calculator, http://www.datamath.org/Sci/Modern/TI-35-PLUS_1.htm I still own. ;)
04:49:51 <lambdabot> Title: DATAMATH
04:50:15 <earthy> no fancy graphing or programmability
04:50:28 <earthy> it did numbers, and I was glad for it. :)
04:50:39 <Beelsebob> hehe
04:50:53 <RayNbow> http://images.google.nl/images?um=1&hl=nl&q=casio+82+sx
04:50:54 <lambdabot> Title: casio 82 sx - Google Afbeeldingen zoeken
04:50:58 <Beelsebob> my proudest program on my Ti-82+ was implementing 3D graphing on it
04:51:00 <RayNbow> anyway, gtg, byes :)
04:51:10 <cjs> I still own an HP 15C and 12C.
04:54:29 <cjs> Given a type with constructors such as 'A Int | B Int | C String', can I pattern match against return values of that type to select the Int value from any constructor '_ Int'?
04:55:30 <quicksilver> yes and no.
04:55:41 <jmg> hi
04:55:58 <quicksilver> getInt (A i) = Just i; getInt (B i) = Just i; getInt _ = Nothing;
04:56:08 <quicksilver> case getInt foo of Just i -> ....
04:56:13 <cjs> Basically, I want to process the Int value from A Int and B Int in the same way, without having to use two patterns.
04:56:29 <Beelsebob> cjs: yep, what quicksilver just proposed will do that
04:56:42 <cjs> Except I also need to process the other things in a different way.
04:56:46 <quicksilver> there isn't automatic support for case-grouping.
04:56:50 <quicksilver> But it's trivial to do by hand
04:56:51 <jmg> could anyone give me a hint how to call a custom code generator from the cabal build system?
04:56:57 <quicksilver> you just have to write a couple of helper functions.
04:57:17 <cjs> Hm. Which I have to keep updating as the type constructors change....
04:57:18 <Beelsebob> cjs: f (C s) = doom s; f x = case getInt x of Just i -> doom2 i
04:57:41 <cjs> Ah, ok, thanks Beelsebob, I get quicksilver's solution now.
04:58:04 <quicksilver> someone should write a proper case-grouping proposal for Haskell'
04:58:10 <Beelsebob> indeed
04:58:14 <quicksilver> It really ought to be fairly uncontroversial.
04:58:33 <quicksilver> except for the syntax I suppose.
04:58:36 <quicksilver> Damned syntax.
04:58:39 <Beelsebob> it needs something like an or operator in pattern matching
04:58:49 <quicksilver> yes, an or in pattern matching
04:58:53 <Beelsebob> f ((A x) | (B x)) = doom x
04:59:06 <quicksilver> and a restriction that if each group binds variables they must bind exactly the same names at exactly the same types.
04:59:14 <cjs> Well, maybe I'll just write a pretty-printer for the type; it will work better in the long run, anyway.
04:59:15 <Beelsebob> yep
04:59:17 <quicksilver> (well, or there must be a common unifier for the type)
04:59:28 <Beelsebob> oh yeh, it can be relaxed can't it
04:59:30 <Beelsebob> that works
05:00:09 <Beelsebob> quicksilver: I guess though when you get into that sort of stuff there's no reason why you can't have: f :: Eq a => a -> a -> b; f x x = "zomg, equal inputs"
05:00:36 <quicksilver> well that is qualitatively different.
05:00:45 <quicksilver> there is a difference between grouping cases which bind the same variables
05:00:51 <Beelsebob> but requires pretty much exactly the same thing to implement
05:00:51 <quicksilver> to save you naming a stupid auxiliary function
05:01:01 <quicksilver> and introducing Eq constraints.
05:01:07 <Beelsebob> true
05:01:33 <quicksilver> most of the minor front-end enhancements I'd like to see are to avoid naming things you only use once
05:01:39 <quicksilver> (or morally only once)
05:01:46 <quicksilver> r <- bar ; case r of ....
05:03:16 <mm_freak_work> hmm…  i'm sure that i can implement a modular type using the State monad, but somehow my brain is blocked
05:03:29 <mm_freak_work> what's the preferred method to do that?
05:04:03 <quicksilver> what's a modular type?
05:05:50 <mm_freak_work> sorry…  a type for modular arithmetic, which 'carries' around its modulus
05:06:06 <mm_freak_work> seems to be just the use case for the state monad
05:07:36 <mm_freak_work> i'd create a newtype Mod = Mod Integer
05:07:47 <mm_freak_work> and derive an instance Num (State Mod Integer)
05:07:53 <mm_freak_work> is my idea flawed?
05:08:10 <quicksilver> yes.
05:08:29 <mm_freak_work> could you point me into the right direction?
05:08:32 <quicksilver> I don't see why you need that to be a monad.
05:09:01 <quicksilver> you can just have data Mod = Mod Integer Integer
05:09:06 <quicksilver> (first is modulus, second is value)
05:09:09 <mm_freak_work> because the modulus should be state, so i could do something like:  runMod 7 (3 + 4 + 5)
05:09:39 <quicksilver> is it a useful thing to be able to take an abstract expression and run it in different moduli?
05:10:38 <mm_freak_work> yes, firstly it's easy to type and easier to read, secondly carrying the modulus in each variable is a hugh waste of space, especially for memory-expensive programs
05:10:54 <quicksilver> that's not what I asked.
05:10:56 <quicksilver> :P
05:11:06 <mm_freak_work> ah well =)
05:11:18 <mm_freak_work> to run it in different moduli is not the point of this
05:11:32 <quicksilver> in that case it doesn't seem much like a monad at all.
05:11:39 <mm_freak_work> the point is to specify the modulus once and then carry it around implicitly without using implicit parameters
05:11:52 <mm_freak_work> there was an excellent paper about that using the idea of state monads
05:12:12 <quicksilver> If you were to make it a monad, it sounds more like reader than state.
05:12:47 <mm_freak_work> true
05:12:48 <quicksilver> but I could certainly see it working.
05:13:10 <mm_freak_work> it works well, unless i want it to be an instance of Num
05:13:51 <mm_freak_work> (and some other classes)
05:14:15 <quicksilver> Num isn't really designed for this.
05:14:22 <quicksilver> Having said that, Num can be abused ;)
05:14:24 <quicksilver> > 3 + x
05:14:27 <lambdabot>  3 + x
05:14:37 <quicksilver> what you're talking about is not such a different abuse.
05:14:45 <quicksilver> but the Eq instances is going to be a pain.
05:15:09 <mm_freak_work> well, Num was designed for numeric types, which support ring-like features, wasn't it?
05:15:14 <mm_freak_work> Eq is easy
05:15:25 <mm_freak_work> runMod 7 (3 == 10) is going to be True =)
05:15:37 <quicksilver> that doesn't have the right type.
05:15:49 <quicksilver> (==) is oing to evaluate to Bool
05:15:51 <quicksilver> not m Bool
05:16:10 <mm_freak_work> ah…  i get what you mean
05:17:03 <mm_freak_work> but in that case, (==) takes a Mod, takes a Mod and reduces to a Mod
05:17:25 <quicksilver> you would need (==) to have the type
05:17:25 <mm_freak_work> in the paper (just search for "implicit configurations") it seemed to work well
05:17:45 <mm_freak_work> uhm…  sorry…  it of course reduces to a Bool
05:17:45 <quicksilver> (State Mod Integer) -> (State Mod Integer) -> Bool
05:17:51 <quicksilver> I don't think you can write that function.
05:18:01 <cjs> What does "No instance for (IsChar [Char])" typically mean when it complains about a printf format pattern?
05:18:08 <quicksilver> because until you decide what modulus it doesn't have a answer.
05:18:21 <quicksilver> cjs: you've managed to get [String] where you wanted String, I think.
05:18:38 <cjs> I'm just doing 'printf "op=%s,code=%s,name=%s,local=%s,isin=%s,group=%s" "" "" "" "" "" ""'
05:19:00 <cjs> Oh....
05:19:27 <cjs> You're exactly right; it was my type declaration for the function using this that was wrong. Thanks.
05:20:19 <quicksilver> cjs: FWIW I think "op=" ++ op ++ "code=" ++ code ++ "name=" ++ name
05:20:22 <quicksilver> (etc)
05:20:28 <quicksilver> looks nicer than printf format strings :)
05:20:34 <mm_freak_work> quicksilver: is there another way to remove the need for carrying the modulus around explicitly and a copy of it in each variable?
05:21:00 <mm_freak_work> quicksilver: in code it looks nicer, but did you actually evaluate it? ;)
05:21:07 <cjs> Hm. I tend to like it less, though I use it much more often.
05:21:55 <quicksilver> mm_freak_work: sure, you can do the same general trick, but just don't call it a monad ;)
05:22:06 <mm_freak_work> i like printf, where real formatting is needed, otherwise i just make use of Show
05:22:10 <quicksilver> mm_freak_work: however, you won't solve the Eq problem.
05:22:39 <mm_freak_work> quicksilver: could you give me a pointer?  or maybe a datatype to work with?
05:23:06 <quicksilver> mm_freak_work: well you have to make a deep embedding
05:23:12 <quicksilver> I.e. a whole expression tree
05:23:29 <quicksilver> because you want to delay evaluation until you later decide the modulus.
05:23:59 <mm_freak_work> hmm, good point
05:25:29 <mm_freak_work> but how can i implement state without using a monad?  the paper i'm referring to abuses some kind of 'dictionary' for that purpose
05:25:49 <mm_freak_work> class or instance dictionary of a type, IIRC
05:27:20 <quicksilver> I would do
05:27:26 <quicksilver> bah
05:27:33 <quicksilver> the point is you don't need to store the state at all :)
05:27:41 <quicksilver> you just supply it when you 'run' it.
05:27:58 <quicksilver> data ModExpr = Const Integer | Sum ModExpr ModExpr
05:28:04 <quicksilver> ^^ modulus is not even mentioned!
05:28:22 <quicksilver> run :: ModExpr -> Integer -> Integer
05:28:33 <quicksilver> run (Const n) m = n `mod` m
05:29:02 <quicksilver> run (Sum e e') m = ((run e m) + (run e' m)) `mod` m
05:33:27 <mm_freak_work> hmm
05:33:32 <mm_freak_work> interesting idea
05:33:37 <quicksilver> it's the same idea :P
05:33:41 <quicksilver> that's what the state monad does.
05:33:51 <quicksilver> the state monad doesn't store the state (while you're constructing the action)
05:34:11 <mm_freak_work> yeah, but the implementation idea is different
05:34:18 <mm_freak_work> i'll try that one…  thanks
05:34:51 <quicksilver> it's not even very different from an implementation perspective, my 'run' is just like runState.
05:35:08 <quicksilver> but I'm not making it a monad instance because I'm not sure a monad instance is a useful way to think of it :)
05:37:14 <mm_freak_work> yeah
05:37:20 <mm_freak_work> that really helps a lot…  thank you =)
05:40:49 <ski_> (.. more like `Reader', i'd say)
05:41:00 <quicksilver> yes, even more like reader.
05:41:08 <quicksilver> although a state monad where you never change the state is a lot like reader :)
05:41:27 <quicksilver> and I was using the word state because it obviously resonated with mm_freak_work's mental model.
05:43:42 <mm_freak_work> quicksilver: now i get what you mean with the (==) problem
05:45:28 <mm_freak_work> hmm
05:45:38 <mm_freak_work> that's actually very difficult =/
05:46:04 <mm_freak_work> there is no equality relation, just an equivalence relation, and it depends on the modulus
05:46:09 <quicksilver> exactly.
05:46:12 <quicksilver> these things aren't numbers yes.
05:46:18 <quicksilver> erm
05:46:21 <quicksilver> aren't numbers 'yet'
05:46:25 <quicksilver> I meant to type.
05:46:37 <quicksilver> however, you can do the same trick with (==)
05:46:42 <quicksilver> but you need to make your type a bit more complex
05:46:46 <quicksilver> (and it's not a real eq)
05:47:00 <mm_freak_work> hmm
05:47:11 <quicksilver> it's an interesting one to ponder.
05:47:15 <mm_freak_work> why does Num demand an instance of Eq and Show?
05:47:22 <quicksilver> to annoy you.
05:47:41 <quicksilver> to support pattern matching functions like f 1 = "foo"; f 0 = "bar";
05:47:53 <mm_freak_work> hmm, ok
05:48:10 <quicksilver> No idea why it requires Show.
05:48:37 <mm_freak_work> well, what would you do?  write a separate checkMod function?
05:49:08 <mm_freak_work> well, it doesn't make sense anyway
05:49:20 <mm_freak_work> that's why i saw it as a monad
05:49:36 <mm_freak_work> or at least as state
05:52:31 <opqdonut> ?mtl a->b->Either String a
05:52:31 <lambdabot> Maybe you meant: ft map msg pl unmtl url
05:52:53 <opqdonut> oh, mtl works only in the other dir :/
05:53:06 <opqdonut> ?unmtl ReaderT String (Either String)
05:53:07 <lambdabot> err: `ReaderT String (Either String)' is not applied to enough arguments, giving `/\A. String -> Either String A'
05:53:20 <opqdonut> ?unmtl ReaderT String (Either String) a
05:53:21 <lambdabot> String -> Either String a
05:57:27 <mm_freak_work> quicksilver: would you find using Ptr a good idea?
05:57:37 <quicksilver> No.
05:57:46 <mm_freak_work> i thought so =)
05:57:49 <quicksilver> using Ptr is only a good idea when interfacing to other languages.
05:57:54 <quicksilver> what were you trying to do with it?
05:58:26 <mm_freak_work> well, i can't solve the equivalence problem elegantly with the current solution…  i just don't want to encode the modulus explicitly
05:58:36 <mm_freak_work> not because it's more to type, but because it's inefficient
05:58:41 <quicksilver> I seroiusly doubt Ptr is going to help you solve it elegantly :P
05:58:54 <mm_freak_work> hehe yeah, you're totally right
05:59:46 <quicksilver> if you are even *considering* using Ptr, use IORef.
05:59:52 <quicksilver> but, equally, don't use IORef either :P
06:00:02 <ski_> quicksilver : istr seeing some argument about having `Show' in `Num' because of ease of debugging (don't need to add a `Show' constraint when you want to show the number)
06:00:13 <mm_freak_work> yeah, it wasn't a serious idea anyway =)
06:00:24 <mm_freak_work> and i'm pretty sure that there is a good pure way
06:00:54 <mauke> ski_: that doesn't make sense
06:01:16 <quicksilver> ski_: that sounds a bit daft to me :P
06:01:44 <mauke> why not add a Show constraint to Monoid? same argument, etc
06:04:58 <quicksilver> quite.
06:08:34 <wjt> Given a Parsec  Parser a, is there a straightforward way to get a  Parser (a, String)  which also returns the consumed string?
06:10:34 <wjt> hmm, i suppose it could be written as   consumed p = do { start <- getPosition; result <- p; end <- getPosition; str <- range start end =<< getInput; return (result, str) }
06:12:53 <quicksilver> I think that may be about as well as you can do.
06:13:42 <kwaazy> hey, can any1 help me with making a game in haskell please
06:14:14 <quicksilver> kwaazy: sure, ask questions and people will answer.
06:14:20 <kwaazy> kk
06:16:28 <mm_freak_work> quicksilver: i tried using the Reader monad, but it doesn't solve the problem, because of the type of (==)
06:16:39 <mm_freak_work> i guess, there is no easy way into Num =/
06:17:02 <kwaazy> im trying to make the game reversii, and im trying to write a function to place a stone color (list of lists) with an x,y co-ordinate
06:17:21 <kwaazy> i have type Coord (int,int) and type Board [[Stone]]
06:17:38 <kwaazy> and have a template of put:: Stone -> Coord -> Board -> Board
06:18:04 <zooko> Greetings, people of Haskell!
06:18:31 <kwaazy> so i want to put a new stone to the board on position x,y
06:20:08 <matthew_-> I do like how you can't ever write data Foo x = Foo x ; let f = Foo f
06:20:17 <matthew_-> but you CAN write let f = undefined :: f
06:20:51 <matthew_-> and I realise they're completely different things, but visually, if you squint a bit, they're confusingly similar
06:21:06 <BMeph> kwaazy: Just looking at that, it Cries Out to be placed in an Array, vice lists... ;)
06:21:20 <kwwaaazy> ok
06:21:38 <kwwaaazy> yeh i understand that haha, its just im soo new to haskell and came off Basic
06:21:40 <kwwaaazy> soo confusing
06:21:58 <kwwaaazy> just not sure how to implement it
06:22:02 <kwwaaazy>  put:: Stone -> Coord -> Board -> Board is all i can think of so far
06:22:05 <quicksilver> I don't really agree with BMeph
06:22:09 <quicksilver> Arrays are really ugly.
06:22:15 <mauke> you could use a Map instead
06:22:26 <mauke> that gives you easy update
06:22:35 <quicksilver> Yeah, I think a Map is the most natural notion.
06:22:42 <lilac> kwwaaazy: IIRC if your board is an Array, you can say something like "put stone coord board = board // [(coord, stone)]"
06:22:43 <quicksilver> a map from Coords to Stones
06:23:07 <lilac> :type (//)
06:23:10 <BMeph> quicksilver: I never said it was pretty, just that it's an obvious-seeming idea.
06:23:20 <kwwaaazy> ah righteo
06:23:26 <kwwaaazy> i have to use lists however
06:23:29 <mm_freak_work> matthew_-: try data Foo a = Foo (Foo a)
06:24:02 <quicksilver> win 32
06:24:30 <BMeph> But then, being used to programming in Lua, I'm still tentative in classing Arrays, Map, and "associative lists" as separate beasts. :)
06:24:59 <kwwaaazy> i want to use a list of lists
06:25:03 <BMeph> mm_freak_work: Brilliant! ;)
06:25:04 <lilac> @ty (Data.Array.//)
06:25:06 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
06:25:10 <kwwaaazy> [[Stone]]
06:25:20 <quicksilver> kwaazy: then you ahve to construct a new list based on the old ones.
06:25:28 <quicksilver> kwaazy: if it is a homework problem it's best to be upfront about it.
06:25:31 <mm_freak_work> BMeph: ?
06:25:37 <quicksilver> you will find take and drop useful.
06:25:58 <kwwaaazy> yeh its homework, but i really want to understand how it works, i dont just want some1 to spit something out
06:26:10 <kwwaaazy> really keen on this language
06:26:11 <quicksilver> (take 4 list) ++ change middle list ++ drop 5 list
06:26:23 <quicksilver> is a general pattern for changing the 'middle' of a list.
06:27:08 <kwwaaazy> what does the // do?
06:27:56 <kwwaaazy> gah
06:28:04 <kwwaaazy> hope i havent dcd again
06:28:12 <lilac> something like "let (head, (elem:tail)) = splitAt 5 list in head ++ change elem:tail"?
06:29:37 <quicksilver> yeah, that's another approach to the take/drop one.
06:29:40 <quicksilver> splitAt is handy.
06:31:08 <kwwaaazy> quicksilver: how do you construct a new list based on old ones
06:31:20 <BMeph> mm_freak_work: Just appreciating your clarification.
06:32:13 <mm_freak_work> BMeph: ah ok, you were referring to my reply to matthew_-
06:32:27 <quicksilver> kwwaaazy: well much like I showed you
06:32:30 <quicksilver> (take 4 list) ++ change middle list ++ drop 5 list
06:32:31 <mm_freak_work> uhm…  thanks hehe, i always love to be helpful =)
06:32:42 <quicksilver> kwwaaazy: or also the splitAt version lilac suggests is equivalent
06:32:52 <quicksilver> > let l = [1..9] in l
06:32:59 <lambdabot>  [1,2,3,4,5,6,7,8,9]
06:33:11 <quicksilver> > let l = [1..9] in take 4 l ++ [22] ++ drop 5 l
06:33:12 <lambdabot>  [1,2,3,4,22,6,7,8,9]
06:33:30 <kwwaaazy> ah i see
06:33:34 <kwwaaazy> wow thats clever!
06:34:57 <kwwaaazy> so in the case of stones and co-ordaintes
06:35:04 <quicksilver> you might define 'update_list'
06:35:11 <quicksilver> which replaces the nth element of a list with something else
06:35:38 <kwwaaazy> [[Dark 0,1] , [White 0,2] ... etc]
06:35:51 <kwwaaazy> thats the sorta layout i want
06:35:55 <kwwaaazy> kk
06:36:01 <quicksilver> let update_list n l x = (take (n) l) ++ x ++ (drop (n+1) l) in update_list 3 [1..9] 22
06:36:12 <quicksilver> > let update_list n l x = (take (n) l) ++ x ++ (drop (n+1) l) in update_list 3 [1..9] 22
06:36:14 <lambdabot>   add an instance declaration for (Num [t])
06:36:16 <quicksilver> bah
06:36:23 <quicksilver> > let update_list n l x = (take (n) l) ++ [x] ++ (drop (n+1) l) in update_list 3 [1..9] 22
06:36:24 <lambdabot>  [1,2,3,22,5,6,7,8,9]
06:36:26 <quicksilver> ;)
06:36:36 <kwwaaazy> your a wizard.....
06:36:45 <quicksilver> you said you wanted [[Stone]
06:36:48 <quicksilver> [[Stone]]
06:36:50 <quicksilver> list-of-lists
06:36:52 <kwwaaazy> yeh
06:36:53 <quicksilver> that's a sensible idea.
06:36:54 <kwwaaazy> exactly
06:36:56 <schme2_> Naw... ghc died :(
06:37:02 <quicksilver> but it's different from what you just showed me.
06:37:16 <kwwaaazy> it is? how should it look like
06:38:04 <eugman> F# seems to have somewhat similar syntax to haskell. What are the main differences between the two languages?
06:38:17 <mauke> impurity, strictness
06:38:25 <mauke> no type classes
06:38:31 <quicksilver> [[Dark,White,None,None,Dark,White],[None,None,Dark,White,None,None],....]
06:38:34 <orbitz> eugman: F#is mostly ocaml
06:38:36 <quicksilver> eugman: evil and good ?
06:38:38 <twobitwork> eugman: F# is modelled after ocaml
06:38:40 <quicksilver> ;)
06:38:47 <orbitz> it's syntax is erally quite different in teh end
06:39:12 <kwwaaazy> oh okay, what about the co-ordinates?
06:39:33 <eugman> k,thx
06:39:41 <orbitz> eugman: #ocaml doe exist too:)
06:39:55 <quicksilver> but mauke has the key points, impurity + strictness.
06:40:13 <quicksilver> kwwaaazy: well in thsi model of list-of-lists the coordinates are implicit.
06:40:20 <quicksilver> kwwaaazy: the coordinate si just where the thing is.
06:40:26 <orbitz> quicksilver: mauke is my hero afterall
06:40:29 * orbitz highfives mauke 
06:40:46 <mauke> aiieee
06:41:06 <orbitz> mauke: that perl iw as asking abotu? yeah i just rewrote it in python. management eb dammed!
06:41:07 <BMeph> update_board (x_coord, y_coord) board new_stone = update_list x_coord board (update_list y_coord (board !! x_coord) new_stone)
06:42:29 <orbitz> can you pattern match a function inpu and give the entire thing a name at teh same time?  for instance if i wan to do like foo (1, x) = (1, x):soemthing
06:42:43 <BMeph> Er, or something like that (only not so ugly ;).
06:42:58 <mauke> orbitz: yes, var@pattern
06:43:06 <Botje> foo pair@(1,x) = pair: ...
06:43:16 <orbitz> awesome
06:43:44 <mauke> > let foo x@y@z = [x,y,z] in foo 14
06:43:46 <lambdabot>  [14,14,14]
06:45:10 <kwwaaazy> any ideas on how i could implement it under put :: Stone -> Coord -> Board -> Board
06:51:28 <shapr> @users
06:51:28 <lambdabot> Maximum users seen in #haskell: 463, currently: 416 (89.8%), active: 14 (3.4%)
06:56:40 <shapr> @seen edwardk
06:56:41 <lambdabot> I saw edwardk leaving #haskell 1h 33m 28s ago, and .
06:57:40 <BMeph> put stone place board = update_board place board stone... ;)
06:58:05 <BMeph> shapr! 8D
06:58:44 * BMeph pulls an inflatable lambda from his pocket, looks at it, then slyly smirks at shapr...
06:58:45 <shapr> hiya BMeph
06:58:47 <shapr> Wassup?
06:59:58 <BMeph> Just saying "hi" - my home's been Internet-free for a month-and-a-half, while I argue my ISP into accepting payment... :p
07:00:25 <shapr> I've been irc free at work for several months, just decided to setup ssh today.
07:00:31 <shapr> hiya SyntaxNinja!
07:01:17 <shapr> BMeph: How's code treating you?
07:01:31 <shapr> hoi tromp
07:01:32 <BMeph> Ooh, ssh! I like it... I already have a VMWare setup for playing with Sage, that could be interesting. :)
07:01:37 <tromp> hi shae
07:01:42 <shapr> tromp: How's code?
07:02:09 <tromp> i recently wrote some nice binary lambda calculus:)
07:02:13 <ski_> mauke,quicksilver : indeed .. my memory tells me i read something like that in the mailing lists .. however, my memory could could possibly be a fault here
07:02:16 <BMeph> shapr: Code's not bad, I tossed up my first package on Hackage yesterday.
07:02:21 <schme2_> Is there some haskell for vms?
07:03:20 <shapr> tromp: Sounds cool, is it up on your playground?
07:03:22 <shapr> BMeph: What package?
07:03:32 <tromp> yes
07:03:42 <snhmib> could someone have a quick look at this to see why ghc thinks the indentation is wrong?
07:03:52 <snhmib> http://rafb.net/p/RSCHXg67.html
07:03:55 <lambdabot> Title: Nopaste - haskell indentation problem :(
07:03:55 <tromp> I was able to improve the constant in the symmetry-of-information theorem from 1876 down to 1636.
07:04:06 <snhmib> i'm not sure what's wrong with it =(
07:04:19 <BMeph> It's a Haskell version of Dominus' UDCode module that he did in perl.
07:05:02 <schme2_> snhmib: maybe (-1) ?
07:05:16 <snhmib> oh i haven't tried that one yet
07:05:22 <mauke> snhmib: is that the entire do block?
07:05:34 <shapr> tromp: I don't know the symmetry-of-information theorem.
07:06:06 <ski_> snhmib : indent the `case' branches more than the `align'
07:06:25 <snhmib> no there's some stuff after it
07:06:47 <shapr> Ah, I see. Citeseer says it's related to Kolmogorov complexity.
07:06:53 <tromp> it says that x has as much information about y as y has about x
07:07:34 <tromp> where information x has about y is formalized as K(y)-K(y|x)
07:07:58 <quicksilver> snhmib: as ski says, the problem is the "let" block.
07:08:18 <quicksilver> snhmib: "let" is layout aware like case.
07:08:49 <tromp> Thorsten's evaluator is quite cute
07:10:29 <BMeph> Weird - my company 'Net filter thinks your site is porn, tromp... =8*O
07:12:14 <snhmib> where can i find the rules for indentation?
07:13:11 <mauke> @where report
07:13:11 <lambdabot> http://www.haskell.org/onlinereport/
07:13:27 <quicksilver> snhmib: they're simpler to explain than to read in the report.
07:13:28 <quicksilver> probably.
07:13:47 <quicksilver> snhmib: quite simply when you're in a layout block, anything which starts to the left of that column ends the block.
07:14:15 <quicksilver> snhmib: -1 was to the left of the column for the let-block.
07:14:27 <quicksilver> snhmib: so it ended the let-block (and thus the case-block which is inside it)
07:14:32 <quicksilver> and that's a syntax error
07:14:37 <quicksilver> the case-block wasn't ready to end.
07:15:53 <snhmib> oh ok thanks all =)
07:16:21 <BeelsebobWork> snhmib: if you watch football, think about it as being offside -- if you're ahead of all the defenders, you can't do anything
07:17:00 <snhmib> heh
07:19:22 <quicksilver> snhmib: I find with kuribas' enhanced emacs mode indentation is very painless indeed :)
07:23:51 <Arnar> quicksilver: link?
07:24:13 <smg> emacs? vi(m)!
07:24:14 <smg> :)
07:24:32 <quicksilver> @where kuribas-indentation
07:24:32 <lambdabot> I know nothing about kuribas-indentation.
07:24:32 <Arnar> I keep switching back and forth between vim and emacs
07:24:34 <Arnar> :)
07:24:40 <quicksilver> @where haskell-indentation
07:24:41 <lambdabot> I know nothing about haskell-indentation.
07:24:42 <quicksilver> bah!
07:25:06 <Arnar> smg: the scripts section on the vim site has a very good indent script for haskell
07:25:27 <Arnar> smg: I recommend the extended highlight script too.. highlights stuff from prelude
07:25:27 <quicksilver> Cale: where did the @where Db go?
07:25:41 <smg> Arnar: ty
07:25:44 <quicksilver> @where+ kuribas-indentation http://kuribas.hcoop.net/haskell-indentation.el
07:25:45 <lambdabot> Done.
07:25:50 <quicksilver> Arnar: there ;)
07:25:55 <Arnar> quicksilver: thanks :)
07:28:10 <SyntaxNinja> hi shapr
07:30:26 <shapr> @yow !
07:30:27 <lambdabot> The FALAFEL SANDWICH lands on my HEAD and I become a VEGETARIAN ...
07:34:57 <shapr> @quote
07:34:58 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
07:44:00 <SamB> sweeeet
07:44:08 <SamB> someone restored the quote database?
07:44:21 <quicksilver> yes, for some value of restore
07:44:25 <quicksilver> @quote stereo
07:44:26 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
07:44:31 <quicksilver> not that old :)
07:47:00 <Jaak> > map (:[{- nom nom nom -}]) [1..3]
07:47:01 <lambdabot>  [[1],[2],[3]]
07:49:25 <opqdonut> :P
07:55:27 <sjw> anyone have experience using hGetContents on a pipe?
07:56:43 <quicksilver> sjw: no, I avoid hGetContents. But I understand pipes. What appears to be the trouble?
07:56:56 <sjw> quicksilver: laziness :)
07:57:03 <sjw> I want to read XML output from a process
07:57:27 <sjw> interactively
07:57:41 <sjw> so I send a query, read some XML, send a query ...
07:57:55 <quicksilver> ah
07:57:56 <quicksilver> give up
07:57:57 <quicksilver> stop there
07:58:06 <quicksilver> don't even THINK of using hGetContents for anything interactive.
07:58:36 <sjw> I wouldn't, except Parsec et al. don't seem to support inner monads for the token stream
07:58:49 <sjw> (nor does HaXML which is what I am using)
07:59:03 <quicksilver> once you've totally flushed that evil notion from your mind....
07:59:05 <earthy> and that is a problem why?
07:59:13 <quicksilver> there are some basic problems with interactive programs.
07:59:36 <sjw> quicksilver: I was more hoping than expecting that it would work
07:59:39 <earthy> I mean, if you can truly do it interactively, you can either a. keep things in memory
07:59:47 <mm_freak_work> sjw: hGetContents on sockets works well, but i strong suggest not using it for anything serious
07:59:56 <earthy> or b. figure out how to do the I/O nicer than with hGetContents
08:00:00 <mm_freak_work> if it works on sockets, it also works on pipes
08:00:06 <earthy> b. is only needed if a. doesn't work out
08:00:27 <sjw> earthy: I don't know how much to read, it is only 1 XML element
08:00:49 <sjw> so really you want the XML parser to read chars in monadically
08:01:21 <earthy> um... so there's no clear 'end of interactive input' marker?
08:01:27 <sjw> nope
08:01:31 <quicksilver> right.
08:01:36 <earthy> so how does your thing interact?
08:01:37 <quicksilver> that's what I was about to type.
08:01:39 <sjw> well, there is <start> ... </start>
08:01:46 <earthy> good! :)
08:01:47 <quicksilver> this is the fundamental problem with interactive programs.
08:01:53 <quicksilver> how do you know when the interaction is over?
08:02:01 <sjw> where start can be any number of things
08:02:14 <earthy> oh. that's a bit of a pity
08:02:23 <sjw> quicksilver: so this thing is essentially a pretty printer for Coq terms
08:02:49 <sjw> you give it a document, it replaces things like @{print nat} with pretty printed latex
08:03:02 <quicksilver> so what you really want to do is incrementally parse "1 single XML element"
08:03:08 <quicksilver> (which may contain lots of stuff inside)
08:03:12 <sjw> yup
08:03:15 <quicksilver> and that's your unit of response.
08:03:26 <earthy> sjw: you could look at uulib's parsing combinators
08:03:27 <quicksilver> if you're very careful, hGetContents might work.
08:03:35 <quicksilver> but you have to understand how parsec/haxml work
08:03:40 <sjw> quicksilver: If it did, I wouldn't be here :)
08:03:42 <quicksilver> do they try to read past that last newline?
08:03:44 <earthy> they allow you to make your own instances of the required tokens typeclass
08:03:49 <earthy> and those can be monadic
08:03:54 <quicksilver> if they don't try to read beyond the end of the element
08:04:06 <quicksilver> then they won't cause a block
08:04:20 <quicksilver> you need to make sure appropriate buffering, of course.
08:04:25 <quicksilver> either line buffering or no buffering.
08:04:40 <quicksilver> line buffering is typical for interactive protocols which are often line based
08:04:44 <sjw> the problem I get is that when I stick in a debug print, it works
08:04:47 <quicksilver> if you buffer too much you deadlock.
08:04:53 <quicksilver> sounds like buffering then?
08:04:58 <sjw> when I remove it, I get *** Exception: Ran out of input (EOF)
08:05:16 <mm_freak_work> quicksilver: hGetContents is a hazard…  i've just read in the documentation that it silently ignores all errors
08:05:17 <sjw> line buffering should more or less work
08:05:23 <quicksilver> mm_freak_work: correct. I never use it.
08:05:24 <mm_freak_work> really…  i wouldn't even use it for experiments
08:06:03 <quicksilver> sjw: what you *really* want is an incremental parser
08:06:08 <quicksilver> which you can feed input to line by line
08:06:15 <quicksilver> and it will tell you when it has slurped a whole element :)
08:06:19 <geezusfreeek> wait, silently ignores? i thought it threw exceptions…
08:06:20 <quicksilver> I'm not sure if such things exist.
08:06:22 <quicksilver> malcolmw: ?
08:06:46 <mm_freak_work> geezusfreeek: according to the docs, it doesn't…  it closes the semi-closed handle and terminates the list
08:06:58 <sjw> I suppose I could do something evil with hReady
08:07:13 <mm_freak_work> so errors are indistinguishable from EOF
08:07:15 <sjw> quicksilver: hence my comment about parsec not having an inner token stream monad
08:07:29 <quicksilver> sjw: yeah, but that's not the way I'd want it to be
08:07:36 <quicksilver> inner monads sounds like pointless complexity.
08:07:45 <quicksilver> I'd just want it to accept input chunk by chunk
08:07:57 <quicksilver> and tell me when it has (or has not) parsed the thing I asked it to parse
08:08:00 <sjw> and return Either Cont a
08:08:40 <geezusfreeek> i can't think of anything that would go wrong from using hGetContents on, say, /dev/urandom or something
08:09:09 <sjw> I don't really see a problem when using it for reading a plain file
08:09:13 <mm_freak_work> geezusfreeek: you might get less entropy that you would expect
08:09:24 <geezusfreeek> mm_freak_work: that is besides the point :P
08:09:31 <malcolmw> quicksilver: incremental, like polyparse, you mean?
08:09:47 <mm_freak_work> geezusfreeek: why?  it would be "something wrong" =)
08:10:05 <geezusfreeek> but not due to using hGetContents
08:10:29 <mm_freak_work> due to not handling errors, reopening and reading more of /dev/urandom
08:10:43 <shapr> Incremental reading from a file can cause weirdness if the file gets changed between reads. Haskell expects a purely function filesystem :-)
08:11:25 <sjw> shapr: in this case the file is more or less lazy ...
08:11:34 <sjw> being the output from a process
08:11:43 <quicksilver> malcolmw: I don't know.
08:11:52 <quicksilver> malcolmw: I mean the ability to send it chunk by chunk
08:12:03 <quicksilver> malcolmw: and it will tell me if it's completed the non-terminal I first asked for.
08:12:38 <geezusfreeek> woah, i had never noticed the interact function before
08:12:39 <Saizan> quicksilver: there's a version of binary's Get monad like that floating around somewhere
08:12:46 <geezusfreeek> that looks terrible
08:12:50 <malcolmw> quicksilver: what is this "chunk-by-chunk"?  isn't it just a lazy stream, whose tail is not yet known?
08:13:09 <quicksilver> malcolmw: maybe, yes. But I don't want to use a lazy stream.
08:13:16 <quicksilver> malcolmw: I want to set you strict chunks of data.
08:13:30 <quicksilver> malcolmw: and get an error reported immediately if what I've sent is not a valid partial parse.
08:13:34 <sjw> quicksilver: I don't really care if the stream is lazy ...
08:13:38 <quicksilver> and an indicator if it is now 'complex'
08:13:40 <quicksilver> erm
08:13:42 <quicksilver> 'complete'
08:14:11 <malcolmw> then you are going to need something that can convert your chunks back into a stream of tokens I reackon
08:15:01 <quicksilver> I think I'm failing to communicate but alas I don't have time right now to explain it better.
08:15:25 <sjw> malcolmw: I am trying to get HaXML to talk to a process (reading)
08:16:08 <sjw> unfortunately, interaction between output and input (via hGetContents) is giving strange behaviours
08:17:35 <malcolmw> sjw: presumably the socket you are reading from is buffered or something?
08:17:44 <chessguy> @type hGetContents
08:17:46 <lambdabot> Not in scope: `hGetContents'
08:18:02 <quicksilver> sjw: yes, I did say at the beginning of this conversation to make sure you were using line buffering.
08:18:16 <quicksilver> sjw: you also need to be aware of the possibility that the far end of the pipe is itself buffering.
08:18:21 <quicksilver> there's not a lot you can do about that.
08:18:22 <sjw> malcolmw: the problem isn't that the thing is hanging --- there is more input after the current element
08:18:34 <sjw> it is that it gets an exception
08:19:17 <sjw> the handles are from runInteractiveProcess
08:19:48 <malcolmw> I've heard of lots of bugs in ghc's process IO library that could be responsible
08:19:54 * edwardk waves hello.
08:20:16 <sjw> ah
08:20:22 * sjw changes to NoBuffering
08:20:55 <sjw> nope
08:20:59 <quicksilver> sjw: it may not help if the far end has Buffering on ;)
08:21:17 <quicksilver> unfortunately the standard behaviour of standard IO libs is to Buffer if not connected to a tty.
08:21:27 <Vulpyne> Why not read with something other than hGetContents?
08:21:27 <sjw> quicksilver: sure, but buffering would cause it to hang waiting for input, but that isn't the case
08:21:34 <quicksilver> so many programs behave this way, if not explicitly written not to.
08:21:38 <quicksilver> true.
08:21:50 <quicksilver> I agree what you're describing doesn't seem to be consistent with a buffering deadlock.
08:22:45 <malcolmw> buffering can also cause the reader of pipe to believe the pipe is empty, when it isn't
08:23:56 <quicksilver> malcolmw: but hGetContents just uses reads, which should block.
08:24:00 <quicksilver> malcolmw: I believe.
08:24:09 <shapr> edwardk: Dude, let's go to lunch.
08:24:17 <quicksilver> malcolmw: you'd expect hGetContents to block and not to return EOF.
08:25:05 <malcolmw> that's what you would expect, but I'm sure I've seen bug reports indicating otherwise
08:26:08 <sjw> ugh
08:26:13 <sjw> it is definately laziness related
08:26:48 <sjw> I have >     ; let (rv, hout') = xmlParseWith prolog hout
08:26:49 <sjw> >     ; let pl = either error id $ rv
08:26:49 <sjw> >     ; pl `seq` return ()
08:26:49 <sjw> >     ; let (rv', hout'') = xmlParseWith element hout'
08:26:49 <lambdabot>  Parse error at ";" (column 1)
08:26:49 <lambdabot> Unbalanced parentheses
08:26:49 <lambdabot>  Parse error at ";" (column 1)
08:26:51 <sjw>  
08:26:54 <sjw> whoops
08:27:04 <sjw> anyway, without the seq, it breaks
08:27:05 <geezusfreeek> you hurt lambdabot
08:27:08 <sjw> with the seq, it works
08:27:27 <JaffaCake> malcolmw: I haven't been following the discussion, but anything I can help with?
08:27:48 <WebGuest> hi there..
08:27:54 <WebGuest> i need help on haskell
08:28:07 <WebGuest> i just a begginer to tht..
08:28:15 <WebGuest> anyone here could help?
08:28:35 <malcolmw> JaffaCake: it's not me that has the problem (today), it's sjw
08:29:40 <WebGuest> i have question here ...
08:29:59 <sjw> JaffaCake: seq of operations : runInteractiveProcess, turn output handle into String with hGetContents, write to input handle, read from string, read from string
08:30:04 <sjw> WebGuest: ask away ...
08:30:22 <sjw> if I force the results of the first read, things occur as expected
08:30:33 <WebGuest> type Line	=  String
08:30:52 <JaffaCake> sjw: typically you need to use threads to do that
08:30:52 <sjw> if I don't, I get an exception (EOF)
08:31:39 <quicksilver> JaffaCake: what does seem a bit odd is surely hGetContents should never return EOF on an open pipe?
08:31:52 <quicksilver> JaffaCake: surely hGetContents should block (which might deadlock sjw's program)
08:31:58 <quicksilver> JaffaCake: but not return EOF...
08:32:10 <quicksilver> when I say 'return' I mean 'raise exception'
08:32:16 <JaffaCake> well true, hGetContents doesn't normally raise an exception
08:32:23 <JaffaCake> that does sound bogus
08:32:39 <ski_> WebGuest : yes, what about that ?
08:32:43 <quicksilver>  *** Exception: Ran out of input (EOF)
08:32:48 <quicksilver> is what he reports seeing
08:33:04 <JaffaCake> I don't recognise "Ran out of input", that sounds like it came from the program
08:33:17 <WebGuest> i created a function call menu :: IO()
08:33:17 * sjw greps HaXML source ...
08:33:31 <quicksilver> JaffaCake: could hGetContents be finishing early with [] ?
08:33:42 <quicksilver> that also sounds bogus! I'm sure it's supposed to block :)
08:33:50 <WebGuest> how could i using this to call another funtion with the funtion of splitWords :: Line -> [Word]
08:33:53 <quicksilver> unless the subprocess is actually dying.
08:33:57 <JaffaCake> it should block if the pipe is still open, yes
08:34:00 <geezusfreeek> that would say broken pipe
08:34:02 <quicksilver> maybe the subprocess is dying from SIGPIPE
08:34:19 <geezusfreeek> oh wait
08:34:22 <ski_> WebGuest : maybe it would be better if you paste your current code at a paste service ?
08:34:24 <quicksilver> if the subprocess gets SIGPIPE and dies does the owning process get []?
08:34:25 <ski_> @paste
08:34:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:34:34 <geezusfreeek> yeah it's silent on failure, as documented, then there would be no distinguishable difference
08:34:43 <JaffaCake> quicksilver: yes, I think so
08:34:55 <sjw> but why would seq affect that ?
08:35:08 <quicksilver> well changing the order of IO operations can make a big difference.
08:35:10 <geezusfreeek> force it to happen sooner?
08:35:27 <quicksilver> I can't think why the subprocess would SIGPIPE though
08:35:37 <quicksilver> unless it's printing something to stderr which you aren't consuming.
08:35:42 <WebGuest> sjw: just pasted..
08:36:01 <sjw> WebGuest: what is the URL?
08:36:12 <ski_> http://hpaste.org/7615
08:36:42 <WebGuest> yes ski
08:36:44 <WebGuest> u r right
08:38:00 <ski_> try changing `putStrLn doc' into `print (splitWords doc)' ?
08:38:03 <mm_freak_work> hmm…  somehow prolog is a nice language, too
08:38:22 <ski_> (or possibly with `mapM_ putStrLn' instead of `print')
08:38:29 <sjw> quicksilver: maybe, but I somewhat doubt it ...
08:38:50 <ski_> mm_freak_work : hmm ?
08:39:59 <malcolmw> hmm, yes "ran out of input (EOF)" is a message from polyparse's "next" combinator
08:40:00 <mm_freak_work> well, haskell seems to have a few things in common with prolog, so i'm currently reading a prolog tutorial
08:40:06 <sjw> hmmm, how about this: the program gets killed before the output is forced
08:40:18 <quicksilver> how does the program get killed?
08:40:22 <sjw> I kill it :)
08:40:23 <ski_> mm_freak_work : #prolog might also be handy, btw ..
08:40:34 <WebGuest> u r the man ski_
08:40:35 <WebGuest> is work
08:40:36 <quicksilver> sjw: you kill the program before you finish consuming the data? :P
08:40:38 <WebGuest> thanks a lot
08:40:39 <quicksilver> sjw: yes, that would do it :P
08:40:40 <sjw> terminateProcess
08:40:41 <WebGuest> :)
08:40:47 * quicksilver slaps sjw
08:40:51 <sjw> quicksilver: um, well, not really
08:40:52 <ski_> WebGuest : you can also write like this
08:40:53 <quicksilver> you could have told us that bit before ;)
08:41:03 <sjw> so it gets opened, read, then killed
08:41:22 <ski_>   doc <- getLine
08:41:26 <ski_>   let words = splitWords doc
08:41:27 <ski_>   print words
08:41:30 <mm_freak_work> ski_: i wasn't going to ask a question, just looking for other opinions =)
08:41:47 <ski_> WebGuest : so you can name the intermediate result(s) if you want
08:41:50 <dejones> JaffaCake, quicksilver: http://www.google.com/codesearch?hl=en&q=+%22ran+out+of+input+(EOF)%22&sa=N&filter=0
08:41:51 <lambdabot> Title: "ran out of input (EOF)" - Google Code Search, http://tinyurl.com/5bxhlz
08:41:58 <ski_> mm_freak_work : yes
08:42:05 <malcolmw> quicksilver: sjw: the EOF message will be raised into an exception somewhere in polyparse
08:42:08 <quicksilver> sjw: yes, but remember haskell is a lazy language.
08:42:12 <sjw> sure
08:42:15 <quicksilver> sjw: "read" doesn't do anything.
08:42:17 <dejones> JaffaCake, quicksilver: it seems it's related to parsing.
08:42:29 <dejones> malcolmw: it seems we found the same info at the same time.  ;)
08:42:30 <quicksilver> so you don't actually consume the data until after the process is dead
08:42:38 <quicksilver> that certainly seems to explain it.
08:42:44 <quicksilver> and it explains why your seq fixes it.
08:42:59 <quicksilver> I think this is a great example of why hGetContents is dangerous, myself.
08:43:00 <sjw> quicksilver: sort of
08:43:09 <sjw> the seq is on the first read, not the second
08:44:18 <WebGuest> ski_: THanks so much for ur suggestion..
08:44:27 <ski_> yw
08:44:30 <WebGuest> i shld visit this forum early..
08:44:41 <dejones> quicksilver: why is hGetContents dangerous?  I just came in on this convo...
08:45:31 <Saizan> dejones: because the side effect of reading from the Handle is not completed before it "returns"
08:46:11 <quicksilver> dejones: in this particular example it was dangerous because once finished reading, the program killed the subprocess which generated the output.
08:46:12 <sjw> I suppose I was assuming that terminateProcess was a little more magic than it is
08:46:35 <quicksilver> however, because of the bizarrely interleaved way hGetContents does IO
08:46:45 <ski_> (this is just `IO' ..)
08:46:47 <quicksilver> the author of the code couldn't see without knowing the insides of his parsers
08:46:59 <quicksilver> whether it forced enough to consume the whole stream
08:47:02 <quicksilver> before the kill went through.
08:47:04 <quicksilver> ski_: ?
08:47:37 <ski_> i meant that this is just the nondeterministic part of `IO'
08:48:07 <WebGuest> ski_: how could then read the text file and process it by using splitWords function?
08:48:27 <Saizan> the IO monad is supposed to sequentialize my side effects, no?
08:48:45 <ski_> Saizan : `forkIO'
08:48:50 <sjw> quicksilver: it probably won't be an issue in real code, as it would force the value before exiting anyway
08:49:08 <quicksilver> ski_: well I meant the way hGetContents hides the non-determinism of IO inside an object of type 'String'
08:49:10 <Saizan> ski_: yeah, the thread is spawned before forkIO returns :)
08:49:20 <quicksilver> ski_: which does not claim to be a non-deterministic object.
08:49:23 <ski_> WebGuest : just read the file into a string, and process that string as usual with `spitWords'
08:50:59 <sjw> quicksilver: thanks ... it was the SIGPIPE that figured it out for me
08:51:23 <ski_> Saizan : and the new thread is not sequentialized wrt to the old one
08:51:53 <quicksilver> sjw: glad you worked it out in the end.
08:52:21 <Saizan> ski_: ok, but that new thread is not even part of the current "do-block" is not connected with the rest of the computation by >>=, so it's not relevant
08:53:16 <ski_> quicksilver : more or less what i mean is, from one point of view `unsafeInterleaveIO' nondeterministically chooses a time to execute the action (in some way comparable to thread scheduling), and just returns the thunk that will evaluate to the value
08:53:36 <quicksilver> ski_: yes, definitely.
08:53:39 <sjw> quicksilver: using hGetContents is a little dirty, but unless malcolmw wants to hack HaXML so that token state is monadic, I am stuck
08:53:43 <Saizan> ski_: we can have more than one "control flow", the point of IO is also to ensure the order of events within one, i'd say
08:54:05 <quicksilver> sjw: I vent my frustration periodically partly just to stir debate.
08:54:13 <ski_> quicksilver : otoh, if we want to reason more specifically about *if* and *when* the action actually gets executed, we must drag in operational semantics of thunks .. which is where the problems appear .. yes ?
08:54:42 <quicksilver> sjw: I think that hGetContents is more harmful than people generally admit/agree.
08:54:48 <sjw> quicksilver: unfortunately, there is no nice fix to the broken DTD I have to live with, but that isn't Haskell's fault
08:54:54 * dcoutts_ loves hGetContents
08:54:55 <quicksilver> ;)
08:55:07 <dcoutts_> though I would make it throw exceptions rather than just finishing []
08:55:09 <quicksilver> dcoutts: I don't actually think it's a bad thing, although I sometimes pretend to for effect.
08:55:11 <ski_> Saizan : `(>>=)' is one combinator, `forkIO' is another, i don't see the difference (in this context)
08:55:24 <vixey> harmfulGetContents
08:55:29 <quicksilver> dcoutts: I *do* think its limitations and issue need to be documented more "loudly"
08:55:35 <dcoutts_> quicksilver: aye
08:55:36 <malcolmw> sjw: monadic stateful lexing, ugh.
08:55:38 <quicksilver> dcoutts: and that perhaps it's not really to be encouraged as a standard API.
08:55:49 <quicksilver> dcoutts: more of an "advanced API which is very clever but has some caveats"
08:55:52 <sjw> dcoutts_: SIGPIPE would have been more enlightening
08:56:01 <malcolmw> lexing = regular expressions = state-free
08:56:07 <quicksilver> malcolmw: lazy streams = ugh.
08:56:13 <quicksilver> ;)
08:56:24 <dcoutts_> sjw: right, it's just that way because H98 didn't have exceptions from pure code, so hGetContents could not throw an exception
08:56:27 <quicksilver> you don't need to support monadic token streams though.
08:56:30 <sjw> malcolmw: OK, but if you want to read from a stream, which I assume people do with SOAP et al ...
08:56:32 <quicksilver> just a left-fold enumerator.
08:56:38 <dcoutts_> sjw: Data.ByteString's hGetContents does throw exceptions
08:56:59 <malcolmw> I don't actually understand what was broken yet
08:57:03 <sjw> dcoutts_: it all comes back to ByteString with you and dons :)
08:57:09 <dcoutts_> heh heh
08:57:23 <WebGuest> ski_ : i hving problem in read the file into a string
08:57:31 <WebGuest> how could i do tht? :(
08:57:31 <sjw> malcolmw: I was terminating the program before forcing the return value of the parser
08:57:56 <ski_> quicksilver : hm .. if `hGetContents' were guarranteed to get the contents of a file at *execution*time* of the `hGetContents' call, then some of the problems would go away, yes ? .. however, the problem is that this can't in general be done with pipes and sockets and whatnot .. i.e. an abstraction leak
08:58:00 <sjw> so I suppose you could say 'dont do that'
08:58:01 <malcolmw> sjw: PEBKAC?
08:58:09 <Saizan> ski_: essentially that the result of forkIO doesn't depend on the effects performed by the new thread
08:58:12 <ski_> WebGuest : try `readFile' ?
08:58:44 <sjw> malcolmw: well ...
08:58:47 <quicksilver> malcolmw: he was misuing hGetContents, not understand the caveats of it.
08:59:02 <quicksilver> malcolmw: in particular he didn't realise that TerminateProcess isn't magik w.r.t hGetContents.
08:59:13 <quicksilver> not entirely unreasonable to imagine it might be, IMO.
08:59:35 <dcoutts_> quicksilver, malcolmw: it's a mismatch between pull/push styles
08:59:41 <quicksilver> dcoutts_: yes.
08:59:47 <sjw> it comes back to the evilness of implicit state
08:59:57 <quicksilver> quicksilver: hence my suggestion of a left-fold enumerator for the parsing libraris
08:59:58 <vixey> @brain
09:00:00 <lambdabot> I think so, Brain, but Lederhosen won't stretch that far.
09:00:02 * malcolmw always thinks of I/O like unix pipes - you kill the writer, then the reader receives zip
09:00:07 <quicksilver> dcoutts_: which would give one way to invert that
09:00:31 <dcoutts_> when you've got some IO source, you want to pull data from the file and push it into the parser and know when you're done with the file
09:00:53 <dcoutts_> but parsers are usually structured as 'pull' on some pure source
09:01:35 <sjw> dcoutts_: exactly
09:01:53 <dcoutts_> it requires the parser to be structured using continuations or something
09:01:57 <malcolmw> that's an alien concept to me
09:02:25 <dcoutts_> so that you give it some input, it does some work and comes back to you and says it needs more
09:02:29 <quicksilver> yes
09:02:32 <WebGuest> ski_: i hv this with me. .http://hpaste.org/7616
09:02:32 <quicksilver> or says it's done
09:02:38 <dcoutts_> quicksilver: right
09:02:40 <quicksilver> or says "that's deifnitely an error, don't even bother to give me more"
09:02:55 <dcoutts_> basically as an unfold rather than a fold
09:02:57 <ski_> WebGuest : next time, try "annotate" the paste
09:03:29 <BMeph> BRB, rebooting the comp.
09:03:33 <malcolmw> dcoutts_: eek, all that plumbing! how horrible
09:03:41 <dcoutts_> malcolmw: not necessarily
09:03:49 <dcoutts_> malcolmw: it can all be hidden in a cont monad
09:04:01 <ski_> (WebGuest : or .. maybe not, if this was not directly related to your earlier question)
09:04:32 <WebGuest> ski_: is do relate to my earlier question
09:04:55 <WebGuest> simply now.. i would like to store some word in a text file
09:05:01 <dcoutts_> malcolmw: it's buried in the get action in the parser monad
09:05:08 <WebGuest> now i would like to read and process it using splitWords
09:05:15 <WebGuest> and display it..
09:05:17 <quicksilver> malcolmw: I don't think you need to add much pluming at all.
09:05:20 <dcoutts_> malcolmw: getToken or whatever
09:05:28 <ski_> WebGuest : http://hpaste.org/7616#a1
09:05:32 <quicksilver> malcolmw: it's just instead of your parsers "returning" what they parsed
09:05:40 <quicksilver> malcolmw: they return one of three things:
09:05:42 <malcolmw> well, I suppose the parsing monad already has 'next' which is like 'get'
09:05:43 <quicksilver> an actual result
09:05:52 <quicksilver> "please give me more" (with a continuation)
09:05:55 <quicksilver> "that is an error"
09:06:08 <quicksilver> the 'continuation' is a partially applied parser, in some sense.
09:06:13 <quicksilver> which you can give more stuff too.
09:06:30 <malcolmw> who does the giving more stuff though?
09:06:36 <dcoutts_> malcolmw: the caller
09:06:40 <quicksilver> data Parser a = Success a | Error err | NeedMore (String -> Parser a)
09:06:47 <dcoutts_> malcolmw: they have to use it in an unfold
09:06:50 <quicksilver> really (String ->) should be (toks -> )
09:06:50 <malcolmw> but that's the plumbing that ought to be hidden...
09:07:06 <dcoutts_> malcolmw: and it's easy to convert that api to the lazy list [a] ->  style
09:07:12 <dcoutts_> malcolmw: by using an unfold
09:07:27 <sjw> how do you go with backtracking?
09:08:13 <WebGuest> ski_: i got what i need today..
09:08:21 <ski_> fine
09:08:26 <WebGuest> thanks again.. and hv a nice day
09:08:51 <quicksilver> erm
09:08:52 <ski_> WebGuest : and don't mix tab-indentation with space-indentation
09:08:58 <quicksilver> s/Parser/ParseResult/
09:09:02 <quicksilver> in my example.
09:09:08 <WebGuest> ski_: noted..
09:09:09 <quicksilver> This doesn't affect parser construction at all
09:09:22 <quicksilver> you can still use whatever monadic or non-monadic combinators you like to build the parsers.
09:09:30 <quicksilver> it just affects your 'runParser' method.
09:09:47 <quicksilver> you would provide variations on 'runParser' for more-or-less complex approaches
09:11:11 <ski_> type Parser a = toks -> ParseResult a  -- ?
09:11:47 <quicksilver> well that's a very concrete view of a parser, yes.
09:11:54 <quicksilver> or do I mean very abstract.
09:11:59 <quicksilver> I'm never sure with those works.
09:12:03 <quicksilver> it's one view, anyhow :)
09:14:48 <dcoutts_> I'd mostly ignored continuations for years, the textbook examples I've seen are pretty pointless
09:14:55 <dcoutts_> and CPS style isn't lovely
09:15:03 <xif> yeah
09:15:03 <dcoutts_> but there are a few killer applications
09:15:16 <xif> Continuations have some very good uses, but they don't commonly occur.
09:15:19 <ski_> quicksilver : `shallow' (as opposed to `deep') (if i don't confuse them)
09:15:31 <dcoutts_> and hiding them in monads where you don't have to look at the types is a very good approach imho
09:16:32 <dcoutts_> the ml/scheme/lisp people have been looking at continuations for longer
09:16:50 <dcoutts_> probably because they do not have laziness as an advanced control structure
09:17:37 <dons> oh, that's a good reason.
09:18:02 <ski_> hm, push vs. pull is related to external vs. internal iterator ?
09:18:06 <sjw> dons: hi
09:18:21 <sjw> continuations hurt my brain at 2am ...
09:18:47 <dcoutts_> dons: when I next look at binary, I want to look at doing Get on a cont style, and also for error handling
09:19:26 <dcoutts_> dons: for the nextChunk monad primitive
09:21:51 <dons> isn't Get already really fast?
09:21:56 <dcoutts_> yes
09:21:59 <dons> it's Put we need to improve :)
09:22:13 <dcoutts_> I did some work on that that never got integrated
09:22:18 <dons> but yeah, i think there's room to look at this stuff again.
09:22:33 <dcoutts_> dons: but the point is it's a feature, hopefully one with low perf cost
09:22:58 <dcoutts_> dons: it'd eliminate the need for that binary-strict package
09:23:03 <dons> ah
09:23:14 <s_clv> There once was a haskell coder / who was quite the linguistic promoter / till he met an impure young lass / who inspired thoughts most crass / and type safety be damned, he unsafe IOed her.
09:23:15 <dcoutts_> and possibly also give us decent error/decoding handling
09:23:43 <dcoutts_> dons: possibly even get-what-you-pay-for alternative backtracking
09:24:10 <dcoutts_> ie if you don't use it, then it's no extra cost
09:24:14 <ddarius> ski_: Related, but not inextricably bound.
09:26:17 <quicksilver> s_clv: the 3rd and 4th lines don't scan in the traditional way. But that was still a good effort :)
09:28:50 <shapr> edwardk: yarr!
09:28:52 <shapr> @quote
09:28:53 <lambdabot> samc says: monads are hard, let's go shopping
09:28:55 <shapr> yay!
09:28:59 <ddarius> heya shapr
09:29:03 <shapr> Hiya!
09:29:21 <Vulpyne> Consultant Barbie? Is that you?
09:29:25 <opqdonut> @quote
09:29:26 <lambdabot> therp says: good morning. I think I have been dreaming of shift/reset continuations...
09:29:35 <vixey> oh god
09:29:38 <vixey> the nightmares
09:30:03 <sjw> night all
09:30:30 <shapr> mwc__: score?
09:30:45 <mwc__> shapr: fun with NickServ....
09:31:55 <opqdonut> escaping nickserv by adding underscores fast enough ;)
09:32:11 <vixey> I like ReaderT
09:32:32 <mwc__> opqdonut: nah, just fixing linked accounts
09:32:57 <opqdonut> vixey: yeah it's really handy
09:33:22 <opqdonut> noticing a need for Reader is quite common but i can never bother monadizing the code
09:33:33 <opqdonut> but when one is already inside a monad, the ReaderT comes "for free"
09:34:11 <Saizan> it depends on the inner monad, with IO is still a pain to sprinkle liftIO around
09:34:35 <Saizan> "it's"
09:35:03 <DRMacIver> augustss: I kinda wish you hadn't done that. :)
09:35:19 <opqdonut> Saizan: true
09:37:44 <snhmib> how can i do debug-prints in another monad then the IO-one?
09:38:05 <quicksilver> Saizan: I often "use" readerT
09:38:20 <quicksilver> Saizan: but actually write my functions using ReaderT $ \env -.
09:38:32 <quicksilver> Saizan: then I get the benefit of them being monads so I can combine them
09:38:40 <quicksilver> Saizan: but I don't get the stupid lift problem :)
09:38:46 <edwardk> @seen ski
09:38:46 <lambdabot> I saw ski leaving #haskell.hr, ##logic and #haskell 7d 8h 10m ago, and .
09:39:05 <edwardk> heh
09:39:07 <edwardk> @seen ski_
09:39:08 <lambdabot> ski_ is in ##logic and #haskell. I last heard ski_ speak 21m 6s ago.
09:39:20 <Saizan> quicksilver: i do that too, but i wonder how much i'm gaining from that :)
09:39:34 <quicksilver> Saizan: the ability to write foo >> bar
09:39:37 <quicksilver> Saizan: for two such functions
09:39:40 <quicksilver> basically, that's it.
09:39:46 <quicksilver> but in some code bases that's worth it.
09:39:58 <quicksilver> (and the ability to use mapM, sequence, etc)
09:40:45 <atsampson> snhmib: if your monad contains IO, use liftIO; if not, use the Debug.Trace module
09:41:02 <Saizan> yeah, it's handy if you have large snippets that don't use the inner monad directly (fsvo large)
09:41:15 <quicksilver> snhmib: often debug prints are not the best way to debug non-IO code because of lazy evaluation.
09:41:24 <Saizan> or better, if you don't need to interleave them much :)
09:41:50 <quicksilver> Saizan: yeah. of course I do also wish the standard libs were written in terms of MonadIO =>
09:41:54 <snhmib> oh
09:42:53 <snhmib> i just want to look at some variables to see why the drawing goes wrong =(
09:43:07 <snhmib> i'll try Debug.Trace though, thanks =)
09:43:48 <BMeph> Do any of you more math-minded folks know of any Applicative functors with the same fmap, but different pure/"return" functions? Besides lists and zip lists?
09:43:54 <ski__> edwardk : yes ?
09:48:53 <skorpan> @pl \s -> s { irc = (irc s) + 1 }
09:48:54 <lambdabot> (line 1, column 9):
09:48:54 <lambdabot> unexpected "{"
09:48:54 <lambdabot> expecting variable, "(", operator or end of input
09:49:00 <skorpan> okelidokeli
09:49:14 <opqdonut> skorpan: you might want to have a look at FRef
09:49:25 <opqdonut> ?where fref
09:49:26 <lambdabot> I know nothing about fref.
09:49:34 <opqdonut> ?go FRef haskell
09:49:35 <lambdabot> No Result Found.
09:49:46 <opqdonut> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
09:49:48 <opqdonut> that one
09:49:48 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
09:53:30 <BMeph> ?where+ FRef http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
09:53:31 <lambdabot> Okay.
09:53:57 <quicksilver> BMeph: I'm not even sure Lists count.
09:54:10 <quicksilver> BMeph: the zip list thing only works for infinite streams
09:54:17 <BMeph> Count as what - AFs?
09:54:21 <quicksilver> BMeph: the normal one only works strictly finite lists
09:54:37 <quicksilver> BMeph: I'm not sure they count as 'one functor with the same fmap but different pure"
09:54:43 <quicksilver> I think they're actually different functors.
09:55:12 <conal> quicksilver: why not finite zip lists?
09:55:12 <quicksilver> Stream a and FiniteList a
09:55:27 <quicksilver> conal: 'pure' returns an infinite stream of as
09:55:52 <quicksilver> it also works for lengths of some fixed length, of course
09:55:58 <quicksilver> but again, different structures.
09:56:04 <masklinn> @quote
09:56:04 <lambdabot> stepcut says: I wrote 1 + 1 in php once, and got 11 -- wasn't quite what I was hoping for
09:56:11 <conal> quicksilver: and yet the fmaps agree
09:56:35 <quicksilver> conal: well the sort of agree in the sense that they are all subsets of Haskell's List.
09:56:57 <quicksilver> conal: but to try to get intuitive insight into BMeph's question I would argue they are actually separate Functors.
09:57:06 <BMeph> Well, "fmap f (ZipList xs) = ZipList (map f xs)" looks like it's the same thing, modulo data construction.
09:57:12 <conal> quicksilver: pure makes an infinite list, but <*> cuts it off
09:57:38 <conal> quicksilver: why separate functors?
09:58:35 <BMeph> Hmm, if I ever had to explain to someone why I Hate PHP, that quote would do nicely. :)
09:59:38 <gwern> dcoutts_: well, go ahead and comment on it then; if something is said in #haskell, did it ever really exist?
09:59:40 <cpoucet> @seen kowey
09:59:41 <lambdabot> I saw kowey leaving #haskell-books, #haskell.fr, #darcs and #haskell 6d 17h 34m 20s ago, and .
10:00:03 <conal> ZipList . fmap f . unZipList == fmap f && unZipList . fmap f . ZipList == fmap f
10:00:06 <dcoutts_> gwern: huw? wha? I've missed some context
10:00:07 <conal> i think
10:01:19 <gwern> dcoutts_: cabal-install
10:01:25 <gwern> you replied to me hours earlier
10:01:29 <ski_> edward1 : yes ?
10:01:45 <cpoucet> edward1: hey, thx for the link :)
10:01:58 <dcoutts_> gwern: oh, the upload thing, I remember now
10:02:22 <dcoutts_> gwern: yes I agree in general, the only detail is how to know if the tarball is up to date or if it needs to be re-generated
10:03:00 <gwern> dcoutts_: in that case, just do a clean and re-sdist
10:03:22 <dcoutts_> gwern: always do a clean and sdist, every time?
10:04:41 <ski_> same functor with two different applicative structures
10:05:17 <gwern> dcoutts_: it's not the smartest thing to do, could be wasteful, but the alternative is to what? check every file included in the sdist tarball if it has a modification time more recent than the existing tarball?
10:05:26 * gwern likes smart tools, but that might be too smart
10:05:44 <dcoutts_> gwern: once we have a dependency framework we could do exactly that
10:05:51 <dcoutts_> but in the mean time...
10:06:46 <gwern> *that would be included
10:20:26 * shapr throws del.icio.us lambdas at bos
10:20:45 <bos> oog?
10:21:33 <cpoucet> object oriented graphs?
10:22:28 <shapr> bos: I was just reading your del.icio.us bookmarks and enjoying them.
10:22:33 <olsner> oog = Ook programming while having a cold
10:22:55 <bos> shapr: i collect them like little tropical butterflies.
10:25:52 <cpoucet> bos: by snuffing them and then sticking fine needles through their limbs?
10:26:21 <bos> cpoucet: each web page is lovingly dropped into a jar of carbon monoxide.
10:26:53 <cpoucet> Nowadays computers run on electricity, not fuel :)
10:31:34 <pizza_> cpoucet: how is your electricity generated?
10:33:06 <cpoucet> pizza_: little gnomes
10:33:24 <cpoucet> gnome-fat has a very high burn-efficiency
10:34:31 <pizza_> sounds like a good fuel to me
10:35:35 <cpoucet> wow, fuel is a much more widely applicable word than I thought
10:35:48 <cpoucet> apparently it even applies to fissionable material
10:41:32 <edwardk> cpoucet: np =)
10:41:46 <edwardk> ski: was going pick your brain about generating functions =)
10:44:46 <edwardk> cpoucet: wish the approach had worked better though =/ anyways was pleased with the other stuff i was able to figure out as a result of taking the wrong turn.
10:45:16 <cpoucet> edwardk: the new post ?
10:45:30 <edwardk> cpoucet: yeah
10:46:26 <czakey> hello
10:46:40 <edwardk> i've also been playing around with negative generating functions as restrictions on another one.i..e [x] - Maybe x = x^2 + x^3 + .. is well formed even though we can only realize structures that have non-negative coefficients
10:46:45 <czakey> is there some simple way to parse html in haskell?
10:46:49 <ski_> edwardk : yes ?
10:46:59 <czakey> I mean - do I have to use happy?
10:47:00 <dons> czakey: yeah.
10:47:11 <dons> czakey: no, just use tagsoup or xhtml or hxt
10:47:11 <czakey> I want to write something like wget
10:47:19 <czakey> but much simpler
10:47:29 <dons> czakey: pretty easy, i'd use tagsoup. go to hackage.haskell.org
10:47:34 <czakey> ok
10:47:40 <czakey> thanks very much
10:47:43 <czakey> ill try it :)
10:47:54 <edwardk> ski: basically i was curious about, how you are with generating functions? i was trying to figure out if i'd just overlooked something that would make my idea work for codata or if i was screwed
10:48:51 <ski_> edwardk : well, i don't really know much a-bout them
10:49:00 <ski_> what idea for codata ?
10:50:27 <edwardk> ski: http://comonad.com/reader/2008/generatingfunctorology works for data types defined in terms of the least fixed point for which there are a finite number of ways the constructors can generate a term containing a given number of values.
10:50:28 <lambdabot> Title: The Comonad.Reader  Generatingfunctorology
10:50:50 <edwardk> i was trying to figure out how to get the approach to work for codata as well, but i think i'm screwed. mostly sounding out randomly for ideas
10:51:27 <edwardk> basically its 'data structures as formal power series'
10:54:04 <edwardk> when dealing with codata there is no '\aleph_n' coefficient.
10:55:04 <czakey> dons: do you know any example of using that tagsoup?
10:55:45 <edwardk> so Maybe a :+: Stream a has the same generating function as Maybe a: 1 + x. because the 'next non-zero coefficient' is pushed out towards infinity
10:56:06 <czakey> I've cabaled it, and now I'm reading something about it on haddock
10:56:34 <czakey> but for truth I dont know how to start ;)
10:57:46 <edwardk> there is probably some trick involving transfinite ordinals or something that could do it, but thats pretty far from my specialty
11:02:57 <ski_> (edwardk : just guessing, but maybe one'd need some dual of power series ..)
11:03:13 <edwardk> ski: hrmm
11:05:53 <edwardk> ski: if we look at a power series another way you can view each coefficient as the number of structures that are 'well-founded' for a given depth. i'd be curious to see how to say 'productive' corecursive similarly. maybe the number of distinct paths to a given depth?
11:06:05 <edwardk> ski: i think that will work =)
11:06:09 <edwardk> ski: thanks =)
11:06:52 <edwardk> ski: i just figured it out. i'll formalize it tonight
11:07:27 <Bonus> in Map.fromAscList
11:07:30 <Bonus> what has to be ascending
11:07:36 <Bonus> the keys or the values
11:07:38 <Bonus> or both
11:07:56 <Bonus> im guessing keys???
11:07:59 <mauke> keys
11:08:02 <Bonus> w00t
11:08:10 <mauke> :t fromAscList
11:08:15 <lambdabot> Not in scope: `fromAscList'
11:08:16 <mauke> :t M.fromAscList
11:08:18 <lambdabot> forall k a. (Eq k) => [(k, a)] -> M.Map k a
11:08:36 <mauke> Eq? impressive
11:08:49 <Bonus> umm but if its ascending
11:08:58 <Bonus> doesnt that mean that (Ord k) should hold true?
11:09:15 <mauke> yes, in theory
11:09:36 <ski_> edwardk : ehrm ? .. ok, whatever you say :)
11:09:38 <mauke> but fromAscList doesn't actually check that precondition, it just assumes you've done it right
11:10:17 <Bonus> ah
11:15:10 <edwardk> ski: its just using a generating function to represent a different fact about the data structure.
11:16:48 * shapr boings frivolously
11:17:00 * shapr throws a banana at edwardk
11:18:26 <shapr> @yow !
11:18:26 <lambdabot> Excuse me, but didn't I tell you there's NO HOPE for the survival of
11:18:26 <lambdabot> OFFSET PRINTING?
11:18:42 * ski_ views the banana get lost in outer space, through a large telescope lens
11:19:18 <shapr> haha
11:19:38 <shapr> I really wander over to edwardk's cube and smack him with a banana I bought in the lunchroom. He was surprised...
11:19:43 <shapr> did*
11:21:15 <edwardk> it was more of a poke actually ;)
11:21:49 <shapr> Bananas, Lense, Cubicles and ...
11:25:16 * edwardk needs to tell them to scramble the launch codes, er.. firewall settings, again to keep shapr productive ;)
11:25:31 <shapr> hah
11:25:34 <shapr> :-P
11:25:54 <shapr> Meds would probably fix my current hyperactivity.
11:26:01 * shapr sigh sand sucks it up..
11:26:19 <thetallguy> Heh.  stepcut does that at home.  He blocks reddit and several other sites to keep from surfing too much.
11:26:35 <thetallguy> himself, that is
11:26:45 <shapr> Smart guy
11:26:50 <thetallguy> I"m starting to think about it myself
11:27:07 <shapr> I've discovered that my Arduino does not have a web browser, and thus I get more done.
11:27:13 <thetallguy> shapr: did you get the ``unicycle'' link I sent you?
11:27:15 <bringert> can anyone explain to me why this function cannot be written: ((a -> b) -> b) -> (a -> [b]) -> [b]
11:27:24 <bringert> or even better, explain how it can be written
11:27:27 <shapr> thetallguy: Yeah, that's cool!
11:27:42 <bringert> me head hurts
11:27:45 <thetallguy> shapr: cool, glad to hear that lambdabot was reliable.
11:28:12 <thetallguy> bringert: I could give you a trivial function...
11:28:15 <shapr> bringert: Doesn't that imply that the first argument is a function that can return an item without input?
11:28:26 <Botje> @djinn ((a -> b) -> b) -> (a -> c) -> c
11:28:27 <lambdabot> -- f cannot be realized.
11:28:33 <Botje> awwh
11:28:38 <bringert> thetallguy: heh, yeah, I meant the correct one
11:28:41 <Botje> stupid @djinn not getting lists and me hacking around it badly :p
11:28:43 <shapr> @djinn (a -> b) -> b
11:28:43 <lambdabot> -- f cannot be realized.
11:28:49 <bringert> which I of course haven't specified
11:29:04 <vixey> ?djinn (a -> b) -> (Maybe a -> Maybe b)
11:29:04 <lambdabot> f a b =
11:29:05 <lambdabot>     case b of
11:29:05 <lambdabot>     Nothing -> Nothing
11:29:05 <lambdabot>     Just c -> Just (a c)
11:29:11 <Igloo> bringert: Given the two arguments there's nothing you can do
11:29:20 <bringert> Igloo: yeah, but why
11:29:23 <vixey> [] -> [], (c:cs) -> a c : f a cs
11:29:26 <thetallguy> the djinn ca't do it because there aren't any a's
11:29:33 <Igloo> What sort of an answer do you want?
11:29:36 <vixey> :t fix :: (a -> b) -> b
11:29:37 <lambdabot>     Couldn't match expected type `a' against inferred type `b'
11:29:37 <lambdabot>       `a' is a rigid type variable bound by
11:29:37 <lambdabot>           the polymorphic type `forall a b. (a -> b) -> b'
11:29:40 <vixey> :(
11:29:46 <bringert> Igloo: an intuitive one if possible
11:29:53 <thetallguy> bringert: you need to produce a list of [b]'s
11:30:16 <Igloo> Well, you haven't got an a, or any way of producing one, so you can't apply teh second argument to anything
11:30:18 <s_clv> hmm... if you turn (a->[b]) into [a->b] then it should be trivial...
11:30:18 <edwardk> bringert: because you can't go from ~~a -> a to call your function
11:30:22 <thetallguy> but the only way to do that given your parameters is to run a function on an a
11:30:26 <Igloo> And likewise for the first and (a -> b)
11:30:27 <thetallguy> and you don't have any a's
11:30:36 <edwardk> bringert: you are in an intuitionistic logic not a classical one
11:30:39 <s_clv> but there's no general way to do that.
11:30:48 <edwardk> hrmm
11:30:56 <edwardk> playing with it more
11:31:14 <edwardk> @djinn (a -> [b]) -> [a -> b]
11:31:15 <lambdabot> -- f cannot be realized.
11:31:28 <s_clv> even then you can do it hackishly...
11:31:40 <edwardk> that i think is the rub
11:32:20 <thetallguy> bringert: what did you want it to do?
11:32:41 <s_clv> its like unsequence Cont, no?
11:33:51 <edwardk> it seems to lift a member of Cont b a to ContT [] b a
11:34:10 <s_clv> :t func f as = map const (f (head a))
11:34:12 <lambdabot> parse error on input `='
11:34:20 <shapr> s_clv: Hi, who are you?
11:34:25 <Deewiant> @ty \f a -> map const (f (head a))
11:34:27 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a1 -> f a) -> [a1] -> f (b -> a)
11:34:54 <bringert> s_clv: yeah, but that will of course lose the tail
11:35:03 <s_clv> right -- it matches, but only because it lies!
11:35:29 <ski_> bringert : what is the intent of the type ?
11:35:34 <s_clv> shapr: s_clv = sclv = sclv_ :-)
11:35:35 <bringert> I might try a deep embedding of the continuation monad instead
11:36:00 <shapr> I'm looking for more Haskellers in Boston, I found another one today!
11:36:14 <shapr> s_clv: But you're in NJ, not MA, right?
11:36:21 <bringert> I want to use a continuation applicative functor with non-deterministic evaluation order
11:36:23 <s_clv> yeah, NJ/nY
11:37:01 <shapr> I have this urge to organize a NorthEastern Haskell gathering.
11:37:29 <bringert> and now I want to lift a deterministic function into that
11:37:30 <s_clv> there's a class of monads for which unsequence can be generally written though...
11:37:45 <bringert> this thing isn't even a monad I think
11:37:57 <bringert> just an applicative functor
11:38:27 <s_clv> ne haskell would be fun.
11:38:48 <ski_> bringert : lift how ?
11:39:09 <ski_> details, please :)
11:39:31 <shapr> I'm not sure what to call it though... AmeroHaskell seems too general.
11:39:38 <pcc1> anyone know about this warning when compiling happy-generated code in ghc? "Warning: Pattern match(es) are overlapped" the relevant code: http://hpaste.org/7618 note: the case list is exhaustive
11:40:08 <shapr> Bah, meds are kicking in, I'm off to do work.
11:41:40 <bringert> ski_: well, it can't be done, so it's kind of hard to explain how I want it to work :-)
11:42:39 <ski_> i don't see what the type `Bah, meds are kicking in, I'm off to do work.
11:42:42 <ski_> er
11:43:17 <ski_> i don't see what the type `((a -> b) -> b) -> (a -> [b]) -> [b]' has to do with lifting a deterministic function into some applicative nondeterminsitic functor
11:43:28 <s_clv> ?ty  \ f as -> map (\g b -> if b == a then g else f b) (f (head a))
11:43:29 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
11:43:29 <lambdabot>     In the first argument of `head', namely `a'
11:43:29 <lambdabot>     In the first argument of `f', namely `(head a)'
11:43:50 <ski_> bringert : e.g. what is the functor in question ?
11:43:55 <Deewiant> s_clv: s/as/a/
11:44:10 <s_clv> nah, even that won't save it.
11:44:29 <bringert> ski_: sorry, I'm just experimenting here. I will go off and try some other things.
11:44:42 <s_clv> somehow i suspect this is possible though, with enough creativity.
11:45:32 <ski_> bringert : ok .. (i was just trying to grasp what the situation was, and what you wanted there ..)
11:45:33 <s_clv> turn the single (a->[b]) into a list of functions that given the same a each give different bs.
11:46:25 <s_clv> maybe thread a monad through...
11:47:30 <dolio> There's no list until you have an 'a'.
11:50:38 <dolio> Is it standard procedure to put 'throw ()' in the signature of every C++ function you write?
11:51:30 <Zao> dolio: Not as far as I know.
11:51:45 <edwardk> dolio: depends on how anal retentive you want to be
11:51:53 <dolio> Heh.
11:52:07 <Zao> On the contrary, I think that it's contraproductive as it'll terminate you with std::unexpected without a chance to recover.
11:53:00 <vixey> std:: ????
11:53:05 <edwardk> i'll admit the behavior as implement is fubared
11:53:18 <Zao> dolio: Did you intend to ask this in #haskell by the way or is your aim weak?
11:53:50 <dolio> I did intend to ask here.
11:54:40 <dolio> I'm continuing my sorting kick from last night, and I'm looking at the wikibook implementations of smooth sort in the hopes that I'll find them easier to understand than Dijkstra's original paper.
11:54:53 <dolio> And the C++ implementation has 'throw ()' on every single function.
11:55:53 <dons> dolio: i'd be keen to include a fast sort in uvector
11:55:56 <dons> if you come up with one.
11:56:00 <dons> or a streamed sort...
11:56:07 <dons> though that might be a paper :)
11:56:39 <dolio> Yeah, I'm sticking to sorting MUArrs at the moment. :)
11:57:18 <vixey> What is a uvector?
11:57:37 <Zao> dolio: See 15.4 for exception specifiers and 15.5.2 for std::unexpected by the way.
11:57:46 <dons> dolio: great. you've just been monkeying around in the src to work it out?
11:57:53 <dons> haddock 2.0 fails on type familes it seems :(
11:58:00 <dons> vixey: a new arrays library in alpha
11:58:17 <s_clv> There once was a system named Coq / that at solving proofs was tip-top / though its name was punned / in unfortunate runs / pronounced poorly for the sake of a joke
11:58:17 <dolio> Yeah, it's not too hard to figure out.
11:58:46 <dolio> Filling big arrays with random stuff is a pain, though.
11:58:48 <vixey> what is a uvector made out of?
11:59:01 <paczesiowa> awesome
11:59:04 <czakey> eh
11:59:05 <dons> dolio: have a look at darcs.haskell.org/packages/ndp
11:59:14 <dons> dolio: there's a random permutation stream thign
11:59:27 <dons> dolio: though hooking that into the mersenne-random generator so it was also fast might be something to do
11:59:31 <dolio> In C, I can fill a 5 million element array using rand() in like .3 seconds, but using random gens takes like 20 seconds.
11:59:43 <czakey> when I'm trying to compile something with Text.HTML.Tagsoup
11:59:46 <dons> don't use System.Random!
11:59:52 <czakey> I'm getting
11:59:54 <czakey> $ ghc -o hwget hwget.hs
11:59:54 <czakey> hwget.o: In function `so1_info':
11:59:54 <czakey> (.text+0x315): undefined reference to `__stginit_tagsoupzm0zi6_TextziHTMLziDownload_'
11:59:57 <czakey> collect2: ld returned 1 exit status
12:00:01 <czakey> any suggestions?
12:00:02 <fizzletip> Hello.
12:00:02 <paczesiowa> czakey: use --make
12:00:10 <thetallguy> System.Random is too slow, eh?
12:00:19 <tromp> what makes System.Random bad?
12:00:21 <czakey> paczesiowa: thx ;)
12:00:49 <dolio> dons: I should use mersenne-random?
12:01:09 <dons> dolio: yeah. its  only 1000x faster
12:01:17 <dolio> Hah. Okay, then.
12:01:18 <dons> there's a darcs repo of mersenne-random-pure
12:01:27 <dons> that is similarly fast, and avoids IO
12:01:32 <tromp> why isn't System.Random a mersenne twister?
12:01:34 <dolio> Yeah, which one? mersenne-random or -pure64?
12:03:10 <dons> tromp: its unknown how to split it.
12:03:16 <dons> dolio: mersenne-random is very fast
12:04:34 <tromp> hmm, splitting is over-rated:(
12:04:58 <tromp> shld make separate class for Splittable Random
12:06:01 <paczesiowa> @src guard
12:06:01 <lambdabot> guard True  =  return ()
12:06:01 <lambdabot> guard False =  mzero
12:08:28 <dolio> Oh, that is much faster.
12:08:32 <dolio> Very nice.
12:08:44 <gwern> @hoogle run
12:08:45 <lambdabot> Control.Concurrent.runInBoundThread :: IO a -> IO a
12:08:45 <lambdabot> Control.Concurrent.runInUnboundThread :: IO a -> IO a
12:08:45 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
12:09:05 <gwern> @hoogle Process
12:09:06 <lambdabot> System.Process :: module
12:09:06 <lambdabot> System.Process.ProcessHandle :: data ProcessHandle
12:09:06 <lambdabot> System.Posix.Types.ProcessID :: type ProcessID
12:10:13 <pcc1> how can I extract the path (i.e. directory) of a file using the name, taking into account platform specific considerations?
12:12:50 <fizzletip> Is http://hpaste.org/7619 a good way to write mergeSort?
12:13:29 <pcc1> @hoogle FilePath -> FilePath
12:13:30 <lambdabot> System.FilePath.Windows.dropExtension :: FilePath -> FilePath
12:13:30 <lambdabot> System.FilePath.Windows.dropExtensions :: FilePath -> FilePath
12:13:30 <lambdabot> System.FilePath.Windows.takeDrive :: FilePath -> FilePath
12:15:04 <zooko> Dear people of #ghc:  So, darcs uses ghc to compile some C code from .c to .o.
12:15:11 <zooko> (The advisability of using ghc for this instead of gcc is an open question in my mind, in the first place.)
12:15:22 <zooko> But anyway, since darcs does it, and presumably has some reason to, then I need to know how to tell it configuration information like one needs to tell a C compiler, such as LDFLAGS, LIBS, CPPFLAGS.
12:15:39 <zooko> Now, it accepts -optl-lz , for example to mean the same thing as "-lz"
12:15:51 <zooko> means to a C compiler and it acceepts -optl-L$LIB_DIR , to mean the same thing that "-L$LIB_DIR" means to a c compiler,
12:16:00 <zooko> but apparently it does *not* accept -optl-I$INCL_DIR , to mean the same thing that "-I$INCL_DIR" means to a c compiler.
12:16:04 <zooko> Any ideas?
12:16:06 <zooko> Thanks.
12:16:52 <zooko> I mean people of #haskell, of course.
12:21:35 <snhmib> zooko: i don't know about darcs but i think you can just do ghc -Ldir -llib *.o ?
12:21:42 <ibid> isn't optl for linker options? -I obviously can't work :)
12:21:48 <ibid> what snhmib said
12:22:15 <zooko> I need to tell it to look for a .h file in a different directory.
12:22:27 <zooko> Having started to Read The Fine Manual, http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id350566
12:22:28 <lambdabot> Title: 5.17. Flag reference, http://tinyurl.com/ydk2e6
12:22:34 <zooko> I'm wondering if "-i" is the right answer...
12:24:19 <zooko> Nope.
12:24:56 <zooko> Ha!  :-)  The answer is -I
12:24:59 <zooko> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id354222
12:25:00 <lambdabot> Title: 5.17. Flag reference, http://tinyurl.com/ydk2e6
12:25:11 <paczesiowa> is there some guard-like thing for IO which on False would propagate IO () to the end of block (can be dirty hack, just stupid gui code anyway)
12:26:12 <dcoutts> @type when
12:26:14 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:26:26 <paczesiowa> @src when
12:26:26 <lambdabot> when p s = if p then s else return ()
12:26:43 <dcoutts> when foo $ do ...
12:26:49 <dcoutts> the opposite is unless
12:27:11 <paczesiowa> but then I have to indent following block anyway
12:28:22 <gwern> http://hpaste.org/7620 <-- hGetContents problem - what am I doing wrong?
12:29:05 <paczesiowa> maybe monad is nice, but lifting everything in MaybeT just to have "real" return seems overkill
12:29:26 <gwern> wait, nm
12:29:28 <gwern> I was reading the stdin handle, not stdout
12:29:36 * gwern feels sheepish
12:30:42 <sjanssen> gwern: the first thing you're doing wrong is using the wrong characters for <-, ::, and -> :)
12:31:20 <davidL> Does Knuth give you a check if you find an error in one of his essays as opposed to one of his books?
12:31:47 <paczesiowa> you might get some change:>
12:31:55 <i186824> :pl
12:32:05 <gwern> sjanssen: eh, emacs/terminal blah blah
12:32:05 <i186824> 2+2
12:33:36 <davidL> sjanssen: you replied to my reddit comment on "GHC Predictability"...if I rewrite that using foldl' it will use O(1) stack?
12:34:08 <gwern> @pl darcsChanges a = run "darcs changes" [a] -- go go list monad!
12:34:08 <lambdabot> darcsChanges = run "darcs changes" . return
12:35:25 <sjanssen> davidL: you also have to use seq or bang patterns because pairs are lazy
12:35:57 <davidL> I see
12:36:27 <sjanssen> > (undefined, undefined) `seq` 1
12:36:32 <lambdabot>  1
12:36:44 <paczesiowa> why there is no MaybeT in mtl?
12:37:09 <davidL> sjanssen: so add flip and a seq?
12:37:40 <sjanssen> you actually need to seq both elements of the tuple
12:38:27 <davidL> alright thanks, I'll fix the comment when I get home
12:38:56 <sjanssen> you could import Control.Parallel.Strategies and stick a 'force' in there
12:39:26 <davidL> I suppose the pointy version would be shorter/nicer anyway though
12:39:56 <flipfilip> @type flip
12:39:58 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:40:11 <flipfilip> @pl \fx->fx
12:40:11 <lambdabot> id
12:40:22 <flipfilip> @pl \fgx=fx(gx)
12:40:23 <lambdabot> (line 1, column 5):
12:40:23 <lambdabot> unexpected "="
12:40:23 <lambdabot> expecting letter or digit, operator, pattern or "->"
12:40:28 <flipfilip> @pl \fgx->fx(gx)
12:40:29 <lambdabot> const (fx gx)
12:40:40 <flipfilip> @pl \f g x -> f x ( g x)
12:40:40 <lambdabot> ap
12:41:11 <flipfilip> @type ap
12:41:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:42:53 <flipfilip> @type \f g x -> f x (g x)
12:42:55 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
12:43:03 <flipfilip> @type ap
12:43:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:43:14 <flipfilip> @ap \f g x -> f x (g x)
12:43:14 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
12:43:19 <gwern> @pl darcsChanges a = run "darcs" ["changes", a]
12:43:20 <lambdabot> darcsChanges = run "darcs" . ("changes" :) . return
12:44:04 <gwern> ew
12:45:10 <sjanssen> seems okay to me
12:45:13 <gwern> @where HSH
12:45:13 <lambdabot> http://software.complete.org/hsh
12:46:23 <gwern> well, you're you
12:50:50 <skorpan> is there any way to "override" a "deriving Show" with another instance of Show?
12:55:48 <vincenz> @seen tibbe
12:55:49 <lambdabot> I saw tibbe leaving #haskell-soc, #xmonad, #ghc and #haskell 5h 27m 25s ago, and .
12:58:52 <Saizan> skorpan: no, you can use a newtype
13:00:06 <dcoutts> I saw a cool use of newtype today
13:00:57 <Saizan> yes?
13:00:59 <dcoutts> type ListF a x = (x, a -> Maybe (a, x))
13:01:25 <dmwit> :t unfoldr
13:01:28 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:01:43 <dcoutts> newtype CoList a = CoList (ListF a (CoList a))
13:02:03 <dmwit> oh
13:02:13 <Saizan> s/(x, a/(a, x/ ?
13:02:22 <dcoutts> oops
13:02:25 <dcoutts> type ListF a x = (x, x -> Maybe (a, x))
13:02:45 <Saizan> ah, right
13:03:10 <dcoutts> so it's a bit like : mu x. ListF a x
13:03:21 <dcoutts> we're hiding the x parameter
13:03:24 <ski_> s/mu/nu/
13:03:27 <skorpan> if i have a module defining a class, how do i make other modules find it? it seems that just importing the module doesn't work
13:03:28 <ski_> no ?
13:03:34 <dcoutts> ski_: oh, ok, maybe :-)
13:03:45 <ski_> non-empty lists ?
13:04:00 <ski_> (.. no)
13:04:04 <dcoutts> ski_: no, ordinary lists
13:04:12 <ski_> yes
13:04:43 <paczesiowa> @src when
13:04:43 <lambdabot> when p s = if p then s else return ()
13:04:48 <paczesiowa> @src unless
13:04:48 <lambdabot> unless p s = if p then return () else s
13:05:19 <dmwit> when . not
13:05:26 <dcoutts> Saizan: so I've used existentials before to hide type parameters like that before, but I'd not seen the trick with recursive (new-)types
13:06:05 <dcoutts> data CoList a = exists x. CoList (ListF a x)
13:06:28 <Saizan> mmh it's not equivalent
13:06:35 <dmwit> skorpan: Can you be more specific about what doesn't work?
13:06:37 <dcoutts> no, indeed, not quite
13:06:43 <dcoutts> you'll notice that's our encoding of Streams
13:07:07 <dcoutts> using the exists.
13:07:29 <skorpan> dmwit: the importing module gets "<function> out of scope" where <function> is the only function in the class
13:07:40 <dcoutts> I'm not exactly sure of the relationship between the recursive type version and the existential quantification version
13:07:58 <skorpan> this is the top of my "class" module: module QuadShow (QuadShow(..)) where
13:08:01 <skorpan> QuadShow is the class
13:08:13 <skorpan> in the importing module i do: import QuadShow
13:08:16 <dcoutts> where are our resident category, lambda and type experts?
13:08:27 <Saizan> ?seen edwardk
13:08:27 <lambdabot> edwardk is in #haskell-blah, ##logic and #haskell. I last heard edwardk speak 1h 3m 29s ago.
13:09:34 <Saizan> it seems like the recursive one has many streams inside it..
13:09:38 <dmwit> skorpan: I can't reproduce it; care to paste?
13:09:54 <skorpan> dmwit: i would, and thanks for your help, but i *really* must be going now! :)
13:10:07 <dmwit> Okay, another time. =)
13:10:12 <skorpan> yep :)
13:12:48 <gwern> @hoogle [[a]] -> [[a]] -> [a]
13:12:49 <lambdabot> No matches, try a more general search
13:13:02 <ehird> Hmm. Is there a haskell database library that lets you specify tables in haskell?
13:13:04 <gwern> @hoogle [String] -> [String] -> [String]
13:13:05 <lambdabot> No matches, try a more general search
13:13:13 <gwern> ++, right
13:13:15 <ehird> For haskellnomic, it'd be nice to just be able to edit the files.
13:13:23 <gwern> no. hm.
13:13:25 <ehird> & the sql to do it otherwise would be error-prone
13:15:00 <dmwit> gwern: Yes, (++).
13:15:15 <Heffalump> ehird: HaskellDB does, but you still need to jump through the hoops to actually make a database with them
13:15:23 <dmwit> gwern: What do you want the function to do?
13:16:23 <ehird> Heffalump: HaskellDB is all hoops.
13:16:44 <Saizan> dcoutts: maybe type Stream a = nu x. x -> Maybe (a, x), since that way you can apply the stream to itself and get Maybe (a,Stream a)
13:16:44 <Heffalump> I know :-(
13:17:02 * Heffalump is currently writing an alternative that lets you write more natural Haskell code.
13:19:56 <edwardk> saizan: here
13:20:13 <dcoutts> Saizan: mm, I think I see
13:20:39 <dcoutts> edwardk: we were trying to understand different type-based approaches to hiding internal types
13:20:55 <dcoutts> the example was, start with the list functor:
13:21:08 <dcoutts> type ListF a x = (x, x -> Maybe (a, x))
13:21:26 <gwern> question: anyone see a shorter way to do: gitChanges "" = run "git" ["--no-pager", "log"]
13:21:29 <gwern> gitChanges a = run "git" ["--no-pager", "log", a]
13:21:32 <dcoutts> edwardk: then we have two candidate encodings of co-lists
13:21:35 <edwardk> dcoutts: like existentials, etc?
13:21:40 <dcoutts> edwardk: right
13:22:03 <dcoutts> edwardk: so for existentials we get data Stream a = exists x. Stream (ListF a x)
13:22:10 <dcoutts> and recursive newtypes
13:22:20 <ehird> Heffalump: Takusen?
13:22:39 <edwardk> dcoutts: so far so good
13:22:43 <dcoutts> newtype Thing a = Thing (ListF a (Thing a))
13:23:06 <dcoutts> edwardk: so we plug the type in as the x parameter of the list functor
13:23:14 <dcoutts> the newtype
13:23:43 <dcoutts> edwardk: and we were trying to understand the relationship between the two
13:23:43 <roconnor> @spell tuple
13:23:50 <roconnor> @spell tupple
13:23:58 <Heffalump> ehird: no, squiggle. http://code.haskell.org/squiggle
13:23:58 <lambdabot> Title: Index of /squiggle
13:24:35 <ehird> Heffalump: example? supported dbs?
13:24:44 <edwardk> dcoutts: if you check the darcs repo for category-extras and go back a couple of versions, you might find the Control.Comonad.Cofree.Alt implementation to be useful to understand these
13:24:51 <ehird> Test.hs looks alright
13:25:01 <Heffalump> ehird: it's still in the "I'm hacking on it to see if it works" stage, not "you could use this".
13:25:10 <ehird> Heffalump: But this is a codenomic.
13:25:11 <ehird> ;)
13:25:11 <edwardk> dcoutts: in that case i have an alternative implementation of the cofree comonad done in terms of explicit head and tail functions (a slightly more draconian decomposition than the one you have here)
13:25:17 <ehird> Heffalump: So -- example, supported DBs!
13:25:18 <Heffalump> and only MySQL, but it just compiles to SQL so anything that HSQL or HDBC supports should be fine.
13:25:20 <ehird> oh
13:25:22 <ehird> mysql
13:25:23 <dcoutts> edwardk: Ralph Lammel gave a talk today where he used the recursive newtype trick as part of his encoding of OO in functional style
13:25:23 <ehird> :(
13:25:35 <dcoutts> @where category-extras
13:25:36 <lambdabot> I know nothing about category-extras.
13:25:41 <Heffalump> a codenomic?
13:26:22 <dcoutts> edwardk: where do I find category-extras
13:26:29 <Saizan> dcoutts: ah! that makes sense, every "object" is carring around its method
13:26:37 <edwardk> dcoutts: http://comonad.com/haskell/category-extras
13:26:38 <lambdabot> Title: Index of /haskell/category-extras
13:26:47 <dcoutts> @where+ category-extras http://comonad.com/haskell/category-extras
13:26:47 <lambdabot> Okay.
13:26:54 <edwardk> the code in question has been cut, but was in a couple of patches ago as Control.Comonad.Cofree.Alt
13:26:56 <dmwit> Heffalump: Some kind of game where the rules keep changing under your nose.
13:27:10 <dcoutts> saiam: right, an object is a record of functions with a hidden state type
13:27:21 <dcoutts> opps, silly tab completion
13:27:32 <dcoutts> Saizan: I meant you :-)
13:27:33 <ehird> Heffalump: yes
13:27:38 <ehird> oh god do I have to explain nomics and codenomics
13:27:39 <ehird> :D
13:27:42 <ehird> (again!)
13:27:53 <Heffalump> how long ago should I read scrollback from?
13:27:58 <ehird> Heffalump: days
13:27:59 <dmwit> a few days
13:28:01 <ehird> Heffalump: but
13:28:04 <ehird> let me explain -- again
13:28:06 <Heffalump> I know what nomic is, if you mean the game.
13:28:09 <ehird> Yes, yes I do
13:28:19 <ehird> Heffalump: So, a codenomic is a nomic, but instead of rules you have programs.
13:28:22 <Heffalump> ah.
13:28:23 <edwardk> when you look at the definition there you'll see that the existential encoding is just making your functor explicitly model the anamorphism. 'anaCofree' becomes very very easy with the existential representation. otoh, if i recall correctly you lose pattern matching and sharing
13:28:28 <Heffalump> I get the rough idea.
13:28:32 <Heffalump> What does this have to do with a database?
13:28:39 <ehird> Heffalump: Specifically, in its web-based form, it's like a self-modifying web app. But of course instead of being like a wiki, it creates proposals.
13:28:49 <ehird> Heffalump: Now, just as people in a nomic can use the rules to add real gameplay,
13:28:57 <twobitwork> I'm trying to figure out how to use the SQLite package, but the cabal package doesn't come with any docs, and the entry on hackage doesn't have anything either...
13:29:03 <ehird> people can use codenomics to add real mini-games - e.g. PerlNomic has a map where you can move and 'bite' players for points
13:29:17 <ehird> Heffalump: Now, for storing players, the data for the mini-games, etc., a database would be nice.
13:29:28 <ehird> Being able to keep it all inside haskell would be even nicer.
13:29:43 <EvilTerran> ?hackage sqlite
13:29:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sqlite
13:29:44 <Heffalump> but still persisted to a DB?
13:30:42 <twobitwork> EvilTerran: yeah, that's the page I'm looking at... but I don't see any docs on there
13:31:23 <EvilTerran> twobitwork, click on things in "exposed modules"? there seems to be a bit of haddock documentation there
13:31:39 <edwardk> dcoutts: basically, my limited experience seems to be that if you only touch some of the data and you don't retraverse it (or it regenerates cheaply) then the existential encoding can be cheaper
13:31:40 <edwardk> , while the explicit constructor encoding may wind up holding onto more thunks.
13:31:53 <twobitwork> EvilTerran: ahh, ok... I'll check that out, thanksd
13:32:00 <dcoutts> edwardk: mm, interesting
13:32:21 <ehird> Heffalump: yes
13:32:23 <Saizan> edwardk: but looking at the previous defined newtype Thing a = Thing (Thing a, Thing a -> Maybe (a,Thing a)), i can either use the stored function with the value to get head and tail, or peel another newtype layer and get another pair of (hidden state, function), that's what looks weird
13:32:32 <ehird> Heffalump: so a table definition in haskell, with a haskell querying api = perfect
13:32:52 <edwardk> saizan: but what is a thunk? its some hidden state and a function on it!
13:33:03 <edwardk> saizan: all you've done is make that explicit
13:33:38 <dcoutts> Saizan: yeah, it does seem odd
13:33:56 <Saizan> edwardk: but i've two ways to traverse that "stream", no?
13:33:57 <dcoutts> Saizan: I can apply the function to the seed or the original value itself
13:34:16 <dcoutts> Saizan: or indeed, unwrap the seed again
13:34:24 <dcoutts> yeah, I don't grok that
13:34:36 <edwardk> i thought it was newtype Thing a = Thing (ListF a (Thing a)) ?
13:34:54 <dcoutts> edwardk: Saizan just expanded the ListF type alias
13:35:11 <Saizan> yeah, but type ListF a x = (x, x -> Maybe (a,x)) here
13:35:21 <Heffalump> ehird: well, once it's done squiggle ought to support that fine.
13:35:32 <edwardk> hrmm your thing seems a little odd to me
13:35:38 <ehird> BRB
13:35:43 <Heffalump> you'd define a Haskell datatype, make a table from that, then be able to do queries that returns values of that type.
13:35:45 <edwardk> heh thats a dangerous line to utter
13:35:52 <dcoutts> ;-)
13:35:56 <Saizan> :D
13:36:19 <Saizan> however it's that oddness we were talking about :)
13:36:34 <edwardk> where did that def for thing come from?
13:36:41 <edwardk> its a little different than the one i thought it was
13:36:50 <dcoutts> it's the "recursive newtype trick"
13:36:55 <dcoutts> for some functor F
13:37:03 <dcoutts> newtype T = T (F T)
13:37:40 <dcoutts> so we've "hidden" the functor parameter
13:37:45 <edwardk> its the fixpoint of the functor, sure.
13:38:53 <dcoutts> edwardk: right, but as I understand it, there are two system F encodings for fixpoints, and those give us data and co-data
13:39:11 <dcoutts> and the co-data encoding uses existentials, like Stream
13:39:16 <Saizan> that LiftF comes from the existential encoding it seems? taking the fixpoint is a quite different operation though, no?
13:39:30 <edwardk> dcoutts: newtype Mu f a = In { out :: f a (Mu f)) } is probably more traditional than Thing =)
13:39:51 <edwardk> fair nuff
13:39:55 <dcoutts> so we'd expected the fixpoint to behave like the existential encoding
13:40:16 <dcoutts> but there seem to be more (weird) things you can do with the Mu version
13:40:54 <edwardk> checking the result of fixing the listf bifunctor
13:43:02 <edwardk> so what you're seeing is that: out :: Mu (ListF a) -> (Mu (ListF a), Mu (ListF a) -> Maybe (a, Mu (ListF a))
13:43:22 <edwardk> so that fst . out :: Mu (ListF a) -> Mu (ListF a) ?
13:44:02 <Saizan> right
13:44:49 <edwardk> but thats the way that your recursion can 'catch its own tail' and refer to itself, no? without it you'd lose sharing wouldn't you?
13:45:23 <Saizan> edwardk: so fst.out is supposed to be the tail?
13:45:37 <edwardk> no fst . out is the node you are at
13:45:51 <Saizan> and out . fst . out ?
13:46:33 <EvilTerran> wouldn't that be out . snd . out?
13:46:38 <edwardk> should be = out, or am I off base?
13:46:48 <Saizan> uncurry id . out should be Maybe (head,tail)
13:47:43 <gwern> which one do you think more haskellers use for haskelly stuff? CVS, Mercurial, or Montone?
13:47:50 <Saizan> edwardk: and that's useful for sharing?
13:48:03 <zooko> I know of one Haskell monotone project.
13:48:28 <zooko> http://lwn.net/SubscriberLink/281849/0dc93cbf061925a7/
13:48:30 <gwern> zooko: distract?
13:48:32 <lambdabot> Title: Distributed bug tracking [LWN.net]
13:48:40 <edwardk> thats because you have a function that expects to take a list, and give you a 1 + a x. It takes the list so it has access to itself in case you want to use it in the tail.
13:49:43 <ehird> gwern: not CVS
13:49:44 <gwern> zooko: yeah, I've heard of distract. I packaged it for hackage
13:49:47 <ehird> not Mercurial
13:49:51 <ehird> not Monot- none of them.
13:49:57 <ehird> gwern: out of them, not Monotone.
13:50:05 <ehird> Mercurial ... maybe. It's more popular for other langs
13:50:12 <ehird> CVS is the home of e.g. hugs and ghc, officially, so maybe
13:50:17 <ehird> but I don't know of any other projects using it
13:50:23 <ehird> gwern: darcs & git are the main ones
13:50:24 <gwern> and let me tell you, the experience of *just accessing* the source files in montone convinced me that monotone will never ever ever ever be popular beyond a small group of crypto-paranoid developers
13:50:38 <ehird> gwern: yeah monotone is kinda sux.
13:51:01 <gwern> ehird: right, but I've got them covered for my little program, so I was wondering which one next
13:51:41 <Saizan> edwardk: i see, do you know if Mu (ListF a) is isomorphic to lists? or is it greater?
13:51:55 <zooko> Dear people of Haskell: when I compile a certain tiny .hs file with -optl-lcurl, it successfully links in libcurl and invokes a curl function through ffi.
13:52:04 <ehird> zooko: Good to know!
13:52:12 <zooko> But when I do the same with -fvia-C added, it gives an undefined reference error at link time.
13:52:28 <zooko> I would like to know how to link to libcurl with -fvia-C.
13:52:45 <zooko> Or else, how to make sure that ghc stops with an error if the curl.h file isn't found, without -fvia-C.
13:52:55 <dcoutts> zooko: you can use just -lcurl, you don't need the -optl prefix
13:52:58 <zooko> That is: the reason for the -fvia-C is just to make sure that it breaks if the curl.h file isn't found.
13:53:04 <zooko> dcoutts: thanks!  I'll try that.
13:53:20 <dcoutts> zooko: it makes no difference to your other problem
13:53:23 <edwardk> repeat z = In (repeat z, \self -> Just (z,self))
13:54:08 <dcoutts> zooko: why do you want the compilation to fail if curl.h file isn't found?
13:54:10 <edwardk> saizan: it would appear to be greater, since its some form of modified context comonad. i can't call the 'self-recursive' part of a normal list node with a different 'self', but i can call that one
13:54:52 <zooko> dcoutts: because this compilation is just for testing, during a ./configure, whether it will be able to compile the full thing at compile time.
13:55:11 <zooko> And at compile time, if the header files aren't found, it fails, because at compile time it is compiling some .c to .o code, not .hs.
13:55:23 <dcoutts> zooko: you need the header if you compile -fvia-C, if not you do not need the header
13:55:32 <paczesiowa> would anyone take a look at this http://hpaste.org/7623 ? (hpaste announce broke?)
13:56:00 <zooko> dcoutts: okay, so what I want to do is figure out how to make it link to libcurl while using -fvia-C.
13:56:08 <edwardk> i.e. given your Mu (ListF a), i could (snd . out) to get a function from Mu (ListF a) -> Maybe (a,Mu (ListF a)), with that i could distinguish between say, a version of repeat that repeated twice THEN called into itself by seeing that it prepended onto my supplied list, and one that didn't share, and one that did the loop above
13:56:14 <zooko> In order to use ghc at configure time as a predictor of whether it will be able to compile at compile time.
13:56:34 <dcoutts> zooko: just use -fvia-C and -lcurl, or am I missing something?
13:57:02 <edwardk> so just like DList is bigger than [], your Mu (ListF a) is bigger than [a], because i can distinguish between more members.
13:57:06 <dcoutts> zooko: or if you do not use -fvia-C at compile time then you don't need to bother testing for curl.h at all
13:57:16 <zooko> Well, it turns out that -fvia-C and -lcurl gives me this undefinied refreence error that I mentined earlier.
13:57:18 <edwardk> with appropriate wrapping in a module thats not a problem though.
13:57:34 <zooko> dcoutts: the thing is, the compile-time code is not Haskell code using FFI, it is C code.
13:57:42 <zooko> So, I definitely require curl.h at compile-time.
13:57:48 <dcoutts> zooko: then use the c compiler to test for curl.h
13:58:03 <dcoutts> zooko: there are autoconf macros to do that for you
13:58:57 <Saizan> edwardk: it seems that they would not behave well wrt garbage collection
13:59:06 <edwardk> if you didn't expose the constructors and only offered up a 'near context comonadic extract' from Mu (ListF a) -> Maybe (a, Mu (ListF a)) then you'd be ok.
13:59:27 <edwardk> meh, you get a handle to yourself that you can choose to ignore, you get than now with any let block.
13:59:43 <edwardk> most of those will get dropped from the environment unless used
14:00:31 <zooko> dcoutts: well, that is certainly good advice, but for some reason that I don't know, darcs uses ghc to compile C code.
14:00:47 <Sgeo> Does format :: (Formatter a b) => b make sense for a function that needs to accept arguments? *prods ehird*
14:00:48 <Saizan> uhm, right, the tail only gets an handle to the tail, i was confusing myself :)
14:01:06 <ehird> I love watching Sgeo embarrass himself.
14:01:14 <__pao__> hi all :-)
14:01:14 <dcoutts> zooko: that's partly for portability, since it needs to compile C code on windows, and ghc has a bundled gcc
14:01:17 <ehird> Sgeo: What if I have a Formatter instances where b is a function type?
14:01:23 <ehird> Whoopsy!
14:01:52 <__pao__> i'm try to complete a pseudo comprehensive haskell tour
14:01:55 <monochrom> "format :: (Formatter a b) => b" seems to say it doesn't want any argument.
14:01:59 <dcoutts> zooko: I mean it has a bundled gcc on windows, so if you use ghc to compile C code you know there will always be a C compiler, where as not all windows users have gcc installed normally
14:02:05 <ehird> monochrom: Formatter a (b -> c)
14:02:23 <dcoutts> zooko: I suggest you investigate why it fails with ghc -fvia-C -lcurl
14:02:23 <zooko> dcoutts: Ah, that's a good point.
14:02:27 <zooko> That's fine with me.  I just ...
14:02:29 <zooko> What you said.  :-)
14:02:33 <monochrom> That's dangerous water.
14:02:46 <__pao__> I got through: monads, phantom types, gadt.... is there anything else I should be "aware" of in order to be 99% "productive"?
14:03:06 <zooko> I just need to make ./configure predict correctly whether "ghc hscurl.c" will work.
14:03:13 <monochrom> Also it's something specific to one particular instance of Formatter, but not generally for all possible "format"s.
14:03:30 <zooko> So perhaps rather than using ghc to ffi a function from libcurl, I really need to write an autoconf macro (scary prospect)
14:03:34 <dcoutts> zooko: then use ghc small-curl-test.c
14:03:35 <zooko> that invokes ghc on a .c file.
14:03:37 <zooko> That sounds right.
14:03:48 <EvilTerran> __pao__, monad transformers?
14:03:57 <__pao__> EvilTerran: done it
14:04:08 <dcoutts> __pao__: OO encodings of data types :-)
14:04:08 <__pao__> EvilTerran: arrows are "useful"?
14:04:31 <Sgeo> So that type is not specific enough?
14:04:35 <zooko> If you are familiar with autoconf macros and ghc (I'm not with either), you could help me by showing me the equivalent of GHC_CHECK_LIBRAR() http://allmydata.org/trac/darcs-2/browser/aclocal.m4#L86
14:04:37 <lambdabot> Title: /aclocal.m4 – darcs – Trac
14:04:38 <__pao__> dcoutts: argh! I thought I could get rid of OO ;-) .... can you give me a pointer?
14:04:45 <zooko> but for .c test files, not .hs test files with FFI in them.
14:05:02 <dcoutts> __pao__: you know how ordinary algebraic data types make it easy to add new functions, but if you wanted to add a new constructor, then you'd have to go modify every function right?
14:05:12 <monochrom> gadt includes existential type includes OO. You already know it.
14:05:19 <zooko> dcoutts: I'm *also* curious why I get a link error when I add -fvia-C to a working command-line, though...
14:05:27 <dcoutts> __pao__: so it's easily extensible in one direction and hard in the other
14:05:40 <__pao__> dcoutts: yep
14:05:57 <dcoutts> __pao__: OO by default is the dual, they get alternatives easily (subclassing) but adding new operations requires changes in every class
14:06:18 <EvilTerran> __pao__, i wouldn't say arrows are that useful. that might just be because i don't grok them, though
14:06:24 <__pao__> dcoutts: yep
14:06:30 <dcoutts> __pao__: so OO has a technique to get extensability in the other direction (the visitor pattern) and FP has a technique to get the OO extensability
14:06:46 <dcoutts> __pao__: in both cases you only get easy extensability in one direction at a time
14:06:52 <EvilTerran> @go data types a la carte
14:06:55 <lambdabot> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
14:07:07 <__pao__> dcoutts: I'm following...
14:07:16 <EvilTerran> that's a (very readable, imo) paper on the matter
14:07:17 <dcoutts> __pao__: but you get to choose which extension direction is more important for each problem
14:07:42 <__pao__> dcoutts: there's no way to "solve" the dualism?
14:08:02 <dcoutts> __pao__: that's "the expression problem". You can read papers on it.
14:08:10 <__pao__> dcoutts: how do you get OO advantages in haskell?
14:08:16 * zooko tries to write an autoconf macro to compile C code with GHC.
14:08:28 * Toxaris votes for virtual classes to solve the expression problem in OO languages
14:08:38 <dcoutts> __pao__: the simplest encoding that gets you most of the OO extension features is to make records of functions
14:09:10 <dcoutts> __pao__: data Foo = Foo { bar :: ... -> ...; baz :: ... -> ... }
14:09:39 <dcoutts> __pao__: or for a concrete example, eg in Cabal we might want a compiler abstraction and implementations for ghc, hugs, etc
14:09:58 <dcoutts> __pao__: so we can have data Compiler = GHC | HUGS | ...
14:10:08 <dcoutts> but then adding a new compiler is a pita
14:10:31 <dcoutts> so for this problem it seems nicer to group the functionality by compiler rather than by each operation on the compiler
14:10:48 <dcoutts> so we want, ghc :: Compiler, hugs :: Compiler etc
14:11:09 <dcoutts> ghc = Compiler { compile = \blah -> ...; etc }
14:11:58 <dcoutts> __pao__: and most of the time that style of encoding is enough
14:12:13 <__pao__> dcoutts: very enlightening
14:12:26 <dcoutts> __pao__: note how it allows us to have lists of compilers for example
14:12:55 <dcoutts> __pao__: you need something a bit cleverer if your object has 'mutative' operations, ie ones that return objects in a new state
14:13:26 <__pao__> dcoutts: brb
14:17:21 <zooko> Okay, now to try my shiny new autoconf macro to compile C code using ghc.
14:17:33 <__pao__> dcoutts: very clear
14:17:52 <Japsu> väärä kanava
14:17:54 <Japsu> ...
14:17:56 <Japsu> multifail
14:17:58 <Japsu> @oeis 3 12
14:17:58 <lambdabot> Binomial(3n,n)/(2n+1) (enumerates ternary trees and also non-crossing trees).
14:17:58 <lambdabot> [1,1,3,12,55,273,1428,7752,43263,246675,1430715,8414640,50067108,300830572,18...
14:18:10 <Japsu> that's what I was trying to type
14:18:13 <__pao__> dcoutts: scala by being both functional and OO should solve somehow the "expression problem", right?
14:18:29 <__pao__> dcoutts: I know I'm cutting corners :-)
14:18:39 <zooko> Um, now autoconf gives me a warning that appears to be completely unrelated to what I just changed.  :-(
14:19:18 <__pao__> dcoutts: do you have a pattern olso for 'mutative' operations?
14:19:41 <__pao__> EvilTerran: thanks for the link... I'm looking at it...
14:20:08 * ehird is trying to work on a silly type-safe formatter
14:20:12 <ehird> format "a" => "a"
14:20:15 <ehird> format str "a" => "a"
14:20:20 <ehird> format (str %% str) "a" "b" => "a"
14:20:30 <ehird> format ("Hello, " %% str %% "!") "a" => "Hello, a!"
14:21:24 <zooko> Wow, and now it goes into an infinite loop when I run autoconf.  They weren't kidding when they said it sucks to hack autoconf code.
14:21:27 <EvilTerran> __pao__, you can't solve the expression problem in any easy way, as you basically need a behaviour definition for the cross product of methods and constructors
14:21:34 <monochrom> Must you support (format "a")?  Shouldn't it be cleaner to require (format str "a") if the programmer wants "a"?
14:21:50 <EvilTerran> __pao__, so you need to write a new definition for each constructor when you add a method
14:22:08 <EvilTerran> __pao__, and a new definition for each method when you add a constructor
14:22:23 <ehird> monochrom: I'd like to.
14:22:37 <Toxaris> EvilTerran: sure. the point of the expression problem is that it should be possible to add these new methods / cases without changing (or even recompiling) any old code
14:23:02 <__pao__> EvilTerran: I see... but you can choose function _or_ oo for parts of your program...
14:23:07 <Toxaris> EvilTerran: of course they have to be provided, how else could the system know what to do?
14:23:09 <EvilTerran> __pao__, so, if you could add either, then you couldn't be sure someone else hadn't added a method you don't know about before you added your new constructor, so you wouldn't know to write a definition for it
14:23:20 <EvilTerran> or vice-versa
14:23:43 <Toxaris> EvilTerran: why can't this be handled by static typechecking?
14:24:03 <EvilTerran> well, it can, but you still get errors
14:24:22 <EvilTerran> so one module that adds a method can't be used with another that adds a constructor
14:24:39 <Toxaris> __pao__: the expression problem as I understand it is solved by virtual classes, and Scala can emulate virtual classes (through abstract type members which have abstract traits as upper bounds), so Scala solves the expression problem
14:24:59 <s_clv> ehird: delconts ftw.
14:25:20 <Toxaris> EvilTerran: yes, but, the typesystem will tell me which methods are missing, and I can write exactly the missing methods (e.g. as a trait in scala) and add them to make the two modules compatible
14:25:26 <ehird> s_clv: Delconts? Lammmme. I'm not doing anything LAME like that.
14:25:27 <ehird> :3
14:25:44 <__pao__> Toxaris: what do you mean by "abstract trait as upper bounds"? (I know what traits are)
14:25:44 <s_clv> so what then, lots of typeclasses?
14:25:45 <EvilTerran> Toxaris, eh, i guess so.
14:25:53 <ehird> s_clv: Yah.
14:26:01 <Toxaris> __pao__: do you know what abstract types are?
14:26:03 <s_clv> oooh... elegant.... :-P
14:26:10 <__pao__> Toxaris: yep
14:26:32 <s_clv> haha of course my next silly project is i want to implement the full loop macro.
14:26:39 <s_clv> (without th, that is)
14:26:39 <ehird> s_clv: haahahah
14:26:58 <ehird> s_clv: you can get away by doing
14:26:58 <Toxaris> __pao__: trait Base { type ToBeExtended <: Interface; trait Interface { ... } }
14:27:00 <ehird> for = For
14:27:02 <ehird> so you can do:
14:27:33 <ehird> for \x -> in lst doo (putStrLn (x+2))
14:27:33 <s_clv> or at least implement a large enough subset that it shows how haskell can get you 90% of the expressiveness of macros.
14:27:39 <ehird> s_clv: look above
14:27:39 <ehird> :D
14:27:41 <ehird> it's evil
14:27:52 <EvilTerran> "in" is a keyword...
14:27:52 <ehird> s_clv: You would call it with undefined to get the in lst part, of course.
14:27:59 <ehird> EvilTerran: it's 'of' in CL
14:28:01 <ehird> so
14:28:05 <ehird> for \x -> of lst doo (putStrLn (x+2))
14:28:06 <Toxaris> __pao__: trait Ext1 extends Base { type ToBeExtended <: ExtInterface; trait ExtInterface { ... } }
14:28:27 * dolio gives up on smooth sort.
14:28:33 <__pao__> Toxaris: clear
14:28:40 <s_clv> ehird: very cute.
14:29:27 <ehird> s_clv: you propose something better
14:29:35 <s_clv> just wait :-P
14:30:18 <Toxaris> __pao__: trait Ext2 extends Base { type ToBeExtended = Constructor; class Constructor extends Interface }
14:30:32 <__pao__> Toxaris: a straight question.... do you think scala potential expressivness and flexibility (oo and funcional mix) is enough to forgive it's immaturity?
14:30:41 <ehird> s_clv: format int (3 :: Integer)
14:30:46 <ehird> my type classes suck at inferring :P
14:30:48 <s_clv> ehird: does your solution let you chain fors, and ands, and untils?
14:30:50 <Toxaris> __pao__: now we have two extensions, one of them adds operations, the other adds constructors
14:31:10 <s_clv> yeah, you do fancy stuff and the default Num polymorphism bites you .
14:31:36 <Toxaris> __pao__: for research: yes, if you like it. For real-world programming: no clue, I don't do that :)
14:31:58 <EvilTerran> ehird, you might be able to do something with -XExtendedDefaultRules
14:32:17 <Toxaris> __pao__: my biggest problem with scala is it's impurity. why are there no objectfunctional languages
14:32:36 <ehird> s_clv: not even Num polymorphism
14:32:39 <ehird> int :: Formatter Integer
14:32:47 <ehird> EvilTerran: mayb.
14:32:50 <__pao__> Toxaris: my very uninformed feeling is that scala complexity (cross product between functional and OO) doesn't provide real gains in real world programming tasks
14:33:12 <Botje> I thought where scoped over multiple definitions of a function? :(
14:33:23 <EvilTerran> Botje, don't think so, only different branches of a guard
14:33:34 <Botje> ah
14:33:35 <Botje> bugger.
14:33:39 <Toxaris> __pao__: so when we compose these traits, we get an error that the type definitions aren't working out, and somehow we can fix this by mixing in a trait which exactly specifies the new operations, but i forgot how :(
14:33:47 <EvilTerran> Botje, as the top-level parameters are in scope in a where{}, and they're different bindings for each definition
14:33:55 <ehird>     The equation(s) for `format' have four arguments,
14:33:56 <ehird>     but its type `ComposedFormatter a b x y -> b -> y -> String'
14:33:56 <Botje> makes sense, thanks :)
14:33:57 <ehird> Lul whut
14:34:02 * Botje hacks around with a machete and a local function
14:34:15 <__pao__> dcoutts: ping
14:34:15 <EvilTerran> ehird, should that first -> be a => ?
14:34:21 <Toxaris> Botje: you can use    f a b c = case (a, b, c) of ... where ...
14:34:51 <Botje> hmm
14:34:53 * Botje tries
14:35:02 <__pao__> Toxaris: clear...
14:35:07 <ehird> EvilTerran: Hm, unsure
14:35:11 <Toxaris> __pao__: Scala is a clear advantage over Java
14:35:17 <ehird> Oh
14:35:17 <ehird> I see
14:35:29 <ehird>     Could not deduce (FormatType x (y -> [Char]))
14:35:30 <ehird>       from the context (FormatType
14:35:30 <ehird>                           (ComposedFormatter a b x y) (b -> y -> String))
14:35:31 <ehird> :DDDD
14:35:32 <__pao__> Toxaris: I'm weighting it against haskell
14:36:10 <dmwit> Okay, so I'm playing with a writing a constraint solver for Sudoku.
14:36:18 <monochrom> Immutable OO languages are a pain to use. You say "return new object instead of mutate old one".  OK, but you also have to make all existing objects who referred to the old now refer to the new.  You wanna write code to do that?  You're replacing a whole object graph, the whole heap.
14:36:30 <RayNbow> @faq Can Haskell sooth the pain of 45+ hours DSL downtime?
14:36:30 <lambdabot> The answer is: Yes! Haskell can do that.
14:36:40 * RayNbow starts ghci
14:36:41 <dmwit> I have functions "(row|column|value)Neighbors", where xNeighbors means the neighbors in which "x" varies.
14:36:46 <dcoutts> __pao__: pong
14:36:58 <__pao__> dcoutts: sorry for disturbing...
14:36:59 <Toxaris> monochrom: how is that argument related to OO? It sounds like a general counter-purity argument.
14:37:03 <dmwit> (So "rowNeighbors" returns a list of all the squares in the same *column*.)
14:37:19 <dmwit> What should I name the function that returns a list of all the squares in the same block?
14:37:20 <__pao__> do you have a pattern for OO haskell and 'mutating' operations?
14:37:29 <dmwit> "blockNeighbors" doesn't fit the pattern...
14:38:03 <dcoutts> __pao__: actually it's easier than I was saying for most cases, since it just returns something of the same type
14:38:05 <Toxaris> dmwit: farAwayNeighbors
14:38:08 <monochrom> It's related to OO because OO is the biggest user of "need update one way or another".
14:38:21 <dmwit> Toxaris: hehe
14:38:29 <Toxaris> monochrom: hypothesis: because there is no pure lazy OO language yet
14:38:31 <mib_16qbv6> Hello guys
14:38:38 <Cale> hello
14:38:39 <__pao__> dcoutts: thanks
14:38:48 <dmwit> Hiya, mib_16qbv6!
14:39:06 <dcoutts> __pao__: the really tricky case (we're talking 0.00..% of cases here) is needing those mutative ops and needing to be able to relate different instances of the same class, then we need more type trickery like existential types
14:39:13 <monochrom> You can try to zipper it.
14:39:19 <Toxaris> monochrom: we live without updates in Haskell and invent zippers instead or restrict ourselfs to the implicit thunk updates from laziness. why shouldn't that be enough for OO?
14:39:40 <Sadache> i have a question that might be stupid
14:39:45 <dcoutts> __pao__: there are papers that explain OO features in FP languages that you can read
14:39:53 <__pao__> dcoutts: I'll ask for help when I'll meet one of those 0.00 % cases :-)
14:40:14 <ehird> who wants to help my typesafe formatter BLOSSOM
14:40:15 <ehird> :3
14:40:15 <__pao__> dcoutts: "the expression problem" is the right keyword, right?
14:40:20 <ehird> it handles everything but composed types!
14:40:24 <dcoutts> __pao__: yep
14:40:30 <Sadache> can i in haskell extend a datatype?
14:40:30 <Toxaris> __pao__: the "problem" with functional update in OO only shows up when you model subclassing somehow
14:40:33 <dcoutts> __pao__: another good advanced topic is continuations, but perhaps leave that for another day :-)
14:40:39 <ehird> @hpaste
14:40:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:40:50 <__pao__> dcoutts: thanks :-)
14:40:59 <Cale> Sadache: In the most general sense, no, but it depends on what you mean :)
14:40:59 <monochrom> At this point I think science dictates that you demonstrate how immutable OO programs work out rather than me prove it won't work out.
14:41:03 <dmwit> Sadache: Extend how?
14:41:16 <Toxaris> Sadache: datatype as data X = ...? No, they are closed. there are a number of work-arounds of course.
14:41:19 <dmwit> Sadache: You can add functions that play with the data type, and you can write new instances for the data type.
14:41:22 <Sadache> Person >> Student
14:41:37 <Cale> You can construct a new datatype, one of whose constructors holds a value of the old type.
14:41:48 <Toxaris> Sadache: could be handled as data Student = Student Person AdditionalInfo
14:41:57 <monochrom> I have certainly tried immutable OO myself a bit, and I see a big problem. I don't know a solution. Maybe you have a solution.
14:42:00 <Sadache> but if i want only for example to add fields
14:42:12 <dmwit> Sadache: Inheritance is not as useful in Haskell, because type classes and data types are separated more carefully.
14:42:20 <Sadache> monochrom: that is composition
14:42:50 <Cale> Sadache: yeah, probably something like Toxaris' example is what you want.
14:42:53 <Toxaris> monochrom: that part about science sounds true. still, I can ask people now or then, hoping someone will do the work for me
14:43:02 <Sadache> dmwit: and i love that, but i am trying to imagine how can i extend type abstraction
14:43:17 <Toxaris> monochrom: a big problem generally, or a specific big problem?
14:43:36 <ehird> http://hpaste.org/7624 Incomplete type-safe formatter. The composing stuff doesn't work :<
14:43:54 <monochrom> I have said the problem. You just think it's nothing.
14:44:24 <Cale> Sadache: Some people have suggested that supporting (optionally) open datatypes would be a nice extension to Haskell.
14:44:48 <Sadache> Cale: but it doesn't exist does it?
14:44:58 <Cale> No, not at the moment.
14:45:15 <Sadache> and do u think it is necessary?
14:45:16 <Cale> If you want to extend a datatype, you currently just create a new datatype.
14:45:18 <Toxaris> monochrom: not at all. just wanted to check that you mean the "OO style is a big graph of objects and we want to change only one of them at a time" problem
14:45:32 <Cale> I don't think it's necessary. There are cases where it would be convenient though.
14:45:45 <Cale> I think having a proper record/variant system would be great.
14:46:02 <ehird> bleh
14:46:03 <ehird> :
14:46:04 <ehird> :\
14:46:14 <Sadache> I mean both Car and Bus types share fields but i found no way to abstract that
14:46:38 <Cale> There are cases where interfacing with external systems (particularly ones designed for use in OO languages) is hard, because functional programming doesn't really fit in very well with large product types.
14:46:59 <Cale> (at least in Haskell)
14:47:22 <Cale> With a proper record system, that pain would perhaps be somewhat alleviated.
14:47:50 <Toxaris> monochrom: it's clearly a big problem, but it's importance depends on how you define OO. if you say "supports current OO style", then functional OO doesn't make sense, because the current OO style. maybe any other definition is pointless, and I should search for FP with subtyping instead, or just use Haskell with existentials.
14:48:14 <Toxaris> monochrom: no, not its "importance", but its "impact on this question" or something
14:48:42 <Toxaris> monochrom: and "because the current OO style clearly depends on mutable state"
14:49:03 <Cale> In my head, the essence of OO programming is support for features which make working with existentials natural.
14:49:31 <Cale> (and not really anything to do with state, though the OO people certainly seem to like state)
14:49:38 <Sadache> Toxaris: with your example Student = Student Person AdditionalInfo , I have to call two type constructors to get the student right?
14:50:05 <Toxaris> Sadache: yes. but you can write   student x y z = Student (Person x y) z
14:50:15 <tromp> sorry for being off-topic, but how to set a Perl array to n zeros?
14:50:26 <ehird> tromp: wow
14:50:28 <ehird> that IS off-topic
14:51:21 <vixey> tromp, ummmmm..
14:51:47 <ehird> I don't even know what to say
14:51:47 <ehird> :D
14:51:48 <pizza_> @foo = (0) x $n;
14:51:49 <lambdabot> Maybe you meant: faq ft todo yow
14:51:49 <Sadache> Toxaris: it is a helper function right?
14:51:56 <ehird> 'sorry for being off-topic'
14:51:58 <ehird> '/j #perl'
14:51:58 <Toxaris> Sadache: yep
14:51:59 <ehird> Compare.
14:52:04 <zooko> Hello John Trimp.
14:52:15 <zooko> Oops, I meant John Tromp, sorry.
14:52:20 <tromp> now there's a new mis-spelling:)
14:52:20 <EvilTerran> tromp, pizza_: note the ()s around the 0 are necessary, otherwise you'll get a string of n "0"s
14:52:33 <__pao__> Toxaris: monochrom: Cale .... please continue the discussion! I was finding it very interesting ;-)
14:52:33 <tromp> hi zooko
14:52:54 <monochrom> discussion is a waste of time
14:53:05 <quicksilver> Cale: I don't really find the big product types particularly hard.
14:53:14 <Sadache> so there is not obvious way to 'extend' a type, but maybe it is necessary is haskell, I guess it is just my oop mindset that makes me think in terms of inheritence for datatypes
14:53:16 <quicksilver> Cale: modelling complex inheritance nets is not fun though.
14:53:17 <monochrom> reasoning, doing, learning are not.
14:53:17 <ehird> Anyone know a little language with easy dependent types?
14:53:21 <ehird> Wanna play around with it
14:53:30 <quicksilver> Cale: but I'm not sure complex inheritance nets are a good thing :)
14:53:32 <ddarius> quicksilver: complex inheritance nets are not fun
14:53:34 <pizza_> EvilTerran: they are necessary
14:53:41 <quicksilver> ddarius: quite
14:53:46 <EvilTerran> pizza_, yes, that's what i said
14:53:54 <dmwit> ehird: Coq, I think?
14:54:00 <vixey> quicksilver, it is! there's a book AMOP about it
14:54:05 <Cale> quicksilver: Not so much hard as awkward. There are some systems out there which would need lots and lots of record types with dozens of fields, which just isn't how you expect to do things in Haskell.
14:54:05 <quicksilver> agda is maybe more approachable?
14:54:06 <pizza_> sorry, read you wrong
14:54:23 <vixey> I wouldn't recommend Agda over Coq
14:54:23 <Cale> (especially as you can't share field labels)
14:55:19 <EvilTerran> ehird, it'd be cool to get a statically-checked one that ensured that the substitution markers and the other parameters matched, too
14:55:30 <EvilTerran> ehird, but i can't think how to do that at the moment
14:55:40 <vixey> EvilTerran: delimited continuations ?
14:55:43 <ehird> dmwit: Coq isn't a Real Language tohugh.
14:55:47 <vixey> ehird: yes it is
14:55:49 <ehird> I mean, I want something I can write Hello, world! in
14:55:49 <ehird> ;)
14:55:56 <ehird> vixey: OK, but it's more a theorem prover.
14:56:00 <EvilTerran> Agda's a Real Language - doesn't that have dependent types?
14:56:01 <ehird> I'd like Haskell, but dependently typed ;)
14:56:03 <vixey> ehird: and the difference?
14:56:16 <Philippa> vixey: the emphasis
14:56:17 <zooko> tromp: Are you the John Tromp from Amsterdam in about 1996?  I haven't heard back from you in private messages, possibly because this IRC server requires you to register for an account before it will deliver your priv msgs -- anti-spam measure.
14:56:31 <vixey> EvilTerran: http://www.lri.fr/perso/~sozeau/repos/coq/misc/shiftreset/GenuineShiftReset.html
14:56:33 <lambdabot> Title: GenuineShiftReset, http://tinyurl.com/2ywh6h
14:56:34 <Philippa> Coq has been developed on the assumption that 'real work' gets done with tactics
14:56:34 <EvilTerran> ehird, i think you'd like Agda, then
14:56:38 <vixey> maybe not what you meant, but this is cool
14:57:08 <ehird> Isn't Clean dependently-typed?
14:57:08 <Philippa> which isn't to say that it can't be used as a programming language first
14:57:18 <Philippa> ehird: no, Clean has uniqueness types
14:57:31 <ehird> Philippa: Can I make (head []) a type error in it?
14:57:34 <EvilTerran> vixey, looks perfect, actually
14:57:36 <ehird> what about (printf "%i" "abc")?
14:57:45 <Jaak> ehird: yes
14:57:55 <vixey> ehird: what is the type of "%i" ?
14:58:02 <ehird> vixey: "%i" is a string, I believe. :P
14:59:20 <Jaak> oh, clean. i read "agda" for some strange reason
14:59:22 * EvilTerran isn't surprised that Oleg is partly responsible for that printf-as-delimited-continuations idea
14:59:49 <EvilTerran> I swear Oleg sees the Haskell type-system the way normal people see Sudoko or something.
15:00:12 <ddarius> EvilTerran: As a mindless game to pass time?
15:00:26 <ddarius> EvilTerran: You might be interested in Kenichi Asai's work on printf and delimited continuations.
15:00:53 <EvilTerran> well, as a fairly simple set of rules that require a good deal of being able to juggle lots of stuff in your head to be able to apply effectively
15:00:53 <dons> "Security engineers see the world differently than other engineers. Instead of focusing on how systems work, they focus on how systems fail, how they can be made to fail, and how to prevent--or protect against--those failures."
15:01:07 <dons> That sounds a lot like the Haskell mindset.
15:01:12 <EvilTerran> if you want a more flattering look at it, s/Sudoku/Go/
15:01:26 <Philippa> normal people find Go incomprehensible though
15:01:36 <EvilTerran> ok, that works, then :P
15:01:42 <Philippa> also, it's 2-player
15:02:06 <EvilTerran> well, doing things in the type-system would be more like doing go problems, which you could argue are 1-player
15:02:34 <EvilTerran> seeing as you're taking a specific case of trying to apply the rules to a positive end result, with a few things setu up already
15:02:52 <monochrom> I am a formal method person. I focus on both. In fact they are one. Perhaps you can say two sides of one coin.
15:03:04 <EvilTerran> ddarius, yeah, vixey posted a link to that a few minutes ago
15:03:53 <vixey> no I didn't
15:04:04 <dons> formal methods hackers see the world differently from other programmers. Instead of focusing on how things work, they focus on all assumptions and holes in the reasoning"
15:04:13 <ddarius> EvilTerran: Indirectly I guess.
15:04:23 <ivanm> dons: so you're saying all haskellers are security engineers? :p
15:04:31 <EvilTerran> vixey, "AK07, Polymorphic delimited continuations, Asai and Kameyama" - from that link you posted
15:04:40 <zooko> The E language and its descendants are concerned with the antagonize two player security game of mutually untrusting programmers invoking one another's code.
15:04:56 <dons> no, i'm saying the haskell mindset we talk about, where we are gobsmacked at what other people leave as runtime errors, is like the security mindset
15:05:30 <dons> we focus on how things are going to destroy reasoning, on how programmer decisions compromise runtime safety
15:05:43 <dons> while other programmers just shrug this off
15:05:44 <monochrom> A formal specification looks like something equivalent to what you may consider as {precondition}[what I must do when the precondition is true]. If the precondition is violated, I see how things may fail. If the precondition is established, I see how things work.
15:06:12 <zooko> I understood what you were saying.  I was thinking that there are probably some strong intellectual parallels to the E tradition of capability-secure programming languages.
15:06:22 <vixey> monochrom: How do you get started with formal methods?
15:06:23 <joao> monochrom,  It's more {pre-condition}Program{pos-condition}
15:06:36 <dons> we obsess about safety. and very few programmers understand why we go on and on about safety, control, precision, invariants and proofs
15:06:40 <ddarius> EvilTerran: That's not it.  The other one (the technical report) is the paper I was referring to.  (Though that first one does briefly discuss it.)
15:06:48 <EvilTerran> oh, ok
15:07:00 <dons> the article that made me think of this, http://reddit.com/info/6jf39/details
15:07:12 <EvilTerran> ooh, ooh, people are talking about formal program design
15:07:20 * EvilTerran has a finals exam on that in a few weeks
15:07:38 <monochrom> These days the "program{postcondition}" part is merged into [what must I do].
15:08:01 <zooko> dons: yes, much like E programmers, but using different tools and intellectual techniques.
15:08:31 <Sadache> like Eiffel?
15:08:38 <ddarius> E programmers would be pretty unhappy with Haskell and Haskell programmers would be somewhat unhappy with E.
15:08:39 <monochrom> Oh, I see the misunderstanding.
15:08:44 <Sadache> and Spec#
15:09:00 <ehird> OPINIONS
15:09:00 <ehird> format (F.str % F.listBy (++ notLast ", ") % F.int) "foo" ["bar","baz"] 2
15:09:06 <ehird> => "foobar, baz2"
15:09:13 <monochrom> I said "specification".  The program (implementation) is omitted.
15:09:41 <EvilTerran> we're still using Dijkstra's Guarded Command Language, circa 1975 according to my brief research
15:09:49 <vixey> monochrom: (honest question)
15:10:09 <vixey> EvilTerran: did you see A Discipline of Programming?
15:10:16 <ddarius> EvilTerran: We're still using the lambda calculus circa 1932 according to my brief research.
15:10:21 <vixey> EvilTerran: I thought it was an excellent book
15:10:43 <monochrom> You can start with any formal method book.
15:10:59 <ddarius> "Formal Methods for Dummies"
15:11:04 <EvilTerran> ddarius, nyah :P ... i mean, i'm sure there's fresher formal method languages out there. that was in response to monochrom's "These days..." comment.
15:11:17 <vixey> lol
15:11:28 <joao> monochrom, oh, I see. I always write a Hoare triple, with a variable P as the spec. Then P  gets refined at each step..
15:11:31 <ehird> nobody? :P
15:11:36 <EvilTerran> vixey, i've seen it in the college library, and read the preface, but no more than that. our course textbook is Morgan - Programming from Specifications
15:11:58 <zooko> ddarius: agreed.  I think I just wanted to alert dons that Haskell programmers are not unique in the universe in respect to what he said.
15:12:04 <dcoutts> EvilTerran: ah yes, that's not changed in years :-)
15:12:13 <monochrom> I of course plug the shameless plug of suggesting my supervisor's: http://www.cs.toronto.edu/~hehner/aPToP/ .  Even if you don't like it, you can still look for books it lists near the end for alternatives.
15:12:14 <lambdabot> Title: a Practical Theory of Programming
15:12:31 * dcoutts did an impl of Morgan's data language
15:12:37 <vixey> thanks monochrom
15:12:45 <monochrom> Another book I suggest is Lamport's "Specifying Systems".
15:13:03 * EvilTerran has a few things he'd do differently to the language presented in Programming from Specifications
15:13:16 <dcoutts> EvilTerran: such as?
15:13:17 <monochrom> Hoare himself has ditched Hoare's triple for a long time.
15:13:22 <EvilTerran> but what do i know, i'm only an undergrad, i'm probably wrong :P
15:14:00 <ddarius> Hey!  I think I technically count as an undergrad now.  'not sure if I did before.
15:14:24 <EvilTerran> dcoutts, mostly notational things, really. ways to make it less painful to write out in pen. replacing |[ ... ]| with layout or ()s, say.
15:15:06 <zooko> I am skeptical that all of these techniques of specification and proof are an effective path to achieving high-assurance systems.
15:15:29 <EvilTerran> also "fi" and "od" make me wince ;)
15:15:29 <monochrom> I am skeptical too.
15:15:47 <monochrom> I think the most effective path is taking the human out of the loop.
15:15:52 <zooko> I'm not claiming that they are *not* an effective path, but I'm claiming that whether they are or not is an empirical question rooted in human psychology and systems engineering, and it has never been investigated empirically, only assumed by some and assumed away by others.
15:15:53 <roconnor> I see no reasonable alternative
15:15:54 * dons notes he is surrounded by people whose jobs are proof and specification
15:15:58 <MyCatVerbs> EvilTerran: esac and elihw have a nice ring to them, though.
15:16:14 <dcoutts> EvilTerran: I'd forgotten the notation. I should remember really, I wrote a compiler for it :-) perhaps it's scarring
15:16:15 <joao> As monochrom, I have to suggest my supervisor's book too: "Program Construction (Calculating Implementations from Specifications)"
15:16:21 <thetallguy> dons: can you prove that?
15:16:21 <dons> it is very hard to convince governments to install your code without rigorous assessment.
15:16:34 <EvilTerran> dons, *snrk*
15:16:43 <EvilTerran> (sorry)
15:16:48 <vixey> joao: available online?
15:17:01 <EvilTerran> (too used to dealing with horrifically buggy public-funded softwares)
15:17:08 <MyCatVerbs> dons: what on EARTH are you talking about?
15:17:18 <ddarius> EvilTerran: I could take offence to that.
15:17:28 <EvilTerran> ddarius, in what way?
15:17:38 <MyCatVerbs> dons: military firmware, yes, I could see that. Maybe financial modelling. But, uh, government software in general? Surely you jest.
15:17:42 <ddarius> EvilTerran: In that I produce software funded by the public.
15:17:42 <vixey> so unsafeLaunchNuclearMissiles is a realy function?!
15:17:44 <EvilTerran> i'm just saying *some* gov't software is awful, not all of it.
15:17:52 <joao> vixey, no, unless you're a student in nottingham (or if you have access to athens, I think)
15:18:12 <EvilTerran> dcoutts, actually, the thing that really bothers me is the use of variable capture in the predicates and whatnot
15:18:16 <dfrey> Say I have 2 data types defined called Marker and Node.  Is it possible to defined an additional data type called Result that can be either a Marker or a Node?
15:18:16 <vixey> yeah I wish I was at nottingham :p
15:18:25 <vixey> dfrey: No
15:18:40 <dcoutts> EvilTerran: remind me
15:18:43 <vixey> dfrey: You could instead use (Either Marker Node)
15:18:47 <dcoutts> what's the problem there?
15:18:48 <ddarius> EvilTerran: I could take offence, but I wouldn't.  Anyway, -most- software, publically-funded or otherwise, tends to be horribly buggy.
15:18:48 <vixey> dfrey: which is the sum of the two types
15:19:53 <Cale> dfrey: Or something like:  data MyType = M Marker | N Node
15:20:31 <dfrey> vixey: So I might want to create a type synonym by doing "type  Result = (Either Marker Node)
15:20:40 <vixey> you could
15:21:23 * EvilTerran accidentally deletes the epic line he was typing. DAMMIT.
15:22:35 <EvilTerran> dcoutts, take the line "The specification w:[pre, post] is feasible in context inv  iff  (w = w0 && pre && inv) ==> (exists w. inv && post)"
15:23:23 <EvilTerran> dcoutts, the "w"s in "inv && post" are captured by the "exists w". this *really* bugs me.
15:24:18 <Saizan> EvilTerran: you mean that inv and post should be closed and get w as parameter if they need it?
15:24:27 <EvilTerran> it's as if everything's dynamically instead of lexically scopes.
15:24:30 <EvilTerran> Saizan, exactly.
15:25:11 <monochrom> Skipping the "w:" for the moment.  There is dilemma in deciding whether you should write [x>0, x=x0+1] or [lambda x. x>0, lambda x0,x. x=x0+1].  One of them is risky as you said. The other is clumsy and unnecessary most of the time.
15:25:29 <ddarius> Yeah, programmers (particularly programmers with sophisticated scope nesting) really tend to dislike that sort of thing.  More mathematical types do that often.
15:25:47 <EvilTerran> i also have strong memories of my formal logic lecturer hammering into us the importance of only doing "safe substitutions"
15:26:09 <EvilTerran> ddarius, same goes for single-letter variable names, i've noticed. physicists are criminally bad at that one, too.
15:26:34 <EvilTerran> "current, eh? what shall we call that? ooh, ooh, i know! 'I'!"
15:27:01 <EvilTerran> "now, what about energy? we've already used E for electromotive force, so let's use... er... how about W?"
15:27:05 <ehird> what is the forall. extension?
15:27:38 <monochrom> But I don't mind [x>0, x=x0+1]. Yes yes yes we have free variables amok and we deliberately capture them later.  But we do it properly.  We make sure all free variables are state variables and no more.  It's still safe.
15:27:45 <EvilTerran> ehird, RankNTypes or ExistentialQuantification, i think. they're subtly different, iirc, but i don't know how.
15:31:03 <EvilTerran> monochrom, yeah, i guess. it just takes a bit of getting used to.
15:31:38 <EvilTerran> i'm tempted to just retreat to pure functional programming so i can wholly avoid that sort of thing ;)
15:32:34 <vixey> hm
15:32:48 <monochrom> You could take the whole Morgan book and close all formulas and adjust definitions accordingly. It's an equivalent theory and just adds maybe 5% overhead.
15:33:48 <EvilTerran> monochrom, to be honest, when i'm trying to do revision for that class, i'm sorely tempted to procrastinate thusly.
15:34:41 <monochrom> This issue is orthogonal to functional vs imperative.  I could easily write a functional formal method book with free variables amok, e.g., instead of talking about f I could take about f x.
15:37:01 <dobblego> if you have an issue a that is orthogonal to issue b, which is orthogonal to issue c, which is orthogonal to issue d, which is orthogonal to issue e, is a = e or do the right-angles take different directions in orthogonality?
15:37:36 <Cale> dobblego: Depends on how many dimensions the space has? :)
15:37:41 <ddarius> dobblego: Orthogonality can be in higher dimensions.
15:37:42 <monochrom> This hour has six dimensions. You don't have enough issues up there yet.
15:37:52 <dobblego> ah yes, didn't think of that
15:38:10 <Cale> But in general, if a is orthogonal to b which is orthogonal to c, it's not necessarily the case that a is orthogonal to c
15:38:46 <ddarius> Cale: Obviously.
15:38:58 <monochrom> I use "orthogonal" casually. I didn't actually measure.
15:40:19 <Cale> Also, two things can be linearly independent without being orthogonal, of course :)
15:40:21 <monochrom> Indeed even the orthogonality claim I made above isn't complete true. It is easier to use free variables when you create a formal method for imperative programming. It is easier to use closed formulas when you create a formal method for functional programming.  They are slightly dependent.
15:40:51 <ddarius> Cale: That follows from the fact that 'is orthogonal to' is commutative and anti-reflexive (perhaps making up a term).
15:41:47 <monochrom> You assumed "a /= c".
15:42:13 <monochrom> a_|_b, b_|_c, c=a is possible.
15:42:54 <Cale> It's also possible for c to be a scalar multiple of a
15:43:15 <Cale> (so not equal, but not orthogonal either)
15:45:43 <monochrom> hard to imagine "issue X is issue Y scaled up"
15:46:09 <monochrom> Haha, require all issues to be normalized!
15:46:11 <Cale> Or inverted?
15:46:26 <Cale> Or are issues really in projective space?
15:46:47 <ehird> Does nobody like typesafe printfs?!
15:46:52 <monochrom> issue "should you learn haskell" vs issue "should you not learn haskell"? :)
15:47:02 <Cale> ehird: I like concat and show ;)
15:47:09 <mauke> typesafe printfs are too hard to use
15:47:25 <ehird> mauke: hardly
15:47:33 <mattster> is haskell as inefficient for simple things involving IO as some people say it is?
15:47:41 <ehird> format (F.str % F.listBy (++ notLast ", ") % F.int) "foo" ["bar","baz"] 2        => "foobar, baz2"
15:47:42 <mauke> mattster: no
15:47:43 <ehird> how is that hard to use?
15:47:43 <Cale> There's something just so *wrong* about encoding formatting specs as a string.
15:47:44 <conal> is there a hackage package with classes for vector spaces and affine spaces?
15:47:47 <vixey> mattster: yes and no, depends who's saying how hard
15:47:50 <ehird> Cale: nope its not as a string
15:47:54 <ehird> format (F.str % F.listBy (++ notLast ", ") % F.int) "foo" ["bar","baz"] 2        => "foobar, baz2"
15:47:57 <dobblego> mattster, there are many myths from the silly crowd
15:47:58 <Cale> Then it's not printf
15:48:07 <Cale> ;)
15:48:40 <mattster> from people who don't know haskell, in other words?
15:48:45 <ehird> Cale: Well, no. But it's a type-safe formatter.
15:48:46 <mauke> ehird: how do I say printf "(%02d) buttercup %5.2f\n" x y in your system?
15:48:58 <ehird> mauke: Using one of the various formatters
15:49:02 <ehird> Anyway
15:49:04 <Cale> mattster: not really.
15:49:04 <ehird> Translation time
15:49:04 <dobblego> mattster, they clearly don't, if that make such a fundamental error
15:49:07 <ehird> format (F.str % F.listBy (++ notLast ", ") % F.int) "foo" ["bar","baz"] 2
15:49:08 <ehird> ===>
15:49:25 <Cale> mattster: Understanding the performance of Haskell programs takes quite a bit of time and practice though.
15:49:30 <ehird> (format "~a~{~a~^, ~}~a" "foo" (list "bar" "baz") 2)
15:49:40 <mauke> ehird: see? too complicated
15:49:41 <ehird> (CL format)
15:49:47 <ehird> mauke: um, that's just common lisp's format function
15:49:47 <monochrom> I like your listBy combinator. This is beyond printf.
15:50:00 <ehird> monochrom: Yeah -- I'm translating it from the common lisp FORMAT function, as can be seen above.
15:50:00 <mauke> ehird: no, I'm talking about "Using one of the various formatters"
15:50:02 <ehird> But, you know, type safe.
15:50:06 <Cale> mattster: (Similar to how learning to recognise performance problems in your first programming language took time and practice)
15:50:27 <Cale> mattster: Thankfully, there are good tools to help -- GHC has an excellent profiler.
15:50:33 <ehird> mauke: Well, specify %5.2f in human words.
15:50:35 <ehird> And I'll tell you.
15:50:46 <mauke> so you don't even know printf :(
15:50:55 <ehird> mauke: I do.
15:50:57 <monochrom> Writing fast, correct, short programs is difficult for beginners. Truism.
15:51:01 <ehird> Just not off by heart for everything.
15:51:06 <ehird> Suprise - printf is not the most readable thing!
15:51:10 <vixey> writing correct programs is difficult
15:51:11 <mauke> ehird: field width 5 (pad with spaces), 2 digits after the decimal point
15:51:19 <ehird> mauke: Then:
15:51:20 <vixey> whether you are a beginner or not
15:51:38 <ehird> F.fieldWith 5 (F.decimalPlaces 2)
15:51:41 <ehird> mauke: Or similar.
15:51:42 <Cale> Writing fast, short, incorrect programs is easy ;)
15:51:43 <ehird> Not hard at all.
15:51:48 <vixey> Cale, :D
15:51:55 <mauke> ehird: too hard to use
15:52:03 <mauke> and that's not a complete example
15:52:05 <monochrom> Forgetting "short" for the moment.  Some languages make it easy to write fast and incorrect programs for beginners.  You can't compare it with some language that makes it easy to write correct and slow programs for beginners.  Apples and oranges.
15:52:20 <ehird> mauke: I can't tell if you're trolling or just .. actually, I don't think you can be anything else. How on earth is "F.fieldWith 5 (F.decimalPlaces 2)" hard to use?!
15:52:21 <mattster> cale: i thought the type system made that difficult
15:52:26 <ehird> oh and *fieldWidth
15:52:35 <Cale> mattster: I was thinking of something like  main = return ()
15:52:47 <vixey> ehird: compare it with %5.2f
15:53:00 <mauke> ehird: it's completely and utterly unreadable
15:53:08 <thetallguy> conal: all I see is hmatrix.  Haven't looked at it at all.
15:53:16 <ehird> mauke: okay then, what about
15:53:23 <ehird> F.pad 5 (F.fPlaces 2)
15:53:24 <conal> thetallguy: thx.
15:53:29 <Cale> It's certainly fast and short... but unless you're implementing the unix 'true' program, it's incorrect ;)
15:53:31 <thetallguy> conal: I think there is more code out there that hasn't been cabalized
15:53:34 <ehird> since apparently short things like %5.2f are totally better than "F.fieldWith 5 (F.decimalPlaces 2)"
15:54:02 <ehird> And it certainly beats the sh*t out of concat+show.
15:54:05 <conal> i'll make a new package with the abstract interface and some very generic functions.
15:54:13 <ehird> And if you just use regular printf, why are you using haskell? Type-safety, peeps.
15:54:22 <conal> vector spaces, inner product spaces, and affine spaces
15:54:38 <Botje> ehird: gcc can typecheck printf-like functions
15:54:39 <Cale> ehird: Why not just write a function to format floating point values?
15:54:42 <Botje> but that's an extension :)
15:54:52 <mauke> ehird: compare (printf "(%02d) buttercup %5.2f\n" x y) vs (format (F.str % F.pad ' ' (F.width 2) % F.str % F.width 5 (F.precision 2) % str) "(" x ") buttercup " y "\n")
15:55:06 <mauke> your function looks like C++ iostreams
15:55:17 <mauke> oh, and I forgot an F.
15:55:22 <ehird> Botje: Yes. Yes it can. GHC can't.
15:55:28 <monochrom> All EDSLs look like C++ iostreams.
15:55:36 <monochrom> More precisely iomanip.
15:55:42 <Botje> you could write a TH wrapper that converts format strings to what ehird expects
15:55:52 <Botje> (note the "you", i'm not qualified for this :)
15:55:54 <ehird> mauke: Uh, what about:
15:56:08 * Cale fails to understand what's wrong with concat and show (combined with a handful of formatting functions for numeric values)
15:56:47 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a
15:56:48 <lambdabot> Title: Why isn&#39;t X mainstream?---A oldbie&#39;s view - comp.lang.functional | Googl ..., http://tinyurl.com/6fxlo6
15:56:57 <ehird> mauke:  format ("(" % F.pad 2 F.double % ") buttercup " F.pad 2 (F.doublePlaces 2) % "\n")
15:57:04 <monochrom> This is about how faster C is than Haskell.
15:57:15 <ehird> mauke: So, yes, when you misrepresent my function - it's unreadable!
15:57:27 <mauke> still unreadable
15:57:31 <vixey> ehird: readable is a subjective
15:57:39 <ehird> mauke: So use template haskell to translate it.
15:57:44 <ehird> Which is, actually, a really good idea.
15:57:50 <mauke> the advantage of printf is that you can easily see what's going on
15:57:51 <Cale> "This slows down Haskell, in that if the programmer mistakenly uses an invalid index, the process of corrupting data or behaving badly is slowed down or even completely brought to a halt."
15:58:08 <Botje> monochrom: heh. i still like the comeback :)
15:58:15 <mauke> you have a mostly static template with a few %X specifiers that tell you where the data goes
15:58:20 <ehird> mauke: Sousetemplatehaskelltotranslateit
15:58:21 <monochrom> what comeback?
15:58:36 <Botje> the last paragraph
15:58:42 <mauke> ehird: in that case I can just use show + concat
15:58:49 <mauke> it's compiler output
15:59:07 <monochrom> Yes! :)
15:59:11 <ehird> mauke: Whatever. I like my function.
15:59:31 <Botje> functions need love too.
15:59:42 <mauke> I don't make enough type errors in printf to use your version instead
16:00:54 <vixey> mauke: it's not possible to have Template Haskell provide type annotations?
16:01:19 <atsampson> is anyone here going to Fun in the Afternoon tomorrow?
16:01:38 <mauke> vixey: adding a question mark to a statement does not make it a question
16:02:04 <monochrom> You have to add some lambdas.
16:02:31 <vixey> mauke: whenever a statement ends in a question mark either prove or disprove it
16:02:46 <monochrom> Scratch that. You have to add a type signature.  :: Question Bool
16:02:54 <mauke> no?
16:03:53 * Botje LOLs at that nick
16:04:04 <monochrom> mauke: adding ? to a statement does not make it an answer  <duck> :)
16:04:38 <monochrom> luckylurker?
16:06:29 <dmwit> Okay.
16:06:48 <dmwit> My rewrite made this thing half as long (in terms of lines), twice as smart...
16:06:56 <dmwit> and about 10x slower. =P
16:10:05 <ehird> dmwit: Write in C!
16:10:12 <dmwit> Yuck.
16:10:23 <dmwit> I can't imagine how long it would take me to write (>>=) in C.
16:10:33 <ehird> dmwit: Hahaha.
16:10:51 <ehird> Hmm.
16:11:03 <ehird> Who would be interested in a library full of Wonderful Stuff for doing things at compile-time?
16:11:06 <monochrom> Smart people are slower. Perhaps smart code too.
16:11:23 <osfameron> heh
16:12:11 <osfameron> dmwit: would you want to write >>= in any other language?  It seems to need a fair bit of sugar to make it worthwhile
16:12:31 <ehird> osfameron: lern2humor
16:12:47 <dmwit> osfameron: I probably would not.  But I *would* want something similar to concatMap.
16:13:09 <osfameron> I'd like something like Maybe in Perl
16:13:21 <osfameron> concatMap seems to be covered by Perl's map already though
16:13:59 <ehird> osfameron: Nothing - undef
16:13:59 <ehird> :P
16:14:29 <osfameron> ehird: heh, but without having to do (if (defined $whatever) { more stuff with $whatever })
16:14:37 <monochrom> I'll refrain from refuting that. It's probably a joke.
16:14:58 <ehird> monochrom: 'tis
16:15:00 <osfameron> yeah, I'm having trouble with the funnyscanner myself :-)
16:15:12 <osfameron> tiredness + rum not helping
16:15:17 <ehird> osfameron: as long as your sarcasm detector is functioning
16:16:31 <monochrom> It is not too difficult. If someone says something clearly wrong, e.g., "perl undef is as reliable as haskell Maybe", or generally "perl is as reliable as haskell", it is clearly a joke. :)
16:17:00 <ehird> Perl is as reliable as haskell.
16:17:24 <osfameron> perl's undef is very reliable at being an undef
16:17:49 <osfameron> it doesn't do the monadic Maybe thing though, but you can certainly rely on it being an undef
16:18:39 <ehird> quantum undef
16:40:25 <gwern> reading that email on -cafe about leksah makes me glad I'm not on windows
16:40:28 <gwern> man, poor guy
16:41:11 <fnord123> url pls
16:41:20 <vixey> what happened?
16:41:21 <ddarius> gwern: I don't have much pity for hi.
16:41:30 * Zao rolls his thumbs while mutt parses the massive mbox.
16:41:47 <gwern> heck, I dunno. mutt doesn't exactly provide URLs for mails you read :)
16:41:52 <gwern> although it *would* be a cool plugin
16:41:59 <fnord123> oh, i use nabble to lurk :)
16:42:07 <Zao> gwern: What's the title?
16:42:15 <Zao> I'm a week behind :(
16:42:21 <gwern> vixey: oh, he was trying to install and run leksah, and ran into a bunch of problems: with darcs, with dependencies, with compiling, and then with running
16:42:31 <vixey> oh ..
16:42:37 <vixey> that sounds like me
16:42:44 <ehird> ddarius: why not?
16:42:45 <vixey> 99% of times I tried to use software
16:42:56 * gwern pities da vixey then
16:43:31 <gwern> anyway, it is a little odd that the windows build of darcs has a runtime dependency on wget, but that's probably the autotools's fault and not so much the fellow
16:44:30 <ddarius> ehird: 1) I have used Haskell software on Windows, 2) Leksah isn't exactly in version 4.6.3, 3) darcs 2 isn't exactly smoothed out yet, 4) it is well known that there is less support for things on Windows.
16:44:43 * edwardk waves hello.
16:44:58 <edwardk> @seen Cale
16:44:58 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 47m 7s ago.
16:45:26 <fnord123> Zao, looks like it's leksah, but the ANN thread calls is lekash
16:46:30 <gwern> easy typo
16:46:57 <ehird> seklah
16:47:05 <ehird> it hates God. And freedom.
16:47:15 <vixey> hi edwardk
16:48:40 * edwardk is searching frantically for his classical analysis notes.
16:48:45 <gwern> ehird: I think seklah is more edit distances than lekash :)
16:49:11 <fnord123> question: what's the best way to disabuse a java minded c++ programmer that object oriented is not a synonym for "good"?
16:49:14 <ehird> gwern: more proof that it hates freedom
16:49:23 <gwern> wait, unless you can transpose across any distance...
16:49:35 <ddarius> fnord123: Swing? MFC?
16:49:44 <gwern> leksah -> swap s and l, seklah
16:49:56 <gwern> fnord123: design patterns?
16:50:07 <ehird> gwern: I'LL TAKE THAT AS PROOF.
16:50:44 <fnord123> ddarius: whenever I bring up actual examples he says "no, we're not talking about a specific implementation. only design" and then my brain explodes a little
16:50:46 <gwern> WHERE IS YOUR GOD NOW
16:50:55 <fnord123> gwern: my colleague is a design pattern junkie
16:51:41 <vixey> fnord123: they might be lost forever
16:52:12 <gwern> fnord123: ...I sort of thought the Design Patterns book would've convinced any sane person that OO has major flaws
16:52:24 <pjd_> fnord123: show them obsoletions of various design patterns
16:53:42 <fnord123> i think my colleague's ideas are fractally wrong. he suggested an idea and i explained how his suggestion was actually an anti-pattern, but he said oh no, his idea is not the same... i didnt bother pursuing it since i will have made a swing. :(
16:54:50 <osfameron> the design patterns book is surprisingly dull, considering how cute Alexander's originals are
16:54:55 <pjd_> encourage them to learn a decent foundational language
16:55:10 <lament> osfameron: probably because architecture is inherently more interesting than programming? :)
16:55:27 <osfameron> lament: could be :-)
16:55:46 <pjd_> it's probably hard to grasp the point while only thinking in Java/C++
16:55:57 <osfameron> I find the antipatterns like "Big ball of mud" and "Ghetto" are much more like the alexander of "pattern language" than the go4 book
16:59:16 <Cale> Design patterns are signs that the language you're using is too inexpressive. Otherwise they'd just be libraries.
16:59:57 <Pseudonym> Cale: I dissent in part.
17:00:17 <Pseudonym> Libraries also come with standard ways of using them.
17:00:40 <Cale> Those ways ought to be expressed with types.
17:05:32 <shepheb> @remember Cale Design patterns are signs that the language you're using is too inexpressive. Otherwise they'd just be libraries.
17:05:32 <lambdabot> Okay.
17:05:52 <vixey> just put the language in a library
17:09:03 <shepheb> there are plenty of other examples of the paper -> book transformation where the same amount of flavour is spread over 50 times more pages, yielding a dull tome rather than a delicious paper.
17:10:13 <monochrom> The existence of the Visitor pattern proves that Java-minded C++ is broken, if not OOP broken.
17:10:44 <vixey> OO is fine
17:10:46 <monochrom> The existence of the Command pattern proves that these are self-congratulating bureacrats.
17:11:02 <vixey> just very seldom useful
17:11:10 <lament> OO is cute
17:11:29 <lament> hardcore OO starts looking a lot like dataflow
17:11:38 <lament> as, in a way, does functional programming
17:11:43 <monochrom> Of course, "proof" does not mean the reader will accept it.
17:11:47 <lament> except you assemble the "pipes" on the fly with OO
17:11:57 <lament> from little tiny sections
17:12:06 <lament> it's fun!
17:12:18 <monochrom> I agree with that assessment.
17:13:01 <monochrom> Anyway, I think it's unwise to plan to convince anyone, especially colleagues.
17:14:48 <shepheb> my Haskell-doubting roommate finally consented to write a small app in Haskell. about an hour in, he's commenting positively, and three hours later we're nearly done, and he's astounded at how beautiful the concurrency is. but it's hard to do in general, Ive been preaching this stuff for months and months.
17:15:46 <monochrom> Yes, no amount of talk-the-talk will do. The reader has to walk-the-walk.
17:15:55 <Zao> shepheb: Thanks to my ranting about Haskell, I've managed to get some class mates interested in it. :)
17:16:52 <shepheb> I started commenting C functions in a group project with equivalent Haskell a while back. I had to stop though, as the C code expanded it started to make me feel ill
17:16:53 <monochrom> But if you're looking for a pick-up line, here is one: the Command pattern is like requiring TPS report cover sheets for your TPS reports.
17:17:54 <monochrom> Yes, someone actually blogged that "don't learn haskell, I learned and now I'm depressed at work" :)
17:18:18 * ddarius is tired of people generalizing their lack of understanding: "I don't understand how something works now and thus it must be something very hard to understand including for everyone else."
17:18:21 <ehird> <interactive>:1:4:
17:18:21 <ehird>     My brain just exploded.
17:18:23 <ehird>     I can't handle pattern bindings for existentially-quantified constructors.
17:18:25 <shepheb> it's been said many times that "the biggest problem with Haskell is how much it makes you hate other languages"
17:18:25 <ehird> ^_____^
17:18:27 <ehird> I DID IT
17:18:30 <ehird> I DID IT I DID IT I DID IT
17:18:39 <ehird> rite of passage #2: COMPLETE
17:18:52 <vixey> shepheb: I hear that about lisp much more
17:19:00 <Saizan> when porting the spread client library i managed to implement a 600 loc C function in 10 haskell ones
17:19:27 <ddarius> 10 600 line Haskell functions?
17:19:29 <shepheb> vixey: it's been said about every geek-loved language that never gets a grip in the industry, I imagine.
17:19:38 <Saizan> ddarius: locs
17:20:53 <lament> it's true of both haskell and lisp
17:21:02 <lament> they make you hate all the other languages, including lisp and haskell
17:21:05 <lament> so beware of learning both!
17:21:22 <monochrom> I hate myself.
17:21:54 <Saizan> lament: use liskell!
17:22:12 <monochrom> liskell worsens the problem.
17:22:34 <shepheb> I imagine in two years, there will be a hundred thousand blogs intoxicated with F# and the "new, innovative" FP features it has. we'll all be making posts about how McKnight told them this in the 60s and they weren't listening.
17:22:50 <lament> liskell makes you hate liskell
17:23:04 <Trinithis> what about haskisp?
17:23:05 <monochrom> {haskell, lisp} makes you hate all other languages, including each other.  liskell makes you hate all languages, including itself. :)
17:23:05 <ehird> liskell makes me hate its creator
17:23:06 <ehird> and babies
17:23:10 <lament> shepheb: yes. we'll be so bitter, so pathetic, and forgotten by all.
17:23:20 <ehird> lament: so let's DANCE
17:23:56 <ddarius> lament: The Haskell community is not the Lisp community.
17:23:57 <shepheb> lament: unfortunately I think you're right. we might also be rich professors teaching the vast swathes of F#-school kids
17:24:04 <shepheb> though we'll hate ourselves for it
17:24:20 * shepheb puts on the Johnny Cash
17:25:53 <conal> are IORefs thread-safe?
17:26:19 <shepheb> I believe they're on the short list of unsafe things
17:26:35 <shepheb> with unsafePerformIO and unsafeSTMtoIO et al
17:26:37 <lament> shepheb: the haskell community is not the lisp community precisely because lisp spectacularly failed (many times!) and haskell hasnt yet
17:26:56 <Trinithis> does anyone know any good comonad sources? I've gotten interested in them
17:26:56 <dmwit> "rich professors"?
17:26:57 <conal> what's a safe way to get IORef-like functionality and thread-safety.  mvars with swapMVar?
17:27:00 <dmwit> Does it really work like that?
17:27:32 <vixey> lament: failed what?
17:27:37 <vixey> miss world?
17:27:52 <shepheb> well, I reason that you'd have to pay us a lot to do something that horrendous, so we'd /have/ to be rich
17:28:02 <ehird> lament: You know what you should do? Write a language that you want to use daily. I'd be interested.
17:28:22 <lament> vixey: Lisp failed in the sense that nobody uses it
17:28:34 <lament> vixey: yet very many of its technologies live on in other languages
17:28:35 <vixey> that's blatantly wrong..
17:28:40 <lament> vixey: which naturally makes the lispers bitter
17:28:50 <lament> "we told you so 50 years ago! but you weren't listening!"
17:28:56 <lament> and everybody else is like "yeah, whatever, go away"
17:29:31 <monochrom> conal: Yes, MVar helps. You can also use a few MVars to control access to lots of IORefs, if you know you'll get it right.
17:29:43 <lament> new language Foo comes out with feature Bar, everybody is like, "holy crap, Bar is awesome!" Lispers go, "We had Bar 50 years ago!" Everybody else: "Yeah, whatever, go away lispers!"
17:29:48 <monochrom> I.e., conventional locking.
17:29:54 <conal> monochrom: thx.
17:29:57 <lament> This will inevitably happen to haskell.
17:30:13 <dmwit> It's happened already.
17:30:24 <dobblego> lament, it already has; Java has watered-down versions of what Java obtained afterward
17:30:24 <pjd_> lament: Haskell happily encourages borrowing
17:30:30 <roconnor> holy crap, dependent types are awsome!
17:30:33 <dmwit> Python: "Holy crap, syntactical indentation is awesome!"
17:30:35 <lament> dmwit: i suppose a little, with the new C# features
17:30:40 <ehird> roconnor: i agree
17:30:47 <ehird> <dobblego> lament, it already has; Java has watered-down versions of what Java obtained afterward
17:30:48 <ehird> lul wut
17:30:53 <dmwit> pjd_: yeah! =D
17:31:02 <vixey> roconnor: why?
17:31:05 <ehird> <dmwit> Python: "Holy crap, syntactical indentation is awesome!"   # abc had this and abc predates haskell
17:31:06 <ehird> afaik
17:31:09 <ehird> but not miranda
17:31:09 <ehird> so
17:31:13 <dobblego> ehird, er, not quite what I intended; Java stole from Haskell
17:31:16 <ehird> i guess it was popular around then
17:31:23 <ehird> dobblego: I wants me some rank-n types in java
17:31:32 <dobblego> ehird, good luck
17:31:49 <dobblego> Java takes a good idea and makes it a really really bad one, more often
17:31:50 <dmwit> With Haskell it's more like new language Foo says, "Holy crap, Bar is awesome!" and Haskell people are like, "Sweet, some other language is finally using Bar!".
17:32:26 <lament> dmwit: yes, i guess there's a difference, we don't actually want the rest of the world to use haskell
17:32:43 <edwardk> yeah unfortunately Haskell seems to be doomed to succeed.
17:32:48 <gwern> > [1..] !! 1
17:32:50 <lambdabot>  2
17:32:55 <Apocalisp> Given a list of numbers xs and a number n, find the number in xs that's nearest n. What am I describing?
17:32:56 <roconnor> vixey: http://reddit.com/info/6j3hn/comments/c03zlr0
17:33:13 <dmwit> Apocalisp: findMin
17:33:18 <roconnor> ``While conventional type systems allow us to validate our programs with respect to a ﬁxed set of criteria, dependent types are much more ﬂexible, they realize a continuum of precision from the basic assertions we are used to expect from types up to a complete speciﬁcation of the program's behaviour.
17:33:18 <pjd_> dmwit: Haskell's like "Here, let us help!"
17:33:25 <dmwit> Apocalisp: minimumBy should help
17:33:28 <vixey> Apocalisp: map (+n) . min . map (-n)
17:33:41 <dmwit> vixey: Needs more abs.
17:33:45 <Apocalisp> nice! Thanks guys.
17:33:47 <dmwit> :t minimumBy
17:33:49 <vixey> oh yeah .. :(
17:33:50 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
17:34:07 <dmwit> :t comparing
17:34:09 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:34:15 <roconnor> edwardk: don't worry, we will all move onto Epigram before Haskell succeeds
17:34:18 * QtPlatypus sometimes things that in meany things Perl6 followed Haskell down a dark ally and mugged it for its cool features.
17:34:25 <monochrom> Dependent typing is awesome!
17:34:39 <edwardk> roconnor: please, no sheds ;)
17:34:41 <vixey> hmm epigram
17:34:41 <dmwit> :t minimumBy (comparing (\x -> abs (x - n)))
17:34:43 <lambdabot> [Expr] -> Expr
17:34:58 <dons> QtPlatypus: but perl6 bit off more than it could chew. :)
17:35:10 <dons> it overdosed on our rich, lambda heroin.
17:35:13 <Cale> Dependent typing without really good type inference: not as awesome.
17:35:24 <vixey> Cale: inference of what ?
17:35:33 <vixey> oh type
17:35:33 <Trinithis> what is dependent typing? forall and such?
17:35:34 <vixey> sorry
17:35:37 <roconnor> or perhaps Agda
17:35:38 <monochrom> "Haskell now has dependent typing!" "Yeah yeah, epigram has had that forever"
17:35:39 <gwern> dons: just as well. cancer of the semicolon would've killed it off soon enough
17:35:40 <dmwit> > let closest = minimumBy . comparing . abs . subtract in closest 3 [1,2,5]
17:35:41 <lambdabot>   add an instance declaration for (Num (a -> a))
17:35:52 <vixey> roconnor: Why not Coq?
17:35:55 <gwern> Trinithis: functions which can return multiple types
17:35:59 <edwardk> Trinithis: in short its types that can depend on term level calculations, like an array of (2 + 3) elements
17:36:01 <Trinithis> mmk
17:36:02 <vixey> roconnor: Seems much much more advanced than anything
17:36:11 <roconnor> vixey: I'm told Coq is not a real programming language.
17:36:12 <gwern> Trinithis: as opposed to haskell functions, which must return the type they declared. I think.
17:36:26 <vixey> roconnor: who says?
17:36:32 <edwardk> Trinithis: or a function which might return a bool down one path of a integer down another while still making sure that the result is only used in appropriate situations, etc.
17:36:34 <ddarius> lament: The difference is that when Haskell features get added to other languages, Haskell programmers are happy about it, not bitter.
17:36:52 <edwardk> ddarius: says you. I want them to suffer ;)
17:37:08 <dons> Haskell: a Class A controlled substance. Possession with intent to supply is a serious felony.
17:37:11 <lament> ddarius: in my case, i get happy in the sense of "yay, i can finally do this in C#"
17:37:17 <roconnor> vixey: hmm, probably those trying to implement IO in Agda.
17:37:22 <dons> but a little lambda for personal use is ok.
17:37:24 <fnord123> am i understanding correctly that dependent typed languages like coq generate a new type for each io monadic value? e.g. each random number is a new type of number?
17:37:35 <lament> ddarius: as opposed to the lisper reaction, "Why am I using C# at work? I will go kill myself now"
17:37:36 <ddarius> lament: That's my case as well (though I was happy about such feature uptake before I programmed in C#)
17:37:48 <vixey> fnord123: no
17:38:05 <monochrom> hehe dons
17:38:11 <fnord123> dons: Haskell is a depressant like ketamine or marijuana.. [insert punchline about laziness here hurrrrr]
17:38:14 <ddarius> lament: Exactly, Haskell isn't, and I very much doubt, will ever be as "exclusive" a language as Lisp is.
17:38:36 <monochrom> Weapon of Mass Development
17:38:48 <vixey> lament: your generalizations about lisp are false and probably based on IRC experience alone
17:38:58 <Cale> A good example would be that a vector type might depend on a value being the dimension of the space, and operations on vectors, for example, concatenation, will involve computations on those values (addition)
17:39:04 <dons> the FFI certainly helps us be a good citizen
17:39:23 <vixey> data Vec (A : Set) : (n : N) -> Set where
17:39:23 <vixey>   nil : Vec A Z
17:39:23 <vixey>   cons : {x : N} -> A -> Vec A x -> Vec A (S x)
17:39:29 <vixey> _++_ : forall {A : Set}{x y : N} -> Vec A x -> Vec A y -> Vec A (x + y)
17:39:30 <vixey> nil ++ ys = ys
17:39:30 <vixey> cons e xs ++ ys = cons e (xs ++ ys)
17:39:33 <vixey> Cale :)
17:39:40 <Cale> exactly
17:40:18 <Cale> What I haven't seen is a dependently typed language which didn't require tons of type annotations.
17:40:23 <vixey> (Agda does clever proving here, by the structure of the definition of + being so similar to ++)
17:40:44 <Saizan> btw, why not Vec : (A : Set) -> (n : N) -> Set ? because i'd need Set1?
17:40:58 <vixey> Saizan: yes I think so, don't quote me on this ..
17:41:06 <SamB> Cale: well, Agda requires a heckofa lot less than Coq, afaict
17:41:29 <Cale> Yeah, from what I've seen that's the case.
17:41:33 <vixey> Agda requires you to write proofs by exhibiting lambda terms
17:41:53 <SamB> obviously the very nature of dependantly typed languages requires more type annotations than non-, at least when there is a point in using them...
17:41:59 <vixey> Coq doesn't
17:42:07 <lament> vixey: no, also newsgroups and blogs :)
17:42:34 <SamB> vixey: yes but I find that I am always frustrated when I can't find the terms anyway
17:42:34 <vixey> compare a proof of the division algorithm in Coq and Agda
17:42:41 <Cale> Ideally though, you'd have a situtation where programs that don't require dependent typing don't need type annotations.
17:42:56 <vixey> SamB: what do you mean?
17:43:16 <SamB> vixey: well, I like the terms
17:43:27 <SamB> I want to write them anyway
17:43:27 <vixey> You can write them out manually if you want
17:43:36 <dmwit> Cale: Sounds like a good paper, if you can make it work. =)
17:43:40 <vixey> or derive them and Print them out
17:43:50 <dmwit> Oh, I misread.
17:43:51 <SamB> I have had more success with this approach in Agda than in Coq; often I give up and write a proof instead
17:44:05 <Cale> dmwit: It seems to me that all the type system research in Haskell is headed in that direction.
17:44:11 <SamB> even if I just wanted to implement a function, not prove a theorem!
17:44:18 <vixey> SamB: Fixpoint
17:44:22 <dmwit> Cale: Yeah, dependent types seem pretty big right now.
17:44:25 <SamB> vixey: even so
17:44:39 <vixey> I don't understand
17:44:47 <Cale> dmwit: That is, fancier and fancier type systems which are conservative in the sense that programs that don't use the new features are unaffected.
17:44:50 <SamB> I don't know that I do either
17:44:56 <vixey> SamB: example http://pastey.net/87716
17:44:59 <SamB> Agda at the very least has a lot more example terms ;-)
17:45:05 <Cale> (and you still get nice type inference for them)
17:45:11 <fnord123> Cale, I didn't really follow your vector example. if you have a vector of a type.. .and want to concatenate two vectors, you may want to return the space used by the vectors... but that's not really possible since you could be concatenating vectors of vectors whose size isn't known until runtime
17:45:13 <vixey> (that proof gets generated but I wrote it here just as an example)
17:45:53 <Cale> fnord123: Something like  (++) :: Vec n -> Vec m -> Vec (n + m)
17:47:17 <Cale> fnord123: These things are still statically typed.
17:47:30 <SamB> Agda also seems to have a much nicer implementation of implicit argument...
17:47:35 <vixey> fnord123: you can write proofs to, and use them like (x ++ y) ++ z = x ++ (y ++ z)
17:47:48 <fnord123> is that actual notation or mockup to demonstrate that you want the resulting Vector to be of the type that results when you sum type n and m?
17:48:04 <Cale> fnord123: n and m here are integers
17:48:05 <SamB> fnord123: actual notation
17:48:07 <vixey> fnord123: scroll up a little I pasted an actual example
17:48:15 <Cale> and yeah, that's pretty close to actual notation
17:48:23 <SamB> except in Agda, you write it like this
17:48:26 <vixey> _++_ : forall {A : Set}{x y : N} -> Vec A x -> Vec A y -> Vec A (x + y)
17:48:36 * gwern decides to omit monotone support. they don't even have an active irc channel
17:48:53 <gwern> on the other hand, I  see why mercurial is still around - it's interface is almost as nice as darcs
17:49:00 <SamB> er, yes, what vixey said
17:49:37 <vixey> SamB: I saw some really cool reflection stuff in Agda as well though, so that's not just Coq that's capable
17:49:46 <vixey> SamB: but it did crash when I tried to run it ...
17:49:51 <SamB> agda has reflection???
17:49:53 <vixey> yes
17:49:55 <Cale> In the agda example, the vectors are also parametrised over the type of their elements, whereas my vectors just might hold Double values or something :)
17:49:56 <SamB> how ???
17:50:27 <SamB> Cale: well, that's not a terribly significant detail ;-)
17:50:39 <SamB> parametric polymorphism is the easy part
17:50:46 <vixey> http://www.cs.nott.ac.uk/~nad/repos/lib/Algebra/RingSolver/
17:50:46 <lambdabot> Title: Index of /~nad/repos/lib/Algebra/RingSolver
17:51:17 <vixey> same idea as Coq really
17:51:32 <vixey> (although I think you can automate more)
17:51:59 <SamB> anyway, Agda seems like a nicer version of Coq's language without that extraneous (don't tell Smerdy I said this!) tactics language ;-)
17:52:07 <fnord123> vixey, thanks for the coq example.
17:52:44 <Saizan> is there a description of how non-linear patterns are handled in agda (or in general), i mean like in the definition of _==_, refl : x == x
17:52:50 <shepheb> is Coq actually pronounced like a male chicken?
17:52:51 <Saizan> ?
17:52:55 <vixey> SamB: really ... I don't understand your point of view, have you tried proving anything in number theory with Agda 2?
17:53:16 <SamB> Saizan: could you ask a specific question?
17:53:29 <SamB> after we get you up to speed, we can write a wiki page about it
17:53:44 <fnord123> shep, afaik, yes. It's french for male chicken. like le coq sportif
17:53:45 <SamB> vixey: hmm, well, okay, I don't care much about number theory really
17:54:02 <vixey> SamB: I tried a few things in both, found Coq much easier overall.. but it could just be me
17:54:02 <SamB> that is, I haven't needed much of it yet
17:54:03 <vixey> data _==_ {A : Set} : A -> A -> Set where
17:54:04 <vixey>   refl : (x : A) -> x == x
17:54:19 <SamB> I'm more imterested in the lambda calculus
17:54:23 <vixey> Saizan: You know some Prolog?
17:54:30 <Saizan> vixey: yeah
17:54:36 <vixey> if I define in Prolog:
17:54:39 <vixey> X = X.
17:54:53 <vixey> then I can use that to unify things like f(a,B) = f(X,X). etc..
17:55:18 <vixey> I think it's the same principle here, it's just basically taking what's part of the language (CIC I guess in this case, rather than Prolog)
17:55:22 <vixey> and exposing that to us
17:55:23 <SamB> Saizan: I don't see any pattern matching in the definition of ≡
17:55:27 <Saizan> ok, so it's not encodable somehow in lambda calculus?
17:55:49 <vixey> no lambda calculus + datatype/pattern matching is stronger than just lambda
17:56:05 <vixey> http://pastey.net/87716 <-- You can't prove this in CoC but you can in CIC
17:56:24 <Saizan> SamB: well, refl : x == x <-- here x looks like a pattern to me
17:56:57 <SamB> data ≡ (A : Set) where ≡-refl : {x : A} -> x ≡ x
17:57:02 <vixey> Saizan: It says that if x has type A, then x == x is well typed
17:57:11 <SamB> Saizan: where is there a pattern?
17:57:38 <vixey> SamB: that came out as whitespace for me :(
17:57:38 <ivan_salazar_v> Hello. How do I convert a haskell value into a ByteString in order to serialize it with Data.Binary?. I'm trying to save haskell values in a sqlite blobtype.
17:57:41 <SamB> I see only a souped up GADT
17:57:44 <noecksit> hello, is the example in "Roll your own IRC bot" a blocking network socket?
17:58:37 <noecksit> i am using it to try to implement a GUI and I need to quit the connection when the user clicks "Disconnect", but the whole app just freezes up
17:58:39 <vixey> noecksit: You can get klined from freenode for running that bot :P
17:58:45 <vixey> noecksit: be careful
17:59:12 <noecksit> vixey: no, am not writhing an IRC bot, i am only using it as an example for network programming
17:59:19 <vixey> ok
17:59:25 <noecksit> the app im trying to implement has nothing to do with irc
17:59:57 <ddarius> ivan_salazar_v: Use the Binary class, specifically the method put.
18:00:05 <fnord123> hm looks like I was thinking of clean's uniqueness typing when I suggested io values had their own value.
18:00:33 <ivan_salazar_v> ddarius: Thnx.
18:01:16 <noecksit> so i guess it blocks on the "hGetLine h" call
18:01:42 <ddarius> ivan_salazar_v: encode handles everything for you.  encode :: Binary a => a -> ByteString
18:02:58 <ivan_salazar_v> ddarius: Oh, I see... I'll try using it. Thanks.
18:03:23 <ddarius> @hoogle a -> ByteString
18:03:23 <lambdabot> Data.ByteString.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
18:03:23 <lambdabot> Data.ByteString.Char8.unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
18:03:23 <lambdabot> Data.ByteString.Lazy.unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
18:03:37 <ddarius> Hoogle doesn't have Data.Binary (yet)
18:04:41 <dmwit> vixey: Whoa, really?  What's so heinous about the Roll Your Own IRC Bot bot?
18:05:02 <vixey> dmwit: I guess it was a glitch in the spammer detecting thingy .. but it can happen!
18:05:46 <vixey> (btw on the subject of dependant types I found this the other, It's really nice example of dependant types http://citeseer.ist.psu.edu/495376.html )
18:05:47 <lambdabot> Title: First-Order Unification by Structural Recursion - McBride (ResearchIndex)
18:05:57 <vixey> the other day*
18:07:02 <noecksit> is using threads in haskell tough?
18:07:11 <dmwit> Not too bad!
18:07:43 <ddarius> noecksit: No.
18:08:01 <ddarius> noecksit: At worst, it's no harder than using threads in most languages.
18:08:03 <tero-> well, less tough than in C at least
18:08:22 <ddarius> Depending on what you want to do, it can be much easier.
18:08:37 <noecksit> it was really tough in python for some reason
18:08:56 <noecksit> afaik
18:09:13 <tero-> I got some trouble with interrupting the blocking socket operations in threads though
18:10:31 <tero-> noecksit: what kind of application are you planning to write using threads?
18:11:17 <shepheb> as long as one doesn't do evil things (pass IORefs between threads incautiously, use unsafe* functions) threads in Haskell are often much more pleasant than other languages
18:12:05 <tero-> after all, they aren't real threads, right? ;)
18:12:19 <tero-> unless you compile with -threaded I guess
18:12:21 <noecksit> tero-: i am trying to write a GUI app that uses sockets
18:12:33 <shepheb> especially if you remember that they have a negligible cost. no ahead and create three for each client
18:12:51 <gwern> woot. I've now finished the library portion of change-monger - after scrapping montone support and punting on the challenging part of CVS and Subversion :(
18:13:04 <tero-> noecksit: ok. if you want, I could pass you a simple network module I wrote in Haskell
18:13:05 <shepheb> -threaded creates a handful of OS threads. it doesn't make one for each Haskell thread
18:13:12 <tero-> ah, ok
18:13:56 <shepheb> generally, one uses -threaded -N2 to have two OS threads, in order to use 2 cores.
18:14:09 <noecksit> so if i create a socket that is blocking, and then put that in its own thread, would i be able to close the connection outside the thread with "exitWith ExitSuccess"?
18:14:34 <ivan_salazar_v> Whats the difference between Data.ByteString.Lazy.Internal.ByteString and Data.ByteString?
18:15:19 <ivan_salazar_v> It seems that the return type of encode is Data.ByteString.Lazy.Internal.ByteString
18:15:40 <tero-> noecksit: maybe throwTo would work?
18:15:58 <shepheb> noecksit: if the main thread shuts down, it takes the RTS with it, so yes.
18:16:07 <chessguy> 'evening, #haskell
18:16:32 <vixey> hi chessguy
18:16:46 <shepheb> you can also retrieve the ThreadId when you spawn that other thread, and then kill it.
18:17:53 <shepheb> the latter technique has the advantage of not closing down the whole program.
18:18:59 <noecksit> shepheb: yeah, thats actually what i want to do, i dont want the entire program to quit, i just want to disconnect
18:20:10 <noecksit> shepheb : i dont know if i want to kill the thread in itself though, because i think that would leave an open connection hanging, id like to close the connection first
18:20:29 <dfrey> Is there any prelude function like assert that will call error if a condition is not true?  I searched hoogle for "Bool -> [Char] -> a", but nothing came up.
18:20:48 <vixey> :t error
18:20:50 <lambdabot> forall a. [Char] -> a
18:20:54 <vixey> hmm
18:20:59 <vixey> :t guard . error
18:21:01 <lambdabot> forall (m :: * -> *). (MonadPlus m) => [Char] -> m ()
18:21:17 <shepheb> noecksit: you should be able to create the socket, pass it to the thread, and yet hang onto it in the parent thread.
18:21:23 <vixey> dfrey: well
18:21:35 <vixey> dfrey: what would it return if the Bool was True?
18:21:38 <vixey> undefined?
18:22:05 <dfrey> right...
18:22:11 <vixey> then you go
18:22:12 <dfrey> I think it might be time to go home
18:22:20 <vixey> if p then error string else undefined
18:22:27 <vixey> :t \p string -> if p then error string else undefined
18:22:28 <lambdabot> forall a. Bool -> [Char] -> a
18:22:39 <vixey> btw .. reall odd function
18:24:33 <dfrey> vixey: I was thinking in an imperative mindset.  Now I realize that it's not really what I want
18:24:36 <noecksit> shepheb: ok, that makes sense, the new socket would listen on the wire and be blocking, then using some command outside i can safely close the socket
18:25:00 <noecksit> is there any good example of threads in haskell that I may use?
18:26:31 <shepheb> indeed. in a chat-like server I wrote I had a list of Client types as part of the state, and those records contained the Socket.
18:26:51 <shepheb> and the ThreadIds for the reader and writer threads, and the TChan for sending to the latter.
18:28:22 <shepheb> this is all for a centralized server, rather than something like a web server where clients don't interact
18:29:32 <noecksit> id be happy to try to imitate it if it is well documented
18:30:05 <noecksit> is that the barricuda client?
18:30:09 <shepheb> hmm. I can email you the code if you like; though it contains a great deal of application-specific code (for playing tabletop RPGs over the web)
18:30:50 <shepheb> I'm certainly no wizard, though, so take it with a critical eye if you would like it.
18:31:41 <noecksit>  ok cool, thanx, my email is "njvsny@yahoo.com"
18:32:12 <noecksit> does it use any special libraries?
18:32:16 <shepheb> eeee this channel gets logged on the web, be careful not obfuscating the address.
18:32:41 <shepheb> the server doesn't. the client uses GTK and Cairo
18:33:22 <shepheb> okay, I've got the email noted, I'll send later tonight; in class atm and can't spare the brain time to actually sort out the files.
18:34:59 <noecksit> oh, its allright, its my public email, thank you
18:35:47 <shepheb> well, it's your inbox. I'm afk for an hour-ish, class is over.
18:58:27 <gwern> ah! done and uploaded!
18:58:37 <gwern> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/change-monger-0.0
18:58:39 <lambdabot> http://tinyurl.com/5f8pxj
18:58:41 <gwern> 'change-monger is intended to allow you to extract the revision history from various VCSes like Darcs, and save them as a ChangeLog; particularly important is being able to extract the summaries for all patches since the last release. '
18:59:20 <Zao> repeat "wibble"
18:59:24 <gwern> I think this is the first all-my-own-work package I've ever uploaded to hackage
18:59:24 <gwern> huh
18:59:52 <dmwit> > repeat "wibble" -- Zao, did you want this?
18:59:54 <lambdabot>  ["wibble","wibble","wibble","wibble","wibble","wibble","wibble","wibble","wi...
19:00:00 <vixey> yay
19:00:03 <dmwit> > cycle "wibble "
19:00:03 * vixey wibble
19:00:04 <lambdabot>  "wibble wibble wibble wibble wibble wibble wibble wibble wibble wibble wibbl...
19:00:08 <Zao> A wibble is a small patch to correct something insignificant, and darcs logs tend to be full of them.
19:00:16 <Zao> Or so xmonad@ has taught me :)
19:00:17 <dmwit> Oh, yeah.
19:00:36 <ddarius> Zao: Get some significant bugs patched into the xmonad repo.
19:01:04 <ddarius> > var (cycle "wibble ")
19:01:06 <lambdabot>  wibble wibble wibble wibble wibble wibble wibble wibble wibble wibble wibble...
19:01:25 <vixey> ?vixey wibble
19:01:26 <lambdabot> Is that a real poncho or is that a Sears poncho?
19:04:31 <gwern> http://hackage.haskell.org/trac/hackage/ticket/244 <-- whew what a lot of work I've been doing for this feature
19:04:32 <lambdabot> Title: #244 (Add Changelog summary feature to sdist) - Hackage - Trac
19:05:23 <vixey> gwern++ busy bee
19:06:14 <gwern> @seen boegel
19:06:14 <lambdabot> I saw boegel leaving #haskell-blah 5h 43m 57s ago, and .
19:09:10 <gwern> bleh. I want to upload hray!
19:10:09 <gwern> @tell boegel I'd like to upload hray this week; could you incorporate my patches and decide on what license? (bsd3 vs gpl, etc)
19:10:10 <lambdabot> Consider it noted.
19:10:40 <ddarius> You give him a choice?
19:11:58 <vixey> damn it
19:12:06 <gwern> ddarius: well, if he's going to reject my patches and keep the license proprietary, I'd like him to say that too
19:12:08 <gwern> so I can move onto something else
19:12:11 <vixey> roconnor: Why Epigram though?
19:12:31 <vixey> I don't know much about it .. but it seems to be made of different stuff than the others
19:12:40 <vixey> at least Epigram 2
19:13:03 <gwern> @quote epigram
19:13:03 <lambdabot> dolio says: Perhaps he's an epigram guy and frowns on Turing completeness.
19:13:44 <gwern> does epigram disallow unrestricted recursion?
19:14:32 <vixey> I don't think so ..
19:14:38 <vixey> :(
19:18:38 <vixey> hi ozy`
19:19:03 <ozy`> sup
19:19:20 <ozy`> didn't know you frequented these parts
19:20:18 <ddarius> All roads lead to #haskell
19:20:52 <ivanm> ddarius: even those leading to Rome?
19:20:57 <vixey> ozy`: I didn't know -you- frequented these bits :D
19:21:58 <gwern> ivanm: well, where do you think the roads out of rome lead?
19:22:06 <gwern> (you can't stay in rome forever)
19:22:12 <ivanm> to Venice?
19:23:41 <gwern> venice has no roads silly
19:26:42 <pjd_> gwern: just different degrees of wetness
19:33:57 <monochrom> Rome roads lead to Byzantium.
19:38:09 <shepheb> monochrom: you mean Java?
19:38:35 <monochrom> dunno
19:39:13 <dobblego> @djinn (a -> f b -> f b) -> (a -> c) -> c -> f b -> f b
19:39:14 <lambdabot> f _ _ _ a = a
19:40:07 <dobblego> ?instances Functor
19:40:08 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:42:14 <dobblego> @djinn (a -> x -> x) -> (a -> c) -> c -> x -> x
19:42:15 <lambdabot> f _ _ _ a = a
19:42:37 <monochrom> hehe
19:44:07 <shepheb> I'm not familiar with djinn, does that mean what it appears to, that f == const (const (const id))) ?
19:44:21 <dobblego> yes
19:44:27 <dobblego> or f = const . const . const
19:44:38 <shepheb> er, right
19:44:41 <pjd_> @pl \f _ _ _ a -> a
19:44:41 <lambdabot> const (const (const (const id)))
19:45:53 <shepheb> djinn strikes me as appropriately named, if you asked me if such analysis were possible my a priori answer would be no.
19:47:16 <dobblego> shepheb, how many functions have the type forall a. a -> a?
19:47:43 <monochrom> It is possible because recursions at all levels are missing.
19:47:54 <shepheb> infinitely many, but they're isomorphic to id
19:48:53 <ddarius> :t undefined :: a -> a
19:48:55 <lambdabot> forall a. a -> a
19:49:06 <dobblego> +terminating
19:51:05 <dobblego> is there such a thing as a contravariant functor?
19:51:16 <dobblego> F x -> (y -> x) -> F y
19:51:27 <pjd_> sure
19:51:51 <dobblego> ok, just making sure I'm inventing things that already exist, I get shaky otherwise :)
19:52:47 <solrize> is there any code around that handles java modified utf-8 ?
19:54:22 <pjd_> dobblego: http://www.haskell.org/haskellwiki/TypeCompose
19:54:23 <lambdabot> Title: TypeCompose - HaskellWiki
19:54:41 <dobblego> pjd_, I called it compose too :)
19:54:55 <dobblego> pjd_, thanks
19:56:54 <ozy`> vixey: I don't, really... I was led here by the yi editor
19:57:10 <ozy`> (which I can't get to compile, but oh well)
19:58:41 <ddarius> dobblego: The terms co-/contra-variant came out of category theory allegedly.
20:00:18 <dobblego> is there a type-class for it?
20:00:38 <dobblego> if not, would one be useful anyway?
20:01:20 <pjd_> dobblego: see that link i pasted :)
20:01:31 <dobblego> pjd_, ok I will I will :)
20:02:06 <ddarius> Not in widely used libraries and yes-ish.
20:02:38 <pjd_> it defines Cofunctor, with cofmap :: (a -> b) -> (f b -> f a)
20:03:44 <monochrom> "variable-substitution-gives.html" sounds funny. variable substitution gives... HTML? :)
20:17:32 <shapr> SHAZAM!
20:17:46 <shapr> @seen ndm
20:17:46 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 4d 14h 51m 6s ago, and .
20:17:48 <shapr> hmm
20:18:14 * edwardk attacks shapr with a banana.
20:18:20 <shapr> AAA!
20:18:32 <shapr> You just missed me snickering about you on #haskell-blah
20:18:39 <edwardk> mrrrh?
20:18:41 <shepheb> http://uncyclopedia.org/wiki/AAAA
20:19:12 <dons> dolio, sclv_, dcoutts, et al. here's my alpha response to the whole "GHC is unpredicable" saga. if anyone has comments on it, that would be useful. galois.com/~dons/tmp/content
20:19:26 <dons> about how to reliably write very fast code, and understand when and why that is the case
20:19:40 <dons> its not complete, the last section about recovering the naive code with fusion is missing
20:19:45 <shapr> edwardk: So, how would you attack someone with a banana ... IN THE TYPE SYSTEM?
20:19:47 <dons> but the basic points are there.
20:20:04 <dons> so if anyone is interested in outperforming C in Haskell, and wants to see it, check that, and let me know what you think.
20:20:33 <Pseudonym> shapr: We've already done fresh fruit.
20:20:33 <edwardk> shapr: obviously it is a banana bracket.
20:20:37 <shapr> dons: Is the summary "If GHC ain't fast enough for you, it's cause you don't know enough about Haskell" ?
20:20:43 * edwardk wraps shapr in barbed wire.
20:20:47 <shapr> argh!
20:20:59 <dons> well, hmm. ghc isn't predictable if you can make sensible predictions
20:21:07 * shapr burns edwardk with a lens
20:21:10 <dons> and its also bloody good at what it does these days
20:21:15 * dons is off to dinner. 
20:21:18 <dons> feedback please!
20:21:22 * shapr is just off...
20:21:55 * edwardk backs over shapr with a hylo.
20:22:01 <shapr> ow!
20:22:21 <shapr> They call those little forklifts 'hilo' in MI, right?
20:22:31 <edwardk> yeah
20:22:32 <shapr> I've never heard that in the southeast in any case.
20:23:06 * shapr twins edwardk with a zygo
20:23:26 * shapr expands edwardk with an appo
20:23:27 <edwardk> you know son, at this rate you'll have no futu
20:23:31 <shapr> argh
20:23:40 * shapr timetwists edwardk with a CHRONO!
20:23:54 <schme2_> mornin' #haskell
20:24:03 <shapr> Good morning schme2_ ! How's code?
20:24:05 <schme2_> dons: That's a very interesting read.
20:24:52 <schme2_> Code is quite ok. A bit busy turning pgsql tables -> sqlite so Ican actually start writing the stuff that uses it :)
20:24:59 <lucca> crono?
20:25:09 * shepheb can't decide is red wine and ice cream (not mixed, just consuming both) is classy or classless.
20:25:16 <shapr> lucca: Yeah, chronomorphisms!
20:25:28 <shapr> shepheb: Is it strawberry ice cream?
20:25:49 <shapr> At least the colors might match then...
20:26:05 <edwardk> lucca: http://comonad.com/reader/2008/time-for-chronomorphisms/
20:26:07 <lambdabot> Title: The Comonad.Reader  Time for Chronomorphisms
20:26:36 <dolio> dons: So, I've got introsort on uvectors running passably, I think.
20:27:00 <shapr> edwardk: Did you already post about today's lunchtime thought?
20:28:07 <dolio> It's not too far behind glibc's sort().
20:28:08 <edwardk> shapr: the productive corecursion bit?
20:28:35 <shapr> yeah, what you said...
20:28:52 <dolio> ~ 9 - 10 seconds to sort 10 million random 64-bit integers in haskell vs. ~ 7 seconds in C.
20:29:02 <bos> dolio: nice!
20:29:17 <solrize> dolio, cool, that's vs. C qsort?
20:29:19 <bos> dolio: you should compare with STL in C++, too, for fun.
20:29:23 <solrize> yeah
20:29:28 <edwardk> i replied to cale mentioning it on reddit, but that was about it
20:29:55 <dolio> solrize: Yeah, vs. qsort.
20:30:09 <thetallguy> shapr: you've quite the energy burst tonight
20:30:16 <schme2_> So I'm lookin' for some good information on using haskell for web applications. What is that URL again?
20:30:18 <solrize> hmm, is that somehow inlining the comparison anyway?
20:30:25 <shapr> thetallguy: And today too!
20:30:32 <solrize> otherwise using STL would be interesting, if it can inline
20:32:36 <solrize> dons, that post is great
20:34:07 <dolio> If someone wants to write up a quick STL program to compare to, I'll compile and run it.
20:34:16 <dolio> I'd have to do some reading to write such a program.
20:35:16 <solrize> the C code is a little bit weird since it's incrementing both n and a (the .hs code recurses on two variables)
20:35:41 <mxc> @hoogle show
20:35:41 <lambdabot> Prelude.show :: Show a => a -> String
20:35:41 <lambdabot> Text.Show.show :: Show a => a -> String
20:35:41 <lambdabot> Text.Show :: module
20:35:42 <solrize> i wonder if using b += (n-1) would get optimized by the compiler
20:36:13 <mxc> @hoogle (Float -> String)
20:36:14 <lambdabot> No matches, try a more general search
20:36:15 <lucca> edwardk: thanks
20:36:56 <edwardk> lucca: if you have any questions about them (or the others feel free to ask)
20:37:04 <solrize> where it says "ensure all types are inferred to atomic machine types." maybe a little more is needed since it's not clear how to make sure the primitive types end up unboxed
20:40:06 <gwern> 'So let's rewrite the loop to no long take a list, but instead,
20:40:07 <dolio> Holy smokes. I just doubled the speed. :)
20:40:08 <gwern> the start and end values of the loop as arguments'?
20:40:17 <gwern> *longer
20:40:52 <solrize> dolio??
20:41:09 <dolio> GHC kind of sucks when generating code for "loop k k' a b = ... loop k k' a' b'"
20:41:55 <dolio> "loop k k' = loop' where loop' a b = ... loop' a' b'" is much faster.
20:41:59 * gwern still wants to see a fast fold version :)
20:46:43 <dolio> solrize: Yes, I now appear to be sorting random arrays faster than qsort.
20:46:51 <solrize> niice
20:47:11 <dolio> An array of all the same element is still disappointingly slow.
20:47:53 <dolio> Since raw heapsort does that at amazing speed.
20:47:58 <gubagem> ok mathematically what the heck is a monad
20:48:09 <shepheb> dons: excellent read, really explains the how and why of it all.
20:48:36 <solrize> gubagem, http://en.wikibooks.org/wiki/Haskell/Category_theory
20:48:50 <solrize> http://en.wikibooks.org/wiki/Haskell/Category_theory#Monads
20:49:06 <gubagem> thank you
20:50:50 <shepheb> dons: my main question would be whether the memory traffic from the fold version is essential, or whether it could be optimized by a future version of GHC? also, which version of GHC produced these timings, I don't recall seeing the version.
20:52:06 <gubagem> solarize: how do i get the X out of the M's, like M(x) -> x
20:52:49 <gubagem> or is the idea is i never get it out :-(
20:53:26 <solrize> the only way you can get it out is with the bind operation
20:53:52 <solrize> f :: a -> m b
20:54:08 <solrize> now you can say (x :: m a) >>= f
20:54:18 <solrize> the >>= operation pulls x out of the monad and puts it into f
20:54:26 <solrize> and f does some computation the result of which is in the monad
20:56:08 <solrize> i.e. you can't in general get it out and keep it out.  you can only get it out temporarily, in a function whose type signature promises to put it back in :)
21:07:10 <Cale> It's best to think of a value of type, say, IO t, as a program which when eventually executed, will produce a value of type t. The only things which happen to be able to execute IO actions are other IO actions (and the Haskell runtime system)
21:07:48 <Cale> For other monads, you generally have some other function which executes the action or interprets it somehow.
21:07:59 <gubagem> so how do i run a list i read in through a sort then out it to file
21:08:57 <bd_> interact (unlines . sort . lines) :D
21:09:00 <Cale> main = do xs <- getContents; let ys = sort (lines xs); writeFile "myFile" ys
21:09:12 <Cale> er
21:09:20 <Cale> main = do xs <- getContents; let ys = sort (lines xs); writeFile "myFile" (unlines ys)
21:09:25 <bd_> Oh, I suppose interact would go to stdout :|
21:09:33 <Cale> Let me check one thing about that :)
21:09:36 <Cale> :t writeFile
21:09:39 <lambdabot> FilePath -> String -> IO ()
21:09:43 <gubagem> im gonna try this stuff
21:10:00 <Cale> getContents just reads the standard input as a string
21:13:05 <gwern> lazily!
21:13:55 <gwern> > 24 * 31 * (35.5 / 25.6)
21:13:59 <lambdabot>  1031.71875
21:14:15 <solrize> Python 2.4.4c1 (#2, Oct 11 2006, 21:51:02)
21:14:15 <solrize> >>> a = xrange(10**9)
21:14:15 <solrize> >>> print sum(a) / len(a)
21:14:15 <solrize> 499999999
21:14:15 <solrize> >>>
21:14:17 <solrize> heh
21:14:23 <gubagem> [1..]
21:14:25 <edwardk> shapr: more generating function stuff: http://algo.inria.fr/flajolet/Publications/book.pdf
21:15:00 <gubagem> > [1..10]
21:15:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
21:15:10 <gubagem> oh cool
21:15:35 <gwern> hee hee. I use up a petabyte a month of bandwidth?
21:15:40 <gwern> er. terabyte
21:15:44 <solrize> gubagem maybe you want to read "gentle introduction to haskell"
21:15:48 <solrize> which is not all that gentle
21:16:03 * gwern fails at units
21:16:05 <gubagem> im reading realworldhaskell atm
21:16:18 <solrize> also excellent  :)
21:16:30 <gubagem> i learning java in school
21:16:38 <gubagem> and i had been putzing with scheme for a few years
21:17:07 <Cale> gwern: I was about to wonder whether the entire traffic of the internet was passing through some massive machine in your basement.
21:18:41 <gwern> :)
21:18:49 <gwern> the NSA outsourced to me
21:19:14 * gwern spills some tea on teh internets. oops
21:58:30 <bos> @seen dons
21:58:30 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 1h 32m 29s ago.
21:58:30 <dons> gwern, dolio, shepheb : thanks for the feedback. fixed some typos. i'll elaborate on the other stuff later.
21:58:30 <dons> hey bos
21:58:30 <Sgeo> G'night all
22:03:55 <dons> shepheb: re. fold. streams fuse the folds away, so the lazy list is turned into register variables. so yes, it disappears.
22:04:55 <dons> solrize: re. the C code, 3 variables in the for loop, 3 in the recursion. its the same code, isn't it?
22:05:05 <dons>             double n;
22:05:05 <dons>             double b;
22:05:05 <dons>             long long a; // 64 bit machine
22:05:05 <dons>             // go_s17J :: Double# -> Int# -> Double# -> Double#
22:05:05 <dons>             for (n = 1,
22:05:08 <dons>                  a = 0,
22:05:10 <dons>                  b = 0; n <= d; b+=n,
22:05:13 <dons>                                 n++,
22:05:15 <dons>                                 a++)
22:05:16 <solrize> yes, same code
22:05:28 <solrize> i just mean it looks a little bit unnatural as C code
22:05:30 <dons> ok, but you're saying the C guy would try to combine the counters?
22:05:37 <solrize> yeah maybe
22:05:53 <solrize> of course maybe gcc -O2 already does that
22:06:02 <dons> right. and ghc is paying the same cost.
22:06:10 <dons> so the end result is the same. but i might point that out.
22:06:22 <glguy> *time*
22:06:28 <dons> hey glguy :)
22:06:41 <dons> glguy: there you go, what we talked about, http://galois.com/~dons/tmp/content
22:06:51 <solrize> you saw my python example?  it took several minutes to run :)
22:07:04 <dons> solrize: ah ha. yes, i want to collect other examples
22:07:08 <dons> i know its slow in factor too.
22:07:32 <solrize> yeah, the thing is that python's xrange function did the right thing, it created separate iterators for sum and length
22:07:36 <dons> i suspect most languages will be so slow, that hardware hardly matters
22:07:43 <dons> cool
22:07:46 <dons> did you past eit?
22:07:52 <solrize> yeah
22:07:56 <dons> i'll check it out.
22:08:12 <solrize> i mean i pasted it on channel, just scroll back a little
22:08:19 <dons> i only really want to talk about C, as i think it highly unlikely other systems will approach ghc or gcc here.
22:08:47 <solrize> well you've got vesa (the mlton guy) looking over your shoulder in the reddit thread :)
22:08:50 <glguy> dons: you wrote all of that in the 15 minutes between when you got home and when you finally left to meet us?
22:08:55 <dons> yeah, vesa rocks.
22:09:03 <dons> he did a port of the streams paper to mlton, which was very good.
22:09:09 <solrize> neat
22:09:17 <dons> glguy: no, before we went down town.
22:09:27 <glguy> oh, is that what you were doing so late?
22:09:35 <dons> glguy: yeah :) 6-7 is writing time.
22:10:41 <dons> so the last thing to do is recover the performance of the list version by fusion
22:10:55 <dons> and recovering the result from the naive version, via parallelism. though that might be a separate thing
22:13:52 <dons> i'm still kinda amazed that sum `par` length works, with both cores running along the list, while the GC chases it.
22:13:57 <dons> jaffacake++
22:14:33 <mrd> whaa
22:14:41 <mrd> concurrent GC?
22:14:49 <dons> no, GC runs separately
22:15:04 <dons> though we're getting a parallel gc soon
22:15:12 <mrd> i heard about that
22:15:12 <dons> so the gc will collect over multiple cores
22:15:34 <sjanssen> dons: is the parallel version faster? (ie. does parallelism make up for all that GC work)
22:25:13 <solrize> http://research.microsoft.com/~simonpj/papers/parallel-gc/index.htm
22:25:15 <lambdabot> Title: Parallel garbage collection, http://tinyurl.com/6eql8l
22:25:23 <solrize> yes there is a speedup
22:25:37 <solrize> in wall clock time
22:27:02 <dons> sjanssen: oh, for the list traversal? its pretty much the same as the normal list traversal
22:27:15 <dons> i.e. two cores walking the list runs the same as foldl walking with twice as much work
22:27:22 <solrize> oh sorry
22:27:22 <dons> both are over a minute
22:28:05 <travisbrady> does Haskell have any sort of list slicing syntax ala python's lst[start:stop]?
22:28:06 <sjanssen> yeah, I suppose the list overhead will domination simple adding
22:28:20 <sjanssen> travisbrady: no
22:28:46 <sjanssen> > take 10 . drop 20 $ [1 .. ] -- this is what I'd probably do
22:28:52 <lambdabot>  [21,22,23,24,25,26,27,28,29,30]
22:29:02 <travisbrady> sjanssen: thank you
22:29:47 <sjanssen> @let slice n m = take (m - n) . drop n
22:29:49 <lambdabot> Defined.
22:30:03 <sjanssen> > slice 5 9 [1 .. ]
22:30:05 <lambdabot>  [6,7,8,9]
22:30:25 <yaru1022> hi, when I run yi-0.3 it takes up the whole monitor so i cannot even resize it
22:30:30 <yaru1022> how do i solve this problem?
22:31:21 <sjanssen> use xmonad as your window manager? (just kidding)
22:38:12 <thetallguy> I'm trying to install the 'typeof' package.  cabal is complaining that package process-1.0.0.0 is hidden, though ghc-pkg shows it is not.  Any ideas?
22:38:46 <thetallguy> yaru1022: I think the implementers consider that a feature.
22:39:05 <sjanssen> thetallguy: it probably isn't listed in the build-depends
22:39:38 <sjanssen> thetallguy: which is a good hint that this package wasn't updated for The Great GHC 6.8 Package Schism
22:40:55 <thetallguy> Ach.
22:43:12 <thetallguy> sjanssen: you are correct.  And there's no LICENSE file, though it is referenced in the cabal file
22:44:12 <thetallguy> sjanssen: what hack maintains this thing anyway?  Let's see...  author:   Don Stewart   maintainer:          <dons@cse.unsw.edu.au>
22:44:35 <sjanssen> :)
22:44:41 <thetallguy> sjanssen: Aha! Notoriously  unreliable.
22:44:46 <sjanssen> is it actually uploaded on hackage?
22:44:53 <thetallguy> yes
22:45:35 <sjanssen> to be fair, it was uploaded more than a year ago
22:46:17 <thetallguy> I keep trying to ignore this package management problem, especially since I'm no longer at Linspire
22:46:41 <thetallguy> but it's hard, nobody gets it quite right and it really needs to be fixed.
22:46:58 <sjanssen> thetallguy: are you referring to Haskell packaging specifically?
22:47:22 <thetallguy> sjanssen: all packaging that I've dealt with
22:47:31 <sjanssen> there has been some disagreement lately on whether package dependencies are really the right kind of dependency
22:48:02 <thetallguy> sjanssen: yes, I'm ready to try the NixOS method, regardless of the time sink
22:48:49 <thetallguy> I've concluded that anytime users are required to edit a structure that was produced by computation, it's the end of sanity
22:49:40 <sjanssen> .cabal files are generally produced manually
22:50:53 <thetallguy> Yes, but they get put up onto a server where things are supposed to work together...
22:51:41 <thetallguy> The impression for the user is, and the reality should be, that everything is current and working.
22:51:49 <sjanssen> right
22:52:06 <sjanssen> in this case it really is an example of the maintainer not keeping up with the times
22:52:30 <sjanssen> (though one might argue that the package split that causes this shouldn't have happened anyway)
22:52:40 <thetallguy> Indeed, but that should be accounted for, ultimately
22:53:39 <sjanssen> I wonder why that package is lacking a build log
22:54:16 <thetallguy> After I did 'touch LICENSE', it built and installed just fine in my directory.
22:54:54 <thetallguy> where would the build log be?  On the server?
22:55:05 <sjanssen> yeah
23:08:56 <dolio> C++ still has the edge on me.
23:09:16 <Spark> ick it in the balls and run away]
23:13:13 <dolio> Beating out C by a little is pretty good, though, I guess.
23:13:17 <dolio> For a first shot. :)
23:20:50 <cjs> www.haskell.org is getting really slow agan; that same DOS?
23:23:45 <vegai> DOS or critical mass at last? :)
23:26:25 <dblhelix> can someone confirm that haskell.org is down?
23:26:38 <glguy> it isn't
23:26:39 <dblhelix> ah, I'm sorry: it's just slow :=)
23:27:58 <dolio> @seen dons
23:27:58 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 1h 35s ago.
23:35:00 <gardy> Hello
23:35:10 <gardy> Is anybody here?
23:35:15 <thetallguy> Yes
23:35:26 <thetallguy> Although it's a slow time
23:35:32 <gardy> can you help me a little bit?
23:35:41 <thetallguy> US West coast is going to sleep, Europe isn't up yet.
23:35:42 <thetallguy> Sure
23:35:44 <thetallguy> Maybe
23:35:47 <thetallguy> I can try
23:36:02 <vegai> forkIO creates an OS thread, right?
23:36:07 <vegai> s/thread/process/
23:36:26 <vegai> oh, it actually doesn't
23:36:33 <vegai> cool.
23:36:49 <thetallguy> vegai: no, that's forkOS
23:36:53 <vegai> always helps to ask a stupid question in front of a thousand people
23:36:57 <thetallguy> lol
23:37:05 <vegai> @users
23:37:05 <lambdabot> Maximum users seen in #haskell: 463, currently: 411 (88.8%), active: 9 (2.2%)
23:37:21 <vegai> I rounded up slightly
23:37:24 <sjanssen> vegai: no, neither of those create an OS process
23:37:34 <thetallguy> Yeah, Sometimes I just formulate a question, then realize I can answer it myself
23:37:50 <sjanssen> vegai: do you really want a process?
23:37:57 <gardy> I have a list which is representin a matrix. (one line) and I have to get all the specified size matrix from the original without do.
23:38:00 <vegai> sjanssen: no, I really don't
23:38:25 <sjanssen> forkOS creates a Haskell thread bound to an OS thread -- you generally don't want to use this
23:38:32 <sjanssen> forkIO creates a lightweight Haskell thread
23:39:12 <sjanssen> and System.Posix.Process.forkProcess is an interface to the Unix fork() that we all know and love
23:39:16 <thetallguy> gardy: whats the type of the matrix?
23:39:32 <slava> is all io nonblocking in ghc?
23:39:35 <gardy> [Int]
23:39:39 <thetallguy> sjanssen: thanks, I was just working on refining that answer.
23:39:42 <sjanssen> slava: yes
23:39:52 <slava> cool!
23:40:13 * slava is debugging factor's code for windows overlapped io completion ports
23:40:27 <sjanssen> the only thing that can block GHC is blocking FFI calls
23:40:31 <thetallguy> gardy: okay, so we're thinking of that as a matrix with one row.  What do you need to do?
23:40:35 <slava> right
23:40:41 <thetallguy> gardy: find out how many columns?
23:40:51 <sjanssen> and the threaded RTS can even work around those if they're annotated correctly
23:40:56 <slava> sjanssen: which low-level apis do you use for io?
23:40:59 <slava> 'you' being ghc :)
23:41:10 <sjanssen> slava: it is all select() AFAIK
23:41:18 <slava> oh that's a shame
23:41:22 <slava> no kqueue or epoll goodness?
23:41:23 <gardy> for example i have 5x6 matrix and i have to extract all the 2x2 from it
23:41:28 <slava> windows doens't have select() :)
23:41:29 <sjanssen> but I don't really know -- I just hear things here and there :)
23:41:53 <vegai> slava: http://hackage.haskell.org/trac/ghc/ticket/635 :-/
23:41:54 <lambdabot> Title: #635 (Replace use of select() in the I/O manager with epoll/kqueue/etc.) - GHC - ...
23:41:57 <atsampson> slava: there's a WaitForMultipleObjects or similar that does the same thing..
23:42:29 <solrize> is anyone actually using haskell apps that have 1000's of sockets open at once?
23:42:34 <thetallguy> gardy: ah I see.
23:42:35 <slava> WFMO doesn't scale well
23:42:39 <slava> in fact it has a limit of 64 objects
23:42:52 <slava> you really need to use io completion ports which are considerably more complex
23:43:04 <thetallguy> gardy: then I don't understand the 'all on one line'
23:43:09 <vegai> solrize: if anyone has written a comet application server then probably yes
23:43:19 <thetallguy> gardy:  are the rows just concatenated?
23:43:21 <vegai> or any other game server
23:43:37 <solrize> well i dunno if anyone has done that with ghc
23:43:37 <slava> we've been working on our nonblocking io system for about 4 years now
23:43:42 <thetallguy> gardy: so your 5x6 matrix would be :: [Int] with 30 elements?
23:43:56 <solrize> does linux have io completion ports?
23:43:58 <solrize> what are they really?
23:44:12 <solrize> something like epoll?
23:44:37 <slava> yes
23:44:47 <solrize> kevent hmm
23:44:56 <slava> they're like epoll or kevent
23:45:00 <slava> WFMO is like select or poll
23:45:15 <slava> the difference comes to whether you add/remove event sources, or pass a list of handles on every call to the multiplexer
23:46:07 <gardy> the main problem is: i got a string like this (3,3,0,1,0,1,0,1,0,1,0,2,2,0,1,1,0) the first 2 numbers are the first's matrixs size the following ar its elements, and after it there is an another matrix. and i have to look for the all instance of the secon in the first.
23:46:42 <dmwit> Sounds suspiciously like a homework problem.
23:46:52 <gardy> yes, it is
23:48:37 <dmwit> Okay, why don't you tell us what you've tried or thought about so far?
23:48:38 <solrize> is epoll currently the right thing to use?
23:48:46 <joed> gardy: Don't turn #haskell into something like ##java...
23:49:00 <dmwit> (As they say in ##c++: sometimes we do your homeworks for big tall moneys =)
23:49:10 <solrize> lol
23:49:21 <gardy> sorry, i don't want to brother anybody but this was my last idea.
23:49:40 <dmwit> Okay, what was the idea?
23:50:04 <gardy> I'm ask a pro programer like you
23:50:17 <dmwit> hah =)
23:50:17 <sjanssen> gardy: so what have you got so far?
23:50:33 <bd_> @hoogle [a] -> Int -> [[a]]
23:50:36 <lambdabot> No matches, try a more general search
23:50:43 <bd_> @hoogle Int -> [a]  -> [[a]]
23:50:44 <lambdabot> No matches, try a more general search
23:50:56 <dmwit> chunk          i = takeWhile (not . null) . unfoldr (Just . splitAt i)
23:50:59 <dmwit> @bd_
23:50:59 <lambdabot> Maybe you meant: bf bug id
23:51:05 <bd_> :t splitAt
23:51:11 <lambdabot> forall a. Int -> [a] -> ([a], [a])
23:51:25 <bd_> dmwit: yeah, I can write it, I just don't like having to rewrite it again every few months :)
23:51:33 <bd_> which makes me think it ought to be in Data.List
23:51:37 <dmwit> bd_: That's why I have it in module Dmwit. =)
23:51:41 <bd_> heh
23:52:06 <dmwit> (Hence the strange spacing above.)
23:52:54 <gardy> I have everything except that part which function give back all the little sized mtxs to the comparison function...i need something like a double for in c but i can't implement it.
23:52:58 <bd_> I usually write it in a somewhat uglier way though, admittedly :)
23:56:04 <dmwit> gardy: So, what have you done so far?
23:56:23 <dmwit> (We haven't actually gotten an answer to that yet. =)
23:57:55 <gardy> http://gardy.extra.hu/xa.hs
23:59:51 <dmwit> Yikes!
23:59:58 <gardy> ?
