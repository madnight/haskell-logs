00:00:25 <RayNbow> 6.6.x currently
00:00:43 <RayNbow> but at home 6.8.2 didn't give a stack overflow either
00:00:49 <dons> hmm
00:00:52 <RayNbow> unless I swapped fibs and (tail fibs) around
00:04:19 <shachaf> Not stack overflowing here, with 6.8.2.
00:09:30 <dolio> Weird.
00:10:46 <cdsmithus> Strange.  I definitely get the stack overflow with 6.8.2 and with latest darcs.  I tried with and without various options (particularly -fglasgow-exts) and compiled and interpreted, even with -O2.  All stack overflows.
00:11:57 <dolio> What else is everyone running?
00:12:16 <dolio> I'm on 64-bit ubuntu.
00:12:22 <dolio> dons is FreeBSD, no?
00:12:28 <cdsmithus> Same here, Ubuntu, AMD64
00:16:16 <dolio> Incidentally, you built GHC in under 30 minutes?
00:16:51 <glguy> dons is openbsd
00:17:06 <dolio> Ah. I knew it was one or the other.
00:17:13 <solrize_> i am not an operating system.  i am a free nerd.
00:19:14 <Maddas> solrize_: Free as in free beer?
00:19:39 <glguy> as in handcuffs?
00:19:48 <solrize_> as in free variable
00:20:50 <solrize_> http://www.poppyfields.net/filks/00149.html
00:21:01 <lambdabot> Title: Computer songs and poems: Lambda Bound
00:21:14 <Maddas> @pl solrize_
00:21:15 <lambdabot> solrize_
00:21:22 <solrize_> lol
00:21:47 <Maddas> Bah, I hoped it would eliminate you ;-p
00:22:53 <Maddas> solrize_: Haha, that song is funny.
00:42:58 <czShadoW> @src print
00:42:58 <lambdabot> print x = putStrLn (show x)
01:21:42 <RayNbow> dolio: sry for the late reply... at home I run WinXP 32 bit
01:21:56 <dolio> Hmm.
01:22:02 <RayNbow> the machine here is SUSE (don't ask which version#)
01:22:14 <dolio> 32 or 64 bit?
01:22:45 <Baughn> Which version? (Yes, it really matters)
01:40:55 <dmwit> RayNbow: You can ask your computer which version with "uname -a".
01:51:26 <mxc>  is is there a way to have GHCI spit out the contents of a module?
01:51:42 <mxc> like module M = ModuleIwantToSee in ocaml
01:52:02 <mxc> nevermind
01:52:27 <mxc> hm
01:52:32 <mxc> :browse doesn't seem to work
01:52:32 <dmwit> :browse
01:52:35 <dmwit> ?
01:53:24 <mxc> Prelude System.Win32> :br System.Win32.Process
01:53:24 <mxc> module 'System.Win32.Process' is not interpreted
01:53:35 <dolio> :br is :break
01:53:38 <dolio> Just like :b
01:53:53 <mxc> hah
01:53:56 <mxc> my bad
01:53:57 <dolio> At least, if you're using 6.8, which that error message would indicate you are.
01:54:40 <dolio> You're not the first. :)
01:55:41 <mileswu> :src nubBy
01:55:53 <dolio> @src nubBy
01:55:54 <lambdabot> nubBy eq []             =  []
01:55:54 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:56:07 <mileswu> dolio: thanks. its too early!
02:17:34 <mxc> @hoogle pi
02:17:35 <lambdabot> Prelude.pi :: Floating a => a
02:17:35 <lambdabot> Data.Time.Clock.picosecondsToDiffTime :: Integer -> DiffTime
02:17:35 <lambdabot> Data.Fixed.Pico :: type Pico
02:17:48 <mxc> @hoogle  e
02:17:49 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
02:17:49 <lambdabot> Prelude.enumFrom :: Enum a => a -> [a]
02:17:49 <lambdabot> Prelude.enumFromThen :: Enum a => a -> a -> [a]
02:17:51 <mxc> @hoogle  exp
02:17:51 <lambdabot> Prelude.exp :: Floating a => a -> a
02:17:51 <lambdabot> Language.Haskell.TH.Exp :: data Exp
02:17:51 <lambdabot> Language.Haskell.TH.Syntax.Exp :: data Exp
02:19:11 <quicksilver> > exp ( (0 :+ 1) * pi )
02:19:12 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
02:19:20 <quicksilver> so close! and yet, so far.
02:26:54 <mauke> @let i = 0 :+ 1
02:26:55 <lambdabot> Defined.
02:27:00 <mauke> > i^2
02:27:01 <lambdabot> Terminated
02:27:06 <mauke> @undefine
02:27:07 <lambdabot> Undefined.
02:27:47 <chr1s> hey everyone
02:28:28 <chr1s> when I do a System.Environment.getEnvironment from GHCi, the COLS and ROWS variables are set
02:28:48 <chr1s> but when I do that from GHC, they aren't set. Does anybody know why?
02:29:23 <profmakx> chso
02:33:25 <quicksilver> chr1s: what about when you do it from your shell?
02:33:48 <quicksilver> I would suspect these vars are set by ghci, in fact.
02:34:07 <chr1s> echo $LINES in bash displays the number correctly
02:34:13 <quicksilver> although my copy doesn't have them.
02:34:18 <quicksilver> LINES is not the same as ROWS and COLS :P
02:35:07 <chr1s> I meant LINES and COLUMNS
02:35:14 <chr1s> sorry for the confusion =)
02:35:42 <quicksilver> are you running your ghc-compiled program from the same shell?
02:35:46 <chr1s> yes
02:35:47 <quicksilver> as the one that shows LINES and COLUMNS?
02:35:54 <chr1s> yes
02:36:08 <quicksilver> what about the rest of getEnvironment?
02:36:11 <quicksilver> does that look OK?
02:37:03 <chr1s> yes, that's looks perfect.
02:37:29 <chr1s> in GHCi, the LINES and COLUMNS are indeed the last entries in the list, so it's quite possible that GHCi added it
02:38:03 <chr1s> but then it would be interesting to see how they did that. I don't necessarily need them from the environment, I just need those values ;)
02:41:19 <dolio> > i^2
02:41:20 <lambdabot>  i * i
03:02:08 <dolio> @remember JonHarrop This is just Haskell solving problems that don't exist again.
03:02:08 <lambdabot> Good to know.
03:03:04 <ketil> Not really a Haskell question, but does anybody have experience with configuring wordpress?
03:26:31 <duschendestroyer> does anyone know how the current status of this ndp stuff is?
03:27:51 <dmwit> It's in the research stage, I guess.
03:32:42 <mauke> @pl loeb x = fmap (\a -> a (loeb x)) x
03:32:43 <lambdabot> loeb = fix (fmap . flip id =<<)
03:33:38 <Feuerbach> duschendestroyer: it's under active development, afaik
03:35:35 <dolio> Good old loeb.
03:36:11 <dquestions> when i try to install one of the libraries (for ghc)
03:36:18 <dquestions> i get this error:  <no location info>: can't find file: Setup.lhs
03:36:29 <dquestions> i got the X11-1.4.2.tar.gz .. unzipped or w/e cd into it and di:
03:36:44 <dquestions>   runhaskell Setup.lhs configure --user --prefix=$HOME
03:37:33 <mauke> it's Setup.hs
03:39:35 <Feuerbach> dquestions: also, don't forget to run autoreconf
03:39:54 <dquestions> mauke:  i tried .hs too
03:39:55 <dquestions> =-(
03:40:03 <dquestions> same error
03:40:30 <dquestions> so i have neither =-(
03:41:02 <dquestions> oh crap
03:41:10 <dquestions> Feuerbach: what do you mean run autofconfig
03:41:12 <dquestions> ./configure?
03:41:19 <dquestions> or ./autoconfig?
03:41:34 <atsampson> he means run "autoreconf -f -i", to rebuild the configure script etc. from the sources
03:42:52 <dquestions> thanks it works now =-)
03:43:25 <Arnar> hey folks..
03:43:56 <Arnar> so, using the list monoid with writer is bad for performace as append is expensive.. is there a thing like "comonoid" that prepends instead?
03:44:57 <dolio> DList
03:44:59 <dolio> @hackage dlist
03:44:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
03:45:35 <dolio> That takes care of the expensive append.
03:45:40 <quicksilver> dolio: doesn't dlist build up really big thunks though?
03:45:46 <quicksilver> dolio: ideally you want a strict append.
03:45:51 <quicksilver> like the one in Data.Sequence, perhaps.
03:45:52 <Arnar> ok..
03:46:05 <Arnar> I was wondering if the simple solution of flipping (:) would help
03:46:10 <dolio> Yeah, I suppose Sequence would do it, too.
03:46:15 <Arnar> as I'm happy with the "log" being in reverse
03:46:27 <glguy> @seen dons
03:46:27 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 3h 45m 37s ago.
03:46:36 <Arnar> @hoogle Sequence
03:46:37 <lambdabot> Data.Sequence :: module
03:46:37 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
03:46:37 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
03:46:39 <dolio> Well, then Dual List might work.
03:47:09 <dolio> > getDual (Dual [1] `mappend` Dual [2])
03:47:11 <lambdabot>  [2,1]
03:47:30 <Arnar> ok.. thx
03:47:43 <Arnar> @index Dual
03:47:43 <lambdabot> bzzt
03:47:52 <Arnar> @index Dual [a]
03:47:52 <lambdabot> bzzt
03:48:00 <dolio> It's in Data.Monoid.
03:48:10 <Arnar> ah, thanks
03:49:06 <dquestions> so i'm tryign to install another package but i get this error now: autoreconf:  autoreconf:  autoreconf: configure.ac or configure.in is required
03:49:36 <dquestions> xmonad btw
03:49:48 <Feuerbach> dquestions: it's not needed there
03:49:54 <Feuerbach> only in X11
03:50:31 <Feuerbach> for xmonad just use runhaskell configure && runhaskell make && runhaskell install
03:50:39 <Feuerbach> er, runhaskell Setup
03:51:05 <levi13> hi all, I'm having compilation issues with hmp3. It's saying no instance for Binary FilePathP. Any ideas?
03:51:11 <Feuerbach> dquestions: btw, there's #xmonad channel here ;)
03:52:56 <dquestions> lol
03:52:57 <dquestions> k
03:59:11 <Arnar> :t lift
03:59:14 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
03:59:17 <Arnar> :t atomically
03:59:19 <lambdabot> Not in scope: `atomically'
03:59:29 <Arnar> :t Control.Parallel.STM.atomcally
03:59:31 <lambdabot> Couldn't find qualified module.
03:59:41 <Arnar> @index atomically
03:59:41 <lambdabot> GHC.Conc, Control.Concurrent.STM
03:59:49 <Arnar> :t Control.Concurrent.STM.atomcally
03:59:51 <lambdabot> Couldn't find qualified module.
03:59:56 <Arnar> hmm
04:02:54 <Deewiant> Arnar: you're missing an i
04:03:03 <Deewiant> > "atomcally" == "atomically"
04:03:05 <lambdabot>  False
04:03:26 <Deewiant> @ty Control.Concurrent.STM.atomically
04:03:29 <lambdabot> Couldn't find qualified module.
04:03:45 <Deewiant> there is that, though, heh.
04:03:56 <Arnar> Deewiant: thanks :)
04:04:17 <Arnar> :t GHC.Conc.atomically
04:04:19 <lambdabot> forall a. GHC.Conc.STM a -> IO a
04:04:31 <Arnar> :t lift GHC.Conc.atomically
04:04:33 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t) => t ((->) (GHC.Conc.STM a)) (IO a)
04:05:24 <Arnar> I'm not quite sure how to use lift..
04:05:34 <dmwit> :t \x -> lift (GHC.Conc.atomically x)
04:05:35 <Arnar> I have a WriterT [String] STM
04:05:36 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t) => GHC.Conc.STM a -> t IO a
04:05:50 <Arnar> I don't want t IO a
04:05:51 <Arnar> I want IO a
04:06:13 <dmwit> Then you don't need lift at all.
04:06:21 <Arnar> no?
04:06:30 <dmwit> The return value of atomically is already IO a, isn't it?
04:06:36 <Arnar> yes..
04:07:26 <Arnar> so how do I define  WriterT w STM a -> IO a  in terms of STM a -> IO a ?
04:08:07 <ToRA> @type atomically . runWriterT
04:08:09 <lambdabot> Not in scope: `atomically'
04:08:18 <Arnar> ToRA: oh right.. thanks
04:08:20 <dmwit> Yup, use runWriterT.
04:08:31 <matthew_-> ToRA: shift your arse and get into the office
04:08:32 <Arnar> @ty runWriterT
04:08:34 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
04:08:47 <Arnar> @ty execWriterT
04:08:49 <lambdabot> forall w (m :: * -> *) a. (Monad m) => WriterT w m a -> m w
04:08:53 * ToRA feels busted
04:09:05 <dmwit> ?localtime ToRA
04:09:05 <lambdabot> Local time for ToRA is Fri May  9 12:09:05 2008
04:09:10 <matthew_-> you're on a public IRC channel. How am I not going to notice you're clearly still at home?
04:09:47 <Arnar> @hoogle WriterT w m a -> m a
04:09:48 <lambdabot> No matches, try a more general search
04:11:13 <dmwit> :t evalWriter
04:11:16 <lambdabot> Not in scope: `evalWriter'
04:11:18 <dmwit> :t evalWriterT
04:11:21 <lambdabot> Not in scope: `evalWriterT'
04:11:25 <dmwit> hum
04:11:31 <dmwit> ?hoogle eval
04:11:33 <lambdabot> Control.Exception.evaluate :: a -> IO a
04:11:33 <lambdabot> Control.Monad.RWS.Lazy.evalRWS :: RWS r w s a -> r -> s -> (a, w)
04:11:33 <lambdabot> Control.Monad.RWS.Lazy.evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
04:11:45 <ToRA> @type mapWriterT (GHC.Conc.atomically)
04:11:46 <Arnar> dmwit: seems there are only run and exec
04:11:48 <lambdabot> forall a w. WriterT w GHC.Conc.STM a -> WriterT w IO a
04:12:13 <dmwit> ToRA: Oh, neat!
04:12:28 <ToRA> mapFooT's are very useful fns to know when writing your own monad stacks
04:16:25 <Arnar> @type (liftM fst) . GHC.Conc.atomically . runWriterT
04:16:27 <lambdabot> forall w a. WriterT w GHC.Conc.STM a -> IO a
04:16:33 <Arnar> ^^ guess that's what I want..
04:31:59 <visof> urxvt work
04:32:03 <visof> xmonad work
04:32:10 <visof> xmobar don't work
04:56:33 <mm_freak_work> takeWhileM :: Monad m => (a -> Bool) -> [m a] -> m [a]   -- is this really a generalization of takeWhile?  i'd rather consider it something different, something 'similar' to takeWhile
04:57:27 <dcoutts_> @hoogle [m a] -> m [a]
04:57:28 <lambdabot> Prelude.head :: [a] -> a
04:57:28 <lambdabot> Prelude.last :: [a] -> a
04:57:28 <lambdabot> Data.List.head :: [a] -> a
04:57:31 <dcoutts_> bah
04:57:37 <dcoutts_> @type sequence
04:57:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:58:30 <mm_freak_work> well, that doesn't answer my question =)
04:58:38 <dcoutts_> indeed :-)
04:58:53 <dcoutts_> I think it's the obvious 'monadification' of takeWhile
04:59:07 <mm_freak_work> i've written a takeWhileM function, which does the computations in the list until the predicate of the result of those computations becomes False
05:00:23 <dcoutts_> @src sequence
05:00:23 <lambdabot> sequence []     = return []
05:00:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:00:23 <lambdabot> --OR
05:00:23 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:00:29 <mm_freak_work> it's the monadification, but some people seem to view such functions as 'generalizations'
05:00:51 <dmwit> Well, can you write takeWhile in terms of takeWhileM?
05:00:57 <dmwit> That's the acid test of generalization.
05:00:57 <dcoutts_> it's only a generalisation if you can get the original by instantiating
05:01:00 <dcoutts_> right
05:02:14 <dmwit> takeWhileM [] = return []
05:03:19 <dmwit> takeWhileM p (x:xs) = do { v <- x; if p v then liftM (v:) (takeWhileM p xs) else return [] }
05:03:22 <dmwit> Like that?
05:03:50 <dmwit> :t let takeWhileM p (x:xs) = do { v <- x; if p v then liftM (v:) (takeWhileM p xs) else return [] } in takeWhileM
05:03:53 <lambdabot> forall t (t1 :: * -> *). (Monad t1) => (t -> Bool) -> [t1 t] -> t1 [t]
05:04:02 <mm_freak_work> i've written it a bit more verbosely
05:04:15 <dcoutts_> methinks you can do it as a foldr
05:04:31 <dmwit> foldl', I bet, but yeah
05:04:46 <dcoutts_> foldr
05:04:49 <dcoutts_> @src sequence
05:04:49 <mm_freak_work> takeWhileM p [] = return []
05:04:49 <mm_freak_work> takeWhileM p (c:cs) = c >>= (\x -> if p x then takeWhileM p cs >>= (\xs -> return (x:xs)) else return [])
05:04:49 <lambdabot> sequence []     = return []
05:04:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:04:49 <lambdabot> --OR
05:04:49 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:04:56 <dmwit> foldr?
05:05:05 <quicksilver> mm_freak_work: it's a generalisation because it reduces to takeWhile if M is the identity monad, surely?
05:05:25 <quicksilver> takeWhileM :: (a -> Bool) -> [Identity a] -> Identity [a]
05:05:27 <dmwit> Ah, perfect.
05:05:38 <dmwit> That's what I was looking for.
05:05:51 <dmwit> I was trying to imagine it in terms of singleton lists, but Identity is much cleaner.
05:06:03 <dmwit> quicksilver++
05:06:37 <dcoutts_> so takeWhile f = runId . takeWhileM f . map Id ?
05:06:42 <mm_freak_work> what is the identity monad?  return = id ?
05:07:02 <mm_freak_work> uhm…  that would be pointless
05:07:03 <dmwit> mm_freak_work: Well, it's a newtype, so return = Id, where Id is the constructor.
05:07:12 <mm_freak_work> yeah
05:07:27 <dolio> @type \p -> foldr (\m l' -> m >>= \a -> if p a then liftM (a:) l' else return []) (return [])
05:07:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> Bool) -> [m a] -> m [a]
05:07:29 <dmwit> But yeah, conceptually return = id, (>>=) = (.).
05:08:09 <dmwit> Well... (>>=) = ($).
05:08:59 <mm_freak_work> ah ok, so yes, dcoutts_, (runId . takeWhileM f . map Id) makes sense
05:13:25 <dcoutts_> takeWhileM p = foldr (\c m -> c >>= \x -> if p x then liftM (x:) m else return []) (return [])
05:13:34 <dcoutts_> @pl \p -> foldr (\c m -> c >>= \x -> if p x then liftM (x:) m else return []) (return [])
05:13:35 <lambdabot> flip foldr (return []) . flip ((.) . (>>=)) . flip flip (return []) . (flip .) . (. flip (fmap . (:))) . liftM2 if'
05:14:03 <dcoutts_> @pl (\c m -> c >>= \x -> if p x then liftM (x:) m else return [])
05:14:03 <lambdabot> (. flip (flip . liftM2 if' p . flip (fmap . (:))) (return [])) . (>>=)
05:14:17 <dcoutts_> bah, boring
05:14:38 * ToRA thought takeWhileM :: (a -> m Bool) -> [a] -> m [a]
05:14:47 <mm_freak_work> yes, it works
05:15:53 <mm_freak_work> with the Id monad, you can do it
05:16:04 <mm_freak_work> Prelude Main> let tw p = runId . takeWhileM p . map Id
05:16:04 <mm_freak_work> Prelude Main> tw even [2,4,6,7,8]
05:16:04 <mm_freak_work> [2,4,6]
05:16:16 <quicksilver> ToRA: both options are possible..
05:16:31 <dcoutts_> @type \p -> foldr (\c m -> p c >>= \x -> if x then liftM (c:) m else return []) (return [])
05:16:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> [a] -> m [a]
05:17:31 <dolio> @type \p -> foldr (\c m -> c >>= \a -> p a >>= \b -> if b then liftM (a:) m else return []) (return [])
05:17:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> [m a] -> m [a]
05:18:27 <dcoutts_> quicksilver, ToRA: though I think one is a generalisation of the other
05:18:55 <mm_freak_work> well…  i prefer my verbose version
05:26:42 <quicksilver> dcoutts_: for most interesting monads, [m a] can be rewritten as (repeat ma)
05:26:52 <quicksilver> dcoutts_: so it because constant body instead of a list of bodies.
05:26:58 <quicksilver> s/because/becomes/
05:27:08 <quicksilver> whileM :: m Bool -> m a -> m [a]
05:27:26 <dcoutts_> mm
05:27:59 <mm_freak_work> i've written 'while' in a different way:  while :: m (a, Bool) -> m a
05:28:16 <quicksilver> TMTOWTDI
05:29:13 <MyCatVerbs> quicksilver: there's more than one way to do anything. Even in Python. :P
05:29:37 <MyCatVerbs> quicksilver: at the very minimum, you always have the choice between applying f and applying id . f. ;)
05:30:19 <pjd_> people always misremember Python's "one obvious way" as "one way"
05:30:56 <quicksilver> people always misremember Guido as "opinionated fool"
05:31:35 <quicksilver> MyCatVerbs: yes, of course. But I personally think the non-obvious best choice is why we don't have a consensus on which version of whileM/untilM/takeWhileM to put into the library.
05:33:17 <MyCatVerbs> quicksilver: whileM seems sensible enough. In the absolute worst case, they're all trivial to implement in terms of one another, right?
05:33:50 <dolio> id . f is f, seq notwithstanding. :)
05:34:35 <MyCatVerbs> dolio: well yeah, that's the point.
05:35:04 <MyCatVerbs> dolio: "doo foo, then do bugger all for a little bit" is always a viable alternative to "do foo". ;)
05:37:03 <mm_freak_work> quicksilver: your whileM is different…  it will be difficult to base the abort condition on the actual calculation
05:37:20 <mm_freak_work> you're gonna need some means of information passing
05:38:16 <MyCatVerbs> mm_freak_work: it'll be fine in monads with references, or state monads. Agree that you'd probably want something more like (a -> m Bool) -> (a -> m a) -> a -> m [a], though.
05:39:21 <quicksilver> mm_freak_work: I have that means.
05:39:25 <quicksilver> mm_freak_work: it's called "m"
05:39:58 <quicksilver> mm_freak_work: you're absolutely right. The monad has to have its own information passing capablities to make all the alternatives equivalent.
05:40:13 <quicksilver> in the absence of that, they're certainly not.
05:40:24 <quicksilver> (Identity Bool doesn't have much information ;)
05:40:43 <MyCatVerbs> (a -> m Bool)_ -> (a -> m a) -> a -> m [a] -- for the win!
05:42:21 <dolio> It returns all the intermediate values?
05:42:36 <MyCatVerbs> dolio: mmm, yeah, m a is easier to write than m [a]
05:42:40 <quicksilver> how about :
05:42:44 <dolio> @type until
05:42:46 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
05:43:13 <mm_freak_work> quicksilver: it's unnecessarily difficult, IMO
05:43:18 <quicksilver> Monoid n, Monad m => (a -> m Bool) -> (a -> m (n,a)) -> a -> m n
05:43:23 <MyCatVerbs> :t fix (\rec test action initial -> test initial >>= \res -> if res then liftM2 (:) initial (action >>= rec test action) else return [])
05:43:25 <lambdabot> forall (m :: * -> *) a1. (Monad m) => (m a1 -> m Bool) -> m (m a1) -> m a1 -> m [a1]
05:43:38 <MyCatVerbs> ...I cannot believe that typechecks. oO
05:43:44 <dolio> Heh.
05:43:57 <MyCatVerbs> Wait, damn, I got an (m a) in there for the initial instead of an a.
05:43:59 <mm_freak_work> i'd even simplify it to:  Monad m => (a -> Bool) -> m a -> m a
05:44:03 <quicksilver> mm_freak_work: when I've used it it's been very simple. But it depends what you're doing. I've not used any of these variations often enough to bother putting them in a library.
05:44:09 <mm_freak_work> or maybe:  Monad m => (a -> Bool) -> m a -> m [a]
05:44:34 <MyCatVerbs> :t \test action initial -> fix ((\rec test action initial -> test initial >>= \res -> if res then liftM2 (:) initial (action >>= rec test action) else return []) test action (return initial))
05:44:36 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = [a1]
05:44:36 <lambdabot>       Expected type: m a1
05:44:36 <lambdabot>       Inferred type: m [a1]
05:44:40 <dolio> mm_freak_work: That doesn't have anything to change the 'a' at each step.
05:45:06 <mm_freak_work> dolio: it has:  the monad
05:45:36 * MyCatVerbs <3 liftM now. ^_^
05:45:52 <mm_freak_work> while (== 'q') getChar
05:45:55 <mm_freak_work> uhm
05:45:55 <dolio> Heh. We're severely limiting our general monad usefulness.
05:45:59 <mm_freak_work> while (/= 'q') getChar
05:46:02 <ddarius> :t (fmap, liftM, (<$>))
05:46:04 <lambdabot> forall a b (f :: * -> *) a1 r (m :: * -> *) a11 b1 (f1 :: * -> *). (Functor f1, Monad m, Functor f) => ((a -> b) -> f a -> f b, (a1 -> r) -> m a1 -> m r, (a11 -> b1) -> f1 a11 -> f1 b1)
05:53:00 <MyCatVerbs> ddarius: did you do that just to avoid typing :t three times? :)
05:54:05 <ddarius> Yes
05:54:17 <dolio> it made the type signature so much more readable.
05:55:26 <ddarius> @@ map (":t "++) $ unlines "fmap liftM (<$>)"
05:55:27 <lambdabot>  map (":t "++) $ unlines "fmap liftM (<$>)"
05:59:40 <MyCatVerbs> ddarius: what on Earth does @@ do?
05:59:43 <cnwdup> quicksilver: Are you there?
05:59:51 <dolio> @@ I'm the greatest!
05:59:51 <lambdabot>  I'm the greatest!
06:00:12 <quicksilver> cnwdup: who's asking?
06:00:33 <cnwdup> quicksilver: Hum,.. me?
06:00:37 <quicksilver> ;)
06:00:42 <quicksilver> what's up?
06:01:04 <cnwdup> quicksilver: You remember my problem yesterday? I think I understood the concept of tunneling monads but I still have a trouble solving my problem.
06:01:28 <twanvl> @@ ?type ?pl \x -> x  -- @@ allows for nested commands
06:01:28 <quicksilver> ;)
06:01:31 <lambdabot>  forall a. a -> a
06:01:43 <quicksilver> well one thin I didn't understand from your question yesterday
06:01:54 <quicksilver> is whether that callback gets called asynchronously?
06:01:58 <quicksilver> e.g. in a different thread?
06:02:06 <quicksilver> if it does, you have a whole species of problem on your hand.
06:02:14 <cnwdup> Yeah, that's it. Kind of at least.
06:02:40 <quicksilver> called from different haskell thread?
06:02:41 <cnwdup> I add a callback with GTK+'s timeoutAdd which calls a callback every few seconds. But then I can't pass the updated state anymore, can I?
06:02:53 <cnwdup> quicksilver: Hum, I call timeoutAdd from the main thread.
06:03:23 <quicksilver> dcoutts_: GTK expert needed.
06:03:32 <quicksilver> I'm not sure.
06:03:33 <cnwdup> :D
06:03:40 <quicksilver> if it only ever gets called when your main thread is idle
06:03:43 <quicksilver> "in the GTK event loop"
06:03:48 <quicksilver> that's that's probably easy enough.
06:03:52 <quicksilver> it's not really asynchronous
06:03:56 <quicksilver> there is a well defined cut point
06:04:07 <cnwdup> What I thought is I maybe could write a state monad myself which doesn't update the state but instead an IO Ref. But I don't know if that's useful.
06:04:13 <quicksilver> if it's genuinely asynchronous you're going to have to be a lot more careful.
06:04:18 <wjt> it's not genuinely async
06:04:24 <cnwdup> I could simply pass the IORef. Well... "simply".
06:04:34 <quicksilver> wjt: it can only be called once you yield control to the event loop?
06:04:46 <wjt> quicksilver: yes
06:04:51 <quicksilver> OK.
06:04:57 <quicksilver> cjs_: The general picture is this, then
06:05:04 <quicksilver> cjs_: oops
06:05:05 <wjt> it won't fire except from within mainGui
06:05:06 <cnwdup> hehe
06:05:09 <quicksilver> cnwdup: The general picture is this, then
06:05:21 <quicksilver> your nice shiny code runs in nice shiny monad like StateT Foo IO
06:05:26 <quicksilver> or CNDWUPM
06:05:28 <wjt> and regardless of which thread you call timeoutAdd from, the callback will fire in the main thread (i *think*)
06:05:39 <quicksilver> at the 'break points' you need to convert back to an IORef.
06:06:02 <quicksilver> then all your "handlers" which you give to GTK
06:06:11 <quicksilver> unpack the IORef and runStateT your nice monad
06:06:16 <wjt> at least in C, you can't safely call gtk functions from other threads, so the accepted way to fake it is to g_idle_add() a callback that does what you need, precisely because callbacks always run in the main thread
06:06:17 <quicksilver> at the end, they repack the IORef
06:06:55 <quicksilver> all my long email does is show some clever type classes to hide that unpacking/repacking into IORefs, really.
06:07:09 <quicksilver> I don't know enough about the GTK flow to be more concrete :(
06:07:24 <Zao> The Haskell GTK library conveniently has synchronous and asynchronous main thread callbacks.
06:07:30 <cnwdup> Yeah. That's the concept by now. But I get the state, put it into a IORef and pass that to the Callback which unpacks it, calls runStateT, then put's the new state into the IORef again and outside the call back I update the state from the ioref again. That's what was written in the email.
06:08:04 <cnwdup> But then, as I only call the timeoutAdd function once, only the "initial" state will be passed once and thus every time the CB is called.
06:08:27 <quicksilver> the callback you pass to timeoutAdd needs access to the IORef
06:08:28 <cnwdup> So the timeoutAdd's callback doesn't use the up to date state but instead some kind of initial state.
06:08:31 <quicksilver> so it can get the latest state.
06:08:39 <quicksilver> the callback should be off the form:
06:08:51 <cnwdup> But then I have to update the IORef every time I update the state as I call timeoutAdd only once, don't I?
06:09:14 <quicksilver> (do s <- readIORef stateref; s' <- exeStateT realcallback s; writeIORef stateref s')
06:09:37 <quicksilver> every time you cede control back to GTK's main loop you need the IORef to have been updated.
06:09:45 <quicksilver> you can make that automatic simply enough.
06:10:09 <cnwdup> Let me think a moment. I understand the concept, but there's something still troubeling me...
06:10:15 <unenough> does anybody know of a process management (workflow?) app in haskell?
06:10:17 <Zao> http://hpaste.org/7506
06:10:41 <cnwdup> zao: That's relating to my problem? (-:
06:11:12 <Zao> Possibly.
06:11:20 <cnwdup> I'll take a look at it. Thank you.
06:11:42 <Zao> To be honest, I didn't catch your problem :)
06:11:52 <quicksilver> Zao is solving the more complex issues with genuinely threaded programs.
06:11:59 <quicksilver> If you're not using threads you probably don't need it.
06:12:01 <Zao> quicksilver: Ah, you're faking it.
06:12:17 <quicksilver> Zao: I don't think cnwdup is using threads. I could be wrong :)
06:12:31 <cnwdup> I am not. You're right there.
06:12:43 <wjt> i would do this by having mkCb :: IORef MyState -> StateT MyState IO a -> IO a   do whan quicksilver said 15 lines ago
06:13:46 <wjt> then in the function you attach all your callbacks in, you make a single IORef stateref containing your initial state, then pass  (mkCb stateref realcallback) to timeoutAdd
06:14:12 <wjt> then you get the same state threaded through all your callbacks
06:14:46 <quicksilver> wjt: and, if you're interested, there is a generalisation of your 'mkCb' in http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
06:14:53 <wjt> quicksilver: yes, i based it on your email :)
06:15:05 <quicksilver> :)
06:15:47 <cnwdup> quicksilver: http://hpaste.org/7507 That's my problem so far.
06:15:53 <wjt> quicksilver: but afaict in your email you would create a new ioref for each callback?
06:16:04 <sjw> cabal install ftw
06:16:04 <cnwdup> Oh, and sorry. I thought hpaste did wrap the last comment line. |:
06:16:05 <quicksilver> true.
06:16:15 <quicksilver> I'm not sure if it's an inefficiency in practice
06:16:20 <quicksilver> I assume IORefs are pretty cheap.
06:16:29 <wjt> it's not only an inefficiency, it means the state isn't shared between callbacks, surely?
06:16:49 <cnwdup> wjt: Yeah. That's my problem.
06:17:08 <wjt> cnwdup: right, which is why i use the variation i described :)
06:17:08 <quicksilver> wjt: well it's fed back into the monad.
06:17:09 <cnwdup> Future calls of the CB won't update the state and will use an outdated state as my outer monad will move on without updating IORef all the time.
06:17:17 <cnwdup> wjt: Ok, let me re-read it.
06:17:28 <quicksilver> but yes, it depends
06:17:39 <quicksilver> if calls to the callback are interleaved with calls to other callbacks
06:17:44 <quicksilver> (e.g. event callbacks)
06:17:51 <quicksilver> then you're right, the approach in my email is insufficient.
06:18:01 <wjt> well, not exactly
06:18:07 <quicksilver> you need all the interleaved callbacks to be sharing the same IORef
06:18:20 <wjt> you could embed $ \x -> do { attach one callback; attach another; ...}
06:18:48 <cnwdup> wjt: I think I am already doing what you discribed. At least my mkCB function has the same type and then I am doing what quicksilver described.
06:19:07 <wjt> cnwdup: you just need to make sure you're sharing the same IORef between all your callbacks
06:19:33 <cnwdup> I do. But I cannot tell the outer monad from within the callback to update it's state, can I?
06:20:01 <wjt> you don't need to, if the IORef is the canonical place the state is stored; are you actually using multiple threads here, or just a bunch of glib callbacks?
06:20:05 <cnwdup> And then I have to update the IORef every time I change the state of the outer monad, too which appears inefective to me.
06:20:50 <quicksilver> surely there isn't an outer monad?
06:20:51 <cnwdup> wjt: I am using GTK+'s timeoutAdd function which might create a different thread. But I think it does not. I am not using fork or something.
06:20:57 <quicksilver> does mainGui ever return?
06:21:04 <wjt> cnwdup: well then there is no outer monad, since mainGUI never returns
06:21:04 <quicksilver> I thought you never got back to your outer monad
06:21:06 <cnwdup> quicksilver: No, it doesn't.
06:21:09 <quicksilver> right.
06:21:12 <quicksilver> so there is no outer.
06:21:13 <cnwdup> quicksilver: Mh... you're right htere.
06:21:17 <wjt> your monad gets reconstituted from the IORef whenever a callback fires
06:21:19 <quicksilver> all there is is various kinds of callback :)
06:21:25 <wjt> and then liquidized back into the IORef when the callback returns
06:21:42 <SamB> quicksilver: well, and other threads...
06:21:44 <popcorn> are IORefs and STRefs equivalent?
06:21:51 <quicksilver> SamB: but fortunately there aren't other threads.
06:21:58 <SamB> popcorn: equivalent how?
06:22:00 <quicksilver> popcorn: yes. STRefs *are* IORefs.
06:22:07 <quicksilver> popcorn: they just have a different type.
06:22:10 <SamB> quicksilver: that must be backwards
06:22:15 <popcorn> you can implement them in terms of each other
06:22:26 <SamB> popcorn: they are implemented with the same primitives
06:22:26 <cnwdup> Hah!, thanks you all. I think I finally got it. (=
06:22:29 <quicksilver> no, they're not equivalent in that sense.
06:22:35 <quicksilver> you can't implement either with the other in haskell.
06:22:40 <SamB> just as IO and ST are
06:22:44 <popcorn> well this paper about typed logic variables used STRefs
06:22:46 <SamB> (in GHC)
06:22:48 <quicksilver> they need to be primitive.
06:22:52 <quicksilver> or built on primitives.
06:22:55 <popcorn> do you think it would make sense to use IORefs for it?
06:23:04 <quicksilver> but they're equivalent in the sense that they do the same thing.
06:23:06 <quicksilver> just in different monads
06:23:13 <quicksilver> and they are as efficient as each other, etc.
06:23:27 <popcorn> oh that's great then, thanks
06:23:34 <popcorn> I should try with IORefs
06:24:02 <SamB> popcorn: note that when I said I didn't like ST, I wasn't talking about STRefs -- I was talking about STUArray...
06:24:25 <wjt> SamB: in the "there might be other threads" world, i solved this problem by having my monad be a Reader with an MVar for the state, and whenever i want MonadState I wrap the action in 'statefully' which empties the mvar, runStateTs, and fills it again – this is what quicksilver alludes to at the end of his email i think?
06:26:52 <quicksilver> wjt: that's the kind of thing I was sketching, but I didn't ever work it trhough.
06:27:04 <quicksilver> never needed it, yet.
06:27:23 <quicksilver> cnwdup: Another interesting variation is the notion that sometimes particular callbacks can't change the state.
06:27:31 <quicksilver> cnwdup: you can make that explicit in their type, which is nice.
06:28:56 <wjt> it would be nice if you could tell gtk2hs how to do the necessary reconstruction, and then just pass it your bare actions and let it wrap them up
06:29:01 <cnwdup> quicksilver: Yeah, but I think I'll only have a few which need to update the state.
06:29:08 <wjt> i don't know how it would look though
06:29:31 <cnwdup> Wouldn't it be enough to allow m a callbacks to be run instead of IO a?
06:30:05 <quicksilver> wjt: well, I think it would look something like the typeclasses in my email :)
06:30:18 <wjt> quicksilver: well yes, modulo sharing the ioref
06:30:22 <quicksilver> cnwdup: no, because you need to "deconstruct" the m into something which can be embedded in IO, and then "reconstructed"
06:30:34 <cnwdup> ok
06:30:41 <quicksilver> basically, IORefs.
06:30:57 <quicksilver> although there is also the possibility of carrying error monads through IO exceptions.
06:34:41 <SamB> hmm.
06:34:54 <SamB> you seem to be talking about something quite difficult!
06:36:18 <quicksilver> I don't think it is difficult, really.
06:36:21 <quicksilver> it's just plumbing.
06:36:29 <quicksilver> the question is just how much we can hide it.
06:37:52 <SamB> well, if you wanted to make it generic you would be...
06:38:06 <SamB> (talking about something quite difficult)
06:46:24 <RayNbow> have I missed anything related to fibs !! 999999 today? :p
06:57:43 <jorick> > fibs !! 999999
07:17:08 <fizzletip> Hello.
07:23:34 <tromp> :t shift
07:24:01 <EvilTerran> ?bot
07:24:50 <MyCatVerbs> > let l = replicate 10 (length l) in l
07:25:00 * MyCatVerbs pokes lambdabot.
07:25:18 <MyCatVerbs> Damn, how I have to play with my own copy of ghci instead.
07:25:30 <EvilTerran> ... is it Cale who looks after her? i forget
07:26:08 <ndm> dons
07:28:49 <quicksilver> ndm: I think Cale has her now.
07:28:53 <quicksilver> unless dons has taken her back.
07:29:03 <ndm> ah, i didn't realise there was a custody battle
07:31:14 <MyCatVerbs> ndm: the case is going a bit slowly - the lawyers all too lazy and the judge has hit a doubly-exponential worst case trying to work out everybody's types.
07:31:35 <RayNbow> lambdabot is a fembot?
07:31:56 <ndm> RayNbow: she is female
07:31:57 <ari> RayNbow: http://www.cse.unsw.edu.au/~dons/images/lambdabot.png
07:34:15 <Arnar_> hey folks..
07:35:04 <Arnar_> http://hpaste.org/7509
07:35:16 <Arnar_> ^^ I'm having a little trouble finding the right definiton for readTVar
07:40:00 <Beelsebob> Anyone who is familiar with Yampa about?
07:40:14 <Beelsebob> I'm looking at you conal, if you're on
07:42:29 <Saizan> Arnar_: the problem is that the string is appended to the log too early?
07:43:36 <ari> I'd run my own lambdabot and connect it here... if I got the @#!&ing regex-base-0.91 to compile
07:44:04 <ari> Hmmmm, 0.92, 0.93.1? Wonder if those are in Portage...
07:44:21 * ari syncs
07:45:32 <Saizan> isn't 0.72.1 enough?
07:46:18 <Saizan> ?where lambdabot
07:46:27 <Saizan> d'oh
07:50:38 <edward1> heh since (,) abides itself: f = bimap idl idr . abide . bimap coidl coidr . bimap idr idl . abide . bimap coidr coidl is one really long way to say f (a,b) = (b,a)
07:52:04 <Saizan> coidl = fst?
07:52:11 <edward1> er or: bimap idl idr . abide . bimap (coidl . idr) (coidr . idl) . abide . bimap coidr coidl -- woot bimap fusion
07:53:09 <edward1> coidl :: b -> p i b, which in this case is coidl x = (undefined,x)
07:53:39 <edward1> since bottom/undefined/error "whatever" is the 'unit' for (,)
07:54:08 <edward1> idr = fst, idl = snd in the case of (,)
07:54:36 <edward1> was sitting here trying out eckmann-hilton in haskell using bifunctors as the operations just to see what it did =)
07:55:07 <edward1> class (Bifunctor p, Bifunctor q) => Abides p q where abide :: p (q a b) (q c d) -> q (p a c) (q b d) -- is where abide comes from
07:56:11 <edward1> eckman hilton says that if p abides q, and both have identities then, the identities are both the same and that p = q, and that p (and consequently q) is commutative
07:56:47 <edward1> was sitting here trying to see if i could build up some typeclass machinery for saying that, at least by witnessing the various morphisms as haskell functions
07:57:17 <byorgey_> edwardk: you mean q (p a c) (p b d) ?
07:57:18 <Deewiant> preflex: seen lambdabot
07:57:19 -preflex(n=preflex@d90-128-17-80.cust.tele2.de)- lambdabot was last seen on #haskell 1 hour, 55 minutes and 47 seconds ago, saying:  forall a. a -> a
07:57:35 <edwardk> er yeah =)
07:57:45 <byorgey> ok, just checking =)
07:57:47 <edwardk> thats what i get for typing it off the cuff
07:59:24 <edwardk> unfortunately the types become ugly for the function from i -> i' because there are no p's or q's floating around in that one, so it has to pick up a couple of dummy terms to figure out what instance of Abides to use =/
07:59:44 <edwardk> but the commutativity case is easy enough
08:00:35 <edwardk> er for Abides (,) (,): bimap idl idr . abide . bimap coidl coidr is enough i guess
08:01:00 <edwardk> the other is only needed if you don't have a proof that p = q
08:01:48 <Saizan> bimap idr idl . abide . bimap coidr coidl == id ?
08:02:01 <Saizan> for this (,) case at least?
08:02:29 <edwardk> swap (a,b) = (b,a) is equvialent to swap = bimap idr idl . abide . bimap coidr coidl
08:02:58 <edwardk> if haskell had an initial object, that would work for Either as well
08:10:54 <edwardk> hrmm, and idl . bimap idl idr . abide . bimap coidr coidl . coidl shows the fact that the identities are the same, but unfortunately has an ambiguous type so for practical purposes has to be worked with without the idl and coidl on either end
08:15:59 <Arnar> Saizan: sorry.. thanks for responding earlier, had to run myself
08:16:04 <Arnar> Saizan: the problem is a type error..
08:16:35 <popcorn> edwardk: It's not possible to annotate it with a type?
08:17:40 <Saizan> Arnar: oh, right, s/return/lift/ :)
08:17:41 <edwardk> popcorn: it has to go 'through' the type in the middle, you can use an open type annotation or asTypeOf hackery
08:18:58 <Arnar> Saizan: ah, thanks.. needed TM . lift
08:19:10 <Arnar> maybe I should add a liftTM = TM . lift
08:19:46 <Arnar> is that conventional when newtype-defining monad transformers?
08:20:34 <Saizan> Arnar: when the monad you're wrapping doesn't have a limited interface, yes
08:20:39 <Saizan> ?type liftIO
08:21:15 <Saizan> liftIO :: MonadIO m => IO a -> m a, as an example
08:21:30 <edwardk> popcorn: i think i'm going to have to move the 'abide' laws down to the type level rather than have them in classes
08:21:40 <Saizan> you should probably not export it though
08:21:46 <Arnar> Saizan: of course..
08:22:15 <Arnar> Saizan: what do you mean by "doesn't have a limited interface".. you mean within my module?
08:23:58 <Saizan> well, monads like State/Writer/Reader have only a few primitives, so you can just derive the corresponding class
08:24:11 <Saizan> while STM like IO, has nothing like that
08:25:43 <Arnar> right
08:32:18 <swiert> \quit leaving
08:32:27 <swiert> ugh. time to go home.
08:33:39 <daveux> Is this legit? I'm trying to create a type that is a function from a list of strings to some monad (): type Monad m => RoutineF m = Argv -> m ()
08:33:57 <popcorn> no
08:34:03 <popcorn> oops
08:34:17 <popcorn> I thought that was a type not a 'type' declaratino
08:34:37 <daveux> popcorn, am I doing that incorrectly?
08:34:55 <popcorn> I'm not sure
08:35:31 <quicksilver> I don't think type synonyms can have class contexts?
08:35:55 <Saizan> type RoutineF m = Monad m => Argv -> m () ? i'm never sure what goes in type synonyms
08:36:14 <daveux> I tried that first, but I think the Monad m constraint has to go first...
08:36:17 <daveux> maybe bot
08:36:18 <A> > RoutineF m = Monad m => Arv -> m ()
08:36:19 <daveux> maybe not*
08:36:25 <daveux> ok
08:37:11 <Saizan> you could just leave the constraint out
08:37:29 <thoughtpolice> for some reason that doesn't look sound - wouldn't it be better to do type RoutineF m = Argv -> m () and then have 'Monad m => RoutineF m' ?
08:37:39 <thoughtpolice> (then again I haven't run it through the typechecker, just a gut feeling)
08:40:02 <thoughtpolice> yeah, it doesn't work either way.
08:40:19 <thoughtpolice> the first is an illegal polymorphic or quantified type err, and the other has an ambiguous constraint
08:41:51 <quicksilver> the best way to think of haskell types is not to view the context as part of the type.
08:42:04 <quicksilver> you have a type, and then you have a context/constraint on it.
08:42:28 <chylli> help: when I upgrade HaXML, I meed an error: Could not find module `Data.ByteString.Lazy.Char8':
08:42:44 <chylli> but I has installed bytestring
08:43:32 <chylli> how to remove this error ?
08:43:38 <phlpp> @go 10000 Yen in EUR
08:43:52 <malcolmw> chylli: upgrade bytestring to a newer version?
08:44:26 <chylli> malcolmw: it is a most recent version : 0.9.1.0
08:44:52 <byorgey> phlpp: 64.12
08:45:22 <malcolmw> chylli: how are you compiling?  with ghc --make?  with cabal?  with makefiles?
08:45:24 <byorgey> chylli: hm, then perhaps you need to downgrade to an older version
08:45:45 * byorgey hatses bytestring version problemsss
08:46:13 <dcoutts_> we didn't remove anything in 0.9.1.0
08:46:17 <chylli> byorgey: maybe. but is it a bug of bytestring or HaXML? should report it ?
08:46:31 <chylli> malcolmw: runhaskell Setup.hs build
08:46:40 <chylli> malcolmw: and cabel upgrade
08:46:47 <chylli> malcolmw: two meotheld used.
08:47:33 <malcolmw> chylli: ah, just realised, the HaXml.cabal file does not build-depends: on bytestring, but it should
08:47:39 <chylli> malcolmw: not only HaXML, but also cgi
08:47:57 <dcoutts_> malcolmw: you build with the makefiles do you?
08:48:53 <chylli> malcolmw: what should I do ? downgrade bytestring ?
08:49:00 <malcolmw> hold on, no HaXml.cabal _does_ depend on bytestring, but only if base <2 or base >=3
08:49:23 <malcolmw> chylli: so, which compiler? ghc-6.6.x ?
08:49:41 <dcoutts_> chylli: perhaps you could hpaste the output of runhaskell Setup.hs configure -v
08:49:44 <dcoutts_> @hpaste
08:49:50 <dcoutts_> lambdabot?
08:49:59 <malcolmw> @botsnack
08:50:14 <dcoutts_> chylli: http://hpaste.org/new
08:50:27 <chylli> malcolmw: 6.8.2
08:50:49 <dcoutts_> chylli: then we could see what wass going on a bit better
08:52:35 <phlpp> byorgey: thanks
08:52:44 * dcoutts_ suspects a bug in the devel version of cabal that nominolo fixed a couple weeks ago
08:53:21 <chylli> dcoutts_: http://hpaste.org/7510
08:53:49 <dcoutts_> Flags chosen: bytestringinbase=True, splitbase=True
08:54:12 <dcoutts_> chylli: what does "ghc-pkg check Cabal" say?
08:54:30 <dcoutts_> chylli: I'm guessing 1.5.1 or 1.3.10
08:54:52 <nominolo> Setup -v should spit out the cabal version
08:55:01 <dcoutts_> in which case update to the latest darcs version for the fix or use 1.2.3.0
08:55:04 <dcoutts_> nominolo: yeah
08:55:10 * dcoutts_ adds it
08:55:22 <chylli> dcoutts_: it shows the help message instead of result
08:55:30 <conal> Beelsebob: pong
08:55:41 <dcoutts_> chylli: oops, sorry I meant list, not check
08:55:44 <chylli> dcoutts_: ghc-pkg: command-line syntax error
08:56:03 <chylli> Cabal-1.2.3.0, Cabal-1.5.1
08:56:37 <dcoutts_> chylli: so there was a bug a couple weeks ago in the devel version of Cabal where it'd basically ignore the second flag, and so pick the wrong value for it
08:56:48 <dcoutts_> chylli: see where it says Flags chosen: bytestringinbase=True, splitbase=True
08:56:56 <dcoutts_> that flag assignment should be impossible
08:57:10 <dcoutts_> that was the bug, that the second flag got assigned a wrong value
08:57:13 <dcoutts_> it's fixed now
08:57:28 <fizzletip> how do i get the first two elements form a list [merge a b | a b <- xs]
08:57:28 <chylli> then I should upgrade my cabal first ?
08:57:41 <dcoutts_> chylli: yes, or use Cabal-1.2.3.0
08:57:48 <chylli> ok, thanks
08:57:56 <wjt> > take 2 [1,3,5,7,9] -- <- fizzletip
08:58:16 <dcoutts_> chylli: you were unlucky to get it in the one week period when it had that bug, sorry.
08:58:19 * wjt prods lambdabot experimentally
08:58:55 <chylli> dcoutts_: then how to remove old version ? sorry for my idiot question
08:59:18 <dcoutts_> chylli: no need, it uses the latest version by default
08:59:33 <dcoutts_> chylli: and as it happens the darcs version is still at 1.5.1
08:59:34 <chylli> but I think 1.5.1 > 1.2.3.0 ? hehe
08:59:43 <chylli> ok, then I use darcs version
09:00:17 <dcoutts_> chylli: oh, if you want to remover 1.5.1 then ghc-pkg unregister Cabal-1.5.1, possibly with the --user flag if you installed it not as root
09:00:29 <chylli> dcoutts_: thanks
09:02:46 * malcolmw is relieved it is not his bug
09:04:10 <dcoutts_> malcolmw: :-)
09:09:55 <dbpatterson> sclv: interested in extending stringtemplates grammar to include $list[0]$ and $list[othervariable]$? :P
09:11:49 <dbpatterson> sclv: I dont _need_ it, but it would clean up some stuff potentially....
09:13:01 <popcorn> > let list = (!!["foo","bar","baz"]).head in list[1]
09:13:24 * Baughn wonders how close quantum mechanics is to IOT List
09:13:41 <popcorn> oops, let list = (["foo","bar","baz"]!!).head in list[1]
09:16:29 <dcoutts_> nominolo:
09:16:30 <dcoutts_> Configuring Cabal-1.5.1...
09:16:32 <dcoutts_> Using Cabal library version 1.5.1 compiled by ghc-6.8
09:16:47 <dcoutts_> only with -v obviously
09:17:07 <Baughn> (Hm - could you implement IOT with unsafePerformIO? And would it be.. safe?)
09:17:14 <nominolo> dcoutts_: looks ok
09:17:51 <nominolo> dcoutts_: i just realised, that in a git repository including the sha1 of the HEAD is all information you need to get the *exact* version
09:18:01 <nominolo> well, and of course os, arch, ...
09:18:28 <dcoutts_> nominolo: sorry, I don't follow
09:18:35 <nominolo> doesn't matter
09:18:51 <dcoutts_> you mean as a fingerprint of the current state of a repo?
09:18:53 <nominolo> (in git the commit id is a hash of the full history)
09:18:54 <dbpatterson> anyone know of a good overview of javascript? (ie, looking for cheatsheet style, not something to teach me how to program)
09:18:55 <nominolo> yep
09:19:15 <dcoutts_> nominolo: where as in darcs you'd have to hash the context
09:19:19 <Baughn> When writing an explicit type, is it possible to leave some parts of the type undefined? Like "words :: String -> [*]" or something?
09:19:36 <ddarius> javascript-reference.info
09:19:42 <dcoutts_> Baughn: not in current Haskell but there is a proposal to allow that
09:19:45 <nominolo> dcoutts_: or take the sha1 of ls _darcs/patches
09:19:58 <dcoutts_> nominolo: that's more than is necessary
09:20:26 <nominolo> dcoutts_: i think darcs2 has a hashed format, too
09:20:33 <ilyak_> What's the function that returns whenever the first list contains the second list?
09:20:48 <nominolo> isInfixOf
09:20:58 <nominolo> or subset
09:21:02 <nominolo> depends on what you want
09:21:19 <nominolo> :t subset
09:21:39 <nominolo> @hoogle [a] -> [a] -> Bool
09:21:45 <nominolo> @bot?
09:22:01 <thoughtpolice> lambdabot appears to be sick
09:22:19 <dbpatterson> ddarius: I wish the site didnt look like a parked domain, but the content looks perfect, thanks
09:22:23 <chylli> dcoutts_: I has upgrade to latest version of cabal , but still dont work
09:22:32 <Baughn> @bot
09:22:32 <Cheiron> :)
09:22:58 <chylli> dcoutts_:  seems it is not caused by cabal ?
09:23:04 <pjd_> dbpatterson: http://developer.mozilla.org/en/docs/JavaScript is also a good resource
09:23:38 <dcoutts_> chylli: you re-ran configure right?
09:24:05 <dcoutts_> chylli: when you configure -v does it still say: Flags chosen: bytestringinbase=True, splitbase=True
09:24:08 <Arnar> is there a straight fwd way to turn m a -> m a -> m a (a binary op on monads) to (MonadTrans t) => t m a -> t m a -> t m a  ?
09:24:12 <ilyak_> Prelude doesn't contains either one
09:24:16 <ilyak_> Where are they?
09:24:21 <dbpatterson> pjd_: thanks
09:24:44 <Deewiant> ilyak_: Data.List for isInfixOf at least
09:24:49 <chylli> dcoutts_: I just use cabal upgrade.
09:24:51 <dcoutts_> chylli: and were you using runhaskell Setup.hs configure or cabal configure? if the latter did you rebuild cabal-install against the new Cabal lib?
09:25:10 <chylli> dcoutts_: ok
09:25:15 <dcoutts_> chylli: ok so you were still using the old Cabal lib, because that's what cabal-install was built against
09:25:20 <dbpatterson> writing code with c-style brackets, parens, and semicolons is killing me
09:25:49 <saml> in t.hs, I do import Control.Monad.  in ghci, :l t.hs   :t liftM3   not found
09:26:15 <saml> do I have to use liftM3 some place?
09:26:37 <thoughtpolice> saml: only the module is in the visible context, so even though you've loaded something that uses it, you still need to do 'import Control.Monad' on the prompt
09:27:08 <saml> module Test (liftM3) where exposes it
09:27:26 <saml> is there a way to expose entire Control.Monad.*   from t.hs ?
09:27:35 <wjt> module Test ( module Control.Monad )
09:27:44 <thoughtpolice> you can do module Test (module Control.Monad) where...
09:28:57 <saml> ah thanks.
09:34:39 <Arnar> can I not use if-then-else inside a do block?
09:34:46 <Valodim> yes you can
09:35:14 <Arnar> getting indentation errors..
09:35:25 <Valodim> it does not automatically sub-do
09:35:33 <Arnar> ok..
09:35:44 <Arnar> so I need if bla then do {...} else do {..}
09:35:45 <Arnar> ?
09:35:51 <Valodim> precisely
09:35:55 <Arnar> ok, thanks
09:36:00 <chylli`> dcoutts_: when I complie cabal-install I got this error :
09:36:07 <chylli`> Warning: This package indirectly depends on multiple versions of the same
09:36:07 <chylli`> package. This is highly likely to cause a compile failure.
09:36:07 <chylli`> package zlib-0.4.0.4 requires bytestring-0.9.0.1
09:36:07 <chylli`> package cabal-install-0.4.6 requires bytestring-0.9.1.0
09:36:32 <Arnar> Valodim: nope..
09:36:40 <Arnar> http://hpaste.org/7511
09:36:47 <dcoutts_> chylli`: try configuring with --constraint='bytestring==0.9.0.1'
09:36:57 <Arnar> added nested do-s, must've done it wrong :)
09:37:04 <dcoutts_> some day cabal will do that automagically
09:37:10 <Valodim> not like C
09:37:15 <Valodim> if a
09:37:15 <Valodim>   then do
09:37:15 <Valodim>   else do
09:37:16 <Baughn> chylli`: Or recompile zlib against the newer bytestring. Actually, it'd probably work anyway..
09:37:19 <maltem> Arnar: you need to indent the else further
09:37:33 <Arnar> maltem: ah, of course
09:37:33 <Baughn> chylli`: cabal's notion of "highly likely" is highly conservative
09:37:48 <dcoutts_> Baughn: yeah, we don't have enough info to do better
09:38:07 <chylli`> dcoutts_: thanks again and again :p
09:38:12 <dcoutts_> Baughn: though in this case it is correct
09:38:35 <Baughn> dcoutts_: To predict linker failures? Or runtime weirdness?
09:38:40 <Arnar> thanks maltem++
09:38:43 <dcoutts_> Baughn: compile errors
09:38:46 <dcoutts_> type errors
09:38:54 <Baughn> With the type encoded in the symbol, I should think that anything that doesn't actually change the semantics would work
09:39:24 <Baughn> dcoutts_: Well, it might be nice if the error output was filtered to show the actual haskell types. Is there enough information for that?
09:39:32 <dcoutts_> Baughn: bytestring-0.9.0.1:Data.ByteString.ByteString is a different type from bytestring-0.9.0.4:Data.ByteString.ByteString
09:39:36 <dcoutts_> so it is a type error
09:39:51 <psnively> Testing.
09:40:17 <dcoutts_> Baughn: the output of what? the ghc type error message?
09:40:21 <Baughn> Yes
09:40:30 <Baughn> Well, the linker errors.. maybe not in this case
09:40:34 <dcoutts_> it's a bit late really once we're compiling
09:40:42 <dcoutts_> it's better to pick consistent dependencies
09:40:53 <Baughn> Anything that mentions the actual linker symbol tends to be unreadable. Certainly, to a novice..
09:41:06 <dcoutts_> Baughn: it's not a linker symbol
09:41:11 <dcoutts_> bytestring-0.9.0.1:Data.ByteString.ByteString is a type
09:41:22 <Baughn> dcoutts_: I know. I didn't mean this time, really
09:41:41 <dcoutts_> but ghc has to include the package name in this case otherwise it ends up saying Data.ByteString.ByteString /= Data.ByteString.ByteString
09:41:45 <dcoutts_> which is silly
09:41:56 <dcoutts_> it has to be fully qualified in this case
09:42:09 <dcoutts_> in other cases ghc does not clutter the message with package names
09:42:51 <Baughn> I was thinking more of the times when it starts spewing names like "ghczm6zi8zi2_VectMonad_maybeV_closure"
09:43:04 <dcoutts_> ah the linker
09:43:33 <dcoutts_> those kinds of errors should never happen :-) they're not deliberate error messages from ghc
09:43:54 <Baughn> They happen a lot anyway. Should I be filing bug reports? -_-
09:44:05 <dcoutts_> they're usually recompilation checking bugs
09:44:13 <Baughn> Usually I solve it by reinstalling everything. I've got a nice script, by now..
09:44:24 <dcoutts_> JaffaCake is planning to replace the recompilation checker
09:44:32 <dcoutts_> Baughn: cleaning the package is usually enough
09:47:10 <simony_> does anyone have a link explaining the plans to add Monads and typeclasses to ML?
09:47:33 <chylli`> dcoutts_: it worked. thanks very much. btw, are you the author of cabal ?
09:48:06 <dcoutts_> chylli`: a maintainer
09:48:18 <Igloo> I would say "an author, the maintainer"
09:50:25 <chylli`> dcoutts_: sorry again. it sill has one error about HaXML
09:50:26 <chylli`> src/Text/XML/HaXml/ByteStringPP.hs:27:74:
09:50:27 <chylli`>     Module `Data.ByteString.Lazy.Char8' does not export `join'
09:50:28 <dcoutts_> Igloo: well, ok :-)
09:50:58 <dcoutts_> chylli`: that one is a haxml/bytestring incompatibility which I think malcolmw fixed the other day
09:51:31 <dcoutts_> malcolmw: is the working version on hackage?
09:52:17 <chylli`> dcoutts_: then I should upgrade it later ? wait for the new version ?
09:52:21 <chylli`> dcoutts_: thanks
09:52:38 <pastorn> @hoogle sortBy
09:52:38 <Cheiron> A Hoogle error occured.
09:52:52 <pastorn> @hoogle sort
09:52:53 <Cheiron> A Hoogle error occured.
09:52:56 <pastorn> yay
09:53:27 <saml> > liftM2 (+) (Just 1) (Just 2)
09:53:31 <Cheiron>  Just 3
09:53:35 <malcolmw> chylli`: the darcs version of HaXml has the fix
09:53:45 <saml> that's adding-underneath
09:54:07 <malcolmw> chylli`: or you could just change all occurrences of 'join' to 'intercalate', and then it will build ok
09:55:59 <chylli`> malcolmw: i think using darcs version is more simple :p
09:56:02 <chylli`> malcolmw: thanks
09:58:14 <byorgey> > liftA2 (+) (pure 1) [1..]
09:58:15 <Cheiron>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
10:00:19 * RayNbow still needs to read more stuff on liftA2 and the like...
10:00:27 <RayNbow> *on -> about
10:01:08 <dolio> liftA2 is just like liftM2, except it works on a few more things.
10:01:45 <Deewiant> > liftM2 (+) (return 1) [1..]
10:01:47 <Cheiron>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
10:02:06 <wjt> So the "correct" heirarchy should be Functor -> Applicative -> Monad ?
10:02:14 <dolio> Yeah.
10:02:46 <dolio> Possibly with some other stuff in there, depending on how detailed you like your category theory.
10:03:37 <dolio> For instance, edwardk has a library with a class for pointed functors, which have return/pure but not ap or bind or anything like that.
10:03:58 <dolio> So that could go between Functor and Applicative.
10:04:40 <wjt> it's not possible to let someone fill in return and >>= and get all the others to be implemented in terms of those magically, right?
10:05:14 <dolio> No, although there have been proposals for that.
10:15:29 <Arnar> if I export a type constructor declared with "data ... " from a module, will all the value constructors be exported automatically?
10:15:47 <Saizan> no
10:15:51 <dcoutts_> no, you have to export Foo(..)
10:15:58 <dcoutts_> if you want all the constructors exported
10:15:59 <Arnar> ok..
10:16:10 <dcoutts_> or Foo(Foo, Bar) to export only some of them
10:16:22 <Arnar> dcoutts_: ok.. thanks
10:16:57 <Arnar> Foo(..) will still export the type ctor, right?
10:17:55 <dcoutts_> yep
10:18:02 <Arnar> ok, cool
10:18:14 <dcoutts_> Arnar: Foo is the type (..) is all the constructors
10:18:31 <Arnar> yeah..
10:18:44 <Arnar> I suppose there'd be no use of exporting only the constructors and not the type
10:19:16 <dcoutts_> Arnar: it'd be pretty annoying if you could not write the type signatures
10:19:40 <Arnar> yes :)
10:25:42 <daveux> Hey, I'm generating docs with haddock and I can't figure out how to produce docs with the module header info (Desctiption, Maintainer, License, etc.)
10:26:23 <daveux> Here's the module: http://code.google.com/p/siegel-coveney/source/browse/trunk/final/Routine.hs
10:26:43 <daveux> It has the haddoc tags/comments at the top, but they are not appearing in the generated docs.
10:27:28 <dbpatterson> if I'm getting Could not find module `Data.ByteString.Unsafe': it is a member of package bytestring-0.9.0.1, which is hidden -- this is a cabal problem, right? how can I fix it (easiest way)
10:27:49 <byorgey> dbpatterson: just add 'bytestring' to the build-depends: field in the .cabal file
10:28:31 <zgold> What kind of functions does haskell have for reflection-type things.  Like passing along the 'name' of a constructor to be pattern matched again
10:28:42 <dbpatterson> byorgey: perfect.
10:30:36 <Bonus> i think if you need such reflection, you're probably doing something wrong
10:30:55 <byorgey> daveux: hmm... maybe it doesn't like the empty line before Maintainer?
10:31:27 <byorgey> daveux: normally that info should show up in the upper right corner of the generated haddock documentation
10:31:31 <byorgey> in the title bar
10:31:45 <zgold> Bonus: I'm trying to pass a list of classes to function A and inside A it does something which gets a constructor, and i want it to see if that constructor is in the last that was passed to i
10:32:09 <daveux> byorgey, ok, will try without the line
10:32:20 <daveux> yo, zgold, 552 in the IRC hizouse
10:32:39 <zgold> Making code beautiful is hard
10:32:56 <tromp> so is making it short:)
10:33:29 <zgold> so nothing on passing constructor names around?
10:33:33 <Bonus> yeah but i mean like on a larger scale
10:33:36 <zg0ld> hmm
10:33:42 <Bonus> if you have stuff organised nice and proper
10:33:45 <Bonus> you dont usually have to do that
10:34:00 <Bonus> since with that you'd lose a lot of the advantages of static types and such
10:34:04 <zgold> I mean, I could write 3 seperate functions which all do the same thing and pattern match differently
10:34:13 <zgold> or pass in what i want matched on
10:34:50 <byorgey> zgold: without seeing your code I can't be sure, but from what you've said it seems like it should be possible to do what you want in a nice way without reflection.
10:34:58 <byorgey> although it may involve some restructuring
10:35:36 <zgold> Is it a technique i may not be aware of or just being clever somehow?
10:36:10 <byorgey> zgold: without more details, I have no idea.
10:36:24 <NotBenPierce> @paste
10:36:24 <byorgey> zgold: hmm, are you a student at Penn?
10:36:24 <Cheiron> Haskell pastebin: http://hpaste.org/new
10:36:28 <zgold> hm alright, i'll keep playing
10:36:36 <zgold> byorgey: yep.
10:36:38 <NotBenPierce> zgold: you can show the bit of the code you want there
10:36:45 <byorgey> zgold: cool, I'm going to be starting a PhD there in the fall =)
10:36:46 <NotBenPierce> byorgey: there are three penn students in this room right now haha
10:36:53 <NotBenPierce> under who, byorgey?
10:37:19 <zgold> NotBenPierce apparently
10:37:24 <byorgey> NotBenPierce: well, with the programming languages group, so Ben Pierce, Steve Zdancewic, or Stephanie Weirich
10:37:31 <NotBenPierce> nice
10:38:06 <daveux> byorgey, a bunch of us are UPenn students
10:38:11 <daveux> in a Haskell course
10:38:17 <byorgey> daveux, awesome =)
10:38:36 <NotBenPierce> Ben Pierce is a cool guy...and tall
10:38:40 <daveux> byorgey, removing that empty line didn't work.
10:38:43 <byorgey> hehe, indeed
10:39:07 <byorgey> daveux: hmm, strange.  so in the generated html documentation, what is in the top right corner, in the title bar?  nothing?
10:39:14 <lilac> zgold: you can treat a constructor as a function, and pass it around as such. don't know if that helps
10:39:31 <zgold> yeah thats what its doing, which is the problem :)
10:40:01 <byorgey> zgold: so let me see if I understand the problem.
10:40:13 <byorgey> zgold: you are passing around some constructors as functions
10:40:20 <byorgey> but you want to be able to compare them for equality?
10:40:32 <zgold> Essentially, yes.
10:40:39 <zgold> So more specifically
10:40:59 <zgold> im reading "Actions" off the network, thats function A.  And I have 3 different other functions which each only care about certain actions
10:41:14 <zgold> I could write 3 functions to each pattern match on the appropriate action
10:41:29 <zgold> Or... what im trying to do now, be more clean
10:41:35 <byorgey> zgold: can you paste the definition of your Action type?
10:42:02 <zgold> data Action = Login | Logout | Challenge String String etc. (Theres more, but its not relavent)
10:42:52 <byorgey> so then you have, for example, some function  foo  which only cares about Login actions?
10:42:54 <dmwit> Do these three functions have the same return type?
10:43:04 <zgold> byorgey: yes.
10:43:31 <byorgey> hey, it's a Penn party!
10:43:39 <zgold> aha, had an idea
10:43:44 <byorgey> dmwit will also be starting a PhD at Penn in the fall =)
10:43:54 <zgold> Instead of passing in consturctor names, just pass in a function which matches appropriatly
10:44:08 <NotBenPierce> dmwit: who are you going to be a PhD under?
10:44:09 <byorgey> zgold: that sounds like an excellent idea to me =)
10:44:21 <byorgey> higher-order functions ftw!
10:44:23 <dmwit> NotBenPierce: Same answer: someone in the PL group.
10:44:57 <lispy> I'm wondering, is it possible to design a monad that behaves as a container but shuffles whats inside on every monadic operation?
10:45:15 <zgold> byorgey: thanks ;)
10:45:22 <dmwit> lispy: I don't see why not.
10:45:33 <jamesjb> cd
10:45:35 <byorgey> what do you mean, "shuffles what's inside"?
10:45:36 <jamesjb> oops
10:45:47 <sclv_> like a randomized list monad?
10:45:52 <byorgey> ~jamesjb$
10:46:10 <lispy> byorgey: good question.  So I was thinking, maybe it would be like the list monad, but (>>=) causes the list to get re-ordered implicitly
10:46:42 <byorgey> lispy: interesting.  intuitively I feel like that would violate the monad laws, but I'd have to think about it...
10:46:55 <sclv_> lispy: did you see the diagonalized list monad on hackage?
10:46:59 <Bonus> yeah uh
10:47:03 <lispy> sclv_: no i didn't
10:47:06 <Bonus> if you had a list
10:47:13 <Bonus> and it got randomized after passing through bind
10:47:18 <dbpatterson> sclv_: stmToHCGI (and my smugmug wrapper) is working and live - dbpatterson.com/photos
10:47:22 <Bonus> you'd probably violate m >>= return = m
10:47:22 <dmwit> lispy: That should be no problem, as long as you don't have to examine the contents in any way to do your reordering.
10:47:37 <byorgey> Bonus: ah, bingo =)
10:47:50 <sclv_> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-omega-0.2
10:47:52 <dmwit> oh
10:47:58 <dmwit> ?where monad laws
10:47:59 <Cheiron> I know nothing about monad.
10:48:20 <sclv_> dbpatterson: awesomes!
10:48:35 <lispy> The idea was this, we make a list that reorders itself and call the datatype Enterprise, then you can do, instance Monad Enterprise where ... , and it's a monad that is just full of chaos like a real Enterprise :)
10:48:49 <byorgey> haha
10:48:55 <dbpatterson> sclv_: there is alittle bit of ugliness because no list[num] accessing with stringtemplate, but it totally works...
10:49:03 <byorgey> well, in that case, an instance of Monad which doesn't actually satisfy the monad laws sounds quite appropriate =)
10:49:10 <dbpatterson> now I just need to polish up the wrapper and release it...
10:50:03 <Bonus> but if you have a monad that violates monadic laws i bet it would act pretty freaky with some monadic helper functions
10:50:03 <sclv_> the site redesign is very nice too..
10:50:07 <Bonus> like liftM, mapM etc
10:50:09 <dbpatterson> sclv_: thanks...
10:50:18 <byorgey> Bonus: not "freaky", "enterprisey"
10:50:26 <sclv_> how's it standing up to load (not that i expect you're getting scads) -- no weird issues so far?
10:50:27 <Bonus> ah yes
10:50:36 <Bonus> Haskell Enterprise Edition
10:50:40 <lispy> exactly
10:50:49 <dbpatterson> sclv_: none that I can tell.. but the heaviest I bet its gotten is when I open up 10 or 12 tabs trying to bog it down :)
10:51:10 <dbpatterson> I havent done any real load testing (ala apachebench)
10:51:30 <dbpatterson> mainly because I dont have apache :)
10:51:38 <dmwit> So, what happens badly when (>>= return) is not the identity?
10:51:56 <sclv_> dbpatterson: I'm thinking of reworking the tuple conversion in hstringtemplate -- rather than adding list functions in general, maybe just converting tuples to maps from numeric strings... does that sound like the right way to go?
10:52:00 <Baughn> Bonus: Write out the monad laws in terms of do-syntax, and they turn out to be merely intuition
10:52:22 <Baughn> So if you break them, you're breaking anyone who tries to use the monad
10:53:08 <dmwit> Or, reworded: what does '=' mean in "m >>= return = m"?
10:53:24 <dmwit> We might consider a re-ordering (of the same elements) to be equal...
10:53:26 <dbpatterson> sclv_: hmmm... well the one problem (potential) is if I wanted to access a numbered string with another variable. like, $container.anothervariable$ as apposed to $container.0$ (or perhaps I misunderstood what you meant)
10:53:36 <dbpatterson> where anothervariable = 0
10:53:39 <Bonus> hmm
10:57:44 <dbpatterson> does anyone here know safari? or webkit I guess - why if I replace the html of an image with a new image it wont load the new image? it works in firefox...
10:58:23 <Arnar> dbpatterson: that's a std. way of replacing images and should work in all browsers
10:58:36 <Arnar> dbpatterson: you are talking about modifying the dom in-place, right?
10:58:49 <dons> dcoutts_: i think we might need to look over the inlining again on binary
10:58:55 <dons> some results look a bit suboptimal
10:59:22 <dons> though at least unrolled loops look right.
10:59:31 <dbpatterson> Arnar: perhaps the problem is I am replacing the html (via jquery's .html("new html")) of the containing element, creating a whole new <img> tag?
10:59:39 <dbpatterson> should I just be modifying the src of the tag?
10:59:46 <simony_> is lambdabot alive?
11:00:13 <dons> ?bot
11:00:13 <Cheiron> :)
11:00:30 <dons> $wloop :: Word16 -> Int# -> (# (), Data.Binary.Builder.Builder #)
11:00:36 <dons> doesn't look as good as it should, dcoutts_
11:00:55 <eck> #vim
11:01:59 <simony_> @src block
11:01:59 <Cheiron> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
11:02:18 <dbpatterson> is Cheiron lambdabots clone?
11:03:17 <roconnor> @vixen are you easier than lambdabot?
11:03:18 <Cheiron> <undefined>
11:05:42 <ari> Lambda_Robots:_99%_Loyal :D
11:07:06 <Arnar> dbpatterson: modifying the source should do.. but the other method should work too
11:07:26 <Arnar> can I somehow see a complete list of names exported from a specific module, even though they are re-exports from other modules?
11:07:26 <bos> http://reddit.com/info/6isy0/comments/
11:07:45 <bos> Slides from last night's BayFP talk on concurrent and multicore Haskell
11:07:54 <Arnar> bos: ooh, nice
11:09:08 <Arnar> bos: oh, so that's who you are (your real name) :)
11:09:21 <simony_> cabal install sdl  fails because "configure" is not executable (ghc version: 6.6.1)... any idea why?
11:09:28 <bos> Arnar: most days, yes :-)
11:09:39 <Baughn> simony_: chmod u+x configure
11:09:54 <simony_> Baughn, its in the tarball, not convenient :P
11:10:09 <dons> great work, bos!
11:10:15 <Baughn> simony_: Unpack, set, repack?
11:10:28 <bos> dons: thanks. the talk went really really well.
11:10:30 <Baughn> simony_: Hang on.. you're using cabal-install?
11:10:45 <simony_> Baughn, using "cabal", isn't that cabal-install?
11:10:46 <bos> a 1.5x ratio of questions to talking time is pretty awesome.
11:10:49 <Arnar> so no-one knows how to produce a list of exported names for a module? lambdabot maybe?
11:11:11 <glguy> in GHCi that'd be :browse
11:11:13 <Baughn> simony_: If it's an executable program, yes. cabal is part of cabal-install, which is independent of (er, theoretically) the Cabal library
11:11:29 <Baughn> simony_: 6.6.1 is a bit old for this, but it should work.. could you paste your entire output somewhere?
11:11:47 <simony_> Baughn, k, upgrading cabal-install now (which is also upgrading Cabal appearantly)
11:11:58 <dons> bos, heh, yeah, that is a good  ratio
11:12:00 <Arnar> glguy: thanks
11:12:12 <simony_> Haskell compilation is slow :-)
11:12:21 <Baughn> simony_: FYI, cabal-install mostly just calls to Cabal. But upgrading Cabal will quite likely work.
11:12:26 <dbpatterson> Arnar: seems that safari and/or webkit likes it better when I just replace the attribute...
11:12:34 <Baughn> simony_: (Or just do "cabal upgrade")
11:12:44 <simony_> k, thanks
11:12:53 <simony_> Once everything is upgraded as far as possible, I'll retry
11:12:56 <Saizan> Baughn: i don't see how that helps if the 'configure' script is not executable
11:13:19 <Baughn> Saizan: Seeing as it works fine here, and missing further information, I've got a theory that cabal is supposed to /set/ it executable
11:16:17 <CosmicRay> is it just me or are there a lot of homework problems being posted to -cafe lately?
11:16:42 <Baughn> People are running out of time and getting desperate
11:16:55 <dons> CosmicRay: exam time?
11:16:56 <Baughn> (Why they don't ask comrades or teachers, I'll never know)
11:17:00 <CosmicRay> also in Cabal, is there an alternative to findProgramVersion that takes more than one parameter?  I can't find one, and can't figure out why findProgramVersion only takes one
11:17:02 <CosmicRay> heh
11:17:26 <CosmicRay> Baughn: yeah I remember this stuff cropping up in IRC before, but not on the list.  maybe I jsut missed it.
11:17:52 <dons> dcoutts_: ah spotted it. missing strictness on writes, leading to some weird inner loops
11:18:00 <dons> looks like that used to work, but changed with new ghc
11:18:45 <nathan> trying to compile xmobar with xft support. It says I am missing dependancies, which are not in my distros repos. can I hack the haskell to skip the check for dependancies? do I need to go find and compile X11-xft 0.2 ?
11:21:08 <byorgey> http://hpaste.org/7512
11:23:17 <simony> I think ghc of 'cabal upgrade' just thrashed my system to hell, the OOM thing started shooting random processes
11:24:35 <Arnar> I'm not finding this in the docs, but when inside a Writer monad, do I have a way of "resetting" the log back to mempty ?
11:24:48 <HrrblHskllProgrm> Is there a convenient way within haskell to parse something like "hello dog" blah blah and get (hello dog, blah blah) as a result?
11:24:53 <Baughn> simony: Oh, right.. it'll try to...
11:25:11 <Baughn> simony: Er, is upgrading to 6.8.2 an option? If not, don't do cabal upgrade. It'll try to do it for you, and fail.
11:25:50 <simony> Baughn, oh, cabal upgrade touches ghc even if its a system-wide one?
11:26:01 <simony> Baughn, I am upgrading to hardy in the background but it will take hours
11:26:27 <Baughn> simony: No, but it does touch bytestring and other libraries that *were* in base in 6.6.1 but have been split out since
11:26:47 <Baughn> simony: Just don't do cabal upgrade until that's done and you're on 6.8.2, then. You can upgrade cabal/cabal-install fine.
11:27:39 <glguy> Arnar: Prelude MonadLib> :t collect
11:27:39 <glguy> collect :: (RunWriterM m i) => m a -> m (a, i)
11:27:44 <glguy> is the closest I know of
11:27:49 <dolio> @seen SamB
11:27:49 <Cheiron> SamB is in #haskell and ##c. I last heard SamB speak 5h 10m 26s ago.
11:28:09 <HrrblHskllProgrm> Is there a convenient way in haskell to parse based on tokens?
11:28:11 <HrrblHskllProgrm> @seen yaxu
11:28:11 <Cheiron> I haven't seen yaxu.
11:28:37 <mauke> preflex: seen yaxu
11:28:38 -preflex(n=preflex@d90-128-17-80.cust.tele2.de)- Sorry, I haven't seen yaxu
11:28:44 <Arnar> glguy: thanks
11:28:52 <Baughn> simony: You'll be forced to reinstall your libraries after 6.8.2 is in, so keep the cabal binary around. It can reinstall itself fine, but if you lose it you'll need to install its dependencies manually.
11:29:09 <simony> Baughn, so upgrading everything on 6.6 is bound to break for sure?
11:29:37 <Arnar> glguy: where is that one defined?
11:29:40 <Arnar> @hoogle collect
11:29:40 <Cheiron> A Hoogle error occured.
11:29:42 <HrrblHskllProgrm> is there even a  basic parsing library inside of haskell or will I have to program it myself?
11:29:47 <Baughn> simony: Yes, since cabal-install doesn't handle package splits/merges, and some have happened.
11:29:47 <Arnar> @index collect
11:29:48 <Cheiron> bzzt
11:29:58 <mauke> HrrblHskllProgrm: like Parsec?
11:30:03 <glguy> Arnar: MonadLib
11:30:29 <HrrblHskllProgrm> mauke: I just want to be able to take the string "hello world" hi and get (hello world, hi) from it. can parsec do that?
11:30:38 <HrrblHskllProgrm> I mean clearly I could write a little method but I don't want to if haskell has it already
11:30:55 <mauke> > reads "\"hello world\" hi" :: [(String,String)]
11:30:58 <Cheiron>  [("hello world"," hi")]
11:30:58 <simony> Baughn, I wouldn't think its such a huge technological challenge to make a library compatible with the two major compiler versions out there :)
11:31:09 <HrrblHskllProgrm> wow mauke, that's great
11:31:12 <mauke> HrrblHskllProgrm: parsec can definitely do that
11:31:22 <byorgey> Arnar: there's no way to reset the log to empty in Writer. If you want to be able to do that you need to use State instead, I think.
11:31:25 <HrrblHskllProgrm> @type reads
11:31:26 <Cheiron> Plugin `type' failed with: invalid ghci output: no type signature
11:31:43 <HrrblHskllProgrm> > :t reads
11:31:43 <Cheiron>   parse error on input `:'
11:31:47 <Arnar> byorgey: ok.. figured as much
11:31:53 <Baughn> simony: The exact problem is that cabal deals with conflicts (versions) by picking one (the newest) package to use, and assumes that separate packages never try to grab the same namespace
11:31:56 <mauke> reads :: (Read a) => String -> [(a,String)]
11:32:03 <simony> Baughn, I removed my ~/.cabal and tried "cabal install cabal-install", and I get  ./Main.hs:27:7: Could not find module `Distribution.Verbosity':
11:32:14 <HrrblHskllProgrm> I see. thanks, mauke
11:32:30 <Baughn> simony: ..ah, upgrade cabal first
11:32:37 <Baughn> That is, cabal install cabal
11:33:03 <Baughn> simony: When bytestring was split from main into its own package, that assumption was broken since you could end up with both base and bytestring on the same system. Same for all the others that were split.
11:33:53 <simony> Baughn, http://hpaste.org/7513
11:34:15 <Baughn> simony: cabal /install/ cabal
11:34:23 <dcoutts> simony: the version of cabal-install on hackage is too old
11:34:25 <simony> Baughn, that says everything's already installed
11:34:28 <Baughn> simony: upgrade tries to upgrade /everything/, with the consequences I just suggested
11:34:31 <dcoutts> ignore it, use the darcs version
11:34:36 <byorgey> Arnar: actually, you could easily make your own ResettableWriter monad
11:34:36 <simony> dcoutts, even with ghc 6.6?
11:34:54 <dcoutts> simony: oh it works with both but you don't want it, it's too old
11:35:01 <dcoutts> there are major improvement in the current version
11:35:28 <Baughn> simony: Given that you'll have to reinstall everything afterwards anyway, I think the best path is to wait for hardy to install. ;)
11:39:33 <dejones> edwardk: if you don't mind me asking... do you get to work in missile control at Raytheon?  ;)  Raytheon has got some cool projects!
11:39:42 <Arnar> byorgey: ok.. I actually need a ResettableWriterT monad transformer.. but that shouldn't be much harder should it?
11:40:04 <edwardk> dejones: fraid not. mostly i help people figure out where the money is going on big programs
11:40:05 <byorgey> Arnar: no, not too much harder, I don't think.
11:40:15 <HrrblHskllProgrm> does haskell have a native trim command?
11:40:29 <Arnar> byorgey: nice.. this is a good idea for an excercise in monad transformers I guess :)
11:40:35 <byorgey> Arnar: indeed! =)
11:40:35 <glguy> HrrblHskllProgrm: is this homework?
11:40:36 <edwardk> dejones: so i only get to deal with missiles/radars at the abstract 'how much they cost and where the manpower' is level. =)
11:40:43 <dejones> edwardk: ahh... I guess you get paid more than the missile control programmers since you are deciding where the money actually goes.  ;)
11:40:45 <HrrblHskllProgrm> glguy: no, I'm using it in a bigger program
11:40:53 <dejones> edwardk: management, eh?
11:40:55 <HrrblHskllProgrm> glguy: I could write one but I'd rather use it if it's in the prelude
11:40:58 <glguy> it has dropWhile isSpace
11:41:03 <dcoutts> CosmicRay: you were asking about findProgramVersion in Cabal, what were you after?
11:41:06 <glguy> for trimLeft
11:41:08 <edwardk> meh, mostly i just get the right people data to make those calls
11:41:26 <CosmicRay> dcoutts: the ability to specify more than one command-line parameter
11:41:41 <byorgey> > let f = dropWhile isSpace . reverse ; trim = f . f  in trim "   hello world!    "
11:41:42 <Cheiron>  "hello world!"
11:41:51 * edwardk works as a consultant. So the conclusion is correct, but the path to it was a little off. =)
11:41:55 <glguy> let trimRight = foldr (\ x xs -> if isSpace x && null xs then [] else x : xs) [] in trimRight "a simple test  "
11:42:01 <dejones> edwardk: hehe
11:42:01 <glguy> > let trimRight = foldr (\ x xs -> if isSpace x && null xs then [] else x : xs) [] in trimRight "a simple test  "
11:42:02 <CosmicRay> dcoutts: I essentially need to call python ["-c", "import sys; print sys.version"]
11:42:02 <Cheiron>  "a simple test"
11:42:09 <dcoutts> CosmicRay: oh right
11:42:16 <Arnar> byorgey: I wonder if I need it though.. I have a monad (lets call it TMI) that is essentially a WriterT [LogEntries] STM
11:42:19 <CosmicRay> dcoutts: I can do that later with rawSystemProgramStdout
11:42:35 <Arnar> byorgey: and modified readTVar/writeTVar that "tell" entires into the log
11:42:37 <dcoutts> CosmicRay: yeah, we kind of assumed that programs have a --version flag or equivalent
11:42:41 <byorgey> Arnar: ok
11:42:50 <CosmicRay> dcoutts: but findProgramVersion seems to oddly pass the string to the program as one big one, but only after putting backslashes before the single quotes
11:42:52 <Arnar> byorgey: I'm trying to lift orElse into this TMI monad
11:42:53 <HrrblHskllProgrm> as always, thanks byorgey and glguy
11:43:04 <Arnar> byorgey: and retry too infact..
11:43:10 <CosmicRay> dcoutts: python does, but it writes to stderr.
11:43:16 <dcoutts> doh!
11:43:24 <CosmicRay> yep.
11:43:29 <edwardk> Now if only I could find a good excuse to use haskell here =)
11:43:30 <Arnar> byorgey: I'm not 100% sure but I think if retry for examples retries the tx twice, I will in the end have the log for both (which I don't want)
11:44:05 <byorgey> Arnar: hm, I'm not sure you will actually
11:44:09 <dcoutts> CosmicRay: it doesn't do much odd, it just calls rawSystemStdout verbosity path [versionArg]
11:44:18 <byorgey> @unmtl WriterT [Int] IO
11:44:19 <Cheiron> err: `WriterT [Int] IO' is not applied to enough arguments, giving `/\A. IO (A, [Int])'
11:44:24 <byorgey> @unmtl WriterT [Int] IO a
11:44:24 <Cheiron> IO (a, [Int])
11:44:30 <dcoutts> CosmicRay: it doesn't do any escaping or other string processing, but it does pass just one arg
11:44:36 <Arnar> byorgey: ok.. I guess I could cook up a test function
11:44:48 <CosmicRay> dcoutts: ah.  I haven't looked at the source yet, but from looking at the api docs briefly it seemed that there was a chicken-and-egg problem preventing me from using rawSystemStdout
11:44:56 <byorgey> Arnar: WriterT [LogEntries] STM a  is equivalent to STM (a, [LogEntries])
11:44:58 <Arnar> byorgey: one that retries a few times..
11:45:05 <dcoutts> CosmicRay: it doesn't catch stderr
11:45:16 <daveux> Is there any f = Monad m => m [a] -> (a -> b) -> m [b]   ?
11:45:17 <Arnar> byorgey: oh.. right, so then the log will be "rolled back"?
11:45:31 <byorgey> Arnar: yes, I think so
11:45:33 <CosmicRay> dcoutts: strace sez: 26090 execve("/usr/bin/python", ["/usr/bin/python", "-c \'import sys; print sys.version\'"], [/* 37 vars */]) = 0
11:45:39 <CosmicRay> weird eh
11:45:49 <Arnar> byorgey: allright, then my problems were nonexistent in the first place..
11:45:55 <Arnar> byorgey: I'll verify this with tests
11:45:55 <mauke> :t liftM . map
11:45:55 <CosmicRay> hopefully your rawSystemStdout isn't doing that
11:45:58 <Arnar> thanks byorgey++
11:46:02 <byorgey> Arnar: you should definitely try testing it before you go to the trouble of writing a new monad transformer =)
11:46:08 <dcoutts> CosmicRay: hmm, and that's with ghc not hugs?
11:46:14 <CosmicRay> dcoutts: yup
11:46:34 <Arnar> byorgey: yeah -- although I'd have fun doing it if I had time to spare :)
11:46:40 <mauke> daveux: flip (liftM . map)
11:47:06 <HrrblHskllProgrm> mauke don't tell me you're also getting a PhD in CS or else everyone who has helped us today is a PhD in CS :P
11:47:09 <byorgey> Arnar: true, nothing wrong with that, it might be a fun exercise anyway =)
11:47:12 <dcoutts> CosmicRay: rawSystemStdout uses runInteractiveProcess so check if that's doing weird arg processing
11:47:45 <mauke> HrrblHskllProgrm: ok, I won't :-)
11:47:59 <RayNbow> I was just wondering (thanks to a discussion with luite on a different IRC server)... has anyone ever been crazy enough to define a Haskell interpreter Turing Machine? :p
11:48:04 <CosmicRay> dcoutts: ok, will do.  that would suck, but would not be the first bug in it.
11:48:13 <HrrblHskllProgrm> mauke are you getting a PhD?
11:48:18 <mauke> HrrblHskllProgrm: no
11:48:21 <HrrblHskllProgrm> lol word
11:48:28 <dcoutts> CosmicRay: wait it is doing something stupid
11:49:11 <edwardk> HrrblHskllProgrm: after all, he stopped collecting them a while ago =)
11:49:25 <HrrblHskllProgrm> haha, nice, that's the way to do it :P
11:49:42 <dcoutts> CosmicRay: hmm, no I'm mis-reading
11:50:24 <simony> I got the new cabal-install from darcs and its Setup.hs wants "Could not find module `Distribution.Simple':"  (ghc 6.6)
11:50:37 <simony> dcoutts, are you sure it works with ghc 6.6?
11:51:35 <dcoutts> simony: yes, Distribution.Simple has always been part of the Cabal lib
11:51:51 <dcoutts> simony: so it looks like you're missing the Cabal lib completely for some reason
11:51:59 <dcoutts> ghc-pkg list Cabal
11:52:03 <dcoutts> will tell you
11:52:28 <simony> /usr/lib/ghc-6.6.1/package.conf: Cabal-1.1.6.2   and   /home/simony/.ghc/x86_64-linux-6.6.1/package.conf: Cabal-1.2.3.0
11:53:34 <dcoutts> simony: so what command are you running exactly? and in what context?
11:53:52 <simony> dcoutts, ghc --make Setup   inside the darcs branch of cabal-install
11:54:59 <dcoutts> simony: it works for me with ghc-6.6.1, I don't understand because both versions of Cabal you've got provide the module in question
11:56:01 <mileswu> Has anyone had any problems with plugins-1.2? It seems to be failing the configure script
11:56:37 <simony> dcoutts, my fault.. I "cleaned up" my ~/.cabal without removing relevant stuff from ~/.ghc
11:57:06 <dcoutts> simony: ohh, so you had deleted the actual installation of Cabal-1.2.3.0 but it was still registered
11:57:13 <simony> dcoutts, yeah :-(
11:57:30 <Arnar> is there a generic way to lift a (Monad m) => m a -> m a -> m a  function to a transformed monad?
11:57:39 <Arnar> something like (lift2 .)
11:57:40 <Arnar> ?
11:58:06 <Arnar> no... that didn't make sense :/
11:58:20 <dcoutts> simony: so the darcs version of cabal-install also needs the darcs version of the Cabal lib
11:58:53 <simony> dcoutts, yeah and its so slow to download :(
12:00:01 <mileswu> @src mapM
12:00:02 <Cheiron> mapM f as = sequence (map f as)
12:00:17 <mileswu> @src foldM
12:00:17 <Cheiron> foldM _ a []     = return a
12:00:17 <Cheiron> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:00:47 <dcoutts> simony: even with --partial?
12:01:03 <dcoutts> simony: I'll make a new snapshot
12:01:15 <simony> dcoutts, I don't know about --partial
12:01:16 <Cale> odd, lambdabot thinks it's still running
12:01:29 <dcoutts> simony: it means you don't download the full repo history
12:01:38 <simony> dcoutts, ah thanks
12:02:00 <Cale> oh, and the server still thinks lambdabot's alive...
12:02:01 <Cale> heh
12:02:37 <ari> @botsmack
12:02:37 <Cheiron> :)
12:02:41 <lambdabot> :)
12:02:47 <RayNbow> @faq
12:02:47 <Cheiron> The answer is: Yes! Haskell can do that.
12:02:54 <mmorrow> mileswu: what was the error msg?
12:02:55 <lambdabot> The answer is: Yes! Haskell can do that.
12:03:08 <RayNbow> laggy lambdabot is laggy :p
12:03:18 <Arnar> lambdabot++ welcome back! :)
12:03:24 <simony> dcoutts, why is it downloading patches even with partial? (although much fewer)
12:03:30 <mileswu> mmorrow: C compiler can't create exectubles
12:03:31 <dbpatterson> does anyone know, how far is the gtkwebkit version of rendering from the safari webkit rendering? ie, can I test for safari with epiphany-webkit?
12:04:16 <mmorrow> mileswu: did you darcs get from http://code.haskell.org/~dons/code/hs-plugins
12:04:20 <mauke> @bot
12:04:20 <Cheiron> :)
12:04:21 <lambdabot> Title: Index of /~dons/code/hs-plugins
12:04:27 <lambdabot> :)
12:04:38 <mauke> Cheiron: @part #haskell
12:04:39 <dcoutts> simony: it downloads all the current patches since the last repo tag/snapshot
12:04:46 <mileswu> mmorrow: No. Got it from hackage. Does it matter?
12:05:14 <mmorrow> mileswu: yeah, do: darcs get --partial http://code.haskell.org/~dons/code/hs-plugins
12:05:14 <lambdabot> Title: Index of /~dons/code/hs-plugins
12:05:36 <mauke> :t local
12:05:39 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
12:06:23 <mmorrow> mileswu: also, what ghc version are you running?
12:06:37 <mileswu> mmorrow: 6.8.2
12:07:20 <mmorrow> mileswu: either way you should get it from darcs. lemme know if it builds for you because I have some fixes if not...
12:07:23 <Vulpyne> Ugh, trying to install ghc on a machine without ghc is horrible.
12:07:56 <mileswu> mmorrow: Yeah. I'm getting it now
12:08:36 <mileswu> mmorrow: Nope. Same error I'm afraid
12:09:12 <mmorrow> mileswu: oh no. it's in the configure output, right?
12:09:24 <mileswu> mmorrow: yes
12:09:50 <mmorrow> mileswu: maybe edit configure and just make that test trivially succeed
12:10:28 <byorgey> Vulpyne: eh? why?  can't you just get a binary?
12:10:57 <byorgey> or install it through your package system?
12:11:07 <mmorrow> mileswu: searching for the error msg txt in configure should find it
12:11:56 <Vulpyne> byorgey: Nope, FreeBSD ports says that the package isn't available (cause there isn't an older version installed to compile with), and it's a slightly oldish x64 version.
12:12:07 <dbpatterson> would anyone on safari mind checking this my site and see if clicking next (need to have javascript enabled) or prev goes to a new photo, with a spinning loading graphic in between (if your connection is too fast you might miss it)? actually, if someone on IE wanted to test, that would be great (damn linux development)... - url: http://dbpatterson.com/photos
12:12:09 <lambdabot> Title: dbpatterson.com - photos
12:12:19 <Vulpyne> I think I may be getting close though, found an older version of x64 binaries that may be enough to compile the latest with.
12:12:26 <byorgey> Vulpyne: yikes
12:15:06 <Baughn> dbpatterson: Works fine in safari, but shouldn't you preload the images?
12:15:20 <dbpatterson> Baughn: baby steps.. it is coming :)
12:15:26 <dbpatterson> thanks
12:15:27 <Baughn> dbpatterson: Completely nonfunctional in firefox
12:15:38 <dbpatterson> Baughn: what version, on what os?
12:15:46 <Baughn> dbpatterson: 3.0b5, os x
12:16:00 <Baughn> Oh, but I've got noscript jammed (and on), so..
12:16:05 <dbpatterson> :)
12:16:10 <dbpatterson> it should fail silently
12:16:13 <dbpatterson> ie, the buttons shouldnt show up
12:16:17 <Baughn> It failed silently, yes.
12:16:17 <dbpatterson> if javascript is blocked
12:16:29 <Baughn> Those buttons really should fall back to plain old anchors
12:17:06 <dbpatterson> meh... it woudl be a huge pain to support it w/o javascript, so I like it better this way...
12:17:09 <mileswu> @version
12:17:09 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
12:17:09 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:17:50 <Baughn> dbpatterson: Then I claim you need a better framework. It doesn't need to lok as nice, but right now I'd never be able to use it at all
12:18:30 <Baughn> I don't normally /use/ safari, you understand, and I like to keep javascript off. It makes firefox considerably faster when you have 400+ tabs.
12:18:30 <dbpatterson> Baughn: yell at sclv, hehe.. its his framework (though not his fault at all)
12:19:21 <maltem> Baughn, erm, 400+ tabs?
12:19:32 <Baughn> Stuff I Will Read Later
12:19:32 <dbpatterson> Baughn: well, the non-js functionality is how I had the site entirely before.. random photo each time you went there, you can click on it to see the full gallery. it is really just playing with javascript for me to add the next and previous buttons... so like I said, just not worth it to support it statically.
12:19:48 * maltem imagines 400 books laying open on my desk
12:22:02 * maltem further imagines to assure, I need those, I'll read them all later! ;-)
12:23:07 <Baughn> But I /did/ read them later!
12:23:12 * Baughn was at ~1300 tabs in november
12:23:37 <dbpatterson> really?
12:23:49 <mauke> I never open more than a few hundred tabs in firefox
12:23:50 <Baughn> I wrote a program specifically to count them.
12:23:52 <dbpatterson> I'm amazed firefox handled that at all, no-script or not
12:24:07 * dbpatterson tries to keep it under 20
12:24:12 <Baughn> dbpatterson: 64-bit machine. I believe it swapped out a couple gigabytes, but it handled it well.
12:24:27 <dbpatterson> impressive...
12:24:39 <mauke> it's great for porn browsing
12:24:40 <Baughn> Mind you, 3.0b3 was a /lot/ more responsive than 2.x
12:24:55 <mileswu> Baughn: and how long did it take to choose what 10% of the internet to open up
12:25:09 <Baughn> mileswu: Oh, I'd been collecting them for a year or so at the time
12:25:23 <mauke> I can't run firefox that long :/
12:25:39 <dbpatterson> mauke: thankfully when it crashes it can recover your tabs :)
12:25:41 <mauke> it runs out of some kind of resource and fails to update the content area after some time
12:25:42 <smg> hello.
12:25:53 <Baughn> Whenever I wanted to do something with haskell, I just searched the tabs until I found a Haskell Documentation Cluster. There were several to choose from.
12:26:17 <Baughn> mauke: Right, which is why I had session management. And backups.
12:26:28 <smg> @pl pali x = if reverse x == x then True else False
12:26:28 <lambdabot> pali = flip (flip if' True . ((==) =<< reverse)) False
12:27:05 <Baughn> smg: (Beware: if' is not in the prelude. Nobody knows why.)
12:27:27 <smg> what does if' do?
12:27:31 <Baughn> @src if'
12:27:31 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:27:32 <mauke> class Choose a where choose :: a -> b -> b
12:27:36 <smg> i mean that pointless style is pointless indeed :)
12:27:43 <mauke> if' = choose
12:27:44 <Baughn> @let if' p a b = if p then a else b
12:27:45 <lambdabot> Defined.
12:28:02 <mauke> a && b = choose a b a
12:28:09 <mauke> a || b = choose a a b
12:28:16 <Baughn> @list
12:28:17 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:28:41 <smg> mauke: ty
12:28:49 <smg> lambdabot is cool, but that @pl stuff is not good
12:29:42 <Baughn> smg: @pl output is sometimes useful, and deciphering it makes a good workout
12:29:46 <daveux> How do i safely do a read on what I hope is a string representation of an int?
12:30:00 <Baughn> reads
12:30:15 <Baughn> > reads "forty-two" :: [(Int,String)]
12:30:17 <lambdabot>  []
12:30:19 <dmwit> mauke: Whoa, that definition of (&&) and (||) is pretty neat.
12:30:30 <Baughn> > reads "42 43" :: [(Int,String)]
12:30:32 <lambdabot>  [(42," 43")]
12:30:59 <mauke> dmwit: perl-style
12:31:18 <Baughn> @src reads
12:31:18 <lambdabot> reads = readsPrec minPrec
12:31:25 <daveux> oh, I see
12:31:31 <daveux> thank you
12:31:37 <Baughn> Would reads ever return a list of more than one element, I wonder?
12:31:49 <dmwit> Baughn: Only if you define a type with multiple parses.
12:32:02 <dmwit> Baughn: i.e. something described by an ambiguous grammar.
12:32:07 <Baughn> dmwit: So it's possible. I was wondering why it isn't Maybe.
12:32:25 <smg> i like the clean style of haskell
12:32:30 <dmwit> Yeah, [] is just a *smidge* more general. =)
12:32:34 <dmwit> smg: Me too!
12:32:45 <ddvlad> would trying to parse a String into some sort of TokenTree justify using a Reader String TokenTree? I've never used reader before so i would'nt know
12:32:46 <dmwit> smg: All the language design decisions came from math -- awesome!
12:32:54 <Baughn> smg: I want to write physics with it
12:33:07 <Baughn> I'm sure I could cook up something nicer than what we're living in. ;)
12:33:14 <dmwit> ddvlad: Sure, that's a great use of Reader.
12:33:31 <dmwit> ddvlad: Although you may want to just use Parsec if this is not a learning exercise.
12:33:54 <ddvlad> dmwit: it's a learning excercise :-)
12:34:04 <ddvlad> dmwit: hoped so, but didn't want to start off wrong, like i did countless times. thank you
12:34:19 <dmwit> ddvlad: The key function for you, I think, will be "local":
12:34:20 <dmwit> :t local
12:34:22 <mehrheit> is it possible to redefine []?
12:34:25 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
12:34:41 <dmwit> mehrheit: Not really, unless you hack on the compiler itself.
12:35:08 <mehrheit> ok
12:35:26 <ddvlad> dmwit: hmm, never heard of local. thanks for the tip; i'm off to try everything
12:35:49 <Baughn> mehrheit: Stand by
12:35:56 <dmwit> ddvlad: Hmm, this is a token *tree*?
12:36:29 <ddvlad> dmwit: so i thought to make it; i'm parsing lisp-style syntax
12:36:34 <ddvlad> (s-expressions, right?)
12:36:55 <smg> dmwit: hehe yes it's cool
12:36:57 <smg> Baughn: :)
12:37:06 <Baughn> mehrheit: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax <-- Nope, but what /can/ be rebound is described here
12:37:08 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
12:37:13 <dmwit> ddvlad: Ah, okay.  So, you may want to bump it up to State, so that your branch parser can consume some of the string.
12:37:58 <ddvlad> dmwit: "bump it up" == "use monad transformer", or was that just a figure of speech?
12:38:14 <dmwit> ddvlad: Just a figure of speech; I mean use State *instead of* Reader.
12:38:43 <ddvlad> hmm... State (String, TokenTree)?
12:38:46 <Baughn> ddvlad: Once you've /used/ Parsec, it should be reasonably simple to see how to reimplement it (badly). (The other kinds of parsers, though..)
12:38:56 <smg> http://hpaste.org/7515
12:38:57 <smg> :)
12:39:06 <smg> haskell vs. java, i love hs :)
12:39:08 <byorgey> "bump it up" as in "kick it up a notch" as in "use something strictly more powerful" as in BAM!
12:39:25 <dmwit> ddvlad: State String TokenTree, maybe.
12:39:30 <dmwit> :t runState
12:39:32 <lambdabot> forall s a. State s a -> s -> (a, s)
12:39:36 <mehrheit> Baughn, ok, just thought that I saw someone here mention aliasing [] to pure
12:39:37 <dmwit> Yep, that.
12:39:38 <ddvlad> Baughn: nope, never used parsec, nor would i probably have anything to gain i think
12:39:47 <ddvlad> dmwit: i see
12:40:31 <smg> dmwit: you looked at it? :D
12:41:16 <mehrheit> oh, it was quicksilver
12:41:31 <Baughn> ddvlad: Well, you'd gain hints as to how a parser can be put together. I don't know how much magic Parsec does, but a recursive-descent parser /could/ be almost just pure State
12:42:10 <dmwit> smg: http://hpaste.org/7515#a1 ;-)
12:42:50 <smg> dmwit: ah nice
12:42:56 <ddvlad> Baughn: I'm sure Parsec would mean a lot, but my lab assistant has only basic Haskell skills. So I'd best not toot my own horn
12:43:00 <dmwit> smg: Although it's not totally fair, since the Java version is case-insensitive.
12:43:01 <smg> dmwit: you see i coded now 3 month in java it makes my brain mud :)
12:43:08 <smg> dmwit: hehe true
12:43:16 <ddvlad> (I'm lucky I can write haskell, so I should'nt push it)
12:44:13 <dmwit> smg: Luckily, it's a three-word fix. http://hpaste.org/7515#a2 =)
12:44:14 <Baughn> ddvlad: For your own edification, then?
12:44:50 * Baughn had to cope with a TA who put syntax errors and worse nonsense in the exam code examples. In scheme.
12:45:02 <dmwit> syntax errors... in Scheme?
12:45:04 <ddvlad> Baughn: definitely. it it were only homework, i wouldn't be giving it that much time. haskell is the best thing this seester
12:45:09 <dmwit> There's what, like three possible tokens?
12:45:30 <Baughn> if was never meant to be called without arguments
12:45:49 <smg> dmwit: yeah i changed it now
12:46:17 <smg> dmwit: but i have strange error: if i say checkMany = map checkOne i will get some rather strange "polymorphism" error
12:46:36 <dmwit> smg: Paste the code and the error, please.
12:47:09 <smg> k
12:48:46 <HrrblHskllProgrm> is there a convenient prelude command to take every nth element from a list?
12:48:58 <smg> dmwit: http://hpaste.org/7515#a3
12:49:03 <smg> why does it say that? :D
12:49:22 <ddvlad> HrrblHskllProgrm: map (!!n) ?
12:49:38 <ddvlad> :t map (!!n)
12:49:40 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
12:49:40 <lambdabot>     In the second argument of `(!!)', namely `n'
12:49:40 <lambdabot>     In the first argument of `map', namely `(!! n)'
12:49:47 <dmwit> :t \n -> map (!!n)
12:49:48 <lambdabot> forall a (f :: * -> *). (Functor f) => Int -> f [a] -> f a
12:49:59 <dmwit> :t map (!!) [n,2*n..]
12:50:01 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
12:50:01 <lambdabot>     In the expression: n
12:50:01 <lambdabot>     In the second argument of `map', namely `[n, 2 * n .. ]'
12:50:04 <dmwit> whoops
12:50:05 <Baughn> > iterate (drop 2) [1..10]
12:50:06 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[5,6,7,8,9,10],[7,8,9,10],[9,10],...
12:50:06 <byorgey> I don't think map (!!n) is what HrrblHskllProgrm wants
12:50:12 <dmwit> :t map (flip (!!)) [n,2*n..]
12:50:13 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
12:50:13 <lambdabot>     In the expression: n
12:50:13 <lambdabot>     In the second argument of `map', namely `[n, 2 * n .. ]'
12:50:16 <Baughn> > mp take $ terate (drop 2) [1..10]
12:50:17 <lambdabot>   Not in scope: `terate'
12:50:18 <HrrblHskllProgrm> ddvlad: I what I mean is like you have a list [a] and want every element such that it is the element mod 4 or something
12:50:24 <Baughn> > map (take 1) $ terate (drop 2) [1..10]
12:50:24 <lambdabot>   Not in scope: `terate'
12:50:28 <Baughn> > map (take 1) $ iterate (drop 2) [1..10]
12:50:30 <lambdabot>  [[1],[3],[5],[7],[9],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
12:50:31 <HrrblHskllProgrm> ie [1,2,3,4,5,6,7,8] we want ever 3rd so we get [3,6]
12:50:34 <ddvlad> byorgey, HrrblHskllProgrm : oops, sorry. i'm new :-)
12:51:05 <kpreid> HrrblHskllProgrm: map snd . filter ((== 0) . mod 4 . fst) . zipWith [0..]
12:51:07 <HrrblHskllProgrm> haha baughn that is clever
12:51:08 <byorgey> > let every4th = map snd . filter ((==0) . (`mod` 4) . fst) . zip [0..]  in every4th [1..]
12:51:10 <lambdabot>  [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97,101...
12:51:16 <smg> dmwit: still in?
12:51:17 <byorgey> ddvlad: no worries =)
12:51:42 <dmwit> > let every4th xs = map (xs!!) [3,7..length xs] in every4th [1..] -- the slow way
12:51:47 <lambdabot> Terminated
12:51:50 <dmwit> =)
12:51:56 <byorgey> HrrblHskllProgrm: you could do it that way, by zipping the list with indices, filtering on the indices you want, and then discarding the indices to recover the original list elements
12:51:59 <kpreid> I like Baughn's version
12:51:59 <dmwit> smg: Sorry, I got distracted. =P
12:52:05 <smg> dmwit: i have nifty solution: checkPalindroms = map ((\z -> (reverse z == z, z)) . map toLower)
12:52:08 <HrrblHskllProgrm> hmm
12:52:09 <smg> dmwit: how about that? :)
12:52:16 <dmwit> smg: Yeah, you got bit by the monomorphism restriction.
12:52:26 <dmwit> smg: The preferred solution is to give checkOne an explicit type signature.
12:52:34 <smg> dmwit: i am sorry i forgot about monomorphism restriction :|
12:52:41 <smg> dmwit: ah okay thank yo
12:52:41 <Baughn> > concat $ map (take 1) $ iterate (drop 2) [1..10]
12:52:52 <lambdabot>  [1,3,5,7,9Exception: Time limit exceeded
12:52:57 <dmwit> smg: So, leave checkOne x = (reverse x == x, x), but give also checkOne :: Eq a => [a] -> (Bool, [a]).
12:53:18 <Baughn> > concat $ filter (not null) $ map (take 1) $ iterate (drop 2) [1..10]
12:53:19 <lambdabot>  Couldn't match expected type `Bool'
12:53:25 <byorgey> > map head . takeWhile (not . null) . iterate (drop 2) $ [1..10]
12:53:26 <lambdabot>  [1,3,5,7,9]
12:53:31 <dmwit> > map head . takeWhile (not . null) . iterate (drop 2) [1..10]
12:53:32 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
12:53:37 <dmwit> bah
12:53:39 <byorgey> hehe
12:53:40 <HrrblHskllProgrm> this is my current answer...I guess I am afraid of making it too unreadable
12:53:41 <HrrblHskllProgrm> reads "\"hello world\" hi" :: [(String,String)]
12:53:42 * dmwit can't Haskell today
12:53:42 <HrrblHskllProgrm> oops
12:53:56 <smg> dmwit: yeah
12:54:05 <smg> @pl p x = product $ enumFromTo 1 x
12:54:06 <lambdabot> p = product . enumFromTo 1
12:54:15 <HrrblHskllProgrm> apparently copying from vim isn't as easy as I might like!
12:54:25 <dmwit> "*<movement>y
12:54:31 <dmwit> err...
12:54:35 <dmwit> "*y<movement>
12:55:08 <dmwit> In Windows, you can also highlight and press Ctrl-c, as usual. ;-)
12:55:53 <HrrblHskllProgrm> hahah I'm on a mac
12:56:00 <HrrblHskllProgrm> not sure how to "*y<movement> in vim lol
12:56:08 <dmwit> ...
12:56:11 <smg> dmwit: do you like it? :D
12:56:18 <dmwit> Those are the literal keypresses, with the exception of <movement>.
12:56:30 <dmwit> smg: Which, your definition of factorial?
12:56:36 <smg> no :)
12:56:40 <smg>  checkPalindroms = map ((\z -> (reverse z == z, z)) . map toLower)
12:56:41 <smg> ^^
12:56:53 <dmwit> Oh, yeah, you can do that.
12:56:59 <smg> btw
12:57:01 <HrrblHskllProgrm> dmwit: shift+' followed by shift+8 followed by y followed by a movement?
12:57:06 <dmwit> I think it's more readable to name the (\z -> ...) function, though.
12:57:13 <smg> i'm just wondering why i can't write mypdoruct x = product $ enumFromTo 1
12:57:13 <dmwit> HrrblHskllProgrm: yes
12:57:15 <ski_> @check \s -> (s :: String) == reverse s
12:57:17 <lambdabot>  Falsifiable, after 0 tests: "\544565\613373"
12:57:19 <ski_> @scheck \s -> (s :: String) == reverse s
12:57:20 <smg> dmwit: hehe yeah
12:57:21 <lambdabot>   Failed test no. 5. Test values follow.: "ba"
12:57:37 <HrrblHskllProgrm> that doesn't work dmwit alas
12:57:47 <dmwit> HrrblHskllProgrm: What do you mean?
12:57:49 <ddarius> vim yank to clipboard (?)
12:57:53 <dmwit> yeah
12:57:56 <HrrblHskllProgrm> yeah, that's what I'm trying to do
12:58:04 <HrrblHskllProgrm> it just gives me a clicky sound and nothing happens
12:58:08 <HrrblHskllProgrm> the mac "that did not work" sound
12:58:13 <smg> dmwit: you know why
12:58:24 <dmwit> HrrblHskllProgrm: Did you try pasting into another program after that?
12:58:32 <HrrblHskllProgrm> I tried pasting into here haha
12:58:33 <esteth_> am i correct in thinking a.b.c.d = a(b(c(d))), and a$b$c$d = (((a(b(c(d) ?
12:58:35 <dmwit> HrrblHskllProgrm: If so, Mac's primary might be "+ rather than "*.
12:58:44 <ddarius> esteth: No
12:58:46 <dmwit> smg: Yes, because enumFromTo is a function, not a list.
12:59:00 <dmwit> ?src ($)
12:59:01 <lambdabot> f $ x = f x
12:59:02 <smg> ah
12:59:08 <mehrheit> @type fix
12:59:08 <smg> seems reasonable =)
12:59:09 <lambdabot> forall a. (a -> a) -> a
12:59:11 <Baughn> @scheck \x -> (x :: Int) < 40000 || x > 40003
12:59:12 <lambdabot>   Completed 13 test(s) without failure.
12:59:17 <mehrheit> @type mfix
12:59:19 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
12:59:22 <smg> dmwit: you see, a few months java and my brain needs re-training for haskell.
12:59:26 <dmwit> smg: More importantly, (enumFromTo 1) is still a function (and not a list).
12:59:31 <ski_> esteth_ : a . b . c . d = \x -> a (b (c (d x)))
12:59:32 <smg> yeah exactly
12:59:42 <ski_> esteth_ : (a . b . c . d) x = a (b (c (d x)))
13:00:06 <mehrheit> @index fix
13:00:06 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
13:00:25 <esteth_> ski_: Ok, so . sequences things "from the right" and $ sequences things "from the left" ?
13:00:25 <ski_> Baughn :)
13:00:26 <ddarius> And finally to drive home the confusion: a . b . c . d $ x = a (b (c (d x)))
13:00:35 <ddarius> esteth: No.
13:00:52 <ddarius> (.) is function composition, it takes two functions and returns a function.
13:01:03 <ddarius> ($) is function application, it takes a function and a value and returns a value.
13:01:04 <ski_> esteth_ : no, `.' composes (doesn't matter if you think from the left or from the right, it's the same)
13:01:33 * maltem votes for a broader usage of the very readable (f . g) x way. (Just if you wouldn't have to move the cursor to the beginning of the line to put that opening paren into its place...)
13:02:11 <esteth_> Ah, ok. (a . b) x = give x to a, then give the result to b, then spit the result out?
13:02:22 <ddarius> No.
13:02:38 <ski_> esteth_ : it gives `x' to `b', then gives the result of that to `a', and then returns that result
13:02:52 <ski_> so, just swap `a' and `b' and you're right there
13:03:03 <esteth_> ah, ok. Thanks :)
13:03:23 <ski_> @type \f g x -> (f . g) x
13:03:25 <lambdabot> forall a b t. (Functor ((->) t)) => (a -> b) -> (t -> a) -> t -> b
13:03:33 <ski_> @type \f g x -> (f P.. g) x
13:03:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:03:40 <ski_> @type \f g x -> f P.. g $ x
13:03:41 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:03:50 <ski_> maltem : ^
13:04:04 <dmwit> :t P.. -- also the same
13:04:06 <lambdabot> parse error on input `P..'
13:04:08 <dmwit> :t (P..)
13:04:10 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:04:29 <esteth_> Also, is there a command in ghci to view the source of a function? I see people asking lambdabot for function source, but neither :s or :source work in ghci
13:04:42 <dmwit> No, there is no GHCi function for that.
13:04:48 * ski_ wonders why LB left the `Functor (t ->)' hanging there .. it shoudl be removable ..
13:04:51 <maltem> ski_, hm?
13:05:05 <dmwit> However, you can install lambdabot locally, if you find yourself wanting that function a lot.
13:05:07 <ski_> maltem : `f . g $ x'
13:05:22 <roconnor> wow, Agda looks more like Epigram than I head realized: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=98
13:05:23 <esteth_> dmwit: Ah, ok. That might be an idea, thanks :)
13:05:24 <lambdabot> Title: FP Lunch  Blog Archive  A finite universe in Agda
13:05:28 <roconnor> They have views!
13:05:29 <maltem> ski_, my point was that I find the other style more readable
13:05:46 <roconnor> even exponential views of finite types.
13:06:00 <ski_> maltem : oh .. i thought you were complaining about having to insert the initial (and final) round bracket
13:06:14 <ski_> roconnor : which is ?
13:06:38 <roconnor> ski_: you have a type Fin n for all natural numbers n, right?
13:06:56 <maltem> ski_, I was merely complaining that I usually forget the opening paren when initially planning to use that style
13:07:17 <roconnor> Then you can "view" an element Fin (n^m) as a function (Fin m -> Fin n)
13:07:49 <ski_> oh .. interesting
13:07:52 <roconnor> ... an element of Fin (n^m) as ....
13:08:13 <roconnor> Thorston said the thought such a view would require functional extensionality
13:08:18 <roconnor> but says he was wrong.
13:08:45 * ski_ wonders if it would be hard to get something like paredit for haskell, to ease things like maltem mentioned ..
13:08:49 <ski_> .. probably
13:09:02 <Cale> esteth_: Lambdabot just reads the definitions from a custom text file for this purpose though.
13:09:41 <Riastradh> ski_, you would need something much more syntactically aware than paredit is.
13:09:45 <Cale> esteth_: If you want the actual source for things, there are links from the GHC libraries documentation. For the Prelude, there's also the Report.
13:09:51 <ski_> Riastradh : indeed
13:10:37 <ski_> roconnor : functional extensionality being `f = g  <=  forall x. f x = g x' ?
13:13:04 <esteth_> Cale: Oh, that's good to know. Thanks :)
13:13:45 <Cale> @src (.)
13:13:45 <lambdabot> (f . g) x = f (g x)
13:13:45 <lambdabot> -- In lambdabot, it's been generalised to:
13:13:45 <lambdabot> (.) = fmap
13:17:53 <roconnor> ski_: that's right.
13:25:40 * ski_ wonders why functional extensionality would be thought to be related ..
13:26:13 <ski_> (.. thought possibly it's a good idea to properly understand the code in question first)
13:26:22 <roconnor> I think that Thorston thought a view would require an isomorphism between Fin m -> Fin n and Fin (n^m).
13:26:28 <ski_> (s/thought/though/)
13:27:03 <dmwit> Cale: How come ?src (++) doesn't have a comment like (++) = mappend?
13:27:06 <dmwit> ?src (++)
13:27:07 <lambdabot> []     ++ ys = ys
13:27:07 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:27:07 <lambdabot> -- OR
13:27:07 <lambdabot> xs ++ ys = foldr (:) ys xs
13:27:07 <lambdabot> -- In lambdabot, this is generalised to:
13:27:09 <lambdabot> (++) = mappend
13:27:13 <dmwit> err...
13:27:13 <dmwit> heh
13:27:14 <popcorn> yay
13:27:17 <popcorn> order is restored
13:27:34 <tromp> @src mappend
13:27:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:27:40 <dmwit> ?src [] mappend
13:27:41 <lambdabot> Source not found. Just try something else.
13:27:45 <dmwit> ?src mappend []
13:27:45 <lambdabot> Source not found. I am sorry.
13:27:48 <roconnor> But really you only need an injection Fin (n^m) -> Fin m -> Fin n ... I think?
13:27:48 <dmwit> bah
13:28:29 <dmwit> ?src mappend Ord
13:28:29 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:28:45 <popcorn> > Just [1] `mappend` Just [3,5]
13:28:46 <lambdabot>  Just [1,3,5]
13:30:46 <fizzletip> if i want to go trough a list whit [ x | x<-xs ] but instead of x:xs i want x:y:xs. first the first pair then second pair and so on. How do i write that.
13:30:59 <fizzletip> Tryed a few difftrent ways. but nothing seems to work.
13:33:38 <dmwit> :t intersperse
13:33:40 <lambdabot> forall a. a -> [a] -> [a]
13:33:51 <dmwit> Oh, never mind.
13:34:02 <dmwit> You want the "chunk" function that everybody writes at least once.
13:34:06 <dmwit> ?quote chunk
13:34:06 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
13:34:06 <HrrblHskllProgrm> is there a command that is something like (a->Bool)->[a]->[a] which takes a list and returns all of the pieces of the list that return true?
13:34:09 <dmwit> bummer
13:34:14 <dmwit> :t filter
13:34:16 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:34:23 <HrrblHskllProgrm> thanks :)
13:34:24 <dmwit> HrrblHskllProgrm: See also Hoogle:
13:34:32 <dmwit> ?hoogle (a->Bool)->[a]->[a]
13:34:33 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
13:34:33 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
13:34:33 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
13:34:37 <HrrblHskllProgrm> ah, that's sexy
13:35:05 <roconnor> @where hoogle
13:35:06 <lambdabot> http://haskell.org/hoogle
13:35:37 <dmwit> fizzletip: In Dmwit.hs, I have
13:35:41 <dmwit> chunk          i = takeWhile (not . null) . unfoldr (Just . splitAt i)
13:36:02 <dmwit> > let chunk i = takeWhile (not . null) . unfoldr (Just . splitAt i) in chunk 2 [1..11]
13:36:04 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11]]
13:36:47 <dmwit> ?pl \i -> takeWhile (not . null) . unfoldr (Just . splitAt i)
13:36:47 <lambdabot> (takeWhile (not . null) .) . unfoldr . (Just .) . splitAt
13:36:55 <dmwit> Yeah, that's way less readable. =P
13:39:17 <ski_> > [(x,y) | x:y:_ <- tails [0..9]]
13:39:18 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)]
13:39:22 <ski_> fizzletip : ^
13:40:02 <ski_> or did you mean non-overlapping element pairs ?
13:40:09 <dmwit> > [(x,y) | x:y:_ <- tails [0]] -- but can also miss one
13:40:10 <lambdabot>  []
13:40:38 <ski_> dmwit : sure, that's the intended behaviour, no ?
13:40:41 <dmwit> > ap zip tail [0..9] -- another way to write it
13:40:42 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9)]
13:40:44 <dmwit> ski_: Yeah, probably.
13:42:53 <ski_> > tails [0..3]  -- fizzletip, compare
13:42:54 <lambdabot>  [[0,1,2,3],[1,2,3],[2,3],[3],[]]
13:46:30 <sjanssen> @tell bos in your 15th slide, "a `seq` a" is equivalent to "a", making daxpy and daxpy' equivalent
13:46:31 <lambdabot> Consider it noted.
13:46:33 <fizzletip> mergeSort xs = mergeSort [[merge a b] | a:b:_  <- take 2 xs]
13:47:06 <fizzletip> getting a type error on b but not a.
13:47:07 <dmwit> That looks buggy.
13:47:45 <dmwit> Note that, as you have written it, that function will never examine any elements of the list beyond the first two.
13:48:16 <dmwit> Also, merge probably takes a list as at least one of its two parameters.
13:49:05 <fizzletip> merge :: [a] -> [a] -> [a]
13:49:28 <fizzletip> xs is a [[a]]
13:49:37 <ski_> xs : [[a]]
13:49:43 <ski_> xs :: [[a]]  -- corrected
13:50:05 <dmwit> [[merge a b] | ...] :: [[[a]]] -- ?
13:50:11 <ski_> fizzletip : you could try using dmwit's `chunk' above (or write an equivalent one)
13:50:42 <ski_> yeah, you (probably) don't want the singleton list of `merge a b'
13:51:27 <ski_> (i assume you have a base case for when `xss' is a singleton)
13:51:37 <ski_> fizzletip : ok ?
13:52:06 <fizzletip> yes.
13:53:16 <ski_> (`merge a b' already returns a list of sorted elements, you just want to gather up a list of such sorted lists with the list comprehension .. not a list of *lists* of sorted lists)
13:55:07 <RayNbow> http://lambda-the-ultimate.org/node/2799
13:55:10 <lambdabot> Title: Arrows generalise monads and idioms | Lambda the Ultimate
14:02:40 <roconnor> @remember  ilyas Haskell is a language where you start reading up on random abstract algebra before you feel ready to implement a simple bayesian network app.
14:02:40 <lambdabot> It is forever etched in my memory.
14:04:26 <fizzletip>  bbs@(b:bs)
14:04:36 <fizzletip> opps.
14:06:04 <RayNbow> @djinn a -> a
14:06:04 <lambdabot> f a = a
14:07:29 <fizzletip> what does @ do. feels like its a way to give a name to something.
14:08:13 <popcorn> > let examine bbs@(b:bs) = (bbs,b,bs) in examine [1,2,3,4,5]
14:08:16 <lambdabot>  ([1,2,3,4,5],1,[2,3,4,5])
14:08:28 <popcorn> bbs matches the whole thing
14:10:23 <ski_> (pronounced "at" or "as")
14:12:06 <fizzleti1> as@[a] = as whould that be same as a:[] = a
14:12:32 <popcorn> no
14:12:49 <popcorn> \ as@[a] ->
14:12:50 <popcorn> is like
14:13:00 <popcorn> \ a:[] -> let as = [a] in
14:14:40 <saml> lambda calculus is a great invention of 20th century
14:15:13 <saml> what will be the  great invention of 21st century?
14:15:24 <lament> virtual girlfriends.
14:15:43 <ulfdoz> hrhr
14:16:02 <RayNbow> the great invention of the 21st Century will be NDTMs :p
14:16:04 <ddarius> This conversation isn't Haskell related.
14:16:31 <pizza_> maybe he wants to write speculation program in Haskell
14:16:35 <RayNbow> so we can have a go at solving NP problems in polynomial time :p
14:17:10 <Baughn> Negative time delay elements? Quantum computers? Hardware reconfigurable computers?
14:18:13 <RayNbow> what would happen if someone proved this century that P=NP? Would the world cease to exist? ;)
14:18:13 <popcorn> saml: so you get your lambda interpreter working? :)
14:18:14 <dbpatterson> biotech - something.
14:18:18 <Baughn> (Have any np-complete problems been mapped to quantum computing?)
14:18:51 <Baughn> RayNbow: Only if they also manage to prove that P/=NP
14:19:07 <Baughn> RayNbow: Inconsistencies in commonly assumed math would be annoying. ;)
14:20:04 <RayNbow> :p
14:20:30 <Baughn> It's not impossible, and it can never be proven impossible. So therefore..
14:20:38 <RayNbow> btw Baughn, integer factorization is FNP (according to Wikipedia)
14:20:54 <RayNbow> and there exists a polynomial algorithm on a quantum computer
14:20:59 <Baughn> Yes
14:21:30 <Baughn> Factorials are one thing, but the np-complete class covers a lot of interesting stuff. Having a polynomial-time algorithm for that would be far more useful
14:21:48 <Baughn> Factorials are mostly useful for breaking RSA. ^^;
14:22:05 <saml> popcorn: i need to put typechecking in to the interpreter this weekend
14:22:18 <popcorn> saml: is it lazy or not?
14:22:24 <RayNbow> Baughn: breaking RSA is actually highly interesting...
14:22:28 <RayNbow> ...for criminals that is :p
14:22:38 <Baughn> RayNbow: It's broken, it's broken
14:22:44 <luite> RayNbow: criminals that can afford a quantum computer? ;)
14:22:57 <Baughn> If you want future-proof encryption, you'd better use epileptic curves or something
14:23:07 <idnar> epileptic, haha
14:23:13 <saml> popcorn: i think it's eager. i'm not doing graph reduction..but haskell is lazy by default..
14:23:24 <popcorn> saml: well what about something like
14:23:37 <RayNbow> luite: sure, why not? :p
14:23:47 <popcorn> (\p q -> q)((\u -> u u)(\u -> u u))0
14:23:56 <popcorn> it should give 0 if your interpreter is lazy
14:24:03 <popcorn> and it should diverge if it's strict
14:24:15 <popcorn> (should work since you don't have types yet)
14:24:41 <popcorn> (it's not possible to write a divergent lambda term with the simple types restriction)
14:25:08 <Baughn> You mean that makes it turing-incomplete?
14:25:35 <popcorn> Baughn: exactly
14:25:44 <popcorn> Baughn: if it's turing complete it's not useful for mathematics
14:25:55 <popcorn> (which is the point of lambda.. right?)
14:26:15 <Baughn> > let lambda = (\) in error
14:26:16 <lambdabot>  Parse error at ")" (column 16)
14:26:19 <saml> popcorn: it doesn't typecheck. if i disable typechecking, it diverges
14:26:33 <popcorn> saml: so it's strict then, cool
14:26:38 <popcorn> I was wondering
14:26:58 * RayNbow wonders why links related to functional programming submitted to reddit are often downmodded :p
14:27:18 <popcorn> IIRC reddit sucks
14:27:27 <saml> haskell can't type \u -> u u either
14:27:37 <dons> :t \u -> u u
14:27:41 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:27:41 <lambdabot>     Probable cause: `u' is applied to too many arguments
14:27:41 <lambdabot>     In the expression: u u
14:27:46 <dons> i can haz a newtype?
14:27:57 <popcorn> lambda-the-ultimate seems to be going downhilll too
14:28:07 <ddarius> popcorn: You can add primitives.
14:28:16 <popcorn> primitives? to what
14:28:18 <saml> my interpreter's error message is: occurs check fails
14:28:39 <ddarius> popcorn: The simply typed lambda calculus.
14:28:46 <RayNbow> > (\x -> x x) (\x -> x x)
14:28:48 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
14:28:48 <lambdabot>     Probab...
14:28:51 <RayNbow> awww :p
14:28:59 <gwern> RayNbow: fp fatigue is why
14:29:04 <popcorn> ((lambda (u) (u u)) (lambda (u) (u u)))
14:29:04 <gwern> dons has exhausted them
14:29:26 <saml> what is \u -> u u ? is it Y combinator?
14:29:33 <ddarius> saml: No.
14:29:41 <popcorn> ddarius: yeah seems like adding datatypes (and pattern matching with structural recursion) makes the system more expressive than just having lambda terms
14:29:46 <popcorn> saml: it's U
14:29:53 <popcorn> ((lambda (u) (u u)) (lambda (u) (u u))) is Omega
14:29:54 <ddarius> saml: It's often called the ω combinator.
14:30:30 <popcorn> (but still subturing, thankfully)
14:30:39 <mauke> my $u = sub { goto &{$_[0]} };
14:30:41 <ddarius> popcorn: It was a bit late, but I was specifically referring to adding fix as a primitive constant.
14:30:49 <popcorn> oh I see
14:31:04 <RayNbow> gwern: how could anyone get tired of FP? :p
14:31:15 <RayNbow> I deem it impossible ;)
14:32:45 <gwern> 'error: the impossible has happened! Report this to Reddit HQ....'
14:32:54 <strfryed> what do people generally use for cryptographic hashes in Haskell?
14:33:09 <gwern> sha stuff
14:33:20 <gwern> sha-1 and sha256 are used in darcs, incidentally
14:33:34 <strfryed> ;) I meant implementations, not algs
14:33:35 <saml> :t \f -> (\x -> f (x x)) (\x -> f (x x))
14:33:39 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:33:39 <lambdabot>     Probable cause: `x' is applied to too many arguments
14:33:39 <lambdabot>     In the first argument of `f', namely `(x x)'
14:34:03 <popcorn> saml: Run these in Scheme
14:34:07 <Cale> newtype Rec a = In { out :: Rec a -> a }
14:34:07 <Cale> y :: (a -> a) -> a
14:34:07 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
14:34:27 <gwern> strfryed: oh. then things get messier. there's a lot you could use. there are something like 6 different implementations of/bindings to sha1
14:34:28 <popcorn> hmm
14:34:37 <popcorn> what type do these things get if you have rational unification
14:34:54 <popcorn> unification over rational trees*
14:35:13 <gwern> strfryed: but did you look on Hackage at the crypto section, or at the Crypto package? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto-4.1.0
14:35:15 <lambdabot> http://tinyurl.com/yomk9r
14:35:31 <strfryed> didn't see this one; that's I'll take a good look at it
14:35:38 <gwern> @where crypto
14:35:38 <lambdabot> http://www.haskell.org/crypto
14:36:14 <gwern> oh, so crypto does have a darcs repo: http://darcs.haskell.org/crypto
14:36:15 <gwern> good to know
14:36:15 <lambdabot> Title: Index of /crypto
14:36:23 * gwern departs
14:38:17 <sheyll> hi everyone!
14:38:22 <popcorn> hi again
14:38:33 <sheyll> hi popcorn
14:38:49 <popcorn> I think I'll try to write a parser
14:41:38 <popcorn> what's a good way to define operators?
14:42:14 <popcorn> say I wanted to be able to define things like  [] + [], << [] >>, if [] then [] else [], etc
14:42:28 <popcorn> instead of: infixr 7 +
14:42:45 <popcorn> what would be a good way to describe them?
14:43:11 <popcorn> because it would be neat to be able to define things like this I think
14:43:24 <popcorn> especially if it worked properly with sections
14:48:56 <sheyll> had a network problem
14:49:04 <ddarius> OBJ3 allows fairly sophisticated fixities.
14:49:21 <popcorn> thanks I'll check it out
14:49:27 <sheyll> how do I read the nth element in a tupel?
14:49:41 <popcorn> sheyll: fst and snd work on 2-tuples
14:49:42 <mauke> pattern matching
14:49:59 <popcorn> sheyll: if you had like a 3 tuple you could defien scnd (_,e,_) = e
14:50:28 <popcorn> if you had a 4-tuple, third (_,_,e,_) = e
14:51:14 <Baughn> You could at least make it a class, but probably.. if you find yourself wanting this, you probably shouldn't be /using/ tuples
14:51:14 <roconnor> Boy, sigfpe's observation that the Perhaps monad is the same as Writer Float is really cool.
14:51:32 <sheyll> Baughn: thanx!
14:51:45 <mauke> wait, Float is a Monoid now?
14:51:46 <popcorn> ummm don't use a class to do this
14:51:55 <popcorn> :/
14:52:07 <sheyll> no I think using a list is a better alternative\
14:52:09 <roconnor> mauke: well, it should be Writer (Product Float)
14:52:19 <Baughn> sheyll: Sure, if all your elements are the same type..
14:52:23 <SamB> I'm pretty sure Float isn't a Monoid
14:52:36 <roconnor> but really newtype Prob = Prob Float
14:52:41 <roconnor> Writer Prob
14:52:41 <sheyll> Baughn and that is the case
14:53:43 <SamB> well, it MIGHT be possible to create a Monoid with Floats as values, but it would use a wierd operation probably...
14:54:07 <conal> Product & Sum are handy, as roconnor mentioned
14:54:20 <ddarius> SamB: People just make-believe that floats are nicer than they are.
14:54:24 <conal> arbitrary monoids for Writer is such a neat trick!
14:54:44 <conal> and even more elegant as an applicative functor.
14:54:45 <popcorn> yeah I wish more languages had reals is the default
14:54:57 <Baughn> I don't suppose I could convince anyone that Float should be renamed Half, and Double Float? No?
14:55:07 <ddarius> popcorn: No language has reals as a default or otherwise.
14:55:20 <Baughn> popcorn: Oh, no. That would be horrible
14:55:22 <mauke> Baughn: hey, OCaml's float is Double
14:55:38 <Baughn> mauke: Oh, good. I can take responsibility for that.
14:55:47 <popcorn> Baughn: what do you rather Int or Integer?
14:55:59 <Baughn> popcorn: Integer sounds good
14:56:22 <popcorn> so what is wrong with computable reals as a default type?
14:56:38 <Baughn> They're /inexact/
14:56:45 <popcorn> I want exact reals
14:56:51 <popcorn> e.g. fewdigits
14:56:59 <popcorn> rather than some weird float thing that -I- cant' reason about
14:57:10 <Baughn> Oh well, that's called Fractional then
14:57:28 <popcorn> I don't think you can even guarantee a + (b + c) = (a + b) + c with floats
14:57:37 <Cale> You can't.
14:57:37 <agcorona> I can´t stop looking at the beauty of how Control.Parelel.Strategies solves the separation of algoritm and evaluation strategy
14:57:45 <Baughn> popcorn: Floats make perfect sense, honest
14:57:55 <popcorn> then again, I don't think computable reals can have an == operator. ...
14:58:04 <agcorona> with things like this, Haskell is a clear winner
14:58:20 <SamB> popcorn: you do know that there is no decidable equality on the reals, right?
14:58:27 <popcorn> on reals sure
14:58:38 <SamB> oh, you just said that
14:58:44 <popcorn> on computable reals, I don't think so either
14:58:47 <SamB> man now I feel silly
14:59:00 <SamB> I wouldn't know about the computable reals ;-)
14:59:08 <Cale> > let a = 10^^(-300); b = 10^^300; c = -b in (a + b) + c == a + (b + c)
14:59:09 <popcorn> SamB: well I mean reals is a superset of computable reals
14:59:11 <lambdabot>  False
14:59:17 <SamB> true enough
14:59:33 <ddarius> SamB: Consider pi == some expression that putatively evaluates to pi
14:59:39 <mauke> > let a@b@c = 0/0 in (a + b) + c == a + (b + c)
14:59:39 <popcorn> oh computable reals are things like pi, e, 3, 1/3, there is a program for each one that prints out n : Integer  digits in finite time
14:59:42 <lambdabot>  False
14:59:57 <popcorn> oh cool!
14:59:59 <SamB> popcorn: sure, this much I know
15:00:06 <Cale> heh
15:00:11 <popcorn> > let (x,y)@(z,w) = (1,2) in [x,y,z,w]
15:00:11 <lambdabot>  Parse error at "@(z,w..." (column 10)
15:00:22 <Cale> > let a = 0/0 in a == a
15:00:25 <lambdabot>  False
15:00:26 <SamB> but that doesn't directly buy you a decision procedure for equality, clearly
15:00:55 <Cale> You can't computably compare computable reals for equality.
15:01:09 <ddarius> inequality is semi-decideable
15:01:09 <popcorn> ok
15:01:19 <popcorn> what does semi-decideable mean?
15:01:33 <SamB> that means it might take forever to decide, doesn't it?
15:01:50 <SamB> isn't that almost the same thing as undecidable?
15:02:01 <ddarius> SamB: No, that means if a /= b then it will return True, but if a == b it won't return.
15:02:07 <SamB> ah
15:02:08 <SamB> right
15:02:17 <SamB> don't you mean False?
15:02:28 <ddarius> I said 'inequality'
15:02:33 <SamB> oh.
15:02:36 <SamB> right.
15:03:20 <popcorn> ohh ok
15:03:28 <popcorn> anyway what is decideable
15:03:34 <popcorn> is a == b within epsilon
15:03:54 <Baughn> a >> b -> a + b == a?
15:04:23 * SamB goes back to trying to prove the reflective property
15:04:27 <ddarius> Baughn: Not exactly.
15:04:36 <ddarius> Consider b = -a.
15:05:00 <Baughn> Quite. I believe that rule of thumb was supposed to have abs() in it somewhere
15:05:12 <popcorn> what's the reflective property?
15:05:48 * ddarius thinks SamB meant reflexive, but maybe not.
15:05:50 <SamB> popcorn: well, every equivalence relation must have a value equivalent to itself
15:05:58 <SamB> ddarius: er, yes
15:06:02 <popcorn> oh right x = x.
15:06:02 <MathHat> Baughn, ddarius: all that would mean is 0 >> 0
15:06:19 <SamB> what's the difference anyway?
15:06:33 <Baughn> MathHat: It's not iff
15:06:35 <popcorn> difference between ?
15:06:43 <SamB> reflexive and reflective
15:06:50 <popcorn> well I've never heard of reflective
15:07:07 <Cale> What about the relation on the empty set? It's an equivalence relation ;)
15:07:13 <ddarius> SamB: Isn't the proof that an equivalence relation is reflexive simply: By definition. ?
15:07:16 <Baughn> http://mathworld.wolfram.com/ReflectionProperty.html <-- Reflective property
15:07:17 <lambdabot> Title: Reflection Property -- from Wolfram MathWorld
15:07:25 <Cale> (and yet doesn't have an element which is equivalent to itself ;)
15:07:31 <popcorn> Cale: is it really?
15:07:34 <Cale> yep
15:07:35 <SamB> ddarius: well, I'm trying to prove that it IS an equivalence relation
15:07:36 <SamB> duh
15:07:38 <popcorn> because I was not sure about this one
15:07:42 <popcorn> oh right
15:07:45 <ddarius> Cale: But forall x in X. x = x holds.
15:07:57 <popcorn> ddarius said it first :D
15:07:58 <Cale> ddarius: of course, it is an equivalence relation after all :)
15:08:10 <popcorn> it's not exists x, x = x
15:08:30 <ddarius> SamB feels persecuted.
15:08:34 <SamB> Cale: if I hand you an element of the empty set, you can prove that the element is equivalent to itself using any equivalence over the empty set
15:08:43 <popcorn> probably samB has some relation already, and wishes to prove it's an equivalence
15:08:50 <popcorn> I guess
15:08:56 <SamB> popcorn: I just said that
15:09:28 <roconnor> > compare (0/0) (0/0)
15:09:31 <lambdabot>  GT
15:09:38 <roconnor> Hmm
15:09:38 <SamB> oh noes
15:09:42 <roconnor> is that what IEEE says?
15:09:44 <popcorn> > sort [0/0,0/0]
15:09:47 <lambdabot>  [NaN,NaN]
15:09:50 <popcorn> >:|
15:09:54 <popcorn> I wanted a loop
15:10:07 <popcorn> > sort [0/0,0/0,0/0,0/0]
15:10:11 <roconnor> popcorn: sort is terminating
15:10:15 <lambdabot>  [NaN,NaN,NaN,NaN]
15:10:22 <SamB> > sort [-1/0,0/0,1/0]
15:10:24 <lambdabot>  [Infinity,NaN,-Infinity]
15:10:26 <Cale> > sort [0/0,0/0,0/0,0/0,1,-1,0,1/0,-1/0]
15:10:28 <popcorn> a > b /\ b > a should be able to break -something-
15:10:28 <lambdabot>  [-Infinity,-1.0,0.0,1.0,Infinity,NaN,NaN,NaN,NaN]
15:10:31 <SamB> hahahah
15:10:32 <ddarius> roconnor: I'm not sure IEEE 754 gives enough information to specify, at least not directly.
15:10:44 <SamB> it got them in exactly the wrong order!
15:10:46 <glguy> popcorn: it breaks Data.Set
15:10:52 <popcorn> ah :D
15:10:55 <popcorn> thank you glguy
15:11:25 <Cale> > sort [-1/0,0/0,1/0]
15:11:28 <lambdabot>  [Infinity,NaN,-Infinity]
15:11:30 <SamB> well, that's what you get for using an inappropriate key type
15:11:41 <Cale> > let xs = [-1/0,0/0,1/0] in sort xs == sort (sort xs)
15:11:42 * Baughn boggles
15:11:43 <lambdabot>  False
15:11:44 <glguy> Ratio Int   makes set cry
15:11:47 <SamB> they always said that using equality relations on floats was a bad idea
15:11:56 <Cale> > let xs = [-1/0,0/0,1/0] in iterate sort xs
15:11:57 <roconnor> @type 0%)
15:11:58 <roconnor> @type 0%0
15:11:59 <lambdabot>  [[-Infinity,NaN,Infinity],[Infinity,NaN,-Infinity],[-Infinity,NaN,Infinity],...
15:12:02 <lambdabot> parse error on input `)'
15:12:05 <lambdabot> forall t. (Integral t) => Ratio t
15:12:17 <ddarius> Cale: NaN /= Nan so any list containing NaN is not going to compare equal to itself.
15:12:18 <popcorn> > 0/0 :: CReal
15:12:20 <SamB> Cale: woah
15:12:22 <roconnor> > compare (0%0) (0%0)
15:12:24 <SamB> mondo unstable!
15:12:27 <lambdabot>  Exception: Ratio.%: zero denominator
15:12:33 <SamB> it's an antistable sort
15:12:33 <lambdabot>  thread killed
15:12:35 <Cale> ddarius: that's true :)
15:12:50 <Baughn> Cale: Please tell me there isn't an isNaN or isInfinity anywhere?
15:12:53 <roconnor> > 1 :: CReal
15:12:56 <lambdabot>  1.0
15:12:59 <ddarius> @src RealFrac
15:13:00 <Cale> > isNaN (0/0)
15:13:00 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
15:13:00 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
15:13:00 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
15:13:01 <SamB> @hoogle isNaN
15:13:02 <lambdabot>  True
15:13:03 <lambdabot> Prelude.isNaN :: RealFloat a => a -> Bool
15:13:07 <SamB> @hoogle isInf
15:13:07 <ddarius> @src Floating
15:13:07 <roconnor> where did CReal come from?
15:13:08 <lambdabot> Prelude.isInfinite :: RealFloat a => a -> Bool
15:13:08 <lambdabot> Data.List.isInfixOf :: Eq a => [a] -> [a] -> Bool
15:13:08 <lambdabot> Data.ByteString.isInfixOf :: ByteString -> ByteString -> Bool
15:13:08 <lambdabot> class  (Fractional a) => Floating a  where
15:13:10 <lambdabot>     pi                                                      :: a
15:13:12 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
15:13:14 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
15:13:15 <SamB> Baughn: there is both!
15:13:16 <lambdabot>     (**), logBase                                           :: a -> a -> a
15:13:19 <SamB> there is also isIEEE
15:13:20 <Baughn> Oh dear. Ooh.. dear.
15:13:23 <lilac> Baughn: isNaN x = not (x == x)
15:13:32 <SamB> @src isNaN
15:13:33 <lambdabot> Source not found. That's something I cannot allow to happen.
15:13:36 <SamB> lilac: is it now?
15:13:39 <ddarius> :t isNaN
15:13:43 <lambdabot> forall a. (RealFloat a) => a -> Bool
15:13:47 <Baughn> This means there are demons in the prelude
15:13:48 <ddarius> RealFloat !
15:13:59 <popcorn> roconnor: you? :)
15:14:02 <Baughn> Suddenly the steel ice I've been driving on is cracking...
15:14:04 <SamB> ddarius: that is a bit odd
15:14:07 <Cale> Baughn: What demons?
15:14:12 <roconnor> popcorn: possibly.
15:14:24 <roconnor> I'm not sure though
15:14:25 <Cale> Baughn: Floats just satisfy nonsense properties :)
15:14:26 <roconnor> there are others
15:14:32 <SamB> > (0 :+ 0) / 0
15:14:32 <Baughn> Cale: A non-IO function is observably being impure
15:14:34 <lambdabot>  NaN :+ NaN
15:14:35 <popcorn> roconnor: How far along is the Coq version?
15:14:40 <Cale> Baughn: How so?
15:14:41 <SamB> Baughn: what do you mean?"
15:14:42 <roconnor> popcorn: done
15:14:46 <popcorn> :o
15:14:46 <roconnor> popcorn: more or less
15:14:53 <popcorn> can you extract working haskell with it?
15:14:58 <SamB> Baughn: I would have thought 0/0 /= 0/0 was bad enough???
15:15:07 <Baughn> SamB: Not if it's consistent
15:15:10 <Cale> Baughn: A float is just a value. Checking for NaN is a pure function.
15:15:14 <Baughn> But sorting lists containing infinite/-infinity *isn't*, so..
15:15:33 <SamB> Baughn: that isn't conistant with =='s role as an equality
15:15:38 <popcorn> basically floats are HORRIBLE :)
15:15:52 <Baughn> SamB: No, but it's still /pure/ at least
15:15:52 <Cale> The "ordering" provided by the Ord instance on Double isn't a total ordering, so sort can't be expected to really work sensibly.
15:15:53 <roconnor> Cale: where did CReal in lambdabot come from?
15:15:58 <popcorn> they only suit realtime graphics
15:16:01 <ddarius> Basically floats are HORRIBLE (fields)
15:16:04 <Cale> roconnor: Not from me.
15:16:05 <MathHat> they're horrible in every language...
15:16:19 <popcorn> MathHat: they're ok in C :P
15:16:21 <lilac> SamB: well, perhaps. hugs defines it to be const False for both Float and Double
15:16:22 <roconnor> @version
15:16:23 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
15:16:23 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:16:27 <gwern> @where crypto
15:16:27 <lambdabot> http://www.haskell.org/crypto
15:16:29 <MathHat> popcorn: yeah, maybe.
15:16:29 * Baughn crawls into a corner, gibbering
15:16:46 <popcorn> aww sorry Baughn
15:17:06 <Cale> Baughn: I don't understand what you mean that there's a non-IO function being impure...
15:17:14 <MathHat> It's not like it's Haskell's fault that IEEE 754 is ridiculous.
15:17:23 <SamB> Baughn: sure, it's not a bit sensible
15:17:24 <Baughn> > let xs = [-1/0,0/0,1/0] in iterate sort xs
15:17:26 <lambdabot>  [[-Infinity,NaN,Infinity],[Infinity,NaN,-Infinity],[-Infinity,NaN,Infinity],...
15:17:51 <ddarius> SamB: I eagerly await your improvement on IEEE 754 given the constraints it was working with.
15:17:53 <roconnor> @commands
15:17:53 <lambdabot> Unknown command, try @list
15:17:58 <roconnor> @list
15:17:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:17:58 <Cale> That's called not satisfying the laws necessary for sort to do something reasonable ;)
15:18:00 <Baughn> Okay. Granted. That *might* be pure
15:18:03 <SamB> MathHat: and it isn't like Haskell has to use the same definitions of ==, <, >, <=, and >= as IEEE 754 either
15:18:14 <Baughn> It's still the sort of thing that makes me run screaming into the sunset
15:18:20 <MathHat> heh, OK.
15:18:21 <popcorn> > 1 :: CReal
15:18:24 <lambdabot>  1.0
15:18:32 <popcorn> > pi :: CReal
15:18:34 <lambdabot>  3.1415926535897932384626433832795028841972
15:18:49 <ddarius> Baughn: Code breaking when you explicitly break it's explicitly stated contract?
15:18:51 <roconnor> I bet that is David Lester's code
15:18:53 <opqdonut> CReal is computable real?
15:18:54 <SamB> ddarius: IEEE is great until you try to use it for anything vaguely resembling math
15:19:10 <roconnor> I hope it is too.
15:19:12 <popcorn> > (!!50) . iterate cos $ 1
15:19:15 <lambdabot>  0.7390851339216605
15:19:18 <popcorn> > (!!50) . iterate cos $ 1 :: Creal
15:19:19 <lambdabot>   Not in scope: type constructor or class `Creal'
15:19:21 <popcorn> > (!!50) . iterate cos $ 1 :: CReal
15:19:25 <ddarius> SamB: Why would you do such a thing?
15:19:32 <popcorn> sloooooow
15:19:36 <lambdabot>  thread killed
15:19:55 <SamB> ddarius: well, it would be nice if it would at least have the reflexive property...
15:20:07 <roconnor> > round_uk 0.5
15:20:08 <lambdabot>   Not in scope: `round_uk'
15:20:09 <popcorn> roconnor: when will it be released? (the .v files, if ever?)
15:20:21 <roconnor> popcorn: when Coq 8.2 is released
15:20:22 <Cale> My favourite is giving sort an ordering which is cyclic.
15:20:41 <popcorn> ok
15:20:52 <Cale> That is, have a type with values A, B, C, and define the Ord instance such that A < B, B < C, C < A
15:20:54 <roconnor> > showCReal pi 10
15:20:56 <lambdabot>   add an instance declaration for (Floating Int)
15:20:57 <opqdonut> Cale: does sort even halt with that?
15:21:03 <Cale> yep
15:21:03 <roconnor> > showCReal 10 pi
15:21:03 <opqdonut> ?src sort
15:21:04 <lambdabot> sort = sortBy compare
15:21:06 <lambdabot>  "3.1415926536"
15:21:08 <opqdonut> ?src sortBy
15:21:08 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
15:21:12 <opqdonut> ah yes it was insertion sort
15:21:22 <Beelsebob> okay, that's shit
15:21:24 <Cale> It's not really insertion sort.
15:21:26 <Beelsebob> why does it do insert sort?
15:21:34 <lilac> so, either Double isn't a conforming instance of Ord, or Double doesn't conform to IEEE-754 wrt == and /=.
15:21:35 <popcorn> Beelsebob: what should it do?
15:21:39 <Cale> That's just what the Report uses to define its behaviour.
15:21:46 <Beelsebob> Cale: ah, fair enough
15:21:47 <Cale> It's really a mergesort, iirc.
15:21:48 <mrd> Beelsebob: those listings are optimized for readability. it's not what's really used.
15:21:58 <Beelsebob> popcorn: well, quicksort is easy to write, and equaly readable
15:22:06 <Beelsebob> mrd: oh, okay
15:22:08 <Beelsebob> fair enough
15:22:10 <popcorn> is quicksort faster?
15:22:12 <mrd> quicksort is not so easy to write in haskell, efficiently
15:22:15 <lilac> but mergesort and insertion sort aren't equivalent
15:22:17 <mrd> mergesort is though
15:22:27 <lilac> if your comparison diverges on some input...
15:22:53 <roconnor> lilac: how so?
15:23:08 <Cale> roconnor: They might not do the same set of comparisons.
15:23:18 <roconnor> ugh
15:23:19 <lilac> roconnor: cmp a b = if a == 1 and b == 2 then bottom else a < b
15:23:44 <popcorn> cmp a b = if a == 1 and b == 2 then cmp a b else a < b
15:23:56 <lilac> popcorn: or that ;-)
15:24:12 <opqdonut> insertion sort works on infinite stremas
15:24:15 <opqdonut> *streams
15:24:19 <opqdonut> assuming some ordering
15:24:31 <roconnor> opqdonut: I don't think it does.
15:24:41 <lilac> opqdonut: how can it find the first element without scanning the entire list?
15:24:48 <opqdonut> hmm, true
15:24:59 <opqdonut> nvm
15:25:24 <lilac> i could believe that it has a better space bound on infinite streams, though
15:25:46 <lilac> ok, that's stupid
15:25:51 <lilac> on *large* streams
15:26:07 <SamB> hmm, it seems to be much easier to prove things when none of the constructors of my equivalence relation type are highlighted in yellow ;-)
15:26:21 <popcorn> SamB: is this Agda 2?
15:26:29 <SamB> yeah
15:27:02 <popcorn> if they are yellow doesn't that mean, they might not actually be terminating relations
15:27:16 <popcorn> so like, you might be using inconsistent definitions in your proof
15:27:20 <SamB> no, no!
15:27:27 <popcorn> (that should make things easier to prove though .. :P)
15:27:27 <SamB> it means there are unsolved metavars
15:27:34 <popcorn> ohh I see
15:27:40 <popcorn> so I guess it's red that means that
15:27:40 <SamB> some other yellowish color means possible nontermination
15:28:09 <SamB> (which can also be flagged when you just have holes which, depending on how you fill them, *could* give you nontermination)
15:28:11 <popcorn> yeah I'm still really amazed by what Agda 2 can infer
15:28:27 <popcorn> it does some clever stuff with constructor reasoning
15:28:41 <popcorn> I tried to understand the source code ±_±
15:28:45 <popcorn> did not help to read it
15:31:37 <FalconNL> I don't suppose an implementation of extensible records with scoped labels for GHC yet? I could really use one.
15:31:58 <FalconNL> *there's
15:31:59 <mauke> OOHaskell
15:35:22 <SamB> sweet, I've proved the equivalence properties ;-)
15:35:33 <SamB> now all I gots to do is start proving some equations
15:35:36 <ddarius> Congratulations.
15:35:46 <ddarius> What equivalence relation is this?
15:36:04 <popcorn> yeah post your code :P
15:38:03 <SamB> this equivalence is between two regular type constructors that have the same values
15:38:26 <ddarius> Structural equality?
15:38:41 <FalconNL> Hm. From what I gather from the paper OOHaskell is pretty much IO monads everywhere. I'd much rather have an implementation that retains the purity of records
15:38:44 <SamB> structural?
15:39:03 <SamB> it has nothing to do with the structure of the datatypes
15:39:21 <SamB> that hasn't appeared in any of the proofs ;-)
15:40:07 <ddarius> SamB: So you have something like a leaf tree and you are saying they are equivalent if they have the same fringe say?
15:40:48 <popcorn> the definition of = is reflexitivy usually
15:40:53 <SamB> well, you know that paper about the derivitive of a type?
15:40:55 <popcorn> since you're doing proof by computation in Agda
15:41:04 <ddarius> SamB: Yes.
15:41:29 <SamB> I have two equivalences so far...
15:42:10 <ddarius> FalconNL: The record constructor parts (indeed the whole HList part that OOHaskell is based on) has nothing to do with IO.
15:42:53 <SamB> x≈y means that two closed type expressions x and y are both inhabited by all the same value expressions
15:43:11 <SamB> I defined it like this:
15:44:12 <SamB> man, I need to change my rxvt fontset...
15:44:26 <SamB> _≈_ : Rel (Reg 0)
15:44:27 <SamB> S ≈ T = (forall x -> x ∈⟦ S ⟧ -> x ∈⟦ T ⟧)
15:44:27 <SamB>         × (forall x -> x ∈⟦ T ⟧ -> x ∈⟦ S ⟧)
15:45:21 <Apocalisp> excuse you!
15:45:34 <SamB> Apocalisp: you don't read UTF-8?
15:45:48 <SamB> or you lack the proper fonts??? ;-)
15:45:52 <popcorn> × means and?
15:46:10 <popcorn> hmmmm
15:46:28 <SamB> it basically means "pair"
15:46:57 <SamB> which is equivalent to and as a logical connective, but makes it more clear that you can extract a component later
15:47:05 <popcorn> oh ok cool
15:49:19 <ddarius> It would seem you could use A -> BxC ~ (A -> B) x (A -> C) to prove reflexivity fairly quickly and generically though I should work out the details.
15:50:39 <SamB> then I made another one that basically says that if you have two type expressions with free variables, they are equivalent if replacing the same variables with the same values gives two closed type expressions that would be equivalent by the first equivalence, then they are equivalent...
15:51:12 <SamB> I'll likely end up merging the two sooner or later
15:53:30 <gwern> @where QuickCheck
15:53:30 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
15:54:14 * SamB REALLY wants a terminal font with 100% math coverage
15:54:49 <gwern> @where HUnit
15:54:49 <lambdabot> http://hunit.sourceforge.net/
15:54:57 <gwern> SamB: what do the bitstreams miss?
15:55:06 <roconnor> SamB: monospaced?
15:55:36 <SamB> roconnor: as opposed to proportional?
15:55:38 <SamB> yes!
15:55:45 <SamB> what kind of terminal uses proportional?
15:57:23 <roconnor> what kind of math uses monospaced :)
15:57:37 <SamB> programming math!
15:58:06 <SamB> I want the symbols, not the beautiful typesetting
15:58:45 <lament> you do realize how awfully obsolete terminals and monospaced fonts are :)
15:58:55 <ddarius> They're obsolete?
15:59:15 <SamB> lament: I realize some people have forgotten how useful they are
15:59:15 <popcorn> if you have something better than a terminal please tell me about it
15:59:31 <SamB> I use both of them every day
15:59:42 <lament> i doubt you use a terminal
15:59:47 <lament> you probably use a terminal emulator
15:59:49 <SamB> not a hard terminal
15:59:51 <SamB> no
16:00:06 <SamB> but just like most things computational, it has been moved into software...
16:00:08 <lament> terminals are obsolete, and terminal emulators emulate them for legacy reasons
16:00:13 <glguy> but monospaced, bitmapped fonts are still the one true way
16:00:32 <SamB> terminal emulators emulate them because terminals make more sense as software systems than hardware systems ;-P
16:00:46 <SamB> glguy: I don't quibble about them being bitmapped or not
16:00:53 <lament> SamB: no, sure, but they don't make much sense in general
16:01:07 <SamB> lament: certainly they are not useful for all applications
16:01:20 <lament> what use of intentionally limiting your capabilities that much?
16:01:33 <glguy> lament: to improve productivity of course
16:01:42 <popcorn> if you have something better.. ?
16:01:49 <popcorn> which you seem to not
16:01:57 <SamB> lament: what do you use instead of a terminal?
16:02:07 <glguy> a sys admin
16:02:08 <orbitz> SamB: hurrro
16:02:15 <lament> SamB: i use a terminal, for legacy reasons, just like everyone else
16:02:19 <glguy> he probably hired someone to use his computer for him
16:02:25 <SamB> anyway, I don't know any other decent way to run applications remotely
16:02:40 <dmwit> VNC?
16:02:44 <dmwit> ssh -X?
16:02:46 <popcorn> really it's just a useful interactive programming lanugage
16:02:50 <glguy> *decent*
16:02:51 <SamB> that too
16:02:55 <popcorn> that'll never go away
16:03:02 <SamB> dmwit: something with acceptable latency please
16:03:06 <popcorn> (I mean while computers are still around)
16:03:17 <lament> running applications remotely has very little to do with monospaced fonts and weird escape sequences?
16:03:31 <SamB> lament: how else are you going to run emacs remotely?
16:03:37 * dmwit has had no latency issues with VNC
16:03:37 <SamB> or vi, if you swing that way
16:03:47 <orbitz> SamB: i us etramp!
16:03:51 <lament> SamB: exactly, like i said, legacy reasons - support for legacy applications
16:03:53 <SamB> dmwit: well, bandwidth and strange things to install
16:03:58 <lament> SamB: you do realize how _old_ both emacs and vim are
16:03:59 <SamB> also
16:04:02 * dmwit also uses the terminal for about 90% of his interactions
16:04:07 <orbitz> lament: 74?
16:04:18 <SamB> yes. I also haven't found a better way to run a shell
16:04:24 <lament> SamB: in particular, they both are old enough to actually have been written for _real_ terminals, which is why they work that way.
16:04:27 <lament> SamB: same with the shell.
16:04:41 <SamB> lament: my shell is a lot nicer than a real-terminal shell
16:04:44 <lament> SamB: so of course they work best in a terminal emulator.
16:05:00 <SamB> and I really think zsh was written for software-only terminals from the beginning
16:05:21 <lament> well, all shells are rather strongly influenced by their predecessors
16:05:22 <SamB> you know, a legacy used to be a good thing!
16:05:29 <SamB> did you know that?
16:05:31 <lament> oh, it's a good thing sometimes
16:05:51 <lament> although i wouldn't put "good thing" and "monospaced fonts" in any direct relation
16:05:53 <SamB> nothing has cropped up to replace terminals
16:06:11 <SamB> how else are you going to vertically align your codes?
16:06:16 * edward1 waves hello.
16:06:23 <popcorn> hiya
16:06:40 <lament> SamB: which part of it? The left edge? that's trivial. Anything else?
16:07:00 <SamB> lament: the arguments in left-hand-sides, yes
16:07:05 <mrd> lament: not if you have a zaggy monitor!
16:07:16 <mrd> or circular
16:07:22 <SamB> mrd: come on now
16:07:25 <mrd> how about aligning your code on an oscilliscope
16:07:29 <SamB> that's what drivers are for
16:07:46 <lament> SamB: it's quite easy to have intelligent Tab markers
16:07:47 <popcorn> this is a ridiculous argument
16:07:56 * popcorn suggest #blah
16:07:57 <mrd> programming on an oscilliscope would make you look super hard-core
16:07:57 <SamB> lament: is it now?
16:08:10 <dmwit> This is a ridicument argulous!
16:08:22 <SamB> mrd: do you know of any 'scope fonts with good math coverage?
16:08:46 <lament> SamB: it must be doable, browsers and word processors seem to have no problems with vertical alignment.
16:08:47 <mrd> sadly no
16:09:04 <SamB> lament: please ... do not mention that word
16:09:34 <lament> which word?
16:09:52 <SamB> and do you really want EVERY SINGLE programming language to come with a sucky text editor?
16:10:03 <SamB> isn't just ONE sucky text editor enough for you?
16:10:32 <Spark> i think that, as a species, we are pretty clued up about what is a nice syntax and how it should be laid out on a page
16:10:37 <Spark> within certain parameters anyway
16:10:50 <lament> Spark: you'd think so, and then some people go ahead and hate Python anyway :)
16:11:08 <SamB> lament: now *that's* legacy for you
16:11:16 <edward1> @seen dolio
16:11:17 <lambdabot> I saw dolio leaving #haskell-blah and #haskell 15m 40s ago, and .
16:11:22 <lament> SamB: what's legacy?
16:11:32 <SamB> they learn a few languages where whitespace is insignificant and somehow think that all languages should be that way!
16:11:55 <lament> oh, yeah, exactly the same logic by which you prefer emacs to say eclipse
16:12:11 <SamB> does eclipse use proportional fonts?
16:12:20 <SamB> and ... isn't it written in Java?
16:12:33 <SamB> I have a strong aversion to large applications written in Java
16:12:46 <lament> why do you care what it's written in?
16:12:49 <popcorn> SamB: large applications in general, aren't very good
16:12:51 <mrd> first qualification for an editor is that it doesn't crash your computer trying to run it
16:13:12 <mrd> which rules out large applications written in Java
16:13:24 <lament> at least it's not written for terminal :D
16:13:27 <SamB> maybe when Eclipse is as old as Emacs is now, I'll use it
16:13:39 * mrd uses terminal emulators all the time
16:13:41 <SamB> Emacs used to have the same problem ;-)
16:13:54 <mrd> yea, amazin' that people used to complain about 8 megabytes :)
16:14:37 <lament> SamB: by the time eclipse is as old as emacs, i would hope something good would actually come out. Not that you would use it, because it'd be too cutting-edge. Luddite. :)
16:14:38 <SamB> what is it now, more like 18?
16:14:58 <SamB> lament: cutting edge stuff has this way of making you bleed
16:15:16 <mrd> seems to be between 10 and 20 ya
16:15:26 <SamB> mrd: what is?
16:15:31 <mrd> my emacs processes
16:15:37 <lament> holy shit
16:16:39 <mrd> a fresh one seems to use ~7MB RSS
16:17:01 <popcorn> wtf is a luddite
16:17:04 <popcorn> Etymology: perhaps from Ned Ludd, 18th century Leicestershire workman who destroyed a knitting frame
16:17:23 <opqdonut> yeah
16:18:04 <edward1> @pl \p f a -> p a (f a)
16:18:04 <lambdabot> ap
16:18:09 <gnuvince_> :t ap
16:18:11 <edward1> nice
16:18:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:18:28 <mrd> @src ap
16:18:28 <lambdabot> ap = liftM2 id
16:18:45 <edward1> been using these as names for types to try to get intuition for type level combinators, that one is short =)
16:19:11 <SamB> edward1: using whats?
16:19:26 <edward1> newtype Ap p f a = Ap { runAp :: p a (f a) }
16:20:49 <opqdonut> ah, nice
16:20:53 <edward1> newtype LiftF2 p f g a = LiftF2 { runLiftF2 :: p (f a) (g a) }; type On p f a = LiftF2 p f f a  -- etc
16:21:32 <edward1> using 'Ap' to generalized ideal monads and coideal comonads in terms of Ap Either  (for ideal monads) and Ap (,) for coideal comonads
16:22:17 <edward1> i think i'll move them all into something like control.functor.combinators or something
16:22:24 <lament> actually the reason we have monospaced fonts at all is because typewriters could only move the paper the same amount for each key press. So people had to use monospaced fonts, throwing away hundreds of years of development of typography.
16:23:56 <jberryman> you can't say that halted the development of typography, people were hand-setting type for everything
16:24:15 <jberryman> oh, "throwing away"
16:24:17 <lament> typewriters don't have much to do with typography
16:24:18 <jberryman> sry
16:24:25 <lament> they don't typeset stuff
16:24:42 <opqdonut> yeah, they're just "writing utensils"
16:25:05 <opqdonut> of course the side-effect of people writing with typewriters was that people had to read more typewritten stuff
16:25:23 <opqdonut> which is kind of a setback compared to the state-of-the-art typography back then
16:25:50 <opqdonut> but OTOH, the stuff that was just typewritten would never have been typeset anyway, so the alternative would have been handwritten
16:26:08 <jberryman> anyone seen the film 'Helvetica'?
16:26:16 <opqdonut> no
16:26:16 <popcorn> jberryman: no, is it good?
16:26:29 <edward1> i do wish i could use partially applied types in instances where its unambiguous and there is no way you could fail. i.e. given type (m :+: n) a = LiftF2 Either m n a  it'd be nice to be able to use (m :+: n) in the instance head, since it unambiguously expands and all remaining variables go right on the end
16:26:38 <opqdonut> ah, documentary it seems
16:27:36 <opqdonut> i read an article on helvetica (the typeface)
16:27:40 <edward1> that would clean up my code and greatly improve my readability
16:27:53 <edward1> opq: and the birth of the abortion that is arial ? =)
16:27:59 <opqdonut> probably released because of the 50yr anniversary
16:28:48 <shapr> edward1: btw, the puzzle sentence is: Commutative, local Frobenius algebras are precisely the zero-dimensional local Gorenstein rings containing their residue field and finite dimensional over it.
16:29:01 <edward1> shapr: heh
16:29:08 <jberryman> popcorn: yeah, I'd definitely recommend it. It revolves around the history of the typeface. It really succeeds in communicating this excitement with design and text that the people i  the film have.
16:29:17 <shapr> @seen edwardk
16:29:17 <lambdabot> I saw edwardk leaving #haskell 3h 36m 47s ago, and .
16:29:32 * shapr grins evilly
16:29:34 <jberryman> *that they have for their art
16:30:00 <shapr> @seen glguy
16:30:00 <lambdabot> glguy is in #haskell. I don't know when glguy last spoke.
16:30:06 <glguy> hi
16:30:10 <opqdonut> heh
16:30:15 <glguy> if you are going to ask about hpaste2
16:30:21 <glguy> I tried installing it on code. last night
16:30:43 <shapr> glguy: I was actually going to ask you if you wanted to try the puzzle :-)
16:30:45 <glguy> and will have to try again later when I'v emore stamina trying to install the the stuff from '07 and '08
16:30:48 <glguy> that debian doesn't have
16:30:53 <glguy> shapr: oh, sure
16:31:32 <shapr> The puzzle question is whether this sentence is actual math, or something I made up: "Commutative, local Frobenius algebras are precisely the zero-dimensional local Gorenstein rings containing their residue field and finite dimensional over it."
16:31:34 <popcorn> jberryman: cool, ty
16:32:20 <glguy> shapr: I'm guessing actual...
16:32:26 <edwardk> @google Commutative, local Frobenius algebras are precisely the zero-dimensional local Gorenstein rings containing their residue field and finite dimensional over it.
16:32:27 <lambdabot> http://en.wikipedia.org/wiki/Frobenius_algebra
16:32:30 <shapr> bah!
16:32:31 <edwardk> =)
16:32:33 <shapr> Too easy!
16:32:40 <shapr> glguy: You are CORRECT!
16:32:48 <edwardk> amazing, an exact match on teh interweb
16:32:49 * shapr gives today's gold lambda sticker to glguy 
16:33:45 <shapr> I want some Haskell puzzles.
16:33:58 <SamB> shapr: next time, steal from a BOOK
16:34:17 <edwardk> samb: to be fair it was a trickier puzzle when i was in the car with no internet ;)
16:34:34 <shapr> Yeah, I could ... but in a moment of pragmatism I realized that lots of what I read about math and category theory sounds like creative writing.
16:34:43 <shapr> Sounds like Star Trek technobabble.
16:34:56 <shapr> edwardk: It didn't help that I misquoted...
16:35:48 <jberryman> shapr: I think that sentence just created a black hole
16:35:53 <edwinb> I reckon if you made something up, it'd still have some genuine meaning in category theory
16:36:00 <shapr> edwinb: hah!
16:36:03 * edwinb runs scared from the category theory
16:36:45 <edwardk> l think i'm going to go back to more specific constructors from the 'uber-generic' versions. Ap makes the instance heads too ugly. maybe i'll support both or something so you can see they are the same
16:36:55 <edwardk> but i want a nice concise 'Ideal' constructor to get my hands on
16:37:19 <shapr> But really, I don't know of any other field of knowledge that is quite as impenetrable as category theory.
16:37:29 * araujo throws a lambda-trap at shapr 
16:37:34 * shapr is caught!
16:37:40 <araujo> :-]
16:39:06 <Botje> You caught a wild shapr!
16:39:17 <shapr> I'm especially wild today!
16:39:23 <Botje> Give it a name? (n/Y)
16:39:35 <popcorn> lol
16:41:46 <shapr> ok, time to unicycle
16:44:23 <edwardk> heh 'Ap' takes a 'unpointed applicative functor' and makes it a full fledged Applicative. nice coincidence -- er well Ap Either does anyways
16:44:59 <popcorn> what is pointed?
16:45:15 <edwardk> class Functor f => Pointed f where return :: a -> f a
16:45:26 <edwardk> the boring part of a monad
16:45:27 <popcorn> oh ok
16:45:56 <popcorn>  how do you learn all this category theory ? I just couldn't keep it all together in my head
16:46:32 <edwardk> popcorn: by writing code for it mostly
16:46:46 <edwardk> i get to use haskell as a poor-man's proof assistant that way ;)
16:46:47 <popcorn> ooh ok
16:46:52 <popcorn> :D
16:47:50 * ddarius has learned very little category theory from Haskell.
16:48:16 <popcorn> I was reading sets for mathematics
16:48:27 <popcorn> It's very nice but hard
16:49:35 <Cale> popcorn: By Lawvere?
16:49:41 <popcorn> yes
16:49:47 <Cale> Yeah, that's a fun book :)
16:49:50 <popcorn> I got it because you recommended it :)
16:50:08 <popcorn> (and I'm interested in foundations of mathematics)
16:50:38 <edwardk> @hpaste
16:50:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:50:50 <Cale> It's an interesting alternate formulation of things. It's not clear that it's at all equivalent to ZFC, but it's close enough for jazz.
16:51:02 <dons> dcoutts: we could improve Put speed by avoiding building a list in the result type,just to convert it to Chunks
16:51:09 <popcorn> I only realy know about CIC, haven't studied ZFC
16:51:33 <dcoutts> dons: yes, we did it that way for portability between bytestring versions
16:51:59 <dons> i'll see if it helps performance much
16:52:03 <dcoutts> dons: when we think support for ghc-6.6 no longer matters we can do it directly
16:52:04 <edwardk> hrmm do you think it would be a bad idea to define instances like: http://hpaste.org/7517 so that it is clear that each concept maps onto the more general ones?
16:52:26 <dcoutts> dons: or we could see how much cpp it costs to do it both ways
16:53:35 <edwardk> ddarius: that is because i presume that your mother was reading you prepublish drafts of Mac Lane's works while you were still in the womb. For the rest of us, who weren't fed this material intravenously it seems to help ;)
16:53:51 <Cale> I also rather like how he points out that this way of thinking about elements of sets connects up better with an older notion of what a "value" is -- like how you can have a generalised element of the reals which is the temperature, parametrised over time. Of course, it's just a fancy way of talking about a function, but gets you to think about things somewhat differently :)
16:54:44 <ddarius> edwardk: I had never even heard of category theory until I started using Haskell.
16:54:56 <edwardk> ddarius: i'm mostly teasing =)
16:55:11 <Cale> I heard about category theory prior to Haskell :)
16:56:01 <edwardk> er so does anyone have a strong opinion on if i should implement the redundant tower of instances?
16:56:05 <ddarius> I had a math renaissance around the same time I started Haskell (not inspired by Haskell, but later partially fueled by it.)
16:56:53 <popcorn> edwardk: how are they redundant?
16:57:56 <edwardk> popcorn: they are all the same thing after the compiler gets done basically. the main reason for them is coz i can't use the type alias if i were to say type Ideal f a = Ap Either f a in the instance head, so when you skimmed the instance lists for the free monads or whatever you wouldn't see any of them
16:58:15 <popcorn> oh I see
16:58:21 <edwardk> and that FixB (BiffB ...) is an awful lot to say to say (,)a =)
16:58:22 <popcorn> well do they have different definitions?
16:59:03 <popcorn> (would it be instructive to readers to write them?)
16:59:05 <edwardk> there is some constructor shuffling, so to have the more general concepts in the library i should implement them its a question i suppose of if i should implement the more specific versions. i'm leaning towards yes
16:59:25 <edwardk> and i think they'll be instructive insofar as you can see that oh yeah this is just how i'd apply that same idea to the more general object here...
16:59:38 <popcorn> ok yeah I think so then
16:59:46 <edwardk> i was afraid you'd say that =)
16:59:52 <popcorn> but I mean.. *I* probably wouldn't understand them :P
16:59:59 <edwardk> but i'd pretty much already convinced myself to go that way =)
17:00:46 <edwardk> @pl \p a -> p a a
17:00:46 <lambdabot> join
17:03:06 <edwardk> i think i'm also going to roll all the control.bifunctor.* into control.functor.* so you can include half as many modules
17:07:51 <edwardk> @pl \f p a b -> f (p a b)
17:07:51 <lambdabot> (.) . (.)
17:07:56 <edwardk> @type swing
17:07:57 <lambdabot> Not in scope: `swing'
17:08:21 <popcorn> hey what's swing?
17:08:25 <popcorn> I heard of that before
17:08:47 <edwardk> http://www.haskell.org/haskellwiki/Pointfree
17:08:48 <lambdabot> Title: Pointfree - HaskellWiki
17:09:07 <edwardk> ah thats not 'swing' i guess its called 'dot'
17:09:41 <shachaf> It should be called (..).
17:10:08 <ddarius> edwardk: No one will know what you are talking about if you say "dot"
17:10:16 <edwardk> ddarius: yeah i know
17:10:48 <saml> :t (..).
17:10:50 <lambdabot> parse error on input `..'
17:10:55 <edwardk> i was looking for a good name for a type level functor combinator of a functor wrapped around a bifunctor and the intuitive combinator names that i get from taking the folklore names of the term level equivalents has been good so far
17:10:59 <edwardk> i'd hoped that was swing =)
17:11:13 <shachaf> Some people call it (.:), I think.
17:11:25 <edwardk> Ap, Join, On, LiftF2, etc have worked nicely
17:11:27 <shachaf> Maybe (...) would work; (...) = (.) . (.)
17:11:49 <edwardk> there is still no good name for 'a bifunctor composed with two functors bifunctor
17:11:50 <ddarius> :t curry (***)
17:11:53 <lambdabot>     No instance for (Arrow (,))
17:11:53 <lambdabot>       arising from a use of `***' at <interactive>:1:6-10
17:11:53 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
17:12:17 <edwardk> :t uncurry (***)
17:12:18 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
17:12:40 * gwern has reformatted 2 monad reader articles today. so far so good
17:13:09 <dcoutts> good work!
17:14:13 * dcoutts hacks on cabal upgrade
17:14:37 <edwardk> hrmm going the other way
17:14:49 <edwardk> @let biff p f g a b = p (f a) (g b)
17:14:50 <lambdabot> Defined.
17:15:02 <edwardk> now, what is it good for =)
17:15:18 <popcorn> biff (*) f g = \a b -> f a * f b
17:15:22 <popcorn> oops
17:15:54 <edwardk> i use it all the time at the functor level
17:16:20 <popcorn> > biff (==) id reverse =<< "abba"
17:16:26 <lambdabot>  Couldn't match expected type `[a] -> [a]'
17:17:12 <popcorn> > join (biff (==) id reverse) "abba"
17:17:13 <lambdabot>  True
17:17:29 <edwardk> takes two arguments, i have a 'functorb' that has a similar type but functorb p f g a = p (f a) (g a)
17:17:29 <popcorn> sort of ruins it to use join though
17:18:00 <edwardk> @pl \p f g a -> p (f a) (g a)
17:18:00 <lambdabot> liftM2
17:18:09 <edwardk> oh yeah i'd renamed it to LiftF2
17:18:47 <edwardk> crappy term level name though
17:19:28 <edwardk> @type \p f g a -> p (f a) (g a)
17:19:29 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
17:21:15 <edwardk> > liftM2 (==) id reverse =<< "abba"
17:21:15 <lambdabot>  Couldn't match expected type `m b' against inferred type `Bool'
17:21:30 <gwern> http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue3/Join_Hs <-- looks much better
17:21:32 <lambdabot> Title: The Monad.Reader/Issue3/Join Hs - HaskellWiki, http://tinyurl.com/6n97ut
17:21:34 <twanvl> > liftM2 (==) id reverse $ "abba"
17:21:36 <lambdabot>  True
17:22:03 <edwardk> oh yeah =)
17:35:03 <gwern> http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue3/SoE_Review <-- that one was easy
17:35:04 <lambdabot> Title: The Monad.Reader/Issue3/SoE Review - HaskellWiki, http://tinyurl.com/5mygee
17:41:51 <gwern> http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue3/Purely_Functional_Data_Structures <-- Issue 3 - done!
17:41:52 <lambdabot> Title: The Monad.Reader/Issue3/Purely Functional Data Structures - HaskellWiki, http://tinyurl.com/6lqu5g
17:44:00 <ddarius> Wouter now learns the power of harnessing the internet.
17:44:01 <gwern> interesting that there appears to be no state monad article on the wiki
17:44:15 <ddarius> There was one on the old wiki.
17:50:38 <popcorn> > fix ("foobar"++)
17:50:40 <lambdabot>  "foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoo...
17:54:18 <ddarius> > cycle "foobar"
17:54:19 <lambdabot>  "foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoo...
17:54:31 <ddarius> cycle = fix . (++)
17:55:00 <popcorn> = cycle . repeat ?
17:55:03 <popcorn> eeys
17:55:07 <popcorn> = concat . repeat ?
17:55:16 <ddarius> Yes and no.
17:55:32 <popcorn> hmmm
17:55:38 <popcorn> @src concat
17:55:38 <lambdabot> concat = foldr (++) []
17:55:42 <popcorn> @src repeat
17:55:42 <lambdabot> repeat x = xs where xs = x : xs
17:56:05 <saml> > let { a = "foobar"; b = a ++ b; } in b
17:56:07 <lambdabot>  "foobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoobarfoo...
17:56:23 <saml> i hate recursive definitions
17:56:33 <saml> impossible to implement them
17:56:55 <popcorn> repeat = fix . (:)
17:57:08 <popcorn> > concat . fix . (:) $ "test"
17:57:09 <lambdabot>  "testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttes...
17:57:26 <popcorn> how do I go from
17:57:30 <popcorn> fix . (++)
17:57:31 <popcorn> to
17:57:34 <popcorn> concat . fix . (:)
17:57:35 <popcorn> ?
17:58:03 <ddarius> It would be easier to go the other way.
17:58:14 <ddarius> In which case it's pretty much trivial.
17:58:18 <popcorn> oh let me think about it :D
17:58:44 <popcorn> hmm
17:58:46 <ddarius> @free fix
17:58:48 <lambdabot> f . g = h . f => f (fix g) = fix h
17:58:49 <popcorn> I guess I need foldr fusion
18:01:07 <ddarius> The definition of foldr is the first way (not foldr fusion as there is only one foldr).
18:01:35 <ddarius> Using the free theorem of fix, the problem reduces to concat . (x:) == (x++) . concat
18:01:39 <cdsmithus> Can someone take a look at http://hpaste.org/7519?  GHCi just quits on me. :(
18:02:06 <OceanSpray> Hey guys, what should I write next in Haskell?
18:02:13 <cdsmithus> (Apparently with darcs head, but not 6.8.2)
18:02:19 <popcorn> oooooohhhhh clever
18:02:36 <ddarius> @free concat
18:02:39 <lambdabot> $map f . concat = concat . $map ($map f)
18:02:47 <ddarius> That won't help.
18:03:14 <gwern> OceanSpray: write a shell
18:03:20 <ddarius> Anyway, proving that lemma is a very easy exercise.
18:03:39 <gwern> or maybe a web browser
18:03:42 <gwern> that'd be interesting
18:03:44 <shapr> 1.5 hours of unicycling in cold dark rainy weather gives me a new appreciation for being warm and dry.
18:04:02 <gwern> OceanSpray: or you could try writing the split-up capability-based IO monad some people have discussed
18:04:16 <shapr> whoops, mischan
18:04:17 <OceanSpray> what?
18:07:13 <ddarius> popcorn: However, the sharing behaviour of concat . repeat is different (in a bad way) than the sharing behaviour of cycle.
18:07:32 <popcorn> I don't really understand sharing
18:07:36 <popcorn> I mean like
18:07:38 <popcorn> if you write
18:07:43 <popcorn> g x = f x + f x
18:07:44 <popcorn> vs
18:07:50 <popcorn> h x = let fx = f x in fx + fx
18:07:56 <popcorn> is that ALL sharing is about?
18:08:22 <ddarius> Yes, but sharing is a non-trivial concept.
18:10:39 <dcoutts> popcorn: it's easy when you see it locally like that
18:10:54 <dcoutts> less so when the sharing is in arg positions, in data structures, in recursion etc
18:11:11 <popcorn> oh I see right
18:11:18 <popcorn> yeah I think I understand
18:11:32 <popcorn> and it would be a valid optimization to try to increase sharing when possible?
18:11:36 <popcorn> kind of like it's ok to TCO
18:12:09 <dcoutts> popcorn: in general it's not an optimisation to increase sharing so the compiler does not do so
18:12:25 <popcorn> why would you ever not want sharing?
18:12:25 <dcoutts> you need extra knowledge as a programmer to know it will in a specific case
18:12:39 <dcoutts> if it means you end up holding on to too much data
18:12:55 <dcoutts> data that might be quick to re-compute
18:13:20 <ddarius> popcorn: sharing is a time/space trade-off.
18:13:21 <gwern> ah, so it's memoization all over again
18:13:29 <popcorn> ahh ok
18:13:32 <popcorn> thanks!
18:13:34 <ddarius> gwern: Sharing isn't memoization.
18:13:46 <popcorn> isn't like
18:13:57 <gwern> ddarius: making an analogy
18:14:10 <popcorn> primes = [2,3,5,7..]
18:14:23 <popcorn> prime = (primes !!)
18:14:32 <popcorn> that memo,s where
18:14:36 <popcorn> prime = <calculate>
18:14:39 <popcorn> doesn't right?
18:14:46 <popcorn> because it's sharing a toplevel 'let'
18:14:51 <popcorn> or is that not the case
18:15:10 <ddarius> popcorn: The traditional example is two definitions of powerset.  powersetUnshared [] = [[]]; powersetUnshared (x:xs) = powersetUnshared xs ++ map (x:) (powersetUnshared xs); powersetShared [] = [[]]; powersetShared (x:xs) = xss ++ map (x:) xss where xss = powersetShared xs
18:15:26 <Igloo> popcorn: In your first one, prime is still O(n)
18:16:05 * Igloo isn't sure whether that would technically count
18:16:09 <gwern> http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4 <-- formatting - accomplished!
18:16:10 <lambdabot> Title: The Monad.Reader/Issue4 - HaskellWiki
18:16:25 <ddarius> Igloo: I say we point gwern at the old Hawiki.
18:16:39 <Igloo> gwern: Cool!
18:16:47 <Igloo> ddarius: Isn't the problem there mostly licensing?
18:16:52 <ddarius> Is it?
18:17:02 * gwern believes so
18:17:14 <gwern> that is the stated issue in [[hawiki]]
18:17:17 <ddarius> Maybe for a lot of it, but there is a lot of it that doesn't have (as much at least) licensing issues that is not "ported".
18:17:44 <edwardk> who has to still be chased down for licensing?
18:17:46 <Igloo> gwern: the first contents entry looks wrong, BTW
18:17:52 <ddarius> edwardk: Everyone.
18:18:05 <edwardk> ddarius: i mean is there a checklist of who has given permission?
18:18:10 <ddarius> edwardk: Yes.
18:18:56 <gwern> Igloo: no, it seems phillipa's entry was deliberaltey omitted
18:18:58 <gwern> afaik
18:19:12 <edwardk> i can't seem to actually find it =)
18:19:15 <gwern> Igloo: so I took the expedient of adding an ext ln to the old TMR site
18:19:26 <Igloo> Oh, I see, I didn't notice the link was to the other wiki
18:19:31 <gwern> (better than leaving it unlinked entirely and useless)
18:19:54 <ddarius> edwardk: http://www.haskell.org/haskellwiki/Hawiki
18:19:56 <lambdabot> Title: HaWiki migration - HaskellWiki
18:21:00 <edwardk> ddarius: thx
18:21:16 <underscore> Does anyone know how to get rid of 'thread blocked indefinitely' errors? I have a program that runs fine in ghci but always quits with that message when compiled standalone.
18:23:35 <edwardk> heh taking mcbrides 'jokers and clowns' terminology every monad/comonad gives rise to a 'clown' parameterized monad/comonad. for some reason i have trouble taking that seriously =)
18:24:32 <edwardk> which of course then gives rise back to the same monad when you fix it, yay for strange combinator combinations
18:25:44 <gwern> @where YAHT
18:25:45 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
18:26:07 <ddarius> edwardk: That makes perfect sense.
18:26:32 <edwardk> ddarius: sure, its just nice to see all the instances dropping into place
18:28:25 <edwardk> @pl \mf m -> Clown (runClown mf <*> runClown m)
18:28:25 <lambdabot> (Clown .) . (. runClown) . (<*>) . runClown
18:28:53 <edwardk> @let on (*) f a b = f a * f b
18:28:54 <lambdabot> Defined.
18:28:59 <edwardk> does pl use 'let'?
18:29:03 <ddarius> No
18:29:07 <edwardk> or does it have a small fixed dictionary?
18:29:09 <edwardk> ah oh well
18:29:22 <ddarius> edwardk: @pl is (optimized) compilation to combinators.
18:30:13 <edwardk> ddarius: i meant does it see new combinators from @let ;)
18:31:38 <edwardk> i was originally thinking of renaming Clown and Joker to L and R or something, but they do seem to be easy to remember once you get used to them and they act very differently as far as instances are concerned
18:33:16 <underscore> Ah, for some reason the program had to be compiled with -threaded (?)
18:34:29 <underscore> It seems to work alright with +RTS -N2 -RTS, but without it it still fails intermittently. This is sort of weird, as I only can do one hardware thread at a time (old Pentium M).
18:34:34 <ddarius> edwardk: No it doesn't.
18:35:04 <edwardk> ddarius: well, because the PPointed, etc stuff all fixes the right hand side of the bifunctor. they are different only by convention
18:35:22 <ddarius> edwardk: That would be pretty hard ("dynamically" extending the set of combinators @pl uses)
18:35:50 <edwardk> ddarius: i understand completely, was just checking because lambdabot often pleasantly surprises me
18:36:21 <ddarius> lambdabot is put together with sticks and bubblegum.
18:36:22 <hexpuem> are there any tutorials of examples where its appropriate to roll custom monads?
18:36:50 <visof> @paste
18:36:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:37:11 <ddarius> hexpuem: Technically, any such example that would be generally applicable would suggest a monad that you should put in the library or use as is.
18:37:25 <hexpuem> yea
18:37:43 <hexpuem> i dunno im just having trouble looking at my code and saying "yea this should be changed to a monad" i guess
18:37:44 <visof> http://hpaste.org/7520
18:38:05 <visof> is this function right , it's supposed to do :
18:38:25 <visof> foo        [Just 2, Nothing, Just 3]
18:38:29 <visof>        [Nothing, Nothing, Just 5]
18:38:29 <visof> => [Just 2, Nothing, Just 8]
18:38:33 <visof> is it very wrong ?
18:38:48 <ddarius> hexpuem: Usually you don't do things that way.  You think, "what effects do I need?" and then you make (or usually use an existing) monad to provide those effects.
18:39:22 <hexpuem> hmm ok, thanks
18:39:26 <gwern> I think part of it is supposed to be when you look at your code and think: 'hm, I'm doing a lot of plumbing and excess stuff'
18:39:48 <ddarius> > zipWith (liftM2 (+)) [Just 2, Nothing, Just 3] [Nothing, Nothing, Just 5]
18:39:51 <lambdabot>  [Nothing,Nothing,Just 8]
18:40:17 <ddarius> gwern: You should be abstracting such stuff away anyways without having to look for monads.
18:40:23 <visof> ddarius is what i did very wrong ?
18:40:43 <visof> http://hpaste.org/7520
18:40:55 <ddarius> visof: It demonstrates significant misunderstanding of the language.
18:41:11 <visof> hehe
18:41:18 <visof> so i'm stupid
18:41:41 <ddarius> visof: Maybe.  All I can tell is that you are having serious issues in how you think pattern matching works.
18:41:43 <visof> ddarius thanks for your clarity
18:43:42 <gwern> oh, so that's what he's doing wrong
18:44:06 <gwern> visof: the type error is you're claiming to have Int, where you actually have Maybe Int; do you see why?
18:45:06 <gwern> (or maybe the other way around, whatever)
18:45:14 <visof> gwern what do you mean ?
18:45:34 <gwern> well, consider the last line
18:46:05 <visof> okay
18:46:12 <gwern> suppose somone gives you function [Just 1, Just 2] [Just 1, Just 2], and the patterns are ' (x:xs) (y:ys)'. what is 'x'?
18:46:24 <ddarius> There are three-ish errors I see.  The smallest is Just x+y parses as (Just x)+y. The 'Just's are not being pattern matched to get at the actual values.  Finally, there is a logical error in the overall structure, though it's roughly correct.
18:47:00 <visof> x is the head of the list
18:47:06 <ddarius> Which is?
18:47:06 <gwern> *gives your
18:47:23 <visof> just 1
18:47:27 <gwern> visof: and what is the head of the list, that is, what is 'x+y'?
18:47:50 * gwern suggests that it is 'Just 1 + Just 1'
18:48:20 <gwern> maybe it would help if I formatted the two arguments as ' [(Just 1), (Just 2)] [(Just 1), (Just 2)]'
18:48:24 <visof> (Just x + Just y)
18:48:33 <visof> ?
18:49:10 <gwern> better. now, consider. what is the type of (+)?
18:49:10 <gwern> :t (+)
18:49:11 <lambdabot> forall a. (Num a) => a -> a -> a
18:49:40 <gwern> + wants two Nums, it doesn't want two Maybe Nums, if you follow
18:49:52 <gwern> the sig is a -> a -> a, not m a -> m a -> m a
18:50:03 <gwern> you have to shuck off the wrapper
18:50:06 <lament> @hoogle m a -> m a -> m a
18:50:06 <lambdabot> Prelude.asTypeOf :: a -> a -> a
18:50:06 <lambdabot> Prelude.const :: a -> b -> a
18:50:06 <lambdabot> Prelude.seq :: a -> b -> b
18:50:14 <lament> hoogle dumbs
18:50:41 <lament> @djinn m a -> m a -> m a
18:50:41 <lambdabot> f _ a = a
18:50:54 <lament> djinn is smart!
18:51:35 <visof> gwern can't i say (Just (x+y)) ?
18:51:48 <dmwit> gwern: Alternatively, you have to add a wrapper to (+).
18:52:15 <gwern> visof: remember what x and y are, in our example. that'd translate to '(Just ((Just x) + (Just y)))'
18:52:35 <visof> oh sorry
18:52:47 <gwern> dmwit: yeah, but if he is having trouble with Maybe, I don't want to suggest some weirdo redefinition of + or typeclasses
18:53:07 <dmwit> liftM2 (+) -- not so weird
18:53:36 <dmwit> ...provided you already understand monads. =P
18:55:26 <gwern> the definition of recursion is easy to understand if you know the definition of recursion...
18:55:51 <conal> liftM2 = liftA2.  simpler than monads
18:55:56 <gwern> visof: are you familiar with case expressions yet?
18:56:15 <visof> no
18:56:32 <popcorn> wait conal is that a valid definition of liftM2 ?
18:56:36 <popcorn> for any monad
18:57:16 <conal> popcorn: in a sense, yes, but liftM2 is already defined.
18:57:23 <popcorn> cool
18:57:51 <conal> popcorn: i just meant that that one needn't understand monads to use liftM2, since liftM2 corresponds to liftA2, which is defined on the simpler notion of applicative functors
18:57:55 <gwern> huh
18:57:55 <gwern> @hoogle Maybe a -> a
18:57:55 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
18:57:55 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
18:57:55 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
18:57:56 <gwern> visof: using a case expression is the standard way to shuck off the Maybe wrapper and get at the sweet sweet marrow, but if you don't know it
18:58:08 <popcorn> @src Applicative
18:58:08 <lambdabot> class Functor f => Applicative f where
18:58:08 <lambdabot>     pure  :: a -> f a
18:58:08 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:58:15 <popcorn> @src Monad
18:58:16 <lambdabot> class  Monad m  where
18:58:16 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
18:58:16 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
18:58:16 <lambdabot>     return      :: a -> m a
18:58:16 <lambdabot>     fail        :: String -> m a
18:58:26 <conal> @src liftA2
18:58:26 <lambdabot> liftA2 f a b = f <$> a <*> b
18:58:32 <conal> @src liftM2
18:58:32 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
18:58:58 <popcorn> hmm
18:59:07 <popcorn> I can't write >>= in terms of pure and <*> though, can I?
18:59:08 <Botje> to be fair, liftM2 can be written as return f `ap` a `ap` b too
18:59:13 <ddarius> popcorn: No.
18:59:17 <conal> popcorn: definitely not
18:59:38 <conal> popcorn: because Applicative is simpler, i.e., less expressive, i.e., more general
19:00:35 <bd_> :t (<$>)
19:00:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:01:18 <conal> synonym for fmap
19:01:32 <conal> @src (<$>)
19:01:33 <lambdabot> f <$> a = fmap f a
19:01:48 <popcorn> you cant implement Applicative with Monad either
19:01:56 <conal> popcorn: you can
19:02:01 <popcorn> oh I though you need Monad Functor
19:02:09 <ddarius> instance Monad m => Applicative m where pure = return; (<*>) = ap
19:02:30 <bd_> popcorn: Theoretically, all Monads are Functor
19:02:30 <bd_> s
19:02:40 <ddarius> liftM is the proof
19:02:43 <bd_> it's not implemented that in the standard libraries, which is really quite unfortunate
19:03:16 <bd_> @src <*> Monad
19:03:17 <lambdabot> Source not found. Where did you learn to type?
19:03:32 <bd_> @src (<*>) Functor
19:03:33 <lambdabot> Source not found. Maybe you made a typo?
19:03:38 <ddarius> The above instance declaration isn't legal.
19:03:57 <ddarius> Similarly neither is: instance Monad m => Functor m where fmap = liftM
19:04:12 <bd_> @src (<*>) Identity
19:04:12 <lambdabot> Source not found. My pet ferret can type better than you!
19:04:21 <popcorn> bd_: how?
19:04:32 <popcorn> @src Functor
19:04:32 <lambdabot> class  Functor f  where
19:04:32 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
19:05:06 <popcorn> :t \f es -> do x <- es ; return (f x)
19:05:08 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => (t1 -> t2) -> t t1 -> t t2
19:05:08 <bd_> @sec liftM
19:05:09 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:05:12 <bd_> ^^^ that's how
19:05:15 <bd_> liftM == fmap
19:05:35 <bd_> except fmap due to limitations in H98 instance declarations, is not implementable for all Monads
19:05:57 <bd_> but they should behave the same
19:06:48 <ddarius> bd_: If the monad satisfies the monad laws, then that definition of liftM is provably fmap.
19:07:03 <popcorn> what I am really thrown by is
19:07:06 <popcorn> less expressive = more general
19:07:20 <gwern> visof: I dunno if you wanted to use a case expression, but I've added a semi-working example
19:07:20 <ddarius> That terminology can be confusing.
19:07:55 <ddarius> popcorn: Applicative functors have less restrictions/are less specific than monads and thus more things are applicative functors.
19:08:10 <conal> popcorn: suppose i'm describing an unknown person.  the more i say, the fewer people i might be describing.
19:08:43 <conal> popcorn: the more attributes/methods i assume about a type, the fewer types i'm describing
19:08:45 <ddarius> popcorn: The more information you have about something, the more you can do with it.
19:08:54 <conal> more with less
19:09:02 <conal> (more about less)
19:09:10 <popcorn> ohh ok
19:09:26 <popcorn> I learned a lot today :D
19:09:34 <popcorn> I hope I remember all this
19:11:54 <Korollary> the channel is logged. Bookmark it.
19:13:05 <lament> BookmarkIt! (tm)
19:13:28 <gwern> visof: http://hpaste.org/7520#a2 does something similar
19:14:23 <ddarius> popcorn: It's necessary to keep track of whether you are requiring or providing some abstraction for the "expressive"/"general" terminology to remain consistent.
19:16:47 <gwern> @wn shuck
19:16:47 <lambdabot> *** "shuck" wn "WordNet (r) 2.0"
19:16:47 <lambdabot> shuck
19:16:47 <lambdabot>      n : material consisting of seed coverings and small pieces of
19:16:47 <lambdabot>          stem or leaves that have been separated from the seeds
19:16:47 <lambdabot>          [syn: {chaff}, {husk}, {stalk}, {straw}, {stubble}]
19:16:49 <lambdabot>      v 1: remove from the shell; "shuck oysters"
19:16:51 <lambdabot>      2: remove the shucks from; "shuck corn"
19:17:36 <ddarius> gwern: Uncertain of your diction?
19:17:47 <gwern> ddarius: no, it's for visof
19:17:51 * gwern is never uncertain
19:18:21 <gwern> visof: that's part of what I mean by 'lambdabot is useful'
19:18:35 <visof> yep
19:18:37 <ddarius> gwern: Ugh, that last definition is ugly.
19:19:19 <gwern> ddarius: it is amusing, because normally people only ever use 'shucks' as an expression
19:19:42 <gwern> and it's confusing - is 'shuck' a noun, or a verb? after all, 'shucks' is the plural noun - and a verb!
19:19:46 <ddarius> gwern: I was talking about the paste.  I know what shuck is.
19:19:49 * gwern shucks some shucks
19:20:08 <gwern> ddarius: oh. yeah, I just wanted to demonstrate the definition didn't have to be recursive
19:20:50 <ddarius> gwern: So why use an ugly one and one that does something different?
19:21:27 <gwern> ddarius: I was in a hurry?
19:21:53 * gwern is still formatting TMR articles
19:24:45 <ddarius> If the Applicative instance for [] was the ZipList one you would have a definition nicer than mine as simply: liftA2 (+)
19:25:01 <ddarius> Actually, no.
19:25:57 <ddarius> That definition will work, but over a ZipList applicative functor transformer over Maybe (I think)
19:26:00 * gwern wonders whether zipWith (liftM2 (+)) would've been better
19:27:00 <ddarius> It'd be prettier and shorter and I already wrote it above so you wouldn't've had to divine it, but it's not exactly immediately obvious to a beginner.
19:27:20 <ddarius> Also, per conal's suggestion, zipWith (liftA2 (+)) would work just as well and be more general.
19:28:37 <gwern> yeah. I'm kind of wondering whether I should code up a zip example - which then mapped an arrow + over the list of tuples :)
19:28:39 <popcorn> :t zipWith (liftA2 (+))
19:28:41 <lambdabot> forall a (f :: * -> *). (Applicative f, Num a) => [f a] -> [f a] -> [f a]
19:29:50 <ddarius> gwern: Expanding zipWith f into map (uncurry f) . zip doesn't appeal to me.
19:30:10 <ddarius> .: zip
19:30:16 <gwern> but it's fun figuring it out?
19:30:44 <ddarius> Proving that zipWith f xs ys == map (uncurry f) $ zip xs ys are arriving at it is fun, yes.
19:30:49 <ddarius> s/are/or
19:31:20 * gwern wonders why I've never heard of hray before: http://trappist.elis.ugent.be/~kehoste/Haskell/HRay/
19:31:21 <lambdabot> Title: :: HRay - a Haskell ray tracer ::
19:31:37 <ddarius> gwern: You're not into raytracers perhaps?
19:32:19 <gwern> I heard of the new one on -cafe...
19:33:07 <gwern> who maintains scannedinavian.org?
19:33:11 <gwern> is it shapr?
19:33:59 <Nafai> Yeah, I believe so
19:34:30 <ddarius> Yes.
19:34:41 <gwern> @seen shapr
19:34:41 <lambdabot> shapr is in #scannedinavian, #xmonad, #haskell-soc, #haskell-blah and #haskell. I last heard shapr speak 1h 26m 24s ago.
19:35:05 <gwern> @ask shapr http://trappist.elis.ugent.be/~kehoste/Haskell/HRay/ claims the hray darcs repo is on scannedinavian.org, but I can't seem to find it. where'd it go to?
19:35:05 <lambdabot> Consider it noted.
19:35:46 <shapr> gwern: yes?
19:35:46 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
19:35:54 <shapr> gwern: Ask boegel
19:35:57 <gwern> d'oh
19:36:09 <gwern> @seen boegel
19:36:09 <lambdabot> I saw boegel leaving #haskell-blah 5h 43m 47s ago, and .
19:36:17 <shapr> And yes, scannedinavian.{com,org,net} are my domains.
19:36:27 <gwern> @ask boegel http://trappist.elis.ugent.be/~kehoste/Haskell/HRay/ claims the hray darcs repo is on scannedinavian.org, but I can't seem to find it. where'd it go to? shapr said to ask you
19:36:28 <lambdabot> Consider it noted.
19:36:34 <shapr> hpaste.org is currently pointing to scannedinavian as well.
19:36:34 <gwern> :)
19:37:59 <shapr> I don't think anything else is...
19:38:19 <shapr> gwern: There's also Wolfgang Thaller's sort-of raytracer in Haskell.
19:38:39 <gwern> shapr: is that the one that's been discussed recently on -cafe?
19:38:53 <shapr> gwern: If you want info on rare Haskell packages, have you seen Jan Skibinski's Smalltalk/Squeak bindings?
19:39:05 <shapr> Or what about the InForM workbench?
19:39:17 <gwern> shapr: I think I heard of the smalltalk bindings once, but I don't think I have them
19:39:34 <gwern> shapr: inform workbench? any relation to SamB;s zmachine?
19:39:53 <araujo> shapr, link for those bindings? :-)
19:39:54 <shapr> No, the InForM workbench was made by a German university.
19:40:08 <shapr> That project had a rather monstrous codebase.
19:40:09 <SamB_XP> gwern: are you kidding? capitalized like THAT?
19:40:49 <gwern> SamB_XP: I'm not a text adventure maven, how would I know?
19:40:54 <shapr> oh sorry UniForM Workbench
19:40:55 <shapr> doh
19:41:15 <shapr> From Bremen
19:41:41 <gwern> http://www.informatik.uni-bremen.de/~ewk/WB.html
19:41:43 <gwern> wow, ghc 3.10?
19:41:51 <shapr> oldschool :-)
19:42:20 <gwern> truly, the curse of haskell is not that we lack apps or libraries - just no one wants to maintain them >.<
19:42:23 <shapr> I could never get the daVinci integration to work.
19:42:46 <shapr> Mostly because daVinci had been bought by IBM and renamed to something else.
19:43:06 <shapr> HTk did work at one point.
19:43:16 * gwern is somewhat grateful there is no mention of a Free license, or a download link - so I won't feel any obligation to try to update it
19:43:44 <shapr> It claims to be 40KLOC, but I think that page is old.
19:44:34 <shapr> gwern: Familiar with Fudgets?
19:44:59 <gwern> http://web.archive.org/web/20010306205042/http://www.numeric-quest.com/haskell/smartest.html <-- the smarty (squeak/smalltalk) page has no working downloads?
19:45:00 <lambdabot> Title: The world's smartest i/o device for Haskell, http://tinyurl.com/6fk28l
19:45:07 <gwern> shapr: I've seen it mentioned as a dependency...
19:45:11 <gwern> for stuff I never succeeded with
19:45:33 <ddarius> gwern: That's your only knowledge of it?
19:45:43 <shapr> Fudgets has its own InternetLib, implementing several useful protocols. I don't think I ever got it to build though.
19:46:27 <shapr> whoa, I found an incomplete copy of the Zeroth IOHCC!
19:46:37 <shapr> I should really explore my Haskell dir more often.
19:46:50 <jaj> @users
19:46:50 <lambdabot> Maximum users seen in #haskell: 463, currently: 404 (87.3%), active: 9 (2.2%)
19:47:09 <shapr> jaj: Are you really in Luxembourg?
19:47:17 <jaj> shapr: yep
19:47:20 <gwern> ddarius: well, what else should I know?
19:47:21 <shapr> jaj: Cool!
19:47:28 <jaj> shapr: :) why?
19:47:35 <gwern> shapr: yeah, there's a lot of interesting I downloaded off of scannednavian
19:47:43 <gwern> like that uncc program of dark's
19:47:46 <shapr> yup
19:47:49 <gwern> and mage
19:48:03 <shapr> I have lots more in my haskell dir, but I can't remember which bits are under NDA.
19:48:03 <gwern> and a bunch of other stuff I keep meaning to get around to
19:48:16 <shapr> So I didn't upload my whole dir.
19:48:17 <jaj> NDA :/
19:48:23 <gwern> (like, I keep meaning to ask you for a Free license to some of the SPJ unicycle pictures)
19:48:26 <shapr> jaj: I was doing commercial Haskell work.
19:48:45 <ddarius> gwern: Fudgets was very early FRP work
19:49:12 <gwern> ddarius: ok. and? lots of stuff used it?
19:49:29 <shapr> Fudgets had a huge codebase for the time.
19:50:15 <shapr> @seen syntaxninja
19:50:15 <lambdabot> I saw syntaxninja leaving #haskell and #haskell-blah 2h 6m 23s ago, and .
19:50:23 <shapr> I want HALVM!
19:50:34 <popcorn> I want halva
19:50:39 <popcorn> mmmm
19:50:42 <shapr> What's that?
19:50:52 <shapr> oh
19:50:52 <popcorn> It's a kind of sweet
19:50:56 <gwern> the compressed fudgets source tarballs are a good half a meg
19:50:57 <shapr> @wikipedia Halva
19:50:58 <lambdabot> No Result Found.
19:51:02 <gwern> yeah, I guess that's big for then
19:51:03 <shapr> http://en.wikipedia.org/wiki/Halva
19:51:25 * gwern did a wget -r of chalmers at some point, and I seem to have a bunch of fudgets and alfa stuff
19:51:34 <popcorn> shapr: it's much nice than wikipedia makes it seems :)
19:51:34 <ddarius> gwern: It was the source for many of the modern ideas for functional reactive programming.  The thesis is probably still well worth reading.
19:51:43 <shapr> gwern: Seen The Haskell replacement for sendmail? :-)
19:52:01 <shapr> Hm, I have some Haskell suffixtree code.
19:52:09 <gwern> shapr: didn't I packagfe that?
19:52:15 <shapr> Which?
19:52:23 <gwern> the sendmail one
19:52:47 * shapr looks
19:52:55 <conal> ddarius: how do you see fudgets as a frp source?
19:53:02 <jaj> sendmail the MTA or sendmail the MSA? :)
19:53:17 <shapr> jaj: postmaster the MTA
19:53:55 <shapr> I also had the impression that fudgets influenced FRP.. or was FRP in the beginning.
19:54:06 <shapr> I don't remember why exactly.
19:54:21 <shapr> Huh, I have some sequent calculus code by Aarne Ranta.
19:54:21 <conal> FRP (Fran) came out of TBAG.
19:54:25 <criminy> Having fun with Data.Binary. Is there a BMP image implementation using it floating around?
19:54:59 <ddarius> conal: "the" was probably too strong.  But Yampa seems like a direct successor of Fudgets.
19:54:59 <shapr> criminy: I've only seen a JPEG lib for Haskell for pure Haskell image libs.
19:55:06 <ddarius> (for example)
19:55:36 <conal> ddarius: hm.  yampa came from wrapping fran via an arrow interface, as john hughes suggested.
19:55:50 <jaj> shapr: cool, I didn't know somebody wrote an MTA in haskell
19:56:24 <conal> the first arrow frp was fruit in the paper "genuinely functional user interfaces", which then became yampa
19:56:31 <criminy> shapr: ah, thanks. Even the more reason to finish this, though I'm faily new.
19:56:35 <shapr> Aha, a proof editor for sequent calculus by Aarne Ranta - http://www.cs.chalmers.se/~aarne/pesca/
19:56:54 <shapr> criminy: Welcome, and hang on to your hat for an amazing experience!
19:58:11 <conal> oh, and between tbag and frp was "ActiveVRML"
19:58:22 <shapr> I read about that once.
19:58:35 <conal> i guess ActiveVRML was the first frp
19:58:45 <conal> not yet in haskell
19:59:11 <shapr> I wish I'd gotten that GPL version of Lava that was on the xilinx site for about a week :-(
20:00:18 * gwern abruptly wonders what the license is of lava2000
20:00:46 <shapr> Oh cool, I have the benchmarks tarball for Urban Boquist's GRIN thesis.
20:02:26 * shapr discovers a copy of Data Field Haskell - http://www.mrtc.mdh.se/projects/DFH/
20:02:27 <lambdabot> Title: Data Field Haskell, Introduction
20:04:49 * shapr grumbles, fixes hpaste again.
20:05:57 <shapr> Does anyone use Bernie Pope's buddha?
20:06:21 <gwern> shapr: I don't, but it's on my list to cabalize
20:06:24 <ddarius> I think I installed it once, and maybe used it a little.
20:06:39 <ddarius> It's Haskell 98 only though, right?
20:06:56 <gwern> wasn't that hat?
20:07:18 <orbitz> the perl 6 page claims the haskell community has embraced perl 6 as a possible scripting language.  If this statment is true doe sit mean as an embedded language?
20:07:40 <gwern> 'I'm thinking of dropping Haskell because it's just too lazy. People claim that normal order evaluation optimizes cpu cycles since you don't evaluate code that isn't used. Maybe, but to me I just see a cpu that isn't being utilized effectively. Applicative order languages work much harder, but in the end even they don't fair much better IMHO. Give me a language that implements hyper eager evaluation. Did you realize that idle cpu cycles before you've writte
20:07:50 <Korollary> I embrace haskell as a scripting language
20:08:33 <orbitz> Korollary: that is oen reason i asked, i would figure the haskell community would want haskell as a scripting langauge
20:08:34 <conal> orbitz: doesn't sound likely to me
20:08:43 <orbitz> is that statement hyperbole/made up?
20:08:53 <orbitz> (it does have a [citation needed] next to it for the record)
20:09:09 <orbitz> "A number of features in the Perl 6 language now show similarities with Haskell, and Perl 6 has been embraced by the Haskell community as a potential scripting language"
20:09:10 <Nafai> orbitz: Are they only deriving that statement based on Pugs?
20:09:16 <ddarius> gwern: Hat needed NHC, but Buddha was(is?) also H98 only
20:09:18 <gwern> I think it must be some sort of misinterpretation of pugs
20:09:29 <orbitz> i'm not sure, it's a lone sentence.  it is stated after a paragrpah on pugs though
20:09:47 <shapr> orbitz: I think one or two projects were thinking about using pugs for a scripting language, but I don't remember if it actually happened.
20:10:28 <Korollary> I thought 'scripting language' would be considered a pejorative for languages like perl nowadays
20:10:41 <ddarius> orbitz: The Haskell quite definitely has not and has no intention of "embracing Perl 6 as a scripting language".
20:10:55 <orbitz> i haven't looked at perl 6 at all, and i'm certainly not a langague expert, but i dont want to touch perl with a 10 ft pole if I can
20:10:56 <ddarius> What would we use it for?
20:11:35 <Korollary> ddarius: anything provided that 'we' like it
20:11:51 <orbitz> and part of that is due to using langauge sliek haskell and ocaml, it seems that the comunity wouldn't think highly of perl
20:11:59 <ddarius> In fact, I'm not aware of any language community embracing another language for almost any reason.  It doesn't make sense.
20:12:15 <Korollary> that's true
20:13:15 <shapr> orbitz: I contributed a few lines of code to pugs, I enjoyed it.
20:13:30 <orbitz> shapr: swell
20:13:31 <popcorn> pugs is super cool
20:13:52 <orbitz> most of wha ti have heard about perl 6 has been negative.  along th elines of "There is a reason Larry calls them Apocalypses"
20:13:55 * gwern contributed some - ah, some stuff. something to do with packages and 6.8 support
20:14:09 <popcorn> "Perl 6 has been embraced by the Haskell community as a potential scripting language" is obviously nonsense though
20:14:09 <gwern> I know I contributed because I have a commit bit >.<
20:14:10 <shapr> orbitz: I got to watch pugs go from a random experiment to something that worked, it was a wild ride :-)
20:14:24 <popcorn> It's ridiculous to use -one- language for all "scripting"
20:14:45 <ddarius> shapr: It was cool.  I remember when Audrey first put up the pugs pages on Hawiki.
20:14:53 <shapr> Yeah :-)
20:15:48 <gwern> oh for the days audreyt was pumping out the code and optimizing for fun!
20:16:17 <gwern> how did we lose him?
20:16:21 <gwern> er, her.
20:16:27 <gwern> it, whatever
20:16:37 <popcorn> gwern: stress I think :(
20:16:50 <conal> audreyt's no longer hacking haskell? :(
20:17:09 * gwern sees very little from audrey, and mostly dabbling stuff
20:17:14 <ddarius> I think pugs has stalled.  audreyt is still here.
20:17:37 <Nafai> @seen audreyt
20:17:37 <lambdabot> audreyt is in #perl6 and #haskell. I don't know when audreyt last spoke.
20:17:49 <Korollary> will perl6 ever make it?
20:17:57 <popcorn> Korollary: certainly!
20:19:21 <popcorn> compilers in Perl 5, Common Lisp, python work already?
20:19:29 <popcorn> for at least a decent subset of Perl 6
20:19:58 <orbitz> is support of pugs due to support of Perl 6, or support of such an attentiong etting project?
20:20:12 <popcorn> I think the idea is to implement Perl 6 in Perl 6
20:20:19 <popcorn> (and a big part of it is already)
20:20:46 <popcorn> yeah I'm not totally up to date
20:20:47 <ddarius> orbitz: It depends on the person and also that is a false dichotomy.
20:25:19 <gwern> heh. I've blown out the recent changes on the wiki
20:26:08 <gwern> ok, I think that's enough formatting for tonight
20:26:11 <gwern> I'm tired of that
20:31:19 <jdavis> is there an easy way to embed haskell code?
20:32:18 <ddarius> I think you want the transitive form of the verb 'embed'
20:32:40 * jdavis thinking...
20:33:13 <jdavis> If I have an application in C, can I take in some haskell code, and calculate a result?
20:33:24 <popcorn> yes
20:33:31 <popcorn> It's realyl really really easy
20:33:35 <ddarius> You can call Haskell from C using the FFI
20:33:37 <popcorn> let me try and find this thing dons linked..
20:33:45 <ddarius> @where ffi
20:33:45 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
20:33:59 <jdavis> Oh, I thought FFI was for calling C from haskell.
20:34:27 <jdavis> oh, "support for invoking code written in other programming languages from Haskell and vice versa"
20:34:34 <jdavis> thanks! I'll look into it.
20:37:07 <jdavis> ddarius: I also learned what a transitive verb is: "The meaning of a transitive verb is incomplete without a direct object". ;)
20:44:46 <conal> ddarius: from an earlier thread, i'm interested in what similarities you see between fudgets and yampa (and maybe other instances of frp).  i'm always curious about people's perceptions of frp.  fudgets was such a rich thesis, and i may have missed some connections.
20:47:55 <ddarius> conal: The whole stream processing framework seems very similar (but different) from the approach of some notable FRP incarnations.
20:48:35 <conal> ddarius: okay.  stream processing.  thx.
20:50:25 <snhmib> jdavis: at the end of here there's handy ffi notes =)
20:50:46 <dolio> @seen SamB_XP
20:50:46 <lambdabot> SamB_XP is in #haskell-blah and #haskell. I last heard SamB_XP speak 1h 10m 37s ago.
20:50:52 <criminy> Data.Binary reads and writes Big Endian, while Bitmap data is stored Little Endien...
20:50:59 <SamB_XP> dolio: you rang?
20:51:01 <jdavis> snhmib: where?
20:51:26 <dolio> SamB_XP: Is your mail to the agda list supposed to have a sigma in the title?
20:51:33 <SamB_XP> dolio: yes!
20:51:34 <criminy> endian*
20:51:37 <SamB_XP> I don't know why it doesn't
20:51:47 <popcorn> there's an Agda list ?!
20:51:49 <ddarius> criminy: No, the Binary class uses big endian.  The actual Put and Get monads support either endianness.
20:51:49 <SamB_XP> I was wondering that myself
20:51:51 <dolio> You might find this helpful: http://lambda-the-ultimate.org/node/1299
20:51:52 <lambdabot> Title: Type theory question... | Lambda the Ultimate
20:51:56 <snhmib> ? Foreign procedures may take several arguments. Their Haskell type is curried, as is usually
20:51:57 <snhmib>   the case for multi-argument Haskell functions, but on the C side the arguments are passed
20:51:59 <snhmib>   all at once, as is usual for C:
20:52:01 <snhmib> whoah
20:52:05 <ddarius> criminy: You shouldn't be using the Binary class for a defined format.
20:52:08 <snhmib> http://research.microsoft.com/~simonpj/papers/marktoberdorf/ <- here
20:52:09 <lambdabot> Title: Simon Peyton Jones: papers
20:52:35 <criminy> ddarius: Ah, thanks. I just found data.binary.get little endian-ness section. Why not?
20:52:39 <jdavis> snhmib: thanks, looking now.
20:53:16 <ddarius> criminy: Because Binary is intended for serializing Haskell values, not for producing a fixed format.
20:53:56 <criminy> I couldn't figure out other ways to do binary i/o.
20:53:57 <SamB_XP> dolio: didn't I begin the body of the message with a copy of the subject line anyway?
20:54:21 <criminy> There is System.IO with some functions that work on manually allocated chunks, I think.
20:54:36 <ddarius> criminy: The Put and Get monads are intended to be used to produce any format.
20:54:38 <dolio> SamB_XP: Yeah, but in my mail client, it's either a blank character or a question mark in a diamond in all cases for some reson.
20:54:50 <SamB_XP> dolio: oh.
20:54:58 <ddarius> criminy: The Binary -package- is what you want, but you don't want to use the Binary -class-.
20:55:02 <SamB_XP> well, even in MY client it's a rectangle in the subject line
20:55:18 <SamB_XP> I think it may be a bug in gmail's basic HTML view...
20:56:36 <criminy> ddarius: ah, so that means use "runGet" with the bytestring rather than creating an instance of Binary?
20:57:29 <dolio> SamB_XP: Looking at it in gmail, I do see the sigma in the message body.
20:57:47 <popcorn> :t do { x <- [a,b,c] ; return x }
20:57:50 <lambdabot> [Expr]
20:57:51 <SamB_XP> dolio: yes, me too
20:58:06 <popcorn> @[] instances
20:58:06 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
20:58:08 <ddarius> criminy: Yes.
20:58:09 <SamB_XP> dolio: also, that LTU thread seems to be making me progressively more confused
20:58:13 <dolio> Anyhow, hopefully that article will give some insight as to why 'dependent sums' are related to ordinary pairs.
20:58:18 <SamB_XP> where before I was just befuddled, not quite confused...
20:58:20 <popcorn> hi kryptos23
20:59:18 <ddarius> criminy: Ultimately you'd have something like openBitmap :: FilePath -> IO Bitmap
20:59:19 <dolio> I think the first response by neelk is the most important.
20:59:19 <SamB_XP> also, that still doesn't explain why the module is Data.Product and the type constructor is \sum...
21:00:04 <dolio> Because the Data.Product name is talking about the ordinary product A \times B that's defined in terms of Sigma.
21:00:17 <criminy> ddarius: That's pretty much what I have now, but openBitmap is just a decodeFile call
21:00:18 <dolio> As opposed to Data.Sum which defines A \uplus B.
21:00:28 <jdavis> all the examples I've seen of calling Haskell from C involve compiling the haskell code and linking it. Is there a way I can just execute an arbitrary haskell expression from C, similar to how ghci does it?
21:00:29 <SamB_XP> which is basically Either
21:00:31 <ddarius> dolio: As I state on that page, I don't agree with neelk.
21:00:33 <dolio> Right.
21:00:45 <SamB_XP> yes, the module names both make sense to me ;-)
21:01:02 <SamB_XP> doesn't Coq call that construct dependant product?
21:01:24 <dolio> ddarius: Oh? I suppose I don't actually know your name.
21:01:48 <dolio> SamB_XP: Some people call it dependent product, others call it dependent sum.
21:02:04 <ddarius> jdavis: There is hs-plugins and the GHC API.
21:02:07 <dolio> The former people call pi types dependent functions, I think, where the latter call them dependent products.
21:02:23 <jdavis> ddarius: ok, I'll take a look at that.
21:02:46 <popcorn> Coqs sum and product are just like Either and (,)
21:02:53 <popcorn> sum and prod
21:03:04 <SamB_XP> popcorn: I know!
21:03:09 <popcorn> oh sorry
21:03:29 <SamB_XP> so are Agdas _\uplus_ and _\times_
21:04:06 <popcorn> I should train my client to do TeX
21:04:16 <SamB_XP> eh?
21:04:28 <dolio> Epigram introduces dependent sums with \exists, I believe.
21:04:37 * popcorn sees \uplus as <backslash>uplus
21:04:49 <ddarius> That's because that's what it is.
21:04:51 <SamB> that's the usual way to see it, yes
21:05:02 <dolio> And I think they're built-in, instead of being something you have to define like Agda.
21:05:20 <dolio> I think you can use \forall for dependant products there, too.
21:05:26 <ddarius> What do you define dependent sums in terms of in Agda?
21:05:29 <popcorn> Epigram is weird
21:05:52 <dolio> ddarius: You write a data declaration for them.
21:05:56 <SamB> are there dependant sums?
21:06:06 <popcorn> yes
21:06:14 <ddarius> dependent
21:06:26 <dolio> 'data Sigma (a : Set) (P : a -> Set) where _,_ : (x : a) (y : P x) -> Sigma a P'
21:06:47 <dolio> Oops, I forgot a : Set in there.
21:06:53 <SamB> anyway, using the appropriate input method, I can type _⊎_ and _×_
21:07:09 <SamB> but I don't think SCIM works in XP
21:08:06 <SamB> oh, those are existentials?
21:08:09 <dolio> Somewhat less convenient than the epigram notation, I suppose, which lets you write things like '\exists x:A. expression-involving-x'.
21:08:32 <dolio> In agda I think you're forced to write 'Sigma A (\x -> ...)' for that.
21:08:45 <popcorn> yeah no macros in Agda
21:08:52 <SamB> honestly, I have so far mostly just used the ×...
21:08:55 <popcorn> to define binding constructs
21:09:05 <popcorn> but mixfix solves 99% of the issues
21:09:11 <popcorn> imo
21:09:13 <SamB> does it now?
21:09:28 * SamB doesn't see it solving the RAM usage issues
21:09:29 <popcorn> yeah but I've written hardly any Agda 2 at all so I'm probably wrong :P
21:09:31 <dolio> The mixfix operators are pretty sexy.
21:18:03 <dolio> ddarius: Oh, I see. neelk thinks they should be dependent product and function.
21:18:26 <dolio> Or, I suppose not.
21:19:12 <ddarius> He personally uses Pi-type Sigma-type but suggests that dependent function/product should be the preferred one (in the contexts relevant here).
21:19:29 <ddarius> if Pi-type/Sigma-type isn't used.
21:19:49 <dolio> Anyhow, I thought that explanation of how sum, exists, or and sigma are all related (and the same for pi) was good.
21:22:31 <dolio> It explains why dependent sums are tuples, if you take the term from classical logic and move to intuitionistic logic.
21:24:26 <dolio> Of course, your arguments are probably better for coming to the conclusion that 'sum' and 'product' are in fact the right names.
21:32:46 <kryptos23> hi popcorn
21:38:55 <shapr> SyntaxNinja: Hey, is HALVM released?
21:39:08 <SyntaxNinja> y0
21:39:11 <SyntaxNinja> not as far as I know
21:39:13 <shapr> y0 y0
21:39:13 <SyntaxNinja> someday maybe
21:39:14 <shapr> Ah, ok
21:39:18 <SyntaxNinja> we released some stuffs and stuff recently
21:39:22 <shapr> Oh?
21:39:26 * shapr checks galois news
21:39:31 <SyntaxNinja> someone made a twitter client from stuff we released
21:39:37 <shapr> wow
21:39:52 <shapr> Galois doesn't have a news section.
21:39:53 <glguy> :(
21:41:39 <shapr> I think sethk and BUGlabs gets credit for being the first company to have an 'official' GHC build for their mobile Linux box.
21:42:09 <SyntaxNinja> shapr: we're totally seriously going to get a new web site Real Soon Now
21:42:12 <SyntaxNinja> that'll have all that stuff.
21:42:14 <SyntaxNinja> hi glguy
21:42:26 <shapr> Think about it... I'll be able to use GHCi while I UNICYCLE!
21:42:32 <glguy> hello
21:42:43 <shapr> Not sure why I'd want to do that... but it coul be useful.
21:43:04 <SyntaxNinja> shapr: keep seeing unicycles around town
21:43:09 <shapr> Yay!
21:43:12 <shapr> We're taking over!
21:46:14 <LordBrain> is ghc 6.8 packaged for ubuntu anywhere?
21:46:26 <dolio> It's in hardy.
21:47:03 <SyntaxNinja> shapr, glguy: my bike broke today :(
21:47:28 <glguy> did you make it home?
21:47:31 <glguy> is it fixable?
21:47:42 <SyntaxNinja> not fixable :(
21:47:44 <SyntaxNinja> probably not
21:47:50 <glguy> what then?
21:48:00 <SyntaxNinja> dylan picked me up downtown
21:48:40 <glguy> what broke?
21:48:46 <SyntaxNinja> the frame, bottom tube
21:48:51 <SyntaxNinja> which is strange because it's steel
21:49:44 <glguy> assassins?
21:50:04 <glguy> were you being followed?? :-D
21:50:24 <SyntaxNinja> always!
21:50:30 <SyntaxNinja> (because I'm so fast)
21:50:35 <glguy> Did you roll a reflex saving throw?
21:50:37 <glguy> did you fall off?
21:51:07 <glguy> +2 bike of racing?
21:52:04 <glguy> We're watching Soylent Green
21:52:10 <glguy> I can't say its keeping my attention
21:53:25 <SyntaxNinja> I didn't fall off, thankfully. lucky thing, though
21:54:53 <ddarius> So you went from having one bicycle to two unicycles
22:00:05 <SyntaxNinja> ddarius: yeah, basically :)
22:06:15 <wagle> isnt a bicycle a unicycle with a training wheel?
22:06:35 <dmwit> Not really, unicycles are necessarily direct-drive.
22:07:54 <ddarius> necessarily might be a slight overstatement.
22:08:40 <dmwit> Well.
22:09:02 <dmwit> At the very least, it's a bit tricky to control a unicycle if there's a slip gear.
22:11:18 <wagle> a track bike is a unicycle with a training wheel
22:11:27 <dmwit> Yep. =)
22:11:40 <dmwit> Track bikes are pretty neat.
22:12:05 <dmwit> You can stand in one place on a track bike virtually forever.
22:12:15 <dmwit> The world record is weeks long.
22:12:20 <dmwit> (I think.)
22:28:09 <jfoutz> i'm trying to build a haskell lib to link with a mac objective-c application... does anyone have any advice about building a universal binary, or a ppc cross compiler
22:28:14 <jfoutz> ?
22:40:32 <kscaldef> dmwit: doesn't that require being awake for weeks?
22:41:24 <dons> dcoutts: looks like we're approaching the point where packages need owners in order to upload new versions -- or at least, admin ability to revert. unix got forked, and uploaded
22:41:39 <dons> yo kscaldef !
22:42:08 <kscaldef> hey dons
22:42:50 <dmwit> kscaldef: Hmm, I don't know.
22:43:01 <dmwit> That does shed some doubt on the whole weeks-long record thing, though, huh?
22:43:54 <kscaldef> yeah... I'm not sure what the record is on staying awake, but I know that in general people who stay awake for more than 5 or 6 days tend to never really be quite the same afterwards
22:44:33 <dons> i had 2.5 days uptime working on my thesis submission, and that was brutal. i'd not do it again.
22:45:26 <glguy> doesn't look like unix 2.3 or 2.4 are on darcs.
22:45:48 <glguy> h.o
22:45:50 <dons> so 2.3 was ross.
22:45:56 <kscaldef> looks like the record might be 11 days (staying awake)
22:46:05 <dons> but 2.4 is a fork, so i think he just didn't know that you shouldn't go release your own version of the core libs :(
22:46:21 <glguy> even if 2.3 was Ross, I don't see the code for it on darcs.h.o
22:46:25 <dons> since it kinda screws up cabal install. esp. when you're a haskell newbie who's not had their patches tested.
22:46:37 <dons> glguy: yeah, it looks like the tag didn't get pushed.
22:46:47 <glguy> no, the cabal file is 2.2 too
22:46:49 <dons> actually, hackage is becoming a security concern
22:46:54 <dons> glguy: yeah, i know.
22:47:02 <dons> cabal install could pull in random joe's fork.
22:47:20 <thetallguy> SyntaxNinja: you need to replace your bike with one of these: http://www.core77.com/blog/object_culture/new_electric_vehicle_with_an_unusual_form_factor_9657.asp
22:47:21 <lambdabot> Title: New electric vehicle with an unusual form factor, http://tinyurl.com/6g3oup
22:47:45 <thetallguy> ﻿SyntaxNinja: It's also sort of two unicycles
22:50:00 <glguy> He needs to ask himself wwod
22:51:16 <SyntaxNinja> it has a motor?
22:52:12 <dons> jl and phil are cleaning up tonight, glguy, SyntaxNinja ... as usual.
22:53:06 <dons> SyntaxNinja: we're going to need signing on hackage soon. If you want to fork a few brain cycles to think about what you wanted to do there, that might be useful.
22:53:09 <dmwit> > replicateM 4 [0..255]
22:53:13 <lambdabot>  [[0,0,0,0],[0,0,0,1],[0,0,0,2],[0,0,0,3],[0,0,0,4],[0,0,0,5],[0,0,0,6],[0,0,...
22:53:21 <dons> we could merge it into the project hackage stuff elliottt and i are doing.
22:54:46 <SyntaxNinja> dons: cleaning?
22:55:16 <SyntaxNinja> dons: signing, as in authenticated uploads of some kind, or trusted downloads or what?
22:55:24 <SyntaxNinja> oh for poker
22:55:35 <SyntaxNinja> so Galois is playing poker and D&D at the same time
22:55:45 <SyntaxNinja> dons: that would be _very_ interesting, though.
22:57:03 <dons> SyntaxNinja: right, someone uploaded a private fork of the 'unix' package. so that's scary enough, when coupled with 'cabal install' that we should do something.
22:57:21 <dons> it destabilises anyone relying on a trusted library
22:57:54 <SyntaxNinja> dons: yeah, at least whoever uploaded last time should be the only one who can upload next time
22:57:59 <SyntaxNinja> that should be easy enough
22:59:06 <dons> right. i think we can do that with the auth stuff in eic hackage wrapper
22:59:54 * dons notes "Wanted libraries; 14:11 . . Bjorn (Talk) (OpenID consumer library)" was added to the wanted libs wiki page today
23:00:10 <dons> web stuff is hot hot hot atm.
23:00:40 <dons> @tell gwern want to add pcre-light to http://haskell.org/haskellwiki/PCRE ?
23:00:40 <lambdabot> Consider it noted.
23:01:52 <ndm> dons: that Unix package upload is deeply scary
23:02:11 <thetallguy> SyntaxNinja: yes, like a segway.  Not for you, I know.
23:02:12 <dons> well, its definitely accidental. he's super enthusiastic.
23:02:17 <dons> but we need to lock that down
23:02:37 <dons> you should need to prove you're 'libraries@haskell.org' to update
23:02:58 <dons> ndm, we'll see what ross says
23:03:27 <ndm> dons: but at the moment i could unsafePerformIO and TH and root anyone who inadvertantly runs cabal-install
23:04:08 <dons> ndm, right. its getting to crunch time.
23:04:18 <dons> ndm, good thing we've a nice community.
23:04:38 <dons> good thing we don't have anonymous, online registration
23:04:56 <dons> the fact you need to contact ross is the only thing holding this back
23:05:30 <ndm> very true
23:10:46 <ndm> I am right in thinking that a `seq` a == a
23:10:54 <ndm> and that id $! x == x
23:11:02 <ndm> in terms of strictness and everything, right?
23:11:34 <ddarius> Yes.
23:12:16 <dons> yeah. canonical examples, in fact.
23:12:56 <ndm> yeah, thought so
23:13:02 <ndm> just checking before i blog it
23:13:09 <ndm> since i just saw another example of the first :)
23:13:22 <dons> ndm, let me see what ghc says.
23:17:36 <dons> f x = id $! x -- [Arity 1,  DmdType S]
23:18:01 <dons> f x = x -- [Arity 1, DmdType S]
23:18:44 * dmwit really doesn't understand seq/$!
23:19:15 * ndm will have a blog post on it in 5 mins
23:20:58 <dolio> id $! x should be the same as id x, too.
23:21:27 <ddarius> dmwit: What's not to understand?
23:21:58 <dmwit> Well, why should "f x = seq x x" be the same as "f x = x"?  Doesn't seq force the first constructor?
23:22:07 <dmwit> Yet "f x = x" doesn't seem to force the first constructor at all.
23:22:22 <ddarius> dmwit: So it's not seq you're confused about.
23:22:25 <dolio> seq x x says that when you want to evaluate x, evaluate x.
23:22:47 <dmwit> ddarius: Okay, I'll bite.  What am I confused about?
23:23:36 <ddarius> dmwit: evaluation == forcing
23:24:29 <newsham> anyone up for some agda questions?
23:24:50 <dolio> I'll answer if I can.
23:24:55 <ddarius> You are already demanding the result of 'f x' and thus 'x' by the time you start evaluating the body.
23:25:09 <ddarius> However, it's even easier to think of these things denotationally.
23:25:16 <newsham> dolio: ok on -blah?
23:25:22 <dmwit> Oh, hm.
23:25:24 <ddarius> seq undefined x = undefined
23:25:41 <ddarius> id undefined = undefined
23:25:46 <ddarius> id is already strict.
23:26:48 <ddarius> If you write seq x x either x is undefined in which case seq x x = undefined = x or x is defined in which case seq x x = x
23:28:36 <dmwit> Okay.
23:28:40 <dmwit> That makes perfect sense.
23:28:47 <dmwit> Thanks!
