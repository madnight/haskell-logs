00:00:10 <dons> fail is considered a wart. a committee decision
00:00:28 <slava> really?
00:01:35 <dons> yep. let's see, "fail is a wart,
00:01:35 <dons> not a design pattern"
00:01:50 <dons> "including fail in Monad is a wart, IMO"
00:01:58 <dons> "having fail in the Monad is a horrible wart."
00:02:15 <dons> "I personally consider 'fail' to be a wart,"
00:03:47 <red75> Heritage of IO, i suppose.
00:04:07 <dmwit> Heritage of monad comprehensions, I think.
00:04:24 <dmwit> It's what happens when pattern match in a "do" or list comprehension fails.
00:04:29 <dons> squooshing things together to make pattern matches fail
00:04:55 <slava> yeah, fail doesn't make sense with state for instance
00:05:04 <dons> yeah, very few have sensible notions of fail.
00:05:11 <slava> maybe, either, list?
00:05:14 <dons> so it ends up being 'error', which makes code dangerous
00:05:19 <dmwit> ?instances MonadPlus
00:05:20 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
00:05:26 <dons> > read "x" :: Int
00:05:28 <lambdabot>  Exception: Prelude.read: no parse
00:05:41 <dons> errors are bad for code that could be rock solid
00:05:55 <dmwit> slava: MonadPlus is closer to what ought to have happened.
00:05:59 <slava> yeah
00:06:14 <dons> yeah, [] has a sensible fail
00:06:16 <dmwit> hmm, IO is MonadPlus?
00:09:17 <red75> GHCi thinks otherwise.
00:09:42 <Lewk> Can someone help me out once again with some code please.  I think I know why it's wrong , I'm just lost as to what to do to fix it?
00:09:55 <Lewk> http://hpaste.org/7345#a0
00:10:10 <dons> what's the problem, Lewk ?
00:10:15 <dmwit> ?index mplus
00:10:15 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:10:32 <Lewk> I've been trying to do the dfs' function for the past 2 days
00:10:42 <dons> good idea not to use real tabs in the src, btw.
00:10:49 <dons> makes indening a bit fragile
00:11:05 <dmwit> Whoa, how did you notice tabs so quickly?
00:11:08 <dons> is your member function `elem`
00:11:17 <Lewk> elem?
00:11:22 <dons> dmwit: i clicked on 'raw' , saved it to vim, opened it up, all highlighted yellow :)
00:11:25 <dons> :t elem
00:11:26 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
00:11:30 <dons> > elem 'x' "haskell"
00:11:31 <lambdabot>  False
00:11:33 <dmwit> heh
00:11:34 <dons> ?src elem
00:11:34 <lambdabot> elem x    =  any (== x)
00:11:38 <dons> ?src any
00:11:39 <lambdabot> any p =  or . map p
00:11:45 <dons> oh, down the rabbit hole
00:11:48 <dons> ?src or
00:11:48 <lambdabot> or    =  foldr (||) False
00:11:53 <dons> ?src foldr
00:11:53 <lambdabot> foldr f z []     = z
00:11:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:11:57 <dons> ah there we are.
00:12:06 <dmwit> It's turtles all the way down.
00:12:11 <ivanm> dons: what, you don't want the source of map whilst you're at it as well? :p
00:12:18 <dons> ?src map
00:12:19 <lambdabot> map _ []     = []
00:12:19 <lambdabot> map f (x:xs) = f x : map f xs
00:12:23 <ivanm> heh
00:12:28 <dons> beautiful.
00:12:33 <Lewk> ok now I'm lost :o
00:12:47 <Lewk> were they all for me?
00:13:11 <dmwit> You may be confused about how function application's precedence works.
00:13:11 <dons> Lewk: oh, sorry. no. `elem` looks like your `member` function?
00:13:20 <dmwit> For example, this excerpt:
00:13:29 <dmwit> "push head(graph) stack"
00:13:48 <dmwit> That is equivalent to "push head graph stack", i.e. it calls "push" with three arguments.
00:13:53 <dons> hmm, yes.
00:14:04 <dmwit> I'm guessing by your spacing and parentheses that this is not what was intended. =P
00:14:08 <dons> locks like factor :)
00:14:10 <Lewk> no
00:14:19 <dmwit> push (head graph) stack
00:14:24 <Lewk> so push (head(graph)) stach
00:14:36 <Lewk> cool
00:14:38 <dmwit> Yup, that works too.
00:14:48 <dmwit> Although the parens around graph are redundant.
00:15:03 <Lewk> Does what I have so far make any sense?
00:15:14 <dmwit> Dunno, I haven't looked very carefully yet.
00:15:38 <red75> in the "otherwise" close you redefine dfs' function (let dfs'). you shouldn't
00:15:38 <Lewk> I'm lost as to how/where and when to pop, and add stuff to list
00:16:04 <dmwit> Actually, (head graph) doesn't make sense.
00:16:13 <dmwit> graph isn't a list, and head only operates on lists.
00:16:50 <sjanssen> > let head = id in head 10
00:16:51 <lambdabot>  10
00:16:56 <sjanssen> haha!
00:16:57 <Lewk> even though graph would be = g 1 and g 1 returns a list?
00:17:06 <dmwit> sjanssen: Hush! =P
00:17:38 <dmwit> Lewk: According to your type-signature, graph :: (a -> [a]).
00:17:43 <red75> graph will be g, not (g 1)
00:18:05 <dmwit> right
00:18:23 <Lewk> ah yep you're correct
00:18:36 <red75> so. you should make a list from it. like that: (graph none)
00:18:41 <red75> *node
00:20:06 <Lewk> red75: "otherwise" close you redefine dfs' function (let dfs') - what should I do here?
00:20:41 <Lewk> ok should I look at deleting everything after otherwise and start again?
00:20:56 <dmwit> I think you may want to just delete from the = after "otherwise" to the "if".
00:21:46 <dmwit> But yeah, you may want to start the "otherwise" clause again, since that doesn't look quite right.
00:22:10 <red75> Lewk: Your intention was to put visited nodes in stack?
00:22:23 <dmwit> (Since both the "then" and the "else" clause are basically identical, modulo errors. =)
00:22:26 <red75> *Was your intention
00:24:09 <Lewk> The main thing I want to do is make the list to contain the order in which I traversed
00:24:49 <Lewk> So just use the stack as you normally do in a dfsearch
00:24:57 <dmwit> :t (>>=) :: [a] -> (a -> [a]) -> [a]
00:25:00 <lambdabot> forall a. [a] -> (a -> [a]) -> [a]
00:25:25 <dmwit> (>>=) on lists is basically DFS. ;-)
00:26:16 <dmwit> But let's ignore that for now.
00:26:56 <Lewk> ok
00:27:51 <red75> well, i didn't quite understand the meaning of list parameter in dfs'...
00:28:08 <Lewk> I "think" this is what I'm trying to do... http://hpaste.org/7346#a0
00:28:54 <Lewk> list should just contain the places I visited in the correct order
00:29:24 <Lewk> I think it should be [7,5,6,3...]
00:31:20 <Lewk> Is it ok to post links to homework questions?
00:31:47 <Lewk> I don't know if I'm doing a good job of explaining my intentions
00:33:11 <red75> Well. First. You should maintain list of visited nodes. Right?
00:33:59 <Lewk> yep
00:35:10 <Lewk> So I need a list of visited nodes which will be list
00:35:11 <red75> So, you must pass it as a parameter into dfsearch. As there's no such thing as mutable variable in Haskell.
00:37:23 <Lewk> Sorry, I'm just looking over it now to see what you mean :)
00:39:59 <red75> You cannot do "let stack=push val stack", well you can, but it will be not what you want.
00:43:21 <red75> Uhm. This things are hard to formulate... (given my english isn't fluent).
00:44:09 <takamura> hi
00:44:16 <red75> hi
00:44:16 <dmwit> Hiya, takamura!
00:44:18 <Lewk> You're English seems fine to me :)
00:44:23 <Lewk> your
00:44:24 <takamura> hey! :)
00:44:26 <Lewk> hehe
00:45:07 <red75> But it takes much time to make it err... readable.
00:45:31 <Lewk> Haha it can't be worse than my Haskell code
00:46:03 <Lewk> Would it be cheating to let me know what functions to use?
00:46:20 <Lewk> This assignment is making my head explode
00:46:33 <dmwit> Well, you're doing list operations.
00:46:42 <dmwit> So, foldr and nub seem nice.
00:46:43 <red75> It seems to me, that it's not functions you need, but understanding of nature of functional programming.
00:46:49 <dmwit> map is always good.
00:47:39 <Lewk> foldr to pop all or push all on/off the stack ?
00:48:30 <Lewk> nub takes only one instance of each thing in a list right?
00:48:58 <Lewk> I think red might be right
00:50:30 <slava> dons: this is a good exercise
00:50:33 <dmwit> To get good at handstands, you have to do them a lot.
00:50:45 <red75> Ok. Using stack you are triyng to implement iterative algothm.
00:50:55 <red75> *trying
00:50:59 <Lewk> yep
00:51:05 <Lewk> Is that not correct
00:51:29 <red75> But it's not natural for functional programming. It is based on recursion.
00:52:04 <Lewk> Ok, that makes sense and that's what we've learnt in class
00:52:24 <GrayShade> any tips on how to debug memory leaks in haskell?
00:52:58 <Lewk> I just don't know how to do it otherwise...
00:54:25 <maltem> GrayShade, if you manage to run the program so that it terminates, use profiling to find the guilty functions
00:54:43 <Lewk> and we were given: dfs' (push node emptyStack) [] so I have to use stacks
00:55:08 <red75> oh
00:55:12 <GrayShade> maltem: i think i did that, but i don't know what to do after
00:56:00 <maltem> GrayShade, did you make out some particular function(s) to debug?
00:56:15 <GrayShade> yes
00:56:20 <maltem> A memory leak usually means that some function, or some data structure, is too lazy, or too strict
00:57:37 <GrayShade> i tried adding some strictness adnotations, but iti didn't help too much
00:57:45 <GrayShade> it*
00:58:07 <GrayShade> (annotations*)
00:58:27 <maltem> Well it's hard to give advice in general, not knowing anything about your code
00:58:28 <Lewk> I'll give it another go and report back :)
00:59:51 <GrayShade> it's another sad lisp dialect interpreter
01:01:51 <maltem> GrayShade, well, what does the function do, and what data structure is allocated too much?
01:03:43 <GrayShade> maltem: it's the core of the interpreter; half of the memomry it allocates is for argument evaluations
01:04:43 <GrayShade> i get something like http://monoport.com/10471 , which doesn't look too good
01:04:45 <lambdabot> Title: mono pastebin
01:07:10 <quicksilver> GrayShade: not to sound too stupid, but how do you know it's a leak, rather than just high memory usage?
01:07:18 <quicksilver> GrayShade: and are you compiling with -O ?
01:07:30 <GrayShade> i'm compiling with -O2
01:08:04 <quicksilver> the most common generic cause of a leak is retaining a reference to a large structure which you really want ot be GCed as you go along
01:12:24 <GrayShade> http://79.117.189.152/prof.png -- does this mean that it's too strict?
01:13:48 <maltem> possibly...
01:14:07 <cpoucet> GrayShade: that s impossible to tell without knowledge of the application
01:14:32 <cpoucet> GrayShade: You're basically asking whether data should be alive or dead, only algorithmical knowledge can shed light on that
01:15:33 <quicksilver> another common generic cause of memory leaks is building a very large thunk which you never use.
01:15:49 <quicksilver> (that's the one that strictness can help with. strictness doesn't make any difference to the first type)
01:17:16 <GrayShade> adding seqs reduced the allocations in my case by less than 100 kb (from about 6 gb), so it didn't help
01:19:33 <maltem> GrayShade, well, see cpoucet
01:21:04 <GrayShade> what would introduce strictness besides seqs and ...running in the IO monad?
01:21:38 <ibid> pattern matching
01:21:42 <bd_> @hoogle Control.Exception.evaluate
01:21:43 <lambdabot> No matches, try a more general search
01:21:45 <bd_> hmm
01:22:07 <bd_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#7 It's there all right
01:22:09 <lambdabot> http://tinyurl.com/sqmlj
01:22:29 <bd_> anyway, GrayShade, that function is the most direct way to do so
01:23:00 <GrayShade> but i don't use it
01:23:41 <bd_> also, is it me or does the 'correct definition' in that doc assume that >>= is non-strict in IO?
01:24:06 <bd_> where a better definition would be: evaluate x = (return ()) >>= (\_ -> return $! x)
01:25:42 <slava> dons: i implemented identity, maybe, either, state, and list
01:25:45 <slava> and do notation
01:25:47 <slava> i think that's enough :)
01:25:51 <cpoucet> slava: in factor?
01:25:55 <slava> yes
01:26:24 <cpoucet> slava: add reader
01:26:26 <maltem> bd_, your definition is, since return () has no effect, equivalent to return $! x
01:26:37 <GrayShade> maltem: it's just that i don't know what i could write in some other way to write my code in order to solve that
01:26:48 <cpoucet> slava: reader could be very useful, a lot less 'dup' ing
01:27:03 <maltem> GrayShade, it's impossible to give advice if you do not tell us what is your code
01:27:52 <slava> cpoucet: i'm not sure any of these are useful :)
01:28:01 <GrayShade> maltem: something in the lines of http://hpaste.org/7347
01:28:26 <cpoucet> slava: potay-toe, potah-toe
01:28:50 <slava> good to have this in case i want to use them though
01:28:51 <cpoucet> slava: useful or not, reader will be equally 'useful'
01:28:56 <slava> yeah
01:28:57 <lament> PTT
01:29:34 <bd_> maltem: no, if >>= is strict in IO, shouldn't the result be non-strict?
01:29:35 <cpoucet> @src (>>=) Reader
01:29:35 <lambdabot> Source not found. stty: unknown mode: doofus
01:30:17 <cpoucet> bd_: why not simply "evaluate x = return $! x"
01:30:31 <bd_> cpoucet: read the docs for Control.Exception.evaluate :)
01:30:47 <bd_> (linked above)
01:30:49 <red75> @src Reader (>>=)
01:30:49 <lambdabot> Source not found. I feel much better now.
01:30:50 <maltem> bd_, in ghci, try return undefined >> return 2 :: IO Int
01:32:09 <bd_> maltem: yes...? The question is, is (undefined >> return 2) `seq` return 2 the bottom, and if not, what guarentees that?
01:32:28 <cpoucet> bd_: no it's not
01:32:33 <cpoucet> undefined is never evaluated
01:32:35 <cpoucet> thanks to >>
01:32:45 <cpoucet> oh wait, undefined, not 'return undefined'
01:32:46 <bd_> cpoucet: (undefined >> return 2) is the bottom
01:32:52 <cpoucet> bd_: read too fast
01:33:09 <bd_> cpoucet: (undefined >> return 2) `seq` return 2  is not the bottom... in GHC 6.8. Will it be that way in GHC 7.4?
01:33:27 <cpoucet> bd_: I find that seq think rather ... poorly specified
01:33:32 <cpoucet> s/think/thing
01:33:50 <bd_> cpoucet: it's simple: (bottom) `seq` _ = (bottom); (non-bottom) `seq` x = x
01:34:09 <cpoucet> bd_: I meant the one in the evaluate docs
01:34:11 <bd_> my question is: is >> strict on its arguments?
01:34:13 <quicksilver> bd_: that varies from monad to monad
01:34:23 <bd_> quicksilver: in IO
01:34:37 <quicksilver> in io it is not
01:34:40 <bd_> if the answer is 'implementation-defined' then Control.Exception's sample implementation is flawed
01:34:58 <maltem> argh, bd_'s example is trickier than it looks
01:35:00 <bd_> while in GHC it's not, is this assured by some documentation somewhere?
01:35:23 <quicksilver> don't think so
01:35:38 <quicksilver> i'm not aware of docs specifying >> in IO
01:35:45 <bd_> quicksilver: >>= then
01:35:50 <slava> the reader monad reminds me of dynamic scope
01:35:50 <quicksilver> to this degree.
01:35:58 <bd_> is >>= in IO guarenteed to be non-strict on its first argument?
01:36:08 <bd_> and if not, how does one implement evaluate?
01:36:23 <bd_> my instinct is you'd need to do something like: getArgs >> (return $! x)
01:36:36 <bd_> however! if getArgs is inlinable and implemented as return (something)
01:36:51 <bd_> then the monad laws require return x >>= \_ -> k === k
01:37:07 <bd_> so we'd need the IO equivalent of a memory barrier :)
01:38:01 <bd_> hmm, evaluate x = newIORef x >>= join . readIORef
01:38:04 <dalien> time to go.. ttyl
01:38:04 <bd_> is safe, I think
01:38:18 <bd_> er, correction
01:38:29 <bd_> evaluate x = newIORef (return $! x) >>= join . readIORef
01:38:49 <bd_> each side of >>= is guarenteed to be non-bottom then
01:38:51 <quicksilver> you don't need to care about strictness of >>= to define evaluate
01:39:04 <bd_> quicksilver: you do, because evaluate undefined is not itself the bottom
01:39:22 <bd_> iow, evaluate undefined `seq` return () <-- does not exception
01:39:47 <bd_> and if >>= is strict in its first argument, then the example in the haddock for evaluate is wrong
01:40:28 <cpoucet> bd_: erm
01:40:31 <cpoucet> bd_: you're missing a big point
01:40:35 <bd_> cpoucet: what's that?
01:40:43 <cpoucet> evaluate undefined === return undefined >>= ...
01:40:47 <cpoucet> not plain 'undefined'...
01:40:59 <bd_> what?
01:41:02 <cpoucet> evaluate :: a -> IO a
01:41:11 <bd_> the docs prodide a series of laws for evaluate
01:41:14 <bd_> and a sample implementation
01:41:17 <cpoucet> bd_: yes
01:41:21 <cpoucet> and t 'returns' its argument
01:41:25 <bd_> I argue that if >>= is strict on its first argument, the sample implementation is incorrec
01:41:25 <cpoucet> look at the type sig
01:41:28 <bd_> oh
01:41:29 <cpoucet> a ->  IO a
01:41:30 <bd_> t
01:41:34 <bd_> er
01:41:36 <bd_> what's your point?
01:41:42 <cpoucet> and return undefined >> whatever
01:41:45 <cpoucet> is not bottom
01:42:02 <bd_> no
01:42:03 <bd_> but
01:42:19 <bd_> return (anything) >>= (\_ -> return $! undefined)
01:42:24 <bd_> according to the monad laws
01:42:26 <bd_> is the same as
01:42:28 <bd_> return $! undefined
01:42:32 <cpoucet> right
01:42:33 <bd_> which is the bottom
01:42:52 <bd_> note that GHC's IO is flawed in that this law does not hold
01:43:01 <bd_> I consider this a bug that's unlikely to get fixed ;)
01:43:14 <bd_> in any case...
01:43:19 <bd_> if >>= is strict on its LHS
01:43:20 <cpoucet> ok
01:43:29 <bd_> then evaluate undefined = (bottom) >>= return   === (bottom)
01:43:31 <jsnx> is this a bug?
01:43:32 <jsnx> http://hpaste.org/7348
01:43:56 <cpoucet> bd_: I thought yu were argument hinged on the "undefined >>> bit"
01:44:01 <jsnx> if shorty0 is valid, why isn't short1 ?
01:44:03 <cpoucet> instead of return undefined
01:44:04 <bd_> jsnx: your code needs to be indented above the level of 'then'
01:44:15 <bd_> which in turn needs to be indented above the' if'
01:44:18 <jsnx> bd_: oic
01:44:30 <bd_> move 'then' to the next line and put 'else' at the same level (at least one space beyond where else is now)
01:44:39 <jsnx> bd_: but that is not required in general...
01:44:51 <jsnx> bd_: only for do-notation?
01:44:52 <bd_> cpoucet: well, 'return () >> undefined' ought to be the bottom by the monad laws
01:45:11 <cpoucet> yep
01:45:26 <bd_> jsnx: hmmm, I think the layout  starts with if, and then/else make sub-layouts or something
01:45:53 <bd_> cpoucet: (it isn't, in GHC, which is a bug :P)
01:45:56 <bd_> but i digress
01:46:02 <bd_> maybe i'll post to haskell-cafe or something
01:46:07 <maltem_> wait... from evaluate's specification, is it possible to say that evaluate is like (return $!), only that evaluate is non-strict?
01:46:18 <bd_> maltem_: essentially
01:46:24 <maltem_> right, thanks
01:46:32 <cpoucet> ePrelude> return () >> undefined
01:46:32 <cpoucet> *** Exception: Prelude.undefined
01:46:45 <bd_> cpoucet: (return () >> undefined) `seq` return ()
01:46:49 <bd_> with appropriate :: IO ()
01:47:14 <cpoucet> bd_: no bottom
01:47:26 <bd_> cpoucet: right
01:47:42 <bd_> whereas the monad laws say: (something) >>= \_ -> undefined === undefined
01:48:17 <jsnx> bd_: well, that works
01:48:39 <cpoucet> bd_: ah I see now, indeed, that is rather odd
01:48:48 <jsnx> but generally speaking, i don't have to do it
01:48:59 <bd_> cpoucet: ironically, making >>= strict fixes this :)
01:49:21 <cpoucet> @src IO  >>=
01:49:22 <lambdabot> Source not found. I am sorry.
01:49:26 <cpoucet> @src IO (>>=)
01:49:27 <lambdabot> m >>= k     = bindIO m k
01:49:32 <bd_> @src bindIO
01:49:32 <cpoucet> @src bindIO
01:49:33 <lambdabot> bindIO (IO m) k = IO ( \ s ->
01:49:33 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
01:49:33 <lambdabot> bindIO (IO m) k = IO ( \ s ->
01:49:33 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
01:49:38 <maltem_> bd_, does that mean that (return () >> undefined) is not bottom in ghc, or does this mean that seq is flawed in ghc?
01:49:48 <bd_> maltem_: the former
01:49:56 <cpoucet> Anywho, time to get some useful work done
01:49:57 <cpoucet> cheers
01:50:07 <maltem_> so I agree that this is really stupid
01:50:36 <bd_> easy solution: add strictures to bindIO
01:50:46 <bd_> now watch as Control.Exception.evaluate breaks :)
01:51:04 <bd_> or well, the way it's implemented it won't
01:51:10 <bd_> but the 'correct definition' is not correct
01:51:17 <bd_> @src evaluate
01:51:17 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
01:51:56 <slava> i don't understand this
01:51:58 <slava> (Reader r) >>= f = Reader $ \e -> f (r e) e
01:52:11 <cpoucet> slava: ok
01:52:15 <slava> if f has type (t -> Reader b), how can we do  f (r e) e
01:52:22 <slava> f (r e) has type Reader b
01:52:22 <cpoucet> that's easy
01:52:26 <cpoucet> right
01:52:49 <cpoucet> @src Reader
01:52:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
01:52:51 <slava> i'd understand it if there was a runReader in there :)
01:52:53 <slava> is it implicit?
01:52:56 <slava> or is this a typo in the guide i'm reading?
01:53:05 <cpoucet> slava: afaik there is no 'Reader'
01:53:11 <bd_> slava: the (Reader r) would be your runReader
01:53:13 <slava> http://www.haskell.org/all_about_monads/html/readermonad.html
01:53:14 <lambdabot> Title: The Reader monad
01:53:32 <bd_> slava: and this is more like ReaderT without the T, I guess. The real Reader monad has no newtype
01:53:38 <cpoucet> indeed
01:53:43 <bd_> but basically, runReader would be:  runReader (reader r) = r
01:53:49 <slava> k
01:54:17 <cpoucet> slava: they probably did this to keep it cleaner than having
01:54:24 <cpoucet> instance Reader ((->) a) ...
01:55:01 <cpoucet> actually, it's not even that, since it should supply the second argument to the (->)
01:55:17 <cpoucet> @src Control.Monad.Reader
01:55:18 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:55:22 <cpoucet> @index Control.Monad.Reader
01:55:23 <lambdabot> bzzt
01:55:27 <slava> @src local
01:55:27 <lambdabot> Source not found. :(
01:55:30 <cpoucet> @source Control.Monad.Reader
01:55:31 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
01:56:00 <slava> i don't understand what local does
01:56:20 <quicksilver> allows you to run a subaction with a different environment
01:56:30 <cpoucet> slava: local basically allows you to specifiy a new value for your input
01:57:47 <cpoucet> :t local
01:57:49 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
01:58:18 <cpoucet> most typically, if you're doing binding in a lexically scoped language, and you're writing that in haskell
01:58:22 <cpoucet> you cna do something like
01:58:39 <cpoucet> case (LetStatement bindings  expression) = local (updateEnvironmentWith binings) expression
01:58:55 <quicksilver> jsnx, bd_: "if" is not a layout construct. But the do is.
01:59:10 <quicksilver> bd_: I had to go off for a bit, but I'm interested in your comments about evaluate.
01:59:15 <maltem_> bd_, I'm a little slow, but I don't yet see why we would want (>>=) to be strict on its LHS
01:59:36 <quicksilver> bd_: as far as the monad laws go, I believe it is understood that the === in (return () >> k) === k is something weaker than seq-equivalence.
01:59:44 <bd_> maltem_: I'm not saying it should be - I'm just saying since when have we defined it to be strict?
01:59:58 <quicksilver> bd_: it is "observational equivalence over the monad"
02:00:08 <quicksilver> meaning that the two actions carry out the same effects and return the same value.
02:00:14 <bd_> I see.
02:00:18 <quicksilver> slighltly weaker than true seq-equivalance.
02:00:40 <quicksilver> it's just about impossible to write monad instances for all the interesting monads if you have to respect the laws up to true seq-equivalence.
02:01:01 <maltem_> hmm
02:02:14 <bd_> quicksilver: Could not rewrite rules result in the undefined leaking out from time to time?
02:02:19 <quicksilver> now evalute has nothing to do with strictness.
02:02:20 <bd_> and/or inlining
02:02:32 <quicksilver> bd_: (yes. they could. but no one uses the monad laws as rewrite rules)
02:03:10 <bd_> quicksilver: true, but is it absolutely guarenteed that (something >> undefined) is not undefined?
02:03:14 <quicksilver> don't think inlining is a problem
02:03:18 <bd_> or (undefined >> something) for that matter
02:03:19 <quicksilver> bd_: no, it's not guaranteed.
02:03:25 <quicksilver> it's just not guaranteed that it is, either.
02:03:33 <quicksilver> it's up to the monad instance, AFAIK.
02:03:33 <bd_> quicksilver: then evaluate's "correct definition" is not correct
02:03:39 <bd_> quicksilver: I mean, in IO specifically.
02:03:40 <maltem_> bd_, I mean, I understand your argument about the "correct" definition failing if (>>=) was strict on its LHS, but I don't see the motivation for the hypothesis about (>>=) being strict on its LHS
02:03:52 <quicksilver> bd_: evaluate x = (return $! x) >>= return
02:03:57 <quicksilver> is not correct why?
02:04:16 <bd_> quicksilver: if >>= is strict on its first argument, then (evaluate undefined) `seq` return () would be undefined
02:04:26 <bd_> and as far as I can tell, there's nothing which guarentees that >>= is lazy
02:04:37 <quicksilver> why is that a problem?
02:05:16 <bd_> quicksilver: because the first law listed in evaluate's definition requires that (evaluate undefined) not be undefined
02:05:35 <bd_> just because the implementation /just happens/ to work right now
02:05:42 <bd_> does not mean we should allow the definition to be /wrong/
02:06:24 * quicksilver nods
02:06:37 <quicksilver> well it jsut means that the definition needs a caveat that >>= not be left-strict.
02:06:47 <quicksilver> which is a pretty reasonable assumption.
02:07:04 <bd_> or to use a definition which works in the face of seq-equivalence and fully strict >>=
02:07:22 <quicksilver> I don't see any reason to imagine >>= be left-strict in IO.
02:07:41 <bd_> the behavior of (undefined >>= f) is the same as (undefined) in IO
02:07:54 <quicksilver> ah yes
02:07:58 <bd_> therefore, it's reasonable to think that an optimizer might decide to make them equivalent
02:07:59 <quicksilver> but that doesn't make >>= left strict
02:08:11 <bd_> after all, the monad laws allow such an optimization
02:08:45 <RayNbow> say... is the bottom value being a pain in the ass? :p
02:08:52 <bd_> RayNbow: yep :)
02:08:58 <cpoucet> quicksilver: why would >>= not be left strict?
02:08:59 <bd_> horrid thing, isn't it?
02:09:07 <cpoucet> quicksilver: the archetypical monad (state) is left-strict
02:09:28 <cpoucet> usually you destructure your monad-constructor, get the arguments out
02:09:32 <cpoucet> and pass to the function on the right
02:09:39 <bd_> > (undefined >> return () :: State () ()) `seq` ()
02:09:40 <quicksilver> > (undefined >>= return 1) :: State Integer Integer
02:09:40 <lambdabot>  ()
02:09:41 <lambdabot>        add an instance declaration for (Num (State Integer Integer))
02:09:55 <quicksilver> > (undefined >>= \x -> return 1) :: State Integer Integer
02:09:56 <lambdabot>        add an instance declaration for (Show (State Integer Integer))
02:10:06 <bd_> @src (>>=) State
02:10:07 <lambdabot> Source not found. The more you drive -- the dumber you get.
02:10:10 <cpoucet> > evalState (undefined >>= \x -> return 1)
02:10:12 <lambdabot>  Add a type signature
02:10:16 <quicksilver> cpoucet: I'm not sure it is.
02:10:16 <cpoucet> > evalState (undefined >>= \x -> return 1) :: Integer
02:10:18 <lambdabot>  Couldn't match expected type `Integer'
02:10:23 <quicksilver> evalState proves nothing.
02:10:25 <cpoucet> > execState (undefined >>= \x -> return 1) :: Integer
02:10:26 <lambdabot>  Couldn't match expected type `Integer'
02:10:29 <cpoucet> bah
02:10:31 <quicksilver> of course if you evalutate you will get undefined.
02:10:32 <cpoucet> :t execState
02:10:34 <lambdabot> forall s a. State s a -> s -> s
02:10:37 <quicksilver> but we're not evaluating it.
02:10:41 <bd_> > (undefined >> return () :: State () ()) `seq` ()
02:10:43 <lambdabot>  ()
02:10:48 <quicksilver> right.
02:10:48 <bd_> ^^^ there's your answer for this specific case
02:10:52 <quicksilver> bd_++
02:10:52 <cpoucet> quicksilver: exactly, that says nothing about the strictness of the function in question
02:10:55 <cpoucet> no
02:10:59 <bd_> but again, this is all implementation-defined stuff
02:11:04 <bd_> the theory says it should be undefined
02:11:07 <cpoucet> >>= is left-strict
02:11:08 <quicksilver> > ((undefined >>= \x -> return 1) :: State Integer Integer) `seq` ()
02:11:09 <lambdabot>  ()
02:11:09 <bd_> so we're already cutting corners
02:11:11 <cpoucet> you're just not consuming the >>=
02:11:13 <quicksilver> cpoucet: no, it's not.
02:11:19 <bd_> it's perfectly sane for some optimization to allow this strictness to come back
02:11:26 <quicksilver> cpoucet: if it was left-strict then it would be undefined.
02:11:31 <cpoucet> no it wouldn't
02:11:32 <quicksilver> cpoucet: and then that example woudl be undefined
02:11:37 <cpoucet> err
02:11:40 <quicksilver> that's what left-strict means!
02:11:42 <cpoucet> ok, start from scratch
02:11:43 <cpoucet> do you agree
02:11:48 <cpoucet> undefined >>= foo == undefined ?
02:11:49 <quicksilver> (undefined >>= f) is not undefined.
02:12:01 <quicksilver> cpoucet: depends what you mean by undefined.
02:12:15 <quicksilver> that constructs a monadic action which can't possibly be executed without producing _|_
02:12:21 <quicksilver> however, it is not itself undefined.
02:12:27 <quicksilver> it's (State _|_)
02:12:29 <quicksilver> not _|_
02:12:35 <cpoucet> t's not State _|_
02:12:43 <quicksilver> well that's psuedo syntax
02:12:53 <quicksilver> but what I mean to show is that there is a constructor in the way.
02:12:53 <cpoucet> my point is, the undefined is not inside the State
02:12:55 <bd_> cpoucet: you have undefined in a box. Is the box itself undefined?
02:13:03 <quicksilver> it is no more undefined than "Just undefined"
02:13:04 <quicksilver> i.e. it is not.
02:13:09 * cpoucet ponders
02:13:12 <cpoucet> @src (>>=)
02:13:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
02:13:17 <cpoucet> @src Sate (>>=)
02:13:18 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:13:20 <cpoucet> @src State (>>=)
02:13:20 <lambdabot> Source not found. Are you on drugs?
02:13:20 <quicksilver> bd_: which theory says it should be undefined.
02:13:23 <bd_> @src (>>=) State
02:13:24 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
02:13:29 <bd_> lambdabot--
02:13:34 <quicksilver> bd_: none of the monad lawas I can see give a reduction for (undefined >>= f)
02:13:44 <Deewiant> @src State
02:13:44 <lambdabot> Source not found. My pet ferret can type better than you!
02:13:52 <bd_> quicksilver: right. It's left open. Now, the next problem (which is where I bring up monad laws)
02:13:56 <bd_> is if you try:
02:13:59 <bd_>     evaluate x = (return x) >>= (return $!)
02:14:01 <cpoucet> @src State Monad
02:14:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:14:07 <cpoucet> @src Monad State
02:14:08 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:14:10 <cpoucet> bah
02:14:18 <bd_> If the left-identity monad law applies exactly
02:14:21 <bd_> then this becomes return $! x
02:14:32 <cpoucet> @source Control.Monad.State
02:14:33 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
02:14:38 <quicksilver> bd_: and this is where I tell you that the monad laws only apply up to monadic observational equivalnce not true equivalance :P
02:15:02 <bd_> quicksilver: quite - but! What law states that IO /must not/ follow the monadic laws exactly?
02:15:09 <quicksilver> none.
02:15:13 <bd_> Exactly! :)
02:15:24 <bd_> and this is where we need a better implementation of evaluate in the docs
02:15:25 <quicksilver> which is why I *agree* with you that the defintion for evluate given in the docs needs a caveat
02:15:26 <cpoucet> quicksilver: ah, I see now :)
02:15:29 <bd_> okay :)
02:15:38 <quicksilver> (caveat that >>= should not be left-strict in IO)
02:15:39 <quicksilver> however.
02:15:41 <bd_> or a fixed implementation, which IMO is more interesting
02:15:53 <quicksilver> I personally argue that >>= woudl not be expected to be left-strict in IO
02:16:11 <quicksilver> so it's not a surprising assumption.
02:16:11 <bd_> because if we have true seq-equivalence in the left identity, and >>= is strict on both arguments, is it possible to implement evaluate using the functions given in the report?
02:16:14 <quicksilver> it should be documented.
02:16:34 <bd_> and if not, how far off the beaten path must one go?
02:17:07 <maltem_> bd_, is it ok if I perceive your argument just as: (return $! x) >>= return  ===  return $! x, according to right identity, so the "correct" definition relies on IO not following the monad laws?
02:17:23 <bd_> maltem_: no, there are two seperate issues :)
02:17:29 <quicksilver> maltem_: no. it doesn't rely on IO not following the laws.
02:17:32 <bd_> the monad laws say nothing about (return $! x)
02:17:40 <quicksilver> maltem_: it relies on IO not being left-strict in >>=
02:17:44 <quicksilver> which is not specified.
02:17:51 <quicksilver> but not, in my opinion, surprising, either
02:17:54 * bd_ summarizes all this on a mail to -cafe
02:17:58 <quicksilver> good idea.
02:18:05 <maltem_> ah, very good idea :)
02:18:25 <quicksilver> personally I'd be pretty surprised if (f >>= g >>= h >>= i) was strict in any way
02:18:34 <bd_> hmm, is PGP-signed mail acceptable on -cafe?
02:18:34 <quicksilver> I imagine than an IO action constructed but never used
02:18:35 * maltem_ wants to understand this without keeping asking questions
02:18:43 <quicksilver> is not likely to be a problem
02:18:48 <bd_> k
02:18:56 <bd_> quicksilver: also, Identity monad with each intermediate function being strict
02:19:00 <quicksilver> I suppose I imagine any implementation of IO to have a constructor interposing.
02:19:12 <quicksilver> so at worst it's (IO _|_)
02:19:14 <quicksilver> but never _|_
02:19:25 <bd_> quicksilver: in GHC, IO's a newtype
02:19:30 <quicksilver> that's only my picture of possible IO implementations though.
02:19:37 <quicksilver> bd_: true, but fortunatel it's also a function :)
02:19:43 <quicksilver> bd_: so that's OK as well.
02:19:43 <bd_> however bindIO interposes a new anonymous function, yes :)
02:19:57 <bd_> post made
02:20:04 * bd_ goes to sleep, being 5:20am and all :)
02:20:34 <RayNbow> g'night :)
02:20:35 <slava> ok, reader and writer monads done
02:21:51 <RayNbow> > generate 1 stdgen (undefined >> return 3)
02:21:52 <lambdabot>   Not in scope: `stdgen'
02:21:56 <RayNbow> oh wait
02:22:40 <RayNbow> > generate 1 (mkStdGen 1) (undefined >> return 3)
02:22:41 <lambdabot>  3
02:23:30 <slava> cpoucet, dons: http://paste.factorcode.org/responder/pastebin/show-paste?n=512
02:26:22 <slava> @src liftM2
02:26:22 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:26:23 <bd_> It occurs to me that it'll be possible to implement monads in C++0x. I'm not sure if I should consider this a good thing
02:27:01 <Deewiant> what makes it impossible in current C++?
02:27:36 <ziman> @pl \x y -> f (g x y)
02:27:36 <lambdabot> (f .) . g
02:27:40 <bd_> Deewiant: lambdas are really inconvenient :)
02:27:45 <Deewiant> sure
02:27:50 <Deewiant> but it's still /possible/ :-P
02:27:55 <bd_> bah :P
02:28:56 * bd_ snickers at 'constexpr'
02:30:03 <slava> @src ap
02:30:03 <lambdabot> ap = liftM2 id
02:30:28 <slava> :t ap
02:30:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
02:42:23 <lilac> http://hpaste.org/7349 <-- a monad with a non-strict >>=
02:43:19 <sjanssen> how do we define non-strict >>=?
02:43:40 <sjanssen> _|_ >>= _|_ does not yield _|_?
02:44:49 <lilac> sjanssen: it's more than that. in this case, _|_ >>= f does not yield _|_, and m a >>= _|_ does not yeild _|_
02:45:42 <sjanssen> > ((undefined :: a -> b) >>= (undefined :: b -> a -> c)) `seq` ()
02:45:43 <lambdabot>  ()
02:45:44 <lilac> sjanssen: eg, g :: NullMonad () yields NullMonad
02:46:34 <moozilla> hello
02:47:06 <sjanssen> lilac: it is also pretty useless :)
02:47:34 <moozilla> can someone help me out
02:47:49 <moozilla> i have
02:47:49 <moozilla> main = do contents <- readFile fname
02:48:02 <moozilla> how would i use string operations on that
02:48:09 <ohub> :t readFile
02:48:11 <lambdabot> FilePath -> IO String
02:48:45 <sjanssen> main = do contents <- readFile fname; putStrLn ("hello" ++ contents)
02:48:49 <lilac> sjanssen: yes; any monad m which wants return x to carry around the value of x must unpack something when doing >>=. so is non-strict.
02:49:37 <lilac> sjanssen: although it depends what you mean by 'doing' i guess
02:49:47 <Heffalump> lilac: huh? What if the thing it packs it in is a strict datatype?
02:50:03 <lilac> Heffalump: s/non-strict/strict/
02:50:20 <sjanssen> lilac: the statement is false for either "strict" or "non-strict"
02:50:27 <sjanssen> lilac: see my example above
02:50:36 <moozilla> sjanssen: how would i use the lines function on contents
02:50:56 <sjanssen> moozilla: main = do contents <- readFile fname; print (lines contents)
02:51:18 <moozilla> :t print
02:51:19 <lambdabot> forall a. (Show a) => a -> IO ()
02:51:47 <sjanssen> > ((undefined :: a -> b) >>= (undefined :: b -> a -> c)) `seq` ()
02:51:48 <lambdabot>  ()
02:52:56 <moozilla> sjanssen how can i do something with line contents instead of printing it
02:53:23 <sjanssen> moozilla: like what?
02:53:34 <moozilla> do string ops on each line
02:54:03 <sjanssen> you can use "map somefunction (lines contents)", for example
02:54:44 <moozilla> i see
02:54:48 <lilac> sjanssen: i concede the point.
02:56:28 * mux watches "cabal upgrade" updating his haskell packages automatically
02:56:51 <thoht> :t map last (map (take 1) ["mux","and","the","irreal","nico"])
02:56:53 <lambdabot> [Char]
02:57:52 <thoht> > map last (map (take 1) ["mux","and","the","irreal","nico"])
02:57:54 <lambdabot>  "matin"
02:57:55 <lilac> "n"
02:57:55 <moozilla> sjanssen: this doesnt work: main = do contents <- readFile fname; map putStrLn (lines contents)
02:58:08 <sjanssen> moozilla: you want mapM_ there
02:58:21 <moozilla> mapM_?
02:58:27 <sjanssen> moozilla: map is for pure functions, mapM is for monadic functions
02:58:38 <moozilla> whats the _ for?
02:59:03 <Deewiant> @ty mapM
02:59:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
02:59:06 <Plareplane> it might be easier to ask him what operations he wants to do exactly and explain how to do them
02:59:06 <Deewiant> @ty mapM_
02:59:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
02:59:09 <sjanssen> moozilla: _ in the usual naming scheme means throw away the result
02:59:19 <moozilla> oh ok
02:59:41 <sjanssen> moozilla: mapM_ is like the for loop of Haskell, in some ways
02:59:46 <moozilla> it works with mapM
03:00:18 <sjanssen> right, both will work here
03:00:50 <sjanssen> it is just better to use mapM_ if you don't care about the value of the result (and putStrLn doesn't yield any useful value)
03:05:58 <maltem_> mux, on that matter, it seems there hasn't been a cabal-install release since 2006?
03:07:07 <mux> maltem_: the version on hackage is way old indeed, I guess that's because latest versions require a development version of Cabal
03:07:35 <maltem_> ah ok
03:08:01 <moozilla> sjanssen: how would I use map words to line contents
03:09:32 <moozilla> nvm
03:25:16 <lilac> can someone help me? i'm trying to write a simplified C++ parser in parsec, but i'm having a lot of trouble getting tokenization to work
03:25:26 <moozilla> > filter (ishead 1) [[1,2],[1],[3,4]] where ishead x y = (head x) == y
03:25:26 <lambdabot>  Parse error at "where" (column 37)
03:26:03 <moozilla> > filter ((head x) == 1) [[1,2],[1],[3,4]]
03:26:03 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
03:27:34 <moozilla> can someone help me with that
03:28:15 <xerox> > filter (\x -> head x == 1) [[1,2],[1],[3,4]]
03:28:16 <lambdabot>  [[1,2],[1]]
03:30:30 <lilac> how can I write a parsec parser that ignores all instances of "\\\n"?
03:38:50 <xerox> lilac: this might be helpful? http://research.microsoft.com/users/daan/download/parsec/parsec.html#ParsecLanguage
03:38:52 <lambdabot> http://tinyurl.com/3x5nat
03:41:40 <lilac> xerox: thanks. however, that doesn't deal with the "\\\n" -> "" transformation, and doesn't appear to be composable with a parser which does
03:43:52 <mib_ukr1x8> hello can someone help me translate a c loop
03:44:23 <mux> show us the loop
03:44:49 <mib_ukr1x8> it goes like this for(int a = 0; a < 52; a++) for(int b = a + 1; b < 52; b++) for(int c=b+1; c < 52; c++) do something
03:45:08 <mux> we can't help you without knowing what the "do something" is
03:45:12 <mib_ukr1x8> i have no idea how i can do something like that efficiently in haskell
03:45:17 <mux> whether it has side-effects or not would change the way to write this in haskell
03:45:32 <mib_ukr1x8> the do something is constructs a list
03:45:39 <lilac> then [ something | a <- [0..51]; b <- [a+1..51]; c <- [b+1..51] ]
03:45:41 <mib_ukr1x8> Hand a b c
03:46:09 <lilac> > [ a*b*c | a <- [0..51]; b <- [a+1..51]; c <- [b+1..51] ]
03:46:10 <lambdabot>  Parse error at ";" (column 23)
03:46:10 <mib_ukr1x8> lilac i don't see how that can work
03:46:11 <mux> > [ (,) | <- a [0..51], b <- [a + 1..51] ]
03:46:11 <lambdabot>  Parse error at "<-" (column 9)
03:46:20 <lilac> > [ a*b*c | a <- [0..51], b <- [a+1..51], c <- [b+1..51] ]
03:46:21 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
03:46:23 <mux> > [ (,) | a <- [0..51], b <- [a + 1..51] ]
03:46:23 <lambdabot>  Add a type signature
03:46:38 <mux> > [ (,) | a <- [0..51], b <- [a + 1..51] ] :: [(Int,Int)]
03:46:39 <lambdabot>  Couldn't match expected type `(Int, Int)'
03:46:46 <mux> oh well
03:46:53 <mux> > [ (a,b) | a <- [0..51], b <- [a + 1..51] ]
03:46:54 <lambdabot>  [(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(0,12),...
03:46:58 <lilac> mib_ukr1x8: google for list comprehensions in haskell
03:47:00 <mib_ukr1x8> lets just say it constructs a list with all combinations of number 1 to 52
03:47:11 <mib_ukr1x8> ie (1,2,3)
03:47:20 <lilac> > [ (a,b,c) | a <- [0..51], b <- [a+1..51], c <- [b+1..51] ]
03:47:21 <lambdabot>  [(0,1,2),(0,1,3),(0,1,4),(0,1,5),(0,1,6),(0,1,7),(0,1,8),(0,1,9),(0,1,10),(0...
03:47:22 <mib_ukr1x8> (1,2,4
03:47:24 <mib_ukr1x8> etc
03:47:27 <Lewk> Can someone please tell me a quick and easy way of putting creating a graph data type to represent the following data? http://hpaste.org/7351#a0
03:47:36 <mib_ukr1x8> but you don't want 3,2,1
03:47:44 <lilac> mib_ukr1x8: i don't get (3,2,1)
03:47:55 <lilac> > [ (a,b,c) | a <- [0..4], b <- [a+1..4], c <- [b+1..4] ]
03:47:57 <lambdabot>  [(0,1,2),(0,1,3),(0,1,4),(0,2,3),(0,2,4),(0,3,4),(1,2,3),(1,2,4),(1,3,4),(2,...
03:48:04 <mib_ukr1x8> you already have (1,2,3) so you don't want (3,2,1)
03:48:16 <mib_ukr1x8> thats just a permutation
03:48:17 <trez> @pl modifyHead f xs = f (head xs) : tail xs
03:48:17 <lambdabot> modifyHead = (`ap` tail) . ((:) .) . (. head)
03:48:22 <mib_ukr1x8> you want all combinations
03:48:54 <Lewk> So I can pass all the data as one "Graph" to my function
03:50:15 <mib_ukr1x8> how does haskell evaluate list comprehensions
03:50:43 <mux> list comprehensions are syntactic sugar, and get rewritten into usual functions
03:50:59 <lilac> mib_ukr1x8: have a look at what i wrote and at the output it produces, and if it's producing the wrong output, please have another go at explaining what result you want
03:51:04 <mib_ukr1x8> mux can you show me how it gets written
03:51:58 <mux> http://www.haskell.org/onlinereport/exps.html#sect3.11
03:51:58 <lambdabot> Title: The Haskell 98 Report: Expressions
03:52:05 <mux> this explains the translation
03:52:34 <mib_ukr1x8> i'm not used to the whole idea of lazy evaluation
03:53:36 <mib_ukr1x8> lilac what you showed me is exactly what i needed
03:53:53 <mib_ukr1x8> thanks
03:55:06 <quicksilver> Lewk: I would represnet that as [(Int,[Int])]
03:55:21 <quicksilver> Lewk: a list of pairs, each of which is a node, and a list of its neighbours
03:55:47 <Lewk> so data Graph a = [(Int,[Int])]
03:55:48 <Lewk> ?
03:55:53 <quicksilver> :t [(1,[2,3,4]),(2,[5,6,3]),(3,[6,7]),(5,[7])]
03:55:54 <lambdabot> forall t t1. (Num t1, Num t) => [(t, [t1])]
03:56:00 <quicksilver> yes, exactly.
03:56:09 <quicksilver> there might be advantages to other reps. but that's a nice simpel one
03:56:18 <Lewk> I like simple
03:56:20 <Lewk> :)
03:56:22 <Lewk> Thanks
03:56:40 <jamii> Lewk: I have a bunch of graph algorithms using that represention if you want to see them.
03:56:55 <mib_ukr1x8> http://www.haskell.org/onlinereport/exps.html#sect3.11 can someone explain to me what [  e | b, Q ] 	 = 	 if b then [  e | Q ] else [] means
03:56:55 <lambdabot> Title: The Haskell 98 Report: Expressions
03:57:06 <mib_ukr1x8> i'm confused
03:57:06 <jamii> Different colouring algorithms, connectivity and hamiltonians
03:57:09 <Lewk> That might be good thanks jamii
03:57:23 <Lewk> hehe any DFS?
03:58:14 <mux> mib_ukr1x8: "b" ranges over boolean expressions, "e" over expressions, qnd "Q" over sequences of qualifiers - this is explained after the rules
03:58:31 <mux> so this rule explains how filters in list comprehensions get rewritten into plain if - then - else
03:58:55 <jamii> Colourings: http://hpaste.org/7352
03:59:00 <mib_ukr1x8> filters like a < 3?
03:59:10 <mux> yes
03:59:14 <mib_ukr1x8> ok
03:59:56 <jamii> Hamiltonians: http://hpaste.org/7353
04:00:16 <mib_ukr1x8> so b is boolean expression?
04:00:22 <jamii> They were coursework pieces so Ive deliberately avoided using any complicated haskell features
04:00:39 <maltem_> mib_ukr1x8, note that the interesting equation is the one containing (<-), because list comprehensions without such a binding aren't exiting really
04:00:41 <mib_ukr1x8> sorry if that seems like a dumb questions
04:00:54 <jamii> Array Int (Set Int) would be a much better representation
04:01:04 <mux> yeah, the crucial rule is the one rewriting using concatMap
04:01:37 <maltem_> s/exiting/exciting/, obviously
04:01:58 <Lewk> jamii: Thanks! I'll take a look over those
04:02:18 <mib_ukr1x8> and what is okl or okp?
04:02:52 <mux> "ok is a fresh variable"
04:03:05 <maltem_> mib, that's not okl, that's ok in one place and l in another
04:03:19 <mib_ukr1x8> oh i see
04:03:28 <mib_ukr1x8> so ok is like a data constructor?
04:03:34 <mib_ukr1x8> 'ok'
04:03:37 <mux> no
04:03:41 <mib_ukr1x8> functions
04:03:42 <mux> it's a freshly chosen variable name
04:03:54 <mib_ukr1x8> ah with any name
04:04:01 <mux> yes, that's what it means
04:04:07 <mux> any free name, obviously
04:04:27 <mux> it's for defining the function to pass to concatMap
04:05:02 <mux> I wonder if the simple reflection module could help us show the translation rule
04:05:32 <mux> > [ f x | x <- xs ]
04:05:33 <lambdabot>   Not in scope: `xs'
04:05:41 <mux> > [ f x | x <- (xs :: [Expr]) ]
04:05:41 <lambdabot>   Not in scope: `xs'
04:05:46 <mux> :t x
04:05:48 <lambdabot> Expr
04:05:54 <mux> hmm
04:06:20 <mux> > [ f x | x <- (xs :: [Expr]) ] :: [Expr]
04:06:21 <lambdabot>   Not in scope: `xs'
04:06:43 <lilac> :t [ f x | x <- (xs :: [Expr])
04:06:45 <lambdabot> parse error (possibly incorrect indentation)
04:06:47 <lilac> :t [ f x | x <- (xs :: [Expr]) ]
04:06:49 <lambdabot> Not in scope: `xs'
04:07:06 <mib_ukr1x8> so what sort of expressions are 'e'?
04:07:16 <mib_ukr1x8> it says e ranges over expressions
04:08:16 <mib_ukr1x8> taking this example
04:08:18 <mib_ukr1x8> [ (a,b,c) | a <- [0..4], b <- [a+1..4], c <- [b+1..4] ]
04:08:32 <mib_ukr1x8> e would be (a,b,c)?
04:08:40 <maltem> > let xs = [a,b,c] in [ f x | x <- xs ]
04:08:40 <lambdabot>  Add a type signature
04:08:49 <maltem> > let xs = [a,b,c] in [ f x | x <- xs ] :: [Expr]
04:08:50 <lambdabot>  [f a,f b,f c]
04:09:01 <mux> nice
04:09:12 <mux> but doesn't show the concatMap translation
04:09:46 <snhmib> hello, i am trying to install something (HaXml 1.14) but when building it it says: "Could not find module `Text.PrettyPrint.HughesPJ': it is a member of package pretty-1.0.0.0, which is hidden"
04:09:59 <snhmib> i'm not sure what hidden means here?
04:10:10 <mib_ukr1x8> i understand what maltem showed i just don't understand the symbols
04:10:24 <maltem> mux, well that's all that the Expr thing is capable of
04:10:41 <mib_ukr1x8> can someone translate [ (a,b,c) | a <- [0..4], b <- [a+1..4], c <- [b+1..4] ] for me so i can see how it would look
04:10:50 <mib_ukr1x8> or something simpler
04:11:04 <sendark> come again?
04:11:14 <maltem> mib_ukr1x8, you're trying to understand list comprehension syntax, or you'd like to know how to translate list comprehensions to the concatMap form?
04:11:39 <mib_ukr1x8> i want know how to translate list comprehensions to the concatMap form
04:12:37 <mux> mib_ukr1x8: [f x | x <- xs] ==> let ok x = f x; ok _ = [] in concatMap ok xs
04:13:00 <maltem> concatMap (\b -> [b+1..4]) (concatMap (\a -> [a+1..4]) [0..4]) -- I think
04:13:19 <mib_ukr1x8> hmm ok
04:13:39 <mib_ukr1x8> ok p = [  e | Q ]
04:13:45 <mib_ukr1x8> what should Q be?
04:13:49 <maltem> >  concatMap (\b -> [b+1..4]) (concatMap (\a -> [a+1..4]) [0..4]   ==    [ (a,b,c) | a <- [0..4], b <- [a+1..4], c <- [b+1..4] ]
04:13:50 <lambdabot> Unbalanced parentheses
04:14:00 <mib_ukr1x8> isn't that a sub list comprehension?
04:14:02 <mux> mib_ukr1x8: a possibly empty esequence of qualifiers
04:14:06 <maltem> >  concatMap (\b -> [b+1..4]) (concatMap (\a -> [a+1..4]) [0..4])   ==    [ (a,b,c) | a <- [0..4], b <- [a+1..4], c <- [b+1..4] ]
04:14:06 <lambdabot>   add an instance declaration for (Num (t, t, t))
04:14:49 <jaj> > (1,1,1)==(1,1,1)
04:14:50 <lambdabot>  True
04:14:54 <mux> we don't see how GHC creates the function to pass to concatMap in this example though
04:15:02 <maltem> ah, that term is too long to write on one line without being wrong
04:15:13 <mux> and it's quite informative for when pattern matching is done in list comprehensions
04:15:33 <mib_ukr1x8> bah i don't understand why haskell needs to be so complicated
04:15:50 <mux> > let foo xs = [ Just x | x <- xs ] in foo [Nothing,Just 1,Nothing,Just 2]
04:15:51 <lambdabot>  [Just Nothing,Just (Just 1),Just Nothing,Just (Just 2)]
04:15:56 <mux> err
04:16:07 <mux> > let foo xs = [ x | Just x <- xs ] in foo [Nothing,Just 1,Nothing,Just 2]
04:16:08 <lambdabot>  [1,2]
04:16:15 <maltem> mib, my things were complicated because they were wrong :)
04:16:23 <mib_ukr1x8> ocaml was easy as cake for me to grap but haskell omg
04:16:33 <mib_ukr1x8> grasp*
04:16:53 <mux> haskell has a steep learning curve, but it's rewarding and worth it by all accounts
04:17:19 <jaj> once you get going everything seems logical
04:17:33 <maltem> > [0..4] >>= \a -> [a+1..4] >>= \b -> [b+1..4] >>= \c -> return (a,b,c)
04:17:35 <lambdabot>  [(0,1,2),(0,1,3),(0,1,4),(0,2,3),(0,2,4),(0,3,4),(1,2,3),(1,2,4),(1,3,4),(2,...
04:17:41 <mib_ukr1x8> i'm hanging in:)
04:17:59 <mib_ukr1x8> i havn't learnt what >>= is
04:18:17 <quicksilver> concatMap
04:18:18 <quicksilver> in this case.
04:18:20 <maltem> mib, in this case, xs >>= f  means  concatMap f xs
04:18:30 <mux> we have so many ways to do concatMap :-)
04:18:31 <mib_ukr1x8> ok
04:18:47 <mux> any list comprehensions can be rewritten with concatMap, or with the list monad
04:18:55 <mib_ukr1x8> no monads
04:19:12 <mib_ukr1x8> or i will have brain overload :)
04:19:13 <mux> @src [] (>>=)
04:19:14 <lambdabot> xs >>= f     = concatMap f xs
04:19:17 <maltem> now just flip everything around in the above line, and you have the concatMap version :)
04:19:50 <mux> heh, hayoo is truly cool
04:20:00 <mux> I prefer it over hoogle these days
04:20:03 <mib_ukr1x8> i think haskell would be so much more in use if it didn't have such a steep learning curve
04:20:28 <mib_ukr1x8> do you run into space leeks often?
04:20:42 <maltem> mux, the only bad thing about it is disabling browser-back
04:20:49 <maltem> mux, the rest is cool
04:21:10 <mux> maltem: yeah but that's minor and expected when AJAX stuff comes into play
04:21:52 <paolino> mib_ukr1x8: stack overflows, sometimes
04:22:04 <jaj> could anybody point me out how you combine getInput :: MonadCGI m => String -> m (Maybe String) and fromMaybe? I don't know how to lift it correctly.
04:22:31 * quicksilver replies to apfelmus' reply to bd_ . Let the seq-flame-war begin.
04:22:44 <lilac> @check concatMap (\a -> concatMap (\b -> concatMap (\c -> [(a,b,c)]) [b+1..4]) [a+1..4]) [0..4] == [ (a,b,c) | a <- [0..4], b <- [a+1..4], c <- [b+1..4] ]
04:22:44 <mux> jaj: foo <- fromMaybe default `fmap` getInput "lala"
04:22:46 <lambdabot>  OK, passed 500 tests.
04:22:51 <mib_ukr1x8> paolino: do you run into them often?
04:22:53 <lilac> mib_ukr1x8: there you go
04:23:06 <mib_ukr1x8> thanks lilac
04:23:25 <jaj> mux: thank you
04:23:27 <mux> jaj: there are lots of different ways to write this though
04:23:35 <paolino> mib_ukr1x8: more often then in strict languages
04:23:41 <mux> but at least you've got fmap in the Prelude
04:24:13 <jaj> I could write <$> for esthetical reasons :)
04:24:18 <mux> yes
04:24:19 <mib_ukr1x8> the only thing i don't like in haskell is lazy evaluation :)
04:24:22 <Lewk> Sorry, another question :) -  why can't I use _ on line 7? http://hpaste.org/7354?lines=true#a0
04:24:31 <mib_ukr1x8> i guess i will like it soon :)
04:24:37 <paolino> sure
04:24:50 <maltem> mib, hey, lazy evaluation is the one cool thing about Haskell!
04:24:51 <mux> haskell wouldn't be nearly as much powerful without lazy evaluation
04:25:06 <mib_ukr1x8> lol
04:25:08 <jaj> I have yet to grasp what Functors really are and how you use them
04:25:10 <lilac> Lewk: because you're defining a list not a pattern
04:25:12 <tonky_> hi guys. http://hpaste.org/7355 - how do i convert from Int to Float? there's no "fromInt", only "fromInteger"
04:25:27 <mux> jaj: simply put, Functors are data structures you can "map" over
04:25:31 <mib_ukr1x8> tonk_ this is not ocaml
04:25:35 <jamii> Lewk: _ is used in pattern matches to indicate that you're ignoring something
04:25:45 <maltem> Lewk: What would _ mean in there?
04:25:54 <paolino> tonky_: fromIntegral
04:25:54 <mib_ukr1x8> anyway thanks for the help everyone
04:26:14 <Lewk> I'm wanting to say all other nodes have no children
04:26:23 <tonky_> mib_ukr1x8: yeah, i know ;)
04:26:26 <jaj> mux: yeah but in this case we don't have a list so I don't really see how map applies
04:26:35 <Lewk> Is there a way of doing that?
04:26:47 <mux> jaj: a "Maybe a" is also some kind of data structure, maybe containing an "a"
04:26:48 <maltem> Lewk: You have a list of finite length. There is no concept of "all other nodes" in a list of nodes
04:26:51 <tonky_> paolino: thanks!
04:27:09 <maltem> Lewk: Because there aren't any other nodes, unless you write them down explicitly
04:27:15 <mux> jaj: so fmap on a "Maybe a" applies the function to the "a" if it's there, and does nothing if there is no "a" - that is, when there is Nothing
04:27:26 <jaj> mux: oh yeah I read about the Maybe a == [a]; Nothing == [] analogy
04:27:28 <Lewk> Got it! Thanks!
04:27:30 <Lewk> :)
04:27:47 <paolino> @src Integral
04:27:47 <lambdabot> class  (Real a, Enum a) => Integral a  where
04:27:47 <lambdabot>     quot, rem, div, mod :: a -> a -> a
04:27:47 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
04:27:47 <lambdabot>     toInteger           :: a -> Integer
04:27:48 <mux> jaj: I'll show you some simple examples
04:27:59 <mux> > (+1) `fmap` (Just 1)
04:28:00 <lambdabot>  Just 2
04:28:04 <mux> > (+1) `fmap` Nothing
04:28:05 <lambdabot>  Nothing
04:28:09 <mux> jaj: see?
04:28:31 <jaj> mux: thank you :)
04:28:35 <mux> > liftM2 (+) (Just 2) (Just 3)
04:28:36 <lambdabot>  Just 5
04:28:54 <mux> > (+) <$> Just 2 <*> Just 3
04:28:55 <lambdabot>  Just 5
04:29:09 <jaj> @type (<*>)
04:29:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:29:41 <paolino> > (+2) <$> Just 2
04:29:42 <lambdabot>  Just 4
04:29:47 <maltem> > pure (+) <*> Just 2 <*> Just 3  -- That's how <$> and <*> are related
04:29:48 <lambdabot>  Just 5
04:30:25 <minivan> :t pure
04:30:28 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
04:30:34 <mux> pure f <*> g  ==  f <$> g
04:30:41 <lilac> > let g = (1,[2,3,4]):(2,[5,6,7]):zip [0..] (repeat []) in take 10 $ List.nubBy (\(a,_) (b,_) -> a==b) g
04:30:42 <lambdabot>   Not in scope: `List.nubBy'
04:30:50 <lilac> > let g = (1,[2,3,4]):(2,[5,6,7]):zip [0..] (repeat []) in take 10 $ nubBy (\(a,_) (b,_) -> a==b) g
04:30:52 <lambdabot>  [(1,[2,3,4]),(2,[5,6,7]),(0,[]),(3,[]),(4,[]),(5,[]),(6,[]),(7,[]),(8,[]),(9...
04:31:12 <maltem> pure is for Applicative Functors what return is for Monads
04:31:59 <paolino> describe Applicative once more, please
04:32:10 <mux> @src Applicative
04:32:10 <lambdabot> class Functor f => Applicative f where
04:32:10 <lambdabot>     pure  :: a -> f a
04:32:10 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
04:33:57 <mux> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
04:33:58 <lambdabot>  [5,7,9]
04:34:28 <maltem> > [(^2),(^3)] <*> [1,2,3]
04:34:29 <lambdabot>  [1,4,9,1,8,27]
04:35:00 <paolino> @instances Applicative
04:35:00 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
04:35:02 <jaj> hmm cartesian product
04:35:49 <maltem> @instances-importing Control.Applicaitve Applicative
04:35:50 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
04:35:54 <paolino> :t pure (+)
04:35:55 <lambdabot> forall a (f :: * -> *). (Applicative f, Num a) => f (a -> a -> a)
04:36:01 <maltem> @instances-importing Control.Applicative Applicative
04:36:01 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
04:39:21 <paolino> what is WrappedMonad ?
04:39:36 <maltem> a propos cartesian product:
04:39:39 <maltem> @pl \xs ys -> [(,)] <*> xs <*> ys
04:39:39 <lambdabot> (<*>) . ([(,)] <*>)
04:40:20 <wjt> > [(,)] <*> [1,2] <*> [3,4]
04:40:21 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
04:40:26 <wjt> that's a really obtuse way to write that :)
04:40:50 <maltem> letter-free style
04:44:06 <jaj> somebody has to create archives of discussions on #haskell and reference them by keywords
04:44:28 <jaj> that would yield a great documentation
04:45:25 <maltem> @quote Functor
04:45:25 <lambdabot> lament says: I'm running out of money and about to be evicted, what should i do? Use monads! My girlfriend dumped me, what should i do? Use applicative functors!
04:45:33 <maltem> @quote Functor
04:45:34 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
04:45:46 <ivanm> that _does_ sound scary
04:45:55 <ivanm> *shudder* UML *shudder*
04:47:34 <DRMacIver> I can't remember the context for that.
04:49:28 * wjt contemplates proofs by UML diagram chase.
04:57:47 <jamii> In hindsight, trying to conquer jetlag by reading CS papers was doomed to fail.
05:00:22 <ivanm> lol
05:10:50 <opqdonut> heh
05:41:13 <stevan> is it possible to declare an Maybe String instance of PrintfArg such that: printf "%s" $ Just "foo", outputs "foo"?
05:42:05 <wjt> What would printf "%s" Nothing produce?
05:42:25 <mux> you could just have fromMaybe defaultString yourMaybeVar
05:45:51 <kamaji> If i have a data type which takes 2 Integers, say "data twoInts = ti Integer Integer" how do I "access" the two integers in a function?
05:46:37 <solrize> either with pattern matching or constructor functions
05:46:55 <solrize> i.e. data twoInts = Ti {first :: Integer} {second :: Integer}
05:47:01 <solrize> a = Ti 3 5
05:47:07 <lilac> kamaji: types and type constructors have to start with a capital
05:47:19 <solrize> then (first a) = 3 and (second a) = 5
05:47:21 <lilac> kamaji: f (Ti i1 i2) = i1 + i2
05:47:23 <stevan> i used Maybe here just as an example. what i really got is: printf "%s" (myDataType "foo") and i like to output "foo". currently i pattern match the string out first and then send it to printf.
05:48:37 <kamaji> oh so you can basically just write one of the function arguments as the constructor?
05:49:12 <lilac> kamaji: yes. alternatively, you can use 'case': case x of (Ti i1 i2) = i1 + i2. or let: let (Ti i1 i2) = x in i1 + i2
05:49:37 <lilac> case example should have used -> instead of = btw, sorry
05:49:40 <maltem> stevan, the obvious way would be to have a Show instance for your data type
05:50:08 <maltem> stevan, or, in this particular case, maybe a function toString on its own would be better
05:50:15 <kamaji> lilac: Ok, I think I get it, i'll try some stuff out - thanks
05:50:22 <kamaji> solrize: thanks as well
05:50:42 <maltem> stevan, that is, printf "%s..." (toString my_data)
05:52:38 <Baughn> @type printf "%s"
05:52:39 <lambdabot> forall r. (PrintfType r) => r
05:52:44 <Baughn> @instances PrintfType
05:52:44 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
05:52:52 <Baughn> @instances-importing Text.Printf PrintfType
05:52:53 <lambdabot> (a -> r), IO a, [c]
05:52:56 <maltem> stevan, or finally, you could make your data type an instance of PrintfArg
05:53:30 <Baughn> @src PrintfType
05:53:30 <lambdabot> Source not found. :(
05:53:52 <stevan> that was my initial question :-)
05:54:16 <stevan> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Printf.html#PrintfType
05:54:17 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5gk6an
05:56:54 <stevan> i can't figure out how to, it says `toUPrintf' is not a (visible) method of class `PrintfArg'
05:57:42 <maltem> stevan, crap, it seems Text.Printf does not support user-defined instances by not exporting toUPrintf
05:58:14 <maltem> not sure whether this should be considered a feature
05:59:51 <maltem> if it exported everything needed, than it _would_ read, instance PrintfArg MyDataType where toUPrintf x = UString (toString x)
06:01:34 <stevan> hmmm :-/
06:02:33 <maltem> well you could still fork a Text.Printf.Stevan and fill in the missing exports :)
06:03:06 <jaj> stevan: you could simply write a wrapper function printf'
06:07:03 <jaj> you could import the module hiding PrintfArg and then go and copy the needed bits from the source code of Text.Printf
06:10:10 <stevan> i got it working. i wonder why the needed things are not exported tho.
06:10:40 <Lewk> Question: What are the 3 most important things a Java programmer should know about Haskell?
06:11:48 <sclv> ?seen Kamina
06:11:49 <lambdabot> Kamina is in #haskell. I don't know when Kamina last spoke.
06:12:50 <Baughn> Lewk: I don't see why a java programmer would want to know about haskell.. how about "If you learn it, you can write shorter programs, faster"?
06:13:29 <Baughn> Lewk: If you're looking for a soundbite, you won't find any. All the really neat bits would take too long to explain to one of those.
06:15:31 <minivan> 1. it rox 2. it's sexy 3. monad transformers
06:17:05 <Lewk> shorter programs, faster is good :) what's a soundbite?
06:18:32 <TomMD> lewk: http://en.wikipedia.org/wiki/Soundbite
06:21:13 <MyCatVerbs> Lewk: a snappy phrase that makes you think "ooh, sexy, I want that!"
06:21:59 <MyCatVerbs> Lewk: like Java's would probably be "took most of the good stuff from C++, but left behind most of the gratituous fail."
06:22:01 <Philippa> "Hard things are easy, the impossible just happened"
06:22:12 <Lewk> MyCatVerbs: Thanks ;).   Maybe my question should've been what are  3 simple but important things you should know before attempting to learn haskell :)
06:22:24 <MyCatVerbs> Philippa: hahahahah. Is that a reference to knot-tying? :)
06:22:49 <Philippa> it's the most obvious example, yeah :-)
06:22:52 <Baughn> Lewk: "Things that are easy in other languages are hard in haskell, and vice-versa; be patient."
06:22:58 <Philippa> (obviously that's really the seemingly-impossible)
06:23:23 <Philippa> they're hard at first. There's not a lot that should remain hard, although in fairness there's a significant amount that's still work in progress there
06:23:26 <Baughn> Lewk: "The learning curve is vertical, with overhangs and non-euclidian geometry"
06:24:01 <MyCatVerbs> Lewk: "ignore stupid monad tutorials" "the URL for YAHT is http://darcs.haskell.org/yaht/yaht.pdf " and, uh, "there's usually a cleverer way of doing it that you just haven't heard of yet".
06:24:01 <Lewk> You're not wrong there ^
06:24:05 <Philippa> Lewk: the thing with haskell is that it'll have you pulling metalinguistic stunts with such abandon that you don't even notice half of them - and doing it safely
06:24:06 <Baughn> Mm, yes. Once you get good at it.. sadly, "getting good at it" also involves writing your own library, half the time. IO is still annoyingly bad. :/
06:24:32 <Philippa> that's why the hard things're easy
06:25:07 <lilac> i'm trying to write a lexer for parsec which ignores all instances of "\\\n" -- can anyone offer any suggestions? So far I have http://hpaste.org/7357, but it doesn't work for "\\\n" at EOF
06:25:10 <sclv> s/ignore stupid monad tutorials/monads are computations/
06:25:15 <MyCatVerbs> Philippa: out of curiosity, re: attribute grammars.
06:26:06 <MyCatVerbs> Philippa: I can think of easy ways to write programs that do the same job as attribute grammars for synthesized attributes, but I can't think of any particularly easy way of doing inherited attributes.
06:26:19 <kamaji> Is there a function which takes an operator, a number and a list, and will apply the operator to each element of the list and the number to give a new list? e.g. f (+) 2 [1,2] gives [3,4]
06:26:28 <kamaji> I've been looking at foldr and scanr, but they're not quite right
06:26:33 <MyCatVerbs> Philippa: I think the problem is, more specifically, that I can't think of how to track *up* a tree easily instead of just down it.
06:26:41 <Kamina> kamaji: i think something like map ((+)2) list   will do
06:26:42 <lilac> > map (+2) [1,2]
06:26:43 <lambdabot>  [3,4]
06:27:05 <Philippa> MyCatVerbs: not looked at AGs in ages. Let me get back to you? I haven't had breakfast yet
06:27:09 <maltem> lilac, I'd do it along the lines of tokenWithWhitespace = token <* many whitespace
06:27:19 <Kamina> :t (+2)
06:27:20 <kamaji> Oh cool, thanks
06:27:21 <lambdabot> forall a. (Num a) => a -> a
06:27:30 <MyCatVerbs> Philippa: eeep. Please eat something.
06:27:32 <Kamina> (+2) is a function, adding 2 to any input
06:27:35 <MarcWeber> dcoutts: Is there a recommended cabal layout to add some code testing ? (maybe using hook runTests)
06:27:41 <MyCatVerbs> Philippa: I was just wondering if you knew of a good way to do it offhand.
06:27:46 <Philippa> MyCatVerbs: if it helps any, I've not been up that long either...
06:28:01 <dcoutts> MarcWeber: runTests is pretty free-form
06:28:03 <MyCatVerbs> Philippa: well, it's Caturday.
06:28:08 <MyCatVerbs> Philippa: that's actually a good sign, I guess.
06:28:11 <kamaji> > [n | n <- [1..100], elem 0 (map (mod n) [2,5])]
06:28:12 <lambdabot>  [2,4,5,6,8,10,12,14,15,16,18,20,22,24,25,26,28,30,32,34,35,36,38,40,42,44,45...
06:28:15 <kamaji> whee
06:28:17 <Philippa> also, your cat verbs - mine is less nocturnal than I am
06:28:26 <Lewk> MyCatVerbs: Thanks :)
06:28:45 <MarcWeber> dcoutts: Sure IO () :) No I mean most of the time you want to check your code.. So is adding a conditional test executable beeing run by runTests a good way?
06:29:00 <MyCatVerbs> Philippa: heh. I'd be completely noctural too if it weren't for lectures. :)
06:29:10 <MarcWeber> And what is the Args -> Bool -> .. Bool flag for?
06:29:55 <lilac> :ty (<*)
06:29:59 <MyCatVerbs> Lewk: no worries. Also, if you get impatient and want a faster-paced tutorial than YAHT (one that rushes through and leaves the fine detail for you to discover as you need it), look up the HitchHiker's Guide To Haskell.
06:30:25 <MyCatVerbs> (I don't know the URL for that offhand, but you'll find it easily on google.)
06:30:45 <Lewk> will do :) I think I downloaded it the other day actually
06:30:53 <lilac> maltem: what is <* ?
06:31:05 <Lewk> along with anything else I could find, so didn't get around to that one
06:31:47 <snhmib> what does !<type> mean/do?
06:32:11 <snhmib> i see it sometimes but i can't find what it means
06:32:15 <kamaji> where can I find the function definition of map?
06:32:27 <ttt--> @src map
06:32:27 <lambdabot> map _ []     = []
06:32:27 <lambdabot> map f (x:xs) = f x : map f xs
06:32:42 <kamaji> oh thanks heh
06:32:54 <kamaji> (can I do that in ghci? )
06:33:02 <kamaji> nope :|
06:33:14 <ttt--> http://haskell.org/hoogle/
06:33:18 <minivan> you can do that in hoogle
06:33:26 <lilac> maltem: "logicalLineCharacter = (many deletedNewline) >> basicSourceCharacter >> (many deletedNewline)" seems to do the job, ty
06:33:48 <kamaji> oh I'd forgotten about hoogle
06:33:53 <kamaji> thanks again >_>
06:34:07 <snhmib> kamaji: you can also goto online ghc docs, lookup map and click on Source next to it =)
06:34:10 <MarcWeber> lilac: Have you solved your \\n problem?
06:34:25 <Philippa> snhmib: In a datatype definition? Makes that parameter strict
06:34:54 <Philippa> effectively, given data Foo = Foo !A, Foo a becomes a `seq` Foo a
06:36:14 <snhmib> oh
06:36:18 <snhmib> thanks =)
06:36:46 <MarcWeber> Philippa: :) This example shoud be given in ghc docs :)
06:38:00 <Philippa> heh. It can also make an optimisation hint for the compiler, in that once it knows the parm's strict it can use a faster representation for it
06:45:05 <lilac> MarcWeber: I think so. I'm still not happy with the solution though. I think I'd be best off not using parsec for lexing after all
06:47:07 <visof_> i can't understand this : (x >>= f) >>= g == x >>= (\v -> f v >>= g)
06:47:13 <visof_> can anyone help ?
06:47:37 <sclv> @redo (x >>= f) >>= g == x >>= (\v -> f v >>= g)
06:47:37 <lambdabot> do { a <- do { a <- (do { a <- x; f a}); (g == x) a}; (\ v -> do { a <- f v; g a}) a}
06:47:59 <sclv> @pl (x >>= f) >>= g == x >>= (\v -> f v >>= g)
06:47:59 <lambdabot> g =<< f =<< g == x =<< f =<< x
06:48:07 <sclv> @redo g =<< f =<< g == x =<< f =<< x
06:48:07 <lambdabot> g =<< f =<< g == x =<< f =<< x
06:48:10 <visof_> what is this
06:48:21 <MarcWeber> lilac: It depends. You need to attach a source location to your new tokens. Then you need to build new parser operating on those tokens with attached source location or such. I think parsec-3 is better suited or try one of the other parsing packages
06:48:26 <visof_> i'm absolute beginner in monads
06:48:52 <MarcWeber> visof_: This example seems to be about monads. Have you read any tutorial yet?
06:49:14 <visof_> i read http://www.haskell.org/haskellwiki/Monads_as_Computation
06:49:16 <lambdabot> Title: Monads as computation - HaskellWiki
06:49:19 <visof_> right now
06:49:27 <MarcWeber> visof_: You feed something in, apply a a function to the value depending on monad type.
06:49:46 <MarcWeber> A really nice example is Just 7 >>= (*2) yelding Just 14
06:50:02 <MarcWeber> Nothing >>= (*2) yelds Nothing again.
06:50:39 <MarcWeber> In this simple case the Maybe monad has been used. There a are many more
06:53:26 <ziman> Just 7 >>= return . (*2) it is, isn't it?
06:53:55 <MarcWeber> ziman: correct
06:54:14 <Philippa> MarcWeber: parsec3's not any particular help. I've done lexing in Parsec before though
06:54:35 <Philippa> lilac: that's pretty much the standard solution for eating whitespace, FWIW
06:57:39 <lilac> MarcWeber: it seems easier to do it by hand -- i'll use parsec for higher levels of the parse where it'll give me some benefit, though.
06:57:58 <dcoutts> MarcWeber: I've no idea what the Bool flag to runTests is, all I know is now it's always False :-)
06:58:34 <Philippa> lilac: FWIW, using a lib for lexing definitely makes things easier as your language grows
06:58:59 <Philippa> I don't regret doing it - but then, I knocked up lexer, parser and the rest of a small lambda calculus interpreter in one sitting so YMMV
06:59:13 <dcoutts> MarcWeber: and looking back at older versions it's been False for a long time, so I have no idea what it used to be used for :-)
07:02:13 <MarcWeber> dcoutts: Maybe a  Bool not used has been False for a while keeping it to not break code comment or such would be fun to read, would'nt it?
07:02:44 <Igloo> It might be run-in-place
07:02:59 <Igloo> or run-installed
07:03:01 <dcoutts> MarcWeber: I'm sure we've not removed it precisely because it'd break any existing users
07:05:57 <visof_> meaning of " x >>=  f = f x" , apply action x then pass the result  to f ??
07:07:42 <visof_> is this right?
07:13:05 <Philippa> visof_: I assume that's a function definition. Pretend it's g x f = f x
07:13:12 <Philippa> (with g taking the role of >>=)
07:14:12 <visof_> i'm confused
07:14:42 <Philippa> again, I assume that's a function definition (inside an instance declaration)?
07:14:44 <MarcWeber> visof_: function arguments can be functions as well
07:14:50 <visof_> i knew the meaning of (x >>= f)
07:14:54 <visof_> is:
07:15:20 <Philippa> visof_: stop trying to be clever and answer the questions :-) We know you're confused, let us work out how for you?
07:15:53 <Philippa> (I'm assuming it's a definition because that isn't one of the monad laws, which're the only other place you'd see an equation of that form)
07:16:54 <visof_> Philippa what are your questions ?
07:17:17 <Philippa> is that a function definition? To put it another way, what context does it appear in?
07:17:34 <Philippa> Also, while I'm at it: do you know what it looks like when you bind a function to an operator?
07:17:50 <Philippa> as in l |+| r = ...?
07:18:21 <takamura> This is not haskell-related but... does somebody know a program to invert the colors of a pdf file? (I read a lot of pdf's and the white background hurts my eyes)
07:21:12 <visof_> Philippa  newtype Identity a = Identity { runIdentity :: a }
07:21:12 <visof_>  
07:21:12 <visof_> instance Monad Identity where
07:21:12 <visof_>     return a           = Identity a   -- i.e. return = id
07:21:12 <visof_>     (Identity x) >>= f = f x          -- i.e. x >>= f = f x
07:21:23 <visof_> http://www.haskell.org/all_about_monads/html/identitymonad.html
07:21:23 <lambdabot> Title: The Identity monad
07:21:30 <visof_> definition
07:21:43 <visof_>  (Identity x) >>= f = f x          -- i.e. x >>= f = f x
07:22:16 <Philippa> right. So if it's a definition, what's so hard about it?
07:22:35 <visof_> no hard thing
07:22:39 <Philippa> note that it doesn't "apply action x", it just applies f to x
07:22:47 <visof_> the problem i understand very slowly
07:23:06 <visof_> consider i'm stupid
07:23:09 <Igloo> Note that Identity x is not the same as x
07:23:56 <visof_> apply f to "f" action ?
07:24:13 <visof_> apply to "x"
07:24:43 <visof_> what i understood about bind
07:25:00 <visof_> x >>= f
07:25:13 <visof_> execute x the pass result to f
07:25:29 <visof_> and the pass the result*
07:25:33 <visof_> then*
07:25:45 <visof_> is this right
07:25:46 <visof_> ?
07:25:52 <Philippa> visof_: you're looking at an implementation of bind for a specific monad
07:25:57 <Philippa> in this case, 'execution' is just id
07:26:05 <Philippa> or perhaps more accurately, just unboxing
07:26:13 <Philippa> (taking the value out of the Identity box it's in)
07:26:24 <visof_> x is action
07:26:37 <paolino> no
07:26:39 <visof_> suppose x = getLine
07:26:48 <visof_> no what?
07:26:50 <paolino> Identity x is action
07:27:08 <visof_> if we say x >>= f
07:27:08 <Saizan> in (Identity x) >>= f = f x, (Identity x) is the action, that when executed gives x as result
07:27:17 <Philippa> visof_: then you're about to discover that Identity != IO
07:27:31 <visof_> oh ym God
07:27:33 <visof_> m
07:27:35 <visof_> y
07:27:45 <visof_> i'm very confused
07:27:54 <visof_> i can't understand
07:27:55 <Philippa> you're looking at an implementation of one specific monad
07:28:01 <Philippa> namely the Identity monad
07:28:05 <Philippa> the IO monad is something else
07:28:11 <Philippa> (and it's not implemented in Haskell, either)
07:28:14 <paolino> Monad is a class, you should understand those also
07:29:03 <visof_> if we say x >>= f , explain this definition ?
07:29:36 <visof_> definition of (>>=)
07:29:44 <paolino> depends on the type of x  which is the same of f
07:29:45 <Kamina> compute x, pass the result to f
07:29:46 <visof_> what is the meaning of it?
07:29:55 <Kamina> while the resulting expression is a new computation
07:29:57 <Igloo> There is no one definition of (>>=)
07:29:59 <Kamina> for example
07:30:11 <Igloo> But you can think of it as executing x and passing the result to f, as you said earlier
07:30:12 <Philippa> x >>= f isn't a definition
07:30:27 <visof_> kamina this what i understood
07:30:30 <Philippa> if it's a definition, there's an = involved somewhere (no, not the one in >>=)
07:30:49 <Kamina> visof_: getLine >>= putStrLn  means  "compute" (or "execute") getLine, pass the results to putStrLn, and the whole expression is a new "computation" (which reads lines and writes them out again)
07:30:53 <Philippa> so the x >>= f in x >>= f = f x is a pattern
07:31:05 <Philippa> it binds the LHS parm to x and the RHS parm to f
07:31:48 <Kamina> visof_: the definition of "compute" depends on the kind of monad
07:32:08 <Kamina> visof_: for the List-Monad, compute means doing things with every element of the list
07:32:43 <visof_> kamina explain this   (Identity x) >>= f = f x
07:33:49 <paolino> it's a rewriting rule for (>>=) symbol
07:34:06 <Kamina> visof_: i don't know about the identity monad yet, let me check the page
07:34:14 <visof_> okay
07:34:16 <lilac> is there a nice way to pattern match on "foo"++xs?
07:34:27 <maltem> no
07:34:45 <maltem> except if 'f':'o':'o':xs qualifies as nice
07:34:53 <lilac> not in my book ;-)
07:35:27 <Kamina> visof_: for me the identity monad looks like a kind of writing function application as monads... which has no practical use.. just theoretical
07:35:39 <Deewiant> perhaps some TH could be used to create something nicer?
07:35:47 <Deewiant> or does it operate at a different level
07:35:49 <Kamina> visof_: like wrapping a monad aroudn a function (but i'm not completely sure)
07:35:50 <Igloo> foo ys | Just xs <- stripPrefix "foo" ys = ... (with pattern guards)
07:36:21 <ski> lilac : `foo ys | Just xs <- Data.List.stripRefix "foo" ys  =  ..xs..' -- using some ghc extension i forgot the name of
07:36:37 <maltem> Kamina, that's right, but don't say it has no practical use before you're not completely sure ;)
07:36:38 * ski grins
07:37:01 <maltem> ski, pattern guards, you mean?
07:37:13 <ski> maltem : yeah, see Igloo
07:37:24 <maltem> ah right
07:37:48 <maltem> hey, I didn't even know we have stripPrefix in Data.List
07:38:25 <Kamina> visof_: i think that: Identity <something>  wrapps something
07:39:31 <Kamina> visof_: and when you write >>=, the <something> will be unwrapped again and passed as first argument of the function on the right side
07:40:27 <Kamina> visof_: with getLine this is similar... getLine "wraps" a result (because returning it directly is impossible, as it would mean putLine is not always returning the same, as required in a purely functional language)
07:40:50 <Kamina> visof_: i mean getLine returns a wrapped String
07:40:56 <Kamina> :t getLine
07:40:58 <lambdabot> IO String
07:41:25 <Kamina> and >>= unpacks a wrapped thing, to make it available as first argument to the function on the right hand side
07:41:59 <Kamina> visof_: and the right hand side HAS to return a wrapped thing again
07:42:16 <Kamina> :t (>>=)
07:42:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:42:45 <Kamina> visof_: why do you need to understand that Identity Monad?
07:43:18 <visof_> kamina i want to be familiar with monads
07:43:33 <visof_> so i need to understand the simple then the hard
07:44:01 <Kamina> visof_: there are two different definitions of the term "Monad"
07:44:10 <Botje> the best way to learn monads is simply to use them
07:44:44 <Kamina> visof_: you can either say the Monad is a triple of the things: A type transformer, a ">>=" operator and a "return" operator
07:45:19 <Kamina> visof_: in case of the Identity monad
07:45:52 <Kamina> visof_: "Identity" refers to two things
07:46:33 <Kamina> visof_: it's quite complicated to explain i think...
07:46:48 <Kamina> visof_: the problem is "Identity" is both used as a type, and also as a constructor
07:46:58 <Kamina> visof_: which makes things more confusing
07:47:35 <paolino> visof, probably the State monad is the easier to figure out
07:47:52 <Kamina> visof_: when you write    data Size = Size Integer   then "Size" is both the Type, and also a Constructor
07:48:14 <Kamina> visof_: but you could also write:   data SizeType = SizeConstructor Integer  to make it a bit more clear
07:48:16 <visof_> ah
07:48:55 <Kamina> visof_: and if you look at the page http://www.haskell.org/all_about_monads/html/identitymonad.html you see that type-name and constructor-name are the same too
07:48:56 <lambdabot> Title: The Identity monad
07:49:09 <Kamina> newtype Identity a = Identity { runIdentity :: a }
07:50:03 <Kamina> i think i have seen a nice page explaining monads quite well
07:50:39 <Kamina> visof_: http://www.haskell.org/tutorial/monads.html
07:50:40 <lambdabot> Title: A Gentle Introduction to Haskell: About Monads
07:57:15 <moozilla> I just read a paper on mondas
07:57:18 <moozilla> monads*
07:57:22 <moozilla> it explained them really well
08:00:26 <MarcWeber> dcoutts: http://rafb.net/p/vXZoHa62.html Can I do this ? optionally add a test executable by flags?
08:00:27 <lambdabot> Title: Nopaste - No description
08:00:58 <MarcWeber> dcoutts: Do you think an ./setup --create-initial
08:01:37 <MarcWeber> would be useful generating Setup.hs .cabal stubs?
08:03:02 <Lemmih> Didn't dons write such a tool?
08:04:56 <MarcWeber> dons: ping
08:05:11 <Lemmih> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mkcabal
08:05:13 <lambdabot> http://tinyurl.com/56vq93
08:06:26 <mauke> since when is haskell.org down?
08:08:44 <MarcWeber> Lemmih: thanks
08:09:54 <ski> moozilla : which one ?
08:10:33 <moozilla> ski: sec, haskell.org is being really slow
08:10:56 <ski> visof_ : sometimes the `data Size = MkSize Integer' convention is used
08:12:46 <gweiqi> does anybody know if you can build Yi with ghc 6.6.1?
08:13:49 <moozilla> ski: this: http://research.microsoft.com/~simonpj/Papers/marktoberdorf/mark.pdf
08:13:51 <lambdabot> http://tinyurl.com/y7tbw8
08:14:00 <ski> ok
08:14:01 <moozilla> Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell.
08:14:24 <mauke> .oO( that doesn't sound like it explains monads )
08:14:33 <moozilla> monadic input/output
08:14:43 <moozilla> it has a huge section on them
08:17:03 <astrolabe> @hoogle sort
08:17:04 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
08:17:04 <lambdabot> Data.ByteString.sort :: ByteString -> ByteString
08:17:04 <lambdabot> Data.ByteString.Char8.sort :: ByteString -> ByteString
08:17:33 <joey> Don't supposed anyone has a syntax highlighting config for nano?
08:18:37 <lilac> ?hoogle Search (a -> Bool) -> a -> Maybe a
08:18:38 <lambdabot> No matches, try a more general search
08:18:50 <lilac> ?hoogle Search a -> (a -> Bool) -> Maybe a
08:18:51 <lambdabot> No matches, try a more general search
08:18:58 <mauke> ?hoogle (a -> Bool) -> a -> Maybe a
08:18:59 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
08:20:55 <lilac> ?hoogle Bool -> a -> Maybe a
08:20:56 <lambdabot> No matches, try a more general search
08:21:06 <ski> @hoogle (a -> Bool) -> [a] -> Maybe a
08:21:06 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
08:21:24 <ski> lilac : what are you after ?
08:21:39 <ski> searching though a list for some element ?
08:21:47 <MarcWeber> joey: Didn't knew nano has syntaxhighlighting .. If you want I can show you how to setup vim
08:21:47 <lilac> ski: \p x -> if p x then Just x else Nothing
08:22:07 <mauke> @pl \p x -> if p x then Just x else Nothing
08:22:08 <lambdabot> flip flip Nothing . (`ap` Just) . (if' .)
08:22:28 <ski> @type \p x -> do guard (p x); return x
08:22:30 <lambdabot> forall (t :: * -> *) t1. (MonadPlus t) => (t1 -> Bool) -> t1 -> t t1
08:22:49 <mauke> @. pl undo  \p x -> do guard (p x); return x
08:22:49 <lambdabot> (`ap` return) . (((>>) . guard) .)
08:22:56 <ski> in what context do you want this ?
08:24:16 <lilac> third argument of Text.ParserCombinators.Parsec.Prim.parse
08:24:29 <laz0r> i am wondering: what does that lambdabot @pl command actually do? and why is this so frequently used?
08:25:02 <bd_> laz0r: It does neat tricks to remove the variables from an expression :)
08:25:04 <laz0r> i see you use it all the time, but mostly fail to make sense of the result
08:25:15 <laz0r> ok
08:25:27 <bd_> laz0r: Sometimes it makes things more readable. Most of the time it doesn't. But the meaning of the expression is unchanged.
08:27:07 <joey> MarcWeber: Thanks, no idea how to use vim tho' >.<
08:27:56 <ski> @type Text.ParserCombinators.Parsec.Prim.parse
08:27:58 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
08:28:07 <johnnowak> laz0r: a lot of haskell programmers were forth programmers in a past life
08:28:08 <red75> @pl \ a -> (a:a:a:[])
08:28:08 <lambdabot> ap (:) (ap (:) return)
08:28:27 <lilac> @type Text.ParserCombinators.Parsec.Prim.token
08:28:29 <lambdabot> forall tok a st. (tok -> String) -> (tok -> Text.ParserCombinators.Parsec.Pos.SourcePos) -> (tok -> Maybe a) -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
08:28:35 <lilac> that's the one I meant, sorry
08:28:45 <mauke> > replicate 3 a
08:28:45 <lambdabot>  [a,a,a]
08:29:27 <ski> johnnowak : maybe more like squiggol ..
08:31:20 <ski> lilac : and what structure do you want to seach for a token ? .. a list ? .. something else ?
08:31:56 <laz0r> johnnowak: i never even heard of forth
08:32:59 <johnnowak> laz0r: it's a language that discourages the use of variables
08:33:06 <lilac> ski: i basically want to replicate the existing 'satisfy' function but over a different type of token
08:33:51 <lilac> is it possible to name a module in a hiding clause?
08:35:12 <MarcWeber> lilac: What do you want to do? Limit functions being exported?
08:37:08 <nominolo> @seen dons
08:37:09 <lambdabot> dons is in #haskell-hac4, #haskell-soc, #xmonad and #haskell. I last heard dons speak 8h 6m 17s ago.
08:37:18 <nominolo> @localtime dons
08:37:20 <lambdabot> Local time for dons is Sat May  3 08:37:18 2008
08:37:39 <MarcWeber> @localtime MarcWeber
08:37:42 <lambdabot> Local time for MarcWeber is Sat May  3 17:37:36 2008
08:37:58 <MarcWeber> I'm impressed
08:38:13 <Deewiant> CTCP: it slices, it dices, it even tells you the local time!
08:38:14 <xerox> It's your client giving away the information for free :) /CTCP MarcWeber TIME
08:39:32 <lilac> MarcWeber: i'm importing Parsec, and don't want any of Parsec.Char, which is exported by Parsec
08:42:17 <MarcWeber> lilac: No, don't think you can use kind of difference here. Then you have to use either hiding ( <list of al functions of Parsec.Char> ) or not import Parsec, only Parsec.* or qualify the module whose functions you want to use colliding with Parsec.Char
08:43:19 <ski> lilac : it appears `Parsec.Char' uses `Parsec.Pos' to define `satisfy' from `token' .. and `Parsec.Pos' assumes `Char' to keep track of line and column position ..
08:43:37 <red75> @pl \a b -> fix (\f b a -> case b of 0 -> [] ; _ -> (a:f (b-1) a))
08:43:37 <lambdabot> (line 1, column 36):
08:43:37 <lambdabot> unexpected ">"
08:43:37 <lambdabot> expecting variable, "(", operator or ")"
08:44:26 <mauke> pl doesn't understand case
08:44:38 <red75> understood
08:45:01 <ski> the outer `a' and `b' are unused
08:45:20 <ski> @type fix (\f b a -> case b of 0 -> [] ; _ -> (a:f (b-1) a))
08:45:21 <lambdabot> forall t a. (Num t) => t -> a -> [a]
08:45:25 <red75> oops. yes
08:45:44 <sclv> ?seen SamB
08:45:44 <lambdabot> SamB is in #ghc, #perl6, #xmonad, #haskell, #haskell-blah and #darcs. I don't know when SamB last spoke.
08:45:45 <ski> @type fix (\f a b -> case b of 0 -> [] ; _ -> (a:f a (b-1)))  -- better ?
08:45:47 <lambdabot> forall t a. (Num t) => a -> t -> [a]
08:46:46 <red75> no. it's supposed to be equivalent of repeat
08:47:16 <red75> *replicate
08:48:21 <shapr> yarr
08:48:23 <shapr> @users
08:48:23 <lambdabot> Maximum users seen in #haskell: 459, currently: 433 (94.3%), active: 16 (3.7%)
08:51:17 <snhmib> does someone know a good tutorial/reference for doing calling C from haskell, or can point me to a (small) library that does struct marshalling and callbacks?
08:51:34 <snhmib> i have found the addendum-thing (?) but i could use some code examples =)
08:53:05 <astrolabe> snhmib: Have you seen 'tackling the awkward squad'?
08:53:53 <snhmib> not yet!
08:55:39 <mauke> I don't have an example, but you need to write a Haskell type for the struct and make it an instance of Storable
08:55:55 <mauke> his usually involves hsc2hs to get the right size and member offsets
08:57:47 <Bonus_> hai
08:57:47 <Bonus_> guys
08:58:05 <Bonus_> check this out: http://hpaste.org/7358
08:58:22 <Bonus_> it's supposed to determine whether a number is a lychrel number for an amount of tries
08:58:33 <Bonus_> but it malfunctions kind of
08:58:33 <mauke> what the hell, logBase
08:58:40 <Bonus_> :[
08:59:07 <mauke> isPalindrome n = let s = show n in s == reverse s
08:59:12 <Bonus_> yeah i tried that
08:59:19 <Bonus_> but kept getting no read parse errors
08:59:24 <Bonus_> on some passes
08:59:41 <snhmib> mauke: i'll try some of the helper tools for this stuff later... i want to do it for some small stuff for myself first i think :)
08:59:45 <Bonus_> what's strange here is that, for instance, it reports that 196 isn't a lychrel number at around the 24th try
08:59:54 <mauke> snhmib: uh, you can't do it yourself
09:00:24 <Bonus_> even though it is the most likely candidate for one
09:00:54 <snhmib> oh, well then i'll try the helper tools right away :)
09:00:56 <mauke> @check \n -> length (reads $ show (n :: Int) :: [(Int,String)]) == 1
09:00:58 <lambdabot>  OK, passed 500 tests.
09:01:16 <mauke> snhmib: how are you going to get the offset of a struct member by hand?
09:03:05 <snhmib> i was thinking about by looking at it, but i'll try hsc2hs :)
09:04:32 <mauke> ok, take this struct: struct foo { int a; double b; char c; int d; }
09:04:38 <mauke> what now?
09:04:51 <red75> Bonus_: Int is 32/64-bit integer. Overflow is possible.
09:06:00 <Bonus_> ah
09:06:08 <Bonus_> of course
09:06:15 <Bonus_> i'll see to converting it to Integer
09:08:35 <snhmib> mauke: i'm guess <32> (32) <64> <1> (?) :S i was thinking more of simple examples like struct {int a,b,c;} to get a feel for it before having it done automatically!
09:09:27 <Bonus_> haha yeah switching to Integer solved it
09:09:29 <Bonus_> how stupid of me
09:09:47 <mauke> snhmib: those aren't offsets
09:11:32 <snhmib> oh then a->0 b->8 c->16?
09:12:33 <mauke> depends
09:13:02 <mauke> is int an 8 byte type? or only 4? or 2? what are the alignment constraints on double?
09:13:23 <johnnowak> snhmib: what are you trying to do?
09:13:27 <mauke> or is the C compiler just silly and inserts padding for the heck of it
09:13:58 <mauke> you simply can't derive member offsets just by looking at the type definition
09:14:12 <mauke> @localtime preflex
09:14:18 <snhmib> johnnowak: i have a library i'd like to use in haskell and i'm now (trying) to learn how to call C things
09:14:26 <mauke> whoops
09:16:44 <johnnowak> snhmib: well i don't have what approach you're taking, but if you want to get the offset of a struct member in C, use offsetof(<struct>, member), e.g., offsetof(struct coordinate, y);
09:16:52 <johnnowak> have->know
09:17:36 <johnnowak> the C standard guarantees the members will be in the order they're declared in, but the offsets will vary between systems and compilers
09:17:42 <mauke> @localtime preflex
09:17:43 <lambdabot> Local time for preflex is not available. It's a bot!
09:17:43 <lambdabot> Local time for preflex is not available. It's a bot!
09:19:31 <DuClare> Hmm.  Does it take longer than a flash for a program to walk through 756 000 lines and compare the lines' beginnigs, adding to a list the ones that aren't there already?
09:19:43 <snhmib> johnnowak: yea i know it depends, but i'm just trying to learn the haskell ffi first =)
09:19:50 <DuClare> It's a question of speed versus re-use / fool-proofness
09:19:58 <ziman> @localtime ziman
09:20:02 <lambdabot> Local time for ziman is Sat May  3 18:20:04 2008
09:20:03 <mauke> why a list? sounds more like a set
09:20:08 * qwr . o O ( how long is flash? )
09:20:13 <DuClare> mauke, I don't know sets
09:20:59 <DuClare> qwr, Well, something that doesn't really matter when the program isn't being run in a loop ..  Eg. a second or two won't matter, but spending a minute on it might be a waste. :o
09:21:06 <dogbite> hello all.  if i'm starting a Haskell project that I intend to share with the Haskell community, is it recommended that I use a darcs repository?
09:23:05 <ddarius> import Data.List; import qualified Data.Set as Set; import qualified Data.ByteString.Lazy as BS; main = BS.getContents >>= liftM (foldl' (Set.insert) Set.empty) . filter condition . BS.lines
09:24:09 <sclv> ?hoogle dataCast2
09:24:10 <lambdabot> Data.Generics.Basics.dataCast2 :: (Data a, Typeable2 t) => c (t a b) -> Maybe (c a)
09:27:29 <sm>  dogbite : by me - yes :)
09:27:52 <dogbite> :sm cool.  is there a recommended public server to host my darcs repository?
09:28:00 <dogbite> :sm or should i just set my own public server up?
09:28:24 <qwr> DuClare: well, I would avoid the scanning. but you can time by yourself something like length (filter (Data.List.isInfixOf "100") (map show [1000..757000]))
09:28:28 <ddarius> dogbite: Whichever.  If you want you can request an account on code.haskell.
09:29:02 <qwr> DuClare: and Data.Set is probably helpful ;)
09:29:23 <dogbite> ddarius: okay, i will think about it.
09:29:26 <DuClare> qwr, I guess lots of things will be useful.  But I'm still only starting with haskell..
09:30:45 <geezusfreeek_> i'm not the only one who can't get to haskell.org, am i?
09:31:50 <laz0r> geezusfreeek: haskell.org does not work for me either
09:32:02 <laz0r> maybe it does, but veeeery slow
09:32:13 <geezusfreeek> i haven't gotten _anything_ to load
09:32:17 <jaj> is haskell.org down?
09:32:26 <geezusfreeek> ah, looks like somebody on haskell-cafe can'
09:32:31 <laz0r> i get at least a ping reply
09:32:45 <geezusfreeek> *can't either
09:32:47 <jaj> geezusfreeek: I haven't been able to access it for several hours
09:33:04 <geezusfreeek> hmm
09:33:19 <jaj> but it's not the first time I can't access it while other people here tell me it works for them
09:33:20 <laz0r> ok, now my http request timed out
09:33:22 <geezusfreeek> i don't even know who is responsible for haskell.org
09:33:27 <laz0r> so no haskell.org for me
09:41:02 <ddarius> geezusfreeek: Different people are responsible for different parts.
09:41:19 <sclv> ?hoogle unsafeCoerce
09:41:19 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
09:41:25 <geezusfreeek> of course, i just mean the server itself
09:42:54 <Deewiant> @src unsafeCoerce
09:42:55 <lambdabot> Source not found. stty: unknown mode: doofus
09:43:32 <Deewiant> unsafeCoerce = const undefined
09:43:54 <geezusfreeek> unsafeCoerce is a boxed version of unsafeCoerce#, so seeing the source wouldn't be very useful
09:46:29 <Lemmih> unsafeCoerce have a different kind than unsafeCoerce# ?
09:46:55 <geezusfreeek> i actually don't think so
09:47:18 <geezusfreeek> so "boxed version" was really the wrong thing to say
09:47:51 <geezusfreeek> i dunno, i avoid unsafeCoerce like the plague
09:55:19 <gwern> > 4.750 + 13.230 + 18.440
09:55:19 <lambdabot>  36.42
09:55:37 <gwern> > ((4.750 + 13.230 + 18.440) - 20) / 4
09:55:38 <lambdabot>  4.105
09:56:03 <gwern> > ((4.750 + 13.230 + 18.440) - 20) / 4) / 20
09:56:03 <lambdabot> Unbalanced parentheses
09:56:15 <gwern> > (((4.750 + 13.230 + 18.440) - 20) / 4) / 20
09:56:16 <MathHat> > it / 20
09:56:16 <lambdabot>  0.20525000000000002
09:56:16 <lambdabot>   Not in scope: `it'
09:56:22 <MathHat> aww.
09:56:35 <gwern> > ((((4.750 + 13.230 + 18.440) - 20) / 4) / 20) * 100
09:56:36 <lambdabot>  20.525000000000002
09:56:49 <gwern> heh.
09:56:49 <MathHat> my I ask?
09:56:52 <MathHat> *may
09:57:17 <gwern> so over the past 4 years, I've earned an average annual return of 21% trading on the Iowa Electronic Markets
09:57:35 <lilac> gwern: are you looking for investors? ;-)
09:57:39 <MathHat> ah, tres bien.
09:57:44 <gwern> since I started with 20USD and ended up with 36USD
09:58:13 <gwern> lilac: no, I was just considering whether I should move on up to Intrade and begin trading larger sums
09:58:30 <gwern> I seem to know what I'm talking about, inasmuch as I haven't lost money...
09:58:39 <lilac> gwern: do you need a gambling habit, though? ;-)
09:59:25 <gwern> lilac: I need such a gambling habit like I need money in my wallet :)
10:00:31 <Beelsebob> so you're rich then?
10:01:01 * gwern senses that my clever inversion of the usual expression has gone awry
10:01:24 <DuClare> Toxaris, Are you busy?
10:01:30 <Beelsebob> well, no one needs a gambling habbit -- so that means you don't need money in your wallet, so you must be rich
10:01:43 <gwern> to explain: I need a gambling habit which results in gains and not losses like I need money in my wallet, that is to say, I need them both in the same way
10:02:01 <Toxaris> DuClare: Hi not really. how's your Haskell going?
10:02:07 <gwern> (both being gains, and not losses)
10:02:12 <Beelsebob> but a gambling habbit by definition does not get you gains
10:02:27 <MathHat> ya, the gambling advantage of people who actually need money is taken away by the fat cats, more often than not
10:02:28 <DuClare> Toxaris, I haven't done much after our last time.  School sucks me dry :(
10:02:48 <gwern> Beelsebob: where is that defined? I have a habit of gambling on the IEM, and I seem to not have incurred losses
10:03:27 * gwern wonders if 'gambling habit' means any speculation you lose money on, and 'investment habit' anything you make money on?
10:03:32 <lilac> ?hoogle Monad m => Bool -> String -> m ()
10:03:33 <lambdabot> Language.Haskell.TH.Syntax.qReport :: Quasi m => Bool -> String -> m ()
10:03:34 <DuClare> Toxaris, But I came up with a real world problem that could make a good excercise
10:03:41 <Beelsebob> gwern: hehe, those are nice definitions
10:05:09 <GNU\caust1c> hi! does someone know a nice vim indention plugin?
10:05:28 <Toxaris> DuClare: yes?
10:05:58 <MathHat> vim has pretty nice indenting capabilities already...
10:05:58 <Beelsebob> GNU\caust1c: emacs?
10:06:07 <Beelsebob> sorry couldn't resist
10:06:09 <GNU\caust1c> :/
10:06:18 <GNU\caust1c> MathHat: for C, yes :>
10:06:31 <lilac> Is there an equivalent of guard which takes a string to pass to fail?
10:06:52 <DuClare> Toxaris, My server is running some tests as we speak.  The plain results are not really useluf as they are now, so I need to write something to parse & analyse them, and print both a summary and some more detailed statistics
10:06:57 <Beelsebob> lilac: all but the last 4 words of that sentence made sense
10:07:03 <Beelsebob> what do you want?
10:07:32 * gwern chortles over some of my stocks. I made so much money (percentage-wise) on McCain!
10:07:39 <MathHat> using shiftwidth tabstop softtabstop autoindent etc. isn't enough?
10:07:49 <lilac> Beelsebob: guard_ b s = if b then return () else fail s
10:07:54 <gwern> I bought McCain back at like 20cents a share, and he's at 92cents now
10:08:08 <gwern> 20 shares too :)
10:08:09 <GNU\caust1c> MathHat: i would like to have something that does all indention for me, when its possible
10:08:34 <MathHat> hmm, I don't know how much of that is possible in haskell, since indentation has some meaning
10:09:00 <DuClare> Useluf.  What a stupid sounding word.
10:09:14 <Beelsebob> lilac: oh, okay, I thought you meant a Haskell guard >.<
10:09:17 <GNU\caust1c> it could know that it has to indent after 'if' etc
10:09:42 <Beelsebob> GNU\caust1c: thing is that there are lots of different ways to indent Haskell
10:09:58 <Beelsebob> I think the best approach is to auto-indent to the previous line, and let the user chose
10:10:16 <lilac> GNU\caust1c: I've just started using this one: http://www.vim.org/scripts/script.php?script_id=1968 -- it seems ok
10:10:18 <lambdabot> Title: indent/haskell.vim - Haskell indent file : vim online
10:11:15 <Toxaris> Beelsebob: well, pattern matching failure calls fail in some situations, so you could imagine adding a user-defined error message
10:11:18 <lilac> Beelsebob: i thought you were put off by "to pass to fail"
10:11:54 <Beelsebob> lilac: well, I was, but I'd parsed the rest of the sentence wrong too
10:11:57 <lilac> and its self-contradictory nature
10:12:38 <GNU\caust1c> ill test it lilac, thx :)
10:12:45 <lilac> ok, that's it, i'm writing an LALR(1) grammar for english, and we're sticking to it, ok? :)
10:15:31 <dogbite> how do i request the ability to host code on code.haskell.org?
10:17:16 <ddarius> http://community.haskell.org/
10:17:17 <lambdabot> Title: Haskell Community Server
10:18:30 <DuClare> Toxaris, Each test essentially has initial data (which isn't important), a set of different inputs (or functions) and a corresponding set of results for each input.  There's one thing in common with all tests:  they will always have the same set of inputs, which means that by reading the first test, I could build a list of enums which pair input with a number, making it easier to do further processing on different tests but ...
10:18:36 <DuClare> ... same input
10:19:03 <DuClare> Toxaris, I'm not sure if I need to do some king of state saving to store the list of enums (which will then be used for every test)
10:20:51 <Toxaris> DuClare: "same sets of inputs"?
10:22:20 <Toxaris> DuClare: that means "exactly the same", so that you can represent the whole data set as (Input, [(Initial, Result)]) instead of [(Input, Initial, Result)]?
10:22:51 <DuClare> Toxaris, Meaning if we have three possible inputs, let's say #1, #2 and #3.  Then we have two tests and we want to compare the result of test1 with input #1 and the result of test2 with the same input (#1).  All further tests also must have the same inputs (#1, #2 and #3 in this case)
10:25:25 <DuClare> So test1 may have a list of inputs and list of results; test2 will have list of inputs which is exactly the same as list of inputs in test1, but the results differ
10:25:49 <Toxaris> DuClare: I understand that you have a set of inputs I1, I2, .. In, and a set of tests t1, t2, ..., tm. now your server runs each of the m tests on each of the n inputs to produces (m * n) results. one could imagine these results as placed in a m x n matrix. now you want to analyse one column of that matrix (same input, different tests)
10:27:21 <Toxaris> Toxaris: Obviously, if that is the case, you want to store the input only once, since it's the same for all tests anyway
10:28:19 <DuClare> Yup
10:29:37 <DuClare> To associate a column with an input, would enums work here?
10:31:06 <sclv> ?tell SamB Oh man, you were so right about map deserialization. I tried it, and the ord constraint has been killing me. grrr...
10:31:07 <lambdabot> Consider it noted.
10:33:11 <Toxaris> DuClare: what do you mean by "enums"?
10:34:36 <Toxaris> DuClare: I would probably start with   data Dataset = Dataset [Input] [[Output]]
10:35:28 <Toxaris> DuClare: and maybe refine that to something faster if needed (e.g. arrays if you need random access)
10:35:56 <shapr> yarr
10:35:59 <shapr> What's goin on?
10:36:17 <shapr> Who was working on the indentation based layout for variable width fonts?
10:37:16 <DuClare> Toxaris, Something that tells us the relation of x and y.  Imagine we have three possible inputs: money, dog and cat.  Thus in the matrix we have three columns for storing the result of data and input.  Now, when reading the actual file we're analyzing, reading test N, we encounter a line which says cat = 5;  So we put the result (5) to the 3rd column (because cat was the third possible input).
10:37:18 <mhiku> how can i recode this? http://www.youtube.com/watch?v=s_mIUCmZ7X0
10:37:26 <shapr> Hi! I've heard Haskell is really cool!
10:37:29 <DuClare> Toxaris, Although it could be that I'm just thinking too complicated
10:37:48 <shapr> DuClare: Do you like Haskell?
10:38:31 <DuClare> shapr, I'm interested in it.  Whether I really like it or not is something I'll find out when I've learnt it. :)
10:38:41 <shapr> Ah, that's a good point.
10:38:46 <shapr> How long have you been learning Haskell?
10:39:23 <DuClare> I think I started about a week ago, although I haven't been studying every day
10:39:53 <shapr> Seems easy?
10:39:54 <Toxaris> DuClare: sounds sensible. so you need a function   whichColumn :: String -> Int   which tells you which column to use to store a result in
10:40:37 <Toxaris> DuClare: and this function will be initialized while reading the first result set
10:41:09 <DuClare> Yeah
10:42:00 <shapr> I think I'll try to do something with Haskell today.
10:42:34 <chessguy> @get-slap
10:42:35 <lambdabot> shapr!!
10:42:39 <shapr> Yes?
10:42:53 <DuClare> :)
10:42:59 <Toxaris> DuClare: such a thing is called a "finite map" (because it maps a finite number of strings to ints), and a possible data structure to represent is bundled with Haskell in the Data.Map module
10:43:13 <chessguy> howdy :)
10:43:31 <shapr> hiya chessguy
10:43:34 <DuClare> Toxaris, Makes sense
10:43:37 * shapr installs the latest version of GHC
10:45:00 <Toxaris> DuClare: alternatively, you could just use a [String] to represent it, and use the index of the key as int value. that is, you search in the "caption row" of your matrix for the title, like you would to when manually inserting this data into a paper form
10:45:15 <Toxaris> > findIndex "dog" ["cat", "dog", "money"]
10:45:16 <lambdabot>  Couldn't match expected type `a -> Bool'
10:45:20 <Toxaris> :(
10:45:26 <Toxaris> @type findIndex
10:45:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
10:45:29 <Deewiant> > findIndex (=="dog") ["cat", "dog", "money"]
10:45:31 <lambdabot>  Just 1
10:46:46 <Deewiant> > let findEqualIndex = findIndex . (==) in findEqualIndex "dog" ["cat", "dog", "money"]
10:46:47 <lambdabot>  Just 1
10:48:24 <DuClare> Toxaris, Data.Map is something I'll probably need to learn to handle anyway, so I'll go with it
10:50:50 <mux> if I have a function that uses an IOArray to cache computations as an optimization, can I use unsafePerformIO if the usage of the array is completely contained in my function?
10:51:05 <conal> thetallguy: hi!
10:51:45 <thetallguy> conal: Howdy!
10:52:15 <thetallguy> conal: Nice to see your smiling handle!
10:52:32 <conal> :)
10:52:44 <conal> ditto
10:53:20 <DuClare> Toxaris, Seems like I don't have too much time to code right now, so I'll go read up on maps and think a little further.  Thanks a lot for your guidance again.
10:53:43 <thetallguy> conal: how goes the FRP struggle?
10:54:19 <DuClare> (The tests are probably running for a week so I'm not in a hurry, yet)
10:55:05 <conal> thetallguy: not sure.  there were some STM-related ideas floating around, but they don't really seem to work out, due to undesired unrolling of transactions.  i think i like the approach in my paper best so far.  still have to do some profiling, which is where i got stuck.
10:56:07 <thetallguy> conal: I saw that thread. Haven't yet investigated.  But it seems to jive with the difficulty I've had in dealing with caching over the years.  It's surprisingly tough.
10:56:52 <conal> thetallguy: and yet completely effortless, with purely functional data structures.
10:57:38 <conal> thetallguy: so my leaning is to work with the functional data structures, staying way away from IO or STM.
10:58:07 <thetallguy> conal: aye, and there's the rub.  Third item on my todo list:  Make the world purely functional.
10:58:33 <conal> thetallguy: mine is: notice that the world is purely functional.
10:59:02 <thetallguy> conal: You always get to play good cop, dang it.
10:59:11 <conal> ;p
10:59:33 <Korollary> the world with harddisks and peripherals?
10:59:49 <geezusfreeek> aha, more frp conversation!
11:00:00 <RayNbow> @where ghc manual
11:00:00 <lambdabot> http://haskell.org/ghc
11:00:28 <hehe> typing ":t error" in GHC gives Bad interface file: C:/ghc/GHC-68~1.2/lib\base-3.0.1.0/GHC/Err.hi
11:00:29 <hehe>     magic number mismatch: old/corrupt interface file?
11:00:30 <Cale> The world modelled mostly by purely declarative differential equations?
11:01:25 <thetallguy> Korollary: yes, harddisks are purely functional.
11:01:41 <Igloo> hehe: Is that repeatable?
11:03:12 <hehe> @Igloo now it gives the correct   error :: [Char] -> a
11:03:12 <lambdabot> Unknown command, try @list
11:03:50 <Igloo> *nod*, that sometimes happens on Windows. We don't know why.
11:04:07 <hehe> ok
11:05:03 <RayNbow> ok... GHC's generated C code is not human-readable :p
11:05:28 <mux> heh, my eyes hurt for you
11:13:34 <RayNbow> @src mapM_
11:13:34 <lambdabot> mapM_ f as = sequence_ (map f as)
11:13:39 <paczesiowa> is there some great list representation in which list type doesn't depend only on list value, but can be generalized/unified with other lists (e.g. expression if b then hSingleton 'a' else hSingleton "hi" would typecheck to something that can be converted to Maybe Char :*: Maybe String :*: HNil). I know that I can write my own if conditional, but I can't write case ..of (or can I?)
11:14:09 <Bonus> hmm
11:14:17 <Bonus> this http://hpaste.org/7359 is my solution to http://projecteuler.net/index.php?section=problems&id=92
11:14:33 <Bonus> but it takes like 30 seconds for one million numbers and i'm supposed to do 10 mil
11:14:38 <Bonus> anyone know how to optimize that?
11:16:17 <RayNbow> @src map
11:16:18 <lambdabot> map _ []     = []
11:16:18 <lambdabot> map f (x:xs) = f x : map f xs
11:17:09 <Bonus> or foldr (\acc x -> f x:acc) []
11:20:26 <RayNbow> > let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs
11:20:26 <lambdabot>  Parse error at end of input
11:20:34 <RayNbow> @let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs
11:20:34 <lambdabot> Defined.
11:20:41 <RayNbow> > fibs !! 999999
11:20:43 <lambdabot>  Exception: stack overflow
11:20:49 <yuran> Hi, i'm trying to learn haskell from yaht, and i'm having a problem with an excersize. Is this the place to ask?
11:21:03 <RayNbow> does anyone know why the stack overflow occurs?
11:21:10 <geezusfreeek> yuran: wouldn't be out of place here
11:21:29 <RayNbow> yuran: just ask :)
11:21:55 <Cale> Bonus: Probably memoise the results. You can use a boolean value to record whether the number arrives at 1 or 89.
11:22:13 <Bonus> hmmm
11:22:43 <Bonus> but there's only 1 pass
11:23:37 <Cale> Uhh... you're filtering the lists by their last element.
11:23:40 <Cale> last is O(n)
11:23:57 <sw17ch> does any one know how to capture audio from a mic with Haskell?
11:24:08 <Cale> (and you're recomputing the chains for each element)
11:24:29 <Bonus> yeah but each element has a different chain
11:24:36 <yuran> so here's the problem: http://hpaste.org/7360
11:24:43 <shachaf> sw17ch: readFile /dev/audio? :-)
11:24:47 <Cale> Bonus: That's not entirely true.
11:25:07 <Cale> Bonus: Once you hit a number you've computed before, you can know the result immediately.
11:25:17 <Bonus> hmmm
11:25:26 <yuran> i don't understand how i should treat the return value if it's a list of IO () ...
11:25:59 <geezusfreeek> yuran: haven't studied the code yet, but you mean you have something of type [IO ()]?
11:25:59 <Bonus> usually a list of IO () doesn't do much so you can just >> along
11:26:13 <yuran> geezusfreeek: at least i hope so :)
11:26:24 <Bonus> Cale: i don't see where each number is computed more than once here
11:26:38 <Bonus> because for each number from 1 .. 9999999 i generate a chain and check out the last element of the chain
11:26:50 <Bonus> and if the last element is 89 i count it, otherwise i dont
11:26:55 <Cale> Bonus: for each number from 1 to 9999999 you're applying chain, and looking at the last element, yes.
11:27:19 <Bonus> chain returns a (fairly short) list
11:27:23 <Cale> For example, look at the chain for 42 and then look at the chain for 20
11:27:33 <paczesiowa> yuran: why "[]" in  readNumbers [] ?
11:27:41 <Bonus> Cale: aaaaaaah!
11:27:45 <Bonus> now i see what you mean! :D
11:27:46 <Bonus> thanks
11:28:11 <Cale> No problem :)
11:28:34 <jdroid-> "Somewhat ironically, I think #haskell is the most active channel I'm in." I had to share that someone just said this to me.
11:28:36 <geezusfreeek> yuran: yeah, it doesn't look like readNumbers actually takes an argument
11:28:45 <Bonus> haha
11:28:47 <Bonus> why would that be ironic
11:28:50 <yuran> right, that was left over from an earlier version
11:29:08 <sw17ch> shachaf, i was hoping to tie into some other library :)
11:29:13 <yuran> ok, that fixed it :)
11:29:15 <jdroid-> Bonus: because haskell is lazy (ok... strict).
11:29:16 <yuran> thanks :)
11:29:21 <geezusfreeek> no prob
11:29:29 <Bonus> ah hehe
11:29:43 <Bonus> funny thing was when someone wrote into some report that haskell is one of the strictest languages
11:30:08 <geezusfreeek> yuran: by the way, i didn't notice anything that looked like its type was [IO ()] just so you know
11:32:56 <RayNbow> Cale, do you by any chance know why I get a stack overflow when I try to get the 999.999th element of a list?
11:33:18 <Bonus> RayNbow: is this with the fibs function?
11:33:25 <RayNbow> yeah, but I just found out...
11:33:31 <RayNbow> > [0..] !! 9999999
11:33:33 <lambdabot> Terminated
11:33:34 <RayNbow> also gives a stack overflow
11:33:37 <RayNbow> hmm
11:33:42 <RayNbow> oh
11:33:45 <Cale> RayNbow: because the elements of that list are expressions
11:34:19 <Cale> RayNbow: and the 9999999'th one is a very large expression to start off with
11:35:49 <RayNbow> Cale, would a stack overflow also occur eventually when you run this program? main = mapM_ print fibs where fibs = 0 : 1 : zipWith (+) (tail fibs) fibs
11:35:53 <Cale> RayNbow: If you compute them one by one, you won't get the stack overflow, because they share
11:35:58 <Cale> No.
11:36:08 <Cale> Because you're computing each element before the next.
11:36:12 <RayNbow> ah right
11:36:19 <Cale> and so the expressions never have a chance to get very large
11:36:26 <RayNbow> thanks :)
11:36:32 * RayNbow is seeing the light ^_^
11:36:38 <RayNbow> *sees
11:36:49 <Cale> It's important to remember that the stack doesn't measure what it does in strict languages.
11:36:54 <chessguy> if it's a bright white light, be careful not to walk into it
11:37:23 <Cale> It effectively measures the distance between the expression you're trying to evaluate as a whole and the shallowest reducible subexpression of it.
11:38:42 <Bonus> Cale: would you suggest i do the memoizing in that chain function by giving it a Map of already computed stuff?
11:39:11 <dolio> > let (x:_) !!! 0 = x ; (x:xs) !!! n | n > 0 = x `seq` xs !!! (n-1) ; _ !!! _ = error "Bad index." in [0..] !!! 9999999
11:39:16 <lambdabot>  9999999
11:39:57 <Cale> Bonus: that would work
11:40:30 <Cale> Bonus: You could also have a giant array of Bool, up to a certain size, which would be used to store previous results.
11:40:49 <Cale> (well, the entries would be recursively computed)
11:41:15 <Bonus> ah yeah that could work too
11:49:05 <RayNbow> @src zipWith
11:49:06 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:49:06 <lambdabot> zipWith _ _      _      = []
11:50:42 <tromp> @src zip
11:50:42 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
11:50:42 <lambdabot> zip _      _      = []
11:51:03 <tromp> why not zipWith (,) ?
11:51:10 <tromp> :t (,)
11:51:12 <lambdabot> forall a b. a -> b -> (a, b)
11:52:33 <eyeris> I'm trying to find documentation for WASH's session support
11:54:05 <eyeris> The WASH.CGI.Persistent2 module doesn't seem to provide much
11:55:05 <eyeris> It seems like just a way to save persistent data. It doesn't seem to do any work to link the data to the remote client
11:55:23 <eyeris> which is half of the reason for a library to support "sessions"
11:56:01 <TomMD> What version of GHC benefited from the function specialization SPJ presented at ICFP '07?
11:56:33 <eyeris> Probably 6.8.2
12:03:04 <RayNbow> @src (!!)
12:03:04 <lambdabot> xs     !! n | n < 0 = undefined
12:03:04 <lambdabot> []     !! _         = undefined
12:03:04 <lambdabot> (x:_)  !! 0         = x
12:03:04 <lambdabot> (_:xs) !! n         = xs !! (n-1)
12:03:47 <quicksilver> TomMD: SpecConstr was in 6.8.0
12:03:52 <quicksilver> TomMD: although there was a bug in it :)
12:04:07 <TomMD> The bug harmed performance or correctness?
12:04:10 <quicksilver> TomMD: pointer tagging too. (was that in the paper?)
12:04:15 <quicksilver> not correctness.
12:04:23 <quicksilver> but it didn't always fire.
12:05:55 <casral> Is there a haskell interpreter than you can use similar to #!/bin/bash or #!/bin/perl
12:05:58 <casral> ?
12:06:15 <dolio> runhaskell
12:06:20 <vixey> > let foldnat s z 0 = z ; foldnat s z (n+1) = s (foldnat s z n) ; list !! n = foldnat (tail .) head n list in [1..] !! 6
12:06:21 <lambdabot>  Parse error in pattern at ";" (column 63)
12:08:05 <casral> like #!/bin/runhaskell ?
12:08:57 <dolio> Something like that.
12:09:01 <casral> ty
12:09:05 <shachaf> casral: If you put things like that in /bin. :-)
12:09:35 <lilac> is there a nicer way of writing (:[]) ?
12:09:47 <nominolo> @seen dons
12:09:48 <lambdabot> dons is in #haskell-hac4, #haskell-soc, #xmonad and #haskell. I last heard dons speak 11h 38m 56s ago.
12:09:59 <shachaf> lilac: return
12:10:13 <shachaf> > pure 5 :: [Int]
12:10:14 <dlisboa> how can I execute two functions sequentially?
12:10:14 <lambdabot>  [5]
12:10:28 <shachaf> dlisboa: That depends on what you mean.
12:10:35 <dufflebunk> dlisboa: sequence ?
12:10:39 <lilac> shachaf: i'm in another monad... "foo >>= return.return" looks like it's going to be hard to read
12:10:58 <dufflebunk> or possibly sequence_
12:11:10 <vixey> > let foldnat s z n = if n == 0 then z else s (foldnat s z (n-1)) in head . foldnat (tail .) id 6 $ [1..]
12:11:12 <lambdabot>  7
12:11:29 <Kamina> dlisboa: you mean perhaps something like:  (sin . cos) 5
12:11:39 <vixey> can you change id to something useful in this?
12:11:56 <Kamina> dionoea: (sin . cos) 5  is the same as  sin (cos 5)
12:11:58 <TomM1> quicksilver: Thanks! And no, pointer tagging is in a different paper from specialization.
12:12:01 <dlisboa> Kamina: no. I'll put up some code to explain, just a minute
12:12:42 <shachaf> @let cookiemonster = (:[])
12:12:43 <lambdabot> Defined.
12:13:21 <allbery_b> @quote Help!
12:13:22 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
12:14:02 <shachaf> allbery_b: The question is what that comment was doing before it was being eaten.
12:14:05 <vixey> (:[]) seems like the nicest way to write it to me
12:14:19 <vixey> you could call it box1 I guess
12:14:26 <vixey> box2 :: a -> a -> [a], etc
12:18:27 <dlisboa> Kamina: http://pastebin.com/d45812f6e
12:18:33 <dlisboa> that's what I intended to do.
12:18:46 <dlisboa> probably not the right way to do it, but well...
12:20:30 <dufflebunk> dlisboa: What do you want to do with the two results?
12:23:50 <dlisboa> dufflebunk: hmm. Shouldn't be two values...the function is wrong.
12:24:31 <vixey> @instances-importing Applicative
12:24:32 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
12:24:38 <vixey> :C
12:24:56 <Deewiant> @instances Applicative
12:24:56 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
12:25:02 <Deewiant> @instances-importing Control.Applicative Applicative
12:25:03 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
12:25:13 <vixey> thank you
12:25:18 <Deewiant> no problem
12:25:25 <Deewiant> remember @help :-)
12:25:49 <dufflebunk> dlisboa: Oh, you want to search the left, and if not found you want to search the right?
12:26:05 <dlisboa> dufflebunk: yup.
12:26:43 <ddarius> Then you need to say that.
12:27:23 <ddarius> (I don't mean to us, though that would've helped too.)
12:27:30 <dlisboa> he
12:28:17 <dlisboa> cool, I got. I was afraid it wouldn't return Nil in case it was not found on the right too...stupid.
12:28:22 <dlisboa> I got it*
12:30:55 <mgsloan> are there any good tuts for learning ocaml, with previous haskell knowledge? Learning by equivalencies and differences
12:50:30 <ddarius> mgsloan: Ask the O'Caml people.
12:52:43 <mgsloan> yeah, I just have :P
12:52:50 <mgsloan> don't worry I'm not going over to the dark side
12:54:36 <Korollary> mgsloan: This one may give some of the detail you want: http://pauillac.inria.fr/~remy/cours/appsem/
12:54:38 <lambdabot> Title: Using, Understanding, and Unraveling The OCaml Language From Practice to Theory  ...
12:57:57 <mgsloan> yeah, that one looks pretty good :) isn't a boring nooby tut
13:00:39 <dbpatterson> I'm writing a wrapper to the json api smugmug (a photo site) - here is my problem
13:01:06 <dbpatterson> I want to statically type things - as this is not only appropriate for haskell, but just overall safer
13:01:15 <sfultong> what's the significance of Data.ByteString.Char8 versus the regular Data.ByteString interface
13:01:15 <sfultong> ?
13:01:28 <mauke> Char vs Word8
13:01:54 <dbpatterson> so I've taken the json structures (converted to Data.Map's) and filled them into data structures corresponding to what the requests return
13:02:57 <sfultong> mauke: but why have that distinction?  is char sometimes unicode, sometimes not?
13:02:58 <dbpatterson> but, when you factor in some things are optional,and others available to only the owners, you end up with many many data structures each with perhaps 20 fields, many Maybe fields.. which would be awful to pattern match against (_ _ _ field _ _ _ _ _ _ _ _ _ _ _, etc)
13:03:24 <dbpatterson> and naming the fields wouldnt allow different data structurs with the same fields use the same accessors (I believe)
13:03:25 <mauke> sfultong: no, Char is always unicode
13:03:38 <dbpatterson> so, is there a clear, friendly solution?
13:03:49 <sfultong> mauke: ah, thanks
13:06:12 <dbpatterson> should I just go back to using maps and push the guarantees back to the user?
13:07:15 <ddarius> dbpatterson: You could implement the "accessors" as methods of a type class.
13:09:52 <sclv> we were just talking about this yesterday
13:10:23 <sclv> here's some code that someone came up with which is pretty nice: http://hpaste.org/7342
13:18:56 <dmwit> Haskell++
13:19:04 <dmwit> file = many line
13:19:17 <dmwit> -- an excerpt from some Actual Code
13:19:18 <mauke> file = many line <* eof
13:19:23 <dbpatterson> ddarius: can you expand on that?
13:20:13 <dmwit> mauke: Oh.  Bummer.  I guess it will cause problems if I don't explicitly catch the eof?
13:20:28 <mauke> depends on the definition of "line"
13:20:34 <vixey> if many is greedy ? why would it be a problem
13:20:40 <dmwit> line has "spaces" at the end.
13:21:04 <mauke> does it match anything?
13:21:12 <dmwit> No.
13:21:33 * dmwit tests it
13:21:44 <mauke> it's possible that the parse succeeds but silently discards anything from the first malformed line
13:21:48 <dbpatterson> sclv: that looks pretty nice. basically just adding friendly wrappers around map, right?
13:22:42 <sclv> right -- via typeclasses which can sort of enforce properties, as long as you don't circumvent them.
13:22:56 <dmwit> mauke: Not according to my tests.
13:23:13 <dmwit> mauke: (I'm pretty sure Parsec tries to match the entire string.)
13:23:39 <mauke> hmm
13:24:06 <MarcWeber> mauke: I recall there is a end of tokens parser use that at the end
13:24:08 <dmwit> Anyway, I'm not too worried about error-handling at this point.
13:24:14 <dmwit> This is more a script than a real program.
13:24:39 <mauke> The main parser needs to skip any whitespace at the start of the input (since all other parsers only skip trailing whitespace) and needs to end with the eof parser which only succeeds at the end of the input. This parser garantees that all input will be parsed; if it is left out, a parser is allowed to parse only part of the input.
13:25:26 <SyntaxNinja> w00t
13:26:17 <dmwit> readFile "test" >>= parseTest file -- gives a Parsec error if the "test" has malformed lines
13:26:19 <dmwit> *shrug*
13:26:39 <mauke> again, this depends on the definition of 'line'
13:27:31 <dmwit> line ~= many letter >> spaces >> char ':' >> spaces >> string "$xxx.xx" >> spaces
13:28:32 <mauke> parseTest file "- whee"
13:28:55 <dmwit> ooo
13:28:59 <dmwit> Nasty. =)
13:29:39 <dmwit> My malformed line wasn't malformed enough. =P
13:29:42 <sclv> dbpatterson: I just updated it with an implementation using generics too :-) http://hpaste.org/7342#a2
13:29:59 <mauke> in your case you have to make it fail at the first char
13:30:29 <dmwit> No instance for (Applicative (GenParser Char ())) =/
13:32:11 <sclv> ?seen Kamina
13:32:11 <lambdabot> Kamina is in #haskell. I last heard Kamina speak 1h 20m 14s ago.
13:33:01 <sclv> ?tell Kamina -- I updated the paste with a solution using generics: http://hpaste.org/7342#a2
13:33:01 <lambdabot> Consider it noted.
13:33:25 <dbpatterson> sclv: hmm. so to use this (in my example) I would be making type classes (generic versions) for each attribute I needed (ie, HasColor, HasId, Has-etc)?
13:33:43 <dbpatterson> actually that makes no sense.
13:34:02 <sclv> why not?
13:34:35 <dbpatterson> hmm, maybe I'm just not understanding how it is working, let me look at the code closer...
13:35:38 <dmwit> ?pl \x -> fmap (const x) m
13:35:38 <lambdabot> flip fmap m . const
13:36:36 <dbpatterson> sclv: wow. maybe I should have just found out about generics earlier... that looks like it will make it much much easier...
13:37:21 <lilac> is there a nice way to write something like (*16+)
13:37:41 <vixey> \x y -> x * 16 + y
13:37:42 <dmwit> Lambda expand that for me.
13:38:18 <sclv> if you're working with trees, generics can do all sorts of cool things.
13:38:23 <dmwit> :t ((*16) .) . (+)
13:38:25 <lambdabot> forall a. (Num a) => a -> a -> a
13:39:06 <dmwit> :t ((+) .)
13:39:08 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f (a -> a)
13:39:30 <dmwit> :t (+) . (*16)
13:39:33 <lambdabot> forall a. (Num a) => a -> a -> a
13:39:36 <shachaf> @ty (*16) .: (+)
13:39:38 <lambdabot> forall a. (Num a) => a -> a -> a
13:39:43 <lilac> that's the one. (+).(*16)
13:40:34 <vixey> \x y -> x * 16 + y
13:40:35 * johnnowak wants postfix haskell
13:40:43 <dmwit> ?quote stack
13:40:44 <lambdabot> ghc says: internal error: scavenge_mark_stack: unimplemented/strange closure type -1368815400 @ 0x2aaaae6981f8
13:40:53 <dmwit> ?quote push.end
13:40:53 <lambdabot> No quotes match. :(
13:41:03 <saml> > product [..50]
13:41:04 <lambdabot>  Parse error at "..50]" (column 10)
13:41:16 <dmwit> > reverse [50..]
13:41:20 <lambdabot> Terminated
13:41:29 <dmwit> saml: How far back do you want to go? ;-)
13:41:48 <dmwit> > product [minBound..50] :: Int
13:41:53 <lambdabot> Terminated
13:42:02 <dons> johnnowak: seen okasaki's paper on postfix for haskell?
13:42:26 <shachaf> dmwit: Down to the last turtle.
13:42:29 <dmwit> ?quote stack-calculator
13:42:29 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
13:42:38 <dons> johnnowak: "Techniques for Embedding Postfix Languages in Haskell"
13:42:39 <johnnowak> dons: no -- just found it
13:42:45 <johnnowak> thanks
13:42:54 <saml> > product [1..2**32]
13:42:59 <lambdabot>  out of memory (requested 1048576 bytes)
13:43:13 <vixey> > 2**(sum [1..32])
13:43:13 <dons> > product [1..(2**32::Int)]
13:43:14 <lambdabot>   add an instance declaration for (Floating Int)
13:43:14 <lambdabot>     In the expression: (2 **...
13:43:15 <lambdabot>  8.786941004967181e158
13:43:22 <dons> > product [1..(2^32::Int)]
13:43:23 <lambdabot>  1
13:43:36 <dons> oh, that's a 32 bit box.
13:43:37 <vixey> > 2**(sum [1..32])
13:43:38 <lambdabot>  8.786941004967181e158
13:43:40 <dons> > maxBound :: Int
13:43:40 <vixey> oh I see
13:43:41 <lambdabot>  2147483647
13:43:42 <TomMD> No instance of Show or Ord for Errno?  What is this, the dark ages?
13:43:50 <tromp> > (2^32::Int)
13:43:50 <dons> errno?
13:43:51 <vixey> > product [1..5]
13:43:51 <lambdabot>  0
13:43:52 <lambdabot>  120
13:44:04 <TomMD> As in Foreign.C.Error.Errno
13:44:09 <TomMD> or whatever
13:44:12 <TomMD> @hoogle Errno
13:44:13 <lambdabot> Foreign.C.Error.Errno :: newtype Errno
13:44:13 <lambdabot> Foreign.C.Error.Errno :: CInt -> Errno
13:44:13 <lambdabot> Foreign.C.Error.errnoToIOError :: String -> Errno -> Maybe Handle -> Maybe String -> IOError
13:44:13 <dons> newtype Errno = Errno CInt
13:44:21 <dons> oh that's weird.
13:44:26 <johnnowak> dons: doesn't seem as if it works too well. those types are quite ugly and there's no HOFs
13:44:27 <saml> > maxBound :: Int == 2 ** 32
13:44:27 <lambdabot>  Parse error at "==" (column 17)
13:44:29 <dons> -- The implementation is deliberately exposed, to allow users to add
13:44:29 <dons> -- their own definitions of 'Errno' values.
13:44:38 <dons> johnnowak: i'd agree :)
13:44:52 <dons> TomMD: i think patches here would be gladly accepted. its a little used module
13:45:02 <dons> or, not used in a high level way, anyway
13:45:03 <TomMD> Sounds good
13:45:33 <dons> and its a newtype , so a bit of deriving would be good
13:46:52 <johnnowak> dons: compare the definition of 'fib' in the paper to the joy [small?] [succ] [pred dup pred] [+] binrec
13:46:59 <johnnowak> ah well.
13:48:08 <saml> > let fib n = (zipWith (+) [1..] [2..]) !! n in fib 7
13:48:10 <lambdabot>  17
13:48:27 <vixey> > zipWith (+) [1..] [2..]
13:48:28 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
13:48:39 <saml> i fail
13:48:43 <vixey> :P
13:48:48 <vixey> :t scanl
13:48:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
13:49:02 <ddarius> > fix ((0:).(1:).ap(zipWith(+))tail)
13:49:03 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:49:45 <vixey> > map fst . iterate (\(x,y)->(y,y+x)) $ 1 -- my favorite
13:49:47 <lambdabot>   add an instance declaration for (Num (a, a))
13:49:52 <vixey> > map fst . iterate (\(x,y)->(y,y+x)) $ (0,1) -- oops
13:49:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:50:15 <dmwit> ?pl \(x, y) -> (y, y+x)
13:50:15 <lambdabot> uncurry (ap (,) . (+))
13:50:16 <vixey> although maybe (\(x,y)->(y,y+x)) can be written other ways?
13:50:47 <ddarius> vixey: Not in a shorter way.
13:56:18 <TomMD> Does ghc have patch guidelines anywhere?
13:56:27 <TomMD> As in, submission guidelines.
13:57:01 <dons> yeah, gimme a sec.
13:57:24 <dons> http://haskell.org/haskellwiki/Library_submissions
13:57:36 <dons> base library patches fall under this. you send a mail to libraries@ and open a ticket
14:04:06 <Igloo> There's also http://hackage.haskell.org/trac/ghc/wiki/WorkingConventions/FixingBugs
14:04:08 <lambdabot> Title: WorkingConventions/FixingBugs - GHC - Trac, http://tinyurl.com/6ruzzd
14:08:15 <SyntaxNinja> does cron run as root on debian?
14:12:21 <dmwit> SyntaxNinja: It does here, under Ubuntu.
14:12:38 <dbpatterson> question - could I use generics (or any other method) to get the name of the data type in string form? the reason is I have lots of really repetative code to marshal data from json into haskell types. generally it as simple as testing if the value is in the json map (where the key in the map is the name of the type), and if it exists then pulling it out. of course, this works recursively for more complex types, going through each fiel
14:13:21 <dons> dbpatterson: you want the type name in the map?
14:13:27 <mauke> > show (typeOf ())
14:13:28 <lambdabot>  "()"
14:13:30 <dons> use Typeable or Data.Generics
14:13:41 <dons> > show (typeOf (undefined :: Int -> Bool))
14:13:42 <lambdabot>  "Int -> Bool"
14:13:50 <mauke> > show (typeOf 42)
14:13:52 <lambdabot>  "Integer"
14:14:04 <dons> there's some other ways you can do this (a map of extistentials)
14:14:10 <vixey> show (typeOf typeOf)
14:14:16 <vixey> > show (typeOf typeOf)
14:14:17 <lambdabot>  Add a type signature
14:14:17 <ddarius> > getConstr Just
14:14:18 <lambdabot>   Not in scope: `getConstr'
14:14:19 <dons> polymorphic stuff won't fly
14:14:24 <vixey> oh I see
14:14:47 <mauke> :t typeOf
14:14:49 <lambdabot> forall a. (Typeable a) => a -> TypeRep
14:15:01 <mauke> > show (typeOf (typeOf :: Char -> TypeRep))
14:15:03 <lambdabot>  "Char -> TypeRep"
14:15:30 <dbpatterson> hmm... well I have a typeclass class JRead c where   jread :: J.Value -> Maybe c
14:15:43 <dbpatterson> and in jread I need to get the type of c, as a string
14:15:54 <dbpatterson> would that work?
14:15:59 <dbpatterson> (hmm, I should just try it)
14:16:57 <ddarius> > toConstr (Just 3)
14:16:58 <lambdabot>  Just
14:17:57 <dbpatterson> ddarius: but to get Maybe out of that?
14:18:22 <mauke> > typeOf (Just 3)
14:18:23 <lambdabot>  Maybe Integer
14:18:25 <dbpatterson> actually, most of these types dont have multiple constructors, so it would be okay
14:20:32 <dbpatterson> no, it is more complicated.. because the function is polymorphic, but it needs to be able to figure out which instantiation of itself it is...
14:20:32 <SyntaxNinja> dmwit: thanks
14:20:36 <saml> > toConstr (StateT)
14:20:36 <lambdabot>        add an instance declaration for
14:20:36 <lambdabot>       (Data (StateT s m a), Data (m (a...
14:22:24 <dbpatterson> is there a way to to typeOfSelf?
14:22:27 <dbpatterson> to do*
14:23:01 <vixey> what's self?
14:23:15 <dbpatterson> self is the function in which typeOfSelf is used :)
14:23:46 <vixey> I dont think self is defined in haskell
14:23:57 <dbpatterson> vixey: thats the problem :)
14:24:13 <vixey> what is it you are writing?
14:24:27 <dbpatterson> it is a wrapper around a json api
14:24:31 <Cale> dbpatterson: Universally polymorphic functions are not allowed to determine which instantiation they are. That's actually an important thing.
14:24:58 <TomMD> "darcs send --output" results in a 81KB patch?!  Is this normal?
14:25:04 <Cale> dbpatterson: If I write a function [a] -> Integer, it's not allowed to suddenly sum the elements of the list when a = Integer, and measure its length otherwise.
14:25:07 <TomMD> The change (darcs record) was just one line
14:25:29 <harish> TomMD: use git
14:25:58 <Botje-Eet-> TomMD: darcs sends the list of patches yours is based on
14:26:01 <TomMD> harish: Let us not start a flame war here.  Git is not an option when the group doesn't use git.
14:26:11 <harish> ah alright
14:26:30 <sclv> Cale: if you write a function (Typeable a) => [a] -> Integer, you could though?
14:26:35 <Cale> yeah.
14:26:39 <dbpatterson> Cale: do you have any ideas of how I might figure this problem out then? (this is a map containing key -> values, and I want to read them into haskell types, without manually traversing each level)
14:27:01 <dbpatterson> wait, so if they are typeable I can figure out which instantiation it is?
14:27:20 <Cale> yes
14:27:27 <Cale> (that's the point of Typeable)
14:28:18 <dbpatterson> so I'm still wondering how I do that in a function to itself...
14:28:27 <dbpatterson> I understand that typeOf myfunc would work
14:28:35 <sclv> what's the ultimate typesig you want?
14:28:52 <visof_> what is the type of this function "second xs  = head ( tail xs)
14:28:53 <visof_> ?
14:29:02 <dbpatterson> sclv: jread :: J.Value -> Maybe c
14:29:11 <dbpatterson> where J is Text.Json
14:29:15 <Cale> visof_: [a] -> a
14:29:21 <Cale> visof_: You can ask ghc you know :)
14:29:46 <yitz> @type head (tail xs)
14:29:48 <lambdabot> Not in scope: `xs'
14:29:55 <vixey> @type head (tail ?xs)
14:29:57 <lambdabot> forall a. (?xs::[a]) => a
14:30:00 <yitz> @type \xs -> head (tail xs)
14:30:02 <Cale> @type let second xs = head (tail xs) in second
14:30:03 <dmwit> ?type let second xs = head (tail xs) in second
14:30:03 <lambdabot> forall a. [a] -> a
14:30:05 <lambdabot> forall a. [a] -> a
14:30:07 <lambdabot> forall a. [a] -> a
14:30:10 <Cale> heh
14:30:13 <dbpatterson> sclv: if Value is a map it should check for c in it (converting type to string) and if it is there, return it... if that makes sense
14:30:20 <dmwit> Cale: '?' is superior to '@' ;-)
14:30:39 <dbpatterson> Value being an Object (a map), an Array, a String, an Integer, or a Bool
14:30:56 <Cale> dbpatterson: Why not just construct a single datatype which holds each of those options?
14:31:02 <Cale> er...
14:31:10 <Cale> oh, I see what you mean.
14:31:20 <Cale> class FromValue t where
14:31:21 <dbpatterson> as in, right now I am creating this for each type: instance JRead Public where
14:31:23 <OceanSpray> Who comes up with the syntax for languages like Haskell, anyway?
14:31:26 <dbpatterson>     jread j = if (jmember "Public" j)
14:31:29 <dbpatterson>                 then (Just $ Public (unb (j </> "Public")))
14:31:30 <OceanSpray> sometimes, they just seem so arbitrary.
14:31:32 <dbpatterson>                 else Nothing
14:31:37 <Cale>    jread :: J.Value -> Maybe t
14:31:41 <dbpatterson> that is for the data Public = Public Bool
14:31:52 <sclv> the text.json library seems like it already has encoders and decoders written you can leverage?
14:32:11 <Cale> dbpatterson: That's what I'd probably do.
14:32:13 <dbpatterson> sclv: that is what is creating the Values, I believe...
14:32:32 <dbpatterson> Cale: sorry, how is that different from what I have?
14:32:37 <Cale> dbpatterson: It's not.
14:32:46 <Cale> dbpatterson: What's wrong with what you already have?
14:33:11 <sw17ch> If I want to zap data structures across a network, i want to use Foreign.Storable right?
14:33:15 <dbpatterson> that for every type I am using, I copy and paste a version of what I pasted above, and change just the string of the name
14:33:25 <mauke> sw17ch: or Read/Show
14:33:38 <yitz> sw17ch: Binary
14:33:38 <dbpatterson> generally any copy and pasting makes me think I am doing something wrong :)
14:33:48 <ddarius> dbpatterson: Just abstract out that string.
14:33:49 <sclv> dbpatterson :; you should think in terms of "instance JSON myRecord where" .. I think?
14:34:13 <solrize_> jread j = do {guard $ jmember "Public" j; return Public $ unb (j </> "Public") }
14:34:46 <dbpatterson> solrize_: I still have to put that in for every data type
14:34:55 <Cale> dbpatterson: Also, how is this different from  readJSON?
14:35:00 <ddarius> jread' name f j = if jmember name j then Just (f (unb (j </> name))) else Nothing
14:35:08 <ddarius> jread j = jread' "Public" Public
14:35:11 <sw17ch> yitz: binary?
14:35:14 <sw17ch> @hoogle binary
14:35:15 <lambdabot> System.IO.withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
14:35:15 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
14:35:15 <lambdabot> System.IO.hSetBinaryMode :: Handle -> Bool -> IO ()
14:35:17 <dbpatterson> what is the type of readJSON?
14:35:27 <Cale> JSValue -> Result a
14:35:38 <solrize_> dbpatterson you can't do that if f is a type constructor
14:35:42 <Cale> Where Result is kind of like Either String
14:36:02 <solrize_> oh thats dons's json lib.  has anyone done speed tests on that?
14:36:30 <sclv> right: this is just the beginning bit, but it makes sense to leverage off the parser stuff already in Text.JSON rather than redo it...
14:36:45 <yitz> sw17ch: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.4.2
14:36:47 <lambdabot> http://tinyurl.com/59vv3y
14:36:49 <Cale> Well, I don't know which package we're actually talking about...
14:36:56 <dbpatterson> hmm, that is a different json lib than I am using...
14:37:03 <Cale> I just looked on hackage for json and went with the first thing I found.
14:37:08 <dbpatterson> the one I have is by (c) Masahiro Sakai & Jun Mukai 2006
14:37:22 <Cale> Is it on Hackage?
14:37:25 <solrize_> dbpatterson i used the one you were using and it was pretty slow
14:37:37 <solrize_> cale, no, that japanese one is not on hackage, dons loaded his very recently
14:37:37 <sclv> oh wait -- this is the new one galois just released!
14:37:37 <dbpatterson> I dont think it is, Cale...
14:38:11 <solrize_> so i'd been using the japanese one, but switched to a python to binary serializer followed by Data.Binary, since the haskell json module was so slow
14:38:18 <solrize_> so i was wondering if the galois one was faster
14:38:33 <Cale> dbpatterson: If there were a million different JSON types, then I'd worry about the typeclass solution.
14:38:48 <Cale> dbpatterson: There are only a handful though, and that doesn't seem likely to change...
14:38:57 <dbpatterson> dbpatterson: hmm... well there are going to be a lot
14:39:05 <dbpatterson> because I'd like the api to be fully strongly typed
14:39:24 <dbpatterson> not just a lot of maps where you have to check if attributes are there...
14:39:28 <sclv> what are you binding to again?
14:39:31 <dbpatterson> errm, Cale *
14:39:36 <dbpatterson> smugmug.com
14:39:36 <chessguy> what does "fully" strongly typed mean?
14:40:04 <dbpatterson> chessguy: it means that the whole api consists of types that can be understood before runtime
14:40:11 <Cale> Note that Haskell's type system is a purely compile-time thing... sometimes using it as if it were a dynamic type system will get you into annoying problems.
14:40:33 <dbpatterson> ie, getSomething is Session -> Somekey -> Something
14:40:43 <dbpatterson> instead of getSomething :: Session -> Somekey -> Map
14:40:43 <Cale> Though of course, typeclasses sort of blur the lines somewhat.
14:40:43 <chessguy> dbpatterson, haskell's type system is already strong
14:41:00 <sclv> I see what you mean by a large api: http://wiki.smugmug.com/display/SmugMug/1.2.0
14:41:01 <lambdabot> Title: 1.2.0 - SmugMug Wiki
14:41:03 <dbpatterson> chessguy: not when you replace types with maps
14:41:10 <dbpatterson> sclv: yeah... it is big.
14:41:15 <solrize_> dbpatterson maybe you want generics
14:41:42 <sclv> I think if you use the galois lib it should be pretty straightforward to write the sort of parser you want.
14:41:48 <dbpatterson> solrize_: hehe, I was there before.. figured out how to use it for accessing (thanks sclv) but it is the creating them I'm still having trouble with
14:41:54 <dbpatterson> sclv: link?
14:42:09 <sclv> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/json-0.3.3
14:42:16 <lambdabot> http://tinyurl.com/5ngo66
14:42:20 <solrize_> db, templates
14:42:32 <sclv> yeah -- creating is hard, or at least nontrivial :-) i had to read a bunch of examples to get it.
14:42:44 <Cale> Note that the kinds of APIs which OO people come up with can be extremely annoying to use if you try to statically type everything in Haskell. They tend to consist of large product types, which don't fit terribly well with functional programming.
14:42:50 <sclv> and especially if you want named record fields rather than just types.
14:43:28 <sclv> its feasible though -- i'm building a cute high level sql embedding based on it.
14:44:13 <solrize_> cale what should they do instead?
14:44:22 <dbpatterson> Cale: I'm beginning to realize this - look at this http://smugmug.jot.com/WikiHome/1.2.0/smugmug.images.getInfo
14:44:55 <dbpatterson> sclv: which will make its way into hvac? :)
14:45:08 <solrize_> json is reasonable for that except the only numbers in json are doubles :(
14:45:18 <sclv> yeah -- and also be a separate lib. its too cool to tie to the framework.
14:45:24 <solrize_> i just used the doubles anyway but had an extraction function that barfed on non-integral ones
14:45:33 <saml> how would you quickcheck a typeCheck :: String -> TCMonad Type  function?
14:45:53 <dbpatterson> sclv: are the examples in the tarball?
14:46:06 <dons> saml: provided an unTC function of some kind
14:46:14 <dons> or runTC
14:46:15 <sclv> dbpatterson: of hvac?
14:46:21 <sclv> not yet
14:46:27 <sclv> ?where syb
14:46:27 <lambdabot> http://www.cs.vu.nl/boilerplate
14:46:34 <Cale> dbpatterson: Yeah, sometimes a big Map can feel a bit awkward conceptually, but still be very convenient.
14:46:40 <sclv> the generics papers -- not bad going as they go.
14:47:34 <solrize_> haskell is type-unsound because of Typeable
14:47:50 <Cale> solrize_: Only because you're allowed to define your own instances rather than deriving them.
14:48:27 <solrize_> hmm
14:48:29 <Cale> If the GHC people just made it an error to write instances of Typeable manually, that problem would go away :)
14:49:05 <dbpatterson> sclv: no no of json
14:49:08 <solrize_> but the whole purpose of generics is to not limit automatic deriving to a few magic classes, i thought
14:49:15 <sclv> dbpatterson: beats me
14:49:20 <Cale> solrize_: nope
14:49:28 <Cale> solrize_: Well, sort of.
14:49:37 <dbpatterson> Cale: is your recommendation to just live with the map and stick with writing a few accessors (that die in a friendly way)
14:49:38 <MathHat> if this is a question of data languages, yaml can include info about constypes, and differentiates between integer/float.
14:49:39 <dons> dbpatterson: which json lib are you using, btw?
14:49:47 <dbpatterson> dons: not yours, apparently :)
14:49:52 <dons> ah.
14:49:53 <dbpatterson>  (c) Masahiro Sakai & Jun Mukai 2006
14:49:59 <dons> there's newer ones.
14:50:04 <Cale> dbpatterson: That's probably how I'd go. After all in javascript, effectively everything is a map anyway.
14:50:11 <dons> though they're all roughly similar
14:50:26 <dbpatterson> dons: yeah, I think I'm going to change it...
14:50:29 <Cale> dbpatterson: The problem is really with the API itself -- you can try to impose a statically typed shell on it, but it might get ugly.
14:50:35 <dons> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fcgi-bin%2Fhackage-scripts%2Fpackage&as_q=json+
14:50:37 <lambdabot> Title: json site:hackage.haskell.org/cgi-bin/hackage-scripts/package - Google Search, http://tinyurl.com/6jln47
14:50:37 <solrize_> dons do you know if the one you uploaded recently is faster than the one dbpatterson is using?
14:50:50 <dbpatterson> Cale: yeah.. I was hoping I would make it friendlier for the end user in haskell :)
14:51:00 <dbpatterson> but alas.. it may just be too massive
14:51:03 <dons> solrize_: hmm, no.
14:51:24 <solrize_> thanks
14:51:30 <Cale> dbpatterson: Well, you might ask yourself how you want code using the API to look first.
14:51:41 <Cale> dbpatterson: and then design the wrappers around that conception...
14:52:07 <Cale> It's a bit like language design :)
14:52:08 <dbpatterson> Cale: that was what I was trying to do...
14:52:33 <dbpatterson> thinking that anyone using it would appreciate that it is totally static
14:52:46 <dbpatterson> I guess I can just add some checks on top of the maps
14:52:51 <solrize_> dbpatterson i think i tried basically the same thing you're trying, and it was just too messy, so i did stuff directly on the json structures and that was a lot easier but it was so slow i had to trash it anyway.
14:52:51 <Cale> Of course, you can fit a newtype around a Map :)
14:52:57 <dbpatterson> so there is a reasonable assumption that all is okay
14:53:08 <dbpatterson> Cale: that may be the next step :)
14:53:08 <Cale> And make it so that all the operations ensure the consistency of the data.
14:53:44 <dbpatterson> yeah.
14:53:47 <Cale> mm... in fact, you could just newtype the JSON structures directly.
14:54:07 <dbpatterson> thoughts - can I get totally away from the original api, provided I provide all the functionality?
14:54:19 <dmwit> Wow, that was a very misleading error message.
14:54:46 <Cale> dbpatterson: It might be a lot of work, but it should be possible
14:55:02 <dbpatterson> Cale: I was more meaning would they get mad at me :)
14:55:20 <Cale> Who? :)
14:55:44 <dbpatterson> it would probably be a simple matter of a data structure hiding a map, and all the functions to access it would do all the checking... a poor mans caching, really.
14:56:05 <dbpatterson> Cale: good point... and away I go, to fix up this very OO style api :)
14:58:12 <dufflebunk> I'm having a problem with IO happening in the wrong order when I mix putStr and printf from C. http://dufflebunk.blogspot.com/2008/05/foreign-function-interface-in-haskell.html
14:58:14 <lambdabot> Title: In Aere Aedificare: Foreign Function Interface in Haskell, http://tinyurl.com/5lfwgn
14:58:44 <dufflebunk> Is someone able to take a look at it? I flush stdout after the printf, but they still don't show until the end.
14:59:31 <paczesiowa> is there some great list representation in which list type doesn't depend only on list value, but can be generalized/unified with other lists (e.g. expression if b then hSingleton 'a' else hSingleton "hi" would typecheck to something that can be converted to Maybe Char :*: Maybe String :*: HNil). I know that I can write my own if conditional, but I can't write case ..of (or can I?)
15:00:41 <vixey> maybe you mean  :+: rather than :*: ?
15:00:51 <vixey> Either like a sum of types, (,) is a like a product
15:01:11 <vixey> you could implement hSingleton with a type class
15:02:11 <paczesiowa> hSingleton was just example, it should work with all type-indexed hlists
15:02:26 <vixey> oh sorry I don't know about that then
15:04:30 <paczesiowa> are there any interesting books on advaned types topics?
15:04:41 <TomMD> You know about the Pierce books?
15:04:57 <paczesiowa> no
15:05:05 <TomMD> Look up "Types and Programming Languages"
15:05:25 <TomMD> There is another one with the word "Advanced" somewhere in the title.
15:05:29 <vixey> which advanced types topics?
15:05:34 <paczesiowa> are there typeclasses?
15:06:01 <TomMD> You'll have to get the answer to that from someone else - sorry.
15:06:42 <vixey> typeclasses are not in TAPL or ATTAPL
15:06:45 <vixey> don't see why they would be
15:06:57 <Heffalump> they're not particularly complicated from a type theory point of view
15:07:02 <vixey> what specific topics are you interested in though?
15:07:20 <vixey> theres' a LOT of books about types: P
15:07:39 <paczesiowa> I read Oleg's paper on HList (it is the greatest thing I have ever read), but I would like some more to understand it and not just copy tricks
15:08:36 <sclv> ?yow
15:08:37 <lambdabot> An air of FRENCH FRIES permeates my nostrils!!
15:08:39 <paczesiowa> I'm interested in those advaned typeclass tricks (with undecidable instances)
15:08:47 <Lord_Illidan> I bloody love Haskell :D
15:08:59 <paczesiowa> we all do
15:09:06 <Lord_Illidan> Managed to finish that logo interpreter, and tested it with some nice recursive functions
15:09:13 <Lord_Illidan> trees, spirals the work
15:09:32 <saml> why do you need heterogenious  list?
15:09:58 <vixey> Lord_Illidan: cool :D
15:10:15 <MarcWeber> dcoutts: Does the .cabal parser keep formatting information ? Thus can you use the cabal parser for refactoring cabal files?
15:11:27 <cjb> Lord_Illidan: cool!
15:11:32 <cjb> Lord_Illidan: does it use gtk2hs or something?
15:11:47 <Lord_Illidan> cjb, no, it actually outputs to postscript
15:11:55 <cjb> heh
15:11:59 <Lord_Illidan> Our teacher gave us the IO side
15:12:08 <cjb> gosh
15:12:10 <paczesiowa> saml: they are cool
15:12:11 <Lord_Illidan> And some basic functions we could use
15:12:24 <Lord_Illidan> and we did the work of interpreting the logo commands
15:12:26 <Lord_Illidan> etc
15:12:52 <Lord_Illidan> I'd have liked to start gtkhs though, shame there's no time
15:12:53 <TomMD> Lord_Illidan: Where do you study?
15:13:03 <Lord_Illidan> TomMD, University of Malta
15:16:04 <Lord_Illidan> The rather cool thing is generating these complex recursive shapes and taking a good look at them..god I must sound boring
15:17:34 <paczesiowa> so are you impressed by logo or haskell?
15:18:09 <Lord_Illidan> the way that haskell makes it simple to make a logo interpreter
15:18:13 <MyCatVerbs> Lord_Illidan: not really. That sounds like fun.
15:18:29 <vixey> Lord_Illidan: lol
15:18:39 <vixey> Lord_Illidan: It's good stuff
15:19:00 * vixey had lots of fun writing a Logo interpreter too
15:21:29 <Lord_Illidan> assignment deadline is today, although I'm having more fun gazing at hypnotic spirals
15:21:47 <Lord_Illidan> and watching it give me stack errors heh
15:29:29 <adekoba> i do not understand the difference between rem and mod. does anybody know?
15:29:51 <adekoba> the difference between quot and div makes sense...
15:29:51 <Saizan> > (-1) `rem` 2
15:29:53 <lambdabot>  -1
15:30:00 <Saizan> > (-1) `mod` 2
15:30:01 <lambdabot>  1
15:30:07 <vixey> :t quot
15:30:09 <lambdabot> forall a. (Integral a) => a -> a -> a
15:30:26 <vixey> hmm what does quot do?
15:30:27 <adekoba> so mod takes the absolute value of the remainder?
15:30:37 <adekoba> rounds the result towards 0
15:30:51 <olsner> > (-3) `rem` 4
15:30:52 <lambdabot>  -3
15:30:57 <olsner> > (-3) `mod` 4
15:30:58 <lambdabot>  1
15:31:21 <adekoba> hm. guess not.
15:32:17 <vixey> > rem (-6) 4
15:32:19 <lambdabot>  -2
15:32:42 <vixey> > map (flip rem 6) [-10..10]
15:32:43 <lambdabot>  [-4,-3,-2,-1,0,-5,-4,-3,-2,-1,0,1,2,3,4,5,0,1,2,3,4]
15:32:46 <vixey> > map (flip mod 6) [-10..10]
15:32:47 <lambdabot>  [2,3,4,5,0,1,2,3,4,5,0,1,2,3,4,5,0,1,2,3,4]
15:33:39 <vixey> > map (\(x,y) -> quot x y + rem x y) [ (x,y) | x <- [-5..5] , y <- [-3..3] ]
15:33:40 <lambdabot>  [-1,1,5,Exception: divide by zero
15:34:14 <vixey> :/
15:34:14 <vixey> > map (\(x,y) -> quot x y + rem x y) [ (x,y) | x <- [-5..5] , y <- [-3..3] , y /= 0 ]
15:34:15 <lambdabot>  [-1,1,5,-5,-3,-3,0,2,4,-4,-2,-2,1,0,3,-3,-2,-1,-2,1,2,-2,-1,-2,-1,-1,1,-1,-1...
15:38:41 <GrayShade> how can i lift IO into ParserT in parsec 3?
15:39:28 <dmwit> :k ParserT
15:39:30 <lambdabot>     Not in scope: type constructor or class `ParserT'
15:39:40 <dmwit> :k Parser
15:39:42 <lambdabot> Not in scope: type constructor or class `Parser'
15:39:44 <dmwit> :k GenParser
15:39:46 <lambdabot>     Not in scope: type constructor or class `GenParser'
15:39:48 <dmwit> blast!
15:40:08 * dmwit guesses ParserT IO state token return
15:40:23 <ddarius> Just use liftIO as usual.
15:40:25 <adekoba> olsner: so what is the difference?
15:41:54 <Lord_Illidan> I was wondering..what type of literate programming style do you prefer?
15:43:01 <vixey> I just like readable code :/
15:43:02 <vixey> without comments
15:43:16 <vixey> kind of impossible in general to convey what you want without comments
15:44:02 <Lord_Illidan> that's true, I'd just like to know your opinion between latex style and the other style of LHS (>)
15:44:24 <Lord_Illidan> I'm submitting the entire assignment as a lhs file ;D
15:45:24 <SyntaxNinja> Igloo: I'm going to um finally get around to requesting cabal be removed from debian. any objection?
15:45:38 <SyntaxNinja> (this is the standalone cabal package, which is old, broken, outdated, and comes with ghc anyway)
15:45:41 <Igloo> SyntaxNinja: No, go for it
15:47:23 <ddarius> Lord_Illidan: Usually Bird tracks are preferred for things that aren't going to be latex files.
15:47:40 <ddarius> Lord_Illidan: It doesn't make a big difference to the reader.
15:47:49 <saml> bird style + reStructred Text
15:47:50 <Lord_Illidan> ddarius, sent it already :S
15:47:57 <Lord_Illidan> I just used latex style
15:48:05 <Lord_Illidan> because it's sort of block style
15:48:13 <Lord_Illidan> not marking every line with bird tracks
15:48:34 <saml> it's easy to convert between bird style and latex
15:48:55 <Lord_Illidan> line by line conversion manually?
15:49:08 <saml> http://www.haskell.org/haskellwiki/Literate_programming#Transformation_of_.lhs-files
15:49:10 <lambdabot> Title: Literate programming - HaskellWiki, http://tinyurl.com/y5klfa
15:49:14 <saml> scripts
15:49:36 <roconnor> @pl \f -> takeWhile (not . null) . iterate (f =<<) . f
15:49:36 <lambdabot> (takeWhile (not . null) .) . ((.) =<< iterate . (=<<))
15:49:37 <OceanSpray> Hey Cale,
15:49:41 <OceanSpray> this is your scene:
15:49:42 <OceanSpray> http://i116.photobucket.com/albums/o11/omgwtfazn/out-4.png
15:49:55 <OceanSpray> slightly different, of course.
15:49:58 <Cale> nice :)
15:49:58 <saml> but reST accepts bird style
15:50:18 <sclv> http://reddit.com/info/6i2fn/comments/
15:52:33 <dons> nice work, sclv
15:52:41 <sclv> thx :-)
15:53:20 <Lord_Illidan> thanks for the link
15:53:21 <SyntaxNinja> Igloo: do you think ftp master will be confused by the virtual package provided by ghc6?
15:55:22 <GrayShade> ddarius: i get an error about Identity not being an MonadIO instance when i do that in my code
15:58:52 <paczesiowa> GrayShade: what Parser type do you use? looks like your base monad is Identity
16:00:49 <GrayShade> it is
16:01:38 <GrayShade> but i was expecting it to be IO
16:01:43 <paczesiowa> GrayShade: could you show some of your code?
16:02:23 <paczesiowa> GrayShade: do you use ParsecT or Parsec?
16:02:38 <GrayShade> ParsecT
16:03:04 <GrayShade> http://hpaste.org/7364 this feels stupid
16:03:44 <paczesiowa> try runParserT
16:04:09 <paczesiowa> parse defaults to uni state and Identity monad
16:04:13 <paczesiowa> *unit
16:04:20 <GrayShade> i tried, i just pasted the wrong line there, it was runParserT () parser "interactive" line
16:05:06 <GrayShade> yet i've written another parser (that doesn't do almost anything) and it uses IO for that one
16:05:36 <paczesiowa> what are types of sexp and parser?
16:09:40 <GrayShade> ParsecT String u Control.Monad.Identity.Identity [Types.SExp]
16:10:44 <paczesiowa> could you paste the whole code (with type defs)
16:11:14 <mauke> unrelated, but parser = whiteSpace *> many sexp <* eof
16:11:58 <GrayShade> hm.. if i manually declare the type, it complains about "many sexp"
16:12:15 * obk just looked at the latest RWH. Question: Which chapter, if any, will be discussing lazy/strict issues? Would it be the performance tuning one?
16:12:41 <GrayShade> Expected type: ParsecT String st Control.Monad.Identity.Identity a, Inferred type: ParsecT String st IO [SExp], In the first argument of `many', namely `sexp'
16:13:57 <dons> obk, there'll be discussion throughout the book. with the usual mix of strict, eager, lazy data and control
16:14:13 <ddarius> GrayShade: Which modules are you importing?
16:14:18 <paczesiowa> GrayShade: paste Types module code
16:14:42 * obk has discovered - the hard way - that controlling lazy evaluation is one of the biggest "real world" issues with haskell programs...
16:15:00 <dons> just turn on -O :)
16:15:19 <dons> let the strictness analyser take care of it. the other issue is knowing when you're writing a tail recursive accumulator loop
16:15:33 <GrayShade> paczesiowa: http://hpaste.org/7365
16:16:02 <dons> strictness issues come up so rarely at work, i think they're more confined to early learning stages of haskell.
16:16:05 <ddarius> GrayShade: Monomorphism restriction.
16:16:30 <dons> once you get a sense of how strictness is inferred, it turns out to be pretty simple to decide when and where laziness get exploited
16:16:40 <dons> but this kind of thing is sadly not taught in universities very much
16:16:47 <dons> evaluation strategies in general get ignored
16:16:55 <obk> dons: This "sense" is what I was hoping to find a chapter about ;-)
16:17:01 <dons> yep
16:17:04 <GrayShade> ddarius: why?
16:17:14 <sclv> GrayShade :: try to give your parser an explicit type.
16:17:16 <dons> i like to point out that haskell is really a strict & lazy language.
16:17:36 <GrayShade> i did, for sexp
16:17:40 <dons> so, like type inference, strictness inference makes life more pleasant
16:17:44 <MarcWeber> okb  See the real world haskell book. If this chapter is missing I'm sure there is a way to add a requst
16:18:04 <ddarius> GrayShade: Give both a type signature.
16:18:09 <dons> yeah, just add some noise to the comment system, if you don't find what you're looking for
16:18:32 <ddarius> Also where is the code that actually runs the parser?
16:18:59 <obk> Well, there's no chapter just for this issue - I expected one, but it may be that they are covering it somnewhere non-obvious (or in the performance chapter)
16:19:09 <obk> I guess a comment won't hurt :-)
16:19:32 <GrayShade> let me copy the gather the relevant code to some other place
16:19:35 <Igloo> -- Grubby little function to do "seq" on namesets; replace by proper seq when GHC can do seq
16:19:40 <Igloo> I wonder how old that comment is
16:23:00 <dons> Igloo: wow
16:23:23 <obk> Hmmm... there's no way to comment on the RWH TOC, or on a chapter that doesn't exist yet. I guess I'll have to add the comment when the performance chapter gets uploaded.
16:23:43 <paczesiowa> GrayShade: where is your code for lexeme?
16:25:24 <paczesiowa> GrayShade: and whitespace? you do know how to use Text.Parsec.Token right?
16:26:51 <GrayShade> paczesiowa: if i copy the code to another file and i uncomment lexeme, it compiles, but in my file it doesn't
16:27:22 <GrayShade> http://hpaste.org/7366 this is my definition of lexeme
16:29:28 <Saizan> mmh, maybe it's the monomorphism restriction from hell?
16:31:06 <GrayShade> paczesiowa, ddarius: http://hpaste.org/7367
16:32:52 <paczesiowa> makeTokenParser lispStyle defaults to Identity:/
16:33:41 <GrayShade> type LanguageDef st = GenLanguageDef String st Identity
16:33:56 <GrayShade> why is that?
16:36:05 <Saizan> GrayShade: wait, can't you just remove the signature from lispStyle?
16:36:52 <paczesiowa> try lispStyle :: (Monad m) => GenLanguageDef String st m and {-# OPTIONS -fno-monomorphism-restriction #-}
16:38:09 <paczesiowa> then it works
16:38:17 <GrayShade> i get http://hpaste.org/7370
16:38:39 <GrayShade> oh, never ind
16:38:44 <GrayShade> it works
16:40:58 <paczesiowa> if there is no Show Instance for SExp then ghci doesn't print result, but it doesn't show error about missing Show instance
16:41:19 <paczesiowa> bug with running IO code in ghci?
16:41:51 <Saizan> well you might be running the IO action for side effects
16:41:53 <paczesiowa> or feature so we can run code with IO Handle types
16:42:34 <paczesiowa> GrayShade: why do you use new parsec?
16:42:41 <dalien> hmm been RTFM, but could not find - is there a way to "join" the list consisting of functions, by an infix op ? (http://hpaste.org/7369 - trying to rewrite the ugliness on the top with the higher-order function)
16:43:05 <vixey> > foldr f z [a,b,c]
16:43:06 <lambdabot>  f a (f b (f c z))
16:44:03 <dalien> ok, means i need to figure out the proper way to use "<|>" in that context :) i thought there was some other way
16:45:02 <GrayShade> paczesiowa: a friend is working on a lisp interpreter in f# and challenged me to write one in haskell
16:45:15 <Saizan> i think there's already a combinator that behaves like foldr (<|>) pzero
16:45:26 <GrayShade> paczesiowa: but lisp has those nice reader macros that are executed during the compilation phase
16:45:54 <vixey> nice? heh
16:46:19 <GrayShade> nice for those writing lisp, terrible for the others
16:46:37 <paczesiowa> GrayShade: nice, I had only stupid ideas about non-deterministic parsing depending on the time of the day
16:46:52 <vixey> I only saw one good application of them, xml-mixed-mode
16:47:44 <GrayShade> my friend implemented haskell-style interval lazy lists ([1, 5, ..], etc.) with reader macros
16:47:45 <paczesiowa> GrayShade: anyway sound like your friend can't do that lisp interpreter and he is trying to make you do it:>
16:48:14 <GrayShade> his is way smarter than mine, currently
16:48:15 * vixey idly wonders if F# has any good features worth stealing
16:48:40 <GrayShade> i got depressed when i saw mine allocating 7 gb of memory for some fibonacci stuff
16:49:12 <vixey> GrayShade: Do you convert tail calls to jumps?
16:49:26 <GrayShade> no
16:49:31 <vixey> do that then :P
16:49:54 <GrayShade> mine still has a leak, i think
16:50:02 <dalien> Saizan: bah. indeed - that was "choice" :)
16:50:07 <Saizan> dalien: choice $ zipWith (\s v -> reserved s >> return v) ["Fixed","Low","Medium","High"] [FreqFixed,FrewLow,FreqMedium,FreqHigh]
16:51:00 <GrayShade> his didn't need more that 5 MB for fib 35; mine grows up steadily to 150 mb or something like that
16:51:18 <vixey> GrayShade: probably tail calls.
16:51:33 <GrayShade> he doesn't to tail calls
16:52:18 <dalien> Saizan: the list is the list of types.. I am trying to avoid manual enum :)
16:52:33 <GrayShade> i think mine is piling up junk it won't need again
16:53:07 <GrayShade> yet the memory profiler says that i'm evaluating stuff too early
16:53:17 <GrayShade> i don't know what to think about it
16:57:53 <GrayShade> anyway, i'm off to sleep.. thanks for the help
17:03:31 <lilac> is there an easy way to convert a String into UTF-8?
17:03:59 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string-0.3.1
17:04:02 <lambdabot> http://tinyurl.com/5ludpz
17:04:18 <lilac> ty
17:10:33 <paczesiowa> aren't Strings already unicode capable? I think it's just, that IO read/write functions don't understand unicode. I used encoding package which gives io functions parameterized by encodings
17:12:24 <dcoutts> paczesiowa: that's right
17:12:43 <dcoutts> MarcWeber: no it does not keep location info so cannot currently be used for refactoring .cabal files
17:14:44 <TomMD> Any plans to switch ghc darcs to 2.0 format?
17:17:25 <dons> TomMD: simon marlow's exploring the options
17:18:10 <TomMD> great!
17:19:24 <dons> a quick post about stream fusion on arrays, http://reddit.com/info/6i2ma/comments/
17:19:28 <dons> should be a fun read i hope
17:21:31 <dcoutts> dons: heh, lots of fooU rather than U.foo :-)
17:21:41 * dcoutts blames rl
17:22:04 <dons> dcoutts: yeah. :)
17:22:15 <dons> dcoutts: but check out the code -- the optimiser is getting seriously clever
17:22:30 * dcoutts reads
17:23:36 <dcoutts> dons: nice
17:24:00 <vixey> dons: that is so cool!
17:24:08 <vixey> (you have a typo too "makese")
17:24:15 <dcoutts> dons: you know that sioraiocht_ is doing a fusible unicode bytestring implementation
17:24:35 <dons> dcoutts: yeah, i heard.
17:24:36 <dons> vixey: cheers.
17:25:03 <dcoutts> dons: he's starting from the stream code from the list lib or is there any later code we should look at?
17:25:35 <dons> i reckon start with the ndp arrays
17:25:42 <dons> and add in combinators from the stream-fusion lib
17:25:58 <dons> (it has a much bigger set of stream combinators, but the ndp lib gets the fundamentals a bit better, wrt. spec constr)
17:26:06 <dcoutts> we're starting with just UArray's and might move on to ByteArr#'s
17:26:26 <dons> ok. i'd poke around  a bit in uvector to then
17:26:39 <dons> though i'm more focusing on getting Double arrays to do well
17:27:09 <dcoutts> the representation is really simple though, it's all flat and bytes or word16 depending on utf-8/16
17:27:26 <dcoutts> the important bit is the stream code I think
17:27:51 <dmwit> That ($) looks really odd, hanging off in the middle of that code like that.
17:27:53 <dcoutts> dons: so how has the stream-fusion lib changed from the stream code in the list lib?
17:28:00 <Botje> dons: slight nitpick: in fold :: Int# -> Int# -> ... the order of the case statements is reversed
17:28:15 <dons> Botje: yeah, ghc did that for some reason
17:28:17 <dons> i'm not sure why
17:28:25 <Botje> okay
17:28:32 <Botje> that's pretty sweet though :)
17:28:32 <dons> dmwit: i'll take suggestions :)
17:28:49 <dmwit> dons: Replace the last (.) with ($)?
17:28:50 <dons> give it some upmods on reddit. i'd like to spread the word about haskell/strictness some more :)
17:29:04 <dons> dmwit: yeah, true enough.
17:29:14 <dcoutts> dons: I would, but I can't bring myself to sign up for reddit :-)
17:29:15 <dons> there's some symmetry with the (.), but its unidiomatic
17:29:26 <dmwit> Upmods definitely given, though. =)
17:29:44 <dons> so the summer should be exciting, with a few new fast array libs appearing
17:29:49 <dons> and the native code gen project cranking up
17:29:59 <dons> and the parallel GC getting pushed
17:30:20 <gweiqi> isn't there already native code generation?
17:30:35 <dons> yeah, it just nees to be improved.
17:30:45 <dons> there's a new cutting edge native gen being written
17:30:52 <dons> to go with the cutting edge optimiser
17:31:21 <Botje> we'll have to add "caution: sharp edges" labels to GHC.
17:31:40 <dons> "keep away from children"
17:31:51 <dmwit> Hmm, what does it mean to have "case x of _ -> ...; 10000000000000000000000 -> acc"?
17:31:53 <dons> "do not operate while under the influence"
17:31:59 <dmwit> Will that second case ever be taken?
17:32:02 <dons> dmwit: that's ghc reordering the default branches
17:32:13 <shachaf> dons: "(as its notionally pure and lazy)"
17:32:15 <dons> in user-land haskell you have to write it around the other way
17:32:23 <dmwit> OK.
17:32:33 <dmwit> So it's some sort of branch-prediction-style optimization, then?
17:32:40 <dons> shachaf: yeah, i wasn't sure about that. i want to get across the idea that you really need to know its pure and lazy if you're going nuts in the compiler with inlining
17:33:01 <shachaf> dons: I meant the missing '. :-)
17:33:03 <dons> dmwit: i'm not sure it ends up affecting the ordering of blocks or branches though
17:33:11 <dons> shachaf: oh, right :)
17:33:16 <dolio> We need to get GHC to compile that to 'print 204800000000'. :)
17:33:59 <dons> dolio: i think it should be possible. it does some loops already (with replicate generators)
17:34:07 <dons> eg. print . cons. map. replicate
17:34:16 <dons> which is scary the first time you see it
17:34:47 <dons> main = print . headU . replicateU (100000000::Int) $ (8::Int)
17:34:49 <dons> for example
17:35:02 <dons> lvl = $wshowSignedInt 0 8 ([] @ Char)
17:35:04 <dons> is the result
17:35:12 <dolio> Huh.
17:35:47 <dmwit> > 100000000 :: Int
17:35:49 <lambdabot>  100000000
17:41:08 <dons> new sigfpe, http://reddit.com/info/6i2nn/comments/
17:42:34 <dalien> nice. Token parser is 2x faster than the character one :)
17:42:53 <dmwit> Awesome. =)
17:43:00 <dmwit> Two passes are better than one. ;-)
17:52:10 <TomMD> dons: Not trying to sabatoge your comment, but i edited mine to mention pointer tagging at the same time as your response.
17:52:48 <dons> yeah, i see. that's a useful figure to keep in mind.
17:53:07 <dons> but i wonder, now with bang patterns, and a suite of strict structures, i bet the numbers have changed from 15 years ago
17:53:22 <dons> there's just more strictness around in the code for the compilers to chew on
17:53:41 <TomMD> Certainly.  I blame Launchbury.
17:53:54 <TomMD> I could blame Simon, but I hope to remain on his good side.
17:54:02 <dons> heh
17:58:37 <dalien> http://opensim.be/dalien/haskell/packet_template_token.hs - my first haskell program :-) (although i still wonder why some places I had to put the "whiteSpace" and in some did not)
17:59:51 <TomMD> dalien: What places?  Care to add to 'Common Misunderstandings' page of the wiki?
18:01:17 <jamii> I think the indented <?> at the end of most functions, maybe?
18:01:45 <dalien> between the tokens... the doc says that each token is supposed to eat up the whitespaces, but based on the behaviour it did not do it
18:02:16 <dalien> the thing i was parsing is http://opensim.be/dalien/haskell/1.18.3.5.txt  (200Kb)
18:02:41 <jamii> Oh, I thought you were talking about whitespace in the source...looks like its coffee time again
18:03:30 <dalien> :) nope, the source seems to be ok - I love haskell - it looks like if it compiles, it runs "as I wanted it to" :)
18:04:18 <vixey> yes
18:04:21 <Spark> that's true of all simple programs
18:04:23 <vixey> haskell is great!
18:04:28 <TomMD> A common complaint - this increased efficiency resulted in three of my coworkers getting laid off because management couldn't think of another project in time.
18:04:30 <Spark> the complexity comes when you write large programs, and change large programs
18:05:33 <dalien> well, I'd consider a parser to be a relatively major undertaking if using C :)
18:05:46 <Spark> depends on the parser
18:05:55 <Spark> if it's recursive descent it's probably quite easy
18:06:26 <TomMD> ?faq Could the increased programmer efficiency brought by a better language result in fewer developer jobs?
18:06:27 <lambdabot> The answer is: Yes! Haskell can do that.
18:06:51 <glguy> There's always more money to be made
18:06:59 <TomMD> Yeah, its a joke.
18:07:06 <dalien> probably... it's been a while since i wrote one in C - and this particular task i did in ruby as well for the experiment - but i think the haskell implementation is way cleaner.
18:07:07 <Korollary> were the guys really laid off?
18:07:21 <ddarius> Spark: My experience so far for professional development has been understanding the requirements is the most complex part.
18:07:22 <Spark> the haskell syntax will be nicer than c
18:07:28 <TomMD> No, no - I wish I had three Haskell programming coworkers!
18:07:30 <Spark> but the algorithm is pretty standard
18:07:51 <Spark> and switch(enum)  vs pattern matching.. there's not a huge difference there
18:08:15 <Spark> ddarius: i think that's generally true when doing things for other people, even say... plumbing :)
18:08:24 <ddarius> Spark: Indeed.
18:08:39 <TomMD> well-typed is doing well?
18:08:50 <dalien> Spark: yes. maybe it's just the initial excitement with the language:)
18:09:09 <ddarius> Haskell certainly makes more things "simple"
18:09:41 <vixey> there is a HUGE difference between switch and pattern matching
18:10:10 <vixey> although maybe it's only obvious when you look at things in terms of proving ...
18:10:18 <vixey> obvious/relevant
18:10:48 <dons> vixey: well, it matters if you're using lots of data structures
18:12:02 <Spark> ddarius: like IO :)
18:12:51 <ddarius> Spark: Yep.
18:18:33 <dmwit> Pattern matching is great for nested data structures.
18:18:38 <dmwit> switch(enum), not so much
18:18:52 <dmwit> (Just my two pence.)
18:34:27 <roconnor> what is replicateU?
18:36:31 <dons> roconnor: replicate on unboxed arrays
18:36:38 <glguy> it's part of dons array library that creates an array of a certain size initialized with a constant values
18:36:39 <glguy> -s
18:37:12 <dons> it comes from the function of the same name in the data parallel arrays lib
18:37:34 <dons> http://code.haskell.org/~dons/code/uvector/Data/Array/Vector.hs
18:37:38 <roconnor> dons: um isn't all unboxed code strict
18:37:59 <Socrates`> Hmm, anyway I can write a function like this....
18:38:00 <Socrates`> (foldl1 (.) $ take 1000000 (repeat permute))
18:38:06 <Socrates`> And avoid a stack overflow? >.<
18:38:10 <Cale> dons: Hmm, one thing that the compiler failed to spot in your code is that x,y, and z will always be equal to one another.
18:38:12 <dons> roconnor: you could do it lazily (e.g. lazy bytestrings)
18:38:15 <vixey> :t repeat
18:38:16 <lambdabot> forall a. a -> [a]
18:38:17 <glguy> take n (repeat x) is  replicate n x
18:38:21 <dons> Cale, yeah. interesting. gcc didn't spot it either
18:38:26 <vixey> Socrates: what's permute?
18:38:42 <Socrates`> Just a function to permute a list
18:38:46 <Socrates`> [a] -> [a]
18:39:06 <vixey> oh
18:39:08 <Socrates`> Find the next highest permutation that is
18:39:10 <vixey> :t replicate
18:39:12 <lambdabot> forall a. Int -> a -> [a]
18:39:19 <vixey> take n (repeat x) = replicate n x ?
18:39:20 <dmwit> Socrates`: You might want foldl1'.
18:39:44 <dmwit> The prime is a standard notation for "the strict version".
18:39:53 <dmwit> err... s/standard/common/
18:40:24 <Socrates`> Hmm, right, what library can I find that in?
18:40:34 <glguy> Data.List
18:40:49 <Socrates`> Thanks dmwit, glguy I'll give it a try
18:41:30 <Cale> dons: I suppose it's sort of a special case, though it seems to have come up from a common pattern in the code generation, so perhaps it would be worthwhile to catch things like that.
18:42:02 <jamii> dmwit: Will that work if permute is recursive, rather than monolithic?
18:42:04 <dons> Cale, yeah, i opened up a ticket with a bunch of example loops produced by the array lib, to use as test cases when the native codegen project starts up again
18:42:23 <Socrates`> Doesn't appear to work, nope :C
18:42:28 <jamii> dmwit: Not that permute is likely to be recursize...
18:42:52 <dmwit> I think I missed something.
18:42:59 <jamii> Socrates: can you post the code for permute?
18:43:05 <Socrates`> Hehe, I've managed to make it recursive
18:46:58 <jamii> Socrates: Try (take 1000000 . (iterate permute)) for starters
18:47:29 <Socrates`> Thanks jamil, think I might have found a way to write permute to produce a list of permutations
18:47:42 <Socrates`> So I ought to be able to just use !! 1000000 instead
18:48:03 <dons> glguy: any thoughts on the arrays post? things that could be explained/explored further?
18:48:27 <jamii> Thats what iterate does. (iterate f x) = [ x , f x , f (f x) .....
18:49:01 <twanvl> dons: what is with the uglyU namesU? Why not import qualified?
18:49:06 <dons> yeah yeah
18:49:33 <dons> :)
18:50:38 <roconnor> Modules. They work, bitches.
18:50:58 <vixey> I don't thnk U is ugly
18:51:04 <jamii> roconnor: In haskell they do second-class work
18:51:05 <vixey> comared to Data.UArray.map
18:51:28 <jamii> vixey: import qualified Data.UArray as U
18:51:37 <vixey> U.map vs mapU ?
18:51:38 <jamii> U.map
18:51:38 <vixey> :P
18:51:44 <vixey> It's really not better
18:51:54 <vixey> well maybe it is I don't know, just personal taste
18:52:05 <jamii> vixey: It means you can change module more easily.
18:52:06 <roconnor> fmap
18:52:15 <vixey> mapM
18:52:39 <jamii> vixey: mapM is a symbol of all that hurts in haskell
18:52:54 <shachaf> mapFM. :-)
18:53:00 <Cale> jamii: huh?
18:53:04 <jamii> \shoots shachaf
18:53:10 <Cale> What's wrong with mapM
18:53:11 <Cale> ?
18:53:18 <jamii> Cale: Seperate monadic versions of every interface
18:53:25 <vixey> :t mapM
18:53:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:53:27 <vixey> :t map
18:53:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:53:29 <vixey> :t fmap
18:53:29 <Cale> jamii: They do something different.
18:53:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:53:34 <Cale> hehe
18:53:46 <shachaf> @ty P.map
18:53:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:53:49 <jamii> Cale: map is mapM over the identity monad.
18:53:51 <vixey> is
18:54:02 <vixey> (a -> m b) -> f a -> m (f b) -- possible?
18:54:06 <vixey> ?djinn (a -> m b) -> f a -> m (f b)
18:54:06 <lambdabot> -- f cannot be realized.
18:54:12 <Cale> jamii: That's true, but mapM is not a simple function of map
18:54:43 <Cale> jamii: mapM has more information in it about how the computational effects are to be ordered which map doesn't.
18:54:44 <jamii> mapM is a generalistion of map, but the current monad syntax makes it awkward to express pure computations as identity monadic computations
18:55:20 <jamii> mapM says order it according to the underlying monad. Using the identity monad gives you the same lazy ordering as pure haskell
18:55:34 <Cale> No, that's not the order I'm talking about
18:55:43 <Cale> I'm talking about the execution order, not the evaluation order.
18:56:01 <jamii> How do you distinguish the two for a pure function?
18:56:21 <Cale> The execution order doesn't matter in the identity monad (which is to say the identity monad is a commutative monad)
18:56:33 <Cale> In most monads though, it does matter, which is why we make it explicit.
18:56:55 <Cale> Pure notation doesn't express anything about execution order.
18:57:44 <jamii> Cale: Thats my point. I would like to be able to express pure notation as the Id monad so that you only need one version of map
18:58:03 <jamii> But the syntax for doing so is not obvious
18:58:13 <Cale> jamii: But writing all pure code in the identity monad would be tedious.
18:58:33 <Cale> You'd be forced to include information which is usually irrelevant.
18:58:47 <vixey> like what?
18:58:49 <jamii> Cale: I know. Hence the pain. If someone could figure out how to make the two mesh nicely my life would be a lot easier
18:59:58 <Cale> I think the difference between map and mapM is most nicely expressed by mapM's implementation in terms of sequence :)
19:00:03 <Cale> @src mapM
19:00:04 <lambdabot> mapM f as = sequence (map f as)
19:00:11 * obk agrees with jamii. It would be nice to have just one version of all the xxxM functions...
19:00:48 <adiM> @pl http://fundaez.blogspot.com/2008/04/sporty-affair-ii.html
19:00:48 <lambdabot> (line 1, column 15):
19:00:48 <lambdabot> unexpected "."
19:00:48 <lambdabot> expecting letter or digit, variable, "(", "!!", white space, operator or end of input
19:00:48 <lambdabot> ambiguous use of a right associative operator
19:00:49 <jamii> For example, yesterday I found that my 1500 line simulation needed to make random choices at various points so I had to rewrite the whole thing in either the IO monad, the state monad or with a passed generator. If the pure code mapped directly to the Id monad I would have been able to just chuck in randomIO and watch the inferred type change
19:00:59 <adiM> @pl   read2 list = (read $ head l, read $ last l) where l = words list
19:00:59 <lambdabot> (line 1, column 53):
19:00:59 <lambdabot> unexpected "="
19:00:59 <lambdabot> expecting variable, "(", operator or end of input
19:01:37 <vixey> > return 1 :: Identity Integer
19:01:38 <lambdabot>        add an instance declaration for (Show (Identity Integer))
19:01:44 <shachaf> @pl read2 list = let l = words list in (read $ head l, read $ last l)
19:01:45 <lambdabot> read2 = ap ((,) . read . head) (read . last) . fix . const . words
19:01:49 <vixey> @sirc return Identity
19:01:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:01:55 <Cale> jamii: You could have passed in a stream of random choices perhaps?
19:01:56 <vixey> @src Identity return
19:01:56 <lambdabot> Source not found. :(
19:02:35 <vixey> > runIdentity (return 4)
19:02:36 <lambdabot>  4
19:02:48 <vixey> > runIdentity (mapM (1+) [1..10])
19:02:49 <lambdabot>        add an instance declaration for
19:02:49 <lambdabot>       (Enum (Identity b), Num (Identit...
19:02:51 <jamii> Cale: The random stream would have to be passed around in the same way as the generator
19:02:58 <shachaf> > runIdentity $ filterM (return . even) [1..10]
19:03:00 <lambdabot>  [2,4,6,8,10]
19:03:01 <Cale> jamii: Right.
19:03:07 <Cale> jamii: Is that so hard?
19:03:14 <vixey> > runIdentity (mapM (liftM (1+)) (map return [1..10]))
19:03:15 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
19:03:18 <vixey> hehe
19:03:20 <vixey> this is fun
19:03:26 <vixey> write everything in Identity
19:03:52 <jamii> Cale: Its annoying. And it makes prototyping harder than in a dynamic language. Some sort of implicit Id monad would stop it from happening.
19:04:07 <vixey> jamii: Can you make it possible?
19:04:27 <jamii> Cale: It also confuses the intent of the code to have all these generators flying about
19:04:33 <vixey> if you just replace 1 with return 1
19:04:41 <vixey> lift (+) and a bunch of things
19:05:05 <shachaf> > ((read . head) &&& (read . last)) . words $ "1 2 3" :: (Int,Int)
19:05:06 <lambdabot>  (1,3)
19:05:12 <Cale> jamii: Doesn't it make the intent more clear? The types express the need for random generators, and hence the fact that the result will depend on the generator state.
19:05:13 <shachaf> adiM: That?
19:05:14 <jamii> vixey: I dont know. Noone else has done it so I just assumed it was hard. Maybe its doable
19:05:54 <shachaf> Cale: What jamii is saying, I think, is that if you worked in Id all you'd need to change is the types.
19:06:03 <Cale> One issue with an implicit identity monad is what something like  fmap reverse [[1,2,3],[4,5]]  means.
19:06:05 <shachaf> Cale: In order to express the fact that you're now using random numbers.
19:06:32 <jamii> Cale: I think the issue is that using effects changes the way I interact with things. Its not transparently changed.
19:06:40 <shachaf> > join (&&&) read . head &&& last . words $ "1 2 3" :: (Int,Int)
19:06:42 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
19:06:47 <adiM> shachaf: Thanks!
19:06:47 <jamii> shachaf: yes, thats the idea
19:07:41 <jamii> Im quite excited about DDC but it doesnt seem to have an interpreter so I dont know how well its type system allieviates this problem
19:08:07 <Cale> jamii: Well, right. But the reason that programming *without* effects is so nice in Haskell is that the things you need to add in order to work with effects don't need to be expressed in the first place. So yeah, adding those is work, but it's that, or force people to do that work in all their code.
19:09:10 <jamii> Cale: I think my point is that whilst the fact that one integer came from a pure source and the other came from an rng needs to be expressed in the type, it shouldnt require be to change the code that interacts with it. Haskell has all the machinery to be able to correctly infer the new semantics, its just a matter of syntax
19:09:30 <Cale> But order matters.
19:09:43 <Cale> And the usual pure syntax doesn't express an order.
19:09:53 <obk> "just a matter of syntax" - that's the understatement of the year :-)
19:10:02 <jamii> I know. I want to write *everything* in the monadic syntax
19:10:06 <adiM> Is there a function to convert from list to tuples and vice versa?
19:10:08 <jamii> obk: Ok, fair enough
19:10:41 <Cale> jamii: Well, you can do that :)
19:10:41 <obk> jamii: I'm with you so far...
19:11:00 <shachaf> adiM: Tuples of what size?
19:11:03 <Cale> You can just decide to write everything in the identity monad.
19:11:05 <vixey> jamii: I think it's a cool idea and you should try to make a parser/interp which lets people experiment with it
19:11:07 <obk> But you need to re-interpret the current syntax as somehow using the Id monda... or something
19:11:14 <adiM> Tuples of arbitrary size
19:11:14 <jamii> Yes. Maybe once exams and gsoc are done I should try and make this work.
19:11:26 <shachaf> adiM: Tuples aren't of arbitrary size; that's the point. :-)
19:11:30 <jamii> I have the whole of september free to do something constructive
19:11:35 <Cale> But I think it'll end up being rather ambiguous what order the effects happen in when you start adding them.
19:11:54 <obk> Cale: not if you (somehow) do it right
19:11:55 <Cale> and that's why we didn't have effects mixed with lazy evaluation in the first place...
19:12:01 <jamii> Cale: Possibly. I guess I have to just try it and find out
19:12:26 <jamii> Either that or wait for DDC to get an iterpreter
19:12:29 <obk> jamii: You may have to venture to incompatible-syntax land...
19:12:31 <Cale> (not to mention that it would have potentially brutal effects on the evaluation order)
19:12:33 <adiM> shachf: I have a function that takes a list and returns the result. I want to memoize it, so I thought that turning arguments into tuples will do the trick.
19:12:36 <Cale> DDC is strict though.
19:12:52 <Cale> (by default, anyway)
19:13:13 <Cale> Which is a pretty heavy price to pay for it, but what I think is necessary to make it work sanely in a majority of cases.
19:13:18 <jamii> Cale: Yep. I think there is something about the effect inference which requires that.
19:13:32 <jamii> In DDC you can only suspend a pure function
19:13:47 <Cale> Laziness by default is something I'm just not willing to give up.
19:14:10 <Cale> (or at least non-strict semantics)
19:14:35 <edwardk> do you think haskell folks find 'Fix' less scary than Mu and Nu?
19:14:36 <jamii> Cale: Im not sure. Maybe this Id monad thingy can give the same effect without requiring eager by default
19:16:00 <obk> jamii: That's one of two big problems you need to solve; the other is to reinterpret the "default" syntax as implicitly using the magical Id monad
19:16:13 <obk> It is quite the challange
19:16:17 <vixey> make a new syntax that works for everything
19:16:21 <Cale> edwardk: In general, I think so.
19:16:34 <jamii> obk: Hmm. I going to pull up a ghci session and see how well this works
19:16:38 <obk> vixey: That may be simpler, but it means having to re-write the world...
19:16:39 <vixey> I think they're equally confusing
19:16:41 <edwardk> cale: k, gh and replacing mus and nus with fix, it matches the module name in which you find it then anyways
19:17:03 <vixey> > listify (const True) (1,2,3,4,5)
19:17:04 <lambdabot>  []
19:17:07 <vixey> :/
19:17:09 <Cale> edwardk: If the difference between mu and nu matters though, it might be more confusing :)
19:17:14 <obk> vixey: Unless you could write a transformer from the current syntax forms to the new one... hmmm... rather ambitious either way
19:17:27 <vixey> obk: parser + interpreter should do
19:17:35 <obk> "should" :-)
19:17:36 <edwardk> cale: in haskell, i can't discriminate between them
19:17:37 <jamii> Over-ambition ftw!
19:17:39 <Saizan> "i want to write everything in monadic notation" would make FP advocates scream in horror :)
19:17:59 <vixey> It's not a very ambitious thing to write an interpreter to test out a language design idea...
19:18:07 <vixey> It's kind of usual
19:18:10 <Cale> Also, why the identity monad and not the identity applicative functor, or the identity comonad?
19:18:39 <Cale> There are lots of different conflicting implicit structures you could try to impose on pure code.
19:18:39 <OceanSpray> what's a functor?
19:18:53 <jamii> vixey: Trying to do anything with haskell syntax is ambitious. Have you ever tried writing directly in TH?
19:19:02 <vixey> no I haven't
19:19:04 <Cale> OceanSpray: In the context of Haskell, it's a type constructor with fmap defined for it, such that a couple of laws hold.
19:19:10 <Cale> :t fmap
19:19:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:19:18 <vixey> why does listify (const True) (1,2,3,4,5) give [] and not [1,2,3,4,5] ?
19:19:20 <Cale> fmap id = id
19:19:21 <jamii> Cale: Because its the conflict between pure and monadic computations thats annoying me
19:19:25 <Cale> fmap (f . g) = fmap f . fmap g
19:19:53 <SamB> vixey: yes, most people use toy languages for trying out ideas, or try to shoehorn them into existing Haskell implementations...
19:19:54 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
19:19:57 <vixey> jamii: what is the problem? I've never encountered this
19:19:57 <SamB> @messages
19:19:58 <lambdabot> sclv said 8h 48m 51s ago: Oh man, you were so right about map deserialization. I tried it, and the ord constraint has been killing me. grrr...
19:20:08 <Cale> vixey: what type are you applying it at?
19:20:22 <vixey> (Int,Int,Int,Int,Int)
19:20:26 <Cale> vixey: The result of listify depends on the type at which it's applied
19:20:28 <vixey> I think ..?
19:20:31 <vixey> > listify (const True) (1,2,3,4,5)
19:20:32 <Cale> vixey: no, the result type
19:20:33 <lambdabot>  []
19:20:37 <vixey> > listify (const True) (1,2,3,4,5) :: [Int]
19:20:38 <lambdabot>  []
19:20:40 <vixey> hmm
19:20:47 <Cale> > listify (const True) (1,2,3,4,5) :: [Integer]
19:20:48 <lambdabot>  [1,2,3,4,5]
19:20:53 <vixey> what ?????
19:20:54 <vixey> :(
19:21:01 <vixey> Data.Dynamic hates me
19:21:03 <Cale> Integer is the default numeric type
19:21:07 <SamB> vixey: those 1s were defaulted to Integer
19:21:10 <SamB> er.
19:21:13 <vixey> I understand
19:21:15 <SamB> and other numbers.
19:21:19 <Cale> > listify (const True) (1::Int,2::Integer,3::Int,4::Integer,5::Int) :: [Integer]
19:21:21 <lambdabot>  [2,4]
19:21:25 <Cale> > listify (const True) (1::Int,2::Integer,3::Int,4::Integer,5::Int) :: [Int]
19:21:27 <lambdabot>  [1,3,5]
19:21:48 <SamB> > listify (const False) (1::Int,2::Integer,3::Int,4::Integer,5::Int) :: [Int]
19:21:49 <lambdabot>  []
19:22:04 <vixey> so what about [Int] -> (Int,Int,Int) is that possible?
19:22:05 <SamB> > listify (>3) (1::Int,2::Integer,3::Int,4::Integer,5::Int) :: [Int]
19:22:10 <lambdabot>  [5]
19:22:33 <thesquib> hey all
19:22:39 <vixey> hi squib
19:24:16 <vixey> > synthesize 0 (+) id
19:24:17 <lambdabot>   synthesize 0 (+) id
19:24:17 <lambdabot>     In the definition of `lgm': lgm = synthesize 0 (+) id
19:24:53 <Cale> odd
19:25:00 <Cale> :t synthesize 0 (+) id
19:25:03 <lambdabot>     Couldn't match expected type `t -> t' against inferred type `a1'
19:25:03 <lambdabot>       `a1' is a rigid type variable bound by
19:25:03 <lambdabot>            the polymorphic type `forall a1. (Data a1) => a1 -> t -> t'
19:25:27 <vixey> honestly I'm scared of this "dynamic" stuff :P
19:25:37 <thesquib> is there anyway to have the behaviour ['a'] == [1] = False in haskell?
19:25:46 <vixey> :t 'a'
19:25:48 <vixey> :t 1
19:25:48 <lambdabot> Char
19:25:50 <lambdabot> forall t. (Num t) => t
19:25:50 <thesquib> so two lists of different types
19:26:04 <vixey> @instances Num
19:26:05 <lambdabot> Double, Float, Int, Integer
19:26:05 <Cale> thesquib: that won't typecheck
19:26:18 <thesquib> no i know
19:26:30 <vixey> thesquib: You could make 'Char' a Num
19:26:35 <vixey> thesquib: It's a silly idea though
19:27:36 <thesquib> mm
19:27:47 <Cale> thesquib: Since you must know statically from the type information that the lists must be of different types, and hence the comparison must always be False, what point would there be in comparing?
19:28:01 <thesquib> true
19:28:15 <thesquib> i guess its not necessary
19:28:46 <kpreid> @type \a b -> maybe (a ==) False $ Data.Typeable.cast b
19:28:48 <lambdabot>     Couldn't match expected type `a -> a1 -> Bool'
19:28:48 <lambdabot>            against inferred type `Bool'
19:28:48 <lambdabot>     In the second argument of `maybe', namely `False'
19:28:55 <kpreid> @type \a b -> maybe False (a ==) $ Data.Typeable.cast b
19:28:56 <lambdabot> forall a a1. (Typeable a, Typeable a1, Eq a) => a -> a1 -> Bool
19:28:56 <jamii> thesquib: It can be done, give me a minute to find the right libraries
19:29:00 <kpreid> there you go
19:29:01 <thesquib> I created a queue implementation - in order to learn haskell. I was just thinking of being able to compare two queues of different types. But why would you ever do that anyway.
19:29:13 <kpreid> you can compare arbitrary Typeable lists with that :-)
19:29:25 <kpreid> it'll just always be false unless they are the same
19:29:32 <thesquib> oh cool
19:29:38 <thesquib> thanks for that
19:29:44 <vixey> I don't see why that's cool :|
19:29:53 <jamii> damp kpreid beat me to it
19:29:54 <kpreid> @let (=:=) a b = maybe False (a ==) $ Data.Typeable.cast b
19:29:55 <lambdabot> Defined.
19:30:03 <thesquib> Well - just to know it is possible.
19:30:03 <jamii> *damn, not damp
19:30:07 <kpreid> > "a" =:= [1 :: Int]
19:30:08 <lambdabot>  False
19:30:09 <vixey> > pig :=: sheep
19:30:10 <lambdabot>   Not in scope: `sheep'
19:30:13 <kpreid> > "a" =:= "b"
19:30:14 <lambdabot>  False
19:30:16 <kpreid> > "a" =:= "a"
19:30:17 <lambdabot>  True
19:30:34 <jamii> vixey: Wait, 'pig' is in scope?
19:30:35 <kpreid> thesquib: after you learn how it works, you might decide it's not actually possible :)
19:30:45 <vixey> of course :P
19:30:54 <jamii> :t pig
19:30:55 <lambdabot> Not in scope: `pig'
19:30:59 <jamii> Lies
19:31:00 <kpreid> thesquib: Data.Typeable.cast is a very neat trick, though.
19:31:08 <kpreid> @type Data.Typeable.cast
19:31:10 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
19:32:51 <vixey> what can you do with it ?
19:32:55 <Cale> > pig
19:32:56 <lambdabot>  "yellow"
19:33:00 <vixey> is there anything useful
19:33:28 <vixey> there exists at least one pig that's yellow on at least one side :P
19:34:00 <lament> > pig
19:34:01 <lambdabot>  "yellow"
19:34:10 <Cale> I wonder how many people in this channel would get that reference.
19:34:24 <lament> at least 0
19:34:54 <vixey> > reverse . reverse $ pig
19:34:54 <lambdabot>  "purple"
19:35:07 <jamii> Cale: Dont think this will work. I can transform the syntax but it would then require that all inputs be in the same monad. So if I go from completely pure to adding an IO input all the other inputs will change to IO too. Its like IO ebola
19:35:28 <thesquib> > reverse
19:35:29 <lambdabot>  Add a type signature
19:35:44 <vixey> o_O
19:35:50 <lament> > reverse pig
19:35:52 <lambdabot>  "elprup"
19:36:18 <SyntaxNinja> Lemmih: is there a version of cabal-install that builds with ghc 6.8?
19:36:35 <jamii> I wonder why DDC needs to be eager,,,
19:36:42 <thesquib> > reverse [1,2,3]
19:36:43 <lambdabot>  [3,2,1]
19:36:46 <thesquib> ah crap
19:36:52 <thesquib> i just made a function to reverse a list
19:36:53 <thesquib> haha
19:36:53 <edwardk> jamii: regions
19:36:58 <dons> SyntaxNinja: i think you need the darcs version
19:37:09 <vixey> thesquib: lets see it ?
19:37:11 <edwardk> jamii: the semantics don't work if you can be lazy you never know when th destroy the region basically
19:37:41 <thesquib> reverseList (h:t) = (reverseList t) ++ h:[]
19:37:44 <thesquib> basically that
19:37:44 <jamii> Ok. And the regions are necessary to get mutable variables.
19:37:53 <Cale> thesquib: As a beginner, be prepared to rewrite half the functions in the Prelude and List library before noticing that they're there :)
19:37:58 <vixey> thesquib: you know that does a lot of work
19:37:59 <thesquib> but I think I should use foldl
19:37:59 <edwardk> jamii: explicit region based memory management and a lazy language don't seem to play nice. i spent a few months beating my head against it
19:38:05 <jamii> Cale: Only as a beginner?
19:38:05 <vixey> thesquib: which it needn't
19:38:12 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
19:38:14 <vixey> thesquib: wanna see another way to write append?
19:38:14 <lambdabot>  [5,4,3,2,1]
19:38:43 <jamii> edwardk: I thought the regions in DDC were only to keep track of what was mutable. It doesnt use them for memory management?
19:38:45 <thesquib> definitely. I couldn't figure out how to put an item at the end of a list easily
19:38:55 <lament> he's a squib, he'll never understand it!
19:39:00 <vixey> > let revapp [] ys = ys ; revapp (x:xs) ys = revapp xs (x:ys) in revapp "foo" "bar
19:39:00 <lambdabot>  Improperly terminated string at ""bar" (column 77)
19:39:03 <vixey> > let revapp [] ys = ys ; revapp (x:xs) ys = revapp xs (x:ys) in revapp "foo" "bar"
19:39:03 <lambdabot>  "oofbar"
19:39:10 <vixey> reverse = flip revapp []
19:39:19 <thesquib> heh, I may be a squib, but not a damp squib
19:39:28 <vixey> and the same thing, much more elegantly as Cale put it
19:39:31 <vixey> reverse = foldl (flip (:)) []
19:40:08 <Zao> :t \x -> (++[x])
19:40:10 <lambdabot> forall t. t -> [t] -> [t]
19:40:12 <vixey> but yea that traverse the xs list once
19:40:23 <vixey> whereas your version does append O(n), n times
19:40:53 <vixey> @pl \x -> (++[x])
19:40:53 <lambdabot> flip (++) . return
19:40:57 <Cale> thesquib: Yeah, if you have to put items at the end of a list repeatedly, it might be worth reconsidering the way you do things.
19:41:13 <jamii> Or use Data.Sequence
19:41:23 <vixey> or just put things at the front
19:41:26 <Cale> Well, that would be reconsidering the way you do things :)
19:41:28 <edwardk> jamii: then lippmeier might be able to use lazy semantics if he had wanted to
19:41:32 <jamii> vixey: Never
19:42:10 <Cale> I rather like the trick of using functions which prepend the list elements to a list, in place of lists.
19:42:23 <Cale> Then concatenation is composition, which is O(1)
19:42:44 <jamii> edwardk: He has nice syntax for suspending but it only works on pure values. If you suspend a function of mutable values its semantics depend on when it is evaluated.
19:42:51 <vixey> > (reverse .) . (. reverse) . (:) 7 [1,2,3]
19:42:51 <lambdabot>   add an instance declaration for (Num ([a] -> [a1]))
19:44:07 <solrize_> but then you have to call through the composed function to get each element so it's O(n) again anyway?
19:44:26 <edwardk> heya dolio, starting work on parameterized comonads for sake of completeness =/
19:44:41 <Cale> solrize_: well, building up the whole list is O(n)
19:44:50 <jamii> solrize: Its O(n^2) if you just append to the end
19:44:52 <Cale> solrize_: Whereas it would have been O(n^2)
19:45:26 <dolio> edwardk: Like type indexed? 'w i k a -> w i j (w j k a)'?
19:46:26 <edwardk> dolio: i have two 'flavors' at the (co)monad/functor, parameterized which carries around one extra term of kind *, and higher order which carries around a functor (so carries around something of kind * -> *)
19:47:19 <edwardk> parameterized monads/comonads are both bifunctors, the higher order monad/comonad stuff are monads/comonads over 1-cells, which could be used if i ever get to the point where i can understand what a higher order generalized hylomorphism would mean =)
19:47:39 <dolio> Heh.
19:48:30 <edwardk> but basically its not that hard to understand the higher order case in general, it just allows use of more complicated recursion patterns, so you could make a hylomorphism that had perfect trees as an intermediate result
19:48:32 <edwardk> for instance
19:49:18 <edwardk> just hurts a bit to think through useful higher order monads/comonads, though right kan extension looks kinda like higher order 'Cont' in that setting, etc. so there is hope =)
19:49:50 <dolio> Yeah, I was reading through Initial Algebra Semantics is Enough yesterday and it goes into a lot of that.
19:50:04 <edwardk> yeah
19:50:36 <edwardk> dragged in the stuff from that and the monadic augment for generalized shortcut fusion, and started work on dualizing all of it
19:52:16 <dolio> So the parameterized (co)monads are something other than the ones typically used for, say, indexed state?
19:52:24 <dolio> Or delimited continuations?
19:52:46 <edwardk> parameterized monads should be like those. higher order ones are a little different
19:53:04 <edwardk> i just wanted the dual construct so i could do the same to my comonads
19:53:12 <dolio> Well, then, I'm confused. Don't you need two indices for those?
19:53:36 <edwardk> checking, its been a while. i remember the old post by roundy about his version
19:53:57 <edwardk> those were w i j a -> (a -> w j k a) -> w i k a ?
19:54:50 <dolio> Yeah. For state in the first one, i is the incoming state type, and j is the outgoing state type.
19:54:56 <edwardk> *nods*
19:55:37 <edwardk> the chani/johann/uustalu/vene one has  (a -> f b c) -> f a c -> f b c (carrying its parameter in the second term, but only carrying one, so you have to use the same parameter across the bind
19:55:47 <edwardk> so its weaker than the type-indexed monads
19:56:02 <dolio> I see.
19:56:07 <edwardk> er s/chani/ghani
19:56:52 <edwardk> this notion of parameterized has the nice aspect that you can view the underlying FreeS functor you were playing with before as a 'parameterized monad' and the fact that its fold is a monad follows from a general construction
19:57:28 <edwardk> which would generalize the construction of the (co)free (co)monad to other base parameterized (co)monads
19:58:34 <edwardk> and you get your earlier wish of not having the fixpoint be baked into Free/Cofree
19:58:42 <dolio> Heh.
19:58:56 <edwardk> also a PMonad in the above sense is also a bifunctor
19:59:19 <edwardk> so it fits nicely with jeremy gibbons' style bifunctor based hylo- stuff
19:59:55 <edwardk> so i think i may have to go back through and add yet another notion for Control.Monad.TypeIndexed.
19:59:57 <edwardk> gah
20:00:02 <edwardk> too many subtle variations =)
20:00:06 <dolio> :)
20:00:25 <dolio> I ran into a snag trying to make an indexed monad class a while back.
20:00:39 <edwardk> oh?
20:00:50 <dolio> I think it didn't like 'class (Functor (m i j)) => IMonad m'.
20:00:56 <edwardk> yeah you can't do that
20:01:10 <dolio> We need foralls in contexts. :)
20:01:14 <edwardk> thats why i defined my version of parameterized monads
20:01:18 <edwardk> er my old one
20:01:36 <chessguy> 'evening
20:01:49 <jamii> Morning
20:01:55 <edwardk> dolio: http://comonad.com/reader/2007/parameterized-monads-in-haskell/
20:01:57 <lambdabot> Title: The Comonad.Reader  Parameterized Monads in Haskell
20:03:23 <edwardk> heya chessguy
20:03:49 <edwardk> dolio: yes, we do, i have no idea how you'd get them to work, but yes we do =)
20:04:42 <dolio> I think i saw a request for it in a H' ticket or something.
20:05:11 <dolio> Or maybe it was somewhere else, I forget exactly.
20:05:30 <edwardk> i think it plays hell with overlapping instances though
20:08:23 <Saizan> does the typechecker do any backtracking when deciding instances?
20:08:35 <vixey> I think not
20:08:50 <edwardk> Saizan: nope
20:11:07 <Saizan> it seems some limitations would be solved with that, but i guess it introduces non-termination?
20:11:45 <vixey> I don't think so
20:12:17 <edwardk> saizan: i think it just introduces an extra exponential time component into determining failure
20:14:29 <Saizan> which is never good
20:14:43 <edwardk> dolio: heh i just ran into that very forall problem trying to allow hjoin and hbind to be defined metacircularly, bah
20:14:51 <dolio> :)
20:20:33 <edwardk> @pl \g k -> g (InB . pbind (outB . k))
20:20:33 <lambdabot> (. ((InB .) . pbind . (outB .)))
20:20:47 <edwardk> @pl \k -> g (InB . pbind (outB . k))
20:20:47 <lambdabot> g . (InB .) . pbind . (outB .)
20:20:58 <edwardk> nevermind
20:21:05 <SyntaxNinja> just released my command-line RSS feed generator: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/feed-cli-2008.5.3
20:21:07 <lambdabot> http://tinyurl.com/66ptxe
20:21:10 <SyntaxNinja> (will do a proper announcement later)
20:22:10 <SyntaxNinja> lemmy know if anyone tries it and there are any problems.
20:22:16 <roconnor> SyntaxNinja: isn't RSS last centry?
20:22:47 <roconnor> SyntaxNinja: oh, and congratz!
20:23:42 <SyntaxNinja> roconnor: well, it's 2.0
20:23:54 <SyntaxNinja> if anything command-lines are last century ;)
20:24:03 <SyntaxNinja> roconnor: on getting married? thanks :)
20:38:26 <SyntaxNinja> is the output of cron stored anywhere, or is it just emailed?
20:40:52 <eck> i'm trying to learn about concurrency in haskell, and my question is why doesn't this program use more than one cpu when i compile it using ghc -threaded ? http://hpaste.org/7373
20:41:08 <edwardk> i believe it is just emailed
20:41:17 <eck> oops that should be main = fibIO 30 >>= print
20:44:18 <sohum> hey all. what's the inverse of (++)?
20:44:37 <edwardk> sohum: you mean to remove from the end of a list?
20:44:46 <sohum> remove from a list in general.
20:44:48 <SyntaxNinja> sohum: depends on how you want to separate the strings/list
20:44:52 <edwardk> @type (\\)
20:44:54 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
20:44:57 <SyntaxNinja> @type take
20:44:59 <lambdabot> forall a. Int -> [a] -> [a]
20:45:05 <edwardk> > [1,2,3] \\ [2]
20:45:06 <lambdabot>  [1,3]
20:45:20 <sohum> > [1,2,2,3] \\ [2]
20:45:21 <lambdabot>  [1,2,3]
20:45:26 <sohum> score.
20:45:27 <SyntaxNinja> take 5 [1..10]
20:45:28 <edwardk> that removes from anywhere in the string, so its not strictly an inverse operation of (++)
20:45:35 <SyntaxNinja> > take 5 [1..10]
20:45:36 <lambdabot>  [1,2,3,4,5]
20:45:37 <edwardk> er s/string/list
20:45:45 <sohum> it's close enough for me. thank you very much!
20:45:48 <edwardk> np
20:45:54 <vixey> the inverse of ++ is nondeterministic I guess
20:46:00 <edwardk> yeah
20:46:15 <Ugarte> eck: According to http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#1, threading is done in the Haskell runtime, which to me would imply that it won't be parallelized on multiple CPUs, but I might be wrong.
20:46:17 <lambdabot> http://tinyurl.com/y2q5k2
20:46:31 <Ugarte> eck: It's not something I have any knowledge on myself, so take what I said with a grain of salt. But that's a possible explanation.
20:46:45 <EvilTerran> vixey, well, you can talk about it as a relation between three lists
20:46:51 <edwardk> eck: did you give the right commandline/compiler flags or whatever?
20:47:09 <vixey> I like that
20:47:13 <vixey> relations are good
20:47:25 <eck> edwardk: i guess not, i just compiled with -threaded
20:47:29 <eck> do i need to pass in an rts option
20:47:35 <vixey> for algebra
20:47:51 <EvilTerran> indeed, [a] and (++) form a group, i think
20:48:08 <EvilTerran> no, wait, never mind
20:48:14 <edwardk> http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html#parallel-options
20:48:15 <lambdabot> Title: 5.12. Using SMP parallelism, http://tinyurl.com/ytnnbg
20:48:19 <ddarius> EvilTerran: They (with []) form a monoid.
20:48:23 <sohum> wait, where is \\ defined?
20:48:24 <edwardk> they are a monoid
20:48:29 <vixey> @src (\\)
20:48:30 <lambdabot> (\\) = foldl (flip delete)
20:48:31 <Ugarte> Ah.
20:48:33 <EvilTerran> i know they form a monoid. i was just thinking about invertibility.
20:48:34 <edwardk> sohum: check data.list
20:48:58 <sohum> @src (delete)
20:48:58 <EvilTerran> ?index \\
20:48:58 <lambdabot> Source not found. Sorry.
20:48:58 <lambdabot> bzzt
20:49:02 <edwardk> evil: you have no 'negative lists'
20:49:02 <EvilTerran> ?index (\\)
20:49:02 <lambdabot> bzzt
20:49:07 <eck> oh i see
20:49:08 <sohum> @type (delete)
20:49:10 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
20:49:28 <sohum> > delete 5 [1..5]
20:49:30 <lambdabot>  [1,2,3,4]
20:49:32 <EvilTerran> edwardk, indeed. as i said, i was still in the process of thinking about it :P
20:49:43 <sohum> > delete 3 $ [1..5] ++ [3]
20:49:45 <lambdabot>  [1,2,4,5,3]
20:50:59 <edwardk> heh i think you might be able to make DList into a group though if you ignore the rules for the structure of the functions it holds
20:51:17 <edwardk> and you never wanted a functor instance for it, and, and ..
20:51:19 <EvilTerran> from the relation point of view, the three-way "xs ++ ys = zs" is clearly a function (xs,ys)->zs, but i don't know if it's a function any other way
20:51:32 <EvilTerran> *three-way relation
20:52:20 <vixey> it's a function when two of {xs,ys,zs} are known
20:52:20 <edwardk> meh, its a monoid moving along =)
20:52:24 <EvilTerran> i don't think it is, because of infinite lists and suchlike
20:52:32 <EvilTerran> edwardk, you're missing the point
20:53:03 <EvilTerran> being able to take some of the parameters of a function and its result and calculate the remaining parameters, at runtime, would be kinda useful
20:53:36 <roconnor> did someone say Prolog?
20:53:53 <EvilTerran> vixey, xs = [1..]  =>  zs = [1..], and then you don't know what ys is
20:53:54 <edwardk> evilterran: i don't disagree on that front, i was talking about DList =)
20:53:54 <eck> even if i use +RTS -N2 it still only uses one cpu... i was wondering if there is a problem with the logic of my program that makes ghc not want to parallelize it
20:54:01 <EvilTerran> ok
20:54:02 <jamii> roconnor: back in your cage :-)
20:54:31 <vixey> CHR is cool too
20:54:33 <EvilTerran> vixey, and, given ys = zs = repeat 1, you can't tell what xs is
20:54:39 <vixey> EvilTerran: yeah :(
20:54:41 <edwardk> as for taking the result and other parameters, sounds like MPTCs or equivalently like roconnor said, prolog
20:54:48 <vixey> My brain still works inductively
20:54:53 <EvilTerran> indeed, it'd be a logic language thing, not an FP thing
20:55:02 <vixey> I wonder if CHR is the next thing after Prolog
20:55:07 <vixey> @go MPTC
20:55:22 <lambdabot> Plugin `search' failed with: thread killed
20:56:23 <roconnor> eck: are you using any parallel haskell features?
20:56:40 <eck> roconnor: i'm using forkIO
20:56:43 <jamii> roconnor: No, its just mvars and forkIO
20:56:43 <edwardk> he has a couple of forkIOs
20:56:49 <jamii> It should work
20:56:53 <roconnor> oh
20:56:55 <roconnor> good
20:57:01 <vixey> what's MPTC?
20:57:12 <roconnor> @what MPTC
20:57:13 <lambdabot> I know nothing about mptc.
20:57:16 <roconnor> :(
20:57:22 <jamii> eck: Are you getting the right answers? What platform are you on? What version of GHC?
20:57:26 <roconnor> multi parameter type classes
20:58:10 <eck> jamii: ghc 6.8.2 on 64 bit linux, i have a dual core cpu but only one core ends up being used
21:02:17 <roconnor> @type (7,)
21:02:19 <lambdabot> parse error on input `)'
21:02:29 <sjanssen> roconnor: nope, no tuple sections
21:02:35 <jamii> Hmm. Doesnt work on mine either. Lets go peek at the docs
21:03:09 <sjanssen> eck: did you build with -threaded and run with +RTS -N2?
21:03:21 <sjanssen> eck: oh, sorry, you already covered that
21:03:37 <Cale> eck: Don't fork processes for small cases.
21:04:11 <vixey> :t (,) 7
21:04:13 <lambdabot> forall t b. (Num t) => b -> (t, b)
21:05:14 <Cale> eck: and see if that helps...
21:05:43 <Cale> eck: also, you do know about par, right?
21:06:06 <sjanssen> forking an exponential number of threads and creating as many MVar's is bound to be slow
21:06:38 <Cale> I get the feeling that your program is probably spending most of its time scheduling threads.
21:06:44 <vixey> > 1 , 2
21:06:44 <lambdabot>   parse error on input `,'
21:06:55 <vixey> > let , = (,) in 1 , 2
21:06:55 <lambdabot>  Parse error at "," (column 5)
21:06:59 <vixey> :/ ??
21:07:17 <sjanssen> roconnor: I pine for list sections -- [,2,] 1 3 == [1, 2, 3]
21:07:24 <sjanssen> vixey: , is not a valid operator character
21:07:33 <vixey> is someone using , for something?
21:07:48 <vixey> why can't I have it :P
21:08:06 <vixey> > let ' = ' in '
21:08:06 <lambdabot>  Improperly terminated character constant at "'" (column 5)
21:08:08 <sjanssen> vixey: , is special syntax because it is used for lists, tuples, and records
21:08:09 <Cale> vixey: It's part of the syntax of lists, tuples and list comprehensions, module export lists...
21:08:24 <Cale> Oh yeah, records...
21:08:27 <EvilTerran> vixey, SPJ is using it - as Cale and sjanssen just explained before i got the chance :P
21:09:00 <sjanssen> vixey: similarly, ' can't be the first character in an identifier
21:09:04 <Cale> So you can't use it as an operator symbol without making the grammar of Haskell horribly horribly ambiguous.
21:09:19 <EvilTerran> > let (,) = (+) in (1,2)
21:09:20 <lambdabot>      Constructor `(,)' should have 2 arguments, but has been given 0
21:09:20 <lambdabot>     In t...
21:09:21 <EvilTerran> aww
21:09:42 <Cale> > let (,) x y = (1,2) in x + y
21:09:43 <lambdabot>  3
21:09:48 <roconnor> how do I get the filename before the dot from a fully qualified filename?
21:10:00 <vixey> > let (x,y) = (x+y) in (1,1)
21:10:00 <roconnor> before the dot and after the directory
21:10:00 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t)
21:10:00 <lambdabot>       Expec...
21:10:02 <vixey> > let (x,y) = (x+y) in (1,2)
21:10:03 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t)
21:10:03 <lambdabot>       Expec...
21:10:11 <vixey> > let (x,y) = (x+y) in 1
21:10:12 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t)
21:10:12 <lambdabot>       Expec...
21:10:15 <vixey> wat
21:10:17 <vixey> what *
21:10:47 <Cale> vixey: What's the type of x?
21:10:55 <eck> it's certainly a lot faster if i don't forkio for small n but it still doesn't use more than one cpu... i'm going to see if i can come up with a better example, because i realize now that the cost of creating threads and locking around mvars and whatnot is going to be way, way more than the cost of actually doing the math
21:10:59 <vixey> I don't knwo
21:11:08 <EvilTerran> note that x+y must be the same type as x, and (x,y) must be the same type as x+y
21:11:11 <Cale> If adding x to y produces (x,y), well, first of all x and y must have the same type
21:11:12 <EvilTerran> in that definition
21:11:21 <Cale> and the result has to have the same type as each of them
21:11:29 <vixey> I thought it was the other way around
21:11:35 <vixey> (x,y) produces x+y
21:11:38 <Cale> but if (t,t) is the same type as t
21:11:49 <vixey> let A = B doesn't mean the same as let B = A
21:11:49 <EvilTerran> vixey, you're doing a pattern-match here, not a function definition
21:11:53 <EvilTerran> (,) is a constructor
21:11:58 <Cale> then the type t has to look like an infinitely nested tree of pairs
21:12:08 <EvilTerran> > let (x,y) = (2,3) in x+y
21:12:10 <lambdabot>  5
21:12:11 <vixey> > let Just x = Just 1 in x
21:12:13 <lambdabot>  1
21:12:17 <vixey> what O_o
21:12:25 <vixey> I didn't even know you could do that :D
21:12:36 <EvilTerran> you're not redefining Just, you're pattern-matching on the constructor
21:12:45 <vixey> that's so odd
21:12:49 <Cale> Such definitions are called pattern bindings.
21:12:49 <EvilTerran> it's so handy
21:12:53 <EvilTerran> particularly for tuples
21:12:59 <Cale> It's very natural to allow them :)
21:13:09 <vixey> this is cool
21:13:25 <EvilTerran> foo xs = ... where (ys,zs) = span p xs -- same trick
21:13:25 <vixey> > let (odd,even) = (not.odd,not.even) in odd 7
21:13:25 <lambdabot>  Add a type signature
21:13:42 <EvilTerran> infinite loop whee!
21:14:10 <vixey> oh that'll never work
21:14:15 <vixey> > let (odd,even) = (not.even,not.odd) in odd 7
21:14:24 <EvilTerran> you'll still get the same type error
21:14:30 <lambdabot>  thread killed
21:14:39 <EvilTerran> ... or would, if lambdabot liked you
21:16:12 <vixey> > let (odd,even) = (not.even,\x -> if x == 0 then True else not . odd $ x) in odd 7
21:16:21 <lambdabot> Terminated
21:16:28 <vixey> :/
21:16:47 <keir> has anyone worked with sparse matricies in haskell? i.e. bindings to UMFPACK and such?
21:19:25 <jamii> Actually, I cant even persuade this http://hpaste.org/7374 to use more than one cpu
21:19:43 <jamii> Compiled with -threaded and run with +RTS -N2 -K100m
21:20:24 <sjanssen> jamii: I think you need to be a bit more clever with your par
21:20:47 <sjanssen> print (a `par` b `seq` (a+b)) -- should work
21:21:04 <sjanssen> and you might want to use pseq instead of seq
21:21:31 <jamii> Which of those binds first?
21:22:21 <jamii> Is it just sparking off and evalutating the top thunk at the moment?
21:22:52 <sjanssen> jamii: that sparks a, evaluates b to completion, then evaluates a + b
21:23:12 <sjanssen> jamii: also, fac 100 is way faster than fib 100
21:23:16 <ddarius> vixey: You forgot a -1
21:23:21 <sjanssen> > product [1 .. 100]
21:23:22 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
21:23:48 <jamii> Hooray, 190% cpu
21:23:57 <keir> is there anyone here who makes money programming in haskell?
21:24:05 <ddarius> keir: Many.
21:24:36 <jamii> sjanssen: Neither is very fast the way I wrote it
21:24:47 <vixey> edwardk, what's MPTC?
21:24:59 <keir> ddarius, cool.
21:25:07 <vixey> oh is it multi-parameter type classes?
21:25:10 <jamii> Its still using 180% cpu so I guess the fac 100 is going on for a while
21:25:16 <keir> i am thinking of abandoning my C++ structure from motion library and switching to haskell.
21:25:25 <keir> i want programming to be fun again :)
21:25:38 <edwardk> vixey: multiparameter typeclasses =)
21:26:17 <sjanssen> jamii: it is more likely that a is being evaluated twice
21:27:01 <sjanssen> jamii: even though that version of fac isn't the best, it is still linear vs. fac's exponential time
21:27:28 <jamii> sjanssen: Im beginning to think I dont understand the semantics of par. Why would a evaluate twice?
21:28:18 <sjanssen> jamii: thunks can sometimes be evaluated twice -- GHC doesn't lock the thunks
21:28:47 <jamii> bugger
21:28:55 <sjanssen> jamii: officially, the semantics are "par _ x = x"
21:29:10 <sjanssen> denotational semantics, that is
21:33:38 <jamii> If I change a to fac 10000 it goes back to using one cpu. So whether or not it double evaluates an expensive thunk is unpredictable.
21:34:09 <jamii> Which is less than encouraging
21:35:00 <roconnor> @hoogle [(a,b)] -> a -> [b]
21:35:01 <lambdabot> No matches, try a more general search
21:35:07 <jamii> At leasy I understand why. Thanks sjanssen
21:35:22 <vixey> :t flip lookup
21:35:24 <lambdabot> forall a b. (Eq a) => [(a, b)] -> a -> Maybe b
21:35:42 <vixey> grr
21:36:07 <roconnor> Too bad map a (set b) isn't as easy to use as a -> [b]
21:36:09 * vixey wonders what use [(a,b)] -> a -> [b] is ..
21:36:27 <roconnor> vixey: lookup all?
21:36:34 <vixey> yeah but
21:37:19 <vixey> why not have like a DAG representation kind of [(a,[b])]
21:37:31 <vixey>  any graph*
21:38:23 <roconnor> vixey: No strong reason. I wanted to process edges.
21:38:39 <roconnor> one entry one edge
21:38:45 <vixey> oh I see
21:38:51 <roconnor> that can still be done with your repesentation
21:39:02 <roconnor> but things get slightly messier
21:39:17 <roconnor> anyhow, I sort of want to use map a (set b)
21:39:37 <roconnor> 'cause my exteremely naive program is slower than I hoped.
21:40:54 <roconnor> someone ought to write Data.Multimap
21:41:02 <roconnor> it should be easy
21:41:06 <roconnor> but it ought to be done.
21:41:36 <olsner> Map a [b] or Map a (Set b) should do the trick... but that does lack a Multimap:y interface
21:42:17 <roconnor> exactly
21:42:35 <roconnor> ... I wonder if I can implement the efficent program before the naive program finishes.
21:42:47 <roconnor> well, more efficent
21:43:26 <jamii> roconnor: Ill add it to my todo list
21:44:07 <olsner> what you really want is to write a GHC optimization pass that transforms your naive (list-based?) program into the efficient program :P
21:44:14 <roconnor> jamii: ?
21:44:24 <jamii> multimap
21:44:55 <roconnor> you have a todo list for haskell programming tasks?
21:47:15 <vixey> :t filter ((==?a).fst)
21:47:16 <lambdabot> Not in scope: `==?'
21:47:17 <jamii> I have a gsoc project to complete adrians map library
21:47:21 <vixey> :t filter ((== ?a).fst)
21:47:23 <lambdabot> forall a b. (Eq a, ?a::a) => [(a, b)] -> [(a, b)]
21:47:34 <vixey> :t map snd . filter ((== ?a).fst)
21:47:35 <lambdabot> forall a b. (Eq a, ?a::a) => [(a, b)] -> [b]
21:49:29 <roconnor> jamii: ah
21:49:40 <roconnor> jamii: what is adrian's map library?
21:50:35 <jamii> Faster int maps, fast list tries, generalised tries and maybe pure hashmaps if theres time
21:51:06 <roconnor> oh
21:51:08 <roconnor> nice
21:55:55 <glguy> @seen dons
21:55:55 <lambdabot> dons is in #haskell-hac4, #haskell-soc, #xmonad and #haskell. I last heard dons speak 1h 50m 34s ago.
22:03:25 <geezusfreeek> wow http://www.myspace.com/themonads
22:03:25 <lambdabot> Title: MySpace.com - The Monads - St. Louis - Punk / Bluegrass / Rockabilly - www.myspa ...
22:12:55 * roconnor ponders how to reasonably efficently find all the reachable nodes from a node in a digraph
22:13:31 <megeria> sorry i am a bit puzzle about the behaviour when ThreadKilled is called (http://hpaste.org/7375), not sure why test1 hClose the second time since withFile should catch the ThreadKilled and hClose it then finalize right?
22:14:47 <Jedai> jamii: Pure Hashmap ? A Map (Trie rather) using a hash of the data ?
22:15:30 <jamii> Yep. Clojure using them. Split the hash into a list of 5bits integers and build a trie
22:15:36 <jamii> *uses them
22:16:00 <Jedai> jamii: And that's efficient for which case ?
22:16:21 <jamii> More efficient than maps when youre comparisons are very expensive.
22:16:42 <jamii> For example if you want to use 1000000 elem sets as keys (for some reason)
22:16:43 <Jedai> jamii: Ah right :)
22:16:47 <jamii> *your
22:17:35 <Jedai> jamii: Still you need a good hash function (how will you do that ?)
22:18:13 <jamii> I imagine some sort of polytypic hash. Recurse along the data type and combine the hashes somehow
22:18:48 <jamii> I basically intend to wholesale rip off the clojure code.
22:19:26 <Jedai> jamii: Maybe you could provide a typeclass for the hash function with a defaut generic implementation ?
22:19:53 <jamii> That would be a good idea. Haskell needs a hash class
22:20:25 <jamii> But the generalised tries have to come first, seeing as that was the actual content of my proposal
22:20:32 <adu> isn't there a Data.HashTable?
22:20:47 <Jedai> Well anyway, good luck to you, that sounds all very interesting (we need some very efficient data collections in Haskell)
22:21:46 <jamii> adu: The hashtable uses destructive updates. A hashmap sacrifices fast inserts to get persistence and purity
22:22:01 <adu> hmm ok
22:22:18 <Jedai> adu: I heard bad things about HashTable, like how it wasn't even more efficient than Data.Map in most case...
22:22:45 <adu> Jedai: I've never used it, I just use lists of tuples... :P
22:22:48 <jamii> Its not that theres a big need for it, just that I need to implement most of it for other stuff anyway
22:22:50 <Jedai> Which is pretty bad when  HashTable isn't even functionnal or persistent
22:23:31 <Jedai> jamii: Generalized Tries should be nice (plenty of application where they're better than Map)
22:23:34 <jamii> I suspect that since maps are preferred anyway not much effort has gone into tuning the hashtable
22:24:02 <Jedai> jamii: That was my impression too.
22:24:57 <Jedai> adu: You should really use Map, they're pretty easy to use, give more functionnality than association list and have better performance
22:25:14 <jamii> jedai: GTs will only be useful for complicated key types. The thing I will be using them for is mapping from subsets to values for dynamic programming
22:25:25 <adu> ok, i'll give it a try
22:26:05 <Jedai> adu: Also you can use them mostly as drop-in replacement for your lists with the fromList and toList functions
22:26:23 <adu> cool
22:27:10 <jamii> Id also like to write STM skiplists. Maybe once my gsoc stuff is finished
22:27:21 <Jedai> adu: There's one more requirement though, your key type must be an instance of Ord and not only of Eq (but most type are Ord instance anyway)
22:27:58 <adu> Jedai: sounds like Data.Set
22:28:56 <jamii> adu: Sets and maps have almost the same implementation
22:28:56 <Jedai> adu: Well they looks similar (balanced binary tree) but Data.Map is a map between key and value whereas Data.Set only contains a set of values
22:29:15 <adu> no I meant on the Ord requirement
22:29:18 <jamii> Effectively   Set a == Map a Bool
22:29:44 <adu> just like 2^Set
22:30:03 <Jedai> adu: Yes, that's to allow Data.Map to perform comparison between keys (like Data.Set performs comparison between values)
22:30:26 <adu> for log-time access?
22:30:35 <Jedai> adu: Yes :)
22:30:38 <adu> :)
22:30:50 <ddarius> Map a ()
22:31:10 <jamii> ddarius: Ssh
22:31:49 <koninkje> @pl \xs ys -> foldr ((.|.) . return) (return ()) (zip xs ys)
22:31:50 <lambdabot> (foldr ((.|.) . return) (return ()) .) . zip
22:32:02 <jamii> I was hoping I would get away with it
22:32:23 <sjanssen> data Void; type Set a = Map a Void
22:32:33 <adu> I need to get a new hobby, or a new computer, waiting for computations to finish is so boring
22:32:36 <vixey> :t &&&
22:32:38 <lambdabot> parse error on input `&&&'
22:33:06 <roconnor> :t (&&&)
22:33:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:36:24 <jamii> Hmmm. data DefaultMap k = Map m k => DM m k; instance Map (DefaultMap k) k where ...
22:38:10 <ddarius> adu: Take up yoga.
22:38:21 <adu> ddarius: lol
22:38:51 <adu> ddarius: my favorite position is the tailor
22:57:29 <jberryman> is there a way to find the integer approximation square root of an Int more effeciently than: truncate . sqrt . fromIntegral?
22:57:51 <vixey> yeah
22:58:16 <adu> binomial theorem
22:58:17 <vixey> > let sqrts = map (truncate . sqrt . fromIntegral) ([1..] :: [Int]) in sqrts !! 9
22:58:18 <lambdabot>  3
22:58:34 <vixey> it tables results so you use a lot of mem but lookup is fastish
22:58:50 <vixey> then again, is this actually faster? ...
22:59:39 <adu> binomial theorem is faster
22:59:53 <vixey> what's the code?
23:00:36 <HunterXHunter> > let sqrts = map (truncate . sqrt . fromIntegral) ([1..] :: [Int]) in sqrts !! 1000
23:00:37 <lambdabot>  31
23:08:59 <jberryman> adu: how would I use the binomial theorem?
23:09:43 <orbitz> sqrts, doesn't make me think of square root
23:11:13 <mib_bgvgxz> anyone here tried scala?
23:12:17 <mib_bgvgxz> anyone tried erlang?
23:12:24 <HunterXHunter> me
23:12:39 <mib_bgvgxz> are they good?
23:12:47 <HunterXHunter> no idea
23:12:54 <HunterXHunter> go try and see
23:13:12 <mib_bgvgxz> don't have time to try
23:14:02 <vixey> mib_bgvgxz: yes they are good
23:14:19 <vixey> (actually scala might not be)
23:14:23 <mib_bgvgxz> do you see regular software developed in erlang?
23:14:33 <mib_bgvgxz> or only server stuff
23:19:23 <jberryman> don't know how I missed this: http://en.wikipedia.org/wiki/Integer_square_root
23:20:00 <jberryman> link at the bottom to implementation in many languages including haskell
23:21:03 <adu> jberryman: I'm sorry, I tried implementing it with the binomial theorem (sqrt x = 1 + (x-1)/2 - (x-1)**2/8 + (x-1)**3/16) and it actually sucks
23:21:08 <adu> so n/m
23:22:11 <adu> jberryman: I was thinking you could do 1 + (x-1)`div`2 - (x-1)^2`div`8 ... but this doesn't work either, o well
23:22:28 <vixey> what
23:24:04 <vixey> jberryman: is isqrt faster than sqrt
23:26:23 <jberryman> the code linked to on the wikipedia page is causing stack overflows when I tested it just now, and it's slower
23:26:35 <vixey> :D
23:35:34 <jberryman> maybe I will play around with approximations, since I'm just using the isqrt thing to limit my prime factorization tests
23:35:38 <jberryman> http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
23:37:02 <jberryman> adu: thanks though
23:37:11 <adu> np
23:37:22 <solrize_> jberryman depending on the cpu, the fsqrt instruction can be extremely fast, basically the same as an fdiv
23:37:51 <solrize_> in the slow divider era the fastest way to do isqrt was a table lookup on the high order bits followed by a newton-raphson correction or two
23:37:57 <solrize_> knuth vol 2 discusses it some
23:38:21 <solrize_> these days fsqrt is probably about as good as you can hope for
23:42:32 * jberryman googles
23:42:37 <jberryman> so that is what sqrt is compiled down to, or am I misunderstanding?
23:42:47 <solrize_> sorry?
23:42:49 <vixey> :t sqrt
23:42:50 <lambdabot> forall a. (Floating a) => a -> a
23:43:06 <solrize_> i just mean floating point square root these days is usually done with a hardware instruction that is quite fast
23:43:31 <solrize_> whether the compiler generates that insn, i dunno
23:44:35 <jberryman> thanks, goodnight
23:45:24 <Cale> You could probably check...
23:46:24 <vixey> esoRkrD You are stupid
23:52:01 <Cale> vixey: what?
23:52:14 <vixey> didn't mean to send that
23:52:47 <solrize_> heh
