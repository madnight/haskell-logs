00:00:01 <Trinithis> > 1/0 - 1/0
00:00:03 <lambdabot>  NaN
00:00:26 <quicksilver> NaN isn't part of RealFloat because haskell doesn't require implementations to support NaN, I suppose?
00:00:28 <dmwit> > uncurry (encodeFloat :: Integer -> Integer -> Float) . decodeFloat $ (read "NaN" :: Float)
00:00:30 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
00:00:34 <sjanssen> > uncurry encodeFloat . decodeFloat $ (1/0)
00:00:35 <lambdabot>  Infinity
00:00:39 <dmwit> > uncurry (encodeFloat :: Int -> Int -> Float) . decodeFloat $ (read "NaN" :: Float)
00:00:40 <lambdabot>  Couldn't match expected type `Int' against inferred type `Integer'
00:00:42 <sjanssen> quicksilver: probably
00:00:49 <dmwit> *blink*
00:00:56 <dmwit> :t encodeFloat
00:00:59 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
00:01:27 <Trinithis> > 0^0
00:01:28 <lambdabot>  1
00:01:31 <Trinithis> uhoh!
00:01:34 <quicksilver> conceivably for serious FP work it might be useful to have an IEEERealFloat class
00:02:01 <sjanssen> > isIEEE (undefined :: Double)
00:02:04 <lambdabot>  True
00:02:05 * quicksilver nods
00:02:07 <Trinithis> > 0^^0
00:02:09 <lambdabot>  1.0
00:02:24 <Trinithis> > 1^^(1/0)
00:02:26 <lambdabot>  Add a type signature
00:02:34 <quicksilver> but a putative IEEERealFloat class could be a bit more explicit about some of this tuff
00:02:34 <Trinithis> > 1^^(1/0) :: Double
00:02:35 <lambdabot>  Add a type signature
00:02:39 <quicksilver> > 0**0
00:02:40 <lambdabot>  1.0
00:03:22 <Trinithis> > 1**(1/0) :: Double
00:03:23 <lambdabot>  1.0
00:03:26 <Trinithis> oh dear!
00:04:27 <dmwit> :t 1 ^^ (1/0)
00:04:29 <lambdabot>     Ambiguous type variable `t' in the constraints:
00:04:29 <lambdabot>       `Integral t' arising from a use of `^^' at <interactive>:1:0-9
00:04:29 <lambdabot>       `Fractional t' arising from a use of `/' at <interactive>:1:6-8
00:04:30 <jaj> I think implementation of NaN and Infinity are part of the IEEE standard on floating point calculation
00:04:40 <dmwit> :t (^^)
00:04:42 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
00:04:57 <dmwit> 1/0 -- not too likely to be an Integral, I guess
00:15:24 <mxc> wasn't someone asking about spitAT earlier?
00:15:39 <mxc> splitAt
00:15:39 <b_jonas> lol
00:15:39 <^Someone^> No, I wasn't
00:15:59 <mxc> dammit
00:17:17 <jaj> mxc: tieTYT implemented his own splitAt
00:18:48 <b_jonas> @type splitAt
00:19:03 <b_jonas> is this a kind of splitAt that causes netsplits?
00:20:20 <quicksilver> if I allocate a Ptr with newArray
00:20:28 <quicksilver> that memory lives forever until I manually free it, right?
00:20:31 <quicksilver> no GC
00:20:37 <MyCatVerbs> b_jonas: splitAt n = unsafePerformIO $ writeChan (servers !! n) SelfDestruct -- actually idempotent, since multiple calls won't make the server any more or less dead.
00:20:53 <tieTYT> mxc: yes, that was me
00:21:52 <dmwit> quicksilver: I believe there's some hack to get the garbage collector to free malloc'd memory when it collects a Ptr.
00:21:58 <b_jonas> MyCatVerbs: but it's stateful because it depends on what rights your connection to the irc server has
00:22:04 <b_jonas> like, whether you're server op
00:22:08 <b_jonas> so it's not pure
00:22:11 <quicksilver> dmwit: I really hope not.
00:22:21 <quicksilver> dmwit: otherwise how can you safely pass memory to C?
00:22:32 <MyCatVerbs> b_jonas: oh, that's easy. Just run the servers with a Windows 95-style security policy set up.
00:22:35 <dmwit> quicksilver: I mean: if you want that behavior, you can use this hack.
00:22:40 <MyCatVerbs> b_jonas: aka "everybody is God" mode. ^_^
00:23:06 <b_jonas> MyCatVerbs: that's not my choice with freenode
00:23:09 <quicksilver> dmwit: ah yes, you can use foreignptrs to attach finalisers.
00:24:07 <quicksilver> I don't want to do that though :)
00:26:13 <MyCatVerbs> b_jonas: hmmm... make that unsafePerformIO $ let wt = writeChan (servers !! n) in wt (Identify "username" "password") >> wt SelfDestruct -- ?
00:26:54 <b_jonas> MyCatVerbs: yeah, that's better
00:27:51 <quicksilver> WOOO. VBOs working!
00:27:58 <mxc> VBO?
00:29:35 <^Someone^> Verbond van Belgische Ondernemingen
00:30:57 <mxc> in that case, woohoo!  congrats quicksilver
00:30:58 <^Someone^> Or maybe Vertex Buffer Object
00:31:13 <mxc> Very Big Object?
00:31:21 <^Someone^> But I'm thinking it's most likely that Belgian voice of business
00:31:34 <luqui> Visual Basic Object
00:31:43 <mxc> really?
00:31:49 <luqui> no
00:31:53 <luqui> well maybe, I have no idea
00:31:55 <mxc> does that mean you can link haskell to excel?
00:31:57 <mxc> aw
00:32:05 <mxc> *cries on the inside*
00:32:28 <luqui> Haskcel would be pretty cool
00:32:41 <^Someone^> Hehe
00:32:42 <mxc> fck you!
00:32:43 <luqui> or is that Haxcel
00:32:46 <mxc> its exkell
00:32:59 <mxc> just kidding, of course
00:33:03 <ziman> haskellent! :)
00:33:05 <luqui> really?
00:33:13 <mxc> i like hexcel
00:33:22 <mxc> H# would be pretty cool
00:33:30 <luqui> what, lazy F#?
00:33:42 <mxc> well, haskell on .net
00:33:52 <mxc> i guess its a bit harder since there's no object model in haskell
00:33:55 <luqui> ah.  if only because Microsoft can actually make an IDE...
00:34:04 <^Someone^> http://www.haskell.org/~simonmar/papers/vshaskell.pdf
00:34:16 <mxc> IDE = vim
00:35:00 <luqui> there is _so_ much more that could be done for an IDE for a language like Haskell than vim can offer
00:35:09 <mxc> yi looks interesting
00:35:11 <luqui> (I do love vim, I'm just dreaming)
00:35:18 <mxc> i got this haskell mode for vim
00:35:20 <mahogny> someone should pick up the eclipse plugin
00:35:21 <mxc> its pretty cool
00:35:27 <mxc> type annotations, etc etc
00:35:39 <luqui> mxc, really?  where?
00:35:53 * ^Someone^ picks up the eclipse plugin
00:35:59 <mxc> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
00:38:10 <mxc> that vshaskell paper is interesting
00:38:29 <mxc> but for me, the IDE isn't nearly as important as being able to use .net libraries
00:39:51 <mahogny> java has more libraries. too bad haskell research headquarter is in the wrong building
00:40:19 <^Someone^> Why not Scala, if you want to use Java libraries?
00:41:05 <mxc> unfortuantely, where I work is extremely .net heavy
00:41:28 <mahogny> ^Someone^, scala isn't a very good language at all
00:41:38 <mahogny> better wait for java 7 in that case
00:41:47 <^Someone^> !!
00:41:51 <luqui> Scala is cool, Haskell is cool, Scala /= Haskell.  The problems they are good at are quite different.
00:42:29 <b_jonas> I don't like ides at all
00:42:44 <b_jonas> not even the ones built in editors like vim or emacs
00:42:48 * ^Someone^ wonders if dobblego is around
00:42:57 <[Justice]> would be nice if MS backed a Haskell IDE
00:43:06 <[Justice]> after all, MS is backing GHC
00:43:07 <luqui> My opinion of IDEs has changed quite a lot.  I still use vim for programming in my favorite languages (except C#, since, I mean, come on)
00:43:31 <luqui> but I believe that an innovative IDE could make an incredible language unlike one we've ever seen
00:43:34 <mxc> C# `elem` yourFavoriteLanguages?
00:43:36 <mahogny> well. MS backing GHC? I dunno about that
00:43:44 <profmakx> basically an ide is a big pile of programs that would work way better if used and developed seperately
00:43:47 <luqui> C# is my favorite javalike language.
00:43:54 <profmakx> (except for candy like type annotations perhaps)
00:43:56 <luqui> (because Scala isn't quite mature yet)
00:44:12 <mxc> xcode is pretty decent for osx dev
00:44:19 <[Justice]> http://research.microsoft.com/~simonpj/
00:44:40 <^Someone^> Why is Scala not mature yet, luqui?
00:44:41 <mahogny> I'd like to see the main stuff from scala picked up into the main java, so we get proper tool support and everyone can compile it with standard tools
00:44:54 <luqui> I've just run into walls every time I've tried to useit.
00:45:10 <luqui> but I haven't given it a proper chance in about 9 months.
00:45:57 <luqui> I believe we must transcend the idea that a program is a text file   (less than a year ago I felt strongly the opposite, mind)
00:46:32 <mapreduce> I started using Scala less than nine months ago and now I've nearly ported my 20kloc Java code to it.
00:46:51 <mahogny> I want a new binary format for code so I can insert images, annotation and stuff. helps documentation
00:46:56 <mapreduce> (not that I was doing that from the start)
00:47:00 <b_jonas> I strongly want a program being a text file
00:47:08 <b_jonas> really
00:47:27 <mapreduce> b_jonas: I probably agree.. but why?
00:47:27 <[Justice]> i side with program source as text files over program source as embedded in binary files
00:47:32 <luqui> b_jonas, I probably know where you're coming from...
00:47:33 <arw__> b_jonas: like, perl?
00:47:36 <Vq^> b_jonas: the program as in the executable?
00:47:38 <b_jonas> mapreduce: because of the toolkits
00:47:44 <b_jonas> so I can use the same editor for everything
00:47:49 <b_jonas> Vq^: no, the source
00:47:50 <Dzlk> I see the idea that a prorgram is a text file seperately from the idea that a program is text... The latter I strongly want to keep.
00:47:55 <luqui> eh, text, binary, blah blah, that's not what I'm talking about.
00:48:00 <ziman> @hoogle (a->b->c->d) -> (a, b, c) -> d
00:48:03 <mahogny> or just smack the source into whatever, just give me better annotation possibilities
00:48:03 <mapreduce> There are advantages to using different editors though, e.g., Smalltalk, Excel.
00:48:07 <luqui> more like I don't think editing a program should be very much like editing text.
00:48:08 <b_jonas> I mean, I don't want one of those worksheets like in mathematica (mind you, it can run text sources too)
00:48:16 <[Justice]> i want to be able to open a program source in Notepad(2|++)
00:48:55 <b_jonas> the executable is a different matter, that can be non-plain-text for efficency reasons obviously
00:49:20 <b_jonas> (note that "text" is used in some other sense for binaries though)
00:49:22 <Vq^> [Justice]: if you're talking about the windows application im against it
00:49:37 <mahogny> I think if we insist that code can be opened Joes home-brewn editor that almost has the functionality of cat, we're really not going make much progress
00:49:40 <tieTYT> could this be confusing the compiler: myElem a (x:xs) | a == x = True ?
00:50:02 <b_jonas> (I think there "text" means the parts of the binary that are mapped readonly for execution)
00:50:22 <^Someone^> mahogny hates prepositions?
00:50:36 <mahogny> yep. apparently
00:50:39 <mmorrow> omg, i just discovered BNFC
00:50:40 <mahogny> +with
00:50:41 <b_jonas> ^Someone^: lol
00:50:41 <mmorrow> http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/
00:50:43 <tieTYT> @type Eq
00:50:53 <[Justice]> yes i use Windows, yes i generally use Notepad2 for viewing code, yes i use Notepad++ for Haskell, sue me
00:50:54 <^Someone^> Declensions ftw
00:51:01 <luqui> mahogny, well, it's about the kind of progress we make.
00:51:09 <mmorrow> darcs get --partial http://code.haskell.org/bnfc/
00:51:28 <luqui> Perhaps the progress we should be making is in more powerful textual representations.
00:51:42 <[Justice]> it would still be nice if MS wrote a VS addon for GHC, i would use it
00:51:45 <luqui> for example, Haskell is a big step forward from FORTRAN, but they are both just text.
00:51:55 <mahogny> luqui, the bad thing is, when even the computer scientists get reluctant to changes, things will come to a stand-still for certain. because we move at least 10x faster than the rest of the users :P
00:51:57 <tieTYT> does haskell know I want to return True here? myElem a (x:xs) | a == x = True
00:52:04 * luqui only spouts popular opinions in the current setting as fact :-)
00:52:08 <[Justice]> yes, tieTYT
00:52:11 <Vq^> [Justice]: i have bad experiences of notepad edited code, it usually sprinkles CRs all over the place
00:52:23 <[Justice]> i don't use Notepad
00:52:30 <MyCatVerbs> mahogny: 10x? That's being conservative. :P
00:52:37 <mahogny> MyCatVerbs, prolly
00:52:38 <mahogny> :)
00:52:41 <b_jonas> and I don't want no non-ascii characters in source code either
00:52:41 <luqui> mahogny, so you are essentially arguing that we must continue to explore?
00:52:45 <mahogny> yes
00:52:50 <luqui> good argument :-)
00:52:56 <[Justice]> and i use Windows, so i'm fine with CR's all over the place
00:53:03 <mahogny> at least get utf-8 going
00:53:12 <mapreduce> luqui: Lisp with reader macros can do anything.  Whether you want to use it is another matter.
00:53:28 <[Justice]> and jonas, I hope to whatever diety you all pray to that your editor supports Unicode (and that you use it!)
00:53:29 <luqui> infinite tape and state transitions can do anything...
00:53:31 <tieTYT> [Justice]: ok thanks
00:53:33 <mapreduce> (wrt advanced text formats)
00:53:42 <quicksilver> Vertex Buffer Object, in fact :)
00:53:52 <quicksilver> although some of the other ideas were more fun.
00:54:03 <luqui> my current fantastical ideal is a dependently typed language with a "objects on a table"-like interface
00:54:03 <Dzlk> luqui: I think I'm not sure what about the text file you'd like to transcend. Do you mean transcend text, as in, say, storing ASTs rather that text representations, or transcend the file, as in using a different "basic organizational unit"?
00:54:07 <b_jonas> [Justice]: my editor does support unicode (to some level), but no, I still use a 8859-2 terminal for everything including the editor
00:54:24 <Dzlk> Or is it more a matter of UI?
00:54:32 <luqui> Dzlk, yes very much UI
00:54:41 <luqui> I don't care if it gets stored in text files underneath...
00:54:41 <MyCatVerbs> mahogny: (100 - \epsilon)% of users won't even switch to something sane and easy to reason about like ML. There are people in academia using things like dependent types et all, for example. :p
00:54:52 <tieTYT> why won't this compile? http://pastebin.org/39095
00:54:53 <Dzlk> Ah, ok.
00:55:01 <tieTYT> will ghci errors ever make sense to me?
00:55:05 <[Justice]> luqui, consider how people think and understand concepts, processes, facts, etc:
00:55:07 <tieTYT> or do I have to remember that x means y?
00:55:12 <[Justice]> in terms of textual language
00:55:20 <luqui> [Justice], _some_ people
00:55:28 <[Justice]> textual language is a very highly advanced form of cognition
00:55:31 <mahogny> MyCatVerbs, I'm happy if people would at least use standards -_-
00:55:36 <luqui> I am definitely one who represents many things textually.
00:55:44 <Dzlk> K does some interesting things with tables for GUI programming.
00:55:50 <luqui> There are many folks who do not, and many problems which I can grasp better if I move away from text.
00:56:15 <MyCatVerbs> mahogny: I mean, we have people in here whose first step, about half the time, is to construct a combinator library expressing some set of mathematical constraints that their problem domain manifests. ;)
00:56:27 <[Justice]> yes, it is possible to summarize a program with pictorial representation
00:56:41 <luqui> tieTYT, the type signature is incorrect
00:56:51 <mahogny> MyCatVerbs, *feels hit* :)
00:56:52 <b_jonas> tieTYT: the problem is that you want to compare values of type a
00:56:58 <b_jonas> but if a is any type, you can't do that
00:57:02 <luqui> tieTYT, you are comparing things for equality, but you haven't specified that you need to be able to compare them.  You need to add (Eq a) => to the signature
00:57:09 <b_jonas> like luqui says
00:57:13 <tieTYT> oh
00:57:16 <MyCatVerbs> mahogny: what? That wasn't a criticism, I'm jealous of those people because I wish my mathematics was that tight. :P
00:57:21 <[Justice]> but it is not possible to do what it takes a million lines of C (or the equivalent thousand lines of Haskell) in pictures
00:57:26 <tieTYT> haven't learned that yet so i suppose i'll just remove my type def
00:57:37 <tieTYT> thanks
00:57:59 <b_jonas> I think it _is_ a good practice to add type defs to every global
00:58:07 <tieTYT> i generally do
00:58:15 <mahogny> MyCatVerbs, my critic towards some of these approaches is that at some point you are writing more code than a straight-forward approach would give, complicating it in the progress
00:58:16 <tieTYT> but i'm a newb, i don't want to learn that until i get to it in my book
00:58:17 <b_jonas> because then you can be sure that a type error is in the function the compiler is complaining about,
00:58:20 * ^Someone^ is learning about combinators at the moment
00:58:36 <b_jonas> not in some other global that the compiler thinks has a different type that you think it has
00:58:41 <luqui> [Justice], it's only when I got into dependent types and computer-assisted proofs that I started to feel the text burn
00:58:43 <b_jonas> which is used in that definition
00:59:04 <b_jonas> if you include type sigs to everywhere, you can be sure the error is local
00:59:06 <luqui> [Justice], I think proofs would be a lot easier with a tangible interface.  And I think dependent types are ultimately where things (at least in our neck of the woods) are going
00:59:11 <MyCatVerbs> mahogny: perhaps. At least you're having fun along the way, and it makes to an interesting blog post. ;P
00:59:32 <b_jonas> you could even write a fucntion without type sig first, ask about the type from the compiler, and use that if you think it's correct
00:59:44 <b_jonas> or a tighter type
00:59:56 <mahogny> MyCatVerbs, hm. my current pet is meta programming and functional programming in vanilla java >_<
01:00:01 * luqui _does_ consider it important to eventually become fluent in types to be a decent Haskell programmer
01:00:10 <MyCatVerbs> mahogny: oh, crikey.
01:00:17 <luqui> mahogny, ow
01:00:40 <mahogny> (yes, there is a Tuple-class, and it is used plenty)
01:00:54 <b_jonas> tuple class?
01:01:01 <tieTYT> luqui: for my level, i'm pretty fluent
01:01:08 <tieTYT> i always define a type
01:01:12 <tieTYT> that's why i ran into the problem
01:01:14 <[Justice]> reading and writing programs is my concern, not doing proofs
01:01:30 <mahogny> b_jonas, for smacking arbitrary values together at need. java really need built-in tuples
01:01:43 <b_jonas> mahogny: oh, java
01:01:46 <dmwit> [Justice]: Reading a program *is* doing a proof.
01:01:50 <luqui> tieTYT, by the way, hpaste.org is the preferred paste server.  It does haskell syntax highlighting and announces in this channel.  Just fyi..
01:01:57 <[Justice]> replacing a million lines of C with ten million pages of UML is a step in the wrong direction
01:01:57 <b_jonas> I don't know java, can't you just define one?
01:02:10 <tieTYT> ah it's .org
01:02:15 <b_jonas> c++ has one defined in a trivial way in one of the standard libraries
01:02:25 <mahogny> b_jonas, yeah, you can. the bad part is that once it is annotated with generics, the type looks like a monster
01:02:34 <dmwit> b_jonas: It needs it built in so that the syntax can suck less.
01:02:42 <dmwit> b_jonas: Same as C++. =)
01:02:56 <[Justice]> reading a program is not doing a proof, necessarily - it completely depends on what you want to accomplish
01:03:04 <b_jonas> dmwit: tuple syntax is quite sane in c++, it's lambdas that are insane
01:03:07 <dmwit> std::pair<int, int> f(std::pair<int, string>) // shudder
01:03:08 * luqui just wants lambdas.  In every language.  Lambdas make the world go round
01:03:13 <mahogny> public static <A,B,C> SortedMap<A, C> fmapValues(SortedMap<A, B> map, final EvParallel.FuncAB<B,C> func) <---- type :(
01:03:17 <^Someone^> luqui, also: #functionaljava
01:03:18 <[Justice]> some read a program to prove that it is correct with respect to its intention, others read one to understand the writer's intention
01:03:31 <tieTYT> luqui: java will get closures soon.  They look like shit though
01:03:33 <b_jonas> luqui: yep
01:03:38 <dmwit> f :: (Int, String) -> (Int, Int) -- way less noise, especially since you can omit this line entirely
01:03:55 <b_jonas> I was recently shocked that php not only doesn't have lambdas (like python) but it doesn't even have first-class functions
01:04:14 <[Justice]> php is a procedural language, why were you shocked?
01:04:23 <mahogny> nothing is shocking about php, which even had register_globals until php4
01:04:42 <b_jonas> Justice: well, the procedural languages I use at least have first-class functions
01:04:43 <mapreduce> But it has objects, so you can probably Java it into having first class functions.
01:05:05 <[Justice]> the procedural languages you use, then, bear some minor influences from functional languages
01:05:11 <mmorrow> holy crap. go through the bnfc tutorial. in 5 minutes you'll have (from a 10-line lbnf calculator grammar) latex documentation, abstract syntax .hs module, alex lexer module, happy parser module, pretty printer .hs module, an error monad module, ...
01:05:13 <tieTYT> mapreduce: how well do you know haskell?
01:05:32 <b_jonas> Justice: sure
01:05:39 <mmorrow> "BNFC is a compiler compiler compiler"
01:05:39 <mahogny> public static interface FuncAB<A,B>{public B func(A in);}  <--- my java "first order function"
01:05:49 <mapreduce> tieTYT: I use it as a posh calculator.
01:05:50 <mmorrow> "BNFC saves 90% of source code writing in a typical compiler front end."
01:06:11 <b_jonas> Justice: so? php could have stolen those good things from functional languages, just like every other one
01:06:36 <mmorrow> and by compiler, that means *anything* that you parse and rep as a datastructure
01:06:40 * ski_ notes that `compiler compiler' is a misnomer
01:07:07 <[Justice]> php could have, until you understand the theory behind it
01:07:08 <mmorrow> whatever nomer it is, this thing generates those
01:07:18 <Dzlk> PHP has a theory behind it?
01:07:25 <b_jonas> Justice: it has theory?
01:07:25 <[Justice]> no, it has no theory behind it
01:07:30 <b_jonas> oh, good
01:07:36 <b_jonas> I'm glad I didn't miss that
01:07:48 <b_jonas> so it's like windows which has no design
01:07:53 <mmorrow> and you can choose from output in Haskell, C, C++, OCaml, F#, C#, Java
01:07:57 <dmwit> Which OS has design?
01:08:06 <Dzlk> Plan 9.
01:08:07 <b_jonas> dmwit: unix had one, originally
01:08:16 <b_jonas> and I've heared VMS has a good design
01:08:17 <MyCatVerbs> mapreduce: "so you can probably Java it to have first class functions" <-- those are "second class" functions. Or maybe even "cattle class". :P
01:08:21 <dmwit> Plan 9 I might admit.
01:08:21 <[Justice]> *shrug*, SPJ is at MS Research ... bash Windows all you like
01:08:44 <dmwit> SPJ is at Microsoft.  This does not mean SPJ works on Windows.
01:08:48 <mmorrow> good thing ghc is gpl
01:08:54 <MyCatVerbs> mmorrow: actually BSD.
01:08:56 <dmwit> mmorrow: BSD?
01:09:02 <mmorrow> ohhhhnoooos
01:09:10 <mmorrow> heh
01:09:15 <dmwit> Even more liberal than GPL. =)
01:09:44 <MyCatVerbs> dmwit, b_jonas: Microsoft hired out many of the VMS hackers, anyway. NT's kernel is supposed to be pretty well designed.
01:09:58 <pejo> I don't think you should conflate MSR with MS.
01:10:00 <MyCatVerbs> dmwit, b_jonas: not saying anything at all about the layers of the OS _above_ that, though.
01:10:07 <mxc> MSR /= MS
01:10:08 <opqdonut> yeah i've heard the NT kernel is pretty nice too
01:10:15 <b_jonas> MyCatVerbs: yeah
01:10:26 <dmwit> Any function for reading floating-point numbers in other bases?
01:10:32 <mxc> compare MSR MS = GT
01:10:33 <[Justice]> the NT kernel is available for your inspection, free of charge, provided you are at a university
01:11:13 <[Justice]> sure, the fact that Java is getting closures comes from MSR
01:12:01 <[Justice]> strong competition from C# 2
01:12:15 <mxc> what are closures?
01:12:46 <dmwit> mxc: When you bind a function's parameter to some value and pass the result around, that's a closure.
01:12:51 <dmwit> ?all-dicts closure
01:13:02 <mapreduce> mxc: In the likely implementation in Java, it's a free standing block of code that can use variables from the enclosing scope.
01:13:03 <quicksilver> not just parameters, also "captured" local variables.
01:13:39 <quicksilver> so a closure is a chunk of code containing free variables (which may be formal parameters or not) together with actual values for those variables.
01:13:49 <mapreduce> One definition of closure that has been mentioned here before by Cale is as an implementation technique for the variable capture that quicksilver mentioned.
01:14:16 <b_jonas> I still keep thinking a local variable is always just a parameter of an outer function,
01:14:22 <b_jonas> but in haskell that may not be true
01:14:24 <Cale> Yeah, "closure" is not quite a synonym for "first class function that binds the variables in lexical scope"
01:14:24 <mapreduce> That's what The Scheme Report (correct name?) defined it as, and I think that was the first published use of the word.
01:14:26 <mxc> dmwit - what do you mean 'pass the result around'?
01:14:28 <dmwit> ?foldoc closure
01:14:41 <dmwit> Bah, the first foldoc definition is applicable here.
01:14:46 <b_jonas> I'm not really sure I understand the theory
01:14:46 <dmwit> http://dictionary.die.net/closure
01:15:11 <Cale> A closure is just a pair consisting of a chunk of code with some free variables, and a map from those free variables to values.
01:15:36 <b_jonas> mapreduce: wait, which revision of the scheme report?
01:15:42 <Dzlk> So you can pass them around without changing or losing the referents.
01:15:58 <mapreduce> b_jonas: No idea.
01:16:16 <b_jonas> I'll check if r5rs has the term "closure"
01:16:19 <Cale> It really annoys me when people say that they're going to add closures to language X, because that's almost never what they actually mean.
01:16:38 <Cale> What they mean is that they're adding first-class functions to language X, and using closures to implement them.
01:16:49 <luqui> let a = 42 in \b -> a + b   -- <-- implemented with closure  (most straightforwardly)
01:16:54 <b_jonas> I don't have r4rs at hand
01:17:11 <[Justice]> i wouldn't define a closure as an implementation technique
01:17:17 <b_jonas> no, it seems r5rs doesn't have it
01:17:21 <b_jonas> except in a reference
01:17:30 <luqui> in the perl/python world "closure" = "first class function"
01:17:32 <Cale> A closure is a particular data structure.
01:17:32 <[Justice]> and adding first-class functions does not mean adding first-class functions capable of referencing values or variables in an outer scope
01:17:58 <b_jonas> r5rs uses the term "procedure" for functions
01:18:02 <Dzlk> Cale: Worse, I've noticed people using "first-class functions" and "higher order functions" synonymously.
01:18:04 <Cale> (and it's usually something which only the implementer of a compiler/interpreter will have to worry about, not the user of the language)
01:18:36 <luqui> Dzlk, are they not?  I cannot conceive a language with one but not the other.
01:18:42 <[Justice]> the actual word is "closed anonymous inner higher-order function" ... and it is typically abbreviated "closure"
01:18:52 <b_jonas> luqui: C
01:19:05 <luqui> b_jonas, I suspect you mean it has first-class functions
01:19:11 <b_jonas> yep
01:19:12 <mapreduce> Cale: Spread the anti-FUD.
01:19:27 <Dzlk> You can do HOFs without first-class functions.
01:19:28 <b_jonas> but not closures, at least not in standard C
01:19:38 <Cale> [Justice]: I think that mixes levels of abstraction in a strange way.
01:19:41 <Deewiant> b_jonas: I wouldn't say that functions in C are first-class.
01:19:52 <Cale> A closure is a pair. A function is not.
01:20:03 <tieTYT> sup Caelum
01:20:05 <tieTYT> err Cale
01:20:11 <Dzlk> AIUI, in "map f xs", map is a higher-order function, f is a first-class function.
01:20:17 <[Justice]> closures as a data structure may be implemented as a pair
01:20:42 <Cale> [Justice]: As far as I'm concerned, the word "closure" refers only to such a pair.
01:20:43 <b_jonas> ok, then what about unlambda? it clearly has first-class functions, but they're not really closures
01:20:43 <luqui> Dzlk, so how do you have map without having first-class functions?
01:20:48 <[Justice]> closure as a concept, that the other-wise-free variables in a function are closed, is not a data structure
01:21:05 <Cale> [Justice]: and it's only an abuse of terminology that allows it to be used in any other way
01:21:06 <luqui> b_jonas, is not unlambda just a rewrite engine?
01:21:10 <b_jonas> or what about J? it also has first-class higher-order functions, but not lambdas or closures
01:21:16 <mmorrow> mxc: from the point of view of programming in haskell rather than implementing haskell, there's not a difference between a closure and a function, in the sense that if you are some function that gets another function as an arg, you have no way of knowing if the that func just passed to you is a closure (i really mean partially applied here) or not (nor do you care)
01:21:33 <Cale> mmorrow: Yes you do.
01:21:36 <Dzlk> luqui: Messy approximations thereof?
01:21:37 <mmorrow> or thats mho
01:21:41 <mmorrow> why?
01:21:47 <b_jonas> luqui: I don't think of it as such. think of just ski-calculus with strict evaluation order, not unlambda's extensions
01:21:47 <[Justice]> closures and partial application are completely unrelated
01:21:49 <luqui> Dzlk, is it still higher-order?
01:21:55 <Dzlk> Function pointers or whatnot.
01:21:59 <Cale> mmorrow: If you're passed a closure, you have a chunk of code, and you have a map from the free variables in that code to values, and you can project out the components.
01:22:01 <luqui> b_jonas, that's what I'm thinking of
01:22:06 <Cale> mmorrow: You can't do that with a function.
01:22:15 <luqui> b_jonas, but now I guess it's getting philosophical.
01:22:19 <b_jonas> luqui: you can implement it as a rewrite engine surely
01:22:24 <b_jonas> but I don't think of it as such
01:22:44 <Dzlk> I'd still call them HOFs, but that's my idiolect and may not be standard usage.
01:22:51 <b_jonas> I rather imagine it as rewriting algebraic objects, not strings
01:22:58 <b_jonas> does that still count as a rewrite engine?
01:23:00 <luqui> right.  I think of SK-calculus as rewrite engine which is closely related to lambda calculus, which is platonically about real things called "functions".  But that's just my brain doing what's best for it :-)
01:23:02 <Cale> There is no need to implement functions which capture the bindings in lexical scope with closures.
01:23:10 <mmorrow> Cale: oh, then i'm not thinking of a closure
01:23:11 <Cale> You can just as easily implement them with graph rewriting.
01:23:14 <b_jonas> by algebraic objects, I mean objects of an algebraic datatype
01:23:15 * luqui abandons the oncoming philosophical nightmare
01:23:26 <mmorrow> at what level does a closure exist?
01:23:29 <b_jonas> Cale: exactly
01:23:40 <Cale> mmorrow: As a datastructure inside a compiler or interpreter.
01:23:42 <b_jonas> that's why I'm giving J and unlambda as examples
01:23:46 <b_jonas> they clearly don't use closures,
01:23:53 <b_jonas> but have higher-order and first-class functions
01:24:02 <Cale> It's not something which should usually be visible to the user of a language.
01:24:12 <b_jonas> Cale: yep
01:24:13 <Cale> (unless they're working on said compiler)
01:24:32 <luqui> or unless they are perl and have defined closure differently :-)
01:24:36 <b_jonas> though you can sometimes construct (not deconstruct) closures in C interfaces of languages
01:24:46 <b_jonas> namely in the c interface of mzscheme and of lua
01:25:19 <mmorrow> Cale: exactly, i'm saying that if you're not implementing a language, closure are not something of importance
01:25:31 <vixey> yes they are
01:25:32 <Cale> mmorrow: I agree.
01:25:34 <vixey> depending on the language
01:25:39 <quicksilver> except that some people like concrete implementation notse
01:25:44 <quicksilver> it helps them visualise
01:25:52 <b_jonas> however,
01:25:52 <quicksilver> so it may help explain the language to those people
01:26:01 <quicksilver> (even if a specific implementation turns out not to use them)
01:26:03 <mmorrow> i'm not saying that you shouldn;t understand how things bind, scoping, etc
01:26:09 <mmorrow> just the specific concept
01:26:11 <quicksilver> "How does this function end up with a different value of x each time?"
01:26:12 <Dzlk> What's the relationship between closure and lexical scope?
01:26:15 <b_jonas> you sometimes need to know how closures work internally, at least what values are referenced from it, when you consider memory usage and memory leaks of programs
01:26:28 <quicksilver> "Ah well, the value of x is bound up with each copy, in something called a closure."
01:26:33 <vixey> It's important to have names for things
01:26:34 <b_jonas> a good example for that is perl where cyclic references with closures can bite you,
01:26:51 <mmorrow> quicksilver: ah, i'm assuming a purely functional language, of course
01:26:56 <quicksilver> s/where cyclic references with closures//;
01:27:23 <mmorrow> the internals of which aren't visible
01:27:23 <b_jonas> but I could conceive that language implementation could have functions store references to whole upper stack frames, not just the variables that are actually needed
01:27:25 <solrize_> i've been wondering how often it is that there's a good reason for more than N closures to be awaiting reduction, for some fairly small N
01:27:39 <b_jonas> and in that case you need to know about that or you might use too much memory
01:27:43 <mmorrow> once they are or it's not, it's a different story
01:28:07 <b_jonas> Dzlk: there's a strong relationship
01:28:30 <b_jonas> the lambdas have to remember the values of variables in the outer scope
01:28:32 <[Justice]> reference to an upper stack frame is not closure
01:28:41 <Cale> You can also have a language implementation that implements first class functions by simply using the function body as a template and rewriting the free variables with the values of the variables in scope.
01:28:42 <b_jonas> because those variables are lexically scoped
01:28:44 <[Justice]> hmm ... it is closure, it is not higher-order closure
01:28:58 <Cale> and that's not a closure then.
01:29:02 <b_jonas> whereas were they dynamically scoped (like in emacs lisp), you don't have to store them
01:29:07 <b_jonas> just use the latest value of them
01:29:12 <Cale> It's just using graph rewriting to accomplish the same thing.
01:29:17 <[Justice]> closure means lexical scope is captured, so it is closure
01:29:25 <Dzlk> b_jonas: Intuitively it seems like you can't have closures without lexical scope.
01:29:26 <Cale> [Justice]: Not quite :)
01:29:44 <b_jonas> [Justice]: it's probably not, but you need to know that the implementation of functions is not closures in that case
01:29:57 <b_jonas> Cale: yep
01:30:04 <b_jonas> that's sort of what unlambda does
01:30:13 <b_jonas> and I think tcl and shells might do that too
01:30:14 <Cale> [Justice]: See, you have this impression that I'm complaining about. If you hand me a closure, I should always be able to take it apart and examine the map from free variables to values, and the code separately.
01:30:15 <b_jonas> but I'm not sure
01:30:34 <b_jonas> Dzlk: indeed, you can't
01:30:53 <Itkovian> hi shapr
01:31:07 <[Justice]> a closure data-structure, sure
01:31:21 <b_jonas> also, you could say that a c++ function object isn't a closure either
01:31:26 <b_jonas> so that's another example
01:31:27 <[Justice]> but the concept of closing over a parent lexical scope doesn't necessarily imply that
01:31:31 <Cale> [Justice]: If you hand me a first class function which has captured some lexically bound variables, I won't be able to tell you what those variables are or look at the code. It's just a function.
01:31:40 <b_jonas> for having first-class functions without closures
01:32:24 <Cale> [Justice]: The word "closure" refers to the pair consisting of the code with free variables and an environment map, and not to the thing which it is being used to implement. (Though people abuse it that way.)
01:32:36 <b_jonas> so there are at least three ways of having first-class functions without capturing lexical scope (not caring about the implementation, only the semantics)
01:32:40 <mapreduce> Cale: You can do that in more reflective languages.
01:32:55 <[Justice]> "closure" means both, depending on context
01:32:55 <Cale> mapreduce: Right, and in those languages, perhaps calling it a closure isn't so bad.
01:33:00 <b_jonas> for this reason, I think you could call the concept closures, not the implementation
01:33:09 <Cale> mapreduce: Because you really can think of it as a pair, and not just as a function.
01:33:46 <Cale> b_jonas: I think overloading the word "closure" is not a great idea.
01:34:01 <b_jonas> Cale: ok, but how should we call the concept then?
01:34:04 <[Justice]> every other word in the English language is overloaded
01:34:24 <dmwit> rand()/srand() from C make me sad... I miss Haskell's Random module.
01:34:26 <[Justice]> i don't see why "closure" should be put on a purity-of-unity pedestal
01:34:37 <Cale> b_jonas: I tend to use the word "functions", but if it's not clear, I'll say "first-class functions which capture the variables in lexical scope"
01:34:57 <b_jonas> Cale: ok, that's a bit long though
01:35:04 <Cale> b_jonas: It's clear though.
01:35:05 <jaj> dmwit: use the haskell module in C via FFI ;)
01:35:05 <b_jonas> we could call them lisp functions
01:35:18 <mapreduce> Lexical functions?
01:35:27 <b_jonas> mapreduce: no, that's different
01:35:28 <Cale> Closures also needn't be used to implement such functions.
01:35:29 <dmwit> jaj: Ugh, even worse. =P
01:35:34 <Cale> They can also be used to implement objects.
01:35:39 <b_jonas> that could mean a function assigned to a lexical name
01:35:49 <Cale> Or a number of other semantically different features.
01:36:07 <Cale> It's important to keep the implementation of a language separate from the semantics.
01:36:16 <mapreduce> Why?
01:36:25 <b_jonas> Cale: sure
01:36:31 <b_jonas> but we still need a name, don't we?
01:36:34 <mmorrow> ok, refining... assuming a purely functional lang with static scoping, a function arrived at by closing over some env/scope is indistinguishable from a function that didn't if their outputs coincide with equiv inputs
01:36:54 <mmorrow> so i guess you get that by definition of a purely func lang
01:36:59 <Cale> yeah.
01:36:59 <b_jonas> actually, I think even haskell can have higher-order functions without lexical captures
01:37:02 <b_jonas> namely with currying
01:37:16 <b_jonas> though I'm not sure
01:37:24 <jaj> I always have difficulty in finding adequate names for my functions and variables...
01:37:32 <b_jonas> if you imagine the function defined as nested lambdas on one variable each
01:37:42 <b_jonas> then maybe those have lexical captures as well
01:37:45 <b_jonas> dunno
01:37:53 <b_jonas> jaj: me too
01:38:19 <b_jonas> writing the thesis was the worst in this respect
01:38:36 <Itkovian> I'm looking for something resembling Python's ConfigParser. Google indicates some effort might have been made by jgoerzen, but not much else. Any pointers?
01:38:43 <b_jonas> I've used up all lowercase letters for variables I think
01:39:13 <Cale> Wow, grauenwolf just called me clueless for pointing out that deadlocks can't occur in STM.
01:39:23 <b_jonas> I had to do search and replace to change the name for one overloaded meaning of a variable a few times
01:39:27 <eek> jaj, it may get easier if you use excessively long names for a while; you'll later learn to shorten them
01:39:33 <eek> jaj, or at least I found it so
01:39:36 <vixey> why go on reddit ?
01:40:23 <quicksilver> Itkovian: why would there be anything else :)
01:40:37 <quicksilver> Itkovian: jgoerzen's is an almost exact clone of ConfigParser, AIUI.
01:40:43 <quicksilver> I'm not sure what else you would want...
01:40:46 <Itkovian> quicksilver: yeah, but no pointers to any implementation either.
01:40:50 * Itkovian looks harder
01:40:54 <dmwit> Cale: People are wrong, sometimes. =)
01:41:01 <dmwit> Cale: Sorry you got called clueless, though.
01:46:27 <sjanssen> is it really true that you can't have deadlocks with STM?
01:47:03 <dmwit> Sure.
01:47:07 <sjanssen> perhaps it is more accurate to say that you can't have deadlock in a single transaction, it requires multiple transactions
01:47:13 <Cale_> sjanssen: How are you supposed to have deadlocks when you never take locks on anything?
01:47:13 <dmwit> If somebody's rolling back, that means somebody else made progress, right?
01:47:57 <Cale> dmwit: this is true
01:48:00 <sjanssen> Cale_: see Control.Concurrent.STM.TMVar
01:49:15 <Cale> sjanssen: You can have a bunch of transactions which always retry because their conditions are never met, I suppose. I wouldn't call that a deadlock.
01:49:30 <sjanssen> why isn't it a deadlock?
01:50:08 <mapreduce> Because deadlocked processes don't do anything.
01:50:22 <mapreduce> At least those transactions keep the CPU warm.
01:50:35 <matthew_-> if you implement a mutex with a spin lock and then deadlock on it...?
01:50:58 <sjanssen> not necessarily, GHC is smart enough to pause the failing transactions until they can potentially make progress
01:51:04 <matthew_-> surely a deadlock is just no observable progress?
01:51:17 <quicksilver> Itkovian: implementation? I don't understand?
01:51:21 <Itkovian> Ok, found it, apparently it's called ConfigFile ;-)
01:51:24 <quicksilver> ah ;)
01:51:31 <Cale> A deadlock occurs by processes in multiple threads competing for resources, each aquiring some of them, but none of them aquiring enough to proceed.
01:51:38 <sjanssen> "In computer science, deadlock refers to a specific condition when two or more processes are each waiting for another to release a resource, or more than two processes are waiting for resources in a circular chain"
01:51:49 <Cale> right
01:51:53 <sjanssen> from Wikipedia, which seems to be a correct definition
01:52:24 <RayNbow> http://www.cs.fsu.edu/~baker/cop5611.S03/graphics/F6-1.jpg <-- obligatory deadlock pic
01:52:38 <opqdonut> everybody being stuck in a retry is usually called i "livelock"
01:52:39 <RayNbow> although the picture I've seen before had more cars :p
01:52:46 <Cale> If I takeTMVar from a couple of TMVars, and then the second of them is empty, the transaction retries, so the first is still filled.
01:52:59 <RayNbow> http://www.cs.rpi.edu/academics/courses/fall04/os/c10/gridlock.gif <-- better picture :p
01:53:14 <sjanssen> consider two TMVars m and n, one process executing "do atomically (takeTMVar m); atomically (takeMVar n); atomically (putTMVar m); atomically (putTMVar n)
01:53:26 <sjanssen> and another process executing the same, but with m and n swapped
01:53:52 <Cale> Well, okay, you can create deadlocks by effectively not using STM.
01:54:03 <sjanssen> but we're using STM
01:54:09 <Cale> Only trivially.
01:54:21 <opqdonut> well of course both the takevars should be inside a single atomically
01:54:47 <opqdonut> no, wait
01:54:53 <sjanssen> I've shown that "you can't have deadlock with STM" is a false statement
01:54:56 <opqdonut> will that even lock?
01:55:28 <sjanssen> opqdonut: yes, if you get lucky with the scheduler
01:55:36 <ziman> -
01:55:41 <ziman> oops, wrong window
01:55:44 <sjanssen> Cale: perhaps you should refine that to "you can't have deadlock in a single transaction"
01:56:18 <Cale> Also, using TMVars is a little bit cheap, because you're effectively simulating locking.
01:56:32 <opqdonut> ah, misremembered how TMVars work
01:56:34 <Cale> (or MVars really)
01:56:46 <sjanssen> Cale: this is somehow against the rules?
01:56:55 <Deewiant> I've managed to lock with only TVars
01:58:33 <sjanssen> TMVars are just a small wrapper around TVars
01:58:40 <Cale> That's true.
02:00:09 <Cale> But my complaint is basically that the wrapper effectively invents a sort of lock so that you can create something that looks like deadlock. If you unwrap that wrapping, it doesn't quite look like deadlock anymore, but a kind of livelock.
02:01:38 <Cale> or hmm...
02:01:38 <sjanssen> "A livelock is similar to a deadlock, except that the states of the processes involved in the livelock constantly change with regard to one another, none progressing."
02:01:44 <sjanssen> Wikipedia again
02:02:08 <sjanssen> and that is certainly not true in this case -- the locks that have been acquired reman acquired by the same process
02:02:29 <Cale> hmm...
02:02:42 <sjanssen> this is actually very close to a reasonable program -- the only problem is that the takeTMVars should be inside a single transaction
02:02:53 <Cale> right
02:03:42 <Cale> Of course, you also have things like  atomically retry
02:03:59 <sjanssen> that isn't deadlock, IMO
02:04:08 <Cale> Well, it only involves one thread.
02:04:20 <sjanssen> exactly
02:05:10 <sjanssen> personally, I see no difference between that and "let go = go in go" or any other non-terminating program
02:08:14 <Cale> So okay, I'll concede that you can have IO actions occurring in separate threads that incidentally use STM and create a deadlock situation, but I'm not sure that I agree that STM is actually responsible for the deadlock, but the specific chain of transactions you're requesting.
02:10:02 <Cale> I guess, no single pair of STM transactions running in separate threads can cause a deadlock.
02:14:36 <ziman> I have a (main) .hs file and I loaded it into ghci using :l file.hs but when I want to use a function from it, I get a `not in scope' error. Do I have to add a 'module Main (f1, f2, ...) where' declaration at the beginning of the file? Why does it sometimes work and sometimes not?
02:14:56 <quicksilver> depends if its' compiled or interpreted.
02:15:04 <quicksilver> touch the file to mark it modified
02:15:09 <quicksilver> and that will force it to interpret
02:15:20 <Soliah> ?t foldr
02:15:30 <ziman> wow, it works, thanks!
02:15:42 <dobblego> ?type foldr
02:15:53 <ziman> i see, so if it's compiled, only the exported symbols will be visible
02:15:54 <quicksilver> ziman: I describe this as a bug, myself, but the GHC devs disagree.
02:16:16 <Soliah> that didn't work :<
02:16:20 <Soliah> is lambdabot here
02:16:26 <dobblego> Soliah, no, try /msg lambdac
02:16:45 <[Justice]> if you're "in" the module, you can use anything available in the module ... if you're interpreting, you're in the module, but if you're compiling, you're looking at it from the outside
02:16:52 <b_jonas> we need a protocol how lambdabot clones can choose which one answers
02:17:05 <b_jonas> so if one falls out the others can reply
02:17:15 <dobblego> sounds like distributed computing to me
02:17:26 <b_jonas> dobblego: sorta, but not really
02:18:42 <dmwit> ?botsnack
02:19:38 <dobblego> ?type foldr
02:19:40 <lambdac> forall a b. (a -> b -> b) -> b -> [a] -> b
02:23:50 <vincenz> What does it mean if I get fd:9: hClose: resource vanished (Broken pipe)
02:23:59 <vincenz> when trying to eval something with lambdabot?
02:24:14 <Cale> vincenz: are you getting it consistently?
02:24:26 <vincenz> Cale: yep
02:24:37 <Cale> what are you trying to evaluate?
02:24:41 <Cale> > 1 + 1
02:24:43 <lambdac>  2
02:24:43 <vincenz> > 1
02:24:45 <lambdac>  1
02:24:45 <vincenz> THAT
02:24:51 <vincenz> sorry for all-caps, that even
02:24:52 <Cale> oh hey
02:25:04 <ziman> @unlambda `r```````````.H.e.l.l.o. .w.o.r.l.di
02:25:05 <lambdac>  fd:10: hClose: resource vanished (Broken pipe)
02:25:07 <ziman> ^^
02:25:07 <vincenz> This is my instance of lambdabot on another irc server
02:25:20 <vincenz> > 1
02:25:21 <lambdac>  1
02:25:23 <dobblego> vincenz, I used to get that and newsham gave me the answer
02:25:29 <vincenz> dobblego: what was it?
02:25:30 <Cale> > 1
02:25:32 <lambdac>  1
02:25:39 <lambdabot>  1
02:25:44 <^Someone^> Hello, dobblego!
02:25:47 <dobblego> vincenz, I can't remember exactly; I changed a source file and recompiled
02:25:50 <dobblego> hello ^Someone^
02:25:55 <^Someone^> I'm Gork
02:25:57 <Cale> lambdac: @part #haskell
02:25:58 <lambdac> Not enough privileges
02:26:01 <^Someone^> If you remember
02:26:04 <dobblego> vincenz, it was in #haskell-op about a week ago
02:26:11 <dobblego> ^Someone^, vaguely, where from?
02:26:15 <vincenz> dobblego: there are logs?
02:26:22 <^Someone^> DALnet
02:26:32 <Cale> Who is running lambdac ?
02:26:35 <^Someone^> You got me interested in Scala and Haskell
02:26:36 <dobblego> vincenz, probably; I'll have it on my laptop, but it's packed away
02:26:38 <dobblego> Cale, me
02:26:42 <dobblego> @part #haskell
02:26:49 <lambdabot> Not enough privileges
02:26:50 <vincenz> dobblego: well is there a place where I could get this information :)
02:27:09 <dobblego> vincenz, ask in #haskell-blah (sorry, not #haskell-op) for logs
02:27:48 <dobblego> vincenz, something about commenting out the use System.Posix in a #ifdef in one of the source files (vague recollection)
02:28:13 <vincenz> dobblego: that's rather annoying as I did a "cabal-install lambdabot"
02:28:40 <dobblego> I tried that, hit your problem, then compiled from source and still had the problem; newsham solved it for me
02:28:49 * vincenz nods
02:29:04 <dobblego> gota go, if you're still stuck later, I'll drag the laptop out, which has the answer :)
02:29:10 <vincenz> @tell newsham When you're around, mind telling me the fix you gave dobblego to make lambdabot work instead of getting "hdClose" consistently?
02:29:10 <lambdabot> Consider it noted.
02:29:39 <vincenz> > 1
02:29:40 <lambdabot>  1
02:31:16 <dmwit> vincenz: #define USE_RESOURCE_WORKAROUND seems to be the fix dobblego is referring to.
02:31:54 <dmwit> In scripts/Resource.hs, to be specific.
02:32:04 <dmwit> Dunno if that makes any sense to you.
02:33:09 * vincenz looks
02:34:13 <vincenz> Btw, if everyone is getting this error consistenly, isn't this package in essence broken?
02:34:52 <vincenz> dmwit: no such file
02:34:58 <dmwit> *shrug*
02:35:00 <dmwit> Sorry.
02:41:11 <Syzygy-> How do I declare an array with Int entries?
02:41:19 * quicksilver invents new obscenities to use to describe Andrew Coppin.
02:41:35 <dmwit> Syzygy-: Array Int Int?
02:42:05 <Syzygy-> Ahhh.
02:42:07 <dmwit> Syzygy-: Ix a => Array a Int
02:42:22 <dmwit> ?instances Ix
02:42:22 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
02:42:31 <dmwit> ?instances-importing Data.Ix Ix
02:42:32 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
02:42:35 <Syzygy-> > array ((0,0),(2,2)) [((1,1),2),((0,1),1),((0,2),3)] :: Array (Int,Int) Int
02:42:35 <Syzygy-> array ((0,0),(2,2)) [((0,0),*** Exception: (Array.!): undefined array element
02:42:36 <lambdabot>  array ((0,0),(2,2)) [((0,0),Exception: (Array.!): undefined array element
02:42:56 <b_jonas> wtf
02:43:00 <b_jonas> isn't Ix in prelude?
02:43:08 <dmwit> Syzygy-: Yep, because you have no (0,0) element.
02:43:15 <Syzygy-> But I had (0,0) as a bound
02:43:17 <dmwit> b_jonas: I don't think so.
02:43:22 <quicksilver> the bounds are inclusive.
02:43:28 <vincenz> quicksilver: why new obscenities?
02:43:28 <b_jonas> hmm, ok
02:43:39 <dmwit> Syzygy-: Yes, but you didn't define any value for that bound.
02:43:52 <Syzygy-> Ah
02:43:56 <quicksilver> vincenz: just catching up the cafe. "Interestingly, if you throw in the undocumented "forall" keyword"
02:44:01 <dobblego> vincenz, yes, there is no such file when doing cabal install, you'll have to try compiling from source
02:44:09 <vincenz> dobblego: I am, still no such file
02:44:13 <Syzygy-> Is there some way to construct an array that gives a default value to everything not mentioned?
02:44:19 <dmwit> Syzygy-: There is no default value assigned to non-bound indices.
02:44:19 <quicksilver> vincenz: not only is 'forall' documented, but he had already been pointed to its documentation.
02:44:24 <cremetorte> why does foldr (+) 0 [i|i<-[1..],i<100]  NOT work  but  foldr (+) 0 [i|i<-[1..99]]  does ?
02:44:27 <dmwit> Syzygy-: No, you have to do it manually.
02:44:34 <vincenz> quicksilver: ah, lovely fud
02:44:42 <Dzlk> "t this point, I still haven't worked out exactly why this hack works."
02:44:45 <Dzlk> Yikes.
02:44:49 <quicksilver> cremetorte: because it carries on down that infinite list
02:44:59 <quicksilver> cremetorte: hoping forever to fine another number less than 100
02:45:08 <quicksilver> cremetorte: (how can it know that 10^48 + 1 won't be < 100 ?)
02:45:15 <dmwit> Syzygy-: i.e. array ((0, 0), (2, 2)) $ [((1, 1), 3)] ++ zip (range ((0, 0), (2, 2))) (repeat 0)
02:45:15 <Deewiant> > [i | i <- [1..], i < 100]
02:45:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
02:45:37 <vincenz> > drop 100 $ [i | i <- [1..], i < 100]
02:45:44 <vincenz> > drop 99 $ [i | i <- [1..], i < 100]
02:45:49 <cremetorte> i see that means haskell tests all numbers in [1..]   whether they are less than 100 ?
02:45:52 <lambdabot>  thread killed
02:46:00 <lambdabot>  thread killed
02:46:02 <vincenz> cremetorte: indeed
02:46:05 <cremetorte> ok thank you
02:46:07 <Syzygy-> Ah.
02:46:20 <Deewiant> if you're using Int they will wrap around eventually so Haskell is right to do so ;-)
02:46:22 <vincenz> > take 1 $ drop 99 $ [i | i <- [1..], i < 100]
02:46:27 <Syzygy-> I could first build a 0-filled array and then add my elements in with //
02:46:32 <lambdabot>  Exception: Time limit exceeded
02:46:50 <dmwit> > [maxBound..] :: [Int] -- Deewiant, really?
02:46:52 <lambdabot>  [2147483647]
02:47:05 <dmwit> Syzygy-: yes
02:47:16 <Deewiant> > succ (maxBound :: Int)
02:47:17 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
02:47:19 <Deewiant> darn
02:47:21 <Deewiant> guess not
02:47:41 <Deewiant> > (maxBound :: Int) + 1
02:47:41 <lambdabot>  -2147483648
02:47:50 <dmwit> Deewiant: But the point is still valid.  There's no way to statically guarantee that a predicate applies to all of a (possibly-infinite) list without actually doing all the tests.
02:48:03 <Deewiant> aye, of course
02:49:45 <Deewiant> > [i | i <- [1..], False]
02:49:53 <lambdabot> Terminated
02:53:42 <ivan_> hi everyone, i have a question but not about haskell, what is an non-aproprietary internet application? according to google the def. of non-aproprietary is that it is not a trademark, not under patent and legale to distribute...? So give me an example of an application?
03:13:26 <ketil> what does an empty "Library" declaration in a cabal file mean?  I.e. there's no name, just exposed-modules and build-depends.
03:13:53 <dcoutts_> ketil: there's no name given because the lib has the same name as the package
03:14:03 <dcoutts_> since there can only be one lib per package
03:14:49 <dcoutts_> ketil: so the library decl never has a name given, where as the executables always have a name for the binary which need not be the same as the package name
03:14:54 <dcoutts_> clear as mud?
03:24:38 <ketil> oh, sorry, was away....reading...
03:25:08 <ketil> so, the library declaration just declares some common stuff for all executables?
03:26:40 <ketil> Oh, forget that.
03:27:47 <ketil> What confuses me is that my library doesn't have any Library declaration...
03:28:04 <ketil> ..while the cabal file for a collection of executables does.
03:28:34 <dcoutts_> ketil: the older style of .cabal file didn't have explicit named sections
03:29:06 <dcoutts_> ketil: so you're comparing an old and new style cabal file
03:30:39 <visof> can anyone send lambdabot to #haskell.eg
03:30:40 <visof> ?
03:30:43 <visof> please
03:31:11 <^Someone^> visof - #haskell.jp
03:31:38 <visof> what do you mean/
03:31:40 <visof> ?
03:31:48 <^Someone^> She's in that channel
03:31:51 <ketil> dcoutts, right.  I should have a Library section for the library, then?
03:31:59 <^Someone^> You can play with her there
03:32:13 <dcoutts_> ketil: if you want to convert to the new syntax, yes
03:32:51 <ketil> Can I not specify build-depends for each executable (section) separately?
03:32:54 <visof> ping dons
03:33:09 <visof> dons please send lambdabot to #haskell.eg
03:33:13 <dcoutts_> ketil: you can
03:33:20 <ketil> I only specified it for the first one, and expected more errors for the others, but that didn't happen until I removed the first one.
03:33:33 <nominolo> @localtime dons -- visof
03:33:35 <lambdabot> Local time for dons is Wed May 28 03:33:33 2008
03:33:55 <dcoutts_> ketil: you certainly can using the new syntax, I'm not sure about the old style. You cannot mix the old and new however in one file.
03:34:21 <nominolo> @losers
03:34:21 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
03:34:31 <ketil> hmm.. I'm fairly sure the build-depends is contagious here... could this be an old bug (it's an ageing installation)
03:34:32 <nominolo> @users
03:34:32 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
03:36:07 <dcoutts_> ketil: what's the problem exactly?
03:36:19 <dcoutts_> ketil: and what version of Cabal and ghc?
03:38:07 <ketil> problem exactly: I have three executables.  If I add build-depends to one of them, they all compile.  If I don't add it to any, they all (or at least two of them) fail.
03:38:07 <dcoutts_> ketil: somewhat unintentionally, the build-depends used for each lib/exe is actually the union of all the build-depends for all the lib/exes in the package
03:38:21 <dcoutts_> ketil: right, it's that mis-feature
03:38:25 <ketil> dcoutts_, that explains that, then.
03:38:35 <dcoutts_> ketil: really, you should add it for all
03:38:40 <ketil> okay, no worries.
03:38:44 <dcoutts_> ketil: we may well fix that 'feature'
03:39:02 <ketil> of course, it's more cumbersome to decide the correct dependencies for each executable.
03:39:22 <ketil> easy fix is to make build-depends a global field instead.  I'm not sure partial compilation is such a need-to-have thing.
03:40:42 <ketil> (can you even specify to build just, say, the second executable, if I happen to not have the dependencies for the first one?)
03:42:32 <dcoutts_> ketil: it's possible to mark individual components as being not buildable
03:44:00 <dcoutts_> ketil: we actually went in the other direction and made build-depends local, it was previously global
03:44:54 <ketil> dcoutts_, okay, it's just a suggestion.  It's the XP mantra: always use the simplest solution that satisfies the requirements.  I don't think you lose many customers by keeping it global.
03:45:54 <ketil> Anyway, my cabal files are now in shape, thanks for your help!
03:45:58 <dcoutts_> ketil: it allows for example to have test components that use QuickCheck/HUnit without having the whole package always depend on those test packages
03:46:00 <dcoutts_> ketil: np
03:46:30 <ketil> Good point.  I still use a Makefile for testing. :-)
03:48:57 <dcoutts_> ketil: yeah, our support for tests is still pretty poor
03:54:32 <mm_freak_work> btw, it would be very convenient, if cabal could create Makefiles
03:54:39 <dcoutts_> noooo!
03:54:42 <dcoutts_> ahem :-)
03:54:57 <dcoutts_> actually, it can, but you really don't want to
03:55:19 <mm_freak_work> it would suffce, if the Makefile just calls setup.lhs build
03:55:34 <ivanm> I think lambdabot is playing up....
03:55:35 <ivanm> @users
03:55:36 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
03:55:39 <mm_freak_work> just that a Makefile is there, because that makes most editors very convenient
03:55:43 <ivanm> ^^ that doesn't look right ;-)
03:55:44 <dcoutts_> mm_freak_work: oh, that kind of makefile, well, that's not so bad
03:56:04 <ivanm> a wrapper makefile?
03:56:10 <mm_freak_work> ivanm: right
03:56:49 <mm_freak_work> i hit a key combo in emacs to call make
03:57:06 <mm_freak_work> and currently i write a little Makefile hierarchy myself, which is very inconvenient
03:57:38 <quicksilver> surely better to rebind the key combo to call cabal..
03:58:28 <mm_freak_work> quicksilver: i would have to search for the setup.lhs
03:58:38 <mm_freak_work> and i don't feel like learning emacs lisp =)
03:58:43 <dcoutts_> mm_freak_work: no, you can: runghc Setup
03:58:50 <dcoutts_> no need to know the extension
03:58:58 <dcoutts_> ghc will look for .hs or .lhs
03:59:08 <mm_freak_work> yes, but will it also look in all parent directories?
03:59:13 <dcoutts_> ah, no
03:59:22 <mm_freak_work> also emacs will fail to interpret the error messages properly
03:59:26 <dcoutts_> for that you need haskell-mode which does something like that
03:59:44 <mm_freak_work> since it can't associate the directories properly  it does that for Makefiles automatically
03:59:45 <ivanm> I'm not sure if haskell-mode plays nicely with cabal...
04:00:04 <mm_freak_work> i couldn't find anything relevant in haskell-mode
04:00:07 <dcoutts_> mm_freak_work: by looking upwards for a Makefile?
04:00:25 <mm_freak_work> dcoutts_: by following recursive make calls properly
04:00:39 <dcoutts_> eew, recursive make :-)
04:00:51 <dcoutts_> I don't use emacs but I hear that haskell-mode and/or maybe shim can look for .cabal files and build stuff using that
04:01:31 <mm_freak_work> for projects with a single source directory, there is no problem  i write a Makefile, which calls the Makefile of the project directory, which calls the setup.lhs
04:02:06 <dcoutts_> yeah, there's no reason we cannot make a standard Makefile and ./configure script that wraps Cabal if people or package managers prefer that user interface
04:02:54 <mm_freak_work> people and package managers will just read the INSTALL file  the Makefile would be convenient for developers
04:03:18 <quicksilver> recursive make EWWWWW
04:04:24 <ivan_> :q
04:04:26 <mm_freak_work> it's very comprehensible and convenient, if used properly
04:05:46 <mm_freak_work> one giant Makefile will likely be more difficult to maintain and much more error-prone
04:10:37 <dcoutts_> mm_freak_work: that's what makefile includes are for
04:11:00 <dcoutts_> recursively include all the makefiles
04:11:45 <dcoutts_> sure, make doesn't make that really easy, but otherwise you loose info about deps and rebuilds become inaccurate and slow
04:14:13 <quicksilver> or, to make dcoutts_ point a bit more controversially, recursive make completely nullifies the entire point of using make in the first place.
04:14:22 <quicksilver> at that point you might as well use recursive shell scripts :)
04:14:32 <dcoutts_> it's not quite that bad
04:14:57 <dcoutts_> but certainly, for correctness it's vital to have a single complete view of the dependencies
04:15:28 <^Someone^> Since no one in the math channel is answering, I'll ask this here... "Lets call a projection function that returns its last argument an n-consumer where n is a positive integer representing how many arguments the function wants to consume." Does anyone know what that means? I can't make it out at all
04:15:34 <^Someone^> Src: http://www.mactech.com/articles/mactech/Vol.07/07.05/LambdaCalculus/
04:15:35 <lambdabot> Title: Lambda Calculus, http://tinyurl.com/4h8jnh
04:16:14 <dcoutts_> ^Someone^: projection-3 _ _ x = x
04:16:30 <dcoutts_> ^Someone^: projection-7 _ _ _ _ _ _ x = x
04:16:34 <dcoutts_> etc?
04:16:56 <^Someone^> Hmmm
04:17:17 <^Someone^> Is he defining n-consumer in that sentence, or is it something I'm supposed to know beforehand?
04:17:29 <dcoutts_> sounds like a definition of an n-consumer
04:17:42 <dcoutts_> it's not standard terminology afaik
04:18:12 <^Someone^> Okay
04:18:14 <^Someone^> Thank you :)
04:18:19 <dcoutts_> np
04:18:42 <quicksilver> when looking at a set of rewrite rules
04:18:55 <quicksilver> an n-consumer "eats" n-1 arguments
04:18:59 <quicksilver> and then vanishes
04:19:12 <quicksilver> (no, it's not standard terminology but that's how I understand what you've written)
04:19:23 <^Someone^> Ah, okay
04:19:24 <quicksilver> making me wonder if there is an off-by-one error.
04:19:33 <quicksilver> I'd call that an (n-1)-consumer if anything
04:19:41 <^Someone^> Yeah
04:19:51 <^Someone^> "An observation: an n-consumer applied to anything will yield an n-1-consumer if n is greater than 1. For example, a 3-consumer applied to anything will return a 2-consumer."
04:20:50 <^Someone^> Ohhhhhhhhhhhhhhhhhh
04:20:53 <quicksilver> these things are the kinds of things you think about when thinking at the level of untyped languages / rewrite rules
04:20:57 <quicksilver> like TeX, for example
04:21:05 <mm_freak_work> dcoutts_: no, if you have recursive dependencies, then you might just as well have a messed up concept =)
04:21:07 <quicksilver> you see TeX programmers speak very much in terms like that.
04:21:17 <^Someone^> I think I understand why it's called n-consumer, quicksilver
04:21:34 <quicksilver> in a typed language it's a bit silly because you "know" how many parameters functions take.
04:21:40 <mm_freak_work> that's why make doesn't work well for haskell projects  it works better for other languages
04:22:01 <^Someone^> Actually nevermind, it's not what I thought
04:22:02 <dcoutts_> mm_freak_work: it's not about recursive deps, it's that you cannot actually partition the dep graph sensibly
04:22:40 <dcoutts_> mm_freak_work: even with recursive modules there are no actual recursive deps in haskell projects, since the .hs-boot files break the loop
04:23:31 <^Someone^> (I thought it meant it will consume the n-th argument and yield an (n-1)-consumer, but it just means it takes n arguments to begin with - since consuming the n-th argument doesn't make sense)
04:24:05 <kadir> hello there
04:24:18 <byorgey> hi kadir
04:24:27 <kadir> focusedBorderColor :: !String
04:24:28 <quicksilver> well-designed C++ or C programs tend not to have recursive deps.
04:24:30 <mm_freak_work> dcoutts_: that's really a matter of view  for me a Makefile is a closed entity, but it may call Makefiles in subdirectories
04:24:43 <kadir> what's that the exclamation mark
04:24:44 <quicksilver> your ".h" files form a non-recursive subgraph
04:24:51 <quicksilver> and the .cpp files depend on them
04:24:54 <^Someone^> deps?
04:24:55 <quicksilver> kadir: strictness annotation
04:24:56 <byorgey> kadir: that's a strictness annotation
04:25:15 <quicksilver> forces that field to be immediately evaluated to whnf, never a thunk.
04:25:22 <quicksilver> (not very useful on a 'String' though)
04:25:32 <dcoutts_> mm_freak_work: read "Recursive Make Considered Harmful". It explains the issues very clearly.
04:25:33 <dcoutts_> http://miller.emu.id.au/pmiller/books/rmch/
04:25:37 <lambdabot> Title: Recursive Make Considered Harmful
04:25:55 <JaffaCake> dcoutts_: you don't believe that, do you? :)
04:26:13 <dcoutts_> JaffaCake: what that recursive make is bad and wrong? of course I do :-)
04:26:31 <JaffaCake> recursive make is modular
04:26:40 <dcoutts_> so is include, but without the same failings
04:27:06 <dcoutts_> you don't have to have one massive top level makefile
04:27:20 <mm_freak_work> dcoutts_: that's why i said, if you do it properly  and whether you do depends on your view
04:28:45 <quicksilver> JaffaCake: recursive make fails to recognise that dependencies cross "module" boundaries.
04:28:57 <dcoutts_> I bet all non-trivial uses of recursive make are actually subtly broken because there are cross-module deps that you don't think about
04:29:04 <quicksilver> JaffaCake: unless your directory structure respects some very strict and unusual propertys w.r.t. the dependency graph
04:29:34 <JaffaCake> we do have lots of missing dependencies in the GHC build... but I actually don't want to respect all of them
04:29:51 <JaffaCake> e.g. rebuilding anything in libraries should invalidate the entire stage2 compiler
04:29:52 <dcoutts_> JaffaCake: sure, that is pretty tricky
04:30:46 <dcoutts_> and it means you have to know that you've done that
04:31:06 <dcoutts_> forgetting deps should be done explicitly
04:31:42 <dcoutts_> not implicitly since when you don't realise you've forgotten deps it's almost certainly an error
04:33:52 <dcoutts_> recursive make is also a great way to loose parallelism in a build system
04:35:54 <dcoutts_> Q: why do you serialise the recursive make calls?
04:35:57 <dcoutts_> A: because they are not genuinely independent, there are deps between the dirs that I did not declare
04:37:42 <kadir> "These strict components are evaluated when the structure is created instead of delayed until demanded." i read from samewhere else
04:38:05 <kadir> but i couldn't understand still
04:38:16 <kadir> what that means
04:38:30 <byorgey> kadir: Haskell is lazy, which means that by default, expressions are not evaluated until their value is actually needed
04:38:34 <dmwit> How much do you understand about laziness?
04:38:43 <kadir> on demand evolution
04:38:44 <ivanm> byorgey: that's not quite true, is it?
04:38:55 <byorgey> ivanm: of course not, but it's a useful starting place =)
04:39:01 <ivanm> heh
04:39:07 <ivanm> btw, what did you think of my code?
04:39:08 <kadir> so strict components evaluated on module calls ?
04:39:35 <byorgey> ivanm: I actually haven't had a chance to look at it yet, but I read your description and it sounds neat!
04:39:42 <quicksilver> kadir: suppose you have Data Point = Point Int Int
04:39:51 <ivanm> byorgey: \o/
04:39:54 <dmwit> kadir: Do you understand what "seq" does?
04:40:04 <quicksilver> kadir: if the normally the value of the actual Ints inside is delayed until their value is needed for something
04:40:23 <byorgey> ivanm: I will take a look at it later today.  Don't know whether I'll use it in my talk but I'll still have fun looking at it =)
04:40:28 <quicksilver> kadir: if they were strict fields, the value inside would be forced to be calculated as soon as the main POint is inspected.
04:40:36 <ivanm> byorgey: heh
04:40:42 <mm_freak_work> dcoutts_: that's the art of Makefile-writing  recursive make is indeed only for trivial things =)
04:41:11 <mm_freak_work> one use is in an inner Makefile to call an outer Makefile to have a broader picture of the project
04:41:28 <mm_freak_work> another use is modularization, as long as the modules are independent of each other
04:41:35 <kadir> so it's evaluated as soon as when related module imported?
04:41:44 <mm_freak_work> doing that in a single monolithic Makefile would be hard to maintain
04:41:51 <dmwit> kadir: No, it's evaluated when the constructor is applied.
04:41:52 <kadir> linked if required
04:42:03 <dcoutts_> yeah, that's just the problem, you only want recursive make in the non-trivial cases, which are just the ones where it's most likely to go wrong
04:42:18 <dcoutts_> mm_freak_work: sure, we're not arguing for a single monolithic makefile
04:42:34 <dcoutts_> just no recursive invocations
04:42:36 <kadir> what happen if data declarition is recursive
04:42:42 <mm_freak_work> dcoutts_: what else?
04:42:56 <mm_freak_work> ah, includes
04:43:01 <dcoutts_> right
04:43:33 <mm_freak_work> well, that may be a problem for modularity  if you rename a directory, you're screwed, or you need to take that into account, which makes your Makefiles more difficult to maintain
04:43:56 <dmwit> kadir: Well, it's possible that the entire value could be forced this way.
04:44:41 <mm_freak_work> the nice thing about recursive make is that the make calls are highly independent and localized
04:44:54 <dcoutts_> which is the problem because the dependencies are not
04:45:07 <hpaste>  ToRA pasted "lazy vs strict" at http://hpaste.org/7940
04:45:10 <kadir> dmwit: so thanks, so this increses application speed i think?
04:45:13 <mm_freak_work> maintaining directory structure in Makefiles is a flawed concept, too, IMO
04:45:19 <dcoutts_> mm_freak_work: you have to make changes when you rename in any case, even in the recursive case you have to say which subdirs to recurse into
04:45:36 <mm_freak_work> dcoutts_: as said, it's ok, if you have recursive dependencies  i don't have them =)
04:45:36 <dmwit> kadir: Strictness annotations can sometimes help, yes.
04:45:54 <mm_freak_work> dcoutts_: sure, but it's easier to maintain
04:46:24 <dcoutts_> mm_freak_work: read the article, it explains everything, why it's no harder to maintain
04:46:48 <dmwit> kadir: You should definitely take a look at ToRA's paste.
04:47:11 <quicksilver> dmwit: evaluated when the constructor is matched (not applied)
04:47:13 <dmwit> kadir: It illustrates strictness by using "error" (which evaluates to an exception).
04:47:28 <quicksilver> dmwit: unless that's what you mean by 'applied' which is one possible meaning.
04:47:29 <dmwit> quicksilver: Yes, that's what I meant.  Thanks for the correction.
04:47:55 <quicksilver> kadir: nothing to do with modules, no.
04:47:58 <Bonus> is (map . map) already defined somewhere in the standard libraries?
04:48:02 <Bonus> as map2 or something
04:48:02 <quicksilver> kadir: completely orthogonal to the module system.
04:48:08 <quicksilver> kadir: this is all to do with values.
04:48:11 <dmwit> Bonus: no
04:48:11 <quicksilver> Bonus: no.
04:48:16 <Bonus> oh well
04:48:19 <vixey> :t map.map
04:48:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
04:48:23 <quicksilver> Bonus: I think (map.map) is about as good a name for it as you could hope :)
04:48:27 <Bonus> hehe
04:48:41 <Deewiant> :t Prelude.map Prelude.. Prelude.map
04:48:41 <dmwit> Bonus: I've defined deepMap in the past to work on lists of any dimension.
04:48:43 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
04:48:46 <vixey> (.:) ?
04:48:49 <dmwit> But it turns out not to be that useful. =P
04:48:53 <kadir> dmwit: thanks so much, i'll look at that
04:48:54 <Bonus> haha
04:49:00 <quicksilver> and it requires overlapping instances
04:49:03 <Bonus> yeah but map.map is pretty usefl a lot of times
04:49:04 <quicksilver> which is a clue that it might be evil.
04:49:11 <quicksilver> it breaks parametric polymorphism.
04:49:17 <dmwit> Err, really?
04:49:20 <quicksilver> yes.
04:49:24 <dmwit> I don't recall adding any extensions...
04:49:29 <quicksilver> suppose you call deepmap on [[[a]]]
04:49:36 <quicksilver> it will automatically select the 3-deep version.
04:49:43 <quicksilver> but what if "a" turns out to be [b]
04:49:51 <quicksilver> then should it not have selected the 4 deep version?
04:49:57 <quicksilver> depends what it can "see" at compile time.
04:49:59 <Bonus> hmm
04:50:31 <^Someone^> Haha
04:51:04 <quicksilver> it's a surprisingly subtle problem because normally the type of the function (a -> b) ties it down anyway
04:51:04 <^Someone^> They sure'll be surprised to find it's me and not them
04:51:16 <quicksilver> so, admittedly, most of the time it doesn't look ambiguous
04:51:22 <quicksilver> but if the function is also polymorphic in the right way
04:51:27 <quicksilver> there can be genuine ambiguity
04:56:11 <^Someone^> Lambda calculus question (Assume L stands for the greek lambda...): What does Lx.xy mean?
04:56:21 <^Someone^> Why "xy"?
04:56:42 <^Someone^> (It's as far as I can see different from (Lx.x)y, the application)
04:57:57 <^Someone^> It's from: www.utdallas.edu/~gupta/courses/apl/lambda.pdf
04:58:13 <opqdonut> ^Someone^: it means Lx.(xy)
04:58:24 <opqdonut> argument x applied to y
04:58:33 <^Someone^> Oh
04:58:40 <^Someone^> How can you apply it to y?
04:58:46 <kadir> so is there any magic command in ghci which prints documentation
04:58:49 <^Someone^> Generally
04:58:52 <kadir> i couldn't see any
04:58:58 <^Someone^> What if it's a number?
04:59:33 <ToRA> ^Someone^: the answer to that question is why we have static type systems...
04:59:37 <pejo> Someone, either your numbers are church numerals, in which case they are just lambda abstractions, or you have a type error.
04:59:55 <^Someone^> Okay, ty :)
05:00:05 <Baughn> kadir: :help
05:00:23 <quicksilver> ^Someone^: in lambda calculus you can apply everthing to everything
05:00:32 <quicksilver> ^Someone^: that is one of its distinguishing features
05:00:47 <kadir> :help prints magic commands :)
05:00:59 <quicksilver> (lambda calculus, unqualified, refers to the 'untyped lambda calculus')
05:01:12 <quicksilver> kadir: documentation for what? documentation for libraries you're best having the web page open.
05:01:22 <^Someone^> quicksilver, what happens when you apply a Church numeral to, say, another Church numeral?
05:01:24 <dmwit> Ah, the problem (for deepMap) is in the final step.
05:01:25 <quicksilver> kadir: I never do anything without http://www.haskell.org/ghc/docs/latest/html/libraries/ open in a tab.
05:01:31 <dmwit> I wonder how I did it before...
05:01:38 <quicksilver> ^Someone^: as it happens, they multiply
05:01:52 <quicksilver> ^Someone^: this is a consequence of how church numerals happen to be defined.
05:02:05 <quicksilver> you can imagine other ways of encoding numbers in LC which would behave differently.
05:02:22 <dmwit> ?index liftIO
05:02:23 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:02:33 <kadir> ah so, inner code documentation doesn't seem to exists in haskell :)
05:03:01 <^Someone^> Okay, quicksilver
05:03:03 <^Someone^> Ty
05:03:40 <quicksilver> kadir: ghci doesn't have access to the documentation; the documentation doesn't necessarily come with the (compiled) code and ghci doesn't have the smarts to extract it fro the source although that is certainly possible in principle.
05:04:16 <quicksilver> kadir: however, there is little stomach for writing YA hypertext browser in ghci when web browsers exist, are free, are available on all machine which run haskell compilers...
05:06:35 <kadir> yeah, i know i must do more research on haskell on more generic consepts, but i like to ask here
05:06:45 <kadir> thanks for replies
05:07:07 <kadir> i'll ask here more specific question's
05:11:20 <dmwit> So, how is (liftIO :: IO a -> ListT (ListT (ListT IO)) a) magically possible without overlapping instances?
05:11:40 <quicksilver> because of the IO at the base
05:11:54 <quicksilver> the IO at the base gives a concrete type for the type class hierarchy to "fixate" on.
05:12:06 <quicksilver> you could do deepMap for any fixed set of concrete types
05:12:15 <quicksilver> like [[[Int]]], [[[[[[[Double]]]]]]]
05:12:17 <quicksilver> etc.
05:12:41 <quicksilver> you can generalise that to finitely generated infinite families of concrete types without problem.
05:13:05 <quicksilver> but when you go to 'all types' you break parametricity, in a sense.
05:13:12 <dmwit> Hum.
05:13:17 <dmwit> Do you mind if I ask this again tomorrow?
05:13:23 <quicksilver> of course not
05:13:31 <quicksilver> you might get a better answer from someone smarter, tomorrow :)
05:13:42 <tchakkazulu> [[[[[[Identity a]]]]]]
05:13:52 <dmwit> I might be more awake tomorrow. =P
05:14:03 <quicksilver> tchakkazulu: yes, you can use an explicit Box type to halt the recursion.
05:14:15 <tchakkazulu> That's what IO does, I guess.
05:14:17 <quicksilver> explicit Box types have all kinds of handy uses.
05:14:35 <tchakkazulu> I mean, the whole magic liftIO thing. Makes use of IO stopping the layers.
05:14:46 <tchakkazulu> Oh, wait. That has been mentioned 3 minutes ago.
05:15:04 <tchakkazulu> 's what I get for reading way, way, back up there, and not looking nearby >_>
05:15:35 <quicksilver> ;)
05:15:53 <quicksilver> dmwit: note that some of the stuff in the MTL does use overlaps IIRC.
05:16:04 <quicksilver> some of the class instances
05:18:04 <quicksilver> that's obviously a stupid thing to say, since where else would an overlap be :)
05:18:10 <quicksilver> but I mean the MonadFoo instances.
05:18:45 <ToRA> > flip runState False . flip runReaderT "a" $ liftM2 (,) ask get
05:18:46 <lambdabot>  (("a",False),False)
05:20:36 <ToRA> need the overlapping instances so you don't need to do lift to get a MonadState instance out of a (MonadState m) => ReaderT m
05:21:35 <quicksilver> what does that overlap with?
05:22:10 <ToRA> mmm, good point
05:22:22 <quicksilver> I think it might only be MonadTrans
05:22:25 <quicksilver> but I don't recall the details
05:22:58 <quicksilver> by and large the quadratic instances are there precisely to avoid overlaps.
05:23:14 <quicksilver> (if you're prepared to accept overlaps, you only need a linear number of instances)
05:24:53 <ToRA> ah
05:27:15 <ToRA> so e.g. C.M.R.Class requires undecidable instances in it's source, though it claims only wanting fundeps and mptcs
05:31:53 <quicksilver> undecidable is not as bad as overlapped, in my particular opinion.
05:32:03 <quicksilver> I don't like overlapped because I really like parametricity.
05:32:19 <quicksilver> undecidable in theory (but decidable in practice) doesn't harm that.
05:35:43 <smg> someone a quick suggestion how i can turn [1,2,3,4,5] and [8,9,10,11,12] into [(1,8),(2,9),(3,10),..] ?
05:35:54 <opqdonut> zip
05:35:56 <ndm> smg: zip
05:36:04 <opqdonut> > zip [1,2,3,4,5] [8,9,10,11,12]
05:36:05 <lambdabot>  [(1,8),(2,9),(3,10),(4,11),(5,12)]
05:36:10 <ndm> @hoogle [a] -> [a] -> [(a,a)]
05:36:19 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
05:36:19 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
05:36:25 <smg> ah i forgot about that _really_ handy zipWith
05:36:30 <smg> thank you!
05:40:30 <smg> is that good?
05:40:45 <smg> listEquals x y = and $ zipWith (\x y -> x == y)  x y
05:40:46 <smg> ?
05:41:08 <opqdonut> smg: listEquals = and . zipWith (==)
05:41:17 <smg> ah interesting
05:41:33 <matthew_-> but, that's surely the same as x == y
05:41:35 <ddarius> You may want to choose a different name or perhaps that doesn't do what you think it does.
05:41:36 <mbz> > [1,2,3] == [1,2,3]
05:41:38 <ndm> smg: no, that's no good at all
05:41:39 <lambdabot>  True
05:41:40 <ddarius> matthew_-: No.
05:41:41 <quicksilver> listEquals = (==)
05:41:41 <smg> yeah it is
05:41:45 <ToRA> not it isn't
05:41:54 <smg> i know that we have == for lists
05:41:58 <smg> i just wanted to implement it myself
05:41:58 <ndm> [1,2,3] == [1,2,3,4] in this list equality
05:42:03 <ToRA> you need to pre-truncate the lists to the same length first
05:42:10 <matthew_-> ahh yes
05:42:17 <matthew_-> good point batmen
05:42:28 <smg> i know that ToRA hehe
05:42:46 <ndm> length x == length y && listEquals x y would be enough
05:42:52 <ndm> but its not lazy enough
05:42:59 <ndm> or rather, could be more lazy
05:43:00 <matthew_-> I forget that haskell's lists aren't type indexed by their length...
05:43:08 <smg> opqdonut: nevermind that won't work
05:43:17 * matthew_- invents more crazy excuses...
05:43:24 <vixey> matthew_-: used to some setting where they are?
05:43:29 <vixey> (sounds interesting..)
05:43:31 <matthew_-> vixey: yeah, my code
05:44:33 <vixey> I've never seen this in haskell
05:44:49 <opqdonut> matthew_-: :D
05:45:01 <vixey> []==[]=True; (x:xs)==(y:ys)=x==y&&xs==ys
05:45:42 <vixey> _==_=False
05:45:49 <ToRA> @type ((uncurry (==) . unzip) .) . zip
05:45:52 <lambdabot> forall b. (Eq b) => [b] -> [b] -> Bool
05:46:17 <vixey> @src unzip
05:46:17 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
05:46:23 <matthew_-> vixey: oh. So I suspect hlist and oleg and probably conor have all done this stuff. You just have to have type level arithmetic, which is pretty straight forward and then recreate your notion of a list and then you can statically reject calling == between two lists of different lengths
05:46:26 <vixey> hehe
05:47:17 <vixey> matthew_-: Cool, how does it work in terms of runtime interaction?
05:47:41 <vixey> like if you had n <- getNumber {- read some number from IO -} ; replicate n 'e' ?
05:47:59 <matthew_-> right, so in that case you have no such information
05:48:38 <matthew_-> so you could possibly, if you worked really hard, do let es = replicate n 'e'; fs = replicate n 'f' in es == fs
05:49:06 <matthew_-> but getNumber would have to be supercool and basically be (TyNum n) => IO n
05:49:16 <byorgey> of course, in a true dependently typed language, length-indexed lists are easy as pie, and don't require olegian feats
05:49:17 <matthew_-> which would be a little bit tricky
05:49:28 <matthew_-> byorgey: absolutely.
05:50:07 <matthew_-> but olegian feats are good fun
05:50:10 <quicksilver> they're still not as useful as pie.
05:50:15 <byorgey> or as tasty
05:50:16 <quicksilver> for the reason vixey suggests :)
05:50:31 <quicksilver> that lists of statically-unknown length are rather common in real programs.
05:50:33 <byorgey> matthew_-: to be sure. =)
05:50:51 <matthew_-> quicksilver: you non-believer you!
05:51:10 <matthew_-> user-interaction is overrated
05:51:12 <vixey> has anyone read View From the Left?
05:51:15 <matthew_-> yep
05:51:29 <vixey> I tried to but it didn't make much sense
05:51:32 <byorgey> quicksilver: that's because "real" programs insist on doing silly things like getting "input" from the "user".
05:51:34 <vixey> I think I need to print it
05:51:42 <byorgey> REAL programs have all their input hard-coded!!!
05:51:53 <byorgey> if you want to give a different input, just edit the source code
05:52:45 <smtms> byorgey, and if you want an interactive application, you just correctly guess what the input will be
05:52:50 <matthew_-> byorgey: or require the user input comes complete with a type annotation ;)
05:53:06 <byorgey> hehe
05:53:16 <matthew_-> and then just collapse the compiler, interpreter and runtime system into one unholy mess...
05:53:21 <matthew_-> ... a la Epigram
05:54:10 <vixey> so dependant typed languages fold Types and Values into one
05:54:19 <vixey> and as a result, it folds Users and Programmers into one
05:55:19 <smg> @pl amplifyElementsN (x:xs) times = (take times $ repeat x) ++ amplifyElementsN xs times
05:55:20 <lambdabot> amplifyElementsN = fix ((`ap` tail) . (. head) . flip ((.) . ap . ((++) .) . flip take . repeat))
05:55:24 <smg> ahh :)
05:56:10 <vixey> > replicate 3 =<< [1,2,3]
05:56:11 <lambdabot>  [1,1,1,2,2,2,3,3,3]
05:56:37 <wjt> > join replicate =<< [1, 2, 3]
05:56:40 <lambdabot>  [1,2,2,3,3,3]
06:01:47 <vixey> what about Irdris?
06:02:14 <vixey> Idris*
06:02:23 <vixey> has anyone used that?
06:02:28 <vixey> I found this the other day http://www.cs.st-and.ac.uk/~eb/Idris/
06:02:30 <kadir> annotion strcitness differs in evoluation time and initialization time
06:02:30 <lambdabot> Title: Idris
06:02:35 <smg> vixey: that _is_ cool!
06:03:10 <vixey> I am interested in Idris because it says you can write real programs with it
06:04:13 <kadir> so the choise is up to application type and developer i think
06:05:02 <kadir> i'm messing around xmonad source code
06:05:09 <vixey> byorgey and matthew_- any thoughts?
06:05:37 <kadir> and see that data constructions are generally uses strict annotations
06:06:14 <kadir> why is so in detail?
06:07:09 <vixey> smg,
06:07:14 <vixey> (>>=) = flip concatMap
06:07:20 <vixey> return = (:[])
06:07:32 <vixey> I always remember these two equations for the [] Monad
06:09:06 <pjdelport> fmap = map and join = concat
06:09:11 <pjdelport> much easier
06:09:32 <vixey> what is (>>=) in terms of fmap and join?
06:09:56 <ivanm> is there much of a performance difference between concat . map and concatMap?
06:09:56 <ddarius> vixey: Just work out the types.
06:09:57 <vixey> :t flip(join.fmap)
06:09:59 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
06:09:59 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
06:09:59 <lambdabot>     In the second argument of `(.)', namely `fmap'
06:10:06 <vixey> ivanm: no
06:10:12 <vixey> :t flip(join.map)
06:10:14 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
06:10:14 <lambdabot>     Probable cause: `map' is applied to too many arguments
06:10:14 <lambdabot>     In the second argument of `(.)', namely `map'
06:10:27 <BeelsebobWork> @src concatMap
06:10:28 <lambdabot> concatMap f = foldr ((++) . f) []
06:10:37 <vixey> concatMap = concat . map
06:10:49 <ivanm> if you look at the source, it doesn't though...
06:10:56 <vixey> ivanm: it's true
06:10:59 <BeelsebobWork> vixey: even if implemented like that there's a *tiny* performance difference
06:11:09 <ivanm> not even a space penalty?
06:11:15 <ivanm> BeelsebobWork: that's what I figured
06:11:35 <vixey> BeelsebobWork: I hesistate to make that kind of assumption about a compiler
06:11:37 <ivanm> not to mention the intermediary list data structure
06:11:41 <BeelsebobWork> but if it's implemented as foldr ((++) . f) [] it should be slighly faster though
06:11:46 <vixey> what if it optimized it better
06:12:07 <ivanm> vixey: compiler tricks excluded :p
06:12:10 <MyCatVerbs> What if you just examine the damn Core output and see for yourself?
06:12:15 <ivanm> heh
06:12:20 <vixey> MyCatVerbs, lol
06:12:23 <MyCatVerbs> -ddump-simpl for the win. Guesswork for the lose.
06:13:36 <ivanm> or use don's ghc-core?
06:13:42 <smg> vixey: :))
06:13:59 <dcoutts_> given that concat = foldr (++) [] I'd expect concat . map and concatMap to be identical
06:14:22 <dcoutts_> due to foldr/build fusion
06:15:51 <Deewiant> @ty (join .) . flip fmap
06:15:52 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
06:16:01 <ivanm> dcoutts_: but that's a compiler optimization rather than the actual implementation, right?
06:16:13 <ivanm> what happens if you don't call with any optimization flags?
06:16:51 <dcoutts_> ivanm: I don't know, but then who cares?
06:17:12 <vixey> ivanm: I don't think it's sensible to think about these kinds of optimizations
06:17:21 <ivanm> dcoutts_: heh
06:17:22 <vixey> ivanm: the real differences come from algorithms
06:17:24 <ivanm> vixey: idle curiosity :p
06:17:39 <ivanm> well, algorithms and data structures :p
06:17:42 <dcoutts_> if you don't care about performance enough to turn on -O then I don't think you can complain
06:17:46 <SamB> vixey: why isn't it sensible to think about them?
06:18:00 <SamB> vixey: somebody has to implement them...
06:18:09 <vixey> SamB: we weren't talking about implementing them
06:18:27 <SamB> well, maybe you better qualify the statement
06:18:45 <ivanm> dcoutts_: my original question was more on a theoretic viewpoint
06:18:53 <vixey> in general .. spending time choosing between "concatMap" and "concat . map" is time wasted
06:19:01 <ivanm> obviously you'd assume that the compiler would convert concat . map to concatMap, but still
06:19:01 <SamB> ah, indeed
06:19:07 <ivanm> vixey: yes, I know
06:19:09 <SamB> use concatMap because it's quicker to read
06:19:13 <ivanm> and type
06:19:21 <SamB> reading is more important
06:19:30 <opqdonut> nah, pressing shift takes at least 10 keypresses ;)
06:19:38 <ivanm> and saves valuable storage space... THREE WHOLE BYTES SAVED!!! \o/ :p
06:19:46 <vixey> SamB: Have you looked at Idris at all?
06:19:50 <ivanm> opqdonut: wtf?
06:20:00 <SamB> what's Idris
06:20:11 <vixey> http://www.cs.st-and.ac.uk/~eb/Idris/
06:20:12 <lambdabot> Title: Idris
06:20:14 <opqdonut> ivanm: the unix mentality :)
06:20:23 <tchakkazulu> ?type concat . map
06:20:26 <lambdabot>     Couldn't match expected type `[[a]]'
06:20:26 <lambdabot>            against inferred type `f a1 -> f b'
06:20:26 <lambdabot>     Probable cause: `map' is applied to too few arguments
06:20:45 <tchakkazulu> ?type let (.:) = (.).(.) in concat .: map
06:20:46 <SamB> opqdonut: moving your pinky takes the time of 10 keypresses now?
06:20:47 <opqdonut> ?type (concat .) . map
06:20:47 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
06:20:49 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
06:21:11 <vixey> yikes big mistake on my part
06:21:22 <tchakkazulu> (though concatMap f == concat . map f)
06:21:24 <vixey> thanks for noticing that tchakkazulu++
06:21:54 <ivanm> see? there's an even bigger performance hit! one whole extra function composition! :p
06:22:49 <vixey> SamB: it seems cool because the implementation is tiny, and it's got an IO Monad
06:23:02 <vixey> I mean it's really tiny because it uses a lib but still
06:24:02 <SamB> vixey: ooh, another one?
06:30:19 <pjdelport> :t let (<$$>) = (<$>).(<$>) in concat <$$> map
06:30:22 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
06:32:20 <tchakkazulu> :t (<$>).(<$>)
06:32:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:33:17 <pjdelport> functor application with the right-hand side doubly special
06:34:18 <tchakkazulu> Ah, yes.
06:34:40 <pjdelport> normally, the reader instance means that the right-hand side of <$> takes one extra parameter from the environment
06:35:01 <tchakkazulu> And for an amount of nested functors, you'd need to chain the same amount of (<$>).
06:35:02 <pjdelport> so <$$> means it takes two
06:35:08 <pjdelport> right
06:35:13 <tchakkazulu> Cool :)
06:35:49 <tchakkazulu> Oh, yes. lambdabot's (.) == (<$>). Forgot about that <_<
06:36:17 <pjdelport> doesn't matter if you use <$> directly :)
06:37:12 <tchakkazulu> I tend to think of (.) more like a specialised (<<<) than a specialised (<$>).
06:41:25 <Bonus> what's the general name for a function supplied to a fold
06:41:38 <Bonus> if there is one
06:41:49 <mm_freak_work> fold function
06:41:53 <Bonus> ah
06:41:54 <Bonus> lol
06:41:56 <mm_freak_work> ;)
06:42:22 <mm_freak_work> 'reduction function' may make sense in some cases
06:42:31 <vixey> f
06:42:35 <Bonus> yeah hmm
06:42:40 <vixey> @src foldr
06:42:40 <edwardk> the algebra?
06:42:40 <lambdabot> foldr f z []     = z
06:42:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:42:41 <vixey> :p
06:42:42 <tchakkazulu> I've been working with the term "algebra" <_<
06:42:43 <Bonus> fold function might be confused for fold itself
06:42:51 <tchakkazulu> Ninja'd by edwardk.
06:42:56 <edwardk> heh
06:43:06 <mm_freak_work> algebra?
06:43:22 <edwardk> An f-algebra has the form (f a -> a)
06:43:42 <pjdelport> Bonus: you could perhaps call it by the constructor it replaces
06:43:54 <edwardk> you basically specialize that in foldr with the function for cons and value for nil
06:43:59 <pjdelport> e.g. foldr takes a cons and a nil
06:44:14 <edwardk> together those form an algebra for the underlying list functor
06:45:35 <tchakkazulu> ?type foldr (liftA2 (:)) pure
06:45:37 <lambdabot> forall a. [a -> a] -> a -> [a]
06:45:44 <pjdelport> Bonus: for example, http://srfi.schemers.org/srfi-1/srfi-1.html#FoldUnfoldMap
06:45:51 <lambdabot> Title: SRFI 1: List Library
06:45:59 <tchakkazulu> ?type foldr (liftA2 (:)) (pure [])
06:46:01 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
06:46:18 <edwardk> as opposed to data Mu f = In { outF :: f (Mu f) } ; cata :: (f a -> a) -> Mu f -> a; cata phi = phi . fmap (cata phi) . outF
06:48:59 <smg> @pl swapElements list = reverse first ++ swapElements second  where (first, second) = splitAt 3 list
06:48:59 <lambdabot> (line 1, column 81):
06:48:59 <lambdabot> unexpected "="
06:48:59 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
06:49:13 <vixey> smg, lambabot doesn't understand 'where'
06:49:25 <smg> ah okay
06:49:35 <smg> vixey: see you a possibility to make my version shorter?
06:50:09 <vixey> smg: What does the function do?
06:50:58 <smg> it take a list and reverses 3 values so [1,2,3,4,5] becomes [3,2,1,5,4] or [1,2,3,4] become [3,2,1,4]
06:51:18 <vixey> smg: You should definitely check out Arrow.hs then
06:51:28 <smg> we aren't allowed.
06:51:30 <smg> only Prelude
06:51:33 <vixey> I'm allowing you
06:51:53 <smg> my teacher won't accept if it's not only from the Prelude :)
06:52:06 <vixey> the obvious thing to do would be not give your teacher Arrow.hs
06:52:26 <smg> yeah but we should not use other modules but prelude
06:55:23 <Deewiant> @pl swapElements list = let apart = splitAt 3 list in reverse (fst apart) ++ swapElements (snd apart)
06:55:23 <lambdabot> swapElements = fix ((. splitAt 3) . ap ((++) . reverse . fst) . (. snd))
06:55:45 <smg> hehe
06:56:00 <smg> swapElements list = reverse first ++ (if second == [] then [] else swapElements second) where (first, second) = splitAt 3 list <-- i have now this
06:56:03 <smg> i think it's okay
06:57:21 <Deewiant> > let x `inGroupsOf` n = map (take n) . takeWhile (not.null) . iterate (drop n) $ x; swapElements xs = (xs `inGroupsOf` 3) >>= reverse in swapElements [1..10]
06:57:22 <lambdabot>  [3,2,1,6,5,4,9,8,7,10]
06:58:52 <smg> Deewiant: is this "better"?
06:59:45 <Deewiant> *shrug* I think it makes the intent clearer but it's a matter of opinion I guess
07:00:12 <smg> hehe i like   your version but it's harder to read for me first
07:00:18 <Deewiant> you might want to replace >>= with concatMap though, I just used that because it's shorter to type :-P
07:00:25 <smg> ^^
07:00:31 <smg> no i like obfuscated code :)
07:00:59 <vixey> ooh inGroupsOf
07:01:39 <Deewiant> a function which deserves addition to Data.List IMHO :-)
07:01:52 <smg> hehe
07:01:57 <vixey> yeah we had a vote on it
07:02:01 <vixey> @polls
07:02:01 <lambdabot> Unknown command, try @list
07:02:21 <Deewiant> @poll-list
07:02:21 <lambdabot> []
07:02:26 <Deewiant> :-P
07:02:43 <mbz> @poll-array
07:02:43 <lambdabot> Unknown command, try @list
07:02:49 <mbz> :\
07:03:16 <Deewiant> vixey: but has it been made into a library submission?
07:04:03 <mm_freak_work> > let parts n [] = []; parts n xs = take n xs : parts (drop n xs); in (concat . map reverse . parts 3) [1,2,3,4,5,6,7,8,9]
07:04:04 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Int'
07:04:55 <mm_freak_work> > let parts n [] = []; parts n xs = take n xs : parts n (drop n xs); in (concat . map reverse . parts 3) [1,2,3,4,5,6,7,8,9]
07:04:58 <lambdabot>  [3,2,1,6,5,4,9,8,7]
07:05:46 <mm_freak_work> i needed that 'parts' function quite often  it should be in Data.List
07:05:48 <BMeph> I thought the canonical name was "chunks"? ;)
07:06:04 <Deewiant> I like 'inGroupsOf' myself :-)
07:06:13 <mm_freak_work> or 'parts' as in 'partitions' =)
07:06:26 <BMeph> multi-parts?
07:07:13 <mm_freak_work> Deewiant: you would force infix notation with 'inGroupsOf'
07:07:27 <hpaste>  (anonymous) annotated "captureN" with "(no title)" at http://hpaste.org/7683#a1
07:07:42 <Deewiant> if 'parts' is to be read as 'partitions' I think it should return all partitions of a list
07:07:54 <Deewiant> mm_freak_work: true, but I don't think it's that bad
07:07:58 <mm_freak_work> true
07:08:07 <Deewiant> mm_freak_work: better than any alternative I've seen so far, IMHO :-P
07:08:08 <mm_freak_work> well, i don't like infix notation for some things
07:08:21 <mm_freak_work> i even write (mod a b) instead of (a `mod` b)
07:09:19 <Deewiant> how about stuff like isInfixOf
07:09:49 <Deewiant> they also require infix notation if you want to read them left-to-right and have it make sense :-)
07:10:09 <mm_freak_work> yeah, i write those infix, but i don't like haskell's infix syntax =)
07:10:38 <Deewiant> true, the backticks are annoying
07:10:42 <opqdonut> yeah
07:10:44 <Deewiant> got any good alternatives? :-P
07:10:47 <mm_freak_work> yes
07:11:02 <opqdonut> well something like <isInfixOf> maybe?
07:11:06 <opqdonut> or would that conflict
07:11:13 <opqdonut> yeah
07:11:17 <mm_freak_work> that would be worse, i guess
07:11:19 <Deewiant> it could, but not likely
07:11:24 <mm_freak_work> and it wouldn't work
07:11:25 <Deewiant> mm_freak_work: so what do you propose
07:11:42 <mm_freak_work> maybe some infix operator
07:11:54 <Deewiant> what just came to mind is a pragma or some such
07:12:07 <Deewiant> {-# INFIX #-}
07:12:15 <Deewiant> and then it's /always/ infix
07:12:17 <opqdonut> mm_freak_work: you probably know of the -: :- trick?
07:12:22 <vixey> I like the approach of Agda 2
07:12:29 <opqdonut> vixey: how're they doing it?
07:12:34 <vixey> it would be great if you could get sections and remove some of the need for spaces
07:12:36 <Deewiant> so you can write "xs inGroupsOf 3" and it'll parse it as though there were backticks
07:12:41 <vixey> opqdonut: You may write for example
07:12:52 <vixey> if_then_else_ :: Bool -> a -> a -> a
07:13:04 <opqdonut> ah
07:13:07 <vixey> and then if True then p else q = p .. etc
07:13:17 <smg> is it hard to implement ?:; in haskell?
07:13:44 <mm_freak_work> > let a +: f = f a; (:+) = ($) in 7 -- mod -- 3
07:13:45 <lambdabot>      Constructor `:+' should have 2 arguments, but has been given 0
07:13:45 <lambdabot>     In th...
07:13:53 <byorgey> smg: what is ?:; ?
07:14:01 <mm_freak_work> > let a +: f = f a; (:+) = ($) in 7 +: mod :+ 3
07:14:01 <lambdabot>   add an instance declaration for (RealFloat (t -> t))
07:14:16 <opqdonut> mm_freak_work: :+ is a type constructor
07:14:19 <vixey> infixr 2 <|; x <| f = f x; infixl 1 |>; f |> x = f x     -- [1,2,3] <| zipWith (+) |> [4,5,6]
07:14:22 <opqdonut> use -| |- or something
07:14:28 <vixey> stole that from someone in here :p
07:14:38 <mm_freak_work> > let a -| f = f a; (|-) = ($) in 7 -| mod |- 3
07:14:39 <lambdabot>  1
07:14:40 <opqdonut> yeah, those operator tricks give infix exprs for free too
07:14:53 <mm_freak_work> but actually that's even more ugly
07:14:57 <smg> byorgey: ternary operator
07:15:03 <Itkovian> err ... how do I get the String out of the IO String again? (using randomOctet to generate a bunch of random bytes)
07:15:04 <Deewiant> > let a ? b = if a then Just b else Nothing; (Just a) - _ = a; Nothing - b = b; in (True ? 1 - 2, False ? 1 - 2)
07:15:05 <lambdabot>  (1,2)
07:15:19 <Deewiant> (used - instead of : because you can't use :)
07:15:20 <^Someone^> I didn't even know I had it in the first place, so you're okay, vixey ^^
07:15:21 <^Someone^> :P
07:15:39 <byorgey> smg: ah.  well,  if...then...else in haskell is exactly the ternary operator, with different syntax
07:15:41 <opqdonut> Itkovian: >>= or do-notation and <-
07:15:46 <Deewiant> smg: something like that works, but of course you can't enforce that ? and - have to be used together :-)
07:15:48 <byorgey> smg: or you can do something like what Deewiant showed
07:16:03 <mm_freak_work> > let app (a,f,b) = f a b in app (6,mod,4)
07:16:04 <lambdabot>  2
07:16:07 <Deewiant> smg: but yeh, if-then-else is ?:
07:16:12 <Itkovian> opqdonut: hmm ... I need to shove it in a Map
07:16:27 <mm_freak_work> but that's not infix anymore
07:16:29 * Itkovian tries
07:16:32 <smg> Deewiant: i know :)
07:16:48 <vixey> (6 ,mod, 4)
07:16:52 <smg> yeah i just wanted to implement that shorthand
07:16:54 <vixey> yeck :D
07:17:19 <mm_freak_work> i think i'll stick with mod 6 4 =)
07:17:33 <Deewiant> smg: if you must, you can define something like a Maybe of your own and not export it at all, thus making it impossible for people to use only ? or -
07:17:37 <mm_freak_work> for most of my purposes, that's the most readable version anyway =)
07:17:53 <smg> Deewiant: k
07:18:04 <smg> mod 6 4 works?
07:18:08 <Deewiant> > mod 6 4
07:18:09 <lambdabot>  2
07:18:11 <byorgey> smg: the : character in particular is reservd syntax in Haskell, so you wouldn't be able to implement ?: exactly without hacking the compiler
07:18:17 <smg> ah okay so (mod) is redundant
07:18:30 <smg> byorgey: hehe yes, i guessed that :|
07:18:41 <osfameron> I implemented ternary in haskell as ? !
07:18:43 <mm_freak_work> mostly i use it like (mod (someLongExpression) n) anyway
07:18:56 <Deewiant> osfameron: did you use a trick like mine or how'd you do it
07:19:11 <mm_freak_work> or: flip mod n $ someVeryLongExpression
07:19:13 <vixey> mm_freak_work you can use one less parenthesis with ``
07:19:29 <Deewiant> in most cases I prefer infix syntax to flip :-)
07:19:40 <mm_freak_work> vixey: IMO there's nothing wrong with parenthesis  i like to avoid backticks more ;)
07:20:35 <mm_freak_work> and the parenthesis in the first expression clearly separate the modular expression from the modulus  it's beautiful and readable
07:20:42 <osfameron> Deewiant: http://osfameron.vox.com/library/post/more-on-maybes-and-haskell-ternary.html
07:20:44 <lambdabot> http://tinyurl.com/6cgejl
07:20:50 <mm_freak_work> not always good to try to avoid points and parenthesis, where possible =)
07:21:05 <mm_freak_work> i prefer pointy syntax anyway, for most non-trivial things
07:21:18 <osfameron> Deewiant: I suspect that's the same trick you used from a quick scan of the backlog ?
07:21:24 <Deewiant> osfameron: yeah, looks like
07:21:51 <Mr_You> I'm a newb to Haskell, and occasionally I'm coming across talk of a haskell shell, anyone familiar with the status of this?  Sounds great.
07:22:22 <augur> you can mess with lambdabot while you're here. :P
07:22:47 <mm_freak_work> Mr_You: i don't think, it will replace your system shell  yet ;)
07:23:12 <Mr_You> well as long as thats the goal ;-)
07:23:28 <byorgey> oh, that should be smartBorders (Mirror tiled)
07:23:32 <byorgey> oops, mischan
07:29:49 <byorgey> Mr_You: I've seen a few such things out there, but I think they are all sadly out of date
07:30:15 <edwardk> byorgey: did you get enough math in haskell references?
07:30:30 <nolrai_> @pl \s -> (+s) *** succ
07:30:30 <lambdabot> (*** succ) . (+)
07:30:55 <byorgey> edwardk: there's no such thing =)
07:31:01 <nolrai_> hmm
07:31:11 <edwardk> byorgey: heh
07:31:35 <byorgey> edwardk: the idea is to collect as much as I can so I can pick a few really excellent examples, and have a big list of further reading at the end
07:31:49 <edwardk> byorgey: i also have some 2s complement arithmetic in the type system if it helps ;)
07:31:56 <opqdonut> heh
07:32:09 <byorgey> edwardk: cool, I'd love to see it!
07:32:25 <edwardk> byorgey: http://comonad.com/haskell/type-int/
07:32:26 <lambdabot> Title: Index of /haskell/type-int
07:32:35 <byorgey> thanks!
07:32:41 <edwardk> there is type level base 16 there, but it uses template haskell for all its work, so there be demons ;)
07:32:56 <edwardk> the base 2 stuff is there because it can be understood without a migraine
07:34:12 <jynxzero> Hello Haskellers... I'm trying to define a monad, and I want to restrict the return type to Ord...
07:34:15 <jynxzero>   7 instance Monad ND where
07:34:27 <jynxzero> ^ Can't write (Ord a) => because there's no a
07:34:30 <jynxzero> Any suggestions?
07:35:04 <opqdonut> restricted monads aren't possible with the prelude
07:35:23 <jynxzero> Darn (but thanks)
07:35:29 <jynxzero> I have to define my own Monad class?
07:35:31 <byorgey> jynxzero: see the rmonad package on hackage
07:35:32 <opqdonut> there're some blog posts etc about implementing them
07:35:40 <opqdonut> yeah, and a package
07:36:01 <jynxzero> Not the answer I wanted, but thanks people. :)
07:36:12 <vixey> what's the definition of ND?
07:36:24 <vixey> could you maybe put Ord into that?
07:36:47 <jynxzero>   7 instance Monad ND where
07:36:48 <jynxzero>   8   return a = ND $ Set.singleton a
07:36:48 <jynxzero>   9   a >>= b =
07:36:48 <jynxzero>  10     ND $ Set.unions $ map
07:36:48 <jynxzero>  11       ( valuesS . b )
07:36:50 <jynxzero>  12       ( valuesL a )
07:37:07 <jynxzero> (Trying to make a monad that deals with non-deterministic values by putting them all in a set)
07:37:14 <byorgey> yeah, a Set monad, thought so =)
07:37:21 <vixey> I mean ND though, not Monad ND
07:37:47 <jynxzero> Oh, it's just
07:37:48 <jynxzero> data ND a = ND (Set a)
07:37:55 <vixey> so what about
07:38:03 <jynxzero> I appreciate this has probably all been done before, I'm experimenting/learning.
07:38:10 <vixey> data ND a = ND (Set a) deriving Ord
07:38:17 <vixey> or something like that
07:38:26 <vixey> (that might not compile.. actually)
07:38:53 <byorgey> even if it did, that's not the same thing
07:39:09 <byorgey> the problem is that to construct a (Set a), a needs to be Ord
07:39:20 <byorgey> but there's no way to express that restriction when making an instance of Monad
07:39:56 <jynxzero> Yeh, doesn't help vixey... I can't make that declaration but still not put things into the set inside.
07:40:05 <vixey> ok
07:43:04 <byorgey> jynxzero: this has definitely been discussed a bunch, try searching the haskell list archives on gmane for "restricted monad" or something like that
07:43:12 <byorgey> @go making set a monad
07:43:13 <lambdabot> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
07:43:13 <lambdabot> Title: How to make Data.Set a monad
07:43:27 <jynxzero> Awesome, ta muchly.
07:43:33 <byorgey> there's also that blog post, a bit dated now, but it gives a good intro to some of the issues involved
07:43:54 <byorgey> and for practical use you should definitely get the rmonad package, it's pretty neat =)
07:52:49 <hpaste>  bonus pasted "euler 59" at http://hpaste.org/7942
07:57:39 <Bonus> :X
07:57:48 <Bonus> guilty as charged!
07:57:54 <opqdonut> :)
07:58:29 <mauke> that's what [X] announce does
07:59:30 <Bonus> aaah
07:59:48 <Bonus> i thought that if you didnt announce it that it didnt put it up on the listing on the site
08:03:31 <hpaste>  (anonymous) pasted "buggy TGA writter" at http://hpaste.org/7943
08:22:51 <vincenz> @seen newsham
08:22:51 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
08:23:37 <vincenz> Anyone know what patch to apply to get lambdabot to work?
08:23:38 <mauke> preflex: seen newsham
08:23:38 <preflex>  newsham was last seen on #haskell-blah 8 hours, 58 minutes and 7 seconds ago, saying: BourBaki
08:25:26 <twobitwork> @seen dons
08:25:27 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
08:25:33 * twobitwork kicks lambdabot 
08:25:38 <twobitwork> preflex: seen dons
08:25:38 <preflex>  dons was last seen on #haskell 10 hours, 9 minutes and 19 seconds ago, saying: No instance for (Show (IO ())
08:32:23 <vincenz> @quit
08:32:27 <vincenz> @bot
08:33:20 <mauke> @seen lambdabot
08:33:24 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
08:34:46 <vincenz> corrupt database?
08:36:20 <orbitz> wheee, i can turn a string into a huffmancode
08:47:12 <byorgey> congrats
08:47:18 <byorgey> =)
08:47:50 <vixey> > reverse [1..]
08:47:50 <lambdabot> Terminated
08:47:52 <vixey> > reverse [1..]
08:47:53 <lambdabot> Terminated
08:48:02 <vixey> aww
08:48:02 <byorgey> > 1 + 2
08:48:04 <lambdabot>  3
08:48:21 <bugQ> vixey: thought you could get to infinity that easily? ;)
08:48:25 <byorgey>  [..1]
08:48:45 <twobitwork> is anyone else having problems downloading hs-plugins from the ftp site?
08:48:56 <twobitwork> ftp://ftp.cse.unsw.edu.au/pub/users/dons/hs-plugins/hs-plugins-0.9.10.tar.gz
08:49:07 <byorgey> > reverse "[1..]"
08:49:08 <lambdabot>  "]..1["
08:49:16 <twobitwork> seems like its just hung when issuing the PASV command
08:49:27 <twobitwork> >reverse [1..]
08:49:31 <twobitwork> > reverse [1..]
08:49:33 <Deewiant> > reverse [1..1]
08:49:36 <lambdabot>  [1]
08:49:38 <lambdabot> Terminated
08:49:40 <twobitwork> heh
08:50:30 <twobitwork> reverse ['a'..'z']
08:50:32 <twobitwork> > reverse ['a'..'z']
08:50:33 <lambdabot>  "zyxwvutsrqponmlkjihgfedcba"
08:50:40 <vixey> > reverse' [1..]
08:50:42 <lambdabot>  [infinity - 1,infinity - 2,infinity - 3,infinity - 4,infinity - 5,infinity -...
08:50:47 <trez> > head . reverse . reverse $ [1..]
08:50:53 <lambdabot> Terminated
08:51:29 <byorgey> vixey, hehe =)
08:58:19 <christastrophe> hmm. is Control.Monad.State no longer the proper import for using StateT? ghc 6.8.2 seems to not like it
08:59:55 <dolio> It should be.
09:01:28 <hpaste>  christastrophe pasted "Control.Monad.State error" at http://hpaste.org/7944
09:02:21 <dolio> That says that it can't find Control.Monad.State
09:02:32 <christastrophe> i know.
09:02:40 <dolio> Do you not have mtl installed, perhaps?
09:02:50 <christastrophe> hmm. I'll check
09:03:20 <MyCatVerbs> It's possible to have more than one version of a library installed with ghc-pkg, right? Some random thing is demanding X11-1.3.0 but everything else wants X11-1.4.1, but it's not a problem to install both?
09:04:06 <dolio> Yeah, I think it's okay.
09:04:12 <MyCatVerbs> Spiffy.
09:04:47 * MyCatVerbs makes a mental note to compare the interfaces for 1.3.0 and 1.4.1, haddock against :browse, to work out which is pulled up by default.
09:04:51 <christastrophe> dolio: that was the problem
09:05:06 <christastrophe> thanks
09:05:12 <dolio> No problem.
09:05:30 <BMeph> dolio++
09:05:35 <BMeph> :)
09:06:16 <MyCatVerbs> Oh, the Hell. Damn Ubuntu.
09:06:36 <MyCatVerbs> Why the Heck does this distro have to be simultaneously so great and also such a huge pain in the butt? Argh.
09:07:26 <Mr_You> its better than most linux distros ;-)
09:08:01 <MyCatVerbs> Mr_You: that's what makes the blatant failures even -more- chafing.
09:08:07 <BMeph> ...at certain desired operations.
09:08:41 <BMeph> It's inconsistently inconsistent... ;)
09:10:54 <MyCatVerbs> And of course apt dumps basically no information whatsoever upon failure...
09:12:54 <vixey> that paper Exploring the Regular Tree Types is totally amazing
09:15:21 <MyCatVerbs> Oh and dammit, what kind of git uses clone(2) instead of fork(2) to spawn a child process? That's just mean and gratituous.
09:19:34 <byorgey> vixey: which one is that?
09:20:03 <vixey> this one http://www.cs.nott.ac.uk/~pwm/papers/regular.pdf
09:20:13 <vixey> I was trying to do something a bit like that
09:20:22 <vixey> but of course they do it 1000x better :p
09:20:49 <byorgey> looks interesting
09:20:51 * byorgey goes off to read
09:21:21 * vixey is reading all Morris' papers today :p
09:26:48 <vixey> what are strictly positive types in haskell?
09:27:14 <vixey> data Foo a = a -> a is not one?
09:27:25 <vixey> or is it something totally different
09:32:18 <vixey> perhaps I should implement CHR in haskell
09:32:53 <pjdelport> vixey: yeah, that isn't strictly positive
09:34:06 <ddarius> :t Ord a => Show a => a -> a
09:34:11 <lambdabot> parse error on input `=>'
09:34:17 <ddarius> :t Ord a => (Show a => a -> a)
09:34:19 <lambdabot> parse error on input `=>'
09:34:32 <ddarius> :t undefined :: Ord a => Show a => a -> a
09:34:34 <lambdabot> parse error on input `=>'
09:34:41 <ddarius> :t undefined :: Ord a => (Show a => a -> a)
09:34:43 <lambdabot> forall a. (Show a, Ord a) => a -> a
09:35:21 <quicksilver> vixey: no negative occurences of parameters
09:35:36 <vixey> A negative occurence is on the left of an -> ?
09:35:37 <byorgey> which is negative and which positive, again?  I forget
09:35:49 <quicksilver> negative is on the left of a ->, yes.
09:36:05 <quicksilver> but (a -> r) -> r is positive (in a)
09:37:14 <byorgey> dons: w00t!
09:37:44 * byorgey grumbles something about #xmonad and irssi
09:38:20 <Igloo> Who runs lambdabot these days?
09:38:29 <MyCatVerbs> For some Foo of kind * -> *, Foo is positive in a if you can write a function foomap :: (a -> b) -> Foo a -> Foo b. Foo is negative in a if you can write a function antifoomap :: (a -> b) -> Foo b -> Foo a, righ?
09:38:33 <MyCatVerbs> Igloo: Cale, I think.
09:38:50 <Igloo> Thanks
09:42:06 <byorgey> MyCatVerbs: I think that's right.  Hence positive and negative correspond to covariant and contravariant functors?
09:43:18 <MyCatVerbs> byorgey: I couldn't formalize it offhand, but to me if looks like they're exactly the same thing.
09:43:57 <byorgey> more specifically, it sounds like a type constructor Foo :: * -> * is a functor iff it is strictly positive, and a covariant functor iff it is strictly negative.
09:44:51 <MyCatVerbs> Like you could write instance ContraFunctor ((->) a) where antiFmap = flip (.) and instance Functor ((Flip (->)) a) where fmap = (.)
09:45:11 <byorgey> right
09:45:13 <MyCatVerbs> (Modulo I might have gotten one of those "flip"s the wrong way around. _)
09:45:53 <MyCatVerbs> It seems like an oversight to me that type Flip f a b = f b a -- isn't in the standard libraries somewhere, maybe even the Prelude.
09:46:31 <gal_bolle> putting it into the prelude would yield weird error messages when typoing Flip for flip
09:46:45 <byorgey> well, I'm not sure how useful it would be.  Even if it was I don't think you could actually declare an instance like  instance Functor ((Flip (->)) a)
09:46:56 <byorgey> could you?
09:46:59 <vixey> I would rather have <- defined
09:47:13 <vixey> then couldn't you write ((<-)a) instead
09:47:26 <byorgey> sure
09:47:33 <vixey> type level sections would be good too, (-> a) and (a ->)
09:47:34 <byorgey> but <- is already used syntactically for other things =(
09:47:53 <vixey> I think it would be ok since <- is used in the value syntax but not currently in the type syntax
09:48:06 <byorgey> true, maybe it would work
09:48:06 <vixey> I should really actually write this parser I keep thinking about sometime :`
09:58:18 <twobitwork> the RWH site doesn't seem to be accepting comments today...
09:58:51 <MyCatVerbs> gal_bolle: you have a point. That would be craaaaaazy.
09:59:23 <jgrimes> what is the best way to get the number and type of a function's arguments?
09:59:39 <vixey> :t <function>
09:59:40 <lambdabot> parse error on input `<'
10:01:06 <jgrimes> I meant like in haskell, a function that would return a list of the types of the function's arguments
10:02:31 <BMeph> jgrimes: Look at Data.Typeable.
10:02:55 <Saizan> jgrimes: if you want something like that you're probably trying to do something the wrong way
10:04:16 <byorgey> jgrimes: OOC, what exactly are you trying to do?
10:04:52 <jgrimes> a rough sketch of what I had in mind was like: map render [somefunctions]
10:06:19 <Saizan> > (+) :: Int -> Int
10:06:21 <lambdabot>  Couldn't match expected type `Int'
10:06:29 <jgrimes> mostly to do with the rendering of functions, given some function I want to display a form that has fields for each of its arguments
10:06:30 <Saizan> > (+) :: Int -> Int -> Int
10:06:32 <lambdabot>  <Int -> Int -> Int>
10:07:48 <jgrimes> I think Data.Typeable has what I want
10:08:39 <jgrimes> thanks.
10:09:07 <MyCatVerbs> Is there anybody about fluent in HGL, please?
10:09:25 <MyCatVerbs> I need a quick example to paste into ghci to make sure my installed copy is working (for various bad reasons).
10:10:42 <MyCatVerbs> Ah, heheheh, linker errors.
10:10:49 <MyCatVerbs> Moral of the story, don't fuck with ghc-pkg.
10:13:06 <sclv_> jgrimes: you can peform induction over the structure of functions with typeclasses, which is sort of elegant actually, once you get your head around it.
10:13:15 <sclv_> quickcheck does this, for example.
10:14:27 <sclv_> (nb: if your result of the function you pass in can be anything, you may need to force it into, e.g., a newtype, to keep the typechecker from getting confused)
10:15:32 <jgrimes> sclv_: oh really. That sounds interesting. Perhaps I'll have a look at quickcheck, then. :)
10:18:20 <sclv_> its a pretty nifty idea actually -- combining this with some generics tricks we could probably knock out a nice looking thing similar to python's newforms library.
10:22:22 <christastrophe> I
10:22:50 <christastrophe> bah
10:23:56 <christastrophe> in the small time I've been working with haskell, I've noticed that I need to take two approaches to desining code
10:24:29 <christastrophe> one is a very bottom-up approach, where I can build small pure functions that can compose nicely
10:24:47 <gubagem> how do i get a series of io code to evaluate just to a list
10:24:58 <christastrophe> and the other is this hairy top-down approach where I need to figure out what state and IO I will need right up front, and then figure how I will thread them down into the program
10:25:27 <christastrophe> the second path of thinking feels very foreign to me
10:25:51 <christastrophe> does anyone else have simmilar (or better) approaches with their haskell code?
10:26:26 <gubagem> I kind of approach right now from a scheme perspective, doesnt make small beautiful code but it works
10:26:35 <gubagem> i just pass state around from function to function
10:26:48 <EvilTerran> there's a paradigm for working with monad transformers that encapsulates the behaviour nicely, so you can add a layer without everything breaking
10:26:57 <EvilTerran> plus your code using the monad isn't littered with lifts
10:27:29 <BMeph> EvilTerran: Got a reference? ;)
10:27:48 <christastrophe> but even then it feels like you have to plan out what parts will need to interact with the monad and which wont right up front
10:28:00 <EvilTerran> BMeph, um... i can't remember
10:28:49 <christastrophe> threading state through seems well and good, but when you start wanting to make long running processes or processes with multiple threads, well (I guess thats not simple in any language really)
10:28:50 <EvilTerran> but i mean wrapping the fully-transformed monad in a newtype, writing boilerplate for each of the transformers' methods that you need, and only exporting the type abstractly and the lifted methods from that module
10:30:09 <christastrophe> thats not an approach Im very familliar with, are there examples you might be able to point me to?
10:30:21 <BMeph> Hmm, so you still Use lifts, you just keep them in the back with the rest of the auxiliary functions.
10:30:28 <EvilTerran> exactly
10:30:58 <EvilTerran> afraid not, christastrophe. as i said, i can't remember where i saw this.
10:31:36 <gubagem> what would the function/type declaration be for something that takes no inputs and returns a list of [a]
10:31:52 <christastrophe> well, maybe you can clear up some of your meaning. what exactly is a fully-transformed monad?
10:33:38 <Saizan> EvilTerran: it was in Cale's wiki, iirc
10:33:57 <vixey> gubagem :: [a]
10:34:13 <vixey> gubagem or :: [[a]] depending on what you meant
10:34:26 <gubagem> vixey: so : name-of-function::[a]
10:34:37 <gubagem> and if i know the type i can be more explicit, correct?
10:34:38 <EvilTerran> christastrophe, i mean your monad built from many monad transformers that has all the functionality you need
10:35:31 <dons> Cale, blog is full of such lovely connections between
10:35:31 <dons> functional programming and mathematics: it is a
10:35:36 <dons> grr.
10:35:44 <dons> Cale, et al, http://msfp.org.uk/
10:35:45 <lambdabot> Title: Mathematically Structured Functional Programming 2008
10:37:11 <bos> wonderful conor quote: http://reddit.com/info/6l4oo/comments/
10:37:52 <dons> mm
10:38:21 <christastrophe> EvilTerra: so just something like: newtype Foo m a = State m a
10:38:28 <dons> a) its awesome sigfpe got invited to be a workshop based on his blog. b) conor is awesome.
10:38:44 <bos> dan is really nice in person, too.
10:38:54 <jgrimes> sclv_: I think quickcheck is just the example I was looking for. Thanks
10:39:09 <dons> we don't get to meet too many celebs up here in the northwest, bos :)
10:39:22 <gubagem> can i have a do block using the IO monad evaluate to [a]??
10:39:31 <bos> ha, you've got a bunch of them in-house, quit complaining.
10:39:34 <bos> :-)
10:39:43 <Deewiant> gubagem: only with unsafePerformIO
10:39:45 <byorgey> gubagem: no, only to IO [a]
10:39:49 <dons> hehe
10:40:02 <EvilTerran> christastrophe, something like "newtype MyMonad a = MyMonad (ErrorT String (StateT Int IO))"
10:40:11 <EvilTerran> er, that's not quite right
10:40:19 <EvilTerran> newtype MyMonad a = MyMonad (ErrorT String (StateT Int IO) a)
10:40:35 <byorgey> gubagem: but supposing you have  foo :: IO [a], you can do something like  do { xs <- foo ; return (pure-function-on-[a] xs) }
10:40:54 <byorgey> and then pure-function-on-[a]  will simply take an argument of type [a]
10:41:05 * BMeph watches bos to see if he starts acting too... "jiggery-pokery." ;)
10:41:30 <EvilTerran> then you export a load of MyMonad actions that're the required functionality of ErrorT, StateT, and IO that have the appropriate lifts and newtype wrapping/unwrapping
10:42:25 <EvilTerran> @@ and runMyMonad :: MyMonad a -> (@unmtl ErrorT String (StateT Int IO) a)
10:42:25 <lambdabot>  and runMyMonad :: MyMonad a -> Int -> IO (Either String a, Int)
10:42:45 <EvilTerran> hehehe
10:43:00 <EvilTerran> @bot
10:43:00 <lambdabot> :)
10:43:08 <christastrophe> EvilTerran: meaning handler that handle the boiler plate of getting to the correct monad you wish to be working in
10:43:28 <christastrophe> 'handler that handle' now thats one of my better uses of english :/
10:43:30 <EvilTerran> indeed
10:43:56 <EvilTerran> which means all of the fragile internals of the monad are now safely bundled up in a module and an abstract type
10:44:28 <EvilTerran> so you can add a transformer, or re-order them, or replace StateT with RWST, or whatever, and that's the only module you have to fix
10:45:03 <christastrophe> thats a nice clean approach
10:45:09 <EvilTerran> indeed
10:46:40 <christastrophe> I think I might try adopting that approach
10:48:03 <christastrophe> it certainly seems like it would be useful when managing nested layers of state...
10:48:22 <EvilTerran> definitely
10:48:51 <EvilTerran> although those can also be expressed as a state tuple, unless there's another transformer between the two layers that affects the state behaviour
10:49:23 <christastrophe> the layering of monads still feels like a black art to me
10:50:08 <christastrophe> im working on porting a project of mine from python to haskell (it makes extensive use of lazy generators in python which it why haskell seems like a good fit)...
10:50:23 <christastrophe> of course python is abusively mutable :)
10:50:55 <gubagem> im porting my last java project from cs2 to haskell, i want to see what the size in code reduction is
10:51:01 <gubagem> it was like 450 lines in java
10:51:03 <christastrophe> which is where the impedance mismatch is occurring as I try to rework bits into haskell forms
10:53:02 <Philippa> christastrophe: you'll get used to layering transformers. I've got a reasonable rule of thumb for ordering if you're finding that hard, btw?
10:53:14 <christastrophe> i'd love to hear it.
10:53:19 <byorgey> so would I =)
10:53:34 <BMeph> It's like Monad T's and worker-wrapper's rambunctious love child. ;)
10:54:53 <Philippa> christastrophe: it's about 'rule precedence'. The rules of the monad at the bottom of the stack have precedence over everything else
10:55:01 <Philippa> which is why there's no IOT - you can't override the laws of physics
10:55:11 <Philippa> then each layer has precedence over those above
10:55:28 <Philippa> so you layer stuff based on which you want to have precedence when they interact
10:55:46 <sclv_> oh hey, yeah. that's a very nice way to think of it.
10:55:49 <Philippa> ErrorT (State) if you want 'exceptions' to leave the state intact, StateT (Error) for the other way round
10:56:13 <christastrophe> what about things like STM and State?
10:56:30 <sclv_> christastrophe: STM needs to be a base monad.
10:56:38 <hoelzro> is there a monadic equivalent to ($)?
10:56:46 <sclv_> State is just like in the above its the "effect" of a context.
10:56:47 <Philippa> christastrophe: If there's no transformer you've got no choice, simple as that. State's got a transformer variant, ST hasn't
10:56:49 <christastrophe> ah. so STM is physics! :)
10:57:05 <Philippa> it's not, but it's something you're not allowed to mess with
10:57:32 <sclv_> well, it sort of is -- its a strict subset of IO
10:57:33 <Philippa> likewise ST - a transformer version of ST would look very different because it'd have to allow for 'branching heaps' and the like
10:57:54 <sclv_> (with some extra properties guaranteed)
10:57:58 <Philippa> sclv: it isn't the same way, it's possible to envisage a pure implementation of STM
10:58:15 <mar77a> > max []
10:58:16 <Philippa> more importantly, one that doesn't need a World value
10:58:17 <lambdabot>  <[()] -> [()]>
10:58:21 <mar77a> > maximum []
10:58:23 <lambdabot>  Exception: Prelude.maximum: empty list
10:58:26 <byorgey> hoelzro: there's 'ap'
10:58:29 <sclv_> Philippa: one that operates across threads??
10:58:31 <mar77a> @src maximum
10:58:31 <lambdabot> maximum [] = undefined
10:58:31 <lambdabot> maximum xs = foldl1 max xs
10:58:35 <byorgey> hoelzro: or <*> if you only need an applicative functor
10:58:38 <byorgey> @type ap
10:58:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:58:55 <byorgey> @type (<*>)
10:58:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:59:09 <sclv_> (a mock stm would have to do mock scheduling...)
10:59:32 <Philippa> @go poor man's concurrency monad
10:59:34 <MyCatVerbs> sclv_: well, spark off with `par`
10:59:35 <lambdabot> http://citeseer.ist.psu.edu/45878.html
10:59:36 <lambdabot> Title: Functional Pearls: A Poor Man's Concurrency Monad (ResearchIndex)
11:01:32 <sclv_> Philippa: well, that paper still builds its mutable vars on top of IO though.
11:01:46 <christastrophe> so then what happens if you want to, for instance, mix IO and STM with state? ie write a value to disk, and update a pointer in memory to that disk value (but in a State environment so that others can see the change)?
11:02:02 <vixey> http://www.siouxcityjournal.com/articles/2007/12/29/sports/sports/484eb8d5fe0ef14c862573c00015d948.txt
11:02:03 <lambdabot> Title: Sioux City Journal: Morningside women beat Haskell, http://tinyurl.com/5tx2d7
11:02:18 <sclv_> christastrophe: STM is a computation that is "pure" outside of mvars and is called from IO
11:02:25 <sclv_> @hoogle atomically
11:02:28 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
11:02:28 <lambdabot> Control.Exception.NestedAtomically :: Exception
11:02:29 <EvilTerran> hoelzro, depending on what type you want, there's Prelude.(=<<), and Control.Applicative.(<*>) and .(<$>)
11:02:54 <christastrophe> ah so you just stick the MVars in State (rather StateT, wrapped around IO)
11:03:10 <sclv_> christastrophe: MVars aren't stm. they're plain IO.
11:03:21 <christastrophe> well then TVar
11:03:51 <sclv_> right -- there's lots of ways to do it though, depending on the semantics you want.
11:03:59 <hoelzro> EvilTerran: well, I'm writing a sample function to get my feet wet, and all it does it read lines until a blank one is reached
11:04:03 <EvilTerran> @@ (=<<) :: (@type (=<<)); (<*>) :: (@type (<*>)); (<$>) :: (@type (<$>))
11:04:08 <vixey> WHAT
11:04:08 <lambdabot>  (=<<) :: forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b; (<*>) :: forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b; (<$>) :: forall a b (f :: * -> *). (Functor
11:04:08 <lambdabot> f) => (a -> b) -> f a -> f b
11:04:34 <EvilTerran> hm. that's not very legible.
11:04:45 <hoelzro> here's the code: getUntilBlank = { line <- getLine; if line == "" then return [] else return ((:) line) `fmap` getUntilBlank); }
11:04:55 <hoelzro> damn smilies
11:05:06 <vixey> @@ @run (@run tail . replicate 3 $ "+1")
11:05:09 <lambdabot>  ["+1","+1"]
11:05:12 <EvilTerran> (=<<) :: Monad m => (a -> m b) -> m a -> m b; (<*>) :: Applicative f => f (a -> b) -> f a -> f b; (<$>) Functor f => (a -> b) -> f a -> f b
11:05:32 <byorgey> hoelzro: and what's the problem?
11:05:33 <hoelzro> that was a (:)
11:05:44 <EvilTerran> yeah, i got that. no smilies for me! :P
11:05:49 <byorgey> hoelzro: don't worry, it's only your software that shows smilies...
11:05:52 <hoelzro> haha
11:06:06 <hoelzro> well, ghc complains about the else clause
11:06:09 <byorgey> hoelzro: as an aside, you can write (line:) instead of ((:) line)
11:06:12 <christastrophe> what about if you want to share the state amongst threads, is that what ST is for?
11:06:21 <EvilTerran> hoelzro, i think you can drop the "return"
11:06:39 <byorgey> indeed
11:06:43 <hoelzro> Expected type: [String] -> String Inferred: [String] -> [String]
11:06:50 <sclv_> christastrophe: ST is not for concurrency at all.
11:06:56 <Philippa> <sclv_> Philippa: well, that paper still builds its mutable vars on top of IO though. <- yeah, so you're down to ST rather than IO in practice or you can look at building a pure ST implementation
11:06:57 <hoelzro> and dropping the return did it.
11:06:58 <hoelzro> haha
11:07:05 <EvilTerran> ?type fmap -- is the clue
11:07:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:07:07 <sclv_> quite the opposite.
11:07:08 <Philippa> which I've a feeling should be doable by now
11:07:12 <Philippa> though it'd be slow
11:07:26 <Philippa> oh, wait, it's definitely doable if you don't mind using Data.Dynamic
11:07:28 <sclv_> Its if you want mutable variables which are guaranteed *not* to escape the scope of the runST call.
11:07:34 <hoelzro> thanks for the help
11:07:44 <sclv_> (so that you can call out to ST from a pure computation)
11:08:03 <byorgey> hoelzro: (return (line:)) `ap` getUntilBlank  would also typecheck and may be what you were getting at with your original question
11:08:14 <EvilTerran> hoelzro, as the type of (return ...) is already "m a", fmap will return something of "f (m a)". dropping the "return" makes that just "f a".
11:08:18 <byorgey> but in this case (line:) `fmap` getUntilBlank is the same thing and much simpler
11:08:37 <christastrophe> ah so really if you want to share state among threads  you just wrap IO in StateT, then the threads are all running inside the StateT monad right?
11:08:52 <hoelzro> ah
11:08:57 <EvilTerran> hoelzro, and, as every Monad is (well, can be made, and usually is) a Functor, that f can just be the same as m
11:09:24 <EvilTerran> incidentally, the Control.Applicative stuff i mentioned...
11:09:25 <hoelzro> yeah, I get monads, but functors/arrows/other stuff I'm still not clear on
11:09:33 <hoelzro> I guess I need to write more Haskell =P
11:09:36 <EvilTerran> for Monads, (<$>) = fmap, and (<*>) = ap
11:10:09 <EvilTerran> functors are very easy. almost certainly easier than monads, anyway.
11:10:31 <vixey> @instances Functor
11:10:31 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:11:32 <sclv_> (which by the way is a reply to Philippa too -- for I don't think a "pure" ST will get you what you need)
11:12:19 <sclv_> christastrophe: sharing state between threads should be done with MVars or maybe TVars
11:12:57 <sclv_> you can "hide" those inside a ReaderT or whatever, but you'll need to use them in the end.
11:13:17 <sclv_> ?hoogle forkIO
11:13:18 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
11:13:18 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
11:13:38 <sclv_> ^^ when you fork a thread it needs to be a pure IO action with no surrounding transformers.
11:14:01 <dons> doesn't lambdabot have some cunning MonadIO forkIO?
11:14:06 <sclv_> On the other hand, you can unwrap yr. state, then fork a thread whose first call is runState... to pass the state back through.
11:14:26 <christastrophe> sclv_: I could put them in the environment of the StateT as well couldn't I?
11:14:37 <dons> forkLB :: LB a -> LB ThreadId
11:14:38 <dons> forkLB f = (`liftLB` f) $ \g -> do
11:14:38 <dons>             forkIO $ do
11:14:38 <dons>                 timeout (15 * 1000 * 1000) g
11:14:40 <dons> ah
11:14:50 <kiris> @src LB
11:14:51 <lambdabot> Source not found. Maybe if you used more than just two fingers...
11:14:57 <sclv_> christastrophe: sure. but your runState would need to be "inside" the forkIO call.
11:14:59 <dons> lambdabot state monad
11:15:06 <kiris> ah
11:15:14 <dons> liftLB :: (IO a -> IO b) -> LB a -> LB b
11:15:14 <dons> liftLB f = LB . mapReaderT f . runLB
11:15:15 <sclv_> dons: nice.
11:15:21 <dons> turns an LB thingy into an IO thingy
11:15:27 <dons> so you can get at it for forkIO
11:15:42 <dons> that code was a few years ago.
11:16:09 <dons> but i wonder if we can factor it out into a usable forkIO-for-other-monad-stacks..
11:16:10 <sclv_> I imagine the semantics only work really rationally for ReaderT though... (or, I suppose, MaybeT)
11:16:11 <bos> you can do the same thing with STM.
11:16:48 <dons> sclv_: hmm, yes, i think that was the issue.
11:16:53 <EvilTerran> you could make instances work for StateT with a get and put, and probably for ErrorT as well
11:17:05 <sclv_> atomically can be generalized over anything that gCatch can be
11:17:08 <christastrophe> i need to start playing around with StateT and forkIO to get the semantics down, I've got some good ideas where to start now
11:19:23 <vincenz> dons: hey, what do I do to get rid of  "hClose" error when asking my lambdabot to eval something?
11:19:52 <Cale> vincenz: Does runplugs work on its own?
11:20:14 <vincenz> ah
11:20:19 <vincenz>     Failed to load interface for `Control.Parallel':
11:20:30 <Cale> there you go :)
11:20:30 <dons> install the parallel library
11:20:51 <vincenz> why isn't that a cabal-dep then?
11:21:32 <dons> it is, afaik.
11:21:35 <EvilTerran> actually, that StateT one clearly wouldn't work, because then you'd end up with two threads sharing a state
11:21:39 <dons> it it in mine,                      parallel, numbers
11:21:51 <dons> maybe you've an older copy?
11:22:00 <vixey> yeah I read about regular tree types that was really good
11:22:11 <vincenz> dons: "cabal install lambdabot"
11:22:15 <vixey> but strictly positive families is completely baffling
11:22:20 <vixey> I don't understand this at all
11:22:45 <dons> yeah, its not listed as a dep on the released lambdabot
11:22:46 <Cale> Oh, heh, I don't know if anyone has been keeping the hackage version up to date. Certainly not me :)
11:22:48 <vincenz> dons: new ystem, downloaded + installed everything today
11:22:53 <dons> i guess gwen didn't know what he was doing..
11:23:11 <dons> note that the one on hackage doesn't actually build with 6.8
11:23:21 <dons> according to the build log, nor was it released by lambdabot maintainers
11:23:24 <Deewiant> is there any pure(-ish) image manipulation library? just input is fine for my purposes... Hackage has Imlib and SDL-Image but both live in IO which is somewhat annoying
11:23:43 <vincenz> dons: hmm, whoops, running 6.8.2
11:23:51 <vincenz> dons: error now on "ShowQ"
11:24:06 <vixey> does anyone understand strictly positive families
11:24:08 * vincenz has no idea where that package might reside
11:24:25 <Cale> ShowQ is a module that comes with lambdabot
11:24:28 <dcoutts> dons: think of it as gwern's encouragement for you to make a release :-)
11:24:31 <vincenz> odd
11:24:55 <Cale> ./build
11:24:59 <dons> dcoutts: Cale's job now.
11:25:49 <vincenz> Cale: ./buid flakes with missing BotPP
11:25:54 <Cale> hmm
11:25:54 <vincenz> Cale: this is horribly broken :|
11:26:03 <vincenz> Cale: note this is a cabal-install version, not a source install one
11:26:08 <Cale> vincenz: Get the darcs version.
11:26:15 <dons> vincenz: use the darcs version
11:26:18 * vincenz groans
11:26:20 <dons> the released one is marked as broken.
11:26:29 <dons> and as it wasn't released by lambdabot devs, isn't supported
11:26:31 <vincenz> @tell gwern don't release broken packages, thank yoy
11:26:31 <lambdabot> Consider it noted.
11:26:38 <dons> too late.
11:27:04 * bos pokes at the GHC 6.8.3 release candidate
11:27:04 <vincenz> This is a terrible source of inefficiency as every person will be facing the same issues and be wondering "WTF?"
11:27:18 <dons> its encouragement for dcoutts to lock down the hackage auto checking infrastructure
11:27:28 <mm_freak> dons: where do i find UVector?
11:27:38 <dons> code.haskell.org/~dons/code/uvector
11:27:41 <dons> feedback welcome!
11:27:45 <mm_freak> thanks
11:27:52 <dcoutts> heh
11:28:03 <Igloo> Cale: Can you stop lambdabot repeatedly telling me I have the same new messages, please?
11:28:17 * dcoutts bangs the hackage QA drum
11:28:22 <Cale> Igloo: I'm not sure why it'd be doing that...
11:28:30 <dons> Igloo: when do you need candidate testing by?
11:28:50 <Igloo> Cale: I'm assuming that each time it is restarted it has forgotten that I've read them
11:28:52 <dcoutts> it happens quite often
11:29:03 <dcoutts> I presume it's because the state file gets lost and rolled back to an older version
11:29:13 <Igloo> dons: The sooner you test, the greater the likelihood that bugs you find will be fixed
11:29:24 <dons> lambdabot has an ad hoc implementation of happs' state/macid check pointing thing
11:29:40 <dons> Igloo: right, but when is too late? or is this unknown?
11:29:50 <bos> Igloo: if i run into build problems, what's the best way to ensure that patches get into final 6.8.3?
11:33:30 <zerny> what would be an easy (quick-and-dirty is ok) way to load an image in haskell? Gtk.Gdk.Pixbuf? I just need to read gray scale values from an image.
11:36:27 <vincenz> scripts/BotPP.hs:21:17:
11:36:27 <vincenz>     Could not find module `Data.ByteString.Char8':
11:36:27 <vincenz>       it is a member of package bytestring-0.9.0.1, which is hidden
11:36:37 <vincenz> dons: that's while installing from darcs
11:37:51 <roconnor> @type swap
11:37:55 <lambdabot> Not in scope: `swap'
11:38:00 <roconnor> @hoogle swap
11:38:01 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
11:38:01 <lambdabot> Control.Concurrent.STM.TMVar.swapTMVar :: TMVar a -> a -> STM a
11:38:04 <Igloo> dons: It depends on how many things are reported, whether builds go through, etc
11:38:10 <Igloo> bos: File a bug
11:39:33 <CosmicRay> Does anyone know of either a) QuickCheck code to test functions that operate on Maps, or b) QuickCheck code to operate on functions that take lists of unique elements (where no element appears more than once)?
11:41:09 <dons> CosmicRay: hmm? you want generators for unique lists?
11:41:19 <CosmicRay> dons: yes, either that or maps.
11:41:38 <CosmicRay> Arbitrary instances, specifically, I guess.
11:41:49 <dons> so I think the easy way would be to newtype [a] as UniqueList [a]
11:41:54 <dons> then convert to and from a Set
11:42:13 <dons> so you have something like, instance Arbitrary (UniqueList a) where...
11:42:23 <CosmicRay> hrm, I hadn't thought we had Arbitrary instances for Set, looking...
11:42:28 <dons> QC2 has some generators of a similar flavour for NonEmpty lists et al
11:42:34 <dons> no, you'll need to write them
11:42:48 <dons> gimme a sec.
11:42:49 <CosmicRay> ah.
11:43:11 <CosmicRay> yeah I've sorta kludged around that sort of thing (functions that require a nonempty list) by testing for the nonconforming lists and just returning True
11:43:27 <CosmicRay> and I did have the thought of just removing duplicates from the input data before passing it to my test code
11:43:41 <dons> yeah, generally you just enforce the invariant in the generator
11:43:42 <CosmicRay> but the consequences to the thoroughness of the testing concern me
11:45:08 <CosmicRay> I guess I need to read up on generators again.  I did write some Arbitrary instances for ListLike, but it felt like an arcane black art to me
11:45:15 <CosmicRay> the documentation for it is rather sparse
11:45:47 <bos> writing a definition of coarbitrary is the tricky part, because the explanation in the QC manual is completely worthless.
11:46:13 <[Justice]> yeah, i don't think i understand it myself
11:46:19 <dons> oh, its not too hard.
11:46:20 <CosmicRay> bos: glad it's not just me
11:46:20 <bos> actually, i'd extend that criticism to the entire QC manual.
11:46:35 <hpaste>  dons pasted "QC for unique lists" at http://hpaste.org/7946
11:46:41 <dons> CosmicRay: untested, but you get the idea ^
11:46:56 <bos> dons: it's not difficult, it's just explained for someone who already knows what's involved. i hate that kind of documentation.
11:47:02 <dons> yeah
11:47:28 <bos> the GHC manual, by contrast, is a thing of beauty.
11:47:40 <dons> the QC manual doesn't have a maintainer
11:47:43 <dons> QC  itself either.
11:48:06 * dons => lunch
11:48:14 <CosmicRay> dons: that's easy enough, but would result in things tending to be smaller than the maximum size more often than anticipated, yes?   I don't really understand how this sized/choose/vector stuff works together to ask it "OK, I've removed 5 elements, give me 5 more"
11:48:21 <CosmicRay> or maybe I'm being over-paranoid.
11:48:42 <CosmicRay> I suppose I could just tell it to run 200 cases and be well enough off.
11:55:29 <vixey> A Universe of Strictly Positive Families confused me
11:56:14 <mar77a> well i had my calc test today
11:56:30 <byorgey> mar77a: how'd it go?
11:56:32 <mar77a> "find the triangle with the smallest area which is delimited by the x and y coordinates and the line that has a pivot on point (2,3)
11:56:36 <mar77a> couldn't solve that one
11:56:40 <mar77a> did the other 3 though
11:56:55 <mar77a> line as in y = mx+b
11:56:59 <mar77a> i hope i pass :(
11:58:29 <Igloo> Do you mean the x and y axes?
11:59:06 <mar77a> er yeah
11:59:38 <byorgey> area of that triangle would be 1/2 (3 + 2 tan a)(2 + 3 cot a), where a is the angle the line makes with the x-axis, I think
12:00:02 <mar77a> i tried making it a function
12:00:10 <vixey> how did you solve it so fast o_o
12:00:13 <thetallgu1> ?seen conal
12:00:14 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:00:28 <byorgey> I didn't solve it, I just wrote down an expression =)
12:00:52 <roconnor> preflex: seen conal
12:00:52 <preflex>  conal was last seen on #haskell 1 day, 13 minutes and 39 seconds ago, saying: MyCatVerbs: check out the paper
12:00:55 <mar77a> that's the function
12:00:55 <byorgey> then you have to expand that out, differentiate, and set it equal to zero
12:01:02 <mar77a> exactly
12:01:12 <mar77a> well i gave up cause i knew i had done the first 3
12:01:29 <byorgey> mar77a: is what I wrote the same as the function you got?
12:01:30 <dcoutts> @seen waern
12:01:30 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:01:33 <dcoutts> bah
12:01:41 <mar77a> i didn't get that far, sadly
12:01:44 <mar77a> otherwise i would've solved it
12:01:56 <byorgey> I see, oh well
12:02:02 <mar77a> i had problems putting everything with one variable
12:02:20 <mar77a> like all the stuff in one equation
12:02:23 <thetallgu1> roconnor: thanks.  Dead bot?
12:02:51 <roconnor> thetallgu1: I don't know.  I miss the old working lambdabot of last year
12:02:51 <byorgey> it's not dead, just blind
12:02:55 <mauke> preflex: seen waern
12:02:56 <preflex>  waern was last seen on #haskell 32 days, 20 hours, 59 minutes and 10 seconds ago, saying: Saizan: I've done that, but I didn't want to debug that code since it's a bit complex
12:07:04 <vixey> > let q a b c = ((0-b) + sqrt(b*b-4*a*c)) / (2*a) in q (-1) (-4) (4-12/3)
12:07:05 <lambdabot>  -4.0
12:07:27 <vixey> > let x = (-4.0) in 3*x-(6*x)/(2-x)
12:07:29 <lambdabot>  -8.0
12:07:41 <vixey> um...... I guess that -8.0 *isn't* the right answer
12:08:30 <vixey> mar77a: what do you think of tis http://rafb.net/p/1fm2FQ55.txt ~_~
12:09:11 <mar77a> i think i should've tried a bit more before handing in
12:09:50 <vixey> I think I am going to fail this year :/
12:10:17 <mar77a> me too ; ;
12:11:28 <vixey> I really want to know the answer to your question
12:16:55 <mar77a> i'll give it to you when i get my mark, vixey
12:26:29 <byorgey> vixey: isn't A 1/2 of what you have there?
12:26:49 <mar77a> byorgey isn't that problem too hard for my age
12:27:09 <byorgey> mar77a: um... how old are you?
12:27:28 <mar77a> 17 turning 18
12:27:45 <byorgey> no, I don't think it's too hard
12:27:53 <roconnor> wow, it is indeed really easy to get from page to page in wikipedia
12:27:59 <byorgey> but it may or may not be expecting too much depending on what and how you were taught
12:28:05 <roconnor> 3 clicks from B,C,K,W system to Gulf War
12:28:20 <byorgey> roconnor: hehe
12:28:33 <roconnor> B,C,K,W system -> Haksell Curry -> United States -> Gulf War
12:28:38 <byorgey> http://xkcd.com/214/
12:28:38 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
12:32:42 <byorgey> vixey: I think you switched a sign somewhere, when I differentiate your expression for A and solve for 0 I get +4
12:34:57 * Beelsebob ponders if conal is about
12:35:55 <Philippa> mar77a: "for your age" isn't really relevant
12:36:02 <chessguy> good afternoon #haskell folk
12:36:15 <Philippa> most of the people in this chan are smart enough to've done things that aren't meant "for our age" often enough...
12:36:54 * vixey waves hi
12:37:25 * Vq^ greets the wave
12:37:50 * chessguy just got a phone call from....<drumroll please>....Microsoft, wanting to know if i have any interest in working there
12:38:04 <byorgey> and you told them....?
12:38:32 <Vq^> byorgey: he told them he wanted to be on the mspaint team
12:38:38 <vixey> hey microsoft does haskell
12:38:49 <vixey> Vq^: that would be cool!
12:39:06 <byorgey> MSR cambridge is quite different than Microsoft in general. =)
12:39:17 * chessguy dreams up some QC properties for MS Paint
12:39:40 <vixey> chessguy, why did they phone you? I guess they want to use your chess library :p
12:39:46 <chessguy> byorgey:  i made them leave me a voicemail :)
12:39:52 <vixey> (I mean did you apply and what sort of work?)
12:40:01 <chessguy> they just found my resume online
12:40:17 <Deewiant> has anybody managed to get SDL-image to work under Windows? I get link errors when Cabal tries to build it
12:42:00 <chessguy> byorgey:  is cambridge their only research facility?
12:42:27 <byorgey> chessguy: I don't think so, but that's where they (i.e. SPJ) do haskell stuff
12:42:33 <chessguy> yeah
12:42:57 <Cale> Kind of like Xerox and Xerox PARC
12:48:18 <mar77a> well yeah i figured but i think you get my idea
12:55:01 <opqdonut> what was the name of the "even -> (/2); odd -> (+1).(*3)" sequence?
12:55:05 <opqdonut> bouncy or something
12:55:12 <byorgey> hailstone or collatz
12:55:14 <Deewiant> collatz?
12:55:20 <opqdonut> thanks
12:55:23 <Deewiant> yep, collatz: http://en.wikipedia.org/wiki/Collatz_sequence
12:57:29 <chessguy> opqdonut:  whatcha doing with that?
13:00:40 <lilac> chessguy: Cambridge MA or Cambridge UK?
13:00:52 <chessguy> lilac:  hm?
13:00:59 <lilac> MS' research lab.
13:01:02 <chessguy> i believe MSR is in Cambridge UK
13:01:04 <chessguy> but i don't know
13:01:39 <byorgey> UK
13:01:42 <lilac> i know MSR have a lab here in cambridge, but i always imagined it wasn't the only one ;-)
13:01:46 <hoelzro> did the Haskell language rules change regarding instance declaration?  I can't seem to do "instance Foo String where ...", but I could have sworn I had done this before
13:02:00 <lilac> hoelzro: paste?
13:02:01 <kevinu> are there any libraries for loading and rendering 3d models in opengl?
13:02:05 <byorgey> hoelzro: note String is a type synonym
13:02:13 <hoelzro> lilac: one sec
13:02:24 <lilac> hoelzro: nm, byorgey solved it ;-)
13:02:42 <hoelzro> right, but it doesn't work on [Char] either
13:03:24 <lilac> as you were then :)
13:03:44 <byorgey> hoelzro: what's the error you get?
13:04:08 <hpaste>  hoelzro pasted "instance declaration issues" at http://hpaste.org/7947
13:04:39 <hoelzro> both the instance decls for String and (Num a, Show a) don't work
13:04:48 <EvilTerran> hoelzro, does the error mention "overlapping instance declerations"?
13:04:59 <hoelzro> Illegal instance declaration for `Sqlizable String'
13:05:01 <lilac> hoelzro: the last one overlaps with te others
13:05:24 <lilac> at least potentially, i thin
13:05:28 <Peaker> hey, I wanna toy around by creating a toy ray tracer in haskell - I am wondering about a good way to create an image file, is there an easy lib/way to not worry about image encodings?
13:05:39 <EvilTerran> Peaker, use PBM?
13:05:46 <Peaker> EvilTerran, what's PBM?
13:05:49 <hoelzro> I tried commenting out either decl, and the error still comes up
13:05:57 <vixey> sounds like a useful library to write if it doesn't exist
13:06:19 <lilac> hoelzro: can you paste the errors too?
13:06:25 <hoelzro> sure, one sec
13:06:46 <EvilTerran> Peaker, http://en.wikipedia.org/wiki/Portable_pixmap
13:06:58 <hpaste>  hoelzro pasted "instance declaration errors" at http://hpaste.org/7948
13:07:07 <EvilTerran> i think i meant PPM, looking at that
13:07:51 <Peaker> EvilTerran, I'd rather encode something as a Haskell type than as a String or such
13:07:53 <byorgey> hoelzro: it tells you what you need to do in the errors.  use -XTypeSynonymInstances and -XFlexibleInstances.
13:07:54 <Baughn> Peaker: I've got an imagemagick interface I wrote very early here.. somewhere...
13:08:06 <Baughn> Peaker: It's ridiculously slow, but it should be able to get you any format imagemagick supports
13:08:17 <Peaker> Baughn, as a Haskell type, you mean?
13:08:27 <Peaker> Baughn, I want to create an array of pixel colors or so
13:08:34 <Baughn> Peaker: http://brage.info/~svein/repos/imageIO/
13:08:35 <lambdabot> Title: Index of /~svein/repos/imageIO
13:08:38 <EvilTerran> Peaker, oh, right, i thiought you meant writing to files
13:08:42 <hoelzro> ugh...I have to read things more closely...
13:08:44 <hoelzro> thanks everyone
13:08:59 <Baughn> Peaker: It should get you that, alright. It's just horrible otherwise, but it'll let you write image files.
13:09:20 <Peaker> EvilTerran, I want something that is:  [[PixelColor]] -> FileHandle -> IO () or so
13:09:30 <lilac> hoelzro: haskell 98 has all sorts of restrictions which aren't really necessary :)
13:09:33 <Peaker> Baughn, why is it slow, btw?
13:09:53 <Baughn> Peaker: Because I didn't understand either imagemagick, haskell or the FFI at the time
13:10:01 <Baughn> Peaker: In fact, I'll give it to you. Feel free to fix it. ;)
13:10:44 <Peaker> Baughn, thanks :)
13:10:50 <EvilTerran> Peaker, so you *do* want writing to files? i can't think of anything more direct than using a PPM. you'd only convert it to a String for writing the file, you'd use a UArray (Int,Int) RGB or something otherwise
13:11:35 <Peaker> EvilTerran, I haven't used arrays yet, what's a UArray?
13:11:51 <Peaker> EvilTerran, a PPM sounds like I'd have to worry about how I'm encoding it, even if it is a rather simple encoding
13:12:16 <Baughn> Peaker: An UArray is an unboxed (thus space-efficient, and strict) array
13:12:36 <Peaker> An array whose elements are all strict, that is?
13:12:43 <Peaker> (is that what unboxed means here?)
13:13:03 <Baughn> Oh gods, this is old. It won't even /build/
13:13:08 * Baughn fixes it up on general principle
13:13:17 <EvilTerran> as i said, you'd only convert it to PPM for writing. given i'm sure any sane image would have reasonable complexity for reading off pixels line-by-line, it's hardly going to affect encoding within your program
13:13:29 <OltreIrc`33140> ciao
13:13:32 <EvilTerran> *any sane image encoding*
13:13:38 <OltreIrc`33140> !list
13:13:48 <Baughn> Peaker: No, unboxed means the elements are stored directly, like a C array. Its being strict is a mere consequence, since there's no room left for thunks.
13:13:49 <mrd> Peaker: unboxed means that the value is stored directly, there is no indirection or anything going on
13:14:23 <Peaker> EvilTerran, I am sorry if I am nagging, I am just not completely sure what you mean by complexity here - do you mean inherent complexity of iterating lines already is as complex as encoding PPM?
13:15:23 <Peaker> mrd, what indirection is possible except in a thunk?
13:15:34 <EvilTerran> yes. seeing as PPM is just a width, height, and row-by-row list-off of pixels, no compression or anything, writing a PPM is O(width * height) once you've got the pixels out
13:16:00 <mrd> Peaker: well, it could be allocated on the heap, and a pointer stored to it.  there could be tagging of low order bits.
13:16:12 <mrd> those would be boxed representations
13:17:02 <Peaker> mrd, what areas are there except the heap? The GC'd area and a stack?
13:17:53 <mrd> Peaker: the UArray can be allocated on the heap -- the point is that the individual elements are not separately allocated into their own heap spaces
13:18:04 <Peaker> oh, I see
13:18:29 <lilac> mrd: but they might not be anyway
13:18:48 <Peaker> EvilTerran, its not O() I'm worried about, but the amount of reading I'd have to do before I can do it :)
13:18:49 <dons> Peaker: also registers.
13:19:03 <dons> strict things you use often just end up in registers anyway
13:19:13 <Peaker> EvilTerran, or code complexity
13:19:26 <dons> (# x :: Bool, y :: Int# #) -- two register variables.
13:19:40 <lilac> dons: couldn't a lazy thing end up with a pointer to its thunk being held in a register too?
13:20:05 <Peaker> what does the # mean?
13:20:22 <lilac> the # types are ghc's notation for primitive types, like platform ints
13:23:14 <bos> how do i export a darcs patch to a file?
13:23:36 <lilac> darcs help send
13:23:47 <mauke> -o FILE
13:24:48 <dons> lilac: if its lazy. but you can determine the strictness
13:24:56 <dons> bos: darcs send -o /tmp/f
13:25:13 <bos> thanks.
13:25:17 <dons> Igloo: re. portability of ghc. why don't we just have someone at GHC HQ with a linux box with say, 4 vmware images on it
13:25:25 <dons> running 3 bsds and whatever.
13:25:53 <dons> you don't actually need login access to someone else's real openbsd machine anymore. just boot an openbsd iso in vmware on linux
13:26:36 <rumbleca> vmware is expensive?
13:27:28 <Peaker> bochs/qemu/colinux/...
13:28:14 <ironfroggy> is anyone aware of any papers done describing theorms and proofs of logic transformations and assertions?
13:28:31 <Igloo> dons: Mainly because adminning the OSes etc takes time, I suspect
13:28:58 <dons> Igloo: ok. i'll see how hard it is to set up sometime soon.
13:29:19 <Peaker> ironfroggy, I am not sure it is at all interesting to you, but there's "theorems for free" and some extensions to that
13:29:23 <dons> i suspect its less than half a day's work to get basic installs capable of running ghc's testsuite
13:29:31 <Peaker> ironfroggy, (not sure if its the direction you mean)
13:29:32 <dons> i'll stick notes on the wiki
13:29:50 <Igloo> dons: But you have to keep the OSes up-to-date, keep networking working, etc
13:29:54 <Peaker> ironfroggy, its about theorems you get "for free" from Haskell type declarations
13:30:09 <dons> Igloo: nah, 'tis trivial in vmware, you just use the underlying OS, aka linux
13:30:19 <dons> vmware sets up all the NAT and everything
13:30:27 <dons> all you need to do is boot the iso of your distro
13:30:41 <kevinu> maybe they dont want to because it's something which can be offloaded to the community?
13:30:44 <bos> Igloo: here's a pushover for you: http://hackage.haskell.org/trac/ghc/ticket/2314
13:30:46 <lambdabot> Title: #2314 (GHC 6.8.3 release candidate fails to build under glibc 2.8.0) - GHC - Tra ...
13:31:20 <kevinu> does anyone have any knowledge of a haskell library to load and generate opengl commands necessary to render 3d models?
13:31:31 <dons> HOpenGL ?
13:31:39 <dons> or you want something higher level?
13:31:45 <Baughn> Peaker: http://brage.info/~svein/repos/imageIO/ <-- OKay, it doesn't work, but could you try to build it and tell me exactly how it fails for you? (Install imagemagick-dev first)
13:31:45 <mm_freak> @oeis 4 8 15 16 23 42
13:31:45 <lambdabot> Title: Index of /~svein/repos/imageIO
13:31:46 <lambdabot> The Lost Numbers.
13:31:46 <lambdabot> [4,8,15,16,23,42,108]
13:31:48 <kevinu> im talking something that impliments a specific model format
13:31:56 <kevinu> so higher level
13:32:04 <mm_freak> lost?!
13:32:06 <Baughn> Peaker: I've managed to make ghc-asm fall over, apparently
13:32:11 <dons> poke around on the wiki and hackage, kevinu
13:32:17 <Peaker> Baughn, if its very slow maybe I'll just use EvilTerran's suggestion of writing an ASCII file with the numeric RGB values
13:32:26 <Igloo> bos: Thanks! Presumably we could just always defined _GNU_SOURCE, though?
13:32:41 <sclv_> vis a vis vmware: there are generally premade virtual appliance images for most distros these days.
13:32:59 <Baughn> Peaker: It /doesn't build/
13:33:06 <Peaker> Baughn, Yeah that makes it worse :)
13:33:16 <Baughn> Peaker: But the way in which it fails to build make me wonder if it's a bad ghc installation
13:33:18 <dons> sclv_: yeah, exactly. this seems like a really cheap way to test ghc on all the open OSs
13:33:19 <bos> Igloo: perhaps, but i thought it safest to only enable it if needed.
13:33:26 <dons> from a single maintainer's linux box
13:33:38 <ironfroggy> im looking for two sides of something. firstly are theorms that prove transformations of logic that retains the same results and secondly for theorems that prove what state is read and changed. my end goal is developing a set of transformations to convert procedural logic into parallel logic.
13:33:49 <bos> Igloo: for example, _GNU_SOURCE causes glibc to prefer POSIX semantics over BSD semantics where they differ, and i didn't want to go there.
13:33:55 <Peaker> ironfroggy, I think maybe Scala and other languages with "dependent types" also let you prove many aspects of your code correct. One of these languages is not turing complete as it cannot express programs that do not halt (its useful to be able to prove the program always duly finishes)
13:34:27 <Peaker> ironfroggy, what do you mean by parallel logic?
13:34:58 <ironfroggy> which ive already been doing a very small bit of in a little project of mine asserting which python for loops could be theoretically run in parallel
13:35:39 <mehrheit> kevinu: in case you don't find anything, I think writing your own parser for .obj shouldn't be difficult
13:35:53 <Igloo> bos: Better that we should get the same semantics everywhere, as far as possible
13:35:54 <sclv_> Peaker: what do you mean when you say scala has dependent types?
13:35:57 <ironfroggy> Peaker: in this case, if the order of iterations in a for loop is important or not. if its not, then later i can work on dispatching the work to multiple workers and develop an automatically parallel execution system.
13:36:13 <bos> Igloo: you're welcome to simplify the patch, if you like.
13:36:24 <dons> sclv_: oh my, is this another example of "polymorphism" dependent types...
13:36:30 <Peaker> sclv_, I might be confusing it with other languages, I haven't used it :)
13:37:00 <sclv_> dons... thats why I ask...
13:37:16 <Peaker> ironfroggy, in Python - how can you prove that - given dynamic dispatch of the calls within each iteration and their potential side effects?
13:37:51 <rey_> kevinu: the frag game reads quake 3 models and levels
13:38:16 <kevinu> quake3 models do not have skeletal information i believe :(
13:38:40 <kevinu> ive written my own library for loading and rendering quake2 models and quake3 is not too much different
13:38:47 <dons> ironfroggy: so first you identify what loop combinator each loop corresponds to (i.e. is it a map, or a fold, or a filter, or an unfold..), then you can come up with a parallel implementation of the loop spine. next you need to look at the loop body to see if it is actually pure, if not you're fairly stuck.
13:39:13 <dons> sigh, so much easier when you see: map f xs, and all that work is already done.
13:39:28 <sclv_> hmm.. I think scala has something called a "path dependent type" which is where the confusion arises from...
13:39:54 <ironfroggy> yes its that determination of pure that is the key and im working on that problem from a few different angles.
13:40:40 <Peaker> ironfroggy, www.londonhug.net/wp-content/uploads/2007/05/nested-data-parallelism.ppt  -- that might be an interesting read
13:40:58 <ironfroggy> on a bytecode level i can determine it and pure isn't even completely needed, if i can determine that the state affected is not the same state or if i can deduce a way to combine the state changes effectively.
13:41:19 <dons> right, you need to do some effect inference
13:41:20 <ironfroggy> for example, if there is a call to list.append in the body, i can handle that.
13:41:34 <kevinu> hmm actually quake3 looks like it uses md3 and md4 depending on version, i wonder if frag implimented the later as it has skeletal information, i will have to look into it, thx
13:41:45 <ironfroggy> Peaker: thanks. although i hate the idea of "reading" a power point presentation
13:41:53 <dons> ironfroggy: there are many papers on effect inference, worth looking into
13:42:01 <Peaker> ironfroggy, simon peyton jones likes ppt appearantly
13:42:11 <ziman> what's the right way to do (fold min) over a _long_ list?
13:42:16 <dons> doing it in a dynamic context will again be much harder in general, but maybe you can get it working for a small subset of code.
13:42:26 <dons> ziman: minimum ?
13:42:30 <ziman> yes
13:42:35 <dons> > minimum [ 1 .. 10000]
13:42:39 <lambdabot>  1
13:42:46 <dons> ?src minimum
13:42:46 <lambdabot> minimum [] = undefined
13:42:46 <lambdabot> minimum xs = foldl1 min xs
13:42:50 <ziman> i get a stack overflow a the (foldr min) is the main suspect
13:42:51 <ironfroggy> dons: i think that within code that is already subjectively "good", you'll see more of the kind of code that this can be done with than not.
13:42:54 <ziman> oh
13:42:58 <dons> ziman: use minimum :)
13:43:02 <ironfroggy> or, if you can't im interested in transformations that can split a loop into two loops
13:43:03 <ziman> dons, thanks much ;)
13:43:26 <ironfroggy> where the first would be sequencial and the second would not.
13:43:36 <dons> ironfroggy: i guess the main barrier will be reconstructive type and effect information, rich enough to do the analysis
13:43:42 <ironfroggy> but the first would be cheap enough to be worth it and setup the parameters for the second.
13:43:46 <dons> s/reconstructing/
13:43:53 <ziman> hm, stack overflow, still; it wasn't the fold :\
13:44:14 <ironfroggy> i thought about approaching this as transformations on brainfuck code. theoretically, if it works there, it can be applied to any other turing complete language.
13:44:16 <dons> are you running in ghci?
13:44:17 <Peaker> ironfroggy, I went to a lecture of a guy who was researching "code slicing" for a few years -- that is, deducing which code affects which variables/state.   Unfortunately his work isn't on the web, but he had a Java eclipse plugin where you could right click a variable and say "split to method" and it would duplicate the relevant loops/etc so that variable is computed separately in a method
13:44:29 <ziman> no, it's compiled
13:44:36 <dons> ironfroggy: ok. so you should read some papers  on parallelism though...
13:44:43 <sclv_> > minimum [1..1000000]
13:44:45 <lambdabot>  1
13:44:48 <sclv_> > minimum [1..10000000]
13:44:49 <ironfroggy> Peaker: do you have his name?
13:44:50 <lambdabot>  1
13:44:53 <sclv_> > minimum [1..100000000]
13:44:55 <Peaker> ironfroggy, I can look it up
13:45:01 <lambdabot>  1
13:45:03 <ironfroggy> id appreciate that a lot. thanks.
13:45:04 <sclv_> > minimum [1..1000000000]
13:45:15 <lambdabot>  Exception: Time limit exceeded
13:45:20 <dons> minimum should be fine on Integer. try, say, Word32..
13:45:30 * dons bets the strict minimum specialisation fails.
13:45:38 <dons> oh maybe not, actually
13:45:45 <dons> foldl gets strictness analysed these days
13:45:52 <dons> minimum [1..(100000000::Word)]
13:45:59 <dons> > minimum [1..(100000000::Word)]
13:46:08 <lambdabot>  1
13:46:09 <dons> yeah, 'sok.
13:46:09 <Peaker> ironfroggy, http://www.cs.tau.ac.il/~amiramy/SoftwareSeminar/rani.txt
13:46:22 <ironfroggy> Peaker: thanks
13:47:14 <Dzlk> Hm, is HaskellDB not available for 6.8?
13:48:30 <dons> Igloo: note you can also set up vmware machines with multiple virtual cores. might be useful for testing concurrent stuff
13:48:44 <ziman> well, i read some polygon definitions from a file and when I want to find an intersection with a ray, (findNearest . filter satisfiesIntersectCondition . map (findIntersection ray)) I can see the list is non-empty because when I ask only whether an intersection exists, everything's OK; however, when I ask what are coordinates of the intersection, I get a stack overflow; i guess there's some laziness issue
13:53:04 <sclv_> can you set up vmware machines with more cores than you actually have? as I recall, you can set them up with <= actual cores?
13:53:26 <dons> looks like you can.
13:53:31 <roconnor> ziman: sounds nice. ... except for the stack overflow
13:54:59 * roconnor reads back
13:55:13 <Baughn> sclv_: Not vmware. There are tools that let you do that, but then at vastly below realtime
13:56:36 <dons> well, my one core laptop has a vmware that offers 1 or 2 cores.
13:56:56 <sclv_> ziman: findNearest looks like the likely culprit?
13:57:04 <dons> oh, it does offer a warning though.
13:57:19 <dons> yeah,  it didn't like that.
13:57:26 <sclv_> or more likely findIntersection?
13:58:51 <roconnor> @hoogle [a]->Maybe a
13:59:01 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
13:59:01 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
13:59:25 <roconnor> findNearest = listToMaybe . sortBy (???)  ?
14:00:36 <roconnor> vixey: which version of "The View From The Left" did you read?
14:03:07 <ziman> sclv_, findNearest is just the `minimum' function; (thanks to ordering on the Intersection type)
14:03:23 <ziman> but minimum is strict foldl
14:03:30 <gubagem> how do i get over the pain of not having a mutable variable
14:04:29 <twobitwo2k> gubagem: what do you need to mutate?
14:04:40 <gubagem> a list
14:04:52 <twobitwo2k> remember, haskell takes a much different approach to computation in general, and I find it rare that I miss mutating things
14:04:52 <mauke> why do you not have a mutable variable?
14:04:53 <Baughn> gubagem: Why? What are you trying to /achieve/?
14:05:01 <gubagem> but it was getting wrapped in IO and now im coding main and i think i can unwrap it
14:05:03 <mauke> I have lots of them
14:05:32 <roconnor> ziman: what is Intersection?
14:05:34 <gubagem> right now my only method is passing the variable around
14:05:38 <gubagem> set interesection?
14:05:40 <byorgey> gubagem: instead of mutating something, the functional way is to have a function that takes a value (such as a list) and returns a new one
14:06:32 <byorgey> gubagem: instead of thinking of variables just sitting there and you whack on them until they contain the answer you want, think of values flowing through your program, so you transform some input values into a final output value
14:07:10 <gubagem> yes i get that
14:07:18 <gubagem> but what if im mixing in a lot of io
14:07:45 <mauke> then you can just use IORefs
14:07:50 <twobitwo2k> you should only be doing I/O in IO functions... if you're manipulating data, that should be in functions
14:07:55 <twobitwo2k> or that
14:07:58 <gubagem> read file->make data structure out of it->loop over doing some mutates to thing im passing around->save to file on exit
14:08:49 <ziman> roconnor, Intersection is effectively a triple of Doubles (p, q, r); raySource + p*rayDirectionVector = intersectionPoint; (q, r) are the intersection coords within the polygon
14:10:39 <roconnor> ziman: oh, what is your ordering on Intersection?
14:11:24 <ziman> (Intersection p _ _) < (Intersection q _ _) = p < q
14:11:27 <byorgey> gubagem: the reading and writing to the file are the only parts that should involve any IO.
14:11:32 <roconnor> > minumum [1..100000]
14:11:43 <lambdabot>   Not in scope: `minumum'
14:11:48 <roconnor> > minimum [1..100000]
14:11:49 <lambdabot>  1
14:11:52 <gubagem> oh im mutating my pass around list using user input
14:11:53 <ziman> (there are only positive p's there, it's been already filtered)
14:12:01 <gubagem> so im guessing that needs to be IO code as well
14:12:10 <roconnor> > (range (1,1000) (1,1000))
14:12:11 <lambdabot>  Couldn't match expected type `(t1, t2) -> t'
14:12:14 <byorgey> gubagem: you could do something like this:  do { text <- readFileContents; saveToFile (process text) }
14:12:28 <roconnor> > (range ((1,1000),(1,1000)))
14:12:30 <lambdabot>  [(1,1000)]
14:12:32 <byorgey> gubagem: readFileContents will be :: IO String, and saveToFile will be  :: String -> IO ()
14:12:39 <roconnor> > (range ((1,1),(1000,1000)))
14:12:40 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
14:12:44 <byorgey> gubagem: but process will be a pure function :: String -> String
14:12:47 <roconnor> > minimum (range ((1,1),(1000,1000)))
14:12:49 <lambdabot>  (1,1)
14:13:14 <byorgey> gubagem: and then you can break down process further, into functions which parse the string, make a data structure, process it, and turn it back into a string
14:13:20 <byorgey> and there will be no IO in sight.
14:13:25 <sclv_> ziman: shot in the dark, but make Intersection a strict data type?
14:13:26 <twobitwo2k> how do you get the bot to tell you what module a function is in agian?
14:13:45 <Toxaris> byorgey: but that doesn't help gubagem with it's userinput problem
14:13:53 <gubagem> i think i can work around it
14:14:00 * roconnor ponders ziman's stack overflow
14:14:01 <sclv_> ?hoogle listToMaybe
14:14:03 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
14:14:09 <sclv_> twobitwo2k: ^^
14:14:10 <Toxaris> aeh, sorry, his or her
14:14:13 <twobitwo2k> ?hoogle range
14:14:14 <lambdabot> Data.Ix.range :: Ix a => (a, a) -> [a]
14:14:14 <lambdabot> Language.Haskell.TH.Range :: data Range
14:14:14 <lambdabot> Language.Haskell.TH.Syntax.Range :: data Range
14:14:21 <gubagem> im trying to recode my last java project into haskell and see how much saving in lines of code i get
14:14:30 <byorgey> oh, gubagem, does the "loop over it..." part involve user input?
14:14:34 <gubagem> it was like 400-450
14:14:35 <gubagem> yea
14:14:48 <roconnor> @src minimum
14:14:48 <lambdabot> minimum [] = undefined
14:14:48 <lambdabot> minimum xs = foldl1 min xs
14:14:50 <gubagem> like the whole thing pretty much runs on state and io
14:14:55 <Toxaris> gubagem: often it works to write a pure function per "elementar operation" the user can select
14:15:11 <twobitwo2k> @src range
14:15:11 <lambdabot> Source not found. That's something I cannot allow to happen.
14:15:21 <Toxaris> gubagem: and then have a "main program" in IO which asks the user something, applies some pure function, asks again
14:15:25 <gubagem> are exceptions/errors hard to handle in haskell?
14:15:46 <twobitwo2k> gubagem: use Either or Maybe
14:16:01 <gubagem> then use a conditional to check the result if not loop(recurse again)
14:16:03 <gubagem> ?
14:16:07 <roconnor> ziman: what happens when you do minimum . (map (\Intersection x _ _ -> x)) ?
14:16:12 <twobitwo2k> use pattern matching
14:16:14 <roconnor> (out of curiosity)
14:16:50 <roconnor> ziman: (if you can perform the experiment)
14:17:39 <quicksilver> ow. programming with VBOs turns haskell into a dangerous language
14:17:45 <twobitwo2k> VBO?
14:17:54 <quicksilver> make a typo or two and you can corrupt your screen or hard-lock your computer
14:18:03 <quicksilver> Vertex Buffer Object
14:18:20 <Toxaris> gubagem: there are operators for often needed combinations like "try this, if it worked, feed its output to some function" (>>=) or "try this, if it fails, do something else" (<|>).
14:18:21 <quicksilver> this is surely Apple's fault rather than haskell's really. But still scary.
14:18:51 <Toxaris> gubagem: actually these operators are very abstract and can mean a lot of things, but for Maybe, that's what they do
14:19:20 <twobitwo2k> @src (>>=)
14:19:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:19:26 <twobitwo2k> heh
14:19:52 <twobitwo2k> I guess it doesn't look up instance methods
14:20:00 <mauke> @src Maybe (>>=)
14:20:00 <lambdabot> (Just x) >>= k      = k x
14:20:01 <lambdabot> Nothing  >>= _      = Nothing
14:20:26 <hpaste>  jdrake annotated "else syntax error" with "euler problem 1, needs vetting" at http://hpaste.org/7936#a1
14:20:27 <twobitwo2k> @src Either (>>=)
14:20:27 <lambdabot> Left  l >>= _ = Left l
14:20:27 <lambdabot> Right r >>= k = k r
14:20:54 <jdrake> Can anyone look at that and tell me suggestions for improving it? I believe I don't have proper tail call recursion going, but I can't think of how to fix it.
14:21:11 <Toxaris> gubagem: so you don't have to check for errors at each step, but can postpone error checking to some location where you really care
14:21:25 <mauke> bonus question: why can't you just write x@(Left _) >>= _ = x?
14:21:33 <dons> jdrake: its not tail recursive, of course.
14:21:40 <dons> its guarded recursion under a constructor
14:21:45 <quicksilver> jdrake: [] ++ is a bit daft :)
14:21:46 <dons>    m : multiplesOf n (m - 1)
14:22:11 <twobitwo2k> mauke: no idea
14:22:18 <jdrake> quicksilver: It is the only way I could think of :-)
14:22:29 <twobitwo2k> mauke: I will say that the former is clearer, imo
14:22:47 <jdrake> I suppose I can get rid of that altogether quicksilver?
14:22:59 <quicksilver> jdrake: right.
14:23:04 <mauke> if you switch the two cases, you could even write Right r >>= k = k r; err >>= _ = err
14:23:08 <quicksilver> jdrake: "[] ++ x" is just "x"
14:23:10 <mauke> except that doesn't work :-)
14:23:25 <jdrake> Ok, now how do I make this thing a proper tail recursive call?
14:23:29 <quicksilver> jdrake: for whatever "x"
14:23:30 <quicksilver> you don't.
14:23:36 <quicksilver> it's not going to be tail recursive
14:23:37 <mauke> the answer is: the two 'Left l' in the source above have different types
14:23:40 <quicksilver> it's not that kind of algorithm.
14:23:42 <jdrake> hmm
14:23:44 <lilac> jdrake: you can make it 'properly' tail recursive, by passing the result so far to it. but that makes it worse.
14:23:58 <jdrake> So is what I did here not bad then?
14:24:10 <twobitwo2k> mauke: how?
14:24:14 <lilac> jdrake: as far as i understand things, in haskell, you want to produce as much of the result as you can, as early as you can.
14:24:16 <Toxaris> mauke: oh good point, they belong to different Rights :)
14:24:27 <mauke> Toxaris: Right
14:24:41 <gubagem> if the user input is an error i need to prompt and grab input again
14:24:47 <ziman> roconnor, wow, it printed the numbers
14:24:55 <jdrake> lilac: There is other ways of doing the result other than how I did it (ones that don't involve lists), but I didn't know about them then.
14:25:02 <twobitwo2k> how does it "belong to different Rights"?
14:25:13 <roconnor> ziman: okay.
14:25:18 <twobitwo2k> l has the same type on both ends...
14:25:20 <thetallgu1> anyone know what version of haddock will (not) be bundled with ghc 6.8.3?
14:25:25 <mauke> twobitwo2k: yes, but not Left l
14:25:27 <lilac> jdrake: the recursion looks fine to me (apart from the []++) but the algorithm is suspect
14:25:42 <roconnor> ziman: I think one solution is to add strictness to your Intersection type
14:25:45 <mauke> twobitwo2k: actually, l is irrelevant. we can do the same thing with the Maybe instance
14:25:46 <roconnor> @src Complex
14:25:47 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
14:25:48 <jdrake> lilac: I would love to hear alternatives :-)
14:25:51 <ziman> roconnor, it's already strict
14:25:56 <ziman> it didn't help
14:26:02 <roconnor> crap
14:26:04 <Toxaris> twobitwo2k: look at the type of >>=
14:26:06 <jdrake> Nevermind, I think I know another way of doing it
14:26:07 <mauke> twobitwo2k: Nothing >>= _ = Nothing {- ok -};  x >>= _ = x {- type error -}
14:26:10 <lilac> jdrake: how would you compute a list of multiples of n by hand? :-)
14:26:24 <ziman> but the " minimum . (map (\Intersection x _ _ -> x))" trick helped
14:26:25 <jdrake> lilac: Adding would be the most direct method
14:26:36 <ziman> i guess it must be the other coords
14:26:36 <jdrake> I don't know why I chose this method actually
14:26:38 <roconnor> ziman: yeah, but that is sucky
14:26:45 <twobitwo2k> Toxaris: ahh... that clarifies...
14:27:08 <roconnor> @hoogle minimumBy
14:27:15 <lambdabot> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
14:27:15 <lambdabot> Data.Foldable.minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
14:27:16 <twobitwo2k> first argument is 'm a' but result is 'm b'
14:27:29 <roconnor> ziman: I suppose you could try minimumBy
14:27:33 <jdrake> I will try to fix it, but for now, my dinner is almost ready. Thank you for the help friends.
14:27:34 <Toxaris> twobitwo2k: not sure whether you mean that ironically or not
14:27:40 <twobitwo2k> Toxaris: no.....
14:27:45 <twobitwo2k> Toxaris: am I still confused?
14:27:49 <roconnor> ziman: I'm still disturbed that you are having a stack overflow with your lovely code.
14:27:58 <twobitwo2k> :t (>>=)
14:28:08 <Toxaris> twobitwo2k: no not at all, I hadn't seen your explaining message, sorry
14:28:13 <lambdabot> thread killed
14:28:28 <twobitwo2k> Toxaris: you said look at the type of >>=, and I did, and it seemed to make sense, but now I'm not sure again :P
14:28:55 <lilac> jdrake: functionally, it's fine of course. in terms of asymptotical runtime, it's fine too. but when i looked at it, it took me a while to convince myself that it wasn't doing something more cunning; the more 'obvious' algorithm might be clearer. :)
14:29:03 <mauke> left side is Nothing :: Maybe a, right side is Nothing :: Maybe b
14:29:10 <mauke> a and b can't be unified
14:29:13 <twobitwo2k> right
14:29:29 <ziman> roconnor, i'll try
14:29:49 <mauke> Nothing and Left x are polymorphic values
14:30:16 <twobitwo2k> yeah, I see
14:31:02 <twobitwo2k> the type definition is "m a -> ... -> m b" because the instance implementation could return something of a different (sub?)type
14:31:42 * edwardk waves hello.
14:31:46 <Toxaris> twobitwo2k: no the user of >>= chooses the type
14:31:56 <Toxaris> twobitwo2k: by providing an appropriate f
14:32:03 <jdrake> lilac: I am not quite capable of anything cunning, at least while knowing it :-)
14:32:09 <twobitwo2k> ahhhhhhh
14:32:10 <twobitwo2k> yep
14:32:11 <twobitwo2k> I see
14:32:28 <Toxaris> twobitwo2k: so the "type change" is handled by f in the Just / Right case
14:32:49 <twobitwo2k> becuase I could have: Just 4 >>= (\x -> Just "asdf")
14:32:57 <Toxaris> twobitwo2k: exactly
14:33:03 <lilac> jdrake: have you heard of 'pattern guards'?
14:33:15 <jdrake> lilac: Heard of them, yes, only seen ocaml examples.
14:33:27 <twobitwo2k> I think I'm having that moment of zen people talk about when grokking monads
14:33:28 <Toxaris> twobitwo2k: actually, that's what you have all the time. the monad stays the same, but the concent changes
14:33:35 <jdrake> By the way, is there any good article on haskell and tail call recursion? Something that sort of puts the mind in the correct frame to think about when doing things such as this?
14:33:37 <twobitwo2k> yeah
14:33:39 <lilac> hmm, actually, i think the best way of doing what you want is simpler than i was about to say
14:33:54 <twobitwo2k> I thought I understood them last week, but just now it all seemed to crystalize :)
14:34:07 <jdrake> lilac: in a few minutes, I will give you my new code :-)
14:34:08 <ziman> roconnor, works!!
14:34:10 <ziman> folly
14:34:13 <ziman> *fully
14:34:14 <twobitwo2k> Toxaris: thanks! :)
14:34:17 <roconnor> ziman: :/
14:34:24 <roconnor> ziman: I don't get why it didn't work before.
14:34:28 <ziman> the question is now, why
14:34:31 <lilac> jdrake: multiplesOf n m = [n,n+n..m]
14:34:31 <twobitwo2k> and mauke, thanks for bringing up the question :)
14:34:42 <jdrake> lilac: hmm?
14:35:01 <lilac> jdrake: haskell has a neat notation for enumerated values (like integers).
14:35:15 <jdrake> Is it possible to do multiline comments?
14:35:23 <Toxaris> twobitwo2k: your welcome. I have a somewhat secret theory that you can explain all of monads and similiar stuff by saying "look at the type of ..."
14:35:24 <lilac> jdrake: {- yes \n -}
14:35:24 <dons> {- foo  -}
14:35:47 <jdrake> gedit doesn't syntax highlight those
14:35:54 <twobitwo2k> Toxaris: yeah... but I've seen docs that show lots of type definitions, but I guess it was premature for me
14:36:08 <lilac> jdrake: [a..b] translates to something like enumFromTo a b, which gives you all values from a to b.
14:36:15 <twobitwo2k> Toxaris: the key was when you said "f" determines the type...
14:36:29 <twobitwo2k> christ, its past quittin' time... gotta go
14:36:30 <Toxaris> twobitwo2k: yes, "look at all types at once" is bad :)
14:36:39 <roconnor> ziman: you could try adding (Intersect a b c) < (Intersect d e f) | a `seq` b `seq` c `seq` d `seq` e `seq` f  `seq` False = undefiend
14:36:43 <roconnor> to your old cold
14:36:43 <twobitwo2k> thanks again, and see ya later
14:36:49 <Toxaris> twobitwo2k: I wonder why I didn't said "look at the type of f" :)
14:36:55 <roconnor> to see if strictifying all the elements helps
14:37:03 <jdrake> This is so annoying, any ideas on why it keeps doing this? > euler1  (\n) Interrupted.
14:37:04 <roconnor> ziman: to your old code
14:37:05 <lilac> jdrake: likewise, there's [a..] (potentially infinite) and [..a] (enumFrom and enumTo, IIRC)
14:37:37 <roconnor> ziman: be sure that that line comes before your real definition.
14:37:38 <jdrake> lilac: Now that is certainly cleaver
14:38:01 <roconnor> ziman: it really shouldn't make a difference if Intersect is already strict.
14:38:05 <roconnor> like you say
14:38:12 <lilac> jdrake: [a,a+b..n] is the list which goes [a,a+b,a+2*b,a+3*b, (and so on)] (finishing at the last value of the form a+k*b <= n)
14:38:20 <roconnor> ziman: I'm just shooting in the dark here
14:38:54 <lilac> jdrake: so [1,3..] is all odd numbers, and [n, n+n .. m] is all positive multiples of n <= m.
14:39:22 <bugQ> > [a,a+b..n]
14:39:24 <lambdabot>  Exception: not a number
14:39:26 <roconnor> ... how can minimumBy work, but what you have not work.
14:39:30 <roconnor> @src minimumBy
14:39:30 <lambdabot> Source not found. My brain just exploded
14:39:39 <roconnor> @hoogle minimumBy
14:39:39 <lambdabot> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
14:39:39 <lambdabot> Data.Foldable.minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
14:39:48 <roconnor> @src Data.List.minimumBy
14:39:48 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:40:40 <lilac> jdrake: re the "Interrupted." thing, i don't know why it's getting interrupted, or what by (you're not hitting Ctrl-C are you?)
14:41:00 <jdrake> lilac: Nope, it just is doing it (quite often)
14:42:31 <lilac> jdrake: incidentally, your euler1 loop would be quicker if you did something like: euler1 = sum $ filter (\a -> (a `mod` 3 == 0) || (a `mod` 5 == 0)) [1..999]
14:42:50 <lilac> > sum $ filter (\a -> (a `mod` 3 == 0) || (a `mod` 5 == 0)) [1..999]
14:42:51 <lambdabot>  233168
14:43:34 <Toxaris> be aware of the project euler secret police :)
14:43:36 <lilac> @pl (\a -> (a `mod` 3 == 0) || (a `mod` 5) == 0)
14:43:36 <lambdabot> ap ((||) . (0 ==) . (`mod` 3)) ((0 ==) . (`mod` 5))
14:43:43 <lilac> :(
14:43:49 <Vulpyne> The goggles, they do nothing.
14:44:03 <Toxaris> lilac: maybe any helps?
14:44:15 <andreas_> hi, how can I create a data that is a subset of Char, that is a data that is oneof 'a'..'z'?
14:45:08 <lilac> > filter (any (map mod [3,5])) [1..20]
14:45:09 <lambdabot>  Couldn't match expected type `Bool' against inferred type `a -> a'
14:45:44 <ziman> roconnor, stack overflow with the `a `seq` b `seq` c `seq` d `seq` e `seq` f  `seq` False = undefiend' && no minimumBy
14:45:57 <roconnor> ziman: good
14:46:02 <roconnor> that should have been the same
14:46:09 <jdrake> I think I will start on #2, and come back to #1 in about an hour
14:46:16 <Toxaris> lilac: oh sorry, any is the other way around
14:46:29 <jdrake> This is certainly good language instruction :-)
14:46:32 <roconnor> @src min
14:46:32 <lambdabot> min x y = if x <= y then x else y
14:47:01 <lilac> Toxaris: i think any works, but building a list of ((0==) . mod 3), ((0==) . mod 5) is ugly
14:47:21 <Toxaris> :t any
14:47:22 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:47:35 <lilac> hmm, ok, right you are ;-)
14:47:36 <hpaste>  dons pasted "euler1 fusion" at http://hpaste.org/7949
14:47:52 <Toxaris> :t or
14:47:54 <lambdabot> [Bool] -> Bool
14:48:12 <roconnor> ziman: can you paste your Ord instance?
14:48:12 <Toxaris> to be combined with list applicative functor for easy creation of the two-element list of predicates?
14:48:30 <hpaste>  dons annotated "euler1 fusion" with "rem v mod" at http://hpaste.org/7949#a1
14:48:35 <lilac> dons: mmm, unboxing
14:50:01 <lilac> dons: doesn't ghc's strictness analysis do much the same anyway?
14:50:11 <hpaste>  dons annotated "euler1 fusion" with "and the C backend." at http://hpaste.org/7949#a2
14:50:25 <hpaste>  ziman pasted "Ord Isect" at http://hpaste.org/7950
14:50:31 <dons> lilac: nope. you've got to loop fuse the call to sum
14:50:37 <ziman> roconnor, ^^
14:50:51 <dons> note the 4x speedup switching from ghc 6.8 with -fasm to 6.9 with -fvia-C
14:51:10 <dons> actually, just -fvia-C is enough
14:51:15 <ziman> (there are multiple numbers but I only Debug.Trace.trace the first one)
14:51:34 <lilac> dons: surely sum . filter fuses?
14:51:47 <dons> lilac: not under build/foldr fusion.
14:51:53 <dons> very few consumers do.
14:52:05 <lilac> @src filter
14:52:05 <lambdabot> filter _ []     = []
14:52:06 <lambdabot> filter p (x:xs)
14:52:06 <lambdabot>     | p x       = x : filter p xs
14:52:06 <lambdabot>     | otherwise = filter p xs
14:52:07 <dons> you'll get the same good result with stream fused lists
14:52:21 <dons> ?src sum
14:52:21 <lambdabot> sum = foldl (+) 0
14:52:28 <dons> foldl isn't foldr fusible
14:52:35 <roconnor> @src cmp
14:52:36 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:53:03 <tieTYT2> if i'm not using a let/where, can I put a newline anywhere as long as I indent it?
14:53:06 <dons> so these little one liners ending with sum will uniformly do better with a foldl-fusing optimisation, than without
14:53:11 <monochrom> <3 lazy evaluation
14:53:32 <lilac> dons: does ghc not do any kind of foldl fusing then?
14:53:33 <dons> > 0.065 / 1.248 * 100
14:53:35 <lambdabot>  5.208333333333334
14:53:39 <roconnor> ziman: that isn't a complete definition of an Ord instance
14:53:49 <dons> lilac: right.
14:53:59 <dons> lilac: ghc uses build/foldr fusion for lists.
14:53:59 <roconnor> ziman: you are getting recursion between the default implmenations
14:54:07 <roconnor> ziman: you need to defined either (<=) or compare
14:54:12 <roconnor> ziman: I recommend defining compare
14:54:20 <lilac> dons: presumably it's easy enough to add foldl/filter fusing using ghc's pattern matching magic?
14:54:27 <mauke> tieTYT2: if you're not using a let/where/do/of, you can put a newline anywhere, period
14:54:27 <dons> nope.
14:54:30 <lilac> ;(
14:54:45 <dons> you can use the stream-fusion package for left-fold fusible lists
14:54:50 <dons> or uvector for fusible arrays
14:54:55 <dons> so at least we're not tied down.
14:55:02 <dons> as external libraries can use their own optimisation systems
14:55:21 <ziman> roconnor, clear! thanks!
14:55:28 <lilac> what goes wrong if you try to do left-fold fusing? does ghc not spot that it can apply the rule?
14:55:29 <roconnor> Haskell could use formal notation in classes to declare minimum required definitions, so that we can get errors or warnings if improper instances are made.
14:55:53 <dons> lilac: try to write foldl using only foldr
14:56:00 <dons> its doable, but not efficient.
14:56:12 <lilac> even preserving non-strictness?
14:56:30 <dons> iirc, yes.
14:56:36 <lilac> yow.
14:56:43 <BMeph> lilac: the main thing is, the folding function has an awkward type for currying.
14:56:56 * lilac is still trying to figure out the zip from foldl magic
14:57:11 <BMeph> ..or, I could be completely missing the issue (and likely am, but I think it helps me think about the issue).
14:57:17 * Mr_You opens GHCi for the first time.
14:58:56 <lilac> i don't really understand how ghc applies its fusion rules. i've seen various things saying "here's the syntax for specifing them" and "here's the performance boost i got" but nothing saying "it doesn't work in these cases" or "here's how it works under the hood" :(
14:59:36 <bugQ> Does anyone know Yampa? how awesome is it, and it what general ways?
14:59:54 <monochrom> Presumably the syntax also says when they are invoked.
15:00:00 <sclv_> http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
15:00:06 <lambdabot> Title: Correctness of short cut fusion - HaskellWiki, http://tinyurl.com/23j3w3
15:01:22 <BMeph> bugQ: I'm pretty sure conal had some familiarity with it... ;)
15:03:05 <dons> lilac: read the build/foldr fusion paper
15:03:15 <dons> which describes the rewrite rules that enable loop fusion for lists, currently
15:03:28 <dons> or the stream fusion paper, which describes how loop fusion works in uvector
15:10:51 <RayNbow> @djinn (a -> b -> c) -> (a, b) -> c
15:10:51 <lambdabot> f a (b, c) = a b c
15:13:47 <Elly> what does @djinn do? generate a function with the given type?
15:14:08 <elliottt> Elly: yep :)
15:14:11 <elliottt> if it can.
15:14:48 <Elly> @djinn a -> b
15:14:49 <lambdabot> -- f cannot be realized.
15:14:53 <Elly> smart :)
15:15:00 <monochrom> No recursion in code or type, e.g., no list.
15:15:28 <Elly> @djinn a -> [a]
15:15:28 <lambdabot> -- f cannot be realized.
15:15:30 <mauke> @djinn [a] -> ([a] -> [b]) -> [b]
15:15:30 <lambdabot> f a b = b a
15:15:34 <Elly> aw :(
15:15:47 <Elly> @djinn a -> a
15:15:47 <lambdabot> f a = a
15:17:03 <dmwit> ?djinn g :: a -> a
15:17:03 <lambdabot> Cannot parse command
15:17:37 <mauke> @free g :: a -> a
15:17:38 <lambdabot> f . g = g . f
15:22:17 <dmwit> What if f isn't strict?
15:23:42 <mauke> then the theorem doesn't hold
15:37:59 <jdrake> Should it take any time at all to calculate fibonacci numbers in excess of index 30? I find it takes significant time, even though I am not sure it should.
15:38:29 <Elly> are you using the naive algorithm?
15:39:02 <Japsu> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 30
15:39:03 <lambdabot>  832040
15:39:08 <jdrake> Elly, if that is the one that is easiest derived :-)
15:39:15 <Japsu> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
15:39:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
15:39:24 <Elly> if you are, you may want to consider the runtime (and memory use) of that algorithm :P
15:39:51 <dolio> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 30
15:39:53 <lambdabot>  832040
15:41:07 <int-e> (that took  fib 31 - 1  additions to compute)
15:41:11 <jdrake> Wikipedia has a formula using 
15:41:40 <jdrake> What is the origin of of that formula?
15:42:37 <jdrake> > let fib 0 = 0 ; fib 1 = 1 ; fib n = fib (n-1) + fib (n-2) in fib 50000
15:42:47 <lambdabot>  Exception: Time limit exceeded
15:43:04 <jdrake> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
15:43:05 <lambdabot>  354224848179261915075
15:43:11 <jdrake> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 1000
15:43:13 <lambdabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
15:43:16 <int-e> jdrake: diagonalization of the matrix F = (1,1;1,0) (you have (f_n, f_n+1) = (1,0) F^n
15:43:49 <int-e> (f_n+1, f_n) I guess.
15:43:49 <jdrake> diagonalization?
15:44:25 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 50000
15:44:27 <lambdabot>  1077773489307297478027903885511948082962510676941157978490230921003274473536...
15:44:35 <int-e> http://en.wikipedia.org/wiki/Diagonalizable_matrix
15:46:57 <dolio> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 5000000
15:47:02 <lambdabot>  Exception: stack overflow
15:47:30 <ddarius> dolio: You need to force the elements as you go along.
15:47:37 <dolio> I know.
15:48:01 <dolio> Just wanted to see if the GHC lambdabot was running had magically improved since I last looked.
15:48:29 <int-e> jdrake: the idea is to find sequences of the form  a_n = k^n  that satisfy  a_n = a_(n-1) + a_(n-2), and then express the fibonacci sequence as a linear combination of these. The amounts to solving k^2 = k + 1; phi is one of the roots of that polynomial.
15:49:41 <BMeph> int-e: phi-1 is the other, right? :)
15:49:57 <Japsu> > let fibs = iterate (\(x,y) -> (y, x+y)) (1,1) in snd (fibs !! 30)
15:49:58 <lambdabot>  2178309
15:50:02 <Japsu> > let fibs = iterate (\(x,y) -> (y, x+y)) (1,1) in fst (fibs !! 30)
15:50:04 <lambdabot>  1346269
15:50:05 <int-e> jdrake: If you abstract from that idea, you'll end up with matrix diagonalization, or more generally, the Jordan normal form of a matrix.
15:50:05 <Japsu> hmm
15:50:12 <Japsu> > let fibs = iterate (\(x,y) -> (y, x+y)) (0,1) in fst (fibs !! 30)
15:50:13 <lambdabot>  832040
15:50:23 <Japsu> > let fibs = iterate (\(x,y) -> (y, x+y)) (0,1) in fst (fibs !! 5000000)
15:50:26 <lambdabot>  Exception: stack overflow
15:50:28 <Japsu> bah.
15:50:29 <Japsu> ;<
15:50:56 <ddarius> Japsu: It's exactly the same problem as dolio's example
15:51:21 <Japsu> yeah
15:52:25 <ddarius> @let xs !!! 0 = head xs; (x:xs) !!! n = x `seq` (xs !!! (n-1))
15:52:29 <lambdabot> Defined.
15:52:51 <int-e> BMeph: 1-phi
15:52:56 <ddarius> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !!! 5000000
15:52:57 <monochrom> Two bangs are not enough for strictness. Need three. :)
15:52:59 <lambdabot> Terminated
15:53:02 <ddarius> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !!! 500000
15:53:05 <lambdabot> Terminated
15:53:07 <ddarius> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !!! 50000
15:53:09 <lambdabot>  1077773489307297478027903885511948082962510676941157978490230921003274473536...
15:53:14 <ddarius> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 50000
15:53:16 <lambdabot>  1077773489307297478027903885511948082962510676941157978490230921003274473536...
15:53:23 <ddarius> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100000
15:53:28 <lambdabot> Terminated
15:53:35 <ddarius> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !!! 100000
15:53:38 <lambdabot>  out of memory (requested 1048576 bytes)
15:54:09 <jdrake> What is the difference between !! and!!!?
15:54:28 <jdrake> @src !!
15:54:29 <lambdabot> xs     !! n | n < 0 = undefined
15:54:29 <lambdabot> []     !! _         = undefined
15:54:29 <lambdabot> (x:_)  !! 0         = x
15:54:29 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:54:32 <jdrake> @src !!!
15:54:33 <lambdabot> Source not found. Take a stress pill and think things over.
15:54:35 <BMeph> int-e: Right, thanks. :)
15:54:54 <sjanssen> jdrake: ddarius defined it above, it forces each element of the list in order
15:55:14 <jdrake> sjanssen: is the other out of order?
15:55:35 <sjanssen> jdrake: !! doesn't force the elements of the list at all
15:56:00 <jdrake> I am unsure what is meant
15:56:11 <sjanssen> in the fibs example, this results in a massive thunk (exponential in size, as we might expect)
15:56:21 <monochrom> http://www.haskell.org/haskellwiki/Stack_overflow  has an explanation.  It talks about scanl, but same issue with !!
15:56:22 <lambdabot> Title: Stack overflow - HaskellWiki
15:56:51 <monochrom> Next year I should add !! to it.
15:57:05 <sjanssen> > fibs = x : (x+1) : zipWith (+) fibs (tail fibs) in fibs
15:57:05 <lambdabot>  Parse error at "=" (column 6)
15:57:13 <sjanssen> > let fibs = x : (x+1) : zipWith (+) fibs (tail fibs) in fibs
15:57:14 <lambdabot>  [x,x + 1,x + (x + 1),x + 1 + (x + (x + 1)),x + (x + 1) + (x + 1 + (x + (x + ...
15:57:48 <sjanssen> > let fibs = 0 :: Expr : 1 : zipWith (+) fibs (tail fibs) in fibs
15:57:49 <lambdabot>  Parse error at ":" (column 22)
15:57:57 <sjanssen> > let fibs = (0 :: Expr) : 1 : zipWith (+) fibs (tail fibs) in fibs
15:57:58 <lambdabot>  [0,1,0 + 1,1 + (0 + 1),0 + 1 + (1 + (0 + 1)),1 + (0 + 1) + (0 + 1 + (1 + (0 ...
15:58:53 <monochrom> Correction: It talks about last, but same issue with !!
16:01:19 <sjanssen> > let fibs = (0 :: Expr) : 1 : zipWith (+) fibs (tail fibs) in fibs !! 10
16:01:20 <lambdabot>  0 + 1 + (1 + (0 + 1)) + (1 + (0 + 1) + (0 + 1 + (1 + (0 + 1)))) + (1 + (0 + ...
16:03:01 <lilac> dons: thanks for the fusion reference. my head now hurts ;-)
16:03:25 <monochrom> Then you should write "dons: thanks for the confusion" :)
16:03:39 <lilac> ;-)
16:04:24 * monochrom tries to invent something and call it co-fusion.
16:04:36 <dolio> fission?
16:04:36 * olsner simultaneously thinks of co-fusion :P
16:04:36 <ddarius> fission already exists.
16:04:44 <ehird> .
16:04:48 <ehird> also
16:04:50 <ehird> something about fission
16:05:15 <monochrom> Perhaps applying fusion laws to co-data is co-fusion.
16:05:23 * lament tries to invent something and call it pulation
16:05:33 <sjanssen> @seen byorgey
16:05:33 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:05:38 <sjanssen> bwa?
16:05:39 <sjanssen> @flush
16:05:43 <sjanssen> @seen byorgey
16:05:43 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:05:52 <olsner> out of disk?
16:05:55 <ehird> Lawl.
16:05:55 <ddarius> @seen sjanssen
16:05:56 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:05:57 <ehird> @seen lambdabot
16:05:57 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
16:06:01 <ehird> @hoogle a -> a
16:06:02 <lambdabot> Prelude.id :: a -> a
16:06:02 <lambdabot> Data.Function.id :: a -> a
16:06:02 <lambdabot> GHC.Exts.breakpoint :: a -> a
16:06:05 <ehird> Hm,
16:06:08 * lilac tries to invent something and call it mmorpgism
16:06:10 <ehird> @quote a
16:06:11 <lambdabot> LoganCapaldo says: for I am become fixpoint, ender of functions
16:06:17 <int-e> > let go 0 = (0,1); go n = let (a,b) = go (n`div`2) in if even n then (2*b*a-a*a, a*a+b*b) else (a*a+b*b, 2*a*b+b*b); fib n = fst (go n) in fib 1000000
16:06:18 <sjanssen> olsner: nah, just corrupted state.  It happens too often
16:06:18 <lambdabot>  1953282128707757731632014947596256332443542996591873396953405194571625257887...
16:06:43 <lament> it's buggy because it's written in haskell
16:09:13 * ehird predicts lament's next line: "lisp and python are so much better"
16:09:13 <olsner> heretic! burn him!
16:09:38 <dolio> C++ is so much better.
16:09:51 <olsner> yeah, C++ has dependent types
16:09:58 <ehird> dolio: actually, lament has argued lisp&python>haskell in #esoteric before
16:10:06 <ehird> olsner: obqwe1234?
16:10:26 <dolio> Yeah, I still haven't decided whether I agree with that or not.
16:10:33 <lament> i can't believe i ever argued lisp is better than haskell
16:10:35 <lament> that's just nuts
16:10:44 <olsner> ehird: no, C++?
16:10:48 <sjanssen> olsner: you're joking, right?
16:10:57 <ehird> olsner: 'C++ has dependent types' is a qwe1234 saying
16:11:09 <dolio> It may have dependent types, but they're fairly crappy dependent types.
16:11:16 <ehird> it is, of course, incorrect - he uses things like type-level peano numerals to justify it
16:11:26 <dolio> But apparently Dependent ML had rather crappy dependent types, too.
16:11:27 <ehird> and argues against real dependent typing because 'all typing is at compile-time;
16:11:35 <ehird> qwe1234 is not very bright :-)
16:13:36 <olsner> almost nothing about C++'s type system is non-crappy, but types do take (some) values as arguments
16:14:04 <Heffalump> that doesn't make it dependently typed, because the values have to be constant
16:14:07 <ehird> olsner: that's not dependent types
16:14:13 <dolio> Yeah, you can write stuff like 'template <int i> ...'.
16:14:18 <Heffalump> it's just like duplicating those literals in the type system
16:14:24 <ehird> however, you know, C++ template metaprogramming is pretty nice.
16:14:29 <ehird> it's a lazy functional language
16:14:36 <ehird> which is, uh, kinda strongly typed.
16:14:38 <dolio> Yeah, exactly. There's nothing you can do with it that you can't do in haskell with type families.
16:14:39 <ehird> and it's pure, of course.
16:14:49 <Heffalump> ehird: it's dynamically typed
16:14:57 <ehird> Heffalump: no, not really
16:15:01 <tieTYT2> i didn't know there were haskell haters
16:15:02 <dolio> But, apparently, DML only had values indexed by statically known integers, and it got called 'dependently typed'.
16:15:09 <ehird> Heffalump: a template and a regular type are distinguished in template arguments
16:15:14 <ehird> but, 'regular types' are al lthe same type yes
16:15:16 <Heffalump> ehird: it is, you only get errors after template expansion
16:15:19 <ehird> (typename or class or whatever, depending0
16:15:22 <ehird> Heffalump: no
16:15:27 <ehird> template <typename T>
16:15:30 <ehird> pass a template to that and BOOM
16:15:37 <Heffalump> oh, but that's not very strong
16:15:38 <ehird> (Forgot the syntax for actually taking a template, though)
16:15:55 <ehird> Heffalump: it has the regular C++ type system for value arguments, and then (a->b) and *
16:15:57 <ehird> * = typename
16:16:00 <Heffalump> if your template requires T to have some method foo, you only find out post-expansion that the T you passed doesn't have a foo
16:16:02 <ehird> (a->b) = another template - forgot the syntaxx
16:16:09 <ehird> Heffalump: ok, yes, but that's at a lower layer
16:16:13 <ehird> templates aren't concerned with the _result_
16:16:15 <ehird> just themselves
16:16:27 <Heffalump> ehird: that's just kind checking. Not very strong at all.
16:17:18 <ehird> Heffalump: i guess so
16:17:26 <ehird> Heffalump: its all haskell has :)
16:17:26 <olsner> hmm, in Ada, you can make local instantiations of generic packages and types based on run-time values... does that make Ada dependently typed?
16:17:45 <Heffalump> but Haskell also has proper static type checking, one layer down from kind checking
16:17:56 <Heffalump> whereas C++ templates just have dynamic type checking
16:18:08 <monochrom> dynamic typing simply means merging compile time with run time.
16:18:18 <Pseudonym> Heffalump: That's not _entirely_ true.
16:18:29 <Pseudonym> C++ template type checking happens at compile time.
16:18:31 <ehird> Heffalump: No -- Haskell's type system only has kind checking
16:18:31 <ehird> :-)
16:18:54 <Heffalump> Pseudonym: yes, but we were talking about C++ template expansion as being a functional language
16:18:58 <Heffalump> In that context, it's dynamically checked.
16:19:03 <Pseudonym> Ah, right.
16:19:52 <Heffalump> ehird: C++ template expansion has statically checked kinds and dynamically checked types. Haskell has statically checked types and kinds.
16:20:04 <ehird> Heffalump: Dude, I'm talking about Haskell's _type system_
16:20:09 <ehird> haskell's type system only has kinds.
16:20:14 <ehird> so does C++ template metaprogramming
16:20:21 <ehird> so
16:20:21 <ehird> <Heffalump> ehird: that's just kind checking. Not very strong at all.
16:20:23 <ehird> is very silly
16:20:24 <Heffalump> Haskell's type system isn't a functional programming language.
16:20:33 <ehird> Heffalump: Nor is C++'s template metaprogramming.
16:20:36 <ehird> It just happened to turn out that way.
16:20:55 <Heffalump> but it really is possible to view template expansion as functional programming
16:21:17 <ehird> same with haskell's type system
16:21:20 <ehird> it's just not tc, sans ghc exts
16:21:53 * Heffalump doesn't care any more :-)
16:22:17 <dolio> If you're talking about Haskell's type system as a language, it doesn't even have a kind level.
16:22:32 <dolio> Assuming you move everything down one.
16:22:45 <olsner> so, in the type system, kinds are types? :P
16:22:55 <dolio> Or are you not moving things down in C++? I'm not sure.
16:23:12 <dolio> C++ doesn't really talk about kinds, so it's hard to tell.
16:23:41 <Pseudonym> It doesn't use that terminology, but it does have higher-order templates.
16:24:05 <hpaste>  itkovian pasted "Getting stuff out of IO" at http://hpaste.org/7951
16:24:19 <lilac> Heffalump: when you say C++ template expansion has dynamically-checked types, are you thinking of 'later during the same compilation' as the dynamic part?
16:24:29 <Itkovian> Any idea how to rewrite that so it looks cleaner?
16:24:47 * Itkovian fetches power supply before the battery runs out.
16:24:52 <lilac> Heffalump: C++ templates don't have a compile-time versus runtime distinction AFAICS, so i'm not sure what the static versus dynamic distinction would be
16:25:29 <Heffalump> lilac: yes
16:25:42 <lilac> Heffalump: actually, i think i get it. something like...
16:25:44 <Heffalump> in particular static would be flagging errors in unexpanded code, and dynamic would be only flagging them in the expanded code
16:25:54 <lilac> ^^ what you just said.
16:26:08 <lilac> Heffalump: but C++-0x concepts then give it static type checking
16:26:23 <Heffalump> agreed (except I haven't really looked at them myself, but that's what I understand)
16:26:55 <lilac> it's not foolproof (there's still the possibility of runtime (by which i mean at expansion-time) template argument errors)
16:27:27 <Heffalump> that sucks..
16:27:40 <Heffalump> or do you just mean that it can happen if you don't use concepts fully?
16:27:41 <lilac> not any more than 'Prelude.undefined' sucks
16:28:02 <lilac> even with full use of preludes, you can insert a static_assert inside a template which can fail with parameters which meet the concepts
16:28:18 <Heffalump> fair enough
16:28:18 <ehird> Heffalump: it doesn't suck
16:28:26 <Heffalump> I'd say that a type mismatch is worse than Prelude.undefined
16:28:26 <ehird> you shouldn't do too much inside the type system
16:28:28 <ehird> it's zany
16:28:28 <ehird> :)
16:28:30 <Heffalump> but that's just subjective
16:28:46 <lilac> Heffalump: eg, template<int i> class X { static_assert(i >= 0, "i can't be negative"); };
16:29:17 <lilac> which is not really any different from X i | i < 0 = undefined
16:29:26 <Heffalump> yes, fair enough
16:29:41 <lilac> in any case, there's always the possibility of infinite recursion
16:29:51 <ddarius> ehird: Haskell's type system with fundeps and MPTCs is a logic language.  With type families and associated type synonyms and that stuff, it's a functional language.
16:30:06 <ehird> ddarius: MULTIPARADIGM TYPE PROGRAMMING
16:30:19 <lilac> (except that the standard limits how deep implementors are required to expand templates, which i *think* renders it non-turing-complete)
16:30:20 <ehird> Really, the inevitable outcome is a language that is its own type system, to infinite levels.
16:30:25 <ehird> I chatted about something like that recently.
16:30:33 <ehird> It'd lead itself to dependent types, of course.
16:30:46 <ehird> You could write a program which typechecks iff the reimann hypothesis is true, trivially.
16:30:47 <dolio> There are already plenty of languages like that.
16:30:52 <Heffalump> dependent types are different, though related, because they allow bleeding upwards as well
16:30:53 <ehird> test :: if reimann then Int else Str; test = 3
16:31:11 <ddarius> ehird: Just formulating the Riemann hypothesis would not be trivial.
16:31:18 <ehird> ddarius: not my problem
16:31:18 <ehird> :)
16:31:48 <lament> if halts then Int else Str
16:31:54 <ehird> build = build' id where build' k 0 = k []; build' k n = \x -> build' (\xs -> k (x:xs)) (n-1) -- a type for this involves 'fix' on a type lambda I believe
16:32:01 <ehird> build 0 = []
16:32:04 <ehird> build 1 a = [a]
16:32:04 <ehird> etc
16:32:05 <lilac> the main thing that sucks about the c++ template language is the syntax
16:32:59 <ddarius> lilac: One of the very first Haskell programs I wrote was something that would translate a small Haskell like functional language into C++ templates.
16:33:07 <lilac> hmm. X T1 T2 = class { ...
16:33:24 <lilac> ddarius: we obviously think along similar lines ;-)
16:33:27 <ehird> ddarius: Cute, show me!
16:33:34 <ehird> but yeah, I've wanted a hs->C++ before
16:33:39 <ehird> It would be outrageously _awful_
16:33:51 <lilac> with current compilers, it would be outrageously _slow_
16:34:10 <proq> lilac: why is that?
16:34:11 <ddarius> ehird: That was written a long, long time ago.  It's probably turned to bit dust on some harddrive in a garbage heap somewhere.
16:34:25 <ehird> ddarius: Poor thing. :(
16:34:35 <ddarius> ehird: It's stupid easy to do though (at least a simple one).
16:34:37 <lilac> proq: because current compilers are not very fast at expanding templates, sadly. i think g++ is getting better at this, though.,
16:34:38 <ehird> It's still there .. waiting for you ... hoping you'll come back to it and forgive it ...
16:34:49 <ehird> How can you leave it there, ddarius? It thought you loved it.
16:35:17 <lament> yet all it was to ddarius was just some characters on a screen!
16:36:23 <ehird> lament: :'(
16:36:46 <edwardk> ddarius: hrmm, i don't think the relationship I was looking for exists. the relationship I had for 'dual/complementary functors' is weaker than adjunction. Both f -| g and g -| f are sufficient conditions for it.
16:36:52 <thoughtpolice> this is what happens when you give things like programs emotions/feelings. :(
16:36:56 <thoughtpolice> it's how the robot war will start
16:36:57 <lilac> ddarius: You euthanized your faithful hs -> c++ translator more quickly than any test subject on record. Congratulations.
16:37:14 <edwardk> lilac: =)
16:37:28 <lament> the robot war will start shortly after somebody dumps their virtual girlfriend
16:38:36 <lilac> ddarius: There was even going to be a party for you. A big party that all your friends were invited to.
16:38:58 <lilac> ddarius: I invited your best friend, the hs -> c++ translator. Of course, he couldn't come because you murdered him.
16:39:00 <edwardk> the symmetry there lets you do things you can't do with an adjunction and i make necessary use of that symmetry in lifting that relationship to the free/cofree construction.
16:39:19 <edwardk> that isn't a proof, but i'm relatively convinced
16:39:51 <ddarius> edwardk: Well having something that's both continuous and cocontinuous already leads to a lot of "power"
16:39:53 <lilac> if a significantly advanced piece of software is indistinguishable from an intelligent life form, is deleting it tantamount to killing such a life form?
16:40:04 <lilac> or possibly even to genocide?
16:40:15 <edwardk> the paper you found had a similar relationship, but it wasn't quite what was i looking for, i could only make it work for adjunctions between a category and its dual not just within a category.
16:44:11 <edwardk> ddarius: well, either f -| g or g -| f and both f and g are strong, is what i currently have as the weakest conditions i can put on it i should say. but thats not to say those are the weakest conditions possible.
16:44:56 <edwardk> so i don't know if continuousness or cocontinuousness is necessary, but having them both around makes it easy ;)
16:46:36 <mar77a> wow
16:46:56 <mar77a> so map f a equals foldr ((:).(f)) [] a
16:47:03 <ehird> <lilac> if a significantly advanced piece of software is indistinguishable from an intelligent life form, is deleting it tantamount to killing such a life form?
16:47:03 <ehird> <lilac> or possibly even to genocide?
16:47:04 <ehird> yes.
16:47:09 <mar77a> @src map
16:47:09 <lambdabot> map _ []     = []
16:47:09 <lambdabot> map f (x:xs) = f x : map f xs
16:47:10 <ehird> definately
16:47:35 <mar77a> @src foldr
16:47:35 <lambdabot> foldr f z []     = z
16:47:36 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:48:05 <tieTYT2> @src foldl
16:48:06 <lambdabot> foldl f z []     = z
16:48:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:48:17 <tieTYT2> ah
16:48:22 <mar77a> map f a = foldr ((:).(f)) [] a ?
16:48:28 <mar77a> is my discovery ..correct
16:48:34 <ehird> mar77a: try it!
16:48:43 <ehird> > let map f a = foldr ((:).(f)) [] a in map succ [1,2,3]
16:48:44 <lambdabot>  [2,3,4]
16:48:47 <edwardk> ddarius: i did take that paper and derive some fun constructs for unfolding a free monad wrapped around a cofree comonad of the same functor, and of a cofree comonad wrapped around a free monad using the distributive laws i had lying around from all my morphism stuff, so it gave me some strange toys to play with ;)
16:48:51 <ehird> yes, yes it is!
16:48:55 <mar77a> smooth
16:49:02 <mar77a> ty
16:49:06 <ehird> :)
16:49:19 <ehird> edwardk> ddarius: i did take that paper and derive some fun constructs for unfolding a free monad wrapped around a cofree comonad of the same functor, and of a cofree comonad wrapped around a free monad using the distributive laws i had lying around from all my morphism stuff, so it gave me some strange toys to play with ;)
16:49:20 <ehird> PARSE FAIL.
16:49:50 <edwardk> ehird: spin :: (ComonadCofree f w, RunMonadFree f m) => m (w a) -> m (w a); spin = inFree . distFutu id . liftM outCofree
16:50:05 <ehird> edwardk: By cofree, you mean coffee, right?
16:50:06 <edwardk> where m is the free monad of f and w is the cofree comonad of f
16:50:10 <edwardk> ehird =)
16:50:49 <edwardk> the other thing that messing around with all of this found me was a a rather bizarre function:
16:51:00 <edwardk> wtf :: (Adjunction f g, Traversable f, Traversable g) => Either a b -> Either (f a) (g b); wtf = costrength . fmap (swap . costrength) . unit . swap
16:51:21 <edwardk> not that i think there are all that many adjunctions between pairs of traversable functors in Haskell.
16:51:29 <ehird> on another note
16:51:35 <ehird> let's golf `coerce :: a -> b`
16:51:41 <ehird> shortest definition wins, yes this is a trick question.
16:53:07 <ehird> no? ;)
16:53:27 * edwardk calls dibs on 'coerce' ;)
16:54:24 <thoughtpolice> coerce = undefined
16:54:32 <Heffalump> edwardk's is shorter..
16:54:43 <Heffalump> fix id is the same length as his
16:54:52 <Heffalump> but has fewer non-whitespace chars
16:54:54 <edwardk> nah you got a space =)
16:55:31 <Saizan> c@coerce = c
16:55:40 <Heffalump> sneaky
16:56:35 <ehird> <thoughtpolice> coerce = undefined
16:56:36 <ehird> damnit
16:56:37 <ehird> :(
16:56:42 <ehird> Saizan: hah
16:56:49 <ehird> coerce=c
16:56:53 <ehird> where c is a definition of coerce
16:57:10 <ehird> my real idea was thoughtpolice's though
16:57:21 <ehird> anyway, when did edwardk define it?
16:57:24 <edwardk> ehird: i think you can compress anything with an assumed function library ;) i like saizan's
16:57:32 <edwardk> ehird when i said 'coerce'
16:57:40 <ehird> ah
16:57:40 <ehird> heh
16:57:52 <dmwit> Wouldn't it be coerce@c = c?
16:57:54 <edwardk> @type \coerce -> coerce
16:57:55 <lambdabot> forall t. t -> t
16:57:58 * Heffalump thinks Saizan's wins
16:57:59 <dmwit> > let bot@b = b in bot
16:58:00 <edwardk> dmwit: either
16:58:06 <edwardk> saizan definitely won
16:58:11 <ehird> yeah saizan wions
16:58:14 <lambdabot>  thread killed
16:58:21 <dmwit> > let b@bot = b in bot
16:58:34 <ehird> coerce :: GHC.Prim.Any
16:58:34 <ehird> odd
16:58:35 <Saizan> yeee, what do i win?
16:58:36 <lambdabot>  thread killed
16:58:43 <dmwit> I thought the RHS of @'s were only locally bound, but I guess I was wrong.
16:59:08 <edwardk> an all expense unpaid trip to ehird's place to crash on his couch and drink his beer.
16:59:33 <ehird> edwardk: what if I don't have a couch
16:59:34 <ehird> or beer
16:59:43 <dmwit> or a place
16:59:44 <edwardk> then its a pretty crappy trip ;)
16:59:58 <ehird> dmwit: or a 'to'
17:00:05 <ehird> I might not even exist
17:00:27 <mar77a> @src putStrLn
17:00:27 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
17:00:28 <dmwit> ehird: @part #haskell -- does this work on all bots? =P
17:00:36 <mar77a> @src print
17:00:36 <lambdabot> print x = putStrLn (show x)
17:00:40 <ehird> dmwit: no
17:00:41 <mar77a> @src show
17:00:41 <lambdabot> show x = shows x ""
17:00:45 <ehird> i grew out of that a _very_ long time ago
17:00:45 <ehird> :\
17:00:52 <mar77a> @src shows
17:00:52 <lambdabot> Source not found. Wrong!  You cheating scum!
17:00:54 <mar77a> :<
17:01:01 <ehird> mar77a: shows is in le type class.
17:01:03 <ehird> @type shows
17:01:05 <lambdabot> forall a. (Show a) => a -> String -> String
17:01:08 <ehird> @type Show
17:01:10 <lambdabot> Not in scope: data constructor `Show'
17:01:11 <dmwit> mar77a: It's turtles all the way down.
17:01:16 <mar77a> err
17:01:23 <ehird> @src Show
17:01:24 <lambdabot> class  Show a  where
17:01:24 <lambdabot>     showsPrec :: Int -> a -> ShowS
17:01:24 <lambdabot>     show      :: a   -> String
17:01:24 <lambdabot>     showList  :: [a] -> ShowS
17:01:31 <edwardk> ehird: existence?
17:01:36 <mar77a> shows is the printf right
17:01:42 <thetallgu1> @sequence [1 ..]
17:01:42 <lambdabot> Unknown command, try @list
17:01:43 <dmwit> mar77a: no
17:01:44 <ehird> edwardk: or @part
17:01:47 <mar77a> it automatically detects the type, and converts to ""
17:01:53 <ehird> mar77a: lol wut
17:01:56 <mar77a> "stringed type"
17:01:57 <dmwit> mar77a: Well, yes.
17:01:59 <ehird> ...
17:02:00 <ehird> :\
17:02:03 <mar77a> something like that :)
17:02:08 <ehird> stringed type converted to ""!
17:02:16 <dmwit> mar77a: It's like sprintf, but with a trick to speed up concatenation.
17:02:21 <mar77a> mk
17:02:34 <mar77a> i hate thinking in terms of C/C++ but that's how i 'raised' myself
17:02:38 <mar77a> trying to shake that off
17:02:45 <mar77a> it's beautiful seeing it happen
17:02:53 <mar77a> when you start 'getting' haskell
17:02:59 <ehird> It's nothing like sprintf.
17:03:08 <dmwit> > sprintf "%d" 32 :: String
17:03:08 <lambdabot>   Not in scope: `sprintf'
17:03:09 <ehird> It's just a debugging serialization method that happens to use some funky type class tricks.
17:03:14 <dmwit> ?hoogle sprintf
17:03:14 <ehird> dmwit: ITYM printf
17:03:15 <lambdabot> No matches found
17:03:18 <ehird> > printf "%d" 32 :: String
17:03:20 <lambdabot>  "32"
17:03:22 <ehird> > printf "%d" 32 :: IO String
17:03:23 <lambdabot>  <IO [Char]>
17:03:26 <dmwit> Oh, right, polymorphism FTW.
17:03:27 <ehird> crazy stuff
17:03:30 <mar77a> :)))
17:03:43 <ehird> > printf "%s" 32 :: IO String
17:03:45 <lambdabot>  <IO [Char]>
17:03:53 <ehird> You can tell lambdabot just ignores this IO shizz ;)
17:04:02 <ehird> > printf "%i" "I AM AN INTEGER" :: IO String
17:04:04 <lambdabot>  <IO [Char]>
17:04:06 <jleedev> > unsafePerformIO (print "hello")
17:04:07 <lambdabot>   Not in scope: `unsafePerformIO'
17:04:19 <ehird> And this, kids, is why you should stay in school and just say no to drugs. And non-type-safety
17:04:39 <dons> lambdabot's on the straight edge.
17:04:44 <ehird> hardcore.
17:05:25 <ehird> dons: lambdabot's also an evil liberal progressive
17:05:27 <ehird> @type map
17:05:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:05:34 <ehird> RADICAL REVOLUTIONARY.
17:05:38 <tchakkazulu> ?type (.)
17:05:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:05:41 <mar77a> what the hell does forall mean exactly
17:05:57 <dons> it is like 'let' for type variables
17:06:06 <ehird> dons: er, is it?
17:06:14 <thetallgu1> what's the command for identifying sequences?
17:06:15 <ehird> it's universal quantification more like
17:06:16 <ehird> :P
17:06:24 <mar77a> o_
17:06:28 <dons> sure. it introduces the type variable 'a' with scope
17:06:31 <tchakkazulu> It defines the scope of a type variable.
17:06:34 <ehird> :\
17:06:38 <ehird> I wouldn't define it that way
17:06:45 <ehird> 'forall' means ... 'for all'
17:06:46 <ehird> :P
17:06:51 <edwardk> > describeSequence [1,11,21,1211,111221]
17:06:53 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
17:07:08 <thetallgu1> edwardk: thanks
17:07:10 <ehird> @oeis 1 11 21 1211 1112211
17:07:11 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
17:07:15 <ehird> Lols
17:07:49 <tchakkazulu> Defining it as scope introduction makes the distinction between forall x . (x -> x) -> (Int, Bool) and (forall x . x -> x) -> (Int, Bool) a lot clearer, though.
17:08:48 <mar77a> :t (>>)
17:08:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
17:09:00 <mar77a> @src (>>)
17:09:01 <lambdabot> m >> k      = m >>= \_ -> k
17:09:09 <mar77a> o-o
17:09:21 <ehird> mar77a: Hush, look away you
17:09:22 <ehird> :P
17:09:33 <ehird> Lambdabot should have a "don't scare noobs" mode
17:09:49 <mar77a> :<
17:09:53 <ehird> Hm. Before haskell had monadic IO what was used?
17:09:55 <mar77a> did you just call me a n00b
17:10:00 <ehird> mar77a: noob, not a n00b
17:10:01 <mar77a> i've been coding haskell for a week
17:10:06 <ehird> heh :)
17:10:12 <mar77a> i am the best haskell coder you will find
17:10:17 <mar77a> in my city
17:10:24 <dmwit> heh
17:10:37 <mar77a> ok now i feel special, lets continue deveiling (>>)
17:11:11 <mar77a> any english explanation of what (>>) does?
17:11:21 <lament> yes
17:11:21 <dmwit> It sequences two computations, ignoring the results of the first.
17:11:36 <lament> a>>b = "do a and then do b"
17:11:38 <dmwit> It ignores the results, but not the "side effects", whatever those might be.
17:11:46 <mar77a> IO
17:11:50 <ehird> Oooooh, fudgets are cool
17:11:53 <ehird> lambdabot: no it doesn't
17:11:54 <ehird> :(
17:12:00 <ehird> Though, nice newbie explanation
17:12:01 <ehird> errr
17:12:01 <ehird> lament
17:12:09 <dmwit> mar77a: In IO, it is most often used with "IO ()" actions as the first argument.
17:12:12 <mar77a> > (2+2) >> (+1)
17:12:13 <lambdabot>   add an instance declaration for (Num (a1 -> a))
17:12:19 <mar77a> > (2+2) >> (1+1)
17:12:19 <lambdabot>        add an instance declaration for (Num (m b), Num (m a))
17:12:24 <mar77a> o_o
17:12:25 <dmwit> mar77a: In that case, it just means, do the first action, ignore the () return result, then do the second action.
17:12:32 <ehird> On another note, Fudgets are way cool. Is anyone writing a fudgets lib for wx? The web?
17:12:37 <mar77a> haskell docs say "Sequentially compose two actions, passing any value produced by the first as an argument to the second."
17:12:42 <mrd> > return (2+2) >> return (1+1)
17:12:43 <lambdabot>   add an instance declaration for (Show (m t))
17:12:48 <ehird> mar77a: 2+2 is not an action
17:12:52 <mrd> > return (2+2) >> return (1+1) :: Maybe Int
17:12:53 <mar77a> ahh
17:12:54 <lambdabot>  Just 2
17:13:18 <dmwit> > Nothing >> return (1+1) :: Maybe Int -- showing the side effect
17:13:20 <lambdabot>  Nothing
17:13:44 * mar77a 's head hurts
17:13:50 <mar77a> i'll take a break
17:14:02 <mar77a> btw ehird , i've been learning haskell for months now, with breaks ;(
17:14:08 <kevinu> ok, then what about >$>%<@@%$>, what does that mean?!?
17:14:10 <mar77a> food, later.. thanks for the help, as usual
17:14:27 <dmwit> kevinu: It means a syntax error. =)
17:14:31 <ehird> kevinu: it means 'ZOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOM'
17:14:37 <kevinu> sweet
17:14:46 <dmwit> > let (>$>%<@@%$>) = undefined in 3
17:14:47 <lambdabot>  3
17:14:52 <dmwit> Oh, not a syntax error?
17:15:02 * dmwit would think @@ would be bad
17:15:21 <ehird> > let (>$>%<@@%$>) = (>>) . (>>=) . return . fix . fmap
17:15:22 <lambdabot>  Parse error at end of input
17:15:25 <ehird> > let (>$>%<@@%$>) = (>>) . (>>=) . return . fix . fmap in 3
17:15:27 <lambdabot>  3
17:15:28 <ehird> Wow
17:15:34 <ehird> :t (>>) . (>>=) . return . fix . fmap
17:15:36 <lambdabot> forall b (m :: * -> *) b1 b2 (f :: * -> *). (Functor f, Monad m) => (b2 -> b2) -> ((f b2 -> m b1) -> b) -> (f b2 -> m b1) -> b
17:15:38 <ehird> ...
17:15:42 <dmwit> T-hee!
17:16:06 <dmwit> > let (>$>%<@@%$>) = (+) in 3 >$>%<@@%$> 5
17:16:06 <ehird> dmwit: One day, there will be a functor-post-reactive paradigm and that will be one of the core functions
17:16:07 <lambdabot>  8
17:16:07 <ehird> You bet it.
17:16:17 <ehird> named something less awful I hope
17:16:26 <ehird> Now, first person who can get my function to _do_ something ... :-)
17:16:51 <ehird> I honestly cannot think of one way to call it.
17:17:49 <ddarius> > let f @@ g = \x -> g x  >>= f
17:17:49 <lambdabot>  Parse error at end of input
17:18:01 <ehird> :t \x -> g x >>= f
17:18:03 <lambdabot> forall t (m :: * -> *) a b. (Monad m, SimpleReflect.FromExpr (m b), Show a, SimpleReflect.FromExpr (t -> m a)) => t -> m b
17:18:08 <ehird> Hah.
17:18:12 <ehird> :t \f g x -> g x >>= f
17:18:14 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (a -> m b) -> (t -> m a) -> t -> m b
17:18:26 <ehird> @unpl (>>) . (>>=) . return . fix . fmap
17:18:26 <lambdabot> (\ c -> (>>) ((>>=) (return (fix (fmap c)))))
17:18:30 <ehird> @do (\ c -> (>>) ((>>=) (return (fix (fmap c)))))
17:18:30 <lambdabot> (\ c -> (>>) ((>>=) (return (fix (fmap c))))) not available
17:18:34 <ehird> ..
17:18:35 <ehird> @redo (\ c -> (>>) ((>>=) (return (fix (fmap c)))))
17:18:36 <lambdabot> (\ c -> (>>) ((>>=) (return (fix (fmap c)))))
17:18:38 <ehird> hah
17:18:49 <ehird> @redo (>>) ((>>=) (return (fix (fmap c))))
17:18:49 <lambdabot> (>>) ((>>=) (return (fix (fmap c))))
17:18:51 <ehird> Gah.
17:18:55 <ehird> @unpl (>>) ((>>=) (return (fix (fmap c))))
17:18:55 <lambdabot> (>>) ((>>=) (return (fix (fmap c))))
17:18:58 <ehird> Wtf.
17:19:05 <ehird> er.
17:19:07 <ehird> sorry for spam
17:19:15 <dmwit> It's not pointful, why would ?pl do anything?
17:19:30 <ehird> :t let foo = (>>) . (>>=) . return . fix . fmap in foo id
17:19:31 <sjanssen> @pl liftM
17:19:31 <lambdabot> fmap
17:19:32 <lambdabot> forall b (f :: * -> *) (m :: * -> *) b1 b2. (Functor f, Monad m) => ((f b -> m b1) -> b2) -> (f b -> m b1) -> b2
17:19:35 <sjanssen> dmwit: :P
17:19:43 <dmwit> =/
17:19:44 <ehird> Hokay, let's get this called.
17:20:04 <bd_> @. redo . unpl pl (\ c -> (>>) ((>>=) (return (fix (fmap c)))))
17:20:04 <lambdabot> (\ c -> (>>) ((>>=) (return (fix (fmap c)))))
17:20:11 <ddarius> @pl \x -> map f . map g $ x
17:20:11 <lambdabot> map (f . g)
17:20:42 <ehird> Who wants to help me call foo and make it something useful?
17:20:51 <dmwit> :t let foo = (>>) . (>>=) . return . fix . fmap in foo id id
17:20:53 <lambdabot> forall b (f :: * -> *) (m :: * -> *) b1. (Functor f, Monad m) => (f b -> m b1) -> f b -> m b1
17:21:03 <dmwit> :t let foo = (>>) . (>>=) . return . fix . fmap in foo id id id
17:21:05 <lambdabot> forall b (f :: * -> *). (Functor f, Monad f) => f b -> f b
17:21:12 <dmwit> :t let foo = (>>) . (>>=) . return . fix . fmap in foo id id id []
17:21:13 <lambdabot> forall b. [b]
17:21:32 <dmwit> > let foo = (>>) . (>>=) . return . fix . fmap in foo id id id []
17:21:32 <lambdabot>  []
17:21:35 <dmwit> done
17:22:12 <ehird> dmwit: nooooo
17:22:17 <ehird> I meant with actual sensible arguments
17:22:26 <ehird> i.e., actually utilizing the stuff
17:22:28 <dmwit> Those *are* sensible arguments.
17:22:30 <ehird> instead of just id'ing it up
17:22:31 <ehird> :P
17:22:34 <dmwit> It even called fix and didn't return bottom!
17:22:41 <ehird> dmwit: Heh.
17:22:48 <ehird> Well, let's analyze it
17:22:55 <ehird> the second argument can only use its argument if we hvae a runner
17:22:57 <ehird> Let's go with maybe
17:23:27 <ehird> :t let foo = (>>) . (>>=) . return . fix . fmap in \x y -> foo id (\f -> maybe x id (f y))
17:23:29 <lambdabot> forall b (f :: * -> *) b1. (Functor f) => b1 -> f b -> (f b -> Maybe b1) -> b1
17:24:04 <ehird> :t let foo = (>>) . (>>=) . return . fix . fmap in \x y z -> foo id (\f -> maybe x id (f y)) z (return z) Just
17:24:06 <lambdabot>     Occurs check: cannot construct the infinite type:
17:24:06 <lambdabot>       b = m (f b1 -> Maybe b) -> (a -> Maybe a) -> t
17:24:06 <lambdabot>     Probable cause: `foo' is applied to too many arguments
17:24:15 <ehird> :t let foo = (>>) . (>>=) . return . fix . fmap in \x y z -> foo id (\f -> maybe x id (f y)) z (return z)
17:24:17 <lambdabot>     Occurs check: cannot construct the infinite type:
17:24:17 <lambdabot>       b = m (f b1 -> Maybe b) -> t
17:24:17 <lambdabot>     Probable cause: `foo' is applied to too many arguments
17:24:20 <ehird> guh
17:24:23 <ehird> :t let foo = (>>) . (>>=) . return . fix . fmap in \x y z -> foo id (\f -> maybe x id (f y)) z
17:24:25 <lambdabot> forall b (f :: * -> *) b1. (Functor f) => b1 -> f b -> (f b -> Maybe b1) -> b1
17:24:28 * dmwit suggests /msg lambdabot
17:24:33 <ehird> dmwit: indeed.
17:24:38 <ehird> however, for the final zonk:
17:25:26 <ehird> /msg lambdabot isn't working
17:25:26 <ehird> :\
17:25:43 <dmwit> Works here.
17:26:04 <ehird> ah
17:26:06 <ehird> :t doesn't work
17:26:08 <lambdabot> Not in scope: `doesn't'
17:26:08 <lambdabot> Not in scope: `work'
17:26:15 <ehird> <lambdabot> forall t b (f :: * -> *). (Num t, Functor f, Monad f) => b -> (f b -> Maybe t) -> t
17:26:15 <dmwit> ?ty -- still works
17:26:17 <lambdabot> <no location info>: not an expression: `'
17:26:22 <ehird> dmwit: ty
17:26:23 <ehird> (ha)
17:26:44 <dmwit> You also have to use ?kind instead of :k, in case you end up needing that. =P
17:27:19 <ehird> dmwit: Humph, lambdabot won't even _type_ unsafePerformIO for me
17:27:26 <ehird> welp
17:27:27 <ehird> let foo = (>>) . (>>=) . return . fix . fmap; bar x y z = foo id (\f -> maybe x id (f $ return y)) z in bar 1 (Just . unsafePerformIO)
17:27:29 <ehird> that's the final expression
17:27:55 <ehird> @hoogle fix
17:27:56 <lambdabot> Data.Function.fix :: (a -> a) -> a
17:27:56 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
17:27:56 <lambdabot> Control.Monad.Fix :: module
17:28:07 <ehird>     No instance for (Monad ((->) (f (IO a -> Maybe a) -> Maybe b)))
17:28:09 <ehird> Yeaaah. :|
17:29:28 <ehird> hahaa
17:29:30 <ehird> Left Click
17:29:30 <ehird> :DD
17:29:55 <edwardk> @seen ddarius
17:29:55 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
17:31:02 <edwardk> ok, random question: Cocones in Control.Monad.Cocone or Control.Functor.Cone? They happen to be a monad, but otoh Cones are pretty boring by Haskell standards and don't deserve a file of their own (and aren't comonads, so the duality is lost)
17:31:29 <ehird> Cones?
17:31:42 <ehird> and ... Control.Cone.Co
17:31:42 <ehird> :P
17:32:11 <edwardk> data Cocone f n = forall a. Cocone { f a -> n } -- its a 'MonadReader' over 'Colimit f'
17:32:35 <edwardk> but i figured I might as well implement it explicitly
17:32:58 <ehird> edwardk: looks pretty interesting to me
17:32:59 <ehird> Monad instance?
17:33:02 <edwardk> er strip the { }'s they were there for a runCocone :: but thats illtyped
17:33:21 <edwardk> the monad instance is just like the reader instance
17:33:43 <ehird> no runCocone? Aw.
17:33:51 <ehird> what are cones, anyway?
17:33:54 <edwardk> can't write it, there is an existential involved
17:34:09 <edwardk> http://en.wikipedia.org/wiki/Cone_%28category_theory%29
17:34:23 <ehird> while category theory is lovely I was thinking more a haskell definition
17:34:24 <ehird> :-)
17:34:44 <edwardk> er actually i flawed that definition above
17:34:55 <Maciej> Is there a Haskell package that can handle reading from and writing to the clipboard?
17:35:02 <edwardk> heh
17:35:16 <ehird> Maciej: IT IS IMPOSSIBLE
17:35:19 <ehird> ... no, no it's not.
17:35:25 <edwardk> so you can runCocone ;)
17:36:06 <Maciej> Nothing is impossible ;-)
17:36:09 <ehird> edwardk: YAY :D
17:36:16 <ehird> But what is a real cocone defn. and cone :P
17:36:53 <thoughtpolice> Maciej: in the case of windows, you could probably just use the FFI to link to it; the api is simple from what I remember (albeit several years ago)
17:37:00 <thoughtpolice> for getting clipboard events from X, i have no idea.
17:37:12 <edwardk> ehird: basically think of it as a reader over an (f a) that can't do anything based on the 'type' of the contents of the functor, just on its general properties.
17:37:28 <edwardk> er based on the values contained in its functor, just the general structure of it
17:37:33 <thoughtpolice> Maciej: in the case of windows, there might actually be some functions in System.Win32 that'll do that for you
17:39:56 <Saizan> edwardk: a cone is pretty boring since you can only create values of the functor which don't present values of the contained type?
17:40:21 <Maciej> thoughtpolice: I searched Hackage but missed the hierarchical libraries :-D . There really are some functions. Thanks!
17:40:47 <thoughtpolice> Maciej: the hierarchical libs page is awesome. bookmark it immediately :)
17:40:54 <edwardk> vezzosi: cones are not quite the same, cones just are contravariant and the order of arguments is traditionally backwards even for that type Cone n f = n -> forall a. f a
17:41:56 <ehird> > Nothing
17:41:58 <lambdabot>  Nothing
17:42:00 <ehird> Maciej: Nothing is not impossible!
17:42:05 <jmsaunde> can someone please explain to me why "let blah (a,b) = [(b/a) (a/b)]" doesn't compile?
17:42:18 <ehird> jmsaunde: ITYM ,
17:42:21 <ehird> and why (a,b)?
17:42:22 <ehird> why not a b
17:42:28 <ehird> blah a b = (b/a, a/b)
17:42:58 <jmsaunde> I guess but what was wrong with that?
17:43:19 <ehird> jmsaunde: no comma
17:43:22 <ehird> [(b/a),(a/b)]
17:43:25 <ehird> Bye for today :-)
17:43:38 <jmsaunde> .....
17:43:46 <jmsaunde> thank you so much :(
17:44:56 <dmwit> jmsaunde: Do you still have a question?
17:45:06 <jmsaunde> oh no I'm good for now :)
17:46:57 <edwardk> heh src/Control/Functor/Cone.hs:34:40: My brain just exploded.
17:47:07 <edwardk> I always love that error message
17:48:01 <jmsaunde> oh wow. haven't seen that one heh
17:48:04 <jmsaunde> what does it mean?
17:48:04 <shepheb> is that a real error message? what causes it?
17:48:21 <edwardk> shepheb: pattern matching using a let binding against an existentially quantified variable
17:48:25 <edwardk> you have to use a case
17:48:28 <shepheb> I think I still prefer "The impossible just happened."
17:48:34 <shepheb> edwardk: ah, interesting
17:48:51 <edwardk> let Cocone e' = f (Cocone e) in ... blows up but case f (Cocone e) of Cocone e' -> ... works
17:49:09 <atp> that's wacky
17:49:12 <atp> isn't that a bug?
17:49:19 <edwardk> nah
17:49:32 <edwardk> i seem to recall reading the docs saying they just didn't want to have to code the logic for it ;)
17:49:34 <atp> because case forces evaluation and let doesn't?
17:49:41 <edwardk> coz let bindings are potentially recursive
17:49:45 <atp> ah
17:49:47 <atp> i see
17:50:05 <edwardk> so they could have to deal with all sorts of potentially valid existential circular reasoning
17:50:29 <edwardk> since no one spoke up and i didn't want cone to get lonely: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Cone.html
17:50:30 <lambdabot> http://tinyurl.com/5bgx9r
17:50:41 <atp> btw, i liked your series on kan extensions
17:50:48 <edwardk> atp: thanks =)
17:50:56 <atp> not much good on proggit these days but they were very enlightening
17:51:12 <atp> too bad the comments [on proggit] didn't live up to the article :(
17:51:25 <shepheb> edwardk: they made my brain hurt right now, so I pushed them onto my "read when I have the background knowledge" stack
17:51:26 <edwardk> yeah, i stopped bothering posting them to programming.reddit
17:51:56 <edwardk> though the third one got modded back to 0 on math.reddit, so i think even they are sick of them ;)
17:52:09 <edwardk> maybe kan extension overload or something
17:52:48 <tchakkazulu> edwardk: About the background knowledge. You have mentioned "Categories for the Working Mathematician" a few times in your posts.
17:53:02 <tchakkazulu> Would you recommend this to start learning the stuff?
17:53:13 <edwardk> tchakkazulu: its a very good book. and you'll keep coming back to it
17:53:25 <atp> i don't have a background in category theory, fwiw
17:53:33 <atp> but i do have a background in mathematics...
17:53:46 <tchakkazulu> Yeah, same here, atp.
17:54:06 <atp> i wrote my dissertation on some fairly pedestrian things related to algebraic topology...
17:54:14 <atp> very pedestrian, unfortunately :(
17:54:17 <edwardk> tchakkazulu: if you want something slightly more accessible Basic Categories for Computer Scientists doesn't suck as a 'hey this is what a category is' intro
17:54:23 <tchakkazulu> Okay, the course on topology touched it a bit with commutative diagrams that showed how topologies and their... fundamental groups? behaved similar.
17:54:35 <edwardk> yeah mine was on stabbing line problems in computational geometry. ;)
17:54:43 <atp> yeah, category theory supposedly has its roots in alg top, but we didn't use them the same way at all
17:54:46 <edwardk> er well thesis
17:54:54 <edwardk> i never got around to the whole ph.d thing.
17:54:56 <dolio> I don't think Basic ... is very good as a first introduction.
17:55:00 <atp> edwardk: me neither
17:55:15 <atp> i'd like to, but the real world pays slightly too well
17:55:17 <dolio> Although I came back to it recently and am appreciating it.
17:55:46 <tchakkazulu> edwardk: Okay, I'll keep that title in mind.
17:55:57 <atp> i guess thesis is probably a better english word... is dissertation only for phd?
17:55:59 <edwardk> I keep meaning to just add enough documentation to category-extras that it could be used as a primer ;)
17:56:05 <atp> what do you call the thing you write for your msc
17:56:07 <tchakkazulu> Too bad that books about obscure abstract stuff are hella expensive.
17:56:12 <edwardk> but then i go oooh shiny and code something else before documenting the existing stuff ;)
17:56:53 <edwardk> atp: thats the usual american english practice anyways, thesis for ms/ma. dissertation for ph.d but it has regional variations
17:57:14 <tchakkazulu> Hehehe, yeah. Yay distractions and shininess :)
17:57:21 <proq> atp: no dissertation isn't just for ph.d. it means discourse, basically
17:57:41 <atp> yah... i never did the phd thing :(
17:57:55 <atp> dr. atp has a nice ring to it though, eh?  hehe
17:58:07 <tchakkazulu> Ooh, Basic CT for CS isn't as expensive as the Working Mathematician. Neat.
17:58:17 <tchakkazulu> Thanks for the tips :)
17:58:27 <atp> tchakkazulu: if you live near a uni you can probably raid their math library for free
17:58:29 <edwardk> Heh I should do the monadlib thing to category-extras, get it down to one source file, no pesky dependencies...
17:58:42 * shepheb feels rather undereducated in the Haskell community. on the other hand, I haven't lived long enough to get any more degrees.
17:58:43 <edwardk> might completely lose myself trying to find anything but hey
17:58:49 <atp> tchakkazulu: you can't take the book home, which sucks, but you can probably bring your laptop in
17:59:16 <edwardk> CT for CS is also about the size of a thin paperback book ;)
17:59:28 <tchakkazulu> atp: I used to do math here at the uni, so that should be okay.
17:59:46 <sykopomp> shepheb: it's alright, I haven't taken math since I took pre-calc in high school, and I just got my bachelor's :(
17:59:48 <tchakkazulu> Though I can't remember there being anyone into that area.
18:00:01 <tchakkazulu> I should probably ask the topology guy.
18:00:22 <atp> tchakkazulu: you may get a non CS book on categories, which like i said is a pretty different treatment
18:00:36 <atp> forgetful functors an the like
18:01:03 <atp> i think the CS part is more interesting but my understanding too is rudimentary
18:01:06 * edwardk seriously considers making 'class Zap f g, Zap g f => Adjunction f g | f -> g, g -> f replace the existing adjunction definition to encode the bit abotu adjunction being sufficient for 'zapWith' ;)
18:02:11 <edwardk> with free implementations handy to make that not suck
18:02:41 <atp> do it, why not?
18:02:49 <edwardk> needs a better name
18:03:09 <atp> speaking of names, how did you decide on ... what did you use for counit and cobind again in your Comonad class?
18:03:12 <edwardk> is there an existing notion of a complementary functor outside of priestley spaces?
18:03:22 <edwardk> extract and extend?
18:03:25 <atp> right
18:03:28 <edwardk> and duplicate
18:03:35 <edwardk> for cojoin
18:03:40 <atp> nod
18:04:11 <edwardk> well, to be quite honest i took them from Dave Menendez when I learned comonads, then I used comonads a ton for another project involving substructural logic (where all the modalities were comonads) and the names stuck with me.
18:04:38 <edwardk> plus they have intuitive value when you're trying to figure out what they do
18:04:38 <atp> ah, because i've seen a few different names thrown around in papers
18:04:41 <edwardk> yeah
18:04:46 <tchakkazulu> extract and duplicate make sense if you see the types.
18:04:52 <atp> sure
18:04:53 <tchakkazulu> What was the type of extend again?
18:04:55 <edwardk> cobind, cojoin and coreturn are probably more exact
18:04:59 <tchakkazulu> w a -> (w a -> b) -> w b?
18:05:05 <edwardk> extend :: (w a -> b) -> w a -> w b
18:05:20 <atp> i like unit and counit more than return and coreturn, personally... but i have no strong feelings
18:05:27 <dolio> extend should be coextend, from a few papers I've read.
18:05:47 <edwardk> the 'backwards' definition for 'bind' leads to problems when you define these for arbitrary categories
18:06:27 <edwardk> because 'bind :: (a -> m b) -> m a -> m b' makes sense in categories other than hask that aren't CCC's but the definition for (>>=) doesn't.
18:07:31 <edwardk> hence why category-extras defines things in terms of hbind, pbind, ibind, etc for the generalized monads. because when/if i make them work over other categories and cut the ties to the standard lib, then those definitions generalize, while i have to rewrite all the cruft defined in terms of (>>=)
18:07:45 <tchakkazulu> Yeah. I'm not sure what definition of the Monad class I like most.
18:08:06 <tchakkazulu> (a -> m b) -> (m a -> m b) looks like you're "lifting" a function.
18:08:07 <edwardk> dolio: coextend is just silly =)
18:08:20 <tchakkazulu> Then there's the join/fmap/return version, which is the classical math definition.
18:08:40 <tchakkazulu> And there's (>=>), which mimics function composition.
18:08:43 <dolio> edwardk: I'm pretty sure I've seen extend :: (a -> m b) -> (m a -> m b), as opposed to bind which is flipped.
18:08:43 <edwardk> tchakkazulu: i usualy define join and bind circularly so i don't have to care
18:08:54 <dolio> And then they call the comonad version coextend.
18:09:56 <dolio> But I may be remembering incorrectly.
18:09:57 <edwardk> dolio: heh, by that token they should be eta and mu for return and join, and epsilon and delta for extract and duplicate. ;)
18:10:13 <edwardk> dolio: i gave up on primacy and just went for legibility ;)
18:10:17 <dolio> Totally.
18:10:42 <edwardk> i believe technically the term 'comonad generated by a functor' is older than 'density comonad' but the latter is a lot nicer to say =)
18:10:42 <atp> i usually would define (=>>) = flip extend anyway
18:10:42 <atp> altogether bind is less useful in comonadic code than in monadic code, though
18:10:42 <atp> because you tend to keep things in the comonad for as long as possible...
18:11:03 <edwardk> the >>= doesn't lend itself to a clean dual notation. >> winds up messed up either way
18:11:32 <edwardk> unless you want to make a mandatory superclass of both comonad and monad that implements (>>) :: m a ->  m b -> m b
18:11:52 <edwardk> which i've considered, but worsens the backwards compatibility problem ;)
18:11:56 <dolio> That isn't the right type for the comonad >>, though.
18:12:30 <edwardk> yeah =/
18:12:32 <atp> (>>) is silly anyway
18:12:56 <atp> someone... uustulu and venn (sp?) maybe ... defined some .>> nonesense
18:13:00 <atp> never saw the point
18:13:07 <atp> although u & v are pretty smart guys
18:13:24 <mar77a> maybe they outsmarted you and it does make sense :p
18:13:27 <atp> no, wait, it wasn't them... it was that other paper... what was it called
18:13:37 <mar77a> that's the logic when dealing with superior minds...you're always wrong :D
18:13:41 <edwardk> menendez used .>> i just never liked the 'not quite symmetric' notation
18:13:48 <atp> mar77a: not at all unlikely, especially in their case (but in general with academics too)
18:14:16 <atp> from a usability standpoint the lack of a nice codo notation makes comonadic code difficult sometimes
18:14:21 <edwardk> yeah
18:14:33 <atp> but i haven't the foggiest idea what that would look like and thinking about it hurts my brain
18:14:43 <edwardk> the funny thing is codo is easy to type, just replace everything with the appropriate comonadic equivalent.
18:14:54 <atp> what about >> ?
18:14:58 <tchakkazulu> I actually have no clue how to use comonads in a sensible way.
18:15:20 <tchakkazulu> I mean, sure, I've defined a sudoku solver with a comonad (ye olde cellular-automaton thingie).
18:15:20 <atp> tchakkazulu: some things (like reader) are simpler comonadically than monadically
18:15:24 <edwardk> use the .>> w a -> b -> w b version, it types out. you get a 'value' not a comonad wrapped value, leaving you something suitable to extend.
18:15:31 <atp> tchakkazulu: and zippers
18:15:37 <tchakkazulu> And the different "solving steps" would be chained by =>>
18:15:50 <edwardk> keep in mind all your 'patterns' are 'full comonads' not the contents of them, so its a little harder to use pattern matching in codo.
18:16:07 <tchakkazulu> Yeah, I tried to figure out the (r,a) comonad, but I couldn't find a way to "ask" for the environment.
18:16:17 <tchakkazulu> Which makes a reader kinda useless.
18:16:29 <atp> tchakkazulu: you operate on the comonad... that's what i mean by not taking things out of the comonad
18:16:31 <edwardk> tchakkazulu: yeah though the sudoku variant is suboptimal coz it does the whole once over on the board each pass. so it takes advantage of less than the maximum amount of information at each point.
18:16:34 <atp> you pass the whole comonad around
18:16:47 <dolio> coask :: (r,a) -> r
18:17:00 <tchakkazulu> Ah, yes, duh.
18:17:03 <shepheb> I've been wondering what I need as background before tackling comonads
18:17:08 <edwardk> tchakkazulu: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad-Reader.html
18:17:09 <lambdabot> http://tinyurl.com/59kqgo
18:17:13 <tchakkazulu> You're working in tuples, so the environment is always available >_>
18:17:39 <edwardk> tchakkazulu: yeah
18:17:42 <atp> comonads aren't very complex inherently, it's just that most of the really useful bits can either be done sufficiently well with monads, or they're fairly abstract (in my experience)
18:17:44 <edwardk> tchakkazulu: makes life easy =)
18:18:09 <edwardk> i keep meaning to finish up a nice type level derivative so i can do a zipper comonad for the library from soup to nuts
18:18:18 <edwardk> i haven't boxed things up nicely enough for it yet though
18:18:19 <atp> that bit about how the arrow reader, comonad reader and monad reader are all "isomorphic" in your kan extensions post was quite a nice aha moment i thought
18:18:28 <tchakkazulu> And now the writer comonad, which should be the dual of the writer monad. So... a -> w?
18:18:33 <edwardk> atp: you can do the same for state, context and state arrows
18:18:44 <edwardk> tchakkazulu: look at the supply comonad
18:19:04 <edwardk> tchakkazulu: its a -> (a, a), not (a, a) -> a. that is needed
18:19:06 <atp> edwardk: it's pretty neat stuff.
18:19:17 <edwardk> tchakkazulu: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad-Supply.html
18:19:18 <lambdabot> http://tinyurl.com/6c3jyr
18:19:28 <edwardk> tchakkazulu: though, that version cheats. ;)
18:19:38 <hpaste>  jdrake pasted "Help help I am being repressed!" at http://hpaste.org/7952
18:19:54 <jdrake> Fibs again, specific application
18:20:00 <jdrake> It eats ram :-), not sure why
18:20:28 <edwardk> jdrake fibs is a 'CAF" which means the reference to it sticks around.
18:20:39 <dolio> fibs is top-level, so it's memoized for the whole program.
18:20:52 <edwardk> because you have a naked reference to its name in the top level. give it an argument and ignore the argument ;)
18:21:06 <jdrake> hmm
18:21:24 <jdrake> Can I just do fibs _ = ...
18:21:40 <edwardk> fibs _ = f where f = 0 : 1 : zipWith (+) f (tail f); euler2 = .... $ fibs ()
18:22:01 <edwardk> that should be enough to fool it
18:24:16 <jdrake> Well, it doesn't seem to be eating ram
18:24:42 <jdrake> How long would you expect the operation to take?
18:25:25 <dolio> That will take forever.
18:25:40 <dolio> You need to use 'takeWhile (\x -> x <= 4000000)'
18:26:23 <jdrake> man that was fast
18:26:46 <jdrake> The answer is right too
18:27:00 <Elly> @djinn a -> (a, a)
18:27:00 <lambdabot> f a = (a, a)
18:27:39 <jdrake> Well, I guessed most of the list processing right. It seems to me that takeWhile and filter perform the same basic operation in a different way
18:27:52 <edwardk> tchakkazulu: i need to add a SupplyT to category-extras, i just haven't gotten around to it (want it to finish my duality set against the standard mtl)
18:28:13 <dolio> filter removes all the elements greater than 4000000, but it's an infinite list, so it takes forever to do so.
18:28:39 <dolio> Because it has to examine them all to know they don't belong.
18:28:55 <atp> is filter not defined in terms of a right fold?
18:29:00 <atp> i guess not
18:29:12 <edwardk> atp: remember, his ultimate operation is addition.
18:29:13 <dolio> It is, but he was summing the results.
18:29:16 <edwardk> atp: doesn't matter
18:29:20 <atp> i haven't actually looked at his code
18:29:30 <atp> ah
18:29:35 <atp> i see
18:29:42 <edwardk> atp: its not a 'productive' corecursive operation.
18:30:03 <atp> yeah, if he's summing the results it will never work
18:30:09 <monochrom> > takeWhile (> 0) [2, 1, 0, -1]
18:30:16 <monochrom> > filter (> 0) [2, 1, 0, -1]
18:30:17 <atp> he needs to use the monotonicity of the fib sequence
18:30:24 <lambdabot>  thread killed
18:30:32 <lambdabot>  thread killed
18:31:10 <kmcallister> @seen dons
18:31:10 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
18:32:06 <jdrake> atp, your words are strange
18:32:07 <atp> lambdabot is sick
18:32:10 <kmcallister> :/
18:32:15 <atp> jdrake: how so?
18:32:16 <tchakkazulu> edwardk: I shall look deeper into category-extras later (and perhaps backread your blog, seems to have more good stuff).
18:32:41 <jdrake> monotonicity is a word I have not heard in all my years
18:32:48 <tchakkazulu> Right now, it's past pi-time, so sleep.
18:32:53 <edwardk> tchakkazulu: if you have any questions feel free to ask
18:32:55 <atp> jdrake: a monotonic sequence is one that is strictly increasing or decreasing
18:33:13 <shepheb> well, nonincreasing or nondecreasing.
18:33:20 <atp> yeah, that's what i meant :)
18:33:20 <monochrom> Mexico City, Sin City, Circuit City, Monotoni City
18:33:38 <jdrake> atp, however, I do not see how that is useful
18:33:39 <atp> if you put <= or >= in between every element of the sequence and have the result be true, the sequence is monotonic
18:33:49 <tchakkazzzzz> edwardk: I probably will. Thanks for the interesting discussions.
18:33:52 <dolio> > foldr (flip const) [] [1..]
18:34:00 <lambdabot> Terminated
18:34:21 <atp> jdrake: if you're trying to sum all the fibs under a certain value, you can safely stop filtering once you reach that value, because fib is monotonically increasing
18:34:47 <monochrom> takeWhile is more suitable than filter for this.
18:34:51 <atp> yes
18:34:53 <jdrake> Which is what I was trying to do, but had the wrong function
18:35:08 <atp> well, that's one way to look at it...
18:35:20 <jdrake> Well on to the next problem
18:35:32 <jdrake> This exercise is most illuminating for haskell info
18:37:27 <atp> it would be kind of neat if the compiler could automagically turn filter into takeWhile, heh
18:37:54 <dolio> Just need some kind of oracle. :)
18:37:58 <atp> well,
18:38:14 <atp> no, just a sufficiently smart compiler
18:38:18 <atp> which is similarly mythical
18:38:19 <atp> :)
18:38:41 <atp> although you know thinking about that sort of transformation becomes more plausible the more proof-carrying your language is
18:39:05 <dolio> Yeah.
18:39:34 <atp> haskell isn't there, but of all the "mainstream" languages in use today, it's the one where that sort of thing is most feasible
18:40:23 <dons> filter into takeWhile, oh, if it spots its an enum
18:40:23 <dons> hmm
18:40:51 <atp> if you compare gcc with the c compilers of old, gcc does some truly frightening optimizations... i suspect that 20 years from now, it will be similar
18:40:52 <dolio> That won't help with fibs.
18:41:16 <dolio> Unless you add [1,1,2..]
18:41:25 <atp> the compiler would need to be able to prove that fibs is monotonically increasing and, from looking at the (< x) closure, determine that it needs a takeWhile not a filter
18:41:44 <atp> probably not impossible
18:42:03 <kmcallister> dons, could you please help me diagnose a hs-plugins problem?
18:42:39 <TomMD> I'm minorly confused: "pcre-light-0.3.1 depends on pcre-light-0.3.1 which failed to install."
18:43:30 <Dzlk> That seems to be what cabal install says when it fails. I've seen it for several things that failed for one reason or another.
18:43:47 <Dzlk> I suppose any package does, trivially, depend on itself. :)
18:43:50 <dons> ghc is a little smart, it is able to see that the element is constant here, so the filter turns into a take
18:43:54 <dons> main = print . sumU . filterU (< 100) $ replicateU (1000 :: Int) (1 :: Int)
18:44:00 <dons> but that's not quite the same thing.
18:44:12 <dons> it *does* get some loop transformations, where constant folding kicks in.
18:44:18 <atp> that's still brutally cool
18:45:07 <TomMD> Am I mistaken or does cabal ignore your PATH env?
18:45:10 <dons> it turns it into,
18:45:12 <dons> $wfold = \ (a :: Int#) (b :: Int#) -> case b of 1000 -> a _    -> $wfold (+# a 1) (+# wild_XQ 1)
18:45:20 <ronwalf> Anyone familiar with the datatypes ala carte paper?
18:46:11 <atp> hm
18:46:52 <atp> what is that wild_XQ bit?
18:50:32 <dons> oh, i was renaming things
18:50:35 <dons> that's the 'b'
18:50:40 <dons> or the 'a'?
18:50:44 <atp> haha
18:50:45 <atp> :)
18:50:48 <atp> that's what you get :p
18:51:41 <atp> i really do think algebraic manipulation is going to be haskell's killer feature
18:51:56 <atp> i mean, people will come for the parallel stuff, probably, in the short term
18:52:17 <atp> but long term, the ability to algebraically manipulate huge chunks of code will allow absolutely frightening optimizations
18:52:57 <tieTYT2> why is it *will* allow
18:53:01 <tieTYT2> why not *does* allow?
18:53:38 <tieTYT2> as in, why doesn't ghc take advantage of it already?
18:54:14 <atp> it's very complex
18:54:36 <atp> but as dons showed, it already does basic stuff
18:54:58 <atp> and there's some pretty scary stuff already in the works... fold fusion, supercompilation, etc
18:55:00 <monochrom> You can already do it yourself. Don't wait for the computer.
18:55:08 <atp> hehe
18:55:12 <atp> the big win here is for code reuse
18:55:52 <atp> lots of times when you're writing C or something similar, you find a library that works really well in the general case but in your particular instance you end up with poor performance because the compiler isn't smart enough to see how your code interacts with the library
18:55:53 <tieTYT2> just like with OO, yay!
18:55:56 <dons> well, the above thing also stripped out allocations of a bunch of arrays
18:56:07 <dons> and turned the data structure traversals into loops that sit in registers
18:56:15 <dons> so yeah, its maybe beyond basic already
18:56:18 <atp> that was pretty hard, i have to admit
18:56:24 <atp> (by hard i mean hardass)
18:58:46 <atp> tieTYT2: this is nothing like OO
18:59:17 <dons> its pretty aggressive, the optimisation changes a program that allocates 155M, and runs in 10 seconds
18:59:19 <monochrom> He means slow just like OO.
18:59:20 <dons>   main = print . sumU . filterU (< 100) $ replicateU (10000000 :: Int) (1 :: Int)
18:59:26 <dons> into one that runs in ./A  0.02s user 0.00s system 85% cpu 0.023 total
18:59:36 <atp> that's pretty nuts
18:59:42 <dons> and allocates 20k
19:00:30 <tieTYT2> in a bool guard, i have to refer to things in the where, right?
19:00:32 <atp> hey, speaking of which, do you know if it is possible to get the compiler to fail in compilation if it needs to heap allocate an object?
19:00:33 <tieTYT2> as opposed to a let
19:00:46 <atp> ie, can you force it to just use the stack if possible?
19:01:01 <atp> and fail if it can't figure out how?
19:01:11 <dons> mm.
19:01:19 <dons> no, you have to look at the asm
19:01:27 <atp> the reason i ask is because i've been thinking about writing an OS in haskell, with the garbage collector itself written in haskell
19:01:29 <dons> since you can't be sure there won't be a stack spill
19:01:33 <dons> just for running out of registers
19:01:40 <atp> well, stack is fine
19:01:42 <dons> well, there's been previous work on haskell kernels
19:01:43 <atp> it's heap i want to avoid
19:01:49 <hpaste>  kmcallister pasted "hs-plugins error with custom monad" at http://hpaste.org/7953
19:01:53 <dons> you can ensure there's no heap allocation by using unlifted kinds
19:02:01 <monochrom> eww
19:02:02 <dons> it'd be pretty wild to write a GC that way.
19:02:03 <atp> because until the garbage collector is online, you can't heap allocate
19:02:06 <atp> yeah
19:02:08 <atp> that's what i thought too
19:02:14 <atp> wild as in sexy
19:02:24 <atp> probably a bit slow, but who cares
19:02:26 <kmcallister> if anyone can help me with this error, i'd really appreciate it
19:02:46 <kmcallister> (above is a minimal case to produce the error, i believe)
19:02:57 <atp> i was playing around with implementing an mc^2 gc in haskell, just on an ST array
19:04:14 <atp> it would be a useful feature in general though, if you wanted to link in as little of the RTS as possible... haskell actually makes a very nice typesafe C
19:04:15 <kmcallister> also if anyone knows GHC well enough to tell me what kind of symbol "__stginit_mtlzm1zi1zi0zi0_ControlziMonadziError_" is and why it might not be linked in even though i'm importing Control.Monad.Error, that would also help
19:04:21 <atp> could be good for embedded work, if you could get more control
19:05:14 <monochrom> @remember atp haskell actually makes a very nice typesafe C
19:05:15 <lambdabot> It is stored.
19:05:22 <atp> it does!
19:05:39 <int-e> kmcallister: it's the initialisation function of the Control.Monad.Error module; you can add --make or -package mtl (I think) to the ghc command line to fix it
19:05:51 <monochrom> Yes, we only @remember true statements, such as...
19:05:57 <monochrom> @quote fromIntegral
19:05:58 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
19:06:26 <atp> now i'm going to have the ghostbusters... ahem... fromIntegral theme stuck in my head
19:06:27 <atp> thanks
19:06:27 <int-e> . o O ( @remember this statement is false )
19:06:33 <monochrom> haha
19:06:42 <atp> :)
19:07:28 <kmcallister> int-e, when i add "-package mtl" to the hs-plugins eval_ extra ghc flags list, nothing changes, and when i add "--make" hs-plugins gives a compilation error
19:07:38 <hpaste>  tieTYT pasted "(no title)" at http://hpaste.org/7954
19:07:47 <tieTYT2> i should have titled that..
19:07:53 <int-e> kmcallister: oh. mtl is right, it even says that in the symbol: replacing zi by a dot you get __stginit_mtl.1.1.0.0_Control.Monad.Error_
19:07:54 <tieTYT2> i wrote myIsInfixOf
19:07:59 <tieTYT2> can someone critique my work?
19:08:06 <tieTYT2> it seems a little verbose to me
19:08:15 <kmcallister> (i'm using --make to build the binary also)
19:08:37 <int-e> kmcallister: hmm, doesn't hs-plugins take a list of packages somewhere?
19:09:21 <atp> tieTYT2: stylistically, i would suggest lining up the guards
19:09:26 <atp> it's more readable
19:09:31 <kmcallister> it takes a list of modules, and a list of extra package.conf files
19:09:39 <kmcallister> i'm providing Control.Monad.Error in the list of modules
19:09:41 <tieTYT2> atp: ok, anything else?
19:09:58 <monochrom> Recall that "if x then True else False" is the same as "x".
19:10:00 <int-e> did you provide the path to the package configuration?
19:10:05 <kmcallister> i don't really know what to do with the latter (it might matter because i'm running ghc out of my homedir)
19:10:17 <tieTYT2> monochrom: you talking to me?
19:10:22 <atp> tieTYT2: yes he was
19:10:30 <monochrom> Another one is "if x then True else y" is the same as "x || y".
19:10:36 <tieTYT2> where is that relevant?
19:10:56 <atp> tieTYT2: instead of having function x | bool = True, just say function x = bool
19:11:16 <tieTYT2> yeah but where did i do that?
19:11:28 <monochrom> "if x then blah else False" is "x && blah"
19:11:38 <kmcallister> int-e, yeah
19:12:00 <tieTYT2> monochrom: i didn't use an if anywhere
19:12:07 <atp> guards are a kind of if
19:12:13 <int-e> kmcallister: hmm. I haven't played with hs-plugins enough to help then.
19:12:14 <monochrom> same difference
19:12:29 <tieTYT2> oh i think i get what you're saying
19:12:38 <tieTYT2> i can take advantage that this function returns Bool
19:12:39 <mar77a> :t bracket
19:12:42 <lambdabot> Not in scope: `bracket'
19:12:50 <tieTYT2> if it were returning a list or something though, i wouldn't be able to
19:12:57 <Maciej> tieTYT2: And I think the 'x == y' in the infix function is redundant
19:13:15 <tieTYT2> Maciej: because prefix does it, huh?
19:13:21 <kmcallister> int-e, yeah, it seems few people have :/
19:13:22 <kmcallister> thanks anyway
19:13:28 <tieTYT2> ok let me try again
19:13:34 <atp> also, you can define isInfixOf lazily using tails from Data.List, which is much shorter
19:13:36 <monochrom> If you have many cases, not just two, I wouldn't make my suggestion.  If the function returns something un-Bool, I wouldn't make my suggestion.
19:13:36 <Maciej> tieTVT2: right
19:13:41 <kmcallister> it's such a cool lib and perfect for what i'm doing, i wish i could make it work
19:14:25 <atp> just check to see if the string you are checking isPrefixOf "any" (hint hint) of tails
19:14:34 <atp> you can probably one-line it
19:15:01 <tieTYT2> one sec, information overload
19:15:28 <mar77a> the day i understand everything in that haskell irc bot dons coded
19:15:28 <monochrom> class Information where ... {- information overload -}
19:15:31 <mar77a> that day i will celebrate
19:15:37 <mar77a> for i will have learned haskell
19:15:44 <tieTYT2> ok so for the firs tthing
19:15:50 <atp> tieTYT2: don't worry, this is how you learn, you'll be fine :p
19:16:24 <tieTYT2> ok so i changed it to this: myIsInfixOf (x:xs) (y:ys) = myIsPrefixOf (x:xs) (y:ys) || myIsInfixOf (x:xs) ys						
19:16:40 <tieTYT2> that's the first suggestion, right?
19:17:14 <monochrom> myIsInfixOf (x:xs) (y:ys) = (x == y && myIsPrefixOf (x:xs) (y:ys)) || myIsInfixOf (x:xs) ys
19:17:44 <tieTYT2> monochrom: the x == y was redundant, remember?
19:17:55 <tieTYT2> it's already in the prefix def
19:17:59 <atp> myIsInfixOf xs ys = any (myIsPrefixOf xs) (tails ys)
19:18:03 <monochrom> Ah.
19:18:03 <atp> i think
19:18:13 <monochrom> Then alright!
19:18:13 <tieTYT2> atp: hadn't started on that suggestion
19:18:27 <atp> tieTYT2: sorry :)
19:19:01 <tieTYT2> but that is very interesting
19:19:05 <monochrom> Anyway, I like it. Certainly looks more like Prolog than C.
19:19:20 <tieTYT2> don't you have invalid # args to myIsPrefix?
19:19:25 <tieTYT2> i'll try your way
19:19:33 <atp> the magic of currying :)
19:19:36 <tieTYT2> oh
19:19:37 <atp> tails is in Data.List
19:19:41 <monochrom> It's ok, "any" wants it.
19:19:42 <tieTYT2> then no way in heck i could have come up with that
19:19:42 <atp> you'll need to import it
19:19:49 <tieTYT2> i don't even know tails
19:19:55 <atp> tieTYT2: you say that now.  give yourself a month.
19:20:15 <monochrom> atp: you say that now. give him a month. :)
19:20:27 <atp> hush :)
19:20:31 <tieTYT2> hah
19:21:11 <tieTYT2> also made this: myIsPrefixOf (x:xs) (y:ys) = x == y && myIsPrefixOf xs ys
19:21:23 <monochrom> yeah
19:21:42 <tieTYT2> that took a ridiculous amount of brain power than doing it in java would have :)
19:22:06 <tieTYT2> just weird how i'm learning to program as if i've never done it before
19:22:08 <monochrom> You haven't compiled it into your brain, that's all.
19:22:26 <atp> yeah, you just already understand imperative programming
19:22:26 <monochrom> I took a ridiculous amount of brain power to learn Java.
19:22:34 <int-e> kmcallister: hmm, seems to work for me though. I'm using linux, ghc 6.8.2, plugins 1.2, and I'm loading the plugin with  pdynload, also tried 'load' and 'dynload'.
19:22:36 <tieTYT2> probably
19:22:46 <atp> i taught my cousin haskell as his first programming language and he is really struggling with java at school
19:22:52 <atp> (now a CS major)
19:22:57 <tieTYT2> now to write isSuffixOf... i bet that one will have some crazy optimization that will be hard to think of
19:23:08 <SamB> atp: well, that's his problem right there
19:23:08 <monochrom> You have made your cousin's life miserable.
19:23:13 <atp> he writes great haskell though
19:23:14 <SamB> ("CS major")
19:23:22 <atp> ok, gotta go eat
19:23:23 <int-e> kmcallister: the plugin imports Control.Monad.Error, exports something using that module, and strace indicates that the HSmtl-1.1.0.0.o gets loaded
19:23:31 <TomMD> A friend of mine just bought SoE - is the library still maintained for that book?
19:23:56 <SamB> TomMD: there should be implementations that still work
19:24:02 <SamB> I think gtk2hs has one
19:24:10 <TomMD> That works
19:24:40 <encryptio> twitter architectures are the new monad tutorials
19:26:22 <dogbite> is there a function that applies map twice, so you don't have to write something like
19:26:28 <dogbite> > map (map (*2)) [[1,2],[3,4]]
19:26:30 <lambdabot>  [[2,4],[6,8]]
19:27:36 <hpaste>  int-e pasted "minimalistic hs-plugins test (for kmcallister)" at http://hpaste.org/7955
19:27:52 <encryptio> @hoogle (a -> b) -> [[a]] -> [[b]]
19:27:53 <lambdabot> No matches, try a more general search
19:30:44 <Maciej> dogbite: You can define it yourself: map2 = map . map
19:33:23 <bd_> @djinn (a -> b) -> [[a]] -> [[b]]
19:33:24 <lambdabot> -- f cannot be realized.
19:33:28 <bd_> hmmph
19:34:41 <dolio> djinn doesn't do lists.
19:35:36 <hpaste>  tieTYT pasted "myIsSuffixOf" at http://hpaste.org/7956
19:35:40 <tieTYT2> how about this?
19:36:18 <atp> looks good
19:36:25 <tieTYT2> shweet
19:36:36 <tieTYT2> i learned that myReverse from dibblego
19:36:46 <atp> do you understand why it works?
19:36:55 <tieTYT2> yeah
19:37:01 <tieTYT2> let me recheck the graphs
19:37:04 <atp> you don't need the first two cases
19:37:31 <atp> and even if you did, the second one should be myIsSuffixOf _ [] = False
19:37:35 <tieTYT2> one sec
19:37:44 <atp> (you certainly don't need the (x:xs)... you don't use either one!)
19:39:33 <atp> and incidentally you don't need the myReverse [] = [] line either
19:39:37 <tieTYT2> one sec
19:39:55 <atp> > foldl (flip (:)) [] []
19:39:56 <lambdabot>  []
19:39:59 <atp> see?
19:41:46 <tieTYT2> oh
19:42:25 <atp> > foldl (const undefined) [] []
19:42:26 <lambdabot>  []
19:42:46 <atp> yeah, it doesn't even evaluate the function if the list is null, as we should expect
19:43:00 <tieTYT2> ok
19:43:03 <tieTYT2> now as to how this works...
19:43:13 <[Justice]> > const 10
19:43:14 <lambdabot>  Add a type signature
19:43:19 <tieTYT2> i'm looking at this diagram: http://cale.yi.org/index.php/Fold_Diagrams
19:43:20 <lambdabot> Title: Fold Diagrams - CaleWiki
19:43:21 <dogbite> Maciej: thanks -- that's what i've done.  i guess a better question would ahve been how do I search for such a function
19:43:28 <[Justice]> > const (10 :: Int)
19:43:29 <lambdabot>  Add a type signature
19:43:37 <dogbite> many times i find that i'm defining something that's already in the standard haskell libraries
19:43:42 <tieTYT2> putting a (:) there already makes the numbers in reverse order
19:43:44 <atp> [Justice]: const takes two args
19:44:00 <tieTYT2> but then you gotta use the flip to make sure the x is on the left and the xs is on the right
19:44:02 <[Justice]> ?t const
19:44:02 <lambdabot> Maybe you meant: tell temp thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:44:11 <[Justice]> ?type const
19:44:13 <lambdabot> forall a b. a -> b -> a
19:44:27 <mar77a> can i define an infix function by default
19:44:29 <mar77a> something like
19:44:29 <tieTYT2> > foldl f x xs
19:44:30 <lambdabot>   Not in scope: `xs'
19:44:32 <tieTYT2> hm
19:44:39 <tieTYT2> oh
19:44:43 <tieTYT2> > foldl f x [1,2,3]
19:44:44 <lambdabot>  f (f (f x 1) 2) 3
19:44:49 <mar77a> let (plus) a b = a + b so that one can do 5 plus 2
19:44:55 <atp> mar77a: no
19:45:02 <mar77a> why not?
19:45:08 <atp> just how it is
19:45:11 <atp> write `plus` instead
19:45:22 <mar77a> is there any reason why you aren't allowed or given the option to do it
19:45:23 <hpaste>  morrow annotated "myIsSuffixOf" with "my is*fixOfs" at http://hpaste.org/7956#a1
19:45:37 <atp> mar77a: probably because it would lead to an ambiguous or overly complex grammar
19:46:11 <tieTYT2> i haven't learned zipwith
19:46:22 <atp> zipWith
19:46:31 <atp> it's just like zip, but with an added operation
19:46:37 <tieTYT2> haven't learned zip :P
19:46:40 <atp> > zipWith (+) [1, 2, 3] [2, 4, 5]
19:46:42 <lambdabot>  [3,6,8]
19:46:47 <tieTYT2> ok
19:46:49 <atp> > zip [1, 2, 3] [2, 4, 5]
19:46:52 <lambdabot>  [(1,2),(2,4),(3,5)]
19:46:59 <atp> very useful
19:47:17 <mar77a> > zipWith (:) ["h"] ["i"]
19:47:17 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:47:31 <atp> mar77a: ' not "
19:47:40 <mar77a> > zipWith (:) ['h'] ['i']
19:47:41 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
19:47:42 <atp> and it still won't work
19:47:45 <tieTYT2> :t and
19:47:47 <lambdabot> [Bool] -> Bool
19:47:48 <atp> ?type (:)
19:47:50 <lambdabot> forall a. a -> [a] -> [a]
19:47:56 <mar77a> ah
19:47:57 <atp> see, it needs a list as the second arg
19:48:04 <mar77a> > zipWith (:) ['h'] [['i']]
19:48:05 <lambdabot>  ["hi"]
19:48:07 <mar77a> :p
19:48:10 <tieTYT2> > zip [1,2,3] [2,4,5,6]
19:48:12 <lambdabot>  [(1,2),(2,4),(3,5)]
19:48:17 <tieTYT2> that's interesting
19:48:27 <atp> yeah... you can probably see how to define zip yourself
19:48:34 <atp> i bet you could write myZip pretty quickly
19:48:39 <tieTYT2> i'll try
19:48:48 <atp> good man :)
19:49:00 <mar77a> > zip [] []
19:49:01 <lambdabot>  []
19:49:11 <mar77a> > zip [2] []
19:49:12 <lambdabot>  []
19:49:23 <mar77a> > zip [] [2]
19:49:24 <lambdabot>  []
19:49:39 <tieTYT2> :t zip
19:49:41 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
19:49:46 <mar77a> zip _ [] = [] && zip [] _ = []
19:49:49 <tieTYT2> oh right
19:49:51 <mar77a> right
19:49:52 <tieTYT2> this don't need Eq
19:50:29 <mar77a> i bet my lungs zip is recursive
19:50:51 <atp> recursion in functional languages is a bit like goto in imperative ones
19:50:55 <atp> it's very powerful, but
19:51:04 <atp> using a lot of explicit recursion can make code fairly illegible
19:51:04 <mar77a> zip (x:xs) (y:ys) = (x,y) : zip xs ys
19:51:20 <atp> which is why we prefer using folds and maps and such whenever possible (and zip)
19:51:59 <atp> still, it's good to play with it because it helps you understand (just like goto) how things work "under the hood" so to speak
19:53:01 <mar77a> i can't belive this worked
19:53:03 <mar77a> first try
19:53:06 <mar77a> this is...amazing...
19:53:27 <hpaste>  morrow annotated "euler1 fusion" with "why -O2 instead of -O3?" at http://hpaste.org/7949#a3
19:53:41 <mar77a> myZip _ [] = []; myZip [] _ = []; myZip (x:xs) (y:ys) = (x,y) : myZip xs ys;
19:53:51 <SamB> Cale: do you know any good topology tutorials?
19:53:54 <atp> nice
19:54:10 <mar77a> i'm starting to digg this stiffo!
19:54:41 <atp> SamB: tutorial?
19:54:55 <atp> SamB: you should probably kick it old school and buy a book :p
19:55:12 <SamB> atp: what no PDFs?
19:55:15 <atp> there are
19:55:24 <atp> there's a pretty good algebraic topology book on line at cornell iirc
19:55:40 <atp> but it assumes fairly in depth knowledge of abstract algebra and general point-set topology
19:56:06 <SamB> hmm, I was hoping to go without the sets
19:56:14 <atp> hehe
19:56:23 <atp> sets are pretty important in topology
19:56:29 <SamB> oh?
19:56:31 <SamB> how so?
19:56:34 <atp> you'll need a good grounding in set theory
19:56:57 <SamB> just because topology is usually defined in terms of set theory doesn't mean ...
19:57:00 <atp> well, a topology is a set together with a collection of sets, to begin with
19:57:28 <tieTYT2> ok that took longer than i wanted
19:57:28 <atp> hm... well, i've never seen a treatment that doesn't base it on set theory, but there's a lot of math out there
19:57:40 <atp> tieTYT2: that's ok
19:57:41 <atp> did you get it?
19:57:47 <atp> split
19:57:51 <hpaste>  tieTYT pasted "myZip" at http://hpaste.org/7957
19:57:52 <SamB> atp: I could try to fake knowing set thoery
19:57:58 <tieTYT2> i think so
19:58:00 <tieTYT2> it works
19:58:12 <tieTYT2> afaict
19:58:17 <SamB> atp: though it won't work on the law of excluded middle
19:58:28 <atp> heh
19:58:37 <tieTYT2> ah i don't need those first parens
19:58:47 <SamB> (I've decided I don't believe in the law of excluded middle)
19:59:24 <atp> what if the two lists don't have the same number of elements?
19:59:31 <tieTYT2> hits the last case
19:59:33 <tieTYT2> returns []
19:59:46 <atp> that's true
19:59:56 <atp> i would have done myZip _ [] = []
20:00:00 <atp> myZip [] _ = []
20:00:15 <atp> and myZip (x:xs) (y:ys) = (x, y) : myZip xs ys
20:00:20 <atp> but it doesn't actually matter
20:00:45 <tieTYT2> yours is easier to think about
20:00:50 <tieTYT2> i like it better
20:00:55 <SamB> @ask Cale know any good introductions to topology?
20:00:55 <lambdabot> Consider it noted.
20:01:03 <tieTYT2> much less verbose too
20:01:13 <atp> it's actually the same number of lines
20:01:15 <SamB> @tell Cale preferably free ;-)
20:01:15 <lambdabot> Consider it noted.
20:01:25 <tieTYT2> yeah but i still think it's easier to understand
20:01:35 <atp> anyway it's been nice chatting with you... my gf is bugging me to get into bed
20:01:41 <tieTYT2> ok see ya
20:01:42 <tieTYT2> ttyl
20:01:42 <Cale> SamB: hmm...
20:01:42 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:01:44 <atp> sure
20:01:45 <tieTYT2> i'm going home too
20:01:47 <tieTYT2> thanks
20:01:50 <atp> bye all
20:04:12 <[Justice]> > const 1 2
20:04:13 <lambdabot>  1
20:04:20 <[Justice]> @src const
20:04:20 <lambdabot> const x _ = x
20:04:50 <[Justice]> > const 1 (error "oops")
20:04:52 <lambdabot>  1
20:05:01 <Cale> SamB: Well, I'm not sure about introductory materials, but it would probably be good to know about Hatcher's Algebraic Topology, if you don't already.
20:06:09 <greendemon> do y'all have recommendations for an interface to a sqlite database?
20:07:40 <greendemon> I'm leaning towards HDBC, but I thought I'd ask for suggestions
20:07:47 <greendemon> before I started installing stuff
20:07:51 <Cale> SamB: http://www.maths.tcd.ie/~dwilkins/Courses/212/ looks like it might be useful.
20:07:52 <lambdabot> Title: Course 212 - Topology
20:08:10 <Cale> (but I just skimmed it now, so I'm not sure
20:08:11 <Cale> )
20:10:42 <greendemon> Has anyone here used HDBC before?
20:11:01 <newsham> are the applicative brackets used in the paper defined in any of the std libs?
20:11:12 <newsham> ie:   [ f a b c ] = pure f <*> a <*> b <*> c
20:11:31 <hpaste>  morrow annotated "myZip" with "with parallel list comprehensions" at http://hpaste.org/7957#a1
20:11:35 <newsham> also why isnt there an automatic instance of Applicative for all monads?
20:12:10 <hpaste>  morrow annotated "myZip" with "oops, forgot the '" at http://hpaste.org/7957#a2
20:12:46 <Saizan> newsham: it would require overlapping and undecidable instances
20:13:05 <newsham> which ones would overlap?
20:14:01 <greendemon> ok thanks, just thought I'd ask
20:14:31 <newsham> (also it seems like there are a lot more instances of MonadPlus than Control.Applicative.Alternative, but the instances of Alternative look identical to their MonadPlus definitions)
20:14:41 <Saizan> newsham: instance Monad m => Applicative m where.. overlaps with every other instance for Applicative..
20:15:08 <newsham> saizan: all of the other instances for applicative (except ((,) a) which I dont think overlaps) are defined the same way, no?
20:15:17 <newsham> ie, [], IO, ((->) a) and Maybe
20:15:40 <Saizan> yeah
20:16:02 <newsham> so if you took away their current definitions and made a general definition for monads, there would be no overlap, right?
20:16:23 <Saizan> but that instance overlaps even with instance Applicative Foo where, even if Foo is not a Monad
20:16:57 <newsham> I dont quite understand,  I guess I could just try it out and see what happens
20:17:04 <newsham> anyway, wife calls.. bbl.
20:17:09 <SamB> newsham: that would effectively promote overlapping typeclasses to part of the Haskell language, rather than an extension
20:17:18 <Saizan> "overlapping" doesn't take in consideration instance context, only if the arguments unify
20:18:02 <EvilTerran> they'd be undecidable too, wouldn't they?
20:18:12 <SamB> EvilTerran: I guess so
20:18:19 <Saizan> yeah
20:18:47 <SamB> and to maintain backwards compatability they'd also need to be incoherant
20:19:17 <Saizan> really?
20:20:35 <SamB> well, yes -- what if some user code has a type that has both an Applicative and a Monad instance in it?
20:21:13 * SamB hadn't originally noticed that Applicative was the class under consideration, was thinking of Functor...
20:21:29 <sjanssen> SamB: it doesn't really matter though, all the issues are the same
20:21:46 <Saizan> Applicative m is surely more general, so it will just use the user-defined instance
20:21:52 <SamB> except there's a lot less Applicative-using code out there
20:22:13 <SamB> Saizan: oh, point
20:22:26 <Saizan> you need IncoherentInstances if you have two instances at the same level of generality, afaiu
20:22:37 <EvilTerran> the only trouble would be if they'd defined the same instance themselves
20:22:47 <SamB> I was thinking that IncoherentInstances was needed whenever your instances weren't confluent
20:22:54 <EvilTerran> or done something else with an instance ... => Monad m
20:22:58 <mar77a> ?quote
20:22:58 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
20:23:13 <mar77a> ?quote mar77a
20:23:13 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
20:23:23 <EvilTerran> python on... apache? no, wait, that's a helicopter.
20:23:34 <mar77a> django
20:23:40 <mar77a> ?quote 77
20:23:40 <lambdabot> No quotes match.
20:24:18 <SamB> hmm. What would a Monty Python skit about Snakes on a Plane be like?
20:25:16 <EvilTerran> british
20:42:56 <Armored_Azrael> Hey, does anyone know how to cause serialization/deserialization of functions in yhc?
20:52:45 <newsham> so could anyone tell me how you would go about implementing the Control.Applicative brackets?
20:53:20 <dolio> The typeclass hack?
20:53:24 <newsham> yah
20:53:29 <sjanssen> newsham: there is a page on the wiki
20:53:45 <sjanssen> @google idiom brackets inurl:haskellwiki site:haskell.org
20:53:46 <lambdabot> http://www.haskell.org/haskellwiki/Idiom_brackets
20:53:47 <lambdabot> Title: Idiom brackets - HaskellWiki
20:54:13 <newsham> thank you
20:59:53 <tieTYT> depending on how you look at it, there's no such thing as function overloading in haskell, huh?
21:00:07 <edwardk> typeclasses
21:00:32 <tieTYT> hm, haven't learned those yet
21:00:43 <newsham> > show 5
21:00:44 <lambdabot>  "5"
21:00:49 <newsham> > show "5"
21:00:50 <lambdabot>  "\"5\""
21:01:01 <edwardk> > show 5 ++ " " ++ show "Hello"
21:01:03 <lambdabot>  "5 \"Hello\""
21:01:09 <edwardk> @type show
21:01:11 <lambdabot> forall a. (Show a) => a -> String
21:01:24 <newsham> ?instances Show
21:01:25 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
21:01:35 <edwardk> all of those things are 'show'able
21:01:37 <newsham> (no ZipList :(
21:01:42 <tieTYT> interesting
21:04:42 <newsham> > mconcat $ map Sum [3..10]
21:04:43 <sjanssen> @instances-importing Show Control.Applicative
21:04:43 <lambdabot>  Sum {getSum = 52}
21:04:44 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
21:04:59 <sjanssen> @instances-importing Control.Applicative Show
21:05:00 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
21:05:21 <newsham> > ZipList [1,2,3]  -- sjanssen
21:05:22 <lambdabot>   add an instance declaration for (Show (ZipList t))
21:05:39 <newsham> > getZipList $ ZipList [1,2,3]
21:05:40 <lambdabot>  [1,2,3]
21:06:28 <newsham> > getZipList $ pure (+) <*> [1,2,3] <*> [10,20,30]
21:06:29 <lambdabot>  Couldn't match expected type `ZipList a'
21:06:37 <sjanssen> newsham: huh, did you make a bug report about that?
21:06:37 <newsham> > getZipList $ pure (+) <*> ZipList [1,2,3] <*> ZipList [10,20,30]
21:06:39 <lambdabot>  [11,22,33]
21:06:46 <sjanssen> newsham: it is clearly just some forgotten 'deriving'
21:06:48 <newsham> sjanssen: no I didnt.  I suppose I should
21:07:38 <sjanssen> newsham: I'm not terribly surprised -- I just went through mtl and added Applicative instances.  I'm amazed nobody has done this yet
21:08:14 <newsham> i'm just learning how to use these things
21:08:53 <newsham> hmm.. i dont remember where to file bugs at
21:09:08 <sjanssen> @google ghc trac
21:09:10 <lambdabot> http://hackage.haskell.org/trac/ghc/
21:09:10 <lambdabot> Title: GHC - Trac
21:09:25 <newsham> ty
21:12:25 <newsham> filed
21:17:28 <Saizan> uhm, "applicative programming language" is a synonym of FP?
21:17:51 <SamB_XP> hmm, probably not quite
21:18:11 <SamB_XP> but they are obviously closely related...
21:19:10 <newsham> why is  pure (.) <*> u <*> v <*> w = u <*> (v <*> w) ?
21:19:39 <newsham> err.. nevermind.
21:20:11 <newsham> i like askin gstupid questions, cause even though i couldnt figure out the answer before I figure out as soon as I ask them on irc
21:22:31 <hpaste>  tieTYT pasted "myLines" at http://hpaste.org/7958
21:22:35 <tieTYT> how's this look?
21:23:41 <SamB_XP> @type pure
21:23:42 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
21:23:49 <mmorrow> @seen dons
21:23:50 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
21:23:57 <mmorrow> um
21:24:03 <SamB_XP> @type (<*>)
21:24:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:24:08 <Saizan> any work on explointing parallelism from applicative functors?
21:24:18 <mmorrow> dons: why do you use -O2 instead of -O3 with gcc?
21:25:15 <mmorrow> or directed to anyone
21:26:44 <mmorrow> i can't figure it out. either (1) he's using -O2 because he want to compare the haskell gen code to that of gcc at that partic optim level, or (2) there is some reason that -O2 is better than -O3 for code that is output by ghc
21:27:04 <mmorrow> if (2), then I want to know!
21:27:52 <Saizan> i've seen him use -optc-O3 in general
21:28:00 <mmorrow> hmm
21:28:03 <Smokey`_> mmorrow: -O3 uses optimizations that give a space-speed tradeoff (eg: unrolls loops, generates vectorised code, etc)
21:28:22 <mmorrow> ahh, interesting.
21:28:24 <Smokey`_> forces inlines functions as well
21:28:29 <Smokey`_> thus generating larger binaries
21:29:21 <tieTYT> tieTYT pasted "myLines" at http://hpaste.org/7958 :P
21:29:22 <mmorrow> so, since ghc is not as far along with vectorization as gcc, perhaps code gen by gcc -O2 would be more comparable to code gen by ghc's nativegen
21:29:41 <Smokey`> that's a pretty safe assumption.
21:29:45 <mmorrow> OR, should I read his use of -O2 as his preference
21:29:54 <mmorrow> wrt the space/speed tradeoff
21:30:29 <mmorrow> i guess it could be both, but that answers my wuestion
21:30:34 <mmorrow> question
21:30:59 <mmorrow> Smokey`: ah, missed you response
21:31:00 <Smokey`> wow, I answered a question in #haskell ;)  I feel slightly proud, even if it's related to gcc :)
21:31:13 <mmorrow> :)
21:31:24 <sjanssen> mmorrow: sometimes gcc -O3 and ghc don't play nicely
21:31:38 <mmorrow> interesting, why?
21:31:43 <mmorrow> todo with the mangler??
21:31:51 <sjanssen> I believe so
21:32:36 <mmorrow> everytime i look at the mangler, my eyes bleed with dread
21:33:04 <mmorrow> but then i'm like, perl's great
21:39:14 <mmorrow> while on topic, for the brave: http://darcs.haskell.org/ghc/driver/mangler/ghc-asm.lprl
21:42:06 * sclv idly wonders if the mangler couldn't be rewritten in haskell with an asm parser to become slightly less evil.
21:42:34 <mmorrow> i think about that all the time
21:42:57 <mmorrow> ideally though, it would remain evil in all the right ways
21:43:24 <mmorrow> exterminating ccalls with extreme prejudice!!@
21:43:30 <SamB_XP> I was under the impression they wanted to get rid of the mangler?
21:43:58 <bos> wow, par isn't very well behaved on my laptop.
21:44:04 <mmorrow> as long as ghc can go through C, it'll need a mangler/mangler equvalent
21:44:15 <bos> a butt-simple program segfaults about 80% of the time when I run it.
21:44:18 <SamB_XP> only with tables-next-to-code
21:44:35 <mmorrow> the only other solution is to put the whole program in a single C function, then you can use gotos
21:44:44 <mmorrow> (for tail calls)
21:45:06 <SamB_XP> oh, er, isn't there a trampoline somewhere?
21:45:17 <mmorrow> ickk!
21:45:25 <sjanssen> bos: segfaults?  I haven't heard that one before
21:45:25 <bos> ooh, it's crashing in the garbage collector.
21:45:29 <SamB_XP> possibly an empire state building?
21:46:07 <sclv> I assume that if the c backend becomes only for bootstrapping, the mangler can stop worrying about lots of things though.
21:47:03 <mmorrow> ghc's native codegen doesn't use (or need) the mangler
21:47:30 <mmorrow> thankfully
21:50:15 <newsham> hmm, I'm trying to get this code to ocmpile and having some problems:  http://conal.net/blog/posts/beautiful-differentiation/
21:50:16 <lambdabot> Title: Conal Elliott  Blog Archive  Beautiful differentiation
21:50:27 <newsham> first it seems I need a Show and Eq for these classes?
21:50:41 <newsham> when I provide dummies for those I get some other problems
21:50:55 <newsham> anyone try to get these working?  do I need nonstandard stuff?
21:51:18 <conal> newsham: did you grab the files from the post?
21:51:26 <newsham> there's a file there?
21:51:48 <conal> newsham: yeah.  two.  see the edits near the top of the post.
21:52:06 <newsham> ooh, missed those earlier.  thought that was unimportant meta data :)
21:52:10 <newsham> ty
21:52:15 <conal> :)
21:52:33 <mmorrow> here's an example of using gotos w/in a single C function to implement tail calls (the fun starts on line 187): http://darcs.haskell.org/ghc/rts/Interpreter.c
21:53:02 <conal> newsham: now i see it's easy to miss.  i'll add a paragraph at the end.
21:53:43 <mmorrow> (the fun lasts until line 1458 (1459==EOF))
21:55:18 <bos> sjanssen: http://hackage.haskell.org/trac/ghc/ticket/2317
21:55:19 <lambdabot> Title: #2317 (Garbage collector crashes in simple parallel sorting program) - GHC - Tra ...
21:55:45 <bos> i don't think i'll be writing about parallel programming in haskell just yet, then.
21:56:03 <Smokey`> mmorrow: that's ... horrid
21:56:37 <Smokey`> I thought I had seen some scary code in my ventures, but I think that tops the list.
21:57:33 <mmorrow> think of the labeled blocks as functions, gotos as tail calls, and the C function as a whole an a mutually recursive collection of these functions
21:57:41 <mmorrow> then it's pretty!
21:57:58 <sclv> it is. my heart just skipped a few beats actually..
21:58:00 <mmorrow> ...as a whole as...
21:58:07 <Smokey`> lol
21:58:17 <mmorrow> :)
21:58:58 <sclv> its really the way the cases and the labels interacts that does it I think.
21:59:36 <sclv> (learning about duffs device many years ago was my first Zounds! Programming! moment, I think)
22:01:38 <mmorrow> (just to ensure no miscommunication) "...as a whole as..." wasdoing s/an/as/ to a prev stmt of mine (not sure if this needs mentioning)
22:02:58 <mmorrow> sclv: definitely. the connection between local interactions and the global whole is definitely zounds
22:03:41 <mmorrow> (and vice-versa)
22:09:32 <dmwit> barf("interpretBCO: fell off end of the interpreter");
22:09:33 <mmorrow> this describe what it's actually doing (describes the info tables, application, etc...): http://citeseer.ist.psu.edu/682782.html
22:09:35 <lambdabot> Title: Making a Fast Curry (ResearchIndex)
22:09:45 <mmorrow> interesting stuff
22:11:00 <sclv> I wonder how massive a performance hit we'd get from a self-hoisting rts.
22:13:33 <mmorrow> C-- seems to be the being-pursued path
22:13:50 <mmorrow> it allows all the stuff you wish C did
22:14:41 <dmwit> And none of the stuff that makes C horrid.
22:15:51 <mmorrow> yeah, C-- is pretty cool. been reading up on it...: http://www.cminusminus.org/
22:15:53 <lambdabot> Title: C-- Home
22:21:52 <dmwit> ?src unwords
22:21:52 <lambdabot> unwords [] = ""
22:21:52 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
22:22:27 <dmwit> ?src intersperse
22:22:27 <lambdabot> intersperse _   []     = []
22:22:27 <lambdabot> intersperse _   [x]    = [x]
22:22:27 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
22:22:54 <dmwit> ?src concat
22:22:55 <lambdabot> concat = foldr (++) []
22:27:53 <[Justice]> hmmm SPJ is listed as an author on the C-- lang spec
22:28:37 <dmwit> As I understand it, a variant of C-- is used in GHC.
22:28:44 <dmwit> So it doesn't surprise me.
22:31:10 <cjs> Is there a quick way for me to figure out whether I'm on a Windows or a Unix box?
22:31:22 <ibid> it isn't obvious?
22:31:30 <cjs> Not to my Haskell program. :-)
22:31:34 <ibid> ah :)
22:32:15 <ibid> the trouble there is that many unix programs are ported to windows by adding a unix-like layer on top of windows
22:32:55 <ibid> so looking for unix-like stuff may lead to false positives
22:32:57 <sclv> #if defined(mingw32_HOST_OS) || defined(__MINGW32__)
22:33:09 <ibid> look for something uniquely windows?
22:33:23 <ibid> sclv: that works if the compilation environment is mingw
22:33:38 <ibid> i think that need not be the case even for haskell stuff
22:34:04 <cjs> No instance for (Show Distribution.System.OS)
22:34:07 <ibid> cjs: why do you need to know anyway?
22:34:07 <cjs> Ok, what's up with that?
22:34:20 <cjs> So I can use a different path for gnuplot depending on which system I'm on.
22:34:38 <ibid> cjs: isn't it better to let the builder configure that path anyway?
22:34:42 <sclv> hmm.. that's what filepath uses to decide if it wants to include posix or windows...
22:34:49 <ibid> cjs: that sort of system-type kluging is brittle
22:35:11 <cjs> ibid: Yes. But this is a less brittle kludge than the current hardcoding of it to one value. One step at a time....
22:35:27 <ibid> cjs: use autoconf? :)
22:36:08 <ibid> bbl
22:37:20 <cjs> One step at a time. I have a choice at this point. I can leave it as it is, in which case it doesn't work at all. I can change the path to work only for Unix, in which case I break the Windows version. I can do the quick OS hack, at the cost of a couple of extra minutes, and move slightly forward in improving functionality.
22:37:59 <cjs> I suppose I could spend a few hours packaging it with Cabal or whatever, but then again, I don't even know if this works at all yet; I've never successfully called the main plot function. So spending hours on packing would seem a bit pointless at this point.
22:44:47 <tieTYT> square (x:xs) = x**2 : square xs
22:44:49 <agentzh> hi, how can i produce a profiling version for a cabal package?
22:45:03 <tieTYT> this isn't tail recursion right?  does that mean it's space is not constant?
22:45:30 <dmwit> Yes, it's tail recursion.
22:45:35 <sjanssen> cjs: is your program already package with Cabal?
22:45:35 <dmwit> It's also guarded recursion.
22:45:46 <dmwit> tieTYT: This means that it has nice lazy properties.
22:45:55 <sjanssen> cjs: oh, it isn't, nevermind
22:45:58 <dmwit> tieTYT: I'm not sure what you mean by "constant space" here.
22:46:14 <sjanssen> cjs: you can use Cabal configurations to conveniently detect which OS you're on
22:46:17 <Saizan> dmwit: how can it be tail-recursion if it's guarded?
22:46:17 <tieTYT> why is it tail recursive?  Isn't the last function called ":" ?
22:46:29 <dmwit> err...
22:46:42 <sjanssen> tieTYT: that isn't tail recursive
22:47:03 <sjanssen> cjs: the space occupied by that function depends on the consumer of the output
22:47:44 <sjanssen> I mean tieTYT, of course
22:47:52 <quicksilver> cjs: why not call gnuplot without a path at all
22:48:23 <quicksilver> cjs: it is the program user's responsibility to negotiate with the OS's default path mechanisms and arrange for gnuplot to be in the system PATH
22:48:35 <quicksilver> cjs: that is an OS neutral solution.
22:48:55 <tieTYT> sjanssen: why?
22:49:16 <tieTYT> so like
22:49:23 <cjs> quicksilver: the other guy using this apparently needs the path. A lot of windows users don't keep everything in the path, because it would be miles long.
22:49:32 <cjs> Anyway, I need OS info for the tempfile path, too.
22:49:45 <tieTYT> if I do head (square [2,3,4,5]), it'll only do 2**2?
22:49:59 <cjs> Odd that openTempFile doesn't have some sort of option to use a default path.
22:50:17 <Saizan> tieTYT: yeah, that's because of lazyness :)
22:50:36 <quicksilver> cjs: then supply a windows batch file to set the win32 PATH
22:50:41 <sclv> take 10 $ square [1...100000] -- this would only run square on the first 10 at all, and furthermore, until you examined any given element it wouldn't run ** on it.
22:50:46 <sjanssen> tieTYT: correct, this is called laziness, one of the most important features of Haskell
22:51:03 <quicksilver> cjs: and LART your windows users for refusal to use the system supplied mechanism to solve the problem.
22:51:05 <sclv> cjs: there's a system-independent tempfile path built in to the libs, I think..
22:51:17 <sjanssen> @hoogle temp
22:51:18 <lambdabot> Distribution.Extension.TemplateHaskell :: Extension
22:51:18 <lambdabot> Language.Haskell.Extension.TemplateHaskell :: Extension
22:51:18 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
22:51:23 <tieTYT> so what's the first step to that?  does it become head (square [2])?
22:51:27 <sclv> oh wait, that's openTempFile
22:51:37 <quicksilver> getTemporaryDirectory :: IO FilePath
22:51:42 <sclv> ah there we go
22:51:53 <sjanssen> tieTYT: not exactly
22:52:00 <sjanssen> tieTYT: evaluation is driven by pattern matching
22:52:05 <quicksilver> tieTYT: in some sense it becomes head (4 : square [3,4,5])
22:52:27 <quicksilver> the definition of square is unrolled just enough to produce the constructor (:)
22:52:28 <sclv> well, head (2**2 : square [3,4,5])
22:52:33 <quicksilver> which head is looking for.
22:52:35 <sjanssen> so in the first step, head will examine (square [2, 3, 4, 5]) to see whether it is an empty list or whether it has an element
22:52:54 <sjanssen> to do this, square examines [2, 3, 4, 5] to see if it is empty or not
22:53:39 <quicksilver> cjs: I don't really see how detecting the OS will solve your problem anyway.
22:53:46 <sjanssen> it isn't of course, and we know that "square (x:xs) = x ** 2 : xs", so (square [2, 3, 4, 5]) reduces to (2 : square [3, 4, 5])
22:54:03 <sjanssen> erm, I mean (2 ** 2 : square [3, 4, 5])
22:54:13 <cjs> It solved my problem perfectly.
22:54:20 <sjanssen> and head analyzes that, and sees that 2 ** 2 is the first element and returns it
22:54:29 <quicksilver> cjs: You have two kinds of users, sensible ones and boneheadedly stupid ones. The sensible ones will have gnuplot on their path. The BHS ones will not. In the latter case you'll need an explicit path to gnuplot (command line parameter? config file?)
22:54:36 <quicksilver> cjs: to me this seems orthogonal to OS.
22:54:42 <hpaste>  cjs pasted "os detection" at http://hpaste.org/7959
22:54:51 <quicksilver> cjs: you can just as well have a win32 user who does have gnuplot on path as a linux user who does not.
22:55:04 <cjs> Actually, there are only two users, me and the guy who wrote this originally.
22:55:26 <quicksilver> then you might as well check if the user ID is cjs or not.
22:55:26 <tieTYT> so, how does it know when it's processed enough?  does it constantly poll the function up the stack asking if it needs to do anything else?
22:55:47 <cjs> And, for the moment, it's very important that I keep compatability with his version so he'll accept my changes.
22:55:56 <cjs> We can work on attitude adjustments or whatever later.
22:56:05 <quicksilver> cjs: and if a win32 user installs gnuplot in Program Files/gnuplot-4.2.3/ ?
22:56:14 <cjs> Good programming only comes if you set up the good politics first.
22:56:18 <quicksilver> or Program Files/GNU/gnuplot-4.2.3/
22:56:24 <quicksilver> or any other of a million combination.
22:56:48 <quicksilver> hardcoding a particular choice of path based on the users OS just doesn't seem sane. *shrug*
22:56:53 <cjs> It breaks. Fortunately, no such users of this software exists.
22:57:11 <dmwit> tieTYT: It creates a "thunk" which, when evaluated, yields the next constructor and as many thunks as that constructor takes.
22:57:12 <sclv> cjs: http://www.haskell.org/ghc/docs/6.8.2/html/users_guide/ghci-cygwin.html
22:57:13 <quicksilver> then you didn't really want to check the OS. You just wanted to check if it was him or you :)
22:57:13 <lambdabot> Title: 12.5. Using GHC (and other GHC-compiled executables) with cygwin, http://tinyurl.com/56luhl
22:57:24 <cjs> quicksilver: you're seriously proposing that I spend several hours on a packaging system for what's essentially a little hack?
22:57:27 <dmwit> tieTYT: Each time you pattern match (or otherwise demand the constructor), it evaluates the thunk.
22:57:28 <quicksilver> no.
22:57:35 <sclv> there it explains that ghc always builds in mingw
22:57:41 <quicksilver> I'm suggesting any number of other simple hacks which don't involve cabal.
22:57:42 <cjs> quicksilver: yeah, that probably would have done the trick, too.
22:58:02 <quicksilver> I'm just saying switching based on OS is a really bad hack ;)
22:58:10 <tieTYT> so in my example, what are the tunks?
22:58:11 <halberd> Suppose L is a context free language--is the set of all strings x such that there is some string y such that xy is in L, necessarily also context free?
22:58:12 <tieTYT> thunks
22:58:14 <cjs> Ok, I'm all ears. But it's got to work on his system as a drop-in, without him having to fiddle with batch files and the like.
22:58:33 <dmwit> tieTYT: Your example is (head (square [2..5]))?
22:58:37 <tieTYT> yes
22:59:02 <cjs> Anyway, any more of this would be for #haskell-overflow....
22:59:12 <dmwit> tieTYT: (head (square [2..5])) is the first thunk created.
22:59:17 <dmwit> tieTYT: When it is evaluated...
22:59:48 <dmwit> tieTYT: The call to "head" means that the thunk (square [2..5]) is evaluated.
23:00:07 <mmorrow> tieTYT: re: "how does it know when it's processed enough?..": it's the inverse situation. the call to square xs creates a thunk, then evaluating the thunk created by applying head to the first thunk evaluates to a value (the head) and another thunk, and so on..
23:00:21 <mmorrow> yeah, what dmwit said
23:00:31 <dmwit> tieTYT: This creates the thunk ((:) (thunk 2) (thunk [3..5])).
23:00:35 <quicksilver> cjs: I'd just hardcode a list of paths to try without trying to detect OS
23:00:52 <cjs> That's a reasonable thought.
23:00:52 <tieTYT> dmwit: do you mean thunk 2**2?
23:00:56 <quicksilver> cjs: "gnuplot","wgnuplot.exe","/Program Files/gnuplot/wgnuplot.exe"
23:01:10 <tieTYT> oh no
23:01:11 <tieTYT> i gotcha
23:01:15 <Smokey`> is anyone here familiar with the LGPL?
23:01:18 <quicksilver> cjs: and I'd contemplate in future a config file or command line option.
23:01:22 <dmwit> tieTYT: Yeah, we haven't even gotten to square yet. =P
23:01:24 <quicksilver> cjs: but only if it's worth it :)
23:01:29 <Smokey`> and by familiar, I mean 'very' familiar.
23:01:41 <dmwit> tieTYT: Okay, continuing...
23:01:58 <cjs> quicksilver: We're in violent agreement here.
23:02:12 <dmwit> tieTYT: The call to square now sees the (:) constructor, and immediately returns ((:) (2**2) (square [3..5])).
23:03:06 <dmwit> tieTYT: Then we finally get to the call to "head".  head consumes the (:) constructor (the only thing we've actually calculated yet!), and evaluates the thunk that is the first argument to (:).
23:03:12 <dmwit> tieTYT: So (2**2) gets evaluated.
23:03:17 <tieTYT> does it only see the (:) constructor and use ONLY that to pattern match?
23:03:24 <dmwit> yes
23:03:41 <mmorrow> tieTYT: since (pretty much) every evaluation creates a thunk, sometimes, when talking about such things, a thunk maybe be referred to as if it were already the value which will overwrite it in the interest of concision
23:03:47 <mmorrow> confusing? yes!
23:04:01 <dmwit> In "head (x:xs) = x", what happens is that the list gets evaluated to its constructor, then the thunks for the front and end of the list get bound to "x" and "xs".
23:04:22 <dmwit> s/its constructor/its (:) constructor/
23:05:17 <dobblego> any of you at JAOO Brisbane?
23:05:18 <tieTYT> why does xs need to be bound?
23:05:18 <dmwit> tieTYT: It doesn't.
23:05:18 <dmwit> head (x:_) = x -- is just as good
23:05:26 <tieTYT> ok
23:05:40 <Saizan> tieTYT: in practice every not-yet-evaluated thunk is a pointer to the code to evaluate it, so you can suspend evaluation each time you find a pointer like that
23:06:21 <dmwit> It's actually a pretty cool implementation.
23:06:29 <dmwit> At first, a thunk is a pointer to code that should be executed.
23:06:48 <dmwit> When you first evaluate the thunk, though, it overwrites the code that's pointed to.
23:07:00 <dmwit> It overwrites the code with new code that does nothing, returning the value instantly.
23:07:40 <dobblego> Erik Meijer gave a talk on "Why Functional Programming Still Matters"; it was good :)
23:08:12 <tieTYT> dmwit: I think i need to try an example out myself
23:08:28 <quicksilver> dmwit: I don't believe it does, in GHC at least.
23:08:43 <quicksilver> dmwit: I believe it completely overwrites the code with the value.
23:08:52 <quicksilver> dmwit: no "wasted" thunk pointer to dummy code
23:08:59 <dmwit> By now it does, by taking advantage of pointer tagging.
23:09:05 <dmwit> But I'm pretty sure that's what it used to do.
23:10:33 <tieTYT> so does tail (square [2..5]) still evaluate to 2**2?
23:10:54 <sclv> tieTYT: it shouldn't, no.
23:11:30 <sclv> tieTYT: it shouldn't, no.
23:11:46 <sclv> > tail [undefined,1,2,3] -- erm, I meant this.
23:11:47 <lambdabot>  [1,2,3]
23:11:54 <tieTYT> how does it skip the 2?
23:12:01 <tieTYT> clearly i don't get it
23:12:16 <dmwit> tieTYT: The thunk (2**2) gets bound to x (in tail (x:xs)), then ignored.
23:12:30 <tieTYT> ok
23:12:33 <tieTYT> that's what i was asking
23:12:36 <tieTYT> thanks
23:12:45 <dmwit> It doesn't evaluate (2**2), but it does form the (2**2) thunk.
23:13:08 <tieTYT> ok
23:13:42 <tieTYT> so you get tail [2**2..5**2] (if that's even valid format)?
23:13:47 <sclv> and of course you have to think about this, eventually, for performance, but in practice (outside the presence of exceptions, undefined, etc.) the results should be equal whether or not it evailuates it.
23:14:00 <tieTYT> and if it, for example, needs to print that, it'll evaluate all those **'s
23:14:19 <tieTYT> and if you wrap a tail around it instead, it'll result in 2**2
23:14:28 <sclv> exactly! but unless you're thinking about particular issues, you can sort of forget all this most of the time.
23:14:46 <tieTYT> i've gotten pretty far without understanding it very well
23:14:50 <mmorrow> um, do s/evaluation/application/ in "tieTYT: since (pretty much) every evaluation..."
23:15:06 <tieTYT> i still feel like i don't.  My main problem is I don't always get when something *needs* to be evaluated
23:15:22 <dmwit> tieTYT: What happens to (tail (square [2..5])) is closer to becoming (square [3..5]) than it is to becoming (tail [2**2, 3**2, 4**2, 5**2]).
23:16:01 <dmwit> Which might seem a little magical at first.
23:16:08 <mmorrow> tieTYT: when it needs to be printed!
23:16:13 <dmwit> But look at the definition of square.
23:16:17 <newsham> http://www.icfpcontest.org/  finally updated with this years dates
23:16:18 <lambdabot> Title: ICFP Programming Contest 2008
23:16:19 <mmorrow> or you force it with seq or something
23:16:23 <newsham> who's planning to play?
23:16:28 <dmwit> square calls itself under a (:) constructor.
23:16:40 <sclv> tieTYT: on a high level, every program is in the IO monad, which drives evaluation. if your program doesn't have a main function, then it doesn't evaluate anything, right.
23:16:50 <dmwit> So tail will eliminate the first part of the (:) constructor, and all you'll be left with is a call to square.
23:16:51 <mmorrow> or when you have to test for equality with it and something else
23:16:53 <Saizan> tieTYT: strict languages first evaluate arguments and then pass them to the function, while in haskell you start by evaluating the code of the outermost function and let it drive evaluation of the arguments by pattern matching
23:17:55 <dmwit> newsham: Aw, bummer, it's the same weekend as my brother's wedding.
23:18:07 <tieTYT> dmwit: i really don't get that
23:18:09 <sclv> so you can think of the need to perform IO as driving all computation...
23:18:13 <newsham> bummer indeed.  is your attendence required? ;-)
23:18:19 <dmwit> heh, yes
23:18:32 <newsham> well congrats for your brother, suck for you.
23:18:47 <dmwit> tieTYT: Ok.  Ready?
23:18:47 <cjs> Can't you get your brother to move the wedding?
23:18:48 <tieTYT> dmwit: so tail (square [2..5]) becomes  square [3..5]?
23:19:00 <cjs> Or get the wedding guests to help. :-)
23:19:09 <sclv> think of it by substituting in the body of functions for their name.
23:19:12 <dmwit> tail (square [2..5]) = tail (square (2:[3..5]))
23:19:32 <dmwit>  = tail ((2**2) : square [3..5])
23:19:44 <dmwit>  = square [3..5]
23:20:06 <dmwit> The second line uses the definition of square; the third line uses the definition of tail.
23:20:36 <tieTYT> yeah...
23:20:49 <tieTYT> that's hard for me to predict
23:21:16 <dmwit> tieTYT: Well, look at it this way.
23:21:16 <vixey> hiya
23:21:23 <tieTYT> vixey: hi
23:21:37 <dmwit> tieTYT: You have two choices: either start evaluating "tail" or start evaluating "square".
23:22:08 <dmwit> tieTYT: Since "tail" requires a pattern match right away, and its argument doesn't have a constructor "showing", you can't evaluate it yet.
23:22:45 <dmwit> So you start evaluating square.
23:22:57 <tieTYT> and each step along the way, it starts at the top of the stack and repeats that logic?
23:23:04 <dmwit> (Incidentally, its argument doesn't have a constructor showing either, so you have to evaluate its argument a little bit first.)
23:23:21 <tieTYT> "ok, finished a step.  Can tail use it?  No.  Can square use it?..."
23:23:35 <dmwit> Well... kind of.
23:23:46 <dmwit> It shouldn't hurt anything to think of it as doing that process.
23:24:11 <quicksilver> tieTYT: there is more than one way to think of it.
23:24:19 <quicksilver> tieTYT: actually the executions are interleaved, really.
23:24:21 <tieTYT> and it's kinda like you always prefer progressing the functions near the top of the stack
23:24:26 <quicksilver> "tail" is executed first, in a sense.
23:24:29 <dmwit> tieTYT: exactly
23:24:46 <quicksilver> but it only executes tail as far as discovering that tail needs the top constructor of its argument
23:25:04 <quicksilver> and then it says "ah, well, the argument is still a thunk at the moment, so I'm going to have to evaluate the argument at least somewhat"
23:25:20 <quicksilver> it's called "demand-driven evaluation"
23:25:22 <tieTYT> what's a "top constructor"?
23:25:27 <quicksilver> tail "demands" the top constructor of the argument
23:25:28 <vixey> roconnor, this one http://www.e-pig.org/downloads/view.pdf but I got kind of stuck I think I'll print it and read it later
23:25:39 <quicksilver> and so the evaluation of that argument is demanded, and it happens
23:25:41 <vixey> (I didn't know there was multiple versions ?)
23:25:54 <quicksilver> tieTYT: well, with a simpler looking type, "Just 4" or "Right 5"
23:26:01 <quicksilver> tieTYT: the 'top constructor' is Just or Right.
23:26:14 <tieTYT> aka a value constructor?
23:26:19 <tieTYT> or data constructor?
23:26:20 <quicksilver> tieTYT: with a list "1 : [2,3,4]" is shorthand for (:) 1 [2,3,4]
23:26:22 <quicksilver> yes yes
23:26:26 <quicksilver> but not just any old one
23:26:31 <quicksilver> the 'top' one ;)
23:26:33 <cjs> tieTYT: In something like "Just [1,2,3] :: Maybe []", "Just" is the top constructor.
23:26:47 <cjs> [] is the constructor for a value underneath the top constructor.
23:27:14 <quicksilver> well (:) is immediately underneath
23:27:14 <tieTYT> ok
23:27:14 <cjs> So in this case, it's saying that if you've got a thunk, it will be evaluated to the point of being Just something, where something is left as another thunk.
23:27:51 <tieTYT> i see
23:28:17 <tieTYT> perhaps, that is
23:28:44 <tieTYT> i need some examples to work with
23:28:56 <tieTYT> will anything i come up with work?
23:30:27 <tieTYT> 2 `elem` [1,2,3]  is that a good example?
23:30:54 <tieTYT> or is it better to nest a function inside another one?
23:31:40 <quicksilver> how about 2 `elem` (map (+1) [0,1,2])
23:31:57 <quicksilver> that's quite a good example because you can see how much of the evaluation of the map happens
23:32:07 <tieTYT> donno map
23:32:17 <dmwit> ?src map
23:32:17 <lambdabot> map _ []     = []
23:32:17 <lambdabot> map f (x:xs) = f x : map f xs
23:32:22 <dmwit> Does that help? =P
23:41:30 <mmorrow> > map (*2) [0..2]
23:41:32 <lambdabot>  [0,2,4]
23:42:10 <mmorrow> > map (map (*2)) [[0,1],[2],[]]
23:42:11 <lambdabot>  [[0,2],[4],[]]
23:42:29 <mmorrow> > (map . map) (*2) . map (:[]) $ [0..2]
23:42:30 <lambdabot>  [[0],[2],[4]]
23:42:45 <mmorrow> > map (map (*2)) [[0],[1],[2]]
23:42:46 <lambdabot>  [[0],[2],[4]]
23:44:17 <a13x> i got a question:
23:44:19 <a13x> > type Events = [Event]
23:44:19 <a13x> > instance Eq Events where
23:44:19 <a13x> >   (==) e1 e2 = eventsVariance e1 e2 < 0.1
23:44:20 <lambdabot>  Parse error at "type" (column 1)
23:44:20 <lambdabot>  Parse error at "insta..." (column 1)
23:44:20 <lambdabot>  Parse error at "=" (column 12)
23:44:34 <a13x> this produces an error
23:45:15 <mmorrow> whats the error
23:45:23 <a13x> parse error
23:45:34 <a13x> Data.lhs:61:2:
23:45:34 <a13x>     Illegal instance declaration for `Eq Events'
23:45:34 <a13x>         (All instance types must be of the form (T t1 ... tn)
23:45:34 <a13x>          where T is not a synonym.
23:45:34 <a13x>          Use -XTypeSynonymInstances if you want to disable this.)
23:45:35 <a13x>     In the instance declaration for `Eq Events'
23:45:35 <tieTYT> one sec
23:45:37 <a13x> Failed, modules loaded: none.
23:45:37 <mauke> illegal instance declaration
23:45:50 <mauke> THAT'S NOT A PARSE ERROR
23:46:00 <a13x> ok
23:46:06 <a13x> how do i do this?
23:46:09 <mmorrow> add {-# OPTIONS_GHC -fglasgow-exts #-} to the top of your src
23:46:11 <tieTYT> ok i get it
23:46:14 <tieTYT> let me try to work this out
23:46:15 <mauke>    Use -XTypeSynonymInstances if you want to disable
23:46:25 <mmorrow> or {-# LANGUAGE -XTypeSynonymInstances #-}
23:46:36 <mauke> and after you've done that you probably also need FlexibleInstances
23:46:37 <mmorrow> to execute a precision strike on the error
23:46:37 <a13x> i am trying to compare a list with my own function
23:46:51 <mmorrow> might as well do -fglasgow-exts
23:47:00 <a13x> what does that do
23:47:04 <tieTYT> @src elem
23:47:04 <lambdabot> elem x    =  any (== x)
23:47:09 <mauke> enables most ghc extensions
23:47:31 <mauke> if you want to stay H98 compatible, explicitly call your own function or make Events a newtype
23:47:36 <a13x> why do i need to enable extensions?
23:47:47 <a13x> events is a type
23:47:52 <a13x> > data Event = Event Timestamp Entity          deriving (Show, Eq, Ord)
23:47:52 <lambdabot>  Parse error at "data" (column 1)
23:47:57 <mauke>  (All instance types must be of the form (T t1 ... tn)  where T is not a synonym.
23:48:17 <a13x> this is just a syntax question
23:48:24 <mauke> your instance type has this form but T is a synonym
23:48:35 <a13x> how do i say 'use my own function' to compare lists of type Event?
23:48:35 <tieTYT> that elem definition is really weird
23:48:39 <tieTYT> doesn't it take 2 parameters?
23:48:49 <a13x> > type Timestamp = Double
23:48:49 <lambdabot>  Parse error at "type" (column 1)
23:48:54 <tieTYT> i think that's currying in action, huh?
23:49:13 <mauke> tieTYT: elem x y = any (== x) y
23:49:17 <a13x> > data Entity = EntityNumber Integer | Pattern Pattern
23:49:17 <lambdabot>  Parse error at "data" (column 1)
23:49:24 <mauke> tieTYT: you can cancel the 'y's from both ends
23:49:37 <a13x> wait
23:49:37 <tieTYT> hm
23:50:12 <a13x> what does elem x y = any (== x) y do?
23:50:46 <tieTYT> ok is this the first step: any (== 2) (map (+1) [0,1,2]) ?
23:51:07 <cjs> What's the plural of "series"?
23:51:38 <tieTYT> a13x: it checks if x is in the list y
23:51:44 <tieTYT> :t elem
23:51:45 <a13x> ok thanks
23:51:47 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
23:51:57 <mmorrow> > any (== 2) (map (+1) [0,1,2])
23:51:59 <lambdabot>  True
23:52:08 <mmorrow> > any (== 2) . map (+1) $ [0,1,2]
23:52:09 <lambdabot>  True
23:52:13 <a13x> how do i say 'use my own function' to compare lists of type Event?
23:52:13 <dmwit> cjs: "series"
23:52:30 <mmorrow> > any . map ((==2) . (+1)) $ [0,1,2]
23:52:30 <lambdabot>  Couldn't match expected type `a -> a1' against inferred type `[a2]'
23:52:42 <dmwit> a13x: Depends on where you have to use ti.
23:52:53 <mauke> a13x: you write myfunc x y instead of x == y
23:52:55 <dmwit> a13x: Many Data.List functions have "By" equivalents.
23:52:58 <mmorrow> > or map ((==2) . (+1)) $ [0,1,2]
23:52:59 <lambdabot>  Couldn't match expected type `[Bool]'
23:53:15 <mmorrow> > or . map ((==2) . (+1)) $ [0,1,2]
23:53:15 <dmwit> a13x: So, sort -> sortBy, nub -> nubBy, etc.
23:53:15 <lambdabot>  True
23:53:16 <tieTYT> @src any
23:53:17 <lambdabot> any p =  or . map p
23:53:38 <a13x> i am using it here: events `elem` cleanlist
23:54:05 <a13x> i would like to define something like this:
23:54:16 <a13x> > instance Eq Events where
23:54:16 <a13x> >   (==) e1 e2 = eventsVariance e1 e2 < 0.1
23:54:17 <lambdabot>  Parse error at "insta..." (column 1)
23:54:17 <lambdabot>  Parse error at "=" (column 12)
23:54:33 <dmwit> a13x: That should be no problem, are you getting an error?
23:54:47 <a13x> yes: Data.lhs:61:2:
23:54:47 <a13x>     Illegal instance declaration for `Eq Events'
23:54:47 <a13x>         (All instance types must be of the form (T t1 ... tn)
23:54:47 <a13x>          where T is not a synonym.
23:54:47 <a13x>          Use -XTypeSynonymInstances if you want to disable this.)
23:54:48 <a13x>     In the instance declaration for `Eq Events'
23:54:50 <a13x> Failed, modules loaded: none.
23:55:04 <a13x> > type Events = [Event]
23:55:05 <lambdabot>  Parse error at "type" (column 1)
23:55:25 <dmwit> a13x: In the future, please send long pastes to hpaste.org.
23:55:31 <luqui> a13x, you can't.  the Eq instance for [Event] is determined by the Eq instance for Event
23:55:31 <a13x> oh, sorry
23:55:43 <mmorrow> everytime you paste in someline starting with '>' that isn't a valid haskell expression, lambdabot will do that
23:55:48 <dmwit> But as for the current problem, you have to play tricks to do something like that.
23:55:53 <a13x> oh sorry
23:55:58 <mmorrow> :)
23:56:20 <luqui> a13x, I suggest a newtype if Events is considered anything more than just a shorthand for [Event]
23:56:22 <a13x> what is the trick?
23:56:29 <dmwit> newtype
23:56:30 <luqui> newtype Events = Events [Event]
23:56:38 <a13x> what does it do?
23:56:39 <mauke> <mauke> if you want to stay H98 compatible, explicitly call your own function or make Events a newtype
23:56:48 <dmwit> a13x: It's just like data, but only allows one constructor.
23:56:48 <mauke> YES IGNORE ME
23:56:58 <a13x> ok, thanks
23:57:07 <dmwit> mauke: What?
23:57:21 <dmwit> mauke: Did you say something?
23:57:38 <luqui> mauke, we're trying to answer this question which has _obviously_ not been answered in the past
23:57:58 <mauke>       
23:58:16 <luqui> woah.  you just blew my mind, dude.
23:58:29 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/7960
23:58:30 <dmwit> Those characters are not the same width as everybody else's!
23:58:34 <dmwit> He's a WITCH!
23:58:38 <tieTYT> that's mine
23:58:48 <mxc> > System.exit 1
23:58:48 <lambdabot>   Not in scope: `System.exit'
23:58:52 <tieTYT> i don't know if this is coherent, but maybe you can check it out
23:59:09 <tieTYT> it probably checks if 2 == (+ 1 0) before it evaluates the RHS
23:59:38 <dmwit> I think the "false" is a bit premature.
23:59:41 <mxc> what if you typed something like: "> mapM_ (const . forkIO) [1..]"
23:59:47 <vixey> not otherwise
23:59:53 <mauke> > mapM_ (const . forkIO) [1..]
23:59:54 <lambdabot>  Couldn't match expected type `a -> a1'
