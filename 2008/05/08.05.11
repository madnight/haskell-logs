00:23:27 <schme> Is there some module to import for backtracking and constraint solving in general?
00:24:27 <dmwit> LogicT, I think
00:24:31 <dmwit> ?go haskell logict
00:24:33 <lambdabot> http://okmij.org/ftp/Computation/monads.html
00:24:33 <lambdabot> Title: Monads
00:25:06 <dolio> logict doesn't do constraint solving. It's just better for bactracking search.
00:25:25 <dmwit> I've always sort of written my constraint solvers by hand.
00:25:30 <dolio> Better than vanilla [] and MonadPlus, that is.
00:25:33 <dmwit> Haskell is really concise for that stuff.
00:25:52 <schme> Sounds good. I'll take a look at that.
00:26:10 <schme> You seem to be just very helpful around here in #haskell :)
00:28:33 <mm_freak> @src join
00:28:33 <lambdabot> join x =  x >>= id
00:32:17 <mm_freak> hmmâ€¦  it works, but it appears like monkey business to me =)
00:32:43 <dmwit> The definition of join?
00:32:47 <mm_freak> yeah
00:33:14 <mm_freak> somehow the id function doesn't 'belong' there, although in this case it's totally valid
00:34:14 <mm_freak> i just wondered, how can one remove one layer of monadic structure without extracting the actual value
00:34:32 <dmwit> Well, (>>=) has that knowledge implicit in it.
00:34:44 <dmwit> :t (>>=)
00:34:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
00:35:15 <mm_freak> sure, it just looks weird, really weird, because in this case a = m x, and b = x
00:35:20 <dmwit> So, in (m >>= f), (>>=) knows how to take the "f" thing and "map" it over the monad "m".  But this makes a monad containing monads.
00:35:42 <dmwit> So (>>=) has to know implicitly how to collapse that "monad containing monads" into just a monad.
00:36:07 <dmwit> "join" just takes that implicit knowledge and makes it explicit.
00:36:34 <mm_freak> that makes sense
00:37:42 <dmwit> If you think about it that way, you can also see why you need "f" to be "id" in the definition of join.
00:38:48 <mm_freak> yeah
00:42:31 <mm_freak> on a first look, though, it still looks like if the id function is 'abused' to circumvent one monadic layer
00:43:21 <dmwit> Yeah. =)
00:43:36 <dmwit> Just keep in mind that the type of (>>=) prevents us from going too far with it.
00:44:14 <dmwit> :t (>>= ?id)
00:44:15 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?id::a -> m b) => m a -> m b
00:44:34 <dmwit> Well, that didn't help.
00:44:49 <mm_freak> :t (>>= id)
00:44:51 <dmwit> But id :: Monad m => m a -> m a.
00:44:51 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
00:45:29 <dmwit> (i.e. we can't have id return a non-monadic value, and this saves us from stripping off the last layer of monad-ness.)
00:46:15 <mm_freak> sure, but it looks like if you were inside the monad, you could just 'steal' the value from an inner monad
00:46:30 <dmwit> Well... you can! =)
00:47:42 <dmwit> mm_freak: It may help to see it in both (>>=) form and "do" form.
00:48:13 <dmwit> join mma = do { ma <- mma; a <- ma; return a } -- one possible expansion
00:48:52 <dmwit> Since we pull with (<-) twice, we "steal" the inner value.
00:49:24 <dmwit> :t \mma -> do { ma <- mma; a <- ma; return a } -- just to make sure I got that right
00:49:26 <lambdabot> forall (t :: * -> *) t1. (Monad t) => t (t t1) -> t t1
00:49:38 <mm_freak> ok, yeah, it makes senseâ€¦  i was just thinking too far and got into trouble
00:50:10 <mm_freak> side-effects and state aren't the value of the monad, they are part of the monad
00:52:47 <dmwit> > let stateful = modify (*2) >> return (modify (+1)) in runState 0 (join stateful)
00:52:48 <lambdabot>        add an instance declaration for (Num (State (m ()) a))
00:52:52 <dmwit> :t runState
00:52:54 <lambdabot> forall s a. State s a -> s -> (a, s)
00:53:05 <dmwit> > let stateful = modify (*2) >> return (modify (+1)) in runState (join stateful) 0
00:53:09 <lambdabot>  ((),1)
00:53:54 <dmwit> > let stateful = modify (+3) >> return (get >>= modify . (*)) in runState (join stateful) 0 -- a really bad way to compute 3*3
00:53:56 <lambdabot>  ((),9)
00:55:55 <mm_freak> i'll come back to that as soon as i've fully comprehended the idea behind state monads =)
00:56:21 <dmwit> Yeah, I'm still playing with them myself. =)
00:56:48 <mm_freak> i'm gonna get some sleep nowâ€¦  that'll certainly help a lotâ€¦  thanks a lot, and bye
01:07:04 <mxc_> @hoogle frac
01:07:05 <lambdabot> Prelude.Fractional :: class Num a => Fractional a
01:07:05 <lambdabot> Prelude.RealFrac :: class (Real a, Fractional a) => RealFrac a
01:07:05 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
01:30:35 <dmwit> "For example, *runL Nothing (bogosort [5, 0, 3, 4, 0, 1])* produces two answers that differ in the order of the first two elements: [[0, 0, 1, 3, 4, 5], [0, 0, 1, 3, 4, 5]]."
01:30:41 <dmwit> I love academia. =)
01:35:28 <dmwit> Oh, neat, they use a soft version of pattern matching.
01:36:34 <dolio> Soft?
01:36:58 <dmwit> Well, they have this concept of a "stream", but really it's a type-class.
01:37:06 <dmwit> So they can't pattern-match.
01:37:28 <dmwit> But there's a primitive in the type-class, msplit :: m a -> m (Maybe (a, m a)).
01:38:01 <dmwit> Then they can pattern-match on the Maybe, inside of the monad, and get their stream behavior without knowing the constructors of the type.
01:38:07 <dmwit> I think it's very clever!
01:38:36 <dolio> Oh, are you reading the logict paper?
01:38:41 <dmwit> yeah =)
01:40:12 <dolio> It's a good one.
01:40:33 <dmwit> It's keeping me up.
01:40:42 <dmwit> Which means: I agree. =)
01:45:49 <Saul__> I'm trying to write a transpose function for a Vector type
01:46:15 <Saul__> I'm not sure though if it's possible to do a case where the outer vector has length 0
01:47:01 <Saul__> that would mean that the function would be something like Vector 0 (Vector m a) -> Vector m (Vector 0 a)
01:47:26 <dolio> transpose [] = replicate m []?
01:47:32 <Saul__> so I would need to make a vector of length m with empty vectors in them
01:48:04 <Saul__> that would be great if Haskell had dependent types
01:48:44 <dmwit> I think allowing zero-length vectors in general nets you plenty of trouble without adding a lot of benefit.
01:49:20 <dmwit> Though I might ask how you are representing (Vector m a) currently: what is the m?
01:49:36 <Saul__> I'll make a paste, just a moment
01:51:15 <Saul__> http://hpaste.org/7539 Here it is
01:52:39 <dmwit> Oop, GADTs.
01:53:06 <dmwit> I think I'll shut my trap before I get myself in trouble.
01:53:23 <Saul__> Yeah those make sure that you can't have a types like Vector (Succ Int) a
01:53:48 <Saul__> and thus allows you do define functions normally without a lot of overloading
01:54:56 <Saul__> I can actually define a function that makes a vector of length n with some value in it, but it would require overloading, and thus add nasty class constraints on the function
01:55:05 <dolio> http://hpaste.org/7539#a1
01:55:10 <dolio> Untested.
01:55:35 <Saul__> Yeah like that :)
01:55:36 <dmwit> I think the problem is that transpose is then ill-typed.
01:55:49 <dmwit> Right?
01:56:07 <Saul__> Yes the class constraint is ugly
01:56:23 <dolio> Yeah.
01:56:24 <Saul__> since it's not really a constraint, but a hack
01:57:35 <dolio> You could do it all with a 'class Natural n where rep :: Nat n' probably.
01:57:53 <dolio> 'data Nat n where Zero :: Nat Zero ; Succ :: Nat n -> Nat (Succ n)'
01:59:08 <dmwit> "The CPS-based implementation introduces the type constructor SFKT for functions accepting success and failure continuations."
01:59:27 <dmwit> I'm guessing (S)uccess, (F)ailure, and (T)ransformer, but what would the K be for?
01:59:43 <dolio> K for continuation.
01:59:58 <dmwit> o
02:00:06 <dolio> For some reason, it's usually given a variable name k.
02:00:23 <Saul__> dolio:Could you explain your last comment some more?
02:00:40 <mahogny> has anyone here studied non-relational databases, theory in particular?
02:01:07 <dolio> Well, it's still require a constraint, but the constraint would be like 'Natural n =>'.
02:01:12 <dancor> you will never obtain the konfigurationicon
02:01:32 <dolio> I'm typing up some code to play with it. Give me a few minutes...
02:04:33 <dmwit> ?instances MonadPlus
02:04:35 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
02:15:19 <dmwit> Very cool!
02:18:42 <dolio> Saul__: This isn't great, but it works: http://hpaste.org/7539#a2
02:21:12 <Saul__> dolio: Thanks
02:22:02 <Saul__> dolio: Although I don't really like it :(
02:22:24 <dolio> Yeah, it has way more class constraints than I actually wanted.
02:24:10 <dolio> There are other things you could do, like: 'transpose :: Nat m -> Nat n -> Vector m (Vector n a) -> Vector n (Vector m a)
02:24:27 <hexpuem> is there a way to enable profiling without having profile libs installed for every support library (like gtk)
02:24:36 <dolio> Which would be similar to Agda, except you can't make the dependent Nat arguments implicit.
02:26:30 <Saul__> dolio: That isn't really better
02:26:38 <dolio> Right.
02:27:06 <dolio> You're probably better off sticking with non-empty vectors.
02:27:07 <Saul__> dolio: I think I'll just leave it at what I have now, this way I can't transpose empty vectors, but I doubt I'll miss it
02:28:04 <Saul__> It's actually for a linear algebra library, so empty vectors aren't used much
02:45:56 <dcoutts> edwardk: so was the "cabal acting strage" that it doesn't upgrade to the latest version if you say cabal install foo and you've got some version of foo installed already?
02:48:00 <dcoutts> gwern: pong
02:51:57 <dcoutts> edwardk: http://hackage.haskell.org/trac/hackage/ticket/168
02:51:59 <lambdabot> Title: #168 (Behaviour of cabal-install with respect to upgradeable packages is unexpec ...
02:52:12 <dcoutts> edwardk: if it's that one, I'm planning to fix it soon
02:58:45 <ibid> arjanoosting: what's the story with haxml on powerpc debian unstable? it's ruining my beauty sleep (my package is not building, iow:)
03:10:24 <ibid> arjanoosting: actually, it appears my package's trouble is not just because of haxml, so sorry to bother you
03:30:21 * dcoutts comments on RWH Ch 6
03:30:57 <dcoutts> bos, dons: pretty please no version tags "Version: 0.1-alpha"
03:31:18 <dcoutts> bos, dons: all the other advice is sound, but not that
04:16:54 <sheyll> hi everyone :-)
04:18:58 <sheyll> I am back with another noob question ;-)  In the gtk2hs cairo clock example IORefs are used. Why? Could one also use MVars?
04:19:50 * qwr thinks you could probably use MVar anywhere, where IORef could be used...
04:20:43 <sheyll> qwr what is the diffrence betweeen IORefs and MVars?
04:20:56 <ivanm> sheyll: you mean apart from the name? :p
04:21:16 <sheyll> :)
04:21:26 <sheyll> oh the name is diffrent?
04:21:39 <sheyll> now that you mentioned it
04:21:42 <qwr> sheyll: MVar does more. locking for example.
04:21:59 <qwr> sheyll: and if don't need it, IORef is a bit easier to use
04:22:20 <sheyll> ah ok, makes sense. So an IORef is not thread safe....
04:22:20 <qwr> (probably faster to)
04:22:34 <sheyll> qwr which one?
04:22:45 <qwr> sheyll: IORef is probably faster
04:23:28 <qwr> sheyll: yes, IORef is normally not thread safe
04:28:53 <sheyll> do MVars "know" wheter it is necessary to actually really lock something? (in the situation that this is only a single process that the hardware is running, and green threads are used, it is not quite necessary to use real mutexes)
04:32:06 <sethk> sheyll, I'm not sure, but it would be straightforward to make the mutex operations no-ops
04:39:47 <opqdonut> I want to wrap each node of a tree in a functor, is something like "data Expr_ = Op Expr Expr; type Expr = Functor Expr_" the right way?
04:40:13 <opqdonut> i guess i can't use type if i want this to be polymorphic in the functor type :\
04:40:39 <cpoucet> opqdonut: I usually parameterize my asts
04:40:58 <opqdonut> yeah i thought about that but it turned a bit ugly
04:41:02 <opqdonut> how are you doing it?
04:41:07 <cpoucet> there's two ways of doing it
04:41:32 <cpoucet> wait, there's one way if you want wrapping inside the samea ast, instead of things that are outside of it
04:41:33 <opqdonut> "data Expr a = Expr a Expr Expr" something like this?
04:41:35 <cpoucet> which would imply using Fix
04:41:44 <cpoucet> let's take
04:41:56 <cpoucet> data Exp = Add Exp Exp | Sub Exp Exp | Const Int
04:42:00 <opqdonut> mhmm
04:42:09 <cpoucet> data Exp e = Add e e | Sub e e | Const Int
04:42:17 <cpoucet> type Exp' = Fix Exp
04:42:18 <opqdonut> ah
04:42:38 <opqdonut> and "type Exp'' = Fix (f :. Exp)"?
04:42:47 <cpoucet> f : ?
04:42:49 <opqdonut> or something like that
04:42:55 <cpoucet> erm
04:43:10 <opqdonut> where :. is "type-level composition"
04:43:18 <cpoucet> oh right, does that exist?
04:43:23 <opqdonut> no, but it's defineable
04:43:33 <cpoucet> well yeah, somethng like that :)
04:43:36 <opqdonut> at least with a few extensions :P, i wrote it just for clarity
04:43:44 <opqdonut> yeah, that's actually what i want to do, thanks
04:43:46 <cpoucet> opqdonut: I'd actually be interested in that
04:44:01 <opqdonut> cpoucet: i'll paste the datatype in a moment
04:44:05 <cpoucet> spiffy, thanks
04:44:16 <opqdonut> hmm, problem
04:44:48 <opqdonut> that works only for an "Expr-tree", how about if i can have different node types
04:44:52 <opqdonut> for example Stmt and so on
04:45:04 <opqdonut> a GADT might do it tho
04:45:41 <opqdonut> or then i just need to parametrize every node over expr, stmt and so on
04:45:45 <opqdonut> and use a more complicated fix
04:46:01 <cpoucet> yeah
04:46:12 <opqdonut> ok, i'll see what i can cook up
04:50:16 <cpoucet> opqdonut: ah I found some old code
04:50:56 <cpoucet> opqdonut: http://hpaste.org/7540
04:51:20 <cpoucet> I basically used custom 'fix'es
04:53:11 <opqdonut> ah yeah
04:53:51 <opqdonut> http://hpaste.org/7541
04:54:03 <opqdonut> that's what i just wrote, still haven't refactored the code
04:54:12 <opqdonut> and haven't added the functors yet
04:54:48 <cpoucet> you can't do this
04:54:49 <cpoucet> type Stmt = Stmt_ Stmt Expr
04:54:50 <cpoucet> afaik
04:55:00 <cpoucet> you need data-constructors to tie knots
04:56:20 <opqdonut> well ghc swallowed it it seems
04:56:39 <cpoucet> oh
04:57:01 <opqdonut> let me recheck
04:57:36 <opqdonut> nah,     Cycle in type synonym declarations:
04:59:56 <opqdonut> http://hpaste.org/7541#a1
04:59:58 <opqdonut> that compiles
05:00:31 <opqdonut> now i'll just add a typeclass for wrapping and unwrapping
06:40:30 <pitseleh> hello, i'm trying to write to a file that doesn't exist with writeFile
06:40:47 <pitseleh> and i'm getting an IO.openFile: does not exist (file does not exist) error, do i have to do something before i call writeFile?
06:41:22 <pitseleh> i've been searching online to no avail
06:42:27 <mauke> does your specified filename contain directories?
06:42:56 <pitseleh> mauke, no, at the moment it's just a simple string
06:42:58 <edwardk> dcoutts: well, it seemed to think the packages that the other package was complaining about were installed. if you look at the list, the versions ghc-pkg showed were already installed at sufficient versions. i think it was geezusfreak or someone who pointed out that if i uninstalled and reinstalled them it would work
06:43:02 <EvilTerran> i'd guess either the directory doesn't exist or is read-only
06:43:10 <mauke> dunno then
06:43:17 <mauke> try strace?
06:44:34 <pitseleh> err, never used strace before, might have to
06:46:07 <pitseleh> ah, i see, i wasn't writing anything to the file
06:46:12 <pitseleh> so i suppose it doesn't create it
07:00:40 <bos> dcoutts: what are tags for, if not stuff like "alpha"?
07:20:37 <vixey> @keal
07:20:37 <lambdabot> i lack in verbal and social expression
07:20:49 <vixey> @protontorpedo
07:20:50 <lambdabot> what is a good way to handle the ftp transfer and reading of files to mysql?
07:25:28 <Baughn> @hoogle evaluate
07:25:29 <lambdabot> Control.Exception.evaluate :: a -> IO a
07:33:42 <pitseleh> is there a way to read a file as a list of strings (each line separate) like readlines() in python?
07:34:12 <Baughn> liftM lines getContents
07:34:21 <Baughn> Well, hGetContents
07:34:38 <Baughn> Or readFile, or just readLine repeatedly..
07:34:49 <pitseleh> Baughn, thanks, i was working on a function to iterate until it found \n each time.. ugly stuff
07:35:07 <jorick> @src lines
07:35:08 <lambdabot> Source not found. Just try something else.
07:35:11 <Baughn> @src words
07:35:11 <lambdabot> words s = case dropWhile isSpace s of
07:35:11 <lambdabot>     "" -> []
07:35:11 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
07:35:18 <Baughn> pitseleh: ^-- That is how you do it
07:35:45 <pitseleh> ah, that looks handy for my other parsing too, thanks :)
07:36:04 <Baughn> I suggest splitting up into a splitBy that takes an equality predicate
07:36:26 <Baughn> Of course it should work on Eq a => [a]
07:36:30 <pitseleh> that would make processing it simpler
07:37:05 <Baughn> Mm. Just another Prelude wart, I guess; both words and lines should be implemented in terms of splitBy, but there you go.
07:37:47 <pitseleh> it's no biggie, thanks for the help :)
07:47:26 <jpcooper> hello
07:47:49 <jpcooper> how would I define a data structure on a list of strings?
07:48:02 <jpcooper> and then a list of anything
07:48:24 <mauke> what do you mean by "define a data structure on"?
07:48:38 <vixey> @src []
07:48:39 <lambdabot> data [] a = [] | a : [a]
07:48:39 <jpcooper> I'd like to define a table type
07:49:04 <vixey> type Table = [(String,Int,Shoesize)]
07:49:04 <jpcooper> that has a list of strings defining the parameters, and a list of tuples
07:49:13 <jpcooper> aah, okay
07:49:14 <jpcooper> thanks
07:49:19 <vixey> pure = (return .) ; (<*>) = (=<<)
07:49:27 <Baughn> type Table = Map, perhaps?
07:49:29 <vixey> is that a valid applicative?
07:49:52 <mauke> :t pure
07:49:54 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
07:49:58 <mauke> :t (return .)
07:50:00 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, Monad m) => f a -> f (m a)
07:50:01 <jpcooper> I'd like it to also have a place for the parameters
07:50:19 <vixey> I was looking at
07:50:22 <vixey> @src liftA2
07:50:23 <lambdabot> liftA2 f a b = f <$> a <*> b
07:50:31 <vixey> v-
07:50:36 <vixey> liftM f a = return . f =<< a
07:50:40 <mauke> :t (return P..)
07:50:41 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
07:51:07 <vixey> oh I get it
07:51:23 <mauke> pure = (return .) doesn't typecheck
07:52:30 <jpcooper> data Table [String] [()] = Table [String] [()]
07:52:33 <jpcooper> I'd like something like that
07:52:45 <mauke> that doesn't make sense
07:52:48 <jpcooper> I know
07:52:53 <vixey> data Table a b = Table a b
07:53:03 <jpcooper> but I want to specify the type
07:53:08 <vixey> Table [""] [(),(),()] :: Table [String] [()]
07:53:10 <mauke> data Table = Table [String] [()]
07:53:14 <jpcooper> should I create types a and b?
07:53:19 <mauke> what?
07:53:23 <mauke> a and b are parameters
07:53:24 <vixey> a and b are variables
07:53:51 <jpcooper> okay
07:56:20 <jpcooper> what's the type of a tuple with anything in it?
07:56:39 <vixey> :t ("anything",6,'x')
07:56:41 <lambdabot> forall t. (Num t) => ([Char], t, Char)
07:56:47 <vixey> you can use :t in GHCi
07:56:54 <jpcooper> yes
07:56:58 <vixey> also [Char] = String
07:57:01 <Zao> (t,t1,t2,...)
07:57:23 <jpcooper> I just want to define a list that will only take tuples
07:57:47 <vixey> You can't do that
07:57:52 <jpcooper> yes
07:57:55 <Botje> [(a,b)]
07:58:03 <Botje> that will hold pairs
07:58:11 <Botje> but you can't generalise it to hold tuples
07:58:28 <Botje> not without declaring a Tuple class of some sorts
07:58:54 <vixey> you can't define a Tuple class in haskell
07:59:23 <dolio> You can, depending on what sort of methods you want in it.
08:00:08 <dolio> 'class Tuple t where ; instance Tuple (a,b) where ; instance Tuple (a,b,c) where ; instance Tuple (a,b,c,d) where ; ...'
08:00:25 <jpcooper> sorry. I'm having trouble here. I'll make it more clear what I want
08:00:42 <vixey> It'll take infinite time to write those instances :P
08:00:45 <jpcooper> I would like to define a type whose constructor takes a list of strings, and returns a table with that list of strings, and an empty list
08:01:21 <dolio> vixey: Don't worry, GHC starts crashing when you get to around 50-tuples, so you only have to write finitely many. :)
08:01:34 <Botje> what's a "table" ?
08:02:06 <vixey> wow
08:02:09 <mauke> jpcooper: myconstructor x = (x, [])
08:02:10 <vixey> so it does
08:02:49 <jpcooper> thanks
08:03:10 <jpcooper> what if x isn't a list of strings?
08:03:29 <Botje> if you have to, you can always restrict the type of myconstructor
08:03:42 <mauke> myconstructor :: [String] -> ([String], [a])
08:05:01 <jpcooper> aah thanks
08:05:12 <jpcooper> but I want the table to be a type
08:05:29 <mauke> data Table a = Table [String] a
08:05:38 <mauke> myconstructor :: [String] -> Table a
08:05:45 <mauke> myconstructor x = Table x []
08:06:12 <jpcooper> thank you
08:06:16 <jpcooper> is it common to do this?
08:06:24 <mauke> depends on your definition of "this"
08:06:41 <mauke> er, oops
08:06:52 <mauke> that code doesn't actually work
08:06:59 <mauke> I meant = Table [String] [a]
08:07:07 <jpcooper> okay
08:08:38 <jpcooper> why [a] instead of a?
08:09:06 <mauke> to restrict the second element to lists
08:14:42 <jpcooper> mauke, I'm still quite confused. Could you direct me anywhere to read more on data types?
08:15:12 <mauke> not really; it all seems so obvious to me
08:15:28 <vixey> jpcooper: what do you want to know about them?
08:15:52 <jpcooper> I do not understand how they work
08:15:57 <jpcooper> which side does what
08:16:03 <jpcooper> why [a] instead of a, etc
08:16:21 <vixey> :t [1,2,3,4,5]
08:16:23 <lambdabot> forall t. (Num t) => [t]
08:16:28 <mauke> [a] is the type of lists whose elements have the type a
08:16:35 <jpcooper> yes
08:16:36 <vixey> :t ['p','q','x','z']
08:16:38 <lambdabot> [Char]
08:16:47 <jpcooper> so if I put [] in, is that now [[]]?
08:16:55 <mauke> :t [[]]
08:16:56 <lambdabot> forall a. [[a]]
08:17:04 <mauke> what do you mean by "put [] in"?
08:17:08 <vixey> :t []
08:17:10 <lambdabot> forall a. [a]
08:17:14 <jpcooper> Table x []
08:17:44 <vixey> jpcooper: well do you know that 1 : 2 : 3 : [] = [1,2,3] ?
08:17:49 <jpcooper> yes
08:17:55 <mauke> ok, that's the data constructor
08:17:57 <vixey> :t let end = [] in (1 : [], 'x' : [])
08:18:00 <lambdabot> forall t. (Num t) => ([t], [Char])
08:18:09 <mauke> the type of Table x [] is Table a
08:18:27 <vixey> jpcooper: see what happens here? you can use an empty list as a list of Numbers, Chars..
08:18:39 <jpcooper> mauke, okay
08:18:46 <jpcooper> vixey, yes, I understand that
08:20:56 <jpcooper> oh I get it now
08:21:03 <jpcooper> sorry for the trouble
08:22:27 * monochrom looks for trouble
08:23:37 <olsner> @seen trouble
08:23:37 <lambdabot> I haven't seen trouble.
08:29:10 <vixey> can I ask something slighty ot .. since nobody in ##logic is alive, Does there exist some kind of Curry-Howard analogue for relations (as in logic programming) rather than functions?
08:29:30 <edwardk> samb: i'll be, once you remove the typechecker there _is_ nothing left ;)
08:32:26 <edwardk> vixey: well you can view a relation between A and B as a binary membership selection (A * B) -> Bool, so curry howard can apply via that, but not directly
08:34:54 <monochrom> (A * B) -> Bool is also a boring statement to prove. :)
08:39:59 <pitseleh> how would you parse until you hit a new line?
08:40:13 <pitseleh> i tried '\\':'n':xs
08:40:16 <pitseleh> with pattern matching
08:40:23 <pitseleh> but it only pattern matches "\\n"
08:40:30 <pitseleh> oh wait
08:40:32 <EvilTerran> er... why not '\n' ?
08:40:37 <pitseleh> this is the most stupid question in a long time
08:40:43 <EvilTerran> yeah :P
08:40:43 <pitseleh> yes, why not '\n' indeed
08:40:47 <vixey> :t splitBy
08:40:50 <lambdabot> Not in scope: `splitBy'
08:40:56 <pitseleh> thanks :)
08:41:01 <vixey> one should implement splitBy I suppose
08:41:13 <vininim> @search colimits
08:41:14 <lambdabot> Unknown command, try @list
08:41:18 <monochrom> I have always found escapes confounding.
08:41:30 <pitseleh> monochrom, i'm glad i'm not the only one :)
08:41:31 <vininim> mm.. lambdabot contextualized in its googling or it justs uses google?
08:41:36 <vininim> *is
08:41:57 <EvilTerran> i've never really had any trouble with them, aside from the odd bit of Leaning Toothpick Syndrome
08:44:48 <monochrom> @help search
08:44:49 <lambdabot> search provides: gwiki google wikipedia gsite
08:45:15 <cpoucet> @google colimits
08:45:16 <lambdabot> http://en.wikipedia.org/wiki/Limit_(category_theory)
08:45:20 <monochrom> There is no @search.
08:45:59 <monochrom> @sean sean
08:46:00 <lambdabot> I haven't seen sean.
08:49:44 <seancorfield> shouldn't that be @seen sean? :)
08:50:26 <dolio> @beer seancorfield
08:50:26 <lambdabot> seancorfield is in #haskell. I last heard seancorfield speak 43s ago.
08:50:34 <seancorfield> lol... ok...
08:50:35 <dolio> lambdabot has spelling correction.
08:50:48 <monochrom> There is powerful hamming-distance allowance.
08:50:55 <monochrom> @unseen seancorfield
08:50:56 <lambdabot> seancorfield is in #haskell. I last heard seancorfield speak 21s ago.
08:51:11 <seancorfield> emphasis on "distance" clearly...
08:51:12 <monochrom> My personal favourites are @unseen and @seez.
08:51:53 <monochrom> IIRC distance of 2 allowed. 3 disallowed. So for example @unseez is rejected.
08:57:14 <EvilTerran> @botslack
08:57:15 <lambdabot> :)
09:01:04 <olsner> @google Leaning Toothpick Syndrome
09:01:05 <lambdabot> http://en.wikipedia.org/wiki/Leaning_toothpick_syndrome
09:02:48 <monochrom> @bothack
09:02:49 <lambdabot> :)
09:03:25 <mahogny> another perl non-solution...
09:03:42 <mahogny> well, good shot at least
09:04:58 <dolio> Is it just me, or are the 'initial' and 'terminal' mixed up in the description of (co)limits in that wikipedia article?
09:05:19 <monochrom> All escapes are due to unrealistically hoping to use strings for everything.
09:05:50 <dolio> Oh, never mind.
09:06:14 <dolio> I was thinking (N,psi) was the limit.
09:06:33 <monochrom> Of course, now that escapes are mainstream, the tyranny of majority dictates that they say escapes are realistic and me attacking escapes unrealistic.
09:13:16 <mahogny> if you need tons of escaping you did something wrong
09:13:49 <vixey> escaping occurs everywhere
09:14:04 <vixey> It's a natural phenomenon is programming
09:15:25 * mahogny shoots vixey before he has a chance to escape
09:15:50 <EvilTerran> monochrom, what would you do instead?
09:16:16 <mahogny> you can either use a function that adds the escaping, or you don't try to squeeze everything into one poor string
09:16:38 <mahogny> to use existing APIs, the first approach is the most practical
09:24:39 <vixey> what's a Comonad?
09:26:38 <DRMacIver> It's what Comonader tells you to do.
09:27:19 <DRMacIver> Or, more usefully, the dual notion to a monad. It supports a set of operations that are effectively the reverse of the monad operations.
09:28:10 <mm_freak> @src fmap
09:28:11 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:28:44 <DRMacIver> Incidentally, blatant plug: If anyone can help with http://www.drmaciver.com/2008/05/request-for-help-numerical-linear-algebra/ it would be greatly appreciated. :)
09:28:45 <lambdabot> Title: David R. MacIver » Blog Archive » Request for help: Numerical linear algebra, http://tinyurl.com/6jh3n4
09:32:31 <mahogny> DRMacIver, http://www.amazon.com/Applied-Numerical-Linear-Algebra-Demmel/dp/0898713897  was used in a course
09:32:33 <lambdabot> http://tinyurl.com/5ntffh
09:33:20 <DRMacIver> A lot of books are used in a course. That doesn't make them good. :) Would you specifically recommend it?
09:33:44 <dolio> A comonoid in the category of endofunctors?
09:34:00 <mahogny> DRMacIver, it pretty much covered the subject, I have no objections against it
09:34:11 <mahogny> maybe a bit talky
09:34:56 <mahogny> and could have been cheaper
09:35:06 <mahogny> SIAM know how to get paid for books :|
09:36:10 <orbitz> is it ok o ask a yi building question here?
09:36:28 <DRMacIver> mahogny: ok. I'll add it to the list of potentials. Thanks.
09:36:45 <DRMacIver> Price isn't really an obstacle as long as it's the right book. :)
09:36:55 <DRMacIver> I could probably even get my company to pay for it.
09:37:11 <DRMacIver> But the key here is definitely "a good book" more than "a cheap book"
09:38:27 <DRMacIver> (Other blatant plug. Upvotes for it on reddit pls? I'd like to get the post noticed)
09:38:54 <DRMacIver> (I don't normally karma whore like that, but the utility of this post is directly linked to its readership :) )
09:51:38 <byorgey> orbitz: it's fine to ask a yi building question here (don't ask to ask, just ask ;)
09:52:04 <cpoucet> and when in doubt, ask to ask to ask
09:52:04 <orbitz> in doing ./Setup configure, i get: Setup: At least the following dependencies are missing: fingertree -any
09:52:24 <byorgey> orbitz: well, do you have the fingertree package installed?
09:52:53 <orbitz> i would guess not, however I did not see inforatino n this in th Yi wiki page
09:53:47 <byorgey> or if you're really still in doubt, you can just inductively take care of it in one fell swoop: "is W okay, where Q is asking about whether Q is okay?"
09:54:03 <byorgey> er, doh!  s/W/Q/
09:54:31 <byorgey> orbitz: well, you can get it from hackage.haskell.org
09:54:41 <byorgey> or just 'cabal install fingertree' if you have cabal-install
09:54:55 <orbitz> ieeeee i do not
09:54:59 <orbitz> thanks i'll play around with it
10:09:32 <ehird> :t when
10:09:37 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:10:51 <jaj> @hoogle when
10:10:51 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
10:11:33 <vixey> this might be a silly question but I'm risking it, See when you write a paper and there's various references refer to [2], etc.. In what order are they numbered?
10:13:38 <pejo> vixey, depends on conference/journal. Some according to the order they are cited, some use alphabetical ordering on last name of first author.
10:13:48 <vixey> ok thanks
10:14:10 <dolio> I think you'd definitely want to match them with your bibliography.
10:14:56 <dolio> A random paper I just looked at is alphabetical, but within a single author there doesn't seem to be a particular ordering.
10:15:36 <dolio> Actually, I guess it's alphabetical by all authors sorted alphabetically, by the looks of it.
10:15:50 <cpoucet> mine tend to be order of appearance
10:15:53 <cpoucet> it seems
10:16:09 <dolio> Nope, not that either. Alphabetical by the order they list themselves in their paper, I'd guess.
10:16:29 <cpoucet> dolio: o.O
10:16:31 <cpoucet> dolio: what?
10:16:35 <cpoucet> oh, that was to yourself
10:16:45 <dolio> :)
10:38:06 <pitseleh> hmm, the last question to get my program working..
10:38:54 <pitseleh> i've got some indexes of a list, and for each piece of data the indexes refer to i want to alter the data
10:39:15 <pitseleh> and return a modified list
10:39:21 <pitseleh> does this require backtracking?
10:39:31 <monochrom> No.
10:39:38 * pitseleh scratches head and feels inadequate
10:40:05 <monochrom> Pretend to copy the original list. But check indexes. At selected indexes, use new data instead of original.
10:40:27 <pitseleh> oooo, that's the one!
10:40:28 <Heffalump> put the indexes in order, and walk through the list, decrementing the list of indexes as you go
10:40:52 <Baughn> Dereferencing? Maybe just walking
10:40:54 <pitseleh> thanks for making it obvious :)
10:41:12 <Heffalump> walk through list = something like foo (x:xs) = x:foo xs
10:42:46 <pitseleh> falump, i don't see how that would work.. i'm just a beginner and list:item:list seems beyond me at the moment
10:42:47 <vixey> :t maybe
10:42:49 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:42:57 <vixey> :t lookup
10:42:59 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:43:09 <vixey> pitseleh: you could maybe use these two
10:43:40 <vixey> if you have indices and replacements stored in a [(a, b)] ?
10:43:47 <pitseleh> vixey, they do seem like they were made for this kind of thing..
10:44:02 <pitseleh> no, i merely want to increment an int of (Track, Int)
10:44:11 <pitseleh> i.e. [(Track,Int)]
10:44:41 <vixey> :t map (?increment :: (Track,Int) -> (Track,Int))
10:44:43 <lambdabot> Not in scope: type constructor or class `Track'
10:44:43 <lambdabot> Not in scope: type constructor or class `Track'
10:44:47 <vixey> aww
10:44:58 <pitseleh> track is my own type :)
10:45:02 <vixey> well if you have a way to increment one of those, you can use map to do it over the whole map
10:45:04 <pitseleh> but map would make things easy
10:46:58 <paolino> pitseleh: maybe you want to use another structure then list
10:47:22 <pitseleh> paolino, well, this is kind of the odd one out, list is perfect for all my other needs
10:47:33 <Heffalump> pitseleh: http://hpaste.org/7542
10:47:56 <Heffalump> for added efficiency you could make the offsets in the fs be the difference from the previous offset
10:49:14 <pitseleh> Heffalump, woah, thank you.. this is workable as is
10:49:22 <pitseleh> very kind :)
10:50:15 <EvilTerran> Heffalump, isn't (***id) = first?
10:50:27 <Deewiant> indeed it is
10:50:40 <Heffalump> EvilTerran: yes, it is
10:50:45 <Heffalump> good point :-)
10:50:51 <Deewiant> @check \f x -> (f***id) x == first f x
10:50:55 * Heffalump had never really thought of it that way
10:51:00 <lambdabot>  OK, passed 500 tests.
10:51:54 <vixey> > let glop reps = map (\x -> maybe x id (lookup x reps)) in glop [('r','l'),('l','r')] "greetings all"
10:51:55 <lambdabot>  "gleetings arr"
10:53:41 <paolino> mmhh the fact I use mostly (id &&& f) just shade the fact (id *** f) is second f, I should neil it also
10:56:04 <vixey> :t (&&&)
10:56:06 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:56:12 <Deewiant> @ty (id &&&)
10:56:14 <lambdabot> forall a c'. (a -> c') -> a -> (a, c')
10:56:17 <conal> philosophical comments on "Haskell goes bowling": http://reddit.com/info/6iv5u/comments/
10:57:31 * SamB for some reason wonders if bowling is related to golfing
10:59:25 <fasta> Does Haskell (or some other nice language like Scheme) already compile to some very simple machine language (might be of virtual machine) that has a simple low-level semantics?
11:00:03 <fasta> s/of/of a
11:00:11 <Baughn> fasta: IIRC, it compiles to a variant of C--
11:00:28 <mux> there are some LLVM bindings for haskell, if that can help
11:00:53 <Beelsebob> fasta: if you look at early work on compiling functional languages they all compile down to something machine-code like
11:01:30 <fasta> I basically am talking about a target language that has a minimal amount of instructions (less than ten should certainly be doable (as theoretical constructions only require one)).
11:01:32 <SamB> mux: how would that help?
11:01:49 <SamB> fasta: what do you want to use it for???
11:02:04 <vixey> fasta: You want to define this VM or find one someone else invented?
11:02:07 <Beelsebob> fasta: so, a Haskell to brainfuck compiler?
11:02:23 <SamB> Beelsebob: that sounds really really nast
11:02:29 <Beelsebob> yep yep it does
11:02:33 <fasta> Beelsebob: how does brainfuck compile to a simple machine language?
11:02:43 <Beelsebob> fasta: brainfuck *is* a simple machine language
11:02:48 <fasta> Beelsebob: or how is brainfuck a simple machine language?
11:02:51 <vixey> much easier to compile branfuck to C
11:02:53 <mux> SamB: well that would be a virtual machine language
11:03:02 <SamB> fasta: BF has only 8 instructions
11:03:09 <SamB> does that not stike you as simple?
11:03:21 <SamB> also each of them does something quite simple
11:03:24 <mux> small != simple
11:03:32 <vixey> it is simple too though
11:03:43 <mahogny> look at VAX. never again will you require asm instructions to be simple
11:03:47 <mux> yeah
11:03:48 <SamB> did I mention none of them have operand fields?
11:03:57 <DRMacIver> Brainfuck was basically designed to be simple to compile wasn't it?
11:04:04 <SamB> yes
11:04:06 <fasta> I doubt brainfuck is easy to debug.
11:04:10 <mux> brainfuck was designed?
11:04:13 <SamB> designed to facilitate a 256 byte compiler
11:04:18 <SamB> mux: yes!
11:04:21 <Beelsebob> DRMacIver: brainfuck was designed to fuck brains
11:04:36 <SamB> fasta: certainly not!
11:04:54 <DRMacIver> fasta: I think the problem with wanting an instruction set that small will be getting tolerably efficient numerical operations in that small an instruction set.
11:04:59 <SamB> fasta: what are you actually hoping for?
11:06:21 <fasta> Best case would be if a language I can program well (e.g. Haskell) had a compiler that would compile to a small language (without all the linking business etc.). Then I could use that output to write what I want.
11:07:01 <monochrom> The STG-machine is low level and has nice semantics.
11:07:12 <SamB> fasta: what do you want?
11:07:37 <SamB> maybe you'd like GRIN?
11:08:08 <jpcooper> how can I find the size of a tuple?
11:08:16 <DRMacIver> GRIN?
11:08:50 <SamB> jpcooper: you already know
11:08:52 <DRMacIver> (Ah, Graph Reduction Intermediate Notation)
11:09:12 <fasta> I heard of GRIN, but I know no details.
11:09:15 <jpcooper> SamB, it seems that I don't
11:09:26 <SamB> jpcooper: how do you know that it is a tuple, then?
11:09:52 <jpcooper> alright
11:10:22 <fasta> jpcooper: you can define a sizeOfTuple function in a typeclass, if you want.
11:10:29 <jpcooper> the first entry of an empty list must be a certain size
11:10:56 <jpcooper> this is defined by the parameter list
11:12:58 <vixey> You might want to replace all uses of tuples with lists actually
11:13:13 <vixey> if you're wanting to do things like length, recursion ..
11:13:45 <jpcooper> right
11:13:57 <fasta> The first entry of an empty list is undefined.
11:14:13 <DRMacIver> Although in principle with a decently defined set of type classes there's no reason you can't do recursion, length etc. on tuples.
11:14:38 <vixey> DRMacIver: GHC is limited to 61-tuples
11:14:49 <vixey> sorry 62-tuples
11:15:01 <ddarius> vixey: So don't use 62-tuples.
11:15:05 <DRMacIver> That's probably sufficient to requirements. :)
11:15:28 <vixey> so typeclasses are a non-solution
11:15:30 <fasta> They should implement tuples in a non-hacky way.
11:15:40 <jpcooper> why is there a limit?
11:15:50 <vixey> fasta: Prolog defined , as an infix operator
11:15:54 <conal> ML used to have only pairs, with "," as a binary operator.  so you could still write (a,b,c,d) as an expression or pattern.
11:16:12 <vixey> fasta: You could do this in Haskell too (with a different operator)
11:16:20 <conal> binary-only removes a raft of inconsistencies
11:16:24 <vixey> it means that (X,Y) = (a,b,c) though
11:16:32 <conal> definitely!
11:16:34 <fasta> vixey: you can also just use it as syntax.
11:16:38 <ddarius> class TList a where length :: a -> Int; instance TList () where length _ = 1; instance TList b => TList (a,b) where length (_,b) = 1+length b
11:16:48 <vixey> fasta: yes, I'm only talking about syntax
11:16:51 <DRMacIver> conal: Yeah, I like that approach.
11:17:03 <SamB> conal: but unfortunately it doesn't interact nicely with _|_
11:17:19 <conal> DRMacIver: i suspect the move away binary-only was a performance optimization.
11:17:31 <fasta> vixey: there is no reason why the compiler cannot recognize (a,b,c,.... , <letter 1 million>) as a tuple.
11:17:32 <conal> DRMacIver: and maybe now we have better analysis/optimization tools
11:17:40 <SamB> however, it's fantastic with these newfangled dependently-typed "total" langauges
11:18:01 <DRMacIver> SamB: I think it can be made to play nicely with _|_ if you're careful with strictness.
11:18:07 <conal> SamB: example of a problematic interaction?
11:18:12 <ddarius> SamB: They're newfangled?
11:18:23 <fasta> The total languages are still too stupid. There are lots of ways to encode proofs and they should all be implemented to make an acceptable language, imho.
11:18:26 <SamB> ddarius: well, they are only just becoming trendy afaict
11:18:39 <DRMacIver> SamB: If you have a one-tuple type which is lazy in its argument and a binary tuple type which is strict in the right argument and lazy in the left it should work
11:18:53 <ddarius> Where trendy = sub community of a sub community...
11:18:54 <vixey> yeah Coq takes the same approach as Prolog
11:19:00 <DRMacIver> Oh, actually you can make the one-tuple just an a,()
11:19:02 <fasta> Most language implementors keep using the same old demos (but now with a new syntax!!!).
11:19:03 <vixey> in defining tuples
11:19:13 <SamB> well, Agda 2 is using darcs for their repository
11:20:14 <fasta> Turner wrote about that some time ago. Anyone who knows what he is doing now?
11:22:09 * SamB is trying to implement papers
11:22:18 <SamB> also, I like Agdas library
11:23:01 <saml> f :: a -> Foo a, g :: a -> Bar a,     do { mapM f xs; mapM g xs; }    i can't do that because f and g belong to different monads
11:23:22 <saml> oh i see the problem.
11:34:08 <Cale> saml: Yeah, you'll likely have to "run" the first monadic computation somehow, and then do the other one.
11:34:30 <Cale> Unless there is some mapping  Bar a -> Foo a or Foo a -> Bar a which you can use.
11:34:41 <dolio> Clearly we need edwardk's split up Bind class.
11:34:59 <vixey> heheh
11:35:52 * saml turnes Foo and Bar into FooT and BarT and use them to create a monad and put mapM f .. and mapM g .. in that monad
11:36:00 <xif> you misspelled "function" there
11:38:21 <Cale> I suppose there's that too :)
11:38:42 <Cale> Then you will have appropriate liftings to use :)
11:38:49 <Cale> (or polymorphism)
11:40:14 <vixey> "A language restricted to structural recursion cannot encode its own interpreter'
11:41:13 <olsner> what's structural recursion as opposed to other kinds of recursion?
11:41:50 <ddarius> olsner: Recursion on the structure.  Essentially using folds only.
11:41:52 <vixey> the size of your data should always be decreasing in a structural call
11:42:28 <olsner> oh, I see, so that's not nearly turing complete
11:43:00 <Cale> Uh, will it always be decreasing? If the data is infinite won't it stay the same?
11:43:22 <vixey> yeah, it has to be on inductive data
11:43:26 <ddarius> Cale: Infinite "data" is codata (or worse).  You don't fold over it.
11:43:30 <vixey> coinductive stuff like that is all different
11:44:31 <Cale> > foldr (\x xs -> [x] : map (x:) xs) [] [0..]
11:44:34 <lambdabot>  [[0],[0,1],[0,1,2],[0,1,2,3],[0,1,2,3,4],[0,1,2,3,4,5],[0,1,2,3,4,5,6],[0,1,...
11:45:08 <dolio> We're talking about a language that actually takes a principled stand on the issue, I assume, not Haskell.
11:45:22 <ddarius> data and codata coincide in Haskell
11:45:40 <Cale> This is #haskell ;)
11:45:50 <visof> hi
11:46:04 <visof> i try to clean yi , and i had:
11:46:16 <visof> Setup.hs:22:15: Not in scope: `compilerPath'
11:46:21 <visof> what this mean?
11:47:12 <fasta> visof: probably a wrong version of Cabal installed.
11:47:15 <vininim> visof: the homepage says something about cabal versions
11:47:32 <visof> so
11:47:40 <visof> what should i do ?
11:48:27 <fasta> Yi isn't easy to install, I guess. You should just send an e-mail to the author to get good build instructions.
11:49:05 <visof> is he dons ?
11:49:14 <fasta> If the author (or maintainer) has no interest in providing those, fork or abandon. :)
11:49:28 <fasta> visof: someone else maintains it now, IIRC>
11:49:43 <fasta> It should all be on the wegage.
11:49:47 <fasta> webpage*
11:50:58 <fasta> That happens a lot in Haskell land: "Look at me, I have version 0.0000000000000000001 of this GREAT software" (and then it doesn't compile).
11:51:24 <visof> hehe
11:51:31 <waern_> visof: jyp is the maintainer of yi
11:56:02 <vixey> this is nice
11:56:39 <vixey> use |> for return and <| for bind, so liftM_n becomes |> f <|^n
11:56:43 <vixey> looks better in TeX though..
11:57:00 <Botje> i hope that f isn't claustrophobic
11:57:11 <vixey> hehe
12:00:41 <sizur> @users
12:00:42 <lambdabot> Maximum users seen in #haskell: 463, currently: 460 (99.4%), active: 16 (3.5%)
12:01:08 <sizur> anything exciting?
12:01:20 <vixey> hi sizur
12:01:24 <sizur> like a GUI tool shaping up?
12:02:02 <sizur> Grapefruit winning?
12:03:06 <sizur> vixey: heya, you new in #haskell?
12:04:32 <vixey> I guess so, been around a while though
12:04:56 <sizur> vixey: welcome :) i havent logged in for quite a while ... i guess
12:15:39 <vixey> let (^2) = liftM2 in ((+)^2) (Just 1) (Just 7)
12:15:45 <vixey> > let (^2) = liftM2 in ((+)^2) (Just 1) (Just 7)
12:15:45 <lambdabot>  Parse error in pattern at "in" (column 19)
12:22:36 <ddarius> > let f ^ 2 = liftM2 f in ((+)^2) (Just 1) (Just 7)
12:22:37 <lambdabot>  Just 8
12:22:57 <vixey> cool
12:23:13 <ddarius> If you are hoping to then have f ^ 3 be liftM3 you are out of luck.
12:23:19 <vixey> yeah :(
12:25:58 <ehird> is there a function like mktemp?
12:26:03 <ehird> in IO obviously
12:26:46 <ari> @index mkstemp
12:26:46 <lambdabot> System.Posix.Temp, System.Posix
12:27:03 <mux> @hoogle openTempFile
12:27:03 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
12:28:37 <ehird> mux: a good strategy would be to use openTempFile and then close it, right?
12:28:39 <ehird> to reserve it
12:29:03 <ehird> see, for haskellnomic, I'm writing the best registration captcha ever - You have to enter a haskell expression that compiles :-)
12:29:27 <mux> ehird: under POSIX yes; now I don't know what openTempFile does
12:29:32 <mux> @src openTempFile
12:29:32 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:29:48 <ehird> Only one way to find out.
12:29:51 <ehird> To the ghcioscope!
12:30:10 <mux> if by closing it you meant unlink() it, and by reserving it you meant have it be deleted once done
12:30:12 <ddarius> ehird: Doesn't 1 work?
12:30:45 <ehird> ddarius: huh what
12:30:48 <ehird> well
12:30:48 <ehird> yes
12:30:52 <ehird> but i'm going to put a minimum length on
12:30:56 <saml> newtype TI ...  newtype TIT  lol tit
12:31:03 <ehird> so, a haskell expression of 5 or more characters
12:31:06 <wjt> 555555555
12:31:07 <ehird> (\x -> x) is the simplest
12:31:16 <ddarius> ehird: Why not specify the type?
12:31:18 <ehird> also, __regcheck will also work
12:31:26 <ehird> :P
12:31:34 <ehird> 'module Regcheck where __regcheck = expr'
12:31:40 <ehird> ddarius: Eh.
12:31:48 <ehird> It's simpler this way.
12:31:56 <ddarius> "Write an expression with type [(Char,Int)]?"
12:32:01 <ddarius> How is it any simpler?
12:32:10 <ehird> ddarius: 'cause people just have to think of the first valid haskell expr
12:32:11 <ehird> :P
12:32:25 <vixey> ?djinn [(Char,Int)]
12:32:25 <lambdabot> -- f cannot be realized.
12:32:31 <ehird> haha
12:32:47 <vixey> well ddarius' way outfoxes djinn
12:33:03 * mux hearts mapMaybe (\(b,x) -> guard b >> return x)
12:33:27 <vixey> @src mapMaybe
12:33:27 <lambdabot> Source not found. Are you on drugs?
12:33:28 <ddarius> mux: Some crazy cond?
12:33:33 <mux> ddarius: yup
12:33:40 <vixey> is mapMaybe = liftM map?
12:33:44 <mux> I had n functions which could each return something or not
12:33:48 <mux> based on some conditions
12:34:14 <mux> so I used mapMaybe (...) [(somecond, x), (someothercond, y), ...]
12:34:31 <mux> with the mapMaybe parameter that I wrote above of course
12:34:49 <vixey> What's mapMaybe?
12:35:04 <ari> @type (liftM map) `asTypeOf` mapMaybe
12:35:06 <lambdabot>     Couldn't match expected type `a -> b'
12:35:06 <lambdabot>            against inferred type `Maybe b1'
12:35:06 <lambdabot>     Probable cause: `mapMaybe' is applied to too many arguments
12:35:16 <ari> :t mapMaybe
12:35:17 <mux> a variant of map where the function returns a Maybe a rather than just a a, and where returning Nothing means "remove the element form the list"
12:35:18 <vixey> :t mapMaybe
12:35:18 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
12:35:20 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
12:35:25 <mux> it's just catMaybes . map
12:36:18 <ari> mux: (catMaybes .) . map
12:36:36 <vixey> would you call f Nothing = [] ; f (Just x) = [x] a morphism?
12:36:41 <mux> err, right - functions with more than one parameter suck :-)
12:38:08 <vixey> mapMaybe = (f =<<) . map -- is also valid?
12:40:26 <ari> :t (=<<) . map
12:40:28 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b) -> f (f a) -> f b
12:40:38 <ehird> ddarius: Think I should print out the error ghc spews if the compilation fails?
12:41:49 <saml> is there a way to verify if my instantiation of monad is valid?
12:41:58 <wjt> :t (=<<) . Prelude.map
12:42:00 <lambdabot> forall a b. (a -> b) -> [[a]] -> [b]
12:44:25 <ehird> @pl \a b -> a >>= (return . b)
12:44:25 <lambdabot> (. (return .)) . (>>=)
12:44:38 <ehird> @hoogle (Monad m) => m a -> (a -> b) -> m b
12:44:39 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
12:44:39 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
12:44:39 <lambdabot> Data.Function.($) :: (a -> b) -> a -> b
12:44:42 <ehird> :|
12:44:44 <ehird> @type fmap
12:44:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:44:46 <wjt> shame it doesn't notice that that is flip fmap
12:44:49 <ehird> aha
12:45:08 <ehird> wjt: not all monads are functors.
12:45:14 <wjt> true
12:46:33 <vixey> :t flip liftM
12:46:35 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
12:46:36 <ehird> hm
12:46:40 <ehird> -- doesn't work as a ghc arg
12:46:47 <ehird> (i.e. 'end all opts, next is a filename')
12:46:59 <saml> can I export a module imported with qualification?
12:47:19 <saml> module Foo (module Control.Monad.Trans) where   import qualified Control.Control.Trans as T
12:47:32 <SamB> why not?
12:47:43 <SamB> but if there are conflicts, that will be bad :-(
12:48:23 <saml> The export item `module Control.Monad.Trans' is not imported
12:48:50 <SamB> er. say "module T"
12:49:31 <saml> oh thanks SamB
12:49:54 <ehird> Hm. GHC won't compile to /dev/null
12:49:54 <ehird> :(((
12:52:09 <dons> ehird: sure, -o /dev/null used to work.
12:52:20 <dons> ehird: however... you can also just set the programs that would do the compilation to 'true'
12:52:31 <dons> e.g. -pgmc true
12:52:32 <ehird> dons: heh
12:52:35 <dons> to use 'true' as your C compiler
12:52:42 <ehird> that's deliciously evil
12:52:44 <ehird> now why won't -o /dev/null work
12:52:45 <ehird> ;)
12:52:45 <dons> -fno-code also works for this
12:53:29 <ehird> dons: OK, that generates .hi and .ho though
12:54:50 <ehird> and I can't seem to disable that
12:55:12 <dons> -hidir /dev/null -odir /dev/null ?
12:55:19 <ehird> clever
12:55:43 <vixey> This is really cool http://strictlypositive.org/unify.ps.gz
12:55:46 <ehird> dons: If, by clever, I mean:
12:55:47 <ehird> ghc-6.6: error: directory portion of "/dev/null" does not exist (used with "-odir" option.)
12:56:16 <dons> hmm
12:57:20 <dons> so, $ ghc -O  a.hs  -pgmc true -pgml true -no-recomp works ok for getting no code, but still .hi and .o are created
12:57:31 <dons> -hidir /dev/null
12:57:31 <dons> /dev/null: createDirectory: already exists (File exists)
12:57:32 <dons> sadly
12:57:35 <ehird> $ ghc -fno-code -hidir /dev/null -odir /dev/null test.hs
12:57:41 <ehird> if only there was a directory sink
12:58:05 <ehird> echo 'a'>/sink/x; ls /sink (blank)
12:58:49 <Baughn> ehird: Well, you could make one with FUSE
12:59:19 * ehird pets the little overengineerer
12:59:50 <Baughn> In fact, I might post a patch to linux-kernel just to see their expressions
13:00:16 <Baughn> mount -t dirnull dirnull /dev/dirnull. ^_^
13:01:22 <dons> kernel programmers never think about base cases. otherwise we'd have null everythings
13:02:04 <mux> kernel programmers don't like to add stuff unless it's very very very needed
13:02:12 <ehird> So.
13:02:13 <ehird> What do I do.
13:02:50 <mux> the idea of a directory sink has come up a few times in the past as far as I remember, but everytime it's just one or two guys saying "it would be nice" and everyone leaves it at that
13:02:56 <vixey> I wish Phd thesis were a bit .. shorter
13:03:13 <ehird> dons: can't you specify an output /file/ for .hc and stuff?
13:03:17 <ehird> err, .hi
13:03:29 <wjt> heh, so this hypothetical dirnull mounted on /tmp would break applications which create temporary files insecurely; it could be used to automate checking for such bugs
13:03:32 <dons> don't think so.
13:03:44 <dons> wjt: interesting
13:04:03 <Heffalump> wjt: wouldn't it break those that create them securely too?
13:04:13 <vixey> wjt: maybe you should inform libgreat?
13:04:13 <Baughn> Not with the right semantics
13:04:30 <vixey> (I don't realy understand it enough)
13:04:39 <Baughn> You could allow applications to open/create files on /devnull, but deny any opening by name
13:04:48 <wjt> right
13:04:51 <Baughn> That would actualy be very useful
13:04:52 <mux> there are various tmpfs implementation if you want
13:05:11 <Baughn> That don't let /other/ applications open your files?
13:05:13 <Heffalump> Baughn/wjt: I don't follow
13:05:28 <mux> the dirnull thing leaves a lot to be desired because the semantics of the various things one can do with a directory are not natural
13:05:48 <wjt> Heffalump: there is an atomic "create-and-open" syscall; this dirnull could make that work usefully, and make straight create appear to succeed but not actually create a file
13:05:56 <ehird> anyone?
13:05:58 <Baughn> Heffalump: App1 opens /devnull/a with O_CREAT, and gets a file. App2 tries to open /devnull/a, and gets an error. The directory listing remains empty. App3 tries to open it with O_CREAT, and gets a /new/ one.
13:06:14 <Heffalump> ah
13:06:24 <Heffalump> I sort of see.
13:06:24 <Baughn> Heffalump: Also, no possibility whatsoever of lost space if the program crashes
13:06:46 <Baughn> If it helps, think of it as an atomic kernel-level create-open-unlink
13:07:22 <Baughn> And yes, this could be done with a very tiny patch to tmpfs
13:07:46 <wjt> vixey: oh, i'd not seen libgreat before.  nice!
13:11:57 <ehird> Anyone?
13:12:07 <ehird> <Baughn> Heffalump: App1 opens /devnull/a with O_CREAT, and gets a file. App2 tries to open /devnull/a, and gets an error. The directory listing remains empty. App3 tries to open it with O_CREAT, and gets a /new/ one.
13:12:10 <ehird> I was thinking:
13:12:17 <ehird> app1 opens /devnull/a with O_CREAT and gets a file
13:12:22 <ehird> oh
13:12:22 <ehird> no, wit
13:12:24 <ehird> you're right
13:12:24 <ehird> yes
13:12:28 <ehird> that's exactly what I was thinking
13:16:37 <ehird> :\
13:16:41 <ehird> Surely just checking a haskell source file isn't hard
13:26:11 <saml> http://hpaste.org/7544  TInfer has TI monad in the core. TI is an instance of TIMonad. but why can't TInfer derive TIMonad class?
13:26:39 <ehird> Hmm.
13:26:49 <ehird> Is there a better strategy for just checking if something is a valid haskell expr?
13:26:53 <ehird> Than compiling it.
13:29:29 <ibid> ehird: depends a lot on your use case
13:29:34 <saml> ghc -n is dry run. it creates hi files
13:29:47 <ehird> saml: Can I have that without the hi ;)
13:30:35 <ehird> Hmmmm.
13:30:40 <ehird> openTempFile doesn't let others read it.
13:31:11 <mux> that's good
13:31:19 <ehird> mux: But not for this
13:31:23 <mux> similar to mkstemp() which unlink()'s the file right after having opened it
13:31:35 <ehird> Right but I need to let ghc read it.
13:31:46 <ehird> This would be fine if ghc would listen from stdin
13:31:52 <mux> you could still create a pipe and send it there
13:32:03 <ehird> mux: ghc will only open bonafide files
13:32:09 <mux> ehird: well, use /dev/stdin
13:32:12 <mux> most OSes have it now
13:32:18 <ehird> mux:
13:32:22 <ehird> it actually refuses to
13:32:25 <ehird> ghc-6.6: cannot compile this file to desired target: /dev/stdin
13:32:32 <ehird> it'll only accept Right True Proper files
13:32:43 <mux> it shouldn't be able to make the difference
13:32:54 <ehird> mux: Well it does
13:33:36 <mux> and it doesn't accept '-' either
13:33:43 <ehird> Correct
13:33:45 <mux> that ought to be fixed
13:33:49 <ehird> :t mktemp
13:33:53 <lambdabot> Not in scope: `mktemp'
13:33:58 <ehird> @hoogle mktemp
13:33:59 <lambdabot> No matches found
13:34:02 <ehird> @hoogle temp
13:34:02 <lambdabot> Distribution.Extension.TemplateHaskell :: Extension
13:34:02 <lambdabot> Language.Haskell.Extension.TemplateHaskell :: Extension
13:34:02 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
13:34:04 <ehird> @hoogle tmp
13:34:04 <lambdabot> Data.Generics.Aliases.extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
13:34:04 <lambdabot> Distribution.PackageDescription.extraTmpFiles :: PackageDescription -> [FilePath]
13:34:07 <ehird> @hoogle mktmp
13:34:08 <lambdabot> No matches found
13:34:09 <ehird> wtf
13:34:10 <ehird> :|
13:35:35 <mux> mmm, it's actually looking for /dev/stdin.hs and /dev/stdin.lhs
13:35:51 <ehird> mux: hah
13:35:54 <ehird> that's stupid
13:35:59 <ehird> is it possible to ifx
13:36:07 <mux> there should be some option to tell ghc that we really mean to pass it a file
13:36:12 <mux> as opposed to a module name
13:36:28 <mux> if there is, it shouldn't try to append .hs or .lhs
13:36:55 <ehird> that we should.
13:38:19 <ehird> yayyy
13:38:21 <ehird> I got it working
13:39:05 <ehird> http://hpaste.org/7545
13:41:02 <mux> ehird: so it was the -n flag?
13:41:09 <ehird> mudge: yep
13:41:11 <ehird> mux
13:41:22 <mux> cool
13:41:33 <ehird> checkcaptcha "validcode" -> Nothing
13:41:39 <ehird> checkcaptcha "anythingelse" -> Just ghc_errors
13:41:43 <ehird> *checkCaptcha
13:41:47 <ehird> in IO
13:45:14 <jaj> HaskellNomic.Captcha {
13:45:16 <jaj> ?
13:45:36 <mux> maybe "All good!" ("Uh oh..."++) <$> getLine <*> checkCaptcha
13:47:45 <Baughn> @hoogle unsafePerformIO
13:47:46 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
13:47:46 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
13:48:32 <ehird> jaj: what?
13:48:42 <ehird> mux: :-)
13:49:30 <jaj> ehird: is that a library you wrote yourself?
13:50:31 <ehird> jaj: I just wrote that now
13:51:11 <ehird> jaj: it handles the captcha for haskellnomic.
13:51:12 <jaj> ehird: oh, oj
13:51:13 <ehird> a code nomic I'm writing
13:51:17 <ehird> anyway, going now
13:51:24 <jaj> bye!
13:55:33 <pitseleh> can you use catch on let foo = (read bar :: Int) (for input)?
13:55:55 <pitseleh> since there's no IO about it..
13:56:26 <pitseleh> though a getInt function would return IO Int
14:03:01 <gwern> @wn dyev
14:03:02 <lambdabot> No match for "dyev".
14:03:08 <gwern> @wn babushka
14:03:08 <lambdabot> *** "babushka" wn "WordNet (r) 2.0"
14:03:08 <lambdabot> babushka
14:03:08 <lambdabot>      n : a woman's headscarf folded into a triangle and tied under
14:03:08 <lambdabot>          the chine; worn by Russian peasant women
14:03:44 <dolio> Chine?
14:11:38 <saml> if I have MyMonad and MyMonadT, do I have to make both of them instance of MonadState, Functor...etc?  or just MyMonadT?
14:12:29 <dmwit> both
14:12:41 <dmwit> Or, you can define MyMonad = MyMonadT IdentityMonad and be done with it.
14:13:00 <dmwit> I don't recall what the actual name of IdentityMonad is, though.
14:13:40 <vixey> Identity
14:13:42 <dolio> Identity
14:16:19 <saml> dmwit: oh that's niffy!
14:18:35 * EvilTerran would've just called Identity "Id", but never mind
14:19:29 <saml> how come mtl doesn't use that technique (State = StateT Identity) ?
14:20:42 * Baughn wonders why opengl/glut behaves so oddly in ghci
14:20:43 <EvilTerran> mtl broke new ground, so it's not the best polished design
14:20:49 <EvilTerran> i imagine MonadLib is better in that regard
14:21:03 <wjt> presumably because the definition of the non-transformer variant is clearer when written directly?
14:22:15 <EvilTerran> ... what
14:33:26 <awesame> where can I read about Haskell 2?  google is failing me.
14:33:35 <Japsu> !go haskell prime
14:33:42 <Japsu> @go haskell prime
14:33:44 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/
14:33:44 <lambdabot> Title: Haskell Prime - Trac
14:33:56 <vixey> Haskell 2 doesn't exist..?
14:34:32 <vixey> @go Agda 2
14:34:33 <lambdabot> http://en.wikipedia.org/wiki/Agda_(theorem_prover)
14:36:08 <Japsu> I assume what awesame erroneously referred to as "Haskell 2" is actually Haskell Prime
14:37:18 <dmwit> Since the last Haskell standard was Haskell 98, Haskell 2 would be quite a step back. =)
14:37:52 <awesame> nope, I meant haskell 2
14:38:24 <awesame> I blogged about Haskell', and someone commented suggesting that Haskell 2 might be more to my liking
14:38:36 <olsner> maybe the next one could be Haskell 109 (since we're obviously counting years offset by 1900)
14:39:22 <monochrom> Haskell 2 may refer to a non-existent vision.
14:39:27 <awesame> I think after Haskell 98 the traditional next step is Haskell XP
14:39:35 * allbery_b thought that trick was reserved for perlies (19100)
14:39:37 <SamB> Haskell 2000
14:39:39 <Beelsebob> awesame: >.<
14:39:44 <monochrom> Haskell Millenium
14:39:54 <SamB> except yeah it might be more of a Haskell ME afaict
14:39:57 <Beelsebob> Haskell Millenium edition, also known as C
14:40:32 <Baughn> Haskell releases aren't offset by 1900, they're simply referring to CSY instead of CE
14:40:50 <Baughn> Computer Standard Year, that is
14:41:06 <SamB> of course, the horrible version of Haskell where only the warts remain is called Haskell 3000, after Python 3000
14:41:33 <monochrom> There is no discuss on Haskell 2 yet. However, discussion on Haskell Prime may refer to Haskell 2 meaning "we'll leave ___ for the future".
14:42:56 <Beelsebob> Anyway, in a way, Haskell 98 was Haskell2
14:43:11 <Beelsebob> in that it was the first major revision after the 1.0-1.5 series
14:51:51 <pitseleh> exit
14:51:55 <pitseleh> lol
14:52:00 <pitseleh> not a python prompt
14:54:01 <dolio> Heh, "I would like to propose that we make a concerted effort to completely finalize Haskell 2 by Jan 1, 2000"
14:58:33 <olsner> so, we went haskell 1.5, haskell 98, haskell 2 (which disappeared before actually becoming anything?), then eventually maybe haskell prime?
14:58:44 <olsner> inconsistent versioning scheme is inconsistent :P
14:59:41 <ddarius> We've settled on the one true way.
14:59:45 * ddarius can't wait for Haskel''
15:00:06 <dolio> Haskell 1.5 never existed. They were thinking about that name but chose 98 instead.
15:00:26 <dolio> And I assume Haskell 2 is what they were calling Haskell' back when they were deciding on that name.
15:01:39 <clanehin> @seen gwern
15:01:40 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 58m 31s ago.
15:02:03 <dolio> Actually, most people seemed to not want to call it Haskell 1.5. They wanted to call it "Standard Haskell" or something similar, because that sounds more long-term.
15:02:08 <dolio> Which it certainly has been.
15:02:51 <mux> can someone clue me in as to the correct usage of unsafePerformIO?
15:03:02 <dolio> Some people seemed to want "Teaching Haskell."
15:03:13 <dons> mux, its ok if you can write a pure version of the same function, with identical behaviour
15:03:30 <mux> more specifically, I was wondering if I could use it in the case the function just performs IO to have some internal caching for optimisation, and is still referentially transparent
15:03:36 <dons> right.
15:03:37 <mux> dons: ah, great !
15:03:43 * mux hearts dons
15:03:54 <mux> that's really, really great
15:03:55 <dons> referntial transparency is the key rule.
15:04:11 <dons> from the outside, you should not be able to see any `IO'-like things
15:04:12 <mux> makes me wish unsafePerformIO had a less scary name
15:04:20 <mux> I'd have already used it by now :)
15:04:21 <dons> so usually this restricts it to allocation/reading of memory
15:04:58 <dons> ST usually works in the same situatoin
15:05:07 <dons> but people don't use stToIO much
15:05:19 <SamB> mux: well, what name can you think of that says "YOU must prove that it is safe to perform this IO"
15:05:27 <dons> btw, if anyone wants to have a go at a complete rewrite of the current nbody program, i think its ripe for it.
15:05:37 <dons> the current performance is inexplicably poor
15:05:46 <mux> while you're here, if you don't mind: does the addition of type families and type synonyms gives us a mechanism to deal with having code working for any kind of String (ByteString, etc...)
15:05:53 <ddarius> SamB: youMustProveThatItIsSafeToPerformThisIO
15:05:54 <dons> there appear to be no optimisation problems, so i think the approach is just wrong
15:06:04 <dons> so, easy points for porting the Clean version to GHc.
15:06:10 <mux> SamB: I've always sucked hard at finding good names
15:06:16 <dons> mux, yes, it does.
15:06:17 <SamB> ... and yet still gets the point across that it would perform the IO?
15:06:25 <mux> isolatedIO? referentiallyTransparentIO ?
15:06:33 <mux> dons: *jumping in excitement*
15:06:41 <dons> mux, I think a String class which uses associated types to set up the representation string type, might work well
15:06:41 <SamB> mux: er, that sounds too fuzzy
15:06:47 <SamB> it's suppose to have a scary name!
15:06:55 <dolio> The latter sounds like it magically makes your IO referrentially transparent. :)
15:06:57 <SamB> *supposed
15:07:04 <dons> e.g. instance StringT Byte  where newtype StringT Byte = StringT ByteString
15:07:17 <dons> instance StringT Char where newtype StringT Char = StringTChar [Char]
15:07:18 <mux> dons: being able to change some components without touching other is a very desirable fature for production haskell code
15:07:30 <mux> the inability to easily switch the type of the string being used has annoyed me
15:07:51 <dons> i've not thought through the full implications of this, but similar tricks are working well for the uvector arrays library
15:07:58 <mux> okay, cool
15:08:12 <dons> instance (RealFloat a, UA a) => UA (Complex a) where newtype UArr  (Complex a)   = UAComplex  !(UArr (a :*: a))
15:08:29 <vixey> StringT = [] ?
15:08:30 <dons> says, if you want an array of Complex, actually, go represent it with an array of pairs of real and imaginary
15:08:33 <dons> works nicely
15:08:45 <dons> so maybe we can come up with some cleverly overloaded string class this way
15:09:02 <dons> sjanssen: ^ you might be interested
15:09:22 <dons> i'll write a blog post about this during the week, i htink
15:09:36 <dons> at least the use of associated types to do clever representation tricks safely
15:09:44 <mux> dons: so we don't actually need module polymorphism?
15:10:05 <dons> classes + type familes == modules
15:10:13 <dons> there's a formal translation
15:10:13 <mux> rrrrrrrr
15:10:27 <mux> paint me happy
15:10:27 <dons> some people consider it a poor man's modules though
15:10:36 <dons> however, if the semantics check out, i'm fine. :)
15:11:14 <mux> I can foresee even more work in churning the Prelude to make it more generic - maybe for Haskell' ?
15:11:25 <mux> or have an alternative prelude
15:11:35 <vixey> Cale Haskell
15:11:58 <vixey> hopefully
15:11:59 <Cale> :)
15:12:00 <SamB> dons: I'd want syntax to go with that...
15:12:19 <Cale> Seems I'm going to have to change my last name if this keeps up.
15:12:30 <mux> dons: now that you say it, I feel stupid - it seems clear that a type class with a type and function on this type is pretty much the same as an ML module
15:12:39 <Korollary> Hascale
15:12:45 <mux> Korollary: nice one!
15:16:09 <monochrom> Nice. I have always said "put together several things in Haskell to approximate ML functors". Now we can strengthen that to equivalence.
15:17:19 <dons> SamB: yeah, nbody likes array syntax
15:17:37 <dons> SamB: but i think maybe a careful Vector3 type, and a UArr instance (using UVector) might work well.
15:17:42 <dons> we can set up the value packing
15:19:29 <SamB> I meant with the typeclasses-as-modules thing...
15:20:25 <dons> SamB: oh, syntax schimtax
15:21:04 <dons> maybe that's what I'll do, two birds in one stone: rewrite nbody to use uvectors, in a pure/ST manner, and show how to setup a Vector UArr with associated types at the same time.
15:21:23 <dons> we can absolutely do better in this nbody program
15:21:35 <dolio> That won't get on the shootout, will it?
15:21:36 * mux goes to read the description of the program
15:24:55 <dons> dolio: if i ask very nicely, it will
15:25:11 <czakey> whats the problem
15:25:20 <czakey> with new lambdabot?
15:25:25 <dons> its a funny problem, ghc seems to be generating excellent code, but its way behind, so i think there must be some tricks the C/Clean etc are doing
15:25:30 <dons> ?bot
15:25:31 <lambdabot> :)
15:25:38 <czakey> > "whatever" fd:7: hClose: resource vanished (Broken pipe)
15:25:39 <lambdabot>   Not in scope: `pipe'
15:25:51 <czakey> fd:7: hClose: resource vanished (Broken pipe)
15:26:01 <czakey> Ive compiled recently
15:26:10 <czakey> and get that error
15:26:12 <mux> you're probably not running it from the good directory
15:26:21 <mux> and it can't find the many utilities it needs to run
15:26:27 <czakey> there where no problem before
15:26:41 <czakey> and I think that Im in a good place...
15:26:56 <mux> maybe you've got another problem then :)
15:27:15 <czakey> only with new code
15:27:27 <czakey> maybe ill have to revert ;)
15:27:38 <czakey> but thats not a solution
15:28:16 <dons> > 1+2
15:28:17 <lambdabot>  3
15:29:07 * gwern reads up on ubuntu upgrade to 8.04; this is pretty gutsy of them: https://wiki.ubuntu.com/DashAsBinSh
15:29:56 <dons> not as gutsy as RunHaskellAsBinSh
15:30:00 <czakey> looks like every use of > fails
15:30:07 <dons> czakey: do you have the 'runplugs' program?
15:30:09 <czakey> dons: haha
15:30:09 <mux> czakey: > needs runplugs
15:30:16 <czakey> dons: yup
15:30:20 <dons> does it work?
15:30:25 <dons> echo "1 + 2" | ./runplugs
15:30:33 <SamB_XP> dons: I'm fairly certain that that isn't POSIX at all
15:30:41 <czakey> $ echo "1 + 2" | ./runplugs
15:30:42 <czakey> runplugs: setResourceLimit: invalid argument (Invalid argument)
15:30:46 <czakey> strange
15:30:48 <dons> there we go.
15:30:54 <gwern> dons: we don't have any POSIX shell implementations
15:31:03 <dons> czakey: so maybe poke around scripts/RunPlugs.hs to tweak the setResourceLimit call
15:31:53 <czakey> ok
15:32:19 <czakey> [2 of 2] Compiling Main             ( scripts/RunPlugs.hs, dist/build/runplugs/runplugs-tmp/Main.o )
15:32:25 <czakey> i hope that will help
15:32:27 <czakey> ;)
15:32:33 <mux> use build.sh
15:32:34 <gwern> anyone know what package 'HTam' might be?
15:32:39 <czakey> up
15:32:42 <czakey> im using it
15:33:11 <czakey> runplugs: setResourceLimit: invalid argument (Invalid argument)
15:33:13 <czakey> hmm
15:33:16 <czakey> the same
15:33:29 <czakey> ok, ill try to find out what wrong with that
15:33:37 <dons> you could try just removing the resource limit call
15:33:45 <czakey> (speaking about 2 lambdabots on different computers ;))
15:33:46 <dons> but you should try to find out what's wrong with it
15:35:30 <gwern> clanehin: yes?
15:36:19 <jadrian> is there a name for functions with no monomorphic types?
15:36:33 <SamB_XP> jadrian: eh?
15:36:45 <jadrian> like map
15:36:55 <clanehin> gwern: it depends on how flexible the module is going to be, I like to retain the ability to run roguestar over a network.  It should be possible to install the shell script using an instHook.
15:37:04 <SamB_XP> map has scads of monomorphic types
15:37:21 <jadrian> the type of map has no monomorphic types
15:37:23 <monochrom> polymorphic function?
15:37:39 <gwern> clanehin: yes, it should be, but I don't see how rewriting it as a haskell script loses us anything
15:37:42 <SamB_XP> what about them ->s?
15:37:51 <SamB_XP> those are type constructors!
15:38:07 <gwern> it's not doing any crazy special shell stuff like 'eval'
15:38:08 <jadrian> monochrom:    so you wouldn't call polymorphic to say,   (Int, a) -> a
15:38:22 <monochrom> But I would.
15:38:44 <gwern> clanehin: I mean, it's just two Strings, and three shell commands, if you count sleep
15:39:08 * gwern isn't suggesting turning roguestar-engine into a library and linking it into roguestar-gl or anything
15:39:46 <czakey> @hoogle hSetResourceLimit
15:39:47 <jadrian> monochrom: so is there some sensible way to name functions that are 'completely' polymorphic, and some others which have some type variables but also some type constants?
15:39:47 <lambdabot> No matches found
15:39:47 * gwern sighs. argh. so many libs break with qc2
15:39:58 <monochrom> No.
15:40:00 <czakey> @hoogle setResourceLimit
15:40:00 <lambdabot> No matches found
15:40:09 <SamB_XP> jadrian: the only one I know with no type constants is undefined
15:40:12 <jadrian> monochrom: that sucks :)
15:40:29 <monochrom> In "[a]->[a]", [] and -> are type constants.
15:40:47 <jadrian> well those are type constructores
15:40:51 <clanehin> gwern: That sounds ok, then.
15:40:55 <monochrom> Int is a type constructor.
15:41:07 <jadrian> ok... got your point
15:41:14 <gwern> @hoogle sleep
15:41:14 <lambdabot> No matches found
15:41:26 <monochrom> This is now reminding me of a recent "is a square a rectangle" fiasco.
15:41:36 <gwern> isn't it?
15:41:58 <mauke> not if rectangle has a set_width method
15:42:01 <jadrian> So maybe the proper way to say it would be no constant type constructors of rank 0 ?
15:42:06 <gwern> or is it obvious if you apply kleisli arrows to the natural transformation on segments that they are in no wise the same...
15:42:32 <gwern> setWidth x _ = x * x?
15:43:02 <monochrom> Methinks there is no rational need to label "[a]->a" and "(Int,a)->a" differently.
15:43:08 <jadrian> or maybe
15:43:28 <jadrian> types where the only type constructors of rank 0 allowed are type variables
15:43:34 <mauke> void foo(Rectangle r) { r.set_width(1); r.set_height(2); assert(r.width() == 1); }
15:43:52 <jadrian> there's monomorphic to mean "no type variables"
15:44:13 <jadrian> and I wanted a name for "no type constants of rank 0"
15:44:22 <jadrian> I think that's better now
15:44:36 <gwern> @hoogle run
15:44:37 <lambdabot> Control.Concurrent.runInBoundThread :: IO a -> IO a
15:44:37 <lambdabot> Control.Concurrent.runInUnboundThread :: IO a -> IO a
15:44:37 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
15:44:38 <monochrom> You know, even monomorphic vs polymorphic is an unneeded distinction most of the time.
15:44:39 <SamB_XP> jadrian: what is so special about such functions?
15:44:43 <gwern> @hoogle runCmd
15:44:44 <lambdabot> No matches found
15:44:55 <monochrom> Only compiler writers need worry about monomorphic vs polymorphic.
15:44:56 <gwern> @hoogle runSystem
15:44:58 <lambdabot> No matches found
15:44:58 <SamB_XP> @free ord
15:45:00 <lambdabot> ord = ord
15:45:03 <gwern> bargle
15:45:14 <SamB_XP> monochrom: you get REALLY BORING free theorems from monomorphic functions
15:45:19 <mauke> @free undefined
15:45:21 <lambdabot> f undefined = undefined
15:45:25 <SamB_XP> @free 0
15:45:25 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:45:31 <SamB_XP> @free []
15:45:32 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:45:33 <clanehin> gwern: this is actually pretty good, because I can do away with that silly empty roguestar package.
15:45:34 <mauke> what
15:45:35 <jadrian> SamB_XP: I'm just studying some semantics and wanted to refer to that case
15:45:36 <mauke> since when is f strict?
15:45:40 <SamB_XP> @free singleton
15:45:42 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `singleton'\n\n"
15:45:47 <jadrian> SamB_XP: no big deal really
15:46:03 <SamB_XP> what did you want to say about it?
15:46:04 <monochrom> Well, the boredom depends on the number of type variables in the type.  "Int->a"'s free theorem is also pretty boring.
15:46:20 <SamB_XP> @free f : Int -> a
15:46:20 <lambdabot> Extra stuff at end of line
15:46:21 <jadrian> SamB_XP: not sure yet because I'm coming up with the semantics
15:46:24 <SamB_XP> @free Int -> a
15:46:25 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:46:28 <gwern> clanehin: I was going to quietly suggest scrapping the meta-repo and the autotools stuff, but I was afeared you'd object to there being no easy way to generate the pdf from within the cabal
15:46:29 <SamB_XP> @help free
15:46:30 <lambdabot> free <ident>. Generate theorems for free
15:46:34 <gwern> besides editing Setup.hs anyways
15:46:37 <mauke> @free f :: Int -> a
15:46:37 <lambdabot> g . f = f
15:46:45 <SamB_XP> hah
15:46:49 <SamB_XP> too much Agda, eh?
15:46:49 <jadrian> SamB_XP: it's just useful to be able to say, now I'm not really going to consider any "non variable types"
15:47:24 <monochrom> "I'm not going to consider non-square rectangles"?
15:47:38 <jadrian> monochrom: yeap
15:47:46 <jadrian> monochrom: pretty much it
15:48:30 <jadrian> monochrom: well actually, I'd say something more along the lines of
15:48:35 * gwern wonders what the idiomatic way of sleeping is
15:48:39 <jadrian> monochrom: now I just want to consider squares
15:48:47 <mauke> gwern: go to bed, close your eyes, etc
15:49:06 <monochrom> If you're teaching geometry, I'm pretty sure everything you'll teach about rectangles are true for squares too. Maybe uninteresting for squares, but you don't have to exclude them. Just focus on rectangles in general.
15:49:09 <ddarius> @ft undefined
15:49:11 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
15:49:11 <lambdabot>  Press `:help' for help or `:quit' to quit.
15:49:11 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
15:49:11 <lambdabot>  > The free theorem for the type signature
15:49:11 <lambdabot>    f :: forall a . a
15:49:13 <lambdabot> [3 @more lines]
15:49:17 <gwern> mauke: but that's too pointful - I'd get some sleep accomplished
15:49:22 <ddarius> wtf?
15:49:25 * gwern wants to know the pointsfree way!
15:49:47 <jadrian> monochrom: yes that is the case, but in terms of presentation it simplifies to consider it is a square first
15:49:57 <EvilTerran> @ft undefined :: a
15:49:57 <gwern> argh. so 'sleep' doesn't do anything useful, and all the 'delay's are useless
15:49:59 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
15:49:59 <lambdabot>  Press `:help' for help or `:quit' to quit.
15:49:59 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
15:49:59 <lambdabot>  > The free theorem for the type signature
15:49:59 <lambdabot>    f :: forall a . a
15:50:01 <lambdabot> [3 @more lines]
15:50:02 <gwern> what is the in-haskell way to sleep?
15:50:03 <jadrian> monochrom: and then move on to the rectangle
15:50:05 <EvilTerran> oh dear
15:50:33 <ddarius> @ft :help
15:50:35 <lambdabot>  FTshell (version 0.2) - Automatic generation of free theorems
15:50:35 <lambdabot>  Press `:help' for help or `:quit' to quit.
15:50:35 <lambdabot>  Loading `/home/cgibbard/local/share/ftshell-0.2/ftshell-0.2/declarations.hs' ... found 187 declarations.
15:50:35 <lambdabot>  > > >
15:50:48 <mauke> :t threadDelay
15:50:50 <monochrom> You think [a]->a is more basic, [(Int,a)]->(Int,a) less basic?
15:50:53 <lambdabot> Not in scope: `threadDelay'
15:51:03 <jadrian> monochrom: yeap, in my case it is
15:51:36 <EvilTerran> it seems that @free works, but @ft breaks, according to my experiments in pm
15:51:37 <orbitz> hrm. so i isntalld fingertree by doing  ghc -package Cabal-1.2.3.0 --make Setup.hs; ./Setup configure .. build .. install which al lwent sucessful, however yi's Setup still complains that fingertree -any is missing.  any suggestison on what to do?
15:51:41 <EvilTerran> @free undefined :: a
15:51:41 <lambdabot> f undefined = undefined
15:51:56 <EvilTerran> ... that's impressive. :o
15:51:57 <gwern> orbitz: bet you arebn't configuring yi with --user
15:51:58 <jadrian> monochrom: I'm using different kinds of structures to interpret   a  and  Int
15:52:17 <jadrian> monochrom: so getting rid of Int makes the whole structure less complex
15:52:24 <monochrom> This is confounding. I have no further comments.
15:52:42 <jadrian> monochrom: and I can focus on the only thing that matters which is the interpretation of the a's
15:52:46 <ddarius>  @free assumes the functions are strict, @ft explicitly states that assumption
15:52:48 <orbitz> gwern: i just added a --user to it, same eror (does --user take a parameter?)
15:52:49 <jadrian> and functions built from them
15:52:54 <clanehin> dons: I think that darcs-graph doesn't handle darcs 2.0.  fromJust error.
15:53:39 <ehird> I am back. Gasp.
15:53:46 <gwern> orbitz: that's a weird way to install fingertree, anyway; why didn't you use the usual 'runhaskell' dance?
15:53:48 <orbitz> gwern: opening ghci and doing import Data.FingerTree fails too
15:53:52 <gwern> clanehin: http://hpaste.org/7546
15:53:53 <jadrian> monochrom: I do agree with you that the 1st function is not more complex than the 2nd really... it's just about my presentation, making triples into tuples and getting rid of one kind of morphisms
15:54:15 <orbitz> gwern: i'm battlign conflicting instructions. i'll try that
15:54:24 <gwern> orbitz: ok, if ghci doesn't see it at all, I would guess you installed badly
15:54:34 <ddarius> triples are tuples
15:54:42 <jadrian> ddarius: pairs sorry :)
15:54:57 <dons> clanehin: oh, interesting!
15:55:08 <dons> clanehin: thanks for the report. the patch names have likely changed.
15:56:18 <orbitz> gwern: doin git via runghc worked. stupid me i guess
15:58:37 <orbitz> is gtk2hs under a different name in hackage?  (or can i just direcltyc ompile yi with a coca interface?)
15:59:04 <gwern> orbitz: not in hackage at all :(
15:59:59 <clanehin> gwern: I'll happily accept that.  It's much better than what I have right now.  But I forgot to mention an issue that's really orthogonal to "should we use a shell script."  To really do it right, we should generate the absolute paths at configure time -- a major point of a prefix being to have two installed versions at once.
16:00:35 <gwern> clanehin: that's doable, I think, but difficult
16:00:58 <gwern> (well, not really, but I say that because I'm lazy)
16:01:06 <clanehin> gwern: I don't care if it doesn't get done with this patch.  At least this way we can install two versions at all.
16:01:10 <orbitz> gwern: d'oh
16:01:16 <gwern> however, the easy path would require rogestar-engine and -gl to be merged? hm
16:01:42 <gwern> clanehin: what I'm thinking of is http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
16:01:43 <lambdabot> Title: Neil Mitchell's Haskell Blog: Adding data files using Cabal, http://tinyurl.com/364awx
16:03:49 <gwern> clanehin: hm. why does the opengl interface start up before the engine?
16:03:58 <gwern> why not & them both and just omit the sleep?
16:04:30 <clanehin> gwern: I think it was a hack to make netpipes happy.  There's probably a better way.
16:04:44 <clanehin> gwern: one wouldn't find the socket, and just quit.
16:05:23 <gwern> oh. I was thinking of reordering them to make the engine go first
16:05:24 <clanehin> gwern: I guess the better way would be to block on the socket existing.
16:05:29 <gwern> just seems more logical to me
16:05:56 <clanehin> gwern: afaik they're reversable.
16:06:15 <gwern> great
16:08:17 <clanehin> gwern: well, the client and engine can assume that they are installed in the same path.  I think that's a reasonable expectation to place on the user.  So the data file stuff will work even if it references something not in its own package.
16:09:11 <gwern> mm... you don't think it'll ever be the case the engine will get installed to /usr/bin and the user will install -gl to ~/bin/bin?
16:09:50 <gwern> http://hpaste.org/7546#a1
16:10:16 <clanehin> gwern: threadDelay?
16:10:33 <gwern> clanehin: but what thread would be delayed? it's not creating any threads
16:11:03 <clanehin> it just has to delay itself
16:11:33 * gwern wonders if that would work
16:14:05 <gwern> http://hpaste.org/7546#a2
16:14:43 <clanehin> gwern: hmm, not quite: faucet has to run before hose, I meant that whether the engine or client runs first is reversable
16:15:23 <gwern> bleh
16:16:06 <gwern> so I'd want 'faucet engine' >> 'hose gl'?
16:17:35 * gwern notices lambdabot doesn't seem to be announcing the pastes
16:18:27 <orbitz> chessguy: get back in your cage
16:18:33 <chessguy> @hoogle (a -> Bool) -> [a] -> [a]
16:18:34 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
16:18:34 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
16:18:34 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
16:18:35 <EvilTerran> lambdabot never announces the pastes. that's hpaste's job.
16:18:35 <gwern> 'src/Models/Ascendant.hs:14:7:
16:18:36 <gwern>     Couldn't match expected type `ModelingM () t'
16:18:38 <gwern>            against inferred type `MaterialM attr ()''
16:18:39 <gwern> hm
16:18:39 <chessguy> @more
16:18:40 <EvilTerran> @seen hpaste
16:18:40 <lambdabot> I haven't seen hpaste.
16:18:57 <chessguy> @hoogle+
16:18:58 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
16:18:58 <lambdabot> Data.List.dropWhile :: (a -> Bool) -> [a] -> [a]
16:18:58 <lambdabot> Data.List.filter :: (a -> Bool) -> [a] -> [a]
16:19:06 <chessguy> @hoogle+
16:19:21 <chessguy> @src takeWhile
16:19:21 <lambdabot> takeWhile _ []                 =  []
16:19:21 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
16:19:21 <lambdabot>                    | otherwise =  []
16:19:53 <chessguy> what, no 'takeUntil'?
16:20:12 <gwern> takeWhile (not foo)?
16:20:41 <chessguy> oh, duh
16:22:49 <Cale> Actually, there used to be a takeUntil which was slightly different from takeWhile (not f)
16:23:04 <gwern> really? how did it differ? off-by-1?
16:23:07 <Cale> yeah
16:23:30 <Cale> It would include the element which satisfied the criterion.
16:23:44 <orbitz> was it removed?
16:23:48 <Cale> yep
16:23:55 <orbitz> reasoning?
16:24:16 <gwern> confusing/redundant, I'd guess
16:24:17 <Cale> Probably simplicity.
16:25:11 <EvilTerran> yeah, you could get that by adding a "drop 1", under the current prelude
16:25:30 <Cale> er
16:25:38 <Cale> You mean zipping the list with itself?
16:26:08 <Sadache> Hello everyone
16:26:18 <chessguy> @seen everyone
16:26:18 <lambdabot> I haven't seen everyone.
16:26:40 <gwern> clanehin: I just got it installed and running with the new script
16:26:48 <gwern> it looks much much better than the last time I played!
16:27:54 <Sadache> I have a question:is it possible in haskell to define instances of classes for types outside the module where they're defined?
16:28:26 <Cale> yes
16:28:37 <Sadache> I meant outside the module where the types are defined...
16:28:42 <EvilTerran> yes
16:28:56 <EvilTerran> as long as you've imported the type into the module you're defining the instance in
16:28:56 <Cale> right. You can have types in one module, classes in another and instances in a third.
16:29:05 <EvilTerran> (and the instance. gotta import that too)
16:29:55 <Sadache> great, then can i use "deriving" in another module than the type one?
16:30:10 <Cale> Not without an extension, for syntactic reasons.
16:30:28 <Cale> In ghc 6.8, I believe there's a new declaration for deriving though.
16:30:55 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
16:30:55 <lambdabot> Title: 8.5. Extensions to the "deriving" mechanism, http://tinyurl.com/2ts9ot
16:31:48 <gwern> clanehin: incoming
16:32:06 * clanehin runs for cover
16:32:16 <Sadache> so it is not yet a standard right?
16:32:24 <Cale> right
16:32:27 <dons> its available with new ghc's only.
16:32:46 <Cale> However, you can simply write the instance which would have been derived by hand.
16:32:49 <Sadache> is it suggested for the haskell`?
16:32:59 <dons> yeah.
16:33:04 <Cale> Probably anyway.
16:33:08 <dons> though its not been widely used yet.
16:33:24 <dons> it does solve the problem of needing to derive at the declaration site though
16:33:36 <Cale> The standardisation process is a bit funny. The Haskell standard is perpetually obsolete :)
16:33:37 <Sadache> ok thanks very much
16:34:00 <Sadache> :)
16:34:17 <gwern> Cale: well, could be worse. we could be like perl, or common lisp, or scheme or perhaps maybe python
16:34:23 <Cale> sure :)
16:34:29 <gwern> (other contenders include C++0x)
16:35:24 <Cale> actually, scheme has a pretty decent process, no?
16:35:44 <Cale> "Here are a bunch of things which you can possibly implement, if you want."
16:36:23 <gwern> Cale: well, except for half the community saying FU, as I understand it
16:37:47 <lament> python is pretty awesome, what's wrong with it?
16:37:59 <lament> ignoring the whole py3k issue
16:38:07 <gwern> 3k is taking forever
16:38:14 <lament> yeah, ignore it
16:38:27 <gwern> lament: that's what I was referring to; I figure if haskell' and perl 6 are fair game...
16:38:28 <lament> 3k is almost a different language
16:38:34 <int-e> 992 years is a long time ...
16:39:01 <lament> perl 6 is also a different language from perl 5
16:39:06 <lament> from what i've read
16:39:08 <Cale> Yeah, python 3k is right on schedule ;)
16:39:16 <lament> but haskell' is pretty much haskell
16:39:25 <Cale> Sadly enough.
16:39:26 <lament> the way it's currently used already
16:39:42 <dons> ghc head is our future language.
16:40:27 <gwern> quite
16:40:58 * orbitz sighs, now it's complainign about alex (which i got off hackage and installed an di tsitll complains)
16:41:27 <gwern> I always wonder why a bunch of Common Lisp compiler devs don't get together and by sheer fiat declade that 'libraries x, y, and z are now the SBCL appendix to the CL Standard' or whatever, and start working on getting it through ansi
16:41:58 <gwern> I mean, they've known the old standard has been holding them back for like a decade now, surely
16:41:59 <lament> probably too much fighting over which specific x,y,z to choose
16:42:06 <lament> same as with Scheme
16:42:49 <gwern> yeah, but wouldn't the fight surface on reddit occasionally? I don't think I've ever seen any serious new standard proposals in the CL community
16:43:10 <gwern> (I mean, scheme still has an active process at least so they're not nearly as bad off)
16:44:41 <chessguy> @type \f x -> case x of Nothing -> Nothing; Just y -> Just (f y)
16:44:45 <lambdabot> forall t a. (t -> a) -> Maybe t -> Maybe a
16:45:33 <gwern> @wn praxis
16:45:35 <lambdabot> *** "praxis" wn "WordNet (r) 2.0"
16:45:36 <lambdabot> praxis
16:45:36 <lambdabot>      n : translating an idea into action; "a hard theory to put into
16:45:36 <lambdabot>          practice"; "differences between theory and praxis of
16:45:36 <lambdabot>          communism" [syn: {practice}]
16:45:37 <lambdabot>      [also: {praxes} (pl)]
16:45:59 <gwern> hm. good word to know
16:45:59 <chessguy> is that liftM or something?
16:46:03 <chessguy> @type liftM
16:46:05 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:46:30 <int-e> chessguy: fmap, so, yes.
16:48:49 <allbery_b> compare orthodoxy <-> orthopraxy
16:49:29 <chessguy> i ran across this word earlier:
16:49:37 <chessguy> @wn imprecate
16:49:37 <lambdabot> *** "imprecate" wn "WordNet (r) 2.0"
16:49:37 <lambdabot> imprecate
16:49:37 <lambdabot>      v 1: wish harm upon; invoke evil upon; "The bad witch cursed the
16:49:37 <lambdabot>           child" [syn: {curse}, {beshrew}, {damn}, {bedamn}, {anathemize},
16:49:37 <lambdabot>            {anathemise}, {maledict}] [ant: {bless}]
16:49:39 <lambdabot> [3 @more lines]
16:49:46 <dcoutts> @seen bos
16:49:46 <lambdabot> I saw bos leaving #haskell and #ghc 1h 2m 58s ago, and .
16:51:59 <dcoutts> @tell bos well that's just the thing, tags are useless. All they mean is "different from" but their ordering is screwed up. They compare equal as bags. Encouraging their use atm is a Bad Thing(tm).
16:52:00 <lambdabot> Consider it noted.
16:52:01 <allbery_b> yep, I ususally see it as "imprecation" (~= "curse")
16:52:04 <dcoutts> @tell bos See also the thread starting http://www.haskell.org/pipermail/cabal-devel/2008-May/002818.html
16:52:04 <lambdabot> Consider it noted.
16:52:43 <allbery_b> erm, as a noun, not verb.
17:01:16 <pitseleh> is it possible to output whatever happens in hugs to a file?
17:06:30 <dons> pitseleh:
17:06:31 <dons> $ runhugs A.hs > output
17:06:31 <dons> $ cat output
17:06:31 <dons> "hey, yah!"
17:06:31 <dons> $ cat A.hs
17:06:33 <dons> main = print "hey, yah!"
17:07:09 <dons> though if you want to log your session, that might be a bit harder
17:07:15 <dons> 'script' will certainly let you do htat.
17:08:07 <pitseleh> ah, script sounds like what i'm looking for
17:08:08 <pitseleh> thanks dons :)
17:08:26 <dons> no worries.
17:09:05 <dons> install ghc though, it makes life more vivid.
17:09:31 <pitseleh> i will for my next haskell excursion :)
17:09:36 <ddarius> vivid eh
17:09:58 <dons> ?web1913 vivid
17:09:59 <lambdabot> *** "Vivid" web1913 "Webster's Revised Unabridged Dictionary (1913)"
17:09:59 <lambdabot> Vivid \Viv"id\, a. [L. vividus, from vivere to life; akin to
17:09:59 <lambdabot>    vivus living. See {Quick}, a., and cf. {Revive}, {Viand},
17:09:59 <lambdabot>    {Victuals}, {Vital}.]
17:09:59 <lambdabot>    1. True to the life; exhibiting the appearance of life or
17:10:01 <lambdabot> [19 @more lines]
17:10:04 <Botje> in ghc 6.12, all monads have a different color
17:10:06 <dons> @more
17:10:06 <lambdabot>       freshness; animated; spirited; bright; strong; intense;
17:10:06 <lambdabot>       as, vivid colors.
17:10:07 <lambdabot>  
17:10:09 <lambdabot>             In dazzling streaks the vivid lightnings play.
17:10:11 <lambdabot>                                                   --Cowper.
17:10:13 <lambdabot> [14 @more lines]
17:10:21 <dons> In dazzling threads the vivid monads play.
17:10:24 <Botje> haskell types written by oleg is also executable Piet code.
17:10:34 <Botje> s/is/are/
17:12:18 <dons> looks like the monad laws. http://www.michaelnewberry.com/av/post/Piet_Mondrian_Tableau_11_1921-25.jpg
17:12:19 <lambdabot> http://tinyurl.com/6yxe3g
17:15:03 <Botje> I think that's a type error
17:15:18 <Botje> that yellow bar at the bottom should be half the size and green.
17:15:47 <jaj> :)
17:16:14 <Botje> or maybe just a bit more mauvish pink
17:16:29 <dons> hmm, so yellow is return, red is (>>=), blue is (>>), black is `ap` ?
17:16:30 <Botje> already our type errors are vivified!
17:16:34 <chessguy> @pl \c s -> m c s f
17:16:34 <lambdabot> flip flip f . m
17:17:04 <Botje> does that work at all?
17:17:08 <Botje> if so, i'd be amazed :)
17:17:38 <Botje> dons++ # look at the colors, children! wheeee!
17:18:35 <dons> i've thought for a while that you could generate mondrian-ish things by dumping the types out
17:18:45 <dons> and using those to assign colour to columns and rows
17:19:09 <ddarius> Columns and rows of what?
17:19:31 <dons> src. well, come up with some projection from regions in the code to a grid on canvas
17:19:45 <dons> you might even do it by colouring heap objects
17:20:21 <dons> two-colour IO and pure paintings
17:20:31 <Sadache> I am taking a part in a famous enterprise conference organization
17:20:35 <dons> 4 colour xmonad, X, ReaderT, WriterT, IO
17:20:36 <ddarius> What I want is a conference table as described in Paintable Computing where each of the components of the amorphous computer was equipped with an LED so you could see the execution.
17:21:14 <Sadache> the track i am helping to organize treats Functional Programming Languages in the enterprise
17:21:27 <dons> Sadache: which conference is this?
17:21:43 <chessguy> @type minus
17:21:45 <lambdabot> Not in scope: `minus'
17:21:52 <chessguy> @subtract
17:21:52 <lambdabot> Unknown command, try @list
17:21:56 <chessguy> @type subtract
17:21:58 <lambdabot> forall a. (Num a) => a -> a -> a
17:21:59 <dons> Sadache: check out the CUFP page, http://cufp.galois.com/
17:22:00 <lambdabot> Title: Commercial Users of Functional Programming
17:22:01 <Sadache> I thought that maybe you can guide me through names that actually did enterprise projects using Haskell
17:22:31 <dons> Sadache: the main companies are listed as either past CUFP speakers, or here, http://haskell.org/haskellwiki/Haskell_in_industry
17:22:32 <lambdabot> Title: Haskell in industry - HaskellWiki
17:22:45 <Sadache> and that have experience in Enterprise FP aplication
17:23:24 <Sadache> ok that is good, i ll look throught it
17:23:32 <dons> see also the commercial user's mailing list, http://groups.google.com/group/cufp/
17:23:32 <lambdabot> Title: CUFP | Google Groups
17:24:18 <dons> Sadache: here's the schedule for last year's commercial user's workshop, http://cufp.galois.com/2007/schedule.html
17:24:18 <lambdabot> Title: Commercial Users of Functional Programming 2007 Program
17:25:08 <Sadache> what i am looking for is someone that can clearly point out benefits of Haskell in enterprise on the architecture of the software, and on the team
17:25:32 <Sadache> thanks for the links, i ll go throught them
17:25:36 <dons> Sadache: you could invite speakers on the haskell@ list
17:25:44 <dons> or contact past speakers from CUFP.
17:26:11 <dons> typically, conference speakers are invited by contacting haskell@haskell.org
17:27:22 <Sadache> the conference is called QCon, it is the main conference organized by InfoQ.com
17:27:32 <dons> Sadache: here's the call for speakers to DEFUN, that went out recently, http://www.haskell.org/pipermail/haskell/2008-April/020316.html
17:27:32 <lambdabot> Title: [Haskell] DEFUN08: Call for Talks & Tutorials (co-located w/ ICFP08)
17:27:43 <dons> if you did something similar, i'd expect to get a few respondants, you could choose between
17:27:53 <dons> the other idea might be to try to get Simon Peyton-Jones
17:28:03 <dons> he's a truly excellent speaker
17:28:39 <dons> he spoke at OSCON last year, http://conferences.oreillynet.com/cs/os2007/view/e_spkr/3429
17:28:40 <lambdabot> Title: O'Reilly Open Source Convention 2007 &#8226; July 23-27, 2007 &#8226; Portland,  ...
17:29:31 <dons> Sadache: but in general, ask on the mailing lists. and let me know if you need any other help. (i'm helping organise DEFUN, so can point you to some possible people)
17:29:54 * SamB tries to write data Kâ‚ a x = Kâ‚ a -- constant
17:29:59 * SamB fails miserably :-(
17:30:05 <kpreid> dons: DEFUN? since when are you into lisp?
17:30:07 <kpreid> :-)
17:30:08 <Sadache> we had Simon in QCon london, he did a very good presentation. However what I am looking for is to have the speaker talking about a particular experience, on different level. We want something more enterprisey as most of our audience are architects and managers of Enterprises
17:30:35 <SamB> Sadache: ooooooh
17:30:43 * SamB like warp drives
17:30:58 <dons> kpreid: i didn't get to choose the name, unfortunately
17:31:22 <dons> Sadache: right, so perhaps someone from Credit Suisse, ABN Amro, or Galois.
17:31:41 <Sadache> *different levels: architecture, management, code reuse...etc
17:32:17 <dons> or some of the other companies listed on the industry page. sending an invitation to haskell@haskell.org will also reach most of the industrial users
17:33:33 <saml> if monad Foo and Bar both use ErrorT, and when I combine them to make monad Boo, would it be ok?
17:33:41 <Sadache> I guess I will try to contact Lenard too from Credit Swiss
17:33:41 <Sadache> Lennard was invited for London but he couldn't make it
17:34:03 <ddarius> Lennart
17:34:13 <dons> Sadache: yeah, he's one of the most experienced industrial users.
17:34:40 <Sadache> yep, sorry Lennart
17:34:49 <SamB> oh well. At least I can get away with this one...
17:34:54 <SamB> data (p :Ã— q) x = Pair (p x) (q x)  -- pairing
17:35:30 <Sadache> He caught a cold before his session (a DSL written in Haskell for banking) so it was unforunaitly canceled
17:36:04 <dons> i heard QCon went quite well.
17:36:10 <dons> there was certainly a lot of blog buzz
17:37:00 <saml> typechecking runs in TI monad. TI has state of name-type mappings. evaulation runs in Eval monad. Eval keeps state of name-code mapping. how would you combine them to build Repl monad? user can define new function in repl and both name-type and name-code mappings are updated
17:37:10 <Sadache> I beleive that Haskell is getting more and more famous, especially after the LinQ project release
17:37:29 <dons> a lot of ideas are certainly popping up from haskell, in other languages.
17:37:40 <ddarius> We're attacking them from the inside!
17:37:59 <Sadache> ddarius: :) I like it
17:38:05 <Pseudonym> :-)
17:38:24 <Pseudonym> On a more serious note, I think this really does show why Haskell is important.
17:38:41 <Pseudonym> Where another language might hack, Haskell will not compromise on purity.
17:38:55 <Sadache> F# is a good candidate as well
17:39:00 <Pseudonym> So it's better to leave a feature unimplemented than to implement it badly.
17:39:23 <dons> yeah, F# is turning into a strange hybrid of ML and Haskell
17:39:34 <Sadache> It has a lot to do with Haskell, but unfortunaitly without type classes, my favourite feature of haskell!
17:39:37 <Pseudonym> So when Haskell actually does come up with a solution, it's invariably beautiful.
17:40:47 <Sadache> I guess it was because of the CLR, Simon told that it was almost impossible to implement Haskell on the CLR thats why they came up with F#
17:41:22 <Sadache> CLR is the .NET virtual machine
17:41:28 <dons> i can't imagine why it would be any harder than F#
17:41:56 <dons> just translate GHC Core to F#, and be done with it :)
17:42:05 <Pseudonym> I think the problem isn't the VM per se.
17:42:14 <Pseudonym> It's that .NET languages have to be able to inter-call each other.
17:42:18 <dons> yeah, i suspect its .NET interop
17:42:23 <Pseudonym> Yeah.
17:42:30 <dons> the F# stuff just imports .NET OO code all over
17:42:37 <dons> much to some MLers distate
17:42:44 <Sadache> that is what Simon told, myself I don't know for sure
17:42:44 <dons> dis-taste.
17:42:47 <Pseudonym> I can imagine that calling a .NET library would force a lot of things to be in a monad.
17:42:53 <dons> yeah.
17:43:12 <Sadache> ah, i see maybe it is this then, keeping the interop
17:43:41 <dons> if you just want to import and use a big body of impure .NET code, that'll need to be partitioned in Haskell, while in F# they've already given up on purity
17:43:53 <dons> so it doesn't destabilise things further than they already are.
17:44:19 <dons> actually compiling haskell itself for .NET has been done a couple of times
17:44:36 <dons> there's also an FFI bridge
17:49:08 <saml> given newtype A a = A { runA :: ErrorT String (StateT Int Identity) a }, how can I write the transformer, AT?
17:49:52 <saml> newtype AT m a = AT { runAT :: ErrorT String (StateT Int Identity) m a }
17:50:11 <SamB> newtype AT m a = AT { runAT :: ErrorT String (StateT Int m) a }
17:50:45 <SamB> this one was easy because you had the Identity monad at the bottom of the stack
17:51:20 <saml> what if I had different monad? like my custom monad?
17:51:42 <SamB> you would nead a customT to replace it with ;-)
17:52:03 <saml> then  CustomT Identity at the bottom?
17:52:10 <SamB> eh?
17:52:24 <SamB> you take the Identity out when making the T version
17:53:06 <saml> newtype A a = A { runA :: ErrorT String (StateT Int Custom) a } deriving (...)
17:53:11 <ddarius> A monad transformer is a type function monad -> monad.  You can compose them to get other monad transformers.  Identity is a monad.  You apply a monad transformer to a monad and get a monad.
17:53:43 <saml> newtype AT m a = AT { runA :: ErrorT String (StateT Int (CustomT m)) a } deriving (...)  ?
17:53:54 <dobblego> where is the source to the identity monad?
17:54:04 <ddarius> @hoogle Identity
17:54:08 <lambdabot> Control.Monad.Identity :: module
17:54:08 <lambdabot> Control.Monad.Identity.Identity :: newtype Identity a
17:54:08 <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a
17:54:22 <dobblego> ta
17:54:29 <dons> ?src Identity
17:54:29 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
17:54:33 <saml> http://haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Identity.html
17:54:35 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5qh36f
17:57:51 <ddarius> @docs Control.Monad.Identity
17:57:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html
17:58:15 <ddarius> @source Control.Monad.Identity
17:58:15 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Identity.hs
17:59:19 * SamB wants Haskell with Agda syntax now
17:59:59 <dolio> Yeah, that happened to me, too.
18:00:21 <SamB> dolio: wanting Agda syntax?
18:00:27 <dolio> Yeah.
18:01:02 <SamB> this calls for the invention of the HEH
18:01:14 <dolio> The only problem is writing [ a ] instead of [a].
18:01:25 <SamB> hmm.
18:01:29 <dolio> I think that's the only case where it bothers me.
18:01:57 <SamB> that could be special-cased
18:02:19 <SamB> (but the question is HOW, I suppose...)
18:02:22 <saml> newtype AT m a = AT { runAT :: ErrorT String (StateT Int m) a } deriving (MonadState Int, MonadError String, Monad, Functor)    how can I implement    instance (Monad m) => MonadTrans (AT m)  where lift m = ???
18:02:56 <SamB> lift m = lift (lift m) -- at least I think that would work
18:04:26 <ddarius> lift = lift . lift
18:05:09 <saml> instance MonadTrans AT where lift = lift . lift  -- gives me Occurs check: cannot construct the infinite type: m = t m
18:05:21 <pastorn> @type lift
18:05:22 <edwardk> samb: regarding the expanded operator set, unicode everywhere and the fancy precedence rules for compound function names like if_then_else_ ?
18:05:34 <lambdabot>     Ambiguous occurrence `lift'
18:05:34 <lambdabot>     It could refer to either `SimpleReflect.lift', defined at scripts/SimpleReflect.hs:64:0
18:05:34 <lambdabot>                           or `Control.Monad.Error.lift', imported from Control.Monad.Error
18:05:44 <dolio> AT . lift . lift
18:06:08 <Speck> Hi all. I installed a bunch of packages using cabal-install in user mode. Now I need to install a package with cabal manually (i.e., with runhaskell Setup.hs) and it can't find the packages I installed using cabal install. Is this a common issue?
18:06:19 <edwardk> samb: i'll admit i started a switch from the base for kata's syntax to that of agda for that reason last night. =)
18:06:36 <saml> ah forgot that. thanks dolio
18:06:48 <mux> ST is good
18:06:57 <SamB> edwardk: yes! also I just tried to use subscripts on some constructor names
18:07:07 <SamB> it did NOT work :-(
18:07:47 <mux> I converted a function that was using an IOUArray for speed and unsafePerformIO - now I rewrote it with an STUArray, got to replace unsafePerformIO with runST, it's safer and substantially faster
18:07:53 <edwardk> something like Prepend_Onto_ or something like that for cons?
18:08:00 <mux> win-win situation
18:08:08 <SamB> edwardk: I tried this:
18:08:17 <SamB> data Kâ‚ a x = Kâ‚ a -- constant
18:08:44 <edwardk> ah
18:08:51 <dons> mux, substantially?
18:09:02 <dons> mux, there should literally be no difference, if the operations are the same
18:09:08 <mux> from 1.30s to 1.10s specifically
18:09:15 <mux> running via ghci too
18:09:22 <dons> mux, i'm keen to tackle any performance disparities between array types like this
18:09:31 <dons> can you compile it? (-O2 ) ?
18:09:35 <SamB> edwardk: but got a lexical error on what I presume to be the codepoint for â‚
18:09:39 <mux> dons: okay
18:09:48 <Valodim_> @pl
18:09:49 <lambdabot> (line 1, column 1):
18:09:49 <lambdabot> unexpected end of input
18:09:49 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:09:52 <dons> mux, also, is it self-contained? could you send me the code? (or do you know why it is faster?)
18:10:04 <edwardk> samb: drat
18:10:13 <dons> mux, e..g did you replace ! with unsafeRead ?
18:10:32 <ddarius> dons: While it shouldn't really make much of a difference here, doesn't unsafePerformIO block some optimizations?
18:10:49 <mux> nope, only unsafePerformIO replaced with runST, plus the change in the type signatures
18:11:11 <dons> ddarius: oh, yes, unsafePerformIO is not runST. unsafeDupablePerformIO would be better
18:11:33 <dons> mux, ok. definitely interested. send the code :)
18:11:42 <SamB> edwardk: at the moment, I'm somewhat disgruntled that the only thing I've gotten away with is
18:11:44 <mux> dons: it's some code from euler problem 76 where an array for is needed for caching
18:11:47 <SamB> data (p :Ã— q) x = Pair (p x) (q x)  -- pairing
18:11:51 * dons is library micro-optimisation czar for a few months
18:12:09 <monochrom> dons czar
18:12:27 <dons> monochrom czar?
18:12:27 <SamB> does the czar get a funky crown?
18:12:38 <dons> a crown of spikey lambdas :(
18:12:46 <Valodim_> @pl parse_triples (x:y:z:xs) = (x,y,z) : parse_triples xs
18:12:48 <mux> you'll have to pass a very very big parameter to p and p' for the benchmarking to be usable, it goes too fast otherwise
18:12:51 <lambdabot> parse_triples = fix ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip (flip . ((flip .
18:12:51 <lambdabot>  (((.) . (:)) .)) .) . (,,)))
18:12:51 <lambdabot> optimization suspended, use @pl-resume to continue.
18:12:52 <monochrom> @bothack
18:12:52 <lambdabot> :)
18:12:55 <dons> and decorated with #'s
18:12:59 <Valodim_> ...
18:13:00 <Speck> Do I need to do some configuration to make ghc look for my user packages? Compiles complain of not being able to find packages I installed in user mode.
18:13:08 <mux> dons: and also, the results are wrong, fwiw, because of Int overflows, but it didn't matter in the original exercise
18:13:10 <dons> mux, yep. just mail to me, with details of how to run it. got the email addr?
18:13:18 <mux> remind me
18:13:25 <mux> dons@galois.com ?
18:13:28 <dons> that's it.
18:13:32 <mux> sure
18:13:34 <edwardk> samb: i'm waiting for their lack of nfkc-style normalization on unicode operators/names to bite them in the ass. i skimmed the code there is no codepoint normalization done. so 'a' <grave> and Ã  which appear identical in an editor, etc will be different variable names. talk about obfuscation! =)
18:13:45 <Valodim_> is there a function "every third of a list"
18:14:38 <Botje> Valodim_: map (\x y z -> (x,y,z)) $ while (not . null) $ unfoldr (Just . splitAt) list
18:15:00 <Botje> Just . splitAt 3, even
18:15:06 <dons> unfoldr++
18:15:51 <gnuvince_> :t unfoldr
18:15:58 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:16:17 <saml> http://hpaste.org/7552  this monad transformer is hard
18:16:19 <mux> dons: sent
18:16:26 <Valodim_> thanks
18:17:13 <dons> thanks mux
18:17:13 <dolio> let f (x:y:z:zs) = Just ((x,y,z),zs) ; f _ = Nothing in unfoldr f [1..20]
18:17:19 <dolio> > let f (x:y:z:zs) = Just ((x,y,z),zs) ; f _ = Nothing in unfoldr f [1..20]
18:17:24 <lambdabot>  [(1,2,3),(4,5,6),(7,8,9),(10,11,12),(13,14,15),(16,17,18)]
18:17:38 <Botje> or that.
18:17:39 <monochrom> The dog ate my tail.
18:17:56 <mux> dons: I suppose you guessed that p(n) == number of partitions
18:18:00 <dolio> > let f (_:_:x:xs) = Just (x,xs) ; f _ = Nothing in unfoldr f [1..20]
18:18:01 <lambdabot>  [3,6,9,12,15,18]
18:18:09 <dons> mux, what kind of 'n' gives a reasonable runtime?
18:18:15 <Botje> unfoldr++
18:18:23 <mux> dons: 5000 was nice for ghci on my machine, didn't try for compiled code
18:18:30 <dons> ok
18:18:39 <dons> you care about performance, but aren't compiling? :)
18:18:41 <saml> lift = BT . lift . lift   did it work because B monad had 2 transformers? hence 2 lifts
18:19:00 <mux> dons: I was curious, and just run a few tests in ghci with :set +t, that's about it :-)
18:19:22 <dons> $ time ./euler76 100000
18:19:22 <dons> 1552493300098067990
18:19:23 <dons> ./euler76 100000  4.71s user 0.10s system 99% cpu 4.844 total
18:19:26 <dons> is a reasonable value
18:19:53 <mux> did you change to Integer's for it not to overflow?
18:19:55 <dons> 4.816 with IO.
18:20:11 <dons> so looks pretty much identical with and without ST, in optimised code.
18:20:30 <mux> tried with ghci and see if you can reproduce the difference I was talking about?
18:20:46 <Speck> Hmm. When a make command runs ghc, it can't locate my user packages, but when I run the same ghc command manually it works. What could cause this?
18:20:59 <Valodim_> [Word8] -> Ptr Word8
18:21:11 <mux> Speck: probably some changes in the environment
18:21:19 <Valodim_> how would I do that
18:21:24 <mux> like make(1) doesn't have $HOME defined or something similar
18:21:43 <dons> mux, yeah, maybe 10% faster with ST.
18:22:06 <dolio> How about with uvector? :)
18:22:19 <dons> yeah, looks like a good uvector program
18:22:22 <mux> fuse me harder!
18:22:25 <dons>    fill cache n = do xs <- mapM (readArray cache) (indices n)
18:22:25 <dons>                      writeArray cache n $ sum (zipWith (*) xs signs)
18:22:33 <dons> you convert to a list just to zip and sum.
18:22:50 <mux> yeah, I'm naughty
18:22:59 <Speck> mux: happen to know what environment variable cabal uses to find packages?
18:23:02 <mux> I wrote most of this euler code very late in the night
18:23:06 <mux> Speck: nope, sorry
18:23:23 <dons> yeah, so that'd be, zipWithU (*) cache signs
18:23:34 <dons> so some good perf improvements there.
18:23:35 <mux> but it ran the problem instantaneously so..
18:24:31 <mux> dons: if you want to optimize more, the zipWith (*) thing could probably be best done by having a list of booleans rather than 1 and -1, and using negate or not instead of doing a multiplication
18:24:31 <ddarius> The unnecessity of optimization is no excuse not to do it!
18:24:59 <dons> mux, yeah, zipping with a UArr Bool, ndp style
18:25:17 * dons encourages people to try euler uvector style
18:25:37 <dolio> Is it ready for use now?
18:25:44 <mux> I promise I'll give it a try next time I need an arary :-)
18:25:46 * dolio installed it a day or two ago.
18:26:44 <dons> well, we don't know if its ready for use, till people try.
18:26:55 <dons> its not ready. but its ok for little euler-ish things
18:27:51 <ddarius> I've considered rewriting a fluid simulator to use it, but rewriting the algorithms would take more effort than I feel like putting out.
18:27:52 <dons> we get moderately different code with IO and ST. interesting.
18:27:58 <mux> dons: I guess that's even better: zipWith ($) xs (cycle [id,id,negate,negate])
18:28:19 <ddarius> mux: Switch your args.
18:28:38 <mux> err, yes
18:28:49 <mux> 3:28am here :)
18:31:09 <Klol> can anyone help me with some basic haskell stuff?
18:32:23 <dons> Klol: definitely. ask away. someone in the channel will help.
18:33:23 <Klol> well im making reversi
18:33:51 <Klol> and im trying to write a function that is given an x,y coordinate, and a board. And it returns the colour of the stone at the given coordinate
18:34:10 <Klol> ive never been strong with lists in haskell
18:34:54 <edwardk> are you encoding the board as a list of lists of values or an array?
18:35:11 <Klol> list of lists
18:35:20 <Klol> board = [[stone]]
18:35:52 <edwardk> should it be [[Stone]] or [[Maybe Stone]] ?
18:36:22 <dolio> dons: Also, should there be a performance improvement for the mutable uvectors over STUArray, or just for the immutable vectors?
18:36:48 <Klol> english man, im a newbie =)
18:37:13 <Klol> im pretty sure the def ive got for board is right
18:37:16 <edwardk> klol: well, in c you can say that something isn't there by dropping in a null. in haskell you usally indicate this by saying 'Maybe'
18:37:36 <edwardk> if your definition for Stone is data Stone = White | Black | Nothing then your definition is fine
18:37:36 <mux> Klol: well, you want a function of the like: foo board x y = board !! x !! y
18:37:40 <mux> but it's quite unsafe
18:37:58 <edwardk> however by saying that you've 'baked failure' into the stone. really a stone is either white or black a 'nothing' isn't a stone, so
18:38:18 <edwardk> saying data Stone = White | Black indicates that if you have a stone it is white or black
18:38:34 <Klol> yeah ive defined stone = White | Black | Nothing =(
18:38:39 <edwardk> and that you can factor out the fact that at certain positions there are no stones by saying that one 'Maybe' is there.
18:38:50 <edwardk> the idea is that data Maybe a = Just a | Nothing
18:39:11 <edwardk> so when you look at a board with [[Maybe Stone]] you can look at a position and have Just White, Just Black or Nothing
18:39:30 <Klol> ok thanks
18:39:43 <edwardk> that way when you call functions that deal with color, they only have to deal with White or Black, and you don't have a spurious Nothing player to deal with ;)
18:40:07 <SamB> well, I've also managed to use Ï• as a variable...
18:40:11 <edwardk> second, i think the key you need is to be able to find the nth item in a list then if you are going to use the list representation
18:40:14 <edwardk> @type (!!)
18:40:16 <lambdabot> forall a. [a] -> Int -> a
18:40:19 <saml> how can I import a file below current directory ?
18:40:38 <edwardk> > ['a','p','p','l','e'] !! 4
18:40:42 <cjb> saml: you mean above :)
18:40:43 <lambdabot>  'e'
18:40:47 <saml> import ../../test/Test.hs
18:41:17 <mauke> import isn't about files
18:41:36 <saml> i want to create a seprate directory for test files
18:41:49 <edwardk> using that a couple of times on your board will get you to a given location. that said you might consider using an Array for the board because reversi has its 8x8'ness sort of baked into the board definition and your definition allows for infinite boards. =)
18:41:52 <saml> then test files can't import actual program modules
18:42:36 <newsham> anyone here up for an agda question?
18:42:52 * edwardk wrote an reversi BBS door about 18 years ago. gah i feel old
18:43:02 <Klol> haha pro
18:43:33 <Klol> well its actually for an assignment, and they have done some of the definitions for us. Im just building the empty functions
18:43:55 <Klol> and ive come from C++ so im shocking at haskell
18:44:12 <edwardk> klol: yeah, haskell takes a bit of a mind-shift
18:47:55 <ddarius> It's absolutly critical to be able to use Ï† as a variable.
18:48:15 <edwardk> ddarius: it makes the hylo stuff that much more intimidating after all =)
18:48:48 <mauke> á²f. f f
18:49:15 <mux> Î»X::*. Î»x:X. x
18:49:54 <mauke> CHEROKEE YO > SMALL LAMDA
18:50:32 <IsoPallo> Aw. Doing assignments in haskell must be somehow wrong...
18:51:02 <dons> yeah, i guess it could be considered cheating.
18:51:10 <dons> not spending so much time debugging segfaults and all
18:51:21 <edwardk> while we're at it, maybe ÎºÎ±Ï„Î± and á½‘Î»Î¿ =)
18:52:15 <mauke> Ï‡ÏÎ¿Î½Î¿ Ï„ÏÎ¹Î³Î³ÎµÏ
18:53:26 <dons> ÎºÎ±ÃÎ±ÃÃÎ¹Î³Î³ÎµÃ
18:53:33 <dons> Â¿Î½Î¿!
18:53:38 <thetallguy> Heaven forbid you might actually learn more than what's on the syllabus.
18:54:23 <edwardk>  á½‘Î»Î¿ Ï† Ïˆ = Ï† Â· map (á½‘Î»Î¿ Ï† Ïˆ) Â· Ïˆ
18:55:26 <saml> :set -i../src yay
18:55:56 <edwardk> or even, á½‘Î»Î¿ Ï† Î· Ïˆ = Ï† Â· Î· Â· map (á½‘Î»Î¿ Ï† Ïˆ) Â· Ïˆ -- now its starting to look like APL
18:56:17 <newsham> âˆ„ï¼¥ã‚‹ï¼«
18:56:20 <saml> OPTIONS_GHC doesn't know -i flag?
19:02:45 <dons> saml: its not a dynamic flag, afai, you can't enable it on a per-module basis
19:02:50 <dons> it should be set in the .cabal file
19:08:06 <saml> oh i see
19:09:27 <saml> is there a way to refactor fail calls to something better like throwError?  if I change the monad to be instance of MonadError, then the final monad i'm building has many MonadError inside the monad stack.
19:10:28 <dons> yeah, just wrap up fails as throwError calls (they might even catch the result)
19:12:05 <saml> dons: so the current monad should be an instance of MonadError
19:12:14 <chessguy> 'evening
19:12:29 <saml> then the final monad will have at least 3 MonadError in it
19:17:26 <dons> saml: sounds like a pretty deeply structured set up. possible code smell alert.
19:17:28 <saml> oh i thought I could call fA :: A () in fC :: C () where C is built up with AT (A transformer)
19:17:51 <saml> i think i'm designing it all wrong
19:21:55 <chessguy> @source
19:21:55 <lambdabot>  not available
19:22:00 <chessguy> @src
19:22:00 <lambdabot> src <id>. Display the implementation of a standard function
19:22:24 <chessguy> @source Data.Tree
19:22:25 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
19:22:55 <Saizan_> saml: maybe you should use typeclasses rather than concrete monads?
19:23:30 <chessguy> @docs
19:23:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:23:45 <daveu1> Check it out, guys -- it's Haskore Live!  http://video.google.com/videoplay?docid=5849699036632847795&hl=en
19:23:46 <lambdabot> Title: Haskore Live! Demo
19:24:10 <daveu1> I got some help in here doing MIDI stuff in Haskell, and this is the final product.
19:24:20 <saml> Saizan_: i have typechecker monad that has Map String Type.  and evaluation monad that has Map String Expr.  now in repl, i want to combine the two so that users can define a new function and both Map String Type and Map String Expr are updated
19:25:02 <mxc> @hoogle rational
19:25:03 <lambdabot> Language.Haskell.TH.PprLib.rational :: Rational -> Doc
19:25:03 <lambdabot> Prelude.Rational :: type Rational
19:25:03 <lambdabot> Data.Ratio.Rational :: type Rational
19:25:30 <mxc> safe to assume that rationals are much much faster than single/double floats?
19:25:40 <saml> daveu1: did you disable downloading the file? many dont' have flash plugin
19:26:04 <daveu1> saml, I did not disable that -- I will checl
19:26:32 <chessguy> @pl e m s = f (r m s)
19:26:32 <lambdabot> e = (f .) . r
19:26:35 <Saizan_> mxc: quite the contrary, actually
19:26:47 <daveu1> saml, downloading is allowed
19:27:00 <mxc> really?
19:27:15 <mxc> well, i guess the abilty to express 1/3 1/10 is worth something
19:28:13 <saml> well maybe google went flash only
19:28:56 <Saizan_> yeah, floats trade precision for speed and ability to express a wide range of values in contant space
19:29:05 <Saizan_> *constant
19:30:42 <daveu1> saml, Google video is such crap
19:30:45 <daveu1> sorry
19:30:52 <daveu1> I know flash sucks, because I usually use Linux.
19:45:45 <mxc> besides the syntactic difference, is there a semantic difference between let and where?
19:46:53 <EvilTerran> no, they desugar to the same thing iirc
19:49:47 <mxc> ok, record question
19:49:51 <mxc> say have some type:
19:50:18 <mxc> data RecTest = A { foo :: String} | b {bar :: String}
19:50:21 <mxc> then I get the functions:
19:50:39 <mxc> foo :: RecTest -> String and bar :: RecTest -> String
19:50:54 <mxc> foo B{..} wld fail
19:51:19 <mxc> is there any warning to catch that in the compiler?
19:52:02 <EvilTerran> don't think so
19:52:11 <EvilTerran> but ndm's Catch should spot it
19:52:13 <EvilTerran> ?where catch
19:52:14 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
19:52:34 <allbery_b> hm, does that mean there's a difference between the implicitly defined accessors and explicit ones?
19:53:10 <EvilTerran> allbery_b, in what way?
19:53:12 <allbery_b> I'd expect ghc to warn about not handling all patters if I wrote it explicitly
19:53:36 <EvilTerran> ah, yes. i don't recall.
19:54:28 <allbery_b> ("non-exhaustive patterns in pattern match")
19:55:24 <EvilTerran> i know the one. anyway, it's good practise to pass your code through Catch occasionally :)
19:58:19 <ddarius> EvilTerran: How often do you pass your code through Catch?
19:58:52 <EvilTerran> ... i don't. that was at least partly facetious
20:03:34 <mxc> no nested modules in Haskell?
20:03:49 <allbery_b> nope
20:04:59 <mxc> so there's no way to have two different record types with the same field name in hte same module?
20:05:14 <mxc> somethinglike:
20:05:22 <EvilTerran> -XRecordPunning, I think
20:05:49 <mxc> module A where data Rec {foo :: String}
20:05:56 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
20:05:57 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
20:06:04 <mxc> and module B where data Rec {foo :: Int}
20:06:36 <allbery_b> Haskell98 doesnt allow it but GHC does as an extension
20:06:46 <EvilTerran> ah, it's -XRecordPuns
20:07:14 <vininim> mmmm I think Haskell' should ditch monad all together and use DDC effects system. *runs and hides*
20:07:15 <allbery_b> note that all such fields must be the same type
20:08:15 <dons> vininim: oh, that'd be a fun bunch of type hackery :)
20:08:31 <dons> lennart already predicted that the implicit IO monad would be the death of haskell.
20:08:48 <vininim> =O
20:09:21 <dons> Those who would give up essential Type Safety, to purchase a little temporary Liberty, deserve neither Liberty nor Type Safety.
20:09:56 * dons thinks we could spin that into a good haskell slogan.
20:10:06 <SamB> what about those who would prove a theorem to give up a little compiler-checked safety?
20:10:39 <dons> SamB: curry-howard sez that's the identity
20:11:06 <SamB> well, okay, so tell me when curry-howard gets typeclasses in a decent language!
20:11:18 <dons> doesn't Isabelle have type classes?
20:11:25 <dons> i thought nipkow wrote a paper about that in the early 90s.
20:11:25 <SamB> does it?
20:11:35 <SamB> does Isabelle have mad unicodes?
20:12:08 <dons> mad unicodez! proof general'll slap you upside the head!
20:12:27 <dons> http://citeseer.ist.psu.edu/wenzel00using.html ?
20:12:28 <lambdabot> Title: Using Axiomatic Type Classes in Isabelle - Wenzel (ResearchIndex)
20:17:16 * SamB is fairly certain that the proof assistant, not proof general, is responsible for allowing the user to use unicode in their proof/programs
20:17:32 <dons> proof general marks up \{LAMBDA} to fancy unicodez
20:17:40 <dons> and facilitates inserting htem
20:17:50 <SamB> oh. you mean I can't just type Î›?
20:18:20 <dons> you type I^ or whatever, and it inserts \CODETHING into the source, and renders it as a proper lambda
20:18:38 <dons> so the source stays as ascii, but your view onto it uses unicode
20:18:56 <SamB> ... is that somehow better than my the normal way?
20:19:43 <dons> well it works for tools that don't support unicode.
20:19:47 <dons> so Maybe yes?
20:19:51 <mxc> @hoogle pack
20:19:52 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
20:19:52 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
20:19:52 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
20:20:08 <SamB> dons: what be these tools?
20:20:19 <SamB> certainly Emacs *was* one
20:20:43 <ddarius> no -> Either no yes
20:21:03 <SamB> ddarius: eh???
20:21:14 * SamB doesn't get the joke
20:22:25 <sjanssen> Left?
20:22:33 <sjanssen> @djinn no -> Either no yes
20:22:34 <lambdabot> f = Left
20:22:47 <SamB> @djinn Maybe yes
20:22:47 <lambdabot> f = Nothing
20:23:04 <SamB> dons: you answer me with types of Nothings!
20:25:33 <dons> hehe. anyone else ever tried implementing type classes with rewrite rules?
20:26:14 <ddarius> No.
20:26:27 <dons> well, it works.
20:27:07 <dons> at least, this is very poor man's type dispatch
20:28:03 <ddarius> dons: You're using the type sensitivity of rewrite rule firing to implement them?
20:28:17 <dons> yeah, to do the static resolution of the method
20:28:23 <dons> its a runtime error if the rule doesn't fire :)
20:28:37 <dons> "eq/Bool"   (=-=) = eq_Bool :: Bool -> Bool -> Bool
20:28:44 <dons> that's your instance Eq Bool
20:29:01 <SamB> what language is that?
20:29:15 <dons> Hacksell
20:29:43 <dons> no truly, that's ghc's term rewriting language.
20:29:52 <SamB> actually, JHC generates rewrite rules internally
20:30:31 <SamB> (but if you try to compile Control.Arrow, the whole thing blows up in your face because it generates ill-typed rules!)
20:32:44 <SamB> dons: these typeclasses are lame SPTCs!
20:33:03 * SamB wonders how you prove termination of Prolog programs
20:34:40 <adiM> @pl   append xs alphabet =  map (\x -> x:xs) alphabet
20:34:40 <lambdabot> append = map . flip (:)
20:34:57 <adiM> @pl   append xs =  map (\x -> x:xs) alphabet
20:34:57 <lambdabot> append = flip map alphabet . flip (:)
20:38:40 <mxc> @hoogle match
20:38:40 <lambdabot> Language.Haskell.TH.match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
20:38:40 <lambdabot> Language.Haskell.TH.Lib.match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
20:38:40 <lambdabot> Language.Haskell.TH.Match :: data Match
20:49:05 <mxc> @hoogle neg
20:49:05 <lambdabot> Prelude.negate :: Num a => a -> a
20:49:05 <lambdabot> Foreign.Marshal.Error.throwIfNeg :: (Ord a, Num a) => (a -> String) -> IO a -> IO a
20:49:05 <lambdabot> Prelude.isNegativeZero :: RealFloat a => a -> Bool
20:50:40 <mxc> @hoogle nan
20:50:41 <lambdabot> Prelude.isNaN :: RealFloat a => a -> Bool
20:51:04 <mxc> @hoogle ln
20:51:05 <lambdabot> Prelude.putStrLn :: String -> IO ()
20:51:05 <lambdabot> Prelude.readLn :: Read a => IO a
20:51:05 <lambdabot> System.IO.hPutStrLn :: Handle -> String -> IO ()
21:03:24 <mxc> :hoogle read
21:03:56 <dons> http://reddit.com/info/6j0mb/comments/ there you go.
21:04:04 <dons> implementing instance resolution with rewrite rules
21:21:48 <sjanssen> dons: that is outrageously evil
21:22:46 * gwern wants to know how far down the rabbit hole goes. are rules all you need for type classes, if you're careful?
21:23:09 <dons> gwern: great idea.
21:23:24 <dons> re. your reddit comment.
21:23:36 <dons> we need a type correct expression that always fails at compile time
21:23:46 <gwern> it is?
21:23:50 <dons> gwern: yeah, i think term rewriting is all you need.
21:24:05 * gwern is used to all my ideas either being unoriginal or dumb. this is new
21:24:05 <dons> so, hmm, what's something that's type correct, but won't compile
21:24:12 <dons> assert (1 == 2) -- if only.
21:24:47 <dons> oh, we can replace it with bottom.
21:24:50 <sjanssen> you could use something that will cause a link error
21:24:54 <dons> compile time bottom, that is.
21:24:56 <dons> a rewrite rule loop
21:25:06 <dons> so either it is resolve statically, or it loops forever
21:25:07 <dons> how's that?
21:25:10 <dons> yeah, that's it.
21:25:18 <gwern> sjanssen: yeah, but then you might as well do things earlier and introduce some sort of syntax error
21:25:32 <dons> gwern: well, the thing is, you can't introduce syntax or type errors
21:25:38 <dons> but you can make the compiler loop
21:25:40 <gwern> link error is so far away from the error site...
21:25:41 <dons> which is good enough for me :)
21:25:44 <sjanssen> gwern: rules must be type and syntactically correct
21:26:19 <dons> {-# RULES
21:26:19 <dons> "Unable to resolve instance resolution"
21:26:19 <dons>     (=-=) == (=-=)
21:26:19 <dons>   #-}
21:26:21 <dons> :)
21:26:23 <gwern> sjanssen: oh, interesting. I had assumed it was TH that forced type and syntax safety
21:26:32 <dons> i *think* that'll work.
21:26:36 <dons> might depend on the rule ordering.
21:27:14 <sjanssen> dons: doesn't GHC just evaluate rules for a certain number of steps?
21:27:19 <dons> nope :)
21:27:29 <sjanssen> I thought I read it wasn't possible to make non-terminating rules
21:27:29 <dons> confluence is for dummies!
21:27:47 <mmorrow> dons: whoa, great idea! coding it up to play with now...
21:28:07 <sjanssen> we mean "great" in a perverse way, right?
21:28:32 <gwern> sjanssen: I dunno. it sounds interesting for a high performance approach
21:28:37 <dons> ha, it works!
21:28:46 <gwern> and it certainly is easier to modify than GHC's current type class mechanisms?
21:28:55 <dons> the compiler won't terminate, if it can't resolve the instance
21:28:59 <dons> otherwise, it will.
21:29:03 <dons> gwern++
21:29:10 <sjanssen> gwern: getting different results whether -O is on is not acceptable
21:29:41 <sjanssen> or whether inlining happens, or specialization, ...
21:29:45 <dons> :)
21:29:51 <mmorrow> sjanssen: isn't perversity great?
21:29:52 <gwern> sjanssen: I was actually thinking of JHC there - I know it also uses some sort of static dispatch mechanism, but I remember it being much more complicaqted than this method
21:30:53 * gwern notes that JHC probably doesn't care that optimization would need to be on to get correct results :)
21:34:22 <SamB_XP> I don't believe that JHC relies solely on the rewrite rules
21:34:31 <SamB_XP> it does, after all, have that typecase thing going too...
21:35:33 <syscrash> i've got a question about currying. for example, there's this function "return :: a -> Parser a; return v = \inp -> [(v, inp)]" which could have been defined "return v inp = [(v, inp)]". are the two completely equivalent in terms of currying?
21:36:15 <sjanssen> syscrash: yep
21:36:28 <syscrash> cool, thanks
21:36:59 <sjanssen> syscrash: they're completely equivalent in every way exact the syntax difference
21:37:43 <syscrash> sounds good
21:37:58 <dons> ok, i just updated the post to restore type safety :)
21:38:24 <dons> gwern: thanks!
21:38:27 <sjanssen> syscrash: erm, I mean 'except' rather than 'exact'
21:38:44 <syscrash> yeah i didn't even catch the error
21:39:37 <gwern> dons: welcome
21:40:12 <gwern> David Gwern?
21:40:23 <Cale> Gwern Branwen?
21:40:31 <dons> oh man
21:40:38 <gwern> just Gwern is fine :)
21:40:40 <dons> and i mean termination, not confluence.
21:40:50 <Cale> ehehe
21:40:50 <dons> thankfully, they don't have to be confluent either.
21:40:57 <gwern> what does confluence mean in that context?
21:41:01 <dons> otherwise the (=-=) = (=-=) wouldn't fly
21:41:12 <dons> term rewriting confluence. separate paths reduce to the same term
21:41:16 <Cale> Can you instead replace (=-=) with something that actually is a type error and get the compiler to halt?
21:41:22 <dons> Cale, nope.
21:41:40 <dons> i can't think of a well-typed term to put in there.
21:41:43 <gwern> 'in the form of the compiler failed to terminate. As all good Haskellers know, this is morally sound: one bottom is as good as another, so a type error is as good as a divergent compiler! And well-typed programs are still not going to go wrong. ' <-- lol. morally sound must be from some haskell paper I've not read yet
21:42:03 <dons> "fast and loose reasoning is morally sound"
21:42:08 <dons> or correct, actually
21:42:42 <gwern> I still find it a little hard to believe you couldn't abuse seq/unsafePerformIO or *something* in the rewrite rules to get an outright error
21:42:49 <SamB_XP> dons: I don't think the IEEE code of ethics would agree about that...
21:42:50 <gwern> but I guess I should read the rewrite rules paper
21:43:09 <dons> gwern: http://citeseer.ist.psu.edu/733155.html
21:43:10 <lambdabot> Title: Fast and Loose Reasoning is Morally Correct - Danielsson, Hughes, Jansson, Gibbo ...
21:43:13 <SamB_XP> gwern: you can't get a type error from rewrite rules
21:43:18 <gwern> thanx
21:43:29 <sjanssen> what about replacing (=-=) with a piece of code that triggers some known GHC bug!?
21:43:33 <SamB_XP> they don't fire unless they appear well-type
21:43:43 <SamB_XP> s/well-type/well-typed/
21:43:54 <dons> sjanssen: that also would be awesomely fun.
21:43:56 <gwern> sjanssen: oh, that's evil! any candidate bugs?
21:44:02 <dons> sjanssen: aren't there some floating point code gen bugs
21:44:10 <dons> you can create values that fall over at code generation time
21:44:16 <dons> since they don't fit on some arch's FPUs
21:44:35 <SamB_XP> ... that's a REALLY strange way to get compile-time failure
21:44:51 * sjanssen still prefers his link error idea
21:44:59 <dons> there's definitely some real values you can create that would cause the native gen to fall over (or gcc)
21:45:09 <sjanssen> unknown symbol: type_error_idiot
21:45:34 <dons> hmm, maybe an ffi call to an unknown function
21:45:38 <dons> that would result in a link error
21:45:52 <sjanssen> exactly
21:45:59 <sjanssen> and it should be called type_error_idiot
21:46:50 <gwern> hm. the paper specifically points out you can loop the compiler
21:47:19 <ddarius> It would be too cumbersome to try to avoid.
21:48:19 <dons> A.o(.text+0x86): In function `sw1_info':
21:48:19 <dons> : undefined reference to `dude_you_fail_at_rules'
21:48:20 <dons> :)
21:48:42 <dons> {-# RULES
21:48:42 <dons> "Unable to resolve instance resolution" (=-=) = unsafeCoerce# you_fail_at_rules #-}
21:48:46 <dons> foreign import ccall unsafe "dude_you_fail_at_rules" you_fail_at_rules :: IO ()
21:49:07 <dons> so we encode the type error as a linker error
21:49:07 <gwern> 'A rule is not required to be in the same module as the function whose definition it extends'; hm. I have some vague idea about multiple mismatched definitions, but it's not gelling
21:49:20 <dons> gwern: its the same as for type class instances
21:49:28 <dons> they are tied to no man.
21:49:57 <gwern> maybe we should just ask the ghc devs to add an error primitive to the edsl
21:50:07 <gwern> but that'd be cheating of course
21:51:34 <ddarius> dons: Couldn't you just give you_fail_at_rules the type forall a. a?
21:52:07 <sjanssen> you_fail_at_rules `seq` undefined should work too
21:52:23 <mmorrow> you can make ghc terminate with a rewrite-rule determined error msg with template-haskell: http://hpaste.org/7554#a0
21:52:24 <sjanssen> though I think the unsafeCoerce# actually improves the code :)
21:52:32 <dons> :)
21:52:46 <dons> mmorrow: tricky!
21:52:51 <mmorrow> heh
21:53:29 <ddarius> Rewriting to TH expressions...  I was wondering if that was doable a bit earlier.
21:53:35 <ddarius> This just gets sicker and sicker.
21:54:19 <dons> mmorrow: ah, but its a runtime failure.
21:54:20 <gwern> mmorrow: thank you for vindicating my intuition! I feel a certain unholy joy at the conjunction of TH, rewrite rules, and multiple modules
21:54:23 <dons> just one with a sensible name.
21:54:32 <gwern> oh, phooey
21:54:35 <mmorrow> yeah
21:54:37 <dons> mmorrow: but can you make it fail at compile time?
21:54:37 * gwern reads more closely
21:54:57 <mmorrow> oh, i confused myself
21:55:01 <mmorrow> i think yeah, hold on
21:55:15 <ddarius> Just drop the brackets
21:55:43 <mmorrow> http://hpaste.org/7554#a1
21:55:46 <mmorrow> yeah
21:56:32 <ddarius> I would think you would be able to just write $(error "foo")
21:56:59 <dons> well, TH lets you hide a type error in the lhs, does it?
21:57:04 <mmorrow> yeah, you can
21:57:26 <dons> hmm, no, TH runs before the rules, so it still has to produce a type correct rule, doesn't it?
21:57:27 <mmorrow> i put it in another module, since at first i confused where i wanted the error to get eval'ed
21:57:47 <dons> staging is hard.
21:58:54 <mmorrow> i think error always slips through since it's result type is of no consequence
21:59:28 <mmorrow> gwern: me too
22:26:08 <newsham> agda question: http://hpaste.org/7555
22:38:35 <mxc> @hoogle trace
22:38:36 <lambdabot> Debug.Trace.trace :: String -> a -> a
22:38:36 <lambdabot> Debug.Trace :: module
22:38:36 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
22:58:16 <mxc> strange, any idea why trace a b would print a but nto b?
22:58:59 <taruti> it is not supposed to print b.
22:59:06 <taruti> @type trace
22:59:09 <lambdabot> Not in scope: `trace'
22:59:38 <taruti> @type Debug.Trace.trace
22:59:40 <lambdabot> forall a. String -> a -> a
23:23:55 <dons> huh, QuickCheck defines,
23:23:57 <dons> two :: Monad m => m a -> m (a, a)
23:23:58 <dons> two m = liftM2 (,) m m
23:23:58 <dons> three :: Monad m => m a -> m (a, a, a)
23:23:58 <dons> three m = liftM3 (,,) m m m
23:24:00 <dons> four :: Monad m => m a -> m (a, a, a, a)
23:24:02 <dons> four m = liftM4 (,,,) m m m m
23:24:05 <dons> cute.
23:29:52 <dons> instance (Arbitrary a, Arbitrary b) => Arbitrary (a -> b) where arbitrary         = promote (`coarbitrary` arbitrary) coarbitrary f gen = arbitrary >>= ((`coarbitrary` gen) . f)
23:29:58 <dons> haskell's fun
23:32:49 <hexpuem> has anyone noticed if the bytestring parsing in parsec3 increases performance a lot?
23:33:28 <dons> i've not heard of any dramatic improvements
23:33:44 <dons> the readp parser for bytestrings is fairly quick, i heard
23:33:47 <dons>  as is Data.Binary
23:34:44 <hexpuem> hmm do the primitives combine the same way as parsecs?
23:35:06 <hexpuem> the parse rules were a real headache to throw together for this logfile haha
23:36:43 <mmorrow> crap, the "Unable to resolve instance resolution" rhs gets evaled even if it's never spliced it seems
23:38:46 <dons> hexpuem: nope, if the log file is simple, you might just use normal take/drop/split/break functions
23:38:53 <dons> or perhaps the pcre-light regex matcher for bytestrings
23:39:14 <hexpuem> nah its in english format with a bunch of annoying context sensitive stuff
23:39:14 <dons> if its a real language, and you need a fast parser, finding out which one is fastest would be useful to us all
23:40:24 <dmwit> dons: Oh, wait, the ByteString version of Parsec uses different combinators than the String version?
23:40:42 <dmwit> (I think that's what hexpuem was asking.)
23:40:50 <olsner> it should just be a matter of importing the bytestring-package in parsec... and of course changing everything else you need to change from String to ByteString (i.e. the parser should not change much)
23:40:50 <hexpuem> was asking about ReadP
23:41:12 <hexpuem> would the performance increase be worth it though?
23:42:25 <olsner> I think I tried parsec-bytestring-ing my C lexer, it gave something like 10% iirc (i.e. no amazing orders-of-magnitude improvements, but definitely better)
23:43:06 <hexpuem> in just the parsing related segments or general file IO too?
23:44:27 <dons> still, bytestrings by hand are not unusually 10x faster
23:44:32 <dons> so we can probably do better.
23:45:16 <encryptio> where does cabal install stuff? (i'm removing ghc in a non-standard directory to install a newer version in a proper place)
23:50:51 <dons> omg, {-# LANGUAGE TypeOperators,ScopedTypeVariables,PatternSignatures,RankNTypes,FlexibleInstances,UndecidableInstances,OverlappingInstances,IncoherentInstances,MultiParamTypeClasses,FlexibleContexts #-}
23:51:05 <dons> i don't know how that slipped past my first reading, http://www.kennknowles.com/blog/2008/05/10/debugging-with-open-recursion-mixins/
23:51:07 <lambdabot> Title: Mathematical Pamphlet » Debugging with Open Recursion Mixins, http://tinyurl.com/62tu6v
23:51:34 <dmwit> Maybe because it's all on one line and disappears off the edge of the browser?
23:51:35 <glguy> dons: on mine that line just drives off the right margin
23:52:12 <dons> instead of filling the page
23:57:26 <maltem> encryptio: cabal installs anywhere you tell it to. Have a look into $PREFIX/lib/ghc-*
