00:00:48 <geezusfreeek> it is the return type for forcing a future. it is one of: Always x (x for all time), Available t x (x is determined at time t), Later (undetermined), or Never (will never be determined)
00:01:21 <geezusfreeek> i have Functor and Applicative defined for it, but definitely no Foldable
00:01:48 <ski_> `Later' ?
00:02:05 <ski_> will that (possibly) be replaced later by some of the other options ?
00:02:21 <geezusfreeek> Later means might be determined at some unknown time in the future
00:02:29 <geezusfreeek> right
00:02:48 <geezusfreeek> the force function is in the IO monad, so it may have different results on the same parameters
00:02:49 <ski_> so you have a reference cell which caches one of these options
00:02:53 <geezusfreeek> right
00:03:17 <ski_> why would it be nondeterministic ?
00:03:23 <ski_> nondeclarative concurrency ?
00:03:44 <geezusfreeek> s/nondeterministic/not referentially transparent/
00:03:52 <ski_> (i.e. racing conditions, etc)
00:04:02 <ski_> can you exemplify ?
00:04:53 <geezusfreeek> i have newFuture :: IO (Future t a, a -> IO ()). the first component is the future, the second is a sink which makes the future determined at the time that it is used
00:05:06 <geezusfreeek> force :: Future t a -> IO (Available t a)
00:05:14 <ski_> oh
00:05:27 <ski_> i was assuming the forcing has blocking semantics
00:05:30 <geezusfreeek> no
00:05:44 <geezusfreeek> it just returns Never or Later where appropriate
00:05:47 <ski_> ok
00:06:20 <geezusfreeek> Never, of course, is only possible if the future is constructed in some way other than newFuture
00:06:23 <ski_> but it's at least not possible to determine more than once, yes ?
00:06:27 <geezusfreeek> but that is unimportant
00:06:53 <geezusfreeek> the idea is that once the future is determined the value will never change again
00:06:59 <ski_> *nod*
00:07:08 <geezusfreeek> though that is not enforced at this moment
00:07:56 <ski_> hm, so you don't have lazy futures as an option, then ?
00:08:16 <geezusfreeek> explain what you mean
00:08:40 <ski_> Lazy :: IO a -> Future t a  -- something like this
00:09:09 <geezusfreeek> oh, that would certainly be possible
00:09:25 <ski_> i.e. when `force'd, would execute the action inside, to determine a value
00:09:29 <geezusfreeek> forkIO . snk
00:09:32 <ski_> though i suppose maybe
00:09:47 <ski_> Lazy :: IO (Available t a) -> Future t a  -- might be better ?
00:09:56 <geezusfreeek> but that's not one of my foreseeable use cases
00:09:59 <ski_> or
00:10:07 <ski_> Lazy :: IO (Future t a) -> Future t a
00:10:17 <ski_> geezusfreeek : ok .. just wondered
00:10:19 <geezusfreeek> these futures will actually be hidden behind a selective export list anyway
00:10:30 <ski_> of course
00:11:39 <geezusfreeek> what i mean is futures will not be exposed anyway. they are just an internal mechanism to achieve what i am doing with this FRP stuff
00:11:45 <ski_> is this inspired by Alice ML (or Oz), btw ?
00:11:56 <geezusfreeek> nope
00:11:59 <ski_> ok
00:13:05 * ski_ ponders
00:13:52 <ski_> so you wanted an `forall t a b. (a -> IO b) -> Future t a -> IO (Future t b)' operation ?
00:14:01 <geezusfreeek> anyway, i just need to use an IO function to change the a value inside an Available t, returning an IO (Available t a), hence (a -> IO b) -> Available t a -> IO (Available t b)
00:14:14 <geezusfreeek> that but on Availables, not Futures
00:14:22 <geezusfreeek> but yeah, essentially
00:14:25 <ski_> ok
00:14:41 <ski_> maybe you can make this a constructor of `Available' ?
00:15:06 <ski_> hm
00:15:29 <geezusfreeek> i could just explicitly pattern match on the Available
00:15:39 <geezusfreeek> i just wanted to be concise
00:15:50 <ski_> (maybe better as a constructor for `Future' ? .. i'm not sure if either would work for whatever you want here)
00:16:04 <ski_> ok
00:16:43 <ski_> Always :: a -> Available t a
00:16:52 <ski_> Available :: t -> a -> Available t a
00:16:59 <ski_> Later :: Available t a
00:17:02 <ski_> Never :: Available t a
00:17:15 <geezusfreeek> right
00:17:28 <geezusfreeek> and like i said, i already have Functor and Applicative for Available t
00:17:36 * ski_ ponders the feasability of `Foldable' and `Traversable' for this
00:17:53 <geezusfreeek> i'd say it's probably feasible, but not very meaningful
00:18:18 <geezusfreeek> since it's not a collection of any sort
00:18:34 <geezusfreeek> ooh, no, not even feasible
00:18:42 <ski_> well, it is, but maybe it is sufficiently more for this to not work
00:19:25 <ski_> actually, now i'm doubting that every `Traversable' should be a `Foldable'
00:20:06 <geezusfreeek> i'm thinking this shouldn't even be Traversable, unless i misunderstand the role of Traversable
00:20:48 <ski_> it seems to me that `traverse' and `sequenceA' would maybe be implementable for `Available t'
00:20:59 <ski_> i suppose the trouble is with `Later'
00:21:11 <ski_> hm
00:21:28 <geezusfreeek> we could probably simply this problem by just considering the Maybe monad
00:21:33 <ski_> or do you think of `Available t a' as a snapshot of a `Future t a' ?
00:21:36 <geezusfreeek> since it is similar in structure
00:22:10 <geezusfreeek> i think the actual meaning of Available is rather unimportant here
00:22:15 <ski_> i.e. if we "mapM" over a `Later', do we expect the action to actually performed if and when the corresponding future gets determined ?
00:22:35 <geezusfreeek> no, this is only at this particular moment in time
00:22:38 <ski_> ok
00:23:00 <geezusfreeek> let's just consider Maybe instead of Available
00:23:02 <ski_> mapM f (Always a) = Always `liftM` f a
00:23:22 <ski_> mapM f (Available t a) = Available t `liftM` f a
00:23:31 <ski_> mapM f Later = Later
00:23:36 <ski_> mapM f Never = Never
00:23:40 <ski_> would that be ok ?
00:23:46 <geezusfreeek> ^ is exactly what i would want
00:24:19 <geezusfreeek> just can't be used for Traversable since it requires Foldable
00:24:19 <ski_> so, this seems like it could possibly be an instance of `Traversable'
00:24:45 <ski_> of course you need only `IO', but that above should work for any applicative/monad
00:24:58 <geezusfreeek> well, and mapM doesn't contribute to a minimally complete definition for Traversable
00:25:26 <geezusfreeek> hmm, sequenceA seems to be a simple one to try
00:25:28 <ski_> s/mapM/traverse/ s/liftM/liftA/ :)
00:25:38 <geezusfreeek> ah i see, oay
00:25:40 <geezusfreeek> *okay
00:25:51 <ski_> (the definition isn't really monadic at all)
00:26:34 <ski_> now, `Foldable' ..
00:26:47 <ski_> fold (Always a) = a
00:26:55 <ski_> fold (Available t a) = a
00:27:02 <geezusfreeek> does this even make sense for Traversable though. there is no "left to right" that i see in this structure
00:27:04 <ski_> fold Later = mempty
00:27:10 <ski_> fold Never = mempty
00:27:23 <geezusfreeek> oh monoid!
00:27:47 <ski_> geezusfreeek : even more reason why there's nothing hindering `Traversable' to make sense !
00:28:02 <ski_> is the above `fold' ok ?
00:28:09 <geezusfreeek> alright, time to make Foldable and Traversal instances a reality i guess!
00:28:13 <geezusfreeek> yeah, looks fine
00:28:19 <ski_> or is it unreasonable to skip the `t' ?
00:28:29 <geezusfreeek> not unreasonable
00:28:35 <ski_> ok, good
00:28:43 <geezusfreeek> hmm
00:28:52 <geezusfreeek> the only thing that is a bit weird…
00:28:57 <ski_> (i don't know your intended domain as well as you, i think ..)
00:29:01 <ski_> yes ?
00:29:22 <geezusfreeek> it doesn't really make much sense to get an actual value back when folding Later
00:29:28 <ski_>   Minimal complete definition: foldMap or foldr.
00:29:41 <ski_> so i guess you'd define one of those, instead
00:30:01 <ski_> geezusfreeek : where ?
00:30:10 <geezusfreeek> "fold Later = mempty"
00:30:46 <geezusfreeek> so say it was over Available t Int… fold Later = 0, which is weird
00:30:56 <geezusfreeek> i'm being to picky now i think
00:31:00 <geezusfreeek> *too
00:31:04 <ski_> just define `foldr' if you're worried about that
00:31:22 <geezusfreeek> heh, i'd get the same behavior for fold from that anyway ;)
00:31:24 <ski_> you don't have to use it for monoid elements
00:31:28 <geezusfreeek> yeah
00:31:40 <ski_> (the default implementation uses the `Endo a' monoid ..)
00:31:47 <ski_> @src Endo
00:31:47 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:32:06 <dolio> newtype Endo a = Endo { appEndo :: a -> a }
00:32:11 <ski_> type Endo a = a -> a -- basically
00:32:15 <ski_> right
00:32:18 <geezusfreeek> i see
00:32:23 <geezusfreeek> instance Monoid (Endo a) where
00:32:23 <geezusfreeek> 	mempty = Endo id
00:32:23 <geezusfreeek> 	Endo f `mappend` Endo g = Endo (f . g)
00:37:28 <geezusfreeek> so it appears that this technically means any Functor is Foldable?
00:38:04 <geezusfreeek> and hence is also Traversable
00:38:12 <dolio> Huh?
00:38:19 <geezusfreeek> yeah, seems weird to me too
00:38:32 <dolio> How are you going to implement foldMap using only fmap?
00:39:20 <geezusfreeek> ah you're right
00:39:26 <geezusfreeek> i am inferring too much from this
00:40:56 <geezusfreeek> oh, Maybe _is_ both Foldable and Traversable! i feel less dirty now
00:41:06 <geezusfreeek> if i had noticed that i would have been fine :P
00:42:25 <dolio> @type (**)
00:42:29 <lambdabot> forall a. (Floating a) => a -> a -> a
00:49:05 <solrize> anyone use hexpat?  the cabal build says it can't find c2hs even though i installed that
01:04:27 <trez> > do x <- [1..5]; return (until (>4) (+1) x) :: [Expr]
01:04:29 <lambdabot>  [1 + 1 + 1 + 1 + 1,2 + 1 + 1 + 1,3 + 1 + 1,4 + 1,5]
01:05:14 <solrize>  > do x <- [1..5]; return (until (>4) (+1) x) :: [Int]
01:05:19 <solrize> > do x <- [1..5]; return (until (>4) (+1) x) :: [Int]
01:05:20 <lambdabot>  [5,5,5,5,5]
01:05:30 <solrize> neat
01:06:21 <dolio> > map (max 5) [1..5]
01:06:23 <lambdabot>  [5,5,5,5,5]
01:06:40 <trez> ;)
01:07:18 <quicksilver> geezusfreeek: all 'container-like' monads are foldable and traversable.
01:07:27 <ski_> > map (const 5) (replicate 5 undefined)
01:07:28 <lambdabot>  [5,5,5,5,5]
01:07:30 <quicksilver> geezusfreeek: Maybe, [], Tree, and anything along those lines.
01:07:56 <geezusfreeek> quicksilver: yeah that was my temporary miscategorization of Functor
01:08:24 <quicksilver> conversely, you can make any Traversable into a Monad if you have something like 'concatMap'
01:08:36 <quicksilver> (which would therefore serve as join)
01:08:54 <geezusfreeek> hmm
01:08:55 <quicksilver> specifically if a Traversable is also a Monoid, that probably lets you do it.
01:08:56 <ski_> quicksilver : what about datastructure which have unordered parts ?
01:08:59 <quicksilver> (Lists are like that)
01:09:10 <quicksilver> ski_: then you have to make a "choice" in the Foldable instance.
01:09:24 <quicksilver> ski_: but if you're happy with the arbitrariness it's OK.
01:09:26 <ski_> which might be effectful
01:09:36 <quicksilver> if you can't consistently make a choice (even consistently arbitrary)
01:09:38 <ski_> s/be/be considered/
01:09:43 <quicksilver> then you get strange behaviours.
01:09:52 <geezusfreeek> well it is bedtime
01:09:56 <geezusfreeek> thanks for the help guys
01:10:08 <quicksilver> for example, Set is unordered.
01:10:15 <ski_> *nod*
01:10:15 <quicksilver> But there is a n obvious way to make the arbitrary choices.
01:10:20 <quicksilver> (using the Ord instance)
01:10:25 <quicksilver> so it's OK, FSOV of OK.
01:10:28 * ski_ ponders graph structures
01:10:48 <quicksilver> if you have something subtle, where multiple representations are supposed to be considered the same
01:11:05 <quicksilver> (like a balanced tree which might end up being misbalanced in different ways depend on insertion order)
01:11:14 <quicksilver> and you dont have a consistent thing like Ord
01:11:24 <quicksilver> then you end up with what is probably a 'broken' instance.
01:11:34 <ski_> (:
01:11:36 <quicksilver> Although, if you promise to only fold over commutative monoids it won't matter.
01:11:45 <ski_> yes
01:13:13 <quicksilver> It's not quite clear what rule you're breaking.
01:13:26 <quicksilver> it's certainly not an explicit law of Foldable.
01:13:38 <quicksilver> I think rather it's the more general law that if you have a non-standard Eq instance
01:13:43 <quicksilver> then *everything* should respect it.
01:13:52 <quicksilver> I.e. the law of abstract data types.
01:14:31 <ski_> m, quotient types
01:15:40 <ski_> (i was just thinking in such cases `Traversable' (at least the monadic part) would not be appropriate for such datatypes)
01:16:31 <ski_> (well, i guess the applicative part, too .. unless you somehow guarantee the applicative to be commutative ..)
01:16:39 <quicksilver> I have spend some time pondering about the traversable instance for sets.
01:16:44 <ski_> (s/guarantee/guarantee or promise/)
01:16:55 <quicksilver> in a way it's not a dissimilar problem for the functor instance for Sets, actually.
01:17:09 <ski_> the `Ord' problem ?
01:17:16 <ski_> is that related to this problem ?
01:17:18 <quicksilver> the obvious functor instances for sets breaks some equations
01:17:35 <ski_> which do you mean ?
01:17:38 <quicksilver> I'm not talking about the haskell language issue of making it into a Functor
01:17:49 <ski_> (right)
01:17:54 <quicksilver> well, for example toList (fmap f s) /= fmap f (toList s)
01:18:13 <quicksilver> so toList is not a 'natural' transformation from Set to List.
01:18:15 <quicksilver> that's a bit odd.
01:18:19 <ski_> well, that's because `toList' is evil and makes an abritrary choice, i'd say :)
01:18:24 <quicksilver> yeah, that's a fair point.
01:18:32 <quicksilver> but lots of other functions on sets do the same, I contend.
01:18:36 <ski_> toList :: Set a -> NonDet [a]
01:18:39 <quicksilver> including the foldable instance we're discussing.
01:18:49 <quicksilver> and the traversable one :)
01:18:53 <quicksilver> so it's all the "same" problem.
01:18:54 <ski_> right
01:19:22 <ski_> so, some kind of `NonDet' monad for encapsulating such choices could maybe be useful, here .. hm
01:19:27 * quicksilver nods
01:19:43 <quicksilver> but what's interesting is that toList is correctly defined over the abstract type.
01:19:45 <ski_> (of course we'd have an `choose :: NonDet a -> IO a)
01:19:50 <quicksilver> so toList isn't *broken* in the obvious way.
01:20:01 <quicksilver> it's broken in a more subtle way.
01:20:24 <ski_> @type Data.Set.toList
01:20:26 <lambdabot> forall a. S.Set a -> [a]
01:20:36 <ski_> the obvious way being ?
01:20:46 <quicksilver> the rule for abstract data types.
01:20:53 <quicksilver> it *is* well defined over different insertion orders
01:21:01 <quicksilver> it doesn't expose the internal structure.
01:22:48 <ski_> well, i'm not sure about that
01:23:16 <ski_> it looks to me it exposes *some* part of internal structure (namely order)
01:23:53 <ski_> @source Data.Set
01:23:53 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
01:24:12 <ski_> bah <http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Set.html#toList>
01:24:12 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Set.html#toList>
01:26:37 <ski_> hm
01:28:42 <ski_> i suppose one could maybe argue that since constructing new sets will guarrantee deterministic ordering, this would be ok
01:29:29 <quicksilver> yes
01:29:37 <quicksilver> what I mean is that given two representations of the same set
01:29:45 <quicksilver> (caused by insertion in different orders)
01:29:48 <quicksilver> toList is still well defined
01:29:52 <quicksilver> that's the most important thing.
01:30:01 <quicksilver> the "bug" is only exposed when you fmap
01:30:08 <quicksilver> (via a non-order preserving 'f')
01:30:09 <ski_> quicksilver : ok, granted, given that ordering determines the result of `toList', it is reasonable to expect `mapM' to use that ordering (or some ordering determined from that one)
01:30:26 <quicksilver> so one way of looking at the "problem" is that Data.Set isn't a Functor.
01:30:28 <quicksilver> it's an Ord-Functor
01:30:32 <ski_> (however, i may not like that design decision ..)
01:30:35 <quicksilver> as such, you should only use Ord-preserving 'f'
01:30:37 <dolio> Clearly toList has type 'Set a -> SortedList a'.
01:30:37 <quicksilver> with fmap.
01:30:39 <ski_> quicksilver : exactly
01:30:44 <quicksilver> you're in a slightly different category.
01:31:02 <quicksilver> where morphisms are order-preserving functions, not functions..
01:31:13 <quicksilver> and all objects have Ord instances.
01:31:28 <ski_> `fmap' should uphold the order
01:31:38 <dolio> Although I guess that still isn't a natural transformation.
01:31:41 <quicksilver> it will, if you only give it order-preserving 'f'.
01:31:57 <quicksilver> (which is the only f you can give it, in that category, because it's the only 'f' that there are)
01:33:10 <ski_> hm, so we would want some way of specifying such variations of `*' ..
01:33:31 <ski_> hm, is this a subcategory ?
01:34:16 <quicksilver> it can be viewed as one.
01:34:25 <quicksilver> its objects are Types in Ord, rather than all types.
01:34:40 <quicksilver> its morphisms are Ord-preserving functions, rather than all functions.
01:34:52 <quicksilver> however, there is another way of viewing it which is not a subcategory.
01:35:05 <quicksilver> that is objects are pairs of (Type,Ord-Dictionary)
01:35:19 <quicksilver> and morphisms preserve the given dictionary
01:35:30 <ski_> i suppose if we map both `CaseChar' and `NormalChar' to `Char' it is not a subcategory
01:36:33 <ski_> (yes, if we just use `(a :: *) | Ord a', it should be injective, given at most one instance)
01:36:55 <ski_> quicksilver : right, that's what i was thinking first
01:37:29 <quicksilver> yes, the global instance assumption makes it a subcat
01:37:36 <quicksilver> that's when you view 'Ord' as a kind
01:37:41 <quicksilver> (a :: Ord)
01:38:02 <ski_> i suppose
01:42:05 <dcoutts> solrize: is c2hs on the path? if it is cabal configure should find it, you can use cabal configure -v to see what it's doing
01:42:05 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
01:42:45 <solrize> yes it's on the path, i haven't been using cabal configure actually, i may have been inaccurate.  i used runhaskell Setup.lhs build.
01:43:03 <dcoutts> solrize: it's like ./configure vs make
01:43:13 <solrize> oh, hmm
01:43:28 <dcoutts> solrize: build just uses the current configuration, it doesn't go looking again for progs etc
01:43:30 <solrize> looks like i don't have cabal installed
01:43:42 <dcoutts> well runhaskell Setup.lhs configure
01:44:04 <solrize> ok
01:44:20 <solrize> ohh, i think i see what happened, just a sec
01:44:44 <dcoutts> gwern: re your patch, if you can separate your whitespace changes from the real change that makes it much easier to see what you're proposing
01:45:01 <solrize> well it gets further now.  what happened was i ran setup.lhs configure, then build, and it complained that i didn't have c2hs (which was true).  so i installed c2hs and ran build again, but didn't realize i also had to run configure again
01:45:16 <solrize> now the build complains that expat.h is missing, i.e. i need to install expat?
01:45:42 <dcoutts> solrize: probably
01:45:52 <solrize> looks like it's actually letting me install that with apt-get
01:45:53 <solrize> sec
01:46:10 <solrize> hmm, same complaint
01:48:37 <solrize> i'm trying to figure out where the expat install put the .h file if it put it anywhere
01:49:33 <quicksilver> did you install the devel package ?
01:49:47 <solrize> devel package?!
01:49:53 <quicksilver> yes.
01:49:55 <solrize> i found libexpat1
01:49:56 <quicksilver> libexpat1-dev
01:49:58 <solrize> what package is that?
01:49:58 <solrize> oh
01:50:01 <solrize> no
01:50:06 <quicksilver> runtime packages do not include the headers
01:50:10 <solrize> ic
01:50:11 <quicksilver> on .deb distributions
01:50:13 <solrize> hmm
01:50:17 <solrize> ok lemme try that then
01:50:20 <solrize> expat-dev?
01:50:24 <quicksilver> libexpat1-dev
01:50:35 <solrize> ok installing
01:50:37 <solrize> thanks
01:51:26 <solrize> worked! thanks!!!!!!
02:31:09 <Beelsebob> @index catMaybes
02:31:09 <lambdabot> Data.Maybe
02:33:21 <Beelsebob> @hoogle Monad m => (a -> b -> c) -> m a -> m b -> m c
02:33:22 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
02:33:22 <lambdabot> Data.Function.flip :: (a -> b -> c) -> b -> a -> c
02:33:22 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
02:34:14 <popcorn> :t \f a b -> do a' <- a ; b' <- b ; return (f a' b')
02:34:17 <lambdabot> forall (t :: * -> *) t1 t2 t3. (Monad t) => (t1 -> t2 -> t3) -> t t1 -> t t2 -> t t3
02:34:55 <popcorn> :t \f a b -> (a >>= (b >>= flip f))
02:34:57 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> (a -> a1) -> m b
02:50:11 <Deewiant> ?ty liftM2
02:50:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:53:44 <mxc> god windows is fcking terrible
02:53:46 <mxc> sorry
02:54:06 <gchrupala> i installed ghc on opensuse but when i try to compile smth the linker cant find gmp
02:54:30 <gchrupala> there is /usr/lib/libgmp.so.3
02:54:48 <gchrupala> but it doesnt seem to be what it wants
02:54:52 <gchrupala> any ideas?
02:55:29 <ilyak> gchrupala: say ldconfig
02:55:43 <pejo> gchrupala, what exact error do you get from the linker?
02:55:48 <ilyak> As root
02:55:56 <quicksilver> you probably need to install the gmp-devel pacakge.
02:56:03 <ilyak> Also, yes
02:56:04 <quicksilver> I dont' know what opensuse calls it.
02:56:44 <mm_freak_work> gchrupala: your GMP may be too old
02:56:44 <gchrupala> /usr/lib/gcc/i586-suse-linux/4.2.1/../../../../i586-suse-linux/bin/ld: cannot find -lgmp
02:56:44 <gchrupala> collect2: ld returned 1 exit status
02:56:53 <gchrupala> /usr/lib/gcc/i586-suse-linux/4.2.1/../../../../i586-suse-linux/bin/ld: cannot find -lgmp
02:56:53 <gchrupala> collect2: ld returned 1 exit status
02:56:58 <gchrupala> Add phone numbers, notes and more for the people in your Contact list.   Learn more
02:56:58 <gchrupala> You are currently using 1646 MB (24%) of your 6698 MB.
02:56:58 <gchrupala> Google Mail view: standard | turn off chat | basic HTML  Learn more
02:56:58 <gchrupala> ©2008 Google - Terms - Google Home
02:57:11 <opqdonut> :D
02:57:18 <gchrupala> sorry that paste got screwed up
02:57:44 <gchrupala> i only have a user account on this machine
02:57:54 <gchrupala> anything i can do to use GHC?
02:58:01 <mm_freak_work> doesn't GHC use the static version of the library?
02:58:07 <mm_freak_work> i.e. /usr/lib/libgmp.a
02:58:53 <gchrupala> i dont have that one...
03:00:32 <ilyak> mm_freak_work: It's in -devel, too
03:01:18 <ilyak> gchrupala: You can
03:01:40 <ilyak> ln -sf /usr/lib/libgmp.so.3 libgmp.so
03:01:48 <ilyak> and do -l ./libgmp.so
03:02:02 <ilyak> or add . to LD_LIBRARY_PATH or whatever the linker use
03:02:28 <gchrupala> ilyak what does the first command do?
03:02:41 <pjd_> :t fmap ap `fmap` ap `fmap` return
03:02:43 <lambdabot> forall a b (m :: * -> *) a1. (Monad m) => (a1 -> a -> b) -> m a1 -> m a -> m b
03:02:49 <ilyak> gchrupala: It creates a symlink to that libaray in your current directory
03:02:56 <ilyak> library*
03:03:08 <gchrupala> ah of course
03:03:51 <ilyak> gchrupala: You've better create ~/lib
03:04:02 <ilyak> And add it to LD_LIBRARY_PATH in ~/.profile
03:04:11 <ilyak> and make symlinks live there
03:05:18 <sieni> LD_LIBRARY_PATH is typically evil
03:05:28 <gchrupala> ilyak that still gives the same error
03:05:29 <sieni> what are you trying to achieve with it?
03:05:43 <quicksilver> sieni: use of libraries as non-root user.
03:05:54 <pejo> ilyak, ld doesn't use LD_LIBRARY_PATH.
03:06:13 <pejo> ilyak, and /usr/lib is among the standard directories ld looks in.
03:06:14 <ilyak> pejo: Maybe that
03:06:21 <gchrupala> yeah that didn't work
03:06:23 <ilyak> pejo: You're missing the point
03:06:44 <ilyak> The linker uses the following search paths to locate required shared libraries:
03:06:49 <ilyak> 5.  For a native linker, the contents of the environment variable "LD_LIBRARY_PATH".
03:07:17 <quicksilver> that's the runtime linker
03:07:23 <quicksilver> not the compiletime linker
03:07:24 <ilyak> The second point is that ld wouldn't try to link with libsomething.so.N
03:07:25 <sieni> quicksilver: i.e. to fix software with broken builds
03:07:26 <pejo> ilyak, that's not the documentation for ld.
03:07:50 <quicksilver> sieni: No. To compile a ghc program on a machine where the admin didn't install gmp-devel
03:07:57 <quicksilver> sieni: if he ws root, he'd just install gmp-devel
03:07:59 <ilyak> pejo: It is, probably the wrong section
03:08:02 <quicksilver> but that's not an oprtion for him.
03:08:37 <gchrupala> ok making that symlink and running ghc --make -L. mouse.hs worked
03:08:48 <ilyak> gchrupala: gratz
03:09:00 <sieni> quicksilver: so the gmp-devel package is broken?
03:09:09 <sieni> quicksilver: shouldn't that be fixed?
03:09:19 <ilyak> sieni: he can't install gmp-devel
03:09:21 <quicksilver> sieni: no the gmp-devel pacakge is most excellent.
03:09:22 <ilyak> Because he is not root
03:09:24 <quicksilver> sieni: it's perfect in every way.
03:09:29 <quicksilver> sieni: it's jsut NOT INSTALLED
03:09:29 <pejo> ilyak, your second point might be right, but as quicksilver points out - LD_LIBRARY_PATH is for the runtime linker.
03:09:30 <quicksilver> :P
03:09:35 <ilyak> quicksilver++
03:09:44 <ilyak> pejo: Yeah, looks like that
03:10:02 <gchrupala> do i now always have to use -L. or is there some env var that i can set to avoid it?
03:10:04 <ilyak> I didn't build anything for quite a while :)
03:10:13 <gchrupala> LD_LIBRARY_PATH didint work
03:10:21 <quicksilver> download and compile user-mode-linux
03:10:30 <quicksilver> creae a file to be a file system
03:10:35 <quicksilver> and run as root inside UML
03:10:39 <quicksilver> (that was a joke, by the way)
03:10:47 <quicksilver> that really would be sledgehammer to crack a nut.
03:10:49 <pejo> gchrupala, putting "-L/wherever/you/are" in LDFLAGS might work.
03:11:08 <gchrupala> pejo ok i ll give it a try
03:11:17 <sieni> quicksilver: what's wrong with tar xvfz gmp-devel.tgz && cd gmp-devel && ./configure --prefix=~/gmp-devel && make && make install
03:11:19 <pejo> gchrupala, but a lot of software is broken in that respect, so it doesn't always work.
03:11:19 <ilyak> gchrupala: ALso try DT_RPATH
03:11:21 <sieni> or something like that?
03:12:04 <gchrupala> gmp-devel is probably an rpm no?
03:12:18 <ilyak> gchrupala: rpm2cpio | cpio -flags
03:12:29 <ilyak> But I wouldn't go that way
03:12:30 <pejo> sieni, the -devel packages of distros are typically header files and some other stuff necessary for compiling stuff yourself.
03:12:43 <sieni> but all software should compile and install cleanly to local place
03:14:15 <quicksilver> sieni: gmp-devel is a distro package.
03:14:22 <quicksilver> sieni: it is not a self-contained piece of software.
03:14:29 <quicksilver> gmp is a self-contained piece of software.
03:14:35 <quicksilver> yes, he could locally install GMP
03:14:41 <quicksilver> but then he'd had to locally install GHC as well
03:14:49 <quicksilver> because the system GHC is compiled against the system GMP
03:14:56 <quicksilver> so that would be a fairly long detour.
03:14:59 <sieni> ok
03:15:01 <mm_freak_work> btw GMP linking…  is there still no way to make use of the GMP functions from haskell?
03:15:06 <quicksilver> mm_freak_work: no.
03:15:21 <mm_freak_work> mh…  that's bad
03:15:44 <sieni> quicksilver: I remember compiling ghc with my 1 GHz Powerbook
03:15:53 <sieni> quicksilver: It _was_ a long detour
03:16:06 <sieni> it must have taken at least 10 hours or something
03:16:26 <quicksilver> yup ;)
03:16:48 <quicksilver> mm_freak_work: sounds like a relatively simple task for a new GHC hacker. Well volunteered.
03:17:19 <mm_freak_work> quicksilver: yeah, maybe i should become one
03:17:32 <mm_freak_work> but i'm not very experienced with haskell yet
03:17:41 <quicksilver> although I would point out that the big picture plan is to move away from GMP, I think.
03:17:46 <mm_freak_work> i'd call myself intermediate
03:18:59 <mm_freak_work> yeah…  and when we've moved away from GMP and finally got a good dynamic linking concept, then someone's gonna write Data.GMP oder Numeric.GMP
03:20:34 <mxc> @hoogle intercalate
03:20:34 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
03:20:34 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
03:20:34 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
03:20:39 <mm_freak_work> i always write an integer square root function or primality tests…  those appear like reinventing the square wheel
03:21:34 <quicksilver> mm_freak_work: well they wouldn't have GMP in the name then would they? :)
03:21:36 <quicksilver> if it wasn't GMP.
03:21:38 <quicksilver> Data.Integer
03:21:41 <quicksilver> I gues.
03:22:23 <mxc> GMP = gnu mathematics package?
03:22:35 <quicksilver> something like that
03:22:43 <quicksilver> I thought it was GNU Multiple Precision
03:23:11 <astrobunny|afk> o.o
03:24:09 <mm_freak_work> GNU multi-precision library
03:24:55 <mm_freak_work> quicksilver: either a GMPInt data-type (Data.GMP) or replacing the builtin Integer functions by GMP versions (Numeric.GMP)
03:25:39 <mm_freak_work> (and of course providing the numerous very useful, but missing functions)
03:27:16 <quicksilver> well only if GMP was better than the builtin Integer ones, I guess.
03:27:39 <mm_freak_work> which is quite likely
03:28:20 <mm_freak_work> i'm not talking about mpz_* (the high-level functions), but mpn_* (the low-level functions without memory management, which work directly on the limbs themselves)
03:31:29 <edwardk> @seen dolio
03:31:29 <lambdabot> dolio is in #haskell-blah and #haskell. I last heard dolio speak 1h 59m 51s ago.
03:31:45 <dolio> Eh?
03:31:57 <edwardk> just catching up =)
03:33:09 <edwardk> dolio: re the start of the prepromorphism stuff: supermap f = x where x = InB . bimap id (x . fmap f) . outB
03:33:36 <dolio> Oh, I actually didn't read that stuff yet.
03:34:23 <edwardk> or i guess more naturally supermap f = InB . bimap id (supermap f . fmap f) . outB    -- and equivalently supermap f = InB . bimap id (fmap f . supermap f) . outB
03:34:31 <edwardk> since supermap f . map f = map f . supermap f
03:35:46 <edwardk> supermap is like 'iterate for functors'
03:36:24 <dolio> Ah.
03:37:06 <edwardk> given say a decorated binary tree functor the root decoration gets their value back, the children of that get f of their value, the children of those get f . f of their value, etc.
03:41:52 <cnwdup> Can I somehow access the values stored being hold by the state monad access by guards? I'd like to use them effectivly in pattern matching if that's possible.
03:42:12 <edwardk> dolio: http://www.google.com/url?sa=t&ct=res&cd=2&url=http%3A%2F%2Fwww.cs.nott.ac.uk%2F~rcb%2FMPC%2FRecurProgConstr.ps.gz&ei=gtgiSP2nMKfqebKT2YcM&usg=AFQjCNG5qrpsbnMqCwMWyL_0sH3LLjzVlA&sig2=DS_Nwh12UuIHAuZrTdsNgQ
03:42:13 <lambdabot> http://tinyurl.com/5cu4j2
03:42:27 <ndm> cnwdup: nope, sadly - it would be awfully handy
03:42:27 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
03:42:44 <ndm> cnwdup: i often do: do s <- get; case .... - then you can just use s
03:42:47 <edwardk> dolio: mentions prepromorphisms
03:42:48 <ndm> @messages
03:42:49 <lambdabot> MarcWeber said 14d 20h 45m 57s ago: which are the option to be used to compile your option lib on ghc-6.8.2?
03:43:44 <dolio> edwardk: Incidentally, I was going to ask you earlier what you thought of 'class (Category c, Category d) => Functor f c d | f c -> d, f d -> c' but I found a reason to hate it in the mean time, I think (although what it is slips my mind at the moment).
03:43:46 <cnwdup> ndm: Yep. That's my solutions so far. I've been considering using some weird functions that query the State and return Bool depending on the option's sate. Though I didn't quite became friends with that.
03:44:16 <ndm> cnwdup: yeah, its one of the things you loose by moving to a state monad
03:44:35 <edwardk> dolio: you mean: http://comonad.com/haskell/categories/src/Control/Category/Functor.hs ? =)
03:44:36 <lambdabot> http://tinyurl.com/673c48
03:44:45 <cnwdup> ndm: Well... it's not possible with a Reader Monad either, isn't it?
03:44:54 <ndm> cnwdup: its not possible with any monad
03:44:54 <dolio> Oh, you'd done that.
03:45:03 <dolio> I was fooling with stuff myself.
03:45:12 <cnwdup> I think I could actually avoid the state completly by passing about four parameters around all the time. But would that be good writing a (small) parser?
03:45:21 <edwardk> if you look in that folder there is a ton of functors and bifunctors defined that way
03:45:38 <cnwdup> I thought it was kind of good style using a State monad for this case.
03:45:48 <edwardk> The _nice_ part is that class (Category k1, Category k2, Category k3) => Bifunctor f k1 k2 k3 | f k1 -> k2 k3, f k2 -> k1 k3, f k3 -> k1 k2    subsumes *** and +++, first and second
03:46:00 <edwardk> which is why i started using first and second in my bifunctor package
03:46:06 <edwardk> just in case i later switched
03:46:09 <ndm> cnwdup: if it really is small, then you can - and you can always bundle the 4 parameters into a record, so they are only one - unless you need them
03:46:23 <dolio> Ah, okay. I was curious if you thought that would rule out anything useful, but you've gotten much further than I have, I guess.
03:46:48 <edwardk> dolio: and that is necessary if you want to allow for Arrow-style use of (,) because (,) is a bifunctor over all arrows
03:46:51 <cnwdup> ndm: I think I sould really consider this. Thanks for your help!
03:46:53 <dolio> The fundeps were key for recovering (.) from map, though. Otherwise it was too ambiguous.
03:46:59 <edwardk> yep
03:47:04 <maltem> cnwdup, you ocassionally here people mutter on #haskell about how fine it would be if we could pattern-match the result of a monadic computation with some extra syntax
03:47:18 <edwardk> you need to be able to support bidirectional type inference on map and tridirectional on bifunctor hence the 3-way above
03:47:31 <edwardk> the problem is that the dual category leads to ambiguous instance heads =(
03:47:52 <dolio> Hmm.
03:47:55 <edwardk> and there are very few 'generic' functors that work over multiple categories
03:48:12 <cnwdup> maltem: Yeah. It would enhance haskell's cleanness imho. And it won't break anything, would it?
03:48:28 <edwardk> dolio: http://comonad.com/haskell/categories/src/Control/Category/Transformer/Reader.hs is the reader comonad written as a 'category transformer'
03:48:28 <ndm> more syntax = more complication
03:48:28 <lambdabot> http://tinyurl.com/5essvu
03:48:38 <dolio> I did notice that one of my (Op (->) r) functor instances was already covered by (~>) a.
03:48:39 <ndm> plus what happens if you do a monad action in a guard, do you reverse it if the guard fails?
03:49:06 <maltem> cnwdup, probably not... Can you come up with a succint syntax though?
03:49:12 <cnwdup> ndm: Just move what you do with case into guards.
03:49:22 <edwardk> dolio: unfortunately you can't build a generic 'cokleisli' style construction for an arbitrary category because of the way you can't move in and out of the newtypes without 'arr/pure'
03:49:39 <ndm> cnwdup: yes, but then the guard can have effects, which is bad from a reasoning point of view
03:49:55 <cnwdup> maltem: I am not familiar enough with haskell for that. But I'd like to use it like this: f (s:ss) | s /= "" && myState = ...
03:50:11 <cnwdup> Where myState is an Option in the State or Reader monad.
03:50:11 <dolio> Oh, I remember what my issue was. I think I was unhappy with functor composition.
03:50:26 <cnwdup> ndm: That's true.
03:50:48 <edwardk> dolio: http://comonad.com/haskell/categories/src/Control/Category/Dual.hs winds up beautiful, but unfortunately the instances that say that instance Bifunctor p k1 k2 k3 => Bifunctor p (Dual k1) (Dual k2) (Dual k3) preclude the construction of any contravariant bifunctors. because they collide on the instance head
03:50:48 <lambdabot> http://tinyurl.com/67tqoc
03:50:54 <maltem> cnwdup, that would be ambiguous - myState would be inferred to be a Bool
03:51:20 <mm_freak_work> dons: from the documentation of hGetContents: "Any I/O errors encountered while a handle is semi-closed are simply discarded."
03:51:24 <cnwdup> maltem: Yeah. It shoudl somehow replace the nasty state <- gets myState if state then ... else ...
03:51:45 <edwardk> and one very nice bifunctor is to say bifunctor (->) (Dual (->)) (->) (->) to define functions as bifunctors, contravariant in their first argument
03:51:57 <MarcWeber> ndm: Sorry. You can forgett about my message. I've mixed you up with John Mecham. He was the author..
03:52:15 <ndm> MarcWeber: ah, fair enough - lambdabot has told me that message about 5 times now :)
03:52:23 <cnwdup> !paste
03:52:32 <MarcWeber> ndm: Is she ill ?
03:52:34 <dmwit> ?where hpaste
03:52:35 <lambdabot> http://hpaste.org/
03:52:38 <cnwdup> thanks
03:52:42 <edwardk> attempts to recover instance heads using the usual tricks fail. normally you'd instance Bifunctor p k1 k2 k3 => Bifunctor (DualB p) (Dual k1) (Dual k2) (Dual k3) (or equivalently say 'Dual' instead of DualB' since the types match
03:52:48 <maltem> cnwdup, if it weren't for the fact that pattern guards already use this very syntax, one might wish for  f x | Just a <- action = ...
03:52:49 <ndm> MarcWeber: she's done it to me before, just a little drug-addled i think
03:53:16 <MarcWeber> ndm: Now I feel sorry for this inconvinience.. I should talk to her
03:53:18 <edwardk> unfortunately for that, even that doesn't work because i can't embed/project into the DualB newtype =(
03:53:18 <dmwit> :t guard
03:53:20 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
03:54:07 <cnwdup> It's actually possible using monadic functions in guards, so we have side-effects anyway. Why not implement a nice syntax for that?
03:54:26 <hexpuem> is there a way to do IO while inside the Maybe monad?
03:54:40 <Dafra> hi, where can I find a tutorial for FFI ?
03:54:43 <dmwit> hexpuem: No.
03:54:54 <edwardk> i can do it in (->) but there is no way to do it in general. so i started using crazy hackish 'witness the newtype' classes like  class Cartesian k => HasReaderW k where readerW :: k (Prod k a e) (ReaderW e k a); unreaderW :: k (ReaderW e k a) (Prod k a e) -- and even those didn't work out for doing general (co)kleisli constructions, etc.
03:54:57 <hexpuem> k thanks haha
03:55:02 <dmwit> hexpuem: But there is a MaybeT, so you could make a MaybeT IO monad that has Maybe-ness and IO-ness.
03:55:13 <dmwit> ?where ffi
03:55:13 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
03:55:18 <dmwit> Dafra: ^^
03:55:22 <hexpuem> yea but i was trying to ahve an IO action inside Map.alter (which is Maybe only)
03:55:33 <maltem> cnwdup, how is it possible to use monadic functions in guards?
03:55:48 <dmwit> hexpuem: No can do.  And that's a feature, not a bug. =)
03:56:22 <cnwdup> maltem: Well, nvm. I think I was mistaken...
03:56:46 <Dafra> dmwit : I have already read it, this is reference. I am looking for examples of simple things.
03:56:55 <cnwdup> I think I'll drop the State Monad completly for my parser.
03:57:02 <Dafra> like calling a C function ...
03:57:58 <dmwit> ?go blog haskell ffi
03:57:59 <lambdabot> http://notes-on-haskell.blogspot.com/2007/02/ffi-in-haskell.html
03:57:59 <lambdabot> Title: Notes on Haskell: FFI in Haskell
03:59:11 <edwardk> dolio: anyways thats one reason why i started working with so many functor/bifunctor combinators thinking i could use those and only define a handful of them per category to make it manageable
03:59:31 <dmwit> Dafra: There's also some stuff on the wiki, though I've never done FFI stuff myself, so I don't know how useful it is.
04:00:17 <dmwit> Also: is the wiki search broken?  Google finds some wiki pages referencing the FFI, but the wiki's own search doesn't.
04:00:20 <Dafra> google told me about this page too. This guy is storng, since he made FFI work in 1 day ...
04:02:22 <dmwit> Well, have you seen the FFI Cookbook?
04:02:29 <dmwit> http://www.haskell.org/haskellwiki/FFI_Introduction
04:02:30 <lambdabot> Title: FFI Introduction - HaskellWiki
04:02:38 <dmwit> http://www.haskell.org/haskellwiki/FFICookBook
04:02:39 <lambdabot> Title: FFI cook book - HaskellWiki
04:03:16 <Dafra> dmwit, your right, google found http://www.haskell.org/haskellwiki/GHC/Using_the_FFI at haskell.org
04:03:17 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
04:03:21 <Dafra> looks better
04:03:57 <dmwit> What are you working on, out of curiosity?
04:04:17 <popcorn> dmwit: maybe the wiki is case sensitive but google isn't?
04:04:41 <Dafra> I need a backtrakable array
04:04:43 <dmwit> popcorn: No results for FFI on the wiki's search, either.
04:04:54 <Dafra> I use IArray but copying takes 75% of the time
04:05:13 <edwardk> dolio: anyways the nice part of that functor definition is it lets you define Cont as an adjunction
04:05:15 <Dafra> and Array.Diff is unable to backtrack
04:05:17 <cnwdup> ndm: Hum, if I drop the state monad, the parser is less modular and I'll have no error handling. On the other side pattern matching makes it a lot easier. What's your recommendation? I'd only like to parse simple config files.
04:05:26 <dmwit> Dafra: Backtrack?
04:05:35 <dolio> Yeah.
04:05:38 <ndm> cnwdup: are you using parsec?
04:05:42 <Dafra> imagine a ches playing program
04:05:45 <dolio> I don't know if that's worth it.
04:05:45 <Dafra> the board is an array
04:05:46 <dmwit> Dafra: Everything in Haskell is immutable, so backtracking shouldn't be a problem with any structure...
04:05:57 <cnwdup> ndm: Nope I'm trying to write it from the scratch in order to learn.
04:06:06 <MyCatVerbs> dmwit: except for the things that aren't, of course, but they're specifically marked. ;)
04:06:09 <Dafra> backtracking is OK, but updating a big array is quite slow :(
04:06:19 <ndm> cnwdup: i'd recommend using parsec the first time, then after you can learn how to write hte combinators
04:06:34 <dmwit> Dafra: How big (and how sparse) is the array?
04:06:34 <ndm> cnwdup: with parsec you don't need guards and you get the state stuff and you get error handling
04:06:45 <MyCatVerbs> dmwit: and every time you try using one of them, you can feel SPJ's ethereal disapproving presence impinging upon your conciousness.
04:07:03 <cnwdup> ndm: Okay.
04:07:04 <dmwit> MyCatVerbs: Yeah... it doesn't help that they all start with "unsafe". =P
04:07:05 <Dafra> the array is spare at the beginning and almot full at the end of the game (for the game of go)
04:07:10 <Dafra> and 361 squares big
04:07:33 <Arnar> hey guys..
04:07:52 <Arnar> can anyone recommend a good textbook on type theory?
04:07:53 <dmwit> Dafra: Well, maybe a Data.Map could work for you.
04:08:10 <dmwit> Dafra: Or IntMap, which is specialized to Int indices.
04:08:26 <edwardk> the main reason i have been considering rolling more of the 'categories' lib stuff over is so that Control.Bifunctor's first and second can work over arbitrary categories and replace the ones in Control.Arrow, and then it allows the inclusion of most of the categories stuff, and the construction of 'correct' biarrows
04:08:33 <Dafra> Mpa is sparse, I guess
04:08:45 <dmwit> Map is good for sparse stuff, yeah.
04:09:07 <MyCatVerbs> dmwit: except for the ones that end with "Ref".
04:09:20 <dmwit> But it should still be pretty good for mere hundreds of entries.
04:09:22 <byorgey> Arnar: depends what you mean by 'type theory', but maybe 'Types and Programming Languages' by Pierce?
04:09:32 <edwardk> if i defined Functor the way we mentioned above it'd have to be Functor' or something coz i don't want to make you preclude Functor, map every time you import any module of this
04:09:33 <Dafra> playing a move meens looking at the 4 neighbours, so I need a dense structure
04:09:37 <Arnar> byorgey: maybe.. looking it up now
04:10:00 <dmwit> Incidentally, I once switched an algorithm from an Array to a regular ol' linked list, and it went way faster, despite being a pretty index-heavy algorithm.
04:10:11 <Dafra> the problem is that all immutable solution are trees, so log(n) access time
04:10:22 <MyCatVerbs> dmwit: STRef, IORef, etc. MVars and Chans and STMVars, though those three sometimes feel more like process-calculus primitives than variables.
04:10:23 <Arnar> byorgey: ah.. it's already on my amazon wishlist.. guess I've looked at it before :)
04:10:24 <Dafra> wow
04:10:30 <byorgey> Arnar: hehe, ok =)
04:10:46 <MyCatVerbs> dmwit: plus Data.Array.Diff. I don't know of anything else offhand.
04:10:58 <Dafra> a list faster than an array for indexing ???
04:11:08 <dmwit> Amazing, isn't it?
04:11:20 <Dafra> quite puzzling
04:11:22 <dmwit> Of course, it was only a few hundred elements long...
04:11:25 <Arnar> byorgey: basically, I'm a graduate student currently in concurrency theory ("eurotheory") wanting to do programming languages. I enjoy LtU for example, but I feel I'm missing some background when it comes to complex type systems
04:11:52 <popcorn> Arnar: Read Lectures on the Curry-Howard Isomorphism if you can find it
04:11:56 <popcorn> that's a really nice book
04:11:57 <pejo> Arnar, process calculus?
04:12:03 <Arnar> pejo: yeah
04:12:11 <byorgey> Arnar: ah, ok, then you should definitely read TaPL.
04:12:26 <dmwit> Dafra: Have you considered that if you really need backtracking, the copying may be a really necessary part of your computation?
04:12:29 <Arnar> excellent.. I'll order it when real world-haskell comes out :)
04:12:35 <pejo> Arnar, same group as Luca Aceto?
04:12:36 <Arnar> shipping to iceland is expensive :)
04:12:38 <byorgey> Arnar: it seems to be the standard graduate text on this sort of stuff (and it's really quite good, IMO)
04:12:42 <Arnar> pejo: he's my supervisor :)
04:12:56 <Arnar> byorgey++, cool, thanks
04:13:21 <Dafra> dmwit, most of the time, a move update only 1 square, so copying 361 is painfull
04:13:30 <dmwit> true
04:14:08 <Dafra> in OCaml, I use a semi-persistent array, the API is purely functional, but the array is updated in place under the hood
04:14:10 <Arnar> pejo: you are in this field as well?
04:14:21 <Arnar> popcorn: thanks.. I'll look it up
04:14:30 <dmwit> Dafra: It might be interesting to build your own checkpointed Array.
04:14:34 <Dafra> when you go back to an older version of the board, it cancels the updates (stored in a list)
04:14:57 <Dafra> dmwit : sure, I want to build it in C, with the FFI :)
04:14:57 <dmwit> Dafra: Something like "data Checkpoint = CheckPoint [(Position, Value)] (Array Position Value)"
04:15:17 <popcorn> is C really a good idea for this?
04:15:22 <dmwit> Oh, why not just build it in Haskell?
04:15:27 <pejo> Arnar, I just read his blog, but my office mate is working on a timed pi calculus.
04:15:58 <Dafra> I need some way to update an array instead of copying it, and I found nothing in Haskell ...
04:15:59 <Arnar> pejo: i see. what's his (or her) name?
04:16:14 <EvilRanter> Dafra, sounds like you want an STArray
04:16:30 <pejo> Arnar, Viktor Leijon, but nothing published on that calculus yet.
04:16:37 <Arnar> pejo: ok..
04:16:52 <pejo> Arnar, what are you working on?
04:16:55 <dmwit> Dafra: You can build a list of updates, then every (say) 10 updates, empty the list and update the array.
04:17:10 <shapr> thetallguy: You called?
04:17:15 <dmwit> Dafra: This would cut your copying time by a factor of 10, perhaps more if you never backtrack more than 10 steps.
04:17:18 <Dafra> I have considered STArray, but I have to write my *whole* program in a monad transformer, and I lose what I love in Haskell.
04:17:37 <popcorn> hi shapr :(
04:17:38 <dmwit> Dafra: Lookup time takes a *little* bit of a hit, but not much -- at most 10 lookups in the list, then an Array lookup.
04:17:41 <popcorn> :) *
04:17:43 <shapr> hi popcorn
04:17:44 <Arnar> pejo: I'm starting my thesis work, it'll be a composability theorem for a logic presented by MohammadReza Mousavi in TU/e
04:17:52 <EvilRanter> Dafra, ok, what about an IOArray?
04:17:59 <Arnar> pejo: I'll be visiting TU/e for a couple of months this fall
04:17:59 <edwardk> shapr: carpool?
04:18:10 <fons> :t (\(+) -> (+))
04:18:13 <lambdabot> forall t. t -> t
04:18:20 <shapr> edwardk: You want to drive? I feel pretty crappy.
04:18:22 <Dafra> IEvilRantr : my whole program in an IO monad ? I prefer C.
04:18:24 <fons> is that legal?
04:18:26 <EvilTerran> that's just like an STArray using the free ST-like behaviour that IO has
04:18:28 <edwardk> shapr: if need be
04:18:29 <popcorn> fons: yes
04:18:42 <edwardk> shapr: going to jump in the shower, will pick you up first then
04:18:46 <popcorn> :t (\(+) x y -> x + y) (*) 7 3
04:18:47 <dmwit> EvilTerran: ...WHAT.
04:18:48 <shapr> edwardk: awright
04:18:48 <lambdabot> forall a. (Num a) => a
04:18:49 <popcorn> > (\(+) x y -> x + y) (*) 7 3
04:18:51 <lambdabot>  21
04:19:03 <Dafra> the problem is that if I enter the IO monad for the first data structure, I cannot get out
04:19:07 <fons> :t (\(+) a b = a + b)
04:19:08 <lambdabot> parse error on input `='
04:19:16 <dmwit> Dafra: If you use the FFI, you'll be in the IO monad.
04:19:30 <Arnar> fons: (+) is just a name, you can use it for anything I guess
04:19:36 <fons> :t (\(+) a b -> a + b)
04:19:38 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
04:19:49 <EvilTerran> dmwit, from "I have to write my *whole* program in a monad transformer" i figured most of his code was in the IO monad already
04:19:57 <Dafra> dwwit, I see, I'll have to unsafePerformIO anyway ...
04:19:58 <dmwit> oh
04:19:59 <fons> Arnar: it's not just a name
04:20:12 <Arnar> no?
04:20:12 <dmwit> fons: Yes it is.
04:20:17 <Dafra>  maybe the IOArray is the best solution then
04:20:21 <EvilTerran> Dafra, there's ways of tidying use of monad transformer stacks with surprisingly little boilerplate
04:20:29 <popcorn> fons: It's just a name
04:20:31 <EvilTerran> > let (+) = "foo" in (+)
04:20:32 <lambdabot>  "foo"
04:20:34 <fons> well yes, but my point is that its semantics depend on how you use it
04:20:42 <dmwit> Well, of course.
04:20:44 <popcorn> fons: the type?
04:20:47 <dmwit> That's true of all names.
04:20:49 <EvilTerran> > let (?) = (++"?") in ("hello" ?)
04:20:49 <fons> it can be a constant or a binary operatoe
04:20:50 <lambdabot>  "hello?"
04:20:58 <Arnar> pejo: you mentioned Luca's blog.. which one?
04:21:03 <popcorn> :t let f x y = _ in f
04:21:05 <lambdabot> Pattern syntax in expression context: _
04:21:12 <popcorn> :t let f x y = "bah" in f
04:21:14 <lambdabot> forall t t1. t -> t1 -> [Char]
04:21:14 <Arnar> fons: any name can be a binary operator
04:21:15 <pejo> Arnar, oh, the process algebra one. Didn't know he had several.
04:21:15 <dmwit> :t let f x y = undefined in f
04:21:17 <lambdabot> forall t t1 a. t -> t1 -> a
04:21:24 <popcorn> :t let f = "bah" in f
04:21:26 <lambdabot> [Char]
04:21:28 <fons> Arnar: true
04:21:46 <pejo> Arnar, what is the composability theorem useful for? (What are you composing?)
04:22:11 <popcorn> fons: When you have a function application like f $ x, it mean that f must have a type that fits into a -> b
04:23:14 <popcorn> so when you have x + y = ((+) $ x) $ y, (+) :: a -> b = a -> (c -> d)
04:23:45 <Arnar> pejo: I'm composing processes in parallel. The theorem is something like this: Let A,B be processes and F a logic formula. Then there is a formula F/B such that A|B satisfies F if and only if A satisfies F/B
04:24:01 <Arnar> pejo: the state space size blows up exponentially with parallel composition
04:24:10 <popcorn> > let (?) = (++"?") in (? "hello")
04:24:11 <lambdabot>  Couldn't match expected type `[Char] -> t'
04:24:14 <Arnar> pejo: this kind of compositionality could help with model checking such processes
04:24:23 <fons> ok ok, it's just strange that one can bind operator names to any type (even constants)
04:24:36 <EvilTerran> popcorn, (x ?) = (?) (x), but (? x) = flip (?) (x)
04:24:45 <Arnar> pejo: the fomrula F/B might be exponentially bigger than F, but we might have more of a chance to "post-process" it to make it easier to check
04:24:47 <popcorn> fons: It seems natural to me :P I always found it odd other languages making special cases about things like that
04:24:54 <popcorn> EvilTerran: that's really neat
04:25:07 <popcorn> I never thought to use sections to get postfix
04:25:08 <Arnar> pejo: the idea being that checking F/B against A is much cheaper than checking F against A|B
04:25:29 <EvilTerran> it's GHC being cheeky, i believe. i don't think it's in the spirit of the report, altho i don't think it explicitly disallows it either
04:25:29 <Arnar> pejo: but equivalent..
04:25:32 <fons> you find natural to du stuff like: {(===) :: Integer; (===) = 3} ?
04:25:41 <fons> do*
04:26:01 <dmwit> no
04:26:31 <dmwit> It is not natural, but then, neither are computers.
04:26:46 <fons> dmwit: well, it seems to be natural for popcorn
04:26:46 <dmwit> I do many things in a typical day that feel unnatural. =)
04:27:04 <popcorn> fons: I never mentioned (===) specifically
04:27:08 <dmwit> fons: I don't think so; just familiar.
04:27:19 <dmwit> fons: You only have to see it once to understand that it can be done. =)
04:27:24 <fons> anyway, it's just my opinion
04:27:31 <popcorn> what is your opinion?
04:27:54 <popcorn> Haskell should restrict operator names to onl values of type a -> b ?
04:28:08 <fons> that the language shoudbn't support binding operator names to types different to binary functions
04:28:13 <fons> popcorn: yep
04:28:16 <pejo> Arnar, I see, I think. It sounds interesting, but difficult.
04:28:19 <popcorn> fons: What do you gain from that?
04:28:41 <dmwit> fons: Oh, that's a terrible idea!
04:28:51 <fons> dmwit: why?
04:28:53 <dmwit> fons: Your trinary function is my binary function!
04:29:20 <fons> popcorn: avoiding unnatural declarations like the example mentioned before
04:29:23 <fons> dmwit: ?
04:29:32 <popcorn> dmwit put it better than I could :)
04:29:41 <MyCatVerbs> Dafra: if you want backtracking and array modification, check out Data.Array.Diff
04:30:20 <dmwit> > let (+) x y z = sum [x, y, z] in (+) 1 2 3 -- an admittedly cooked-up example
04:30:22 <lambdabot>  6
04:30:41 <dmwit> or...
04:30:49 <MyCatVerbs> Dafra: uses mutable updates under the hood to provide a pure interface that is damn fast when working on the current set of values, and not particularly slow for going back in time.
04:31:00 <dmwit> > let x + y = \z -> sum [x, y, z] in 1 + 2 $ 3
04:31:01 <lambdabot>  6
04:31:10 <EvilTerran> > let (?) p t e = if p then t else e in (1 == 2) ? "yes" $ "no"
04:31:11 <lambdabot>  "no"
04:31:46 <dmwit> fons: That is, there are cases where it could make sense to bind a name to a function that takes three (or more) arguments.
04:31:51 <EvilTerran> ?type M.insert
04:31:53 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
04:31:54 <popcorn> @src (.)
04:31:55 <lambdabot> (f . g) x = f (g x)
04:31:55 <lambdabot> -- In lambdabot, it's been generalised to:
04:31:55 <lambdabot> (.) = fmap
04:32:01 <popcorn> :)
04:32:07 <fons> dmwit: yep totally natural, that's why unnecesary parenthesys are included in the name, whose only use is to remove them to denote that we want the name to be a binaty operator
04:32:14 <dmwit> fons: You might argue that it's not so common to want fewer than two arguments for an operator name, but then why bother make that restriction after all?
04:32:15 <EvilTerran> popcorn, ah, yes. good point. :)
04:32:20 <popcorn> fons: look at the . definition
04:32:23 <Deewiant> @src (++)
04:32:24 <lambdabot> []     ++ ys = ys
04:32:24 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:32:24 <lambdabot> -- OR
04:32:24 <lambdabot> xs ++ ys = foldr (:) ys xs
04:32:36 <fons> popcorn: (.) is binary
04:32:38 <Deewiant> no generalization remark there :-/
04:32:44 <popcorn> :t (.)
04:32:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:32:52 <popcorn> @src on
04:32:53 <lambdabot> (*) `on` f = \x y -> f x * f y
04:32:55 <popcorn> :t on
04:32:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:32:59 <EvilTerran> ?type (P..)
04:33:01 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:33:06 <EvilTerran> Prelude.(.) is trinary
04:33:16 <fons> :t (.)
04:33:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:33:22 <popcorn> fons: anyway was your only rationale that it stops evil programmers from writing strange looking code?
04:33:37 <fons> popcorn: uhm, yep mainly
04:33:40 <dmwit> > let (!) x = product [1..x] in (5!) -- another cooked-up example
04:33:42 <lambdabot>  120
04:33:45 <popcorn> (.) :: (c <- b) -> (b <- a) -> (c <- a)
04:33:49 <fons> not necesarilly evil
04:34:04 <EvilTerran> popcorn, O.o
04:34:06 <fons> and it's not like I'm making a formal proposal to H'
04:34:16 <fons> again, it's just my opinion
04:34:24 <EvilTerran> type (:<-) b a = a -> b -- :D
04:34:28 <dmwit> Well, this programmer disagrees with you. =)
04:34:40 <popcorn> fons: sure, just trying to understand
04:34:48 <dmwit> Introducing a restriction like that just makes the language feel... asymmetrical.
04:34:58 <popcorn> in general reducing the expressiveness of a language is usually bad :P
04:35:00 <popcorn> though.
04:35:32 <fons> EvilTerran: (.) is binary
04:35:43 <fons> takes two arguments
04:36:13 <byorgey> nope, look at the type =)
04:36:17 <byorgey> ?type (P..)
04:36:19 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:36:23 <Dafra> MyCatVerbs : Data.Array.Diff updates quickly the current version, but make a full copy if you go back to update a previous version ...
04:36:35 <int-e> > let (.) xs = toUpper (head xs) : tail xs ++ "." in ("hello, world".)
04:36:35 <fons> ups, right
04:36:37 <lambdabot>  "Hello, world."
04:36:47 <fons> sorry
04:36:56 <fons> then I have nothing else to add
04:37:01 <byorgey> fons: it's just that it's normally applied to two function arguments in order to produce another function.
04:37:09 <dmwit> int-e: sneaky =)
04:37:10 <MyCatVerbs> Dafra: ah, wasn't sure how it handled that. Presumably that is a problem for you?
04:37:14 <fons> sure sure
04:37:21 <byorgey> 'number of arguments' is a very slippery concept in a curried system.
04:37:31 <Dafra> what I want is avoid full copy, otherwise, IArray is perfect
04:37:54 <popcorn> f :: a -> (b -> (c -> d))
04:38:03 <popcorn> g :: (a,b,c) -> d
04:38:18 <popcorn> how many arguments do they both take (d might be a function too!)
04:38:43 <dmwit> Okay, I think this argument has said everything interesting that can be said.
04:38:55 <popcorn> there's no real answer is there? It just depends on what's useful for what you're describing
04:39:13 <dmwit> Klingon functions don't take parameters, they take arguments... and they ALWAYS WIN THEM.
04:39:17 <fons> ok, fair enough
04:39:19 <popcorn> haha
04:39:19 <int-e> > undefined undefined undefined undefined
04:39:21 <lambdabot>  Exception: Prelude.undefined
04:39:33 <popcorn> > undefined == undefined
04:39:33 <MyCatVerbs> Dafra: sounds like you probably just want a Map.
04:39:34 <lambdabot>  Exception: Prelude.undefined
04:39:50 <moozilla> hello
04:40:42 <dmwit> Hiya, moozilla!
04:41:10 <moozilla> dmwit, can you help me with something?
04:41:22 <dmwit> Don't ask to ask; just ask.
04:41:23 <dmwit> ;-)
04:41:28 <moozilla> ok :P
04:41:47 <levi13> Hi, I am trying to compile hmp3, but having trouble
04:42:01 <moozilla> I don't really understand what liftIO does
04:42:15 <Dafra> MyCatVerbs : the array is dense, so a map will be o(log(n)) instead of o(1)
04:42:17 <levi13> A few compilation errors. First one is no instance for Binary FilePathP
04:42:37 <Dafra> finger trees are interesting
04:42:47 <dmwit> moozilla: Well, it takes an IO action and lifts it arbitrarily many levels up a monad transformer stack.
04:42:51 <Dafra> since I have a 2D array, I need a finger quadtree
04:42:59 <Dafra> dont know if that exists
04:43:05 <moozilla> dmwit: what I need is someway to unliftIO
04:43:16 <moozilla> is there something like that
04:43:23 <dmwit> moozilla: Most monad transformers come with a run* or exec*.
04:43:27 <dmwit> :t runStateT
04:43:29 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
04:44:07 <moozilla> :t run
04:44:09 <lambdabot> Not in scope: `run'
04:44:10 <dmwit> So, for example, in StateT Int IO (), runStateT :: StateT Int IO () -> Int -> IO ((), Int), which is kind of an unliftIO.
04:44:23 <dmwit> moozilla: You'll have to manually unwind the stack.
04:44:29 <pjd_> moozilla: there is no general way to turn IO a into a, if that's what you're wondering
04:44:51 <moozilla> ok here's the issue specifically
04:44:56 <moozilla> I'm coding an irc bot
04:44:59 <moozilla> it mostly works
04:45:17 <moozilla> but I added a thing to spit out text at certain times according to the clock
04:45:31 <moozilla> and I can get it to print its result to the console
04:45:35 <moozilla> but not to the socket
04:46:33 <moozilla> because the function to write to the socket is of type ReaderT Bot IO
04:46:43 <moozilla> instead of IO
04:46:58 <ikegami--> @seen dcoutts
04:46:58 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 1h 38m 58s ago.
04:47:10 <pjd_> hpaste time
04:47:11 <dcoutts> @yarr!
04:47:12 <lambdabot> Well Ahoy! thar.
04:47:17 <dcoutts> ikegami--: hello
04:47:31 <dmwit> moozilla: Sounds like it's time for a closure over runReaderT!
04:47:44 <matthew_-> are there download stats for packages off hackage?
04:47:45 <ikegami--> dcoutts: hello, i've seen a bug in the iconv-0.4 and how to fix it
04:48:01 <dcoutts> ikegami--: oh yes?
04:48:06 <dmwit> moozilla: Wait.
04:48:18 <dmwit> moozilla: That's exactly what liftIO is for.
04:48:35 <moozilla> really?
04:48:39 <dmwit> moozilla: You have an IO _ action, and it needs to become a ReaderT Bot IO _ action?
04:48:48 <moozilla> dmwit: no, vise versa
04:48:52 <dcoutts> ikegami--: tell me more :-)
04:49:03 <ikegami--> please add 'extra-libraries: iconv' into iconv.cabal for MacOSX'
04:49:11 <moozilla> dmwit: ReaderT Bot IO _ needs to be IO _
04:49:39 <mauke> runReaderT
04:49:42 <dmwit> moozilla: Okay, closure time then.
04:49:47 <matthew_-> @type runReaderT
04:49:49 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
04:50:09 <dcoutts> ikegami--: ah right, yes that's a tricky issue since on some platforms its in libc and others in a separate iconv lib
04:51:01 <ikegami--> hmm.
04:51:36 <moozilla> dmwit: so say function "privmsg" is type "ReaderT Bot IO"; would "runReaderT privmsg" work?
04:51:57 <dmwit> moozilla: You also need to send it a value of type Bot.
04:52:01 <mauke> runReaderT privmsg :: Bot -> IO a
04:52:36 <Beelsebob> @hoogle (RandomGen g,Num a) => g -> a
04:52:37 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
04:52:37 <lambdabot> Data.Generics.Aliases.unGM :: GenericM' m -> Data a => a -> m a
04:52:37 <lambdabot> Control.Monad.Error.Class.throwError :: MonadError e m => e -> m a
04:52:41 <Beelsebob> haha
04:52:45 <Beelsebob> @hoogle random
04:52:46 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
04:52:46 <lambdabot> System.Random :: module
04:52:46 <lambdabot> System.Random.Random :: class Random a
04:53:02 <dmwit> moozilla: Also, there is no type ReaderT Bot IO... but that's just being pedantic. ;-)
04:53:22 <moozilla> ehh I don't think this is what I want to do
04:53:37 <moozilla> I actually don't understand why it wants IO instead of the other type
04:53:45 <ikegami--> dcoutts: anyway, then I can use iconv-0.4, thanks
04:54:06 <ikegami--> iconv is really important for non-English peaple
04:54:38 <ToRA> moozilla: when you create the thing that starts the timer, are you just creating an IO call in a new thread and therefore don't have the Bot to get to the handle?
04:54:59 <moozilla> I think so
04:55:49 <moozilla> :t asks
04:55:53 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
04:56:05 <ToRA> so can't you do something like: foo :: ReaderT IO Bot . foo = do { bot <- ask ; forkIO (runReaderT timerStuff bot) ... }
04:56:22 <ToRA> where foo is already in your IRCBot monad stack?
04:56:29 <moozilla> ToRA: I have no idea :P
04:56:37 <moozilla> I'm not that good at haskell
04:56:47 <ToRA> right
04:58:28 <dmwit> :t forkIO
04:58:30 <lambdabot> Not in scope: `forkIO'
04:58:39 <dmwit> Probably needs a liftIO . forkIO.
04:58:50 <dmwit> But yes, that is essentially what I was suggesting, too.
05:00:25 <ToRA> http://hpaste.org/7470
05:00:36 <ToRA> something like that (though I've made up a lot of function names)
05:00:40 <ikegami--> aha, now I realize that libc has the original builtin libiconv feature.
05:01:47 <dcoutts> ikegami--: right, on solaris and linux it's part of libc, on osx and perhaps the bsds it's a separate lib
05:02:25 <ToRA> moozilla: does the paste help/make sense
05:03:01 <moozilla> ToRA I didn't do anything like that
05:03:30 <ToRA> ok, do you want to paste what you've done?
05:04:08 <cjs> How does one catch a "Prelude.read: no parse" error?
05:04:14 <cjs> I mean exception?
05:04:53 <ikegami--> dcoutts: it is a way to check whether there is glibc>=2.2 or not at configuration
05:04:57 <wjt> cjs: one uses reads not read
05:05:42 <dcoutts> ikegami--: I was thinking of just using extra-libraries: iconv for systems other than solaris and linux
05:06:23 <ikegami--> it is easy and lightweight :)
05:06:39 <cjs> wjt, thanks.
05:07:44 <quicksilver> cjs: don't try to catch errors in pure code
05:07:47 <quicksilver> your soul is in danger :)
05:09:24 <ikegami--> for example, we can use 'if !os(linux)' in cabal
05:09:34 <dcoutts> ikegami--: right
05:09:41 <cjs> quicksilver: actually I was going to catch it somewhere in the impure code.
05:10:12 <cjs> But really, I should probably just straighten out my parsing so I use Maybe or whatever.
05:10:17 <cjs> It's on my list of things to do.
05:10:53 <moozilla> :t ()
05:10:56 <lambdabot> ()
05:11:47 <ikegami--> dcoutts: finally, I notice that you wrote a comment about extra-libraries. Uhh, I missed it.
05:11:50 <quicksilver> cjs: reads lets you use maybe, sort of.
05:11:51 <kpreid> :t [a]
05:11:53 <lambdabot> [Expr]
05:12:11 <popcorn> now that could be confusing..
05:12:14 <kpreid> :( (not that I expected that to work)
05:12:16 <popcorn> :t [a,b]
05:12:18 <lambdabot> [Expr]
05:12:19 <quicksilver> cjs: but I meant 'exceptions arising in pure code'
05:12:24 <quicksilver> cjs: rather than catching in pure code
05:13:12 <moozilla> how come I can't pattern match with ()
05:13:53 <popcorn> you can moozilla
05:14:06 <popcorn> but one thing you should know is that () is the only value (other than _|_) of type ()
05:14:12 <popcorn> so there is only oce pattern
05:14:23 <popcorn> > let x = () in case x of () -> "ok"
05:14:25 <lambdabot>  "ok"
05:14:37 <popcorn> > let x = True in case x of () -> "ok"
05:14:38 <lambdabot>  Couldn't match expected type `Bool' against inferred type `()'
05:14:49 <moozilla> cant you override it?
05:15:12 <moozilla> thats the same error I keep getting
05:15:18 <moozilla> Couldn't match expected type `Bool' against inferred type `()'
05:15:38 <popcorn> moozilla: well the thing is, if x is a boolean, that means it's either True or False, it'll never ever be ()
05:15:41 <popcorn> @src Bool
05:15:41 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:15:48 <cjs> quicksilver: Ah, see. That feels better to me, too. I've got enough other things that could be errors that I just need to have a structure to handle them. It's no big deal.
05:15:53 <moozilla> its actually a [Char]
05:16:04 <moozilla> @src [Char]
05:16:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:16:06 <popcorn> moozilla: maybe you wanna match with "" or [] ?
05:16:09 <popcorn> > "" == []
05:16:11 <lambdabot>  True
05:16:28 <popcorn> > let x = "foo" in case x of "" -> "empty" ; _ -> "nonempty"
05:16:29 <lambdabot>  "nonempty"
05:16:30 <popcorn> > let x = "" in case x of "" -> "empty" ; _ -> "nonempty"
05:16:32 <lambdabot>  "empty"
05:16:45 <popcorn> > null ""
05:16:46 <lambdabot>  True
05:17:14 <quicksilver> cjs: Either or ErrorT is a good way to have "exceptions" in pure code which aren't really exceptions.
05:17:15 <mauke> @let a === b = cast a == Just b
05:17:16 <lambdabot> Defined.
05:17:22 <quicksilver> which you can catch nicely and so on.
05:17:24 <mauke> > "foo" === ()
05:17:25 <lambdabot>  False
05:17:32 <mauke> > "foo" === "foo"
05:17:33 <lambdabot>  True
05:18:57 <popcorn> @let php = exec . "php"
05:18:58 <lambdabot> <local>:4:6: Not in scope: `exec'
05:19:01 <popcorn> humf
05:22:10 <dcoutts> ikegami--: ok, I've updated it in darcs, lemme know if that works for you and I'll update the hackage package too
05:22:38 <moozilla> popcorn: mind looking at this? http://hpaste.org/7472
05:22:47 <ikegami--> dcoutts: thanks for quick your response! I'll try it now
05:22:53 <cjs> quicksilver, Thanks. There seems to be a nice example on the Haddock page.
05:23:08 <popcorn> I looked at it
05:23:17 <moozilla> the error I'm getting is
05:23:25 <moozilla> Couldn't match expected type `[Char]' against inferred type `()'
05:23:32 <moozilla> on the pm x = privmsg x
05:23:57 <mauke> apparently privmsg returns a string
05:24:09 <popcorn> moozilla: well () is not a string
05:24:19 <mauke> oh, that too
05:24:23 <popcorn> moozilla: anyway I think you should just remove pm
05:24:25 <mauke> s/returns/takes/ :-)
05:24:27 <popcorn> remove the where
05:24:31 <moozilla> shouldnt the pm () = return () catch teh ()
05:24:34 <popcorn> no
05:24:36 <mauke> there is no ()
05:24:39 <popcorn> just remove all of that
05:24:44 <moozilla> ok
05:24:48 <popcorn> you could use
05:24:49 <popcorn> do
05:24:49 <popcorn> 	str <- liftIO (saytz "12:00" lastcall)
05:25:01 <popcorn> 	saytz str
05:25:05 <popcorn> and that's it
05:25:31 <popcorn> (that's assuming str is a String, is it?)
05:25:32 <moozilla> you mean privmsg str
05:25:37 <popcorn> no I don't
05:25:38 <moozilla> str is a string
05:25:48 <popcorn> I'm probably confused about your code :P
05:25:51 <moozilla> yes
05:26:12 <moozilla> maybe the problem is in saytz
05:26:16 <moozilla> since it can return ()
05:26:26 <moozilla> but when I change those to return "" it breaks
05:28:27 <ivanm> did anyone read that review of ocaml that dons linked to in -cafe? the site seems to be down atm... in particular, I was wondering where the reviewer was coming from (a Haskell background?)
05:28:38 <mauke> ocaml background
05:29:01 <ivanm> so they had a poor review of ocaml after coming from an ocaml background? :o
05:29:19 <mauke> he said to avoid the "blub" trap, every programmer should keep an open eye for weaknesses in his favorite language and what others do better
05:29:30 <ivanm> ahhh, k
05:29:50 <ivanm> heh... reminds me of the mini arc review linked to on reddit
05:30:00 <mauke> so he lists his "favorite" annoyances with ocaml, hoping to praise it with faint damn :-)
05:30:32 <ivanm> lol
05:30:44 <popcorn> moozilla: one thing that might help is like
05:31:04 <popcorn> moozilla: comment out stuff that doesn't work, and get it so that ghci can load your file
05:31:05 <popcorn> then check
05:31:10 <popcorn> :t whatever
05:31:13 <lambdabot> Not in scope: `whatever'
05:31:14 <mauke> ivanm: link works here
05:31:20 <popcorn> ^ instead of that, you'll get something useful
05:31:46 <popcorn> so you know exactly what types of data functions work on
05:32:22 <cnwdup> I'm trying to import Parsec as mentioned in the user guide but ghci is complaining. Is it import Text.Parsec now and the user guide is outdated?
05:32:26 <mauke> ivanm: I got a 500 error first but reloading fixed it
05:32:33 <quicksilver> cnwdup: which user guide?
05:32:40 <cnwdup> quicksilver: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html that
05:32:53 <quicksilver> yes
05:32:56 <quicksilver> that one is out of date
05:33:01 <quicksilver> although, sadly, it's still the best "guide"
05:33:01 <popcorn> use Text.ParserCombinators.Parsec
05:33:15 <quicksilver> you just have to put up with out-of-date-ness :(
05:33:34 <popcorn> right here http://legacy.cs.uu.nl/daan/parsec.html
05:33:35 <lambdabot> Title: Parsec
05:33:38 <cnwdup> popcorn: Why should I use that?
05:33:43 <popcorn> it says there is an ammendment to it
05:33:52 <cnwdup> Ah, thanks.
05:33:57 <popcorn> cnwdup: if you want to not get errors :P
05:34:00 <ivanm> mauke: yeah, seems to be starting to work here now
05:34:06 <cnwdup> popcorn: Convinced. :D
05:34:44 <cnwdup> Now everything loads perfectly. Even the non-parsec relating errors are gone. Sweet. ^^
05:35:25 <ikegami--> dcoutts: hmm, I met an error: HSiconv-0.4.0.1.o: unknown symbol `_iconv'
05:35:29 <moozilla> popcorn: thanks for the tip, i got it working :D
05:35:53 <ikegami--> I'll report you later if I see what is wrong on MacOSX
05:36:06 <dcoutts> ikegami--: try adding the -fvia-C back in to ghc-options
05:37:25 <popcorn> ok great :)
05:37:34 <ikegami--> dcoutts: OK, I'll try again
05:37:43 <popcorn> moozilla: It's very rare that what I say doesn't just confuse the heck of people :(
05:38:16 <moozilla> popcorn: haskell is a hell of a language
05:38:36 <popcorn> yeah I love it!
05:39:42 <MyCatVerbs> moozilla: and if that isn't enough for you, just spend a few hours putting together a combinator library that will add -even more Hell-! :D
05:40:09 <moozilla> I've recently started coding a lot more in haskell
05:40:20 <moozilla> its waaay easier to do once you understand IO
05:40:30 <moozilla> I still don't quite understand states though
05:40:37 <moozilla> like ReaderT
05:42:00 <ikegami--> dcoutts: wow, you are right. After adding '-fvia-C' to ghc-options, the iconv library works
05:42:20 <dcoutts> ikegami--: sigh, ok thanks
05:42:37 <popcorn> isn't reader t like
05:42:50 <popcorn> foo ctx bar baz = bar ctx foo baz
05:43:00 <popcorn> bar ctx g h = h ctx g g
05:43:05 <ikegami--> dcoutts: you're welcome. thanks for your kindness
05:43:08 <popcorn> I write all these functions with passing 'ctx'
05:43:18 <popcorn> so Reader lets you make the ctx implicit?
05:43:25 <dcoutts> ikegami--: np
05:45:41 <quicksilver> popcorn: yes.
05:49:32 <idnar> MyCatVerbs: or you could write a Malbolge interpreter ;)
05:50:02 <ivanm> And yet the Haskell people implemented in one Simon Peyton Jones long weekend (also known as a couple of man months for mere mortals like you and I). <-- lol
05:52:59 <cjs> dcoutts, ikegami--, I can test the iconv stuff on a *BSD, if you like. Mail me at <cjs@cynic.net> with the details if you want me to.
05:53:08 <cjs> (On NetBSD, in particular.)
05:53:36 <dcoutts> cjs: I think on netbsd iconv is part of libc so no -liconv is needed
05:53:54 <dcoutts> cjay: but if you could confirm that for me that'd be helpful
05:53:59 <dcoutts> oops
05:54:06 <dcoutts> cjs not cjay
05:54:21 <cjay> :)
05:54:22 <dcoutts> cjs: code.haskell.org/iconv
05:55:57 <cjs> Yes, it's in libc. So it should work just like Linux, then.
05:57:39 <Baughn> "Main: caught (and ignoring) too few bytes" <-- Etc. Is there any way of finding out /which/ lambdabot plugin is choking?
06:01:33 <praseodym> what is the type of: fromMaybe -1 (findIndex isDigit s)
06:01:42 <popcorn> :t fromMaybe -1 (findIndex isDigit ?s)
06:01:42 <cjs> dcoutts, http://hpaste.org/7473
06:01:44 <lambdabot> forall a. (Num (a -> Maybe a -> a), ?s::[Char], Num (Maybe Int -> a -> Maybe a -> a)) => a -> Maybe a -> a
06:01:51 <popcorn> a -> Maybe a -> a
06:01:55 <popcorn> give that s is a String
06:02:09 <popcorn> and that you have a Num instances for (a -> Maybe a -> a)
06:02:11 <praseodym> s is a string indeed
06:02:18 <popcorn> which makes no sense at all
06:02:28 <popcorn> so that's really not a valid bit of code
06:02:30 <popcorn> :t fromMaybe
06:02:32 <lambdabot> forall a. a -> Maybe a -> a
06:02:37 <popcorn> :t findIndex
06:02:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
06:02:46 <praseodym> weird enough it works, but I think it's not too nice iether
06:02:56 <popcorn> huh
06:03:04 <popcorn> why is it demanding these num instances then
06:03:13 <popcorn> :t fromMaybe 7 (findIndex isDigit ?s)
06:03:15 <lambdabot> (?s::[Char]) => Int
06:03:17 <popcorn> ok
06:03:21 <popcorn> here's what matters
06:03:26 <popcorn> :t -1
06:03:28 <popcorn> :t (-1)
06:03:29 <lambdabot> forall a. (Num a) => a
06:03:31 <lambdabot> forall a. (Num a) => a
06:03:32 * edwardk waves hello.
06:03:34 <praseodym> (\s -> fromMaybe 1 (findIndex isDigit s)) "t3st"
06:03:38 <popcorn> :t ?f -1
06:03:39 <praseodym> > (\s -> fromMaybe 1 (findIndex isDigit s)) "t3st"
06:03:40 <lambdabot> forall a. (Num a, ?f::a) => a
06:03:42 <lambdabot>  1
06:03:42 <popcorn> :t ?f (-1)
06:03:44 <lambdabot> forall t a. (Num a, ?f::a -> t) => t
06:03:46 <popcorn> Hi edwardk :)
06:03:49 <cjs> dcoutts, But other than the warnings, it's all fine.
06:03:55 <popcorn> see how - in really weird
06:03:58 <cjs> I think. Do I actually need to use it to test it?
06:03:59 <popcorn> that's what confused me
06:04:00 <praseodym> hello edwardk :)
06:04:09 <dcoutts> cjs: ok, so it links, can you test if the examples/hiconv.hs links
06:04:39 <dcoutts> cjs: the archive linking isn't always a guarantee of a user of the lib linking
06:05:26 <praseodym> popcorn: it'd think it were String -> Maybe Int -> Int but that doesn't work
06:05:57 <popcorn> praseodym: like how -1 in (-1) is a number, f -1 is a function, f (-1) is a number
06:06:07 <popcorn> basically this nasty special case :/
06:06:22 <praseodym> :/
06:06:33 <popcorn> yeah there is one thing I don't like
06:06:45 <popcorn> so fromMaybe -1 (findIndex isDigit s)
06:06:47 <popcorn> is actually
06:06:53 <popcorn> (fromMaybe `minus` 1) (findIndex isDigit s)
06:07:11 <popcorn> which is why it wanted num instances for fromMaybe and (find... )
06:07:12 <praseodym> is there any way to write it correctly?
06:07:15 <popcorn> yes
06:07:18 <EvilTerran> actually, it's fromMaybe - (1 $ findIndex isDigit s)
06:07:18 <popcorn> fromMaybe (-1) (findIndex isDigit s)
06:07:32 <popcorn> EvilTerran ohhh damn
06:07:36 <EvilTerran> (the incorrect parse, not the correct version)
06:07:39 <cjs> dcoutts, I can do a quick conversion in ghci.
06:08:08 <EvilTerran> so you'll get weird errors about "no instance for Num (a -> b)" or something
06:08:16 <cjs> And also make it throw an exception when I mistype an encoding name. :-)
06:08:18 <saml> i am writing an interpreter. it does input (can be file) => parse => typecheck => eval. how can I make more useful error message by saving input line and column number?
06:08:19 <dcoutts> cjs: ok, good
06:08:32 <praseodym> seems like everything works when I put parenthesis around, heh
06:09:01 <saml> data Expr = Int FilePath LineNo ColNo | ... ?
06:10:06 <popcorn>                 | If'   { tokenPosition :: SourcePos }
06:10:06 <popcorn>                 | Then' { tokenPosition :: SourcePos }
06:10:06 <popcorn>                 | Else' { tokenPosition :: SourcePos }
06:10:16 <popcorn> that's what I did for the Parsec bit
06:10:33 <popcorn> I'd probably say put LineNo and ColNo into a single type
06:10:49 <praseodym> popcorn, EvilTerran: thanks for the help
06:10:49 <popcorn> (like type a tuple or something)
06:12:33 <saml> hrm this is hard. i might not add this user friendly error message stuff to the interpreter
06:13:32 <popcorn> saml: curious.. what sort of language is it an interpreter for
06:13:34 <praseodym> ?pl \n -> (numEven n == length n)
06:13:35 <lambdabot> liftM2 (==) numEven length
06:13:42 <saml> i think in typechecking monad and eval monad, i might have a stack of function calls that stores SourcePos. then on catchError, i extract the stack and print it
06:14:03 <popcorn> all even . map digitToInt . show
06:14:13 <saml> popcorn: it's a simple functional language. using prefix syntax.. so it looks like lisp
06:14:22 <popcorn> ok
06:14:27 <popcorn> strict or lazy?
06:14:36 <popcorn> @src all
06:14:36 <lambdabot> all p =  and . map p
06:15:07 <saml> popcorn: i can't say for certain because haskell is lazy evaluated... so it's tricky to tell if the interpreter evaluates lazily or eagerly
06:15:21 <popcorn> saml: heehe
06:15:59 <saml> it's to learn haskell anyways. not to make a useful language
06:15:59 <popcorn> > let even = (0==).(`mod`2) ; allEven = all even . map digitToInt . show in (allEven 2456, allEven 2468)
06:16:02 <lambdabot>  (False,True)
06:16:29 <praseodym> popcorn: I'm passing it a [Int]
06:16:59 <popcorn> :t map digitToInt . show :: Int -> [Int]
06:17:01 <lambdabot> Int -> [Int]
06:17:53 <saml> i type in a definition in the repl and it typechecks and registers the function name, body mapping to eval monad. now, when I use the function, it doesn't typecheck because eval monad doesn't have function name, type mapping stored.  should I modify eval monad to have a Map Name Type ?
06:18:18 <popcorn> StateT ? maybe
06:18:22 <saml> typecheck monad has Map Name Type.
06:18:31 <popcorn> saml: Have you seen the monad transformer stack tutorial?
06:18:45 <popcorn> This is very good http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
06:18:48 <saml> i read Step by Step moand transformers
06:18:53 <popcorn> yeah that's the one
06:19:20 <saml> so, i need to write TypeCheckMonadT and use it in EvalMonad
06:19:32 <popcorn> why
06:19:42 <popcorn> oh I see why
06:26:38 <blarz> hi
06:27:15 <popcorn> hi
06:27:22 <pejo> popcorn, hm? Why not link to the version on the homepage of the author instead?
06:27:47 <popcorn> pejo: just clicked the first right thing I saw on google
06:28:07 <saml> @pl map (\x -> M.delete x m) l
06:28:07 <lambdabot> map (flip M.delete m) l
06:34:13 <pastorn> what is this?
06:34:20 <pastorn> @type map (:)
06:34:22 <lambdabot> forall a. [a] -> [[a] -> [a]]
06:34:25 <pastorn> @type map (:) 1
06:34:28 <lambdabot> forall a. (Num [a]) => [[a] -> [a]]
06:35:08 <pastorn> according to (map (:)) the first argument should be a list, but i can just give it 1 as an argument and it doesn't complain
06:35:20 <pastorn> weirdness deluxe
06:35:20 <mauke> only if 1 is a list
06:35:29 <mauke> which it usually isn't
06:35:49 <pastorn> but it accepts it!
06:35:58 <mauke> > map (:) 1
06:35:59 <lambdabot>   add an instance declaration for (Num (f a))
06:36:01 <mauke> no, it doesn't
06:36:18 <pastorn> ok, but it typechecks
06:36:30 <mauke> only if you ignore the Num [a] part
06:36:51 <pastorn> oh, didn't see the [a] in num
06:37:04 <pastorn> instance num [a] where ...
06:37:19 <popcorn> > map (:) [x,y,z]
06:37:21 <lambdabot>  [<[SimpleReflect.Expr] -> [SimpleReflect.Expr]>,<[SimpleReflect.Expr] -> [Si...
06:37:26 <pastorn> this oughta be fun
06:37:43 <saml> subtractMap kv k = kv `Map.difference` Map.fromList (map (\x -> 1) k)     is there a better default value for (\x -> (x, 1)) ?
06:37:55 <mauke> *> map ($ [2,3]) (map (:) 1)
06:37:55 <mauke> [[1,2,3]]
06:38:24 <saml> given a Map k v and [k], I want to delete all entries whose key is in the likst [k]
06:40:27 <mauke> :t foldr M.delete
06:40:29 <lambdabot> Couldn't find qualified module.
06:40:37 <mauke> > foldr M.delete
06:40:37 <lambdabot>  Add a type signature
06:40:42 <mauke> great
06:41:11 <mauke> > foldr M.delete (M.fromList [("a",1),("b",2),("c",3)])
06:41:13 <lambdabot>  <[[Char]] -> Map [Char] Integer>
06:41:20 <mauke> > foldr M.delete (M.fromList [("a",1),("b",2),("c",3)]) ["c", "a"]
06:41:21 <lambdabot>  fromList [("b",2)]
06:42:09 <saml> > foldr d i ["c", "a"] :: Expr
06:42:10 <lambdabot>  Couldn't match expected type `a -> b -> b'
06:43:34 <Saizan> foldl' (flip M.delete) might be better if your list is long
06:45:59 <popcorn> @index IO
06:45:59 <lambdabot> System.IO, Prelude
06:51:07 <cnwdup> I want to parse a line using parsec which may either be a option (foo=bar) or a name (foobar:). I have two functions: parseName :: Parser String and parseOption :: Parser (String, String) and I want to write a function parseLine :: Parser (Either String (String, String). How do I realize that? I have tried sevaral versions using <|> and try but none of them were working.
06:51:38 <popcorn> not working because they didn't type check or what?
06:52:23 <cnwdup> Wait, I'll show my approach which is the closest to what I want. :D
06:52:41 <EvilTerran> try (Left <$> parseName) <|> (Right <$> parseOption) -- this should work
06:53:02 <cnwdup> evilterran: That actually looks great. I didn't know of <$>.
06:53:02 <EvilTerran> (with <$> from Control.Applicative)
06:53:10 <EvilTerran> it's just an infix name for fmap
06:53:38 <EvilTerran> in this case, it serves the same purpose `liftM` would)
06:54:18 <cnwdup> evilterran: Thanks. That is working!
06:54:47 <quicksilver> working++
06:54:57 <popcorn> readLines = (liftIO getLine >>= return) `mplus` readLines
06:55:03 <popcorn> I wrote that
06:55:07 <EvilTerran> hurrah :)
06:55:21 <EvilTerran> cnwdup, now, do you see *why* it works?
06:55:29 <popcorn> but is it possible to use it without -fno-monomorphism thingy :S
06:55:48 <Saizan> popcorn: give it a signature
06:56:18 <Saizan> popcorn: btw, m >>= return === m
06:56:18 <popcorn> aha ok thanks :D
06:56:36 <popcorn> ok cool
06:57:03 <cnwdup> evilterran: Well... The only way I saw was to pass an sequence of action to try which won't work. But as I can avaoid the <- in do { name <- parseName; return $ Left name } with <$> I can pass it to try. Is that correct?
06:57:11 <cnwdup> I'll have to look up what exactly <$> does, though.
06:57:17 <SamB> popcorn: the MR only makes things annoying, not impossible
06:57:45 <EvilTerran> cnwdup, try (do name <- parseName; return (Left name)) would be identical to try (Left <$> parseName)
06:58:05 <EvilTerran> ?type (<$>)
06:58:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:58:15 <EvilTerran> ?type liftM
06:58:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:58:21 <EvilTerran> ?src liftM
06:58:21 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
06:58:34 * SamB wonders how the monad laws would work in a curry-howard system like Agda
06:58:44 <EvilTerran> for Monads, generally fmap = (<$>) = liftA = liftM
06:59:05 <EvilTerran> (altho, if an Applicative instance isn't defined, liftA might not work)
06:59:16 <saml> @pl map (\(k,v) -> (k, f v))
06:59:16 <lambdabot> map (second f)
06:59:19 <ari> > sortBy (compare ++ flip (comparing length)) (words "a b ab cab abra cad abracadabra")
06:59:21 <lambdabot>  ["a","ab","abra","abracadabra","b","cab","cad"]
06:59:56 <EvilTerran> it's easy to define the Applicative instance for any Monad, mind:
07:00:05 <EvilTerran> instance Applicative (GenParser Char st) where pure = return; (<*>) = ap
07:00:34 * ari scratches head
07:01:25 <EvilTerran> if you don't mind using undecidable (safe here) and overlapping (a little dubious here, but probably still okay) instances, "instance Monad f => Applicative f where pure = return; (<*>) = ap" can be quite handy
07:01:44 <cnwdup> evilterran: Thanks. try (do { name <- parseName; return $ Left name }) works, too. I can't figure out anymore what I wrote that didn't work out. |:
07:02:00 <ari> I imported Data.Monoid and defined (++) = mconcat but it's apparently not enough to make that line work in ghci here... what else do I need?
07:02:07 <popcorn> mappend I thought
07:02:08 <EvilTerran> cnwdup, you can leave the {}s off there, but you can't leave the ()s off - might that've been the problem?
07:02:09 <popcorn> :t mappend
07:02:11 <lambdabot> forall a. (Monoid a) => a -> a -> a
07:02:13 <popcorn> :t mconcat
07:02:15 <lambdabot> forall a. (Monoid a) => [a] -> a
07:02:16 <EvilTerran> > id do { return 1 }
07:02:16 <popcorn> :t (++)
07:02:16 <lambdabot>  Parse error at "do" (column 4)
07:02:18 <lambdabot> forall a. [a] -> [a] -> [a]
07:02:23 <mauke> import Prelude hiding (++)
07:02:27 <EvilTerran> > id (do return 1) :: Maybe Int
07:02:28 <popcorn> o_o
07:02:28 <lambdabot>  Just 1
07:02:34 <ari> popcorn++
07:02:34 <popcorn> > Just [1] ++ Just [2]
07:02:35 <cnwdup> evilterran: I think so.
07:02:36 <lambdabot>  Just [1,2]
07:02:39 <popcorn> :t (++)
07:02:42 <lambdabot> forall a. [a] -> [a] -> [a]
07:02:44 <popcorn> Cale: :S
07:02:46 <ari> popcorn: Thanks, that was what I was missing :)
07:02:47 <popcorn> what is going on
07:02:53 <cnwdup> But try (Left <$> parseName) is a lot clearer, I think.
07:03:03 <popcorn> @undef
07:03:04 <lambdabot> Undefined.
07:03:05 <EvilTerran> yeah. that's exactly what <$> is there for
07:03:06 <popcorn> :t (++)
07:03:08 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:03:14 <popcorn> ooh everything is ok :D
07:03:32 <mauke> > sortBy (comparing length ++ compare) (words "a b ab cab abra cad abracadabra")
07:03:33 <lambdabot>  ["a","b","ab","cab","cad","abra","abracadabra"]
07:03:45 <EvilTerran> cnwdup, actually, i find most of my use of Parsec is within the restrictions of Applicative, and i don't even need it to be a Monad
07:04:37 <EvilTerran> for instance, between before after this = before *> this <* after
07:04:39 <cnwdup> evilterran: I think I don't know enough about the Function class. I'll read that up.
07:04:49 <EvilTerran> er, do you mean Functor?
07:04:54 <cnwdup> Heh, yeah.
07:05:14 <EvilTerran> the closest we have to a "Function class" is Arrow, and that's deep magicks
07:05:38 <cnwdup> Nope, meant Functor. Just a typo.
07:05:57 <popcorn> :t (<.>)
07:05:59 <lambdabot> Not in scope: `<.>'
07:06:00 <EvilTerran> yeah, Arrow's completely irrelevant to the discussion, i figured you meant Functor. i'm just being silly.
07:06:14 <cnwdup> (-:
07:06:19 <EvilTerran> popcorn, i often define (<.>) = liftA2 (.)
07:06:27 <EvilTerran> ?type liftA2 (P..)
07:06:28 <popcorn> :t liftA2 (.)
07:06:30 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
07:06:31 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Applicative f1, Functor f) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
07:06:59 <popcorn> @instances Applicative
07:07:00 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
07:07:08 <popcorn> @instances-importing Applicative Applicative
07:07:08 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
07:07:12 <popcorn> @instances-importing Control.Applicative Applicative
07:07:13 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
07:07:58 <Saizan> Const?
07:08:03 <popcorn> > let (<.>) = liftA2 (.) in [Just [1],Nothing,Just [3]] <.> [Just [7,6],Just[5]]
07:08:04 <lambdabot>  Couldn't match expected type `a -> b'
07:08:07 <popcorn> :(
07:08:54 <popcorn> I am taking another attempt at this Typed Logical Variables thing
07:09:39 <saml> > M.fromList [(1, 2), (0, 4)]
07:09:40 <lambdabot>  fromList [(0,4),(1,2)]
07:09:48 <saml> w00t it's sorted by key already!!
07:11:12 <quicksilver> EvilTerran: you only need Monad (as opposed to Applicative) if you want the parsing of the next symbol to depend on the detailed parse of the previous.
07:11:28 <quicksilver> EvilTerran: that kind of extreme context sensitivity is quite unusual in parsing.
07:14:36 <saml> which type instantiates MonadError?
07:14:47 <mauke> @src MonadError
07:14:48 <lambdabot> class (Monad m) => MonadError e m | m -> e where
07:14:48 <lambdabot>     throwError :: e -> m a
07:14:48 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
07:14:50 <saml> i want to see simple implementation of catchError and throwError
07:14:53 <scook0> @instances MonadError
07:14:54 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
07:17:54 <Saizan> throwError e = Left e; catchError m h = case m of Left e -> h e; r -> r
07:19:19 <saml> Saizan: thanks.  http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Error.html#(line93)
07:19:25 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2knezz
07:20:52 <popcorn> @src lift
07:20:52 <lambdabot> Source not found. stty: unknown mode: doofus
07:21:17 <popcorn> I got stuck
07:21:31 <popcorn> say I used like
07:21:55 <saml> @instances MonadTrans
07:21:56 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
07:21:57 <popcorn> BacktrackingT (StatetT Context IO)
07:22:05 <popcorn> BacktrackingT (StatetT Context Identity)
07:22:06 <popcorn> or whatever
07:22:24 <popcorn> I use lift put and lift get to modify the state
07:22:35 <popcorn> but I should like to have something like
07:22:44 <popcorn> BacktrackingT (StatetT Context (StatetT Context' Identity))
07:22:45 <saml> popcorn: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Error.html#(line167)  one example of lift
07:22:46 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2knezz
07:23:11 <popcorn> so the stateful modifications to Context (or Context') get reset on backtracking, but not the other one
07:23:14 <popcorn> is that possible?
07:23:31 <popcorn> and how would you actually do this ?
07:24:03 <popcorn> (I'm hoping that it doesn't involve hacking into BacktrackingT ... but I can't see how else right now)
07:24:12 <Saizan> popcorn: it depends on BacktrackingT mostly, but probably you'd have to put a StateT outside and one inside
07:24:55 <DRMacIver> Hm. I have m points in an N dimensional space (N is large - thousands if not tens of thousands. m is < N, but potentially O(N)). I want a way of efficiently finding the nearest point in this set to some point in this space. What sort of structure should I be looking for? Is an N-dimensional equivalent of a quadtree the way to go?
07:25:18 <Saizan> like StateT Context (BacktrackingT (StateT Context') Identity
07:25:23 <quicksilver> DRMacIver: I'm not expert but I think that's correct.
07:25:52 <quicksilver> DRMacIver: I'm not sure it's an optimisation if m really is O(N).
07:25:53 <popcorn> thanks Saizan I'll try this now
07:26:12 <quicksilver> DRMacIver: I think generalised-quadtrees might be O(dimensions)
07:27:01 <DRMacIver> quicksilver: To query or to build?
07:27:44 <quicksilver> DRMacIver: to query. But I coul dbe wrong.
07:27:53 <quicksilver> DRMacIver: I've never actually written one.
07:28:01 <quicksilver> DRMacIver: although I read about them sometimes :)
07:28:30 <DRMacIver> It sounds wrong.
07:28:47 <DRMacIver> At least, it sounds like a worst-case rather than expected value
07:29:34 <titusg> OT what d'you call the point where two lines cross each other in a graph?
07:29:51 <DRMacIver> It seems like you should be able to do this so you have a decision tree where at each point you cut down the query space by 50%
07:30:25 <DRMacIver> Maybe I'm wrong though
07:30:30 <byorgey> should be O(lg N) to query, where N is the number of points stored
07:30:32 <byorgey> yeah
07:30:58 <popcorn> Is this an error I can't avoid?
07:30:59 <popcorn> Type synonym `Core' should have 2 arguments, but has been given 1
07:31:02 <DRMacIver> Oh, this reminds me of somethign I was wondering about.
07:31:07 <popcorn> for whatever type sym I make
07:31:13 <DRMacIver> Is there an extension that lets me do local type and instance declarations?
07:31:14 <byorgey> at each node you pick a hyperplane which partitions the points evenly.
07:31:39 <byorgey> popcorn: you can't partially apply type synonyms.
07:31:47 <byorgey> popcorn: if you want to do that you'll have to make a newtype instead.
07:31:58 <DRMacIver> I'd like to use something like lightweight static type capabilities to do statically typechecked indices.
07:32:16 <popcorn> oh I see, thanks byorgey I'll tyr
07:32:16 <Saizan> or eta-reduce your synonym declaration if you can
07:32:20 <quicksilver> byorgey: no, I'm talking about the number of dimensions
07:32:25 <popcorn> I can't eta reduce is annoyingly
07:32:34 <quicksilver> byorgey: surely there is an O effect on dimensions
07:32:53 <quicksilver> popcorn: type synonyms considered harmful
07:32:56 <DRMacIver> The thing is, it doesn't have to be a hyperplane.
07:32:59 <quicksilver> popcorn: for that reason and some related ones.
07:33:07 <DRMacIver> But at that point it isn't a quadtree analog I guess
07:33:14 <popcorn> when you do newtype do you it's unboxed right?
07:33:23 <quicksilver> maybe a 2^n-tree is wrong, for your particular case.
07:33:29 <DRMacIver> Yeah
07:33:39 <byorgey> quicksilver: not necessarily, not if you have O(1) access to any one of the components of the points
07:33:42 <DRMacIver> At each stage you should be able to pick a coordinate which partitions the points reasonably well.
07:33:52 <DRMacIver> And then make the decision to split based only on that coordinate
07:33:53 <quicksilver> I've not read any literature about efficient queries in N-dimensions for 'very large N'.
07:33:56 <byorgey> at each node you know which dimension to look at and what value is being split on
07:34:20 <DRMacIver> Hm. But then of course it's not a distance based tree.
07:34:30 <DRMacIver> And I'm no longer sure how to perform "give me the nearest point" queries.
07:34:36 <byorgey> oh, but you want to do nearest-neighbor queries?
07:34:38 <byorgey> hm
07:34:43 <Elly> ugh...calc in 3d and linear algebra finals today =(
07:34:51 <byorgey> then yeah, it's probably O(d * lg N) or something
07:35:00 <DRMacIver> Bugger. :)
07:35:16 <byorgey> Elly: good luck!
07:35:40 <Elly> thanks
07:35:46 <DRMacIver> The problem here is that I have m points in an N-d space. m < N, but of O(N). I want to perform "find me the nearest of these m points" queries efficiently.
07:35:50 <Elly> I haven't really studied for calc in 3d either :X
07:35:56 <byorgey> DRMacIver: I'm curious, what kind of application requires doing nearest-neighbor queries in a ten thousand-dimensional space ??
07:36:02 <DRMacIver> N is at least 1000s, probably 10000.
07:36:25 <quicksilver> byorgey: scheduling junk mail delivery in for pandimensional beings?
07:36:40 <DRMacIver> It's to do with graph clustering.
07:36:41 <byorgey> quicksilver: oh, of course!  I should have known
07:37:01 <popcorn> aww :(
07:37:02 <popcorn> newtype Core a = Core (forall r. SG r (StateT LogicS Identity) a) deriving Monad
07:37:15 <DRMacIver> You model points in the graph by their row in the adjacency matrix, and the distance between them in this N dimensional space gives you a way of measuring "cluster similarity" between them.
07:37:16 <popcorn> GHC is telling me,     Can't make a derived instance of `Monad Core'  (even with cunning newtype deriving:..
07:37:24 <DRMacIver> It's also useful for applying k-means clustering, etc.
07:37:35 <popcorn> the representation type has wrong kind?
07:38:03 <byorgey> popcorn: newtype Foo a = Foo (Blah a) deriving Bar  only works if  Blah is an instance of Bar
07:38:20 <popcorn> I thought it was a monad though
07:38:35 <byorgey> DRMacIver: interesting.
07:38:37 <Saizan> SG is a monad transformer?
07:38:55 <popcorn> Saizan: yes, I didn't write it though, it's from LogicT
07:39:25 <Saizan> popcorn: the problem is the forall r. maybe
07:39:25 <DRMacIver> byorgey: Yeah. But possibly not very useful.
07:39:26 <quicksilver> SG is a monad transformer
07:39:31 <quicksilver> but forall r . SG r is not
07:39:31 <popcorn> ok so
07:39:32 <popcorn> newtype Core r a = Core (SG r (StateT LogicS IO) a) deriving (Monad, MonadPlus, MonadState, MonadIO)
07:39:32 <popcorn> type LogicM a = forall r. StateT LogicS (Core r) a
07:39:43 <popcorn> I did that
07:39:46 <quicksilver> or, not so that haskell can see :)
07:39:52 <popcorn> but now it just says Can't make a derived instance of `MonadState (Core r)' (even with cunning newtype deriving: `MonadState' does not have arity 1)
07:39:58 <DRMacIver> byorgey: There seems to be too much noise for small numbers of clusters, and when you have large numbers of clusters you get the above problem in trying to calculate what they are.
07:40:17 <yuriyp> DRMacIver: it's funny since I am right now trying to use Haskell for very similar problem
07:40:18 <eugman> Is there an easy way to split a length of text based on the occurance of a specific line?
07:40:20 <popcorn> So I'm kind of stuck I think :|
07:40:28 <saml> data (Error e) => Foo a = Foo ..  | Bar e     where e is an instance of class Error.  can I do this?
07:40:37 <DRMacIver> It's a shame, because on graphs of a few hundred nodes the results are pretty promising
07:40:38 <sclv_> maybe it should be MonadState LogicS ?
07:40:45 <byorgey> popcorn: you need to say   deriving (..., MonadState s, ...)  where s is the type of the state
07:41:00 <DRMacIver> yuriyp: I'm actually just thinking the problem through in Haskell (I tend to use Haskell as a tool for thinking when I'm stuck on hard problems). The real code is in Scala.
07:41:20 <byorgey> eugman: there isn't a library function for that, no.  but it's not too hard to write yourself.
07:41:37 <yuriyp> DRMacIver: probably the same thing will happen here. Only C++ instead of Scala
07:41:44 <byorgey> saml: that probably doesn't do what you want.
07:41:57 <DRMacIver> I should dig up my spatial datastructures book.
07:42:06 <DRMacIver> I have a massive great big tome of this stuff, but I've used it all of twice.
07:42:11 <eugman> byorgey, I'm just not sure how to go about it. I'm trying to make some very simple xml parsing for a file I have.
07:42:13 <DRMacIver> So naturally it's not at work. :)
07:42:31 <byorgey> saml: I would suggest saying  data Foo a e = Foo ...  | Bar e, and then in functions that use Foo you can say   somefunc :: (Error e) => Foo a e -> ....
07:43:31 <byorgey> saml: otherwise you could make an existential type by saying  data Foo a = forall e. (Error e) => ...  but that may not be what you want either, plus it can be complicated.
07:43:43 <DRMacIver> Oh, fuck. No wonder this is so slow. There's another O(N) factor creeping in on my linear scan.
07:43:51 <saml> byorgey: oh thank you
07:44:09 <DRMacIver> As I'm not taking advantage of the fact that these vectors are sparse, so calculating the distance between them is O(N).
07:44:14 <DRMacIver> O(N^3) algorithms ftl.
07:45:53 <byorgey> eugman: splitOn s [] = ([],[]); splitOn s (l:ls) | s == l = ([],ls)  | otherwise = (l:xs,ys) where (xs,ys) = splitOn s ls  -- eugman, something like this?
07:46:05 <popcorn> but when you go > :i LogicM
07:46:17 <popcorn> oh nevermind, sorry I'm just confused
07:46:35 <quicksilver> the deriving things have to be the right kind
07:46:43 <quicksilver> so you do have to apply them, possibly.
07:46:55 <popcorn> well I have this at the moment:
07:46:56 <popcorn> newtype Core r a = Core (SG r IO a) deriving (Monad, MonadPlus, MonadIO)
07:46:56 <popcorn> type LogicM a = forall r. StateT LogicS (Core r) a
07:47:04 <popcorn> which kindchecks ok
07:47:17 * SamB thinks gmails basic html should be more ... well, basic
07:47:20 <popcorn> so I just need to write runLogicM
07:47:39 <SamB> hrmm, on second thought it *is* more basic
07:48:00 <popcorn> I wish I could write _ in types
07:48:05 <SamB> they just did a good job of maintaining the brand
07:48:18 <SamB> popcorn: try using agda?
07:48:39 <popcorn> in haskell I mean :P
07:49:44 <SamB> yeah, I wish I could do that too sometimes
07:51:35 <mm_freak_work> wouldn't that be ambiguous?
07:51:49 <popcorn> mm_freak_work: exactly
07:53:58 <Saizan> incomplete i'd say, with the hope the typechecker can fill it for you
08:01:08 <popcorn> t's very hard
08:02:02 <popcorn> Do you think I have to define my own LogicT instance :.
08:02:12 <popcorn> to get state that backtracks
08:03:57 <jamii__> Does anyone have any experience with CAL?
08:06:19 <flazz> on leopard, does the binary release of ghc require macports' readline? or is there a way to have it specify the stock readline?
08:08:24 <quicksilver> flazz: various different releases have done different things, I think.
08:08:59 <flazz> the release i used is this one http://www.haskell.org/ghc/download_ghc_682.html#macosxintel
08:08:59 <lambdabot> Title: GHC: Download version 6.8.2
08:10:25 <quicksilver> looks like it wants a macports readline.
08:10:32 <quicksilver> flazz: not sure what you mean by 'stock readline' btw.
08:10:43 <saml> http://hpaste.org/7477   how can I write my custom state,error monad?
08:10:53 <flazz> the one that is stock with leopard, not macports'
08:11:09 <quicksilver> leopard doesn't come with readline, afaik.
08:11:18 <quicksilver> it comes with a broken not-readline
08:11:22 <quicksilver> that's why we don't want to use it.
08:11:28 <saml> running the function, test, causes Non-exhaustive patterns
08:11:49 <flazz> ok, good enough answer, thanks
08:12:29 <quicksilver> saml: well you commented out the Fail case, didn't you?
08:12:39 <quicksilver> saml: persumably that's the non-exhaustive pattern.
08:12:47 <quicksilver> (in your definition of >>=)
08:12:51 <saml> quicksilver: yes. when I put it in.. it complains that (,,) Subst Int is not instnace of MonadError
08:12:53 <Saizan> but he can't write the Fail case there..
08:13:15 <Saizan> data TI a = TI { runTI :: Subst -> Int -> (Subst, Int, a) }
08:13:22 <quicksilver> saml: yes, because you're already inside a TI
08:13:37 <quicksilver> saml: you can't fail inside a TI, as it were.
08:13:38 <Saizan> saml: you've to use a type like this: data TI a = TI { runTI :: Subst -> Int -> Either String (Subst, Int, a) }
08:13:54 <quicksilver> I suspect you have just proved that this type isn't a monad :)
08:14:01 <quicksilver> by your inability to write >>= for it.
08:14:28 <Arnar> quicksilver: that's not a "proof" :)
08:14:30 <byorgey> data TI a = TI { ... } | Fail String
08:14:58 <popcorn> What's a proof?
08:15:00 <saml> so far, I'm just using fail "blah blah"  in TI monad. I was wondering if I can catch the fail message. without modifying all fail "blah blah"
08:15:14 <quicksilver> Arnar: no, but it does hint at the problem.
08:15:29 <Saizan> ?unmtl ErrorT String (State Int) ()
08:15:29 <lambdabot> Int -> (Either String (), Int)
08:15:33 <Arnar> quicksilver, popcorn: a valid proof would for example be to assume that there was a well-defined >>= and show thaty by using it you'd get some contradiction
08:15:54 <Arnar> quicksilver: of course.. I was being pedantic / trolling :)
08:15:57 <ToRA> popcorn: isn't backtracking state monad a StateT [] ?
08:16:34 <saml> hrm i need to play around with transformers then
08:18:48 <saml> would it be possible to make TIT (transformer of TI moand)  even when TI is a custom state monad and I wrap TI with ErrorT ?
08:19:11 <Saizan> newtype TI a = TI { runTI :: ErrorT String (State (Subst,Int) a } deriving (MonadError String, etc...)
08:19:11 <saml> i'll try it and see
08:26:55 <popcorn> looks like it ToRA!
08:27:28 <popcorn> I tried to check like
08:27:29 <popcorn> type Foo a = StateT Integer [] a
08:27:29 <popcorn> runFoo :: Foo a -> [(a,Integer)]
08:27:29 <popcorn> runFoo foo = runStateT foo 0
08:27:29 <popcorn> iotaN n = if n < 0 then mzero else return n `mplus` iotaN (n-1)
08:27:29 <popcorn> iotaP n = if n < 0 then mzero else (do put n ; return n) `mplus` iotaP (n-1)
08:28:20 <popcorn> oh infact I think I made a mistake
08:28:32 <popcorn> *Main> runFoo (do a <- iotaP 1 ; b <- ((iotaN 2 `mplus` mzero) `mplus` iotaN 2) ; return (a,b))
08:28:33 <popcorn> [((1,2),1),((1,1),1),((1,0),1),((1,2),1),((1,1),1),((1,0),1),((0,2),0),((0,1),0),((0,0),0),((0,2),0),((0,1),0),((0,0),0)]
08:28:33 <popcorn> *Main> runFoo (do a <- iotaP 1 ; b <- ((iotaP 2 `mplus` mzero) `mplus` iotaN 2) ; return (a,b))
08:28:33 <popcorn> [((1,2),2),((1,1),1),((1,0),0),((1,2),1),((1,1),1),((1,0),1),((0,2),2),((0,1),1),((0,0),0),((0,2),0),((0,1),0),((0,0),0)]
08:28:53 <popcorn> since te mzero make iotaP backtrack, but the results are different, since state wasn't reset :(
08:29:39 <EvilTerran> popcorn, i think you want NondetT State rather than StateT []
08:29:50 <EvilTerran> (or whatever the non-broken version of ListT is)
08:30:05 <popcorn> oh well I was trying with LogicT
08:30:13 <EvilTerran> that's one of 'em, yeah
08:30:20 <popcorn> but when I had like LogicT (StateT ...
08:30:26 <popcorn> the state wasn't reset in that either
08:30:52 <popcorn> so maybe I need to be explicit about this, rather than getting a monad to backtrack it.. not sure
08:30:53 * EvilTerran thinks... this might be an annoying quirk of MTL
08:31:07 <EvilTerran> maybe try MonadLib instead?
08:31:08 <popcorn> yeah I saw that callCC/State bug
08:31:19 <popcorn> ok I'll give it a go
08:31:19 <Saizan> wait, StateT s [] a == s -> [(a,s)] so each branch has its own state, that gets discared on mzero
08:31:27 <ToRA> > runStateT (lift [1,2,3,4] >>= \n -> guard (even n) >> modify (n+) >> return (n `div` 2)) 0
08:31:29 <lambdabot>  [(1,2),(2,4)]
08:32:01 <popcorn> > runStateT (lift [1,2,3,4] >>= \n -> modify (n+) >> guard (even n) >> return (n `div` 2)) 0 -- equivalent iff state is reset
08:32:02 <lambdabot>  [(1,2),(2,4)]
08:32:11 <popcorn> oh :O
08:32:52 <ToRA> :)
08:33:15 <popcorn> > runStateT (lift [1,2,3,4] >>= \n -> modify (n+) >> return (n `div` 2)) 0
08:33:16 <lambdabot>  [(0,1),(1,2),(1,3),(2,4)]
08:33:39 <quicksilver> popcorn: state wouldn't backtrack in LogicT (StateT ...
08:33:52 <ToRA> but it would in StateT LogicT ...
08:33:52 <quicksilver> popcorn: it would backtrack in StateT (LogicT ...
08:33:57 <quicksilver> popcorn: is that what you meant?
08:33:59 <popcorn> quicksilver: so I tried StateT (LogicT .. but I can't run the thing :P
08:34:05 <popcorn> so I got stuck both ways
08:35:32 <popcorn> ToRA: actually it seems like that example didn't prove anything :|
08:35:55 <ToRA> yeah it did.  it shows that there is one state per backtrack path
08:35:59 <ToRA> which is what you wanted no?
08:36:17 <popcorn> > runStateT (lift [1,2,3,4] >>= \n -> modify (n+) >> return (n `div` 2)) 0
08:36:18 <lambdabot>  [(0,1),(1,2),(1,3),(2,4)]
08:36:21 <popcorn> is equivalent to
08:36:27 <popcorn> oh wait sorry not that
08:36:37 <popcorn> > runStateT (lift [1,2,3,4] >>= \n -> modify (n+) >> guard (even n) >> return (n `div` 2)) 0
08:36:39 <lambdabot>  [(1,2),(2,4)]
08:36:53 <popcorn> > filter (even.fst) (runStateT (lift [1,2,3,4] >>= \n -> modify (n+) >> return (n `div` 2)) 0)
08:36:55 <lambdabot>  [(0,1),(2,4)]
08:37:22 <popcorn> > filter (even.(*2).fst) (runStateT (lift [1,2,3,4] >>= \n -> modify (n+) >> return (n `div` 2)) 0)
08:37:23 <lambdabot>  [(0,1),(1,2),(1,3),(2,4)]
08:37:27 <dons> http://reddit.com/info/6inbz/comments/ nice
08:37:27 <lambdabot> dons: You have 9 new messages. '/msg lambdabot @messages' to read them.
08:37:30 <popcorn> oh I don't know
08:37:41 <popcorn> It's all very confusing :)
08:37:56 <popcorn> to me
08:38:14 <Saizan> popcorn: no, in the latter you're checking if the state is even
08:38:35 <ToRA> s/n `div` 2/() and it may be a bit clearer as to what's going on wrt states
08:38:44 <Saizan> popcorn: while in ToRA's example is the result of lift [1,2,3,4] that must be even
08:40:12 <popcorn> what I don't get is that if
08:40:13 <popcorn> > runStateT (do x <- lift [1..5] ; modify (+x) ; guard (even x) ; return x) 0
08:40:15 <lambdabot>  [(2,2),(4,4)]
08:40:24 <popcorn> has the same results in it as
08:40:25 <popcorn> > runStateT (do x <- lift [1..5] ; modify (+x) ; return x) 0
08:40:26 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5)]
08:40:41 <popcorn> they both have the same state values corresponding to the actual values
08:40:51 <popcorn> then state is never reset on backtracking, surely?
08:41:36 <Saizan> popcorn: it's like you're working in multiple branchable worlds
08:41:54 <Saizan> and with mzero you can decide to abandon a branch
08:42:14 <popcorn> Saizan: that's exactly what I want, but I can't observe that from these results
08:42:18 <Saizan> but what happens in a branch can't affect what happened in other branches
08:43:14 <Saizan> why not? guard only decides if the branch must continue or not
08:43:25 <Saizan> why should it alter the state?
08:43:53 <popcorn> so like
08:44:02 <popcorn> > runStateT (do x <- lift [1..5] ; guard (even x) ; modify (+x) ; return x) 0
08:44:03 <lambdabot>  [(2,2),(4,4)]
08:44:16 <popcorn> since the guard is before the modify in there, how come that the results are the same?
08:44:33 <quicksilver> well the guarded tracks are completely cut
08:44:37 <popcorn> ohh I understand it now
08:44:38 <quicksilver> the unguarded ones continue.
08:44:39 <ToRA> > runStateT (do x <- lift [1..5] ; guard (even x) ; put "hello" ; return x) "not hello"
08:44:41 <lambdabot>  [(2,"hello"),(4,"hello")]
08:46:12 <Saizan> popcorn: when you decide to branch the computation (e.g. with lift [1..5]) each branch receives a copy of the state, and from then those states are indipendent
08:46:59 <Wraithan> I am just learning this language, coming from an imperial language background, I was wondering though, in the YAHT they say in functional programming you use recursion instead of loops, the problem I see with that (from my imperial language background) is wouldn't you eventually run out of space in the stack? That is what typically happens if you have recursion that goes on for too long
08:47:48 <geezusfreeek> Wraithan: haskell's runtime model isn't the same as C's
08:48:11 <geezusfreeek> Wraithan: in haskell, the garbage collector can run behind you and clean up things as your recurse
08:48:32 <Wraithan> well if you haven't returned from a function how can it clean things up?
08:48:36 <ToRA> popcorn: this may make things clearer, here you can see the states for all the computations that were cut too
08:48:37 <Saizan> and even in imperative languages tail call optimization makes tail recursion use constant stack space
08:48:39 <ToRA> > flip runStateT "initialState" . runErrorT $ (do x <- lift (lift [1..5]) ; guard (even x) ; put "hello" ; return x) :: [(Either String Int, String)]
08:48:40 <lambdabot>  [(Left "","initialState"),(Right 2,"hello"),(Left "","initialState"),(Right ...
08:48:50 <Wraithan> your call stack will still get rather long
08:49:06 <geezusfreeek> Wraithan: there is no stack in that sense
08:49:10 <mauke> Wraithan: not for tail calls
08:49:31 <mauke> also, lazy evaluation transposes the execution table
08:49:41 * ToRA grumbles at needing to use errorT as Either String, as opposed to Either () or the lack of a MaybeT in the std lib
08:49:42 <Wraithan> hmm
08:49:48 <popcorn> ok!
08:49:48 <popcorn> > let flip = lift [1,0] in runStateT (do [x,y,z] <- sequence [flip,do modify (+1) ; e <- flip ; if e == 1 then return 1 else mzero,flip] ; return (x,y,z)) 0
08:49:50 <lambdabot>  [((1,1,1),1),((1,1,0),1),((0,1,1),1),((0,1,0),1)]
08:50:23 <popcorn> when the second coin is flipped, if it was a 0, then the modify (+1) is reest
08:50:27 <geezusfreeek> Wraithan: usually in haskell you have very small tail recursive functions that you can use as pretty reliable, memory-efficient combinators
08:50:33 <Saizan> Wraithan: the short answer is "with decent-written code the compiler takes care of it for you"
08:50:47 <Wraithan> ok, just hard for me to wrap my head around, I didn't got too into recursion with C++... the few times if there was a bug I would run out of space and crash the application
08:51:07 <geezusfreeek> Wraithan: basically with recursion you shouldn't worry about it unless it becomes a problem
08:51:47 <Wraithan> Thank you geezusfreeek, Saizan, and mauke
08:52:02 <popcorn> Wraithan: do you know any imperative language with goto?
08:52:07 <Wraithan> I don't quiet understand but I will keep reading and hopefully it will become more clear
08:52:13 <Wraithan> popcorn: yeah
08:52:19 <popcorn> Wraithan: which?
08:52:40 <ToRA> popcorn: look at your output results, you've culled all those that dn't have a 1 in the second flip, and thus kept all the states at +1.
08:52:52 <Wraithan> popcorn: most of the goto use I have used was in a scripting language for everquest
08:52:53 <popcorn> ToRA: yeah, I see it now, this is great
08:53:09 <Wraithan> C/C++ also allows for it but it is frowned upon
08:53:51 <Wraithan> In the afformentioned scripting language, there was no loop model, you had to use ifs with gotos
08:54:45 <popcorn> Wraithan: I'll just use C syntax then, if you write int factorial(int n) { if(n == 0) { return 1; } else { return n * factorial(n - 1); } }, It'll (just pretend the following is true) use 20 stack frames when you call it factorial(20)
08:56:27 <mm_freak_work> are there any uses for a (Monad m => [m a] -> [m a]) function other than reorganizing/modifying the list without doing actual monadic computations?
08:57:14 <geezusfreeek> mm_freak_work: that's basically all you can do with a function like that that i can think of
08:57:48 <popcorn> Wraithan: um bad example, sorry, should have used: factorial(int n, int accum) { if(n == 0) { return accum; } else { return factorial(n - 1, n * accum); } }, anyway something like haskell would optimize it to jumps e.g. factorial(int n, int accum) { loop: if(n == 0) { return accum; } else { accum = n * accum; n = n - 1; goto loop; }
08:58:09 <geezusfreeek> mm_freak_work: you would have to have something like (Monad m => [m a] -> m [m a]) or (Monad m => [m a] -> m [a]) to do anything with the monad
08:58:53 <geezusfreeek> popcorn: really that's a bad example anyway because the C compiler will do the same thing
08:59:05 <popcorn> geezusfreeek: Yours might, mine might not
08:59:14 <ToRA> @type map (fail "hi" >>)
08:59:15 <mm_freak_work> yeah…  so in fact a (Monad m => [m a] -> [m a]) is just a more restricted variant of ([a] -> [a])
08:59:16 <lambdabot> forall (m :: * -> *) b (f :: * -> *). (Functor f, Monad m) => f (m b) -> f (m b)
08:59:23 <Wraithan> popcorn: I see, that makes more sense
08:59:34 <geezusfreeek> mm_freak_work: basically
08:59:45 <popcorn> Wraithan: *phew* I thought it came out a lot more jumbled than I meant :P
08:59:49 <ToRA> mm_freak_work: you can still mess about with the computations inside the list though, since you know about fail and >> etc.
09:00:00 <popcorn> Wraithan: anyway that sort of thing is why recursion is a fine replacement for loops
09:00:07 <mm_freak_work> ToRA: ?
09:00:16 <ToRA> @type map (fail "hi" >>)
09:00:18 <lambdabot> forall (m :: * -> *) b (f :: * -> *). (Functor f, Monad m) => f (m b) -> f (m b)
09:00:34 <mehrheit> @type map
09:00:35 <ToRA> that's a function of your type that doesn't reorder the list elements
09:00:36 <Wraithan> popcorn: Thank you
09:00:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:00:54 <geezusfreeek> mm_freak_work: he means that you could, say, take the first two elements of the list, bind them, and then place the result in the list
09:01:08 <mm_freak_work> ToRA: but that doesn't compute anything from the input list, as far as i understand
09:01:16 <geezusfreeek> it's still not run in the current monad, but it could be if you extracted it later
09:02:22 <geezusfreeek> mm_freak_work: imagine you have x :: Show a => [a]. you could do something like map print x :: [IO ()], then later extract the IO stuff with sequence_
09:02:35 <geezusfreeek> :t sequence_
09:02:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
09:02:42 <geezusfreeek> :t sequence
09:02:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:04:22 <byorgey> oh, map = fmap now?
09:04:33 <geezusfreeek> (or you could have just used mapM_ in the first place, but this is just an example)
09:04:34 <byorgey> neat =)
09:04:46 <geezusfreeek> byorgey: ?
09:05:03 <byorgey> @type Prelude.map
09:05:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:05:07 <byorgey> @type map
09:05:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:05:11 <popcorn> @src mapM
09:05:11 <lambdabot> mapM f as = sequence (map f as)
09:05:19 <popcorn> @src sequence
09:05:20 <lambdabot> sequence []     = return []
09:05:20 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:05:20 <lambdabot> --OR
09:05:20 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
09:05:40 <mm_freak_work> geezusfreeek, ToRA: thanks
09:05:47 <mm_freak_work> that makes sense to me
09:05:56 <byorgey> geezusfreeek: 'map' in lambdabot has been generalized to fmap
09:05:57 <geezusfreeek> byorgey: lambdabot reports types differently from reality though :(
09:06:03 <byorgey> geezusfreeek: yes, I know =)
09:06:06 <popcorn> :t let seq [] = return mzero ; seq (x:xs) = do v <- x ; vs <- xs ; return (x `mplus` xs) in seq
09:06:09 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
09:06:09 <lambdabot>       Expected type: [a]
09:06:09 <lambdabot>       Inferred type: [[a]]
09:06:10 <byorgey> > map (+1) (1,3)
09:06:12 <lambdabot>  (1,4)
09:06:13 <geezusfreeek> :t (.)
09:06:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:06:21 <geezusfreeek> :t liftA
09:06:23 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
09:06:24 <geezusfreeek> :t liftM
09:06:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:06:27 <mm_freak_work> well…  i don't see any reason for a separate 'map' function anyway
09:06:28 <byorgey> map = fmap = (.)
09:06:30 <geezusfreeek> :t (<$>)
09:06:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:06:32 <popcorn> :t let seq [] = mzero ; seq (x:xs) = do v <- x ; x `mplus` seq xs in seq
09:06:34 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
09:06:44 <mm_freak_work> i'd just remove map and rename fmap from Functor to 'map'
09:06:47 <popcorn> > let seq [] = mzero ; seq (x:xs) = do v <- x ; x `mplus` seq xs in seq [[1,2,3],[4,5]]
09:06:48 <lambdabot>  [1,2,3,4,5,4,5,1,2,3,4,5,4,5,1,2,3,4,5,4,5]
09:06:50 <byorgey> mm_freak_work: I do.  it's so beginners can map functions over lists without having to learn yet what a Functor is.
09:06:56 <popcorn> O_O
09:07:12 <geezusfreeek> mm_freak_work: me too. the usual argument against is for the sake of beginners, which i think is a poor argument
09:07:27 <popcorn> > let seq [] = return mzero ; seq (x:xs) = do v <- x ; vs <- seq xs ; return (v `mplus` vs) in seq [[1,2,3],[4,5]]
09:07:27 <lambdabot>   add an instance declaration for (Num (m a))
09:07:38 <mm_freak_work> byorgey: they can do that with fmap, too…  you don't need to talk about functors in tutorials, when introducing fmap
09:07:41 <popcorn> > let seq [] = mzero ; seq (x:xs) = do v <- x ; vs <- seq xs ; v `mplus` vs in seq [[1,2,3],[4,5]]
09:07:42 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a
09:07:42 <lambdabot>       Expected...
09:07:47 <byorgey> I would, however, be in favor of renaming 'fmap' to 'map', and having the list-specific version be 'lmap' or something
09:07:53 <geezusfreeek> mm_freak_work: you do if you show its type though
09:08:14 <geezusfreeek> byorgey: i would be in complete favor of that
09:08:17 <byorgey> mm_freak_work: yeah, that argument doesn't fly.  as soon as they want to know its type (which you should encourage!), or get an error message involving it...
09:09:06 <mm_freak_work> when talking about fmap, you could introduce a myMap function, which is list-specific
09:09:26 <popcorn> why
09:09:28 <mm_freak_work> later in the tutorial you could admit that fmap is actually much more general than myMap
09:09:28 <geezusfreeek> it would still be more complicated that way
09:09:42 <popcorn> :t id :: Bool -> Bool -- just do this
09:09:44 <lambdabot> Bool -> Bool
09:09:52 <geezusfreeek> lol
09:09:52 <popcorn> :t map :: (a -> b) -> [a] -> [b]
09:09:53 <byorgey> I still think it's useful to have a list-specific version in the Prelude.  that way beginners can play around with it *before* they write it themselves (which they should also do).
09:09:54 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:10:05 <mm_freak_work> anyway, i don't see a reason for not introducing functors right away, since they're a pretty simple thing
09:10:18 <byorgey> mm_freak_work: as a teacher, I do not agree. =)
09:10:22 <geezusfreeek> mm_freak_work: because that involved type classes, which are less simple
09:10:28 <mm_freak_work> true
09:10:54 <geezusfreeek> it would be hell for an imperative programmer
09:10:57 <quicksilver> functors are pretty hard compared to lists.
09:10:58 <mm_freak_work> but i'm also in favor of renaming 'map' to 'lmap' and 'fmap' to 'map'
09:11:08 <quicksilver> suppose you're teaching someone in their first week of programming, ever.
09:11:13 <quicksilver> explaining a list to them isn't too bad.
09:11:17 <quicksilver> explaining a functor to them is :)
09:11:18 <byorgey> mm_freak_work: they are quite simple once you understand them.  but there are a LOT of things you have to learn to get to that point, which are easy to take for granted from the vantage point of already understanding it.
09:11:23 <quicksilver> unless they have a particular kind of background.
09:11:49 <mm_freak_work> quicksilver: well, you can explain them as simple as "a construct that may contain any number of values, which you can map functions over" =)
09:11:59 <geezusfreeek> mm_freak_work: imagine if i wrote a "beginner's" tutorial that starts with monad transformers ;)
09:12:26 <byorgey> mm_freak_work: that would be good enough for them to have a vague fuzzy idea of what you mean, but they would quickly get confused with the particulars.
09:12:31 <popcorn> I don't think it's a good idea to have a language bend over backwards to make things easy for newbies though
09:12:46 <byorgey> popcorn: of course not.  you have to find a balance.
09:12:47 <popcorn> what seems more important is having uniformity
09:12:53 <mm_freak_work> well…  most imperative programmers have already met a lot of functors, but under different names
09:13:09 <mm_freak_work> they would call them lists, linked lists, trees, classes, …
09:13:15 <quicksilver> I"m more interested personally in peple who haven't done any programming
09:13:17 <quicksilver> or not much.
09:13:30 <quicksilver> imperative programmers souls may already be irretrievably lost ;(
09:13:34 <mm_freak_work> yeah, they have a much easier time learning haskell than those who have =)
09:13:38 <geezusfreeek> mm_freak_work: i think that makes it even more difficult though. it's really hard to abstract things into one concept which you had previously only very loosely related
09:14:18 <mm_freak_work> well…  i'm coming from the imperative world, and i had a hard time
09:14:23 <popcorn> what's fmap on trees?
09:14:27 <popcorn> @src Functor
09:14:27 <lambdabot> class  Functor f  where
09:14:28 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
09:14:35 <geezusfreeek> popcorn: just like fmap on lists ;)
09:14:39 <mm_freak_work> but functors were a pretty easy concept to me
09:15:03 <popcorn> here's an idea
09:15:14 <popcorn> make [_] the symbol for functor
09:15:22 <opqdonut> :P
09:15:24 <geezusfreeek> nonono
09:15:26 <mm_freak_work> popcorn: ?
09:15:28 <popcorn> so map :: (a -> b) -> [a] -> [b]
09:15:53 <geezusfreeek> popcorn: yuck yuck yuck
09:15:53 <mm_freak_work> that won't work, because you'd need a different constructor for lists then
09:16:21 <popcorn> mm_freak_work: I don't think so
09:16:43 <geezusfreeek> popcorn: Functor is not a type constructor anyway
09:16:45 <mm_freak_work> then how would you express a function of a list?
09:16:59 <wjt> List a
09:17:02 <mm_freak_work> a functor is more general than a list
09:17:02 <popcorn> @src Functor -- geezusfreeek
09:17:02 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:18:13 <funktio> > let (!) n = product [1..n] in (10!)
09:18:14 <lambdabot>  3628800
09:18:31 <geezusfreeek> popcorn: if it was a type constructor then fmap would normally look like fmap :: (a -> b) -> Functor a -> Functor b, but it doesn't because Functor is a type class
09:18:49 <quicksilver> I've toyed with making [ _ ] overloaded syntax for 'pure' before
09:18:52 <geezusfreeek> hence, fmap :: Functor f => (a -> b) -> f a -> f b
09:18:54 <quicksilver> so instead of writing
09:19:06 <int-e> Is there a way to get cabal install a data file  data/foo  (relative to the package source dir) to $DATADIR/foo  instead of  $DATADIR/data/foo ?
09:19:09 <quicksilver> f <$> a <*> pure b <*> c <*> pure d <*> f
09:19:11 <quicksilver> you can write
09:19:20 <quicksilver> f <$> a <*> [b] <*> c <*> [d] <*> f
09:19:23 <dcoutts_> int-e: no
09:19:23 <quicksilver> btu I'm not sure it's worth it.
09:19:37 <popcorn> it would be great to have proper mixfix though
09:19:41 <geezusfreeek> i don't like it
09:20:15 <geezusfreeek> though i like it more than making [] = Functor ;)
09:20:15 <dcoutts_> int-e: if you can think of a way to specify what would be the base and relative paths then do propose something
09:21:19 <int-e> dcoutts_: a Data-Dirs field would be the obvious way I think. copying a data file would have to search that path when it copies a file.
09:21:36 <dcoutts_> int-e: also bear in mind that we'd like to be able to find data files without installing, ie run in-place
09:21:50 <dcoutts_> int-e: which probably does not work once we have multiple data-dirs
09:23:07 <int-e> dcoutts_: actually I'd be happy with a single Data-Dir field (no search path). And of course it's mostly a cosmetical problem.
09:23:18 <mm_freak_work> btw arrows…  how can, for example, turning a list into an arrow be useful?
09:23:49 <dcoutts_> int-e: you can file a feature request if you like
09:23:50 <byorgey> mm_freak_work: what do you mean?  lists aren't Arrows.
09:24:06 <mm_freak_work> ah, ok…  that's what i was confused about
09:24:15 <int-e> dcoutts_: Looking at Paths_foo, the getDataFileName interface could work with a search path, but the getDataDir one obviously won't. Yeah, I guess I'll do that.
09:24:37 <quicksilver> c -> [d] is an arrow, though.
09:24:45 <mm_freak_work> from the fact that arrows are a more general structure, every monad must also be an arrow
09:24:55 <quicksilver> arrows aren't really more general than monads.
09:25:00 <quicksilver> They're incomparable.
09:25:11 <mm_freak_work> quicksilver: yeah, that was my impression
09:25:11 <quicksilver> but all monads generate arrows whilst not all arrows generate monads.
09:25:17 <quicksilver> so it feels like 'there are more' arrows.
09:25:30 <quicksilver> they're differently kinded, though, so they really are "different"
09:25:34 <quicksilver> monads have a "return type"
09:25:44 <quicksilver> arrows have source + destination types
09:27:19 <mm_freak_work> is it correct to view monads as computations and arrows as computers?
09:28:00 <ddarius> dcoutts: You realize the "trick" you use in your well-typed.com blog post is just the functional version of dependency inversion.
09:28:14 <popcorn> mm_freak_work: I think there's lots of ways to look at them
09:28:16 <byorgey> mm_freak_work: IMO that's not a bad view, as an intuition
09:28:17 <pejo> quicksilver, did you see the paper on Wadlers homepage about arrows, monads and .. something more?
09:28:35 <dcoutts_> ddarius: I'm not claiming it's original :-)
09:28:35 <byorgey> pejo: idioms, i.e. Applicative functors
09:28:55 <mm_freak_work> popcorn: sure, but one needs an impression of how a purely theoretical structure "looks like" to be able to make real use of it
09:29:30 <quicksilver> pejo: I saw that it existed, but I didn't read it.
09:29:34 <quicksilver> pejo: I should read it.
09:29:53 <popcorn> @src StateT
09:29:53 <lambdabot> Source not found. Take a stress pill and think things over.
09:29:56 <popcorn> please
09:30:00 <popcorn> :[
09:30:02 <popcorn> @source StateT
09:30:02 <lambdabot> StateT not available
09:30:04 <quicksilver> mm_freak_work: I'm not sure.
09:30:04 <byorgey> mm_freak_work: I definitely like the 'computation' intuition for monadic values. I haven't thought too hard about arrows, but 'computer' seems like a good metaphor
09:30:09 <ddarius> dcoutts: Depending on your target audience, it might be worth mentioning.
09:30:20 <quicksilver> the strong commonality between arrows and monads is that they can both be effectful.
09:30:24 <quicksilver> that's the same.
09:30:32 <dcoutts_> ddarius: I wasn't aware that's what the OOP people called it, but yes it looks like it's exactly the same thing
09:30:33 <quicksilver> but they have rather different binding strategies.
09:30:48 <quicksilver> monads you can pull the results of a computation out and use it arbitrarily
09:30:53 <quicksilver> (that's what >>= lets you do)
09:31:00 <mm_freak_work> byorgey: 'computer' or even 'relation'
09:31:09 <quicksilver> arrows you can somehow only pass the result directly to another arrow
09:31:12 <quicksilver> no messing around
09:31:15 <quicksilver> using it for other stuff.
09:31:25 <byorgey> in particular, you can't decide which arrow to use next based on the output of the first.
09:31:48 <quicksilver> a monad in which you force yourself to only use >=>
09:31:50 <quicksilver> is an arrow
09:31:54 <quicksilver> (you're using it as an arrow)
09:32:20 <quicksilver> then the other difference is the 'domino composition rule'
09:32:30 <dcoutts_> ddarius: for that matter it's like module functors
09:32:47 <mehrheit> @type (>=>
09:32:49 <lambdabot> parse error (possibly incorrect indentation)
09:32:56 <mehrheit> @type (>=>)
09:32:58 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:33:09 <byorgey> quicksilver: what's that?
09:33:14 <quicksilver> mehrheit: that's arrow composition in the "kleisli" arrow
09:33:26 <quicksilver> byorgey: you join "a b c" to "a c d" and get "a b d"
09:33:29 <quicksilver> byorgey: like function composition
09:33:32 <byorgey> oh, of course
09:33:33 <quicksilver> or matrix multiplication.
09:33:41 <byorgey> I'd just never heard it called 'domino composition rule' =)
09:33:53 <ddarius> matrix multiplication is just a representation of (linear) function composition.
09:34:05 <geezusfreeek> @src (>=>)
09:34:05 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
09:34:16 <geezusfreeek> broccoli brains, eh?
09:34:54 <jaj> "that's arrow composition in the "kleisli" arrow" this goes into section 9 of Real World #haskell
09:34:57 <nottha_k> haskell broke my brain. i had to build and traverse a tree from some data using php today. I couldn't figure out how to do it with loops and without closures. Well I did figure it out, but it made my head hurt.
09:35:09 <byorgey> (h >= k) x = h x >>= k
09:35:15 <dcoutts_> ddarius: heh, the main difference seems to be that it's easy to apply dependency inversion in FP using higher order stuff compared to the OOPy interface approach
09:35:17 <byorgey> er, (h >=> k) x = h x >>= k
09:35:22 <geezusfreeek> nottha_k: join the club
09:35:29 <byorgey> jaj: hehe =)
09:35:55 <popcorn> MaybeT !!!!!?
09:36:04 <popcorn> @instances MonadT
09:36:04 <lambdabot> Couldn't find class `MonadT'. Try @instances-importing
09:36:08 <popcorn> @instances MonadTrans
09:36:09 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
09:36:17 <geezusfreeek> wow, >=> is exactly what i was looking for at this very moment!
09:36:36 <shepheb> @quote drawback
09:36:36 <lambdabot> No quotes match.
09:36:37 <popcorn> @src I
09:36:37 <lambdabot> Source not found. Maybe you made a typo?
09:36:39 <popcorn> @src MonadTrans
09:36:40 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:36:42 <Deewiant> popcorn: http://www.haskell.org/haskellwiki/New_monads/MaybeT
09:36:43 <lambdabot> Title: New monads/MaybeT - HaskellWiki
09:36:54 <eugman> @src words
09:36:54 <lambdabot> words s = case dropWhile isSpace s of
09:36:54 <lambdabot>     "" -> []
09:36:54 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:36:59 <shepheb> wasn't there an old quote, "Haskell's biggest drawback is that it makes you hate other programming languages"
09:37:08 <popcorn> shepheb: that's lisp
09:37:27 <popcorn> haskell makes you -implement- all other programming languages
09:37:32 <popcorn> (and that takes a long time..)
09:37:34 <geezusfreeek> shepheb: i don't know about old quote, but i've said it before
09:38:20 <eugman> Is there a builting way to see if a certain substring is in a string?
09:38:28 <popcorn> @hoogle infix
09:38:29 <lambdabot> Data.Generics.Basics.Infix :: Fixity
09:38:29 <lambdabot> Text.ParserCombinators.Parsec.Expr.Infix :: GenParser t st (a -> a -> a) -> Assoc -> Operator t st a
09:38:29 <lambdabot> Language.Haskell.TH.Syntax.Infix :: NameIs
09:38:32 <popcorn> @hoogle infixOy
09:38:32 <lambdabot> No matches found
09:38:36 <Deewiant> @ty isInfixOf
09:38:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
09:40:19 <popcorn> hey anyone got KMP in haskell?
09:40:26 <popcorn> just wondering what it'd look like
09:40:26 <dcoutts_> yep
09:40:41 <mehrheit> are arrows a subset or a superset of monads?
09:40:54 <Deewiant> superset
09:41:07 <popcorn> @instances Arrow
09:41:08 <lambdabot> (->), Kleisli m
09:41:15 <popcorn> @instances Monad
09:41:16 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:41:38 <dcoutts_> popcorn: see the stringsearch package
09:41:43 <dcoutts_> @hackage stringsearch
09:41:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stringsearch
09:41:49 <mehrheit> what is the relation of kleisli arrows and monads?
09:41:51 <popcorn> cool thanks
09:42:00 <int-e> popcorn: here's one: http://hpaste.org/1912
09:42:07 <popcorn> thanks int-e
09:42:29 <ddarius> @src Kleisli
09:42:29 <lambdabot> Source not found. Do you think like you type?
09:44:09 <Deewiant> mehrheit: http://www.haskell.org/haskellwiki/Arrow_tutorial
09:44:11 <lambdabot> Title: Arrow tutorial - HaskellWiki
09:44:24 <kpreid> mehrheit: you get a Kleisli arrow from every monad
09:44:41 <kpreid> mehrheit: so it lets you use a monad with the arrow operators
09:45:00 <kpreid> but there are arrows that can't be expressed that way.
09:46:22 <mehrheit> thank you
09:47:18 <kpreid> a monad has one type parameter, the result; m b
09:47:26 <kpreid> an arrow has two, input and result, arr a b
09:47:50 <kpreid> so Kleisli adds the input parameter, but in a particular fashion
09:48:04 <kpreid> it can't do anything specific to the monad
09:58:51 <quicksilver> I have trouble thinking of interesting arrows which are not Kleisli arrows
09:58:58 <quicksilver> it's a real gap in my arrow intuition
09:59:19 <cnwdup> I am experimenting with gtk2hs and encountered a problem I cannot solve: I'd like to write a GTK application which maintains a state, so I run most functions inside the State Monad. As I'd like to use timeouts, I use gtk2hs' timeoutAdd :: IO Bool -> Int -> IO HandlerId, to maintain a state, it has to be of State s IO Bool, doesn't it? Can I solve this or do I have to rethink my concept?
09:59:56 <quicksilver> @go monadic tunnelling
09:59:57 <lambdabot> No Result Found.
10:00:01 <quicksilver> stupid lambdabot
10:00:08 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
10:00:10 <lambdabot> Title: [Haskell-cafe] Monadic tunnelling: the art of threading one monad through anothe ..., http://tinyurl.com/3xmhco
10:00:16 <quicksilver> cnwdup: been there, done that, got the T-shirt.
10:00:26 <cnwdup> Thank you, quicksilver.
10:00:28 <kpreid> cnwdup: use an IORef instead
10:00:28 <quicksilver> cnwdup: no, you don't have to re think. Yes, your reasoning is accurate.
10:00:44 <quicksilver> use an IORef in a thin wrapper which calls your real callback.
10:00:52 <kpreid> cnwdup: you can do runStateT inside the callback to get back in the monad
10:00:55 <quicksilver> that link I just posted is just a way to abstract those wrappers.
10:00:58 <quicksilver> right.
10:01:14 <cnwdup> kpreid: But then I can't modify my state from outside the timeoutAdd callback, can I?
10:01:28 <kpreid> cnwdup: well, you have to use the same IORef
10:01:34 <cnwdup> ok
10:01:40 <cnwdup> I think, I'll read the link first. (-:
10:02:38 <kpreid> cnwdup: one thing to do is make your own monad type (data MyM a = MyM (IORef myStateType) (IO a) which is an instance of MonadState
10:02:47 <quicksilver> yuck
10:02:48 <quicksilver> nasty
10:02:53 <quicksilver> I would minimise the pollution of the IORef
10:02:56 <kpreid> then you can implement get and put in terms of IORef
10:02:59 <quicksilver> to as thin a wrapper as you can.
10:02:59 <kpreid> well, this hides it :-)
10:03:00 <visof> cnwdup i want to start with GUI in Haskell , and i know a little about monads , does should i know a lot about it first?
10:03:44 <kpreid> and transitioning between StateT and the IORef means that if you accidentally use the IORef while inside, then you lose consistency
10:04:12 <int-e> kpreid: MyM a = MyM (IORef myStateType -> IO a) works better and is essentially a ReaderT (IORef myStateType) IO
10:04:12 <popcorn> visof: no just go for it, learn by need
10:05:03 <kpreid> int-e: that doesn't carry...oh. I see. yes, that's better
10:05:16 <kpreid> in fact, mine wouldn't work
10:05:24 <kpreid> return x = MyM ???
10:05:30 <int-e> :)
10:05:49 <cnwdup> visof: The gtk2hs library isn't hard to use at all. I - still *very* new to Haskell - encounter a lot of problems that require much reading as soon as I go faster. Writing a GTK app isn't hard, but I have problems combining it with MPD for example. But you sould just try it and don't desperate just because something doesn't work out on the first time.
10:06:04 <cnwdup> s/faster/deeper/
10:06:08 <cnwdup> *lol*
10:06:12 <visof>  where should i start?
10:06:15 <visof> tutorial
10:06:16 <visof> ?
10:06:24 <Deewiant> @unmtl ReaderT (IORef myStateType) IO a
10:06:25 <lambdabot> IORef myStateType -> IO a
10:06:45 <sw17ch> Data.Binary is pretty neat
10:06:49 <cnwdup> visof: http://home.telfort.nl/sp969709/gtk2hs/index.html that helped me a lot
10:06:50 <lambdabot> Title: Gtk2Hs Tutorial
10:07:36 <cnwdup> visof: You may find it usefull to read some C tutorials as well. I have experience from coding gtk apps in C which helped me a lot to understand the haskell tutorial. Though I don't think "C knowledge" will be required.
10:08:18 <visof> cnwdup i know c basics
10:08:21 <cnwdup> The introduction of different widgets isn't as gentle as in other tutorials.
10:08:32 <int-e> it's less C than knowing the Gtk classes a bit
10:08:38 <cnwdup> Well, then just read the tutorial. It's pretty good.
10:08:42 <cnwdup> int-e: That's true.
10:09:00 <visof> cnwdup do you use Glade ?
10:10:43 <cnwdup> visof: Nope. I prefer writing my GUIs instead of clicking them. Gtk is very powerfull helping you with that. But if you want to use Glade, there's nothing wrong with it. Probably faster development.
10:11:18 <cnwdup> And it's very easy to create runtime loaded GUIs which is encouraged in the tutorial I gave you as GUI design is more flexible.
10:18:16 <sw17ch> cnwdup, i've loved the XML gui's that libglade uses... very practical for my purposes :)
10:20:00 <eugman> Hmm, can anyone tell me what a ^M character means?
10:20:17 <popcorn> newline I think
10:21:41 <byorgey> eugman: it probably means the file was created in a windows/dows environment with \r\n pairs signifying newline
10:21:49 <byorgey> eugman: so now the \r is being displayed as ^M
10:22:06 <byorgey> at least, that's when I always see ^M
10:22:20 <byorgey> er, windows/dos  =P
10:22:22 <eugman> Yeah that must be it. I did lines and then reverse on some of the lines and I see thes ^M's at the starts
10:22:41 <byorgey> eugman: yeah, lines isn't \r-aware =)
10:23:27 <byorgey> eugman: you can either (1) run a utility like dos2unix on the files first, or (2) strip the \r characters after using 'lines'
10:23:51 <popcorn> @src lines
10:23:52 <lambdabot> Source not found. I am sorry.
10:24:12 <eugman> Well it doesn't seem to be on my ubuntu box and a quick aptitude install dos2unix didn't work. Hmmm
10:25:03 <popcorn> dos2unix [] = [] ; dos2unix [x] = [x] ; dos2unix ('\r':'\n':xs) = '\n' : dos2unix xs
10:25:29 <byorgey> eugman: I forget which package it's in, hang on a sec...
10:25:37 <popcorn> just use this?
10:26:11 <EvilTerran> > lines []
10:26:14 <lambdabot>  []
10:26:44 <kpreid> > words []
10:26:46 <lambdabot>  []
10:27:06 <Baughn> @ty splitBy
10:27:07 <lambdabot> Not in scope: `splitBy'
10:27:08 <byorgey> eugman: it's in the tofrodos package
10:27:13 <EvilTerran> lines cs = case break (== '\n') cs of (line,[]) -> [line]; (line,rest) -> line : lines rest
10:27:14 <EvilTerran> iirc
10:27:22 <Baughn> @src lines
10:27:22 <lambdabot> Source not found. Just try something else.
10:27:33 <eugman> thanks
10:27:35 * Baughn blinks. This is not my doing.
10:27:37 <popcorn> oops
10:27:47 <popcorn> dos2unix (x:xs) = x : dos2unix xs
10:27:52 <popcorn> forgot that bit..
10:28:37 <EvilTerran> http://haskell.org/onlinereport/standard-prelude.html#$vlines
10:28:37 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
10:28:46 <EvilTerran> bit more complicated than that, apparently
10:29:17 <Zao> > length $ filter (/='\r') "omg\r\nwtf"
10:29:19 <lambdabot>  7
10:29:21 <EvilTerran> well, that's a refinement of my version. less strict, because it moves the line: outside the case.
10:29:40 <thetallguy> ?tell shapr http://feeds.feedburner.com/~r/core77/blog/~3/280758708/new_electric_vehicle_with_an_unusual_form_factor_9657.asp
10:29:40 <lambdabot> Consider it noted.
10:30:15 <EvilTerran> same behaviour as mine in the places mine is defined
10:30:48 <EvilTerran> but more defined if you have ("...\n" ++ _|_) in the string
10:32:28 <DuClare> Twey, :o  I didn't know you were a haskeller.
10:32:41 <Baughn> @let splitBy f s = case dropWhile f s of "" -> []; s' -> let (w, s'') = break f s' in w : splitBy f s''
10:32:42 <lambdabot> Defined.
10:32:43 <Twey> DuClare: Yes you did
10:32:50 <Twey> DuClare: I told you days ago.  :-P
10:32:56 <Baughn> @let words' = splitBy isSpace
10:32:56 <lambdabot> Defined.
10:32:57 <DuClare> How cone I can't remember.
10:33:00 <DuClare> come.
10:33:07 <Baughn> > words " Foo bar "
10:33:08 <lambdabot>  ["Foo","bar"]
10:33:16 <Baughn> > words' " Foo bar "
10:33:18 <lambdabot>  ["Foo","bar"]
10:33:26 <Deewiant> @check \x -> words x == words' x
10:33:29 <EvilTerran> ?src words
10:33:29 <lambdabot>  OK, passed 500 tests.
10:33:29 <lambdabot> words s = case dropWhile isSpace s of
10:33:29 <lambdabot>     "" -> []
10:33:29 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:33:34 <Deewiant> @scheck \x -> words x == words' x
10:33:37 <lambdabot>   Completed 1957 test(s) without failure.
10:33:45 <popcorn> @check words == words'
10:33:46 <lambdabot>        add an instance declaration for (Eq (String -> [String]))     In the e...
10:33:50 <popcorn> :|
10:33:57 <EvilTerran> ?check liftM2 (==) words words'
10:33:57 <Deewiant> @pl \x -> words x == words' x
10:33:58 <lambdabot>  OK, passed 500 tests.
10:33:58 <lambdabot> liftM2 (==) words words'
10:34:14 <popcorn> @let (===) = liftM2 (==)
10:34:15 <lambdabot> <local>:3:8:     Ambiguous type variable `m' in the constraint:       `Monad ...
10:34:20 <popcorn> :/
10:34:28 * EvilTerran would like (<==>) = liftM2 (==) for @(s)check purposes
10:34:29 <popcorn> @let y === x = liftM2 (==) y x
10:34:31 <lambdabot> Defined.
10:34:35 <popcorn> @let y <==> x = liftM2 (==) y x
10:34:37 <lambdabot> Defined.
10:34:53 <EvilTerran> well, liftA2
10:34:58 <popcorn> @check (\x->x+1) <==> (\x->1+x)
10:35:00 <lambdabot>  OK, passed 500 tests.
10:35:12 <popcorn> @check words <==> words'
10:35:12 <Baughn> @scheck \x -> lines x == (splitBy (== '\n')) x
10:35:14 <lambdabot>  OK, passed 500 tests.
10:35:15 <lambdabot>   Completed 1957 test(s) without failure.
10:35:17 <popcorn> great!
10:35:29 <Baughn> Now I just need to get that into the prelude
10:35:44 <EvilTerran> it'd be nice if things could be implicitly lifted into Reader, but it'd be an Olegian dream/everyone else's nightmare
10:36:28 <EvilTerran> (so (f + g) x = f x + g x, regardless of (+), based on static type inference)
10:37:51 <FalconNL> Could anyone give me a hint about what I'm doing wrong in http://hpaste.org/7480 ?
10:38:46 <dmwit> FalconNL: Yeah, the list (as you declared it) can only be a list of a single instance of ShapeType.
10:39:12 <dmwit> i.e. it can be a list of any ShapeType instance, but once the instance has been nailed down, all elements have to be *that* instance.
10:39:22 <dmwit> The syntax for what you want is something like
10:39:38 <dmwit> shapeTypes :: [[forall a. ShapeType a => a]]
10:40:09 <Baughn> Don't you still have to wrap that type in a data?
10:40:35 <FalconNL> dmwit: I'm getting a parse error on input '=>'
10:41:03 <dmwit> Listen to Baughn, he most likely knows more than me.
10:41:49 <Baughn> I do not. I've read the section on existential types repeatedly, but without /using/ it yet..
10:42:22 <Baughn> Well, dmwit's type is correct, but I don't believe ghc supports it. It would support the same type in a data (and possibly newtype), which you could then put in a list
10:42:38 <Baughn> With an extension, mind you. ghc will prompt you to add it.
10:43:10 <FalconNL> Perhaps it's better if I give the real situation, as there might be a better approach altogether. Give me a second to type it up.
10:43:19 <dons> Prelude> :set -XRankNTypes
10:43:26 <dons> Prelude> :k [[forall a. Eq a => a]]
10:43:27 <dons> [[forall a. Eq a => a]] :: *
10:44:21 <Baughn> FalconNL: The basic documentation is at http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#existential-quantification
10:44:23 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
10:44:59 <Baughn> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification for dons' version
10:45:00 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
10:45:47 <dbpatterson> sclv_: are you around?
10:50:25 <FalconNL> I'm working on a Roguelike in haskell. I have different bitmaps for things like monsters, items, etc. For each of these I have a legend to identify which part of the bitmap maps to what object. (e.g.:
10:50:27 <FalconNL> data Tile = Wall | Floor | Water | ... deriving Eq
10:50:28 <FalconNL> data Items = ShortSword | LongSword | ... deriving Eq
10:50:30 <FalconNL> tilesLegend = [[Wall, Floor],[Water, ...]]
10:50:31 <FalconNL> itemsLegend = [[ShortSword, LongSword], ...]
10:50:33 <FalconNL> I call the draw function for each type of item and wanted to get rid of all the nearly identical function calls so I tried to zip3 the relevant lists (bitmaps, legends and functions that take the World and return the appropriate object type) and mapM_ the draw function over that. This however leads to a problem for the legends and functions list as they all have different types.
10:50:34 <FalconNL> If anyone has a better approach I'd love to hear it.
10:51:41 <Zao> FalconNL: Wrap the heterogenous elements in some type to hold them?
10:52:33 <eugman_> Gah, i keep getting stuck on this function and i can't figure out how to stucture it. I want to make a function that takes a test function and a list of lines and I want it to return a list where each element is a chunk of the text, essetially a smaller list of lines. I want the chunking to be done based on whenever a line passes the test function.
10:52:51 <Zao> eugman_: Use groupBy maybe?
10:53:05 * eugman_ goes to look that up
10:53:07 <FalconNL> Zao: I tried to do that by making a class Dummy and having Tile, Item, etc. be an instance of that, with legends becoming Dummy a => [[a]], but this gives the error shown in hpaste
10:53:29 <byorgey> eugman_: maybe something with span?
10:53:42 <int-e> > groupBy ((==) `on` odd) [1,2,4,5,6,7,9,11,13]
10:53:44 <lambdabot>  [[1],[2,4],[5],[6],[7,9,11,13]]
10:53:58 <int-e> funny
10:54:11 <popcorn> @let both = ((==)`on`)
10:54:12 <lambdabot> <local>:5:8:     Ambiguous type variable `b' in the constraint:       `Eq b' ...
10:54:14 <Baughn> FalconNL: I think he's suggesting "data Dummy = T Tile | I Item | ...", but..
10:54:16 <popcorn> :[
10:54:18 <byorgey> chunk test [] = []; chunk test ls = ch : chunk test rest  where (ch, rest) = span test ls   -- eugman_, does this work?
10:54:21 <popcorn> this is irritaing
10:54:27 <popcorn> > let both = ((==)`on`) in both odd 3 7
10:54:28 <lambdabot>  True
10:54:32 <Baughn> FalconNL: That sounds like a reasonable use for existential qualification to me
10:54:49 <int-e> popcorn: that's the monomorphism restriction at work
10:54:54 <EvilTerran> Baughn, well, a dummy class isn't really appropriate
10:54:58 <eugman_> byorgey, I was thinking that but I haven't figured out how to goe through a whole list that way
10:55:12 <eugman_> also, is groupby in prelude?
10:55:14 <int-e> @let both p = (==) `on` p -- works, I suspect
10:55:15 <lambdabot> Defined.
10:55:16 <maltem> > let both = ((==) `on`) in both even 3 7 -- hm?
10:55:17 <lambdabot>  True
10:55:23 <byorgey> eugman_: using recursion, as in my example there
10:55:23 <Baughn> FalconNL: So, "[[forall a. Textble a => a]]" or thereabouts
10:55:24 <FalconNL> Baughn: ok, I'll go read up on that.
10:55:28 <EvilTerran> if Dummy has no methods, then [forall a. Dummy a => a] might as well be [forall a. a]
10:55:29 <byorgey> eugman_: it's in Data.List
10:55:32 <int-e> groupBy is in Data.List
10:55:38 <dbpatterson> does anyone know what Database.StaticRecord is?
10:55:44 <Baughn> FalconNL: You'd need rank-n types. To be honest, I don't know exactly how that would work, but I assume it would.
10:56:58 <dbpatterson> or I should say, know about it? (it's sclv's)
10:57:25 <Baughn> FalconNL: With "Textable a => [[a]]", they /all have to be the same a/. Existential qualification allows you to use forall, which lets you scope the type so they can be /different/ as; rank-n types allows you to use existential qualification inside other type constructors, such as []
10:57:47 <Baughn> FalconNL: And the above explanation is horrible and most likely misleading, so read the actual documentation instead. ;)
10:58:01 <FalconNL> Baughn: :)
10:58:46 <sclv_> dbatterson: you rang?
10:58:53 <int-e> FalconNL: have a look at this, http://www.haskell.org/haskellwiki/Existential_types#Expanded_example_-_rendering_objects_in_a_raytracer
10:58:55 <lambdabot> Title: Existential type - HaskellWiki, http://tinyurl.com/5boogo
11:02:09 <dbpatterson> sclv_: yeah, I have two questions
11:02:40 <dbpatterson> second - I just darcs pull'd, and it seems okay, but compiling existing code gave me this error - Failed to load interface for `Database.StaticRecord'
11:02:59 <sclv_> hmmm... maybe I didn't update the cabal file yet.
11:03:14 <dbpatterson> first is more general - is there an easy way to do IO stuff in the controller?
11:03:34 <jdavis_> I'm just learning. What's the equivalent of an OCaml function definition like: "let foo x = match x with Something -> 1 | Nothing -> 0"
11:03:36 <dbpatterson> or do I have to copy what you've done (havent even looked yet) for hvReadfile etc
11:04:11 <sclv_> all the io is sort of encapsulated to keep things atomic.
11:04:17 <sclv_> what sort of IO do you want
11:04:17 <mrd> jdavis_: case .. of
11:04:20 <byorgey> jdavis_: foo x = case x of { Something -> 1 ; Nothing -> 0 }
11:04:34 <Zao> {} may be replaced by lines and indentation.
11:04:35 <tromp> you can even avoid explicit case
11:04:47 <dbpatterson> sclv_: curl, essentially... its a library I'm writing for my photo hosting site (smugmug)
11:04:54 <dbpatterson> and system.random too :)
11:04:57 <jdavis_> byorgey, mrd: can you do pattern matching with a case statement?
11:05:00 <tromp> foo (Just x) = ....; foo _ = ....
11:05:07 <byorgey> jdavis_: yes, that's exactly what it's for =)
11:05:34 <mrd> jdavis_: mind you, most haskell programmers would do the pattern match directly in the function definition
11:06:03 <byorgey> foo Something = 1
11:06:05 <byorgey> foo Nothing = 0
11:06:08 <byorgey> like that
11:07:18 <geezusfreeek> why the heck does Num require Show?
11:07:34 <mehrheit> @src Num
11:07:35 <lambdabot> class  (Eq a, Show a) => Num a  where
11:07:35 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:07:35 <lambdabot>     negate, abs, signum     :: a -> a
11:07:35 <lambdabot>     fromInteger             :: Integer -> a
11:07:37 <sclv_> hmm... I've been meaning to write an unsafeIOtoHCGI function for things like that I suppose...
11:07:42 <maltem> geezusfreeek, Haskell-98 numeric classes are broken
11:08:06 <geezusfreeek> my type isn't well-suited to Show :(
11:08:08 <maltem> geezusfreeek, you may also ask why Num requires Eq
11:08:37 <mehrheit> maltem, how are they broken?
11:08:38 <dbpatterson> sclv_: that would be a really nice function :)
11:08:40 <sclv_> but it should really be stmToHCGI I think, and then the end user should be forced to call unsafeIOtoSTM
11:08:41 <geezusfreeek> maltem: i presume because of the law: abs x * signum x == x
11:08:57 <dbpatterson> okay too
11:08:58 <sclv_> to emphasize that things may get rerun due to stm
11:09:38 <popcorn> geezusfreeek: more likely so you can use == in Numbers...
11:09:49 <jaj> geezusfreeek: show x = error "not suited to show"
11:09:56 <opqdonut> heh
11:10:02 <maltem> geezusfreeek, I'd argue that that law is about the behaviour of abs and signum, and the (==) is not required to be Eq's (==)
11:10:08 <Cale> The reason for Num to require Eq is n-patterns
11:10:13 <opqdonut> show x = error "you don't really want to do that"
11:10:15 <geezusfreeek> maltem: i guess you're right
11:10:20 <Cale> It's not a terribly good reason.
11:10:33 <geezusfreeek> ugh
11:11:02 <Cale> That is, it's so that you don't create an additional Eq constraint when writing code like  fib 0 = 0
11:11:03 <maltem> Cale, ah, that makes already a little sense
11:11:42 <maltem> is it equivalent to fib n | n == fromInteger 0 = fromInteger 0 ?
11:11:47 <geezusfreeek> i would just as soon prefer having to explicitly specify the Eq contraint when i need to do n-patterns though
11:12:17 <jdavis_> byorgey, mrd: can I pattern match based on some kind of union type? Why doesn't the following work: \x -> case x of { 1 -> 100; 'b' -> 20; _ -> 0 }
11:12:35 <popcorn> jdavis: they aren't members of a sum type
11:12:44 <byorgey> jdavis_: there is no type of which 1 and 'b' are both elements.
11:12:44 <Cale> maltem: yeah
11:12:47 <popcorn> you could have like
11:12:58 <popcorn> \x -> case x of { Left 1 -> 100; Right 'b' -> 20; _ -> 0 }
11:12:59 <Cale> geezusfreeek: I would too
11:13:01 <popcorn> @src Either
11:13:01 <lambdabot> Source not found. My pet ferret can type better than you!
11:13:03 <jdavis_> Ok, but if I declared a type like that, it would work?
11:13:20 <mrd> popcorn: _ would be redundant there
11:13:27 <byorgey> jdavis_: you could declare a type like this:  data MyType = I Int | C Char
11:13:36 <maltem> mehrheit: broken in the sense that their structure isn't totally obvious and not very extensible, both from a mathematical view
11:13:42 <popcorn> mrd: how?
11:13:44 <byorgey> jdavis_: and then you could write  case x of { I 1 -> 100 ; C 'b' -> 20; _ -> 0 }
11:13:58 <byorgey> jdavis_: but note that the constrctors (here, I and C) are necessary
11:14:02 <Cale> jdavis_: You can't declare a type for which 1 and 'b' are both elements... well, you could write an instance of Num for Char so that 1 could be interpreted as a Char, but I don't think that's what you're looking for :)
11:14:14 <geezusfreeek> i assume Haskell' will have these type classes cleaned up?
11:14:18 <Cale> Yeah, you can only have tagged unions :)
11:14:24 <Cale> geezusfreeek: Who knows.
11:14:49 <byorgey> geezusfreeek: that would be nice, but I wouldn't count on it. There's a lot of inertia to overcome at this point.
11:14:51 <jdavis_> byorgey: Ok, that's exactly what I was looking to do, thanks everyone!
11:14:56 <mrd> popcorn: nevermind, i was thinking of Left i; Right b
11:15:11 <geezusfreeek> ugh. but why? haskell' isn't supposed to be backward compatible, is it?
11:15:17 <Cale> geezusfreeek: There seems to be a bunch of people (like me) who would like to see compatibility breaking changes in the Prelude, and also a lot of people who want to preserve backwards compatibility as much as possible
11:15:22 <jdavis_> Cale: what's a tagged union?
11:15:59 <Cale> jdavis_: You have a data constructor which tells you which of the options you have... like byorgey pointed out
11:16:02 <Cale> data MyType = I Int | C Char
11:16:12 <geezusfreeek> ah, so a consensus has not been reached on whether to break backward compatibility?
11:16:16 <ski_> aka disjoint union
11:16:26 <jdavis_> Cale: oh, just making sure. Thanks.
11:16:51 <Cale> A value of type MyType is either of the form  (I x) for some Int value x, or of the form (C y) for some Char value y
11:16:58 <ski_> {I i | i : Int} U {C c | c : Char}  -- in set-theoretic terms
11:17:58 <sclv_> dbpatterson: Ok I fixed the cabal file and added stmToHCGI for you -- just pushed. (now that's service! :-))
11:18:09 <dbpatterson> sclv_: awesome!
11:18:50 <sclv_> i want to split staticrecord out soon and finish cleaning it up tho, and then make it available seperately as well, and get the whole thing hackaged... so its getting there...
11:19:22 <jdavis_> I've been very happy learning Haskell so far... and the first line I wrote ever was a few days ago.
11:19:27 * geezusfreeek writes broken instance of for Show and Eq
11:19:29 <dbpatterson> sclv_: staticrecord is your database dsl?
11:19:34 <geezusfreeek> *instances for
11:19:50 <sclv_> dbpatterson: if you play with the file operations, let me know... i recently rewrote everything to use a new stm-based locking model and haven't really tested it at all...
11:20:36 <sclv_> dbpatterson: yep. its not documented yet, but pretty usable. i don't think i'm going to add much more to it at this point before an 0.1 release...
11:20:58 * gwern wonders whats new in haskell land
11:21:11 <geezusfreeek> gwern: less than i would like
11:21:33 <gwern> geezusfreeek: what are you doing about it?
11:21:41 <geezusfreeek> complaining
11:22:19 <gwern> a worthy contribution
11:22:25 <gwern> @seen dcoutts
11:22:25 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 3h 45m 6s ago.
11:22:27 <dbpatterson> sclv_: hmm... what is the stuff with TupleLevel (existing code breaking...), or, hmm.. are the examples updated (seems like a couple things have changed... I haven't pulled for about a month or so)?
11:22:35 <gwern> argh
11:23:58 <sclv_> I changed some type signatures...
11:24:01 <roconnor> how much is 300 words?
11:24:06 <roconnor> doesn't sound very long
11:24:20 <dons> 3-5 paragraphs?
11:24:25 <dons> not much at all
11:24:32 <dbpatterson> sclv_: so what should a controller type sig look like? I have :: (String -> StringTemplate BS.ByteString) -> HCGI ReadWrite Sess CGIResult
11:24:57 <slarba> roconnor: replicate 300 "word"
11:24:58 <slarba> ;)
11:25:04 <sclv_> for database access, I think, now intead [SqlValue] as a last param they take e.g. (Box <SqlType>) or (<SqlType>,<SqlType) etc...
11:25:04 <slarba> it's that much
11:25:07 <gwern> @tell dcoutts there wasn't much whitespace changes, but here: http://hpaste.org/7463#a1 - basically swap a die for a warn
11:25:07 <lambdabot> Consider it noted.
11:25:15 <sclv_> the controller type sig shouldn't change I think.
11:25:27 <dcoutts_> gwern: yes
11:25:39 <sclv_> the examples are updated too tho, so you can take a look.
11:25:51 <dcoutts_> gwern: yeah, I'm not sure what the better behaviour is
11:26:03 <gwern> oh noes, it's teh dcoutts_! why do I always use dcoutts...
11:26:09 <dcoutts_> heh
11:26:16 <dbpatterson> sclv_: sounds good...
11:26:35 <gwern> dcoutts_: well, to me it looks like an error: the user has a specific request, the request makes no sense (in the context), but cabal is going to claim everything wnet fine?
11:27:29 <dcoutts_> gwern: well in a sense it did what you asked :-)
11:27:43 <gwern> -_-
11:27:45 <visof> @where yaht
11:27:45 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
11:28:18 <gwern> dcoutts_: yes, well, then how do you address my shell script point?
11:28:48 <dcoutts_> gwern: so what is that trying to do? build the docs for the library and any executables?
11:29:04 <dbpatterson> sclv_: errm, /usr/local/lib/hvac-0.1/ghc-6.8.2.20080221/Network/Frameworks/HVAC/Types.h \n Declaration for $f3: \n Failed to load interface for `Network.Frameworks.HVAC.TypeCast':
11:29:24 <gwern> dcoutts_: build whatever docs possible, I was sort of thinking
11:29:51 <dcoutts_> gwern: then just use --executables, it's in addition, not instead of
11:30:05 <gwern> you could say 'haddock; haddock --executables', but that almost guarantees that you'll have a messed up request whenever you ask, and who knows but that enumeration is not exclsuive
11:30:32 <dcoutts_> whu?
11:30:34 <thetallguy> Has anyone written an executive summary of FP for non-programmers?
11:30:55 <dons> for non-programmers? hmm
11:31:04 <thetallguy> i.e., someone for whom this http://haskell.org/haskellwiki/Functional_programming would be way too technical
11:31:04 <lambdabot> Title: Functional programming - HaskellWiki
11:31:13 <Deewiant> maybe there's something of the sort in SICP?
11:31:20 <thetallguy> I Hmm...
11:31:25 <dons> Why FP matters?
11:31:28 <thetallguy> I doubt it.
11:31:48 <thetallguy> nothing John Hughes says is comprehensible to the people I'm talking about
11:31:59 <gwern> dcoutts_: well, is there any particular reason for it to not be an error?
11:32:20 <dons> thetallguy: so i always tell my parents its about making software not crash
11:32:28 <dons> 'nuf said.
11:32:38 <thetallguy> dons: that's the kind of thing I'm thinking about
11:33:07 <thetallguy> dons: I say, based on mathematics, trying to make it so things like Vista don't happen.
11:33:12 <dons> and then show a couple of function definitions -- "See, its just like math. We want our software to be as solid as math.
11:33:18 <JokerDoom> rofl@thetallguy
11:33:42 <gwern> you know what would be nice? if there were some sort of function where you could pass it a function, and it'd spit out a list of qc properties it satisfies which you could henceforth use
11:34:14 <Cale> I liked Launchbury's (?) metaphor about building bridges.
11:34:16 <sclv_> dbpatterson: oh, forgot to add typecast!
11:34:17 <sclv_> one sec.
11:34:30 <thetallguy> dons: yes, that's exactly right.  I've just had to say that several times recently and I'm thinking I should get something up on the CUFP site that will tell that story well and quickly for managers, casual observers, etc.
11:34:31 <dons> yeah, JL has some good guides to FP for managers/
11:34:36 <thetallguy> Cale: do tell?
11:34:42 <gwern> for example, you pass it (+), it'd give you tests for associavity, commutavity, monotonicity and so on
11:34:54 <dons> thetallguy: i'll ask jl if he has some slides on this stuff we can reuse?
11:34:57 <thetallguy> are they written down someplace?
11:35:15 <Cale> They used to build bridges by putting up scaffolds, putting the stones in place and then just taking the scaffolding away bit by bit and fixing up parts which fell down.
11:35:21 <thetallguy> That would be great.  Doesn't/shouldn't be much.  Just enough to paint a picture.
11:35:39 <dons> thetallguy: i'll ask around
11:35:49 <Cale> That's sort of how most of today's software is built, but you can't build modern bridges like that.
11:35:50 <thetallguy> Cale: got it.
11:36:01 <thetallguy> thanks
11:36:22 * Botje wonders about strict vs lazy managers
11:36:53 <Cale> Today, we have mathematical models for the way that bridges work, and can adapt them to include new features, like resonances, which are found to be important, so that we have a very good idea of the way that a bridge will behave once built before the first bit of concrete is poured.
11:37:17 <sclv_> dbpatterson: you can either add that file to yr. cabal file yourself, or pull again and it should be ok.
11:37:52 <thetallguy> Yes, an important point in all scientific discussions, that good theories give you predictibility
11:38:54 <Baughn> Those theories universally work by simplifying the objects they are describing. I'm not sure you *can* simplify programs like that.. though of course, when you can it's a good idea
11:38:56 <dbpatterson> pulling (to avoid stupid merging later on).
11:39:32 <thetallguy> Jock Mackinlay used to begin his talks about his thesis work saying just that and pointing out that most research on user interfaces doesn't have anything like that yet...
11:40:03 <thetallguy> Baughn: absolutely, you can.
11:40:32 <Baughn> thetallguy: Well, I suppose that's part of what functional programming is about
11:40:49 <thetallguy> Baughn: separating tasks and making them composable
11:41:14 <thetallguy> Baughn: It doesn't mean that every program is going to be trivial to understand and/or write, as you say
11:41:23 <dbpatterson> sclv_: are your sql types Ints? (not Integers)
11:42:20 <thetallguy> Baughn: but if you can isolate each part of the complexity, establish properties about it's behavior, then compose things back together with proofs that those properties still hold, you have eliminated a lot of errors.
11:43:04 <Baughn> One of the nice things about programming is that you *can* support a ten-kilometer skyscraper with a rotten stick
11:43:18 <Baughn> ..well, that's nice until you see someone actually do it
11:43:24 <Botje> yes
11:43:33 <Botje> unlike bridges, tentacles work just fine in programming
11:43:48 <thetallguy> Baughn: and therein lies the source of the mess we are currently in...
11:44:26 <dbpatterson> sclv_: nevermind.. I wasnt Box'ing single values
11:44:36 <eugman> botje, that last sentence is such a strange one with no context
11:44:57 <gwern> in imperative programming, summoning cthulhu is well-typed?
11:45:04 <EvilTerran> @remember Botje unlike bridges, tentacles work just fine in programming
11:45:04 <lambdabot> Nice!
11:45:12 <Botje> hehe
11:45:19 <thetallguy> Did you know that in the 1920s there was a transition in the banking world?  Most people didn't trust banks to handle their money.
11:45:21 <Botje> \bot needed a tentacles quote
11:45:29 <popcorn> thetallguy: It's so cool seeing real software come out today which has correctness proofs, at least I find it really cool :D
11:45:32 <gwern> @quote tentacle
11:45:32 <lambdabot> Botje says: unlike bridges, tentacles work just fine in programming
11:46:56 <eugman> My brief exposeure to hentai makes me cring at that sentence really.
11:46:58 <thetallguy> I think we're seeing the same thing in the software world.  People (by which I mean most people) have realized the value of software, but they are also figuring out that they can't really trust the software industry implicitly.
11:47:02 <EvilTerran> OldOnes.Cthulhu.tentacles :: IO Insanity
11:47:09 <thetallguy> popcorn: agreed.
11:47:18 <Baughn> EvilTerran: No, just :: Insanity
11:47:29 <EvilTerran> iah iah import Cthulhu (Fthaghn)
11:47:29 <Baughn> I think we can be fairly certain they use unsafePerformIO. Whether or not that is safe.
11:47:35 <popcorn> hahaha
11:47:53 <shepheb> unsafePerformIO :: IO a -> Madness
11:47:57 <thetallguy> :t Just
11:47:59 <lambdabot> forall a. a -> Maybe a
11:48:46 <gwern> EvilTerran: is the iah iah import an extension?
11:49:24 <EvilTerran> yeah, it's in -fmiskatonic-exts
11:49:37 <sclv_> dbpatterson: yeah, the "Box" thing is the one ugly price I have to pay for all the nice polymorphism elsewise...
11:49:47 <Botje> kingLeonidas :: Madness -> IO !SPARTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
11:49:48 * Botje runs
11:50:27 <MyCatVerbs> (Madness -> Bool) -> IO (Bool,SPARTAAAAAAAAAA)
11:50:30 <gwern> Botje: spartans weren't unboxed. they had all that armor and helmets and shields on
11:50:31 <popcorn> I am liking how newtype is unboxed
11:50:44 <Botje> MyCatVerbs++ # nice correction :)
11:50:58 <sclv_> @remeber shepheb unsafePerformIO :: IO a -> Madness
11:50:59 <lambdabot> Good to know.
11:51:28 <eugman> is there a function to trim leading white space?
11:51:40 <int-e> dropWhile isSpace
11:51:50 <gwern> dropWhile (isSpace)?
11:51:51 <MyCatVerbs> Botje: kingLeonidas madness = declare (not madness) >>= \delareTo -> put boot (face declareTo) -- into the pit 'e goes!
11:51:56 <gwern> curse you int-e!
11:52:00 <eugman> lol
11:53:00 <thetallguy> dropTrailing = reverse . dropWhile isSpace . reverse
11:53:39 * gwern isn't really fond of the whole reverse . stuff . reverse idiom. it feels like a failing in lists
11:53:54 <glguy> defining dropTrailing with reverses makes it less lazy than it could be
11:53:57 * thetallguy agrees with gwern
11:54:19 <thetallguy> Hmm....
11:54:37 <roconnor> how could bit be less lazy?
11:54:37 <eugman> Hmmm, do I have to import something to use isSpace?
11:54:41 <dons> makes more sense on Sequence or Arrays
11:54:41 <glguy> head (dropTrailing ('a':undefined))
11:54:44 <roconnor> how could it be lesss lazy
11:54:44 <dcoutts_> glguy: though you can't be lazy since you don't know what you'll be allowed to return 'til you hit the end of the list
11:54:47 <thetallguy> Data.Char?
11:54:47 <int-e> eugman: Data.Char
11:54:59 <Baughn> More like a failing in usage. If you /need/ dropTrailing, and it matters for performance, you have the wrong data structure
11:55:03 <glguy> dcoutts_: you know that it is always safe to return non-space characters
11:55:05 <eugman> Ok, was wondering why I was getting scope errors
11:55:21 <dcoutts_> glguy: true
11:55:25 <MyCatVerbs> roconnor: have a function that takes the list twice, outputs characters from the left copy while the right isn't space.
11:55:27 <roconnor> Data.Seq \o\ \o/ /o/
11:55:38 <glguy> did you just do a wave?
11:55:47 <dbpatterson> sclv_: StringTemplate question? how to access numbered elements in a list?
11:55:50 <roconnor> yep
11:56:00 <dcoutts_> glguy: so when you hit a space you have to buffer them up til you hit the next non-space
11:56:04 <glguy> yeah
11:56:09 <MyCatVerbs> roconnor: when the right copy hits space, traverse it until a non-space is hit. If one is, then emit the characters from the left copy until you get up to the point you reached on the right.
11:56:09 <glguy> for maximum lazy!
11:56:30 <MyCatVerbs> roconnor: if the right copy runs off without finding a non-whitespace, emit [].
11:56:35 <sclv_> dbpatterson: no good way :-(
11:56:38 <gwern> Baughn: it may be that; obviously you want a lazy/undefined 'area' in a list somewhere, and syntactically, we can't do it 'to the left', so we do it to the right. although I kind of wonder about something where the *middle* is lazy
11:56:49 <gwern> a zipper? [a],a,[a]? dunno
11:56:52 <sclv_> why does the question arise?
11:57:05 <roconnor> MyCatVerbs: at the reverse thing doesn't do this?
11:57:13 * roconnor doesn't understand operational semantics :P
11:57:17 <MyCatVerbs> roconnor: not at all. The reverse thing doesn't work on infinite lists.
11:57:36 <roconnor> MyCatVerbs: oh okay
11:57:45 <roconnor> Now I understand
11:57:49 <dbpatterson> sclv_: a tuple I have, trying to pass in in a friendly way.. do maps work? (I can convert it to a named map)
11:58:01 <gwern> well, there is no last element to infinite lists, so I can't see how you could want to drop trailing whitespace in infninte lists
11:58:12 <dcoutts_> heh
11:58:20 <sclv_> (I could extend the grammar to add it, but as it stands, you just need to apply first to rest to rest to rest, etc)
11:58:25 <Baughn> Obviously, that should be a no-op on an infinite list
11:58:36 <MyCatVerbs> gwern: still causes _|_ in places where you *could* return elements.
11:58:49 <sclv_> dbpatterson: yeah, named maps work... I was thinking of ways to make working with lists friendlier too, or maybe to convert tuples to something friendlier than a list...
11:59:03 <dbpatterson> sclv_: okay, well then map it is... thanks
11:59:12 <dbpatterson> gotta go.. thanks a ton for all of this!
11:59:24 <sclv_> ok, cheers!
12:01:03 <MyCatVerbs> > let { dropTrailing f l = dth f l l; dth _ [] _ = []; dth _ _ [] = []; dth f (a:as) (b:bs) = if not (f a) then a : dth f as bs else dtt f (a:as) (b:bs) 0; dtt _ [] _ _ = []; dtt _ _ [] _ = []; dtt f aa (b:bs) n = if not (f b) then take n aa ++ dth f (drop n aa) (b:bs) else dtt f aa bs (n+1); } in dropTrailing isSpace "foo  "
12:01:05 <lambdabot>  "foo"
12:01:14 <MyCatVerbs> > let { dropTrailing f l = dth f l l; dth _ [] _ = []; dth _ _ [] = []; dth f (a:as) (b:bs) = if not (f a) then a : dth f as bs else dtt f (a:as) (b:bs) 0; dtt _ [] _ _ = []; dtt _ _ [] _ = []; dtt f aa (b:bs) n = if not (f b) then take n aa ++ dth f (drop n aa) (b:bs) else dtt f aa bs (n+1); } in dropTrailing isSpace "foo  bar baz    "
12:01:15 <lambdabot>  "foo  bar baz"
12:01:27 <MyCatVerbs> \o\ \o/ /o/ -- this calls for another wave!
12:02:06 <MyCatVerbs> I'm sure there must be a nicer way of writing that, but that's the only one I can think of. Probably it'd help to at least abuse a where close so that f doesn't have to be passed down the call stack.
12:02:29 <arussel> I am trying to reimplement filter using foldr, what is wrong:  foldr (\x y -> if even x then (:) else (\z w -> w) ) [] [1,2,3]
12:02:38 <Deewiant> > let dropTrailing p = reverse . dropWhile p . reverse in dropTrailing isSpace " foo bar baz  "
12:02:39 <lambdabot>  " foo bar baz"
12:02:51 <EvilTerran> > (\p -> foldr (\x xs -> if null xs && p x then [] else x:xs) []) isSpace "  foo  bar baz   "
12:02:53 <lambdabot>  "  foo  bar baz"
12:03:10 <MyCatVerbs> Deewiant: mine still emits text on b0rky strings. Observe:
12:03:11 <byorgey> dmwit: great!
12:03:33 <MyCatVerbs> > let { dropTrailing f l = dth f l l; dth _ [] _ = []; dth _ _ [] = []; dth f (a:as) (b:bs) = if not (f a) then a : dth f as bs else dtt f (a:as) (b:bs) 0; dtt _ [] _ _ = []; dtt _ _ [] _ = []; dtt f aa (b:bs) n = if not (f b) then take n aa ++ dth f (drop n aa) (b:bs) else dtt f aa bs (n+1); } in dropTrailing isSpace (concat . cycle $ "foo  bar baz ")
12:03:34 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
12:03:35 <Deewiant> anybody passing _|_ to such is in a state of sin anyway. ;-)
12:03:41 <popcorn> arussel: I think of it like this: foldr (\x ys -> ...) z l
12:03:41 <MyCatVerbs> ...fail.
12:03:43 <Deewiant> > fix show
12:03:45 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
12:03:52 <EvilTerran> > (\p -> foldr (\x xs -> if p x && null xs then [] else x:xs) []) isSpace ("  foo  bar baz   " ++ undefined)
12:03:53 <lambdabot>  "  foo  bar bazException: Prelude.undefined
12:03:57 <popcorn> arussel: ys are the bits of the list already processed, x is ready to -be- processed
12:03:58 <EvilTerran> that way works better
12:04:13 <MyCatVerbs> > let { dropTrailing f l = dth f l l; dth _ [] _ = []; dth _ _ [] = []; dth f (a:as) (b:bs) = if not (f a) then a : dth f as bs else dtt f (a:as) (b:bs) 0; dtt _ [] _ _ = []; dtt _ _ [] _ = []; dtt f aa (b:bs) n = if not (f b) then take n aa ++ dth f (drop n aa) (b:bs) else dtt f aa bs (n+1); } in dropTrailing isSpace ['f','f'..'f']
12:04:14 <lambdabot>  "fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff...
12:04:17 <EvilTerran> > (\p -> foldr (\x xs -> if p x && null xs then [] else x:xs) []) isSpace "  foo  bar baz   "
12:04:18 <lambdabot>  "  foo  bar baz"
12:04:18 <eugman> Does a tab get counted as a space?
12:04:24 <Deewiant> > isSpace '\t'
12:04:26 <lambdabot>  True
12:04:30 <eugman> huzzah
12:04:34 <EvilTerran> > filter isSpace [minBound..maxBound]
12:04:36 <lambdabot>  "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201...
12:04:37 <popcorn> arussel: and another tip would be start with list = foldr (\x ys -> x : ys) [] list
12:04:37 <glguy> ?check \xs -> (\p -> foldr (\x xs -> if null xs && p x then [] else x:xs) []) isSpace xs == (reverse . dropWhile isSpace . reverse $ xs)
12:04:37 <MyCatVerbs> > let dropTrailing = reverse . dropWhile isSpace . reverse in dropTrailing (repeat 'f')
12:04:40 <lambdabot>  OK, passed 500 tests.
12:04:41 <glguy> ?scheck \xs -> (\p -> foldr (\x xs -> if null xs && p x then [] else x:xs) []) isSpace xs == (reverse . dropWhile isSpace . reverse $ xs)
12:04:42 <glguy> :)
12:04:44 <lambdabot>   Completed 1957 test(s) without failure.
12:04:45 <lambdabot>  "
12:04:51 <Deewiant> EvilTerran: handy, that.
12:04:53 <glguy> i wonder if those checks have many spaces
12:04:56 <eugman> wtf is \f ?
12:05:03 <Deewiant> > ord '\f'
12:05:05 <lambdabot>  12
12:05:17 <EvilTerran> glguy, i think mine has better _|_ semantics
12:05:23 <MyCatVerbs> Deewiant: anyway. My favourite is dropTail, where dropTail n l = zipWith const l (drop n l)
12:05:26 <Deewiant> ah, right
12:05:27 <Deewiant> eugman: form feed
12:05:36 <EvilTerran> > reverse . dropWhile isSpace . reverse $ "  foo  bar baz   " ++ undefined
12:05:37 <lambdabot>  "Exception: Prelude.undefined
12:05:39 <glguy> EvilTerran: yeah, yours is the version I argued for
12:05:39 <MyCatVerbs> Or dropLast, or whatever you might wish to call it. ^_^
12:05:42 <Deewiant> heh
12:06:06 <glguy> 12 , \f , NP form feed, new page
12:06:38 <glguy> EvilTerran: you need to reverse the &&
12:06:53 <EvilTerran> sorry?
12:07:00 <eugman> Ah, that's a bit more helpful than "12"
12:07:00 <glguy> > foldr (\x xs -> if null xs && p x then [] else x:xs) []) isSpace (repeat 'a')
12:07:00 <lambdabot> Unbalanced parentheses
12:07:02 <EvilTerran> i did it both ways round, above
12:07:14 <glguy> > (\p -> foldr (\x xs -> if null xs && p x then [] else x:xs) []) isSpace (repeat 'a')
12:07:27 <glguy> > (\p -> foldr (\x xs -> if p x && null xs then [] else x:xs) []) isSpace (repeat 'a')
12:07:29 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
12:07:30 <lambdabot>  thread killed
12:07:37 <EvilTerran> that's what i did, second time round
12:07:45 <popcorn> arussel: *wondering if what I said made sense?*
12:07:47 <EvilTerran> <EvilTerran> > (\p -> foldr (\x xs -> if p x && null xs then [] else x:xs) []) isSpace ("  foo  bar baz   " ++ undefined)
12:07:49 <EvilTerran> <EvilTerran> that way works better
12:08:08 <int-e> > (\p -> foldr (\x xs -> if p x && null xs then [] else x:xs) []) isSpace (replicate 10 undefined ++ "! ")
12:08:09 <eugman> You made lambdabot scream
12:08:09 <lambdabot>  "Exception: Prelude.undefined
12:08:17 <Leimy> and kill it's thread
12:08:44 <int-e> > length $ (\p -> foldr (\x xs -> if null xs && p x then [] else x:xs) []) isSpace (replicate 10 undefined ++ "! ")
12:08:46 <lambdabot>  11
12:08:55 <arussel> popcorn: I replaced y by ys, it makes a lot of sense.
12:09:27 <arussel> popcorn: not sure it is obvious but I am looking for the same result as filter even [1,2,3]
12:09:34 <int-e> EvilTerran: that's an example where swapping the arguments of && is worthwhile - well, in fact this way you evaluate p x only when necessary.
12:09:45 <popcorn> arussel: 'y'?
12:09:53 <EvilTerran> > length $ (\p -> foldr (\x xs -> if p x && null xs then [] else x:xs) []) isSpace (replicate 10 undefined ++ "! ")
12:09:55 <lambdabot>  Exception: Prelude.undefined
12:10:13 <popcorn> my point was that like (\x xs -> is kind of misleading
12:10:14 <EvilTerran> int-e, i think my way is more generally useful, but i do see the argument for yours, yeah
12:10:18 <popcorn> so I call it (\x ys ->
12:10:42 <popcorn> you can do like, foldr (\x ys -> Cons x ys) Nil, for example
12:11:04 <int-e> EvilTerran: is it? I think testing p x no more than necessary is a good thing.
12:11:12 <arussel> popcorn: yes, that is what I understood. but for the rest, if x is even, append, if not return a function that return a  list and discard the first argument.
12:12:25 <int-e> EvilTerran: but yeah, neither version is strictly better (in terms of strictness) than the other.
12:12:52 <popcorn> arussel: you needn't actually append (++), just consing (:) will do.
12:13:00 <popcorn> [x] ++ ys = x : ys
12:15:33 <eugman> Ok, let's say I have a line like <someTag>someInformation</someTag> . What's the simplest way to return "someInformation" ?
12:15:39 <arussel> this:  "foldr ( (:) ) [] [1,2,3]" compile, this:"  foldr ( (\z w -> w) ) [] [1,2,3]" compile too, why not:  foldr (\x ys -> if even x then (:) else (\z w -> w) ) [] [1,2,3]
12:15:52 <arussel> the function is well defined and it choosed according to x
12:17:01 <shachaf> arussel: You're using the arguments, and then returning a function.
12:17:10 <popcorn> arussel: the think is that you already used up the argumets
12:17:13 <shachaf> Does (\x ys -> if even x then x : ys else ys) work?
12:17:52 <popcorn> arussel: do you know that  foldr (:) [] [1,2,3] = foldr (\x ys -> x : ys) [] [1,2,3]
12:18:29 <arussel> popcorn: I understand that.
12:18:37 <arussel> shachaf: yes it does indead
12:18:41 <byorgey> eugman: take 15 . drop 9  ;)
12:19:10 <arussel> popcorn: now I understand about ys :-)
12:19:21 <int-e> eugman: quick and dirty, takeWhile (/= '<') . tail . dropWhile (/= '>')
12:19:23 <byorgey> eugman: are you trying to write your own xml parser?
12:19:31 <arussel> shachaf, popcorn: thanks
12:19:33 <saml> what does lifting mean? can I say it is something that takes a function and and applies it in a monad?
12:19:35 <popcorn> arussel: did you get filter yet?
12:19:43 <saml> :t lift
12:19:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
12:20:01 <byorgey> saml: sure, liftM is what you said
12:20:08 <byorgey> saml: lift is for monad transformers, that's something else
12:20:18 <arussel> popcorn: yes
12:20:20 <byorgey> :t liftM
12:20:22 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:20:37 <popcorn> cool
12:20:38 <popcorn> :)
12:20:58 <byorgey> saml: liftM  takes a function  f :: a -> b  and produces a new function  liftM f :: m a -> m b
12:20:59 <arussel> arussel: that was filter without using filter :-) ex 7.8.3 from Hutton book
12:21:08 <HunterXHunter> > take 10 [1..100]
12:21:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:21:35 <HunterXHunter> > drop 10 [1..100]
12:21:36 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
12:21:40 <saml> byorgey, oh that's a nice explanation
12:21:45 <saml> :t fmap
12:21:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:22:18 <eugman> byorgey, Just something very simple for a comp lang project but yes, I'm trying to parse some xml
12:22:25 <saml> i define lifting to be an action that transforms a function into a function that transforms a context into another context
12:23:24 <tromp> @src liftM
12:23:25 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:23:41 <byorgey> saml: sure, that's a good way to think about it
12:23:59 <saml> i define functor to be a function whose domain and range are contexts
12:24:00 <byorgey> saml: and yes, fmap is another kind of lifting, it lifts functions to act on Functors
12:24:11 <tromp> @src (=<<)
12:24:11 <lambdabot> f =<< x = x >>= f
12:24:21 <saml> so, lifting is an action that transforms a function into a functor
12:24:25 <HunterXHunter> ?pl drop 10 (take 10 [1..10])
12:24:25 <lambdabot> drop 10 (take 10 [1..10])
12:24:26 <popcorn> o =<< e = e >>= o
12:24:47 <popcorn> (>>=) = flip concatMap
12:24:55 <popcorn> return = (:[])
12:24:56 <popcorn> :D
12:24:59 <MyCatVerbs> saml: loosely, but we also have lifting into monads and arrows.
12:25:04 <HunterXHunter> ?pl drop x (take x [n..m])
12:25:04 <lambdabot> drop x (take x [n..m])
12:25:10 <tromp> liftM f = (return.f =<<)
12:25:11 <byorgey> saml: hmm, I don't think that's correct.
12:25:20 <MyCatVerbs> saml: don't take anything I say as authorative, ever, though.
12:25:22 <popcorn> @pl \x -> drop x (take x [n..m])
12:25:22 <lambdabot> ap drop (flip take [n..m])
12:25:31 <HunterXHunter> ahh
12:25:53 <byorgey> saml: in a sense, the Functor is the transformation itself, the function doesn't get transformed 'into' a functor.
12:26:09 <MyCatVerbs> Maybe it's just me expressive naivete here, but in theory, no Haskell program (that doesn't use Foreign.* and unsafeFoo) shold ever cause valgrind --tool=memcheck to ever output anything under any circumstances, right?
12:26:18 <byorgey> it just gets transformed into another function, which happens to work on a Functor type.
12:27:00 <HunterXHunter> ?src ap
12:27:00 <lambdabot> ap = liftM2 id
12:27:16 <HunterXHunter> ?src liftM2
12:27:16 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:27:20 <saml> what is a functor?
12:27:50 <MyCatVerbs> saml: a couple of things, unfortunately. ;)
12:27:57 <saml> i thought functor was a closure: a function with context (environment) attached to it
12:28:11 <MyCatVerbs> saml: in category theory, it's a mapping between categories that preserves the structure.
12:28:12 <byorgey> saml: in Haskell, Functor is this typeclass:
12:28:15 <byorgey> @src Functor
12:28:16 <lambdabot> class  Functor f  where
12:28:16 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
12:28:48 <byorgey> saml: so, an instance of Functor is (1) a type constructor of kind * -> * (e.g. [], Maybe) along with (2) an implementation of fmap.
12:29:05 <popcorn> @instances Functor
12:29:06 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:29:13 <MyCatVerbs> saml: in Haskell's libraries, a Functor is a class which basically says "if you can transform a goat to a sheep then you can transform a Functor instance of goats into a Functor instance of sheepies."
12:29:27 <popcorn> :t fmap :: (a -> b) -> (e -> a) -> (e -> b)
12:29:30 <lambdabot> forall a b e. (a -> b) -> (e -> a) -> e -> b
12:29:38 <geezusfreeek> baa
12:29:43 <popcorn> saml: what you described seems like the ((->) e) functor to me
12:29:45 <byorgey> hehe, thanks =)
12:29:51 <byorgey> oops, mischan
12:29:57 * MyCatVerbs suddenly wants shepherds pie.
12:30:27 <thetallguy> Who doesn't?
12:30:41 <monochrom> I don't. I want chicken pot pie.
12:30:46 <MyCatVerbs> thetallguy: vegetarians.
12:30:50 <thetallguy> There's always room for shepherds pie.
12:31:09 <MyCatVerbs> thetallguy: and baco-vegetarians. (Like vegetarians, but acknowledging that bacon is probably worth it anyway.)
12:31:24 <thetallguy> Ground vegetarians make a reasonable substitute for the meat in shepherd's pie.
12:31:37 <byorgey> ah, right, thanks =)
12:31:39 <monochrom> Indeed.
12:31:49 * byorgey kicks self
12:31:52 * monochrom goes grind some vegetarians.
12:32:00 <thetallguy> A bit grainy and mild-flavored, but they will do in a pinch.
12:32:15 <eugman> I can't believe they put real shepherds in the pies!
12:32:30 <thetallguy> It's priest...
12:33:47 <monochrom> The best meats come from vegetarians, e.g., vegetarian cows, vegetarian sheeps and goats, and above all, vegetarians.
12:33:53 <thetallguy> And we have some shepherd's pie peppered
12:33:53 <thetallguy> With actual shepherd on top!
12:34:02 <thetallguy> http://www.lyricsondemand.com/soundtracks/s/sweeneytoddlyrics/alittlepriestlyrics.html
12:34:02 <lambdabot> Title: Sweeney Todd - A Little Priest Lyrics - A Little Priest - Lyrics On Demand, http://tinyurl.com/2hctxy
12:34:48 <sieni> my ex-wife was a lacto-ovo-sausago-vegetarian
12:35:25 <eugman> Lol. Vegetarian meal with just a bit of an omlet thown in?
12:37:02 <eugman> Oh, how am I suppose to modify a variable in a do loop? I want to run a bunch of functions on it before it gets outputed back out but I don't want a massive nest of them all on the output line.
12:37:35 <eugman> I tried declaring a new one with "=" but that doesn't seem to work.
12:38:03 <byorgey> eugman: you can use 'let'
12:38:22 <HunterXHunter> let f x = y
12:38:37 <byorgey> do var <- action ; let { var2 = func var1 ; var3 = func var2 } ; return var3  -- for example
12:38:39 <eugman> ah, right
12:38:49 <byorgey> but in that case you might as well just say:
12:38:50 <yitz> eugman: you can declare a variable with let and give it a value. but you can't modify it.
12:39:08 <byorgey> do var <- action ; return $ (func2 . func1) var
12:39:31 <eugman> yitz, that's fine, I basically want to have intermediate stages before I pass on the variable to output so the code looks cleaner
12:39:38 <byorgey> which is the same as  action >>= return . (func2 . func1)
12:39:49 <byorgey> which is the same as  liftM (func2 . func1) action  =)
12:48:58 * byorgey bakes some focaccia lambdas
12:50:08 * Baughn bakes some pancakes. Yummier.
12:50:47 <byorgey> especially if they are not metaphorical pancakes!
12:50:51 <monochrom> Shepherd Pie with Lambda and Spam! Fish and Chips with Lambda and Spam! Pancakes with Lambda and Spam! ...
12:51:17 <Baughn> byorgey: Well, I'm not sure they /are/ pancakes at all. I don't normally add baking soda, but this time...
12:51:37 <byorgey> \spam -> replicate 40 spam ++ ["lambda", spam]
12:51:54 <byorgey> Baughn: hehe
12:52:16 * Baughn experiments, and the siblings had better eat.
12:52:38 <byorgey> I like adding a little baking soda, sugar, and lemon juice.
12:52:50 <byorgey> nice and fluffy
12:53:37 <Baughn> Oh, good idea
12:53:41 <Baughn> How much lemon juice?
12:53:48 <byorgey> not much
12:54:02 <byorgey> like a tablespoon or so
12:54:12 <byorgey> depends on how much batter you are making =)
12:54:20 <Beelsebob> why did I read that as lesbian juice?
12:54:21 <flazz> j #erlang
12:54:24 <Beelsebob> >.<
12:54:37 <byorgey> Beelsebob: I... don't know.
12:54:37 <geezusfreeek> :o
12:55:00 <monochrom> because you have auto-completion in your brain
12:55:04 <Baughn> Beelsebob: It might trip you up
12:55:16 <Beelsebob> hehe
12:55:20 <Beelsebob> good answer monochrom
12:57:18 <dmwit> ?quote monochron
12:57:18 <lambdabot> monochron says:  "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
12:57:31 <dmwit> monochrom: Was that you?  (I'll fix the quote if it was. =)
12:57:33 <JokerDoom> lambdabot, ha
12:57:41 <Japsu> @quote surround
12:57:41 <lambdabot> No quotes match.
12:57:43 <monochrom> It was me. Thanks.
12:57:43 <Japsu> :<
12:57:51 <dmwit> ?help quote-
12:57:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:57:54 <dmwit> ?help forget
12:57:54 <lambdabot> forget nick quote.  Delete a quote
12:58:10 <dmwit> ?forget monochron Welcome to #haskell, where your questions are answered in contrapuntal fugues.
12:58:11 <lambdabot> No match.
12:58:24 <dmwit> ?forget monochron  "Welcome to #haskell, where your questions are answered in contrapuntal fugues."
12:58:24 <lambdabot> Done.
12:58:40 <dmwit> ?remember monochrom Welcome to #haskell, where your questions are answered in contrapuntal fugues.
12:58:41 <lambdabot> It is forever etched in my memory.
12:58:53 <dmwit> yay!
13:01:54 <byorgey> If I wanted to create a simple web page for my diagrams library (with links, a tutorial, etc.) what would be my best bet in terms of hosting?
13:02:01 <byorgey> the wiki?
13:02:28 <byorgey> or is there some server with space specifically for hosting web pages for haskell projects?
13:04:02 <eugman> Heh, there's always google pages but I doubt it's what you are looking for.
13:04:47 <byorgey> hehe, not really =)
13:05:07 <Saizan> community/code.haskell.org ?
13:08:31 <byorgey> yeah, I guess I can just put it in my home directory on code.haskell.org or something
13:11:30 <byorgey> ah, even better, I'll create the web page as part of the darcs repo itself!  That way you can do a darcs pull from c.h.o/diagrams, but if you visit it with your web browser you get the website =)
13:15:59 <quicksilver> byorgey: the haskell wiki.
13:16:04 <quicksilver> byorgey: (is the other option)
13:16:12 <quicksilver> of course if your content isn't suitable for a wiki then it's the wrong one.
13:17:17 <byorgey> quicksilver: yeah, I'd thought of that too.  It would probably work fine, just a bit clunky.
13:17:25 <conal> quicksilver: did you get anywhere with opengl FBOs?
13:18:26 <quicksilver> conal: No. I decided that copyTexImage was probably good enough for me.
13:18:42 <quicksilver> conal: because one of my target machines only has a radeon 9250
13:18:49 <quicksilver> conal: which doesn't have EXT_framebuffer_object anyway
13:19:23 <underscore> Does anyone know how to get the processor ID that the current thread's running on? It's fine if it doesn't remain static for the thread lifetime.
13:19:28 <conal> quicksilver: oh, okay.  does copyTexImage have a significant perf loss (assuming EXT_framebuffer_object)?
13:19:48 <conal> quicksilver: or quality?
13:19:53 <underscore> Alternately: any suggestions for generating process-unique integers with little to no contention in the presence of multiple cores?
13:20:35 <dmwit> I think there's an RFC on that.
13:21:01 <dmwit> What I remember is that it's not that rigorous, though.
13:21:24 <monochrom> underscore: does http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cpuid help?
13:22:18 <quicksilver> conal: not quality. Although it's a bit fiddly.
13:22:47 <quicksilver> conal: the fiddly part is arrange to get 1-1 pixels, if that's what you want.
13:22:58 <quicksilver> and coping with a texture a different shape from your back buffer
13:23:26 <quicksilver> underscore: is threadID not useful to you?
13:23:32 <quicksilver> underscore: I don't quite understand what you're after :)
13:23:41 <conal> quicksilver: got it. thx.
13:23:52 <quicksilver> conal: I haven't measured the performance difference
13:23:58 <quicksilver> the ##opengl people seemed to think there was one
13:24:12 <underscore> Looking at the cpuid stuff-- that could be useful, but I can't seem to work out how to get the core currently executing the thread.
13:24:16 <quicksilver> I got distracted by a universal parameter tuning toolkit with a ridiculous steampunk UI
13:25:04 <underscore> threadID isn't handy for this because the IDs are meant for objects that can be accessed by multiple threads-- and I think that threadIDs get recycled (?)
13:25:56 <tromp> :t liftM
13:25:59 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:27:36 <tromp> :t (=<<).(return.)
13:27:38 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> a1) -> m a -> m a1
13:27:42 <underscore> I could get the effect I want by storing a long in an MVar and incrementing it on access, but this would introduce a bottleneck I'd prefer to avoid. (I need to get new IDs from many different threads fairly often.)
13:29:03 <Leimy> I was reading what looked like an older paper on concurrent haskell
13:29:12 <tromp> GHCi complains when i say  let mylift = (=<<).(return.)
13:29:35 <Leimy> It looked like they were going to introduce mutable types into the system... but then I lost my link to the paper.
13:29:37 <wjt> @unpl (=<<) . (return .)
13:29:38 <lambdabot> (\ d g -> g >>= \ j -> return (d j))
13:29:56 <Leimy> can someone point me back at the paper and/or confirm deny the concurrent haskell mutable state idea I have? :-)
13:30:12 <Leimy> I was hoping it'd be more erlang-like in it's model.
13:31:08 <wjt> tromp: if you   let mylift d g = g >>= (return . d)   , does it stop complaining?  I think the monomorphism restriction may be biting you.
13:31:25 <tromp> let mylift f = (return.f =<<)       is fine
13:31:27 <wjt> tromp: incidentally, i think you have just reinvented fmap
13:31:46 <tromp> but not   let mylift = (=<<).(return.)
13:32:03 <wjt> > ((=<<) . (return .))  (+1) [1,2,3]
13:32:06 <lambdabot>  [2,3,4]
13:32:09 <wjt> > (+1) `fmap` [1..3]
13:32:11 <lambdabot>  [2,3,4]
13:32:20 <tromp> ghci is also happy with  :t (=<<).(return.)
13:32:32 <popcorn> I'm not
13:32:39 <popcorn> what's that supposed to do :?
13:32:53 <popcorn> weird kind of map
13:32:58 <tromp> @src fmap
13:32:59 <lambdabot> Source not found. You type like i drive.
13:33:03 <wjt> @src [] fmap
13:33:04 <lambdabot> fmap = map
13:33:04 <gwern> 'The system was very powerful and flexible.[i] Unfortunately, it was so powerful that it was inconsistent' <-- oops
13:33:07 <wjt> @src IO fmap
13:33:07 <lambdabot> fmap f x = x >>= (return . f)
13:33:52 <tromp> @pl fmap f x = x >>= (return . f)
13:33:52 <lambdabot> fmap = fmap
13:34:06 <wjt> heh, heh.
13:36:43 <yitz> @pl \ f x -> x >>= (return . f)
13:36:43 <lambdabot> fmap
13:37:04 <yitz> (=<<) . (return .)
13:38:38 <dmwit> gwern: heh
13:38:43 <Trinithis> @pl (=<<) . (return .)
13:38:43 <lambdabot> fmap
13:39:05 <dmwit> For example:
13:39:18 <dmwit> (getLine >>= return . read) :: Read a => a
13:39:21 <dmwit> ...
13:39:23 <dmwit> (getLine >>= return . read) :: Read a => IO a
13:39:52 <dmwit> (But it really is nicer to write this as liftM read getLine or fmap read getLine or ever readLn.)
13:41:37 <zgold> @src readFile
13:41:37 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
13:49:31 <underscore> Is there a higher-precision counter than what's in System.CPUTime?
13:50:19 <underscore> Ideally I'd like to (on x86 at least) RDTSC.
13:53:10 <underscore> http://uebb.cs.tu-berlin.de/~magr/projects/rdtsc/doc/ looks good, but is there something in the standard library?
13:53:34 <sieni> perhaps you can just do an rdtsc?
13:57:07 <underscore> That's the goal
13:57:39 <underscore> But since I don't think I can inline assembler, I have to delegate to someone else
13:58:15 <dons> rdtsc is on hackage
13:58:26 <dons> you could also call into C to measure things
13:58:30 <underscore> Just got it installed
13:58:35 <dons> i'd just use rdtsc though
13:58:37 <dons> it works quite well
14:03:03 <gwern> 'In this and several other ways, backtracking proved unwieldy helping to fuel the great control structure debate. Hewitt investigated some preliminary alternatives in his thesis. Using program schemas, Hewitt in collaboration with Mike Paterson proved that recursion is more powerful than iteration and parallelism more powerful than sequential recursion [Patterson and Hewitt 1970].'
14:04:03 * gwern wonders whether http://logicprogramminghistory.wikicensored.info/ is full of shit, or whether I'm just misunderstanding it
14:04:09 <popcorn> it's full of shit
14:04:18 <gwern> glguy: a fellow a while ago was wondering where the repo for hpaste 2 is, btw
14:04:35 <dons> code.haskell.org
14:05:30 <gwern> hpaste.git?
14:05:34 <glguy> yes
14:05:54 <glguy> I actually installed it on a RHEnterpriseLinux5 box yesterday
14:06:01 <cnwdup> Ok, so now I got it how to call a IO () from inside a monad (http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html), but, as I am using GTK+'s timeoutAdd, I have to maintain and update the IORef during all my program which means I have to write my own monad that consequently updates the state as well as the IORef when >> and >>= is used?
14:06:02 <lambdabot> http://tinyurl.com/6zdyv3
14:06:07 <glguy> so I should be able to put enough modern software on code. to install it there
14:06:11 <popcorn> http://alain.colmerauer.free.fr/ArchivesPublications/HistoireProlog/19november92.pdf && http://citeseer.ist.psu.edu/vanroy93wonder.html
14:06:13 <lambdabot> http://tinyurl.com/5rh869
14:06:21 <popcorn> There's good stuff about logic programming :)
14:06:24 <dons> glguy is snarky under the radar
14:06:27 <popcorn> (history)
14:07:11 <dmwit> > length "functional" - length "f'nal"
14:07:12 <lambdabot>  5
14:07:23 <gwern> glguy: out of curisotiy, why git?
14:07:34 <glguy> gwern: it is generally better than darcs
14:07:39 <glguy> and I use it at work
14:07:48 <glguy> so I didn't watch to have to switch back and forth
14:08:35 <gwern> ah, work
14:08:56 <dons> got you some darcs 2.0 koolaid yet, glguy ? its refreshing!
14:12:12 <Leimy> dons: darcs 2.0 is definitely ftw
14:12:25 <glguy> darcs 2.0 has the same work-flow as darcs 1.0
14:12:50 <Leimy> I'm seeing good things about hg too
14:12:50 <dons> the work flow of awesomeness?
14:12:53 <Leimy> but haven't tried it yet
14:12:56 <glguy> dons: nope, not that one
14:12:59 <sieni> does darcs have similar patch management functionality as mercurial queues?
14:13:02 <dons> the work flow of no rebase?
14:13:12 <glguy> dons: the one branch per child
14:13:15 <eugman> Hmm, is there a inline way to make a function that sends the input to a different function and compares the output to a set value? Kinda like (y==(someFunc x)) but it returns a function I can use with an any?
14:13:22 <glguy> OBPC
14:13:26 <glguy> no thanks
14:13:28 <dons> oh, you've been seduced by branches eh?
14:13:40 <glguy> senseless destruction of data?
14:13:44 <glguy> immutable commits please
14:13:48 <dons> hah
14:13:56 <dons> yeah, cause amend-record is messing up your life?
14:14:49 <glguy> Haskell programmers of all people should appreciate git's immutable objects
14:14:58 <glguy> ability to revert to previous states easily
14:15:04 <dons> its nice, but swimming in a sea of verbosity
14:15:34 <glguy> who wants power and flexibility when you can have limitations and danger?
14:15:48 <dons> simple, orthogonal primitives, versus a pile of chainsaws
14:15:58 <glguy> simple, restricted, primitives
14:16:05 <Leimy> I certainly don't get git.
14:16:08 <glguy> with timebombs
14:16:11 <Leimy> nor do I think I ever will
14:16:11 <dons> back to C programming for glguy
14:16:21 * Cale doesn't understand what this conversation is referring to.
14:16:22 <glguy> darcs is more C
14:16:26 <dons> i've not had a single issue in 4 weeks of darcs 2.0, fwiw
14:16:31 <Leimy> Cale: religion
14:16:37 <dons> no merge issues, which is refreshing
14:16:40 <eugman> Oh wait, I can just use a lambda function, whoops
14:16:46 <dons> no repo messiness on timeouts/^C network issues
14:17:10 <mm_freak> dons: did you receive my quote?  the docs say that hGetContents silently ignores errors and finishes the list and closes the handle instead
14:17:11 <pejo> dons, is 2.0 stable?
14:17:22 <dons> well, i'm on the verge of declaring it so, yes.
14:17:42 <dons> i've been using it for ghc, xmonad, all my projects since early april, and not one issue yet
14:17:46 <Leimy> dons: I like darcs but did Roundy ever finish his bridge game? :-)
14:17:48 <dons> it just works.
14:18:02 <dons> so its a good line in the sand
14:18:05 <gwern> yay, Takusen doesn't compile -_-
14:18:08 <gwern> Leimy: I heard he never did
14:18:25 <Leimy> gwern: oh well, I think darcs was a worthwhile distraction :-)
14:18:42 <dons> glguy: you'll need to reconsider your view of darcs in light of the 2.0 release. Most of your concerns appear to be addressed.
14:18:51 <gwern> Leimy: indeed. we've all benefitted
14:18:58 <dons> glguy: i might see if we can break it , and we could cover it in the dev symposia
14:19:19 <glguy> dons: darcs 2.0 has the same work flow as darcs 1.0 - bugs as far as I can tell
14:19:21 <glguy> which means its own
14:19:23 <glguy> out*
14:19:27 <dons> bugs?
14:19:30 <glguy> minus
14:19:39 <dons> sure, but that's a completely different issue.
14:19:40 <Cale> What's wrong with darcs' work flow?
14:19:53 <dons> you may not like the branch idea, others see that as a strength. reasonable people can disagreeeeeee
14:20:10 <Cale> eee
14:20:14 <dons> the core complaints of stability, safety are addressed well now, it seems
14:20:27 <dons> so, that's a good thing.
14:20:36 <glguy> anyway, I didn't bring darcs up in the first place
14:20:47 <glguy> you are welcome to continue using it for your projects
14:20:59 <dons> no, i was just wondering if you'd tried 2.0 at all
14:21:05 * gwern did :)
14:21:15 <dons> yeah, i was starting to move things to git, but that process has stopped with 2.0
14:21:25 <dons> i've gone back to darcs for personal stuff
14:21:32 <glguy> surprise!
14:21:33 <glguy> ;)
14:21:50 <dons> hey, i spent a lot of time sorting out darcs<->git interop issues
14:22:38 <popcorn> @hoogle STRef
14:22:38 <lambdabot> Data.STRef :: module
14:22:38 <lambdabot> Data.STRef.STRef :: data STRef s a
14:22:38 <lambdabot> Data.STRef.Lazy.STRef :: data STRef s a
14:26:23 <gwern> oh dear... Takusen has the Setup.hs from hell
14:26:31 <dons> gwern: don't go there.
14:26:43 <gwern> eh?
14:26:57 <dons> don't jump!
14:27:14 <gwern> but... but hpaste2 needs it!
14:27:28 <dons> are you trying to build hpaste locally?
14:27:39 <dons> or are you trying to upload it to hackage?
14:27:40 <dcoutts> gwern: heh, yes, tell me about it
14:27:43 <gwern> yes
14:27:48 <dons> former or later?
14:28:00 <popcorn> :index ST
14:28:02 <dcoutts> it's the only Setup.hs that is impossible to support in Cabal-1.4
14:28:03 <popcorn> @index ST
14:28:03 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
14:28:05 <gwern> neither former nor latter
14:28:20 <hkBst> how would one side-effect on definition of functions, to collect them into a list for example in Haskell? (like the following Guile source http://hpaste.org/7483 does for a class)
14:28:21 <astrolabe> Is there an easy way for me to get the parsec package on ubuntu?
14:28:27 <gwern> dcoutts: what's so bad about it? I've hit the missing 'writeHookedBuildInfo' error, but that seems simple
14:28:30 <dons> astrolabe: install it from hackage?
14:28:34 <dcoutts> gwern: they also do some highly evil stuff
14:28:36 <glguy> takusen installed flawlessly for me from hackage
14:28:41 <dons> hkBst: ?
14:28:51 <dons> :t [ (+1), (*2) ]
14:28:53 <lambdabot> forall a. (Num a) => [a -> a]
14:28:56 <dcoutts> gwern: like changing the package definition in Setup.hs
14:28:58 <dons> > map ($ 7) [ (+1), (*2) ]
14:29:00 <lambdabot>  [8,14]
14:29:02 <gwern> glguy: using non 6.8 I'd wager?
14:29:02 <Saizan> astrolabe: do you use ghc form ubuntu? there should be a package for parsec in that case
14:29:06 <popcorn> what's the difference between ST and StateT?
14:29:13 <astrolabe> dons: thanks.
14:29:21 <glguy> gwern: 6.8.2
14:29:27 <dcoutts> gwern: it should work with 6.8 with Cabal-1.2.x
14:29:30 <gwern> 'One install script to rule them all, and in the darkness build them...' <-- comments like these are always a bad sign
14:29:38 <gwern> hm. maybe the problem is too modern cabals installed
14:29:46 <astrolabe> Saizan: Yes I do, but I can't see parsec using ghc-pkg list
14:29:56 <dcoutts> gwern: and it copies gobs of code out of Cabal rather than just calling stuff
14:30:14 <dcoutts> which means it uses a much wider interface in the Cabal lib
14:30:57 <gwern> uh oh. 'cabal-version:  ==1.2.3.0' didn't seem to help
14:31:18 <dons> dcoutts: did andyjgill ask you about tags in version numbers?
14:31:31 <Saizan> astrolabe: install libghc6-parsec-dev from apt
14:31:32 <dcoutts> dons: nope
14:31:34 <dons> is "1.2.3-unstable" > "1.2.3" ?
14:31:42 <gwern> dcoutts: fun. so what do the takusen devs plan to do about it?
14:31:49 <dons> or are they not kosher at all
14:31:53 <andyjgill> I wanted to know a good way of having a tag on a local development version of a package.
14:32:01 <andyjgill> I was using 0.X-dev
14:32:15 <dcoutts> andyjgill: it's easier just to append a date
14:32:28 <andyjgill> Thats what dons said.
14:32:45 <dcoutts> andyjgill: the current situation is confused, the == does not agree with `compare`
14:32:55 <andyjgill> Can you say more?
14:32:57 <dcoutts> andyjgill: == requires the set of tags be equal
14:33:09 <dcoutts> `compare` ignores tags completely
14:33:12 <hkBst> dons: it isn't so nice anymore if you use names for your functions
14:33:16 <astrolabe> Saizan: Thanks very much.  Could you tell me how you knew where to look?
14:33:28 <gwern> the goggles, they do nothing!
14:33:37 <dons> > map ($ 'x') [ord, ord, ord] -- ?
14:33:38 <lambdabot>  [120,120,120]
14:33:42 * gwern concedes defeat; not someting I want to tangle with today
14:34:02 * dons is relieved. back from the edge, gwern 
14:34:09 <dcoutts> andyjgill: my opinion is that tags have no meaning, they should be carried around but not considered for Eq/Ord
14:34:22 <Saizan> astrolabe: well, i think i saw the libghc6* packages when searching for ghc the first time
14:34:30 <andyjgill> dcoutts: oh, okay.
14:34:51 <dcoutts> andyjgill: a bit like case sensitivity, case preserving but case insensitive
14:34:51 <astrolabe> Saizan: Thanks.
14:34:59 <cpoucet> dcoutts: been thinking..
14:35:09 <cpoucet> dcoutts: you free to discuss a bit?
14:35:13 <dcoutts> cpoucet: sure
14:35:15 <astrolabe> @karma+ Saizan
14:35:15 <lambdabot> Saizan's karma raised to 7.
14:35:43 <cpoucet> dcoutts: well a thought occurred to me in regards with the cache.  Since we'd be providing a pure interface we would in essence break referential transparency.
14:35:53 <hkBst> dons: I don't want to construct a list of functions. I want to define functions in a special way and have them put into a list without having to worry about it. So I don't have to compare the list with the function definitions to see if there is anything missing...
14:36:02 <cpoucet> dcoutts: unles only pure functions are cached
14:36:04 <MyCatVerbs> cpoucet: nahhh. Lazy evaluation already provides cacheing of thunks.
14:36:18 <MyCatVerbs> (Effectively, anyway.)
14:36:19 <dons> hkBst: oh, you'll need template haskell for that, most likely
14:36:25 <cpoucet> dcoutts: but extending the concept to, for instance, io-caching, would be very intereesting, but there it would break.
14:36:37 <cpoucet> MyCatVerbs: the idea is do caching with cache-eviction
14:36:43 <cpoucet> s/do/to do
14:36:49 <hkBst> dons: what's the best place to start learning about that?
14:36:57 <dcoutts> cpoucet: right I was only thinking of caching/memoising pure functions
14:37:08 <cpoucet> dcoutts: btw, ccshan referred me to a paper
14:37:14 <cpoucet> dcoutts: have an email so I can foward?
14:37:26 <dons> hkBst: the HTF package on hackage doe shtis
14:37:29 <dcoutts> cpoucet: duncan at haskell.org
14:37:59 <dcoutts> cpoucet: so with io stuff you need to know when returned values get out dated and have to be recalculated
14:38:56 <sheyll> hi!
14:39:28 <sheyll> I was wondering how to do pattern matching in haskell, I am used to erlang.
14:40:02 <eugman> Am I correct in my observation in that haskell requires diminshing effort? It seems to take much effort to think up and put downt he first few lines of code and after a while, tossing on features is quite simple.
14:40:20 <sheyll> I would like to match a string starting with something like i.e. "https"
14:40:37 <monochrom> Oh, that one will look ugly.
14:40:42 <Zao> :t Data.List.isPrefixOf
14:40:44 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:40:51 <sheyll> ahh thx!
14:40:53 <dons> > "https" `isPrefixOf` "https://google.com"
14:40:54 <lambdabot>  True
14:40:55 <lambdabot> Title: Google
14:40:55 <monochrom> f 'h':'t':'t':'p':'s':_ = ...
14:40:57 <dons> > "https" `isPrefixOf` "http://google.com"
14:40:58 <lambdabot>  False
14:40:58 <lambdabot> Title: Google
14:41:05 <cpoucet> foo str | "https" `isPrefixOf` str = ...
14:41:19 <cpoucet>         | otherwise  = ....
14:41:20 <sheyll> why does this not work:  case "https:sdf" of ("https:":) -> False; _ -> True;
14:41:30 <cpoucet> sheyll: that is a list of strings
14:41:31 <monochrom> It is defined to not work.
14:41:34 <dons> eugman: it gets really easy, yeah, to through together code
14:41:37 <Valodim> : doesn't work for two lists
14:41:44 <dons> eventually you stop using pseudocode, and just write down haskell directly
14:41:46 <cpoucet> not to mention you can't patternmatch on somthing without a tail
14:41:47 <Valodim> element:list, not list:list
14:41:50 <sheyll> thanx!
14:41:51 <dons> since it becomes how you think about computation
14:42:02 <dons> ?src []
14:42:02 <lambdabot> data [] a = [] | a : [a]
14:42:03 <roconnor> If only we had views...
14:42:15 <sheyll> yes you are so right...
14:42:19 <popcorn> yeah ST is hard to use /
14:42:19 <dons> would our lives be a lot simpler, roconnor ?
14:42:22 <sheyll> in erlang this is diffrent
14:42:37 <cpoucet> sheyll: you -can- do it, but it' ugly
14:42:51 <cpoucet> I wonder if this could easily be solved with quasiquoting ...
14:42:51 <popcorn> > case "https:sdf" of ("https:":_) -> False; _ -> True;
14:42:52 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
14:43:01 * dons notes Sequence has a bunch of ViewL/ViewR stuff
14:43:10 <popcorn> > case "https:sdf" of ('h':'t':'t':'p':'s':':':_) -> False; _ -> True;
14:43:11 <roconnor> dons: then we could write foo ("https"++rest) = blah
14:43:12 <lambdabot>  False
14:43:13 <cpoucet> dons: tht's a pain
14:43:18 <popcorn> > case "httxs:sdf" of ('h':'t':'t':'p':'s':':':_) -> False; _ -> True;
14:43:19 <lambdabot>  True
14:43:30 <popcorn> @hoogle prefixOf
14:43:31 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
14:43:31 <lambdabot> Data.ByteString.isPrefixOf :: ByteString -> ByteString -> Bool
14:43:31 <lambdabot> Data.ByteString.Char8.isPrefixOf :: ByteString -> ByteString -> Bool
14:43:38 <cpoucet> dons: afaik, viewL is still per-element
14:43:48 <popcorn> > not ("https:" `prefixOf` "https:sdf")
14:43:48 <lambdabot>   Not in scope: `prefixOf'
14:43:52 <popcorn> :/
14:43:56 <cpoucet> isPrefixO
14:43:58 <cpoucet> f
14:44:04 <popcorn> > not ("https:" `isPrefixOf` "https:sdf")
14:44:05 <lambdabot>  False
14:44:06 <popcorn> thanks
14:44:09 <popcorn> > not ("https:" `isPrefixOf` "httxs:sdf")
14:44:10 <lambdabot>  True
14:44:12 <dons> | Just [_,s1] <- match "http://(.*)/$/" url = s1
14:44:18 <dons> pattern guards forever!
14:44:29 <sheyll> dons: wow
14:44:32 <JokerDoom> match does RegExps in Haskell?
14:44:37 <sheyll> :O
14:44:43 <dons> JokerDoom: its from one of  the regex libraries, yeah
14:44:45 * JokerDoom is a major Haskell newb, be gentle
14:44:56 <sheyll> haskell can use regexes in patterns
14:45:10 <dons> in pattern guards, the patterns with <- in them
14:45:14 <Botje> the faster your brain blows, the faster we can get at the gooey insides!
14:45:22 <Leimy> pattern guards ftw!
14:45:51 <cpoucet> patterns guards are in already?
14:45:59 <dons> for the last 15 years, yeah
14:46:13 <cpoucet> oh wat, I was confusing this with monadic patterns
14:46:13 <Leimy> 15 years ftw!
14:46:27 <Saizan> @remember Botje the faster your brain blows, the faster we can get at the gooey insides!
14:46:27 <lambdabot> Done.
14:46:31 <sheyll> dons: pls could you tell me where I can use pattern matching in haskell?
14:46:46 <cpoucet> > case "foo" of _ | Just [_, s1] <- match "fo" = s1
14:46:47 <lambdabot>  Parse error at "<-" (column 32)
14:46:55 <awesame> my thoughts after reading the haskell-prime list for a couple weeks: http://www.hackerdashery.com/2008/05/terrible-legacy-of-legacy.html
14:46:56 <lambdabot> Title: hackerdashery: The Terrible Legacy of Legacy, http://tinyurl.com/5z6euv
14:47:00 <cpoucet> dons: eh?
14:47:04 <popcorn> can I implement STRefs efficiently in StateT?
14:47:09 <popcorn> using like Data.Map?
14:47:10 <cpoucet> dons: not the one you just presented
14:47:37 <dons> yeah, those ones.
14:47:43 <dons> since 97
14:47:45 <cpoucet> dons: doesn't seem to work
14:47:59 <roconnor> question about fusion: http://hpaste.org/7485
14:48:11 <cpoucet> > case "foo" of x | Just [_, s1] <- match "fo" x -> s1
14:48:12 <lambdabot>  Parse error at "<-" (column 32)
14:48:17 <hkBst> dons: template Haskell is like CL macros?
14:48:17 <monochrom> 2008-1997 /= 15
14:48:23 <Lord_Illidan> Can someone give me a hint with this please : http://hpaste.org/7484
14:48:27 <roconnor> basically does foldMap fuse better than foldr?
14:48:43 <Lord_Illidan> Basically, it's supposed to only take Logo, with no arguments
14:48:47 <dons> $ echo "http://google.com/" | ./A
14:48:47 <dons> Just "google.com"
14:48:47 <lambdabot> Title: Google
14:49:00 <Vulpyne> Someone's a WoW player. :P
14:49:00 <sheyll>  cpoucet: sorry I don't get it: could you explain case "foo" of x | Just [_, s1] <- match "fo" x -> s1
14:49:06 <dons> http://hpaste.org/7486
14:49:18 <cpoucet> dons: interesting
14:49:18 <dons> ^ regular expressions, perl-compat regexes, pattern guards
14:49:22 <Vulpyne> Lord_Illidan: What do you want to know about that specificially?
14:49:26 <cpoucet> ah, extension :)
14:49:36 <cpoucet> neat
14:49:37 <dons> they're on by default
14:49:40 <cpoucet> you learn something new every day
14:49:43 <dons> you get a warning if you don't turn on the flag
14:49:47 <sheyll> don: what does {-# LANGUAGE PatternGuards #-}
14:49:52 <sheyll> mean?
14:49:55 <Lord_Illidan> I have no idea how you're supposed to implement a recursive function with no arguments
14:50:00 <dons> sheyll: it turns on the PatternGuards syntax
14:50:09 <Lord_Illidan> how would you stop it?
14:50:21 <dons> > fix  (1:) -- lazily?
14:50:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:50:26 <Vulpyne> lord: I didn't see anything about that in your hpaste. Are you sure you gave the right hpaste link?
14:50:28 <dons> > take 5 $ fix  (1:) -- lazily?
14:50:29 <lambdabot>  [1,1,1,1,1]
14:50:38 <roconnor> Lord_Illidan: since the result is generated lazily, all you have to do is not use it all.
14:50:55 <roconnor> Lord_Illidan: if no more is demanded, no more will be computed.
14:50:55 <Lord_Illidan> I'll edit it a bit
14:51:32 <roconnor> dons: do you have an expert opinion about: http://hpaste.org/7485
14:51:48 <monochrom> I don't see anything wrong in the code Lord_Illidan pasted.
14:52:21 <Lord_Illidan> http://hpaste.org/7484#a1
14:52:31 <Lord_Illidan> I edited it a bit so you can see what I'm talking about
14:52:32 <dons> roconnor: partitionEithers will fuse when implemented as foldr
14:52:40 <dons> where's foldMap defined?
14:53:01 <Vulpyne> Lord_Illidan: Ahh... Well, recursion will be halted when size >= 300.
14:53:08 <roconnor> dons: it's Conor's traversable stuff
14:53:09 <Lord_Illidan> Yes, Vulpyne
14:53:12 <roconnor> @hoogle foldMap
14:53:13 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
14:53:13 <lambdabot> Data.Traversable.foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
14:53:16 <Lord_Illidan> The first is my original code
14:53:20 <Lord_Illidan> I know it works, heh :D
14:53:22 <dons> that stuff isn't build/foldr friendly, is it?
14:53:32 <dons> unless its defined in terms of build or GHC.Base. foldr,
14:53:32 <monochrom> repeatLogo will do the recursion for you. You don't have to worry about it.
14:53:35 <Lord_Illidan> The second is my miserable failure at trying to satisfy the demands
14:53:47 <Lord_Illidan> because the way it is now, it's only doing a circle
14:53:48 <Vulpyne> Ah, I guess I don't have the context to evaluate your question.
14:53:50 <roconnor> dons: rumour has it that it is, but I don't have confirmation.
14:53:51 <Vulpyne> I just looked at the hpaste.
14:53:58 <Lord_Illidan> I need the value of forward to change
14:54:04 <Lord_Illidan> every time it is doing the repeat
14:54:09 <monochrom> I don't think anyone has the complete context anyway.
14:54:23 <Lord_Illidan> Well
14:54:40 <Lord_Illidan> I'm trying to make a spiral
14:55:00 <Lord_Illidan> now, the way I understand a spiral, in logo context is
14:55:05 <dons> roconnor: foldMap f = foldr (mappend . f) mempty
14:55:20 <dons> so looks good -- *if* it gets inlined (they might not have paid attention to that, so check)
14:55:28 <roconnor> spiralLogo2   = Forward 100 :> Turn 10 :> spiralLogo2
14:55:34 <roconnor> ?
14:55:45 <Lord_Illidan> rconnor, but how would that stop?
14:55:53 <Lord_Illidan> how do you even define a base case?
14:55:54 <roconnor> dons: is the foldMap version better?
14:55:59 <Vulpyne> It wouldn't, it would generate an infinite spiral.
14:56:04 <Lord_Illidan> It doesn't
14:56:07 <Lord_Illidan> it's a circle
14:56:09 <roconnor> Lord_Illidan: it wouldn't stop
14:56:14 <popcorn> is your logo interpreter lazy?
14:56:15 <sheyll> another question, why does the following code not compile: http://hpaste.org/7487
14:56:22 <monochrom> Do you want it to stop?
14:56:28 <Lord_Illidan> monochrom, yes..
14:56:32 <popcorn> sheyll: I think it's the semicolons
14:56:42 <monochrom> What should trigger it to stop?
14:56:42 <popcorn> also you can't bind the same variable twice
14:56:44 <roconnor> Lord_Illidan: but if you tell Logo to only consume a finite number of logo commands, then it will stop.
14:56:53 <popcorn> haskell doesn't have logic variables like that
14:57:00 <sheyll> popcorn i will try, thx
14:57:13 <popcorn> so you write instead
14:57:17 <Lord_Illidan> roconnor, nope..I tried what you said, and it did an infinite spiral
14:57:18 <popcorn> (x,y) | x == y -> 2;
14:57:32 <Lord_Illidan> to generate a spiral is similar to generating a circle
14:57:39 <Lord_Illidan> I dunno if anyone has logo experience here LOL
14:57:45 <roconnor> Lord_Illidan: how big of a spiral do you want?
14:57:49 <Lord_Illidan> repeat 360 [forward 1 rt 1]
14:57:53 <Lord_Illidan> roconnor, doesn't matter
14:58:04 <sheyll> popcorn: I dont understand that. I thought in haskell, as in erlang, variables can be bound once only...
14:58:10 <roconnor> Lord_Illidan: what commands do you have for Logo?
14:58:14 <Lord_Illidan> however, when generating a spiral, the value assigned to forward must change
14:58:18 <roconnor> comands/functions
14:58:36 <Lord_Illidan> repeat, turn, forward
14:58:38 <Lord_Illidan> pen down, pen up
14:58:44 <popcorn> sheyll: variables are never bound in haskell
14:58:55 <Cale> popcorn: what?
14:59:02 <roconnor> Lord_Illidan: if you want the value passed to forward to change, I think you will have to use an argument.
14:59:06 <Vulpyne> Lord_Illidan: I think I see what you mean now.
14:59:11 <Vulpyne> And yeah, what roconnor said.
14:59:14 <popcorn> variables already have values, you don't bind them
14:59:16 <Lord_Illidan> roconnor, well, that's what I thought too
14:59:24 <Lord_Illidan> And I told my teacher that much in an email
14:59:29 <Vulpyne> It'll have to be passed somehow, even if you hide it with a monad or whatever.
14:59:29 <popcorn> in Prolog and Erlang, you can have an unbound variable, and then bind it (which is a mutation)
14:59:40 <sheyll> ah
14:59:47 <popcorn> Cale: is that correct?
14:59:54 <popcorn> Cale: this is my view of thing-
15:00:04 <Cale> sheyll: Haskell doesn't allow nonlinear patterns like (x,x) -- variables can only occur once in a pattern. It's been suggested a few times that should perhaps generate an equality test, but you can just use a guard.
15:00:04 <monochrom> Like this? http://hpaste.org/7484#a2
15:00:08 <Vulpyne> Maybe your logo thing is a monad where you can thread state using that or something?
15:00:34 <Cale> popcorn: Well, when (\x -> x + 1) is applied to a value, for instance, the variable x gets bound to that value.
15:00:42 <Lord_Illidan> I'll post the entire code online, the assignment has already been submitted, so I needn't worry bout plagiarism or such nonsense, I'd just like to understand
15:00:55 <Vulpyne> That would probably help us help you.
15:01:04 <popcorn> dhmm ok
15:01:11 <popcorn> Cale: btw @src (++) is broken
15:01:15 <monochrom> It would be really nice if you could spell out what sequence of Logo commands you want this function to create.
15:01:33 <Cale> popcorn: It's not broken, it just has the Haskell 98 source for (++)
15:01:42 <popcorn> :t (++)
15:01:44 <lambdabot> forall m. (Monoid m) => m -> m -> m
15:01:47 <popcorn> @src (++)
15:01:47 <lambdabot> []     ++ ys = ys
15:01:47 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:01:47 <lambdabot> -- OR
15:01:47 <lambdabot> xs ++ ys = foldr (:) ys xs
15:01:49 <Lord_Illidan> right, this is the Logo module : http://hpaste.org/7488
15:01:53 <popcorn> doesn't make sense ...
15:01:59 <Lord_Illidan> I didn't write it, our teacher did
15:02:01 <cpoucet> Caleskell
15:02:05 <popcorn> why not add the = mappend
15:02:15 <monochrom> If you say something like "I want to obtain Forward 100 :> Turn 10 :> Forward 99 :> Turn 9 :> ... :> Forward 1 :> PenDown" then it's really clear what should be done.
15:02:31 <sheyll> :t *->*
15:02:33 <lambdabot> parse error on input `*->*'
15:02:34 <cpoucet> popcorn: cause that's not std haskell
15:02:40 <Cale> popcorn: I could.
15:02:43 <popcorn> @src (.)
15:02:43 <lambdabot> (f . g) x = f (g x)
15:02:43 <lambdabot> -- In lambdabot, it's been generalised to:
15:02:43 <lambdabot> (.) = fmap
15:02:45 <Lord_Illidan> monochrom, yes, something like that
15:02:49 <popcorn> ^ this is more informative
15:02:49 <Lord_Illidan> is it possible to do so?
15:02:52 <cpoucet> oh, it shows generaization
15:02:55 <Cale> It just makes the result of @src a little long
15:03:04 <popcorn> oh
15:03:05 <popcorn> that's true
15:03:17 <Vulpyne> Lord_Illidan: But you have some special constraint - you can't pass your function an argument?
15:03:20 <cpoucet> Cale: is this a subte way of pushing something into haskell?
15:03:23 <popcorn> I just find it -really- odd having type errors like this :P
15:03:25 <Cale> Maybe one more line would be okay
15:03:35 <cpoucet> Cale: by teaching all noobs the newr versions so they'll whine when normall haskell doesn't have them?
15:03:39 <Cale> cpoucet: It's mostly for fun, and yeah, to get people trying these things :)
15:03:44 <Lord_Illidan> this is the rest : http://hpaste.org/7489
15:03:50 <Lord_Illidan> Vulpyne, yes
15:03:50 <Cale> cpoucet: and it's working :)
15:03:56 <cpoucet> Cale: evil :D
15:04:00 <popcorn> I like . and ++
15:04:03 <popcorn> it seems good
15:04:17 <popcorn> but I wish you'd boil reduce haskell down more :)
15:04:27 <popcorn> to like 5 primitives or whatever
15:04:31 <Lord_Illidan> heh
15:04:35 <ddarius> S K
15:04:36 <dons> S and K, dudez
15:04:39 <cpoucet> :t fmap
15:04:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:04:50 <joricj> :t lift
15:04:52 <dons> let, case, lambda, apply. that's all we really need
15:04:53 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
15:04:58 <cpoucet> :t elevator
15:05:00 <lambdabot> Not in scope: `elevator'
15:05:07 <popcorn> dons: I mean the typeclassy fun stuff
15:05:08 <sheyll> id = s k k
15:05:10 <sheyll> ?
15:05:14 <ddarius> sheyll: Yes.
15:05:20 <ddarius> Indeed, forall x. id = s k x
15:05:22 <popcorn> id = s k id
15:05:27 <Vulpyne> Lord_Illidan: Define a sub function using where inside your function? :)
15:05:42 <Lord_Illidan> Vulpyne heh
15:05:50 <Lord_Illidan> idiotic limitation
15:06:02 <ddarius> popcorn: That can be reduced to dictionary passing.
15:06:03 <Vulpyne> Then the top level could have that signature, and it could generate an infinite spiral, or whatever.
15:06:11 <sheyll>  is the forall x. ... stuff also haskell ?
15:06:13 <Vulpyne> I don't see any other way you could really do it that wasn't tricky like that.
15:06:20 <monochrom> Like this? http://hpaste.org/7484#a3
15:06:28 <popcorn> ddarius: in a typesafe way?
15:06:30 <ddarius> sheyll: No.  That's just a proposition.
15:06:37 <monochrom> which is what Vulpyne says.
15:06:38 <ddarius> popcorn: Yes.  That's how they are implemented.
15:06:48 <Lord_Illidan> thanks monochrom
15:06:49 <Lord_Illidan> but heh
15:06:56 <Lord_Illidan> looks like cheating to me LOL
15:07:06 <popcorn> I mean in the language itsself though, not a compiler written in haskell ?
15:07:11 <Vulpyne> Hey, it's thinking outside the box. Not cheating.
15:07:15 <popcorn> I thought typeclasses were resolved at compile time
15:07:25 <Lord_Illidan> I mean, it's like saying, look I got a function that does in 2 lines of code what yours does in 100 lines
15:07:27 <monochrom> It is not cheating. It is not even thinking outside the box.
15:07:32 <Lord_Illidan> but mine calls a number of other functions
15:07:33 <cpoucet> which box?
15:07:48 <ddarius> popcorn: It requires higher order types, but otherwise yes.
15:07:51 <monochrom> It can be proved this is the only way.
15:07:51 <Lord_Illidan> I was thinking of using FoldL, or FoldR
15:08:00 <ddarius> s/higher order/higher rank/
15:08:03 <Vulpyne> Yes, you could use something like that to pass the state.
15:08:05 <Lord_Illidan> applying Forward to a list
15:08:06 <popcorn> I see
15:08:13 <Lord_Illidan> but I'm not too sure how to do that
15:08:24 <Vulpyne> Whether you use a fold, or sub function, or state monad or whatever, you'll be passing the size as an argument.
15:08:28 <Vulpyne> Even if it's hidden in the plumbing.
15:08:42 <popcorn> @source LPRef
15:08:42 <lambdabot> LPRef not available
15:09:09 <popcorn> oops
15:09:16 <Cale> @src (++)
15:09:16 <lambdabot> []     ++ ys = ys
15:09:16 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
15:09:17 <lambdabot> -- OR
15:09:19 <lambdabot> xs ++ ys = foldr (:) ys xs
15:09:21 <lambdabot> -- In lambdabot, this is generalised to:
15:09:23 <lambdabot> (++) = mappend
15:09:25 <popcorn> o/
15:09:26 <monochrom> Somewhere you need a function that takes an extra argument.
15:09:40 <popcorn> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-STRef.html
15:09:44 <Lord_Illidan> I've never used foldr before
15:09:48 <popcorn> how come there's no reference implementation?
15:09:52 <dons> xs ++ ys = augment (\c n -> foldr c n xs) ys
15:09:53 <Lord_Illidan> foldr Forward [1..100] :> spiralLogo2?
15:10:00 <dons> augment g xs = g (:) xs
15:10:01 <Lord_Illidan> this doesn't work for some wierd reason
15:10:09 <ddarius> popcorn: Because it is not implementable in Haskell.
15:10:15 <popcorn> :(
15:10:16 <Cale> Lord_Illidan: you're missing the replacement for the empty list
15:10:36 <popcorn> so I really can't use StateT to implemet logic variables
15:10:37 <sheyll> @src FoldR
15:10:38 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:10:43 <popcorn> @src foldr
15:10:44 <lambdabot> foldr f z []     = z
15:10:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:10:51 <Cale> Lord_Illidan: The most useful way to think about foldr f z xs is that it's replacing each (:) in xs with f, and the [] at the end with z
15:10:57 <popcorn> sheyll: you know how a list is made like [1,2,3] = 1 : 2 : 3 : [] ?
15:11:03 <popcorn> oh Cale said itt already :)
15:11:03 <sheyll> yes
15:11:06 <sheyll> thanks
15:11:17 <sheyll> I was confused by FoldR
15:11:20 <Cale> I have some pretty diagrams you can look at.
15:11:22 <Lord_Illidan> bah, I don't think it's going to work damn it
15:11:28 <sheyll> I know foldr not FoldR
15:11:33 <ddarius> popcorn: You can if you are willing to accept some limitation and a large performance penalty.
15:11:40 <monochrom> Random coding does not work. The reason is not weird.
15:11:44 <Lord_Illidan> thanks for all your help
15:11:47 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
15:11:51 <lambdabot> Title: Fold Diagrams - CaleWiki
15:11:57 <monochrom> Programming is most effective by Intelligent Design.
15:12:09 <Lord_Illidan> I believe in evolution :D
15:12:21 <Lord_Illidan>   Couldn't match expected type `b -> b' against inferred type `Logo'
15:12:21 <sheyll> Cale: this is really great!
15:12:33 <cpoucet> :t \xs -> g (:) xs
15:12:35 <lambdabot>     No instance for (Show (a -> [a] -> [a]))
15:12:35 <lambdabot>       arising from a use of `g' at <interactive>:1:7-14
15:12:35 <lambdabot>     Possible fix:
15:12:38 <cpoucet> :t \g xs -> g (:) xs
15:12:41 <lambdabot> forall t a t1. ((a -> [a] -> [a]) -> t -> t1) -> t -> t1
15:12:48 <monochrom> Evolution works if you give it a million years. I don't dispute that.
15:13:00 <Lord_Illidan> LOL :D I saw your first implementation
15:13:05 <Lord_Illidan> spiralLogo2   =		spiralLogo 1
15:13:12 <Lord_Illidan> I suppose I could be cheeky and do it :D
15:13:27 <Lord_Illidan> Just to see the teacher exploding or somewhat :D
15:13:28 <popcorn> :t let augment g xs = g (:) xs in augment
15:13:30 <lambdabot> forall a t t1. ((a -> [a] -> [a]) -> t -> t1) -> t -> t1
15:13:32 <monochrom> Same principle as my f and g that follow.
15:13:37 <Lord_Illidan> I know
15:13:42 <dons> haddock: internal Haddock or GHC error: internal: extractDecl
15:13:43 <dons> fun
15:13:50 <monochrom> It can be proved you must do this, there is no other way.
15:14:30 <monochrom> If you claim your instructor says otherwise, then either he/she is wrong, or you misunderstood him/her.
15:14:49 <monochrom> My experience is the probability of the latter is above 99%.
15:15:02 <Lord_Illidan> YOU CHANGED FUNCTION DEFINITION FOR THIS, IT SHOULD JUST HAVE GIVEN LOGO WITH NO ARGUMENTS APART FROM THAT, IT IS CORRECT
15:15:14 <Lord_Illidan> That's what he said. Caps are his, not mine
15:15:22 <popcorn> Lord_Illidan: over email?
15:15:31 <Lord_Illidan> No, in the same lhs I sent him
15:15:37 <popcorn> o_o
15:15:42 <Lord_Illidan> probably he was having a dalek moment
15:16:03 <monochrom> I don't understand English. I don't understand that statement.
15:16:16 <Lord_Illidan> heh :P
15:16:23 <Lord_Illidan> I don't understand you there, either
15:16:35 <Vulpyne> *Main> foldr (:>) DoNothing $ map Forward [1..10]
15:16:35 <Vulpyne> Forward 1.0 :> (Forward 2.0 :> (Forward 3.0 :> (Forward 4.0 :> (Forward 5.0 :> (Forward 6.0 :> (Forward 7.0 :> (Forward 8.0 :> (Forward 9.0 :> (Forward 10.0 :> DoNothing)))))))))
15:16:35 <Lord_Illidan> He was saying that my answer was correct
15:16:46 <Lord_Illidan> aya
15:16:49 <Lord_Illidan> ah
15:17:02 <Lord_Illidan> hmm
15:17:04 <popcorn> I don't understand ST...
15:17:08 <glguy> Vulpyne: infixr :>
15:17:16 <popcorn> what is wrong with type LogicM a = forall r. SG r (ST RealWorld a) a ?
15:17:23 <Vulpyne> glguy: Hmm?
15:17:32 <popcorn> because I could use type LogicM a = forall r. SG r (StateT LogicS IO) a before
15:17:34 <popcorn> that was fine
15:17:35 <monochrom> SG = StarGate?
15:17:36 <ddarius> popcorn: Why are you writing 'RealWorld' at all?
15:17:45 <glguy> Vulpyne: to avoid the lisp-like nested parentheses :)
15:18:01 <Vulpyne> glguy: Ah, I was just using the definition from his project.
15:18:11 <popcorn> upsidedown lisp
15:18:11 <Vulpyne> Which is data Logo = Logo :> Logo for that.
15:18:22 <glguy> Vulpyne: ok, (I haven't been following the conversation, just threw that out there)
15:18:30 <Vulpyne> Didn't know infixr would do that though, so good to know.
15:18:39 <popcorn> ddarius: I'm not meant to?
15:18:45 <Vulpyne> Lord_Illidan: Does that make sense to you?
15:18:46 <fons_> popcorn: wrong in what sense?
15:18:50 <ddarius> popcorn: No.
15:19:02 <monochrom> forall r. SG r (forall s. ST s a) a  ?
15:19:07 <popcorn> oh I got a Kind mismatch
15:19:21 <Vulpyne> Ohnoes, kind mismatch!
15:19:24 <Lord_Illidan> Vulpyne, I'm experimenting a bit with it
15:20:19 <popcorn> monochrom: with that, it still says Expected kind `* -> *', but `ST s a' has kind `*'
15:20:50 <Saizan> (ST s) is the monad
15:21:08 <popcorn> but if I write that I get this error: Expected kind `*', but `ST s' has kind `* -> *'
15:21:18 <monochrom> newtype SH a = SH (forall s. ST s a);  type SM a = forall r. SG r SH a ?
15:21:52 <monochrom> This will cause lots of code change later.
15:22:20 <monochrom> Perhaps it is simpler to forall r. SG r (ST RealWorld) a
15:22:21 <Lord_Illidan> just one clarification
15:22:27 <Lord_Illidan> what does the $ do?
15:22:31 <Lord_Illidan> never encountered it
15:22:39 <monochrom> > f $ x :: Expr
15:22:40 <cpoucet> @src ($)
15:22:41 <lambdabot>  f x
15:22:41 <lambdabot> f $ x = f x
15:22:45 <Vulpyne> It's like a parenthesis that just opens.
15:22:54 <Lord_Illidan> ic
15:22:56 <mauke> it's more like )(
15:22:58 <sheyll> ok, thanks for all your nice answers. I have to sleep now :) - kthxbai
15:22:58 <Vulpyne> (blah blah $ blah blah) = (blah blah (blah blah))
15:23:05 <Lord_Illidan> oh ic
15:23:12 <monochrom> > f f $ f f
15:23:13 <lambdabot>  Add a type signature
15:23:18 <monochrom> > f f $ f f :: Expr
15:23:18 <lambdabot>  Add a type signature
15:23:34 <popcorn> I don't like ST :/
15:23:42 <HelenF> I'm reading a list of the prime numbers out of a file, so I've got, storedprimes :: IO [Integer] - but the primes are the same forever
15:23:47 <SamB> popcorn: me either
15:23:50 <SamB> nasty forall!
15:23:53 <HelenF> what should I do about that?
15:23:56 <popcorn> what do you use instead?
15:24:09 <SamB> er, uh, unsafePerformIO?
15:24:23 <HelenF> I'm new sorry
15:24:37 <monochrom> The primes are the same forever. This is a mathematical fact.
15:24:41 <HelenF> I saw the dire warnings on that
15:24:55 <SamB> HelenF: I was talking to popcorn
15:25:11 <SamB> in case you got confused, which is quite possible considering the type of unsafePerformIO
15:25:34 <monochrom> I don't understand the questions of this generation.
15:25:53 <SamB> HelenF: well, the file could be wrong
15:25:59 <popcorn> are there any other descriptions of adding typed logic variables to haskell?
15:26:27 <HelenF> I think I have to assume the file is right
15:26:43 <SamB> HelenF: in that case, you also could use unsafePerformIO
15:26:47 <monochrom> What is meant by "the primes are the same forever"?
15:26:49 <byorgey> noooooooooo
15:26:49 <HelenF> so that means I can assume its the same at the beginning and the end of the program
15:26:55 <Vulpyne> Lord_Illidan: foldr ((:>) . (Turn 10 :>)) DoNothing $ map Forward [1..10] -- Something similar to this maybe.
15:27:03 <SamB> byorgey: why like that?
15:27:06 <byorgey> HelenF: there's nothing wrong with having storedprimes :: IO [Integer]
15:27:08 <cpoucet> monochrom: not helping
15:27:39 <cpoucet> SamB: don't teach unsafeperformIO to noobs
15:27:40 <monochrom> Well, like I said, I don't understand the questions of this generation.  "Help, the primes are the same forever."  What's wrong with that?
15:27:40 <mauke> monochrom: the file doesn't change
15:27:40 <byorgey> HelenF: in your main, just have something like this :  do { primes <- storedprimes ; dowhatever primes }
15:27:45 <cpoucet> obviously, the answer here is 'do'
15:27:48 <SamB> @oeis 2,3,5,7,11
15:27:49 <lambdabot> The prime numbers.
15:27:49 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
15:27:50 <byorgey> HelenF: then dowhatever can be a pure function which takes the list of primes as input
15:27:51 <tromp> primes can be generated faster than read from disk...
15:28:04 <SamB> monochrom: do you see that sequence changing?
15:28:07 <HelenF> tromp: they can?
15:28:09 <popcorn> @oeis 1 1
15:28:10 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
15:28:10 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
15:28:11 <SamB> I don't see that sequence changing
15:28:28 <tromp> in like 2 lines of code
15:28:30 <HelenF> I already did it with do, but I'm using it a lot and my code is getting quite nasty
15:28:32 <SamB> how come it doesn't tell us what the sequence number is?
15:28:32 <monochrom> I don't see that sequence changing either.  It's a good thing.  Why does anyone need help changing it?
15:28:57 <SamB> monochrom: well, apparantly HelenF was somehow confused because her function was in IO
15:28:57 <byorgey> HelenF: the point is that you should only need *one* do block, from which you call a pure function which calls everything else (all the other pure stuff)
15:29:08 <byorgey> HelenF: it should be possible to cleanly separate the nastiness from the pure stuff
15:29:10 <SamB> when it was supposed to find her a list of primes
15:29:24 <tromp> @let primes = 2:[x|x<-[3..],all(\p->x`mod`p>0)(takeWhile(\p->p*p<=x)primes)]
15:29:26 <lambdabot> Defined.
15:29:29 <mauke> this is the configuration problem
15:29:34 <SamB> HelenF: btw, do you have ALL of the prime numbers in that file?
15:29:39 <cpoucet> tromp: that's quadratic
15:29:43 <HelenF> no, only some of them
15:29:51 <Lord_Illidan> Vulpyne, thanks, although I don't understand thing
15:29:55 <HelenF> tromp: I did it like that first and its slower
15:29:56 <Lord_Illidan> a thing, sorry
15:30:24 <HelenF> ok I know why it's an IO
15:30:54 <tromp> no, it's not quadratic
15:31:00 <Lord_Illidan> and, can someone tell me what does this mean? *** Exception: JeanAzzopardi.lhs:(139,0)-(160,32): Non-exhaustive patterns in function play
15:31:14 <tromp> it's roughly n^1.5
15:31:27 <ddarius> Lord_Illidan: It means you patterns are not exhaustive in function play.
15:31:28 <cpoucet> tromp: well I meant output n, not input n
15:31:41 <tromp> same
15:31:41 <Lord_Illidan> ddarius, which means?
15:31:54 <Vulpyne> Lord_Illidan: foldr (\x y -> Turn 10 :> x :> y) DoNothing $ map Forward [1..10] -- Easier to understand?
15:31:55 <tromp> i'm ignoring logarithmic factors
15:31:58 <Vulpyne> Do you know lambdas yet?
15:32:01 <Saizan> Lord_Illidan: there's a case you have not covered in the definition of play
15:32:09 <ddarius> > case [1] of [] -> "foo"
15:32:10 <Lord_Illidan> oh
15:32:10 <lambdabot>   Non-exhaustive patterns in case
15:32:51 <HelenF> I guess my program isn't really normal
15:32:59 <Vulpyne> foldr (\x y -> Turn 10 :> Forward x :> y) DoNothing [1..10] -- That's probably simpler.
15:33:00 <HelenF> I'm doing "problems" which are all quite short
15:33:31 <Vulpyne> You can think of y as the whole rest of the Logo list thingy (which hasn't been evaluated yet, but since Haskell is lazy, that's okay.)
15:34:03 <HelenF> is there really a faster way of making primes than reading them from a file?
15:34:17 <popcorn> HelenF: Yes
15:34:27 <popcorn> for small numbers
15:34:31 <atsampso1> depends how many primes you're after, I assume
15:34:37 <mauke> > let primes = repeat 2 in primes
15:34:38 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
15:34:51 * atsampso1 grins at mauke
15:34:54 <HelenF> up to 8 million so far
15:35:24 <Lord_Illidan> ah I got it why it was giving me that error
15:35:28 <popcorn> > let facs 1=[];facs n=dr n:facs(n`div`dr n) where dr n=(!!0)$filter((==0).(n`mod`))[2..n] in nub (facts =<< [1..])
15:35:29 <lambdabot>   Not in scope: `facts'
15:35:32 <Lord_Illidan> I hadn't defined DoNothing in the play function
15:35:32 <popcorn> > let facs 1=[];facs n=dr n:facs(n`div`dr n) where dr n=(!!0)$filter((==0).(n`mod`))[2..n] in nub (facs =<< [1..])
15:35:35 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
15:35:44 <Vulpyne> That would do it.
15:35:50 <mm_freak> what would you people suggest for a 'while' function?  (Monad m => m (Bool, a) -> m a) or (Monad m => (a -> Bool) -> m a -> m a) ?
15:35:57 <popcorn> @src whileM_
15:35:58 <lambdabot> Source not found. You untyped fool!
15:36:40 <HelenF> hmm
15:36:50 <monochrom> I like the former, mm_freak
15:36:56 <dons> apparently its not widely known, but http://reddit.com/info/6ip7c/comments/
15:36:59 <popcorn> it is possible to use ST?
15:37:00 <dons> how to call Haskell from C.
15:37:05 <Lord_Illidan> hmm, it works now
15:37:16 <Lord_Illidan> thanks a lot Vulpyne I'll be trying to understand it now
15:37:28 <Vulpyne> Lord_Illidan: Any specific part you're having trouble with?
15:37:30 <popcorn> dons: wow! That's really cool
15:37:54 <Vulpyne> I'm glad I don't have to write C anymore. :)
15:38:16 <ddarius> dons: The FFI does a decent job covering it.
15:38:33 <conal> does reddit use markdown for comments? including `foo` and indented-by-four blocks for code?
15:38:35 <tromp> http://www.haskell.org/haskellwiki/Prime_numbers has a fast real sieve in Haskell, but it's ugle imperative style using STUArray's with unsafe reads/writes
15:38:36 <lambdabot> Title: Prime numbers - HaskellWiki
15:38:48 <mm_freak> monochrom: yeah, me too, since it's actually a "do … while COND" equivalent, not "while COND do …"
15:38:51 <MyCatVerbs> conal: yes.
15:38:56 <conal> MyCatVerbs: thx.
15:39:00 <MyCatVerbs> conal: er, yes and "I don't know" respectively.
15:39:04 <Lord_Illidan> Vulpyne, It now gives me a neat spiral
15:39:07 <conal> :)
15:39:11 <Vulpyne> Lord_Illidan: Excellent.
15:39:19 <Lord_Illidan> So what I'm trying to understand is this..
15:39:20 <Vulpyne> Lord_Illidan: Do you understand how the foldr works?
15:39:31 <Lord_Illidan> I'm tyring to understand that part
15:39:36 <MyCatVerbs> Vulpyne: BLACK MAGIC AND RECURSION! MWHAAHAHAH!
15:39:36 <Lord_Illidan> give me a moment pls
15:39:40 <Lord_Illidan> heh
15:39:45 <Lord_Illidan> exactly :D
15:39:47 <Vulpyne> foldr (\x y -> Turn 10 :> Forward x :> y) DoNothing [1..10] -- Use this one, not the others.
15:39:51 <dons> ddarius: yeah, i know. its too easy.
15:39:57 <Vulpyne> The other ones I gave you were more complicated/redundant.
15:40:11 <MyCatVerbs> Lord_Illidan: you familiar with the idea of an accumulator?
15:40:25 <Lord_Illidan> in what sense, MyCatVerbs?
15:40:42 <Lord_Illidan> as in assembly language?
15:41:04 <MyCatVerbs> Lord_Illidan: as in, imagine going through all the elements of a collection with a local variable that gets modified on each pass through the loop.
15:41:45 <Lord_Illidan> yes
15:41:51 <MyCatVerbs> Lord_Illidan: like summing the contents of an array. The accumulator will be an integer that you set to 0 to begin with, and for each element in the array, add that to the accumulator.
15:42:08 <Lord_Illidan> yes
15:42:17 <Vulpyne> foldr doesn't really seem to fit that idea though, though foldl does.
15:42:32 <Lord_Illidan> foldr works like foldl, no?
15:42:39 <Lord_Illidan> It just takes the last element of the list
15:42:57 <MyCatVerbs> Right, excellent. fold functions take a two-argument function (whose arguments are the previous accumulator value and the current element value) which generates a new accumulator value.
15:43:02 <Vulpyne> Well, foldl you can kind of think of it like giving it an initial state, and at each step you return the next state.
15:43:25 <Vulpyne> foldr kind of seems like the reverse of that. I haven't used foldr much though.
15:43:31 <MyCatVerbs> Lord_Illidan: And also they take an initial value for the accumulator, and then the last function is a list of values in the collection.
15:43:38 <Lord_Illidan> so what are the 2 arguments to foldr?
15:43:39 <monochrom> There is some way foldl is "like" foldr, and there is some way they are not "like".
15:43:52 <Vulpyne> :t foldr
15:43:54 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:43:55 <popcorn> I don't like these stateful ways to look at folds
15:44:01 <popcorn> is it really helpful
15:44:03 <Lord_Illidan> but here : foldr (\x y -> Turn 10 :> Forward x :> y) DoNothing [1..1000]
15:44:13 <Lord_Illidan> you got 3 arguments, or am I mistaken?
15:44:18 <Lord_Illidan> dear god, I need some coffee
15:44:22 <Vulpyne> Just two, x and y.
15:44:39 <Vulpyne> x will be one item from the list that [1..1000] generates.
15:45:13 <Vulpyne> And y will be type Logo - the whole rest of the final Logo result.
15:45:33 <MyCatVerbs> Lord_Illidan: er, you have foldr f a l -- f is a function from an accumulator and an element to an accumulator -- a is an initial accumulator value -- l is the list of elements.
15:45:47 <HelenF> popcorn: your function takes more than a minute on my machine to get the 10000th prime
15:45:54 <HelenF> that isn't fast enough
15:46:02 <popcorn> aww ok
15:46:11 <popcorn> it can be written much faster though
15:46:19 <HelenF> I need the 2 millionth in well under a minute
15:46:25 <conal> Deewiant: thanks for the suggestion on reddit (http://reddit.com/info/6ikr0/comments/).  i just left a reply.
15:46:52 <MyCatVerbs> Lord_Illidan: the difference between foldr and foldl is whether the brackets go to the left of the right when you write it out.
15:47:10 <Lord_Illidan> I think I'll better research lambda expressions too
15:47:12 <Vulpyne> Lord_Illidan: BTW, if you add a "deriving Show" to the Logo type, you can just play with it in ghci and print it ount.
15:47:13 <Vulpyne> Out.
15:47:21 <Vulpyne> Lord_Illidan: A lambda is just a small anonymous function.
15:47:36 <Lord_Illidan> yes, Vulpyne, it does derive show btw
15:47:38 <Vulpyne> (\x y -> x + y) 1 2
15:47:46 <Lord_Illidan> ah
15:47:49 <Vulpyne> That's a lambda that takes two arguments.
15:47:53 <Lord_Illidan> now I understand that
15:48:14 <Vulpyne> You can also do pattern matching in the argument part, but there can only be one definition of a lambda.
15:48:22 <Vulpyne> So you can't use it to match multiple cases.
15:48:23 <HelenF___> I hate my wireless =*(
15:48:38 <Lord_Illidan> you all should take teaching jobs
15:48:45 <jberryman> HelenF: there is a page about creating prime number functions on haskell.org somewhere IIR. I just finished a program to solve a project euler problem and wrote an infinite prime list function for it which i could understand. could post if you'd like
15:48:55 <Lord_Illidan> Vulpyne, now I'm getting it
15:49:37 <HelenF___> I can't have my browser open at the same time as IRC and wireless, but yes please I can look at it later
15:49:54 <Lord_Illidan> so in your expression
15:49:54 <HelenF___> IRC + ghci +wireless isn't happy either =/
15:50:02 <Lord_Illidan> foldr (\x y -> Turn 10 :> Forward x :> y) DoNothing [1..1000]
15:50:16 <jberryman> Lord_Illidan: I'm just learning haskell, and finding it really helpful to read the source for the prelude functions I use
15:50:20 <Lord_Illidan> x is being assigned to [1..1000]
15:50:25 <Lord_Illidan> :t foldr
15:50:27 <jberryman> they are all pretty simple for the most part
15:50:27 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:51:01 <Vulpyne> BTW, the lambda part is the same as if you defined a sub function like: where subfunc x y = Turn 10 :> Forward x :> y
15:51:07 <Vulpyne> And passed that to foldr instead.
15:51:29 <Lord_Illidan> in \x y -> ...
15:51:29 <Vulpyne> And that sub function would have the type: Float -> Logo -> Logo
15:51:38 <Lord_Illidan> is x DoNothing
15:51:43 <Lord_Illidan> or [1..1000]?
15:51:46 * EvilTerran pokes HelenF___
15:51:50 <Lord_Illidan> because that's what really confusing me now
15:52:07 <Vulpyne> x is [1..1000]
15:52:22 <jberryman> ?
15:52:34 <Vulpyne> Only one item of it though. foldr calls the function once per item in the list.
15:52:57 <Lord_Illidan> hmm, so whenever you have a lambda expression
15:53:07 <Vulpyne> Are you familiar with functions that recurse into themselves to build a list? Like: ascending x = x: ascending (x + 1)
15:53:18 <Vulpyne> If you did ascending 0 you'd get [0,1,2,3,4,...]
15:53:22 <Lord_Illidan> (\x y -> x + y) 1 2 : does x become 1 or does it become 2
15:53:23 <Lord_Illidan> ?
15:53:34 <EvilTerran> 1
15:53:42 <EvilTerran> > (\x y -> x) 1 2
15:53:43 <lambdabot>  1
15:53:45 <EvilTerran> > (\x y -> y) 1 2
15:53:46 <popcorn> > (\x y -> show x ++ " + " ++ show y) 1 2
15:53:47 <lambdabot>  2
15:53:48 <lambdabot>  "1 + 2"
15:53:54 <shapr> yarr!
15:53:54 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
15:53:55 <Vulpyne> x is the first argument to the function, y is the second.
15:54:05 <Lord_Illidan> but..in that case.. isn't DoNothing the first argument?
15:54:08 <Vulpyne> (\x y -> x + y) is the same as myfunc x y = x + y
15:54:10 <monochrom> > (\x y -> x + y) 1 2 :: Expr
15:54:12 <lambdabot>  1 + 2
15:54:12 <Lord_Illidan> Or am I getting everything completely wrong?
15:54:27 <popcorn> Lord_Illidan: it's the second argument to foldr
15:54:36 <Vulpyne> foldr passes DoNothing as the y on the very last iteration.
15:54:39 <popcorn> Lord_Illidan: foldr puts it into the y of the lambda abstraction
15:54:52 <Vulpyne> You know how a list is basically a constructor that takes an item and a list, and returns a list?
15:54:55 <Leimy> > flip (\x y -> x) 1 2
15:54:56 <lambdabot>  2
15:55:05 <Vulpyne> So a list [1,2,3] is 1:2:3:[]
15:55:09 <mauke> Lord_Illidan: a b c doesn't call b with c; it calls a with b and c
15:55:29 <Lord_Illidan> Arghh..please somebody else tell me that it's not just confusing to only me?
15:55:43 <EvilTerran> Lord_Illidan, you get used to it pretty quickly, but it is confusing at first
15:55:43 <Vulpyne> Which part?
15:55:56 <Vulpyne> I dunno about the pretty quickly part, but you get used to it eventually. :)
15:56:10 <monochrom> It has never been confusing to me.
15:56:26 <jberryman> Lord_Illidan: go here http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#foldr and try to understand the way foldr is defined in the commented code
15:56:27 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/3dzxqb
15:56:27 <HelenF____> sorry, it's rude of me to be asking questions when my connection is that bad
15:56:27 <Vulpyne> I wish I was a genius too. :(
15:56:29 <Lord_Illidan> well, the part about DoNothing and [1..1000] being both arguments to foldr and to x and y heh
15:56:44 <SamB> HelenF: you could ask them on hpaste ;-)
15:56:46 <Vulpyne> :t foldr
15:56:47 <EvilTerran> if you're used to, say, perl, where unparenthesised application is mostly right-associative, it can be a bit confusing
15:56:47 <popcorn> HelenF____: Don't worry, I think I missed it though
15:56:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:56:50 <monochrom> It probably helped that I learned assembly early.
15:56:59 <Lord_Illidan> I'm mostly used to java :D
15:57:01 <popcorn> HelenF____: If you miss something you can catch up with http://tunes.org/~nef/logs/haskell/
15:57:05 * EvilTerran pokes HelenF____
15:57:05 <mauke> Lord_Illidan: they're arguments to foldr, not x and y
15:57:08 <lambdabot> Title: Index of /~nef/logs/haskell
15:57:14 <HelenF____> hi
15:57:19 <EvilTerran> hello
15:57:29 <mauke> isn't there this thing called Visitor Pattern?
15:57:30 <Vulpyne> lord: foldr is a function that takes 3 arguments: First is a function that takes an "a", and a "b" and returns a "b", second is a "b", and last is a list of "a"s.
15:57:37 <mauke> because that's what foldr is
15:57:41 <Lord_Illidan> so..wait a bit..
15:57:42 <SamB> mauke: eww, not Java!
15:57:59 <Lord_Illidan> :t foldr
15:58:01 <Vulpyne> So the DoNothing and [1...1000] are arguments to foldr, not to the lambda.
15:58:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:58:30 <dobblego> is lambdabot still an incredible pain in the arse to compile and run?
15:58:41 <Vulpyne> It'll call the supplied function on each a in the [a].
15:58:57 <Lord_Illidan> so..
15:58:57 <dobblego> Lord_Illidan, it's best to forget everything you know about Java at this point
15:59:05 <mauke> noooo
15:59:09 <ddarius> > foldr c n (1:2:3:[])
15:59:10 <lambdabot>  Couldn't match expected type `a -> b -> b'
15:59:23 <Lord_Illidan> foldr is taking the function that is (\x y -> Turn 10 :> Forward x :> y), DoNothing, and [1..1000]
15:59:23 <ddarius> > foldr f n (1:2:3:[]) :: Expr
15:59:25 <lambdabot>  f 1 (f 2 (f 3 n))
15:59:34 <mauke> yes
16:00:03 <Lord_Illidan> and then, x is being mapped to 1000 (in the first iteration), and y is being mapped to DoNothing
16:00:06 <Vulpyne> Lord_Illidan: http://hpaste.org/7484#a4
16:00:10 <mauke> yes
16:00:52 <Vulpyne> Lord_Illidan: Those two functions are the same.
16:01:15 <Vulpyne> Except I spelled Forward wrong in the second one. Heh.
16:05:30 <Lord_Illidan> > foldr(\x y -> x) 0 [1..100]
16:05:31 <lambdabot>  1
16:05:39 <Lord_Illidan> I've been playing a bit with these, trying to understand them
16:06:07 <popcorn> > foldr (:) []   [1,2,3]
16:06:08 <lambdabot>  [1,2,3]
16:06:26 <popcorn> > foldr (\x ys -> x + 1 : ys) []   [1,2,3]
16:06:28 <lambdabot>  [2,3,4]
16:06:35 <popcorn> > foldr (\x ys -> ys ++ [x]) []   [1,2,3]
16:06:35 --- mode: ChanServ set +o glguy
16:06:35 --- mode: glguy set -b *!*@bas1-toronto35-1279627401.dsl.bell.ca
16:06:35 --- mode: ChanServ set -o glguy
16:06:36 <lambdabot>  [3,2,1]
16:06:42 <Vulpyne> > foldr (\x ys -> x + 1 : ys) []   [1,2,3] :: Expr
16:06:43 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
16:06:45 <popcorn> > foldr (flip (:)) []   [1,2,3]
16:06:46 <lambdabot>      Occurs check: cannot construct the infinite type: b = [b]
16:06:46 <lambdabot>       Expected...
16:06:51 <popcorn> > foldl (flip (:)) []   [1,2,3]
16:06:53 <lambdabot>  [3,2,1]
16:07:20 <popcorn> > (foldr (\x ys -> (+x) . ys) id   [1,2,3]) 0
16:07:21 <lambdabot>  6
16:07:42 <Lord_Illidan> I think I'll need some time to think this over
16:08:26 <Vulpyne> Lord_Illidan: You know how you can make a function that takes two arguments act like an infix operator by using the backticks? Like "myfunc 1 2" is the same as "1 `myfunc` 2"?
16:08:33 <Lord_Illidan> yes
16:08:54 <Vulpyne> Lord_Illidan: You can think of foldr as inserting a `yourfunc` in between each item in the list, and putting whatever its second argument was at the end.
16:09:03 <Lord_Illidan> oh
16:09:07 <Vulpyne> So foldr (:) [] [1,2]  is 1 : 2 : []
16:09:20 <popcorn> > foldr f z [a,b,c,d,e]
16:09:22 <lambdabot>  f a (f b (f c (f d (f e z))))
16:09:23 <Vulpyne> foldr myfunc HELLO [1,2] is 1 `myfunc` 2 `myfunc` HELLO
16:09:39 <popcorn> Vulpyne: =
16:09:49 <Lord_Illidan> I feel enlightened
16:09:49 <mauke> > foldr (+) 0 [a,b,c]
16:09:50 <lambdabot>  a + (b + (c + 0))
16:09:54 <Lord_Illidan> Vulpyne, thanks a lot
16:09:58 <Vulpyne> No problem.
16:10:05 <mauke> > foldr (*) 1 [a,b,c]
16:10:07 <lambdabot>  a * (b * (c * 1))
16:10:10 <Lord_Illidan> and all the rest who helped out
16:10:13 <Lord_Illidan> of course
16:10:21 <Vulpyne> I think it's nice that more people are learning Haskell.
16:11:00 <Lord_Illidan> It's safe to say that this irc channel is definitely not going to drive them away
16:11:24 <mauke> :-)
16:11:52 <jberryman> HelenF____: here is my primes function, it's very simple: http://hpaste.org/7491#a0
16:12:00 <shapr> yay!
16:12:12 * ddarius will have to raise his crotchetiness level.
16:12:22 <Vulpyne> Get off mah lawn!
16:12:29 <Vulpyne> Damn kids.
16:12:36 <Lord_Illidan> foldr (\x y -> x+y) 0 [1..10] = 10 + foldr (+) 0 [1..9]?
16:12:49 <popcorn> Lord_Illidan: no
16:12:50 <Lord_Illidan> ROFL :D
16:12:50 <MyCatVerbs> > foldl f [a,b,c,d,e]
16:12:51 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
16:12:54 <MyCatVerbs> > foldl f [a,b,c,d,e] f
16:12:55 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [b])
16:12:57 <popcorn> @src foldr
16:12:57 <lambdabot> foldr f z []     = z
16:12:57 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:12:59 <MyCatVerbs> Argh, stupid
16:13:09 <popcorn> foldr (\x y -> x+y) 0 [1..10] = foldr (\x y -> x+y) 0 (1:[2..10])
16:13:14 <MyCatVerbs> > foldl f a [b,c,d,e]
16:13:15 <lambdabot>  f (f (f (f a b) c) d) e
16:13:25 <popcorn> = (\x y -> x+y) 10 (foldr (\x y -> x+y) 0 [2..10])
16:13:25 <mauke> Lord_Illidan: it unwinds in the other direction
16:13:31 <popcorn> = 10 + foldr (\x y -> x+y) 0 [2..10]
16:13:40 <popcorn> Lord_Illidan: Is that clear?
16:13:42 <Vulpyne> It does give the same end result in that case though.
16:13:50 <mauke> popcorn: huh?
16:13:51 <popcorn> Vulpyne: a+b = b+a ?
16:13:56 <Lord_Illidan> Vulpyne, yes, I was confused by that, actually
16:13:57 <mauke> popcorn: how did that 10 get there?
16:14:09 <popcorn> mauke: I made some stupid mistake :P
16:14:10 <Vulpyne> Because the order of operations with + doesn't matter.
16:14:20 <Lord_Illidan> obviously
16:14:41 <Lord_Illidan> but umm
16:14:43 <Vulpyne> > 10 : foldr (:) [] [1..9]
16:14:44 <lambdabot>  [10,1,2,3,4,5,6,7,8,9]
16:14:52 <Lord_Illidan> yes, that's true
16:14:57 <Lord_Illidan> but what popcorn said doesn't make sense
16:15:01 <Lord_Illidan> that's foldl, not foldr
16:15:03 <Vulpyne> > foldr (\x y -> x:y) [] [1..10]
16:15:05 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:15:08 <popcorn> @src foldr
16:15:09 <lambdabot> foldr f z []     = z
16:15:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:15:16 <popcorn> foldr f z (x:xs) = f x (foldr f z xs)
16:15:28 <mauke> Lord_Illidan: it's neither, really
16:15:31 <Vulpyne> Using : and lists is probably one of the best ways to visualize the order.
16:15:34 <popcorn> foldr f z (1:[2..10]) = f 1 (foldr f z [2..10])
16:15:52 <Lord_Illidan> popcorn, you said that foldr (+) 0 [1..10] = 10 + foldr (\x y -> x+y) 0 [2..9]
16:15:55 <Lord_Illidan> however
16:16:04 <Lord_Illidan> foldr (+) 0 [2..9] = 54
16:16:08 <popcorn> Lord_Illidan: So did you :P
16:16:20 <popcorn> Lord_Illidan: Did you not see exactly where that mistake krept in ?
16:16:28 <mauke> Lord_Illidan: it's 1 + foldr (\x y -> x+y) 0 [2 .. 10]
16:16:39 <mauke> so it's right if you change 10 to 1 and 9 to 10
16:16:48 <Lord_Illidan> I said this : foldr (\x y -> x+y) 0 [1..10] = 10 + foldr (+) 0 [1..9]
16:17:00 <Lord_Illidan> I was thinking that it's basically like 10 is placed off the list
16:17:10 <mauke> right idea, wrong end of the list
16:17:10 <Lord_Illidan> and thus, it's now 9..8..down to 1
16:17:17 <Lord_Illidan> :S
16:17:33 <Lord_Illidan> :t foldr
16:17:35 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:18:44 <Lord_Illidan> oh
16:18:46 <Lord_Illidan> http://cale.yi.org/images/9/92/Folds.png
16:19:18 <mauke> http://foldr.com/
16:19:18 <lambdabot> Title: foldr.com
16:19:21 <Lord_Illidan> I've been a fool :D
16:19:41 <Lord_Illidan> wow,mauke
16:20:42 <Lord_Illidan> ok, so I understand now
16:21:13 <Lord_Illidan> foldr (\x y -> x+y) 0 [1..10] = 1 + foldr (+) 0 [1..9]
16:21:20 <mauke> [2..10]
16:21:28 <Lord_Illidan> yes, yes
16:21:38 <Lord_Illidan> it's 1.21 AM here, a bit tired lol
16:21:53 <popcorn> foldr (\x y -> x+y) 0 [1..10] = 1 + foldr (+) 0 [2..9]
16:22:04 <popcorn> @src foldr
16:22:05 <lambdabot> foldr f z []     = z
16:22:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:22:24 <mauke> popcorn: fail
16:22:32 <popcorn> foldr (\x y -> x+y) 0 [1..10] = foldr (\x y -> x+y) 0 (1:[2..10]) = (\x y -> x+y) 1 (foldr (\x y -> x+y) 0 [2..10]) = 1 + foldr (\x y -> x+y) 0 [2..10]
16:22:33 <dobblego> Lord_Illidan, this might help understand foldl http://blog.tmorris.net/scalalistfoldleft-for-java-programmers/
16:22:35 <lambdabot> Title: λ Tony&#8217;s blog λ  Blog Archive  scala.List.foldLeft for Java programmer ...
16:23:05 <mauke> foldr (+) 0 (1 : [2..10]) = (+) 0 (foldr (+) 0 [2..10])
16:23:10 * Lord_Illidan laughs at popcorn's repetition of his mistake :D
16:23:13 <mauke> ^ much simpler if you write (+) directly
16:23:42 <popcorn> no mauke that's wrong
16:23:55 <Lord_Illidan> it's right, not wrong
16:23:58 <popcorn> Lord_Illidan: her, and I what I wrote is right ..
16:24:02 <Lord_Illidan> ?
16:24:03 <popcorn> look:
16:24:09 <popcorn> > foldr f z [a,b,c]
16:24:10 <lambdabot>  f a (f b (f c z))
16:24:18 <popcorn> it's f a not f z
16:24:21 <mauke> haha
16:24:31 <mauke> how did I typo 1 as 0?
16:24:34 <Lord_Illidan> yeah, yeah I get you popcorn
16:24:44 <mauke> I MEANT 1 I SWEAR
16:24:53 <popcorn> Lord_Illidan: Do you see how what I wrote is correct?
16:24:59 <popcorn> Lord_Illidan: or did I make -another- mistake?
16:25:00 <Lord_Illidan> but in here foldr (\x y -> x+y) 0 [1..10] = 1 + foldr (+) 0 [2..9], it should be [2..10]
16:25:11 <popcorn>  <popcorn> foldr (\x y -> x+y) 0 [1..10] = foldr (\x y -> x+y) 0 (1:[2..10]) = (\x y -> x+y) 1 (foldr (\x y -> x+y) 0 [2..10]) = 1 + foldr (\x y -> x+y) 0 [2..10]
16:25:19 <Lord_Illidan> whao
16:25:21 <popcorn> that's what I wrote
16:25:33 <popcorn> I think you are just imagining me tripping up now :P
16:26:07 <Lord_Illidan> let's settle this once and for all : foldr (\x y -> x+y) 0 [1..10] = 1 + foldr (+) 0 [10..1000]
16:26:09 <Lord_Illidan> ok?
16:26:25 <popcorn> no
16:26:33 <Lord_Illidan>  foldr (\x y -> x+y) 0 [1..10] = 1 + foldr (+) 0 [2..10]
16:26:51 <Lord_Illidan> > foldr (\x y -> x+y) 0 [1..10]
16:26:52 <lambdabot>  55
16:26:59 <popcorn> yes but once since (\x y -> x+y) = (+)
16:27:01 <Lord_Illidan> >1 + foldr (+) 0 [2..10]
16:27:22 <Lord_Illidan> > 1 + foldr (+) 0 [2..10]
16:27:23 <lambdabot>  55
16:28:37 <mauke> > 1 + foldr (+) 0 [2..10] :: Expr
16:28:38 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
16:29:09 <MathHat> woohoo, we all know our associative laws
16:29:23 <popcorn> > let foldr f z (x:xs) = f x ((fun "foldr") f z xs) in foldr (+) 0 [1..10]
16:29:24 <lambdabot>  Add a type signature
16:29:26 <dons> > 1 + foldl (+) 0 [1..10] :: Expr
16:29:28 <lambdabot>  1 + (0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10)
16:29:28 <popcorn> > let foldr f z (x:xs) = f x ((fun "foldr") f z xs) in foldr (+) 0 [1..10] :: Expr
16:29:30 <lambdabot>  1 + foldr <SimpleReflect.Expr -> SimpleReflect.Expr -> SimpleReflect.Expr> 0...
16:29:39 <popcorn> grrr
16:29:45 <popcorn> > let foldr f z (x:xs) = f x ((fun "foldr") f z xs) in foldr (fun "+") 0 [1..10] :: Expr
16:29:46 <lambdabot>  Add a type signature
16:30:10 <Lord_Illidan> lol
16:30:20 <Vulpyne> Time to go home. Yay.
16:30:28 <Lord_Illidan> I'm off to bed
16:30:33 <Lord_Illidan> luckily 1.3 metres away
16:30:40 <Lord_Illidan> thanks all of you
16:31:48 <MathHat> popcorn: you have an incomplete definition for foldr there.
16:32:02 <omg911> anyone know what's the syntax to map over a Data.Sequence?
16:32:04 <Lord_Illidan>  > 1 + foldr (+) 0 [2..10] :: Expr
16:32:09 <Lord_Illidan> > 1 + foldr (+) 0 [2..10] :: Expr
16:32:11 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
16:32:11 <popcorn> MathHat: I was trying to get it to display one reduction but it didn't work
16:32:15 <Lord_Illidan> > 1 + foldr (+) 0 [2..100] :: Expr
16:32:16 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (1...
16:32:25 <popcorn> @hoogle map
16:32:25 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
16:32:25 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
16:32:25 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
16:32:31 <omg911> like mapM (*2) (empty |> 1 |> 2)
16:32:43 <mauke> omg911: I'd try fmap
16:33:18 <omg911> mauke: thx! that seems to work
16:33:39 <omg911> weird that it's an instance of monad and none of the functions seem to work..
16:34:17 <mauke> it's not a monad
16:34:24 <mauke> or wait
16:34:52 <mauke> d'oh, list style
16:34:53 <omg911> well through hoogle in the docs
16:34:58 <omg911> i see it is
16:34:58 <mauke> omg911: mapM doesn't map over monads
16:35:09 <mauke> :t mapM
16:35:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:35:21 <mauke> mapM is for lists only
16:35:29 <omg911> oh i see
16:35:29 <snhmib> uhm, what's the haskell variant of scanf?
16:35:30 <ddarius> :t Data.Foldable.mapM
16:35:32 <lambdabot> Not in scope: `Data.Foldable.mapM'
16:35:43 <ddarius> :t Data.Traversable.mapM
16:35:45 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
16:35:49 <mauke> snhmib: there is none. reads is similar, sort of
16:36:25 <snhmib> thanks i'll have a look at it
16:37:14 <mauke> also check the stuff in Text.ParserCombinators
16:37:44 <ddarius> Exercise: Write scanf in the style of printf.
16:38:20 <fons_> scanf would be doable in  template haskell
16:38:21 <mauke> that's sort of hard because scanf only takes one argument
16:38:43 <fons_> maybe it's even possible to do with a trick similar to the one in printf
16:38:44 <ddarius> mauke: But you can have it return a tuple.
16:39:01 <mauke> how do you recurse on that?
16:40:16 <ddarius> You can use nested tuples if you'd like
16:57:09 <cdsmithus> So, anyone want to give a "Intro to Haskell" user group presentation in Colorado Springs, CO (U.S.) on June 10?
16:58:05 <jdavis_> is there any difference between: "length [] = 0; length (x:xs) = 1 + length xs" and "length x = case x of [] -> 0; (y:ys) -> 1 + length ys"
16:58:27 <popcorn> jdavis: no
16:58:40 <popcorn> juts syntax
16:58:51 <cdsmithus> jdavis_: No, the first becomes the second during the compilation.
16:59:01 <jdavis_> Ok, thanks
17:06:53 <edward1> hrmm is there a good name for an applicative sans 'pure'?
17:07:39 <Cale> An unpointed applicative functor?
17:07:52 <edward1> cale: well, i guess that works =)
17:08:31 <EvilTerran> so the technical term for functor with pure but no ap is "pointed functor"?
17:08:40 <edward1> evil: yeah
17:09:41 <edward1> @src liftM
17:09:41 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:09:43 <dobblego> does it have to have no ap, or not necessarily ap?
17:09:55 <edward1> not necessarily ap
17:10:06 <edward1> functor => pointed => applicative => monad basically
17:10:12 <dobblego> ah ok
17:10:25 <dobblego> can a functor have ap but no pure?
17:10:53 <edward1> dobblego yeah
17:11:06 <dobblego> what's that called then?
17:11:20 <edward1> dobblego: (8:06:41 PM) Cale: An unpointed applicative functor?
17:11:25 <dobblego> oh sorry
17:11:28 <edward1> =)
17:11:36 <edward1> np
17:11:53 <edward1> generally its a less useful construct
17:12:05 <edward1> but i'm sitting here and found the rare case where that was the set of constraints i needed on the type
17:12:38 <edward1> f (a -> b) -> f a -> f b was the only requirement, because in an ideal monad the 'return/pure' part is already factored out
17:14:15 <dobblego> I've found things like that too
17:14:31 <dobblego> I had a really good use case once for a monoid without zero (semigroup)
17:15:53 <edward1> heh its when you go 'oh man, what i really need here is a left semimedial magma' that you should check yourself in for therapy =)
17:17:43 <TSC> Where should I look for a beginner's guide to reading GHC Core output?
17:18:19 <shapr> @seen edwardk
17:18:19 <lambdabot> I saw edwardk leaving #haskell 2h 26m 47s ago, and .
17:18:29 * edward1 hides.
17:18:35 * shapr grins
17:20:01 <shapr> edwardk: In the future I will bang on your airconditioner instead of your front door, thus causing Kubla Khan like amputation for your evening's category theory.
17:20:12 <Pseudonym> TSC: Have you read the STG paper?
17:20:18 <TSC> I don't think so
17:20:24 <TSC> That would be a good start?
17:20:29 <Pseudonym> ?go spineless tagless g machine
17:20:30 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
17:20:30 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
17:20:33 <Pseudonym> Yes.
17:20:45 <TSC> Great, thanks
17:20:56 <Pseudonym> That describes the language and its semantics.
17:21:02 <Pseudonym> Core should be fairly easy to understand after that.
17:21:29 <FalconNL> Question: Suppose I have the following ADT:
17:21:31 <FalconNL> data Living = Player  { race :: Race, hp :: Int, expPoints :: Int}
17:21:32 <FalconNL>             | Monster { race :: Race, hp :: Int }
17:21:34 <FalconNL>             | NPC     { race :: Race, hp :: Int }
17:21:35 <FalconNL> Is there any way to get rid of the duplication of race, hp, etc. while keeping the 'mutability' that records provide?
17:22:39 <Pseudonym> FalclnNL: There are several ways to do it, but they all depend on one very important thing:
17:22:45 <Pseudonym> Make Living abstract.
17:23:08 <Pseudonym> And only access and mutate it through functions.
17:23:11 <Pseudonym> And maybe views.
17:23:38 <FalconNL> Pseudonym: do you happen to have a link to a page explaining this approach?
17:24:08 <Pseudonym> Nope.  But the point is to put the data type in a module, and don't expose the details./
17:24:10 <edwardk> class Living a where race :: a -> Race; hp :: a -> Int
17:24:16 <Pseudonym> Do expose smart constructors:
17:24:19 <Pseudonym> ?go factory function
17:24:20 <lambdabot> http://gsraj.tripod.com/design/creational/factory/factory.html
17:24:20 <lambdabot> Title: The Factory Method Design Pattern by Gopalan Suresh Raj
17:24:26 <Pseudonym> Uhm.
17:24:29 <Pseudonym> ?go smart constructor
17:24:30 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
17:24:30 <lambdabot> Title: Smart constructors - HaskellWiki
17:24:33 <Pseudonym> That.
17:24:36 <Pseudonym> Also expose views.
17:24:39 <Pseudonym> ?go concrete view
17:24:41 <lambdabot> http://theatrenotes.blogspot.com/2006/05/view-of-concrete_05.html
17:24:41 <lambdabot> Title: A View of Concrete ~ theatre notes
17:24:45 <Pseudonym> ?go concrete views
17:24:45 <lambdabot> http://www.actapress.com/Abstract.aspx?paperId=16581
17:24:46 <lambdabot> Title: [Abstract] Integrating Web Information with XML Concrete Views
17:24:54 <Pseudonym> Uhm...
17:24:57 <Pseudonym> Those are some cool links.
17:25:07 <Pseudonym> ?go concrete view haskell
17:25:09 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
17:25:09 <lambdabot> Title: ViewPatterns - GHC - Trac
17:25:10 <Botje> go is really hating you today :)
17:25:17 <Pseudonym> Woo.
17:25:36 <Pseudonym> The point is, don't expose the implementation.
17:25:48 <FalconNL> Pseudonym: Thanks for the links. Looks like I've got some reading to do :)
17:25:49 <Pseudonym> That way, you can implement it however you like.
17:25:56 <Pseudonym> :-)
17:25:58 <lament> go is hard
17:26:03 <Pseudonym> The one on the theatre notes look particularly interesting.
17:26:13 <Pseudonym> If quite irrelevant.
17:26:40 <Pseudonym> And yeah, it's not so dumb to expose a class like edwardk suggested, either.
17:48:57 <hasenov> hello, i have a problem installing opengl on gentoo
17:49:09 <hasenov> it is version 2.2.1
17:49:23 <hasenov> is this a known problem or something particular?
17:49:33 <Zao> What exactly are you trying to install?
17:49:46 <Zao> Erm, never mind. This isn't the channel I thought it was :)
17:49:52 <hasenov> Zao: dev-haskell/opengl
17:53:25 <reilly> i think we should rename "applicative functors/idioms" to be monotremes
17:53:54 <reilly> visually in line with monads, monoids.   but funnier
17:54:06 <dons> instance Monotreme Platypus ?
17:54:11 <reilly> exactly
17:55:58 <FalconNL> Hm. I'm ending up with the following, which I'm pretty sure is completely the wrong direction, as it get horrible very quickly:
17:56:00 <FalconNL> class Living a where race :: a -> Race; hp :: a -> Int
17:56:02 <FalconNL> instance Living Creature where race (Player _ r) = r; hp (Player h _) = h
17:56:03 <FalconNL> data Creature = Player Race Int | Monster Race Int
17:56:04 <FalconNL> updateRace :: Living -> Living
17:56:06 <FalconNL> updateRace l = ... -- Stuck.
17:56:07 <FalconNL> Would anyone be kind enough to explain the correct approach in a bit more detail?
17:56:40 <dons> updateRace wouldn't take a class as a parameter
17:56:51 <dons> or does it?
17:57:18 <chessguy> dons: presumably it's updateRace :: (Living a) => a -> a
17:57:27 <dons> isn't it Creature -> Creature then?
17:57:33 <dons> humans turn into monsters?
17:57:37 <dons> what are you trying to implement?
17:57:47 <chessguy> haha
17:57:59 <chessguy> Haskenstein
17:58:15 <chessguy> or perhaps Frankeskell
17:58:52 <FalconNL> dons: I'm trying to make a roguelike. Currently the player, monsters and NPCs are completely different types. However, since they share a lot of logic I'm trying to unite them into one type.
17:59:52 <popcorn> data Living = Player Race Int | Monster Race Int | ...
18:00:04 <popcorn> no need for classes?
18:00:37 <FalconNL> popcorn: yeah, but that (as well as my latest sample) doesn't solve the duplication I'm trying to get rid of
18:00:49 <Elly> FalconNL: how are you doing the user interface?
18:01:13 <FalconNL> I'm trying to not have to define all the common properties (there will be quite a few more) three times
18:01:22 <popcorn> ?
18:01:26 <FalconNL> Elly: wxHaskell. It will be a graphical roguelike
18:01:32 <Elly> ah, okay
18:01:47 <popcorn> data Species = Player | Monster | ...
18:01:56 <popcorn> data Living = Living Species Race Int
18:02:07 <edwardk> falconNL: factor out the common stuff data wise into a data type, build a living class to access it, and lift the methods to that
18:02:12 <edwardk> one sec i'll give an example
18:13:09 <edwardk> @hpaste
18:13:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:13:43 <saml> @where pattern matching
18:13:44 <lambdabot> I know nothing about pattern.
18:13:59 <saml> is implementing pattern matching hard?
18:14:28 <edwardk> http://hpaste.org/7496 is probably simpler
18:15:26 <edwardk> Then you can write functions that expect any living thing by saying they take 'Living a' or one that takes only a Monster
18:16:00 <Saizan> saml: it depends on how you implement ADTs, with Church-encoding it becames a matter of function application
18:16:47 <SamB> Saizan: well, first you have to split it into primitive cases...
18:17:50 <saml> it sounds hard.
18:18:23 <Saizan> SamB: true
18:19:25 <SamB> saml: not as hard as kind inference
18:19:52 <FalconNL> edwardk: Yeah, this is pretty much what I needed. Thanks mate.
18:19:57 <Saizan> SamB: what's so hard about it?
18:20:04 <saml> for me, it took about 2 months each to implement typechecking and evaluation.
18:20:15 <edwardk> falcon: np
18:20:18 <SamB> Saizan: well, it's far more cross-cutting...
18:20:49 <SamB> and defaulting makes it worse, afaict
18:20:59 * edwardk would point out that Living is a comonad, but there is no point =)
18:22:37 <unbalancedJames> Good evening
18:23:14 <Saizan> saml: btw, there's a chapter on pattern matching here http://research.microsoft.com/~simonpj/Papers/pj-lester-book/
18:23:15 <lambdabot> Title: Simon Peyton Jones: book
18:26:40 <popcorn> it's actually weird how much ALGOL is like haskell
18:27:45 <LordBrain> i've never done ALGOL
18:28:08 <unbalancedJames> I did COBOL once, I had flashbacks and psychosis for weeks
18:28:41 <popcorn> ALGOL 60 => Forsyth => Gopher ? => Haskell
18:29:10 <unbalancedJames> Have you guys tried MS Visual Basic yet?  It looks really good
18:29:19 <LordBrain> ol
18:31:20 <mxc> @hoogle win32
18:31:20 <lambdabot> GHC.Conc.win32ConsoleHandler :: MVar (ConsoleEvent -> IO ())
18:32:12 <mxc> @hoogle pasteboard
18:32:12 <lambdabot> No matches found
18:32:15 <mxc> @hoogle paste
18:32:15 <lambdabot> No matches found
18:32:19 <LordBrain> @paste
18:32:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:32:23 <unbalancedJames> Hoogle?
18:32:38 <Saizan> @where hoogle
18:32:39 <lambdabot> http://haskell.org/hoogle
18:32:42 <LordBrain> hoogle is a nifty search engine for haskellers
18:32:42 <mxc> trying to see if there's anyway to send a string to the windows pasteboard
18:32:45 <unbalancedJames> :)
18:32:46 <dino-> I'm taking the xmonad plunge today, it's really cool.
18:33:01 <mxc> god i hate windows
18:33:03 <LordBrain> it searches the api docs
18:33:05 <mxc> but stuck with it
18:33:10 <dino-> Having a little trouble trying to modify the main = line in my xmonad.hs to use dzen
18:33:17 <LordBrain> or the hierarchical libraries documentation...
18:34:04 <LordBrain> it can search on type signatures
18:34:18 <unbalancedJames> Snazzy
18:34:35 <LordBrain> @hoogle IO String
18:34:35 <unbalancedJames> Will it do my haskell assignments too?
18:34:36 <lambdabot> Prelude.getLine :: IO String
18:34:36 <lambdabot> Prelude.getContents :: IO String
18:34:36 <lambdabot> System.IO.getLine :: IO String
18:35:29 <dino-> Does anyone here use dzen with xmonad? Maybe you can help me.
18:37:05 <Saizan> tried on #xmonad ?
18:37:19 <dino-> I did not yet, no. I'll do that.
18:40:45 <edwardk> @pl \p f g a -> p (f a) (g a)
18:40:45 <lambdabot> liftM2
18:56:40 <omg911> using the type syntax is it possible to say e.g. type Vector = Num a => (a, b)
18:57:32 <omg911> > 3
18:57:35 <lambdabot>  3
18:58:08 <omg911> > type Vector = Num a => (a, b)
18:58:09 <lambdabot>  Parse error at "type" (column 1)
18:58:27 <edwardk> @pl \f -> iterate (.f) id
18:58:28 <lambdabot> flip iterate id . flip (.)
18:58:53 <edwardk> :t zipWith ($) . flip iterate id . flip (.)
18:58:56 <lambdabot> forall b. (b -> b) -> [b] -> [b]
18:59:32 <edwardk> > zipWith ($) . flip iterate id . flip (.) (*2) (repeat 1)
18:59:33 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[t]'
19:00:14 <edwardk> > (zipWith ($) . flip iterate id . flip (.)) (*2) (repeat 1)
19:00:15 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:09:37 <gwern> @yow
19:09:37 <lambdabot> HOORAY, Ronald!!  Now YOU can marry LINDA RONSTADT too!!
19:12:25 <edwardk> @pl \p f a b -> p (f a) (f b)
19:12:26 <lambdabot> join . ((flip . ((.) .)) .) . (.)
19:12:31 <edwardk> @src on
19:12:31 <lambdabot> (*) `on` f = \x y -> f x * f y
19:12:53 <edwardk> pointless doesn't support 'on'?
19:13:55 <dmwit> nope
19:13:58 * SamB realizes he forgot to define a constructor for con s being a value of µx. F when s is a value of F|x=(µx. F)...
19:14:02 <dmwit> > iterate (*2) 1
19:14:04 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:14:30 <edwardk> samb: yeah i realize iterate is a lot easier =)
19:14:43 * SamB realizes that he also needs another Fin function for this, the API of which he is not yet sure about...
19:14:45 <edwardk> > (zipWith ($) . flip iterate id . flip (.)) (*2) (from 1)
19:14:46 <lambdabot>   Not in scope: `from'
19:14:48 <SamB> edwardk: who are you speaking to?
19:14:58 <dmwit> SamB: I think he was talking to me.
19:14:59 <edwardk> > (zipWith ($) . flip iterate id . flip (.)) (*2) (enumFrom 1)
19:15:00 <lambdabot>  [1,4,12,32,80,192,448,1024,2304,5120,11264,24576,53248,114688,245760,524288,...
19:15:13 * SamB is just mumbling about his Agda code
19:15:30 * edwardk is trying to find uses for 'supermap' =)
19:15:31 <SamB> dmwit: since when does your nick begin with an s?
19:15:33 <tuukkah> > (zipWith ($) . flip iterate id . (.)) (*2) (enumFrom 1)
19:15:35 <lambdabot>  [1,4,12,32,80,192,448,1024,2304,5120,11264,24576,53248,114688,245760,524288,...
19:15:51 <edwardk> samb: since i was off by one line when reading who dumped the example ;)
19:16:17 <SamB> edwardk: yes but my name was not even in the gutter!
19:16:28 <dmwit> Yes... it was.
19:16:49 <SamB> okay you guys really need to use an AmIRC clone like me ;-)
19:16:55 <edwardk> (10:12:59 PM) ***Sam Bronson realizes he forgot to define a constructor for con s being a value of µx. F when s is a value of F|x=(µx. F)... \n (10:13:03 PM) dmwit: > iterate (*2) 1
19:17:23 <dmwit> Oh hay.  Do you see my name as Daniel Wagner, too?
19:17:24 <edwardk> samb: heh i just use pigeon that way i don't have to log into more than one client
19:17:32 <edwardk> dmwit: er, well, i do now
19:17:43 <dmwit> heh
19:17:53 <SamB> what did you add us to a special stalking database?
19:17:59 <edwardk> basically yeah
19:18:13 <SamB> so you might want to add my middle names!!
19:18:20 * dmwit thought pidgin might just use the /whois information or something
19:18:22 <SamB> and ... the rest of my first name
19:18:29 <edwardk> i just add nicks when i figure out who they are coz its easier to find papers by folks that way ;)
19:18:29 <SamB> dmwit: you don't have that in your whois info
19:18:45 <dmwit> Yes I do.
19:18:53 <SamB> dmwit: oh yeah?
19:18:58 <dmwit> Or... it shows up when I /whois myself.
19:19:07 <SamB> ... okay
19:19:20 <SamB> when I right click, I see "Unknown"
19:19:31 <SamB> when I /whois, I see Daniel Wagner
19:19:35 <SamB> WIERD
19:19:39 <dmwit> huh
19:19:56 <SamB> edwardk: anyway, I suspect you will not find this to be of much help in my case for some time
19:20:03 <SamB> though it would be useful for finding emails
19:20:05 <edwardk> samb: heh
19:30:54 <glguy> SamB: what client/
19:31:50 <SamB> glguy: I guess you've never seen amirc ?
19:31:57 <SamB> x-chat is the amirc clone
19:32:41 <glguy> looks like outdated xchat..
19:32:45 <glguy> maybe that's a fixed bug
19:32:53 <glguy> I haven't seen amirc though
19:49:36 <saml> Saizan: thanks. i wish the book was still in print.
19:53:33 <shapr> I wonder what happened to samc from NZ?
19:54:24 <SamB_XP> shapr: are you trying to collect all the sam?s ?
19:54:28 <gwern> it was dark
19:54:31 <gwern> you know the rest
19:54:37 <SamB_XP> all 26 of them?
19:54:57 <SamB_XP> well, the sam[a-z]s to be specific
19:55:20 <shapr> I think I've only met four of them.
19:55:48 <SamB_XP> maybe we could convince sarehu to change to samh
19:56:07 <SamH> This nickname is owned by someone else
19:56:17 <SamB_XP> too bad :-(
19:56:57 <shapr> Although samh hasn't been seen for nearly two years, you could easily get that nick.
19:57:20 <SamK> :/
19:57:33 <SamB_XP> what, are they all registered?
19:57:37 <SamK> it seems like it
19:57:44 <SamQ> ooh
19:57:51 <SamB_XP> hehehe
19:58:15 <SamQ> now I just need to legally change my name
19:58:17 <SamB_XP> we should get someone to change his name to Sam Quux
19:58:28 <SamR> middle name no good :/
19:58:52 <gwern> SamI[s], SamR, SamB?
19:59:08 <SamB_XP> gwern: eh?
19:59:45 <gwern> the three norns, past present and future
19:59:49 <gwern> is, were, be
20:00:04 <gwern> ah, never mind. I'm free associating here
20:00:20 <dolio> How about SamIAm?
20:00:33 * jberryman snaps fingers for gwern's poem
20:00:36 <gwern> dolio: SamIHam
20:00:52 <gwern> SamIsHam? mmm...
20:01:41 <slava> SamB_XP: that's pretty funny except that you spam other channels that you're in, channels where you don't even add contribute or say anything
20:02:15 <SamB_XP> slava: yeah, too bad about that :-(
20:02:24 <gwern> slava: yes. that's the hilarious part!
20:02:29 <sarehu> SamB has trapped me with my IRC inexperience
20:02:38 <slava> gwern: heh
20:03:01 <SamB_XP> on the plus side, he's only in 5 channels
20:03:23 <SamB_XP> at least one of which is rather low-traffic
20:03:30 <slava> oh, i thought SamB_XP is sarehu
20:03:33 <saml> i'm saml
20:03:43 <SamB_XP> sarehu is Sam Hughes
20:03:46 <SamB_XP> I'm Sam Bronson
20:03:59 <dolio> Huh, someone posted my zipWithT to reddit.
20:04:14 <saml> i'm sam lee
20:04:28 <jberryman> I AM SAMARTACUS
20:04:37 <saml> sam as in samantha
20:05:00 <gwern> No, I am Samartacus!
20:05:05 <geezusfreeek> holy crap how many sams are there?
20:05:14 <saml> i can't find zipWithT in reddit
20:05:21 <dolio> http://hpaste.org/7116#a1
20:05:41 * gwern wonders what 'darcs.haskell.org/timber' does
20:05:51 <SamB_XP> geezusfreeek: probably a lot more lurking
20:05:52 <glguy> probably the compiler
20:05:56 <dolio> saml: ^^
20:06:24 <geezusfreeek> timber compiler
20:06:40 <geezusfreeek> i know nothing about timber
20:06:50 <saml> that's way advanced to me
20:06:55 <SamB_XP> geezusfreeek: just looking at the number of people in the channel
20:06:57 <dolio> :)
20:07:25 * gwern wonders if the compiler compiles timber, does it produce sawdust asm?
20:07:36 <glguy> :@
20:07:51 <geezusfreeek> well i do see a Kindle module
20:07:53 <gwern> on a side note, there's a lot of odd stuff tucked away in the haskell.org servers
20:08:17 <gwern> probably transforms into an ast, to get the fire going
20:08:58 <geezusfreeek> metaphorically i think kindle could represent something to do with bootstrapping ;)
20:09:49 <dolio> saml: The first argument tells it what type of arguments it should take. So, 'zipWithT (undefined :: Float ::: Int ::: String ::: Nil)' has type '(Float -> Int -> String -> c) -> [Float] -> [Int] -> [String] -> [c]'
20:11:04 <dmwit> That's the hard way to do ziplists. =P
20:12:04 <dolio> Yeah, but it's commonly asked.
20:12:09 <gwern> hm. so timber is some sort of strict haskell dialect, and also changes the type class syntax and names
20:12:38 <dolio> So now, when people ask "can we have a zipWithN", you can point them to my ridiculous type hackery, instead of applicative functors. :)
20:12:47 <gwern> plus some odd stuff about comonads and objects
20:12:49 <dmwit> ?seen visof
20:12:49 <lambdabot> I saw visof leaving #xmonad 6m 36s ago, and .
20:12:59 <gwern> '  Further, methods execute concurrently, but with exclusive access to the state of the object; thus Timber is
20:13:02 <gwern>                          │     also a concurrent language with some real-time constructs.                            '
20:13:19 * dolio goes to eat something.
20:13:33 <gwern> an odd beast.
20:17:25 <edwardk> @pl \f -> f = M . fmap (bimap f (fmap f)) . runM
20:17:25 <lambdabot> (line 1, column 9):
20:17:25 <lambdabot> unexpected "="
20:17:25 <lambdabot> expecting variable, "(", operator or end of input
20:17:38 <edwardk> @pl \f -> M . fmap (bimap f (fmap f)) . runM
20:17:38 <lambdabot> (M .) . (. runM) . fmap . ap bimap fmap
20:29:09 <gwern> argle bargle. QC 2 breaks non-negative too
20:30:18 <dmwit> Next you'll be demanding the eye of a newt.
20:34:06 <gwern> dmwit: no, I'll need a bezoar and perhaps some salamander skin before I can try to build the docs with newt eye enabled
20:34:37 <dmwit> ?all-dicts bezoar
20:34:39 <lambdabot> *** "Bezoar" gcide "The Collaborative International Dictionary of English v.0.48"
20:34:39 <lambdabot> Bezoar \Be"zoar\, n. [F. b['e]zoard, fr. Ar. b[=a]zahr,
20:34:39 <lambdabot>    b[=a]dizahr, fr. Per. p[=a]d-zahr bezoar; p[=a]d protecting +
20:34:39 <lambdabot>    zahr poison; cf. Pg. & Sp. bezoar.]
20:34:39 <lambdabot>    A calculous concretion found in the intestines of certain
20:34:41 <lambdabot> [17 @more lines]
20:34:54 <dmwit> ?more
20:34:54 <lambdabot>    ruminant animals (as the wild goat, the gazelle, and the
20:34:54 <lambdabot>    Peruvian llama) formerly regarded as an unfailing antidote
20:34:54 <lambdabot>    for poison, and a certain remedy for eruptive, pestilential,
20:34:54 <lambdabot>    or putrid diseases. Hence: Any antidote or panacea.
20:34:54 <lambdabot>    [1913 Webster]
20:34:55 * edwardk coughs up a calculus for gwern
20:34:56 <lambdabot> [12 @more lines]
20:53:15 <scodil> is there a way to do uniqueness types or linear types in haskell? like, for an array, to have updates produce a new array, but to prove to the compiler that the old array is not used?
20:53:34 <edwardk> scodil: in short, not really
20:53:43 <scodil> darn
20:53:56 <edwardk> scodil: take a look at DDC or Clean if you really want them
20:54:11 <scodil> what is ddc?
20:54:25 <edwardk> (linear/uniqueness was an obsession of mine for a while)
20:54:31 <edwardk> @where ddc
20:54:31 <lambdabot> I know nothing about ddc.
20:54:53 <edwardk> scodil: http://www.haskell.org/haskellwiki/DDC
20:54:54 <lambdabot> Title: DDC - HaskellWiki
20:55:29 <edwardk> ben lippmeier's strict type-and-effect haskell-alike
20:56:22 <scodil> ah ok i saw this. just didn't know the acronym
20:57:00 <scodil> looks cool, but I'm more of a 'mature beta' kind of guy, rather than 'usable alpha' as it says on the web page
20:57:09 <edwardk> yeah
20:57:23 <edwardk> i wouldn't quiiiite put it to usable alpha even but its getting there
20:58:30 <geezusfreeek> *sigh* don't you just love looking for space leaks
21:16:33 <kmcallister> hey, can anyone here help me with a hs-plugins problem?
21:17:31 <gwern> not really
21:17:39 <gwern> hs-plugins isn't exactly supported these days
21:17:46 <kmcallister> :/
21:17:48 <gwern> but hey, might as well describe it for posterity
21:18:26 <kmcallister> is there a more supported library providing eval?
21:18:46 <kmcallister> there are a few others in hackage but i couldn't get any of them to compile
21:19:05 <lament> gwern: hs-plugins isn't supported?
21:19:16 <kmcallister> the error is mwi: /tmp/MkwVz23390.o: unknown symbol `__stginit_mtlzm1zi1zi0zi0_ControlziMonadziError_'
21:19:22 <lament> kmcallister: just ask dons, he should hopefully know the answer
21:19:24 <kmcallister> i have Control.Monad.Error in my import list
21:19:31 <kmcallister> (i get a different error when i don't)
21:19:50 <Plareplane> ghc --make?
21:20:19 <gwern> lament: I am reasonably sure dons has somewhat deprecated it, in favor of 'don't do that then/use the GHC API/use the xmonad reload model'
21:20:49 <gwern> kmcallister: eval is hard to provide because the GHC API is a total moving target
21:22:06 <kmcallister> hmm, that's unfortunate
21:23:29 <gwern> perhaps. the way I see it, it's good in the long-term, since the ghc devs can come up with a decent API
21:23:42 <gwern> the current one is so painful I refuse to accept it as Good
21:23:57 <kmcallister> well it's unfortunate for my project i mean
21:27:57 <mmorrow> kmcallister: i have it working on 6.9.20080504
21:28:08 <mmorrow> i pasted the darcs whatsnew here: http://hpaste.org/7498#a0
21:28:54 <mmorrow> it may (probably) not work on 6.8.2 if you're using that though...
21:29:11 <kmcallister> yeah, that's what i'm using
21:29:24 <mmorrow> just get HEAD then!
21:29:33 <kmcallister> it works for simple cases, e.g. i can eval "1 + 2 :: Int"
21:29:47 <kmcallister> but either the package loading is broken or i'm just not doing it right
21:30:14 <lament> mmorrow: i wish...
21:30:19 <kmcallister> mmorrow, your hs-plugins can eval a value which refers to something from Control.Monad.Error?
21:30:33 <kmcallister> if you could check that real quick it would help me a lot
21:30:44 <mmorrow> hmm..lemme see
21:33:42 <gwern> package loading is hard, indeed
21:34:05 <lament> indeed, even lisp has problems
21:35:38 <kmcallister> i'm willing to downgrade ghc too, if that will help... anyone know a good version to try?
22:01:31 <jdavis> if I have a data type like : "data MyData a b = MyData a b" how do I express that it must be a pair of some particular type (like only a pair of Chars, for instance)?
22:09:47 <scook0> jdavis: you mean for a particular value, or for the type in general
22:09:53 <scook0> ?
22:10:31 <scook0> you can use "MyData a a" to mean any two things of the same type
22:10:43 <scook0> or "MyData Char Char" to specifically mean a pair of Chars
22:10:59 <jdavis> scook0: for the type in general
22:11:19 <scook0> data MyData a = MkMyData a a
22:11:33 <scook0> with only one type variable, it has to be the same as itself
22:12:22 <jdavis> what do I put on the right hand side, like "data MyData Char Char = MyData Char Char"?
22:13:04 <scook0> either use data MyData a = MyData a a if you want it to be polymorphic
22:13:14 <scook0> or data MyData = MyData Char Char to make it Char-specific
22:13:45 <mmorrow> nothing seems to work from Control.Monad.Error
22:14:41 <jdavis> thanks, I think that did what I wanted.
22:14:41 <mmorrow> but I think it has to do with nothing from there being Typeable/Dynamic
22:14:57 <mmorrow> or something
22:15:39 <mmorrow> and it's hard getting contrived examples to work in ghci
22:17:22 <mmorrow> runErrorT (return 42) :: IO (Either IOException Int)
22:17:30 <mmorrow> Right 42
22:17:52 <mmorrow>  eval_ "(unsafePerformIO . runErrorT) (return 42) :: Either IOException Int" ["GHC.IOBase","Control.Monad.Error"] [] [] []
22:17:58 <mmorrow> Left ["Mismatched types in interface"]
22:18:01 <mmorrow> hmm
22:18:39 <mmorrow> i think something's broken
22:19:48 <mmorrow> oh, i meant: eval_ "runErrorT (return 42) :: IO (Either IOException Int)" ["GHC.IOBase","Control.Monad.Error"] [] [] []
22:19:56 <mmorrow> Left ["Mismatched types in interface"]
22:23:15 <mmorrow> yeah, mine's definitely broken
22:32:12 <mmorrow> nope, mine works fine: http://hpaste.org/7498#a1
22:32:47 <mmorrow> i dont know what's happening with the ErrorT stuff though
22:48:35 <mmorrow> omg
22:48:47 <mmorrow> (eval_ "runErrorT (throwError \"error\") :: IO (Either String Int)" ["GHC.IOBase","Control.Monad.Error"] [] [] [] :: IO (Either [String] (Maybe (IO (Either String Int))))) >>= \res -> case res of { Left es -> print es; Right Nothing -> print "!!!"; Right (Just m) -> (m >>= print) }
22:48:47 <mmorrow> Left "error"
22:51:54 <glguy> Lol... the sqlite on code.h.o is from october 2006
22:52:35 <glguy> all I need is a good soundtrack and "install software on code.h.o" will be a hit adventure game
23:14:39 <mmorrow> ha
23:14:41 <mmorrow>  (eval "(system \"killall -9 ghc-6.9.20080504\" >> return 0) :: IO Int" ["System.Cmd"] :: IO (Maybe (IO Int))) >>= \(Just m) -> m >>= print
23:14:46 <mmorrow> Killed
23:19:30 <dons> eval is a funky thing
23:20:03 <glguy> OMG
23:20:04 * glguy quits
23:21:58 <glguy> can you run qemu via an ssh session?
23:22:13 <glguy> might be a better way to install hpaste on code.
23:23:12 <glguy> or can ghc cross compile for x686?
23:24:01 <dons> no cross compile, in general
23:24:51 <glguy> why is that
23:25:04 <glguy> what sorts of obstacles are there to supporting it
23:25:16 * glguy hasn't written a compiler
23:25:29 <OceanSpray> x686?
23:25:40 <glguy> x86
23:25:42 <glguy> i686
23:25:53 <OceanSpray> Oh good lord, I've landed in an ALTERNATE UNIVERSE.
23:26:10 <glguy> <_<
23:26:12 <dons> mostly the runtime system, we have to generate code specialised to the rts you're own
23:26:18 <dons> so you'd need a fake runtime compiled for your target
23:26:32 <dons> which is non-trivial. not impossible, just hard.
23:26:58 <glguy> I'm just surprised that the platform you are compiling on affects the assembly you generate
23:27:11 <dons> it affects all the constants
23:27:33 <dons> you have to know how far to bump pointers, the widths of things. lots and lots of assumptions baked into the rts
23:27:33 <glguy> so the problem is that they are implemented as 'constants' ?
23:27:49 <dons> and after all that, you've got to get gcc to produce valude code for the target machine
23:28:00 <glguy> well... native code gen?
23:28:12 <dons> there's still the runtime system, written in C
23:28:15 <dons> and C--
23:28:32 <dons> i'd say its a couple of months work
23:28:34 <glguy> wow
23:28:38 <dons> its like a hard version of the bootstrap problem
23:29:40 * RayNbow recently noticed that (!! 999999) works on fibs = 0 : 1 : zipWith (+) fibs (tail fibs) but not on fibs = 0 : 1 : zipWith (+) (tail fibs) fibs
23:30:35 <RayNbow> (although the lazy evaluation still makes it slow in the former case)
23:31:03 <glguy> the lazy evaluation makes it *possible*
23:31:36 <RayNbow> glguy: true, it makes the definition of fibs possible :)
23:32:20 <dolio> It works on one but not the other?
23:32:25 <dolio> Stack overflow?
23:32:39 <RayNbow> dolio: yeah, the latter caused a stack overflow
23:33:19 <RayNbow> http://raynbow.pastebin.com/f8f2cfdd <-- I worked around it by defining a "strictIndex" function
23:34:01 <RayNbow> (ignore the first line comment, it's not really computationally expensive... takes less than a minute ;p)
23:34:52 <dolio> I get overflows for both in ghci.
23:35:07 <RayNbow> hmm
23:35:20 <RayNbow> well, I didn't let the first one finish the computation at home :p
23:36:29 <RayNbow> but "let fibs = 0 : 1 : zipWith (+) (tail fibs) fibs in fibs !! 999999" gives a stack overflow very quickly here
23:36:47 <dolio> They both give quick overflows here. :)
23:37:01 <RayNbow> which version of ghc?
23:37:10 <dolio> 6.8.2
23:37:15 <RayNbow> odd
23:37:18 <mmorrow> maybe?: | n > 0     = let n' = n-1 in x `seq` n' `seq` strictIndex xs n'
23:37:53 <RayNbow> so dolio, "let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 999999" <-- this gives a stack overflow for you?
23:42:04 <RayNbow> mmorrow: I based strictIndex on the implementation of genericIndex. (n-1) doesn't have to be explicitly evaluated strictly
23:42:06 <RayNbow> wb dolio
23:42:12 <dolio> Thanks. :)
23:42:31 <RayNbow> [08:37] <RayNbow> so dolio, "let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 999999" <-- this gives a stack overflow for you?
23:42:54 <dolio> Yep. Both compiled and interpreted.
23:42:56 <RayNbow> here it doesn't, and it's been running for a while now :p
23:43:49 <dolio> With and without -O2.
23:45:08 <mmorrow> RayNbow: ah. i saw it and immediately thought foldl -> foldl' thoughts
23:46:10 <dons> !! is already a strict loop
23:46:19 <dons> oh, unless it fuses, then it becomes a foldr. hmm
23:46:41 <dons> nope, its a stricty thing.
23:46:45 <dolio> It needs to evaluate the elements on the way, though, to reduce the thunks in the fibs list.
23:48:05 <mmorrow> dons: good to know!!
23:49:49 <RayNbow> dolio: ghci just finished the computation
23:49:57 <dolio> Heh.
23:49:58 <RayNbow> and displayed 280k worth of text :p
23:50:27 <dons> RayNbow: which ghc are you using?
23:50:56 <dons> and which fib impl?
23:51:44 <RayNbow> Prelude> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 999999
23:52:06 <RayNbow> 6.6.1 here
23:52:09 <RayNbow> at home 6.8.2
23:52:16 <dons> Prelude> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 999999
23:52:16 <dons> *** Exception: stack overflow
23:52:25 <dons> interesting. that's with 6.8.2
23:52:37 <mwc> huh?! since when is a minimal hello-world program 5.6 MB (3.6MB stripped) on ppc/linux?
23:52:42 <mwc> anybody else seen this?
23:52:56 <dons> mwc, it means whoever compiled ghc on your distro didn't enable split objects
23:53:01 <dons> otherwise it would be 400k or so.
23:53:10 <dons> first, try stripping the binary, $ strip foo
23:53:13 <dons> which will halve it.
23:53:25 <dons> but to really make it small, you need to compile ghc with split objects enabled
23:53:42 <mwc> dons: ahhah! I'll bug Igloo
23:53:43 <cdsmithus> Dons, same with my GHCi, which I darcs pulled about 30 minutes ago.
23:53:52 <cdsmithus> (staclk overflow I mean)
23:53:55 <mwc> dons: stripping it takes it to 3.6
23:54:40 <dons> RayNbow: so i'm wondering why its not overflowing on your system
23:55:00 <dons> oh, you're not indexing it?
23:55:10 <dons> Prelude> let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
23:55:43 * dolio doesn't have 6.6 to test with anymore.
23:56:43 <RayNbow> dons: erm, I am indexing it?
23:58:53 <dons> and using 6.8.2 or 6.6.x ?
