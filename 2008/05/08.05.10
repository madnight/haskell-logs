00:15:27 <dmwit> Okay, so, just to verify:
00:15:35 <dmwit> A call to seq still forms a thunk, right?
00:17:30 <mrd> i haven't thunk about it before
00:22:57 <ndm> dmwit: yes, it does
00:23:12 <ndm> dmwit: although in optimised code, the chances of finding a call to seq are fairly low
01:43:48 <schme> Hrm.. Playing around a bit with haskell here and it turns out that vim indents my code very much not like the examples I am looking at. Anyone know of a good fix for this?
01:54:12 <bd_> schme: fwiw, the relevant portions of my vimrc are:
01:54:18 <bd_> filetype plugin indent on
01:54:18 <bd_> filetype indent on
01:54:18 <bd_> set ts=4 sw=4 noet modeline
01:54:24 <bd_> autocmd FileType haskell
01:54:24 <bd_>   \ setlocal et ai
01:56:54 <schme> Aha. I'll look into that, thanks bd_
01:58:47 <bauchus> is there a `floor_float :: Double -> Double'? e.g. I cannot calculate `pi - floor pi'
01:59:39 <vixey> :t pi
01:59:43 <lambdabot> forall a. (Floating a) => a
01:59:56 <vixey> :t fromRational . floor
01:59:58 <lambdabot>     No instance for (Integral Rational)
01:59:58 <lambdabot>       arising from a use of `floor' at <interactive>:1:15-19
01:59:58 <lambdabot>     Possible fix: add an instance declaration for (Integral Rational)
02:00:01 <vixey> :t fromIntegral . floor
02:00:04 <lambdabot> forall b a. (RealFrac a, Num b) => a -> b
02:00:27 <vixey> > pi - (fromIntegral.floor) pi
02:00:30 <lambdabot>  0.14159265358979312
02:01:10 <vixey> yeah you can do that
02:01:10 <vixey> It's not usual to name things in haskell with _'s though
02:04:47 <bd_> > let a_b = 1 in a_b
02:04:49 <lambdabot>  1
02:04:52 <bd_> > let _b = 1 in _b
02:04:54 <lambdabot>  1
02:04:55 <bd_> huh
02:05:59 <vixey> > let bd_ = 1 in bd_
02:06:01 <lambdabot>  1
02:16:24 <mehrheit> is there a simple way to get number of miliseconds elapsed from some arbitrary constant time x?
02:17:53 <profmakx> mehrheit, 5?
02:20:19 <mehrheit> profmakx, the function should return different values in IO depending on the time of the call
02:20:50 <profmakx> hm
02:22:14 <profmakx> System.Posix.Process.getProcessTimes perhaps?
02:24:29 <dolio> Data.Time.Clock.diffUTCTime
02:26:09 <ndm> @hoogle getCPUTime
02:26:10 <lambdabot> System.CPUTime.getCPUTime :: IO Integer
02:26:25 <ndm> mehrheit: if you want to time something, that is often a good way to go
02:26:49 <dolio> I'm not sure how you get seconds out of a NominalDiffTime. It seems to be abstract.
02:28:17 <dolio> I guess you could use toRational or something.
02:28:25 <mehrheit> isn't CPUTime dependent on the CPU (and variable with load or CPU speed) instead of the system clock?
02:38:25 <dolio> Huh, that CPUTime module is interesting.
02:38:26 <mercury^> "The approxRational function, applied to two real fractional numbers x and epsilon, returns the simplest rational number within the open interval (x-epsilon, x+epsilon)"
02:39:17 <mercury^> But the implementation from the report returns the simplest rational within the closed interval [x-epsilon, x+epsilon]
02:46:41 <mercury^> http://rohanlean.de/pub/approxRational_simplest.hs there is a fixed definition of the simplest' helper function
03:12:46 <dcoutts> dons: aye, concerning
03:14:45 <funktio> @pl \[a,b,c,d] -> ((a,b),(c,d))
03:14:46 <lambdabot> (line 1, column 2):
03:14:46 <lambdabot> unexpected "["
03:14:46 <lambdabot> expecting pattern
03:14:59 <funktio> @pl \a b c d -> ((a,b),(c,d))
03:14:59 <lambdabot> flip flip (,) . (((.) . (.) . (,)) .) . (,)
03:17:05 <RayNbow> @pl \(a:b:c:d:[]) -> ((a,b),(c,d))
03:17:05 <lambdabot> (line 1, column 11):
03:17:05 <lambdabot> unexpected "["
03:17:05 <lambdabot> expecting "()", natural, identifier, "_" or "("
03:17:27 <RayNbow> oh, it doesn't like desugared lists either :p
03:20:28 <dolio> @type (curry .) . (curry . curry $ id)
03:20:30 <lambdabot> forall a b a1 b1. a1 -> b1 -> a -> b -> ((a1, b1), (a, b))
03:25:17 <funktio> @type (curry .) . (curry (,))
03:25:19 <lambdabot> forall a b a1 b1. a1 -> b1 -> a -> b -> ((a1, b1), (a, b))
03:26:58 <EvilTerran> > ((&&&) <*> (.tail.tail)) (((&&&) <*> (.tail)) head) [1..]
03:27:00 <lambdabot>  ((1,2),(3,4))
03:27:09 <EvilTerran> ph33r
03:28:48 <EvilTerran> ((&&&) <*> (.f)) g x = (g x, g (f x))
03:31:16 <EvilTerran> i may be able to make that even shorter by extracting the duplicated ((&&&) <*>)
03:33:23 <EvilTerran> @pl \(a:b:c:d:_) -> ((a,b),(c,d))
03:33:28 <lambdabot> ap (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . (((.) . (const .)) .)) .) . flip flip (,) . (((.) .
03:33:28 <lambdabot>  (.) . (,)) .) . (,) . head) tail
03:33:28 <lambdabot> optimization suspended, use @pl-resume to continue.
03:33:32 <EvilTerran> dear lord
03:33:35 <EvilTerran> @pl-resume
03:33:37 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . (((.) . (const .)) .)) .) . flip flip (,) . (((.) .
03:33:37 <lambdabot> (.) . (,)) .) . (,) . head) tail
03:33:46 <Valodim> hahaha
03:33:49 <Valodim> yeah right
03:36:17 <cpoucet> o.O
03:36:31 <cpoucet> wow
03:37:18 <mehrheit> @pl \o O x -> o (O x)
03:37:21 <lambdabot> (.)
03:38:11 <cpoucet> @pl \x -> o (O x)
03:38:12 <lambdabot> o . O
03:38:39 <vixey> hehe
03:39:50 * EvilTerran ponders sensible definitions for the operators (-.-), (>.>), (<.<), and (>.<)
03:41:18 <EvilTerran> ... also (^.^)
03:41:42 <vixey> (^.^) = liftA2
03:42:02 <EvilTerran> or liftA2 (.) ?
03:42:09 <xerox> (>.<) = undefined -- I'd make
03:45:33 <cpoucet> @let (...) = o . (var "O")
03:45:34 <lambdabot> Couldn't match expected type `a -> b' against inferred type `Expr'
03:45:45 <cpoucet> @let (...) = fun "o" . (fun "O") :: Expr
03:45:46 <lambdabot> Couldn't match expected type `Expr' against inferred type `f b'
03:45:51 <cpoucet> @let (...) = fun "o" . (fun "O") :: Expr -> Expr
03:45:52 <lambdabot> Add a type signature
03:45:58 <cpoucet> bah
03:46:16 <cpoucet> > o . O
03:46:17 <lambdabot>   Not in scope: data constructor `O'
03:46:24 <cpoucet> > o . (fun "O")
03:46:25 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Expr'
03:46:28 <cpoucet> :|
03:46:34 <EvilTerran> ?type fun
03:46:36 <lambdabot> forall a. (FromExpr a) => String -> a
03:46:48 <cpoucet> @more fun
03:46:51 <EvilTerran> ?instances FromExpr
03:46:56 <lambdabot> Couldn't find class `FromExpr'. Try @instances-importing
03:47:02 <vixey> > o . (fun "O") :: Expr -> Expr
03:47:03 <lambdabot>  Couldn't match expected type `a -> Expr'
03:47:03 <cpoucet> EvilTerran: it's the thing from twanvl
03:47:12 <EvilTerran> yeah, i know
03:47:13 <vixey> > fun "o . O"
03:47:14 <mehrheit> @have fun
03:47:14 <lambdabot>  Add a type signature
03:47:14 <lambdabot> Not enough privileges
03:47:20 <cpoucet> > var "o . O"
03:47:21 <lambdabot>  o . O
03:47:25 <cpoucet> but that ain't as fun
03:47:32 <cpoucet> bah, poor pun unintended
03:47:51 <EvilTerran> > fun "o" . fun "O" $ var "wtf?"
03:47:52 <lambdabot>  Add a type signature
03:47:55 <EvilTerran> > fun "o" . fun "O" $ var "wtf?" :: Expr
03:47:55 <lambdabot>  Add a type signature
03:47:58 <EvilTerran> ...
03:48:17 <cpoucet> > var "you suck"
03:48:19 <lambdabot>  you suck
03:48:49 <EvilTerran> ?type f
03:48:51 <lambdabot> forall a. (FromExpr a) => a
03:48:54 <EvilTerran> ?type x
03:48:55 <lambdabot> Expr
03:49:04 <EvilTerran> hm
03:49:58 <cpoucet> > fun "f" :: Expr
03:50:00 <lambdabot>  f
03:50:11 <cpoucet> > (fun "f" . fun "b" ):: Expr
03:50:12 <lambdabot>  Couldn't match expected type `Expr' against inferred type `f b'
03:50:23 <cpoucet> inferred type 'f b' lol
04:45:20 <cnwdup> catch (func1) (\_ -> func2) with func1 :: IO Int and func2 :: IO Int should return func2's Int if func1 fails, right?
04:46:46 <augustss> yes
04:47:04 <augustss> if computing func1 to whnf fails
04:47:42 <cnwdup> Any suggestion why this then still raises an exception: http://hpaste.org/7523 ?
04:48:14 <cnwdup> pix' is valid as io $ pixbufNewFromFile nocover does not fail. I don't know why I still get main: exception :: System.Glib.GError.GError
04:48:49 <wjt> are you using the right catch?  IIRC there are two, and one of them only catches a small set of exceptions
04:48:52 <wjt> @index catch
04:48:53 <lambdabot> Control.Exception, System.IO.Error, Prelude
04:49:12 <cnwdup> What does "small set" mean?
04:49:22 <cnwdup> Does it mean that it doesn't match all exceptions?
04:49:24 <wjt> From Control.Exception.catch's documentation:
04:49:27 <wjt> >>> Also note that The Prelude also exports a function called catch which has the same type as catch, the difference being that the Prelude version only catches the IO and user families of exceptions (as required by Haskell 98). We recommend either hiding the Prelude version of catch when importing Control.Exception, or importing Control.Exception qualified, to avoid name-clashes.
04:49:46 <cnwdup> I'll try that. (-:
04:49:56 <maltem> @type Prelude.catch
04:49:58 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
04:50:03 <maltem> @type Control.Exception.catch
04:50:05 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
04:50:21 <wjt> @type System.IO.Error.catch
04:50:22 <maltem> (So the type also reflects what exceptions may be caught.)
04:50:24 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
04:50:29 <cnwdup> Great. Using Control.Exception.catch is working. (-:
05:49:56 <schme> So.. is there a tutorial or book about actually doing anything practical with haskell?
05:50:52 <vixey> yes
05:51:05 <schme> Where? :)
05:51:19 <vixey> um actually the one I was thiking of is not finished, but there's lots
05:51:21 <vixey> 1 sec
05:51:41 <vixey> yeah this is in development http://book.realworldhaskell.org/beta/
05:51:42 <lambdabot> Title: Real World Haskell
05:51:46 <schme> I tried the gentle introduction and the wikibook one. I mean they're not bad reading.. just a bit.. "uh ok" :)
05:51:54 <schme> Ah cools.
05:51:57 <vixey> yeah  I know what you mean
05:52:22 <schme> Thansk a lot, vixey. I'll bookmark that.
05:52:25 <vixey> I think you just get some basiacs and then  learn by need as you write a more realistic program
05:53:07 <vixey> there's lots of little tutorials about specific practical things too
05:53:22 <schme> Mmm.. My problem is that I really don't get an idea of how I store data and change it and what not.
05:54:19 <schme> I suppose I coulde use some monad trickery to represent the state of things. It just seems a bitch :)
05:54:20 <vixey> in general I think, you define a function that goes from what you had to what you want
05:54:26 <vixey> just composing these and so on ..
05:54:42 <vixey> there is actually state monad in the standard library by the way
05:54:42 <schme> Ugh.
05:54:58 <schme> See what Ineed to represent is the state of the backgammon board.
05:55:35 <schme> In the program I'm rewriting in haskell here I have it as an object of class backgammon-board. Which just is easy for me to work with :)
05:55:43 <schme> But here it's just "eh?" :)
05:55:52 <vixey> mmm well
05:56:13 <esteth_> You could have a datatype representing the board? And store it in a state monad instead of passing it around?
05:56:17 <vixey> let me get backgammon straight.. you have like 16 cells that can be empty, black or white?
05:56:30 <esteth_> I'm also new to haskell, so take everything i say as though it's probably wrong, by the way :)
05:56:32 <schme> esteth: Oh hum. I'll look into that.
05:56:40 <schme> esteth: Seems better than my ideas ;)
05:57:35 <schme> vixey: Almost.. basically you have 26 cells which can be zero, black (1 to 15) or white (1 to 15) .. representing how many black or white checkers on it.
05:58:17 <vixey> oh ok
05:58:26 <vixey> I guess one way to do it would be like you said yeah
05:58:40 <vixey> data Cell = Empty | White Integer | Black Integer
05:58:44 <schme> Which at the moment actually is an array of length 26 that has -15 to 15 in it.  I mean in the CL program I'm rewriting.
05:58:54 <vixey> and then data Board = [Cell] or (Cell,...16...,Cell)
05:58:58 <schme> ah board = [Cell] ya.
05:59:03 <vixey> oops
05:59:05 <vixey> I'm sorry
05:59:09 <vixey> type Board = [Cell] or (Cell,...16...,Cell)
05:59:20 <schme> Hmm.
05:59:28 <schme> Great.
05:59:30 <vixey> then you could use this in the state monad yeah
05:59:48 <schme> It does indeed sound easy here in #haskell.
05:59:50 <vixey> and I think there's a cool hting you can do is use StateT and the list monad, so you get backtracking for free
06:00:10 <schme> That would be quite good actually.
06:00:20 <vixey> so like if you wanted to a DFS search for an AI or somesuch, you could have the state rollback automatically
06:00:49 <vixey> (Using StateT on list, btw I just learned this the other day so .. yeah, but I thought it's really cool and hopefully relevant)
06:01:26 <schme> Hoh.. Not writing an AI. Just a GUI client for playing ze game, and exporting positions to gnubg :)
06:01:47 <shapr> @seen syntaxninja
06:01:47 <lambdabot> I saw syntaxninja leaving #haskell and #haskell-blah 5h 5m 36s ago, and .
06:01:58 <shapr> Aww, I was going to offer to buy him a unicycle to replace his bike.
06:03:43 <shapr> hiya jaj
06:04:02 <shapr> schme: Have you heard of Real World Haskell?
06:08:06 <schme> shapr: I think I was just pointed to it.
06:08:47 <jaj> hi shapr!
06:11:30 * edwardk realizes after he starts filling in a spreadsheet the number of instances he has gotten himself into writing
06:13:39 <schme> Real worl haskell looks very good.
06:43:02 <schme> Is there a good IDE for haskell development?
06:43:28 <vixey> I just use a text editor and have GHCi open in a terminal, that works really well
06:43:46 <vixey> so you consult the file and query it (checking types and such) just like working with Prolog
06:44:08 <schme> Mmm. That's what I thought.
06:44:13 <vixey> (I think theres' like Yi and leksah IDEs/editors written in haskell but I haven't tried them)
06:44:43 <schme> For CL I have SLIME on emacs which really makes a world of difference. I was thinking something along those lines.
06:45:00 <byorgey> schme: there is haskell-mode for emacs
06:45:06 <vixey> I can't really see that working
06:47:03 <esteth_> I use haskell-mode for emacs, and i think it's great. You get type signitures for everything in the minibuffer when you hover over things, you have a code browser (install ECB or use speedbar). What more do you want from an IDE? :)
06:50:00 <quicksilver> schme: 'shim' is like SLIME for haskell.
06:50:05 <quicksilver> schme: I've not used it though.
06:50:52 <quicksilver> @where shim
06:50:53 <lambdabot> http://shim.haskellco.de/trac/
06:51:05 <quicksilver> I think that's wrong.
06:51:20 <quicksilver> @where+ shim http://mapcar.org/haskell/shim/  http://mawercer.de/~publicrepos/shim/
06:51:20 <lambdabot> Good to know.
06:55:30 * dolio never got shim working.
06:56:16 <pejo> dolio, too old version of emacs?
06:56:29 <dolio> Doubtful. It's 23.
06:58:47 <dolio> I didn't try that hard.
06:59:03 <dolio> I think it complained that it couldn't connect to the 'shim server' or something.
07:26:31 <mux> anyone used to Data.Graph.Inductive.Query.SP?
07:28:15 <mux> I've been able to solve a shortest path problem for multiple sources and multiple destination nodes calling spTree for each source node - I think it may be possible to reduce this to one dijkstra call, but can't see how to do this
07:30:41 <mux> I just don't understand the meaning of the third parameter of the dijkstra function, the Heap b (LPath b) one
07:32:21 <ibid> how fast does hackage test-build new uploads?
07:35:25 <jaj> doesn't lambdabot have a feature which does the inverse of @instances, meaning you give it a type and it tells you to which typeclasses it belongs?
07:39:23 <Saizan> no, try :info in ghci
07:48:53 <byorgey> ibid: not very, in my experience
07:49:13 <byorgey> ibid: as in, it might take a day or two (I think?)
07:49:52 <ibid> byorgey: ok. i was surprised to find it does that at all :)
07:49:58 <byorgey> hehe
07:50:11 <ibid> (darcs-monitor hit hackage a week ago, btw, in case anyone was waiting)
07:50:29 <byorgey> ibid: what's darcs-monitor?
07:50:49 <ibid> byorgey: http://wiki.darcs.net/DarcsWiki/DarcsMonitor
07:50:51 <lambdabot> Title: DarcsMonitor - DarcsWiki
07:51:37 <byorgey> ibid: cool
07:54:05 <jaj> Saizan: thanks
07:55:33 <vixey>   
08:26:04 <ibid> is there any simple way to determine what the earliest version of the base package is that provides a particular function?
08:27:42 <mehrheit> that calls for some perly online documentation grepping (provided that online documentation is available for all versions of base)
08:29:27 <ibid> in other words, no
08:29:50 <ibid> or i can just explore the darcs version history
08:31:21 <mdmkolbe|work> I tried to install libghc6-ghc-dev (3.2.0.0-1) on Ubuntu and it is reporting an error about X11-1.3.0 not existing even though "ghc-pkg list" reports having X11-1.4.1.  Is this a packaging bug (i.e. wrong dependancy listed in the package)?  Who do I talk to about it?
08:32:44 <schme2> mdmkolbe|work: I think you talk to the ubuntu people.
08:57:10 <Eiler> dons: how is it going with real world haskell?
09:09:13 <wieczyk> Hi, i have GHC compilation error:
09:09:21 <wieczyk> [18:21] zubr:...home/wieczyk/programowanie (1) $ ghc -o zad2 zad2.hs
09:09:21 <wieczyk> compilation IS NOT required
09:09:21 <wieczyk> zad2.o(.text+0x5409): In function `__stginit_Main_':
09:09:21 <wieczyk> : undefined reference to `__stginit_containerszm0zi1zi0zi1_DataziSet_'
09:09:27 <wieczyk> when i am using Data.Set
09:09:35 <wieczyk> i need to add some library to ghc commandline ?
09:10:06 <wieczyk> ;]
09:10:20 <ibid> try adding --make?
09:11:12 <wieczyk> working
09:11:30 <ibid> :)
09:11:52 <ibid> --make tells ghc to figure all the dependencies out
09:12:03 <ibid> without it, you have to specify them manually
09:12:06 <wieczyk> i checked on manual now :)
09:12:10 <cpoucet> ibid: hey
09:12:15 <wieczyk> but, did you know what is dependency for Data.Set ?
09:12:18 <ibid> cpoucet: 'lo
09:12:28 <chessguy> i have a question. why is it that we so detest partial functions?
09:12:43 <cpoucet> ibid: I think I sent you an email to ask whether you could add my new blog to planet haskel
09:12:55 <chessguy> @src head
09:12:55 <lambdabot> head (x:_) = x
09:12:55 <lambdabot> head []    = undefined
09:13:06 <ibid> wieczyk: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html says containers
09:13:12 <geezusfreeek> chessguy: i wouldn't say we detest them so much. you just have to be more careful with them
09:13:15 <ibid> cpoucet: likely. i have some backlog
09:13:23 <chessguy> geezusfreeek, what do you mean by 'more careful'
09:13:26 <cpoucet> was 2 weeks ago I believe
09:13:28 <cpoucet> ok :)
09:13:32 <cpoucet> just checking the mail didn't get lost
09:13:36 <geezusfreeek> chessguy: make sure you don't use head on an empty list
09:13:44 <geezusfreeek> the type checker won't guarantee that for you
09:13:49 <chessguy> sure
09:13:51 <geezusfreeek> hence, you have to be more careful
09:13:57 <byorgey> chessguy: if all your functions are total, then you know (trivially) that your program will not crash
09:14:05 <ibid> cpoucet: apr 27? i have it there
09:14:11 <chessguy> fair enough
09:14:13 * ibid probably should process them :)
09:14:17 <byorgey> chessguy: if you use a partial function, it adds a burden of proof that it only ever gets called on inputs for which it is defined
09:14:33 <chessguy> is that typically a difficult proof?
09:14:39 <ibid> it's just another precondition :)
09:14:42 <geezusfreeek> chessguy: the trick is simply to minimize partial functions, but it would be extreme to eliminate them completely. you just have to be practical sometimes
09:14:45 <byorgey> chessguy: not necessarily.
09:15:02 <byorgey> chessguy: there are even tools like Catch to automate some of those proofs.
09:15:03 <ibid> (or, put it another way, preconditions are a way of specifying partiality)
09:15:08 <geezusfreeek> chessguy: the burden of proof is on the code that uses the partial function(s)
09:15:18 <geezusfreeek> just like having to check for null values in C
09:15:21 <ibid> and quite often, just having a precondition is better than trying to handle bad inputs
09:15:29 <cpoucet> ibid: yeah, apr 27
09:15:33 <ibid> (inside a program. that does not apply to user input)
09:15:42 <opqdonut> is there some elegant way to add an "attribute" field to each node in a tree (consisting of many datatypes or one large GADT)
09:15:43 <chessguy_> i was just thinking about algebraic groups, and the fact that you can't really verify all the properties with the type system, thus you probably _want_ partial functions
09:16:05 <opqdonut> usecase: i get an AST from a parser and want to do attribute grammars on it
09:16:06 <ibid> cpoucet: life has been hectic lately
09:16:11 <ibid> dons: ping?
09:16:15 <cpoucet> ibid: take your time, was just a "not-lost" check :)
09:16:20 <ibid> :)
09:16:53 <geezusfreeek> chessguy: well, you probably could verify the properties with the type system, but it would be a mess and hard to use
09:16:56 <opqdonut> maybe i should somehow parametrize the tree with a functor...
09:17:29 <mux> Control.Applicative is so addictive, I can't bear to write foo <- bar; baz; return foo for a monadic parser now that I can write bar <* baz
09:17:36 <ibid> geezusfreeek: in general you can't unless you're prepared to lose the nice property that all type checks terminate
09:17:44 <geezusfreeek> ibid: right
09:17:58 <geezusfreeek> i personally don't think a turing complete type system is so bad
09:18:01 * ibid considers that a quasiessential property of type systems
09:18:37 <ibid> so much so that i'm tempted to refuse calling non-terminating type systems type systems :)
09:18:49 <geezusfreeek> ibid: why is that? i hear that from a lot of people, but without much justification
09:19:01 <mauke> mux: huhu, I actually reinvented <* just for that :-)
09:19:06 <ibid> instead just call them proof checkers (or if "types" are implicit, proof generators)
09:19:41 <mux> who needs do notation when there's Control.Applicative :-)
09:19:44 <ibid> geezusfreeek: fundamentally, it's a matter of terminology, and thus a matter of taste
09:19:47 <geezusfreeek> ibid: maybe that's the difference. i consider type systems to be a class of proof checkers anyway
09:19:56 <ibid> geezusfreeek: fair enough. i'
09:19:58 <ibid> gah
09:20:16 <ibid> geezusfreeek: fair enough. i'd say that type systems are proof systems that terminate :)
09:20:33 <ibid> geezusfreeek: (at least when applied in the usual program context)
09:21:11 <ibid> (/me so hates having the ' key next to the return key. actually, the same goes for the backspace key)
09:21:22 * geezusfreeek too
09:21:27 <geezusfreeek> i always do that
09:21:35 <quicksilver> in the same way that we normally restrict languages
09:21:41 <quicksilver> and only consider those with terminating parsers.
09:22:16 * mux wonders if there's a penalty in the compiled code for foo <$> bar <$> baz instead of (foo . bar) <$> baz
09:22:35 <quicksilver> and, come to that, many people prefer to only consider terminating compilers. C++ and GHC be damned!
09:22:43 <mux> when you start using <$> and <*> I find function composition slightly inconvenient
09:22:43 <quicksilver> mux: not if inlining is working.
09:23:10 <mux> quicksilver: good then
09:23:15 <quicksilver> and foo and bar have the (->) part of their type concrete.
09:23:31 <geezusfreeek> mux: how about a <.> operator then? ;)
09:24:21 <mux> geezusfreeek: <$> is fine for that purpose, I was mostly concerned about whether there'd be an overhead in using it instead of plain function composition
09:24:26 <geezusfreeek> ah
09:24:42 <ttt--> or the < >
09:24:43 <maltem> quicksilver: GHC should terminate when programming without any extensions?
09:24:48 <mux> > (+1) <$> (*2) <$> Just 2
09:24:51 <lambdabot>  Just 5
09:24:52 * ibid finally figured out today that cabal provides out of the box the stuff i've laboriously done myself in the darcs-monitor Setup.hs
09:25:05 <Saizan> > (+1) . (*2) . Just 2
09:25:06 <lambdabot>  Just 5
09:25:13 <ibid> cabal could be better documented
09:25:18 <Saizan> you can go both ways :)
09:25:20 <mux> Saizan: what the
09:25:35 <mux> how could use . here for the second usage?
09:25:36 <Saizan> ?type (.) -- not standard
09:25:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:25:39 <mux> is that a new LB trick?
09:25:48 <Saizan> not so new
09:25:52 <Saizan> uhm
09:25:55 <ibid> LB?
09:25:55 <geezusfreeek> i really want lambdabot's definition for composition
09:26:08 <quicksilver> maltem: yes.
09:26:09 <Saizan> well, for '> ' (.) = fmap
09:26:20 <mauke> > (.)
09:26:20 <maltem> > typeOf (.)
09:26:22 <lambdabot>  Add a type signature
09:26:22 <lambdabot>  Add a type signature
09:26:24 <mux> that's Cale's point of view of function composition, IIRC :)
09:26:32 <Saizan> yeah
09:26:38 <maltem> quicksilver, fair enough.
09:26:42 <mux> still feels weird to me
09:27:12 <ttt--> what does a function with <> usually mean?
09:27:16 <Saizan> > (+1) . (*2) <$> Just 2 -- this has problems with fixities?
09:27:17 <lambdabot>  Just 5
09:27:26 <xerox> Jost do it.
09:27:42 <maltem> ttt--, having one's residence in Control.Applicative
09:28:36 <mux> ibid: LB == lambdabot
09:28:38 <wjt> @index (<|>)
09:28:38 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
09:28:50 <wjt> hmm, i thought applicative had some <>s that clashed with Parsec
09:28:54 <ibid> mux: how disappointing
09:29:09 <Saizan> wjt: that's the one
09:29:13 <quicksilver> wjt: it does, <|> is in Alternative (which is part of Applicative)
09:29:16 <wjt> ahhh
09:29:26 <quicksilver> ttt--: really they just mean we ran out of symbols
09:29:28 <mux> wjt: it has many which clashes
09:29:29 <wjt> roll on unicode symbols ;-)
09:29:32 <quicksilver> ttt--: and started making up new ones :)
09:29:36 <mux> @index many
09:29:36 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP, Distribution.Compat.ReadP
09:29:44 <mux> though LB doesn't seem to se it
09:29:47 <quicksilver> often < > means something has be 'lifted' to a higher level
09:29:53 <quicksilver> e.g. monad/applicative
09:29:59 <ibid> mux: i expected it to be some new library or a technique witha a cool paper i haven't yet read :)
09:30:07 <quicksilver> I will sometimes define <++> = liftM2 (++), etc
09:30:38 <mux> liftA2 would be more appropriate, wouldn't it?
09:31:27 <maltem> That's where custom brackets would be cool. let <op> = liftM2 op
09:32:01 <xerox> geezusfreeek: http://code.haskell.org/lambdabot/State/L.hs
09:32:02 <quicksilver> you can do that sort of. but you'd need to bracket the op.
09:32:25 <quicksilver> you could make    iI (+) Ii    work
09:32:31 <quicksilver> but that's not eactly beautiful.
09:32:37 <xerox> and this is the imports http://code.haskell.org/lambdabot/imports.h
09:32:40 <quicksilver> roll on GHC front-end plugins.
09:35:16 <cpoucet> :t fmap ($)
09:35:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
09:36:01 <opqdonut> we should really have fmap2, fmap3 and so on
09:36:24 <opqdonut> or does that require applicative?
09:37:13 <Saizan> liftA2..N are fmap2..N
09:38:36 <Saizan> and (<*>) == liftA2 id
09:39:14 <Apocalisp> (>>=) f -- What can be said that >>= has done to f?
09:39:55 <EvilTerran> received it in its first parameter :P
09:40:22 <EvilTerran> specific to >>=, you could say it's bound the result of f
09:40:34 <EvilTerran> or will have, when it gets its second parameter and is rub
09:40:36 <EvilTerran> *run
09:41:08 <Apocalisp> OK, cool
09:41:28 <EvilTerran> as >>= is also known as "bind"
09:41:49 <quicksilver> opqdonut: there is somethiing else fmap2 might mean, with bifunctors.
09:41:52 <maltem> On that liftA/fmap matter, is the Functor constraint in   Functor f => Applicatve f   there for more than cosmetic reasons?
09:46:14 <byorgey> maltem: no, it's required.  It doesn't make sense to have an Applicative that isn't a Functor.
09:46:23 <conal> maltem: in that fmap is definable via pure and (<*>)?
09:46:36 <conal> byorgey: can you say how it "doesn't make sense"?
09:47:02 <byorgey> conal: well... no, I guess not =)
09:47:05 <quicksilver> it doesn't make sense because the rules for applicative relate pure and <*> to fmap.
09:47:17 <quicksilver> so you can't write them down if fmap doesn't exist
09:47:23 <conal> quicksilver: sure but the rule could be modified.
09:47:28 <quicksilver> indeed.
09:47:33 <quicksilver> and the combinators could be renamed
09:47:38 <quicksilver> and the type signatures changed
09:47:41 <conal> hm.  i'd never thought of applicative without functor.
09:47:41 <quicksilver> and it would be bytestring!
09:47:43 <maltem> byorgey: required in the sense that the definition of fmap gets redundant, right?
09:48:52 <maltem> I mean, I'd rather see an (instance Applicative f => Functor f) than a (class Functor f => Applicative f).
09:48:54 <byorgey> maltem: required in the sense that the very notion that Applicative is designed to model is defined in terms of Functor.
09:49:24 <byorgey> maltem: instance Applicative f => Functor f  likely doesn't mean what you think.
09:49:25 <conal> byorgey: what notion is that?
09:49:44 <quicksilver> the notion of "applicative functors" ;)
09:49:48 <byorgey> it means 'everything is a functor, and must be Applicative as well'
09:49:50 <maltem> byorgey, what does it mean then?
09:50:12 <conal> oh, i see. Applicative models applicative functors
09:50:12 <maltem> hm?
09:50:23 <conal> then shift the question to the model
09:50:32 <quicksilver> I'm partly being mean.
09:50:37 <quicksilver> I can imagine a non-functorial applicative.
09:50:39 <quicksilver> MVar
09:50:42 <quicksilver> IORef.
09:50:52 <quicksilver> I'm not sure how useful they are, though.
09:51:18 <byorgey> maltem: instances are chosen by 'pattern-matching' (if you will) on the type.
09:51:51 <byorgey> so for example,  instance Foo (Bar a)  means, any type that is of the form 'Bar a' is an instance of Foo.
09:52:25 <maltem> byorgey, that instance has no constraints
09:52:26 <conal> aside from a possible necessity of AFs being functors, it's a helpful factoring.  simplifies the notion of AF to be "functor plus the following properties ..."
09:52:42 <byorgey> and if there is a constraint like  instance  Constraint a => Foo (Bar a),  the constraint gets added to the list of constraints that must be satisfied *after* the instance is chosen.
09:52:51 <conal> though i don't understand why have liftA in addition to fmap
09:52:54 <maltem> byorgey, (a,b) isn't an instance of Eq in any case either.
09:53:06 <conal> i understand liftM as a historical accident
09:53:25 <byorgey> maltem: so  instance Constraint a => Foo (Bar a)  means, anything of the form Bar a is an instance of Foo, and if you use it as such, a better be a member of class Constraint as well.
09:53:47 <conal> mehrheit: does "mehrheit" mean something like "moreness" or what?
09:53:55 <byorgey> in particular it does *not* mean (appearances aside!) that Bar a is an instance of Foo only if a is a member of class Constraint.
09:54:13 <conal> mehrheit: unlimitedness?
09:54:41 <clanehin> I think, majority.
09:54:42 <mehrheit> majority
09:54:48 <conal> oh!  thx.
09:55:05 <byorgey> maltem: it's sort of confusing, since with instances the =>  seems to point the wrong way.
09:55:30 <opqdonut> quicksilver: oh, okay
09:55:43 <maltem> byorgey, but it does say that Bar a is an instance of Foo _if_ the constraint holds, or else I used type classes all the time successfully without noticing I wouldn't understand them
09:55:44 <conal> clanehin: i see you're doing some cool algebraic graphics stuff
09:58:11 <clanehin> conal: I grew up with POV, so it's the easiest way for me to get things done
09:58:55 <byorgey> maltem: no, it doesn't really say that (although thinking of it in that way might work sometimes).
09:59:39 <quicksilver> maltem: in particular, it means you will never get the error "Bar a is not an instance of Foo"
09:59:40 <byorgey> maltem: what it actually says is, 'Bar a is an instance of Foo, and if you use Bar a as an instance of Foo (for some particular type a), then the constraint must hold for a, or else you will get a type error.'
10:00:01 <quicksilver> maltem: the only error you would ever get is "a is not a member of Constraint"
10:00:13 <conal> clanehin: does POV have a nice algebraic structure?
10:00:16 <byorgey> it's a subtle difference but sometimes it matters. =)
10:01:00 <byorgey> maltem: another way to look at it is that the type checker does not look at constraints when deciding what instance to use.
10:01:32 <byorgey> only after it decides what instance to use does it look at the constraint and go off to make sure it is satisfied as well.
10:01:44 <maltem> Ah, it means that for my Functor instance, we couldn't have Functors that aren't Applicatives anymore?
10:02:39 <byorgey> maltem: right.
10:02:54 <maltem> Now that makes clear where my thinking was wrong, thx
10:03:17 <byorgey> maltem: if you tried to declare another instance of Functor  (instance Functor Foo where ...)  the typechecker would probably complain, because the two instances for Functor  (instance Functor Foo and instance Functor f) overlap
10:03:37 <maltem> right
10:03:51 <clanehin> conal: Ah, well, I don't think that it is designed around parametric surfaces as such; which is certainly for the best.
10:03:56 <byorgey> maltem: I totally understand what you are proposing however.  you would like a way to automatically derive Functor instances for things where only an Applicative instance is defined.
10:04:17 <byorgey> maltem: that would be nice indeed, and there are several proposals out there which would allow just this sort of thing.
10:04:32 <quicksilver> maltem: incidentally, in the presence of certain GHC options it allows overlaps and kind of behaves as you thought it might.
10:04:34 <clanehin> conal: but in both cases there is a DSL to describe the geometry.
10:04:44 <quicksilver> however I don't understand those options and I don't use them :)
10:05:21 <byorgey> yeah, I think with -XOverlappingInstances it tries to choose the most specific instance possible, or something like that
10:06:28 <quicksilver> byorgey: I *think* that means it will prefer an instance of the form [a] over a
10:06:29 <maltem> I guess that would become fiddly when you try to sort out what the "most specific" instance is in a particular case
10:06:40 <quicksilver> byorgey: I.e. that's most specific in the sense of type constructors.
10:06:54 <quicksilver> I don't think it pays attention to constraints.
10:07:03 <quicksilver> But the effect is that your 'a' instance is by definition least specific.
10:07:09 <byorgey> quicksilver: yeah, I think so, but I'm not sure.  I've never understood it well enough to rely on its behavior =)
10:07:19 <quicksilver> me too; me neither.
10:07:24 <byorgey> maltem: yeah, it can become fiddly, indeed
10:07:38 <maltem> byorgey: may I find those deriving proposals on the Haskell' wiki?
10:08:28 <quicksilver> john meacham's class alias proposal is one of them.
10:08:37 <quicksilver> well it solves the same problem, at least.
10:09:05 <quicksilver> http://repetae.net/recent/out/classalias.html
10:09:05 <lambdabot> Title: Class Alias Proposal for Haskell
10:13:10 <maltem> looks interesting too...
10:15:31 <conal> clanehin: geometry dsl.  got it.
10:17:12 <pitseleh> hello, i'm slightly confused as to why one of my functions is recurring
10:17:43 <pitseleh> i've got a main function which creates a list called catalogue
10:18:13 <pitseleh> then i create something to put in the catalogue using a function which allows the user to input information into
10:18:18 <pitseleh> tempTrack <- inputTrack
10:18:45 <pitseleh> i've got another function that's simply supposed to add a 'track' to the start of a catalogue
10:19:15 <pitseleh> let catalogue = addTrackToCatalogue catalogue tempTrack
10:19:33 <pitseleh> seems to make an infinite list of tempTrack
10:20:21 <mauke> why is catalogue recursive?
10:20:51 <pitseleh> i don't know why it's recursive :(
10:21:07 <pitseleh> addTrackToCatalogue :: Catalogue -> CatalogueTrack -> Catalogue
10:21:08 <pitseleh> addTrackToCatalogue catalogue track = (track:catalogue)
10:21:15 <mauke> er
10:21:16 * pitseleh hopes i'm not flooding
10:21:20 <mauke> you defined it to be recursive
10:21:23 <mauke> I'm asking you why
10:21:51 <pitseleh> will let catalogue = addTrackToCatalougue.. act recursively?
10:22:02 <sclv> hmmm... just reading the new wadler paper -- I thought the Idiom, Arrow, Monad ordering was well known...
10:22:08 <mauke> pitseleh: not necessarily
10:22:18 <mauke> pitseleh: but let catalogue = ... catalogue .. definitely will
10:22:22 <sclv> if not formalized, that is.
10:22:41 <pitseleh> mauke, ah, i see.. i didn't realise that
10:22:43 <mauke> you're using catalogue in its own definition. that makes it recursive.
10:23:32 <pitseleh> mauke, that makes sense, silly me.. i'd have to create a new catalogue variable and return it at the end of the 'main loop' function
10:24:02 <pitseleh> mauke, for a program that builds the catalogue list up each time it iterates
10:24:34 <pitseleh> well, it's one way at least :)
10:29:31 <mrd> sclv: me too, but that's probably bc we are here
10:31:10 <quicksilver> or maybe it's *why* you are here ;)
10:31:46 <quicksilver> cause and effect, such a slippery pair
10:32:02 <conal> quicksilver: amen!
10:32:51 <mrd> i wouldn't be here but for applicative functors being more general than arrows
10:33:21 <conal> quicksilver: i've been thinking of cause&effect as a moveable choice focus among the many relationships between things.
10:33:32 <sclv> well, cause and effect depends if #haskell is oblivious, meticulous, or promiscuous...
10:34:00 <dmwit> Okay, thanks ndm.
10:34:07 <conal> sclv: very articulous!
10:34:25 * conal is being ridiculate
10:42:26 <thetallguy> conal: your cause&effect, I'm not sure I understand 'moveable choice focus'
10:45:31 <bauchus> succ on enum error: "tried to take `succ' of last tag in enumeration". Is there another succ, which starts from the beginning?
10:45:37 <bauchus> succ False
10:45:50 <Baughn> @src Enum
10:45:51 <lambdabot> class  Enum a   where
10:45:51 <lambdabot>     succ                     :: a -> a
10:45:51 <lambdabot>     pred                     :: a -> a
10:45:51 <lambdabot>     toEnum                   :: Int -> a
10:45:51 <lambdabot>     fromEnum                 :: a -> Int
10:45:52 <lambdabot> [3 @more lines]
10:46:10 <bauchus> > succ True
10:46:13 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
10:46:34 <Baughn> That's what you have to work with. You could presumably use toEnum/fromEnum to make it cyclical.
10:46:42 <Baughn> @instances Enum
10:46:43 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
10:46:51 <Baughn> > toEnum 2 :: Bool
10:46:53 <lambdabot>  Exception: Prelude.Enum.Bool.toEnum: bad argument
10:47:31 <Baughn> > toEnum (mod 2 $ succ $ fromEnum True) :: Bool
10:47:33 <lambdabot>  False
10:48:16 <Baughn> Although, this feels like a wrong use of succ. Why do you want this?
10:50:11 <bauchus> i make a game. Left and Right key change the direction (North, East, South, West). At the moment I use succ and pred to calculcate  the next direction.
10:51:14 <bauchus> succ North =(Right key)=> East, pred East =(Left key)=> North
10:51:29 <byorgey> bauchus: if I were you, I'd just make my own rotCW and rotCCW functions
10:51:40 <kpreid> bauchus: toEnum . (`mod` 4) . (+ 1) . fromEnum
10:51:57 <kpreid> er, succ in place of (+ 1)
10:52:20 <bauchus> thanks
10:52:33 <kpreid> oh, wait
10:53:46 <kpreid> cycleSucc x = (toEnum . (`mod` (pred . fromEnum) (maxBound `asTypeOf` x)) . succ . fromEnum) x
10:53:50 <kpreid> @let cycleSucc x = (toEnum . (`mod` (pred . fromEnum) (maxBound `asTypeOf` x)) . succ . fromEnum) x
10:53:52 <lambdabot> Defined.
10:54:04 <kpreid> > iterate cycleSucc False
10:54:05 <lambdabot>  [False,Exception: divide by zero
10:54:26 <kpreid> whoops
10:54:38 <kpreid> @let cycleSucc x = (toEnum . (`mod` (succ . fromEnum) (maxBound `asTypeOf` x)) . succ . fromEnum) x
10:54:39 <lambdabot> <local>:4:0:     Warning: Pattern match(es) are overlapped              In th...
10:54:44 <kpreid> @undefine
10:54:44 <lambdabot> Undefined.
10:54:46 <kpreid> @let cycleSucc x = (toEnum . (`mod` (succ . fromEnum) (maxBound `asTypeOf` x)) . succ . fromEnum) x
10:54:47 <lambdabot> Defined.
10:54:52 <kpreid> > iterate cycleSucc LT
10:54:53 <lambdabot>  [LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,...
10:55:13 <kpreid> bauchus: there you go
10:55:20 <kpreid> actually...
10:55:38 <kpreid> cycleModify f x = (toEnum . (`mod` (succ . fromEnum) (maxBound `asTypeOf` x)) . f . fromEnum) x
10:55:39 <bauchus> wow. quite complicated for such a simple problem ;-)
10:55:48 <kpreid> then parameterize it with pred and succ
10:56:23 <byorgey> bauchus: it's complicated because it's way, way too general for what you need =)
10:56:41 <ddarius> > let cycleSucc = (tail $ cycle [minBound .. maxBound] !!) . fromEnum in iterate cycleSucc LT
10:56:42 <lambdabot>      The operator `!!' [infixl 9] of a section
10:56:42 <lambdabot>         must have lower preced...
10:56:56 <ddarius> > let cycleSucc = (tail (cycle [minBound .. maxBound]) !!) . fromEnum in iterate cycleSucc LT
10:56:58 <lambdabot>  [LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,...
10:56:59 <edwardk> hey i'm feeling kinda slow at the moment. does anyone remember the derivation of call/cc _from_ shift and reset?
10:57:08 <bauchus> this could be included in Prelude'
10:57:50 <ddarius> edwardk: ?  callCC f = shift (\k -> f k >>= k)
10:58:12 <edwardk> ddarius thx
10:58:12 <ddarius> bauchus: This isn't something commonly desired.
10:59:16 <EvilTerran> > let cycleSucc x = fromJust $ x `lookup` (zip <*> tail) (cycle [minBound ..]) in iterate cycleSucc EQ
10:59:17 <lambdabot>  [EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,...
10:59:26 <EvilTerran> huzzah!
10:59:43 <SamB> ddarius: cyclic pred/succ are that unusual?
10:59:53 <EvilTerran> > succ maxBound :: Int
10:59:54 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
11:00:05 <bauchus> it's very useful!
11:00:18 <EvilTerran> yes
11:00:33 <edwardk> i figured i should make the indexed monad stuff support the traditional monadic callCC, etc.
11:01:08 <EvilTerran> more generally useful would be safeSucc :: Enum a => a -> Maybe a
11:01:20 <ddarius> SamB: In my experience, yes.
11:01:31 <EvilTerran> then cyclicSucc = fromMaybe minBound . safeSucc
11:01:55 <wjt> newtype CyclicBounded a; instance Bounded a => Bounded (CyclicBounded a) where
11:02:02 <SamB> ddarius: perhaps they aren't used terribly often...
11:02:48 <ddarius> > let cyclicSucc x | x == maxBound = minBound | otherwise = succ x in iterate cyclicSucc LT
11:02:50 <lambdabot>  [LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,EQ,GT,LT,...
11:03:04 <conal> EvilTerran: nice one!
11:03:26 <ddarius> wjt: And what is minBound and maxBound going to be for that?  I think you wanted Enum.
11:03:55 <EvilTerran> indeed, (Enum a, Bounded a)
11:04:01 <ddarius> :t let safeSucc x | x == maxBound = Nothing | otherwise = Just (succ x) in safeSucc
11:04:03 <lambdabot> forall a. (Enum a, Eq a, Bounded a) => a -> Maybe a
11:05:59 <wjt> ddarius: you're right, i did!
11:06:23 <ddarius> SamB: I didn't say they were never desired, just not commonly desired.
11:10:09 <EvilTerran> newtype Cyclic a = Cyclic { unCyclic :: a }; instance (Bounded a, Enum a) => Enum (Cyclic a) where ...
11:11:28 <ddarius> EvilTerran: I believe you'll need Eq.
11:11:56 <ddarius> No, actually you don't.
11:13:09 <quicksilver> conal: clearly cause and effect are just two axes on the zipper of life.
11:13:38 <edwardk> er that 'zipper' seems stuck
11:13:41 <edwardk> =)
11:15:14 <edwardk> sometimes i wish there was a newtype Foo = Foo (Bar) deriving (*)
11:20:07 <chessguy> anybody know who maintains community.haskell.org?
11:20:28 <dcoutts> chessguy: yep
11:20:36 <dcoutts> there's a bunch of admins
11:21:22 <dcoutts> ibid: which feature was it that was not documented? I'll make sure to add it to the user manual.
11:22:51 <chessguy> dcoutts, ah, never mind, actually. my project did get created, i just didn't get notified (i don't think)
11:23:11 <dcoutts> chessguy: oh yes, I made it a while ago
11:23:27 <dcoutts> chessguy: I'm never sure if our responses make it back to the submitters
11:23:29 <chessguy> dcoutts, thanks
11:23:53 <chessguy> dcoutts, doesn't look like it did in this case
11:27:20 <chessguy> @src Num
11:27:21 <lambdabot> class  (Eq a, Show a) => Num a  where
11:27:21 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:27:21 <lambdabot>     negate, abs, signum     :: a -> a
11:27:21 <lambdabot>     fromInteger             :: Integer -> a
11:27:57 <byorgey> dcoutts: I also had a project created a while ago of which I never got notified
11:28:13 <dcoutts> sigh
11:28:18 <byorgey> so it seems like maybe the notification process is broken, if there is supposed to be one
11:28:47 <ehird> :t when
11:28:48 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:28:49 <dcoutts> Igloo: we should make sure the project request stuff sets the user as the ticket requester
11:29:04 <ibid> dcoutts: that the Paths_ module exports version
11:29:14 <ibid> (generated module)
11:29:40 <dcoutts> ibid: ah right
11:29:48 <dcoutts> ibid: thanks, I'll check the manual
11:30:10 <ibid> dcoutts: and while you're at it, providing the package identifier along with the version would be nice (but not at all critical:)
11:31:05 <dcoutts> ibid: the tricky bit with adding more structured data is that we cannot use any types defined in the Cabal lib
11:31:28 <chessguy> i wonder if a definition like this would make sense? http://hpaste.org/7528
11:31:28 <dcoutts> ibid: we can of course provide a String that is your program name, though I'm not sure it'd be very helpful
11:31:45 <dcoutts> ibid: since presumably you already know that :-)
11:32:12 <ibid> dcoutts: (and documenting the rest of that file would be nice. i think the manual just mentions getDataFileName)
11:32:43 <dcoutts> right
11:32:49 <ibid> dcoutts: i also know the version, but i prefer not to duplicate information.  it ought to be enough to give this stuff in .cabal only :)
11:33:14 <dcoutts> ibid: we can certainly provide the program name
11:33:23 <ibid> (of course, it's rather less likely for the name to change)
11:33:28 <dcoutts> right :-)
11:33:36 <ibid> (and thus not critical, as i said)
11:35:47 <ibid> dcoutts: in any case, thanks :)
11:37:18 <warlink> Hey guys, I got a small problem, if I got a Table on the form [name, schema, records] how do I get the infomation out of the table? hope you understand what I mean  and can help..
11:37:50 <dmwit> Isn't that a SQL question, not a Haskell one?
11:38:06 <dmwit> Or: what library are you using to interface to your database?
11:38:40 <ehird> So. HaskellNomic. I'm just going to say this and no more until it's ready because anyone who will be interested in it will have died of happiness already and all others will be going 'WTF'.
11:39:10 <dmwit> 'WTF'
11:39:33 <mdmkolbe|work> Is there an 8bit type?
11:39:45 <dmwit> Word8
11:39:47 <SamB> Word8
11:39:50 <dmwit> It's in Data.Word.
11:39:52 <SamB> also Int8 if you want
11:39:58 <dmwit> There's also Word16, Word32.
11:40:06 <ibid> (not in h98, though)
11:40:21 <SamB> what is?
11:40:29 <mdmkolbe|work> @index Int8
11:40:29 <lambdabot> Data.Int, Foreign
11:40:32 <ehird> dmwit: Oh well. A nomic is a game whose initial ruleset consists of rules on how you can change the rules. A codenomic is a nomic where the rules are replaced with programs. PerlNomic - http://nomic.info/perlnomic/ - is the most popular of them
11:40:34 <lambdabot> Title: PerlNomic: Current Source
11:40:51 <dmwit> ehird: Oh, fun!
11:40:53 <SamB> ehird: you mean like corewars?
11:41:09 <mdmkolbe|work> So what is the difference between Word8 and Int8?
11:41:19 <dmwit> sign
11:41:29 <mdmkolbe|work> Word8 is unsigned?
11:41:29 <ehird> SamB: Kind of
11:41:30 <dmwit> (Word8 is unsigned, Int8 is signed.)
11:41:38 <ehird> SamB: But not really
11:41:45 <ehird> SamB: Basically, in PerlNomic, when you make a proposal, you input a program.
11:41:50 <ehird> SamB: When it's accepted, it's executed.
11:42:06 <ehird> SamB: When you e.g. use the registration form, what it does is submit a proposal which adds you to the list of users and writes it out to disk.
11:42:07 <mdmkolbe|work> thx all
11:42:22 <ehird> SamB: You see? And, it lets you edit the CGI scripts like the adduser.cgi.
11:42:45 <dmwit> Who accepts the proposals?
11:42:51 <ehird> SamB: So, e.g., people have added a mini game to it that shows a map (map.cgi) of all players, and lets you move (move.cgi) in it and bite (bite.cgi) ones near you.
11:43:10 <ehird> dmwit: They are voted on. Ones that get enough 'for' votes can be activated by going to activate.cgi and choosing it.
11:43:39 <lament> an interesting model of software development.
11:44:02 <ehird> Basically, everything you see in /perlnomic/ is modifiable by proposal (as well as arbitary perl execution can be tagged on to a proposal)
11:44:07 <ehird> lament: well, no ;)
11:44:14 <ehird> it would be impractical for anything but a game!
11:44:24 <dmwit> So... you're implementing darcs?
11:44:26 <dmwit> ;-)
11:45:13 <ehird> dmwit: Darcs does voting now?
11:45:33 <ehird> dmwit: But anyway, no, it's not the same.
11:45:35 <mdmkolbe|work> @hoogle (Ord a) => a -> a -> a -> Bool
11:45:37 <lambdabot> No matches, try a more general search
11:45:47 <ehird> Obviously explaining a nomic AND a codenomic at the same time, over IRC, is going to be nigh-on impossible.
11:45:53 <dmwit> mdmkolbe|work: What's the desired behavior?
11:45:55 <ehird> So I won't try any more. Google is your friend ;)
11:46:00 <dmwit> =)
11:46:47 <mdmkolbe|work> dmwit: Right now I'm using my own helper "between a b x = a <= x && x <= b", but is there is already one built in I could use that
11:47:14 <dmwit> Ah, yeah, that's probably the cleanest way to do that.
11:50:45 <chylli> is it possible to recompile packages by cabal without download & compile myself ?
11:51:29 <dcoutts> chylli: you mean a tool to download and compile them automatically?
11:52:29 <chylli> dcoutts: yes
11:52:41 <chylli> dcoutts: I want to upgrade pacakges
11:52:46 <dcoutts> chylli: I thought you'd already been using cabal-install?
11:53:06 <chylli> dcoutts: yes. I just want to upgrade all of packages
11:53:28 <dcoutts> chylli: cabal upgrade
11:53:34 <chylli> dcoutts: but there are dependence erroes
11:53:46 <dcoutts> ah
11:54:06 <andresj> hello. what function should I use for summations? (i have a function, a start value and an end value)
11:54:07 <dcoutts> well, that's a harder problem
11:54:27 <mauke> sum [a .. z]
11:54:49 <dcoutts> chylli: I'm working on that at the moment, trying to have it search for solutions that use consistent dependencies, but it's harder than you'd think
11:54:59 <dcoutts> in fact it's an NP complete problem
11:55:14 <dmwit> andresj: Use Gauss' formula for sums of adjacent integers.
11:55:53 <dmwit> sum [a..b] = (a + b) * (b - a + 1) / 2
11:56:00 <andresj> mauke, dmwit: :) I dont want adjacent integers. (dont want f x = x), I want f x = whatever
11:56:16 <mauke> sum (map f [a .. z])
11:56:19 <dmwit> andresj: Then use the "sum" function.
11:56:38 <chylli> dcoutts: then should I recomile them by hand ? thanks
11:57:05 <dcoutts> chylli: for the moment, you'll have to ask it to compile individual packages
11:57:05 <dmwit> ?check \a b -> sum [a..b] == (a + b) * (b - a + 1) `div` 2
11:57:07 <lambdabot>  Falsifiable, after 6 tests: 6, -2
11:57:07 <andresj> This is what i wanted :D: `sum (map f [ 1 .. 8])`
11:57:22 <dcoutts> chylli: or resolve the inconsistencies
11:57:28 <dmwit> ?check \a b -> b >= a ==> (sum [a..b] == (a + b) * (b - a + 1) `div` 2)
11:57:29 <lambdabot>  OK, passed 500 tests.
11:58:35 <chylli> dcoutts: then should I download them and recomple one by one ? or can I recompile them one by one by cabal-install ? like 'cabal reinstall HTTP'
11:59:16 <andresj> anybody know what's the syntax for lambda functions in haskell?
11:59:25 <dcoutts> chylli: cabal install 'HTTP>=${version-currently-installed}'
11:59:55 <mauke> haha
12:00:08 <dcoutts> chylli: there's a mis-feature where saying cabal install HTTP does nothing if you already have some version of HTTP installed
12:00:17 <mauke> andresj: no, that's an unsolved research problem
12:00:27 <dcoutts> chylli: it only will install if you ask specifically for a newer one
12:00:36 <dcoutts> I'll probably fix that later today
12:00:45 <andresj> mauke: then I have to declare the function elsewhere? (no inline functions)
12:01:08 <mauke> lern2sarcasm
12:01:12 <arcatan> andresj: \x y -> x + y
12:01:12 <andresj> -.-
12:01:14 <mauke> andresj: it's \x -> ...
12:01:17 <andresj> :)
12:01:33 <andresj> thanks
12:01:42 <chylli> dcoutts: ok.
12:01:56 <RayNbow> hmm, a few links at http://tunes.org/~nef/logs/haskell/ are outdated
12:01:58 <lambdabot> Title: Index of /~nef/logs/haskell
12:05:01 <gwern> out of curiosity: does it annoy anyone else that when you click on a package link in Hackage, you get sent to a version specific page like http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light-0.3.1 instead of http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pcre-light ?
12:05:03 <lambdabot> http://tinyurl.com/6eb6fk
12:05:11 <ehird> gwern: Mu
12:05:46 <dmwit> The question doesn't make sense, really?
12:05:56 * gwern doesn't see how to unask the question
12:06:03 <dmwit> Seems like a reasonable question to me.
12:06:09 <ehird> I just answer Mu to things that I want to answer but have no answer to.
12:06:12 <ehird> It confuses people.
12:06:32 <SamB> ehird: why do you do that?
12:06:39 <dmwit> gwern: It doesn't annoy me.  But I also don't use Hackage very much, and never even noticed that behavior.
12:07:23 <chylli> dcoutts: another question. I tried cabal upgrade a moment ago and it said there is no a upgrade plan because of dependence error. but now I run it again it said 'cabal: No cabal file found.'
12:07:54 <gwern> dmwit: it's an issue for me when I go around adding links to wiki pages and such - when I want to right 'also take a look at dons [http:... pcre-light] package', I don't mean 'this one specific 0.3.1 version', I mean 'the latest pcre-light'
12:08:14 <chessguy_> @pl \f -> f x
12:08:14 <lambdabot> ($ x)
12:08:27 <gwern> it's kind of like linking to a WP article: most of the time you want to say 'look at the latest', not 'look at the version as of 12:45 6/1/08'
12:08:34 <dmwit> gwern: Yeah, I can see how it would be annoying.
12:08:47 <Deewiant> @pl flip id x
12:08:48 <lambdabot> ($ x)
12:09:14 <dmwit> People who bought ($ x) also looked at:
12:09:23 <dmwit> Control.Monad.Reader
12:09:29 <int-e> ap id id
12:09:32 <ddarius> dmwit: Control.Monad.Cont
12:09:44 <ddarius> return x = Cont ($ x)
12:09:58 <dmwit> Oooh, I really should take the time to figure out what Cont does.
12:10:13 <Botje> magic :(
12:10:27 <ddarius> It just hides continuation passing.
12:10:52 <dmwit> Well, since I don't know what continuation passing is like that doesn't really help much.
12:11:00 <dmwit> I think looking at the source will be the right next step. =P
12:11:52 <ddarius> @src Monad Cont
12:11:52 <lambdabot> Source not found. My pet ferret can type better than you!
12:11:55 <ddarius> @src Cont Monad
12:11:56 <lambdabot> Source not found.
12:12:05 <dmwit> ?src Cont (>>=)
12:12:06 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
12:12:07 <ddarius> dmwit: djinn knows all
12:13:59 <chessguy_> hmm, can a class method not have a function whose type doesn't mention the type variable?
12:14:21 <chessguy_> e.g., class Foo a where bar :: Bar -> Bar
12:14:24 <ddarius> chessguy: In Haskell 98 it can't.
12:14:25 <dmwit> Correct.
12:14:28 <chylli> dcoutts: 'cabal fetch HTTP' has no action. why ?
12:14:34 <dmwit> chessguy_: How would it know which instance to use?
12:15:43 <int-e> phantom types to the rescue. newtype Mark a b = Mark { unMark :: b }; class Foo a where bar :: Mark a (Bar -> Bar)
12:15:56 <chessguy_> hm
12:16:02 <ddarius> int-e: Or you could just add an extra argument...
12:16:25 <ddarius> :t sizeOf
12:16:26 <lambdabot> Not in scope: `sizeOf'
12:16:32 <int-e> ddarius: yes, but I'll pay for it later.
12:16:37 <dmwit> ?hoogle sizeOf
12:16:37 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
12:16:50 <dmwit> > sizeOf (undefined :: Int)
12:16:50 <lambdabot>   Not in scope: `sizeOf'
12:17:01 <dmwit> > Foreign.Storable.sizeOf (undefined :: Int)
12:17:02 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
12:18:00 <int-e> ddarius: (the compiler has no way of knowing that the argument isn't used, in general. and you can easily define a helper function of type  Mark a b -> a -> b  to get the ease of use of dummy arguments back)
12:26:10 <chessguy_> @pl \x y -> w (f x) (f y)
12:26:10 <lambdabot> (. f) . w . f
12:26:56 <chessguy_> @pl \x y -> w (r (f x)) (r (f y))
12:26:57 <lambdabot> (. (r . f)) . w . r . f
12:27:04 <chessguy_> :(
12:30:21 <Deewiant> @src on
12:30:22 <lambdabot> (*) `on` f = \x y -> f x * f y
12:30:26 <Deewiant> chessguy_: ^
12:31:32 <chessguy_> @hoogle on
12:31:32 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:31:32 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
12:31:32 <lambdabot> Data.Function :: module
12:38:31 <chessguy_> Deewiant, nice, thanks
12:38:44 <underscore> Does anyone know how to get rid of a "thread blocked indefinitely"?
12:38:57 <Baughn> underscore: Sure. Don't get deadlocked.
12:39:10 <underscore> In ghci the routine in question does not deadlock.
12:39:20 <Baughn> So it's a race condition, then?
12:39:45 <Baughn> (Or try pasting the code.)
12:41:14 <dons> underscore: it typically means a bug in your code -- you've created an MVar condition such that a thread can make no progress
12:41:35 <underscore> Why would it succeed in ghci, though?
12:42:00 <Baughn> underscore: Any number of possible reasons. Code runs in a slightly different order, perhaps, which would make it a race condition
12:42:46 <Baughn> underscore: Or trying to grab an MVar twice in the same thread
12:43:54 <Baughn> underscore: If the code is small, try pasting it. If not.. try rewriting it; by far the best way to fix threading bugs is not to write them in the first place.
12:44:07 <Baughn> underscore: (What do you use MVars for in your program?)
12:45:10 <underscore> Baughn: The whole thing is an implementation of the ambient calculus
12:45:44 <sjanssen> underscore: does your program simply hang forever in ghci?
12:45:53 <underscore> sjanssen: No, it works correctly in ghci.
12:46:00 <opqdonut> kinda hard to empirically find that it hangs forever
12:46:35 <Baughn> A thread blocked/deadlock exception does just that, though
12:46:42 <schme> I'm going through the wikibook here and I got to writing a function `diffs' that returns a list of differences between adjacent items. The site says I should create a helper function and such so my wondering is if it is bad to just use zip ?
12:46:48 <underscore> Baughn: without printing anything?
12:46:56 <Baughn> underscore: No, it prints something
12:47:16 <sjanssen> schme: using zip is fine
12:47:18 <underscore> Baughn: But this prints nothing-- and I'm pretty sure that the ambient programs are executing correctly
12:47:23 <ddarius> zipWith would probably be better.
12:47:27 <schme> sjanssen: Ah thanks :)
12:47:33 <schme> Hmm.. I'll look up zipWith :)
12:47:40 <Baughn> underscore: You /are/ compiling with -threaded, right?
12:47:48 <underscore> Baughn: It's only when I run it after having compiled with ghc that I get the 'thread blocked indefinitely' problems.
12:48:05 <underscore> Baughn: yes: ghc -threaded --make Main
12:48:16 <schme> ddarius: My god, that's even easier.
12:48:35 <Baughn> underscore: Well, I can't really help. It's a deadlock; if you're implementing ambient calculus you should already know how to write and debug ordinary threading models.
12:48:52 <ddarius> > ap(zipWith(-))tail $ [0..]
12:48:53 <lambdabot>  [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,...
12:49:22 <Baughn> > ap(zipWith(-))tail $ [0,2..]
12:49:23 <lambdabot>  [-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,-2,...
12:50:10 <ddarius> > ap(zipWith(-))tail $ map (join(*)) [0..]
12:50:11 <lambdabot>  [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19,-21,-23,-25,-27,-29,-31,-33,-35,-37,-39,...
12:50:32 <ddarius> > scanl1 (+) $ ap(zipWith(-))tail $ map (join(*)) [0..]
12:50:33 <lambdabot>  [-1,-4,-9,-16,-25,-36,-49,-64,-81,-100,-121,-144,-169,-196,-225,-256,-289,-3...
12:50:40 <schme> (what have I done)
12:51:18 <ddarius> > ap(zipWith subtract)tail $ map (join(*)) [0..]
12:51:20 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:58:31 <underscore> This is pretty bizarre
12:59:00 <Beelsebob> so um... why?
12:59:08 <underscore> The way the program is set up is that it builds all of the threads the ambient processes are running in, then waits on an MVar
12:59:29 <underscore> One of the ambient processes can signal the main thread to wake up by writing to that MVar
13:00:01 <underscore> If I insert a threadDelay between setting up the processes and waiting on that MVar, it works
13:00:36 <Baughn> underscore: How do you "write to the MVar"?
13:00:40 <Baughn> underscore: Not modifyMVar?
13:00:55 <underscore> Baughn: http://hpaste.org/7530
13:01:54 <underscore> Baughn: The main thread executes the snd action; some ambient thread is responsible for calling the fst.
13:02:05 <Baughn> underscore: Nothing inherently wrong there. Add debugging output to tell when they are called?
13:03:14 <underscore> Baughn: I'm playing with that now. It seems like a wakeup's getting lost in the ghc version that isn't getting lost otherwise
13:03:17 <Baughn> underscore: The only way you'd get "thread not runnable" (in reference to the one that is blocking on takeMVar) is if the fst action has been lost - if no runnable thread has a reference to it. (That works recursively; a non-runnable thread also counts, so long as it isn't itself blocked indefinitely)
13:03:43 <Baughn> underscore: What ghc version?
13:03:58 <Baughn> underscore: If you can write a simple test-case for this, you should report it. It /could/ be a ghc bug
13:04:01 <underscore> Baughn: 6.8.2
13:04:32 <chessguy_> @hoogle [[a]] -> (a -> b) -> [b]
13:04:33 <lambdabot> No matches, try a more general search
13:04:43 <chessguy_> you're kidding
13:04:49 <underscore> Baughn: I understand that (re: thread graph), but I still can't fathom how the delay would fix an unrelated deadlock. (It happens on every execution I've tried; the ghci version has never deadlocked.)
13:05:03 <chessguy_> @hoogle (a -> b) -> [[a]] -> [b]
13:05:03 <lambdabot> No matches, try a more general search
13:05:49 <chessguy_> weird
13:05:53 <Baughn> underscore: Presumably that delay gives another thread time to call putMVar first. Well, it /could/ be a bug.. does it get called anyway? What does your debug output say?
13:06:16 <Baughn> If putMVar is called and some takeMVar doesn't return, that is definitely a bug
13:07:17 <chessguy> @type \f xss -> concat (map (map f) xss)
13:07:19 <lambdabot> forall a b. (a -> b) -> [[a]] -> [b]
13:07:41 <chessguy> @pl \f xss -> concat (map (map f) xss)
13:07:42 <lambdabot> (join .) . map . map
13:10:26 <underscore> Baughn: Hm-- it doesn't look like it's getting called during the ghc run. I still suspect a missed wakeup. (I do condition variables like this: http://hpaste.org/7531 )
13:10:44 <chessguy> @hoogle ([a] -> [b]) -> [[a]] -> [b]
13:10:45 <lambdabot> No matches, try a more general search
13:11:25 <ADEpt> anyone here with some LazySmallCheck experience under their belt?
13:11:44 <chessguy> @type concat . map
13:11:46 <lambdabot>     Couldn't match expected type `[[a]]'
13:11:46 <lambdabot>            against inferred type `f a1 -> f b'
13:11:46 <lambdabot>     Probable cause: `map' is applied to too few arguments
13:12:21 <chessguy> @pl \f xss -> concat (map f xss)
13:12:21 <lambdabot> (=<<)
13:12:22 <ddarius> @free concat
13:12:24 <lambdabot> $map f . concat = concat . $map ($map f)
13:12:32 <ehird> @free?
13:12:32 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:12:40 <ehird> @free id
13:12:42 <lambdabot> f . id = id . f
13:12:43 <chessguy> :t (=<<)
13:12:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:12:47 <gwern> @seen dcoutts
13:12:47 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell-blah, #ghc and #haskell. I last heard dcoutts speak 1h 12m 10s ago.
13:12:49 <ehird> @free (>>=)
13:12:49 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:12:50 <pitseleh> is there a do nothing in haskell?
13:12:54 <pitseleh> like python's pass?
13:13:00 <ehird> pitseleh: what is that supposed to mean
13:13:01 <ddarius> So concat (map (map f) xss) is map f (concat xss)
13:13:02 <ehird> what type would it be
13:13:12 <ehird> @free flip
13:13:14 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
13:13:15 <pitseleh> i want to quit an IO function
13:13:18 <Saizan> pitseleh: return () ?
13:13:18 <gwern> dmwit: incidentally, I've added a bug report for that thing I mentioned earlier: http://hackage.haskell.org/trac/hackage/ticket/278
13:13:20 <lambdabot> Title: #278 (Default to non-versioned links in Hackage index) - Hackage - Trac
13:13:30 <pitseleh> Saizan, that might work..
13:13:39 <chessguy> @type \f xss -> map f (concat xss)
13:13:41 <lambdabot> forall b a. (a -> b) -> [[a]] -> [b]
13:13:51 <chessguy> @pl \f xss -> map f (concat xss)
13:13:52 <lambdabot> (. join) . map
13:14:09 <pitseleh> ehird, i have a mainLoop function that calls itself to keep the program running until the user chooses to quit
13:14:38 <ehird> pitseleh: well you're not thinking very functually
13:14:41 <ehird> @free (\x -> 2)
13:14:41 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:15:20 <pitseleh> ehird, i know :/ i'm just starting.. i'll get a better grip of monads for my next app
13:15:23 <chessguy> @hoogle join
13:15:24 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
13:15:24 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
13:15:24 <lambdabot> System.FilePath.Windows.joinDrive :: FilePath -> FilePath -> FilePath
13:15:59 <ehird> pitseleh: well, try forgetting about them instead
13:16:00 <ehird> ;)
13:16:34 <pitseleh> ehird, that would be more purely functional, at least conceptually :)
13:16:47 <ehird> pitseleh: exactly
13:16:54 <ehird> write your program purely functionally as much as you can
13:17:00 <ehird> then write a tiny main loop around it
13:18:05 <pitseleh> i'm learning that with the difficulty of this app, i'll do it differently next time
13:19:45 <gwern> dons: did you ever do a blog post about pcre-light? I have vague memories of something, but google wots it not
13:24:15 <gwern> dons: anyways: http://haskell.org/haskellwiki/?title=Regular_expressions&diff=20913&oldid=11760
13:24:16 <lambdabot> Title: Regular expressions - HaskellWiki, http://tinyurl.com/5lghzr
13:24:52 <chessguy> @pl \f xss -> concat (map f xss)
13:24:53 <lambdabot> (=<<)
13:25:00 <chessguy> @type \f xss -> concat (map f xss)
13:25:03 <lambdabot> forall a a1. (a -> [a1]) -> [a] -> [a1]
13:25:39 <chessguy> @type [[a]] -> [a]
13:25:41 <lambdabot> parse error on input `->'
13:25:45 <chessguy> why am i getting so confused?
13:25:50 <chessguy> @hoogle [[a]] -> [a]
13:25:50 <lambdabot> Prelude.concat :: [[a]] -> [a]
13:25:50 <lambdabot> Data.List.concat :: [[a]] -> [a]
13:25:50 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
13:27:52 <mehrheit> @src intercalate
13:27:52 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
13:28:14 <byorgey> chessguy: what are you confused about?
13:28:54 <chessguy> byorgey, i think i've got it now
13:28:59 <chessguy> don't mind me
13:29:03 <byorgey> chessguy: ok, cool =)
13:30:53 <chessguy> @pl \ss -> map f (g ss)
13:30:53 <lambdabot> map f . g
13:32:59 <tahir_hhh> Has anyone ever set up HDirect?
13:33:43 <tahir_hhh> COM (component object model) is for Windows, yet the author seems to want us to build it using GNU tools!
13:33:58 <tahir_hhh> I dont have gnu tools but I have visual studio!
13:34:40 <pitseleh> but you can have mingw if you need to
13:34:50 <pitseleh> i don't know what the COM build requirements are
13:35:23 <tahir_hhh> pitseleh: if I use mingw what about my paths?
13:35:53 <tahir_hhh> I just wish that the author told me I could use the Microsoft nmake.
13:36:14 <pitseleh> tahir_hhh, i don't know, sorry :(, never used gnu tools outside of linux
13:36:31 <dons> tahir_hhh: its 10 years or more old, isn't it?
13:36:43 <dons> i've not heard of it in use for a long time
13:36:57 <tahir_hhh> dons: HDirect or GNU?
13:37:05 <dons> hdirect. :)
13:37:50 <tahir_hhh> of course ;). It says that the last release was 2004 which is fairly recent in in the Microsoft world
13:39:16 <ehird> @free id.flip
13:39:17 <lambdabot> Extra stuff at end of line
13:39:23 <ehird> @free pa
13:39:24 <ehird> @free ap
13:39:24 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `pa'\n\n"
13:39:26 <lambdabot> Expected variable or '.'
13:39:32 <ehird> @free ap
13:39:34 <lambdabot> Expected variable or '.'
13:39:36 <ehird> :|
13:40:37 <tahir_hhh> It should not matter if I use cygwin's gnu make or mingw's make should it?
13:42:53 <chessguy> @pl \c s -> c' (b c s) d
13:42:53 <lambdabot> flip flip d . (c' .) . b
13:43:04 <ddarius> ehird: @free takes a type actually.  It fetches the type if you give it a term.
13:43:08 <ddarius> @free a -> b -> b
13:43:09 <lambdabot> Extra stuff at end of line
13:43:20 <ddarius> @free forall a b. a -> b -> b
13:43:20 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
13:43:36 <ehird> ddarius: I find issue with your statement.
13:43:37 <ehird> ;)
13:43:38 <ddarius> @free f :: a -> b -> b
13:43:39 <lambdabot> h . f x = f (g x) . h
13:43:44 <ehird> @free x :: a
13:43:44 <lambdabot> f x = x
13:43:52 <ehird> @free x :: a -> a
13:43:53 <lambdabot> f . x = x . f
13:43:58 <ddarius> @free f :: Monad a => a -> mb a
13:43:59 <lambdabot> Extra stuff at end of line
13:44:01 <ddarius> @free f :: Monad a => a -> m a
13:44:02 <lambdabot> Extra stuff at end of line
13:44:12 <ehird> @free f :: (Monad a) => a -> m a
13:44:12 <lambdabot> Extra stuff at end of line
13:44:20 <ehird> I hate lambdabot tools which only support a tiny subset of Haskell.,
13:44:25 <ehird> With a fiery passion.
13:44:29 <ddarius> @free eq :: Eq a => a -> a -> Bool
13:44:30 <lambdabot> Extra stuff at end of line
13:44:34 <ddarius> It doesn't do type classes.
13:44:46 <ehird> ddarius: Fail
13:44:46 <Cale> ehird: Then fix them to work with a larger subset :P
13:44:54 <ddarius> ehird: The restrictions on djinn are there for a reason.
13:45:01 <Cale> ehird: I'll gladly apply the patches :)
13:45:27 <ddarius> Er free.
13:45:47 <ehird> Cale: But that's, like, >work<
13:46:09 <Cale> It seems like free should perhaps be able to handle typeclasses at least to some extent.
13:47:32 <daveux> Can anyone tell me how to do IO within an HUnit test case?
13:47:44 <codetoad> daveux: unsafePerformIO i'm guessing
13:47:54 <codetoad> that's what I had to do within quickcheck at lesat
13:48:01 <daveux> eh.. there has to be a safer way
13:48:39 <eu-prleu-peupeu> does haskell allow "lambda objects" ? (or something like that ?)
13:48:44 <eu-prleu-peupeu> like "anonymous objects"
13:49:15 <ehird> eu-prleu-peupeu: what
13:49:18 <daveux> eu-prleu-peupeu: \x -> x + 1
13:49:26 <Cale> eu-prleu-peupeu: lambda expressions?
13:49:34 <ehird> daveux: beauty in the beast stuff might help
13:49:36 <Cale> > map (\x -> x + 1) [1..10]
13:49:38 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:50:03 <Cale> > zipWith (\x y -> x + y) [1..10] [10,20..100]
13:50:05 <lambdabot>  [11,22,33,44,55,66,77,88,99,110]
13:52:34 <daveux> Hmm.., looks like HUnit is not creating its own monad. I was in IO after all...
13:52:35 <daveux> :)
13:53:05 <codetoad> so the hunit functions have type a -> IO Bool or something?
13:53:37 <Cale> type Assertion = IO ()
13:54:23 <daveux> Ah.
13:58:21 <pchiusano> hello
13:58:55 <Cale> hello
13:58:57 * qwr  
13:59:03 <pchiusano> what is the easiest way to get the source code for standard prelude functions?
13:59:18 <pchiusano> ... and/or data structures
13:59:18 <Cale> Probably the report, unless you want the exact source code
13:59:28 <Cale> http://haskell.org/onlinereport/standard-prelude.html
13:59:29 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
13:59:40 <Zao> pchiusano: I believe that the GHC docs have source code links.
13:59:56 <Cale> It does, yeah.
13:59:57 <Zao> Or just download source code for your compiler of choice.
14:00:03 <pchiusano> okay, cool
14:00:03 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
14:00:06 <lambdabot> http://tinyurl.com/y4wexy
14:00:11 <Baughn> pchiusano: LB's @src command also tend to produce.. something. Not always the correct thing.
14:00:35 <edwardk> woohoo, i finally figured out how to keep the 'Dual' category instance heads from blowing up. means a lot more instance declarations, but hey. so now i can steal the rest of my stuff from my categories library and fold it into category-extras
14:00:39 <Cale> The Report source is optimised only for readability. The actual source is perhaps somewhat different.
14:00:44 <pchiusano> has anyone written a tool to quickly lookup source from the 98 report
14:00:53 <Cale> Well, there's @src
14:00:57 <Cale> @src foldr
14:00:58 <lambdabot> foldr f z []     = z
14:00:58 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:01:01 <Baughn> @src (++)
14:01:01 <lambdabot> []     ++ ys = ys
14:01:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:01:01 <lambdabot> -- OR
14:01:01 <lambdabot> xs ++ ys = foldr (:) ys xs
14:01:01 <lambdabot> -- In lambdabot, this is generalised to:
14:01:03 <lambdabot> (++) = mappend
14:01:22 <pchiusano> does lambdabot get src from the report?
14:01:29 <Cale> It gets it from all over.
14:01:42 <qwr> pchiusano: just follow the links in the ghc lib docs
14:01:44 <Cale> It has a text file of definitions which it reads.
14:02:46 <Cale> (I try to keep it optimised for readability though)
14:02:50 <Cale> @src sequence
14:02:50 <lambdabot> sequence []     = return []
14:02:50 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:02:50 <lambdabot> --OR
14:02:50 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:03:29 <pchiusano> it would be cool if there were a web interface to lambdabot's src-getting capabilities
14:03:45 <ddarius> There was a web interface to lambdabot at one point.
14:04:10 <Cale> pchiusano: Well, much of the source is on the web, linked from the GHC documentation. It's not quite the same of course.
14:04:16 <yitz> pchiusano: I usually look here: http://darcs.haskell.org/packages/base/Prelude.hs
14:04:36 <orbitz> what ways are there to achieve an object heirarchy other htan classes?
14:05:07 <edwardk> @where oohaskell
14:05:08 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
14:05:12 <ddarius> type classes don't give you an object heirarchy
14:05:34 <Cale> orbitz: You mean for the purposes of designing a binding to an external library?
14:05:41 <yitz> orbitz: ADTs (data structures and records defined using "data")
14:05:57 <daveux> How can I tell which OS I'm on?
14:06:29 <edwardk> orbitz: you can go through some oohaskell type stuff if you want the rocket-science end of things. you can also wrap 'subclasses' in parent classes or vice versa and use some lifting operations to get to the values. (though you need typeclasses to get to the values if you wrap superclasses in subs)
14:06:43 <orbitz> Cale: like ways to implement an exception heirarchy
14:06:46 <edwardk> er 'subclasses' and 'parent classes' being data types in that sense
14:07:09 <edwardk> orbitz: http://www.haskell.org/~simonmar/papers/ext-exceptions.pdf
14:07:45 <yitz> daveux: System.Info
14:07:52 <yitz> os, arch, compiler
14:08:45 <orbitz> edwardk: reading, thanks
14:14:16 <gwern> > let (-->) = (+) in 2 --> 2
14:14:16 <lambdabot> Unbalanced parentheses
14:14:27 <gwern> > let (-->) = (+) in (-->) 2 2
14:14:27 <lambdabot> Unbalanced parentheses
14:14:43 <dmwit> -- is a comment, right?
14:14:55 <gwern> I don't *think* so
14:15:11 <gwern> http://haskell.org/haskellwiki/Xmonad/Config_archive/Octoploid's_xmonad.hs
14:15:13 <lambdabot> Title: Xmonad/Config archive/Octoploid's xmonad.hs - HaskellWiki, http://tinyurl.com/68qv7q
14:15:18 <gwern> note that you have --> being used as an operator, but colored as comment
14:15:22 <dmwit> gwern: You're right, it works in ghci.
14:15:39 <dmwit> gwern: \bot's sanity-check parser is probably just broken a little.
14:16:04 * gwern is more concerned about the syntax highlighting, but lambdabot is a concern too
14:16:21 <dmwit> Oh, yeah, Haskell.org's parser seems broken, too. =P
14:16:41 * dmwit wonders if there's a way to ask GHC for its parse tree.
14:17:18 <pchiusano> I have a question
14:17:39 <dmwit> Just as a side note: vim gets this right. =)
14:17:48 <RayNbow> pchiusano: just ask the question :)
14:17:54 <pchiusano> is it true to say that there is always a mechanical translation possible between the monadic and nonmonadic versions of a function
14:18:15 <pchiusano> or are there cases where the translation is nontrivial
14:18:16 <RayNbow> (and highly probable, I think everyone here has questions ;))
14:18:23 <pchiusano> hehe
14:18:30 <gwern> fwiw, so does emacs
14:18:42 <dmwit> pchiusano: Well, the compiler does a mechanical translation.
14:18:49 <dmwit> So, I guess it must not be *too* hard. ;-)
14:19:01 <gwern> pchiusano: do you mean, 'can I always turn the >>= >> return sequences into lambda expressions?'
14:19:19 <pchiusano> are you saying nonmonadic code is lifted to the identity monad, or something like that?
14:19:28 <yitz> > let x --> y = x + y in 2 --> 2
14:19:29 <lambdabot>  4
14:19:31 * gwern guesses so, aren't the monadic operators kind of defined in nonmonadic terms?
14:19:54 <dmwit> gwern: Ah, great, good editors++
14:20:28 <yitz> Cale: are you aware of this lambdabot issue that gwern has raised?
14:20:42 <pchiusano> gwern, no, I mean - functions like map/liftM fold/foldM
14:20:55 <yitz> > let (-->) = (+) in 2 --> 2
14:20:55 <lambdabot> Unbalanced parentheses
14:21:00 <Cale> huh?
14:21:03 <vixey> -- is a comment
14:21:09 <yitz> > let x --> y = x + y in 2 --> 2
14:21:10 <lambdabot>  4
14:21:11 <gwern> so what is haskell.org using to do highlighting?
14:21:24 <Cale> Oh, that's probably a bug in the parser.
14:21:38 <gwern> yeah, but whom do I tell about this?
14:21:44 <yitz> Cale :)
14:22:21 <pchiusano> @src foldM
14:22:21 <lambdabot> foldM _ a []     = return a
14:22:21 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:22:31 <gwern> yitz: Cale maintains the wiki?
14:22:38 <pchiusano> @src foldl
14:22:39 <lambdabot> foldl f z []     = z
14:22:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:22:43 <yitz> no, lambdabot
14:22:45 <Cale> The wiki?
14:22:54 <dmwit> The wiki's code highlighter also has this bug.
14:23:00 <dmwit> Or a similar one, at least.
14:23:04 <codetoad> pchiusano:  why wouldn't you be able to transform a -> b into m a -> m b? it would always be possible..?
14:23:20 <dmwit> codetoad: I think he's talking about the other direction.
14:23:35 <Cale> In fact, GHC had that bug for a while.
14:23:46 <gwern> dmwit: it might be the same one, if 'let (-->)...foo' is seen as 'let (< -- comments, untermindated parenthesis'
14:23:47 <pchiusano> codetoad - I guess I am talking about both directions
14:23:56 <dmwit> pchiusano: With the exception of a few low-level monads (IO, STM), all of the monads you use on a day-to-day basis just boil down to pure code.
14:24:12 <gwern> except in haskell.org's case, it never gets to unterminated parenthesis, obviously, so it just renders everything to the newline as comment
14:24:26 <dmwit> pchiusano: Oh, well, lifting into a monad is easy:
14:24:28 <dmwit> :t liftM
14:24:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:24:43 <dmwit> ?src liftM
14:24:43 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:25:43 <edwardk> does anyone know the version of haddock that started supporting class associated types?
14:25:49 <Cale> x --> y = y
14:25:49 <Cale>   :: String
14:25:49 <Cale> x = "1"
14:25:49 <Cale> main = print $ x --> "2"
14:26:00 <edwardk> and infix type operators?
14:26:20 * edwardk is fixing up cabal files/#ifdef blocks
14:28:56 <sjanssen> edwardk: 2.0, I assume
14:29:09 <sjanssen> that is the version that switched to the GHC API
14:29:23 <edwardk> sjanssen: thx. do you know if the __HADDOCK__ define includes the version number?
14:29:35 <sjanssen> I don't know
14:29:58 <edwardk> i've been paranoid and hiding a crapload of stuff from haddock and i want to relax that a bit
14:30:20 <sjanssen> Haddock 2 should handle everything GHC handles
14:30:50 <Beelsebob> notably, it doesn't handle an entire line of ------- in a haddock comment though
14:31:14 <edwardk> sjanssen: hrmm, i guess i'll just kill the #ifnfdef __HADDOCK__ blocks then and say 'use haddock 2.0!'
14:31:59 <Beelsebob> edwardk: well, Haddock now being cabalised, you can make it a reuirement in your .cabal file
14:32:13 <edwardk> Beelsebob: yeah
14:32:29 <edwardk> waiting for 6.10 so i can reasonably require type families too =)
14:34:12 <pchiusano> > map (:[]) [1..4]
14:34:13 <lambdabot>  [[1],[2],[3],[4]]
14:34:30 <pchiusano> join . map (:[]) [1..4]
14:34:56 <pchiusano> > join . map (:[]) [1..4]
14:34:57 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
14:34:57 <vixey> :t join
14:34:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:35:00 <yitz> > map return [1..4] :: [[Int]]
14:35:01 <lambdabot>  [[1],[2],[3],[4]]
14:35:13 <Cale> > join . map return $ [1..4]
14:35:14 <lambdabot>  [1,2,3,4]
14:35:24 <vixey> > return =<< [1,2,3,4]
14:35:25 <lambdabot>  [1,2,3,4]
14:35:34 <yitz> > join $ map return [1..4] :: [[Int]]
14:35:36 <lambdabot>   add an instance declaration for (Num [Int])
14:35:36 <lambdabot>     In the expression: 1
14:35:37 <Cale> > id $ [1..4]
14:35:39 <lambdabot>  [1,2,3,4]
14:35:59 <pchiusano> hmm, how come join doesn't just work for concatenating a list of lists?
14:35:59 <yitz> > join $ map return [1..4]
14:36:02 <lambdabot>  [1,2,3,4]
14:36:04 <Cale> yitz: [Int], not [[Int]] of course
14:36:15 <vixey> > concat ["foo","bar","baz"]
14:36:15 <yitz> thanks. forgot to erase that
14:36:16 <lambdabot>  "foobarbaz"
14:36:33 <pchiusano> :t join
14:36:35 <augustss> > join ["foo","bar","baz"]
14:36:35 <Cale> pchiusano: It doesn't?
14:36:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:36:36 <lambdabot>  "foobarbaz"
14:36:43 <vixey> @src join
14:36:44 <lambdabot> join x =  x >>= id
14:36:49 <pchiusano> join [[1],[2]]
14:36:50 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
14:36:51 <lambdabot>  [1,2,3,4,5,6,7,8]
14:37:03 <pchiusano> huh, that's weird
14:37:07 <earthy> why?
14:37:14 <pchiusano> why didn't this work, then -
14:37:16 <vixey> > [[1,2,3],[4,5],[6,7,8]] >>= id
14:37:18 <lambdabot>  [1,2,3,4,5,6,7,8]
14:37:36 <Cale> > do xs <- [[1,2,3],[4,5],[6,7,8]]; x <- xs; return x
14:37:38 <lambdabot>  [1,2,3,4,5,6,7,8]
14:37:45 <vixey> > (flip concatMap) [[1,2,3],[4,5],[6,7,8]] id
14:37:46 <lambdabot>  [1,2,3,4,5,6,7,8]
14:37:46 <pchiusano> > join (:[]) [1..4]
14:37:47 <lambdabot>  Couldn't match expected type `a1 -> a' against inferred type `[a1]'
14:38:00 <pchiusano> oop, I mean -
14:38:05 <yitz> pchiusano: you used . instead of $ before
14:38:15 <Cale> Or you forgot a $\
14:38:20 <vixey> @src ((->)e) Monad
14:38:20 <lambdabot> Source not found. You speak an infinite deal of nothing
14:38:25 <vixey> @src Monad ((->)e)
14:38:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:38:26 <pchiusano> > join $ map (:[]) [1..4]
14:38:28 <lambdabot>  [1,2,3,4]
14:38:30 <Cale> > join . map (:[]) $ [1..4]
14:38:32 <lambdabot>  [1,2,3,4]
14:38:32 <vixey> @src Monad (->)
14:38:33 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:38:36 <vixey> @src (->) Monad
14:38:36 <lambdabot> Source not found. Maybe you made a typo?
14:38:36 <pchiusano> ah, ok, i see
14:38:40 <vixey> @src Monad ->
14:38:41 <lambdabot> Source not found. You type like i drive.
14:38:45 <vixey> @src -> Monad
14:38:46 <lambdabot> Source not found. Are you on drugs?
14:38:56 <vixey> lambdabot needs more brains
14:39:00 <earthy> vixey: you can msg lambdabot...
14:39:35 <Cale> @src (->) return
14:39:36 <lambdabot> return = const
14:39:40 <Cale> @src (->) (>>=)
14:39:40 <lambdabot> f >>= k = \ r -> k (f r) r
14:39:48 <Cale> @src (->) fmap
14:39:48 <lambdabot> fmap = (.)
14:40:22 <yitz> Cale: fmap = (.) and (.) = fmap ?
14:40:31 <Cale> yitz: :)
14:41:07 <sjanssen> so fmap = _|_?
14:41:09 <vixey> @pl \f k r -> k (f r) r
14:41:10 <lambdabot> flip flip id . (ap .) . flip (.)
14:41:38 <yitz> sjanssen: worse yet, (.) = |
14:41:59 <yitz> |
14:42:29 <yitz> (why can't I write "bottom" in this irc client?)
14:42:40 <yitz>  |
14:43:40 <Beelsebob> ?
14:44:06 <Beelsebob> hmm, I should convert one of my programs to use all unicode, and see how it comes out
14:44:16 <Beelsebob> I suspect rather beautifully
14:44:32 <yitz> Beelsebob: that came out as Latin-1 garbage for me.
14:44:48 <Beelsebob> yitz: was sent as UTF-8
14:44:50 <lament> yitz: use utf-8.
14:44:57 <Vq^> yitz: then you're using the wrong encoding
14:45:35 <lament> Latin-1, i'm guessing :)
14:45:39 <yitz> Beelsebob: please send that again
14:45:47 <Beelsebob> 
14:46:00 <Beelsebob> yitz: what client are you using?
14:46:02 <yitz> blech.
14:46:15 <yitz> at this moment: ksirc
14:46:29 <yitz> i usually use Colloquy on the Mac.
14:46:54 <Beelsebob> maybe use xchat on linux?
14:47:07 <Beelsebob> incidentally -- that was Colloquy sending it, so :P
14:47:19 <vixey> (f >>= (*)) x = f x * x
14:47:31 <yitz> Beelsebob: i'm experimenting with xmonad/kde
14:48:40 <vixey> palindrome = reverse >>= (==)
14:49:10 <Beelsebob> vixey: does that make sense for all monads?
14:49:16 <edwardk> hrm ghc 6.9 allows type families in instance heads?
14:49:22 <vixey> only ((->)e)
14:49:53 <vixey> :t reverse >>= (==)
14:49:55 <lambdabot> forall a. (Eq a) => [a] -> Bool
14:49:58 <yitz> vixey: cool!
14:50:11 <vixey> trying to think of other uses for f x * x
14:50:34 <edwardk> @hpaste
14:50:34 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:51:08 <edwardk> why do these not conflict? http://hpaste.org/7533
14:51:11 <jpcooper> hello
14:51:32 <axm> hi
14:51:33 <jpcooper> what alternatives are there to using SQL as something to manipulate a simple database with?
14:51:57 <edwardk> jcooper: if its reaaaaly tiny you can always use berkeley db
14:52:03 <yitz> jpcooper: if the db is sql-based, you are limited :)
14:52:08 <jpcooper> no
14:52:10 <edwardk> i.e. you just need a persistent hash or something
14:52:11 <jpcooper> I'm creating a new programme
14:52:24 <edwardk> @google berkeley db
14:52:25 <lambdabot> http://www.oracle.com/technology/products/berkeley-db/index.html
14:52:30 <jpcooper> I would like something maybe written in haskell
14:52:52 <axm> you mean bindings in haskell?
14:52:53 <ddarius> Beelsebob: That is using a particular monad.
14:52:57 <edwardk> @where haskelldb
14:52:57 <lambdabot> http://haskelldb.sourceforge.net/
14:53:12 <Beelsebob> ddarius: yeh, I noticed after
14:53:14 <jpcooper> no, I mean some DB system that was written for haskell
14:53:24 <vixey> (f x * x >>= (+)) y = (f x * x) y + y
14:53:25 <jpcooper> thanks, edwardk
14:53:30 <yitz> jpcooper: in the simple case, you can just use Data.Map and serialize it to disk.
14:53:47 <jpcooper> yitz, I'd rather not rewrite relationship algebra in haskell
14:53:51 <jpcooper> relational*
14:54:03 <yitz> jpcooper: good idea :)
14:55:17 <axm> the thing why relational dbs have been around for so long is that they have been around for so long
14:55:45 <axm> common problems like transaction issues are long solved there
14:56:13 <Cale> edwardk: I think the ambiguity will occur on use -- it won't be able to infer which instance you want, most likely.
14:57:14 <Cale> edwardk: But to be honest, I don't know a whole lot about how type families work.
14:57:29 <Cale> (and I don't have 6.9 installed to try things)
14:57:30 <edwardk> cale: k. mostly i was trying to see if i could use these type families to smuggle an 'alias' into an instance head so that the documentation was more readable with those not every one 15 combinators has to have instances for everything =)
14:58:23 <vixey> :t (\(+) (*) -> (\y -> (\x -> g x * x) (f y) y))
14:58:24 <edwardk> coz saying type (m :+: n) a = Lift Either m n a   prevents you from putting (m :+: n) in the head of an instance like instance Foo (m :+: n)    but using a type family that is explicitly of kind * -> * works =)
14:58:25 <lambdabot> forall t t1 t2 t3 t4. (SimpleReflect.FromExpr (t3 -> t1), SimpleReflect.FromExpr (t1 -> t2)) => t -> (t2 -> t1 -> t3 -> t4) -> t3 -> t4
14:58:42 <Cale> It might just be that GHC is not so good at determining when two type function applications reduce to the same thing?
14:58:44 <dons> a couple of new articles on reddit, http://reddit.com/r/programming/info/6ix07/comments/ and http://reddit.com/r/programming/info/6ix06/comments/
14:59:26 <RayNbow> dons: heh, I just opened one of them right before you mentioned them here :p
14:59:49 <Cale> What about   type (m :+: n) = Lift Either m n  -- ISTR there was a GHC extension which allowed type aliases in instance heads, so long as they expanded to something reasonable?
15:00:18 <edwardk> is that legal? (that would be a type declaration with kind * -> * no?
15:00:44 <edwardk> i think if it fully expands its ok, its because i want to do it at the functor level and i have unapplied bits and pieces
15:00:52 <edwardk> if that part is legal i get the best of both worlds
15:02:04 <Cale> edwardk: It seems to work for me...
15:02:30 <edwardk> cale: nice!
15:02:37 <edwardk> cale: then i can streamline a lot of code
15:06:23 <edwardk> cale: you my friend are a god striding among mere mortals. i can now undo about 8 hours of work =)
15:06:47 <jpcooper> I am wondering of something about Haskell
15:06:56 <saml> data Foo ..    class Foo ..    can I say Foo is a type constructor in both cases?
15:07:19 <jpcooper> say I were to insert a list into a list. If I change the first list, would the list in the second list also be changed?
15:07:40 <saml> i see similarities between type constructor and value constructor.  and class and instance
15:08:01 <edwardk> the nice thing is i was going to have to say everything about 6 times before, now i just say it once for the most general combinator and the more specific ones for the most part just work
15:08:04 <jpcooper> sorry, this is silly
15:08:17 <jpcooper> I forgot I was talking about haskell
15:08:18 <saml> jpcooper: [[1,2,3]] ?
15:08:29 <saml> that's a list of int lists
15:08:57 <jpcooper> I'm just wondering how I can implement my own database
15:09:22 <Zao> jpcooper: Take a peek at the DB interfaces in hackage?
15:09:29 <jpcooper> yes
15:09:52 <dmwit> jpcooper: Take a look at "relational algebra" on Wikipedia.
15:09:57 <saml> databases are there from the beginning. you don't implement them.
15:10:12 <Cale> edwardk: :)
15:10:42 <jpcooper> dmwit, yes, I know it
15:10:49 <edwardk> its always nice when you can delete 40k of haskell source
15:10:51 <jpcooper> I have an idea of how I'll do it
15:11:02 <Cale> 40k?!
15:11:09 <edwardk> yeah scary huh?
15:11:27 <dons> that's a lot of source.
15:11:27 <edwardk> ~800 instances and counting =)
15:11:30 <SamB> what is that, half an xmonad?
15:11:50 <edwardk> should be closer to 80-100 now
15:11:51 <jpcooper> edwardk, what is this of?
15:12:07 <saml> i bet his database
15:13:06 <edwardk> jcooper: a bunch of category theory stuff. i was grumbling that it was getting impossible to read instance heads like 'instance Functor f => Monad (Fix (Biff Either Identity f))'   instead of 'instance Functor f => Monad (Free f)'
15:13:31 <jpcooper> aah, I'm not as advanced in Haskell, yet
15:13:59 <vininim> mmm does DDC have access to haskell libraries?
15:14:09 <edwardk> jcooper: so i started writing a class of general functor combinators and deriving all the laws for them, but since each combinator was distinct to keep the code legible, just defining the instances was making for a lot of near-identical code.
15:15:21 <edwardk> so i went back and figured out how to solve my 'Dual category' problem (or at least bandaid it enough to use it) to cut down some of the classes, and cale gave me the piece to cut down most of the others. i'll still have to do a few combinators for things like Join or Fix, but they are the ones that actually play with the last couple of places in the type, so they SHOULD require work
15:15:22 <saml> even if i count lines of code i've ever written in any language, it wouldn't exceed 40k
15:16:07 <edwardk> saml: bytes not klocs =)
15:16:51 <edwardk> only 1.6 klocs =)
15:17:19 <SamB> saml: are you sure?
15:17:35 <edwardk> 40,000 lines isn't that much in the grand scheme of a programmer's life
15:17:48 <edwardk> well, it is more so in haskell than elsewhere, but still ;)
15:18:04 <SamB> yeah, it's easy to throw out that many lines of useless code
15:18:38 <SamB> not generally in one go, but
15:18:44 <vixey> what about lines of code you've generated?
15:18:46 <yitz> SamB: unfortunately, it's just as easy to throw out that many lines of useful code, too.
15:19:19 <dmwit> Why is that unfortunate?
15:19:21 <Cale> 40,000 lines is a *very* significant amount of Haskell code.
15:19:34 <Cale> At least, if it can be assumed to be well-written.
15:19:39 <yitz> good thing we have darcs
15:19:52 <saml> i have a couple of over 1000 lines of code home work submissions. i don't think they add up to 40k yet. maybe just about 40k
15:19:53 <SamB> Cale: well, lines of code written aren't assumed to be any good ;-)
15:19:58 <Valodim> 40000 lines?
15:20:05 <Valodim> how many lines does ghc have...?
15:20:11 <SamB> saml: oh, you only count finished programs ???
15:20:22 <Zao> Valodim: Depends on if you could libraries, the runtime and extra libs.
15:20:56 <saml> oh i see what you mean. I should've said that number of chatting lines exceeds number of source code lines i ever wrote
15:21:17 <Cale> Heh, the proportion of unfinished or throwaway code to useful-to-others code that I've ever produced is rather large :)
15:28:47 <cadabra> This is the beginning of a memoizing function: collatz n = map collatz [1..] !! (n-1)
15:29:07 <cadabra> Is there a sensible way to use a map or array instead of a list?
15:29:25 <dmwit> Data.Array
15:29:26 <dmwit> ?
15:29:50 <dmwit> You will need to decide on bounds first.
15:29:52 <dmwit> See also:
15:30:05 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
15:30:07 <lambdabot> Title: Gmane -- Mail To News And Back Again
15:30:08 <vixey> :t let collatz n = map collatz [1..] !! (n-1) in collatz
15:30:11 <lambdabot> forall a. Int -> a
15:30:39 <dmwit> vixey: It's probably collatz n = map collatz' [1..] !! (n-1)
15:31:12 <Beelsebob> > let collatz n = map collatz [1..] !! (n-1) in collatz 4
15:31:14 <cadabra> Oh, it's supposed to be memoCollatz = ...
15:31:14 <lambdabot>  Exception: stack overflow
15:31:31 <cadabra> mcollatz n = map collatz [1..] !! (n-1)
15:31:31 <cadabra>     where collatz 1 = 1
15:31:31 <cadabra>           collatz n = 1 + mcollatz (if even n then n `div` 2 else 3*n + 1)
15:31:48 * Beelsebob notes that cadabra is playing with project euler
15:32:01 <cadabra> ;o
15:32:15 <Cale> There are a bunch of Project Euler solutions on the wiki :)
15:32:26 <Beelsebob> Cale: what fun is that?
15:32:50 <dmwit> cadabra: Note that you can actually do *more* memoization than that.
15:33:10 <yitz> cadabra: memoization is almost never needed in project euler. if it's running too slowly, do some math.
15:33:34 <SamB> yitz: uh, dynamic programming is often appropriate
15:33:57 <yitz> SamB: ?
15:34:09 <cadabra> At this point I don't care too much about project euler, but would like to get comfy with memoizing in haskell instead.
15:34:10 <SamB> @go dynamic programming
15:34:11 <lambdabot> http://en.wikipedia.org/wiki/Dynamic_programming
15:34:22 <dmwit> Dynamic programming usually implies some memoization.
15:35:03 <SamB> at least, the easiest way to do it in Haskell is with memoization...
15:35:12 <yitz> dynamic programming solves diophantine equations? never knew that.
15:35:24 <SamB> well, no
15:35:49 <SamB> diophantine equations aren't too easy to solve...
15:36:00 <yitz> dynamic programming is also usually the wrong approach. it may work - but better to do some math.
15:36:09 <SamB> it depends
15:36:54 <SamB> and sometimes it may take some math to figure out how dynamic programming would help
15:37:04 <vixey> what sort of sharing could you get if you represent the collatz thing as a tree?
15:37:09 <vixey> infinite tree
15:38:21 <dmwit> Here's a great example where dynamic programming is "the right approach", I think:
15:38:24 <dmwit> http://projecteuler.net/index.php?section=problems&id=81
15:38:25 <lambdabot> Title: Problem 81 - Project Euler
15:39:34 <dmwit> Or this one, which is very similar:
15:39:37 <dmwit> http://projecteuler.net/index.php?section=problems&id=67
15:39:37 <lambdabot> Title: Problem 67 - Project Euler
15:40:16 <dmwit> vixey: How would an infinite tree work?
15:40:35 <gwern> bleh. cabalizing roguestar is annoying. why the heck did he make the final executable binary a shell script? >.<
15:44:58 <vixey> > let mcollatz n = map collatz [1..] !! (n-1) where collatz 1 = 1 ; collatz n = 1 + mcollatz (if even n then n `div` 2 else 3*n + 1) in mcollatz 3571
15:45:03 <lambdabot>  31
15:45:18 <vixey> I tried collatzT n = let l = n`div`2 ; r = 3*n+1 in (l, collatzT l) :++: (r, collatzT r)
15:45:30 <vixey> collatz n = traverse n (collatzT n) where traverse 1 _ = 1 ; traverse n (p:++:q) = 1 + (uncurry traverse) (if even n then p else q)
15:46:21 <vixey> I think it's a little bit faster than mcollatz
15:46:24 <gwern> stupid pdflatex! I also hate programs that won't exit on C-c!
15:46:35 <vixey> (also data Tree a = (a, Tree a) :++: (a, Tree a))
15:47:06 <cadabra> I tried a finite array: acollatz n = array (0, maxup) [(i, collatz i) | i <- range (0, maxup)] ! n
15:47:31 <cadabra> But it looks like the array is rebuilt on each invocation.
15:47:37 <vixey> cadabra: do you have a way to compare speeds?
15:48:04 <cadabra> Not really, I'm just going by feel at the moment
15:49:29 <vixey> is: collatzDirect 1 = 1 ; collatzDirect n = 1 + collatzDirect (if even n then n`div`2 else 3*n+1)
15:49:31 <vixey> too slow?
15:49:42 <mrd> gwern: like ghci?
15:49:47 <vixey> because mcollatz is lots slower than that
15:51:36 <cadabra> Well, I want to test collatz for n <- [0..1000000]
16:02:58 <gwern> mrd: at least ghci will interrupt the current computation on C-c, and then you can C-d
16:03:00 <gwern> but pdflatex isn't that good
16:11:15 <dmwit> > fix (\f n -> case () of _ | n == 1 -> 1 | even n -> 1 + f (n `div` 2) | otherwise -> 1 + f (3 * n + 1)) 1
16:11:18 <lambdabot>  1
16:11:20 <dmwit> > fix (\f n -> case () of _ | n == 1 -> 1 | even n -> 1 + f (n `div` 2) | otherwise -> 1 + f (3 * n + 1)) 10
16:11:22 <lambdabot>  7
16:14:18 <dmwit> cadabra: With appropriate bounds and the memoization function I linked to above, (map collatz [1..1000000]) takes about 45 seconds to warm up, then prints all the answers as fast as it can print.
16:15:40 <dons> looks like a nice problem for streams
16:16:08 <dmwit> Really?
16:16:14 <dmwit> Do streams have a lookahead?
16:16:26 <dons> i mean, collatz in general
16:16:42 <dmwit> Well, how would you do the (collatz (3 * n + 1)) branch without lookahead?
16:19:55 <SamB> hmm, is it just me, or are Agda's modules and records intimately related?
16:31:01 <jberryman> I wrote this to solve the planet euler problem of "amicable chains". and would be interested to see if anyone has anything to say about it, or ideas about memoization, etc.
16:31:04 <jberryman> http://hpaste.org/7534
16:31:32 <dmwit> Is this problem 21?
16:32:01 <dmwit> Oh no, problem 95.
16:32:45 <jberryman> right. all the code is really simple obviously, but figuring out the algorithms was really good for me
16:33:43 <Heffalump> jberryman: why not first make a table of all the "result numbers"?
16:36:14 <jberryman> Heffalump: could you elaborate on what you mean? like remember where each number "points to"?
16:39:10 <dmwit> yes
16:40:51 <Heffalump> jberryman: yeah
16:41:12 <yitz> dmwit: project euler 81 needs neither dynamic programming nor memoization. it is solved trivially by nested folds.
16:41:39 <yitz> (just did it, but in ghci)
16:41:51 <Heffalump> rename your divSum function to divSum', and add a new one that defines a map whose elems are the calls to divSum on the keys, and which just does a lookup in the map
16:41:51 <yitz> next...
16:43:00 <Heffalump> divSum = let mp = Map.fromList [(n, divSum n) | n <- [1..1000000]] in \n -> Map.findWithDefault (error (show n ++ " out of range")) mp n
16:43:10 <Heffalump> sorry, that second divSum should be divSum'
16:45:33 <jberryman> Heffalump: thank you. also it seems odd to me that about 1/3 of the running time is taken up by my isqrt calls which are just limiting the search for prime numbers
16:45:37 <yitz> dmwit #67 is also obviously a fold.
16:46:08 <yitz> any other attempts at disproving my claim?
16:46:57 <jberryman> yitz: it's basically the same problem. if I recall you just start from the bottom and sort of replace each cell with the sum of the highest possible route below it
16:47:12 <yitz> jberryman: yep
16:47:15 <jberryman> right?
16:48:04 <Heffalump> jberryman: well, they might be quite slow. But avoiding the repetition of the factorisations might speed things up quite a bit in itself.
16:48:15 <dmwit> I do not think saying that it can be solved with a fold means that you are not using dynamic programming.
16:49:08 <dmwit> Or, with less negatives: I think that many dynamic programming solutions are best expressed as folds.
16:49:11 <jberryman> yeah definitely, thanks. hae to run, but will check the logs if any more to add. thx
16:49:13 <yitz> dmwit: perhaps you can prove the algorithms equivalent, but you don't need that kind of thinking to solve the problem. it's just a fold.
16:49:40 <Heffalump> you might also want to memoise primeFactors in the same way, and change the nested recursive call to a call to the outer function, so that it uses previously computed factorisations.
16:50:15 <dmwit> yitz: You call it just a fold, I call it just an application of dynamic programming; neither of us is wrong, I think
16:50:22 <Saizan> dynamic programming is nothing fancier than divide and conquer with sharing, it's not surprising that it's well expressed as recursion :)
16:50:26 <dmwit> It's just two different names for a high-level algorithm.
16:52:26 <yitz> in general, i find that the whole idea of "memoization" as a general technique is rarely needed in Haskell. sure, sometimes you store things in a temporary data structure. but the kinds of things you generalize when you make memoization a general technique seem to be just workarounds for weaknesses in non-functional programming.
16:52:40 <yitz> mostly
16:54:57 <yitz> i think that's why people who try to use "memoization techniques" to solve project euler problems always wind up with something way more complex than what is needed.
16:55:35 <yitz> Saizan: makes sense.
17:13:33 <mmorrow> edwardk: related to your "why do these not conflict?" and the "dual instance inferred as dups" thing: http://hpaste.org/7533#a1
17:15:00 <edwardk> morrow: hrmm
17:15:57 <mmorrow> edwardk: i found this one interesting in general: http://hpaste.org/7533#a7
17:17:08 <edwardk> i've tied a couple of dictionary knots like that myself, i think the one i use for Show/Eq on (Co)Free (Co)monads is the same thing basically just with an extra type parameter
17:18:03 <mmorrow> i just checked out the category-extras code...interesting
17:18:17 <mmorrow> i plan on playing with it
17:18:34 <dmwit> edwardk: Holy!
17:19:12 <edwardk> mmorrow: i'm in the process of mangling it back towards the approach i was using in my unreleased categories library. debating about the merits of the more general Bifunctor class carrying the 3 categories explicitly
17:19:15 <edwardk> dmwit: ?
17:19:43 * dmwit is constantly humbled by the Haskell skills displayed in here
17:19:53 <edwardk> mmorrow: i've made some pretty drastic changes since the version that was released, but the current version doesn't build yet =)
17:20:18 <mmorrow> do you have a darcs repo somewhere?
17:20:49 <edwardk> i do but i haven't checked in the mangled version. (its lying unchecked in in the folder though since i work in it directly. http://comonad.com/haskell/category-extras
17:20:50 <lambdabot> Title: Index of /haskell/category-extras
17:21:27 <edwardk> i can check in the current ramblings, but they are pretty incoherent since i started going pretty far down one path before cale pointed out that i can define 'type' definitions for kinds other than *
17:21:37 <jaj> dmwit: first thing I asked when I entered here was whether you had to have a PhD in math to be allowed in ;)
17:21:50 <dmwit> heh
17:22:13 <mmorrow> cool, just darcs got
17:22:17 <edwardk> so instead of type (a :+: b) c = Lift Either a b c, i can say type (:+:) = Lift Either
17:22:25 <Saizan> it would be nice if one could get a phd by staying here :)
17:22:32 <edwardk> mmorrow: the version that darcs has recorded should be consistent
17:22:59 * edwardk still needs to get around to picking up a phd some day
17:23:43 <edwardk> mmorrow: it was the addition of the MonadIdeal stuff that made me need to rethink how I was handling instances for my functor combinators
17:24:57 <mmorrow> edwardk: i'm in the "getting the global picture of the lib in my head" stage
17:25:16 <mmorrow> edwardk: excited
17:25:39 <yitz> jaj, dmwit: that's what's nice about this channel. you don't need a math phd to participate. but those do who have one can still have fun.
17:25:52 <edwardk> mmorrow: fair enough, basically at this point, morphisms, bifunctors, comonads, comonad transformers, bikleisli arrows, some generic functor combinators for putting things together
17:26:28 <edwardk> adjunctions, monads/comonads from adjunctions, representable functors (thanks ddarius!), pretty much anything else that i can find an excuse for from category theory.
17:27:04 <mmorrow> nice, i'm of that view also
17:27:55 <mmorrow> yeah, the representable functor, kan extensions, .... interesting possibilities
17:27:59 <edwardk> and the old old way that mark jones had for composing monads with pointed functors from 93, also dualized to comonads, indexed monads (ala the supermonad in sessions), parameterized (co)monads so you can do some more principle monad foldiong
17:28:18 <jaj> we definitely need Strong Hylozygomorphism Trifunctor Transformations ;)
17:28:20 <edwardk> i have a lot more kan extension stuff to add in there. an instance for HFunctor for Lan, etc.
17:29:52 <edwardk> one thing i want to do is since i have all these bifunctor combinators, i want to also bake in the dissection/derivative stuff so i can do a comonad zipper. (since you can make a comonadic zipper just like the pointer comonad, you use it and basically each step of the transformation has a 'local' view of the stuff in the structure around it)
17:30:34 <edwardk> you don't use it like you use a current zipper library, but it can be used to let each piece of data 'look around' when it generates the next step, so for automata, etc.
17:31:02 <mmorrow> i've been thinking alot about sheaves and a nice way to embed the construction into haskell
17:31:40 <mmorrow> not sure about an approach yet though
17:32:05 <mmorrow> the passage from global to local, etc.
17:32:16 <mmorrow> (and back)
17:32:31 <yitz> @google Strong Hylozygomorphism Trifunctor Transformations
17:32:41 <lambdabot> Plugin `search' failed with: getAddrInfo: does not exist (Name or service not known)
17:33:00 <yitz> darn :)
17:33:00 <jaj> yitz: http://www.haskell.org/haskellwiki/Real_World
17:33:01 <lambdabot> Title: Real World - HaskellWiki
17:34:40 <yitz> jaj: :)
17:35:00 <edwardk> mmorrow: yeah i've been taking this kinda slow. right now i'm still trying to find an indexed comonad that is useful. nanevski's modal necessity doesn't work because we don't have an initial object and i can't figure out an encoding without one.
17:36:50 <mmorrow> yeah usefulness is paramount! as is simplicity
17:36:59 <edwardk> the other thing i ran into is i encoded the eckmann-hilton argument the other day, but it doesn't play nice with haskell typeclasses. i wind up having to box up the whole conjecture in a type
17:38:05 <edwardk> i'm willing to forgo simplicity for correctness. i previously gave up the explicit category arguments to bifunctor, but i think i'm adding them back in to avoid all the noise of 'contravariant' vs. 'covariant' arguments to functors and bifunctors
17:38:08 <mmorrow> the interaction between gadts, typeclasses, and type function is interesting
17:38:55 <edwardk> mmorrow: if you want to see type functions used more, look at http://comonad.com/haskell/categories/dist/doc/html/categories/
17:39:11 <edwardk> that uses type families to represent products, sums, exponentials, etc.
17:39:14 <mmorrow> been trying to find out how to use some/all of them in combo to do things i want
17:39:34 <mmorrow> partial success so far (mostly just more questions)
17:39:48 <edwardk> so that you can actually refer to the dual category correctly, and have its coproduct be the product of the dual category without a million parameters in all your typeclasses
17:40:02 <mmorrow> nice, i've just recently started looking in to them
17:40:30 <edwardk> the problem i ran into there was the instance heads for the 'Dual' category stuff conflicted with any practical attempt at a general purpose Dual construction
17:40:48 <edwardk> er sorry that came out wrong
17:41:03 <mmorrow> it seems this "dual dilemma" is a crux for achieving the possibility of awesomeness
17:42:04 <edwardk> what i meant was the instance heads for things like instance Bifunctor f k1 k2 k3 => Bifunctor f (Dual k1) (Dual k2) (Dual k3) where ...  conflict with instance Bifunctor k (Dual k) k k for exponentials in the category using the category morphism type itself as the type for exponentials
17:43:48 <edwardk> where Bifunctor has the longer form: class (Category k1, Category k2, Category k3) => Bifunctor f k1 k2 k3 | f k1 -> k2 k3, f k2 -> k1 k3, f k3 -> k1 k2 where ... which is necessary to  let (,) and Either work in multiple categories. (a more correct fundep would have f -> k 1 k2 k3)
17:44:51 <mmorrow> it seems like somehow a knot has to tied in the sense that morphisms in a cat with nats (of blah) are just *morphism* wrt that cat
17:45:24 <mmorrow> kinda like how the typechecker doesn't recurse into newtypes to avoid loops
17:45:39 <mmorrow> or something
17:45:55 <mmorrow> kinda a vague thought, trying to refine it
17:48:49 <mmorrow> clarifying, i meant ...morphisms in a cat with objects natural transormations....
17:49:00 <edwardk> i've been playing with ways to avoid it, one way i started from was to say that you have a simple relationship between a category and its dual, so that you have a simple class like 'Op k1 k2 | k1 -> k2, k2 -> k1', then you go from (->) to Dual (->) and back to (->), the symmetry can be enforced by using two class specifications
17:50:06 <edwardk> mmorrow: i've been bitten pretty hard by the fact that there is no way to define something as being 'polykinded', so that it can work the same over terms, functors via natural transformations, etc. Lan for instance would be very nice that way
17:50:33 <edwardk> i was half tempted to turn to template haskell to generate the various kind-levels of the same construction rather than recode
17:51:31 <mmorrow> YES! i've been going down that path in various ways
17:52:11 <edwardk> mmorrow: if you look in http://crab.rutgers.edu/~pjohann/popl08.pdf they have to keep defining additional classes to deal with subtle variations, oh this takes two of that kind of parameter, or it takes functor here and works over natural transformations instead, etc.
17:52:12 <mmorrow> wrt 'polykindedness' and turning to template-haskell
17:52:42 <edwardk> heh my answer was to start writing an 'untyped' haskell-alike where i could code up the stuff and test it. ;)
17:53:00 <edwardk> this category library grew out of my prelude ;)
17:53:16 <mmorrow> ha, that's pretty much what my attempt degenerate to as well
17:54:12 <edwardk> on the other hand i got a very nice set of toy language semantics. and i can go back to my obsession with static contract checking/ESC without types weighing me down.
17:54:28 <edwardk> whenever i can get to the point where category-extras is internally consistent anyways
17:56:34 <mmorrow> yeah, haskell provides all the tools to be able to use it to ensure that itself is consistent wrt whatever
17:57:01 <mmorrow> how exactly to do so in a practical way is challenging/interesting
17:57:32 <edwardk> yeah. though even if the rest of the library died i'm quite happy with the comonad transformer library fragment in it =)
17:58:21 <edwardk> Reader/ReaderT, Supply/SupplyT (which I have yet to merge back in), Context/ContextT are dual to reader, writer, and state
18:00:38 <mmorrow> i mean, taking kinds beyond * is no different than taking types beyond an untyped language, and haskell clearly has all the machinery to do so (esp with gadts). But, when using the typechecker to typecheck things beyond its design scope, difficulties arise
18:01:05 <edwardk> mmorrow: yeah, did you look at omega?
18:01:31 <mmorrow> no, i've seen a few passing refs to it though
18:01:53 <mmorrow> i'll check it out
18:04:18 <edwardk> the devil's advocate in me is saying that i should just take this whole thing transcode it to agda deal with the fact that everything is explicit and get on with life because there at least i know i won't run into the typeclass limitations. if everything is explicit there can be no problems like my current set of them ;)
18:04:54 <mmorrow> i've been meaning to get into agda
18:04:58 <mmorrow> maybe now's the time
18:05:10 <ddarius> edwardk: Instead you'll have problems unlike your current set.
18:05:22 <edwardk> ddarius: sure
18:07:28 <edwardk> but at least they'll be fresh problems ;)
18:07:41 <edwardk> heh and it'd be like what the 3rd library written in agda? ;)
18:08:24 <edwardk> lol. http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.Libraries my number was accurate ;)
18:08:29 <lambdabot> Title: 19 The Agda Wiki - Libraries 4b, http://tinyurl.com/5raomg
18:14:48 <saml> how easy is it to make my custom monad into transformer that can be in between mtl transformers or in the core of transformer stack?
18:15:20 <edwardk> saml: you should implement MonadTrans to get 'lift' then make instances for MonadReader/Writer/etc to lift over you for what you don't support
18:15:58 <edwardk> its not so bad, look in the haddock for the standard library and at the how the ones in the mtl  just lift the stuff over themselves that they don't do.
18:16:39 <saml> edwardk: do I have to make my monad instances for every Monad* in mtl?
18:17:28 <edwardk> saml: only the ones you want to have 'work transparently' through you. there are only 5 that you need iirc. monad{reader/writer/state/cont/error} + monadtrans for the basic lift functionality
18:17:29 <saml> hrm there aren't that many
18:17:49 <edwardk> its about 30-40 lines and they are all basically just get = lift get    put s = lift (put s)
18:18:27 <edwardk> er probably not even that much
18:18:48 <edwardk> mmorrow: installing it now ;)
18:20:18 <visof> i want to understand how can we port hugs to any system ?
18:20:23 <visof> the general idea
18:20:25 <visof> ?
18:20:44 <visof> and is very hard  task ?
18:20:51 <geezusfreeek> isn't hugs just written in C?
18:20:55 <visof> is this *
18:21:21 <visof> i think so
18:21:48 <geezusfreeek> should be about like porting any other C program, i would imagine
18:22:28 <visof> i have no experience about porting
18:22:35 <visof> so what should i read?
18:24:05 <geezusfreeek> well, you could just try compiling it first
18:24:09 <geezusfreeek> it may work as is
18:24:20 <geezusfreeek> and if it doesn't then you will just need to see about fixing any errors
18:24:29 <geezusfreeek> there's not really a general process that i know of
18:24:47 <edwardk> @hpaste
18:24:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:25:44 <edwardk> hrmm anyone have an idea what i'm doing wrong here: cabal acting strange: http://hpaste.org/7535
18:26:39 <geezusfreeek> edwardk: try ./Setup.lhs configure --user
18:26:59 <edwardk> oh and i also installed those libraries as root to make sure jic
18:27:22 <geezusfreeek> failing that, try ghc-pkg unregister readline --user and ghc-pkg unregister binary --user, and then try cabal-install again
18:27:34 <edwardk> kk
18:27:51 <cokolina> i never heard of haskell
18:28:07 <cokolina> someone give me a lil live intro :P
18:28:07 <geezusfreeek> cokolina: what you doing here then? ;)
18:28:26 <geezusfreeek> > "Hello" -- for cokolina
18:28:29 <lambdabot>  "Hello"
18:28:34 <_dml> Is anyone reasonably familiar with using the openGL bindings?
18:28:46 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
18:28:46 <geezusfreeek> _dml: i _sort of_ am
18:28:47 <lambdabot>  [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
18:28:55 <edwardk> > take 20 [1,3..]
18:28:56 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39]
18:29:11 <Cale> > nubBy (\x y -> y `mod` x /= 0) [2..]
18:29:21 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
18:29:24 <_dml> I'm seeing a lot of flicker in an animation i'm trying to get done, despite the fact that I *think* i'm doing double buffering correctly
18:29:24 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
18:29:26 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:29:40 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
18:29:41 <geezusfreeek> _dml: hpaste it
18:29:42 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:29:48 <_dml> ok, one sec
18:30:20 <Cale> > sortBy (comparing length) (words "Here's a bunch of words to be sorted by length.")
18:30:22 <lambdabot>  ["a","of","to","be","by","bunch","words","Here's","sorted","length."]
18:30:45 <Cale> > unwords . sortBy (comparing length) . words $ "Here's a bunch of words to be sorted by length."
18:30:47 <lambdabot>  "a of to be by bunch words Here's sorted length."
18:31:15 <geezusfreeek> cokolina: overwhelmed yet? :P
18:31:25 * edwardk sometimes wonders if Cale just has a script programmed to spew this stuff out to the channel in 3 second increments when someone new shows up.
18:31:31 <Cale> edwardk: heh
18:32:03 <hexpuem> is there a clearer way to do this:  maybe (return ()) (\f -> f) =<< readIORef x
18:32:10 <_dml> geezusfreeek: http://hpaste.org/7536
18:32:24 <allbery_b> \f -> f is id
18:32:43 <bd_> :t maybe (return ()) (\f -> f) =<< readIORef x
18:32:45 <lambdabot> Not in scope: `readIORef'
18:32:54 <edwardk> @src mzero IO
18:32:55 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:33:02 <allbery_b> but what monad are you lifting the Maybe into
18:33:03 <allbery_b> ?
18:33:07 <allbery_b> IO?  []?
18:33:13 <bd_> edwardk: well, (\f -> f) is id
18:33:16 <hexpuem> IO yea
18:33:22 <edwardk> bd: yeah
18:33:31 <bd_> edwardk: so at a zeroth-order improvement: maybe (return ()) id =<< readIORef x
18:33:46 <edwardk> bd: i think you mean hexpuem ;)
18:34:00 <bd_> err
18:34:02 <bd_> right XD
18:34:04 <bd_> sorry
18:34:06 <_dml> geezusfreeek: any thoughts?
18:34:13 <geezusfreeek> _dml: looking
18:35:27 <geezusfreeek> _dml: the only thing i can tell right off the bat that i'm not used to seeing is a lack of whatever the haskell equivalent of glFlush or glFinish is before swapBuffers
18:35:51 <geezusfreeek> _dml: i'm not sure if that is the problem though
18:35:52 <Zao> geezusfreeek: Swapping buffers is generally considered implicitly flushing.
18:36:16 <_dml> geezusfreeek: let me give that a shot real quick
18:36:18 <geezusfreeek> Zao: i have had problems before even with double buffering due to not flushing
18:36:27 <Zao> Explicit glushes are considered unhealthy anyway nowadays, since they tend to cause stalls.
18:36:28 <_dml> zao: I'd heard that too but it's worth a try :)
18:36:31 <geezusfreeek> Zao: but you're right, it _shouldn't_ be a problem
18:37:18 <geezusfreeek> _dml: i'm really not seeing the problem there, sorry
18:37:54 <_dml> geezusfreeek: thanks for looking, nonetheless
18:38:15 <Cale> cokolina: anyway, play around with the language, and if you have any questions, feel free to ask here :)
18:38:21 <_dml> is it possible that render function is taking too long and i'm missing the vertical refresh?
18:38:42 <geezusfreeek> _dml: that's kind of something double buffering is good for :)
18:39:25 <Zao> That'd just decimate your frame rate, provided you have proper vsync.
18:39:38 <Cale> > let qsort [] = []; qsort (x:xs) = qsort less ++ [x] ++ qsort greater where (less, greater) = partition (<x) xs in qsort (words "this is a list of words to sort")
18:39:39 <lambdabot>  ["a","is","list","of","sort","this","to","words"]
18:39:43 <Zao> If your vsync is forcibly disabled, you're hosed no matter how much you buffer.
18:40:20 <_dml> I can't imagine vsync the problem, i've gotten some animations running smoothly on this system
18:40:23 <ddarius> maybe x id = fromMaybe x
18:43:01 <geezusfreeek> @src fromMaybe
18:43:01 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
18:44:58 <ddarius> @src maybe
18:44:58 <lambdabot> maybe n _ Nothing  = n
18:44:58 <lambdabot> maybe _ f (Just x) = f x
18:45:07 <ddarius> Now simply set f to id.
19:15:38 <jfredett> whereabouts is the quickcheck v2 package located? (it's not on hackage).
19:17:39 <dons> code.haskell.org/QuickCheck iirc
19:18:28 <jfredett> excellent, thanks
20:08:27 * shapr boings cheerfully
20:11:12 * edwardk tries to hold shapr down.
20:11:23 <shapr> edwardk: I got my Arduino!
20:11:29 <edwardk> nice
20:12:02 * edwardk is thinking about gutting agda's parser for use in a rebuilding kata
20:12:27 <edwardk> i like the nifty precedence parser that handles various fixities, etc.
20:12:30 <SamB> edwardk: perhaps you would like to wait until they stop changing it quite so much?
20:12:50 <edwardk> samb: meh, i just am looking for a fragment of code to start from for something completely unrelated to agda =)
20:13:11 <edwardk> this is a nice branching point. and i might be able to leverage some of their module stuff for my purposes.
20:13:27 <edwardk> the nice part is in my case i can just kinda chuck the type system, and any annotations in that directions and go ;)
20:14:00 <SamB> ... will there be anything LEFT?
20:14:06 * SamB teases
20:14:34 <edwardk> samb: heh, syntax and some module namespace management, and precedence management in the parser
20:15:05 <SamB> (the implication being that Agda consists entirely of type system ;-)
20:15:15 <edwardk> samb: kinda figured
20:15:26 * SamB thought someone else might not get it
20:15:27 <edwardk> which is why i find it more ironic to rip out ITS type system than that of GHC =)
20:16:14 <SamB> I'm implying that the reduction rules are also nothing but part of the type system
20:16:50 <edwardk> i don't want any of their actual evaluation engine =)
20:16:51 <sethk> SamB, you're implying that _everything_ is part of the type system  :)
20:18:33 <SamB_XP> sethk: well, at least that I couldn't think of anything off hand that was not
20:19:22 <sethk> SamB_XP, is the type system part of itself?
20:19:32 <SamB_XP> sethk: trivially!
20:20:47 <edwardk> samb: =)
20:21:54 <SamB_XP> at least, if we use a definition of "part of" like the one used in the type derivitives paper...
20:23:15 <SamB_XP> (I have yet to figure out what that judgement is used FOR)
20:26:16 <edwardk> samb: which paper?
20:26:21 <edwardk> the clowns/jokers one?
20:26:43 <SamB_XP> @go the derivative of a type is it's type of one-hole contexts
20:26:44 <lambdabot> http://citeseer.ist.psu.edu/472190.html
20:26:44 <lambdabot> Title: The Derivative of a Regular Type is its Type of One-Hole Contexts (Extended Abst ...
20:27:16 <SamB_XP> clowns and jokers?
20:27:57 <edwardk> @go clowns to the left of me jokers to the right (pearl)
20:27:58 <lambdabot> http://strictlypositive.org/CJ.pdf
20:34:01 <edwardk> @type foldr
20:34:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:35:28 <pizza_> @type foldl
20:35:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:42:19 <_dml> is there a concise way to apply a function to all elements of a 4-tuple?
20:42:56 <hexpuem> is it worth converting something like this to an &&& arrow: http://hpaste.org/7537
20:44:37 <SamB_XP> let app4tup f (a,b,c,d) = (f a, f b, f c, f d) in ...
20:46:25 <_dml> samB: yeah, i was hoping to avoid writing that out, seems like something that should be pre-defined somewhere
20:59:48 <dancor> @pl \ x y -> f y z x
20:59:49 <lambdabot> flip (flip f z)
21:03:06 <dancor> > foldlM return "yay" []
21:03:11 <lambdabot>   Not in scope: `foldlM'
21:03:21 <dancor> > Data.Foldable.foldlM return "yay" []
21:03:25 <lambdabot>  ["yay"]
21:03:58 <dancor> > (Data.Foldable.foldlM return "yay" []) :: Maybe String
21:04:00 <lambdabot>  Couldn't match expected type `String'
21:04:13 <dancor> wat
21:04:17 <dancor> > (Data.Foldable.foldlM return "yay" []) :: Maybe [Char]
21:04:18 <lambdabot>  Couldn't match expected type `[Char]'
21:05:21 <dancor> oh return doesn't take two params
21:05:31 <dancor> > (Data.Foldable.foldlM (const return) "yay" []) :: Maybe [Char]
21:05:35 <lambdabot>  Just "yay"
21:05:41 <dancor> > (Data.Foldable.foldlM (const return) "yay" [])
21:05:43 <lambdabot>   add an instance declaration for (Show (m [Char]))
21:06:43 <dancor> > (Data.Foldable.foldlM (\ s b -> return (s ++ "woo")) "yay" []) :: Maybe String
21:06:44 <lambdabot>  Just "yay"
21:06:50 <dancor> > (Data.Foldable.foldlM (\ s b -> return (s ++ "woo")) "yay" ["a", "b"]) :: Maybe String
21:06:55 <lambdabot>  Just "yaywoowoo"
21:22:02 <gwern> I wonder why the adga folk have never put anything up on hackage?
21:22:03 <gwern> seems pretty well cabalized
21:25:01 <ddarius> cabal install agda2
21:26:06 <rhz> anyone ever thought it would be nice to have a GHCi feature that derived types from the Show class without requiring modification of the source code?
21:26:47 <gwern> ddarius: dunno about you, but my cabal install knows of no agda
21:26:52 <pantsd> I'm getting an error when I try and run haddock (parse error in doc string: [TokPara]) is there a good online guide for resolving haddock errors?
21:29:55 <gwern> pantsd: don't think so, but if you don't have any luck, could always email waern
21:30:07 <gwern> rhz: sounds difficult
21:30:23 <pantsd> gwern: cool, thanks. I'll poke around with it some more before I do that :)
21:31:09 <sethk> rhz, sure it would be nice.  But, as gwern said ...
21:31:18 <gwern> rhz: how would that work for compiled code, for example? I'm not sure GHC leaves enough type info in the binaries...
21:31:40 <gwern> and if you have source, nothing wrong with editing?
21:31:49 <rhz> Unless it's a lot of editing
21:32:32 <ddarius> It's one or two tokens per data type.  You'd have to have a lot of data types.
21:33:09 <gwern> I suppose in a way it's too bad you can't write in Haskell 'derive as many instances of this as you can'
21:33:59 <sethk> gwern, it would be just as good to have it derive the type at the point where it tells you that you need to derive it
21:34:31 <gwern> sethk: are you suggesting lazy derivations? :)
21:34:46 <sethk> gwern, sure, that's a good way to put it.
21:35:14 <sethk> gwern, seems more manageable than "derive as many instances as you can"
21:35:38 <sethk> gwern, especially as, in the future, it might be possible to derive instances for types that don't exist at the "as many as you can" point
21:36:51 <sethk> gwern, of course perhaps both alternatives are completely unmanageable
21:36:59 <gwern> sethk: well, what you can and can't derive seems kind of sticky right now. as I understand it, there's at least three widening sets of what you can do: what GHC can derive, what GHC can derive if you add some deriving extension, and what drift can derive (and there are probably other auto-derivation tools)
21:37:22 <gwern> sethk: yup, we'll never know until someone finds out. sounds like a good phd thesis, maybe
21:38:23 <sethk> gwern, it would be worth investigating.  Even if the general case is impractical, useful additional derivations might be discovered
21:40:28 <gwern> http://hackage.haskell.org/trac/hackage/ticket/278 <-- fixed, yay
21:40:29 <lambdabot> Title: #278 (Default to non-versioned links in Hackage index) - Hackage - Trac
21:43:24 <mudge> hello
21:43:35 <mudge> does anyone recommend any discrete math books?
21:43:49 <sethk> mudge, mostly for insomnia
21:44:39 <edwardk> i'd just like to be able to say 'deriving (*)' for a newtype, i realize it probably yields inconsistencies somehow
21:45:23 <sethk> edwardk, yes, but an implementation that turns that into "derive what's possible" might work
21:45:53 <edwardk> sethk: yeah
21:45:55 <mudge> sethk, which ones?
21:46:19 <edwardk> mudge: what is your major emphasis?
21:46:22 <sethk> mudge, there's one by Knuth et. al. that I like.  I don't have the details here, though.
21:46:22 <mudge> i wonder what the best books on discrete math   that would be good to understand programming and algorithms better
21:46:39 <mudge> and compiler design,  and language grammers better
21:47:44 <dmwit> edwardk: While we're at the wishing game, I wish we could provide functions to translate between a and b, then be allowed to send instances across the a <-> b barrier for free.
21:48:07 <gwern> TAOCP doesn't cover compiler design and language grammars yet, I don't think
21:48:48 <sethk> gwern, mudge, In general the grammar and compiler pieces don't belong in a text on discrete math in general.
21:49:17 <sethk> in fact, grammars and such are really a different kind of thing (using kind intentionally)
21:49:25 <mudge> but grammers have to do with sets,  and grammers work with set theory
21:49:30 <mudge> and set theory is part of discrete math
21:49:52 <edwardk> mudge: well, re algorithms the slightly diminutively named Introduction to Algorithms http://mitpress.mit.edu/algorithms/ covers the algorithms side. i used to recommend Sedgewick's algorithms, if you want something more functional Chris Okasaki's functional data structures is good. but for real discrete math, hrm. MIT press has a couple volumes of http://www.amazon.com/Handbook-Theoretical-Computer-Science-Vol/dp/0262720140 which make for a
21:49:52 <lambdabot> Title: Introduction to Algorithms, Second Edition
21:49:58 <mudge> oh yea,  knuth has a book along with some other authors,   Concrete math
21:50:16 <sethk> mudge, yes, I like that one
21:50:25 <bos> for them as has time to review book chapters, here's a guide to where your attention will be most helpful: http://www.realworldhaskell.org/blog/2008/05/10/comment-coverage-and-how-to-help-us-most/
21:50:25 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
21:50:26 <lambdabot> Title: Real World Haskell  Blog Archive  Comment coverage, and how to help us most, http://tinyurl.com/5h5ng6
21:50:36 <mudge> sethk:  thanks very much for the info and recommendations
21:50:38 <ddarius> "set theory is part of discrete math"
21:51:01 <sethk> hmm., well, set theory is much more general, isn't it?
21:51:16 <gwern> one thing I've always wondered about compilers - is there any optimal compiler design, that is, can always produce optimal binaries (even if it's with uselessly large constant factors or ridiculous big-os)? I keep trying to think how it might be balked by halting problems, but then again, compilers don't compile all inputs
21:51:19 <bos> oops.
21:51:23 <edwardk> ddarius: as taught in intro discrete math courses anyways. =)
21:51:26 <bos> @seen dons
21:51:26 <lambdabot> dons is in #haskell-hac4, #xmonad, #haskell-soc, #ghc and #haskell. I last heard dons speak 2h 18m 34s ago.
21:52:10 <sethk> gwern, I don't think there's an answer to that question that applies to all types of languages.
21:52:19 <edwardk> gwern: you run into kolmogorov complexity arguments there, which basically will say no, because its ill posed.
21:52:46 <mudge> bos: i heard that your talk recently with the FP group went really well
21:53:02 <mudge> i wish I had been there
21:53:05 <bos> it did, apart from one silly mistake :-)
21:53:17 <gwern> edwardk: hm, I can't really see how kolmogorov would apply
21:53:20 <ddarius> Moral of the story, don't make silly mistakes.
21:53:49 <sethk> or, at least, don't _admit_ to making silly mistakes  :)
21:53:56 <edwardk> er i meant to say -style there
21:55:10 <ddarius> gwern: No, there isn't.
21:56:24 * gwern supposes the problem is in defining 'optimal binary' - measuring space/time efficiency of all possible compilation targets does seem likely to fall prey to rice's theorem
21:57:14 <ddarius> gwern: Just consider strictness analysis for example.
21:58:11 <gwern> hm. I want to say that you could fix that by replacing 'optimal' by shortest - but I can't figure out how you could generate the binary. enumerating all programs from shortest to longest and testing them on inputs obviously won't work,,,
22:09:19 <mm_freak> i don't understand the State monad, and i can't find a good documentation for it =/
22:09:53 <shachaf> mm_freak: Try threading the state yourself.
22:10:09 <shachaf> mm_freak: And then reimplementing the State monad from that.
22:12:08 <mm_freak> already done that, and i think, i've got the missing part  the (>>=) function does the magic
22:13:43 <mm_freak> it's the concept of passing transition functions instead of actual values, which seems to be over my head today, but maybe i should just go to sleep
22:14:42 <edwardk> gwern: the thing is - the smallest representation _is_ a kolmogorov complexity problem. =)
22:24:28 <mm_freak> http://www.haskell.org/all_about_monads/html/statemonad.html  in the example at the bottom, in the getAny function, why does the author use ((x,g') <- return $ random g) instead of (let (x,g') = random g) ?
22:24:29 <lambdabot> Title: The State monad
22:24:51 <mm_freak> just style or a technical reason?
22:25:07 <edwardk> mm_freak: style
22:25:10 <dmwit> No, those two statements are equivalent.
22:25:28 <dmwit> (The let-form is translated into the (<-) form, I think.)
22:25:31 <edwardk> most likely they didn't think about it and just wrote the line monadically
22:25:39 <mm_freak> ok, thanks
22:26:09 <dmwit> Have you seen sigfpe's You Could Have Invented Them Yourself thing?
22:26:10 <edwardk> dmwit: the let style shouldn't have to be should it? it can be a real let binding at that location, no need to invoke bind
22:26:40 <ddarius> dmwit: let is translated to let
22:26:51 <ddarius> @undo do let x = y; return x
22:26:51 <lambdabot>  Parse error at end of input
22:26:57 <edwardk> @undo do x <- foo; let {bar = baz x}; quux
22:26:58 <lambdabot> foo >>= \ x -> let { bar = baz x} in quux
22:27:02 <mm_freak> dmwit: i've read it, but IIRC i skipped the State monad part, because somehow it was a bit over my head that time
22:27:29 <mm_freak> it's not too difficult to comprehend _how_ it works  my big problem is _why_ it works
22:27:34 <dmwit> ddarius, edwardk: Okay, sorry.
22:27:35 <ddarius> Also, though it's not an issue in this case, the scoping is different for a let as opposed to the x <- return y pattern
22:27:50 <edwardk> dmwit: np
22:30:18 <edwardk> to clarify ddarius' point let (x,g) = randomR (bounds g)   -- would bind the g recursively but (x,g) <- return $ randomR (bounds g) does not
22:30:26 <mm_freak> i'd think that there is an efficiency risk with the monadic version, since the compiler may not be smart enough to optimize it away
22:30:35 <edwardk> that too
22:32:17 <mm_freak> would it make sense to implement state through an arrow?  i'd think, yes
22:32:30 <dmwit> All monads are also arrows.
22:32:44 <dmwit> ?hoogle kleisli
22:32:44 <lambdabot> Control.Arrow.Kleisli :: newtype Kleisli m a b
22:32:44 <lambdabot> Control.Arrow.Kleisli :: (a -> m b) -> Kleisli m a b
22:32:44 <lambdabot> Control.Arrow.runKleisli :: Kleisli m a b -> a -> m b
22:32:52 <edwardk> mm_freak: sure there are a couple of encodings for arrowstate
22:33:03 <mm_freak> dmwit: i'm asking whether it would make sense, not whether it would work
22:33:10 <dmwit> Okay. =)
22:33:42 <edwardk> you can use the kleisli version fo the state monad or the more 'arrow-like' tupling of it with the state itself, data StateArrowT k a b = StateArrow (k (a,s) (b,s) )
22:34:06 <edwardk> er StateArrowT s k a b
22:34:52 <mm_freak> i guess, it wouldn't make _using_ state any easier, but it would make comprehending its implementation easier, doesn't it?
22:35:05 <edwardk> mm_freak arrows?
22:35:08 <mm_freak> yes
22:36:08 <edwardk> mm_freak: arrows make it easier to compose 'almost-linear' pipelines of operations, like pointfree code. the problem with them in general is just like pointfree code your code tends to be very 'brittle' and small changes require large changes to the plumbing of arguments because you can't see the 'points' the arrow sugar helps somewhat though
22:37:50 <edwardk> mm_freak: state arrows are a lot more straightforward i think to explain to someone than monadic state, because (a,s) -> (b,s)  is simpler looking than than a -> (s -> (b,s)) but they are just the same thing with currying differences
22:38:53 <mm_freak> edwardk: well, that seems to depend on how you view arrows  it helped me a lot to view them as computers for most purposes, but i haven't implemented one myself yet  maybe implementing a state arrow would be an interesting exercise for both comprehending state and arrows
22:39:34 <edwardk> since the kleisli newtype and the state monad newtype get erased by the compiler anyways and ghc effectively retuples its arguments back up to make calls anyways, you shouldn't see any operational difference between the two other than minor quirks
22:40:55 <mm_freak> well, i'm coming from the C world, so i like readable code
22:41:12 <mm_freak> for that reason, for example i'm not an advocate of point-free style
22:41:12 <lament> nice logic!
22:41:22 <mm_freak> sometimes it makes sense, but mostly it doesn't
22:41:46 <edwardk> if you want a fun one i like the cokleisli arrow for the reader comonad, the reader monad is (e -> b) right? so a -> (e -> b) is a kleisli arrow for that monad, otoh the 'reader comonad is (e,a) so a cokleisli arrow for that comonad looks like (e,a) -> b -- this is why category theory types like to have the product put on the other side so that currying/uncurrying between the two naturally makes one into the other
22:42:27 <edwardk> lament: re the state stuff?
22:43:25 <lament> re readable code
22:43:59 <edwardk> i use pointfree style whenever i can use it to gain insight. i.e. when i'm doing category theory stuff its great, the functions are arrows in the diagram i am chasing and its easy to run 'pointfree code backwards' to figure out the dual,.
22:44:19 <edwardk> but i don't believe it is a great general purpose programming tool when taken to extremes
22:44:44 <mm_freak> yeah, but i often see people overuse it
22:45:21 <edwardk> same with arrows, the above arrow like examples give you a common setting to view monadic, comonadic and reader arrows and see that they are just different ways of saying the exact same operations
22:45:36 <mm_freak> particularly with folding, it often results in messy code, just to prevent lambda notation
22:45:43 <edwardk> er monadic, comonadic, and arrow reader implementations
22:46:31 <mm_freak> @src reverse
22:46:31 <lambdabot> reverse = foldl (flip (:)) []
22:46:44 <edwardk> touche
22:47:30 <mm_freak> ok, that's still tolerable =)
22:48:48 <mm_freak> but i've seen simple list functions implemented using folds with lifting, flipping and consing, which was totally crazy
22:49:39 <dmwit> In general, more names for intermediate functions helps a lot.
22:50:05 <edwardk> mm_freak: i understand, g_bihylo w m f e g = extract . h . return where h = liftW f . w . e . bimap id (duplicate . h . join) . m . liftM g -- starts to look a little ugly after a while =)
22:50:28 <edwardk> though that one is at least entirely linear modulo its recursion bit
22:51:25 <mm_freak> hehe
22:52:03 <mm_freak> but i guess that writing that one with points would be even worse (parentheses)
22:52:26 <edwardk> but without point-free, its very hard to see that g_cata k g = extract . c where c = liftW g . k . fmap (duplicate . c) . outF -- and, g_ana k g = a . return where a = InF . fmap (a . join) . k . liftM g are doing the exact same things just with the arrows going in the opposite direction
22:53:06 <edwardk> whereas with it, the pointfree notation allows you to read one off of the other by just reading backwards
22:53:35 <slava> what's intersesting about g_cata and g_bihylo?
22:54:03 <mm_freak> btw  does the compiler actually optimize the state transition into destructive updates, or do i need ST for that?
22:54:41 <edwardk> slava: well, g_cata and g_ana are just generalized catamorphisms and anamorphisms, basically you can use them to recover more powerful recursion schemes than a base catamorphism while still having fusion rules for them, etc.
22:54:54 <slava> what advantage do they provide over explicit recursion?
22:54:58 <edwardk> g_cata and g_ana were the ones i wanted to compare there
22:55:05 <edwardk> slava: fusion laws
22:55:11 <slava> oh ok
22:55:31 <slava> is it harder for a compiler to recognize recursive idioms than is it to recognize g_*?
22:55:47 <mxc_> @hoogle normal
22:55:47 <lambdabot> Distribution.Verbosity.normal :: Verbosity
22:55:47 <lambdabot> System.Time.normalizeTimeDiff :: TimeDiff -> TimeDiff
22:55:47 <lambdabot> System.FilePath.Windows.normalise :: FilePath -> FilePath
22:57:40 <edwardk> slava: there are nice ways you can stick these things together and fuse loops. another reason to think about these is they can give you a different set of tools to bring to bear on studying a problem. just like curry-howard lets you use logic to think about what types have meaningful terms in them
22:58:18 <slava> ok
22:58:30 <slava> so i guess you have explicit rewrite rules for these?
22:58:33 <edwardk> slava: that said i'm not going to say they are a panacea, they have issues, they can be hard for the compiler to recognize in their own right, shortcut fusion or stream fusion tends to be cheaper and easier to spot forthe compiler, etc.
22:58:36 <slava> and the compile doesn't infer fusion properties on its own?
22:58:41 <slava> ok
22:59:10 <edwardk> slava: well, there was some work on that in the late 90s by some japanese spin-offs of erik meijer iirc
22:59:34 <edwardk> @go A Calculational Fusion System HYLO
22:59:35 <lambdabot> http://citeseer.ist.psu.edu/41091.html
22:59:35 <lambdabot> Title: A Calculational Fusion System HYLO - Onoue, Hu, Iwasaki, Takeichi (ResearchIndex ...
23:01:00 <edwardk> slava: but yes, i cheat and drop in RULE pragmas for them
23:01:25 <slava> ok
23:01:52 <edwardk> though for the most part they turn into nested fmaps/bimaps which have simpler fusion rules already
23:02:09 <edwardk> er neighboring nested maps
23:09:54 <dancor> @pl \ xss -> fmap concat (sequence (map monadicF xss))
23:09:55 <lambdabot> fmap join . sequence . map monadicF
23:10:34 <dancor> @type fmap concat (sequence (map return [[4]]))
23:10:38 <lambdabot> forall a (f :: * -> *). (Functor f, Num a, Monad f) => f [a]
23:11:00 <dancor> @type fmap join . sequence . map return
23:11:02 <lambdabot> forall a (m :: * -> *). (Monad m, Functor m) => [[a]] -> m [a]
23:21:11 <dolio> @type fmap join . Data.Traversable.sequence . fmap return
23:21:13 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Data.Traversable.Traversable f, Functor m, Monad f) => f (f a) -> m (f a)
