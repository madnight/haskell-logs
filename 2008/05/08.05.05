00:01:55 <mxc2> hm, how does one define a word8 constant?
00:01:55 <mxc2> getting the following error:
00:02:10 <mxc2>   Couldn't match expected type `GHC.Word.Word8'
00:02:10 <glguy> > 8 :: Word8
00:02:11 <mxc2>          against inferred type `Char'
00:02:11 <mxc2>   In the first argument of `split', namely '|'
00:02:11 <mxc2>   In the expression: split '|' header
00:02:11 <mxc2>   In the definition of `cleanHdr': cleanHdr = split '|' header
00:02:14 <lambdabot>  8
00:02:42 <mauke> mxc2: where is split from?
00:03:13 <mxc2> let ls = split '|' header
00:03:38 <glguy> > ord '|'
00:03:40 <lambdabot>  124
00:04:05 <glguy> mxc2: I'm not sure what you are doing, but Char in Haskell is a unicode code-point
00:04:12 <glguy> and not an 8bit value like in C
00:04:39 <glguy> mxc2: are you trying to use a bytestring?
00:04:50 <mxc2> yes
00:04:52 <mxc2> http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#v%3Asplit
00:04:54 <lambdabot> http://tinyurl.com/39be59
00:05:03 <mauke> mxc2: see Data.ByteString.Char8
00:08:27 <mxc2> ah
00:08:34 <mxc2> thanks mauke
00:08:46 <mxc2> i love how accepting of newbie questions this community is
00:21:22 <lament> the first one is always free
00:33:20 <dmwit> Haskell is a drug now?
00:33:59 <dmwit> Well... getting help with Haskell is a drug, now? =P
00:34:35 <mxc2> @src lines
00:34:35 <lambdabot> Source not found. Maybe if you used more than just two fingers...
00:34:43 <mxc2> @src Data.List.lines
00:34:43 <lambdabot> Source not found. Just try something else.
00:35:00 <dmwit> ?source Prelude
00:35:01 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
00:35:43 <visof_>  perfects a = [b| b <- [1..a], b == sum (factors b)] is this right for perfect numbers ?
00:35:54 <visof_> factors x = [n|n <- [1..x] , x `mod` n == 0]
00:36:01 <dmwit> Not quite.
00:36:10 <visof_> okay
00:36:10 <dmwit> That includes the biggest factor.
00:36:20 <visof_> what do you mean?
00:36:22 <GrayShade> try x `div` 2
00:36:43 <dmwit> visof_: You have (factors 6 = [1, 2, 3, 6]).
00:37:02 <dmwit> visof_: But then (sum [1, 2, 3, 6] === 12 /== 6).
00:37:14 <visof_> ah
00:37:22 <visof_> thanks
00:37:32 <dmwit> visof_: So yes, either use [1..x `div` 2] in factors, or use (2 * b == sum ...) in perfects.
00:37:56 <dmwit> ?source GHC.Base
00:37:57 <lambdabot> GHC.Base not available
00:37:58 <GrayShade> is that for project euler?
00:38:08 <visof_> no
00:38:23 <dmwit> Huh, I would have guessed PE, too. =P
00:38:36 <visof_> i try to solve graham hutton exercise
00:38:51 <visof_> chapter 5
00:39:55 <mxc2> is there a compelling reason to use bytestrings instead of the Prelude Strings?
00:40:09 <mxc2> ([Char] strings that is)
00:40:19 <mxc2> aside from much more support functions
00:40:23 <glguy> speed and memory usage
00:40:55 <earthy> speed, mostly though
00:41:06 <earthy> memory usage factors into speed
00:44:45 <mxc2> another newbie question, how can you create a bytestring constant in ghci?
00:45:18 <dmwit> let x = pack "hey"
00:45:46 <dmwit> Though I've never used bytestrings, so it might be "unpack" or something like that.
00:45:47 <thoughtpolice> mxc2: use the 'pack' function from Data.ByteString.Char8
00:47:37 <thoughtpolice> if you have bytestring > v0.9.0.4 and ghc 6.8 you can use a nice extension and just do 'let x = "hi" :: ByteString'
00:47:47 <thoughtpolice> (the extension being -XOverloadedStrings)
00:51:45 <visof_> dmwit factors x = [n|n <- [1..(x-1)] , x `mod` n == 0]
00:51:47 <visof_> ?
00:52:01 <dmwit> visof_: That's fine.
00:52:08 <visof_> dmwit okay
00:52:33 <visof_> dmwit are you mathematician?
00:52:47 <dmwit> Well... I'm a math minor. =)
01:17:45 <mxc2> @hoogle readDouble
01:17:46 <lambdabot> No matches found
01:17:49 <mxc2> @hoogle readFloat
01:17:49 <lambdabot> Numeric.readFloat :: RealFrac a => ReadS a
01:22:55 <snhmib> uhm what's the syntax for having type guards (?) for a function
01:23:12 <snhmib> i have an ugly helper function that looks like this:
01:23:30 <snhmib> gvIter :: GVThingie a, GVThingie b, GVThingie c => a -> (a -> GV b) -> (a -> b -> GV b) -> (b -> d) -> GV [d]
01:23:51 <snhmib> but ghc says parse error on input `,'
01:24:08 <dolio> Put the list of contexts in parentheses.
01:24:10 <int-e> you need parentheses around the context, (GVThingie a, GVThingie b, GVThingie c)
01:24:24 <snhmib> cool thanks
01:25:42 <snhmib> oh i forgot i threw out the c :S
01:29:03 <GrayShade> how can i define something like class Wrap f where unwrap :: f a -> a ?
01:29:27 <mauke> like that
01:29:54 <GrayShade> but it doesn't work for any type
01:30:08 <GrayShade> data N = N Integer; instance Wrap N where unwrap (N a) = a
01:31:58 <mauke> that's a kind error
01:32:04 <mauke> f must be a type constructor
01:32:45 <thoughtpolice> in your class definition, the type which is an instance of the class must have kind * -> *, i.e. it must be applied to another type. the datatype N only has kind * since it is applied to no datatype
01:32:46 <GrayShade> of course, i can write unwrap :: f -> a and it will work for N
01:33:01 <thoughtpolice> you would want something like data N a = N a, so that N as a datatype has the appropriate kind
01:33:32 <GrayShade> so there's no way to write a Wrap class that works for any type?
01:33:57 <ski> what would it do ?
01:34:01 <thoughtpolice> the class you have works fine, the data you want to make an instance of it has the err (wrong kind)
01:34:01 <mauke> class Wrap a b where unwrap :: a -> b
01:34:11 <mauke> of course that's probably not useful
01:35:29 <thoughtpolice> GrayShade: from the class definition, unwrap must take some time f a and return an a. for example, given a type 'Maybe Int' you would return 'Int'
01:35:46 <thoughtpolice> the problem is that N as a type is just that: N. it isn't parametrised over any other type
01:35:51 <thoughtpolice> so the declaration makes no sense
01:35:57 <GrayShade> but if i want to unwrap a type with any number of parameters?
01:36:16 <GrayShade> so it would work for both data M a = M a and data N = N Integer
01:36:20 <GrayShade> or any other type?
01:36:30 <thoughtpolice> but for example, having 'data N a = N a' would work
01:36:54 <mauke> GrayShade: how would that be useful?
01:37:05 <thoughtpolice> GrayShade: the instance of the class would have to have a kind of * -> *
01:37:14 <thoughtpolice> anything with just kind * couldn't work because it wouldn't make sense
01:38:40 <Vq^> GrayShade: in the type of unwrap, how could f be replaced by N in a sensible way?
01:38:55 <thoughtpolice> if you line up the type variables in the signature 'f a -> a' you can see M would work because you can unify f with M and a with anything you want so unwrap in the instance of M would have a type of 'M a -> a'
01:39:03 <GrayShade> Vq^: it wouldn't
01:39:48 <Vq^> GrayShade: but thats what you're trying/want to do, isn't it?
01:39:58 <GrayShade> i understand it doesn't work, but i was wondering if it was possible to do something like that
01:40:18 <thoughtpolice> but in the case of the N type, it makes no sense: as N as a type takes no other types (kind *), you cannot unify N with f, because, well, the type variable 'f' has kind * -> *
01:40:40 <mauke> GrayShade: did you see my suggestion?
01:41:48 <GrayShade> mauke: that would work for my N, but not for data M a = M a
01:41:54 <GrayShade> i think
01:42:20 <mauke> instance Wrap (M a) a where ...
01:42:23 <thoughtpolice> why? instance Wrap (M a) a where ..
01:42:40 <GrayShade> oh
01:43:25 <Vq^> type N = M Integer; N = M
01:46:25 <GrayShade> like this? http://hpaste.org/7406
01:46:51 <mauke> yes
01:47:17 <mauke> now you've run into the problem that unwrap x is ambiguous
01:48:54 <mauke> http://hpaste.org/7406#a1
01:49:32 <GrayShade> oh.. :)
01:50:41 <GrayShade> judging from the number of extensions it needs (to do almost nothing), i'd guess it's not such a good idea to use that
02:01:19 <Beelsebob> > splitFileName "file/doom/jam.txt"
02:01:20 <lambdabot>   Not in scope: `splitFileName'
02:07:28 <slava> @src sequence
02:07:28 <lambdabot> sequence []     = return []
02:07:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:07:28 <lambdabot> --OR
02:07:28 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:07:57 <glguy> thinking about putting some of the monad combinators in Factor?
02:08:05 <slava> yeah
02:10:04 <slava> @src mapM_
02:10:05 <lambdabot> mapM_ f as = sequence_ (map f as)
02:10:08 <slava> hmm
02:10:10 <slava> @src sequence_
02:10:10 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
02:10:11 <skorpan> haskell is so awesome.
02:15:54 <Beelsebob> @hoogle FilePath -> FilePath
02:15:54 <lambdabot> System.FilePath.Windows.dropExtension :: FilePath -> FilePath
02:15:54 <lambdabot> System.FilePath.Windows.dropExtensions :: FilePath -> FilePath
02:15:54 <lambdabot> System.FilePath.Windows.takeDrive :: FilePath -> FilePath
02:16:00 <mxc2> @hoogle fromJust
02:16:00 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
02:16:21 <Beelsebob> @hoogle FilePath -> IO FilePath
02:16:21 <lambdabot> System.Directory.canonicalizePath :: FilePath -> IO FilePath
02:16:21 <lambdabot> System.Directory.makeRelativeToCurrentDirectory :: FilePath -> IO FilePath
02:16:21 <lambdabot> Distribution.Simple.Utils.findPackageDesc :: Verbosity -> FilePath -> IO FilePath
02:17:03 <Beelsebob> hmm, is there a version of canonicalizePath given a specific pwd?
02:17:35 <dmwit> mxc2: That should be called unsafePerformMaybe. =)
02:17:43 <mauke> a specific print working directory :(
02:17:55 <Beelsebob> present working directory
02:18:13 <mxc2> dmwit i know, i'm basically happy for the program to crash and burn if it fails
02:18:28 <Beelsebob> so given /doom/jam/monkies and ../willies/jam.txt it would produces /doom/jam/willie/jam.txt
02:19:15 <dmwit> *nods*
02:19:48 <mauke> Beelsebob: concatenate and canonicalize
02:20:11 <Beelsebob> mauke: yeh, but then it gets stuck in the IO monad
02:20:20 <Beelsebob> when it doesn't need to me
02:20:21 <mauke> you can't do it without IO
02:20:21 <Beelsebob> be*
02:20:24 <mauke> yes, it does
02:20:25 <Beelsebob> ofc you can
02:20:28 <mauke> no
02:20:36 <Beelsebob> why do you need IO?
02:20:42 <mauke> to resolve symbolic links
02:20:52 <Beelsebob> interesting...
02:21:10 * Beelsebob ponders whether this is a moment for unsafePerformIO then
02:21:22 <Beelsebob> I think it probably is
02:21:32 <mauke> no, because symbolic links can be changed from outside the program
02:21:41 <Beelsebob> yes, but I'm only doing it once
02:21:43 <Beelsebob> so that matters not
02:22:08 <mauke> why do you need that at all?
02:22:25 <Beelsebob> tbh, it doesn't even need to resolve symbolic links
02:23:03 <mauke> then just concatenate
02:23:19 <Beelsebob> that's a point
02:23:27 * Beelsebob ponders if he even needs it to be a neat version
02:23:39 <mauke> you can't make it neater without resolving symlinks
02:24:15 <Beelsebob> ah, no, concatenate doesn't quite work
02:24:32 <Beelsebob> I need it for example to be able to deal with being passed /jam/ham/bob and /monkies/jam.txt
02:24:38 <Beelsebob> and produce /monkies/jam.txt
02:24:45 <Beelsebob> (ignore the pwd if it's an absolute path)
02:25:48 <dmwit> I wonder if there's an isAbsolutePath.
02:25:53 <dmwit> ?hoogle FilePath -> Bool
02:25:54 <lambdabot> Distribution.Simple.Utils.matchesDescFile :: FilePath -> Bool
02:25:54 <lambdabot> System.FilePath.Windows.hasExtension :: FilePath -> Bool
02:25:54 <lambdabot> System.FilePath.Windows.hasDrive :: FilePath -> Bool
02:26:13 <mauke> Beelsebob: System.FilePath.combine
02:26:41 <Beelsebob> > System.FilePath.combine "/jam" "/ham"
02:26:42 <lambdabot>   Not in scope: `System.FilePath.combine'
02:27:07 <Beelsebob> ah, okay
02:27:11 <Beelsebob> I'm a nubbin then
02:27:15 <mxc2> @hoogle try
02:27:15 <lambdabot> Control.Exception.try :: IO a -> IO (Either Exception a)
02:27:15 <lambdabot> System.IO.Error.try :: IO a -> IO (Either IOError a)
02:27:15 <lambdabot> Text.ParserCombinators.Parsec.Prim.try :: GenParser tok st a -> GenParser tok st a
02:27:16 <Beelsebob> that's awesome :)
02:27:47 <mxc2> @hoogle read
02:27:48 <lambdabot> Prelude.read :: Read a => String -> a
02:27:48 <lambdabot> Text.Read.read :: Read a => String -> a
02:27:48 <lambdabot> Text.Read :: module
02:30:15 <Beelsebob> :i createDirectory
02:30:23 <Beelsebob> @hoogle createDirectory
02:30:23 <lambdabot> System.Directory.createDirectory :: FilePath -> IO ()
02:30:23 <lambdabot> System.Directory.createDirectoryIfMissing :: Bool -> FilePath -> IO ()
02:30:23 <lambdabot> Distribution.Simple.Utils.createDirectoryIfMissingVerbose :: Verbosity -> Bool -> FilePath -> IO ()
02:31:25 <mxc2> @hoogle catch
02:31:26 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
02:31:26 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
02:31:26 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
02:32:11 <mxc2> @hoogle finally
02:32:12 <lambdabot> Control.Exception.finally :: IO a -> IO b -> IO a
02:36:41 <mxc2> hm
02:36:56 <mxc2> there is no 'pure' way to catch exceptions?
02:37:46 <mxc2> trying to figure out how to create something like maybeReadDouble :: (String -> Double) w/out getting into the IO monad
02:37:54 <ski> not `IO'-exceptions, no
02:38:07 <glguy> mxc2: don't use "read", but use "reads"
02:38:09 <glguy> :t reads
02:38:11 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:38:14 <ski> you could maybe use `Maybe' or `Either SomeError' instead
02:38:33 <ski> we want
02:38:42 <mxc2> ski: thats the idea, not sure how to implement that though
02:38:55 <wjt> > reads "3.3" :: [(Double, String)]
02:38:59 <ski>   readM :: (MonadPlus m,Read a) => String -> m a
02:39:05 <lambdabot>  [(3.3,"")]
02:39:06 <wjt> > reads "william shatner" :: [(Double, String)]
02:39:09 <lambdabot>  []
02:39:38 <ski> > (reads :: ReadS Double) "3.3apa"
02:39:39 <lambdabot>  [(3.3,"apa")]
02:40:27 <ski> @let readM s = case reads s of [(a,"")] -> return a ; _ -> mzero
02:40:27 <lambdabot> <local>:4:50: lexical error (UTF-8 decoding error)
02:40:44 <mxc2> got it
02:41:10 <Deewiant> > mread "3.3apa" :: Maybe Double
02:41:12 <lambdabot>  Just 3.3
02:42:33 <mxc2> @hoogle mread
02:42:33 <lambdabot> No matches found
02:42:42 <ski> @type L.mread
02:42:44 <lambdabot>     attempting to use module `L' (L.hs) which is not loaded
02:42:49 <ski> @type mread
02:42:50 <lambdabot> Not in scope: `mread'
02:42:59 <Deewiant> mread s = case reads s of [] -> mzero; xs -> return.fst.head $ xs
02:43:43 <ski> that's skipping trailing stuff :(
02:44:32 <Deewiant> ski: yours returns mzero on trailing stuff :-P
02:44:45 <ski> yes, that's better, imo
02:45:09 <ski> (if you want to allow trailing stuff, you should return it too, imo)
02:45:30 <Deewiant> @src read
02:45:31 <lambdabot> read s = either error id (readEither s)
02:45:51 <ski> mxc2 : something like `maybeReadDouble :: String -> Maybe Double' ?
02:46:05 <mxc2> ski, yeah, got it
02:46:15 <Deewiant> hm, what kind of stuff parses ambiguously anyway
02:47:38 <dmwit> Deewiant: Plenty of things!
02:47:46 <Deewiant> dmwit: For instance!
02:47:51 <dmwit> Let me think!
02:47:54 <Deewiant> :-)
02:47:56 <dmwit> =)
02:48:02 <mxc2> reading a CSV with holes in the data
02:48:10 <mxc2> not that i'm doing exactly that or anything..
02:48:20 <dmwit> Oh?  Is that actually ambiguous?
02:48:25 <mxc2> doing something very different
02:48:30 <snhmib> what is wrong here, i have a function that calls some C-iteration functions and maps a function over the returned values (gvIterMap) and that works, but when i make a function that calls that one but where the function i map is id then ghc gives an error
02:48:31 <mxc2> reading a PSV
02:48:32 <snhmib> http://rafb.net/p/9VUXE536.html
02:48:32 <Deewiant> well, plenty of stuff basically might, but I was thinking more of builtin ReadS instances
02:48:33 <lambdabot> Title: Nopaste - No description
02:48:43 <Deewiant> most people use Parsec for parsing anyway :-)
02:48:45 <mxc2> @hoogle monadplus
02:48:46 <lambdabot> Control.Monad.MonadPlus :: class Monad m => MonadPlus m
02:48:50 <snhmib> i'm not sure why ghc would complain there :(
02:49:48 <Saul_> Type level programming in Haskell is really bad
02:49:51 <dmwit> Deewiant: Well, as usual, Wikipedia's example is overly academic.
02:50:22 <Deewiant> dmwit: Like said, I was hoping for a standard ReadS instance.
02:50:32 <snhmib> Saul_: was that for me?
02:50:36 <dmwit> I don't think any of the standard instances are ambiguous.
02:50:52 <Saul_> snhmib: No that was more of a general remark
02:50:57 <snhmib> oh ok :)
02:51:30 <Saul_> I've been working on this vector/matrix library, but most functions need to be overloaded to allow recursion
02:51:35 <dmwit> snhmib: I find it hard to believe that (liftM id :: b -> GV d).
02:51:57 <dmwit> Unless GV is a monad?
02:52:02 <Saul_> which means that the type classes I've used pop up in functions that use the library
02:52:37 <snhmib> i just did type GV a = IO (a)
02:53:28 <Zao> So, who made darcs.net keel over?
02:53:33 <dmwit> :t liftM id
02:53:37 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
02:53:48 <dmwit> :t return . id
02:53:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
02:53:56 <thoht> :t id
02:53:57 <lambdabot> forall a. a -> a
02:54:00 <dmwit> snhmib: You probably want (return . id) instead of (liftM id).
02:54:03 <snhmib> ah thanks
02:54:14 <dmwit> ...or just return.
02:54:15 <dmwit> =P
02:54:22 <dmwit> (. id) is sort of silly
02:54:35 <snhmib> just a bit :)
03:10:43 <mxc2> @hoogle readDate
03:10:44 <lambdabot> No matches found
03:10:47 <mxc2> @hoogle readCalendar
03:10:48 <lambdabot> No matches found
03:11:01 <mxc2> :t read :: (String -> CalendarTime)
03:11:02 <lambdabot>     Not in scope: type constructor or class `CalendarTime'
03:11:08 <mxc2> :t read :: (String -> Time.CalendarTime)
03:11:10 <lambdabot> String -> System.Time.CalendarTime
03:11:18 <mxc2> @src read :: (String -> Time.CalendarTime)
03:11:18 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:26:18 <visof_> is the Parser a function that takes String and return Tree ?
03:27:43 <visof_> if yes
03:27:55 <visof_> the type of the Parser will be:
03:28:06 <visof_> Parser :: String -> Tree ?
03:28:16 <ski> String -> Maybe Tree
03:28:17 <ski> rather
03:28:49 <ski> (or `String -> [Tree]' if you want nondeterministic parsing)
03:28:59 <visof_> in Graham Hutton book :
03:29:02 <ski> (s/nondeterministic/ambiguous/
03:29:03 <ski> )
03:29:15 <visof_> type Parser = String -> Tree
03:29:22 <visof_> i can't understand
03:29:26 <visof_> what is type
03:29:33 <ski> type synonym
03:29:34 <visof_> i know "data"
03:29:41 <visof_> what is this
03:29:42 <visof_> ?
03:29:53 <ski> it just means that `Parser' is a shorthand for `String -> Tree'
03:29:55 <ski> so
03:29:59 <pjd_> @src String
03:29:59 <lambdabot> type String = [Char]
03:30:01 <ski> foo :: Parser
03:30:04 <ski> is the same as
03:30:09 <ski> foo :: String -> Tree
03:30:37 <ski> as pjd_ showed, `String' itself is also a type synonym (for list of characters)
03:30:58 <visof_> ah
03:31:02 <visof_> thanks ski
03:31:22 <pjd_> visof_: there's a third variant, newtype
03:31:51 <visof_> pjd_ how can i use it?
03:31:58 <dmwit> newtype defines a type alias (like type), but with a constructor (like data).
03:32:00 <dmwit> So:
03:32:11 <dmwit> newtype MyInt = MyInt Int
03:32:16 <Deewiant> @src IO
03:32:16 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
03:32:36 <pjd_> the important difference is that the newtype doesn't work like a synonym;  the type system treats them like distinct types
03:32:45 <dmwit> instance Num MyInt where (MyInt a) + (MyInt b) = MyInt ((a + b) `mod` 5)
03:32:58 <dmwit> That's a fun way to get modular arithmetic.
03:33:05 <pjd_> (but newtypes still have no runtime cost)
03:34:14 <dmwit> I sometimes wish for this feature:
03:35:04 <visof_> type visof =  {ID=Int , name=[Char]}, is this right?
03:35:05 <dmwit> given an instance Foo of class Bar, a new data type Baz with conversion function f :: Baz -> Foo and g :: Foo -> Baz
03:35:22 <dmwit> create the instance Baz of class Bar automatically.
03:35:36 <dmwit> visof_: Not quite.
03:35:48 <visof_> why ?
03:35:50 <dmwit> visof_: First: type names must be capitalized.
03:35:58 <dmwit> visof_: Second, records can't be aliased.
03:36:02 <dmwit> So:
03:36:12 <dmwit> type Visof = (Int, [Char]) -- this is okay
03:36:19 <Arnar_> hey guys
03:36:25 <dmwit> Hiya, Arnar_!
03:36:31 <visof_> okay
03:36:36 <Deewiant> data Visof = Visof { id :: Int, name :: [Char] }
03:36:54 <Arnar_> so.. can anyone give me the shortest possible explanation of the difference between newtype and data ?
03:37:09 <ToRA> Deewiant: id is a very bad name to use as a record selector ;)
03:37:10 <dmwit> newtype may use only one constructor
03:37:21 <Arnar_> dmwit: that's the only difference?
03:37:33 <dmwit> No.
03:37:33 <Deewiant> ToRA: in general, I prefix all my record selectors with a part of the type name anyway
03:37:34 <TSC> newtype is just a wrapper around an existing type
03:37:36 <Arnar_> and data with only one alternative is equivalent to a newtype?
03:37:46 <dmwit> Arnar_: There is one other difference.
03:37:47 <ToRA> Deewiant: amen to that
03:37:47 <visof_> ToRA what should use for record selector ?
03:38:04 <dmwit> Arnar_: Newtype's constructor is discarded in the compiler.
03:38:17 <Arnar_> dmwit: ah ok..
03:38:23 <Deewiant> visof_: well, 'id' is bad because it's a Prelude function. :-)
03:38:25 <dmwit> Arnar_: This means (Constructor undefined) behaves differently for a newtype and for data.
03:38:31 <visof_> ah
03:38:38 <visof_> thanks all
03:38:42 <Arnar_> dmwit: so newtype is just like type -- except the type system enforces that you are using exaclty the correct type (and not an alias)?
03:39:02 <dmwit> Yes!
03:39:09 <Arnar_> excellent..
03:39:12 <Arnar_> thanks dmwit++
03:39:56 <Arnar_> don't you hate it when you touch vinegar and your hands smell for days .. :/
03:42:04 <Arnar_> so.. can I ask a lengthy question?
03:42:09 <Arnar_> need some advice on tyyping
03:42:12 <Arnar_> typing*
03:42:29 <wjt> evidently ;-)
03:42:29 <dmwit> Good posture is the key.
03:42:31 <dmwit> ;-)
03:42:37 <Arnar_> :)
03:43:10 <Arnar_> here's the deal.. I want to wrap an existing monad type (STM).. let's say in "LoggedSTM"
03:43:22 <Arnar_> I want to add a new kind of a TVar..
03:43:25 <Arnar_> LoggedTVar
03:44:24 <Arnar_> then I want to have readTVar and writeTVar operate on both types (on TVar they'll call the std ones, on LoggedTVar they'll log it in the monad and then call the std ones)
03:44:39 <dmwit> type classes!
03:44:42 <Arnar_> I want "atomically :: STM a -> IO a" to handle only regular tvars
03:44:44 <Arnar_> ok
03:44:58 <Arnar_> but "logged_atomicaaly :: LoggedSTM a -> IO a" to handle both
03:45:01 <dmwit> Sorry, go ahead and finish your question.
03:45:06 <Arnar_> I'm done :)
03:45:22 <Arnar_> although I should have typed "atomically :: LoggedSTM a -> IO a"
03:45:29 <dmwit> :t readTVar
03:45:33 <lambdabot> Not in scope: `readTVar'
03:45:41 <Arnar_> ?index readTVar
03:45:42 <Deewiant> ?h readTVar
03:45:42 <lambdabot> GHC.Conc, Control.Concurrent.STM.TVar, Control.Concurrent.STM
03:45:42 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
03:45:47 <Deewiant> ?hoogle readTVar
03:45:47 <lambdabot> GHC.Conc.readTVar :: TVar a -> STM a
03:46:00 <dmwit> OK, so readTVar isn't typeclassed.
03:46:04 <dmwit> Arnar_: Here's my suggestion.
03:46:19 <Arnar_> I'm willing to hide readTVar with my own implementation
03:46:32 <dmwit> Yeah, okay, then just make type classes.
03:46:48 <Arnar_> I'd still like to hear your suggestion :)
03:46:51 <dmwit> This is exactly the situation they were made for.
03:47:04 <dmwit> (...that *was* my suggestion. =P)
03:47:11 <Arnar_> heh ok.. :)
03:47:38 <Arnar_> so would I make one typelcass for TVars and another one for the STM monad?
03:47:56 <dmwit> hum
03:48:00 * dmwit reads back a bit
03:48:05 <Arnar_> I really need help with typing... :)
03:48:55 <dmwit> Yeah, two separate type classes makes the most sense.
03:48:58 <Arnar_> here's an example situation.. take a program that already uses the regular STM system (tvars, atomically, etc.) - replace the import Control.Concurrent.STM with my module
03:49:01 <Arnar_> ok..
03:49:26 <Arnar_> should work that way.. but now change soe newTVars to newLoggedTVars -- and any atomically block they are used in to "logged_atomically"
03:49:36 <Arnar_> s/soe/some/
03:49:56 <Arnar_> but yes.. you've given me enough to start with..
03:49:58 <Arnar_> thanks again
03:52:04 <ibid> anybody awake with access to haskell.org www logs?
04:00:25 <Arnar_> can typeclasses be polymorphic (i.e. be parametrized on types)
04:00:37 <Arnar_> like:  class (MyClass a) b where ...
04:01:49 <Arnar_> wondering how to make a typeclass for types like (TVar a)
04:02:54 <ex1stenz> http://www.colectionarul.com/existenz1.html
04:02:55 <lambdabot> Title: 1a Albumul de surprize a lui 1d existenz1 | Colectionarul.Com 1a6
04:03:27 <GrayShade> wtf, ex1stenz?
04:03:34 <Arnar_> spammer?
04:03:35 <shapr> ex1stenz: Spam is not allowed here.
04:03:41 --- mode: ChanServ set +o shapr
04:03:54 --- kick: ex1stenz was kicked by shapr (Kicked by shapr)
04:04:50 <anX> Hey; a Haskell newbie here.
04:04:58 <dmwit> Hiya, anX!
04:05:03 <anX> How do I define infix functions?
04:05:47 <dmwit> > let a + b = 3 in 1 + 2
04:05:50 <lambdabot>  3
04:06:03 <dmwit> Okay, bad example. =)
04:06:13 <Deewiant> > let 1 + 1 = 3 in 1 + 1
04:06:16 <lambdabot>  3
04:06:27 <anX> Oh nice
04:06:29 <anX> Thanks
04:06:33 <GrayShade> anX: what do you mean by infix functions?
04:06:35 <ziman> :D
04:06:42 <Arnar_> > let a `combine` b = concat [a,b] in "abc" `combine` "def"
04:06:43 <lambdabot>  "abcdef"
04:06:57 <anX> Those backtics are annoying
04:07:08 <anX> s/backtics/backticks
04:07:22 <Arnar_> anX: the backticks tell the parser that you want to apply it as an infix function
04:07:40 <dmwit> Use operator characters as your function name if you want to use it infix a lot.
04:07:50 <TSC> > let a ## b = concat [a,b] in "abc" ## "def"
04:07:51 <lambdabot>  "abcdef"
04:08:11 <anX> Okay, cool.
04:08:18 <Arnar_> you can also call operators in prefix form
04:08:19 <Arnar_> > (
04:08:20 <lambdabot> Unbalanced parentheses
04:08:21 <Arnar_> soryr
04:08:23 <Deewiant> > (+) 2 3
04:08:25 <lambdabot>  5
04:08:28 <anX> I know
04:08:30 <anX> Thanks
04:08:42 <ski> > let a `combine` b = concat [a,b] in combine "abc" "def"
04:08:44 <lambdabot>  "abcdef"
04:08:44 * Arnar_ goes to buy some new fingers
04:09:15 <GrayShade> are there any plans to take (+) and (-) out of Num to support things like vector spaces?
04:09:52 <dmwit> er?
04:10:01 <dmwit> Oh, vector spaces don't do (*), huh?
04:10:23 <ibid> they do different (*)
04:10:28 <GrayShade> they sometimes have two (*)s
04:10:29 <dmwit> There have been proposals for a new Num hierarchy, I think, but not a lot of agreement.
04:10:51 <ivanm> we could start categorizing operations on semigroups or something :p
04:10:55 <ibid> three, if 3d
04:10:57 <dmwit> ibid, GrayShade: I meant, their (*) doesn't match the Num-version's type signature.
04:11:01 <ibid> two for any dimensions
04:11:07 <ibid> dmwit: yes, exactly
04:11:18 <ibid> dmwit: and there are two contenders for that name, anyway
04:11:55 <GrayShade> dmwit: they also don't have fromInteger and signum
04:13:01 <ibid> signum would make some sense, i think
04:13:18 <ibid> (normalize)
04:13:23 <ski> mapping to a projective space ?
04:13:30 <ski> ok
04:14:03 <ibid> abs for getting the magnitude, signum for getting the direction
04:14:19 <ToRA> Arnar_: http://hpaste.org/7408
04:14:34 <ivanm> where's the hpaste bot got to?
04:14:51 <ski> @check \x -> abs x * signum x == x
04:14:52 <lambdabot>  OK, passed 500 tests.
04:15:00 <Arnar_> ToRA: wow.. thank you
04:15:04 <Arnar_> ToRA++
04:15:05 <ToRA> your Arnar_: wasn't quite sure /what/ you wanted logging, but you get the idea
04:15:25 <Arnar_> ToRA: yeah.. I mainly needed an example of how to construct type typeclasses
04:15:36 <Arnar_> thanks a million
04:15:54 <ToRA> Arnar_: i tried it with them separated, but then inference just broke in the example function, so had to shove the two together
04:16:12 <Arnar_> ok
04:16:43 <Arnar_> ToRA: this might end up in a publication.. can I acknowledge you somehow?
04:16:51 <ToRA> certainly
04:17:21 <Arnar_> ToRA: I see your name in /whois.. I can use that one?
04:17:54 <ToRA> sure
04:34:29 <Japsu>          
04:34:34 <Japsu> -"         "
04:35:44 <dcoutts_> ibid: I've no idea why that /etc/hosts entry is there, perhaps Igloo or malcolmw know
04:36:32 <skorpan> i need some advice on how to make a bit of monadic code sleaker...
04:36:44 <malcolmw> dcoutts_: ibid: me neither
04:36:44 <ibid> dcoutts_: right. let's wait for them :)
04:36:51 <skorpan> http://hpaste.org/7409
04:36:55 <ibid> dcoutts_: gtk2hs is one of the sufferers :)
04:37:07 <dcoutts_> ibid: oh right
04:37:42 <malcolmw> dcoutts_: ibid: it is probably so that code.h.o thinks of itself as being haskell.org, but I never understood why that was desirable
04:39:12 <skorpan> does anyone have a neat trick for me? i *think* i saw like eight functions such as fst and snd
04:39:14 <dmwit> skorpan: liftM (\(_, _, _, ..., r) -> r) (execStateT ... initState)
04:39:46 <skorpan> well i guess that's one way of doing it..
04:39:54 <skorpan> i'm not sure i see it as sleaker though
04:40:04 <dmwit> skorpan: But really, use a record for tuples longer than 3ish, I would say.
04:48:44 <skorpan> i seem to have forgotten how haskell records work :)
04:49:18 <dmwit> data Foo = Foo { a :: Bar, b :: Baz }
04:49:26 <skorpan> yes, that part i know
04:49:38 <skorpan> but i'm trying to pattern match it when i use "get"
04:49:56 <dmwit> Use gets instead.
04:49:57 <dmwit> :t gets
04:50:02 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
04:50:09 <dmwit> Well.
04:50:13 <skorpan> oh
04:50:15 <dmwit> Use gets if you need a single entry.
04:50:20 <skorpan> Gets specific component of the state, using a projection function supplied.
04:50:29 <dmwit> Use this kind of pattern if you need several parts of the record:
04:50:37 <skorpan> well i only need to change a single entry, but i will put the new state after that
04:50:41 <dmwit> (Foo { a = aValue })
04:50:50 <dmwit> :t modify
04:50:51 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
04:51:03 <skorpan> cool thanks
04:51:08 <dmwit> Yup. =)
04:53:10 <ibid> malcolmw: yeah, that's the effect, obviously, but it's wrong unless it also provides identical services :)
05:14:14 <skorpan> wow, "modify" and usage of records drastically improved readability of my code :)
05:14:29 <opqdonut> modify is great
05:14:55 <skorpan> indeed
05:16:40 <GrayShade> modify tail sounds funny
05:17:26 <Deewiant> modify head sounds worrying... fortunately it doesn't type-check ;-)
05:17:51 <GrayShade> :d
05:20:49 <GrayShade> how are views used?
05:21:00 <GrayShade> i always get warnings on the patterns
05:21:41 <GrayShade> http://hpaste.org/7410
05:22:40 <wjt> GrayShade: what if view were not to yield 1 ?
05:26:31 <Wraithan> While I know there is a list of books on the website, are there any that stand out as supreme for one just learning the language, coming from a C++ background?
05:27:38 <GrayShade> wjt: it complains that they are overlapped, not that they're incomplete
05:27:57 <GrayShade> and it says the same if i write view -> x
05:27:57 <wjt> huh.
05:28:13 <GrayShade> Warning: Pattern match(es) are overlapped In the definition of `f': f ((view -> x)) = ...
05:28:45 <ibid> Wraithan: no, they're all about as good for that.  which you ought to choose depends more on if you're math oriented or bells-and-whistles oriented
05:29:23 <ToRA> http://hpaste.org/7411 - anybody know what the syntax is for placing class constraints on existially quantified variables in gadts with record syntax?
05:30:09 <ibid> Wraithan: there's the small trouble, though, that all the books are written for programming newbies and thus may be deceptively slow at the beginning
05:30:14 <Wraithan> ibid: Ok, well, I guess I will just head down to the bookstore and check out a couple of them
05:30:43 <GrayShade> maybe you should try YAHT as a start
05:31:12 <Wraithan> ibid: heh, that is alright, with how crazy of syntax haskell has compared to what I am used to, I will need a slow start
05:31:21 <GrayShade> Wraithan: http://en.wikibooks.org/wiki/Haskell/YAHT
05:31:39 <ibid> Wraithan: just remember, the syntax is the easy part :)
05:31:55 <Wraithan> GrayShade: I was about to start that actually, but I like to have a hardcopy book to go along with my studies of languages
05:32:52 <Wraithan> ibid: it is what is slowing me down the most so far when it comes to trying to use xmonad heh
05:32:56 <ibid> Wraithan: my three recommendations are bird for the math-oriented, hudak for those who want to make stuff that is visible, and thompson as a sort of middle ground between them
05:33:35 <Wraithan> Will probably go with thompson then, never know what you will need your languages for :D
05:34:14 <ibid> Wraithan: (those are the books i know best.  i have skimmed the new-ish hutton book which many people praise but didn't find it very inspirational)
05:42:06 <Igloo> dcoutts_, ibid: The haskell.org/haskell /etc/hosts entry looks to me like the problem is we don't have a name for the machine
05:42:34 <dcoutts_> Igloo: a name for which machine?
05:42:42 <Igloo> dcoutts_: Community
05:43:03 <dcoutts_> Igloo: can't we call it community.haskell.org?
05:43:06 <Igloo> Hmm, but it's for the IP address, not 127.0.0.1. That's very odd.
05:43:08 <Arnar_> does "data Bla" on its own create both a type and value ctors?
05:43:22 <ToRA> no
05:43:26 <Igloo> dcoutts_: That's a role rather than a machine
05:43:27 <ToRA> data Bla = Bla does
05:43:42 <Arnar_> ToRA: ok.. so "data Bla" is basically a type you can't create a value of?
05:43:42 <ToRA> data Bla creates only type ctrs
05:43:45 <ToRA> yeah
05:43:48 <Arnar_> ok
05:43:56 <ToRA> you'll need LANGUAGE EmptyDataDecls turned on
05:44:00 <ToRA> iirc
05:44:05 <Arnar_> ok.. thx
05:46:21 <ibid> Igloo: sounds plausible - but it can't remain so (forex, i'm getting email from its cron every hour because of those 404s:)
05:47:22 * Igloo will fix it
05:47:31 <ibid> cool
05:47:45 <malcolmw> Igloo: dcoutts_ : so here is a suggestion for a name for the machine, separate from any of its roles:  rented.haskell.org  :-)
05:48:12 * Igloo has called it bishop for now. We can argus about its final name later  :-)
05:48:47 * Igloo wonders what generated the autogenerated hostname
05:48:54 * ibid looks up bishop haskell in wikipedia .... nothing
05:49:12 <ibid> Igloo: one guess is resolvconf
05:49:14 <Igloo> darcs.haskell.org == monk
05:49:18 <ibid> hah
05:49:22 * malcolmw has a laptop called bishop (but not bishop.h.o)
05:49:31 <ibid> nun?
05:49:48 <cjs__> BTW, in case anyone is interested: http://www.cynic.net/LittleHaskeller.lhs
05:50:36 <Igloo> Argh. The control panel tells me I've receieved an invalid certificate
05:52:34 <Igloo> ibid: Should work now. I'm not sure if it'll work if it reboots, though
05:54:22 <ibid> trying
05:54:47 * SamB_XP wonders why the emacs frontend for agda loads agda in GHCi...
05:56:43 <ibid> Igloo: confirmed, works
05:57:17 <ibid> and i'll remember to check this issue again if haskell.org blogs resume 404ing for planet
05:57:20 <SamB_XP> ... and whether that has anything to do with it being such a RAM hog
05:57:51 <ddarius> SamB_XP: I can't see it helping memory usage.
05:58:04 <SamB_XP> well, yes, it certainly can
05:58:06 <SamB_XP> t help
05:59:55 <ddarius> Maybe it's so you can debug Agda !
06:00:54 <SamB_XP> ddarius: wouldn't it be better if that were a customization option then?
06:01:40 <SamB_XP> plus, my favorite way to debug involves using the profiler
06:02:03 <ddarius> Why would you want to do a silly thing like give users options?
06:19:05 <mercury^> How can I combat the stack overflow with (iterate f x)!!(largeInt)?
06:25:44 <Deewiant> mercury^: instead of !! use something that `seq`s every index as it goes along
06:25:56 <Deewiant> @src (!!)
06:25:57 <lambdabot> xs     !! n | n < 0 = undefined
06:25:57 <lambdabot> []     !! _         = undefined
06:25:57 <lambdabot> (x:_)  !! 0         = x
06:25:57 <lambdabot> (_:xs) !! n         = xs !! (n-1)
06:26:17 <Deewiant> replace the last with (x:xs) !!! n = x `seq` xs !! (n-1)
06:26:27 <Deewiant> might help
06:27:23 <mercury^> Deewiant: thanks
06:28:44 <Wraithan> Heh, that will teach me for skimming, couldn't figure out the last problem in the lists section until I re-read the first part of that word for word. It said head returned the first element, so I assumed that tail returned the last and just moved on...
06:29:05 <GrayShade> @src foldl'
06:29:05 <lambdabot> foldl' f a []     = a
06:29:05 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:31:10 <Deewiant> > foldl' (const . f) x [1..10]
06:31:11 <lambdabot>  f (f (f (f (f (f (f (f (f (f x)))))))))
06:31:14 <Deewiant> > iterate f x !! 10
06:31:15 <lambdabot>  f (f (f (f (f (f (f (f (f (f x)))))))))
06:43:01 <Vq^> :t f
06:43:01 <lambdabot> forall a. (FromExpr a) => a
06:57:40 * edward1 waves hello.
06:58:33 <fizzletip> Hello.
07:00:31 <byorgey> morning edwardk
07:00:37 <byorgey> hi fizzletip
07:08:20 <k34h> hi
07:10:20 <byorgey> hi k34h
07:13:05 <k34h> can anyone help me with an error im getting in this code http://hpaste.org/7412
07:13:26 <k34h> Type error in final generator on line 130
07:13:54 <Deewiant> yikes, that's a lot of indentation O_o
07:14:28 <Deewiant> what's with the hanging 'let' at the end
07:14:46 <int-e> the paste is too long
07:15:12 <int-e> it's restricted to 5k of text
07:15:32 <k34h> http://rafb.net/p/8JTzOX24.html
07:15:33 <lambdabot> Title: Nopaste - Haskell Type error in final generator
07:18:11 <tahir_hh> Hi everyone, I am embarking on a mission to write a gui application in haskell that will run on windows xp.  I have decided to download wxHaskell and GHC. Is there anything I should know before starting?
07:18:49 <Deewiant> k34h: the type of trackToCatalogueUI seems odd. You probably want it to return a new Catalogue, and since you have the 'invalid selection' case there you probably want its type to be something like String -> Catalogue -> IO (Maybe Catalogue)
07:19:02 <MarcWeber> tahir_hh: No.. except that wx version should match ghc version
07:19:12 <tahir_hh> thanks marc.
07:19:24 <MarcWeber> tahir_hh: Just get started :)
07:19:38 <tahir_hh> Last question please:
07:19:50 <tahir_hh> is building things a mission or is it fairly easy?
07:19:55 <MarcWeber> Does something like this myWhen already exist ? http://rafb.net/p/cV9qYO84.html
07:19:55 <lambdabot> Title: Nopaste - No description
07:20:16 <MarcWeber> tahir_hh: describe things..
07:22:22 <tahir_hh> On linux I am sure that building things are a few commands away but on windows xp everything is a bit harder.  You have to mess around with different compilers etc
07:22:34 <k34h> the error winHugs is giving me is *** Term           : addToCatalogue (Popular title artist length 0) userCatalogue
07:22:34 <k34h> *** Type           : [Track]
07:22:34 <k34h> *** Does not match : IO a
07:22:56 <tahir_hh> I meant building in the sense of compilation rather than the actual writing of the software
07:23:08 <Deewiant> k34h: yes, because the type signature for trackToCatalogueUI is wrong.
07:23:41 <Deewiant> k34h: you're currently having it take an IO action and return a Catalogue, yet what you're doing in the function is IO ().
07:24:01 <MarcWeber> tahir_hh: :) It depends.. There is no general answer to this.. But yes *g* I'm on working on linux because of this reason.
07:26:02 <tahir_hh> MarcWeber: are you writing gui applications specifically or some research type stuff?
07:26:21 <tahir_hh> MarcWeber: *as the reason you are using linux.
07:28:02 <MarcWeber> I've written a very small gui application on win once.. Right now I'm working on a shim branch to enhance editor haskell support (emacs, vim and maybe eclipse)
07:28:31 <DuClare> Interesting
07:28:42 <MarcWeber> tahir_hh: The reason is nix now. And that a lot of tools such as ssh etc are easier to be used in scripting
07:29:25 <tahir_hh> MarcWeber: so is this academia or industry? Just out of interest (not to be nosey)
07:29:31 <k34h> ok iv changed its type to String -> Catalogue -> Catalogue, but im still getting the same error
07:30:03 <Deewiant> k34h: since you're doing IO, you need to have the return type in IO. String -> Catalogue -> IO Catalogue is along the lines of what you want.
07:30:18 <MarcWeber> tahir_hh: I plan to use haskell for economic reasons - So I guess the answer is industrial
07:30:28 <Deewiant> k34h: but I suggest you read a few Haskell tutorials before continuing. :-)
07:31:24 <DuClare> MarcWeber, What kind of things you're doing for Vim exactly?
07:32:20 <tahir_hh> MarcWeber: Respect to you for believing.  I am doing it for a mixture of enlightenment in addition to wanting to broaden my employment opportunities
07:32:59 <MarcWeber> DuClare: Using tags and rewrite part of shim. Shim did already function and some module completion. I'd like to add full cabal support (automatically recompile cabal setup file etc)..
07:33:31 <DuClare> Cute.
07:33:56 <MarcWeber> DuClare: http://rafb.net/p/Tgc7mw22.html A wish list
07:33:56 <lambdabot> Title: Nopaste - No description
07:36:28 <cjs_> tahir_hh: Oh, yeah, "I can do Haskell Windows apps" is really going to broaden your employment oppertunities. By about three, worldwide, maybe. :-)
07:37:12 <MarcWeber> *lol* Yeah .. On windows it depends on what you have to do. Integration of different tools is so much better (eg when using COM)
07:38:34 <cjs_> Well, I'm definitely interested if you get any COM stuff working. I'm starting to integrate Haskell apps into Excel, at the moment, and though I finally convinced my outsourced Windows guy to switch from VB to C#, I'm still not terribly happy with it.
07:39:11 <tahir_hh> cjs_: its not about the Haskell-ness or the WindowsGUI-ness that employers want.  It is the ability to think functionally and having used different technologies
07:39:21 <MarcWeber> cjs_: There is also f# which might be even better.
07:39:57 <cjs_> MarcWeber: for me, possibly. Given that I'm outsourcing this bit right now, "Ha ha!"
07:40:28 <MarcWeber> cjs_: That's another way to solve a problem.. Don't bother ask someone else
07:40:33 <cjs_> Given a few months I'll probably be doing some more serious hacking on that stuff myself, but right now I'm busy with the Unix side. (And learning Haskell.)
07:41:23 <cjs_> MarcWeber, that's not necessarially an easy way. It often takes me longer to spec. stuff than to program it myself. I'm just not up to speed on Windows at the moment.
07:41:29 <MarcWeber> cjs_: About com have a look at haskellcafe mailinglist. There have been some posts about newer libs than hdirect (which was kind of broken)
07:42:08 <cjs_> Thanks. I'll follow up on that when the time comes.
07:42:14 <MarcWeber> cjs_: Whats your task on the linux side?
07:43:20 <MarcWeber> cjs_: So you don't spec stuff for your customers?
07:44:18 <tahir_hh> woooohooooooooooo!!! I compiled and then I ran the sample program.  I feel so happy :)
07:44:54 <Kamina> can someone explain me what's the difference between "existential types" and "polymorphic components"?
07:44:54 <lambdabot> Kamina: You have 1 new message. '/msg lambdabot @messages' to read it.
07:45:00 <Kamina> oh
07:46:01 <cjs_> MarcWeber, on the Linux side, an automated trading system. It eats a market data feed, applies pricing algorithms to it, and uses that to place orders.
07:46:25 <childe> Hi, is Haskell's way to handle exceptions purely functional?
07:46:34 <Valodim> yes
07:46:45 <cjs_> No, I'm an Extreme Programming kinda guy, so not in the way I have to spec. with outsourcers.
07:46:58 <Kamina> i think exceptions are done with Mondas?
07:47:01 <MarcWeber> Kamina: I can only tell you a little bit about existential types. You can see it as data havin attached some functions at runtime. (thus similar to kind of object with virtual table in most other languages)
07:47:38 <MarcWeber> Kamina: Not everywhere. Using monads is one way. Throwing exceptions is another one
07:47:56 <ski>   data SomeThing a = forall x. ST x (a -> x -> x) (x -> Maybe (a,x))
07:47:57 <MarcWeber> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors @ Kamina
07:47:58 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
07:48:01 <Valodim> how can you throw exceptions outside of a monad?
07:48:16 * Valodim reads
07:48:24 <ski>    ST :: forall x. x -> (a -> x -> x) -> (x -> Maybe (a,x)) -> SomeThing a
07:48:26 <ski>     data AnyThing a = AT (forall b. b -> a b) (forall b c. a b -> (b -> a c) -> a c)
07:48:28 <childe> Thanks!
07:48:33 <MarcWeber> cjs_: Do you know about nix? It might be of interested. Configure your service one and reinstall it from source repo
07:48:42 <ski>   AT :: (forall b. b -> a b) -> (forall b c. a b -> (b -> a c) -> a c) -> AnyThing a
07:49:20 <MarcWeber> cjs_: So it's kind of let's buy there where it's cheapest? And that's done automatically?
07:49:22 <ski> Kamina : note how in the first case, the `forall x.' is wrapped around the whole type of `ST' (but `x' is not used in the return type of the constructor)
07:49:55 <childe> So the catch catches exceptions in a monad.
07:49:56 <ski> Kamina : in the second case, the `forall b.' and `forall b c.' are nested inside the arguments of `AT'
07:50:18 <ski> Kamina : those two uses of `forall' are very different .. in some sense they are opposite
07:50:18 <Kamina> ski: the second case is polymorphic components, right?
07:50:22 <ski> right
07:50:51 <Kamina> but can't i rewrite
07:50:52 <Kamina> data AnyThing a = AT (forall b. b -> a b) (forall b c. a b -> (b -> a c) -> a c)
07:50:55 <Kamina> as
07:51:09 <ski> the first case says, I (`AT') can handle any type `x' you want, and i return something that has forgotten what type `x' was, so you can't recall it, when pattern-matching
07:51:24 <ski> s/AT/ST/
07:51:50 <cjs_> MarcWeber, well, "when," not "where"; it has a pricing model, and uses that to attempt to buy low and sell high.
07:51:51 <Kamina> data AnyThing a = forall b' b c. AT (b' -> a b') (a b -> (b -> a c) -> a c)
07:52:10 <ski> the second case says, I (`AT') require arguments that can handle any type `b' (and `c') that *I* want, you have to give me things which work for every possible `b' (and `c')
07:52:11 <cjs_> And yes, it's automated; it's supposed to run at 10-20 orders per second.
07:52:20 <MarcWeber> cjs_: What kind of goods are you trading with?
07:52:22 <cjs_> I don't know about nix; tell me more?
07:52:26 <cjs_> Options on futures.
07:52:37 <ski> Kamina : no, you can't
07:52:43 <cjs_> (BTW, market == stock market, here.)
07:52:56 <ski> Kamina : generally, when thinking of this, think like :
07:53:04 <childe> BTW, is there a function in Haskell that works like the APPLY function in Lisp?
07:53:20 <ski>   data Foo = forall a. MkFoo (type 0) (type 1) (type 2)
07:53:42 <ski>   forall a. MkFoo :: (type 0) -> (type 1) -> (type 2) -> Foo
07:53:49 <ski>   MkFoo :: forall a. (type 0) -> (type 1) -> (type 2) -> Foo
07:53:53 <ski> which means
07:53:57 <ski>   MkFoo :: forall a. ((type 0) -> (type 1) -> (type 2) -> Foo)
07:53:58 <MarcWeber> cjs_: The system is a lazy functional language describing how to compile your os with --rollback options. You cannot break your system by installing the wrong software. Just get back to the older state. Remove no longer used software by a garbage collector (as used in memory)
07:54:02 <ski> for the other case
07:54:24 <ski>   data Bar = MkBar (forall a. some type) (some other type)
07:54:34 <ski>   MkBar :: (forall a. some type) -> (some other type) -> Bar
07:54:37 <cjs_> Ooo. interesting. Sounds like it could provide some of the functionality of Erlang.
07:54:59 <cjs_> childe: $, I think.
07:55:05 <MarcWeber> childe: don't know that apply? Does it work like apply plus [2,3] ?
07:55:07 <ski> Kamina : note that you could rewrite `Foo' to the almost same :
07:55:15 <cjs_> Though suddenly I'm not clear on what apply does, really.
07:55:21 <ski>   data Foo' = forall a. MkFoo (type 0,type 1,type 2)
07:55:33 <ski>   forall a. MkFoo' :: (type 0,type 1,type 2) -> Foo
07:55:42 <ski>   MkFoo' :: forall a. (type 0,type 1,type 2) -> Foo'
07:55:50 <ski>   MkFoo' :: (exists a. (type 0,type 1,type 2)) -> Foo'
07:55:51 <cjs_> I have used $ in the sense of (map ($ 2) [(1+), (2+), (3+)]).
07:56:02 <ski> (forgot to add two of the appostrophes ..)
07:56:06 <Kamina> so
07:56:08 <cjs_> > map ($ 2) [(1+), (2+), (3+)]
07:56:10 <lambdabot>  [3,4,5]
07:56:13 <Kamina> i think i'm now completely confused :-)
07:56:28 <ski> Kamina : hence the name "existential data types"
07:56:37 <ski> Kamina : oh, sorry ;)
07:56:41 <Kamina> ski: what i understood is that... with existential types the "forall" belonds to the whole type
07:56:46 <ski> yes
07:56:55 <Kamina> ski: while with polymorphic components the "forall" belongs to some component of a type
07:56:58 <Kamina> ski: right?
07:56:59 <ski> yes
07:57:08 <childe> MarcWeber: Yes it's like that.
07:57:22 <Kamina> ski: but i don't understand what changes, if i pull the forall of the component out to belong to the complete type
07:57:26 <ski> and if it "belongs to the whole type", then the *caller* of the constructor may decide the type
07:57:27 <Kamina> ski: so how do things behave differently?
07:57:39 <childe> (apply #'+ '(1 2))
07:57:51 <byorgey> childe: no, that doesn't exist in Haskell, the most important reason why being that lists in Haskell are homegeneous (all elements must be the same type).
07:57:59 <tahir_hh> Can one do in wxHaskell everything that one can do in a wx application written in c++?  And what does it mean for a language to have wx "bindings"?  what does "bind" mean in this context?
07:58:03 <MarcWeber> childe: Have a look at foldr foldl foldr1 etc
07:58:05 <byorgey> it's not really a restriction in practice though.
07:58:12 <ski> Kamina : hm, maybe this is simpler to explain for general functions, first
07:58:30 <ski> Kamina : consider `length :: forall a. ([a] -> Int)'
07:58:35 <childe> Yes I guess so.
07:58:39 <MarcWeber> childe: in this case you can use sum [1,2,3] = 6 = foldr1 (+) [1,2,3] = foldr (+) 0 [1..3]
07:59:03 <Kamina> ski: yes, i would consider that being a polymorphic function without contraints
07:59:12 <ski> Kamina : this means that the *caller* of the function may decide what type `a' should be (e.g. you may want to pass a list of strings, so `String')
07:59:15 <tahir_hh> are "bindings" done by hand?
07:59:44 <ski> Kamina : note that, in this case, this also means that the *calle*, i.e. `length' itself, has to be able to handle any type `a' at all
07:59:55 <ski> s/calle/callee/
07:59:56 <Kamina> ski: yes
08:00:00 <MarcWeber> childe: And you don't need an apply list of args to a function in haskell because you can partially apply functions
08:00:24 <sclv_> ?ty runST
08:00:24 <MarcWeber> say (plus 2) 3 is equal to plus 2 3
08:00:26 <lambdabot> forall a. (forall s. ST s a) -> a
08:00:43 <ski> Kamina : now, logically `length :: forall a. ([a] -> Int)' is more or less the same as `length :: (exists a. [a]) -> Int', though we can't write that in haskell
08:01:12 <cjs_> MarcWeber, do you have a link to anything about nix? I've found a deceased man named Haskell C. Nix, but....
08:01:23 <ski> Kamina : because, length takes a list of type `[a]', for *some* type `a' .. there just has to *exist* some such type, it doesn't care which
08:01:25 <Kamina> ski: the first way of writing means, we have a function for all possible types a
08:01:31 <ski> yes
08:01:40 <Kamina> ski: while the second way means, we have ONE function, accepting a list of any type?
08:01:48 <ski> yes
08:02:03 <Kamina> okay
08:02:05 <ski> do you see that this amounts to the same requirements and possibilities ?
08:02:32 <MarcWeber> cjs_ The server is down till tomorrow. I can only give you a link to my local copy of the paper mawercer.de/phd-thesis.pdf
08:02:54 <sclv_> tahir_hh: bindings are typically done for large projects partially by hand and partially with the help of automation.
08:03:16 <ski> Kamina : so, in the "Foo'" case above, we had `MkFoo :: forall a. (..a..a..) -> Foo'
08:03:29 <MarcWeber> cjs_: Anyway... if you think you'll need another partner.. I could be interested in your business :)
08:03:37 <ski> Kamina : which by this reasoning is the same as `MkFoo :: (exists a. ..a..a..) -> Foo'
08:04:16 <sclv_> wxHaskell has "low level" bindings that provide a thin Haskell wrapper to the wxWidgets library, and a "high level" handwritten API that makes things more natural to work with.
08:04:23 <cjs_> MarcWeber, if you can just e-mail the link to <cjs@starling-software.com>, I'll look at it tomorrow.
08:04:40 <cjs_> MarcWeber, how do you feel about moving to Tokyo. :-)
08:04:47 <Kamina> ski: so... is it right that.. existential types are ONE type, while polymorphic components refer to MANY constructors for every type?
08:04:56 <ski> Kamina : now, otoh, `Bar' above is another kind of beast, it uses *`forall'* (not `exists') inside *argument* types `MkBar :: (forall a. ..a..a..) -> Bar'
08:05:32 <tahir_hh> sclv_: I am wondering if let us say, I wanted a tray icon in windows xp.  Let us say that there was a wx object for it.  would that automatically mean that I could use it within wxHaskell?
08:05:50 <Kamina> ski: i'm a bit confused,  think my ghc uses forall for both existentials and polymorphic components
08:05:56 <Kamina> ski: it doesn't know about exists
08:05:58 <ski> Kamina : existential data types are a single type, which may contain values of differing types .. think `[Widget]'
08:06:19 <ski> Kamina : indeed, i'm using `exists' here to (hopefully) explain better what things mean
08:06:42 <ski> Kamina : you saw how `length :: forall a. ([a] -> Int)' and `length :: (exists a. [a]) -> Int' amounted to the same thing ?
08:07:22 <ski> Kamina : a `forall' wrapped around the whole type (but only used in argument types) amounts to the same as an `exists' used inside the argument type
08:07:24 <Kamina> so...... with polymorphic components you can extract the original types by pattern matching?
08:07:46 <ski> no .. polymorphic components are for a different purpose
08:07:56 <Kamina> for which purpose?
08:08:12 <ski> encapsulating polymorphic values (usually functions)
08:08:49 <ski> existential data types are for heterogenous collections things .. two values of the same existential type can use different internal types
08:09:26 <Kamina> i tried to implement a length function with existentials
08:09:28 <Kamina> and it didn't work
08:09:29 <Kamina> i got:
08:09:30 <ski> polymorphic components are for having arguments which are not of *some* type (that is existential), but which are of *every* type
08:09:34 <ski> i.e. are polymorphic
08:09:54 <ski> `exists' is not a valid haskell keyword
08:10:11 <Kamina> Couldn't match expected type `forall(exists). a. [a]' against inferred type `[a]'
08:10:11 <ski> (it is supported to some degree by jhc)
08:10:17 <Kamina> ski: yes, i wrote forall instead
08:10:18 <ski> right
08:10:27 <kuvkir> hi all
08:10:45 <Kamina> ski: but i don't understand why exists a. [a]   is not the same as [a]
08:10:55 <sclv_> tahir_hh: if the binding is complete, yes. you can look at the documentation for yourself. (and indeed, we see: http://wxhaskell.sourceforge.net/doc/Graphics-UI-WXCore-WxcClassesMZ.html#85)
08:10:57 <lambdabot> http://tinyurl.com/63jwbp
08:11:08 <opqdonut> Kamina: [a] is really forall a. [a]
08:11:18 <opqdonut> which is a stronger promise than exists a. [a]
08:11:46 <tahir_hh> thanks sclv
08:11:50 <ski> Kamina : often people get confused by using `forall' for both existential data types *and* for polymorphic components .. the key point is that `forall' is used in diametrically opposite positions .. so the end result is opposite
08:12:11 <Kamina> and sometimes the forall is even ommitted
08:12:15 <Kamina> so
08:12:16 <Kamina> if i write
08:12:19 <Kamina> forall a. [a]
08:12:21 <kuvkir> i wrote a program in haskell that works with FSM (finite automata). the problem is that computation takes a long time and i want to save the results by using memoization
08:12:21 <Kamina> i mean
08:12:23 <Kamina> exists a. [a]
08:12:26 <Kamina> which is not the same as
08:12:26 <Kamina> [a]
08:12:31 <Kamina> which really is  forall a. [a]
08:12:31 <Kamina> right?
08:12:32 <ski> Kamina : really `[a]' is a type with a free type variable `a' .. just as `foo = \x -> x + y' defines a function with one free variable `y'
08:13:40 <ski> haskell has a convention of, *in*type*signatures*, implicitly `forall'ing every free type variable .. so `length :: [a] -> Int' is interpreted to mean `length :: forall a. ([a] -> Int)' (*not* `length :: (forall a. [a]) -> Int')
08:13:46 <sclv_> kuvkir: http://www.haskell.org/haskellwiki/Memoization
08:13:48 <lambdabot> Title: Memoization - HaskellWiki
08:13:52 <Kamina> [a] is not a type, but denotes a type, depending on a, right?
08:14:16 <Kamina> while exists a. [a]  is a CONCRETE type
08:14:22 <kuvkir> sclv_:  i read this page, but it didn't help.
08:14:27 <ski> just as `x + y' is not a number, unless you give number values for `x' and `y', yes
08:14:29 <sclv_> why not?
08:14:32 <ski> Kamina : yes
08:14:33 <Kamina> and i have to write exists a. [a] as  forall a. [a]
08:14:41 <ski> Kamina : no
08:14:47 <kuvkir> i want to be able to do an automatic memoization without modifying function source code ... is that possible in haskell?
08:14:50 <Kamina> but ghc doesn't have the exists keyword
08:15:03 <sclv_> kuvkir: everything requires modifying source code :-)
08:15:26 <sclv_> oh.. I see -- what's the type of the function you want to memoize
08:15:32 <ski> Kamina : you have to write `(exists a. ..a..a..) -> blah' as `forall a. (..a..a.. -> blah)'
08:15:46 <ski> Kamina : very different from what you said
08:16:05 <EvilTerran> kuvkir, in some circumstances, yes
08:16:06 <Beelsebob> are the semantics of fail in the IO monad to bomb out of the entire program?
08:16:12 <kuvkir> sclv_:  the type is pretty complex , as one of the parameter is takes a DFA data structure...
08:16:26 <EvilTerran> kuvkir, but you need at least an Eq constraint, and preferrably an Ord constraint, on the parameter type
08:16:37 <EvilTerran> (Ix would also work, i think)
08:16:41 <GrayShade> how can i catch a fail from StateT?
08:16:46 <Kamina> ski: ah okay.. the forall outside is really exists
08:16:56 <ski> Kamina : if you want to write `blah -> (exists a. ..a..a..)' .. well then you're out of luck .. there's no (easy) way to get anything like this in haskell
08:17:07 <Beelsebob> or does it just bomb out of the function?
08:17:10 <EvilTerran> GrayShade, you can't directly - you could roll an ErrorT into your monad transformer stack as well
08:17:11 <GrayShade> in a StateT*
08:17:18 <GrayShade> oh
08:17:19 <GrayShade> thank
08:17:19 <GrayShade> s
08:17:44 <Kamina> ski: len2 :: forall a. [a] -> Int   this works
08:17:48 <Kamina> while this works not:
08:17:49 <EvilTerran> Beelsebob, i think it's an exception, if that's what you're wondering
08:17:54 <ski> Kamina : so `exists' in *argument*types* is just the same as `forall' around the *whole* function type
08:18:06 <kuvkir> is there a mailing list i can post my problem to and get some help from guru haskell coders?
08:18:06 <Kamina> ski: len2 :: (forall a. [a]) -> Int
08:18:22 <ski> Kamina : yes, because those two mean radically different things
08:18:28 <Beelsebob> EvilTerran: so if I have something along the lines of main = do ...; someMagic; ... and someMagic calls fail, the proccess will end with the error message, yes?
08:18:30 <Kamina> ski: okay, i understood now the syntactical issues i think
08:18:36 <EvilTerran> Beelsebob, you can probably handle it with Control.Exception.catch
08:18:40 <Beelsebob> cool
08:18:42 <EvilTerran> Beelsebob, but, lacking that, yes
08:18:44 <Beelsebob> I don't want to handle it
08:18:46 <ski> Kamina : `length' says "you'll give me a list of `a's, for any `a' *you* like"
08:18:53 <EvilTerran> ?src IO fail
08:18:53 <Beelsebob> I want a way to bomb out without adding if all over the place
08:18:53 <lambdabot> fail s  = failIO s
08:18:58 <EvilTerran> ?src failIO
08:18:58 <lambdabot> failIO s = ioError (userError s)
08:19:04 <EvilTerran> ?src ioError
08:19:05 <lambdabot> Source not found. It can only be attributed to human error.
08:19:06 <EvilTerran> darn
08:19:13 <Beelsebob> okay, looks hopeful
08:19:13 <ski> Kamina : `len2' says "you'll give me a list of `a's, and it must work for any `a' *I* like"
08:19:28 <EvilTerran> ioError		=  ioException -- hehe
08:19:42 <Beelsebob> :)
08:19:44 <EvilTerran> ioException err =  IO $ raiseIO# (IOException err) -- going further down the rabbit hole
08:19:58 <sclv_> kuvkir: there's a much fancier way to memoize too, but its rather tricky: http://citeseer.ist.psu.edu/peytonjones99stretching.html
08:19:59 <lambdabot> Title: Stretching the storage manager: weak pointers and stable names in Haskell - Jone ...
08:20:24 <ski> Kamina : the only thing you can pass to `len2' (apart from `undefined' things) is the empty list .. it has type `forall a. [a]'
08:20:24 <byorgey> of course, the only value of type  forall a. [a] is []  =)
08:20:42 <kuvkir> sclv_:  thanks for the link, i'll read it :)
08:20:59 <ibid> byorgey: no bottom?
08:21:13 <sclv_> also, the haskell-cafe mailing list is great for discussions like this.
08:21:29 <ski> Kamina : do you see the distinction between `you' and `I', there ?
08:21:32 <Kamina> ski: hmmm.... *beingconfused*
08:21:32 <Kamina> so
08:21:33 <Kamina> yes
08:21:35 <Kamina> but....
08:21:36 <byorgey> ibid: yes, I should have said 'the only non-bottom-involving value of type forall a.[a]'
08:21:37 <ibid> ski: what about a list of bottoms?
08:21:52 <byorgey> there's also undefined, [undefined], [undefined, undefined] ...
08:21:57 <ibid> or list of empty lists?
08:22:00 <GrayShade> @src (<*)
08:22:00 <lambdabot> (<*) = liftA2 const
08:22:01 <ski> Kamina : between who's responsiobility it is to choose the type `a' , an dwho must make sure they can work with any type `a' at all
08:22:07 <EvilTerran> undefined:undefined...
08:22:12 <byorgey> ibid: no, [[], []...]  is not of type  forall a. [a]
08:22:15 <ski> ibid : see "`undefined' things" :)
08:22:26 <Kamina> ski: with existentials it's the callers responsibility to chose
08:22:32 <byorgey> it's of type  forall a. [[a]]
08:22:33 <ski> Kamina : right
08:22:38 <Kamina> ski: and with polymorphic components its the calees responsibility to choose?
08:22:46 <ibid> byorgey: mm, right
08:22:47 <ski> Kamina : right
08:23:06 <Kamina> ski: but when would the callee would like to chose it?
08:23:07 <ski> Kamina : and for a constructor, "callee" really means the function which patter-matches on the constructor
08:23:09 <ibid> ski: see where?
08:23:13 <Kamina> ski: i cannot imagine an example
08:23:18 <GrayShade> @src (*>)
08:23:19 <lambdabot> (*>) = liftA2 (const id)
08:23:37 <ski> ibid : "<ski> Kamina : the only thing ... (apart from `undefined' things) ..."
08:24:34 <sclv_> ?ty runST
08:24:36 <lambdabot> forall a. (forall s. ST s a) -> a
08:24:42 <ski> Kamina : if we didn't have type classes, then we could have a *type* `data Eq a = Eq {eq :: a -> a -> Bool; neq :: a -> a -> Bool}
08:24:45 <ibid> ski: i took that to mean bottom itself, not stuff derived from bottom. my bad.
08:25:36 <ski> Kamina : and then we'd have things like `elem :: Eq a -> a -> [a] -> Bool' .. so the `Eq a' type is a record/dictionary containing the equality and disequality methods for the `Eq' class, so to speak
08:25:50 <ski> Kamina : ok, so far ?
08:26:10 <schme> What is recommended to use for GUI programming with haskell?
08:26:25 <ibid> we still could, i think. and it'd be more flexible than type classes (though istr some type class stuff requires stuff that the h98 typechecker doesn't like)
08:26:41 <Kamina> moment
08:26:43 <ibid> schme: wxhaskell and gtk2hs are the most popular ones, i think
08:27:01 <ski> (Kamina : `elem dict _ [] = False; elem dict a0 (a:as) = (eq dict) a0 a && elem dict a0 as' if you care how it would look to write code like this)
08:27:04 <schme> ibid: Thanks. I'll look into that. Will give me a reason to learn gtk or wx at the same time (:
08:27:13 <ski> @src elem
08:27:13 <lambdabot> elem x    =  any (== x)
08:27:45 <ski> (Kamina : compare with the type-class-ful `elem _ [] = False; elem a0 (a:as) = (==) a0 a && elem a0 as')
08:28:25 <ski> ibid : mm
08:29:14 <Kamina> so.. sorry i have to leave now
08:29:22 <Kamina> i really would like to understand, but i don't have time left
08:29:24 <byorgey> ski: this is actually how type classes are implemented, right?
08:29:35 <ski> byorgey : this is one way to implement them, yes
08:29:41 <ski> Kamina : ok, maybe another time
08:29:43 <Kamina> thanks for your help so far... can you tell me some page, explaining the polymorphic components?
08:29:53 <ski> possibly some wiki page
08:30:37 <ski> http://www.haskell.org/haskellwiki/Existential_type
08:30:37 <lambdabot> Title: Existential type - HaskellWiki
08:30:43 <Kamina> i was looking but didn't find something at once... but maybe we can talk later again
08:30:46 <Kamina> yes
08:30:51 <Kamina> i've seen the thing about the existential type
08:30:57 <Kamina> but not about the polymorphic components
08:32:20 <ski> Kamina : yes .. can't find any direct on polymorphic components atm (not sure if that's an established term, btw)
08:34:09 <ski> hm .. there ought to be a nicer way of explaining this topic
08:34:41 <ski> though, i guess it is several topics, which can often be confused
08:35:11 <LordBrain> Hey dons, nice blog post about strictness analysis and loop fusion. It's been a while since you posted on your blog; I just wanted to let you know you have an audience.
08:35:51 <Bonus> hey guys check this out - this http://hpaste.org/7413 is my solution for this euler problem http://projecteuler.net/index.php?section=problems&id=14
08:35:52 <ski> 0. quantification
08:35:57 <Bonus> i've tried implementing memoizing with arrays
08:36:16 <Bonus> but it still takes a buttload of time and then gives a stack overflow exception
08:36:17 <ski>    a. `forall' around whole type. also `exists' inside function argument types
08:36:25 <Bonus> anyone know what's up?
08:36:36 <ski>    b. `forall' inside function argument types
08:36:47 <EvilTerran> ?type listArray
08:36:48 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
08:36:53 <ski>   c. `exists' outside function argument types
08:37:09 <ski> 1. qunatification interaction with data types
08:37:22 <ski>    a. existential data types
08:37:38 <ski>    b. data types with polymorphic arguments
08:38:02 <EvilTerran> Bonus, the array won't be being memoized, as the binding's within the scope of the parameter "upper"
08:38:26 <EvilTerran> Bonus, because of how you've written it, each time you call (lengths upper), it's making a new array
08:38:32 <Bonus> ah
08:38:37 <Bonus> i thought it was something like that
08:38:41 <Bonus> how do you propose i fix it?
08:39:02 <Bonus> get rid of the parameter and hardcode it?
08:39:17 <Bonus> the parameter is pretty useless since i'm always gonna pass it 999999
08:39:35 <EvilTerran> ?seen hpaste
08:39:35 <lambdabot> I haven't seen hpaste.
08:39:42 <EvilTerran> hm. anyway, i've annotated with a suggestion
08:40:16 <Bonus> ah
08:40:20 <Bonus> so arrays don't get memoized
08:40:22 <ski> Bonus : http://hpaste.org/7413#a3
08:40:24 <Bonus> if they're called with parameters
08:40:30 <LordBrain> dons, i like how you provide the assembly there. One of the draw backs of a highly optimizing high level language is how mysterious the connection between what we write and what the machine sees.
08:40:48 <ski> Bonus : see that annotation for the fix
08:40:49 <EvilTerran> Bonus, no, definitions within the body of a function get re-created every time you call that function
08:41:04 <EvilTerran> ski, beat ya :P
08:41:16 <Bonus> thanks a lot guy! :D
08:41:21 <Bonus> s/guy/guys
08:41:32 <ski> EvilTerran : so you did. congratulations :)
08:42:05 <Bonus> although i'm still a bit confused about what you said about the definitions within the body of a function getting recreated
08:43:27 <ski> Bonus : for a simpler example of basically the same thing :
08:43:36 <ski>   repeat a = a : repeat a
08:43:43 <ski> Bonus : understand that definition ?
08:43:57 <ski> @src repeat
08:43:57 <lambdabot> repeat x = xs where xs = x : xs
08:43:58 <Bonus> yeah
08:44:04 <ski> now compare with that one
08:44:23 <Bonus> hmm
08:44:30 <ski> the former (given a naive implementation) will create as many cons-cells as you look at
08:44:58 <ski> the latter (with reasonable implementations) will only construct one cons-cell, which points to itself
08:45:09 <Bonus> aha
08:45:14 <Bonus> i think i sort of get it
08:45:43 <ski> (compiler optimizations can transform the former to the latter, automatically .. but *not* always, only in "simple enough" cases)
08:45:53 <Bonus> aha
08:46:11 <Bonus> thanks!
08:46:18 <ski> (s/compiler //)
08:48:05 <Bonus> although it's strange i still get the stack overflow
08:48:17 <Bonus> when doing the foldr
08:48:35 <EvilTerran> maybe a foldl' would be in order
08:48:49 <Bonus> hmm let me try it
08:49:18 <chessguy> > map (\n -> 2 * n) [1..5] :: Expr
08:49:20 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
08:49:46 <Bonus> is there a good reason that foldr takes a function as \x acc -> and foldl takes it as \acc x
08:49:57 <opqdonut> yes
08:50:10 <opqdonut> because one does it from the left and the other from the right :)
08:50:22 <Bonus> yeah i kind of thought it was that
08:50:22 <opqdonut> > foldl1 f [x,y,z]
08:50:23 <lambdabot>  f (f x y) z
08:50:25 <chessguy> where "does it" = f
08:50:27 <opqdonut> > foldr1 f [x,y,z]
08:50:28 <lambdabot>  f x (f y z)
08:50:49 <Bonus> hmmm now i'm not getting a stack overflow but it's still taking forever to finish
08:50:52 <Bonus> man oh man
08:52:01 <k474so> hi, i fixed the problem i had before but now i need help with another function
08:52:01 <ski> > foldl f leftmost [x,y,z]
08:52:02 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (Sym a))
08:52:03 <ski>  > foldr f rightmost [x,y,z]
08:52:08 <k474so> http://rafb.net/p/LdtWYq74.html
08:52:09 <lambdabot> Title: Nopaste - Haskell Last genorator must be expression
08:52:10 <ski> bah
08:52:18 <Deewiant> ski: 'leftmost' isn't an Expr.
08:52:21 <k474so> im getting Last generator in do {...} must be an expression
08:52:45 <Deewiant> it needs to be in the range ['a'..'e'] or ['i'..'z'], I think.
08:52:46 <Bonus> just add return ()
08:52:46 <Bonus> ?
08:53:27 <chessguy> @seen sorear
08:53:28 <lambdabot> I haven't seen sorear.
08:53:36 <chessguy> where's that kid at these days?
08:53:47 <Bonus> hmm strange
08:53:54 <Bonus> in that function i have
08:53:55 <Bonus> lengths
08:54:02 <Bonus> if i do lenghts 999999 ! 999999
08:54:05 <Bonus> i get a stack overflow
08:54:21 <Saizan> > var "leftmost" -- ?
08:54:22 <lambdabot>  leftmost
08:54:36 <ski> > var "leftmost" :: Expr  -- see !
08:54:37 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Sym a'
08:54:47 <EvilTerran> error
08:54:53 * ski hides in a corner and sulks
08:55:22 <chessguy> @type var
08:55:24 <lambdabot>     Ambiguous occurrence `var'
08:55:24 <lambdabot>     It could refer to either `SimpleReflect.var', defined at scripts/SimpleReflect.hs:61:0
08:55:24 <lambdabot>                           or `Data.Number.Symbolic.var', imported from Data.Number.Symbolic
08:55:28 <chessguy> d'oh
08:55:28 <Saizan> > [var "leftmost",x]
08:55:28 <lambdabot>  Couldn't match expected type `Sym a' against inferred type `Expr'
08:57:51 <ski> k474so : where does `x' come from ? (also s/onine/online/)
08:58:22 <Bonus> hmm
08:58:45 <Bonus> haha i found where it is
08:58:45 <Bonus> *Main Data.List> lengths 999999 ! 520161
08:58:45 <Bonus> *** Exception: stack overflow
08:58:45 <Bonus> *Main Data.List> lengths 999999 ! 520160
08:58:45 <Bonus> 196
08:58:55 <Bonus> sadly that doesn't help find why it's overflowing
08:58:55 <ski> @type SimpleReflect.var
08:58:56 <lambdabot> String -> Expr
08:59:01 <ski> @type Data.Number.Symbolic.var
08:59:03 <lambdabot> forall a. String -> Sym a
08:59:11 <ski> > SimpleReflect.var "foo"
08:59:12 <lambdabot>   Not in scope: `SimpleReflect.var'
08:59:22 <ski> bah
09:00:45 <ski> k474so : anyway .. probably you either want to use `if x == "1" then ... else if x == "" then ... else ...' or `case () of () | x == "1" -> ... ; x == "" -> ... ; _ -> ...'
09:01:14 <ski> k474so : though in your actual case, you can possibly use `case x of "1" -> ... ; "" -> ... ; _ -> ...', instead
09:01:37 <ski> (or maybe you want to use `readIO')
09:01:58 <ski> @arr
09:01:59 <lambdabot> Aye Aye Cap'n
09:05:31 <pjd_> @pure
09:05:32 <lambdabot> Maybe you meant: more part url
09:05:43 <dons> ?users
09:05:43 <lambdabot> Maximum users seen in #haskell: 460, currently: 437 (95.0%), active: 20 (4.6%)
09:10:00 <byorgey> pjd_: ?
09:10:06 <k474so> thanks ski
09:10:16 <pjd_> :t arr
09:10:18 <lambdabot> Not in scope: `arr'
09:10:30 <ski> @type Control.Arrow.arr
09:10:32 <lambdabot> forall b c (a :: * -> * -> *). (Control.Arrow.Arrow a) => (b -> c) -> a b c
09:10:47 <pjd_> :t Control.Arrow.pure
09:10:47 <ski> @type Control.Arrow.pure
09:10:48 <byorgey> arr creates a 'pure' arrow out of a function
09:10:51 <lambdabot> forall b c (a :: * -> * -> *). (Control.Arrow.Arrow a) => (b -> c) -> a b c
09:10:51 <lambdabot> forall b c (a :: * -> * -> *). (Control.Arrow.Arrow a) => (b -> c) -> a b c
09:11:15 <ski> (`arr' should be in a subclass ..)
09:11:36 <visof>  (prime.factors) 100
09:11:44 <visof> i have an error with this
09:11:50 <byorgey> arr is a synonym of pure, but we still have 'arr' for hysterical raisins, I guess
09:12:24 <visof> ah
09:12:34 <visof> factors 100 produce list
09:12:46 <visof> and prime work on Int
09:12:55 <visof> so we need map , right?
09:12:57 <ski> (map prime . factors) 100
09:13:00 <ski> (filter prime . factors) 100
09:13:05 <visof> okay
09:13:08 <byorgey> map, or filter
09:13:09 <ski> you might want some of those
09:13:09 <visof> thanks ski
09:13:24 <byorgey> > filter even [1..10]
09:13:25 <lambdabot>  [2,4,6,8,10]
09:13:29 <byorgey> > map even [1..10]
09:13:30 <lambdabot>  [False,True,False,True,False,True,False,True,False,True]
09:13:33 <Bonus> man i don't get why this memoization isn't working
09:14:00 <chessguy> @src Eq
09:14:01 <lambdabot> class  Eq a  where
09:14:01 <lambdabot>     (==), (/=)   :: a -> a -> Bool
09:14:18 <Bonus> i give up
09:15:04 <chessguy> > @type \g y -> let f x = if (even x) then (x/2) else (3*x+1) in takeWhile ((/=) 1) $ iterate f x
09:15:04 <lambdabot>  Parse error at "@type" (column 1)
09:15:09 <chessguy> @type \g y -> let f x = if (even x) then (x/2) else (3*x+1) in takeWhile ((/=) 1) $ iterate f x
09:15:12 <lambdabot> forall t t1. t -> t1 -> [Expr]
09:15:13 <Bonus> if a data type is an instance of the monad class
09:15:20 <Bonus> does that guarantee that it obeys the monadic rules?
09:15:24 <ski> no
09:15:30 <pjd_> Bonus: not in Haskell, no
09:15:33 <Bonus> ah
09:15:37 <chessguy> @type \g y -> let next x = if (even x) then (x/2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next x
09:15:40 <lambdabot> forall t t1. t -> t1 -> [Expr]
09:15:50 <Deewiant> instance Monad Foo where return _ = undefined; a >>= b = a + b;
09:15:51 <Bonus> so you could write a data type that is an instance of the monad class, but not really a monad
09:16:00 <ski> e.g. `ListT m' isn't a monad, for `Monad m'
09:16:02 <pjd_> Bonus: (it certainly *should*, of course;  Haskell just doesn't verify it)
09:16:05 <chessguy> @type \y -> let next x = if (even x) then (x/2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next x
09:16:07 <Bonus> yeah
09:16:08 <lambdabot> forall t. t -> [Expr]
09:16:09 <shapr> @users
09:16:09 <lambdabot> Maximum users seen in #haskell: 460, currently: 434 (94.3%), active: 21 (4.8%)
09:16:31 <chessguy> > (\y -> let next x = if (even x) then (x/2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next x) 100
09:16:33 <lambdabot>  [x,3 * x + 1,3 * (3 * x + 1) + 1,3 * (3 * (3 * x + 1) + 1) + 1,3 * (3 * (3 *...
09:16:49 <visof> The prime factors of 13195 are 5, 7, 13 and 29
09:16:57 <pjd_> Bonus: that's true of any type class, of course, not just monads
09:17:05 <Bonus> yeah
09:17:11 <chessguy> > (\y -> let next x = if (even x) then (x/2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next y) 100
09:17:13 <visof> is (map prime . factors) 13195 , did it?
09:17:13 <lambdabot>  Add a type signature
09:17:16 <ski> > product [5,7,13,29]
09:17:18 <lambdabot>  13195
09:17:21 <pjd_> e.g. you can provide Num or Eq instances that do something completely random
09:17:22 <idnar> > 5 * 7 * 13 * 29
09:17:23 <lambdabot>  13195
09:17:29 <chessguy> > (\y -> let next x = if (even x) then (x/2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next y) 100 :: Integer
09:17:31 <lambdabot>  Couldn't match expected type `Integer' against inferred type `[t]'
09:17:39 <idnar> oh
09:17:44 <chessguy> > (\y -> let next x = if (even x) then (x/2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next y) 100 :: [Integer]
09:17:45 <lambdabot>   add an instance declaration for (Fractional Integer)
09:18:02 * chessguy sigh
09:18:04 <ski> x `div` 2
09:18:11 <chessguy> oh, duh
09:18:19 <chessguy> > (\y -> let next x = if (even x) then (x `div` 2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next y) 100 :: [Integer]
09:18:22 <lambdabot>  [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2]
09:18:29 <pjd_> x >> 1
09:18:38 <ski> @hoogle takeUntil
09:18:38 <lambdabot> No matches found
09:18:57 <byorgey> > (\y -> let next x = if (even x) then (x `div` 2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next y) 27 :: [Integer]
09:18:58 <lambdabot>  [27,82,41,124,62,31,94,47,142,71,214,107,322,161,484,242,121,364,182,91,274,...
09:19:30 <ski> > (\y -> let next x = if (even x) then (x `div` 2) else (3*x+1) in takeWhile ((/=) 1) $ iterate next y) (-1) :: [Integer]
09:19:33 <lambdabot>  [-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,-2,-1,...
09:19:44 <Bonus> takeUntil p = takeWhile (not . p)
09:20:08 <chessguy> byorgey, http://en.wikipedia.org/wiki/Collatz_conjecture
09:20:20 <chessguy> seems an interesting problem
09:20:25 <chessguy> anyway, back to work
09:20:31 <byorgey> chessguy: indeed =)
09:20:34 <Bonus> yeah taht's problem 14 from euler http://projecteuler.net/index.php?section=problems&id=14
09:20:36 <lambdabot> Title: Problem 14 - Project Euler
09:20:42 <Bonus> i can't slve it even though it's so freaking simple
09:20:54 <Bonus> i always get stack overflows when accessing big indices in an array
09:21:11 <ski> > showIntAtBase 10 intToDigit 123 ""
09:21:12 <lambdabot>  "123"
09:21:13 <ski> > showIntAtBase (-10) intToDigit 123 ""
09:21:14 <lambdabot>  "Exception: Numeric.showIntAtBase: applied to unsupported base -10
09:21:17 <ski> bah!
09:21:31 <ski> negative bases are fun
09:21:44 <pjd_> Bonus: are you using an array or a list?
09:21:45 <Deewiant> Bonus: you might want to use a version of (!!) which seq's values as it goes.
09:21:47 <EvilTerran> > iterate (*(-10)) 1
09:21:48 <lambdabot>  [1,-10,100,-1000,10000,-100000,1000000,-10000000,100000000,-1000000000,10000...
09:22:00 <Bonus> i'm using an array
09:22:06 <Bonus> here's the code im using
09:22:06 <Bonus> http://hpaste.org/7413
09:22:18 <Bonus> evilterran and ski made annotations
09:22:22 <Bonus> but they don't work either
09:22:23 <Bonus> : (
09:22:43 * EvilTerran tries to work out if that would actually provide complete and unique representation of the natural numbers
09:23:19 <EvilTerran> or indeed the integers... i *think* it does
09:24:11 <pjd_> EvilTerran: representation?
09:24:16 <EvilTerran> 10_{10} would be 190_{-10}
09:24:44 <EvilTerran> pjd_, writing things in base -10
09:25:07 <byorgey> EvilTerran: yeah, I think that works for any base
09:25:14 <EvilTerran> crazy
09:25:24 <ski> byorgey : not (-1),0,1
09:25:24 <pjd_> EvilTerran: oh, i thought you were talking about the Collatz sequence
09:25:37 <EvilTerran> ... i bet someone's come up with a use for negative bases
09:25:45 <byorgey> well, I *obviously* meant 'non-trivial bases'  ;)
09:26:00 <opqdonut> trancendental bases are interesting
09:26:01 <pjd_> http://en.wikipedia.org/wiki/Negative_base
09:26:01 <lambdabot> Title: Negative base - Wikipedia, the free encyclopedia
09:26:07 <ski> > iterate (*pi) 1
09:26:09 <lambdabot>  [1.0,3.141592653589793,9.869604401089358,31.006276680299816,97.4090910340024...
09:26:11 <byorgey> EvilTerran: Don Knuth famously wrote about base (-2) in high school =)
09:26:33 <EvilTerran> he did? awesome
09:26:51 <Deewiant> wasn't it base (-2i)
09:26:56 <ski> Bonus : what if `cNext x' is out-of-bounds for the array ?
09:27:04 <jaj> is there any way to optimise this: http://hpaste.org/7419? It just went out of memory with "+RTS -K83886080" while it had allocated half of my 3GB of swap...
09:27:17 <Bonus> hmm
09:27:26 <Bonus> that's not supposed to happen i think
09:27:35 <MathHat> :) probably not.
09:27:40 <Bonus> or wait hmm
09:27:48 <mrd> 4 million stack frames is a bit excessive
09:28:15 <Bonus> because i check if cNext x < x
09:28:19 <EvilTerran> ?hoogle even
09:28:19 <lambdabot> Prelude.even :: Integral a => a -> Bool
09:28:19 <lambdabot> GHC.Conc.ConsoleEvent :: data ConsoleEvent
09:28:19 <lambdabot> GHC.ConsoleHandler.ConsoleEvent :: data ConsoleEvent
09:28:46 <Bonus> and x is always within bounds for the array
09:28:50 <EvilTerran> > fix (zipWith (+) <*> tail)
09:29:05 <pjd_> jaj: you can simplify that list comprehension to zipWith (+) fibs (tail fibs)
09:29:06 <lambdabot>  thread killed
09:29:06 <EvilTerran> ...
09:29:07 <Deewiant> EvilTerran: needs initial values. :-)
09:29:14 <ski> Bonus : oh, right (for some reason the branches flipped in my mind :)
09:29:24 <EvilTerran> > fix ((zipWith (+) <*> tail) . (1:) . (1:))
09:29:25 <lambdabot>  [2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,...
09:29:29 <byorgey> Deewiant: oh, maybe it was (-2i), I don't know
09:29:32 <EvilTerran> > map even $ fix ((zipWith (+) <*> tail) . (1:) . (1:))
09:29:34 <lambdabot>  [True,False,False,True,False,False,True,False,False,True,False,False,True,Fa...
09:29:36 <Deewiant> > fix ((0:)<$>(1:)<$>zipWith (+)<*>tail)
09:29:37 <lambdabot>  Couldn't match expected type `a1 -> a' against inferred type `[t]'
09:29:41 <EvilTerran> jaj, notice anything?
09:29:43 <Deewiant> d'oh
09:30:28 <jaj> EvilTerran: seems to be periodical
09:30:37 <EvilTerran> indeed
09:30:47 <EvilTerran> ?oeis 2 8 34 144
09:30:48 <lambdabot> Even Fibonacci numbers; or, Fibonacci_{3k}.
09:30:48 <lambdabot> [0,2,8,34,144,610,2584,10946,46368,196418,832040,3524578,14930352,63245986,26...
09:31:14 <byorgey> jaj: also, are you sure you want  take (4 * 10^6), or do you want  takeWhile (< (4*10^6)) ?
09:31:19 <mrd> i think the latter
09:31:19 <ski> > fix ((0:)<$>((1:)<$>(zipWith (+)<*>tail)))
09:31:22 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:31:22 <byorgey> 4 million is a lot of Fibonacci numbers.
09:31:25 <EvilTerran> http://www.research.att.com/~njas/sequences/A014445
09:31:29 <lambdabot> Title: id:A014445 - OEIS Search Results
09:32:12 <jaj> byorgey: what does takeWhile do?
09:32:23 <EvilTerran> of particular note is "a(n) = 4*a(n-1) + a(n-2); a(-1) = 2, a(0) = 0"
09:32:28 <tromp> > let f=0:scanl 1 f in f
09:32:28 <mrd> takes, while condition is true
09:32:29 <lambdabot>  Couldn't match expected type `[t]'
09:32:30 <Bonus> > takeWhile (< 5) [1..]
09:32:32 <lambdabot>  [1,2,3,4]
09:32:42 <MathHat> pow!
09:32:45 <EvilTerran> wb niven
09:32:49 <tromp> > let f=0:scanl(+)1 f in f
09:32:51 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:33:05 <aasdfas> anyone here uses paltalk or recommend using paltalk? what about skype? are they trying to screw up my speaking skills?
09:33:06 <EvilTerran> > fix ((0:) . scanl (+) 1)
09:33:06 <mrd> > fix $ \f -> 0:scanl(+)1 f
09:33:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:33:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:33:12 <mrd> har
09:33:17 <EvilTerran> har de har
09:33:26 <EvilTerran> mine is more pointless :P
09:33:33 <mrd> you win the pointless contest
09:33:40 <aasdfas> anyone here uses paltalk or recommend using paltalk? what about skype? are they trying to screw up my speaking skills?
09:33:42 <EvilTerran> I'm the #1 guy!
09:33:44 <byorgey> > let fibs = 0:1:zipWith (+) fibs (tail fibs)  in  take 20 fibs   -- jaj, this takes the first 20 fibonacci numbers...
09:33:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
09:33:58 <EvilTerran> ?where ops
09:33:59 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
09:34:03 <byorgey> > let fibs = 0:1:zipWith (+) fibs (tail fibs)  in  takeWhile (<20) fibs   -- ... while this only takes ones which are less than 20
09:34:04 <lambdabot>  [0,1,1,2,3,5,8,13]
09:34:13 <ski> EvilTerran : ?
09:34:17 <jaj> byorgey: indeed, I want takeWhile... how stupid of me
09:34:21 <EvilTerran> aasdfas, no need to repeat yourself
09:34:31 <byorgey> jaj: ok, I thought so =)
09:34:46 <jaj> 4e6 fibonacci number is really a lot...
09:34:55 <byorgey> > let phi = (1 + sqrt 5)/2  in  phi^(4*10^6) / sqrt 5
09:34:56 <lambdabot>  Infinity
09:35:12 <byorgey> jaj: yes, it's huge!
09:35:21 <byorgey> it's bigger than DOUBLE_MAX, as you can see...
09:36:16 <tromp> of course, doubles dont have exponents in the milions...
09:36:18 <EvilTerran> aasdfas, also, that's completely off-topic
09:36:48 <ski> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  fibs !! (4*10^6)
09:36:50 <lambdabot> Terminated
09:36:51 <ski> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  fibs !! (4*10^6)  :: Rational
09:36:54 <lambdabot> Terminated
09:36:56 <ski> bah
09:37:39 <Deewiant> heh
09:37:45 <byorgey> I suppose it should be possible to calculate the 4-millionth fibonacci number.  It's got less than 4 million digits.
09:37:49 <Deewiant> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  fibs !! (10^6)
09:37:51 <lambdabot> Terminated
09:37:56 <Deewiant> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  fibs !! (10^5)
09:37:58 <lambdabot> Terminated
09:38:05 <Deewiant> you've got a long way to go :-)
09:38:23 <byorgey> > let phi = (1 + sqrt 5)/2  in  (4*10^6 * log phi - log (sqrt 5))/log 10
09:38:24 <lambdabot>  835950.2115149128
09:38:35 <byorgey> see, only 835950 digits!
09:38:44 <jaj> peanuts :)
09:38:59 <ski> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  fibs !! (4*10^5)  :: Rational
09:39:01 <lambdabot> Terminated
09:39:03 <ski> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  fibs !! (4*10^4)  :: Rational
09:39:06 <lambdabot>  1432600165457807343833735095090282537486869471812930196955973309340677668252...
09:39:16 <ski> <lambdabot>  out of memory (requested 1048576 bytes)
09:40:59 <byorgey> why :: Rational?
09:41:38 <Deewiant> > 5 :: Rational
09:41:40 <lambdabot>  5%1
09:42:00 <pjd_> > pi :: Rational
09:42:01 <lambdabot>   add an instance declaration for (Floating Rational)
09:42:01 <lambdabot>     In the expression: ...
09:42:20 <czakey> > 4 :: Rational
09:42:21 <lambdabot>  4%1
09:42:32 <Syzygy-> > 6%3
09:42:33 <lambdabot>  2%1
09:42:39 <Deewiant> > realToFrac pi :: Rational
09:42:39 <pjd_> hmm, pi floater
09:42:40 <lambdabot>  884279719003555%281474976710656
09:43:36 <byorgey> > let root = fromIntegral; beer = 3 in root beer :: Float
09:43:37 <lambdabot>  3.0
09:44:11 <MathHat> hyar har.
09:44:59 <ski> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  fibs !! (4*10^4)  :: Double
09:45:00 <lambdabot>  Infinity
09:45:05 <ski> byorgey : ^ therefore
09:45:13 <Deewiant> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  fibs !! (4*10^4)
09:45:15 <lambdabot>  1432600165457807343833735095090282537486869471812930196955973309340677668252...
09:45:19 <Deewiant> ski: ^ therefore not
09:45:31 <byorgey> ski: why not :: Integer ?
09:45:44 <Deewiant> it's Integer by default, that's why. :-P
09:45:45 <ski> um
09:45:54 <ski> ah
09:46:08 <byorgey> > let fibs = 0:1:zipWith (+) fibs (tail fibs); (a:_) !! 0 = a; (a:as) !! n = a `seq` (as !! (n-1))  in  length . show $ fibs !! (4*10^4)
09:46:09 <lambdabot>  8360
09:46:29 <ski> for some reason i was thinking this was non-integral (probably since i just before was thinking about collatz or something, which used `x / 2')
09:46:51 <ddarius> Even Collatz is still integral
09:46:55 <Deewiant> > let phi = (1 + sqrt 5) / 2 in round$ (4*10^4 * log phi - log$sqrt 5) / log 10
09:46:57 <lambdabot>   add an instance declaration for (Floating (a -> a))
09:47:09 <Deewiant> > let phi = (1 + sqrt 5) / 2 in round$ (4*10^4 * log phi - log(sqrt 5)) / log 10
09:47:10 <ski> yes, but the formulation above used `(/)' ..
09:47:11 <lambdabot>  8359
09:47:40 <MathHat> integral: doesn't your nick filter drive you nuts?
09:47:57 <tromp> you can compute 4millionth fib easily by repeated squaring of 2x2 [[0,1],[1,1]] matrix
09:48:22 <opqdonut> tromp: actually you can store just the diagonal iirc
09:48:35 <tromp> yes, 2 entries suffice
09:48:50 <ddarius> opqdonut: Indeed.  It can be diagonalized and then you only need to exponentiate a diagonal matrix
09:48:52 <opqdonut> i think the nicest solution is implementing Z[sqrt(5)] arithmetic
09:49:07 <opqdonut> and then using repeated squarings
09:49:14 <ddarius> opqdonut: Easy enough to do in Haskell.
09:49:14 <tromp> since any power of the matrix looks like [[a,b],[b,a+b]]
09:49:24 <opqdonut> mhmm
09:49:47 <mrd> you can parallelize it that way too
09:50:43 <byorgey> yes, diagonalizing that matrix results in a diagonal matrix with nonzero entries phi, -phi =)
09:50:49 <ski> adjoin_sqrt :: Num a => a -> exists x. Num x  -- ?
09:50:55 <byorgey> which is where the Z[sqrt(5)] arithmetic comes in.
09:51:14 <ski> (or something of that sort ..)
09:51:38 <opqdonut> just repeatedly squaring the matrix requires only normal integer arithmetic
09:51:41 <opqdonut> so it's kinda elegant
09:51:51 <ddarius> ski: I would, for this particular case, simply use a pair of numbers...
09:52:12 <MathHat> opqdonut: so do most zip-based implementations
09:52:12 <ski> i suppose
09:52:28 <ddarius> As do the recursive implementations.
09:52:30 <opqdonut> MathHat: yeah but they're O(n) instead of O(log n)
09:52:55 <MathHat> right.
09:54:05 <MathHat> except when integers become just as expensive to multiply as to add many times
09:54:51 <ddarius> MathHat: When does that happen?
09:54:59 <MathHat> when they're huge?
09:55:44 <funktio> http://www.speedsolving.com/showpost.php?p=49747&postcount=1
09:55:48 <funktio> asdfagfadfsgf
09:55:54 <funktio> oops, wrong channel, sorry
09:56:01 <ddarius> MathHat: There are O(n log n) methods of multiplying integers which is better than O(n^2) by repeated addition.
09:57:18 <MathHat> okay, so it's O(n log n) vs. O(n^2) instead of O(log n) vs. O(n).
09:57:52 <Deewiant> multiplying integers is a bit slower than O(n log n), the next-best known is O(n log n log log n).
09:59:08 <Botje_> @pl \x y -> f [x,y]
09:59:08 <lambdabot> (f .) . (. return) . (:)
09:59:49 <Deewiant> @pl \x y -> [x,y]
09:59:50 <lambdabot> (. return) . (:)
10:03:27 <allbery_b> still need an op?
10:12:50 <MathHat> well, I got the 4e6th fib number, and my tty buffer couldn't hold it all.
10:16:26 <nejucomo> When pattern matching against a specific constructor, must I deconstruct the components, or can I somehow specifify the object as a single name?
10:16:51 <nejucomo> For example, I have:
10:17:01 <nejucomo> data Thingy = Foo a b c | Bar x y z
10:17:05 <Deewiant> yes, you can specify it as a single name
10:17:06 <nejucomo> and I want a function like:
10:17:19 <opqdonut> do you mean "f x@(Foo _ _ _) = g x"
10:17:25 <nejucomo> f (Foo a b c) = g (Foo a b c)
10:17:29 <opqdonut> yes
10:17:29 <Deewiant> or just f x = g x.
10:17:36 <nejucomo> f (Bar x y z) = h2 (Bar x y z)
10:17:40 <Deewiant> f = h2
10:17:44 <ziman> nejucomo, you can use the `as' syntax: func foo@(Foo _ _ _) = func' foo
10:17:51 <mauke> nejucomo: try f x@(Foo {}) = ...
10:17:51 <opqdonut> nejucomo: you can use @ to name matched components
10:18:36 <Deewiant> f x@(Foo{}) = g x; f x@(Bar{}) = h2 x
10:18:49 <nejucomo> Cool, thanks.
10:20:49 <nejucomo> Also, I could not figure out how to specify a type, but when I left it out, the inference did the right thing.
10:21:13 --- mode: ChanServ set +o shapr
10:21:16 --- kick: aasdfas was kicked by shapr (Kicked by shapr)
10:21:19 <nejucomo> I have a parameterized type: data Foo a b = FooConstructor (- ... stuff related to a and b ... -)
10:22:02 <nejucomo> and I want a function which takes a "Foo a b" (for any a and b) and an "a" of the same type used by the Foo, and then returns a "b" of the same type.
10:22:09 <nejucomo> But this didn't seem to work:
10:22:19 <nejucomo> f :: (Foo a b) -> a -> b
10:22:31 <mauke> that should work
10:22:35 <mauke> is it a local function?
10:22:39 <nejucomo> Hmm...  Maybe I forgot the parens.
10:22:44 * nejucomo tries again.
10:22:49 <mauke> no, f :: Foo a b -> a -> b is fine
10:23:06 --- mode: ChanServ set -o shapr
10:23:17 <pjd_> nejucomo: the definition has to actually implement that type, of coures
10:23:22 <pjd_> course, even
10:23:27 <mauke> :t let f (x, y) z = x `asTypeOf` z `seq` y in f
10:23:33 <lambdabot> forall t t1. (t, t1) -> t -> t1
10:23:53 <mauke> :t let f :: (,) a b -> a -> b; f (x, y) z = x `asTypeOf` z `seq` y in f
10:23:54 <lambdabot> forall a b. (a, b) -> a -> b
10:26:34 <byorgey> type_inference++
10:26:50 <mauke> (type inference)++
10:26:58 <cpoucet> @karma (type inference)
10:26:59 <lambdabot> (type has a karma of 0
10:27:10 <ski> @type inference
10:27:11 <lambdabot> Not in scope: `inference'
10:27:35 <mauke> preflex_: karma type inference
10:27:36 -preflex_(n=preflex@d83-181-90-215.cust.tele2.de)- karma for type inference: 1
10:31:26 <Twey> type-inference++
10:32:04 <mauke> please, this is haskell: typeInference!
10:32:28 <ski> type Inference = ...
10:32:41 <mauke> type Inference = Awesome
10:33:53 <mrd> type Inference = ____ fill in the blank
10:34:01 <mrd> that's the point
10:39:54 <ktne> hello
10:40:19 <ktne> anyone here using haskell mode for emacs? how do i send a text selection to the interpreter?
10:40:19 <paolino> hi
10:41:14 <conal> ktne: i use haskell mode, and i haven't seen that functionality.  maybe it's missing.
10:41:31 <ktne> so i basically have to type everything in the interpreter?
10:41:38 <ktne> *retype
10:42:01 <Deewiant> save it into a file and just load the file in the interpreter?
10:42:03 <ktne> this is odd since it's such a basic feature in other modes
10:42:20 <ktne> Deewiant yes that is possible but i wanted a more interactive mode
10:43:32 <maltem> ktne, the reason may be that you typically want to load a Haskell module as a whole anyway
10:44:16 <ktne> maltem yes but i want to do incremental development
10:44:20 <ktne> isn't that possible in haskell?
10:44:28 <conal> ktne: more specifically?
10:44:32 <ktne> write one function at a time, then test it and so on
10:44:43 <conal> ktne: definitely.
10:44:59 <ktne> is it possible to undefine a function in haskell?
10:45:15 <ktne> ghci more precise
10:45:35 <mauke> not really
10:45:40 <ktne> oh
10:45:43 <ktne> that's bad
10:45:43 <sclv_> ?seen kuvkir
10:45:43 <conal> ktne: why would you want to? (there may be another solution)
10:45:43 <lambdabot> I saw kuvkir leaving #haskell 1h 10m 34s ago, and .
10:45:53 <ktne> conal prototyping
10:46:07 <maltem> ktne: Why undefine a good, nice, pretty function?
10:46:19 <MathHat> there's :undef for things you've defined in the interpreter
10:46:20 <mauke> why do you need to undefine functions for that?
10:46:37 <MathHat> wait, that's different...
10:46:41 <ktne> maltem because i don't have the right function from the first trial
10:46:54 <mauke> so change it and :r
10:46:55 <maltem> ktne, then just correct the definition, and reload
10:46:57 <conal> ktne: are you typing function definitions right into ghci?
10:47:07 <conal> ktne: if not, then what mauke said.
10:47:32 <conal> ktne: especially convenient in haskell-mode.  edit your code and do \C-c\C-r
10:47:44 <ktne> conal i want to do like in ocaml, edit the source in the file buffer then send it to the interpreter
10:48:05 <conal> ktne: \C-c\C-r
10:48:06 <ktne> \C-c\C-r undefined
10:48:11 <jaj> :)
10:48:38 <ktne> that's the feature i'm looking for but it's not implemented in haskell mode it seems :)
10:48:55 <conal> ktne: are you in Haskell mode and C-c C-r is unbound?
10:49:18 <ktne> yes
10:49:45 <sclv_> you need inferior-haskell set up right in your haskell mode configs.
10:49:52 <Saizan> it's C-c C-l, no?
10:50:15 <conal> ktne: oh!  my private binding apparently: (local-set-key "\C-c\C-r" '(lambda () (interactive) (inferior-haskell-load-file t)))
10:50:35 <conal> ktne: or use C-c C-l
10:51:12 * conal wishes emacs lisp had real closures.
10:51:15 <ktne> conal but i don't want to load a file
10:51:23 <mauke> yes, you do
10:51:29 <nejucomo> So ghc --make is pretty nice, but I still ended up writing a Makefile to implement "make clean" and "make test".  Is there a haskellish way to do this stuff?
10:51:31 <ktne> i want to load only the selected region
10:51:35 <mauke> no, you don't
10:51:39 <ktne> yes i do
10:51:44 <ktne> i know very well what i want :)
10:51:47 <mauke> that doesn't even make sense
10:51:48 <maltem> nejucomo, if it's a full-blown project, use Cabal
10:51:52 <ktne> i'm used to this style of development
10:51:59 <conal> ktne: i see, and i agree that you want what you want.
10:52:02 <ktne> where i define a function and refine it in the source code
10:52:05 <maltem> nejucomo, otherwise, you may use Cabal, too
10:52:23 <conal> ktne: you could write some elisp code to do that.
10:52:25 <ktne> if i load the whole file then i can't hold multiple versions of the same function
10:52:35 <conal> oh!
10:52:47 <ktne> also if i load the whole file then won't i lose the program state?
10:52:57 <conal> ktne: what's program state?
10:53:02 <ktne> variables
10:53:10 <conal> we don't have variables
10:53:13 <maltem> ktne, that last one is where you have a point
10:53:15 <nejucomo> Ah, even though I refactored my code by introducting a parameterized type, I've run into the same kind of type inference error which I don't understand:
10:53:27 <maltem> conal, he thinks of let bindings in ghci, I guess
10:53:34 <conal> maltem: maybe so
10:53:44 <maltem> (or she, actually)
10:53:49 <nejucomo> f :: String -> Foo a b
10:54:11 <ktne> maltem yes
10:54:11 <conal> ktne: i think you can do what you want with some elisp code.
10:54:17 <nejucomo> f "blah" = make_a_foo ...
10:54:27 <conal> ktne: and you won't have to undefine.  new defs will shadow old
10:54:29 <nejucomo> make_a_foo :: Foo Int String
10:54:43 <mauke> nejucomo: that can't work
10:54:55 <nejucomo> Couldn't match expected type `a' (a rigid variable) against inferred type `Int'.
10:55:11 <mauke> right
10:55:18 <Deewiant> nejucomo: you're saying that f returns any type of Foo (Foo a b) when what it does is it makes a Foo Int String
10:55:38 <Deewiant> so GHC complains that 'Int' doesn't match 'any type' ('a').
10:55:41 <conal> ktne: so, go for it.  and if you come up with some elisp code you like, send it to stefan m.
10:55:43 <nejucomo> Ah...  The type can't be determined by the arguments at runtime.  Doh!
10:55:55 <maltem> nejucomo, the type sig for f says that a and b must be generic
10:56:03 <maltem> right
10:56:17 <ktne> conal so there is no problem with shadowing? i thought i might get some error
10:56:29 <nejucomo> So I have several different instances of Foo a b for concrete types and I want to select among them at runtime.
10:56:37 <nejucomo> What's the way to do this?
10:56:47 <conal> ktne: at most a warning, depending on flags
10:56:59 <maltem> nejucomo, maybe type classes?
10:57:07 <conal> ktne: though i haven't tried what i'm suggesting
10:57:48 <conal> ktne: i just tried shadowing a def in ghci.  no problem.
10:58:09 <ktne> conal ok, thanks, i'll try to get some code from ocaml mode, i hope it works since i don't know elisp :)
10:58:20 <sclv_> ktne: be warned though, shadowing might not do what you want.
10:58:25 <nejucomo> maltem: I'm not sure how type classes could address this issue?
10:58:30 <sclv_> if you have foo x y = bar y x
10:58:34 <sclv_> and then you shadow bar
10:58:39 <sclv_> foo will still refer to the old bar.
10:58:41 <ktne> ah
10:58:42 <ktne> oh
10:58:46 <ktne> not what i want indeed
10:58:50 <conal> ktne: doesn't ml do the same?
10:59:02 <ktne> no
10:59:03 <conal> ktne: as opposed to lisp?
10:59:07 <conal> oh, oops.
10:59:25 <ktne> well i guess then i have no usage for this
10:59:28 <conal> then i don't think haskell & ghci work the way you want.
10:59:36 <ktne> too bad since it was such a good development methodology
10:59:57 <sclv_> the reload style works just fine for folks though -- if you want some temporary bindings, throw those in your .hs file too...
11:00:27 <ktne> is it possible to save variables?
11:00:33 <conal> sclv_: though ktne wants multiple conflicting defs in a single file
11:00:34 <ktne> some easy way to save state?
11:00:52 <ktne> conal well not all are in usage since only the last one send to the interpreter is visible
11:01:05 <ktne> i need some easy way to save state so that i can handle large data
11:01:13 <ktne> i can't afford to recompute it each time
11:01:29 <sclv_> oh dear. that's a real problem. :-(
11:01:44 <ktne> :(
11:02:06 <sclv_> if you have one data set and know you'll need it for a while, you could always serialize it to a file, and just load that file...
11:02:09 <conal> yeah.  bummer, ktne. :(
11:02:28 <conal> CAFs (top-level defined values) get reset when you reload in ghci
11:02:40 <conal> not what you want
11:02:42 <ktne> sclv_ i have multiple data sets since i debug different parts at the same time
11:03:22 <ktne> i could define a data1, data2, data3, data4, etc
11:03:43 <ktne> oh
11:03:46 <sclv_> yeah, that seems reasonable. if your data is expensive to compute, serializing with read/show should be a win generally.
11:03:50 <ktne> can't since the function will just access 'data'
11:04:08 <ktne> and since you can't really shadow stuff because it's still linked to old data you can't really use data1, data2, data3
11:04:10 <conal> or serializing with Binary, which would be much more efficient.
11:04:13 <ktne> unless i send the data as parameter
11:04:25 <ktne> but that would mean to add one extra parameter to all functions
11:04:29 <sclv_> ktne -- that's a good idea anyway, reduces dependencies!
11:04:38 <ktne> well, maybe
11:04:47 <ktne> hmm
11:04:51 <ktne> good idea indeed :)
11:05:01 <sclv_> the haskell way is functions should know as little as they can about anything else going on.
11:05:19 <ktne> yes but there still is the problem of old unshadowed functions
11:05:52 <maltem> nejucomo, with type classes you can specify that a function may have any specific type T -> U, with only the condition that those types be in some class
11:06:07 <conal> book title: "The Way of the Haskeller"
11:06:14 <sclv_> right -- but if you serialize yr. data (and maybe even write a little loader function for it) then you should be aboue to use edit-and-reload style just fine?
11:06:36 <sclv_> "Lambda's Progress"
11:06:37 <maltem> nejucomo, instance declarations are how you specify what those types can be, and what the specific implementations are
11:06:58 <ktne> sclv yes but then i'll have to reload all data after each function modification
11:07:08 <ktne> which is not a good idea if the dataset is large
11:07:45 <ktne> but i guess i don't have an option, at least it's not much worse than c++ :)
11:07:52 <ktne> at least i have an interactive shell :)
11:08:16 <sclv_> hmm... compute yr. data set, and place it in a seperate module... then compile it and include it in yr. working file?
11:08:29 <ktne> hmm
11:08:32 <ktne> that's a clever idea :)
11:08:40 <ktne> but then, how do i update that?
11:09:03 <conal> ktne: i think the problem here is that ghci lacks sophisticated dependency tracking.
11:09:03 <ktne> is it possible to write a module from the data? some save-all function?
11:09:34 <ktne> save-symbols-to-module [symbols list...]
11:09:46 <Saizan> nothing like that, no
11:09:50 <ktne> like save-symbols-to-module [data1, data2, data3]
11:10:02 <conal> ktne: "symbols"?
11:10:09 <ktne> conal the defined stuff
11:10:23 <ktne> conal the top level defined stuff
11:10:32 <sclv_> ktne: if your data is an instance of show with the default instances, its "show" instance is runnable code to create it.
11:11:03 <ktne> sclv_ what that really means? it's above my knowledge level :)
11:11:08 <conal> ktne: maybe writeModule :: FileName -> [(String, Dynamic)] -> IO ()
11:11:43 <sclv_> > show [Just 4, Nothing, Just 23.0]
11:11:45 <lambdabot>  "[Just 4.0,Nothing,Just 23.0]"
11:12:00 <ktne> show 2+3
11:12:01 <sclv_> see -- you could paste the show instance right into ghci or a source file...
11:12:04 <ktne> > show 2+3
11:12:05 <lambdabot>   add an instance declaration for (Num String)
11:12:18 <conal> though lists are homogenous
11:12:18 <sclv_> > show (2+3)
11:12:20 <conal> (as in ml)
11:12:20 <lambdabot>  "5"
11:12:35 <ktne> but the dataset cannot be serialized to strings since it's a graph
11:12:35 <sclv_> ^^ you need to get precedence right.
11:12:39 <ktne> a large graph
11:12:46 <conal> so Dynamic might help.  and you'd have to include the names you want to use in the module.
11:13:03 <sclv_> is it a directed graph, or does it contain cycles?
11:13:15 <ktne> it contains cycles
11:13:19 <conal> does Binary handle graphs (either generally or acyclic)?
11:13:53 <conal> i don't think a haskell library *could* observe sharing
11:14:02 <conal> though the haskell RTS could
11:14:07 <ktne> i'm surprised that nobody ran into this sort of issues so far :)
11:14:16 <conal> unless of course you use refs or some such for explcit sharing
11:14:20 <ktne> i mean, nobody used haskell to do any sort of processing on a reasonably large graph? :)
11:14:43 <conal> ktne: maybe.  you could ask on haskell-cafe
11:14:48 <ktne> ok, thanks
11:15:07 <ktne> oh, it's not an irc channel :)
11:15:17 <conal> ktne: i'm curious as well.  i like the questions you're asking!
11:15:19 <ktne> ok, cya, thanks for help to everyone :)
11:15:34 <conal> take care, ktne
11:15:36 <ktne> conal i'll come back when i'll have this solved :)
11:15:57 <conal> ktne:  i do hope you post on haskell-cafe.   then everyone will get to see the issue.
11:16:12 <ktne> i'll post tommorow i really must fly now :)
11:16:14 <conal> ktne: and you'll likely get more help there than here.
11:16:58 <cjs_> Thoughts on http://hpaste.org/7422 (given that I've not yet read Ron Jeffries' Haskell critiques, or the responses)?
11:18:38 <dons> cjs_: oh, Ron's thing about recursion being bad?
11:19:09 <cjs_> I only know about that from the title.
11:20:53 <cjs_> The interesting thing was, once I actually read the rules of the game (which I keep forgetting, despite having done this problem twice before in OO languages), I instantly started to think that the whole "sequence of rolls" direction he starts off with was wrong, and wanted to head towards a (data Frame = Strike | Spare n | ...) kind thing.
11:21:10 <dons> yeah, a data type makes a lot more sense
11:21:24 <cjs_> Which is starting to seem to me, really, the true power of Haskell.
11:21:26 <dons> than encoding it in some slopppy integer thing
11:21:35 <tahir_hh> Hi, this afternoon I was looking at wxHaskell and I am wondering how to go about using the documentation.  I managed to get a text box on the application drawn but I got to that stage by skimming a research paper.  Any ideas?
11:21:37 <dons> right. data types matching exactly the domain are *cheap*
11:21:55 <dons> tahir_hh: hmm, the wxHaskell site should have more docs, i think
11:22:14 <cjs_> Mmmm, that's a very good way of putting it.
11:22:26 <tahir_hh> dons: but it does not tell me *how* to read the documentation
11:23:12 <cpoucet> dons: hey
11:23:20 <cpoucet> dons: I already found a new person to lure into haskell :)
11:23:21 <cjs_> Also, I found it interesting that my tests worked out a lot more cleanly than his did, for the usual Haskell reasons.
11:23:47 <conal> cpoucet: when you do move to zurich?
11:23:53 <cpoucet> conal: I'm here :)
11:23:56 <cpoucet> conal: todady was my first day
11:24:13 <cjs_> And I was pretty severly disappointed at how crap his Smalltalk solution looks after my Haskell one. Especially since Smalltalk used to be my favourite language.
11:24:13 <conal> cpoucet: hey.  congrats!!
11:24:21 <cpoucet> conal: thans !
11:24:25 <nejucomo> maltem: Thanks for the type class description.  I think I have a handle on them, but I don't think they help with my issue.
11:24:27 <conal> cpoucet: and you're already proselytizing haskell?
11:24:34 <cpoucet> conal: yeah, to one of the other nooglers :)
11:24:37 <cjs_> cpoucet: Which bank are you with? :-)
11:24:51 <conal> cpoucet: awesome.  spread the virus!
11:24:55 <nejucomo> I've defined a parameterized type which contains functions that translate the parameterized types to and from strings.
11:24:57 <cpoucet> conal: also told him about hte user-gruouop I'm staring upin here
11:25:02 <dons> conal: not a bank, a search engine company
11:25:06 <cpoucet> cjs_: haven't decided yet, I'll go tomorrow morning
11:25:21 <nejucomo> I want the user to be able to specify which instance of this parameterized type to use when parsing the commandline.
11:25:26 <cpoucet> dons: lykos :
11:25:27 <cpoucet> :D
11:25:29 <cjs_> (Dons got it.)
11:25:33 <dons> heh
11:25:41 <Arnar_> hey folks.. could someone have a look at http://hpaste.org/7423 ?
11:25:47 <cpoucet> Anywho, I'm gonna try to push haskell here, maybe even start an internal UG :)
11:26:17 <Arnar_> having some trouble with >>=
11:26:19 <cjs_> Huh, really. Oh, thus the "already proselytizing" thing. I'm guessing that's within the company, then. Poor guy.
11:26:20 <conal> cpoucet: great.  good luck.
11:26:57 <mux> the ECMAScript 4.0 guys are writing formal specifications for the language: http://wiki.ecmascript.org/doku.php?id=clarification:formal_type_system
11:26:57 <bos> google has an odd lack of haskell people compared to microsoft.
11:27:01 <lambdabot> Title: clarification:formal_type_system [ES4 Wiki], http://tinyurl.com/63tqjt
11:27:09 <cjs_> Still, there's hope. Google is screwed, since they're not using it, so this is some other company's chance to get ahead.
11:27:11 <mux> I wonder if there's such an effort ongoing for Haskell
11:27:14 <maltem> nejucomo, hard to comment on that, not knowing your exact issue
11:27:26 <mux> the idea of having a wiki for it sounds nice
11:27:40 <dons> mux, a formal spec for haskell?
11:27:45 <geezusfreeek> Arnar_: what is going wrong?
11:27:50 <dons> in twelf or isabelle or?
11:27:57 <Arnar_> geezusfreeek: it says GHC.Conc.STM is not in scope..
11:27:57 <mux> er?
11:28:10 <Arnar_> geezusfreeek: was thinking maybe I'm not allowed to use it like this
11:28:21 <pjd_> bos: MS or MSR?
11:28:27 <cpoucet> pjd_: he prolly means MSR
11:28:31 <mux> dons: I don't know what those are
11:28:36 <cjs_> Google appears to have gotten incredibly stupid in the last few years. I won't even comment on their recruiting process, but that they have a set of languages for their production code along the lines of (C++, Java, Python) says you probably won't have to worry about them two decades from now.
11:28:47 <dons> mux, oh, tools for formalising languages mechanically
11:28:51 <geezusfreeek> Arnar_: i see now. what is it exactly you are trying to do? (that syntax is quite invalid)
11:28:52 <cjb> cjs_: If that's a bet, I'll take it :)
11:28:55 <dons> (not just on paper)
11:29:14 <cjs_> cjb: You're on!
11:29:17 <cpoucet> cjs_: sounds like the words of a cynic, anywho, this is ot
11:29:17 <bos> pjd_: MSR, but it has some influence over aspects of MS behaviour. see LINQ and F#.
11:29:22 <lilac> cjs_: you seem to be assuming their policy is unchangeable?
11:29:27 <Philippa> cjs: consider how big they are - that's not a stupid choice considering
11:29:36 <Arnar_> geezusfreeek: I want the TMI monad to "replace" the STM monad, so to speak. plan to implement all the operations on STM on TMI. The difference is that the TMI maintains a log also (the [String] part)
11:29:42 <mux> dons: ISTR people talking about how having formal semantics (denotational) would be nice for Haskell, and seeing the ES4 guys do this for their language on their wiki, it sounds like a good idea to me
11:29:46 <pjd_> bos: i know, but there is still a substantial divide between MSR and the "trenches", IINM
11:29:56 <cjs_> No, I'm not assuming it can't change. But to still be using Java in anything but legacy systems at this point....
11:29:56 <geezusfreeek> Arnar_: this implementation is not possible
11:29:59 <cpoucet> pjd_: "IINM"?
11:30:04 <pjd_> "if i'm not mistaken"
11:30:09 <geezusfreeek> Arnar_: i would recommend looking into monad transformers and the Writer monad
11:30:09 <Arnar_> geezusfreeek: I was afraid you'd say that .. :)
11:30:15 <cjs_> Even I dumped it several years ago. I would never encourage new code to be written in it.
11:30:21 <bos> pjd_: indeed, but i can't think of *any* visible haskell people at google.
11:30:23 <pjd_> bos: i would bet you won't find noticeably more Haskell in MS proper than Google proper
11:30:26 <nejucomo> maltem: I'm writing a hashing utility.  To compute the hash of a string, you call a function with type "HashImplementation chainvar block -> String -> String".
11:30:39 <Arnar_> geezusfreeek: ah.. ok - had a hunch monad transformers were the proper thing here, but haven't read that chapter yet ;)
11:30:43 <cpoucet> bos: *holds his hand up*
11:30:43 <Arnar_> geezusfreeek: will do that now.. thanks
11:30:49 <geezusfreeek> Arnar_: no prob
11:30:51 <mux> oddly, ES4 has structured types and the overview seems to refer to duck typing, but I don't see any structural subtyping judgement in their specs
11:30:56 <nejucomo> I have a single HashImplementation: "sha1 = HashImplementation SHA1ChainVar SHA1Block".
11:31:02 <mux> only the lexical rules
11:31:13 <nejucomo> I want to make a program where the user can say: "myprog --hash=sha1 ...".
11:31:16 <mux> like :
11:31:18 <mux>  |- class C1.<A1, .., An> extends C2.<T ..>
11:31:18 <mux> --------------------------------------------------------------
11:31:19 <mux> D |- C1.<T1', .., Tn'> <: C2.<T ..> [A1 := T1', .., An := Tn']
11:31:31 <cjs_> Philippa, that "we're big, so we need make sure we're always operating at the level of the dumbest programmers" thing will kill any company. Not even MS is that bad.
11:31:33 <vincenz> bos: and there's also "tibbe"
11:31:50 <nejucomo> So I want a function like "String -> HashImplementation a b"
11:31:52 <lilac> it seems obvious to me that the in future there will be a chasm between those languages where taking advantage of multi-CPU machines is easy, and those where it's hard. further, functional languages fall into the first bucket, whereas the current incarnation of c++, java and python fall into the second.
11:32:05 <nejucomo> That returns sha1 if the string is "sha1".
11:32:08 <maltem> nejucomo, where does the hash algorithm go?
11:32:39 <Philippa> lilac: I suspect Google don't much care about SMP concurrency, on account of having to do seriously distributed stuff anyway
11:32:43 <cjs_> Maybe my impression is wrong. But my impression is, if you go up to your boss at Google and say, I'm going to add this cool new thing to GMail, and I'm going to do it in Haskell," he'll say, "no, do it in Java or C++ or Python."
11:32:57 <vincenz> Philippa: and most likely, nd this is just speculation, they're IO bottlenecked
11:32:57 <nejucomo> The function with type "HashImplementation -> String -> String" implements the chaining of the compression function.  The type "HashImplementation" contains the compression function.
11:33:05 <Philippa> vincenz: that too
11:33:12 <pjd_> bos: http://josefsblog.blogspot.com/2006/09/haskell-google.html ?
11:33:13 <lambdabot> Title: Josef's blog: Haskell @ Google
11:33:28 <Philippa> cjs_: and for maintainability, that's the right thing
11:33:54 <pjd_> bos: winning the ICFP with Haskell seems reasonably visible :)
11:34:07 <Philippa> think interfacing issues for a moment
11:34:35 <cjs_> Re: Haskell @ Google; well, ok, maybe we're all screwed instead. :-)
11:35:13 <Philippa> now what does make plenty of sense is for them to prototype etc etc in whatever language they feel like
11:35:23 <pjd_> bos: also, http://www.cs.vu.nl/~ralf/MapReduce/
11:35:24 <lambdabot> Title: Google's MapReduce Programming Model -- Revisited
11:35:32 <cjs_> Philippa, no, that's exactly the wrong thing for maintainablity. Maintainability is mostly about getting rid of old code (line by line) as quickly as possible, and replacing it with a lesser amount of newer, smaller, better code.
11:35:41 <pjd_> revisiting MapReduce and Sawzall with Haskell
11:35:41 <cpoucet> pjd_: that was a paper in answer to google's paper, not google's afaik
11:35:55 <maltem> nejucomo, I'm not sure if exposing one more type for any kind of hash is a good idea. why not just have different hash functions, all of the same type?
11:36:00 <Philippa> cjs_: it's also about making sure your programmers can read each others' code
11:36:30 <maltem> nejucomo, which would probably be ByteString -> String
11:36:31 <cjs_> I've done a lot of "dig out of legacy code" projects, and in most of them, you spend most of your time and effort deleting code and merging redundant code. If you can do it at all. It's often cheaper to throw it away.
11:36:40 <cpoucet> cjs_: you knw, it's ccurious you're saying "the managers won't let me write in haskell" while at the same time saying they shouldn't be using pythonjava/c++.  You're just as hardheaded if you expect everyone to follow your langauge du jour.
11:36:47 <nejucomo> I want to generalize the algorithm that all merkle-damgard hash functions use.
11:36:47 <cpoucet> cjs_: there needs to be a balacne
11:37:01 <pjd_> cpoucet: ah, looks like he actually works for MS
11:37:04 <nejucomo> Simplified, it's type could be: "CompressionFunction -> String -> String"
11:37:07 <Philippa> cjs: yes, sure, congratulations. Now WTF makes you think you can't do that in Java or Python?
11:37:11 <mapreduce> pjd_: You didn't visit me in the first place.
11:37:12 <pjd_> (Ralf LÃ¤mmel
11:37:26 <cjs_> Philippa, mmm. And readability is often inversely proportional to how much code there is, which is usually inversely proportional to how well refactored it is.
11:37:29 <maltem> nejucomo, that would be id
11:37:34 <nejucomo> I have this line: "sha1 = mdhash sha1_impl"
11:37:44 <nejucomo> and "sha1 :: String -> String"
11:37:45 <pjd_> i just saw the @gmail.com address
11:38:44 <maltem> nejucomo, right, then when the user says --sha1, just map that to that function
11:38:51 <Philippa> it is, however, proportional to whether you know a thing about the language in question. You absolutely cannot let someone who doesn't know Haskell loose on a Haskell system, it's far more dangerous than handing Python code to people who've not touched it before
11:39:10 <cjs_> cpoucet, I agree there needs to be a balance, but one must always be moving forward. And if you're "with it", as it were, Java's been dead for years, and ruby is pretty close to dead. At least for new projects. If you're still looking at starting new projects in Java these days, I think you're in trouble. Or even Ruby, for that matter. If you're a Ruby user, you should be working now on how to get out of that. (Thus my presence here, actually.)
11:39:15 <pjd_> Philippa: in Haskell, at least there's the type system
11:39:16 <cpoucet> not to mention that readability is not inversely proportional to how much code there is but to how well it is written
11:39:21 <cpoucet> that's like saying terser = beter
11:39:24 <nejucomo> Well...  It gets more complicated...  Because I want to allow hash extensions.
11:39:24 <cpoucet> at that point, go program per.
11:39:25 <pjd_> i reckon they could do far more damage in Python
11:39:26 <cpoucet> l
11:39:47 <cpoucet> cjs_: the JVM is actually pickinig up steam with the pletohora of stuff that runs on it
11:39:53 <cjs_> BTW, I'm not saying that "the managers won't let me ..." anything. I have no such problems, so if I fall behind technically, it's entirely my fault as a bad technical guy.
11:39:54 <dons> haskell's a safe language for newbies -- they can't do anything (wrong)
11:39:56 <nejucomo> So I have a function with type: "HashImpl cv bl -> cv -> Int -> String -> (String, String)"
11:40:00 <Philippa> pjd_: you're assuming "programming newbie", I suspect. It's much easier to give yourself a complete semantic WTF moment in Haskell
11:40:02 <cpoucet> cjs_: and then java forms a nice 'assembly' language for the core-libraries.
11:40:16 <dons> with enough cunning types you can ensure the only things they can do are the right things
11:40:26 * dons laughs evilly
11:40:27 <cjs_> cpoucet, mmm, there's some hope for the JVM. Mostly becuase it's not horribly slow any more, and there are other compilers to it.
11:40:30 <nejucomo> I want to parse commandline args to return "(HashImpl cv bl, cv, Int, String)"
11:40:34 <cpoucet> dons: the problem is that they can't do anything right either then D
11:40:41 <geezusfreeek> that is so evil
11:40:43 <nejucomo> -but that's not possible with the type system.
11:40:49 <Philippa> not because Haskell is WTFy, but because people Google hire will know most of the principles behind Python without being told
11:40:55 <pjd_> Philippa: nah, i'm assuming anyone not familiar with the language in question, but experienced in something else (C++, say)
11:40:55 <maltem> nejucomo, I'm still ignorant of what HashImpl cv bl is going to abstract
11:41:19 <nejucomo> Which md hash implementation the user wants: sha1, md5, etc...
11:41:21 <cjs_> cpoucet, Not really. That massive pile of cra^H^H^Hore libraries is fairly useless to better languages. How much of your Haskell code are you going to link to that?
11:41:27 <Philippa> pjd_: "I fixed your infinite recursion"
11:41:36 <cpoucet> cjs_: none, cuse of the cost of linking
11:41:43 <cpoucet> cjs_: that means nothing however.
11:41:56 <cjs_> cpucet: in general, terser is better.
11:42:06 <cjs_> At least for good programmers.
11:42:09 <nejucomo> I believe I can do pattern matching on the commandline and then return an IO () that uses the correct hash function, but I can't separate out the commandline parsing and the main IO ()...
11:42:11 <Philippa> you know where FORTH is if you want it
11:42:13 <cpoucet> cjs_: I would disagree. A bok that is wellwritten but longer is easier to read than one cryptically written
11:42:31 <maltem> nejucomo, you cannot let the user choose the implementation if you hard-code it into the type.
11:42:33 <nejucomo> I'll try the way I think can work now to see if that sheds light on the issue.
11:42:34 <dons> cpoucet: if you can't do the right thing, best do nothing at all :)
11:42:43 <dons> the haskell approach to software engineering
11:42:43 <cpoucet> dons: "it heats the cpu" )
11:42:45 <monochrom> Ahem, a well-written book is both shorter and easier to read.
11:42:53 <cjs_> Code isn't a book.
11:43:02 <nejucomo> maltem: Yes, I'm beginning to see my mistake in understanding parameterized types.
11:43:07 <monochrom> Well-written code is also both shorter and easier to read.
11:43:10 <cpoucet> cjs_: it comes down to, I don't agree with your axiom of shorter = better
11:43:11 <pjd_> dons: what about practicality beats purity? :)
11:43:11 <dons> xmonad is an epic poem
11:43:16 <maltem> nejucomo, there you go :)
11:43:22 <cpoucet> cjs_: I think ther's a sweet spot
11:43:29 <cpoucet> and if you go shorter, it gets worse again
11:43:50 <monochrom> I also see a lot of presentations and do a few of my own. A well-written set of slides is also both shorter and easier to read.
11:43:55 <cjs_> cpoucet: Hm. So let me ask, are you always bothered by your xterms being to short? Do you lust after screens that give you 90 lines instead of 72 in an xterm?
11:43:56 <mapreduce> Less repetitive is better.
11:44:11 <cpoucet> cjs_: you're taking an extreme case and then saying that it applies along the entire range
11:44:19 <cpoucet> cjs_: fitting in my screen != as short as possible
11:44:29 <cpoucet> cjs_: hence 'sweet' spot
11:44:31 <cjs_> Or, perhaps, do you get really, really annoyed by the C# and GNU convention of putting the opening brace on the next line?
11:44:32 <nejucomo> So, more generally, suppose I want to provide type "(String -> a) -> (a -> String) -> String -> String"
11:44:39 <Philippa> I've heard there's this amazing thing known as wrapping
11:44:39 <cpoucet> cjs_: your points do not refute that
11:44:53 <nejucomo> -then how can I select different "a" instances at runtime?
11:44:59 <cpoucet> cjs_: are you really annoyed by extremely tiny cars where you can fit nothing in them?
11:45:07 <cpoucet> cjs_: ergom everyone should drive cars that are 1 kilometer long
11:45:07 <Philippa> I get annoyed by idiots making generalisations from lexical convention all the way up to large semantic structures
11:45:10 <cpoucet> cjs_: that is how you're arguing
11:45:15 <cjs_> Nope.
11:45:29 <pjd_> #haskell-overflow?
11:45:33 <cpoucet> pjd_: yeah
11:45:34 <geezusfreeek> yeah please
11:45:40 <maltem> @djinn (String -> a) -> (a -> String) -> String -> String
11:45:41 <lambdabot> f a b c = b (a c)
11:45:42 <Philippa> yep, -overflow
11:45:50 <cjs_> Ok, I'm there.
11:46:34 <Philippa> nejucomo: what you'll find is that you don't and can't and that it doesn't necessarily matter
11:46:43 <Philippa> you just feed stuff in and get stuff out
11:47:14 <Cale> nejucomo: You don't do that at runtime... Haskell's type system is static -- the type of everything is determined at compile time, and then all that information is thrown away.
11:48:02 <Cale> But if all you're asking is how to apply that function at different types 'a', you just apply it to things of the appropriate type.
11:48:09 <maltem> Now I finally experienced what #haskell-overflow is good for. OT discussion goes away, Cale comes back :)
11:48:20 <Cale> I just woke up :)
11:48:40 <maltem> @localtime Cale
11:48:40 <lambdabot> Local time for Cale is Mon May  5 15:17:21
11:48:54 <Cale> yeah, yeah, it's the afternoon, so sue me :)
11:49:01 <monochrom> Whenever someone says something in #haskell-overflow, Cale wakes up in #haskell?  Quantum entangling?
11:49:14 <maltem> Sleeping at noon is said to be refreshing
11:49:58 <Cale> Staying up until 5 or 6 am and then sleeping through the entire morning works as well. :)
11:50:05 <nejucomo> What I'll do is write a working implementation, and then show how repetitive the code is, and the paste it and ask for advice on how to change the design...
11:50:10 <geezusfreeek> Cale: that's the ticket!
11:50:36 <maltem> Cale, that sounds more exciting anyway
11:50:51 <geezusfreeek> while i do have some leeway, i wish my job would permit me to do that more often
11:51:20 <geezusfreeek> i am more productive when everybody else is asleep
11:51:56 <nejucomo> (You all might be able to tell how python has soiled my understanding of static typing.  ;-)
11:52:16 <tahir_hh> I honestly cannot find what I am looking for in the documentation.  Can someone tell me please where to look and how to look?
11:53:11 * monochrom probes tahir_hh's brain. Only way to know.
11:53:20 <geezusfreeek> nejucomo: it's always a humbling experience to see your design reduced 10:1 in this channel when you ask for help ;)
11:53:28 <monochrom> All brain probes are destructive.
11:53:37 <tahir_hh> I am looking to resize a textbox in wxHaskell
11:53:45 <olsner> @faq can Haskell read minds?
11:53:46 <lambdabot> The answer is: Yes! Haskell can do that.
11:54:08 <tahir_hh> how would I go about probing the documentation for that?
11:55:14 <geezusfreeek> @faq can Haskell buy me a chicken sandwich for lunch today?
11:55:14 <lambdabot> The answer is: Yes! Haskell can do that.
11:56:34 <Cale> tahir_hh: Well, I don't know wxHaskell extremely well, but I can try to show how I might look for that information...
11:56:44 <Cale> http://wxhaskell.sourceforge.net/doc/ -- I'd start here.
11:57:02 <tahir_hh> I have gone there
11:57:05 <Cale> Graphics.UI.WX.Controls  looks hopeful... I can look up things about text entry boxes there
11:57:25 <tahir_hh> gone there too but I have not imported this namespace so doubtful
11:58:23 <Cale> Then in the text entry section here, it shows that a textEntry control is an instance of a class called Dimensions... which might have to do with controlling its size
11:59:02 <Cale> and yeah, http://wxhaskell.sourceforge.net/doc/Graphics-UI-WX-Classes.html#t%3ADimensions -- this class looks like it has the attributes which control the sizes of things
11:59:04 <lambdabot> http://tinyurl.com/68ojsr
11:59:12 <twanvl> tahir_hh: try something like "set myControl [outerSize := Size 123 456]"
11:59:28 <Cale> So yes, try something like twanvl just suggested :)
12:03:28 <tahir_hh> Thanks Cale  and twanvl ! It worked (when resized it went back) but that was really helpful.
12:04:15 <tahir_hh> so "classes" in haskell are a bit like interfaces in Java etc?
12:04:20 <Cale> tahir_hh: Oh, and about the comment that you haven't imported that module -- if you've imported Graphics.UI.WX, then you've imported everything underneath it because it reexports those modules
12:04:25 <Cale> tahir_hh: yeah
12:06:37 <tahir_hh> Cale: so it behaves like c++ #include? where if one header h1 includes another header h2 then including h1 automatically includes h2?
12:07:00 <Beelsebob> tahir_hh: no, it must explicitly reexport the modules
12:09:08 <tahir_hh> does the import statement import a particular folder structure?  I see that I have C:\wxhaskell-0.10.3\lib\imports\Graphics\UI\WX so does it look at all the files in this directory?
12:09:21 <cjs_> tahir_hh, "classes" in Haskell are actually kinda like Ruby's "duck typing," but with type checking and inheritance.
12:10:12 <cjs_> tahir_hh, Reading the Haskell spec. section on modules you might find helpful; I did. It's pretty readable.
12:10:12 <monochrom> On http://wxhaskell.sourceforge.net/doc/Graphics-UI-WX.html you see lots of lines saying "module XXX", "module YYY".  This means XXX and YYY are re-exported.
12:10:25 <monochrom> If you don't see such lines, there is no re-export.
12:11:44 <tahir_hh> monochrom: but is there anyway to see thing in the files and folders that physically reside on my computer (an a a bit of a concrete thinker)
12:12:47 <tahir_hh> cjs_: I dont know much Ruby but I was thinking about interfaces in that you are forced to implement a set of functions for you to be an instance of that class (much like in Java)
12:13:08 <Cale> tahir_hh: yeah, it's rather like that
12:13:09 <tahir_hh> monochrom: to see *this*
12:13:11 <cjs_> tahir_hh, yes, more or less like that.
12:13:12 <monochrom> #include is a crude approximation to module importing and exporting, and it only approximates one aspect (i.e., what happens at -c time). #include does not say what happens at link time.  A complete module system has to say what happens to source code and what happens to link time.
12:13:38 <monochrom> In short, don't use #include to understand a module system.  Wrong glasses to put on.
12:14:03 <Cale> tahir_hh: You can think of a typeclass as a predicate on types, where if the predicate is true, then some functionality is present. These predicates can then be used to restrict the set of types over which type variables range.
12:14:17 <cjs_> tahir_hh, except that you can inherit code in a Haskell class, and then there's "derives," which is just your dream come true, basically.
12:14:53 <Cale> For example, while you might have a function like  length :: [a] -> Integer, which works no matter what the type a is, because it doesn't need to look at the elements of the list
12:15:17 <Cale> there are functions like sort, which you'd like to be polymorphic, but you also need to be able to compare elements of the list for ordering
12:15:31 <Cale> So there's an Ord class, for types with a specified order
12:15:39 <Cale> and then  sort :: Ord a => [a] -> [a]
12:15:44 <monochrom> What do you want to see in the files residing on your disk?  You may need a hex editor to examine the .o files and the .lib files and the .a files and the .obj files and the .dll files...
12:16:44 <tahir_hh> monochrom: because when you see stuff on your computer and it corresponds with your mental model you think you understand it :)
12:17:07 <monochrom> Use a hex editor.
12:17:33 <cjs_> Unless you're worried about the linking issues (in which case you're getting into a massive ball of wax that ghc does pretty well, anyway), just think of "import" as bringing in a bunch of stuff from one namespace to another.
12:19:12 <monochrom> It is trivial for a concrete thinker and tinkerer to figure out which files correspond to which modules.
12:19:13 <tahir_hh> are there any textbooks that you guys would recommend? I have a haskell book by Simon Thompson which is brilliant but most the excercises could be done on paper.  I would lie,k
12:19:33 <tahir_hh> like a book that I can use to build a *real* application
12:19:53 <monochrom> It is also trivial for a real programmer to use a hex editor to figure out which modules import which other modules and re-export which other modules.
12:20:02 <monochrom> I'll leave it at that.
12:21:57 <cjs_> tahir_hh, I think you'd like Hudak's _The Haskell School of Expression_, but it gets hard pretty quick. I found going through Graham Hutton's _Programming in Haskell_ helped immensely.
12:22:01 <tahir_hh> monochrom: when a module imports another module it uses it for its personal use and when a module m re-exports another module then it uses it for personal reasons and then a module that imports m which also import the modules that m re-exported?
12:22:20 <nejucomo> Okay, I have a compiling example: http://pastebin.com/db133b67
12:23:13 <tahir_hh> cjs_: but does the haskell school of expression cover monads.  reviewers and a browse through the toc says no.
12:23:25 <cjs_> tahir_hh, If it wants to, yes. You really want to read this: http://haskell.org/onlinereport/modules.html
12:23:30 <lambdabot> Title: The Haskell 98 Report: Modules
12:23:31 <monochrom> Probably yes, pending elimination of ambiguous pronouns such as "it".  "it uses it" is sloppy writing.
12:23:49 <nejucomo> -and here is what it would look like if I had implemented md5 already: http://pastebin.com/d1ed6f058
12:24:04 <nejucomo> Notice how the two cases have almost identical structure except for a single name.
12:24:05 <cjs_> tahir_hh, yes, it does. Actually, even the "Functional Parsers" chapter of Hutton's book does, though you won't know it at first.
12:24:28 <nejucomo> The problem is, those two names refer to different types (the same parameterized type with different type parameters).
12:24:55 <nejucomo> -so I can't make a function that takes "sha1" or "md5" and returns the appropriate thingy which would let me collapse those 6 lines down to 3.
12:25:08 <nejucomo> The more hash implementations there are, the more I have to cut'n'paste that block.
12:25:11 <cjs_> But if you're doing a real application in Haskell (as I am), you're going to be bouncing around all over the place anyway, as far as reading goes, so I wouldn't worry about what anything in particular covers, except in books if you're cost-constrained.
12:25:15 <nejucomo> Any suggestions?
12:25:37 <tahir_hh> this is really good information.  I am going to copy and paste it and save it :)
12:25:47 <tahir_hh> rarely has irc been so productive
12:26:11 <maltem> nejucomo, change the functions involved so that you don't have to pass arguments of varying types?
12:26:26 <monochrom> Great quote from Lamport in his book Specifying Systems.  First he quotes Guindon: "Writing is nature's way of letting you know how sloppy your thinking is."  Then he adds his own, "Mathematics is nature's way of letting you know how sloppy your writing is."  But that's not all.  "Formal mathematics is nature's way of letting you know how sloppy your mathematics is."
12:26:38 <nejucomo> maltem: That might work...  I'll have to think about it.
12:26:47 <cjs_> I really should just put up a set of reviews of all of the books I own.
12:27:16 <nejucomo> I think I went overboard with generalization, since I wanted the block type and chaining variable type to be parameterized for each hash implementation.
12:27:20 <cjs_> BTW, tahir_hh, are you already comfortable with FP? If not, _The Little Schemer_ might help you a lot.
12:27:30 <nejucomo> In reality they are always byte strings of fixed length (the length varies between hashes).
12:27:32 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml  My favourite books on functional programming.
12:28:02 <nejucomo> So I could replace those type parameters with a concrete type which is a byte string (possibly with a length associated).
12:28:12 <tahir_hh> monochrom: I was going to give each module a letter because using plain english quickly gets confusing but then I think that this would not be acceptable
12:28:38 <monochrom> IMO plain English is unacceptable.
12:28:48 <nejucomo> (It was fun, though, to imagine a strange new hash that operated on something besides type strings...)
12:29:02 <nejucomo> Back after lunch.
12:29:42 <tahir_hh> monochrom: what is the alternative? English augmented with mathematics?
12:30:41 <saml> @type \x -> \x -> (x + x)
12:30:45 <lambdabot> forall t a. (Num a) => t -> a -> a
12:31:07 <monochrom> As you said, giving each module a distinct letter is much clearer.
12:31:50 <tahir_hh> cjs_: I have done functional programming at university but I am working as a programmer.  I am finding a way of implementing an application that was written in c++ in wxhaskell instead.  Don't know if I will manage but once I do I will try to convince my boss that is it a good thing to do.
12:34:06 <tahir_hh> monochrom: do you think that this form of english should be part of the gcse english syllabus? (assuming that you come from the uk)
12:34:30 <monochrom> Yes.
12:36:13 <fizzletip> Not in scope. What is that?
12:36:29 <tahir_hh> fizzletip: you have not imported something
12:36:37 <monochrom> I think "not in scope" is self-explanatory.
12:36:38 <tahir_hh> just a suggestion
12:37:16 <fizzletip> i thought it was enough to have it in module Tree ( emptyTree ) where
12:37:34 <saml> is this valid:   \x -> \x -> x + x  ??  to type check this do I have to transform it to  \x -> \y -> y + y ?
12:38:01 <bd_> saml: \x -> \x -> x + x is syntactically valid, and has type Num b => a -> b -> b
12:38:10 <Heffalump> saml: yes, and probably in practice.
12:38:11 <monochrom> They have the same type and the same meaning.
12:38:12 <bd_> :t \x -> \x -> x + x
12:38:15 <lambdabot> forall t a. (Num a) => t -> a -> a
12:38:19 <monochrom> They are both valid.
12:38:31 <saml> but if I were to write an evaluator/typechecker, substitution is the only way?
12:38:40 <Heffalump> assuming you mean "write my own type checker", rather than just use someone else's
12:38:40 <monochrom> Some people say "\x -> \x -> ... is confusing" but I don't care about them.
12:38:43 <eu-prleu-peupeu> hello again
12:39:01 <Heffalump> saml: you'd have to translate it to *something* internally
12:39:16 <Heffalump> and that thing would obviously have to disambiguate, whether implicitly or explicitly
12:39:19 <monochrom> If you use de Bruijn numbering, there is nothing to do.
12:39:29 <Heffalump> monochrom: you still need to convert to it
12:39:41 <monochrom> If you do shadowing, there is also nothing to do.
12:42:03 <saml> @go lambda shadowing
12:42:17 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
12:43:16 <czakey> huh
12:54:06 <saml> data Expr = Lam [String] Expr
13:13:36 <jaj> hmm I have an array of test functions: tests :: [Int -> Bool] and I'd like to see if an Int passes all tests or not. I tried foldr (&&) stuff and seq and I can't figure out how to do it
13:14:21 <dolio> @type \i -> all ($i)
13:14:23 <lambdabot> forall a. a -> [a -> Bool] -> Bool
13:15:36 <dolio> @type \l -> and . sequence l
13:15:38 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
13:17:23 <jaj> dolio: thanks I'll try all
13:20:30 <dolio> @type \t -> Data.Folable.and . Data.Traversable.sequence t
13:20:33 <lambdabot> Couldn't find qualified module.
13:20:36 <dolio> @type \t -> Data.Foldable.and . Data.Traversable.sequence t
13:20:38 <lambdabot> forall (t :: * -> *) (f :: * -> *). (Functor f, Monad f, Data.Traversable.Traversable t) => t (f Bool) -> f Bool
13:29:55 <jaj> dolio: what does ($i) above mean? is this simply the ($) operator?
13:30:13 <dolio> Yeah. It means \f -> f $ i
13:30:41 <monochrom> Just like (* i) means \f -> f * i
13:30:59 <monochrom> > (* 2) x
13:31:01 <lambdabot>  x * 2
13:31:19 <monochrom> (Courtesy someone's symbolic magic)
13:31:35 <monochrom> > ($ 2) f
13:31:36 <lambdabot>  Add a type signature
13:31:57 <monochrom> Oh, I forgot what type signature it should be. There is one that works.
13:31:59 <jaj> yeah I know about currying
13:32:02 <monochrom> :type f
13:32:08 <monochrom> @type f
13:32:10 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:32:18 <dolio> > ($ 2) f :: Expr
13:32:19 <lambdabot>  f 2
13:35:56 <jaj> dolio: thanks a lot
13:36:04 <dolio> No problem.
13:38:14 <sieni> dolio: that's actually one of the weirdest ways to be pointfree/less
13:38:28 <sieni> @pl \f -> f foo
13:38:28 <lambdabot> ($ foo)
13:39:13 <cpoucet> it's quite useful
13:39:31 <sieni> yeah, I guess so
13:39:54 <sieni> but can you say ($ foo) without using $?
13:39:59 <sieni> like flip something
13:40:05 <dolio> flip id
13:40:07 <cpoucet> > map ($ 3) [(+2), (*3), (+4)]
13:40:09 <lambdabot>  [5,9,7]
13:40:22 <dolio> @type all . flip id
13:40:24 <lambdabot> forall b. b -> [b -> Bool] -> Bool
13:40:29 <cpoucet> :t flip id
13:40:31 <lambdabot> forall b c. b -> (b -> c) -> c
13:40:33 <cpoucet> :t flip ($)
13:40:35 <lambdabot> forall a b. a -> (a -> b) -> b
13:40:36 <sieni> > map (flip id) [(+2), (*3), (+4)]
13:40:37 <lambdabot>  Add a type signature
13:40:51 <sieni> dolio: doesn't work
13:41:01 <dolio> ($i) is flip id i
13:41:03 <cpoucet> > map (flip id 3) [(+2), (*3), (+4)]
13:41:05 <lambdabot>  [5,9,7]
13:41:07 <sieni> > map (flip . id) [(+2), (*3), (+4)]
13:41:08 <lambdabot>   add an instance declaration for (Num (b -> c))
13:41:17 <sieni> that doesn't work either
13:42:53 <dolio> flip . id = flip
13:45:21 <cpoucet> forall f :: a -> b, f . id = f
13:45:41 <nejucomo> Is there a standard / common library for commandline argument parsing?
13:46:03 <dolio> GetOpt or something like that.
13:46:32 <eyeris> What is the syntax for embedding compiler options into a source file for GHC?
13:47:07 <dons> {-# OPTIONS_GHC -fglasgow-exts #-}
13:47:33 <eyeris> thanks
13:50:04 <dons> if they're language features though, you should use the LANGUAGE pragma
13:50:06 <Cale> eyeris: Note that for language extension options in particular, there's a special syntax: {-# LANGUAGE TheLanguageExtension #-}
13:50:17 <dons> e.g. {-# LANGUAGE MagicHash, UnboxedTupes, TypeFamilies #-}
13:51:25 <jaj> ./5  136.33s user 0.28s system 96% cpu 2:21.81 total
13:51:30 <jaj> oops
13:53:09 <jaj>   let allTests = flip (\i -> all ($i)) tests
13:53:37 <jaj> tests :: Int -> Bool, allTests :: Int -> Bool
13:53:49 <jaj> that's not really beautiful code, is it?
13:55:11 <jaj> no, tests :: [Int -> Bool]
13:55:15 <dons> ?pl allTests = flip (\i -> all ($i)) tests
13:55:15 <lambdabot> allTests = flip all tests . flip id
13:55:20 <jaj> I guess I'm just tired...
13:55:23 <dons> ?unpl allTests = flip (\i -> all ($i)) tests
13:55:24 <lambdabot> allTests c = all (\ d -> d c) tests
13:55:33 <dons> ?pl (\ d -> d c)
13:55:33 <lambdabot> ($ c)
13:56:02 <dolio> flip (\i -> all ($i)) tests = flip (\i l -> all ($i) l) tests = (\l i -> all ($i) l) tests = \i -> all ($i) tests
13:56:08 <jaj> lambdabot rocks
14:00:36 <tahir_hh> (\x -> x+ 1) 1
14:00:46 <Arnar_> ?index runState
14:00:46 <lambdabot> Control.Monad.State, Control.Monad.RWS
14:00:46 <tahir_hh> ?(\x -> x+ 1) 1
14:00:47 <lambdabot> you are welcome
14:00:50 <conal> what's the state of type families in ghc 6.8.2?
14:00:50 <Arnar_> :t runState
14:00:52 <lambdabot> forall s a. State s a -> s -> (a, s)
14:01:00 <ziman> >  (\x -> x+ 1) 1
14:01:00 <tahir_hh> ?(\x -> x+ 1) 1
14:01:01 <lambdabot> you are welcome
14:01:03 <lambdabot>  2
14:01:11 <ziman> tahir_hh, ^^
14:01:35 <monochrom> ?
14:01:39 <tahir_hh> didn't get the answer the first time :)
14:02:08 <dolio> jaj: Also: allTests = and . sequence tests
14:02:12 <Arnar_> ?help (
14:02:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:02:35 <sclv_> conal: so broken. :-(
14:02:45 <conal> sclv_: urg.  thx.
14:02:54 <sclv_> or rather, i've seen people use them for some things, so you can try, but they're unreliable.
14:03:14 <sclv_> I get an "impossible happened" on a (a~b) constraint for example.
14:03:25 <conal> sclv_: i'll give it them a try.  thx.
14:04:08 <jaj> dolio: that gives me No instance for (Monad ((->) Int))
14:04:18 <dolio> import Control.Monad.Instances
14:05:43 <jaj> dolio: ok thanks, this definition is also much clearer. I've got a lot more to learn...
14:07:23 <Wraithan> haskell is great, just started learning it but it allows me to frame math problems like I want to instead of translating into terms of spread sheets or C++ (my most fluent computer tongue)
14:08:11 <MyCatVerbs> Wraithan: it also allows you to frame things like spreadsheets, too, though. :)
14:09:55 <eyeris> Why does Control.Monad.Trans have both liftIO and lift? Can't the IO special case be handled in the definition of lift, using pattern matching?
14:09:59 <Wraithan> MyCatVerbs: bleh, only like using spreadsheets for some stuff, haskell allowed me to frame it how my mind works
14:13:41 <dmwit> eyeris: I don't really think that's what pattern matching does.
14:14:28 <dolio> lift lifts one level. liftIO lifts many levels.
14:16:14 <eyeris> dolio: so in order to use lift on a function of type M1 a, my function must be in M2 M1 a but I can use liftIO anywhere?
14:17:28 <dolio> 'liftIO m' might be equivalent to 'lift m' or 'lift (lift m)' or 'lift (lift (lift m))' or ... depending on context.
14:19:52 <dolio> And, of course, there are situations whre 'lift m' is not the same as 'liftIO m' at all, because m is not an IO action.
14:23:29 <nomeata> dcoutts: Hi. I see that cabal-install patches appeared at darcswatch. I made it track that repository as well now: http://darcswatch.nomeata.de/repo_http:__darcs.haskell.org_cabal-install.html
14:23:32 <lambdabot> Title: DarcsWatch overview for http://darcs.haskell.org/cabal-install, http://tinyurl.com/5czpnt
14:29:13 <tero-> I'm trying to use HSQL 1.7 with ghc 6.8.2 but I cannot get the package installed
14:30:00 <tero-> hsql.cabal was missing at least LiberalTypeSynonyms and TypeOperators
14:30:02 <mmorrow> tero-: why not?
14:30:06 <mmorrow> ahh
14:30:25 <tero-> now it says "Database/HSQL/Types.hs:134:18: Not in scope: type variable 'forall'"
14:30:42 <mmorrow> add -fglasgow-exts to the ghc_options:
14:30:55 <tero-> humm.. how to do that with cabal?
14:31:03 <mmorrow> edit hsql.cabal
14:32:46 <tero-> ah, also old-time module was hidden. I added it to build-depends-section
14:33:15 <mmorrow> mine built with=> extensions: ForeignFunctionInterface, TypeSynonymInstances, PolymorphicComponents, DeriveDataTypeable, CPP
14:33:26 <mmorrow> (and without -fglasgow-exts)
14:33:43 <mmorrow> or any ghc options for that matter
14:35:22 <tero-> mmorrow: perfect. with those options it managed to build. thanks
14:35:28 <mmorrow> nice
14:40:31 <tero-> a-ha. now it complains about rawSystemVerbose. the function is not exported by Distribution.Simple.Utils
15:09:55 <gwern> what is the general justification for not 'strip'ping a binary by default?
15:10:04 <gwern> is it just for better core dumps?
15:10:56 <dmwit> For debugging, right?
15:11:26 <dcoutts> it only helps gdb style debugging
15:11:37 <ptolomy2> Hmm.. Anybody know what sort of performance hit one takes from 'fromDynamic'?
15:11:46 <dcoutts> and that's not usually much use except for debugging rts bugs
15:12:02 * gwern wonders if any haskellers actually use gdb on core dumps
15:12:02 <dcoutts> gwern: cabal-1.4+ strips by default
15:12:15 <dcoutts> gwern: with --disable-executable-stripping as an option
15:12:29 <gwern> come to think of it, I don't think I've ever seen any core dumps being created by crashing haskell programs
15:12:35 <gwern> wonder if that's due to some system setting or something
15:12:47 <dcoutts> gwern: core dumps are a system setting, not per binary
15:12:56 <snhmib> haskell program crash? o_O
15:13:05 <popcorn> > head []
15:13:06 <lambdabot>  Exception: Prelude.head: empty list
15:13:14 <popcorn> that counts as a crash?
15:13:22 <ddarius> snhmib: If you try hard enough.
15:13:35 <gwern> snhmib: sure. uncaught exceptions, for starters, cause crashes; FFI stuff can result in crashes
15:13:43 <popcorn> > last [100000000000000000..]
15:13:47 <lambdabot> Terminated
15:13:59 <popcorn> > [1,1000000000000000000000000,..]
15:14:00 <lambdabot>  Parse error at "..]" (column 30)
15:14:14 <snhmib> i thought real crashes :P
15:14:18 <popcorn> > [1,1000000000000000000000000..]
15:14:21 <dcoutts> gwern: and we now warn about using -optl-Wl,-s too since cabal does it, that flag isn't portable, and it's important to be able to disable for distros that manage striping themselves (eg gentoo, fedora 8+ iirc)
15:14:21 <lambdabot>  [1,1000000000000000000000000,1999999999999999999999999,299999999999999999999...
15:15:15 * gwern nods. what brought this up was wondering why darcs' makefiles didn't strip
15:16:35 <dcoutts> gwern: eg it's gentoo policy that gentoo deals with striping, not package build systems, so we always need to be able to disable it
15:17:09 <gwern> hm. and other systems don't care if you go ahead and strip or not?
15:17:13 <snhmib> talking about generating real crashes
15:17:31 <dcoutts> gwern: similarly for fedora iirc, since they allow striping debugging info out of binaries and storing it elsewhere so that it can be used later for gdb or generating stack traces for bug reports
15:17:48 <ptolomy2> Guh. Sometimes a value-based system is annoying.. I think I'm going to need to parameterize a pile of types to accomplish what would just be a single pointer and forward declaration in C++.
15:18:04 <snhmib> is it possible to pass haskell StablePtr's to C, "forgetting" what type they were, getting them back from C and have haskell figure out what type they were?
15:18:07 <dcoutts> gwern: some don't care, some require you do not strip or they class it as a QA violation
15:18:15 <gwern> dcoutts: storing... elsewhere? what
15:18:19 <ddarius> snhmib: No.
15:18:50 <dcoutts> gwern: yes, I believe fedora keeps debug info in separate files somewhere and uses it for gdb or bug-buddy stack trace info
15:18:57 <bd_> snhmib: You could wrap in a Dynamic, I suppose, but you still need to know the type to extract it
15:19:35 <snhmib> let me look up dynamic
15:19:46 <bd_> snhmib: but, what are you really trying to do? :)
15:19:48 <dcoutts> nomeata: yes, I subscribed darcswatch to cabal-devel
15:20:00 <gwern> dcoutts: I had no idea you could do that
15:20:12 <nomeata> dcoutts: nice. I hope you will find it useful.
15:20:58 <dcoutts> nomeata: me too :-)
15:21:17 <dcoutts> nomeata: I'll announce it to the cabal-devel folk, unless you'd prefer to :-)
15:22:05 <snhmib> bd_: trying to learn the ffi (and haskell) =) i made some bindings to graphviz and thought it would be neat to find out how to attach haskell objects to stuff instead of just strings
15:22:35 <dcoutts> gwern: I think the advantage from the fedora pov is that they do not need to install the debug info on every end user box but they can still generate bug-budy stack traces etc by matching up the addresses with the saved stripped debug info from their packages
15:23:03 <nomeata> dcoutts: no, go ahead. It would be nice if you put me in the CC:, though.
15:23:31 <dcoutts> gwern: it is indeed pretty neat, and a relatively new system, the gentoo stuff is much simpler, just a system wide preference to install/not-install debug info
15:23:34 <dcoutts> nomeata: ok
15:23:40 <bd_> snhmib: ah, StablePtr Dynamic might do what you want then
15:24:43 <ddarius> snhmib: If you are making something more like a library just leave it to the user.  The user can then handle the details.
15:24:45 <snhmib> cool (still looking up dynamic)
15:25:09 <ddarius> @docs Data.Dynamic
15:25:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
15:25:13 <bd_> snhmib: you could also make the type of the graph be parameterized on the type of the labels
15:25:35 --- topic: set to 'Manifest0' by puppet_aragorn
15:25:35 --- topic: set to '["The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/ ","Call for papers: http://haskell.org/haskell-symposium/2008/CFP.html "]' by ChanServ
15:25:57 <bd_> puppet_aragorn: what?
15:26:02 <puppet_aragorn> sorry
15:26:08 <puppet_aragorn> irc newbie
15:26:15 <snhmib> you mean reading a label and guessing the type from that?
15:26:22 <gwern> dcoutts: oh, I see. since they're distributing pre-compiled binaries, they can keep the big symbol tables on the developer machines, but strip everything being downloaded by endusers. yeah, that is pretty cool
15:26:33 <dcoutts> gwern: right
15:26:45 <bd_> snhmib: No, I mean things like setNodeLabel :: SomethingtoIdentityTheNode -> a -> Graph a -> IO ()
15:26:50 <bd_> where 'a' is the node label
15:27:04 <bd_> but I don't know what the graphviz API looks like, so I'm making things up as I go :)
15:28:42 <saml> concat $ map f l     is this normal? or is there a better?
15:28:51 <ddarius> :t concatMap
15:28:53 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:28:54 <ddarius> @src concatMap
15:28:54 <lambdabot> concatMap f = foldr ((++) . f) []
15:29:08 <ddarius> Or if you want to be obfuscatory, l >>= f
15:29:11 <popcorn> l >>= f
15:29:14 <popcorn> oops
15:29:31 <saml> concatMap !
15:29:35 <snhmib> dynamic looks nice... seems like it could take care of the "you can't have type -> type -> type variable" - problem =)
15:29:36 <cpoucet> > [1,2,3] >>= (\x -> [x,x*2])
15:29:38 <lambdabot>  [1,2,2,4,3,6]
15:30:11 <dmwit> > [1, 2, 3] >>= sequence [id, (*2)]
15:30:13 <lambdabot>  [1,2,2,4,3,6]
15:30:16 <snhmib> s/problem/feature , maybe
15:30:39 <dons> nice, http://reddit.com/info/6i9np/comments/
15:33:09 <ddarius> Haskell: Turning Features Into Bugs Since 1989
15:35:36 <popcorn> I don't understand why anyone would use dynamic :/
15:37:03 * ptolomy2 considers using Dynamic to avoid the parameterized type non-h98 gymnastics required to resolve a circular dependency.
15:38:41 <bd_> ptolomy2: what kind of circular dependency?
15:39:14 <ptolomy2> What is the syntax for "data Foo x = Foo (Bar x) Whatever" if I want to say that 'x' is an instance of typeclass 'Num', for instance?
15:39:29 <roconnor> > let x = (0/0) in x==x
15:39:31 <lambdabot>  False
15:40:10 <ptolomy2> data Foo x = (Num x) => .... ?
15:40:19 <snhmib> popcorn: me neither, except in this very special case where it seems handy! :P
15:40:52 <snhmib> probably the people that made it thought the same thing
15:41:10 <dmwit> ptolomy2: It is preferred to put that restriction on functions using Foo rather than on Foo itself.
15:41:30 <dolio> To correctly put it on Foo you need to use GADT syntax.
15:41:45 <dolio> At least, if you want it to store the dictionary.
15:41:57 <ptolomy2> hm. .Okay.
15:42:02 <ptolomy2> I suppose I don't want to be storing the dictionary.
15:42:22 <dolio> Oh, then it's just 'data (Num x) => Foo x = Foo (Bar x)'
15:42:42 <dolio> That constrains the type of Foo.
15:42:59 <dmwit> But take a look at, for example, Data.Map.
15:43:18 <dmwit> Although Maps only make sense for keys in Ord, there is no Ord restriction in the Map data declaration.
15:43:28 <ddarius> :t Map.empty
15:43:30 <lambdabot> Couldn't find qualified module.
15:43:35 <ddarius> :t M.empty
15:43:36 <lambdabot> forall k a. M.Map k a
15:43:41 <dmwit> Right.
15:43:57 <dmwit> The Ord constraint only exists on functions that actually use Ord functions.
15:46:34 <dolio> I do remember red black trees seeming much harder in the class I had about them than they do in Okasaki's book.
15:46:47 <dolio> All the pointer fiddling is nasty.
15:48:02 * ptolomy2 is starting to get the impression that trying to put everything associated with a type in the same module isn't always the best strategy.
15:49:53 <sheyll> hi every1
15:50:30 <ptolomy2> hallo
15:50:41 <sheyll> hi
15:50:42 <dmwit> Hiya, sheyll!
15:51:08 <sheyll> I would like to add sth to gtk2hs, is it hard for a beginner?
15:51:33 <dmwit> I guess that depends on what you want to add, what you've done with Gtk before, etc.
15:51:58 <sheyll> I would like to add some missing events in mozembed
15:52:34 <sheyll> I have not much gtk experiences.
15:53:18 <Saizan> gtk2hs's source comes with tools that automate a lot of the FFI bindings, but you still have to know how to use the Storable class in some cases
15:53:18 <sheyll> also I am experiencing reproducable segfaults with mozembed... :(
15:55:10 <sheyll> I tried to find some documentation on how to extend gtk2hs, and all I found were some perl scripts, that looked scary...
15:55:25 <sheyll> well and some tools
15:56:09 <sheyll> I thought maybe this could be a simple copy-paste-modify job...
15:58:41 <sheyll> in the signal reference found here: http://www.mozilla.org/unix/gtk-embedding.html, there are some signals missing in gtk2hs, most importantly progress, location, net_state, new_window and net_start/stop_
15:58:42 <lambdabot> Title: GtkMozEmbed: Embedding Mozilla into Gtk Applications
16:00:35 <sheyll> what do you think, will that be as easy as copying stuff in the corresponding .chs.pp file, or do I need to look further?
16:03:17 <OceanSpray> guys,
16:03:31 <OceanSpray> ECE or CS?
16:03:43 <dmwit> What's ECE?
16:04:05 <glguy> variation on home-ec
16:04:22 <OceanSpray> Electrical and Computer Engineering.
16:04:37 <glguy> OceanSpray: which one do you think you'll be more interested in?
16:04:41 <lament> OceanSpray: are you interested in electrical engineering and very low-level programming?
16:04:46 <lament> OceanSpray: if not, do CS
16:04:52 <sheyll> CS
16:05:13 <dmwit> Do logic gates get your juices flowing? ECE
16:05:17 <ddarius> MBA
16:05:29 <dmwit> Does the Structure and Interpretation of Computer Programs make you hot? CS
16:05:36 <sheyll> according to the channel you are currently joined to: CS
16:05:42 * MathHat holds up a cross in front of ddarius.
16:05:43 <ddarius> dmwit: What if I answer yes to both?
16:05:56 <dmwit> ddarius: double-major ;-)
16:06:08 <lament> OceanSpray: i work at a "normal" software company (not related to EE in the slightest). Many co-op students come to interviews from EE (despite our company being completely unrelated to what they study!). They tend to suck at programming.
16:06:36 <MathHat> CE!
16:06:43 <sheyll> ES
16:06:49 <OceanSpray> but if they ROCK at programming...?
16:06:57 <lament> but they don't. That's the thing.
16:07:06 <OceanSpray> hm.
16:07:19 <lament> i'm sure they know assembly well!
16:07:46 <lament> think: where do you have a higher chance of studying haskell, EE or CS? :)
16:08:03 <lament> hint: it's not EE
16:08:18 <ddarius> Where do you have a higher chance of doing mathematics?
16:08:33 <dmwit> In the math department!
16:09:11 <OceanSpray> screw it, I'm double majoring.
16:09:13 * Cale likes the way Waterloo is laid out :)
16:09:13 <ddarius> lament: Actually with Lava and BlueSpec and Wired ...
16:09:28 <Cale> There's a mathematics faculty, with a school of CS inside of it.
16:09:34 <ddarius> Also, Where do you have the higher chance of studying Java?
16:09:54 <OceanSpray> I'm trying to avoid that at all costs.
16:10:03 <Cale> Unfortunately, they still study Java in undergrad, since the co-op program has such a heavy influence on everything.
16:10:06 <OceanSpray> One year of AP "Computer Science" is enough.
16:10:36 <ddarius> OceanSpray: We did C++ when I went through though they were going to transition to Java.
16:10:40 <ddarius> (The next year actually)
16:10:59 <OceanSpray> Does anybody here know what languages they use at CMU?
16:11:28 <dmwit> English, I think. ;-)
16:19:16 <ddarius> dmwit: Could be German or Dutch.
16:20:00 <jsnx> it seems like I can class constrain a datatype two ways: `data C t => D t = D t` and `data D t = C t => D t`
16:20:04 <jsnx> are they the same?
16:20:36 <ddarius> jsnx: One is not Haskell 98.
16:20:42 <jsnx> oic
16:20:50 <jsnx> but they are otherwise equivalent :)
16:21:00 <Riastradh> Nope.
16:21:09 <jsnx> O.o
16:25:33 <tverwaes> higher chance of avoiding java... mit perhaps?
16:25:54 <tverwaes> at the vub I only touched java by chance in my last year (cs)
16:26:00 <tverwaes> go scheme-universities :)
16:29:09 <Riastradh> You would have a very low chance of avoiding Java at MIT.
16:29:33 <tverwaes> (I must admit I touched the joy of C and C++ :))
16:33:21 <sheyll> mozembed in gtk2hs always crashed when trying to open an ssl connection on my system. anyone similar problems?
16:34:57 <snhmib> bd_: thanks again for suggesting Dynamic, works like a charm =)
16:40:36 <jsnx> ddarius: so, i think i know how it's different
16:40:59 <jsnx> it's GADT style
16:41:00 <jsnx> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt-style
16:41:02 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
16:41:40 <jsnx> it makes the context available in pattern matches when i put the context on the right hand side in a data definition, yes?
16:49:33 <chessguy> > map f [1..3[
16:49:34 <lambdabot>  Parse error at end of input
16:49:42 <chessguy> > map f [1..3]
16:49:43 <lambdabot>  Add a type signature
16:49:50 <chessguy> > map f [1..3] :: Expr
16:49:51 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[b]'
16:50:12 <chessguy> > map f [1..3] :: [Expr]
16:50:14 <lambdabot>  [f 1,f 2,f 3]
16:53:39 <chessguy> > map f [x :: Expr, y :: Expr] :: [Expr]
16:53:41 <lambdabot>  [f x,f y]
17:03:09 <chessguy> > let c x = (x, [f x, g x]) in unfoldTree c (x::Expr)
17:03:10 <lambdabot>  Node {rootLabel = x, subForest = [Node {rootLabel = f x, subForest = [Node {...
17:03:48 <chessguy> hrm, is there somwehere i can find this Expr code somewhere?
17:03:53 <chessguy> @where Expr
17:03:54 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
17:07:07 <saml> Lam "x" (Lam "x" (App (App (Prim "+") (Var "x")) (Var "x")))  ==> Lam "x" (Lam "y" (App (App (Prim "+") (Var "y")) (Var "y")))   how can I do this for arbitrary Lam ?
17:12:15 <BONUS> say i have
17:12:22 <BONUS> [list comprehension] /= []
17:12:30 <EvilTerran> saml, what do you mean by "arbitrary Lam"?
17:12:32 <BONUS> will that stop evaulation as soon as one element pops up?
17:12:43 <EvilTerran> BONUS, i think you want not (null [...]), incidentally
17:12:45 <EvilTerran> but yes
17:12:52 <saml> EvilTerran: the expression might be \x -> \x -> \x -> ... arbitrary depth
17:13:00 <BONUS> ah
17:13:24 <EvilTerran> > not (null (undefined:undefined))
17:13:26 <lambdabot>  True
17:13:31 <EvilTerran> > (undefined:undefined) /= []
17:13:33 <lambdabot>  True
17:13:38 <dons> > [undefined] /= []
17:13:39 <lambdabot>  True
17:13:42 <dons> laziness ftw
17:14:05 <EvilTerran> :D
17:15:10 <byorgey> > not (null [1,sum [1..]])
17:15:12 <lambdabot>  True
17:15:18 <BONUS> kewl
17:18:01 <Saizan> saml: to explicitly renaming i'd walk down the expression tree carrying a list of yet-binded-vars, and substituting before recursing inside a lambda if you find another matching var
17:20:37 <jorick> i don't think you really win something with doing renaming explicitely before evaluation
17:21:12 <jorick> (well, at least for an interpreter ... case might be diffrent for a compiler)
17:21:15 <Saizan> yeah, neither in typechecking
17:22:05 <Saizan> managing scope/shadowing is not that much of a problem
17:22:41 <chessguy> @docs Data.Tree
17:22:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
17:22:52 <chessguy> @source Data.Tree
17:22:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/Tree.hs
17:23:05 <chessguy> sigh
17:24:47 <chessguy> @docs
17:24:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:28:02 <OceanSpray> oh man, there's this 12-year-old kid in #scheme asking to learn.
17:28:18 <OceanSpray> Cutest (computer-science-related) thing I've ever seen.
17:28:39 <lament> awwwwwwwwwwwwwwww
17:28:45 <ddarius> ...
17:28:46 <Saizan> i wish i knew scheme existed at 12..
17:29:31 <lament> i wish i never knew scheme existed
17:29:32 <dons> i wish i knew about haskell 1.1 when i was 12.
17:30:07 <dons> i wish haskell had hackage when i was 12.
17:30:14 <dons> we'd have a gatrillion libs by now
17:30:26 <orbitz> lament: you would
17:30:53 <saml> Saizan: for typechecking, how can I preperly set up scope so that I don't have to explicitly rename? I have  extendSubst :: Subst -> TI ()  that extends type substitution environment. that really messes things up
17:32:29 <chessguy> 12. bah, he should have written his own chess engine by now
17:33:19 <Saizan> saml: well i guess you have an environment like Map Var Type? when you enter a lambda you simply overwrite the value for that Var
17:34:13 <ddarius> chessguy: If nothing else, he should have written his own Scheme implementation by now.
17:34:41 <chessguy> as the saying goes, if he's written anything interesting, he already has :)
17:35:57 <Saizan> saml: this post might be interesting http://notvincenz.blogspot.com/2008/01/using-typechecker-monad-to-type-check.html
17:35:58 <lambdabot> Title: lambda.oasis: TypeChecking Lambda Calculus using TyperMonad (courtesy of Saizan), http://tinyurl.com/3ds6be
17:38:16 <chessguy> @pl \x -> f (g (f (f (g (f x)))))
17:38:16 <lambdabot> f . g . f . f . g . f
17:38:54 <Saizan> it's nice how local in the reader monad models so well the essence of scopes
17:38:54 <chessguy> is f . (g . f) the same as f . g . f ?
17:39:14 <ddarius> Saizan: That's not an accident...
17:39:43 <ddarius> chessguy: yes
17:40:09 <ddarius> (.) is associative
17:40:15 <Cale> chessguy: and indeed, that's the same as  (f . g) . f
17:40:32 <ddarius> Syntactically, I forget what the associativity of the operator is declared to be.
17:40:42 <ddarius> > \(. $)
17:40:42 <lambdabot>  Parse error at "$)" (column 5)
17:40:45 <ddarius> > (. $)
17:40:45 <lambdabot>  Parse error at "$)" (column 4)
17:40:45 <chessguy> ah, associative. i always get associativity and commutativity mixed up
17:40:51 <Cale> I believe it's defined to be right associative.
17:41:35 <Cale> f . (g . h) is a little more efficient than (f . g) . h
17:41:50 * ddarius has never confused associativity and commutativity.
17:41:51 <chessguy> wha....
17:41:53 <chessguy> why?
17:42:13 <Cale> Because it's f which needs to be applied first, and (g . h) might never need to be evaluated then.
17:42:37 <Cale> But in the second case, you always end up evaluating both compositions.
17:43:17 <Cale> (remember, lazy evaluation is outermost first)
17:43:19 <chessguy> oh, assuming a lazy context, ok
17:44:03 <chessguy> err, i suppose i should ask, how much of this is also true for mathematical functions?
17:44:19 <orbitz> chessguy: how about (f .) . y ieee!!!
17:44:31 <Cale> Well, with mathematical functions we don't really measure efficiency. Composition is still associative though.
17:44:39 <chessguy> orbitz: get back to ##c++ where you belong :)
17:44:43 <dobblego> is there a n-ary tree implementation in the standard libraries?
17:44:50 <orbitz> chessguy: i'm in two places at once
17:44:52 <orbitz> !
17:44:53 <Cale> dobblego: There's Data.Tree
17:45:22 <Cale> dobblego: It's not the prettiest thing in the world, but it might do the trick. I usually just invent my own tree types on the spot.
17:45:34 <dobblego> ok thanks
17:47:13 <midfield> @seen dons
17:47:13 <lambdabot> dons is in #haskell-hac4, #haskell-soc, #xmonad and #haskell. I last heard dons speak 17m ago.
17:47:48 <midfield> dons: is uvector ready for beta testing?  do i need to compile my own ghc to use it?
17:52:18 <ddarius> midfield: It works fine with 6.8.2
17:52:43 <midfield> ddarius: including stream fusion and all?
17:53:25 <ddarius> Yes
17:53:51 <midfield> ddarius: thanks
18:01:20 <ivanm> anyone here familiar with FGL?
18:02:53 <saml> http://hpaste.org/7428   I still can't figure out how to implement tInfer (Lam x e)  the testcase runs. test function should return t1 -> Int -> Int, but it returns Int -> t1 -> Int
18:04:55 <lurkymclurkleton> fred: you there?
18:11:24 <dalien> hi all :) I'm back with some stupid questions after exercising a bit... writing a small DNS server as an exercise, and spent quite some time to write the decoder for the strings in the requests - which look <len1>str1<len2>str2...<0> - http://hpaste.org/7429 - but wonder if there is a more straightforward way to do it
18:15:43 <Saizan> dalien: i'd probably not use DnsEnd
18:17:20 <dalien> i thought it should be doable with "Maybe ..." type
18:17:38 <Saizan> yeah
18:17:39 <dalien> since essentially I am doing the same thing, i think
18:18:01 <dalien> but my main wonder is around the woodoo to get the recursion
18:18:10 <dalien> DnsElement x y -> get >>= \dns -> return $ DnsStr (elem : get_element_list dns)
18:18:35 <dalien> this is ugly - i first get the same parent structure as myself, and then unwind it and get the element ... it looks very dirty :)
18:19:08 <dalien> i was thinking there's got to be a more "proper" way
18:20:54 <Saizan> http://hpaste.org/7429#a1
18:21:24 <Saizan> well, that's quite a common pattern with lists
18:21:38 <Saizan> you get a bit of noise due to the DnsStr contructor..
18:22:26 <dalien> aha
18:22:56 <Saizan> uh
18:23:02 <Saizan> i've made a mistake :)
18:23:11 <dalien> :-)
18:23:42 <Saizan> the second pattern is (Just elem') and then you've to use elem'
18:24:11 <saml> @pl (\x -> f)
18:24:12 <lambdabot> const f
18:24:36 <dalien> aha, let me poke around :)
18:24:43 <Saizan> (Just elem') -> fmap (DnsStr . (elem':) . get_element_list) get, would also work :)
18:27:12 <dalien> hmm this i still need to parse :) btw the ghc complained for the "Binary (Maybe DnsElement)" declaration - said need to use -XFlexibleInstances
18:27:39 <Saizan> not having DnsEnd means you don't have to worry about it later.. [] is sufficient to signal the end of the list
18:28:11 <dalien> hm and then when i enabled that it said it overlaps with a definition in Data.Binary... bigarre
18:28:46 <Saizan> oh, right, it overlaps with the (Maybe a) instance..
18:28:59 <dalien> aha
18:29:45 <Saizan> which won't do what you need
18:31:47 <ddarius> http://hpaste.org/7429#a3
18:32:51 <Saizan> http://hpaste.org/7429#a4 :)
18:32:59 <dalien> http://hpaste.org/7429#a5 :)
18:34:27 <Saizan> now take a mix :)
18:34:29 <dalien> although i think it's a bit of a cheat - since i use "0" as a way of saying "Nothing" :)
18:43:12 <zgold> What does <<loop>> indicate ?
18:43:33 <SamB> zgold: it means there is a blackhole in your program
18:43:45 <SamB> well, actually it means you have a value that is strict in itself
18:43:50 <SamB> for example:
18:43:52 <dons> an infinite loop, spotted by the runtime (a definition defined in terms of itself)
18:43:53 <SamB> > let x = x in x
18:44:02 <zgold> Thats what i suspected
18:44:08 <zgold> but im really curious as to how thats possible
18:44:09 <lambdabot>  thread killed
18:44:11 <zgold> in what im doing
18:44:25 <zgold> may i hpaste?
18:44:27 <dons> zgold: look very carefully at any recursion
18:44:32 <byorgey> zgold: of course
18:44:34 <zgold> there is no recursion ><
18:44:45 <byorgey> that's what YOU think ;)
18:44:45 <SamB> you could compile for profiling and use +RTS -xc
18:44:57 <zgold> http://hpaste.org/7430
18:45:02 <jamii_> Does anyone know how to turn views on in ghci? The wiki makes it sound likes its been implemented but I cant find the right option
18:45:19 <SamB> jamii_: what the heck there are no views?!?
18:45:38 <byorgey> zgold: the definition of 'lobbys' is recursive
18:45:46 <zgold> OH
18:45:47 <SamB> indeed!
18:45:48 <zgold> Jesus
18:45:50 <byorgey> zgold: note that defining 'lobbys' in a let like that shadows the parameter
18:45:50 <jamii_> This page (http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns) talks about what has been implemented so far
18:45:53 <lambdabot> Title: ViewPatterns - GHC - Trac
18:46:04 <SamB> zgold: I thought it would be something like that ;-)
18:46:09 <zgold> Silly naming
18:46:10 <byorgey> zgold: so the 'lobbys' on the rhs of the = is the same one being defined, NOT the parameter to the function
18:46:13 <zgold> I coded in java yesterday
18:46:17 <byorgey> hehe
18:46:19 <zgold> hence why my style today sucks
18:46:32 <zgold> Problem solved ><
18:46:44 <ddgromit> is there a way to convert an Integer to an Int?
18:46:46 <Cale> jamii_: I'm not sure any of those changes are available outside the development GHC. (At least, I'd be interested if they were...)
18:46:54 <Cale> ddgromit: fromIntegral
18:47:08 <Cale> ddgromit: It'll convert from any integer-like type to any numeric type.
18:47:20 <ddgromit> numeric type includes primitives?
18:47:25 <jamii_> Cale: Would they be in Head, maybe? They would make my set munging much prettier
18:47:27 <SamB> ddgromit: no!
18:47:33 <Cale> ddgromit: Primitives?
18:47:37 <SamB> only things in Num
18:47:50 <SamB> ddgromit: primitives aren't even first-class!
18:47:54 <jamii_> I guess I could use patter guards for now
18:47:58 <jamii_> *pattern
18:48:21 <SamB> jamii_: I was under the impression that views had been implemented long ago and removed since
18:48:39 <Cale> View Patterns are different from Views
18:48:44 <SamB> jamii_: and the current consensus seems to be that pattern guards are a lot more usable for the purpose
18:49:01 <ddgromit> k im going to investigate this further
18:49:05 <SamB> ah, yes, I had heard about some new thing
18:49:07 <jamii_> Cale: Ok, I was wanting view patterns rather than views
18:49:26 <SamB> that is probably in HEAD
18:49:27 <jamii_> SamB: Do you know why they were removed? Are we both talking about the same thing?
18:49:38 <SamB> of course, HEAD is just a word we use for the latest darcs
18:49:39 <Cale> Actually, I'm not sure they were ever implemented.
18:49:43 <Cale> (Views proper)
18:49:48 <Cale> Well, at least not in GHC.
18:49:55 <SamB> Cale: well, I'm fuzzy on that point
18:50:13 <jamii_> Cale: Whats the difference? It was just the view patterns I was after, but Im curious now
18:50:16 <SamB> but if it ever was, it was before my time
18:50:25 <Cale> I doubt they would have been removed. I think the reason they weren't popular was that they were too much work to implement relative to the benefit.
18:50:47 <Cale> Or maybe they just made the language spec more complex than seemed warranted...
18:50:53 <Cale> I don't remember very well either.
18:50:56 <SamB> Cale: they would have been removed
18:51:15 <SamB> the work involved in implementing them does not end
18:51:28 <Cale> That's a reasonable point.
18:52:35 <SamB> @go "view patterns"
18:52:37 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
18:52:37 <lambdabot> Title: ViewPatterns - GHC - Trac
18:52:51 <ddarius> Some version(s?) of SML have views.
18:53:08 <jamii_> Yep. That page says that they were implemented, but not where
18:53:31 <SamB> NEAT
18:53:35 <jamii_> I'm trying to compile qtHaskell at the moment but Ill see if ghc head has view patterns later
18:53:36 <SamB> I LOVE IT
18:53:58 <SamB> I WANT TO EAT THEM AND IMPLEMENT THEM IN JHC!
18:54:27 <SamB> jamii_: seeing as that page is on the GHC trac wiki, it seems reasonable to expect them to be in HEAD
18:54:45 <jamii_> Excellent. Will make sets fun again
18:55:43 <SamB> (since you say the page says they are implemented)
18:55:50 <dolio> @yow!
18:55:50 <lambdabot> He probably just wants to take over my CELLS and then EXPLODE inside me
18:55:50 <lambdabot> like a BARREL of runny CHOPPED LIVER!  Or maybe he'd like to
18:55:50 <lambdabot> PSYCHOLIGICALLY TERRORISE ME until I have no objection to a RIGHT-WING
18:55:50 <lambdabot> MILITARY TAKEOVER of my apartment!!  I guess I should call AL PACINO!
18:56:11 <EvilTerran> blimey
18:56:46 <SamB> pages on the GHC trac that state that a feature is implemented generally mean that he feature is implemented in GHC, unless otherwise implied or stated
18:57:51 <dolio> I don't recall GHC ever having view patterns.
18:58:21 <SamB> dolio: do you usually recall features that are only implemented in HEAD?
18:58:52 <dolio> I remember there was talk of implementing them at one point within maybe the last year, but haven't heard of anything since.
18:59:04 <dolio> Are they in HEAD?
18:59:43 <SamB> either that or in a branch, I guesss...
19:00:08 <SamB> but such a branch is probably found in the directory listing of darcs.haskell.org?
19:01:01 <Saizan> does JHC handle MTCPs and fundeps?
19:01:02 <dolio> Hmm. I had HEAD built a few days ago. I should have checked.
19:02:24 <SamB> Saizan: not unless someone sneaked them in without sending anything to the mailing list!
19:02:29 <SamB> seems unlikely
19:02:55 <SamB> or I suppose they could have implemented them within the last 8 hours and sent a mail then...
19:03:14 <SamB> but I suppose then it would be in my inbox
19:03:27 <dolio> Maybe they announced it on the super-secred no-SamBs-allowed list. :)
19:04:53 <jamii_> dolio: Is that still a secret then...?
19:05:07 <dolio> Oh no!
19:05:13 <SamB> John specifically stated that he'd be happy for me to make changes towards the eventual goal of implementing MPTCs when I was working on class aliases
19:05:23 <SamB> dolio: relax
19:05:48 <SamB> the list is secret until the URL/mail-address gets out
19:05:57 <dolio> Whew.
19:08:01 <SamB> hmm, man, I had no idea it was going to be this trivial to prove that ++ was associative for Data.DifferenceList. well, trivial in the sense that I only had to figure out how to refer to the reflective property of a Setoid...
19:08:18 <SamB> (note: I speak of Agda, not Haskell)
19:11:22 <Cale> Heh, I thought you were referring to English and thought "hey, what's the big deal about that?" :)
19:12:51 <sw17ch> is there something similar to the POSIX select() call for MVar's?
19:13:21 <SamB> in English it would be quite trivial -- in english, I could expect the reader to know that function composition is associative ;-)
19:13:24 <sw17ch> tryAny ([a,b,c,d] :: [MVar a])
19:13:27 <sw17ch> ?
19:13:35 <Cale> SamB: indeed.
19:14:43 <Apocalisp> Does haskell have an equivalent to typed exceptions?
19:15:13 * SamB wonders if there is any way to keep the TeX emacs input method from messing up strings beginning with _
19:15:51 <SamB> Apocalisp: typed?
19:15:59 <Saizan> sw17ch: no.. you've to use threads or something else
19:16:42 <sw17ch> Saizan, alright. thanks. this is my first foray into GHC.Conc and MVars
19:16:43 <SamB> @hoogle MVar a -> IO (Maybe a)
19:16:44 <lambdabot> GHC.Conc.tryTakeMVar :: MVar a -> IO (Maybe a)
19:16:44 <lambdabot> Control.Concurrent.MVar.tryTakeMVar :: MVar a -> IO (Maybe a)
19:17:00 <sw17ch> @hoogle [MVar]
19:17:01 <lambdabot> No matches, try a more general search
19:17:01 <SamB> sw17ch: or try STM
19:17:27 <sw17ch> SamB: can you be more specific? or is this a "go figure it out" thing?
19:17:58 <SamB> sw17ch: this is probably more a "wait for someone else to point out why STM won't help" kind of thing ;-)
19:18:05 <sw17ch> :)
19:18:16 * SamB wanders off to do some non-computer tasks
19:18:24 <sw17ch> I'm (trying) to write a UDP based voice client.
19:23:24 <jamii_> Oooh. qtHaskell is shiny
19:23:41 <jamii_> Although it probably isnt supposed to segfault when I click a button.
19:24:02 <zgold> l.o.l.
19:24:18 <sw17ch> can the case statement be convinced to point multiple patterns to the same place?
19:24:39 <sw17ch> case x of "a" | "b" -> doSomething; "c" | "d" -> doSomethingElse
19:25:33 <Cale> sw17ch: 'case expression', and no, there are no or-patterns unfortunately
19:25:42 <sw17ch> Cale, oh well. thanks :)
19:26:12 <Cale> sw17ch: You can however use 'let' to define some common thing and use it in multiple cases.
19:26:32 <sw17ch> Cale, yes, that's what i'm doing
19:34:58 <sw17ch> @hoogle queue
19:34:59 <lambdabot> No matches found
19:40:45 * SamB_XP really seriously wonders what about Agda makes it use so much RAM!!!
19:40:58 * SamB_XP is beginning to suspect the Emacs interface...
19:42:32 <zgold> Alright maybe im being naive
19:42:49 <zgold> But whats an elegant way to open a file, find something in it, change it, and writeback?
19:42:58 <TomMD> sed?
19:43:07 <zgold> :)
19:43:24 <zgold> You really suggest a syscall to sed?
19:43:28 <cjs_> Make sure you put an mv ahead of that sed.
19:43:29 <TomMD> No, no.
19:44:28 <zgold> TomMD: ?
19:44:39 <cjs_> zgold: Typically I slorp the whole file into memory, munge it, and write the whole thing out again.
19:44:40 <TomMD> zgold: I don't deal with files much in my programming so I'm betting someone else could help you better/easier.
19:44:48 <cjs_> But be careful if you're using lazy I/O.
19:45:10 <zgold> cjs_: thats what i was afraid of.  I dont have big files so computationally im OK... its just ugly
19:45:41 <cjs_> I'm assuming small files, but read the whole thing into a non-lazy ByteString, close the file, munge, and open/write/close.
19:45:44 <SamB_XP> zgold: just be carefull about writing to the same file you read from in GENERAL
19:45:44 <cjs_> What's ugly about it?
19:46:18 <zgold> code wise, i have to read line by line, check if its the line i want, etc. etc.
19:46:18 <cjs_> Yeah, what SamB_XP said. Most of my systems read from a source file and write to a destination file, like a compiler or whatever.
19:46:28 <SamB_XP> personally, I wouldn't want to write programs that did that
19:46:32 <cjs_> Ah, string processing in Haskell!
19:46:35 <SamB_XP> since I hate it when programs eat my files
19:46:45 <SamB_XP> and I probably wouldn't be careful enough to avoid it...
19:47:04 <cjs_> Actually, you can probably do that pretty cleanly. Processing a list of lines is not really any different from processing anything else.
19:47:05 <zgold> I mean... emacs does it every couple seconds...
19:47:18 <SamB_XP> does what?
19:47:25 <zgold> Writes to a file it read
19:47:30 <zgold> Just have to be careful :_
19:47:32 <zgold> :)*
19:47:32 <SamB_XP> which one?
19:47:48 <zgold> No idea how it does its backup things
19:48:18 <SamB_XP> does it read them?
19:48:27 <zgold> SamB_XP: -> #emacs
19:48:31 <SamB_XP> well, I mean, sure it checks for them...
19:48:52 <SamB_XP> anyway, emacs has been much better tested than anything I will write will likely ever be...
19:49:10 <SamB_XP> at least in regards to such fundamental activities as that
19:49:53 <TomMD> zgold: You do know that you have access to all the regular C fundamentals (namely, seek) through System.IO, right?
19:50:11 <zgold> TomMD: Nope, but I don't know where in the file im going anyway
19:50:13 <TomMD> I figured you were just asking for a cleaner / higher level / functional method.
19:50:48 <SamB_XP> what are you looking for?
19:50:58 <SamB_XP> one time-honoured method is "sed"
19:52:50 <TomMD> SamB_XP: That sed comment brings us full circle ;-)
20:00:52 <mxc> @hoogle openfile
20:00:53 <lambdabot> System.IO.openFile :: FilePath -> IOMode -> IO Handle
20:00:53 <sebaseba> Can anyone help me? I'm getting a link error whenever I import Data.Set.
20:01:23 <SamB_XP> sebaseba: how are you linking?
20:01:50 <sebaseba> ghc program.hs -o program
20:02:03 <SamB_XP> you either need -package or --make
20:02:07 <SamB_XP> or you could use Cabal
20:02:40 <sebaseba> Thanks! Worked with --make. Why is that?
20:02:55 <cjs_> Anyway, TomMD, just hack out something, make sure you've got tests for it, and you can refactor it later into something nicer.
20:02:57 <ivanm> because that's the right parameter? :p
20:03:02 <SamB_XP> because --make is smart enough to pull in the package that Data.Set is in
20:03:15 <SamB_XP> but -o program is not
20:03:45 <sebaseba> I see. I guess all the imports I did so far never needed a package to be pulled in.
20:06:33 <bos> @users
20:06:33 <lambdabot> Maximum users seen in #haskell: 460, currently: 411 (89.3%), active: 16 (3.9%)
20:06:33 <TomMD> What, huh
20:07:31 <TomMD> cjs_: I think you were looking for zgold, right?  Unless you were takling about the Foreign.C proposal on the ML.
20:07:51 <cjs_> Oops, no, that was for zgold.
20:08:37 <cjs_> I saw a blog comment the other day complaining about how there were hundreds of people here talking about Haskell, and only about 30 people on the ColdFusion channel talking about their personal lives.
20:09:48 <TomMD> Ha! We have 45 people talking about personal lives on haskell-blah!
20:10:06 <mib_4ytuwl> hey guys, i created a search index to contain locations of all my search in a list [1,2,3,4] i want to call back that search index, but each time, it must call back the one after the one i chose first [1,2,3,4] chooses 1 then 2.. 3.. 4 .. and so on, how can i accomplish this, tried a queue, but it doesn't seem to be working for me
20:10:43 <ivanm> anyone here familiar with FGL?
20:12:53 <zgold> Well, that didn't turn out to be half as ugly as i expected
20:13:30 <TomMD> zgold: Great!  Time to blog about the solution ;-)
20:13:44 <zgold> its simply a where'd function using an accumulator
20:17:48 <mxc> @hoogle trace
20:17:48 <lambdabot> Debug.Trace.trace :: String -> a -> a
20:17:48 <lambdabot> Debug.Trace :: module
20:17:48 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
20:30:27 <mib_4ytuwl> any help guyS???
20:31:16 <TomMD> Help is only provided after questions are asked ;-)
20:31:24 <TomMD> err, scratch that
20:33:31 <ivanm> lol
20:33:32 <dmwit> mib_4ytuwl: The "map" function iterates over a list.
20:34:43 <glguy> mib_4ytuwl: can you give another example?
20:37:07 <mib_4ytuwl> search "glguy" >> found "glguy at:" [(0,3), (5,6) ... and so on] >> index stores these locations >> find1 "glguy" >> (0,3), the next i run it, it should give me : find1 "glguy" >> (5,6)
20:38:24 <ivanm> State monad?
20:38:32 <glguy> and where did you want to store information about the last location
20:38:38 <mxc> @hoogle putTraceMsg
20:38:39 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
20:39:43 <dmwit> I would suggest restructuring the function that uses find1 into either a map or a fold, rather than diving into State monads.
20:40:21 <mxc> is trace considered harmful?
20:40:54 <SamB_XP> mxc: what do you mean?
20:41:00 <mxc> i know that its not technically pure
20:41:15 <mib_4ytuwl> glguy what i did was to write the location to a file then read it back when needed
20:41:20 <mxc> and feels a little bit like unsafeIO, but since you're only outputting, it should be 'pure enough
20:41:33 <SamB_XP> it can be considered as pure, if you simply decide that writing to stderr doesn't count as a side effect...
20:41:57 <SamB_XP> (sure, it also forces the string, but you could do that with seq anyway)
20:42:20 <dmwit> mxc: It's probably not a great idea to use trace in production code, but *man* is it handy for debugging.
20:43:10 <SamB_XP> so, QUITE harmful if you actually wanted to use stderr for something else
20:43:15 <mib_4ytuwl> hey guys, just a random question. do u think it's easier to create a compiler in a functional language ?
20:43:16 <SamB_XP> otherwise not a big deal
20:43:23 <SamB_XP> mib_4ytuwl: totally
20:43:41 <SamB_XP> how is that random?
20:43:58 <mib_4ytuwl> wrong word sorry
20:44:33 <lament> we don't know much about functional languages, but Haskell seems particularly suited for some of the tasks involved :)
20:44:40 <SamB_XP> isn't that one of the top 5 things to write in FP languages?
20:44:44 <ivanm> @faq writing compilers
20:44:44 <lambdabot> The answer is: Yes! Haskell can do that.
20:44:49 <ivanm> ;-)
20:45:15 <lament> mib_4ytuwl: particularly parsing is spectacular; i don't know about the rest of the stuff but i suspect it gets messier
20:45:23 <mib_4ytuwl> SAMB_XP i have to write a compiler, we can use any language we want, i was thinking of using haskell... we have like a month (project starts in december), but i am doing my research from now
20:45:31 <sebaseba> > filter (>5) [1..10]
20:45:33 <lambdabot>  [6,7,8,9,10]
20:45:33 <lament> mib_4ytuwl: and of course a "real" compiler, that is, seriously optimized, will be very very hairy code in any language
20:45:46 <SamB_XP> mib_4ytuwl: do you know haskell?
20:46:05 <SamB_XP> mib_4ytuwl: what do you know, and what are you compiling?
20:46:08 <EvilTerran> you can get a bit of the muck out of the way by using lex+yacc, mind. or, in haskell's case, alex+happy
20:46:15 <mib_4ytuwl> well... not like u guys, i ordered some books, should be here soon
20:46:22 <SamB_XP> which ones?
20:46:26 <EvilTerran> and there's various other utils you can hook into along the way
20:46:36 <EvilTerran> generating C code and letting gcc do the optimisation, that kinda thing :P
20:46:42 <SamB_XP> I love alex, and happy is okay
20:46:58 <EvilTerran> i tend to use parsec by default, for both lexing and parsing
20:47:03 <ivanm> EvilTerran: which utils do that?
20:47:06 <mib_4ytuwl> well we have to build a programming our language, it suppose to mimic the actions of a actual like, but yet retain it's uniqueness
20:47:33 <SamB_XP> you mean you are making your own unique toy languages?
20:47:34 <EvilTerran> ivanm, i meant gcc was the util. generating C code is the way you use it. ;P
20:47:49 <SamB_XP> which are recognizable as programming languages?
20:48:00 <EvilTerran> rather than having your compiler produce its own assembly or bytecode
20:48:02 <ivanm> EvilTerran: ahhh, -fviac ? :p
20:48:07 <EvilTerran> indeed.
20:48:08 <ivanm> or whatever the ghc flag is
20:48:09 <mib_4ytuwl> yes
20:48:13 <SamB_XP> ivanm: except with less evil
20:48:38 * ivanm thought EvilTerran meant there were specific haskel utils/libs to help create optimized C-code for a specific problem
20:48:59 <EvilTerran> sadly not, that i know of
20:49:02 <mib_4ytuwl> the thing is, it  must not be dependent on the language it was built in after cmpilation
20:49:16 <mib_4ytuwl> sorry for the errors
20:50:30 <mib_4ytuwl> can u give me a like a guide as to what i would have to learn please
20:50:46 <dmwit> cs143.stanford.edu
20:51:16 <dmwit> Your class will likely be very similar.
20:51:18 <underscore> If anyone has time for a newbie question! I'm looking for a synchronization structure that does multiple-wakeup (as opposed to MVar single-wakeup).
20:51:49 <underscore> (The implicit question being, of course: which part of the library should I look at to find it?)
20:55:12 <mxc> @hoogle trim
20:55:12 <lambdabot> Data.ByteString.Internal.createAndTrim :: Int -> (Ptr Word8 -> IO Int) -> IO ByteString
20:55:12 <lambdabot> Data.ByteString.Internal.createAndTrim' :: Int -> (Ptr Word8 -> IO (Int, Int, a)) -> IO (ByteString, a)
20:55:45 <sw17ch> is there a good built in FIFO structure?
20:55:55 <dmwit> Lists?
20:56:02 <gwern> sw17ch: lists?
20:56:19 <sw17ch> with O(1) ***
20:56:22 <sw17ch> forgot that qualifier
20:56:28 <midfield> @seen dons
20:56:28 <lambdabot> dons is in #haskell-hac4, #haskell-soc, #xmonad and #haskell. I last heard dons speak 2h 12m 1s ago.
20:56:31 <underscore> Finite or infinite?
20:56:33 <sieni> lists a fifo?
20:56:37 <sw17ch> infinite
20:56:46 <sw17ch> queue
20:57:00 <sw17ch> nothing obvious came to mind for an O(1) queue in Haskell
20:57:11 <dmwit> Oops, I was thinking LIFO, sorry.
20:57:13 <glguy> lists are amortized O(1) pop
20:57:14 <dolio> Data.Sequence?
20:57:17 <SamB_XP> sw17ch: they exist
20:57:17 <glguy> if you keep two of them
20:57:25 <SamB_XP> sw17ch: try okasaki's book
20:57:27 <dmwit> sw17ch: For FIFO, use ([], []).
20:57:29 <sieni> glguy: sure
20:57:34 <sw17ch> glguy, i have more concern about the append
20:57:41 <dmwit> sw17ch: The first list is forwards, the second list is backwards.
20:57:51 <dmwit> sw17ch: It's O(1) for insert and pop.
20:57:55 <mxc> @hoogle whitespace
20:57:55 <lambdabot> Text.ParserCombinators.Parsec.Token.whiteSpace :: TokenParser st -> CharParser st ()
20:57:56 <dmwit> (amortized)
20:57:57 <SamB_XP> sw17ch: or if you don't want to buy that, you could look at his thesis
20:57:58 <gwern> sounds almost like a zipper
20:58:05 <glguy> Data.Sequence has efficient access to edge elements
20:58:13 <dmwit> gwern: Very similar.
20:58:14 <SamB_XP> glguy: but that's O(log n)
20:58:27 <SamB_XP> gwern: except this one has to flip lists
20:58:38 <sw17ch> dmwit, so, i pop off the first [], and when the first [] is empty, replace it with the reversed second list and empty the second?
20:58:52 <sieni> sw17ch: yeah, using two lists is nice, except you might occasionally have to spend some time reversing a list
20:58:53 <mxc> @hoogle space
20:58:54 <lambdabot> Text.ParserCombinators.Parsec.Char.space :: CharParser st Char
20:58:54 <lambdabot> Language.Haskell.TH.PprLib.space :: Doc
20:58:54 <lambdabot> Data.Char.Space :: GeneralCategory
20:58:57 <dmwit> sw17ch: Exactly.
20:59:06 <SamB_XP> sieni: but that's O(1) amortized
20:59:10 <sw17ch> dmwit, works great for my situation, i think... :)
20:59:15 <SamB_XP> sieni: which is just fine if you aren't doing realtime
20:59:16 <sieni> sw17ch: but on average that's still O(1)
20:59:22 <sw17ch> amortized is more than enough for me
20:59:31 <sieni> SamB_XP: yes, obviously
20:59:33 <sw17ch> especially if this thing runs with the throughput that i hope it does
20:59:33 <SamB_XP> and realtime is probably not a terribly good application of Haskell ;-)
20:59:47 <sw17ch> SamB_XP, hehe... we'll see :)
20:59:53 <underscore> No ideas wrt multiple wakeup?
21:00:01 <sw17ch> i'm trying to write a distributed data client
21:00:05 <sw17ch> voice/text/images
21:00:05 <sw17ch> etc
21:00:12 <glguy> underscore: I think that you didn't get responses because no one knew what yo uwere asking for
21:00:14 <sw17ch> send once, gets to whole network graph
21:00:23 <dolio> The Data.Sequence docs say (|>) and viewl are O(1).
21:00:24 <SamB_XP> sw17ch: you do know that realtime has a specific technical meaning, I hope?
21:00:32 <sw17ch> oh yes, i do :)
21:00:35 <SamB_XP> sw17ch: not like in RTS ;-P
21:00:47 <sw17ch> :)
21:01:00 <SamB_XP> well, personally I would avoid realtime *in* haskell because it would be a bitch debug
21:01:03 <sw17ch>  realtime as in data that needs to be processed immediately in order to be useful?
21:01:15 <sw17ch> such as voice/video?
21:01:15 <dolio> So if you use it like a queue, the operations should be O(1).
21:01:16 <dmwit> Yeah, realtime as in there is a hard deadline.
21:01:19 <underscore> Ah-- sorry. In Java, for example, you can .wait() on an object. This will block the thread until someone else calls .notify() on that object. This is similar to MVar's semantics for taking/tryPutting unit, I think.
21:01:22 <TomMD> Don't let the nuclear core over heat type of real time?
21:01:39 <glguy> underscore: check out: Control.Concurrent.Chan.dupChan
21:01:44 <underscore> Java also has a .notifyAll(), which wakes up all threads that have .waited on a particular object.
21:01:47 <glguy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html#v%3AdupChan
21:01:48 <lambdabot> http://tinyurl.com/3953km
21:02:05 <SamB_XP> sw17ch: well, a realtime has to take O(1) every operation, even if it means that the 1 must be much bigger than an amortized data structure...
21:02:06 <sw17ch> TomMD, i think that's still RTOS ground
21:02:28 <SamB_XP> sw17ch: I said not like an RTS
21:02:39 <SamB_XP> oh, btw, I was referring to the genre of game
21:02:42 <SamB_XP> not runtime systems
21:02:43 <dmwit> underscore: I seem to remember the paper on the concurrency primitives showing how to use single-cast primitives to make a multicast channel.
21:02:55 <sw17ch> SamB_XP, oh... hah!
21:03:04 <sw17ch> suddenly things are a little clearer :)
21:03:18 <dmwit> underscore: I suddenly can't remember the name of the paper, though... =/
21:03:53 <SamB_XP> of course, GHC's RTS isn't realtime anyway
21:04:21 <SamB_XP> but that doesn't necessarily mean there are no applications for realtime data structures...
21:04:50 <ivanm> SamB_XP: so whoever named the RTS lied? :o
21:05:04 <SamB_XP> ivanm: no, they just meant "not turn based"
21:05:44 <dmwit> underscore: "Tackling the Awkward Squad"
21:05:51 <dmwit> underscore: Section 4 is on concurrency.
21:06:15 <underscore> glguy: Thanks! I'm a little confused, though-- if I write unit to a channel created with dupChan and read it from another thread, won't that thread consume the value and leave the rest waiting?
21:06:30 <underscore> dmwit: Thanks as well-- I have the paper right nearby, one second
21:06:56 <ivanm> SamB_XP: lol
21:07:23 <ivanm> underscore: you do realise that thanks to you, "Ah" and "well" have negative karma? :o
21:07:30 <ivanm> :p
21:07:40 <ivanm> not to mention "though"
21:07:43 <dmwit> though++
21:07:44 <dmwit> well++
21:07:46 <SamB> @karma Ah
21:07:47 <lambdabot> Ah has a karma of -1
21:07:49 <ivanm> heh
21:07:51 <SamB> @karma well
21:07:51 <lambdabot> well has a karma of 0
21:07:56 <dmwit> Ah++
21:07:56 <SamB> @karma though
21:07:56 <lambdabot> though has a karma of 0
21:08:02 <SamB> @karma Ah
21:08:02 <lambdabot> Ah has a karma of 0
21:08:05 <SamB> @karma ah
21:08:05 <lambdabot> ah has a karma of 0
21:08:13 <SamB> @karma oh
21:08:13 <lambdabot> oh has a karma of 0
21:08:14 <wagle_home> @karma though
21:08:14 <lambdabot> though has a karma of 0
21:08:16 <dmwit> Problem solved. =P
21:08:46 <ivanm> dmwit: so are you the official cleaner of this channel, fixing up everyone's mistakes and messes? :p
21:09:40 <dmwit> Okay, time to get some actual work done.
21:09:47 <underscore> Hee. Is there a better way to form an em-dash, or is the channel just trying subtly to influence my writing?
21:09:48 <ivanm> yeah, that stuff :s
21:09:58 <ivanm> underscore: leave spaces on either side?
21:10:11 <wagle_home>  --
21:10:12 <ivanm> e.g. this is an em-dash -- did you like it?
21:10:15 <wagle_home> @karma
21:10:16 <lambdabot> You have a karma of 0
21:10:21 <wagle_home> @karma ""
21:10:21 <lambdabot> "" has a karma of 0
21:10:23 <SamB> hahahaha
21:10:28 <wagle_home> @karma
21:10:29 <lambdabot> You have a karma of 0
21:10:29 <SamB> ""++
21:10:33 <SamB> @karma ""
21:10:33 <lambdabot> "" has a karma of 1
21:10:35 <SamB> hah
21:10:45 <ivanm> @karma " "
21:10:46 <lambdabot> " has a karma of -3
21:10:47 <ivanm> :p
21:11:02 <SamB> "++" increases the karma of whatever came right before it ;-P
21:11:18 <sw17ch> @hoogle Sequence
21:11:18 <lambdabot> Data.Sequence :: module
21:11:18 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
21:11:18 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
21:11:23 <sw17ch> is Data.Sequence infinite?
21:11:25 <wagle_home> @karma "
21:11:25 <lambdabot> " has a karma of -3
21:11:30 <sw17ch> ...finger trees... right?
21:11:58 <wagle_home> @karma
21:11:59 <lambdabot> You have a karma of 0
21:12:13 <bos> infinite?
21:12:14 <sw17ch> @karma c
21:12:14 <lambdabot> c has a karma of 15
21:12:16 <sw17ch> @karma C
21:12:16 <lambdabot> C has a karma of 15
21:12:23 <ivanm> that's just wrong....
21:12:27 <ivanm> @karma haskell
21:12:27 <lambdabot> haskell has a karma of 24
21:12:32 <ivanm> that's better though!
21:12:34 <sw17ch> @karma c++
21:12:35 <lambdabot> c++ has a karma of -8
21:12:39 <sw17ch> c++--
21:12:41 <sw17ch> @karma c++
21:12:41 <lambdabot> c++ has a karma of -9
21:12:42 <ddarius> I'd like an infinite sequence of the naturals with O(1) append to end.
21:12:44 <wagle_home> how many lines of C in Haskell?
21:12:46 <ivanm> heh
21:12:48 <sw17ch> c--++
21:12:51 <sw17ch> @karma c--
21:12:51 <lambdabot> c-- has a karma of 4
21:12:57 <ivanm> wagle_home: only in the RTS IIRC
21:13:32 <ivanm> that's why we should use cpp instead of 'c':'+':'+':[] :p
21:13:36 <wagle_home> doesnt that give C some karma?  *<8-D
21:13:36 <underscore> Does GHC still compile down to Henk?
21:14:04 <SamB> did it ever?
21:14:10 <SamB> I mean, did mainline ever?
21:14:21 <underscore> I'm not certain.
21:14:22 <ivanm> what's henk?
21:14:26 <ddarius> No it didn't.
21:14:31 <SamB> right now it's using a system F_C variant
21:15:46 <bos> 98917 lines of C in GHC HEAD.
21:16:05 <SamB> bos: why do you mention it?
21:16:16 <SamB> whatever you do, don't mess with Java's karma
21:16:17 <bos> wagle_home asked.
21:16:21 <underscore> Aw, that's a little sad. It was a neat paper.
21:16:43 <SamB> underscore: JHC uses a Henk variant
21:16:45 <bos> 422665 lines of haskell, by comparison.
21:16:46 <wagle_home> @karma java
21:16:47 <lambdabot> java has a karma of -23
21:17:21 <underscore> dmwit++ , glguy++ : Thanks for the help!
21:19:21 <mxc> @hoogle length
21:19:21 <lambdabot> Prelude.length :: [a] -> Int
21:19:21 <lambdabot> Data.List.length :: [a] -> Int
21:19:21 <lambdabot> Data.ByteString.length :: ByteString -> Int
21:20:53 <sw17ch> hmm.... is there any way, when using Network.Socket.recv on a UDP socket, to figure out which host the information came form?
21:20:55 <sw17ch> from*
21:22:06 <mib_4ytuwl> is it possible to create a unbreakable encryption algorithm ?
21:22:16 <sw17ch> mib_4ytuwl, one time pads
21:22:18 <mib_4ytuwl> i tried, but i manage to crack them
21:22:40 <ivanm> mib_4ytuwl: put it this way... do you want to be able to decrypt it?
21:22:46 <mxc> is there an easy way to have ghci suppress the printing of a large value?
21:23:05 <ivanm> if so, then with enough computing resources it's possible to break any algorithm, using brute force if nothing else
21:23:08 <ddarius> Oi, homegrown cryptography is as bad as homegrown random number generators.
21:23:11 <mxc> ie ab <- liftM lines $ getContents ...
21:23:21 <ddarius> ivanm: You can't break a one-time pad.
21:23:30 <ivanm> ddarius: doh, forgot about them
21:23:35 <sw17ch> :)
21:23:46 <ivanm> not using computing/mathematical means, anyway
21:23:54 <ivanm> you're reduced to social engineering
21:23:59 <sw17ch> the best thing about one time pads, is you can fake the key to make it say whatever you wish
21:24:11 <sw17ch> at least, in my mind
21:24:20 <ivanm> ddarius: actually, you can.... _if_ they're not used properly (i.e. used more than once)
21:24:44 <sieni> sw17ch: yeah, and also the ciphertext and the key are symmetric, so you really can't say which one is which
21:24:44 <ivanm> sw17ch: there's a famous example by Edgar Allan Poe (?) where the key translated the message to all "e"s
21:24:44 <ddarius> ivanm: And I can crack you encryption if you give me your private key.
21:24:52 <ivanm> ddarius: true ;-)
21:25:22 <ivanm> with one-time-pads, brute-force can give you a message.... but you can't tell if it's the correct one :p
21:25:23 <sw17ch> hmm... back to my question of a few lines ago... is it possible to gather where data came from when doing a recv on a UDP socket?
21:25:23 <sieni> ddarius: not necessarily
21:25:28 <sclv> sw17ch: otp + hash :-)
21:25:38 <ivanm> sclv: then you can't reverse it to get the message
21:25:42 <ivanm> which defeats the point
21:25:55 <sclv> sorry, that was supposed to be a product type.
21:26:03 <sieni> ddarius: you can't for example crack the contents of an ssh session even if you know the private keys of the parties
21:26:12 <bd_> mib_4ytuwl: To my knowledge, there is no proof that there does not exist an encryption algorithm with a fixed-size reusable key where determining the k-bit key from an arbitrary amount of chosen-plaintext messages requires less than O(2^k) time. However, there exists no proof that there does exist one either.
21:26:17 <sclv> I guess I should have said otp :*: hash
21:26:58 <sieni> ddarius: since you need to know the session key, for which you need the temporary data generated at either end of the connection
21:27:14 <ivanm> bd_: fine, prove us wrong and find such an encryption! :p
21:27:17 <sieni> diffie-hellman ftw
21:28:03 <ivanm> sieni: nah, Clifford Cocks ftw!
21:28:28 <sclv> quantum: bogocrypt -- I send random bits, and you decrypt it with random bits and in some universe it works out.
21:28:30 <ivanm> wait, not him....
21:28:39 <bd_> ivanm: Well, if such a thing does exist, here is an algorithm: Let the key be a pair of programs on a turing machine which transform the message on the tape from plaintext to ciphertext and vice-versa. The encryption and decryption programs execute the key on the tape. The key generation algorithm, of course, is left as an exercise to the reader. :)
21:28:42 <ivanm> sclv: that's not how quantum encryption works...
21:29:13 <ivanm> bd_: lol "the key generation algorithm is trivial, and left as an exercise for the interested reader" <-- that sounds better :p
21:29:19 * sclv is duly chastened.
21:29:23 <bd_> sclv: Quantum encryption is more about using the write-once, read-once nature of certain quantum entites to detect eavesdropping :)
21:29:29 <bd_> IIRC anyway
21:29:30 <ivanm> sieni: I meant James Ellis
21:30:16 <sclv> it's by analogy.
21:30:20 <sclv> ?go quantum bogosort
21:30:22 <lambdabot> http://en.wikipedia.org/wiki/Bogosort
21:30:32 <ivanm> http://en.wikipedia.org/wiki/Non-secret_encryption#History
21:31:24 <ivanm> sclv: write a haskell implementation!
21:32:09 <ivanm> with that java code there, isn't having it sorted in inverse order a valid bogosort?
21:32:29 <ivanm> wait, forget that last comment :p
21:32:35 <ivanm> I thought it was a shuffling algorithm :s
21:34:05 <bd_> Quantum bogoshuffle: Do nothing. In one of the many possible worlds, cosmic rays will have permuted your list for you.
21:35:14 <sclv> ?ty return . randoms =<< getStdGen
21:35:16 <lambdabot> forall a. (Random a) => IO [a]
21:35:16 <ivanm> bd_: according to the wiki article, it's not _quite_ right
21:35:23 <sclv> done!
21:35:28 <dmwit> ?ty fmap randoms getStdGen
21:35:31 <lambdabot> forall a. (Random a) => IO [a]
21:35:51 <sclv> ?ty randoms <$> getStdGen
21:35:53 <lambdabot> forall a. (Random a) => IO [a]
21:36:13 <ivanm> Quantum bogoshuffle: randomly sort the list.  Since the number of such shuffles is finite, there will be at least one universe with the list being sorted.  Destroy the other universes.
21:36:21 <sclv> and thus the quantum bogocrypt golfing contest comes to a close on this lazy monday evening.
21:36:36 <ivanm> golf? I don't recall anyone mentioning golf...
21:36:52 <bd_> ivanm: All actual implementations settle with destroying merely the earth, however.
21:36:59 <dmwit> ?ty randoms . getStdGen
21:37:01 <lambdabot> forall a. (Random a) => IO [a]
21:37:07 <SamB> doesn't the quantum bogoshuffle require several pieces of specialty hardware?
21:37:08 <dmwit> sclv: I got you beat. ;-)
21:37:08 <mib_4ytuwl> would one time pad make sense in haskell, especially on a memory basis (u remembering)
21:37:14 <ivanm> bd_: heh
21:37:19 <sclv> caleskill! no fair!
21:38:03 <sclv> apparently quantum bogoshuffle is atomic :-)
21:38:20 <sclv> either the list is sorted, or you are not.
21:38:32 <sclv> you are really really not.
21:38:51 <dmwit> Well, I'm glad we got that sorted out.
21:39:02 <dmwit> It's just the sort of thing that always gives me trouble.
21:40:21 <bd_> sclv: It is actually vitally important not to observe the list until it is completely sorted.
21:40:41 <sw17ch> oh good gosh, it was just recvFrom
21:40:44 * sw17ch smacks self
21:40:54 <sw17ch> that's a badly named function...
21:43:22 <sw17ch> well, i'll consider that a win for tonight. goodnight all
21:44:48 <mib_4ytuwl> is it possible to create a truley random number in haskell?
21:45:03 <sieni> mib_4ytuwl: what kind of question is that?
21:45:12 <dmwit> Anything written in software is inherently deterministic.
21:45:13 <sw17ch> mib_4ytuwl, is it possible in C? :)
21:45:18 <sieni> mib_4ytuwl: is it possible to create a truly random number in software?
21:45:32 <Caelum> it's not possible to create a truly random number on a computer (at least until we have quantum computers or something)
21:45:33 <Twey> A truly random number?  Certainly, you just need something that can pick up background radio noise from the air.
21:45:49 <Twey> Oh 'create.'
21:47:50 <sieni> mib_4ytuwl: but if you really need something really random (whatever that means) you need to use hardware for that, but a good approximation is to get a few bytes of data from /dev/urandom, pick your favourite cipher and start encrypting zeros with the key you just obtained from /dev/urandom
21:48:43 <mib_4ytuwl> i was trying to create the one time pad encryption >> but i was thinking of creating random brute force cracker which mimic the save results random number in ghc in like say about every 1Million tries ?
21:49:01 <bos> Caelum: that's quite incorrect.
21:49:22 <Twey> randomNumber = 4 -- Generated by roll of a fair die, guaranteed to be random.
21:49:22 <sieni> mib_4ytuwl: are you trying to crack a one time pad? good luck with that
21:52:15 <sclv> its a fun exercise to create something that given two messages encrypted with the same otp decrypts them.
21:52:33 <sclv> or better yet, that given n messages of which m share onetime pads, to do so.
21:53:54 <sw17ch> sclv: if you use a key on the same two messages, and then xor the messages, doesn't that produce the key?
21:54:35 <sclv> give it a try and see.
21:54:35 <mib_4ytuwl> dew to the fact that haskell geneartes pseudo-random numbers and not random codes i think it code be broken
21:54:49 <sw17ch> sclv, yep...
21:54:50 <sw17ch> :)
21:54:58 <SamB> what did I say about the special hardware?
21:55:12 <SamB> you need not only a hard RNG, but also a universe-destruction-device
21:55:16 <sw17ch> mib_4ytuwl, every piece of software can only generate pseudo-randoms
21:55:56 <sw17ch> mib_4ytuwl, if you really need random data, you need to stick some probe out into the universe and collect them from the noise
21:56:17 <mib_4ytuwl> oh cool
21:56:30 <mib_4ytuwl> that's a great idea
21:56:33 <mib_4ytuwl> thanks
21:56:41 <sw17ch> for example... dd if=/dev/dsp of=key count=1024 size=1 will give you a 1024 byte key
21:56:45 <sw17ch> of somewhat random data
21:57:01 <sw17ch> but you're best off running over the bytes produced by that and modding them by some value
21:57:28 <sw17ch> or, better yet, cycle over the words (int/long int) and then use that as the key
21:57:53 <sclv> (x + k) - (y + k) = x -y, no?
21:58:07 <sclv> there's still some work left to extract the messages...
21:58:53 <dmwit> Surely for symmetry it would be x + y.
21:59:11 <sw17ch> mib_4ytuwl, i had the arguments to dd wrong..
21:59:14 <dmwit> (Though I will note that x - y = x + y, mod 2.)
21:59:19 <sw17ch> dd if=/dev/audio of=key bs=1 count=1024
21:59:36 <sw17ch> make sure that the microphone is picking stuff up midrange
21:59:45 <sw17ch> you don't want it peaked and you don't want it silent
22:00:23 <sw17ch> that's as close i can get to real random data without more hardware
22:00:31 <sw17ch> (and even that is predictable)
22:00:38 <sw17ch> to some degree
22:03:15 <dmwit> sclv: I think it's a hard problem; you have to consider every possible key and see if it produces two intelligible decryptions, right?
22:03:59 <sclv> as i recall there are tricks to make it work faster
22:04:10 <ivanm> sw17ch: http://random.org/
22:04:11 <lambdabot> Title: RANDOM.ORG - True Random Number Service
22:05:02 <sclv> you can ignore the key entirely and just consider statistically what two messages would produce the appropriate sum
22:06:15 <sclv> so figure out what you would expect common sequences of differences to be, based on dictionary frequencies, etc. its a bit fancier but subject to lots of conventional methods... not that i know them all very well.
22:06:36 <dmwit> ah
22:06:44 <dmwit> Those crypto guys are pretty clever.
22:19:47 <mib_gfr1te> 	hey guys, i wanna write a haskell function to open/close my cd tray with module can i used to acess the preipherals
22:20:56 <dmwit> That is a genuinely new question, I think.
22:21:15 <dmwit> Probably the best thing you can do right now is like (spawn "eject cdrom") or so.
22:21:15 <mib_gfr1te> can it be done?
22:21:16 <lament> @faq can haskell open and close the CD tray?
22:21:16 <lambdabot> The answer is: Yes! Haskell can do that.
22:21:21 <lament> @faq are you sure?
22:21:21 <lambdabot> The answer is: Yes! Haskell can do that.
22:21:24 <dmwit> i.e. call out to another program that does it.
22:21:56 <Twey> @faq Can Haskell eat frogs?
22:21:56 <lambdabot> The answer is: Yes! Haskell can do that.
22:22:04 <mib_gfr1te> anything simpler like >> opensesimi cd >>
22:22:50 <lament> mib_gfr1te: No. Obviously this is very platform-dependent
22:25:32 <sw17ch> > System.system "eject"
22:25:33 <lambdabot>   Not in scope: `System.system'
22:25:36 <sw17ch> > System.system "eject -t"
22:25:36 <lambdabot>   Not in scope: `System.system'
22:25:42 <sw17ch> will open/close the cd tray
22:26:20 <sw17ch> hmm, i would have expected the type of system to be System :: [String] -> IO ExitCode
22:26:30 <sw17ch> instead of System :: String -> IO ExitCode
22:29:06 <mib_gfr1te> well i think that's something u guys need to think about, peripheral linkage
22:29:48 <dons> mib_gfr1te: hehe, what OS are you on?
22:30:06 <jsnx> i am trying to find out what the difference is between `data C t => D t = D t` and `data D t = C t => D t`
22:30:45 <dolio> jsnx: The second isn't valid syntax, is it?
22:31:08 <jsnx> dolio: it's not haskell 98
22:31:13 <jsnx> dolio: but it works in ghc
22:31:19 <mib_gfr1te> my work requires me to use all three sun, linux, windows, i think it should be pretty easy on linux and sun, but the windows system poses a challenge?
22:31:21 <sw17ch> mib_gfr1te, seems like something that would be done through a dbus library or something similar rather than defining openCDTray in Prelude or System
22:31:26 <dolio> Huh. Wouldn't have guessed that.
22:31:36 <jsnx> i came on here earlier, and some enigmatic people said there was a difference, but would not explain it
22:31:42 <bos> mib_gfr1te: no, it's not easy on any platform.
22:31:55 <bos> mib_gfr1te: on linux, there are four device-specific ways to eject something.
22:32:36 <sw17ch> mib_gfr1te, what exactly do you need to do with the devices any way?
22:33:08 <mib_gfr1te> in linux could simply link the compiler to the system and execute the eject command
22:33:24 <jsnx> mib_gfr1te: i don't think i have ever seen openCDTray as a language primitive
22:33:36 <jsnx> or part of the base libraries
22:33:57 <cjs_> sw17ch: No, I think that String rather than [String] is correct; typically the "system" function passes a command line to the shell for interpretation. [String] would be what you'd pass to exec.
22:33:57 <sw17ch> what if the machine doesn't even have a CD drive?
22:34:20 <sw17ch> cjs_: perhaps i'm just drawing a parallel between similarly named functions in other languages
22:34:25 <mib_gfr1te> what about writing it in C and using FFI to run in haskell, can that be done?
22:34:29 <sw17ch> i believe that python/perl/ruby all do system the same way
22:34:43 <sw17ch> system("cmd", "arg0", "arg1", ..)
22:34:47 <jsnx> sw17ch: they use varargs, though
22:35:04 <jsnx> so you could just do "cmd arg0..."
22:35:21 <sw17ch> mib_gfr1te, why can't you just use the "system" function?
22:35:32 <dolio> jsnx: Did my message go through? (My connection is flaky, apparently.)
22:35:39 <sw17ch> jsnx, i suppose i can deal with system (unwords argarry)
22:35:40 <sw17ch> :)
22:35:54 <cjs_> If you have a look, ruby overloads the function to hand it to the shell or not based on the number of arguments. system("echo *") shows you a list of files; system("echo", "*") shows you "*".
22:36:01 <jsnx> dolio: no, did not receive message
22:36:08 <cjs_> And exec in Ruby does the same thing. It's just one of those weird things in Ruby.
22:36:14 <dolio> jsnx: The first one constrains all the constructors of D, effectively ensuring that the only 'D t's you can construct are for ts in class C.
22:36:30 <jsnx> dolio: and the second?
22:36:46 <mib_gfr1te> can the system function open the drive?
22:36:47 * SamB thought python's system was as useless as Cs
22:37:05 <mib_gfr1te> or be used to write a function that does
22:37:08 <jsnx> dolio: it's equivalent in the single constructor case, right?
22:37:10 <dolio> jsnx: But due to the way h98 is, that fact isn't available when you match on Ds, so you still have to qualify all functions over Ds.
22:37:15 <bos> actually, the first goes beyond that. it requires that every *use* of D mentions the C context.
22:37:32 <jsnx> mib_gfr1te: yes, you can use the system function
22:37:48 <cjs_> Actually, I think that perl is the same. But note that in C, system(3) is a library function that takes one argument and passes a command to the shell.
22:37:50 <jsnx> dolio: okay
22:37:52 <dolio> jsnx: I'm still experimenting, but apparently the second is like the GADT version, where it stores the evidence that t is in C.
22:38:03 <jsnx> dolio: that makes sense
22:38:21 <jsnx> i prefer that, needless to say
22:38:49 <sw17ch> mib_gfr1te, system "eject"
22:38:55 <sw17ch> that will open the tray in linux
22:39:01 <sw17ch> try it from ghci
22:39:12 <jsnx> i even came on the channel and said as much, but no one replied so i was not sure
22:39:25 <sw17ch> mib_gfr1te, System.system "eject"
22:40:01 <dolio> jsnx: I didn't realize the second was even valid, but apparently it works with -XExistentialQuantification or -XGADTs.
22:40:18 <jsnx> dolio: i think i must have those on all the time in GHCi
22:40:43 <mib_gfr1te> closing the drive seems to be a killer
22:41:18 <sw17ch> System.system "eject -t"
22:42:04 <dolio> jsnx: Yeah, 'data D t = C t => D t' is the same as 'data D t where D :: C t => t -> D t'.
22:42:53 <dolio> Note that if you have 'data D t = C t => D t | E t' the C t context only applies to D.
22:43:32 <dolio> Whereas 'data C t => D t = D t | E t' will constrain both constructors (and is useless).
22:48:30 <mib_gfr1te> hey guys if i wanted info on a file how could i get that e.g. getinfo "test.txt" (readonly, 475475 bytess .... blahhhh...)
22:54:54 <sw17ch> mib_gfr1te, http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhFileSize
22:54:56 <lambdabot> http://tinyurl.com/sbkmj
22:55:05 <sw17ch> System.IO has all that stuff
22:55:28 <mib_gfr1te> anyone as experience with th haskell kate highlighter?
22:55:58 <sw17ch> mib_gfr1te, works fine for my install
22:56:01 <sw17ch> i use VIM primarily though
22:59:44 <cjs_> mib_gfr1te, system can do whatever you can do from the command line. On NetBSD, at least, "eject -l" will load media (i.e., close the drive).
23:00:55 <mib_gfr1te> ok
23:01:02 <mib_gfr1te> cjs_ thanks
23:01:05 <SamB> hmm, you know, it's really  crazy how long it took me to prove that Data.DifferenceList iss a Monoid...
23:01:08 <cjs_> mib_gfr1te, there's also a lot of unix syscall- and library-equivalant functions in the various System.Posix packages.
23:01:10 <SamB> (in Agda)
23:01:13 <dancor> is there a cute way to convert Either MyError a to Maybe a
23:01:34 <SamB> most of it was waitingg for Agda to reload the module I was working in, though, I guess...
23:01:36 <mib_gfr1te> sw17ch which version r u running (kate highlighter)
23:02:08 <Cale> :t either (const Nothing) Just
23:02:10 <lambdabot> forall a a1. Either a1 a -> Maybe a
23:02:16 <jamii> My kate highlighter is a bit manky. Not as good as hsColour
23:02:22 <sw17ch> mib_gfr1te, 3.5.8 ... that's my version of kate... i don't know if the highlighter for KDE is versioned differently
23:02:26 <dancor> nice
23:02:54 <dolio> SamB: Isn't it pretty trivial?
23:02:58 <mib_gfr1te> cw17ch i am talking about the package not the application kate sorry?
23:03:58 <dolio> 'Endo = record { Îµ = id ; _â_ = _â_ ; âidâ = refl ; âidâ = refl ; âassoc = refl }' from my playing-around Agda library.
23:04:16 <mib_gfr1te> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/highlighting-kate-0.2.1
23:04:19 <lambdabot> http://tinyurl.com/5zdxhr
23:05:07 <mib_gfr1te> ever tried it?
23:05:27 <sw17ch> mib_gfr1te, no, i have not
23:07:13 <mib_gfr1te> oh
23:08:22 <mib_gfr1te> sw17ch i creating a syntax highlighter inside my text editor (written with wxhaskell) , but i can't seem to get it how i want it
23:09:05 <sw17ch> mib_gfr1te, you're out of of my skill set now :)
23:09:38 <mib_gfr1te> sw17ch why u say that?
23:09:51 <sw17ch> i've never worked with wxHaskell or the Kate highlighting libraries
23:10:18 <sw17ch> not to mention im' quite tired and am going to go to bed now. best of luck. :)
23:10:46 <mib_gfr1te> oh cool, well then later
23:28:43 <dmwit> ?botsnack
23:29:08 <ivanm> @botsmack
23:34:49 <mxc> anyone around for a newbie-ish GHCi question?
23:35:56 <mxc> if i have a function foo :: Handle  -> IO [String] and I want to bind a var in the top level, say like temp <- foo hnd
23:36:27 <mxc> is there a way to prevent GHCi from printing the output of Show on the entire contents of temp?
23:37:45 <cjs_> Use let?
23:37:53 <twifkak> cheesy way: do temp <- foo hnd; return ()
23:38:33 <twifkak> uh, no, i take that back :)
23:41:09 <dmwit> Yes, there's a way.
23:42:15 <dmwit> :unset -fprint-bind-result
23:42:45 <dmwit> (@mxc)
23:43:03 <mxc> woohoo
23:43:08 <mxc> thanks dmwit
23:44:43 <twifkak> hrm.. didn't work for me, but :set -fno-print-bind-result did
23:45:34 <dmwit> Works here, ghc 6.8.
23:45:44 <dmwit> Maybe you're on a different version?
23:45:54 <mxc> works for me
23:47:33 <twifkak> yeah, 6.6
23:47:54 <twifkak> (macports is waaaaaaay behind)
23:48:04 <dolio> Dude, you type system is way old.
23:50:08 <twifkak> (yeah, my haskell hacking's been on the dl; luckily, xmonad doesn't use type families... yet)
23:50:31 <dolio> Heh. It's only a matter of time.
23:51:51 <twifkak> oh, i'm wrong. macports is up-to-date.
23:54:23 <cjs_> Phew! Chapter 2 is long. I could only get the first half done today. http://www.cynic.net/LittleHaskeller.lhs
23:56:37 <cpoucet> cjs_: neat :)
