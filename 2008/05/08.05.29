00:00:19 <dmwit> :t forkIO
00:00:23 <lambdabot> IO ()
00:00:26 <tieTYT> dmwit: that's not the return, that's just up into that point
00:00:40 <tieTYT> it did 2 == 1 and returned false
00:00:45 <dmwit> Oh, sure.
00:00:47 <luqui> i.e., note indentation
00:00:51 <tieTYT> then it continues to the next element in the list
00:01:02 <tieTYT> so map has to evaluate on the next elemetn
00:01:06 <tieTYT> that becomes 2
00:01:09 <tieTYT> no wait
00:01:11 <tieTYT> 1 + 1
00:01:19 <tieTYT> and then it does 2 == 1 + 1
00:01:24 <tieTYT> then 2 == 2 then true
00:01:25 <tieTYT> and that's the result
00:01:29 <dmwit> tieTYT: I think you've got the idea now.
00:01:47 <tieTYT> i hope
00:01:49 <dmwit> Wait, forkIO :: IO () ?
00:01:50 <dmwit> really?
00:01:52 <a13x> no luck with newtype Events = Events [Event], i have to rewrite my  functions
00:01:52 <tieTYT> but this seems like something really easy to forget :)
00:02:11 <mmorrow> IO ThreadId
00:02:17 <dmwit> ?undefine
00:02:18 <lambdabot> Undefined.
00:02:21 <dmwit> :t forkIO
00:02:23 <lambdabot> Not in scope: `forkIO'
00:02:26 <dmwit> good
00:02:31 <mmorrow> heh
00:02:49 <dmwit> :t Control.Concurrent.forkIO
00:02:50 <lambdabot> IO () -> IO GHC.Conc.ThreadId
00:02:56 <dmwit> That looks *much* more reasonable.
00:03:13 <dmwit> a13x: yep
00:03:14 <joed> i hate xml..
00:03:21 <joed> Sorry, wrong window.
00:03:29 <dmwit> a13x: Of course, this is where mauke reminds you that there is another option.
00:03:34 <tieTYT> joed: was that meant for #java
00:03:54 <dmwit> a13x: Replace all your calls to (==) with calls to whatever implementation you were going to give (==) anyway.
00:03:59 <joed> tieTYT: No, actually for customer code, I'm working on a laszlo application.
00:04:15 <tieTYT> ah, i've heard that's a good tool
00:04:28 <tieTYT> joed: I didn't know you were into haskell
00:04:33 <a13x> dmwit: then i will have to write my own `elem` function
00:04:43 <dmwit> :t find
00:04:44 <tieTYT> you're not one of those people that constantly goes OT about it in #java
00:04:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
00:04:53 <dmwit> :t (isJust .) . find
00:04:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:05:00 <dmwit> a13x: done
00:05:07 <mauke> :t elemBy
00:05:09 <lambdabot> Not in scope: `elemBy'
00:05:31 <a13x> dmwit: and any other function which executes ==, messy
00:05:32 <joed> tieTYT: Of course :) And no, there is no point in debating what Java may lack that a FP language has.
00:05:37 <dmwit> a13x: yes
00:05:42 <dmwit> a13x: You get your choice of messes.
00:05:52 <tieTYT> joed: that doesn't stop most people
00:05:59 <tieTYT> dmwit: just to drive it home: upperCase (x:xs) = toUpper x : upperCase xs
00:06:00 <dmwit> a13x: You do have to tell the compiler what you want to do.
00:06:06 <tieTYT> using that just to print
00:06:29 <mmorrow> al3x: i meant {-# LANGUAGE TypeSynonymInstances #-}, not {-# LANGUAGE -XTypeSynonymInstances #-}
00:06:44 <joed> tieTYT: Those would be idiots. I've received so much great advice in terms of thinking here, that would help in call it object design.
00:06:48 <mmorrow> {-# OPTIONS_GHC -XTypeSynonymInstances #-} would also work
00:06:56 <tieTYT> dmwit: actually I have a question
00:07:06 <dmwit> I have an answer!
00:07:08 <dmwit> Let's trade.
00:07:09 <a13x> mmorrow: what does that do?
00:07:26 <mmorrow> al3x: that would just enable that particular language extension
00:07:43 <tieTYT> if i want to print upperCase "abc", does it go toUpper 'a' : upperCase ["bc"], evaluate the LHS and then continue?
00:07:48 <mmorrow> {-# OPTIONS_GHC -fglasgow-exts #-} enables that one and more
00:08:18 <dmwit> ?src print
00:08:19 <lambdabot> print x = putStrLn (show x)
00:08:26 <dmwit> ?src putStr
00:08:27 <lambdabot> putStr s  = hPutStr stdout s
00:08:27 <tieTYT> joed: would you prefer to do everything in haskell if you had a choice?
00:08:31 <tieTYT> or do you like both languages?
00:08:40 <joed> tieTYT: We don't have closures here so we don't need to talk about em.
00:08:57 <mmorrow> pretty much, the only time you use LANGUAGE to be specific about what youre using is when you want to do so for demonstration purposes or you're releasing a lib
00:08:58 <dmwit> tieTYT: Well, if we assume character-at-a-time output (I figure it's pretty likely), then see if you can answer the question yourself.
00:09:30 <joed> tieTYT: if I had the tools, experience, and know how - sure.
00:09:35 <dmwit> putStr [] = return (); putStr (x:xs) = primitivePutStr x >> putStr xs
00:09:59 <dmwit> Actually, that kind of delves into areas we may want to avoid for now.
00:10:03 <tieTYT> joed: so how familiar are you with haskell?
00:10:10 <mmorrow> joed: the only way to get those is to not have them, want them, then decide to get them
00:10:10 <tieTYT> yeah i donno what >> is
00:10:22 <tieTYT> but if I assume character at a time... doesn't it kinda not matter?
00:10:34 <tieTYT> I already know i'm going to print every character at that point
00:10:44 <joed> tieTYT: I like the elegance and whatnot else, doing a customer based solution around rest, soap and mtom right now would have me billing little.
00:10:58 <dmwit> tieTYT: Yeah, so, I think what ends up happening is that each character is printed before the remainder of the list is evaluated.
00:11:08 <mmorrow> joed: that process goes alot quicker if you just start doing it. (burn those bridges).
00:11:19 <cjs> What's wrong with "type Point = (Num x, Num y) => (x,y)"?
00:11:29 <dmwit> So, putStr (upperCase "abc") -> { putChar 'A'; putStr (upperCase "bc") }
00:11:33 <cjs> I get "Illegal polymorphic or qualified type."
00:11:34 <a13x> mmorrow: where do i put {-# LANGUAGE TypeSynonymInstances #-}?
00:11:35 <tieTYT> dmwit: ok, regardless, that's pretty much consistent with the way lazy evaluation works in general, right?  Regardless of what really happens, there's a benefit to pretending it works that way, no?
00:11:36 <dmwit> Don't know if that answers your question.
00:11:46 <joed> mmorrow: Very true. I burned those bridges a while back in Java and I have paying customers :) - I'm not arguing you.
00:11:57 <mmorrow> joed: it goes alot quicker that way because it become a matter of necessity, nor just occasional desire
00:12:08 <joed> mmorrow: Indeed.
00:12:09 <mmorrow> i'm not arguing either
00:12:18 <mmorrow> just describing my personal experience
00:12:21 <tieTYT> let me know: toUpper 'a' turns into 'A' and then it continues with : upperCase "bc"
00:12:25 <tieTYT> the rest is straight forward
00:12:29 <dmwit> right
00:12:32 <joed> mmorrow: If I snuck haskell in now I'd be strangled by co-contractors.
00:12:55 <mmorrow> heh. start your own business! program in only haskell.
00:13:14 <tieTYT> joed: I'm thinking about sneaking some haskell into my job :)
00:13:29 <mmorrow> well, not *only* haskell...
00:13:32 <tieTYT> (12:12:14 AM) GF: babies you want me to suck your monads?
00:13:35 <tieTYT> (12:13:10 AM) tieTYT: where did you learn that word?
00:14:17 <dmwit> O_o
00:14:40 <mxc> tieTYT:  lance armstrong
00:15:32 <mmorrow> al3x: oh, at the top of your src file. if you have another pragma already the (e.g. {-# OPTIONS_GHC ... #-}), put it on the second line.
00:15:37 <mxc> joed: strangle them first, preemptively
00:15:50 <tieTYT> my company has this app
00:15:51 <mmorrow> al3x: s/already the/already the/
00:15:53 <a13x> mmorrow: doesn't seem to change anything
00:16:32 <tieTYT> written in java, and it utilizes threading, and takes screenshots of websites
00:16:34 <a13x> mmorrow: do i put > ?
00:16:47 <tieTYT> you think tha'd be a good project to rewrite in haskell?
00:16:57 <mmorrow> al3x: ah, I didn't mean to imply that it would
00:17:09 <mmorrow> al3x: was just speaking in general
00:17:12 <joed> mxc: Heh, I like these people. tieTYT I did that, was met with large amounts of wrath
00:17:36 <mxc> joed>  wow, sucks that you gotta kill them
00:17:41 <tieTYT> wrath like, "Now we can't get rid of this guy?"
00:17:59 <a13x> mmorrow: ghci -XTypeSynonymInstances does change error message
00:18:32 <a13x> mmorrow: Overlapping instances for Eq Events
00:19:28 <joed> tieTYT: Well that they did, and called me for a month straight after, I think I made more contracting than empolyed and then they sent the same complainer to an Erlang course. Pretty funny as I only wrote a few cli filters.
00:20:05 <mmorrow> al3x: nice
00:20:42 <tieTYT> did you write it in erlang or haskell?
00:20:52 <mmorrow> al3x: you can add stuff to the file .ghci in your ~ (or i have no idea on windows) to make them always be there in ghci
00:21:21 <mmorrow> al3x: you should add ":set -fglasgow-exts" to it right now
00:21:32 <mmorrow> al3x: imho
00:22:04 <dmwit> I disagree that adding TypeSynonymInstances and OverlappingInstances (and maybe IncoherentInstances?) is the right solution to this.
00:22:23 <dmwit> Seriously, just bite the bullet and newtype your [Event].
00:22:54 <mmorrow> al3x: overlapping instances extension (more an allowance) isn't enabled by -fglasgow-exts. add OverlappingInstances to the LANGUAGE pragma (assuming you want to go this path)
00:22:55 <joed> tieTYT: I wrote it in Haskell as I was bored, I was asked to automate systems, the CTO still calls me, he was happy, the complainer was friends with the CFO (This a VC startup) and he said I was a bad influence as I used ruby, Haskell and Java in a mix and deploying these compilers to each servers would cause a serious load.
00:23:15 <vixey> hehehe
00:23:18 <dmwit> joed: =/
00:24:00 <joed> The load actually went down...
00:24:15 <vixey> joed++
00:24:44 <mmorrow> it seems like the only way you can use haskell on the job without people resisting is if you are your boss, or your boss is his boss because that then lets *him* use haskell on the job
00:24:54 <tieTYT> the thing I would have complained about is that it'll raise the learning curve for the maintainer
00:25:03 <mmorrow> yeah, me too
00:25:15 <mmorrow> not complained, but i worry about that
00:25:26 <quicksilver> al3x, dmwit : looks like a pretty harmful Eq instance to me. I would just make it a function.
00:25:27 <joed> tieTYT: and how would JPA, EJB3, etc not do that?
00:25:28 <tieTYT> and i say this hypocritically, as I use stripes/wicket/struts in the webapps i create
00:25:34 <tieTYT> they would
00:25:35 <quicksilver> YMMV
00:25:42 <tieTYT> but at least they're all java.  You can leverage that knowledge
00:25:59 <tieTYT> if you saw me ask questions in this channel, you'll notice that for me haskell is like learning my first language all over again
00:25:59 <joed> For some value of it sure.
00:26:07 * quicksilver shows tieTYT a #haskell-yellowcard for use of the word 'leverage'.
00:26:18 <luqui> tieTYT, that is extremely common of course...
00:26:20 <joed> tieTYT: Same here.
00:26:33 <quicksilver> If people start saying 'enterprise' I'm going to get nasty.
00:26:34 <quicksilver> ;)
00:26:38 <tieTYT> luqui: of course, but i think it indicates the learning curve
00:26:44 <joed> tieTYT: I don't know Haskell, I sit here and listen
00:26:50 <tieTYT> joed: I see
00:28:08 <joed> tieTYT: to me knowing is similar to I don't need to ask on IRC unless I run into an issue where I feel I'm right and the author is wrong.
00:28:10 <tieTYT> same case for the ruby part?
00:28:26 <cjs> Can I use a class qualification in a type declaration?
00:28:29 <tieTYT> didn't understand that sentence..
00:28:38 <quicksilver> cjs: you should not.
00:28:41 <joed> tieTYT: No, ruby is to perl like to be hard.
00:28:42 <quicksilver> as a general rule.
00:28:55 <a13x> thanks a lot for your help, guys
00:29:15 <cjs> So everywhere I'd rather say Point, I need to say (Num n) => (n,n)?
00:29:15 <quicksilver> it's often handy to think of the class context as not really being 'part of the type'
00:29:16 <tieTYT> joed: no offense, but is english your first language?
00:29:29 <joed> tieTYT: Nope. Swedish.
00:29:31 <quicksilver> cjs: more often, Num n => Point n
00:29:31 <tieTYT> ah
00:29:37 <tieTYT> that's amazing, i never noticed until now
00:30:02 <joed> tieTYT: I just came off a contract... So I indulged in some wine.
00:30:13 <tieTYT> ah, that's helping
00:30:22 <mxc> mmorrow> any idea what the windows equivalant of ~/.ghci would be?
00:30:30 <cjs> quicksilver: Why is that?
00:30:40 <cjs> Oh, wait, I see what you mean.
00:30:40 <mmorrow> mxc: heh, none
00:30:41 <tieTYT> anyway back to haskell.  A threaded app that takes screenshots of websites.  Is that a good candidate for haskell?
00:31:06 <tieTYT> mxc: somewhere under C:\Documents and Settings
00:31:15 <quicksilver> tieTYT: well the actual taking screenshots part requires a full HTML renderer? :)
00:31:17 <tieTYT> C:\Documents and Settings\Your User
00:31:25 <tieTYT> quicksilver: yes
00:31:47 <quicksilver> then that's not suitable for haskell, no, because writing a full HTML renderer is about 5 man-years of work :)
00:31:47 * dmwit suggests a greasemonkey script instead
00:31:47 <tieTYT> and it'll definitely need JS support
00:32:18 <tieTYT> dmwit: can haskell somehow tie in there?
00:32:18 <quicksilver> I would recommend reusing an existing renderer, probably gecko.
00:32:22 <dmwit> Or maybe even just a shell script that calls firefox and import.
00:32:49 <tieTYT> at this point i should just think of another project.  This already "works" as a java version
00:32:57 <joed> Hhe
00:32:58 <dmwit> tieTYT: I don't think shoehorning Haskell into a bad area is a good way to get your bosses'/coworkers' approval rating of Haskell up.
00:33:11 <mxc> tieTYT - you could just download the HTML and any linked images to an archive and just use FFox as the view
00:33:17 <tieTYT> dmwit: trying to test the waters here.  I don't know what haskell's bad areas are
00:33:35 <joed> tieTYT: do something rather complex/funny/not easy in Java instead.
00:33:41 <mxc> in which case you'd just be doing a fair bit of parsing so not that bad
00:33:44 <tieTYT> mxc: no i can't, cause the home page may use JS to redirect to another page
00:33:52 <mxc> joed> like write stable software?
00:33:59 <tieTYT> in which case, i want to take a screenshot of the redirected to page
00:34:05 <joed> mxc: That I do my friend....
00:34:08 <dmwit> tieTYT: You could certainly use Haskell to script firefox and a screenshoter.
00:34:18 <dmwit> I wouldn't recommend Haskell as anything more than glue, though.
00:34:23 <dmwit> (In this use case.)
00:34:31 <joed> mxc: I'm often accused of over-testing deliverables
00:34:45 <mxc> joed> with much more difficulty than is necessary.
00:35:11 <mxc> joed> ok, you can be productive without having to turn adjectives into crappy-business-speak-nouns
00:35:11 <joed> mxc: In the Java world, sure, but I'm paid for it.
00:35:16 <mxc> (deliverable)
00:35:21 <joed> Haha
00:35:22 <mmorrow> eh! i've been on and off looking for something to do just that (get images of a website given a url and you're a script). one way that seemed promising used a virtual X framebuffer but i never got any method to work
00:35:50 <mmorrow> that makes me think of my favorite shell command!
00:36:00 <mmorrow> cat /dev/urandom > /dev/fb0
00:36:05 <dmwit> Or, hell, just use one of the many web-services that screenshots sites.
00:36:36 <dmwit> mmorrow: permission denied: fb0 =P
00:36:37 <tieTYT> dmwit: i thought of that
00:36:41 <mmorrow> i need it to be self contained and dependency (that i don't have the source to) free
00:36:41 <joed> Writing a restful image thing grabber should be easy.
00:36:42 <tieTYT> or even snap.com
00:36:45 <luqui> cat /dev/urandom > /dev/dsp   # make sure your volume is on max though, otherwise you won't hear it
00:36:49 <mmorrow> sudo cat /dev/urandom > /dev/fb0
00:37:00 <mmorrow> yeah, that one's good too
00:37:01 <dmwit> mmorrow: Same error. (!)
00:37:05 <tieTYT> joed: you might be right.  Unfortunately, nobody in the world seems to be able to define restful
00:37:20 <mmorrow> oh, make sure /dev/fb0 is writeable as root
00:37:48 <dmwit> /dev/fb0 doesn't exist.
00:37:53 <joed> tieTYT: Well.... I could give you about 5 weeks of that working with CXF and apache people.
00:37:53 <mmorrow> oh
00:38:15 <mmorrow> find the dev file that's your framebuffer, and insert that for /dev/fb0
00:38:24 <mmorrow> what distro are you using?
00:38:27 <tieTYT> that wouldn't teach me what restful means :P
00:38:43 <dmwit> ubuntu
00:38:48 <joed> tieTYT: most of the CXF changes right now are from our work.
00:38:57 <mmorrow> try: ls -l /dev/fb
00:39:10 <mmorrow> is it a directory?
00:39:18 <mmorrow> if so, just start trying each one
00:39:21 <dmwit> ls /dev/fb*
00:39:22 <dmwit> no matches
00:39:26 <mmorrow> hmm
00:39:30 <mmorrow> hold on
00:40:44 * dmwit observes that all of #haskell "held on"
00:41:47 <mmorrow> so far, i've found this: http://ubuntuforums.org/archive/index.php/t-652038.html
00:41:52 <lambdabot> Title: Gutsy Framebuffer HOWTO [Archive] - Ubuntu Forums
00:42:02 <dmwit> not worth it
00:42:07 <vixey> wait does that command scribble over the screen?
00:42:10 <dmwit> I can get random noise way easier than that.
00:42:13 <mmorrow> yeah
00:42:15 <vixey> cool
00:42:40 <mmorrow> dmwit: can you get it over every pixel of your screen though
00:42:41 <mmorrow> >
00:42:42 <mmorrow> ?
00:42:47 <dmwit> yes
00:42:49 <dmwit> xmonad++
00:42:51 <mmorrow> how?
00:42:52 <mmorrow> ah
00:42:54 <mmorrow> heh
00:43:50 <vixey> @botsnack
00:43:50 <lambdabot> :)
00:44:05 <vixey> @seen _
00:44:05 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
00:44:17 <vixey> preflex: calc 3
00:44:18 <preflex>  3
00:44:53 <mmorrow> whenever i'm explaining how "everything is a file" on *nix to someone new (to *nix), i do (cat /dev/urandom > /dev/dsp) and (cat /dev/urandom > /dev/fb0) and they're usually like "ooooooh, i getit"
00:45:14 <dmwit> You should suggest this instead:
00:45:22 <dmwit> </dev/urandom >/dev/dsp
00:46:19 <mmorrow> cat</dev/urandom | tee /dev/dsp /dev/fb0
00:46:34 <mauke> dmwit: isn't that zsh only?
00:46:38 <dmwit> mauke: Could be.
00:50:06 <tieTYT> dmwit: so what's haskell's area?
00:50:38 <dmwit> Haskell is good at a lot of things.
00:50:46 <dmwit> Language munging/compilers is a strong area.
00:50:57 <dmwit> Theoretical math is easily expressible.
00:51:11 <mmorrow> i'd say it's superb at metaprogramming
00:51:27 <dmwit> I hear that concurrency and parallelism are very nice in Haskell.
00:51:29 <tieTYT> hm, none of those stand out as opportunities to use at my job
00:51:39 <tieTYT> concurrency/parallelism sound good
00:51:51 <mxc> haskell is good at convincing programmers to go way out of their way to write code in a certain way that makes compiler optimization and parallelization much muhc simpler, and then fails to deliver on the compiler side..
00:52:25 <Zao> mxc: You better get hacking on the compiler then, since you seem to know all about it ;)
00:52:45 <mxc> dont get me wrong, I love it and am way too much a newbie to contribue
00:52:47 <mxc> contribute
00:52:55 <vixey> mxc: that's not true
00:52:57 <dmwit> Haskell does two things: it favors safety over convenience, and it favors programmer time over compute time.
00:52:59 <mxc> i guess I see learning haskell as an investment in the future
00:53:19 <vixey> The only way software gets written is people actually doing it
00:53:21 <mxc> on the memoization side, to be fair, I guess lazy arrays and maps basically fully make up for that
00:53:39 <tieTYT> square2 xs = map squareOne xs ; where squareOne x = x ** 2  so in a where you can define a new function
00:53:43 <tieTYT> can you use pattern matching there?
00:53:45 <cjs> tieTYT: What's your job?
00:54:09 <tieTYT> cjs: mostly make enterprise apps
00:54:19 <dmwit> tieTYT: definitely
00:54:31 <tieTYT> coo
00:54:37 <dmwit> Gtk2Hs is nice for enterprisey
00:54:44 <tieTYT> let me try something
00:54:51 <tieTYT> dmwit: what's that?
00:55:02 <dmwit> Bindings to gtk2...
00:55:10 <dmwit> It's really just nice for GUIs.
00:55:18 <dmwit> But I assume enterprisey implies GUI.
00:55:18 <mmorrow> the great thing is though, once you realize that all unsafe* means is you're on your own (in C, everything is prefixed with unsafe), you realize that haskell puts no resrictions on you whatsoever. But full safety's there if/when you want/need it.
00:55:41 <tieTYT> dmwit: i think enterprisy usually means web based
00:55:49 <dmwit> oh
00:56:10 <tieTYT> dmwit: what do you do?
00:56:17 <dmwit> student =P
00:56:21 <tieTYT> oh
00:56:34 <tieTYT> anyone use haskell professionally here?  What do you do?
00:57:01 <mmorrow> "independent contractor/consultant"
00:57:20 <tieTYT> well what things have you done with haskell?
00:57:30 <mmorrow> hold on, i'm writing
00:57:45 <tieTYT> k
00:58:26 <Syzygy-> tieTYT: Research in computational algebra and topology.
00:58:28 <dmwit> http://www.haskell.org/haskellwiki/Haskell_in_industry
00:58:29 <lambdabot> Title: Haskell in industry - HaskellWiki
01:00:57 <mmorrow> been doing alot of database stuff for insurance companies. dataminingy at first, but recently operations-supporting db-related things. studied math, so can do stat analysis/that sort of matlaby stuff among other things which usually leads to analyzing data in a db for whatever
01:01:21 <tieTYT> i see
01:01:24 <mmorrow> in particular, to determine optimal insurance policy rates given blah
01:01:26 <mmorrow> eg
01:01:31 <tieTYT> most of that seems like "backend" work
01:02:13 <mmorrow> yeah, some web interface stuff, but mostly for people using it internally to the company to do part of their job
01:02:44 <tieTYT> ok i'll keep that in mind when i try to think of a task for it
01:02:57 <vixey> good morning
01:03:11 <tieTYT> morning
01:03:21 <dmwit> @vixen good morning
01:03:22 <lambdabot> good? not great?
01:03:22 <tieTYT> vixey: you already said hi, are you a bot today?
01:03:35 <dmwit> vixey, vixen, what's the difference?
01:03:36 <dmwit> ;-)
01:03:43 <vixey> ?vixey I wonder
01:03:43 <lambdabot> i hate it when i get stuck with chatting with a bot!
01:03:51 <dmwit> bwahahaha
01:05:47 <mmorrow> tieTYT: haskell is great, because it lets you accomplish in one concisely expressed stroke 10x what you could express in (most) any other language (and express much less clearly) i know
01:05:52 <vixey> I'm going to read A Universe of Strictly Positive Families again today
01:06:03 <vixey> maybe it will make sense since I got some rest
01:06:04 <mmorrow> and the FFI gives you access to whatever you need
01:06:15 <tieTYT> mmorrow: i'm sure that's true
01:06:27 <mmorrow> so, you could be using any language then
01:06:27 <tieTYT> but on the other hand, it doesn't have all the useful libraries that java does
01:06:50 <tieTYT> and it's not its fault, its community is just not as big so it doesn't have as many people writing libs
01:07:24 <mmorrow> so you use whatever is appropriate/best for the task at hand, and tie it all together with haskell
01:08:33 <tieTYT> tie together java pieces?
01:09:02 <mmorrow> then go : fmap (makePrettyWithSomehow . whatUsedToTakeMeAWeek . evalWith infoFromDb) listOfProgramsIJustGenerated
01:09:34 <mmorrow> and you're sitting pretty!
01:10:07 <mmorrow> i hate java and refuse to use it
01:10:16 <mmorrow> even if that is to my disadvantage
01:10:25 <tieTYT> or irrelevant?
01:10:26 <mmorrow> i know java though
01:10:28 <vixey>  doesn't sound like a programmer
01:10:38 <mmorrow> call me what you will
01:10:45 <mmorrow> no java
01:10:58 <mmorrow> programmed in java for 4 years
01:11:10 <tieTYT> i'm just asking how you tie together java pieces without starting a jvm for each one
01:11:22 <mmorrow> (by "programmed" I mean was the language i primarily used)(
01:12:11 <mmorrow> oh yeah, i "use" java in the sense that i control things some of which may be somethingsomehow with a jvm involved
01:12:31 <mmorrow> oh, i misread your question
01:12:34 <dmwit> http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages#Java
01:12:35 <lambdabot> Title: Applications and libraries/Interfacing other languages - HaskellWiki, http://tinyurl.com/66ubno
01:12:44 <mmorrow> i don't actually have to deal with java directly
01:13:09 <tieTYT> cool
01:13:18 <mmorrow> this is partially do to my efforts and partially due to that it's just not directly present in the things i'm involved with
01:13:28 <tieTYT> mmorrow: you're misunderstanding, i'm not asking how you do it, i'm asking how i can
01:13:47 <mmorrow> oh
01:13:53 <dmwit> Sadly, this is the state of the art for dealing with C++ code, as far as I know:
01:13:55 <tieTYT> dmwit: ok that's good to know
01:13:55 <mmorrow> what do you want to do in particular
01:13:58 <dmwit> http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell
01:13:59 <lambdabot> Title: CPlusPlus from Haskell - HaskellWiki
01:14:47 <dmwit> nasty
01:15:20 <mmorrow> "<mmorrow> even if that is to my disadvantage": it never is though ;)
01:20:26 <mmorrow> tieTYT: "how you tie together java pieces without starting a jvm for each one": if you're using the FFI with java, the java has to be executed somehow. Unless it's been compiled to machine code, i would imagine this would involve a jvm.
01:22:37 <tieTYT> yeah well that'll probably be a problem for performance
01:22:42 <mmorrow> oh yes
01:22:47 <tieTYT> that's why i asked
01:23:06 <tieTYT> but maybe it's possible to reuse a piece over and over again
01:23:12 <mmorrow> the only solution i see is to not be in such a position
01:23:55 <mmorrow> or the heavyweight beast that is java will bring you into it's infinite slowmo replay
01:24:12 <tieTYT> someone complained about the haskell compiler
01:24:24 <tieTYT> is tail recursion optimization implemented at least?
01:24:25 <mmorrow> while leaking memory, then crash
01:24:35 <dmwit> tieTYT: Tail recursion is an odd beast in Haskell.
01:24:55 <dmwit> tieTYT: Without any strictness annotations, tail recursion could easily blow your stack allocating thunks.
01:25:03 <dmwit> > foldl (+) 0 [1..100000]
01:25:15 <lambdabot>  5000050000
01:25:28 <tieTYT> seemed to take a while :)
01:25:30 <vixey> > (100000*(100000+1))/2
01:25:30 <dmwit> > foldl (+) 0 [1..100000000] -- okay, so computers have lots of memory these days
01:25:34 <lambdabot>  5.00005e9
01:25:42 <lambdabot> Terminated
01:25:47 <vixey> hahaha
01:25:49 <dmwit> vixey: Try `div`.
01:25:53 <tieTYT> who won?
01:26:19 <tieTYT> so is that tail recursion implemented poorly?
01:26:30 <dmwit> tieTYT: Anyway, try that foldl in ghci, and you'll probably see a stack-overflow exception.
01:26:35 <vixey> oh
01:26:36 <dmwit> tieTYT: yes
01:26:42 <dmwit> tieTYT: This tail recursion is better:
01:26:43 <vixey> I thought yours succeeded but mine failed
01:26:51 <mmorrow> In a sense your flying by the same seat of your pants when you're accessing memory with pointers in C
01:26:54 <dmwit> > foldl' (+) 0 [1..10000000]
01:27:02 <lambdabot>  50000005000000
01:27:12 <mmorrow> a stack overflow is indistinguishable from a segfault in the sense that both terminate your program
01:27:14 <tieTYT> what's the difference?
01:27:20 <tieTYT> what's foldl'?
01:27:28 <dmwit> tieTYT: The foldl' has some strictness annotations.
01:27:33 <mmorrow> well, you can handle the stack overflow, but ...
01:27:41 <dmwit> It means that it counteracts the usual "lazy" evaluation order slightly.
01:27:47 <tieTYT> why not make that foldl instead?
01:28:07 <cjs> How do I raise a number to a non-integral power?
01:28:12 <dmwit> > 2 ** 0.5
01:28:13 <lambdabot>  1.4142135623730951
01:28:17 <cjs> Oh, **. Thanks.
01:28:19 <dmwit> > 2 ^^ 0.5
01:28:20 <lambdabot>  Add a type signature
01:28:21 <vixey> :t (^)
01:28:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
01:28:28 <dmwit> :t (^^)
01:28:30 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
01:28:34 <dmwit> Oh, right.
01:28:43 <cjs> dmwit: Exactly what I started with.
01:29:02 <tieTYT> dmwit: why don't they just give foldl foldl'  's impl?
01:29:25 <dmwit> tieTYT: Sadly, strictness annotations are not in H98, the current Haskell standard.
01:29:33 <tieTYT> oh
01:29:38 <tieTYT> so when can i expect the next version?
01:29:45 <dmwit> Real Soon Now
01:29:51 <tieTYT> o_O
01:29:53 <tieTYT> why all caps?
01:30:01 <dmwit> To indicate sarcasm.
01:30:06 <dmwit> =/
01:30:12 <tieTYT> you should have added a (tm) and a smiley face then
01:30:42 <dmwit> http://en.wikipedia.org/wiki/Real_soon_now
01:31:08 <dmwit> "See also: vaporware, Starcraft: Ghost, Duke Nukem Forever" =P
01:31:54 <tieTYT> oh man
01:31:59 <tieTYT> i forgot about starcraft ghost
01:32:02 <tieTYT> i saw that at e3
01:32:14 <dmwit> Actually, that wikipedia page was probably a bit more scathing than I want to be.
01:32:26 <dmwit> There has actually been recent activity by the Haskell' committee.
01:32:27 <luqui> is there some beautiful elegant way to implement A* in Haskell?
01:32:36 <dmwit> But they've been promising things for ten years now. =)
01:32:46 <tieTYT> ok so like
01:32:54 <tieTYT> i was thinking of trying to implement something in haskell
01:32:59 <tieTYT> that i implemented in java already
01:33:00 <dmwit> luqui: I would guess the list monad makes it nice, though I've never actually done it.
01:33:09 <tieTYT> but in java it takes like a gig+ of ram and is slow
01:33:12 <luqui> dmwit, yeah, but there's that whole heap thing...
01:33:13 <tieTYT> does that sound like a bad idea?
01:33:22 <dmwit> luqui: mmm, yeah
01:33:29 <dmwit> luqui: StateT [] maybe?
01:33:48 <dmwit> tieTYT: What does it do?
01:34:07 <tieTYT> reads in a large file and has to do searches on it i list and hashmap form
01:34:22 <tieTYT> and relate values to each other
01:34:36 <tieTYT> but the file is so large that it's very slow even in a DB
01:34:47 <dmwit> hum
01:34:54 <tieTYT> actually a case where a custom impl is smarter than using a db
01:34:54 <dmwit> You'd definitely want to use ByteString.
01:35:18 <dmwit> Hash maps aren't very nice in Haskell, though Data.Map is pretty darned fast.
01:35:38 <dmwit> (Tree map, not hash map.)
01:35:53 <eek> tieTYT, custom implementations are usually faster than using a DB - databases are just convenient
01:36:25 <tieTYT> eek: right i understand that, but you'd be a retard to use a custom implementation most the time
01:36:39 <tieTYT> I might as well create my own custom programming language for it while i'm at it
01:37:09 <mmorrow> tieTYT: that sounds like a perfect application of haskell, and one that is pretty much identical to thing i've encountered and used haskell todo successfully
01:37:22 <mmorrow> s/thing/things/
01:37:26 <mmorrow> do it!
01:37:26 <tieTYT> mmorrow: dmwit seems a little more wary than you
01:37:32 <luqui> yes, creating one's own programming language is what haskell is good at :-)
01:37:34 <tieTYT> weary?
01:37:40 <luqui> (yes I know that's not what you meant)
01:38:11 <tieTYT> why aren't hashmaps nice in haskell?  I use that data type a lot in java
01:38:26 <mmorrow> well, look at it this way. your doing it in java. the program terminates. thus, doing it in haskell will not only also terminate, but terminate in a shorter amount of time.
01:38:31 <dmwit> tieTYT: Hashmaps rely on destructive updates for their speed.
01:38:39 <mmorrow> the code will be both more clear and more concise
01:38:46 <vixey> I like the howto,
01:38:52 <tieTYT> mmorrow: this is a situation where performance actually matters
01:38:58 <mmorrow> even better!
01:39:00 <tieTYT> it's not just about the 80% maintainence
01:40:12 <dmwit> tieTYT: I think you should give it a shot.
01:40:19 <tieTYT> dmwit: ok, might as well
01:40:32 <dmwit> Just... don't use String. =P
01:40:32 <tieTYT> if i recall, it's not very complicated, just a lot of ram
01:40:35 <mmorrow> depending on how large the such a file you need to work with is, though, you might benefit from using at least sqlite
01:40:50 <tieTYT> mmorrow: why?
01:41:08 <mmorrow> wait, did you say you handled it in java?
01:41:13 <tieTYT> yes
01:41:15 <mmorrow> if so, then your fine
01:41:23 <eek> tieTYT, ref performance, do you need to have the "reads in" part? kernels are good at maintaining and caching these things; mmap goes along with this, read fights it.
01:41:40 <tieTYT> define "reads in"
01:41:50 <mmorrow> bytestring-mmap is awesome
01:41:59 <eek> tieTYT, as opposed to mmaping the file.
01:42:08 <tieTYT> i'm not sure what mmaping is :T
01:42:17 <quicksilver> just accessing the file as if it was in memory
01:42:18 <TSC> Accessing a file as if it was memory
01:42:21 <quicksilver> and letting the kernel work it out
01:42:23 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-mmap
01:42:25 <eek> tieTYT, mmap is a kernel function that provides the file as a flat memory access
01:42:25 <lambdabot> http://tinyurl.com/6xpfmw
01:42:38 <quicksilver> but, if you need to build auxiliary indices then you need to read in enough to build the indices
01:42:53 <tieTYT> yeah i'll need that
01:43:00 <eek> quicksilver, the kernel will read that for you on demand, though
01:43:11 <tieTYT> well i don't know if indexes mean persistence
01:43:15 <tieTYT> i'd like to do it all in ram
01:43:24 <mmorrow> how big exactly is one such file you'd be working with
01:43:31 <tieTYT> let me think...
01:43:38 <tieTYT> i believe over a gig
01:43:43 <tieTYT> perhaps just 600mb
01:44:03 <tieTYT> but if i recall, over a gig
01:44:12 <mmorrow> ok, just wondering
01:44:53 <dmwit> You want to deal with a gigabyte file in-memory, and you're complaining that Java uses a gig of RAM?
01:45:09 <tieTYT> good point
01:45:11 <mmorrow> oh, relating to the hashwhatever or Data.Map: use Data.Map
01:45:12 <tieTYT> i have to think about that
01:45:15 <mmorrow> definitely
01:45:17 <tieTYT> i'm not a retard so there's some detail
01:45:22 <tieTYT> well i'm somewhat of one
01:45:26 <tieTYT> i think the file was verbose ass xml
01:45:35 <dmwit> mmm
01:46:03 <tieTYT> that, or i'm seriously overestimating the size of the file
01:46:06 <mmorrow> bytestring mmap allocates the memory lazily, and it's garbage collected as chunks go out of scope
01:46:14 <tieTYT> cause i'd never load a 1gig file and complain that I use 1gig ram :)
01:46:38 <tieTYT> mmorrow: what if i'm using windows?
01:46:43 <mmorrow> uhoh
01:46:56 <tieTYT> is haskell write once, compile anywhere?
01:47:23 <mmorrow> assuming ghc and no platform specific code/dependencies in the haskell code, yes
01:47:35 <kalven> unsafePerformIO, lol
01:47:48 <tieTYT> mmorrow: couldn't you say the same thing about ansi c?
01:47:55 <mmorrow> also, #ifdef SOMEPLATFORM ... #else ... #endif work like a charm
01:48:02 <mmorrow> yes, you could
01:48:13 <tieTYT> well, i consider ansi C to be very bad in this respect
01:48:24 <mmorrow> *but*, ghc is the only compiler you'll use for production code
01:48:27 <dmwit> tieTYT: There are some platform-specific libraries.
01:48:39 <dmwit> tieTYT: But not that many.
01:49:00 <tieTYT> dmwit: are the basics for reading in a file platform specific?
01:49:05 <dmwit> tieTYT: There's even a "unix" package that works on both *nix and Windows. =P
01:49:39 <dmwit> tieTYT: ByteString is part of the standard libraries now, so that should be cross-platform.
01:49:57 <mmorrow> (well, maybe yhc for yhc javascript. looks awesome and have been meaning to learn it)
01:49:59 <dmwit> Likewise for the Handle/String-based file functions.
01:51:30 <quicksilver> tieTYT: you are foolish to consider ansi C to be bad in this respect.
01:51:37 <quicksilver> tieTYT: ansi C is nicely cross platform.
01:51:41 <quicksilver> however, it's very very limited.
01:51:51 <quicksilver> there is hardly anything you can do without calling platform dependent libraries.
01:52:10 <quicksilver> haskell is similarly cross platform but has a much larger set of platform independent useful libs.
01:52:14 <tieTYT> quicksilver: yeah i should have not included "ansi" in my question
01:52:32 <tieTYT> so it's real easy to write cross platform code with a lot of IO?
01:52:45 <dmwit> Definitely.
01:52:50 <tieTYT> ok, good
01:53:23 <dabblego> hello tieTYT, are you winning?
01:53:32 <tieTYT> winning what?
01:53:44 <mmorrow> just saw the part about it being xml. if so, you're in even better shape since once you parse it, extract the information content, and put it all cleverly into some data structure of yours involving Data.Map and possibly other of its friends, your memory usage will most likely be more than reasonable.
01:53:45 <dabblego> whatever it is you are challenging yourself with
01:53:49 <dmwit> Dang, how many d?bblego's are there.
01:54:07 <dmwit> a, i, and o at least
01:54:29 <tieTYT> dobblego: well with dmwit's help, i have a better understanding of lazy evaluation
01:54:34 <dmwit> One down, one to go. =P
01:55:05 <dobblego> tieTYT, ah great; I was at a *Java* conference where Erik Meijer delivered the opening note on Haskell and a few talks on F# (Don Syme); funny watching the imperative guys crumble
01:55:14 <tieTYT> dmwit: what's left?
01:55:20 <mmorrow> it'd be ideal if your parser doesn't need to read in the entire file before returning some results. that way, only part of it'll be in memory at a time, making in addition the parsing stage's memory use reasonable
01:55:20 <dobblego> ?type Left
01:55:22 <lambdabot> forall a b. a -> Either a b
01:55:25 <dmwit> tieTYT: I was referring to the d?bblego thing.
01:55:27 <dobblego> it's that!
01:55:44 <tieTYT> mmorrow: yeah
01:55:54 <dmwit> mmm, fusion
01:56:01 * Itkovian has trouble distinguishing between using let and <- in a do construction
01:56:13 <tieTYT> :P
01:56:16 <mmorrow> i think that covers all the parts of the app where memory use could be of concern, so you're in the clear
01:56:18 <dmwit> Don't use "do" then. ;-)
01:56:20 <opqdonut> Itkovian: <- grabs a out of m a
01:56:22 <dobblego> Itkovian, <- gets it out of the container; let is a straight assignment
01:56:24 <mmorrow> now all you have to do is write it
01:56:25 <opqdonut> Itkovian: let grabs a out of a
01:56:32 <opqdonut> (where a is a type and m is a monad)
01:56:48 <tieTYT> mmorrow: well the fact that haskell doesn't work nice with hashmaps (apparently) may be another performance concern
01:56:49 <tieTYT> i'll see
01:57:01 <opqdonut> Itkovian: let is introducing a shorthand, <- is "executing" an action
01:57:06 <dobblego> Itkovian, it might help to do what dmwit said and use >>=/>> and return explicitly
01:57:09 <tieTYT> maybe i'll look at it as another opportunity to reduce memory footprint
01:57:09 <quicksilver> tieTYT: that's an ill-informed concern :)
01:57:13 <opqdonut> tieTYT: haskell works nicely with hashmaps
01:57:16 <dmwit> tieTYT: I seriously doubt you'll miss hashmaps, since Data.Map is so nice.
01:57:22 <quicksilver> tieTYT: until you've work out how fast (or slow) Data.Map is for your purpose
01:57:32 <quicksilver> tieTYT: you don't know whether you'll miss hashmaps :)
01:57:35 <mmorrow> don't use hash anything
01:57:48 <dmwit> opqdonut: Haskell *can* do Hashmaps... but I don't think it's "nice".
01:58:06 <tieTYT> ok well that'll be nice to use
01:58:07 <mmorrow> well, saying nothing about all meanings of that word....
01:58:14 <mmorrow> but, seriously, use Data.Map
01:58:22 <tieTYT> ok
01:58:25 <[Justice]> Haskell can do anything which any other Turing complete language can do ... some of it more nicely than other languages, some of it less nicely
01:58:29 <tieTYT> that's way off anyway.  I don't even know what a monad is yet
01:58:29 <Itkovian> If <- gets the a out of m a, I should get a String from IO String, right? Which I can use on the next line in say a concat?
01:58:41 <dobblego> Itkovian, correct
01:58:41 <quicksilver> Itkovian: exactly.
01:58:44 <tieTYT> anyway, i'm gonna go to sleep now
01:58:45 <tieTYT> see ya
01:58:46 <opqdonut> Itkovian: yes
01:58:53 * Itkovian tries again
01:59:07 <dmwit> [Justice]: Haskell can perform any calculation that any other Turing complete language can do.
01:59:26 <dmwit> [Justice]: That's a little different than saying Haskell can do anything that any other Turing complete language can do.e
01:59:28 <dobblego> @undo do { str <- ios; f str }
01:59:29 <lambdabot> ios >>= \ str -> f str
01:59:51 <slarba> ios >>= f
01:59:57 <Itkovian> great!
02:00:00 <mmorrow> tieTYT: you should also buy this book if you're at all serious about using haskell for anything that matters: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/ref=pd_bbs_sr_1?ie=UTF8&s=books&qid=1212051587&sr=8-1
02:00:02 <lambdabot> http://tinyurl.com/5p4dqr
02:00:12 <dobblego> @pl . @undo do { str <- ios; f str }
02:00:12 <lambdabot> (line 1, column 1):
02:00:12 <lambdabot> unexpected "."
02:00:12 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
02:00:16 <dobblego> dang :)
02:00:36 <mmorrow> ok, gotta do some work. good luck!
02:00:46 <tieTYT> thanks
02:01:05 <[Justice]> @undo map
02:01:05 <lambdabot> map
02:01:08 <[Justice]> @pl map
02:01:08 <lambdabot> map
02:01:10 <[Justice]> boo
02:01:12 <quicksilver> @. pl undo do { str <- ios; f str }
02:01:12 <lambdabot> f =<< ios
02:01:15 <dobblego> @unpl map
02:01:15 <lambdabot> map
02:01:23 <quicksilver> is what dobblego was after I believe.
02:01:37 <dcoutts> agentzh: I assume you figured out profiling libs, but just in case: cabal configure --enable-library-profiling
02:01:38 <dobblego> quicksilver, great cheers!
02:01:45 <dcoutts> agentzh: or just cabal configure -p
02:01:47 <gaconnet> I'm confused about HsSyck. Am I using it wrong? http://hpaste.org/7963
02:02:14 <[Justice]> @. pl undo do { return 1 }
02:02:15 <lambdabot> return 1
02:02:30 <agentzh> ﻿dcoutts: thanks! i've figured out that via google search :P
02:03:09 <agentzh> dcoutts: the -p shorthand is very cool. thanks for the tip :)
02:03:16 <dcoutts> agentzh: for future reference, there's cabal configure --help and the user guide
02:03:25 <dmwit> tieTYT: It looks like even mmap works okay in both *nix and Windows: http://www.nabble.com/-ANN--Memory-mapped-files-for-POSIX-and-Windows-td16121619.html
02:03:27 <lambdabot> Title: Nabble - Haskell - Libraries - [ANN] Memory mapped files for POSIX and Windows, http://tinyurl.com/5c6mnx
02:03:29 <agentzh> dcoutts: many thanks :)
02:04:21 <dmwit> mmorrow: @you, too
02:18:25 <Itkovian> Looking for the Codec.Binary.Base64 module
02:21:09 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto
02:21:11 <quicksilver> I think?
02:21:18 <quicksilver> can't actually see it there
02:21:24 <quicksilver> but I thought that's where it came from
02:22:33 <quicksilver> ah no
02:22:35 <quicksilver> it's moved to here
02:22:36 <quicksilver> e
02:22:39 <quicksilver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dataenc
02:22:42 <lambdabot> http://tinyurl.com/6oa7ky
02:25:20 <Itkovian> quicksilver: So did I, but the latest version does not have it (4.1.0).
02:25:27 <Itkovian> ah, thx.
02:25:38 * Itkovian should read all lines before replying
02:25:59 <sioraioc_> nick sioraiocht
02:26:07 <cjs> A two-item tuple is a pair, right? What's a three-item tuple?
02:26:19 <sioraioc_> a 3-tuple
02:26:24 <sioraioc_> or a triple
02:26:33 <cjs> Thanks.
02:26:50 <eu-prleu-peupeu> hi there
02:30:16 <ndm> cjs: i just say tuple of length n
02:30:22 <ndm> or n-element tuple
02:30:42 <opqdonut> n-tuple is pretty standard
02:30:44 * luqui denies the existence of any tuple larger than a pair
02:31:03 * ndm likes triples, and wishes they were better supported
02:31:22 <ndm> or i'd be happy with inductive tuples, of course
02:31:30 <opqdonut> inductive tuples would rock, yes
02:31:32 <luqui> yes that would be nice
02:31:37 <ndm> so (a,b,c) is a desugaring for (a,(b,c))
02:31:41 <luqui> and it's just a syntax thing anyway
02:31:58 <ndm> luqui: kind of, once you add type classes to the language it becomes a semantic thing
02:32:26 <luqui> well, I mean to support inductive tuples is only a syntax tweak
02:33:00 <ndm> yes, but they you have many overlapping instances for things like Show
02:33:07 <vincenz> Cale: you around?
02:33:12 <luqui> example?
02:33:25 <ndm> instance Eq (a,b), instance Eq (a,b,c)
02:33:27 <luqui> oh I see what you mean
02:33:38 <luqui> well, yeah, presumably the latter would go away
02:33:44 <ndm> presumably
02:33:53 <luqui> but the problem is do you show (a,b,c) as (a,b,c) or as (a,(b,c))
02:33:54 <ndm> but it does mean that its quite a breaking change
02:34:04 <opqdonut> yeah
02:34:07 <luqui> you want the former, but you can't specify that with type classes
02:34:10 <opqdonut> but haskell needs a few of those
02:34:26 <ndm> exactly, we did consider inductive tuples for Yhc
02:34:34 <ndm> but decided against it because of the type class thing
02:34:41 <luqui> I consider those huge lists of instances for (a,b), (a,b,c), (a,b,c,d), (a,b,c,d,e) a pretty big wart on the language though
02:34:46 <opqdonut> mhmm
02:35:31 <vincenz> Anyone know how to fix: Could not find module `Data.ByteString.Char8': it is a member of package bytestring-0.9.1.0, which is hidden
02:35:34 <ndm> yep,m me too :)
02:35:50 <ndm> vincenz: ghc-pkg unhide bytestring?
02:35:52 <dmwit> (a,b,c) ought to be syntactic sugar for (a,(b,c)) or ((a,b),c), not sure which.
02:36:05 <vixey> I should think (a,(b,c))
02:36:06 <dmwit> vincenz: cabal?
02:36:07 <ndm> vincenz: ghc-pkg --help should give you enough details
02:36:14 <vincenz> thanks
02:36:16 <dmwit> vixey: It hardly matters, does it?
02:36:20 <vixey> you could just define , as an infix operator
02:36:33 <ndm> vincenz: oh, if its cabal, you might need to add a dependency in
02:36:43 <opqdonut> vixey: yeah and make it right-associative
02:36:45 <ndm> vixey: no, you have lists remember
02:36:51 <vincenz> sudo ghc-pkg expose bytestring-0.9.1.0
02:36:59 <vincenz>  Could not find module `Data.ByteString.Char8':
02:37:01 <vincenz>       it is a member of package bytestring-0.9.1.0, which is hidden
02:37:11 <vincenz> (the second is after trying to build lambdabot from darcs
02:37:37 <sjanssen> vincenz: sounds like bytestring isn't listed in the build-depends
02:38:13 <vincenz> sjanssen: thanks
02:38:33 <sjanssen> vincenz: though lambdabot.cabal seems to be fine in my repository...
02:39:18 <vincenz> bah :|
02:39:35 <vincenz> /usr/bin/ld: cannot find -lHSplugins-1.2
02:39:43 <vincenz> I just reinstalled it again (plugins-1.2)
02:41:26 <sjanssen> perhaps a clean/configure/build cycle is required in lambdabot
02:42:00 <vincenz> no, still seems to be unable to find the HSplugins
02:42:20 <dobblego> vincenz, I installed lambdabot on a vmware because I know how painful it is to build
02:42:39 <sjanssen> it shouldn't be painful anymore
02:42:41 <vincenz> dobblego: :|
02:42:47 <vincenz> sjanssen: it hasn't been easy for sure :)
02:42:47 <sjanssen> simply 'cabal install' each of the missing build-depends
02:43:08 <dobblego> sjanssen, then there is a bug you have to workaround (and so cannot use cabal install for the lambadbot package)
02:43:09 <vincenz> sjanssen: I have plugins.1-2 installed, both via cabal and now manually to douclecheck, it can't find the HSplugins-1.2
02:43:14 <dcoutts> if you have cabal install already then it does that automagically
02:43:24 <sjanssen> dobblego: what bug?
02:43:25 <vincenz> dcoutts: acbal install installs a lambdabot that does not run
02:43:29 <vincenz> s/acbal/cabal
02:43:37 <sudo1970> If I have a function with several equations, some of which have the same right side, is there any way to write the right side only once?
02:43:37 <sudo1970> (An Example: two of my equations are:
02:43:37 <sudo1970> findWay' layout _ _ [] _ r = (layout : r)
02:43:37 <sudo1970> findWay' layout _ _ _ [] r = (layout : r)
02:43:37 <sudo1970> Is there any way to write (layout : r) only once?)
02:43:51 <sjanssen> right, you don't want to do 'cabal install' in lambdabot's directory, because lambdabot is goofy
02:44:01 <dcoutts> sjanssen: oh?
02:44:05 * vincenz is on a 64bit machine, if that makes any difference
02:44:07 <dcoutts> why wouldn't it work?
02:44:20 <sjanssen> dcoutts: it won't run without a bunch of state files and executables in the current directory
02:44:20 <dobblego> sjanssen, the same one that vincenz hit yesterday; #ifdef USE_RESOURCE_WORKAROUND import System.Posix ...
02:44:51 <vincenz> dobblego: I could not find that clause anywhere
02:44:56 <dcoutts> sjanssen: sounds like it wants fixing
02:45:14 <dobblego> vincenz, did you download the lambdabot source and compile that?
02:45:14 <vincenz> dcoutts: any idea why it might not find -lHSplugins-1.2 on a 64 bit machine?
02:45:27 <vincenz> dobblego: trying to, but getting stuck on ld -lHSplugins-1.2
02:45:33 <dcoutts> sjanssen: why not have the default initial state files installed automatically and then lambdabot can copy the defaults to ~/.lambdabot/ on startup if they're missing and from then on use those writable versions?
02:45:54 <dobblego> vincenz, want the vmware image? :)
02:45:57 <dcoutts> vincenz: if it's missing and/or registration is messed up
02:46:11 <sjanssen> dcoutts: I don't think anyone really cares enough
02:46:20 <vincenz> dcoutts: I did a clean install on it
02:46:23 <sjanssen> dcoutts: parts of lambdabot are really arcane and aren't fun to hack on
02:46:23 <dcoutts> sjanssen: so how do you install it?
02:46:46 <opqdonut> sudo1970: findWay' layout _ _ xs ys r | null xs || null ys   = layout : r
02:46:48 <sjanssen> dcoutts: run it inside the darcs repository
02:46:51 <opqdonut> that's at least one way
02:46:58 <dcoutts> vincenz: ghc-pkg clearly thinks its installed in a place where it isn't, check that libHSplugins-1.2.a really does exist where you think it should
02:47:19 <vincenz> dcoutts: it doesn't, I checked /usr/local/lib, nada
02:47:42 <dcoutts> vincenz: check in the place where ghc-pkg thinks it'll be, which is not directly in /usr/local/lib
02:48:03 <sudo1970> thanks ﻿opqdonut
02:48:31 <sjanssen> vincenz: it has been a while since I've built lambdabot, I'll try it and give you any results
02:48:51 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/7964
02:48:52 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/7965
02:49:00 <vincenz> http://hpaste.org/7965
02:49:10 <vincenz> whoops
02:49:22 <dcoutts> vincenz: ghc-pkg deescribe plugins tells you everything ghc-pkg knows about the package, including what library dirs it looks in for the libHSplugins-1.2.a
02:49:43 <dcoutts> vincenz: so check /usr/local/lib/plugins-1.2/ghc-6.8.2
02:49:46 <int-e> lambdabot has a 'build' script that runs setup and then compiles a few extra modules
02:49:59 <vincenz> ok, fixed at last
02:50:06 <vincenz> I think cause priorly I had a cabal-install'd version
02:51:05 <vincenz> bleh
02:51:19 <vincenz> Lambdabot.hs:64:17:
02:51:19 <vincenz>     Could not find module `Data.Map':
02:51:19 <vincenz>       it is a member of package containers-0.1.0.1, which is hidden
02:51:22 <vincenz> I expose it, same thing
02:51:31 <vincenz> This seems to be an issue with all packages installed via "sudo synaptic"
02:52:08 <vincenz> or, this could be a missing build-depend
02:52:16 <hpaste>  morrow pasted "(no title)" at http://hpaste.org/7966
02:55:46 <ivanm> vincenz: you're using >=ghc-6.8?
02:55:49 * vincenz fixes them all
02:55:51 <vincenz> ivanm: yep
02:55:58 <vincenz> Could not find module `Data.ByteString.Base':
02:56:14 <ivanm> well, with 6.8.2 the libs were split out, and you get that error
02:56:23 <vincenz> ivanm: yeah, added a bunch of dependencies
02:56:36 <vincenz> dcoutts: did Data.Bytestring.Base dissapear?
02:56:45 <ivanm> like the containers package? I don't think you actually need that...
02:56:51 * ivanm could be wrong though
02:56:55 <vincenz> ivanm: Data.Map
02:57:02 <dcoutts> vincenz: yes, split into .Internal and .Unsafe
02:57:36 <vincenz> @hoogle packAddress
02:57:37 <lambdabot> Data.ByteString.Unsafe.unsafePackAddress :: Addr# -> IO ByteString
02:57:37 <lambdabot> Data.ByteString.Unsafe.unsafePackAddressLen :: Int -> Addr# -> IO ByteString
02:58:02 <sjanssen> vincenz: why aren't you using the stock lambdabot.cabal?
02:58:09 <vincenz> sjanssen: cause it breaks
02:58:21 <sjanssen> vincenz: actually, you're asking about errors that have been fixed in darcs for ages
02:58:30 <sjanssen> what version of lambdabot are you trying to build?
02:58:35 <vincenz> packAddress -> unsafePackAddress ?
02:58:38 <vincenz> sjanssen: darsc version
02:59:00 * vincenz is running 64bit ubuntu Hardy which ships with 6.8.2
02:59:02 <sjanssen> vincenz: no, this isn't the darcs version because these issues don't exist in the darcs version
02:59:06 <dcoutts> vincenz: what darcs repo? sounds like you got an ancient one
02:59:13 <vincenz> sjanssen: sjanssen I assure you it is
02:59:19 <vincenz> Downloaded today
02:59:21 <dcoutts> vincenz: which darcs repo?
02:59:23 <dcoutts> what URL
02:59:53 <vincenz> The first one in google: http://www.cse.unsw.edu.au/~dons/lambdabot.html
02:59:59 <lambdabot> Title: lambdabot
03:00:02 <sjanssen> ah, there is the confusion
03:00:04 <vincenz> # darcs get --partial http://www.cse.unsw.edu.au/~dons/lambdabot
03:00:05 <lambdabot> Title: Index of /~dons/lambdabot
03:00:08 <dcoutts> sjanssen: does the old repo have a motd on it saying "NO NOT USE!!!" ?
03:00:09 <sjanssen> vincenz: http://code.haskell.org/lambdabot
03:00:10 <lambdabot> Title: Index of /lambdabot
03:00:29 <vincenz> sjanssen: thanks
03:00:33 <sjanssen> @tell dons can you do something to mark the unsw lambdabot repository as obsolete?
03:00:33 <lambdabot> Consider it noted.
03:01:06 <dcoutts> @dons people are finding it via google and getting confused, add a motd to tell them where to find the new one.
03:01:06 <lambdabot> people are finding it via google and getting confused, add a motd to tell them where to find the new one. not available
03:01:07 <int-e> it does, http://www.cse.unsw.edu.au/~dons/lambdabot/_darcs/prefs/motd
03:01:10 <dcoutts> doh!
03:01:12 <dcoutts> @tell dons people are finding it via google and getting confused, add a motd to tell them where to find the new one.
03:01:12 <lambdabot> Consider it noted.
03:01:46 <dcoutts> int-e: perhaps it needs an ever bigger warning :-)
03:02:31 <dcoutts> > "N" ++ replicate 15 'O' ++ replicate 15 '!'
03:02:32 <lambdabot>  "NOOOOOOOOOOOOOOO!!!!!!!!!!!!!!!"
03:03:07 <vincenz> Seriously, when you do a darcs pull of a big repo, typically you switch to another terminal or get some coffee
03:03:13 <int-e> dcoutts: yeah, maybe the repository should be empty except for the motd.
03:03:13 <vixey> > 'N':(++replicate15)=<<"O!"
03:03:14 <lambdabot>   Not in scope: `replicate15'
03:03:23 * vincenz thinks that should be mentioned on that homepage in red letters (:
03:03:47 <int-e> vincenz: heh, easier to just fix the url?
03:03:54 <vincenz> int-e: that works too ("
03:04:16 <dcoutts> @tell dons ok so there is a motd already :-) perhaps fix the url on the unsw lambdabot page as people miss the darcs motd
03:04:16 <lambdabot> Consider it noted.
03:05:21 <mbz> @yarr
03:05:21 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
03:05:56 <sjanssen> > "N" ++ join (replicateM 3 "Oo")
03:05:57 <lambdabot>  "NOOOOOoOoOOoooOOoOoooOooo"
03:06:21 <opqdonut> sjanssen: :D
03:07:08 <BeelsebobWork> > "zomg" ++ join (replicateM 3 "!1")
03:07:10 <lambdabot>  "zomg!!!!!1!1!!111!!1!111!111"
03:07:12 <BeelsebobWork> :P
03:07:57 <ivanm> > "zomg" ++ (cycle "!1")
03:07:59 <lambdabot>  "zomg!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!1!...
03:08:35 <BeelsebobWork> > "zomg" ++ join (replicateM 3 (cycle "!1"))
03:08:37 <lambdabot>  "zomg!!!!!1!!!!!1!!!!!1!!!!!1!!!!!1!!!!!1!!!!!1!!!!!1!!!!!1!!!!!1!!!!!1!!!!!...
03:08:59 <sjanssen> dcoutts: have you ever looked at lambdabot's build system?  It is one of the biggest abuses of Cabal ever
03:09:24 <dcoutts> sjanssen: I note the way it builds a pre-processor and then uses that when building something else
03:09:43 <dcoutts> sjanssen: I bet it's not a big abuse as takusen
03:09:45 * vincenz prays after installing oeis and numbers
03:09:55 <sjanssen> dcoutts: yeah, -pgmF dist/build/BotPP/BotPP
03:10:06 <dcoutts> sjanssen: yeah so that's evil. Anything else?
03:10:07 <sjanssen> dcoutts: maybe not, I've never looked at it
03:10:27 <dcoutts> sjanssen: and it should be using Cabal to install the data files
03:11:26 <ivanm> dcoutts: what's takusen?
03:11:41 <dcoutts> ivan: a db connectivity layer
03:11:43 <sjanssen> dcoutts: the eval mechanism is also a bit funky, it has to precompile certain files to .o and .hi
03:11:51 <sjanssen> and this is done manually
03:11:52 <vincenz> Lib/Regex.hs:60:42:
03:11:52 <vincenz>     Couldn't match expected type `bytestring-0.9.0.1:Data.ByteString.Internal.ByteString'
03:11:55 <vincenz>            against inferred type `ByteString'
03:12:13 <dcoutts> @google dreaded diamond dependency problem
03:12:13 <lambdabot> No Result Found.
03:12:14 <vincenz> Lib/Regex.hs
03:12:16 <dcoutts> grrr
03:12:23 <dcoutts> vincenz: see dreaded diamond dependency problem
03:12:23 <ivanm> dcoutts: *nod*
03:12:27 <vincenz> dcoutts: ah
03:12:35 <vincenz> dcoutts: suggestions?
03:12:50 <dcoutts> vincenz: google for the definition of the term and explanation
03:13:02 <dcoutts> ie my blog post on it
03:13:20 <sjanssen> vincenz: figure out which version of bytestring your regex lib is linked against, then make lambdabot use that bytestring
03:13:46 * vincenz sees
03:14:25 <vincenz> sjanssen: how do I force a version?
03:14:48 <sjanssen> in the build-depends, bytestring == foo.bar
03:15:30 <vincenz> Thank you
03:16:03 <sjanssen> man, it takes a ridiculous amount of memory to link lambdabot
03:16:54 <dcoutts> in the latest Cabal there's a --constraint flag to specify which version of a dep you'd like, if you don't want the default which is the latest version
03:17:02 <ivanm> sjanssen: are you using dcoutts' cabal-install to do so, or doing it by hand?
03:17:18 <sjanssen> ivanm: just Cabal
03:17:23 <ivanm> *nod*
03:17:27 <dcoutts> and the next cabal-install release should fix the diamond dep problem
03:17:31 <sjanssen> it's an ld issue, not a Cabal issue
03:17:36 <dcoutts> it even works for yi
03:17:40 <ivanm> dcoutts: have you fixed cabal-install so that it doesn't complain about Cabal versions when installing lambdabot, etc.?
03:17:41 <sjanssen> dcoutts: ooh
03:17:50 <dcoutts> sjanssen: yep :-)
03:18:02 <ivanm> hang on.... there's _been_ cabal-install releases? I thought it was still darcs only...
03:18:12 <dcoutts> ivan: dunno what you're referring to exactly
03:18:30 <vincenz> sjanssen: Last question, it doesn't copy the files required at runtime anywhere, does it?
03:18:36 <dcoutts> ivan: yeah, pretty much. There are some ancient releases but they're not relevant.
03:18:50 <ivanm> ahhh
03:19:22 <ivanm> well, "cabal install lambdabot"  brings up inconsistent Cabal version errors, even though both are installed
03:19:40 <dcoutts> can you be any more specific?
03:19:54 <ivanm> Package Cabal is required by several packages, but they require inconsistent versions:
03:19:55 <ivanm>   package ghc-6.8.2 requires Cabal-1.2.3.0
03:19:55 <ivanm>   package plugins-1.2 requires Cabal-1.5.1
03:20:00 <dcoutts> ah ok
03:20:10 <sjanssen> vincenz: no, you'll want to run lambdabot in tree
03:20:21 <ivanm> last time I asked you about this you claimed your new dep tree will fix it :p
03:20:36 <dcoutts> ivan: yes, it'll pick Cabal-1.2.3.0 in that instance
03:20:41 <ivanm> *nod*
03:21:02 <ivanm> so, how long until we can expect this magic dep tree generator to be available to us mere mortals? :P
03:21:03 <sjanssen> dcoutts: will it also rebuild plugins against the older version of Cabal?
03:21:10 <ivanm> s/mortals/n00bs/ :p
03:21:26 <mxc_> thats harsh
03:21:36 <ivanm> mxc_: why?
03:21:52 <dcoutts> sjanssen: yes
03:21:55 <ivanm> I've seen a quote somewhere saying that "every guru's dream is to be a n00b for eternity"
03:21:56 <mxc_> oh, related to a specific comment
03:22:00 <ivanm> yeah
03:22:12 <mxc_> ivanm, i thought you were making a general comment about those who are not immortal
03:22:18 <mxc_> hah
03:22:19 <ivanm> heh
03:22:34 <QtPlatypus> ivanm: I don't understand that comment.
03:22:40 <ivanm> QtPlatypus: which one? the quote?
03:22:50 <QtPlatypus> The quote
03:23:07 <ivanm> fundamentally its stating that they always want something new to learn, do, etc.
03:23:14 <ivanm> to avoid boredom, stagnation, etc. :p
03:23:25 <QtPlatypus> Ah ok.
03:23:41 <int-e> ivanm: that's weird though because plugins uses ghc as well.
03:23:49 <Arnar> I'm no guru, but I'm pretty good at being a n00b at something at all times
03:24:02 <ivanm> int-e: *shrug*
03:24:08 <ivanm> Arnar: lol
03:24:37 <mbz> Arnar, wow! how do you do that?
03:24:58 <mbz> j/k
03:25:05 <Arnar> :)
03:25:30 * Arnar bets the same goes for most people here.. (except many of them *are* gurus)
03:26:52 <sjanssen> does anyone know the IRC nick of sven.ove?
03:46:27 * dcoutts pushes a huge pile of Cabal and cabal-install patches...
03:48:22 <dcoutts> where huge = 45
03:51:23 <ivanm> \o/
03:51:36 <ivanm> including the new dep tree generator?
04:00:31 <vincenz> ok
04:00:40 <vincenz> compiled lambdabot, runplugs is still failing
04:00:49 <vincenz>  Failed to load interface for `L':
04:00:49 <vincenz>       Use -v to see a list of the files searched for.
04:08:01 <vixey> I wish there was something like paredit for haskell
04:08:10 <vixey> it only lets you write well typed terms
04:08:12 <ivanm> what's paredit?
04:08:21 <quicksilver> there is something like paredit for haskell
04:08:25 <quicksilver> it's called paredit :)
04:08:31 <vixey> It's an editing mode which only lets you input well formed s-exps
04:08:45 <quicksilver> doesn't help you with typing, of course, but it does help you with well-forming
04:08:51 <vixey> paredit dosen't understand haskell
04:09:09 <vixey> it would be interesting to have the type system interact with editing
04:09:27 <quicksilver> paredit understands haskell syntax fine
04:09:33 <quicksilver> with a couple of small buglets which are easy to fix.
04:09:39 <vixey> I am talking the types
04:09:43 <quicksilver> it doesn't understand haskell types.
04:09:56 <quicksilver> Yes, I agree type-aware editing is a nice thought.
04:10:01 <quicksilver> that's quite a lot more than just paredit.
04:10:13 <quicksilver> paredit as-is is still a useful tool for haskell for the same reason it's a useful tool for lisp.
04:10:55 <quicksilver> see also epigram for some thoughts on type-aware editing.
04:11:09 <vixey> I tried to run epigram :[
04:11:20 <vixey> I don't like xemacs
04:11:36 <vixey> it wouldn't do things
04:12:04 <vincenz> Cale: ping
04:15:09 <vixey> quicksilver: did you read  Universe of Strictly Positive Families?
04:15:39 <vincenz> sjanssen: Do you know how to make runplugs find L.hs?
04:15:57 <ivanm> vixey: what's xemacs got to do with epigram?
04:16:59 <vixey> ivanm: Interactive part of Epigram1
04:17:20 <vixey> just had trouble with it
04:17:56 <ivanm> why did they tie it in to a particular text editor?
04:18:16 <vixey> ivanm: well it's a much much better choice than using ncurses
04:18:31 <ivanm> yes, but why necessarily _X_emacs?
04:18:44 <vixey> I'm not an Epigram hacker .. I don't know
04:19:00 <ivanm> heh
04:19:06 <vixey> It could just be what they use
04:19:36 <eek> xemacs used to be the most featureful emacs variant, even for console use
04:20:35 <quicksilver> when they made that decision emacs simply couldn't do it
04:20:43 <quicksilver> the whole boxes sheds things
04:25:53 <gh_> hi, is there something particular I must do so that Alex and Happy files get compiled in a cabal project ? I always get a "file not found" error since my switch to the ghc 6.8.2 version of ubuntu hardy
04:37:43 <ivanm> what's with lambdabot, that plugins like @seen and @users isn't working properly?
04:38:40 <SamB_XP> my guess is that the state file got corrupted somehow...
04:38:50 <SamB_XP> ... or that the plugin is broken
04:39:53 <ivanm> *nod*
04:59:33 <dcoutts_> gh_: all the modules need to be listed in exposed-modules or other-modules for Cabal to notice them and decide that alex/happy files need pre-processing
05:00:00 <dcoutts_> gh_: though it's always been that way, so I dunno if that's your issue since you say it changed with your recent upgrade
05:00:55 <mxc_> question about records
05:01:12 <mxc_> if i turn on DisambiguateRecordFields and RecordPuns, shouldn't the following be acceptable:
05:01:13 <mxc_> data Foo = Foo { id :: String, size :: Int }
05:01:13 <mxc_> data Bar = Bar { id :: String, blah :: String }
05:01:42 <mxc_> i thought with those flags you could have different records sharing field names
05:01:59 <ToRA> i thought you can have them in scope, but not defined in the same module
05:02:19 <mxc_> oh, they have to be in separate modules?
05:02:24 <ToRA> i think so
05:02:31 <ToRA> check the ghc docs
05:03:53 <mxc_> in the GHC docs example, they are in separate modules, but, IIRC, it didn't say that was a requirement
05:07:08 <ToRA> hmm, what is recordpuns supposed to do?
05:07:30 <mbz> is there any way to use two records sharing the same field name in one module?
05:08:49 <quicksilver> not in haskell, no
05:08:55 <quicksilver> I think there is a GHC extension which permits it.
05:09:22 <mxc_> is that hte -XRecordPuns that i can't find any docs on?
05:09:31 <mxc_> tora no idea
05:09:44 * SamB wishes this ASD paper defined the typing judgment explicitly...
05:11:09 <mbz> the same problem with records like ocaml has..
05:12:59 <malcolmw> RecordPuns was a feature of Haskell 1.3 and 1.4 that got removed in H'98
05:13:11 <quicksilver> I think you're right.
05:13:17 <quicksilver> I think they have to be in separate modules.
05:14:02 <malcolmw> RecordPuns allow pattern-matching on fieldnames where the var bound to the field value has the same name as the field itself
05:14:40 <malcolmw> e.g. f (Foo {bar,baz}) = Foo { bar = bar+1, baz=baz-1 }
05:15:19 <ToRA> you can do that?
05:15:19 <ToRA> wow
05:15:32 <quicksilver> it just lets you use bar as shorthand for bar=bar
05:15:36 <quicksilver> it's not really a big win :)
05:15:39 * ToRA suddenly has a way to make his code even shorter!
05:16:37 <ToRA> can you mix style? Foo { bar , baz = baz' }
05:16:47 <quicksilver> I suspect so.
05:20:36 <vincenz> Anyone have experience with lambdabot? I'm getting problems as runplugs can't find the module "L"
05:21:51 <dcoutts_> quicksilver: the main win as far as I'm concerned is not getting name shadowing warnings with -Wall
05:22:07 <mxc_> in http://hpaste.org/7968 any idea why the second module declaration gives a syntax error?
05:22:21 <mxc_> i thought that you could have mutiple modules in one file
05:22:22 <dcoutts_> mxc_: one module per file
05:22:43 <int-e> ToRA: why not  f foo@Foo { baz } = foo { baz = baz' } ?
05:23:08 <mxc_> from the "gentle introduction to haskell" : "and more than one module could conceivably reside in a single file (one module may even span several files)."
05:23:14 <dcoutts_> mxc_: the H98 spec doesn't say much about the relation between files and modules but all the implementations match them up 1-1
05:23:18 <mxc_> http://www.haskell.org/tutorial/modules.html
05:23:19 <lambdabot> Title: A Gentle Introduction to Haskell: Modules
05:23:23 <mxc_> ah
05:24:04 <dcoutts_> mxc_: it's rather imprecise advice
05:24:11 <dcoutts_> "Of course, a particular implementation will most likely adopt conventions that make the connection between modules and files more stringent."
05:24:18 <dcoutts_> that bit should be made stronger
05:24:22 <mxc_> so in one file you can't share field names in records?
05:24:33 <dcoutts_> mxc_: correct
05:25:12 <mxc_> unless they are all part of one type right?
05:25:52 <quicksilver> correct.
05:26:01 <quicksilver> dcoutts_: I consider that a broken -Wall
05:26:11 <quicksilver> dcoutts_: in fact, I consider -Wall to be too broken to use, which is a shame :(
05:27:08 <mxc_> is there any likelihood of the module situation improving in future releases?
05:27:20 <mxc_> it seems like there is a lot of talk on the mailing lists about that
05:27:22 <dcoutts_> quicksilver: I dunno, it'correct in a pedantic sense
05:27:36 <quicksilver> dcoutts_: I just don't consider shadowing a bad thing, really.
05:27:37 <Igloo> Is this name shadowing? That's a really useful warning
05:27:42 <int-e> vincenz: did you use the 'build' script? it compiles a few extra modules, including said L module. there's also the question which directory you run lambdabot from ...
05:27:54 <dcoutts_> quicksilver: you want an exception when you pattern match Foo { foo = foo } = ...
05:28:02 <Igloo> It makes it much easier to understand the code
05:28:06 <dcoutts_> yes, in general name shadowing is very useful
05:28:11 <dcoutts_> as a warning I mean
05:28:11 <int-e> vincenz: that being said I haven't built or used lambdabot in a while
05:28:31 <quicksilver> mxc_: in the long term, sure. In the short term it won't improve because nobody has a suggestion on how to improve it.
05:28:36 <vincenz> int-e: I'm running it from the darcs directory
05:28:49 <Igloo> Code that does "Foo { foo = foo }" is harder to understand than it needs to be, IMO
05:29:01 <dcoutts_> Igloo: the puns extension does that
05:29:11 <Igloo> Yes, and I don't like that either
05:29:16 <quicksilver> in retrospect the decision to make field names selector functions may have been a mistake.
05:29:19 <quicksilver> IMO.
05:29:31 <dcoutts_> Igloo: but if we add it then we cannot make it a warning :-)
05:29:46 <Igloo> Add it to what?
05:29:50 <dcoutts_> Igloo: you just have to add "don't use record puns" to your coding style guidelines
05:30:02 <dcoutts_> Igloo: record puns to Haskell'
05:30:10 <Igloo> Is that going to happen?
05:30:13 <dcoutts_> arn't they already implemented in ghc ?
05:30:24 <Igloo> Yes
05:30:39 <dcoutts_> and presumably do not generate name shadowing warnings
05:30:53 <Igloo> I don't know
05:30:59 <dcoutts_> Igloo: I dunno if they'll be in H', just saying if they are they cannot generate warnings or it's silly
05:31:03 <ndm> dcoutts_: they are in Yhc and nhc, and always have been (with a flag)
05:31:47 <ndm> if i hadn't proposed them for removal from Yhc, I don't think anyone would have bothered adding them to GHC...
05:32:38 <dcoutts_> ndm: do you know if that's NamedFieldPuns or RecordPuns ?
05:32:54 <dcoutts_> ndm: or does nhc98's -puns flag turn on both?
05:33:04 <dcoutts_> ndm: I just want to check we're doing it right in cabal
05:33:18 <dcoutts_> currently only NamedFieldPuns enables -puns for nhc98
05:33:18 <ndm> dcoutts_: not the slightest idea...
05:33:23 <dcoutts_> malcolmw: and idea?
05:33:26 <dcoutts_> and/any
05:34:20 <Igloo> I suspect NamedFieldPuns is foo=foo, and RecordPuns is {..}, so it's probably right
05:34:25 <malcolmw> dcoutts_: http://www.cs.york.ac.uk/fp/nhc98/compiler-options.html says -puns (on by default)
05:34:28 <lambdabot> Title: nhc98 compile-time options
05:34:55 <dcoutts_> malcolmw: do you know if -puns corresponds to the NamedFieldPuns or RecordPuns extensions, or both?
05:34:56 <malcolmw> -nopuns to switch off
05:35:09 <malcolmw> dcoutts_: I didn't know there was a difference
05:35:40 <malcolmw> dcoutts_: oh hold on, one of them is Lennart's Foo{...} i.e. explicit ellipsis, right?
05:35:55 <dcoutts_> malcolmw: probably, but I'm a bit hazy on it too
05:40:48 <malcolmw> dcoutts_: I have a suspicion that RecordPuns and NamedFieldPuns are the same thing, just added to Cabal.Distribution at different times, in error.
05:41:04 <dcoutts_> malcolmw: hmm
05:41:12 <dcoutts_> it'd really help if each of them were documented
05:41:38 <dcoutts_> I should find docs for the existing ones and demand docs for any new ones that people want to register
05:42:51 <malcolmw> Google says that NamedFieldPuns have been in cabal since the very beginning, and RecordPuns were added later.
05:42:55 <int-e> ghc doesn't know about NamedFieldPuns.
05:44:14 <dcoutts_> Igloo: do you know if NamedFieldPuns and RecordPuns are just aliases?
05:44:16 <malcolmw> see the original proposal for Cabal:  http://www.haskell.org/cabal/proposal/pkg-spec.pdf
05:45:40 <dcoutts_> malcolmw: I see
05:45:59 <malcolmw> RecordPuns were added in ghc-6.8, a mere 6 months ago:  http://archive.netbsd.se/?ml=haskell-libraries&a=2007-11&t=5609140
05:46:00 <lambdabot> Title: archive.netbsd.se, http://tinyurl.com/5cdd4l
05:46:23 <malcolmw> so it looks like the name RecordPuns was a mistake, since there already existed a name for exactly the same thing.
05:46:48 <dcoutts_> Igloo: we suspect that ghc really implements NamedFieldPuns but when -fglasgow-exts was split out we didn't notice the existing name and picked RecordPuns as an extension name instead
05:47:04 <malcolmw> ah, RecordWildcards are Lennart's addition of {..}
05:47:13 <dcoutts_> malcolmw: ah ok
05:48:05 <dcoutts_> Igloo: so we should try and confirm if this is the case
05:48:05 <mxc_> anyone aware of large, enterprise projects being done in haskell besides GHC
05:48:19 <dcoutts_> Igloo: and if so, get ghc to use the old name and keep the new one as a deprecated alias
05:48:40 <dcoutts_> Igloo: ie deprecate RecordPuns and make it an alias for NamedFieldPuns
05:48:57 <dcoutts_> Igloo: if you think it is a confusion, I'll open a ghc ticket
05:49:10 <quicksilver> if by enterprise you mean "over-engineered, un-neccessarily complex systems involving a huge mesh of underspecified interlock components each of which depends on undocumented and unintended features of other components..."
05:49:17 <quicksilver> then, no. I don't :)
05:49:36 <malcolmw> quicksilver: but ghc is all of those, right?  :-)
05:49:58 <mxc_> well i used to work at jane street, which really really well done 'enterprise' class systems in ocaml
05:50:04 <quicksilver> ;)
05:50:10 <mxc_> quicksilver its a fair point
05:50:17 <quicksilver> I'm not ttrying to be difficult, but I really don't know what you mean by 'enterprise'
05:50:24 <mxc_> but jane street/ocaml was such an outstanding example
05:50:29 <quicksilver> what enterprise means to me (which is roughly what I said)
05:50:31 <mxc_> basically large, corporate projects
05:50:35 <quicksilver> is all about complexity and communication and legacy
05:50:36 <mxc_> quicksilver, you are basically right
05:50:44 <quicksilver> and by definition they are mostly secret
05:50:47 <quicksilver> so we mostly don't know :)
05:50:52 <mxc_> let me rephrase to just "large projects"
05:50:59 <quicksilver> but certainly jane street uses haskell to some extent too
05:51:14 <quicksilver> and so do some quant outfits
05:51:17 <quicksilver> for financial models and stuff
05:51:21 <mxc_> if they do its very very recent and quite unlikely
05:51:36 <Igloo> dcoutts_: GHC doesn't know anything about NamedFieldPuns
05:51:49 <dcoutts_> Igloo: yes, that's the problem
05:51:58 <mxc_> i'd actually be shocked if they used ocaml they've basically spent so much time rewriting the ocaml std libraries
05:52:05 <dcoutts_> Igloo: NamedFieldPuns as an extension name has been around for ever
05:52:25 <sioraiocht> I'm trying to implement a dynamic array for a specific use, is there a way to cheaply copy elements from one array to another
05:52:26 <lambdabot> sioraiocht: You have 1 new message. '/msg lambdabot @messages' to read it.
05:52:28 <dcoutts_> Igloo: when all the new ghc extensions were added in 6.8, I think we didn't notice that NamedFieldPuns was the real name for the thing ghc implements
05:52:56 <Igloo> Oh, I see
05:53:02 <dcoutts_> Igloo: and so we added an extra name instead. If that's the case I think we should correct it.
05:53:04 <int-e> dcoutts_: the option used to be called -frecord-puns in 6.8.1, which certainly didn't help
05:53:16 <dcoutts_> int-e: ah yes
05:53:22 <dcoutts_> that would not help at all
05:54:15 <Igloo> dcoutts_: Does anyone use NamedFieldPuns? Or RecordPuns?
05:54:21 <dcoutts_> Igloo: not many
05:54:29 <dcoutts_> is my impression
05:54:48 <Igloo> It seems unlikely that anyone uses NamedFieldPuns, as it wouldn't work with GHC 6.8.2, right?
05:54:57 <dcoutts_> Igloo: right.
05:55:35 <gpd> im not sure if this is the proper place for newcomers to ask questions but i was curious about the feasibility of using haskell for numerical/scientific programming.  specifically, how is the performance for matrix/arrays/etc
05:56:01 <Igloo> dcoutts_: So all things being equal, which name would we prefer to use?
05:56:08 <dcoutts_> Igloo: the old name I think
05:56:13 <dcoutts_> Igloo: ie NamedFieldPuns
05:56:17 <Igloo> OK
05:56:27 <sioraiocht> gpd: This is the right place, that's a bit of a vague question, though.
05:56:33 <dcoutts_> Igloo: so rename it internally in ghc and support RecordPuns as a deprecated alias for NamedFieldPuns
05:56:35 <Igloo> dcoutts_: Can you file a bug then, please?
05:56:36 <malcolmw> interestingly, the term 'record' is not defined in the H'98 report at all.
05:56:40 <dcoutts_> Igloo: yep
05:56:50 <sioraiocht> gpd: Naïve haskell is far slower than, for example, naïve C
05:56:59 <Igloo> malcolmw: Does it just refer to them as labelled fields or something all the time?
05:57:41 <gpd> sioraiocht: what about library support for matrix manipulation (analogous to say scipy for python).  do these exist and give similar performance gains?
05:57:47 <malcolmw> Igloo: all the definitions use the term "labelled fields", because at the time it was added, it was recognised to be a long way short of real records
05:58:24 <malcolmw> Igloo: although it is true that the word "record" does appear a couple of times in passing (probably by mistake), although it is never defined
05:58:44 <sioraiocht> gpd: http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics lists a lot of maths libraries
05:58:45 <slarba> gpd: check hmatrix
05:58:45 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/hq4t3
05:58:56 <sioraiocht> I don't know how complete it is, though
05:59:16 <sioraiocht> They should all be faster than using haskell's List or Array types, though
05:59:25 <slarba> gpd: hmatrix is implemented using LAPACK bindings afaik
05:59:26 <gpd> sioraiocht, slarba: thanks, ill look into hmatrix.
06:00:09 <sioraiocht> gpd: Haskell should also GENERALLY be faster than Python
06:00:42 <gpd> i havent found anything similar to python's PIL for imaging though
06:01:22 <gpd> perhaps some library exists.  ill look at the site
06:01:47 <slarba> I have a (yet unpublished) PNG decoder library for use with opengl (texture loading)
06:01:52 <slarba> written in pure haskell
06:02:34 <gpd> sounds like an interesting project
06:02:38 <slarba> it performs decently, though API is very rough.
06:03:09 <quicksilver> I use wx for loading images
06:03:18 <quicksilver> don't do anythiing clever with them though
06:03:23 <cjay> this question probably comes up often, but I can't find the answer: why is there no way to automatically create a typeclass for ambiguous record field names? would that be a bad idea?
06:03:23 <quicksilver> just shove them on opengl textures
06:03:29 <slarba> quicksilver: that works, also SDL_image but they're large dependencies
06:03:50 <quicksilver> cjay: people do indeed discuss that
06:03:59 <quicksilver> I think it's solving the wrong problem, in a way.
06:04:19 <cjay> I've searched through the proposed haskell' features, but couldn't find that idea
06:04:28 <sioraiocht> are there any dynamic array implementations in haskell?
06:04:30 <slarba> hey, another question: has anyone considered ranged types for ghc?
06:04:52 <slarba> like a :: Int<10..20> and when a gets out of that range, runtime would assert
06:05:21 <sioraiocht> slarba: ah, you mean like refinement types
06:06:30 <slarba> sioraiocht: yeah, if that's the official name for that :)
06:06:42 <twobitwo2k> gaurds could serve that purpose, kind of.
06:06:51 <cjay> the haskell-prime mailinglist doesn't seem to have a search index
06:06:56 <slarba> twobitwo2k: yes, but that's manual checking
06:06:58 <sioraiocht> slarba: check out Sage programming language
06:06:59 <malcolmw> slarba: you can define your own enumeration: data Short = Ten | Eleven | Twelve | ... | Twenty deriving (Eq, Ord, Ix)
06:07:03 <sioraiocht> http://sage.soe.ucsc.edu/
06:07:05 <lambdabot> Title: Sage: A Programming Language with Hybrid Type-Checking
06:07:17 <slarba> malcolmw: I know, but how about ranges having million elements?
06:08:27 <sioraiocht> slarba: you would probably define a type that uses Int and overloads operations and uses guards to give runtime errors
06:08:29 <malcolmw> slarba: I suppose you could newtype over Integer, then add bounds-checking to every operation in Num
06:08:43 <slarba> hmm, ok.. that works
06:09:15 <sioraiocht> slarba: now, if you're talking STATICALLY verifying such things, welcome to my thesis proposal =p
06:09:34 <slarba> sioraiocht: that would be the ultimate thing to do of course :)
06:09:51 <sioraiocht> slarba: hopefully in 3 years I'll have something to show you...
06:09:53 <slarba> proving that something remains within the range
06:10:54 <Toxaris> would that be different from statically checking for regular integer overflows?
06:11:10 <slarba> sioraiocht: abstract interpretation stuff?
06:11:31 <slarba> your thesis I mean
06:11:31 <Toxaris> (which is not done in any language I know)
06:11:55 <sioraiocht> Toxaris: there are program analysis tools that do that for you
06:12:29 <sioraiocht> slarba: It's on using types to define a specification and proving it at compile time
06:14:26 <Toxaris> sioraiocht: yeah, but they are not integrated into type systems / type checkers, are they?
06:14:53 <sioraiocht> no, not currently
06:15:01 <Toxaris> but you will change that :)
06:15:06 <sioraiocht> hopefully!
06:15:08 <slarba> how about ada? it has refinement types
06:15:21 <slarba> but I think it will inject runtime checks into generated code
06:15:26 <sioraiocht> slarba: they are checked at runtime
06:15:32 <slarba> which can be removed with recompile
06:15:33 <slarba> yes
06:16:47 <eek> sioraiocht, are you sure they're always checked dynamically?  because I've understood this as being optimized away in a lot of cases
06:17:14 <sioraiocht> eek: that might be true, I'm not 100% sure atm.
06:17:14 <slarba> sioraiocht: you know P. Cousot's papers about abstract interpretation?
06:17:34 <Toxaris> maybe you can simulate a intervall-based type system in Haskell with phantom types and type class magic, e.g. newtype Checked l h = Checked Integer, and l, h being type-level representions of lower and higher bounds of the dynamic value
06:17:39 <sioraiocht> slarba: yes
06:20:29 <BMeph> Sounds like just another example of how people Hate that Haskell doesn't do subtyping... :|
06:20:37 <sioraiocht> lol
06:21:39 <mm_freak1work> what is subtyping?
06:21:56 <sioraiocht> mm_freak1work: think of super/sub classes in java
06:21:58 <sioraiocht> same idea
06:22:36 <mm_freak1work> doesn't make sense to me, since java has a totally different type concept
06:22:55 <mm_freak1work> a superclass would be a supertype in haskell
06:23:18 <BMeph> ...a super type class! ;)
06:23:31 <sioraiocht> A is a subtype of B if A's fields are a superset of B's fields
06:23:49 <quicksilver> I don't really agree with sioraiocht's version.
06:23:54 <sioraiocht> lol okay
06:23:56 <quicksilver> A is a subtype of B if all As are Bs.
06:24:06 <quicksilver> doesn't have to be about fields, although that's one concrete kind of subtyping.
06:24:17 <Toxaris> A is a subtype of B if the extension of A is a subset of the extension of B
06:24:27 <quicksilver> mm_freak1work: this is *precisely* the way in which java's type concept is totally different haskells
06:24:35 <qebab> I should be able to construct all composite integers < 1E8 containing two prime factors with a list of all primes < 5E7, right?
06:24:46 <quicksilver> java is fundamentally based around subtypes and supertypes
06:25:02 <quicksilver> and haskell doesn't have them.
06:25:10 <eek> qebab, yes
06:25:22 <mm_freak1work> qebab: nub [ x*y | x <- primes, y <- primes]
06:25:37 <qebab> I don't understand what I am doing wrong ):
06:25:40 <Toxaris> mm_freak1work: for example, one could imagine that Int is a subtype of Integer
06:25:46 <qebab> mm_freak1work: that's basically what I am doing
06:25:50 <osfameron> typeclasses are sortof subtypes
06:26:12 <quicksilver> typeclasses have subtype relationships between them.
06:26:15 <mm_freak1work> Toxaris: so with "subtyping" something completely different is meant?
06:26:27 <Toxaris> mm_freak1work: different to what?
06:26:53 <Toxaris> quicksilver: subtypeclass relationships?
06:29:17 <quicksilver> Toxaris: what we call classes might be called types by someone else.
06:29:29 <quicksilver> Toxaris: if you think 'Num' is a type, then certainly Integral is a subtype of it.
06:29:37 <quicksilver> however, it's not what haskell calls a type.
06:29:54 <mm_freak1work> > let primes = filter (\x -> and $ map ((/= 0) . rem x) [2..x-1]) [2..] in nub [ x*y | x <- take 10 primes, y <- take 10 primes ]
06:29:57 <lambdabot>  [4,6,10,14,22,26,34,38,46,58,9,15,21,33,39,51,57,69,87,25,35,55,65,85,95,115...
06:30:31 <mm_freak1work> Toxaris: different to the sub-/superclassing of object-oriented languages
06:30:57 <Toxaris> mm_freak1work: subclassing /= subtyping :)
06:31:17 <mm_freak1work> Toxaris: <sioraiocht> mm_freak1work: think of super/sub classes in java <sioraiocht> same idea
06:31:42 <Toxaris> mm_freak1work: sioraiocht /= Toxaris :)
06:31:58 <mm_freak1work> Toxaris: but that's what i was referring to ;)
06:32:05 <Toxaris> from my point of view, subclassing is about code reuse
06:32:15 <sioraioc_> fine, last time I try and give YOU people a concrete example =p
06:32:22 <Toxaris> and subtyping is about describing sets of values
06:32:40 <Toxaris> in many (all?) OO languages, these things are thightly coupled, i.e., the same
06:32:43 <mm_freak1work> hehe
06:33:00 <qebab> mm_freak1work: I am writing it in C, but this channel has mathematicians, so I figured it'd be the right place to ask :p the algorithm is the same, though
06:33:13 <mm_freak1work> Toxaris: i don't think that OO languages in the classic view of types can offer such a thing
06:33:22 <mm_freak1work> haskell's type system can, theoretically
06:33:49 <mm_freak1work> qebab: in C, you'll have to solve it differently
06:34:03 <qebab> I am finding that there are 44832018 such numbers
06:34:07 <mm_freak1work> at least, if you don't want to precompute primes
06:34:41 <qebab> mm_freak1work: I am precomputing the primes, using an efficient sieve that I have verified the correctness of
06:34:50 <qebab> other than that, the approach is the same
06:34:58 <sioraioc_> is it possible to use copy values from one MutableByteArray to another using a memcpy-like function?
06:35:24 <Toxaris> mm_freak1work: "classic view of types"?
06:35:49 <Toxaris> mm_freak1work: actually, I'm not sure what you mean with "such a thing" either. subtypes decoupled from subclasses
06:36:19 <mm_freak1work> qebab: then do the following:  for (i1 = 0; i1 < MAX; i1++) { for (i2 = i1; i2 < MAX; i2++) { save_somewhere(primes[i1] * primes[i2]); } }
06:36:33 <mm_freak1work> qebab: if you want to exclude squares, then start i2 at i1+1
06:37:10 <qebab> mm_freak1work: that is exactly what I am doing, except that I need only the amount of numbers, not the numbers themselves (and I want to include squares)
06:37:23 <mm_freak1work> Toxaris: "such a thing" = subtyping in terms of values, "classic view of types" = the C idea of types
06:37:46 <mm_freak1work> qebab: if you want an exact amount, you have to compute it
06:38:04 <mm_freak1work> there is no exact formula, otherwise you'd have a prime counting function, and such a thing isn't found yet
06:38:12 <Toxaris> mm_freak1work: in modern OO languages, we have generics, variance annotations and stuff like that wich makes the subtyping relation more complicated then the subclassing relation. some OO languages feature structural subtyping. some OO languages don't feature classes.
06:40:00 <Toxaris> mm_freak1work: If I remember correctly, Pascal had types of the form 4..17, and a simple kind of subtyping, e.g., you could provide a value of type 8..10 when a value of type 4..17 was needed. unfortunately, these intervall types were basically unchecked.
06:40:09 <ivanm> anyone have any ideas what to do if darcs suddenly decides to not let you unrecord patches because it can't find a tarball with some patches in it?
06:40:11 <qebab> mm_freak1work: basically, what I am doing is: result = 0; for (i = 0; i < len; i++) for (j = i; j < len; j++) { if (primes[i] * primes[j] < lim) nums++; else break; }
06:40:40 <mm_freak1work> Toxaris: and that's just interval arithmetic, no real subtyping
06:40:53 <Toxaris> mm_freak1work: how is that no real subtyping?
06:40:54 <qebab> I am starting to suspect that I have misunderstood the problem
06:41:18 <mm_freak1work> qebab: in fact, that's exactly the way you have to do it
06:41:40 <BMeph> ivanm: revert? :)
06:41:44 <mm_freak1work> but you could optimize it by aborting the inner loop, when the product is out of range
06:42:01 <mm_freak1work> Toxaris: well, it is, but just a very special case
06:42:05 <qebab> s/nums++;/result++;
06:42:16 <ivanm> BMeph: well, I recorded a patch, didn't like it, unrecorded, changed it, recorded again, realised I didn't like it but now it can't unrecord :s
06:42:51 <BMeph> ivanm: Zoiks!  =8*O
06:42:54 <Toxaris> mm_freak1work: what do you expect? the the programmers specifies arbitrary subtype relationships, and the type checker verifies them? thats too hard, of course.
06:42:56 <mm_freak1work> Toxaris: in real subtyping, Float would be a subtype of Double, and Float, Double and Integer would be a subtype of Rational
06:43:32 <int-e> qebab: beware of overflows.
06:43:57 <qebab> int-e: ahhh, of course
06:44:02 <qebab> gaaahhh
06:44:04 <qebab> ):
06:44:15 <ziman> @pl [f x | x <- xs, p x]
06:44:15 <lambdabot> [f x | x <- xs, p x]
06:44:19 <BMeph> ivanm: Did you literally use the "record" and "unrecord" commands? Because if you did, it likely didn't do what you thought was happening. :)
06:45:05 <ivanm> I used "darcs record" and "darcs unrecord"
06:45:23 <ivanm> now it keeps complaining that some tarballs are missing in _darcs/patches
06:45:52 <BMeph> ivanm: "unrecord       Remove recorded patches without changing the working copy."
06:45:57 <Toxaris> mm_freak1work: how can Float be a subtype of Double? Float-values are bitvectors of 32bit, and Double-values are bitvectors of 64bit. there is not a single Float value which is a Double value. ... It all depends on the interpretation :)
06:46:15 <int-e> qebab: just write the second loop as  for (j=0; j<=i; j++) { /* as before */ }
06:46:21 <ivanm> BMeph: yes... but has that got to do with it not finding tarballs with the patches in them?
06:46:33 <ivanm> e.g. /gentoo/gentoo-haskell/_darcs/patches/20060322225757-1db7e-8c0d67c274ad1459f00cba0a018f0591d9324910.gz: openBinaryFile: does not exist (No such file or directory)
06:46:33 <ivanm> Perhaps this is a 'partial' repository?
06:46:43 <BMeph> I.e., it sounds like you wanted to change what was in you working copy, not just your tarball.
06:46:58 <ivanm> I'm currently resorting to wget'ing the ones it's complaining about from the central repo on haskell.org
06:47:31 <ivanm> BMeph: nope, nothing to revert :s
06:48:00 <qebab> int-e: I got it right now, it was a bloody overflow ):
06:48:03 <mm_freak1work> Toxaris: my interpretation is in terms of a generalized (==) operator
06:48:08 <BMeph> ivanm: :(
06:48:17 <Toxaris> mm_freak1work: so there is no "real" subtyping without talking about the actual types and values. most subtyping-aware languages offer some rough approximation of the real subset-relationship of the extensions of the types, based on prebuild rules (like intervall-arithmetic in Pascal) or subclassing
06:48:20 <ivanm> exactly my feeling :s
06:49:19 * ivanm is tempted to backup his changes and re-get the repo :s
06:49:34 <BMeph> ivanm: Does your copy check?
06:50:10 <ivanm> nope... failed to read a whole bunch of patches :s
06:50:20 <Toxaris> mm_freak1work: I agree, you can define a complete subtype system by giving an (==) operator which works on all values regardless of their types.
06:51:59 <BMeph> ziman: pl doesn't "grok" list comprehensions. :)
06:52:15 <mm_freak1work> Toxaris: from what i've understood, A is a subtype of B, if for each value x::A, there is exactly one y::B, for which x ==== y, where ((====) :: forall a b. a -> b -> Bool), and that for each y::B, at most one such x::A exists
06:53:18 <mm_freak1work> but such a relation can probably only be declared by humans
06:53:50 <Toxaris> I don't think you need "exactly one" etc. but I'm not sure.
06:54:07 <Toxaris> Yes, that's the idea behing subtyping, how it is implemented in real languages is a different questions
06:55:21 <mm_freak1work> i don't think, you don't need, too, but i'm also unable to find an example, where one x::A maps to many y::B
06:55:36 <BMeph> Toxaris: ...and how it is supported. :)
06:55:43 <ziman> BMeph, yeah, apparently :)
06:56:09 <mm_freak1work> if x ==== y and x ==== z, then in my view y == z, since (====) is a generalized (==)
06:56:34 <BMeph> mm_freak1work: E6 and E12
06:56:41 <Toxaris> BMeph: and whether it is really related to this idea, or just shares the name.
06:56:54 <BMeph> mm_freak1work: Fixed-point representations, that is. :)
06:57:18 <mm_freak1work> BMeph: i don't understand
06:59:25 <BMeph> mm_freak1work: Let's simplify to E3 and E4. 1.234 "===" 1.2340, but 1.2341 would also correspond to 1.234 in E3.
07:00:22 <mm_freak1work> E3 is a subtype of E4, but 1.2341::E4 ==== 1.123::E3 should be False
07:00:31 <mm_freak1work> the values are not equal
07:00:51 <mm_freak1work> if they were, then E3 would be the same as E4
07:01:28 <Toxaris> mm_freak1work: I have understood that I can define ==== however I like, and get a subtype relation returned. but now you seem to have a pretty specific ==== in mind which I don't understand at all
07:02:20 <mm_freak1work> Toxaris: i've just defined axioms for (====)…  i've left the exact interpretation open, but mine would be a generalized (==) relation
07:03:08 <BMeph> Mmm, okay, I messed up there. I agree w/ your "exactly one" and "at most one" qualifications, then, unless Toxaris can come up with a counter... :)
07:03:10 <Toxaris> so how does your ==== know that 1.2 :: Float ==== 1.2 :: Double, even though these are totally different values and not equal in any sense
07:03:44 <Toxaris> (except the "I know what they mean to me as a programmer"-sense, which doesn't count)
07:03:45 <mm_freak1work> Toxaris: they are equal in the sense of numeric interpretation
07:04:07 <int-e> > toRational (1.2 :: Float) == toRational (1.2 :: Double)
07:04:20 <lambdabot>  False
07:04:36 <int-e> > toRational (1.25 :: Float) == toRational (1.25 :: Double)
07:04:37 <lambdabot>  True
07:04:38 <BMeph> Denotationally equal, while operationally different? :)
07:05:28 <Toxaris> that would imply unsound implementation, wouldn't it?
07:05:49 <Toxaris> I think we should try to avoid floating point numbers, they are evil.
07:05:54 <mm_freak1work> int-e: that's a rounding error
07:06:00 <int-e> 1.2 can't be represented exactly. In that sense, writing 1.2 :: Float is misleading, because it involves rounding.
07:06:12 <mm_freak1work> > 1.2::Float * 10 == 12
07:06:12 <lambdabot>  Parse error at "*" (column 12)
07:06:19 <mm_freak1work> > (1.2::Float) * 10 == 12
07:06:20 <lambdabot>  True
07:06:35 <eek> Toxaris, they're very handy for a lot of things, though.  maybe stick with using only Double?  if I've understood correctly, it's as fast as Float on modern processors
07:06:43 <eek> as fast as or often faster
07:07:02 <mm_freak1work> > last [ 1.0, 1.2 .. 5000 ]
07:07:03 <lambdabot>  4999.9999999976435
07:07:04 <BMeph> > toRational (1.2 :: Float)
07:07:05 <lambdabot>  5033165%4194304
07:07:10 <Toxaris> eek: I do not mean generally avoid, just avoid in a discussion about the general meaning of subtyping
07:07:10 <BMeph> =8*O
07:07:34 <kaol> > toRational (1.2 :: Double)
07:07:35 <lambdabot>  5404319552844595%4503599627370496
07:07:43 <Toxaris> eek: we are talking about the connection between subtyping and equality, and since equality is a bit of problem with floating points, we are lost now :(
07:07:44 <mm_freak1work> Toxaris: i think, an axiom for (====) is needed
07:08:04 <eek> Toxaris, ah, right.  I think I agree - all floating point implementations are sort of off on the side
07:08:34 <mm_freak1work> no rounding errors occur, if the demoninator of the number is a power of two
07:08:47 <daf> surely it's not a problem of the implementations: floating point has rounding errors by nature
07:08:51 <mm_freak1work> > last [ 1, 1.0625 .. 5000]
07:08:52 <lambdabot>  5000.0
07:08:59 <BMeph> eek: It the number is not... yeah, what mm_freak1work said. :)
07:09:07 <BMeph> s/It/If
07:09:54 <BMeph> daf: Binary representation of numbers is an implementation detail. :)
07:09:58 <eek> daf, I don't mean that it's a bug in the implementations - I meant that floating point works in a way where we lose precision in most cases, and this makes them fit badly with precise reasoning
07:09:59 <mm_freak1work> daf: a floating point number is nothing but a binary number…  as you can't notate 1/3 cyclefree in decimal, you can't notate 1/5 cycle-free in binary
07:10:13 <mm_freak1work> daf: sorry, that was meant for eek
07:10:36 <daf> BMeph:
07:10:45 <BMeph> daf:
07:10:54 <BMeph> :)
07:11:01 <BMeph> ?bot?
07:11:01 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
07:11:03 <daf> BMeph: right, but every representation will lose precision for some numbers :)
07:11:08 <Toxaris> mm_freak1work: I think to realy define this things, we have to talk about the semantics of the language we want to add subtyping to. e.g., for floating points, a sensible semantic domain for Float is *not* the set of real numbers, but the set of sets of real numbers, since each Float value can stand for a set of real numbers.
07:11:22 <mm_freak1work> Toxaris: we're not lost because of the equality relation of floating point types, but because our (====) relation is too abstract, i think
07:11:36 <mm_freak1work> we need an axiomatic description of (====)
07:12:04 <mar77a> how would i do pattern matching for an array?
07:12:10 <mar77a> i'm trying to write a maximum function for arrays
07:12:18 <mm_freak1work> so that you can clearly state that Int8 is a subtype of Float, but Int32 isn't
07:12:23 <mar77a> i need some guidelines :<
07:12:42 <mm_freak1work> mar77a: you can't pattern-match for them, because their constructors aren't public
07:12:49 <mar77a> o_Ô
07:12:50 <mm_freak1work> but you can use guards
07:13:03 <quicksilver> the simplest way to find the maximum of an array is to convert it to a list first.
07:13:07 <int-e> mar77a: use elems and go from there?
07:13:22 <quicksilver> the simplest way to do any operation which uses all the elements of an array once only is to pretend it's a list :)
07:13:47 <Toxaris> mm_freak1work: I would say: for some ====, Int8 is a subtype of Float, for other ====, it isn't. would that be a problem for you?
07:13:52 <mm_freak1work> true…  arrays are inconvenient anyway…  their only advantage is their speed =)
07:14:06 <int-e> > let arr = listArray (0, 100) [1..] in maximum $ elems arr
07:14:07 <lambdabot>  101
07:14:13 <mm_freak1work> and for many purposes, lists even outperform arrays
07:14:25 <BMeph69> Toxaris: So, what info are you trying to communicate with your "==="? :)
07:14:36 <int-e> and for many purposes, arrays outperform lists
07:14:44 <mm_freak1work> Toxaris: it wouldn't…  probably that's our main issue
07:15:31 <int-e> but for iterating over an array, using  elems  or  assocs  is generally a good idea
07:15:46 <Toxaris> BMeph69: It's mm_freak1work's ==== :) I misinterpreted it like this: given a equivalence relation ====, subtyping is defined by A <: B iff forall x : A . exists y : B . x ==== y.
07:16:39 <mm_freak1work> Toxaris: i think, we need a general axiomatic description of (====), and then we can derive specific subtyping instances from that, like numeric subtyping, memory-representational subtyping, etc.
07:16:53 <mar77a> gar i need a type signature for
07:16:56 <mar77a> arrayMax = maximum . elems
07:17:31 <int-e> oh the dreaded monomorphism restriction
07:17:32 <mm_freak1work> (IArray e a, Ix i) => a i e -> e
07:17:52 <int-e> arrayMax a = maximum (elems a)  wouldn't need one.
07:18:06 <mar77a> ah
07:18:10 <Toxaris> mm_freak1work: yes, sound sensible. But what's from with the following set of axioms: {}
07:18:12 <int-e> mm_freak1work: you need an Ord e in there
07:18:28 <mm_freak1work> Toxaris: ?!
07:18:30 <mar77a> and IArray is Ix right
07:18:34 <mm_freak1work> int-e: true
07:18:41 <Toxaris> mm_freak1work: Note that I've written "equivalence relation ====", which is a axiomatic description
07:19:03 <mm_freak1work> Toxaris: (====) cannot be an equivalence relation
07:19:52 <Toxaris> mm_freak1work: why not?
07:20:13 <mm_freak1work> because an equivalence relation is symmetric, and that doesn't make sense here
07:20:33 <int-e> mar77a: ah, to add to the confusion, if you import Data.Array, the signature is (Ix i, Ord e) => Array i e -> e; if you import Data.Array.IArray, it'll be (IArray a e, Ix i, Ord e) => a i e -> e.
07:20:54 <BMeph69> mm_freak1work: Okay, now you Really lost me there... :)
07:21:01 <int-e> mar77a: (the advantage of the latter is that it'll work on unboxed arrays as well)
07:21:03 <mar77a> import Array
07:21:21 <int-e> Array is Data.Array in the hierarchical libraries
07:21:26 <Toxaris> mm_freak1work: why not?
07:22:04 <mm_freak1work> BMeph69: symmetry of an equivalence relation states that if a ==== b, then b ==== a
07:22:14 <Toxaris> mm_freak1work: if, for example, 1.0 ==== 1, there certainly is no problem with 1 ==== 1.0, is there?
07:22:26 <mar77a> @hoogle elems
07:22:26 <lambdabot> Data.Set.elems :: Set a -> [a]
07:22:26 <lambdabot> Data.Map.elems :: Map k a -> [a]
07:22:26 <lambdabot> Data.IntSet.elems :: IntSet -> [Int]
07:22:27 <mm_freak1work> Toxaris: there is:  overspecialization
07:22:53 <int-e> hum, hoogle doesn't index the arrays package?
07:23:16 <Toxaris> mm_freak1work: Ok, you mean that we don't gain anything by restricting ourselves to symmetric ====?
07:23:24 <mm_freak1work> you don't need the symmetry or transivity, you only need reflexivity…  that saves you from having to define that relation into both directions
07:23:38 <mm_freak1work> → transitivity
07:24:04 <al-maisan> Hi there!
07:24:16 <BMeph> It's an equivalence, not a partition, right? ;)
07:24:25 <Toxaris> mm_freak1work: well, if you a non transitive ====, the induced subtyping relation will not be transitive (which is fine for me)
07:24:29 <al-maisan> I have a list of strings passed from the command line that I want to convert to integers
07:24:30 <BMeph> ...D'Oh! :O
07:24:38 <mm_freak1work> BMeph: a partition is something different ;)
07:24:57 <al-maisan> How do I deal with "Exception: Prelude.read: no parse" in case that an user passed in something like "abc"
07:25:27 <mm_freak1work> Toxaris: another question to ask is:  do we actually need subtyping?
07:25:30 <int-e> @index readMaybe
07:25:31 <lambdabot> bzzt
07:25:38 <Toxaris> mm_freak1work: if you have a non reflexive ====, the subtype relationship will not be reflexive, which is also fine for me, but maybe not for you
07:25:41 <BMeph> al-maisan: use reads, vice read. ;)
07:25:48 <int-e> > reads "abc" :: [(Int, String)]
07:25:49 <lambdabot>  []
07:25:54 <int-e> > reads "12abc" :: [(Int, String)]
07:25:55 <lambdabot>  [(12,"abc")]
07:26:08 <Toxaris> mm_freak1work: I already proposed to set of axioms {}, which is certainly not overspecialized ;)
07:26:17 <al-maisan> BMeph: thanks
07:26:29 <BMeph> al-maisan: You're very welcome. :)
07:27:04 <mm_freak1work> Toxaris: yes, but i'm wondering, whether subtyping would be of use…  it would certainly, for other languages, but for haskell?
07:27:36 <BMeph> Tox, mm_: How would that make sense that "===" wouldn't be reflexive?
07:27:39 <mm_freak1work> our type classes give us a way to do subtyping
07:28:29 <mm_freak1work> BMeph: if you search long enough, you certainly find examples, because we aren't restricting ourselves to numeric subtyping
07:28:44 <Toxaris> BMeph: wouldn't make that much sense :) My POV is that we know the relationship "<:" is reflexive if "===" is reflexive
07:29:47 <mm_freak1work> d'oh
07:29:51 <Toxaris> BMeph: so we have to restrict us to reflexive "===" only if we actually want a reflexive "<:" for some reason
07:29:55 <BMeph> Toxaris: Okay, I thought you meant that in the sense of "is NOT reflexive," vice "is not STATED to be reflexive". :)
07:30:03 <mm_freak1work> i've confused reflexivity with symmetry =)
07:30:43 <mm_freak1work> but actually, if we don't demand symmetry, we also shouldn't demand reflexivity
07:30:55 <BMeph> mm_freak1work: AHA! So I'm not the only one who makes simple flubs...that reassures me, somehow. ;)
07:31:15 * Toxaris keeps looking these things up in wikipedia
07:31:51 <mm_freak1work> my whole point is that an equivalence relation in X is a subset of X²
07:32:12 <mm_freak1work> while our (====) relation would rather be a subset of X*Y
07:32:25 <mm_freak1work> (*) being the cartesian product, of course
07:32:38 <vixey> wow
07:32:41 <BMeph> I suppose if your logic system doesn't let you define reflexivity, then you'd have to do without it. However, I think that for the intended purposes of the relation, it has to be reflexive.
07:32:51 <mm_freak1work> so our (====) is much more general than an equivalence relation
07:33:08 <Toxaris> oh, I dream of all semantic domains united into a big set BIG, and ==== a subset of BIG
07:33:34 <BMeph> Toxaris: I Like it! >:)
07:33:55 <mm_freak1work> actually that's a good way to define all that =)
07:34:02 <Toxaris> a bit like type erasure :)
07:34:41 * BMeph now runs off to look up stuff on Wikipedia...
07:35:36 <mm_freak1work> type A is an X-eric subtype of B, if for each x::A there exists a y::B with x ==== z and y ==== z for some z in X
07:35:58 <vixey> what is this ?
07:36:25 <vincenz> how do I force a specific version of the bytestring library in the build script?
07:37:01 <Toxaris> mm_freak1work: you introduced the X (and the z) to distinguish Numeric subtypes, ... subtypes, and so on?
07:37:09 <mm_freak1work> Toxaris: yes
07:37:56 <Toxaris> mm_freak1work: why not use different ===='s instead?
07:38:43 <BMeph> vincenz: "build-depends: bytestring-0.9.0.4"
07:38:52 <mm_freak1work> Toxaris: because it appears easier to me to define the semantics in terms of a large set instead of a relation
07:38:53 <vincenz> BMeph: no in the 'build' script
07:39:18 <Toxaris> but a relation is a large set?
07:40:07 <byorgey> vincenz: what 'build' script?
07:40:14 <BMeph> vincenz: ...eh? Okay, I don't understand, so I'll just shut up now. :)
07:41:04 <mm_freak1work> Toxaris: with defining (====) i see a risk that A >> B and B >> C, but not A >> C
07:41:17 <mm_freak1work> Toxaris: though that's rather intuitive
07:41:18 <vixey> wtf is ==== o_o
07:41:26 <Toxaris> mm_freak1work: subtyping is normally writen as "<:", afaik
07:41:36 <mm_freak1work> ok
07:41:42 <mm_freak1work> vixey: nothing concrete yet =)
07:41:50 <vixey> are you talking about John Major equality?
07:42:03 <Toxaris> mm_freak1work: well, if ==== is transitive, <: will be transitive.
07:42:25 <vincenz> byorgey: lambdabot, but I just removed the newer bytestirng package altogether
07:42:50 <mm_freak1work> Toxaris: true, but one problem still remains…  how would you define (====) for numeric subtyping?
07:43:01 <mm_freak1work> vixey: never heard of that
07:43:22 <mm_freak1work> Toxaris: wouldn't you define it in terms of a large set anyway?
07:43:39 <mxc_> more fun with records, say i have a type data Rec = A {x :: Int} | B {y :: String}
07:43:53 <vixey> mm_freak1work: I guess it's like  (=) :: A -> B -> Prop
07:43:57 <mxc_> then i get 2 functions, x :: Rec -> int and y :: Rec -> String
07:44:05 <byorgey> mxc_: right
07:44:17 <vixey> mm_freak1work: but it's only inhabited when A = B and a : A, b : B, a = b
07:44:33 <vixey> (warning anything I say might not be totally correct*)
07:44:35 <mxc_> but, that doesn't seem safe because what happens on: > y (A {x=5})
07:44:47 <byorgey> mxc_: exactly, it's not
07:44:54 <byorgey> you get a pattern-match failure, I think
07:45:35 <Toxaris> mm_freak1work: I would enumerate all pairs of numbers I consider as equivalent.
07:46:09 <mxc_> is there any way to get compile time checking for that?
07:46:35 <mm_freak1work> Toxaris: you could also define a subtype relation in terms of an injective mapping
07:47:01 <BMeph> Toxaris: You just Hate all those people that want Naturals in Hask, don't you? DON'T YOU?!?!  ;)
07:47:02 <byorgey> mxc_: there may be tools to check for it (maybe Catch?) but I don't think the compiler can do anything about it.
07:47:32 <Toxaris> mm_freak1work: but maybe your question about whether we need / want subtypes in Haskell is more, well, interesting?
07:47:33 <byorgey> mxc_: in general, it's impossible to statically determine whether a value of type Rec will always use one constructor or the other.
07:47:47 <Toxaris> BMeph: I would use Haskell to enumerate a infinitely large set, if you mean that
07:47:47 <mm_freak1work> Toxaris: yes, because IMO we don't need them
07:47:56 <byorgey> mxc_: generally, for this reason you probably want to avoid record syntax on data types with multiple constructors.
07:47:58 <mm_freak1work> we have our from* and to* family of functions
07:48:29 <mxc_> if, if you dont do that, no two records in the same module can have identically named fields
07:48:36 <mm_freak1work> in fact, that's the injective mapping i meant =)
07:50:32 <byorgey> mxc_: I think in the latest version of GHC, you actually can have identically named fields in certain situations where the compiler can unambiguously figure out which one you mean.
07:50:45 <byorgey> mxc_: I don't recall the details, though, you'll have to consult the GHC manual.
07:50:48 <mxc_> byorgey> only if in separate modules
07:50:52 <vincenz> Does anyone know where to redefine the '>' prefix for eval?
07:50:58 <byorgey> mxc_: ah, ok.
07:51:20 <mxc_> but, then you can't pput multiple modules into one file, so i see this as just being kind of a headache
07:51:20 <trontonic> How does Haskell compare to Dylan?
07:51:39 <vixey> trontonic: I don't think it does really
07:51:46 <BMeph> mm_freak1work: I say we need them, if only because, for instance, Naturals should be defined in a way that doesn't force cut-and-paste copying of the code for Integers. ;p
07:52:05 <trontonic> vixey: They are both programming languages. Why do you think they can't be compared?
07:52:26 <mm_freak1work> BMeph: that's a technical issue ;)
07:52:41 <vixey> trontonic: any comparison would be less effective than just describing each language in isolation
07:53:06 <trontonic> vixey: so you do admit that they can be compared, after all? :)
07:53:27 <BMeph> mxc_: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
07:53:28 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
07:53:37 <Toxaris> mm_freak1work: if you have subtypes, its cheaper to use very small and accurate types, which descripe exactly what you want, instead of a bigger type which you use for convenience
07:53:55 <vixey> trontonic: no
07:54:00 <mxc_> bmpeh_ thanks, but  we were talking about that earlier, it requires each record to come from a different module
07:54:46 <trontonic> vixey: anyways, I wasn't looking for the most effective description, but a comparison. Sometimes programmers feel that a language is one way or another. That was what I was looking for, not a full description of each language.
07:54:56 <BMeph> Toxaris: Cheaper for what/who? ;)
07:55:04 <mm_freak1work> Toxaris: again, a technical issue, not a theoretical
07:55:14 <Toxaris> BMeph: cheaper for the programmer
07:55:19 <byorgey> mxc_: the Haskell record system could definitely use some improvement. =(
07:55:38 <Toxaris> BMeph: no need to explicitly wrap and unwrap newtypes etc.
07:55:41 <trontonic> vixey: and, you are contradicting yourself when you first say you don't think they can be compared, then say the comparison would be less effective, and then answer "no" to a question if you would admit that they could be compared
07:56:04 <Toxaris> mm_freak1work: if we believe in turing equivalence, everything is purely technical :)
07:56:40 <mm_freak1work> Toxaris: i mean, how could subtyping help here?
07:57:01 <vixey> Prelude> let negate -x = x
07:57:01 <vixey> Prelude> negate 4
07:57:01 <vixey> -4
07:57:09 <quicksilver> well for example suppose your data model is about Foobles
07:57:12 <mm_freak1work> in other words:  what would be your type signature for a function that works on integers, but never uses values larger than what Word64 can hold?
07:57:17 <quicksilver> some foobles are foos, and other foobles are bars
07:57:26 <quicksilver> you really want foos and bars to be separate types
07:57:31 <quicksilver> but if they are, you have a lot of unwrapping to do
07:57:36 <Deewiant> > let negate -x = x in 1 - 3
07:57:37 <lambdabot>  3
07:57:49 <quicksilver> often in haskell-like languages you have foo and bar as separate constructors (but not real separate types)
07:57:54 <Toxaris> mm_freak1work: f :: Word64 -> Word64
07:58:02 <quicksilver> and this leads to inaccurate types for some of your functions.
07:58:06 <Deewiant> vixey: see above in case you found that confusing :-)
07:58:09 <mm_freak1work> Toxaris: ok, now where is subtyping useful here?
07:58:16 <quicksilver> most haskell programs of significant size come up against this kind of thing.
07:58:42 <Toxaris> mm_freak1work: hmm thats wrong, we need something more complicated :(
07:58:56 <vixey> Deewiant: that's different
07:59:00 <trontonic> > 3 - 3
07:59:01 <lambdabot>  0
07:59:05 <vixey> wait ........
07:59:11 <Deewiant> vixey: no, that's exactly what you typed :-)
07:59:12 <mm_freak1work> Toxaris: the point is, you would need to do it manually anyway…  the compiler couldn't deduce that from the code
07:59:29 <mm_freak1work> so, you could just as well just use an appropriate type (or class)
07:59:39 <Toxaris> mm_freak1work: f :: (n >: Word64) => n -> Word64
07:59:39 <vixey> it's not like there's anything similar to n+k patterns
07:59:42 <vixey> for -x
07:59:44 <vixey> ?
07:59:57 <Deewiant> don't think so, no
08:00:07 <Deewiant> > let negate (-x) = x in negate 4
08:00:08 <lambdabot>  Parse error in pattern at "in" (column 21)
08:00:16 <Deewiant> evidently not
08:00:42 <mm_freak1work> Toxaris: what's the advantage over (f :: Integral i => i -> i)?  that it prefers Integer, if you don't give an explicit type?
08:01:57 <Toxaris> mm_freak1work: Hmm. I think this is a bad example, because the numerical class hierarchy is already there. consider something programmer-defined like quicksilver's example
08:02:32 <mm_freak1work> then you can express it in terms of classes again =)
08:02:38 <quicksilver> you can of course
08:02:43 <quicksilver> and it's a lot of work to make those classes
08:02:44 <Toxaris> mm_freak1work: yes. and subtyping would be cheaper for the programmer.
08:03:15 <mm_freak1work> how?  in that you don't need to separate foos from bars anymore?  i think you have to
08:03:16 <FordCortina> !maybe Noting
08:03:18 <Toxaris> mm_freak1work: you don't need any classes. you can pass dictionary records around instead.
08:03:31 <quicksilver> there is all kinds of things you can do
08:03:34 <quicksilver> and indeed I do.
08:03:38 <quicksilver> it's not a huge massive problem
08:03:44 <quicksilver> it doesn't make haskell a useless language
08:03:50 <quicksilver> but it is an expressivity barrier
08:03:52 <quicksilver> and slightly annoying
08:04:31 <trontonic> > [1.0, 1.1..1.3]
08:04:32 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003]
08:04:55 <Toxaris> mm_freak1work: but still, you use classes, since they are more convenient and cheaper to write. but they add nothing to the language. As I understand it, they were introduced to avoid name clash problems, a purely syntactical feature of the language.
08:05:00 <FordCortina> \msg lambdabot > maybe Nothing
08:05:16 <quicksilver> > [1.0,1.1..1.3] :: [Rational]
08:05:17 <lambdabot>  [1%1,11%10,6%5,13%10]
08:05:25 <trontonic> quicksilver: thanks! :)
08:05:34 <quicksilver> rationals ftw!
08:05:49 <mm_freak1work> map (/10) [1..10]
08:05:53 <mm_freak1work> > map (/10) [1..10]
08:05:54 <lambdabot>  [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
08:06:43 <mxc_> is there anyway to put multiple modules in one file with GHC?
08:07:11 <quicksilver> no.
08:07:16 <trontonic> Out of curiosity, why is [1.0, 1.1..1.3] not implemented in a way that gives similarly formatted results as map (/10) [1..10]? :)
08:07:37 <mm_freak1work> trontonic: because the idea is different
08:07:56 <trontonic> mm_freak1work: this boggles my mind, but as most things in Haskell I guess it has a good reason
08:08:03 <mm_freak1work> take 11 (iterate (+0.1) 0)
08:08:06 <mm_freak1work> > take 11 (iterate (+0.1) 0)
08:08:07 <mxc_> quicksilver - even if those modules only need to be visible to each other
08:08:07 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
08:08:39 <quicksilver> mxc_: the answer is no.
08:08:43 <Vq^> trontonic: it's not very specific to haskell
08:08:49 <mxc_> ah the joys of binary floating point numbers
08:09:04 <mm_freak1work> trontonic: i demanded exactness by using map…  it's a different computational approach and yields different results…  also it would require (/)
08:09:10 <mm_freak1work> finally the map version is much slower
08:09:29 <mm_freak1work> > sum [1, 1.1 .. 10000]
08:09:31 <lambdabot>  5.0000499550040853e8
08:09:40 <trontonic> Vq^: true, I know it is a common issue with floating point numbers, however it seems like it is smoothed over in some parts of Haskell, but not others
08:09:44 <mm_freak1work> > sum $ map (/10) [1..100000]
08:09:46 <lambdabot>  5.00005e8
08:09:56 <trontonic> mm_freak1work: I see. Thanks :)
08:10:38 <quicksilver> mm_freak1work: not quite the same calculation I think.
08:10:39 <Vq^> > take 10 $ iterate (+0.1) 1
08:10:41 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
08:10:47 <mm_freak1work> quicksilver: it isn't =)
08:10:48 <quicksilver> mm_freak1work: first should start with 0.1, I guess, not 1.
08:11:00 <mm_freak1work> quicksilver: the map version is slower, but much more accurate
08:11:00 <quicksilver> mm_freak1work: I mean, not even comparable in the sense you were trying to compare.
08:11:00 <vixey> > take 10 $ iterate (+0.1) (1::CReal)
08:11:02 <lambdabot>  [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9]
08:11:03 <Vq^> trontonic: it's a big difference to work with + compared to /
08:11:09 <mm_freak1work> true
08:11:09 <quicksilver> mm_freak1work: because 1/10 is not 1.
08:11:10 <Vq^> trontonic: and thats true for any language
08:11:15 <mm_freak1work> > sum $ map (/10) [10..100000]
08:11:16 <lambdabot>  5.000049955e8
08:11:59 <trontonic> Vq^: agree
08:12:15 <FordCortina> is there a library function for maybe Nothing? I want to apply a function to a Maybe value but I just want to return Nothing if I get Nothing
08:12:33 <Saizan> FordCortina: fmap
08:12:53 <FordCortina> Saizan: thanks
08:12:57 <Baughn> FordCortina: >>=
08:13:30 <mm_freak1work> FordCortina: you want to make use of the monadic features of Maybe =)
08:13:59 <ToRA> FordCortina: <$>
08:14:17 <hexpuem> is it possible to use ArrowChoice (|||) to branch based on the result of a function stuck in the IO monad?
08:14:24 <FordCortina> thanks all. I knew i was missing something :)
08:14:58 <Baughn> @hoogle Maybe a -> (a -> b) -> Maybe b
08:14:58 <lambdabot> No matches, try a more general search
08:15:13 <Saizan> ?type (|||)
08:15:15 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
08:15:17 <Baughn> Room for improvement there. :/
08:16:21 <quicksilver> Baughn: the real hoogle gives some results for that.
08:16:48 <quicksilver> Baughn: although sadly fmap is down on page two :(
08:17:01 <Saizan> hexpuem: yes, but you need the Kliesli wrapper to use Arrow* methods on (a -> IO b)
08:17:04 <mm_freak1work> @hoogle Monad m => m a -> (a -> m b) -> m b
08:17:05 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
08:17:05 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
08:17:05 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
08:17:14 <Baughn> quicksilver: Hm. I thought lb /used/ the real hoogle (or at least the package) now
08:17:26 <mm_freak1work> well, i expected (>>=)
08:17:33 <quicksilver> uses an old version perhaps?
08:17:42 <quicksilver> mm_freak1work: this hoogle knows nothing about type classes.
08:17:43 <hexpuem> saizan: ill check it out, thanks
08:17:54 <mm_freak1work> oh, ok
08:17:56 <Saizan> hoogle 3 just does a textual search
08:18:00 <vixey> is there a google that does?
08:18:07 <quicksilver> the real hoogle, yes, I think so
08:18:11 <mm_freak1work> @hoogle Maybe a -> (a -> Maybe b) -> Maybe b
08:18:11 <lambdabot> No matches, try a more general search
08:18:21 <mm_freak1work> odd
08:18:25 <vixey> ?djinn Maybe a -> (a -> Maybe b) -> Maybe b
08:18:26 <lambdabot> f a b =
08:18:26 <lambdabot>     case a of
08:18:26 <lambdabot>     Nothing -> Nothing
08:18:26 <lambdabot>     Just c -> b c
08:18:28 <quicksilver> hmm, maybe not.
08:18:34 <quicksilver> maybe it's the next version of hoogle that will.
08:18:37 <mm_freak1work> maybe it doesn't know anything about types at all =)
08:18:46 <Toxaris> I understand Neil that the next version will handle type classes
08:20:45 <mm_freak1work> > do { x <- Just 3; y <- Just (x^2); Just y+2 }
08:20:46 <lambdabot>   add an instance declaration for (Num (Maybe t))
08:20:55 <mm_freak1work> > do { x <- Just 3; y <- Just (x^2); Just (y+2) }
08:20:56 <lambdabot>  Just 11
08:21:05 <mm_freak1work> > do { x <- Just 3; y <- Nothing; Just (y+2) }
08:21:06 <lambdabot>  Nothing
08:21:47 <Baughn> @src Maybe fmap
08:21:47 <lambdabot> fmap _ Nothing       = Nothing
08:21:47 <lambdabot> fmap f (Just a)      = Just (f a)
08:22:23 <Baughn> @src M.Map fmap
08:22:23 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:22:26 <mm_freak1work> @type join . fmap
08:22:28 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
08:22:28 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
08:22:28 <lambdabot>     In the second argument of `(.)', namely `fmap'
08:22:45 <mm_freak1work> @type \f -> join . fmap f
08:22:47 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f a) -> f a1 -> f a
08:22:50 <vixey>  > fmap (+1) (Just (Just 1))
08:23:00 <mm_freak1work> @type \f -> flip (join . fmap f)
08:23:02 <lambdabot> forall a b a1. (a1 -> b -> a) -> b -> (b -> a1) -> a
08:23:02 <vixey> > fmap (+1) (Just (Just 1))
08:23:03 <lambdabot>   add an instance declaration for (Num (Maybe t))
08:23:05 <vixey>  > (+1) . (Just (Just 1))
08:23:07 <vixey> > (+1) . (Just (Just 1))
08:23:08 <lambdabot>   add an instance declaration for (Num (Maybe t))
08:23:22 <vixey> @src Maybe mappend
08:23:22 <lambdabot> Source not found. Maybe you made a typo?
08:23:25 <Baughn> > join (Just (Just 2))
08:23:26 <lambdabot>  Just 2
08:23:42 <mm_freak1work> > join Just Nothing
08:23:43 <lambdabot>  Couldn't match expected type `(->) a' against inferred type `Maybe'
08:23:52 <mm_freak1work> > join $ Just Nothing
08:23:53 <lambdabot>  Nothing
08:24:15 <mm_freak1work> i love haskell for this englishness =)
08:24:25 <mm_freak1work> forever $ do
08:24:47 <trontonic> > 2%3 :: Rational
08:24:48 <lambdabot>  2%3
08:24:55 <Baughn> @type until
08:24:57 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
08:24:58 <nolrai_> > fmap (fmap (+1)) $ [Nothing, Just 2]
08:24:58 <vixey> expected vs inferred always confuses me
08:25:00 <lambdabot>  [Nothing,Just 3]
08:25:10 <mm_freak1work> until ?!
08:25:13 <mm_freak1work> @where until
08:25:14 <lambdabot> I know nothing about until.
08:25:18 <Baughn> > until (>3) (+1) 0
08:25:19 <lambdabot>  4
08:25:29 <trontonic> Why does 2%3 work with lambdabot, while ghci says that % is not in scope?
08:25:41 <mm_freak1work> trontonic: :m Data.Ratio
08:25:50 <trontonic> mm_freak1work: ah, thank you :)
08:26:12 <Baughn> trontonic: Lambdabot has a rather non-standard prelude. Look in Pristine.hs if you're curious
08:26:50 <mm_freak1work> @where (%)
08:26:51 <lambdabot> I know nothing about (%).
08:27:49 <quicksilver> it's not jsut that LB has a non-standard prelude
08:27:52 <quicksilver> although in a sense it does
08:28:00 <Baughn> > reverse $ until ((> 10) . length) (\l -> l!!0 + l!!1 : l) [1,0]
08:28:01 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55]
08:28:02 <quicksilver> it's also that it imports a huge bunch of useful modules by default.
08:28:42 <vixey> Baughn cool
08:29:20 <vixey> > map last . iterate (\l -> l!!0 + l!!1 : l) $ [1,0]
08:29:21 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
08:29:23 <Baughn> vixey: Tying the knot is considerably better, but as tools for understanding until go..
08:29:28 <vixey> > map head . iterate (\l -> l!!0 + l!!1 : l) $ [1,0]
08:29:29 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
08:29:43 <mm_freak1work> > fst $ iterate (\(a,b) -> (b,a+b)) (0,1)
08:29:47 <lambdabot>  Couldn't match expected type `(a, b)'
08:29:57 <Baughn> mm_freak1work: first
08:30:04 <Baughn> mm_freak1work: Oh, wait. head. first is CL.
08:30:18 <vixey> > map fst . iterate (\(a,b) -> (b,a+b)) $ (0,1)
08:30:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
08:30:36 <mm_freak1work> d'oh
08:30:52 <nolrai_> can Bounded be derived?
08:31:07 <Baughn> nolrai_: Try it, see what happens
08:31:15 <mm_freak1work> nolrai_: unlikely
08:31:17 <twobitwo2k> is there any reasoning why ghci sometimes uses type-variables other than a, b, etc? like sometimes it uses t...
08:31:19 <quicksilver> yes, it can.
08:31:39 <Baughn> twobitwo2k: It attempts to apply conventions. Sometimes it even succeeds.
08:31:49 <mm_freak1work> twobitwo2k: convention
08:31:53 <twobitwo2k> Baughn: what convention would that be?
08:31:56 <mm_freak1work> it uses 'm' for monads
08:32:04 <twobitwo2k> yeah...
08:32:08 <Baughn> twobitwo2k: Specific example, please?
08:32:15 <twobitwo2k> myMap :: (t -> a) -> [t] -> [a]
08:32:39 <mar77a> :t id
08:32:39 <quicksilver> twobitwo2k: it copies the type variables from type sigs you give
08:32:41 <lambdabot> forall a. a -> a
08:32:41 <Baughn> ..no clue.
08:32:44 <quicksilver> twobitwo2k: or others it has in scop.e
08:32:47 <mar77a> :t (=)
08:32:49 <lambdabot> parse error on input `='
08:32:55 <mm_freak1work> twobitwo2k: seems pretty random/incidental
08:33:03 <quicksilver> twobitwo2k: when it has to rename, it does.
08:33:07 <twobitwo2k> quicksilver: I didn't give any type sigs :)
08:33:12 <quicksilver> the prelude does.
08:33:13 <Baughn> mar77a: Syntax. Maybe you want ==?
08:33:15 <twobitwo2k> ahh
08:33:23 <mar77a> :t (==)
08:33:28 <lambdabot> forall a. (Eq a) => a -> a -> Bool
08:33:38 <mar77a> > (==) 5 5
08:33:54 <twobitwo2k> c'mon, you can do it, lambdabot
08:33:58 <lambdabot>  thread killed
08:34:01 <twobitwo2k> ?
08:34:04 <mm_freak1work> huh?!
08:34:07 <Baughn> > 5 == 5
08:34:14 <geezusfreeek> been doing that a lot
08:34:15 <mm_freak1work> @src (==)
08:34:15 <lambdabot> x == y = not (x /= y)
08:34:18 <Baughn> @undefine (==)
08:34:21 <mm_freak1work> @src (/=)
08:34:23 <lambdabot>  thread killed
08:34:26 <Baughn> @undefine ==
08:34:29 <geezusfreeek> for a while there lambdabot hated id too, but i don't know if that's still true
08:34:33 <lambdabot> thread killed
08:34:33 <lambdabot> x /= y = not (x == y)
08:34:38 <Baughn> It gets hung if ...
08:34:39 <mm_freak1work> lol
08:34:42 <lambdabot> thread killed
08:34:45 <mm_freak1work> that explains why ;)
08:34:48 <twobitwo2k> heh
08:34:48 <Baughn> Cale: There? Fix your bot, please. ;)
08:34:49 <mar77a> i'm such a visionary
08:35:18 <Baughn> > (==) 5 5
08:35:20 <Cheiron>  True
08:35:22 <mm_freak1work> > (5::Int) == 5
08:35:22 <lambdabot>  True
08:35:23 <lambdabot>  True
08:35:23 <Cheiron>  True
08:35:24 <vixey> It's so reassuring when you see comments like "Yuck!! Cast away const.  fe-gtk does this so it must be ok.."
08:35:27 <mm_freak1work> > (5::Int) /= 5
08:35:28 <Cheiron>  False
08:35:29 <lambdabot>  False
08:35:34 <vixey> espically in non-type-safe languages..
08:35:37 <geezusfreeek> works all of a sudden…
08:35:47 <Baughn> ..there we go. It just wanted some reassurance from a fellow bot.
08:35:49 <mm_freak1work> > (5::Integer) == 5
08:35:50 <Cheiron>  True
08:35:52 <lambdabot>  True
08:35:54 <Baughn> @leave #haskell
08:35:54 <lambdabot> Not enough privileges
08:36:00 <mar77a> > let (+) a b = a - b
08:36:00 <lambdabot>  Parse error at end of input
08:36:12 <geezusfreeek> > 5 == 5
08:36:14 <lambdabot>  True
08:36:15 <twobitwo2k> in ...
08:36:26 <twobitwo2k> > let (+) a b = a - b in 4 + 4
08:36:27 <lambdabot>  0
08:36:32 <vixey> actually yeah lambdabot is really broken
08:36:37 <mar77a> how did someone manage to override (==) then
08:36:49 <twobitwo2k> ohh... I don't knoew
08:36:53 <Baughn> vixey: Well, not exactly..
08:36:59 <Saizan> override?
08:37:00 <mm_freak1work> @let (==) = (+)
08:37:04 <mm_freak1work> > 3 == 4
08:37:05 <lambdabot> Defined.
08:37:06 <lambdabot> Terminated
08:37:09 <Baughn> vixey: I /think/ the problem is that the machine it's on is really overloaded, so it keeps timing out
08:37:10 <mm_freak1work> > 3 == 4
08:37:10 <lambdabot> Terminated
08:37:20 <mm_freak1work> @undefine (==)
08:37:20 <lambdabot> Undefined.
08:37:24 <mar77a> is there any way to undefine all
08:37:25 <mm_freak1work> > 3 == 4
08:37:26 <lambdabot>  False
08:37:28 <twobitwo2k> @src (==)
08:37:29 <lambdabot> x == y = not (x /= y)
08:37:29 <mar77a> something like :m :l
08:37:32 <Baughn> @undefine-all
08:37:32 <lambdabot> Unknown command, try @list
08:37:35 <Baughn> @undefine all
08:37:36 <lambdabot> Undefined.
08:37:39 <mar77a> ca ching
08:37:46 <Baughn> @undefine the sun
08:37:47 <lambdabot> Undefined.
08:37:52 <Baughn> I wonder.
08:37:55 <mar77a> heh
08:38:28 <twobitwo2k> @undefine =
08:38:30 <lambdabot> Undefined.
08:38:32 <twobitwo2k> heh
08:40:30 <Socrates> Right, exams are done for the summer
08:40:36 <Socrates> I've got 4 months of bordom ahead
08:40:47 <twobitwo2k> @seen dons
08:40:47 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
08:40:49 <Socrates> Anyone got any good (intermediate level) Haskell project ideas?
08:40:55 * twobitwo2k shoots lambdabot 
08:41:11 <Baughn> Socrates: Reimplement platonian ideals in haskell
08:41:14 <twobitwo2k> Socrates: a Rails-like web framework :)
08:41:40 <Baughn> Socrates: Write me a fuse FFI. ;)
08:41:44 <quicksilver> a web framework which is in no way like rails, and thus actually good?
08:41:45 <quicksilver> ;P
08:42:00 <Socrates> Hmm, without research, those ideas sound slightly beyond my haskell ability at the moment :P
08:42:06 <twobitwo2k> quicksilver: well... I meant "rails-like in concept, haskell-like in design and implementation"
08:43:14 <Baughn> Socrates: How about a HTTP client library?
08:43:29 <Baughn> Socrates: There's one there already, but someone needs to add pipelining and a few other things
08:43:53 <Baughn> Socrates: ..actually, just look at the SoC list and pick something nobody else has taken. ;)
08:43:54 <mm_freak1work> we have two good web frameworks, hAppS and WASH
08:44:05 <Socrates> Hmm SoC? Got a link for that?
08:44:17 <Baughn> Socrates: #haskell-soc
08:44:38 <Socrates> Cheers Baughn
08:44:52 <Baughn> Socrates: It's a bit late to apply for it, but you should still be able to get an (unofficial) mentor if you seriously take a whack at one of them
08:45:08 <Socrates> I'll hope a poke about, see if anything interests me
08:45:15 <Socrates> s/hope/have
08:46:31 <mm_freak1work> Socrates: if you're totally bored, try to do the H-99
08:46:45 <mm_freak1work> http://haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
08:46:46 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
08:47:17 <Socrates> Heh, not sure I'm that bored yet, tho' give me another two weeks and no doubt I'll be asking for that link again
08:48:08 <mm_freak1work> hehe
08:48:11 <mm_freak1work> it's actually fun
08:54:31 <ronwalf> So the datatypes ala carte paper uses right associative constructors: data (f :+: g) e = Inl (f e) | Inr (g e)
08:54:39 <ronwalf> That's not haskell 98, is it?
08:54:58 <ronwalf> Well, the constructor isn't inline
08:55:17 <ronwalf> but the type is (that's the right terminology, right?)
08:55:27 <ronwalf> ghc likes it, hugs does not
08:55:29 <gbacon> @info splitRegex
08:55:29 <lambdabot> splitRegex
08:55:33 <gbacon> @type splitRegex
08:55:40 <lambdabot> Not in scope: `splitRegex'
08:55:45 * gbacon frowns
08:56:25 <vixey> > 1+1
08:56:40 <lambdabot>  thread killed
08:58:07 <ronwalf> topdecl 	 -> 	 data [context =>] simpletype = constrs [deriving]
08:58:07 <ronwalf> simpletype 	-> 	tycon tyvar1 ... tyvark 	(k>=0)
08:58:11 <ronwalf> (from the haskell report)
08:58:23 <roconnor> @ops
08:58:23 <lambdabot> Maybe you meant: docs oeis pl
08:58:30 <vixey> ?where op
08:58:31 <lambdabot> I know nothing about op.
08:58:32 <ronwalf> I guess it's not so legal
08:58:33 <Lemmih> vixey: You only have three seconds. Try something less computational complex.
08:58:52 <roconnor> @where ops
08:58:52 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
08:58:56 <Baughn> >42==42
08:58:58 <Baughn> > 42==42
08:59:00 <lambdabot>  True
08:59:08 --- mode: ChanServ set +o dcoutts_
08:59:09 <Baughn> @undefine (+)
08:59:21 <lambdabot> Undefined.
08:59:27 <Baughn> > 1+1
08:59:28 <lambdabot>  2
08:59:29 <bos> roconnor: what's up?
08:59:51 <tverwaes> \x -> x
09:00:01 <vixey> :t \x -> x
09:00:06 <lambdabot> forall t. t -> t
09:00:07 <roconnor> bos: there was a global notice that people should op themselves.  I guess ChanServe is disappearing for a few minutes.
09:00:17 <bos> oh.
09:01:15 --- mode: ChanServ set +o Saizan
09:02:20 <vixey> @seen musasabi
09:02:21 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
09:02:28 <vixey> yeah lambdabot is broken
09:02:30 <BMeph> D'Oh!
09:02:39 <roconnor> preflex: seen musasabi
09:02:40 <preflex>  Sorry, I haven't seen musasabi
09:02:51 <vixey> rewrite from scratch
09:02:55 <vixey> that's what I'd do
09:02:59 <gbacon> @index
09:02:59 <lambdabot> bzzt
09:03:03 <gbacon> @index splitRegex
09:03:03 <lambdabot> Text.Regex
09:03:18 <BMeph> I think vincenz is in the middle of that pain now...
09:03:24 <Baughn> vixey: The state system fails any acid check you care to give it. The rest is fine. And there's a very simple fix, so..
09:03:32 * Baughn pokes renameFile
09:03:41 <vixey> oh cool vincenz++
09:04:06 <vixey> I would like to have a better djinn but I'm not sure how to do it
09:04:14 <vixey> It would be cool to add typeclasses
09:04:39 <vixey> I wonder what set of typeclasses still let djinn be a decision procedure
09:05:56 <dcoutts_> Baughn: aye, writeFileAtomic, Cabal has an implementation of that
09:06:27 * dcoutts_ thinks writeFile should be writeFileAtomic
09:06:30 <Baughn> dcoutts_: I'm halfway tempted to make it use sqlite, but writeFileAtomic would fit well with the way it works now
09:08:57 <roconnor> there she goes
09:09:27 <vixey> pretty odd actually
09:09:42 <vixey> I wonder what they were thinking when they programmed the IRC server
09:10:02 <vixey> "should we allow instant update of the services? no .. wouldn't be useful"
09:10:13 <BMeph> vixey: If you want a better djinn, talk to augustss, or work on the old one. ;)
09:10:29 <Baughn> vixey: While you're at it, wonder why it takes more than a second or two to bring back up
09:10:49 <vixey> Baughn: ChanServ has to type /join #haskell /join ... for a LOT of channels :P
09:11:03 <Baughn> vixey: I refuse to believe it works like that.
09:11:55 <znutar> yeah, chanserv probably has "/join" on the clipboard and just pastes it
09:12:05 <vixey> BMeph: I think it would be fun to code but I'm not sure where to start
09:12:28 <nolrai_> :t M.lookup
09:12:29 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
09:12:43 <vixey> BMeph: stuff like Monad m => join :: m (m a) -> w a should let you ?djinn m (m (m (m a))) -> m a
09:12:53 * EvilTerran is tempted sometimes to write a djinn that can use typeclass instances
09:13:03 <twobitwo2k> a what?
09:13:07 <vixey> EvilTerran: that's exactly what I want
09:13:21 <BMeph> djinn m (m (m (m a))) -> m a
09:13:22 <vixey> EvilTerran: Do you have any idea what set of typeclasses let it remain decideable?
09:13:27 <twobitwo2k> ahh
09:13:27 <BMeph> ?djinn m (m (m (m a))) -> m a
09:13:28 <lambdabot> -- f cannot be realized.
09:13:34 <vixey> @djinn-env
09:13:34 <lambdabot> data () = ()
09:13:34 <lambdabot> data Either a b = Left a | Right b
09:13:34 <lambdabot> data Maybe a = Nothing | Just a
09:13:34 <lambdabot> data Bool = False | True
09:13:34 <lambdabot> data Void
09:13:36 <lambdabot> type Not x = x -> Void
09:13:37 <EvilTerran> and maybe that tries to recurse structurally on recursively-typed parameters and recurse guardedly for a recursively-typed result
09:13:38 <lambdabot> class Eq a where (==) :: a -> a -> Bool
09:13:48 <ziman> :t join . join . join
09:13:50 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m (m a))) -> m a
09:14:12 <vixey> EvilTerran: I'm not interested in recursion though (too hard)
09:14:35 <BMeph> vixen: How about co-recursion? Easier - or harder for ou? ;)
09:14:36 <nolrai_> :t M.lookup
09:14:36 <EvilTerran> vixey, i'd think it'd still be decidable for everything that doesn't need -XUndecidableInstances
09:14:37 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
09:14:46 <BMeph> s/vixen/vixey
09:14:51 <vixey> EvilTerran: how do you get that conclusion?
09:14:55 <twobitwo2k> I still need to learn about kinds
09:15:02 <vixey> BMeph: corecusion is horrifying
09:15:03 <EvilTerran> hand-waving and intuition :P
09:15:10 <vixey> EvilTerran: ok lol
09:15:30 * BMeph drones "these are not the co-recursions you're looking fro...
09:15:34 <vixey> twobitwo2k: Do you know how types related to values?
09:15:42 <EvilTerran> but having typeclasses just means that you have to pattern-match types against instance heads when seeing which "laws" (aka definitions) you can apply to an expression
09:15:44 <vixey> twobitwo2k: kinds relate to types in exactly the same way
09:15:55 <twobitwo2k> right, kinds relate to types... but that still doesn't click in my head
09:16:00 <BMeph> Yich, if I keep this up, I'm going to break down and learn to type... :|
09:16:12 <vixey> twobitwo2k: 3 :: Integer,  Integer :: *
09:16:25 <twobitwo2k> are all types :: * ?
09:16:29 <vixey> yes
09:16:35 <twobitwo2k> are there any other kinds?
09:16:41 <vixey> twobitwo2k: \x -> x+1 :: Integer -> Integer,  Maybe :: * -> *
09:16:54 <vixey> twobitwo2k: Maybe :: * -> *, Integer :: *, Maybe Integer :: *
09:17:09 <BMeph> twobitwo2k: Monads are * -> *, generally.
09:17:23 <vixey> twobitwo2k: \x -> x+1 :: Integer -> Integer, 3 :: Integer,  ((\x -> x+1) 3) :: Integer
09:17:48 <byorgey> not just generally, monads are always * -> * .
09:17:49 <vixey> twobitwo2k: does it click now? :)
09:17:56 <byorgey> i.e. an instance of Monad must have kind * -> *.
09:17:59 <twobitwo2k> ohhhhhh.... so you think of parameterized types as sort of like "type functions" which accept a type of kind * and return a type of kind *
09:18:10 <vixey> twobitwo2k: Certainly
09:18:19 <vixey> type Constructors
09:18:20 <twobitwo2k> ok...
09:18:24 <byorgey> twobitwo2k: not even "sort of" =)
09:18:33 <vixey> well we don't call them type functions
09:18:38 <vixey> but that is really what they are
09:18:44 <twobitwo2k> right, that's why I said sort of
09:18:49 <vixey> (we don't say value functions either)
09:19:20 <vixey> what is the type of * ?
09:19:42 <twobitwo2k> so.... now, I need to know how this fits into the "forall" notation
09:19:49 <twobitwo2k> does * have a type?
09:19:59 <vixey> it doesn't
09:20:06 <vixey> (fit into forall)
09:20:09 <twobitwo2k> ok, I didn't think it would
09:20:11 <twobitwo2k> ohh
09:20:24 <vixey> forall a, a -> a :: *
09:20:27 <twobitwo2k> then what does this mean:  forall k a (m :: * -> *).
09:21:00 <Baughn> twobitwo2k: "m is a type constructor taking a type and returning another type"
09:21:06 <vixey> m could be Maybe, [], or (,)Integer
09:21:08 <byorgey> it means for all type variables k, a, and m, where k and a represent something with kind * and m represents something with kind * -> *
09:21:09 <Baughn> Such as any monad
09:21:23 <byorgey> (k :: *) and (a :: *) are implicit
09:21:34 <twobitwo2k> byorgey: ok, I see
09:21:50 <vixey> k :: * and a :: * would be inferrable if you had the full type
09:21:51 <twobitwo2k> kind of like a "type guard" :)
09:21:58 <vixey> like a -> a you know a :: *
09:22:12 <vixey> you can't have (a :: * -> *) -> (b :: * -> *)
09:22:42 <twobitwo2k> right, because you can't pass types into functions
09:22:46 <twobitwo2k> (?)
09:23:06 <vixey> if you could pass types into functions you still couldn't have that
09:23:27 <twobitwo2k> but wouldn't passing Maybe into a function satisfy that?
09:23:42 <vixey> no
09:23:47 <vixey> Maybe :: * -> *
09:23:55 <vixey> * -> * :: ?
09:24:23 <vixey> oh wait a sec
09:25:18 * Baughn enjoys the infinite regress. Sorts of kinds of types of values... where does it all end?
09:25:19 <vixey> twobitwo2k: Yeah you're right
09:25:36 <twobitwo2k> heh... I was about  be really confused :)
09:27:38 <quicksilver> Baughn: it's turtles all the way down.
09:27:56 <twobitwo2k> uh-oh... there are sorts?
09:28:01 <Baughn> quicksilver: Then what we want to do is implement lazy typing
09:28:05 <Baughn> twobitwo2k: Not in haskell
09:28:12 <twobitwo2k> ohh... swew
09:28:20 <twobitwo2k> whew, even
09:28:32 <vixey> Baughn: You don't have to typecheck 'Integer'
09:28:45 <vixey> and we know * is a valid Kind
09:28:51 <Baughn> twobitwo2k: But if you add type-level algebra, or even dependent typing.. you'll want sorts
09:29:00 <twobitwo2k> stop
09:29:05 <twobitwo2k> my head is starting to heart :P
09:29:16 <Baughn> twobitwo2k: And then you'll want the same for the sorts. They can even use the same machinery, so you get a literally infinite hierarchy of types.
09:29:17 <twobitwo2k> <- not a math-head
09:29:43 <vixey> oh I read about this
09:29:48 <vixey> Luos UTT
09:30:17 <Baughn> vixey: *Right now* we know * is a valid kind, since it's the only non-function sort of kind we have. If we had more than one sort of kind (okay, two, with * -> *), we would need explicit sorts.
09:30:30 <Saizan> you can say that in haskell all kinds have sort Box, we don't have kind-polymorphism or kind lambdas
09:30:32 <vixey> *0 *1 ... etc?
09:30:44 <vixey> oh yeah when you look at it as a PTS
09:31:04 <vixey> I want to find Harper, R. and Pollack, R. (1991). Type checking with universes
09:31:23 <Baughn> newkind M = M (forall a. Monad a => a -> *)
09:31:28 <vixey> newkind :D
09:31:32 --- mode: Saizan set +o glguy
09:31:55 <Baughn> I'm pretty sure that was neat-looking nonsense, though. I haven't looked much into it myself. :P
09:31:59 <vixey> Baughn ooh
09:32:09 <vixey> that seems more precise than * -> *
09:32:35 <Baughn> vixey: Exactly. Right now, we're basically using weak, dynamic.. kinding to implement our strong typing.
09:32:44 <vixey> dynamic kinding lol
09:32:54 <Baughn> vixey: Once we implement strong kinding, we'll need weak sorting to sort our kinds.
09:32:55 <vixey> I thought it was more like simple typing
09:33:14 <Baughn> vixey: And really, to have a *really* strongly-typed language, we'd need an infinite hierarchy. Which should be fine.
09:33:44 <vixey> Baughn: I was reading about Epigram today
09:34:04 <vixey> have you seen View From The Left?
09:34:10 <twobitwo2k> would it have to be a strict heirarchy, or would it be possible for a type to be a memeber of two "super-types"? in the same way that types belong to classes
09:34:34 <gbacon> @index on
09:34:34 <lambdabot> bzzt
09:34:38 <gbacon> @info on
09:34:38 <vixey> @src on
09:34:38 <lambdabot> on
09:34:38 <lambdabot> (*) `on` f = \x y -> f x * f y
09:34:41 <Baughn> twobitwo2k: Depends on the implementors, I imagine
09:34:44 <BMeph> Baughn: Wouldn't that newkind be (* -> *) -> *?
09:34:50 <vixey> Data.Function but the source code is much prettyer
09:35:14 <Baughn> BMeph: Yes, presumably so. Or (a* -> b*) -> c*
09:35:21 <Baughn> Well..
09:35:42 <Baughn> No, wait just a minute here. That's newtype.
09:35:48 <Baughn> newkind must be described using sorts, not kinds
09:35:51 <twobitwo2k> also, what would other kinds look like? and how would you determine if a type is over a certain kind? also (maybe same question), how are kinds really different from classes?
09:36:11 <quicksilver> classes can be considered to be kinds
09:36:26 <quicksilver> although conventional haskell notation is, in fact, not to consider them kinds.
09:36:37 <twobitwo2k> so why have kinds?
09:36:42 <quicksilver> given that classes are groupings of types they certainly could be considered kinds.
09:36:51 <quicksilver> haskell kinds are just used to count the arity of type constructors.
09:36:52 <twobitwo2k> or, rather, what's the difference?
09:36:57 <twobitwo2k> ah, ok
09:37:00 <quicksilver> :k Either
09:37:02 <lambdabot> * -> * -> *
09:37:06 <quicksilver> :k StateT
09:37:08 <lambdabot> * -> (* -> *) -> * -> *
09:37:16 <mm_freak1work> :k Monad m => m
09:37:17 <lambdabot>     `m' is not applied to enough type arguments
09:37:18 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
09:37:20 <vixey> :k RWST
09:37:22 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
09:37:23 <mm_freak1work> :k Monad m => m a
09:37:25 <lambdabot> *
09:37:41 <twobitwo2k> :k Monad
09:37:43 <lambdabot> Class `Monad' used as a type
09:37:46 <vixey> cool!
09:37:47 <twobitwo2k> ohh yeah :P
09:37:56 <vixey> I never thought about typeclasses like that
09:38:01 <vixey> that's really neat
09:38:18 <vixey> so how do you implement ad-hoc polymorphism?
09:38:35 <vixey> pattern matching on types?
09:38:35 <vixey> eoa
09:39:06 --- mode: glguy set +o erick
09:39:06 <Saizan> vixey: JHC does that iirc, GHC uses dictionaries
09:39:08 --- mode: erick set +t
09:39:21 <Baughn> vixey: Pattern-matchin on types...
09:39:30 <Baughn> vixey: I *like* this. It makes everything so very much simpler. :D
09:39:54 <vixey> hehe
09:40:12 <vixey> Baughn: and I Exploring the Regular Tree Types
09:40:17 <vixey> that was really good
09:40:39 <BMeph> vixey: I haven't found a bad McBride paper yet. :)
09:40:50 <Baughn> Oh gods. 66 pdfs to read.
09:40:59 <vixey> Baughn what is your list ?
09:41:00 <Baughn> ..good thing summer is coming up
09:41:04 <Baughn> vixey: I'm not sure
09:41:05 <matthew_-> does polythesism help there?
09:41:19 <vixey> What is polythesism?
09:41:25 <Baughn> A bad joke
09:41:53 <BMeph> Baughn: Start here: http://strictlypositive.org/publications.html :)
09:41:54 <lambdabot> Title: Conor McBride's Publications
09:42:07 <vixey> BMeph: I am absolutely confused by A Universe of Strictly Positive Families
09:42:12 <vixey> BMeph: have you read tis ?
09:42:32 <BMeph> vixey: Not yet, but it's on my "stack". :)
09:42:41 <matthew_-> vixey: polythesism is a religious system with more than one god. It was simply a reference to Baughn's "Oh gods..."
09:43:07 <BMeph> vixey: Read any Voigtlaender papers lately? ;)
09:43:34 <vixey> no I haven't
09:44:10 <vixey> he looks very like Bill Hicks ...
09:44:14 <BMeph> matthew_-: No, that's polytheism. Polythesism is the practise of explaining things with more than one (possibly conflicting) basis. ;)
09:44:33 <nolrai_> :P
09:44:51 <matthew_-> you mean it's not just submitting a polymorphic thesis?
09:44:56 <vixey> http://i5.photobucket.com/albums/y158/ivansaari/billhicks.jpg http://wwwtcs.inf.tu-dresden.de/~voigt/janis.voigtlaender.jpg
09:45:09 <Baughn> matthew_-: No, that would be panthesism
09:45:29 <Corun> "I'm not a frying-pan-theist"
09:45:48 <matthew_-> Corun: haven't you got exams to sit?
09:45:51 <Baughn> ..oh gods, the puns
09:45:52 <Corun> No, actually
09:45:59 <Corun> We finished
09:46:06 <Corun> Just got *smirk* prolog coursework
09:46:33 <Corun> And then a bunch'o'freetime
09:46:45 <Corun> And then I get to work on the same floor as you for two months
09:46:49 <Corun> Bwahahahaha
09:47:05 * matthew_- locks the doors
09:47:45 <vixey> hmm I don't understand free theorems yet
09:47:54 <vixey> I don't understand natural transforms either
09:47:58 <vixey> I wonder if there is a link ...
09:48:04 <[Justice]> how's your prolog coursework coming ... searching for the right solutions?
09:49:03 <Corun> Certainly searching
09:49:09 <Corun> For the right solutions?
09:49:11 <BMeph> vixey: Huh, you're right! I think I didn't notice it so much because of the red hair (of Voigtl..).
09:49:29 <vixey> certainly not a bad look :)
09:50:13 * BMeph thinks of ways to use "out of the frying pan-theism" jokes in regular conversation.
09:50:46 --- mode: glguy set +o dons
09:50:50 <Baughn> BMeph: Do it, and you'll get killed
09:51:29 <BMeph> Baughn: Oh - out of the frying-pan-theism, and into the fire? ;p
09:51:59 <BMeph>  /umode +w BMeph
09:52:04 <nolrai_> @src cycleSucc
09:52:04 <lambdabot> Source not found. Sorry.
09:52:15 <nolrai_> @src succ
09:52:15 <lambdabot> Source not found. Wrong!  You cheating scum!
09:52:16 <vixey> cycleSucc = snoc ?
09:52:32 <ToRA> @src Bool succ
09:52:33 <lambdabot> Source not found.
09:52:34 <BMeph> <Sniffs> It didn't work.
09:53:16 <BMeph> ?hoogle succ
09:53:17 <lambdabot> Prelude.succ :: Enum a => a -> a
09:53:17 <lambdabot> GHC.Conc.alwaysSucceeds :: STM a -> STM ()
09:53:17 <lambdabot> System.Exit.ExitSuccess :: ExitCode
09:53:20 <vixey> > let cycle(x:xs)=xs++[x] in iterate cycle "xyzw!"
09:53:22 <lambdabot>  ["xyzw!","yzw!x","zw!xy","w!xyz","!xyzw","xyzw!","yzw!x","zw!xy","w!xyz","!x...
09:53:59 <nolrai_> :t snoc
09:54:01 <vixey> @pl \(x:xs)->(x,xs)
09:54:01 <lambdabot> liftM2 (,) head tail
09:54:03 <lambdabot> Not in scope: `snoc'
09:54:19 <vixey> @pl \(x,xs)->xs++[x]
09:54:19 <lambdabot> uncurry (flip (++) . return)
09:54:31 <vixey> :t (uncurry (flip (++) . return)).(liftM2 (,) head tail)
09:54:34 <lambdabot> forall a. [a] -> [a]
09:55:01 <nolrai_> a taste of pl hell there, eh.
09:55:35 <vixey> liftM2 (,) head tail could be rewritten (head ^^ tail) fsvo ^^
09:56:15 <nolrai_> fsvo?
09:56:21 <BMeph> vixey: Lately, I've been warping my mind looking over Manfred von Thun's combinatorial expositing on Joy.
09:56:43 <vixey> BMeph: I tried Joy once .. it was so difficult :(
09:57:31 <BMeph> vixey: Do you already know Forth?
09:57:35 <vixey> no
09:57:45 <vixey> I don't actually have any experience with stack languages
09:57:46 <vixey> aoe
09:57:46 <nolrai_> @src Bounded
09:57:47 <lambdabot> class  Bounded a  where
09:57:47 <lambdabot>     minBound, maxBound :: a
09:57:47 <vixey> ops
09:58:01 <ToRA> > (head &&& tail) [1,2,3]
09:58:04 <BMeph> vixey: Hmm, that might explain things...
09:58:04 <lambdabot>  (1,[2,3])
09:58:12 <ToRA> > liftM2 (,) head tail [1,2,3]
09:58:13 <lambdabot>  (1,[2,3])
09:58:22 <vixey> nolrai: &&& looks like a good value of ^^
09:58:25 <vixey> ty ToRa
09:58:33 <ToRA> np
09:58:49 <ToRA> it's in Control.Arrow, which is often thought of as Data.Tuple ;)
09:58:52 <vixey> can anyone pl \(x,xs)->xs++[x] better?
09:59:14 <vixey> :t (++).return
09:59:16 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => a -> m a -> m a
09:59:20 <vixey> :t swap
09:59:22 <lambdabot> Not in scope: `swap'
09:59:33 <nolrai_> :t flip
09:59:35 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:59:53 <vixey> > let swap(x,y)=(y,x) in iterate ((++).return.swap.(head&&&tail)) "xyz!"
09:59:54 <lambdabot>  Couldn't match expected type `m (t1, t) -> m (t1, t)'
09:59:57 <vixey> awww.
10:00:00 <vixey> > let swap(x,y)=(y,x) in iterate ((++).return.swap.(head&&&tail)) $ "xyz!"
10:00:01 <lambdabot>  Couldn't match expected type `m (t1, t) -> m (t1, t)'
10:00:12 <ToRA> @type uncurry (flip (++) . return)
10:00:15 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => (a, m a) -> m a
10:00:29 <vixey> > let swap(x,y)=(y,x) in iterate (uncurry((++).return).swap.(head&&&tail)) "xyz!"
10:00:30 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
10:00:30 <lambdabot>       Expected...
10:00:30 <ToRA> @type uncurry (flip (Prelude.++) . return)
10:00:33 <lambdabot> forall a. (a, [a]) -> [a]
10:00:38 <tchakkazulu> > (fst &&& snd) (1,2)
10:00:41 <lambdabot>  (1,2)
10:00:44 <tchakkazulu> > (snd &&& fst) (1,2)
10:00:46 <lambdabot>  (2,1)
10:01:02 <nolrai_> > iterate (uncurry((++).return).(tail&&&head)) "xyz!"
10:01:03 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
10:01:03 <lambdabot>       Expected...
10:01:08 <BMeph> 	> let swap~(x,y)=(y,x) in iterate (uncurry((++).return).swap.(head&&&tail)) "xyz!"
10:01:11 * ToRA grrs gently in the direction of lambdabots generalisation of (++)
10:01:16 <ToRA> @type (++)
10:01:18 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:01:21 <vixey> ToRA: does it cause a problem?
10:01:30 <nolrai_> :t (uncurry((++).return).(tail&&&head)) "xyz!"
10:01:32 <lambdabot>     Occurs check: cannot construct the infinite type: a = m [a]
10:01:32 <lambdabot>       Expected type: [a] -> ([a], m [a])
10:01:32 <lambdabot>       Inferred type: [a] -> ([a], a)
10:01:38 <vixey> I thought the type error was caused by somethingelse
10:01:51 <nolrai_> :t (tail&&&head)) "xyz!"
10:01:53 <lambdabot> parse error on input `)'
10:01:59 <nolrai_> :t (tail&&&head)
10:02:01 <lambdabot> forall a. [a] -> ([a], a)
10:02:10 <ToRA> it doesn't give the type i expect from normal haskell usage, and may confuse beginners if you're trying to show something and you get a different type than ghci/hugs
10:02:22 <nolrai_> :t uncurry((++).return)
10:02:24 <lambdabot> forall a (m :: * -> *). (Monad m, Monoid (m a)) => (a, m a) -> m a
10:02:32 <vixey> what about smart beginners :p
10:02:38 <Saizan> > iterate (uncurry (++).fmap return.(tail&&&head)) "xyz!"
10:02:38 <BMeph> ToRA: Maybe you're teaching your beginners wrong... ;)
10:02:39 <vixey> they will learn 2 things
10:02:39 <lambdabot>  ["xyz!","yz!x","z!xy","!xyz","xyz!","yz!x","z!xy","!xyz","xyz!","yz!x","z!xy...
10:03:24 <ToRA> i never said i was teaching beginners ;)
10:03:35 <ToRA> but inconsistency doesnt help
10:04:07 * vixey thinks of unary negate ..
10:05:06 * BMeph points slyly at "list comprehensions"...
10:06:00 * BMeph ponders type constructors with their Initial Capital Letters
10:07:23 <tchakkazulu> ToRA: Try ?type (.), and be afraid.
10:08:16 <nolrai_> ?type (.)
10:08:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:08:49 <ToRA> tchakkazulu: yeah, i know.  I'm in two minds whether it would be a good idea for general haskell, but i don't like λb not being the same haskell in what (.), (++) etc are typed as
10:09:05 <vixey> You can define . and ++ like this in haskell
10:09:24 <vixey> also
10:09:32 <vixey> :t (++) :: [a] -> [a] -> [a]
10:09:34 <lambdabot> forall a. [a] -> [a] -> [a]
10:09:36 <ToRA> vixey: that's not my argument
10:13:10 <xif> hi
10:13:41 <xif> is it possible, in theory, to embed inside a Haskell program a Haskell interpreter (e.g. hgci),
10:14:01 <xif>   thus achieving dynamic capabilities?
10:14:13 <xif> (like runtime code loading etc)
10:14:15 <Lemmih> xif: Yes.
10:14:29 <xif> Lemmih: are people actually doing that?
10:14:32 <Lemmih> xif: ghc(i) is a program that uses the ghc-api library.
10:14:33 <Baughn> xif: See: hs-plugins
10:14:45 <Baughn> > 2+2 -- Also, that's how this works
10:14:46 <lambdabot>  4
10:15:00 <Baughn> ..phew. It worked.
10:15:01 <Lemmih> Baughn: Really?
10:15:11 <Baughn> Lemmih: LB uses hs-plugins, yes
10:15:11 <Lemmih> Baughn: I thought it used runplugs.
10:15:17 <xif> interesting, thanks.
10:15:20 <Baughn> Lemmih: Which uses hs-plugins
10:15:28 <Lemmih> Baughn: I don't think so.
10:15:32 <xif> "Dynamically Loaded Haskell Modules" just what I needed
10:15:36 <Baughn> Lemmih: I wrote quite a bit of it. ;)
10:15:43 <xif> I assume this enables stuff like runtime code generation?
10:15:57 <Baughn> -- | Runplugs: use hs-plugins to run a Haskell expression under
10:15:57 <Baughn> -- controlled conditions.
10:16:14 <nolrai_> @src Enum
10:16:14 <lambdabot> class  Enum a   where
10:16:14 <lambdabot>     succ                     :: a -> a
10:16:14 <lambdabot>     pred                     :: a -> a
10:16:14 <lambdabot>     toEnum                   :: Int -> a
10:16:14 <lambdabot>     fromEnum                 :: a -> Int
10:16:15 <Baughn> xif: Sure, if you like
10:16:16 <lambdabot> [3 @more lines]
10:16:32 <xif> that's awesome.
10:16:47 <xif> so, essentially, I could do in Haskell everything I could do in Ruby or Python.
10:16:48 <Baughn> xif: The hs-plugins API has more neat stuff like runtime at-load typechecking. I'm not sure how stable it is right now, but it'll be an important feature in 6.10 (hopefully)
10:17:02 <Baughn> ..yes, but you could do that /anyway/
10:17:04 <Lemmih> Hm, indeed.
10:17:31 <xif> Baughn: well, I was worried since when I first asked, people here said Haskell couldn't dynamically load extra code at runtime.
10:17:33 <orbitz> hrm, anyone read Luke Palmer post from today?
10:18:00 <xif> which means you can't do stuff like have a dynamic module system on the server, with refreshable code.
10:18:06 <sclv_> orbitz: some discussion at reddit
10:18:07 <Lemmih> xif: It can't be done easily. I wouldn't recommend it for most things.
10:18:08 <Baughn> xif: It's not a stable feature yet. THings could occasionally break, and you may have to rewrite the interface code at updates.
10:18:09 <ronwalf> Anyone know if Hugs is likely to support infix types?
10:18:23 <Baughn> xif: But if you want that, you *can* use it and rely on it getting better over time
10:18:25 <BMeph> orbitz: I did.
10:18:40 <Baughn> xif: ALternately, the ghc-api *interpreter* functions are considerably stabler. Just a few times slower.
10:18:46 <bos> orbitz: he's right, but people don't usually program in the style he criticises.
10:18:48 <nolrai_> is there a type class for data types that have a finite number of values? ie you could make a list of all values.
10:18:48 <orbitz> the title kind of confused me.  Is anyone saying haskell IS good at OO?
10:19:10 <Baughn> orbitz: I would, if someone'd ask me
10:19:18 <orbitz> bos: that was anoher hti ngi noticed.  his example seems liek the typical first chapter of haskell "look at what you can do with this!" but then by the last chapter you see that isn't how you'd program
10:19:25 <ddarius> Baughn: Haskell is not remotely an OO language.
10:19:27 <orbitz> Baughn: would you read the latest luke palmer?
10:19:30 <Baughn> nolrai_: Well, you can make infinite lists just fine, but.. Bounded, I guess
10:19:34 <Baughn> ddarius: Never said it was
10:20:09 <xif> Baughn, Lemmih: right, my most major concern was that Haskell wouldn't support stuff like runtime code generation and integration, which is the basis for meta-programming methods I regularly use in Python and Ruby programs.
10:20:30 <FordCortina> :t (1 :: Integer) / (2 :: Integer)
10:20:32 <lambdabot>     No instance for (Fractional Integer)
10:20:32 <lambdabot>       arising from a use of `/' at <interactive>:1:0-30
10:20:32 <lambdabot>     Possible fix: add an instance declaration for (Fractional Integer)
10:20:34 <xif> i.e. that there was a theoretical (fundamental, unchangeable) problem with Haskell loading extra code at runtime.
10:20:59 <Baughn> xif: You'll find that you won't /need/ some of those. There's also template-haskell, for compile-time metaprogramming. But no, no fundamental issues, just alpha-level code
10:21:00 <xif> as long as it's theoretically feasible, I'm sure the practical interface for doing that would stabilize in time.
10:21:21 <nolrai_> Baughn: not quite, i dont think.
10:21:24 <xif> Baughn, Lemmih: *nod* thanks.
10:21:28 <nolrai_> Is using non derived instances of Enum bad form?
10:21:31 <FordCortina> we cant you divide one integer by another?
10:21:43 <Zao> > div 42 3
10:21:44 <lambdabot>  14
10:21:52 <Baughn> nolrai_: Not particularily, but if auto-deriving gives good results, why not?
10:22:00 <vixey> "Now I get to see what all this Isabelle hype is about."
10:22:07 <vixey> I never heard *anyone* mention Isabelle :P
10:22:10 <vixey> where's all the hype?
10:22:12 <Baughn> FordCortina: Not and get a floating-point result like / wants
10:22:16 <ddarius> xif: Going all the way would require more than any plugins API is going to implement in the immediate future.  (No conceptual difficulty though.)
10:22:35 <Baughn> nolrai_: There are certain invariants you're supposed to obey that the derivation handles automatically. Breaking /those/ would be bad form
10:22:38 <ddarius> xif: You may also want to look at Clean which has a bit more built-in support for doing these types of things.
10:22:44 <FordCortina> Baugh: Zao: I was looking for a floating point answer yes
10:22:52 <nolrai_> because I cant out derive because they have non-nullary constructors.
10:23:07 <byorgey> vixey: so you've read all the text in the world, eh? ;)
10:23:12 <Baughn> FordCortina: Then you'll want to convert your integers to a floating-point type first
10:23:15 <nolrai_>  */out/auto
10:23:28 <vixey> no
10:23:29 <Baughn> > fromIntegral (2 :: Int) / fromIntegral (3 :: Int)
10:23:30 <lambdabot>  0.6666666666666666
10:23:36 <vixey> I mean where is the hype
10:23:48 <vixey> comp.lang.isabelle ?
10:24:01 <byorgey> I don't know, I've heard Isabelle mentioned many times
10:24:01 <vixey> for example no one on #haskell talks about it
10:24:07 <FordCortina> ah, thanks Baughn
10:24:21 <byorgey> "hype" is a subjective term =)
10:25:23 <xif> ddarius: what does "Going all the way" mean? (vs. what hs-plugins gives you)
10:26:07 <sclv_> xif: I really do suspect that you'll want plugins-style functionality far far less than you think.
10:26:10 <ddarius> xif: Smalltalk style reflection.
10:27:36 <xif> ddarius: hm, but you're saying there's no theoretical obstacle, so i.e. I could write it myself?
10:27:40 <sclv_> xif: see, e.g., quickcheck which generates arbitrary test data for a function, based on its type, and is written in pure haskell98.
10:28:42 <xif> sclv_: I don't understand what you mean by "I really do suspect that you'll want plugins-style functionality far far less than you think", or your quickcheck example :)
10:28:44 <ddarius> xif: You'd pretty much have to rewrite a Haskell implementation.
10:28:46 <Baughn> xif: The only obstacle around is that it hasn't been done yet, and it'd be a very broad interface. (Affecting large swathes of ghc)
10:29:07 <Baughn> xif: Certainly we'd applaud if you do it. ;)
10:29:30 <xif> hm, interesting.
10:30:56 <xif> hopefully in time I'll get a better estimate of the proportion of Python/Ruby reflexivity and runtime-dynamism that the plugin interface allows.
10:30:58 <nolrai_> whats the function to apply f n times to a?
10:31:12 <xif> right now, I'm not completely sure what it supports and doesn't support.
10:31:21 <Baughn> nolrai_: (!! . iterate)
10:31:49 <ddarius> Baughn: That's not even syntactically correct.
10:31:59 <xif> (since I'm not a Smalltalk programmer, and thus have only a vague sense of what "Smalltalk style reflection" entails)
10:32:14 <ddarius> xif: Learn smalltalk then.
10:32:18 <dmwit> ddarius: Isn't it amazing that humans are nonetheless able to understand that answer?
10:32:20 <Baughn> ddarius: Which means he won't try using it, yes
10:32:28 <Baughn> > iterate (+1) 0 !! 5
10:32:30 <lambdabot>  5
10:32:56 --- mode: irc.freenode.net set +o ChanServ
10:32:56 --- mode: ChanServ set -t
10:32:57 --- mode: erick set +t
10:32:57 <Baughn> That's slightly wasteful, though. ANy better ones?
10:32:58 --- mode: ChanServ set -t
10:32:59 --- mode: erick set +t
10:33:00 --- mode: ChanServ set -t
10:33:01 --- mode: erick set +t
10:33:01 --- mode: ChanServ set -t
10:33:03 --- mode: erick set +t
10:33:03 --- mode: ChanServ set -t
10:33:05 --- mode: erick set +t
10:33:05 --- mode: ChanServ set -t
10:33:07 --- mode: erick set +t
10:33:07 --- mode: ChanServ set -t
10:33:09 --- mode: erick set +t
10:33:09 --- mode: ChanServ set -t
10:33:11 --- mode: erick set +t
10:33:11 --- mode: ChanServ set -t
10:33:13 --- mode: erick set +t
10:33:13 --- mode: ChanServ set -t
10:33:15 <vixey> /msg chanserv help set
10:33:15 --- mode: erick set +t
10:33:15 --- mode: ChanServ set -t
10:33:16 <dons> hmm
10:33:17 <sclv_> @where ops
10:33:17 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:33:19 --- mode: erick set +t
10:33:19 --- mode: ChanServ set -t
10:33:21 --- mode: erick set +t
10:33:21 --- mode: ChanServ set -t
10:33:22 <dv\_> oh dear
10:33:22 --- mode: erick set +t
10:33:23 --- mode: ChanServ set -t
10:33:24 --- mode: erick set +t
10:33:25 --- kick: erick was kicked by dons (dons)
10:33:25 --- mode: ChanServ set -t
10:33:27 <FordCortina> lol
10:33:29 <FordCortina> sry
10:33:31 --- kick: erick was kicked by glguy (glguy)
10:33:37 <glguy> heh
10:33:42 <Baughn> That was exciting
10:33:48 <trontonic> irc-action
10:33:50 <sclv_> fsvo exciting
10:34:05 <xif> erick seems to be unpopular.
10:34:25 <dcoutts_> what was all that about?
10:34:25 <Baughn> @ops
10:34:26 <lambdabot> Maybe you meant: docs oeis pl
10:34:30 <dcoutts_> +-t?
10:34:33 <dmwit> ?where ops
10:34:33 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:34:36 <dons> oh, where was our chanserv?
10:34:40 <dons> it only just joined
10:34:43 <dmwit> dcoutts_: You wanted that?
10:34:48 <Baughn> Hm. How could erick change options if he wasn't an op?
10:34:53 <ddarius> Baughn: He was.
10:34:57 <vixey> he was given +o
10:35:01 <dons> hmm, i can't lower ops anymore?
10:35:12 <dons> what monkey business is going on..
10:35:15 <sclv_> xif: in any case, I just meant that as you become more familiar with haskell, you'll find that there are ways to do everything you want that are built out of simple higher order functions and laziness, probably.
10:35:40 <dons> 09:50:46 --- mode: glguy set +o dons
10:35:41 <dons> oh
10:35:51 <dons> ah, erick is glguy.
10:35:55 <dons> 'sok.
10:36:12 <dcoutts_> ohh
10:36:13 <Baughn> xif: I don't think haskell is quite up to erlang-style high-availability yet, but it can certainly do old-style plugins
10:36:24 <dcoutts_> glguy: so what was all that +-t business?
10:36:31 <byorgey> dons: there was a message a while back, all the *Serv bots were going down for some kind of upgrade
10:36:37 <dons> ah ok.
10:36:40 <xif> ddarius: I only want to be sure that I'll use able use in Haskell the same powerful methods I currently use in Ruby and Python. learning another language just to get to know a particular thing I can't do in Haskell sort of defeats the purpose :)
10:37:08 <ddarius> xif: That wasn't the point of learning Smalltalk.  The point is to learn things you've never seen before.
10:37:21 <Zao> dons: http://blog.freenode.net/?p=80
10:37:23 <lambdabot> Title: staffblog  Blog Archive  Services Migration
10:37:25 <xif> ddarius: (that's why I'm learning Haskell :)
10:37:30 <dons> yep, cool
10:37:39 <Baughn> xif: Haskell is a purely functional language. A lot of the metaobject tricks you can do in python or ruby don't make /sense/ in haskell, and aren't needed either
10:37:51 <xif> sclv_: yeah, I guess some of that runtime code generation techniques may have better, static alternatives in Haskell. would have to learn more about the language before I know.
10:37:53 <sclv_> xif: seriously. full-on functional programming with higher order functions will make you realize that what you were doing with "eval" was a pale imitation.
10:38:08 <dons> ?seen sorear
10:38:08 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
10:38:14 <wolgo> hi
10:38:31 <roconnor> preflex: seen sorear
10:38:31 <preflex>  Sorry, I haven't seen sorear
10:38:31 <vixey> hiya wolgo
10:38:44 <vixey> what's goin on
10:38:44 <wolgo> hi :)
10:38:47 <wolgo> Nothing
10:38:48 <Baughn> @tell cale Time to reset the seendb
10:38:48 <lambdabot> Consider it noted.
10:38:48 <dmwit> sorear hasn't been around in a while.
10:39:02 <wolgo> omw to a data center in Sacramento to work with a customer
10:39:06 <wolgo> on the amtrak
10:39:31 <vixey> in haskell?!
10:39:53 <vixey> hey is there a library to realtime interact with antialiased 2D graphics and some other GUI stuff?
10:40:07 <dmwit> Gtk2Hs
10:40:22 <dcoutts_> vixey: cairo which is part of gtk2hs
10:40:25 <dmwit> You can use Cairo... pretty!
10:40:58 <xif> Baughn, sclv_: OK, thanks :)
10:41:32 <wolgo> No not in Haskell
10:41:42 * wolgo is not a pro haskell programmer, in fact he is a noob
10:41:53 <olsner> @quote newbie
10:41:53 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
10:42:08 <olsner> that's not the quote I'm looking for!
10:42:19 <dmwit> These are not the droids you're looking for.
10:42:25 * wolgo works as an engineer for someone that manufactures load balancing equipment
10:42:25 <Baughn> olsner: Download lb, zless the quotedb. ;)
10:42:42 <dmwit> ?where state
10:42:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/State/
10:42:54 <xif> "hs-plugins includes spiffy features like eval, make, and load. The eval function does compiling, loading, and executing a single string's worth of code. the make function checks a source module and its dependencies for any changes since the last compilation, and recompiles and reloads all changed modules."
10:42:54 <dmwit> Or you could download *just the state* and zless that. =P
10:42:55 <shepheb> wolgo: physical weight-balancing or computation load-balancing?
10:43:07 <wolgo> computation load balancing
10:43:25 <wolgo> specifically network and applications
10:43:28 <dmwit> xif: May I suggest trying to tackle your problem without hs-plugins first?
10:43:35 * wolgo cringes at marketing speak
10:43:56 <Baughn> xif: All the cute stuff is in load. But yes, try to do without first
10:43:59 <dmwit> xif: (This is without hearing what your problem is, but still.)
10:44:01 <wolgo> Wow,
10:44:29 <wolgo> you know it is so odd, I have these questions and I look at the types and all of a sudden part of my question disappears. Weird what happens when you read the docs :P
10:44:30 <olsner> @quote "newbie"
10:44:30 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
10:44:39 <olsner> that's the one I was trying to say
10:44:59 * Baughn has an itch to write an evaluation-model tutorial. With embedded monads, no doubt.
10:45:03 <xif> dmwit, Baughn: yeah, you're probably right. I'm just excited to find an eval in Haskell :)
10:45:28 --- mode: ChanServ set -o dons
10:45:37 <hpaste>  wolgo pasted "quicksort algorithm question" at http://hpaste.org/7970
10:45:41 <vixey> are there other things than Gtk?
10:46:05 <olsner> U - {Gtk} /= 0
10:46:19 <vixey> such as ?
10:46:38 <Baughn> xif: While higher-order arguing is nice, do you think you could give us a concrete case where you'd want eval?
10:47:04 <olsner> wxWidgets and qt are probably the most popular ones
10:47:21 <olsner> don't know if qt has a haskell binding though
10:47:42 <xif> Baughn: nothing atm really, it's just that for years, I've been using languages that all have working runtime eval (Scheme, Python, Javascript, Ruby)
10:48:01 <xif> so somehow, not having that in a language seems a bit awkward :P
10:48:10 <vixey> you ever actually use eval in those languages?
10:48:14 <dmwit> vixey: There's a wxWidgets binding for sure.
10:48:18 <vixey> I wrote a lot of lisp and never wanted eval
10:48:19 <xif> vixey: sure, quite a lot.
10:48:25 <vixey> xif such as?
10:48:40 <xif> you generally don't do much Ruby without using some form of runtime eval.
10:48:49 <Toxaris> wolgo: are you aware that (x : equal) builds a list containing x and everything contained in equal?
10:48:51 <xif> in Javascript, eval usage is quite common as well.
10:48:51 <vixey> xif, for example?
10:49:10 <xif> vixey: concrete one?  adding methods to a class at runtime.
10:49:18 <xif> based on program state, or even data.
10:49:20 <vixey> why would you need eval to do that?
10:49:26 <vixey> just need a better object system
10:49:35 <wolgo> Toxaris: Ahh yes, because filter returns a list and (x : equal) is constructing a list of x and equal
10:49:49 <vixey> wolgo: that's adding an extra x to the list
10:49:57 <Toxaris> wolgo: yep.
10:50:02 <wolgo> Oh ok
10:50:05 <vixey> so the output list is too long right?
10:50:27 <Toxaris> vixey: no why, filter runs over xs?
10:50:31 <wolgo> I do not know. I am just trying to understand how quicksort works in Haskell
10:50:38 <vixey> Toxaris: ohh ok
10:51:02 <wolgo> equal = filter ( ==x ) xs so there would be matches for every element
10:51:19 <Toxaris> wolgo: matches?
10:51:44 <wolgo> Yeah, it is pattern matching x in the list of xs right?
10:51:46 <wolgo> hahah
10:51:59 * wolgo begins to fail in understanding quicksort
10:52:16 <Toxaris> wolgo: pattern matching happens to the left of the equals sign
10:52:18 <wolgo> What the hell
10:52:18 <vixey> quicksort is best understood imperatively
10:52:22 <wolgo> never mind
10:52:28 <Toxaris> wolgo: to the right of the equals sign is expression :)
10:52:34 * wolgo needed to pay attention to the GIGANTIC ++
10:52:43 <vixey> wolgo look at this animation http://en.wikipedia.org/wiki/Quick_Sort
10:52:46 <wolgo> less ++ equal ++ more
10:53:00 <wolgo> I think I understand it
10:53:00 <Toxaris> wolgo: yes, thats the overall scheme
10:53:08 <wolgo> wow I feel stupid now hahah
10:53:18 <wolgo> This is actually pretty simple in Haskell
10:53:29 <wolgo> wow that is so awesome
10:53:32 <dons> Igloo: are you on top of Serge's ghc reports?
10:53:48 <dons> vixey: imperatively?
10:53:52 <wolgo> That has to be the most concise quicksort I have seen :)
10:53:59 <wolgo> (now that I understand what is going on)
10:54:03 <Toxaris> wolgo: yeah you can just write those recursive equations down and that's it
10:54:10 <dons> i remember teaching quicksort, and the kids had a really hard tie understanding it. merge sort, however..
10:54:25 <vixey> merge sort is very simple to prove correct
10:54:39 <wolgo> Oops, need to get off the train soon. I will see you guys later :)
10:54:55 <Toxaris> vixey: a sensible quicksort should be implemented imperatively probably, but the basic idea is easier to understand functionaly
10:55:51 <Toxaris> vixey: but wolgo wants to learn Haskell, not quicksort, so quicksort is not really the point, is it?
10:56:19 <vixey> I don't think there's much point in learning Haskell
10:56:26 <vixey> It's much better to use it to write programs
10:57:05 <Toxaris> better in what sense?
10:57:57 <RayNbow> @djinn (b -> a) -> (c -> b) -> c -> a
10:57:57 <lambdabot> f a b c = a (b c)
10:58:16 <dmwit> f = (.)
10:58:26 <dmwit> My implementation is shorter. ;-)
10:58:38 <RayNbow> dmwit: I know :p
10:58:42 <roconnor> @pl (.)
10:58:42 <lambdabot> (.)
10:58:54 <sclv_> @unpl (.)
10:58:54 <lambdabot> (\ a b c -> a (b c))
10:58:55 <RayNbow> dmwit, I typed this in another channel: <RayNbow> f = (.)  -- composition :p
10:59:03 <roconnor> oh, that's what I meant
10:59:23 <dmwit> ?. pl djinn (b -> a) -> (c -> b) -> (c -> a)
10:59:23 <lambdabot> f = (.)
11:00:24 <Toxaris> interesting.
11:01:04 <Toxaris> even cooler would be to keep the intermediate result, and show the less "complex" one, for some metric
11:02:28 <RayNbow> :t (.)
11:02:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:02:33 <RayNbow> ?type (.)
11:02:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:02:41 <RayNbow> luite: same type?
11:02:46 <RayNbow> or well, same output
11:02:53 <vixey> :t (.) :: (b -> a) -> (c -> b) -> (c -> a)
11:02:54 <lambdabot> forall b a c. (b -> a) -> (c -> b) -> c -> a
11:03:42 <luite> RayNbow: different output than my own GHCi :)
11:03:49 <RayNbow> oh :p
11:04:06 <olsner> @seen olsner
11:04:06 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
11:04:31 <luite> RayNbow: and I don't really understand what the lambdabot version means
11:04:48 <RayNbow> @src (.)
11:04:48 <lambdabot> (f . g) x = f (g x)
11:04:48 <lambdabot> -- In lambdabot, it's been generalised to:
11:04:48 <lambdabot> (.) = fmap
11:04:58 <RayNbow> ^ there you go, luite :p
11:05:02 <luite> ah tnx
11:05:03 <Toxaris> luite: lambdabot's (.) is your fmap
11:05:26 <Toxaris> luite: but you can still use it like your (.)
11:07:04 <ziman> :t fmap
11:07:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:07:42 <ziman> :t (f.)
11:07:44 <lambdabot> forall a b (f :: * -> *). (Functor f, SimpleReflect.FromExpr b, Show a) => f a -> f b
11:07:45 <EvilTerran> :t (P..)
11:07:47 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:07:59 <EvilTerran> > (f P.. g) x :: Expr
11:08:00 <lambdabot>  Add a type signature
11:08:03 <EvilTerran> bah
11:15:18 <vixey> dyld: Symbol not found: __ZN5wxApp10InitializeERiPPw
11:15:18 <vixey>   Referenced from: /usr/local/wxhaskell/lib/libwxc-mac2.8.7-0.10.3.dylib
11:15:18 <vixey>   Expected in: flat namespace
11:15:20 <vixey> :(
11:15:20 <vixey> e
11:16:01 <Baughn> vixey: Have you been upgrading ghc? Or recompiling it?
11:16:08 <vixey> not recently
11:16:44 <vixey> I have 6.8.2 though....
11:19:03 <Baughn> vixey: I'm sure there's a better way, but personally my response to that sort of thing is to slash and burn. Eventually you figure out what causes it..
11:19:15 <Baughn> Keeping a cabal binary around helps. ;)
11:19:59 <dons> this is cool, http://reddit.com/info/6la86/comments/
11:20:49 <vixey> I think I am going to use Clozure .. the end result is the same software
11:22:13 <ehird> whoa, ops
11:22:32 <vixey> lazy unification doesn't make much sense
11:24:31 <dons> vixey: Clozure, the commercail lisp?
11:24:39 <ehird> clozure is not commercial
11:24:42 <dons> ah
11:24:44 <ehird> it is the open source continuation of MCL
11:24:49 <ehird> previously known as OpenMCL
11:24:53 <ehird> it is very popular on macs
11:25:34 <dons> vixey: be sure to report anything that looks like a bug. we've a fairly active mac osx ghc dev pool now
11:27:01 <ronwalf> How does clozure compare to allegro (besides being free)?
11:27:08 <ehird> ronwalf: um.
11:27:09 <ehird> :)
11:27:15 <ehird> clozure is comparable to SBCL, really.
11:27:25 <ehird> but clozure is mainly for ppc macs
11:27:28 <ehird> x86 macs are in development
11:27:34 <ehird> and lunix sometime, maye
11:27:36 <ehird> *maybe
11:27:38 * ronwalf really knows little about lisp, other than being forced to use it occasionally
11:28:04 <vixey> ronwalf: forced by who?
11:28:18 <ehird> forced to use lisp, the horror oh the horror!
11:29:15 * ronwalf is a fan of static type checking, not so much of endless nested parenthesis
11:29:32 * Baughn is a fan of the parantheses. They help more than they hurt, honest
11:29:36 <dons> ehird: its pretty scary, yeah. you have to sacrifice so much
11:29:53 <ehird> dons: i hope you're being sarcastic
11:29:54 <ehird> :\
11:30:06 <ehird> haskell and lisp are both wuvvly ;P
11:30:15 <ehird> has anyone written anything about game programming in haskell by the way?
11:30:28 <ehird> esp. interested in purely-functional approaches
11:30:38 <ehird> but not very interested in things I can't compile and run and actually play :-)
11:30:41 <dons> there's Mun's thesis on the topic.
11:31:02 <dons> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Game
11:31:03 <lambdabot> http://tinyurl.com/yqov7f
11:31:19 <ehird> i've currently been thinking about an approach similar to that erlang guy's thing
11:31:22 <dons> and the thesis on building 3d games based on reactive programming, http://haskell.org/haskellwiki/Frag
11:31:23 <lambdabot> Title: Frag - HaskellWiki
11:31:27 <ehird> that is, get an infinite lazy list of events from sdl
11:31:37 <dons> yep, even streams ftw.
11:31:42 <ehird> and map over it to produce output events
11:31:44 <ehird> well, likely concatMap
11:31:51 <ehird> and then (forM_ render) or similar
11:31:56 <ehird> like
11:32:02 <dmwit> ehird: There's some pretty nebulous stuff here: http://prog21.dadgum.com/23.html
11:32:03 <lambdabot> Title: prog21: Purely Functional Retrogames, Part 1
11:32:12 <dons> nebulous is right.
11:32:27 <ehird> gameMain = do initStuff; events <- allEvents; forM_ updateStuff $ concatMap handleCrap allEvents
11:32:29 <ehird> something liek that
11:32:32 <ehird> dmwit: that's what i meant by the erlang guy
11:33:02 <vixey> ghc is being defiant
11:33:05 <vixey> % ghc -package wx -o helloworld HelloWorld.hs
11:33:05 <vixey> compilation IS NOT required
11:33:10 <vixey> Prelude> :m + EnableGUI
11:33:10 <vixey> module main:EnableGUI is not loaded
11:33:24 <ehird> just get rid of the .ho and stuff
11:33:24 <vixey> have I not been a good parent ?
11:33:30 <ehird> haha#
11:33:33 <dmwit> make clean
11:33:36 <ehird> I WON'T compile any more daddy!!
11:34:01 <dons> vixey: use -no-recomp --make to force recompilation
11:34:05 <ehird> but yeah i'd love something like a haskell version of pygame
11:34:15 <ehird> I mean, I know it's essentially an SDL binding
11:34:21 <ehird> but something that enables the style of programming I talked about
11:34:24 <ehird> for games
11:34:35 <dons> vixey: and if you're compiling, you may as well just run the binary, rather than loading it in ghci.
11:34:58 <vixey> Im still getting
11:34:58 <vixey> % ghc --make EnableGUI.hs
11:34:58 <vixey> [1 of 1] Compiling EnableGUI        ( EnableGUI.hs, EnableGUI.o )
11:34:58 <vixey> EnableGUI.hs:8:8: parse error on input `import'
11:35:05 <vixey> for this http://wxhaskell.sourceforge.net/download/EnableGUI.hs
11:35:19 <vixey> (Im trying to determine if this wx-not-working thing is a bug or not)
11:35:28 <dons> so there's a typo on the first line by the sounds of it.
11:35:38 <dons> likely you save an html file?
11:35:59 <Saizan> vixey: -fffi
11:36:05 <dons> ah yes.
11:36:21 <ehird> :\
11:36:21 <Saizan> or LANGUAGE ForeignFunctionInterface
11:37:10 <vixey> Loading package wxcore-0.10.3 ... can't load .so/.DLL for: wxc-mac2.8.7-0.10.3 (dlopen(/usr/local/wxhaskell/lib/libwxc-mac2.8.7-0.10.3.dylib, 10): Symbol not found: __ZN5wxApp10InitializeERiPPw
11:37:10 <vixey>   Referenced from: /usr/local/wxhaskell/lib/libwxc-mac2.8.7-0.10.3.dylib
11:37:10 <vixey>   Expected in: flat namespace
11:37:10 <vixey> )
11:37:32 <vixey> not sure what to do about it
11:38:57 <vixey> I think it's a bug in wx and not wxhaskell
11:39:05 <nolrai_> is there a better way to write "(takeWhile (/= end) $ iterate succ start) ++ [end]"?
11:39:28 <nolrai_> Im writing an instance of Enum.
11:40:13 <r3m0t> @pf f x y = x + y
11:40:14 <lambdabot> Maybe you meant: bf pl
11:40:20 <Baughn> nolrai_: deriving(Enum)?
11:40:24 <r3m0t> @pl f x y = x + y
11:40:24 <lambdabot> f = (+)
11:40:27 <bos> @seen sioraiocht
11:40:27 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
11:40:33 <bos> blorgle.
11:40:46 <sioraiocht> hi bos
11:41:08 <vixey> those start end | start == end = [end]
11:41:17 <vixey> those start end | otherwise = start : those (succ start) end
11:41:28 <bos> sioraiocht: what's the confusion over arrays and bytestrings?
11:41:33 <nolrai_> Baughn: I cant because there are non nullitary constructors.
11:41:38 <ehird> anyone?
11:41:39 <Beelsebob> @pl f x y = y + x
11:41:39 <lambdabot> f = (+)
11:41:39 <nolrai_> vixey: thanks
11:41:42 <Beelsebob> interesting
11:41:44 <r3m0t> @pl f x = x == reverse x
11:41:44 <lambdabot> f = ap (==) reverse
11:42:17 <bos> sioraiocht: or is that not you?
11:42:52 <r3m0t> @pl nodups xs = and (zipWith (/=) sxs (tail sxs)) where sxs = sort xs
11:42:53 <lambdabot> (line 1, column 57):
11:42:53 <lambdabot> unexpected "="
11:42:53 <lambdabot> expecting variable, "(", operator or end of input
11:43:43 <r3m0t> @pl f xs = let sxs = sort xs in and (zipWith (/=) sxs (tail sxs))
11:43:43 <lambdabot> f = and . ap (zipWith (/=)) tail . fix . const . sort
11:45:07 <r3m0t> @pl f a b = b . flip a
11:45:08 <lambdabot> f = flip (.) . flip
11:45:50 <ehird> hahahah, Wallaby Haskell
11:45:50 <ehird> I must write that
11:46:38 * FordCortina lold
11:47:38 <ehird> "Powering the next generation of Haskell whimsy"
11:48:06 <dmwit> r3m0t: nub, or map head . group . sort
11:48:32 <dmwit> (zipWith (/=)) is almost certainly not what you want.
11:49:02 <dmwit> or... maybe it is
11:49:06 <r3m0t> why? I want to detect duplicates
11:49:08 <Deewiant> @ty \xs -> and (zipWith (/=) (sort xs) (tail . sort $ xs))
11:49:10 <lambdabot> forall a. (Ord a) => [a] -> Bool
11:49:11 <dmwit> Yeah, never mind.
11:49:45 <dmwit> :t any ((>1) . length) . group . sort
11:49:47 <lambdabot> forall a. (Ord a) => [a] -> Bool
11:49:48 <vixey> detect?
11:49:55 <vixey> this is very simple
11:50:05 <vixey> :t any (uncurry (/=))
11:50:08 <lambdabot> forall a. (Eq a) => [(a, a)] -> Bool
11:50:09 <Deewiant> @ty \xs -> xs == nub xs
11:50:11 <lambdabot> forall a. (Eq a) => [a] -> Bool
11:50:15 <vixey> :t zip ?lefts ?rights
11:50:16 <lambdabot> forall a b. (?rights::[b], ?lefts::[a]) => [(a, b)]
11:50:23 <vixey> the problem is solved
11:50:25 <vixey> :)
11:50:31 <r3m0t> :)
11:50:32 <vixey> just stick a . between
11:50:53 <vixey> but
11:50:53 <dmwit> vixey: hmm, I don't understand how that solves it.
11:50:58 <vixey> this solved a totally different problem :P
11:51:06 <vixey> I better get some rest
11:51:06 <Baughn> @type \f -> f ?x
11:51:08 <lambdabot> forall t t1. (?x::t) => (t -> t1) -> t1
11:53:32 <FordCortina> is there a nice way to use fromIntegral with (Maybe Integer)?
11:54:05 <FordCortina> ah
11:54:06 <Deewiant> @ty fmap fromIntegral
11:54:08 <lambdabot> forall a b (f :: * -> *). (Functor f, Num b, Integral a) => f a -> f b
11:54:09 <FordCortina> stupid me
11:54:11 <FordCortina> fmap
11:54:20 <FordCortina> thanks
11:54:31 <Deewiant> or liftM if you prefer Monads to Functors :-P
11:55:06 <vixey> > fromIntegral . Just 3
11:55:08 <lambdabot>  Just 3
11:55:31 <vixey> let (.) = fmap
11:55:34 <Deewiant> only in Caleskell
11:55:40 <vixey> not only there
11:55:45 <vixey> you can just define .
11:55:48 <ehird> Deewiant: can Cale do that? Yes!
11:55:56 <ehird> Unless it's non-generic.
11:56:02 <Deewiant> well of course you can define it, but out-of-the-box only in Caleskell :-)
11:56:34 <ehird> Deewiant: i find lambdabot's type-rebellion amusing
11:56:40 <ehird> it makes :t less useful :-)
11:56:51 <Deewiant> type-rebellion?
11:56:58 <ehird> Deewiant: the caleskell types
11:56:59 <ehird> :t fmap
11:57:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:57:01 <ehird> :t (.)
11:57:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:57:05 <Deewiant> oh, yes :-)
11:57:10 <Deewiant> just use Prelude..
11:57:16 <ehird> Deewiant: right, but still :)
11:57:25 <Deewiant> true, it can be annoying
11:58:59 <ehird> http://pll.cpsc.ucalgary.ca/charity1/www/wofm/wofm2.html I love how the charity people put their language anywhere but 'theoretical'
11:59:00 <lambdabot> Title: CHARITY - The Winds of Formal Methods III
11:59:10 <ehird> I wrote a webapp in charity last week, myself.
11:59:36 <opqdonut> can i get the IEEE representation of a float?
11:59:49 <ehird> opqdonut: no, afaik
12:00:08 <opqdonut> hmmh
12:00:37 <newsham> slightly off-topic math type question - whats the theorem called that says the cardinality of facts is larger than the cardinality of proofs?
12:03:14 <jleedev> goedel's first incompleteness theorem?
12:04:40 <ehird> So anyone re game programming in haskell?
12:05:07 <newsham> jleedev: i didnt see any arguments about cardinality on the wikipedia page for that
12:10:57 <MyCatVerbs> ehird: ?
12:12:03 <ttt--> deer are practical, but boats are not
12:12:47 <vixey> hi MyCatVerbs
12:13:21 <ehird> MyCatVerbs: ?
12:14:03 <hkBst> > 3 + 5
12:14:04 <lambdabot>  8
12:15:46 * ronwalf loathes to give up infix types
12:15:50 <MyCatVerbs> ehird: ?
12:15:53 <MyCatVerbs> 'lo vixey.
12:15:55 <ehird> MyCatVerbs: ?
12:16:26 <vixey> ronwalf: what?
12:16:46 <MyCatVerbs> ehird: <<loop>>
12:16:48 <ronwalf> data (f :+: g) e = Inl (f e) | Inr (g e)
12:16:56 <ehird> MyCatVerbs: but yeah whut
12:17:06 <MyCatVerbs> ehird: what were you asking about games earlier?
12:17:09 <ronwalf> vixey: It's apparently a ghc extensions
12:17:26 <ehird> MyCatVerbs: is there a good way to do purely-functional game programming (that is, event handling & logic is purely functional ... rendering of course not) in haskell
12:17:38 <ronwalf> vixey: And I'm weighing it against being hugs incompatible
12:17:50 <twobitwo2k> @src sort
12:17:50 <lambdabot> sort = sortBy compare
12:17:54 <MyCatVerbs> ehird: dunno, people keep coming up with tricks and advances upon the idea of FRP.
12:17:57 <twobitwo2k> @src sortBy
12:17:57 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:18:12 <ehird> MyCatVerbs: I was thinking of something like
12:18:29 <ehird> do evts <- allEvents; mapM_ updateEverything $ concatMap handleEvent evts
12:18:33 <ehird> where evts is a lazy infinite list
12:18:34 <vixey> ronwalf: is there any reason you want to use hugs?
12:18:50 <ehird> MyCatVerbs: that erlang guy wrote some stuff about that.
12:18:52 <ehird> it's interesting.
12:18:56 <ehird> is that what FRP is?
12:18:59 <MyCatVerbs> vixey: Hugs support is good, especially when you're on a P1 with old Slackware installed.
12:19:16 <MyCatVerbs> ehird: I don't actually know, I haven't looked into it much.
12:19:45 <ehird> Hm. I can't google Control.Alternative :-P
12:20:10 <MyCatVerbs> ehird: Yampa is an FRP implementation, though I have no clue what it does.
12:20:15 <ronwalf> vixey: For whatever reasons I can't pin down, I like using hugs as my interactive interpreter
12:20:24 <ehird> ronwalf: ghci works fine...
12:20:27 <vixey> ronwalf: that is weird but your choice :p
12:20:31 <ehird> and if you liked it you wouldn't complain!
12:20:36 <vixey> ronwalf: I don't use hugs at all so I guess I'm missing out
12:21:14 <wolverian> en halua
12:21:15 <wolverian> ww
12:21:18 <ronwalf> Besides, when one compiler gives me indecipherable errors, I can try another
12:21:33 <ronwalf> In the hopes that /someone/ has useful messages
12:21:39 <vixey> I usually just stare at the code until it fixes itsself
12:21:52 <twobitwo2k> vixey: that never works for me...
12:22:45 <ehird> alternatives a la <|> - haddock docs plz?
12:22:47 <ehird> can't google
12:25:54 <Dzlk> hugs is the only one ported to Plan 9.
12:29:35 <ehird> Chyene ... what is that language called again ...
12:30:18 <denbuen_> @seen dcoutts
12:30:19 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:30:32 <denbuen> @seen dcoutts
12:30:32 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:30:44 <dcoutts> @yarr!
12:30:45 <lambdabot> Yarrr!
12:30:50 <b_jonas> in case anyone's interested, the date of the icfp contest this summer was just announced on http://www.icfpcontest.org/
12:30:51 <lambdabot> Title: ICFP Programming Contest 2008
12:30:55 <dcoutts> dbueno: hia
12:31:15 <BMeph> ehird: Cayenne, perhaps? ;)
12:31:17 <dbueno> b_jonas: It's been up here (http://www.icfpconference.org/icfp2008/) for several weeks....
12:31:18 <lambdabot> Title: ICFP 2008 : The 13th ACM SIGPLAN International Conference on Functional Programm ...
12:31:31 <b_jonas> dbueno: oh, I never watched that
12:31:35 <b_jonas> only the http://www.icfpcontest.org/ site
12:31:35 <lambdabot> Title: ICFP Programming Contest 2008
12:31:44 <dbueno> dcoutts: Hiya.  Quick question ... can I get a few lines of commentary about the CondTree data type?
12:31:50 <dcoutts> dbueno: sure
12:31:54 <b_jonas> for the 2007 organizers promised that will be the website of the new one as well
12:32:03 <b_jonas> (or at least a redirect)
12:32:05 <dcoutts> dbueno: btw, I went to an interesting talk today on constraint programming and its relation to SAT
12:32:11 <dbueno> dcoutts: I understand it's hierarchical, but, it's oddly-recursive.  Undoubtedly it's a problem of perception, and not design. =]
12:32:20 <dcoutts> dbueno: I discussed the package problem with them, was very interesting
12:32:24 <ehird> BMeph: KTHX
12:32:30 <b_jonas> dbueno: thanks for the info
12:32:41 <BMeph> ehird: /salute
12:32:46 <dbueno> dcoutts: Ooh, neat --- was the topic more specific than "the relation of constraint programming and SAT"?
12:32:51 <dcoutts> dbueno: the type is recursive yes, because you can nest if's inside each other, so you get a tree
12:33:00 <dbueno> b_jonas: No problem. =]
12:33:25 <dbueno> dcoutts: Sorry, I didn't mean it's odd because it's recursive --- just it doesn't have the recursive structure I expected.
12:33:27 <dcoutts> dbueno: it was a 25 min talk from a CP advocate explaining the areas where SAT thrashes CP and the niches where CP is the better choice
12:33:53 <dbueno> dcoutts: interesting.  I've wondered exactly where CP approaches win out.
12:34:18 <dcoutts> dbueno: particularly the areas where the encoding into SAT is very complex
12:34:25 <vixey> what about using -> instead of ^ to mean exponentiation
12:34:33 <vixey> 2^3 = 2->3
12:34:39 <MyCatVerbs> vixey: why?
12:34:49 <b_jonas> vixey: isn't that already a reserved token in h?
12:35:09 <vincenz> 2^3 == 3->2
12:35:16 <dbueno> dcoutts: Huh.  I'd be interested to hear more; later, if now is not conveniente.
12:35:31 <dcoutts> dbueno: ok, so the CondTree has the bits at the top level
12:35:36 <vixey> vincenz: thanks thats what I meant
12:35:49 <vixey> (I was actually thinking about 3^2)
12:35:57 <dcoutts> dbueno: those are the fields you get at that level, ie the Library/Executable/BuildInfo stuff
12:36:00 <vincenz> off by 1 error :)
12:36:05 <vincenz> 2^3 + 1 = 3^2
12:36:08 <b_jonas> oh, -> for functions with domain on the left!
12:36:10 <b_jonas> I see
12:36:13 <vixey> MyCatVerbs: the numbers functions from sets of those cardinalites
12:36:17 <b_jonas> I didn't get why you'd use ->
12:36:26 <dcoutts> dbueno: then a bunch of if's and each one has a then body and one optionally an else part
12:36:43 <MyCatVerbs> vixey: I failed to parse that. :/
12:36:43 <vixey> and it makes 0->0 = 1 feel a lot less scary
12:36:49 <dcoutts> dbueno: the constraints at this level are the build-depends that appear at exactly this level
12:37:01 <dcoutts> dbueno: perhaps I should @hpaste an example
12:37:03 <vixey> MyCatVerbs: 3={x,y,z} 2={p,q}
12:37:05 <b_jonas> vixey: meh, 0->0 must be 1 so polynomials work
12:37:08 <MyCatVerbs> vixey: you mean the numbers *of* functions from sets of those cardinalities?
12:37:27 <b_jonas> the set thing is just another example why
12:37:28 <MyCatVerbs> vixey: ooh, good explaination for why 0^0=1.
12:37:36 <vixey> MyCatVerbs: how many f : 2->3 are there
12:37:48 <dbueno> dcoutts: That would be nice.  Each element of `condTreeComponents' is an if with a Condition (the test) then a body (which is itself a condtree) and an (optional) else, also a condtree.
12:37:59 <vixey> and is x^y^z (x^y)^z or x^(y^z) ?
12:38:02 <dbueno> dcoutts: ... should have ended my last comment with a question mark. =]
12:38:23 <MyCatVerbs> vixey: it's (x^y)^z, because we all love left-associativity.
12:38:31 <vixey> great!
12:38:35 <vixey> -> is right assoc :)
12:38:39 <vixey> this is perfect
12:38:41 <b_jonas> MyCatVerbs: actually there are two independent reasons why it's x^(y^z)
12:38:50 <vixey> oh. :[
12:38:56 <MyCatVerbs> b_jonas: except that I'm wrong, naturally.
12:39:01 <MyCatVerbs> b_jonas: please elaborate?
12:39:25 <dmwit> (x^y)^z = x^(yz)
12:39:27 <vixey> so ^ has the same associativity as -> (but it's flipped) well that ruins my idea
12:39:29 <b_jonas> One is the typographical:
12:39:40 <b_jonas> power is originally marked by upper index
12:39:48 <b_jonas> superscript that is
12:39:49 <MyCatVerbs> > ((2^3)^3,2^(3^4))
12:40:04 <lambdabot>  (512,2417851639229258349412352)
12:40:11 <MyCatVerbs> > ((2^3)^4,2^(3^4)) -- even, now where's lambdabot?
12:40:12 <lambdabot>  (4096,2417851639229258349412352)
12:40:24 <b_jonas> ^ or up arrow is used only because some mediums can't show a superscript
12:40:25 <dmwit> > 2^3^4
12:40:26 <lambdabot>  2417851639229258349412352
12:40:43 <b_jonas> now try to write (x^y)^z that way but without a superscript
12:40:48 <b_jonas> I mean
12:40:53 <b_jonas> with a superscript
12:41:03 --- mode: irc.freenode.net set +o ChanServ
12:41:04 <b_jonas> now that would come out ugly without a paren
12:41:12 <MyCatVerbs> b_jonas: ah, okay. Good reason.
12:41:12 <b_jonas> because y and z would be adjacent and of the same size
12:41:26 <b_jonas> so {x^y}^z actually looks like x^{yz}
12:41:32 <b_jonas> which, funnily, it is equal to
12:41:38 <MyCatVerbs> Very handy.
12:41:49 <b_jonas> this also shows it's a good notation
12:42:00 <MyCatVerbs> b_jonas: parsimonious, even?
12:42:01 <b_jonas> the other reason is of course what dwmit says
12:42:35 <b_jonas> MyCatVerbs: mostly yes
12:43:02 <b_jonas> but in some maths formulas an equivalent infix would come handy
12:43:12 <b_jonas> when the exponent is large
12:43:46 <b_jonas> sometimes you can't do anything but write exp huge left paren exponent log base huge right paren
12:44:35 <hpaste>  dcoutts pasted "CondTree example" at http://hpaste.org/7972
12:44:42 <dcoutts> dbueno: ^^
12:45:22 <dbueno> dcoutts: Thanks!  That is very helpful.
12:45:31 <dcoutts> dbueno: I'm off, but I'll be around later if you have more Qs
12:45:42 <dbueno> dcoutts: Thanks; bye.
12:53:08 <ronwalf> No file tab completion in ghci :(
12:53:19 <vixey> yes it does
12:53:20 * ronwalf cries, and want a hug(s)
12:53:27 <ronwalf> Really?  For :e ?
12:53:34 * ronwalf wonders what he's missing
12:53:42 <vixey> readline probably
12:54:00 <ehird> ghc-6.8.2: unknown package: posix
12:54:01 <ehird> :D
12:56:59 <tieTYT2> in this java code I have this date that I use to check if it's before today.  If it is, i later increment it.  It feels like a hack to do that.  I'm not sure if that's because I've been learning haskell or if it's really a hack
12:57:50 <vixey> tieTYT, what's the variable for?
12:57:58 <vixey> do you mean you increment in a loop?
12:58:15 <dmwit> "to check if it's before today"
12:58:29 <dmwit> What is "it"?
12:58:34 <vixey> dmwit, yes ... but why
12:58:55 <dolio> dmwit: It's right now, of course.
12:59:02 <dolio> Is is currently before today? :)
12:59:28 <tantalum> no it's the day before tomorrow
12:59:39 <dmwit> That depends on what your definition of "is" is.
12:59:57 <dolio> All right, Mr. President.
13:00:09 <dolio> Oh, I see. I made a typo.
13:00:15 <vixey> well I don't have a clue what the variable is for but incrementing variables isn't usually a bad thing..
13:03:03 <dmwit> > map (^2) [0.241, 0.760]
13:03:05 <lambdabot>  [5.8080999999999994e-2,0.5776]
13:03:06 <Itkovian> Following the ConfigFile example, where they use a runErrorT to get the result in an Either, the types do not seem to work out when I'm making a disticntion between Right ConfigParser and Left CPError.
13:03:29 <dmwit> Itkovian: paste?
13:03:41 <Itkovian> yes. working on that ;-)
13:05:02 <dmwit> > 0.05 * 54675
13:05:08 <lambdabot>  2733.75
13:06:32 <vixey> wait a sec
13:06:39 <vixey> x^y^z = (x^y)^z
13:06:55 <tieTYT2> vixey: yeah i do
13:06:57 <tieTYT2> bbl
13:07:09 <mar77a> vixey: (x^y^x) = x^(y*z) ?
13:07:09 <dmwit> vixey: Not in Haskell.
13:07:20 <dmwit> > 2^3^4 == (2^3)^4
13:07:21 <lambdabot>  False
13:07:44 <vixey> > 2^3^4 == 2^(3*4)
13:07:45 <lambdabot>  False
13:07:53 <vixey> ok
13:07:59 <vixey> (2^3)^4 == 2^(3*4)
13:07:59 <dmwit> > 2^3^4 == 2^(3^4)
13:08:01 <lambdabot>  True
13:08:04 <vixey> > (2^3)^4 == 2^(3*4)
13:08:05 <lambdabot>  True
13:08:15 <mar77a> ^^
13:08:16 <vixey> 4 -> 3 -> 2 = 3*4 -> 2 !
13:08:20 <vixey> this works out ok
13:08:56 <vixey> it's just currynig
13:12:49 <ronwalf> hm
13:18:52 <Beelsebob> @check \n m l -> (n^m)^l == n ^ (m * l)
13:18:54 <lambdabot>  Exception: Prelude.^: negative exponent
13:18:55 <FordCortina> why is it that:
13:18:57 <FordCortina> > @type fromIntegral . Just 3
13:18:57 <lambdabot>  Parse error at "@type" (column 1)
13:19:01 <FordCortina> @type fromIntegral . Just 3
13:19:02 <lambdabot> forall b. (Num b) => Maybe b
13:19:05 <FordCortina> works here
13:19:10 <FordCortina> but not in ghc
13:19:12 <Beelsebob> @check \n m l -> n>0 && m>0 ==> (n^m)^l == n ^ (m * l)
13:19:13 <lambdabot>  Exception: Prelude.^: negative exponent
13:19:22 <Beelsebob> @check \n m l -> l>0 && m>0 ==> (n^m)^l == n ^ (m * l)
13:19:23 <FordCortina> ?
13:19:23 <lambdabot>  Arguments exhausted after 280 tests.
13:19:25 <dmwit> FordCortina: Congratulations, you just met the Monomorphism Restriction!
13:19:40 <dmwit> ?wiki monomorphism restriction
13:19:40 <lambdabot> http://www.haskell.org/haskellwiki/monomorphism_restriction
13:19:58 <ehird> seriously why can't ghc just fix that crap
13:19:59 <ehird> :\
13:20:00 <dmwit> FordCortina: The short answer is: put an explicit type-signature and it will work just fine.
13:20:08 <dmwit> ehird: It's in the language specification.
13:20:10 <Beelsebob> ehird: it can, but it has consequences
13:20:14 <dmwit> ehird: That *is* the fix.
13:20:17 <Heffalump> ehird: -XNoMonormorphismRestriction
13:20:23 <FordCortina> so lambdabot is not based on ghc?
13:20:24 <Beelsebob> you can disable the monomorphism restriction using what Heffalump said
13:20:26 <FordCortina> @version
13:20:26 <lambdabot> lambdabot 4p629, GHC 6.8.2 (Linux i686 2.40GHz)
13:20:26 <lambdabot> darcs get http://code.haskell.org/lambdabot
13:20:44 <Heffalump> I add that to all my code these days
13:20:45 <dmwit> FordCortina: It is, but it sticks {-# LANGUAGE NoMonomorphismRestriction #-}, probably.
13:20:48 <FordCortina> ic
13:21:24 <Beelsebob> FordCortina: the monomorphism restriction is there essentially to stop you thinking "this constant will get evaluated once", when it's not true
13:21:43 <Beelsebob> because in reality it's not a constant -- it's a function taking a class dictionary as an argument
13:21:58 <dolio> "fromIntegral . Just 3" only works here because (.) = fmap.
13:22:04 <dmwit> :t fromIntegral
13:22:06 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:22:17 <Heffalump> (.) /= fmap except in lambdabot's world..
13:22:17 <dmwit> AHH
13:22:36 <dmwit> I was wondering what the deuce was going on, after I went back and actually looked at what he pasted.
13:22:50 <dolio> And if that's literally what's being written, it's equivalent to 'Just 3' because 3 is already polymorphic.
13:22:56 <dmwit> FordCortina: Ignore all that MR hooey.
13:24:11 <FordCortina> dmwit: right
13:25:36 <dmwit> FordCortina: You grok (.) vs. fmap?
13:25:59 <Heffalump> so it's not the monomorphism restriction at all
13:26:09 <Beelsebob> well, it would be, if you used fmap in ghc
13:26:24 <Heffalump> Prelude> :t fmap fromIntegral (Just 3)
13:26:25 <dmwit> Only if it was a top-level definition.
13:26:25 <Heffalump> fmap fromIntegral (Just 3) :: (Num b) => Maybe b
13:26:38 <dmwit> right
13:26:49 <Heffalump> oh, sorry, I thought ghci was being used
13:26:50 <Beelsebob> dmwit: right
13:27:01 <Heffalump> yes, it'd be a problem as a top-level declaration in a .hs file
13:27:12 <Heffalump> but typically people compare lambdabot with ghci
13:27:20 <dolio> It should become monomorphic if you do 'let foo = fmap fromIntegral (Just 3)'
13:27:36 <Heffalump> yep, it does
13:27:40 <dolio> Defaulting to... Integer?
13:27:44 <FordCortina> dmwit: i see the differnce
13:27:45 <Heffalump> yep
13:27:55 <dmwit> Okay, great.
13:28:19 * Heffalump cites this as a good reason that Cale should fix lambdabot :-)
13:28:31 <Beelsebob> question is... why does \bot implement . as fmap?
13:28:48 <dmwit> Or a good reason that Haskell' should switch to Caleskell. ;-)
13:28:53 <augustss> because Cale likes it
13:29:00 <Beelsebob> ah, I see
13:29:04 <dmwit> Beelsebob: fmap generalizes (.), mappend generalizes (++)
13:29:20 <Beelsebob> dmwit: yes, but that doesn't mean that fmap *is* (.)
13:29:28 <Beelsebob> if I write . in code, I mean it
13:29:28 <dmwit> Sure it does.
13:29:39 <Beelsebob> well no, here's an example where they're not the same
13:29:39 <dmwit> > fmap (+1) (*2) 3
13:29:40 <lambdabot>  7
13:29:49 <Beelsebob> > fmap fromInteger (Just 3)
13:29:50 <lambdabot>  Just 3
13:29:53 <Beelsebob> see... not (.)
13:30:02 <dmwit> ?src fmap (->)
13:30:03 <lambdabot> Source not found. You type like i drive.
13:30:09 <dmwit> ?src (->) fmap
13:30:10 <lambdabot> fmap = (.)
13:30:11 <dmwit> See?
13:30:48 <Beelsebob> Prelude> fromInteger (.) (Just 3)
13:30:48 <Beelsebob> <interactive>:1:12:
13:30:48 <Beelsebob>     Couldn't match expected type `Integer'
13:30:48 <Beelsebob>            against inferred type `(b -> c) -> (a -> b) -> a -> c'
13:30:49 <Beelsebob>     In the first argument of `fromInteger', namely `(.)'
13:30:49 <Beelsebob>     In the expression: fromInteger (.) (Just 3)
13:30:50 <Beelsebob>     In the definition of `it': it = fromInteger (.) (Just 3)
13:30:52 <Beelsebob> not (.)
13:30:57 <Beelsebob> they have different behaviours
13:31:04 <Beelsebob> even if fmap is a general case of (.), they're not the same thing
13:31:07 <dmwit> > (.) fromInteger (Just 3) -- you put it in the wrong order
13:31:08 <lambdabot>  Just 3
13:31:33 <dmwit> > fromInteger (.) (Just 3) -- an error here, too
13:31:34 <lambdabot>  Couldn't match expected type `Integer'
13:31:42 <Beelsebob> no, that's because \bot implements (.) as fmap
13:31:52 <dmwit> I'm just saying.
13:31:53 <Beelsebob> Prelude> (.) fromInteger (Just 3)
13:31:53 <Beelsebob> <interactive>:1:17:
13:31:53 <Beelsebob>     Couldn't match expected type `a -> Integer'
13:31:54 <Beelsebob>            against inferred type `Maybe t'
13:31:54 <Beelsebob>     In the second argument of `(.)', namely `(Just 3)'
13:31:54 <Beelsebob>     In the expression: (.) fromInteger (Just 3)
13:31:55 <Beelsebob>     In the definition of `it': it = (.) fromInteger (Just 3)
13:32:14 <dmwit> Look, all I said was: fmap generalizes (.).
13:32:18 <Beelsebob> `more general version of` is not the same as `equal to`
13:32:18 <dmwit> I stand by that statement.
13:32:24 <Beelsebob> yep, and I agree with you
13:32:32 <augustss> dmwir: as you should, because it's true
13:32:46 <Beelsebob> that doesn't mean that \bot should treat them as the same
13:32:53 <Beelsebob> because fmap works in cases where (.) doesn't
13:32:56 <dmwit> That's arguable.
13:32:56 <Beelsebob> (or should)
13:33:09 <dmwit> I do think \bot should treat (.) as fmap.
13:33:15 <dmwit> It's a nice notation.
13:33:19 <Beelsebob> I don't
13:33:24 <dmwit> *shrug*
13:33:25 <Beelsebob> I think (.) is a well defined Haskell function
13:33:32 <Beelsebob> and it's not the same as the well defined fmap function
13:33:44 <Beelsebob> it's close, but not the same
13:33:45 <sclv_> It's a strict subset though.
13:33:47 <dmwit> Beelsebob: So, what you're saying is: it shouldn't do that, because H98 doesn't?
13:33:55 * dmwit supports progress
13:34:08 <Beelsebob> dmwit: I'm saying if it's going to include a Haskell interpretter, it should actually be a Haskell interpretter
13:34:22 * sclv_ has come around to realizing that a generalization of (.) for Categories (for use in FRefs) is actually more useful.
13:34:22 <Beelsebob> if I *want* the general version, I can write it
13:34:38 <dmwit> > let f :: a -> (forall b. b -> c) -> d; f = undefined in 3
13:34:38 <lambdabot>  Parse error at "." (column 24)
13:34:38 <Beelsebob> if I don't want it, then I can write that too (if it is implemented sensibly)
13:34:41 <byorgey> sclv_: hear, hear!
13:35:27 * dmwit tries searching for a really nice extension that \bot uses
13:35:34 <sclv_> its more intuitive too actually.
13:36:23 <BMeph> If I want electricity coursing through my home I can bloody-well call for a lightning bolt! (Apologies to the fun at Heffalump's expense)
13:36:45 <BMeph> Er, Beelsebob, I mean.
13:36:47 <dmwit> Right, I don't find Beelsebob's argument convincing, either.
13:37:16 <Deewiant> > Just [1,2] ++ Just [3,4] ++ Nothing
13:37:18 <lambdabot>  Just [1,2,3,4]
13:37:25 <Beelsebob> so my argument that "(.) has a well defined behaviour, and I should get it when I write (.)" is not convincing
13:37:31 <dmwit> The set of things I can do in lambdabot is a strict superset of the things I can do in H98.  What's not to like?
13:37:50 <BMeph> I don't find it "convincing," but I do sympathize with it.
13:37:52 <Beelsebob> and that "fmap has a well defined behaviour, and I should get it when I write fmap and only when I write fmap"
13:38:01 <Heffalump> it's not a strict superset
13:38:03 <Beelsebob> (or one of it's synonyms)
13:38:06 <Heffalump> you get different types printed out
13:38:11 <dmwit> Beelsebob: It is not convincing, because I could argue that (.)'s well-defined behavior is wrong.
13:38:25 <dmwit> ...as I am, in fact, arguing.
13:38:32 <byorgey> but you already get the behavior of (.) when you write fmap, for a suitable functor instance.
13:38:33 <Heffalump> also, when what you want to do is "test whether foo works", then it is also not a strict superset
13:38:38 <Beelsebob> dmwit: why have two functions with the same behaviour when you could have two with different behaviours
13:38:47 <Beelsebob> and have one produce an error when you use it wrong
13:38:52 <Beelsebob> an error that the other one wouldn't produce
13:38:58 * BMeph also thinks that ($) should be left-associative.
13:39:05 <dmwit> Beelsebob: I agree, but removing fmap would break backwards compatibility. ;-)
13:39:08 <Beelsebob> because the other one works in that situation, but doesn't do what you expect
13:39:16 <Heffalump> I don't object to \bot supporting extra stuff, but it shouldn't do so in the default commands.
13:39:41 <BMeph> Beelsebob: "dmwit: why have two functions with the same behaviour when you could have two with different behaviours" is a very poor complaint.
13:39:49 <kowey> hello #haskell! when I run a 'hello world' program under Wine, I get no output, not even if I redirect the output
13:39:52 <kowey> any ideas?
13:39:56 <Beelsebob> BMeph: that's not the whole complaint
13:40:05 <dmwit> kowey: Maybe ask the Wine people?
13:40:06 <Beelsebob> if you're gonna quote me, quote me wholy
13:40:08 <kowey> (compiled via ghc, of course)
13:40:10 <mar77a> kowey: why use Wine
13:40:18 <BMeph> Beelsebob True, just pointing out that that particular one is bad. :)
13:40:25 <dmwit> But yeah, why use Wine for a Haskell program?
13:40:28 <kowey> mar77a: to make it easier for non-windows darcs people to test Windows bugs
13:40:34 <mar77a> ah
13:40:47 <kowey> just curiosity really, see if it's possible :-)
13:40:48 <Beelsebob> BMeph: true
13:41:33 <kowey> oh that's interesting... it's fine under cmd.exe... just not under rxvt (msys on Wine)
13:42:06 <olsner> then that's a bug in msys not being able to handle windows console applications?
13:42:45 <Heffalump> presumably it works fine in real Windows, though
13:42:51 <Heffalump> otherwise nothing would work ever
13:43:03 <Heffalump> so it's some combination of msys and Wine going wrong
13:43:11 <Heffalump> kowey: do C programs work?
13:43:18 <BMeph> Beelsebob: I get where you're coming from, especially concerning "\bot doesn't eval things the same way you'd see in GHCi," but I still think it's not just valid, but useful, to have the "expanded" interpretation she does.
13:43:31 * kowey writes hello world in C
13:43:44 <Heffalump> BMeph: it's an interesting experiment, it just doesn't belong in the default behaviour
13:44:11 <Beelsebob> BMeph: I don't see why it's useful -- without it, you can get the same behaviour (by using fmap), and by having (.) actually be (.) you get errors when people do things wrong
13:44:23 <Beelsebob> getting errors when you got it wrong is *really* important
13:44:24 <Heffalump> in the same way as you have to do something special in GHC to deviate from H98, you should have to do something special in lambdabot to deviate from standard Haskell
13:44:27 <Beelsebob> it's why I use Haskell, not C
13:44:46 <dmwit> Beelsebob: f . g is much less noisy than f `fmap` g.
13:44:48 <BMeph> Heffalump: If it weren't \bot, I might agree wth you. Lambda's not meant to be a static reference, though. :)
13:44:50 <dmwit> That's why it's useful.
13:45:10 <dmwit> Less noisy is one of the reasons I like Haskell.
13:45:12 <vincenz> @join #oasis
13:45:15 <Beelsebob> dmwit: yes, but unfortunately fromInteger . (Just 3) doesn't produce an error
13:45:16 <Beelsebob> which it should
13:45:22 <vincenz> @bot
13:45:22 <lambdabot> :)
13:45:23 <Heffalump> BMeph: but there's only room for one responder to the standard commands on the "official" Haskell IRC channel.
13:45:27 <vincenz> > product . take 20 . iterate (subtract 1) . product $ [1..20]
13:45:29 <lambdabot>  5278278940031998497063300709889117522397507601440814591891521644477363372473...
13:45:34 <vincenz> > length . show . product . take 20 . iterate (subtract 1) . product $ [1..20]
13:45:36 <lambdabot>  368
13:45:55 <Beelsebob> especially considering that a lot of people using \bot are noobs
13:45:57 <kowey> Heffalump and olsner: yes! same symptoms with a C version
13:45:58 <dmwit> Heffalump: >> could be different from >
13:46:10 <Heffalump> dmwit: right, that would be fine
13:46:15 <Beelsebob> and might need to have it explained to them why fromInteger . (Just 3) doesn't work
13:46:16 <BMeph> Heffalump: Note your usage, "official." ;)
13:46:27 <dmwit> But that would break the "IRC is a literate Haskell file" thing. =)
13:46:30 <Heffalump> BMeph: well, it's advertised on haskell.org etc
13:46:41 <Heffalump> dmwit: c> then (c for cale)
13:47:04 <Cale> You guys are strange :)
13:47:04 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
13:47:29 <twobitwo2k> has dons been around recently?
13:47:41 <dmwit> preflex: seen dons
13:47:41 <preflex>  dons was last seen on #haskell 2 hours, 11 minutes and 36 seconds ago, saying: ah yes.
13:48:03 <BMeph> Beelsebob: Maybe we should add a line to the topic: "Warning: Lambdabot must be used with caution - 'don't try this at home!'"
13:48:06 <twobitwork> ahh
13:48:26 <Beelsebob> BMeph: could do -- or could just have \bot stop doin it rong
13:48:27 <Heffalump> or we could just fix it :-)
13:48:34 <Beelsebob> but I do appreciate why people like it doin it rong
13:48:49 <Heffalump> I did have a go at doing it a few weeks ago, but got a bit stuck on how to fit in with the way the code is structured now
13:49:09 <BMeph> Or we could only have her respond to private messages.
13:49:13 <Heffalump> (where fixing = making it possible to have several different evaluation environments tied to different commands)
13:49:40 <Beelsebob> Heffalump: yep
13:49:44 <Heffalump> that would be mostly useless for on-channel purposes though (whichever mode she was operating in)
13:49:55 <dons> twobitwork: ?
13:50:18 <twobitwork> dons: hey :) did you get my message I left you a couple days about about hs-plugins not compiling?
13:50:27 <Beelsebob> could always have something like
13:50:28 <Beelsebob> > {-# LB #-} doom
13:50:28 <lambdabot>   Not in scope: `doom'
13:50:39 <Heffalump> that's pretty verbose
13:50:39 <Beelsebob> a lambdabot wierdness pragma
13:50:42 <Beelsebob> yep
13:50:51 <Beelsebob> was trying to think of how to make it less so
13:51:01 <Heffalump> punctuation!
13:51:04 <Beelsebob> but it does keep the whole lhs thing
13:51:17 <Heffalump> that's pretty over-rated
13:51:31 <Heffalump> it doesn't obey the rule about blank lines between code and comments, for example
13:51:37 <Beelsebob> yep
13:51:48 <sjanssen> not to mention the fact that lambdabot only accepts expressions
13:51:54 <Heffalump> and since it behaves like ghci in terms of being do-notation, not Haskell top-level definitions, I think it's already quite far away from being lhs
13:51:59 <Heffalump> > let foo = 3
13:51:59 <lambdabot>  Parse error at end of input
13:52:06 <Heffalump> oh, I thought you could add definitions
13:52:10 <sjanssen> Heffalump: it isn't like do notation, only expressions are allowed
13:52:11 <Heffalump> I guess not with that syntax
13:52:13 <sjanssen> @let foo = 3
13:52:14 <lambdabot> Defined.
13:52:15 <ziman> @let foo = 3
13:52:16 <lambdabot> <local>:2:0:     Multiple declarations of `L.foo'     Declared at: <local>:1:...
13:52:17 <Heffalump> fair enough
13:52:24 <BMeph> It's non-canonical! Burn the heretic! ;p
13:52:42 <twobitwork> > foo
13:52:43 <lambdabot>  3
13:52:49 <sclv_> <eval bot="lambda" lang-exts="cale">[[!CDATA ...
13:53:05 <sjanssen> what about a @caleskell command?
13:53:10 <Beelsebob> lol
13:53:14 <Beelsebob> a bit verbose too
13:53:26 <Deewiant> cale $ (...)
13:53:26 <ziman> it's quite mind-twisting, thinking of (.) as fmap and trying to comprehend f . g in these terms :)
13:53:26 <sjanssen> but Heffalump is right, it currently isn't convenient to modify the environment
13:53:38 <mauke> @kale
13:53:38 <lambdabot> i prove infinity never ends in both directions
13:53:43 <Cale> Even without my changes, there's a lot of stuff in lambdabot which you can't do in GHCi already.
13:53:45 <ziman> hascale :)
13:53:55 <Cale> (without a bit of setup)
13:53:55 <Beelsebob> ziman: nice idea
13:54:09 <sjanssen> (as evidence, not that we have three copies of RunPlugs in the scripts/, one each for @run, @check and @scheck)
13:54:22 <sjanssen> s/not that/note that
13:54:50 <Cale> fmap :: (a -> b) -> f a -> f b. Replace f with (e ->), to get  fmap :: (a -> b) -> (e -> a) -> (e -> b)
13:54:57 <Cale> That's about all there is to it :)
13:55:09 <Heffalump> cale: those things probably come a lot closer to the "strict superset" argument, though
13:55:31 * sjanssen prefers the Control.Category interpretation of (.) if we must overload it
13:55:34 <Cale> Heffalump: I've only generalised the types of things.
13:55:41 <Heffalump> yes, and that is not a strict superset. See above.
13:55:42 <twobitwork> dons: did I lose you again?
13:55:49 <Cale> above?
13:55:52 <Beelsebob> Heffalump: thing is that even getting a strict superset is a bad thing
13:55:57 <sclv_> sjanssen: agreed. standardizing frefs would be a key part of a new record syntax.
13:56:04 <Beelsebob> if something doesn't work, you should get an error
13:56:06 <dmwit> Cale: It's not a strict superset because :t (.) reports a different answer.
13:56:20 <Cale> It reports a more general answer.
13:56:22 <dmwit> yes
13:56:40 <dmwit> Cale: But with other extensions, all the old queries give exactly the same results.
13:56:51 <dons> twobitwork: ?
13:56:52 <dmwit> (With some exceptions.)
13:57:06 <sclv_> isn't "forall a. a -> a" a strict superset of "Int->Int" ?
13:57:08 <dmwit> Cale: Note that I don't think this is a good argument.  I'm just stating what the argument is.
13:57:10 <Heffalump> Beelsebob: well, it depends what the thing that doesn't work is. Adding more definitions than are in the Prelude to the environment is better than generalising types of existing things.
13:57:13 <dons> oh, hs-plugins. don't have time to look at it, unfortunately
13:57:21 <Cale> I'm not sure I agree with it either :)
13:57:24 <dons> seafood's got a student doing summer of code work in this area though
13:57:26 <twobitwork> dons: ahh... alright
13:57:28 <Beelsebob> Heffalump: true
13:57:44 <Beelsebob> I don't have a problem with adding function definitions
13:57:45 <Heffalump> cale: (a) the types are *different*, and (b) things that should be type errors aren't
13:58:13 <vixey> Heffalump: application of forall'd variables is implicit
13:58:14 <Cale> What do you mean by "should"?
13:58:16 <twobitwork> dons: one last thing... seems like the ftp server hosting the 0.9 version doesn't like PASV mode
13:58:20 <vixey> Heffalump: so really.. the type are equal
13:58:21 <Cale> According to Haskell 98?
13:58:22 <Heffalump> in Haskell..
13:58:25 <dmwit> Cale: yeah
13:58:28 <Beelsebob> Cale: fromInteger . (Just 3) *should* be a type error
13:58:29 <vixey> (in the sense of unification)
13:58:30 <Heffalump> vixey: you what?
13:58:36 <Heffalump> unification is not equality...
13:58:40 <Cale> Would you rather I turn all the GHC extensions off too?
13:58:45 <vixey> it is certainly an equivalence relation
13:58:50 <Heffalump> it certainly is not
13:58:57 <vixey> I can prove this ..
13:59:01 <dmwit> Cale: That's what I said, too. =P
13:59:02 <Heffalump> cale: yes, unless they are in Haskell'
13:59:08 <mauke> vixey: ok, unify Int and Char
13:59:12 <Cale> Haskell' doesn't exist yet. :)
13:59:21 <Heffalump> but there are definitely accepted proposals for it
13:59:24 <sjanssen> lambdabot doesn't accept very many extensions right now anyway
13:59:45 <sclv_> > can i haz cheezburger
13:59:46 <lambdabot>  "Of course!"
13:59:51 <Beelsebob> o.O
13:59:52 <Beelsebob> rofl
13:59:55 <Botje> what now?
13:59:55 <twobitwork> arooo?
13:59:58 <sclv_> the cheezburger ext will be confusing to noobs too
14:00:10 <Heffalump> "This is going to be in the new Haskell" is a far better argument than "I'd think this is cool and would like it to be in Haskell" (especially since you have very little hope of it getting in)
14:00:10 <Beelsebob> > can
14:00:11 <lambdabot>  Add a type signature
14:00:17 <Beelsebob> > cheezburger
14:00:18 <lambdabot>  12
14:00:22 <Beelsebob> > haz
14:00:23 <lambdabot>  22
14:00:26 <Beelsebob> > i
14:00:27 <lambdabot>  i
14:00:35 <ziman> > can
14:00:37 <Beelsebob> @type i
14:00:37 <lambdabot>  Add a type signature
14:00:38 <lambdabot> Expr
14:00:40 <MyCatVerbs> sclv_: not really. Most of the people it attracts to Haskell will find it quite intuitive already, due to their prior LOLCODE experience.
14:00:48 <marko> hi all
14:00:49 <Beelsebob> > can :: Expr -> Int -> Int
14:00:51 <lambdabot>  Couldn't match expected type `Int'
14:00:53 <byorgey> hi marko
14:00:59 <Beelsebob> > can :: Expr -> Int -> Int -> String
14:00:59 <mauke> :t can
14:01:01 <lambdabot>  <SimpleReflect.Expr -> Int -> Int -> [Char]>
14:01:02 <lambdabot> forall t t1 t2. t -> t1 -> t2 -> [Char]
14:01:08 <vixey> Heffalump: why do you say unification is not an equivalence?
14:01:10 <marko> can someone help with hxt and arroes?
14:01:13 <Heffalump> vixey: because it's not..
14:01:14 <marko> arrows
14:01:16 <Beelsebob> > can i haz 13
14:01:17 <dmwit> can _ _ _ = "Of course!" -- ;-)
14:01:17 <lambdabot>  "Of course!"
14:01:23 <vixey> Heffalump: can you give a bit more detail please
14:01:23 <Beelsebob> hehe
14:01:28 <Heffalump> Int unifies with a, a unifies with Char, but Int doesn't unify with Char
14:01:31 <Heffalump> So it's not transitive
14:01:36 <ehird> <sclv_> > can i haz cheezburger
14:01:41 <ehird> its 'I CAN HAZ CHEEZBURGR'
14:01:41 <MyCatVerbs> > can undefined undefined undefined
14:01:44 <lambdabot>  "Of course!"
14:01:45 <ehird> joo failer
14:02:03 <dmwit> > let can _ _ _ = fun "COURSE" in can i haz cheezburger
14:02:04 <lambdabot>  Add a type signature
14:02:14 <dmwit> > let can _ _ _ = expr $ fun "COURSE" in can i haz cheezburger
14:02:14 <marko> how would you count the number of children of an xml node?
14:02:14 <mauke> it isn't anything because the whole "lolcats" thing is a travesty
14:02:15 <lambdabot>  COURSE
14:02:35 <ehird> its 'i can haz'
14:02:35 <ehird> cheez
14:02:35 <ehird> er
14:02:36 <ehird> geez
14:02:37 <Heffalump> marko: with my fingers, and toes if necessary
14:02:43 <Botje> argh, spam!
14:02:56 <Botje> which will come out first: perl 6, haskell prime, or duke nukem forever?
14:03:04 <Heffalump> Botje: :-)
14:03:08 <dmwit> marko: It depends on which XML library you're using.
14:03:14 <twobitwork> I hope the latter
14:03:15 <Heffalump> don't forget the apocalypse, and the heat death of the universe
14:03:16 <dmwit> Starcraft Ghost
14:03:26 <mauke> who designed showGFloat?
14:03:28 <marko> dmwit: hxt
14:03:47 <twobitwork> Heffalump: I thought we were headed for a cold death
14:03:55 <Botje> nope
14:03:58 <Botje> entropy only goes _UP_
14:04:04 <sclv_> ?hoogle showGFloat
14:04:05 <lambdabot> Numeric.showGFloat :: RealFloat a => Maybe Int -> a -> ShowS
14:04:27 <Heffalump> twobitwork: well, that just makes the heat death even further away!
14:04:30 <twobitwork> right... but I thought the prevailing view was that the universe was expanding faster than gravity would be able to reverse it?
14:04:47 <sclv_> mauke: whats yr beef with showGFloat?
14:05:02 <mauke> why does it exist? what is its purpose?
14:05:16 <dmwit> :t showGFloat
14:05:17 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
14:05:24 <mauke> it doesn't work like printf %g or any other float formatter I know
14:06:09 * BMeph notes that both Int and Char are Enums...
14:06:24 <marko> dmwit: I tried using `getChildren >>> ...` but `...` is applied to every child not the list of children
14:06:52 <dmwit> Dunno, having never used HXT.
14:06:59 <sclv_> mauke: its in the report. you also have showE and FFloat, so...
14:07:04 <dmwit> But do you get to use a State Arrow?
14:07:09 <Saizan> marko: there's something like listA which gives you the list
14:07:11 <mauke> what
14:07:18 <dmwit> If so, just increment a (stateful) counter.
14:07:24 <mauke> things don't just magically appear in the report
14:07:35 <mauke> also, where's showHFloat?
14:07:39 <marko> Saizan: thanks.
14:07:53 <sclv_> i think its pretty convenient though, for sort of human-readable values.
14:08:16 <mauke> why not make it compatible with printf %g?
14:08:18 <marko> dmwit: I thought about that too, but we already have length...
14:08:40 <dmwit> > printf "%g" 0.23 :: String
14:08:41 <lambdabot>  "0.23"
14:08:50 <dmwit> mauke: Because we already have that?  dunno
14:08:58 <mauke> > printf "%g" 1.0 :: String
14:08:59 <lambdabot>  "1.0"
14:09:02 <mauke> no, we don't
14:09:08 <dmwit> ok
14:09:09 <mauke> Text.Printf.printf just calls showGFloat
14:09:17 <dmwit> Oh, heh.
14:09:35 <BMeph> > arr length
14:09:36 <lambdabot>   add an instance declaration for (Show (a [a1] Int))
14:09:37 <mauke> > printf "%#g" 1.0 :: String
14:09:39 <lambdabot>  "Exception: Printf.printf: bad formatting char #
14:09:45 <mauke> :-|
14:10:12 <BMeph> ?ty arr length
14:10:14 <lambdabot> forall a (a1 :: * -> * -> *). (Arrow a1) => a1 [a] Int
14:11:45 <twobitwork> ?wtf ty
14:11:46 <lambdabot> Maybe you meant: bf ft wn
14:11:51 <twobitwork> @wtf
14:11:51 <lambdabot> Maybe you meant: bf ft wn
14:11:53 <twobitwork> > wtf
14:11:54 <lambdabot>   Not in scope: `wtf'
14:11:55 <twobitwork> :P
14:12:06 <twobitwork> @let wtf = "omg"
14:12:07 <lambdabot> Defined.
14:14:08 <Jiten> > wtf
14:14:09 <lambdabot>  "omg"
14:15:12 <mauke> > omg
14:15:13 <lambdabot>   Not in scope: `omg'
14:15:28 <idnar> heh
14:16:35 <ehird> > test
14:16:36 <lambdabot> Terminated
14:17:00 <ehird> > test'
14:17:02 <lambdabot>  ...
14:17:02 <lambdabot> I am SICK of evaluating all of this crap for you. What did you ever do f...
14:17:06 <ehird> awww
14:17:07 <ehird> stupid limiter
14:17:30 <Botje> \bot is mopey enough as is :(
14:17:36 <Botje> WE STILL LOVE YOU \BOT!
14:18:15 <mar77a> \bot no such nick
14:18:21 <mar77a> 8D
14:18:58 <sclv_> > arr there matey
14:18:59 <mauke> mar77a: did you solve your problem with the triangle area?
14:18:59 <lambdabot>  "ahoy"
14:19:18 <Japsu> wtf :D
14:19:32 <mar77a> yeah, byorgey helped me
14:19:32 <Japsu> what triggers that response
14:19:38 <Japsu> from lambdabot
14:19:42 <Japsu> the "I am SICK" thingy
14:19:49 <twobitwork> @src test'
14:19:50 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:20:03 <Japsu> > test'
14:20:04 <lambdabot>   Not in scope: `test''
14:20:07 <Japsu> > test'
14:20:08 <lambdabot>   Not in scope: `test''
14:20:09 <Japsu> > test'
14:20:10 <lambdabot>   Not in scope: `test''
14:20:11 <dmwit> > expr $ fun "Japsu, stop"
14:20:12 <lambdabot>  Japsu, stop
14:20:14 <twobitwork> strange
14:20:18 <Japsu> hmm
14:20:22 <Japsu> interesting
14:20:33 <Japsu> but it's not a @def, is it?
14:20:50 <dmwit> test' was likely ?let'd and ?undefine'd in a privmsg.
14:20:50 <twobitwork> :t test'
14:20:53 <lambdabot> Not in scope: `test''
14:20:57 <twobitwork> ahh
14:20:57 <Japsu> hmm, right
14:21:42 <mar77a> @let me down = "don't let me " ++ down
14:21:43 <lambdabot> Defined.
14:21:48 <mar77a> me "down"
14:21:52 <mar77a> > me "down"
14:21:54 <lambdabot>  "don't let me down"
14:22:02 <Japsu> > thisWay
14:22:03 <BMeph> > me go
14:22:03 <lambdabot>  Yeah, it works
14:22:04 <lambdabot>   Not in scope: `go'
14:22:13 <Japsu> @undef
14:22:13 <lambdabot> Undefined.
14:22:15 <Japsu> right
14:22:29 <Japsu> that's an interesting feature ;)
14:22:38 <BMeph> @let omg = "Dude! ;)"
14:22:40 <lambdabot> Defined.
14:22:53 <twobitwork> @let sweet = omg
14:22:53 <lambdabot> <local>:1:8: Not in scope: `omg'
14:22:59 <twobitwork> @let dude = "sweet"
14:23:00 <lambdabot> Defined.
14:23:08 <twobitwork> @let sweet = "dude"
14:23:08 <lambdabot> Defined.
14:23:13 <twobitwork> > dude
14:23:14 <lambdabot>  "sweet"
14:23:15 <Botje> @tell ndm tiny nitpick about uniplate: transform is spelled wrong in the example on haddock (negLits = trasform f)
14:23:16 <lambdabot> Consider it noted.
14:23:17 <twobitwork> > sweet
14:23:18 <lambdabot>  "dude"
14:23:41 <Botje> *groan* :)
14:23:41 <tchakkazulu> @let say = expr . fun
14:23:42 <lambdabot> Defined.
14:23:57 <mauke> @undefine
14:23:58 <lambdabot> Undefined.
14:24:00 <mauke> @let say = var
14:24:01 <lambdabot> Defined.
14:24:14 <twobitwork> @src var
14:24:14 <lambdabot> Source not found. Wrong!  You cheating scum!
14:24:29 <tchakkazulu> > say "Hello."
14:24:31 <lambdabot>  Hello.
14:24:35 <tchakkazulu> Ah, that works :)
14:24:46 <Japsu> trashform f
14:24:51 <Japsu> ^___^
14:25:04 <mar77a> hello
14:25:17 <idnar> do functors give rise to(?) an arrow?
14:25:53 <Heffalump> no
14:26:10 <conal> idnar: maybe.  do you have a mapping in mind
14:26:12 <sclv_> idnar: various things, I think. a free monad is the monad freely generated by a functor, for example?
14:26:43 <idnar> conal: no, just pondering how all this stuff fits together
14:26:52 <Heffalump> I assumed the question was "are all functors arrows"
14:27:10 <idnar> Heffalump: yes, in the sense that all monads are arrows
14:27:31 <tchakkazulu> newtype WrappedFunctor f a b = WF (f a -> f b)
14:27:33 <sclv_> but functors can also give rise to comonads
14:27:44 <sclv_> which can also give be arrows
14:28:31 <dmwit> idnar: It is not possible to define instance Functor f => Arrow f, if I understand correctly.
14:28:45 <dmwit> ?src Arrow
14:28:45 <lambdabot> class Arrow a where
14:28:45 <lambdabot>     arr, pure   :: (b -> c) -> a b c
14:28:45 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
14:28:45 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
14:28:45 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
14:28:47 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
14:28:49 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
14:28:53 <tchakkazulu> instance Functor f => Arrow (WrappedFunctor f) where arr = WF . fmap; (>>>) = flip (.); first = fmap first.
14:29:02 <idnar> dmwit: you can't quite do that for Monad either though, right?
14:29:10 <dmwit> idnar: I believe you can, yes.
14:29:16 <tchakkazulu> No.
14:29:19 <conal>  tchakkazulu: i don't that def works for f = []
14:29:29 <tchakkazulu> Monads are kind * -> *, Arrows are kind * -> * -> *
14:29:29 <dmwit> errr, no?
14:29:36 <conal> tchakkazulu: one of the arrow laws fails in that case, iirc
14:29:47 <tchakkazulu> Ah, okay.
14:29:54 <tchakkazulu> Where does it go wrong? "arr"?
14:30:13 <conal> tchakkazulu: possible length mismatch.  works for streams, though.
14:30:16 <dmwit> Oh, right.
14:31:47 <idnar> @instances Arrow
14:31:49 <lambdabot> (->), Kleisli m
14:32:03 <idnar> right, you need the Kleisli wrapping
14:32:33 <tchakkazulu> conal: Arrow laws are "arr (f >>> g) == arr f >>> arr g", and what more?
14:32:43 <idnar> @src Kleisli
14:32:43 <lambdabot> Source not found. :(
14:32:45 <tchakkazulu> At the moment I can't think of stuff that would do the length mismatch.
14:32:45 <idnar> aww
14:32:59 <conal> tchakkazulu: there are nine or so.  listed in ross's arrow notation papers
14:33:10 <tchakkazulu> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }, I guess.
14:33:20 <tchakkazulu> Ahh, okay. Will check them out.
14:33:41 <Heffalump> didn't Phil Wadler cut down the number needed or something?
14:33:50 <conal> Heffalump: to 8 i think
14:34:04 <conal> in a very recent paper
14:34:08 <Heffalump> yeah
14:34:10 <thomashartman1> can someone help me with a searchpath problem? question thread at http://groups.google.com/group/HAppS/browse_thread/thread/975bc7c85cafb761
14:34:11 <lambdabot> Title: happs quickstart fails (on sp make, System.Log.Logger not found) - HAppS | Googl ..., http://tinyurl.com/6qvohs
14:34:35 <tchakkazulu> Found the paper. Playtime :)
14:40:45 <Saizan> thomashartman1: try cleaning old files. packages on which a module depends are recorded in the .hi files
14:41:07 <Saizan> thomashartman1: also, i'd just use cabal-install if i were you
14:41:12 <dcoutts> @arr!
14:41:12 <lambdabot> Swab the deck!
14:41:19 --- mode: glguy set +t
14:41:19 --- mode: ChanServ set -t
14:41:22 <glguy> :-/
14:42:52 --- mode: Saizan set -o Saizan
14:42:52 <dolio> Should have switched when they took ChanServ offline earlier.
14:42:58 <dolio> It wouldn't have noticed! :)
14:43:12 --- mode: glguy set -o glguy
14:43:31 --- mode: ChanServ set +o glguy
14:43:33 --- mode: glguy set +t
14:43:37 --- mode: ChanServ set -o glguy
14:43:40 <dcoutts> ah
14:56:14 <shapr> yarr
14:56:18 <tchakkazulu> Ah! Indeed, doesn't work for Functors.
14:56:51 <tchakkazulu> You'd need something of type (Functor f) => (f a -> f b) -> f (a,c) -> f (b,c), which can't be done.
15:02:20 <ziman> is there a way to write haskell sources in unicode (λ x → x*x) so that GHC will understand it?
15:02:39 <bos> you can use  → already
15:02:42 <dolio> -XUnicodeSource or something of that sort.
15:02:53 <bos> but λ is a valid letter, so no go there.
15:03:12 <ziman> yeah, thanks
15:03:20 <dolio> Oh, UnicodeSyntax.
15:03:51 <FordCortina> :t (fmap (/) (Just 3))
15:03:54 <lambdabot> forall a. (Fractional a) => Maybe (a -> a)
15:04:18 <FordCortina> lambdabot: oh so now you reply to me!
15:04:44 <FordCortina> (fmap (/) (Just 3))
15:05:10 <BMeph> FordCortina: Heh-heh. You're not disrespecting the fmap. ;)
15:05:21 <FordCortina> lol
15:05:54 <FordCortina> its not an instance of show which is why lambda bot wasnt printing the "answer" i guess
15:06:10 <FordCortina> but it wasn't giving me the type before which was wierd
15:06:18 <tchakkazulu> > (fmap (/) (Just 3))
15:06:19 <lambdabot>  Just <Double -> Double>
15:06:29 <FordCortina> ic
15:06:32 <FordCortina> oops
15:06:43 <proq> has anyone here successfully built hugs with bitbake?  I'm getting errors when I build
15:06:47 <tchakkazulu> Use '>' for evaluation. Otherwise the poor bot would try to make sense of everything that's said.
15:07:01 <FordCortina> yeh sorry i forgot heh
15:10:09 <thomashartman1> how do I install cabal-insall?
15:10:11 <kiris> I am so impressed with how lovely this code is and I'm not sure why: http://hpaste.org/7973
15:10:45 <dcoutts> thomashartman1: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
15:10:47 <lambdabot> Title: CabalInstall - Hackage - Trac
15:11:17 <dcoutts> thomashartman1: oh, one bit of the instructions I have to fix...
15:11:44 <thomashartman1> yes, I think it's a bit finicky about what exactly to check outl.
15:12:02 <kiris> I'm using Haskell for writing a throw away script and I'm spending all my time admiring it :-P
15:12:35 <thomashartman1> cabal setup insists cabal needs to be  >=1.3.11 && <1.5
15:12:49 <dcoutts> thomashartman1: that's the bit I was correcting
15:12:55 <thomashartman1> but I didn't see any tags in that range on hackage... aha.
15:13:02 <dcoutts> thomashartman1: I've updated the page to point to the 1.4 branch repo
15:13:38 <thomashartman1> thanks.
15:14:45 * dcoutts adds a tag & checkpoint to the cabal-1.4 branch
15:15:23 <thomashartman1> kiris: why do you lift into the IO monad?
15:16:04 <kiris> thomashartman1: it just seemed natural. hm.
15:16:17 <thomashartman1> it sacrifices purity of essense. (to quote doctor strangelove)
15:16:26 <thomashartman1> ;)
15:16:35 <kiris> how would you write it?
15:18:22 <thomashartman1> delete liftm. then do all the io in main. not exactly sure what you are trying to do though, so take that advice with a grain of salt.
15:18:34 <thomashartman1> but generally the more pure functions you have the better I would say.
15:18:44 <kiris> thomashartman1: nah, secFilenames is called from mapM
15:19:01 <thomashartman1> yeah but why?
15:19:15 <kiris> thomashartman1: er, because it has to get the directory contents for each Chapter
15:19:33 <thomashartman1> oh, i see.
15:20:03 <thomashartman1> i didn't see that io action.
15:20:13 <kiris> I could get the directory contentses all at once and then map over it, perhaps
15:21:12 <ziman> why isn't λ equivalent to \ ? i mean, why is it a syntactically non-significant, standard character? when we have →, ∃, ∀, ⇒, ∷, it's not complete without λ, i think
15:21:26 <mauke> because it's a letter
15:21:46 <ziman> well, `do' is a (double) letter, too
15:21:51 <dons> anyone have any thoughts on what commercial haskell app this guy was asked to review, http://ask.slashdot.org/comments.pl?sid=567799&cid=23587805 ?
15:21:51 <lambdabot> Title: What Makes a Programming Language Successful?
15:22:15 <mauke> do is a keyword
15:22:25 <ziman> why can't λ be a keyword?
15:22:41 <mauke> it can, but you still couldn't write λx
15:22:42 <jaj> ziman: \ introduces a lambda expression
15:22:57 <mauke> > let λ = 1 in λ
15:22:58 <lambdabot>  Illegal character ''\187''
15:22:58 <lambdabot>  at "" (column 6)
15:23:06 <mauke> lambdabot--
15:23:29 <ziman> umm, yes, it'd require a special case in the lexer
15:23:42 <ziman> but i think, it'd be worth it..
15:23:51 <ddarius> That would be unacceptable.
15:24:21 <jaj> ziman: what would it bring you?
15:24:30 <ehird> <lambdabot>  at "»" (column 6)
15:24:31 <ehird> :D
15:24:40 <ehird> λx->y is valid in ghc
15:24:43 <ehird> just enable the XUnicode thingy
15:24:52 <jaj> just stick to ASCII for programming
15:25:05 <ziman> nicer sources that use lambda itself, not a replacement character
15:25:07 <ddarius> ehird: No it isn't.  Unless you mean case foo of λx -> y
15:26:07 <thomashartman1> dcouts: darcs checkout for cabal branch 1.4 is horribly slow. a tar.gz file sure would be nice.
15:26:22 <jaj> ziman: well you could also argue that you want to be able to write down formulas in latex
15:26:24 <dcoutts> thomashartman1: aye, that's why I just checkpointed it
15:26:34 <dcoutts> thomashartman1: is it downloading 100's of patches?
15:26:37 <thomashartman1> yes
15:26:41 <dcoutts> if so you might prefer to kill it
15:26:43 <thomashartman1> something I can do about that?
15:26:44 <dcoutts> and do it again
15:26:54 <dcoutts> and you'll pick up the checkpoint I added a few min ago
15:27:07 <dcoutts> which means darcs will only download one big checkpoint patch
15:27:15 <dcoutts> == much faster
15:27:28 <thomashartman1> do I need to use --partial ?
15:27:31 <dcoutts> yes
15:27:45 <dcoutts> though still not very fast since darcs.h.o is throttling bandwidth still
15:28:45 <ziman> i'd like to have an intelligent editor that would replace -> for → while editing and then save it as -> :)
15:28:46 <gaconnet> I'm confused about (parseYaml "hi: there" >>= emitYaml >>= putStrLn") printing binary non-printables with HsSyck 0.42. Shouldn't it giving me something equivalent to "hi: there"? http://hpaste.org/7963
15:28:59 <thomashartman1> anyone think darcs will ever be as fast as git someday?
15:29:14 <roconnor> nope
15:29:27 <thomashartman1> me neithah
15:29:28 <mauke> ziman: wasn't there a script for emacs?
15:29:31 <dons> thomashartman1: they're not optimising for that kind of stuff, so no.
15:29:41 <ziman> mauke, i'll google
15:30:31 <thomashartman1> dcouts: darcs get seems to be just hung. does the checkpointing operation take some time?
15:30:39 <thomashartman1> oh it just finished.
15:33:49 <oklofok> > "cool"
15:33:51 <lambdabot>  "cool"
15:39:25 <idnar> darcs does harder work than git, I don't think it's likely that'll be optimised to be faster than git given how much work has gone into optimising git in the first place
15:39:42 <thomashartman1> dcouts: zlib, a cabal-install dependency, doesn't seem to want to install, maybe cause I just upgraded cabal? tried with lib-0.4.0.4.tar.gz
15:39:45 <dons> agentzh: woot, http://agentzh.blogspot.com/2008/05/some-haskell-love.html
15:39:46 <lambdabot> Title: Human & Machine: Some Haskell love
15:39:47 <dons> good work
15:39:58 <MyCatVerbs> @pl \l -> a : (return l)
15:39:58 <lambdabot> (a :) . return
15:40:14 <dcoutts> thomashartman1: should work, what's the problem? missing zlib.h?
15:40:50 <MyCatVerbs> Okay, I'm missing something here, I'm sure. Surely there's a better way of doing this than this:
15:41:01 <thomashartman1> dcouts: yes
15:41:04 <MyCatVerbs> > [1..10] >>= \a -> map ((a:) . return) [1..10]
15:41:05 <hpaste>  Itkovian pasted "Wrestling with ConfigFile" at http://hpaste.org/7974
15:41:05 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[2,1],[2,2],[2...
15:41:16 <thomashartman1> apt-get install zlib or some such?
15:41:28 <mauke> > replicateM 2 [1..10]
15:41:29 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[2,1],[2,2],[2...
15:41:30 <roconnor> > transpose [[1..10],[1..]]
15:41:31 <lambdabot>  [[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10],[11],[12],[13...
15:41:47 <Itkovian> Sigh. I cannot get stuff out of the configfile data I parsed and use it.
15:41:59 <roconnor> > transpose [[1..10],[1,1..]]
15:42:01 <lambdabot>  [[1,1],[2,1],[3,1],[4,1],[5,1],[6,1],[7,1],[8,1],[9,1],[10,1],[1],[1],[1],[1...
15:42:06 <Itkovian> Some types are not aligning, due to something I'm not grokking I guess
15:42:06 <roconnor> oh
15:42:59 <Itkovian> a pointer in the right direction would be appreciated.
15:43:36 <MyCatVerbs> mauke: replicateM -- perfect, thank you.
15:43:55 <thomashartman1> dcouts: shouldn't an error like that be picked up on the configure step?
15:43:57 <MyCatVerbs> @src replicateM
15:43:57 <lambdabot> replicateM n x = sequence (replicate n x)
15:44:12 <MyCatVerbs> @src sequence
15:44:12 <lambdabot> sequence []     = return []
15:44:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:44:12 <lambdabot> --OR
15:44:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
15:47:18 <dons> cool stuff, http://reddit.com/info/6lbhq/comments/
15:51:58 <tieTYT2> hm
15:52:02 <tieTYT2> liftM2... weird name
15:52:40 <ddarius> In what way?
15:53:12 <tieTYT2> wtf does M2 mean?
15:53:13 <Tchakkazzzzz> ?type liftM2
15:53:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:53:20 <tieTYT2> you don't see that as weird?
15:53:28 <Tchakkazzzzz> compare with:
15:53:31 <Tchakkazzzzz> ?type liftM3
15:53:32 <tieTYT2> i guess m stands for monad
15:53:33 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:53:37 <mauke> :t liftM
15:53:39 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:53:47 <mauke> it's like liftM2, only with two arguments
15:53:50 <mauke> er
15:56:24 <augustss> :t liftM413
15:56:26 <lambdabot> Not in scope: `liftM413'
15:59:20 <elliottt> that's a huge function to try to lift :)
15:59:34 <idnar> heh
16:05:57 <newsham> > mconcat $ map Product [1..5]
16:05:58 <lambdabot>  Product {getProduct = 120}
16:07:25 <newsham> > succ (Product 1)
16:07:26 <lambdabot>   add an instance declaration for (Enum (Product t))
16:23:14 <pjdelport> :t forkliftM413
16:23:16 <lambdabot> Not in scope: `forkliftM413'
16:25:19 <lispy|web> is bind only strict in some monads?
16:25:56 <slavik> I am doing the haskell in 5 steps tutorial and I am having some trouble understanding a piece of the following code: Prelude> let fac n = if n == 0 then 1 else n * fac (n-1)
16:26:48 <slavik> I see that it is the regular recursive definition of the factorial function, but it seems to me that the if-else block is being treated as a function that returns 1 or the recursive definition
16:26:51 <slavik> am I correct?
16:26:59 <lispy|web> > let fact n = if n == 0 then 1 else n * fact (n -1) in fact 10
16:27:00 <lambdabot>  3628800
16:27:13 <lispy|web> slavik: correct,
16:27:13 <mauke> slavik: it's not a block
16:27:16 <dolio> ifs in haskell are expressions.
16:27:19 <Botje> @src foldr
16:27:19 <lambdabot> foldr f z []     = z
16:27:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:27:23 <Botje> okay
16:27:24 <mauke> if-then-else is an expression
16:27:25 <lispy|web> > if True then 1 else 0
16:27:26 <lambdabot>  1
16:27:27 <ddarius> slavik: Everything in Haskell has a value.
16:27:28 <Botje> i was doubting there for a sec
16:27:47 <dolio> If you have a C background, if is more like the ternary operator.
16:27:54 <roconnor> everything in haskell is a value
16:28:14 <lispy|web> data Foo = F Int -- is that really a value?
16:28:20 <mauke> roconnor: how about infix declaration?
16:28:23 <mauke> s
16:28:24 <slavik> right, what I mean is, n gets set to 1 or to n*fac(n-1), correct?
16:28:26 <roconnor> :)
16:28:30 <mauke> slavik: no
16:28:40 <mauke> n is never set to anything
16:28:44 <roconnor> lispy|web: no, but it ought to be :P
16:29:03 <lispy|web> read it like, fac n is defined as, if (n == 0) then 1 else (n * fact (n - 1))
16:29:06 <dolio> roconnor: This isn't ruby. :)
16:29:34 <roconnor> Foo ought to have value Int, more or less.
16:29:37 <slavik> oh, I get it ... oops, I was looking at fac n = as fac, n = where I should be looking at it as (fac n) (if ...) (pardon the lispyness)
16:29:59 <lispy|web> never pardon the lispy :)
16:30:03 * slavik hopes he is right
16:30:14 <mauke> (defun (fac n) (if (= n 0) 1 (* n (fac (- n 1)))))
16:30:27 <slavik> I see ...
16:30:29 <mauke> except it's (defun fac (n) in lisp
16:30:41 <ddarius> We ignore CL here.
16:30:45 <slavik> (define fac n) in scheme?
16:30:53 <pjdelport> (define (fac n) ...)
16:30:57 * slavik had 1 week of scheme in college :(
16:31:11 <ddarius> (define (fac n) (if (= n 0) (* n (fac (- n 1)))))
16:31:22 <lispy|web> is bind only strict in some monads?
16:31:36 <ddarius> lispy|web: Sure.
16:31:48 <lispy|web> and IO is one of the strict ones?
16:31:52 <edwardk> hrmm. any advice on the right way to implement Adjunction? I think I can't do it between two arbitrary categories and still get a monad out of it using a haskell type class. Maybe with class associated types?
16:32:02 <lispy|web> And if so, how does unsafeInterleaveIO make the bind less strict?
16:32:31 <ddarius> To your first question, sure.  To your second, no.
16:32:52 <ddarius> Calling unsafeInterleaveIO doesn't change the definition of (>>=)
16:33:02 <ddarius> edwardk: What are your desiderata?
16:33:07 <dolio> unsafeInterleaveIO throws away the real world token, I imagine.
16:33:17 <dolio> So it eliminates the data dependencies.
16:33:37 <dolio> In GHC, that is.
16:33:55 <lispy|web> So, Foo x <- unsafeInterleaveIO iox, is strict?
16:34:07 <lispy|web> and it's strict because of the pattern match or the bind?
16:34:23 <edwardk> If I say class (Functor f c d, Functor g d c) => Adjunction f g c d | f c -> g d, f d -> g c, g c -> f d, g d -> f c where ... then I blow up when I go to define an instance of class Functor m k k => Monad m k where ... because the instance head in instance Adjunction f g c d => Monad (g `O` f) d -- doesn't mention the other category 'c' at all.
16:35:22 <slavik> for the above factorial function, would I win anything (in terms of speed) by declaring n as Int?
16:35:27 <edwardk> one fix is to go 'all the way' and define functors correctly with a pair of class associated types for their domain and range, then you lose the ambiguity involved
16:35:36 <ddarius> slavik: Of course.
16:35:45 <ddarius> slavik: You'd lose in correctness though.
16:36:04 <ddarius> slavik: And there's not much point in optimizing a naive definition.
16:36:04 <slavik> ddarius: what do you mean?
16:36:13 <ddarius> > 2^1000
16:36:13 <slavik> ddarius: I see.
16:36:14 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
16:36:21 <ddarius> > 2^1000 :: Int
16:36:23 <lambdabot>  0
16:36:25 <pjdelport> slavik: it's better to keep the function polymorphic
16:36:37 <slavik> I am just learning haskell, :P
16:36:45 <ddarius> edwardk: Try it.
16:36:47 <edwardk> class (Category (Dom f), Category (Cod f)) => Functor f where type Dom f :: * -> * -> *; type Cod f :: * -> * -> *; map :: Dom f a b -> Rng f (f a) (f b)
16:36:56 <pjdelport> slavik: you can declare its result to be type Int when you use it
16:37:28 <pjdelport> without hardwiring the whole function to Int, so to speak
16:37:49 <slavik> because in Perl (the language that I know well enough that is closest to haskell) all arithmetic is done using floats
16:37:50 <edwardk> the cost there is that you have to have 'different functors' for working over different domains and ranges (gee, like real math) so when I get to bifunctors i have to break the overuse of (,) for all arrows. =/
16:38:38 <Pseudonym> I think now is the time to fix mistakes like that, though.
16:39:01 <Pseudonym> If there's a "right" solution that's better than what we have, do it now before people use it too much.
16:39:05 <edwardk> I still don't understand why if I have class Foo f g | f -> g. and I define class Foo f g => Bar f, the instance head for Bar should have to say ANYTHING about g.
16:39:09 <ddarius> I would think Perl would have a Scheme-like numeric tower...
16:39:11 <Pseudonym> I fear that the associativity of ($) will never be fixed now.
16:39:34 <slavik> ddarius: ?
16:39:36 <Pseudonym> Precisely because we waited too long.
16:40:05 <ddarius> Pseudonym: I'm pretty sure we can swing that.
16:40:19 <pjdelport> ddarius: Perl has ints, floats, and decimal strings
16:41:02 <mauke> slavik: perl has integer arithmetic
16:41:15 <dmwit> There can't possibly be a system so big that fixing ill-advised uses of ($) would take more than a day.
16:41:38 <dmwit> Given a sufficiently competent programmer, that is.
16:41:45 <slavik> mauke: if you say use Integer; or int(arithmetic operations)
16:41:55 <ddarius> dmwit: You could practically do it with sed.
16:42:01 <dmwit> right
16:42:06 <mauke> slavik: or if you say 2 + 2
16:42:20 <slavik> mauke: that could be floats
16:42:25 <mauke> no
16:51:48 <dons> has anyone written a parallel md5 ?
16:52:10 <lispy|web> I haven't.
16:52:17 <lispy|web> dons: can you parallelize that?
16:52:43 <lispy|web> dons: I was thinking each step depended on the last calculation
16:53:10 <dons> yeah, that's what i wonder.
16:53:29 <lispy|web> I don't actually know md5 algo, but I heard zooko talking about it in #darcs one day...
16:55:19 <OceanSpray> Curry is delicious.
17:03:29 <Apocalisp> yum!
17:04:09 <TomMD> No, we use Cabal here.
17:05:12 <roconnor> http://arcanux.org/lambdacats/flavor.jpg
17:05:31 <Apocalisp> Tastes like curry
17:05:38 <Tchakkazzzzz> ?type augment
17:05:41 <lambdabot> Not in scope: `augment'
17:05:59 <Tchakkazzzzz> ?hoogle augment
17:06:00 <lambdabot> GHC.Exts.augment :: (a -> b -> b -> b -> b) -> [a] -> [a]
17:06:00 <roconnor> http://arcanux.org/lambdacats/more-curry.jpg
17:06:01 <Apocalisp> if you were quickchecking an unfold, what properties could you state?
17:06:15 <Tchakkazzzzz> O_O
17:06:45 <roconnor> I often quickcheck how one function distributes over another.
17:07:05 <Apocalisp> fold/unfold
17:09:25 <Tchakkazzzzz> And an identity-unfold, perhaps.
17:13:27 <mar77a> > length "heartbeatpigmeat"
17:13:28 <lambdabot>  16
17:15:50 <roconnor> Do we know that if A is an applicative functior, then T A is an applicative functor when T is a monad transformer from the MTL?
17:16:10 <Pseudonym> I doubt it.
17:16:23 * roconnor worries about the library proposals
17:16:29 <Pseudonym> If you never use "lift", you never see the applicative functor underneath.
17:17:22 <Pseudonym> roconnor: I assume you've read Phil Wadler's preprint?
17:17:32 <roconnor> Pseudonym: nope
17:17:41 <roconnor> don't know what you are talking about
17:18:05 <Pseudonym> http://homepages.inf.ed.ac.uk/wadler/topics/links.html#arrows-and-idioms
17:18:07 <lambdabot> Title: Wadler: Links, http://tinyurl.com/5j58vk
17:19:38 <roconnor> Pseudonym: I don't see how that applies to monad transformers (from the abstract)
17:19:59 <Pseudonym> No, but it gives a very good basis for thinking about what an applicative functor actually is.
17:20:36 <dolio> We know that if A and B are applicative functors that A `O` B is an applicative functor.
17:21:39 <dolio> I'm not sure how many of the mtl transformers qualify under that.
17:21:57 <dolio> Probably not StateT.
17:22:05 <roconnor> dolio: contT isn't a composition
17:22:23 <roconnor> stateT is kinda like composing a reader on one side and a writer on the other
17:22:45 <dolio> Yeah. But ContT A is an applicative functor regardless of what A is. :)
17:23:06 <roconnor> Pseudonym: Since i don't understand arrows, I'm not sure reducting applicative functors to arrows will help me. :)
17:24:33 <dolio> The types in the abstract of Wadler's paper make a lot of sense.
17:24:48 <dolio> A ~> B is an effectful computation from As to Bs.
17:25:40 <mar77a> > length "BLACKHAIRYDICK"
17:25:41 <lambdabot>  14
17:26:03 <roconnor> Ah, Wadler starts with the inernet robustness prinicple, which is widely blamed for the HTML mess we have today.
17:26:19 <dolio> 1 ~> (A -> B) rather matches the F (A -> B) -> F A -> F B of applicative functors (you have effectful computations that return pure functions).
17:26:21 <roconnor> HTML/browser mess
17:27:04 <dolio> A -> (1 ~> B) matches the (A -> M B) -> M A -> M B of monads (you have a pure function that takes As and returns effectful Bs).
17:28:15 <dolio> I guess one might expect comonads to correspond to A ~> B ~= (1 ~> A) -> B.
17:29:23 <roconnor> dolio: does that make comonads weaker or stronger than arrows?
17:29:29 <Tchakkazzzzz> Wow. I was pointed at that paper today. Didn't know it was this recent.
17:31:40 <dolio> roconnor: Comonads have the same relation to arrows that monads do, I think.
17:32:33 <dolio> Every comonad w gives rise to CoKleisli arrows w a -> b.
17:32:56 <dolio> Monads give you Kleisli arrows a -> m b
17:33:30 <roconnor> dolio: of course.
17:33:58 <roconnor> so every arrow gives rise to an applicative functor?
17:34:28 <dolio> Yeah, by partially applying it.
17:34:44 <roconnor> what does that mean?
17:34:56 <dolio> And I guess applicative functors f give rise to arrows f (a -> b)
17:35:17 <roconnor> dolio: that can't be right
17:35:29 <roconnor> can it?
17:35:36 <dolio> If (~>) is an arrow, then (~>) e is an applicative functor.
17:36:38 <roconnor> each e yields a different applicative functor.
17:36:43 <roconnor> ?
17:37:00 <Saizan> it's just the reader arrow transform of the applicative functor
17:37:03 <roconnor> or do is (~>) () the one we choose.
17:37:18 <dolio> Yeah, just like each e gives a different reader monad (->) e.
17:38:22 <roconnor> presumably we should get the same applicative functor going via arrows that we do with our direct translation of monads to applicative functors
17:38:55 <roconnor> this suggests that (~>) () should be the applicative functor corresponding to an arrow.
17:39:09 <dolio> @type \f g -> (Prelude..) <$> f <*> g
17:39:11 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
17:39:28 <dolio> There's your composition for applicative arrows.
17:40:43 <roconnor> how can applicative functors be weaker than arrows if applicative functors give rise to arrows
17:41:19 <dolio> Well, I'm not done yet. I have to see if I can define first.
17:45:33 <dolio> I'm drawing a blank, maybe it's not possible.
17:47:00 <dolio> @type fmap (\f (a,c) -> (f a, c))
17:47:02 <lambdabot> forall t t1 t2 (f :: * -> *). (Functor f) => f (t -> t2) -> f ((t, t1) -> (t2, t1))
17:47:13 <dolio> There we go.
17:47:36 <dolio> @type fmap (\f (a,c) -> (f a, c)) :: (Functor f) => f (a -> b) -> f ((a,c) -> (b,c))
17:47:37 <lambdabot> forall (f :: * -> *) a b c. (Functor f) => f (a -> b) -> f ((a, c) -> (b, c))
17:48:28 <dolio> So, applicatives f give rise to arrows f (a -> b).
17:48:52 <dolio> Which corresponds to the 1 ~> (a -> b)
17:50:54 <dolio> But, note that Arrow -> Applicative -> Arrow doesn't necessarily leave you with the same arrow (I think).
17:51:18 <mar77a> short & sweet definition of high order function?
17:51:37 <Tchakkazzzzz> mar77a: A function that takes a function as argument.
17:51:47 <dons> :t map
17:51:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:51:49 <lament> high order function: short & sweet.
17:52:00 <dons> grr. Cale!
17:52:15 * dons abandons lesson based on the simplicity of map
17:52:21 <dolio> That map is still higher order. :)
17:52:23 <lament> cale's definitions always confuse newbies and dons
17:52:31 <lament> dolio: use @src
17:52:32 <lament> er
17:52:33 <lament> *dons
17:52:34 <dons> its just tedious.
17:52:36 <lament> @src map
17:52:36 <lambdabot> map _ []     = []
17:52:36 <lambdabot> map f (x:xs) = f x : map f xs
17:52:40 <lament> there we go.
17:52:40 <shepheb> maybe LB needs a standard-defintion :t as well as the Caleskell one?
17:52:42 <dons> :t Prelude.map
17:52:44 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:53:01 <Cale> or even
17:53:03 <Cale> :t P.map
17:53:05 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:53:11 <mar77a> :t Cale
17:53:12 <lambdabot> Not in scope: data constructor `Cale'
17:53:16 <mar77a> > sexy
17:53:16 <lambdabot>   Not in scope: `sexy'
17:53:22 * Tchakkazzzzz grmbls *again* at (.) = fmap, instead of (<<<)
17:53:46 <Cale> You want <<< to be fmap?
17:53:48 <Cale> ;)
17:53:58 <Tchakkazzzzz> :P
17:54:05 <shepheb> is the ((->) a) monad used more often than arrows?
17:54:13 <dons> i want to be able to illustrate basic concepts of Haskell without silly things getting in the way
17:54:17 <Tchakkazzzzz> That wouldn't even make sense.
17:54:27 <Cale> (.) = (<<<) would be strange though, in that there are not as many Arrows as there are Functors.
17:54:35 <Tchakkazzzzz> Yeah, that's true.
17:54:36 <shepheb> dons: on the other hand, I learned a lot from LB's liftM = fmap = (.)
17:54:53 <Tchakkazzzzz> But people get introduced to (.) as being composition, not a mapping.
17:54:57 <shepheb> but that was at a post-newbie stage
17:55:21 <dons> right, we've all learnt the lesson.
17:55:33 <dons> now can we go back to actually using haskell in #haskell?
17:55:49 <Cale> It is Haskell.
17:56:29 <dolio> Perhaps Cale can make a spinoff channel #haskell-where-the-libraries-don't-stink. :)
17:56:34 <Cale> As much as GHC is Haskell, anyway. I mean, if you want to be really picky, we should make the bot Haskell 98 compliant :P
17:56:34 <roconnor> dons: does Data.Generics throw away static types?
17:56:44 <dons> roconnor: at runtime? no.
17:56:48 <dons> hinze generics do
17:56:53 <roconnor> at compile time
17:57:07 <dons> i'm not sure i understand the sentence then
17:57:23 <roconnor> dons. ... what do static types and runtime have to do with each other?
17:57:50 <roconnor> dons: do I get compile time type safety when using the Data.Generics library to solve the expression problem?
17:58:11 <dons> it depends.
17:58:21 <dons> in general, tags are checked at runtime
17:58:31 <roconnor> :/
17:58:32 <dons> if you use hinze generics, they're all done at compile time.
17:58:36 <roconnor> that's crappy
17:58:42 <dons> well, write a paper
17:58:42 <roconnor> what are hinze generics
17:58:52 <dons> the other generics in the base library
17:58:55 <roconnor> dons: Woustra already did
17:59:03 <dons> :t (GHC.Base.:*:)
17:59:05 <lambdabot> forall a b. a -> b -> a :*: b
17:59:06 <dons> those guys
17:59:19 <tieTYT2> dons: do you use haskell at work?
17:59:23 <dons> tieTYT2: yeah.
17:59:26 <tieTYT2> what do you do?
17:59:30 <dons> all the bloody day long.
17:59:36 <dons> i write haskell software :)
17:59:41 <dons> http://galois.com
17:59:41 <lambdabot> Title: Galois, Inc.
17:59:55 <dolio> roconnor: Go ahead and implement Clean-like generics/dynamics in GHC. :)
17:59:58 <TomMD> @remember tieTYT2 "dons: do you use haskell at work?"
17:59:58 <lambdabot> I will never forget.
17:59:59 <dolio> We won't stop you.
18:00:07 <dons> dolio: clean like generics are checked at runtime
18:00:10 <tieTYT2> i see
18:00:18 <dons> they're just a fancier Typeable
18:00:23 <dons> that can do some unification
18:00:24 <roconnor> dolio: how does clean's generics work?  Do they solve the expression problem?
18:00:31 <dons> roconnor: same as Typeable
18:00:37 <dons> runtime extension via runtime type-case
18:00:42 <roconnor> ... I must admit I was pretty unclear on the releationship between generics and the expression problem.
18:00:56 <dolio> Actually, I've not seen Clean's generics. The copy of the report I have is blank in that section.
18:00:56 <roconnor> bah
18:01:04 <roconnor> runtime
18:01:16 <dolio> Their dynamics are nicer than Data.Dynamic, though.
18:01:36 <Saizan> you can have polymorphic dynamics, iirc
18:01:50 <dons> dolio: well, they're wired into the language
18:01:54 <ddarius> The end is to perform complete type checking at run-time. (Note that this is very different from dynamic typing.)
18:02:08 <roconnor> any description on how to use generics to solve the expression problem?
18:02:20 <dons> roconnor: yeah, Sean Seefried wrote a paper on this last year
18:02:25 <roconnor> ddarius: how is it different from "dynamic typing"?
18:02:48 <dons> http://www.cse.unsw.edu.au/~sseefried/files/papers/seefried07exp-prob.pdf
18:02:50 <lambdabot> http://tinyurl.com/67ckvo
18:03:25 <ddarius> roconnor: Because you still never execute code that isn't type correct.  You still preserve properties like parametricity.
18:04:52 <roconnor> dynamic type systems don't execute code that isn't type correct.  Perhaps you have a point about parametricity
18:05:41 <ddarius> roconnor: They'll execute code until they explicitly hit some type mismatch, by then you may regret what you've already executed.
18:06:45 <ddarius> startNuclearCountdown(); if cancelled then cancelNuclearCountdown(); --> "type error in cancelNuclearCountdown: can't convert string to int"
18:08:01 * roconnor wonders if I care about separate compilation
18:08:31 <dons> well, if you have access to all the code, its a lot easier
18:09:08 <ddarius> You always have access to all the code at runtime.
18:09:40 <mikeday> Hi, any tips on the best way to write a lexer/scanner in Haskell? I see plenty of parser generators, but is "Alex" the only lex equivalent?
18:09:59 <dons> alex is the industrial one, yeah.
18:10:03 <dons> there's others, but alex rocks.
18:10:48 * ddarius has never used Alex.
18:11:03 <mikeday> I couldn't find anything in the Alex documentation about UNICODE support
18:11:10 <mikeday> any idea if it works with UTF-8?
18:11:42 <ddarius> http://www.nondot.org/sabre/Projects/HaskellLexer/
18:11:44 <lambdabot> Title: The Haskell Dynamic Lexer Engine
18:12:54 <QtPlatypus> ddarius: I don't feel that is an accurte charitorisation of dynamic typing.
18:13:12 <QtPlatypus> (And yes the spelling of that sentence was totally bubkis)
18:14:54 <QtPlatypus> With dynamic typing the type is a property of the value, while in static typing the type is a property of the verable.  Everything else is a possable coniquence of this rather then a neccery one.
18:15:29 <lispy|web> variable?
18:15:41 <lispy|web> But, I thought haskell didn't have "variables" and it has static types :)
18:15:57 <QtPlatypus> lispy|web: Yes.
18:16:56 <QtPlatypus> haskell has variables, they just don't vary.
18:17:16 <lispy|web> staticles
18:17:22 <Riastradh> They do vary.
18:17:46 <Riastradh> let f x = x in [f 1; f 2]  -- The value of the variable x varies depending on which call to f is in question.
18:17:51 <lament> haskell doesn't have variables, but they do vary.
18:18:11 <lispy|web> those are formal parameters
18:18:30 <Riastradh> What they do not do is change depending on the time of reference.  In the same call to f, two different references to the same variable x will yield the same value.
18:18:52 <roconnor> heh, what is this "time" you speak of. :P
18:19:06 <Riastradh> That's precisely why they don't change depending on time, roconnor: Haskell *doesn't* have an implicit concept of time.
18:19:22 <roconnor> yep
18:20:05 <dolio> It's not just variables that have types in Haskell, though.
18:20:09 <dolio> Expressions have types.
18:20:36 <dolio> Variables are just names for expressions (more or less).
18:21:31 <geezusfreeek> it's variable in the same sense that you would call something a variable in mathematics. they don't change, they just represent some unknown (yet) value
18:21:58 <mikeday> yay, nomenclature :)
18:22:11 <geezusfreeek> and different uses of the same variable may bind it to different values, but it's not really the same as a mutable variable
18:22:37 <geezusfreeek> man, i thought it would be easier to say than that
18:23:45 <mikeday> so, no one really familiar with Alex and UNICODE, then?
18:25:11 <lispy|web> All I know about UNICODE I learned from Joel on Software
18:25:13 <geezusfreeek> say i have an infinite stream of random values and i wanted to implement a split function for it (treating it like a generator for Random)... is there any better way of doing it at all than leapfrogging?
18:25:18 <lispy|web> I'm of no use :)
18:25:45 <Riastradh> Why do you folks upcase `Unicode', out of curiosity?
18:26:22 <dolio> It's clearly an acronym. :)
18:26:49 <dolio> Universal... uh...
18:27:00 <bd_> geezusfreeek: my instinct says no, unless we can make assumptions about the generator (ie, if the stream of values is generated from some hardware quantum source, then feeding any subset into a PRNG will degrade the quality)
18:27:07 <mikeday> because we pronounce it in a booming voice, like slabs of lead falling to the ground in an empty warehouse
18:27:29 <lispy|web> Riastradh: I can put starts around it too if you prefer, __*UNICODE*__, or some such
18:27:45 <mikeday> much like Death in Terry Pratchett's Discworld. "Does this program support... UNICODE?"
18:27:51 <bd_> \__*UNICODE*__/
18:27:56 <geezusfreeek> bd_: :(
18:29:15 <znutar> I like the uppercase because it makes me think of UNIVAC
18:30:03 <mikeday> Given the hassle it takes to implement it, writing it as "Unicode" seems anticlimactic.
18:31:30 <znutar> I remember when I first read about it and it seemed both simple and a good idea
18:32:51 <znutar> Then I think they figured out there were more than 2^16 characters in the union of all the worlds alphabets and made it ugly and some weird cross between useful and unimplementable
18:33:13 <bd_> znutar: this is when you avoid UTF-16 like the plauge
18:33:23 <bd_> UCS4 or UTF8
18:33:45 <geezusfreeek> i remember when i first was learning programming and i thought programming with strings was easy (in C, no less!)
18:33:52 <geezusfreeek> then the more i learned the worse things got
18:33:59 <geezusfreeek> *became
18:37:15 <mikeday> it looks like Alex applies regular expressions to 8-bit byte streams
18:37:27 <mikeday> in which case UTF-8 support can be hacked in, awkwardly, much as it can with flex
18:37:28 <agentzh> dons: thanks :)
18:38:11 <SamB_XP> mikeday: I bet it's possible to do better than that...
18:39:06 <SamB_XP> not sure what would BE better...
18:39:28 <mikeday> being able to define character ranges in terms of actual code points instead of UTF-8 sequences
18:40:05 <SamB_XP> mikeday: I was thinking it might be desirable to use character properties, rather than hardcoding codepoints
18:40:36 <mikeday> right, but many syntaxes define their own properties, eg. XML's definition of which characters can be in a tag name
18:40:43 <SamB_XP> since it is rare that individual unicode codepoints are hardwired into a lexical grammer
18:40:57 <SamB_XP> mikeday: yeah, that's why I don't know what would BE better
18:41:00 <mikeday> well, XML 1.0 is a major exception to that :)
18:41:04 <ddarius> geezusfreeek: Clearly the problem was learning.
18:41:15 <SamB_XP> I'm thinking you'd want to make it flexible...
18:41:36 <hpaste>  ronwalf pasted "GHC Build failure on OS X" at http://hpaste.org/7976
18:41:41 <mikeday> trouble is I guess then you would want to write a function to generate your Alex definition which then gets compiled back to Haskell; seems like too many layers
18:42:11 <ronwalf> That build was from $ ./configure --with-readline-include=/sw/include/readline --with-readline-libraries=/sw/lib
18:42:23 <SamB_XP> I guess it might be cleaner to just use the HACK
18:42:31 <znutar> bd_: yeah, but originally it wasn't proposed as having anything but a single 16 bit encoding, then they panicked and it turned into a mess
18:42:40 <SamB_XP> rather than have all that ill-fitting crap
18:42:48 <mikeday> right
18:43:33 <SamB_XP> though I've this nagging feeling that I might be forgetting something...
18:44:28 * ronwalf tries the binaries instead
18:44:42 <mikeday> hmm, perhaps Parsec is better, doesn't appear to need a separate lexer
18:45:36 <mikeday> maybe not very efficient to use it for scanning, though. Oh well.
18:45:48 <nolrai_> Parsec is sweet
18:47:11 <Spark> chessguy: hi from #math :)
18:47:39 <chessguy> hiya #haskell folk
18:48:57 <dmwit> Hiya, chessguy!
19:05:45 <mmorrow> ℕℤℚℝℂ
19:06:23 <mmorrow> ←↑→↓↔↕↖↗↘↙↚↛↜↝↞↟↠↡↢↣↤↥↦↧↨↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪⇫⇬⇭⇮⇯⇰⇱⇲⇳⇴⇵⇶⇷⇸⇹⇺⇻⇼⇽⇾⇿
19:07:31 <SamB_XP> I onlys see ←↑→↓↔↕↖↗↘↙↨
19:07:59 <mmorrow> i think if you copy and paste into something else, it'll show up
19:08:01 <SamB> I see all of them, though
19:08:09 <SamB> stupid Windows
19:09:01 <SamB> mmorrow: are you gearing up to write some Agda or something?
19:09:35 <mmorrow> i just discovered how many cool symbols unicode has
19:09:45 <mmorrow> always used to scoff at it
19:09:56 <mmorrow> that was cuz i had never bothered to look
19:10:04 <mmorrow> holy crap!
19:10:06 <SamB_XP> too bad Windows comes with such pathetic fonts
19:10:16 <mmorrow> ∀∁∂∃∄∅∆∇∈∉∊∋∌∍∎
19:10:22 <mmorrow> ∑∏∐
19:10:34 <mmorrow> (i'm organizing)
19:10:52 <mmorrow> ⌤⌥⎇⍽⏏⏎
19:10:57 <SamB_XP> only ∂∆∈∑∏ work here...
19:11:14 <mmorrow> ∧∨∩∪⋀⋁⋂⋃
19:11:26 <SamB_XP> ∧∨∩∪
19:11:29 <mmorrow> ≂≃≄≅≆≇≈≉≊≋≌≍
19:11:37 <SamB_XP> ≈≌
19:11:39 <mmorrow> ≎≏≐≑≒≓≔≕≖≗
19:11:48 <mmorrow> g∘f
19:12:03 <mmorrow> ⊕⊖⊗⊘⊙⊚⊛⊜⊝
19:12:14 <SamB_XP> ≒∘⊕⊙
19:12:18 <mmorrow> ⊢⊣⊤⊥⊦⊧⊨⊩⊪⊫⊬⊭⊮⊯
19:12:34 <dmwit> What is this moon-speak?
19:12:34 <mmorrow> ⋎⋏⋐⋑⋒⋓
19:12:44 <mmorrow> i'm organizing unicode symbols
19:13:13 <Zao> It's breaking my misconfigured terminal, that's what it is.
19:13:46 <dmwit> Well, mr-configure it, then!
19:14:43 <mmorrow> what's your terminal doing
19:14:50 <Zao> Thinking it's latin1.
19:15:13 <Zao> Which makes it not clear properly, leaving fragments of other channels, making me go wtf at the conversation.
19:15:15 <mmorrow> oh dear
19:15:23 <Zao> Fixed now though, was a virgin installation of putty.
19:15:54 <dmwit> You're talking on IRC... via putty.
19:15:55 <mmorrow> just ^z  reset fg is nice
19:16:29 <SamB> dmwit: I would too if I didn't know how much MORE time I would waste that way
19:16:35 <Zao> dmwit: Yes. It kind of helps to have a ssh client when your irssi is on an solaris box.
19:17:11 <dmwit> Oh, are you using some kind of screen-alike?
19:17:18 <shepheb> I'm even on an Ubuntu box with irssi readily available, but I SSH into an irssi running under screen elsewhere since my internet goes down every 90 bleeding seconds.
19:17:27 * dmwit always forgets about screen
19:18:00 <SamB> I learned how to use screen as a tutor at the community college
19:18:20 <SamB> ... since, you know, it allowed me to goof off more effectively
19:19:27 <nolrai_> :t (>>=)
19:19:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:19:29 * SamB has pasted the part where mmorrow was spouting unicode into a text file
19:20:56 <SamB_XP> ⊥ also worked, btw...
19:21:47 <ronwalf> Can ghci load automatically after editing (ala hugs)?
19:22:41 <SamB_XP> you type :r
19:23:03 <nolrai_> :t (<<=)
19:23:05 <lambdabot> Not in scope: `<<='
19:23:10 <nolrai_> :t (=<<)
19:23:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:23:55 <mmorrow> SamB: my scratch file as of now: http://morrow.jypsis.com/unicode/omg_unicode.txt
19:24:11 <mmorrow> firefox chokes on it
19:24:30 <mmorrow> xchat sees all
19:24:48 <SamB_XP> hmm, firefox here doesn't choke
19:25:14 <dmwit> Boy, Firefox does choke on that.
19:25:16 <dmwit> nasty
19:25:20 <SamB_XP> but also misses a number of characters and displays them all in a tiny font...
19:25:36 <dmwit> mmorrow: Set the encoding to UTF-8, then it looks fine.
19:25:50 <mmorrow> trying to find it...
19:25:54 <dmwit> It's under View -> Character Encoding
19:26:26 <TSC> That helps quite a bit
19:26:39 <SamB> this firefox only misses a few ... 6, is it?
19:26:48 <mmorrow> nice.
19:27:06 <mmorrow> dmwit: thx
19:27:27 <SamB> actually I just spotted a 7th missing
19:32:26 * ronwalf cries about ghci not auto-reloading
19:32:51 <shepheb> ronwalf: if you're an emacs user, the ghci integration gives quick reloads, at least.
19:33:09 <ronwalf> shepheb: I use vim
19:33:13 <ronwalf> at least in this case
19:33:41 <shepheb> ronwalf: fair enough. there is :r, is auto-reloading that much hanider?
19:33:47 <ronwalf> I used to have a nice cycle of editing in hugs/vim, compiling in ghc to test
19:34:14 <ronwalf> Twice the commands!
19:34:17 <ronwalf> But no, not too bad
19:35:20 <ronwalf> thanks
19:36:39 <shepheb> Project Euler is becoming less and less of a place to enjoy writing some Haskell. now it's more like I spend several days pondering the algorithm, and then write a bit of Haskell.
19:37:14 <SamB> you might as well write some of those for your graphing calculator
19:38:28 <dons> ?yow
19:38:28 <lambdabot> Yow!  I just went below the poverty line!
19:38:32 <dons> crikey!
19:39:33 <dons> Cale: http://radix.twistedmatrix.com/2008/05/requirements-for-restricted-execution.html
19:39:34 <lambdabot> Title: Twisted Radix: Requirements for a restricted execution runtime, http://tinyurl.com/62moex
19:39:39 <dons> see the query about how to write continuations in haskell
19:40:53 <SamB> radix: did you ask here?
19:44:06 <SamB> hmm, hasn't spoken in twisted for about 2 hours
19:44:14 <SamB> er. #twisted
19:44:45 <SamB> his last words were about going to get some dinner...
19:50:45 <nolrai_> @pl pairWise f (x1,y1) (x2,y2) = (f x1 x2, f y1 y2)
19:50:46 <lambdabot> pairWise = (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
19:51:08 <fadec> A[B2123
19:51:37 <nolrai_> thats pl hell. gezzus
19:52:22 <dmwit> :t (,) . join (&&&) . uncurry f
19:52:24 <lambdabot> forall b (a :: * -> * -> *) b1 c a1 b2. (SimpleReflect.FromExpr (a b1 c), Show b2, Show a1, Arrow a) => (a1, b2) -> b -> (a b1 (c, c), b)
19:52:29 <dmwit> :t (,) . join (&&&) . uncurry
19:52:30 <lambdabot> forall b a b1 c. (a -> b1 -> c) -> b -> ((a, b1) -> (c, c), b)
19:52:40 <dmwit> Not quite.
19:52:42 <dmwit> Let's see.
19:53:08 <dolio> :t join (***)
19:53:10 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
19:53:14 <dmwit> :t curry . join (***) . uncurry
19:53:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> (a, b) -> (c, c)
19:53:25 <dmwit> nolrai_: ^^
19:53:33 <nolrai_> thats not bad.
19:53:42 <dolio> No, that's not what he has.
19:53:46 <dmwit> oh
19:53:53 <dolio> His is (a -> b -> c) -> (a,a) -> (b,b) -> (c,c)
19:54:08 <dmwit> Agh, I misread the x/y 1/2 thing.
19:54:54 <dmwit> Oh, his is kind of nasty.
19:54:57 <nolrai_> :t (&&&)
19:54:58 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:55:07 <dmwit> Here we go!
19:55:10 <dolio> :t uncurry (***) . join (***)
19:55:12 <lambdabot>     No instance for (Arrow (,))
19:55:12 <lambdabot>       arising from a use of `***' at <interactive>:1:8-12
19:55:12 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
19:55:24 <dmwit> :t join (***) . join (***)
19:55:26 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a ((b, b), (b, b)) ((c, c), (c, c))
19:55:40 <dmwit> Oh, no3.
19:55:51 <shepheb> does (,) actually form an arrow? seems like it shoul
19:55:52 <radix> dons: aha!
19:56:01 <dmwit> :t curry . join (***)
19:56:03 <lambdabot> forall b c. (b -> c) -> b -> b -> (c, c)
19:56:11 <radix> dons: I was hoping someone in here would notice that post :)
19:56:23 <newsham> Hi, goofing off with some applicative stuff, and wondering how much transformations the compiler can or could do.  Of the transformations here, what are allowed and what are implemented?  http://hpaste.org/7978
19:56:28 <dmwit> :t curry . join (***) . curry . join (***)
19:56:30 <lambdabot> forall b c. (b -> c) -> b -> b -> (b -> (c, c), b -> (c, c))
19:56:33 * SamB wonders how Haskell is Turing complete when System F isn't...
19:56:50 <radix> dons: and I was especially hoping someone would post a comment to it
19:56:59 <byorgey> shepheb: I don't think so, how would you implement arr?
19:57:00 * SamB supposes it's because of lets
19:57:02 <byorgey> @type arr
19:57:03 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
19:57:32 <byorgey> it would have to have type (b -> c) -> (b,c)
19:57:58 <dmwit> :t ((***) .) . curry . join (***)
19:57:59 <shepheb> byorgey: ah, I see.
19:58:00 <lambdabot> forall b' c' b c. (b -> c) -> b -> (b' -> c') -> (b, b') -> ((c, c), c')
19:58:09 <byorgey> dmwit: good luck with that ;)
19:58:11 * dmwit is just guessing now
19:58:20 <dmwit> I got phase one!
19:58:25 <dmwit> I just need phase two. =P
19:59:11 <byorgey> dmwit: write a program to create all ASTs with up to 10 nodes of (***), (.), curry, uncurry, (,), and join, and check their types =)
19:59:27 <dmwit> No no, I'm going to *actually* solve this. =)
19:59:32 <byorgey> ok =)
19:59:36 <dmwit> Because, you know, I should be working.
19:59:38 <newsham> is do { x <- return y; act; act }  ==> do { act; x <- return y; act }   a valid transofrmation?
19:59:49 <newsham> (assuming y isnt used in the first act)
19:59:52 <dmwit> Not in general.
19:59:58 <dmwit> err
20:00:01 <gubagem> i would say depends on the monad
20:00:04 <dmwit> I misread.
20:00:06 <dmwit> Let's see.
20:00:16 * gubagem still has little idea what a monad is
20:00:30 <newsham> my intuition says it should be valid, but i dont think the existing monad laws would allow it
20:00:55 <nolrai_> my intuition says so too.
20:00:57 <dolio> :t \f -> uncurry (***) . join (***) f
20:00:58 <dmwit> (return y >>= \x -> act >>= \_ -> act) vs. (act >>= return y >>= \x -> act)
20:01:00 <lambdabot> forall (a :: * -> * -> *) b c (a1 :: * -> * -> *) b1. (Functor (a1 (b1, b1)), Arrow a1, Arrow a) => a1 b1 (a b c) -> a1 (b1, b1) (a (b, b) (c, c))
20:01:15 <dolio> Well, that's useless.
20:01:20 <newsham> basically  "x <- return y" is like a "let" and should be possible to reorder those when there are no deps that say otherwise, yes?
20:01:23 <dmwit> The first becomes ((\x -> act >>= \_ act) y).
20:01:47 <dolio> > (uncurry (***) . join (***) f) (x,y) (z,w)
20:01:48 <lambdabot>  Add a type signature
20:01:49 <gubagem> i dont think it would be valid for say the io monad
20:01:56 <newsham> why not?
20:02:09 <dolio> > (uncurry (***) . join (***) (f :: Expr -> Expr -> Expr)) (x,y) (z,w)
20:02:09 <gubagem> you are changing the order action
20:02:10 <lambdabot>  (f x z,f y w)
20:02:15 <newsham> since its a pure value, there are no side effects
20:02:20 <gubagem> s/order action/ order of action
20:02:26 <dmwit> newsham: Are we assuming act /= act here?
20:02:32 <dmwit> i.e. the first and second actions are different?
20:02:34 * gubagem hides and sulks for he will never learn monads
20:02:36 <newsham> dmwit: yah, sorry, was just trying to save typing
20:02:40 <dmwit> Okay.
20:03:06 <newsham> y, act (the first) and act (the second) are arbitrary exprs and x is not used in act (the first)
20:03:07 <byorgey> that should be a valid transformation I think, unless x <- return y results in a pattern match failure
20:03:24 <byorgey> in which case they are definitely not the same
20:03:34 <newsham> thats a good point.  pattern matching can have a side effect
20:03:51 <newsham> here's what I'd like to use it for: http://hpaste.org/7978
20:03:57 <newsham> towards the bottom "XXX"
20:04:01 <nolrai_> a1 b1 (a b c) -> a1 (b1, b1) (a (b, b) (c, c)) == (b1 -> b -> c) -> (b1,b1) -> (b,b) -> c provided a and a1 are (->) right?
20:04:41 <dolio> Yeah.
20:05:05 <nolrai_> which is what i wanted right?
20:05:09 <newsham> it seems like you should be able to get the applicative form to reduce to something like the non applicative form
20:05:16 <dolio> Yeah. It's just a terrible type. :)
20:05:33 <dolio> \f -> uncurry (***) . join (***) f  is what you wanted.
20:05:45 <dolio> Although I suspect it's longer than your definition. :)
20:06:08 <nolrai_> yes, yes it is.
20:06:22 <dmwit> :t ((join (***) (uncurry ($)) .) .) . curry . join (***) . first
20:06:23 <lambdabot> forall b b1 d. (b1 -> d -> b) -> (b1, d) -> (b1, d) -> (b, b)
20:06:32 <dmwit> Win!
20:06:45 <dolio> :) I beat you.
20:07:05 <dmwit> :t uncurry (***) . join (***) f
20:07:07 <lambdabot> forall (a :: * -> * -> *) b c (a1 :: * -> * -> *) b1. (Functor (a1 (b1, b1)), SimpleReflect.FromExpr (a1 b1 (a b c)), Arrow a1, Arrow a) => a1 (b1, b1) (a (b, b) (c, c))
20:07:23 <dolio> Wait, that's still the wrong type on yours, no?
20:07:36 <dolio> It's still (a,b) -> (a,b) -> (c,c)
20:07:54 <dmwit> I'm still doing the wrong frieking problem.
20:07:56 <dmwit> =/
20:07:57 <TomMD> @quote work
20:07:57 <lambdabot> Botje says: unlike bridges, tentacles work just fine in programming
20:08:09 <TomMD> @quote work
20:08:10 <lambdabot> Randroid says: I just wrote a monad that does my laundry. It threads it round and round until it's washed. Now I'm going to work on the Dryer monad.
20:08:19 <dmwit> No wait, mine is right.
20:08:38 * dmwit scrolls up again
20:08:57 <dolio> @type \f (x1,y1) (x2,y2) -> (f x1 x2, f y1 y2)
20:08:58 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t) -> (t1, t1) -> (t2, t2)
20:09:18 <dmwit> dang
20:10:46 <ddarius> SamB: The simply typed lambda calculus is Turing complete if you add fix as a primitive.
20:11:12 <SamB_XP> or recursive let
20:11:21 <ddarius> recursive let == fix
20:11:27 <SamB_XP> well, yes
20:15:48 <dmwit> dolio: Yep, okay, I finally end up with the same thing. =P
20:16:08 <dolio> @yow!
20:16:08 <lambdabot> I need to discuss BUY-BACK PROVISIONS with at least six studio SLEAZEBALLS!!
20:18:29 <SamB_XP> @yow!
20:18:30 <lambdabot> SHHHH!!  I hear SIX TATTOOED TRUCK-DRIVERS tossing ENGINE BLOCKS into
20:18:30 <lambdabot> empty OIL DRUMS ...
20:19:38 <narain> hi all, i'm trying to generate html in haskell. would you recommend using a library or doing my own string concats? i tried Text.Html for a bit, but either it needs too many annoying stringToHtml calls all the time or else i was doing something wrong
20:20:12 <geezusfreeek> @yow!
20:20:12 <lambdabot> I'm DESPONDENT ... I hope there's something DEEP-FRIED under this
20:20:12 <lambdabot> miniature DOMED STADIUM ...
20:20:13 <dmwit> I recommend a library.
20:20:27 <dmwit> You can statically guarantee well-formed HTML in a lot of (common) cases.
20:20:30 <geezusfreeek> library
20:20:50 <dmwit> narain: If it's really a pain, you could write "str = stringToHtml" or some similar abbreviation.
20:21:10 <newsham> string concats are a good way to make a mistake.
20:21:14 <atp> plus in my experience using Text.Html that's rarely necessary
20:21:23 <ddarius> newsham: We have TagSoup.
20:21:27 <geezusfreeek> i've been meaning to try haxml to generate xhtml
20:21:35 <atp> well, i use Text.XHtml but ssds
20:21:43 <newsham> I thought Text.Html automatically converted strings for you
20:21:52 <atp> it does iirc
20:22:03 <narain> atp: does it? i must have been doing something wrong
20:22:03 <newsham> ddarius: isnt tag soup th eother way around?  parsing and navigating html?
20:22:03 <dmwit> From the docs on stringToHtml, though, it sounds like you shouldn't be using it much.
20:22:04 <atp> it uses type classes and string is an instance afaik
20:22:19 <ddarius> newsham: Yes, I'm saying we'll be able to parse the mess he makes.
20:22:33 <newsham> oh..  there are other reasons not to make mistakes, though.
20:22:42 <newsham> like correctness and security
20:24:33 <gubagem> is there something like System.exit(1) from java in haskell
20:24:45 <gubagem> ie i just want to exit on the function call
20:24:49 <narain> oh, i'm all for correctness, but i don't mind messy in this case because it's just a little non-important program i'm writing, and i'm pretty careful with my html generation in any case. still, since everyone agrees with using a library i'll do that.
20:24:59 <dolio> @hoogle exitWith
20:24:59 <lambdabot> System.Exit.exitWith :: ExitCode -> IO a
20:25:46 <narain> but with Text.Html i tried  thetitle "Hello, world!"  and ghc told me  "Couldn't match expected type `Html' against inferred type `[Char]'"
20:25:47 <dmwit> narain: From the wiki, 'page = body << h1 << "Hello, world!"' -- doesn't require stringToHtml.
20:25:51 <newsham> narain: if you're using it right it should promote your strings appropriately though
20:25:56 <narain> oh, <<
20:26:09 <narain> hmm i should go read the wiki
20:26:10 <narain> thanks
20:26:40 <ddarius> So.  When documentation exists, people just go by the types.
20:27:03 <newsham> narain: here's a bunch of code using the lib, with some more expansive examples: http://www.thenewsh.com/%7Enewsham/x/Templs.hs
20:27:40 <newsham> if you indent right and squint it almost looks like html
20:28:30 <ppot> Does anyone know how to get Java-style objects in Haskell?
20:28:35 <ppot> What packages should I include?
20:28:50 <newsham> what do you mean by a java style object?
20:29:18 <ppot> Like, one where I can say something analogous to:
20:29:19 <ddarius> newsham: That applicative code -is- the same thing as liftM2 and x <- return y is the same as let x = y (x not free in y) if the monad satisfies the monad laws.
20:29:21 <narain> newsham: that certainly does look good
20:29:26 <ppot> foo = new bar();
20:29:33 <ppot> bar.happy();
20:29:59 <narain> dmwit: sorry, but where is it on the wiki? i can't find it
20:30:00 <ddarius> ppot: What package do you include to get Haskell style higher order functions in Java?
20:30:07 <dmwit> 1. Why would you want to?
20:30:10 <ivanm> ppot: why would you want that?
20:30:16 <dmwit> 2. No package, just use record syntax.
20:30:32 <newsham> ddarius: but the only way to make it the same is to reorder the "let", and there's no law to do that, is there?
20:30:33 <dmwit> narain: http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell#.28X.29HTML
20:30:34 <lambdabot> Title: Practical web programming in Haskell - HaskellWiki, http://tinyurl.com/2n99cj
20:30:38 <ppot> I have a book of algorithms for Eiffel that I'd like to apply to my Haskell program.
20:30:48 <Korollary> ppot: how well do you know haskell?
20:31:09 <ivanm> ppot: not all OOP/imperative algorithms translate nicely to FP
20:31:27 <ivanm> Functional Algorithms and Data Structurs (by Oleg?) is a good book
20:31:40 <dmwit> Not by Oleg.
20:31:43 <dmwit> Chris Okasaki
20:31:48 <dmwit> err...
20:31:49 <ivanm> that's right
20:31:52 <newsham> ppot: java objects are mutable.  you dont usually make mutable things in haskell
20:31:54 <ddarius> newsham: Why wouldn't it be reorderable?  You can substitute equals for equals.
20:31:54 <ivanm> I knew it started with an O :p
20:31:58 <dmwit> if you mean Purely Function Data Structures
20:32:02 <ivanm> dmwit: yeah
20:32:07 <ivanm> whatever it's called :p
20:32:09 <ppot> I've basically mastered Haskell, I just find all the best algorithms are OO.
20:32:20 <gubagem> ppot: like what
20:32:22 <Korollary> ppot: I have a feeling you are troling then.
20:32:24 <ivanm> what makes them the best?
20:32:34 <narain> dmwit: thanks! it didn't turn up in a search for "html"
20:32:36 <ivanm> ppot: no-one masters haskell... people like dons come close though!
20:32:55 <edwardk> How cute, a troll =)
20:32:56 <ddarius> let x1 = (++) x2' in getLine >>= \ x2 -> x1 x2  === getLine >>= \x2 -> x2' ++ x2
20:32:58 <newsham> ddarius: hmm.. i guess if i just translated it to a "let" I wouldnt even have to reorder it, just apply the let binding.
20:32:58 <ivanm> > "dons" == "ppot"
20:33:00 <lambdabot>  False
20:33:45 <ppot> Well, I've made a compiler in Haskell.
20:33:54 <ivanm> really? what for?
20:33:59 <edwardk> Hasn't everyone? =)
20:34:03 <dmwit> Are you this guy? http://www.research.att.com/viewResearcher.cfm?id=24
20:34:03 <lambdabot> Title: AT&T Labs Research
20:34:05 <ddarius> newsham: So the only issue is x1 <- return ((++) x2') only is equivalent to let x1 = (++) x2' if the monad laws hold (which the compiler knows nothing about)
20:34:06 <ivanm> edwardk: I haven't yet :(
20:34:11 <sclv> ?quote compiler
20:34:11 <lambdabot> scook0 says: real men don't need semantics, they pipe meaning directly into their compilers!
20:34:21 <newsham> > zipWith (\a b -> chr (ord a - ord b)) "ppot" "dons"
20:34:22 <lambdabot>  "\f\SOH\SOH\SOH"
20:34:40 <ppot> But I find the best data structures usually come in Java.lang etc..
20:34:43 <newsham> > zipWith (\a b -> chr (ord 'a' + ord a - ord b)) "ppot" "dons"
20:34:44 <lambdabot>  "mbbb"
20:34:54 <dmwit> newsham: Pretty close!
20:35:08 <ivanm> ppot: which data structures?
20:35:09 * dmwit blinks
20:35:15 <newsham> ppot is rot2 dons?
20:35:25 <sclv> ?quote Pseudonym newbie
20:35:25 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
20:35:29 <dmwit> "The best data structures usually come in Java.lang"?
20:35:29 <edwardk> more familiar, i'd hardly say best
20:35:31 <sclv> there we go!
20:35:36 <ppot> Like fibonacci heaps and stuff.
20:35:42 <Korollary> ppot: you're absolutely right. You should stick with java.
20:35:49 <edwardk> @quote ppot But I find the best data structures usually come in Java.lang etc/
20:35:49 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
20:35:52 <ivanm> does that mean I'm not even a newbie, since I've never even written a monad tutorial? :(
20:35:59 <newsham> ddarius: arent there rewrite rules based on monad laws?
20:36:03 <edwardk> @remember ppot But I find the best data structures usually come in Java.lang etc.
20:36:03 <lambdabot> Good to know.
20:36:04 <ivanm> edwardk: @remember is what you want
20:36:09 <edwardk> yeah i always forget
20:36:13 <ivanm> heh
20:36:20 <sclv> the ironing is delicious
20:36:26 <ddarius> newsham: Some, but not in general.  You can always add your own.
20:36:29 <ivanm> sclv: you eat your clothes?
20:36:54 <gubagem> is it that easy to write a compiler in haskell?
20:36:57 <edwardk> ppot: the best data structure is one you never actually have to build at all because the compiler can figure out it never needed to occupy memory. I've yet to see anything in Java.Lang vanish at runtime.
20:37:00 <lament> gubagem: yes.
20:37:11 * gubagem boggles
20:37:16 <SamB_XP> is it possible to write anything ELSE in Haskell?
20:37:19 <dmwit> gubagem: It's pretty easy.
20:37:21 <lament> SamB_XP: no.
20:37:23 <Axioplase> gubagem: not especially harder or easier than in any other functional language I guess
20:37:25 <edwardk> SamB_XP: alas, no.
20:37:34 <SamB_XP> wait, why is that bad?
20:37:45 <ddarius> I'm compiling user input to reports!
20:37:54 <edwardk> well to get anything done first you have to write the compiler for the language you want to run your language in ;)
20:37:54 <dmwit> ?yow!
20:37:54 <lambdabot> Yow!  Now I get to think about all the BAD THINGS I did to a BOWLING
20:37:54 <lambdabot> BALL when I was in JUNIOR HIGH SCHOOL!
20:38:03 <sclv> ?where 48hours
20:38:04 <lambdabot> I know nothing about 48hours.
20:38:09 <gubagem> do i need to weave in do statements inside a case inside a do block
20:38:12 <sclv> ?where+ 48hours http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
20:38:12 <lambdabot> Done.
20:38:26 <dmwit> gubagem: Yes.
20:38:29 <gubagem> yea ive looked at that
20:38:29 <Elly> someone should make an HQ9+ variant, but all it would let you do is the common functional examples :)
20:38:43 <SamB_XP> sclv: honestly, I think it's easier to just do this than to remember the name:
20:38:46 * edwardk guesses ppot is the guy at the bottom of: http://www.orientation.math.uwaterloo.ca/2004/teams/earthquake.php
20:38:47 <lambdabot> Title: University of Waterloo | Faculty of Math | Orientation 2004, http://tinyurl.com/66s6g6
20:38:48 <SamB_XP> @go scheme in 48 hours
20:38:50 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
20:38:50 <lambdabot> Title: Write Yourself a Scheme in 48 hours
20:38:51 <newsham> gubagem: you need "do" (or (>>=)) whenever you want to combine two or more actions into a single action
20:39:00 <ppot> Okay, but say I just want to insert a small snippet of Java code into my Haskell program.
20:39:04 <ppot> How should I go about it?
20:39:09 <SamB_XP> (where by "the name" I mean "the keyword to which you associated the URL")
20:39:11 <newsham> each clause of a case has to be a single expression.
20:39:40 <edwardk> ppot: well, to be quite honest, 'FFI' to talk to libraries like .NET or Java is a bit of a sticking point for Haskell.
20:39:42 <dolio> Mmm, inline java. Way better than assembly.
20:39:45 <sclv> Elly: FFS? does fibs, factorials, and interprets scheme!
20:39:55 <dmwit> ppot: Look at the FFI for JNI.
20:39:58 <Axioplase> ppot: How do you insert a small snippet of Haskell into your Java program?
20:40:01 <Elly> sclv: :D
20:40:03 <edwardk> ppot: There is quite the impedence mismatch between the underlying semantics of the two platforms.
20:40:12 <dmwit> ppot: Maybe by the time you get things working you'll stop this Java madness.
20:40:14 <Elly> sclv: let's call it FS! though
20:40:17 <ivanm> ppot: why would you want to though?
20:40:18 <Elly> for fib, scheme, factorial
20:40:33 <ivanm> only time you generally use an FFI is to get something like C code for performance, etc.
20:40:38 <sclv> hmm... anything else common? ackerman!
20:40:40 <ivanm> or else to get access to an external lib
20:40:41 <SamB_XP> ppot: yeah, Java datastructures would not work in Haskell programs...
20:40:44 <ppot> ivanm: Like I said, I have a blazing fast Java algorithm (technically Eiffel, but transliterable).
20:40:54 <dmwit> sclv: You forgot quicksort. ;-)
20:40:59 <sclv> well then you can translate that into haskell too ppot!
20:41:05 <Elly> "Java algorithm (technically Eiffel...)" <---
20:41:07 <ivanm> well, if you want to use it in Haskell you'd be better off translating it into Haskell
20:41:07 <SamB_XP> ppot: I think you'd have an easier time using the Eiffal code than the Java code...
20:41:08 <edwardk> ppot: then it can probably transliterate into something in the IO monad in Haskell.
20:41:09 <ppot> And it should work fine, just use a different segment of memory for the different data.
20:41:13 <newsham> ppot: if you really want to, a two step process of using JNI and FFI should do the trick
20:41:24 <sclv> FASQ!
20:41:41 <newsham> ppot: you could try to implement the algorithm in haskell
20:41:41 <ivanm> and how do you know it's "blazing fast".... is it faster than the C equivalent?
20:41:46 <Elly> sclv: AQ?
20:41:54 <sclv> ackerman, quicksort
20:42:04 <Elly> ah, okay
20:42:07 <edwardk> ppot: then from there you can figure out if you can transliterate it down to the ST monad in Haskell, eliminating that pesky 'real world' connection and you can pretend its a pure algorithm ;)
20:42:14 <gubagem> whats the average learning curve for haskell(how long does it take to become competent with), or does it differ widely
20:42:20 <Elly> FASM! might be better; mergesort is usually pretty in functional languages
20:42:26 <Elly> gubagem: depends on prior exposure to similar languages
20:42:30 <SamB_XP> gubagem: what is competency?
20:42:32 <sclv> the scheme bit makes it a bit harder to implement than HQ9+ though...
20:42:42 <ppot> ivanm: I found the original paper and it's very reliant on OO for the proven complexity bound.
20:42:49 <sclv> I guess it could reduce SK calc instead...
20:42:50 <Elly> ppot: let's see?
20:43:00 <Korollary> gubagem: the learning curve differs widely
20:43:04 <Elly> I'm curious why objects let you achieve a better complexity bound
20:43:05 <newsham> gubagem: thats a tough question.  it takes longer than with some other languages (getting better though, thanks to better tutorials and books), but its a lifelong process
20:43:11 <gubagem> prior scheme experience
20:43:15 <gubagem> lifelong
20:43:18 <newsham> ie. "what is the learning curve for learning chess"
20:43:30 <gubagem> 20 games before you have a clue
20:43:35 <dmwit> Incidentally, had anybody ever heard of the "increment an accumulator" thing as an exercise before HQ9+!?
20:43:39 <gubagem> 200 games before you have any idea
20:43:43 <Elly> dmwit: nope
20:43:45 <gubagem> 10 years and you start to get it
20:44:00 <SamB_XP> gubagem: I think
20:44:10 <gubagem> but then there is always some old guy down at chess club that can whoop you all day
20:44:10 <SamB_XP> Haskell is faster to learn than that
20:44:13 <ivanm> gubagem: nah, took me only a few years (i.e. when my younger brother started beating me :p ) to hate chess ;-)
20:44:21 <ivanm> as for "master"... never!
20:44:37 <gubagem> i switched from quake to chess, tired of 13 year old reflexes
20:44:45 <gubagem> <--still isnt very good at chess
20:45:00 <gubagem> its basically who makes a mistake first
20:45:00 <newsham> i think after a year of haskell you start to get the feel for it
20:45:04 <gubagem> oh ok
20:45:11 <sclv> I think it really depends how much you throw yourself at it, really, for haskell. You'll either get the basics and level off, or get hooked and start reading research papers. The blogosphere helps, but good mid-high-level tutorial-like things are sort of lacking.
20:45:31 <sclv> I.e., if you want to use syb, you read the paper and a bunch of code that uses it. No other way.
20:45:32 <gubagem> scheme seemed like that to me
20:45:40 <gubagem> i just learned to reinvent the wheel all by myself
20:45:45 <newsham> after 2years you figured it all out, after 3 you start to realize that you dont know that much yet, after 5 you realize that its going to take a lot longer.
20:45:47 <edwardk> sclv: thats probably it, the community kind of self-selects through that mechanism for people who aren't afraid of research papers
20:45:55 <newsham> i imagine after 10 years you'd probably realize that you'll never know it?
20:46:01 <edwardk> heh
20:46:05 <ppot> So, does Haskell have a Java/C#-style class operator?
20:46:06 <Elly> newsham: so it's like grad school? :O
20:46:07 <ivanm> of course, you get better at it if you try and write things in the language rather than writing imperative/OO code in haskell *hint, hint* :p
20:46:14 <SamB_XP> papers == the good
20:46:19 <gubagem> ppot:: there is some OOhaskell
20:46:32 <SamB_XP> silly xchat ruining my use of teh ...
20:46:37 <edwardk> ppot: there is 'class' in Haskell, but its quite different from java/c# style classes. coz classes aren't limited by tying them to the representation of your data.
20:46:37 <sclv> Working effectively with ghc-exts to the typesystem, there's lots of folklore...
20:46:38 <gubagem> is a monad a functor or a category(object)
20:46:47 <ivanm> SamB_XP: just delete it from the auto-replace list!
20:46:55 <Elly> ppot: so, do Java/C# have map?
20:47:06 <ivanm> or reduce
20:47:07 <SamB_XP> ... why is it the ONLY THING THERE?
20:47:09 <gubagem> the jvm can do it
20:47:09 <edwardk> ppot: if you REALLY want java/c# style object semantics look at OOHaskell, but its pretty much the wrong direction to go
20:47:10 <gubagem> kawa
20:47:10 <ddarius> Elly: Yes.
20:47:20 <Elly> ddarius: really?
20:47:21 <ivanm> SamB_XP: sample default to improve the english language by force! :p
20:47:26 <ddarius> Elly: Yes.
20:47:33 <Elly> ddarius: what on earth does it look like?
20:47:35 <Axioplase> gubagem: kawa is Scheme, isn't it?
20:47:36 <dmwit> Elly: There's some stupid reflection thing you can do to actually make "map" look nice.
20:47:41 <gubagem> i believe so
20:47:44 <gubagem> i havent tried it
20:47:47 <gubagem> just read about it a bit
20:47:49 <Axioplase> it is :)
20:47:50 <Elly> I wish to see this device
20:47:55 <ivanm> I thought kawa was a dodgy pseudo-IDE for java...
20:48:00 <solrize> http://developers.slashdot.org/article.pl?sid=08/05/27/1916235
20:48:01 <lambdabot> Title: Slashdot | Scalable Nonblocking Data Structures
20:48:05 <ppot> Elly: "map" just performs an operation on a bunch of data.
20:48:06 <Elly> before I knew any better I used to use Java, and I never stumbled across such a thing
20:48:08 <ddarius> Elly: foreach(Foo foo in fooEnumeration) { ... foo ... } in C# replace 'in' with : in Java.
20:48:12 <ppot> So sure, there's a map in C#.
20:48:14 <Elly> ppot: and returns the result
20:48:16 <Elly> ddarius: that is not map
20:48:21 <ivanm> ddarius: yes, but it's not reusable like map
20:48:25 <ddarius> Elly: C# also has System.Array.ForEach
20:48:38 <Elly> map (\x -> x + 1) [1, 2, 3]
20:48:40 <ivanm> ppot: so C# treats functions as first-class data?
20:48:46 <Elly> ought to return [2, 3, 4]
20:48:47 <sclv> solrize: are those the click things?
20:48:48 <gubagem> i dont see why you couldnt have map in java...oh wait functions arent first class...
20:48:49 <ddarius> ivanm: Yes.
20:48:54 <solrize> sclf yeah
20:48:57 <solrize> sclv
20:49:05 <Elly> ddarius: that is apply, though
20:49:14 <dmwit> Elly: http://functionalj.sourceforge.net/
20:49:15 <lambdabot> Title: FunctionalJ - A library for Functional Programming in Java
20:49:22 <newsham> you can pretend that functions are first class by using methods
20:49:24 * ivanm shudders at the thought
20:49:27 <ivanm> @quote kolmodin java
20:49:27 <bd_> ivanm: technically, functions aren't first class, but there's syntax sugar to pack an anonymous function into a delegate into a object, in the recent versions
20:49:27 <lambdabot> kolmodin says: I would rather lose my left arm than write it in Java
20:49:28 <newsham> or you can use scala and let it pretend for you
20:49:31 <sclv> they're really STM, he just doesn't want to admit it though. :-)
20:49:36 <edwardk> ppot: a better example would be Monad. you can't work 'backwards' from the return type' in those languages.
20:49:39 <ppot> ivanm: Yeah, a function pointer.
20:50:16 <edwardk> the closest you get is the Workflow stuff in F#.
20:50:21 <ivanm> bd_: isn't that cheating? :p
20:50:28 <gubagem> i wonder if my java teacher semester would love me going all functional on him
20:50:30 <sclv> the array-like thing for hashtables is, as far as i can tell, a very low-level equiv of an array of tvars.
20:50:39 <Elly> dmwit: Function0, Function1, Function2, Function3, Function4, FunctionN...
20:50:40 <ddarius> IEnumerable<B> Map<A,B>(Func<A,B> f, IEnumerable<A> as) { foreach(A a in as) yield return f(a); }
20:50:41 <gubagem> s/teach/ teacher next/
20:50:44 <bd_> ivanm: The implementation details don't matter :) but you do have to predeclare a name for its prototype, effectively
20:51:03 <dmwit> Elly: yup
20:51:04 * dmwit shrugs
20:51:10 <dmwit> Other than that, it looks pretty tolerable.
20:51:15 <solrize> sclv yeah i'm looking at that article now, it's just a separate lock on each array slot, yawn
20:51:25 <Elly> dmwit: having to wrap everything up into a Func object first seems pretty miserable, though, as compared to 'map f l'
20:51:31 <dmwit> When you compare it to the gymnastics you'd have to do to make your lambdas otherwise.
20:51:32 <ivanm> I know that I got pissed off when I worked on a Java project and a large part of what i was doing was effectively mapping or folding over arrays... AND I HAD TO WRITE IT OUT IN FULL EACH TIME!!!
20:51:34 <edwardk> I have a rather large library of Haskell inspired C# floating around here that I should post up some time.
20:51:40 <sclv> the trick is the hardware support for it.
20:51:55 <edwardk> Especially since now the would-be commercial venture it was for apears like it'll never get off its feet.
20:51:58 <dmwit> Elly: Better than (new Runnable() { public void run() { ... } }).
20:51:59 <newsham> ivanm: you need to cut&paste
20:52:02 <ddarius> Map<Int,Int>(x => x +1, someListOrArrayOrAnythingImplementingIEnumerable)
20:52:18 <gubagem> this functionalJ looks evil
20:52:21 <edwardk> ddarius: though to be fair the result doesn't memoize ;)
20:52:29 <Elly> ddarius: there's no way that works
20:52:31 <ivanm> didn't someone call Java the Verb language?
20:52:33 <edwardk> a second traversal retriggers all the effects
20:52:39 <Elly> ivanm: no, Java is the Noun Language
20:52:43 <ivanm> newsham: yes, I did a lot of that....
20:52:48 <ivanm> Elly: oh, wait, that's right
20:52:49 <edwardk> ivanm: its the kingdom of nouns.
20:53:01 <ivanm> that's the one
20:53:03 <sclv> java with closures will be alright tho.
20:53:05 <ivanm> who said that?
20:53:08 <dmwit> Haskell is firmly in the kingdom of the verbs.
20:53:19 <ivanm> sclv: I thought apparently it already had closures...
20:53:25 <ivanm> pseudo-closures, anyway
20:53:26 <edwardk> ivanm: thats one of the reasons why I defected to c#, you can box most of that up now with linq and 3.5
20:53:27 <Elly> I think in the original essay Lisp is the land of verbs
20:53:28 <gubagem> what kingdom is scheme?
20:53:33 <ddarius> Elly: Except that I'm not sure if Func is a standard type definition in C# 3.5 (if not then replace it with Converter), it should all be valid C# 3.0+
20:53:39 <edwardk> gubagem: the kingdom of cons ;)
20:53:40 <sclv> one explicit motivation for the closures proposal (real ones) is to get mapping
20:53:41 <ivanm> gubagem: the kingdom of the pixies?
20:53:43 <Elly> ppot: you mentioned a paper that can only achieve the desired complexity with OOP; can we see it?
20:53:48 <sclv> @go java kingdom nouns
20:53:50 <lambdabot> http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
20:53:50 <lambdabot> Title: Stevey's Blog Rants: Execution in the Kingdom of Nouns
20:53:55 <SamB_XP> what kingdom is C in?
20:54:01 <Elly> ddarius: still less pretty than map f l :)
20:54:07 <ivanm> SamB_XP: the kingdom of pain...
20:54:11 <sclv> the kingdom of the *s
20:54:14 <gubagem> C is the dude who rotoroots your castles toilets
20:54:22 <SamB_XP> heh
20:54:33 <Elly> gubagem: but we can't live without him
20:54:38 <SamB_XP> but ... castle toilets don't have plumbing
20:54:41 <Elly> I will confess to having a soft spot for C
20:54:46 <ivanm> Elly: sure we can... lisp machines! :p
20:54:46 <newsham> this channel needs more haskell.
20:54:46 <SamB_XP> they just have holes that let out past the wall
20:54:58 <gubagem> ok ill do an hpaste one sec
20:55:04 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
20:55:05 <lambdabot>  Parse error at end of input
20:55:07 <Elly> ivanm: modern machines are heavily optimized for C/fortran :(
20:55:10 <ivanm> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
20:55:12 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:55:15 <ivanm> newsham: happy?
20:55:24 <ivanm> Elly: :(
20:55:37 <SamB_XP> Elly: I'm not sure what I'd want them to do differently for functional languages...
20:55:40 <sclv> the ghc runtime is written in C!
20:55:49 <Elly> SamB_XP: look at the hardware design of lisp machines :)
20:55:53 <ivanm> sclv: all of it?
20:56:03 <SamB_XP> Elly: that's NOT what I would want them to do
20:56:07 <Elly> why not?
20:56:09 <hpaste>  gubagem pasted "whats wrong with my case(oh though caseless ammunition works better i hear)" at http://hpaste.org/7979
20:56:12 <SamB_XP> that maybe was a good idea 20 years ago
20:56:17 <sclv> erm, most key bits I think.
20:56:38 <SamB_XP> Elly: I would expect a more gradual change from the state of the art to work a lot better
20:56:46 <dmwit> gubagem: Needs more "in".
20:56:54 <dmwit> let ... in
20:57:08 <gubagem> oh i thought i could leave it out in do blocks :(
20:57:09 <TSC> gubagem: Needs an "in" (as dmwit says), or a "do" after the "then"
20:57:15 <gubagem> ohhhhhh
20:57:16 <gubagem> ok
20:57:19 <gubagem> duh ty
20:57:45 <Elly> I still don't understand the zipWith fib
20:57:48 <dmwit> Though I would prefer this:
20:57:52 <Elly> I should find out what zipWith does
20:58:07 <Elly> oh, wait
20:58:08 <dmwit> if any (not . isSpace) line ...
20:58:10 <Elly> I see what it does now
20:58:13 <Elly> oh, wow, that's amazing
20:58:18 <dmwit> gubagem: (@you)
20:58:25 <newsham> elly: see the wikipedia article on haskell
20:58:29 <newsham> it shows the evaluation of the fib
20:58:39 <dmwit> Skip the "words" calculation entirely.
20:58:53 <Elly> newsham: nah, I just looked at what zipWith does and it makes sense
20:59:07 <dmwit> Or maybe... let realChars = dropWhile isSpace line in ...
21:00:01 <newsham> gub: the "let" in the "then" isnt inside of a "do", hence the need for the "in"
21:00:31 <newsham> btw, you can put the "let" outside of the "if" if you want to
21:01:28 <newsham> also you can use "null wordz" instead of comparing with []
21:01:32 <hpaste>  dmwit annotated "whats wrong with my case(oh though caseless ammunition works better i hear)" with "cleaner way?" at http://hpaste.org/7979#a1
21:01:44 <sclv> ghc runtime: http://darcs.haskell.org/ghc/rts/ -- look! c!
21:01:45 <lambdabot> Title: Index of /ghc/rts
21:02:30 <dmwit> Okay, so there's an unnecessary "do" there.  Whatever.
21:02:51 <newsham> > do it
21:02:51 <lambdabot>   Not in scope: `it'
21:03:08 <ivanm> sclv: doesn't mean we're proud of it...
21:03:09 <ivanm> ;-)
21:03:17 <sclv> and incredible magic goto-ridden crazy brilliant c: http://darcs.haskell.org/ghc/rts/Interpreter.c
21:03:42 <ivanm> is there any reason why the RTS can't be written in haskell as well?
21:04:03 <shepheb> what would the RTS run on?
21:04:22 <sclv> shepheb: you could totally have a self-hoisting rts.
21:04:26 <newsham> the rts would be compiled to machine code, shepheb.
21:04:48 <ivanm> same as how the RTS is currently compiled to machine code...
21:05:21 <bd_> you could make some restricted variant of Haskell that can be compiled directly to machine code...
21:05:25 <SamB_XP> the part we call the "RTS" cannot be
21:05:39 <ddarius> bd_: Haskell is compiled directly to machine code.
21:05:49 <SamB_XP> however, things can be moved from there to Haskell code
21:05:53 <bd_> ddarius: I mean, without the support of a garbage collector, for example :)
21:06:04 <SamB_XP> GC is not really one of those things
21:06:06 <bd_> If your GC requires a GC to function, things won't end well.
21:06:19 <SamB_XP> it would be silly to try write the GC in Haskell, just silly
21:06:22 <sclv> right -- parallelism similarly I'd think.
21:06:23 <solrize> what's exactly the prob?  the T garbage collector is written in T
21:06:27 <ivanm> SamB_XP: why?
21:06:39 <SamB_XP> because it would be too hard to read
21:07:04 <bd_> There's a variant of smalltalk which is *completely* self-hosting, I believe...
21:07:23 <sclv> There was a famous scheme garbage collector written in scheme, but it was full of tricks to ensure that it never allocated memory while it ran...
21:07:23 <bd_> squeak, that's it
21:07:27 <SamB_XP> not Squeak! they have some C files
21:07:31 <ivanm> would it be possible to re-write the evil mangler in haskell?
21:07:36 <SamB_XP> I was gonna say that *before* you remembered
21:07:38 <solrize> sclv, there's more than one of those  T and scheme48 both do that iirc
21:07:56 <solrize> and for that matter, pypy (python written in python)
21:08:01 <SamB_XP> ivan: sure
21:08:06 <bd_> ivanm: sure, it's just a collection of evil regex hacks
21:08:07 <SamB_XP> er. ivanm
21:08:14 <SamB_XP> the evil mangler is just a filter for assembly code
21:08:17 <SamB_XP> nothing special there
21:08:32 <sclv> is pypy completely self-hoisting or does it call out to c ever?
21:08:35 <SamB_XP> but, I mean, why bother rewriting in Haskell when PERL is better at evil regex hacks?
21:08:40 <sjanssen> @keal
21:08:40 <lambdabot> doctor just give meds not fix prollem
21:09:06 <ivanm> sclv: I think it's self-hosting...
21:09:09 <sclv> the mangler has broken in the past when gcc changed the whitespace in its output.
21:09:22 <sclv> much better to do it without regex hacks at all.
21:09:30 <sjanssen> SamB_XP: it would reduce external dependencies
21:09:46 <SamB_XP> doubt it
21:09:50 <sjanssen> this isn't a big deal on your average Unix, but it helps Windows
21:09:55 <hpaste>  gubagem pasted "I just want itemList to be a nice [Item] not IO ([Item])" at http://hpaste.org/7980
21:10:08 <ddarius> sclv: Much better not to need it in the first place.
21:10:09 <sjanssen> SamB_XP: GHC on Windows has to distribute perl
21:10:17 <SamB_XP> sjanssen: how much space does that even take?
21:10:25 <sjanssen> probably not much
21:10:47 <sclv> ddarius: but if you want the ability to bootstrap ghc onto new platforms, a C backend seems important to keep around...
21:11:13 <SamB_XP> sclv: I think the idea is to have a C backend that needs not the evil mangler
21:11:18 <SamB_XP> i.e. is unregisterized
21:11:40 * gubagem wonders if he posted tooo much coooooode 
21:11:41 <sclv> via cmm the whole way then?
21:11:54 <newsham> gub: you cant escape the IO
21:11:57 <newsham> you are trapped forever
21:12:04 <gubagem> seriously?
21:12:16 <ddarius> sclv: I believe unregistered builds already don't use/need the evil mangler.
21:12:28 <newsham> can you explain why you want [Item]?
21:12:37 <sclv> ddarius: wao!
21:12:44 <sjanssen> sclv: there would be two paths, what we currently call -fasm, and a C backend only used for compatibility with archictectures that GHC doesn't have a native code gen for
21:12:51 <gubagem> thats my idea of passing it around from function to function, its my state
21:12:58 <ivanm> with -fasm, do you still need the mangler?
21:13:04 <sjanssen> no
21:13:13 <newsham> gubagem: from within your IO code you can call functions with the [Item]
21:13:21 <gubagem> i read off disk, perform userinput operations on it, then save to disk
21:13:26 <dmwit> gubagem: Passing it around is a fine first way of dealing with this.
21:13:26 <newsham> but your IO code can never return the [Item] without it being IO
21:13:29 <SamB_XP> presumably, the C backend would need the compiler to properly implement tail calls?
21:13:49 <bd_> SamB_XP: you could fake it with goto, if it doesn't
21:13:53 <dmwit> gubagem: Incidentally, did you see my annotation of your previous paste?
21:14:00 <gubagem> annotations whaaaaaaaat
21:14:06 <dmwit> http://hpaste.org/7979#a1
21:14:36 <dmwit> Now, with 40% fewer lines! =)
21:14:53 <SamB_XP> bd_: not terribly well
21:14:59 <dmwit> 30% if you don't count gratuitous do-notation-elimination.
21:15:20 <newsham> ?type mapM_   -- gubagem
21:15:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:15:28 <bd_> SamB_XP: why not? this is generated code, we're allowed to be ugly and evil :)
21:15:33 <newsham> > mapM_ print "this is a test"
21:15:35 <lambdabot>  <IO ()>
21:15:35 <sclv> ddarius: I though the mangler was needed to clean the callstack stuff? or do unregistered builds just live with that?
21:15:49 <bd_> just stick a f434532_top: label at the start, then change your parameters and goto it to do a tailcall
21:15:55 <bd_> or wait
21:16:01 <SamB_XP> bd_: well, I think that only works if you generate everything in one go
21:16:02 <bd_> that's self-recursion only, nevermind >_>
21:16:06 <dmwit> gubagem: newsham is saying imap = mapM_
21:16:23 <gubagem> i just wanted foreach out of scheme
21:16:26 <ddarius> sclv: No, they just handle it in a different (less efficient) way.
21:16:32 <gubagem> and then it gave me a monad
21:16:40 <dmwit> map/mapM/mapM_ are foreach
21:17:07 <gubagem> i gotta get to sleep
21:17:13 <bd_> SamB_XP: hmm, you could do something like chicken scheme does, with a continuation-based architecture. They let the stack be their gen-0 allocation pool; when it gets too big, they enter the GC, which copies everything out, then longjmps back to a trampoline, which resumes execution. Not sure how well that'd work with GHC though.
21:17:29 <dmwit> gubagem: Are you doing code kata?
21:17:41 <SamB_XP> bd_: I did jokingly refer to that technique the other day
21:17:47 <gubagem> huh meaning? im rewriting things i know from other languages in haskell
21:17:58 <dmwit> http://codekata.pragprog.com/2007/01/code_kata_one_s.html
21:17:59 <lambdabot> Title: CodeKata: Code Kata One - Supermarket Pricing
21:18:04 <TomMD> What is the best tutorial for FFI?  After some playing at it I find my current knowledge insufficient.
21:18:12 <SamB_XP> after someone expressed disgust at my mention of tramolines, I mumbled something about the empire state building...
21:18:17 <dmwit> gubagem: It just looked like you were playing with that code kata, and I was curious.
21:18:54 <ddarius> @where ffi
21:18:54 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:19:15 <gubagem> it was my last project after a semester of java
21:19:34 <gubagem> are these katas any good?
21:19:48 <dmwit> Dunno, never did any.
21:19:52 <dmwit> My attention span is too short. =P
21:20:51 <gubagem> get some provigil
21:21:08 <solrize> those katas are maybe ok for total programming beginners
21:21:16 <solrize> for something a little meatier you might try the euler problem list
21:21:24 <gubagem> its farther then my formal cs education has been
21:21:32 <gubagem> but ive done binary trees in scheme
21:21:46 <dmwit> solrize: I actually think the kata are meatier than the PE ones.
21:21:59 <dmwit> solrize: PE is basically math, the kata are about real-world programming in messy situations.
21:22:07 <dmwit> (Math is rarely "messy" in the way I mean here.)
21:22:11 <solrize> ic
21:22:25 <solrize> but the katas aren't really that messy
21:22:30 <dmwit> Hmm.
21:22:35 <dmwit> Which ones did you look at?
21:22:42 <solrize> the first few and then a few random ones
21:22:48 <solrize> looking at 11 right now
21:23:01 <dmwit> I thought the Supermarket one was real messy.
21:23:04 <solrize> Given the text:
21:23:04 <solrize>   When not studying nuclear physics, Bambi likes to play
21:23:04 <solrize>   beach volleyball.
21:23:04 <solrize> our program would return:
21:23:04 <solrize>   aaaaabbbbcccdeeeeeghhhiiiiklllllllmnnnnooopprsssstttuuvwyyyy
21:23:14 <solrize> the supermarket one was just a thought exercise with no coding
21:23:36 <solrize> > let a="When not studying nuclear physics, Bambi likes to play beach volleyball" in sort a
21:23:36 <gubagem> night
21:23:37 <lambdabot>  "          ,BWaaaaabbbcccdeeeeeghhhiiiiklllllllmnnnnooopprsssstttuuvyyyy"
21:23:51 <solrize> :t lowercase
21:23:52 <lambdabot> Not in scope: `lowercase'
21:23:55 <solrize> :t tolower
21:23:57 <lambdabot> Not in scope: `tolower'
21:24:01 <solrize> :t toLower
21:24:03 <lambdabot> Char -> Char
21:24:05 <dmwit> > filter isAlpha . map toLower . sort "blah blah, blah"
21:24:06 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
21:24:14 <dmwit> > filter isAlpha . map toLower . sort $ "blah blah, blah"
21:24:15 <lambdabot>  "aaabbbhhhlll"
21:24:20 <solrize> > let a="When not studying nuclear physics, Bambi likes to play beach volleyball" in sort $ map toLower a
21:24:21 <lambdabot>  "          ,aaaaabbbbcccdeeeeeghhhiiiiklllllllmnnnnooopprsssstttuuvwyyyy"
21:24:38 <dmwit> solrize: Gotta filter, probably, to meet his requirements.
21:24:43 <solrize> yeah
21:25:18 <dmwit> But: "cheaply, and without using built-in libraries"
21:25:22 <solrize> > let a="When not studying nuclear physics, Bambi likes to play beach volleyball" in sort [toLower c | c<-a, isAlpha c]
21:25:23 <lambdabot>  "aaaaabbbbcccdeeeeeghhhiiiiklllllllmnnnnooopprsssstttuuvwyyyy"
21:25:39 <dmwit> He probably means counting-sort.
21:25:42 <solrize> oh ic
21:25:59 <solrize> but in haskell that probably calls for a built-in lib like intmap ;)
21:26:16 <dmwit> Which, incidentally, is pretty nice in Haskell.
21:26:25 <dmwit> http://hpaste.org/7462
21:27:05 <solrize> that looks sorta horrendous, copying that array around for every input char?
21:27:11 <dmwit> It can even be "cheap" (in his sense of the word) if you modify that to require bounds.
21:27:17 <dmwit> what?
21:27:23 <solrize> bounds?
21:27:24 <dmwit> I don't think so.
21:27:40 <solrize> :t accumArray
21:27:40 <dmwit> I'm pretty sure the "accumArray" function is smarter than that.
21:27:41 <hpaste>  travisbrady pasted "RLE advice" at http://hpaste.org/7981
21:27:42 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
21:28:02 <dmwit> solrize: bounds, as in, not using (minBound, maxBound) as the array bounds.
21:28:06 <travisbrady_> i'm looking for efficiency/style advice for the hpaste above
21:28:22 <dmwit> That looks terrible.
21:28:25 <dmwit> I think you can do much better. =)
21:28:31 <dolio> concat . uncurry (flip replicate) . map (second chr) . toList . fromListWith (+) . map (\x -> (ord x,1))
21:28:37 <solrize> > maxBound
21:28:38 <lambdabot>  ()
21:28:41 <dmwit> travisbrady_: Have a look at scanl and group.
21:28:52 <dmwit> Well, groupBy in your case.
21:28:59 <travisbrady_> dmwit: i actually previously used groupBy with a custom thing
21:29:21 <travisbrady_> but after reading some of dons's bloggings lately i'd thought maybe a recursive version of this type was appropriate
21:29:30 <dmwit> (You might not even need scanl, just groupBy and foldr.)
21:29:36 <dmwit> travisbrady_: Oh, really, why?
21:29:43 <travisbrady_> i thought maybe this would save a list traversal or something
21:29:46 <dmwit> Oh, for CPS?
21:29:48 <travisbrady_> i also just wanted to try writing it this way
21:30:10 <travisbrady_> no, some of what was written about computing a mean
21:30:50 <ddarius> travisbrady: Your code is jacked up as well as gratuitously ugly.
21:30:52 <dmwit> I don't think you'll get better fusion on vanilla lists than what groupBy/foldr can give you.
21:31:30 <solrize> it looks like accumarray uses iarrays so that thing will copy the array around each time?
21:32:04 <sjanssen> @type accumArray
21:32:05 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
21:32:14 <sjanssen> solrize: no
21:32:37 <sjanssen> internally it creates a mutable array, performs all the updates, then "freezes" that array into an immutable one
21:32:43 <travisbrady_> ddarius: haha, ok, fair enough
21:32:51 <solrize> oh i see, that makes sense
21:33:02 <travisbrady_> ddarius: care to annotate?
21:33:27 <dmwit> :t foldr
21:33:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:34:17 <ddarius> travisbrady: Without changing the approach, using the coding conventions of the libraries would be nice.  Further your case is equivalent to an if and that is equivalent to a guard.
21:34:46 <dmwit> > foldr (\es (acc, rs) -> (acc + length es, (acc, length es, head es):rs)) (0, []) . group $ [1,1,1,2,1]
21:34:47 <lambdabot>  (5,[(2,3,1),(1,1,2),(0,1,1)])
21:35:01 <hpaste>  travisbrady annotated "RLE advice" with "RLE with groupBy" at http://hpaste.org/7981#a1
21:35:51 <travisbrady_> ddarius: when case is equivalent to an if is it preferred?  in erlang-land if is sort of frowned upon
21:36:21 <dmwit> guards are my preferred if
21:36:42 <ddarius> guards and pattern matching are preferred to if and case.
21:37:34 <dmwit> guards and functions?
21:37:40 <dmwit> case uses pattern matching
21:37:59 <dolio> case does guards, too.
21:38:01 <ddarius> dmwit: By 'pattern matching', I mean multiple clauses of a function.
21:38:06 <dmwit> right
21:38:35 <solrize> > case 'a' of {'a'->1; 'b'->2}
21:38:36 <lambdabot>  1
21:39:16 <solrize> \x -> {x=='a' | 1; x=='b' | 2} $ 'a'
21:39:20 <solrize> > \x -> {x=='a' | 1; x=='b' | 2} $ 'a'
21:39:20 <lambdabot>  Parse error at "{x=='..." (column 7)
21:39:23 <solrize> ehh
21:40:02 <ddarius> solrize: What do you think that means?
21:40:40 <solrize> > let { f 'a' ==1; f 'b' == 2} in f 1
21:40:40 <lambdabot>  Parse error at ";" (column 16)
21:40:44 <dolio> Clearly he's longing for the pattern calculus proposal submitted for H' long ago.
21:41:14 <solrize> > let { f 'a' =1; f 'b' = 2} in f 1   --oops
21:41:15 <lambdabot>   add an instance declaration for (Num Char)
21:41:31 <solrize> > let { f 'a' =1; f 'b' = 2} in f 'a'   --oops
21:41:33 <lambdabot>  1
21:41:36 <solrize> there :)
21:45:56 <shapr> @seen shapr
21:45:56 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
21:45:59 <shapr> hmm
21:46:51 <int-e> > (\x -> let f | x == 'a' = 1 | x == 'b' = 2 in f) 'a'
21:46:52 <lambdabot>  1
21:56:43 <andyjgill> Does anyone have some advice about profiling the thread interaction of Haskell code?
21:57:00 <bos> as in, contention for MVars and the like?
21:57:21 <andyjgill> Hi bos!
21:57:30 <bos> hi andyjgill !
21:57:34 <andyjgill> yes, I think I have starvation.
21:57:34 <nolrai_> :t (***)
21:57:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:57:50 <andyjgill> (slash) race condition.
21:58:11 <bos> i take it -sstderr isn't telling you anything useful.
21:58:27 <bos> (because it almost never does.)
21:58:29 <nolrai_> :t ((+1)***(+1))
21:58:31 <lambdabot> forall b b'. (Num b', Num b) => (b, b') -> (b, b')
21:58:50 <andyjgill> I've not tried that. Does it give info about thread changes?
21:58:56 <nolrai_> :t join
21:58:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:59:10 <nolrai_> :t (&&&)
21:59:12 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
21:59:13 <bos> not really.
21:59:28 <bos> it just tells you how much time each one spent allocating or in the GC.
21:59:36 <nolrai_> :t join (***)
21:59:38 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
22:00:00 <bos> otherwise, you'll have to instrument MVars yourself, i'm afraid.
22:00:04 <andyjgill> That will not heap.
22:00:14 <Cale> > runCont (do t <- mapCont not (return 0); return (t < 0)) id
22:00:16 <lambdabot>  True
22:00:18 <andyjgill> I was wondering about doing that, for all the IO actions that are relevent.
22:00:19 <Cale> > runCont (do t <- mapCont not (return 0); return (t > 0)) id
22:00:20 <lambdabot>  True
22:00:29 <Cale> > runCont (do t <- mapCont not (return 0); return (t > 0, t < 0)) id
22:00:30 <lambdabot>  Couldn't match expected type `Bool'
22:00:41 <Cale> > runCont (do t <- mapCont not (return 0); return (t > 0 && t < 0)) id
22:00:42 <lambdabot>  True
22:00:49 <bos> andyjgill: there are a few hidden ones you won't be able to get at without hacking on the RTS itself.
22:01:12 <bos> but you're probably not starving on contention for a Handle, would be my guess.
22:01:22 <andyjgill> I know; I hacked on the tracer for hpc, and had the facility I want to use now.
22:01:29 <bos> heh.
22:02:21 <Cale> ^^ Example of how it's not safe to think of bound values in a monad as being any one value of the specified type.
22:03:22 <Saizan_> Cale: nice, i thougt continuations could screw that assumption :)
22:03:51 <bos> right now, if you have a serious concurrent haskell program and need to debug concurrency problems, you're probably a bit worse off than you would be in C.  if you're using STM, you're totally doomed.
22:03:55 <Saizan_> ?ty mapCont
22:03:57 <lambdabot> forall r a. (r -> r) -> Cont r a -> Cont r a
22:04:21 <Cale> bos: Why is that? At least STM has a nice semantics you can follow.
22:04:40 <SamB_XP> because STM doesn't have a debugger?
22:04:49 <Cale> What's a "debugger"? :)
22:04:57 <bos> Cale: it has nice semantics, but if a thread gets starved, you'll have a devil of a time figuring out why.
22:05:27 <SamB_XP> well, I'm thinking it would tell you what a thread was waiting for, or why a transaction had to be restarted...
22:05:40 <Cale> bos: That is quite possibly true. It would be nice if GHC did more to ensure that threads are scheduled intelligently.
22:05:42 <bos> the correctness properties of STM are gorgeous, but if you have high contention, it doesn't currently perform well.
22:05:50 <Cale> (with regard to completing transactions)
22:05:58 <SamB_XP> Cale: things like that
22:06:03 <SamB_XP> not single stepping!
22:06:06 <SamB_XP> that would be silly
22:06:12 <bos> Cale: in the STM case, it's probably impossible to create a fair schedule.  this is an open research problem.
22:06:47 <bos> actually, more like a yawning research maw.
22:07:02 <Cale> There have been papers about how to schedule STM transactions. Apparently a sort of exponential backoff with weights applied to computations based on how long they've been running works very well.
22:11:16 <kiris> hehe, some code I wrote got someone interested in Haskell ( http://github.com/chrisdone/cllc/tree/master/BuildContents.hs ) because he thought it was damn short. reminds me of when I first saw real Haskell code in the wild, I was like "wow that's concise!" and decided to learn it :-)
22:11:17 <lambdabot> Title: BuildContents.hs at master from chrisdone's cllc &mdash; GitHub
22:11:18 <Heffalump> why is the situation any worse than with locks, btw?
22:12:44 <nolrai_> :t round
22:12:45 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
22:13:09 <bos> Heffalump: because a lock is a simple, static thing that you can instrument and fiddle with.  a transaction is the sum of everything that happens within its bounds.
22:13:19 <int-e> Because with locks you generally don't throw away any work? (that's the naive view, assuming that you take all the locks that you need before you start working. this is not always possible.)
22:13:33 <kiris> locks don't compose
22:14:00 <Pseudonym> Transactions _can_ compose.
22:14:06 <Pseudonym> Locks are primitives.
22:14:13 <Pseudonym> Transactions are concepts.
22:15:06 <Pseudonym> Like how a machine register is just a bundle of bits, but an integer is a concept.
22:16:26 <eek> I'd tend to say a lock is a concept, too - I have implemented locks at least ten different ways, probably more
22:16:54 <eek> a primitive concept, though ;)
22:17:22 <orbitz> is tehre an abstract way to define somethign as composable or not?
22:19:30 <wolgo> @src filter
22:19:31 <lambdabot> filter _ []     = []
22:19:31 <lambdabot> filter p (x:xs)
22:19:31 <lambdabot>     | p x       = x : filter p xs
22:19:31 <lambdabot>     | otherwise = filter p xs
22:19:38 <luqui> orbitz, what do you mean?
22:20:53 <orbitz> well locks are not composible, transactions are.  what is the dfiference there? and can we take that difference and use it to decide if anything is composible?
22:21:22 <Heffalump> orbitz: code with locks doesn't compose well because when you try, you can behaviour that isn't just the "sum" (in some sense) of the behaviour of the two parts
22:21:56 <luqui> but I don't think there is a mathematical way to define "composable" to correspond to what we mean when we use that word
22:22:10 <luqui> it kind of depends on the situation :-)
22:22:13 <Heffalump> in that sense you can view compositionality as being a homomorphism on semantics - f(x+y) = f(x) * f(y) where x and y is code, + is combination of code, and * is combination of semantics
22:22:13 <orbitz> what luqui said is wha ti was goign for
22:22:41 <orbitz> basicaly i would say i'm asking: if we have some operator x, and we know the properti esof th eoperator, can we say if it is composible or not?
22:26:31 <sjanssen> given two valid things, can they be these things be combined to create another valid thing
22:26:46 <sjanssen> s/they be//
22:27:25 <sjanssen> given two valid lock-using programs, can these be combined to create another valid thing?  The answer is frequently no
22:32:45 <mxc> can you put nonpure code inside a pure function, as long as you throw away the result?  code compiles, but it seems like the putStrLn isn't executed:
22:32:49 <Heffalump> so valid is an example of an 'f' in my equation above, with * = &&
22:32:58 <mxc> f :: Int -> Int
22:32:58 <mxc> f x = putStrLn ("sdfsd") `seq` (x + 2)
22:33:05 <Heffalump> mxc: you have to throw away the side effect too
22:33:09 <eek> sjanssen, isn't this only a problem when they rely on the same locks?  and doesn't relying on any shared resource really lead to the same problem?  or am I forgetting some cases I should think of?
22:33:12 <Heffalump> which makes it a little pointless
22:33:13 <bos> mxc: that code doesn't do what you think it does.
22:33:27 <mxc> so basically, the 'side effect' never makes it out of the sec and wont print
22:33:49 <Heffalump> eek: take a look at the "bank account" problem usually quoted to justify STM
22:33:54 <roconnor> IO commands can only be executed by main
22:33:59 <roconnor> ... and unsafePerformIO
22:34:22 <roconnor> otherwise the commands are simply "normalized"
22:34:30 <roconnor> which in this case, does nothing.
22:34:40 <roconnor> because IO is essentially a function
22:34:42 <roconnor> @src IO
22:34:43 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:34:47 <mxc> so that code is basically equivalent to f x = () `seq` x + 2 which is the same as f x = x + 2
22:35:02 <roconnor> I believe so
22:35:23 <orbitz> :t seq
22:35:24 <lambdabot> forall a t. a -> t -> t
22:35:41 <orbitz> > 'a' `seq' 3
22:35:42 <lambdabot>  Parse error at "3" (column 11)
22:35:45 <eek> Heffalump, relying on any shared resource in the absence of transactions, then.  actually, what I was thinking of when saying "shared resource" was really "shared variable" - locks leads to the same interaction problems as sharing other variables
22:35:48 <orbitz> > 'a' `seq` 3
22:35:50 <lambdabot>  3
22:36:11 * Heffalump has to go
22:36:33 <Heffalump> the basic point is that locks don't work inside transactions
22:36:36 <mxc> so how does trace work?
22:36:39 <roconnor> mxc: if you are trying to debug, you can use Debug.Trace.trace
22:36:40 <mxc> @src trace
22:36:40 <lambdabot> trace string expr = unsafePerformIO $ do
22:36:40 <lambdabot>     hPutStrLn stderr string
22:36:40 <lambdabot>     return expr
22:36:45 <mxc> right, thats what I use
22:36:46 <Heffalump> it cheats
22:36:49 <mxc> oh
22:37:06 <roconnor> IO commands can only be executed by main and unsafePerformIO
22:37:23 <orbitz> you probably wan tto avoid something that is unsafe right?
22:37:32 <mxc> yeah
22:37:43 <mxc> although, debug.trace is 'safe enough' for debuggin
22:37:47 <mxc> debugging
22:37:53 <nolrai_> Im geting an "unknown symbol `base_GHCziIO_zdwa13_info'" error when i try to run my main in ghci, this feels vaugely fimiliar, anyone know whats going on?
22:38:00 <bd_> roconnor: or unsafeStToIO
22:38:15 <bd_> @hoogle IO a -> ST e a
22:38:15 <roconnor> @src unsafeStToIO
22:38:15 <lambdabot> Source not found. My brain just exploded
22:38:17 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
22:38:17 <lambdabot> Control.Monad.ST.Lazy.unsafeIOToST :: IO a -> ST s a
22:38:19 <bd_> er
22:38:24 <bd_> unsafeIOToST rather :)
22:38:27 <bd_> @src unsafeIOToST
22:38:28 <lambdabot> unsafeIOToST (IO io) = ST $ \ s -> (unsafeCoerce# io) s
22:38:34 <mxc> nolrai_ try cleaning everything out, deleting the .o and .hi files
22:38:38 <mxc> seems like a linker problem
22:38:42 <bd_> wow, that's even more unsafe than I thought
22:40:44 <roconnor> @src ST
22:40:44 <lambdabot> newtype ST s a = ST (STRep s a)
22:40:54 <roconnor> @src STRep
22:40:54 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
22:41:06 <roconnor> @src runST
22:41:06 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
22:41:22 <roconnor> @src runSTRep
22:41:22 <lambdabot> runSTRep st_rep = case st_rep realWorld# of (# _, r #) -> r
22:41:35 <roconnor> ah
22:41:41 <roconnor> they just make up a realWorld
22:41:50 <roconnor> GHC scares me
22:41:56 <Cale> Where was the article that documented the steps taken over the years to make lambdabot's eval safe?
22:42:32 <Cale> ah, http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
22:42:33 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/2orccu
22:42:34 <nolrai_> why would it be look at "/usr/lib/haskell-packages/ghc6/lib/gtk-0.9.12.1/HSgtk.o:" when loading package array-0.1.0.0?
22:43:05 <roconnor> Why is the definition of ST so indirect?
22:43:23 <roconnor> oh
22:43:26 <roconnor> one is a type
22:43:30 <roconnor> I guess that is fine
22:52:15 <Enzo_> Hello, I am trying to gather up ideas on how to simplify and show a function of the type Expr. For example: Add (Mul (Num 2.0) (Var "x")) (Var "x") -> "3x". Does anyone have any suggestions? Here is a screen shot of what I'm working on: http://s28.photobucket.com/albums/c217/haussecker/?action=view&current=Wronskian-1.jpg (zoom in to fix the resolution).
22:52:17 <lambdabot> Title: Wronskian-1.jpg - Image - Photobucket - Video and Image Hosting, http://tinyurl.com/6syy3t
22:52:30 <orzo> c==34 || 40==c || c==41 || c==44 || c==47 || 58<=c && c<=64 || 91<=c || c<=93
22:52:48 <orzo> in that expression, i am testing single characters or using the && operator to test a range
22:53:02 <orzo> does && have higher precedence than || like i expect?
22:53:31 <orzo> > True
22:53:32 <lambdabot>  True
22:53:41 <psygnisfive> hey
22:53:49 <psygnisfive> im curious how haskell would solve this:
22:54:08 <psygnisfive> how would you generate a list of all pairwise combinations of items in A with items in B
22:54:21 <psygnisfive> ?
22:54:23 <dons> ah, quite nicely.
22:54:25 <bos> Enzo_: that's easy to do.
22:54:27 <thetallguy> psygnisfive: homework?
22:54:29 <psygnisfive> nah
22:54:37 <Zao> > [(a,b) | a <- [1..4], b <- [5..7]]
22:54:38 <lambdabot>  [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7),(4,5),(4,6),(4,7)]
22:54:42 <psygnisfive> im just curious, because i have ideas for a language that i want to mess with
22:54:52 <mauke> > liftM2 (,) [1..4] [5..7]
22:54:53 <lambdabot>  [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7),(4,5),(4,6),(4,7)]
22:55:00 <psygnisfive> ah thats neat.
22:55:02 <dons> mauke is a showoff
22:55:19 <thetallguy> the form Zao showed you is called a list comprehension, designed to look like ordinary set notation
22:55:45 <psygnisfive> yeah.
22:55:56 <mauke> > (,) <$> [1..4] <*> [5..7]
22:55:59 <lambdabot>  [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7),(4,5),(4,6),(4,7)]
22:56:08 <psygnisfive> i hadnt thought of that. hm.
22:56:19 <dons> there must be an arrow wrapper for the explict (,)
22:56:22 <mauke> > (,,) <$> [1..4] <*> [5..7] <*> "xy"
22:56:24 <lambdabot>  [(1,5,'x'),(1,5,'y'),(1,6,'x'),(1,6,'y'),(1,7,'x'),(1,7,'y'),(2,5,'x'),(2,5,...
22:56:43 <ivanm> dons: _now_ he's showing off ;-)
22:56:58 <Enzo_> bos, do you know of an article which explains that
22:57:34 <bos> Enzo_: it's just a bunch of pattern matching.
22:57:39 <thetallguy> > sequence [[1,2],[11,12],[21,22]]
22:57:40 <lambdabot>  [[1,11,21],[1,11,22],[1,12,21],[1,12,22],[2,11,21],[2,11,22],[2,12,21],[2,12...
22:58:00 <psygnisfive> hm.
22:58:28 <thetallguy> the List monad is lurking behind many of these
22:58:59 <Saizan_> Enzo_: it's similar to writing a simple eval function, you recurse on the subterms and apply the needed transformation based on the current constructor
22:59:45 * bos ponders when to stop parallel recursion in a parallel recursive quicksort.
22:59:55 <Enzo_> bos, ugh ..thats going to be a lot of pattern matching =[, I was hoping for some revers parsing method
23:00:13 <Enzo_> *reverse
23:00:27 <thetallguy> bos: how long should a man's legs be?
23:00:40 <psygnisfive> long enough to reach the ground! *rimshot*
23:00:41 <Saizan_> Enzo_: i think you first want to reduce the expression to a convenient normal form, and only then convert it to a string
23:02:16 <Enzo_> Saizan,   Thanks, I think that's how I'm going to do it
23:02:33 <bos> it's tricky to decide when to switch to a serial sort if you're sorting a list, because you don't know how long any given sublist is.
23:02:52 <bos> at least, not at a time useful enough to influence the decision.
23:03:06 <psygnisfive> tallguy: i originally asked because im considering playing with the idea of quantified expressions
23:03:18 <psygnisfive> where like
23:03:25 <psygnisfive> pair x y = (x,y)
23:04:04 <psygnisfive> pair (each x) (each y) == [(x,y) | x <- [1..3], y <- [7..9]]
23:04:29 <psygnisfive> and yet the definition of pair is like that, where it looks only at individual cases
23:04:35 <psygnisfive> and the interpreted handles quantification
23:05:36 <Saizan_> psygnisfive: that's almost like the list monad in haskell
23:05:47 <psygnisfive> er, that should've been: pair (each [1..3]) (each 7..9]) but you get the idea
23:05:49 <psygnisfive> :P
23:06:00 <psygnisfive> is it? i dont get monads, to be honest.
23:06:14 <thetallguy> bos: I was thinking about that recently for another problem.  Take the length of the list when you start and stop at say sqrt of len?
23:06:15 <psygnisfive> not that i dont get the point of them, but that i just dont grasp them at all.
23:06:40 <psygnisfive> i just like the idea of being able to define things in terms of individual cases, and let the quantified situations be handled by the interpreter
23:07:03 <Saizan_> > let pair x y = (x,y) in do x <- [1..3]; y <- [7..9]; return $ pair x y
23:07:04 <lambdabot>  [(1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9)]
23:07:55 <bos> thetallguy: something like that might work.  the only alternative is to see if a sublist is at least N elements long.
23:07:57 <psygnisfive> o_x
23:08:00 <thetallguy> psygnisfive: they take time, but the list monad is pretty much what you're talking about.
23:08:03 <psygnisfive> i dont like the way tht looks at all.
23:08:53 <thetallguy> bos: I suppose you could measure where the returns diminish, but you still have to look at the size of the list all the time
23:09:01 <bos> thetallguy: exactly.
23:09:25 <thetallguy> bos: unless you make a list of 'repeat 30 []'
23:09:43 <psygnisfive> but i withdraw now. that idea of quantifiers wasnt about haskell, i just was curious how haskell achieved the same thing. :)
23:10:07 <thetallguy> sorry, 'repeat (sqrt len) []'
23:10:10 <psygnisfive> arigatou
23:10:18 <thetallguy> and then stop when you hit the end of the list
23:12:08 <thetallguy> so this list has length == depth of recursion
23:12:42 <thetallguy> You know what sucks?  Posting to planet haskell from the last timezone on the planet
23:13:47 <smtms> thetallguy, why does it suck?
23:13:59 <thetallguy> because they are sorted by localtime, not UTC
23:15:09 <thetallguy> Ah well, life is hard.
23:15:18 <psygnisfive> thetallguy: atleast you dont have to go far to get sorted to the top, ey?
23:15:23 <psygnisfive> just one time zone over!
23:15:23 <psygnisfive> :)
23:15:36 <psygnisfive> where are you, hawaii?
23:15:38 <thetallguy> big swim
23:15:42 <thetallguy> San Diego
23:15:51 <psygnisfive> well thats not the LAST time zone. lol
23:16:00 <thetallguy> But I don't know of any haskellers in Hawaii
23:16:00 <psygnisfive> alaskan haskellians have it worse
23:16:13 <thetallguy> don't know of any there, either
23:16:18 <psygnisfive> oh there must be some in hawaii
23:16:36 <thetallguy> haskellers, maybe, but not bloggers.
23:18:30 <thetallguy> but as troubles go, this is pretty far down the list ;-)
23:20:48 <psygnisfive> change your system time ;)
23:21:04 <thetallguy> I use blogspot.
23:21:05 <vixey> Enzo_: Did you get it ?
23:21:12 <psygnisfive> ahh ok.
23:21:17 <thetallguy> I suppose I could lie about my time zone to it.
23:21:27 <psygnisfive> doesn't blogger let you specify time?
23:21:29 <psygnisfive> i think it does
23:22:00 <psygnisfive> yeah man
23:22:06 <psygnisfive> blogger lets you specify date and time
23:22:25 <psygnisfive> you could post it in the distant distant future and always be the most recent ;)
23:23:10 <psygnisfive> but you need crazy special effects since you're posting from the fuuuuuuutuuuuuuure 0.0
23:23:28 <eek> psygnisfive, the new version of blogger won't publish until the timestamp you put on the post
23:23:44 <psygnisfive> oh. nevermind :P
23:23:49 <eek> psygnisfive, though I think you can edit an already published entry and put it in the future
23:23:56 <psygnisfive> AHA!
23:24:09 <psygnisfive> time travelers win!
23:24:15 <psygnisfive> bye :P
23:24:59 <newsham> [20:12] < thetallguy> But I don't know of any haskellers in Hawaii
23:25:02 <newsham> <--
23:26:04 <Enzo_> vixey, I actually took a break to do some diff eq homework, but do you know of any relevant wiki pages?
23:26:24 <thetallguy> D'oh!
23:26:50 <vixey> Enzo_: I wrote this in Prolog for someone the other day adn I thought it would be interesting to compare
23:27:22 <vixey> Enzo_: (if you like it's here http://pipapo.org/prologwiki/PasteBin/Simplify but I'm not sure this would be the best approach in Haskell)
23:27:24 <lambdabot> Title: PasteBin/Simplify - Prolog Wiki
23:27:54 <vixey> Enzo_: but really I think the biggest problem of all is that "simplify" doesn't have a very clear meaning
23:29:06 <Enzo_> vixey, I need combining like terms, trig substitutions, etc.
23:29:48 <vixey> trig substitutions? like sin^x + cos^x -> 1 ?
23:29:51 <vixey> oops
23:30:00 <vixey> sin^2(x) + cos^2(x) -> 1
23:30:06 <ivanm> lol
23:30:47 <luqui> mathematica's FullSimplify is the result of many many years of research
23:30:50 <newsham> ?check \x -> sin(x)**2 + cos(x)**2 == 1.0
23:30:50 <Enzo_> yes, I guess I'll have to define that through pattern matching
23:30:52 <lambdabot>  Falsifiable, after 0 tests: -1.3333333333333333
23:31:01 <ivanm> > \let sinx x y -> (sin y)^x; sin2 = sinx 2; sin2 y
23:31:01 <lambdabot>  Parse error at "let" (column 2)
23:31:05 <vixey> Enzo_: I don't think pattern matching is the right way
23:31:10 <ivanm> > let \sinx x y -> (sin y)^x; sin2 = sinx 2; sin2 y
23:31:11 <lambdabot>  Parse error at "\sinx" (column 5)
23:31:19 <vixey> for example what if you have sin^2(x) + 3 + cos^2(x)
23:31:21 <ivanm> > let sinx x y = (sin y)^x; sin2 = sinx 2; sin2 y
23:31:22 <lambdabot>  Parse error at end of input
23:31:23 <newsham> ?check \x -> (sin x)**2 + (cos x)**2 == 1.0
23:31:23 <luqui> you might try a rewrite engine
23:31:25 <lambdabot>  Falsifiable, after 2 tests: 1.0
23:31:28 <ivanm> > let sinx x y = (sin y)^x; sin2 = sinx 2 in sin2 y
23:31:29 <lambdabot>  sin y * sin y
23:31:36 <luqui> which just rewrites things based on laws and searches for the smallest form according to some metric
23:31:39 <ivanm> ^^ that's what I meant
23:31:43 <luqui> and terminates after a given number of tries
23:32:10 <newsham> > (\x -> (sin x)**2 + (cos x)**2) 1.0
23:32:11 <lambdabot>  1.0
23:32:22 <Pseudonym> The Risch structure theorem, IIRC, is the theorem that underlies the theory of algebraic simplification.
23:32:23 <newsham> > (\x -> (sin x)**2 + (cos x)**2) 1.0 - 1.0
23:32:24 <lambdabot>  5.551115123125783e-17
23:32:30 <Pseudonym> It's incredibly useful.  Should check it out some time.
23:33:10 <luqui> Pseudonym, wikipedia is unaware.  do you have a good ref?  sounds very interesting.
23:33:21 <vixey> yeah
23:33:28 <Pseudonym> Hmmm.
23:33:30 <newsham> ?check \x -> abs ((sin x)**2 + (cos x)**2 - 1.0) < 0.001
23:33:31 <lambdabot>  OK, passed 500 tests.
23:33:34 <Pseudonym> ?google algebraic simplification confused
23:33:34 <lambdabot> No Result Found.
23:33:48 <vixey> Enzo_: I just look at things as a sum of products, and select out like terms, merge them and put them back until there's nothing left
23:34:19 <Pseudonym> Dammit, just a moment.
23:34:27 <Pseudonym> Windows is slowly hanging on me.
23:35:24 <Pseudonym> ?google algebraic simplification perplexed
23:35:28 <lambdabot> http://portal.acm.org/citation.cfm?id=806298
23:35:28 <lambdabot> Title: Algebraic simplification a guide for the perplexed
23:35:30 <Enzo_> vixey! that a good idea, I had not thought of that!
23:35:32 <Pseudonym> That's it.
23:35:43 <Pseudonym> I seem to remember there's somethign in there about it.
23:35:49 <vixey> Enzo_: Select is a Prolog thing but you can easily do it in haskell
23:37:32 <vixey> @let select [] = mzero ; select (e:es) = (e,es) : do (x,xs) <- select es ; return (x,e:xs)
23:37:32 <lambdabot> Defined.
23:37:38 <vixey> > select "xyz"
23:37:39 <lambdabot>  [('x',"yz"),('y',"xz"),('z',"xy")]
23:38:07 <vixey> soo if you had.. Sum [Product [3, x], Product [y], Product [4, x]]
23:38:22 <vixey> it's sort of simple but it's not very powerful
23:38:34 <Enzo_> hmm
23:39:14 <newsham> > sequence [Just 2, Just 3, Just 4]
23:39:15 <lambdabot>  Just [2,3,4]
23:39:21 <newsham> > sequence [Just 2, Nothing, Just 4]
23:39:22 <lambdabot>  Nothing
23:39:40 <Enzo_> so vixey, your into web programming?
23:39:45 <vixey> no
23:40:38 <Enzo_> but you seem to be quite knowledgeable
23:40:52 <vixey> I'm more interested in programming languages
23:41:04 <vixey> (implementation)
23:42:05 <Enzo_> ahh .. well you must find haskell pretty cool then
23:42:32 <solrize> is that risch structure theorem the same one about symbolic integration?
23:42:50 <solrize> if yes it's in wikipedia and mathworld as "Risch algorithm"
23:43:10 <solrize> googling it finds some good hits
23:50:23 * bos misread that as "meatworld"
23:54:36 <solrize> hee
23:56:16 <newsham> > fmap (+1) $ Id 5
23:56:17 <lambdabot>   Not in scope: data constructor `Id'
23:57:39 <Enzo_> >fmap (+1) $ id 5
23:57:44 <Enzo_> > fmap (+1) $ id 5
23:57:45 <lambdabot>   add an instance declaration for (Num (f a))
23:58:42 <newsham> > fmap (+1) $ Const 5 :: Const Int String
23:58:43 <lambdabot>        add an instance declaration for (Show (Const Int String))
23:58:55 <newsham> > getConst $ fmap (+1) $ Const 5 :: Const Int String
23:58:55 <lambdabot>        add an instance declaration for (Num (Const Int String))
23:59:03 <newsham> > getConst $ (fmap (+1) $ Const 5 :: Const Int String)
23:59:04 <lambdabot>   add an instance declaration for (Num String)
23:59:21 <newsham> > getConst $ fmap (+1) $ Const 5
23:59:23 <lambdabot>  5
23:59:26 <mxc> :t fmap
23:59:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
