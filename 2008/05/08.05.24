00:19:15 <ivanm> tibbe: nope
00:38:28 <jmg_> hi everyone
00:41:30 <wolgo> x:xs expresses  list = [1,2,3] x = 1, xs [2,3] no?
00:41:57 <roconnor> > 1:[2,3]
00:41:58 <lambdabot>  [1,2,3]
00:42:19 <wolgo> ok good
00:46:48 <Cale> Hello jmg_
00:49:12 <kaol> "[PHP and Python have] achieved substantial popularity due primarily to their ability to facilitate rapid prototyping." Why don't they say the same about Haskell?
00:50:35 <mbz> haksell is more academical language
00:51:16 <mbz> and it requires more time to learn the basics of the language
00:51:29 <ivanm> hang on, I thought PHP was used solely for web stuff...
00:51:35 <ivanm> i.e. nothing real :p
00:51:42 <kaol> I know I've never had things click together faster with anything else.
00:53:23 <cjs> I've definitely found it slower to this point, though I expect that will change over the next few months as I get better.
00:53:58 <mbz> cjs, are you talking about haskell?
00:54:04 <cjs> Yes.
00:54:23 <kaol> I like how haskell tastes so much like math
00:55:54 <mbz> cjs, are you using python with psyco?
00:56:21 <mbz> w/o psyco, python is much more slower especially dealing with math/arithmecis/etc
00:57:09 <mbz> and python hasn't support for threading (there is a global lock and one thread can lok up appication)
00:57:21 <mbz> lock
00:58:16 <kaol> still, I wish it would get a few fixes... Like splitting MonadPlus and removing fail and sticking do pattern match failures into MonadPlus
01:03:04 <cjs> mbz: no, I've been a ruby guy for the past three or four years.
01:03:52 <cjs> But I'm not talking about haskell programming *running* more slowly; they're far, far faster. I just don't find, in many circumstances, that things fall together quite as quickly as Ruby.
01:04:17 <cjs> Moving from Ruby to Haskell there were a great number of new concepts to learn, compared to my Java -> Ruby move.
01:04:53 <mbz> ;)
01:05:06 <cjs> And I supsect that for non-OO programmers, the Perl/Ruby/Python support for straight imperative scripts helps people get "started" fast, too.
01:05:48 <cjs> But then again, I'm making a specific effort to learn better methods of program organization at the same time, too, so that's probably making me go a bit slower than I would otherwise.
01:07:41 <Cale> MonadZero
01:08:02 <mbz> cjs, yep, that's completely true
01:10:41 <cjs> And I've got to say, some of the stuff was reasonably tough for a non-degreed, work-a-day programmer like me.
01:11:11 <cjs> And I'm smart with a lot of experience. A standard PHP dude probably couldn't pick this stuff up without extensive training.
01:14:33 <cjs> On the other hand, some things that seem to be regarded as a bit "higher-level" by some seemed rather trivial to me. Type classes, for example.
01:16:12 <mbz> to be honest I'm using python for allmost all prototypes
01:17:25 <mbz> I guess almost nobody in my company knows haskell
01:18:25 <mbz> we have about 150 developers... I know only one except me who is using haskell :\
01:18:41 <cjs> Using a dynamic language for prototypes might make a lot of sense. Haskell tends to front-load the design part of the work, in that it's much harder to implement broken designs.
01:18:52 <vixey> mbz: out of all the people I've met in my life I only know two that knew haskell
01:18:57 <kaol> cjs: is that a bad thing?
01:19:21 <kaol> I don't want to implement broken designs ;-)
01:19:38 <cjs> If you are more concerned about getting a "feel" for the problem, rather than figuring out how to solve all cases correctly, you might get that faster from hacking it out in Ruby or Python or whatever.
01:20:23 <cjs> Or if it's a program where you don't care that much if it breaks, it might be faster to do it in a language that spends less effort keeping you from writing wrong code.
01:20:51 <cjs> It really depends on the purpose of the prototype.
01:21:05 <kaol> I've found it easy enough to just leave parts out that you aren't concerned about yet easily. Functional code isolates really well.
01:21:43 <cjs> Well, I'm thinking more of cases where there are error conditions you just don't want to handle, and you're happy to have the program crash instead.
01:22:06 <cjs> Though I'm getting a bit better with using undefined and error in Haskell to simulate that a bit.
01:22:26 <solrize> bos and cosmicray both switched from python to haskell and say they've become as productive in haskell as they were in python
01:22:34 <cjs> The big advantage of Haskell, of course, is that even when you do do that, it's much easier to go back and find those spots later.
01:22:49 <solrize> the thing flipping -me- off is that my haskell programs run slower than the same programs in python :(
01:22:56 <cjs> Yeah, probably another six months and I'll be the same way, for most stuff.
01:23:04 <dolio> In my experience there isn't much that haskell keeps you from writing that wouldn't just give you useless answers in ruby.
01:23:14 <solrize> but, haskell programs once they work feel very solid and correct
01:23:16 <cjs> solrize: ByteString is your friend. :-)
01:23:34 <solrize> with python it feels like you have built a car out of rubber bands and it could sproing all over at any second
01:23:46 <solrize> cjs i'm using bytestring but getting killed in the haskell sha1 and json libraries
01:24:49 * mrsolo shrugs
01:25:02 <mrsolo> haskell really lack some libraries..even worst so than say ruby
01:25:19 <mrsolo> i can't use haskell at work for a lot of stuffs... just don't have time to write libraries from scratch
01:25:21 <cjs> solrize, Really? Hm. That should be fixable.
01:25:36 <solrize> mrsolo yeah that true too
01:25:47 <cjs> I've never found libraries to be that big an issue. And Ruby has this problem that a lot of the libraries are just crap. Buggy, poor interfaces....
01:25:58 <cjs> ...behaviour very poorly defined...
01:26:10 <solrize> once UnicodeString works some things will be a lot easier
01:26:19 <cjs> Yes, we need to have that back.
01:27:19 <cjs> Oh, and fixing space leaks due to overgeneration of thunks can be a pain.
01:27:39 <mbz> btw, is it easy to embed haskell in applications?
01:27:53 <mbz> (comparing to python)
01:27:55 <solrize> mbz, err i'd say not really.
01:28:07 <cjs> I've not tried it, but it looks pretty easy. I have checked out the FFI interface, and it looks reasonable.
01:28:35 <pejo> solrize, are the pure Python sha1 libraries faster than the haskell implementations?
01:28:37 <solrize> i think the FFI assumes the ghc rts will be in charge of the show
01:28:57 <solrize> pejo hahahaha no of course not, the python sha1 lib is written in C
01:29:17 <cjs> pejo: python gets its speed for certain apps basically because it's a scripting wrapper around a bunch of C libraries.
01:29:27 <solrize> right
01:29:55 <cjs> solrize, There's some sort of interface to make Haskell libraries that you can call from other programs.
01:30:40 <pejo> solrize, so use FFI then and get comparable numbers?
01:30:46 <solrize> yeah, i just don't think it's as embeddable as python.  e.g. the rts wants to take control of the timer interrupt, iirc
01:31:26 <solrize> pejo, that's not a valid comparison, if i can say "import sha" in python but have to spend N hours mucking around with the FFI to hash something in haskell at comparable speed
01:31:55 <bd_> Or you could use the haskell crypto library...?
01:31:57 <vixey> solrize: but once you did the N hours, somebody else using haskell would be able to write import sha?
01:32:52 <solrize> bd_ the sha that i used is from the haskell crypto library.  vixey, again not a fair comparison, in python i just use what's there and in haskell i have to become a library developer... anyway using a C lib from haskell is distasteful
01:32:53 <bd_> hmm, needs updating for bytestrings
01:32:59 <pejo> vixey, that largely depends on the corporate culture, investment banking is a typical counter example where it probably doesn't work very well.
01:34:00 <solrize> what i keep hearing is that haskell can run a few times slower than C with a bit of careful coding
01:34:08 <solrize> which makes me think the haskell sha1 lib is written carelessly ;)
01:34:19 <cjs> solrize, me too.
01:34:19 <bd_> solrize: It uses [Word8] as its input
01:34:21 <bd_> nuff said :)
01:34:41 <bd_> :t Data.Digest.SHA1.hash
01:34:43 <lambdabot> Couldn't find qualified module.
01:34:50 <bd_> hmm, not in lambdabot
01:35:00 <tieTYT2> solrize: how many times slower than C does Java run?
01:35:06 <cjs> E.g., I've got an app which processes a day of trading data, and it currently can read and parse 5.5 million messages in less than 60 seconds.
01:35:12 * nornagon prods bd_ 
01:35:13 <bd_> also it has two incompatible definitions of Word160 o_O
01:35:16 <bd_> nornagon: oh hi
01:35:25 <cjs> The only way I'd ever get that in Python is by writing an extension in C.
01:35:26 <solrize> tietyt2 i haven't clocked a java sha1 routine
01:35:27 <nornagon> Word160?!
01:35:58 <bd_> nornagon: yes, the return type of SHA1. See http://www.haskell.org/crypto/doc/html/Data-LargeWord.html and http://www.haskell.org/crypto/doc/html/Data-Digest-SHA1.html, and note the incompatibility
01:36:13 <nornagon> ah right.
01:36:24 * bd_ is grabbing the darcs version now
01:36:49 <solrize> cjs what format is the day trading data in?
01:37:10 <bd_> hmm, still broken there
01:37:14 <bd_> maybe i'll hack on it a bit tomorrow
01:37:16 <bd_> for now, sleep
01:37:17 <solrize> cool
01:37:33 <cjs> GL messages. A reasonably compact, sort of mostly-ascii format; messages probably average 80-100 bytes each, though some are much larger.
01:38:25 <solrize> i.e. some weird format that you have to actually parse
01:38:33 <solrize> i thought maybe it was CSV or something
01:38:42 <solrize> there is a fast csv lib for python
01:38:48 <cjs> But the really nice thing is that I'm getting excellent type safety, since for this particular application, correctness and not crashing is quite important.
01:38:59 <cjs> Yes, I wrote my own monadic parser of ByteStrings to deal with this.
01:39:11 <solrize> yeah, python now feels just unbelievably sloppy even when i code in a type-rigorous style
01:39:22 <cjs> Same for me in Ruby.
01:40:00 <solrize> i've even gotten interested in coding something in ada :-P
01:42:42 <Syzygy-> dons: Amusing monad code. Where did you find it?
01:46:54 <vixey> > iterate ((++")").("("++)) ""
01:46:55 <lambdabot>  ["","()","(())","((()))","(((())))","((((()))))","(((((())))))","((((((())))...
01:47:47 <cjs> What's the trick for combining "comparing" for making new comparision functions? E.g., on a data type, I want to sort first based on fieldB, then on fieldC.
01:48:13 <vixey> cjs: I think.. mplus, maybe?
01:48:17 <vixey> @instances MonadPlus
01:48:18 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
01:48:19 <cjs> sortBy (comparing fieldB) does the first part, but then there must be a nice way to get fieldC in there, to be used when fieldB is equal...
01:48:30 <vixey> :t comparing
01:48:32 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
01:48:38 <vixey> maybe it's mappend
01:48:53 <vixey> > GT ++ EQ
01:48:54 <lambdabot>  GT
01:49:09 <cjs> It's not MPlus, maybe Monoid?
01:49:15 <vixey> ah
01:49:19 <vixey> @instances Monoid
01:49:20 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:49:21 <cjs> > EQ ++ GT
01:49:22 <lambdabot>  GT
01:49:27 <cjs> EQ ++ EQ
01:49:36 <cjs> > EQ ++ EQ
01:49:38 <lambdabot>  EQ
01:49:40 <solrize> ugh!!!
01:49:46 <vixey> @pl \x y -> comparing f x y ++ comparing g x y
01:49:46 <lambdabot> ap (ap . ((++) .) . comparing f) (comparing g)
01:50:09 <vixey> :t liftM2 (++) (comparing ?f) (comparing ?g)
01:50:10 <lambdabot> forall b a a1. (Ord a1, ?g::b -> a1, Ord a, ?f::b -> a) => b -> b -> Ordering
01:50:37 <solrize> > Nothing ++ (Just 3)
01:50:37 <lambdabot>  Add a type signature
01:50:51 <solrize> > Nothing ++ (Just "foo")
01:50:52 <lambdabot>  Just "foo"
01:51:00 <mbz> Cale_,  good pictures of folding. how have you made them?
01:51:02 <solrize> (Just "foo") ++ (Just "bar")
01:51:10 <solrize> > (Just "foo") ++ (Just "bar")
01:51:11 <Cale_> mbz: inkscape
01:51:12 <lambdabot>  Just "foobar"
01:52:49 <vixey> Just "foobar"?
01:53:25 <solrize> yeah, (Just x) ++ (Just y) == Just (x++y)
01:53:55 <vixey> I'm trying to imagine a situation where 'Just "foobar"' is a reasonable answer
01:54:11 <vixey> > Just (Just "foo") ++ Just (Just "bar")
01:54:12 <lambdabot>  Just (Just "foobar")
01:54:31 <mbz> Cale, thanks. Is it free?
01:54:38 <Cale> Yep :)
01:54:53 <mbz> cool ;)
01:57:50 <Cale> I'm not a professional graphic designer, but as far as I'm concerned, it's as good as Illustrator.
01:58:23 <cjs> See, this is what I'm saying about Haskell. As soon as I start to try and get the littlest bit clever, I find myself heading off to read yet another academic paper.
01:58:25 <mahogny> inkscape is awful last time I tried (a few weeks ago)
01:58:31 <mahogny> *was
01:58:33 * cjs is off to learn about monoids.
01:58:55 <mbz> mahogny, what's wrong with inkscape?
01:58:56 <mahogny> but then, illustrator doesn't impress either
01:58:59 <Cale> mahogny: What didn't you like about it?
01:59:04 <mahogny> general usability
01:59:47 <mbz> you are to learn how to use it ?
01:59:58 <mahogny> I think corel xara is the best illustrating app I've tried so far. someone should replicate it
01:59:58 <Cale> It takes some getting used to the basic tools. The pen tool especially.
01:59:58 <mbz> (like vi/emacs)
02:00:26 <Cale> (though if you've used similar programs, it's exactly the same)
02:01:17 <mahogny> a xara replica should fit perfectly in haskell. it is all based on easy undo, and undo is unbeatably easy to implement in FP
02:01:35 <vixey> FP?
02:01:40 <vixey> what is this
02:01:43 <mbz> ;)
02:01:46 <mahogny> :)
02:01:50 <mahogny> functional programming
02:02:17 <cjs> @src mappend :: Orderering -> Ordering -> Ordering
02:02:17 <lambdabot> Source not found. :(
02:02:42 <vixey> (++) = mappend
02:02:55 <vixey> oh
02:03:27 <Cale> cjs: It's effectively lexicographic concatenation... if that makes sense.
02:03:40 <vixey> > map (\(x,y)->(x,y,x++y)) [(x,y) | x <- [EQ,GT,LT] , y <- [EQ,GT,LT] ]
02:03:41 <lambdabot>  [(EQ,EQ,EQ),(EQ,GT,GT),(EQ,LT,LT),(GT,EQ,GT),(GT,GT,GT),(GT,LT,GT),(LT,EQ,LT...
02:03:42 <cjs> No, it's all clear. I'm learning that often the best thing to do is just to go read the source, and it's all obvious.
02:03:44 <Cale> cjs: The right parameter is only used if the left one is EQ
02:04:27 <cjs> In this case, the source in http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Monoid.html is far more clear than any other explanation, I think.
02:04:27 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6atqpo
02:04:34 <Cale> > sortBy (comparing length ++ compare) (words "Here is a bunch of words to sort by length and then alphabetically")
02:04:35 <lambdabot>  ["a","by","is","of","to","and","Here","sort","then","bunch","words","length"...
02:04:39 <cjs> (Just search for "ordering" in there.
02:04:45 <vixey> oooo
02:04:49 <vixey> Cale++
02:05:10 <vixey> btw
02:05:12 <tieTYT2> wow that's badass
02:05:13 <vixey> is there no way to write
02:05:19 <vixey> liftM2 (++) (comparing ?f) (comparing ?g)
02:05:19 <sjanssen> hey, does ++ mean mappend when incrementing karma too?
02:05:20 <tieTYT2> doing that in java is annoying
02:05:22 <vixey> better
02:05:37 <vixey> like ^++^
02:05:38 <vixey> :D
02:05:45 <Cale> tieTYT2: You should note that I've replaced the definition of (++) with mappend
02:05:58 <Cale> tieTYT2: The Prelude (++) only concatenates lists, and not other things.
02:06:05 <cjs> yeah, it's this sort of stuff where FP can give you some truly serious wins. Once you learn how to do that.
02:06:06 <vixey> what's a good operator for liftM2 (++) ?
02:06:07 <sjanssen> vixey: no need to liftM2, the Monoid instance for functions takes care of that
02:06:24 <tieTYT2> Cale: oh
02:06:26 <vixey> sjanssen: *omg*
02:06:29 <sjanssen> (assuming we're in the function Monad here)
02:06:37 <cjs> Ah, it was replacing ++ with `mappend` that finally fixed my type checking problem!
02:06:38 <tieTYT2> so you can override functionality with operators i see
02:06:39 <vixey> :t comparing ?f ++ comparing ?g
02:06:41 <lambdabot> forall a b a1. (Ord a1, ?g::b -> a1, Ord a, ?f::b -> a) => b -> b -> Ordering
02:06:46 <cjs> Why did ++ work for lambdabot?
02:06:46 <vixey> sjanssen++ :D
02:06:51 <sjanssen> Cale: that is a pretty awesome example, ignoring the Prelude shadowing
02:07:06 <vixey> @instances Monoid
02:07:07 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:07:10 <Cale> cjs: Because I replaced the definition of (++)
02:07:22 <cjs> Cale: Ah, I just noticed that comment.
02:07:29 <tieTYT2> the java creators didn't like the idea of operator overloading.  Are there reasons why their concerns are negated in haskell, or do the makers of haskell just disagree with their reasons?
02:07:38 <Cale> tieTYT2: Yeah, they're just ordinary functions. You can invent your own infix operators too.
02:07:49 <vixey> tieTYT2: IIRC Sussman is trying to get it added
02:08:04 <Cale> > let x %^@$## y = x^2 + y^2 in 5 %^@$## 7
02:08:05 <lambdabot>  74
02:08:07 <tieTYT2> well lots of people don't like the idea, myself included
02:08:09 <tieTYT2> for java that is
02:08:17 <tieTYT2> i don't want some retard to change what + does
02:08:26 <vixey> so don't hack code with them .....
02:08:29 <tieTYT2> unless it's intuitive
02:08:32 <Cale> It's not really operator overloading.
02:08:32 <cjs> That's not overloading: that's overriding.
02:08:34 <sjanssen> is Java's type system good enough to do that sort of overloading sanely?
02:08:44 <tieTYT2> cjs: that's what i mean
02:09:04 <cjs> tieTYT2, While you can do it in Haskell, it's pretty rare.
02:09:29 <cjs> For example, when made an operator to add two maybes, I actually called it .+
02:09:29 <Cale> tieTYT2: Infix operators in Haskell aren't special. If you want to overload them, you need a typeclass, just like anything else.
02:09:31 <tieTYT2> i donno haskell very well so I can't say it's a bad idea for haskell.  But i know i wouldn't like it in Java
02:09:49 <Cale> They're just valid function names.
02:09:52 <mahogny> the operator space is very scarce. it's very easy to clog it up
02:10:11 <cjs> It's really no different from overriding a regular function. But it somehow seems different in Java, I agree.
02:10:21 <Cale> It's unfortunate that keyboards don't have more easily accessible symbol keys.
02:10:30 <dolio> Pff, we have infinitely many operators!
02:10:33 <Cale> Why couldn't the space cadet keyboard have won?
02:10:39 <dolio> ==<==##= isnt' taken.
02:10:48 <Cale> dolio: But only a few which are short and memorable :)
02:10:55 <mahogny> dolio, well. yeah. that's the next problem :)
02:11:12 <cjs> tieTYT2, yeah, I think that the problem with java is that there's just too few operators.
02:11:36 <mahogny> don't see a problem in adding more operators to java on-the-fly. having a fixed set is just awful
02:11:52 <tieTYT2> it depends on how it's implemented, but I think the problem is i currently know what to expect when i see "1" + "2".  I don't want anyone to be able to confuse me
02:12:21 <tieTYT2> yeah if i can add new ones, that's fine
02:12:27 <mahogny> well. it could return "3". concatenation is no more intuitive
02:12:31 <tieTYT2> but i don't feel comfortable with being able to change the old ones
02:12:44 <tieTYT2> mahogny: it is because of tradition
02:12:50 <tieTYT2> perhaps when you learn the language, you're right
02:13:01 <mahogny> there are languages when you will get 3 you know
02:13:10 <mahogny> so. tradition? no
02:13:11 <sjanssen> I think the problem with "operator overloading" in Java is the "overloading" bit rather than the "operator" bit
02:13:13 <tieTYT2> sure but that's not the way java works
02:13:15 <mahogny> arbitrary choice
02:13:17 <tieTYT2> it's a tradition in java
02:13:17 <dcoutts> tibbe: not yet
02:13:21 <Cale> tieTYT2: In Haskell, we separate overloading from operators :)
02:13:34 <tieTYT2> mahogny: yes but one that's been around 10+ years in the java language
02:13:35 <sjanssen> I mean, look at the horrible mess Java has made out of equality
02:13:37 <dcoutts> tibbe: it's dependent on a release of Cabal-1.4
02:13:58 <mahogny> tieTYT2, sure and of course it won't change once it's in. but it was an arbitrary choice from the beginning
02:14:10 <tieTYT2> i wasn't arguing that
02:14:15 <tieTYT2> or saying another language shouldn't do it differently
02:14:17 <mahogny> no one can override the + for strings in java, ever. unless they write their own string class but "" always gives String
02:14:41 <mahogny> so I don't think that is an issue
02:14:51 <tieTYT2> mahogny: did you read this convo from the start?  Someone said Sussman was talking about adding it
02:15:08 <mahogny> even overriding for given classes? o_O
02:15:14 <mahogny> not just for new classes?
02:15:22 <tieTYT2> i donno
02:15:24 <mahogny> because the latter makes sense
02:15:32 <tieTYT2> not necessarily
02:15:33 <mahogny> the first.. uh. I have no idea how it even would work out semantically
02:16:09 <sjanssen> what would the type of an overloadable '+' be in Java?
02:16:10 <tieTYT2> if you do "this is a string" + anyObject it calls anyObject.toString()
02:16:24 <Cale> Without typeclasses to inflict some amount of sanity, functions with multiple meanings are not as cool.
02:16:34 <hpaste>  chylli pasted "xmonad.hs" at http://hpaste.org/7853
02:17:12 <Cale> glguy: You really need to turn up the paste size limit a tad.
02:17:16 <hpaste>  morrow pasted "TH ppr bug" at http://hpaste.org/7854
02:17:37 <EvilTerran> what OOPers call inheritence, haskellers could perfectly well call -XOverlappingInstances :P
02:17:42 <Cale> @tell glguy You really need to turn up the paste size limit a tad.
02:17:42 <lambdabot> Consider it noted.
02:17:42 <glguy> Cale: I'm not in a position to recompile hpaste at the moment and that isn't a knob
02:17:43 <lambdabot> glguy: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:17:47 <Cale> glguy: oh
02:17:49 <mahogny> Cale, well. it can be quite cool except if you do it wrong (C++ is the perfect example as always). make the number of operators fixed and see them used for about anything under heaven, no matter if it makes sense :P
02:18:02 <Cale> glguy: What is the size limited by?
02:18:11 <glguy> the handler for that action
02:18:19 <glguy> the function you use in happs
02:18:27 <glguy> to get a form field takes a size parameter
02:18:36 <hpaste>  morrow annotated "TH ppr bug" with "(no title)" at http://hpaste.org/7854#a1
02:18:38 <Cale> oh, huh...
02:19:39 <Cale> glguy: You can't pass a larger size?
02:19:55 <glguy> you could , and then you'd recompile the app
02:19:57 <glguy> and restart
02:20:06 <glguy> I can't do the last two actions
02:20:07 <hpaste>  chylli pasted "xmonad.hs" at http://hpaste.org/7855
02:20:11 <Cale> ah, okay
02:20:19 <hpaste>  morrow annotated "TH ppr bug" with "(no title)" at http://hpaste.org/7854#a2
02:20:24 <glguy> it's running as a user I'm not and I don't have a 32bit machine to compile on and I don't have the right version of happs
02:20:37 <cjs> So it's typeclasses, then, that give sanity to operator overloading. Yes, this makes sense.
02:21:11 <cjs> Oh, and also that functions are not quite so polymorphic as they are in Java.
02:21:31 <Cale> Well, the typeclass imposes that constraint.
02:21:40 <glguy> I tried building the new hpaste for code.haskell.org but it runs debian so it was so out of date non of the stuff I needed was in the right year
02:21:48 <cjs> Yes, and it's starting to look a much more reasonable constraint, now. :-)
02:22:02 <Cale> If (+) was defined in a class Plus a where (+) :: a, then you could give it any type at all.
02:22:23 <EvilTerran> typeclasses also tend to come with more formal semantics than java classes
02:22:31 <Cale> (and one which was completely independent of the type for (-)
02:22:32 <Cale> )
02:22:38 <tieTYT2> or perhaps it's the fact that "1" + "2" wouldn't work in haskell
02:22:50 <tieTYT2> in haskell, if i see that, i can expect overloading
02:23:01 <tieTYT2> but in java, i have a preconceived notion of what that means
02:23:02 <EvilTerran> let (+) = mappend ...
02:23:08 <cjs> EvilTerran, indeed. I tend to think of it as a formalized version of duck typing.
02:23:18 <hpaste>  morrow annotated "TH ppr bug" with "it appears to be only in the printing" at http://hpaste.org/7854#a3
02:23:21 <tieTYT2> i mean overriding
02:23:48 <tieTYT2> sorry, i forget to think when i pick between overriding and overloading in a sentence :P
02:23:59 <vixey> EvilTerran: noooooooooooo
02:24:33 <EvilTerran> import Prelude (); import CalePrelude -- :D
02:24:51 <vixey> cabal install CaleHaskell ?
02:25:07 <EvilTerran> ISTR it's called Caleskell
02:25:18 <tieTYT2> any comments on my last statement? :P
02:25:21 <dcoutts> is that a replacement prelude?
02:25:23 <EvilTerran> ... or would "Hascale" be better?
02:25:24 <glguy> Hascale?
02:25:56 <EvilTerran> dcoutts, i don't think it's standalone, but i mean what lambdabot has in scope
02:26:05 <EvilTerran> (.) = fmap, (++) = mappend, etc
02:26:27 <Cale> It's just a handful of definitions I made in L.hs
02:26:29 <dcoutts> ah, there should be though
02:26:43 <Cale> Yeah, we should work on a proper new Prelude.
02:26:44 <dcoutts> a replacement prelude I mean
02:26:46 <dcoutts> right
02:27:42 <Cale> tieTYT2: Well, I suppose that in Haskell, if you see "1" + "2", you can infer that someone went to the trouble of writing an instance of Num for String.
02:28:17 <vixey> :t ((.).(.)) show ((+)`on`read)
02:28:19 <lambdabot> String -> String -> String
02:29:02 <tieTYT2> Cale: isn't it true that if you see that you can assume + got overridden?
02:29:10 <tibbe> dcoutts: OK, cool
02:29:21 <Cale> tieTYT2: Not just (+), but (*) and (-) and fromInteger as well.
02:29:43 <Cale> (all the methods of the Num class)
02:32:00 <Cale> Though, that's a restriction which is possibly a bit excessive.
02:32:31 <Cale> It would be nice to be able to define (+) for additive things without needing a full instance of Num.
02:32:36 <tieTYT2> well my point is, in java (if it had operator overriding), when you see "1" + "2", you wouldn't be able to assume it was overriding
02:32:39 <tieTYT2> you could never assume that anymore
02:32:51 <tieTYT2> and that would suck.  If something unexpected happens, you'd have to consider that as a source of a bug
02:33:00 <tibbe> dcoutts: it's a bit confusing that there is a cabal-install package on hackage
02:33:15 <Cale> tieTYT2: What else could it be?
02:33:50 <tieTYT2> couldn't you override + to count the number of characters in the two strings?
02:33:54 <tieTYT2> can't you do anything you want?
02:34:03 <dcoutts> tibbe: yeah, that one is well out of date
02:34:08 <Cale> well, sure
02:34:23 <Cale> > let x + y = length x + length y in "hello" + "world"
02:34:23 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
02:34:24 <dcoutts> tibbe: and we've not been able to replace it because we need the new Cabal-1.4 to be released
02:34:37 <Cale> oh, right :)
02:34:42 <Cale> > let x + y = length x Prelude.+ length y in "hello" + "world"
02:34:43 <lambdabot>  10
02:34:55 <Cale> Don't need it to be recursive ;)
02:34:58 <tibbe> dcoutts: fair enough
02:35:05 <tibbe> dcoutts: just checking :)
02:35:06 <tieTYT2> oh
02:35:11 <tieTYT2> so you can do it in haskell too
02:35:19 <tieTYT2> see, i know your first thoughts are probably, "Don't abuse it"
02:35:25 <Cale> Yeah, that's just a local binding that shadows the Prelude one though.
02:35:27 <tieTYT2> but my first thought is, "Somebody stupid will"
02:35:47 <Cale> It's really noticeable when someone does that, because the normal (+) doesn't work anymore.
02:35:55 <tieTYT2> ok good
02:36:11 <Cale> > let x + y = length x Prelude.+ length y in 5 + 7
02:36:12 <lambdabot>   add an instance declaration for (Num [a1])
02:36:13 <tieTYT2> perhaps that's what makes haskell a better candidate for it than java
02:36:50 <Cale> Heh, nice error message. It's complaining that it doesn't know how to treat 5 as a list in order to compute its length :P
02:37:12 <cjs> tieTYT2, It's because you can *only* do local shadowings in Haskell.
02:37:14 <tieTYT2> makes sense :)
02:37:30 <tieTYT2> cjs: I haven't really learned haskell scope rules except for inside functions
02:37:46 <cjs> The only other thing you need to learn is the module system.
02:37:55 <cjs> And that's almost as simple: anything you import is in scope.
02:38:00 * vixey is reminded of Logo "I don't know how to SQUARE"
02:38:13 <cjs> And you'll get errors for clashes.
02:38:43 <tieTYT2> i see
02:39:04 <cjs> So if a module overrides (+), when you try to use (+) it will tell you it can't chose between Prelude.(+) and Bozo.(+), and you need to fix your imports to pick a default (explicitly), or qualify the particular call.
02:39:37 <tieTYT2> what if someone uses your module?
02:39:42 <tieTYT2> do they have to import your weird plus rules?
02:40:04 <cjs> They import by default, but as I said, any unqualified use will result in the error.
02:40:33 <cjs> At that point you realize the module author was a moron, and add "hiding ((+))" to your import statement.
02:40:47 <tieTYT2> ah
02:41:04 <vixey> actually I'd suggest finding someone else to hack with
02:41:11 <vixey> if you are having this much trouble
02:41:22 <tieTYT2> vixey: seriously :)
02:41:31 <tieTYT2> i like my job except for maintaining his code
02:41:37 <tieTYT2> so it's not so straight forward
02:42:04 <tieTYT2> when i stop enjoying going to work, i probably will
02:42:10 <cjs> Actually, even if you define + yourself in your own module, you'd need to either qualify its use with your own module name or hide it explicitly.
02:42:17 <Cale> You can also have weird (+) rules without exporting your definition for (+)
02:43:18 <tieTYT2> i just think things are better when they're as idiot proof as possible
02:43:24 <hpaste>  cjs pasted "shadowing (+)" at http://hpaste.org/7856
02:43:38 <tieTYT2> and i've heard that haskell is one of the best languages in that respect
02:43:58 <cjs> So that's what it looks like even if you do this only within a single module. Just scan the imports, and you'll see that someone's being...err..."tricky."
02:44:01 <dancor> un-qualified-by-default imports is def one of the more reckless aspects of haskell
02:44:06 <dcoutts> I think all serious code should be using explicit or qualified imports
02:44:12 <dcoutts> ie not just: import Foo
02:44:24 <vixey> > (((.).(.)) show ((+)`on`read)) "5" "7"
02:44:24 <dcoutts> either: import Foo (foo)
02:44:25 <lambdabot>  "12"
02:44:36 <cjs> dancor, Really? I find it to work very well, since once you use anything that collides, you'll know about it and it won't compile.
02:44:37 <dcoutts> or: import qualified Foo as Whatever
02:44:40 <dancor> dcoutts: but do ghc and darcs use _only_ explicit imports?
02:44:52 <Cale> tieTYT2: Yeah, the nice thing is that this gives you a little more freedom to do zany things at times because if something goes wrong, the type system will catch it.
02:45:07 <dancor> cjs: but try figuring out why someone else's unqualified imports code doesn't compile
02:45:24 <tieTYT2> Cale: yep
02:45:25 <dcoutts> dancor: ghc is in a somewhat different situation since it's at the bottom of the pile and does not need to worry about changing libs underneath it
02:45:32 <vixey> or you could read the code you use
02:45:33 <dancor> throw in the constant churn of haskell code, and you've got a fun time on your hands
02:45:40 <vixey> rather than relying on a compiler telling you everything
02:45:45 <dcoutts> dancor: many of the standard libs do though, and Cabal does. I dunno about darcs.
02:45:47 <tieTYT2> Cale: and i've said like 3 times already, if my coworker could not reassign variables, his code would be so much cleaner
02:45:50 <cjs> dancor, Our rule is that you don't commit anything that doesn't compile, so it remains that other person's uncommitted problem. :-)
02:45:56 <Cale> Someone please tell me how a wired ethernet connection on a LAN with only 2 computers can just randomly drop. This must have something to do with heat or barometric pressure or something...
02:46:00 <tieTYT2> so that's also cool
02:46:09 <dancor> cjs: compile with what version of ghc?  etc
02:46:10 <Cale> tieTYT2: Yeah :)
02:46:45 <tieTYT2> you guys are here at all hours
02:46:48 <cjs> dancor, We usually fix that for a project, too. For library code likely to be used under several versions of the compiler, and several different compilers, you have a point.
02:47:03 <Cale> heh, it's 5:46am here, and I haven't slept :)
02:47:23 <Cale> I think I might just stay up a while longer and have a nap in the middle of the day.
02:47:32 <tieTYT2> why?
02:47:42 <cjs> tieTYT2, We're here in shifts based on time zones. :-)
02:49:23 <Cale> I have friends in lots of time zones, so talking to them screws up my hours :)
02:50:09 <Cale> Plus I seem to just slip into 32 hour days unless I'm careful about it and set an alarm.
02:50:32 <hpaste>  morrow annotated "TH ppr bug" with "fixed" at http://hpaste.org/7854#a4
02:50:50 <tieTYT2> i can't function well after 16 hours of work
02:51:53 <Cale> (by which I mean 32 hour cycles, including sleep)
02:57:20 <vixey> Grand Master Turing once dreamed that he was a machine. When he awoke he exclaimed:
02:57:20 <vixey> "I don't know whether I am Turing dreaming that I am a machine, or a machine dreaming that I am Turing!"
02:59:23 <tirpen> Does anyone know why Data.Sequence.Seq is a member of Monad but not MonadPlus?
02:59:55 <tirpen> Err, never mind.
03:05:11 <cjs> So what's the difference between a Monad and a Monoid? Just the lack of (>>)?
03:06:25 <Heffalump> monoids don't have a (>>=)
03:06:32 <Heffalump> and they have different kinds
03:06:39 <Heffalump> they are fundamentally different things
03:06:42 <vixey> @src Monaid
03:06:42 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:07:10 <cjs> Oh, I see, right. (>>=) is not like mappend.
03:07:18 <Heffalump> in principle if m is a MonadPlus then m a is a Monoid for any a
03:07:38 <Heffalump> but for example Int can be a monoid (under either mappend = (+) or mappend = (*))
03:10:09 <cjs> So a MonadPlus is basically a Monad and a Monoid?
03:10:33 <vixey> are there no proposals for different typeclass systems?
03:10:47 <dolio> Different how?
03:10:53 <cjs> (Albeit with mplus instead of mappend?)
03:11:27 <Cale> cjs: yes, in a way that the monoid operation interacts nicely with the monad operations
03:11:45 <cjs> I see. I'm starting to get this now.
03:12:00 <Cale> http://www.haskell.org/haskellwiki/MonadPlus
03:12:00 <lambdabot> Title: MonadPlus - HaskellWiki
03:12:14 <vixey> dolio: dispatch could be done differently I guess, but I haven't thought of any better ways that current
03:12:17 <tieTYT2> is that haskell wiki really useful?
03:12:22 <Cale> tieTYT2: yes
03:12:24 <tieTYT2> right now i'm learning from real world haskell beta
03:12:29 <vixey> maybe describing instances in another way
03:13:14 <cjs> "The precise set of rules that MonadPlus should obey is not agreed upon."
03:13:23 <tieTYT2> ha
03:13:27 <Cale> cjs: yeah, but it's one of two things
03:13:36 <Cale> cjs: See the proposal :)
03:16:58 <cjs> Hm. It would be good if there were a tutorial introduction to abstraction of control structures that covered these various things and their uses.
03:17:27 <Cale> yeah
03:17:33 <cjs> Starting with Monoid, in particular, can make things easier.
03:17:52 <vixey> Zyglomorphisms in practice
03:18:28 <Cale> Dayglomorphisms
03:18:47 <tieTYT2> you people use such big words
03:19:15 <Cale> Dayglomorphisms stand out because of their distinctive bright orange colour.
03:21:10 <Syzygy-> ...
03:21:51 <vixey> Cale: nurikabe led me to a kind of fun problem
03:22:23 <Cale> What's that?
03:23:23 <vixey> Cale: If you take a grid of cells with some already filled in.. the problem is to enumerate every (unique) blob of cells that grows out (i.e. you only fill in adjacent cells) from that by order of size
03:24:07 <vixey> It's probably not actually relevant to solving nurikabe but it seems like a tricky problem
03:24:21 <vixey> (I think I got a solution but haven't coded it yet)
03:25:36 <Cale> Presumably one which also fulfills the nurikabe restrictions?
03:26:50 <Cale> Polyomino counting problems are generally fairly tricky except by brute force.
03:27:13 <vixey> yeah the hardest bit I think is enumerating them without duplicates
03:27:26 <vixey> but I think it's possible (not certain yet)
03:27:53 <vixey> I mean without using nub on hte whole list
03:28:23 <vixey> > nub [1..]
03:28:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:29:38 <vixey> is there any way to get something like (x:xs)`interleave`(y:ys) = x:y:(xs`interleave`ys) for free?
03:29:41 <Cale> It may be tricky. Anything too simple would lead to a nice recurrence for the number of them, which would probably have been found already. :)
03:30:23 <Cale> I usually name that operation /\/ (though I also have used /\/ for ordered merge)
03:30:48 <Cale> But defining it yourself is probably the best you can do. You could use transpose, I guess.
03:31:15 <Cale> > concat (transpose [[1,3,5,7,9],[2,4,6,8,10]])
03:31:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:31:22 <Cale> > concat (transpose [[1,3,5,7,9],[2,4,6,8]])
03:31:23 <lambdabot>  [1,2,3,4,5,6,7,8,9]
03:31:25 <vixey> what kinds of things do you write in Haskell?
03:32:15 <Cale> The biggest thing I've written was a pipeline scheduler for PPC/Altivec assembly, which was essentially a combinatorial search.
03:32:33 <vixey> woah ....
03:33:08 <Cale> But mostly I write small toys and mathematical things.
03:33:45 <Cale> I did an L-System generator with Paolo Martini a while back.
03:34:24 <Cale> I spend a lot more time thinking about how to structure code than I actually spend writing anything of use.
03:34:57 <tieTYT2> do you eventually write what you think about?
03:35:51 <Cale> Well, I write things to test ideas sometimes.
03:36:34 <Cale> But I'm not thinking about specific programs.
03:39:04 <Cale> I should probably be writing more libraries that people can use though :)
03:39:48 <vixey> Cale: I wonder what would happen if you join forces with edwardk
03:41:20 <vixey> I don't really know much work it would be to replace mtl from what's been written already
03:56:56 <gvdm> hah! success!
03:57:02 <gvdm> I've found the buggers
03:57:15 <gvdm> hiding in ~/.gstreamer-0.10
03:57:29 <gvdm> but I pull out my rm and -rf'ed away
03:57:48 <gvdm> hmm, wrong windo
04:09:35 <b_jonas> gvdm: this _is_ the right window for "rm -rf"
04:09:40 <b_jonas> better than the shell at least
04:10:44 <vixey> cool http://edwinb.wordpress.com/2008/03/09/idris-a-language-with-dependent-types/
04:10:45 <lambdabot> Title: Idris, a language with dependent types « Types, Programming, etc., http://tinyurl.com/2dettx
04:15:39 <opqdonut> quicksilver: exactly
04:15:49 <opqdonut> quicksilver: tho it starts feeling like i need my own
04:15:52 <opqdonut> (re: abstractions)
04:16:40 <opqdonut> a monad stack got me quite far, but it seems i'd need an additional StateT and WriterT
04:16:55 <opqdonut> and that'd leave me with a stack with every "basic" monad in the mtl :D
04:17:16 <mauke> :k RWS
04:17:18 <lambdabot> * -> * -> * -> * -> *
04:17:32 <vixey> :k RWS RWS
04:17:34 <lambdabot>     `RWS' is not applied to enough type arguments
04:17:34 <lambdabot>     Expected kind `*', but `RWS' has kind `* -> * -> * -> * -> *'
04:17:36 <vixey> awww
04:18:19 <mauke> :k RWST
04:18:21 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
04:18:27 <vixey> ok!!
04:34:47 <b_jonas> eek
04:35:00 <mbz> @yarr
04:35:01 <lambdabot> Splice the Mainbrace!
04:35:09 <b_jonas> that kind is just bad
04:35:19 <vixey> I like it
04:36:38 <b_jonas> shouldn't the compiler snap you if any type you use has a kind other than one of *, *->*, *->*->*, *->*->*->*, (*->*)->*, *->(*->*)->*, (*->*)->*->*?
04:36:44 <Cale> It'd be more informative if we had kind synonyms.
04:36:54 <b_jonas> oh god, no
04:37:01 <b_jonas> no kind synonyms
04:37:07 <vixey> why don't you just make kinds types
04:38:05 <b_jonas> kind synonyms would just make you create more complicated kinds, and what's worse, you'd want higher-order kind synonyms
04:38:11 <b_jonas> like a kind name that has a kind parameter
04:38:22 <b_jonas> and that's the bad part
04:38:34 <vixey> types aren't scary
04:38:42 <vixey> why should kinds be scary?
04:38:49 <Peaker> if kinds are types, then types are values?
04:39:08 <vixey> Peaker: shhhh
04:39:29 <vixey> :p
04:39:39 <Saizan> vixey: you want kind polymorphism?
04:39:55 <dolio> Who doesn't?
04:40:10 <b_jonas> and kind classes too, yeah?
04:40:11 <Cale> b_jonas: kind functions!
04:40:22 <b_jonas> no, not those, those would be too easy
04:40:44 <b_jonas> kind classes and instances and functional dependencies
04:40:53 <b_jonas> so you have to write functions the hard way
04:40:59 <b_jonas> like how you have to write type functions
04:42:08 <Cale> oh, also, dependent kinds
04:42:27 <Deewiant> kind families
04:42:34 <b_jonas> and kind variables
04:42:53 <b_jonas> I think we should just leave kinds the way they are
04:45:45 <Cale> existential kinds
04:45:58 <Deewiant> phantom kinds?
04:45:58 <Cale> okay, I'm out.
04:46:01 <vixey> generalized algebraic data kinds!
04:46:20 <cpst> just get dependent types
04:46:29 <b_jonas> eek,
04:46:31 <cpst> and program by extraction ;-)
04:46:36 <b_jonas> algebraic data kinds sounds bad
04:46:55 <vixey> cpst: I just found this http://www.cs.st-and.ac.uk/~eb/Idris/
04:46:55 <lambdabot> Title: Idris
04:47:20 <vixey> the source code is just a few pages
04:47:25 <vixey> which is impressive
04:47:39 <cpst> yeah, Coq is probably the dependently typed language with the most traction and the largest programs
04:47:42 <dolio> Even the underlying theorem prover?
04:47:45 <xerox> be kind
04:48:04 <b_jonas> oh, and we need Type.Kindable and Type.Dynamic so we can serialize any higher-order type
04:51:55 <Peaker> ok, I have for the first time benefited from persistent data structures. Adding undo to my chess GUI was trivial! :-)
04:56:10 <Peaker> it took me 30 Haskell lines just to describe how a Pawn may move...
04:56:43 <augustss> pawns are tricky
04:57:19 <augustss> does those 30 lines include en passant?
04:57:34 <b_jonas> yep. move, capture, double move, promotion, en passant
04:57:38 <Peaker> augustss, yeah
04:57:49 <b_jonas> that's complicated enough
04:59:03 <vixey> what's the rules of chess?
04:59:49 <augustss> similar to tennis
05:00:03 <vixey> haha
05:00:30 <augustss> in tennis the person who wins the last ball wins the match
05:00:31 <vixey> Peaker: do you have it online ?
05:00:37 <Heffalump> but the physical prowess required to execute the desired moves is rather smaller
05:00:41 <Peaker> vixey, yeah: http://nextflow.dyndns.org/chess.tgz
05:00:45 <augustss> in chess the person who makes the last move probably wins
05:01:00 <Peaker> vixey, if you have cabal-install it should be easy enough to compile
05:01:14 <vixey> I just want to read
05:01:26 <Peaker> vixey, the gui code is horrible :-)
05:01:33 <Peaker> vixey, I need to taste some horror so I can appreciate FRP goodness
05:01:43 <vixey> when I was growing up I used to play chess against my friend
05:01:53 <Peaker> the chess code itself is also not very clean - I need to work on cleaning that up
05:02:05 <vegai> I wonder if a Go board implementation is harder or easier than chess
05:02:21 <b_jonas> vegai: depends on which variation of rules I think
05:02:23 <Peaker> This started as a "30 minute excercise in Haskell" for me, inspired by questions from chessguy about his code.  So far I worked about 3 days on it :)
05:02:27 <vixey> for about 8 years, I never beat them once.. they turned out to win lots of competitions and such
05:02:31 <Peaker> vegai, the AI is supposedly harder, I think
05:02:37 <b_jonas> go has some ugly rules
05:02:46 <vixey> Go has a bigger board
05:02:47 <vegai> Peaker: nah, it's just random
05:02:48 <b_jonas> that is, ugly for computers
05:02:48 <Peaker> vixey, he multiplied and became them? :)
05:02:53 <vixey> bigger search space
05:03:11 <vegai> or an interface to gnugo
05:06:00 <Peaker> is there anyone here who does UI work -- and can point to a non-terrible way/library to do GUI's?
05:06:24 <doun> use GTK and follow the GNOME user interface guide?
05:06:57 <Peaker> doun, I guess I should say I find imperative GUI programming kinda horrible in Haskell :-)
05:07:26 <vixey> oh
05:07:28 <Peaker> I also need to write my own widgets - and I'm not sure these toolkits allow that
05:07:34 <vixey> pawn is the most complex peice in chess
05:07:50 <b_jonas> isn't there a full Wx interface for haskell yet?
05:08:20 <Peaker> vixey, probably yeah, but maybe a fair comparison would be to inline all the code that's shared between the other pieces before comparing line counts/etc
05:08:30 <b_jonas> vixey: that's debatable, because of the ugly rules of castling and check, king might be more complicated
05:08:59 <vixey> b_jonas: well I am only comparing lines of code
05:09:36 <Peaker> its hard to compare "Complexities" though as those are spread on lots of code - castling complexity is spread on code that keeps track whether the king and rooks moved, but that's not in the castling code itself
05:09:37 <doun> taking into account a pawn can at some point become a different kind of piece, it adds more dimensions
05:10:30 <b_jonas> dunno
05:10:42 <b_jonas> maybe it doesn't even make sense to talk about the complexities of each piece
05:11:09 <b_jonas> for the complexity of chess is not just the sum of the complexity of pieces
05:12:02 <vixey> b_jonas: is it the product?
05:12:10 <vixey> I should think not
05:12:12 <b_jonas> dunno
05:12:18 <b_jonas> I'm not good at chess
05:12:28 <b_jonas> so I can't really tell
05:16:52 <vixey> I was a fan of Xiangqi though
05:18:24 <b_jonas> I tried bridge for a few years but nowadays I don't play games that require much thinking
05:18:27 <b_jonas> I don't like that
05:18:46 <b_jonas> if I want to do thinking, I can do that for work
05:20:35 <doun> I like Chess if I'm playing someone who doesn't take it seriously. if they get pissed off when they are losing or think it means they're a wise chess master when they are winning, I'd rather play a computer.
05:21:13 <b_jonas> doesn't a computer also take it seriously?
05:21:28 <b_jonas> well, except HAL.
05:21:44 <doun> hehe
05:23:14 <b_jonas> though if you don't like when they get pissed of when they lose, the computer of course doesn't do that
05:23:35 <b_jonas> It just takes the thinking out the moves part seriously
05:23:38 <b_jonas> not the game itself
05:23:46 <b_jonas> so it's a different meaning of "take it seriously"
05:26:38 <vixey> http://en.wikipedia.org/wiki/Game_complexity
05:28:20 <b_jonas> HAKMEM also has a complexity ranking
05:28:29 <b_jonas> which of course also has go as the most complex
05:29:46 <vixey> Tetris in NP complete? :S
05:29:55 <vixey> what does that mean
05:30:11 <b_jonas> dunno
05:30:27 <b_jonas> perhaps they mean tetris on a wider than 10 field
05:31:12 <b_jonas> but it could maybe work on a 10 wide arbitarily high field too
05:31:14 <Deewiant> http://www.liacs.nl/~kosters/tetris/tot.pdf
06:01:35 <Peaker> @hoogle nub
06:01:36 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
06:01:38 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
06:02:24 <Peaker> I never understand why Haskell has so many misnamed concepts, many of which are brilliant
06:02:42 <mauke> misnamed?
06:02:44 <b_jonas> which are misnamed?
06:02:58 <Peaker> Well, "misnamed" as in "a name that conveys the meaning much less effectively"
06:03:27 <b_jonas> it just depends on where you come from
06:03:27 <Peaker> nub, Monad, Functor, null, tail, init, etc
06:03:36 <b_jonas> different languages use different names for things
06:03:41 <mauke> nub is cute albeit too short
06:03:48 <mauke> null and tail are fine
06:04:21 <Peaker> null -> isEmpty,  nub -> uniquify/removeDuplicates, tail -> next?, init -> withoutLast, ...
06:04:32 <vixey> you can rename these
06:04:33 <mauke> "next" would be wrong
06:04:35 <Deewiant> tail -> withoutFirst
06:04:40 <vixey> isEmpty = null
06:04:43 <Peaker> Deewiant, that's good
06:04:50 <mauke> yeah, and filter -> removeIfNot
06:04:52 <mauke> no, thanks
06:04:56 <Peaker> vixey, yeah but then I will find it hard to read other's code and converse about it, right?
06:05:02 <Deewiant> but, head/tail/init/last are so common it's worth learning them
06:05:06 <Deewiant> much better than car/cdr
06:05:07 <Deewiant> :-P
06:05:08 <vixey> Peaker: no not really
06:05:15 <Peaker> mauke, filter is ok, it conveys the meaning though keepIf or removeIfNot are ok too
06:05:16 <b_jonas> (head, tail, init, last) is just shorter than (first, rest, most, last) and those are common functions
06:05:21 <b_jonas> especially the first two
06:05:24 <mauke> Peaker: no, they aren't
06:05:34 <b_jonas> (there's a third scheme too)
06:05:39 <mauke> composite names should be avoided when a good alternative exists
06:05:41 <Peaker> Deewiant, I "learned" them but I still have to re-remember what "init" means every time. The first thing I think when I see "init" is something is being initialized
06:05:55 <b_jonas> null rocks I think
06:05:58 <Deewiant> then you just need to code more ;-)
06:06:04 <Deewiant> or read more code, whichever
06:06:33 <Peaker> Deewiant, that's a waste of time, if the alternative is using better names and using that time for better purposes :)
06:07:01 <b_jonas> lisp predates haskell and it has bad names like rplca, but we should keep the good names like map or null
06:07:21 <b_jonas> ah, it's actually rplaca
06:07:23 <Peaker> b_jonas, map is ok. null is not great but not horrible.  init is one of the worse names, as is nub...
06:07:24 <Deewiant> I honestly think stuff like withoutLast is much worse than init, too much verbosity
06:07:26 <mauke> except lisp calls it MAPCAR :-)
06:07:33 <vixey> (setf (car ...) ...) is preferred
06:07:42 <Deewiant> init and nub are bad, I agree, but changing them to 15-letter monstrosities is worse :-P
06:07:42 <Peaker> Deewiant, its explicitness - not verbosity :)
06:07:56 <b_jonas> well, init could be most or behead or butfirst
06:07:59 <Deewiant> my point is that everybody will run into these sooner or later
06:08:02 <Peaker> Deewiant, what's wrong with 15 letters?
06:08:02 <b_jonas> the problem with init is this:
06:08:10 <Deewiant> so there's no need to be explicit
06:08:12 <mauke> Peaker: hard to read, hard to write
06:08:16 <vixey> > init "what"
06:08:17 <lambdabot>  "wha"
06:08:29 <b_jonas> first/rest/last/most works; head/tail works too but it can't be completed to four
06:08:33 <Peaker> mauke, I think "init" is hard to read, and M-x is easy to write..
06:08:46 <mauke> Peaker: yeah, but you're wrong :-)
06:08:55 <vixey> M-x ?
06:08:57 <b_jonas> there's first/butfirst/last/butlast from logo or head/behead/tail/curtail from j but those are stupid
06:08:59 <Peaker> oops M-/
06:09:01 <b_jonas> so init is the best they could find
06:09:20 <b_jonas> I honestly don't know what init should be called
06:09:24 <Peaker> b_jonas, I think each of those other schemes is better than what Haskell has now
06:09:36 <mauke> .oO( cotail )
06:09:41 <vixey> Haskell is Haskell
06:09:41 <b_jonas> what does standard ml have? hd, tl, ?
06:09:55 <vixey> if you don't like it just do what I said
06:09:59 <b_jonas> cohead and cotail lol
06:10:04 <vixey> it's not going to your code less understandable
06:10:25 <Peaker> vixey, The main probably is readability, not writeability
06:10:32 * b_jonas looks up standard ml
06:10:48 <Peaker> vixey, I don't mind it for my own use which can be fixed as you say - I mind it because I want to be able to easily read others' code
06:10:56 <vixey> you can't remember what init does?
06:11:19 <vixey> but you can understand the various levels of totally new abstractions in someones code
06:11:20 <Peaker> vixey, Its hard to remember, as "initialization" is the first thing that comes to mind - and there are many names except it
06:11:37 <Peaker> vixey, I have SDL.init for example
06:11:46 <mauke> "initialization" is a derived concept
06:11:56 <vixey> I'd say that's a really bad name
06:12:02 <vixey> SDL.initialize
06:12:03 <mauke> "init-" refers to the first part of something
06:12:08 <vixey> is better
06:12:21 <b_jonas> hmm, it has hd, tl, last, but no fourth function
06:12:34 <mauke> to initialize something is to put it in the starting state
06:12:39 <Peaker> vixey, init/fini are common names/idioms in many architectures/languages
06:12:44 <b_jonas> dunno
06:13:05 <Peaker> mauke, I'd expect init to be head then - by that meaning
06:13:12 <mauke> Peaker: right
06:13:13 <vixey> never heard of fini before
06:13:26 <Peaker> vixey, initialize/finalize, init/fini
06:13:26 <mauke> the only place I've seen init/fini is the old library interface here
06:13:39 <mauke> Peaker: I'd prefer init/exit for that
06:14:04 <Peaker> mauke, the opposite of exit is enter though..., init/fini, start/stop, begin/end, etc.
06:14:12 <mauke> "init" means enter
06:14:32 <mauke> "init" means "go in", "exit" means "go out"
06:14:38 <opqdonut> no it doesn't
06:14:40 <b_jonas> it's not that clear
06:14:48 <mauke> IT DOES NOW
06:14:50 <Peaker> btw I can't find the "first part of" definition of init in the wiktionary
06:14:54 <b_jonas> because actually begin/finish and start/end would make more sense to me
06:15:04 <b_jonas> but we're used to begin/end from algol
06:15:05 <Deewiant> Peaker: "initial"
06:15:14 <b_jonas> also isn't it enter/leave?
06:15:44 <Peaker> Deewiant, ah, then at best call it initial - given that init has other more dominant connotations
06:16:11 <Deewiant> but "initial" could also be short for "initialize", neh? :-)
06:16:19 <Peaker> Deewiant, Have never seen it used that way
06:16:57 <b_jonas> and maybe init/cease
06:17:00 <b_jonas> dunno
06:17:07 <b_jonas> but what would stop pair with then?
06:17:25 <mauke> start/stop
06:17:46 <mauke> well, depends on which "stop" we need
06:18:04 <mauke> er, start
06:18:35 <mauke> stop/go
06:18:43 <b_jonas> actually, we could have start/stop, init/finish, begin/cease, since end is often unpaired as in foo .. endfoo
06:18:59 <mauke> play/pause/stop
06:19:04 <b_jonas> heh
06:19:10 <b_jonas> goto/comefrom
06:19:23 <mauke> defun/undef
06:19:52 <b_jonas> and there's the elif - elsif - elseif - else if thingy
06:20:21 <vixey> else { if
06:20:32 <mauke> elseif looks ugly and elif is just weird
06:20:53 <vixey> elif is 4 chars
06:20:59 <b_jonas> if it was always spelt the same, it would be easy
06:21:01 <vixey> I guess that's the motivation
06:21:03 <Vq^> mauke: it looks less weird when you get used to it
06:21:12 <Vq^> mauke: just like bananas
06:23:46 <vixey> nested datatypes are confusing
06:24:09 <mauke> @vixen how do I polymorphed recursion?
06:24:10 <lambdabot> however you want
06:24:15 <vixey> http://blog.jbapple.com/2008/02/name-that-type-nested-types-edition.html
06:25:57 <b_jonas> is that like http://byorgey.wordpress.com/2007/10/01/higher-dimensional-enumeration/ ?
06:25:58 <lambdabot> Title: Higher-dimensional enumeration « blog :: Brent -> [String], http://tinyurl.com/yrn7v8
06:38:16 <Peaker> maybe I should reimplement FRP from scratch to learn about it :P
06:40:55 <lilac> i have 2000 lines of terrible haskell code i'd like to make suck less. where / how should i start?
06:41:25 <mauke> ghc -Wall
06:41:34 <Peaker> Hey I only have 700 sucky lines :)
06:41:59 <Peaker> -Wall forces you to place all the type signatures -- is that good practice?
06:42:04 <lilac> wow, that's a lot of warnings
06:42:31 <mauke> Peaker: IMHO yes
06:43:34 <Peaker> I always saw type inference as the best of both worlds - the lack of redundant specifications (as in Python) with the error-checking and optimization benefits of full specifications
06:44:00 <Peaker> it feels as though that negates it..
06:44:20 <lilac> Peaker: it also gives you error messages in the wrong places
06:44:37 <ddarius> There's a difference between annotating the type of top-level functions and annotating every variable you declare.
06:44:56 <lilac> miss out a return, and you might get a type error in the caller's caller's caller
06:45:25 <mauke> also, I like to code by writing the type signatures first and leaving the body undefined
06:45:35 <mauke> that way you can incrementally test things in ghci
06:46:21 <Peaker> mauke, wouldn't it fail to compile at all that way?
06:46:29 <ddarius> Peaker: A specification is something you provide, not something the compiler infers.
06:46:53 <mauke> Peaker: no, why?
06:48:40 <Peaker> mauke, when you specify the type of something undefined it doesn't like that (or do you mean you define everything to be "undefined" specifically?)
06:48:47 <vixey> lilac, what does the code do?
06:49:09 <lilac> vixey: it's about half of a c tokenizer + preprocessor
06:49:43 <ddarius> It's taking you 2000 lines just to tokenize C?
06:49:59 <mauke> Peaker: yeah, I just write 'foo = undefined'
06:50:03 <Peaker> mauke, oh
06:50:11 <sclv> Is there an easy way to quickCheck functions that perform IO?
06:50:12 <mauke> self-documenting code :-)
06:50:40 <vixey> lilac: paste it?
06:50:48 <vixey> ( rafb.net/paste )
06:50:49 <lilac> ddarius: only 320 lines of tokenizing. the rest is the other things you need to do (trigraphs, line splicing, ...)
06:51:15 <lilac> vixey: tis split over 12 files
06:51:32 <allbery_b> people care about trigraphs?
06:51:32 <lilac> vixey: if that's ok, i'll paste it
06:51:50 <lilac> allbery_b: i'm trying to be standards-compliant
06:52:21 <vixey> sure
06:52:38 <vixey> (btw what's the point in parsing C?)
06:52:50 <lilac> vixey: the goal is to parse C++ ;-)
06:53:25 <lilac> vixey: (1) learn haskell, (2) learn more about c++, (3) hopefully make something useful in the process
06:53:41 <vixey> wow ok
06:53:49 <vixey> cool
06:53:51 <lilac> not at all ambitious ;-)
06:54:14 <mauke> hah, parsing C++
06:54:17 <mauke> good luck :-)
06:54:29 * Peaker also is fixing all the warnings from -Wall now... yikes
06:54:39 <vixey> maximal munch will be fun
06:54:57 <vixey> repeating terrific design mistakes
06:55:02 <mauke> you might want to practise with Perl first; it's probably easier
06:55:10 * Vq^ didn't know C++ was parseable
06:55:19 <ddarius> With perl you only need to write a perl interpreter.
06:55:45 <Vq^> scheme is also a fun excercise
06:55:46 <vixey> oh I read this today
06:56:41 <ddarius> lilac: You may want to look at this: http://www.computing.surrey.ac.uk/research/dsrg/fog/
06:56:42 <lambdabot> Title: FOG - Flexible Object Generator
06:57:43 <lilac> i've pasted my monster here: http://rafb.net/p/37Djtu55.html
06:58:27 * sclv sighs and goes off to write a monadic quickcheck driver
06:59:07 <lilac> vixey: max munch isn't too hard with parsec
06:59:18 <sclv> unless anyone knows... does qc2 have one already?
06:59:41 <lilac> vixey: especially since, in all cases but one, every prefix of a legal operator is itself an operator.
06:59:48 <lilac> symbolic operator at least
06:59:54 <Peaker> -Wall complains about a guarded pattern-match that is exhaustive that it isn't exhaustive, is it better to have a wrong "otherwise" case with an error, or ignore the warning, or?
07:00:11 <mauke> Peaker: depends
07:00:38 <lilac> Peaker: can you rewrite the matching so that ghc can tell it's exhaustive?
07:00:40 <Peaker> mauke, I have a data Player = White | Black   and I have a guard that matches White, and another that matches Black, and its complaining
07:00:54 <mauke> that seems wrong
07:00:59 <mauke> can you paste the code somewhere?
07:01:10 <Peaker>   pawnJumpAllowed board (Pos (_, y))
07:01:10 <Peaker>       | bPlayer board == Black  =  (1 == y)
07:01:10 <Peaker>       | bPlayer board == White  =  (6 == y)
07:01:30 <lilac> ah, pattern guards, my old nemesis
07:01:50 <Peaker> I could have it call a pawnJumpAllowed' internal function with bPlayer board and then the pattern is over an argument
07:02:09 <mauke> Peaker: why not use 'otherwise' there?
07:02:18 <Peaker> mauke, because it would never happen
07:02:27 <lilac> Peaker: as in, replace the == White with otherwise
07:02:32 <Peaker> oh
07:02:43 <mauke> pawnJumpAllowed board (Pos (_, y)) =
07:02:44 <Peaker> I guess I could, I think its a little less clear that way though
07:02:48 <mauke>     case bPlayer board of
07:02:55 <mauke>         Black -> 1 == y
07:02:59 <mauke>         _ -> 6 == y
07:03:09 <mauke> or use White instead of _
07:03:12 <Deewiant> Peaker: alternatively, add otherwise = error "this can't happen" or something
07:03:15 <mauke> it shouldn't warn about that
07:03:30 <Peaker> Deewiant, Yeah I don't like dead code though
07:03:44 <lilac> vixey: have you died of shock from looking at my code? ;-)
07:03:49 <Peaker> mauke, yeah a case works, thanks
07:04:04 <Deewiant> I think dead code is okay when it's a sort of compile-time assertion like that
07:05:37 <ddarius> Deewiant: That is a particularly bad case.  You'd get a better error message without the extraneous case and a compile-time warning if that case should ever become possible.
07:05:40 <cjb> ~/
07:06:31 <Deewiant> ddarius: wasn't the case here that we got a compile-time warning even though it's /not/ possible?
07:06:43 <Deewiant> (TBH I didn't follow the discussion that much so I could be wrong)
07:07:32 <ddarius> Deewiant: Yes, but that's less of an issue than getting no warning and a not particularly informative error message and added unnecessary code.
07:08:00 <ddarius> Also, the issue is easily resolved without adding extra cases.
07:08:02 <Deewiant> of course I wouldn't put that kind of an error message in real code :-P
07:08:36 <Deewiant> ddarius: is it? Now we use "6 == y" even if, some time in the future, we add another possibility and forget to change that function.
07:08:59 <cjs> What's the current situation with overloaded Strings? Is that going to become a standard thing that will, e.g., work with ByteStrings?
07:09:01 <ddarius> Deewiant: An explicit case would be best. case ... of Black -> ... ; White -> ...
07:09:19 <Deewiant> and the compiler doesn't warn? if so, great :-)
07:09:28 <Peaker> ddarius, Deewiant : mauke's solution of using a case on a specific value rather than a guard on an open boolean expression got the best of both - I specify specifically the two cases, and the compiler is smart enough to understand that's exhaustive so there's no warning
07:09:43 <Deewiant> great
07:09:56 <Peaker> yay, -Wall gets no warning now
07:12:55 <lilac> :t pos
07:12:57 <lambdabot> Not in scope: `pos'
07:13:01 <Peaker> oh man, tie rules in chess are hard...
07:13:02 <vixey> Actually you can't parse Perl without executing it and since there's no other implementation for Perl 5 than perl5, you have to rely on that one implementation.
07:13:03 <vixey> So if you want to change perl 5's syntax you have to dig into C and yacc/bison code and recompile perl, or write a source filter. But if you want to write a correct source filter, you have to parse perl - which is impossible, as just discussed.
07:13:38 <vixey> lilac: ops = $( [| words "{ } [ ] # ## ( ) <: :> <% %> %: %:%: ; : ...  ? :: . .* + - * / % ^ & | ~ ! = < > += -= *= /= %= ^= &= |= << >> >>= <<= == != <= >= && || ++ -- , ->* ->" |] )
07:13:52 <vixey> lilac: rather than ops = words "{ } [ ] ..." ?
07:14:00 <lilac> umm
07:14:23 <vixey> @src on
07:14:23 <lambdabot> (*) `on` f = \x y -> f x * f y
07:14:32 <Peaker> C would have been much simpler if * the type-operator, and * the dereferencer were postfix rather than prefix...
07:14:36 <vixey> by = on
07:15:00 <Peaker> wouldn't need any precedence rules between type operators, wouldn't need the silly "->" operator
07:15:00 <mauke> ah, lovely C++
07:15:22 <Peaker> vixey, what's ->" ?
07:15:24 <lilac> vixey: oops... i was planning on building the op parser at compile time with TH, but it looks like i nefer got around to it
07:15:29 <Peaker> oops, nm :-)
07:15:55 <mauke> lilac: which operator doesn't have a legal prefix?
07:16:12 <vixey>   (char 'n' >> return '\n') <|>
07:16:13 <lilac> mauke: %:%:
07:16:17 <vixey> might be rewritten as
07:16:23 <mauke> argh, digraphs
07:16:24 <vixey> 'n' --> '\n' <|>
07:16:28 <vixey> by the way
07:16:40 <mauke> ## isn't a real operator anyway
07:16:42 <vixey> if you defined c --> h = char c >> return h
07:17:18 <lilac> :t (-->)
07:17:20 <lambdabot> parse error (possibly incorrect indentation)
07:17:42 <vixey> :t let c --> h = char c >> return h in (-->)
07:17:44 <lambdabot> parse error (possibly incorrect indentation)
07:18:01 <vixey> well it's valid haskell
07:18:09 <sclv> and there... a monadic quickcheck driver, for testing impure functions.
07:18:14 <gubagem> --> is a valid arrow??
07:18:15 <vixey> :t let c ~~> h = char c >> return h in (~~>)
07:18:17 <lambdabot>     Couldn't match expected type `m a' against inferred type `Doc'
07:18:17 <lambdabot>     In the first argument of `(>>)', namely `char c'
07:18:17 <lambdabot>     In the expression: char c >> return h
07:18:31 * sclv is so sure there's got to be a preexisting thing that does this.
07:18:43 <vixey> :t char
07:18:45 <lambdabot> Char -> Doc
07:18:59 <vixey> @src Doc
07:18:59 <lambdabot> Source not found. You speak an infinite deal of nothing
07:19:04 <vixey> @index Doc
07:19:04 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
07:19:39 <lilac> vixey: --> works, thanks, that makes that less ugly
07:19:53 * Botje votes that undefined be renamed the "yadayada" value
07:20:04 <Botje> that's waht i'm using it for, at least :)
07:21:29 * byorgey hands out gingersnap lambdas!
07:22:09 <byorgey> I've missed you all
07:22:14 <Botje> welcome back :)
07:22:20 * byorgey initiates slightly awkward group hug
07:22:48 * Botje group hugs
07:22:49 <opqdonut> :D
07:22:54 * gubagem puts bunny ears behind byorgey and takes a snapshot with his nonexistant digital camera
07:22:54 <Botje> pretty lame group hug, though :P
07:23:04 * gubagem hugs everyone
07:23:32 <gubagem> lets all sit down and have a love in
07:24:17 <vixey> I don't like '\'' much
07:24:23 <vixey> not sure if '''' is better
07:24:27 <gubagem> for lambdas?
07:24:41 <vixey> char
07:24:43 <Deewiant> vixey: head "'" ;-)
07:25:29 <mar77a> how would i go around looping through the lines (file_contents) with a sort of index
07:25:31 <lilac> didn't realise '''' was legal :)
07:25:46 <Deewiant> > ''''
07:25:47 <lambdabot>  Improperly terminated character constant at "'" (column 4)
07:25:52 <Deewiant> didn't think so :-P
07:26:02 <vixey> It's legal Prolog....
07:26:03 <gubagem> mar77a: pass a linecount variable around
07:26:05 <mar77a> say i have a text file with Name\nPhone\nName2\nPhone2... and i want to loop through that
07:26:20 <byorgey> mar77a: try zipping with [0..] first
07:26:29 <mar77a> ah
07:26:44 <lilac> vixey: let a' = '\'' in ... :)
07:26:52 <byorgey> > zip [0..] (lines "Name\nPhone\nName2\nPhone2")
07:26:53 <lambdabot>  [(0,"Name"),(1,"Phone"),(2,"Name2"),(3,"Phone2")]
07:27:12 <byorgey> and then you can map a function over that which makes use of the indices if you like
07:27:14 <sclv> oh... I see... monadic quickcheck is not so easy
07:27:32 <vixey> lillac aha
07:27:35 <sclv> I'm always a bit quick to the draw on this stuff
07:29:23 <mar77a> @hoogle readfile
07:29:23 <lambdabot> Prelude.readFile :: FilePath -> IO String
07:29:23 <lambdabot> System.IO.readFile :: FilePath -> IO String
07:29:23 <lambdabot> Data.ByteString.readFile :: FilePath -> IO ByteString
07:29:59 <opqdonut> @unmtl Reader a a
07:30:00 <lambdabot> a -> a
07:30:03 <opqdonut> mhmm
07:30:06 <gubagem> doesnt getContetns do the same thing
07:30:19 <gubagem> s/  /getContents
07:30:27 <lilac> getContents :: IO String
07:30:35 * bos weeps over the QuickCheck manual
07:30:47 <vixey> @unmtl Reader a b
07:30:47 <lambdabot> a -> b
07:31:25 <vixey> :t on :: Reader (Reader b (Reader b c)) (Reader (Reader a b) (Reader a (Reader a c)))
07:31:27 <lambdabot>     Couldn't match expected type `Reader
07:31:27 <lambdabot>                                     (Reader b (Reader b c))
07:31:27 <lambdabot>                                     (Reader (Reader a b) (Reader a (Reader a c)))'
07:31:44 <opqdonut> vixey: Reader is a newtype
07:31:45 <opqdonut> not a type
07:31:49 <opqdonut> ?src Reader
07:31:49 <lambdabot> Source not found. You type like i drive.
07:31:51 <vixey> :(((
07:32:05 <vixey> @unmtl Reader (Reader b (Reader b c)) (Reader (Reader a b) (Reader a (Reader a c)))
07:32:05 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
07:32:18 <opqdonut> newtype Reader a b = Reader { runReader :: a->b }
07:32:21 <opqdonut> something like that
07:32:42 <vixey> @unmtl RWSS
07:32:43 <lambdabot> RWSS
07:32:45 <vixey> @unmtl RWST
07:32:45 <lambdabot> err: `RWST' is not applied to enough arguments, giving `/\A B C D E. A -> C -> D (E, C, B)'
07:33:01 <Deewiant> @unmtl RWST a b c d e
07:33:02 <lambdabot> a -> c -> d (e, c, b)
07:33:31 <vixey> @unmtl RWST (RWST a b c d e) (RWST a b c d e) (RWST a b c d e) (RWST a b c d e) (RWST a b c d e)
07:33:31 <lambdabot> err: `a -> c -> d (e, c, b)' is not a type function.
07:36:10 <vixey> ?where lambdabot
07:36:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
07:37:42 <vixey> rwsT :: T -> T -> T -> (T -> T) -> T -> T
07:37:42 <vixey> rwsT r w s m a  = r --> s --> m (tuple [a, s, w])
07:38:14 <lilac> vixey: so how bad is my code? (be honest, i can take it...)
07:39:10 <vixey> lilac: It seems good
07:40:06 <lilac> vixey: have you got as far as Cpp.hs yet?
07:40:23 <vixey> yes
07:43:24 <vixey> lilac are you going to make it return an AST at some point?
07:44:38 <lilac> yes, eventually, once i get more of the preprocessing done
07:44:40 <lilac> :)
07:44:45 <vixey> cool
07:45:14 <lilac> i think the remaining major work items are #if and #include (#include shouldnt' be too hard tho)
07:46:28 <lilac> when run interactively, it has a weird issue -- it requires two newlines after the close bracket of a function-like macro instance before it gives the result of the expansion. i can't see what i've done wrong -- any ideas?
07:47:13 <vixey> @unmtl RWST (RWST a b c d e) (RWST a b c d e) (RWST a b c d e) x (RWST a b c d e)
07:47:13 <lambdabot> (a -> c -> d (e, c, b)) -> (a -> c -> d (e, c, b)) -> x (a -> c -> d (e, c, b), a -> c -> d (e, c, b), a -> c -> d (e, c, b))
07:51:14 <Deewiant> @djinn (a -> c -> d (e, c, b)) -> (a -> c -> d (e, c, b)) -> x (a -> c -> d (e, c, b), a -> c -> d (e, c, b), a -> c -> d (e, c, b))
07:51:14 <lambdabot> -- f cannot be realized.
07:53:10 <Feuerbach> is it possible for lhs2TeX to translate Haskell's a^bc to TeX's a^{bc}?
07:53:47 <lilac> is there any way to get a backtrace or similar from a running haskell process?
07:55:04 <lilac> i have essentially got a read-parse-print loop, and i want to know what path through my parser is forcing a read when i don't think any lookahead is needed
07:58:15 <opqdonut> ghci has a debugger
08:00:02 <hpaste>  morrow pasted "Main.c (really)" at http://hpaste.org/7859
08:05:39 <sclv> monadicIO :: PropertyM IO a -> Property
08:05:39 <sclv> monadicIO (MkPropertyM m) =
08:05:40 <sclv>   property $
08:05:40 <sclv>     unsafePerformIO `fmap`
08:05:42 <sclv>       m (const (return (return (property True))))
08:05:44 <cjs> lilac: Debug.Trace?
08:05:52 <sclv> ^^ quickCheck2 u break my heart
08:06:07 <vixey> what's wrong with this code?
08:06:40 <mnislaih> lilac: http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html#tracing
08:06:40 <lambdabot> Title: 3.5. The GHCi Debugger, http://tinyurl.com/2nxab2
08:07:00 <vixey> ?check \x -> fst x == snd x -- I like this
08:07:03 <sclv> vixey, that code? the unsafePerformIO of course. I was hoping qc2 was smarter than I was.
08:07:03 <lambdabot>  OK, passed 500 tests.
08:07:22 <vixey> sclv: I don't see what's wrong with it ?
08:07:43 <sclv> the problem is how to test properties that aren't pure -- i.e. involve io.
08:08:01 <sclv> the answer seems to be "you need to use unsafePerformIO to do so"
08:08:11 <vixey> well you could use unit tests
08:08:18 * sclv gags
08:08:20 <opqdonut> sclv: have you looked at htest
08:08:23 <vixey> what?
08:08:47 <vixey> sclv: do you just dislike unsafePerformIO because it's got unsafe in the name?
08:08:49 <opqdonut> or what ever the unit test lib was called
08:09:06 <sclv> yeah, I'm familiar with hunit.
08:09:23 <opqdonut> yeah hunit it was
08:09:30 <sclv> vixey: because there should really be a more elegant way to do this.
08:09:51 <vixey> sclv: I don't really understand your point of view at all
08:10:00 <sclv> but mixing an arbitrary monad with the, ahem, "Arbitrary" monad doesn't work.
08:10:20 <sclv> conceptually what I'm doing shouldn't need unsafePerformIO is all..
08:10:30 <lilac> mnislaih, opqdonut: i'm having a hard time getting anything useful from that. i have no idea where i should set a breakpoint, and i can't get ghci to show me history if i exit via Ctrl-C.
08:11:03 <sclv> I have no objections to using unsafePerformIO when yr. genuinely doing something to extend the language, but in this case, its just running a bunch of unit tests, and quickCheck is already in the IO monad to begin with.
08:11:06 <mnislaih> lilac: use -fbreak-on-exception if you want to exit via Ctrl-C. The docs are great, make sure you look at them
08:11:13 <sclv> s/unit//
08:12:11 <lilac> mnislaih: i did not realise Ctrl-C was regarded as an exception, so skipped the 'Debugging exceptions' section. thanks!
08:12:38 <sclv> on the other hand, promiscuous use of unsafePerformIO in testing code is much better than in production code...
08:13:45 <ndm> sclv, i don;'t see the problem with unsafePerformIO - I've used it loads of times
08:13:55 <ndm> you have to be careful, but its not evil just because its used
08:14:11 <sclv> ndm: I know. I use it too. I just hate using it where I think there must be a cleaner way.
08:14:29 <ndm> sclv, its perfectly clean as long as you abstract it into a safe manner
08:14:59 <sclv> the concrete problem at hand is to run quickChecks on properties that involve IO.
08:15:09 <ndm> similarly to something like Typeable and SYB, i feel - not very good idea to use them directly, but once they are nicely abstracted, that's fine
08:15:25 <ndm> yep, i've seen that - smallcheck has exactly the same issue and solution
08:15:40 <ndm> its testing, so by rights its something that can be a little unsafe, as long as it models your program
08:16:02 <sclv> right... I'm working on a library for quickchecking CGI actions.
08:16:40 <sclv> I did the easy part, now I'm getting a significant headache.
08:16:57 <ndm> why is unsafePerformIO not suitable?
08:17:26 <sclv> it is, I was just hoping that it wouldn't have to be... there are still headaches to come anyway though.
08:18:21 <ndm> my suggestion would be just unsafePerformIO, then clean up later - if you can
08:19:59 <sclv> the tricky part is stashing it in the right place in my code so that at least its invisible to the end user...
08:20:17 <vixey> don't hide things from the user!
08:20:31 <vixey> let users = programmers
08:21:04 <sclv> the point of this library is to abstract away the difficulty of writing test code for web stuff.
08:21:07 <ndm> vixey: you should definately hide unsafePerformIO from end users!
08:21:21 <sclv> I don't want to be writing unsafePerformIO every time I use it any more than anyone else would.
08:21:24 <ndm> sclv, which would work for something like Hoogle?
08:21:36 * ndm is writing a test framework for Hoogle on Monday
08:22:31 <sclv> I guess. I can't quite t get the signatures right, but the idea is something like quickCheckCGI :: (Testable a) => (CGI CGIResult -> a) -> CGI CGIResult -> IO ()
08:22:52 <sclv> the tricky bit is giving the user the freedom to generate the requests cleanly.
08:22:58 <cjs> sclv: Have you just considered changing your library interface to get most of the stuff out of IO?
08:23:26 <sclv> cjs: the problem is that CGI actions are in IO, full stop, or usually at least.
08:23:55 <cjs> It seems to me that you could have an interface with some data type for the input, and output via ByteString, and you just need a little bit of IO stuff to build and send that.
08:24:01 <sclv> ndm: there will also be a checkCGIConcurrent function that runs multithreaded for concurrency issues.
08:24:18 <cjs> sclv, what libraries are you using that have stuff in IO?
08:24:43 <sclv> cjs: CGI. The point is to test any arbitrary action in the CGI monad. the CGI monad is a writer around a reader around IO.
08:24:53 <sclv> IO is baked in.
08:25:26 <sclv> ndm: what sort of scheme are you thinking of for hoogle?
08:25:43 <ndm> sclv, i start thinking on Monday - i want to test it in some way, it is a CGI program
08:26:06 <twanvl> can't you use CGIT SomeOtherMonad?
08:26:15 <sclv> heh, maybe I'll have finished something usable by then.
08:26:45 <ddarius> @check \x -> (fst x :: Int) == snd x
08:26:46 <lambdabot>  Falsifiable, after 0 tests: (-3,-2)
08:26:59 <sclv> twanvl: well, I could. but generally people don't. and generally I don't. Especially with FastCGI where it's fixed to CGIT IO
08:27:34 <sclv> and checking FastCGI is more interesting than checking CGI anyway, because there are more state issues.
08:28:31 <cjs> Really? What are the extra state issues?
08:29:15 <sclv> since fastcgi is long-running, you share state (via MVars, etc) between requests.
08:29:38 <sclv> so you want to do testing that can expose if your concurrency logic is borked.
08:31:10 <cjs> Ah.
08:31:28 <cjs> Gha, looking through this just reminds me that the whole "CGI" interface is f**ked.
08:31:46 <sclv> its not too bad, just not pleasant for streams.
08:32:04 <sclv> I tend to be on the side of serving web stuff strictly 99% of the time anyway though.
08:32:21 <cjs> Well the awful thing about it is that it translates HTTP requests into another format, getting dodgy with the data in the process.
08:32:30 <sclv> users expect that either a page returns or does not.
08:32:36 <cjs> And FastCGI is more painful, because it does the same thing unnecessarially.
08:33:02 <sclv> cjs: do you mean the mixing get and post var thing, or the encoding thing...?
08:33:24 <sclv> no escaping for cookies makes me sad, btw. :-(
08:33:35 <cjs> I mean not just simply handing the request, whole, to appropriate parsing routines.
08:33:59 <cjs> Which can at least be done with FastCGI, where you get the actual request, along with an environment. (CGI doesn't give you this.)
08:34:47 <sclv> oh, because FastCGI is designed to go through the standard CGI setup?
08:34:52 <cjs> I've been nailed quite a few times by the extra parse/unparse stage in Ruby's FastCGI library.
08:35:41 <cjs> Yeah, basically the fast CGI protocol sends the request over without processing, and then the server library tries to make it look as if it were parsed into environment variables as the CGI "protocol" does.
08:37:09 <sclv> ah, so no way to fix that without breaking the CGI/FastCGI common interface though?
08:37:11 <cjs> I've been meaning to write a new version of a FastCGI library for Ruby for years, but never got around to it. (Though I probably need to do it to support x-sendfile, since the current library seems to kill my attempts to generate a valid header using that.) If I ever do any web work in Haskell, I'll quite likely start out by writing my own FastCGI library.
08:37:23 <cjs> No, but the interface sucks so badly, I wouldn't be too worried about it.
08:37:58 <sclv> well, true that.
08:38:02 <cjs> CGI performance is so bad anyway that it's best avoided.
08:38:36 <cjs> And FastCGI with lighttpd can actually be faster than lighttpd serving files directly, if you use x-sendfile and get a bit clever.
08:39:03 <cjs> Well, actually, that would be heavily dependent on the situation, but...
08:39:48 <cjs> And in fact I may be completely wrong about that, come to think about it. But still, getting it as fast as static, while still returning different content for the same URL based on some processing, should be no problem.
08:43:41 <cjs> Anyway, a pet peeve of mine. Ignore me.
08:43:46 <sclv> quickCheckCGI (\x s -> inBody (show (s::Int)) $ doCGI (setPost "foo" (show s) basicEnv) x) (setHeader "foo" "bar" >> getInput "foo"
08:43:54 <sclv> >>= \(Just x) -> output ("asdffooasdf" ++ x))
08:44:05 <sclv> OK, passed 100 tests.
08:44:08 <sclv> whoo!
08:44:28 <sclv> still a pretty ugly api, but at least it works.
08:45:21 <cjs> (Oh, I forgot to mention the destruction of URI information. But I'll stop now.)
08:45:33 <sclv> cjs: yeah, I ran into that too.
08:45:50 * edwardk wakes up and joins the human race.
08:46:00 <sclv> lighttpd actually has some bugs in that dept.
08:46:06 <ddarius> edwardk: You just missed them.
08:46:27 <edwardk> yeah nobody told me when to run, I missed the starting gun.
08:46:50 <sclv> the ratrace is just coming by now though.
08:47:03 <edwardk> ddarius: i'm actually liking the Yoneda monad transformer. its actually useful =)
08:47:03 * ddarius feels like listening to "Hopeless Housewife" now.
08:47:46 <ddarius> edwardk: for?
08:47:51 <edwardk> ddarius: if you have a comparatively expensive bind operation the resulting 'fmap' is more efficient than the liftM version.
08:48:05 <edwardk> because fmaps get batched up in the (a -> b) and applied during the next bind
08:48:37 <ddarius> What does your Yoneda monad transformer look like?
08:48:42 <edwardk> similarly CoYoneda seems to have the same nice properties for comonads
08:49:01 <edwardk> newtype Yoneda f a = Yoneda { runYoneda :: forall b. ((a -> b) -> f b) }
08:49:04 <cjs> sclv: The problem is, there's no accepted standard for how to decompose the URI info, which means of course no proper way to recompose it.
08:49:21 <edwardk> instance Functor (Yoneda f) where fmap f m = Yoneda (\k -> runYoneda m (k . f))
08:49:46 <cjs> But yeah, I've been bitten by lighttpd on that score. Sometimes you just have to know what's in the config file.
08:49:51 <edwardk> which lets you see that you batch up the fmaps in the 'continuation'
08:49:59 <Peaker> yay, my chess thing identifies draw/wins now
08:50:04 <Peaker> draw is difficult to identify in chess!
08:50:11 <sclv> reading the network.http comments its like a singly forlorn cry of "why is this not a real standard? oh why? oh why?"
08:50:18 <Heffalump> well, it requires a lot of history
08:50:24 <cjs> My standard practice is to run *everything* to the FCGI backends, and let them serve the "static" files as well. When that's possible, anyway.
08:50:45 <edwardk> Then:  m >>= k = Yoneda (\f -> runYoneda m id >>= \a -> runYoneda (k a) f)    -- note the application of f, because we can slide the bind 'left' over the function from (a -> b)
08:50:56 <Peaker> Heffalump, tsDullCounter :: Int, tsSeen :: Map.Map (Army, Army) Int -- and updating them, whew
08:51:35 <Peaker> Heffalump, (where dull means capture-less and without pawn moves, and reaching 50 is an extra way to have a draw)
08:51:56 <Heffalump> and you just drop the map and reset the counter when a capture/pawn move happens?
08:52:01 <Peaker> Heffalump, and the map remembers all visited states within the last dull sequence because a 3-time visit to the same state is a draw
08:52:05 <edwardk> so while the Ran m m monad for a monad m has the operational characteristics of the ContT monad transformer. this maintains the same cost for bind as the original monad, while just batching up fmaps to be applied when you extract from Yoneda f a -> f a or until the next bind.
08:52:10 <Peaker> Heffalump, yeah
08:53:06 <edwardk> another interesting quirk is that you can lift comonadic operations into coyoneda cheaply, and they batch up fmap in the 'experiment' side of the resulting near-context comonad.
08:53:19 <sclv> edwardk: nice! this is what that Stream example the other day was buying me too...
08:53:55 <sclv> (when Streams are Chans, fmap is not only very expensive, its not even there by default)
08:54:15 <edwardk> though you could choose to Yoneda a comonad (its a value comonad transformer as well), CoYoneda is the only case likely to get you a performance win
08:54:58 <edwardk> sclv: i've been studying these because there are cases like histomorphisms where you rather inefficiently use the resulting free monad/cofree comonad, so i've gone through and redefined free/cofree to enable me to perform histo futu dyna and chrono over more general monads.
09:01:59 <cjs> Hmph. Haskell can't have a :-) operator. :-(
09:02:19 <vixey> You can have a :-| constructor
09:02:33 <edwardk> or :-/
09:02:51 <Peaker> hehe
09:03:05 <Baughn> Smileys denote global state. You can't have globals /either/ in haskell, so..
09:03:10 <Peaker> ok, I think my chess gui is as playable as any hotseat chess thing out there now
09:03:17 <Peaker> Baughn, say, do you do any UI stuff in Haskell?
09:03:21 <edwardk> data P; type a :- b = [a]; []:-P
09:03:29 <vixey> haha
09:03:30 <edwardk> er data P = P
09:03:36 <Baughn> Peaker: Recently, yes. I'm trying to think up a new opengl-based UI for a game I'm doing
09:03:48 <Peaker> Baughn, are you doing it imperatively or conally?
09:03:49 <Baughn> But so far that just means reading a lot about FRP
09:03:56 <Peaker> Baughn, ah, cool
09:04:08 <edwardk> aand type a :- b = a b
09:04:13 <Baughn> Peaker: Definitely not imperatively. Not sure what "conally" means..
09:04:19 <Peaker> Baughn, FRP :)
09:04:24 <Baughn> Ah.
09:04:34 <mix25> Is there operator for 	
09:04:35 <mix25> intersection
09:04:35 <vixey> [P,P,P,P] :: [] :-P
09:04:36 <Peaker> Baughn, I want a usable FRP library...
09:04:38 <mix25>  in haskell?
09:04:47 <Baughn> mix25: Data.List
09:04:49 <Peaker> Baughn, Yampa seems kind of daunting, and there's no simple tutorial
09:04:51 <doun> you have types, kinds, then what?
09:04:56 <Baughn> mix25: Or Data.Map/Data.Set if you want efficiency
09:05:10 <Peaker> doun, there is just one metakind so it has no name
09:05:12 <vixey> :t intersection
09:05:14 <lambdabot> Not in scope: `intersection'
09:05:19 <Baughn> :t Data.Set.intersection
09:05:20 <Deewiant> :t intersect
09:05:21 <lambdabot> forall a. (Ord a) => S.Set a -> S.Set a -> S.Set a
09:05:22 <doun> :t intersect
09:05:23 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:05:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:05:28 <mauke> :t insect
09:05:29 <lambdabot> Not in scope: `insect'
09:05:45 * doun blinks
09:05:46 <mix25> and the final answer?
09:05:47 <Peaker> :t bug
09:05:49 <lambdabot> Not in scope: `bug'
09:05:55 <Baughn> mix25: "Yes, several different ways"
09:06:35 <vixey> mix25: why do you want to find the intersection?
09:06:39 <Peaker> Baughn, what are your plans regarding FRP? I wouldn't want to do a duplicate of your work
09:06:45 <vixey> mix25: and of what?
09:06:49 <Baughn> Peaker: I started reading yesterday. ;)
09:06:51 <mix25> of list's
09:06:56 <Deewiant> > [1..5] `intersect` [3..8]
09:06:57 <lambdabot>  [3,4,5]
09:07:02 <mix25> yes
09:07:04 <ndm> doun: after types and kinds come sorts - i recommend stopping before you get that far...
09:07:08 <Saizan> Peaker: seen Data.Reactive ?
09:07:17 <Peaker> Saizan, nope, what's that?
09:07:26 <mix25> or [1..3] intersect [4..5] = []
09:07:36 <Baughn> Peaker: I want it to be easy to use and as automatic as possible. Beyond that.. heh, I still haven't decided /how/ to do that, so just do what you like
09:07:54 <doun> ndm: ahh, that's it!
09:07:54 <Baughn> > [1..3] `intersect` [4..5]
09:07:55 <lambdabot>  []
09:08:40 <ndm> doun: Haskell does not have sorts
09:08:46 <Baughn> mix25: If they're /large/ lists, piping it through Data.Set will be faster. If they're small ones you won't care. Set requires a stronger comparator, though
09:09:03 <doun> ndm: yep
09:09:32 <mix25> ahm
09:10:10 <Saizan> Peaker: http://www.haskell.org/haskellwiki/Reactive
09:10:10 <lambdabot> Title: Reactive - HaskellWiki
09:10:34 <Baughn> Peaker: Oh, but flapjax looks cute. I'll probably experiment with that for a bit - another thing I've wanted to look at is an ui library that will cleanly produce local, client-server or broweser-server applications without (much) code change
09:10:43 <Peaker> Saizan, how does it compare to conal's new "Simply efficient FRP"?
09:11:30 <doun> Baughn: you've _still_ not found one yet? =0
09:11:42 <Saizan> Peaker: that paper is an improvement over it
09:11:49 <Baughn> doun: "Still"?
09:11:55 <ndm> flapjax looked very cool, but i was unconvinved it could be used for real things
09:11:56 <Baughn> doun: I've been busy with exams; it happens. :P
09:12:06 <Baughn> doun: Also, my requirement has an implicit "in haskell" on the end
09:12:11 <doun> Baughn: sure
09:12:56 <Peaker> Baughn, I looked at one of flapjax's examples and there's a LOOOT of code to define a form that I believe should be derived automagically
09:13:13 <Baughn> Peaker: Which one?
09:13:49 <edwardk> @pl \a -> Yoneda (\f -> liftM f a)
09:13:49 <lambdabot> Yoneda . flip fmap
09:13:58 <Peaker> Baughn, http://www.flapjax-lang.org/demos/validator/
09:13:58 <lambdabot> Title: Flapjax Demo Code
09:14:05 <Peaker> Baughn, I am not sure why it is showing the html code though
09:14:28 <Baughn> Peaker: Ouch. Yes.
09:15:05 <Baughn> Peaker: It's immediately obvious how to improve that, but they /do/ claim it's under heavy development
09:15:10 <wolgo> so in the list comprehension: odds (x:xs) = [x | x <- xs, (not ((mod x 2) == 0)) ] the portion after the comma is always some expression of Bool type?
09:15:20 <Baughn> Peaker: Plausibly that demo was created specifically so they could figure out where to improve things
09:15:51 <ndm> wolgo: yes, you can have either listy things (generate more), or boolean things (filter what you already have)
09:16:08 <ndm> > [x | x <- [1..10], even x]
09:16:08 <edwardk> wolgo: you can stick a few different things in there. you can put more source lists x <- xs, y <- ys,    or some boolean expression x /= y
09:16:09 <lambdabot>  [2,4,6,8,10]
09:16:19 <Peaker> Baughn, I haven't yet seen a framework that truly disconnects the medium used from the logic/UI code - so that it can compile to a local app, or to a client/server based components that talk
09:16:32 <wolgo> @type even
09:16:34 <lambdabot> forall a. (Integral a) => a -> Bool
09:16:37 <ndm> > [(x,y) | x <- [1..10], y <- [1..10], even (x * y)]
09:16:38 <lambdabot>  [(1,2),(1,4),(1,6),(1,8),(1,10),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(2,7),(2...
09:16:41 <mar77a> > [x | x <- [1..10], y <- [1..10]]
09:16:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4...
09:16:49 <mar77a> what
09:17:02 <ndm> mar77a: you only showed x, hence the result
09:17:20 <wolgo> ok so only lists and only Bool expressions
09:17:25 <Baughn> Peaker: Then I'll just have to write one, won't I? ;)
09:17:26 <mar77a> it's extracting y for each x it extracts
09:17:34 <idnar> Peaker: if you have a client and a server, just run them on the same system for a local app :p
09:17:48 <doun> Baughn: do you have a blog or something that I can look at in case you /do/ write one?
09:17:53 <Baughn> doun: No.
09:18:07 <doun> Baughn: how will I know?!11
09:18:16 <edwardk> 6.9 is adding some group by, order by type stuff in there isn't it?
09:18:22 <Peaker> idnar, The thing is - a browser is a pretty horrible UI platform, and I don't want its disadvantages if I don't have to suffer them
09:18:24 <Baughn> doun: Well, it'll show up on hackage..
09:18:32 <Peaker> idnar, not to mention "deployment" issues of running it locally
09:18:38 <Peaker> idnar, its a crappy software world :-(
09:18:44 <Baughn> doun: Subscribe to planet-haskell. If I end up writing anything interesting, it'll probably go in there
09:18:57 <doun> Baughn: oh good
09:19:01 <edwardk> > [(x,y) | x <- [1..10] | y <- [1..10] ]
09:19:01 <lambdabot>  Parse error at "|" (column 23)
09:19:14 <idnar> so far, I prefer the browser environment over any native toolkit
09:19:27 <idnar> both as a user, and as a developer
09:19:28 <edwardk> hrmm what happened to parallel list comprehensions? or does lambdabot not -fglasgow-exts ?
09:20:19 <idnar> as a user, applications tend to behave much more consistently
09:20:27 <mar77a> > (30/7)
09:20:28 <Peaker> edwardk, what's it supposed to do differently to a comma there?
09:20:28 <lambdabot>  4.285714285714286
09:20:43 <edwardk> Prelude>  [(x,y) | x <- [1..10] | y <- [1..10] ]      ==> [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
09:20:50 <edwardk> its 'zipWith (,) basically
09:21:12 <idnar> as a developer, it's a lot easier to get an application up and running, even if I do have to write javascript
09:21:34 <doun> yeah. as opposed to 'for each x 1..10, for each y 1..10' it's 'for each x 1..10 and each y 1..10'
09:21:40 <Peaker> idnar, its a terrible UI none-the-less. It cannot be efficiently operated with the keyboard, it is limited in the kinds of input/output it can do reasonably. Its unresponsive, its unreliable, it exposes your potential secrets to third entities for technical/irrelevant reasons, and it generally sucks :)
09:22:00 <idnar> I'd much rather write some HTML than fight with glade and friends
09:22:05 <edwardk> > extendSequence [1,2,3]
09:22:05 <Peaker> idnar, I think a local application, even with the horrors of toolkits, its much easier to set up an application than with the web stuff
09:22:07 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
09:22:16 <Baughn> Peaker: http://sigfpe.blogspot.com/2008/05/life-in-lazy-universe.html <-- Amusingly, this is exactly how I'm approaching the simulation part of that game. Hmm, consequence of knowing haskell?
09:22:16 <lambdabot> Title: A Neighborhood of Infinity: Life in a Lazy Universe
09:22:19 <edwardk> somehow i think OEIS overcomplicated that one ;)
09:22:34 <Peaker> Baughn, which game?
09:22:39 <edwardk> > extendSequence [1,2,3,4]
09:22:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:22:41 <idnar> all of the web apps I've written work just fine from the keyboard
09:22:45 <Baughn> Peaker: The one I'm writing an UI for. ;)
09:22:55 <b_jonas> edwardk: try /msg buubot oeis: 1,2,3
09:22:59 <Peaker> Baughn, what's the game?
09:22:59 <wolgo> > [ (x,y) | x <- [1..10], (not ((mod x 2) == 0)) | y <- [1..10], (not ((mod x 2) == 0]
09:22:59 <lambdabot> Unbalanced parentheses
09:23:03 <Baughn> Peaker: Just a little thing to learn haskell properly (meaning using it a lot)
09:23:07 <wolgo> > [ (x,y) | x <- [1..10], (not ((mod x 2) == 0)) | y <- [1..10], (not ((mod x 2)) == 0]
09:23:07 <lambdabot> Unbalanced parentheses
09:23:09 <idnar> I hardly ever touch the mouse when I'm using my browser
09:23:13 <b_jonas> that doesn't only tell you the hit with the lowest A-number (the fibonacci) but also an url for all hits
09:23:15 <wolgo> deoh
09:23:26 <edwardk> same
09:23:27 <wolgo> > [ (x,y) | x <- [1..10], (not ((mod x 2) == 0)) | y <- [1..10], (not ((mod x 2) == 0))]
09:23:27 <lambdabot>  Parse error at "|" (column 48)
09:23:28 <b_jonas> you can also see right from the reply if it's the only match
09:23:49 <idnar> but let me continue this when I'm at a real keyboard, T9 is too low bandwidth
09:23:50 <b_jonas> it's better than the lambdabot plugin
09:24:13 <Peaker> Baughn, yeah, that's why I wrote a chess + GUI now. I don't particularly like the result though
09:24:21 <edwardk> fair nuff =)
09:24:43 <Peaker> Baughn, the gui is horrible, the chess code - I am not sure if its better or worse than the Python equivalent. (Undo was surely easier to implement than with Python, though :-)
09:24:44 <int-e> > extendSequence [23, 42, 666]
09:24:45 <lambdabot>  [23,42,666]
09:25:04 <lilac> > extendSequence [6, 16]
09:25:06 <lambdabot>  [6,16,26,36,46,56,66,76,86,96,7,17,27,37,47]
09:25:18 <doun> so I used an MVar to lock a file which stores my âdatabaseâ (or: normalised data structure) so that it isn't read/written at the same time by two threads. is this awesome (y/n)?
09:25:20 <Peaker> > extendSequence [1,10,100]
09:25:22 <lambdabot>  [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,1000000000...
09:25:24 <edwardk> i still think it'd be funny to keep generating terms of a generating function for a functor until OEIS gave you a single answer, then look up a data structure for that form.
09:25:26 <vixey> > describeSequence [6, 16]
09:25:27 <lambdabot>  Just "Read n backwards (referred to as R(n) in many sequences)."
09:25:28 <wolgo> Hey what is -XParralelListComp?
09:25:42 <lilac> > extendSequence [1,11,21,1211,111221]
09:25:43 <edwardk> wolgo: the language flag you need to use to run my example
09:25:43 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
09:26:17 <Peaker> that's impressive - was that hardcoded into extendSequence?
09:26:21 <edwardk> lilac: self describing numbers?
09:26:25 <Baughn> doun: That works. How about having a single "editor" thread and passing it functions to do editing? You could scale that approach up to add atomicity, transactions, etc. at will
09:26:27 <lilac> edwardk: yep
09:26:28 <edwardk> lilac: it his the database
09:26:30 <b_jonas> Peaker: it's in oeis
09:26:35 <vixey> > drop 10 $ extendSequence $ [1,11,21,1211,111221]
09:26:36 <lilac> > describeSequence [1,11,21,1211]
09:26:37 <lambdabot>  [11131221133112132113212221,3113112221232112111312211312113211]
09:26:38 <lambdabot>  Just "Look and Say sequence: describe the previous term! (method A - initial...
09:26:39 <ndm> wolgo: a slight extension, that is not really that useful
09:26:44 <vixey> > drop 20 $ extendSequence $ [1,11,21,1211,111221]
09:26:46 <lambdabot>  []
09:27:09 <Peaker> hmm?
09:27:34 <edwardk> unfortunately oeis doesn't supply an executable fragment for its lists ;)
09:27:50 <b_jonas> edwardk: it often does
09:27:57 <edwardk> it'd be cool to build up a set of OEIS indexed haskell fragments for them
09:27:59 <b_jonas> but not for all sequences
09:28:01 <doun> Baughn: hum, that could also work, yes. it is for a very simple web application, I'm not sure it's worth the abstraction?
09:28:03 <edwardk> for as many as you can
09:28:19 <b_jonas> otoh I had some simple code to compute the look-and-say
09:28:24 <b_jonas> not very efficent, but worked
09:28:27 <edwardk> b_jonas Yeah but not in an extractable/executable form you usually have to go oh thats for maple, or thats for octave, or whatever.
09:28:54 * doun can't believe he used the word 'application'
09:28:59 <Baughn> doun: At the simplest level it's isomorphic to what you're doing, so I guess it doesn't really matter. It's just easier to keep track of things with a single thread - less shared state.
09:29:01 <b_jonas> edwardk: well, you could still try to execute those if you can do in a safe manner
09:29:12 <b_jonas> but you need lots of interpreters
09:29:27 <b_jonas> free and non-free
09:29:36 <b_jonas> so it's not easy
09:29:41 <b_jonas> it's not worth the hassle
09:30:22 <vixey> > map (head *** length) . group $ "111211"
09:30:22 <lambdabot>  Couldn't match expected type `([a], [a1])'
09:30:30 <mauke> &&&
09:32:46 <doun> Baughn: ah. well. it sounds like a good approach. at the moment I just have a "withLock" function. if you're interested in looking at some random web code out of curiousity: http://github.com/chrisdone/clixra/tree/master/View/View.hs
09:32:48 <lambdabot> Title: View/View.hs at master from chrisdone's clixra &mdash; GitHub
09:33:04 <vixey> > map (uncurry (++) . (return.head &&& show.length)) . group $ "111211"
09:33:06 <lambdabot>  ["13","21","12"]
09:33:18 <vixey> (uncurry (++) . (return.head &&& show.length)) =<< group
09:33:19 <Baughn> doun: You /could/ just rename "withLock" to "inDB" and rewrite it later
09:33:50 <doun> Baughn: yeah, I prefer that name. I'll change it right now =]
09:34:14 <Baughn> doun: I mean, you're already passing a function to withLock, right?
09:34:32 <doun> Baughn: an action, yeah
09:34:47 <Baughn> doun: ..why an action? Isn't it in-memory?
09:34:48 <wolgo> So is XParallelListComp something that should be avoided?
09:35:35 <doun> Baughn: no, it's being written to a file for later recall. although I had considered storing the whole DB in memory considering it is refreshed every half hour or something...
09:35:36 <ndm> wolgo: its not compatible with other compilers, and provides very little benefit
09:35:47 <wolgo> Oh ok
09:35:56 <ndm> i actually find it kind of confusing
09:36:13 <wolgo> So are parallel list comprehensions not part of the haskell98 standard?
09:36:15 <Baughn> doun: withLock (or inDB) would have to be an action, then. That does not mean the functions you pass in have to be
09:36:27 <roconnor> > let x = "1":(map (map (\y -> show (length y)++(take 1 y)) . group) x in x
09:36:28 <lambdabot> Unbalanced parentheses
09:36:41 <roconnor> > let x = "1":(map (map (\y -> show (length y)++(take 1 y)) . group) x) in x
09:36:41 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
09:36:47 <ndm> [(x,y) | x <- [1..10] | y <- [1..10]] can be rewritten: [(x,y) | (x,y) <- zip [1..10] [1..10]]
09:37:07 <wolgo> Oh ok
09:37:12 <wolgo> I understand why
09:37:21 <skorpan> haskell is awesome
09:38:20 <Baughn> doun: Oh, I see. It just grabs the lock, and nothing else.. seems to me you'd want to factor the write-to-disk code into it
09:38:32 <doun> Baughn: you mean maybe I could pass it functions that manipulate the database structure? e.g. inDB :: (DB -> DB) -> Clixra (), or somethig similar
09:38:42 <Baughn> doun: It makes sense to me
09:38:46 <roconnor> > iterate ((map (\y -> show (length y)++(take 1 y)) . group) "1"
09:38:46 <lambdabot> Unbalanced parentheses
09:38:56 <roconnor> > iterate (map (\y -> show (length y)++(take 1 y)) . group) "1"
09:38:57 <lambdabot>  Couldn't match expected type `Char' against inferred type `String'
09:39:07 <roconnor> > group "1"
09:39:08 <lambdabot>  ["1"]
09:39:21 <doun> Baughn: well I think I'll try that. hehe, a chance to use git's branches! :D
09:39:23 <Baughn> doun: Although, for purposes of ACID and efficiency, DB -> [DBChange] might be better
09:39:27 <roconnor> > take 1 (group "1")
09:39:28 <lambdabot>  ["1"]
09:39:32 <doun> Baughn: ACID = ?
09:39:34 <skorpan> @src group
09:39:34 <lambdabot> group = groupBy (==)
09:39:40 <skorpan> @src groupBy
09:39:40 <lambdabot> groupBy _  []       =  []
09:39:41 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
09:39:41 <lambdabot>     where (ys,zs) = span (eq x) xs
09:39:43 <roconnor> > take 1 "1"
09:39:44 <lambdabot>  "1"
09:39:54 <skorpan> take 1 ["1"]
09:39:54 <Baughn> doun: Look it up, but basically just "not breaking, ever"
09:39:57 <skorpan> > take 1 ["1"]
09:39:57 <b_jonas> still look-and-say?
09:39:58 <doun> Baughn: what information would DBChange have?
09:39:59 <lambdabot>  ["1"]
09:40:09 <roconnor> > iterate (concatMap (\y -> show (length y)++(take 1 y)) . group) "1"
09:40:09 <skorpan> > take 1 ['1']
09:40:11 <lambdabot>  ["1","11","21","1211","111221","312211","13112221","1113213211","31131211131...
09:40:11 <lambdabot>  "1"
09:40:14 <skorpan> what the heck
09:40:21 <vixey> :t (show . length ++ take 1)
09:40:23 <lambdabot> [Char] -> String
09:40:33 <Baughn> doun: Depends on the DB, but some (serializable!) list of alterations to the DB that can itself be written to file
09:40:37 <mix25> :i intersect
09:40:38 <b_jonas> I've found my J code for it
09:40:41 <b_jonas> it's
09:41:02 <vixey> > iterate (group >>= (show . length ++ take 1)) $ "1"
09:41:03 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
09:41:15 <Baughn> doun: This might be overkill, though. For a small DB, just writing the thing to a separate file and then moving it over the old one is /plenty/.
09:41:21 <doun> Baughn: sounds a bit **Enterprise** to me?
09:41:26 <b_jonas> anyway, I don't want to bring the J bot in here
09:41:27 <doun> Baughn: yeah
09:42:11 <b_jonas> but (decay =: [:;(~:|.!.'')({.,~'01234'{~#);.1]) generates the next element, try e.g. (decay^:10 '1') for the tenth element
09:42:33 * doun reads about git branches
09:42:37 <Baughn> doun: "Enterprise" does not automatically equal "bad". A log-structured database is a pure win in most situations.. unless you never, ever have crashes
09:43:42 <doun> Baughn: well, I didn't mean "bad" as much as "overkill for this specific task". but yeah, it seems to be what STM is based on, isn't it?
09:44:13 <Baughn> doun: Well, no. STM does argue (quite reasonably) that it won't crash - if it did you'd lose the memory, right?
09:44:47 <Baughn> doun: It could be overkill. It could also be a learning experience - it's not really very much code, especially in haskell. ;)
09:45:11 <dogbite> is it odd that this old result is linked on reddit?
09:45:12 <dogbite> http://www.iist.unu.edu/~vs/haskell/dhs/
09:45:19 <lambdabot> Title: Erlang-style Distributed Haskell
09:45:26 <doun> Baughn: sure, I am going to try it
09:47:02 <Dzlk> Wow. A recent ghc, like 4.08.
09:47:10 <doun> Baughn: I suspect two channels carried in the monad, abstracted with an inDB should be sufficient
09:47:20 <Saizan> dogbite: yeah, especially since it's not so innovative
09:47:22 <Baughn> doun: http://en.wikipedia.org/wiki/Log-structured_file_system <-- Here, have a relevant article
09:48:07 <dogbite> Saizan: have there been more recent writeups about erlang-style concurrency with haskell?
09:48:52 <doun> Baughn: ohh that is sexy
09:49:10 <Baughn> doun: You /really/ should read up on ACID too
09:50:22 <Saizan> dogbite: in haskell you'd want much more type information
09:50:26 <doun> I am reading the wikipedia article, it's a start :-P
09:50:29 <Dzlk> Erlang is neat but I don't think it should be surprising that Haskell can do it.
09:51:03 <dogbite> Saizan: yeah, that's part of why i started learning haskell
09:51:30 <dogbite> i wrote a few erlang programs and i wasn't satisfied with how it handled types
09:52:47 <Saizan> http://wellquite.org/sessions/tutorial_1.html <-- this is quite recent
09:52:48 <lambdabot> Title: Well Quite
09:53:16 * Dzlk sort of prefers writing Erlang in languages that aren't Erlang to writing Erlang in Erlang.
09:55:21 <cjs> Baughn, a DBChange would not be just a list of changes, but a list of reads and updates.
09:55:35 <ehird> sclv: I noticed you commented on the wt article on reddit. the stateless slots things interests me and I agree with the type-system bit. And now I'm tempted to hack up a wt-in-haskell
09:56:00 <Saizan> wt?
09:56:17 <ehird> Saizan: boring web stuff!
09:56:33 <Baughn> cjs: Well, not reads. No reason for /those/ to be logged - unless you're going for a full-blown DBMS, anyhow
09:56:57 <pastorn> @hoogle Filepath -> IO
09:56:58 <lambdabot> No matches, try a more general search
09:57:01 <pastorn> @hoogle Filepath -> IO *
09:57:01 <lambdabot> Hoogle Error: Parse Error: Unexpected character '*'
09:57:11 <pastorn> @hoogle Filepath -> IO Fileath
09:57:11 <lambdabot> No matches, try a more general search
09:57:17 <vixey> @hoogle contents
09:57:17 <lambdabot> Prelude.getContents :: IO String
09:57:17 <lambdabot> System.IO.hGetContents :: Handle -> IO String
09:57:17 <lambdabot> System.IO.getContents :: IO String
09:57:24 <Saizan> Baughn: it depends on how you implement isolation, right?
09:57:25 <pastorn> vixey: thanks :)
09:58:30 <Baughn> Saizan: It does
09:59:13 <pastorn> @hoogle directory
09:59:14 <lambdabot> System.Directory :: module
09:59:14 <lambdabot> System.Directory.createDirectory :: FilePath -> IO ()
09:59:14 <lambdabot> System.Directory.removeDirectory :: FilePath -> IO ()
09:59:47 <Saizan> anyone have a graph-zipper handy?
10:00:03 <arnarb> hey there..
10:00:23 <doun> hi
10:00:43 <ehird> sclv is not here again it seems ;)
10:03:28 <Arnar_> can I somehow define an exception type, and and a throw/catch pair - the reason is that I want to throw an exception but I don't want to expose the catch outside of my module
10:05:25 <Arnar_> for example.. say I'd like to crate an STM action "abort" -- it would have the same affect as a throw (i.e. aborting the exception) - but I don't want user code to be able to catch it in an encompassing STM before it propogates up to the atomically call
10:05:50 <Baughn> Arnar_: Look at dynamic exceptions. If you don't export the datatype, it won't be catchable.
10:06:17 <Baughn> arnarb: Look at dynamic exceptions. If you don't export the datatype, it won't be catchable.
10:06:47 <arnarb> Baughn: ok.. thanks
10:08:19 <conal> augustss: ping
10:15:20 <pastorn> http://haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html <-- is there an easier way to do isDirectory (:: FilePath -> IO Bool) than to do f fp = doesFileExist fp >>= \b -> if b then return doesDirectoryExist fp else return False
10:15:20 <lambdabot> http://tinyurl.com/5waeo3
10:15:30 <OXIj> is there any good method to take 4th element from list. not like last (take 4 list)?
10:15:39 <ddarius> (!!3)
10:15:54 <pastorn> @type (!!)
10:15:56 <lambdabot> forall a. [a] -> Int -> a
10:16:51 <Saizan> pastorn: doesDirectoryExist should suffice
10:17:09 <ddarius> edwardk: Maybe you should go to Reykjavik and participate in the Mathematically Structured Functional Programming Workshop.
10:17:17 <pastorn> hmm... i COULD make a filter with that...
10:17:23 * pastorn is making something recursive
10:17:50 <arnarb> ddarius: are you going?
10:18:09 <arnarb> in fact.. is anyone here coing to ICALP (or the associated workshops)?
10:18:23 <ddarius> arnarb: I'm not.
10:18:50 <arnarb> s/coing/going/ of course..
10:18:53 <arnarb> ok..
10:20:32 <sclv> ehird: go for it! I think it'll be pretty darn nontrivial, but most of the work looks to be on the javascript side...
10:20:52 * sclv has to run though...
10:20:53 <ehird> sclv: it works without JS too, it seems
10:20:58 <ehird> sclv: though not the stateless stuff I think
10:21:02 <pastorn> weird... why is there no function that returns file permissions?
10:21:11 <pastorn> or is there (and i missed it)?
10:21:16 <sclv> ehird: well, yeah, but the stateless stuff is the only interesting bit.
10:21:23 <ehird> sclv: no it's not! :-)
10:21:24 <arnarb> pastorn: maybe because it is not cross-platform
10:21:51 <sclv> what's the other interesting bit? i've seen server-side "widget" type things for years.
10:22:07 <sclv> java server faces I'm looking at *you*
10:22:18 <arnarb> pastorn:
10:22:26 <pastorn> arnarb: isn't here either: http://haskell.org/ghc/docs/latest/html/libraries/filepath/System-FilePath-Posix.html
10:22:27 <lambdabot> http://tinyurl.com/5cfp3s
10:22:28 <arnarb> :t System.Directory.getPermissions
10:22:30 <lambdabot> FilePath -> IO System.Directory.Permissions
10:22:42 * pastorn missed that
10:29:02 <pastorn> @hoogle (a -> Bool) -> [a] -> ([a],[a])
10:29:03 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
10:29:03 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
10:29:03 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
10:31:32 <pastorn> shit, given a [FilePath], doesDirectoryExist :: FilePath -> IO Bool and partition :: (a -> Bool) -> [a] -> ([a], [a]), how do i combine them?
10:31:33 * bauchus has a syntax question for case. In Ocaml I can write  match 2 with (1|2) -> 1 | _ -> 0. How can I do this kind of pattern matching in haskell?
10:32:00 * pastorn hasn't done haskell in some time, he realises...
10:32:19 <augustss> @seen conal
10:32:20 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 24m ago.
10:32:21 <vixey> bauchus: There's no way to do that in Haskell
10:32:45 <bauchus> hm. ok.
10:32:49 <dolio> Does the 1|2 match both 1 and 2?
10:32:56 <bauchus> yes
10:33:05 <Saizan> :t \xs -> do bs <- mapM doesDirectoryExist xs; partition fst (zip bs xs)
10:33:07 <lambdabot> Not in scope: `doesDirectoryExist'
10:33:08 <dolio> You'd have to do separate cases in haskell, unfortunately.
10:33:12 <vixey> bauchus: idiomatic would be like case 2 of e | e `elem` [1,2] -> 1 ; _ -> 0
10:33:19 <vixey> > case 2 of e | e `elem` [1,2] -> 1 ; _ -> 0
10:33:20 <dolio> case 2 of 1 -> 1 ; 2 -> 1 ; _ -> 0
10:33:20 <lambdabot>  1
10:33:26 <Saizan> :t \xs -> do bs <- mapM System.Directory.doesDirectoryExist xs; return $ partition fst (zip bs xs)
10:33:27 <lambdabot> [FilePath] -> IO ([(Bool, FilePath)], [(Bool, FilePath)])
10:33:43 <conal> augustss: hi.  i'm playing with your function Expr code (blog post) and ran into a problem similar to what you found with my code.  you overloaded Show for functions.
10:33:46 <Saizan> pastorn: map fst on the results ^^^
10:33:51 <vixey> bauchus: (but you can't introduce bindings with elem)
10:34:03 <conal> augustss: and i wanted a different overloading, as i'm working with typed expressions.
10:34:19 <augustss> conal: yes, I know.  it's a pain
10:34:56 <conal> augustss: i'm putting this stuff together into a library: Twan's, your extension, and a phantom type layer.
10:35:15 <conal> augustss: instead of the Show instances for functions, i'll make a showFun function.
10:35:32 <pastorn> Saizan: http://arcanux.org/lambdacats/io-monad.jpg
10:36:18 <augustss> cool.  I've worked on something similar to Expr, but where each item has a real value as well as a symbolic representation
10:36:34 <Saizan> pastorn: :D that helps a little no?
10:36:45 <dolio> Multiple patterns leading to the same branch would be handy. I'm not sure why that hasn't been done in haskell.
10:36:54 <pastorn> it helps some, thanks :)
10:37:04 <vixey> dolio: it makes very little sense to me
10:37:12 <conal> augustss: yeah.  i like that feature.  but not the restriction to functions having all the same type of argument.
10:37:28 <bauchus> I should start a wishlist for Haskell': mod_float, succCyclic, predCyclic and this case.
10:37:35 <vixey> dolio: I can only imagine cases when it doesn't type.. or only binds a subset of what it should bind ..
10:37:46 <dolio> That might actually have a ticket in h' already.
10:37:48 <vixey> (other than trivial ones like bauchus example)
10:37:50 <dolio> I can't remember.
10:38:03 <vixey> how is mod_float different from mod?
10:38:11 <conal> augustss: maybe it's time for a simple general replacement based on a lambda calculus GADT
10:38:25 <conal> augustss: carrying syntactic and semantic representations.
10:38:30 <dolio> > 10 `mod'` pi -- bauchus
10:38:31 <lambdabot>  0.5752220392306207
10:38:32 <augustss> conal: no, but that was enough for my experiments.  :)  I've also added observable sharing.  That way, when you evaluate an expression you get a value, as well as a DAG representing the computation
10:38:36 <pastorn> @type mapM
10:38:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:38:39 <pastorn> @type mapM_
10:38:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:38:46 <pastorn> right...
10:38:58 <conal> augustss: oh!  very handy.
10:39:06 <bauchus> mod_float 0.7 0.5 -> 0.2
10:39:21 <dolio> > mod' 0.7 0.5
10:39:23 <lambdabot>  0.19999999999999996
10:39:28 <mauke> preflex: calc 0.7 % 0.5
10:39:28 <preflex>  0.2
10:39:28 <dolio> Heh.
10:39:29 <vixey> augustss: How is the DAG updated? (I guess evaluation mutates it.. but how?)
10:39:30 <conal> augustss: then the result would be much closer to showing what actually gets computed and what shared.
10:39:32 <mauke> I WIN
10:40:30 <augustss> vixey: there's nothing that updates the DAG beyond the usual evaluation.  But to recover the sharing you need a little unsafeness
10:41:03 <vixey> what is meant by recovering?
10:41:11 <vixey> naturally .. the expression would have no sharing?
10:41:31 <augustss> vixey: Haskell will only give you a tree.  You won't see where the sharing was
10:42:24 <vixey> is there code ? :)
10:42:29 <augustss> conal: I did this just to see what what was going on in Jerzy's adjoint code.  It's broken from a performance perspective.
10:42:32 <Saizan> augustss: you add some unique identifiers to expressions?
10:42:48 <conal> augustss: active project?  i'd love to dump what i'm doing in favor of something better.  i'm wrapping twan's code and your blog code so as test my derivative stuff.
10:42:51 <augustss> Saizan: yes, i just gensym some
10:43:19 <dolio> vixey: One non-trivial example I've seen of multi-pattern case in ML is in Purely Functional Data Structures, where the red-black tree balancing code uses multiple patterns to match different inputs, but the output expression is always the same.
10:43:27 <augustss> conal: I've done it the last few days.  but it's not in the shape ai want it.  Just one type at the moment
10:43:44 <vixey> dolio: ohh good point, I've seen that one
10:43:51 <conal> augustss: great.  please keep plugging away and let me know.
10:44:30 <augustss> conal: my real project is an efficient reverse AD
10:45:15 <dolio> vixey: I don't think it's uncommon in C switch statements, either.
10:45:18 <conal> augustss: great!
10:45:30 <conal> augustss: i thought about that problem a few years back also.
10:45:36 <dolio> And I don't think `elem` is a great solution to that.
10:46:22 <vixey> elem is equivalent because it just tests == on each thing in turn
10:47:02 <vixey> just can't bind with it because there's no logic variables
10:47:35 <vixey> maybe it's possible to add this (| matching) with a bit of work
10:48:41 <newsham> > take 8 $ let d `idivs` n = n `mod` d == 0; (a,b) `cdivs` (a',b') = (let d = a*a+b*b in (d `idivs` (a*a' - b*b')) && (d `idivs` (a'*b + a*b')) ); real (a,b) = b == 0 in map fst $ filter real $ nubBy cdivs $ tail [(a, b) | a <- [1..], b <- [0 .. a]]
10:48:41 <bauchus> another simple example is: match ... with x::[] | _::x::[] -> x ... Here x is bind to different positions in the list.
10:48:42 <lambdabot>  [3,7,11,19,23,31,43,47]
10:49:59 <dolio> I guess multiple patterns doesn't have a ticket.
10:50:12 <nogglist> > [x*10 | x <- [1,2,3,4,5,6,7,8,9,10]]
10:50:13 <lambdabot>  [10,20,30,40,50,60,70,80,90,100]
10:50:17 <dolio> The only things under 'case' are multi-way-if and lambda-case.
10:50:26 <wolgo> wtf
10:50:45 <wolgo> I must have gotten DC'd
10:53:07 <bauchus> @where mod'
10:53:07 <lambdabot> I know nothing about mod'.
10:53:25 <dolio> @hoogle mod'
10:53:25 <lambdabot> Data.Fixed.mod' :: Real a => a -> a -> a
10:53:25 <lambdabot> Data.Fixed.divMod' :: (Real a, Integral b) => a -> a -> (b, a)
10:53:39 <bauchus> thanks
10:53:56 <vixey> why would you use mod rather than mod' ?
10:54:06 <idnar> :t mod
10:54:09 <lambdabot> forall a. (Integral a) => a -> a -> a
10:54:14 <dolio> mod works on Integral values.
10:54:18 <Deewiant> > mod' 5 2
10:54:19 <lambdabot>  1
10:54:30 <newsham> > mod' (exp 1) pi
10:54:31 <lambdabot>  2.718281828459045
10:54:46 <newsham> > mod' pi (exp 1)
10:54:47 <lambdabot>  0.423310825130748
10:55:04 <mauke> preflex: calc pi % e
10:55:04 <preflex>  0.423310825130748
10:57:00 <vixey> @instances Real
10:57:00 <lambdabot> Double, Float, Int, Integer
10:57:02 <vixey> @instances Integral
10:57:03 <lambdabot> Int, Integer
10:57:44 <dolio> Hmm.
10:57:58 <mauke> @src Real
10:57:58 <lambdabot> class  (Num a, Ord a) => Real a  where
10:57:58 <lambdabot>     toRational      ::  a -> Rational
10:57:59 <newsham> > (16 * 8 + 4) / 21 * 0.5
10:58:00 <lambdabot>  3.142857142857143
10:59:34 <vixey> > pi::CReal
10:59:36 <lambdabot>  3.1415926535897932384626433832795028841972
11:00:09 <lilac> > e::Rational
11:00:10 <lambdabot>  Couldn't match expected type `Rational'
11:00:17 <lilac> :D
11:00:45 <newsham> > (1 :+ 2) * (1 :+ (-2))
11:00:46 <lambdabot>  5.0 :+ 0.0
11:00:57 <dons> The shootout team are getting a quad core machine
11:01:01 <dons> This is rather exciting.
11:01:04 <opqdonut> !
11:01:08 <opqdonut> excellent
11:01:10 <dons> Isaac wrote to us, with some questions.
11:01:18 <dons> > - Are there particular problems/tasks which come to mind as something
11:01:18 <dons> > we might use as a benchmark?
11:01:18 <dons> > - If there are both sequential and concurrent programs should we keep
11:01:18 <dons> > them separate or show them together?
11:01:18 <dons> > - Which benchmarks do you think we should drop, which should we keep?
11:01:19 <lambdabot>  Parse error at "do" (column 20)
11:01:19 <lambdabot>   parse error on input `}'
11:01:19 <lambdabot>   parse error on input `}'
11:01:20 <lambdabot>   Not in scope: `as'
11:01:20 <lambdabot>   Not in scope: `keep'
11:01:24 <vixey> hehe
11:02:01 <dons> so, if anyone has thoughts on good parallelism benchmarks, let me know.
11:03:08 <pastorn> dons: maping over trees where each node contains its subtrees weight?
11:03:15 * dolio still has a lowly 1-core machine.
11:03:45 <pastorn> (as a test werter or not it would be worth doing in paralell)
11:04:10 <newsham> large matrix multiplication?
11:04:33 <newsham> grid computations ?
11:04:41 <arnarb> dons: Karatsuba's algorithm?
11:04:41 <lilac> sorting?
11:04:58 <newsham> travelling salesman?
11:04:59 <pastorn> arnarb: what does that do?
11:05:16 <arnarb> pastorn: multiplies large numbers (larger than the word size of the machine)
11:05:20 <arnarb> http://citeseer.ist.psu.edu/189168.html
11:05:20 <lambdabot> Title: Using the Parallel Karatsuba Algorithm for Long Integer Multiplication and Divis ...
11:06:16 <arnarb> it is a classical example of a dynamic programming algorithm
11:06:41 <pastorn> arnarb: is there a non-parallel version as well?
11:07:04 <arnarb> pastorn: for multiplying large numbers?
11:07:17 <pastorn> yeah, i mean a paper
11:07:28 <vixey> pastorn: "We experiment with sequential and parallel versions..."
11:07:28 <arnarb> dunno..
11:07:29 <arnarb> http://en.wikipedia.org/wiki/Karatsuba_algorithm
11:07:54 <pastorn> ah, that was better :D
11:07:56 <newsham> dons: they shouldnt dictate parallel implementations, they should allow you to exploit it if you want to.
11:07:57 <arnarb> that paper on citeseer is about comparing sequential and parallel versions..
11:08:03 <arnarb> the wikipedia is bout Karatsuba in general
11:09:08 <newsham> ie. the current mand example is parallelizable, why shouldnt that also be allowed to be solved in a parallel manner if you choose to
11:09:26 <mix25> If i have this func :: [[Int]] -> Bool. func (xs:yss) = ... . How Can I move on each element of the list?
11:09:51 <newsham> what is "move"?
11:09:52 <vixey> mix58: maybe with map?
11:10:10 <arnarb> in fact.. I can't get the PDF, but Google's index seems to suggest that this paper implements a parallel version of Karatsuba for GHC: http://www.springerlink.com/content/0tyrqpj2hh0xj9e2/
11:10:12 <lambdabot> Title: SpringerLink - Book Chapter
11:10:59 <arnarb> :t map.map
11:11:01 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
11:11:06 <arnarb> ah..
11:11:13 <arnarb> :t (Prelude.map).(Prelude.map)
11:11:16 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
11:11:19 <Deewiant> :t map (Prelude..) map
11:11:21 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a1 -> b) -> (a -> f a1) -> a -> f b
11:11:29 <pastorn> arnarb: stop that
11:11:40 <Cale> stop what?
11:11:42 <arnarb> pastorn: ?
11:11:49 <vixey> don't use prelude!
11:11:51 <vixey> :p
11:11:54 <pastorn> hehe
11:11:55 <arnarb> hehe
11:12:10 <vixey> > map (+1) [55,33,11,88] -- mix25
11:12:11 <lambdabot>  [56,34,12,89]
11:13:32 <newsham> > map (map (+1)) [[55,33],[11,18]]
11:13:34 <lambdabot>  [[56,34],[12,19]]
11:13:36 <dons> thanks guys. that's some useful things.
11:13:43 <wolgo> what is a functor
11:13:55 <Cale> wolgo: Do you know about type constructors?
11:13:56 <newsham> ?type fmap
11:13:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:14:05 <wolgo> like :
11:14:24 <wolgo> or like data wolgo :: Awesome x
11:14:24 <Cale> like  Maybe, or [] (at the type level)
11:14:42 <Cale> :t Just 5
11:14:44 <lambdabot> forall t. (Num t) => Maybe t
11:14:53 <wolgo> I do not know what maybe is
11:14:59 <pastorn> wolgo: there has to be a way to apply a function (a->b) over a functor of a's
11:15:02 <pastorn> that's all
11:15:02 <vixey> @src Maybe
11:15:02 <lambdabot> data Maybe a = Nothing | Just a
11:15:41 <mauke> a functor is a container in which you can apply a function to all values
11:16:04 <wolgo> oh ok
11:16:16 <wolgo> that is why map has functor in it
11:16:19 <Cale> A functor is a type constructor f, which constructs a datatype for which there is a function fmap :: (a -> b) -> f a -> f b
11:16:19 <mauke> > fmap (*2) [1,2,3]
11:16:20 <lambdabot>  [2,4,6]
11:16:25 <pastorn> > map (\c -> if isUpper then Just c else Nothing) "hello WOLgO"
11:16:26 <lambdabot>  Couldn't match expected type `Bool'
11:16:29 <mauke> > fmap (*2) (Just 3)
11:16:30 <lambdabot>  Just 6
11:16:33 <pastorn> > map (\c -> if isUpper c then Just c else Nothing) "hello WOLgO"
11:16:35 <lambdabot>  [Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Just 'W',Just 'O',Just 'L',...
11:17:14 <wolgo> oh weird
11:17:48 <mauke> > fmap (*2) ("wat", 21)
11:17:49 <lambdabot>  ("wat",42)
11:17:52 <schme> hello there #haskell. I'm looking at using ghc for developing some software here and I was wondering how difficult it is to write software that is portable between microsoft OS and unixy os.
11:18:03 <schme> ie. filehandling, sound output, etc.
11:18:17 <Cale> schme: Filehandling isn't bad.
11:18:30 <schme> Cale: excellent!
11:18:31 <vixey> Sound.OpenAL is sort of hard to use
11:18:35 <Cale> schme: Sound output, you might have to worry about getting yourself a sound abstraction library that you like.
11:18:55 <schme> But there are such things somewhere so I don't really have to write one meself, huh?
11:19:16 <newsham> you can do a lot of stuff quite portably.
11:19:31 <schme> Hurraah
11:19:36 <newsham> for example, you can use gtk on both for gui
11:19:44 <schme> I'm going with opengl
11:19:49 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Sound
11:19:51 <lambdabot> http://tinyurl.com/yqov7f
11:20:52 <schme> Lookin' good there.
11:20:54 <Cale> Also, I seem to recall there were SDL bindings, but I'm not sure where those have gone. (Why aren't they on Hackage?)
11:21:23 <Saizan> aren't they?
11:21:26 <tilman> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SDL
11:21:35 <tilman> that one worked for me earlier today
11:22:00 <pastorn> schme: what are you planning on making?
11:22:06 <schme> pastorn: A lil' game.
11:22:12 <pastorn> what type?
11:22:26 <schme> pastorn: I'm not sure what the type is called. The type mah missus keeps playing all the time.
11:22:39 <schme> So I need opengl, and sound, and networkin, and file handling.
11:22:40 <Cale> oh, it is there
11:22:41 <pastorn> :)
11:23:06 <Cale> Firefox 3's search in text thing sucks if you start to use it while the page is loading, it seems :)
11:23:07 <schme> Which I'm hoping can be done totally portable with all the differences neatly abstracted away.
11:23:10 <schme> Yay.
11:24:01 <schme> I've been lookin' for a project to hack up in haskell after my last one went another way.. so this just seems great.
11:24:05 <schme> :)
11:24:15 <Cale> Yeah, networking should also be no problem with the libraries that come with GHC.
11:25:37 <schme> I'm mostry worried about the filehandling actually :)
11:25:42 <schme> \ being / and so.
11:25:52 <Cale> Just use /
11:26:01 <jcreigh> uh, that's going to be the least of your problems. :)
11:26:11 <Cale> Windows will actually accept / anyway, I'm pretty sure.
11:26:24 <vixey> FilehandlingUNIX.hs
11:26:27 <vixey> FilehandlingWindows.hs
11:26:36 <Cale> That shouldn't be required :)
11:26:48 <Cale> There's also a FilePath abstraction library.
11:27:05 <ndm> schme: the System.FilePath library deals with all those details
11:27:10 <schme> Horrah.
11:27:15 <ndm> > "foo" </> "bar"
11:27:16 <lambdabot>   Not in scope: `</>'
11:27:46 <ndm> but that would have given "foo/bar" on Linux and "foo\bar" on Windows
11:28:17 <schme> I'm very confused about this system.filepath. How does ghc know if it should be using windows or posix?
11:28:42 <dons> it was baked in at compile time.
11:29:05 <dons> Prelude> :m + System.Info
11:29:05 <dons> Prelude System.Info> os
11:29:06 <dons> "openbsd"
11:29:13 <schme> Right.
11:29:38 <schme> I guess i just have to figure out how to tell ghc what to use for compilation then.
11:29:46 <pastorn> > partition odd [1..10]
11:29:47 <lambdabot>  ([1,3,5,7,9],[2,4,6,8,10])
11:29:58 <ndm> schme: no, you just import System.FilePath, it will get it right
11:30:12 <schme> ndm: Ok?
11:30:12 <vixey> @src partition
11:30:12 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
11:30:12 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
11:30:12 <lambdabot>                               | otherwise = (ts, x:fs)
11:30:24 <pastorn> Saizan: writing partitionM now...
11:30:27 <ndm> if you want to use Posix on Windows or vice versa, you can, but the detault will do the right thing
11:30:41 <Deewiant> pastorn: use google instead, http://hpaste.org/1747 :-)
11:30:50 <dons> ndm: how does it determine the default?
11:30:57 <ndm> dons: CPP
11:31:00 <schme> Ok lemme phrase it this way then.
11:31:05 <dons> oh. ok
11:31:14 <schme> How do I tell my ghc on mah linux system to generate windows binaries ?
11:31:30 <dons> you can't. there's no cross compiling. you'd have to run windows in vmware or similar
11:31:34 <ndm> schme: you mean cross compiling? much easier just not to, i don't think its that supported by GHC
11:31:39 <schme> That's bollocks :(
11:31:50 <pastorn> Deewiant: not as fun :p
11:32:01 <schme> windows is too expensive :)
11:32:04 <dons> its a non trivial problem, schme, that's why you don't see cross compilers from linux to windows very often.
11:32:06 <newsham> you clearly should add cross compilation to ghc, schme.
11:32:15 <dons> better to write portable source, and let your users compile it for you
11:32:36 <schme> Uh.
11:32:45 <schme> That's not quite what I had in mind.
11:32:49 <pastorn> schme: reactOS
11:33:10 <pastorn> www.reactos.org
11:33:11 <schme> pastorn: ah thanks
11:33:26 <Cale> schme: Heh, just get your first windows user to let you use their machine :)
11:33:51 <mehrheit> schme, try wine
11:33:56 <schme> Not suppling precompiled binaries is not a very friendly way to do things. So it's not really an option.
11:33:56 <mehrheit> works for me
11:34:00 <schme> Ya I'll try wine.
11:34:08 <ndm> schme: if your code becomes interesting enough to tempt a windows user, and works with the standard cabal thing, they will contribute one for you
11:34:16 <TomM1> "What is this "Windows" everyone speaks of?" -- One of my grand children, I hope.
11:34:18 <dons> schme: no, i mean, you identify some alpha tester who can compile it for you
11:34:26 <schme> What is this cabal?
11:34:35 <dons> i.e. they can: cabal install
11:34:36 <dons> it
11:34:37 <pastorn> TomM1: :)
11:34:49 <schme> Uh..
11:34:51 <dons> schme: the package system used to distribute and build haskell code, see hackage.haskell.org
11:35:11 <schme> no what it needs is not something like that. It needs a lil program named setup.exe with a nice icon to click.
11:35:22 <schme> completely source free.
11:35:44 <dons> ok. so you're going to need a windows computer. whether yours, or borrowed.
11:35:52 <schme> Ya.
11:35:59 <pastorn> or react os
11:36:01 <schme> I'll try the wine or the reactos first though.
11:36:08 <dons> pastorn: has anyone tried ghc on reactos?
11:36:14 <dons> i've not heard any reports.
11:36:15 <pastorn> dons: dunno
11:36:43 <schme> 'cause I'm not living in fantasy land where the majority of windows users have any interest in doing source based installs and compiling shit ;)
11:36:58 <dons> schme: i was suggesting you find 1 windows user who can do that.
11:36:59 <ndm> schme: if your project is useful and popular, a windows user will do that for you
11:37:02 <dons> and have them build it for you.
11:37:04 <dons> then you host the binary
11:37:26 <ndm> if cabal/hackage gets sufficiently improved, it may do that for you
11:37:28 <dons> that part is easy in comparison to writing good software in the first place :)
11:37:30 <schme> "useful" is not so very likely :)
11:37:44 <schme> I mean it's a game.
11:37:51 <TomM1> dons: To finish up the conversation from yesterday, the nano-md5 test fails almost immediately when I do "ghc --make nano-md5-test.hs ; ./nano-md5-test"
11:37:51 <ndm> useful = wanted by a person, i.e. provides fun
11:37:52 <dons> anyway, you need to learn about cabal, since that's how you build this stuff
11:37:57 <dons> TomM1: huh.
11:38:03 <schme> Huh..
11:38:06 <dons> i wonder if openbsd uses a variant of openssl
11:38:10 <ndm> i really wouldn't worry about distributing it to windows users, you are miles away from that
11:38:13 <dons> TomM1: i couldn't get failures before or after.
11:38:15 <schme> I thought I just ran stuff through ghc to compile stuff.
11:38:25 <ndm> dons: they wrote it, they use the original openssl
11:38:31 <newsham> schme: first you need to make a program that is interesting to windows users.  the nyou can work about the installer for it.
11:38:37 <TomM1> dons: Perhaps.  I would also expect fewer or no faliures if the haskell threads were able to run on separate OS threads, of course.
11:38:41 <schme> ndm: My goal is to have it distributed to windows users. anything else comes second hand.
11:38:44 <Deewiant> http://galois.com/~dons/images/monad-fail.png - laughter ensued
11:38:47 <ndm> dons: i believe they write one for openbsd, then give a variant to everyone else, with portability bits
11:38:48 <dons> ndm, no, not openssl.
11:38:53 <dons> you're thinking of openssh
11:38:57 <ndm> oh, yeah
11:39:08 <ndm> they are only an r apart...
11:39:28 <schme> newsham: Mmm.. figured there was some install generator thing abouts somewhere. all windows programs seem to install pretty much the same.
11:39:31 <schme> oh well.
11:39:40 <dons> TomM1: did you check that the new version is ok then?
11:39:43 <newsham> there are installer generators, more than one of them.
11:39:43 <ndm> schme: there is one for gtk2hs, dcoutts wrote it, its very nice
11:39:47 <TomM1> dons: I'll do that now.
11:39:56 <newsham> and often seperate from the compiler environment.
11:39:58 <Peaker> Deewiant, I don't get it
11:40:17 <schme> ndm: No I meant all windows software in general.
11:40:18 <dons> Peaker: http://failblog.org/
11:40:18 <lambdabot> Title: The FAIL Blog
11:40:27 <ndm> schme: oh, no, there isn't
11:40:31 <newsham> not all windows software uses the same installer.
11:40:50 <schme> Too bad.
11:40:55 <newsham> anyway, you need to write software first, installer comes later.
11:41:30 <schme> Well of course.
11:41:34 <schme> just a bitch with the compiling there.
11:41:58 <newsham> windows developers write software on windows.
11:42:01 <ndm> compiling is a 10 second job, once you've written the software
11:42:03 <newsham> tis the way of the world
11:42:03 <schme> building a qemu for that reactos at the moment.
11:42:32 <pastorn> cool :D
11:42:45 <schme> That makes little sense. I've written portable software before and I never touched windows.
11:42:54 <wolgo> This is weird: mult3 :: Int -> (Int -> (Int -> Int))
11:43:01 <newsham> and you distributed installers for windows?
11:43:27 <schme> No. They were not aimed at the crowd that had no idea about anything.
11:43:37 <schme> I think I need one of those MSI things.
11:43:42 <wolgo> so this means mult3 x y z where mult3 x returns a function that returns a function that takes an Int as an argument?
11:43:48 <newsham> I like "NSI" from nullsoft.
11:44:06 <ndm> newsham: have you ever looked at NSI, its really badly designed...
11:44:22 <newsham> i've not looked at it internally, i've used it to wrap commercial software.
11:44:33 <wolgo> @type mult3 x y z = x * y * z
11:44:34 <schme> I'll take a look at that nsi.
11:44:34 <lambdabot> parse error on input `='
11:44:40 <wolgo> @type let mult3 x y z = x * y * z
11:44:42 <lambdabot> <no location info>:
11:44:42 <lambdabot>     not an expression: `let mult3 x y z = x * y * z'
11:44:46 <Deewiant> wolgo: yep, and it's actually the exact same thing as Int -> Int -> Int -> Int
11:44:48 <schme> Ya who gives a fuck about how well the installer is designed anyway.
11:44:59 <Deewiant> @ty let mult3 x y z = x*y*z in mult3
11:45:00 <lambdabot> forall a. (Num a) => a -> a -> a -> a
11:45:09 <schme> Hrm.. reactos downloads seems not to be movin' :(
11:45:15 <wolgo> ok
11:45:28 <wolgo> this currying business is neat
11:45:48 <newsham> partial application is way cool
11:46:01 <schme> Is there some haskell opengl tutorial anywhere?
11:46:01 * wolgo would like to add that while it is neat there are somethings his noob mind has yet to comprehend
11:46:35 <newsham> http://www.haskell.org/haskellwiki/Opengl
11:46:36 <lambdabot> Title: OpenGL - HaskellWiki
11:46:37 <wolgo> @type add
11:46:39 <lambdabot> Not in scope: `add'
11:46:47 <wolgo> @type sum
11:46:48 <lambdabot> forall a. (Num a) => [a] -> a
11:46:55 <newsham> first hit on google
11:47:16 <schme> Not in my google :S
11:47:31 <Deewiant> @go haskell opengl
11:47:31 <lambdabot> http://www.haskell.org/HOpenGL/
11:48:10 <newsham> then you didnt click on the first link
11:48:22 <schme> Is there a way to automate the ghc install + source compilation and installation of that in the right places?
11:48:22 <opqdonut> or didn't use the right google!
11:49:42 <schme> That would make things easier.
11:49:46 <schme> but more to distribute.
11:50:08 <ndm> schme: cabal does all this
11:50:46 <TomM1> dons: The test program succeeds at making my CPU hot, but omits nothing :-)
11:51:02 <TomM1> s/omit/emit/
11:51:26 <schme> ndm: It looks to me that cabal requires a lot of typing and not just clicking setup.exe
11:51:35 <mix25> There is debugger for haskell ?
11:51:39 <TomMD> schme: cabal install frag
11:51:50 <TomMD> mix25: Use ghci, which has a debugger.
11:51:52 <schme> hmmm..
11:51:59 <schme> and that will install ghc + the stuff ?
11:52:00 <newsham> you dont use setup.exe to compiler your program.
11:52:03 <ndm> schme: you can automate it all
11:52:10 <newsham> yo use setup.exe to install a binary that you already compiled
11:52:14 <TomMD> schme: Nope
11:52:17 <mix25> how, do u know some web site to read how to use it
11:52:24 <schme> Well then cabal is not what I want.
11:52:28 <wolgo> you can do :?
11:52:31 <newsham> you can use cabal to organize the build process
11:52:34 <ndm> schme: it is....
11:52:34 <wolgo> that shows the help file
11:52:37 <TomMD> ?where debugger
11:52:38 <lambdabot> I know nothing about debugger.
11:52:39 <ndm> mix25: yes, there was a monad reader article
11:52:40 <TomMD> ?where debug
11:52:41 <lambdabot> I know nothing about debug.
11:52:41 <newsham> it might not be what you want, but it is what you asked for.
11:52:46 <ndm> @google monad reader debugger
11:52:47 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad.Reader
11:52:47 <lambdabot> Title: The Monad.Reader - HaskellWiki
11:52:47 <schme> ndm: I was just told it wan't :P
11:52:57 <mix25> Monad
11:52:58 <schme> wasn't
11:53:18 <ndm> mix25: monad /= monad reader, its just the name of a magazine
11:53:36 <ndm> mix25: http://www.haskell.org/sitewiki/images/0/0a/TMR-Issue10.pdf - article on the debugger is the second one
11:53:46 <schme> See what I need is a setup.exe that checks for ghc, not there? well we install that, then do that cabal thing with this game thing. preferably without using any form of online activity, ie. some local repo.
11:53:47 <TomMD> @where+ debugger http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html
11:53:48 <lambdabot> It is forever etched in my memory.
11:53:48 <ndm> uses a really cool library to illustate as well ;-)
11:54:07 <schme> So I suppose I need to distribute ghc with the source. which is bollocks too :S
11:54:08 <schme> gaah!
11:54:36 <mix25> thanks
11:54:51 <ndm> schme: i think you need to write your amazing game first, then you'll find its a few minutes to distribute it, but all  much easier once you aren't talking hypothetical
11:55:29 <schme> ndm: Well.. though. if it's this much trouble to distribute it I'll just hack it up in java though. No need to get started on something if it won't work in the end :)
11:56:32 <newsham> that is another alternative.
11:56:58 <schme> Ya I just fucking hate java though.
11:57:10 <edwardk> ddarius: hrmm when is that?
11:57:14 <newsham> you could also use scala, which is a functional language that lets you use normal java virtual machines
11:57:18 <schme> It seems much easier to just figure out how to do a binary. This cabal thing seems very complicated.
11:57:32 <newsham> cabal is very simple compared to writing a game.
11:57:33 <Ugarte> If you really want portability, you should probably just distribute a single-purpose OS on a bootable disk.
11:57:50 <Ugarte> Fucking around with languages and runtimes and library dependencies is just a recipe for disaster.
11:57:51 <schme> Ugarte: That's a lot more work.
11:57:52 <newsham> cabal is the moral equivalent of Make or ant.
11:57:55 <edwardk> ddarius: ah found it
11:58:24 <schme> newsham: Yes. I don't want to force anyone running make
11:58:25 <newsham> if you plan to distribute your program as source, cabal will make it easy for people who have haskell installed to install your package.
11:58:42 <newsham> if you're just going to build and distribute a binary with an installer, you don't need to worry about cabal
11:58:49 <newsham> (but it can still help you with your work)
11:58:50 <schme> newsham: As long as I can automate it so all people do is click setup.exe and it works with the offline, then cabal sounds supersweet.
11:59:28 <newsham> ?faq can haskell build a windows binary?
11:59:28 <lambdabot> The answer is: Yes! Haskell can do that.
11:59:41 <newsham> cabal has nothing to do with setup.exe
11:59:46 <Ugarte> Er, backing up a little bit, if you just want a setup.exe *binary*, why all thet alk of distributing GHC, compilation, etc?
12:00:00 <newsham> ugarte: he's confused himself (several times)
12:00:22 <schme> Ugarte: I have no idea. I started out with wanting a binary to distribute and people started saying cabal and compilation was the way to distribute stuff.
12:00:34 <Ugarte> schme: No, if you want to distribute a binary, you can do so
12:00:46 <schme> Ya that's what I figured too.
12:00:52 <Saizan> Ugarte: he doesn't want to compile from windows
12:00:55 <schme> It seems a lot easier than using cabal.
12:00:57 <newsham> schme wants to write his software on a non-windows platform, have it build a windows binary, and then ship it to the unwashed masses
12:00:58 <edwardk> ddarius: i'll see if i can schedule the timeoff work to at least show up for the workshop
12:01:03 <Ugarte> Saizan: Ah.
12:01:03 <newsham> but he doesnt want to install windows
12:01:05 <Ugarte> ...
12:01:15 <Ugarte> I regret having spoken up.
12:01:18 <schme> windows is a bit too expensive to buy just to develope some stuff. that is the issue.
12:01:42 <schme> Wow the reactos install is broken :S
12:01:53 <ndm> schme: is this software open source?
12:02:05 <newsham> it sounds to me that perhaps it is too expensive for you not to buy windows
12:02:06 <schme> ndm: I think it is. Ya.
12:02:09 <Ugarte> I'm sort of confused. You want to distribute software for Windows, but you don't want to install Windows?
12:02:17 <Ugarte> There are a number of issues with that policy.
12:02:29 <Ugarte> Aside from the whole issue of how to make the binaries, the far, far bigger issue is how you're going to do testing and so forth.
12:02:34 <ndm> schme: i guarantee that if you make the software so people want to use it on Linux, some Windows user will do the copmilation for you
12:02:44 <schme> ndm: ??
12:02:49 <ndm> in fact, if the game looks fun, and someone on Linux told me it was fun, *I* would build a binary for it
12:02:51 <schme> ndm: What does this have to do with reactos?
12:02:51 <newsham> ndm: I dont think he wants to let someone on linux have the src code :)
12:02:58 <TSC> Ugarte is a Microsoft shill
12:03:04 <Ugarte> That is, in fact, true.
12:03:13 <newsham> I'm declaring troll on this one.  enjoy.
12:03:16 <Korollary> TSC is a big pharma shill
12:03:16 <Ugarte> hehe
12:03:26 <Ugarte> This is rapidly spiralling downhill.
12:03:54 <schme> ndm: I don't really care that much about if people want to use it on linux though. The goal is to have it easily install for me missus so she will be happy.
12:04:07 <schme> then if people play it on linux.. well fuck if I care.
12:04:14 <TSC> Your missus uses Windows?
12:04:14 <Ugarte> For your missus?
12:04:15 <ndm> schme: ah, does she have a windows machine? and is somewhere near you?
12:04:16 <Ugarte> What?
12:04:17 <schme> They tend not to need setup.exe's anyway.
12:04:26 <schme> TSC: yup.
12:04:29 <schme> ndm: indeed!
12:04:38 <ndm> i always borrow my girlfriends computer, and install stuff for her
12:04:40 <TSC> So you have a Windows computer to build it on...
12:04:46 <ndm> that sounds like an easy solution :)
12:04:48 <schme> Ugarte: Ya. she wants a new game to play.
12:04:51 <schme> Oh.
12:05:00 <schme> Ya if you have a nice wife like that all is well!
12:05:03 <ndm> i'd just recommend her to Peggle and get on with doing something else :)
12:05:18 <Ugarte> Something makes me think that schme has a nontraditional relationship.
12:05:24 <newsham> My deceased uncle has recently left me 3,000,000 (FIVE MILLION) Windows XP licenses.  I need someone to distribute them to in america.  Please send me your email address and a small payment of $50.00 (FIFTY DOLLARS) to cover initial shipping.
12:05:39 <schme> woooh
12:05:40 <Ugarte> hahaha
12:05:42 <schme> peggle looks nasteh.
12:05:46 <dogbite> Could somebody explain the type signature of the 'updateState' function in the writeup on this page?
12:05:49 <dogbite> http://weblogs.asp.net/brianbec/archive/2004/10/20/245338.aspx
12:06:06 <dogbite> I don't understand how 'St' is both an Int
12:06:07 <ndm> Peggle is always the answer to someone wanting a new game - http://www.popcap.com/games/peggle/
12:06:08 <lambdabot> Title: Peggle&#153; Official Site - PopCap Games - Free Download Games
12:06:17 <dogbite> and a function
12:06:23 <schme> Mm.
12:06:32 <schme> Seems more fun to write one though.
12:06:38 <schme> And I need a good haskell project.
12:06:56 <Immmortal> newsham, and (FIVE MILLION) of original CDs?
12:07:45 <newsham> immmortal: sorry, that offer was meant for schme.  although I do have some linux licenses if you're interested.
12:07:46 <chessguy> dogbite: St is a function, because the State monad is basically just a wrapper around a function
12:07:50 <chessguy> @src State
12:07:50 <schme> peggle is not very free :S
12:07:50 <lambdabot> Source not found. Where did you learn to type?
12:07:52 <Korollary> dogbite: it's not an int
12:08:03 <dogbite> Earlier though they write
12:08:06 <dogbite> type St = Int
12:08:19 <Immmortal> who need these licenses?
12:08:35 <ndm> schme: your wife is worth it :)
12:08:46 <newsham> dogbite: "both"?
12:08:54 <schme> ndm: I doubt she is very interested in paying for a game :P
12:08:59 <chessguy> dogbite: oh, i didn't read the whole thing
12:09:15 <dogbite> newsham: well i know it can't be both but i'm confused
12:09:18 <chessguy> dogbite: it looks like they're using Label as their monad
12:09:24 <chessguy> state monad
12:09:33 <schme> Well thanks for the help there #haskellers.
12:09:54 <newsham> dogbite: what else does it look like its acting as?  I'm confused.
12:09:56 <dogbite> chessguy: yes, Label is a monad, but I don't understand Label St
12:10:22 <dogbite> I'm confused by the type signature of Label St in the updateState function
12:10:25 <chessguy> dogbite: in that case, St is the result of running the Label monad
12:10:26 <newsham> Label St is just Label Int
12:10:44 <newsham> since they defined St as another name for Int
12:11:20 <dogbite> What does it mean to "run the Label monad"
12:11:45 <chessguy> @hoogle execState
12:11:46 <lambdabot> Control.Monad.State.Lazy.execState :: State s a -> s -> s
12:11:46 <lambdabot> Control.Monad.State.Strict.execState :: State s a -> s -> s
12:11:46 <lambdabot> Control.Monad.State.Lazy.execStateT :: Monad m => StateT s m a -> s -> m s
12:11:55 <chessguy> @hoogle evalState
12:11:56 <lambdabot> Control.Monad.State.Lazy.evalState :: State s a -> s -> a
12:11:56 <lambdabot> Control.Monad.State.Strict.evalState :: State s a -> s -> a
12:11:56 <lambdabot> Control.Monad.State.Lazy.evalStateT :: Monad m => StateT s m a -> s -> m a
12:12:03 <chessguy> dogbite: there we go
12:12:04 <newsham> dogbite: the values in the Label monad are these state imperatives.
12:12:28 <chessguy> evalState takes a monad and gets the value out of it
12:12:52 <dogbite> well let's back up a second because you're losing me
12:12:55 <newsham> and to run it is to use the imperative and get back its final state
12:13:02 <dogbite> if i say a function is going to be of type Label St
12:13:04 <newsham> yah, perhaps we should
12:13:29 <dogbite> then I would assume that ... i mean... what we pass to 'Label' in the definition of tha tfunction
12:13:33 <newsham> its too bad they used different names for all of these things, because we could use lambdabot to test things out
12:13:36 <dogbite> would be a 'St', otherwise known as an Int
12:14:01 <newsham> the "Label St" means that its an imperative action that has a result value of type St
12:14:03 <dogbite> I don't see how you can pass a function in there instead of the St
12:14:04 <newsham> ie.  results in an integer
12:14:21 <dogbite> what's an "impreative action"
12:14:28 <newsham> err.. wait.. lemme read this more carefully
12:14:51 <newsham> ok.. I think I might understand why you said "both".
12:14:56 <newsham> they're using "St" in two different ways.
12:15:06 <newsham> on one hand, St defines the type of the state.  the type of the state is always an integer.
12:15:07 <dogbite> How's that possible?
12:15:23 <chessguy> newsham: perhaps 'effectful action' is a better term than 'imperative action
12:15:23 <newsham> on the other hand, sometimes they're also defining St as the result type of the monad
12:15:48 <dogbite> How can it be used both ways?
12:15:51 <chessguy> dogbite: this example is not explained very well
12:15:56 <newsham> while the type of the state itself is always an Int (St), the return type can by other values (anytype)
12:16:24 <newsham> can I do some examples using lambdabot?  perhaps it will clear up the roles.
12:16:29 <dogbite> sure
12:17:06 <newsham> > runState (do { x <- get; return (chr x) }) 48
12:17:07 <lambdabot>  ('0',48)
12:17:11 <newsham> > runState (do { x <- get; return (chr x) }) 65
12:17:13 <lambdabot>  ('A',65)
12:17:27 <newsham> so I have a mini "state" program here (the do expression).
12:17:39 <dogbite> okay so can i ask a question?
12:17:44 <newsham> it first get's the current state, then sets the return value to a character based on the state value.
12:17:59 <newsham> then I "ran" it with an initial state of 65, and it said the end state was 65 and the result was 'A'
12:18:03 <newsham> sure go ahead
12:18:13 <dogbite> what is the argument to 'get'?
12:18:17 <dogbite> @type get
12:18:18 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
12:18:31 <chessguy> there is no argument
12:18:32 <newsham> get takes no argument.  it fetches the current value of the state
12:18:39 <dogbite> where does it fetch it from?
12:19:02 <newsham> :type (do { x <- get; return (chr x) })
12:19:14 <newsham> ?type (do { x <- get; return (chr x) })
12:19:16 <lambdabot> forall (t :: * -> *). (MonadState Int t) => t Char
12:19:38 <newsham> so that whole thing is a value.  the value happens to be a function (wrapped up nicely)
12:19:39 <dogbite> @type runState
12:19:41 <lambdabot> forall s a. State s a -> s -> (a, s)
12:19:53 <newsham> when you use "runState" it passes the initial state as an argument to that function
12:20:03 <newsham> so inside that function it can access that state
12:20:19 <dogbite> hmm, okay
12:20:21 <newsham> in your text:
12:20:22 <newsham> newtype Label anytype = Label (St -> (St, anytype))
12:20:36 <newsham> it wraps up a funciton of type   Int -> (Int, a)
12:20:43 <chessguy> runState (State f) s = f s
12:21:14 <newsham> so later to "run" it, you give it an Int (the initial state), and it will do some work and return you a tuple with (final state, final result)
12:21:31 <newsham> now, the "initial state" and "final state" are both "St" (Int)
12:21:39 <newsham> but the "final result" can be of any type you choose
12:21:49 <dogbite> hmmm... okay
12:21:56 <newsham> in my small example above, I used a state of type Int, and a result value of type Char
12:22:31 <newsham> > runState (return 'C') 5
12:22:32 <lambdabot>  ('C',5)
12:22:39 <newsham> > runState get 5
12:22:40 <lambdabot>  (5,5)
12:22:46 <chessguy> @src runState
12:22:47 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:22:57 <newsham> > runState (put 8) 5
12:22:58 <lambdabot>  ((),8)
12:23:11 <newsham> "return", "get" and "put" are your primitives
12:23:18 <newsham> do you see what they do, and why?
12:23:25 <dogbite> hmmm let me think here
12:23:34 <dogbite> i understand return
12:24:05 <dogbite> @type runState
12:24:06 <newsham> "get" starts with a state of 5, and returns a final state and return value of (5,5)
12:24:07 <lambdabot> forall s a. State s a -> s -> (a, s)
12:24:17 <newsham> ie. its return value is the state
12:24:22 <newsham> (and the state is unchanged)
12:24:40 <saml> what type system is a language using if the language does Hindley Milner style type inference?
12:24:44 <dogbite> what do you mean by
12:24:50 <dogbite> returns a final state and a return value of (5,5)
12:24:52 <saml> is it System F ?
12:25:09 <newsham> dogbite: runState will give you back a tuple.
12:25:16 <newsham> that tuple has two things, the final state, and the result
12:25:32 <newsham> runState get 5 ->  (5,5)
12:25:41 <newsham> 5 is the initial value, 5 is the final value and 5 is the result
12:25:51 <newsham> runState (return 'C') 5 ->  ('C', 5)
12:25:58 <newsham> here the result is 'C' and the final state is 5
12:26:03 <newsham> (oops, I got the order backwards earlier)
12:26:15 <dogbite> okay
12:26:27 <dogbite> so we could do something like
12:26:44 <newsham> runState (put 8) 5 ->  ((),8)
12:26:50 <newsham> here the final state is 8, and the result is ()
12:27:12 <chessguy> @src Monad
12:27:12 <lambdabot> class  Monad m  where
12:27:12 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:27:12 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:27:12 <lambdabot>     return      :: a -> m a
12:27:12 <lambdabot>     fail        :: String -> m a
12:27:15 <dogbite> runState { do x <- get; put (x+2); return 'C' } 3
12:27:24 <edwardk> saml: well, there isn't a fixed type system for it, but you can embed hindley milner types in system F if thats what you mean
12:27:26 <SamB> saml: System F is an explicitly-typed langauge
12:27:26 <newsham> > runState { do x <- get; put (x+2); return 'C' } 3
12:27:26 <lambdabot>  Parse error at "do" (column 12)
12:27:29 <SamB> er. language
12:27:38 <newsham> > runState (do {x <- get; put (x+2); return 'C' }) 3
12:27:39 <lambdabot>  ('C',5)
12:27:39 <ddarius> return = (&&& id) . const; get = id &&& id; put = (const () &&&) . const
12:27:51 <newsham> dogbite: I think you're getting it :)
12:27:52 <edwardk> saml: so in that sense system f is suficient to encode the standard hindley milner stuff, but its bigger
12:28:19 <dogbite> newsham: hmmm i feel like i'm understanding a bit
12:28:20 <SamB> saml: so you could use it as the output of hindley-milner style type inference
12:28:25 <dogbite> how to *use* get, put, return.
12:28:26 <newsham> so each of those "actions" (get, put (x+2), return 'C') are values of the State monad
12:28:30 <Immmortal> what is the successor of Hindley-Milner stuff? Lama...???
12:28:31 <saml> so, HM is just implementation feature. not language feature.
12:28:35 <dogbite> i'm still getting a bit lost when i think about the details.
12:28:43 <newsham> and the   >>=   combinator simple builds a bigger value out of two smaller values
12:28:55 <newsham> (or alternately, do { }   does that...)
12:28:57 <SamB> saml: System F has type lambdas
12:29:07 <newsham> and the value itself is inert until you use "runState" to run it
12:29:10 <edwardk> saml: well, haskell isn't 'system f', so i don't understand your question
12:29:17 <newsham> (ther are other variations like evalState and execState that call runState)
12:29:45 <dogbite> so (>>=) builds a successively larger function...
12:29:51 <wolgo> I have a question about IO
12:29:55 <newsham> yup, it combines two of those state function things
12:30:03 <wolgo> Why is it treated so differently?
12:30:09 <wolgo> err
12:30:18 <wolgo> Why does it seem to be treated so differently?
12:30:19 <dogbite> where's a good place to read about evalState, execState and runState?
12:30:23 <edwardk> wolgo: because if you're lazy and you allow effects to happen in any order how can you get any work done? =)
12:30:24 <saml> eager vs. lazy evaluation is a language featuer because denotational semantics can differentiate them.  but type system is not a language feature because denotational semantics can't represent type system ??
12:30:27 <ddarius> wolgo: Treated different from?
12:30:28 <newsham> ?src execState
12:30:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:30:34 <SamB> saml: it is impossible to use Hindley-Milner inference on System F programs, since the types are already in the programs
12:30:46 <wolgo> like <- instead of =
12:30:51 <newsham> there's not much to read.
12:30:51 <wolgo> for readFile
12:30:57 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html
12:30:57 <lambdabot> http://tinyurl.com/2dn8t6
12:31:05 <newsham> > runState (do {x <- get; put (x+2); return 'C' }) 3
12:31:06 <lambdabot>  ('C',5)
12:31:07 <edwardk> wolgo: remember haskell is allowed to be lazy about the order in which functions get evaluated. so if you just allowed unrestricted IO in any statement 'when does the IO happen'? when the answer is needed?
12:31:08 <newsham> > evalState (do {x <- get; put (x+2); return 'C' }) 3
12:31:10 <lambdabot>  'C'
12:31:13 <newsham> > execState (do {x <- get; put (x+2); return 'C' }) 3
12:31:14 <lambdabot>  5
12:31:20 <wolgo> ohhhh
12:31:28 <edwardk> what about reading a file then deleting it? the 'world changes' i can't just rerun the read file after i nuke the file.
12:31:46 <Immmortal> what about Damas?Milner type inference?
12:31:50 <wolgo> I seeeeeeeeeeeeeeeeeeeeeee
12:31:53 <wolgo> oops
12:31:54 <dogbite> i see interesting
12:32:18 <edwardk> in haskell the = is read like a mathematical equality, the compiler is free to realize that foo = bar means that it can replace foo with bar wherever it sees foo, it can inline EVERYTHING if it wants to
12:32:24 <Immmortal> these from 1982, 26 years ago.
12:32:34 <SamB> saml: it is drop-dead-easy to infer/check System F types from terms...
12:32:54 <SamB> becuase every binding site has an explicit type assigned to it
12:33:21 <dogbite> okay so getting back to the definition of this
12:33:22 <edwardk> so you can't just even take the naive answer that foo = readFile "blarg", because of you said foo ++ foo, you'd break that law. because inlining foo twice in the second case would read the file twice, while in the first you'd just read it once and concatenate the strings
12:33:23 <dogbite> updateState function
12:33:33 <dogbite> the type signature makes sense because of the typesignature
12:33:40 <dogbite> of the Label value constructor
12:33:42 <wolgo> Oh ok.
12:33:43 <wolgo> I see
12:33:45 <dogbite> right?
12:33:49 <edwardk> wolgo: so the 'magic of IO' is largely tog ive you the tools to reason about when and how often an effect happens 'in the real world'
12:33:50 <wolgo> That makes complete sense
12:33:52 <saml> @go system f implemented in haskell
12:33:54 <lambdabot> http://www.tcs.informatik.uni-muenchen.de/~abel/projects.html
12:33:54 <lambdabot> Title: Andreas Abel's Projects
12:34:20 <wolgo> Thanks edwardk
12:34:23 <wolgo> :)
12:34:29 <newsham> it looks like your updateState is just an "action" that increments the state and returns the old value
12:34:39 <edwardk> not a problem. I enjoy this stuff =)
12:34:50 <newsham> so the result type is going to be the same as the state type
12:35:00 <dogbite> right, i think that's right
12:35:04 <SamB> Isn't System F also known as the 2nd-order typed lambda calculus?
12:35:13 <newsham> it's basically    do { x <- get; put (x+1); return x }
12:35:23 <edwardk> wolgo: the nice thing about doing IO this way is we give the compiler a LOT of flexibility in how it can optimize out code for us
12:35:41 <edwardk> in C or python, etc. it can really only do what we say in the order we say it. coz anything can have an effect.
12:35:51 <newsham> or in C terms, its post-increment   st++
12:36:05 <dogbite> runState ( do { x <- get; put (x+1); return x } ) 5
12:36:17 <newsham> > runState ( do { x <- get; put (x+1); return x } ) 5
12:36:18 <lambdabot>  (5,6)
12:36:21 <wolgo> So lazy evaluation increases efficiency?
12:36:24 <newsham> you need to prefix with "> "
12:36:27 <edwardk> the Haskell compiler can do incredible amounts of 'origami' on your code. letting you write modular code with simple functions and fuse it all together into a single fast loop, even though you didn't write it as a single loop. you wrote a bunch of transformation steps.
12:36:44 <dogbite> i see
12:36:48 <SamB> > runState (modify (2+)) 5
12:36:50 <lambdabot>  ((),7)
12:36:55 <wolgo> Oh, because it evaluates only when needed instead of line by line
12:36:57 <newsham> to confuse matters, they ordered their (result,state) differently :)
12:37:00 <SamB> hm.
12:37:24 <dogbite> newsham: i think that's because of how Hudak ordered it in his book.  that confused me.
12:37:38 <newsham> you can see the ordering in the type decl:
12:37:38 <edwardk> i.e. typically a haskell compiler will figure out that you went fmap (+1) . fmap (*2) . filter (>3) $ somelist, and it can turn those 3 separate recursions from the fmaps and the filter into a single recursive loop in the output code.
12:37:45 <newsham> >
12:37:46 <newsham> oops
12:37:51 <newsham> newtype Label anytype = Label (St -> (St, anytype))
12:38:02 <newsham> a function from state to (state, something)
12:38:13 <edwardk> so fmap and filter were able to be written completely separately and reasoned about in isolation
12:38:31 <newsham> whereas Control.Monad.State.Lazy defines   s -> m (a, s)
12:38:31 <SamB> edwardk: typical in what sense?
12:38:46 <dogbite> > runSate (do { l1 <- get; put (5:l1); return (head l1) }) [1,2,3]
12:38:46 <lambdabot>   Not in scope: `runSate'
12:39:06 <SamB> I'm still waiting for stream fusion to land in base
12:39:09 <wolgo> Oh that is interesting
12:39:09 <edwardk> samb: well, using stream fusion, i'm mostly using this for expository purposes. there is a little bit of the pleasant fiction in that statement ;)
12:39:16 <newsham> > runState (do { l1 <- get; put (5:l1); return (head l1) })
12:39:18 <lambdabot>  <[Integer] -> (Integer,[Integer])>
12:39:22 <newsham> > runState (do { l1 <- get; put (5:l1); return (head l1) }) [1,2,3]
12:39:23 <lambdabot>  (1,[5,1,2,3])
12:39:38 <edwardk> but it should currently at least fuse the fmaps.
12:39:53 <SamB> yes, the maps are fairly easy
12:39:59 <ddarius> That shoud fuse fine
12:41:35 <edward1> wolgo: in c or python the compiler has to work very very hard to figure out that it can fold two loops together. (and 99 times out of 100 it can't) in Haskell its implicit.
12:41:51 <dogbite> newsham: thanks a lot for all your help.  i will have to think about this some more but i'm further along!
12:41:58 <newsham> no problem.  enjoy
12:42:09 <ddarius> I'd like to see a python compiler that does loop fusion.
12:42:18 <newsham> i'd like to see a python compiler :(
12:42:19 <edwardk> heh
12:42:30 <edwardk> well i was using them as an example. i meant to say 'would have to work'
12:43:05 <edwardk> ddarius: i'm going to see if i can make it up to that workshop
12:48:59 <SamB> hmm. I just wrote a unit test in a dependently typed language...
12:51:08 <edwardk> samb: agda?
12:51:14 <SamB> yes
12:51:54 <edwardk> samb: i've been thinking about porting my category theory stuff over to agda to force some clarity. but the lack of universe polymorphism hurts and its hard to bring myself to use --type-in-type or whatever
12:52:05 <SamB> edwardk: yeah
12:52:11 <Immmortal> @go Damas
12:52:12 <lambdabot> http://www.damasjewel.com/
12:52:12 <lambdabot> Title: Damas
12:52:20 <Immmortal> @go Damas Milner
12:52:21 <lambdabot> http://citeseer.ist.psu.edu/376069.html
12:52:21 <lambdabot> Title: Certification of a type inference tool for ML: Damas-Milner within Coq - Dubois, ...
12:52:22 <edwardk> samb: i'd use coq but i can't stand the syntax. how pathetic is that ;)
12:52:33 <SamB> edwardk: I don'
12:52:39 <SamB> t like the syntax either
12:53:14 <edwardk> the main problem i have with agda is i spend an hour trying to recall enough unicode codepoints and their tex input mode equivalents every time i go to use it ;)
12:53:48 <SamB> edwardk: well, you don't have to use that library
12:53:58 <SamB> Ulf apparantly doesn't
12:54:07 <edwardk> samb: the standard one?
12:54:12 <SamB> indeed!
12:54:24 <SamB> it was just added to the test suite in the past few days
12:54:34 <edwardk> samb: heh its a very pretty software artifact, its just very hard to use in practice.
12:54:46 <SamB> agreed
12:55:06 <SamB> what I don't like is that \equiv-reasoning seems to eat all my RAM
12:55:15 <SamB> er. \equiv-Reasoning
12:55:33 <SamB> (but only if I actually use it, thankfully)
12:55:50 <edwardk> A slightly more er.. sesquipedalian API would be nice too. it suffers the haskell problem of #-resp-$, etc short names that you never remember the chosen abbreviation for.
12:56:39 <edwardk> given the unicode codepoints everywhere its not like 'shorthand promotes fast typing' since its a 'read mostly' language as a result of its encoding.
12:56:48 <SamB> edwardk: Mayvbe if we made a quick reference card for that library?
12:57:28 <edwardk> samb: i dunno. its a standard problem with any dense structure with a lot of abbeviations. i know i suffer it pretty badly in category-extras myself.
12:58:44 <SamB> edwardk: yes, but it would be easier if there was a list of the abbreviations used in Algebra.Structures in one place
12:58:54 <edwardk> yeah, that would definitely help
12:59:02 <SamB> since then you could just look down the list, instead of having to hunt through the whole file
12:59:06 <edwardk> abbreviations and common conotations of various symbols
12:59:23 <edwardk> with their associated latex entry form
12:59:31 <SamB> actually, I'd like to see a better notation for algebraic structures...
13:00:22 <SamB> dunno what it would be, though...
13:01:46 <edwardk> so with agda's current type-in-type that i saw on the mailing list, i think you could do an interesting Category record, with baked in associativity laws, build up functors, and monads, etc. over that and then reflect (->) as a category. i think that would be kinda nice and be similar to the haskell derivation. (you can do that much without type-in-type, but with type-in-type. enriched categories and 'Cat' should be expressible at least cons
13:02:27 <edwardk> another good thing would be a guide to how to use the algebraic reasoning tools the ~=? and ? stuff, etc.
13:03:11 <SamB> ~=?
13:03:35 <edwardk> ~= should be read as ~ over ~. i just didn't have a unicode entry form handy ;)
13:03:42 <SamB> \approx
13:03:47 <SamB> just say \approx
13:03:50 <edwardk> fair nuff
13:04:14 <edwardk> ok, anyways \approx? and ?
13:04:55 <edwardk> heh i almost want a 'latexify' option to just strip the symbols down to \foo's
13:06:25 <SamB> I just wish that my Emacs could tell me how to type them...
13:06:31 <edwardk> but, in general i kinda think Category.Monad should look more like: http://math1.unice.fr/~maggesi/lc/Monad.html than the current RawMonad
13:06:32 <lambdabot> Title: Monad
13:06:37 <edwardk> yeah
13:06:42 <SamB> edwardk: clearly
13:07:09 <edwardk> Maggesi's coq version is very clean. (and it introduces the beautiful module over a monad concept)
13:07:17 <SamB> I mean, clearly RawMonad is not enough to do more with them than use them to do output...
13:07:23 <edwardk> yeah
13:07:51 <SamB> and I don't really have any desire to do output in that fashion
13:08:24 <roconnor> edwardk: join and map ought to be part of the record structure.
13:08:37 <SamB> What I would like would be a form that would let me write an expression and have Agda write the normalization after it, updating as I go...
13:08:43 <roconnor> and then smart constructors used to generate default values.
13:08:52 <SamB> roconnor: hmm?
13:09:00 <edwardk> roconnor: yeah though then you need to bake in the rest of the laws.
13:09:21 <edwardk> in this case he was just using monads, he didn't care about functors, etc. so sure, in a general library setting a lot more should get baked in.
13:09:39 <roconnor> edwardk: you just need one more law for each new functions saying that it is equivalent to its definition.
13:09:45 <SamB> honestly, I wouldn't want to use anything in Agda that I wasn't able to prove things about
13:10:05 <roconnor> edwardk: oh dear, and you need to work with setoids instead of sets
13:10:08 <SamB> because otherwise I'd just end up with something I couldn't prove things about
13:10:21 <SamB> roconnor: indeed, indeed...
13:10:43 <roconnor> sorry, maybe I shouldn't drop into the middle of the conversation
13:11:04 <edwardk> roconnor: i was putting it up as a model, not as a candidate for direct inclusion =)
13:11:55 <SamB> edwardk: but I surely would need setoids
13:12:06 <SamB> \equiv would not be enough for me
13:12:11 <edwardk> anyways to be done write you want universe polymorphism don't you? coz even setoid needs to get 'lifted up' a level to do Cat as a category.
13:12:22 <SamB> quite so
13:12:27 <edwardk> er s/write/right/
13:12:44 <SamB> I clearly have already run into this restriction
13:14:21 <edwardk> but with universe polymorphism that could be an incredibly elegant category theory library. i'm tempted to start it now in --type-in-type
13:14:59 <SamB> edwardk: well, the main problem with that would be that you might do things that won't work after they fix it...
13:15:04 <edwardk> yeah =(
13:15:12 <edwardk> thats why i haven't and am only tempted =)
13:15:57 <edwardk> also i don't quite no how to represent all the foo-morphism stuff in a total language.
13:16:03 <edwardk> er know
13:16:26 <SamB> hmm?
13:16:47 <edwardk> hylo- cata- ana- futu- prepro- whatever morphisms
13:17:02 <SamB> why would the total-ness be an issue?
13:17:06 <edwardk> termination criteria etc.
13:17:15 <SamB> ah! termination.
13:17:31 <ddarius> SamB: You can express all computation with hylomorphisms.
13:17:49 <SamB> I keep forgetting about that one
13:18:09 <edwardk> and metamorphisms never terminate ;)
13:18:10 <ddarius> However attempting to write hylo would presumably lead to a codata v. data issue.
13:18:47 <edwardk> but thats all productive codata so thats probably fine
13:19:30 <SamB> I wish I understood codata
13:19:35 <edwardk> yeah hylo is the sticking point
13:19:45 <SamB> but I do know that Agda lacks it atm
13:19:49 <edwardk> oh
13:19:56 <edwardk> then i can't do squat ;)
13:20:00 <SamB> at least, I think I heard it did...
13:20:25 <SamB> you could ask about the likely time frame on the list...
13:21:18 <ddarius> What's not to understand about codata?
13:21:43 <edwardk> now, you might not be able to encode hylo as a function that you can use but maybe encoding something about its properties as the least fixedpoint of the h = f . map h . g equation or something
13:22:56 <edwardk> that would let you work outside of the category manipulating constructive algorithmic morphisms algebra of programming style.
13:23:07 <SamB> ddarius: well, I don't know
13:24:11 <edwardk> in data you know you terminate because you have a base case right? you eventually reach a constructor that is terminal and stop. in codata you know you terminate because you know each constructor on the path you take can be generated in a bounded amount of time and that you only inspect a finite amount of codata.
13:24:46 <edwardk> so recursion is well-founded if it has a base case, corecursion is 'productive' if you have the bound on the time to construct each constructor on the path.
13:24:57 <SamB> ah
13:25:14 <edwardk> so it doesn't matter if the tree is infinite if i only have to build a finite portion of it
13:26:06 <edwardk> with that codata is pretty straightforward ;)
13:26:48 <vincenz> edwardk: I get your codata explanation more thn your data one
13:26:48 <edwardk> haskell data is really codata. its just not that all haskell functions are productive.
13:27:03 <vincenz> edwardk: erm, not really
13:27:21 <SamB> well, certainly it is more like data than codata
13:27:28 <edwardk> > fix (1:)
13:27:29 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:27:41 <edwardk> thats codata ;)
13:27:44 <bd_> > quotRem 5 3 :: Word160
13:27:45 <lambdabot>   Not in scope: type constructor or class `Word160'
13:27:48 <bd_> > quotRem 5 3 :: Word128
13:27:49 <lambdabot>  Couldn't match expected type `Word128'
13:28:06 <SamB> so, can you prove that "cycle xs ++ ys = cycle xs" using codata?
13:28:06 <bd_> > quotRem 5 3 :: (Word128, Word128)
13:28:08 <lambdabot>  Exception: scripts0: No instance nor default method for class operation GHC....
13:28:13 <bd_> oho
13:28:23 <bd_> the crypto lib looks like it could use a bit of work there... :)
13:28:27 <vincenz> edwardk: btw, in what way is codata the 'co' of data?
13:28:28 <edwardk> i get an 'answer' because it can generate an outermost constructor for me whenever i ask it for one.
13:30:56 <edwardk> vincenz: i always thought it was because you tended to view data through the constructors that built it up and codata through destructors that tear it down.
13:31:07 <vincenz> hum
13:32:02 <edwardk> a system like Charity bakes in the data/codata distinction by using those opposing methods of interacting with them.
13:32:03 <ddarius> codata and data coincide in Haskell
13:32:42 <shachaf> Do they also incide?
13:32:53 <edwardk> schacaf =)
13:33:01 <edwardk> only in Hask^op
13:33:34 <gubagem> whats Hask^op
13:33:34 <ddarius> vincenz: data is an initial algebra and codata is a final coalgebra
13:33:41 <edwardk> the dual category of Hask =)
13:34:27 * gubagem goes back to edit.com to write something like a mutable array 
13:34:41 <SamB> gubagem: you use edit.com???
13:34:51 <gubagem> yea
13:34:57 <gubagem> it has linecount instead of notepad
13:35:13 <ddarius> I used edit.com for years (admittedly many years ago)
13:35:14 <gubagem> i use vim on *nix
13:35:29 <SamB> as did I
13:35:45 <gubagem> you changed to ewacs, i mean ewoks, i mean emacs?
13:36:10 * maltem was wondering, for a moment, what http://edit.com has to do with cs
13:36:16 <lambdabot> Title: Edit.com: the website maintenance experts
13:37:22 <ddarius> gubagem: Why not use vim on Windows?
13:37:30 <vincenz> gvim
13:37:31 * gubagem is lazy
13:37:33 <thetallguy> anyone know what it means when 'ghc-pkg list' puts something in braces ({})?
13:37:59 <gubagem> and i heard vim didnt indent haskell code correctly
13:38:03 <chr1s> I remember (from back in the days) that gvim on windows used to suck
13:38:08 <maltem> thetallguy: A hidden package I think
13:38:22 <Igloo> I think () is hidden, and {} is broken (missing deps)
13:38:23 <ddarius> chr1s: gvim doesn't suck still (on any OS)?
13:38:41 <chr1s> ddarius: I use MacVim, it's awesome.
13:38:51 <Dzlk> it's fine if you ':set expandtabs'. by default vim uses real tabs which make layout unhappy.
13:38:55 <vincenz> chr1s: macvim, huh?
13:39:16 <chr1s> vincenz: http://code.google.com/p/macvim/
13:39:17 <lambdabot> Title: macvim - Google Code
13:39:28 * ddarius always uses a console version of vim.
13:39:31 <thetallguy> igloo: thanks
13:39:44 <chessguy> anybody got any suggestions on getting a job in functional programming (not necessarily Haskell, though I'd certainly take that if i could get it)
13:40:03 <zloog_> Anyone here use ubuntu?
13:40:03 <gubagem> try janet street capital
13:40:08 <chessguy> searching 'functional programming' on job sites doesn't seem to turn up much
13:40:14 <Lemmih> zloog_: Yes.
13:40:15 <gubagem> they use Ocaml but dont mind haskell eperience
13:40:19 <chr1s> chessguy: do a PhD somewhere?
13:40:30 <gubagem> start your own business
13:40:30 <chessguy> chr1s: that would require a masters :)
13:40:31 <vincenz> chessguy: another option is credit suiisse in london, talk to augusts
13:40:41 <zloog_> Lemmih: Have you been having problems getting ghc libraries down from the repos? (I'm using 7.10)
13:40:41 <gubagem> you dont need a masters before a phd do you?
13:40:43 <chessguy> vincenz: i'm in the US
13:40:45 <chr1s> chessguy: do a Masters first? ;)
13:40:50 <edwardk> vincenz: same problem w.r.t. to the degree i think for him
13:40:51 <Dzlk> chessguy: you'll have better luck searching on functional programming sites for 'jobs'. the haskell wiki has a few interesting leads, last I looked.
13:40:58 <vincenz> Fair enough
13:41:06 <chessguy> Dzlk: good idea
13:41:09 <vincenz> chessguy: don't have a master?
13:41:13 <chessguy> vincenz: nope
13:41:14 <ddarius> @where jobs
13:41:14 <lambdabot> I know nothing about jobs.
13:41:15 <Lemmih> zloog_: Nope, everything works fine for me. Sorry.
13:41:19 <vincenz> Don't yo uget those by default?
13:41:24 <thetallguy> maltem: () is hidden, as igloo says.
13:41:37 <zloog_> Lemmih: ok, can you tell me the version number you are using? I'm just gonna try a sys update
13:41:54 <Lemmih> zloog_: 8.04
13:41:58 <newsham> I just threw together a small tutorial on the State monad based on earlier discussion here.  Reviews/edits appreciated: http://www.haskell.org/haskellwiki/State_Monad
13:41:59 <lambdabot> Title: State Monad - HaskellWiki
13:42:02 <zloog_> Lemmih: Cool, thank you
13:42:09 <gubagem> @faq can haskell get me a job?
13:42:09 <lambdabot> The answer is: Yes! Haskell can do that.
13:42:16 <maltem> thetallguy: ah alright
13:42:17 <gubagem> there see it can
13:42:28 <vincenz> edwardk `ap` #oasis
13:42:58 <ddarius> @where+ jobs http://www.haskell.org/haskellwiki/Jobs
13:42:58 <lambdabot> Good to know.
13:43:44 <chessguy> ddarius++
13:44:11 <Dzlk> My thinking is, Haskell is less likely to get me a *job* than, say, C#, but several orders of magnitude more likely to get me a job I *like*.
13:45:34 <chessguy> Dzlk: agreed. i'm mostly looking for functional programming jobs because it says something about the company
13:45:42 <SamB> Dzlk: if you think that, you are probably right
13:45:43 <thetallguy> Dzlk:  There you go!
13:46:02 <newsham> if coders were choosers then monads would fly
13:46:18 <thetallguy> newsham: ah, but they are
13:46:34 * Lemmih grins.
13:46:36 <chessguy> @remember newsham if coders were choosers then monads would fly
13:46:36 <lambdabot> It is stored.
13:46:37 <thetallguy> that's what we did at Linspire.
13:46:47 <newsham> if ~(monads fly) then ~(coders were choosers)
13:47:46 <dons> but don't forget, getting haskell used in existing companies is also a key to success.
13:48:03 <thetallguy> We chose Haskell and let management decide if it was okay or not.  But we made it clear that without being able to use Haskell (or O'Caml earlier), it wasn't worth it to us to stay.
13:48:29 <dons> :)
13:48:59 <thetallguy> oddly, our CEO said, ``I don't care what you use, as long as you continue to deliver on time.''
13:49:02 <jaj> newsham: thanks a lot for the state howto! personally I didn't understand how State works until I read your previous conversation with dogbite and it all seems clear to me now!
13:49:08 <thetallguy> It was the other engineers who rioted.
13:49:13 <ddarius> That is the appropriate response.
13:49:16 <jaj> @karma+ newsham
13:49:16 <lambdabot> newsham's karma raised to 7.
13:49:21 <jaj> ;)
13:49:23 <dons> thetallguy: yeah. i can imagine.
13:49:48 <SamB> thetallguy: other engineers?
13:49:56 <thetallguy> at CUFP 2006, there was a fellow from NASA who switched to Scheme
13:50:25 <thetallguy> that made the C++ group uneasy, but when he tried to hire a Smalltalk programmer, they revolted
13:50:48 <mrd> they were worried about being replaced by 1 guy
13:51:12 <newsham> jaj: can you review the tutorial to see if it captures enough of the details?   http://www.haskell.org/haskellwiki/State_Monad
13:51:13 <lambdabot> Title: State Monad - HaskellWiki
13:51:15 <SamB> mrd: heh
13:51:50 <thetallguy> SamB: yes, other engineers.  They felt we were leading the company astray, indulging our own whims.  They wanted ``enterprise quality'' systems for which lots of respondents would show up when you advertised.
13:52:19 <thetallguy> One of them just sent me a message that I should look at Scala. ;-)
13:52:27 <dons> hah
13:52:41 <dons> enterprise quality, eh? :)
13:52:52 <SamB> does that mean "sucky"?
13:53:01 <newsham> thetallguy: consevatism can occasionally be a good strategy.
13:53:02 <thetallguy> dons: that term has become a quip for us
13:53:18 <newsham> and you are indulging your whims, but thats not necessarily bad
13:53:20 <thetallguy> newsham: indubitably.  that's why we let the CEO choose
13:53:33 <SamB> newsham: yes, but weeding through all those applicants is a nice thing to have to do since when?
13:53:40 <doun> **--scalable business logic solutions--**
13:53:44 <thetallguy> newsham: we just felt that imperative programming was a sunken ship
13:54:13 <newsham> I dont think its underwater yet
13:54:21 <SamB> *sinking?
13:54:26 <thetallguy> sunken
13:54:27 <newsham> sounds about right :)
13:54:33 <thetallguy> they just don't know it yet.
13:54:46 <SamB> oh, is that why mozilla is so heavy
13:54:50 <SamB> it is waterlogged?
13:55:08 <thetallguy> They are breathing trapped air.
13:55:18 <dons> mm, nice metaphor
13:55:29 <chr1s> I'm curious for the first graphical haskell browser!
13:55:34 <Dzlk> it certainly feels waterlogged.
13:55:53 <Apocalisp> I'm waiting for the first browser based on tagsoup
13:55:57 <SamB> well, imperative programming isn't going to go away. just hopefully be relegated to the dark corners where it belongs
13:55:58 <thetallguy> chr1s: I keep wanting to build it, but can't quite make a business case for it.
13:55:58 <doun> last three interviews I've had, none of them knew what Haskell was. :( one of them looked it up after seeing it on my CV (seriously, I put Haskell on my CV). he put me on the spot and made me explain why it's a good language. I mentioned some stuff about code re-usability and correctness and easiness of reasonability :\`
13:56:01 <newsham> exercise to the reader: how much imperative code are you using when you run haskell code?
13:56:11 <chr1s> thetallguy: call Opera.
13:56:14 <dons> doun: great!
13:56:26 <chr1s> maybe they're up for it?
13:56:27 <dons> doun: would be interesting to hear about what things you think work
13:56:30 <dons> when explaining to new people
13:56:41 <thetallguy> chr1s: at least, I've already ditched the idea of a Haskell plugin for firefox
13:56:46 <dons> parallelism, reusability, robustness
13:56:49 <newsham> gtk, ssl, ghc runtime, still lots of C code in there.
13:56:59 <newsham> ... someday...
13:57:01 <Baughn> Kernel...
13:57:01 <schme> scaleability.
13:57:14 <SamB> libc...
13:57:20 <Apocalisp> Scala-bility
13:57:37 <thetallguy> chr1s: but conal is on the right trail for a stand-alone browser that could ship Haskell code around
13:57:46 <newsham> zlib, sometimes xml libs?
13:57:57 <chr1s> thetallguy: oh?
13:58:08 <chr1s> what's he doing?
13:58:11 <thetallguy> chr1s: there are just a lot of pieces that still need sorting out.
13:58:16 <SamB> various bits and pieces of Haskell libraries
13:58:34 <thetallguy> chr1s: so, FRP can be the basis for more than just animation
13:58:49 <chr1s> it would be great to do something like parallel rendering of parts of pages.
13:58:53 <doun> for some reason I mentioned that seeing as programs are essentially kind of one big expression, being pure, and that haskell is strictly typed, the type system makes sure that every part of the program is in the correct place
13:59:02 <SamB> thetallguy: of course
13:59:18 <dons> doun: right. you get a sense of precision and control over the code base
13:59:24 <thetallguy> chr1s: I think it's geezusfreek who is working on a make system based on the latest
13:59:30 <doun> dons: indeed, that's what I said
13:59:44 <dons> its much harder to break the code terribly. and you can program in a way to make useful kinds of invariants impossible to break
13:59:49 <dons> so new programmers can't destabilise the system
13:59:59 <dons> no monkey patching!
14:00:22 <chr1s> dons: but if you have never heard about Haskell before, it still doesn't make a good case.
14:00:36 <chr1s> people just don't take you seriously or don't believe you.
14:00:43 <thetallguy> chr1s: tied up with that are some ideas of changing to a model where you import source, no files, no text, just a datatype that represents source
14:00:49 <newsham> cern's www took off before most people ever heard of html
14:00:50 <dons> there was a long thread last year about an 'elevator pitch' for haskell
14:00:59 <Dzlk> If JavaScript can work well as a compilation target it might be interesting if a server could send code to run directly in the Haskell browser and compile to js for others.
14:01:10 <thetallguy> chr1s: the compiler is always available as a library
14:01:34 <SamB> dons: yes, but how many elevators have whiteboards?
14:01:36 <chr1s> thetallguy: yeah. the pieces are indeed there. now the rendering part ;) maybe a soc project sometime....
14:02:27 <thetallguy> given all that, one could then make a browser that accepted expressions of type GIO (graphical IO), where that was restricted to rendering output and reading input from mouse/keyboard.
14:02:44 <dons> so , for those not around earlier, looks like the great language shootout is getting a quad core machine
14:02:48 <thetallguy> much the way lambdabot controls its users
14:02:49 <dons> and they're seeking new benchmarks
14:02:58 <chr1s> dons: awesome.
14:02:58 <dons> any suggestions from the `par` happy fiends?
14:02:58 <doun> cool
14:03:16 <dons> in particular, they want feedback on , "Are there particular problems/tasks which come to mind as something we might use as a benchmark?"
14:03:22 <thetallguy> chr1s: Andy Gill and Conal are now working on making 3D FRP libs...
14:03:45 <dons> elliottt built an FRP based irc bot this week
14:03:55 <dons> nice event despatch mechanism
14:04:01 <thetallguy> chr1s: I'm thinking again about user interface design and structure.
14:04:46 <thetallguy> at seereason, we're working on collaborative web-based user interfaces.  We'd be done if we had such a browser...
14:05:01 <chr1s> dons: maybe some standard map/reduce problems (are there standard problems for that?)
14:05:02 <thetallguy> dons: thanks, I'll ask him about that.
14:05:37 <newsham> dons: is there code or documentation on frp bot online?
14:06:02 <thetallguy> ?seen elliottt
14:06:02 <lambdabot> elliottt is in #haskell and #xmonad. I last heard elliottt speak 3d 11m 1s ago.
14:06:08 <thetallguy> oog
14:08:59 <thetallguy> @send elliottt would like to see your frp bot, is code available?
14:08:59 <lambdabot> Maybe you meant: kind read seen
14:09:23 <thetallguy> I can never remember those verbs.
14:09:36 <mauke> it's called "ask"
14:09:51 <thetallguy> the deuce you say!
14:10:01 <newsham>  ?tell ?
14:10:28 <thetallguy> Ah, tell is what I know
14:10:44 <thetallguy> ï»¿@tell elliottt would like to see your frp bot, is code available?
14:10:45 <dons> yeah, i'm sure he'll make the code available
14:10:54 <dons> we were thinking of rewriting the lambdabot core in this style
14:11:21 <thetallguy> I want to write a completely new IRC/chat client
14:11:28 <thetallguy> none of them are any good at all
14:11:36 <chr1s> thetallguy: I've got some twitter-bot code lying around
14:11:50 <chr1s> might be interesting to hook it up
14:11:52 <Anthraxx> What do you want from an IRC client then thetallguy?
14:11:59 * allbery_b hands thetallguy a 2x4 to hit himself with repeatedly; it'd be less painful
14:12:07 <thetallguy> lol
14:12:13 <doun> thetallguy: what do you want your IRC client to do?
14:12:20 <thetallguy> allbery_b: noted
14:12:46 <thetallguy> first, it would be more than a linear display of conversations
14:13:27 <doun> "LEAVE B4 U UR EXPUNGED"
14:13:33 <thetallguy> it would group convos based on all clues available, who sent them, what was said, how long between entries,
14:13:47 <Elly> how would you navigate that kind of user interface?
14:13:49 <Anthraxx> But wouldn't that make a big mess of conversations?
14:13:51 <thetallguy> it would allow conversations to be summarized
14:14:03 <Elly> what would the UI even look like?
14:14:13 <thetallguy> so that they could automatically become more like wiki entries
14:14:13 <schme> thetallguy: Just use some elisp IRC client and hack it up to put all the stuff you want sorted in different buffers.
14:14:24 <thetallguy> schme: blech
14:14:42 <thetallguy> schme: there are lots of things like that
14:15:13 <schme> So what would you be doing that's new then?
14:15:17 <thetallguy> I'm thinking more of a living, breathing, conversations become documents become records of our lives
14:15:34 <schme> O_o
14:15:58 <thetallguy> Everythings been done before, except when it hasn't
14:16:28 <schme> I have a hard time connecting IRC with "living, breathing" and "life" :)
14:16:39 <thetallguy> See!?
14:16:42 <Anthraxx> well, IRC could be someones life ;-)
14:16:56 <thetallguy> That's the old attitude.  If you spend time on a computer, you don't have a life
14:17:07 <schme> What?
14:17:09 <thetallguy> but what do those people consider a life?
14:17:14 <schme> Who has that attitude?
14:17:19 <thetallguy> mostly chatting with other people.
14:17:36 <thetallguy> Hollywood, most people who aren't geeks
14:17:42 <schme> I haven't met anyone who has that attitude in yars and yars.
14:17:50 <thetallguy> It's very recent that chatrooms have become normal.
14:17:52 <schme> But back to the irc client. It sounds like interesting stuff.
14:17:56 <thetallguy> like, 10?
14:18:15 <schme> I have only really found one decent irc client.. all others seem to suck in various ways :)
14:18:22 <thetallguy> Here's a simple thing that would improve things incrementally
14:18:38 <hpaste>  (anonymous) annotated "wget" with "(no title)" at http://hpaste.org/7782#a3
14:19:11 <thetallguy> identify sub conversations based on user prefix and indent
14:19:50 <schme> Ok.. but you don't need to write a new irc client to do that though .)
14:20:00 <Dzlk> thetallguy: I've been thinking about a unified IM client made of loosley coupled or orthogonal components that are more tightly integrated into the rest of Unix. I wonder if that'd be a step toward what you want.
14:20:26 <thetallguy> schme: I'm sure there are dozens of these tricks done in many clients
14:20:50 <thetallguy> Dzlk: that's certainly a part of the technical solution
14:21:22 <thetallguy> but as schme points out, it needs to be a consistent whole, not just a few tricks, because those have been done.
14:21:38 <schme> thetallguy: I'm a bit confused here about the conversations becomeing documents becoming records of our lives.. I mean why? Would that not require people to keep logs and other crap? :)
14:21:42 <schme> Mmm.
14:21:52 <schme> Just do what normal people do. integrate it all in emacs ;)
14:21:55 <thetallguy> people don't keep logs, computers do.
14:22:03 <schme> Yeah. Not my computers.
14:22:16 <thetallguy> Why not?
14:22:25 <thetallguy> You think you will remember everything?
14:22:32 <thetallguy> or you don't want it recorded.
14:22:33 <schme> main reason: Why the heck would I keep records of IRC?
14:22:43 <thetallguy> Because they are valuable.
14:22:53 <orbitz> depends on what channel you are in
14:23:01 <orbitz> i don't review my #teen-chat logs to omuch!
14:23:04 <schme> If there's something I want remembered I mark it and make a howm note of it.
14:23:13 <thetallguy> ten years from now, you will recall something and not be able to get it.
14:23:37 <thetallguy> More importantly, for a channel like this, it might well increase efficiency.
14:23:41 <Dzlk> Mm, you could have a log that's thrown out every so often unless you mark it as worth saving.
14:24:01 <schme> Yeah.. or .. well. Ijust don't log irc in the first place.
14:24:03 <schme> yay.
14:24:03 <thetallguy> already, people say something, a convo gets going, and poof, there's a wiki entry or a blog
14:24:13 <orbitz> schme: it's ok, plenty of palces do for you!
14:24:20 <schme> orbitz: hahaha
14:24:36 <schme> thetallguy: the blogosphere is a cancer though :)
14:24:54 <thetallguy> schme: Dude!
14:24:59 <orbitz> blagosphere
14:25:13 <schme> Sweet! what does mine say?
14:25:20 <thetallguy> schme: it is a hugely valuable resource, an extension of what humanity is all about
14:25:27 <orbitz> Dude! What does mine sy?
14:25:28 <schme> uhm.. right.
14:25:31 <vincenz> -> #haskell-blah ?
14:25:47 <schme> I think we have different opinions on what humanity is all about ;)
14:25:52 <Dzlk> the way logging works now I find I either leave it on all the time and retain a lot of useless junk, or switch it on and off selectively and, of course, the one conversation I want to save happens when I wasn't logging it.
14:26:07 <orbitz> Dzlk: hah
14:26:08 <schme> mmm.
14:26:12 <thetallguy> schme: I think you don't see what's happening around you.
14:26:15 <orbitz> Dzlk: maybe we just need a better log editor
14:27:17 <schme> I just C-s or C-r to where I need to go to put mark. go to next place. copy . and howm.
14:27:23 <thetallguy> lol
14:27:41 <thetallguy> Anyway, that's a sort of pastiche of what I'm imagining.
14:28:11 <schme> What the heck is pastiche?
14:28:19 <orbitz> a typ eof pistachio
14:28:21 <thetallguy> a musical, literary, or artistic composition made up of selections from different works
14:28:26 <Dzlk> I think the basic problem is that I can't know how valuable until after it's happened, and I want a logging mechanism that takes that into account.
14:28:40 <thetallguy> Dzlk: exactly.
14:28:41 <Dzlk> how valuable a conversation is.
14:28:43 <schme> Dzlk: You must log all then. Great fun to you!
14:28:55 <thetallguy> Dzlk: but you save the raw material, because it's cheap to do so.
14:29:08 <Dzlk> Right.
14:29:21 <thetallguy> schme: we're talking about a few gigabytes at $.15 / per
14:29:22 <mauke> I do the opposite since there's nothing valuable to save
14:29:36 <mauke> also, I wouldn't read the logs anyway
14:29:45 <schme> thetallguy: Ya. I'm with mauke here!
14:29:45 <thetallguy> Yikes!
14:29:48 <thetallguy> Guys!
14:30:08 <thetallguy> machines read the logs!
14:30:24 <thetallguy> help you summarize into new stuff!
14:30:26 <dons> the parallel SPEC benchmarks are another good source of possible shootout problems
14:30:32 <orbitz> my log of #haskell is almost 3 years old and is only a quarter a gig.  pretty cheap
14:30:41 <schme> thetallguy: I've been on irc for what.. 20 yars? and I have never kept a single log. Iam quite happy with that.
14:30:48 <doun> orbitz: a quarter gig? holy crap
14:31:13 <thetallguy> schme: I search through #haskell logs for tidbits I'd forgotten all the time
14:31:16 <orbitz> doun: holy crap that's big or holycrpa that's small?
14:31:34 <schme> thetallguy: Great. I have never done that. Maybe you should take notes of the important stuff.
14:31:35 <doun> #haskell is so busy. coming from Scheme it's like "an active community? what's all that about?"
14:31:36 <thetallguy> dons: I think those would be very interesting
14:31:49 <orbitz> #haskell is probably the mos tactive channel i'm in
14:32:01 <schme> ppfft
14:32:09 <schme> #femsubmissionsex beats all
14:32:17 <schme> in the activity level ;)
14:32:40 <thetallguy> schme: So that the room will be empty.
14:32:48 <doun> zillions of @hoogle and lambdabot queries probably add lots to the logs, hehehe
14:32:49 <schme> thetallguy: I do tend to keep a lot of mailing list stuff around. But that is sorted by threads. good stuff.
14:32:52 <dobblego> ~/.xchat2/xchatlogs$ du -hc
14:32:53 <dobblego> 68M     total
14:33:04 <orbitz> my log dir is 2.8 gigs
14:33:12 <dobblego> you win
14:33:27 <doun> do you actually need or use that?
14:33:35 <schme> thetallguy: What I *do* like is having my mail client, IRC client, IM client, note taking, planning, calendar, news reader, etc. etc. all neatly integrated in the same environment though :)
14:33:37 <doun> [that = those logs]
14:33:38 <orbitz> dobblego: now i can bone tons of hot ladies
14:33:55 <orbitz> dobblego: i generallly use it to extract URLs
14:34:20 <orbitz> ack that was for doun
14:36:19 <schme> keeping logs of IRC seems to me like running around with a tape recorder and recording everywhere you go.
14:37:26 <Jiten> schme: There is one important distinction. It's much much easier to find the conversation you want from the logs :P
14:37:48 <doun> orbitz: oh right
14:37:52 <schme> Jiten: pfft! audio-grep 1
14:38:03 <schme> eeh
14:38:03 <schme> 1 being !
14:38:31 <schme> I dunno though. It has never happened to me that I have though "my god. what the fuck did fuckfuck say about boggoboggo"
14:38:32 <SamB> also it's not illegal
14:38:42 <edwardk> orbitz: i just go to http://tunes.org/~nef/logs/haskell/ ;)
14:38:43 <schme> thought
14:38:46 <lambdabot> Title: Index of /~nef/logs/haskell
14:38:51 <doun> @quote fuckfuck
14:38:52 <lambdabot> No quotes match.
14:38:56 <doun> :-(
14:39:12 <schme> hahaha
14:39:39 <ehird> @quote fuck
14:39:40 <lambdabot> sorear says: [emacs haskell mode] not fucked up, just well documented
14:39:42 <Jiten> schme: Although, the most common use for my irc logs is to "find that damn url again" :P
14:39:49 <ehird> Jiten: me too.
14:39:50 <SamB> @google fuckfuck
14:39:55 <lambdabot> http://www.semiologic.com/2005/04/27/fuckfuck/
14:39:55 <lambdabot> Title: Fuckfuck
14:39:55 <ehird> You know what we need?
14:39:58 <schme> Hmm..
14:40:03 <ehird> A mix of wget--mirror and grep.
14:40:11 <ehird> wgrep 'google.com' http://tunes.org/~nef/logs/haskell/
14:40:12 <lambdabot> Title: Index of /~nef/logs/haskell
14:40:13 <ehird> voila
14:40:19 <schme> Jiten: I see.. I have this thing called "bookmarks" here ;)
14:40:29 <ehird> schme: not everything is worth bookmarking
14:40:35 <ehird> ; or indeed recognized as worthy at the time if indeed worthy
14:40:37 <Jiten> schme: do you bookmark every url you see on IRC and look at?
14:40:49 <schme> ehird: Why on earth would you want to look it up again then?
14:40:50 <ehird> oh, fuckfuck the language
14:40:54 <ehird> a trivial brainfuck cypher
14:41:00 <ehird> schme: If it was interesting perhaps?
14:41:05 <SamB> schme: you decide later on that you want to go again
14:41:08 <schme> Jiten: No. I do bookmark urls that I intend to visit again though.
14:41:11 <schme> I see.
14:41:11 <ehird> Or if you think 'ahh, X did that didn't it? Need that url again ...;
14:41:23 <SamB> schme: you intend everything in advance?
14:41:23 <ehird> schme: you might see it, not think much of it, but remember an important point
14:41:28 <ehird> and need it again
14:41:30 <schme> Well as I said none of this has ever happened to me since I started using IRC and I highly doubt it ever will.
14:41:43 <ehird> if you are a hyper-predictive multiplexer sentient AI, however -- you probably don't have this problem
14:42:00 <schme> Or maybe I just have more bookmarks than you guys ;)
14:43:01 <schme> (with proper notes attached to the bookmarks, and sorted real neat, of course)
14:43:17 <Jiten> schme: Also, it's useful if someone you know has somehow decided that a conversation went the other way instead of how you remember. Then you can easily verify who is right.
14:43:35 <schme> Yes...
14:43:47 <schme> That's also something I have never really had the need to do.
14:43:59 <Dzlk> Tho I'm sort of loath to admit enthusiasm for anything Web 2.0, I am addicted to del.icio.us.
14:44:07 <ehird> schme: Clearly you don't use irc much.
14:44:18 <schme> ehird: How so?
14:44:22 <schme> web2.0 is fucking great.
14:44:24 <ehird> Dzlk: It's hip to hate on web 2.0 for no reason nowadays. Used to be the opposite. I wonder if it'll flip again?
14:44:26 <Jiten> Me neither, I don't associate enough with people who might do that. (or they don't use IRC)
14:44:27 <ehird> It really depends on what you're doing.
14:44:37 <ehird> oh, seems schme hasn't flipped over yet
14:44:43 <ehird> What happened to rational, case-by-case thinking?
14:44:52 <schme> web2.0 is a real nice bandwidth saver.
14:45:03 <ehird> schme: uh, what.
14:45:08 <ehird> I think you're talking about ajax.
14:45:12 <schme> ya.
14:45:16 <schme> isn't that the same thing?
14:45:18 <ehird> what are you on? 56k?
14:45:29 <schme> Huh.
14:45:31 <ehird> Ajax can improve a UI's usability drastically, it's not a silver bullet.
14:45:33 <schme> For the people serving the pages.
14:45:38 <ehird> And web 2.0 is ... not very well-defined at all.
14:45:47 <Jiten> It's not just bandwidth, it also reduces the need for processing.
14:45:48 <ehird> But ajax is one part of that, sure. (I guess the others are large fonts and gradients.)
14:45:55 <Jiten> That is, when well done
14:45:58 <ehird> yes, ajax can be very useful
14:46:38 <schme> But anyway. I use IRC quite a fuck of a lot, and has for the last 15 years or so. Still never ran across any of the needs you mention :P
14:47:04 <schme> and honestly.. keeping logs to prove who's right or wrong in a conversation from yesterdi?  Who the fuck cares :)
14:47:07 <Dzlk> Actually the only real problem I have is with the discourse around it - there's a lot of hype and nonsense. A lot of the design principles grouped under "Web 2.0" are sound.
14:47:13 <ehird> schme: this is why public logs exist.
14:47:14 <doun> i has use the eye are see
14:47:35 <ehird> Dzlk: Most of that has died down a lot thankfully
14:47:44 <schme> ehird: exists for proving who is right or wrong?
14:48:02 <ehird> schme: no, they exist so you don't have to log yourself
14:48:15 <ehird> they leverage the power of the interwebnet to distribute them, I hear
14:48:28 <schme> ya.
14:48:35 <schme> never had the need of public logs either. So it's all good.
14:48:58 <schme> From what I read in the wiki web2.0 is basically sites that not just provide information but live upon user interaction.
14:49:01 <schme> seems like good stuff.
14:49:11 <Jiten> schme: The reason I keep logs is that you never know in advance when or if the time will come when they'd actually be useful.
14:49:12 <schme> participation is the word.
14:49:21 <ehird> schme: hahahahaha
14:49:28 <ehird> i'm sorry but please shut up :)
14:49:29 <Jiten> it doesn't cost much to keep them
14:49:32 <ehird> web 2.0 is a marketing term
14:49:39 <schme> Jiten: Ya. and that's the thing there. It has never happened to me that I have needed it.
14:49:43 <schme> Of course it is a marketing thing.
14:49:48 <schme> But that is what the wiki says.
14:49:52 <ehird> schme: it's called wikipedia
14:49:55 <ehird> not the wiki
14:50:15 <schme> Ya and I call it the wiki.
14:50:26 <schme> And you knew what I meant. go figure.
14:50:29 <ehird> schme: There are thousands of wikis.
14:50:34 <schme> Of course there are.
14:50:37 <ehird> Why deliberately use completely incorrect technology except to ignore?
14:50:39 <schme> But just one The wiki.
14:50:47 <ehird> It's about as sensible as calling google 'the google'.
14:50:50 <ddarius> Actually, "the wiki" without (much) context usually refers to the c2 wiki.
14:50:54 <ehird> Except that there's only one google.
14:50:57 <ehird> ddarius: Yeah.
14:51:03 <ehird> But only among nerds.
14:51:04 <ehird> :)
14:51:09 <schme> ddarius: not in my world it does.
14:51:12 <ehird> Non-techy types don't even go to 'the wiki', it's just 'wiki' to them
14:51:39 <schme> Well of course not.
14:51:57 <schme> The majority of people don't go to a computer in the first place.
14:52:05 <Jiten> schme: Anyway, in short. It takes me a couple of minutes to activate logging, the space they use is negligible and becoming even less negligible all the time and they have the potential of saving me hours of trouble someday.
14:52:16 <schme> Jiten: that's good fer you.
14:52:23 <Jiten> So, I log
14:52:27 <schme> Ya.
14:52:30 <schme> and that's great.
14:52:37 <schme> I don't 'cause I've never had any use for it.
14:53:49 <Jiten> I suspect it's more likely you've never noted a situation where they could have helped because you don't have them and therefore don't think about them.
14:54:27 <ddarius> I don't think the vast majority of people here care whether you (all) log or not or your opinions on logging.
14:54:36 <schme> ddarius: of course they care!
14:54:52 <schme> Jiten: nah. never happened.
14:55:19 <schme> I'd be more interested in keeping logs of stuff not computer related. That would make life easier.
14:55:25 <schme> Will haskell do that for me?
14:56:31 <Jiten> schme: do you keep your old email by the way? If yes, has it ever been useful that you did?
14:56:43 <schme> Ya. I keep a lot of old email.
14:56:54 <ddarius> Please take this conversation somewhere else.
14:56:57 <schme> I just have a knack for knowing which stuff to store ;)
14:57:00 <thetallguy> On another note, what's the neatest formulation of cartesian product you know of?  cp :: [[a]] -> [[a]]
14:57:02 <jaj> schme: hmm I think you'd have to hack around realWorld#
14:57:14 <schme> jaj: Cools!
14:57:26 <ddarius> thetallguy: sequence
14:57:27 <schme> jaj: hopefully I can find where the heck I put my keys then.
14:57:41 <Dzlk> @faq Can Haskell find your keys?
14:57:42 <lambdabot> The answer is: Yes! Haskell can do that.
14:57:57 <jaj> schme: it's all in realWorld# you just have to find a way to extract it
14:58:37 <thetallguy> ddarius: ahah!  I'd forgotten about that one.
15:01:07 * bos is mystified by ghc generating horrible Core.
15:02:10 <dons> bos, for what kind of code?
15:02:15 * monochrom demonstrates his infinite wisdom again on haskell-cafe :)
15:02:31 <bos> dons: bit-fiddling. i just had the brainwave of looking at Data.Bits, which explains some of it.
15:02:51 <bos> dons: this should be a tight loop updating an STUArray, but it's filled with branches.
15:03:02 <bos> but the definitions of shiftL and shiftR help to explain that.
15:03:13 <dons> hmm. there were a few wibbles, but for Int types at least, it'll constant fold these days
15:03:22 <dons> what type are you shifting on?
15:03:37 <bos> no, hm, maybe not.
15:03:40 <dons> shiftL# :: Word# -> Int# -> Word#
15:03:40 <dons> a `shiftL#` b   | b >=# WORD_SIZE_IN_BITS# = int2Word# 0# | otherwise                = a `uncheckedShiftL#` b
15:03:45 <bos> ah, that's it.  it's a Word32.
15:03:50 <dons> will constant fold if 'b' is known
15:04:08 <dons> yeah, there's a lack of 'scalability' for some of the optimisations outside of Int, Word.
15:04:17 <dons> i'm on an audit crusade against these
15:04:35 <dons> so examples are welcome.
15:04:54 <dons>     (I32# x#) `shift` (I# i#)
15:04:54 <dons>         | i# >=# 0#            = I32# (x# `iShiftL32#` i#)
15:04:54 <dons>         | otherwise            = I32# (x# `iShiftRA32#` negateInt# i#)
15:04:55 <schme> So haskell. I'm lookin' here at some haskell opengl tutorial and I get an Could not find module `Graphics.UI.GLUT' . How does one fix this?
15:05:07 <bos> oh, that's funny.  Word has an optimised shift, but not an optimised shiftL.
15:05:33 <bos> so it uses the default shiftL, which includes a test-and-branch.
15:06:18 <dons> so most of the defaults are in GHC/Word.hs
15:06:55 <bos> yeah, i see them.
15:07:05 <dons> any problems here though, let me know. i've a bunch of tickets open on this.
15:07:33 <bos> but as you can see, there's no shiftL or shiftR for any Word type.
15:07:48 <dons> ah ha. yes, so it uses the 3 way shiftL default?
15:07:50 <chessguy_> so, the thought occurred to me the other day to wonder about the notion of dependencies between functions. that is, if f = g . h, then f depends on g and h, because if either of them change, then f changes
15:07:58 <chessguy_> has such a notion been formalized before?
15:08:11 <bos> at least in the core it does.
15:08:15 <dons> hmm
15:08:26 <dons>     x `shiftL`  i = x `shift`  i
15:08:40 <bos> i don't know if any further optimisation is performed after i see -ddump-simpl.
15:08:46 <dons> none, basically
15:09:02 <dons> shouldn't the above default inline directly to the optimised shift?
15:09:20 <bos> i'd hope so.
15:09:22 <schme> No one on the GLUT?
15:09:48 <dons> schme: its in the GLUT package. see hackage.haskell.org
15:09:50 <geezusfreeek> schme: is the package installed?
15:10:14 <dons> bos, you want no test , since the shift value is constant, and >= 0 ?
15:10:21 <schme> dons: Ok Ilook there.
15:10:25 <bos> dons: righ.t
15:10:26 <geezusfreeek> chessguy: what exactly do you mean? how would such a formalization help?
15:10:43 <dons> hmm, looks like that should work. got the shift expression handy?
15:10:48 <bos> dons: but my code mysteriously got 12% slower for no apparent reason anyway.
15:11:01 <schme> geezusfreeek: I have no idea. The tutorial does not mention any need for it to be installed and it is listed in the standard libraries in GHC at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
15:11:03 <bos> it used to run in 3.3 seconds, now it runs in 3.7.  i am baffled.
15:11:10 <bos> dons: hang on.
15:11:12 <schme> geezusfreeek: So I imagine it should be installed.
15:11:15 <dons> oh, sometimes you can get, for example, ^ not floated out.
15:11:32 <geezusfreeek> schme: do you happen to be on os x with ghc installed via macports?
15:11:56 <dons> well, `shiftL` 2 works for me on Int, its constant folded, and the test disappears
15:12:01 <schme> geezusfreeek: No. debian sid linux-x86
15:12:14 <dons> and on Word.
15:12:16 <geezusfreeek> schme: hmmâ¦ well i know the macports version doesn't come with some packages
15:12:21 <geezusfreeek> schme: just try installing it
15:12:27 <dons> main = print . sumU . mapU (`shiftL` 2) . replicateU (100000000::Int) $ (8::Word)
15:12:32 <geezusfreeek> schme: yours may not have come with it either
15:12:40 <dons> bos, the above at least folds away nicely.
15:12:41 <schme> Ya.
15:12:48 <TSC> schme: apt-cache search ghc6 glut
15:12:54 <schme> no surprise there. It's debian afterall.
15:12:54 <bos> dons: darcs get http://darcs.serpentine.com/bloom
15:12:56 <lambdabot> Title: Index of /bloom
15:13:19 <bos> dons: to see the crummy code, ghc-core -- --make -O2 Data/BloomFilter.hs
15:13:23 <schme> TSC: ah cools.
15:13:26 <bos> dons: and look for the body of insertMB
15:13:29 <dons> ok.
15:13:48 <schme> What is the better way to use ghc anyway.   Using the debian packages or building from source and using that there bacal thing?
15:14:01 <bos> you'll see all kinds of tests in the body of the loop.
15:14:26 <dons> mm, yes.
15:14:29 <geezusfreeek> schme: no problem with doing ghc via apt-get, but i recommend cabal-install for packages that are on hackage
15:14:44 <dons> case >=# a5_s7a6 64 of wild4_a3t4 { False -> uncheckedShiftL# __word 1 a5_s7a6; True -> __word 0
15:15:05 <bos> dons: right
15:15:13 <geezusfreeek> schme: generally more up to date and is especially useful since it will usually offer packages that other package managers will not
15:15:33 <dons> possibly more aggressive inlining, or some strictness hints.
15:15:43 <schme> right.
15:15:44 <myname> Hi all! I need help: I'm trying to compile the HDBC-sqlite3 package and get an error message that the HDBC package is missing. HDBC is already localy installed, I just don't know how can I include it manually...
15:15:44 <dons> or specialise. something's not getting through to the compiler.
15:15:51 <chessguy> geezusfreeek: hm, maybe for documentation purposes at least
15:15:51 <chessguy> auto-generating what functions depend on this one,
15:15:51 <chessguy> so you know what you're affecting when you change a single function
15:16:06 <bos> i can't imagine what. these are all shifts of Word32 by a constant Int known at compile time.
15:16:29 <dons> yeah
15:17:15 <dons> let me see what ghc head does.
15:17:21 <ddarius> chessguy: g can change without f changing.
15:18:26 <dons> bos, actually, looks much better under ghc head
15:18:45 <dons> bos, there's no shifts in the core for insertMB
15:19:33 <bos> ah.
15:19:46 <dons> it looks a bit more polymorphic than i'd like. STUArray should aggresively inline the way uvector does.
15:19:53 <dons> but the shifts are gone
15:20:15 <hpaste>  dons pasted "ghc 6.9.May" at http://hpaste.org/7860
15:22:37 <chessguy> geezusfreeek: i was particularly thinking for type classes. if there are a bunch of functions with default implementations, determining which to override can be made a lot easier if such info were automatically generated
15:22:37 <chessguy> ddarius: well, for some definition of change
15:22:44 <ddarius> chessguy: Indeed.
15:22:50 <dons> rl was of the view that ndp arrays were much better under the head, due to improvements in the inliner and simplifier
15:22:54 <dons> so this might be an example of that, bos.
15:23:40 <Dzlk> chessguy: I think the problem with trying to formalize dependence is that the notion of "same" is kind of ambiguous.
15:24:01 <dons> bos, you'll need -fvia-C to turn on cc-options: -O3 no?
15:24:04 <dons> in the .cabal file
15:24:42 <dons> bos, also, due to the nested CPR issue, data a :* b = {-# UNPACK #-} !a :* {-# UNPACK #-} !b
15:24:47 <dons>  won't really unpack into registers
15:25:15 <dons> it'll box on returns possibly.
15:25:20 <dons> may not be an issue though
15:28:23 * SamB wonders what formulations of the integers make it easiest to prove the important properties
15:28:46 <tibbe> how do I best convert a String of hex digits to an Int?
15:28:48 * SamB wonders if he can find one that also has finite size
15:28:56 <vixey> prove binary is isomorphic to unary?
15:29:05 <mauke> > read "0x12345" :: Int
15:29:06 <lambdabot>  74565
15:29:09 <vixey> and use whichever integers are easiest..
15:29:46 <tibbe> mauke: I guess the 0x is neccesary, i.e. you can't give the base specifically?
15:30:52 <mauke> @hoogle read
15:30:53 <lambdabot> Prelude.read :: Read a => String -> a
15:30:53 <lambdabot> Text.Read.read :: Read a => String -> a
15:30:53 <lambdabot> Text.Read :: module
15:30:57 <mauke> @hoogle readHex
15:30:57 <lambdabot> Numeric.readHex :: Num a => ReadS a
15:30:57 <lambdabot> Text.Read.Lex.readHexP :: Num a => ReadP a
15:31:41 * SamB wonders if Haskell 98 even mandates reading of hex-format integers?
15:32:08 <hpaste>  beroal pasted "type Pair a = (a,a)" at http://hpaste.org/7861
15:33:57 <dons> very nice article on defunctionalisation, http://reddit.com/info/6ko4w/comments/
15:34:12 <jaj> > read 0b10111 :: Int
15:34:13 <lambdabot>   Not in scope: `b10111'
15:34:20 <cjb> is that what happens when you get bored of Haskell and take a job writing C++?
15:35:57 <saml> how can I generate all permutation of a list?
15:36:02 <bos> dons: the strict pair definitely helps performance there.
15:36:17 <bos> as for -O3, that's for compiling the C module, not the haskell code.
15:36:18 <cjb> saml: there's no prelude function, incredibly.  We can give you one, though.
15:36:25 <saml>  "abc" ==> "abc"  "acb"   "bac" ...
15:36:33 <mauke> saml: http://dis.4chan.org/read/prog/1210939612/1-
15:36:34 <lambdabot> Title: 4chan BBS - A Challenge For Prog
15:37:09 <saml> i'm a student
15:37:29 <saml> oh crap. i meant to type "i'm a student looking to get my program written for me"
15:37:32 <wolverian> haha, "Simon Peyote Joints"
15:38:04 <vixey> insertions e [] = [[e]] ; insertions e (x:xs) = (e:x:xs) : map (x:) (insertions e xs)
15:38:05 <vixey> permutations [] = [[ ]] ; permutations (x:xs) = insertions x =<< permutations xs
15:38:25 <cjb> @let permute (x:y:xs) = (map (x:) $ permute (y:xs)) ++ (map (y:) $ permute (x:xs)); permute xs = [xs]
15:38:40 <lambdabot> thread killed
15:41:30 <vixey> dons, is this (defunctionalization) something a compiler does?
15:41:47 <monochrom> Hahaha, crossing out lambda
15:41:51 <dons> bos, yeah, strict pairs are really fundamental. you can sometimes, in particular contexts, replace a polymorphic strict pairs with a specialised one, data T = T !Int !Bool, and you'll beat a polymorphic strict pair, since the return will happen in registers, removing a heap check
15:41:59 <dons> but that's got to be really tight code to exhibit this
15:42:43 <dons> bos, ok, also, you might see some good results with -fvia-C -optc-O2 or more then.
15:44:07 <thetallguy> dons: I wonder you should run a little workshop at ICFP on all these tricks.
15:44:39 <dons> heh. well, hmm, i want to make the tricks disappear. :)
15:44:47 <thetallguy> dons: seems like they are amounting to more than a blog post
15:44:54 <thetallguy> dons: yes, good point.
15:45:07 <thetallguy> much the better approach
15:45:08 <dons> some of it is going into the performance chapter of the book
15:45:17 <thetallguy> good
15:45:27 <dons> not the very specific things, like specialised strict pairs, but slightly higher level stuff
15:45:55 <dons> ghc-core is helping too, i think. more people with more knowledge about the compiler transformations
15:46:05 <dons> and more eyes watching for when things go wrong :)
15:46:07 <thetallguy> I find I"m not learning them in detail now because I'm not working on something that requires them.
15:46:08 <vixey> why is defunctionalization interesting?
15:46:19 <thetallguy> but I will want to go back later...
15:46:36 <dons> yeah, it helps to have a specific problem
15:46:51 <lilac> dons: all ghc-core provides for me is line noise :(
15:46:51 <thetallguy> yes, we don't clean up things we don't see.
15:46:53 <dons> vixey: pretty powerful compilation technique, useful for a wide range of problems.
15:47:01 <thetallguy> I have a draft of a blog post about that
15:47:09 <schme> What means $= ?
15:47:16 <dons> right. until rl started working on optimising parallel arrays, no one was really looking at the inliner
15:47:28 <dons> now there's a fair few more people poking sticks at it
15:47:39 <vixey> cool
15:47:45 <dons> making it as cheap as possible to get many eyes on the key performance parts of ghc will really help
15:47:54 <orbitz> schme: do you meant eh $ operator? it lets you not have to use so many parens
15:48:17 <lilac> dons: though i do like GHC.Prim.RealWorld
15:48:19 <thetallguy> schme: there's a ($=) operaton in http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
15:48:20 <lambdabot> http://tinyurl.com/24hd3h
15:48:32 <thetallguy> Used to assign values
15:49:02 <orbitz> (inside a monad)
15:49:02 <thetallguy> Otherwise, it means what you want it to.
15:49:13 <orbitz> thetallguy: in a monad right?
15:49:35 <schme> orbitz: Oh ya. I know of $ to uglify code. Here was some $= .
15:49:36 <thetallguy> orbitz: the OpenGL stuff is specialized state vars
15:49:38 <schme> thetallguy: That must be it, ya.
15:49:55 <lilac> does ghc do inter-module inlining?
15:50:02 <orbitz> schme: *shrug* it's not that ugly
15:50:12 <schme> so what is @ ?   foo s@(F b h)   ?
15:50:19 <mauke> aliased binding
15:50:21 <schme> orbitz: I like parens :)
15:50:23 <orbitz> schme: it lets you pattern match and assign the total to a variable
15:50:30 <thetallguy> lilac: it an, but it doesn't always
15:50:32 <schme> oh ya. Now I remember.
15:50:36 <thetallguy> s/an/can/
15:50:37 <schme> thanks #haskell-bot
15:50:39 <orbitz> schme: your evil, big surprise
15:51:05 * lilac looking at un-inlined core which i'd hoped would be
15:51:12 <schme> hahha
15:51:41 <schme> As diamond head put it: Am I evil? YES I AM.
15:51:45 <orbitz> schme: i'm sorry. "You're"
15:51:57 <dons> lilac: right, so you need to know the simple rules. big things won't inline unless you ask. explicitly recursive things won't. small things, yes. INLINE things, yes.
15:52:02 <orbitz> schme: how is the haskull coming a long?
15:52:48 <schme> orbitz: Oh you know.. I spent a week or so trying to figure it out. Then I realized the app I was writing had to be written using some other tools so I spent time with that. Now I'm back to trying to learn haskell.
15:53:03 <lilac> dons: i have three functions all recursing down a list and performing simple transformations; will adding INLINE help?
15:53:17 <schme> orbitz: This time around I figured I'd just avoid reading all the tutorials and just throw code att ghc and bug you guys when it does not work.
15:53:56 <schme> cause well.. the tutorials are boring as bad fuck :)
15:54:01 <orbitz> schme: you should get Simon Thompsons book.  I quite like it
15:54:52 <hpaste>  (anonymous) pasted "get" at http://hpaste.org/7862
15:54:52 <schme> The craft ... ?
15:55:20 <orbitz> schme: yes
15:55:31 <SamB> hmm, commutativity at least looks easy to prove for a digital representation
15:55:32 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml   FP books I use.  I recommend Bird's. Both of them. :)
15:55:33 <dons> lilac: only if there's some optimisation that'll be enabled by moving them to the call site.
15:55:40 <schme> Iseem to remember seeing that at the library. I will check it out.
15:55:56 <orbitz> schme: Paul Hudak's book is a bit more exciting too.
15:56:08 <schme> I hope it just avoids "omg! this is a list! have you ever seen a list before? You can do stuff with lists!" and the "omg! lemme show you recursion! 'scool!"
15:56:34 <schme> Cools. I'll take a look at that too :)
15:56:39 <monochrom> Bird's introductory book has monads, monad transformers, and what's wrong with foldl and how foldl' solves it.  To date there is still no other book covering all of them.
15:56:53 <monochrom> In fact there is still no other book on the last one.
15:56:56 <lilac> dons: I believe the loops can be fused together, but even with INLINE i'm not seeing it happen. perhaps i'm expecting too much from ghc
15:57:11 <orbitz> schme: since GUI's are pretty easy in haskell, it jumps righ tinto problem solving with graphics
15:57:21 <schme> orbitz: Sounds great.
15:57:38 <schme> I find learning fp through multimedia
15:57:42 * vixey is reading Algebra of Programming
15:57:46 <orbitz> schme: the GUI API has changed a bit since his book was relased (or atleast my copy), so if you get it, beware
15:57:47 <MyCatVerbs> orbitz: hang on, whut?
15:57:58 <orbitz> MyCatVerbs: which part?
15:58:10 <schme> Well stuff always changes :)
15:58:14 <MyCatVerbs> orbitz: honestly I haven't bothered to look into it very much at all, but relatively easy GUI work? Please elaborate?
15:58:27 <schme> So top 10 or so haskell books one should order would be .. ?
15:58:28 <monochrom> Nothing changes. Ever. Mutation does not exist.   <duck>  :)
15:58:45 <orbitz> MyCatVerbs: well drawing graphics and stuff is pretty simple in haskell, just important some modules, link the lirbaires, and you are off to the races
15:58:53 <vixey> mmm which philosopher was this..
15:59:01 <orbitz> schme: the two i metneiond are the ones i have and i like them
15:59:24 <Dzlk> Parmenides, I think.
15:59:25 <schme> Ah cools.
15:59:33 <vixey> yes!
15:59:52 <orbitz> schme: and http://www.haskell.org/ghc/docs/latest/html/libraries/ is my main source
16:00:00 <dons> lilac: the loops won't generally fuse unless you're programming for a specific loop fusion optimisation
16:00:03 <schme> :)
16:00:05 <dons> such as buld/foldr or stream fusion
16:00:26 <dons> general recursion doesn't fuse in ghc. (nor any non-research system)
16:00:34 <lilac> dons: :( ok. interestingly, in one case i'm seeing stuff getting inlined only if i *don't* add INLINE
16:00:43 <monochrom> "top 10 haskell books" = buy them all!  since we haven't got 10 yet. :)
16:00:44 <dons> is the example small?
16:00:58 <lilac> dons: yes, i'll check how much supporting stuff it needs
16:01:39 <dons> monochrom: i dispute that. we must be close now, http://haskell.org/haskellwiki/Books
16:01:40 <lambdabot> Title: Books - HaskellWiki
16:02:03 <monochrom> oops, forgot to count the japanese book etc.
16:02:09 <dons> 19 if you count foreign languages
16:02:15 <dons> and 2 out of print books
16:02:22 <dons> there's likely half a dozen others floating around
16:02:27 <dons> fairly rare though
16:03:12 <hpaste>  lilac pasted "Adding INLINE causes less inlining" at http://hpaste.org/7863
16:03:42 <lilac> dons: remove the INLINES from that example, and 'trigraph' gets inlined. and then it looks like the 'trigraphs' loop gets unrolled a bit?
16:04:15 <dons> right. you can end up with a bigger, recursive thing that can't be inlined
16:04:16 <lilac> dons: data Source a = Source SourcePos a
16:04:22 <dons> trigraphs for example
16:04:35 <monochrom> Some are "data structure and algorithms in haskell" type, which I hesitate to count, since they don't teach haskell.
16:04:42 <lilac> dons: without the INLINE, everything gets inlined AFAICS
16:04:56 <monochrom> Well, they teach some haskell. It's a grey area.
16:05:16 <lilac> (including trigraphs into itself)
16:05:31 <monochrom> I mean, "data structure and algorithm in C++" clearly doesn't teach C++. :)
16:05:52 <dons> monochrom: certainly
16:14:30 <orbitz> drats, i wish TAM didn't cost so much so I could go this year
16:15:12 <Dzlk> I have a "data structures and algorithms in C++ pseudocode". It's the worst of all worlds. :)
16:17:37 <vixey> what other ways are there to annotate a data structure
16:17:40 <vixey> like first going from
16:17:42 <vixey> @src Maybe
16:17:42 <lambdabot> data Maybe a = Nothing | Just a
16:17:45 <vixey> to
16:17:53 <vixey> data Maybe ctx a = Nothing ctx | Just ctx a
16:19:02 <doun> what's all that about?
16:20:46 <orbitz> what is the poitn of ctx?
16:22:41 <schme> Hmmm.. Is there some easy way to eeh.. how to say... It seems that there are a lot of functions named *Color* in this package I'm using. Is there some easy way to make it so I can put *Colour* in my source and it just works?
16:23:12 <monochrom> I think you can go from (Maybe a) to (Maybe a, ctx).
16:24:10 <vixey> I should have used a recursive type as an example
16:26:14 <orbitz> schme: you want to spell color different than the module does?
16:26:52 <schme> orbitz: Yes.
16:27:51 <orbitz> schme: is Color the name of th emodule or a type in it?
16:28:18 <doun> personally I just assume American English for my code, saves the hassle...
16:28:31 <orbitz> that too
16:28:41 <schme> orbitz: oh it's types, functions. lotsa stuff that has color in 'em.
16:28:58 <orbitz> schme: modify your editor to fix your typing on the fly
16:29:02 <schme> orbitz: What I'm interested in is telling ghc to read my source and change all colour to color whet it compiles.
16:29:15 <schme> I'd rather not. It's so ugly to look at.
16:29:21 <schme> whet = when
16:29:22 <orbitz> hrh
16:29:28 <orbitz> yeah, i love dem 'u's
16:29:39 <orbitz> schme: that would be an incredibly silly feature for a compiler
16:29:41 <orbitz> schme: learn awk?
16:29:46 <schme> I know awk.
16:29:58 <orbitz> or just Get Over It (tm) and spell i tliek the module want
16:30:01 <schme> I'm just asking if there is a haskell way to do this.
16:30:13 <schme> Hah. Not bloody likely.
16:30:20 <orbitz> i don't think that is a problme programming languages are designed to deal with
16:30:33 <schme> ok.
16:30:41 <schme> I really just need a yes or a no here.
16:30:49 <schme> Yer a bit crazy in this channel really :)
16:30:59 <dons> you want a macro to rewrite your source?
16:31:02 <orbitz> "hrm.. programmers may not like it when some peopel use american vs english english in their code, we should make our ocmpiler able to transform it
16:31:07 <schme> dons: sure.
16:31:16 <dons> schme: you could write a macro to do that
16:31:23 <mauke> pipe through cpp and use a #define
16:31:28 <mauke> THIS CAN ONLY END WELL
16:31:30 <schme> dons: cools. Where do I look for info on that?
16:31:40 <dons> -pgmp 'sed 's/colour/color/g'
16:31:42 <thetallguy> @yow
16:31:42 <lambdabot> Jesuit priests are DATING CAREER DIPLOMATS!!
16:31:44 <dons> would be the approx. compiler flag.
16:31:55 <schme> ah sweet. thanks.
16:32:29 <dons> its a little bit more involed, actually, gimme a sec.
16:32:48 <schme> THERE ISNOT! IT'S SUPERSWEET! STOP COMPLICATING IT.(
16:33:04 <schme> dons: I liked you a lot more before you said there was more to it. :(
16:33:17 <dons> the input and output files are specified as arguments to the preoprocessor
16:34:07 <orbitz> schme: i think you should just stop spelling words like an idiot
16:34:11 <orbitz> ther eis no 'u' in color!!!
16:34:53 <dons> ?spell colour
16:34:59 <dons> oh, no aspell.
16:35:01 <mauke> lern2latin
16:35:15 <schme> orbitz: Nah. that has never worked.
16:35:29 <orbitz> go back to scheme! nobody likes you!
16:36:16 <schme> Go back to scheme?
16:36:21 <schme> Sorry. not following you there :(
16:37:23 <vixey> orbitz..
16:38:17 <orbitz> hai
16:38:56 <hpaste>  dons pasted "text rewriting using a custom preprocessor" at http://hpaste.org/7864
16:39:08 <dons> schme: there you go, you evil evil person
16:39:38 <schme> ah 'scool. thanks dons.
16:40:01 <schme> orbitz: For the record I try to stay way clear of scheme.
16:40:04 <hpaste>  wolgo is doing  pasted "testing how tight different operations bind" at http://hpaste.org/7865
16:40:11 <newsham> they can take you out of australia but they cant take the u out of colour
16:40:20 <dons> bloody oath.
16:41:17 <vixey> wolgo: functions bind tighter than operators
16:41:23 <dons> according to the slang dictionary, you are supposed to translate that as , "that is certainly true" :)
16:41:26 <wolgo> I learned that
16:41:47 <wolgo> because of this error: blah blah In the expression: (b x) * y
16:42:07 <wolgo> I was on a windows machine using cmd and ghci
16:42:25 <wolgo> things were not working out for me
16:42:37 <wolgo> Hey I think that the documentation is really good
16:45:57 <schme> orbitz: oh! you're the guy I forget all the time! haha! Well scheme doesn't like you either so it evens out!
16:54:32 <schme> oh cool. GHC crash :)
16:54:41 <schme> or well the program I wrote crashed anyway.
16:54:54 <schme> correction: the program in the tutorial crashed. hah.
16:55:16 <schme> Stack space overflow: current size 8388608 bytes.
16:56:47 <dons> you compiled with ghc -O ?
16:56:59 <schme> No.
16:57:09 <dons> so just ran it in ghci or hugs?
16:57:22 <schme> ghc --make -package GLUT foo.hs -o foo
16:58:00 <newsham> ?keal
16:58:00 <dons> if you're going to compile it, you might as well turn on the strictness analyser. try again:  ghc --make -package GLUT foo.hs -o foo -no-recomp -O
16:58:01 <lambdabot> somone would expect that trees 500gb hdds of expressions as if they were floppy dicks
16:58:31 <schme> ok
16:59:12 <schme> Same deal.
17:00:48 <dons> time to think about why its using the stack then.
17:00:48 <saml> > let range n = if n < 0 then [] else n : range (n - 1) in range 10  -- can do this but prints 0, 1, 2, .. ?
17:00:55 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0]
17:01:11 <saml> that does not use other parameter. and can't use reverse at the top
17:01:12 <schme> That even made the program not pop up teh window.
17:01:13 <vixey> saml: o_o ..
17:01:26 <saml> and not using [1..10]
17:01:27 <dons> let range n = if n < 0 then [] else n : range (n - 1) in init . tail . concat . intercalate " " . map show $ range 10
17:01:28 <vixey> > let range n = if n < 0 then [] else range (n - 1) ++ [n]
17:01:29 <lambdabot>  Parse error at end of input
17:01:34 <schme> dons: How do I figure that out?
17:01:48 <dons> schme: what code is this?
17:02:00 <schme> dons: http://blog.mikael.johanssons.org/archive/2006/09/opengl-programming-in-haskell-a-tutorial-part-2/
17:02:02 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » OpenGL programming in Haskell, a tutorial (P ..., http://tinyurl.com/yl5ljl
17:02:30 <schme> dons: the first animation changes made. The instant I resize the window it goes bang.
17:04:21 <Cale> > let range n = take n (iterate (+1) 0) in range 10
17:04:22 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
17:04:27 <Cale> > let range n = take (n+1) (iterate (+1) 0) in range 10
17:04:29 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
17:05:29 <dons> schme: that's interesting. you can talk to Syzygy- about his code.
17:05:32 <dons> he's the author.
17:05:36 <Cale> > let range n = [0..n] in range 10
17:05:37 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
17:06:29 <schme> dons: Ah cools.   But anyway. if I have a piece of code then how do I go by "thinking about why its using the stack" ?
17:09:26 <dons> look at loops that recurse, building up data structures
17:11:20 <zloog_>  /join #debian
17:11:30 <zloog_> hrm
17:11:34 <zloog_> thats odd
17:11:43 <schme> hmmm
17:13:44 <schme> One thing is funny though.. I have not had software crash as much as the stuff I do in haskell (either my own or from tutorials) in yars and yars. I thought 'twas supposed to be a "safe" language :)
17:14:09 <QtPlatypus> schme: Crash in what way?
17:14:28 <schme> QtPlatypus: As in stack space overflow
17:14:42 <schme> and ze program just dies.
17:15:14 <wolgo> schme: do you have a lot of experience programming?
17:15:18 <dons> schme: you mean, random code you paste from the web ?
17:15:42 <schme> wolgo: that really depends on what "a lot" is.
17:15:53 <schme> dons: No. I mean random code from the web, and stuff I hack up meself.
17:16:14 <wolgo> Sorry, a lot means: Years of experience with different languages
17:16:21 * wolgo is a new programmer
17:16:24 <dons> i'd hope you don't actually see crashes, in the runtime error form. i can imagine you'll see stack overflows, if you're not careful with how you program.
17:16:27 <schme> wolgo: Yeah ok. Yes, yes I do.
17:16:35 <wolgo> Oh ok
17:16:56 <wolgo> I thought you might be new. My programs crash because I misunderstand types and recursion a lot.
17:17:00 <wolgo> But I am new
17:17:07 <dons> that's the basic newbie issue, not knowing when lazy evaluation is happening, since newbies tend to grow up in strict environment
17:17:10 <schme> wolgo: It is probably related to me misunderstanding haskell.
17:17:35 <wolgo> I want to make cool things like hpaste
17:17:39 <wolgo> and lambdabot
17:17:53 <lilac> dons: i see quite a lot of runtime errors
17:17:54 <schme> wolgo: I do consider myself as new. I've only been hacking code for 20 years or there abouts. So it's nothing really.
17:18:18 <dons> lilac: of what form?
17:18:19 <lilac> dons: but that's because i forget the "f [] = []" bits of my recursion :)
17:18:27 <dons> oh, turn on -Wall then
17:18:33 <dons> you'll get partiality warnings
17:18:37 <schme> But I can totally buy it being related to me being used to strict evaluation.
17:18:39 <lilac> have done now, still sifting through the rubble
17:18:42 <dons> -Wall -Werror will prevent you from compiling till you fix that.
17:18:56 <dons> its not theorem proving, so you can still write wrong programs :)
17:19:22 <dons> also, using higher order functions for loops helps avoid forgetting base cases.
17:19:36 <dons> still, nothing's better than knowing precisely what you're doing.
17:19:50 <thetallguy> amen to that
17:19:51 <wolgo> So I will crash these programs until I learn how not to crash them. Well crash them as much
17:19:55 <schme> I find it very hard to know precisely what I'm doing in haskell.
17:20:06 <schme> But I guess it's just a matter of hacking more code.
17:20:24 <schme> I just need a new project to hack on now. seeing how this opengl stuff is not working out ><
17:20:38 <dons> it is important to get a good mental model of what your code actually represents in the machine. until then, it'll be hard to reason concretely about space and time.
17:20:59 <schme> Mmm.
17:21:04 <lilac> dons: i'm finding there usually isn't a higher-order function for doing exactly what i want to do :(
17:21:07 <schme> That's so much easier to do with low level languages :)
17:21:33 <lilac> dons: and if i find some clever way of combining three HOFs to do it, then i find i need to rewrite the whole thing when i realize the requirements are slightly different
17:22:59 <wolgo> It took 20 seconds to find fib 30
17:23:02 <wolgo> :(
17:23:07 <dons> hah
17:23:17 <dons> algorithms, dude.
17:23:17 <gnuvince_> wolgo: do the iterative version then
17:23:20 * wolgo experiences his noobishness fully
17:23:21 <augur> lamewolgo
17:23:25 <gnuvince_> It'll find it in 20 microseconds
17:23:29 <vixey> > (!!29) . extendSequence $ [1,1]
17:23:31 <lambdabot>  832040
17:23:36 <dons> iterative, schmiterative.
17:23:54 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 30
17:23:55 <lambdabot>  832040
17:23:56 <lilac> it seems to me that unmaintainability is an inherent problem with using HOFs.
17:24:17 <vixey> lilac: no not at all
17:24:25 <dons> i'd be surprised at that, lilac. you've named your loops explicitly. surely there's more information there, and less chance for subtle mistakes, than in manual loops?
17:24:35 <wolgo> @type !!
17:24:37 <lambdabot> parse error on input `!!'
17:24:42 <wolgo> what is !!?
17:24:43 <lilac> suppose i want to map to uppercase. I can say "map toUpper". now suppose i have to map the german long-s to "SS". i must rewrite the whole thing.
17:24:50 <vixey> wolgo: it takes the nth element of a list
17:25:01 <lilac> i'm finding this on a larger scale as well
17:25:08 <dons> lilac: they're entirely different though. how would writing that recursively help?
17:25:09 <vixey> (x:_)!!0 = x ; (_:xs)!!(n+1) = xs!!n
17:25:26 <dons> one is a a -> a function, the other is a -> [a], so either way you're going to have to allocate new things.
17:25:27 <lilac> dons: they're almost exactly the same. a recursive solution is easy.
17:25:34 <lilac> they're both [a] -> [a]
17:25:36 <dons> its concatMap versus map.
17:26:01 <vixey> lilac: You don't rewrite the whole thing.. just change one stream transformer
17:26:14 <mar77a> > [1..] !! 65403
17:26:15 <lambdabot>  65404
17:26:41 <mar77a> > [] !! 0
17:26:43 <lambdabot>  Exception: Prelude.(!!): index too large
17:26:56 <kaol> > [] !! (-1)
17:26:58 <lilac> vixey: i change "map toUpper" to "concatMap (\a -> case a of '\x1E9E' -> "SS"; a -> [toUpper a])". the code is almost entirely different.
17:26:59 <lambdabot>  Exception: Prelude.(!!): negative index
17:27:17 <mar77a> (!!) [1,3..] !! 16
17:27:23 <mar77a> > (!!) [1,3..] !! 16
17:27:24 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int -> t'
17:27:37 <mar77a> > (!!) [1,3..] 16
17:27:39 <lambdabot>  33
17:27:40 <schme> So in there a way to inspect how things are actually represented in the machine?
17:27:44 <schme> is
17:27:57 <mar77a> at what level?
17:28:10 <Baughn> > (tail [0..]) (!!!) (-1)
17:28:10 <lambdabot>  Couldn't match expected type `t1 -> t2 -> t'
17:28:12 <lilac> vixey: or i change "up c:cs = toUpper c:up cs; up [] = []" by adding an extra case, "up '\x1E9E':cs = 'S':'S':up cs", which seems a simpler and more obvious change
17:28:19 <gnuvince_> How would you call a function that turns [1,2,3,4,5,8] into "1-3, 4-5 and 8"?
17:28:24 <Baughn> > (tail [0..]) !!! (-1)
17:28:25 <lambdabot>  -1
17:28:32 <schme> Well preferebly at an assembly codeish level.
17:28:41 <mar77a> dissasembler?
17:28:41 <schme> So one gets some basic grasp on what is going on.
17:28:42 <dons> schme: read the STG paper.
17:28:43 <vixey> gnuvince_: summarize
17:28:54 <Baughn> > (tail [0..]) !!! (-1)
17:28:56 <lambdabot>  0
17:29:14 <schme> dons: Where's that?
17:29:20 <vixey> @src (!!!)
17:29:20 <lambdabot> Source not found. Wrong!  You cheating scum!
17:29:30 <Baughn> > [1..] !!! (-1)
17:29:30 <wolgo> hey that is a good exercise for me
17:29:32 <lambdabot>  0
17:29:47 <Baughn> > [2..] !!! (-1)
17:29:48 <lambdabot>  1
17:30:07 <dons> we talked about it last week, schme :)
17:30:10 <vixey> > [5,7,11,13,17] !!! (-1)
17:30:11 <lambdabot>  42
17:30:14 <vixey> ...
17:30:15 <dons> ?go spineless tagless g machine stock hardware
17:30:17 <vixey> lol
17:30:21 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
17:30:21 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
17:31:03 <schme> dons: That's great. Where is it?
17:31:09 <dons> see above.
17:31:13 <Baughn> > (tail [16,11,12,3]) !!! (-1)
17:31:14 <lambdabot>  16
17:31:31 <Baughn> vixey: See, no fair passing an invalid list to the poor thing
17:31:34 <lilac> how on earth does !!! work?
17:31:41 <dons> ?src (!!)
17:31:41 <lambdabot> xs     !! n | n < 0 = undefined
17:31:41 <lambdabot> []     !! _         = undefined
17:31:41 <lambdabot> (x:_)  !! 0         = x
17:31:41 <lambdabot> (_:xs) !! n         = xs !! (n-1)
17:31:55 <lilac> dons: !!! not !!
17:31:56 <dons> not sure what this !!! is. something sneaky defined locally?
17:32:01 <mauke> :t (===)
17:32:03 <lambdabot> Not in scope: `==='
17:32:21 <monochrom> !!!1111 :)
17:32:25 <lilac> > (drop 5 [a,b,c,d,e,f,g,h]) !!! (-2)
17:32:26 <lambdabot>   Not in scope: `!!!'
17:32:27 <schme> all I find is some acm portal bullcrap that I can't access.
17:32:39 <newsham> [14:24] < schme> So in there a way to inspect how things are actually represented in the machine?
17:32:43 <newsham> ghc -S foo.hs
17:32:49 <dons> http://citeseer.ist.psu.edu/peytonjones92implementing.html was linked above.
17:32:50 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
17:32:52 <dons> which has a cahce of it.
17:33:12 <schme> newsham: 'scool.
17:33:34 <pastorn> @hoogle zipWith
17:33:38 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
17:33:38 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
17:33:38 <lambdabot> Data.ByteString.zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
17:33:42 <pastorn> wtf{?
17:33:52 * pastorn needs wipWithM
17:34:05 <idnar> :t zipM
17:34:07 <lambdabot> Not in scope: `zipM'
17:34:10 <vixey> :t sequence . zipWith
17:34:11 <mauke> whipWith
17:34:12 <lambdabot>     Couldn't match expected type `[m a]'
17:34:12 <lambdabot>            against inferred type `[a1] -> [b] -> [c]'
17:34:12 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
17:34:26 <monochrom> whipWithwhip
17:34:31 <vixey> :t sequence (zipWith ?f ?x ?y)
17:34:33 <lambdabot> forall a b (m :: * -> *) a1. (Monad m, ?y::[b], ?x::[a], ?f::a -> b -> m a1) => m [a1]
17:34:44 <monochrom> (try to pronounce whipWithwhip quickly! :) )
17:35:01 <pastorn> vixey: wtf?
17:35:02 <schme> great. a light read for work.
17:35:14 <vixey> pastorn: try to ask a sensible question
17:35:27 <pastorn> @type sequence_ $ zipWith_ renameFile
17:35:29 <lambdabot> Not in scope: `zipWith_'
17:35:29 <lambdabot> Not in scope: `renameFile'
17:35:35 <pastorn> @type sequence_ $ zipWith_ System.Directory.renameFile
17:35:37 <lambdabot> Not in scope: `zipWith_'
17:35:41 <pastorn> @type sequence_ $ zipWith System.Directory.renameFile
17:35:43 <lambdabot>     Couldn't match expected type `[m a]'
17:35:43 <lambdabot>            against inferred type `[FilePath] -> [FilePath] -> [IO ()]'
17:35:43 <lambdabot>     In the second argument of `($)', namely
17:35:45 <schme> This looks like the exact stuff that should go into tutorials really.
17:35:50 <pastorn> kill me plz
17:36:14 <newsham> i wonder if keal and schme went to the same school
17:36:25 <dons> schme: you could take notes, and place them on the wiki?
17:36:26 <zloog_> school of expression?
17:36:38 <schme> newsham: Maybe. Who is keal?
17:36:42 <mauke> @keal
17:36:43 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
17:36:44 <pastorn> schme: du Ã¤r svenne vÃ¤l?
17:36:51 <monochrom> everything should go into tutorials.
17:36:53 <schme> pastorn: lÃ¤tt att jag Ã¤r, baby.
17:37:04 <pastorn> schme: /join #haskell.se
17:37:10 <vixey> @protontorpedo
17:37:10 <lambdabot> can haskell do same stuff as J2EE but nicer?
17:37:13 <vixey> @protontorpedo
17:37:13 <lambdabot> why haskell over say clsip or smalltalk?
17:37:31 <monochrom> @keal
17:37:32 <lambdabot> evaluating expressions is ALL haskell does?????
17:38:20 <vixey> @protontorpedo
17:38:21 <lambdabot> or does it become a mishmash of code?
17:39:21 <augur> lolwut
17:40:20 <chessguy> @quote
17:40:21 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
17:40:38 <vixey> @protontorpedo
17:40:38 <lambdabot> is it hard to set up n ready my pc for programming?
17:41:38 <newsham> ?fact: ?fact
17:41:38 <lambdabot> ?fact: ?fact
17:42:00 <vixey> ?fact: orial
17:42:00 <lambdabot> I know nothing about orial
17:42:50 <newsham> ?fact diagonalization
17:42:50 <lambdabot> diagonalization: This sentence is false.
17:43:11 <Baughn> ..well, it sure ain't true
17:43:12 <vixey> ?facts
17:43:13 <lambdabot> I can not handle empty facts.
17:43:22 <vixey> lol
17:43:48 <Baughn> data Bool = True | False | Nonsense
17:44:02 <mauke> data Bool = True | False | FileNotFound
17:44:05 <wolgo> I see why it takes 20 seconds. It has to run through every recursion for every number
17:44:08 <wolgo> ...
17:44:11 <wolgo> that sucks
17:44:26 <Cale> wolgo: Which program?
17:44:31 <wagle> data bool = True | False | Both | Neither
17:44:34 * wolgo has to trace everything on paper to understand recursion :(
17:44:38 <wolgo> fib n
17:44:42 <vixey> wolgo: did you use let ever?
17:44:55 <Cale> wolgo: ah, the doubly recursive version?
17:45:02 <wolgo> yes
17:45:06 <roconnor> data bool = True | False | FixNot
17:45:09 <wolgo> vixey: what do you mean?
17:45:11 <newsham> the simple impl of fib is prone to that problem
17:45:15 <vixey> roconnor: I was thinking that
17:45:16 <ddarius> wolgo: Tracing everything on paper is probably a good thing to do.
17:45:17 <newsham> you can use memoization to speed it up
17:45:19 <dons> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 1000
17:45:20 <lambdabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
17:45:32 <dons> wolgo: the above cleverly reuses previous results
17:45:44 <ddarius> > fix((0:).(1:).ap(zipWith(+))tail)
17:45:45 <wolgo> Have I used it or did I use let in my version of fib?
17:45:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:45:52 <vixey> wolgo: let foo = bar in ..., think about the lazy evalution
17:45:55 <newsham> the wikipedia article on haskell explains that fib definition
17:46:07 <ddarius> > fix((0:).(1:).ap(zipWith(+))tail)!!1000
17:46:08 <lambdabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
17:46:13 <wolgo> newsham: :)
17:46:26 <Elly> what does '$' mean in haskell?
17:46:35 <newsham> $ is kind of like parenthesis
17:46:35 <ddarius> Elly: It's the identity function.
17:47:04 <vixey> wolgo: say let x = (compute something tricky) in x + x, something tricky is only computed once
17:47:05 <roconnor> ddarius!
17:47:12 <ddarius> roconnor!
17:47:22 <dons> ?src ($)
17:47:22 <lambdabot> f $ x = f x
17:47:29 <thetallguy> Elly: put those two answers together and you've got an answer
17:47:34 <ddarius> @pl ($)
17:47:34 <lambdabot> id
17:47:42 <roconnor> ddarius: you know better that to give useless help like that.
17:47:48 <Elly> hm...so why does it exist?
17:47:55 <newsham> elly: its often more convenient than parenthesis
17:47:57 <wolgo> vixey: oh a let - in
17:48:02 <wolgo> I have not used that
17:48:08 <jberg> how can i get a string from an integer?
17:48:10 <thetallguy> Elly: when you use it, it changes precedence
17:48:11 <newsham> ie:   f a (b c d e f)    can be written  f a $ b c d e f
17:48:13 <roconnor> Elly: ($) has a difference precidence level than normal application
17:48:15 <ddarius> It's also more descriptive than id in higher order contexts.
17:48:18 <vixey> wolgo: well does it make sense that the computation is only done once in my example?
17:48:26 <wolgo> yes
17:48:34 <newsham> > show 52345
17:48:36 <lambdabot>  "52345"
17:48:40 <vixey> wolgo: so.. you can think of toplevel definitions like they're all in a let
17:48:40 <Dzlk> jberg: show n
17:48:47 <jberg> thanks
17:48:47 <wolgo> because in says: do this in this one case : in x + x
17:48:53 <Elly> oh, I see what you meant about parentheses now :)
17:49:09 <wolgo> vixey: oh ok
17:49:45 <ddarius> roconnor: I actually dislike the "its like parentheses" answer as it makes ($) seem magical.  It's also quite easy to miss the fact that ($) is just id.
17:49:53 <wolgo> vixey: you should rewrite crontab in haskell :P
17:49:58 <vixey> wolgo: and a trick to getting fibs to reuse its computation is say that we defined an infinite list of the fibs (Ill just use magic at the moment but it's possible without) so fibsList = <magic>
17:50:03 <ddarius> wolgo: I think someone already did.
17:50:09 <vixey> wolgo: then you can write fib n = fibsList !! n
17:50:27 <newsham> how about "its the identity function defined infix with low precedence so that it can be used in a similar manner as parentheses" ?
17:50:37 <schme> Is there some debugger or somesuch for haskelling?
17:50:42 <roconnor> ddarius: I might agree with you, but better to call it function application at a different level of precidence level.
17:50:52 <dons> schme: yeah, ghci has a built in debugger
17:51:08 <newsham> didnt you ask and get an answer about haskell debuggers about 3hrs ago?
17:51:12 <schme> dons: Cools.
17:51:19 <newsham> its described in The Monad Reader
17:51:21 <wolgo> vixey: Based on what you are telling me I can use that technique in other areas too.
17:51:22 <schme> newsham: No. I have newer asked anything related to it.
17:51:23 <dons> yeah, i thought we had this conversation last week
17:51:33 <vixey> wolgo: yes it's a very general thing, it'll work everywhere
17:51:39 <schme> newsham: newer = never
17:51:54 <newsham> ahh, it was earlier today, but mix25 asked.
17:52:04 <Elly> so if I write: yes = forever $ do putStrLn "y" where forever a = do a; forever a
17:52:11 <Elly> (in the spirit of the IRC bot tutorial)
17:52:22 <wolgo> @hoogle haskell debugging
17:52:23 <lambdabot> Did you mean: Haskell Debugging
17:52:23 <lambdabot> Prelude.undefined :: a
17:52:23 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
17:52:30 <schme> Yes.. If I was prone ta asking the same question over and over I think I'd keep logs.
17:52:33 <schme> hahahaha
17:52:34 <Elly> it turns into... yes = forever (do putStrLn "y") where forever a = do a; forever a
17:52:41 <schme> answered questions that is.
17:52:49 <mauke> Elly: yes
17:52:52 <dons> ah, 08.05.21:15:22:17 <Peaker> ddarius, what Haskell debuggers are there?
17:52:54 <wolgo> @go haskell debugger
17:52:54 <vixey> wolgo: which means we can write fibsList = map fibr [0..] where fibr 0 = 1 ; fibr 1 = 1 ; fibr n = fibsList !! (n-2) + fibsList !! (n-1) in fibsList
17:52:57 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
17:52:57 <lambdabot> Title: A declarative debugger for Haskell 98
17:53:02 <vixey> errr
17:53:11 <vixey> s/ in fibsList//
17:53:11 <ddarius> dons: It has come up several times in the past 24 hours or so.
17:53:28 <dons> interesting.
17:53:37 <schme> Seems a natural question :)
17:53:48 <wolgo> I SEE
17:53:49 <mauke> putStr . cycle $ "y\n"
17:53:55 <monochrom> Desperate for debugging?
17:54:02 <vixey> > let fibsList = map fibr [0..] where fibr 0 = 1 ; fibr 1 = 1 ; fibr n = fib (n-2) + fib (n-1) ; fib n = fibsList !! n in fib 1000
17:54:02 <lambdabot>   Not in scope: `fib'
17:54:07 <vixey> :[
17:54:12 <vixey> > let fibsList = map fibr [0..] ; fibr 0 = 1 ; fibr 1 = 1 ; fibr n = fib (n-2) + fib (n-1) ; fib n = fibsList !! n in fib 1000
17:54:14 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
17:54:29 <Elly> mauke: why isn't that: cycle . putStr $ "y\n"?
17:54:30 <wolgo> whoa
17:54:30 <ddarius> monochrom: The new'uns like writing buggy code.
17:54:33 <vixey> wolgo: it's called memoization by the way
17:54:36 <mauke> :t cycle
17:54:38 <lambdabot> forall a. [a] -> [a]
17:54:45 <Elly> oh!
17:54:45 <mauke> Elly: because putStr doesn't return a list
17:54:47 <newsham> > take 8 $ let d `idivs` n = n `mod` d == 0; (a,b) `cdivs` (a',b') = (let d = a*a+b*b in (d `idivs` (a*a' - b*b')) && (d `idivs` (a'*b + a*b')) ); real (a,b) = b == 0 in map fst $ filter real $ nubBy cdivs $ tail [(a, b) | a <- [1..], b <- [0 .. a]]
17:54:47 <jberg> hmm, i think my haskell mode is fucked. i dont think its indenting the way it should be.. can i set it to indent "smart" somehow?
17:54:48 <lambdabot>  [3,7,11,19,23,31,43,47]
17:54:53 <Elly> ah, I see what you mean there
17:54:59 <mauke> > cycle "y\n"
17:55:01 <lambdabot>  "y\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\ny\n...
17:55:07 <monochrom> The zeroth law of debugging: structure and comment your program well, and it's easy to debug.
17:55:14 <Elly> ah
17:55:24 <Baughn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !!! 13
17:55:25 <Elly> and that gets lazily evaluated as putStrLn goes?
17:55:25 <wolgo> lists...
17:55:25 <lambdabot>  "Help, I'm trapped in the machine!"
17:55:30 <mauke> Elly: right
17:55:33 <Elly> cool :)
17:55:36 <ddarius> The negative first law of debugging: don't write bugs, and it's easy to debug
17:55:45 <mauke> @go antibuddha
17:55:46 <lambdabot> No Result Found.
17:55:57 <vixey> wolgo: oh of course this applies to everything in haskell, not just lists.. you could use an infinite tree of computations .. or a finite thing .. whatever
17:56:01 <monochrom> If I kill the machine, will that liberate her?
17:56:18 <ddarius> monochrom: If you kill a prison, does that liberate the prisoners?
17:56:24 <wolgo> because we can use memoization everywhere?
17:56:25 <newsham> ?go memoization
17:56:26 <lambdabot> http://en.wikipedia.org/wiki/Memoization
17:56:34 <monochrom> Exactly what I worry about.
17:56:55 <monochrom> w00t, there is also memoization page on haskell wiki. let me find it.
17:57:07 <mauke> @wiki Memoization
17:57:07 <lambdabot> http://www.haskell.org/haskellwiki/Memoization
17:57:32 <monochrom> beaten :)
17:57:45 <ddarius> @let wiki = ("http://en.wikipedia.org/wiki/"++)
17:57:46 <lambdabot> Defined.
17:57:55 <ddarius> > wiki "Memoization"
17:57:56 <lambdabot>  "http://en.wikipedia.org/wiki/Memoization"
17:58:10 <monochrom> @hackage Memoization
17:58:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Memoization
17:58:18 <mauke> @define
17:58:18 <lambdabot> Undefined.
17:58:24 <wolgo> I understand that example I think :)
17:58:28 <mauke> @let wiki = var .  ("http://en.wikipedia.org/wiki/"++)
17:58:28 <lambdabot> Defined.
17:58:33 <ddarius> mauke: I was about to do that.
17:58:44 <mauke> > wiki "Memoization"
17:58:45 <lambdabot>  http://en.wikipedia.org/wiki/Memoization
17:58:55 <monochrom> What does var do?
17:59:02 <ddarius> :t var
17:59:04 <lambdabot> forall a. String -> Sym a
17:59:05 <wolgo> zipWith is using (+) to perform addition on the (x:xs) xs portion of the list.
17:59:14 <monochrom> Oh noes... :)
17:59:31 <newsham> > var "> var"
17:59:32 <lambdabot>  > var
18:00:12 <ddarius> wolgo: Take the typical: fibs = 0:1:zipWith (+) fibs (tail fibs) and evaluate it out with pencil and paper.
18:00:16 <wolgo> > let test = 0 : 1 zipWith (*) (head test)
18:00:17 <lambdabot>  Parse error at end of input
18:00:33 <wolgo> ddarius: good idea
18:00:41 <monochrom> let x=y in x
18:00:58 <ddarius> @src zipWith
18:00:58 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
18:00:58 <lambdabot> zipWith _ _      _      = []
18:01:04 <monochrom> also  zipWith (*) (head test)  is going to be type error
18:01:13 <wolgo> :t head
18:01:15 <lambdabot> forall a. [a] -> a
18:01:19 <vixey> > let fibss fibs = "0 : 1 : zipWith (+) "++fibs++" (tail "++fibs++")" in iterate fibs "fibs"
18:01:20 <lambdabot>   Not in scope: `fibs'
18:01:20 <wolgo> ahh
18:01:22 <ddarius> monochrom: As well as 1 zipWith
18:01:27 <vixey> > let fibss fibs = "0 : 1 : zipWith (+) "++fibs++" (tail "++fibs++")" in iterate fibss "fibs"
18:01:28 <lambdabot>  ["fibs","0 : 1 : zipWith (+) fibs (tail fibs)","0 : 1 : zipWith (+) 0 : 1 : ...
18:01:32 <jberg> gaaah, my haskell mode is not indenting correctly :(
18:01:35 <vixey> > let fibss fibs = "0 : 1 : zipWith (+) "++fibs++" (tail "++fibs++")" in tail (iterate fibss "fibs")
18:01:36 <lambdabot>  ["0 : 1 : zipWith (+) fibs (tail fibs)","0 : 1 : zipWith (+) 0 : 1 : zipWith...
18:01:54 <vixey> hmm ..
18:02:38 <vixey> > let fibss fibs = "0 : 1 : zipWith (+) ("++fibs++") (tail ("++fibs++"))" in iterate fibss "fibs"!!3
18:02:40 <lambdabot>  "0 : 1 : zipWith (+) (0 : 1 : zipWith (+) (0 : 1 : zipWith (+) (fibs) (tail ...
18:03:06 <vixey> @@ @run @run var (let fibss fibs = "0 : 1 : zipWith (+) ("++fibs++") (tail ("++fibs++"))" in iterate fibss "fibs"!!3)
18:03:07 <lambdabot>  Unbalanced parentheses
18:03:53 <wolgo> I feel like I am in a computer science class
18:04:06 * wolgo considers going back to college now
18:04:09 <mauke> made of cheese
18:04:10 <vixey> wolgo: sorry
18:04:52 <wolgo> vixey: nothing to be sorry about. I have not been this intrigued by anything in a while. I really appreciate your time in explaining these things to me
18:05:13 <vixey> oh :)
18:05:17 <wolgo> @src zipWith
18:05:17 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
18:05:17 <lambdabot> zipWith _ _      _      = []
18:05:41 <vixey> > zipWith (*) [x,y,z] [u,v,w]
18:05:42 <lambdabot>  [x * u,y * v,z * w]
18:06:55 <wolgo> haha zipWith _ _ _
18:07:08 <wolgo> I don't know why I think that is funny
18:07:27 <wolgo> brb going to get some coffee
18:09:24 <neurogeek> Hello.. how can I sort this? [ [1.23, 0.0], [2.30, 1.0], [0.2, 2.0] ] -> by the head of each element and obtain this -> [ [0.2, 2.0], [1.23, 0.0], [2.30.1.0] ] ??
18:09:57 <vixey> > sortBy (comparing`on`head) [ [1.23, 0.0], [2.30, 1.0], [0.2, 2.0] ]
18:09:58 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> a
18:09:58 <lambdabot>     Probabl...
18:10:24 <jberg> in emacs i have a module loaded so it says Main*> but now i cant use prelude functions like quoteRem..
18:10:30 <jberg> how can i fix that?
18:10:43 <vixey> > sortBy (comparing head) [ [1.23, 0.0], [2.30, 1.0], [0.2, 2.0] ]
18:10:44 <lambdabot>  [[0.2,2.0],[1.23,0.0],[2.3,1.0]]
18:10:47 <neurogeek> vixey, thanks!
18:11:00 <vixey> neurogeek: [un]lucky guess :p
18:11:55 <mauke> jberg: it's quotRem
18:12:02 <jberg> oh.. :)
18:13:27 <newsham> > let s = "let s = %c%s%c in var $ %c> %c ++ printf s 34 s 34 34 34" in var $ "> " ++ printf s 34 s 34 34 34
18:13:29 <lambdabot>  > let s = "let s = %c%s%c in var $ %c> %c ++ printf s 34 s 34 34 34" in var ...
18:14:09 <vixey> > var " \n >"
18:14:11 <lambdabot>  >
18:14:14 <vixey> > var "< \n >"
18:14:15 <lambdabot>  <
18:14:15 <lambdabot>  >
18:14:34 <newsham> > var "\n> 1 + 1"
18:14:36 <lambdabot>  > 1 + 1
18:15:55 <newsham> > var "http://www.thenewsh.com/title"
18:15:56 <lambdabot>  http://www.thenewsh.com/title
18:15:57 <lambdabot> Title: 404 - Page Not Found
18:15:58 <chessguy> @type comparing
18:15:59 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
18:16:02 <mar77a> :t var
18:16:04 <lambdabot> forall a. String -> Sym a
18:16:10 <mar77a> :T Sym
18:16:13 <mar77a> :t Sym
18:16:14 <lambdabot> Not in scope: data constructor `Sym'
18:16:17 <vixey> :k Sym
18:16:19 <lambdabot> * -> *
18:16:25 <mar77a> ._.
18:16:27 <chessguy> @hoogle Sym
18:16:27 <lambdabot> Text.Read.Symbol :: String -> Lexeme
18:16:28 <lambdabot> Text.Read.Lex.Symbol :: String -> Lexeme
18:16:28 <lambdabot> Text.ParserCombinators.Parsec.Token.symbol :: TokenParser st -> String -> CharParser st String
18:16:33 <chessguy> @hoogle+
18:16:33 <lambdabot> Data.Char.isSymbol :: Char -> Bool
18:16:33 <lambdabot> Data.Char.MathSymbol :: GeneralCategory
18:16:33 <lambdabot> Data.Char.CurrencySymbol :: GeneralCategory
18:26:23 <wolgo> I am BACK!
18:27:00 <pastorn> I am DRUNK!
18:39:39 <wolgo> @src (!!)
18:39:39 <lambdabot> xs     !! n | n < 0 = undefined
18:39:39 <lambdabot> []     !! _         = undefined
18:39:39 <lambdabot> (x:_)  !! 0         = x
18:39:39 <lambdabot> (_:xs) !! n         = xs !! (n-1)
18:40:33 <vixey> I like my version better
18:44:09 <wolgo> I see that this does not support negative indices
18:44:59 <vixey> (The panda doesn't feel well, because of programming too much OCaml. But trust me on this, you do not want to see a panda that had to code C++)
18:45:10 <vixey> http://photos1.blogger.com/blogger/1785/2897/400/120905.7.jpg
18:45:36 <wolgo> haaahahhaha
18:45:39 <wolgo> That is hilarious
18:45:45 <wolgo> sad panda is sad
18:48:17 <wolgo> I swear I have rewritten half of the standard library figuring out recursion
18:48:25 <wolgo> since EVERYTHING uses recursion
18:48:35 <wolgo> !! is now getidx
18:48:44 <wolgo> now I need to do map
18:48:55 <vixey> Don't use recursion to write map
18:49:01 <vixey> @src fold
18:49:01 <lambdabot> Source not found.
18:49:07 <vixey> um. :(
18:49:09 <vixey> @src foldr
18:49:09 <lambdabot> foldr f z []     = z
18:49:09 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:49:10 <wolgo> @src foldl
18:49:10 <lambdabot> foldl f z []     = z
18:49:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:49:13 <vixey> try to define map using foldr instead
18:49:16 <wolgo> YOU ARE A REPUBLICAN
18:49:25 <vixey> I am? what's that
18:49:31 <dolio> Don't use foldl, either.
18:49:34 <vixey> OH
18:49:38 <wolgo> hahah
18:50:06 <wolgo> I will find the site
18:50:12 <wolgo> evolution of a haskell programmer
18:50:26 <wolgo> makes a joke about people that use foldr and foldl
18:50:28 <mauke> @where evolution
18:50:28 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
18:50:36 <wolgo> Well lookie here
18:50:57 <dolio> That site is much more interesting than the "Evolution of a Python Programmer" that was on reddit recently.
18:53:00 <wolgo> I like reddit
18:53:12 <wolgo> :)
18:53:12 <monochrom> @src enumFromTo
18:53:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:53:18 <monochrom> oops :)
18:53:32 <wolgo> I feel pretty good about the stuff I have learned this is pretty fun
18:57:20 <vixey> 02:56
19:01:08 <schme> aha
19:01:20 <schme> lazy eval makes a lot more sense after reading that there paper
19:01:35 <schme> still not too sure about how stuff is actually represented at a machine level :S
19:10:26 <dolio> A value is a pointer to code that computes the value at first.
19:11:03 <SamB> what were some good documents about how GHC does it?
19:11:20 <dolio> Then, when you evaluate it the first time, you replace the code with code that just returns the already-computed value.
19:11:27 <dolio> Or something like that.
19:12:56 <dolio> I don't know. SPJ's book probably talks about it, but GHC's almost certainly evolved since then.
19:13:00 <SamB> and pointer tagging changes things a bit so that it isn't necessary to enter the code or even follow the pointer to know that the value is already computed...
19:13:18 <SamB> I was thinking more like papers rather than the book
19:13:56 <dolio> Well, there's the STG-machine paper.
19:14:12 <schme> That STG paper is great me thinks.
19:14:20 <schme> Though some things in it struck me as very odd.
19:15:13 <mmorrow> i found this extremely enlightening: http://citeseer.ist.psu.edu/682782.html
19:15:14 <lambdabot> Title: Making a Fast Curry (ResearchIndex)
19:15:53 <mmorrow> push/enter vs. eval/apply
19:16:28 <mmorrow> at one point ghc used the former and now uses the later
19:17:14 <mmorrow> describes in exact detail info tables and other inner working of the rts
19:18:01 <mmorrow> was initially linked to it from the ghc commentary
19:19:57 * SamB tries to remember if tagging does anything for this...
19:20:20 * SamB thinks it might encode the number of arguments remaining?
19:20:37 <wolgo> I am almost on the intermediate haskell tutorial but I feel like I have a lot more work on the basics to do...
19:20:53 <SamB> wolgo: which basics?
19:21:11 <SamB> the basics may be considered an advanced topic, dependon on what you mean by the basics ;-)
19:21:34 <wolgo> recursion, currying, point free, list comprehension all kinds of stuff
19:21:37 <schme> wolgo: good work there!
19:21:40 <wolgo> I guess it will come with time
19:21:44 <wolgo> and practice :)
19:21:48 <SamB> wolgo: there is NOTHING to currying
19:22:04 <SamB> currying is just partial application
19:22:05 <wolgo> @src uncurry
19:22:05 <lambdabot> uncurry f p = f (fst p) (snd p)
19:22:16 <vixey> don't look at the source code
19:22:18 <vixey> :t curry
19:22:20 <vixey> :t uncurry
19:22:23 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:22:23 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:22:24 <vixey> look at the types
19:22:30 <Baughn> Currying is.. storing parameters for later use when you've got all of them. Best get it right.
19:22:44 <SamB> Baughn: that's what I said!
19:22:49 <SamB> partial application
19:22:56 <Baughn> Sounds too much like partial evaluation. ;)
19:23:13 <SamB> you apply a function to some parameters here, the rest there...
19:23:32 <SamB> currying is why we write the arrows like that
19:23:46 <SamB> if we didn't have it, we'd write types like this:
19:23:47 <wolgo> right associative
19:23:56 <SamB> f : (a, b, c) -> d
19:24:50 <vixey> or maybe like d f(a a, b b, c c) { ... }
19:26:51 <vixey> can't think what to code :[
19:28:06 <wolgo> > let add x = \y -> x + y
19:28:06 <lambdabot>  Parse error at end of input
19:28:13 <wolgo> > add x = \y -> x + y
19:28:14 <lambdabot>  Parse error at "=" (column 7)
19:28:32 <wolgo> how...
19:28:40 <wolgo> how does it get y?
19:28:52 <wolgo> time for some experiments!
19:29:38 <Cale> > let add x = \y -> x + y in map (add 3) [1..10]
19:29:41 <lambdabot>  [4,5,6,7,8,9,10,11,12,13]
19:32:51 <wolgo> BRB! food!
19:33:05 * wolgo feels his mind melting
19:33:25 * vixey 's mind is not melting :(
19:34:12 * SamB wonders if there is such a thing as a transreal number
19:34:47 <dolio> Sounds like a word someone might have used before.
19:35:08 <Cale> SamB: That's what that Anderson guy called his numbers.
19:35:10 <vixey> haha
19:35:11 <vixey> Anderson quickly gained publicity in December 2006 in the United Kingdom when the regional BBC South Today reported his claim of "having solved a 1200 year old problem", namely that of division by zero. However, commentators quickly pointed out that his ideas are just a variation of the standard IEEE 754 concept of NaN (Not a Number), a datum that has been commonly employed on computers in floating point arithmetic for many years
19:35:31 <dolio> Oh, great.
19:35:32 <edwardk> heh
19:35:33 <SamB> rats
19:35:44 <SamB> waste of a perfectly good name!
19:35:45 <Cale> He is a bit of a quack, but the media also twisted things a bit on him.
19:35:46 <dolio> Nullity!
19:36:26 <vixey> I hate the way they say "a 1200 year old problem" .. as if it's actually a problem
19:36:28 <edwardk> yeah, i don't mind the guy trying things out i just wish he hadn't tainted the thought processes of classes full of highschool students on the way.
19:36:29 <SamB> he seems not to understand the problem in the least
19:36:50 <Cale> SamB: It's the media which don't understand the problem.
19:37:00 <edwardk> "having solved a non-problem 1200 years in the making" doesn't have the same ring to it
19:37:01 <SamB> the "problem" isn't that you "can't divide by zero"...
19:37:05 <Cale> SamB: He actually does have some idea what he's doing.
19:37:07 <vixey> lol
19:37:16 <Cale> (I've talked to him via email)
19:37:30 <gwern> 'Mr. Anderson. You can take either the blue pill. In which case, this will all be nothing but a dream; nothing will change. Or you can take the nullity pill - and see how far down the rabbit hole goes!'
19:37:36 <SamB> ... the problem is that if you decide that you "can", it complicates things very badly
19:37:54 <hpaste>  ripplepay pasted "sort/uniqify a stream?" at http://hpaste.org/7866
19:37:55 * vixey just finds the transreal/IEEE comparison hilarious
19:38:22 <Cale> Well, it is quite a lot like the ultimate IEEE floating point extension.
19:38:22 <vixey> ripplepay: You can use nub on an infinite list
19:38:33 <vixey> > nub [1..]
19:38:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:38:39 <ripplepay> danke, trying that
19:39:01 <vixey> > nub (map (`div`7) [1..])
19:39:02 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
19:39:08 <SamB> Cale: where by "ultimate", you mean covering all of the reals in addition to the usual NaN/Inf suspects?
19:39:13 <Cale> SamB: right
19:39:30 <arw__> hi. perhaps a stupid question: what would be a no-op with regard to IO?
19:39:35 <SamB> ... by using an infinite number of bits to store each value?
19:39:39 <Cale> and so his paper talks about what you actually can expect from such a system, even though it's not a field.
19:39:40 <vixey> arw__: return ()
19:40:01 <arw__> ah, the parentheses were missing :) thanks.
19:40:02 <SamB> I'm sure such a system has a heckofa lot more laws than IEEE has
19:40:07 <ripplepay> thanks, that's great.
19:40:10 <Cale> that's true :)
19:40:55 <Cale> ripplepay: You will pay a cost which is roughly quadratic in the number of elements you use though.
19:41:01 <SamB> hmm, I guess the reals are codata?
19:41:14 <Cale> ripplepay: That can be improved by carrying the already-seen elements around in a Data.Set
19:41:16 <vixey> SamB: I don't think so
19:41:28 <Cale> SamB: The real reals aren't even all computable.
19:41:42 <mmorrow> > nub . map (`mod`13) $ [1..]
19:41:45 <SamB> Cale: there is little evidence that the uncomputable reals actually exist
19:41:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,0
19:41:47 <Cale> But yeah, the computable reals are codata.
19:42:02 <Cale> SamB: They exist as much as 'exist' actually means anything at all.
19:42:20 <SamB> I think that might very between foundational theories
19:42:29 <Cale> It does, of course, like everything.
19:43:25 <SamB> I have decided that I don't like set theory as a foundational theory...
19:44:41 <SamB> did I mention that I've decided that I'm a constructivist?
19:44:50 * vixey . o O ( Have you been using those intusitionistic theorem proving tools? )
19:44:51 <Cale> Are you a platonist? Do you think that there actually is an objective truth about the existence of mathematical objects?
19:44:56 <Cale> (I certainly don't.)
19:45:32 <SamB> well, there seems to be evidence that our laws of physics use only computable reals
19:45:49 <SamB> and I haven't heard of any way to actually obtain an uncomputable real...
19:45:56 <vixey> it seems utterly ridiculous to mix physics and maths to me
19:46:01 <SamB> so I can't really bring myself to believe that they exist...
19:46:16 <Cale> Yeah, mathematics isn't subject to what's useful for physical models.
19:46:21 <vixey> SamB: does the number 73 exist?
19:46:30 <SamB> vixey: yes!
19:46:35 <SamB> I see it there on my screen
19:46:45 <Cale> How about the number 10^(10^(10^10)) ?
19:46:46 <vixey> is that because I can go Succ (Succ (Succ (Succ (Succ (..... Zero)))))))))))
19:46:47 <vixey> ?
19:46:57 <Cale> Does it exist?
19:47:04 <SamB> Cale: of course it does
19:47:07 <mmorrow> i can go pi!
19:47:08 <vixey> (or if not, why does 73 exist?)
19:47:14 <Cale> It's not a physically useful number though.
19:47:19 <MyCatVerbs> :t fix \rec l -> case l of { [] -> return []; (a:as) -> liftM2 (:) a (rec as); }
19:47:21 <SamB> just because my equipment is incapable of storing it in a naive fashion does not mean it does not exist
19:47:23 <lambdabot> parse error on input `\'
19:47:33 <MyCatVerbs> :t fix (\rec l -> case l of { [] -> return []; (a:as) -> liftM2 (:) a (rec as); })
19:47:35 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
19:47:43 <SamB> how do the uncomputable reals exist if you can't ever find one?
19:47:45 <Cale> It's already much larger than the number of particles in the visible universe (and that's a tremendous understatement)
19:47:53 <vixey> MyCatVerbs: sequence!
19:47:57 <vixey> (I think?)
19:48:09 <vixey> SamB: why does 73 exist .. ?
19:48:16 * glguy has 73 pennies
19:48:31 <MyCatVerbs> vixey: yes. Just playing with the combinators in C.Monad while reading SPJ's "Tackling the Awkward Squad."
19:48:39 <SamB> vixey: you've constructed an expression that computes it
19:48:50 <newsham> see you later combinator
19:48:55 <vixey> newsham :D
19:49:08 <vixey> @remember <newsham> see you later combinator
19:49:08 <lambdabot> Nice!
19:49:17 <Cale> @remember newsham see you later combinator
19:49:17 <lambdabot> Done.
19:49:46 <dolio> How about that number sum(a_i * 2^(-i)), where a_i = 1 if the turing machine encoded by i halts, and 0 otherwise?
19:49:49 <SamB> Cale: I suppose the uncomputable reals could be in that grey area between top and bottom, where the proofless things lie
19:49:56 * dolio forgets what it's referred to as. Omega?
19:50:06 <SamB> dolio: you can't compute that
19:50:13 <vixey> SamB: but there's a number expressible as Succ (Succ (Succ (... Zero)))))))))))))...)))) which nobody in the entire universe will ever ever compute or even think about
19:50:20 <dolio> I know you can't compute it.
19:50:21 <vixey> SamB: so does it not exist ?
19:50:24 <dolio> Obviously.
19:50:48 <Cale> SamB: It's useful to include them because they make the theory free of annoying exceptions without actually hurting things.
19:50:59 <MyCatVerbs> @index par
19:51:00 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
19:51:12 <dolio> You can compute parts of it.
19:51:23 <dolio> Does that mean that parts of it exist and other parts don't?
19:51:46 <MyCatVerbs> What the Hell. Apparently Control.Parallel isn't shipped with ghc6.8.2 on Ubuntu? oO
19:52:01 <Cale> MyCatVerbs: The Ubuntu packages are separated out.
19:52:03 <dolio> MyCatVerbs: Yeah, I noticed that, too. And I don't see a package for it.
19:52:06 <newsham> dolio isnt that sort of like saying 1+<some number which isnt computable> ?
19:52:40 <MyCatVerbs> Cale: IMO, it's bloody irritating. GHC already eats disk space like crazy, what the Hell is the point in splitting out the goddamn *standard libraries*? Bah, humbug.
19:52:56 <Cale> MyCatVerbs: They're not standard.
19:53:07 <Cale> They're just the libraries that GHC happens to come with.
19:53:10 <newsham> catv: how much space are we talking about here?
19:53:17 <MyCatVerbs> Oh and SEPERATE -prof and -dev versions. Who the HELL thought that was a good idea and what were they smoking!?
19:53:20 <newsham> a 500G drive is like $99 right?
19:53:28 <SamB> dolio: In what theory can you even express what you just said?
19:53:33 <Immmortal> 10^10 bytes
19:53:33 <shapr> Actually, 1TB is $99 on newegg.com
19:53:44 <Cale> MyCatVerbs: why not just install them all?
19:53:54 <dolio> Control.Parallel is marked as 'experimental', just like 80% of the stuff in the hierarchical libraries. :)
19:53:57 <newsham> so $1 = 10G?
19:53:59 <SamB> about the \sum a_i * 2^(-i)
19:54:00 <MyCatVerbs> newsham: just shy of 300MB.
19:54:08 <newsham> mycatverb: how much is that in dollars?
19:54:09 <solrize_> 1tb=$99 ?  wow
19:54:11 <mmorrow> don't forget that their are infinite infinities whose cardinalities are strictly larger than the reals
19:54:18 <MyCatVerbs> Cale: I *have*.
19:54:23 <newsham> 3c?
19:54:26 <shapr> I have 750GB of SATA 3GB/sec storage.
19:54:31 <dolio> SamB: Presumably in some theory that allows you to talk about turing machines being encoded as integers.
19:54:44 <Cale> MyCatVerbs: Oh, is there no package for it?
19:54:52 <MyCatVerbs> Cale: what's even more impressive is that several of the packages are completely broken, and not only won't install at all, but can't be uninstalled after they fail to install.
19:55:00 <shapr> MyCatVerbs: Fix it?
19:55:11 <SamB> dolio: yes, but how would you say "and 0 otherwise"?
19:55:16 <Immmortal> Turing machines are GPGPUs are possible
19:55:20 <SamB> you can't say that in agda can you?
19:55:26 <Immmortal> s/are/in/
19:55:32 <mmorrow> something exists if it exists wrt the axioms you choose the define what exists means
19:55:35 <Cale> MyCatVerbs: Nice. I just use the generic linux binary anyway.
19:55:37 <MyCatVerbs> shapr: this would involve learning how Debian's package management machinery works.
19:55:43 <mmorrow> if it doesn't exist, add another axiom
19:55:46 <mmorrow> now it does!!
19:55:47 <shapr> MyCatVerbs: Well, that's not nearly as hard as learning Haskell :-)
19:56:08 <MyCatVerbs> shapr: it's more work than just bootstrapping from a source tarball.
19:56:09 <Cale> MyCatVerbs: Ubuntu's support for GHC is awful enough that I just ignore it.
19:56:27 <shapr> MyCatVerbs: Yeah, but you could send patches to the package authors and then the problem would be solved for the future.
19:56:36 <Cale> I wouldn't even bother with the source. The binary package works fine.
19:56:36 <MyCatVerbs> shapr: Hell, often as not I end up doing that anyway because the shipped version of GHC is always bloody old.
19:56:37 <newsham> might as well build from src :)
19:56:43 <Dzlk> the problem I have depating platonism is that "exist" is a vague predicate. this pencil, 14 and Ivan Karamazov all "exist".
19:56:49 <roconnor> Cale: what's wrong with ubuntu's support?
19:56:50 <Cale> Compiling things yourself is for suckers.
19:57:05 <MyCatVerbs> shapr: not really. I can't correct for the kind of gross bogosity that results in things like seperate -prof and -dev packages merely by submitting a handful of patches.
19:57:09 <shapr> MyCatVerbs: Er, really? Igloo is the GHC package maintainer for debian, and also one of the GHC maintainers.
19:57:09 <Cale> roconnor: It's almost always a full year behind (not atm, but usually)
19:57:51 <Cale> roconnor: and as MyCatVerbs points out, the way in which things are packaged is a bit obnoxious.
19:58:02 <MyCatVerbs> Cale: a bit? Gah!
19:58:04 <newsham> anyone here know how to install os/360 by any chance?
19:58:13 <shapr> MyCatVerbs: So you'd rather have combined -prof and -dev packages?
19:58:33 <MyCatVerbs> shapr: naturally. If you're doing serious development you need both.
19:58:44 <Cale> I can't imagine a reason why I'd ever want to install the dev version of a package without the profiling support.
19:59:11 <MyCatVerbs> shapr: if you're not doing serious development, then you probably don't need either since whatever app it is you want to compile should already be in Ubuntu's semi-infinite repositories anyway.
19:59:12 <roconnor> Cale: should I switch to NixOS?
19:59:18 <Dzlk> -nodev might be okay.
19:59:35 <Cale> roconnor: I just use the generic linux binary for GHC on Ubuntu, and it works fine.
19:59:37 <shapr> MyCatVerbs: Have you talked to the package maintainers about why you'd like to have combined packages?
19:59:45 * ddarius isn't sure where his ghc came from.  Presumably from an Ubuntu package.
19:59:50 <roconnor> Cale: oh
20:00:06 <Immmortal> it's much Ubuntu that Debian is forgotten.
20:00:08 <roconnor> Cale: isntalled in /usr/local?
20:00:15 <Cale> roconnor: yep
20:00:24 <roconnor> oh
20:00:26 <MyCatVerbs> shapr: I really don't see much point bothering. It's something they've already put effort into doing, and I'd be amazed if they hadn't had a flamewar on the topic every six months or so for the last couple years.
20:00:27 <roconnor> I could get 6.8
20:00:34 <Cale> Yep.
20:00:43 <roconnor> I'll consider doing that
20:00:48 <roconnor> eventually
20:00:54 <Cale> and 6.10, which will be out sooner than the next Ubuntu release surely.
20:00:55 <shapr> MyCatVerbs: Well, there doesn't seem to be much point complaining if you don't want to do something about it :-)
20:01:22 <ddarius> shapr: Bitching is a human pasttime.
20:01:28 <MyCatVerbs> shapr: eh. The bug reports have all been filed months back, no one's bothered to look at them.
20:01:30 <Immmortal> Save to Debian, they do better configurations than Ubuntu's do.
20:01:31 <Cale> MyCatVerbs: Just grab the generic linux binary from the GHC website and install that into /usr/local
20:01:36 <MyCatVerbs> shapr: bitching is more fun than not bitching.
20:01:44 <dolio> SamB: How about this: Omega = sum(2^(-i)), where i ranges over the integers that encode turing machines that halt.
20:02:02 <Cale> http://haskell.org/ghc/download_ghc_682.html#x86linux
20:02:02 <lambdabot> Title: GHC: Download version 6.8.2
20:02:19 <Cale> You'll want Christian Maeder's version.
20:02:26 <shapr> Yeah, but bitching isn't very productive.
20:03:58 <dolio> omega = sum . map ((2^) . negate) . filter (halts . toTuringMachine) $ [1..]
20:04:48 <MyCatVerbs> shapr: neither is your lawnmower.
20:04:52 * gwern sighs. wxhaskell fails to compile even here. I'm never going to get it to work
20:05:06 <shapr> MyCatVerbs: ?
20:06:01 * ddarius sells a book, "How to Win Arguments by Making Nonsensical Statements"
20:06:03 <ripplepay> is there a ghc flag that just checks if the syntax is ok for myfile.hs?
20:06:32 <vixey> ripplepay: in ghci :load myfile
20:06:36 <Cale> http://www.rinkworks.com/persuasive/
20:06:36 <lambdabot> Title: How To Be Persuasive
20:06:53 <newsham> pervasive > persuasive
20:07:06 <ripplepay> yeah, but I have a bunch of files and I just want to find | xargs through them
20:07:08 <shapr> MyCatVerbs: What does that mean?
20:07:08 <SamB> so... uh... cantor's daigonalization argument doesn't seem to work
20:07:25 <ddarius> SamB overturns a century of mathematics.
20:07:33 * shapr tries to figure out how lawnmower == bitching
20:07:40 <MyCatVerbs> ddarius: only if you let me write the foreword, otherwise I'll cheese your breadmaker into a thousand greased camels.
20:07:51 <newsham> he didnt say they are the same, just similarly productive, shapr.
20:07:58 <shapr> oh
20:07:59 <SamB> if you can make a list of all the computable reals, can't you use the list to compute a non-computable number?
20:08:02 <newsham> i think he's offering to mow your lawn
20:08:07 <shapr> Could be!
20:08:12 <shapr> Too bad I don't have one :-(
20:08:28 <MyCatVerbs> Yaaay! And hence I get to mow something else instead!
20:08:31 <newsham> i wonder if its transferable
20:08:31 <ddarius> MyCatVerbs: The book will be entirely authored by women.
20:08:33 <Cale> SamB: Perhaps the list of computable reals isn't itself computable.
20:08:49 <mmorrow> what does it mean to be a computable number?
20:08:54 <SamB> Cale: in that case I'm not sure how the argument works either...
20:08:56 <ddarius> lawnmowers are fairly productive
20:09:11 <newsham> mmorrow: that you have an algorithm to construct a representation of the number?
20:09:11 <vixey> mmorrow: there exists some program that prints n digits of the number in finite time, forall n
20:09:17 <dolio> Especially mulching mowers.
20:09:31 <MyCatVerbs> ddarius: they aren't when your goal is to hack on compilers.
20:09:39 <Cale> SamB: The computable reals are certainly countable, but they're probably not computably countable.
20:09:42 <mmorrow> why do you fix a representation for numbers?
20:09:42 <MyCatVerbs> Unless you feel like printing the compiler out and hacking it apart, that is.
20:09:44 <roconnor> > omega :: CReal
20:09:46 <lambdabot>   Not in scope: `omega'
20:09:49 <SamB> Cale: oh...
20:10:14 <SamB> I don't understand how you mathemeticians propose to count things without computing them...
20:10:28 <Immmortal> 0/0=1
20:10:32 <Cale> SamB: By exhibiting bijections from those sets to the natural numbers
20:10:42 <ddarius> SamB: Those wild constructivists need to be reigned in.  Join the strict finitists
20:10:55 <mmorrow> lol
20:10:56 <SamB> how is it a bijection if I can't use it to compute?
20:11:05 <MyCatVerbs> SamB: "there exists a bijection..." suffices.
20:11:08 <ddarius> Cale: What are these "natural numbers" you speak of.
20:11:12 <roconnor> for some lose sense of exhibit
20:11:20 <vixey> the number of programs is cleary finite
20:11:21 <SamB> Cale: I told you, I'm a constructivist
20:11:23 <Immmortal> demostration: 0=1*0
20:11:24 <MyCatVerbs> ddarius: anything isomorphic to Peano numbers.
20:11:27 <mmorrow> (lol was directed at ddarius)
20:11:27 <vixey> every program is a binary strign
20:11:38 <vixey> which of those programs denote a computable real?
20:11:40 <Cale> SamB: Be a bit more of a formalist, and be happy to I'll tell you
20:11:41 <SamB> vixey: that's not a finite set
20:11:42 <Cale> er
20:11:48 <vixey> oops=
20:11:50 <SamB> vixey: or whatever word I should use instead of set
20:11:53 <vixey> clearly countable*
20:11:59 <Cale> heh, how'd that I'll move over there :)
20:12:09 <ddarius> I see a process for making more "natural numbers", but I see no collection of all of them.
20:12:12 <SamB> "and be happy to tell you I will be"
20:12:23 <SamB> Cale: well, you can step on my toes when I do something overly informa
20:12:26 <Immmortal> another demonstration, for another day.
20:12:27 <SamB> *informal
20:12:30 <vixey> nats = [1..]
20:13:04 <Cale> SamB: That is, if you'll accept that mathematics is just a formal system, and we can make up whatever rules we like, then I can show you the rules which we normally use and how they lead to that conclusion.
20:13:11 <mmorrow> newtype A a = A { unA :: A a } type typechecks
20:13:24 <mmorrow> a finit rep for the infinite
20:13:30 <roconnor> vixey: nats = [0..]
20:13:46 <vixey> oops forget we are computers :P
20:13:51 <vixey> forgot*
20:14:02 <roconnor> 0 is the most natural number
20:14:03 <Cale> SamB: Of course, you're free to pick different rules, but usually we agree on a particular set just so that we can communicate more easily.
20:14:10 <vixey> 0 is weird ....
20:14:14 <Cale> SamB: After all, this is mathematics, not philosophy :)
20:14:28 <Immmortal> 0 attacks you with its strategy of division by zero
20:14:29 <roconnor> so natural people totally missed it for hundreds of years.
20:14:51 <Immmortal> 0 = nihilism
20:15:03 <Immmortal> 0 = bankrupt
20:15:47 <SamB> well, can you explain to me how it is of benefit to me to believe that the uncomputable reals exist?
20:15:55 <vixey> Cales argument makes sense though, we know the computable reals are finite but you cannot filter the list of every program computably
20:16:05 <mmorrow> how is it of benefit to you to not?
20:16:09 <mmorrow> or not not?
20:16:27 <gubagem> reals themselves are infinite
20:16:46 <gubagem> how could you prove an uncomputable real
20:16:56 <vixey> dedekind cuts ?
20:16:57 <gubagem> just an irrational like pi or that hting from natural log
20:17:02 <vixey> heytings tree thingy.....
20:17:11 <gubagem> whats a dedkind cut
20:17:26 <Immmortal> the symbolic computation of the integral of cos(1/x) dx is recursively computable without termination
20:17:32 <roconnor> computable reals are not finite.
20:17:32 <mmorrow> so, are you saying the set of reals has infinite cardinality, or that individual elts of that set have an infinite rep given the way you happen to choose to represent them?
20:17:44 <Cale> pi is computable
20:17:50 <arw__> http://www.umcs.maine.edu/~chaitin/olympia.pdf <- with a neat proof by turing.
20:17:50 <vixey> bah I keep saying "finite" when I mean to say "countable"
20:17:50 <SamB> I posit that any argument that would convince me would also result in a way to find one
20:18:02 <mmorrow> haha
20:18:22 <SamB> ... which would be a contradiction
20:18:24 <roconnor> the computable reals are not countable.
20:18:27 <roconnor> er
20:18:31 <Cale> For an example of an uncomputable real, try  sum over i >= 0 such that the ith Turing machine halts of 1/2^i
20:18:31 <roconnor> hmm
20:18:44 <roconnor> it is not provable that the reals are contable.
20:18:48 <Cale> (under any fixed ordering of the Turing machines)
20:18:50 <SamB> Cale: I don't believe that what you have just said means anything
20:18:56 <Cale> SamB: Of course it does.
20:18:56 <Elly> roconnor: the reals aren't countable
20:18:59 <roconnor> it is not provable that the computable reals are countable.
20:19:06 <gubagem> the cardinality of the reals is 2^aleph-null
20:19:08 <roconnor> still not right
20:19:13 <roconnor> it is not provable that the constructive reals are countable.
20:19:15 <roconnor> there
20:19:28 <vixey> roconnor: Why? they are a subset of all programs aren't they?
20:19:32 <Cale> SamB: What's confusing about it?
20:19:47 <vixey> (programs being binary strings)
20:19:52 <roconnor> vixey: yeah, I had to change to constructive reals.
20:19:54 <gubagem> you could never have enough turing machines to produce them all
20:19:56 <Cale> SamB: Either a Turing machine halts on the empty input, or it doesn't.
20:20:02 <gubagem> if you had countable turing machines
20:20:05 <SamB> Cale: there it is!
20:20:08 <vixey> constructive and computable reals are different? :S
20:20:11 <Immmortal> the symbolic computation of the integral of cos(1/x) dx never halts
20:20:12 <SamB> you used the law of excluded middle!
20:20:13 <vixey> OH
20:20:17 <Cale> SamB: Right.
20:20:17 <vixey> right yeah, sorry I know what you mean
20:20:38 <Cale> SamB: LEM is one of the formal rules which I'm allowed to use.
20:20:38 <vixey> It's not LEM
20:20:38 <gubagem> SamB i did?
20:20:38 <vixey> It's a fact about turing machines
20:20:40 <Cale> It's meaningless to ask whether LEM is true.
20:20:45 <Cale> It's an axiom.
20:20:59 <roconnor> SamB: everytime Cale says or, just read it as not and not not, then you'll understand him.
20:21:06 <Cale> (So of course it's true, in this context)
20:21:10 <vixey> hehe
20:21:35 <Cale> In fact, prefix every one of my statements with not not.
20:21:45 <roconnor> SamB: Cale speaks in a limited language.
20:21:57 <vixey> You don't need LEM to say that though, every turing machine does halt or not
20:22:08 <vixey> this isn't as strong as P \/ ~P
20:22:14 <MyCatVerbs> Cale: oh goodness no, not in a Prolog interpreter. That would be suicidal.
20:22:28 <MyCatVerbs> Cale: not(not(X)) being very definately not the same as (X), and all that.
20:22:50 <Cale> roconnor: Of course, I can embed intuitionist logic as well (though in not as simple a fashion), given set theory.
20:22:54 <vixey> not/1 existence error
20:22:56 <gubagem> in reality every turing machine has a chance of halting
20:22:59 <roconnor> @djinn not (not Nat)
20:23:01 <Immmortal> Use Coq, Isabelle, Hol4, ... they are high level logic languages.
20:23:02 <lambdabot> -- f cannot be realized.
20:23:05 <gubagem> because there is a chance of error
20:23:10 <roconnor> @djinn Nat
20:23:10 <lambdabot> -- f cannot be realized.
20:23:19 <roconnor> oh
20:23:22 <roconnor> recursive types
20:23:32 <vixey> @djinn Nat -> Nat
20:23:32 <lambdabot> f a = a
20:23:37 <vixey> @djinn Nat -> not (not Nat)
20:23:37 <lambdabot> -- f cannot be realized.
20:23:52 <MyCatVerbs> gubagem: in reality, every Turing machine has a nonzero chance of being hit by a meteorite. We're not *usually* interested in such issues, though.
20:23:54 <arw__> gubagem: wrong, there are equally many turing machines which would have a chance of not halting because of error which would have halted in a error-free world.
20:24:04 <roconnor> Cale: yes, but you interpretation is deep (shallow?) while our interpetation of your language is shallow (deep?)
20:24:27 <Immmortal> a cluster of GPGPUs does more faster than your supercomputer
20:24:31 <MyCatVerbs> arw__: if you define "error" as "incoming meteorite and/or ICBM" then actually errors *always* cause machines to halt early instead of not-halt. ;P
20:24:39 <SamB> Cale: I thought I told you I was a constructivist
20:24:51 <SamB> constructivists are not allowed to use the LEM in general
20:24:51 <Immmortal> they can compute thousands of TMs
20:24:52 <vixey> why be a constructivist though
20:24:58 <vixey> there's interesting maths which isn't constructive
20:25:04 <gubagem> like what
20:25:14 <arw__> gubagem: the only (almost correct) argument would be to argue that our universe probably has a finite lifetime.
20:25:15 <SamB> vixey: well, it's the natural camp for a programmer to be in
20:25:24 <gubagem> ive seen it man
20:25:29 <Cale> roconnor: I'm of the weak opinion that the two languages are almost equally expressive for real world use, but will likely model things in different ways.
20:25:29 <gubagem> the whole universe is just full of stars
20:25:37 <gubagem> and then it becomes that light you reach when you die
20:25:42 <mib_elre1i> hey, how can i had latin1 support in ghc6.8.2, i wanna had the @ sign and i am getting trouble
20:25:43 <vixey> SamB: it seems like only using one programming language for every task
20:25:50 <roconnor> The most annoying thing about classical logic is that there is a TM that prints yes if Riemann hypothesis and prints no if it is false.
20:25:57 <roconnor> and that is just stupid
20:25:59 <vixey> SamB: just picking whichever logic you want to work in should be fine, as long as you know what your doing
20:26:40 <mib_elre1i> how can i had latin1 support in ghc6.8.2, i wanna had the @ sign and i am getting trouble ???
20:26:48 <SamB> I hate theorems that say that something exists but the proofs don't say how to find it
20:27:04 <arw__> don't we all? :)
20:27:13 <roconnor> SamB: such as above. :)
20:27:18 <Immmortal> SamB, i love more the algorithms than the theorems.
20:27:26 <SamB> THAT is why I am a constructivist
20:28:06 <vixey> Reals are weird though
20:28:25 <roconnor> vixey: which ones?
20:28:34 <vixey> the set R
20:28:38 <Cale> SamB: I *love* those proofs.
20:28:45 <roconnor> classical reals
20:28:46 <twanvl> mib_elre1i: You don't need to do anything special, the @ sign is in ascii and most other code tables. What is the problem exactly?
20:28:46 <vixey> existence of a lub etc ..
20:29:00 <Cale> Nonconstructive existence proofs are awesome!
20:29:10 <mmorrow> !
20:29:14 <Immmortal> year 2008: programming algorithms
20:29:20 <Immmortal> year 2108: programming theorems
20:29:31 <vixey> Cale, any good ones spring to mind?
20:30:19 <MyCatVerbs> @check (2*a) == a + a
20:30:21 <lambdabot>  Falsifiable, after 0 tests:
20:30:24 <mib_elre1i> any help !!!
20:30:24 <mib_elre1i> i am getting a lexical string error, when decoding utf-8 chars
20:30:51 <roconnor> MyCatVerbs: wtf?
20:31:12 <MyCatVerbs> roconnor: not guaranteed to be true in floating point implementations. :P
20:31:16 <Cale> There's a cute little famous one that there exist irrational numbers a and b such that a^b is rational
20:31:20 <MyCatVerbs> @check (2*a) == a + (a :: Integer)
20:31:21 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Expr'
20:31:34 <Cale> Do you know that one?
20:31:41 <vixey> I don't think I've heard it
20:31:42 <roconnor> ah
20:31:47 <MyCatVerbs> roconnor: either that or \bot is interpreting the expression in a completely different way to whatI was expecting. ;)
20:31:54 <Cale> Remember that sqrt(2) is irrational and 2 is rational.
20:31:55 <SamB> Cale: why wouldn't they exist?
20:31:57 <twanvl> mib_elre1i: could you show us your code and the exact error message,  http://hpaste.org/new
20:32:06 <roconnor> @check \a -> (2*a) == a + a
20:32:07 <lambdabot>  OK, passed 500 tests.
20:32:08 <Cale> Consider the number q = sqrt(2)^(sqrt(2))
20:32:16 <roconnor> @check a
20:32:16 <lambdabot>   add an instance declaration for (Testable Expr)     In the expression: let ...
20:32:16 <Cale> Either it's rational or it's irrational.
20:32:25 <Cale> If q is rational, we're done.
20:32:37 <roconnor> > a == b
20:32:38 * SamB wonders how you can decide which it is
20:32:38 <lambdabot>  False
20:32:40 <vixey> ooh
20:32:42 <roconnor> > a == a
20:32:43 <lambdabot>  True
20:32:53 <Cale> If q is irrational, then q^sqrt(2) = sqrt(2)^(sqrt(2)*sqrt(2)) = sqrt(2)^2 = 2
20:32:54 <Immmortal> why  irrational  *  irrational  =  rational ?
20:32:55 <SamB> I'm sure it's not neither, however
20:33:00 <vixey> that's nice :D
20:33:28 <Cale> So you don't need to know which one it is. :)
20:33:38 <vixey> I do wonder though
20:34:06 <Cale> Right, it's a good question.
20:34:20 <Cale> But it's nice that it's a separate question, at least I think.
20:34:26 <SamB> Cale: how are you supposed to know if you are done?
20:34:29 <mmorrow> the great thing is, one could construct a program which constructs nonconstructivist existence proofs (i claim without proof)
20:34:39 <dsdsd> why utf-8 is not working in my ghc,latin1 chars r not decoding
20:34:43 <Cale> SamB: I've exhausted all the possible cases.
20:34:59 <SamB> Cale: I meant, you said "if q is rational, then we are done"
20:35:10 <SamB> I suppose you could take both paths at once...
20:35:14 <Cale> SamB: Oh, because q = sqrt(2)^sqrt(2)
20:35:16 <SamB> that should work
20:35:28 <gwern> 'Solomonoffâs model of induction rapidly learns to make optimal predictions for any computable sequence, including probabilistic ones [13, 14]. It neatly brings together the philosophical principles of Occamâs razor, Epicurusâ principle of multiple explanations, Bayes theorem and Turings model of universal computation into a theoretical sequence predictor with astonishingly powerful properties. Indeed the problem of sequence prediction could well be c
20:35:31 <Cale> and if q is rational, well, we already know that sqrt(2) is irrational for sure
20:35:34 <gubagem> can a constructivist construct some varieties of infinite
20:35:36 <gwern> hee hee. incomputability is something of a problem :)
20:35:51 <Cale> So that means we've already found a rational of the form a^b with a and b irrational.
20:35:52 <SamB> Cale: yes, but you can't stop when you are done unless you are AWARE of this fact
20:36:00 <vixey> gwern omg :o
20:36:00 <Cale> SamB: hm?
20:36:05 <Cale> SamB: What do you mean stop?
20:36:05 <vixey> I want that in lambdabot
20:36:07 <SamB> it doesn't count as finding unless you can see that you have found something
20:36:09 <Immmortal> define the multiplication of two irrationals
20:36:13 <ddarius> Cale: His point is that if q isn't rational, you could spend forever trying to determine if it is.
20:36:33 <Cale> I don't care about determining *whether* q is rational or not.
20:36:34 <Immmortal> and why sometimes it results rational!
20:36:41 <Cale> Because I have a backup plan in either case.
20:37:13 <SamB> I suppose you could just say that "either these two numbers or those two numbers" satisfy the stated critereon...
20:37:25 <Cale> Immmortal: sqrt(2) is irrational, and sqrt(2) sqrt(2) = 2
20:37:36 <twanvl> dsdsd/mib_elre1i: Are you sure it is an utf-8 decoding error? @ is a keyword in haskell, so it is not a valid operator name for example.
20:37:42 <Cale> SamB: right.
20:37:53 <Immmortal> Cale, it's possible that the multiplication of these 2 irrationals are non-computable
20:38:06 <Cale> SamB: and we don't need to know which, because if one isn't, then the other will be.
20:38:26 <Cale> Immmortal: the product of computable numbers is computable
20:38:35 <Cale> Immmortal: By the highschool algorithm
20:38:52 <Cale> (or elementary school algorithm, really :)
20:38:54 <Immmortal> the irrationals are non-computable numbers
20:38:55 <SamB> Cale: they don't teach that kind of stuff in any highschool around here...
20:39:03 <SamB> Immmortal: they are not
20:39:07 <Cale> SamB: How to multiply numbers?
20:39:07 <QtPlatypus> Cale: Not if you wish your algorithm to terminate.
20:39:19 <SamB> Cale: how to multiply numbers of non-finite length
20:39:20 <Immmortal> sqrt(2) never terminates
20:39:34 <arw__> QtPlatypus: but then 1/3 is not computable, although it is rational.
20:39:39 <Cale> Do you know what it means for a real number to be computable?
20:39:41 <SamB> QtPlatypus: Immmortal: but the computable reals are codata, not data
20:39:49 <SamB> they don't need to terminate, they need to progress
20:39:52 <vixey> how are they codata?
20:40:04 <gubagem> is there left and right codata?
20:40:04 <Cale> It means that there is a program which takes an integer which is the number of digits to compute, and emits that number of digits of the real number, essentially.
20:40:05 <SamB> you need to be able to get n digits in bounded time
20:40:07 <dsdsd> twanvl just giving a string error when decoding the latin1 chars, when i comment them out it compiles
20:40:10 <vixey> I see them as a program with some property
20:40:18 <vixey> not as an infinite list of digts
20:40:19 <gwern> Distributed Haskell has a '!' operator?
20:40:22 <gwern> what a lousy choice
20:40:22 <MyCatVerbs> vixey: because they aren't finite.
20:40:25 <SamB> Cale: I don't like that way of stating it ;-)
20:40:27 <vixey> am I wrong with this visualization
20:40:34 <MyCatVerbs> vixey: see Cauchy numerals, for example.
20:40:37 <SamB> vixey: what is the difference?
20:40:44 <QtPlatypus> arw__: 1/3 is computable because I can write a computable function f(n->{0,1}) that gives me the n'th diget.
20:40:48 <vixey> SamB: data vs codata I guess
20:40:54 <elliottt> thetallguy: ping
20:41:03 <twanvl> dsdsd: it is probably safest to escape anything that is not ascii inside strings
20:41:18 <ddarius> vixey: A program is like a machine with some sequence of output, no?  That's perfectly in accordance with codata.
20:41:31 <MyCatVerbs> vixey: any representation which fully captures the properties of real numbers is either going to have to take infinite space to hold, or is going to have to be codata. :p
20:41:35 <SamB> QtPlatypus: so too with the product of irrationals...
20:41:46 <vixey> I see!
20:42:07 <Immmortal> why the product of two codata is a data ?
20:42:07 <vixey> MyCatVerbs: is it called something else? (I didn't find Cauchy numerals)
20:42:21 <arw__> QtPlatypus: yes, but that disproves your earlier claim that all reals are noncomputable. because i can give you such an algorithm for pi or sqrt(2).
20:42:23 <QtPlatypus> SamB: The high school alorgithum is start at the LSB.  Finding the LSB would be equiverlent to solving the halting problem.
20:42:49 <SamB> QtPlatypus: I never agreed that they actually teach an appropriate algorithm in highschool
20:42:49 <arw__> QtPlatypus: replace 'reals' with 'irrationals'.
20:43:09 <QtPlatypus> arw__: I didn't say that all reals are noncomputable.  I said that calculating the product of reals isn't computable.
20:43:40 <vixey> > pi * pi :: CReal
20:43:42 <lambdabot>  9.8696044010893586188344909998761511353137
20:43:44 <QtPlatypus> SamB: What is the algorithm for finding the product your thinking of.
20:44:02 <SamB> QtPlatypus: I don't know OTTOMH
20:44:15 <Cale> QtPlatypus: To get the first n digits of a product, you only need the first n digits of each of the factors.
20:44:19 <SamB> but it is well known that it exists
20:44:23 <Cale> (in fact, that's more than enough)
20:44:33 <SamB> (Apparantly not well ENOUGH)
20:45:03 <Cale> SamB: they don't teach you how to multiply numbers by hand?
20:45:15 <SamB> Cale: not infinitely long ones, no...
20:45:25 <Cale> SamB: Well, not specifically.
20:45:27 <Immmortal> for a TM, the codatas are bad idea
20:46:17 <Cale> But now that we're grown up, it's pretty easy to see that you just take finite segments, and compute the product to get a corresponding segment of the result.
20:46:36 <SamB> Cale: yeah
20:46:59 <Immmortal> how assign i PI to TM ? does anyone know how to assign it?
20:47:01 <Cale> actually, I'm pretty sure that was mentioned in one of my highschool classes
20:47:04 <SamB> Cale: and it isn't THAT hard to figure out how to go on and generate more
20:47:53 <vixey> what are the operations you cant do with computable reals?
20:47:58 <vixey> all I know is ==
20:48:58 <monochrom> You can multiply two infinite power series. In this sense: find the x^0 term in the answer, then find the x^1 term in the answer, then find the x^2 term in the answer...  The x^n term takes only n^2 time to find.
20:49:34 <newsham> cale: umm.. dont you have to know all of the digits before you can know what the carry into the upper most digit is?
20:49:34 <monochrom> Likewise, you can also multiply two "infinitely long" numbers, i.e., "10-adic" numbers...
20:49:56 <Cale> newsham: nope
20:50:06 <Immmortal> don't exist TM to store infinite digits of these numbers
20:50:10 <monochrom> Just go from LSB towards the MSB direction.
20:50:59 <newsham> mono: what if there are an infinite number of msb's?
20:51:00 <Immmortal> no such tape has infinite length
20:51:11 <newsham> err lsb's i mean
20:51:55 <Cale> newsham: Note that (in binary, say), we have 0.111... = 1.000...
20:52:04 <Immmortal> otherwise, TM never terminates assigning infinite digits
20:52:16 <hpaste>  tphyahoo pasted "various nub functions on unsafeperformio's blog won't work on streams" at http://hpaste.org/7867
20:52:28 <monochrom> I carefully said towards the msb direction. This does not imply you will hit some kind of msb real soon now.
20:52:43 <newsham> cale: and what of 0.1111111111.....0......111111.... ?
20:52:49 <Immmortal> i though the TM only work for countable numbers
20:52:57 <newsham> you dont know if the "last" digit is zero or one
20:53:11 <Cale> There is no last digit.
20:53:19 <newsham> right.
20:53:27 <newsham> so when you're multiplying using a finite prefix of the value
20:53:32 <newsham> how do you comute a finite prefix of the result
20:53:33 <monochrom> Oh! infinitely man lsbs?  Then start from msb and go towards the lsb direction...
20:53:41 <newsham> without accumulating all of the (infinite) bits?
20:53:57 <newsham> since the msb's will depend on the carry's from adding the lsb's
20:54:13 <newsham> (unless you're using a different algorithm than I am)
20:54:14 <Immmortal> then should exist a 5th X-Machine that covers the TM
20:54:14 <vixey> newsham: You can still compute a finite number of digits in finite time
20:54:27 <Immmortal> for non-countable numbers
20:54:35 <newsham> vixey: how do you compute the first digit?
20:54:46 <monochrom> Ha, ok, I don't know how to add.
20:54:51 <Cale> newsham: Well, think of it this way. Numbers in binary have an integer part (which is no problem), and then some subset of {1/2^i : i a positive integer}
20:54:57 <SamB> newsham: well, you just have to stop rounding the usual way...
20:54:57 <newsham> the first digit of the result relies on all of lsb's of the two operands
20:55:11 <vixey> ?where CReal
20:55:11 <lambdabot> I know nothing about creal.
20:55:15 <vixey> :/
20:55:22 <newsham> cale: why is the integer part no problem?
20:55:32 <newsham> the integer part of the result is not independent of the fraction part of the inputs
20:55:37 <Cale> Because I'm sure you know how to multiply two integer parts.
20:55:52 <newsham> but the integer part of the result isnt the product of the integer parts of the inputs
20:55:52 <SamB> and accept that if you find that the first 5 digits of two numbers are 0.1111 and 1.0000, they could be the same number
20:56:00 <vixey> ?where+ CReal http://r6.ca/FewDigits/
20:56:01 <lambdabot> Nice!
20:56:07 <newsham> 3.x * 3.y != 9.z
20:56:18 <vixey> newsham: This code will describe it more clearly than I
20:56:23 <Cale> newsham: well, okay
20:56:36 <Cale> newsham: So I'll do this the right way then :)
20:56:55 <newsham> I know how to multiply two infinite power series.  but multiplying an infinite number of digits also involves a carry operation
20:56:59 <Immmortal> The TM is ya not an Universal Machine
20:57:22 <Immmortal> The Universal Machine is this 5th X-Machine
20:57:23 <Cale> A binary expansion for a real number is a subset of {1/2^i : i in Z} with finitely many terms that have negative values for i.
20:57:25 <vixey> newsham: (incase you missed the link http://r6.ca/FewDigits/ )
20:57:26 <lambdabot> Title: Few Digits 0.5.0
20:57:36 <Cale> We'll look at it that way :)
20:57:57 <Cale> That is, the real number being represented is the sum of those binary fractions.
20:58:05 <newsham> sure
20:58:57 <newsham> or   2^(n-i) | i <- [0..]    if you consider all positive reals
20:59:05 <newsham> for some n
20:59:22 <Cale> er, yeah, I should have said positive number
21:00:42 <Cale> Now, note that the sum over k > n of 1/2^k is equal to 2^-n
21:01:00 <newsham> yup
21:01:10 <Immmortal> TM only solve "finite" elements
21:01:37 <Immmortal> it can't solve infinite series, irrationals numbers, etc.
21:01:51 <dons> hmm, this seems wrong, "Persistent data structures can also be created using in-place updating of data and these may, in general, use less time or storage space than their purely functional counterparts."
21:01:56 <dons> http://en.wikipedia.org/wiki/Persistent_data_structure
21:02:07 <dons> the 'in general use less time or storage space .."
21:02:42 <Cale> Now, when we take the product of two real numbers, we're effectively taking the Cartesian product of the expansions, multiplying each pair individually (add the exponents), and then summing over the results.
21:02:44 <dons> you've had to trade something there -- access to the old copies. so likely time, since you now have to be able to regenerate the old versions by undoing the updates
21:03:21 <newsham> *nod*
21:03:31 <Cale> So the question becomes how many times can 1/2^k show up in the result of that?
21:03:46 <Cale> and I suppose I actually made a small mistake in what I'd said before :)
21:04:01 <ddarius> dons: I believe there exist imperative implementations of persistent data structures with asymptotic bounds better than can be achieved without mutation.
21:04:06 <Immmortal> they computed in the wrong machine
21:04:12 <Cale> Because you actually need a few more digits according to the integer part.
21:04:44 <dons> ddarius: in general? for time *and* space
21:04:45 <dons> ?
21:04:47 <newsham> cale: you're saying that the 2^(-k) term only shows up a finite amount of times?
21:04:58 <Cale> newsham: right.
21:05:03 <newsham> and the you sum those.
21:05:09 <newsham> but.... also.. you sum the smaller terms
21:05:13 <dons> that sounds like a very strong results. it rings a bell, maybe for a restricted class of structures/or in dimension
21:05:15 <Cale> newsham: In fact, it's bounded by the number of integer terms
21:05:16 <newsham> and they can have carries into the 2^(-k) term
21:05:17 <dons> hmm
21:05:27 <Cale> er, the exponent on the largest integer terms
21:05:42 <newsham> because the factor on the 2^(-k) term has to be only 0 or 1.
21:05:47 <newsham> larger factors have to be propogated out.
21:05:48 <ddarius> dons: I'm not sure if it has been conclusively proven, but if it hasn't, the expectation is that that is the result.
21:05:54 <newsham> (unless you're ocnsider a different representation of numbers)
21:05:59 <Cale> Don't think in terms of carries just yet.
21:06:07 <Immmortal> 0^-1 is division by zero
21:06:21 <newsham> ok.. so you have a finite number of terms to get to get your intermediate factor for the 2^(-k) term.
21:06:24 <newsham> I buy that
21:06:57 <newsham> so you collect all of those and sum all of those terms..
21:07:05 <Cale> But the important thing is that 1/2^k can occur only finitely many times for all k, bounded by a common bound.
21:07:14 <newsham> yup.
21:07:20 <newsham> I buy that part
21:07:28 <Immmortal> it doesn't use division, it only uses the powering
21:07:30 <Cale> Let's say that's B
21:07:49 <newsham> err.. wait.. the bound is different for each k
21:07:50 <Cale> then the error from ignoring terms with k > n is only at most 2^-n B
21:07:53 <newsham> but for a given k its finite
21:08:23 <Cale> hmmm
21:08:49 <geezusfreeek> is it generally true that mzero = empty and mplus = (<|>) ?
21:08:51 <dons> ddarius: if you know of a reference, that would be interesting
21:08:59 <geezusfreeek> for MonadPlus and Alternative, respectively
21:09:05 <Cale> oh, right, for each k, it's the a,b such that a+b = k of course
21:09:29 <Cale> ah, but what really matters is not how many terms there are
21:09:39 <Immmortal> you need "some induction" for it
21:09:56 <Saizan> isn't enough to notice that once you've approximated a trailing 0 (or two?) smaller terms can at most have an effect on that digit?
21:09:56 <Cale> But how many terms which involve terms farther out than k
21:09:59 <newsham> I buy that you can compute a number to within an arbitrary 2^(-k) error
21:10:11 <Cale> newsham: okay
21:10:28 <Cale> newsham: Then once you've done that, you have the binary expansion exactly up to that point.
21:10:31 <Immmortal> it need to invent a number, by example, the 0 or the 1 or the 0.5 or the 0.75 or the 0.25 ...
21:10:35 <newsham> and you're saying that since you can pick the size of that error arbitrarily small, you in effect computed the solution in finite time?
21:10:40 <Cale> yes
21:10:45 <newsham> well not "exactly" but pretty close
21:10:49 <newsham> ok, that seems reasonable.
21:11:05 <Cale> Computable reals remember, are programs which tell you the first n digits of the number.
21:11:07 <Immmortal> and then to test if it accomplies the bound condition
21:11:13 <Cale> (for any supplied input n)
21:11:16 <newsham> you dont know exactly what each digit is (there might be a carry bit to accomodate for) but that error is arbitrarily small
21:11:36 <newsham> so.. thats not exactly the same thing as "telling you the first n digits"
21:11:38 <Cale> newsham: Well, if the error is smaller than 2^-n, then you know the first n digits.
21:11:39 <newsham> but I buy your argument.
21:11:41 <ddarius> dons: I don't though something by or referenced by Tarjan may do.  As an exercise, consider implementing DiffArrays purely functionally and with the same bounds on operations.
21:11:52 <Cale> (and there won't be any carries)
21:12:02 <newsham> the first n digits of 1.0 is not 0.11111111111111....<n>....1
21:12:15 <newsham> the first digit of 1.0 is 1.
21:12:20 <vixey> newsham: yes it is
21:12:23 <newsham> but "close enough"  (arbitrarily small delta)
21:12:26 <Cale> Well, 1 has two binary expansions
21:12:27 <vixey> 0.1111111111111111 = 1
21:12:30 <Cale> and they're both valid
21:12:31 <vixey> within your epsilon
21:12:38 <newsham> ok, I see what you're saying.
21:12:48 <Cale> (binary expansions are not unique)
21:13:03 <dons> ddarius: yeah, for a particular structure, i could buy say, space.
21:13:22 <dons> but in general, for time and space, seems unlikely. zippers, for example. so much sharing
21:13:57 <newsham> thats not entirely true.  for any finite size there is a distinct difference between 1.0 and 0.11111111
21:14:21 <newsham> its only when you're considering an infinite length bit stream that they are equivalent
21:14:48 <Immmortal> the Turing Machine never has a infinite lengh tape
21:14:57 <newsham> immmortal: thats ok, we dont care.
21:15:05 <Immmortal> its tape is very longer but finite
21:15:07 <dons> ddarius: we should ask okasaki to write that page..
21:15:29 <arw__> Immmortal: it is always 'long enough', which is infinite for our purpose :)
21:15:43 <Immmortal> but it fails storing PI
21:15:55 <ddarius> Don't start responding to Immortal now.
21:15:59 <Immmortal> it never terminates storing PI
21:16:03 <newsham> it doesnt have to store PI, it just needs to store a program that can compute digits of PI
21:16:21 <newsham> ?keal pi
21:16:21 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
21:16:21 <dons> ddarius: ? troll?
21:16:25 <Immmortal> PI is the input data
21:16:34 <dons> or a bot.
21:16:49 <newsham> ?vixen  PI is the input data
21:16:49 <lambdabot> Uh-huh
21:16:49 <geezusfreeek> huh
21:16:50 <ddarius> dons: I don't know, but he's just spent the past half hour or so interjecting random comments.
21:16:58 --- mode: ChanServ set +o dons
21:17:13 <vixey>  <Immmortal> wow joshcryer, but i don't want compilers because are more complicated and buggier than interpreters
21:17:36 <Immmortal> vixey, why paste my line from #scheme?
21:17:49 <Immmortal> you're insulting me
21:17:50 <newsham> ?vixen vixey, why paste my line from #scheme?
21:17:50 <lambdabot> why don't you guess?
21:17:52 --- mode: dons set +b *!*=ReinoDio@84.79.67.*
21:17:52 --- kick: Immmortal was kicked by dons (dons)
21:18:03 <geezusfreeek> yay
21:18:09 <vixey> ?vixey your line?
21:18:09 <lambdabot> let's don't talk about that
21:18:15 <Korollary> pasting from another channel is insulting eh
21:18:15 <dons> the logs are a bit of an indictment
21:18:40 <dons> keal-ish
21:19:05 <vixey> ?w80 indictment
21:19:06 <lambdabot> *** "indictment" wn "WordNet (r) 2.0"
21:19:06 <lambdabot> indictment
21:19:06 <lambdabot>      n 1: a formal document written for a prosecuting attorney
21:19:06 <lambdabot>           charging a person with some offense [syn: {bill of
21:19:06 <lambdabot>           indictment}]
21:19:08 <lambdabot>      2: an accusation of wrongdoing; "the book is an indictment of
21:19:09 <lambdabot>         modern philosophy"
21:19:21 <newsham> have the schemers grown a sudden interest in pestering haskell users?
21:19:30 <dons> he's in 20 other channels
21:19:32 --- mode: ChanServ set -o dons
21:19:55 <monochrom> I'm fairly sure he is the unique person in exactly all those channels.
21:20:15 <gwern> newsham: 'the only thing worse than being talked about is not being talked about'?
21:20:38 <vixey> newsham: What did you mean "my line"?
21:21:08 <newsham> ?vixen What did you mean "my line"?
21:21:08 <lambdabot> no
21:21:30 <vixey> newsham: ... can you answer ?
21:21:37 <newsham> I dont understand the question.
21:21:43 <vixey>  <newsham> ?vixen vixey, why paste my line from #scheme?
21:21:51 <vixey> I have no idea what you mean by "my line" there
21:22:00 <newsham> I was providing Immmortal's msg to vixen
21:22:04 <geezusfreeek> <Immmortal> vixey, why paste my line from #scheme?
21:22:12 <vixey> oh ok
21:22:16 <vixey> I put them on /ignore hours ago
21:22:18 <mmorrow> i don't think Immmortal was a bot
21:22:26 <geezusfreeek> still annoying
21:22:47 <ddarius> mmorrow: I'm pretty sure he wasn't.
21:22:51 <geezusfreeek> if we say one more thing about Immortal, the terrorists win
21:22:57 <vixey> they're probably just some interested foreign language speaker
21:23:02 <mmorrow> yeah
21:23:30 <newsham> > map succ "immortal hitler terrorists"
21:23:34 <lambdabot>  "jnnpsubm!ijumfs!ufsspsjtut"
21:23:41 <vixey> iirc they're ban evading in #scheme now though
21:23:50 <ddarius> I'm pretty sure he wasn't interested.
21:24:26 <dons> ban evading, vixey ?
21:24:27 <mmorrow> hard to tell, but it is how it is
21:24:40 <newsham> apply apathy
21:24:52 <monochrom> Haskell is my immortal beloved.
21:24:58 <vixey> dons: maybe it's someone else who also idles in #smalltalk and talks nonsense in #scheme not sure
21:25:33 <newsham> fmap apathy #haskell
21:26:09 <mmorrow> filter (/=Immortal) .
21:37:22 --- mode: ChanServ set +o glguy
21:37:23 --- mode: glguy set +b *!*@84.79.67.*
21:37:39 --- mode: glguy set -b *!*@84.79.67.*
21:37:42 <glguy> err
21:37:48 --- mode: glguy set +b *!*@84.79.67.*
21:37:56 --- mode: glguy set -b *!*=ReinoDio@84.79.67.*
21:38:09 --- mode: glguy set -o glguy
21:38:30 <gubagem> gubagem: what do you think of the language
21:38:30 <gubagem> (12:36:01 AM) tiltgod: it's hidious
21:38:30 <gubagem> (12:36:07 AM) gubagem: oh how so
21:38:30 <gubagem> (12:36:35 AM) tiltgod: it looks like shell script high on scheme
21:38:39 <gubagem> someones opinion of haskell
21:38:50 <allbery_b> someone needs help
21:38:52 <gubagem> or maybe my code just still looks like scheme :-(
21:39:03 <gubagem> he likes nasm
21:39:27 <gubagem> are monads even neccesary for anything but IO
21:39:59 <monochrom> I like shell script and haskell. I did asm, been there done that tired of it. Bite me.
21:40:29 <monochrom> Monads aren't necessary. You can use arrow or applicative instead.
21:41:03 <gubagem> yeah but the <- arrow is just >>= with a \f->thingie
21:41:20 <gubagem> but whats the applicative
21:41:30 <SamB_XP> yku
21:41:32 <SamB_XP> er.
21:41:35 <monochrom> I mean Control.Arrow and Control.Applicative, not "<-".
21:41:40 <SamB_XP> you could also just use "warm fuzzy things"
21:42:17 * gubagem does a group hug and runs off to bed
21:44:02 <monochrom> It's so difficult to converse with ignorant people.
21:44:17 <monochrom> You say "computable real" and they think you mean IEEE 754.
21:44:37 <monochrom> You say "arrow" and they think you mean "<-" in the do-notation.
21:45:04 <Elly> monochrom: what is the definition of "computable real"?
21:45:11 <monochrom> What's next, you say "haskell is a programming language" and they think you mean "oh, so like VBA?"
21:45:18 <vixey> Elly: It's been defined about 15 times today o_o
21:45:22 <Elly> oh
21:45:26 <Elly> I haven't been paying attention :P
21:45:42 <vixey> there exists some program that prints n digits of the number in finite time, forall n
21:45:48 <Elly> ah, okay
21:45:55 <aFlag_> hi. I've compiled a wx-haskell program and when I try to run it the system complains that I don't have the libwxc-gtk2.6.3-0.10.3.so shared object
21:46:05 <Elly> so pi is computable, for example?
21:46:06 <aFlag_> has anyone here ever had that problem?
21:46:08 <vixey> yes
21:46:12 <SamB_XP> Elly: quite!
21:46:20 <Elly> excellent
21:46:30 <Elly> what's an example of an uncomputable real?
21:46:38 <SamB_XP> Elly: I haven't the slightest!
21:46:43 <aFlag_> I can't even find anything on google just looking for that shared object
21:46:53 <SamB_XP> I
21:46:59 <SamB_XP> am not sure I believe they exist
21:47:00 <dolio> Omega.
21:47:13 <Elly> Omega in what sense?
21:47:21 <vixey> Elly: Here's a great book http://www.umcs.maine.edu/~chaitin/unknowable/
21:47:21 <lambdabot> Title: Chaitin, The Unknowable
21:47:29 <vixey> Elly: careful, it's not really maths ... even though it looks like it
21:47:50 <vixey> (he's published some other stuff online too it's all good)
21:48:01 <dolio> sum(2^-i) where i ranges over the integers that denote halting turing machines.
21:48:08 <dolio> Positive integers, that is.
21:48:19 <Elly> ahh
21:48:28 <Elly> yeah, I believe that is uncomputable
21:48:48 <SamB_XP> yes, but does it exist?
21:48:54 <dolio> Well, it has to be unless the halting problem has become decidable. :)
21:49:44 <monochrom> exists non-constructively, doesn't exist constructively.
21:50:09 <SamB_XP> yes. and I've got distinctly constructivist leanings ;-)
21:50:58 <monochrom> It comes down to: when you run Coq, do you load up the "classical" module? :)
21:51:22 <SamB_XP> ... I switched to Agda
21:52:03 <vixey> Have you proved strong normalization for STLC?
21:52:13 <SamB_XP> not yet
21:52:14 <vixey> I haven't done that yet
21:52:16 <vixey> ok
21:52:53 <SamB_XP> I'm not sure I've even figured out a reasonable encoding for the concept of strong normalization
21:53:33 <SamB_XP> and I'm certain I don't know what representation to use for the terms of the STLC that will not be too much of a pain...
21:54:11 <SamB_XP> anyway, I'm going to go to bed...
21:54:55 <dolio> Define an equivalence relation on lambda terms, and then provide an implementation for decidable equality?
21:55:05 <dolio> The libraries have something for that, don't they?
21:57:24 * dolio once again has to kill emacs as it hangs displaying unicode agda source.
21:57:36 <monochrom> haha
21:58:00 <glguy> can god define a number he can not compute?
21:58:09 <mar77a> yes
21:58:17 <wolgo> @src splitAt
21:58:17 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
21:58:27 <newsham> how can sun(2^(-i)) for i == machine halts exist if there are some i's for which the machine neither halts nor doesnt halt?
21:59:13 <dolio> How can you not halt, and not not-halt?
21:59:31 <newsham> nevermind, i just slapped myself for that thought
22:00:34 <dolio> Maybe quantum turing machines can do that.
22:00:47 <dolio> They're in a superposition of halting and not halting.
22:01:00 <mmorrow> and killing kittays
22:08:58 <hpaste>  obk pasted "Type class problem" at http://hpaste.org/7868
22:09:46 <obk> Anyone has any idea why this doesn't work, but it does work replacing the 2 with 2::Int ?
22:10:21 <dolio> It's potentially ambiguous.
22:10:49 <dolio> The compiler can't tell that Int is the only instance of C.
22:10:58 <obk> I sort of get that
22:11:15 <obk> Is there a way to tell it that?
22:11:30 <dolio> Not that I know of.
22:12:01 <obk> Ok, is there another type other than Int I could put in there instead then, so it will work for an unadorned '2'?
22:12:38 <dolio> In where?
22:13:04 <obk> In the definition of 'data I'
22:13:18 <obk> I just want to be able to wrap the value 2 somehow
22:13:30 <obk> Alas, "Num" isn't a type...
22:13:35 <dolio> Hmm, I don't think so.
22:14:02 <dolio> Why do you need the class C if only Int is going to be a member?
22:14:31 <obk> Actually, it will also have an 'S String' member
22:14:46 <obk> I need to write a function that takes either an integer or a string as an argument
22:14:53 <obk> And do different things accordingly
22:15:19 <obk> The tricky part is that the call needs to be "clean", that is either f 2 or f "s"
22:15:55 <geezusfreeek> obk: by "clean" you mean without type annotation?
22:15:59 <obk> Yes
22:16:35 <geezusfreeek> i don't think that will be possible unless you can avoid using numeric literals
22:16:52 <obk> Alas, using numeric literals is the whole point :-(
22:17:56 <Trinithis> print $ f (2 :: Int) ??
22:17:57 <geezusfreeek> perhaps instead of a class you could just have two specialized functions?
22:18:10 <obk> Both are good advice
22:18:13 <geezusfreeek> Trinithis: he wants without the annotation though
22:18:35 <obk> Here's my problem - I have a BNF file which is actuallt Haskell code.
22:19:01 <obk> It is inclued into two modules, one actually is a working parser (using one set of definitions)
22:19:13 <obk> The other creates an in-memory grammer to play with
22:19:43 <obk> In the BNF I havce stuff like 'foo `repeat` 2' and 'foo `repeat` "n"'
22:19:53 <obk> Well actuallt 'foo `repeat` n'
22:20:12 <obk> But I can play with the variable 'n' to become "n" :)
22:20:52 <obk> I can go over the syntax and have two repeats, one for reapeatConstant and one for repeatByParameter, I suppose...
22:21:07 <obk> Path of least resistance...
22:21:36 <geezusfreeek> obk: i would venture a guess that unless you foresee needing to implement more instances later, a type class wouldn'
22:21:42 <geezusfreeek> *wouldn't help much anyway
22:21:48 <geezusfreeek> besides a slight bit of cleanliness
22:21:57 <obk> I suppose so
22:23:00 <geezusfreeek> you could perhaps use template haskell if the look is important enough
22:23:09 <geezusfreeek> but i don't know how much that fits what you are trying to do anyway
22:23:17 <dolio> Heh.
22:23:18 <geezusfreeek> *how well
22:23:31 <dolio> Template Haskell's going to look really nice. :)
22:24:20 <obk> I don't think I want to delve that deep into this
22:24:31 <obk> I'll just use two different function names.
22:24:42 <geezusfreeek> that's what i would do too ;)
22:24:43 * obk has enough tricky code to write as it is ;-)
22:27:28 <wolgo> I feel like solving this test with: splitlist x = splitAt ((length x) `div` 2) x is cheap. I know there has to be a recursive way to do it.
22:28:06 <vixey> haha
22:28:17 <vixey> well
22:28:20 <wolgo> the challenge is to split a list into a pair using a function that I have defined instead of splitAt
22:28:25 <vixey> length has to go over the entire list
22:28:32 <vixey> the split at has to go over it too
22:29:16 <wolgo> splitAt 3 [1,2,3,4,5,6] works but it says I cannot just use split
22:29:32 <wolgo> err splitAt
22:29:52 <wolgo> this is a stupid test
22:30:02 <wolgo> It doesn't do anythin
22:30:03 <wolgo> g
22:30:05 <vixey> I can't see how to do it
22:30:52 <wolgo> except for define a function and use splitAt explicitly but the test says to not use splitAt explicitly, then I look at the answer and IT IS THE SAME DAMN CODE I HAVE
22:31:01 <Cale> What's the problem?
22:31:07 <wolgo> no problem
22:31:14 <wolgo> well yes a problem
22:31:16 <vixey> wolgo: I actually feel the exact same way about some code I'm writing
22:31:23 <Cale> You want to split a list into two parts which are of equal length?
22:31:28 <Trinithis> make a newtype that encapsulates the list length of a list
22:31:29 <vixey> (although it's a totally different problem)
22:31:46 <vixey> oh it doesn't have to be in half?
22:31:50 <wolgo> yes
22:31:56 <vixey> it just have to be into two partitions of equal length?
22:32:00 <wolgo> yes
22:32:08 * vixey wont give it away then :P=
22:32:25 <wolgo> mine works
22:32:44 <Trinithis> wolgo, what is the excersise source?
22:32:47 <vixey> that reminds me of data ZebraList a b = Nil | Cons a (ZebraList b a)
22:32:50 <wolgo> @type partition
22:32:52 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
22:32:56 <wolgo> ...
22:33:19 <wolgo> I am using programming in haskell
22:33:28 <wolgo> lets read the question again
22:33:30 <wolgo> brb
22:33:31 <Trinithis> vixey: ZebraList makes use of phantom types right?
22:33:37 <wolgo> oh jesus
22:33:40 <wolgo> I am an idiot
22:33:45 <vixey> Trinithis: I think it's called nested types
22:34:02 <dolio> They aren't phantom.
22:34:14 <wolgo> It says "using library functions split a list in two equal parts, assume the list will be of even length"
22:34:15 <wolgo> nm
22:34:18 <vixey> It's cool because like [1,"foo",3,"bar"] :: ZebraList Int String
22:34:25 * wolgo needs to learn how to read
22:34:31 <Trinithis> oh
22:34:36 <vixey> (`mod`syntax)
22:34:41 <wolgo> that is still a stupid test
22:34:43 <Trinithis> i misread the cons
22:34:47 * wolgo maintains his stance
22:34:55 <wolgo> err exercise
22:35:34 <Trinithis> if the cons were : Cons a (ZebraList a b).... would that be phantomed?
22:36:56 <Cale> yeah, the b would be a phantom type parameter then
22:37:01 <Trinithis> k
22:37:29 <vixey> these ones are really fun to think about
22:38:07 <vixey> http://blog.jbapple.com/2008/02/name-that-type-nested-types-edition.html
22:38:09 <lambdabot> Title: Everyone Else is Crazy: Name that type! (nested types edition), http://tinyurl.com/5p7chm
22:44:25 <glguy> http://pastie.caboo.se/202956
22:44:26 <lambdabot> Title: #202956 - Pastie
22:45:00 <glguy> oops, wrong channel, (but yikes :))
22:45:11 <Cale> guards!
22:45:47 <Trinithis> to the asylum.
22:47:41 <glguy> Cale: the channel guard tend to take a while to respond ;)
22:48:41 <Cale> hehe, actually I was referring to the structure of your pasted code ;)
22:48:56 <Cale> g'night
22:49:09 <glguy> ciao
23:06:10 <Trinithis> is there a reason to use Hugs since I already have ghci?
23:11:34 <Armored_Azrael> Hey, how do I paralellize a list of IO operations
23:11:52 <Armored_Azrael> i.e. I essentially want a version of map that works on IO monadic actions, in parallel
23:12:13 <Trinithis> mapM?
23:12:38 <Armored_Azrael> mapM is not parallel though, right?
23:12:42 <Trinithis> oh
23:12:52 <Armored_Azrael> I'm essentially looking for parMapM
23:13:02 <edwardk> vixey: heh i needed a type very much like the zebra list for encoding coproducts of ideal monads
23:16:50 <wolgo> @go scalar product
23:16:51 <lambdabot> http://hyperphysics.phy-astr.gsu.edu/Hbase/vsca.html
23:16:51 <lambdabot> Title: Scalar Product of Vectors
23:18:32 <Trinithis> wolgo: k <v1,v2,...vN> = <kv1, kv2, ..., kvN>
23:19:05 <Trinithis> kind of like: map (*k) [v1,v2,...]
23:19:51 <roconnor> > map (*k) [a,b]
23:19:54 <lambdabot>  [a * k,b * k]
23:19:55 <wolgo> so multiplying two lists
23:20:04 <Trinithis> no
23:20:08 <wolgo> oh
23:20:16 <wolgo> just multiplying k by a list element?
23:20:22 <edwardk> one list and a value
23:20:29 <wolgo> oh ok
23:20:38 <Trinithis> each element in the list gets multiplied by that value
23:20:50 <Trinithis> map (*5) [1,2,3]
23:20:53 <Trinithis> > map (*5) [1,2,3]
23:20:54 <lambdabot>  [5,10,15]
23:20:55 <wolgo> yeah
23:20:57 <wolgo> ok
23:20:58 <wolgo> cool
23:21:12 <wolgo> so map makes calculating scalar products quick :)
23:21:12 <[Justice]> scalarProduct k = map (k *)
23:21:49 <wolgo> They appear to be used in geometry...
23:22:05 <Trinithis> to multiply two lists you can: [x*y | x <- xs, y <- ys]
23:22:12 <mmorrow> scalarProduct = map . (*)
23:22:23 <wolgo> I only heard the term about 5 minutes ago while working through these exercises
23:22:25 <[Justice]> even better
23:22:35 <mmorrow> (just cuz)
23:22:47 <wolgo> that is point free right?
23:22:58 <Trinithis> yea
23:23:00 <wolgo> and it works because of currying right?
23:23:13 <[Justice]> that was a point-free-ness contest
23:23:51 <Trinithis> currying is one way to do point free
23:23:54 <hpaste>  (anonymous) pasted "is there a better way to check if a number is a perfect square?" at http://hpaste.org/7869
23:24:41 <wolgo> man this language is cool
23:24:49 <ripplepay> http://hpaste.org/7869 was me...
23:25:04 <wolgo> @go perfect square
23:25:05 <lambdabot> http://en.wikipedia.org/wiki/Perfect_square
23:25:05 <lambdabot> Title: Perfect square - Wikipedia, the free encyclopedia
23:25:24 <Trinithis> ripplepay: (x :: Float) the float annotation is redundant fyi
23:29:45 <mmorrow> Justice: heh
23:38:02 <ripplepay> perfectSquare2 x = (snd . properFraction . sqrt ) x == 0.0
23:38:06 <ripplepay> guess that works too.
23:38:34 <Trinithis> @src properFraction
23:38:34 <lambdabot> Source not found. I am sorry.
23:39:33 <Trinithis> @ty sqrt
23:39:35 <lambdabot> forall a. (Floating a) => a -> a
23:39:42 <Trinithis> :t properFraction
23:39:44 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
23:47:24 <ddarius> Armored_Azrael: You'd need to explicitly fork a thread for each computation and gather the results.
23:49:11 <Armored_Azrael> ddarius: There's no clever monad transform that can be used with parMap from Control.Parallel.Strategies
23:49:14 <Armored_Azrael> ?
23:49:42 <cjs> The Hugs prelude types fmap as "fmap :: (a -> b) -> (f a -> f b)"
23:49:45 <cjs> :t fmap
23:49:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:50:03 <cjs> Do the extra parens at the end have any significance, or even make any sense?
23:50:16 <edwardk> @type parMap
23:50:17 <ddarius> Control.Parallel is only for -evaluating- things in parallel.  If you execute arbitrary IO actions "in parallel" you'll have a non-deterministic result, i.e. true concurrency.
23:50:18 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
23:51:14 <Trinithis> cjs: they are left associative
23:51:20 <Armored_Azrael> OK. Just to make sure, before I go write an explicit threading implementation for it, there's nothing that gives me something like
23:51:28 <Armored_Azrael> parMapIO :: (a -> IO b) -> [a] -> IO [b]
23:51:45 <cjs> Trinithis, so what does that change?
23:51:46 <dobblego> ?type parMap
23:51:47 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
23:52:00 <Trinithis> it means that the defintions are equivalent
23:52:02 <ddarius> Armored_Azrael: Not in Control.Parallel.  There may be in Control.Concurrent, but I don't think so.  It's not that complicated to implement.
23:52:42 <ddarius> The arrow type constructor (->) is right associative.
23:52:48 <Trinithis> though adding the extra parenthesis can add a level of abstraction semantics-wise
23:54:53 <cjs> So it's just trying to say something to the programmer about how he might think about this function?
23:54:59 <Trinithis> yea
23:55:06 <cjs> Ok, I get that.
23:55:25 <Trinithis> consider(>=>)
23:55:33 <Trinithis> :t (>=>)
23:55:35 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
23:56:13 <Trinithis> notice there are no parens for (a -> m c),  but generally, you would want to think of it as returinging a function
23:56:34 <Trinithis> , which the source code (at hoogle) hints at.
23:56:47 <dobblego> ?type \f g a -> return a >>= f >>= g
23:56:50 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => (a -> m a1) -> (a1 -> m b) -> a -> m b
23:56:51 <Armored_Azrael> runInBoundThread looks like it can help do what I want, but I have a question about its behavior--it claims "runInBoundThread doesn't finish until the IO computation finishes." but it doesn't seem to make any sense, as it returns an (IO a)
23:57:22 <Trinithis> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html#%3E%3D%3E
23:57:23 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2c5ecq
23:57:32 <Deewiant> ?ty \f g a -> f a >>= g
23:57:34 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
23:57:41 <dobblego> yeah that :)
23:57:52 <ddarius> Armored_Azrael: Unless you're doing FFI or something like that (and even then only in pretty particular cases), runInBoundThread is not what you want.
23:58:16 <Armored_Azrael> ddarius: OK, I was guessing based on type signature
23:58:38 <Armored_Azrael> ddarius: Because everything else in Control.Concurrent does not allow the thread to have a return value.
23:59:08 <Trinithis> \f g -> \a -> f a >>= g
23:59:26 <Trinithis> is 'easier' to grasp the intent
23:59:42 <Trinithis> guess its all a matter of preference
